{
  "metadata": {
    "timestamp": 1736710194834,
    "page": 893,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "LukeSmithxyz/st",
      "stars": 1643,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "patches/\n.gitignore\n*.o\nst\n*.orig\n"
        },
        {
          "name": "FUNDING.yml",
          "type": "blob",
          "size": 0.0654296875,
          "content": "custom: [\"https://lukesmith.xyz/donate.html\"]\ngithub: lukesmithxyz\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.791015625,
          "content": "MIT/X Consortium License\n\n© 2014-2022 Hiltjo Posthuma <hiltjo at codemadness dot org>\n© 2018 Devin J. Pohly <djpohly at gmail dot com>\n© 2014-2017 Quentin Rameau <quinq at fifth dot space>\n© 2009-2012 Aurélien APTEL <aurelien dot aptel at gmail dot com>\n© 2008-2017 Anselm R Garbe <garbeam at gmail dot com>\n© 2012-2017 Roberto E. Vargas Caballero <k0ga at shike2 dot com>\n© 2012-2016 Christoph Lohmann <20h at r-36 dot net>\n© 2013 Eon S. Jeon <esjeon at hyunmu dot am>\n© 2013 Alexander Sedov <alex0player at gmail dot com>\n© 2013 Mark Edgar <medgar123 at gmail dot com>\n© 2013-2014 Eric Pruitt <eric.pruitt at gmail dot com>\n© 2013 Michael Forney <mforney at mforney dot org>\n© 2013-2014 Markus Teich <markus dot teich at stusta dot mhn dot de>\n© 2014-2015 Laslo Hunhold <dev at frign dot de>\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.541015625,
          "content": "# st - simple terminal\n# See LICENSE file for copyright and license details.\n.POSIX:\n\ninclude config.mk\n\nSRC = st.c x.c boxdraw.c hb.c\nOBJ = $(SRC:.c=.o)\n\nall: options st\n\noptions:\n\t@echo st build options:\n\t@echo \"CFLAGS  = $(STCFLAGS)\"\n\t@echo \"LDFLAGS = $(STLDFLAGS)\"\n\t@echo \"CC      = $(CC)\"\n\n.c.o:\n\t$(CC) $(STCFLAGS) -c $<\n\nst.o: config.h st.h win.h\nx.o: arg.h config.h st.h win.h hb.h\nhb.o: st.h\nboxdraw.o: config.h st.h boxdraw_data.h\n\n$(OBJ): config.h config.mk\n\nst: $(OBJ)\n\t$(CC) -o $@ $(OBJ) $(STLDFLAGS)\n\nclean:\n\trm -f st $(OBJ) st-$(VERSION).tar.gz *.rej *.orig *.o\n\ndist: clean\n\tmkdir -p st-$(VERSION)\n\tcp -R FAQ LEGACY TODO LICENSE Makefile README config.mk\\\n\t\tconfig.h st.info st.1 arg.h st.h win.h $(SRC)\\\n\t\tst-$(VERSION)\n\ttar -cf - st-$(VERSION) | gzip > st-$(VERSION).tar.gz\n\trm -rf st-$(VERSION)\n\ninstall: st\n\tmkdir -p $(DESTDIR)$(PREFIX)/bin\n\tcp -f st $(DESTDIR)$(PREFIX)/bin\n\tcp -f st-copyout $(DESTDIR)$(PREFIX)/bin\n\tcp -f st-urlhandler $(DESTDIR)$(PREFIX)/bin\n\tchmod 755 $(DESTDIR)$(PREFIX)/bin/st\n\tchmod 755 $(DESTDIR)$(PREFIX)/bin/st-copyout\n\tchmod 755 $(DESTDIR)$(PREFIX)/bin/st-urlhandler\n\tmkdir -p $(DESTDIR)$(MANPREFIX)/man1\n\tsed \"s/VERSION/$(VERSION)/g\" < st.1 > $(DESTDIR)$(MANPREFIX)/man1/st.1\n\tchmod 644 $(DESTDIR)$(MANPREFIX)/man1/st.1\n\ttic -sx st.info\n\t@echo Please see the README file regarding the terminfo entry of st.\n\nuninstall:\n\trm -f $(DESTDIR)$(PREFIX)/bin/st\n\trm -f $(DESTDIR)$(PREFIX)/bin/st-copyout\n\trm -f $(DESTDIR)$(PREFIX)/bin/st-urlhandler\n\trm -f $(DESTDIR)$(MANPREFIX)/man1/st.1\n\n.PHONY: all options clean dist install uninstall\n"
        },
        {
          "name": "PKGBUILD",
          "type": "blob",
          "size": 1.1396484375,
          "content": "# Maintainer:\n\npkgname=st-luke-git\n_pkgname=st\npkgver=0.8.2.r1062.2087ab9\npkgrel=1\nepoch=1\npkgdesc=\"Luke's simple (suckless) terminal with vim-bindings, transparency, xresources, etc. \"\nurl='https://github.com/LukeSmithxyz/st'\narch=('i686' 'x86_64')\nlicense=('MIT')\noptions=('zipman')\ndepends=('libxft')\nmakedepends=('ncurses' 'libxext' 'git')\noptdepends=('dmenu: feed urls to dmenu')\nsource=(git+https://github.com/LukeSmithxyz/st)\nsha1sums=('SKIP')\n\nprovides=(\"${_pkgname}\")\nconflicts=(\"${_pkgname}\")\n\npkgver() {\n\tcd \"${_pkgname}\"\n\tprintf \"%s.r%s.%s\" \"$(awk '/^VERSION =/ {print $3}' config.mk)\" \\\n\t\t\"$(git rev-list --count HEAD)\" \"$(git rev-parse --short HEAD)\"\n}\n\nprepare() {\n\tcd $srcdir/${_pkgname}\n\t# skip terminfo which conflicts with ncurses\n\tsed -i '/tic /d' Makefile\n}\n\nbuild() {\n\tcd \"${_pkgname}\"\n\tmake X11INC=/usr/include/X11 X11LIB=/usr/lib/X11\n}\n\npackage() {\n\tcd \"${_pkgname}\"\n\tmake PREFIX=/usr DESTDIR=\"${pkgdir}\" install\n\tinstall -Dm644 LICENSE \"${pkgdir}/usr/share/licenses/${pkgname}/LICENSE\"\n\tinstall -Dm644 README.md \"${pkgdir}/usr/share/doc/${pkgname}/README.md\"\n\tinstall -Dm644 Xdefaults \"${pkgdir}/usr/share/doc/${pkgname}/Xdefaults.example\"\n}\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8154296875,
          "content": "# Luke's build of st - the simple (suckless) terminal\n\nThe [suckless terminal (st)](https://st.suckless.org/) with some additional\nfeatures that make it literally the best terminal emulator ever:\n\n## Unique features (using dmenu)\n\n+ **follow urls** by pressing `alt-l`\n+ **copy urls** in the same way with `alt-y`\n+ **copy the output of commands** with `alt-o`\n\n## Bindings for\n\n+ **scrollback** with `alt-↑/↓` or `alt-pageup/down` or `shift` while scrolling the\n  mouse.\n+ OR **vim-bindings**: scroll up/down in history with `alt-k` and `alt-j`.\n  Faster with `alt-u`/`alt-d`.\n+ **zoom/change font size**: same bindings as above, but holding down shift as\n  well. `alt-home` returns to default\n+ **copy text** with `alt-c`, **paste** is `alt-v` or `shift-insert`\n\n## Pretty stuff\n\n+ Compatibility with `Xresources` and `pywal` for dynamic colors.\n+ Default [gruvbox](https://github.com/morhetz/gruvbox) colors otherwise.\n+ Transparency/alpha, which is also adjustable from your `Xresources`.\n+ Default font is system \"mono\" at 14pt, meaning the font will match your\n  system font.\n\n## Other st patches\n\n+ Boxdraw\n+ Ligatures\n+ font2\n+ updated to latest version 0.8.5\n\n## Installation for newbs\n\nYou should have xlib header files and libharfbuzz build files installed.\n\n```\ngit clone https://github.com/LukeSmithxyz/st\ncd st\nsudo make install\n```\n\nObviously, `make` is required to build. `fontconfig` is required for the\ndefault build, since it asks `fontconfig` for your system monospace font. It\nmight be obvious, but `libX11` and `libXft` are required as well. Chances are,\nyou have all of this installed already.\n\nOn OpenBSD, be sure to edit `config.mk` first and remove `-lrt` from the\n`$LIBS` before compiling.\n\nBe sure to have a composite manager (`xcompmgr`, `picom`, etc.) running if you\nwant transparency.\n\n## How to configure dynamically with Xresources\n\nFor many key variables, this build of `st` will look for X settings set in\neither `~/.Xdefaults` or `~/.Xresources`. You must run `xrdb` on one of these\nfiles to load the settings.\n\nFor example, you can define your desired fonts, transparency or colors:\n\n```\n*.font:\tLiberation Mono:pixelsize=12:antialias=true:autohint=true;\n*.alpha: 0.9\n*.color0: #111\n...\n```\n\nThe `alpha` value (for transparency) goes from `0` (transparent) to `1`\n(opaque). There is an example `Xdefaults` file in this respository.\n\n### Colors\n\nTo be clear about the color settings:\n\n- This build will use gruvbox colors by default and as a fallback.\n- If there are Xresources colors defined, those will take priority.\n- But if `wal` has run in your session, its colors will take priority.\n\nNote that when you run `wal`, it will negate the transparency of existing windows, but new windows will continue with the previously defined transparency.\n\n## Contact\n\n- Luke Smith <luke@lukesmith.xyz>\n- [https://lukesmith.xyz](https://lukesmith.xyz)\n"
        },
        {
          "name": "Xdefaults",
          "type": "blob",
          "size": 2.9541015625,
          "content": "!! Transparency (0-1):\nst.alpha: 0.92\nst.alphaOffset: 0.3\n\n!! Set a default font and font size as below:\nst.font: Monospace-11;\n\n! st.termname: st-256color\n! st.borderpx: 2\n\n!! Set the background, foreground and cursor colors as below:\n\n!! gruvbox:\n*.color0: #1d2021\n*.color1: #cc241d\n*.color2: #98971a\n*.color3: #d79921\n*.color4: #458588\n*.color5: #b16286\n*.color6: #689d6a\n*.color7: #a89984\n*.color8: #928374\n*.color9: #fb4934\n*.color10: #b8bb26\n*.color11: #fabd2f\n*.color12: #83a598\n*.color13: #d3869b\n*.color14: #8ec07c\n*.color15: #ebdbb2\n*.background: #282828\n*.foreground: white\n*.cursorColor: white\n\n/* /1* !! gruvbox light: *1/ */\n/* *.color0: #fbf1c7 */\n/* *.color1: #cc241d */\n/* *.color2: #98971a */\n/* *.color3: #d79921 */\n/* *.color4: #458588 */\n/* *.color5: #b16286 */\n/* *.color6: #689d6a */\n/* *.color7: #7c6f64 */\n/* *.color8: #928374 */\n/* *.color9: #9d0006 */\n/* *.color10: #79740e */\n/* *.color11: #b57614 */\n/* *.color12: #076678 */\n/* *.color13: #8f3f71 */\n/* *.color14: #427b58 */\n/* *.color15: #3c3836 */\n/* *.background: #fbf1c7 */\n/* *.foreground: #282828 */\n/* *.cursorColor: #282828 */\n\n/* !! brogrammer: */\n/* *.foreground:  #d6dbe5 */\n/* *.background:  #131313 */\n/* *.color0:      #1f1f1f */\n/* *.color8:      #d6dbe5 */\n/* *.color1:      #f81118 */\n/* *.color9:      #de352e */\n/* *.color2:      #2dc55e */\n/* *.color10:     #1dd361 */\n/* *.color3:      #ecba0f */\n/* *.color11:     #f3bd09 */\n/* *.color4:      #2a84d2 */\n/* *.color12:     #1081d6 */\n/* *.color5:      #4e5ab7 */\n/* *.color13:     #5350b9 */\n/* *.color6:      #1081d6 */\n/* *.color14:     #0f7ddb */\n/* *.color7:      #d6dbe5 */\n/* *.color15:     #ffffff */\n/* *.colorBD:     #d6dbe5 */\n\n/* ! base16 */\n/* *.color0:       #181818 */\n/* *.color1:       #ab4642 */\n/* *.color2:       #a1b56c */\n/* *.color3:       #f7ca88 */\n/* *.color4:       #7cafc2 */\n/* *.color5:       #ba8baf */\n/* *.color6:       #86c1b9 */\n/* *.color7:       #d8d8d8 */\n/* *.color8:       #585858 */\n/* *.color9:       #ab4642 */\n/* *.color10:      #a1b56c */\n/* *.color11:      #f7ca88 */\n/* *.color12:      #7cafc2 */\n/* *.color13:      #ba8baf */\n/* *.color14:      #86c1b9 */\n/* *.color15:      #f8f8f8 */\n\n/* !! solarized */\n/* *.color0:\t#073642 */\n/* *.color1:\t#dc322f */\n/* *.color2:\t#859900 */\n/* *.color3:\t#b58900 */\n/* *.color4:\t#268bd2 */\n/* *.color5:\t#d33682 */\n/* *.color6:\t#2aa198 */\n/* *.color7:\t#eee8d5 */\n/* *.color9:\t#cb4b16 */\n/* *.color8:\t#fdf6e3 */\n/* *.color10:\t#586e75 */\n/* *.color11:\t#657b83 */\n/* *.color12:\t#839496 */\n/* *.color13:\t#6c71c4 */\n/* *.color14:\t#93a1a1 */\n/* *.color15:\t#fdf6e3 */\n\n/* !! xterm */\n/* *.color0:   #000000 */\n/* *.color1:   #cd0000 */\n/* *.color2:   #00cd00 */\n/* *.color3:   #cdcd00 */\n/* *.color4:   #0000cd */\n/* *.color5:   #cd00cd */\n/* *.color6:   #00cdcd */\n/* *.color7:   #e5e5e5 */\n/* *.color8:   #4d4d4d */\n/* *.color9:   #ff0000 */\n/* *.color10:  #00ff00 */\n/* *.color11:  #ffff00 */\n/* *.color12:  #0000ff */\n/* *.color13:  #ff00ff */\n/* *.color14:  #00ffff */\n/* *.color15:  #aabac8 */\n"
        },
        {
          "name": "arg.h",
          "type": "blob",
          "size": 1.01171875,
          "content": "/*\n * Copy me if you can.\n * by 20h\n */\n\n#ifndef ARG_H__\n#define ARG_H__\n\nextern char *argv0;\n\n/* use main(int argc, char *argv[]) */\n#define ARGBEGIN\tfor (argv0 = *argv, argv++, argc--;\\\n\t\t\t\t\targv[0] && argv[0][0] == '-'\\\n\t\t\t\t\t&& argv[0][1];\\\n\t\t\t\t\targc--, argv++) {\\\n\t\t\t\tchar argc_;\\\n\t\t\t\tchar **argv_;\\\n\t\t\t\tint brk_;\\\n\t\t\t\tif (argv[0][1] == '-' && argv[0][2] == '\\0') {\\\n\t\t\t\t\targv++;\\\n\t\t\t\t\targc--;\\\n\t\t\t\t\tbreak;\\\n\t\t\t\t}\\\n\t\t\t\tint i_;\\\n\t\t\t\tfor (i_ = 1, brk_ = 0, argv_ = argv;\\\n\t\t\t\t\t\targv[0][i_] && !brk_;\\\n\t\t\t\t\t\ti_++) {\\\n\t\t\t\t\tif (argv_ != argv)\\\n\t\t\t\t\t\tbreak;\\\n\t\t\t\t\targc_ = argv[0][i_];\\\n\t\t\t\t\tswitch (argc_)\n\n#define ARGEND\t\t\t}\\\n\t\t\t}\n\n#define ARGC()\t\targc_\n\n#define EARGF(x)\t((argv[0][i_+1] == '\\0' && argv[1] == NULL)?\\\n\t\t\t\t((x), abort(), (char *)0) :\\\n\t\t\t\t(brk_ = 1, (argv[0][i_+1] != '\\0')?\\\n\t\t\t\t\t(&argv[0][i_+1]) :\\\n\t\t\t\t\t(argc--, argv++, argv[0])))\n\n#define ARGF()\t\t((argv[0][i_+1] == '\\0' && argv[1] == NULL)?\\\n\t\t\t\t(char *)0 :\\\n\t\t\t\t(brk_ = 1, (argv[0][i_+1] != '\\0')?\\\n\t\t\t\t\t(&argv[0][i_+1]) :\\\n\t\t\t\t\t(argc--, argv++, argv[0])))\n\n#endif\n"
        },
        {
          "name": "boxdraw.c",
          "type": "blob",
          "size": 6.0908203125,
          "content": "/*\n * Copyright 2018 Avi Halachmi (:avih) avihpit@yahoo.com https://github.com/avih\n * MIT/X Consortium License\n */\n\n#include <X11/Xft/Xft.h>\n#include \"st.h\"\n#include \"boxdraw_data.h\"\n\n/* Rounded non-negative integers division of n / d  */\n#define DIV(n, d) (((n) + (d) / 2) / (d))\n\nstatic Display *xdpy;\nstatic Colormap xcmap;\nstatic XftDraw *xd;\nstatic Visual *xvis;\n\nstatic void drawbox(int, int, int, int, XftColor *, XftColor *, ushort);\nstatic void drawboxlines(int, int, int, int, XftColor *, ushort);\n\n/* public API */\n\nvoid\nboxdraw_xinit(Display *dpy, Colormap cmap, XftDraw *draw, Visual *vis)\n{\n\txdpy = dpy; xcmap = cmap; xd = draw, xvis = vis;\n}\n\nint\nisboxdraw(Rune u)\n{\n\tRune block = u & ~0xff;\n\treturn (boxdraw && block == 0x2500 && boxdata[(uint8_t)u]) ||\n\t       (boxdraw_braille && block == 0x2800);\n}\n\n/* the \"index\" is actually the entire shape data encoded as ushort */\nushort\nboxdrawindex(const Glyph *g)\n{\n\tif (boxdraw_braille && (g->u & ~0xff) == 0x2800)\n\t\treturn BRL | (uint8_t)g->u;\n\tif (boxdraw_bold && (g->mode & ATTR_BOLD))\n\t\treturn BDB | boxdata[(uint8_t)g->u];\n\treturn boxdata[(uint8_t)g->u];\n}\n\nvoid\ndrawboxes(int x, int y, int cw, int ch, XftColor *fg, XftColor *bg,\n          const XftGlyphFontSpec *specs, int len)\n{\n\tfor ( ; len-- > 0; x += cw, specs++)\n\t\tdrawbox(x, y, cw, ch, fg, bg, (ushort)specs->glyph);\n}\n\n/* implementation */\n\nvoid\ndrawbox(int x, int y, int w, int h, XftColor *fg, XftColor *bg, ushort bd)\n{\n\tushort cat = bd & ~(BDB | 0xff);  /* mask out bold and data */\n\tif (bd & (BDL | BDA)) {\n\t\t/* lines (light/double/heavy/arcs) */\n\t\tdrawboxlines(x, y, w, h, fg, bd);\n\n\t} else if (cat == BBD) {\n\t\t/* lower (8-X)/8 block */\n\t\tint d = DIV((uint8_t)bd * h, 8);\n\t\tXftDrawRect(xd, fg, x, y + d, w, h - d);\n\n\t} else if (cat == BBU) {\n\t\t/* upper X/8 block */\n\t\tXftDrawRect(xd, fg, x, y, w, DIV((uint8_t)bd * h, 8));\n\n\t} else if (cat == BBL) {\n\t\t/* left X/8 block */\n\t\tXftDrawRect(xd, fg, x, y, DIV((uint8_t)bd * w, 8), h);\n\n\t} else if (cat == BBR) {\n\t\t/* right (8-X)/8 block */\n\t\tint d = DIV((uint8_t)bd * w, 8);\n\t\tXftDrawRect(xd, fg, x + d, y, w - d, h);\n\n\t} else if (cat == BBQ) {\n\t\t/* Quadrants */\n\t\tint w2 = DIV(w, 2), h2 = DIV(h, 2);\n\t\tif (bd & TL)\n\t\t\tXftDrawRect(xd, fg, x, y, w2, h2);\n\t\tif (bd & TR)\n\t\t\tXftDrawRect(xd, fg, x + w2, y, w - w2, h2);\n\t\tif (bd & BL)\n\t\t\tXftDrawRect(xd, fg, x, y + h2, w2, h - h2);\n\t\tif (bd & BR)\n\t\t\tXftDrawRect(xd, fg, x + w2, y + h2, w - w2, h - h2);\n\n\t} else if (bd & BBS) {\n\t\t/* Shades - data is 1/2/3 for 25%/50%/75% alpha, respectively */\n\t\tint d = (uint8_t)bd;\n\t\tXftColor xfc;\n\t\tXRenderColor xrc = { .alpha = 0xffff };\n\n\t\txrc.red = DIV(fg->color.red * d + bg->color.red * (4 - d), 4);\n\t\txrc.green = DIV(fg->color.green * d + bg->color.green * (4 - d), 4);\n\t\txrc.blue = DIV(fg->color.blue * d + bg->color.blue * (4 - d), 4);\n\n\t\tXftColorAllocValue(xdpy, xvis, xcmap, &xrc, &xfc);\n\t\tXftDrawRect(xd, &xfc, x, y, w, h);\n\t\tXftColorFree(xdpy, xvis, xcmap, &xfc);\n\n\t} else if (cat == BRL) {\n\t\t/* braille, each data bit corresponds to one dot at 2x4 grid */\n\t\tint w1 = DIV(w, 2);\n\t\tint h1 = DIV(h, 4), h2 = DIV(h, 2), h3 = DIV(3 * h, 4);\n\n\t\tif (bd & 1)   XftDrawRect(xd, fg, x, y, w1, h1);\n\t\tif (bd & 2)   XftDrawRect(xd, fg, x, y + h1, w1, h2 - h1);\n\t\tif (bd & 4)   XftDrawRect(xd, fg, x, y + h2, w1, h3 - h2);\n\t\tif (bd & 8)   XftDrawRect(xd, fg, x + w1, y, w - w1, h1);\n\t\tif (bd & 16)  XftDrawRect(xd, fg, x + w1, y + h1, w - w1, h2 - h1);\n\t\tif (bd & 32)  XftDrawRect(xd, fg, x + w1, y + h2, w - w1, h3 - h2);\n\t\tif (bd & 64)  XftDrawRect(xd, fg, x, y + h3, w1, h - h3);\n\t\tif (bd & 128) XftDrawRect(xd, fg, x + w1, y + h3, w - w1, h - h3);\n\n\t}\n}\n\nvoid\ndrawboxlines(int x, int y, int w, int h, XftColor *fg, ushort bd)\n{\n\t/* s: stem thickness. width/8 roughly matches underscore thickness. */\n\t/* We draw bold as 1.5 * normal-stem and at least 1px thicker.      */\n\t/* doubles draw at least 3px, even when w or h < 3. bold needs 6px. */\n\tint mwh = MIN(w, h);\n\tint base_s = MAX(1, DIV(mwh, 8));\n\tint bold = (bd & BDB) && mwh >= 6;  /* possibly ignore boldness */\n\tint s = bold ? MAX(base_s + 1, DIV(3 * base_s, 2)) : base_s;\n\tint w2 = DIV(w - s, 2), h2 = DIV(h - s, 2);\n\t/* the s-by-s square (x + w2, y + h2, s, s) is the center texel.    */\n\t/* The base length (per direction till edge) includes this square.  */\n\n\tint light = bd & (LL | LU | LR | LD);\n\tint double_ = bd & (DL | DU | DR | DD);\n\n\tif (light) {\n\t\t/* d: additional (negative) length to not-draw the center   */\n\t\t/* texel - at arcs and avoid drawing inside (some) doubles  */\n\t\tint arc = bd & BDA;\n\t\tint multi_light = light & (light - 1);\n\t\tint multi_double = double_ & (double_ - 1);\n\t\t/* light crosses double only at DH+LV, DV+LH (ref. shapes)  */\n\t\tint d = arc || (multi_double && !multi_light) ? -s : 0;\n\n\t\tif (bd & LL)\n\t\t\tXftDrawRect(xd, fg, x, y + h2, w2 + s + d, s);\n\t\tif (bd & LU)\n\t\t\tXftDrawRect(xd, fg, x + w2, y, s, h2 + s + d);\n\t\tif (bd & LR)\n\t\t\tXftDrawRect(xd, fg, x + w2 - d, y + h2, w - w2 + d, s);\n\t\tif (bd & LD)\n\t\t\tXftDrawRect(xd, fg, x + w2, y + h2 - d, s, h - h2 + d);\n\t}\n\n\t/* double lines - also align with light to form heavy when combined */\n\tif (double_) {\n\t\t/*\n\t\t* going clockwise, for each double-ray: p is additional length\n\t\t* to the single-ray nearer to the previous direction, and n to\n\t\t* the next. p and n adjust from the base length to lengths\n\t\t* which consider other doubles - shorter to avoid intersections\n\t\t* (p, n), or longer to draw the far-corner texel (n).\n\t\t*/\n\t\tint dl = bd & DL, du = bd & DU, dr = bd & DR, dd = bd & DD;\n\t\tif (dl) {\n\t\t\tint p = dd ? -s : 0, n = du ? -s : dd ? s : 0;\n\t\t\tXftDrawRect(xd, fg, x, y + h2 + s, w2 + s + p, s);\n\t\t\tXftDrawRect(xd, fg, x, y + h2 - s, w2 + s + n, s);\n\t\t}\n\t\tif (du) {\n\t\t\tint p = dl ? -s : 0, n = dr ? -s : dl ? s : 0;\n\t\t\tXftDrawRect(xd, fg, x + w2 - s, y, s, h2 + s + p);\n\t\t\tXftDrawRect(xd, fg, x + w2 + s, y, s, h2 + s + n);\n\t\t}\n\t\tif (dr) {\n\t\t\tint p = du ? -s : 0, n = dd ? -s : du ? s : 0;\n\t\t\tXftDrawRect(xd, fg, x + w2 - p, y + h2 - s, w - w2 + p, s);\n\t\t\tXftDrawRect(xd, fg, x + w2 - n, y + h2 + s, w - w2 + n, s);\n\t\t}\n\t\tif (dd) {\n\t\t\tint p = dr ? -s : 0, n = dl ? -s : dr ? s : 0;\n\t\t\tXftDrawRect(xd, fg, x + w2 + s, y + h2 - p, s, h - h2 + p);\n\t\t\tXftDrawRect(xd, fg, x + w2 - s, y + h2 - n, s, h - h2 + n);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "boxdraw_data.h",
          "type": "blob",
          "size": 6.06640625,
          "content": "/*\n * Copyright 2018 Avi Halachmi (:avih) avihpit@yahoo.com https://github.com/avih\n * MIT/X Consortium License\n */\n\n/*\n * U+25XX codepoints data\n *\n * References:\n *   http://www.unicode.org/charts/PDF/U2500.pdf\n *   http://www.unicode.org/charts/PDF/U2580.pdf\n *\n * Test page:\n *   https://github.com/GNOME/vte/blob/master/doc/boxes.txt\n */\n\n/* Each shape is encoded as 16-bits. Higher bits are category, lower are data */\n/* Categories (mutually exclusive except BDB): */\n/* For convenience, BDL/BDA/BBS/BDB are 1 bit each, the rest are enums */\n#define BDL (1<<8)   /* Box Draw Lines (light/double/heavy) */\n#define BDA (1<<9)   /* Box Draw Arc (light) */\n\n#define BBD (1<<10)  /* Box Block Down (lower) X/8 */\n#define BBL (2<<10)  /* Box Block Left X/8 */\n#define BBU (3<<10)  /* Box Block Upper X/8 */\n#define BBR (4<<10)  /* Box Block Right X/8 */\n#define BBQ (5<<10)  /* Box Block Quadrants */\n#define BRL (6<<10)  /* Box Braille (data is lower byte of U28XX) */\n\n#define BBS (1<<14)  /* Box Block Shades */\n#define BDB (1<<15)  /* Box Draw is Bold */\n\n/* (BDL/BDA) Light/Double/Heavy x Left/Up/Right/Down/Horizontal/Vertical      */\n/* Heavy is light+double (literally drawing light+double align to form heavy) */\n#define LL (1<<0)\n#define LU (1<<1)\n#define LR (1<<2)\n#define LD (1<<3)\n#define LH (LL+LR)\n#define LV (LU+LD)\n\n#define DL (1<<4)\n#define DU (1<<5)\n#define DR (1<<6)\n#define DD (1<<7)\n#define DH (DL+DR)\n#define DV (DU+DD)\n\n#define HL (LL+DL)\n#define HU (LU+DU)\n#define HR (LR+DR)\n#define HD (LD+DD)\n#define HH (HL+HR)\n#define HV (HU+HD)\n\n/* (BBQ) Quadrants Top/Bottom x Left/Right */\n#define TL (1<<0)\n#define TR (1<<1)\n#define BL (1<<2)\n#define BR (1<<3)\n\n/* Data for U+2500 - U+259F except dashes/diagonals */\nstatic const unsigned short boxdata[256] = {\n\t/* light lines */\n\t[0x00] = BDL + LH,       /* light horizontal */\n\t[0x02] = BDL + LV,       /* light vertical */\n\t[0x0c] = BDL + LD + LR,  /* light down and right */\n\t[0x10] = BDL + LD + LL,  /* light down and left */\n\t[0x14] = BDL + LU + LR,  /* light up and right */\n\t[0x18] = BDL + LU + LL,  /* light up and left */\n\t[0x1c] = BDL + LV + LR,  /* light vertical and right */\n\t[0x24] = BDL + LV + LL,  /* light vertical and left */\n\t[0x2c] = BDL + LH + LD,  /* light horizontal and down */\n\t[0x34] = BDL + LH + LU,  /* light horizontal and up */\n\t[0x3c] = BDL + LV + LH,  /* light vertical and horizontal */\n\t[0x74] = BDL + LL,       /* light left */\n\t[0x75] = BDL + LU,       /* light up */\n\t[0x76] = BDL + LR,       /* light right */\n\t[0x77] = BDL + LD,       /* light down */\n\n\t/* heavy [+light] lines */\n\t[0x01] = BDL + HH,\n\t[0x03] = BDL + HV,\n\t[0x0d] = BDL + HR + LD,\n\t[0x0e] = BDL + HD + LR,\n\t[0x0f] = BDL + HD + HR,\n\t[0x11] = BDL + HL + LD,\n\t[0x12] = BDL + HD + LL,\n\t[0x13] = BDL + HD + HL,\n\t[0x15] = BDL + HR + LU,\n\t[0x16] = BDL + HU + LR,\n\t[0x17] = BDL + HU + HR,\n\t[0x19] = BDL + HL + LU,\n\t[0x1a] = BDL + HU + LL,\n\t[0x1b] = BDL + HU + HL,\n\t[0x1d] = BDL + HR + LV,\n\t[0x1e] = BDL + HU + LD + LR,\n\t[0x1f] = BDL + HD + LR + LU,\n\t[0x20] = BDL + HV + LR,\n\t[0x21] = BDL + HU + HR + LD,\n\t[0x22] = BDL + HD + HR + LU,\n\t[0x23] = BDL + HV + HR,\n\t[0x25] = BDL + HL + LV,\n\t[0x26] = BDL + HU + LD + LL,\n\t[0x27] = BDL + HD + LU + LL,\n\t[0x28] = BDL + HV + LL,\n\t[0x29] = BDL + HU + HL + LD,\n\t[0x2a] = BDL + HD + HL + LU,\n\t[0x2b] = BDL + HV + HL,\n\t[0x2d] = BDL + HL + LD + LR,\n\t[0x2e] = BDL + HR + LL + LD,\n\t[0x2f] = BDL + HH + LD,\n\t[0x30] = BDL + HD + LH,\n\t[0x31] = BDL + HD + HL + LR,\n\t[0x32] = BDL + HR + HD + LL,\n\t[0x33] = BDL + HH + HD,\n\t[0x35] = BDL + HL + LU + LR,\n\t[0x36] = BDL + HR + LU + LL,\n\t[0x37] = BDL + HH + LU,\n\t[0x38] = BDL + HU + LH,\n\t[0x39] = BDL + HU + HL + LR,\n\t[0x3a] = BDL + HU + HR + LL,\n\t[0x3b] = BDL + HH + HU,\n\t[0x3d] = BDL + HL + LV + LR,\n\t[0x3e] = BDL + HR + LV + LL,\n\t[0x3f] = BDL + HH + LV,\n\t[0x40] = BDL + HU + LH + LD,\n\t[0x41] = BDL + HD + LH + LU,\n\t[0x42] = BDL + HV + LH,\n\t[0x43] = BDL + HU + HL + LD + LR,\n\t[0x44] = BDL + HU + HR + LD + LL,\n\t[0x45] = BDL + HD + HL + LU + LR,\n\t[0x46] = BDL + HD + HR + LU + LL,\n\t[0x47] = BDL + HH + HU + LD,\n\t[0x48] = BDL + HH + HD + LU,\n\t[0x49] = BDL + HV + HL + LR,\n\t[0x4a] = BDL + HV + HR + LL,\n\t[0x4b] = BDL + HV + HH,\n\t[0x78] = BDL + HL,\n\t[0x79] = BDL + HU,\n\t[0x7a] = BDL + HR,\n\t[0x7b] = BDL + HD,\n\t[0x7c] = BDL + HR + LL,\n\t[0x7d] = BDL + HD + LU,\n\t[0x7e] = BDL + HL + LR,\n\t[0x7f] = BDL + HU + LD,\n\n\t/* double [+light] lines */\n\t[0x50] = BDL + DH,\n\t[0x51] = BDL + DV,\n\t[0x52] = BDL + DR + LD,\n\t[0x53] = BDL + DD + LR,\n\t[0x54] = BDL + DR + DD,\n\t[0x55] = BDL + DL + LD,\n\t[0x56] = BDL + DD + LL,\n\t[0x57] = BDL + DL + DD,\n\t[0x58] = BDL + DR + LU,\n\t[0x59] = BDL + DU + LR,\n\t[0x5a] = BDL + DU + DR,\n\t[0x5b] = BDL + DL + LU,\n\t[0x5c] = BDL + DU + LL,\n\t[0x5d] = BDL + DL + DU,\n\t[0x5e] = BDL + DR + LV,\n\t[0x5f] = BDL + DV + LR,\n\t[0x60] = BDL + DV + DR,\n\t[0x61] = BDL + DL + LV,\n\t[0x62] = BDL + DV + LL,\n\t[0x63] = BDL + DV + DL,\n\t[0x64] = BDL + DH + LD,\n\t[0x65] = BDL + DD + LH,\n\t[0x66] = BDL + DD + DH,\n\t[0x67] = BDL + DH + LU,\n\t[0x68] = BDL + DU + LH,\n\t[0x69] = BDL + DH + DU,\n\t[0x6a] = BDL + DH + LV,\n\t[0x6b] = BDL + DV + LH,\n\t[0x6c] = BDL + DH + DV,\n\n\t/* (light) arcs */\n\t[0x6d] = BDA + LD + LR,\n\t[0x6e] = BDA + LD + LL,\n\t[0x6f] = BDA + LU + LL,\n\t[0x70] = BDA + LU + LR,\n\n\t/* Lower (Down) X/8 block (data is 8 - X) */\n\t[0x81] = BBD + 7, [0x82] = BBD + 6, [0x83] = BBD + 5, [0x84] = BBD + 4,\n\t[0x85] = BBD + 3, [0x86] = BBD + 2, [0x87] = BBD + 1, [0x88] = BBD + 0,\n\n\t/* Left X/8 block (data is X) */\n\t[0x89] = BBL + 7, [0x8a] = BBL + 6, [0x8b] = BBL + 5, [0x8c] = BBL + 4,\n\t[0x8d] = BBL + 3, [0x8e] = BBL + 2, [0x8f] = BBL + 1,\n\n\t/* upper 1/2 (4/8), 1/8 block (X), right 1/2, 1/8 block (8-X) */\n\t[0x80] = BBU + 4, [0x94] = BBU + 1,\n\t[0x90] = BBR + 4, [0x95] = BBR + 7,\n\n\t/* Quadrants */\n\t[0x96] = BBQ + BL,\n\t[0x97] = BBQ + BR,\n\t[0x98] = BBQ + TL,\n\t[0x99] = BBQ + TL + BL + BR,\n\t[0x9a] = BBQ + TL + BR,\n\t[0x9b] = BBQ + TL + TR + BL,\n\t[0x9c] = BBQ + TL + TR + BR,\n\t[0x9d] = BBQ + TR,\n\t[0x9e] = BBQ + BL + TR,\n\t[0x9f] = BBQ + BL + TR + BR,\n\n\t/* Shades, data is an alpha value in 25% units (1/4, 1/2, 3/4) */\n\t[0x91] = BBS + 1, [0x92] = BBS + 2, [0x93] = BBS + 3,\n\n\t/* U+2504 - U+250B, U+254C - U+254F: unsupported (dashes) */\n\t/* U+2571 - U+2573: unsupported (diagonals) */\n};\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 24.4892578125,
          "content": "/* See LICENSE file for copyright and license details. */\n\n/*\n * appearance\n *\n * font: see http://freedesktop.org/software/fontconfig/fontconfig-user.html\n */\nstatic char *font = \"mono:pixelsize=12:antialias=true:autohint=true\";\nstatic char *font2[] = { \"NotoColorEmoji:pixelsize=10:antialias=true:autohint=true\" };\nstatic int borderpx = 2;\n\n/*\n * What program is execed by st depends of these precedence rules:\n * 1: program passed with -e\n * 2: scroll and/or utmp\n * 3: SHELL environment variable\n * 4: value of shell in /etc/passwd\n * 5: value of shell in config.h\n */\nstatic char *shell = \"/bin/sh\";\nchar *utmp = NULL;\n/* scroll program: to enable use a string like \"scroll\" */\nchar *scroll = NULL;\nchar *stty_args = \"stty raw pass8 nl -echo -iexten -cstopb 38400\";\n\n/* identification sequence returned in DA and DECID */\nchar *vtiden = \"\\033[?6c\";\n\n/* Kerning / character bounding-box multipliers */\nstatic float cwscale = 1.0;\nstatic float chscale = 1.0;\n\n/*\n * word delimiter string\n *\n * More advanced example: L\" `'\\\"()[]{}\"\n */\nwchar_t *worddelimiters = L\" \";\n\n/* selection timeouts (in milliseconds) */\nstatic unsigned int doubleclicktimeout = 300;\nstatic unsigned int tripleclicktimeout = 600;\n\n/* alt screens */\nint allowaltscreen = 1;\n\n/* allow certain non-interactive (insecure) window operations such as:\n   setting the clipboard text */\nint allowwindowops = 0;\n\n/*\n * draw latency range in ms - from new content/keypress/etc until drawing.\n * within this range, st draws when content stops arriving (idle). mostly it's\n * near minlatency, but it waits longer for slow updates to avoid partial draw.\n * low minlatency will tear/flicker more, as it can \"detect\" idle too early.\n */\nstatic double minlatency = 8;\nstatic double maxlatency = 33;\n\n/*\n * blinking timeout (set to 0 to disable blinking) for the terminal blinking\n * attribute.\n */\nstatic unsigned int blinktimeout = 800;\n\n/*\n * thickness of underline and bar cursors\n */\nstatic unsigned int cursorthickness = 2;\n\n/*\n * 1: render most of the lines/blocks characters without using the font for\n *    perfect alignment between cells (U2500 - U259F except dashes/diagonals).\n *    Bold affects lines thickness if boxdraw_bold is not 0. Italic is ignored.\n * 0: disable (render all U25XX glyphs normally from the font).\n */\nconst int boxdraw = 1;\nconst int boxdraw_bold = 0;\n\n/* braille (U28XX):  1: render as adjacent \"pixels\",  0: use font */\nconst int boxdraw_braille = 0;\n\n/*\n * bell volume. It must be a value between -100 and 100. Use 0 for disabling\n * it\n */\nstatic int bellvolume = 0;\n\n/* default TERM value */\nchar *termname = \"st-256color\";\n\n/*\n * spaces per tab\n *\n * When you are changing this value, don't forget to adapt the »it« value in\n * the st.info and appropriately install the st.info in the environment where\n * you use this st version.\n *\n *\tit#$tabspaces,\n *\n * Secondly make sure your kernel is not expanding tabs. When running `stty\n * -a` »tab0« should appear. You can tell the terminal to not expand tabs by\n *  running following command:\n *\n *\tstty tabs\n */\nunsigned int tabspaces = 8;\n\n/* bg opacity */\nfloat alpha = 0.8;\nfloat alphaOffset = 0.0;\nfloat alphaUnfocus;\n\n/* Terminal colors (16 first used in escape sequence) */\nstatic const char *colorname[] = {\n\t\"#282828\", /* hard contrast: #1d2021 / soft contrast: #32302f */\n\t\"#cc241d\",\n\t\"#98971a\",\n\t\"#d79921\",\n\t\"#458588\",\n\t\"#b16286\",\n\t\"#689d6a\",\n\t\"#a89984\",\n\t\"#928374\",\n\t\"#fb4934\",\n\t\"#b8bb26\",\n\t\"#fabd2f\",\n\t\"#83a598\",\n\t\"#d3869b\",\n\t\"#8ec07c\",\n\t\"#ebdbb2\",\n\t[255] = 0,\n\t/* more colors can be added after 255 to use with DefaultXX */\n\t\"#add8e6\", /* 256 -> cursor */\n\t\"#555555\", /* 257 -> rev cursor*/\n\t\"#282828\", /* 258 -> bg */\n\t\"#ebdbb2\", /* 259 -> fg */\n};\n\n\n/*\n * Default colors (colorname index)\n * foreground, background, cursor, reverse cursor\n */\nunsigned int defaultfg = 259;\nunsigned int defaultbg = 258;\nunsigned int defaultcs = 256;\nunsigned int defaultrcs = 257;\nunsigned int background = 258;\n\n/*\n * Default shape of cursor\n * 2: Block (\"█\")\n * 4: Underline (\"_\")\n * 6: Bar (\"|\")\n * 7: Snowman (\"☃\")\n */\nstatic unsigned int cursorshape = 2;\n\n/*\n * Default columns and rows numbers\n */\n\nstatic unsigned int cols = 80;\nstatic unsigned int rows = 24;\n\n/*\n * Default colour and shape of the mouse cursor\n */\nstatic unsigned int mouseshape = XC_xterm;\nstatic unsigned int mousefg = 7;\nstatic unsigned int mousebg = 0;\n\n/*\n * Color used to display font attributes when fontconfig selected a font which\n * doesn't match the ones requested.\n */\nstatic unsigned int defaultattr = 11;\n\n/*\n * Force mouse select/shortcuts while mask is active (when MODE_MOUSE is set).\n * Note that if you want to use ShiftMask with selmasks, set this to an other\n * modifier, set to 0 to not use it.\n */\nstatic uint forcemousemod = ShiftMask;\n\n/*\n * Xresources preferences to load at startup\n */\nResourcePref resources[] = {\n\t\t{ \"font\",         STRING,  &font },\n\t\t{ \"fontalt0\",     STRING,  &font2[0] },\n\t\t{ \"color0\",       STRING,  &colorname[0] },\n\t\t{ \"color1\",       STRING,  &colorname[1] },\n\t\t{ \"color2\",       STRING,  &colorname[2] },\n\t\t{ \"color3\",       STRING,  &colorname[3] },\n\t\t{ \"color4\",       STRING,  &colorname[4] },\n\t\t{ \"color5\",       STRING,  &colorname[5] },\n\t\t{ \"color6\",       STRING,  &colorname[6] },\n\t\t{ \"color7\",       STRING,  &colorname[7] },\n\t\t{ \"color8\",       STRING,  &colorname[8] },\n\t\t{ \"color9\",       STRING,  &colorname[9] },\n\t\t{ \"color10\",      STRING,  &colorname[10] },\n\t\t{ \"color11\",      STRING,  &colorname[11] },\n\t\t{ \"color12\",      STRING,  &colorname[12] },\n\t\t{ \"color13\",      STRING,  &colorname[13] },\n\t\t{ \"color14\",      STRING,  &colorname[14] },\n\t\t{ \"color15\",      STRING,  &colorname[15] },\n\t\t{ \"background\",   STRING,  &colorname[258] },\n\t\t{ \"foreground\",   STRING,  &colorname[259] },\n\t\t{ \"cursorColor\",  STRING,  &colorname[256] },\n\t\t{ \"termname\",     STRING,  &termname },\n\t\t{ \"shell\",        STRING,  &shell },\n\t\t{ \"minlatency\",   INTEGER, &minlatency },\n\t\t{ \"maxlatency\",   INTEGER, &maxlatency },\n\t\t{ \"blinktimeout\", INTEGER, &blinktimeout },\n\t\t{ \"bellvolume\",   INTEGER, &bellvolume },\n\t\t{ \"tabspaces\",    INTEGER, &tabspaces },\n\t\t{ \"borderpx\",     INTEGER, &borderpx },\n\t\t{ \"cwscale\",      FLOAT,   &cwscale },\n\t\t{ \"chscale\",      FLOAT,   &chscale },\n\t\t{ \"alpha\",        FLOAT,   &alpha },\n\t\t{ \"alphaOffset\",  FLOAT,   &alphaOffset },\n};\n\n/*\n * Internal mouse shortcuts.\n * Beware that overloading Button1 will disable the selection.\n */\nstatic MouseShortcut mshortcuts[] = {\n\t/* mask                 button   function        argument       release */\n\t{ XK_NO_MOD,            Button4, kscrollup,      {.i = 1} },\n\t{ XK_NO_MOD,            Button5, kscrolldown,    {.i = 1} },\n\t{ XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },\n\t{ ShiftMask,            Button4, ttysend,        {.s = \"\\033[5;2~\"} },\n\t{ XK_ANY_MOD,           Button4, ttysend,        {.s = \"\\031\"} },\n\t{ ShiftMask,            Button5, ttysend,        {.s = \"\\033[6;2~\"} },\n\t{ XK_ANY_MOD,           Button5, ttysend,        {.s = \"\\005\"} },\n};\n\n/* Internal keyboard shortcuts. */\n#define MODKEY Mod1Mask\n#define TERMMOD (Mod1Mask|ShiftMask)\n\nstatic char *openurlcmd[] = { \"/bin/sh\", \"-c\", \"st-urlhandler -o\", \"externalpipe\", NULL };\nstatic char *copyurlcmd[] = { \"/bin/sh\", \"-c\", \"st-urlhandler -c\", \"externalpipe\", NULL };\nstatic char *copyoutput[] = { \"/bin/sh\", \"-c\", \"st-copyout\", \"externalpipe\", NULL };\n\nstatic Shortcut shortcuts[] = {\n\t/* mask                 keysym          function        argument */\n\t{ XK_ANY_MOD,           XK_Break,       sendbreak,      {.i =  0} },\n\t{ ControlMask,          XK_Print,       toggleprinter,  {.i =  0} },\n\t{ ShiftMask,            XK_Print,       printscreen,    {.i =  0} },\n\t{ XK_ANY_MOD,           XK_Print,       printsel,       {.i =  0} },\n\t{ TERMMOD,              XK_Prior,       zoom,           {.f = +1} },\n\t{ TERMMOD,              XK_Next,        zoom,           {.f = -1} },\n\t{ TERMMOD,              XK_Home,        zoomreset,      {.f =  0} },\n\t{ TERMMOD,              XK_C,           clipcopy,       {.i =  0} },\n\t{ TERMMOD,              XK_V,           clippaste,      {.i =  0} },\n\t{ MODKEY,               XK_c,           clipcopy,       {.i =  0} },\n\t{ ShiftMask,            XK_Insert,      clippaste,      {.i =  0} },\n\t{ MODKEY,               XK_v,           clippaste,      {.i =  0} },\n\t{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },\n\t{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },\n\t{ ShiftMask,            XK_Page_Up,     kscrollup,      {.i = -1} },\n\t{ ShiftMask,            XK_Page_Down,   kscrolldown,    {.i = -1} },\n\t{ MODKEY,               XK_Page_Up,     kscrollup,      {.i = -1} },\n\t{ MODKEY,               XK_Page_Down,   kscrolldown,    {.i = -1} },\n\t{ MODKEY,               XK_k,           kscrollup,      {.i =  1} },\n\t{ MODKEY,               XK_j,           kscrolldown,    {.i =  1} },\n\t{ MODKEY,               XK_Up,          kscrollup,      {.i =  1} },\n\t{ MODKEY,               XK_Down,        kscrolldown,    {.i =  1} },\n\t{ MODKEY,               XK_u,           kscrollup,      {.i = -1} },\n\t{ MODKEY,               XK_d,           kscrolldown,    {.i = -1} },\n\t{ MODKEY,\t\tXK_s,\t\tchangealpha,\t{.f = -0.05} },\n\t{ MODKEY,\t\tXK_a,\t\tchangealpha,\t{.f = +0.05} },\n\t{ TERMMOD,              XK_Up,          zoom,           {.f = +1} },\n\t{ TERMMOD,              XK_Down,        zoom,           {.f = -1} },\n\t{ TERMMOD,              XK_K,           zoom,           {.f = +1} },\n\t{ TERMMOD,              XK_J,           zoom,           {.f = -1} },\n\t{ TERMMOD,              XK_U,           zoom,           {.f = +2} },\n\t{ TERMMOD,              XK_D,           zoom,           {.f = -2} },\n\t{ MODKEY,               XK_l,           externalpipe,   {.v = openurlcmd } },\n\t{ MODKEY,               XK_y,           externalpipe,   {.v = copyurlcmd } },\n\t{ MODKEY,               XK_o,           externalpipe,   {.v = copyoutput } },\n};\n\n/*\n * Special keys (change & recompile st.info accordingly)\n *\n * Mask value:\n * * Use XK_ANY_MOD to match the key no matter modifiers state\n * * Use XK_NO_MOD to match the key alone (no modifiers)\n * appkey value:\n * * 0: no value\n * * > 0: keypad application mode enabled\n * *   = 2: term.numlock = 1\n * * < 0: keypad application mode disabled\n * appcursor value:\n * * 0: no value\n * * > 0: cursor application mode enabled\n * * < 0: cursor application mode disabled\n *\n * Be careful with the order of the definitions because st searches in\n * this table sequentially, so any XK_ANY_MOD must be in the last\n * position for a key.\n */\n\n/*\n * If you want keys other than the X11 function keys (0xFD00 - 0xFFFF)\n * to be mapped below, add them to this array.\n */\nstatic KeySym mappedkeys[] = { -1 };\n\n/*\n * State bits to ignore when matching key or button events.  By default,\n * numlock (Mod2Mask) and keyboard layout (XK_SWITCH_MOD) are ignored.\n */\nstatic uint ignoremod = Mod2Mask|XK_SWITCH_MOD;\n\n/*\n * This is the huge key array which defines all compatibility to the Linux\n * world. Please decide about changes wisely.\n */\nstatic Key key[] = {\n\t/* keysym           mask            string      appkey appcursor */\n\t{ XK_KP_Home,       ShiftMask,      \"\\033[2J\",       0,   -1},\n\t{ XK_KP_Home,       ShiftMask,      \"\\033[1;2H\",     0,   +1},\n\t{ XK_KP_Home,       XK_ANY_MOD,     \"\\033[H\",        0,   -1},\n\t{ XK_KP_Home,       XK_ANY_MOD,     \"\\033[1~\",       0,   +1},\n\t{ XK_KP_Up,         XK_ANY_MOD,     \"\\033Ox\",       +1,    0},\n\t{ XK_KP_Up,         XK_ANY_MOD,     \"\\033[A\",        0,   -1},\n\t{ XK_KP_Up,         XK_ANY_MOD,     \"\\033OA\",        0,   +1},\n\t{ XK_KP_Down,       XK_ANY_MOD,     \"\\033Or\",       +1,    0},\n\t{ XK_KP_Down,       XK_ANY_MOD,     \"\\033[B\",        0,   -1},\n\t{ XK_KP_Down,       XK_ANY_MOD,     \"\\033OB\",        0,   +1},\n\t{ XK_KP_Left,       XK_ANY_MOD,     \"\\033Ot\",       +1,    0},\n\t{ XK_KP_Left,       XK_ANY_MOD,     \"\\033[D\",        0,   -1},\n\t{ XK_KP_Left,       XK_ANY_MOD,     \"\\033OD\",        0,   +1},\n\t{ XK_KP_Right,      XK_ANY_MOD,     \"\\033Ov\",       +1,    0},\n\t{ XK_KP_Right,      XK_ANY_MOD,     \"\\033[C\",        0,   -1},\n\t{ XK_KP_Right,      XK_ANY_MOD,     \"\\033OC\",        0,   +1},\n\t{ XK_KP_Prior,      ShiftMask,      \"\\033[5;2~\",     0,    0},\n\t{ XK_KP_Prior,      XK_ANY_MOD,     \"\\033[5~\",       0,    0},\n\t{ XK_KP_Begin,      XK_ANY_MOD,     \"\\033[E\",        0,    0},\n\t{ XK_KP_End,        ControlMask,    \"\\033[J\",       -1,    0},\n\t{ XK_KP_End,        ControlMask,    \"\\033[1;5F\",    +1,    0},\n\t{ XK_KP_End,        ShiftMask,      \"\\033[K\",       -1,    0},\n\t{ XK_KP_End,        ShiftMask,      \"\\033[1;2F\",    +1,    0},\n\t{ XK_KP_End,        XK_ANY_MOD,     \"\\033[4~\",       0,    0},\n\t{ XK_KP_Next,       ShiftMask,      \"\\033[6;2~\",     0,    0},\n\t{ XK_KP_Next,       XK_ANY_MOD,     \"\\033[6~\",       0,    0},\n\t{ XK_KP_Insert,     ShiftMask,      \"\\033[2;2~\",    +1,    0},\n\t{ XK_KP_Insert,     ShiftMask,      \"\\033[4l\",      -1,    0},\n\t{ XK_KP_Insert,     ControlMask,    \"\\033[L\",       -1,    0},\n\t{ XK_KP_Insert,     ControlMask,    \"\\033[2;5~\",    +1,    0},\n\t{ XK_KP_Insert,     XK_ANY_MOD,     \"\\033[4h\",      -1,    0},\n\t{ XK_KP_Insert,     XK_ANY_MOD,     \"\\033[2~\",      +1,    0},\n\t{ XK_KP_Delete,     ControlMask,    \"\\033[M\",       -1,    0},\n\t{ XK_KP_Delete,     ControlMask,    \"\\033[3;5~\",    +1,    0},\n\t{ XK_KP_Delete,     ShiftMask,      \"\\033[2K\",      -1,    0},\n\t{ XK_KP_Delete,     ShiftMask,      \"\\033[3;2~\",    +1,    0},\n\t{ XK_KP_Delete,     XK_ANY_MOD,     \"\\033[P\",       -1,    0},\n\t{ XK_KP_Delete,     XK_ANY_MOD,     \"\\033[3~\",      +1,    0},\n\t{ XK_KP_Multiply,   XK_ANY_MOD,     \"\\033Oj\",       +2,    0},\n\t{ XK_KP_Add,        XK_ANY_MOD,     \"\\033Ok\",       +2,    0},\n\t{ XK_KP_Enter,      XK_ANY_MOD,     \"\\033OM\",       +2,    0},\n\t{ XK_KP_Enter,      XK_ANY_MOD,     \"\\r\",           -1,    0},\n\t{ XK_KP_Subtract,   XK_ANY_MOD,     \"\\033Om\",       +2,    0},\n\t{ XK_KP_Decimal,    XK_ANY_MOD,     \"\\033On\",       +2,    0},\n\t{ XK_KP_Divide,     XK_ANY_MOD,     \"\\033Oo\",       +2,    0},\n\t{ XK_KP_0,          XK_ANY_MOD,     \"\\033Op\",       +2,    0},\n\t{ XK_KP_1,          XK_ANY_MOD,     \"\\033Oq\",       +2,    0},\n\t{ XK_KP_2,          XK_ANY_MOD,     \"\\033Or\",       +2,    0},\n\t{ XK_KP_3,          XK_ANY_MOD,     \"\\033Os\",       +2,    0},\n\t{ XK_KP_4,          XK_ANY_MOD,     \"\\033Ot\",       +2,    0},\n\t{ XK_KP_5,          XK_ANY_MOD,     \"\\033Ou\",       +2,    0},\n\t{ XK_KP_6,          XK_ANY_MOD,     \"\\033Ov\",       +2,    0},\n\t{ XK_KP_7,          XK_ANY_MOD,     \"\\033Ow\",       +2,    0},\n\t{ XK_KP_8,          XK_ANY_MOD,     \"\\033Ox\",       +2,    0},\n\t{ XK_KP_9,          XK_ANY_MOD,     \"\\033Oy\",       +2,    0},\n\t{ XK_Up,            ShiftMask,      \"\\033[1;2A\",     0,    0},\n\t{ XK_Up,            Mod1Mask,       \"\\033[1;3A\",     0,    0},\n\t{ XK_Up,         ShiftMask|Mod1Mask,\"\\033[1;4A\",     0,    0},\n\t{ XK_Up,            ControlMask,    \"\\033[1;5A\",     0,    0},\n\t{ XK_Up,      ShiftMask|ControlMask,\"\\033[1;6A\",     0,    0},\n\t{ XK_Up,       ControlMask|Mod1Mask,\"\\033[1;7A\",     0,    0},\n\t{ XK_Up,ShiftMask|ControlMask|Mod1Mask,\"\\033[1;8A\",  0,    0},\n\t{ XK_Up,            XK_ANY_MOD,     \"\\033[A\",        0,   -1},\n\t{ XK_Up,            XK_ANY_MOD,     \"\\033OA\",        0,   +1},\n\t{ XK_Down,          ShiftMask,      \"\\033[1;2B\",     0,    0},\n\t{ XK_Down,          Mod1Mask,       \"\\033[1;3B\",     0,    0},\n\t{ XK_Down,       ShiftMask|Mod1Mask,\"\\033[1;4B\",     0,    0},\n\t{ XK_Down,          ControlMask,    \"\\033[1;5B\",     0,    0},\n\t{ XK_Down,    ShiftMask|ControlMask,\"\\033[1;6B\",     0,    0},\n\t{ XK_Down,     ControlMask|Mod1Mask,\"\\033[1;7B\",     0,    0},\n\t{ XK_Down,ShiftMask|ControlMask|Mod1Mask,\"\\033[1;8B\",0,    0},\n\t{ XK_Down,          XK_ANY_MOD,     \"\\033[B\",        0,   -1},\n\t{ XK_Down,          XK_ANY_MOD,     \"\\033OB\",        0,   +1},\n\t{ XK_Left,          ShiftMask,      \"\\033[1;2D\",     0,    0},\n\t{ XK_Left,          Mod1Mask,       \"\\033[1;3D\",     0,    0},\n\t{ XK_Left,       ShiftMask|Mod1Mask,\"\\033[1;4D\",     0,    0},\n\t{ XK_Left,          ControlMask,    \"\\033[1;5D\",     0,    0},\n\t{ XK_Left,    ShiftMask|ControlMask,\"\\033[1;6D\",     0,    0},\n\t{ XK_Left,     ControlMask|Mod1Mask,\"\\033[1;7D\",     0,    0},\n\t{ XK_Left,ShiftMask|ControlMask|Mod1Mask,\"\\033[1;8D\",0,    0},\n\t{ XK_Left,          XK_ANY_MOD,     \"\\033[D\",        0,   -1},\n\t{ XK_Left,          XK_ANY_MOD,     \"\\033OD\",        0,   +1},\n\t{ XK_Right,         ShiftMask,      \"\\033[1;2C\",     0,    0},\n\t{ XK_Right,         Mod1Mask,       \"\\033[1;3C\",     0,    0},\n\t{ XK_Right,      ShiftMask|Mod1Mask,\"\\033[1;4C\",     0,    0},\n\t{ XK_Right,         ControlMask,    \"\\033[1;5C\",     0,    0},\n\t{ XK_Right,   ShiftMask|ControlMask,\"\\033[1;6C\",     0,    0},\n\t{ XK_Right,    ControlMask|Mod1Mask,\"\\033[1;7C\",     0,    0},\n\t{ XK_Right,ShiftMask|ControlMask|Mod1Mask,\"\\033[1;8C\",0,   0},\n\t{ XK_Right,         XK_ANY_MOD,     \"\\033[C\",        0,   -1},\n\t{ XK_Right,         XK_ANY_MOD,     \"\\033OC\",        0,   +1},\n\t{ XK_ISO_Left_Tab,  ShiftMask,      \"\\033[Z\",        0,    0},\n\t{ XK_Return,        Mod1Mask,       \"\\033\\r\",        0,    0},\n\t{ XK_Return,        XK_ANY_MOD,     \"\\r\",            0,    0},\n\t{ XK_Insert,        ShiftMask,      \"\\033[4l\",      -1,    0},\n\t{ XK_Insert,        ShiftMask,      \"\\033[2;2~\",    +1,    0},\n\t{ XK_Insert,        ControlMask,    \"\\033[L\",       -1,    0},\n\t{ XK_Insert,        ControlMask,    \"\\033[2;5~\",    +1,    0},\n\t{ XK_Insert,        XK_ANY_MOD,     \"\\033[4h\",      -1,    0},\n\t{ XK_Insert,        XK_ANY_MOD,     \"\\033[2~\",      +1,    0},\n\t{ XK_Delete,        ControlMask,    \"\\033[M\",       -1,    0},\n\t{ XK_Delete,        ControlMask,    \"\\033[3;5~\",    +1,    0},\n\t{ XK_Delete,        ShiftMask,      \"\\033[2K\",      -1,    0},\n\t{ XK_Delete,        ShiftMask,      \"\\033[3;2~\",    +1,    0},\n\t{ XK_Delete,        XK_ANY_MOD,     \"\\033[P\",       -1,    0},\n\t{ XK_Delete,        XK_ANY_MOD,     \"\\033[3~\",      +1,    0},\n\t{ XK_BackSpace,     XK_NO_MOD,      \"\\177\",          0,    0},\n\t{ XK_BackSpace,     Mod1Mask,       \"\\033\\177\",      0,    0},\n\t{ XK_Home,          ShiftMask,      \"\\033[2J\",       0,   -1},\n\t{ XK_Home,          ShiftMask,      \"\\033[1;2H\",     0,   +1},\n\t{ XK_Home,          XK_ANY_MOD,     \"\\033[H\",        0,   -1},\n\t{ XK_Home,          XK_ANY_MOD,     \"\\033[1~\",       0,   +1},\n\t{ XK_End,           ControlMask,    \"\\033[J\",       -1,    0},\n\t{ XK_End,           ControlMask,    \"\\033[1;5F\",    +1,    0},\n\t{ XK_End,           ShiftMask,      \"\\033[K\",       -1,    0},\n\t{ XK_End,           ShiftMask,      \"\\033[1;2F\",    +1,    0},\n\t{ XK_End,           XK_ANY_MOD,     \"\\033[4~\",       0,    0},\n\t{ XK_Prior,         ControlMask,    \"\\033[5;5~\",     0,    0},\n\t{ XK_Prior,         ShiftMask,      \"\\033[5;2~\",     0,    0},\n\t{ XK_Prior,         XK_ANY_MOD,     \"\\033[5~\",       0,    0},\n\t{ XK_Next,          ControlMask,    \"\\033[6;5~\",     0,    0},\n\t{ XK_Next,          ShiftMask,      \"\\033[6;2~\",     0,    0},\n\t{ XK_Next,          XK_ANY_MOD,     \"\\033[6~\",       0,    0},\n\t{ XK_F1,            XK_NO_MOD,      \"\\033OP\" ,       0,    0},\n\t{ XK_F1, /* F13 */  ShiftMask,      \"\\033[1;2P\",     0,    0},\n\t{ XK_F1, /* F25 */  ControlMask,    \"\\033[1;5P\",     0,    0},\n\t{ XK_F1, /* F37 */  Mod4Mask,       \"\\033[1;6P\",     0,    0},\n\t{ XK_F1, /* F49 */  Mod1Mask,       \"\\033[1;3P\",     0,    0},\n\t{ XK_F1, /* F61 */  Mod3Mask,       \"\\033[1;4P\",     0,    0},\n\t{ XK_F2,            XK_NO_MOD,      \"\\033OQ\" ,       0,    0},\n\t{ XK_F2, /* F14 */  ShiftMask,      \"\\033[1;2Q\",     0,    0},\n\t{ XK_F2, /* F26 */  ControlMask,    \"\\033[1;5Q\",     0,    0},\n\t{ XK_F2, /* F38 */  Mod4Mask,       \"\\033[1;6Q\",     0,    0},\n\t{ XK_F2, /* F50 */  Mod1Mask,       \"\\033[1;3Q\",     0,    0},\n\t{ XK_F2, /* F62 */  Mod3Mask,       \"\\033[1;4Q\",     0,    0},\n\t{ XK_F3,            XK_NO_MOD,      \"\\033OR\" ,       0,    0},\n\t{ XK_F3, /* F15 */  ShiftMask,      \"\\033[1;2R\",     0,    0},\n\t{ XK_F3, /* F27 */  ControlMask,    \"\\033[1;5R\",     0,    0},\n\t{ XK_F3, /* F39 */  Mod4Mask,       \"\\033[1;6R\",     0,    0},\n\t{ XK_F3, /* F51 */  Mod1Mask,       \"\\033[1;3R\",     0,    0},\n\t{ XK_F3, /* F63 */  Mod3Mask,       \"\\033[1;4R\",     0,    0},\n\t{ XK_F4,            XK_NO_MOD,      \"\\033OS\" ,       0,    0},\n\t{ XK_F4, /* F16 */  ShiftMask,      \"\\033[1;2S\",     0,    0},\n\t{ XK_F4, /* F28 */  ControlMask,    \"\\033[1;5S\",     0,    0},\n\t{ XK_F4, /* F40 */  Mod4Mask,       \"\\033[1;6S\",     0,    0},\n\t{ XK_F4, /* F52 */  Mod1Mask,       \"\\033[1;3S\",     0,    0},\n\t{ XK_F5,            XK_NO_MOD,      \"\\033[15~\",      0,    0},\n\t{ XK_F5, /* F17 */  ShiftMask,      \"\\033[15;2~\",    0,    0},\n\t{ XK_F5, /* F29 */  ControlMask,    \"\\033[15;5~\",    0,    0},\n\t{ XK_F5, /* F41 */  Mod4Mask,       \"\\033[15;6~\",    0,    0},\n\t{ XK_F5, /* F53 */  Mod1Mask,       \"\\033[15;3~\",    0,    0},\n\t{ XK_F6,            XK_NO_MOD,      \"\\033[17~\",      0,    0},\n\t{ XK_F6, /* F18 */  ShiftMask,      \"\\033[17;2~\",    0,    0},\n\t{ XK_F6, /* F30 */  ControlMask,    \"\\033[17;5~\",    0,    0},\n\t{ XK_F6, /* F42 */  Mod4Mask,       \"\\033[17;6~\",    0,    0},\n\t{ XK_F6, /* F54 */  Mod1Mask,       \"\\033[17;3~\",    0,    0},\n\t{ XK_F7,            XK_NO_MOD,      \"\\033[18~\",      0,    0},\n\t{ XK_F7, /* F19 */  ShiftMask,      \"\\033[18;2~\",    0,    0},\n\t{ XK_F7, /* F31 */  ControlMask,    \"\\033[18;5~\",    0,    0},\n\t{ XK_F7, /* F43 */  Mod4Mask,       \"\\033[18;6~\",    0,    0},\n\t{ XK_F7, /* F55 */  Mod1Mask,       \"\\033[18;3~\",    0,    0},\n\t{ XK_F8,            XK_NO_MOD,      \"\\033[19~\",      0,    0},\n\t{ XK_F8, /* F20 */  ShiftMask,      \"\\033[19;2~\",    0,    0},\n\t{ XK_F8, /* F32 */  ControlMask,    \"\\033[19;5~\",    0,    0},\n\t{ XK_F8, /* F44 */  Mod4Mask,       \"\\033[19;6~\",    0,    0},\n\t{ XK_F8, /* F56 */  Mod1Mask,       \"\\033[19;3~\",    0,    0},\n\t{ XK_F9,            XK_NO_MOD,      \"\\033[20~\",      0,    0},\n\t{ XK_F9, /* F21 */  ShiftMask,      \"\\033[20;2~\",    0,    0},\n\t{ XK_F9, /* F33 */  ControlMask,    \"\\033[20;5~\",    0,    0},\n\t{ XK_F9, /* F45 */  Mod4Mask,       \"\\033[20;6~\",    0,    0},\n\t{ XK_F9, /* F57 */  Mod1Mask,       \"\\033[20;3~\",    0,    0},\n\t{ XK_F10,           XK_NO_MOD,      \"\\033[21~\",      0,    0},\n\t{ XK_F10, /* F22 */ ShiftMask,      \"\\033[21;2~\",    0,    0},\n\t{ XK_F10, /* F34 */ ControlMask,    \"\\033[21;5~\",    0,    0},\n\t{ XK_F10, /* F46 */ Mod4Mask,       \"\\033[21;6~\",    0,    0},\n\t{ XK_F10, /* F58 */ Mod1Mask,       \"\\033[21;3~\",    0,    0},\n\t{ XK_F11,           XK_NO_MOD,      \"\\033[23~\",      0,    0},\n\t{ XK_F11, /* F23 */ ShiftMask,      \"\\033[23;2~\",    0,    0},\n\t{ XK_F11, /* F35 */ ControlMask,    \"\\033[23;5~\",    0,    0},\n\t{ XK_F11, /* F47 */ Mod4Mask,       \"\\033[23;6~\",    0,    0},\n\t{ XK_F11, /* F59 */ Mod1Mask,       \"\\033[23;3~\",    0,    0},\n\t{ XK_F12,           XK_NO_MOD,      \"\\033[24~\",      0,    0},\n\t{ XK_F12, /* F24 */ ShiftMask,      \"\\033[24;2~\",    0,    0},\n\t{ XK_F12, /* F36 */ ControlMask,    \"\\033[24;5~\",    0,    0},\n\t{ XK_F12, /* F48 */ Mod4Mask,       \"\\033[24;6~\",    0,    0},\n\t{ XK_F12, /* F60 */ Mod1Mask,       \"\\033[24;3~\",    0,    0},\n\t{ XK_F13,           XK_NO_MOD,      \"\\033[1;2P\",     0,    0},\n\t{ XK_F14,           XK_NO_MOD,      \"\\033[1;2Q\",     0,    0},\n\t{ XK_F15,           XK_NO_MOD,      \"\\033[1;2R\",     0,    0},\n\t{ XK_F16,           XK_NO_MOD,      \"\\033[1;2S\",     0,    0},\n\t{ XK_F17,           XK_NO_MOD,      \"\\033[15;2~\",    0,    0},\n\t{ XK_F18,           XK_NO_MOD,      \"\\033[17;2~\",    0,    0},\n\t{ XK_F19,           XK_NO_MOD,      \"\\033[18;2~\",    0,    0},\n\t{ XK_F20,           XK_NO_MOD,      \"\\033[19;2~\",    0,    0},\n\t{ XK_F21,           XK_NO_MOD,      \"\\033[20;2~\",    0,    0},\n\t{ XK_F22,           XK_NO_MOD,      \"\\033[21;2~\",    0,    0},\n\t{ XK_F23,           XK_NO_MOD,      \"\\033[23;2~\",    0,    0},\n\t{ XK_F24,           XK_NO_MOD,      \"\\033[24;2~\",    0,    0},\n\t{ XK_F25,           XK_NO_MOD,      \"\\033[1;5P\",     0,    0},\n\t{ XK_F26,           XK_NO_MOD,      \"\\033[1;5Q\",     0,    0},\n\t{ XK_F27,           XK_NO_MOD,      \"\\033[1;5R\",     0,    0},\n\t{ XK_F28,           XK_NO_MOD,      \"\\033[1;5S\",     0,    0},\n\t{ XK_F29,           XK_NO_MOD,      \"\\033[15;5~\",    0,    0},\n\t{ XK_F30,           XK_NO_MOD,      \"\\033[17;5~\",    0,    0},\n\t{ XK_F31,           XK_NO_MOD,      \"\\033[18;5~\",    0,    0},\n\t{ XK_F32,           XK_NO_MOD,      \"\\033[19;5~\",    0,    0},\n\t{ XK_F33,           XK_NO_MOD,      \"\\033[20;5~\",    0,    0},\n\t{ XK_F34,           XK_NO_MOD,      \"\\033[21;5~\",    0,    0},\n\t{ XK_F35,           XK_NO_MOD,      \"\\033[23;5~\",    0,    0},\n};\n\n/*\n * Selection types' masks.\n * Use the same masks as usual.\n * Button1Mask is always unset, to make masks match between ButtonPress.\n * ButtonRelease and MotionNotify.\n * If no match is found, regular selection is used.\n */\nstatic uint selmasks[] = {\n\t[SEL_RECTANGULAR] = Mod1Mask,\n};\n\n/*\n * Printable characters in ASCII, used to estimate the advance width\n * of single wide characters.\n */\nstatic char ascii_printable[] =\n\t\" !\\\"#$%&'()*+,-./0123456789:;<=>?\"\n\t\"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_\"\n\t\"`abcdefghijklmnopqrstuvwxyz{|}~\";\n\n"
        },
        {
          "name": "config.mk",
          "type": "blob",
          "size": 0.9375,
          "content": "# st version\nVERSION = 0.8.5\n\n# Customize below to fit your system\n\n# paths\nPREFIX = /usr/local\nMANPREFIX = $(PREFIX)/share/man\n\nX11INC = /usr/X11R6/include\nX11LIB = /usr/X11R6/lib\n\nPKG_CONFIG = pkg-config\n\n# includes and libs\nINCS = -I$(X11INC) \\\n       `$(PKG_CONFIG) --cflags fontconfig` \\\n       `$(PKG_CONFIG) --cflags freetype2` \\\n       `$(PKG_CONFIG) --cflags harfbuzz`\nLIBS = -L$(X11LIB) -lm -lrt -lX11 -lutil -lXft -lXrender\\\n       `$(PKG_CONFIG) --libs fontconfig` \\\n       `$(PKG_CONFIG) --libs freetype2` \\\n       `$(PKG_CONFIG) --libs harfbuzz`\n\n# flags\nSTCPPFLAGS = -DVERSION=\\\"$(VERSION)\\\" -D_XOPEN_SOURCE=600\nSTCFLAGS = $(INCS) $(STCPPFLAGS) $(CPPFLAGS) $(CFLAGS)\nSTLDFLAGS = $(LIBS) $(LDFLAGS)\n\n# OpenBSD:\n#CPPFLAGS = -DVERSION=\\\"$(VERSION)\\\" -D_XOPEN_SOURCE=600 -D_BSD_SOURCE\n#LIBS = -L$(X11LIB) -lm -lX11 -lutil -lXft \\\n#       `$(PKG_CONFIG) --libs fontconfig` \\\n#       `$(PKG_CONFIG) --libs freetype2`\n\n# compiler and linker\n# CC = c99\n"
        },
        {
          "name": "hb.c",
          "type": "blob",
          "size": 3.912109375,
          "content": "#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <X11/Xft/Xft.h>\n#include <X11/cursorfont.h>\n#include <hb.h>\n#include <hb-ft.h>\n\n#include \"st.h\"\n\n#define FEATURE(c1,c2,c3,c4) { .tag = HB_TAG(c1,c2,c3,c4), .value = 1, .start = HB_FEATURE_GLOBAL_START, .end = HB_FEATURE_GLOBAL_END }\n\n/*\n * Replace 0 with a list of font features, wrapped in FEATURE macro, e.g.\n * FEATURE('c', 'a', 'l', 't'), FEATURE('d', 'l', 'i', 'g')\n * \n * Uncomment either one of the 2 lines below. Uncomment the prior to disable (any) font features. Uncomment the \n * latter to enable the (selected) font features.\n */\n\nhb_feature_t features[] = { 0 };\n//hb_feature_t features[] = { FEATURE('s','s','0','1'), FEATURE('s','s','0','2'), FEATURE('s','s','0','3'), FEATURE('s','s','0','5'), FEATURE('s','s','0','6'), FEATURE('s','s','0','7'), FEATURE('s','s','0','8'), FEATURE('z','e','r','o') };\n\nvoid hbtransformsegment(XftFont *xfont, const Glyph *string, hb_codepoint_t *codepoints, int start, int length);\nhb_font_t *hbfindfont(XftFont *match);\n\ntypedef struct {\n\tXftFont *match;\n\thb_font_t *font;\n} HbFontMatch;\n\nstatic int hbfontslen = 0;\nstatic HbFontMatch *hbfontcache = NULL;\n\nvoid\nhbunloadfonts()\n{\n\tfor (int i = 0; i < hbfontslen; i++) {\n\t\thb_font_destroy(hbfontcache[i].font);\n\t\tXftUnlockFace(hbfontcache[i].match);\n\t}\n\n\tif (hbfontcache != NULL) {\n\t\tfree(hbfontcache);\n\t\thbfontcache = NULL;\n\t}\n\thbfontslen = 0;\n}\n\nhb_font_t *\nhbfindfont(XftFont *match)\n{\n\tfor (int i = 0; i < hbfontslen; i++) {\n\t\tif (hbfontcache[i].match == match)\n\t\t\treturn hbfontcache[i].font;\n\t}\n\n\t/* Font not found in cache, caching it now. */\n\thbfontcache = realloc(hbfontcache, sizeof(HbFontMatch) * (hbfontslen + 1));\n\tFT_Face face = XftLockFace(match);\n\thb_font_t *font = hb_ft_font_create(face, NULL);\n\tif (font == NULL)\n\t\tdie(\"Failed to load Harfbuzz font.\");\n\n\thbfontcache[hbfontslen].match = match;\n\thbfontcache[hbfontslen].font = font;\n\thbfontslen += 1;\n\n\treturn font;\n}\n\nvoid\nhbtransform(XftGlyphFontSpec *specs, const Glyph *glyphs, size_t len, int x, int y)\n{\n\tint start = 0, length = 1, gstart = 0;\n\thb_codepoint_t *codepoints = calloc((unsigned int)len, sizeof(hb_codepoint_t));\n\n\tfor (int idx = 1, specidx = 1; idx < len; idx++) {\n\t\tif (glyphs[idx].mode & ATTR_WDUMMY) {\n\t\t\tlength += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (specs[specidx].font != specs[start].font || ATTRCMP(glyphs[gstart], glyphs[idx]) || selected(x + idx, y) != selected(x + gstart, y)) {\n\t\t\thbtransformsegment(specs[start].font, glyphs, codepoints, gstart, length);\n\n\t\t\t/* Reset the sequence. */\n\t\t\tlength = 1;\n\t\t\tstart = specidx;\n\t\t\tgstart = idx;\n\t\t} else {\n\t\t\tlength += 1;\n\t\t}\n\n\t\tspecidx++;\n\t}\n\n\t/* EOL. */\n\thbtransformsegment(specs[start].font, glyphs, codepoints, gstart, length);\n\n\t/* Apply the transformation to glyph specs. */\n\tfor (int i = 0, specidx = 0; i < len; i++) {\n\t\tif (glyphs[i].mode & ATTR_WDUMMY)\n\t\t\tcontinue;\n\t\tif (glyphs[i].mode & ATTR_BOXDRAW) {\n\t\t\tspecidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codepoints[i] != specs[specidx].glyph)\n\t\t\t((Glyph *)glyphs)[i].mode |= ATTR_LIGA;\n\n\t\tspecs[specidx++].glyph = codepoints[i];\n\t}\n\n\tfree(codepoints);\n}\n\nvoid\nhbtransformsegment(XftFont *xfont, const Glyph *string, hb_codepoint_t *codepoints, int start, int length)\n{\n\thb_font_t *font = hbfindfont(xfont);\n\tif (font == NULL)\n\t\treturn;\n\n\tRune rune;\n\tushort mode = USHRT_MAX;\n\thb_buffer_t *buffer = hb_buffer_create();\n\thb_buffer_set_direction(buffer, HB_DIRECTION_LTR);\n\n\t/* Fill buffer with codepoints. */\n\tfor (int i = start; i < (start+length); i++) {\n\t\trune = string[i].u;\n\t\tmode = string[i].mode;\n\t\tif (mode & ATTR_WDUMMY)\n\t\t\trune = 0x0020;\n\t\thb_buffer_add_codepoints(buffer, &rune, 1, 0, 1);\n\t}\n\n\t/* Shape the segment. */\n\thb_shape(font, buffer, features, sizeof(features));\n\n\t/* Get new glyph info. */\n\thb_glyph_info_t *info = hb_buffer_get_glyph_infos(buffer, NULL);\n\n\t/* Write new codepoints. */\n\tfor (int i = 0; i < length; i++) {\n\t\thb_codepoint_t gid = info[i].codepoint;\n\t\tcodepoints[start+i] = gid;\n\t}\n\n\t/* Cleanup. */\n\thb_buffer_destroy(buffer);\n}\n"
        },
        {
          "name": "hb.h",
          "type": "blob",
          "size": 0.1513671875,
          "content": "#include <X11/Xft/Xft.h>\n#include <hb.h>\n#include <hb-ft.h>\n\nvoid hbunloadfonts();\nvoid hbtransform(XftGlyphFontSpec *, const Glyph *, size_t, int, int);\n\n"
        },
        {
          "name": "st-copyout",
          "type": "blob",
          "size": 0.6533203125,
          "content": "#!/bin/sh\n# Using external pipe with st, give a dmenu prompt of recent commands,\n# allowing the user to copy the output of one.\n# xclip required for this script.\n# By Jaywalker and Luke\ntmpfile=$(mktemp /tmp/st-cmd-output.XXXXXX)\ntrap 'rm \"$tmpfile\"' 0 1 15\nsed -n \"w $tmpfile\"\nsed -i 's/\\x0//g' \"$tmpfile\"\nps1=\"$(grep \"\\S\" \"$tmpfile\" | tail -n 1 | sed 's/^\\s*//' | cut -d' ' -f1)\"\nchosen=\"$(grep -F \"$ps1\" \"$tmpfile\" | sed '$ d' | tac | dmenu -p \"Copy which command's output?\" -i -l 10 | sed 's/[^^]/[&]/g; s/\\^/\\\\^/g')\"\neps1=\"$(echo \"$ps1\" | sed 's/[^^]/[&]/g; s/\\^/\\\\^/g')\"\nawk \"/^$chosen$/{p=1;print;next} p&&/$eps1/{p=0};p\" \"$tmpfile\" | xclip -selection clipboard\n"
        },
        {
          "name": "st-urlhandler",
          "type": "blob",
          "size": 0.90234375,
          "content": "#!/bin/sh\n\nurlregex=\"(((http|https|gopher|gemini|ftp|ftps|git)://|www\\\\.)[a-zA-Z0-9.]*[:;a-zA-Z0-9./+@$&%?$\\#=_~-]*)|((magnet:\\\\?xt=urn:btih:)[a-zA-Z0-9]*)\"\n\nurls=\"$(sed 's/.*│//g' | tr -d '\\n' | # First remove linebreaks and mutt sidebars:\n\tgrep -aEo \"$urlregex\" | # grep only urls as defined above.\n\tuniq | # Ignore neighboring duplicates.\n\tsed \"s/\\(\\.\\|,\\|;\\|\\!\\\\|\\?\\)$//;\n\ts/^www./http:\\/\\/www\\./\")\" # xdg-open will not detect url without http\n\n[ -z \"$urls\" ] && exit 1\n\nwhile getopts \"hoc\" o; do case \"${o}\" in\n\th) printf \"Optional arguments for custom use:\\\\n  -c: copy\\\\n  -o: xdg-open\\\\n  -h: Show this message\\\\n\" && exit 1 ;;\n\to) chosen=\"$(echo \"$urls\" | dmenu -i -p 'Follow which url?' -l 10)\"\n\tsetsid xdg-open \"$chosen\" >/dev/null 2>&1 & ;;\n\tc) echo \"$urls\" | dmenu -i -p 'Copy which url?' -l 10 | tr -d '\\n' | xclip -selection clipboard ;;\n\t*) printf \"Invalid option: -%s\\\\n\" \"$OPTARG\" && exit 1 ;;\nesac done\n"
        },
        {
          "name": "st.1",
          "type": "blob",
          "size": 3.96484375,
          "content": ".TH ST 1 st\\-VERSION\n.SH NAME\nst \\- simple terminal\n.SH SYNOPSIS\n.B st\n.RB [ \\-aiv ]\n.RB [ \\-c\n.IR class ]\n.RB [ \\-f\n.IR font ]\n.RB [ \\-g\n.IR geometry ]\n.RB [ \\-n\n.IR name ]\n.RB [ \\-o\n.IR iofile ]\n.RB [ \\-T\n.IR title ]\n.RB [ \\-t\n.IR title ]\n.RB [ \\-l\n.IR line ]\n.RB [ \\-w\n.IR windowid ]\n.RB [[ \\-e ]\n.IR command\n.RI [ arguments ...]]\n.PP\n.B st\n.RB [ \\-aiv ]\n.RB [ \\-c\n.IR class ]\n.RB [ \\-f\n.IR font ]\n.RB [ \\-g\n.IR geometry ]\n.RB [ \\-n\n.IR name ]\n.RB [ \\-o\n.IR iofile ]\n.RB [ \\-T\n.IR title ]\n.RB [ \\-t\n.IR title ]\n.RB [ \\-w\n.IR windowid ]\n.RB \\-l\n.IR line\n.RI [ stty_args ...]\n.SH DESCRIPTION\n.B st\nis a simple terminal emulator.\n.SH OPTIONS\n.TP\n.B \\-a\ndisable alternate screens in terminal\n.TP\n.BI \\-c \" class\"\ndefines the window class (default $TERM).\n.TP\n.BI \\-f \" font\"\ndefines the\n.I font\nto use when st is run.\n.TP\n.BI \\-g \" geometry\"\ndefines the X11 geometry string.\nThe form is [=][<cols>{xX}<rows>][{+-}<xoffset>{+-}<yoffset>]. See\n.BR XParseGeometry (3)\nfor further details.\n.TP\n.B \\-i\nwill fixate the position given with the -g option.\n.TP\n.BI \\-n \" name\"\ndefines the window instance name (default $TERM).\n.TP\n.BI \\-o \" iofile\"\nwrites all the I/O to\n.I iofile.\nThis feature is useful when recording st sessions. A value of \"-\" means\nstandard output.\n.TP\n.BI \\-T \" title\"\ndefines the window title (default 'st').\n.TP\n.BI \\-t \" title\"\ndefines the window title (default 'st').\n.TP\n.BI \\-w \" windowid\"\nembeds st within the window identified by\n.I windowid\n.TP\n.BI \\-l \" line\"\nuse a tty\n.I line\ninstead of a pseudo terminal.\n.I line\nshould be a (pseudo-)serial device (e.g. /dev/ttyS0 on Linux for serial port\n0).\nWhen this flag is given\nremaining arguments are used as flags for\n.BR stty(1).\nBy default st initializes the serial line to 8 bits, no parity, 1 stop bit\nand a 38400 baud rate. The speed is set by appending it as last argument\n(e.g. 'st -l /dev/ttyS0 115200'). Arguments before the last one are\n.BR stty(1)\nflags. If you want to set odd parity on 115200 baud use for example 'st -l\n/dev/ttyS0 parenb parodd 115200'. Set the number of bits by using for\nexample 'st -l /dev/ttyS0 cs7 115200'. See\n.BR stty(1)\nfor more arguments and cases.\n.TP\n.B \\-v\nprints version information to stderr, then exits.\n.TP\n.BI \\-e \" command \" [ \" arguments \" \"... ]\"\nst executes\n.I command\ninstead of the shell.  If this is used it\n.B must be the last option\non the command line, as in xterm / rxvt.\nThis option is only intended for compatibility,\nand all the remaining arguments are used as a command\neven without it.\n.SH SHORTCUTS\n.TP\n.B Alt-j/k or Alt-Up/Down or Alt-Mouse Wheel\nScroll up/down one line at a time.\n.TP\n.B Alt-u/d or Alt-Page Up/Page Down\nScroll up/down one screen at a time.\n.TP\n.B Alt-Shift-k/j or Alt-Shift-Page Up/Page Down or Alt-Shift-Mouse Wheel\nIncrease or decrease font size.\n.TP\n.B Alt-Home\nReset to default font size.\n.TP\n.B Shift-Insert or Alt-v\nPaste from clipboard.\n.TP\n.B Alt-c\nCopy to clipboard.\n.TP\n.B Alt-p\nPaste/input primary selection.\n.TP\n.B Alt-l\nShow dmenu menu of all URLs on screen and choose one to open.\n.TP\n.B Alt-y\nShow dmenu menu of all URLs on screen and choose one to copy.\n.TP\n.B Alt-o\nShow dmenu menu of all recently run commands and copy the output of the chosen command to the clipboard.\n.I xclip\nrequired.\n.TP\n.B Alt-a/s\nIncrease or decrease opacity/alpha value (make window more or less transparent).\n.TP\n.B Break\nSend a break in the serial line.\nBreak key is obtained in PC keyboards\npressing at the same time control and pause.\n.TP\n.B Ctrl-Print Screen\nToggle if st should print to the\n.I iofile.\n.TP\n.B Shift-Print Screen\nPrint the full screen to the\n.I iofile.\n.TP\n.B Print Screen\nPrint the selection to the\n.I iofile.\n.SH CUSTOMIZATION\n.B st\ncan be customized by creating a custom config.h and (re)compiling the source\ncode. This keeps it fast, secure and simple.\n.SH AUTHORS\nSee the LICENSE file for the authors.\n.SH LICENSE\nSee the LICENSE file for the terms of redistribution.\n.SH SEE ALSO\n.BR tabbed (1),\n.BR utmp (1),\n.BR stty (1),\n.BR scroll (1)\n.SH BUGS\nSee the TODO file in the distribution.\n"
        },
        {
          "name": "st.c",
          "type": "blob",
          "size": 58.9814453125,
          "content": "/* See LICENSE for license details. */\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <termios.h>\n#include <unistd.h>\n#include <wchar.h>\n\n#include \"st.h\"\n#include \"win.h\"\n\n#if   defined(__linux)\n #include <pty.h>\n#elif defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)\n #include <util.h>\n#elif defined(__FreeBSD__) || defined(__DragonFly__)\n #include <libutil.h>\n#endif\n\n/* Arbitrary sizes */\n#define UTF_INVALID   0xFFFD\n#define UTF_SIZ       4\n#define ESC_BUF_SIZ   (128*UTF_SIZ)\n#define ESC_ARG_SIZ   16\n#define STR_BUF_SIZ   ESC_BUF_SIZ\n#define STR_ARG_SIZ   ESC_ARG_SIZ\n#define HISTSIZE      2000\n\n/* macros */\n#define IS_SET(flag)\t\t((term.mode & (flag)) != 0)\n#define ISCONTROLC0(c)\t\t(BETWEEN(c, 0, 0x1f) || (c) == 0x7f)\n#define ISCONTROLC1(c)\t\t(BETWEEN(c, 0x80, 0x9f))\n#define ISCONTROL(c)\t\t(ISCONTROLC0(c) || ISCONTROLC1(c))\n#define ISDELIM(u)\t\t(u && wcschr(worddelimiters, u))\n#define TLINE(y)\t\t((y) < term.scr ? term.hist[((y) + term.histi - \\\n\t\t\t\tterm.scr + HISTSIZE + 1) % HISTSIZE] : \\\n\t\t\t\tterm.line[(y) - term.scr])\n#define TLINE_HIST(y)           ((y) <= HISTSIZE-term.row+2 ? term.hist[(y)] : term.line[(y-HISTSIZE+term.row-3)])\n\nenum term_mode {\n\tMODE_WRAP        = 1 << 0,\n\tMODE_INSERT      = 1 << 1,\n\tMODE_ALTSCREEN   = 1 << 2,\n\tMODE_CRLF        = 1 << 3,\n\tMODE_ECHO        = 1 << 4,\n\tMODE_PRINT       = 1 << 5,\n\tMODE_UTF8        = 1 << 6,\n};\n\nenum cursor_movement {\n\tCURSOR_SAVE,\n\tCURSOR_LOAD\n};\n\nenum cursor_state {\n\tCURSOR_DEFAULT  = 0,\n\tCURSOR_WRAPNEXT = 1,\n\tCURSOR_ORIGIN   = 2\n};\n\nenum charset {\n\tCS_GRAPHIC0,\n\tCS_GRAPHIC1,\n\tCS_UK,\n\tCS_USA,\n\tCS_MULTI,\n\tCS_GER,\n\tCS_FIN\n};\n\nenum escape_state {\n\tESC_START      = 1,\n\tESC_CSI        = 2,\n\tESC_STR        = 4,  /* DCS, OSC, PM, APC */\n\tESC_ALTCHARSET = 8,\n\tESC_STR_END    = 16, /* a final string was encountered */\n\tESC_TEST       = 32, /* Enter in test mode */\n\tESC_UTF8       = 64,\n};\n\ntypedef struct {\n\tGlyph attr; /* current char attributes */\n\tint x;\n\tint y;\n\tchar state;\n} TCursor;\n\ntypedef struct {\n\tint mode;\n\tint type;\n\tint snap;\n\t/*\n\t * Selection variables:\n\t * nb – normalized coordinates of the beginning of the selection\n\t * ne – normalized coordinates of the end of the selection\n\t * ob – original coordinates of the beginning of the selection\n\t * oe – original coordinates of the end of the selection\n\t */\n\tstruct {\n\t\tint x, y;\n\t} nb, ne, ob, oe;\n\n\tint alt;\n} Selection;\n\n/* Internal representation of the screen */\ntypedef struct {\n\tint row;      /* nb row */\n\tint col;      /* nb col */\n\tint maxcol;\n\tLine *line;   /* screen */\n\tLine *alt;    /* alternate screen */\n\tLine hist[HISTSIZE]; /* history buffer */\n\tint histi;    /* history index */\n\tint scr;      /* scroll back */\n\tint *dirty;   /* dirtyness of lines */\n\tTCursor c;    /* cursor */\n\tint ocx;      /* old cursor col */\n\tint ocy;      /* old cursor row */\n\tint top;      /* top    scroll limit */\n\tint bot;      /* bottom scroll limit */\n\tint mode;     /* terminal mode flags */\n\tint esc;      /* escape state flags */\n\tchar trantbl[4]; /* charset table translation */\n\tint charset;  /* current charset */\n\tint icharset; /* selected charset for sequence */\n\tint *tabs;\n\tRune lastc;   /* last printed char outside of sequence, 0 if control */\n} Term;\n\n/* CSI Escape sequence structs */\n/* ESC '[' [[ [<priv>] <arg> [;]] <mode> [<mode>]] */\ntypedef struct {\n\tchar buf[ESC_BUF_SIZ]; /* raw string */\n\tsize_t len;            /* raw string length */\n\tchar priv;\n\tint arg[ESC_ARG_SIZ];\n\tint narg;              /* nb of args */\n\tchar mode[2];\n} CSIEscape;\n\n/* STR Escape sequence structs */\n/* ESC type [[ [<priv>] <arg> [;]] <mode>] ESC '\\' */\ntypedef struct {\n\tchar type;             /* ESC type ... */\n\tchar *buf;             /* allocated raw string */\n\tsize_t siz;            /* allocation size */\n\tsize_t len;            /* raw string length */\n\tchar *args[STR_ARG_SIZ];\n\tint narg;              /* nb of args */\n} STREscape;\n\nstatic void execsh(char *, char **);\nstatic void stty(char **);\nstatic void sigchld(int);\nstatic void ttywriteraw(const char *, size_t);\n\nstatic void csidump(void);\nstatic void csihandle(void);\nstatic void csiparse(void);\nstatic void csireset(void);\nstatic void osc_color_response(int, int, int);\nstatic int eschandle(uchar);\nstatic void strdump(void);\nstatic void strhandle(void);\nstatic void strparse(void);\nstatic void strreset(void);\n\nstatic void tprinter(char *, size_t);\nstatic void tdumpsel(void);\nstatic void tdumpline(int);\nstatic void tdump(void);\nstatic void tclearregion(int, int, int, int);\nstatic void tcursor(int);\nstatic void tdeletechar(int);\nstatic void tdeleteline(int);\nstatic void tinsertblank(int);\nstatic void tinsertblankline(int);\nstatic int tlinelen(int);\nstatic void tmoveto(int, int);\nstatic void tmoveato(int, int);\nstatic void tnewline(int);\nstatic void tputtab(int);\nstatic void tputc(Rune);\nstatic void treset(void);\nstatic void tscrollup(int, int, int);\nstatic void tscrolldown(int, int, int);\nstatic void tsetattr(const int *, int);\nstatic void tsetchar(Rune, const Glyph *, int, int);\nstatic void tsetdirt(int, int);\nstatic void tsetscroll(int, int);\nstatic void tswapscreen(void);\nstatic void tsetmode(int, int, const int *, int);\nstatic int twrite(const char *, int, int);\nstatic void tcontrolcode(uchar );\nstatic void tdectest(char );\nstatic void tdefutf8(char);\nstatic int32_t tdefcolor(const int *, int *, int);\nstatic void tdeftran(char);\nstatic void tstrsequence(uchar);\n\nstatic void drawregion(int, int, int, int);\n\nstatic void selnormalize(void);\nstatic void selscroll(int, int);\nstatic void selsnap(int *, int *, int);\n\nstatic size_t utf8decode(const char *, Rune *, size_t);\nstatic Rune utf8decodebyte(char, size_t *);\nstatic char utf8encodebyte(Rune, size_t);\nstatic size_t utf8validate(Rune *, size_t);\n\nstatic char *base64dec(const char *);\nstatic char base64dec_getc(const char **);\n\nstatic ssize_t xwrite(int, const char *, size_t);\n\n/* Globals */\nstatic Term term;\nstatic Selection sel;\nstatic CSIEscape csiescseq;\nstatic STREscape strescseq;\nstatic int iofd = 1;\nstatic int cmdfd;\nstatic pid_t pid;\n\nstatic const uchar utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};\nstatic const uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};\nstatic const Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};\nstatic const Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};\n\nssize_t\nxwrite(int fd, const char *s, size_t len)\n{\n\tsize_t aux = len;\n\tssize_t r;\n\n\twhile (len > 0) {\n\t\tr = write(fd, s, len);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tlen -= r;\n\t\ts += r;\n\t}\n\n\treturn aux;\n}\n\nvoid *\nxmalloc(size_t len)\n{\n\tvoid *p;\n\n\tif (!(p = malloc(len)))\n\t\tdie(\"malloc: %s\\n\", strerror(errno));\n\n\treturn p;\n}\n\nvoid *\nxrealloc(void *p, size_t len)\n{\n\tif ((p = realloc(p, len)) == NULL)\n\t\tdie(\"realloc: %s\\n\", strerror(errno));\n\n\treturn p;\n}\n\nchar *\nxstrdup(const char *s)\n{\n\tif ((s = strdup(s)) == NULL)\n\t\tdie(\"strdup: %s\\n\", strerror(errno));\n\tchar *p;\n\n\tif ((p = strdup(s)) == NULL)\n\t\tdie(\"strdup: %s\\n\", strerror(errno));\n\n\treturn p;\n}\n\nsize_t\nutf8decode(const char *c, Rune *u, size_t clen)\n{\n\tsize_t i, j, len, type;\n\tRune udecoded;\n\n\t*u = UTF_INVALID;\n\tif (!clen)\n\t\treturn 0;\n\tudecoded = utf8decodebyte(c[0], &len);\n\tif (!BETWEEN(len, 1, UTF_SIZ))\n\t\treturn 1;\n\tfor (i = 1, j = 1; i < clen && j < len; ++i, ++j) {\n\t\tudecoded = (udecoded << 6) | utf8decodebyte(c[i], &type);\n\t\tif (type != 0)\n\t\t\treturn j;\n\t}\n\tif (j < len)\n\t\treturn 0;\n\t*u = udecoded;\n\tutf8validate(u, len);\n\n\treturn len;\n}\n\nRune\nutf8decodebyte(char c, size_t *i)\n{\n\tfor (*i = 0; *i < LEN(utfmask); ++(*i))\n\t\tif (((uchar)c & utfmask[*i]) == utfbyte[*i])\n\t\t\treturn (uchar)c & ~utfmask[*i];\n\n\treturn 0;\n}\n\nsize_t\nutf8encode(Rune u, char *c)\n{\n\tsize_t len, i;\n\n\tlen = utf8validate(&u, 0);\n\tif (len > UTF_SIZ)\n\t\treturn 0;\n\n\tfor (i = len - 1; i != 0; --i) {\n\t\tc[i] = utf8encodebyte(u, 0);\n\t\tu >>= 6;\n\t}\n\tc[0] = utf8encodebyte(u, len);\n\n\treturn len;\n}\n\nchar\nutf8encodebyte(Rune u, size_t i)\n{\n\treturn utfbyte[i] | (u & ~utfmask[i]);\n}\n\nsize_t\nutf8validate(Rune *u, size_t i)\n{\n\tif (!BETWEEN(*u, utfmin[i], utfmax[i]) || BETWEEN(*u, 0xD800, 0xDFFF))\n\t\t*u = UTF_INVALID;\n\tfor (i = 1; *u > utfmax[i]; ++i)\n\t\t;\n\n\treturn i;\n}\n\nchar\nbase64dec_getc(const char **src)\n{\n\twhile (**src && !isprint((unsigned char)**src))\n\t\t(*src)++;\n\treturn **src ? *((*src)++) : '=';  /* emulate padding if string ends */\n}\n\nchar *\nbase64dec(const char *src)\n{\n\tsize_t in_len = strlen(src);\n\tchar *result, *dst;\n\tstatic const char base64_digits[256] = {\n\t\t[43] = 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n\t\t0, 0, 0, -1, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n\t\t13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0,\n\t\t0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n\t\t40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n\t};\n\n\tif (in_len % 4)\n\t\tin_len += 4 - (in_len % 4);\n\tresult = dst = xmalloc(in_len / 4 * 3 + 1);\n\twhile (*src) {\n\t\tint a = base64_digits[(unsigned char) base64dec_getc(&src)];\n\t\tint b = base64_digits[(unsigned char) base64dec_getc(&src)];\n\t\tint c = base64_digits[(unsigned char) base64dec_getc(&src)];\n\t\tint d = base64_digits[(unsigned char) base64dec_getc(&src)];\n\n\t\t/* invalid input. 'a' can be -1, e.g. if src is \"\\n\" (c-str) */\n\t\tif (a == -1 || b == -1)\n\t\t\tbreak;\n\n\t\t*dst++ = (a << 2) | ((b & 0x30) >> 4);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\t*dst++ = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);\n\t\tif (d == -1)\n\t\t\tbreak;\n\t\t*dst++ = ((c & 0x03) << 6) | d;\n\t}\n\t*dst = '\\0';\n\treturn result;\n}\n\nvoid\nselinit(void)\n{\n\tsel.mode = SEL_IDLE;\n\tsel.snap = 0;\n\tsel.ob.x = -1;\n}\n\nint\ntlinelen(int y)\n{\n\tint i = term.col;\n\n\tif (TLINE(y)[i - 1].mode & ATTR_WRAP)\n\t\treturn i;\n\n\twhile (i > 0 && TLINE(y)[i - 1].u == ' ')\n\t\t--i;\n\n\treturn i;\n}\n\nint\ntlinehistlen(int y)\n{\n\tint i = term.col;\n\n\tif (TLINE_HIST(y)[i - 1].mode & ATTR_WRAP)\n\t\treturn i;\n\n\twhile (i > 0 && TLINE_HIST(y)[i - 1].u == ' ')\n\t\t--i;\n\n\treturn i;\n}\n\nvoid\nselstart(int col, int row, int snap)\n{\n\tselclear();\n\tsel.mode = SEL_EMPTY;\n\tsel.type = SEL_REGULAR;\n\tsel.alt = IS_SET(MODE_ALTSCREEN);\n\tsel.snap = snap;\n\tsel.oe.x = sel.ob.x = col;\n\tsel.oe.y = sel.ob.y = row;\n\tselnormalize();\n\n\tif (sel.snap != 0)\n\t\tsel.mode = SEL_READY;\n\ttsetdirt(sel.nb.y, sel.ne.y);\n}\n\nvoid\nselextend(int col, int row, int type, int done)\n{\n\tint oldey, oldex, oldsby, oldsey, oldtype;\n\n\tif (sel.mode == SEL_IDLE)\n\t\treturn;\n\tif (done && sel.mode == SEL_EMPTY) {\n\t\tselclear();\n\t\treturn;\n\t}\n\n\toldey = sel.oe.y;\n\toldex = sel.oe.x;\n\toldsby = sel.nb.y;\n\toldsey = sel.ne.y;\n\toldtype = sel.type;\n\n\tsel.oe.x = col;\n\tsel.oe.y = row;\n\tselnormalize();\n\tsel.type = type;\n\n\tif (oldey != sel.oe.y || oldex != sel.oe.x || oldtype != sel.type || sel.mode == SEL_EMPTY)\n\t\ttsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey));\n\n\tsel.mode = done ? SEL_IDLE : SEL_READY;\n}\n\n\nvoid\nselnormalize(void)\n{\n\tint i;\n\n\tif (sel.type == SEL_REGULAR && sel.ob.y != sel.oe.y) {\n\t\tsel.nb.x = sel.ob.y < sel.oe.y ? sel.ob.x : sel.oe.x;\n\t\tsel.ne.x = sel.ob.y < sel.oe.y ? sel.oe.x : sel.ob.x;\n\t} else {\n\t\tsel.nb.x = MIN(sel.ob.x, sel.oe.x);\n\t\tsel.ne.x = MAX(sel.ob.x, sel.oe.x);\n\t}\n\tsel.nb.y = MIN(sel.ob.y, sel.oe.y);\n\tsel.ne.y = MAX(sel.ob.y, sel.oe.y);\n\n\tselsnap(&sel.nb.x, &sel.nb.y, -1);\n\tselsnap(&sel.ne.x, &sel.ne.y, +1);\n\n\t/* expand selection over line breaks */\n\tif (sel.type == SEL_RECTANGULAR)\n\t\treturn;\n\ti = tlinelen(sel.nb.y);\n\tif (i < sel.nb.x)\n\t\tsel.nb.x = i;\n\tif (tlinelen(sel.ne.y) <= sel.ne.x)\n\t\tsel.ne.x = term.col - 1;\n}\n\nint\nselected(int x, int y)\n{\n\tif (sel.mode == SEL_EMPTY || sel.ob.x == -1 ||\n\t\t\tsel.alt != IS_SET(MODE_ALTSCREEN))\n\t\treturn 0;\n\n\tif (sel.type == SEL_RECTANGULAR)\n\t\treturn BETWEEN(y, sel.nb.y, sel.ne.y)\n\t\t    && BETWEEN(x, sel.nb.x, sel.ne.x);\n\n\treturn BETWEEN(y, sel.nb.y, sel.ne.y)\n\t    && (y != sel.nb.y || x >= sel.nb.x)\n\t    && (y != sel.ne.y || x <= sel.ne.x);\n}\n\nvoid\nselsnap(int *x, int *y, int direction)\n{\n\tint newx, newy, xt, yt;\n\tint delim, prevdelim;\n\tconst Glyph *gp, *prevgp;\n\n\tswitch (sel.snap) {\n\tcase SNAP_WORD:\n\t\t/*\n\t\t * Snap around if the word wraps around at the end or\n\t\t * beginning of a line.\n\t\t */\n\t\tprevgp = &TLINE(*y)[*x];\n\t\tprevdelim = ISDELIM(prevgp->u);\n\t\tfor (;;) {\n\t\t\tnewx = *x + direction;\n\t\t\tnewy = *y;\n\t\t\tif (!BETWEEN(newx, 0, term.col - 1)) {\n\t\t\t\tnewy += direction;\n\t\t\t\tnewx = (newx + term.col) % term.col;\n\t\t\t\tif (!BETWEEN(newy, 0, term.row - 1))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (direction > 0)\n\t\t\t\t\tyt = *y, xt = *x;\n\t\t\t\telse\n\t\t\t\t\tyt = newy, xt = newx;\n\t\t\t\tif (!(TLINE(yt)[xt].mode & ATTR_WRAP))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (newx >= tlinelen(newy))\n\t\t\t\tbreak;\n\n\t\t\tgp = &TLINE(newy)[newx];\n\t\t\tdelim = ISDELIM(gp->u);\n\t\t\tif (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim\n\t\t\t\t\t|| (delim && gp->u != prevgp->u)))\n\t\t\t\tbreak;\n\n\t\t\t*x = newx;\n\t\t\t*y = newy;\n\t\t\tprevgp = gp;\n\t\t\tprevdelim = delim;\n\t\t}\n\t\tbreak;\n\tcase SNAP_LINE:\n\t\t/*\n\t\t * Snap around if the the previous line or the current one\n\t\t * has set ATTR_WRAP at its end. Then the whole next or\n\t\t * previous line will be selected.\n\t\t */\n\t\t*x = (direction < 0) ? 0 : term.col - 1;\n\t\tif (direction < 0) {\n\t\t\tfor (; *y > 0; *y += direction) {\n\t\t\t\tif (!(TLINE(*y-1)[term.col-1].mode\n\t\t\t\t\t\t& ATTR_WRAP)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (direction > 0) {\n\t\t\tfor (; *y < term.row-1; *y += direction) {\n\t\t\t\tif (!(TLINE(*y)[term.col-1].mode\n\t\t\t\t\t\t& ATTR_WRAP)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nchar *\ngetsel(void)\n{\n\tchar *str, *ptr;\n\tint y, bufsize, lastx, linelen;\n\tconst Glyph *gp, *last;\n\n\tif (sel.ob.x == -1)\n\t\treturn NULL;\n\n\tbufsize = (term.col+1) * (sel.ne.y-sel.nb.y+1) * UTF_SIZ;\n\tptr = str = xmalloc(bufsize);\n\n\t/* append every set & selected glyph to the selection */\n\tfor (y = sel.nb.y; y <= sel.ne.y; y++) {\n\t\tif ((linelen = tlinelen(y)) == 0) {\n\t\t\t*ptr++ = '\\n';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sel.type == SEL_RECTANGULAR) {\n\t\t\tgp = &TLINE(y)[sel.nb.x];\n\t\t\tlastx = sel.ne.x;\n\t\t} else {\n\t\t\tgp = &TLINE(y)[sel.nb.y == y ? sel.nb.x : 0];\n\t\t\tlastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;\n\t\t}\n\t\tlast = &TLINE(y)[MIN(lastx, linelen-1)];\n\t\twhile (last >= gp && last->u == ' ')\n\t\t\t--last;\n\n\t\tfor ( ; gp <= last; ++gp) {\n\t\t\tif (gp->mode & ATTR_WDUMMY)\n\t\t\t\tcontinue;\n\n\t\t\tptr += utf8encode(gp->u, ptr);\n\t\t}\n\n\t\t/*\n\t\t * Copy and pasting of line endings is inconsistent\n\t\t * in the inconsistent terminal and GUI world.\n\t\t * The best solution seems like to produce '\\n' when\n\t\t * something is copied from st and convert '\\n' to\n\t\t * '\\r', when something to be pasted is received by\n\t\t * st.\n\t\t * FIXME: Fix the computer world.\n\t\t */\n\t\tif ((y < sel.ne.y || lastx >= linelen) &&\n\t\t    (!(last->mode & ATTR_WRAP) || sel.type == SEL_RECTANGULAR))\n\t\t\t*ptr++ = '\\n';\n\t}\n\t*ptr = 0;\n\treturn str;\n}\n\nvoid\nselclear(void)\n{\n\tif (sel.ob.x == -1)\n\t\treturn;\n\tsel.mode = SEL_IDLE;\n\tsel.ob.x = -1;\n\ttsetdirt(sel.nb.y, sel.ne.y);\n}\n\nvoid\ndie(const char *errstr, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, errstr);\n\tvfprintf(stderr, errstr, ap);\n\tva_end(ap);\n\texit(1);\n}\n\nvoid\nexecsh(char *cmd, char **args)\n{\n\tchar *sh, *prog, *arg;\n\tconst struct passwd *pw;\n\n\terrno = 0;\n\tif ((pw = getpwuid(getuid())) == NULL) {\n\t\tif (errno)\n\t\t\tdie(\"getpwuid: %s\\n\", strerror(errno));\n\t\telse\n\t\t\tdie(\"who are you?\\n\");\n\t}\n\n\tif ((sh = getenv(\"SHELL\")) == NULL)\n\t\tsh = (pw->pw_shell[0]) ? pw->pw_shell : cmd;\n\n\tif (args) {\n\t\tprog = args[0];\n\t\targ = NULL;\n\t} else if (scroll) {\n\t\tprog = scroll;\n\t\targ = utmp ? utmp : sh;\n\t} else if (utmp) {\n\t\tprog = utmp;\n\t\targ = NULL;\n\t} else {\n\t\tprog = sh;\n\t\targ = NULL;\n\t}\n\tDEFAULT(args, ((char *[]) {prog, arg, NULL}));\n\n\tunsetenv(\"COLUMNS\");\n\tunsetenv(\"LINES\");\n\tunsetenv(\"TERMCAP\");\n\tsetenv(\"LOGNAME\", pw->pw_name, 1);\n\tsetenv(\"USER\", pw->pw_name, 1);\n\tsetenv(\"SHELL\", sh, 1);\n\tsetenv(\"HOME\", pw->pw_dir, 1);\n\tsetenv(\"TERM\", termname, 1);\n\n\tsignal(SIGCHLD, SIG_DFL);\n\tsignal(SIGHUP, SIG_DFL);\n\tsignal(SIGINT, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tsignal(SIGTERM, SIG_DFL);\n\tsignal(SIGALRM, SIG_DFL);\n\n\texecvp(prog, args);\n\t_exit(1);\n}\n\nvoid\nsigchld(int a)\n{\n\tint stat;\n\tpid_t p;\n\n\tif ((p = waitpid(pid, &stat, WNOHANG)) < 0)\n\t\tdie(\"waiting for pid %hd failed: %s\\n\", pid, strerror(errno));\n\n\tif (pid != p)\n\t\treturn;\n\n\tif (WIFEXITED(stat) && WEXITSTATUS(stat))\n\t\tdie(\"child exited with status %d\\n\", WEXITSTATUS(stat));\n\telse if (WIFSIGNALED(stat))\n\t\tdie(\"child terminated due to signal %d\\n\", WTERMSIG(stat));\n\t_exit(0);\n}\n\nvoid\nstty(char **args)\n{\n\tchar cmd[_POSIX_ARG_MAX], **p, *q, *s;\n\tsize_t n, siz;\n\n\tif ((n = strlen(stty_args)) > sizeof(cmd)-1)\n\t\tdie(\"incorrect stty parameters\\n\");\n\tmemcpy(cmd, stty_args, n);\n\tq = cmd + n;\n\tsiz = sizeof(cmd) - n;\n\tfor (p = args; p && (s = *p); ++p) {\n\t\tif ((n = strlen(s)) > siz-1)\n\t\t\tdie(\"stty parameter length too long\\n\");\n\t\t*q++ = ' ';\n\t\tmemcpy(q, s, n);\n\t\tq += n;\n\t\tsiz -= n + 1;\n\t}\n\t*q = '\\0';\n\tif (system(cmd) != 0)\n\t\tperror(\"Couldn't call stty\");\n}\n\nint\nttynew(const char *line, char *cmd, const char *out, char **args)\n{\n\tint m, s;\n\n\tif (out) {\n\t\tterm.mode |= MODE_PRINT;\n\t\tiofd = (!strcmp(out, \"-\")) ?\n\t\t\t  1 : open(out, O_WRONLY | O_CREAT, 0666);\n\t\tif (iofd < 0) {\n\t\t\tfprintf(stderr, \"Error opening %s:%s\\n\",\n\t\t\t\tout, strerror(errno));\n\t\t}\n\t}\n\n\tif (line) {\n\t\tif ((cmdfd = open(line, O_RDWR)) < 0)\n\t\t\tdie(\"open line '%s' failed: %s\\n\",\n\t\t\t    line, strerror(errno));\n\t\tdup2(cmdfd, 0);\n\t\tstty(args);\n\t\treturn cmdfd;\n\t}\n\n\t/* seems to work fine on linux, openbsd and freebsd */\n\tif (openpty(&m, &s, NULL, NULL, NULL) < 0)\n\t\tdie(\"openpty failed: %s\\n\", strerror(errno));\n\n\tswitch (pid = fork()) {\n\tcase -1:\n\t\tdie(\"fork failed: %s\\n\", strerror(errno));\n\t\tbreak;\n\tcase 0:\n\t\tclose(iofd);\n\t\tclose(m);\n\t\tsetsid(); /* create a new process group */\n\t\tdup2(s, 0);\n\t\tdup2(s, 1);\n\t\tdup2(s, 2);\n\t\tif (ioctl(s, TIOCSCTTY, NULL) < 0)\n\t\t\tdie(\"ioctl TIOCSCTTY failed: %s\\n\", strerror(errno));\n\t\tif (s > 2)\n\t\t\tclose(s);\n#ifdef __OpenBSD__\n\t\tif (pledge(\"stdio getpw proc exec\", NULL) == -1)\n\t\t\tdie(\"pledge\\n\");\n#endif\n\t\texecsh(cmd, args);\n\t\tbreak;\n\tdefault:\n#ifdef __OpenBSD__\n\t\tif (pledge(\"stdio rpath tty proc\", NULL) == -1)\n\t\t\tdie(\"pledge\\n\");\n#endif\n\t\tclose(s);\n\t\tcmdfd = m;\n\t\tsignal(SIGCHLD, sigchld);\n\t\tbreak;\n\t}\n\treturn cmdfd;\n}\n\nsize_t\nttyread(void)\n{\n\tstatic char buf[BUFSIZ];\n\tstatic int buflen = 0;\n\tint ret, written;\n\n\t/* append read bytes to unprocessed bytes */\n\tret = read(cmdfd, buf+buflen, LEN(buf)-buflen);\n\n\tswitch (ret) {\n\tcase 0:\n\t\texit(0);\n\tcase -1:\n\t\tdie(\"couldn't read from shell: %s\\n\", strerror(errno));\n\tdefault:\n\t\tbuflen += ret;\n\t\twritten = twrite(buf, buflen, 0);\n\t\tbuflen -= written;\n\t\t/* keep any incomplete UTF-8 byte sequence for the next call */\n\t\tif (buflen > 0)\n\t\t\tmemmove(buf, buf + written, buflen);\n\t\treturn ret;\n\t}\n}\n\nvoid\nttywrite(const char *s, size_t n, int may_echo)\n{\n\tconst char *next;\n\tArg arg = (Arg) { .i = term.scr };\n\n\tkscrolldown(&arg);\n\n\tif (may_echo && IS_SET(MODE_ECHO))\n\t\ttwrite(s, n, 1);\n\n\tif (!IS_SET(MODE_CRLF)) {\n\t\tttywriteraw(s, n);\n\t\treturn;\n\t}\n\n\t/* This is similar to how the kernel handles ONLCR for ttys */\n\twhile (n > 0) {\n\t\tif (*s == '\\r') {\n\t\t\tnext = s + 1;\n\t\t\tttywriteraw(\"\\r\\n\", 2);\n\t\t} else {\n\t\t\tnext = memchr(s, '\\r', n);\n\t\t\tDEFAULT(next, s + n);\n\t\t\tttywriteraw(s, next - s);\n\t\t}\n\t\tn -= next - s;\n\t\ts = next;\n\t}\n}\n\nvoid\nttywriteraw(const char *s, size_t n)\n{\n\tfd_set wfd, rfd;\n\tssize_t r;\n\tsize_t lim = 256;\n\n\t/*\n\t * Remember that we are using a pty, which might be a modem line.\n\t * Writing too much will clog the line. That's why we are doing this\n\t * dance.\n\t * FIXME: Migrate the world to Plan 9.\n\t */\n\twhile (n > 0) {\n\t\tFD_ZERO(&wfd);\n\t\tFD_ZERO(&rfd);\n\t\tFD_SET(cmdfd, &wfd);\n\t\tFD_SET(cmdfd, &rfd);\n\n\t\t/* Check if we can write. */\n\t\tif (pselect(cmdfd+1, &rfd, &wfd, NULL, NULL, NULL) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tdie(\"select failed: %s\\n\", strerror(errno));\n\t\t}\n\t\tif (FD_ISSET(cmdfd, &wfd)) {\n\t\t\t/*\n\t\t\t * Only write the bytes written by ttywrite() or the\n\t\t\t * default of 256. This seems to be a reasonable value\n\t\t\t * for a serial line. Bigger values might clog the I/O.\n\t\t\t */\n\t\t\tif ((r = write(cmdfd, s, (n < lim)? n : lim)) < 0)\n\t\t\t\tgoto write_error;\n\t\t\tif (r < n) {\n\t\t\t\t/*\n\t\t\t\t * We weren't able to write out everything.\n\t\t\t\t * This means the buffer is getting full\n\t\t\t\t * again. Empty it.\n\t\t\t\t */\n\t\t\t\tif (n < lim)\n\t\t\t\t\tlim = ttyread();\n\t\t\t\tn -= r;\n\t\t\t\ts += r;\n\t\t\t} else {\n\t\t\t\t/* All bytes have been written. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (FD_ISSET(cmdfd, &rfd))\n\t\t\tlim = ttyread();\n\t}\n\treturn;\n\nwrite_error:\n\tdie(\"write error on tty: %s\\n\", strerror(errno));\n}\n\nvoid\nttyresize(int tw, int th)\n{\n\tstruct winsize w;\n\n\tw.ws_row = term.row;\n\tw.ws_col = term.col;\n\tw.ws_xpixel = tw;\n\tw.ws_ypixel = th;\n\tif (ioctl(cmdfd, TIOCSWINSZ, &w) < 0)\n\t\tfprintf(stderr, \"Couldn't set window size: %s\\n\", strerror(errno));\n}\n\nvoid\nttyhangup(void)\n{\n\t/* Send SIGHUP to shell */\n\tkill(pid, SIGHUP);\n}\n\nint\ntattrset(int attr)\n{\n\tint i, j;\n\n\tfor (i = 0; i < term.row-1; i++) {\n\t\tfor (j = 0; j < term.col-1; j++) {\n\t\t\tif (term.line[i][j].mode & attr)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\ntsetdirt(int top, int bot)\n{\n\tint i;\n\n\tLIMIT(top, 0, term.row-1);\n\tLIMIT(bot, 0, term.row-1);\n\n\tfor (i = top; i <= bot; i++)\n\t\tterm.dirty[i] = 1;\n}\n\nvoid\ntsetdirtattr(int attr)\n{\n\tint i, j;\n\n\tfor (i = 0; i < term.row-1; i++) {\n\t\tfor (j = 0; j < term.col-1; j++) {\n\t\t\tif (term.line[i][j].mode & attr) {\n\t\t\t\ttsetdirt(i, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ntfulldirt(void)\n{\n\ttsetdirt(0, term.row-1);\n}\n\nvoid\ntcursor(int mode)\n{\n\tstatic TCursor c[2];\n\tint alt = IS_SET(MODE_ALTSCREEN);\n\n\tif (mode == CURSOR_SAVE) {\n\t\tc[alt] = term.c;\n\t} else if (mode == CURSOR_LOAD) {\n\t\tterm.c = c[alt];\n\t\ttmoveto(c[alt].x, c[alt].y);\n\t}\n}\n\nvoid\ntreset(void)\n{\n\tuint i;\n\n\tterm.c = (TCursor){{\n\t\t.mode = ATTR_NULL,\n\t\t.fg = defaultfg,\n\t\t.bg = defaultbg\n\t}, .x = 0, .y = 0, .state = CURSOR_DEFAULT};\n\n\tmemset(term.tabs, 0, term.col * sizeof(*term.tabs));\n\tfor (i = tabspaces; i < term.col; i += tabspaces)\n\t\tterm.tabs[i] = 1;\n\tterm.top = 0;\n\tterm.bot = term.row - 1;\n\tterm.mode = MODE_WRAP|MODE_UTF8;\n\tmemset(term.trantbl, CS_USA, sizeof(term.trantbl));\n\tterm.charset = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\ttmoveto(0, 0);\n\t\ttcursor(CURSOR_SAVE);\n\t\ttclearregion(0, 0, term.col-1, term.row-1);\n\t\ttswapscreen();\n\t}\n}\n\nvoid\ntnew(int col, int row)\n{\n\tterm = (Term){ .c = { .attr = { .fg = defaultfg, .bg = defaultbg } } };\n\ttresize(col, row);\n\ttreset();\n}\n\nvoid\ntswapscreen(void)\n{\n\tLine *tmp = term.line;\n\n\tterm.line = term.alt;\n\tterm.alt = tmp;\n\tterm.mode ^= MODE_ALTSCREEN;\n\ttfulldirt();\n}\n\nvoid\nkscrolldown(const Arg* a)\n{\n\tint n = a->i;\n\n\tif (n < 0)\n\t\tn = term.row + n;\n\n\tif (n > term.scr)\n\t\tn = term.scr;\n\n\tif (term.scr > 0) {\n\t\tterm.scr -= n;\n\t\tselscroll(0, -n);\n\t\ttfulldirt();\n\t}\n}\n\nvoid\nkscrollup(const Arg* a)\n{\n\tint n = a->i;\n\n\tif (n < 0)\n\t\tn = term.row + n;\n\n\tif (term.scr <= HISTSIZE-n) {\n\t\tterm.scr += n;\n\t\tselscroll(0, n);\n\t\ttfulldirt();\n\t}\n}\n\nvoid\ntscrolldown(int orig, int n, int copyhist)\n{\n\tint i;\n\tLine temp;\n\n\tLIMIT(n, 0, term.bot-orig+1);\n\n\tif (copyhist) {\n\t\tterm.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;\n\t\ttemp = term.hist[term.histi];\n\t\tterm.hist[term.histi] = term.line[term.bot];\n\t\tterm.line[term.bot] = temp;\n\t}\n\n\ttsetdirt(orig, term.bot-n);\n\ttclearregion(0, term.bot-n+1, term.col-1, term.bot);\n\n\tfor (i = term.bot; i >= orig+n; i--) {\n\t\ttemp = term.line[i];\n\t\tterm.line[i] = term.line[i-n];\n\t\tterm.line[i-n] = temp;\n\t}\n\n\tif (term.scr == 0)\n\t\tselscroll(orig, n);\n}\n\nvoid\ntscrollup(int orig, int n, int copyhist)\n{\n\tint i;\n\tLine temp;\n\n\tLIMIT(n, 0, term.bot-orig+1);\n\n\tif (copyhist) {\n\t\tterm.histi = (term.histi + 1) % HISTSIZE;\n\t\ttemp = term.hist[term.histi];\n\t\tterm.hist[term.histi] = term.line[orig];\n\t\tterm.line[orig] = temp;\n\t}\n\n\tif (term.scr > 0 && term.scr < HISTSIZE)\n\t\tterm.scr = MIN(term.scr + n, HISTSIZE-1);\n\n\ttclearregion(0, orig, term.col-1, orig+n-1);\n\ttsetdirt(orig+n, term.bot);\n\n\tfor (i = orig; i <= term.bot-n; i++) {\n\t\ttemp = term.line[i];\n\t\tterm.line[i] = term.line[i+n];\n\t\tterm.line[i+n] = temp;\n\t}\n\n\tif (term.scr == 0)\n\t\tselscroll(orig, -n);\n}\n\nvoid\nselscroll(int orig, int n)\n{\n\tif (sel.ob.x == -1)\n\t\treturn;\n\n\tif (BETWEEN(sel.nb.y, orig, term.bot) != BETWEEN(sel.ne.y, orig, term.bot)) {\n\t\tselclear();\n\t} else if (BETWEEN(sel.nb.y, orig, term.bot)) {\n\t\tsel.ob.y += n;\n\t\tsel.oe.y += n;\n\t\tif (sel.ob.y < term.top || sel.ob.y > term.bot ||\n\t\t    sel.oe.y < term.top || sel.oe.y > term.bot) {\n\t\t\tselclear();\n\t\t} else {\n\t\t\tselnormalize();\n\t\t}\n\t}\n}\n\nvoid\ntnewline(int first_col)\n{\n\tint y = term.c.y;\n\n\tif (y == term.bot) {\n\t\ttscrollup(term.top, 1, 1);\n\t} else {\n\t\ty++;\n\t}\n\ttmoveto(first_col ? 0 : term.c.x, y);\n}\n\nvoid\ncsiparse(void)\n{\n\tchar *p = csiescseq.buf, *np;\n\tlong int v;\n\n\tcsiescseq.narg = 0;\n\tif (*p == '?') {\n\t\tcsiescseq.priv = 1;\n\t\tp++;\n\t}\n\n\tcsiescseq.buf[csiescseq.len] = '\\0';\n\twhile (p < csiescseq.buf+csiescseq.len) {\n\t\tnp = NULL;\n\t\tv = strtol(p, &np, 10);\n\t\tif (np == p)\n\t\t\tv = 0;\n\t\tif (v == LONG_MAX || v == LONG_MIN)\n\t\t\tv = -1;\n\t\tcsiescseq.arg[csiescseq.narg++] = v;\n\t\tp = np;\n\t\tif (*p != ';' || csiescseq.narg == ESC_ARG_SIZ)\n\t\t\tbreak;\n\t\tp++;\n\t}\n\tcsiescseq.mode[0] = *p++;\n\tcsiescseq.mode[1] = (p < csiescseq.buf+csiescseq.len) ? *p : '\\0';\n}\n\n/* for absolute user moves, when decom is set */\nvoid\ntmoveato(int x, int y)\n{\n\ttmoveto(x, y + ((term.c.state & CURSOR_ORIGIN) ? term.top: 0));\n}\n\nvoid\ntmoveto(int x, int y)\n{\n\tint miny, maxy;\n\n\tif (term.c.state & CURSOR_ORIGIN) {\n\t\tminy = term.top;\n\t\tmaxy = term.bot;\n\t} else {\n\t\tminy = 0;\n\t\tmaxy = term.row - 1;\n\t}\n\tterm.c.state &= ~CURSOR_WRAPNEXT;\n\tterm.c.x = LIMIT(x, 0, term.col-1);\n\tterm.c.y = LIMIT(y, miny, maxy);\n}\n\nvoid\ntsetchar(Rune u, const Glyph *attr, int x, int y)\n{\n\tstatic const char *vt100_0[62] = { /* 0x41 - 0x7e */\n\t\t\"↑\", \"↓\", \"→\", \"←\", \"█\", \"▚\", \"☃\", /* A - G */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, /* H - O */\n\t\t0, 0, 0, 0, 0, 0, 0, 0, /* P - W */\n\t\t0, 0, 0, 0, 0, 0, 0, \" \", /* X - _ */\n\t\t\"◆\", \"▒\", \"␉\", \"␌\", \"␍\", \"␊\", \"°\", \"±\", /* ` - g */\n\t\t\"␤\", \"␋\", \"┘\", \"┐\", \"┌\", \"└\", \"┼\", \"⎺\", /* h - o */\n\t\t\"⎻\", \"─\", \"⎼\", \"⎽\", \"├\", \"┤\", \"┴\", \"┬\", /* p - w */\n\t\t\"│\", \"≤\", \"≥\", \"π\", \"≠\", \"£\", \"·\", /* x - ~ */\n\t};\n\n\t/*\n\t * The table is proudly stolen from rxvt.\n\t */\n\tif (term.trantbl[term.charset] == CS_GRAPHIC0 &&\n\t   BETWEEN(u, 0x41, 0x7e) && vt100_0[u - 0x41])\n\t\tutf8decode(vt100_0[u - 0x41], &u, UTF_SIZ);\n\n\tif (term.line[y][x].mode & ATTR_WIDE) {\n\t\tif (x+1 < term.col) {\n\t\t\tterm.line[y][x+1].u = ' ';\n\t\t\tterm.line[y][x+1].mode &= ~ATTR_WDUMMY;\n\t\t}\n\t} else if (term.line[y][x].mode & ATTR_WDUMMY) {\n\t\tterm.line[y][x-1].u = ' ';\n\t\tterm.line[y][x-1].mode &= ~ATTR_WIDE;\n\t}\n\n\tterm.dirty[y] = 1;\n\tterm.line[y][x] = *attr;\n\tterm.line[y][x].u = u;\n\n\tif (isboxdraw(u))\n\t\tterm.line[y][x].mode |= ATTR_BOXDRAW;\n}\n\nvoid\ntclearregion(int x1, int y1, int x2, int y2)\n{\n\tint x, y, temp;\n\tGlyph *gp;\n\n\tif (x1 > x2)\n\t\ttemp = x1, x1 = x2, x2 = temp;\n\tif (y1 > y2)\n\t\ttemp = y1, y1 = y2, y2 = temp;\n\n\tLIMIT(x1, 0, term.maxcol-1);\n\tLIMIT(x2, 0, term.maxcol-1);\n\tLIMIT(y1, 0, term.row-1);\n\tLIMIT(y2, 0, term.row-1);\n\n\tfor (y = y1; y <= y2; y++) {\n\t\tterm.dirty[y] = 1;\n\t\tfor (x = x1; x <= x2; x++) {\n\t\t\tgp = &term.line[y][x];\n\t\t\tif (selected(x, y))\n\t\t\t\tselclear();\n\t\t\tgp->fg = term.c.attr.fg;\n\t\t\tgp->bg = term.c.attr.bg;\n\t\t\tgp->mode = 0;\n\t\t\tgp->u = ' ';\n\t\t}\n\t}\n}\n\nvoid\ntdeletechar(int n)\n{\n\tint dst, src, size;\n\tGlyph *line;\n\n\tLIMIT(n, 0, term.col - term.c.x);\n\n\tdst = term.c.x;\n\tsrc = term.c.x + n;\n\tsize = term.col - src;\n\tline = term.line[term.c.y];\n\n\tmemmove(&line[dst], &line[src], size * sizeof(Glyph));\n\ttclearregion(term.col-n, term.c.y, term.col-1, term.c.y);\n}\n\nvoid\ntinsertblank(int n)\n{\n\tint dst, src, size;\n\tGlyph *line;\n\n\tLIMIT(n, 0, term.col - term.c.x);\n\n\tdst = term.c.x + n;\n\tsrc = term.c.x;\n\tsize = term.col - dst;\n\tline = term.line[term.c.y];\n\n\tmemmove(&line[dst], &line[src], size * sizeof(Glyph));\n\ttclearregion(src, term.c.y, dst - 1, term.c.y);\n}\n\nvoid\ntinsertblankline(int n)\n{\n\tif (BETWEEN(term.c.y, term.top, term.bot))\n\t\ttscrolldown(term.c.y, n, 0);\n}\n\nvoid\ntdeleteline(int n)\n{\n\tif (BETWEEN(term.c.y, term.top, term.bot))\n\t\ttscrollup(term.c.y, n, 0);\n}\n\nint32_t\ntdefcolor(const int *attr, int *npar, int l)\n{\n\tint32_t idx = -1;\n\tuint r, g, b;\n\n\tswitch (attr[*npar + 1]) {\n\tcase 2: /* direct color in RGB space */\n\t\tif (*npar + 4 >= l) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"erresc(38): Incorrect number of parameters (%d)\\n\",\n\t\t\t\t*npar);\n\t\t\tbreak;\n\t\t}\n\t\tr = attr[*npar + 2];\n\t\tg = attr[*npar + 3];\n\t\tb = attr[*npar + 4];\n\t\t*npar += 4;\n\t\tif (!BETWEEN(r, 0, 255) || !BETWEEN(g, 0, 255) || !BETWEEN(b, 0, 255))\n\t\t\tfprintf(stderr, \"erresc: bad rgb color (%u,%u,%u)\\n\",\n\t\t\t\tr, g, b);\n\t\telse\n\t\t\tidx = TRUECOLOR(r, g, b);\n\t\tbreak;\n\tcase 5: /* indexed color */\n\t\tif (*npar + 2 >= l) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"erresc(38): Incorrect number of parameters (%d)\\n\",\n\t\t\t\t*npar);\n\t\t\tbreak;\n\t\t}\n\t\t*npar += 2;\n\t\tif (!BETWEEN(attr[*npar], 0, 255))\n\t\t\tfprintf(stderr, \"erresc: bad fgcolor %d\\n\", attr[*npar]);\n\t\telse\n\t\t\tidx = attr[*npar];\n\t\tbreak;\n\tcase 0: /* implemented defined (only foreground) */\n\tcase 1: /* transparent */\n\tcase 3: /* direct color in CMY space */\n\tcase 4: /* direct color in CMYK space */\n\tdefault:\n\t\tfprintf(stderr,\n\t\t        \"erresc(38): gfx attr %d unknown\\n\", attr[*npar]);\n\t\tbreak;\n\t}\n\n\treturn idx;\n}\n\nvoid\ntsetattr(const int *attr, int l)\n{\n\tint i;\n\tint32_t idx;\n\n\tfor (i = 0; i < l; i++) {\n\t\tswitch (attr[i]) {\n\t\tcase 0:\n\t\t\tterm.c.attr.mode &= ~(\n\t\t\t\tATTR_BOLD       |\n\t\t\t\tATTR_FAINT      |\n\t\t\t\tATTR_ITALIC     |\n\t\t\t\tATTR_UNDERLINE  |\n\t\t\t\tATTR_BLINK      |\n\t\t\t\tATTR_REVERSE    |\n\t\t\t\tATTR_INVISIBLE  |\n\t\t\t\tATTR_STRUCK     );\n\t\t\tterm.c.attr.fg = defaultfg;\n\t\t\tterm.c.attr.bg = defaultbg;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tterm.c.attr.mode |= ATTR_BOLD;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tterm.c.attr.mode |= ATTR_FAINT;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tterm.c.attr.mode |= ATTR_ITALIC;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tterm.c.attr.mode |= ATTR_UNDERLINE;\n\t\t\tbreak;\n\t\tcase 5: /* slow blink */\n\t\t\t/* FALLTHROUGH */\n\t\tcase 6: /* rapid blink */\n\t\t\tterm.c.attr.mode |= ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tterm.c.attr.mode |= ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tterm.c.attr.mode |= ATTR_INVISIBLE;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tterm.c.attr.mode |= ATTR_STRUCK;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tterm.c.attr.mode &= ~(ATTR_BOLD | ATTR_FAINT);\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tterm.c.attr.mode &= ~ATTR_ITALIC;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tterm.c.attr.mode &= ~ATTR_UNDERLINE;\n\t\t\tbreak;\n\t\tcase 25:\n\t\t\tterm.c.attr.mode &= ~ATTR_BLINK;\n\t\t\tbreak;\n\t\tcase 27:\n\t\t\tterm.c.attr.mode &= ~ATTR_REVERSE;\n\t\t\tbreak;\n\t\tcase 28:\n\t\t\tterm.c.attr.mode &= ~ATTR_INVISIBLE;\n\t\t\tbreak;\n\t\tcase 29:\n\t\t\tterm.c.attr.mode &= ~ATTR_STRUCK;\n\t\t\tbreak;\n\t\tcase 38:\n\t\t\tif ((idx = tdefcolor(attr, &i, l)) >= 0)\n\t\t\t\tterm.c.attr.fg = idx;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tterm.c.attr.fg = defaultfg;\n\t\t\tbreak;\n\t\tcase 48:\n\t\t\tif ((idx = tdefcolor(attr, &i, l)) >= 0)\n\t\t\t\tterm.c.attr.bg = idx;\n\t\t\tbreak;\n\t\tcase 49:\n\t\t\tterm.c.attr.bg = defaultbg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (BETWEEN(attr[i], 30, 37)) {\n\t\t\t\tterm.c.attr.fg = attr[i] - 30;\n\t\t\t} else if (BETWEEN(attr[i], 40, 47)) {\n\t\t\t\tterm.c.attr.bg = attr[i] - 40;\n\t\t\t} else if (BETWEEN(attr[i], 90, 97)) {\n\t\t\t\tterm.c.attr.fg = attr[i] - 90 + 8;\n\t\t\t} else if (BETWEEN(attr[i], 100, 107)) {\n\t\t\t\tterm.c.attr.bg = attr[i] - 100 + 8;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"erresc(default): gfx attr %d unknown\\n\",\n\t\t\t\t\tattr[i]);\n\t\t\t\tcsidump();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\ntsetscroll(int t, int b)\n{\n\tint temp;\n\n\tLIMIT(t, 0, term.row-1);\n\tLIMIT(b, 0, term.row-1);\n\tif (t > b) {\n\t\ttemp = t;\n\t\tt = b;\n\t\tb = temp;\n\t}\n\tterm.top = t;\n\tterm.bot = b;\n}\n\nvoid\ntsetmode(int priv, int set, const int *args, int narg)\n{\n\tint alt; const int *lim;\n\n\tfor (lim = args + narg; args < lim; ++args) {\n\t\tif (priv) {\n\t\t\tswitch (*args) {\n\t\t\tcase 1: /* DECCKM -- Cursor key */\n\t\t\t\txsetmode(set, MODE_APPCURSOR);\n\t\t\t\tbreak;\n\t\t\tcase 5: /* DECSCNM -- Reverse video */\n\t\t\t\txsetmode(set, MODE_REVERSE);\n\t\t\t\tbreak;\n\t\t\tcase 6: /* DECOM -- Origin */\n\t\t\t\tMODBIT(term.c.state, set, CURSOR_ORIGIN);\n\t\t\t\ttmoveato(0, 0);\n\t\t\t\tbreak;\n\t\t\tcase 7: /* DECAWM -- Auto wrap */\n\t\t\t\tMODBIT(term.mode, set, MODE_WRAP);\n\t\t\t\tbreak;\n\t\t\tcase 0:  /* Error (IGNORED) */\n\t\t\tcase 2:  /* DECANM -- ANSI/VT52 (IGNORED) */\n\t\t\tcase 3:  /* DECCOLM -- Column  (IGNORED) */\n\t\t\tcase 4:  /* DECSCLM -- Scroll (IGNORED) */\n\t\t\tcase 8:  /* DECARM -- Auto repeat (IGNORED) */\n\t\t\tcase 18: /* DECPFF -- Printer feed (IGNORED) */\n\t\t\tcase 19: /* DECPEX -- Printer extent (IGNORED) */\n\t\t\tcase 42: /* DECNRCM -- National characters (IGNORED) */\n\t\t\tcase 12: /* att610 -- Start blinking cursor (IGNORED) */\n\t\t\t\tbreak;\n\t\t\tcase 25: /* DECTCEM -- Text Cursor Enable Mode */\n\t\t\t\txsetmode(!set, MODE_HIDE);\n\t\t\t\tbreak;\n\t\t\tcase 9:    /* X10 mouse compatibility mode */\n\t\t\t\txsetpointermotion(0);\n\t\t\t\txsetmode(0, MODE_MOUSE);\n\t\t\t\txsetmode(set, MODE_MOUSEX10);\n\t\t\t\tbreak;\n\t\t\tcase 1000: /* 1000: report button press */\n\t\t\t\txsetpointermotion(0);\n\t\t\t\txsetmode(0, MODE_MOUSE);\n\t\t\t\txsetmode(set, MODE_MOUSEBTN);\n\t\t\t\tbreak;\n\t\t\tcase 1002: /* 1002: report motion on button press */\n\t\t\t\txsetpointermotion(0);\n\t\t\t\txsetmode(0, MODE_MOUSE);\n\t\t\t\txsetmode(set, MODE_MOUSEMOTION);\n\t\t\t\tbreak;\n\t\t\tcase 1003: /* 1003: enable all mouse motions */\n\t\t\t\txsetpointermotion(set);\n\t\t\t\txsetmode(0, MODE_MOUSE);\n\t\t\t\txsetmode(set, MODE_MOUSEMANY);\n\t\t\t\tbreak;\n\t\t\tcase 1004: /* 1004: send focus events to tty */\n\t\t\t\txsetmode(set, MODE_FOCUS);\n\t\t\t\tbreak;\n\t\t\tcase 1006: /* 1006: extended reporting mode */\n\t\t\t\txsetmode(set, MODE_MOUSESGR);\n\t\t\t\tbreak;\n\t\t\tcase 1034:\n\t\t\t\txsetmode(set, MODE_8BIT);\n\t\t\t\tbreak;\n\t\t\tcase 1049: /* swap screen & set/restore cursor as xterm */\n\t\t\t\tif (!allowaltscreen)\n\t\t\t\t\tbreak;\n\t\t\t\ttcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase 47: /* swap screen */\n\t\t\tcase 1047:\n\t\t\t\tif (!allowaltscreen)\n\t\t\t\t\tbreak;\n\t\t\t\talt = IS_SET(MODE_ALTSCREEN);\n\t\t\t\tif (alt) {\n\t\t\t\t\ttclearregion(0, 0, term.col-1,\n\t\t\t\t\t\t\tterm.row-1);\n\t\t\t\t}\n\t\t\t\tif (set ^ alt) /* set is always 1 or 0 */\n\t\t\t\t\ttswapscreen();\n\t\t\t\tif (*args != 1049)\n\t\t\t\t\tbreak;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase 1048:\n\t\t\t\ttcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);\n\t\t\t\tbreak;\n\t\t\tcase 2004: /* 2004: bracketed paste mode */\n\t\t\t\txsetmode(set, MODE_BRCKTPASTE);\n\t\t\t\tbreak;\n\t\t\t/* Not implemented mouse modes. See comments there. */\n\t\t\tcase 1001: /* mouse highlight mode; can hang the\n\t\t\t\t      terminal by design when implemented. */\n\t\t\tcase 1005: /* UTF-8 mouse mode; will confuse\n\t\t\t\t      applications not supporting UTF-8\n\t\t\t\t      and luit. */\n\t\t\tcase 1015: /* urxvt mangled mouse mode; incompatible\n\t\t\t\t      and can be mistaken for other control\n\t\t\t\t      codes. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"erresc: unknown private set/reset mode %d\\n\",\n\t\t\t\t\t*args);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (*args) {\n\t\t\tcase 0:  /* Error (IGNORED) */\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\txsetmode(set, MODE_KBDLOCK);\n\t\t\t\tbreak;\n\t\t\tcase 4:  /* IRM -- Insertion-replacement */\n\t\t\t\tMODBIT(term.mode, set, MODE_INSERT);\n\t\t\t\tbreak;\n\t\t\tcase 12: /* SRM -- Send/Receive */\n\t\t\t\tMODBIT(term.mode, !set, MODE_ECHO);\n\t\t\t\tbreak;\n\t\t\tcase 20: /* LNM -- Linefeed/new line */\n\t\t\t\tMODBIT(term.mode, set, MODE_CRLF);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"erresc: unknown set/reset mode %d\\n\",\n\t\t\t\t\t*args);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ncsihandle(void)\n{\n\tchar buf[40];\n\tint len;\n\n\tswitch (csiescseq.mode[0]) {\n\tdefault:\n\tunknown:\n\t\tfprintf(stderr, \"erresc: unknown csi \");\n\t\tcsidump();\n\t\t/* die(\"\"); */\n\t\tbreak;\n\tcase '@': /* ICH -- Insert <n> blank char */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttinsertblank(csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'A': /* CUU -- Cursor <n> Up */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(term.c.x, term.c.y-csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'B': /* CUD -- Cursor <n> Down */\n\tcase 'e': /* VPR --Cursor <n> Down */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(term.c.x, term.c.y+csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'i': /* MC -- Media Copy */\n\t\tswitch (csiescseq.arg[0]) {\n\t\tcase 0:\n\t\t\ttdump();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttdumpline(term.c.y);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttdumpsel();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tterm.mode &= ~MODE_PRINT;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tterm.mode |= MODE_PRINT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'c': /* DA -- Device Attributes */\n\t\tif (csiescseq.arg[0] == 0)\n\t\t\tttywrite(vtiden, strlen(vtiden), 0);\n\t\tbreak;\n\tcase 'b': /* REP -- if last char is printable print it <n> more times */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\tif (term.lastc)\n\t\t\twhile (csiescseq.arg[0]-- > 0)\n\t\t\t\ttputc(term.lastc);\n\t\tbreak;\n\tcase 'C': /* CUF -- Cursor <n> Forward */\n\tcase 'a': /* HPR -- Cursor <n> Forward */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(term.c.x+csiescseq.arg[0], term.c.y);\n\t\tbreak;\n\tcase 'D': /* CUB -- Cursor <n> Backward */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(term.c.x-csiescseq.arg[0], term.c.y);\n\t\tbreak;\n\tcase 'E': /* CNL -- Cursor <n> Down and first col */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(0, term.c.y+csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'F': /* CPL -- Cursor <n> Up and first col */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(0, term.c.y-csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'g': /* TBC -- Tabulation clear */\n\t\tswitch (csiescseq.arg[0]) {\n\t\tcase 0: /* clear current tab stop */\n\t\t\tterm.tabs[term.c.x] = 0;\n\t\t\tbreak;\n\t\tcase 3: /* clear all the tabs */\n\t\t\tmemset(term.tabs, 0, term.col * sizeof(*term.tabs));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto unknown;\n\t\t}\n\t\tbreak;\n\tcase 'G': /* CHA -- Move to <col> */\n\tcase '`': /* HPA */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveto(csiescseq.arg[0]-1, term.c.y);\n\t\tbreak;\n\tcase 'H': /* CUP -- Move to <row> <col> */\n\tcase 'f': /* HVP */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\tDEFAULT(csiescseq.arg[1], 1);\n\t\ttmoveato(csiescseq.arg[1]-1, csiescseq.arg[0]-1);\n\t\tbreak;\n\tcase 'I': /* CHT -- Cursor Forward Tabulation <n> tab stops */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttputtab(csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'J': /* ED -- Clear screen */\n\t\tswitch (csiescseq.arg[0]) {\n\t\tcase 0: /* below */\n\t\t\ttclearregion(term.c.x, term.c.y, term.col-1, term.c.y);\n\t\t\tif (term.c.y < term.row-1) {\n\t\t\t\ttclearregion(0, term.c.y+1, term.col-1,\n\t\t\t\t\t\tterm.row-1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: /* above */\n\t\t\tif (term.c.y > 1)\n\t\t\t\ttclearregion(0, 0, term.col-1, term.c.y-1);\n\t\t\ttclearregion(0, term.c.y, term.c.x, term.c.y);\n\t\t\tbreak;\n\t\tcase 2: /* all */\n\t\t\ttclearregion(0, 0, term.col-1, term.row-1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto unknown;\n\t\t}\n\t\tbreak;\n\tcase 'K': /* EL -- Clear line */\n\t\tswitch (csiescseq.arg[0]) {\n\t\tcase 0: /* right */\n\t\t\ttclearregion(term.c.x, term.c.y, term.col-1,\n\t\t\t\t\tterm.c.y);\n\t\t\tbreak;\n\t\tcase 1: /* left */\n\t\t\ttclearregion(0, term.c.y, term.c.x, term.c.y);\n\t\t\tbreak;\n\t\tcase 2: /* all */\n\t\t\ttclearregion(0, term.c.y, term.col-1, term.c.y);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'S': /* SU -- Scroll <n> line up */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttscrollup(term.top, csiescseq.arg[0], 0);\n\t\tbreak;\n\tcase 'T': /* SD -- Scroll <n> line down */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttscrolldown(term.top, csiescseq.arg[0], 0);\n\t\tbreak;\n\tcase 'L': /* IL -- Insert <n> blank lines */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttinsertblankline(csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'l': /* RM -- Reset Mode */\n\t\ttsetmode(csiescseq.priv, 0, csiescseq.arg, csiescseq.narg);\n\t\tbreak;\n\tcase 'M': /* DL -- Delete <n> lines */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttdeleteline(csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'X': /* ECH -- Erase <n> char */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttclearregion(term.c.x, term.c.y,\n\t\t\t\tterm.c.x + csiescseq.arg[0] - 1, term.c.y);\n\t\tbreak;\n\tcase 'P': /* DCH -- Delete <n> char */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttdeletechar(csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'Z': /* CBT -- Cursor Backward Tabulation <n> tab stops */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttputtab(-csiescseq.arg[0]);\n\t\tbreak;\n\tcase 'd': /* VPA -- Move to <row> */\n\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\ttmoveato(term.c.x, csiescseq.arg[0]-1);\n\t\tbreak;\n\tcase 'h': /* SM -- Set terminal mode */\n\t\ttsetmode(csiescseq.priv, 1, csiescseq.arg, csiescseq.narg);\n\t\tbreak;\n\tcase 'm': /* SGR -- Terminal attribute (color) */\n\t\ttsetattr(csiescseq.arg, csiescseq.narg);\n\t\tbreak;\n\tcase 'n': /* DSR – Device Status Report (cursor position) */\n\t\tif (csiescseq.arg[0] == 6) {\n\t\t\tlen = snprintf(buf, sizeof(buf), \"\\033[%i;%iR\",\n\t\t\t\t\tterm.c.y+1, term.c.x+1);\n\t\t\tttywrite(buf, len, 0);\n\t\t}\n\t\tbreak;\n\tcase 'r': /* DECSTBM -- Set Scrolling Region */\n\t\tif (csiescseq.priv) {\n\t\t\tgoto unknown;\n\t\t} else {\n\t\t\tDEFAULT(csiescseq.arg[0], 1);\n\t\t\tDEFAULT(csiescseq.arg[1], term.row);\n\t\t\ttsetscroll(csiescseq.arg[0]-1, csiescseq.arg[1]-1);\n\t\t\ttmoveato(0, 0);\n\t\t}\n\t\tbreak;\n\tcase 's': /* DECSC -- Save cursor position (ANSI.SYS) */\n\t\ttcursor(CURSOR_SAVE);\n\t\tbreak;\n\tcase 'u': /* DECRC -- Restore cursor position (ANSI.SYS) */\n\t\ttcursor(CURSOR_LOAD);\n\t\tbreak;\n\tcase ' ':\n\t\tswitch (csiescseq.mode[1]) {\n\t\tcase 'q': /* DECSCUSR -- Set Cursor Style */\n\t\t\tif (xsetcursor(csiescseq.arg[0]))\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto unknown;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid\ncsidump(void)\n{\n\tsize_t i;\n\tuint c;\n\n\tfprintf(stderr, \"ESC[\");\n\tfor (i = 0; i < csiescseq.len; i++) {\n\t\tc = csiescseq.buf[i] & 0xff;\n\t\tif (isprint(c)) {\n\t\t\tputc(c, stderr);\n\t\t} else if (c == '\\n') {\n\t\t\tfprintf(stderr, \"(\\\\n)\");\n\t\t} else if (c == '\\r') {\n\t\t\tfprintf(stderr, \"(\\\\r)\");\n\t\t} else if (c == 0x1b) {\n\t\t\tfprintf(stderr, \"(\\\\e)\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"(%02x)\", c);\n\t\t}\n\t}\n\tputc('\\n', stderr);\n}\n\nvoid\ncsireset(void)\n{\n\tmemset(&csiescseq, 0, sizeof(csiescseq));\n}\n\nvoid\nosc_color_response(int num, int index, int is_osc4)\n{\n\tint n;\n\tchar buf[32];\n\tunsigned char r, g, b;\n\n\tif (xgetcolor(is_osc4 ? num : index, &r, &g, &b)) {\n\t\tfprintf(stderr, \"erresc: failed to fetch %s color %d\\n\",\n\t\t        is_osc4 ? \"osc4\" : \"osc\",\n\t\t        is_osc4 ? num : index);\n\t\treturn;\n\t}\n\n\tn = snprintf(buf, sizeof buf, \"\\033]%s%d;rgb:%02x%02x/%02x%02x/%02x%02x\\007\",\n\t             is_osc4 ? \"4;\" : \"\", num, r, r, g, g, b, b);\n\tif (n < 0 || n >= sizeof(buf)) {\n\t\tfprintf(stderr, \"error: %s while printing %s response\\n\",\n\t\t        n < 0 ? \"snprintf failed\" : \"truncation occurred\",\n\t\t        is_osc4 ? \"osc4\" : \"osc\");\n\t} else {\n\t\tttywrite(buf, n, 1);\n\t}\n}\n\nvoid\nstrhandle(void)\n{\n\tchar *p = NULL, *dec;\n\tint j, narg, par;\n\tconst struct { int idx; char *str; } osc_table[] = {\n\t\t{ defaultfg, \"foreground\" },\n\t\t{ defaultbg, \"background\" },\n\t\t{ defaultcs, \"cursor\" }\n\t};\n\n\tterm.esc &= ~(ESC_STR_END|ESC_STR);\n\tstrparse();\n\tpar = (narg = strescseq.narg) ? atoi(strescseq.args[0]) : 0;\n\n\tswitch (strescseq.type) {\n\tcase ']': /* OSC -- Operating System Command */\n\t\tswitch (par) {\n\t\tcase 0:\n\t\t\tif (narg > 1) {\n\t\t\t\txsettitle(strescseq.args[1]);\n\t\t\t\txseticontitle(strescseq.args[1]);\n\t\t\t}\n\t\t\treturn;\n\t\tcase 1:\n\t\t\tif (narg > 1)\n\t\t\t\txseticontitle(strescseq.args[1]);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tif (narg > 1)\n\t\t\t\txsettitle(strescseq.args[1]);\n\t\t\treturn;\n\t\tcase 52:\n\t\t\tif (narg > 2 && allowwindowops) {\n\t\t\t\tdec = base64dec(strescseq.args[2]);\n\t\t\t\tif (dec) {\n\t\t\t\t\txsetsel(dec);\n\t\t\t\t\txclipcopy();\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"erresc: invalid base64\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\tcase 10:\n\t\tcase 11:\n\t\tcase 12:\n\t\t\tif (narg < 2)\n\t\t\t\tbreak;\n\t\t\tp = strescseq.args[1];\n\t\t\tif ((j = par - 10) < 0 || j >= LEN(osc_table))\n\t\t\t\tbreak; /* shouldn't be possible */\n\n\t\t\tif (!strcmp(p, \"?\")) {\n\t\t\t\tosc_color_response(par, osc_table[j].idx, 0);\n\t\t\t} else if (xsetcolorname(osc_table[j].idx, p)) {\n\t\t\t\tfprintf(stderr, \"erresc: invalid %s color: %s\\n\",\n\t\t\t\t        osc_table[j].str, p);\n\t\t\t} else {\n\t\t\t\ttfulldirt();\n\t\t\t}\n\t\t\treturn;\n\t\tcase 4: /* color set */\n\t\t\tif (narg < 3)\n\t\t\t\tbreak;\n\t\t\tp = strescseq.args[2];\n\t\t\t/* FALLTHROUGH */\n\t\tcase 104: /* color reset */\n\t\t\tj = (narg > 1) ? atoi(strescseq.args[1]) : -1;\n\n\t\t\tif (p && !strcmp(p, \"?\")) {\n\t\t\t\tosc_color_response(j, 0, 1);\n\t\t\t} else if (xsetcolorname(j, p)) {\n\t\t\t\tif (par == 104 && narg <= 1)\n\t\t\t\t\treturn; /* color reset without parameter */\n\t\t\t\tfprintf(stderr, \"erresc: invalid color j=%d, p=%s\\n\",\n\t\t\t\t        j, p ? p : \"(null)\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * TODO if defaultbg color is changed, borders\n\t\t\t\t * are dirty\n\t\t\t\t */\n\t\t\t\ttfulldirt();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 'k': /* old title set compatibility */\n\t\txsettitle(strescseq.args[0]);\n\t\treturn;\n\tcase 'P': /* DCS -- Device Control String */\n\tcase '_': /* APC -- Application Program Command */\n\tcase '^': /* PM -- Privacy Message */\n\t\treturn;\n\t}\n\n\tfprintf(stderr, \"erresc: unknown str \");\n\tstrdump();\n}\n\nvoid\nstrparse(void)\n{\n\tint c;\n\tchar *p = strescseq.buf;\n\n\tstrescseq.narg = 0;\n\tstrescseq.buf[strescseq.len] = '\\0';\n\n\tif (*p == '\\0')\n\t\treturn;\n\n\twhile (strescseq.narg < STR_ARG_SIZ) {\n\t\tstrescseq.args[strescseq.narg++] = p;\n\t\twhile ((c = *p) != ';' && c != '\\0')\n\t\t\t++p;\n\t\tif (c == '\\0')\n\t\t\treturn;\n\t\t*p++ = '\\0';\n\t}\n}\n\nvoid\nexternalpipe(const Arg *arg)\n{\n\tint to[2];\n\tchar buf[UTF_SIZ];\n\tvoid (*oldsigpipe)(int);\n\tGlyph *bp, *end;\n\tint lastpos, n, newline;\n\n\tif (pipe(to) == -1)\n\t\treturn;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\tclose(to[0]);\n\t\tclose(to[1]);\n\t\treturn;\n\tcase 0:\n\t\tdup2(to[0], STDIN_FILENO);\n\t\tclose(to[0]);\n\t\tclose(to[1]);\n\t\texecvp(((char **)arg->v)[0], (char **)arg->v);\n\t\tfprintf(stderr, \"st: execvp %s\\n\", ((char **)arg->v)[0]);\n\t\tperror(\"failed\");\n\t\texit(0);\n\t}\n\n\tclose(to[0]);\n\t/* ignore sigpipe for now, in case child exists early */\n\toldsigpipe = signal(SIGPIPE, SIG_IGN);\n\tnewline = 0;\n\tfor (n = 0; n <= HISTSIZE + 2; n++) {\n\t\tbp = TLINE_HIST(n);\n\t\tlastpos = MIN(tlinehistlen(n) + 1, term.col) - 1;\n\t\tif (lastpos < 0)\n\t\t\tbreak;\n        if (lastpos == 0)\n            continue;\n\t\tend = &bp[lastpos + 1];\n\t\tfor (; bp < end; ++bp)\n\t\t\tif (xwrite(to[1], buf, utf8encode(bp->u, buf)) < 0)\n\t\t\t\tbreak;\n\t\tif ((newline = TLINE_HIST(n)[lastpos].mode & ATTR_WRAP))\n\t\t\tcontinue;\n\t\tif (xwrite(to[1], \"\\n\", 1) < 0)\n\t\t\tbreak;\n\t\tnewline = 0;\n\t}\n\tif (newline)\n\t\t(void)xwrite(to[1], \"\\n\", 1);\n\tclose(to[1]);\n\t/* restore */\n\tsignal(SIGPIPE, oldsigpipe);\n}\n\nvoid\nstrdump(void)\n{\n\tsize_t i;\n\tuint c;\n\n\tfprintf(stderr, \"ESC%c\", strescseq.type);\n\tfor (i = 0; i < strescseq.len; i++) {\n\t\tc = strescseq.buf[i] & 0xff;\n\t\tif (c == '\\0') {\n\t\t\tputc('\\n', stderr);\n\t\t\treturn;\n\t\t} else if (isprint(c)) {\n\t\t\tputc(c, stderr);\n\t\t} else if (c == '\\n') {\n\t\t\tfprintf(stderr, \"(\\\\n)\");\n\t\t} else if (c == '\\r') {\n\t\t\tfprintf(stderr, \"(\\\\r)\");\n\t\t} else if (c == 0x1b) {\n\t\t\tfprintf(stderr, \"(\\\\e)\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"(%02x)\", c);\n\t\t}\n\t}\n\tfprintf(stderr, \"ESC\\\\\\n\");\n}\n\nvoid\nstrreset(void)\n{\n\tstrescseq = (STREscape){\n\t\t.buf = xrealloc(strescseq.buf, STR_BUF_SIZ),\n\t\t.siz = STR_BUF_SIZ,\n\t};\n}\n\nvoid\nsendbreak(const Arg *arg)\n{\n\tif (tcsendbreak(cmdfd, 0))\n\t\tperror(\"Error sending break\");\n}\n\nvoid\ntprinter(char *s, size_t len)\n{\n\tif (iofd != -1 && xwrite(iofd, s, len) < 0) {\n\t\tperror(\"Error writing to output file\");\n\t\tclose(iofd);\n\t\tiofd = -1;\n\t}\n}\n\nvoid\ntoggleprinter(const Arg *arg)\n{\n\tterm.mode ^= MODE_PRINT;\n}\n\nvoid\nprintscreen(const Arg *arg)\n{\n\ttdump();\n}\n\nvoid\nprintsel(const Arg *arg)\n{\n\ttdumpsel();\n}\n\nvoid\ntdumpsel(void)\n{\n\tchar *ptr;\n\n\tif ((ptr = getsel())) {\n\t\ttprinter(ptr, strlen(ptr));\n\t\tfree(ptr);\n\t}\n}\n\nvoid\ntdumpline(int n)\n{\n\tchar buf[UTF_SIZ];\n\tconst Glyph *bp, *end;\n\n\tbp = &term.line[n][0];\n\tend = &bp[MIN(tlinelen(n), term.col) - 1];\n\tif (bp != end || bp->u != ' ') {\n\t\tfor ( ; bp <= end; ++bp)\n\t\t\ttprinter(buf, utf8encode(bp->u, buf));\n\t}\n\ttprinter(\"\\n\", 1);\n}\n\nvoid\ntdump(void)\n{\n\tint i;\n\n\tfor (i = 0; i < term.row; ++i)\n\t\ttdumpline(i);\n}\n\nvoid\ntputtab(int n)\n{\n\tuint x = term.c.x;\n\n\tif (n > 0) {\n\t\twhile (x < term.col && n--)\n\t\t\tfor (++x; x < term.col && !term.tabs[x]; ++x)\n\t\t\t\t/* nothing */ ;\n\t} else if (n < 0) {\n\t\twhile (x > 0 && n++)\n\t\t\tfor (--x; x > 0 && !term.tabs[x]; --x)\n\t\t\t\t/* nothing */ ;\n\t}\n\tterm.c.x = LIMIT(x, 0, term.col-1);\n}\n\nvoid\ntdefutf8(char ascii)\n{\n\tif (ascii == 'G')\n\t\tterm.mode |= MODE_UTF8;\n\telse if (ascii == '@')\n\t\tterm.mode &= ~MODE_UTF8;\n}\n\nvoid\ntdeftran(char ascii)\n{\n\tstatic char cs[] = \"0B\";\n\tstatic int vcs[] = {CS_GRAPHIC0, CS_USA};\n\tchar *p;\n\n\tif ((p = strchr(cs, ascii)) == NULL) {\n\t\tfprintf(stderr, \"esc unhandled charset: ESC ( %c\\n\", ascii);\n\t} else {\n\t\tterm.trantbl[term.icharset] = vcs[p - cs];\n\t}\n}\n\nvoid\ntdectest(char c)\n{\n\tint x, y;\n\n\tif (c == '8') { /* DEC screen alignment test. */\n\t\tfor (x = 0; x < term.col; ++x) {\n\t\t\tfor (y = 0; y < term.row; ++y)\n\t\t\t\ttsetchar('E', &term.c.attr, x, y);\n\t\t}\n\t}\n}\n\nvoid\ntstrsequence(uchar c)\n{\n\tswitch (c) {\n\tcase 0x90:   /* DCS -- Device Control String */\n\t\tc = 'P';\n\t\tbreak;\n\tcase 0x9f:   /* APC -- Application Program Command */\n\t\tc = '_';\n\t\tbreak;\n\tcase 0x9e:   /* PM -- Privacy Message */\n\t\tc = '^';\n\t\tbreak;\n\tcase 0x9d:   /* OSC -- Operating System Command */\n\t\tc = ']';\n\t\tbreak;\n\t}\n\tstrreset();\n\tstrescseq.type = c;\n\tterm.esc |= ESC_STR;\n}\n\nvoid\ntcontrolcode(uchar ascii)\n{\n\tswitch (ascii) {\n\tcase '\\t':   /* HT */\n\t\ttputtab(1);\n\t\treturn;\n\tcase '\\b':   /* BS */\n\t\ttmoveto(term.c.x-1, term.c.y);\n\t\treturn;\n\tcase '\\r':   /* CR */\n\t\ttmoveto(0, term.c.y);\n\t\treturn;\n\tcase '\\f':   /* LF */\n\tcase '\\v':   /* VT */\n\tcase '\\n':   /* LF */\n\t\t/* go to first col if the mode is set */\n\t\ttnewline(IS_SET(MODE_CRLF));\n\t\treturn;\n\tcase '\\a':   /* BEL */\n\t\tif (term.esc & ESC_STR_END) {\n\t\t\t/* backwards compatibility to xterm */\n\t\t\tstrhandle();\n\t\t} else {\n\t\t\txbell();\n\t\t}\n\t\tbreak;\n\tcase '\\033': /* ESC */\n\t\tcsireset();\n\t\tterm.esc &= ~(ESC_CSI|ESC_ALTCHARSET|ESC_TEST);\n\t\tterm.esc |= ESC_START;\n\t\treturn;\n\tcase '\\016': /* SO (LS1 -- Locking shift 1) */\n\tcase '\\017': /* SI (LS0 -- Locking shift 0) */\n\t\tterm.charset = 1 - (ascii - '\\016');\n\t\treturn;\n\tcase '\\032': /* SUB */\n\t\ttsetchar('?', &term.c.attr, term.c.x, term.c.y);\n\t\t/* FALLTHROUGH */\n\tcase '\\030': /* CAN */\n\t\tcsireset();\n\t\tbreak;\n\tcase '\\005': /* ENQ (IGNORED) */\n\tcase '\\000': /* NUL (IGNORED) */\n\tcase '\\021': /* XON (IGNORED) */\n\tcase '\\023': /* XOFF (IGNORED) */\n\tcase 0177:   /* DEL (IGNORED) */\n\t\treturn;\n\tcase 0x80:   /* TODO: PAD */\n\tcase 0x81:   /* TODO: HOP */\n\tcase 0x82:   /* TODO: BPH */\n\tcase 0x83:   /* TODO: NBH */\n\tcase 0x84:   /* TODO: IND */\n\t\tbreak;\n\tcase 0x85:   /* NEL -- Next line */\n\t\ttnewline(1); /* always go to first col */\n\t\tbreak;\n\tcase 0x86:   /* TODO: SSA */\n\tcase 0x87:   /* TODO: ESA */\n\t\tbreak;\n\tcase 0x88:   /* HTS -- Horizontal tab stop */\n\t\tterm.tabs[term.c.x] = 1;\n\t\tbreak;\n\tcase 0x89:   /* TODO: HTJ */\n\tcase 0x8a:   /* TODO: VTS */\n\tcase 0x8b:   /* TODO: PLD */\n\tcase 0x8c:   /* TODO: PLU */\n\tcase 0x8d:   /* TODO: RI */\n\tcase 0x8e:   /* TODO: SS2 */\n\tcase 0x8f:   /* TODO: SS3 */\n\tcase 0x91:   /* TODO: PU1 */\n\tcase 0x92:   /* TODO: PU2 */\n\tcase 0x93:   /* TODO: STS */\n\tcase 0x94:   /* TODO: CCH */\n\tcase 0x95:   /* TODO: MW */\n\tcase 0x96:   /* TODO: SPA */\n\tcase 0x97:   /* TODO: EPA */\n\tcase 0x98:   /* TODO: SOS */\n\tcase 0x99:   /* TODO: SGCI */\n\t\tbreak;\n\tcase 0x9a:   /* DECID -- Identify Terminal */\n\t\tttywrite(vtiden, strlen(vtiden), 0);\n\t\tbreak;\n\tcase 0x9b:   /* TODO: CSI */\n\tcase 0x9c:   /* TODO: ST */\n\t\tbreak;\n\tcase 0x90:   /* DCS -- Device Control String */\n\tcase 0x9d:   /* OSC -- Operating System Command */\n\tcase 0x9e:   /* PM -- Privacy Message */\n\tcase 0x9f:   /* APC -- Application Program Command */\n\t\ttstrsequence(ascii);\n\t\treturn;\n\t}\n\t/* only CAN, SUB, \\a and C1 chars interrupt a sequence */\n\tterm.esc &= ~(ESC_STR_END|ESC_STR);\n}\n\n/*\n * returns 1 when the sequence is finished and it hasn't to read\n * more characters for this sequence, otherwise 0\n */\nint\neschandle(uchar ascii)\n{\n\tswitch (ascii) {\n\tcase '[':\n\t\tterm.esc |= ESC_CSI;\n\t\treturn 0;\n\tcase '#':\n\t\tterm.esc |= ESC_TEST;\n\t\treturn 0;\n\tcase '%':\n\t\tterm.esc |= ESC_UTF8;\n\t\treturn 0;\n\tcase 'P': /* DCS -- Device Control String */\n\tcase '_': /* APC -- Application Program Command */\n\tcase '^': /* PM -- Privacy Message */\n\tcase ']': /* OSC -- Operating System Command */\n\tcase 'k': /* old title set compatibility */\n\t\ttstrsequence(ascii);\n\t\treturn 0;\n\tcase 'n': /* LS2 -- Locking shift 2 */\n\tcase 'o': /* LS3 -- Locking shift 3 */\n\t\tterm.charset = 2 + (ascii - 'n');\n\t\tbreak;\n\tcase '(': /* GZD4 -- set primary charset G0 */\n\tcase ')': /* G1D4 -- set secondary charset G1 */\n\tcase '*': /* G2D4 -- set tertiary charset G2 */\n\tcase '+': /* G3D4 -- set quaternary charset G3 */\n\t\tterm.icharset = ascii - '(';\n\t\tterm.esc |= ESC_ALTCHARSET;\n\t\treturn 0;\n\tcase 'D': /* IND -- Linefeed */\n\t\tif (term.c.y == term.bot) {\n\t\t\ttscrollup(term.top, 1, 1);\n\t\t} else {\n\t\t\ttmoveto(term.c.x, term.c.y+1);\n\t\t}\n\t\tbreak;\n\tcase 'E': /* NEL -- Next line */\n\t\ttnewline(1); /* always go to first col */\n\t\tbreak;\n\tcase 'H': /* HTS -- Horizontal tab stop */\n\t\tterm.tabs[term.c.x] = 1;\n\t\tbreak;\n\tcase 'M': /* RI -- Reverse index */\n\t\tif (term.c.y == term.top) {\n\t\t\ttscrolldown(term.top, 1, 1);\n\t\t} else {\n\t\t\ttmoveto(term.c.x, term.c.y-1);\n\t\t}\n\t\tbreak;\n\tcase 'Z': /* DECID -- Identify Terminal */\n\t\tttywrite(vtiden, strlen(vtiden), 0);\n\t\tbreak;\n\tcase 'c': /* RIS -- Reset to initial state */\n\t\ttreset();\n\t\tresettitle();\n\t\txloadcols();\n\t\tbreak;\n\tcase '=': /* DECPAM -- Application keypad */\n\t\txsetmode(1, MODE_APPKEYPAD);\n\t\tbreak;\n\tcase '>': /* DECPNM -- Normal keypad */\n\t\txsetmode(0, MODE_APPKEYPAD);\n\t\tbreak;\n\tcase '7': /* DECSC -- Save Cursor */\n\t\ttcursor(CURSOR_SAVE);\n\t\tbreak;\n\tcase '8': /* DECRC -- Restore Cursor */\n\t\ttcursor(CURSOR_LOAD);\n\t\tbreak;\n\tcase '\\\\': /* ST -- String Terminator */\n\t\tif (term.esc & ESC_STR_END)\n\t\t\tstrhandle();\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"erresc: unknown sequence ESC 0x%02X '%c'\\n\",\n\t\t\t(uchar) ascii, isprint(ascii)? ascii:'.');\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\nvoid\ntputc(Rune u)\n{\n\tchar c[UTF_SIZ];\n\tint control;\n\tint width, len;\n\tGlyph *gp;\n\n\tcontrol = ISCONTROL(u);\n\tif (u < 127 || !IS_SET(MODE_UTF8)) {\n\t\tc[0] = u;\n\t\twidth = len = 1;\n\t} else {\n\t\tlen = utf8encode(u, c);\n\t\tif (!control && (width = wcwidth(u)) == -1)\n\t\t\twidth = 1;\n\t}\n\n\tif (IS_SET(MODE_PRINT))\n\t\ttprinter(c, len);\n\n\t/*\n\t * STR sequence must be checked before anything else\n\t * because it uses all following characters until it\n\t * receives a ESC, a SUB, a ST or any other C1 control\n\t * character.\n\t */\n\tif (term.esc & ESC_STR) {\n\t\tif (u == '\\a' || u == 030 || u == 032 || u == 033 ||\n\t\t   ISCONTROLC1(u)) {\n\t\t\tterm.esc &= ~(ESC_START|ESC_STR);\n\t\t\tterm.esc |= ESC_STR_END;\n\t\t\tgoto check_control_code;\n\t\t}\n\n\t\tif (strescseq.len+len >= strescseq.siz) {\n\t\t\t/*\n\t\t\t * Here is a bug in terminals. If the user never sends\n\t\t\t * some code to stop the str or esc command, then st\n\t\t\t * will stop responding. But this is better than\n\t\t\t * silently failing with unknown characters. At least\n\t\t\t * then users will report back.\n\t\t\t *\n\t\t\t * In the case users ever get fixed, here is the code:\n\t\t\t */\n\t\t\t/*\n\t\t\t * term.esc = 0;\n\t\t\t * strhandle();\n\t\t\t */\n\t\t\tif (strescseq.siz > (SIZE_MAX - UTF_SIZ) / 2)\n\t\t\t\treturn;\n\t\t\tstrescseq.siz *= 2;\n\t\t\tstrescseq.buf = xrealloc(strescseq.buf, strescseq.siz);\n\t\t}\n\n\t\tmemmove(&strescseq.buf[strescseq.len], c, len);\n\t\tstrescseq.len += len;\n\t\treturn;\n\t}\n\ncheck_control_code:\n\t/*\n\t * Actions of control codes must be performed as soon they arrive\n\t * because they can be embedded inside a control sequence, and\n\t * they must not cause conflicts with sequences.\n\t */\n\tif (control) {\n\t\ttcontrolcode(u);\n\t\t/*\n\t\t * control codes are not shown ever\n\t\t */\n\t\tif (!term.esc)\n\t\t\tterm.lastc = 0;\n\t\treturn;\n\t} else if (term.esc & ESC_START) {\n\t\tif (term.esc & ESC_CSI) {\n\t\t\tcsiescseq.buf[csiescseq.len++] = u;\n\t\t\tif (BETWEEN(u, 0x40, 0x7E)\n\t\t\t\t\t|| csiescseq.len >= \\\n\t\t\t\t\tsizeof(csiescseq.buf)-1) {\n\t\t\t\tterm.esc = 0;\n\t\t\t\tcsiparse();\n\t\t\t\tcsihandle();\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (term.esc & ESC_UTF8) {\n\t\t\ttdefutf8(u);\n\t\t} else if (term.esc & ESC_ALTCHARSET) {\n\t\t\ttdeftran(u);\n\t\t} else if (term.esc & ESC_TEST) {\n\t\t\ttdectest(u);\n\t\t} else {\n\t\t\tif (!eschandle(u))\n\t\t\t\treturn;\n\t\t\t/* sequence already finished */\n\t\t}\n\t\tterm.esc = 0;\n\t\t/*\n\t\t * All characters which form part of a sequence are not\n\t\t * printed\n\t\t */\n\t\treturn;\n\t}\n\tif (selected(term.c.x, term.c.y))\n\t\tselclear();\n\n\tgp = &term.line[term.c.y][term.c.x];\n\tif (IS_SET(MODE_WRAP) && (term.c.state & CURSOR_WRAPNEXT)) {\n\t\tgp->mode |= ATTR_WRAP;\n\t\ttnewline(1);\n\t\tgp = &term.line[term.c.y][term.c.x];\n\t}\n\n\tif (IS_SET(MODE_INSERT) && term.c.x+width < term.col)\n\t\tmemmove(gp+width, gp, (term.col - term.c.x - width) * sizeof(Glyph));\n\n\tif (term.c.x+width > term.col) {\n\t\ttnewline(1);\n\t\tgp = &term.line[term.c.y][term.c.x];\n\t}\n\n\ttsetchar(u, &term.c.attr, term.c.x, term.c.y);\n\tterm.lastc = u;\n\n\tif (width == 2) {\n\t\tgp->mode |= ATTR_WIDE;\n\t\tif (term.c.x+1 < term.col) {\n\t\t\tif (gp[1].mode == ATTR_WIDE && term.c.x+2 < term.col) {\n\t\t\t\tgp[2].u = ' ';\n\t\t\t\tgp[2].mode &= ~ATTR_WDUMMY;\n\t\t\t}\n\t\t\tgp[1].u = '\\0';\n\t\t\tgp[1].mode = ATTR_WDUMMY;\n\t\t}\n\t}\n\tif (term.c.x+width < term.col) {\n\t\ttmoveto(term.c.x+width, term.c.y);\n\t} else {\n\t\tterm.c.state |= CURSOR_WRAPNEXT;\n\t}\n}\n\nint\ntwrite(const char *buf, int buflen, int show_ctrl)\n{\n\tint charsize;\n\tRune u;\n\tint n;\n\n\tfor (n = 0; n < buflen; n += charsize) {\n\t\tif (IS_SET(MODE_UTF8)) {\n\t\t\t/* process a complete utf8 char */\n\t\t\tcharsize = utf8decode(buf + n, &u, buflen - n);\n\t\t\tif (charsize == 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tu = buf[n] & 0xFF;\n\t\t\tcharsize = 1;\n\t\t}\n\t\tif (show_ctrl && ISCONTROL(u)) {\n\t\t\tif (u & 0x80) {\n\t\t\t\tu &= 0x7f;\n\t\t\t\ttputc('^');\n\t\t\t\ttputc('[');\n\t\t\t} else if (u != '\\n' && u != '\\r' && u != '\\t') {\n\t\t\t\tu ^= 0x40;\n\t\t\t\ttputc('^');\n\t\t\t}\n\t\t}\n\t\ttputc(u);\n\t}\n\treturn n;\n}\n\nvoid\ntresize(int col, int row)\n{\n\tint i, j;\n\tint tmp;\n\tint minrow, mincol;\n\tint *bp;\n\tTCursor c;\n\n\ttmp = col;\n\tif (!term.maxcol)\n\t\tterm.maxcol = term.col;\n\tcol = MAX(col, term.maxcol);\n\tminrow = MIN(row, term.row);\n\tmincol = MIN(col, term.maxcol);\n\n\tif (col < 1 || row < 1) {\n\t\tfprintf(stderr,\n\t\t        \"tresize: error resizing to %dx%d\\n\", col, row);\n\t\treturn;\n\t}\n\n\t/*\n\t * slide screen to keep cursor where we expect it -\n\t * tscrollup would work here, but we can optimize to\n\t * memmove because we're freeing the earlier lines\n\t */\n\tfor (i = 0; i <= term.c.y - row; i++) {\n\t\tfree(term.line[i]);\n\t\tfree(term.alt[i]);\n\t}\n\t/* ensure that both src and dst are not NULL */\n\tif (i > 0) {\n\t\tmemmove(term.line, term.line + i, row * sizeof(Line));\n\t\tmemmove(term.alt, term.alt + i, row * sizeof(Line));\n\t}\n\tfor (i += row; i < term.row; i++) {\n\t\tfree(term.line[i]);\n\t\tfree(term.alt[i]);\n\t}\n\n\t/* resize to new height */\n\tterm.line = xrealloc(term.line, row * sizeof(Line));\n\tterm.alt  = xrealloc(term.alt,  row * sizeof(Line));\n\tterm.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));\n\tterm.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));\n\n\tfor (i = 0; i < HISTSIZE; i++) {\n\t\tterm.hist[i] = xrealloc(term.hist[i], col * sizeof(Glyph));\n\t\tfor (j = mincol; j < col; j++) {\n\t\t\tterm.hist[i][j] = term.c.attr;\n\t\t\tterm.hist[i][j].u = ' ';\n\t\t}\n\t}\n\n\t/* resize each row to new width, zero-pad if needed */\n\tfor (i = 0; i < minrow; i++) {\n\t\tterm.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));\n\t\tterm.alt[i]  = xrealloc(term.alt[i],  col * sizeof(Glyph));\n\t}\n\n\t/* allocate any new rows */\n\tfor (/* i = minrow */; i < row; i++) {\n\t\tterm.line[i] = xmalloc(col * sizeof(Glyph));\n\t\tterm.alt[i] = xmalloc(col * sizeof(Glyph));\n\t}\n\tif (col > term.maxcol) {\n\t\tbp = term.tabs + term.maxcol;\n\n\t\tmemset(bp, 0, sizeof(*term.tabs) * (col - term.maxcol));\n\t\twhile (--bp > term.tabs && !*bp)\n\t\t\t/* nothing */ ;\n\t\tfor (bp += tabspaces; bp < term.tabs + col; bp += tabspaces)\n\t\t\t*bp = 1;\n\t}\n\t/* update terminal size */\n\tterm.col = tmp;\n\tterm.maxcol = col;\n\tterm.row = row;\n\t/* reset scrolling region */\n\ttsetscroll(0, row-1);\n\t/* make use of the LIMIT in tmoveto */\n\ttmoveto(term.c.x, term.c.y);\n\t/* Clearing both screens (it makes dirty all lines) */\n\tc = term.c;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (mincol < col && 0 < minrow) {\n\t\t\ttclearregion(mincol, 0, col - 1, minrow - 1);\n\t\t}\n\t\tif (0 < col && minrow < row) {\n\t\t\ttclearregion(0, minrow, col - 1, row - 1);\n\t\t}\n\t\ttswapscreen();\n\t\ttcursor(CURSOR_LOAD);\n\t}\n\tterm.c = c;\n}\n\nvoid\nresettitle(void)\n{\n\txsettitle(NULL);\n}\n\nvoid\ndrawregion(int x1, int y1, int x2, int y2)\n{\n\tint y;\n\n\tfor (y = y1; y < y2; y++) {\n\t\tif (!term.dirty[y])\n\t\t\tcontinue;\n\n\t\tterm.dirty[y] = 0;\n\t\txdrawline(TLINE(y), x1, y, x2);\n\t}\n}\n\nvoid\ndraw(void)\n{\n\tint cx = term.c.x, ocx = term.ocx, ocy = term.ocy;\n\n\tif (!xstartdraw())\n\t\treturn;\n\n\t/* adjust cursor position */\n\tLIMIT(term.ocx, 0, term.col-1);\n\tLIMIT(term.ocy, 0, term.row-1);\n\tif (term.line[term.ocy][term.ocx].mode & ATTR_WDUMMY)\n\t\tterm.ocx--;\n\tif (term.line[term.c.y][cx].mode & ATTR_WDUMMY)\n\t\tcx--;\n\n\tdrawregion(0, 0, term.col, term.row);\n\tif (term.scr == 0)\n\t\txdrawcursor(cx, term.c.y, term.line[term.c.y][cx],\n\t\t\t\tterm.ocx, term.ocy, term.line[term.ocy][term.ocx],\n\t\t\t\tterm.line[term.ocy], term.col);\n\t/* xdrawcursor(cx, term.c.y, term.line[term.c.y][cx], */\n\t/* \t\tterm.ocx, term.ocy, term.line[term.ocy][term.ocx], */\n\t/* \t\tterm.line[term.ocy], term.col); */\n\tterm.ocx = cx;\n\tterm.ocy = term.c.y;\n\txfinishdraw();\n\tif (ocx != term.ocx || ocy != term.ocy)\n\t\txximspot(term.ocx, term.ocy);\n}\n\nvoid\nredraw(void)\n{\n\ttfulldirt();\n\tdraw();\n}\n\n"
        },
        {
          "name": "st.h",
          "type": "blob",
          "size": 3.490234375,
          "content": "/* See LICENSE for license details. */\n\n#include <stdint.h>\n#include <sys/types.h>\n\n/* macros */\n#define MIN(a, b)\t\t((a) < (b) ? (a) : (b))\n#define MAX(a, b)\t\t((a) < (b) ? (b) : (a))\n#define LEN(a)\t\t\t(sizeof(a) / sizeof(a)[0])\n#define BETWEEN(x, a, b)\t((a) <= (x) && (x) <= (b))\n#define DIVCEIL(n, d)\t\t(((n) + ((d) - 1)) / (d))\n#define DEFAULT(a, b)\t\t(a) = (a) ? (a) : (b)\n#define LIMIT(x, a, b)\t\t(x) = (x) < (a) ? (a) : (x) > (b) ? (b) : (x)\n#define ATTRCMP(a, b)\t\t(((a).mode & (~ATTR_WRAP) & (~ATTR_LIGA)) != ((b).mode & (~ATTR_WRAP) & (~ATTR_LIGA)) || \\\n\t\t\t\t(a).fg != (b).fg || \\\n\t\t\t\t(a).bg != (b).bg)\n#define TIMEDIFF(t1, t2)\t((t1.tv_sec-t2.tv_sec)*1000 + \\\n\t\t\t\t(t1.tv_nsec-t2.tv_nsec)/1E6)\n#define MODBIT(x, set, bit)\t((set) ? ((x) |= (bit)) : ((x) &= ~(bit)))\n\n#define TRUECOLOR(r,g,b)\t(1 << 24 | (r) << 16 | (g) << 8 | (b))\n#define IS_TRUECOL(x)\t\t(1 << 24 & (x))\n\nenum glyph_attribute {\n\tATTR_NULL       = 0,\n\tATTR_BOLD       = 1 << 0,\n\tATTR_FAINT      = 1 << 1,\n\tATTR_ITALIC     = 1 << 2,\n\tATTR_UNDERLINE  = 1 << 3,\n\tATTR_BLINK      = 1 << 4,\n\tATTR_REVERSE    = 1 << 5,\n\tATTR_INVISIBLE  = 1 << 6,\n\tATTR_STRUCK     = 1 << 7,\n\tATTR_WRAP       = 1 << 8,\n\tATTR_WIDE       = 1 << 9,\n\tATTR_WDUMMY     = 1 << 10,\n\tATTR_BOXDRAW    = 1 << 11,\n\tATTR_LIGA       = 1 << 12,\n\tATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,\n};\n\nenum selection_mode {\n\tSEL_IDLE = 0,\n\tSEL_EMPTY = 1,\n\tSEL_READY = 2\n};\n\nenum selection_type {\n\tSEL_REGULAR = 1,\n\tSEL_RECTANGULAR = 2\n};\n\nenum selection_snap {\n\tSNAP_WORD = 1,\n\tSNAP_LINE = 2\n};\n\ntypedef unsigned char uchar;\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned short ushort;\n\ntypedef uint_least32_t Rune;\n\n#define Glyph Glyph_\ntypedef struct {\n\tRune u;           /* character code */\n\tushort mode;      /* attribute flags */\n\tuint32_t fg;      /* foreground  */\n\tuint32_t bg;      /* background  */\n} Glyph;\n\ntypedef Glyph *Line;\n\ntypedef union {\n\tint i;\n\tuint ui;\n\tfloat f;\n\tconst void *v;\n\tconst char *s;\n} Arg;\n\nvoid die(const char *, ...);\nvoid redraw(void);\nvoid tfulldirt(void);\nvoid draw(void);\n\nvoid externalpipe(const Arg *);\nvoid kscrolldown(const Arg *);\nvoid kscrollup(const Arg *);\n\nvoid printscreen(const Arg *);\nvoid printsel(const Arg *);\nvoid sendbreak(const Arg *);\nvoid toggleprinter(const Arg *);\n\nint tattrset(int);\nvoid tnew(int, int);\nvoid tresize(int, int);\nvoid tsetdirtattr(int);\nvoid ttyhangup(void);\nint ttynew(const char *, char *, const char *, char **);\nsize_t ttyread(void);\nvoid ttyresize(int, int);\nvoid ttywrite(const char *, size_t, int);\n\nvoid resettitle(void);\n\nvoid selclear(void);\nvoid selinit(void);\nvoid selstart(int, int, int);\nvoid selextend(int, int, int, int);\nint selected(int, int);\nchar *getsel(void);\n\nsize_t utf8encode(Rune, char *);\n\nvoid *xmalloc(size_t);\nvoid *xrealloc(void *, size_t);\nchar *xstrdup(const char *);\n\nint isboxdraw(Rune);\nushort boxdrawindex(const Glyph *);\n#ifdef XFT_VERSION\n/* only exposed to x.c, otherwise we'll need Xft.h for the types */\nvoid boxdraw_xinit(Display *, Colormap, XftDraw *, Visual *);\nvoid drawboxes(int, int, int, int, XftColor *, XftColor *, const XftGlyphFontSpec *, int);\n#endif\n\n/* config.h globals */\nextern char *utmp;\nextern char *scroll;\nextern char *stty_args;\nextern char *vtiden;\nextern wchar_t *worddelimiters;\nextern int allowaltscreen;\nextern int allowwindowops;\nextern char *termname;\nextern unsigned int tabspaces;\nextern unsigned int defaultfg;\nextern unsigned int defaultbg;\nextern float alpha;\nextern float alphaUnfocus;\nextern const int boxdraw, boxdraw_bold, boxdraw_braille;\nextern unsigned int defaultcs;\n\n"
        },
        {
          "name": "st.info",
          "type": "blob",
          "size": 3.974609375,
          "content": "st-mono| simpleterm monocolor,\n\tacsc=+C\\,D-A.B0E``aaffgghFiGjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,\n\tam,\n\tbce,\n\tbel=^G,\n\tblink=\\E[5m,\n\tbold=\\E[1m,\n\tcbt=\\E[Z,\n\tcvvis=\\E[?25h,\n\tcivis=\\E[?25l,\n\tclear=\\E[H\\E[2J,\n\tcnorm=\\E[?12l\\E[?25h,\n\tcolors#2,\n\tcols#80,\n\tcr=^M,\n\tcsr=\\E[%i%p1%d;%p2%dr,\n\tcub=\\E[%p1%dD,\n\tcub1=^H,\n\tcud1=^J,\n\tcud=\\E[%p1%dB,\n\tcuf1=\\E[C,\n\tcuf=\\E[%p1%dC,\n\tcup=\\E[%i%p1%d;%p2%dH,\n\tcuu1=\\E[A,\n\tcuu=\\E[%p1%dA,\n\tdch=\\E[%p1%dP,\n\tdch1=\\E[P,\n\tdim=\\E[2m,\n\tdl=\\E[%p1%dM,\n\tdl1=\\E[M,\n\tech=\\E[%p1%dX,\n\ted=\\E[J,\n\tel=\\E[K,\n\tel1=\\E[1K,\n\tenacs=\\E)0,\n\tflash=\\E[?5h$<80/>\\E[?5l,\n\tfsl=^G,\n\thome=\\E[H,\n\thpa=\\E[%i%p1%dG,\n\ths,\n\tht=^I,\n\thts=\\EH,\n\tich=\\E[%p1%d@,\n\til1=\\E[L,\n\til=\\E[%p1%dL,\n\tind=^J,\n\tindn=\\E[%p1%dS,\n\tinvis=\\E[8m,\n\tis2=\\E[4l\\E>\\E[?1034l,\n\tit#8,\n\tkel=\\E[1;2F,\n\tked=\\E[1;5F,\n\tka1=\\E[1~,\n\tka3=\\E[5~,\n\tkc1=\\E[4~,\n\tkc3=\\E[6~,\n\tkbs=\\177,\n\tkcbt=\\E[Z,\n\tkb2=\\EOu,\n\tkcub1=\\EOD,\n\tkcud1=\\EOB,\n\tkcuf1=\\EOC,\n\tkcuu1=\\EOA,\n\tkDC=\\E[3;2~,\n\tkent=\\EOM,\n\tkEND=\\E[1;2F,\n\tkIC=\\E[2;2~,\n\tkNXT=\\E[6;2~,\n\tkPRV=\\E[5;2~,\n\tkHOM=\\E[1;2H,\n\tkLFT=\\E[1;2D,\n\tkRIT=\\E[1;2C,\n\tkind=\\E[1;2B,\n\tkri=\\E[1;2A,\n\tkclr=\\E[3;5~,\n\tkdl1=\\E[3;2~,\n\tkdch1=\\E[3~,\n\tkich1=\\E[2~,\n\tkend=\\E[4~,\n\tkf1=\\EOP,\n\tkf2=\\EOQ,\n\tkf3=\\EOR,\n\tkf4=\\EOS,\n\tkf5=\\E[15~,\n\tkf6=\\E[17~,\n\tkf7=\\E[18~,\n\tkf8=\\E[19~,\n\tkf9=\\E[20~,\n\tkf10=\\E[21~,\n\tkf11=\\E[23~,\n\tkf12=\\E[24~,\n\tkf13=\\E[1;2P,\n\tkf14=\\E[1;2Q,\n\tkf15=\\E[1;2R,\n\tkf16=\\E[1;2S,\n\tkf17=\\E[15;2~,\n\tkf18=\\E[17;2~,\n\tkf19=\\E[18;2~,\n\tkf20=\\E[19;2~,\n\tkf21=\\E[20;2~,\n\tkf22=\\E[21;2~,\n\tkf23=\\E[23;2~,\n\tkf24=\\E[24;2~,\n\tkf25=\\E[1;5P,\n\tkf26=\\E[1;5Q,\n\tkf27=\\E[1;5R,\n\tkf28=\\E[1;5S,\n\tkf29=\\E[15;5~,\n\tkf30=\\E[17;5~,\n\tkf31=\\E[18;5~,\n\tkf32=\\E[19;5~,\n\tkf33=\\E[20;5~,\n\tkf34=\\E[21;5~,\n\tkf35=\\E[23;5~,\n\tkf36=\\E[24;5~,\n\tkf37=\\E[1;6P,\n\tkf38=\\E[1;6Q,\n\tkf39=\\E[1;6R,\n\tkf40=\\E[1;6S,\n\tkf41=\\E[15;6~,\n\tkf42=\\E[17;6~,\n\tkf43=\\E[18;6~,\n\tkf44=\\E[19;6~,\n\tkf45=\\E[20;6~,\n\tkf46=\\E[21;6~,\n\tkf47=\\E[23;6~,\n\tkf48=\\E[24;6~,\n\tkf49=\\E[1;3P,\n\tkf50=\\E[1;3Q,\n\tkf51=\\E[1;3R,\n\tkf52=\\E[1;3S,\n\tkf53=\\E[15;3~,\n\tkf54=\\E[17;3~,\n\tkf55=\\E[18;3~,\n\tkf56=\\E[19;3~,\n\tkf57=\\E[20;3~,\n\tkf58=\\E[21;3~,\n\tkf59=\\E[23;3~,\n\tkf60=\\E[24;3~,\n\tkf61=\\E[1;4P,\n\tkf62=\\E[1;4Q,\n\tkf63=\\E[1;4R,\n\tkhome=\\E[1~,\n\tkil1=\\E[2;5~,\n\tkrmir=\\E[2;2~,\n\tknp=\\E[6~,\n\tkmous=\\E[M,\n\tkpp=\\E[5~,\n\tlines#24,\n\tmir,\n\tmsgr,\n\tnpc,\n\top=\\E[39;49m,\n\tpairs#64,\n\tmc0=\\E[i,\n\tmc4=\\E[4i,\n\tmc5=\\E[5i,\n\trc=\\E8,\n\trev=\\E[7m,\n\tri=\\EM,\n\trin=\\E[%p1%dT,\n\tritm=\\E[23m,\n\trmacs=\\E(B,\n\trmcup=\\E[?1049l,\n\trmir=\\E[4l,\n\trmkx=\\E[?1l\\E>,\n\trmso=\\E[27m,\n\trmul=\\E[24m,\n\trs1=\\Ec,\n\trs2=\\E[4l\\E>\\E[?1034l,\n\tsc=\\E7,\n\tsitm=\\E[3m,\n\tsgr0=\\E[0m,\n\tsmacs=\\E(0,\n\tsmcup=\\E[?1049h,\n\tsmir=\\E[4h,\n\tsmkx=\\E[?1h\\E=,\n\tsmso=\\E[7m,\n\tsmul=\\E[4m,\n\ttbc=\\E[3g,\n\ttsl=\\E]0;,\n\txenl,\n\tvpa=\\E[%i%p1%dd,\n# XTerm extensions\n\trmxx=\\E[29m,\n\tsmxx=\\E[9m,\n# disabled rep for now: causes some issues with older ncurses versions.\n#\trep=%p1%c\\E[%p2%{1}%-%db,\n# tmux extensions, see TERMINFO EXTENSIONS in tmux(1)\n\tTc,\n\tMs=\\E]52;%p1%s;%p2%s\\007,\n\tSe=\\E[2 q,\n\tSs=\\E[%p1%d q,\n\nst| simpleterm,\n\tuse=st-mono,\n\tcolors#8,\n\tsetab=\\E[4%p1%dm,\n\tsetaf=\\E[3%p1%dm,\n\tsetb=\\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,\n\tsetf=\\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,\n\tsgr=%?%p9%t\\E(0%e\\E(B%;\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,\n\nst-256color| simpleterm with 256 colors,\n\tuse=st,\n\tccc,\n\tcolors#256,\n\toc=\\E]104\\007,\n\tpairs#32767,\n#\tNicked from xterm-256color\n\tinitc=\\E]4;%p1%d;rgb\\:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\\E\\\\,\n\tsetab=\\E[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m,\n\tsetaf=\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m,\n\nst-meta| simpleterm with meta key,\n\tuse=st,\n\tkm,\n\trmm=\\E[?1034l,\n\tsmm=\\E[?1034h,\n\trs2=\\E[4l\\E>\\E[?1034h,\n\tis2=\\E[4l\\E>\\E[?1034h,\n\nst-meta-256color| simpleterm with meta key and 256 colors,\n\tuse=st-256color,\n\tkm,\n\trmm=\\E[?1034l,\n\tsmm=\\E[?1034h,\n\trs2=\\E[4l\\E>\\E[?1034h,\n\tis2=\\E[4l\\E>\\E[?1034h,\n\nst-bs| simpleterm with backspace as backspace,\n\tuse=st,\n\tkbs=\\010,\n\tkdch1=\\177,\n\nst-bs-256color| simpleterm with backspace as backspace and 256colors,\n\tuse=st-256color,\n\tkbs=\\010,\n\tkdch1=\\177,\n"
        },
        {
          "name": "win.h",
          "type": "blob",
          "size": 1.1474609375,
          "content": "/* See LICENSE for license details. */\n\nenum win_mode {\n\tMODE_VISIBLE     = 1 << 0,\n\tMODE_FOCUSED     = 1 << 1,\n\tMODE_APPKEYPAD   = 1 << 2,\n\tMODE_MOUSEBTN    = 1 << 3,\n\tMODE_MOUSEMOTION = 1 << 4,\n\tMODE_REVERSE     = 1 << 5,\n\tMODE_KBDLOCK     = 1 << 6,\n\tMODE_HIDE        = 1 << 7,\n\tMODE_APPCURSOR   = 1 << 8,\n\tMODE_MOUSESGR    = 1 << 9,\n\tMODE_8BIT        = 1 << 10,\n\tMODE_BLINK       = 1 << 11,\n\tMODE_FBLINK      = 1 << 12,\n\tMODE_FOCUS       = 1 << 13,\n\tMODE_MOUSEX10    = 1 << 14,\n\tMODE_MOUSEMANY   = 1 << 15,\n\tMODE_BRCKTPASTE  = 1 << 16,\n\tMODE_NUMLOCK     = 1 << 17,\n\tMODE_MOUSE       = MODE_MOUSEBTN|MODE_MOUSEMOTION|MODE_MOUSEX10\\\n\t                  |MODE_MOUSEMANY,\n};\n\nvoid xbell(void);\nvoid xclipcopy(void);\nvoid xdrawcursor(int, int, Glyph, int, int, Glyph, Line, int);\nvoid xdrawline(Line, int, int, int);\nvoid xfinishdraw(void);\nvoid xloadcols(void);\nint xsetcolorname(int, const char *);\nint xgetcolor(int, unsigned char *, unsigned char *, unsigned char *);\nvoid xseticontitle(char *);\nvoid xsettitle(char *);\nint xsetcursor(int);\nvoid xsetmode(int, unsigned int);\nvoid xsetpointermotion(int);\nvoid xsetsel(char *);\nint xstartdraw(void);\nvoid xximspot(int, int);\n\n"
        },
        {
          "name": "x.c",
          "type": "blob",
          "size": 52.6513671875,
          "content": "/* See LICENSE for license details. */\n#include <errno.h>\n#include <math.h>\n#include <limits.h>\n#include <locale.h>\n#include <signal.h>\n#include <sys/select.h>\n#include <time.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <X11/Xatom.h>\n#include <X11/Xlib.h>\n#include <X11/cursorfont.h>\n#include <X11/keysym.h>\n#include <X11/Xft/Xft.h>\n#include <X11/XKBlib.h>\n#include <X11/Xresource.h>\n\nchar *argv0;\n#include \"arg.h\"\n#include \"st.h\"\n#include \"win.h\"\n#include \"hb.h\"\n\n/* types used in config.h */\ntypedef struct {\n\tuint mod;\n\tKeySym keysym;\n\tvoid (*func)(const Arg *);\n\tconst Arg arg;\n} Shortcut;\n\ntypedef struct {\n\tuint mod;\n\tuint button;\n\tvoid (*func)(const Arg *);\n\tconst Arg arg;\n\tuint  release;\n} MouseShortcut;\n\ntypedef struct {\n\tKeySym k;\n\tuint mask;\n\tchar *s;\n\t/* three-valued logic variables: 0 indifferent, 1 on, -1 off */\n\tsigned char appkey;    /* application keypad */\n\tsigned char appcursor; /* application cursor */\n} Key;\n\n/* Xresources preferences */\nenum resource_type {\n\tSTRING = 0,\n\tINTEGER = 1,\n\tFLOAT = 2\n};\n\ntypedef struct {\n\tchar *name;\n\tenum resource_type type;\n\tvoid *dst;\n} ResourcePref;\n\n/* X modifiers */\n#define XK_ANY_MOD    UINT_MAX\n#define XK_NO_MOD     0\n#define XK_SWITCH_MOD (1<<13|1<<14)\n\n/* function definitions used in config.h */\nstatic void clipcopy(const Arg *);\nstatic void clippaste(const Arg *);\nstatic void numlock(const Arg *);\nstatic void selpaste(const Arg *);\nstatic void changealpha(const Arg *);\nstatic void zoom(const Arg *);\nstatic void zoomabs(const Arg *);\nstatic void zoomreset(const Arg *);\nstatic void ttysend(const Arg *);\n\n/* config.h for applying patches and the configuration. */\n#include \"config.h\"\n\n/* XEMBED messages */\n#define XEMBED_FOCUS_IN  4\n#define XEMBED_FOCUS_OUT 5\n\n/* macros */\n#define IS_SET(flag)\t\t((win.mode & (flag)) != 0)\n#define TRUERED(x)\t\t(((x) & 0xff0000) >> 8)\n#define TRUEGREEN(x)\t\t(((x) & 0xff00))\n#define TRUEBLUE(x)\t\t(((x) & 0xff) << 8)\n\ntypedef XftDraw *Draw;\ntypedef XftColor Color;\ntypedef XftGlyphFontSpec GlyphFontSpec;\n\n/* Purely graphic info */\ntypedef struct {\n\tint tw, th; /* tty width and height */\n\tint w, h; /* window width and height */\n\tint ch; /* char height */\n\tint cw; /* char width  */\n\tint mode; /* window state/mode flags */\n\tint cursor; /* cursor style */\n} TermWindow;\n\ntypedef struct {\n\tDisplay *dpy;\n\tColormap cmap;\n\tWindow win;\n\tDrawable buf;\n\tGlyphFontSpec *specbuf; /* font spec buffer used for rendering */\n\tAtom xembed, wmdeletewin, netwmname, netwmiconname, netwmpid;\n\tstruct {\n\t\tXIM xim;\n\t\tXIC xic;\n\t\tXPoint spot;\n\t\tXVaNestedList spotlist;\n\t} ime;\n\tDraw draw;\n\tVisual *vis;\n\tXSetWindowAttributes attrs;\n\tint scr;\n\tint isfixed; /* is fixed geometry? */\n\tint depth; /* bit depth */\n\tint l, t; /* left and top offset */\n\tint gm; /* geometry mask */\n} XWindow;\n\ntypedef struct {\n\tAtom xtarget;\n\tchar *primary, *clipboard;\n\tstruct timespec tclick1;\n\tstruct timespec tclick2;\n} XSelection;\n\n/* Font structure */\n#define Font Font_\ntypedef struct {\n\tint height;\n\tint width;\n\tint ascent;\n\tint descent;\n\tint badslant;\n\tint badweight;\n\tshort lbearing;\n\tshort rbearing;\n\tXftFont *match;\n\tFcFontSet *set;\n\tFcPattern *pattern;\n} Font;\n\n/* Drawing Context */\ntypedef struct {\n\tColor *col;\n\tsize_t collen;\n\tFont font, bfont, ifont, ibfont;\n\tGC gc;\n} DC;\n\nstatic inline ushort sixd_to_16bit(int);\nstatic int xmakeglyphfontspecs(XftGlyphFontSpec *, const Glyph *, int, int, int);\nstatic void xdrawglyphfontspecs(const XftGlyphFontSpec *, Glyph, int, int, int);\nstatic void xdrawglyph(Glyph, int, int);\nstatic void xclear(int, int, int, int);\nstatic int xgeommasktogravity(int);\nstatic int ximopen(Display *);\nstatic void ximinstantiate(Display *, XPointer, XPointer);\nstatic void ximdestroy(XIM, XPointer, XPointer);\nstatic int xicdestroy(XIC, XPointer, XPointer);\nstatic void xinit(int, int);\nstatic void cresize(int, int);\nstatic void xresize(int, int);\nstatic void xhints(void);\nstatic int xloadcolor(int, const char *, Color *);\nstatic int xloadfont(Font *, FcPattern *);\nstatic int xloadsparefont(FcPattern *, int);\nstatic void xloadsparefonts(void);\nstatic void xloadfonts(const char *, double);\nstatic void xunloadfont(Font *);\nstatic void xunloadfonts(void);\nstatic void xsetenv(void);\nstatic void xseturgency(int);\nstatic int evcol(XEvent *);\nstatic int evrow(XEvent *);\nstatic float clamp(float, float, float);\n\nstatic void expose(XEvent *);\nstatic void visibility(XEvent *);\nstatic void unmap(XEvent *);\nstatic void kpress(XEvent *);\nstatic void cmessage(XEvent *);\nstatic void resize(XEvent *);\nstatic void focus(XEvent *);\nstatic uint buttonmask(uint);\nstatic int mouseaction(XEvent *, uint);\nstatic void brelease(XEvent *);\nstatic void bpress(XEvent *);\nstatic void bmotion(XEvent *);\nstatic void propnotify(XEvent *);\nstatic void selnotify(XEvent *);\nstatic void selclear_(XEvent *);\nstatic void selrequest(XEvent *);\nstatic void setsel(char *, Time);\nstatic void mousesel(XEvent *, int);\nstatic void mousereport(XEvent *);\nstatic char *kmap(KeySym, uint);\nstatic int match(uint, uint);\n\nstatic void run(void);\nstatic void usage(void);\n\nstatic void (*handler[LASTEvent])(XEvent *) = {\n\t[KeyPress] = kpress,\n\t[ClientMessage] = cmessage,\n\t[ConfigureNotify] = resize,\n\t[VisibilityNotify] = visibility,\n\t[UnmapNotify] = unmap,\n\t[Expose] = expose,\n\t[FocusIn] = focus,\n\t[FocusOut] = focus,\n\t[MotionNotify] = bmotion,\n\t[ButtonPress] = bpress,\n\t[ButtonRelease] = brelease,\n/*\n * Uncomment if you want the selection to disappear when you select something\n * different in another window.\n */\n/*\t[SelectionClear] = selclear_, */\n\t[SelectionNotify] = selnotify,\n/*\n * PropertyNotify is only turned on when there is some INCR transfer happening\n * for the selection retrieval.\n */\n\t[PropertyNotify] = propnotify,\n\t[SelectionRequest] = selrequest,\n};\n\n/* Globals */\nstatic DC dc;\nstatic XWindow xw;\nstatic XSelection xsel;\nstatic TermWindow win;\n\n/* Font Ring Cache */\nenum {\n\tFRC_NORMAL,\n\tFRC_ITALIC,\n\tFRC_BOLD,\n\tFRC_ITALICBOLD\n};\n\ntypedef struct {\n\tXftFont *font;\n\tint flags;\n\tRune unicodep;\n} Fontcache;\n\n/* Fontcache is an array now. A new font will be appended to the array. */\nstatic Fontcache *frc = NULL;\nstatic int frclen = 0;\nstatic int frccap = 0;\nstatic char *usedfont = NULL;\nstatic double usedfontsize = 0;\nstatic double defaultfontsize = 0;\n\nstatic char *opt_alpha = NULL;\nstatic char *opt_class = NULL;\nstatic char **opt_cmd  = NULL;\nstatic char *opt_embed = NULL;\nstatic char *opt_font  = NULL;\nstatic char *opt_io    = NULL;\nstatic char *opt_line  = NULL;\nstatic char *opt_name  = NULL;\nstatic char *opt_title = NULL;\n\nstatic int focused = 0;\n\nstatic int oldbutton = 3; /* button event on startup: 3 = release */\nstatic uint buttons; /* bit field of pressed buttons */\n\nvoid\nclipcopy(const Arg *dummy)\n{\n\tAtom clipboard;\n\n\tfree(xsel.clipboard);\n\txsel.clipboard = NULL;\n\n\tif (xsel.primary != NULL) {\n\t\txsel.clipboard = xstrdup(xsel.primary);\n\t\tclipboard = XInternAtom(xw.dpy, \"CLIPBOARD\", 0);\n\t\tXSetSelectionOwner(xw.dpy, clipboard, xw.win, CurrentTime);\n\t}\n}\n\nvoid\nclippaste(const Arg *dummy)\n{\n\tAtom clipboard;\n\n\tclipboard = XInternAtom(xw.dpy, \"CLIPBOARD\", 0);\n\tXConvertSelection(xw.dpy, clipboard, xsel.xtarget, clipboard,\n\t\t\txw.win, CurrentTime);\n}\n\nvoid\nselpaste(const Arg *dummy)\n{\n\tXConvertSelection(xw.dpy, XA_PRIMARY, xsel.xtarget, XA_PRIMARY,\n\t\t\txw.win, CurrentTime);\n}\n\nvoid\nnumlock(const Arg *dummy)\n{\n\twin.mode ^= MODE_NUMLOCK;\n}\n\nvoid\nchangealpha(const Arg *arg)\n{\n    if((alpha > 0 && arg->f < 0) || (alpha < 1 && arg->f > 0))\n        alpha += arg->f;\n    alpha = clamp(alpha, 0.0, 1.0);\n    alphaUnfocus = clamp(alpha-alphaOffset, 0.0, 1.0);\n\n    xloadcols();\n    redraw();\n}\n\nvoid\nzoom(const Arg *arg)\n{\n\tArg larg;\n\n\tlarg.f = usedfontsize + arg->f;\n\tzoomabs(&larg);\n}\n\nvoid\nzoomabs(const Arg *arg)\n{\n\txunloadfonts();\n\txloadfonts(usedfont, arg->f);\n\txloadsparefonts();\n\tcresize(0, 0);\n\tredraw();\n\txhints();\n}\n\nvoid\nzoomreset(const Arg *arg)\n{\n\tArg larg;\n\n\tif (defaultfontsize > 0) {\n\t\tlarg.f = defaultfontsize;\n\t\tzoomabs(&larg);\n\t}\n}\n\nvoid\nttysend(const Arg *arg)\n{\n\tttywrite(arg->s, strlen(arg->s), 1);\n}\n\nint\nevcol(XEvent *e)\n{\n\tint x = e->xbutton.x - borderpx;\n\tLIMIT(x, 0, win.tw - 1);\n\treturn x / win.cw;\n}\n\nint\nevrow(XEvent *e)\n{\n\tint y = e->xbutton.y - borderpx;\n\tLIMIT(y, 0, win.th - 1);\n\treturn y / win.ch;\n}\n\nfloat\nclamp(float value, float lower, float upper) {\n    if(value < lower)\n        return lower;\n    if(value > upper)\n        return upper;\n    return value;\n}\n\nvoid\nmousesel(XEvent *e, int done)\n{\n\tint type, seltype = SEL_REGULAR;\n\tuint state = e->xbutton.state & ~(Button1Mask | forcemousemod);\n\n\tfor (type = 1; type < LEN(selmasks); ++type) {\n\t\tif (match(selmasks[type], state)) {\n\t\t\tseltype = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\tselextend(evcol(e), evrow(e), seltype, done);\n\tif (done)\n\t\tsetsel(getsel(), e->xbutton.time);\n}\n\nvoid\nmousereport(XEvent *e)\n{\n\tint len, x = evcol(e), y = evrow(e),\n\t    button = e->xbutton.button, state = e->xbutton.state;\n\tchar buf[40];\n\tstatic int ox, oy;\n\n\t/* from urxvt */\n\tif (e->xbutton.type == MotionNotify) {\n\t\tif (x == ox && y == oy)\n\t\t\treturn;\n\t\tif (!IS_SET(MODE_MOUSEMOTION) && !IS_SET(MODE_MOUSEMANY))\n\t\t\treturn;\n\t\t/* MOUSE_MOTION: no reporting if no button is pressed */\n\t\tif (IS_SET(MODE_MOUSEMOTION) && oldbutton == 3)\n\t\t\treturn;\n\n\t\tbutton = oldbutton + 32;\n\t\tox = x;\n\t\toy = y;\n\t} else {\n\t\tif (!IS_SET(MODE_MOUSESGR) && e->xbutton.type == ButtonRelease) {\n\t\t\tbutton = 3;\n\t\t} else {\n\t\t\tbutton -= Button1;\n\t\t\tif (button >= 3)\n\t\t\t\tbutton += 64 - 3;\n\t\t}\n\t\tif (e->xbutton.type == ButtonPress) {\n\t\t\toldbutton = button;\n\t\t\tox = x;\n\t\t\toy = y;\n\t\t} else if (e->xbutton.type == ButtonRelease) {\n\t\t\toldbutton = 3;\n\t\t\t/* MODE_MOUSEX10: no button release reporting */\n\t\t\tif (IS_SET(MODE_MOUSEX10))\n\t\t\t\treturn;\n\t\t\tif (button == 64 || button == 65)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!IS_SET(MODE_MOUSEX10)) {\n\t\tbutton += ((state & ShiftMask  ) ? 4  : 0)\n\t\t\t+ ((state & Mod4Mask   ) ? 8  : 0)\n\t\t\t+ ((state & ControlMask) ? 16 : 0);\n\t}\n\n\tif (IS_SET(MODE_MOUSESGR)) {\n\t\tlen = snprintf(buf, sizeof(buf), \"\\033[<%d;%d;%d%c\",\n\t\t\t\tbutton, x+1, y+1,\n\t\t\t\te->type == ButtonRelease ? 'm' : 'M');\n\t} else if (x < 223 && y < 223) {\n\t\tlen = snprintf(buf, sizeof(buf), \"\\033[M%c%c%c\",\n\t\t\t\t32+button, 32+x+1, 32+y+1);\n\t} else {\n\t\treturn;\n\t}\n\n\tttywrite(buf, len, 0);\n}\n\nuint\nbuttonmask(uint button)\n{\n\treturn button == Button1 ? Button1Mask\n\t     : button == Button2 ? Button2Mask\n\t     : button == Button3 ? Button3Mask\n\t     : button == Button4 ? Button4Mask\n\t     : button == Button5 ? Button5Mask\n\t     : 0;\n}\n\nint\nmouseaction(XEvent *e, uint release)\n{\n\tMouseShortcut *ms;\n\n\t/* ignore Button<N>mask for Button<N> - it's set on release */\n\tuint state = e->xbutton.state & ~buttonmask(e->xbutton.button);\n\n\tfor (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {\n\t\tif (ms->release == release &&\n\t\t    ms->button == e->xbutton.button &&\n\t\t    (match(ms->mod, state) ||  /* exact or forced */\n\t\t     match(ms->mod, state & ~forcemousemod))) {\n\t\t\tms->func(&(ms->arg));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\nbpress(XEvent *e)\n{\n\tint btn = e->xbutton.button;\n\tstruct timespec now;\n\tint snap;\n\n\tif (1 <= btn && btn <= 11)\n\t\tbuttons |= 1 << (btn-1);\n\n\tif (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {\n\t\tmousereport(e);\n\t\treturn;\n\t}\n\n\tif (mouseaction(e, 0))\n\t\treturn;\n\n\tif (btn == Button1) {\n\t\t/*\n\t\t * If the user clicks below predefined timeouts specific\n\t\t * snapping behaviour is exposed.\n\t\t */\n\t\tclock_gettime(CLOCK_MONOTONIC, &now);\n\t\tif (TIMEDIFF(now, xsel.tclick2) <= tripleclicktimeout) {\n\t\t\tsnap = SNAP_LINE;\n\t\t} else if (TIMEDIFF(now, xsel.tclick1) <= doubleclicktimeout) {\n\t\t\tsnap = SNAP_WORD;\n\t\t} else {\n\t\t\tsnap = 0;\n\t\t}\n\t\txsel.tclick2 = xsel.tclick1;\n\t\txsel.tclick1 = now;\n\n\t\tselstart(evcol(e), evrow(e), snap);\n\t}\n}\n\nvoid\npropnotify(XEvent *e)\n{\n\tXPropertyEvent *xpev;\n\tAtom clipboard = XInternAtom(xw.dpy, \"CLIPBOARD\", 0);\n\n\txpev = &e->xproperty;\n\tif (xpev->state == PropertyNewValue &&\n\t\t\t(xpev->atom == XA_PRIMARY ||\n\t\t\t xpev->atom == clipboard)) {\n\t\tselnotify(e);\n\t}\n}\n\nvoid\nselnotify(XEvent *e)\n{\n\tulong nitems, ofs, rem;\n\tint format;\n\tuchar *data, *last, *repl;\n\tAtom type, incratom, property = None;\n\n\tincratom = XInternAtom(xw.dpy, \"INCR\", 0);\n\n\tofs = 0;\n\tif (e->type == SelectionNotify)\n\t\tproperty = e->xselection.property;\n\telse if (e->type == PropertyNotify)\n\t\tproperty = e->xproperty.atom;\n\n\tif (property == None)\n\t\treturn;\n\n\tdo {\n\t\tif (XGetWindowProperty(xw.dpy, xw.win, property, ofs,\n\t\t\t\t\tBUFSIZ/4, False, AnyPropertyType,\n\t\t\t\t\t&type, &format, &nitems, &rem,\n\t\t\t\t\t&data)) {\n\t\t\tfprintf(stderr, \"Clipboard allocation failed\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (e->type == PropertyNotify && nitems == 0 && rem == 0) {\n\t\t\t/*\n\t\t\t * If there is some PropertyNotify with no data, then\n\t\t\t * this is the signal of the selection owner that all\n\t\t\t * data has been transferred. We won't need to receive\n\t\t\t * PropertyNotify events anymore.\n\t\t\t */\n\t\t\tMODBIT(xw.attrs.event_mask, 0, PropertyChangeMask);\n\t\t\tXChangeWindowAttributes(xw.dpy, xw.win, CWEventMask,\n\t\t\t\t\t&xw.attrs);\n\t\t}\n\n\t\tif (type == incratom) {\n\t\t\t/*\n\t\t\t * Activate the PropertyNotify events so we receive\n\t\t\t * when the selection owner does send us the next\n\t\t\t * chunk of data.\n\t\t\t */\n\t\t\tMODBIT(xw.attrs.event_mask, 1, PropertyChangeMask);\n\t\t\tXChangeWindowAttributes(xw.dpy, xw.win, CWEventMask,\n\t\t\t\t\t&xw.attrs);\n\n\t\t\t/*\n\t\t\t * Deleting the property is the transfer start signal.\n\t\t\t */\n\t\t\tXDeleteProperty(xw.dpy, xw.win, (int)property);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * As seen in getsel:\n\t\t * Line endings are inconsistent in the terminal and GUI world\n\t\t * copy and pasting. When receiving some selection data,\n\t\t * replace all '\\n' with '\\r'.\n\t\t * FIXME: Fix the computer world.\n\t\t */\n\t\trepl = data;\n\t\tlast = data + nitems * format / 8;\n\t\twhile ((repl = memchr(repl, '\\n', last - repl))) {\n\t\t\t*repl++ = '\\r';\n\t\t}\n\n\t\tif (IS_SET(MODE_BRCKTPASTE) && ofs == 0)\n\t\t\tttywrite(\"\\033[200~\", 6, 0);\n\t\tttywrite((char *)data, nitems * format / 8, 1);\n\t\tif (IS_SET(MODE_BRCKTPASTE) && rem == 0)\n\t\t\tttywrite(\"\\033[201~\", 6, 0);\n\t\tXFree(data);\n\t\t/* number of 32-bit chunks returned */\n\t\tofs += nitems * format / 32;\n\t} while (rem > 0);\n\n\t/*\n\t * Deleting the property again tells the selection owner to send the\n\t * next data chunk in the property.\n\t */\n\tXDeleteProperty(xw.dpy, xw.win, (int)property);\n}\n\nvoid\nxclipcopy(void)\n{\n\tclipcopy(NULL);\n}\n\nvoid\nselclear_(XEvent *e)\n{\n\tselclear();\n}\n\nvoid\nselrequest(XEvent *e)\n{\n\tXSelectionRequestEvent *xsre;\n\tXSelectionEvent xev;\n\tAtom xa_targets, string, clipboard;\n\tchar *seltext;\n\n\txsre = (XSelectionRequestEvent *) e;\n\txev.type = SelectionNotify;\n\txev.requestor = xsre->requestor;\n\txev.selection = xsre->selection;\n\txev.target = xsre->target;\n\txev.time = xsre->time;\n\tif (xsre->property == None)\n\t\txsre->property = xsre->target;\n\n\t/* reject */\n\txev.property = None;\n\n\txa_targets = XInternAtom(xw.dpy, \"TARGETS\", 0);\n\tif (xsre->target == xa_targets) {\n\t\t/* respond with the supported type */\n\t\tstring = xsel.xtarget;\n\t\tXChangeProperty(xsre->display, xsre->requestor, xsre->property,\n\t\t\t\tXA_ATOM, 32, PropModeReplace,\n\t\t\t\t(uchar *) &string, 1);\n\t\txev.property = xsre->property;\n\t} else if (xsre->target == xsel.xtarget || xsre->target == XA_STRING) {\n\t\t/*\n\t\t * xith XA_STRING non ascii characters may be incorrect in the\n\t\t * requestor. It is not our problem, use utf8.\n\t\t */\n\t\tclipboard = XInternAtom(xw.dpy, \"CLIPBOARD\", 0);\n\t\tif (xsre->selection == XA_PRIMARY) {\n\t\t\tseltext = xsel.primary;\n\t\t} else if (xsre->selection == clipboard) {\n\t\t\tseltext = xsel.clipboard;\n\t\t} else {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Unhandled clipboard selection 0x%lx\\n\",\n\t\t\t\txsre->selection);\n\t\t\treturn;\n\t\t}\n\t\tif (seltext != NULL) {\n\t\t\tXChangeProperty(xsre->display, xsre->requestor,\n\t\t\t\t\txsre->property, xsre->target,\n\t\t\t\t\t8, PropModeReplace,\n\t\t\t\t\t(uchar *)seltext, strlen(seltext));\n\t\t\txev.property = xsre->property;\n\t\t}\n\t}\n\n\t/* all done, send a notification to the listener */\n\tif (!XSendEvent(xsre->display, xsre->requestor, 1, 0, (XEvent *) &xev))\n\t\tfprintf(stderr, \"Error sending SelectionNotify event\\n\");\n}\n\nvoid\nsetsel(char *str, Time t)\n{\n\tif (!str)\n\t\treturn;\n\n\tfree(xsel.primary);\n\txsel.primary = str;\n\n\tXSetSelectionOwner(xw.dpy, XA_PRIMARY, xw.win, t);\n\tif (XGetSelectionOwner(xw.dpy, XA_PRIMARY) != xw.win)\n\t\tselclear();\n}\n\nvoid\nxsetsel(char *str)\n{\n\tsetsel(str, CurrentTime);\n}\n\nvoid\nbrelease(XEvent *e)\n{\n\tint btn = e->xbutton.button;\n\n\tif (1 <= btn && btn <= 11)\n\t\tbuttons &= ~(1 << (btn-1));\n\n\tif (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {\n\t\tmousereport(e);\n\t\treturn;\n\t}\n\n\tif (mouseaction(e, 1))\n\t\treturn;\n\tif (btn == Button1)\n\t\tmousesel(e, 1);\n}\n\nvoid\nbmotion(XEvent *e)\n{\n\tif (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {\n\t\tmousereport(e);\n\t\treturn;\n\t}\n\n\tmousesel(e, 0);\n}\n\nvoid\ncresize(int width, int height)\n{\n\tint col, row;\n\n\tif (width != 0)\n\t\twin.w = width;\n\tif (height != 0)\n\t\twin.h = height;\n\n\tcol = (win.w - 2 * borderpx) / win.cw;\n\trow = (win.h - 2 * borderpx) / win.ch;\n\tcol = MAX(1, col);\n\trow = MAX(1, row);\n\n\ttresize(col, row);\n\txresize(col, row);\n\tttyresize(win.tw, win.th);\n}\n\nvoid\nxresize(int col, int row)\n{\n\twin.tw = col * win.cw;\n\twin.th = row * win.ch;\n\n\tXFreePixmap(xw.dpy, xw.buf);\n\txw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h,\n\t\t\txw.depth);\n\tXftDrawChange(xw.draw, xw.buf);\n\txclear(0, 0, win.w, win.h);\n\n\t/* resize to new width */\n\txw.specbuf = xrealloc(xw.specbuf, col * sizeof(GlyphFontSpec));\n}\n\nushort\nsixd_to_16bit(int x)\n{\n\treturn x == 0 ? 0 : 0x3737 + 0x2828 * x;\n}\n\nint\nxloadcolor(int i, const char *name, Color *ncolor)\n{\n\tXRenderColor color = { .alpha = 0xffff };\n\n\tif (!name) {\n\t\tif (BETWEEN(i, 16, 255)) { /* 256 color */\n\t\t\tif (i < 6*6*6+16) { /* same colors as xterm */\n\t\t\t\tcolor.red   = sixd_to_16bit( ((i-16)/36)%6 );\n\t\t\t\tcolor.green = sixd_to_16bit( ((i-16)/6) %6 );\n\t\t\t\tcolor.blue  = sixd_to_16bit( ((i-16)/1) %6 );\n\t\t\t} else { /* greyscale */\n\t\t\t\tcolor.red = 0x0808 + 0x0a0a * (i - (6*6*6+16));\n\t\t\t\tcolor.green = color.blue = color.red;\n\t\t\t}\n\t\t\treturn XftColorAllocValue(xw.dpy, xw.vis,\n\t\t\t                          xw.cmap, &color, ncolor);\n\t\t} else\n\t\t\tname = colorname[i];\n\t}\n\n\treturn XftColorAllocName(xw.dpy, xw.vis, xw.cmap, name, ncolor);\n}\n\nvoid\nxloadalpha(void)\n{\n\tfloat const usedAlpha = focused ? alpha : alphaUnfocus;\n\tif (opt_alpha) alpha = strtof(opt_alpha, NULL);\n\tdc.col[defaultbg].color.alpha = (unsigned short)(0xffff * usedAlpha);\n\tdc.col[defaultbg].pixel &= 0x00FFFFFF;\n\tdc.col[defaultbg].pixel |= (unsigned char)(0xff * usedAlpha) << 24;\n}\n\nvoid\nxloadcols(void)\n{\n\tint i;\n\tstatic int loaded;\n\tColor *cp;\n\n\tif (!loaded) {\n\t\tdc.collen = 1 + (defaultbg = MAX(LEN(colorname), 256));\n\t\tdc.col = xmalloc(dc.collen * sizeof(Color));\n\t}\n\n\tfor (i = 0; i+1 < dc.collen; i++)\n\t\tif (!xloadcolor(i, NULL, &dc.col[i])) {\n\t\t\tif (colorname[i])\n\t\t\t\tdie(\"could not allocate color '%s'\\n\", colorname[i]);\n\t\t\telse\n\t\t\t\tdie(\"could not allocate color %d\\n\", i);\n\t\t}\n\n\tif (dc.collen) // cannot die, as the color is already loaded.\n\t\txloadcolor(background, NULL, &dc.col[defaultbg]);\n\n\txloadalpha();\n\tloaded = 1;\n}\n\nint\nxgetcolor(int x, unsigned char *r, unsigned char *g, unsigned char *b)\n{\n\tif (!BETWEEN(x, 0, dc.collen))\n\t\treturn 1;\n\n\t*r = dc.col[x].color.red >> 8;\n\t*g = dc.col[x].color.green >> 8;\n\t*b = dc.col[x].color.blue >> 8;\n\n\treturn 0;\n}\n\nint\nxsetcolorname(int x, const char *name)\n{\n\tColor ncolor;\n\n\tif (!BETWEEN(x, 0, dc.collen))\n\t\treturn 1;\n\n\tif (!xloadcolor(x, name, &ncolor))\n\t\treturn 1;\n\n\tXftColorFree(xw.dpy, xw.vis, xw.cmap, &dc.col[x]);\n\tdc.col[x] = ncolor;\n\n\treturn 0;\n}\n\n/*\n * Absolute coordinates.\n */\nvoid\nxclear(int x1, int y1, int x2, int y2)\n{\n\tXftDrawRect(xw.draw,\n\t\t\t&dc.col[IS_SET(MODE_REVERSE)? defaultfg : defaultbg],\n\t\t\tx1, y1, x2-x1, y2-y1);\n}\n\nvoid\nxhints(void)\n{\n\tXClassHint class = {opt_name ? opt_name : \"st\",\n\t                    opt_class ? opt_class : \"St\"};\n\tXWMHints wm = {.flags = InputHint, .input = 1};\n\tXSizeHints *sizeh;\n\n\tsizeh = XAllocSizeHints();\n\n\tsizeh->flags = PSize | PResizeInc | PBaseSize | PMinSize;\n\tsizeh->height = win.h;\n\tsizeh->width = win.w;\n\tsizeh->height_inc = win.ch;\n\tsizeh->width_inc = win.cw;\n\tsizeh->base_height = 2 * borderpx;\n\tsizeh->base_width = 2 * borderpx;\n\tsizeh->min_height = win.ch + 2 * borderpx;\n\tsizeh->min_width = win.cw + 2 * borderpx;\n\tif (xw.isfixed) {\n\t\tsizeh->flags |= PMaxSize;\n\t\tsizeh->min_width = sizeh->max_width = win.w;\n\t\tsizeh->min_height = sizeh->max_height = win.h;\n\t}\n\tif (xw.gm & (XValue|YValue)) {\n\t\tsizeh->flags |= USPosition | PWinGravity;\n\t\tsizeh->x = xw.l;\n\t\tsizeh->y = xw.t;\n\t\tsizeh->win_gravity = xgeommasktogravity(xw.gm);\n\t}\n\n\tXSetWMProperties(xw.dpy, xw.win, NULL, NULL, NULL, 0, sizeh, &wm,\n\t\t\t&class);\n\tXFree(sizeh);\n}\n\nint\nxgeommasktogravity(int mask)\n{\n\tswitch (mask & (XNegative|YNegative)) {\n\tcase 0:\n\t\treturn NorthWestGravity;\n\tcase XNegative:\n\t\treturn NorthEastGravity;\n\tcase YNegative:\n\t\treturn SouthWestGravity;\n\t}\n\n\treturn SouthEastGravity;\n}\n\nint\nxloadfont(Font *f, FcPattern *pattern)\n{\n\tFcPattern *configured;\n\tFcPattern *match;\n\tFcResult result;\n\tXGlyphInfo extents;\n\tint wantattr, haveattr;\n\n\t/*\n\t * Manually configure instead of calling XftMatchFont\n\t * so that we can use the configured pattern for\n\t * \"missing glyph\" lookups.\n\t */\n\tconfigured = FcPatternDuplicate(pattern);\n\tif (!configured)\n\t\treturn 1;\n\n\tFcConfigSubstitute(NULL, configured, FcMatchPattern);\n\tXftDefaultSubstitute(xw.dpy, xw.scr, configured);\n\n\tmatch = FcFontMatch(NULL, configured, &result);\n\tif (!match) {\n\t\tFcPatternDestroy(configured);\n\t\treturn 1;\n\t}\n\n\tif (!(f->match = XftFontOpenPattern(xw.dpy, match))) {\n\t\tFcPatternDestroy(configured);\n\t\tFcPatternDestroy(match);\n\t\treturn 1;\n\t}\n\n\tif ((XftPatternGetInteger(pattern, \"slant\", 0, &wantattr) ==\n\t    XftResultMatch)) {\n\t\t/*\n\t\t * Check if xft was unable to find a font with the appropriate\n\t\t * slant but gave us one anyway. Try to mitigate.\n\t\t */\n\t\tif ((XftPatternGetInteger(f->match->pattern, \"slant\", 0,\n\t\t    &haveattr) != XftResultMatch) || haveattr < wantattr) {\n\t\t\tf->badslant = 1;\n\t\t\tfputs(\"font slant does not match\\n\", stderr);\n\t\t}\n\t}\n\n\tif ((XftPatternGetInteger(pattern, \"weight\", 0, &wantattr) ==\n\t    XftResultMatch)) {\n\t\tif ((XftPatternGetInteger(f->match->pattern, \"weight\", 0,\n\t\t    &haveattr) != XftResultMatch) || haveattr != wantattr) {\n\t\t\tf->badweight = 1;\n\t\t\tfputs(\"font weight does not match\\n\", stderr);\n\t\t}\n\t}\n\n\tXftTextExtentsUtf8(xw.dpy, f->match,\n\t\t(const FcChar8 *) ascii_printable,\n\t\tstrlen(ascii_printable), &extents);\n\n\tf->set = NULL;\n\tf->pattern = configured;\n\n\tf->ascent = f->match->ascent;\n\tf->descent = f->match->descent;\n\tf->lbearing = 0;\n\tf->rbearing = f->match->max_advance_width;\n\n\tf->height = f->ascent + f->descent;\n\tf->width = DIVCEIL(extents.xOff, strlen(ascii_printable));\n\n\treturn 0;\n}\n\nvoid\nxloadfonts(const char *fontstr, double fontsize)\n{\n\tFcPattern *pattern;\n\tdouble fontval;\n\n\tif (fontstr[0] == '-')\n\t\tpattern = XftXlfdParse(fontstr, False, False);\n\telse\n\t\tpattern = FcNameParse((const FcChar8 *)fontstr);\n\n\tif (!pattern)\n\t\tdie(\"can't open font %s\\n\", fontstr);\n\n\tif (fontsize > 1) {\n\t\tFcPatternDel(pattern, FC_PIXEL_SIZE);\n\t\tFcPatternDel(pattern, FC_SIZE);\n\t\tFcPatternAddDouble(pattern, FC_PIXEL_SIZE, (double)fontsize);\n\t\tusedfontsize = fontsize;\n\t} else {\n\t\tif (FcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==\n\t\t\t\tFcResultMatch) {\n\t\t\tusedfontsize = fontval;\n\t\t} else if (FcPatternGetDouble(pattern, FC_SIZE, 0, &fontval) ==\n\t\t\t\tFcResultMatch) {\n\t\t\tusedfontsize = -1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Default font size is 12, if none given. This is to\n\t\t\t * have a known usedfontsize value.\n\t\t\t */\n\t\t\tFcPatternAddDouble(pattern, FC_PIXEL_SIZE, 12);\n\t\t\tusedfontsize = 12;\n\t\t}\n\t\tdefaultfontsize = usedfontsize;\n\t}\n\n\tif (xloadfont(&dc.font, pattern))\n\t\tdie(\"can't open font %s\\n\", fontstr);\n\n\tif (usedfontsize < 0) {\n\t\tFcPatternGetDouble(dc.font.match->pattern,\n\t\t                   FC_PIXEL_SIZE, 0, &fontval);\n\t\tusedfontsize = fontval;\n\t\tif (fontsize == 0)\n\t\t\tdefaultfontsize = fontval;\n\t}\n\n\t/* Setting character width and height. */\n\twin.cw = ceilf(dc.font.width * cwscale);\n\twin.ch = ceilf(dc.font.height * chscale);\n\n\tFcPatternDel(pattern, FC_SLANT);\n\tFcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);\n\tif (xloadfont(&dc.ifont, pattern))\n\t\tdie(\"can't open font %s\\n\", fontstr);\n\n\tFcPatternDel(pattern, FC_WEIGHT);\n\tFcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);\n\tif (xloadfont(&dc.ibfont, pattern))\n\t\tdie(\"can't open font %s\\n\", fontstr);\n\n\tFcPatternDel(pattern, FC_SLANT);\n\tFcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);\n\tif (xloadfont(&dc.bfont, pattern))\n\t\tdie(\"can't open font %s\\n\", fontstr);\n\n\tFcPatternDestroy(pattern);\n}\n\nint\nxloadsparefont(FcPattern *pattern, int flags)\n{\n\tFcPattern *match;\n\tFcResult result;\n\n\tmatch = FcFontMatch(NULL, pattern, &result);\n\tif (!match) {\n\t\treturn 1;\n\t}\n\n\tif (!(frc[frclen].font = XftFontOpenPattern(xw.dpy, match))) {\n\t\tFcPatternDestroy(match);\n\t\treturn 1;\n\t}\n\n\tfrc[frclen].flags = flags;\n\t/* Believe U+0000 glyph will present in each default font */\n\tfrc[frclen].unicodep = 0;\n\tfrclen++;\n\n\treturn 0;\n}\n\nvoid\nxloadsparefonts(void)\n{\n\tFcPattern *pattern;\n\tdouble sizeshift, fontval;\n\tint fc;\n\tchar **fp;\n\n\tif (frclen != 0)\n\t\tdie(\"can't embed spare fonts. cache isn't empty\");\n\n\t/* Calculate count of spare fonts */\n\tfc = sizeof(font2) / sizeof(*font2);\n\tif (fc == 0)\n\t\treturn;\n\n\t/* Allocate memory for cache entries. */\n\tif (frccap < 4 * fc) {\n\t\tfrccap += 4 * fc - frccap;\n\t\tfrc = xrealloc(frc, frccap * sizeof(Fontcache));\n\t}\n\n\tfor (fp = font2; fp - font2 < fc; ++fp) {\n\n\t\tif (**fp == '-')\n\t\t\tpattern = XftXlfdParse(*fp, False, False);\n\t\telse\n\t\t\tpattern = FcNameParse((FcChar8 *)*fp);\n\n\t\tif (!pattern)\n\t\t\tdie(\"can't open spare font %s\\n\", *fp);\n\n\t\tif (defaultfontsize > 0) {\n\t\t\tsizeshift = usedfontsize - defaultfontsize;\n\t\t\tif (sizeshift != 0 &&\n\t\t\t\t\tFcPatternGetDouble(pattern, FC_PIXEL_SIZE, 0, &fontval) ==\n\t\t\t\t\tFcResultMatch) {\n\t\t\t\tfontval += sizeshift;\n\t\t\t\tFcPatternDel(pattern, FC_PIXEL_SIZE);\n\t\t\t\tFcPatternDel(pattern, FC_SIZE);\n\t\t\t\tFcPatternAddDouble(pattern, FC_PIXEL_SIZE, fontval);\n\t\t\t}\n\t\t}\n\n\t\tFcPatternAddBool(pattern, FC_SCALABLE, 1);\n\n\t\tFcConfigSubstitute(NULL, pattern, FcMatchPattern);\n\t\tXftDefaultSubstitute(xw.dpy, xw.scr, pattern);\n\n\t\tif (xloadsparefont(pattern, FRC_NORMAL))\n\t\t\tdie(\"can't open spare font %s\\n\", *fp);\n\n\t\tFcPatternDel(pattern, FC_SLANT);\n\t\tFcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);\n\t\tif (xloadsparefont(pattern, FRC_ITALIC))\n\t\t\tdie(\"can't open spare font %s\\n\", *fp);\n\n\t\tFcPatternDel(pattern, FC_WEIGHT);\n\t\tFcPatternAddInteger(pattern, FC_WEIGHT, FC_WEIGHT_BOLD);\n\t\tif (xloadsparefont(pattern, FRC_ITALICBOLD))\n\t\t\tdie(\"can't open spare font %s\\n\", *fp);\n\n\t\tFcPatternDel(pattern, FC_SLANT);\n\t\tFcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ROMAN);\n\t\tif (xloadsparefont(pattern, FRC_BOLD))\n\t\t\tdie(\"can't open spare font %s\\n\", *fp);\n\n\t\tFcPatternDestroy(pattern);\n\t}\n}\n\nvoid\nxunloadfont(Font *f)\n{\n\tXftFontClose(xw.dpy, f->match);\n\tFcPatternDestroy(f->pattern);\n\tif (f->set)\n\t\tFcFontSetDestroy(f->set);\n}\n\nvoid\nxunloadfonts(void)\n{\n\t/* Clear Harfbuzz font cache. */\n\thbunloadfonts();\n\n\t/* Free the loaded fonts in the font cache.  */\n\twhile (frclen > 0)\n\t\tXftFontClose(xw.dpy, frc[--frclen].font);\n\n\txunloadfont(&dc.font);\n\txunloadfont(&dc.bfont);\n\txunloadfont(&dc.ifont);\n\txunloadfont(&dc.ibfont);\n}\n\nint\nximopen(Display *dpy)\n{\n\tXIMCallback imdestroy = { .client_data = NULL, .callback = ximdestroy };\n\tXICCallback icdestroy = { .client_data = NULL, .callback = xicdestroy };\n\n\txw.ime.xim = XOpenIM(xw.dpy, NULL, NULL, NULL);\n\tif (xw.ime.xim == NULL)\n\t\treturn 0;\n\n\tif (XSetIMValues(xw.ime.xim, XNDestroyCallback, &imdestroy, NULL))\n\t\tfprintf(stderr, \"XSetIMValues: \"\n\t\t                \"Could not set XNDestroyCallback.\\n\");\n\n\txw.ime.spotlist = XVaCreateNestedList(0, XNSpotLocation, &xw.ime.spot,\n\t                                      NULL);\n\n\tif (xw.ime.xic == NULL) {\n\t\txw.ime.xic = XCreateIC(xw.ime.xim, XNInputStyle,\n\t\t                       XIMPreeditNothing | XIMStatusNothing,\n\t\t                       XNClientWindow, xw.win,\n\t\t                       XNDestroyCallback, &icdestroy,\n\t\t                       NULL);\n\t}\n\tif (xw.ime.xic == NULL)\n\t\tfprintf(stderr, \"XCreateIC: Could not create input context.\\n\");\n\n\treturn 1;\n}\n\nvoid\nximinstantiate(Display *dpy, XPointer client, XPointer call)\n{\n\tif (ximopen(dpy))\n\t\tXUnregisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,\n\t\t                                 ximinstantiate, NULL);\n}\n\nvoid\nximdestroy(XIM xim, XPointer client, XPointer call)\n{\n\txw.ime.xim = NULL;\n\tXRegisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,\n\t                               ximinstantiate, NULL);\n\tXFree(xw.ime.spotlist);\n}\n\nint\nxicdestroy(XIC xim, XPointer client, XPointer call)\n{\n\txw.ime.xic = NULL;\n\treturn 1;\n}\n\nvoid\nxinit(int cols, int rows)\n{\n\tXGCValues gcvalues;\n\tCursor cursor;\n\tWindow parent;\n\tpid_t thispid = getpid();\n\tXColor xmousefg, xmousebg;\n\tXWindowAttributes attr;\n\tXVisualInfo vis;\n\n\txw.scr = XDefaultScreen(xw.dpy);\n\n\tif (!(opt_embed && (parent = strtol(opt_embed, NULL, 0)))) {\n\t\tparent = XRootWindow(xw.dpy, xw.scr);\n\t\txw.depth = 32;\n\t} else {\n\t\tXGetWindowAttributes(xw.dpy, parent, &attr);\n\t\txw.depth = attr.depth;\n\t}\n\n\tXMatchVisualInfo(xw.dpy, xw.scr, xw.depth, TrueColor, &vis);\n\txw.vis = vis.visual;\n\n\t/* font */\n\tif (!FcInit())\n\t\tdie(\"could not init fontconfig.\\n\");\n\n\tusedfont = (opt_font == NULL)? font : opt_font;\n\txloadfonts(usedfont, 0);\n\n\t/* spare fonts */\n\txloadsparefonts();\n\n\t/* colors */\n\txw.cmap = XCreateColormap(xw.dpy, parent, xw.vis, None);\n\txloadcols();\n\n\t/* adjust fixed window geometry */\n\twin.w = 2 * borderpx + cols * win.cw;\n\twin.h = 2 * borderpx + rows * win.ch;\n\tif (xw.gm & XNegative)\n\t\txw.l += DisplayWidth(xw.dpy, xw.scr) - win.w - 2;\n\tif (xw.gm & YNegative)\n\t\txw.t += DisplayHeight(xw.dpy, xw.scr) - win.h - 2;\n\n\t/* Events */\n\txw.attrs.background_pixel = dc.col[defaultbg].pixel;\n\txw.attrs.border_pixel = dc.col[defaultbg].pixel;\n\txw.attrs.bit_gravity = NorthWestGravity;\n\txw.attrs.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask\n\t\t| ExposureMask | VisibilityChangeMask | StructureNotifyMask\n\t\t| ButtonMotionMask | ButtonPressMask | ButtonReleaseMask;\n\txw.attrs.colormap = xw.cmap;\n\n\txw.win = XCreateWindow(xw.dpy, parent, xw.l, xw.t,\n\t\t\twin.w, win.h, 0, xw.depth, InputOutput,\n\t\t\txw.vis, CWBackPixel | CWBorderPixel | CWBitGravity\n\t\t\t| CWEventMask | CWColormap, &xw.attrs);\n\n\tmemset(&gcvalues, 0, sizeof(gcvalues));\n\tgcvalues.graphics_exposures = False;\n\txw.buf = XCreatePixmap(xw.dpy, xw.win, win.w, win.h, xw.depth);\n\tdc.gc = XCreateGC(xw.dpy, xw.buf, GCGraphicsExposures, &gcvalues);\n\tXSetForeground(xw.dpy, dc.gc, dc.col[defaultbg].pixel);\n\tXFillRectangle(xw.dpy, xw.buf, dc.gc, 0, 0, win.w, win.h);\n\n\t/* font spec buffer */\n\txw.specbuf = xmalloc(cols * sizeof(GlyphFontSpec));\n\n\t/* Xft rendering context */\n\txw.draw = XftDrawCreate(xw.dpy, xw.buf, xw.vis, xw.cmap);\n\n\t/* input methods */\n\tif (!ximopen(xw.dpy)) {\n\t\tXRegisterIMInstantiateCallback(xw.dpy, NULL, NULL, NULL,\n\t                                       ximinstantiate, NULL);\n\t}\n\n\t/* white cursor, black outline */\n\tcursor = XCreateFontCursor(xw.dpy, mouseshape);\n\tXDefineCursor(xw.dpy, xw.win, cursor);\n\n\tif (XParseColor(xw.dpy, xw.cmap, colorname[mousefg], &xmousefg) == 0) {\n\t\txmousefg.red   = 0xffff;\n\t\txmousefg.green = 0xffff;\n\t\txmousefg.blue  = 0xffff;\n\t}\n\n\tif (XParseColor(xw.dpy, xw.cmap, colorname[mousebg], &xmousebg) == 0) {\n\t\txmousebg.red   = 0x0000;\n\t\txmousebg.green = 0x0000;\n\t\txmousebg.blue  = 0x0000;\n\t}\n\n\tXRecolorCursor(xw.dpy, cursor, &xmousefg, &xmousebg);\n\n\txw.xembed = XInternAtom(xw.dpy, \"_XEMBED\", False);\n\txw.wmdeletewin = XInternAtom(xw.dpy, \"WM_DELETE_WINDOW\", False);\n\txw.netwmname = XInternAtom(xw.dpy, \"_NET_WM_NAME\", False);\n\txw.netwmiconname = XInternAtom(xw.dpy, \"_NET_WM_ICON_NAME\", False);\n\tXSetWMProtocols(xw.dpy, xw.win, &xw.wmdeletewin, 1);\n\n\txw.netwmpid = XInternAtom(xw.dpy, \"_NET_WM_PID\", False);\n\tXChangeProperty(xw.dpy, xw.win, xw.netwmpid, XA_CARDINAL, 32,\n\t\t\tPropModeReplace, (uchar *)&thispid, 1);\n\n\twin.mode = MODE_NUMLOCK;\n\tresettitle();\n\txhints();\n\tXMapWindow(xw.dpy, xw.win);\n\tXSync(xw.dpy, False);\n\n\tclock_gettime(CLOCK_MONOTONIC, &xsel.tclick1);\n\tclock_gettime(CLOCK_MONOTONIC, &xsel.tclick2);\n\txsel.primary = NULL;\n\txsel.clipboard = NULL;\n\txsel.xtarget = XInternAtom(xw.dpy, \"UTF8_STRING\", 0);\n\tif (xsel.xtarget == None)\n\t\txsel.xtarget = XA_STRING;\n\n\tboxdraw_xinit(xw.dpy, xw.cmap, xw.draw, xw.vis);\n}\n\nint\nxmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)\n{\n\tfloat winx = borderpx + x * win.cw, winy = borderpx + y * win.ch, xp, yp;\n\tushort mode, prevmode = USHRT_MAX;\n\tFont *font = &dc.font;\n\tint frcflags = FRC_NORMAL;\n\tfloat runewidth = win.cw;\n\tRune rune;\n\tFT_UInt glyphidx;\n\tFcResult fcres;\n\tFcPattern *fcpattern, *fontpattern;\n\tFcFontSet *fcsets[] = { NULL };\n\tFcCharSet *fccharset;\n\tint i, f, numspecs = 0;\n\n\tfor (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {\n\t\t/* Fetch rune and mode for current glyph. */\n\t\trune = glyphs[i].u;\n\t\tmode = glyphs[i].mode;\n\n\t\t/* Skip dummy wide-character spacing. */\n\t\tif (mode & ATTR_WDUMMY)\n\t\t\tcontinue;\n\n\t\t/* Determine font for glyph if different from previous glyph. */\n\t\tif (prevmode != mode) {\n\t\t\tprevmode = mode;\n\t\t\tfont = &dc.font;\n\t\t\tfrcflags = FRC_NORMAL;\n\t\t\trunewidth = win.cw * ((mode & ATTR_WIDE) ? 2.0f : 1.0f);\n\t\t\tif ((mode & ATTR_ITALIC) && (mode & ATTR_BOLD)) {\n\t\t\t\tfont = &dc.ibfont;\n\t\t\t\tfrcflags = FRC_ITALICBOLD;\n\t\t\t} else if (mode & ATTR_ITALIC) {\n\t\t\t\tfont = &dc.ifont;\n\t\t\t\tfrcflags = FRC_ITALIC;\n\t\t\t} else if (mode & ATTR_BOLD) {\n\t\t\t\tfont = &dc.bfont;\n\t\t\t\tfrcflags = FRC_BOLD;\n\t\t\t}\n\t\t\typ = winy + font->ascent;\n\t\t}\n\n\t\tif (mode & ATTR_BOXDRAW) {\n\t\t\t/* minor shoehorning: boxdraw uses only this ushort */\n\t\t\tglyphidx = boxdrawindex(&glyphs[i]);\n\t\t} else {\n\t\t\t/* Lookup character index with default font. */\n\t\t\tglyphidx = XftCharIndex(xw.dpy, font->match, rune);\n\t\t}\n\t\tif (glyphidx) {\n\t\t\tspecs[numspecs].font = font->match;\n\t\t\tspecs[numspecs].glyph = glyphidx;\n\t\t\tspecs[numspecs].x = (short)xp;\n\t\t\tspecs[numspecs].y = (short)yp;\n\t\t\txp += runewidth;\n\t\t\tnumspecs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Fallback on font cache, search the font cache for match. */\n\t\tfor (f = 0; f < frclen; f++) {\n\t\t\tglyphidx = XftCharIndex(xw.dpy, frc[f].font, rune);\n\t\t\t/* Everything correct. */\n\t\t\tif (glyphidx && frc[f].flags == frcflags)\n\t\t\t\tbreak;\n\t\t\t/* We got a default font for a not found glyph. */\n\t\t\tif (!glyphidx && frc[f].flags == frcflags\n\t\t\t\t\t&& frc[f].unicodep == rune) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Nothing was found. Use fontconfig to find matching font. */\n\t\tif (f >= frclen) {\n\t\t\tif (!font->set)\n\t\t\t\tfont->set = FcFontSort(0, font->pattern,\n\t\t\t\t                       1, 0, &fcres);\n\t\t\tfcsets[0] = font->set;\n\n\t\t\t/*\n\t\t\t * Nothing was found in the cache. Now use\n\t\t\t * some dozen of Fontconfig calls to get the\n\t\t\t * font for one single character.\n\t\t\t *\n\t\t\t * Xft and fontconfig are design failures.\n\t\t\t */\n\t\t\tfcpattern = FcPatternDuplicate(font->pattern);\n\t\t\tfccharset = FcCharSetCreate();\n\n\t\t\tFcCharSetAddChar(fccharset, rune);\n\t\t\tFcPatternAddCharSet(fcpattern, FC_CHARSET,\n\t\t\t\t\tfccharset);\n\t\t\tFcPatternAddBool(fcpattern, FC_SCALABLE, 1);\n\n\t\t\tFcConfigSubstitute(0, fcpattern,\n\t\t\t\t\tFcMatchPattern);\n\t\t\tFcDefaultSubstitute(fcpattern);\n\n\t\t\tfontpattern = FcFontSetMatch(0, fcsets, 1,\n\t\t\t\t\tfcpattern, &fcres);\n\n\t\t\t/* Allocate memory for the new cache entry. */\n\t\t\tif (frclen >= frccap) {\n\t\t\t\tfrccap += 16;\n\t\t\t\tfrc = xrealloc(frc, frccap * sizeof(Fontcache));\n\t\t\t}\n\n\t\t\tfrc[frclen].font = XftFontOpenPattern(xw.dpy,\n\t\t\t\t\tfontpattern);\n\t\t\tif (!frc[frclen].font)\n\t\t\t\tdie(\"XftFontOpenPattern failed seeking fallback font: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\tfrc[frclen].flags = frcflags;\n\t\t\tfrc[frclen].unicodep = rune;\n\n\t\t\tglyphidx = XftCharIndex(xw.dpy, frc[frclen].font, rune);\n\n\t\t\tf = frclen;\n\t\t\tfrclen++;\n\n\t\t\tFcPatternDestroy(fcpattern);\n\t\t\tFcCharSetDestroy(fccharset);\n\t\t}\n\n\t\tspecs[numspecs].font = frc[f].font;\n\t\tspecs[numspecs].glyph = glyphidx;\n\t\tspecs[numspecs].x = (short)xp;\n\t\tspecs[numspecs].y = (short)yp;\n\t\txp += runewidth;\n\t\tnumspecs++;\n\t}\n\n\t/* Harfbuzz transformation for ligatures. */\n\thbtransform(specs, glyphs, len, x, y);\n\n\treturn numspecs;\n}\n\nvoid\nxdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)\n{\n\tint charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);\n\tint winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,\n\t    width = charlen * win.cw;\n\tColor *fg, *bg, *temp, revfg, revbg, truefg, truebg;\n\tXRenderColor colfg, colbg;\n\tXRectangle r;\n\n\t/* Fallback on color display for attributes not supported by the font */\n\tif (base.mode & ATTR_ITALIC && base.mode & ATTR_BOLD) {\n\t\tif (dc.ibfont.badslant || dc.ibfont.badweight)\n\t\t\tbase.fg = defaultattr;\n\t} else if ((base.mode & ATTR_ITALIC && dc.ifont.badslant) ||\n\t    (base.mode & ATTR_BOLD && dc.bfont.badweight)) {\n\t\tbase.fg = defaultattr;\n\t}\n\n\tif (IS_TRUECOL(base.fg)) {\n\t\tcolfg.alpha = 0xffff;\n\t\tcolfg.red = TRUERED(base.fg);\n\t\tcolfg.green = TRUEGREEN(base.fg);\n\t\tcolfg.blue = TRUEBLUE(base.fg);\n\t\tXftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg, &truefg);\n\t\tfg = &truefg;\n\t} else {\n\t\tfg = &dc.col[base.fg];\n\t}\n\n\tif (IS_TRUECOL(base.bg)) {\n\t\tcolbg.alpha = 0xffff;\n\t\tcolbg.green = TRUEGREEN(base.bg);\n\t\tcolbg.red = TRUERED(base.bg);\n\t\tcolbg.blue = TRUEBLUE(base.bg);\n\t\tXftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg, &truebg);\n\t\tbg = &truebg;\n\t} else {\n\t\tbg = &dc.col[base.bg];\n\t}\n\n\t/* Change basic system colors [0-7] to bright system colors [8-15] */\n\tif ((base.mode & ATTR_BOLD_FAINT) == ATTR_BOLD && BETWEEN(base.fg, 0, 7))\n\t\tfg = &dc.col[base.fg + 8];\n\n\tif (IS_SET(MODE_REVERSE)) {\n\t\tif (fg == &dc.col[defaultfg]) {\n\t\t\tfg = &dc.col[defaultbg];\n\t\t} else {\n\t\t\tcolfg.red = ~fg->color.red;\n\t\t\tcolfg.green = ~fg->color.green;\n\t\t\tcolfg.blue = ~fg->color.blue;\n\t\t\tcolfg.alpha = fg->color.alpha;\n\t\t\tXftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg,\n\t\t\t\t\t&revfg);\n\t\t\tfg = &revfg;\n\t\t}\n\n\t\tif (bg == &dc.col[defaultbg]) {\n\t\t\tbg = &dc.col[defaultfg];\n\t\t} else {\n\t\t\tcolbg.red = ~bg->color.red;\n\t\t\tcolbg.green = ~bg->color.green;\n\t\t\tcolbg.blue = ~bg->color.blue;\n\t\t\tcolbg.alpha = bg->color.alpha;\n\t\t\tXftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg,\n\t\t\t\t\t&revbg);\n\t\t\tbg = &revbg;\n\t\t}\n\t}\n\n\tif ((base.mode & ATTR_BOLD_FAINT) == ATTR_FAINT) {\n\t\tcolfg.red = fg->color.red / 2;\n\t\tcolfg.green = fg->color.green / 2;\n\t\tcolfg.blue = fg->color.blue / 2;\n\t\tcolfg.alpha = fg->color.alpha;\n\t\tXftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colfg, &revfg);\n\t\tfg = &revfg;\n\t}\n\n\tif (base.mode & ATTR_REVERSE) {\n\t\ttemp = fg;\n\t\tfg = bg;\n\t\tbg = temp;\n\t}\n\n\tif (base.mode & ATTR_BLINK && win.mode & MODE_BLINK)\n\t\tfg = bg;\n\n\tif (base.mode & ATTR_INVISIBLE)\n\t\tfg = bg;\n\n\t/* Intelligent cleaning up of the borders. */\n\tif (x == 0) {\n\t\txclear(0, (y == 0)? 0 : winy, borderpx,\n\t\t\twiny + win.ch +\n\t\t\t((winy + win.ch >= borderpx + win.th)? win.h : 0));\n\t}\n\tif (winx + width >= borderpx + win.tw) {\n\t\txclear(winx + width, (y == 0)? 0 : winy, win.w,\n\t\t\t((winy + win.ch >= borderpx + win.th)? win.h : (winy + win.ch)));\n\t}\n\tif (y == 0)\n\t\txclear(winx, 0, winx + width, borderpx);\n\tif (winy + win.ch >= borderpx + win.th)\n\t\txclear(winx, winy + win.ch, winx + width, win.h);\n\n\t/* Clean up the region we want to draw to. */\n\tXftDrawRect(xw.draw, bg, winx, winy, width, win.ch);\n\n\t/* Set the clip region because Xft is sometimes dirty. */\n\tr.x = 0;\n\tr.y = 0;\n\tr.height = win.ch;\n\tr.width = width;\n\tXftDrawSetClipRectangles(xw.draw, winx, winy, &r, 1);\n\n\tif (base.mode & ATTR_BOXDRAW) {\n\t\tdrawboxes(winx, winy, width / len, win.ch, fg, bg, specs, len);\n\t} else {\n\t\t/* Render the glyphs. */\n\t\tXftDrawGlyphFontSpec(xw.draw, fg, specs, len);\n\t}\n\n\t/* Render underline and strikethrough. */\n\tif (base.mode & ATTR_UNDERLINE) {\n\t\tXftDrawRect(xw.draw, fg, winx, winy + dc.font.ascent + 1,\n                width, 1);\n\t}\n\n\tif (base.mode & ATTR_STRUCK) {\n\t\tXftDrawRect(xw.draw, fg, winx, winy + 2 * dc.font.ascent * chscale / 3,\n\t\t\t\twidth, 1);\n\t}\n\n\t/* Reset clip to none. */\n\tXftDrawSetClip(xw.draw, 0);\n}\n\nvoid\nxdrawglyph(Glyph g, int x, int y)\n{\n\tint numspecs;\n\tXftGlyphFontSpec spec;\n\n\tnumspecs = xmakeglyphfontspecs(&spec, &g, 1, x, y);\n\txdrawglyphfontspecs(&spec, g, numspecs, x, y);\n}\n\nvoid\nxdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og, Line line, int len)\n{\n\tColor drawcol;\n\n\t/* remove the old cursor */\n\tif (selected(ox, oy))\n\t\tog.mode ^= ATTR_REVERSE;\n\n\t/* Redraw the line where cursor was previously.\n\t * It will restore the ligatures broken by the cursor. */\n\txdrawline(line, 0, oy, len);\n\n\tif (IS_SET(MODE_HIDE))\n\t\treturn;\n\n\t/*\n\t * Select the right color for the right mode.\n\t */\n\tg.mode &= ATTR_BOLD|ATTR_ITALIC|ATTR_UNDERLINE|ATTR_STRUCK|ATTR_WIDE|ATTR_BOXDRAW;\n\n\tif (IS_SET(MODE_REVERSE)) {\n\t\tg.mode |= ATTR_REVERSE;\n\t\tg.bg = defaultfg;\n\t\tif (selected(cx, cy)) {\n\t\t\tdrawcol = dc.col[defaultcs];\n\t\t\tg.fg = defaultrcs;\n\t\t} else {\n\t\t\tdrawcol = dc.col[defaultrcs];\n\t\t\tg.fg = defaultcs;\n\t\t}\n\t} else {\n\t\tif (selected(cx, cy)) {\n\t\t\tg.fg = defaultfg;\n\t\t\tg.bg = defaultrcs;\n\t\t} else {\n\t\t\tg.fg = defaultbg;\n\t\t\tg.bg = defaultcs;\n\t\t}\n\t\tdrawcol = dc.col[g.bg];\n\t}\n\n\t/* draw the new one */\n\tif (IS_SET(MODE_FOCUSED)) {\n\t\tswitch (win.cursor) {\n\t\tcase 7: /* st extension */\n\t\t\tg.u = 0x2603; /* snowman (U+2603) */\n\t\t\t/* FALLTHROUGH */\n\t\tcase 0: /* Blinking Block */\n\t\tcase 1: /* Blinking Block (Default) */\n\t\tcase 2: /* Steady Block */\n\t\t\txdrawglyph(g, cx, cy);\n\t\t\tbreak;\n\t\tcase 3: /* Blinking Underline */\n\t\tcase 4: /* Steady Underline */\n\t\t\tXftDrawRect(xw.draw, &drawcol,\n\t\t\t\t\tborderpx + cx * win.cw,\n\t\t\t\t\tborderpx + (cy + 1) * win.ch - \\\n\t\t\t\t\t\tcursorthickness,\n\t\t\t\t\twin.cw, cursorthickness);\n\t\t\tbreak;\n\t\tcase 5: /* Blinking bar */\n\t\tcase 6: /* Steady bar */\n\t\t\tXftDrawRect(xw.draw, &drawcol,\n\t\t\t\t\tborderpx + cx * win.cw,\n\t\t\t\t\tborderpx + cy * win.ch,\n\t\t\t\t\tcursorthickness, win.ch);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tXftDrawRect(xw.draw, &drawcol,\n\t\t\t\tborderpx + cx * win.cw,\n\t\t\t\tborderpx + cy * win.ch,\n\t\t\t\twin.cw - 1, 1);\n\t\tXftDrawRect(xw.draw, &drawcol,\n\t\t\t\tborderpx + cx * win.cw,\n\t\t\t\tborderpx + cy * win.ch,\n\t\t\t\t1, win.ch - 1);\n\t\tXftDrawRect(xw.draw, &drawcol,\n\t\t\t\tborderpx + (cx + 1) * win.cw - 1,\n\t\t\t\tborderpx + cy * win.ch,\n\t\t\t\t1, win.ch - 1);\n\t\tXftDrawRect(xw.draw, &drawcol,\n\t\t\t\tborderpx + cx * win.cw,\n\t\t\t\tborderpx + (cy + 1) * win.ch - 1,\n\t\t\t\twin.cw, 1);\n\t}\n}\n\nvoid\nxsetenv(void)\n{\n\tchar buf[sizeof(long) * 8 + 1];\n\n\tsnprintf(buf, sizeof(buf), \"%lu\", xw.win);\n\tsetenv(\"WINDOWID\", buf, 1);\n}\n\nvoid\nxseticontitle(char *p)\n{\n\tXTextProperty prop;\n\tDEFAULT(p, opt_title);\n\n\tif (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,\n\t                                &prop) != Success)\n\t\treturn;\n\tXSetWMIconName(xw.dpy, xw.win, &prop);\n\tXSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmiconname);\n\tXFree(prop.value);\n}\n\nvoid\nxsettitle(char *p)\n{\n\tXTextProperty prop;\n\tDEFAULT(p, opt_title);\n\n\tif (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,\n\t                                &prop) != Success)\n\t\treturn;\n\tXSetWMName(xw.dpy, xw.win, &prop);\n\tXSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmname);\n\tXFree(prop.value);\n}\n\nint\nxstartdraw(void)\n{\n\treturn IS_SET(MODE_VISIBLE);\n}\n\nvoid\nxdrawline(Line line, int x1, int y1, int x2)\n{\n\tint i, x, ox, numspecs;\n\tGlyph base, new;\n\tXftGlyphFontSpec *specs = xw.specbuf;\n\n\tnumspecs = xmakeglyphfontspecs(specs, &line[x1], x2 - x1, x1, y1);\n\ti = ox = 0;\n\tfor (x = x1; x < x2 && i < numspecs; x++) {\n\t\tnew = line[x];\n\t\tif (new.mode == ATTR_WDUMMY)\n\t\t\tcontinue;\n\t\tif (selected(x, y1))\n\t\t\tnew.mode ^= ATTR_REVERSE;\n\t\tif (i > 0 && ATTRCMP(base, new)) {\n\t\t\txdrawglyphfontspecs(specs, base, i, ox, y1);\n\t\t\tspecs += i;\n\t\t\tnumspecs -= i;\n\t\t\ti = 0;\n\t\t}\n\t\tif (i == 0) {\n\t\t\tox = x;\n\t\t\tbase = new;\n\t\t}\n\t\ti++;\n\t}\n\tif (i > 0)\n\t\txdrawglyphfontspecs(specs, base, i, ox, y1);\n}\n\nvoid\nxfinishdraw(void)\n{\n\tXCopyArea(xw.dpy, xw.buf, xw.win, dc.gc, 0, 0, win.w,\n\t\t\twin.h, 0, 0);\n\tXSetForeground(xw.dpy, dc.gc,\n\t\t\tdc.col[IS_SET(MODE_REVERSE)?\n\t\t\t\tdefaultfg : defaultbg].pixel);\n}\n\nvoid\nxximspot(int x, int y)\n{\n\tif (xw.ime.xic == NULL)\n\t\treturn;\n\n\txw.ime.spot.x = borderpx + x * win.cw;\n\txw.ime.spot.y = borderpx + (y + 1) * win.ch;\n\n\tXSetICValues(xw.ime.xic, XNPreeditAttributes, xw.ime.spotlist, NULL);\n}\n\nvoid\nexpose(XEvent *ev)\n{\n\tredraw();\n}\n\nvoid\nvisibility(XEvent *ev)\n{\n\tXVisibilityEvent *e = &ev->xvisibility;\n\n\tMODBIT(win.mode, e->state != VisibilityFullyObscured, MODE_VISIBLE);\n}\n\nvoid\nunmap(XEvent *ev)\n{\n\twin.mode &= ~MODE_VISIBLE;\n}\n\nvoid\nxsetpointermotion(int set)\n{\n\tMODBIT(xw.attrs.event_mask, set, PointerMotionMask);\n\tXChangeWindowAttributes(xw.dpy, xw.win, CWEventMask, &xw.attrs);\n}\n\nvoid\nxsetmode(int set, unsigned int flags)\n{\n\tint mode = win.mode;\n\tMODBIT(win.mode, set, flags);\n\tif ((win.mode & MODE_REVERSE) != (mode & MODE_REVERSE))\n\t\tredraw();\n}\n\nint\nxsetcursor(int cursor)\n{\n\tif (!BETWEEN(cursor, 0, 7)) /* 7: st extension */\n\t\treturn 1;\n\twin.cursor = cursor;\n\treturn 0;\n}\n\nvoid\nxseturgency(int add)\n{\n\tXWMHints *h = XGetWMHints(xw.dpy, xw.win);\n\n\tMODBIT(h->flags, add, XUrgencyHint);\n\tXSetWMHints(xw.dpy, xw.win, h);\n\tXFree(h);\n}\n\nvoid\nxbell(void)\n{\n\tif (!(IS_SET(MODE_FOCUSED)))\n\t\txseturgency(1);\n\tif (bellvolume)\n\t\tXkbBell(xw.dpy, xw.win, bellvolume, (Atom)NULL);\n}\n\nvoid\nfocus(XEvent *ev)\n{\n\tXFocusChangeEvent *e = &ev->xfocus;\n\n\tif (e->mode == NotifyGrab)\n\t\treturn;\n\n\tif (ev->type == FocusIn) {\n\t\tif (xw.ime.xic)\n\t\t\tXSetICFocus(xw.ime.xic);\n\t\twin.mode |= MODE_FOCUSED;\n\t\txseturgency(0);\n\t\tif (IS_SET(MODE_FOCUS))\n\t\t\tttywrite(\"\\033[I\", 3, 0);\n\t\tif (!focused) {\n\t\t\tfocused = 1;\n\t\t\txloadcols();\n\t\t\ttfulldirt();\n\t\t}\n\t} else {\n\t\tif (xw.ime.xic)\n\t\t\tXUnsetICFocus(xw.ime.xic);\n\t\twin.mode &= ~MODE_FOCUSED;\n\t\tif (IS_SET(MODE_FOCUS))\n\t\t\tttywrite(\"\\033[O\", 3, 0);\n\t\tif (focused) {\n\t\t\tfocused = 0;\n\t\t\txloadcols();\n\t\t\ttfulldirt();\n\t\t}\n\t}\n}\n\nint\nmatch(uint mask, uint state)\n{\n\treturn mask == XK_ANY_MOD || mask == (state & ~ignoremod);\n}\n\nchar*\nkmap(KeySym k, uint state)\n{\n\tKey *kp;\n\tint i;\n\n\t/* Check for mapped keys out of X11 function keys. */\n\tfor (i = 0; i < LEN(mappedkeys); i++) {\n\t\tif (mappedkeys[i] == k)\n\t\t\tbreak;\n\t}\n\tif (i == LEN(mappedkeys)) {\n\t\tif ((k & 0xFFFF) < 0xFD00)\n\t\t\treturn NULL;\n\t}\n\n\tfor (kp = key; kp < key + LEN(key); kp++) {\n\t\tif (kp->k != k)\n\t\t\tcontinue;\n\n\t\tif (!match(kp->mask, state))\n\t\t\tcontinue;\n\n\t\tif (IS_SET(MODE_APPKEYPAD) ? kp->appkey < 0 : kp->appkey > 0)\n\t\t\tcontinue;\n\t\tif (IS_SET(MODE_NUMLOCK) && kp->appkey == 2)\n\t\t\tcontinue;\n\n\t\tif (IS_SET(MODE_APPCURSOR) ? kp->appcursor < 0 : kp->appcursor > 0)\n\t\t\tcontinue;\n\n\t\treturn kp->s;\n\t}\n\n\treturn NULL;\n}\n\nvoid\nkpress(XEvent *ev)\n{\n\tXKeyEvent *e = &ev->xkey;\n\tKeySym ksym;\n\tchar *buf = NULL, *customkey;\n\tint len = 0;\n\tint buf_size = 64;\n\tint critical = - 1;\n\tRune c;\n\tStatus status;\n\tShortcut *bp;\n\n\tif (IS_SET(MODE_KBDLOCK))\n\t\treturn;\n\nreallocbuf:\n\tif (critical > 0)\n\t\tgoto cleanup;\n\tif (buf)\n\t\tfree(buf);\n\n\tbuf = xmalloc((buf_size) * sizeof(char));\n\tcritical += 1;\n\n\tif (xw.ime.xic) {\n\t\tlen = XmbLookupString(xw.ime.xic, e, buf, buf_size, &ksym, &status);\n\t\tif (status == XBufferOverflow) {\n\t\t\tbuf_size = len;\n\t\t\tgoto reallocbuf;\n\t\t}\n\t} else {\n\t\t// Not sure how to fix this and if it is fixable\n\t\t// but at least it does write something into the buffer\n\t\t// so it is not as critical\n\t\tlen = XLookupString(e, buf, buf_size, &ksym, NULL);\n\t}\n\t/* 1. shortcuts */\n\tfor (bp = shortcuts; bp < shortcuts + LEN(shortcuts); bp++) {\n\t\tif (ksym == bp->keysym && match(bp->mod, e->state)) {\n\t\t\tbp->func(&(bp->arg));\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* 2. custom keys from config.h */\n\tif ((customkey = kmap(ksym, e->state))) {\n\t\tttywrite(customkey, strlen(customkey), 1);\n\t\tgoto cleanup;\n\t}\n\n\t/* 3. composed string from input method */\n\tif (len == 0)\n\t\tgoto cleanup;\n\tif (len == 1 && e->state & Mod1Mask) {\n\t\tif (IS_SET(MODE_8BIT)) {\n\t\t\tif (*buf < 0177) {\n\t\t\t\tc = *buf | 0x80;\n\t\t\t\tlen = utf8encode(c, buf);\n\t\t\t}\n\t\t} else {\n\t\t\tbuf[1] = buf[0];\n\t\t\tbuf[0] = '\\033';\n\t\t\tlen = 2;\n\t\t}\n\t}\n\tif (len <= buf_size)\n\t\tttywrite(buf, len, 1);\ncleanup:\n\tif (buf)\n\t\tfree(buf);\n}\n\nvoid\ncmessage(XEvent *e)\n{\n\t/*\n\t * See xembed specs\n\t *  http://standards.freedesktop.org/xembed-spec/xembed-spec-latest.html\n\t */\n\tif (e->xclient.message_type == xw.xembed && e->xclient.format == 32) {\n\t\tif (e->xclient.data.l[1] == XEMBED_FOCUS_IN) {\n\t\t\twin.mode |= MODE_FOCUSED;\n\t\t\txseturgency(0);\n\t\t} else if (e->xclient.data.l[1] == XEMBED_FOCUS_OUT) {\n\t\t\twin.mode &= ~MODE_FOCUSED;\n\t\t}\n\t} else if (e->xclient.data.l[0] == xw.wmdeletewin) {\n\t\tttyhangup();\n\t\texit(0);\n\t}\n}\n\nvoid\nresize(XEvent *e)\n{\n\tif (e->xconfigure.width == win.w && e->xconfigure.height == win.h)\n\t\treturn;\n\n\tcresize(e->xconfigure.width, e->xconfigure.height);\n}\n\nvoid\nrun(void)\n{\n\tXEvent ev;\n\tint w = win.w, h = win.h;\n\tfd_set rfd;\n\tint xfd = XConnectionNumber(xw.dpy), ttyfd, xev, drawing;\n\tstruct timespec seltv, *tv, now, lastblink, trigger;\n\tdouble timeout;\n\n\t/* Waiting for window mapping */\n\tdo {\n\t\tXNextEvent(xw.dpy, &ev);\n\t\t/*\n\t\t * This XFilterEvent call is required because of XOpenIM. It\n\t\t * does filter out the key event and some client message for\n\t\t * the input method too.\n\t\t */\n\t\tif (XFilterEvent(&ev, None))\n\t\t\tcontinue;\n\t\tif (ev.type == ConfigureNotify) {\n\t\t\tw = ev.xconfigure.width;\n\t\t\th = ev.xconfigure.height;\n\t\t}\n\t} while (ev.type != MapNotify);\n\n\tttyfd = ttynew(opt_line, shell, opt_io, opt_cmd);\n\tcresize(w, h);\n\n\tfor (timeout = -1, drawing = 0, lastblink = (struct timespec){0};;) {\n\t\tFD_ZERO(&rfd);\n\t\tFD_SET(ttyfd, &rfd);\n\t\tFD_SET(xfd, &rfd);\n\n\t\tif (XPending(xw.dpy))\n\t\t\ttimeout = 0;  /* existing events might not set xfd */\n\n\t\tseltv.tv_sec = timeout / 1E3;\n\t\tseltv.tv_nsec = 1E6 * (timeout - 1E3 * seltv.tv_sec);\n\t\ttv = timeout >= 0 ? &seltv : NULL;\n\n\t\tif (pselect(MAX(xfd, ttyfd)+1, &rfd, NULL, NULL, tv, NULL) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tdie(\"select failed: %s\\n\", strerror(errno));\n\t\t}\n\t\tclock_gettime(CLOCK_MONOTONIC, &now);\n\n\t\tif (FD_ISSET(ttyfd, &rfd))\n\t\t\tttyread();\n\n\t\txev = 0;\n\t\twhile (XPending(xw.dpy)) {\n\t\t\txev = 1;\n\t\t\tXNextEvent(xw.dpy, &ev);\n\t\t\tif (XFilterEvent(&ev, None))\n\t\t\t\tcontinue;\n\t\t\tif (handler[ev.type])\n\t\t\t\t(handler[ev.type])(&ev);\n\t\t}\n\n\t\t/*\n\t\t * To reduce flicker and tearing, when new content or event\n\t\t * triggers drawing, we first wait a bit to ensure we got\n\t\t * everything, and if nothing new arrives - we draw.\n\t\t * We start with trying to wait minlatency ms. If more content\n\t\t * arrives sooner, we retry with shorter and shorter periods,\n\t\t * and eventually draw even without idle after maxlatency ms.\n\t\t * Typically this results in low latency while interacting,\n\t\t * maximum latency intervals during `cat huge.txt`, and perfect\n\t\t * sync with periodic updates from animations/key-repeats/etc.\n\t\t */\n\t\tif (FD_ISSET(ttyfd, &rfd) || xev) {\n\t\t\tif (!drawing) {\n\t\t\t\ttrigger = now;\n\t\t\t\tdrawing = 1;\n\t\t\t}\n\t\t\ttimeout = (maxlatency - TIMEDIFF(now, trigger)) \\\n\t\t\t          / maxlatency * minlatency;\n\t\t\tif (timeout > 0)\n\t\t\t\tcontinue;  /* we have time, try to find idle */\n\t\t}\n\n\t\t/* idle detected or maxlatency exhausted -> draw */\n\t\ttimeout = -1;\n\t\tif (blinktimeout && tattrset(ATTR_BLINK)) {\n\t\t\ttimeout = blinktimeout - TIMEDIFF(now, lastblink);\n\t\t\tif (timeout <= 0) {\n\t\t\t\tif (-timeout > blinktimeout) /* start visible */\n\t\t\t\t\twin.mode |= MODE_BLINK;\n\t\t\t\twin.mode ^= MODE_BLINK;\n\t\t\t\ttsetdirtattr(ATTR_BLINK);\n\t\t\t\tlastblink = now;\n\t\t\t\ttimeout = blinktimeout;\n\t\t\t}\n\t\t}\n\n\t\tdraw();\n\t\tXFlush(xw.dpy);\n\t\tdrawing = 0;\n\t}\n}\n\nint\nresource_load(XrmDatabase db, char *name, enum resource_type rtype, void *dst)\n{\n\tchar **sdst = dst;\n\tint *idst = dst;\n\tfloat *fdst = dst;\n\n\tchar fullname[256];\n\tchar fullclass[256];\n\tchar *type;\n\tXrmValue ret;\n\n\tsnprintf(fullname, sizeof(fullname), \"%s.%s\",\n\t\t\topt_name ? opt_name : \"st\", name);\n\tsnprintf(fullclass, sizeof(fullclass), \"%s.%s\",\n\t\t\topt_class ? opt_class : \"St\", name);\n\tfullname[sizeof(fullname) - 1] = fullclass[sizeof(fullclass) - 1] = '\\0';\n\n\tXrmGetResource(db, fullname, fullclass, &type, &ret);\n\tif (ret.addr == NULL || strncmp(\"String\", type, 64))\n\t\treturn 1;\n\n\tswitch (rtype) {\n\tcase STRING:\n\t\t*sdst = ret.addr;\n\t\tbreak;\n\tcase INTEGER:\n\t\t*idst = strtoul(ret.addr, NULL, 10);\n\t\tbreak;\n\tcase FLOAT:\n\t\t*fdst = strtof(ret.addr, NULL);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nvoid\nconfig_init(void)\n{\n\tchar *resm;\n\tXrmDatabase db;\n\tResourcePref *p;\n\n\tXrmInitialize();\n\tresm = XResourceManagerString(xw.dpy);\n\tif (!resm)\n\t\treturn;\n\n\tdb = XrmGetStringDatabase(resm);\n\tfor (p = resources; p < resources + LEN(resources); p++)\n\t\tresource_load(db, p->name, p->type, p->dst);\n}\n\nvoid\nusage(void)\n{\n\tdie(\"usage: %s [-aiv] [-c class] [-f font] [-g geometry]\"\n\t    \" [-n name] [-o file]\\n\"\n\t    \"          [-T title] [-t title] [-w windowid]\"\n\t    \" [[-e] command [args ...]]\\n\"\n\t    \"       %s [-aiv] [-c class] [-f font] [-g geometry]\"\n\t    \" [-n name] [-o file]\\n\"\n\t    \"          [-T title] [-t title] [-w windowid] -l line\"\n\t    \" [stty_args ...]\\n\", argv0, argv0);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\txw.l = xw.t = 0;\n\txw.isfixed = False;\n\txsetcursor(cursorshape);\n\n\tARGBEGIN {\n\tcase 'a':\n\t\tallowaltscreen = 0;\n\t\tbreak;\n\tcase 'A':\n\t\topt_alpha = EARGF(usage());\n\t\tbreak;\n\tcase 'c':\n\t\topt_class = EARGF(usage());\n\t\tbreak;\n\tcase 'e':\n\t\tif (argc > 0)\n\t\t\t--argc, ++argv;\n\t\tgoto run;\n\tcase 'f':\n\t\topt_font = EARGF(usage());\n\t\tbreak;\n\tcase 'g':\n\t\txw.gm = XParseGeometry(EARGF(usage()),\n\t\t\t\t&xw.l, &xw.t, &cols, &rows);\n\t\tbreak;\n\tcase 'i':\n\t\txw.isfixed = 1;\n\t\tbreak;\n\tcase 'o':\n\t\topt_io = EARGF(usage());\n\t\tbreak;\n\tcase 'l':\n\t\topt_line = EARGF(usage());\n\t\tbreak;\n\tcase 'n':\n\t\topt_name = EARGF(usage());\n\t\tbreak;\n\tcase 't':\n\tcase 'T':\n\t\topt_title = EARGF(usage());\n\t\tbreak;\n\tcase 'w':\n\t\topt_embed = EARGF(usage());\n\t\tbreak;\n\tcase 'v':\n\t\tdie(\"%s \" VERSION \"\\n\", argv0);\n\t\tbreak;\n\tdefault:\n\t\tusage();\n\t} ARGEND;\n\nrun:\n\tif (argc > 0) /* eat all remaining arguments */\n\t\topt_cmd = argv;\n\n\tif (!opt_title)\n\t\topt_title = (opt_line || !opt_cmd) ? \"st\" : opt_cmd[0];\n\n\tsetlocale(LC_CTYPE, \"\");\n\tXSetLocaleModifiers(\"\");\n\n\tif(!(xw.dpy = XOpenDisplay(NULL)))\n\t\tdie(\"Can't open display\\n\");\n\n\tconfig_init();\n\tcols = MAX(cols, 1);\n\trows = MAX(rows, 1);\n\tdefaultbg = MAX(LEN(colorname), 256);\n\talphaUnfocus = alpha-alphaOffset;\n\ttnew(cols, rows);\n\txinit(cols, rows);\n\txsetenv();\n\tselinit();\n\trun();\n\n\treturn 0;\n}\n\n"
        }
      ]
    }
  ]
}