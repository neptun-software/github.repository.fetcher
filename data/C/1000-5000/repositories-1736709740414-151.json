{
  "metadata": {
    "timestamp": 1736709740414,
    "page": 151,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dankamongmen/notcurses",
      "stars": 3715,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".drone.yml",
          "type": "blob",
          "size": 3.107421875,
          "content": "---\nkind: pipeline\ntype: docker\nname: debian-unstable\n\nsteps:\n- name: debian-build\n  image: debian:unstable-slim\n  commands:\n    - export LANG=en_US.UTF-8\n    - export TERM=xterm\n    - apt-get update -y\n    - apt-get install -y ncurses-dev pkgconf libqrcodegen-dev libavdevice-dev cmake build-essential doctest-dev libunistring-dev libdeflate-dev libgpm-dev pandoc locales\n    - echo \"en_US.UTF-8 UTF-8\" > /etc/locale.gen\n    - locale-gen\n    - mkdir build\n    - cd build\n    - cmake .. -DCMAKE_BUILD_TYPE=Release -DUSE_STATIC=off -DUSE_GPM=on -DUSE_QRCODEGEN=on -DDFSG_BUILD=on -DBUILD_FFI_LIBRARY=on\n    - make -j2\n    - ./notcurses-info\n    - ctest --output-on-failure\n    - make install\n    - ldconfig\n    - apt-get install -y python3-setuptools python3-wheel python3-pip python3-pypandoc python3-cffi-backend\n    - cd ../cffi\n    - LDFLAGS=-L/usr/local/lib CFLAGS=-I/usr/local/include python3 setup.py sdist build install\n    - env LD_LIBRARY_PATH=/usr/local/lib ./notcurses-pydemo > /dev/null\n    - env LD_LIBRARY_PATH=/usr/local/lib ./ncdirect-pydemo > /dev/null\n---\nkind: pipeline\ntype: docker\nname: fedora-rawhide\n\nsteps:\n- name: fedora-rawhide\n  image: dankamongmen/rawhide:2021-11-14a\n  commands:\n    - export LANG=en_US.UTF-8\n    - export TERM=xterm\n    - mkdir build\n    - cd build\n    - cmake -DCMAKE_BUILD_TYPE=Release -DUSE_DEFLATE=off -DUSE_MULTIMEDIA=oiio -DUSE_QRCODEGEN=on ..\n    - make -j2\n    - ./notcurses-info\n    - ctest --output-on-failure\n    - make install\n    - ldconfig\n    - cd ../cffi\n    - LDFLAGS=-L/usr/local/lib CFLAGS=-I/usr/local/include python3 setup.py sdist build install\n    - cd ../python\n    - LDFLAGS=-L/usr/local/lib CFLAGS=-I/usr/local/include python3 setup.py sdist build install\n    - env LD_LIBRARY_PATH=/usr/local/lib ./notcurses-pydemo > /dev/null\n    - env LD_LIBRARY_PATH=/usr/local/lib ./ncdirect-pydemo > /dev/null\n---\nkind: pipeline\ntype: docker\nname: ubuntu-noble\n\nsteps:\n- name: ubuntu-build\n  image: dankamongmen/noble:2024-12-31b\n  commands:\n    - export LANG=es_ES.UTF-8\n    - export TERM=xterm\n    - mkdir build\n    - cd build\n    - cmake -DCMAKE_BUILD_TYPE=Debug -DUSE_DOCTEST=off -DUSE_QRCODEGEN=on -DUSE_MULTIMEDIA=none ..\n    - make -j2\n    - ./notcurses-info\n    - ctest --output-on-failure\n    - make install\n    - ldconfig\n    - cd ../cffi\n    - python3 setup.py sdist build\n    - cd ../python\n    - LDFLAGS=-L/usr/local/lib CFLAGS=-I/usr/local/include python3 setup.py sdist build install\n---\nkind: pipeline\ntype: docker\nname: alpine-edge\n\nsteps:\n- name: alpine-edge\n  image: dankamongmen/edge_builder:2024-12-31a\n  commands:\n    - export LANG=en_US.UTF-8\n    - export TERM=vt100\n    - mkdir build\n    - cd build\n    - cmake -DCMAKE_BUILD_TYPE=Release -DUSE_PANDOC=off ..\n    - make -j2\n    - ./notcurses-info\n    - ctest --output-on-failure\n---\nkind: pipeline\ntype: docker\nname: gentoo\n\nsteps:\n- name: gentoo\n  image: dankamongmen/gentoo:2025-01-02b\n  commands:\n    - export LANG=C.UTF-8\n    - export TERM=xterm\n    - mkdir build\n    - cd build\n    - cmake -DCMAKE_BUILD_TYPE=Release -DUSE_PANDOC=off -DUSE_DOCTEST=off -DUSE_DEFLATE=off ..\n    - make -j2\n    - ./notcurses-info\n    - ctest --output-on-failure\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3466796875,
          "content": "build*\ncffi/build\ncffi/dist\ncffi/src/notcurses.egg-info\ndoc/examples/book\nobj-x86_64-linux-gnu\ncffi/include\npython/.eggs/\npython/build/\npython/dist/\npython/notcurses-pydemo.1\npython/notcurses-direct-pydemo.1\npython/src/notcurses.egg-info/\npython/src/_notcurses.so\ntools/function-summary/out-*\nrust/target\nrust/Cargo.lock\n*.asc\n*.pyc\n*.so\n*.swp\n*.swo\n*.xz\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 32.7783203125,
          "content": "# 3.14.0 introduced NAME_WLE\ncmake_minimum_required(VERSION 3.14.0)\nproject(notcurses VERSION 3.0.13\n  DESCRIPTION \"Blingful UI for modern terminal emulators\"\n  HOMEPAGE_URL \"https://nick-black.com/dankwiki/index.php/notcurses\"\n  LANGUAGES C)\ninclude(CTest)\ninclude(GNUInstallDirs)\ninclude(CMakeDependentOption)\ninclude(FeatureSummary)\n\n###################### USER-SELECTABLE OPTIONS ###########################\n# BUILD_TESTING is defined by CTest\noption(DFSG_BUILD \"DFSG build (no non-free media/code)\" OFF)\noption(USE_ASAN \"Build with AddressSanitizer\" OFF)\noption(USE_COVERAGE \"Assess code coverage with llvm-cov/lcov\" OFF)\noption(USE_CXX \"Build C++ code\" ON)\ncmake_dependent_option(\n  USE_DOCTEST \"Build notcurses-tester with doctest\" ON\n  \"BUILD_TESTING;USE_CXX\" OFF\n)\noption(USE_DEFLATE \"Use libdeflate instead of libz\" ON)\noption(USE_DOXYGEN \"Build HTML cross reference with doxygen\" OFF)\noption(USE_GPM \"Enable libgpm console mouse support\" OFF)\noption(USE_PANDOC \"Build man pages and HTML reference with pandoc\" ON)\noption(BUILD_EXECUTABLES \"Build executables\" ON)\noption(BUILD_FFI_LIBRARY \"Build ffi library (containing all symbols which are static inline)\" ON)\noption(USE_POC \"Build small, uninstalled proof-of-concept binaries\" ON)\noption(USE_QRCODEGEN \"Enable libqrcodegen QR code support\" OFF)\noption(USE_STATIC \"Build static libraries (in addition to shared)\" ON)\ncmake_dependent_option(\n  USE_STATIC_BINARIES \"Link binaries statically (requires USE_STATIC)\" OFF\n  \"USE_STATIC\" ON\n)\nset(USE_MULTIMEDIA \"ffmpeg\" CACHE STRING \"Multimedia engine, one of 'ffmpeg', 'oiio', or 'none'\")\nset_property(CACHE USE_MULTIMEDIA PROPERTY STRINGS ffmpeg oiio none)\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE\n    STRING \"Choose the build mode.\" FORCE)\nendif()\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS Debug Release MinSizeRel RelWithDebInfo Coverage)\n############## END (additional) USER-SELECTABLE OPTIONS ##################\nset(USE_FFMPEG OFF)\nset(USE_OIIO OFF)\nif(${USE_MULTIMEDIA} STREQUAL \"ffmpeg\")\n  set(USE_FFMPEG ON)\nelseif(${USE_MULTIMEDIA} STREQUAL \"oiio\")\n  if(NOT ${USE_CXX})\n    message(FATAL_ERROR \"USE_CXX must be on to use OpenImageIO.\")\n  endif()\n  set(USE_OIIO ON)\nelseif(NOT ${USE_MULTIMEDIA} STREQUAL \"none\")\n  message(FATAL_ERROR \"USE_MULTIMEDIA must be one of 'oiio', 'ffmpeg', 'none' (was '${USE_MULTIMEDIA}').\")\nendif()\nif (NOT BUILD_EXECUTABLES AND USE_POC)\n  message(WARNING \"Disabling USE_POC since BUILD_EXECUTABLES=OFF\")\n  set(USE_POC OFF)\nendif()\n\nif(${USE_CXX})\n  enable_language(CXX)\nendif()\nif(${USE_CXX})\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_VISIBILITY_PRESET hidden)\nstring(APPEND CMAKE_CXX_FLAGS_DEBUG \" -Og\")\nendif()\nset(CMAKE_C_STANDARD 17)\nset(CMAKE_C_VISIBILITY_PRESET hidden)\n\nmessage(STATUS \"Requested multimedia engine: ${USE_MULTIMEDIA}\")\nmessage(STATUS \"Requested build mode: ${CMAKE_BUILD_TYPE}\")\n\nstring(APPEND CMAKE_C_FLAGS_DEBUG \" -Og\")\nif(${USE_COVERAGE})\n  if(NOT \"${CMAKE_C_COMPILER_ID}\" MATCHES \"(Apple)?[Cc]lang\")\n    message(FATAL_ERROR \"USE_COVERAGE was on but CC isn't clang\")\n  endif()\n  # FIXME requires clang11+\n  string(APPEND CMAKE_C_FLAGS_DEBUG \" --coverage -fprofile-instr-generate -fcoverage-mapping\")\n  if(${USE_CXX})\n    if(NOT \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(Apple)?[Cc]lang\")\n      message(FATAL_ERROR \"USE_COVERAGE was on but CXX isn't clang++\")\n    endif()\n    string(APPEND CMAKE_CXX_FLAGS_DEBUG \" --coverage -fprofile-instr-generate -fcoverage-mapping\")\n  endif()\nendif()\n\n# under msys2 (and all other operating systems) we want pkgconfig. when\n# building with visual studio, don't require it.\nif(NOT MSVC)\nif(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\nset(PKGCONFIG_DIR \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\")\nelseif(APPLE)\n# surely there's a better way to do this? alas, seems necessary to pull the\n# pkg-config files out of Homebrew.\nif(NOT DEFINED ENV{PKG_CONFIG_PATH})\nset(ENV{PKG_CONFIG_PATH} \"/usr/local/opt/ncurses/lib/pkgconfig\")\nendif()\nset(PKGCONFIG_DIR \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\")\nelse()\nset(PKGCONFIG_DIR \"${CMAKE_INSTALL_PREFIX}/libdata/pkgconfig\")\nendif()\nfind_package(PkgConfig REQUIRED)\n# some distros (<cough>motherfucking alpine</cough> subsume terminfo directly\n# into ncurses. accept either, and may god have mercy on our souls.\npkg_search_module(TERMINFO REQUIRED tinfo>=6.1 ncursesw>=6.1)\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND terminfo)\nset_package_properties(terminfo PROPERTIES TYPE REQUIRED)\nset(PKGCONF_REQ_PRIV \"${TERMINFO_LIBRARIES}\")\n\nif(${USE_FFMPEG})\npkg_check_modules(AVCODEC REQUIRED libavcodec>=57.0)\npkg_check_modules(AVDEVICE REQUIRED libavdevice>=57.0)\npkg_check_modules(AVFORMAT REQUIRED libavformat>=57.0)\npkg_check_modules(AVUTIL REQUIRED libavutil>=56.0)\npkg_check_modules(SWSCALE REQUIRED libswscale>=5.0)\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND FFMpeg)\nelseif(${USE_OIIO})\npkg_check_modules(OPENIMAGEIO REQUIRED OpenImageIO>=2.1)\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND OpenImageIO)\nendif()\nendif()\n\n# global compiler flags\nif(NOT WIN32)\n# MSYS2 needs -lssp and -fstack-protector for _FORTIFY_SOURCE\n# macOS with ASAN can't handle _FORTIFY_SOURCE != 1\nif(NOT ${USE_ASAN})\nadd_compile_definitions(_FORTIFY_SOURCE=2)\nendif()\nadd_compile_options(-Wformat -Werror=format-security)\nendif()\nif(MSVC)\nadd_compile_options(/W4)\nelse()\nadd_compile_options(-Wall -Wextra -W -Wshadow -Wvla -Wstrict-aliasing=2)\n# -ffast-math dies on NaNs we draw from libav (by -ffinite-math-only)\nadd_compile_options(-fno-signed-zeros -fno-trapping-math -fassociative-math)\nadd_compile_options(-fno-math-errno -freciprocal-math -funsafe-math-optimizations)\nadd_compile_options(-fexceptions -fstrict-aliasing)\nif(${USE_ASAN})\nadd_compile_options(-fsanitize=address)\nadd_link_options(-fsanitize=address)\nendif()\nendif()\n\n# don't use REQUIRED with subsequent find_package() operations; we use\n# feature_summary + set_package_properties to fail in one fell swoop.\nfind_package(Threads)\nset_package_properties(Threads PROPERTIES TYPE REQUIRED)\n# platform-specific logics\nif(WIN32)\n  set(LIBRT wsock32 ws2_32 secur32)\nelseif(NOT APPLE)\n  find_library(LIBM m REQUIRED)\n  find_library(LIBRT rt REQUIRED)\nendif()\nif(NOT ${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n  include_directories(/usr/local/include)\n  link_directories(/usr/local/lib)\n  set(CMAKE_REQUIRED_INCLUDES /usr/local/include)\nendif()\n\nif(${USE_DOCTEST})\nfind_package(doctest 2.3.5)\nset_package_properties(doctest PROPERTIES TYPE REQUIRED)\nendif()\n\n# don't cache these, or installing them requires clearing the cache to be found.\n# this is going to be true for anything lacking pkg-config/CMake support.\n# unigbrk.h was introduced in libunistring 0.9.4, 2010-02-14.\nunset(HAVE_UNISTRING_H CACHE)\nfind_path(UNISTRING_INCLUDE unigbrk.h)\nset(CMAKE_REQUIRED_INCLUDES ${UNISTRING_INCLUDE})\ncheck_include_file(\"unigbrk.h\" HAVE_UNISTRING_H)\nif(NOT \"${HAVE_UNISTRING_H}\")\n  message(FATAL_ERROR \"Couldn't find unigbrk.h from GNU libunistring\")\nendif()\nfind_library(unistring unistring REQUIRED)\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND libunistring)\nset_package_properties(libunistring PROPERTIES TYPE REQUIRED)\n\n# optional dependencies lacking pkg-config support\n# libdeflate has had pkgconf support since 1.9, where is it on ubuntu? FIXME\nif(${USE_DEFLATE})\nunset(HAVE_DEFLATE_H CACHE)\ncheck_include_file(\"libdeflate.h\" HAVE_DEFLATE_H)\nif(NOT \"${HAVE_DEFLATE_H}\")\n  message(FATAL_ERROR \"Couldn't find libdeflate.h\")\nendif()\nfind_library(DEFLATE deflate REQUIRED)\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND DEFLATE)\nset_package_properties(DEFLATE PROPERTIES TYPE REQUIRED)\nset(DEFLATE_LIBRARIES ${DEFLATE})\nelse()\nfind_package(ZLIB)\nset_package_properties(ZLIB PROPERTIES TYPE REQUIRED)\nendif()\n\nif(${USE_GPM}) # no pkgconfig from gpm\nunset(HAVE_GPM_H CACHE)\ncheck_include_file(\"gpm.h\" HAVE_GPM_H)\nif(NOT \"${HAVE_GPM_H}\")\n  message(FATAL_ERROR \"Couldn't find gpm.h from libgpm\")\nendif()\nfind_library(gpm gpm REQUIRED)\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND libgpm)\nset_package_properties(libgpm PROPERTIES TYPE REQUIRED)\nendif()\n\nif(\"${USE_QRCODEGEN}\")\nunset(HAVE_QRCODEGEN_H CACHE)\ncheck_include_file(\"qrcodegen/qrcodegen.h\" HAVE_QRCODEGEN_H)\nif(NOT \"${HAVE_QRCODEGEN_H}\")\n  message(FATAL_ERROR \"USE_QRCODEGEN is active, but couldn't find qrcodegen.h\")\nendif()\nset_property(GLOBAL APPEND PROPERTY PACKAGES_FOUND qrcodegen)\nendif()\n\nfeature_summary(WHAT ALL FATAL_ON_MISSING_REQUIRED_PACKAGES)\n\nfile(GLOB COMPATSRC CONFIGURE_DEPENDS src/compat/*.c)\n\n############################################################################\n# libnotcurses-core (core shared library, core static library)\nfile(GLOB NCCORESRCS CONFIGURE_DEPENDS src/lib/*.c)\nadd_library(notcurses-core SHARED ${NCCORESRCS} ${COMPATSRC})\nif(${USE_STATIC})\nadd_library(notcurses-core-static STATIC ${NCCORESRCS} ${COMPATSRC})\nelse()\nadd_library(notcurses-core-static STATIC EXCLUDE_FROM_ALL ${NCCORESRCS} ${COMPATSRC})\nendif()\n# don't want these on freebsd/dragonfly/osx\nif(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\ntarget_compile_definitions(notcurses-core\n  PUBLIC\n   _XOPEN_SOURCE=700 # wcwidth(3) requires _XOPEN_SOURCE, and is in our headers\n  PRIVATE\n   _GNU_SOURCE _DEFAULT_SOURCE\n)\ntarget_compile_definitions(notcurses-core-static\n  PUBLIC\n   _XOPEN_SOURCE=700 # wcwidth(3) requires _XOPEN_SOURCE, and is in our headers\n  PRIVATE\n   _GNU_SOURCE _DEFAULT_SOURCE\n)\nendif()\nset_target_properties(notcurses-core PROPERTIES\n  VERSION ${PROJECT_VERSION}\n  SOVERSION ${PROJECT_VERSION_MAJOR}\n)\nset_target_properties(notcurses-core-static PROPERTIES\n  VERSION ${PROJECT_VERSION}\n  OUTPUT_NAME notcurses-core\n)\ntarget_include_directories(notcurses-core\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n    \"${DEFLATE_INCLUDE_DIRS}\"\n    \"${ZLIB_INCLUDE_DIRS}\"\n)\ntarget_include_directories(notcurses-core-static\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_STATIC_INCLUDE_DIRS}\"\n    \"${DEFLATE_STATIC_INCLUDE_DIRS}\"\n    \"${ZLIB_STATIC_INCLUDE_DIRS}\"\n)\ntarget_link_libraries(notcurses-core\n  PRIVATE\n    \"${TERMINFO_LIBRARIES}\"\n    \"${LIBM}\"\n    \"${unistring}\"\n    \"${gpm}\"\n    \"${DEFLATE_LIBRARIES}\"\n    \"${ZLIB_LIBRARIES}\"\n  PUBLIC\n    Threads::Threads\n    \"${LIBRT}\"\n)\ntarget_link_libraries(notcurses-core-static\n  PRIVATE\n    \"${TERMINFO_STATIC_LIBRARIES}\"\n    \"${LIBM}\"\n    \"${unistring}\"\n    \"${gpm}\"\n    \"${DEFLATE_STATIC_LIBRARIES}\"\n    \"${ZLIB_STATIC_LIBRARIES}\"\n    Threads::Threads\n    \"${LIBRT}\"\n)\ntarget_link_directories(notcurses-core\n  PRIVATE\n    \"${TERMINFO_LIBRARY_DIRS}\"\n    \"${DEFLATE_LIBRARY_DIRS}\"\n    \"${ZLIB_LIBRARY_DIRS}\"\n)\ntarget_link_directories(notcurses-core-static\n  PRIVATE\n    \"${TERMINFO_STATIC_LIBRARY_DIRS}\"\n    \"${DEFLATE_STATIC_LIBRARY_DIRS}\"\n    \"${ZLIB_STATIC_LIBRARY_DIRS}\"\n)\nif(${USE_QRCODEGEN})\ntarget_link_libraries(notcurses-core PRIVATE qrcodegen)\ntarget_link_libraries(notcurses-core-static PRIVATE qrcodegen)\nendif()\n\n############################################################################\n# libnotcurses (multimedia shared library+static library)\nfile(GLOB NCSRCS CONFIGURE_DEPENDS src/media/*.c src/media/*.cpp)\nadd_library(notcurses SHARED ${NCSRCS} ${COMPATSRC})\nif(${USE_STATIC})\n# can't build binaries against static notcurses until ffmpeg linking issues\n# are resolved (USE_STATIC_BINARIES) FIXME\nadd_library(notcurses-static STATIC ${NCSRCS} ${COMPATSRC})\nelse()\nadd_library(notcurses-static STATIC EXCLUDE_FROM_ALL ${NCSRCS} ${COMPATSRC})\nendif()\nset_target_properties(notcurses PROPERTIES\n  VERSION ${PROJECT_VERSION}\n  SOVERSION ${PROJECT_VERSION_MAJOR}\n)\nset_target_properties(notcurses-static PROPERTIES\n  VERSION ${PROJECT_VERSION}\n  OUTPUT_NAME notcurses\n)\ntarget_include_directories(notcurses\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n)\ntarget_include_directories(notcurses-static\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n)\ntarget_compile_definitions(notcurses\n  PRIVATE\n   _GNU_SOURCE _DEFAULT_SOURCE\n)\ntarget_compile_definitions(notcurses-static\n  PRIVATE\n   _GNU_SOURCE _DEFAULT_SOURCE\n)\ntarget_link_libraries(notcurses\n  PUBLIC\n    notcurses-core\n)\ntarget_link_libraries(notcurses-static\n  PUBLIC\n    notcurses-core-static\n)\nif(${USE_FFMPEG})\ntarget_include_directories(notcurses\n  PRIVATE\n    \"${AVCODEC_INCLUDE_DIRS}\"\n    \"${AVDEVICE_INCLUDE_DIRS}\"\n    \"${AVFORMAT_INCLUDE_DIRS}\"\n    \"${AVUTIL_INCLUDE_DIRS}\"\n    \"${SWSCALE_INCLUDE_DIRS}\"\n)\ntarget_include_directories(notcurses-static\n  PRIVATE\n    \"${AVCODEC_STATIC_INCLUDE_DIRS}\"\n    \"${AVDEVICE_STATIC_INCLUDE_DIRS}\"\n    \"${AVFORMAT_STATIC_INCLUDE_DIRS}\"\n    \"${AVUTIL_STATIC_INCLUDE_DIRS}\"\n    \"${SWSCALE_STATIC_INCLUDE_DIRS}\"\n)\ntarget_link_libraries(notcurses\n  PRIVATE\n    \"${AVCODEC_LIBRARIES}\"\n    \"${AVDEVICE_LIBRARIES}\"\n    \"${AVFORMAT_LIBRARIES}\"\n    \"${SWSCALE_LIBRARIES}\"\n    \"${AVUTIL_LIBRARIES}\"\n)\ntarget_link_libraries(notcurses-static\n  PRIVATE\n    \"${AVCODEC_STATIC_LIBRARIES}\"\n    \"${AVDEVICE_STATIC_LIBRARIES}\"\n    \"${AVFORMAT_STATIC_LIBRARIES}\"\n    \"${SWSCALE_STATIC_LIBRARIES}\"\n    \"${AVUTIL_STATIC_LIBRARIES}\"\n)\ntarget_link_directories(notcurses\n  PRIVATE\n    \"${AVCODEC_LIBRARY_DIRS}\"\n    \"${AVDEVICE_LIBRARY_DIRS}\"\n    \"${AVFORMAT_LIBRARY_DIRS}\"\n    \"${SWSCALE_LIBRARY_DIRS}\"\n    \"${AVUTIL_LIBRARY_DIRS}\"\n)\ntarget_link_directories(notcurses-static\n  PRIVATE\n    \"${AVCODEC_STATIC_LIBRARY_DIRS}\"\n    \"${AVDEVICE_STATIC_LIBRARY_DIRS}\"\n    \"${AVFORMAT_STATIC_LIBRARY_DIRS}\"\n    \"${SWSCALE_STATIC_LIBRARY_DIRS}\"\n    \"${AVUTIL_STATIC_LIBRARY_DIRS}\"\n)\nelseif(${USE_OIIO})\ntarget_include_directories(notcurses PUBLIC \"${OIIO_INCLUDE_DIRS}\")\ntarget_include_directories(notcurses-static PUBLIC \"${OIIO_STATIC_INCLUDE_DIRS}\")\ntarget_link_libraries(notcurses PRIVATE OpenImageIO)\ntarget_link_libraries(notcurses-static PRIVATE ${OIIO_STATIC_LIBRARIES})\ntarget_link_directories(notcurses PRIVATE ${OIIO_LIBRARY_DIRS})\ntarget_link_directories(notcurses-static PRIVATE ${OIIO_STATIC_LIBRARY_DIRS})\nendif()\n\n#######################################\n# libnotcurses-ffi (ffi shared library)\nif(${BUILD_FFI_LIBRARY})\nfile(GLOB NCFFISRCS CONFIGURE_DEPENDS src/libffi/*.c src/libffi/*.cpp)\nadd_library(notcurses-ffi SHARED ${NCFFISRCS})\ntarget_compile_options(notcurses-ffi PUBLIC -fkeep-inline-functions)\ntarget_compile_definitions(notcurses-ffi PUBLIC NOTCURSES_FFI)\n# don't want these on freebsd/dragonfly/osx\nif(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\ntarget_compile_definitions(notcurses-ffi\n  PUBLIC\n   _XOPEN_SOURCE=700 # wcwidth(3) requires _XOPEN_SOURCE, and is in our headers\n  PRIVATE\n   _GNU_SOURCE _DEFAULT_SOURCE\n)\nendif()\nset_target_properties(notcurses-ffi PROPERTIES\n  VERSION ${PROJECT_VERSION}\n  SOVERSION ${PROJECT_VERSION_MAJOR}\n)\ntarget_include_directories(notcurses-ffi\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n    \"${DEFLATE_INCLUDE_DIRS}\"\n    \"${ZLIB_INCLUDE_DIRS}\"\n)\n\ntarget_link_libraries(notcurses-ffi\n  PRIVATE\n    \"${DEFLATE_LIBRARIES}\"\n    \"${ZLIB_LIBRARIES}\"\n    \"${TERMINFO_LIBRARIES}\"\n    \"${LIBM}\"\n    \"${unistring}\"\n    \"${gpm}\"\n    \"notcurses-core\"\n  PUBLIC\n    Threads::Threads\n    \"${LIBRT}\"\n)\n\ntarget_link_directories(notcurses-ffi\n  PRIVATE\n    \"${TERMINFO_LIBRARY_DIRS}\"\n    \"${DEFLATE_LIBRARY_DIRS}\"\n    \"${ZLIB_LIBRARY_DIRS}\"\n)\nendif()\n\n############################################################################\nif(${USE_CXX})\n# libnotcurses++ (C++ wrappers)\nset(NCPP_SOURCES\n  src/libcpp/FDPlane.cc\n  src/libcpp/Menu.cc\n  src/libcpp/MultiSelector.cc\n  src/libcpp/NotCurses.cc\n  src/libcpp/Plane.cc\n  src/libcpp/Plot.cc\n  src/libcpp/Reel.cc\n  src/libcpp/Root.cc\n  src/libcpp/Selector.cc\n  src/libcpp/Subproc.cc\n  src/libcpp/Tablet.cc\n  src/libcpp/Utilities.cc\n  )\n\nadd_library(notcurses++ SHARED ${NCPP_SOURCES})\nif(${USE_STATIC})\nadd_library(notcurses++-static STATIC ${NCPP_SOURCES})\nelse()\nadd_library(notcurses++-static STATIC EXCLUDE_FROM_ALL ${NCPP_SOURCES})\nendif()\nset_target_properties(\n  notcurses++-static PROPERTIES\n  OUTPUT_NAME notcurses++\n)\n\nset_target_properties(\n  notcurses++ PROPERTIES\n  VERSION ${PROJECT_VERSION}\n  SOVERSION ${PROJECT_VERSION_MAJOR}\n  OUTPUT_NAME \"notcurses++\")\n\nset(NCPP_INCLUDE_DIRS\n    \"include\"\n    \"src\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n  )\n\ntarget_include_directories(notcurses++\n  BEFORE\n  PRIVATE ${NCPP_INCLUDE_DIRS}\n  )\n\ntarget_include_directories(notcurses++-static\n  BEFORE\n  PRIVATE ${NCPP_INCLUDE_DIRS}\n  )\n\ntarget_link_libraries(notcurses++\n  PUBLIC\n  notcurses)\n\nset(NCPP_COMPILE_OPTIONS\n  -Wnull-dereference\n  -Wunused\n  -Wno-c99-extensions\n  -fno-strict-aliasing\n  -ffunction-sections\n  -fno-rtti\n  )\n\nset(NCPP_COMPILE_DEFINITIONS_PUBLIC\n  _GNU_SOURCE _DEFAULT_SOURCE\n  )\n\ntarget_compile_options(notcurses++\n  PRIVATE\n  ${NCPP_COMPILE_OPTIONS}\n  -fPIC\n  )\n\ntarget_compile_options(notcurses++-static\n  PRIVATE\n  ${NCPP_COMPILE_OPTIONS}\n  -fPIE\n)\n\ntarget_compile_definitions(notcurses++\n  PUBLIC\n    ${NCPP_COMPILE_DEFINITIONS_PUBLIC}\n)\n\ntarget_compile_definitions(notcurses++-static\n  PUBLIC\n    ${NCPP_COMPILE_DEFINITIONS_PUBLIC}\n)\n\ntarget_compile_options(notcurses++-static\n  PRIVATE\n  ${NCPP_COMPILE_OPTIONS}\n  -fPIE\n)\n\ntarget_compile_definitions(notcurses++\n  PUBLIC\n    ${NCPP_COMPILE_DEFINITIONS_PUBLIC}\n)\n\ntarget_compile_definitions(notcurses++-static\n  PUBLIC\n    ${NCPP_COMPILE_DEFINITIONS_PUBLIC}\n)\nendif() # end USE_CXX block\n\ntarget_compile_options(notcurses-core\n  PRIVATE\n    -fPIC\n)\n\ntarget_compile_options(notcurses-core-static\n  PRIVATE\n    -fPIE\n)\n\ntarget_compile_options(notcurses\n  PRIVATE\n    -fPIC\n)\n\ntarget_compile_options(notcurses-static\n  PRIVATE\n    -fPIE\n)\n\nfile(GLOB NCPP_HEADERS\n  CONFIGURE_DEPENDS\n  LIST_DIRECTORIES false\n  ${PROJECT_SOURCE_DIR}/include/ncpp/*.hh)\n\nfile(GLOB NCPP_INTERNAL_HEADERS\n  CONFIGURE_DEPENDS\n  LIST_DIRECTORIES false\n  ${PROJECT_SOURCE_DIR}/include/ncpp/internal/*.hh)\n\ninstall(FILES ${NCPP_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/ncpp)\ninstall(FILES ${NCPP_INTERNAL_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/ncpp/internal)\n\nexport(PACKAGE notcurses)\n\nfile(GLOB NOTCURSES_HEADERS\n  CONFIGURE_DEPENDS\n  LIST_DIRECTORIES false\n  ${PROJECT_SOURCE_DIR}/include/notcurses/*.h\n  ${CMAKE_CURRENT_BINARY_DIR}/include/version.h)\ninstall(FILES ${NOTCURSES_HEADERS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/notcurses)\n\n# tiny proofs of concept, one binary per source file\nif(USE_POC)\nfile(GLOB POCSRCS CONFIGURE_DEPENDS src/poc/*.c)\nforeach(f ${POCSRCS})\n  get_filename_component(fe \"${f}\" NAME_WE)\n  add_executable(${fe} ${f})\n  target_include_directories(${fe}\n    BEFORE\n    PRIVATE include src \"${TERMINFO_INCLUDE_DIRS}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n  )\n  target_link_libraries(${fe}\n    PRIVATE notcurses \"${TERMINFO_LIBRARIES}\" \"${LIBM}\" \"${LIBRT}\"\n  )\n  target_link_directories(${fe}\n    PRIVATE \"${TERMINFO_LIBRARY_DIRS}\"\n  )\nendforeach()\nif(${USE_CXX})\n  file(GLOB POCPPSRCS CONFIGURE_DEPENDS src/pocpp/*.cpp)\n  foreach(f ${POCPPSRCS})\n    get_filename_component(fe \"${f}\" NAME_WE)\n    add_executable(${fe} ${f})\n    target_include_directories(${fe}\n      BEFORE\n      PRIVATE include src \"${TERMINFO_INCLUDE_DIRS}\"\n      \"${PROJECT_BINARY_DIR}/include\"\n    )\n    target_link_libraries(${fe}\n      PRIVATE notcurses++ \"${TERMINFO_LIBRARIES}\" \"${LIBM}\" \"${LIBRT}\"\n    )\n    target_link_directories(${fe}\n      PRIVATE \"${TERMINFO_LIBRARY_DIRS}\"\n    )\n  endforeach()\nendif()\nendif()\n\n# documentation source, processed by pandoc into XHTML and man pages. declare\n# them here so that we can filter out man pages for binaries which aren't\n# going to be installed.\nfile(GLOB MANSOURCE1 CONFIGURE_DEPENDS doc/man/man1/*.md)\nfile(GLOB MANSOURCE3 CONFIGURE_DEPENDS doc/man/man3/*.md)\n\nif(BUILD_EXECUTABLES)\n############################################################################\n# notcurses-demo\nfile(GLOB DEMOSRCS CONFIGURE_DEPENDS src/demo/*.c)\nadd_executable(notcurses-demo ${DEMOSRCS} ${COMPATSRC})\ntarget_compile_definitions(notcurses-demo\n  PRIVATE\n    _GNU_SOURCE\n)\ntarget_include_directories(notcurses-demo\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${TERMINFO_INCLUDE_DIRS}\"\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n)\ntarget_link_libraries(notcurses-demo\n  PRIVATE\n    notcurses\n    ${LIBM}\n    ${LIBRT}\n    Threads::Threads\n)\n\n############################################################################\n# notcurses-info\nfile(GLOB INFOSRCS CONFIGURE_DEPENDS src/info/*.c)\nadd_executable(notcurses-info ${INFOSRCS} ${COMPATSRC})\ntarget_compile_definitions(notcurses-info\n  PRIVATE\n   _GNU_SOURCE _DEFAULT_SOURCE\n)\ntarget_include_directories(notcurses-info\n  BEFORE\n  PRIVATE\n    src\n    include\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n)\ntarget_link_libraries(notcurses-info\n  PRIVATE\n    notcurses\n    \"${LIBRT}\"\n)\n\n############################################################################\n# notcurses-input\nif(${USE_CXX})\nfile(GLOB INPUTSRCS CONFIGURE_DEPENDS src/input/input.cpp)\nadd_executable(notcurses-input ${INPUTSRCS})\ntarget_include_directories(notcurses-input\n  BEFORE\n  PRIVATE\n    include\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n)\ntarget_link_libraries(notcurses-input\n  PRIVATE\n    notcurses++\n    \"${LIBRT}\"\n)\n\n############################################################################\n# nctetris\nfile(GLOB TETRISSRC CONFIGURE_DEPENDS src/tetris/*.cpp src/compat/*.c)\nadd_executable(nctetris ${TETRISSRC})\ntarget_include_directories(nctetris\n  BEFORE\n  PRIVATE\n    src\n    include\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n)\ntarget_link_libraries(nctetris\n  PRIVATE\n    notcurses++\n    \"${LIBRT}\"\n)\nendif()\n\n############################################################################\n# tfman\nif(NOT WIN32)\nfile(GLOB TFMANSRCS CONFIGURE_DEPENDS src/man/*.c)\nadd_executable(tfman ${TFMANSRCS} ${COMPATSRC})\ntarget_compile_definitions(tfman\n  PRIVATE\n    _GNU_SOURCE\n)\ntarget_include_directories(tfman\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${DEFLATE_INCLUDE_DIRS}\"\n    \"${ZLIB_INCLUDE_DIRS}\"\n)\nif(USE_STATIC_BINARIES)\ntarget_link_libraries(tfman\n  PRIVATE\n    notcurses-core-static\n    \"${DEFLATE_LIBRARIES}\"\n    \"${ZLIB_LIBRARIES}\"\n)\nelse()\ntarget_link_libraries(tfman\n  PRIVATE\n    notcurses-core\n    \"${DEFLATE_LIBRARIES}\"\n    \"${ZLIB_LIBRARIES}\"\n)\nendif()\nendif()\n\n############################################################################\n# ncneofetch\nfile(GLOB FETCHSRCS CONFIGURE_DEPENDS src/fetch/*.c src/compat/*.c)\nadd_executable(ncneofetch ${FETCHSRCS} ${COMPATSRC})\ntarget_include_directories(ncneofetch\n  BEFORE\n  PRIVATE\n    include\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    src\n)\ntarget_link_libraries(ncneofetch\n  PRIVATE\n    notcurses\n    \"${LIBRT}\"\n)\n\n# all further binaries require multimedia and C++ support\nif(${USE_CXX})\nif(${USE_MULTIMEDIA} STREQUAL \"none\")\n  list(FILTER MANSOURCE1 EXCLUDE REGEX \"ncls.1.md\")\n  list(FILTER MANSOURCE1 EXCLUDE REGEX \"ncplayer.1.md\")\nelse()\n############################################################################\n# ncls\nfile(GLOB LSSRC CONFIGURE_DEPENDS src/ls/*.cpp)\nadd_executable(ncls ${LSSRC})\ntarget_include_directories(ncls\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n)\ntarget_link_libraries(ncls\n  PRIVATE\n    notcurses++\n)\n\n############################################################################\n# ncplayer\nfile(GLOB PLAYERSRCS CONFIGURE_DEPENDS src/player/*.cpp)\nadd_executable(ncplayer ${PLAYERSRCS} ${COMPATSRC})\ntarget_include_directories(ncplayer\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n)\ntarget_link_libraries(ncplayer\n  PRIVATE\n    notcurses++\n)\nendif()\nendif()\nelse()\nset(MANSOURCE1 \"\") # no executables were built\nendif() # BUILD_EXECUTABLES\n\n############################################################################\n# testing\nif(${BUILD_TESTING})\nif(${USE_CXX})\n#set(CMAKE_CTEST_ARGUMENTS \"-V\")\nif(${USE_DOCTEST})\nfile(GLOB TESTSRCS CONFIGURE_DEPENDS src/tests/*.cpp src/compat/*.c)\nadd_executable(notcurses-tester ${TESTSRCS})\ntarget_include_directories(notcurses-tester\n  BEFORE\n  PRIVATE\n    include\n    src\n    \"${CMAKE_REQUIRED_INCLUDES}\"\n    \"${PROJECT_BINARY_DIR}/include\"\n    \"${TERMINFO_INCLUDE_DIRS}\"\n)\ntarget_link_libraries(notcurses-tester\n  PRIVATE\n    notcurses++\n    \"${unistring}\"\n    \"${TERMINFO_LIBRARIES}\"\n)\ntarget_link_directories(notcurses-tester\n  PRIVATE\n    \"${TERMINFO_LIBRARY_DIRS}\"\n)\nadd_test(\n  NAME notcurses-tester\n  COMMAND notcurses-tester -p ${CMAKE_CURRENT_SOURCE_DIR}/data --abort-after=1\n)\nset_tests_properties(notcurses-tester PROPERTIES RUN_SERIAL TRUE)\ninstall(TARGETS notcurses-tester DESTINATION bin)\nelse()\n  list(FILTER MANSOURCE1 EXCLUDE REGEX \"notcurses-tester.1.md\")\nendif()\nendif()\nenable_testing()\n# the accursed Ubuntu buildd sets \"TERM=unknown\" for unfathomable reasons\nif(DEFINED ENV{TERM} AND NOT $ENV{TERM} STREQUAL \"unknown\" AND USE_POC)\nadd_test(\n  NAME notcurses-info\n  COMMAND notcurses-info\n)\nif(${USE_CXX})\nadd_test(\n  NAME ncpp_build\n  COMMAND ncpp_build\n)\nadd_test(\n  NAME ncpp_build_exceptions\n  COMMAND ncpp_build_exceptions\n)\n# provide an empty source\nadd_test(\n  NAME input-devnull\n  COMMAND sh -c \"./notcurses-input -v < /dev/null\"\n)\n# provide an ASCII file\nadd_test(\n  NAME input-text\n  COMMAND sh -c \"./notcurses-input < ${CMAKE_SOURCE_DIR}/COPYRIGHT\"\n)\nadd_custom_target(check COMMAND ${CMAKE_CTEST_COMMAND} DEPENDS notcurses-input)\nLIST(APPEND TESTBINS ncpp_build ncpp_build_exceptions input-devnull input-text)\nendif()\nadd_test(\n  NAME sgr-direct\n  COMMAND sgr-direct\n)\nadd_test(\n  NAME sgr-full\n  COMMAND sgr-full\n)\nadd_test(\n  NAME rgb\n  COMMAND rgb\n)\nLIST(APPEND TESTBINS notcurses-info sgr-direct sgr-full rgb)\nif(${USE_CXX})\nadd_test(\n  NAME rgbbg\n  COMMAND rgbbg\n)\nLIST(APPEND TESTBINS rgbbg)\nendif()\nif(${USE_QRCODEGEN})\nadd_test(\n  NAME qrcode\n  COMMAND qrcode\n)\nendif()\nset_tests_properties(\n  ${TESTBINS} PROPERTIES RUN_SERIAL TRUE\n)\nendif()\nelse()\n  list(FILTER MANSOURCE1 EXCLUDE REGEX \"notcurses-tester.1.md\")\nendif()\n\n# Pandoc documentation (man pages, HTML reference)\nif(USE_PANDOC)\n  find_program(PANDOC pandoc)\n  if(NOT PANDOC)\n    message(FATAL_ERROR \"pandoc not found. USE_PANDOC=OFF to disable.\")\n  else()\n    foreach(m ${MANSOURCE3} ${MANSOURCE1})\n      get_filename_component(me ${m} NAME_WLE)\n      add_custom_command(\n        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${me}\n        DEPENDS ${m}\n        COMMAND ${PANDOC}\n        ARGS --to man --standalone --from markdown-smart ${m} > ${CMAKE_CURRENT_BINARY_DIR}/${me}\n        COMMENT \"Building man page ${me}\"\n      )\n      add_custom_target(${me}.man\n        ALL\n        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${me}\n      )\n      file(GLOB ANALHTML doc/analytics-header.html)\n      add_custom_command(\n        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${me}.html\n        DEPENDS ${m} ${ANALHTML}\n        COMMAND ${PANDOC}\n        ARGS -H ${ANALHTML} --to html --standalone --from markdown-smart ${m} > ${CMAKE_CURRENT_BINARY_DIR}/${me}.html\n        COMMENT \"Building HTML5 ${me}.html\"\n      )\n      add_custom_target(${me}.html5\n        ALL\n        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/${me}.html\n      )\n    endforeach()\n    foreach(m ${MANSOURCE3})\n      get_filename_component(me ${m} NAME_WLE)\n      LIST(APPEND MANPAGES3 ${CMAKE_CURRENT_BINARY_DIR}/${me})\n    endforeach()\n    foreach(m ${MANSOURCE1})\n      get_filename_component(me ${m} NAME_WLE)\n      LIST(APPEND MANPAGES1 ${CMAKE_CURRENT_BINARY_DIR}/${me})\n    endforeach()\n  endif()\nendif()\n\n# Doxygen / diagrams\nif(USE_DOXYGEN)\n  find_package(Doxygen REQUIRED dot dia)\n  if(NOT ${DOXYGEN_FOUND})\n    message(FATAL_ERROR \"doxygen not found. USE_DOXYGEN=OFF to disable.\")\n  else()\n    set(DOXYFILE ${CMAKE_CURRENT_SOURCE_DIR}/doc/Doxyfile)\n    # FIXME should dep on all source, i suppose, yuck\n    add_custom_command(\n      OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/html/index.html\"\n      DEPENDS ${DOXYFILE}\n      COMMAND Doxygen::doxygen\n      ARGS ${DOXYFILE}\n      COMMENT \"Running doxygen\"\n    )\n    add_custom_target(doxygen\n      ALL DEPENDS \"${CMAKE_CURRENT_BINARY_DIR}/html/index.html\"\n    )\n    set(MODELDOT ${CMAKE_CURRENT_SOURCE_DIR}/doc/model.dot)\n    add_custom_command(\n      OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/model.png\"\n      DEPENDS ${MODELDOT}\n      COMMAND Doxygen::dot\n      ARGS -Tpng ${MODELDOT} -o \"${CMAKE_CURRENT_BINARY_DIR}/model.png\"\n      COMMENT \"Running dot\"\n    )\n    add_custom_target(dot\n      ALL DEPENDS \"${CMAKE_CURRENT_BINARY_DIR}/model.png\"\n    )\n  endif()\nendif()\n\nadd_custom_target(demo\n  COMMAND ./notcurses-demo -p ${CMAKE_CURRENT_SOURCE_DIR}/data -c\n  DEPENDS notcurses-demo\n)\n\n# pkg-config support\nconfigure_file(tools/notcurses-core.pc.in\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses-core.pc\n  @ONLY\n)\nconfigure_file(tools/notcurses.pc.in\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses.pc\n  @ONLY\n)\n\nif(${BUILD_FFI_LIBRARY})\nconfigure_file(tools/notcurses-ffi.pc.in\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses-ffi.pc\n  @ONLY\n)\nendif()\nif(${USE_CXX})\n   configure_file(tools/notcurses++.pc.in\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses++.pc\n  @ONLY\n)\nendif()\ninclude(CMakePackageConfigHelpers)\nconfigure_file(tools/version.h.in include/version.h)\nconfigure_file(tools/builddef.h.in include/builddef.h)\n\nconfigure_package_config_file(tools/NotcursesConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/NotcursesConfig.cmake\n  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Notcurses\n)\n\nwrite_basic_package_version_file(\n  ${CMAKE_CURRENT_BINARY_DIR}/NotcursesCoreConfigVersion.cmake\n  COMPATIBILITY SameMajorVersion\n)\n\nconfigure_package_config_file(tools/NotcursesCoreConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/NotcursesCoreConfig.cmake\n  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/NotcursesCore\n)\n\nwrite_basic_package_version_file(\n  ${CMAKE_CURRENT_BINARY_DIR}/NotcursesConfigVersion.cmake\n  COMPATIBILITY SameMajorVersion\n)\n\nif(${USE_CXX})\nconfigure_package_config_file(tools/Notcurses++Config.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/Notcurses++Config.cmake\n  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Notcurses++\n)\n\nwrite_basic_package_version_file(\n  ${CMAKE_CURRENT_BINARY_DIR}/Notcurses++ConfigVersion.cmake\n  COMPATIBILITY SameMajorVersion\n)\nendif()\n\n# Installation\ninstall(FILES\n  \"${CMAKE_CURRENT_BINARY_DIR}/NotcursesCoreConfig.cmake\"\n  \"${CMAKE_CURRENT_BINARY_DIR}/NotcursesCoreConfigVersion.cmake\"\n  DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/NotcursesCore\"\n)\n\ninstall(FILES\n  \"${CMAKE_CURRENT_BINARY_DIR}/NotcursesConfig.cmake\"\n  \"${CMAKE_CURRENT_BINARY_DIR}/NotcursesConfigVersion.cmake\"\n  DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/Notcurses\"\n)\n\nif(${USE_CXX})\ninstall(FILES\n  \"${CMAKE_CURRENT_BINARY_DIR}/Notcurses++Config.cmake\"\n  \"${CMAKE_CURRENT_BINARY_DIR}/Notcurses++ConfigVersion.cmake\"\n  DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/Notcurses++\"\n)\nendif()\n\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses-core.pc\n  DESTINATION ${PKGCONFIG_DIR}\n)\n\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses.pc\n  DESTINATION ${PKGCONFIG_DIR}\n)\n\nif(${BUILD_FFI_LIBRARY})\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses-ffi.pc\n  DESTINATION ${PKGCONFIG_DIR}\n)\nendif()\n\nif(${USE_CXX})\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/notcurses++.pc\n  DESTINATION ${PKGCONFIG_DIR}\n)\nendif()\n\nif(NOT ${USE_MULTIMEDIA} STREQUAL \"none\")\nfile(GLOB TESTDATA CONFIGURE_DEPENDS data/*)\n# Don't install source materia for self-originated multimedia\nlist(FILTER TESTDATA EXCLUDE REGEX \".*xcf$\")\nlist(FILTER TESTDATA EXCLUDE REGEX \".*osp$\")\ninstall(FILES ${TESTDATA} DESTINATION ${CMAKE_INSTALL_DATADIR}/notcurses)\nendif()\n\ninstall(FILES ${MANPAGES1} DESTINATION ${CMAKE_INSTALL_DATADIR}/man/man1)\ninstall(FILES ${MANPAGES3} DESTINATION ${CMAKE_INSTALL_DATADIR}/man/man3)\nfile(GLOB MARKDOWN CONFIGURE_DEPENDS *.md)\nlist(FILTER MARKDOWN EXCLUDE REGEX \"INSTALL.md\")\ninstall(FILES ${MARKDOWN} DESTINATION ${CMAKE_INSTALL_DOCDIR})\n\nif(BUILD_EXECUTABLES)\ninstall(TARGETS notcurses-demo DESTINATION bin)\ninstall(TARGETS notcurses-info DESTINATION bin)\ninstall(TARGETS ncneofetch DESTINATION bin)\nif(NOT WIN32)\ninstall(TARGETS tfman DESTINATION bin)\nendif()\nif(${USE_CXX})\ninstall(TARGETS notcurses-input DESTINATION bin)\ninstall(TARGETS nctetris DESTINATION bin)\nif(NOT ${USE_MULTIMEDIA} STREQUAL \"none\")\ninstall(TARGETS ncls DESTINATION bin)\ninstall(TARGETS ncplayer DESTINATION bin)\nendif()\nendif()\nendif() # BUILD_EXECUTABLES\n\nif(${BUILD_FFI_LIBRARY})\nLIST(APPEND INSTLIBS notcurses-ffi)\nendif()\nLIST(APPEND INSTLIBS notcurses-core notcurses)\nif(${USE_STATIC})\nLIST(APPEND INSTLIBS notcurses-core-static notcurses-static)\nendif()\nif(${USE_CXX})\nLIST(APPEND INSTLIBS notcurses++)\nif(${USE_STATIC})\nLIST(APPEND INSTLIBS notcurses++-static)\nendif()\nendif()\n\ninstall(TARGETS ${INSTLIBS}\n  LIBRARY\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    COMPONENT Libraries\n    NAMELINK_COMPONENT Development\n)\n\noption(DUMMY_PYTHON \"Build dummy python module used for compile check and Clangd\" OFF)\nif(${DUMMY_PYTHON})\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nadd_subdirectory(\"./python\")\nendif()\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.521484375,
          "content": "# Contributing to Notcurses\n\nYour quality contributions are cheerfully appreciated, however small. Example\ncode and documentation are especially welcome.\n\nChanges ought reflect the style of the surrounding matter, whether code or\ndocumentation. The styles used in the C core, the C++ wrappers, and the Rust\nwrappers are quite distinct; use the appropriate style for the language.\n\nNew features should have unit tests. It is appreciated if bugfixes have\nunit tests, as well. Wrappers in a new language absolutely must have at\nleast some superficial tests (it is not necessary to deeply test the\nunderlying functionality in each language). Adding a wrapper implies that\nyou're prepared to maintain that wrapper; if you can't maintain it, the wrapper\nwill likely be removed.\n\nEscape sequences available from terminfo must not be hard-coded. Routines must\ncheck to ensure the relevant escape sequence is valid for the current TERM\ndefinition, and not emit it if invalid. Routines emitting characters beyond\nthe 128 elements of ASCII should check for UTF8 availability, and fall back to\nan ASCII equivalent if not present (or return an error).\n\nRun `make test` with your changes, and ensure all tests pass. Run\n`notcurses-demo` as well, if your changes affect the core library (or the\ndemo code).\n\n## C standard\nNotcurses targets the ISO C11 standard. This means you should avoid using\nGNU C extensions as they might not work outside GCC/Clang. To verify your\nstandard compliance on GCC and Clang you can compile with `-std=c11 -pedantic`\ncommand line arguments.\n"
        },
        {
          "name": "COPYRIGHT",
          "type": "blob",
          "size": 1.7880859375,
          "content": "Copyright 2019-2025 Nick Black\nCopyright 2019-2021 Marek Habersack\nCopyright 2020-2021 José Luis Cruz\nCopyright 2020-2021 igo95862\nCopyright 2021 Łukasz Drukała\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nThe contents of src/fetch/ncart.c are extracted from Neofetch,\ncopyright 2015-2025 Dylan Araps under the MIT License:\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in al\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 6.1279296875,
          "content": "# Building and installation\n\nYou are generally recommended to use your distro's package manager to install\nNotcurses; it is [available](https://repology.org/project/notcurses/versions)\nprepackaged on many distributions. If you wish to build from source, read on.\n\n## Prerequisites for building\n\nAcquire the current source via\n\n`git clone https://github.com/dankamongmen/notcurses.git`\n\nThere are no submodules. Dependencies are fairly minimal.\n\n### APT\n\nInstall build dependencies:\n\n`apt-get install build-essential cmake doctest-dev libavdevice-dev libdeflate-dev libgpm-dev libncurses-dev libqrcodegen-dev libswscale-dev libunistring-dev pandoc pkg-config`\n\nIf you only intend to build core Notcurses (without multimedia support), you\ncan omit `libavdevice-dev` from this list. `zlib1g-dev` can be substituted for\n`libdeflate-dev`; build with `-DUSE_DEFLATE=off` in this case. If you don't\nwant to generate QR codes, you can omit 'libqrcodegen-dev'.\n\nIf you want to build the Python wrappers, you'll also need:\n\n`apt-get install python3-cffi python3-dev python3-pypandoc python3-setuptools`\n\n### RPM\n\nInstall build dependencies:\n\n`dnf install cmake doctest-devel libdeflate-devel ncurses-devel gpm-devel libqrcodegen-devel libunistring-devel OpenImageIO-devel pandoc`\n\nIf you only intend to build core Notcurses (without multimedia support), you\ncan omit `OpenImageIO-devel`. If you're building outside Fedora Core (e.g. with\nRPM Fusion), you might want to use FFmpeg rather than OpenImageIO. If you don't\nwant to generate QR codes, you can omit 'libqrcodegen-devel'. `zlib-devel` can\nsubstitute for `libdeflate-devel`; build with `-DUSE_DEFLATE=off` in this case.\n\n### FreeBSD / DragonFly BSD\n\nInstall build dependencies:\n\n`pkg install archivers/libdeflate devel/ncurses multimedia/ffmpeg graphics/qr-code-generator devel/libunistring`\n\nIf you only intend to build core Notcurses (without multimedia support), you\ncan omit `multimedia/ffmpeg`. If you do not want to deflate Kitty graphics,\nyou can omit 'archivers/libdeflate'; build with `-DUSE_DEFLATE=off` in this\ncase. If you don't want to generate QR codes, you can omit\n'graphics/qr-code-generator'.\n\n### Microsoft Windows\n\nBuilding on Windows requires [MSYS2](https://www.msys2.org/) in its\n64-bit Universal C Runtime (UCRT) incarnation. This builds native Windows DLLs\nand EXEs, though it does not use Visual Studio. Install build dependencies:\n\n`pacman -S mingw-w64-ucrt-x86_64-cmake mingw-w64-ucrt-x86_64-libdeflate mingw-w64-ucrt-x86_64-libunistring mingw-w64-ucrt-x86_64-ncurses mingw-w64-ucrt-x86_64-ninja mingw-w64-ucrt-x86_64-openimageio mingw-w64-ucrt-x86_64-toolchain`\n\nNote that on Windows, OpenImageIO is (at the moment) recommended over FFmpeg.\n\nIf you only intend to build core Notcurses (without multimedia support), you\ncan omit `mingw-w64-ucrt-x86_64-openimageio`. If you do not want to deflate Kitty\ngraphics, you can omit 'mingw-w64-ucrt-x86_64-libdeflate'; build with\n`-DUSE_DEFLATE=off` in this case.\n\nYou'll want to add `-DUSE_DOCTEST=off -DUSE_PANDOC=off` to your `cmake` invocation.\n`notcurses-tester` does not currently work on Windows, and you probably don't want\nto build the UNIX-style documentation.\n\n## Building\n\n* Create a subdirectory, traditionally `build` (this is not strictly necessary,\n  but it keeps your source tree clean). Enter the directory.\n* `cmake ..`\n  * You might want to set e.g. `CMAKE_BUILD_TYPE`. Use `-DVAR=val`.\n  * To build without multimedia support, use `-DUSE_MULTIMEDIA=none`.\n* `make`\n* `make test`\n* `make install`\n* `sudo ldconfig`\n\nThe default multimedia engine is FFmpeg. You can select a different engine\nusing `USE_MULTIMEDIA`. Valid values are `ffmpeg`, `oiio` (for OpenImageIO),\nor `none`. Without a multimedia engine, Notcurses will be unable to decode\nimages and videos.\n\nTo get mouse events in the Linux console, you'll need the GPM daemon running,\nand you'll need run `cmake` with `-DUSE_GPM=on`.\n\nRun unit tests with `make test` following a successful build. If you have unit\ntest failures, *please* file a bug including the output of\n\n`./notcurses-tester -p ../data`\n\n(`make test` also runs `notcurses-tester`, but hides important output).\n\nTo watch the bitchin' demo, run `make demo` (or `./notcurses-demo -p ../data`).\nMore details can be found on the `notcurses-demo(1)` man page.\n\nInstall with `make install` following a successful build. This installs the C\ncore library, the C headers, the C++ library, and the C++ headers (note that\nthe C headers are C++-safe). It does not install the Python wrappers. To\ninstall the Python wrappers (after installing the core library), run:\n\n```\ncd cffi\npython setup.py build\npython setup.py install\n```\n\nThe Python wrappers are also available from [PyPi](https://pypi.org/project/notcurses/).\n\n### Build options\n\nTo set the C compiler, export `CC`. To set the C++ compiler, export `CXX`. The\n`CMAKE_BUILD_TYPE` CMake variable can be defined to any of its standard values,\nbut must be `Debug` for use of `USE_COVERAGE`.\n\n* `DFSG_BUILD`: leave out all content considered non-free under the Debian Free Software Guidelines (default `off`)\n* `BUILD_TESTING`: build test targets (default `on`)\n* `BUILD_EXECUTABLES`: build executables (in addition to libs) (default `on`)\n* `BUILD_FFI_LIBRARY`: Build ffi library (containing all symbols which are static inline) (default `on`)\n* `USE_ASAN`: build with AddressSanitizer (default `off`)\n* `USE_CXX`: build C++ code (requires a C++ compiler) (default `on`)\n* `USE_COVERAGE`: build coverage support (for developers, requires use of Clang) (default `off`)\n* `USE_DOCTEST`: build `notcurses-tester` with Doctest, requires `BUILD_TESTING` and `USE_CXX` (default `on`)\n* `USE_DOXYGEN`: build interlinked HTML documentation with Doxygen (default `off`)\n* `USE_GPM`: build GPM console mouse support via libgpm (default `off`)\n* `USE_MULTIMEDIA`: `ffmpeg` for FFmpeg, `oiio` for OpenImageIO, `none` for none (default `ffmpeg`)\n  * `oiio` cannot be used with `USE_CXX=off`\n* `USE_PANDOC`: build man pages with pandoc (default `on`)\n* `USE_POC`: build small, uninstalled proof-of-concept binaries (default `on`)\n* `USE_QRCODEGEN`: build qrcode support via libqrcodegen (default `off`)\n* `USE_STATIC`: build static libraries (in addition to shared ones) (default `on`)\n"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 72.8701171875,
          "content": "This document attempts to list user-visible changes and any major internal\nrearrangements of Notcurses.\n\n* 3.0.13 (2025-01-11)\n  * Fix regression when building with `USE_CXX=off`.\n  * Use `distutils` from its own Python component rather than assuming\n    it's in `setuputils`, from which it was removed in Python 3.12.\n  * Properly check for UTF8 before calling ncmetric_use_utf8(), fixing\n    a bug when using ncmetric without UTF8 support.\n\n* 3.0.12 (2025-01-09)\n  * Fixed a bug when rendering QR codes into a small area. QR codes now\n    require `NCBLIT_2x1`, as that is the only blitter which can generate a\n    proper aspect ratio. It thus no longer works in an ASCII environment.\n  * The `NCBLIT_4x2` \"octant\" blitter has been added, making use of new\n    characters from Unicode 16. `notcurses_canoctant()` has been added to\n    check for `NCBLIT_4x2` support at runtime. If present, octants will be\n    used for `NCBLIT_DEFAULT` when used with `NCSCALE_NONE_HIRES`,\n    `NCSCALE_SCALE_HIRES`, or `NCSCALE_STRETCH`. Thanks, eschnett! Note\n    that octants are not supported by GNU libc until 2.41.\n  * Fixed coredump on exit when using musl as libc (alpine, some gentoo).\n\n* 3.0.11 (2024-10-02)\n  * We now normalize the return of `nl_langinfo()` according to the behavior\n    of glibc's `_nl_normalize_charset()`, supporting some atypical synonyms\n    of `UTF-8`.\n  * Fixed a bug in `ncsixel_as_rgba()` (called by `ncvisual_from_sixel()`)\n    that broke loading of sixels having more than 12 rows (sixel generation\n    from images worked fine). Thanks, waveplate!\n  * Reject illegal geometries in `ncvisual_from_*()`.\n  * We build with FFMPEG 7.1.\n\n* 3.0.10 (2024-10-02)\n  * Cursed. See https://github.com/dankamongmen/notcurses/issues/2795.\n\n* 3.0.9 (2022-12-10)\n  * Eliminated infinite loop in `ncplane_move_family_above()`.\n    Thanks, drewt!\n\n* 3.0.8 (2022-04-06)\n  * Bugfix release, but also support curled underlines in Contour.\n\n* 3.0.7 (2022-02-20)\n  * Tab characters may now be used with `ncplane_put*()`. See\n     `ncplane_output.3` for more information.\n\n* 3.0.6 (2022-02-09)\n  * `ncplane_set_[fb]channel()`, `ncplane_[fb]channel()`,\n    `ncplane_channels()`, `ncplane_set_channels()`,\n    `ncchannels_set_[fb]channel()`, and `ncchannels_[fb]channel()` now\n    function only on the 28 alpha + coloring bits of their respective\n    channels, which is almost certainly what you wanted in the first place.\n  * Restore `nccell_set_[fb]channel()` and friends, using these semantics.\n\n* 3.0.5 (2022-01-21)\n  * The Hyper and Super modifiers are now supported. CapsLock and NumLock\n    can further be disambiguated when using the Kitty protocol. The\n    new functions `ncinput_super_p()` and friends have been added.\n  * `ncinput` has a new field, `modifiers`. The old `alt`, `shift`, and\n    `ctrl` booleans are now deprecated, and will be removed in 4.0.\n  * `ncmenu_section` **must** now specify any expected modifiers for their\n    shortucts using `modifiers`. Setting any of `alt`, `shift`, or\n    `ctrl` will see `ncmenu_create()` fail.\n  * `ncinput_equal_p()` considers `NCTYPE_UNKNOWN` equal to `NCTYPE_PRESS`.\n  * Added `ncpalette_get()` for orthogonality's sake.\n\n* 3.0.4 (2022-01-08)\n  * We now use level 2 of `XTMODKEYS`, providing better differentiation\n    of keyboard modifiers. We now unpack the Meta modifier.\n  * Added `ncinput_shift_p()`, `ncinput_alt_p()`, `ncinput_ctrl_p()`,\n    and `ncinput_meta_p()` to test for various modifiers in `ncinput`s.\n  * When support is advertised, the 1016 mouse protocol will be used\n    to provide pixel-level detail. See the `{yx}px` fields of `ncinput`.\n\n* 3.0.3 (2022-01-02)\n  * No user-visible changes to the API, but Sixel quantization has been\n    rewritten. It is now substantially faster, though quality has gone\n    down for some images. I'll be working on bringing it back for 3.0.4.\n\n* 3.0.2 (2021-12-21)\n  * Added `ncplane_cursor_y()` and `ncplane_cursor_x()`.\n  * Added `NCOPTION_SCROLLING`, equivalent to calling\n    `ncplane_set_scrolling(true)` on the standard plane.\n  * Added `NCOPTION_CLI_MODE`, an alias for the bitwise OR of\n    `NCOPTION_SCROLLING`, `NCOPTION_NO_CLEAR_BITMAPS`,\n    `NCOPTION_NO_ALTERNATE_SCREEN`, and `NCOPTION_PRESERVE_CURSOR`.\n  * Added `ncvisual_from_sixel()`.\n  * The control sequence corresponding to a pixel-blitted `ncvisual()`\n    can be retrieved by using `ncplane_at_yx()` on the sprixel plane.\n\n* 3.0.1 (2021-12-14)\n  * Added the `NCPLANE_OPTION_VSCROLL` flag. Creating an `ncplane` with this\n    flag is equivalent to immediately calling `ncplane_set_scrolling(true)`.\n  * Added the `NCPLANE_OPTION_AUTOGROW` flag and the `ncplane_set_autogrow()`\n    and `ncplane_autogrow_p()` functions. When autogrow is enabled, the plane\n    is automatically enlarged to accommodate output at its right (no scrolling)\n    or bottom (scrolling enabled) boundaries.\n  * Added `notcurses_default_background()` and `notcurses_default_foreground()`.\n  * Added `nccell_load_ucs32()`.\n  * Added `nctree_add()` and `nctree_del()`. `nctree` is now dynamic.\n\n* 3.0.0 (2021-12-01) **\"In the A\"**\n  * Made the ABI/API changes that have been planned/collected during 2.x\n    development. This primarily involved removing deprecated functions,\n    and making some `static inline` (and thus no longer linkable symbols).\n    There have been a few small renamings (i.e. `ncplane_pixelgeom()` to\n    `ncplane_pixel_geom()`) for purposes of regularity. The only thing removed\n    without an obvious replacement is the `renderfp` field of\n    `notcurses_options`, for which I make no apology. If you've been avoiding\n    deprecated functionality, ABI3 ought require small changes, if any.\n  * `notcurses_get()` and `ncdirect_get()` now require an absolute deadline\n    rather than a delay bound; it ought be calculated using `CLOCK_MONOTONIC`.\n  * The handling of geometry and distance has been normalized across all\n    functions. Lengths are now `unsigned` as opposed to `int`. Where -1 was\n    being used to indicate \"everything\", 0 is now required. This affects\n    `ncplane_as_rgba()`, `ncplane_contents()`, and `ncvisual_from_plane()`,\n    which all used -1. A length of zero passed to line-drawing functions is\n    now an error. Several line-drawing functions now reliably return errors\n    as opposed to short successes. Dimensions of 0 to `ncplane_mergedown()`\n    now mean \"everything\". Almost all coordinates now accept -1 to indicate the\n    current cursor position in that dimension. `ncplane_highgradient()` has\n    been deprecated in favor of the new `ncplane_gradient2x1()`, which takes\n    origin coordinates. `ncplane_format()` and `ncplane_stain()` now take\n    origin coordinates. All now interpret their `unsigned` argument as\n    lengths rather than closing coordinates, observing the same semantics as\n    outlined above.\n  * `ncstrwidth_valid()`, introduced in 2.4.1, has replaced `ncstrwidth()`\n    entirely, and been renamed to reflect this. For the old behavior,\n    simply add two `NULL`s to your `ncstrwidth()` invocations.\n  * `ncplayer` now defaults to pixel blitting.\n  * `NCKEY_SIGNAL` is no longer a synonym for `NCKEY_RESIZE`, but instead\n    indicates receipt of `SIGCONT`.\n  * `CELL_TRIVIAL_INITIALIZER`, `CELL_CHAR_INITIALIZER`, and\n    `CELL_INITIALIZER` are all now prefixed with `NC`.\n  * A new resize callback, `ncplane_resize_placewithin()`, has been added.\n  * The `ncinput` struct has a new field, `utf8`. `notcurses_get()` will fill\n    in this array of `char` with the NUL-terminated UTF-8 representation of\n    the input whenever one exists.\n\n* 2.4.9 (2021-11-11)\n  * Added `ncnmetric()`, which uses `snprintf()` internally. `ncmetric()`\n    was reimplemented as a trivial wrapper around `ncnmetric()`.\n  * `qprefix()`, `bprefix()`, and `iprefix()` have been renamed\n    `ncqprefix()`, `ncbprefix()`, and `nciprefix()`, respectively.\n    All related constants have been prefixed with `NC`, and the old\n    definitions will be removed for abi3.\n  * `notcurses_mice_enable()` and `notcurses_mouse_disable()` replace\n    `notcurses_mouse_enable()` and `notcurses_mouse_disable()`, which\n    have been deprecated, and will be removed in ABI3.\n    `notcurses_mice_enable()` takes an additional `unsigned eventmask`\n    parameter, a bitmask union over `NCMICE_*_EVENT` (`NCMICE_ALL_EVENTS`\n    is provided for convenience and future-proofing).\n    `notcurses_mice_disable()` is now a `static inline` wrapper around the\n    former, passing 0 as the event mask. This can be used to get mouse\n    movement buttons and focus events, which were previously unavailable.\n  * `ncvisual_geom()` has been introduced, using the `ncvgeom` struct\n    introduced for direct mode. This allows complete statement of geometry\n    for an `ncvisual`. It replaces `ncvisual_blitter_geom()`, which has been\n    deprecated, and will be removed in ABI3. It furthermore exposes some of\n    the information previously available only from `ncplane_pixelgeom()`,\n    though that function continues to be supported.\n  * `ncvgeom`'s `rcelly` and `rcellx` fields are now (finally) filled in\n    by `ncvisual_geom()` (and thus `ncdirectf_geom()`), and suitable for use.\n  * On transition between `ncplane`s (on terminals implementing complex wide\n    glyphs), Notcurses now always issues an `hpa` sequence to force horizontal\n    positioning. This fixes a number of longstanding bugs in e.g. the\n    `[uniblock]` and `[whiteout]` demos at the cost of some extra control\n    sequences. For more information, see\n    [issue 2199](https://github.com/dankamongmen/notcurses/issues/2199). The\n    number of `hpa`s issued in this manner is tracked in a new stat,\n    `hpa_gratuitous`.\n\n* 2.4.8 (2021-10-23)\n  * Added new functions `notcurses_canpixel()` and `notcurses_osversion()`.\n  * `notcurses_get()` now evaluates its timeout against `CLOCK_MONOTONIC`\n    instead of `CLOCK_REALTIME`.\n  * `SIGBUS` is now included among the signals for which a handler is\n    by default installed.\n\n* 2.4.7 (2021-10-16)\n  * Features 1, 2, and 8 of the Kitty keyboard protocol are now supported. This\n    provides much more detailed and fine-grained keyboard reports, including\n    key repeat and release events, and modifier events (i.e. pressing Shift by\n    itself now generates an event; it is not required to press another key\n    along with the modifier). Only Kitty supports this protocol at this time.\n  * `XTMODKEYS` is now used where supported. This is essentially a subset of\n    the Kitty protocol discussed above.\n  * In the absence of any `XTSMGRAPHICS` replies, advertising feature 4 in a\n    DA1 response will be considered as claiming support for Sixel with 256\n    color registers. If you're a terminal author, please do `XTSMGRAPHICS`.\n    Actually, please implement the vastly superior Kitty graphics protocol.\n  * `ncvisualplane_create()` now allows for a new pile to be created, by\n    passing a `NULL` ancestor `ncplane` in `vopts`. The first argument is\n    now a `struct notcurses*` rather than a `struct ncplane*`.\n  * `ncvisual_render()` has been deprecated in favor of the new function\n    `ncvisual_blit()`. When a `NULL` `vopts->n` is passed to `ncvisual_blit()`,\n    a new plane is created (as it was in `ncvisual_render()`), but that plane\n    is the root of a new pile, rather than a child of the standard plane.\n    The only tricky conversion is if you previously had `vopts.n` as `NULL`,\n    and were not using `NCVISUAL_OPTION_CHILDPLANE` (or were passing `NULL`\n    as `vopts`). This would result in a new plane bound to the standard plane\n    with `ncvisual_render()`, but with `ncvisual_blit()` it will create a new\n    pile. To keep the behavior, explicitly pass the standard plane as\n    `vopts->n`, and include `NCVISUAL_OPTION_CHILDPLANE` in `vopts->flags`.\n    All other cases will continue to work as they did before.\n\n* 2.4.5 (2021-10-06)\n  * The poorly-considered function `ncplane_boundlist()`, added in 2.3.17, has\n    been removed, having never ought have been born.\n  * Added functions `ncplane_move_family_top()`, `ncplane_move_family_bottom()`,\n    `ncplane_move_family_above()`, and `ncplane_move_family_below()`.\n  * Added functions `ncplane_set_name()` and `ncplane_name()`.\n\n* 2.4.4 (2021-10-03)\n  * Notcurses no longer uses libreadline, as it was realized to be incompatible\n    with the new input system. `ncdirect_readline()` has been rewritten to\n    work without libreadline, which means it's now always available (readline\n    was an optional dependency). `NCDIRECT_OPTION_INHIBIT_CBREAK` should *not*\n    be used with `ncdirect_readline()`, or else it can't implement line-editing\n    keybindings.\n  * Helper function `ncwcsrtombs()` is now available for converting a\n    `wchar_t *` to a heap-allocated UTF-8 `char *`.\n  * Building without a C++ compiler is now supported using `-DUSE_CPP=off`. See\n    the FAQs for restrictions.\n\n* 2.4.3 (2021-09-26)\n  * `ncplane_erase_region()` has been made much more general, and can now\n    operate relative to the current cursor.\n  * Several terminal emulators have recently changed their semantics regarding\n    DECSDM. These changes correctly match the real VT340 behavior.\n    Unfortunately, this means we always draw Sixels in the upper left corner of\n    the screen. Code has been added to deal with XTerm 369, the ayosec/graphics\n    branch of Alacritty 15.1, foot 1.8.2, and MinTTY 3.5.2.\n\n* 2.4.2 (2021-09-19)\n  * The Rust wrappers have been moved to\n     [dankamongmen/libnotcurses-sys](https://github.com/dankamongmen/libnotcurses-sys),\n     under the continued stewardship of @joseluis.\n  * You can now set a resize callback on the standard plane.\n  * Added `notcurses_getvec()`, providing batched input.\n  * Added `NCOPTION_DRAIN_INPUT`. Notcurses now launches a thread to process\n    input, so that it can respond to terminal messages with minimal latency.\n    Input read from `stdin` intended for the client is buffered until\n    retrieved. If your client never intends to read this input, provide this\n    flag to eliminate unnecessary processing, and ensure Notcurses can always\n    retrieve terminal messages (if buffers are full, Notcurses cannot\n    continue reading). Likewise added `NCDIRECT_OPTION_DRAIN_INPUT`.\n  * Removed a bunch of deprecated `static inline` functions from the headers.\n  * A new field, `evtype`, has been added to `ncinput`. It takes a value\n    from among `NCTYPE_{UNKNOWN, PRESS, REPEAT, RELEASE}.`. Where possible,\n    Notcurses will distinguish between a press, repeat, and release. This\n    cannot be done in all environments, nor with all inputs. The\n    `NCKEY_RELEASE` definition is no longer returned; instead, the\n    appropriate `NCKEY_BUTTONx` synthesized key is returned, with\n    `EVTYPE_RELEASE` set.\n  * `NCKEY_EOF` now indicates the end of input.\n\n* 2.4.1 (2021-09-12)\n  * `notcurses_check_pixel_support()` still returns 0 if there is no support\n    for bitmap graphics, but now returns an `ncpixelimple_e` to differentiate\n    the pixel backend otherwise. This result is strictly informative.\n  * Added `ncstrwidth_valid()`, which is like `ncstrwidth()` except that it\n    returns partial results in the case of an invalid character. `ncstrwidth()`\n    will become a `static line` wrapper of `ncstrwidth_valid()` in ABI3.\n\n* 2.4.0 (2021-09-06)\n  * Mouse events in the Linux console are now reported from GPM when built\n    with `-DUSE_GPM=on`.\n\n* 2.3.18 (2021-08-31)\n  * No user-visible changes.\n\n* 2.3.17 (2021-08-22)\n  * Added `notcurses_enter_alternate_screen()` and\n    `notcurses_leave_alternate_screen()`.\n  * Added `ncplane_boundlist()`.\n  * Plots now support `NCBLIT_PIXEL`!\n\n* 2.3.16 (2021-08-19)\n  * Fix `ncdirect_set_*_rgb()` for the case where an emulator has fewer than\n    8 colors, i.e. vt100. This release exists to make unit tests work again\n    on the Alpine and Fedora buildservers.\n\n* 2.3.15 (2021-08-17)\n  * `ncneofetch` has been changed to use \"CLI mode\" instead of Direct Mode,\n    as a proof of concept. It is very likely that Direct Mode will be\n    deprecated for ABI3. New code ought not be written using it.\n  * Added `ncplane_scrollup()` and `ncplane_scrollup_child()`.\n  * Fixed grotesque errors in `ncplane_set_*_palindex()`.\n  * Removed support for the iTerm2 graphics protocol, which is unsuitable for\n    the Notcurses model. macOS users who want graphics are recommended to use\n    Kitty or WezTerm. It will be added back if it gains necessary capabilities.\n\n* 2.3.13 (2021-08-04)\n  * Added the portable utility functions `notcurses_accountname()` and\n    `notcurses_hostname()`.\n\n* 2.3.12 (2021-07-29)\n  * `notcurses_getc()` and `ncdirect_getc()` no longer accept a `sigset_t*`\n    as their third argument. Instead, they accept a `void*`, with which\n    they will do nothing. This is due to POSIX signals being unportable in\n    addition to terrible, and this one wart complicating wrappers a great\n    deal. If you were using this functionality, you were probably using it\n    incorrectly, no offense. If you're certain you were doing it right,\n    roll your own with `pthread_sigmask()`, and accept the race condition.\n    For ABI3, these functions will be dropped entirely; for now they have\n    only been marked deprecated. New functions `ncdirect_get()` and\n    `notcurses_get()` elide this parameter entirely, and ought be used in\n    new code. All callers have been updated.\n  * Added `nccell_cols()`, which is just `nccell_width()` except it doesn't\n    require the first `const ncplane*` argument, and it's `static inline`.\n    `nccell_width()` has been deprecated, and will be removed in ABI3.\n  * `ncvisual_subtitle_plane()` now handles all LibAV subtitle types,\n    including Type-1 DVB (bitmap subtitles), so long as a pixel blitter is\n    available. `ncvisual_subtitle()` has been deprecated, and will be\n    removed in ABI3.\n  * Add `ncvisual_from_palidx()`, which does what you would think.\n\n* 2.3.11 (2021-07-20)\n  * Notcurses now requires libz to build. In exchange, it can now generate\n    PNGs on the fly, necessary for driving iTerm2's graphics protocol.\n  * Experimental code has been added to draw graphics using both the iTerm2\n    protocol and directly to the Linux console framebuffer. This functionality\n    is still quite raw, but can be played with.\n  * Added `NCPLANE_OPTION_FIXED`, to prevent a plane bound to a scrolling\n    plane from scrolling along with it. Otherwise, bound planes will scroll\n    along with the parent plane so long as the planes intersect.\n  * Added `input_errors` and `input_events` stats.\n  * `NCALPHA_HIGHCONTRAST` now works properly atop default backgrounds.\n  * `SIGFPE` is now included among the fatal signals for which handlers are\n    by default installed. Unsure how I overlooked it this long.\n\n* 2.3.10 (2021-07-14)\n  * Notcurses now builds and works, so far as I can tell, on OS X 11.4+.\n  * Emit XTPUSHCOLORS and XTPOPCOLORS where supported (XTerm and Kitty).\n  * `notcurses-info` now works around Unicode unsupported by the local\n    platform, so that other output remains available.\n\n* 2.3.9 (2021-07-12)\n  * Fixed major regressions from 2.3.8: menu highlighting is working once\n    more, as are pointer inputs (mice) and the 8x1 plotter. Sorry about that!\n  * `notcurses_detected_terminal()` and `ncdirect_detected_terminal()` now\n    both return a heap-allocated string, which will contain the terminal\n    version if Notcurses was able to detect it. This result ought be free()d.\n  * Added `ncplane_move_rel()`.\n  * Documented `ncplane_move_yx()` in `notcurses_plane.3`, and removed the\n    false comment that \"passing -1 as a coordinate will hold that axis\n    constant\" from `USAGE.md` and `notcurses.h`. This has never been true.\n  * Added `ncdirect_putegc()` to perform Unicode segmentation. It returns\n    the number of columns consumed, and makes available the number of bytes\n    used by the EGC.\n  * `ncmenu`s can now be used with any plane, not just the standard plane.\n  * Added `ncchannels_reverse()`, which reverses the color aspects of the\n    two channels, while keeping other elements constant.\n  * `CHANNELS_RGB_INITIALIZER` and `CHANNEL_RGB_INITIALIZER` have been renamed\n    `NCCHANNELS_INITIALIZER` and `NCCHANNEL_INITIALIZER`. The former two are\n    now deprecated, and will be removed for ABI3.\n\n* 2.3.8 (2021-07-04)\n  * Marked all capability functions `__attribute__ ((pure))`. If you were\n    calling `notcurses_check_pixel_support()` before in order to enable pixel\n    blitting (unnecessary since 2.3.5), you might get compiler warnings about\n    statements without effects. Just remove the call if so.\n  * Fixed bugs in `ncvisual_blitset_geom()` and `ncvisual_render()` when using\n    `NCVISUAL_OPTION_CHILDPLANE` in certain configurations.\n  * Fixed some serious bugs in the OpenImageIO backend.\n  * Disabled Synchronized Update Mode for Kitty in response to upstream bugs.\n\n* 2.3.7 (2021-06-29)\n  * Deprecated `NCSTYLE_REVERSE` and `NCSTYLE_DIM`. The remainder are safe,\n    and I added back `NCSTYLE_BLINK` according to popular demand.\n  * Added `NCOPTION_PRESERVE_CURSOR`. If used, the standard plane's virtual\n    cursor will be initialized to match its position at startup, rather than\n    starting in the upper-left corner. Together with a scrolling standard\n    plane and inhibition of the alternate screen, this allows rendered mode\n    to easily be used for scrolling shell environment programs.\n  * Control characters from C0 and C1 are now rejected when loading `nccell`s\n    or writing to a plane (except for newline, when using a scrolling plane).\n    This was always intended, but never enforced. Horizontal tabs might be\n    enabled anew sometime in the future.\n  * `ncls` now defaults to `NCBLIT_PIXEL`.\n  * Added `ncplane_scrolling_p()` to retrieve a plane's scrolling status.\n  * Greatly expanded `notcurses-info`.\n\n* 2.3.6 (2021-06-23)\n  * Fixed (harmless) warning with `-Wformat-security`.\n  * Remove `NCSTYLE_{INVIS,BLINK,STANDOUT}` with extreme prejudice. They\n    remain defined for now, but will be removed for ABI3.\n  * Deprecated `notcurses_debug_caps()`, which no longer generates output.\n    Hey, I explicitly commented that its output was \"subject to change\".\n\n* 2.3.5 (2021-06-23)\n  * Happy day! The terminal interrogation routines in the initialization code \n    have been completely revamped. The first outcome of this is that Sixel\n    parameters are now opportunistically read at startup, and thus there is\n    no longer any need to call `notcurses_check_pixel_support()` before\n    using `NCBLIT_PIXEL`. If it's there, it'll be used; if not, it'll degrade\n    or fail. The new routines rely on the terminal answering the Send Device\n    Attributes escape; if it does not, Notcurses may refuse to start, or even\n    hang. Please report a bug if you run into this.\n    It is still necessary to supply a correct `TERM` environment variable,\n    because this is used to index into the `terminfo(5)` database, which\n    seeds most common escapes. The extended capabilities of some modern\n    terminals, however, will be retrieved independently of `TERM`; they'll\n    be made available for use if supported by the connected terminal, and\n    others will not, even if your `TERM` variable implies they ought.\n  * `ncplane_as_rgba()`/`ncvisual_from_plane()` now support `NCBLIT_BRAILLE`.\n  * `CELL_ALPHA_*` macros are now `NCALPHA_*`. The former will remain\n    `#define`d until ABI3.\n  * Filled out the complete set of `ncdirect_can*()` capability functions,\n    which now match the `notcurses_can*()` API. Added\n    `ncdirect_canget_cursor()` to check if the cursor can be located.\n  * `ncdirect_dim_y()` and `ncdirect_dim_x()` no longer accept a\n    `const ncdirect*`, since they update the term parameters. Sorry!\n  * Added `NCDIRECT_OPTION_VERBOSE` and `NCDIRECT_OPTION_VERY_VERBOSE`.\n    They map to `NCLOGLEVEL_WARNING` and `NCLOGLEVEL_TRACE`, respectively.\n  * New functions `ncvisual_from_rgb_packed()` and `ncvisual_from_rgb_loose()`.\n  * New stat `sprixelbytes`.\n  * Added new functions `ncpile_render_to_buffer()` and\n    `ncpile_render_to_file()`. Rewrote `notcurses_render_to_buffer()` and\n    `notcurses_render_to_file()` as trivial wrappers around these functions,\n    and deprecated the latter. They will be removed in ABI3.\n  * Added support for application-synchronized updates, and a new stat.\n\n* 2.3.4 (2021-06-12)\n  * Added the flag `NCVISUAL_OPTION_NOINTERPOLATE` to use non-interpolative\n    scaling in `ncvisual_render()`. `ncvisual_render()` without a multimedia\n    engine will now use this method for any requested scaling (previously,\n    scaling was not performed without a linked multimedia backend).\n  * `NCVISUAL_OPTION_BLEND` used with `NCBLIT_PIXEL` will now, when the Kitty\n    graphics protocol is in use, cut the alpha of each pixel in half.\n  * `ncvisual_inflate()` has been rewritten as a wrapper around the new\n    function `ncvisual_resize_noninterpolative()`, and deprecated. It will be\n    removed for ABI3. Godspeed, `ncvisual_inflate()`; we hardly knew ye.\n  * `ncdirectf_render()` has been changed to accept a `ncvisual_options`,\n    replacing and extending its four final arguments. Sorry about the breakage\n    here, but `ncdirectf_render()` was introduced pretty recently (2.3.1).\n    As a result, `ncdirectf_render()` and `ncdirect_stream()` now honor\n    `NCVISUAL_OPTION_BLEND` and `NCVISUAL_OPTION_NOINTERPOLATE`. All of this\n    also applies to `ncdirect_geomf()`.\n  * `ncplayer` now accepts `-n` to force non-interpolative scaling.\n  * A new binary is installed, `notcurses-info`. It prints information about\n    the terminal environment in which it runs. More information is available\n    from its man page, `notcurses-info(1)`.\n  * Added `ncdirect_light_box()`, `ncdirect_heavy_box()`,\n    `ncdirect_ascii_box()`, `nccells_light_box()`, and `nccells_heavy_box()`.\n    Publicized `nccells_ascii_box()`. All are `static inline`.\n  * A bug was fixed in `ncplane_move_yx()`: root planes were being moved\n    relatively instead of absolutely. This was never the intended behavior.\n  * It used to be possible to pass `NULL` as the second parameter of\n    `ncplane_mergedown_simple()`, and have the standard plane be used as\n    the destination. This is no longer supported, since the source plane\n    could be in another pile. An error will instead be returned.\n  * Fixed a bug in `ncdirect_box()` where default/palette-indexed colors\n    weren't properly used on the top and bottom borders.\n  * Added `notcurses_detected_terminal()` and `ncdirect_detected_terminal()`.\n\n* 2.3.2 (2021-06-03)\n  * Fixed a bug affecting certain scalings of `ncvisual` objects created from\n    memory (e.g. `ncvisual_from_rgba()`).\n  * Fixed a bug where setting a style in direct mode reset color. Shocked that\n    such a bug could exist for so long, ugh.\n  * Fixed memory leaks in the `ffmpeg` and `none` implementations of the\n    `ncvisual` API, and also the `libnotcurses-core` implementation.\n  * `ncinput_nomod_p()` has been added. This function returns `true` if and\n    only if its `ncinput` argument has no modifiers active.\n  * Added `notcurses_cursor_yx()` to get the current location of the cursor.\n  * Added `ncdirect_supported_styles()`.\n  * `ncplane_at_yx()` now properly integrates the plane's base cell when\n    appropriate, and thus represents the cell as it will be used during\n    rendering. This change cascades, affecting e.g. `ncplane_contents()`.\n  * `ncplane_at_yx()` now returns the EGC when called on any column of a\n    wide glyph. `ncplane_at_yx_cell()` continues to duplicate the exact\n    `nccell`, and can thus continue to be used to distinguish between primary\n    and secondary columns of a wide glyph. Likewise, `notcurses_at_yx()`\n    now returns the EGC when called on any column of a wide glyph.\n  * Sadly, `ncplane_contents()` no longer accepts a `const ncplane*`, since it\n    might write temporaries to the plane's EGCpool during operation.\n  * Added `ncdirect_styles()`, to retrieve the current styling.\n  * In previous versions of Notcurses, a rendered-mode context\n    (`struct notcurses`) and a direct-mode context (`struct ncdirect`) could\n    be open at the same time. This was never intended, and is no longer\n    possible.\n\n* 2.3.1 (2021-05-18)\n  * Sprixels no longer interact with their associated plane's framebuffer. This\n    means plane contents are maintainted across blitting a sprixel and then\n    independently destroying that sprixel (i.e. without destroying the plane).\n    While the sprixel is bound to the plane, these contents are ignored (save\n    that they will be reported by `ncplane_at_yx()`). Since no method currently\n    exists to destroy a sprixel without destroying its plane, I don't think\n    this will impact anyone.\n  * 8bpc RGB is unconditionally enabled if the terminal emulator is determined\n    to be Kitty, Alacritty, or foot; there is no longer any need to export\n    `COLORTERM` on these terminals.\n  * Fixed bad bug in `ncvisual_resize()` when growing an image. This isn't\n    relevant to enlarging an `ncvisual` via scaling, but only when persistently\n    growing one with `ncvisual_resize()`.\n  * Direct mode image rendering now honors the `maxy` and `maxx` parameters,\n    which specify the maximum number of cell rows and columns, respectively,\n    to use for the render. They were previously ignored, contrary to\n    documentation. It is now an error to pass a negative number for either of\n    these values. Use 0 to specify \"as much space as is necessary\".\n  * Added `ncdirectf_from_file()`, `ncdirectf_geom()`, and `ncdirectf_render()`,\n    with the net result that you can now (efficiently) get media geometry in\n    direct mode. If you don't care about media geometry, you can keep using\n    `ncdirect_render_frame()` and/or `ncdirect_render_image()`, and Godspeed.\n    Oh yes, and `ncdirectf_free()`. Rien n'est simple, mais tout est facile....\n\n* 2.3.0 (2021-05-09) **\"Triumph\"**\n  * No user-visible changes.\n\n* 2.2.11 (2021-05-08)\n  * `notcurses-core.pc` is now generated with a `Requires.private` line\n    matching the local system's source of Terminfo. This ought resolve\n    static linking on systems with libtinfo embedded into libncurses.\n  * Added `ncblit_rgb_loose()` and `ncblit_rgb_packed()` helpers for blitting\n    32bpp RGBx and 24bpp RGB.\n  * Added `ncplane_erase_region()` to initialize all `nccell`s within a\n    region of a plane.\n\n* 2.2.10 (2021-05-05)\n  * Added `NCVISUAL_OPTION_CHILDPLANE` to interpret the `n` field of\n    `ncvisual_options` as a parent plane.\n  * Reimplemented `ncdirect_cursor_down()` using vertical tabs instead\n    of the `cud` capability, so that it now scrolls when on the last line.\n    Thanks to Daniel Eklöf for this idea, of which I was totally ignorant!\n  * Fixed several embarrassing `assert()`s which I'd not had exposed due\n    to misuse of CMake.\n  * Fixed a state machine bug that caused sprixels to sometimes not be\n    properly redisplayed following a rebuild.\n\n* 2.2.9 (2021-05-03)\n  * Added two new stats, `sprixelemissions` and `sprixelelisions`.\n  * Added `notcurses_canhalfblock()` and `notcurses_canquadrant()`.\n  * The `palette256` type has been renamed `ncpalette`, and all functions\n    prefixed with `palette256_` have been deprecated in favor of versions\n    prefixed with `ncpalette_`, which the former now wrap. The old versions\n    will be removed in ABI3.\n  * All functions prefixed with `channel_` have been deprecated in favor of\n    versions prefixed with `ncchannel_`, which the former now wrap. The old\n    versions will be removed in ABI3.\n  * All functions prefixed with `channels_` have been deprecated in favor of\n    versions prefixed with `ncchannels_`, which the former now wrap. The old\n    versions will be removed in ABI3.\n  * `SIGINT`, `SIGQUIT`, and `SIGTERM` are now masked for the calling thread\n    when writing starts, and unmasked when writing has ended. This prevents\n    the writing thread from handling these signals in the middle of a write,\n    which could otherwise leave the terminal locked up (if it resulted in\n    aborting an escape sequence). The signal will be delivered when unblocked.\n    For this to work properly, other threads ought also have these signals\n    blocked. `notcurses_getc()` and friends thus no longer drop these signals\n    from the provided `sigset_t`; they are instead added if not present.\n  * Added `nccell_width()` to get the column length of an `nccell`.\n\n* 2.2.8 (2021-04-18)\n  * All remaining functions prefixed with `cell_` or `cells_` have been\n    deprecated in favor of versions prefixed with `nccell_` or `nccell_`,\n    respectively, which the former now wrap. The old versions will be\n    removed in ABI3.\n  * `ncvisual_inflate()` has been added to perform non-interpolative\n    enlarging. It is intended for use with pixel art.\n\n* 2.2.6 (2021-04-12)\n  * `ncplane_rgba()` has been deprecated in favor of the new function\n    `ncplane_as_rgba()`, which the former now wraps. It will be removed\n    in ABI3. The new function can report the synthesized pixel geometry.\n  * `ncvisual_geom()` has been deprecated in favor of the new function\n    `ncvisual_blitter_geom()`, which the former now wraps. It will be\n    removed in ABI3. The new function can report the chosen blitter.\n  * `ncplane_pixelgeom()` has been added, allowing callers to determine the\n    size of the plane and cells in pixels, as well as the maximum bitmap\n    size that can be displayed.\n  * Added new function `ncdirect_stream()`, which does what you'd think.\n  * `cell_release()` and `cell_duplicate()` have been migrated to\n    `nccell_release()` and `nccell_duplicate()`, respectively. The former\n    forms have been deprecated, and will be removed in API3.\n  * Added `NCVISUAL_OPTION_ADDALPHA`, and the `transcolor` field to\n    `ncvisual_options`. If the former flag is used, the latter color\n    will be treated as transparent.\n\n* 2.2.5 (2021-04-04)\n  * Bugfix release, no user-visible changes.\n\n* 2.2.4 (2021-03-29)\n  * Implemented **EXPERIMENTAL** `NCBLIT_PIXEL` for terminals reporting the\n    Kitty pixel graphics protocol.\n  * Added `notcurses_debug_caps()` to dump terminal properties, both those\n    reported and those inferred, to a `FILE*`.\n  * Added `NCOPTION_NO_CLEAR_BITMAPS` option for `notcurses_init()`.\n  * Added `ncplane_valign()` and `ncplane_halign()`. `ncplane_align()` is now\n    an alias for `ncplane_halign()`, and deprecated.\n  * Added `NCVISUAL_OPTION_HORALIGNED` and `NCVISUAL_OPTION_VERALIGNED` flags\n    for `ncvisual_render()`.\n  * Added `NCPLANE_OPTION_VERALIGNED` flag for `ncplane_create()`.\n  * Added the `nctabbed` widget for multiplexing planes data with navigational\n    tabs. Courtesy Łukasz Drukała, in his first contribution.\n  * Removed **notcurses_canpixel()**, which was obsoleted by\n    **notcurses_check_pixel_support()**.\n  * Added `NCPLANE_OPTION_MARGINALIZED` flag for `ncplane_create()`. Added\n    the `ncplane_resize_marginalized()` resize callback. This allows you to\n    have automatic resizing with a margin relative to some parent plane.\n\n* 2.2.3 (2021-03-08)\n  * Implemented **EXPERIMENTAL** `NCBLIT_PIXEL` for terminals reporting Sixel\n    support. Added `notcurses_check_pixel_support()` and its companion\n    `ncdirect_check_pixel_support()`, which must be called (and must return\n    success) before `NCBLIT_PIXEL` will be available. `NCBLIT_PIXEL` degrades\n    to `NCBLIT_3x2` until support is verified. This functionality is not yet\n    well integrated into general rendering; it will not play nicely with other\n    intersecting planes. Do not rely on current behavior.\n  * Add the `nctree` widget for line-oriented hierarchical data. See\n    the new `notcurses_tree(3)` man page for complete information.\n  * Ceased exporting `cell_fchannel()`, `cell_bchannel()`,\n    `cell_set_fchannel()`, and `cell_set_bchannel()`. These functions were\n    never safe for users. Everything a user might want to manipulate can be\n    manipulated with more granular functions.\n  * Add `SIGILL` to the set of fatal signals we handle.\n  * Added `NCKEY_SIGNAL`. `NCKEY_RESIZE` is now an alias for `NCKEY_SIGNAL`.\n  * `SIGCONT` now synthesizes a `NCKEY_SIGNAL`, just like `SIGWINCH`.\n\n* 2.2.2 (2021-02-18):\n  * `notcurses_stats()` no longer qualifies its `notcurses*` argument with\n    `const`, since it now takes a lock. I'm sorry about that, though on the\n    plus side, data races can no longer result in invalid stats.\n  * `ncplane_qrcode()` no longer accepts a blitter argument, since `NCBLIT_2x1`\n    is the only one that actually works with qr code scanners. I'm unaware of\n    any external `ncplane_qrcode()` users, so hopefully this isn't a problem.\n\n* 2.2.1 (2021-02-09):\n  * Brown-bag release: fix UTF8 discovery in direct mode. Sorry!\n\n* 2.2.0 (2021-02-08):\n  * Add `notcurses_canbraille()` capability predicate.\n\n* 2.1.8 (2021-02-03):\n  * The `notcurses-tetris` binary has been renamed `nctetris`.\n  * The new function `channel_set_palindex()` has been added.\n  * `NCDIRECT_OPTION_NO_READLINE` has been removed after a short life.\n  * `ncdirect_readline()` has been added. The first time used, it initializes\n    Readline. Readline will be destroyed by ncdirect_stop() if it was ever\n    initialized.\n\n* 2.1.7 (2021-01-21):\n  * Notcurses has been split into two libraries, `notcurses-core` and\n    `notcurses`. The latter contains the heavyweight multimedia code,\n    so that applications which don't need this functionality can link against\n    only the former. `pkg-config` support is present for both. If using only\n    `notcurses_core`, use the new functions `notcurses_core_init()` and/or\n    `ncdirect_core_init()` in place of `ncdirect_init()` and\n    `notcurses_init()`, or your program is unlikely to link.\n  * The `notcurses-view` binary has been renamed `ncplayer`.\n\n* 2.1.5 (2021-01-15):\n  * Notcurses **now depends on GNU Readline at build and runtime**, entirely\n    for the benefit of direct mode, which now prepares GNU Readline for safe\n    use (unless the new `NCDIRECT_OPTIONS_NO_READLINE` is used).\n  * `ncplane_putstr_yx()`, `ncplane_putstr_stained()`, and\n    `ncplane_putnstr_yx()` now return the number of columns output, as\n    long documented (they were mistakenly returning the number of bytes).\n  * `ncplane_abs_yx()` has been added, returning the absolute coordinates of\n    the plane's origin (i.e. coordinates relative to its pile).\n\n* 2.1.4 (2021-01-03):\n  * Direct mode now supports `NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS`, and by\n    default installs signal handlers similar to those of fullscreen mode.\n    They will attempt to reset the terminal, and propagate the signal.\n  * Add `channels_fg_palindex()` and `channels_bg_palindex()`.\n\n* 2.1.3 (2020-12-31)\n  * `ncdirect_styles_{set, on, off}()` have been deprecated in favor of\n    `ncdirect_{set, on, off}_styles()`, to match `ncplane_` equivalents.\n  * `ncdirect_raster_frame()` no longer requires `blitter` nor `scale`.\n  * `ncdirect_{fg, bg}_{default, rgb}()` have been deprecated in favor of\n    `ncdirect_set_{fg, bg}_{default, rgb}()`, to match `ncplane`.\n\n* 2.1.2 (2020-12-25)\n  * Add `notcurses_linesigs_enable()` and `notcurses_linesigs_disable()`.\n  * Divide `ncdirect_render_image()` into component `ncdirect_render_frame()`\n    and `ncdirect_raster_frame()` (the original remains), allowing multiple\n    threads to decode images concurrently.\n  * Sextants are now considered supported for certain values of `TERM`.\n  * `ncvisual_default_blitter()` has been deprecated in favor of the new\n    function `ncvisual_media_defblitter()`. This function's opaque logic\n    accepts a `struct notcurses *`, providing some future-proofing against\n    blitter changes. This function is necessary to get `NCBLIT_3x2` from\n    `NCBLIT_DEFAULT`.\n\n* 2.1.1 (2020-12-16)\n  * Progress bars via `ncprogbar`, using the standard widget API.\n\n* 2.1.0 (2020-12-13)\n  * `cell` has been renamed `nccell`. The old name has been kept as an alias,\n    but ought be considered deprecated. It will be removed in Notcurses 3.0.\n\n* 2.0.12 (2020-12-12)\n  * `ncplane_resize_maximize()` has been added, suitable for use as a\n    `resizecb`. It resizes the plane to the visual area's size, and is\n    the resizecb used by the standard plane.\n\n* 2.0.11 (2020-12-09)\n  * Added `ncplane_descendant_p()` predicate.\n \n* 2.0.10 (2020-12-06)\n  * `ncpile_top()` and `ncpile_bottom()` have been added, returning the top\n    or bottommost plane, respectively, of the pile containing their argument.\n  * Added `cell_load_egc32()`, allowing a cell to be released and then reloaded\n    with a UTF-8 EGC of up to 4 bytes, passed as a `uint32_t` (as opposed to a\n    `const char *`).\n\n* 2.0.9 (2020-12-01)\n  * `ncmenu`s now automatically expand or shrink to match their binding plane.\n\n* 2.0.8 (2020-11-27)\n  * The major, minor, and patch versions are now available as preprocessor\n    numeric defines, fit for comparisons at the cpp level. The\n    `NOTCURSES_VERSION_COMPARABLE` macro has been added, to form a comparable\n    version ID from a provided major, minor, and patch level. The\n    `NOTCURSES_VERNUM_ORDERED` macro has been added, defined as a comparable\n    version ID for the current version of Notcurses.\n  * Add new function `ncplane_reparent_family()`, which reparents a plane and\n    its bindtree (all planes bound to the plane, recursively).\n    `ncplane_reparent()` now reparents only the specified plane; any planes\n    bound to it are reparented to its old parent.\n  * Move to a multipile model. For full details, consult\n      https://groups.google.com/g/notcurses/c/knB4ojndv8A and\n      https://github.com/dankamongmen/notcurses/issues/1078 and\n      `notcurses_plane(3)`. In short:\n    * A `struct notcurses` is now made up of one or more piles. A pile is one\n      or more `ncplane`s, with a bindtree and a z-axis. Different piles can be\n      mutated or rendered concurrently. There is no new user-visible type: a\n      `struct notcurses` can be treated as a single pile.\n    * To create a new pile from a new plane, use the new function\n      `ncpile_create()`. The returned plane will be the top, bottom, and root\n      of a new plane. Alternatively, use `ncplane_reparent()` or\n      `ncplane_reparent_family()` with the source equal to the destination.\n    * Add new function `ncpile_render()`, which renders the pile containing the\n      specified plane to the specified buffer. Add new function\n      `ncpile_rasterize()` to rasterize the specified buffer to output.\n  * Added `NCSTYLE_STRUCK` for strikethrough.\n\n* 2.0.7 (2020-11-21)\n  * The `horiz` union of `ncplane_options` has been discarded; the `int x`\n    within has been promoted. This union brought no actual type safety, and was\n    annoying for callers to deal with otherwise. Sorry for the inconvenience.\n  * Added `ncplane_set_resizecb()` and `ncplane_resizecb()`.\n\n* 2.0.3 (2020-11-09)\n  * Add `NCBLIT_3x2` aka the SEXBLITTER, making use of Unicode 13's sextant\n    glyphs. `notcurses_lex_blitter()` now recognizes `sexblitter`.\n  * Blitting functions no longer count transparent cells towards the total\n    returned number of cells written, but since these are not directly\n    callable by the user, this ought not lead to any user-visible changes.\n  * Added (k)eller demo to `notcurses-demo`.\n  * `ncreader` now supports Alt+'b' to move one word back, Alt+'f' to move one\n    word forward, Ctrl+'A' to move to the beginning of the line, Ctrl+'E' to\n    move to the end of the line, Ctrl+'U' to clear the line before the cursor,\n    and Ctrl+'W' to clear the word before the cursor (when\n    `NCREADER_OPTION_NOCMDKEYS` has not been specified).\n\n* 2.0.2 (2020-10-25)\n  * Add `ncvisual_decode_loop()`, which returns to the first frame upon\n    reaching the end of a file.\n\n* 2.0.1 (2020-10-19)\n  * Add `ncmenu_item_set_status()` for disabling or enabling menu items.\n    * Disabled menu items cannot be selected.\n    * Menu sections consisting only of disabled items are themselves disabled,\n      and cannot be unrolled.\n  * Add `ncinput_equal_p()` for comparison of `ncinput` structure data.\n  * `ncmenu_offer_input()` now recognizes the shortcuts for registered\n    sections, and will unroll the appropriate section when given input.\n  * Added `notcurses_stddim_yx_const()` (`notcurses_stddim_yx()` `const` form).\n\n* 2.0.0 (2020-10-12) **\"Stankonia\"**\n  * **API STABILITY!** The API expressed in 2.0.0 will be maintained throughout\n    at least 2.x.x. A program compiled against 2.0.0 will continue to compile\n    and function properly against all 2.x.x releases. Thanks for putting up\n    with the freewheeling API breakage until now.\n  * `NOTCURSES_VERSION_{MAJOR, MINOR, PATCH, TWEAK}` are now available from\n    `notcurses/version.h`. These represent the version your program was\n    *compiled against*. The version your program is *linked to* can still be\n    acquired with `notcurses_version_components()` (or as a human-readable\n    string via `notcurses_version()`).\n\n* 1.7.6 (2020-10-09)\n  * `ncstats` added the new stats `writeout_ns`, `writeout_min_ns`, and\n    `writeout_max_ns`. The `render_*ns` stats now only cover the rendering\n    and rasterizing process. The `writeout*ns` stats cover the time spent\n    writing data out to the terminal. `notcurses_render()` involves both of\n    these processes.\n  * `notcurses_render_to_buffer()` has been added, allowing user control of\n    the process of writing frames out to the terminal.\n  * `notcurses_stats_alloc()` has been added, to allocate an `ncstats` object.\n    `notcurses_reset_stats()` has been renamed `notcurses_stats_reset()`.\n  * Two flags have been defined for `ncdirect_init()`:\n    `NCDIRECT_OPTION_INHIBIT_SETLOCALE` and `NCDIRECT_OPTION_INHIBIT_CBREAK`.\n    The former is similar to `NCOPTION_INHIBIT_SETLOCALE`. The latter keeps\n    `ncdirect_init()` from touching the termios and entering cbreak mode.\n  * The C++ wrapper `Ncplane::putwc()` has been renamed `Ncplane::putwch()`, so\n    as not to clash with standard libraries implementing `putwc()` as a macro.\n\n* 1.7.5 (2020-09-29)\n  * `ncreel_destroy()` now returns `void` rather than `int`.\n  * `nctablet_ncplane()` has been renamed `nctablet_plane()`.\n  * The standard plane now has the name `std`.\n  * Removed long-deprecated `ncplane_set_attrs()` and `ncplane_attrs()`.\n  * Renamed `ncplane_styles_*()` to `ncplane_*_styles()`, to conform with\n    every other `ncplane_set_*()` function, but retained the old versions as\n    (deprecated) aliases.\n  * Renamed `cell_styles_*()` to `cell_*_styles()`, to conform with every other\n    `cell_set_*()` function. Since these were inline functions, I've not\n    bothered to retain the old versions.\n\n* 1.7.4 (2020-09-20)\n  * All `_rgb_clipped()` functions have been renamed `_rgb8_clipped()`, to\n    match the changes made in 1.7.2. Sorry, I ought have done this before.\n  * `ncplane_create()` has been introduced, taking a `struct ncplane_options`\n    parameter. This replaces `ncplane_aligned()`, and will replace\n    `ncplane_new()`. The latter ought be considered deprecated, and will be\n    removed in the future. To align a place as previously done with\n    `ncplane_aligned()`, use the `NCPLANE_OPTION_HORALIGNED` flag.\n  * The `ncplane_options` struct includes a function pointer member,\n    `resizecb`. If not `NULL`, this function will be called after the parent\n    plane is resized. See `notcurses_plane.3` for more information.\n  * `ncplane_resize_realign()` has been added, suitable for use as a\n    `resizecb`. It realigns the plane against its parent.\n  * `NCCHANNEL_ALPHA_MASK` has been renamed `CHANNEL_ALPHA_MASK`, to match\n    the other declarations.\n\n* 1.7.3 (2020-09-19)\n  * API changes pursuant to 2.0 API finalization:\n  * `mbswidth()` has been renamed `ncstrwidth()`.\n  * The long-promised/dreaded Great Widget Review, normalizing behavior across\n    all widgets, has been effected. Sorry, there was no getting around this\n    one. Pretty much all widgets have slightly changed, because pretty much all\n    widgets previously behaved slightly differently:\n     * `ncselector_create()` and `ncmultiselector_create()` now take ownership\n       of the provided `ncplane`. On an error in these functions, the `ncplane`\n       will be destroyed. Otherwise, the `ncplane` is destroyed by\n       `ncselector_destroy()` or `ncmultiselector_destroy()`.\n     * `ncselector_create()`, `ncmultiselector_create()`, and\n       `ncreader_create()` no longer accept `int y, int x` placement\n       parameters. Just place the `ncplane`.\n     * `ncselector_options`, `ncmultiselector_options`, and `ncreel_options`\n       have lost their `bgchannels` members. Just set the base character for\n       the `ncplane`.\n     * `ncreader_options` has lost its `echannels`, `eattrword`, `egc`,\n       `physrows`, and `physcols` fields. Just set the base character and size\n       for the `ncplane`.\n  * Functions which set a 24-bit RGB value have had the suffix `g` replaced\n    with `g_rgb`. Functions which set three 8-bit RGB components have had the\n    suffix `rgb` replaced with `rgb8`. This was done because e.g.\n    `channels_set_fg()` and `channels_set_fchannel()` were indistinguishable on\n    sight. Failure to make the necessary conversions will result in compiler\n    errors. See https://github.com/dankamongmen/notcurses/issues/985.\n  * Functions ending in `_stainable()` now end in `_stained()`.\n  * `ncplane_putwc_stained()` and `ncplane_putwstr_stained()` have been\n    added in the interest of orthogonality.\n  * `ncplane_new_named()` has been eliminated. `ncplane_new()` now takes a\n    `const char* name` argument. `ncplane_bound()` and `ncplane_bound_named()`\n    have both been eliminated. `ncplane_new()` now accepts an `ncplane*`\n    instead of a `notcurses*`. All functionality exposed by the removed\n    functions is thus now present in `ncplane_new()`.\n  * `ncplane_aligned_named()` has been removed. `ncplane_aligned()` now accepts\n    a `const char* name` argument.\n\n* 1.7.2 (2020-09-09)\n  * Exported `ncvisual_default_blitter()`, so that the effective value of\n    `NCBLIT_DEFAULT` can be determined.\n  * Added `NCREADER_OPTION_CURSOR`, instructing the `ncreader` to make the\n    terminal cursor visible, and manage the cursor's placement.\n\n* 1.7.1 (2020-08-31)\n  * Renamed `CELL_SIMPLE_INITIALIZER` to `CELL_CHAR_INITIALIZER`, and\n    `cell_load_simple()` to `cell_load_char()`.\n  * Renamed `ncplane_putsimple()` to `ncplane_putchar()`,\n    `ncplane_putsimple_stainable()` to `ncplane_putchar_stainable()`,\n    and `ncplane_putsimple_yx()` to `ncplane_putchar_yx()`.\n\n* 1.7.0 (2020-08-30)\n  * Added `notcurses_ucs32_to_utf8()` conversion helper.\n  * `ncdirect_init()` now takes a third `uint64_t flags` parameter. No flags\n    have been defined, and this parameter ought be set to 0.\n\n* 1.6.20 (2020-08-30)\n  * Added convenience functions `ncplane_y()` and `ncplane_x()`, components\n    of longstanding `ncplane_yx()`.\n  * `ncreel` functions now generally call `ncreel_redraw()` themselves. This\n    includes `ncreel_add()`, `ncreel_del()`, `ncreel_next()`, and\n    `ncreel_prev()`. `ncreel_redraw()` need only be called to update tablets.\n  * In order to conform with CMake naming conventions, our CMake package is\n    now accessed as \"Notcurses\" rather than \"notcurses\".\n\n* 1.6.19 (2020-08-27)\n  * Direct mode now places the terminal into \"cbreak mode\". This disables\n    echo and line-buffering of input. If this is undesirable, you can restore\n    the terminal state following `ncdirect_init()`, but this will break the\n    semantics of `ncdirect_getc()` and derivatives (due to line buffering).\n  * The notcurses input layer has been reproduced for direct mode, including\n    `ncdirect_getc()`, `ncdirect_getc_nblock()`, `ncdirect_getc_blocking()`,\n    and `ncdirect_inputready_fd()`. Mouse support is not yet available in\n    direct mode, but becomes possible through these additions.\n  * Some very subtle bugs on big-endian machines have been repaired. Be\n    aware that if your execution endianness does not match the endianness\n    assumed at build time, you're gonna have a rough go of it.\n\n* 1.6.18 (2020-08-25)\n  * `nc_err_e` has been taken behind the shed and shot in the face. All\n    functions which once returned `nc_err_e` now return a bimodal `int`. Those\n    functions which accepted a value-result `nc_err_e*` no longer take this\n    argument.\n  * `notcurses_cursor_enable()` now takes two `int` parameters specifying the\n    desired location of the cursor. Both `notcurses_cursor_enable()` and\n    `notcurses_cursor_disable()` now return `int` rather than `void`.\n  * `NCOPTION_RETAIN_CURSOR` has been removed.\n  * `ncreader` now implements `NCREADER_OPTION_HORSCROLL` for horizontal\n    scrolling. In addition, the following functions have been added:\n    * `int ncreader_move_left(struct ncreader* n)`\n    * `int ncreader_move_right(struct ncreader* n)`\n    * `int ncreader_move_up(struct ncreader* n)`\n    * `int ncreader_move_down(struct ncreader* n)`\n    * `int ncreader_write_egc(struct ncreader* n, const char* egc)`.\n  * Added `ncplane_above()` and `notcurses_bottom()`.\n  * Added `ncplane_set_fchannel()` and `ncplane_set_bchannel()`.\n\n* 1.6.17 (2020-08-22)\n  * `ncdirect_flush()` now takes a `const struct ncdirect*`.\n  * A `const char* title` field has been added to `ncplot_options`. If not\n    `NULL`, this title will be displayed to the right of any labels. Plot\n    data will cover the title, if present.\n  * `ncplot` no longer inverts `maxchannel` and `minchannel`. Speaking\n    of which, both of these fields are now plural, `maxchannels` etc.\n\n* 1.6.16 (2020-08-22)\n  * `cell_simple_p()` has been removed. It is no longer a useful concept for\n    user code, and its presence is indicative of a likely error.\n  * `channels_blend()` has been removed. It wasn't really useful to users,\n    and was difficult to explain.\n  * `ncplane_mergedown()` has been renamed `ncplane_mergedown_simple()`. A\n    more general form, capable of projecting arbitrary subregions of the source\n    plane down to the destination plane. The source argument to\n    `ncplane_mergedown_simple()` is now `const`.\n  * `iprefix()` has been added, corresponding to `IPREFIXSTRLEN`. This ought\n    be used if you want binary prefixes without the 'i' suffix indicating\n    binary prefixes, which I predict will endear you to exactly no one.\n  * Added `channels_set_fg_palindex()` and `channels_set_bg_palindex()`.\n    Rewrote `cell_set_fg_palindex()` and `cell_set_bg_palindex()` in terms\n    of these two. This is possible because the palette index now overlaps the\n    RGB in a channel (they were originally in the attrword).\n  * Added `ncdirect_flush()`, mainly for the benefit of FFI that might not\n    have a native interface to `fflush(3)`.\n  * The `ncplot_options` struct has a new field, `legendstyle`. If the\n    dependent variable is being labeled, this style will be applied to the\n    legend. Without NCPLOT_OPTION_LABELTICKSD, this value is ignored.\n\n* 1.6.15 (2020-08-16)\n  * Styles now work properly with `ncdirect`, which apparently has never\n    been the case until now :/.\n  * EGCs occupying four bytes or fewer when encoded as UTF8 are now\n    inlined directly into the `cell` structure. This should mean nothing\n    for you save less memory consumption per plane, and faster operation.\n    In the course of doing so, the `attrword` field of the `cell` structure\n    was renamed `stylemask`, and reduced from 32 to 16 bits.\n  * `notcurses_palette_size()` now returns `unsigned`.\n\n* 1.6.12 (2020-08-12)\n  * `ncreel`s `tabletcb` callback function semantics are radically simplified.\n    No more worrying about borders that might or might not have been drawn;\n    simply fill up the plane that you're handed. This eliminates four of the\n    seven arguments to these callbacks. I hope the inconvenience of adapting\n    them is worth the elimination of complexity therein; I obviously think\n    it is =].\n  * `ncselector_redraw()` and `ncmultiselector_redraw()` no longer call\n    `notcurses_render()`. You will need to call `notcurses_render()` for the\n    display to reflect any changes. `ncselector_create` now binds the plane\n    it creates to the plane it was provided, and no longer checks to ensure\n    the widget can be fit within the borders of this binding plane.\n  * Added `ncplane_new_named()`, `ncplane_bound_named()`, and\n    `ncplane_aligned_named()`. These would be the defaults, but I didn't want\n    to break existing code. They might become the defaults by 2.0. Names are\n    used only for debugging (`notcurses_debug()`) at this time.\n  * Added `ncplane_parent()` and `ncplane_parent_const()` for accessing the\n    plane to which a plane is bound.\n  * The `notcurses` Rust crate (`rust/notcurses`) has been moved to\n    `dankamongmen/notcurses-rs` on GitHub, and removed from the tree.\n    Jose Luis will be leading development on this high-level wrapper.\n\n* 1.6.11 (2020-08-03)\n  * `cell_egc_idx()` is no longer exported; it was never intended to be.\n\n* 1.6.10 (2020-08-01)\n  * The `egc` member of `ncreader_options` is now `const`.\n\n* 1.6.7 (2020-07-26)\n  * GNU libunistring is now required to build/load Notcurses.\n  * Added `ncmenu_mouse_selection()`. Escape now closes an unrolled menu\n    when processed by `ncmenu_offer_input()`.\n\n* 1.6.6 (2020-07-19)\n  * `notcurses-pydemo` is now only installed alongside the Python module,\n    using setuptools. CMake no longer installs it.\n  * Added `notcurses_lex_blitter()` and `notcurses_str_scalemode()`.\n\n* 1.6.4 (2020-07-19)\n  * Added `notcurses_str_blitter()`.\n\n* 1.6.2 (2020-07-15)\n  * The option `NCOPTION_NO_FONT_CHANGES` has been added. This will cause\n    Notcurses to not muck with the current font. Because...\n  * Notcurses now detects a Linux text console, and reprograms its Unicode\n    to glyph tables and font data tables to include certain Box-Drawing and\n    Block-Drawing glyphs. This vastly improves multimedia rendering and\n    line/box art in the Linux console.\n\n* 1.6.1 (2020-07-12)\n  * Added `notcurses_version_components()` to get the numeric components of\n    the loaded Notcurses version.\n  * Added `notcurses_render_file()` to dump last rendered frame to a `FILE*`.\n  * The `ncreel` widget has been overhauled to bring it in line with the\n    others (`ncreel` began life in another project, predating Notcurses).\n    The `toff`, `boff`, `roff`, and `loff` fields of `ncreel_options` have\n    been purged, as have `min_` and `max_supported_rows` and `_cols`. There\n    is no longer any need to provide a pipe/eventfd. `ncreel_touch()`,\n    `ncreel_del_focused()`, and `ncreel_move()` have been removed.\n  * Added `ncdirect_hline_interp()`, `ncdirect_vline_interp()`,\n    `ncdirect_rounded_box()`, `ncdirect_double_box()`, and the ridiculously\n    flexible `ncdirect_box()`.\n  * Added `ncplane_putstr_stainable()`.\n\n* 1.6.0 (2020-07-04)\n  * Behavior has changed regarding use of the provided `FILE*` (which, when\n    `NULL`, is assumed to be `stdout`). Both Notcurses and `ncdirect` now\n    try to open a handle to the controlling TTY, **unless** the provided\n    `FILE` is a TTY, in which case it is used directly. Certain interactions\n    now only go to a TTY, in particular `ncdirect_cursor_yx()` and various\n    `ioctl()`s used internally. Furthermore, when no true TTY is found (true\n    for e.g. daemonized processes and those in a Docker launched without\n    `-t`), Notcurses (in both full mode and direct mode) will return a virtual\n    screen size of 80x24. This greatly improves behavior when redirecting to a\n    file or lacking a TTY; one upshot is that we now have much-expanded unit\n    test coverage in the Docker+Drone autobuilders.\n  * `ncdirect_render_image()` has been added, allowing images (but not\n    videos or animated images) to be rendered directly into the standard I/O\n    streams. It begins drawing from the current cursor position, running\n    through the right-hand side of the screen, and scrolling as much content\n    as is necessary.\n  * `ncneofetch` has been rewritten to use `ncdirect`, and thus no longer\n    clobbers your entire terminal, and scrolls like standard I/O.\n\n* 1.5.3 (2020-06-28)\n  * The default blitter when `NCSCALE_STRETCH` is used is now `NCBLIT_2x2`,\n    replacing `NCBLIT_2x1`. It is not the default for `NCSCALE_NONE` and\n    `NCSCALE_SCALE` because it does not preserve aspect ratio.\n  * The values of `CELL_ALPHA_OPAQUE` and friends have been redefined to\n    match their values within a channel representation. If you've been\n    using the named constants, this should have no effect on you; they sort\n    the same, subtract the same, and a zero initialization remains just as\n    opaque as it ever was. If you weren't using their named constants, now's\n    an excellent time to revise that policy. `CELL_ALPHA_SHIFT` has been\n    eliminated; if you happened to be using this, the redefinition of the\n    other `CELL_*` constants (probably) means you no longer need to.\n\n* 1.5.2 (2020-06-19)\n  * The `ncneofetch` program has been added, of no great consequence.\n  * A `NULL` value can now be passed as `sbytes` to `ncplane_puttext()`.\n  * `ncvisual_geom()` now takes scaling into account.\n  * `notcurses_cantruecolor()` has been added, allowing clients to\n    determine whether the full RGB space is available to us. If not,\n    we only have palette-indexed pseudocolor.\n\n* 1.5.1 (2020-06-15)\n  * The semantics of rendering have changed slightly. In 1.5.0 and prior\n    versions, a cell without a glyph was replaced *in toto* by that plane's\n    base cell at rendering time. The replacement is now tripartite: if there\n    is no glyph, the base cell's glyph is used; if there is a default\n    foreground, the base cell's foreground is used; if there is a default\n    background, the base cell's background is used. This will hopefully be\n    more intuitive, and allows a plane to effect overlays of varying colors\n    without needing to override glyphs (#395).\n  * `ncvisual_geom()`'s `ncblitter_e` argument has been replaced with a\n    `const struct ncvisual_options*`, so that `NCVISUAL_OPTIONS_NODEGRADE`\n    can be taken into account (the latter contains a `blitter_e` field).\n  * Added `ncuplot_sample()` and `ncdplot_sample()`, allowing retrieval of\n    sample data from `ncuplot`s and `ncdplot`s, respectively.\n  * Added convenience function `ncplane_home()`, which sets the cursor\n    to the plane's origin (and returns `void`, since it cannot fail).\n  * `ncplane_qrcode()` now accepts an `ncblitter_e`, and two value-result\n    `int*`s `ymax` and `xmax`. The actual size of the drawn code is\n    returned in these parameters.\n\n* 1.5.0 (2020-06-08)\n  * The various `bool`s of `struct notcurses_options` have been folded into\n    that `struct`'s `flags` field. Each `bool` has its own `NCOPTION_`.\n  * Added a Pixel API for working directly with the contents of `ncvisual`s,\n    including `ncvisual_at_yx()` and `ncvisual_set_yx()`.\n  * Added `ncplane_puttext()` for writing multiline, line-broken text.\n  * Added `ncplane_putnstr()`, `ncplane_putnstr_yx()`, and\n    `ncplane_putnstr_aligned()` for byte-limited output of UTF-8.\n\n* 1.4.5 (2020-06-04)\n  * `ncblit_rgba()` and `ncblit_bgrx()` have replaced most of their arguments\n    with a `const struct ncvisual_options*`. `NCBLIT_DEFAULT` will use\n    `NCBLITTER_2x1` (with fallback) in this context. The `->n` field must\n    be non-`NULL`--new planes will not be created.\n  * Added `ncplane_notcurses_const()`.\n\n* 1.4.4.1 (2020-06-01)\n  * Got the `ncvisual` API ready for API freeze: `ncvisual_render()` and\n    `ncvisual_stream()` now take a `struct ncvisual_options`. `ncstyle_e`\n    and a few other parameters have been moved within. Both functions now\n    take a `struct notcurses*`. The `struct ncvisual_options` includes a\n    `ncblitter_e` field, allowing visuals to be mapped to various plotting\n    paradigms including Sixel, Braille and quadrants. Not all backends have\n    been implemented, and not all implementations are in their final form.\n    `CELL_ALPHA_BLEND` can now be used for translucent visuals.\n  * Added `ncvisual_geom()`, providing access to an `ncvisual` size and\n    its pixel-to-cell blitting ratios.\n  * Deprecated functions `ncvisual_open_plane()` and `ncplane_visual_open()`\n    have been removed. Their functionality is present in\n    `ncvisual_from_file()`. The function `ncvisual_plane()` no longer has\n    any meaning, and has been removed.\n  * The `fadecb` typedef now accepts as its third argument a `const struct\n    timespec`. This is the absolute deadline through which the frame ought\n    be displayed. New functions have been added to the Fade API: like the\n    changes to `ncvisual_stream()`, this gives more flexibility, and allows\n    more precise timing. All old functions remain available.\n\n* 1.4.3 (2020-05-22)\n  * Plot: make 8x1 the default, instead of 1x1.\n  * Add `PREFIXFMT`, `BPREFIXFMT`, and `IPREFIXFMT` macros for `ncmetric()`.\n    In order to properly use `printf(3)`'s field width capability, these\n    macros must be used. This is necessary to support 'µ' (micro).\n  * C++'s NotCurses constructor now passes a `nullptr` directly through to\n    `notcurses_init()`, rather than replacing it with `stdout`.\n  * Added `USE_STATIC` CMake option, defaulting to `ON`. If turned `OFF`,\n    static libraries will not be built.\n\n* 1.4.2.4 (2020-05-20)\n  * Removed `ncplane_move_above_unsafe()` and `ncplane_move_below_unsafe()`;\n    all z-axis moves are now safe. Z-axis moves are all now O(1), rather\n    than the previous O(N).\n\n* 1.4.2.3 (2020-05-17)\n  * Added `notcurses_canutf8()`, to verify use of UTF-8 encoding.\n  * Fixed bug in `ncvisual_from_plane()` when invoked on the standard plane.\n  * `ncvisual_from_plane()` now accepts the same four geometric parameters\n    as other plane selectors. To reproduce the old behavior, for `ncv`, call\n    it as `ncvisual_from_plane(ncv, 0, 0, -1, -1)`.\n  * `ncvisual_from_plane()`, `ncplane_move_below_unsafe()`, `ncplane_dup()`,\n    and `ncplane_move_above_unsafe()` now accept `const` arguments where they\n    did not before.\n  * `notcurses_canopen()` has been split into `notcurses_canopen_images()` and\n    `notcurses_canopen_videos()`.\n  * `ncmetric()` now uses multibyte suffixes (particularly for the case of\n    'µ', i.e. micro). This has changed the values of `PREFIXSTRLEN` and\n    friends. So long as you were using `PREFIXSTRLEN`, this should require\n    only a recompile. If you were using `PREFIXSTRLEN` in a formatted output\n    context to count columns, you must change to `PREFIXCOLUMNS` etc.\n  * The `streamcb` type definition now accepts a `const struct timespec*` as\n    its third argument. This is the absolute time viz `CLOCK_MONOTONIC` through\n    which the frame ought be displayed. The callback must now effect delay.\n  * Mouse coordinates are now properly translated for any margins.\n  * `qprefix()` and `bprefix()` now take a `uintmax_t` in place of an\n    `unsigned`, to match `ncprefix`.\n\n* 1.4.0 (2020-05-10)\n  * `ncplane_content()` was added. It allows all non-null glyphs of a plane to\n    be returned as a nul-terminated, heap-allocated string.\n  * `ncreader` was added. This widget allows freeform input to be edited in a\n    block, and collected into a string.\n  * `selector_options` has been renamed to `ncselector_options`, and\n    `multiselector_options` has been renamed to `ncmultiselector_options`.\n    This matches the other widget option struct's nomenclature.\n  * `ncplane_set_channels()` and `ncplane_set_attr()` have been added to allow\n    `ncplane` attributes to be set directly and in toto.\n  * `NULL` can now be passed as the `FILE*` argument to `notcurses_init()` and\n    `ncdirect_init()`. In this case, a new `FILE*` will be created using\n    `/dev/tty`. If the `FILE*` cannot be created, an error will be returned.\n  * A `flags` field has been added to `notcurses_options`. This will allow new\n    boolean options to be added in the future without resizing the structure.\n    Define `NCOPTION_INHIBIT_SETLOCALE` bit. If it's not set, and the \"C\" or\n    \"POSIX\" locale is in use, `notcurses_init()` will invoke\n    `setlocale(LC_ALL, \"\")`.\n  * All widgets now take an `ncplane*` as their first argument (some took\n    `notcurses*` before). All widgets' `options` structs now have an `unsigned\n    flags` bitfield. This future-proofs the widget API, to a degree.\n\n* 1.3.4 (2020-05-07)\n  * `notcurses_lex_margins()` has been added to lex margins expressed in either\n    of two canonical formats. Hopefully this will lead to more programs\n    supporting margins.\n  * `ncvisual_open_plane()` has been renamed `ncvisual_from_file()`. The former\n    has been retained as a deprecated alias. It will be removed by 1.6/2.0.\n  * `ncvisual_from_rgba()` and `ncvisual_from_bgra()` have been added to\n    support creation of `ncvisual`s from memory, requiring no file.\n  * `ncvisual_rotate()` has been added, supporting rotations of arbitrary\n    radians on `ncvisual` objects.\n  * `ncvisual_from_plane()` has been added to support \"promotion\" of an\n    `ncplane` to an `ncvisual`. The source plane may contain only spaces,\n    half blocks, and full blocks. This builds atop the new function\n    `ncplane_rgba()`, which makes an RGBA flat array from an `ncplane`.\n  * The `ncplane` argument to `ncplane_at_yx()` is now `const`.\n\n* 1.3.3 (2020-04-26)\n  * The `ncdplot` type has been added for plots based on `double`s rather than\n    `uint64_t`s. The `ncplot` type and all `ncplot_*` functions were renamed\n    `ncuplot` for symmetry.\n  * FFMpeg types are no longer leaked through the Notcurses API. `AVERROR`\n    is no longer applicable, and `ncvisual_decode()` no longer returns a\n    `struct AVframe*`. Instead, the `nc_err_e` enumeration has been introduced.\n    Functions which once accepted a value-result `AVERROR` now accept a value-\n    result `nc_err_e`. The relevant constants can be found in\n    `notcurses/ncerrs.h`.\n  * OpenImageIO 2.1+ is now supported as an experimental multimedia backend.\n    FFmpeg remains recommended. Video support with OIIO is spotty thus far.\n  * CMake no longer uses the `USE_FFMPEG` option. Instead, the `USE_MULTIMEDIA`\n    option can be defined as `ffmpeg`, `oiio`, or `none`. In `cmake-gui`, this\n    item will now appear as an option selector. `oiio` selects OpenImageIO.\n\n* 1.3.2 (2020-04-19)\n  * `ncdirect_cursor_push()`, `notcurses_cursor_pop()`, and\n    `ncdirect_cursor_yx()` have been added. These are not supported on all\n    terminals. `ncdirect_cursor_yx()` ought be considered experimental; it\n    must read a response from the terminal, and this can interact poorly with\n    other uses of standard input.\n  * 1.3.1 unintentionally inverted the C++ `Notcurses::render()` wrapper's\n    return code. The previous semantics have been restored.\n\n* 1.3.1 (2020-04-18)\n  * `ncplane_at_yx()` and `ncplane_at_cursor()` have been changed to return a\n    heap-allocated EGC, and write the attributes and channels to value-result\n    `uint32_t*` and `uint64_t*` parameters, instead of to a `cell*`. This\n    matches `notcurses_at_yx()`, and means they're no longer invalidated if the\n    plane in question is destroyed. The previous functionality is available as\n    new functions `ncplane_at_yx_cell()` and `ncplane_at_cursor_cell()`.\n  * `ncplane_set_base()` inverted its `uint32_t attrword` and `uint64_t channels`\n    parameters, thus matching every other function with these two parameters.\n    It moved `const char* egc` before either, to force a type error, as the\n    change would otherwise be likely to go overlooked.\n  * Scrolling is now completely implemented. When a plane has scrolling enabled\n    through use of `ncplane_set_scrolling(true)`, output past the end of the\n    last line will now result in the top line of the plane being lost, all\n    other lines moved up one, and the bottom line cleared.\n\n* 1.2.8 (2020-04-10)\n  * `notcurses-tetris` now happily continues if it can't load its background.\n\n* 1.2.7 (2020-04-10)\n  * Plots now always keep the most recent data to their far right (i.e., the\n    gap that is initially filled is on the left, rather than the right).\n\n* 1.2.6 (2020-04-08)\n  * `ncplane_putsimple_yx()` and `ncplane_putstr_yx()` have been exported as\n    static inline functions.\n  * `ncplane_set_scrolling()` has been added, allowing control over whether a\n    plane scrolls. All planes, including the standard plane, do not scroll by\n    default. If scrolling is enabled, text output via the `*put*` family of\n    functions continues onto the next line when encountering the end of a row.\n    This does not apply to e.g. boxes or lines.\n  * `ncplane_putstr_yx()` now always returns the inverse of the number of\n    columns advanced on an error (it used to return the positive short count so\n    long as the error was due to plane geometry, not bad input).\n  * `ncplot_add_sample()` and `ncplot_set_sample()` have been changed to accept\n    a `uint64_t` rather than `int64_t`, since negative samples do not\n    currently make sense. Plots were made more accurate in general.\n  * `notcurses_term_dim_yx()` now accepts a `const struct notcurses*`.\n  * `notcurses_resize()` is no longer exported. It was never necessary to call\n    this in response to a resize, despite confusing documentation that could\n    have been read to suggest otherwise. If you're in a long block on input, and\n    get an `NCKEY_RESIZE`, just call `notcurses_refresh()` (which now calls\n    `notcurses_resize()` internally, as `notcurses_render()` always has).\n  * First Fedora packaging.\n\n* 1.2.5 (2020-04-05)\n  * Add ncplot, with support for sliding-windowed horizontal histograms.\n  * gradient, polyfill, `ncplane_format()` and `ncplane_stain()` all now return\n    the number of cells written on success. Failure still sees -1 returned.\n  * `ncvisual_render()` now returns the number of cells emitted on success, as\n    opposed to 0. Failure still sees -1 returned.\n  * `ncvisual_render()` now interprets length parameters of -1 to mean \"to the\n    end along this axis\", and no longer interprets 0 to mean this. 0 now means\n   \"a length of 0\", resulting in a zero-area rendering.\n  * `notcurses_at_yx()` no longer accepts a `cell*` as its last parameter.\n    Instead, it accepts a `uint32_t*` and a `uint64_t*`, and writes the\n    attribute and channels to these parameters. This was done because the\n    `gcluster` field of the `cell*` was always set to 0, which was surprising\n    and a source of blunders. The EGC is returned via the `char*` return\n    value. https://github.com/dankamongmen/notcurses/issues/410\n\n* 1.2.4 (2020-03-24)\n  * Add ncmultiselector\n  * Add `ncdirect_cursor_enable()` and `ncdirect_cursor_disable()`.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 32.3505859375,
          "content": "# Notcurses: blingful TUIs and character graphics\n\n**What it is**: a library facilitating complex TUIs on modern terminal\nemulators, supporting vivid colors, multimedia, threads, and Unicode to the\nmaximum degree possible. [Things](https://www.youtube.com/watch?v=dcjkezf1ARY) can be done with\nNotcurses that simply can't be done with NCURSES. It is furthermore\nfast as shit. **What it is not**: a source-compatible X/Open Curses implementation, nor a\nreplacement for NCURSES on existing systems.\n\n<p align=\"center\">\n<a href=\"https://www.youtube.com/watch?v=dcjkezf1ARY\"><img src=\"https://raw.githubusercontent.com/dankamongmen/notcurses/gh-pages/notcurses-logo.png\" alt=\"setting the standard (hype video)\"/></a>\n</p>\n\nfor more information, see [dankwiki](https://nick-black.com/dankwiki/index.php/Notcurses)\nand the [man pages](https://notcurses.com). in addition, there is\n[Doxygen](https://notcurses.com/html/) output. To subscribe to the\n[mailing list](https://groups.google.com/forum/#!forum/notcurses), send an email\nto notcurses+subscribe@googlegroups.com (the email contents don't matter). i wrote a coherent\n[guidebook](https://nick-black.com/htp-notcurses.pdf), which is available for\nfree download (or [paperback purchase](https://amazon.com/dp/B086PNVNC9)).\n\ni've not yet added many documented examples, but [src/poc/](https://github.com/dankamongmen/notcurses/tree/master/src/poc)\nand [src/pocpp/](https://github.com/dankamongmen/notcurses/tree/master/src/pocpp)\ncontain many small C and C++ programs respectively. `notcurses-demo` covers\nmost of the functionality of Notcurses.\n\n**If you're running Notcurses applications in a Docker, please consult\n\"[Environment notes](#environment-notes)\" below.**\n\n<a href=\"https://repology.org/project/notcurses/versions\">\n<img src=\"https://repology.org/badge/vertical-allrepos/notcurses.svg\" alt=\"Packaging status\" align=\"right\">\n</a>\n\n![Linux](https://img.shields.io/badge/-Linux-grey?logo=linux)\n![FreeBSD](https://img.shields.io/badge/-FreeBSD-grey?logo=freebsd)\n![Windows](https://img.shields.io/badge/-Windows-grey?logo=windows)\n![macOS](https://img.shields.io/badge/-macOS-grey?logo=macos)\n\n[![Linux](https://github.com/dankamongmen/notcurses/actions/workflows/ubuntu_test.yml/badge.svg?branch=master)](https://github.com/dankamongmen/notcurses/actions/workflows/ubuntu_test.yml?query=branch%3Amaster)\n[![macOS](https://github.com/dankamongmen/notcurses/actions/workflows/macos_test.yml/badge.svg?branch=master)](https://github.com/dankamongmen/notcurses/actions/workflows/macos_test.yml?query=branch%3Amaster)\n[![Windows](https://github.com/dankamongmen/notcurses/actions/workflows/windows_test.yml/badge.svg?branch=master)](https://github.com/dankamongmen/notcurses/actions/workflows/windows_test.yml?query=branch%3Amaster)\n\n[![pypi_version](https://img.shields.io/pypi/v/notcurses?label=pypi)](https://pypi.org/project/notcurses)\n[![crates.io](https://img.shields.io/crates/v/libnotcurses-sys.svg)](https://crates.io/crates/libnotcurses-sys)\n\n[![Matrix](https://img.shields.io/matrix/notcursesdev:matrix.org?label=matrixchat)](https://app.element.io/#/room/#notcursesdev:matrix.org)\n[![Sponsor](https://img.shields.io/badge/-Sponsor-red?logo=github)](https://github.com/sponsors/dankamongmen)\n\n## Introduction\n\nNotcurses abandons the X/Open Curses API bundled as part of the Single UNIX\nSpecification. For some necessary background, consult Thomas E. Dickey's\nsuperb and authoritative [NCURSES FAQ](https://invisible-island.net/ncurses/ncurses.faq.html#xterm_16MegaColors).\nAs such, Notcurses is not a drop-in Curses replacement.\n\nWherever possible, Notcurses makes use of the Terminfo library shipped with\nNCURSES, benefiting greatly from its portability and thoroughness.\n\nNotcurses opens up advanced functionality for the interactive user on\nworkstations, phones, laptops, and tablets, possibly at the expense of e.g.\nsome industrial and retail terminals. Fundamentally, Curses assumes the minimum\nand allows you (with effort) to step up, whereas Notcurses assumes the maximum\nand steps down (by itself) when necessary. The latter approach probably breaks\non some older hardware, but the former approach results in new software looking\nlike old hardware.\n\nWhy use this non-standard library?\n\n* Thread safety, and efficient use in parallel programs, has been a design\n  consideration from the beginning.\n\n* A more orderly surface than that codified by X/Open: Exported identifiers are\n  prefixed to avoid common namespace collisions. Where reasonable,\n  `static inline` header-only code is used. This facilitates compiler\n  optimizations, and reduces loader time. Notcurses can be built without its\n  multimedia functionality, requiring a significantly lesser set of dependencies.\n\n* All APIs natively support the Universal Character Set (Unicode). The `nccell`\n  API is based around Unicode's [Extended Grapheme Cluster](https://unicode.org/reports/tr29/) concept.\n\n* Visual features including images, fonts, video, high-contrast text, sprites,\n  and transparent regions. All APIs natively support 24-bit color, quantized\n  down as necessary for the terminal.\n\n* Portable support for bitmapped graphics, using Sixel, Kitty,\n  and even the Linux framebuffer console.\n\n* Support for unambiguous [keyboard protocols](https://sw.kovidgoyal.net/kitty/keyboard-protocol/).\n\n* \"TUI mode\" facilitates high-performance, non-scrolling, full-screen\n  applications. \"CLI mode\" supports scrolling output for shell utilities,\n  but with the full power of Notcurses.\n\n* It's Apache2-licensed in its entirety, as opposed to the\n  [drama in several acts](https://invisible-island.net/ncurses/ncurses-license.html)\n  that is the NCURSES license (the latter is [summarized](https://invisible-island.net/ncurses/ncurses-license.html#issues_freer)\n  as \"a restatement of MIT-X11\").\n\nMuch of the above can be had with NCURSES, but they're not what NCURSES was\n*designed* for. On the other hand, if you're targeting industrial or critical\napplications, or wish to benefit from time-tested reliability and\nportability, you should by all means use that fine library.\n\n## Requirements\n\nMinimum versions generally indicate the oldest version I've tested with; it\nmay well be possible to use still older versions. Let me know of any successes!\n\n* (build) CMake 3.14.0+ and a C11 compiler\n* (OPTIONAL) (OpenImageIO, testing, C++ bindings): A C++17 compiler\n* (build+runtime) From [NCURSES](https://invisible-island.net/ncurses/announce.html): terminfo 6.1+\n* (build+runtime) GNU [libunistring](https://www.gnu.org/software/libunistring/) 0.9.10+\n* (OPTIONAL) (build+runtime) [libgpm](https://www.nico.schottelius.org/software/gpm/) 1.20+\n* (OPTIONAL) (build+runtime) From QR-Code-generator: [libqrcodegen](https://github.com/nayuki/QR-Code-generator) 1.5.0+\n* (OPTIONAL) (build+runtime) From [FFmpeg](https://www.ffmpeg.org/): libswscale 5.0+, libavformat 57.0+, libavutil 56.0+, libavdevice 57.0+\n* (OPTIONAL) (build+runtime) [OpenImageIO](https://github.com/OpenImageIO/oiio) 2.15.0+, requires C++\n* (OPTIONAL) (testing) [Doctest](https://github.com/onqtam/doctest) 2.3.5+\n* (OPTIONAL) (documentation) [pandoc](https://pandoc.org/index.html) 1.19.2+\n* (OPTIONAL) (python bindings): Python 3.7+, [CFFI](https://pypi.org/project/cffi/) 1.13.2+, [pypandoc](https://pypi.org/project/pypandoc/) 1.5+\n* (runtime) Linux 2.6+, FreeBSD 11+, DragonFly BSD 5.9+, Windows 10 v1093+, or macOS 11.4+\n\nMore information on building and installation is available in [INSTALL.md](INSTALL.md).\n\n### Wrappers\n\nIf you wish to use a language other than C to work with Notcurses, numerous\nwrappers are available. Several are included in this repository, while\nothers are external.\n\n| Language | Lead(s)                       | Repository |\n| -------- | ----------------------------- | ---------- |\n| Ada      | Jeremy Grosser                | [JeremyGrosser/notcursesada](https://github.com/JeremyGrosser/notcursesada) |\n| C++      | Marek Habersack, nick black   | internal   |\n| Dart     | Nelson Fernandez              | [kascote/dart_notcurses](https://github.com/kascote/dart_notcurses) |\n| Julia    | Dheepak Krishnamurthy         | [kdheepak/Notcurses.jl](https://github.com/kdheepak/Notcurses.jl) |\n| Nim      | Michael S. Bradley, Jr.       | [michaelsbradleyjr/nim-notcurses](https://github.com/michaelsbradleyjr/nim-notcurses) |\n| Python   | nick black                    | internal   |\n| Python   | igo95862                      | internal   |\n| Rust     | José Luis Cruz                | [dankamongmen/libnotcurses-sys](https://github.com/dankamongmen/libnotcurses-sys) |\n| Zig      | Jakub Dundalek                | [dundalek/notcurses-zig-example](https://github.com/dundalek/notcurses-zig-example) |\n\n## Included tools\n\nNine executables are installed as part of Notcurses:\n* `ncls`: an `ls` that displays multimedia in the terminal\n* `ncneofetch`: a [neofetch](https://github.com/dylanaraps/neofetch) ripoff\n* `ncplayer`: renders visual media (images/videos)\n* `nctetris`: a tetris clone\n* `notcurses-demo`: some demonstration code\n* `notcurses-info`: detect and print terminal capabilities/diagnostics\n* `notcurses-input`: decode and print keypresses\n* `notcurses-tester`: unit testing\n* `tfman`: a swank manual browser\n\nTo run `notcurses-demo` from a checkout, provide the `data` directory via\nthe `-p` argument. Demos requiring data files will otherwise abort. The base\ndelay used in `notcurses-demo` can be changed with `-d`, accepting a\nfloating-point multiplier. Values less than 1 will speed up the demo, while\nvalues greater than 1 will slow it down.\n\n`notcurses-tester` likewise requires that `data`, populated with the necessary\ndata files, be specified with `-p`. It can be run by itself, or via `make test`.\n\n## Documentation\n\nWith `-DUSE_PANDOC=on` (the default), a full set of man pages and XHTML\nwill be built from `doc/man`. The following Markdown documentation is included\ndirectly:\n\n* Per-release [News](NEWS.md) for packagers, developers, and users.\n* The `TERM` environment variable and [various terminal emulators](TERMINALS.md).\n* Notes on [contributing](doc/CONTRIBUTING.md) and [hacking](doc/HACKING.md).\n* There's a semi-complete [reference guide](USAGE.md).\n* A list of [other TUI libraries](doc/OTHERS.md).\n* Abbreviated [history](doc/HISTORY.md) and thanks.\n* [Differences from](doc/CURSES.md) Curses and adapting Curses programs.\n\nIf you (understandably) want to avoid the large Pandoc stack, but still enjoy\nmanual pages, I publish a tarball with generated man/XHTML along with\neach release. Download it, and install the contents as you deem fit.\n\n## Environment notes\n\n* If your `TERM` variable is wrong, or that terminfo definition is out-of-date,\n  you're going to have a very bad time. Use *only* `TERM` values appropriate\n  for your terminal. If this variable is undefined, or Notcurses can't load the\n  specified Terminfo entry, it will refuse to start, and you will\n  [not be going to space today](https://xkcd.com/1133/).\n\n* Notcurses queries the terminal on startup, enabling some advanced features\n  based on the determined terminal (and even version). Basic capabilities,\n  however, are taken from Terminfo. So if you have, say, Kitty, but\n  `TERM=vt100`, you're going to be able to draw RGBA bitmap graphics (despite\n  such things being but a dream for a VT100), but *unable* to use the alternate\n  screen (despite it being supported by every Kitty version). So `TERM` and an\n  up-to-date Terminfo database remain important.\n\n* Ensure your `LANG` environment variable is set to a UTF8-encoded locale, and\n  that this locale has been generated. This usually means\n  `\"[language]_[Countrycode].UTF-8\"`, i.e. `en_US.UTF-8`. The first part\n  (`en_US`) ought exist as a directory or symlink in `/usr/share/locales`.\n  This usually requires editing `/etc/locale.gen` and running `locale-gen`.\n  On Debian systems, this can be accomplished with `dpkg-reconfigure locales`,\n  and enabling the desired locale. The default locale is stored somewhere like\n  `/etc/default/locale`.\n\n* If your terminal has an option about default interpretation of \"ambiguous-width\n  characters\" (this is actually a technical term from Unicode), ensure it is\n  set to **Wide**, not narrow (if that doesn't work, ensure it is set to\n  **Narrow**, heh).\n\n* If your terminal supports 3x8bit RGB color via `setaf` and `setbf` (most\n  modern terminals), but exports neither the `RGB` nor `Tc` terminfo capability,\n  you can export the `COLORTERM` environment variable as `truecolor` or `24bit`.\n  Note that some terminals accept a 24-bit specification, but map it down to\n  fewer colors. RGB is unconditionally enabled whenever\n  [most modern terminals](TERMINALS.md) are identified.\n\n### Fonts\n\nGlyph width, and indeed whether a glyph can be displayed at all, is dependent\nin part on the font configuration. Ideally, your font configuration has a\nglyph for every Unicode EGC, and each glyph's width matches up with the POSIX\nfunction's `wcswidth()` result for the EGC. If this is not the case, you'll\nlikely get blanks or � (U+FFFD, REPLACEMENT CHARACTER) for missing characters,\nand subsequent characters on the line may be misplaced.\n\nIt is worth knowing that several terminals draw the block characters directly,\nrather than loading them from a font. This is generally desirable. Quadrants,\nsextants, and octants are not the place to demonstrate your design virtuosity.\nTo inspect your environment's rendering of drawing characters, run\n`notcurses-info`. The desired output ought look something like this:\n\n<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/dankamongmen/notcurses/gh-pages/notcurses-info.png\" alt=\"notcurses-info can be used to check Unicode drawing\"/>\n</p>\n\n## FAQs\n\nIf things break or seem otherwise lackluster, **please** consult the\n[Environment Notes](#environment-notes) section! You **need** correct\n`TERM` and `LANG` definitions, and might want `COLORTERM`.\n\n<details>\n <summary>Can I use Notcurses in my closed-source program?</summary>\n Notcurses is licensed under <a href=\"https://www.apache.org/licenses/LICENSE-2.0\">Apache2</a>,\n a demonstration that I have transcended your petty world of material goods,\n fiat currencies, and closed sources. Implement Microsoft Bob in it. Charge\n rubes for it. Put it in your ballistic missiles so that you have a nice LED\n display of said missile's speed and projected yield; right before impact,\n scroll \"FUCK YOU\" in all the world's languages, and close it out with a smart\n palette fade. Carve the compiled objects onto bricks and mail them to Richard\n Stallman, taunting him through a bullhorn as you do so.\n</details>\n\n<details>\n  <summary>Can I write a CLI program (scrolling, fits in with the shell, etc.)\n   with Notcurses?</summary>\n   Yes! Use the <code>NCOPTION_CLI_MODE</code> flag (an alias for several\n   real flags; see <a href=\"https://notcurses.com/notcurses_init.3.html\"><code>notcurses_init(1)</code></a>\n   for more information). You still must explicitly render.\n</details>\n\n<details>\n  <summary>Can I have Notcurses without this huge multimedia stack?</summary>\n  Again yes! Build with <code>-DUSE_MULTIMEDIA=none</code>.\n</details>\n\n<details>\n  <summary>Can I build this individual Notcurses program without aforementioned\n  multimedia stack?</summary>\n  Almost unbelievably, yes! Use <code>notcurses_core_init()</code> or\n  <code>ncdirect_core_init()</code> in place of <code>notcurses_init()</code>/\n  <code>ncdirect_init()</code>, and link with <code>-lnotcurses-core</code>.\n  Your application will likely start a few milliseconds faster;\n  more importantly, it will link against minimal Notcurses installations.\n</details>\n\n<details>\n  <summary>We're paying by the electron, and have no C++ compiler. Can we still\n  enjoy Notcurses goodness?</summary>\n  Some of it! You won't be able to build several executables, nor the NCPP C++\n  wrappers, nor can you build with the OpenImageIO multimedia backend (OIIO\n  ships C++ headers). You'll be able to build the main library, though, as\n  well as <code>notcurses-demo</code> (and maybe a few other programs).\n  Use <code>-DUSE_CXX=off</code>.\n</details>\n\n<details>\n  <summary>Do I want ffmpeg or OpenImageIO?</summary>\n  While OpenImageIO is a superb library for dealing with single-frame images,\n  its video support is less than perfect (blame me; I've been promising Larry\n  I'd rewrite it for several months), and in any case implemented\n  atop...ffmpeg. ffmpeg is the preferred multimedia backend.\n</details>\n\n<details>\n  <summary>Does it work with hardware terminals?</summary>\n  With the correct <code>TERM</code> value, many hardware terminals are\n  supported. In general, if the terminfo database entry indicates mandatory\n  delays, Notcurses will not currently support that terminal properly. It's\n  known that Notcurses can drive the VT320 and VT340, including Sixel graphics\n  on the latter.\n</details>\n\n<details>\n  <summary>What happens if I try blitting bitmap graphics on a terminal which\n  doesn't support them?</summary>\n  Notcurses will not make use of bitmap protocols unless the terminal positively\n  indicates support for them, even if <code>NCBLIT_PIXEL</code> has been\n  requested. Likewise, sextants (<code>NCBLIT_3x2</code>) won't be used without\n  Unicode 13 support, octants (<code>NCBLIT_4x2</code>) won't be used without\n  Unicode 16 support, etc. <code>ncvisual_blit()</code> will use the best blitter\n  available, unless <code>NCVISUAL_OPTION_NODEGRADE</code> is provided (in\n  which case it will fail).\n</details>\n\n<details>\n  <summary>Notcurses looks like absolute crap in <code>screen</code>.</summary>\n  <code>screen</code> doesn't support RGB colors (at least as of 4.08.00);\n  if you have <code>COLORTERM</code> defined, you'll have a bad time.\n    If you have a <code>screen</code> that was compiled with\n    <code>--enable-colors256</code>, try exporting\n    <code>TERM=screen-256color</code> as opposed to <code>TERM=screen</code>.\n</details>\n\n<details>\n  <summary>Notcurses looks like absolute crap in <code>mosh</code>.</summary>\n  Yeah it sure does. I'm not yet sure what's up.\n</details>\n\n<details>\n  <summary>Notcurses looks like absolute crap in Windows Terminal.</summary>\n  Go to <a href=\"ms-settings:regionlanguage\">Language Setting</a>, click\n  \"Administrative language settings\", click \"Change system locale\", and check\n  the \"Beta: Use Unicode UTF-8 for worldwide language support\" option. Restart\n  the computer. That ought help a little bit. Try playing with fonts—Cascadia\n  Code and Cascadia Mono both seem to work well (quadrants and Braille both\n  work), whereas Consolas and Courier New both have definite problems.\n</details>\n\n<details>\n  <summary>I'm getting strange and/or duplicate inputs in Kitty/foot.</summary>\n  Notcurses supports Kitty's powerful\n  <a href=\"https://sw.kovidgoyal.net/kitty/keyboard-protocol/\">keyboard protocol</a>,\n  which includes things like key release events and modifier keypresses by\n  themselves. This means, among other things, that a program in these terminals\n  will usually immediately get an <code>NC_ENTER</code> <code>NCTYPE_RELEASE</code>\n  event, and each keypress will typically result in at least two inputs.\n</details>\n\n<details>\n  <summary>Why didn't you just render everything to bitmaps?</summary>\n  That's not a TUI; it's a slow and inflexible GUI. Many terminal emulators\n  don't support bitmaps. They doesn't work well with mouse selection.\n  Sixels have a limited color palette. With that said, both Sixel and the\n  Kitty bitmap protocol are well-supported.\n</details>\n\n<details>\n  <summary>My multithreaded program doesn't see <code>NCKEY_RESIZE</code> until\n  I press some other key.</summary>\n  You've almost certainly failed to mask <code>SIGWINCH</code> in some thread,\n  and that thread is receiving the signal instead of the thread which called\n  <code>notcurses_getc_blocking()</code>. As a result, the <code>poll()</code>\n  is not interrupted. Call <code>pthread_sigmask()</code> before spawning any\n  threads.\n</details>\n\n<details>\n  <summary>Using the C++ wrapper, how can I ensure that the <code>NotCurses</code>\n  destructor is run when I return from <code>main()</code>?</summary>\n  As noted in the\n  <a href=\"https://isocpp.org/wiki/faq/dtors#artificial-block-to-control-lifetimes\">\n  C++ FAQ</a>, wrap it in an artificial scope (this assumes your\n  <code>NotCurses</code> is scoped to <code>main()</code>).\n</details>\n\n<details>\n  <summary>How do I hide a plane I want to make visible later?</summary>\n  In order of least to most performant: move it offscreen using\n  <code>ncplane_move_yx()</code>, move it underneath an opaque plane with\n  <code>ncplane_move_below()</code>, or move it off-pile with\n  <code>ncplane_reparent()</code>.\n</details>\n\n<details>\n  <summary>Why isn't there an <code>ncplane_box_yx()</code>? Do you hate\n  orthogonality, you dullard?</summary> <code>ncplane_box()</code> and friends\n  already have far too many arguments, you monster.\n</details>\n\n<details>\n  <summary>Why doesn't Notcurses support 10- or 16-bit color?</summary>\n  Notcurses supports 24 bits of color, spread across three eight-bit channels.\n  You presumably mean 10-bit-per-channel color. I needed those six bits for\n  other things. When terminals support it, Notcurses might support it.\n</details>\n\n<details>\n  <summary>The name is dumb.</summary>\n  That's not a question?\n</details>\n\n<details>\n  <summary>I'm not finding qrcodegen on BSD, despite having installed\n  <code>graphics/qr-code-generator</code>.</summary>\n  Try <code>cmake -DCMAKE_REQUIRED_INCLUDES=/usr/local/include</code>.\n  This is passed by <code>bsd.port.mk</code>.\n</details>\n\n<details>\n  <summary>Do you support <a href=\"https://musl.libc.org/\">musl</a>?</summary>\n  I try to! You'll need at least 1.20.\n</details>\n\n<details>\n  <summary>I only seem to blit in ASCII, and/or can't emit Unicode beyond ASCII\n  in general.</summary>\n  Your <code>LANG</code> environment variable is underdefined or incorrectly\n  defined, or the necessary locale is not present on your machine (it is also\n  possible that you explicitly supplied <code>NCOPTION_INHIBIT_SETLOCALE</code>,\n  but never called <code>setlocale(3)</code>, in which case don't do that).\n</details>\n\n<details>\n  <summary>I pretty much always need an <code>ncplane</code> when using a\n  <code>nccell</code>. Why doesn't the latter hold a pointer to the former?\n  </summary>\n  Besides the massive redundancy this would entail, <code>nccell</code> needs to\n  remain as small as possible, and you almost always have the <code>ncplane</code>\n  handy if you've got a reference to a valid <code>nccell</code> anyway.\n</details>\n\n<details>\n <summary>I ran my Notcurses program under <code>valgrind</code>/ASAN, and\n    it shows memory leaks from <code>libtinfo.so</code>, what's up with that?</summary>\n  Yeah, the NCURSES Terminfo leaks memory unless compiled a special,\n  non-standard way (see the NCURSES FAQ). It shouldn't be a substantial amount;\n  you're advised not to worry overmuch about it.\n</details>\n\n<details>\n  <summary>I ran <code>notcurses-demo</code>, but my table numbers don't match\n  the Notcurses banner numbers, you charlatan.</summary>\n  <code>notcurses-demo</code> renders several frames beyond the actual demos.\n</details>\n\n<details>\n  <summary>When my program exits, I don't have a cursor, or text is invisible,\n  or colors are weird, <i>ad nauseam</i>.</summary>\n  Ensure you're calling <code>notcurses_stop()</code>/<code>ncdirect_stop()</code>\n  on all exit paths, including fatal signals (note that, by default, Notcurses\n  installs handlers for most fatal signals to do exactly this).\n</details>\n\n<details>\n  <summary>How can I use Direct Mode in conjunction with libreadline?</summary>\n  You can't anymore (you could up until 2.4.1, but the new input system is\n  fundamentally incompatible with it). <code>ncdirect_readline()</code> still exists,\n  though, and now actually works even without libreadline, though it is of\n  course not exactly libreadline. In any case, you'd probably be better off\n  using CLI mode with a <code>ncreader</code>.\n</details>\n\n<details>\n  <summary>So is Direct Mode deprecated or what?</summary>\n  It is not currently deprecated, and definitely receives bugfixes. You are\n  probably better served using CLI mode (see above), which came about\n  somewhat late in Notcurses development (the 2.3.x series), but is superior\n  to Direct Mode in pretty much every way. The only reason to use Direct\n  Mode is if you're going to have other programs junking up your display.\n</details>\n\n<details>\n  <summary>Direct Mode sounds fast! Since it's, like, direct.</summary>\n  Direct mode is <i>substantially slower</i> than rendered mode. Rendered\n  mode assumes it knows what's on the screen, and uses this information to\n  generate optimized sequences of escapes and glyphs. Direct mode writes\n  everything it's told to write. It is furthermore far less capable—all\n  widgets etc. are available only to rendered mode, and will definitely\n  not be extended to Direct Mode.\n</details>\n\n<details>\n  <summary>Will there ever be Java wrappers?</summary>\n  I should hope not. If you want a Java solution, try @klamonte's\n  <a href=\"https://jexer.sourceforge.io/\">Jexer</a>. Autumn's a good\n  woman, and thorough. We seem to have neatly partitioned the language\n  space.\n</details>\n\n<details>\n  <summary>Given that the glyph channel is initialized as transparent for a\n  plane, shouldn't the foreground and background be initialized as transparent,\n  also?</summary>\n  Probably (they are instead by default initialized to opaque). This would change\n  some of the most longstanding behavior of Notcurses, though,\n  so it isn't happening.\n</details>\n\n<details>\n  <summary>I get linker errors when statically linking.</summary>\n  Are you linking all necessary libraries? Use\n  <code>pkg-config --static --libs notcurses</code>\n  (or <code>--libs notcurses-core</code>) to discover them.\n</details>\n\n<details>\n  <summary>Notcurses exits immediately in MSYS2/Cygwin.</summary>\n  Notcurses requires the\n  <a href=\"https://devblogs.microsoft.com/commandline/windows-command-line-introducing-the-windows-pseudo-console-conpty/\">Windows ConPTY</a>\n  layer. This is available in Cygwin by default since 3.2.0, but is disabled\n  by default in MSYS. Launch <code>mintty</code> with <code>-P on</code>\n  arguments, or export <code>MSYS=enable_pcon</code> before launching it.\n</details>\n\n<details>\n  <summary>Can I avoid manually exporting <code>COLORTERM=24bit</code>\n  everywhere?</summary>\n  Sure. Add <code>SendEnv COLORTERM</code> to <code>.ssh/config</code>, and\n  <code>AcceptEnv COLORTERM</code> to <code>sshd_config</code> on the remote\n  server. Yes, this will probably require root on the remote server.\n  Don't blame me, man; I didn't do it.\n</details>\n\n<details>\n  <summary>How about <i>arbitrary image manipulation here</i> functionality?</summary>\n  I'm not going to beat ImageMagick et al. on image manipulation, but you can\n  load an <code>ncvisual</code> from RGBA memory using\n  <code>ncvisual_from_rgba()</code>.\n</details>\n\n<details>\n  <summary>My program locks up during initialization. </summary>\n  Notcurses interrogates the terminal. If the terminal doesn't reply to standard\n  interrogations, file a Notcurses bug, send upstream a patch, or use a different\n  terminal. No known terminal emulators exhibit this behavior.\n</details>\n\n<details>\n  <summary>How can I draw a large plane, and only make a portion of it visible?</summary>\n  The simplest way is probably to create a plane of the same dimensions immediately above\n  the plane, and keep a region of it transparent, and the rest opaque. If you want the visible\n  area to stay in the same place on the display, but the portion being seen to change, try\n  making a plane twice as large in each dimension as the original plane. Make the desired area\n  transparent, and the rest opaque. Now move the original plane behind this plane so that the\n  desired area lines up with the &ldquo;hole&rdquo;.\n</details>\n\n<details>\n  <summary>Why no <code>NCSTYLE_REVERSE</code>?</summary>\n  It would consume a precious bit. You can use <code>ncchannels_reverse()</code>\n  to correctly invert fore- and background colors.\n</details>\n\n<details>\n  <summary>How do I mix Rendered and Direct mode?</summary>\n  You really don't want to. You can stream a subprocess to a plane with the\n  <code>ncsubproc</code> widget.\n</details>\n\n<details>\n  <summary>How can I clear the screen on startup in Rendered mode when not using\n  the alternate screen?</summary>\n  Call <code>notcurses_refresh()</code> after <code>notcurses_init()</code>\n  returns successfully.\n</details>\n\n<details>\n  <summary>Why do the stats show more Linux framebuffer bitmap bytes written\n  than total bytes written to the terminal? And why don't Linux console\n  graphics work when I ssh?</summary>\n  Linux framebuffer graphics aren't implemented via terminal writes, but rather\n  writes directly into a memory map. This memory map isn't available on remote\n  machines, and these writes aren't tracked by the standard statistics.\n</details>\n\n<details>\n <summary>What is the possessive form of Notcurses?</summary>\n <b>Notcurses'.</b> I cite <a href=\"https://en.wikipedia.org/wiki/Garner%27s_Modern_English_Usage\">\n Garner's Modern English Usage</a> in its third edition: \"<b>POSSESSIVES. A. Singular\n Possessives.</b>…Biblical and Classical names that end with a /zəs/ or /eez/\n sound take only the apostrophe.\" Some ask: is Notcurses then Biblical, or is it\n Classical? Truly, it is both.\n</details>\n\n<details>\n  <summary>I just want to display a bitmap on my terminal. Your library is\n  complex and stupid. You are simple and stupid.</summary>\n  If you're willing to call a binary, use <tt>ncplayer</tt> to put an image,\n  with desired scaling, anywhere on the screen and call it a day. Otherwise,\n  call <tt>notcurses_init()</tt>, <tt>ncvisual_from_file()</tt>,\n  <tt>ncvisual_blit()</tt>, <tt>notcurses_render()</tt>, and\n  <tt>notcurses_stop()</tt>. It's not too tough. And thanks—your thoughtful\n  comments and appreciative tone are why I work on Free Software.\n</details>\n\n## Useful links\n\n* [BiDi in Terminal Emulators](https://terminal-wg.pages.freedesktop.org/bidi/)\n* [The Xterm FAQ](https://invisible-island.net/xterm/xterm.faq.html)\n  * [XTerm Control Sequences](https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf)\n* [The NCURSES FAQ](https://invisible-island.net/ncurses/ncurses.faq.html)\n* [ECMA-35 Character Code Structure and Extension Techniques](https://www.ecma-international.org/publications/standards/Ecma-035.htm) (ISO/IEC 2022)\n* [ECMA-43 8-bit Coded Character Set Structure and Rules](https://www.ecma-international.org/publications/standards/Ecma-043.htm)\n* [ECMA-48 Control Functions for Coded Character Sets](https://www.ecma-international.org/publications/standards/Ecma-048.htm) (ISO/IEC 6429)\n* [Unicode 14.0 Full Emoji List](https://unicode.org/emoji/charts/full-emoji-list.html)\n* [Unicode Standard Annex #29 Text Segmentation](http://www.unicode.org/reports/tr29)\n* [Unicode Standard Annex #15 Normalization Forms](https://unicode.org/reports/tr15/)\n* [mintty tips](https://github.com/mintty/mintty/wiki/Tips)\n* [The TTY demystified](http://www.linusakesson.net/programming/tty/)\n* [Dark Corners of Unicode](https://eev.ee/blog/2015/09/12/dark-corners-of-unicode/)\n* [UTF-8 Decoder Capability and Stress Test](https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt)\n* [Emoji: how do you get from U+1F355 to 🍕?](https://meowni.ca/posts/emoji-emoji-emoji/)\n* [Glyph Hell: An introduction to glyphs, as used and defined in the FreeType engine](http://chanae.walon.org/pub/ttf/ttf_glyphs.htm)\n* [Text Rendering Hates You](https://gankra.github.io/blah/text-hates-you/)\n* [Use the UTF-8 code page](https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page)\n* My wiki's [Sixel page](https://nick-black.com/dankwiki/index.php?title=Sixel) and Kitty's [extensions](https://sw.kovidgoyal.net/kitty/protocol-extensions.html).\n* Linux man pages: [console_codes(4)](http://man7.org/linux/man-pages/man4/console_codes.4.html), [termios(3)](http://man7.org/linux/man-pages/man3/termios.3.html), [ioctl_tty(2)](http://man7.org/linux/man-pages/man2/ioctl_tty.2.html), [ioctl_console(2)](http://man7.org/linux/man-pages/man2/ioctl_console.2.html)\n* The Microsoft Windows [Console Reference](https://docs.microsoft.com/en-us/windows/console/console-reference)\n* NCURSES man pages: [terminfo(5)](http://man7.org/linux/man-pages/man5/terminfo.5.html), [user_caps(5)](http://man7.org/linux/man-pages/man5/user_caps.5.html)\n\n> “Our fine arts were developed, their types and uses were established, in times\nvery different from the present, by men whose power of action upon things was\ninsignificant in comparison with ours. But the amazing growth of our\ntechniques, the adaptability and precision they have attained, the ideas and\nhabits they are creating, make it a certainty that _profound changes are\nimpending in the ancient craft of the Beautiful_.” —Paul Valéry\n"
        },
        {
          "name": "TERMINALS.md",
          "type": "blob",
          "size": 19.201171875,
          "content": "# Terminals\n\nNotcurses attempts to provide an abstraction layer over the highly varied\nworld of terminals. First and foremost, Notcurses needs to know the terminal\non which it is running, so that has an accurate understanding of its\ncapabilities.\n\nIt is of course possible that Notcurses is not connected to an actual\nterminal (e.g. when running daemonized). In such a case, many escapes\nwill not be emitted, and no querying is performed.\n\nNotcurses determines terminal capabilities via a combination of (more-or-less)\nstandardized queries sent to the terminal, the `TERM` environment variable\nused by `terminfo(5)`, and the `COLORTERM` environment variable.\n\n## Queries\n\nAt startup, the Linux console is identified via `ioctl(2)`s specific it.\nOtherwise, if it is determined that the process is connected to a terminal\n(see `isatty(3)`), Notcurses writes a series of queries to it. Several are\nrelated to terminal identification:\n\n* Send Tertiary Device Attributes (`CSI = c`)\n  * Identifies VTE and foot\n* Send Secondary Device Attributes (`CSI > c`)\n  * Identifies Alacritty's version number\n* `XTVERSION` (`CSI > 0 q`)\n  * Identifies XTerm, WezTerm, and Contour\n* `XTGETTCAP` for the `TN` key (`DCS + q 544e ST`)\n  * Identifies Kitty and MLterm\n* Send Primary Device Attributes (`CSI c`)\n\nNo terminals requiring special handling identify themselves via Primary Device\nAttributes, but we send this because all known terminals respond to it with\n*something*, preventing us from hanging, waiting for input (**if a terminal does\n*not* reply in a recognizable way to Primary Device Attributes,\n`notcurses_init()` will hang**).\n\nEven if the terminal responds unambiguously to one of these queries, Notcurses\nmust have code to recognize the response, and bind it to some terminal\ndefinition. Assuming the terminal to be thus identified, Notcurses enables or\ndisables certain capabilities based on built-in knowledge.\n\nTerminal.App exports `TERM_PROGRAM=Apple_Terminal`.\n\n## The `COLORTERM` environment variable\n\n24-bit RGB for glyphs and cell backgrounds is fairly widely implemented. In\nthe Terminfo database, this is indicated via the `rgb` capability. It is\nnot uncommon for this capability to not be expressed, despite support being\npresent. Defining the `COLORTERM` environment variable with the value `24bit`\nwill instruct Notcurses to issue RGB sequences regardless.\n\n## Terminfo and `TERM`\n\nEven if the terminal is unambiguously determined via query, many capabilities\nare acquired from the `terminfo(5)` database, keyed by the `TERM` environment\nvariable. It is critical that the `TERM` environment variable be correct for\nyour shell, and that the terminfo database entry keyed by this variable be\nup-to-date.\n\nThe following have been established on a Debian Unstable workstation.\n`ccc` is the Terminfo can-change-colors capability. \"Blocks\" refers to whether\nthe terminal provides its own implementation of block-drawing characters, or\nrelies on the font. Patches to correct/complete this table are very welcome!\n\n| Terminal        | Pixel `TIOCGWINSZ` | `ccc` | Blocks | Recommended environment           | Notes |\n| --------------- | ------------------ | ----- | ------ | -----------------------           | ----- |\n| [Alacritty](https://github.com/alacritty/alacritty)       | ✅         |  ✅   |❌      |`TERM=alacritty` `COLORTERM=24bit` | [Sixel support WIP](https://github.com/ayosec/alacritty/tree/graphics) |\n| [cool-retro-term](https://github.com/Swordfish90/cool-retro-term) | ❌ | ❌ |✅ | `TERM=xterm-256color` `COLORTERM=24bit` | Accepts RGB. No `initc` despite claiming to be XTerm. |\n| [Contour](https://github.com/christianparpart/contour)    | ✅         |  ✅   |✅       |`TERM=contour`             | Sixel support.             |\n| [Darktile](https://github.com/liamg/darktile) | ? | ? | ? | `TERM=xterm-256color` | ? |\n| [ETerm](https://github.com/mej/Eterm) | | | | `TERM=Eterm` | Doesn't reply to Send Device Attributes |\n| [FBterm](https://github.com/zhangyuanwei/fbterm)  | ❌                 |  ?    |?       |`TERM=fbterm`                      | 256 colors, no RGB color. |\n| [foot](https://codeberg.org/dnkl/foot)            | ✅                 |  ✅   |✅      |`TERM=foot`                        | Sixel support. |\n| [Ghostty](https://github.com/ghostty-org/ghostty) | ? | ? | ? | ? | |\n| [Gnome Terminal](https://gitlab.gnome.org/GNOME/gnome-terminal)  |❌   |  ❌   |✅      |`TERM=gnome` `COLORTERM=24bit`     | `ccc` support *is* available when run with `vte-256color`. |\n| [Guake](https://github.com/Guake/guake)           |                    |  ?    |?       |                                   | |\n| [iTerm2](https://github.com/gnachman/iTerm2)      | ✅  |  ✅   |✅    |`TERM=iterm2`  | |\n| [Kitty](https://github.com/kovidgoyal/kitty)      | ✅  |  ✅   |✅    |`TERM=xterm-kitty`                 | See below. |\n| [kmscon](https://github.com/dvdhrm/kmscon)        | | ❌    | ❌      |`TERM=xterm-256color`              | No RGB color AFAICT, nor any distinct terminfo entry. No actual `ccc` implementation. Sets `COLORTERM=kmscon`.|\n| [Konsole](https://invent.kde.org/utilities/konsole) | ❌       |  ❌   |?       |`TERM=konsole-direct`              | |\n| Linux console   | ❌                 |  ✅   |see [below](#the-linux-console) |`TERM=linux` `COLORTERM=24bit`   | 8 (512 glyph fonts) or 16 (256 glyph fonts) colors max, but RGB values are downsampled to a 256-index palette. See below. |\n| [mintty](https://github.com/mintty/mintty) | ✅ | ✅ | ? | `TERM=mintty-direct` | Windows, both old-skool and ConPTY |\n| [mlterm](https://github.com/arakiken/mlterm)          | ✅                 |  ❌   |?       |`TERM=mlterm-256color`           | Do not set `COLORTERM`. `mlterm-direct` gives strange results. |\n| [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)           |                    |  ❌   |❌      |`TERM=putty-256color` `COLORTERM=24bit` | |\n| [refterm](https://github.com/cmuratori/refterm.git) | ? | ? | ? | ? | Windows, ConPTY only |\n| rxvt            | ✅                 |  ?    |?       |                                 | Seems unmaintained; many forks exist. |\n| [Sakura](https://github.com/dabisu/sakura)          | ✅                 |  ✅   |?       |`TERM=vte-256color` `COLORTERM=24bit` | VTE-derived, no terminfo entry. |\n| [GNU Screen](https://www.gnu.org/software/screen/)      | ✅                 |  ❌   |n/a     |`TERM=screen.OLDTERM`            | Must be compiled with `--enable-256color`. `TERM` should typically be `screen.` suffixed by the appropriate `TERM` value for the true connected terminal, e.g. `screen.vte-256color`. See below. |\n| [st (\"suckless\")](https://st.suckless.org/) | ✅                 |  ✅   |?       |`TERM=st-256color` `COLORTERM=24bit` | Many features are maintained as external patches; users often roll their own instance, composing from these patches. |\n| [Tabby](https://github.com/Eugeny/tabby) | ? | ? | ? | ? | |\n| [Terminal.app](https://en.wikipedia.org/wiki/Terminal_(macOS)) | ✅ | ❌ | ❌ | `TERM=xterm-256color`| No RGB; no `ccc` despite wanting `xterm-256color`. |\n| [Terminator](https://github.com/software-jessies-org/jessies/wiki/Terminatorhttps://github.com/software-jessies-org/jessies/wiki/Terminator)      | ✅                 |  ?    |?       | ?                               | |\n| [Terminology](https://github.com/borisfaure/terminology)     | ❌                 |  ❌   |✅       | `TERM=terminology`              | Identified via DA3 before XTVERSION. 256 colors, no RGB. |\n| [Tilda](https://github.com/lanoxx/tilda)  |       |  ?    |?       | ?                               | |\n| [tmux](https://github.com/tmux/tmux/wiki) | ✅    |  ❌   |n/a     |`TERM=tmux-256color` `COLORTERM=24bit`| `tmux.conf` must apply `Tc`; see below. `bce` is available with the `tmux-256color-bce` definition. |\n| [WezTerm](https://github.com/wez/wezterm) | ✅    |  ✅   |?       |`TERM=wezterm` `COLORTERM=24bit` | See below. |\n| [Windows Terminal](https://github.com/microsoft/terminal)|                    |  ?    |?       | `TERM=ms-terminal` `COLORTERM=24bit` | Nice [escape docs](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences).|\n| [wterm](https://github.com/majestrate/wterm)           |                    |  ?    |?       | ?                               | |\n| [XFCE4 Terminal](https://gitlab.xfce.org/apps/xfce4-terminal)  | ❌                 |  ✅   |✅      |`TERM=xfce` `COLORTERM=24bit`    | No `xfce-direct` variant exists. |\n| [XTerm](https://invisible-island.net/xterm/xterm.html)           | ✅                 |  ?    |❌      |`TERM=xterm+256color2` `COLORTERM=24bit` | See note about DirectColor. Must configure with `--enable-direct-color`. `TERM=xterm-direct` seems to have the undesirable effect of mapping low RGB values to a palette; I don't yet understand this well. The problem is not seen with the specified configuration. Sixel support when built with `--enable-sixel-graphics` and run in vt340 mode. |\n| [Yakuake](https://github.com/KDE/yakuake)         |                    |  ?    |?       | ?                               | |\n\nNote that `xfce4-terminal`, `gnome-terminal`, etc. are essentially skinning\natop the common GNOME [VTE (\"Virtual TErminal\")](https://gitlab.gnome.org/GNOME/vte) library.\n\n### XTerm\n\nXTerm is extensively configurable. I recommend the following settings, assuming\na compatible build:\n\n```\nxterm*directColor: true\nXTerm*allowTcapOps: true\nXTerm*disallowedTcapOps:\nXTerm*decGraphicsID: 340\nXTerm*decTerminalID: 420\nXTerm*numColorRegisters: 256\nXTerm*sixelScrolling: true\n```\n\n### Kitty\n\nKitty has some interesting, atypical behaviors. Foremost among these is that\nan RGB background color equivalent to the configured default background color\nwill be rendered as the default background. This means, for instance, that if\nthe configured default background color is RGB(0, 0, 0), and is translucent,\na background of RGB(0, 0, 0) will be translucent. To work around this, we\ndetect the default background color if possible, and when we have done so *and*\nverified that the terminal is Kitty *and* we would write this as RGB, we alter\none of the colors by 1. See https://github.com/kovidgoyal/kitty/issues/3185 and\nhttps://github.com/dankamongmen/notcurses/issues/1117.\n\nKitty is furthermore the only terminal I know to lack the `bce` (Background\nColor Erase) capability, but Notcurses never relies on `bce` behavior, and\ngoes to some lengths to avoid triggering it.\n\nKitty has introduced an unambiguous [keyboard protocol](https://sw.kovidgoyal.net/kitty/keyboard-protocol/).\nNotcurses supports this protocol when it is detected.\n\nThe Kitty [graphics protocol](https://sw.kovidgoyal.net/kitty/graphics-protocol/)\nis superior in just about every way (save breadth of support) to Sixel.\n\n### WezTerm\n\nWezTerm [implements](https://wezfurlong.org/wezterm/escape-sequences.html) some\ninteresting underline options, and both the Sixel and Kitty graphic protocols\n(I think it even handles iTerm2).\n\n### GNU screen\n\nGNU screen does have 24-bit color support, but only in the 5.X series. Note\nthat many distributions ship screen 4.X as of 2020. When built with truecolor\nsupport, add `truecolor on` to your `screenrc`, or run it with `--truecolor`.\nAttempting to force RGB color in screen 4.X **will not work**.\n\nAdd `defutf8 on` to your `screenrc`, or run screen with `-U`, to ensure UTF-8.\n\n### tmux\n\n`tmux` supports 24-bit color through its `Tc` (Truecolor) extension. You'll\nneed an entry in `tmux.conf` of the form:\n\n`set -ga terminal-overrides \",EXTERNALTERM:Tc\"`\n\nWhere `EXTERNALTERM` is your `TERM` variable at the time of attachment, e.g.:\n\n`set -ga terminal-overrides \",vte-256color:Tc\"`\n\nYou'll then need `COLORTERM=24bit` defined within your tmux environment.\n\n### iTerm2\n\nYou're recommended to change \"Report terminal type\" to `iterm2`.\n\nYou're recommended to enable \"Use Unicode version 9+ widths\" under\n`Profiles/Text`.\n\nYou're recommended to enable the following \"Experimental Features\":\n* REP (Repeat previous character)\n* Support variation selector 16 making emoji fullwidth\n\n### mintty\n\nYou're recommended to change the default `TERM` to `mintty-direct`.\n\n### Putty\n\nOf the fonts present on Putty 0.76, \"Cascadia Mono 10 Regular\" is\nfar superior to the default \"Courier New 10\". The latter doesn't\nsupport quadrants, and thus the quadblitter and sexblitter are\nunavailable on Putty. I recommend setting \"ClearType\" under\n\"Appearance→Font Quality\".\n\nBe sure \"UTF-8\" is set under \"Remote character set\".\n\nDirectColor is available so long as \"Allow terminal to use 24-bit color\"\nis checked under \"Appearance→Colours\". Ensure \"Allow terminal to specify\nANSI colours\" and \"Allow terminal to use xterm 256-colour mode\" are also\nchecked.\n\n### The Linux console\n\nThe Linux console supports concurrent virtual terminals, and is manipulated\nby userspace via `ioctl()`s. These `ioctl()`s generally fail when applied to\na pseudotty device, as will happen if e.g. invoked upon one's controlling\nterminal whilst running in a terminal emulator under X (it is still generally\npossible to use them by explicitly specifying a console device, i.e.\n`showconsolefont -C /dev/tty0`).\n\nThe VGA text console requires the kernel option `CONFIG_VGA_CONSOLE`. A\nframebuffer console for VESA 2.0 is provided by `CONFIG_FB_VESA`, while\nUEFI-compatible systems can use `CONFIG_FB_EFI`. So long as a framebuffer\ndriver is present, `CONFIG_FRAMEBUFFER_CONSOLE` will enable a graphics-mode\nconsole using the framebuffer device.\n\nThe Linux console can be in either text or graphics mode. The mode can be\ndetermined with the `KDGETMODE` `ioctl()`, and changed with `KDSETMODE`,\nusing the constants `KD_TEXT` and `KD_GRAPHICS`. Text mode supports a\nrectangular matrix of multipixel cells, filled with glyphs from a font,\na foreground color, and a background color. Graphics (\"All-Points-Addressable\")\nmode supports a rectangular matrix of pixels, each with a single color.\nNote that both modes require appropriate hardware support (and kernel\nconfiguration options), and might or might not be available on a given\ninstallation. Non-x86 platforms often provide only a framebuffer (graphics)\nconsole.\n\nThe kernel text mode loosely corresponds to the 1987 IBM VGA definition. At any\ntime, the display is configured with a monospace raster font, a palette, and\n(when in Unicode mode) a mapping from multibyte sequences to font elements. Up\nto 16 colors can be used with a font of 256 glyphs or fewer. Only 8 colors can\nbe used with fonts having more than 256 glyphs; the maximum font size in any\nconfiguration is 512 glyphs. The keyboard is further configured with a keymap,\nmapping keyboard scancodes to elements of the character set. These properties\nare per-virtual console, not common to all of them. These limitations are not\ntypically present on framebuffer consoles.\n\nExporting `COLORTERM=24bit` and emitting RGB escapes to the Linux console\n**does** work, though the RGB values provided are downsampled to a 256-slot\npalette. Backgrounds don't seem to have the same degree of flexibility in this\nsituation as do foregrounds. The output is better, but not as much better as\none might expect. More research is necessary here.\n\nThe following more-or-less standard tools exist:\n* `showconsolefont`: show the console font\n* `setfont`: load console font\n* `fbset`: show and modify framebuffer settings\n* `fgconsole`: print name of foreground terminal\n* `chvt`: change the foreground terminal\n* `deallocvt`: destroy a virtual console\n* `dumpkeys`: print all keycodes\n* `loadkeys`: load scancode/keycode mapping (the keymap)\n* `setkeycodes`: load scancode/keycode mappings one at a time\n* `showkeys`: interactively print scancodes\n* `kbd_mode`: show or set the keyboard mode\n\nBoth `mapscrn` and `loadunimap` are obsolete; their functionality is present\nin `setfont`.\n\nNote that Notcurses reprograms the console font table when running in the\nLinux console (unless `NCOPTION_NO_FONT_CHANGES` is used). This adds support\nfor half blocks and quadrants.\n\n### Windows Terminal\n\nEnsure UTF-8 is being used for \"Administrative language settings\"\n(see [README.md](README.md)). Codepage 65001 ought be used.\n\nThe Cascadia Code and Cascadia Mono fonts seem to work noticeably better\nthan Consolas or Courier New, both of which have trouble with quadrants\nand Braille.\n\n### 24-bit RGB\n\nMany terminals support one or another form of non-indexed color encoding (also\nknown as DirectColor, RGB color, 24-bit color, or the similar but distinct\nTrueColor), using either the semicolon-based presentation introduced by Konsole\nor the colon-delimited presentation specified in ECMA-48 and ITU T.416. The\n`rgb` termcap capability indicates support for such encodings via the\n`set_a_foreground` and `set_b_foreground` capabilities. Not all terminals\nimplementing `rgb` use the 3x8bpc model; XTerm for instance:\n\n> for values 0 through 7, it uses the “ANSI” control sequences, while\n> for other values, it uses the 3-byte direct-color sequence introduced by Konsole.\n> the number of colors is 224 while the number of color pairs is 216\n\nThus emitting `setaf` with an RGB value close to black can result, when\nusing `xterm-direct`'s `setaf` and `rgb` definitions, in a bright ANSI color.\n\n24-bit RGB is always enabled for Kitty, Alacritty, Contour, WezTerm, iTerm2,\nand foot.\n\n### Problematic characters\n\nSome characters seem to cause problems with one terminal or another. These\nare best avoided until the problems are better understood:\n\n* '­' U+00AD SOFT HYPHEN (some terminals allocate it a cell, some don't)\n* '܏' U+070F [SYRIAC ABBREVIATION MARK](https://en.wikipedia.org/wiki/Syriac_Abbreviation_Mark): puts an\n  overbar above following characters until a non-Syriac character is found.\n* '۝' U+06DD[ARABIC END OF AYAH](https://scriptsource.org/cms/scripts/page.php?item_id=character_detail_des&key=U0006DD):\n   bound to up to three digits, which ought be drawn inside.\n* '࣢' U+08E2 ARABIC DISPUTED END OF AYAH\n* '﷽' U+FDFD ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM\n* '⁄' U+2044 [FRACTION SLASH](https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Fraction_slash)\n   bound to digits fore and aft\n\n## Notes for terminal authors\n\nThe `notcurses-info` tool built as part of Notcurses can be used to inspect\nhow well your terminal supports Notcurses. It is generally desirable that your\nterminal:\n\n* implements `XTVERSION` (no matter your personal philosophical stance).\n* implements `XTGETTCAP` (especially for the `rgb` capability).\n* uses the communication channel to perform flow control. don't read data more quickly than you can actually display it; you'll end up dropping frames or effecting bufferbloat latency. this wastes work, and moves the drop decision away from the client code.\n* draws Unicode's Line- and Box-Drawing characters itself, rather than relying on the font.\n* supports some graphics protocol, ideally Kitty's. if you support Sixel instead, please implement `XTSMGRAPHICS`.\n* implement a keyboard disambiguation protocol, ideally Kitty's.\n* implement `hpa` for cheap absolute horizontal positioning.\n* size EGCs according to the largest `wcwidth()` result returned for any of the component characters. draw them all the same size otherwise.\n* honor Unicode rules for segmentation, including Zero-Width Joiners. emit either zero or one glyph per EGC.\n\nWithout a properly-bracketed Primary Device Attributes reply to my DA1 query,\nNotcurses is not going to work on your terminal emulator.\n\nBiDi's gonna be a mess no matter what. Don't stress too much about it.\n"
        },
        {
          "name": "USAGE.md",
          "type": "blob",
          "size": 167.08203125,
          "content": "# Usage\n\nAs of version 2.0.0, the Notcurses API is stable, and the project is committed\nto backwards compatibility.\n\n* [Direct Mode](#direct-mode)\n* [Alignment](#alignment)\n* [Input](#input)\n* [Planes](#planes) ([Plane Channels API](#plane-channels-api))\n* [Cells](#cells) ([Cell Channels API](#cell-channels-api))\n* [Reels](#reels) ([ncreel Examples](#ncreel-examples))\n* [Widgets](#widgets) ([Plots](#plots)) ([Readers](#readers)) ([Progbars](#progbars)) ([Tabs](#tabs))\n* [Channels](#channels)\n* [Visuals](#visuals) ([QR codes](#qrcodes)) ([Multimedia](#multimedia)) ([Pixels](#pixels))\n* [Stats](#stats)\n* [C++](#c++)\n\nA full API reference [is available](https://nick-black.com/notcurses/) in the\nform of manual pages; these ought have been installed along with Notcurses. This document is a\nsecondary reference, and should not be considered authoritative. For a more\nunified commentary, consider the [paperback](https://www.amazon.com/dp/B086PNVNC9)\n(also available as a [free PDF](https://nick-black.com/dankwiki/index.php?title=Hacking_The_Planet!_with_Notcurses)).\n\nA program wishing to use Notcurses will need to link it, ideally using the\noutput of `pkg-config --libs notcurses`. It is advised to compile with the\noutput of `pkg-config --cflags notcurses`. If using CMake, a support file is\nprovided, and can be accessed as `Notcurses`.\n\nIf your program makes no use of multimedia, you might want to link with only\nthe core Notcurses, and thus incur far fewer dependencies. To use the minimal\ncore Notcurses, use `pkg-config --libs notcurses-core` etc. In place of\n`notcurses_init()` and/or `ncdirect_init()` (see below), you must also use\n`notcurses_core_init()` and/or `ncdirect_core_init()`, or linking will fail.\n\nBefore calling into Notcurses—and usually as one of the first calls of the\nprogram—be sure to call `setlocale(3)` with an appropriate UTF-8 locale. It is\nusually appropriate to use `setlocale(LC_ALL, \"\")`, relying on the user to\nproperly set the `LANG` environment variable. Notcurses will refuse to start if\n`nl_langinfo(3)` doesn't indicate `ANSI_X3.4-1968` or `UTF-8`. In addition, it\nis wise to mask most signals early in the program, before any threads are\nspawned (this is particularly critical for `SIGWINCH`).\n\nNotcurses requires an available `terminfo(5)` definition appropriate for the\nterminal. It is usually appropriate to pass `NULL` in the `termtype` field of a\n`notcurses_options` struct, relying on the user to properly set the `TERM`\nenvironment variable. This variable is usually set by the terminal itself. It\nmight be necessary to manually select a higher-quality definition for your\nterminal, i.e. `xterm-direct` as opposed to `xterm` or `xterm-256color`.\n\nEach terminal can be prepared via a call to `notcurses_init()`, which is\nsupplied a struct of type `notcurses_options`:\n\n```c\n// Get a human-readable string describing the running Notcurses version.\nconst char* notcurses_version(void);\n\n// Cannot be inline, as we want to get the versions of the actual Notcurses\n// library we loaded, not what we compile against.\nvoid notcurses_version_components(int* major, int* minor, int* patch, int* tweak);\n\nstruct nccell;    // a coordinate on an ncplane: an EGC plus styling\nstruct ncplane;   // a drawable Notcurses surface, composed of cells\nstruct notcurses; // Notcurses state for a given terminal, composed of ncplanes\n\n// These log levels consciously map cleanly to those of libav; Notcurses itself\n// does not use this full granularity. The log level does not affect the opening\n// and closing banners, which can be disabled via the Notcurses_option struct's\n// 'suppress_banner'. Note that if stderr is connected to the same terminal on\n// which we're rendering, any kind of logging will disrupt the output.\ntypedef enum {\n  NCLOGLEVEL_SILENT,  // default. print nothing once fullscreen service begins\n  NCLOGLEVEL_PANIC,   // print diagnostics immediately related to crashing\n  NCLOGLEVEL_FATAL,   // we're hanging around, but we've had a horrible fault\n  NCLOGLEVEL_ERROR,   // we can't keep doing this, but we can do other things\n  NCLOGLEVEL_WARNING, // you probably don't want what's happening to happen\n  NCLOGLEVEL_INFO,    // \"standard information\"\n  NCLOGLEVEL_VERBOSE, // \"detailed information\"\n  NCLOGLEVEL_DEBUG,   // this is honestly a bit much\n  NCLOGLEVEL_TRACE,   // there's probably a better way to do what you want\n} ncloglevel_e;\n\n// Bits for notcurses_options->flags\n\n// notcurses_init() will call setlocale() to inspect the current locale. If\n// that locale is \"C\" or \"POSIX\", it will call setlocale(LC_ALL, \"\") to set\n// the locale according to the LANG environment variable. Ideally, this will\n// result in UTF8 being enabled, even if the client app didn't call\n// setlocale() itself. Unless you're certain that you're invoking setlocale() \n// prior to notcurses_init(), you should not set this bit. Even if you are\n// invoking setlocale(), this behavior shouldn't be an issue unless you're\n// doing something weird (setting a locale not based on LANG).\n#define NCOPTION_INHIBIT_SETLOCALE   0x0001\n\n// We typically try to clear any preexisting bitmaps. If we ought *not* try\n// to do this, pass NCOPTION_NO_CLEAR_BITMAPS. Note that they might still\n// get cleared even if this is set, and they might not get cleared even if\n// this is not set. It's a tough world out there.\n#define NCOPTION_NO_CLEAR_BITMAPS    0x0002\n\n// We typically install a signal handler for SIGWINCH that generates a resize\n// event in the notcurses_get() queue. Set to inhibit this handler.\n#define NCOPTION_NO_WINCH_SIGHANDLER 0x0004\n\n// We typically install a signal handler for SIG{INT, SEGV, ABRT, QUIT} that\n// restores the screen, and then calls the old signal handler. Set to inhibit\n// registration of these signal handlers.\n#define NCOPTION_NO_QUIT_SIGHANDLERS 0x0008\n\n// Initialize the standard plane's virtual cursor to match the physical cursor\n// at context creation time. Together with NCOPTION_NO_ALTERNATE_SCREEN and a\n// scrolling standard plane, this facilitates easy scrolling-style programs in\n// rendered mode.\n#define NCOPTION_PRESERVE_CURSOR     0x0010\n\n// Notcurses typically prints version info in notcurses_init() and performance\n// info in notcurses_stop(). This inhibits that output.\n#define NCOPTION_SUPPRESS_BANNERS    0x0020\n\n// If smcup/rmcup capabilities are indicated, Notcurses defaults to making use\n// of the \"alternate screen\". This flag inhibits use of smcup/rmcup.\n#define NCOPTION_NO_ALTERNATE_SCREEN 0x0040\n\n// Do not modify the font. Notcurses might attempt to change the font slightly,\n// to support certain glyphs (especially on the Linux console). If this is set,\n// no such modifications will be made. Note that font changes will not affect\n// anything but the virtual console/terminal in which Notcurses is running.\n#define NCOPTION_NO_FONT_CHANGES     0x0080\n\n// Input may be freely dropped. This ought be provided when the program does not\n// intend to handle input. Otherwise, input can accumulate in internal buffers,\n// eventually preventing Notcurses from processing terminal messages.\n#define NCOPTION_DRAIN_INPUT         0x0100\n\n// Prepare the standard plane in scrolling mode, useful for CLIs. This is\n// equivalent to calling ncplane_set_scrolling(notcurses_stdplane(nc), true).\n#define NCOPTION_SCROLLING           0x0200ull\n\n// \"CLI mode\" is just setting these four options.\n#define NCOPTION_CLI_MODE (NCOPTION_NO_ALTERNATE_SCREEN \\\n                           |NCOPTION_NO_CLEAR_BITMAPS \\\n                           |NCOPTION_PRESERVE_CURSOR \\\n                           |NCOPTION_SCROLLING)\n\n// Configuration for notcurses_init().\ntypedef struct notcurses_options {\n  // The name of the terminfo database entry describing this terminal. If NULL,\n  // the environment variable TERM is used. Failure to open the terminal\n  // definition will result in failure to initialize Notcurses.\n  const char* termtype;\n  // Progressively higher log levels result in more logging to stderr. By\n  // default, nothing is printed to stderr once fullscreen service begins.\n  ncloglevel_e loglevel;\n  // Desirable margins. If all are 0 (default), we will render to the entirety\n  // of the screen. If the screen is too small, we do what we can--this is\n  // strictly best-effort. Absolute coordinates are relative to the rendering\n  // area ((0, 0) is always the origin of the rendering area).\n  unsigned margin_t, margin_r, margin_b, margin_l;\n  // General flags; see NCOPTION_*. This is expressed as a bitfield so that\n  // future options can be added without reshaping the struct. Undefined bits\n  // must be set to 0.\n  uint64_t flags;\n} notcurses_options;\n\n// Lex a margin argument according to the standard Notcurses definition. There\n// can be either a single number, which will define all margins equally, or\n// there can be four numbers separated by commas.\nint notcurses_lex_margins(const char* op, notcurses_options* opts);\n\n// Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must\n// be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in\n// which case /dev/tty will be opened. Returns NULL on error, including any\n// failure initializing terminfo.\nstruct notcurses* notcurses_init(const notcurses_options* opts, FILE* fp);\n\n// The same as notcurses_init(), but without any multimedia functionality,\n// allowing for a svelter binary. Link with notcurses-core if this is used.\nstruct notcurses* notcurses_core_init(const notcurses_options* opts, FILE* fp);\n\n// Destroy a Notcurses context.\nint notcurses_stop(struct notcurses* nc);\n```\n\n`notcurses_stop` should be called before exiting your program to restore the\nterminal settings and free resources.\n\nAn application can freely enter and exit the alternate screen:\n\n```c\n// Shift to the alternate screen, if available. If already using the alternate\n// screen, this returns 0 immediately. If the alternate screen is not\n// available, this returns -1 immediately. Entering the alternate screen turns\n// off scrolling for the standard plane.\nint notcurses_enter_alternate_screen(struct notcurses* nc);\n\n// Exit the alternate screen. Immediately returns 0 if not currently using the\n// alternate screen.\nint notcurses_leave_alternate_screen(struct notcurses* nc);\n```\n\nNotcurses does not typically generate diagnostics (aside from the intro banner\nand outro performance summary). When `stderr` is connected to the same terminal\nto which graphics are being printed, printing to stderr will corrupt the output.\nSetting `loglevel` to a value higher than `NCLOGLEVEL_SILENT` will cause\ndiagnostics to be printed to `stderr`: you could ensure `stderr` is redirected\nif you make use of this functionality.\n\nIt's probably wise to export `NCOPTION_NO_ALTERNATE_SCREEN` to the user (e.g.\nvia command line option or environment variable). Motivated users might\nappreciate the ability to manipulate `loglevel`. The remaining options are\ntypically of use only to application authors.\n\nThe Notcurses API draws almost entirely into the virtual buffers of `ncplane`s.\nOnly upon a call to `notcurses_render` will the visible terminal display be\nupdated to reflect the changes:\n\n```c\n// Renders the pile of which 'n' is a part. Rendering this pile again will blow\n// away the render. To actually write out the render, call ncpile_rasterize().\nint ncpile_render(struct ncplane* n);\n\n// Make the physical screen match the last rendered frame from the pile of\n// which 'n' is a part. This is a blocking call. Don't call this before the\n// pile has been rendered (doing so will likely result in a blank screen).\nint ncpile_rasterize(struct ncplane* n);\n\n// Make the physical screen match the virtual screen. Changes made to the\n// virtual screen (i.e. most other calls) will not be visible until after a\n// successful call to notcurses_render().\nint notcurses_render(struct notcurses* nc);\n\n// Perform the rendering and rasterization portion of notcurses_render(), but\n// do not write the resulting buffer out to the terminal. The returned buffer\n// must be freed by the caller.\nint ncpile_render_to_buffer(struct ncplane* p, char** buf, size_t* buflen);\n\n// Write the last rendered frame, in its entirety, to 'fp'. If a frame has\n// not yet been rendered, nothing will be written.\nint ncpile_render_to_file(struct ncplane* p, FILE* fp);\n\nint ncpile_render_to_file(struct ncplane* p, FILE* fp);\n\n// Retrieve the contents of the specified cell as last rendered. The EGC is\n// returned, or NULL on error. This EGC must be free()d by the caller. The\n// styles and channels are written to 'attrword' and 'channels', respectively.\nchar* notcurses_at_yx(struct notcurses* nc, unsigned yoff, unsigned xoff,\n                      uint16_t* styles, uint64_t* channels);\n```\n\nOne `ncplane` is guaranteed to exist: the \"standard plane\". The user cannot\nmove, resize, reparent, or destroy the standard plane (it *can* be erased).\nIts dimensions always match notcurses's conception of the visible terminal. A\nhandle on the standard plane can be acquired with two top-level functions:\n\n```c\n// Get a reference to the standard plane (one matching our current idea of the\n// terminal size) for this terminal. The standard plane always exists, and its\n// origin is always at the uppermost, leftmost cell of the screen.\nstruct ncplane* notcurses_stdplane(struct notcurses* nc);\nconst struct ncplane* notcurses_stdplane_const(const struct notcurses* nc);\n\n// notcurses_stdplane(), plus free bonus dimensions written to non-NULL y/x!\nstatic inline struct ncplane*\nnotcurses_stddim_yx(struct notcurses* nc, unsigned* restrict y, unsigned* restrict x){\n  struct ncplane* s = notcurses_stdplane(nc); // can't fail\n  ncplane_dim_yx(s, y, x); // accepts NULL\n  return s;\n}\n\nstatic inline const struct ncplane*\nnotcurses_stddim_yx_const(const struct notcurses* nc, unsigned* restrict y, unsigned* restrict x){\n  const struct ncplane* s = notcurses_stdplane_const(nc); // can't fail\n  ncplane_dim_yx(s, y, x); // accepts NULL\n  return s;\n}\n```\n\nA reference to the standard plane *is* persistent across a screen resize, as are\nany indexes into its egcpool, but its framebuffer *is not* necessarily\npersistent across a screen resize. Thankfully, you shouldn't have a reference\nto its framebuffer, and thus only the change to its dimensions can really catch\nyou off guard.\n\nUtility functions operating on the toplevel `notcurses` object include:\n\n```c\n// Return the topmost ncplane of the standard pile.\nstruct ncplane* notcurses_top(struct notcurses* n);\n\n// Return the bottommost ncplane of the standard pile.\nstruct ncplane* notcurses_bottom(struct notcurses* n);\n\n// Return our current idea of the terminal dimensions in rows and cols.\nstatic inline void\nnotcurses_term_dim_yx(const struct notcurses* n, unsigned* restrict rows,\n                      unsigned* restrict cols){\n  ncplane_dim_yx(notcurses_stdplane_const(n), rows, cols);\n}\n\n// Refresh the physical screen to match what was last rendered (i.e., without\n// reflecting any changes since the last call to notcurses_render()). This is\n// primarily useful if the screen is externally corrupted, or if an\n// NCKEY_RESIZE event has been read and you're not yet ready to render. The\n// current screen geometry is returned in 'y' and 'x', if they are not NULL.\nint notcurses_refresh(struct notcurses* n, unsigned* restrict y, unsigned* restrict x);\n\n// Get the default foreground color, if it is known. Returns -1 on error\n// (unknown foreground). On success, returns 0, writing the RGB value to\n// 'fg' (if non-NULL)\nint notcurses_default_foreground(const struct notcurses* nc, uint32_t* fg);\n\n// Get the default background color, if it is known. Returns -1 on error\n// (unknown background). On success, returns 0, writing the RGB value to\n// 'bg' (if non-NULL) and setting 'bgtrans' high iff the background color\n// is treated as transparent.\nint notcurses_default_background(const struct notcurses* nc,\n                                 uint32_t* bg, unsigned* bgtrans);\n\n// Enable or disable the terminal's cursor, if supported, placing it at\n// 'y', 'x'. Immediate effect (no need for a call to notcurses_render()).\n// It is an error if 'y', 'x' lies outside the standard plane. Can be\n// called while already visible to move the cursor.\nint notcurses_cursor_enable(struct notcurses* nc, int y, int x);\n\n// Disable the hardware cursor. It is an error to call this while the\n// cursor is already disabled.\nint notcurses_cursor_disable(struct notcurses* nc);\n\n// Get the current location of the terminal's cursor, whether visible or not.\nint notcurses_cursor_yx(const struct notcurses* nc, int* y, int* x);\n\n// Returns a 16-bit bitmask in the LSBs of supported curses-style attributes\n// (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only\n// indicated as supported if the terminal can support it together with color.\n// For more information, see the \"ncv\" capability in terminfo(5).\nunsigned notcurses_supported_styles(const struct notcurses* nc);\n\n// Returns the number of simultaneous colors claimed to be supported, or 1 if\n// there is no color support. Note that several terminal emulators advertise\n// more colors than they actually support, downsampling internally.\nunsigned notcurses_palette_size(const struct notcurses* nc);\n\n// Can we fade? Fading requires either the \"rgb\" or \"ccc\" terminfo capability.\nbool notcurses_canfade(const struct notcurses* nc);\n\n// Can we directly specify RGB values per cell, or only use palettes?\nbool notcurses_cantruecolor(const struct notcurses* nc);\n\n// Can we load images? This requires being built against FFmpeg/OIIO.\nbool notcurses_canopen_images(const struct notcurses* nc);\n\n// Can we load videos? This requires being built against FFmpeg.\nbool notcurses_canopen_videos(const struct notcurses* nc);\n\n// Can we change colors in the hardware palette? Requires \"ccc\" and \"initc\".\nbool notcurses_canchangecolor(const struct notcurses* nc);\n\n// Is our encoding UTF-8? Requires LANG being set to a UTF-8 locale.\nbool notcurses_canutf8(const struct notcurses* nc);\n\n// Can we reliably use Unicode halfblocks?\nbool notcurses_canhalfblock(const struct notcurses* nc);\n\n// Can we reliably use Unicode quadrants?\nbool notcurses_canquadrant(const struct notcurses* nc);\n\n// Can we draw sextants? This requires Unicode 13.\nbool notcurses_cansextants(const struct notcurses* nc);\n\n// Can we draw Braille? The Linux console cannot.\nbool notcurses_canbraille(const struct notcurses* nc);\n\n// Can we draw bitmaps?\nbool notcurses_canpixel(const struct notcurses* nc);\n\n// pixel blitting implementations. informative only; don't special-case\n// based off any of this information!\ntypedef enum {\n  NCPIXEL_NONE = 0,\n  NCPIXEL_SIXEL,           // sixel\n  NCPIXEL_LINUXFB,         // linux framebuffer\n  NCPIXEL_ITERM2,          // iTerm2\n  // C=1 (disabling scrolling) was only introduced in 0.20.0, at the same\n  // time as animation. prior to this, graphics had to be entirely redrawn\n  // on any change, and it wasn't possible to use the bottom line.\n  NCPIXEL_KITTY_STATIC,\n  // until 0.22.0's introduction of 'a=c' for self-referential composition, we\n  // had to keep a complete copy of the RGBA data, in case a wiped cell needed\n  // to be rebuilt. we'd otherwise have to unpack the glyph and store it into\n  // the auxvec on the fly.\n  NCPIXEL_KITTY_ANIMATED,\n  // with 0.22.0, we only ever write transparent cells after writing the\n  // original image (which we now deflate, since we needn't unpack it later).\n  // the only data we need keep is the auxvecs.\n  NCPIXEL_KITTY_SELFREF,\n} ncpixelimpl_e;\n\n// Returns a non-zero constant corresponding to some pixel-blitting\n// mechanism if bitmap support (via any mechanism) has been detected,\n// or else 0 (NCPIXEL_NONE).\nncpixelimpl_e notcurses_check_pixel_support(struct notcurses* nc);\n\n// Returns a heap-allocated copy of the user name under which we are running.\nchar* notcurses_accountname(void);\n\n// Returns a heap-allocated copy of the local host name.\nchar* notcurses_hostname(void);\n\n// Returns a heap-allocated copy of human-readable OS name and version.\nchar* notcurses_osversion(void);\n```\n\n## Direct mode\n\n\"Direct mode\" makes a limited subset of Notcurses is available for manipulating\ntypical scrolling or file-backed output. Its functions are exported via\n`<notcurses/direct.h>`, and output directly and immediately to the provided\n`FILE*`. `notcurses_render()` is neither supported nor necessary for such an\ninstance. Use `ncdirect_init()` to create a direct mode context:\n\n```c\nstruct ncdirect; // minimal state for a terminal\n\n// Initialize a direct-mode Notcurses context on the connected terminal at 'fp'.\n// 'fp' must be a tty. You'll usually want stdout. Direct mode supports a\n// limited subset of Notcurses routines which directly affect 'fp', and neither\n// supports nor requires notcurses_render(). This can be used to add color and\n// styling to text in the standard output paradigm. 'flags' is a bitmask over\n// NCDIRECT_OPTION_*.\n// Returns NULL on error, including any failure initializing terminfo.\nstruct ncdirect* ncdirect_init(const char* termtype, FILE* fp, uint64_t flags);\n\n// The same as ncdirect_init(), but without any multimedia functionality,\n// allowing for a svelter binary. Link with notcurses-core if this is used.\nstruct ncdirect* ncdirect_core_init(const char* termtype, FILE* fp, uint64_t flags);\n\n// ncdirect_init() will call setlocale() to inspect the current locale. If\n// that locale is \"C\" or \"POSIX\", it will call setlocale(LC_ALL, \"\") to set\n// the locale according to the LANG environment variable. Ideally, this will\n// result in UTF8 being enabled, even if the client app didn't call\n// setlocale() itself. Unless you're certain that you're invoking setlocale()\n// prior to notcurses_init(), you should not set this bit. Even if you are\n// invoking setlocale(), this behavior shouldn't be an issue unless you're\n// doing something weird (setting a locale not based on LANG).\n#define NCDIRECT_OPTION_INHIBIT_SETLOCALE   0x0001ull\n\n// *Don't* place the terminal into cbreak mode (see tcgetattr(3)). By default,\n// echo and line buffering are turned off.\n#define NCDIRECT_OPTION_INHIBIT_CBREAK      0x0002ull\n\n// Input may be freely dropped. This ought be provided when the program does not\n// intend to handle input. Otherwise, input can accumulate in internal buffers,\n// eventually preventing Notcurses from processing terminal messages.\n#define NCDIRECT_OPTION_DRAIN_INPUT         0x0004ull\n\n// We typically install a signal handler for SIG{INT, SEGV, ABRT, QUIT} that\n// restores the screen, and then calls the old signal handler. Set to inhibit\n// registration of these signal handlers. Chosen to match fullscreen mode.\n#define NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS 0x0008ull\n\n// Enable logging (to stderr) at the NCLOGLEVEL_WARNING level.\n#define NCDIRECT_OPTION_VERBOSE             0x0010ull\n\n// Enable logging (to stderr) at the NCLOGLEVEL_TRACE level. This will enable\n// all diagnostics, a superset of NCDIRECT_OPTION_VERBOSE (which this implies).\n#define NCDIRECT_OPTION_VERY_VERBOSE        0x0020ull\n\n// Release 'nc' and any associated resources. 0 on success, non-0 on failure.\nint ncdirect_stop(struct ncdirect* nc);\n```\n\nThis context must be destroyed using `ncdirect_stop()`. The following functions\nare available for direct mode:\n\n```c\n// Read a (heap-allocated) newline-delimited chunk of text. Returns NULL on\n// failure. The NCDIRECT_OPTION_INHIBIT_CBREAK flag ought not be used together\n// with this function, or the line-editing keybindings cannot be honored.\nchar* ncdirect_readline(struct ncdirect* nc, const char* prompt);\n\nint ncdirect_fg_rgb(struct ncdirect* nc, unsigned rgb);\nint ncdirect_bg_rgb(struct ncdirect* nc, unsigned rgb);\n\nstatic inline int\nncdirect_bg_rgb8(struct ncdirect* nc, unsigned r, unsigned g, unsigned b){\n  if(r > 255 || g > 255 || b > 255){\n    return -1;\n  }\n  return ncdirect_bg_rgb(nc, (r << 16u) + (g << 8u) + b);\n}\n\nstatic inline int\nncdirect_fg_rgb8(struct ncdirect* nc, unsigned r, unsigned g, unsigned b){\n  if(r > 255 || g > 255 || b > 255){\n    return -1;\n  }\n  return ncdirect_fg_rgb(nc, (r << 16u) + (g << 8u) + b);\n}\n\n// Get the current number of columns/rows.\nint ncdirect_dim_x(const struct ncdirect* nc);\nint ncdirect_dim_y(const struct ncdirect* nc);\n\nint ncdirect_fg_default(struct ncdirect* nc);\nint ncdirect_bg_default(struct ncdirect* nc);\nint ncdirect_styles_set(struct ncdirect* n, unsigned stylebits);\nint ncdirect_styles_on(struct ncdirect* n, unsigned stylebits);\nint ncdirect_styles_off(struct ncdirect* n, unsigned stylebits);\nunsigned ncdirect_styles(struct ncdirect* n);\nint ncdirect_clear(struct ncdirect* nc); // clear the screen\n\n// Move the cursor in direct mode. -1 to retain current location on that axis.\nint ncdirect_cursor_move_yx(struct ncdirect* n, int y, int x);\nint ncdirect_cursor_enable(struct ncdirect* nc);\nint ncdirect_cursor_disable(struct ncdirect* nc);\n\n// Relative moves. num < 0 is an error.\nint ncdirect_cursor_up(struct ncdirect* nc, int num);\nint ncdirect_cursor_left(struct ncdirect* nc, int num);\nint ncdirect_cursor_right(struct ncdirect* nc, int num);\nint ncdirect_cursor_down(struct ncdirect* nc, int num);\n\n// Get the cursor position, when supported. This requires writing to the\n// terminal, and then reading from it. If the terminal doesn't reply, or\n// doesn't reply in a way we understand, the results might be deleterious.\nint ncdirect_cursor_yx(struct ncdirect* n, unsigned* y, unsigned* x);\n\n// Push or pop the cursor location to the terminal's stack. The depth of this\n// stack, and indeed its existence, is terminal-dependent.\nint ncdirect_cursor_push(struct ncdirect* n);\nint ncdirect_cursor_pop(struct ncdirect* n);\n\n// Formatted printing (plus alignment relative to the terminal).\nint ncdirect_printf_aligned(struct ncdirect* n, int y, ncalign_e align,\n                            const char* fmt, ...);\n\n// Output the string |utf8| according to the channels |channels|. Note that\n// ncdirect_putstr() does not explicitly flush output buffers, so it will not\n// necessarily be immediately visible.\nint ncdirect_putstr(struct ncdirect* nc, uint64_t channels, const char* utf8);\n\n// Output a single EGC (this might be several characters) from |utf8|,\n// according to the channels |channels|. On success, the number of columns\n// thought to have been used is returned, and if |sbytes| is not NULL,\n// the number of bytes consumed will be written there.\nint ncdirect_putegc(struct ncdirect* nc, uint64_t channels,\n                    const char* utf8, int* sbytes);\n\n// Draw horizontal/vertical lines using the specified channels, interpolating\n// between them as we go. The EGC may not use more than one column. For a\n// horizontal line, |len| cannot exceed the screen width minus the cursor's\n// offset. For a vertical line, it may be as long as you'd like; the screen\n// will scroll as necessary. All lines start at the current cursor position.\n// A length of 0 is an error, resulting in a return of -1.\nint ncdirect_hline_interp(struct ncdirect* n, const char* egc,\n                          unsigned len, uint64_t h1, uint64_t h2);\nint ncdirect_vline_interp(struct ncdirect* n, const char* egc,\n                          unsigned len, uint64_t h1, uint64_t h2);\n\n// Draw a box with its upper-left corner at the current cursor position, having\n// dimensions |ylen|x|xlen|. See ncplane_box() for more information. The\n// minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an\n// array of 6 wide characters: UL, UR, LL, LR, HL, VL.\nint ncdirect_box(struct ncdirect* n, uint64_t ul, uint64_t ur,\n                 uint64_t ll, uint64_t lr, const wchar_t* wchars,\n                 int ylen, int xlen, unsigned ctlword);\n\n// ncdirect_box() with the rounded box-drawing characters\nint ncdirect_rounded_box(struct ncdirect* n, uint64_t ul, uint64_t ur,\n                         uint64_t ll, uint64_t lr,\n                         int ylen, int xlen, unsigned ctlword);\n\n// ncdirect_box() with the double box-drawing characters\nint ncdirect_double_box(struct ncdirect* n, uint64_t ul, uint64_t ur,\n                        uint64_t ll, uint64_t lr,\n                        int ylen, int xlen, unsigned ctlword);\n\n// Display an image using the specified blitter and scaling. The image may\n// be arbitrarily many rows -- the output will scroll -- but will only occupy\n// the column of the cursor, and those to the right.\nint ncdirect_render_image(struct ncdirect* nc, const char* filename,\n                          ncblitter_e blitter, ncscale_e scale);\n\n// Render an image using the specified blitter and scaling, but do not write\n// the result. The image may be arbitrarily many rows -- the output will scroll\n// -- but will only occupy the column of the cursor, and those to the right.\n// To actually write (and free) this, invoke ncdirect_raster_frame(). 'maxx'\n// and 'maxy', if greater than 0, are used for scaling; the terminal's geometry\n// is otherwise used. It is an error to pass a negative 'maxy' or 'maxx'.\nncdirectv* ncdirect_render_frame(struct ncdirect* n, const char* filename,\n                                 ncblitter_e blitter, ncscale_e scale,\n                                 int maxy, int maxx);\n\n// Takes the result of ncdirect_render_frame() and writes it to the output.\nint ncdirect_raster_frame(struct ncdirect* n, ncdirectv* ncdv, ncalign_e align);\n```\n\nSeveral of the Notcurses capability predicates have `ncdirect` analogues:\n\n```c\nbool ncdirect_canopen_images(const struct ncdirect* n);\nbool ncdirect_canutf8(const struct ncdirect* n);\n```\n\n## Alignment\n\nMost functions that generate output can be aligned relative to an ncplane.\nAlignment currently comes in three forms: `NCALIGN_LEFT`, `NCALIGN_CENTER`, and\n`NCALIGN_RIGHT`.\n\n```c\n// Alignment within the ncplane. Left/right-justified, or centered.\ntypedef enum {\n  NCALIGN_LEFT,\n  NCALIGN_CENTER,\n  NCALIGN_RIGHT,\n} ncalign_e;\n\n#define NCALIGN_TOP NCALIGN_LEFT\n#define NCALIGN_BOTTOM NCALIGN_RIGHT\n\n// Return the offset into 'availu' at which 'u' ought be output given the\n// requirements of 'align'. Return -INT_MAX on invalid 'align'. Undefined\n// behavior on negative 'availu' or 'u'.\nstatic inline int\nnotcurses_align(int availu, ncalign_e align, int u){\n  if(align == NCALIGN_LEFT || align == NCALIGN_TOP){\n    return 0;\n  }\n  if(align == NCALIGN_CENTER){\n    return (availu - u) / 2;\n  }\n  if(align == NCALIGN_RIGHT || align == NCALIGN_BOTTOM){\n    return availu - u;\n  }\n  return -INT_MAX; // invalid |align|\n}\n\n// Return the column at which 'c' cols ought start in order to be aligned\n// according to 'align' within ncplane 'n'. Return -INT_MAX on invalid\n// 'align'. Undefined behavior on negative 'c'.\nstatic inline int\nncplane_align(const struct ncplane* n, ncalign_e align, int c){\n  return notcurses_align(ncplane_dim_x(n), align, c);\n}\n\n```\n\n## Input\n\nInput can currently be taken only from `stdin`, but on the plus side, stdin\nneedn't be a terminal device (unlike the ttyfp `FILE*` passed to `notcurses_init()`).\nGeneralized input ought happen soon. There is only one input queue per `struct\nnotcurses`.\n\nLike NCURSES, Notcurses will watch for escape sequences, check them against the\nterminfo database, and return them as special keys (we hijack the Private Use\nArea for special keys, specifically Supplementary Private Use Area B (u100000\nthrough u10ffffd). Unlike NCURSES, the fundamental unit of input is the\nUTF8-encoded Unicode codepoint. Note, however, that only one codepoint is\nreturned at a time (as opposed to an entire EGC).\n\nIt is generally possible for a false positive to occur, wherein keypresses\nintended to be distinct are combined into an escape sequence. False negatives\nwhere an intended escape sequence are read as an ESC key followed by distinct\nkeystrokes are also possible. NCURSES provides the `ESCDELAY` variable to\ncontrol timing. Notcurses brooks no delay; all characters of an escape sequence\nmust be readable without delay for it to be interpreted as such.\n\n```c\n// All input is taken from stdin. We attempt to read a single UTF8-encoded\n// Unicode codepoint, *not* an entire Extended Grapheme Cluster. It is also\n// possible that we will produce a synthesized event, i.e. anything that\n// doesn't correspond to a Unicode codepoint (e.g. arrow keys, function keys,\n// screen resize events, etc.). The full list of synthesized events can be\n// found in <notcurses/nckeys.h>.\n//\n// notcurses_get_nblock() is nonblocking. notcurses_get_blocking() blocks\n// until a codepoint or special key is read, or until interrupted by a signal.\n// notcurses_get() allows an optional timeout to be controlled.\n//\n// In the case of a valid read, the provided ncinput is filled in, and the\n// id field is returned. 0 is returned to indicate that no input was available.\n// On any error, (uint32_t)-1 is returned.\n\n// An input event. Cell coordinates are currently defined only for mouse events.\ntypedef struct ncinput {\n  uint32_t id;     // identifier (unicode codepoint or synthesized NCKEY event)\n  int y, x;        // y/x cell coordinate of event, -1 for undefined\n  bool alt;        // was alt held?\n  bool shift;      // was shift held?\n  bool ctrl;       // was ctrl held?\n  enum {\n    NCTYPE_UNKNOWN,\n    NCTYPE_PRESS,\n    NCTYPE_REPEAT,\n    NCTYPE_RELEASE,\n  } evtype;\n  int ypx, xpx;      // pixel offsets within cell, -1 for undefined\n} ncinput;\n\n// Read a UTF-32-encoded Unicode codepoint from input. This might only be part\n// of a larger EGC. Provide a NULL 'ts' to block at length, and otherwise a\n// timespec specifying an absolute deadline calculated using CLOCK_MONOTONIC.\n// Returns a single Unicode code point, or a synthesized special key constant,\n// or (uint32_t)-1 on error. Returns 0 on a timeout. If an event is processed,\n// the return value is the 'id' field from that event. 'ni' may be NULL.\nuint32_t notcurses_get(struct notcurses* n, const struct timespec* ts,\n                       ncinput* ni);\n\n// Acquire up to 'vcount' ncinputs at the vector 'ni'. The number read will be\n// returned, or -1 on error without any reads, 0 on timeout.\nint notcurses_getvec(struct notcurses* n, const struct timespec* ts,\n                     ncinput* ni, int vcount);\n\n// 'ni' may be NULL if the caller is uninterested in event details. If no\n// event is ready, returns 0.\nstatic inline uint32_t\nnotcurses_get_nblock(struct notcurses* n, ncinput* ni){\n  struct timespec ts = { .tv_sec = 0, .tv_nsec = 0 };\n  return notcurses_get(n, &ts, ni);\n}\n\n// 'ni' may be NULL if the caller is uninterested in event details. Blocks\n// until an event is processed or a signal is received.\nstatic inline uint32_t\nnotcurses_get_blocking(struct notcurses* n, ncinput* ni){\n  return notcurses_get(n, NULL, ni);\n}\n\nstatic inline bool\nncinput_nomod_p(const ncinput* ni){\n  return !(ni->modifiers);\n}\n```\n\nBy default, certain keys are mapped to signals by the terminal's line\ndiscipline. This can be disabled with `notcurses_linesigs_disable()`, and\nreenabled with `notcurses_linesigs_enable()`.\n\n```c\n// Disable signals originating from the terminal's line discipline, i.e.\n// SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z). They are enabled by default.\nint notcurses_linesigs_disable(struct notcurses* n);\n\n// Restore signals originating from the terminal's line discipline, i.e.\n// SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z), if disabled.\nint notcurses_linesigs_enable(struct notcurses* n);\n```\n\n## Mice\n\nnotcurses supports mice, though only through brokers such as X or\n[GPM](https://www.nico.schottelius.org/software/gpm/). It does not speak\ndirectly to hardware. Mouse events must be explicitly enabled with a\nsuccessful call to `notcurses_mouse_enable()`, and can later be disabled.\n\n```c\n// Enable the mouse in \"button-event tracking\" mode with focus detection and\n// UTF8-style extended coordinates. On failure, -1 is returned. On success, 0\n// is returned, and mouse events will be published to notcurses_get().\nint notcurses_mouse_enable(struct notcurses* n);\n\n// Disable mouse events. Any events in the input queue can still be delivered.\nint notcurses_mouse_disable(struct notcurses* n);\n\n// Is the event a synthesized mouse event?\nstatic inline bool\nnckey_mouse_p(uint32_t r){\n  return r >= NCKEY_BUTTON1 && r <= NCKEY_BUTTON11;\n}\n```\n\n\"Button-event tracking mode\" implies the ability to detect mouse button\npresses, and also mouse movement while holding down a mouse button (i.e. to\neffect drag-and-drop). Mouse events are returned via the `NCKEY_MOUSE*` values,\nwith coordinate information in the `ncinput` struct.\n\n## Planes\n\nFundamental to Notcurses is a z-buffer of rectilinear virtual screens, known\nas `ncplane`s. An `ncplane` can be larger than the physical screen, or smaller,\nor the same size; it can be entirely contained within the physical screen, or\noverlap in part, or lie wholly beyond the boundaries, never to be rendered.\nIn addition to its framebuffer--a rectilinear matrix of `nccell`s\n(see [Cells](#cells))--an `ncplane` is defined by:\n\n* a base `nccell`, used for any cell on the plane without a glyph,\n* the egcpool backing its `nccell`s,\n* a current cursor location,\n* a current style, foreground channel, and background channel,\n* its geometry,\n* a configured user curry (a `void*`),\n* its position relative to the visible plane,\n* its z-index, and\n* an optional resize callback,\n* a name (used only for debugging).\n\nIf opaque, a `nccell` on a higher `ncplane` completely obstructs a corresponding\n`nccell` from a lower `ncplane` from being seen. An `ncplane` corresponds loosely\nto an [NCURSES Panel](https://invisible-island.net/ncurses/ncurses-intro.html#panels),\nbut is the primary drawing surface of notcurses—there is no object\ncorresponding to a bare NCURSES `WINDOW`.\n\nAn `ncplane` can be created aligned relative to an existing `ncplane`\n(including the standard plane) using `NCPLANE_OPTION_HORALIGNED`.\n\nWhen an `ncplane` is no longer needed, free it with\n`ncplane_destroy()`. To quickly reset the `ncplane`, use `ncplane_erase()`.\n\n```c\n// Horizontal alignment relative to the parent plane. Use ncalign_e for 'x'.\n#define NCPLANE_OPTION_HORALIGNED   0x0001ull\n// Vertical alignment relative to the parent plane. Use ncalign_e for 'y'.\n#define NCPLANE_OPTION_VERALIGNED   0x0002ull\n// Maximize relative to the parent plane, modulo the provided margins. The\n// margins are best-effort; the plane will always be at least 1 column by\n// 1 row. If the margins can be effected, the plane will be sized to all\n// remaining space. 'y' and 'x' are overloaded as the top and left margins\n// when this flag is used. 'rows' and 'cols' must be 0 when this flag is\n// used. This flag is exclusive with both of the alignment flags.\n#define NCPLANE_OPTION_MARGINALIZED 0x0004ull\n// If this plane is bound to a scrolling plane, it ought *not* scroll along\n// with the parent (it will still move with the parent, maintaining its\n// relative position, if the parent is moved to a new location).\n#define NCPLANE_OPTION_FIXED        0x0008ull\n// Enable automatic growth of the plane to accommodate output. Creating a\n// plane with this flag is equivalent to immediately calling\n// ncplane_set_autogrow(p, true) following plane creation.\n#define NCPLANE_OPTION_AUTOGROW     0x0010ull\n// Enable vertical scrolling of the plane to accommodate output. Creating a\n// plane with this flag is equivalent to immediately calling\n// ncplane_set_scrolling(p, true) following plane creation.\n#define NCPLANE_OPTION_VSCROLL      0x0020ull\n\ntypedef struct ncplane_options {\n  int y;            // vertical placement relative to parent plane\n  int x;            // horizontal placement relative to parent plane\n  int rows;         // rows, must be positive (unless NCPLANE_OPTION_MARGINALIZED)\n  int cols;         // columns, must be positive (unless NCPLANE_OPTION_MARGINALIZED)\n  void* userptr;    // user curry, may be NULL\n  const char* name; // name (used only for debugging), may be NULL\n  int (*resizecb)(struct ncplane*); // callback when parent is resized\n  uint64_t flags;   // closure over NCPLANE_OPTION_*\n  unsigned margin_b, margin_r; // margins (require NCPLANE_OPTION_MARGINALIZED)\n} ncplane_options;\n\n// Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to\n// the origin of 'n') and the specified size. The number of 'rows' and 'cols'\n// must both be positive. This plane is initially at the top of the z-buffer,\n// as if ncplane_move_top() had been called on it. The void* 'userptr' can be\n// retrieved (and reset) later. A 'name' can be set, used in debugging.\nstruct ncplane* ncplane_create(struct ncplane* n, const ncplane_options* nopts);\n\n// Plane 'n' will be unbound from its parent plane, and will be made a bound\n// child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If\n// 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n'\n// is already the root of a pile, in which case this is a no-op. Returns 'n'.\n// The standard plane cannot be reparented. Any planes bound to 'n' are\n// reparented to the previous parent of 'n'.\nstruct ncplane* ncplane_reparent(struct ncplane* n, struct ncplane* newparent);\n\n// The same as ncplane_reparent(), except any planes bound to 'n' come along\n// with it to its new destination. Their z-order is maintained.\nstruct ncplane* ncplane_reparent_family(struct ncplane* n, struct ncplane* newparent);\n\n// Replace the ncplane's existing resizecb with 'resizecb' (which may be NULL).\nvoid ncplane_set_resizecb(struct ncplane* n, int(*resizecb)(struct ncplane*));\n\n// Returns the ncplane's current resize callback.\nint (*ncplane_resizecb(const struct ncplane* n))(struct ncplane*);\n\n// Suitable for use as a 'resizecb', this will resize the plane to the visual\n// region's size. It is used for the standard plane.\nint ncplane_resize_maximize(struct ncplane* n);\n\n// Suitable for use as a 'resizecb' with planes created with\n// NCPLANE_OPTION_MARGINALIZED. This will resize the plane 'n' against its\n// parent, attempting to enforce the supplied margins.\nint ncplane_resize_marginalized(struct ncplane* n);\n\n// Suitable for use as a 'resizecb'. This will realign the plane 'n' against\n// its parent, using the alignment specified at ncplane_create()-time.\nint ncplane_resize_realign(struct ncplane* n);\n\n// Get the plane to which the plane 'n' is bound, if any.\nstruct ncplane* ncplane_parent(struct ncplane* n);\nconst struct ncplane* ncplane_parent_const(const struct ncplane* n);\n\n// Set the plane's name, replacing any current name.\nint ncplane_set_name(struct ncplane* n, const char* name);\n\n// Return a heap-allocated copy of the plane's name, or NULL if it has none.\nchar* ncplane_name(const struct ncplane* n);\n\n// Duplicate an existing ncplane. The new plane will have the same geometry,\n// will duplicate all content, and will start with the same rendering state.\nstruct ncplane* ncplane_dup(struct ncplane* n, void* opaque);\n\n// Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously\n// defined as \"write to 'dst' the frame that would be rendered were the entire\n// stack made up only of the specified subregion of 'src' and, below it, the\n// subregion of 'dst' having the specified origin. Supply -1 to indicate the\n// current cursor position in the relevant dimension. Merging is independent of\n// the position of 'src' viz 'dst' on the z-axis. It is an error to define a\n// subregion that is not entirely contained within 'src'. It is an error to\n// define a target origin such that the projected subregion is not entirely\n// contained within 'dst'.  Behavior is undefined if 'src' and 'dst' are\n// equivalent. 'dst' is modified, but 'src' remains unchanged. Neither 'src'\n// nor 'dst' may have sprixels. Lengths of 0 mean \"everything left\".\nint ncplane_mergedown(struct ncplane* RESTRICT src, struct ncplane* RESTRICT dst,\n                      int begsrcy, int begsrcx, unsigned leny, unsigned lenx,\n                      int dsty, int dstx);\n\n// Merge the entirety of 'src' down onto the ncplane 'dst'. If 'src' does not\n// intersect with 'dst', 'dst' will not be changed, but it is not an error.\nint ncplane_mergedown_simple(struct ncplane* restrict src,\n                             struct ncplane* restrict dst);\n\n// Erase every cell in the ncplane, resetting all attributes to normal, all\n// colors to the default color, and all cells to undrawn. All cells associated\n// with this ncplane are invalidated, and must not be used after the call,\n// excluding the base cell. The cursor is homed.\nvoid ncplane_erase(struct ncplane* n);\n\n// Erase every cell in the region starting at {ystart, xstart} and having size\n// {|ylen|x|xlen|} for non-zero lengths. If ystart and/or xstart are -1, the current\n// cursor position along that axis is used; other negative values are an error. A\n// negative ylen means to move up from the origin, and a negative xlen means to move\n// left from the origin. A positive ylen moves down, and a positive xlen moves right.\n// A value of 0 for the length erases everything along that dimension. It is an error\n// if the starting coordinate is not in the plane, but the ending coordinate may be\n// outside the plane.\n//\n// For example, on a plane of 20 rows and 10 columns, with the cursor at row 10 and\n// column 5, the following would hold:\n//\n//  (-1, -1, 0, 1): clears the column to the right of the cursor (column 6)\n//  (-1, -1, 0, -1): clears the column to the left of the cursor (column 4)\n//  (-1, -1, INT_MAX, 0): clears all rows with or below the cursor (rows 10--19)\n//  (-1, -1, -INT_MAX, 0): clears all rows with or above the cursor (rows 0--10)\n//  (-1, 4, 3, 3): clears from row 5, column 4 through row 7, column 6\n//  (-1, 4, -3, -3): clears from row 5, column 4 through row 3, column 2\n//  (4, -1, 0, 3): clears columns 5, 6, and 7\n//  (-1, -1, 0, 0): clears the plane *if the cursor is in a legal position*\n//  (0, 0, 0, 0): clears the plane in all cases\nint ncplane_erase_region(struct ncplane* n, int ystart, int xstart,\n                         int ylen, int xlen);\n```\n\nAll planes, including the standard plane, are created with scrolling disabled.\nAttempting to print past the end of a line will stop at the plane boundary,\nand indicate an error. On a plane 10 columns wide and two rows high, printing\n\"0123456789\" at the origin should succeed, but printing \"01234567890\" will by\ndefault fail at the eleventh character. In either case, the cursor will be left\nat location 0x10; it must be moved before further printing can take place. If\nscrolling is enabled, the first row will be filled with 01234546789, the second\nrow will have 0 written to its first column, and the cursor will end up at 1x1.\nNote that it is still an error to manually attempt to move the cursor off-plane,\nor to specify off-plane output. Boxes do not scroll; attempting to draw a 2x11\nbox on our 2x10 plane will result in an error and no output. When scrolling is\nenabled, and output takes place while the cursor is past the end of the last\nrow, the first row is discarded, all other rows are moved up, the last row is\ncleared, and output begins at the beginning of the last row. This does not take\nplace until output is generated (i.e. it is possible to fill a plane when\nscrolling is enabled).\n\n```c\n// All planes are created with scrolling disabled. Scrolling can be dynamically\n// controlled with ncplane_set_scrolling(). Returns true if scrolling was\n// previously enabled, or false if it was disabled.\nbool ncplane_set_scrolling(struct ncplane* n, unsigned scrollp);\n\n// Returns true iff the plane is scrolling.\nbool ncplane_scrolling_p(const struct ncplane* n);\n\n// Effect |r| scroll events on the plane |n|. Returns an error if |n| is not\n// a scrolling plane, and otherwise returns the number of lines scrolled.\nint ncplane_scrollup(struct ncplane* n, int r);\n\n// Scroll |n| up until |child| is no longer hidden beneath it. Returns an\n// error if |child| is not a child of |n|, or |n| is not scrolling, or |child|\n// is fixed. Returns the number of scrolling events otherwise (might be 0).\nint ncplane_scrollup_child(struct ncplane* n, const struct ncplane* child);\n```\n\nPlanes can be freely resized, though they must retain a positive size in\nboth dimensions. The powerful `ncplane_resize()` allows resizing an `ncplane`,\nretaining all or a portion of the plane's existing content, and translating\nthe plane in one step. The helper function `ncplane_resize_simple()` allows\nresizing an `ncplane` without movement, retaining all possible data. To move\nthe plane without resizing it or changing its content, use `ncplane_move_yx()`.\nIt is an error to invoke these functions on the standard plane.\n\n```c\n// Resize the specified ncplane. The four parameters 'keepy', 'keepx',\n// 'keepleny', and 'keeplenx' define a subset of the ncplane to keep,\n// unchanged. This may be a region of size 0, though none of these four\n// parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane.\n// They must specify a coordinate within the ncplane's totality. 'yoff' and\n// 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner\n// of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the\n// ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny',\n// and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to\n// attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx'\n// is non-zero, both must be non-zero.\n//\n// Essentially, the kept material does not move. It serves to anchor the\n// resized plane. If there is no kept material, the plane can move freely.\nint ncplane_resize(struct ncplane* n, int keepy, int keepx, int keepleny,\n                   int keeplenx, int yoff, int xoff, int ylen, int xlen);\n\n// Resize the plane, retaining what data we can (everything, unless we're\n// shrinking in some dimension). Keep the origin where it is.\nstatic inline int\nncplane_resize_simple(struct ncplane* n, int ylen, int xlen){\n  int oldy, oldx;\n  ncplane_dim_yx(n, &oldy, &oldx); // current dimensions of 'n'\n  int keepleny = oldy > ylen ? ylen : oldy;\n  int keeplenx = oldx > xlen ? xlen : oldx;\n  return ncplane_resize(n, 0, 0, keepleny, keeplenx, 0, 0, ylen, xlen);\n}\n\n// Move this plane relative to the standard plane, or the plane to which it is\n// bound (if it is bound to a plane). It is an error to attempt to move the\n// standard plane.\nint ncplane_move_yx(struct ncplane* n, int y, int x);\n\n// Move this plane relative to its current location. Negative values move up\n// and left, respectively. Pass 0 to hold an axis constant.\n__attribute__ ((nonnull (1))) static inline int\nncplane_move_rel(struct ncplane* n, int y, int x){\n  int oy, ox;\n  ncplane_yx(n, &oy, &ox);\n  return ncplane_move_yx(n, oy + y, ox + x);\n}\n\n// Get the origin of plane 'n' relative to its bound plane, or its pile (if\n// 'n' is a root plane).\nvoid ncplane_yx(const struct ncplane* n, int* restrict y, int* restrict x);\nint ncplane_y(const struct ncplane* n);\nint ncplane_x(const struct ncplane* n);\n\n// Get the origin of plane 'n' relative to its pile. Either or both of 'x' and\n// 'y' may be NULL.\nvoid ncplane_abs_yx(const struct ncplane* n, int* y, int* x);\nint ncplane_abs_y(const struct ncplane* n);\nint ncplane_abs_x(const struct ncplane* n);\n\n// Return the dimensions of this ncplane.\nvoid ncplane_dim_yx(struct ncplane* n, unsigned* restrict rows, unsigned* restrict cols);\n\nstatic inline unsigned\nncplane_dim_y(const struct ncplane* n){\n  int dimy;\n  ncplane_dim_yx(n, &dimy, NULL);\n  return dimy;\n}\n\nstatic inline unsigned\nncplane_dim_x(const struct ncplane* n){\n  int dimx;\n  ncplane_dim_yx(n, NULL, &dimx);\n  return dimx;\n}\n\n// Retrieve pixel geometry for the display region ('pxy', 'pxx'), each cell\n// ('celldimy', 'celldimx'), and the maximum displayable bitmap ('maxbmapy',\n// 'maxbmapx'). If bitmaps are not supported, 'maxbmapy' and 'maxbmapx' will\n// be 0. Any of the geometry arguments may be NULL.\nvoid ncplane_pixel_geom(struct ncplane* n,\n                        unsigned* restrict pxy, unsigned* restrict pxx,\n                        unsigned* restrict celldimy, unsigned* restrict celldimx,\n                        unsigned* restrict maxbmapy, unsigned* restrict maxbmapx);\n\n// provided a coordinate relative to the origin of 'src', map it to the same\n// absolute coordinate relative to the origin of 'dst'. either or both of 'y'\n// and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane.\nvoid ncplane_translate(const struct ncplane* src, const struct ncplane* dst,\n                       int* restrict y, int* restrict x);\n\n// Fed absolute 'y'/'x' coordinates, determine whether that coordinate is\n// within the ncplane 'n'. If not, return false. If so, return true. Either\n// way, translate the absolute coordinates relative to 'n'. If the point is not\n// within 'n', these coordinates will not be within the dimensions of the plane.\nbool ncplane_translate_abs(const struct ncplane* n, int* restrict y, int* restrict x);\n```\n\nNormally, when text reaches the end of a plane (the horizontal end unless\nscrolling is enabled, and the vertical end otherwise), more cannot be written.\nIf a plane is autogrowing, it will be enlarged to accommodate the extra text.\nIf it is scrolling, it will be enlarged down; it will otherwise be enlarged\nright. Note that attempting to explicitly move the cursor outside the plane is\nstill an error. The growth occurs when text is written, *not* when the cursor\nis moved.\n\n```c\n// By default, planes are created with autogrow disabled. Autogrow can be\n// dynamically controlled with ncplane_set_autogrow(). Returns true if\n// autogrow was previously enabled, or false if it was disabled.\nAPI bool ncplane_set_autogrow(struct ncplane* n, unsigned growp);\n\nAPI bool ncplane_autogrow_p(const struct ncplane* n);\n```\n\nIf a given cell's glyph is zero, or its foreground channel is fully transparent,\nit is considered to have no foreground. A _default_ cell can be chosen for the\n`ncplane`, to be consulted in this case. If the base cell's glyph is likewise\nzero (or its foreground channel fully transparent), the plane's foreground is\nnot rendered. Note that the base cell, like every other cell, has its own\nforeground and background channels.\n\n```c\nuint16_t ncplane_styles(const struct ncplane* n);**\n\n// Set the specified style bits for the ncplane 'n', whether they're actively\n// supported or not.\nvoid ncplane_set_styles(struct ncplane* n, unsigned stylebits);\n\n// Add the specified styles to the ncplane's existing spec.\nvoid ncplane_on_styles(struct ncplane* n, unsigned stylebits);\n\n// Remove the specified styles from the ncplane's existing spec.\nvoid ncplane_off_styles(struct ncplane* n, unsigned stylebits);\n\n// Set the ncplane's base nccell to 'c'. The base cell is used for purposes of\n// rendering anywhere that the ncplane's gcluster is 0. Note that the base cell\n// is not affected by ncplane_erase(). 'c' must not be a secondary cell from a\n// multicolumn EGC.\nint ncplane_set_base_cell(struct ncplane* n, const nccell* c);\n\n// Set the ncplane's base nccell. It will be used for purposes of rendering\n// anywhere that the ncplane's gcluster is 0. Note that the base cell is not\n// affected by ncplane_erase(). 'egc' must be an extended grapheme cluster.\nint ncplane_set_base(struct ncplane* n, const char* egc,\n                     uint16_t stylemask, uint64_t channels);\n\n// Extract the ncplane's base cell into 'c'. The reference is invalidated if\n// 'ncp' is destroyed.\nint ncplane_base(struct ncplane* ncp, nccell* c);\n```\n\n`ncplane`s are completely ordered along an imaginary z-axis. Newly-created\n`ncplane`s are on the top of the stack. They can be freely reordered.\n\n```c\n// Splice ncplane 'n' out of the z-buffer, and reinsert it at the top or bottom.\n__attribute__ ((nonnull (1)))\nstatic inline void\nncplane_move_top(struct ncplane* n){\n  ncplane_move_below(n, NULL);\n}\n\n__attribute__ ((nonnull (1)))\nstatic inline void\nncplane_move_bottom(struct ncplane* n){\n  ncplane_move_above(n, NULL);\n}\n\n// Splice ncplane 'n' and its bound planes out of the z-buffer, and reinsert\n// them at the top or bottom. Relative order will be maintained between the\n// reinserted planes. For a plane E bound to C, with z-ordering A B C D E,\n// moving the C family to the top results in C E A B D, while moving it to\n// the bottom results in A B D C E.\nvoid ncplane_move_family_top(struct ncplane* n);\nvoid ncplane_move_family_bottom(struct ncplane* n);\n\n// Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'.\n// Returns non-zero if 'n' is already in the desired location. 'n' and\n// 'above' must not be the same plane. If 'above' is NULL, 'n' is moved\n// to the bottom of its pile.\nint ncplane_move_above(struct ncplane* RESTRICT n,\n                       struct ncplane* RESTRICT above);\n\n// Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'.\n// Returns non-zero if 'n' is already in the desired location. 'n' and\n// 'below' must not be the same plane. If 'below' is NULL, 'n' is moved to\n// the top of its pile.\nint ncplane_move_below(struct ncplane* RESTRICT n,\n                       struct ncplane* RESTRICT below);\n\nint ncplane_move_family_above(struct ncplane* RESTRICT n,\n                              struct ncplane* RESTRICT above);\n\nint ncplane_move_family_below(struct ncplane* RESTRICT n,\n                              struct ncplane* RESTRICT below);\n\n// Return the ncplane below this one, or NULL if this is at the stack's bottom.\nstruct ncplane* ncplane_below(struct ncplane* n);\n\n// Return the ncplane above this one, or NULL if this is at the stack's top.\nstruct ncplane* ncplane_above(struct ncplane* n);\n\n// Return the topmost plane of the pile containing 'n'.\nstruct ncplane* ncpile_top(struct ncplane* n);\n\n// Return the bottommost plane of the pile containing 'n'.\nstruct ncplane* ncpile_bottom(struct ncplane* n);\n```\n\nEach plane holds a user pointer which can be retrieved and set (or ignored). In\naddition, the plane's virtual framebuffer can be accessed (note that this does\nnot necessarily reflect anything on the actual screen).\n\n```c\n// Retrieve the current contents of the cell under the cursor. The EGC is\n// returned, or NULL on error. This EGC must be free()d by the caller. The\n// styles and channels are written to 'styles' and 'channels', respectively.\nchar* ncplane_at_cursor(struct ncplane* n, uint16_t* styles, uint64_t* channels);\n\n// Retrieve the current contents of the cell under the cursor into 'c'. This\n// cell is invalidated if the associated plane is destroyed.\nint ncplane_at_cursor_cell(struct ncplane* n, nccell* c);\n\n// Retrieve the current contents of the specified cell. The EGC is returned, or\n// NULL on error. This EGC must be free()d by the caller. The stylemask and\n// channels are written to 'stylemask' and 'channels', respectively. The return\n// represents how the cell will be used during rendering, and thus integrates\n// any base cell where appropriate. If called upon the secondary columns of a\n// wide glyph, the EGC will be returned (i.e. this function does not distinguish\n// between the primary and secondary columns of a wide glyph).\nchar* ncplane_at_yx(const struct ncplane* n, int y, int x,\n                    uint16_t* stylemask, uint64_t* channels);\n\n// Retrieve the current contents of the specified cell into 'c'. This cell is\n// invalidated if the associated plane is destroyed. Returns the number of\n// bytes in the EGC, or -1 on error. Unlike ncplane_at_yx(), when called upon\n// the secondary columns of a wide glyph, the return can be distinguished from\n// the primary column (nccell_wide_right_p(c) will return true).\nint ncplane_at_yx_cell(struct ncplane* n, int y, int x, nccell* c);\n\n// Create an RGBA flat array from the selected region of the ncplane 'nc'.\n// Start at the plane's 'begy'x'begx' coordinate (which must lie on the\n// plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and\n// 'lenx' can be specified as 0 to go through the boundary of the plane.\n// Only glyphs from the specified blitset may be present. If 'pxdimy' and/or\n// 'pxdimx' are non-NULL, they will be filled in with the pixel geometry.\nuint32_t* ncplane_as_rgba(const struct ncplane* n, ncblitter_e blit,\n                          unsigned begy, unsigned begx, unsigned leny,\n                          unsigned lenx, unsigned* pxdimy, unsigned* pxdimx);\n\n// Create a flat string from the EGCs of the selected region of the ncplane\n// 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the\n// plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and\n// 'lenx' can be specified as 0 to go through the boundary of the plane.\n// -1 can be specified for 'begx'/'begy' to use the current cursor location.\nchar* ncplane_contents(const struct ncplane* nc, int begy, int begx,\n                       unsigned leny, unsigned lenx);\n\n// Manipulate the opaque user pointer associated with this plane.\n// ncplane_set_userptr() returns the previous userptr after replacing\n// it with 'opaque'. the others simply return the userptr.\nvoid* ncplane_set_userptr(struct ncplane* n, void* opaque);\nvoid* ncplane_userptr(struct ncplane* n);\n```\n\nAll output is to `ncplane`s. There is no cost in moving the cursor around the\nvirtual framebuffer. Output that's never rendered still has some memory transfer\ncost as the virtual framebuffer is prepared, but new data overwrites it in\nmemory.\n\n```c\n// Move the cursor to the specified position (the cursor needn't be visible).\n// Pass -1 as either coordinate to hold that axis constant. Returns -1 if the\n// move would place the cursor outside the plane.\nint ncplane_cursor_move_yx(struct ncplane* n, int y, int x);\n\n// Move the cursor relative to the current cursor position (the cursor needn't\n// be visible). Returns -1 on error, including target position exceeding the\n// plane's dimensions.\nint ncplane_cursor_move_rel(struct ncplane* n, int y, int x);\n\n// Get the current position of the cursor within n. y and/or x may be NULL.\nvoid ncplane_cursor_yx(const struct ncplane* n, int* restrict y, int* restrict x);\n\nstatic inline unsigned\nncplane_cursor_y(const struct ncplane* n){\n  unsigned y;\n  ncplane_cursor_yx(n, &y, NULL);\n  return y;\n}\n\nstatic inline unsigned\nncplane_cursor_x(const struct ncplane* n){\n  unsigned x;\n  ncplane_cursor_yx(n, NULL, &x);\n  return x;\n}\n\n// Replace the cell at the specified coordinates with the provided cell 'c',\n// and advance the cursor by the width of the cell (but not past the end of the\n// plane). On success, returns the number of columns the cursor was advanced.\n// On failure, -1 is returned.\nint ncplane_putc_yx(struct ncplane* n, int y, int x, const nccell* c);\n\n// Call ncplane_putc_yx() for the current cursor location.\nstatic inline int\nncplane_putc(struct ncplane* n, const nccell* c){\n  return ncplane_putc_yx(n, -1, -1, c);\n}\n\n// Replace the nccell at the specified coordinates with the provided 7-bit char\n// 'c'. Advance the cursor by 1. On success, returns 1. On failure, returns -1.\n// This works whether the underlying char is signed or unsigned.\nstatic inline int\nncplane_putchar_yx(struct ncplane* n, int y, int x, char c){\n  nccell ce = CELL_INITIALIZER(c, ncplane_styles(n), ncplane_channels(n));\n  return ncplane_putc_yx(n, y, x, &ce);\n}\n\n// Call ncplane_putchar_yx() at the current cursor location.\nstatic inline int\nncplane_putchar(struct ncplane* n, char c){\n  return ncplane_putchar_yx(n, -1, -1, c);\n}\n\n// Replace the EGC underneath us, but retain the styling. The current styling\n// of the plane will not be changed.\nint ncplane_putchar_stained(struct ncplane* n, char c);\n\n// Replace the nccell at the specified coordinates with the provided wide char\n// 'w'. Advance the cursor by the character's width as reported by wcwidth().\n// On success, returns the number of columns written. On failure, returns -1.\nstatic inline int\nncplane_putwc_yx(struct ncplane* n, int y, int x, wchar_t w){\n  wchar_t warr[2] = { w, L'\\0' };\n  return ncplane_putwstr_yx(n, y, x, warr);\n}\n\n// Call ncplane_putwc() at the current cursor position.\nstatic inline int\nncplane_putwc(struct ncplane* n, wchar_t w){\n  return ncplane_putwc_yx(n, -1, -1, w);\n}\n\n// Replace the cell at the specified coordinates with the provided EGC, and\n// advance the cursor by the width of the cluster (but not past the end of the\n// plane). On success, returns the number of columns the cursor was advanced.\n// On failure, -1 is returned. The number of bytes converted from gclust is\n// written to 'sbytes' if non-NULL.\nint ncplane_putegc_yx(struct ncplane* n, int y, int x, const char* gclust, int* sbytes);\n\n// Call ncplane_putegc() at the current cursor location.\nstatic inline int\nncplane_putegc(struct ncplane* n, const char* gclust, int* sbytes){\n  return ncplane_putegc_yx(n, -1, -1, gclust, sbytes);\n}\n\n// Replace the EGC underneath us, but retain the styling. The current styling\n// of the plane will not be changed.\nint ncplane_putegc_stained(struct ncplane* n, const char* gclust, int* sbytes);\n\n#define WCHAR_MAX_UTF8BYTES 6\n\n// ncplane_putegc(), but following a conversion from wchar_t to UTF-8 multibyte.\nstatic inline int\nncplane_putwegc(struct ncplane* n, const wchar_t* gclust, int* sbytes){\n  // maximum of six UTF8-encoded bytes per wchar_t\n  const size_t mbytes = (wcslen(gclust) * WCHAR_MAX_UTF8BYTES) + 1;\n  char* mbstr = (char*)malloc(mbytes); // need cast for c++ callers\n  if(mbstr == NULL){\n    return -1;\n  }\n  size_t s = wcstombs(mbstr, gclust, mbytes);\n  if(s == (size_t)-1){\n    free(mbstr);\n    return -1;\n  }\n  int ret = ncplane_putegc(n, mbstr, sbytes);\n  free(mbstr);\n  return ret;\n}\n\n// Call ncplane_putwegc() after successfully moving to y, x.\nstatic inline int\nncplane_putwegc_yx(struct ncplane* n, int y, int x, const wchar_t* gclust,\n                   int* sbytes){\n  if(ncplane_cursor_move_yx(n, y, x)){\n    return -1;\n  }\n  return ncplane_putwegc(n, gclust, sbytes);\n}\n\n// Replace the EGC underneath us, but retain the styling. The current styling\n// of the plane will not be changed.\nint ncplane_putwegc_stained(struct ncplane* n, const wchar_t* gclust, int* sbytes);\n\n// Write a series of EGCs to the current location, using the current style.\n// They will be interpreted as a series of columns (according to the definition\n// of ncplane_putc()). Advances the cursor by some positive number of columns\n// (though not beyond the end of the plane); this number is returned on success.\n// On error, a non-positive number is returned, indicating the number of columns\n// which were written before the error.\nint ncplane_putstr_yx(struct ncplane* n, int y, int x, const char* gclusters);\n\nstatic inline int\nncplane_putstr(struct ncplane* n, const char* gclustarr){\n  return ncplane_putstr_yx(n, -1, -1, gclustarr);\n}\n\nint ncplane_putstr_aligned(struct ncplane* n, int y, ncalign_e align, const char* s);\n\n// Replace a string's worth of glyphs at the current cursor location, but\n// retain the styling. The current styling of the plane will not be changed.\nint ncplane_putstr_stained(struct ncplane* n, const char* s);\n\n// ncplane_putstr(), but following a conversion from wchar_t to UTF-8 multibyte.\nstatic inline int\nncplane_putwstr_yx(struct ncplane* n, int y, int x, const wchar_t* gclustarr){\n  // maximum of six UTF8-encoded bytes per wchar_t\n  const size_t mbytes = (wcslen(gclustarr) * WCHAR_MAX_UTF8BYTES) + 1;\n  char* mbstr = (char*)malloc(mbytes); // need cast for c++ callers\n  if(mbstr == NULL){\n    return -1;\n  }\n  size_t s = wcstombs(mbstr, gclustarr, mbytes);\n  if(s == (size_t)-1){\n    free(mbstr);\n    return -1;\n  }\n  int ret = ncplane_putstr_yx(n, y, x, mbstr);\n  free(mbstr);\n  return ret;\n}\n\n// Write a series of EGCs to the current location, using the current style.\n// They will be interpreted as a series of columns (according to the definition\n// of ncplane_putc()). Advances the cursor by some positive number of columns\n// (though not beyond the end of the plane); this number is returned on success.\n// On error, a non-positive number is returned, indicating the number of columns\n// which were written before the error. No more than 's' bytes will be written.\nint ncplane_putnstr_yx(struct ncplane* n, int y, int x, size_t s, const char* gclusters);\n\nstatic inline int\nncplane_putnstr(struct ncplane* n, size_t s, const char* gclustarr){\n  return ncplane_putnstr_yx(n, -1, -1, s, gclustarr);\n}\n\nint ncplane_putnstr_aligned(struct ncplane* n, int y, ncalign_e align,\n                            size_t s, const char* s);\n\nstatic inline int\nncplane_putwstr_aligned(struct ncplane* n, int y, ncalign_e align,\n                        const wchar_t* gclustarr){\n  int width = wcswidth(gclustarr, INT_MAX);\n  int xpos = ncplane_align(n, align, width);\n  return ncplane_putwstr_yx(n, y, xpos, gclustarr);\n}\n\nstatic inline int\nncplane_putwstr(struct ncplane* n, const wchar_t* gclustarr){\n  return ncplane_putwstr_yx(n, -1, -1, gclustarr);\n}\n\n// The ncplane equivalents of printf(3) and vprintf(3).\nint ncplane_vprintf_aligned(struct ncplane* n, int y, ncalign_e align,\n                            const char* format, va_list ap);\n\nint ncplane_vprintf_yx(struct ncplane* n, int y, int x,\n                       const char* format, va_list ap);\n\nstatic inline int\nncplane_vprintf(struct ncplane* n, const char* format, va_list ap){\n  return ncplane_vprintf_yx(n, -1, -1, format, ap);\n}\n\nstatic inline int\nncplane_printf(struct ncplane* n, const char* format, ...)\n  __attribute__ ((format (printf, 2, 3)));\n\nstatic inline int\nncplane_printf(struct ncplane* n, const char* format, ...){\n  va_list va;\n  va_start(va, format);\n  int ret = ncplane_vprintf(n, format, va);\n  va_end(va);\n  return ret;\n}\n\nstatic inline int\nncplane_printf_aligned(struct ncplane* n, int y, ncalign_e align,\n                       const char* format, ...)\n  __attribute__ ((format (printf, 4, 5)));\n\nstatic inline int\nncplane_printf_yx(struct ncplane* n, int y, int x, const char* format, ...){\n  va_list va;\n  va_start(va, format);\n  int ret = ncplane_vprintf_yx(n, y, x, format, va);\n  va_end(va);\n  return ret;\n}\n\nstatic inline int\nncplane_printf_yx(struct ncplane* n, int y, int x, const char* format, ...)\n  __attribute__ ((format (printf, 4, 5)));\n\nstatic inline int\nncplane_printf_aligned(struct ncplane* n, int y, ncalign_e align, const char* format, ...){\n  va_list va;\n  va_start(va, format);\n  int ret = ncplane_vprintf_aligned(n, y, align, format, va);\n  va_end(va);\n  return ret;\n}\n```\n\nMultiline chunks of human-readable text can be written with\n`ncplane_puttext()` even if the plane does not have scrolling enabled. Such\ntext will be broken up across lines using the Unicode line-breaking algorithm\nof [Unicode Annex #14](http://www.unicode.org/reports/tr14/tr14-34.html).\n\n```c\n// Write the specified text to the plane, breaking lines sensibly, beginning at\n// the specified line. Returns the number of columns written. When breaking a\n// line, the line will be cleared to the end of the plane (the last line will\n// *not* be so cleared). The number of bytes written from the input is written\n// to '*bytes' if it is not NULL. Cleared columns are included in the return\n// value, but *not* included in the number of bytes written. Leaves the cursor\n// at the end of output. A partial write will be accomplished as far as it can;\n// determine whether the write completed by inspecting '*bytes'.\nint ncplane_puttext(struct ncplane* n, int y, ncalign_e align,\n                    const char* text, size_t* bytes);\n```\n\nLines and boxes can be drawn, interpolating their colors between their two\nendpoints. For a line of a single color, be sure to specify the same channels\non both sides. Boxes allow fairly detailed specification of how they're drawn.\n\n```c\n// Draw horizontal or vertical lines using the specified cell, starting at the\n// current cursor position. The cursor will end at the cell following the last\n// cell output (even, perhaps counter-intuitively, when drawing vertical\n// lines), just as if ncplane_putc() was called at that spot. Return the\n// number of cells drawn on success. A length of 0 is an error.\nint ncplane_hline_interp(struct ncplane* n, const nccell* c,\n                         unsigned len, uint64_t c1, uint64_t c2);\n\nstatic inline int\nncplane_hline(struct ncplane* n, const nccell* c, unsigned len){\n  return ncplane_hline_interp(n, c, len, c->channels, c->channels);\n}\n\nint ncplane_vline_interp(struct ncplane* n, const nccell* c,\n                         unsigned len, uint64_t c1, uint64_t c2);\n\nstatic inline int\nncplane_vline(struct ncplane* n, const nccell* c, unsigned len){\n  return ncplane_vline_interp(n, c, len, c->channels, c->channels);\n}\n\n// Draw a box with its upper-left corner at the current cursor position, and its\n// lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the\n// upper-left, ur, ll, and lr corners, then the horizontal and vertical lines.\n// 'ctlword' is defined in the least significant byte, where bits [7, 4] are a\n// gradient mask, and [3, 0] are a border mask:\n//  * 7, 3: top\n//  * 6, 2: right\n//  * 5, 1: bottom\n//  * 4, 0: left\n// If the gradient bit is not set, the styling from the hl/vl cells is used for\n// the horizontal and vertical lines, respectively. If the gradient bit is set,\n// the color is linearly interpolated between the two relevant corner cells.\n//\n// By default, vertexes are drawn whether their connecting edges are drawn or\n// not. The value of the bits corresponding to NCBOXCORNER_MASK control this,\n// and are interpreted as the number of connecting edges necessary to draw a\n// given corner. At 0 (the default), corners are always drawn. At 3, corners\n// are never drawn (as at most 2 edges can touch a box's corner).\n\n#define NCBOXMASK_TOP    0x0001\n#define NCBOXMASK_RIGHT  0x0002\n#define NCBOXMASK_BOTTOM 0x0004\n#define NCBOXMASK_LEFT   0x0008\n#define NCBOXGRAD_TOP    0x0010\n#define NCBOXGRAD_RIGHT  0x0020\n#define NCBOXGRAD_BOTTOM 0x0040\n#define NCBOXGRAD_LEFT   0x0080\n#define NCBOXCORNER_MASK 0x0300\n#define NCBOXCORNER_SHIFT 8u\n\nint ncplane_box(struct ncplane* n, const nccell* ul, const nccell* ur,\n                const nccell* ll, const nccell* lr, const nccell* hline,\n                const cell* vline, int ystop, int xstop, unsigned ctlword);\n\n// Draw a box with its upper-left corner at the current cursor position, having\n// dimensions 'ylen'x'xlen'. See ncplane_box() for more information. The\n// minimum box size is 2x2, and it cannot be drawn off-screen.\nstatic inline int\nncplane_box_sized(struct ncplane* n, const nccell* ul, const nccell* ur,\n                  const nccell* ll, const nccell* lr, const nccell* hline,\n                  const nccell* vline, int ylen, int xlen, unsigned ctlword){\n  int y, x;\n  ncplane_cursor_yx(n, &y, &x);\n  return ncplane_box(n, ul, ur, ll, lr, hline, vline, y + ylen - 1,\n                     x + xlen - 1, ctlword);\n}\n\nstatic inline int\nncplane_perimeter(struct ncplane* n, const nccell* ul, const nccell* ur,\n                  const nccell* ll, const nccell* lr, const nccell* hline,\n                  const nccell* vline, unsigned ctlword){\n  if(ncplane_cursor_move_yx(n, 0, 0)){\n    return -1;\n  }\n  int dimy, dimx;\n  ncplane_dim_yx(n, &dimy, &dimx);\n  return ncplane_box_sized(n, ul, ur, ll, lr, hline, vline, dimy, dimx, ctlword);\n}\n\nstatic inline int\nncplane_rounded_box(struct ncplane* n, uint16_t attr, uint64_t channels,\n                    int ystop, int xstop, unsigned ctlword){\n  int ret = 0;\n  nccell ul = CELL_TRIVIAL_INITIALIZER, ur = CELL_TRIVIAL_INITIALIZER;\n  nccell ll = CELL_TRIVIAL_INITIALIZER, lr = CELL_TRIVIAL_INITIALIZER;\n  nccell hl = CELL_TRIVIAL_INITIALIZER, vl = CELL_TRIVIAL_INITIALIZER;\n  if((ret = nccells_rounded_box(n, attr, channels, &ul, &ur, &ll, &lr, &hl, &vl)) == 0){\n    ret = ncplane_box(n, &ul, &ur, &ll, &lr, &hl, &vl, ystop, xstop, ctlword);\n  }\n  nccell_release(n, &ul); nccell_release(n, &ur);\n  nccell_release(n, &ll); nccell_release(n, &lr);\n  nccell_release(n, &hl); nccell_release(n, &vl);\n  return ret;\n}\n\nstatic inline int\nncplane_rounded_box_sized(struct ncplane* n, uint16_t attr, uint64_t channels,\n                          int ylen, int xlen, unsigned ctlword){\n  int y, x;\n  ncplane_cursor_yx(n, &y, &x);\n  return ncplane_rounded_box(n, attr, channels, y + ylen - 1,\n                             x + xlen - 1, ctlword);\n}\n\nstatic inline int\nncplane_double_box(struct ncplane* n, uint16_t attr, uint64_t channels,\n                   int ystop, int xstop, unsigned ctlword){\n  int ret = 0;\n  nccell ul = CELL_TRIVIAL_INITIALIZER, ur = CELL_TRIVIAL_INITIALIZER;\n  nccell ll = CELL_TRIVIAL_INITIALIZER, lr = CELL_TRIVIAL_INITIALIZER;\n  nccell hl = CELL_TRIVIAL_INITIALIZER, vl = CELL_TRIVIAL_INITIALIZER;\n  if((ret = nccells_double_box(n, attr, channels, &ul, &ur, &ll, &lr, &hl, &vl)) == 0){\n    ret = ncplane_box(n, &ul, &ur, &ll, &lr, &hl, &vl, ystop, xstop, ctlword);\n  }\n  nccell_release(n, &ul); nccell_release(n, &ur);\n  nccell_release(n, &ll); nccell_release(n, &lr);\n  nccell_release(n, &hl); nccell_release(n, &vl);\n  return ret;\n}\n\nstatic inline int\nncplane_double_box_sized(struct ncplane* n, uint16_t attr, uint64_t channels,\n                         int ylen, int xlen, unsigned ctlword){\n  int y, x;\n  ncplane_cursor_yx(n, &y, &x);\n  return ncplane_double_box(n, attr, channels, y + ylen - 1,\n                            x + xlen - 1, ctlword);\n}\n```\n\nSimilarly, areas can be filled with a cell.\n\n```c\n// Starting at the specified coordinate, if its glyph is different from that of\n// 'c', 'c' is copied into it, and the original glyph is considered the fill\n// target. We do the same to all cardinally-connected cells having this same\n// fill target. Returns the number of cells polyfilled. An invalid initial y, x\n// is an error. Returns the number of cells filled, or -1 on error.\nint ncplane_polyfill_yx(struct ncplane* n, unsigned y, unsigned x, const nccell* c);\n\n// Draw a gradient with its upper-left corner at the position specified by 'y'/'x',\n// where -1 means the current cursor position in that dimension. The area is\n// specified by 'ylen'/'xlen', where 0 means \"everything remaining below or\n// to the right, respectively.\" The glyph composed of 'egc' and 'styles' is\n// used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr'\n// are composed into foreground and background gradients. To do a vertical\n// gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a\n// horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To\n// color everything the same, all four channels should be equivalent. The\n// resulting alpha values are equal to incoming alpha values. Returns the\n// number of cells filled on success, or -1 on failure.\nint ncplane_gradient(struct ncplane* n, int y, int x, unsigned ylen,\n                     unsigned xlen, const char* egc, uint16_t styles,\n                     uint64_t ul, uint64_t ur, uint64_t ll, uint64_t lr);\n\n// Do a high-resolution gradient using upper blocks and synced backgrounds.\n// This doubles the number of vertical gradations, but restricts you to\n// half blocks (appearing to be full blocks). Returns the number of cells\n// filled on success, or -1 on error.\nint ncplane_gradient2x1(struct ncplane* n, int y, int x, unsigned ylen,\n                        unsigned xlen, uint32_t ul, uint32_t ur,\n                        uint32_t ll, uint32_t lr);\n\n// Set the given style throughout the specified region, keeping content and\n// channels unchanged. The upper left corner is at 'y', 'x', and -1 may be\n// specified to indicate the cursor's position in that dimension. The area\n// is specified by 'ylen', 'xlen', and 0 may be specified to indicate everything\n// remaining to the right and below, respectively. It is an error for any\n// coordinate to be outside the plane. Returns the number of cells set,\n// or -1 on failure.\nint ncplane_format(struct ncplane* n, int y, int x, unsigned ylen,\n                   unsigned xlen, uint16_t stylemask);\n\n// Set the given channels throughout the specified region, keeping content and\n// channels unchanged. The upper left corner is at 'y', 'x', and -1 may be\n// specified to indicate the cursor's position in that dimension. The area\n// is specified by 'ylen', 'xlen', and 0 may be specified to indicate everything\n// remaining to the right and below, respectively. It is an error for any\n// coordinate to be outside the plane. Returns the number of cells set,\n// or -1 on failure.\nint ncplane_stain(struct ncplane* n, int y, int x, unsigned ylen,\n                  unsigned xlen, uint64_t ul, uint64_t ur,\n                  uint64_t ll, uint64_t lr);\n```\n\nMy 14 year-old self would never forgive me if we didn't have sweet palette\nfades. The simple fade API runs the operation over a time interval, adapting\nto the actual runtime, invoking a callback at each iteration.\n\n```c\n// Called for each fade iteration on 'ncp'. If anything but 0 is returned,\n// the fading operation ceases immediately, and that value is propagated out.\n// The recommended absolute display time target is passed in 'tspec'.\ntypedef int (*fadecb)(struct notcurses* nc, struct ncplane* ncp,\n                      const struct timespec*, void* curry);\n\n// Fade the ncplane out over the provided time, calling 'fader' at each\n// iteration. Requires a terminal which supports truecolor, or at least palette\n// modification (if the terminal uses a palette, our ability to fade planes is\n// limited, and affected by the complexity of the rest of the screen).\nint ncplane_fadeout(struct ncplane* n, const struct timespec* ts,\n                    fadecb fader, void* curry);\n\n// Fade the ncplane in over the specified time. Load the ncplane with the\n// target cells without rendering, then call this function. When it's done, the\n// ncplane will have reached the target levels, starting from zeroes.\nint ncplane_fadein(struct ncplane* n, const struct timespec* ts,\n                   fadecb fader, void* curry);\n\n// Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be\n// Pulse the plane in and out until the callback returns non-zero, relying on\n// the callback 'fader' to initiate rendering. 'ts' defines the half-period\n// (i.e. the transition from black to full brightness, or back again). Proper\n// use involves preparing (but not rendering) an ncplane, then calling\n// ncplane_pulse(), which will fade in from black to the specified colors.\nint ncplane_pulse(struct ncplane* n, const struct timespec* ts, fadecb fader, void* curry);\n\n```\n\nThe more flexible fade API allows for fine control of the process.\n\n```c\n// paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free().\nstruct ncfadectx* ncfadectx_setup(struct ncplane* n);\n\n// Return the number of iterations through which 'nctx' will fade.\nint ncfadectx_iterations(const struct ncfadectx* nctx);\n\n// Fade out through 'iter' iterations, where\n// 'iter' < 'ncfadectx_iterations(nctx)'.\nint ncplane_fadeout_iteration(struct ncplane* n, struct ncfadectx* nctx,\n                              int iter, fadecb fader, void* curry);\n\n// Fade in through 'iter' iterations, where\n// 'iter' < 'ncfadectx_iterations(nctx)'.\nint ncplane_fadein_iteration(struct ncplane* n, struct ncfadectx* nctx,\n                             int iter, fadecb fader, void* curry);\n\n// Release the resources associated with 'nctx'.\nvoid ncfadectx_free(struct ncfadectx* nctx);\n```\n\nRaw streams of RGBA or BGRx data can be blitted directly to an ncplane:\n\n```c\n// Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'vopts->n',\n// which mustn't be NULL. the blit begins at 'vopts->y' and 'vopts->x' relative\n// to the specified plane. Each source row ought occupy 'linesize' bytes (this\n// might be greater than 'vopts->lenx' * 4 due to padding or partial blits). A\n// subregion of the input can be specified with the 'begy'x'begx' and\n// 'leny'x'lenx' fields from 'vopts'. Returns the number of pixels blitted, or\n// -1 on error.\nint ncblit_rgba(const void* data, int linesize,\n                const struct ncvisual_options* vopts);\n\n// Same as ncblit_rgba(), but for RGBx, with 'alpha' supplied as an alpha value\n// throughout, 0 <= 'alpha' <= 255. linesize ought be a multiple of 4.\nint ncblit_rgb_loose(const void* data, int linesize,\n                     const struct ncvisual_options* vopts, int alpha);\n\n// Same as ncblit_rgba(), but for RGB, with 'alpha' supplied as an alpha value\n// throughout, 0 <= 'alpha' <= 255.\nint ncblit_rgb_packed(const void* data, int linesize,\n                      const struct ncvisual_options* vopts, int alpha);\n\n// Same as ncblit_rgba(), but for BGRx.\nint ncblit_bgrx(const void* data, int linesize,\n                const struct ncvisual_options* vopts);\n```\n\n### Plane channels API\n\nHelpers are provided to manipulate an `ncplane`'s `channels` member. They are\nall implemented in terms of the lower-level [Channels API](#channels).\n\n```c\n// Get the current colors and alpha values for ncplane 'n'.\nuint64_t ncplane_channels(const struct ncplane* n);\n\n// Get the current styling for the ncplane 'n'.\nuint16_t ncplane_styles(const struct ncplane* n);\n\n// Set the alpha and coloring bits of the plane's current channels from a\n// 64-bit pair of channels.\nAPI void ncplane_set_channels(struct ncplane* n, uint64_t channels)\n  __attribute__ ((nonnull (1)));\n\n// Extract the background alpha and coloring bits from a 64-bit channel\n// pair as a single 32-bit value.\nstatic inline uint32_t\nncplane_bchannel(const struct ncplane* n){\n  return ncchannels_bchannel(ncplane_channels(n));\n}\n\n// Extract the foreground alpha and coloring bits from a 64-bit channel\n// pair as a single 32-bit value.\nstatic inline uint32_t\nncplane_fchannel(const struct ncplane* n){\n  return ncchannels_fchannel(ncplane_channels(n));\n}\n\n// Set the background alpha and coloring bits of the plane's current\n// channels from a single 32-bit value.\nuint64_t ncplane_set_bchannel(struct ncplane* n, uint32_t channel);\n  __attribute__ ((nonnull (1)));\n\n// Set the foreground alpha and coloring bits of the plane's current\n// channels from a single 32-bit value.\nuint64_t ncplane_set_fchannel(struct ncplane* n, uint32_t channel);\n\n// Extract 24 bits of working foreground RGB from an ncplane, shifted to LSBs.\nstatic inline unsigned\nncplane_fg_rgb(const struct ncplane* nc){\n  return ncchannels_fg_rgb(ncplane_channels(nc));\n}\n\n// Extract 24 bits of working background RGB from an ncplane, shifted to LSBs.\nstatic inline unsigned\nncplane_bg_rgb(const struct ncplane* nc){\n  return ncchannels_bg_rgb(ncplane_channels(nc));\n}\n\n// Extract 2 bits of foreground alpha from 'struct ncplane', shifted to LSBs.\nstatic inline unsigned\nncplane_fg_alpha(const struct ncplane* nc){\n  return ncchannels_fg_alpha(ncplane_channels(nc));\n}\n\n// Extract 2 bits of background alpha from 'struct ncplane', shifted to LSBs.\nstatic inline unsigned\nncplane_bg_alpha(const struct ncplane* nc){\n  return ncchannels_bg_alpha(ncplane_channels(nc));\n}\n\n// Set the alpha parameters for ncplane 'n'.\nint ncplane_set_fg_alpha(struct ncplane* n, unsigned alpha);\nint ncplane_set_bg_alpha(struct ncplane* n, unsigned alpha);\n\n// Extract 24 bits of foreground RGB from 'n', split into subcomponents.\nstatic inline unsigned\nncplane_fg_rgb8(const struct ncplane* n, unsigned* r, unsigned* g, unsigned*\n  return ncchannels_fg_rgb8(ncplane_channels(n), r, g, b);\n}\n\n// Extract 24 bits of background RGB from 'n', split into subcomponents.\nstatic inline unsigned\nncplane_bg_rgb8(const struct ncplane* n, unsigned* r, unsigned* g, unsigned*\n  return ncchannels_bg_rgb8(ncplane_channels(n), r, g, b);\n}\n\n// Set the current fore/background color using RGB specifications. If the\n// terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\",\n// indicated by the \"RGB\" terminfo capability), the provided values will be\n// interpreted in some lossy fashion. None of r, g, or b may exceed 255.\n// \"HP-like\" terminals require setting foreground and background at the same\n// time using \"color pairs\"; Notcurses will manage color pairs transparently.\nint ncplane_set_fg_rgb8(struct ncplane* n, unsigned r, unsigned g, unsigned b);\nint ncplane_set_bg_rgb8(struct ncplane* n, unsigned r, unsigned g, unsigned b);\n\n// Same, but clipped to [0..255].\nvoid ncplane_set_bg_rgb8_clipped(struct ncplane* n, int r, int g, int b);\nvoid ncplane_set_fg_rgb8_clipped(struct ncplane* n, int r, int g, int b);\n\n// Same, but with rgb assembled into a channel (i.e. lower 24 bits).\nint ncplane_set_fg_rgb(struct ncplane* n, uint32_t channel);\nint ncplane_set_bg_rgb(struct ncplane* n, uint32_t channel);\n\n// Use the default color for the foreground/background.\nvoid ncplane_set_fg_default(struct ncplane* n);\nvoid ncplane_set_bg_default(struct ncplane* n);\n\n// Provide a palette index on [0..255].\nint ncplane_set_fg_palindex(struct ncplane* n, unsigned idx);\nint ncplane_set_bg_palindex(struct ncplane* n, unsigned idx);\n```\n\n## Cells\n\nUnlike the `notcurses` or `ncplane` objects, the definition of `nccell` is\navailable to the user. It is somewhat ironic, then, that the user typically\nneedn't (and shouldn't) use `nccell`s directly. Use an `nccell` when the EGC\nbeing output is used several times. In this case, time otherwise spent running\n`nccell_load()` (which tokenizes and verifies EGCs) can be saved. It can also\nbe useful to use an `nccell` when the same styling is used in a discontinuous\nmanner.\n\n```c\n// An nccell corresponds to a single character cell on some plane, which can be\n// occupied by a single grapheme cluster (some root spacing glyph, along with\n// possible combining characters, which might span multiple columns). At any\n// cell, we can have a theoretically arbitrarily long UTF-8 string, a foreground\n// color, a background color, and an attribute set. Valid grapheme cluster\n// contents include:\n//\n//  * A NUL terminator,\n//  * A single control character, followed by a NUL terminator,\n//  * At most one spacing character, followed by zero or more nonspacing\n//    characters, followed by a NUL terminator.\n//\n// Multi-column characters can only have a single style/color throughout.\n// Existence is suffering, and thus wcwidth() is not reliable. It's just\n// quoting whether or not the EGC contains a \"Wide Asian\" double-width\n// character. This is set for some things, like most emoji, and not set for\n// other things, like cuneiform. True display width is a *function of the\n// font and terminal*. Among the longest Unicode codepoints is\n//\n//    U+FDFD ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM ﷽\n//\n// wcwidth() rather optimistically claims this most exalted glyph to occupy\n// a single column. BiDi text is too complicated for me to even get into here.\n// Be assured there are no easy answers; ours is indeed a disturbing Universe.\n//\n// Each nccell occupies 16 static bytes (128 bits). The surface is thus ~1.6MB\n// for a (pretty large) 500x200 terminal. At 80x43, it's less than 64KB.\n// Dynamic requirements (the egcpool) can add up to 16MB to an ncplane, but\n// such large pools are unlikely in common use.\n//\n// We implement some small alpha compositing. Foreground and background both\n// have two bits of inverted alpha. The actual grapheme written to a cell is\n// the topmost non-zero grapheme. If its alpha is 00, its foreground color is\n// used unchanged. If its alpha is 10, its foreground color is derived entirely\n// from cells underneath it. Otherwise, the result will be a composite.\n// Likewise for the background. If the bottom of a coordinate's zbuffer is\n// reached with a cumulative alpha of zero, the default is used. In this way,\n// a terminal configured with transparent background can be supported through\n// multiple occluding ncplanes. A foreground alpha of 11 requests high-contrast\n// text (relative to the computed background). A background alpha of 11 is\n// currently forbidden.\n//\n// Default color takes precedence over palette or RGB, and cannot be used with\n// transparency. Indexed palette takes precedence over RGB. It cannot\n// meaningfully set transparency, but it can be mixed into a cascading color.\n// RGB is used if neither default terminal colors nor palette indexing are in\n// play, and fully supports all transparency options.\n//\n// This structure is exposed only so that most functions can be inlined. Do not\n// directly modify or access the fields of this structure; use the API.\ntypedef struct nccell {\n  // These 32 bits, together with the associated plane's associated egcpool,\n  // completely define this cell's EGC. Unless the EGC requires more than four\n  // bytes to encode as UTF-8, it will be inlined here. If more than four bytes\n  // are required, it will be spilled into the egcpool. In either case, there's\n  // a NUL-terminated string available without copying, because (1) the egcpool\n  // is all NUL-terminated sequences and (2) the fifth byte of this struct (the\n  // gcluster_backstop field, see below) is guaranteed to be zero, as are any\n  // unused bytes in gcluster.\n  //\n  // The gcluster + gcluster_backstop thus form a valid C string of between 0\n  // and 4 non-NUL bytes. Interpreting them in this fashion requires that\n  // gcluster be stored as a little-endian number (strings have no byte order).\n  // This gives rise to three simple rules:\n  //\n  //  * when storing to gcluster from a numeric, always use htole()\n  //  * when loading from gcluster for numeric use, always use htole()\n  //  * when referencing gcluster as a string, always use a pointer cast\n  //\n  // Uses of gcluster ought thus always have exactly one htole() or pointer\n  // cast associated with them, and we otherwise always work as host-endian.\n  //\n  // A spilled EGC is indicated by the value 0x01XXXXXX. This cannot alias a\n  // true supra-ASCII EGC, because UTF-8 only encodes bytes <= 0x80 when they\n  // are single-byte ASCII-derived values. The XXXXXX is interpreted as a 24-bit\n  // index into the egcpool. These pools may thus be up to 16MB.\n  //\n  // The cost of this scheme is that the character 0x01 (SOH) cannot be encoded\n  // in a nccell, which is absolutely fine because what 70s horseshit is SOH?\n  // It must not be allowed through the API, or havoc will result.\n  uint32_t gcluster;          // 4B → 4B little endian EGC\n  uint8_t gcluster_backstop;  // 1B → 5B (8 bits of zero)\n  // we store the column width in this field. for a multicolumn EGC of N\n  // columns, there will be N nccells, and each has a width of N...for now.\n  // eventually, such an EGC will set more than one subsequent cell to\n  // WIDE_RIGHT, and this won't be necessary. it can then be used as a\n  // bytecount. see #1203. FIXME iff width >= 2, the cell is part of a\n  // multicolumn glyph. whether a cell is the left or right side of the glyph\n  // can be determined by checking whether ->gcluster is zero.\n  uint8_t width;              // 1B → 6B (8 bits of EGC column width)\n  uint16_t stylemask;         // 2B → 8B (16 bits of NCSTYLE_* attributes)\n  // (channels & 0x8000000000000000ull): blitted to upper-left quadrant\n  // (channels & 0x4000000000000000ull): foreground is *not* \"default color\"\n  // (channels & 0x3000000000000000ull): foreground alpha (2 bits)\n  // (channels & 0x0800000000000000ull): foreground uses palette index\n  // (channels & 0x0400000000000000ull): blitted to upper-right quadrant\n  // (channels & 0x0200000000000000ull): blitted to lower-left quadrant\n  // (channels & 0x0100000000000000ull): blitted to lower-right quadrant\n  // (channels & 0x00ffffff00000000ull): foreground in 3x8 RGB (rrggbb)\n  // (channels & 0x0000000080000000ull): reserved, must be 0\n  // (channels & 0x0000000040000000ull): background is *not* \"default color\"\n  // (channels & 0x0000000030000000ull): background alpha (2 bits)\n  // (channels & 0x0000000008000000ull): background uses palette index\n  // (channels & 0x0000000007000000ull): reserved, must be 0\n  // (channels & 0x0000000000ffffffull): background in 3x8 RGB (rrggbb)\n  // At render time, these 24-bit values are quantized down to terminal\n  // capabilities, if necessary. There's a clear path to 10-bit support should\n  // we one day need it, but keep things cagey for now. \"default color\" is\n  // best explained by color(3NCURSES). ours is the same concept. until the\n  // \"not default color\" bit is set, any color you load will be ignored.\n  uint64_t channels;          // + 8B == 16B\n} nccell;\n\n#define NCALPHA_HIGHCONTRAST 0x30000000ull\n#define NCALPHA_TRANSPARENT  0x20000000ull\n#define NCALPHA_BLEND        0x10000000ull\n#define NCALPHA_OPAQUE       0x00000000ull\n```\n\n`nccell`s must be initialized with an initialization macro or `nccell_init()`\nbefore any other use. `nccell_init()` and `CELL_TRIVIAL_INITIALIZER` both\nsimply zero out the `nccell`.\n\n```c\n#define CELL_TRIVIAL_INITIALIZER { }\n#define CELL_CHAR_INITIALIZER(c) { .gcluster = (c), .gcluster_backstop = 0, .reserved = 0, .stylemask = 0, .channels = 0, }\n#define CELL_INITIALIZER(c, s, chan) { .gcluster = (c), .gcluster_backstop = 0, .reserved = 0, .stylemask = (s), .channels = (chan), }\n\nstatic inline void\nnccell_init(nccell* c){\n  memset(c, 0, sizeof(*c));\n}\n```\n\nAn `nccell` has three fundamental elements:\n\n* The EGC displayed at this coordinate, encoded in UTF-8. If the EGC is a\n  single ASCII character (value less than 0x80), it is stored inline in\n  the `nccell`'s `gcluster` field. Otherwise, `gcluster`'s top 24 bits\n  are a 128-biased offset into the associated `ncplane`'s egcpool. This\n  implies that `nccell`s are associated with `ncplane`s once prepared.\n* The Curses-style attributes of the text.\n* The 52 bits of foreground and background RGBA (2x8/8/8/2), plus a few flags.\n\nThe EGC should be loaded using `nccell_load()`. Either a single NUL-terminated\nEGC can be provided, or a string composed of multiple EGCs. In the latter case,\nthe first EGC from the string is loaded. Remember, backing storage for the EGC\nis provided by the `ncplane` passed to `nccell_load()`; if this `ncplane` is\ndestroyed (or even erased), the `nccell` cannot safely be used. If you're done\nusing the `nccell` before being done with the `ncplane`, call `nccell_release()`\nto free up the EGC resources.\n\n```c\n// Breaks the UTF-8 string in 'gcluster' down, setting up the nccell 'c'.\n// Returns the number of bytes copied out of 'gcluster', or -1 on failure. The\n// styling of the cell is left untouched, but any resources are released.\nint nccell_load(struct ncplane* n, nccell* c, const char* gcluster);\n\n// nccell_load(), plus blast the styling with 'attr' and 'channels'.\nstatic inline int\nnccell_prime(struct ncplane* n, nccell* c, const char* gcluster,\n             uint16_t stylemask, uint64_t channels){\n  c->stylemask = stylemask;\n  c->channels = channels;\n  int ret = nccell_load(n, c, gcluster);\n  return ret;\n}\n\n// Duplicate 'c' into 'targ'. Not intended for external use; exposed for the\n// benefit of unit tests.\nint nccell_duplicate(struct ncplane* n, nccell* targ, const cell* c);\n\n// Release resources held by the cell 'c'.\nvoid nccell_release(struct ncplane* n, nccell* c);\n\n// return the number of columns occupied by 'c'. see ncstrwidth() for an\n// equivalent for multiple EGCs.\nstatic inline int\nnccell_cols(const nccell* c){\n  return c->width ? c->width : 1;\n}\n\n#define NCSTYLE_MASK      0xffffu\n#define NCSTYLE_ITALIC    0x0010u\n#define NCSTYLE_UNDERLINE 0x0008u\n#define NCSTYLE_UNDERCURL 0x0004u\n#define NCSTYLE_BOLD      0x0002u\n#define NCSTYLE_STRUCK    0x0001u\n#define NCSTYLE_NONE      0\n\n// copy the UTF8-encoded EGC out of the cell, whether simple or complex. the\n// result is not tied to the ncplane, and persists across erases / destruction.\nstatic inline char*\nnccell_strdup(const struct ncplane* n, const nccell* c){\n  return strdup(nccell_extended_gcluster(n, c));\n}\n\n// Set the specified style bits for the cell 'c', whether they're actively\n// supported or not. Only the lower 16 bits are meaningful.\nstatic inline void\nnccell_styles_set(nccell* c, unsigned stylebits){\n  c->stylemask = stylebits & NCSTYLE_MASK;\n}\n\n// Extract the style bits from the cell.\nstatic inline unsigned\nnccell_styles(const nccell* c){\n  return c->stylemask;\n}\n\n// Add the specified styles (in the LSBs) to the cell's existing spec, whether\n// they're actively supported or not.\nstatic inline void\nnccell_on_styles(nccell* c, unsigned stylebits){\n  c->stylemask |= (stylebits & NCSTYLE_MASK);\n}\n\n// Remove the specified styles (in the LSBs) from the cell's existing spec.\nstatic inline void\nnccell_off_styles(nccell* c, unsigned stylebits){\n  c->stylemask &= ~(stylebits & NCSTYLE_MASK);\n}\n\n// Is the cell part of a multicolumn element?\nstatic inline bool\nnccell_double_wide_p(const nccell* c){\n  return (c->width >= 2);\n}\n\n// Load a 7-bit char 'ch' into the nccell 'c'. Returns the number of bytes\n// used, or -1 on error.\nstatic inline int\nnccell_load_char(struct ncplane* n, nccell* c, char ch){\n  char gcluster[2];\n  gcluster[0] = ch;\n  gcluster[1] = '\\0';\n  return nccell_load(n, c, gcluster);\n}\n\n// Load a UTF-8 encoded EGC of up to 4 bytes into the nccell 'c'. Returns the\n// number of bytes used, or -1 on error.\nstatic inline int\nnccell_load_egc32(struct ncplane* n, nccell* c, uint32_t egc){\n  char gcluster[sizeof(egc) + 1];\n  egc = htole(egc);\n  memcpy(gcluster, &egc, sizeof(egc));\n  gcluster[4] = '\\0';\n  return nccell_load(n, c, gcluster);\n}\n\n// Load a UCS-32 codepoint into the nccell 'c'. Returns the number of bytes\n// used, or -1 on error.\nstatic inline int\nnccell_load_ucs32(struct ncplane* n, nccell* c, uint32_t u){\n  unsigned char utf8[WCHAR_MAX_UTF8BYTES];\n  if(notcurses_ucs32_to_utf8(&u, 1, utf8, sizeof(utf8)) < 0){\n    return -1;\n  }\n  uint32_t utf8asegc;\n  _Static_assert(WCHAR_MAX_UTF8BYTES == sizeof(utf8asegc));\n  memcpy(&utf8asegc, utf8, sizeof(utf8));\n  return nccell_load_egc32(n, c, utf8asegc);\n}\n\n// return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer\n// is invalidated by any further operation on the plane 'n', so...watch out!\nconst char* nccell_extended_gcluster(const struct ncplane* n, const nccell* c);\n\n// Returns true if the two nccells are distinct EGCs, attributes, or channels.\n// The actual egcpool index needn't be the same--indeed, the planes needn't even\n// be the same. Only the expanded EGC must be equal. The EGC must be bit-equal;\n// it would probably be better to test whether they're Unicode-equal FIXME.\nstatic inline bool\nnccellcmp(const struct ncplane* n1, const nccell* RESTRICT c1,\n          const struct ncplane* n2, const nccell* RESTRICT c2){\n  if(c1->stylemask != c2->stylemask){\n    return true;\n  }\n  if(c1->channels != c2->channels){\n    return true;\n  }\n  return strcmp(nccell_extended_gcluster(n1, c1), nccell_extended_gcluster(n2, c2));\n}\n\n// load up six cells with the EGCs necessary to draw a box. returns 0 on\n// success, -1 on error. on error, any cells this function might\n// have loaded before the error are nccell_release()d. There must be at least\n// six EGCs in gcluster.\nstatic inline int\nnccells_load_box(struct ncplane* n, uint16_t style, uint64_t channels,\n                 nccell* ul, nccell* ur, nccell* ll, nccell* lr,\n                 nccell* hl, nccell* vl, const char* gclusters){\n  int ulen;\n  if((ulen = nccell_prime(n, ul, gclusters, style, channels)) > 0){\n    if((ulen = nccell_prime(n, ur, gclusters += ulen, style, channels)) > 0){\n      if((ulen = nccell_prime(n, ll, gclusters += ulen, style, channels)) > 0){\n        if((ulen = nccell_prime(n, lr, gclusters += ulen, style, channels)) > 0){\n          if((ulen = nccell_prime(n, hl, gclusters += ulen, style, channels)) > 0){\n            if(nccell_prime(n, vl, gclusters + ulen, style, channels) > 0){\n              return 0;\n            }\n            nccell_release(n, hl);\n          }\n          nccell_release(n, lr);\n        }\n        nccell_release(n, ll);\n      }\n      nccell_release(n, ur);\n    }\n    nccell_release(n, ul);\n  }\n  return -1;\n}\n\n\nstatic inline int\nnccells_rounded_box(struct ncplane* n, uint16_t attr, uint64_t channels,\n                    nccell* ul, nccell* ur, nccell* ll, nccell* lr, nccell* hl, nccell* vl){\n  return nccells_load_box(n, attr, channels, ul, ur, ll, lr, hl, vl, \"╭╮╰╯─│\");\n}\n\nstatic inline int\nnccells_double_box(struct ncplane* n, uint16_t attr, uint64_t channels,\n                   nccell* ul, nccell* ur, nccell* ll, nccell* lr, nccell* hl, nccell* vl){\n  return nccells_load_box(n, attr, channels, ul, ur, ll, lr, hl, vl, \"╔╗╚╝═║\");\n}\n```\n\nIt is sometimes useful to find the number of bytes and columns represented by\na UTF-8 string. `ncstrwidth_valid()` returns -1 if it encounters an invalid\ncharacter, and the number of columns otherwise. Even if there is an error, if\n`validbytes` and/or `validwidth` are not `NULL`, the number of bytes and\ncolumns (respectively) consumed before error are returned via these parameters.\n\n```c\n// Returns the number of columns occupied by a the valid prefix of a multibyte\n// (UTF-8) string. If an invalid character is encountered, -1 will be returned,\n// and the number of valid bytes and columns will be written into *|validbytes|\n// and *|validwidth| (assuming them non-NULL). If the entire string is valid,\n// *|validbytes| and *|validwidth| reflect the entire string.\nint ncstrwidth_valid(const char* egcs, int* validbytes, int* validwidth);\n```\n\n### Cell channels API\n\nHelpers are provided to manipulate an `nccell`'s `channels` member. They are\nall implemented in terms of the lower-level [Channels API](#channels).\n\n```c\n// Extract the background alpha and coloring bits from a cell's channels\n// as a single 32-bit value.\nstatic inline uint32_t\nnccell_bchannel(const nccell* cl){\n  return ncchannels_bchannel(cl->channels);\n}\n\n// Extract the foreground alpha and coloring bits from a cell's channels\n// as a single 32-bit value.\nstatic inline uint32_t\nnccell_fchannel(const nccell* cl){\n  return ncchannels_fchannel(cl->channels);\n}\n\n// Extract 24 bits of foreground RGB from 'cl', shifted to LSBs.\nstatic inline uint32_t\nnccell_fg_rgb(const nccell* cl){\n  return ncchannels_fg_rgb(cl->channels);\n}\n\n// Extract 24 bits of background RGB from 'cl', shifted to LSBs.\nstatic inline uint32_t\nnccell_bg_rgb(const nccell* cl){\n  return ncchannels_bg_rgb(cl->channels);\n}\n\n// Extract 2 bits of foreground alpha from 'cl', shifted to LSBs.\nstatic inline unsigned\nnccell_fg_alpha(const nccell* cl){\n  return ncchannels_fg_alpha(cl->channels);\n}\n\n// Extract 2 bits of background alpha from 'cl', shifted to LSBs.\nstatic inline unsigned\nnccell_bg_alpha(const nccell* cl){\n  return ncchannels_bg_alpha(cl->channels);\n}\n\n// Extract 24 bits of foreground RGB from 'cl', split into subcell.\nstatic inline uint32_t\nnccell_fg_rgb8(const nccell* cl, unsigned* r, unsigned* g, unsigned* b){\n  return ncchannels_fg_rgb8(cl->channels, r, g, b);\n}\n\n// Extract 24 bits of background RGB from 'cl', split into subcell.\nstatic inline uint32_t\nnccell_bg_rgb8(const nccell* cl, unsigned* r, unsigned* g, unsigned* b){\n  return ncchannels_bg_rgb8(cl->channels, r, g, b);\n}\n\n// Set the r, g, and b cell for the foreground component of this 64-bit\n// 'cell' variable, and mark it as not using the default color.\nstatic inline int\nnccell_set_fg_rgb8(nccell* cl, unsigned r, unsigned g, unsigned b){\n  return ncchannels_set_fg_rgb8(&cl->channels, r, g, b);\n}\n\n// Same, but clipped to [0..255].\nstatic inline void\nnccell_set_fg_rgb8_clipped(nccell* cl, int r, int g, int b){\n  ncchannels_set_fg_rgb8_clipped(&cl->channels, r, g, b);\n}\n\n// Same, but with an assembled 24-bit RGB value.\nstatic inline int\nnccell_set_fg_rgb(nccell* c, uint32_t channel){\n  return ncchannels_set_fg_rgb(&c->channels, channel);\n}\n\n// Set the r, g, and b cell for the background component of this 64-bit\n// 'cell' variable, and mark it as not using the default color.\nstatic inline int\nnccell_set_bg_rgb8(nccell* cl, unsigned r, unsigned g, unsigned b){\n  return ncchannels_set_bg_rgb8(&cl->channels, r, g, b);\n}\n\n// Same, but clipped to [0..255].\nstatic inline void\nnccell_set_bg_rgb8_clipped(nccell* cl, int r, int g, int b){\n  ncchannels_set_bg_rgb8_clipped(&cl->channels, r, g, b);\n}\n\n// Same, but with an assembled 24-bit RGB value.\nstatic inline int\nnccell_set_bg_rgb(nccell* c, uint32_t channel){\n  return ncchannels_set_bg_rgb(&c->channels, channel);\n}\n\nstatic inline int\nnccell_set_fg_alpha(nccell* c, unsigned alpha){\n  return ncchannels_set_fg_alpha(&c->channels, alpha);\n}\n\nstatic inline int\nnccell_set_bg_alpha(nccell* c, unsigned alpha){\n  return ncchannels_set_bg_alpha(&c->channels, alpha);\n}\n\n// Is the foreground using the \"default foreground color\"?\nstatic inline bool\nnccell_fg_default_p(const nccell* cl){\n  return ncchannels_fg_default_p(cl->channels);\n}\n\n// Is the background using the \"default background color\"? The \"default\n// background color\" must generally be used to take advantage of\n// terminal-effected transparency.\nstatic inline bool\nnccell_bg_default_p(const nccell* cl){\n  return ncchannels_bg_default_p(cl->channels);\n}\n\n// Use the default color for the foreground.\nstatic inline void\nnccell_set_fg_default(nccell* c){\n  ncchannels_set_fg_default(&c->channels);\n}\n\n// Use the default color for the background.\nstatic inline void\nnccell_set_bg_default(nccell* c){\n  ncchannels_set_bg_default(&c->channels);\n}\n\n```\n\n## Reels\n\nncreels are a complex UI abstraction offered by notcurses, derived from my\nsimilar work in [outcurses](https://github.com/dankamongmen/ncreels#ncreels).\n\nThe ncreel is a UI abstraction supported by Notcurses in which\ndynamically-created and -destroyed toplevel entities (referred to as tablets)\nare arranged as if on a cylinder, allowing for infinite scrolling\n(infinite scrolling can be disabled, resulting in a rectangle rather than a\ncylinder). This works naturally with keyboard navigation, mouse scrolling wheels,\nand touchpads (including the capacitive touchscreens of modern cell phones).\nThe term \"reel\" derives from slot machines. An ncreel initially has\nno tablets; at any given time thereafter, it has zero or more tablets, and if\nthere is at least one tablet, one tablet is focused (and on-screen). If the\nlast tablet is removed, no tablet is focused. A tablet can support navigation\nwithin the tablet, in which case there is an in-tablet focus for the focused\ntablet, which can also move among elements within the tablet.\n\nThe ncreel object tracks the size of the screen, the size, number,\ninformation depth, and order of tablets, and the foci. It also draws the\noptional borders around tablets and the optional border of the reel itself. It\nknows nothing about the actual content of a tablet, save the number of lines it\noccupies at each information depth. The typical control flow is that an\napplication receives events (from the UI or other event sources), and calls\ninto Notcurses saying e.g. \"Tablet 2 now has 40 valid lines of information\".\nnotcurses might then call back into the application, asking it to draw some\nline(s) from some tablet(s) at some particular coordinate of that tablet's\nplane. Finally, control returns to the application, and the cycle starts anew.\n\nEach tablet might be wholly, partially, or not on-screen. Notcurses always\nplaces as much of the focused tablet as is possible on-screen (if the focused\ntablet has more lines than the actual reel does, it cannot be wholly on-screen.\nIn this case, the focused subelements of the tablet are always on-screen). The\nplacement of the focused tablet depends on how it was reached (when moving to\nthe next tablet, offscreen tablets are brought onscreen at the bottom. When\nmoving to the previous tablet, offscreen tablets are brought onscreen at the\ntop. When moving to an arbitrary tablet which is neither the next nor previous\ntablet, it will be placed in the center).\n\nThe controlling application can, at any time,\n\n* Insert a new tablet somewhere in the reel (possibly off-screen)\n* Delete a (possibly off-screen) tablet from the reel\n* Change focus to the next or previous tablet, bringing it on-screen if it is off\n* Change focus to some arbitrary other tablet, bringing it on-screen if it is off\n* Expand or collapse the information depth of a tablet\n* Change the content of a tablet, updating it if it is on-screen\n  * Remove content from a tablet, possibly resizing it, and possibly changing focus within the tablet\n  * Add content to the tablet, possibly resizing it, and possibly creating focus within the tablet\n* Navigate within the focused tablet\n* Create or destroy new planes atop the ncreel\n* Indicate that the screen has been resized or needs be redrawn\n\nA special case arises when moving among the tablets of a reel having multiple\ntablets, all of which fit entirely on-screen, and infinite scrolling is in use.\nNormally, upon moving to the next tablet from the bottommost tablet, the\n(offscreen) next tablet is pulled up into the bottom of the reel (the reverse\nis true when moving to the previous tablet from the topmost). When all tablets\nare onscreen with infinite scrolling, there are two possibilities: either the\nfocus scrolls (moving from the bottom tablet to the top tablet, for instance),\nor the reel scrolls (preserving order among the tablets, but changing their\norder on-screen). In this latter case, moving to the next tablet from the\nbottommost tablet results in the tablet which is gaining focus being brought to\nthe bottom of the screen from the top, and all other tablets moving up on the\nscreen. Moving to the previous tablet from the topmost tablet results in the\nbottommost tablet moving to the top of the screen, and all other tablets moving\ndown. This behavior matches the typical behavior precisely, and avoids a rude\nUI discontinuity when the tablets grow to fill the entire screen (or shrink to\nnot fill it). If it is not desired, however, scrolling of focus can be\nconfigured instead.\n\n```c\n// An ncreel is a Notcurses region devoted to displaying zero or more\n// line-oriented, contained tablets between which the user may navigate. If at\n// least one tablets exists, there is a \"focused tablet\". As much of the focused\n// tablet as is possible is always displayed. If there is space left over, other\n// tablets are included in the display. Tablets can come and go at any time, and\n// can grow or shrink at any time.\n//\n// This structure is amenable to line- and page-based navigation via keystrokes,\n// scrolling gestures, trackballs, scrollwheels, touchpads, and verbal commands.\n\n// is scrolling infinite (can one move down or up forever, or is an end\n// reached?). if true, 'circular' specifies how to handle the special case of\n// an incompletely-filled reel.\n#define NCREEL_OPTION_INFINITESCROLL 0x0001ull\n// is navigation circular (does moving down from the last tablet move to the\n// first, and vice versa)? only meaningful when infinitescroll is true. if\n// infinitescroll is false, this must be false.\n#define NCREEL_OPTION_CIRCULAR       0x0002ull\n\ntypedef struct ncreel_options {\n  // Notcurses can draw a border around the ncreel, and also around the\n  // component tablets. inhibit borders by setting all valid bits in the masks.\n  // partially inhibit borders by setting individual bits in the masks. the\n  // appropriate attr and pair values will be used to style the borders.\n  // focused and non-focused tablets can have different styles. you can instead\n  // draw your own borders, or forgo borders entirely.\n  unsigned bordermask; // bitfield; 1s will not be drawn (see bordermaskbits)\n  uint64_t borderchan; // attributes used for ncreel border\n  unsigned tabletmask; // bitfield; same as bordermask but for tablet borders\n  uint64_t tabletchan; // tablet border styling channel\n  uint64_t focusedchan;// focused tablet border styling channel\n  uint64_t flags;      // bitfield over NCREEL_OPTION_*\n} ncreel_options;\n\nstruct nctablet;\nstruct ncreel;\n\n// Take over the ncplane 'nc' and use it to draw a reel according to 'popts'.\n// The plane will be destroyed by ncreel_destroy(); this transfers ownership.\nstruct ncreel* ncreel_create(struct ncplane* n, const ncreel_options* popts)\n  __attribute__ ((nonnull (1)));\n\n// Returns the ncplane on which this ncreel lives.\nstruct ncplane* ncreel_plane(struct ncreel* pr);\n\n// Tablet draw callback, provided a tablet (from which the ncplane and userptr\n// may be extracted), and a bool indicating whether output ought be drawn from\n// the top (true) or bottom (false). Returns non-negative count of output lines,\n// which must be less than or equal to ncplane_dim_y(nctablet_plane(t)).\ntypedef int (*tabletcb)(struct nctablet* t, bool drawfromtop);\n\n// Add a new nctablet to the provided ncreel 'nr', having the callback object\n// 'opaque'. Neither, either, or both of 'after' and 'before' may be specified.\n// If neither is specified, the new tablet can be added anywhere on the reel.\n// If one or the other is specified, the tablet will be added before or after\n// the specified tablet. If both are specified, the tablet will be added to the\n// resulting location, assuming it is valid (after->next == before->prev); if\n// it is not valid, or there is any other error, NULL will be returned.\nstruct nctablet* ncreel_add(struct ncreel* nr, struct nctablet* after,\n                            struct nctablet* before, tabletcb cb, void* opaque);\n\n// Return the number of nctablets in the ncreel 'nr'.\nint ncreel_tabletcount(const struct ncreel* nr);\n\n// Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the\n// tablet cannot be found.\nint ncreel_del(struct ncreel* nr, struct nctablet* t);\n\n// Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and\n// tablets will be lain out, using the focused tablet as a fulcrum. Tablet\n// drawing callbacks will be invoked for each visible tablet.\nint ncreel_redraw(struct ncreel* nr);\n\n// Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns\n// true, and the input ought not be processed further. If it's irrelevant to\n// the reel, false is returned. Relevant inputs include:\n//  * a mouse click on a tablet (focuses tablet)\n//  * a mouse scrollwheel event (rolls reel)\n//  * up, down, pgup, or pgdown (navigates among items)\nbool ncreel_offer_input(struct ncreel* nr, const ncinput* ni);\n\n// Return the focused tablet, if any tablets are present. This is not a copy;\n// be careful to use it only for the duration of a critical section.\nstruct nctablet* ncreel_focused(struct ncreel* nr);\n\n// Change focus to the next tablet, if one exists\nstruct nctablet* ncreel_next(struct ncreel* nr);\n\n// Change focus to the previous tablet, if one exists\nstruct nctablet* ncreel_prev(struct ncreel* nr);\n\n// Destroy an ncreel allocated with ncreel_create().\nvoid ncreel_destroy(struct ncreel* nr);\n\n// Returns a pointer to a user pointer associated with this nctablet.\nvoid* nctablet_userptr(struct nctablet* t);\n\n// Access the ncplane associated with nctablet 't', if one exists.\nstruct ncplane* nctablet_plane(struct nctablet* t);\n```\n\n### ncreel examples\n\nLet's say we have a screen of 11 lines, and 3 tablets of one line each. Both\na screen border and tablet borders are in use. The tablets are A, B, and C.\nNo gap is in use between tablets. Xs indicate focus. If B currently has focus,\nand the next tablet is selected, the result would be something like:\n\n```\n -------------                         -------------\n | --------- |                         | --------- |\n | |   A   | |                         | |   A   | |\n | --------- |                         | --------- |\n | --------- | ---- \"next tablet\" ---> | --------- |\n | |XX B XX| |                         | |   B   | |\n | --------- |                         | --------- |\n | --------- |                         | --------- |\n | |   C   | |                         | |XX C XX| |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\nIf instead the previous tablet had been selected, we would of course get:\n\n```\n -------------                         -------------\n | --------- |                         | --------- |\n | |   A   | |                         | |XX A XX| |\n | --------- |                         | --------- |\n | --------- | ---- \"prev tablet\" ---> | --------- |\n | |XX B XX| |                         | |   B   | |\n | --------- |                         | --------- |\n | --------- |                         | --------- |\n | |   C   | |                         | |   C   | |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\nIf A instead has the focus, choosing the \"next tablet\" is trivial: the tablets\ndo not change, and focus shifts to B. If we choose the \"previous tablet\", there\nare three possibilities:\n\n* Finite scrolling: No change. The tablets stay in place. A remains focused.\n\n```\n -------------                         -------------\n | --------- |                         | --------- |\n | |XX A XX| |                         | |XX A XX| |\n | --------- |                         | --------- |\n | --------- | ---- \"prev tablet\" ---> | --------- |\n | |   B   | |     (finite scroll)     | |   B   | |\n | --------- |                         | --------- |\n | --------- |                         | --------- |\n | |   C   | |                         | |   C   | |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\n* Infinite scrolling with rotation: Focus shifts to C, which moves to the top:\n\n```\n -------------                         -------------\n | --------- |                         | --------- |\n | |XX A XX| |                         | |XX C XX| |\n | --------- |                         | --------- |\n | --------- | ---- \"prev tablet\" ---> | --------- |\n | |   B   | |  (infinite scroll with  | |   A   | |\n | --------- |        rotation)        | --------- |\n | --------- |                         | --------- |\n | |   C   | |                         | |   B   | |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\n* Infinite scrolling with focus rotation: Focus shifts to C, and moves to the bottom:\n\n```\n -------------                         -------------\n | --------- |                         | --------- |\n | |XX A XX| |                         | |   A   | |\n | --------- |                         | --------- |\n | --------- | ---- \"prev tablet\" ---> | --------- |\n | |   B   | |  (infinite scroll with  | |   B   | |\n | --------- |     focus rotation)     | --------- |\n | --------- |                         | --------- |\n | |   C   | |                         | |XX C XX| |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\nNow imagine us to have the same 3 tablets, but each is now 4 lines. It is\nimpossible to have two of these tablets wholly onscreen at once, let alone all\nthree. If we started with A focused and at the top, the result after all three\ntablets have grown will be:\n\n```\n -------------                         -------------\n | --------- |                         | --------- | A remains at the top, and\n | |XX A XX| |                         | |XXXXXXX| | is wholly on-screen. B is\n | --------- |                         | |XX A XX| | below it, but we can show\n | --------- | ---- \"grow tablet\" ---> | |XXXXXXX| | only the first two lines.\n | |   B   | |       A (focused)       | |XXXXXXX| | C has been pushed\n | --------- |                         | --------- | off-screen.\n | --------- |                         | --------- |\n | |   C   | |                         | |       | |\n | --------- |                         | |   B   | |\n -------------                         -------------\n```\n\nWhen a tablet is enlarged, it grows towards the nearest boundary, unless that\nwould result in the focused tablet being moved, in which case the growing\ntablet instead grows in the other direction (if the tablet is in the middle\nof the screen exactly, it grows down). There is one exception to this rule: if\nthe tablets are not making full use of the screen, growth is always down (the\nscreen is always filled from the top), even if it moves the focused tablet.\n\nA 12-line screen has three tablets: A (2 lines), B (1 line), C (1 line), filling\nthe screen exactly. B is focused, and grows two lines:\n\n```\n -------------                         -------------\n | --------- |                         | --------- | B grows down, since it is\n | |   A   | |                         | |   A   | | closer to the bottom (3\n | |       | |                         | |       | | lines) than the top (4\n | --------- | ---- \"grow tablet\" ---> | --------- | lines). C is pushed almost\n | --------- |       B (focused)       | --------- | entirely off-screen. A is\n | |XX B XX| |                         | |XXXXXXX| | untouched.\n | --------- |                         | |XX B XX| |\n | --------- |                         | |XXXXXXX| |\n | |   C   | |                         | --------- |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\nStarting with the same situation, A grows by 2 lines instead:\n\n```\n -------------                         -------------\n | --------- |                         | |       | | A grows up. It would have\n | |   A   | |                         | |   A   | | grown down, but that would\n | |       | |                         | |       | | have moved B, which has\n | --------- | ---- \"grow tablet\" ---> | --------- | the focus. B and C remain\n | --------- |     A (not focused)     | --------- | where they are; A moves\n | |XX B XX| |                         | |XX B XX| | partially off-screen.\n | --------- |                         | --------- |\n | --------- |                         | --------- |\n | |   C   | |                         | |   C   | |\n | --------- |                         | --------- |\n -------------                         -------------\n```\n\nIf we started with the same situation, and B grew by 7 lines, it would first\npush C entirely off-screen (B would then have four lines of text), and then\npush A off-screen. B would then have eight lines of text, the maximum on a\n12-line screen with both types of borders.\n\n## Widgets\n\nSelectors:\n\n```\n                              ╭──────────────────────────╮\n                              │This is the primary header│\n╭──────────────────────this is the secondary header──────╮\n│        ↑                                               │\n│ option1 Long text #1                                   │\n│ option2 Long text #2                                   │\n│ option3 Long text #3                                   │\n│ option4 Long text #4                                   │\n│ option5 Long text #5                                   │\n│ option6 Long text #6                                   │\n│        ↓                                               │\n╰────────────────────────────────────here's the footer───╯\n```\n\nMultiselectors:\n\n```\n                                                   ╭───────────────────╮\n                                                   │ short round title │\n╭now this secondary is also very, very, very outlandishly long, you see┤\n│  ↑                                                                   │\n│ ☐ Pa231 Protactinium-231 (162kg)                                     │\n│ ☐ U233 Uranium-233 (15kg)                                            │\n│ ☐ U235 Uranium-235 (50kg)                                            │\n│ ☒ Np236 Neptunium-236 (7kg)                                          │\n│ ☐ Np237 Neptunium-237 (60kg)                                         │\n│ ☐ Pu238 Plutonium-238 (10kg)                                         │\n│ ☐ Pu239 Plutonium-239 (10kg)                                         │\n│ ☒ Pu240 Plutonium-240 (40kg)                                         │\n│ ☐ Pu241 Plutonium-241 (13kg)                                         │\n│ ☐ Am241 Americium-241 (100kg)                                        │\n│  ↓                                                                   │\n╰────────────────────────press q to exit (there is sartrev(\"no exit\"))─╯\n```\n\nMenus:\n\n```\n  Schwarzgerät  File                                    Help\nxxxxxxxxxxxxxxxx╭─────────────╮xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx│New    Ctrl+n│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx│Open   Ctrl+o│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx│Close  Ctrl+c│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx├─────────────┤xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx│Quit   Ctrl+q│xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nxxxxxxxxxxxxxxxx╰─────────────╯xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n```\n\n### Plots\n\n**FIXME**\n\n### Readers\n\nncreaders provide freeform input in a (possibly multiline) region, supporting\noptional libreadline-style keybindings.\n\n```c\ntypedef struct ncreader_options {\n  uint64_t tchannels; // channels used for input\n  uint32_t tattrword; // attributes used for input\n  bool scroll; // allow more than the physical area's worth of input\n} ncreader_options;\n\n// takes ownership of 'n', destroying it on any error (ncreader_destroy()\n// otherwise destroys the ncplane).\nstruct ncreader* ncreader_create(struct ncplane* n, const ncreader_options* opts);\n\n// empty the ncreader of any user input, and home the cursor.\nint ncreader_clear(struct ncreader* n);\n\nstruct ncplane* ncreader_plane(struct ncreader* n);\n\n// Offer the input to the ncreader. If it's relevant, this function returns\n// true, and the input ought not be processed further. Almost all inputs\n// are relevant to an ncreader, save synthesized ones.\nbool ncreader_offer_input(struct ncreader* n, const ncinput* ni);\n\n// return a nul-terminated heap copy of the current (UTF-8) contents.\nchar* ncreader_contents(const struct ncreader* n);\n\n// destroy the reader and its bound plane(s). if 'contents' is not NULL, the\n// UTF-8 input will be heap-duplicated and written to 'contents'.\nvoid ncreader_destroy(struct ncreader* n, char** contents);\n```\n\n### Progbars\n\nProgress bars proceed linearly in any of four directions. The entirety of the\nprovided plane will be used -- any border should be provided by the caller on\nanother plane. The plane will not be erased; text preloaded into the plane\nwill be consumed by the progress indicator. The bar is redrawn for each\nprovided progress report (a double between 0 and 1), and can regress with\nlower values. The procession will take place along the longer dimension (at\nthe time of each redraw), with the horizontal length scaled by 2 for\npurposes of comparison. I.e. for a plane of 20 rows and 50 columns, the\nprogress will be to the right (50 > 40) or left with `OPTION_RETROGRADE`.\n\n```c\n// Takes ownership of the ncplane 'n', which will be destroyed by\n// ncprogbar_destroy(). The progress bar is initially at 0%.\nstruct ncprogbar* ncprogbar_create(struct ncplane* n, const ncprogbar_options* opts);\n\n// Return a reference to the ncprogbar's underlying ncplane.\n#define NCPROGBAR_OPTION_RETROGRADE        0x0001u // proceed left/down\n\ntypedef struct ncprogbar_options {\n  uint32_t ulchannel; // upper-left channel. in the context of a progress bar,\n  uint32_t urchannel; // \"up\" is the direction we are progressing towards, and\n  uint32_t blchannel; // \"bottom\" is the direction of origin. for monochromatic\n  uint32_t brchannel; // bar, all four channels ought be the same.\n  uint64_t flags;\n} ncprogbar_options;\n\nstruct ncplane* ncprogbar_plane(struct ncprogbar* n);\n\n// Set the progress bar's completion, a double 0 <= 'p' <= 1.\nint ncprogbar_set_progress(struct ncprogbar* n, double p);\n\n// Get the progress bar's completion, a double on [0, 1].\ndouble ncprogbar_progress(const struct ncprogbar* n);\n\n// Destroy the progress bar and its underlying ncplane.\nvoid ncprogbar_destroy(struct ncprogbar* n);\n```\n\n### Tabs\n\nTabbed widgets. The tab list is displayed at the top or at the bottom of the\nplane, and only one tab is visible at a time.\n\n```c\n// Display the tab list at the bottom instead of at the top of the plane\n#define NCTABBED_OPTION_BOTTOM 0x0001ull\n\ntypedef struct nctabbed_options {\n  uint64_t selchan; // channel for the selected tab header\n  uint64_t hdrchan; // channel for unselected tab headers\n  uint64_t sepchan; // channel for the tab separator\n  char* separator;  // separator string\n  uint64_t flags;   // bitmask of NCTABBED_OPTION_*\n} nctabbed_options;\n\n// Tab content drawing callback. Takes the tab it was associated to, the ncplane\n// on which tab content is to be drawn, and the user pointer of the tab.\n// It is called during nctabbed_redraw().\ntypedef void (*tabcb)(struct nctab* t, struct ncplane* ncp, void* curry);\n\n// Creates a new nctabbed widget, associated with the given ncplane 'n', and with\n// additional options given in 'opts'. When 'opts' is NULL, it acts as if it were\n// called with an all-zero opts. The widget takes ownership of 'n', and destroys\n// it when the widget is destroyed. Returns the newly created widget. Returns\n// NULL on failure, also destroying 'n'.\nstruct nctabbed* nctabbed_create(struct ncplane* n, const nctabbed_options* opts);\n\n// Destroy an nctabbed widget. All memory belonging to 'nt' is deallocated,\n// including all tabs and their names. The plane associated with 'nt' is also\n// destroyed. Calling this with NULL does nothing.\nvoid nctabbed_destroy(struct nctabbed* nt);\n\n// Redraw the widget. This calls the tab callback of the currently selected tab\n// to draw tab contents, and draws tab headers. The tab content plane is not\n// modified by this function, apart from resizing the plane is necessary.\nvoid nctabbed_redraw(struct nctabbed* nt);\n\n// Make sure the tab header of the currently selected tab is at least partially\n// visible. (by rotating tabs until at least one column is displayed)\n// Does nothing if there are no tabs.\nvoid nctabbed_ensure_selected_header_visible(struct nctabbed* nt);\n\n// Returns the currently selected tab, or NULL if there are no tabs.\nstruct nctab* nctabbed_selected(struct nctabbed* nt);\n\n// Returns the leftmost tab, or NULL if there are no tabs.\nstruct nctab* nctabbed_leftmost(struct nctabbed* nt);\n\n// Returns the number of tabs in the widget.\nint nctabbed_tabcount(struct nctabbed* nt);\n\n// Returns the plane associated to 'nt'.\nstruct ncplane* nctabbed_plane(struct nctabbed* nt);\n\n// Returns the tab content plane.\nstruct ncplane* nctabbed_content_plane(struct nctabbed* nt);\n\n// Returns the tab callback.\ntabcb nctab_cb(struct nctab* t)\n  __attribute__ ((nonnull (1)));\n\n// Returns the tab name. This is not a copy and it should not be stored.\nconst char* nctab_name(struct nctab* t);\n\n// Returns the width (in columns) of the tab's name.\nint nctab_name_width(struct nctab* t);\n\n// Returns the tab's user pointer.\nvoid* nctab_userptr(struct nctab* t);\n\n// Returns the tab to the right of 't'. This does not change which tab is selected.\nstruct nctab* nctab_next(struct nctab* t);\n\n// Returns the tab to the left of 't'. This does not change which tab is selected.\nstruct nctab* nctab_prev(struct nctab* t);\n\n// Add a new tab to 'nt' with the given tab callback, name, and user pointer.\n// If both 'before' and 'after' are NULL, the tab is inserted after the selected\n// tab. Otherwise, it gets put after 'after' (if not NULL) and before 'before'\n// (if not NULL). If both 'after' and 'before' are given, they must be two\n// neighboring tabs (the tab list is circular, so the last tab is immediately\n// before the leftmost tab), otherwise the function returns NULL. If 'name' is\n// NULL or a string containing illegal characters, the function returns NULL.\n// On all other failures the function also returns NULL. If it returns NULL,\n// none of the arguments are modified, and the widget state is not altered.\nstruct nctab* nctabbed_add(struct nctabbed* nt, struct nctab* after,\n                           struct nctab* before, tabcb tcb,\n                           const char* name, void* opaque);\n\n// Remove a tab 't' from 'nt'. Its neighboring tabs become neighbors to each\n// other. If 't' if the selected tab, the tab after 't' becomes selected.\n// Likewise if 't' is the leftmost tab, the tab after 't' becomes leftmost.\n// If 't' is the only tab, there will no more be a selected or leftmost tab,\n// until a new tab is added. Returns -1 if 't' is NULL, and 0 otherwise.\nint nctabbed_del(struct nctabbed* nt, struct nctab* t);\n\n// Move 't' after 'after' (if not NULL) and before 'before' (if not NULL).\n// If both 'after' and 'before' are NULL, the function returns -1, otherwise\n// it returns 0.\nint nctab_move(struct nctabbed* nt, struct nctab* t, struct nctab* after,\n               struct nctab* before);\n\n// Move 't' to the right by one tab, looping around to become leftmost if needed.\nvoid nctab_move_right(struct nctabbed* nt, struct nctab* t);\n\n// Move 't' to the right by one tab, looping around to become the last tab if needed.\nvoid nctab_move_left(struct nctabbed* nt, struct nctab* t);\n\n// Rotate the tabs of 'nt' right by 'amt' tabs, or '-amt' tabs left if 'amt' is\n// negative. Tabs are rotated only by changing the leftmost tab; the selected tab\n// stays the same. If there are no tabs, nothing happens.\nvoid nctabbed_rotate(struct nctabbed* nt, int amt);\n\n// Select the tab after the currently selected tab, and return the newly selected\n// tab. Returns NULL if there are no tabs.\nstruct nctab* nctabbed_next(struct nctabbed* nt);\n\n// Select the tab before the currently selected tab, and return the newly selected\n// tab. Returns NULL if there are no tabs.\nstruct nctab* nctabbed_prev(struct nctabbed* nt);\n\n// Change the selected tab to be 't'. Returns the previously selected tab.\nstruct nctab* nctabbed_select(struct nctabbed* nt, struct nctab* t);\n\n// Write the channels for tab headers, the selected tab header, and the separator\n// to '*hdrchan', '*selchan', and '*sepchan' respectively.\nvoid nctabbed_channels(struct nctabbed* nt, uint64_t* RESTRICT hdrchan,\n                       uint64_t* RESTRICT selchan, uint64_t* RESTRICT sepchan);\n\nstatic inline uint64_t\nnctabbed_hdrchan(struct nctabbed* nt){\n  uint64_t ch;\n  nctabbed_channels(nt, &ch, NULL, NULL);\n  return ch;\n}\n\nstatic inline uint64_t\nnctabbed_selchan(struct nctabbed* nt){\n  uint64_t ch;\n  nctabbed_channels(nt, NULL, &ch, NULL);\n  return ch;\n}\n\nstatic inline uint64_t\nnctabbed_sepchan(struct nctabbed* nt){\n  uint64_t ch;\n  nctabbed_channels(nt, NULL, NULL, &ch);\n  return ch;\n}\n\n// Returns the tab separator. This is not a copy and it should not be stored.\n// This can be NULL, if the separator was set to NULL in ncatbbed_create() or\n// nctabbed_set_separator().\nconst char* nctabbed_separator(struct nctabbed* nt);\n\n// Returns the tab separator width, or zero if there is no separator.\nint nctabbed_separator_width(struct nctabbed* nt);\n\n// Set the tab headers channel for 'nt'.\nvoid nctabbed_set_hdrchan(struct nctabbed* nt, uint64_t chan);\n\n// Set the selected tab header channel for 'nt'.\nvoid nctabbed_set_selchan(struct nctabbed* nt, uint64_t chan);\n\n// Set the tab separator channel for 'nt'.\nvoid nctabbed_set_sepchan(struct nctabbed* nt, uint64_t chan);\n\n// Set the tab callback function for 't'. Returns the previous tab callback.\ntabcb nctab_set_cb(struct nctab* t, tabcb newcb);\n\n// Change the name of 't'. Returns -1 if 'newname' is NULL, and 0 otherwise.\nint nctab_set_name(struct nctab* t, const char* newname);\n\n// Set the user pointer of 't'. Returns the previous user pointer.\nvoid* nctab_set_userptr(struct nctab* t, void* newopaque);\n\n// Change the tab separator for 'nt'. Returns -1 if 'separator' is not NULL and\n// is not a valid string, and 0 otherwise.\nint nctabbed_set_separator(struct nctabbed* nt, const char* separator);\n```\n\n## Channels\n\nA channel encodes 24 bits of RGB color, using 8 bits for each component. It\nadditionally provides 2 bits of alpha channel, a bit for selecting terminal\ndefault colors, and a bit to indicate whether it describes a Wide East Asian\ncharacter. The remaining four bits are reserved. Typically two channels are\nbound together in a 64-bit unsigned integer (`uint64_t`), with eight bits\ncurrently going unused. There is such a double-channel in every `nccell` and\n`ncplane` object.\n\nUsually, the higher-level `ncplane` and `nccell` functionality ought be used. It\nwill sometimes be necessary, however, to muck with channels at their lowest\nlevel. The channel API facilitates such muckery. All channel-related `ncplane`\nand `nccell` functionality is implemented in terms of this API.\n\n```c\n// Extract the 8-bit red component from a 32-bit channel.\nstatic inline unsigned\nchannel_r(uint32_t channel){\n  return (channel & 0xff0000u) >> 16u;\n}\n\n// Extract the 8-bit green component from a 32-bit channel.\nstatic inline unsigned\nchannel_g(uint32_t channel){\n  return (channel & 0x00ff00u) >> 8u;\n}\n\n// Extract the 8-bit blue component from a 32-bit channel.\nstatic inline unsigned\nchannel_b(uint32_t channel){\n  return (channel & 0x0000ffu);\n}\n\n// Extract the three 8-bit R/G/B components from a 32-bit channel.\nstatic inline unsigned\nchannel_rgb8(uint32_t channel, unsigned* r, unsigned* g, unsigned* b){\n  *r = channel_r(channel);\n  *g = channel_g(channel);\n  *b = channel_b(channel);\n  return channel;\n}\n\n// Set the three 8-bit components of a 32-bit channel, and mark it as not using\n// the default color. Retain the other bits unchanged.\nstatic inline int\nncchannel_set_rgb8(uint32_t* channel, unsigned r, unsigned g, unsigned b){\n  if(r >= 256 || g >= 256 || b >= 256){\n    return -1;\n  }\n  uint32_t c = (r << 16u) | (g << 8u) | b;\n  // clear the existing rgb bits, clear the palette index indicator, set\n  // the not-default bit, and or in the new rgb.\n  *channel = (*channel & ~(NC_BG_RGB_MASK | NC_BG_PALETTE)) | NC_BGDEFAULT_MASK | c;\n  return 0;\n}\n\n// Set the three 8-bit components of a 32-bit channel, and mark it as not using\n// the default color. Retain the other bits unchanged. r, g, and b will be\n// clipped to the range [0..255].\nstatic inline void\nncchannel_set_rgb8_clipped(uint32_t* channel, int r, int g, int b){\n  if(r >= 256){\n    r = 255;\n  }\n  if(g >= 256){\n    g = 255;\n  }\n  if(b >= 256){\n    b = 255;\n  }\n  if(r <= -1){\n    r = 0;\n  }\n  if(g <= -1){\n    g = 0;\n  }\n  if(b <= -1){\n    b = 0;\n  }\n  uint32_t c = (r << 16u) | (g << 8u) | b;\n  *channel = (*channel & ~(NC_BG_RGB_MASK | NC_BG_PALETTE)) | NC_BGDEFAULT_MASK | c;\n}\n\n// Same, but provide an assembled, packed 24 bits of rgb.\nstatic inline int\nncchannel_set(uint32_t* channel, uint32_t rgb){\n  if(rgb > 0xffffffu){\n    return -1;\n  }\n  *channel = (*channel & ~(NC_BG_RGB_MASK | NC_BG_PALETTE)) | NC_BGDEFAULT_MASK | rgb;\n  return 0;\n}\n\n// Extract the 2-bit alpha component from a 32-bit channel.\nstatic inline unsigned\nchannel_alpha(unsigned channel){\n  return channel & NC_BG_ALPHA_MASK;\n}\n\n// Set the 2-bit alpha component of the 32-bit channel.\nstatic inline int\nchannel_set_alpha(unsigned* channel, unsigned alpha){\n  if(alpha & ~NC_BG_ALPHA_MASK){\n    return -1;\n  }\n  *channel = alpha | (*channel & ~CHANNEL_ALPHA_MASK);\n  if(alpha != NCALPHA_OPAQUE){\n    *channel |= NC_BGDEFAULT_MASK;\n  }\n  return 0;\n}\n\n// Is this channel using the \"default color\" rather than its RGB?\nstatic inline bool\nncchannel_default_p(uint32_t channel){\n  return !(channel & NC_BGDEFAULT_MASK);\n}\n\n// Mark the channel as using its default color.\nstatic inline uint32_t\nncchannel_set_default(uint32_t* channel){\n  return *channel &= ~NC_BGDEFAULT_MASK;\n}\n\n// Extract the background alpha and coloring bits from a 64-bit channel pair.\nstatic inline uint64_t\nncchannels_channels(uint64_t channels){\n  return ncchannels_bchannel(channels) |\n         ((uint64_t)ncchannels_fchannel(channels) << 32u);\n}\n\n// Set the alpha and coloring bits of a channel pair from another channel pair.\nstatic inline uint64_t\nncchannels_set_channels(uint64_t* dst, uint64_t channels){\n  ncchannels_set_bchannel(dst, channels & 0xffffffffull);\n  ncchannels_set_fchannel(dst, (channels >> 32u) & 0xffffffffull);\n  return *dst;\n}\n\n// Extract the background alpha and coloring bits from a 64-bit channel\n// pair as a single 32-bit value.\nstatic inline unsigned\nncchannels_bchannel(uint64_t channels){\n  return channels & (NC_BG_RGB_MASK | NC_BG_PALETTE |\n                     NC_BGDEFAULT_MASK | NC_BG_ALPHA_MASK);\n}\n\n// Extract the foreground alpha and coloring bits from a 64-bit channel\n// pair as a single 32-bit value.\nstatic inline uint32_t\nncchannels_fchannel(uint64_t channels){\n  return ncchannels_bchannel(channels >> 32u);\n}\n\n// Returns the channels with the color information swapped, but not\n// alpha, nor other housekeeping bits.\nstatic inline uint64_t\nncchannels_reverse(uint64_t channels){\n  const uint64_t raw = ((uint64_t)ncchannels_bchannel(channels) << 32u) +\n                       ncchannels_fchannel(channels);\n  const uint64_t statemask = ((NC_NOBACKGROUND_MASK | NC_BG_ALPHA_MASK) << 32u) |\n                             NC_NOBACKGROUND_MASK | NC_BG_ALPHA_MASK;\n  uint64_t ret = raw & ~statemask;\n  ret |= channels & statemask;\n  if(ncchannels_bg_alpha(ret) != NCALPHA_OPAQUE){\n    if(!ncchannels_bg_rgb_p(ret)){\n      ncchannels_set_bg_alpha(&ret, NCALPHA_OPAQUE);\n    }\n  }\n  if(ncchannels_fg_alpha(ret) != NCALPHA_OPAQUE){\n    if(!ncchannels_fg_rgb_p(ret)){\n      ncchannels_set_fg_alpha(&ret, NCALPHA_OPAQUE);\n    }\n  }\n  return ret;\n}\n\n// Extract 24 bits of foreground RGB from 'channels', shifted to LSBs.\nstatic inline unsigned\nncchannels_fg_rgb(uint64_t channels){\n  return ncchannels_fchannel(channels) & NC_BG_MASK;\n}\n\n// Extract 24 bits of background RGB from 'channels', shifted to LSBs.\nstatic inline unsigned\nncchannels_bg_rgb(uint64_t channels){\n  return ncchannels_bchannel(channels) & NC_BG_MASK;\n}\n\n// Extract 2 bits of foreground alpha from 'channels', shifted to LSBs.\nstatic inline unsigned\nncchannels_fg_alpha(uint64_t channels){\n  return ncchannel_alpha(channels_fchannel(channels));\n}\n\n// Extract 2 bits of background alpha from 'channels', shifted to LSBs.\nstatic inline unsigned\nncchannels_bg_alpha(uint64_t channels){\n  return ncchannel_alpha(channels_bchannel(channels));\n}\n\n// Extract the 24-bit RGB value from a 32-bit channel.\n// Only valid if ncchannel_rgb_p() would return true for the channel.\nstatic inline uint32_t\nncchannel_rgb(uint32_t channel){\n  return channel & NC_BG_RGB_MASK;\n}\n\n// Extract the three 8-bit R/G/B components from a 32-bit channel.\n// Only valid if ncchannel_rgb_p() would return true for the channel.\nstatic inline uint32_t\nncchannel_rgb8(uint32_t channel, unsigned* restrict r, unsigned* restrict g,\n               unsigned* restrict b){\n  *r = ncchannel_r(channel);\n  *g = ncchannel_g(channel);\n  *b = ncchannel_b(channel);\n  return channel;\n}\n\n// Extract 24 bits of foreground RGB from 'channels', split into subchannels.\nstatic inline uint32_t\nncchannels_fg_rgb8(uint64_t channels, unsigned* r, unsigned* g, unsigned* b){\n  return ncchannel_rgb8(channels_fchannel(channels), r, g, b);\n}\n\n// Extract 24 bits of background RGB from 'channels', split into subchannels.\nstatic inline uint32_t\nncchannels_bg_rgb8(uint64_t channels, unsigned* r, unsigned* g, unsigned* b){\n  return ncchannel_rgb8(channels_bchannel(channels), r, g, b);\n}\n\n// Set the r, g, and b channels for the foreground component of this 64-bit\n// 'channels' variable, and mark it as not using the default color.\nstatic inline int\nncchannels_set_fg_rgb8(uint64_t* channels, unsigned r, unsigned g, unsigned b){\n  unsigned channel = ncchannels_fchannel(*channels);\n  if(channel_set_rgb8(&channel, r, g, b) < 0){\n    return -1;\n  }\n  *channels = ((uint64_t)channel << 32llu) | (*channels & 0xffffffffllu);\n  return 0;\n}\n\n// Set the r, g, and b channels for the background component of this 64-bit\n// 'channels' variable, and mark it as not using the default color.\nstatic inline int\nncchannels_set_bg_rgb8(uint64_t* channels, unsigned r, unsigned g, unsigned b){\n  unsigned channel = ncchannels_bchannel(*channels);\n  if(channel_set_rgb8(&channel, r, g, b) < 0){\n    return -1;\n  }\n  *channels = (*channels & 0xffffffff00000000llu) | channel;\n  return 0;\n}\n\n// Same, but set an assembled 32 bit channel at once.\nstatic inline int\nncchannels_set_fg_rgb(uint64_t* channels, unsigned rgb){\n  unsigned channel = ncchannels_fchannel(*channels);\n  if(channel_set(&channel, rgb) < 0){\n    return -1;\n  }\n  *channels = ((uint64_t)channel << 32llu) | (*channels & 0xffffffffllu);\n  return 0;\n}\n\nstatic inline int\nncchannels_set_bg_rgb(uint64_t* channels, unsigned rgb){\n  unsigned channel = ncchannels_bchannel(*channels);\n  if(channel_set(&channel, rgb) < 0){\n    return -1;\n  }\n  *channels = (*channels & 0xffffffff00000000llu) | channel;\n  return 0;\n}\n\n// Set the 2-bit alpha component of the foreground channel.\nstatic inline int\nncchannels_set_fg_alpha(uint64_t* channels, unsigned alpha){\n  unsigned channel = ncchannels_fchannel(*channels);\n  if(channel_set_alpha(&channel, alpha) < 0){\n    return -1;\n  }\n  *channels = ((uint64_t)channel << 32llu) | (*channels & 0xffffffffllu);\n  return 0;\n}\n\n// Set the 2-bit alpha component of the background channel.\nstatic inline int\nncchannels_set_bg_alpha(uint64_t* channels, unsigned alpha){\n  if(alpha == NCALPHA_HIGHCONTRAST){ // forbidden for background alpha\n    return -1;\n  }\n  unsigned channel = ncchannels_bchannel(*channels);\n  if(channel_set_alpha(&channel, alpha) < 0){\n    return -1;\n  }\n  *channels = (*channels & 0xffffffff00000000llu) | channel;\n  return 0;\n}\n\n// Is the foreground using the \"default foreground color\"?\nstatic inline bool\nncchannels_fg_default_p(uint64_t channels){\n  return channel_default_p(ncchannels_fchannel(channels));\n}\n\n// Is the background using the \"default background color\"? The \"default\n// background color\" must generally be used to take advantage of\n// terminal-effected transparency.\nstatic inline bool\nncchannels_bg_default_p(uint64_t channels){\n  return channel_default_p(ncchannels_bchannel(channels));\n}\n\n// Mark the foreground channel as using its default color.\nstatic inline uint64_t\nncchannels_set_fg_default(uint64_t* channels){\n  unsigned channel = ncchannels_fchannel(*channels);\n  channel_set_default(&channel);\n  *channels = ((uint64_t)channel << 32llu) | (*channels & 0xffffffffllu);\n  return *channels;\n}\n\n// Mark the foreground channel as using its default color.\nstatic inline uint64_t\nncchannels_set_bg_default(uint64_t* channels){\n  unsigned channel = ncchannels_bchannel(*channels);\n  channel_set_default(&channel);\n  *channels = (*channels & 0xffffffff00000000llu) | channel;\n  return *channels;\n}\n```\n\n## Visuals\n\n`ncvisual`s are virtual pixel framebuffers. They can be operated upon using\nfamiliar pixel graphics routines, and then rendered to a (character-\ngraphics) plane using a variety of blitting methods:\n\n* Space with background color -- the only cell blitter that works in ASCII\n  mode. 1:1 pixels map losslessly to 2:1 cells.\n* Unicode upper- and lower-half blocks (▀ and ▄, respectively). 2:1 pixels\n  map losslessly to 2:1 cells. The default blitting mode.\n* Unicode half blocks plus quadrants. 2x2 pixels map to 2:1 cells.\n* Unicode sextants. 3x2 pixels map to 2:1 cells.\n* Braille. 4:2 pixels map to 2:1 cells. Useful when only two colors are needed\n  in a small area, due to high resolution.\n* Sixel- and Kitty-based bitmaps.\n\nIt is most typicaly to prepare `ncvisual`s from files on disk (see \n[Multimedia](#multimedia) below); this requires Notcurses to be built against\na multimedia engine. Even without such an engine, `ncvisual`s can be\nconstructed directly from RGBA or BGRA 8bpc memory:\n\n```c\n// Prepare an ncvisual, and its underlying plane, based off RGBA content in\n// memory at 'rgba'. 'rgba' is laid out as 'rows' lines, each of which is\n// 'rowstride' bytes in length. Each line has 'cols' 32-bit 8bpc RGBA pixels\n// followed by possible padding (there will be 'rowstride' - 'cols' * 4 bytes\n// of padding). The total size of 'rgba' is thus (rows * rowstride) bytes, of\n// which (rows * cols * 4) bytes are actual non-padding data.\nstruct ncvisual* ncvisual_from_rgba(const void* rgba, int rows,\n                                    int rowstride, int cols);\n\n// ncvisual_from_rgba(), but the pixels are 4-byte RGBx. A is filled in\n// throughout using 'alpha'. rowstride must be a multiple of 4.\nstruct ncvisual* ncvisual_from_rgb_packed(const void* rgba, int rows,\n                                          int rowstride, int cols, int alpha);\n\n// ncvisual_from_rgba(), but the pixels are 3-byte RGB. A is filled in\n// throughout using 'alpha'.\nstruct ncvisual* ncvisual_from_rgb_loose(const void* rgba, int rows,\n                                         int rowstride, int cols, int alpha);\n\n// ncvisual_from_rgba(), but for BGRA.\nstruct ncvisual* ncvisual_from_bgra(struct notcurses* nc, const void* bgra,\n                                    int rows, int rowstride, int cols);\n\n// ncvisual_from_rgba(), but 'data' is 'pstride'-byte palette-indexed pixels,\n// arranged in 'rows' lines of 'rowstride' bytes each, composed of 'cols'\n// pixels. 'palette' is an array of at least 'palsize' ncchannels.\nstruct ncvisual* ncvisual_from_palidx(const void* data, int rows,\n                                      int rowstride, int cols, int palsize,\n                                      int pstride, const uint32_t* palette);\n\n// Construct an ncvisual from a nul-terminated Sixel control sequence.\nstruct ncvisual* ncvisual_from_sixel(const char* s, unsigned leny, unsigned lenx);\n```\n\n`ncvisual`s can also be loaded from the contents of a plane:\n\n```c\n// Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces,\n// half blocks, and full blocks. The latter will be checked, and any other\n// glyph will result in a NULL being returned. This function exists so that\n// planes can be subjected to ncvisual transformations. If possible, it's\n// better to create the ncvisual from memory using ncvisual_from_rgba().\n// Lengths of 0 are interpreted to mean \"all available remaining area\".\nstruct ncvisual* ncvisual_from_plane(const struct ncplane* n,\n                                     ncblitter_e blit,\n                                     unsigned begy, unsigned begx,\n                                     unsigned leny, unsigned lenx);\n```\n\nVarious transformations can be applied to an `ncvisual`, regardless of how\nit was built up:\n\n```c\n// describes all geometries of an ncvisual: those which are inherent, and those\n// dependent upon a given rendering regime. pixy and pixx are the true internal\n// pixel geometry, taken directly from the load (and updated by\n// ncvisual_resize()). cdimy/cdimx are the cell-pixel geometry *at the time\n// of this call* (it can change with a font change, in which case all values\n// other than pixy/pixx are invalidated). rpixy/rpixx are the pixel geometry as\n// handed to the blitter, following any scaling. scaley/scalex are the number\n// of input pixels drawn to a single cell; when using NCBLIT_PIXEL, they are\n// equivalent to cdimy/cdimx. rcelly/rcellx are the cell geometry as written by\n// the blitter, following any padding (there is padding whenever rpix{y, x} is\n// not evenly divided by scale{y, x}, and also sometimes for Sixel).\n// maxpixely/maxpixelx are defined only when NCBLIT_PIXEL is used, and specify\n// the largest bitmap that the terminal is willing to accept. blitter is the\n// blitter which will be used, a function of the requested blitter and the\n// blitters actually supported by this environment. if no ncvisual was\n// supplied, only cdimy/cdimx are filled in.\ntypedef struct ncvgeom {\n  unsigned pixy, pixx;     // true pixel geometry of ncvisual data\n  unsigned cdimy, cdimx;   // terminal cell geometry when this was calculated\n  unsigned rpixy, rpixx;   // rendered pixel geometry (per visual_options)\n  unsigned rcelly, rcellx; // rendered cell geometry (per visual_options)\n  unsigned scaley, scalex; // pixels per filled cell (scale == c for bitmaps)\n  unsigned begy, begx;     // upper-left corner of used region\n  unsigned leny, lenx;     // geometry of used region\n  unsigned maxpixely, maxpixelx; // only defined for NCBLIT_PIXEL\n  ncblitter_e blitter;     // blitter that will be used\n} ncvgeom;\n\n// all-purpose ncvisual geometry solver. one or both of 'nc' and 'n' must be\n// non-NULL. if 'nc' is NULL, only pixy/pixx will be filled in, with the true\n// pixel geometry of 'n'. if 'n' is NULL, only cdimy/cdimx, blitter,\n// scaley/scalex, and maxpixely/maxpixelx are filled in. cdimy/cdimx and\n// maxpixely/maxpixelx are only ever filled in if we know them.\nint ncvisual_geom(const struct notcurses* nc, const struct ncvisual* n,\n                  const struct ncvisual_options* vopts, ncvgeom* geom);\n\n// Scale the visual to 'rows' X 'columns' pixels, using the best scheme\n// available. This is a lossy transformation, unless the size is unchanged.\nint ncvisual_rotate(struct ncvisual* n, double rads);\n\n// Resize the visual so that it is 'rows' X 'columns'. This is a lossy\n// transformation, unless the size is unchanged.\nint ncvisual_resize(struct ncvisual* n, int rows, int cols);\n\n// Scale the visual to 'rows' X 'columns' pixels, using non-interpolative\n// (naive) scaling. No new colors will be introduced as a result.\nint ncvisual_resize_noninterpolative(struct ncvisual* n, int rows, int cols);\n\n// Polyfill at the specified location within the ncvisual 'n', using 'rgba'.\nint ncvisual_polyfill_yx(struct ncvisual* n, unsigned y, unsigned x, uint32_t rgba);\n\n// Get the specified pixel from the specified ncvisual.\nint ncvisual_at_yx(const struct ncvisual* n, unsigned y, unsigned x,\n                   uint32_t* pixel);\n\n// Set the specified pixel in the specified ncvisual.\nint ncvisual_set_yx(const struct ncvisual* n, unsigned y, unsigned x,\n                    uint32_t pixel);\n\n// If a subtitle ought be displayed at this time, return a new plane (bound\n// to 'parent' containing the subtitle, which might be text or graphics\n// (depending on the input format).\nstruct ncplane* ncvisual_subtitle_plane(struct ncplane* parent,\n                                        const struct ncvisual* ncv);\n```\n\nAnd finally, the `ncvisual` can be blitted to one or more `ncplane`s:\n\n```c\n// Render the decoded frame according to the provided options (which may be\n// NULL). The plane used for rendering depends on vopts->n and vopts->flags.\n// If NCVISUAL_OPTION_CHILDPLANE is set, vopts->n must not be NULL, and the\n// plane will always be created as a child of vopts->n. If this flag is not\n// set, and vopts->n is NULL, a new plane is created as root of a new pile.\n// If the flag is not set and vopts->n is not NULL, we render to vopts->n.\n// A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and\n// 'leny'. Negative values for any of thse are an error. It is an error to\n// specify any region beyond the boundaries of the frame. Returns the (possibly\n// newly-created) plane to which we drew. Pixels may not be blitted to the\n// standard plane.\nstruct ncplane* ncvisual_blit(struct notcurses* nc, struct ncvisual* ncv,\n                              const struct ncvisual_options* vopts);\n\n// Create a new plane as prescribed in opts, either as a child of 'vopts->n',\n// or the root of a new pile if 'vopts->n' is NULL (or 'vopts' itself is NULL).\n// Blit 'ncv' to the created plane according to 'vopts'. If 'vopts->n' is\n// non-NULL, NCVISUAL_OPTION_CHILDPLANE must be supplied.\nstatic inline struct ncplane*\nncvisualplane_create(struct notcurses* nc, const struct ncplane_options* opts,\n                     struct ncvisual* ncv, struct ncvisual_options* vopts);\n\n// decode the next frame ala ncvisual_decode(), but if we have reached the end,\n// rewind to the first frame of the ncvisual. a subsequent `ncvisual_blit()`\n// will render the first frame, as if the ncvisual had been closed and reopened.\n// the return values remain the same as those of ncvisual_decode().\nint ncvisual_decode_loop(struct ncvisual* nc);\n\n// we never blit full blocks, but instead spaces (more efficient) with the\n// background set to the desired foreground.\ntypedef enum {\n  NCBLIT_DEFAULT, // let the ncvisual pick\n  NCBLIT_1x1,     // space, compatible with ASCII\n  NCBLIT_2x1,     // halves + 1x1 (space)     ▄▀\n  NCBLIT_2x2,     // quadrants + 2x1          ▗▐ ▖▀▟▌▙\n  NCBLIT_3x2,     // sextants + 2x1           🬀🬁🬂🬃🬄🬅🬆🬇🬈🬉🬊🬋🬌🬍🬎🬏🬐🬑🬒🬓🬔🬕🬖🬗🬘🬙🬚🬛🬜🬝🬞\n  NCBLIT_4x2,     // octants + 2x2            there are a great many octants\n  NCBLIT_BRAILLE, // 4 rows, 2 cols (braille) ⡀⡄⡆⡇⢀⣀⣄⣆⣇⢠⣠⣤⣦⣧⢰⣰⣴⣶⣷⢸⣸⣼⣾⣿\n  NCBLIT_PIXEL,   // pixel graphics (also work in ASCII)\n  NCBLIT_4x1,     // four vertical levels     █▆▄▂     (plots only)\n  NCBLIT_8x1,     // eight vertical levels    █▇▆▅▄▃▂▁ (plots only)\n} ncblitter_e;\n\n// Lex a blitter.\nint notcurses_lex_blitter(const char* op, ncblitter_e* blitter);\n\n// Get the name of a blitter.\nconst char* notcurses_str_blitter(ncblitter_e blitter);\n\n#define NCVISUAL_OPTION_NODEGRADE     0x0001ull // fail rather than degrade\n#define NCVISUAL_OPTION_BLEND         0x0002ull // use NCALPHA_BLEND\n#define NCVISUAL_OPTION_HORALIGNED    0x0004ull // x is an alignment, not abs\n#define NCVISUAL_OPTION_VERALIGNED    0x0008ull // y is an alignment, not abs\n#define NCVISUAL_OPTION_ADDALPHA      0x0010ull // transcolor is in effect\n#define NCVISUAL_OPTION_CHILDPLANE    0x0020ull // interpret n as parent\n#define NCVISUAL_OPTION_NOINTERPOLATE 0x0040ull // non-interpolative scaling\n\nstruct ncvisual_options {\n  // if no ncplane is provided, one will be created using the exact size\n  // necessary to render the source with perfect fidelity (this might be\n  // smaller or larger than the rendering area).\n  struct ncplane* n;\n  // the scaling is ignored if no ncplane is provided (it ought be NCSCALE_NONE\n  // in this case). otherwise, the source is stretched/scaled relative to the\n  // provided ncplane.\n  ncscale_e scaling;\n  // if an ncplane is provided, y and x specify where the visual will be\n  // rendered on that plane. otherwise, they specify where the created ncplane\n  // will be placed relative to the standard plane's origin. x is an ncalign_e\n  // value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e\n  // value if NCVISUAL_OPTION_VERALIGNED is provided.\n  int y, x;\n  // the region of the visual that ought be rendered. for the entire visual,\n  // pass an origin of 0, 0 and a size of 0, 0 (or the true height and width).\n  // these numbers are all in terms of ncvisual pixels. negative values are\n  // prohibited.\n  int begy, begx; // origin of rendered region\n  int leny, lenx; // size of rendered region\n  // use NCBLIT_DEFAULT if you don't care, an appropriate blitter will be\n  // chosen for your terminal, given your scaling. NCBLIT_PIXEL is never\n  // chosen for NCBLIT_DEFAULT.\n  ncblitter_e blitter; // glyph set to use (maps input to output cells)\n  uint64_t flags; // bitmask over NCVISUAL_OPTION_*\n  uint32_t transcolor; // used only if NCVISUAL_OPTION_ADDALPHA is set\n  // pixel offsets within the cell. if NCBLIT_PIXEL is used, the bitmap will\n  // be drawn offset from the upper-left cell's origin by these amounts. it is\n  // an error if either number exceeds the cell-pixel geometry in its\n  // dimension. if NCBLIT_PIXEL is not used, these fields are ignored.\n  // this functionality can be used for smooth bitmap movement.\n  // FIXME not yet implemented.\n  unsigned pxoffy, pxoffx;\n};\n\ntypedef enum {\n  NCSCALE_NONE,\n  NCSCALE_SCALE,\n  NCSCALE_STRETCH,\n  NCSCALE_SCALE_HIRES,\n  NCSCALE_NONE_HIRES,\n  NCSCALE_INFLATE,\n} ncscale_e;\n\n// Lex a scaling mode (one of \"none\", \"stretch\", \"scale\", \"hires\",\n// \"inflate\", or \"scalehi\").\nint notcurses_lex_scalemode(const char* op, ncscale_e* scalemode);\n\n// Get the name of a scaling mode.\nconst char* notcurses_str_scalemode(ncscale_e scalemode);\n\n// the streaming operation ceases immediately, and that value is propagated out.\n// The recommended absolute display time target is passed in 'tspec'.\ntypedef int (*streamcb)(struct ncplane*, struct ncvisual*,\n                        const struct timespec*, void*);\n\n// Shut up and display my frames! Provide as an argument to ncvisual_stream().\n// If you'd like subtitles to be decoded, provide an ncplane as the curry. If the\n// curry is NULL, subtitles will not be displayed.\nint ncvisual_simple_streamer(struct ncvisual* ncv, struct ncvisual_options* vopts,\n                             const struct timespec* tspec, void* curry);\n\n// Stream the entirety of the media, according to its own timing. Blocking,\n// obviously. streamer may be NULL; it is otherwise called for each frame, and\n// its return value handled as outlined for stream cb. If streamer() returns\n// non-zero, the stream is aborted, and that value is returned. By convention,\n// return a positive number to indicate intentional abort from within\n// streamer(). 'timescale' allows the frame duration time to be scaled. For a\n// visual naturally running at 30FPS, a 'timescale' of 0.1 will result in\n// 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to\n// supply 'timescale' less than or equal to 0.\nint ncvisual_stream(struct notcurses* nc, struct ncvisual* ncv, float timescale,\n                    streamcb streamer, const struct ncvisual_options* vopts,\n                    void* curry);\n```\n\n### QR codes\n\nIf built with libqrcodegen support, `ncplane_qrcode()` can be used to draw\na QR code for arbitrary data.\n\n```c\n// Draw a QR code at the current position on the plane. If there is insufficient\n// room to draw the code here, or there is any other error, non-zero will be\n// returned. Otherwise, the QR code \"version\" (size) is returned. The QR code\n// is (version * 4 + 17) columns wide, and ⌈version * 4 + 17⌉ rows tall (the\n// properly-scaled values are written back to '*ymax' and '*xmax').\nint ncplane_qrcode(struct ncplane* n, unsigned* ymax, unsigned* xmax,\n                   const void* data, size_t len);\n```\n\n### Multimedia\n\nWhen compiled against a suitable engine (FFmpeg and OpenImageIO are both\ncurrently supported), Notcurses can populate a visual with pixels decoded\nfrom an image or video using `ncvisual_from_file()`. Once opened,\n`ncvisual_decode()` should be used to extract each frame (an image will\nhave only one frame), until it returns `NCERR_EOF`:\n\n```c\n// Open a visual at 'file', extracting a codec and parameters.\nstruct ncvisual* ncvisual_from_file(const char* file);\n\n// extract the next frame from an ncvisual. returns NCERR_EOF on end of file,\n// and NCERR_SUCCESS on success, otherwise some other NCERR.\nint ncvisual_decode(struct ncvisual* nc);\n```\n\n### Pixels\n\nIt is sometimes desirable to modify the pixels of an `ncvisual` directly.\n\n```c\nstatic inline int\nncpixel_set_r(uint32_t* pixel, int r){\n  if(r > 255 || r < 0){\n    return -1;\n  }\n  *pixel = (*pixel & 0xffffff00ul) | (r);\n  return 0;\n}\n\nstatic inline int\nncpixel_set_g(uint32_t* pixel, int g){\n  if(g > 255 || g < 0){\n    return -1;\n  }\n  *pixel = (*pixel & 0xff00fffful) | (g << 16u);\n  return 0;\n}\n\nstatic inline int\nncpixel_set_b(uint32_t* pixel, int b){\n  if(b > 255 || b < 0){\n    return -1;\n  }\n  *pixel = (*pixel & 0xffff00fful) | (b << 8u);\n  return 0;\n}\n\n// set the RGB values of an RGB pixel\nstatic inline int\nncpixel_set_rgb8(uint32_t* pixel, unsigned r, unsigned g, unsigned b){\n  if(pixel_set_r(pixel, r) || pixel_set_g(pixel, g) || pixel_set_b(pixel, b)){\n    return -1;\n  }\n  return 0;\n}\n```\n\n## Stats\n\nNotcurses supplies a number of stats related to performance and state.\nCumulative stats can be reset at any time.\n\n```c\ntypedef struct ncstats {\n  // purely increasing stats\n  uint64_t renders;          // successful ncpile_render() runs\n  uint64_t writeouts;        // successful ncpile_rasterize() runs\n  uint64_t failed_renders;   // aborted renders, should be 0\n  uint64_t failed_writeouts; // aborted writes\n  uint64_t raster_bytes;     // bytes emitted to ttyfp\n  int64_t raster_max_bytes;  // max bytes emitted for a frame\n  int64_t raster_min_bytes;  // min bytes emitted for a frame\n  uint64_t render_ns;        // nanoseconds spent rendering\n  int64_t render_max_ns;     // max ns spent in render for a frame\n  int64_t render_min_ns;     // min ns spent in render for a frame\n  uint64_t raster_ns;        // nanoseconds spent rasterizing\n  int64_t raster_max_ns;     // max ns spent in raster for a frame\n  int64_t raster_min_ns;     // min ns spent in raster for a frame\n  uint64_t writeout_ns;      // nanoseconds spent writing frames to terminal\n  int64_t writeout_max_ns;   // max ns spent writing out a frame\n  int64_t writeout_min_ns;   // min ns spent writing out a frame\n  uint64_t cellelisions;     // cells we elided entirely thanks to damage maps\n  uint64_t cellemissions;    // total number of cells emitted to terminal\n  uint64_t fgelisions;       // RGB fg elision count\n  uint64_t fgemissions;      // RGB fg emissions\n  uint64_t bgelisions;       // RGB bg elision count\n  uint64_t bgemissions;      // RGB bg emissions\n  uint64_t defaultelisions;  // default color was emitted\n  uint64_t defaultemissions; // default color was elided\n  uint64_t refreshes;        // refresh requests (non-optimized redraw)\n  uint64_t sprixelemissions; // sprixel draw count\n  uint64_t sprixelelisions;  // sprixel elision count\n  uint64_t sprixelbytes;     // sprixel bytes emitted\n  uint64_t appsync_updates;  // how many application-synchronized updates?\n  uint64_t input_errors;     // errors processing control sequences/utf8\n  uint64_t input_events;     // characters returned to userspace\n  uint64_t hpa_gratuitous;   // unnecessary hpas issued\n\n  // current state -- these can decrease\n  uint64_t fbbytes;          // total bytes devoted to all active framebuffers\n  unsigned planes;           // number of planes currently in existence\n} ncstats;\n\n// Allocate an ncstats object. Use this rather than allocating your own, since\n// future versions of Notcurses might enlarge this structure.\nncstats* notcurses_stats_alloc(const struct notcurses* nc);\n\n// Acquire an atomic snapshot of the Notcurses object's stats.\nvoid notcurses_stats(struct notcurses* nc, ncstats* stats);\n\n// Reset all cumulative stats (immediate ones, such as fbbytes, are not reset),\n// first copying them into |*stats| (if |stats| is not NULL).\nvoid notcurses_stats_reset(struct notcurses* nc, ncstats* stats);\n```\n\n## C++\n\nMarek Habersack has contributed (and maintains) C++ wrappers installed to\n`include/ncpp/`, `libnotcurses++.so`, and `libnotcurses++.a`.\n\nIn their default mode, these wrappers throw exceptions only from the type \nconstructors (RAII). If `NCPP_EXCEPTIONS_PLEASE` is defined prior to including \nany NCPP headers, they will throw exceptions.\n"
        },
        {
          "name": "cffi",
          "type": "tree",
          "content": null
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}