{
  "metadata": {
    "timestamp": 1736710202540,
    "page": 909,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "o-gs/dji-firmware-tools",
      "stars": 1628,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 27.9990234375,
          "content": "# dji-firmware-tools\n\nTools for extracting, modding and re-packaging firmwares of [DJI](http://www.dji.com) multirotor drones.\n\n# Motivation\n\nThe project started as an alternative implementation of the parser from [phantom-licensecheck](https://github.com/probonopd/phantom-licensecheck).\nOver time it has grown to support many generations of DJI products.\nIt consists of tools which allow not only extraction, but also re-packing of\nthe previously extracted modules back into single file. There are also tools\nwhich are supposed to be used on specific modules to extract and allow modification\nof their content.\n\n# Use cases\n\nHere are a few of possible uses of the tools.\n\n### Calibration after repair\n\nReplacing some components of the drone may require calibration. The tools are\ncapable of triggering calibration in some devices, mostly gimbals with\n[Hall sensors](https://en.wikipedia.org/wiki/Hall_effect_sensor).\n\nIt is also possible to use them to send any custom packet to the drone, and\nthis way trigger factory functions like calibration or pairing - as long\nas you know how the packet should look like.\n\n### Parts identification on board and component level\n\nThe [wiki of this project](https://github.com/o-gs/dji-firmware-tools/wiki)\nhas tons of information about boards within each drone,\nand components on each board. This info is created and shared by many enthusiasts\nand repair technicians.\n\n### Flight parameters modification\n\nThe tools can be used as command line version of DJI Assistant software,\nwhich also allows to change parameters for platforms which lacks such\nOEM software or where it has the advanced functions locked.\n\nFlight Controllers from DJI define hunderds of parameters which affect their\nbehavior. These can be modified by just sending a command to the drone,\nas long as the new value is within limits accepted by FC firmware.\n\n### Firmware modification\n\nThe tools allow modifying firmware binaries, and then re-packing them back\ninto flashable firmware package. This way, any software-controled functionality\ncan be altered, including:\n* hardware pairing can be disabled,\n* allowed value ranges of parameters can be changed,\n* all hard-coded limits can be lifted or extended,\n* unused hardware features can be enabled,\n* additional devices can be added and integrated to the drone,\n* anything you can imagine, as long as you're capable of implementing the change.\n\nIt may sometimes require additional knowledge and software modifications\n(ie. rooting the drone) to flash modified firmware - some firmware packages\nare signed using asymmetric cryptography, and private keys are rarely available.\n\n### Research\n\nIf you're interested in DJI hardware and software, this is the place to start\nlearning. You can:\n\n* capture and analyze communication between modules within the drone and RC\nto figure out what specific hardware and software does,\n* use the wiki to compare hardware and software between platforms, or to analyze\nboards on component level before opening your drone,\n* extract firmware update packages to analyze and compare binaries executed by\neach programmable chip within the drone,\n* analyze a specific binary from firmware, for example by converting it to ELF\nand using disassembler to look at the content, applying symbols for easier\nunderstanding of what the code does,\n* find security vulnerabilities within firmware binaries and communication protocols,\n* compare firmware binaries between FW package versions,\n* parse flight logs generated by the drones,\n* get some basic knowledge to not act stupid when interacting with community\nof modders or researchers.\n\n# Step by step instruction\n\nSuch instruction will not be provided. These tools are for engineers with vast\nhardware and software knowledge. You need to know what you're doing to achieve\nanything with these tools.\n\nThis is to make sure the tools won't be used by script kiddies to disable\nsecurity mechanisms and to allow breaking local laws.\n\nIf you can't understand how the tools work, you should not use them. If any\nwarnings are shown, you must investigate the cause to make sure final firmware\nwill not be damaged. You are using the tools on your own risk.\n\nIf you don't know where to start, check the [tests](#tests). They will provide\nyou with command lines to communicate to the drone, or to extract all the layers\nof a specific firmware (as long as you can place it correctly).\n\n# Firmware structure\n\nSince all the tools are available in source code form, it is easy to check details\non the structure and protocols processed by these tools by looking at their source.\nThe source code is intended to also act as a format documentation.\n\nFor higher level and more hardware related info, check [the project Wiki](https://github.com/o-gs/dji-firmware-tools/wiki).\n\n# Tools\n\nThe tools can be divided into two categories:\n\n* Hardware-independent tools - Those for which you do not need to have any DJI product\nto use. You just need an input file they use, like DJI Firmware Package or DAT Log file.\n\n* Product Communication tools - You need to connect your drone to a PC in order\nto use these tools in any meaningful way. Currently the tools use serial interface\n(UART) and I2C.\n\nBelow the specific tools are described in short. Running them without parameters\nwill give you details on supported commands in each of them.\n\nTo get specifics about command line arguments of each tool, run them with `--help`\noption. Some tools also have additional remarks in their headers - try viewing them.\n\n### dji_xv4_fwcon.py\n\nDJI Firmware xV4 Container tool; allows extracting modules from package file which\nstarts with `xV4`, or creating container by merging firmware modules. Use this tool\nfirst, to extract the BIN file downloaded from DJI, as long as the file starts with\n`xV4`.\n\nExample of extracting modules from DJI firmware package for *Phantom 3 Pro*:\n\n```./dji_xv4_fwcon.py -vv -x -p P3X_FW_V01.08.0080.bin```\n\n### dji_imah_fwsig.py\n\nDJI Firmware IMaH Un-signer and Decryptor tool; allows to decrypt and un-sign module\nfrom `.sig` file which starts with `IM*H`. Use this tool after untarring single\nmodules from a firmware package, to decrypt its content. The tool can also re-sign\na module, as long as private part of the chosen key is available.\n\nKeys used for encryption and authentication were changing over time; when an\n`IM*H` file refers to a key for which the tool has several versions, it will\ndisplay a list of possible keys in a warning message, and select the most\nrecent key for current operation.\n\nExample of un-signing Camera firmware for *Mavic Pro*:\n\n```./dji_imah_fwsig.py -vv -k PRAK-2017-01 -k PUEK-2017-07 -u -i wm220_0101_v02.00.55.69_20161215.pro.fw.sig```\n\nExample of un-signing FC firmware for *Phantom 4 Pro V2*:\n\n```./dji_imah_fwsig.py -vv -k PRAK-2017-01 -k PUEK-2017-07 -u -i wm335_0306_v03.03.04.10_20180429.pro.fw.sig```\n\nExample of signing previously un-signed FC firmware for *Mini 2* (requires `PRAK` with private part):\n\n```./dji_imah_fwsig.py -vv -k PRAK-2019-09 -s -i wm161_0306_v03.04.09.74_20210112.pro.fw.sig```\n\nFor more examples of usage of the tool, as well as identifiers of keys for specific\nplatforms, read the script used for testing it: `tests/test_dji_imah_fwsig_rebin1.sh`.\n\n### dji_mvfc_fwpak.py\n\nDJI Mavic Flight Controller Firmware Decryptor tool; removes second layer encryption\nin Flight Controller firmware modules from several DJI products released around the\nsame period: *Mavic Pro*, *Spark*, *Inspire 2* and *Phantom 4*. Does not accept `IM*H`\nformat - requires input files with first level encryption already removed.\n\nExample of decrypting FC firmware for *Mavic Pro*:\n\n```./dji_mvfc_fwpak.py dec -i wm220_0306_v03.02.40.11_20170918.pro.fw```\n\n### amba_fwpak.py\n\nAmbarella A7/A9 firmware pack tool; allows extracting partitions from the\nfirmware, or merging them back. Use this to extract Ambarella firmware from\nfiles created after DJI Container is extracted. You can recognize the Ambarella\nfirmware by a lot of \"Amba\" strings within, or by a 32-char zero-padded string\nat the beginning of the file.\n\nExample of extracting partitions from Ambarella firmware for *Phantom 3 Pro*:\n\n```./amba_fwpak.py -vv -x -m P3X_FW_V01.08.0080_m0100.bin```\n\n### amba_romfs.py\n\nAmbarella A7/A9 firmware ROMFS filesystem tool; allows extracting single files\nfrom ROMFS filesystem file, or rebuilding filesystem from the single files.\nUse this after the Ambarella firmware is extracted. You can recognize ROMFS\npartitions by file names near beginning of the file, surrounded by blocks of\n0xff filled bytes.\n\nExample of extracting ROMFS partition from Ambarella firmware for *Phantom 3 Pro*:\n\n```./amba_romfs.py -vv -x -p P3X_FW_V01.08.0080_m0100_part_rom_fw.a9s```\n\n### amba_ubifs.sh\n\nLinux script for mounting UBIFS partition from the Ambarella firmware. After\nmounting, the files can be copied or modified. Use this after the Ambarella\nfirmware is extracted. The file containing UBIFS can be easily recognized\nby `UBI#` at the beginning of the file.\n\nExample of mounting Root Filesystem partition from Ambarella firmware for *Phantom 3 Pro*:\n\n```sudo ./amba_ubifs.sh P3X_FW_V01.08.0080_m0100_part_rfs.a9s```\n\n\n### arm_bin2elf.py\n\nTool which wrapps binary executable ARM images with ELF header. If a firmware\ncontains binary image of executable file, this tool can rebuild ELF header for it.\nThe ELF format can be then easily disassembled, as most debuggers can read ELF files.\nNote that using this tool on encrypted firmwares will not result in useable ELF.\n\nExample of converting FC firmware for *Phantom 3* to ELF:\n\n```./arm_bin2elf.py -vv -e -b 0x8020000 -l 0x6000000 -p P3X_FW_V01.07.0060_m0306.bin```\n\nThe command above will cause the tool to try and detect where the border between\ncode (`.text`) and data (`.data`) sections should be. This detection is not perfect,\nespecially for binaries with no `.ARM.exidx` section between them. If `.ARM.exidx`\nexists in the binary, the tool can easily find it and divide binary data properly,\ntreating `.ARM.exidx` as a separator between `.text` and `.data`.\n\nIn other words, position of the `.ARM.exidx` influences length of the `.text` section,\nand starting offset of the `.data` section. If there is no `.ARM.exidx` section in\nthe file, it will still be used as separator, just with zero size.\nAfter first look at the disassembly, it is good to check where the correct border\nbetween `.text` and `.data` sections is located. Memory address of this location can\nbe used to generate better ELF file.\n\nAdditional updates to the ELF after first look can include defining `.bss` sections.\nThese sections represent uninitialized RAM and MMIO areasused by the binary. It is\ntempting to just define one big section which covers whole memory map address range\naccording to programming guide of the chip, but that results in huge memory usage\nand related slowdowns while disassembling the file, while also making the file harder\nto navigate.\n\nNote that all section offsets are defined using in-memory address, not the position\nwithin BIN file. If you have found proper location of a section within BIN file,\nremember to add base address to the file position before inserting to the command\nline of this tool.\n\nBase address can be often found in programming guide of the specific chip; sometimes it\nmay be shifted from that location, if the binary is loaded by an additional bootloader.\nIn such cases the bootloader takes the location from documentation, and the real firmware\nbinary is loaded at a bit higher base address.\n\nOptimized examples for specific firmwares:\n\n```./arm_bin2elf.py -vv -e -b 0x8020000 --section .ARM.exidx@0x80A5D34:0 --section .bss@0x10000000:0x0A000 --section .bss2@0x20000000:0x30000 --section .bss3@0x40000000:0x30000 -p P3X_FW_V01.07.0060_m0306.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x000A000 --section .ARM.exidx@0x026E50:0 --section .bss@0x10000000:0x08000 --section .bss2@0x40000000:0x50000 --section .bss3@0xE0000000:0x10000 -p C1_FW_V01.06.0000_m1400.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x000A000 --section .ARM.exidx@0x0212E0:0 --section .bss@0x10000000:0x08000 --section .bss2@0x40000000:0x50000 --section .bss3@0xE0000000:0x10000 -p C1_FW_v01.09.0200_m1400.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x000A000 --section .ARM.exidx@0x0233E0:0 --section .bss@0x02000000:0x04000 --section .bss2@0x2008000:0x1000 --section .bss3@0x1C000000:0x2400 --section .bss4@0x1c024000:0x2400 --section .bss5@0x4002C000:0x50000 --section .bss6@0x400F8000:0x200 --section .bss7@0xE000E000:0x1200 -p C1_FW_V01.06.0000_m1401.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x8008000 --section .ARM.exidx@0x8015510:0 --section .bss@0x1FFFF700:0x05A00 --section .bss2@0x40000000:0x6700 --section .bss3@0x40010000:0x5500 --section .bss4@0x40020000:0x2200 --section .bss5@0x42200000:0x100 --section .bss6@0x42420000:0x500 -p P3X_FW_V01.08.0080_m0900.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x8008000 --section .ARM.exidx@0x801B6D0:0 --section .bss@0x1FFFF700:0x0C900 --section .bss2@0x40000000:0x6700 --section .bss3@0x40010000:0x5500 --section .bss4@0x40020000:0x7000 --section .bss5@0x50060800:0x100 -p P3X_FW_V01.11.0030_m0400.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x0420000 --section .ARM.exidx@0x4EDAF0:0 --section .bss@0x20400000:0x40000 --section .bss4@0x42200000:0x100 -p MATRICE600_FW_V02.00.00.21_m0306.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x0420000 --section .ARM.exidx@0x4F0E00:0 --section .bss@0x20400000:0x60100 --section .bss2@0x400E0000:0x2000 -p wm330_0306_v03.01.10.93_20160707.fw_0306.decrypted.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x0420000 --section .ARM.exidx@0x5277d0:0 --section .bss@0x20400000:0x60000 --section .bss2@0x400E0000:0x1000 --section .bss3@0xE0000000:0x10000 -p wm100_0306_v03.02.43.20_20170920.pro.fw_0306.decrypted.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x0420000 --section .ARM.exidx@0x5465d8:0 --section .bss@0x20400000:0x60100 --section .bss2@0x400E0000:0x2000 -p wm220_0306_v03.02.35.05_20170525.pro.fw_0306.decrypted.bin```\n\n```./arm_bin2elf.py -vv -e -b 0x7D000000 --section .ARM.exidx@0x7D0356E0:0 --section .bss@0x7D04f380:0x3800 --section .bss2@0x7D0f1900:0x200 -p wm230_0801_v10.00.07.12_20180126-recovery.img.TZOS.bin```\n\n```./arm_bin2elf.py -vv -e -b 0xFFFC0000 --section .ARM.exidx@0xFFFDA540:0x20 --section .bss@0xFFFE14D0:0x42B0 --section .bss1@0x0202000:0x20 --section .bss2@0x0402020:0x20 --section .bss3@0x0B00000:0x40 --section .bss4@0x2700000:0x40 --section .bss5@0x9000000:0x20 --section .bss6@0xF0440000:0x4500 --section .bss7@0xF0501200:0x200 --section .bss8@0xF0A09000:0x20 --section .bss9@0xF0A40000:0x1200 --section .bss10@0xF0A4D000:0x2100 --section .bss11@0xF0A61000:0x1200 --section .bss12@0xF0A72000:0x20 --section .bss13@0xF0D02000:0x20 --section .bss14@0xF0D04000:0x20 --section .bss15@0xF0E00A00:0xC0 --section .bss16@0xF0E08000:0x20 --section .bss17@0xF5001000:0x40 --section .bss18@0xF6409000:0x100 --section .bss19@0xF6800000:0x1200 --section .bss20@0xFA800000:0x100 --section .bss21@0xFAF01000:0x3500 --section .bss22@0xFB001000:0x2900 --section .bss23@0xFCC01000:0x2400 --section .bss24@0xFD001000:0x2D00 --section .bss25@0xFD400000:0x20 --section .bss26@0xFD501000:0x2400 --section .bss27@0xFF001000:0x1100 -p wm230_0801_v10.00.07.12_20180126.pro.fw_0801.bootarea_p0_BLLK.bin```\n\nThis tool supports only conversion in direction of bin-to-elf. To convert an ELF\nfile back to BIN (ie. after modifications), use `objcopy` utility for the\nspecific architecture. The `objcopy` tool is a part of GNU Binary Utilities\n(`binutils`) and not a part of this repository.\n\nExamples:\n\n```arm-none-eabi-objcopy -O binary P3X_FW_V01.07.0060_m0100_part_sys.elf P3X_FW_V01.07.0060_m0100_part_sys.bin```\n\n```arm-none-eabi-objcopy -O binary P3X_FW_V01.07.0060_m0900.elf P3X_FW_V01.07.0060_m0900.bin```\n\n### amba_sys2elf.py\n\nAmbarella A7/A9 firmware \"System Software\" partition converter. The partition\ncontains a binary image of executable file, and this tool wraps it with ELF\nheader. The ELF format can be then easily disassembled, as most debuggers can\nread ELF files. This tool is very similar to `arm_bin2elf.py`, it is just\npre-configured to specific firmware.\n\nExample: ```./amba_sys2elf.py -vv -e -l 0x6000000 -p P3X_FW_V01.08.0080_m0100_part_sys.a9s```\n\nAll border adjusting rules explained for `arm_bin2elf.py` apply for this tool as well.\n\nOptimized examples for specific firmwares:\n\n```./amba_sys2elf.py -vv -e -l 0x6000000 --section .ARM.exidx@0xEA83E4C:0 -p P3X_FW_V01.08.0080_m0100_part_sys.a9s```\n\n```./amba_sys2elf.py -vv -e -l 0x6000000 --section .ARM.exidx@0xEA82EC0:0 -p P3X_FW_V01.07.0060_m0100_part_sys.a9s```\n\n```./amba_sys2elf.py -vv -e -l 0x6000000 --section .ARM.exidx@0xEA64774:0 -p P3X_FW_V01.01.0008_m0100_part_sys.a9s```\n\n### amba_sys_hardcoder.py\n\nAmbarella A7/A9 firmware \"System Software\" partition hard-coded values editor.\n\nThe tool can parse Ambarella firmware SYS partition converted to ELF.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them. Only `setValue` element in the exported JSON file\nis really changeable, all the other data is just informational.\n\nExample of exporting hard-coded values to JSON file:\n\n```./amba_sys_hardcoder.py -vv -x --elffile P3X_FW_V01.08.0080_m0100_part_sys.elf```\n\nExample of importing values from JSON file back to ELF:\n\n```./amba_sys_hardcoder.py -vv -u --elffile P3X_FW_V01.08.0080_m0100_part_sys.elf```\n\n### dm3xx_encode_usb_hardcoder.py\n\nDji DM3xx DaVinci encode_usb binary hard-coded values editor.\n\nThe tool can parse encode_usb ELF file from Dji Firmware module for\nTI DM3xx DaVinci Media Processor.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nExample of exporting hard-coded values to JSON file:\n\n```./dm3xx_encode_usb_hardcoder.py -vv -x --elffile P3X_FW_V01.07.0060_m0800-encode_usb.elf```\n\nExample of importing values from JSON file back to ELF:\n\n```./dm3xx_encode_usb_hardcoder.py -vv -u --elffile P3X_FW_V01.07.0060_m0800-encode_usb.elf```\n\n### lightbridge_stm32_hardcoder.py\n\nDji Lightbridge STM32 micro-controller binary hard-coded values editor.\n\nThe tool can parse Lightbridge MCU firmware converted to ELF.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nExample of exporting hard-coded values to JSON file:\n\n```./lightbridge_stm32_hardcoder.py -vv -x --elffile P3X_FW_V01.07.0060_m0900.elf```\n\nExample of importing values from JSON file back to ELF:\n\n```./lightbridge_stm32_hardcoder.py -vv -u --elffile P3X_FW_V01.07.0060_m0900.elf```\n\n### dji_flyc_hardcoder.py\n\nDji Flight Controller firmware binary hard-coded values editor.\n\nThe tool can parse Flight Controller firmware converted to ELF.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nExample of exporting hard-coded values to JSON file:\n\n```./dji_flyc_hardcoder.py -vvv -x -e P3X_FW_V01.07.0060_m0306.elf```\n\nExample of importing values from JSON file back to ELF:\n\n```./dji_flyc_hardcoder.py -vvv -u -e P3X_FW_V01.07.0060_m0306.elf```\n\n### dji_flyc_param_ed.py\n\nFlight Controller Firmware Parameters Array Editor finds an array of flight\nparameters within firmware binary, and allows to extract the parameters to a JSON\nformat text file. This file can then easily be modified, and used to update\nbinary firmware, changing attributes and limits of each parameter.\n\nIn order to find the Parameters Array, the tool needs base address used for loading\nthe binary file into RAM of the micro-controller. If you don't know the base address\nto use, programming guide of the specific chip used may give you clues.\n\nExample of extracting and then updating the flight controller parameters:\n\n```./dji_flyc_param_ed.py -vv -x -m P3X_FW_V01.07.0060_m0306.bin```\n\n```./dji_flyc_param_ed.py -vv -u -m P3X_FW_V01.07.0060_m0306.bin```\n\nMore examples, for other products:\n\n```./dji_flyc_param_ed.py -vv -x -b 0x420000 -m A3_FW_V01.02.00.00_m0306.bin```\n\n```./dji_flyc_param_ed.py -vv -x -b 0x420000 -m MATRICE600_FW_V02.00.00.21_m0306.bin```\n\n```./dji_flyc_param_ed.py -vv -x -b 0x420000 -m MATRICE600PRO_FW_V01.00.00.80_m0306.bin```\n\n```./dji_flyc_param_ed.py -vv -x -b 0x420000 -m wm220_0306_v03.02.35.05_20170525.pro.bin```\n\n```./dji_flyc_param_ed.py -vv -x -b 0x0000 -m wm230_0306_v01.00.02.255_20170213.bin```\n\n### comm_dat2pcap.py\n\nDJI Universal Packet Container stream pareser with pcap output format.\n\nThe script parses Raw DUML stream (ie. flight log files ```FLY???.DAT```) and wraps\nsingle packets with PCap headers. Packets CRC is checked before the data is passed.\nAny tool with PCap format support can then be used to analyse the data (ie. Wireshark).\n\nExample of converting flight log file:\n\n```./comm_dat2pcap.py -vv -d FLY002.DAT```\n\n### comm_serial2pcap.py\n\nDJI serial bus sniffer with DUML packetizer and PCap output format.\n\nThe script captures data from two UARTs and wraps single DUML packets with PCap headers.\nPackets CRC is checked before the data is passed to the PCap file or FIFO pipe.\nAny tool with pcap format support can then be used to analyse the data (ie. Wireshark).\n\nThe utility requires two serial interfaces with RX lines connected to RX and TX lines\nwithin the drone.\n\nExample of starting the capture from two UART-to-TTL (aka FTDI) converters:\n\n```./comm_serial2pcap.py -b 115200 -F /tmp/wsf /dev/ttyUSB0 /dev/ttyUSB1```\n\n### comm_mkdupc.py\n\nDUML Packet Builder with hex string output.\n\nThis tool can build a proper DUML packet containing given header fields and payload.\nThe packet will be outputed in hexadecimal form. List of known commands and the look\nof expected payloads can be found in Wireshark dissectors described below.\n\nExample of generating a packet to ask Spark camera module for its Sensor ID:\n\n```./comm_mkdupc.py --receiver_type=Camera --seq_num=65280 --ack_type=ACK_After_Exec --cmd_set=Camera --cmd_id=181```\n\n### comm_serialtalk.py\n\nDUML Builder which sends packet to DJI product and receives a response.\n\nThis tool builds a proper DUML packet containing given header fields and payload.\nThen it sends it via given serial port and waits for response. It shows the\nreturning packet upon receiving it.\n\nIt can be considered an alternative to `dji_mb_ctrl` binary which can be found\nin some drones. Parameter names are different between these two tools though.\n\nExample of asking Flight Controller for hardware and firmware version data (tested on Ph3):\n\n```./comm_serialtalk.py --port /dev/ttyUSB0 -vv --timeout=5000 --receiver_type=FlyController --seq_num=65280 --ack_type=No_ACK_Needed --cmd_set=General --cmd_id=1```\n\nExample of asking Flight Controller for hardware and firmware version data (Mavic 3):\n\n```./comm_serialtalk.py --bulk -vv --timeout=5000 --receiver_type=FlyController --seq_num=65280 --ack_type=ACK_After_Exec --cmd_set=General --cmd_id=1```\n\n### comm_og_service_tool.py\n\nOGs Service Tool for Dji products.\n\nThe script allows to trigger a few service functions of Dji drones. It talks to the drone\nlike `comm_serialtalk.py`, but provides easier interface for some important functions.\n\nExample of listing Flight Controller Parameters 200-300 on Ph3 Pro to CSV format:\n\n```./comm_og_service_tool.py --port /dev/ttyUSB0 P3X FlycParam list --start=200 --count=100 --fmt=csv```\n\nExample of getting value of Flight Controller Parameters on Spark:\n\n```./comm_og_service_tool.py --port /dev/ttyUSB0 -vv SPARK FlycParam get g_config.flying_limit.max_height_0 --fmt=2line```\n\nExample of setting value of Flight Controller Parameters on Spark:\n\n```./comm_og_service_tool.py --port /dev/ttyUSB0 -vv SPARK FlycParam set g_config.flying_limit.max_height_0 500```\n\nExample of performing service \"joint coarse\" calibration of Spark gimbal:\n\n```./comm_og_service_tool.py --port /dev/ttyUSB0 -vv SPARK GimbalCalib JointCoarse```\n\nExample of performing service \"linear hall\" calibration of Spark gimbal, using Windows host:\n\n```python3 comm_og_service_tool.py --port COM23 -vv SPARK GimbalCalib LinearHall```\n\nExample of listing Flight Controller Parameters 200-300 on the Mavic 3 Pro to CSV format:\n\n```./comm_og_service_tool.py --bulk MAV3 FlycParam list --start=200 --count=100 --fmt=csv```\n\n### comm_sbs_bqctrl.py\n\nSmart Battery System communication tool.\n\nThis tool allows to interact with chips designed based on Smart Battery Data\nSpecification. It also supports some extensions to that specification\nimplemented by Texas Instruments in their BQ series gas gauge chips.\n\nUsage of this tool requires connection to SMBus lines (SDA,SCL,GND) of the\nSBS-compatible chip. SMBus communication uses I2C as a base, so most devices\nwith I2C bus can be used to establish the communication.\n\nExample of simple read of BatteryStatus(), using I2C interface (the script will construct SMBus messages internally):\n\n```./comm_sbs_bqctrl.py -vvv --bus \"i2c:1\" --dev_address 0x0b read BatteryStatus```\n\nExample of reading several flag fields from BQ30z55 by ManufacturerAccess(), using SMBus interface:\n\n```./comm_sbs_bqctrl.py -v --bus \"smbus:1\" --dev_address 0x0b --chip BQ30z55 --short monitor BQStatusBitsMA```\n\nExample of unsealing BQ30z55 (enabling write capabilities), with default SHA-1 key, using I2C interface on 2nd bus device available to OS:\n\n```./comm_sbs_bqctrl.py -v --bus \"i2c:2\" --dev_address 0x0b --chip BQ30z55 --short sealing Unseal```\n\n### tests\n\nThe `tests` folder contains a collection of scripts which can be used to verify\nwhether the tools do their job correctly. There are two general types of tests\nthere:\n\n* Communication tools tests, marked `comm`. These are for the scripts which normally\n talk to real devices. The tests are injecting expected answers to receive\n buffers, so they can be run without the product connected.\n\n* Firmware extraction tools tests, marked `fw_xv4`, `fw_imah_v1`, `fw_imah_v2`.\n These extract and re-pack a firmware found in `fw_packages` directory, then\n compare the resulting file to original to check whether no unintended changes\n were introduced.\n\nBesides testing your modifications, you can also use tests as source of more\nusage examples of the tools. They log command lines used to extract specific\nfirmwares and execute specific commands on the products.\n\nThe tests are prepared to be used with `pytest`. Example of executing all tests:\n\n```pytest tests -rsx --full-scope --log-cli-level=INFO```\n\nThe `--full-scope` option makes the tests execute on all known binaries, rather\nthat on a selection used for continous integration. The CI tests are selective\nto make sure the automatic testing ends in reasonable time.\n\nRemeber that the tests will only run on binaries placed in proper sub-folder\nof the `fw_packages` folder. Valid names of sub-folders can be easily found\nwithin the test scripts. If no firmware binaries are put to the folder,\nall firmware extraction tests will be skipped.\n\nBesides running all tests, you can also run a specific one (with `-k`) or a group\nof tests with specific marking (with `-m`). Example of running `fw_xv4` tests only:\n\n```pytest tests -rsx --full-scope -m fw_xv4 --log-cli-level=DEBUG```\n\n\n### comm_dissector\n\nThe folder contains [Wireshark](https://www.wireshark.org/) dissector for for analyzing\ncommunication in DJI drone interfaces.\n\nDocumentation of the tool is [included in its folder](comm_dissector/README.md).\n\n# Symbols\n\nFor some specific firmware modules in specific versions, there are partial symbols\navailable in 'symbols' directory. The symbols are in two formats:\n\n- MAP files - Can be loaded into most disassemblers with minimal effort. For IDA Pro,\nthere is a plugin which can read MAP files and rename functions and variables\naccordingly. Only functions and global variables which were given a meaningful names\nare included in these files.\n- IDC script - Format specific to IDA Pro. Stores not only functions and globals,\nbut also type information - enums and structs. Allows storing function parameters\nand local variables with their names and types, too. Can be easily applied to an\nopened ELF file via IDA Pro, no other tool will understand it.\n\nSymbols are matched with ELF files generated with the tools described above,\nnot directly with the BINs. Use example commands provided in previous section\nto generate ELF files with content matching to the symbols.\n\nWhen working on a firmware version for which no symbols are available, you may\nwant to use a version with symbols for reference in naming.\n\nIf you are looking for a best FW version for reference symbols, or you do not care\nfor FW versions at all and just want the most complete symbols - check size of MAP\nfile. MAP file mostly contains manually-named symbols, so the largest one will be\nfor firmware version on which more reversing work was done.\n"
        },
        {
          "name": "amba_fwpak.py",
          "type": "blob",
          "size": 31.6767578125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Ambarella Firmware Packer tool.\n\nExtracts and re-packs partitions from Ambarella firmware module.\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.1.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport argparse\nimport sys\nif sys.version_info < (3, 0):\n    # All checksums would have to be computed differently on Python 2.x\n    # due to differences in types\n    raise NotImplementedError('Python version 3 or newer is required.')\nimport mmap\nimport os\nimport re\nimport zlib\nimport configparser\nimport itertools\nfrom ctypes import c_char, c_ubyte, c_uint, sizeof, LittleEndianStructure\nfrom time import gmtime, strftime\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\ndef raise_or_warn(po, ex):\n    \"\"\" Raise exception, unless force-continue parameter was used.\n    \"\"\"\n    if (po.force_continue):\n        eprint(\"{:s}: Warning: {:s} Continuing anyway.\".format(po.fwmdlfile, str(ex)))\n    else:\n        raise ex\n\n\npart_entry_type_id = [\"sys\", \"dsp_fw\", \"rom_fw\", \"lnx\", \"rfs\"]\npart_entry_type_name = [\"System Software\", \"DSP uCode\", \"System ROM Data\", \"Linux Kernel\", \"Linux Root FS\"]\n\n# The Ambarella firmware file consists of 3 elements:\n# 1. Main header, containing array of partitions\n# 2. Partition header, before each partition\n# 3. Partition data, for each partition\n#\n# The Main header is made of:\n# - model_name - text description of the device model\n# - ver_info - version info, set to 0 in DJI camera FW\n# - crc32 - cummulative checksum of all modules with headers, equal to last\n#   module cummulative checksum xor -1\n# - fw module entries - array of FwModEntry, with amount of entries hard-coded\n#   for specific component; the crc32 here is a cummulative checksum of data\n#   with header, and initial value of -1\n# - partition sizes - array of int, sizes of the partitions in partition table,\n#   with 15 entries (amount of partitions is larger than the amount of modules)\n#\n# For a specific component, main header of Ambarella firmware has constant\n# size. But DJI uses several camera types all developed on Ambarella - amount\n# of module entries is different for each of them. To guess the amount of\n# modules in a file, we're assuming the partition sizes are multiplication of\n# 1024. This way we can detect beginning of the sizes array, as crc value and\n# partition length are very unlikely to both divide by 1024.\n\n\nclass FwModA9Header(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n      ('model_name', c_char * 32),\n      ('ver_info', c_uint),\n      ('crc32', c_uint),\n    ]\n\n    def dict_export(self):\n        d = dict()\n        for (varkey, vartype) in self._fields_:\n            d[varkey] = getattr(self, varkey)\n        varkey = 'ver_info'\n        d[varkey] = \"{:d}.{:d}-{:04X}\".format((d[varkey] >> 24) & 255,\n          (d[varkey] >> 16) & 255, (d[varkey]) & 65535)\n        varkey = 'crc32'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        return d\n\n    def ini_export(self, fp):\n        d = self.dict_export()\n        fp.write(\"# Ambarella Firmware Packer module header file. Loosly based on AFT format.\\n\")\n        fp.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n        varkey = 'model_name'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey].decode(encoding='utf-8', errors='ignore')));\n        varkey = 'ver_info'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=4, width=1)\n\n\nclass FwModEntry(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n      ('dt_len', c_uint),\n      ('crc32', c_uint),\n    ]\n\n    def dict_export(self):\n        d = dict()\n        for (varkey, vartype) in self._fields_:\n            d[varkey] = getattr(self, varkey)\n        varkey = 'crc32'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        return d\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=4, width=1)\n\n\nclass FwModA9PostHeader(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n      ('part_size', c_uint * 15),\n    ]\n\n    def dict_export(self):\n        d = dict()\n        for (varkey, vartype) in self._fields_:\n            d[varkey] = getattr(self, varkey)\n        varkey = 'part_size'\n        d[varkey] = \" \".join(\"{:08x}\".format(x) for x in d[varkey])\n        return d\n\n    def ini_export(self, fp):\n        d = self.dict_export()\n        # No header - this is a continuation of FwModA9Header export\n        varkey = 'part_size'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=4, width=1)\n\n\nclass FwModPartHeader(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n      ('crc32', c_uint),\n      ('version', c_uint),\n      ('build_date', c_uint),\n      ('dt_len', c_uint),\n      ('mem_addr', c_uint),\n      ('flag1', c_uint),\n      ('magic', c_uint),\n      ('flag2', c_uint),\n      ('padding', c_uint * 56),\n    ]\n\n    def build_date_year(self):\n        return (self.build_date >> 16) & 65535\n\n    def build_date_month(self):\n        return (self.build_date >> 8) & 255\n\n    def build_date_day(self):\n        return (self.build_date) & 255\n\n    def version_major(self):\n        return (self.version >> 16) & 65535\n\n    def version_minor(self):\n        return (self.version) & 65535\n\n    def dict_export(self):\n        d = dict()\n        for (varkey, vartype) in self._fields_:\n            d[varkey] = getattr(self, varkey)\n        varkey = 'mem_addr'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        varkey = 'version'\n        d[varkey] = \"{:d}.{:d}\".format(self.version_major(), self.version_minor())\n        varkey = 'build_date'\n        d[varkey] = \"{:d}-{:02d}-{:02d}\".format(self.build_date_year(), self.build_date_month(), self.build_date_day())\n        varkey = 'flag1'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        varkey = 'flag2'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        varkey = 'magic'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        varkey = 'crc32'\n        d[varkey] = \"{:08X}\".format(d[varkey])\n        varkey = 'padding'\n        d[varkey] = \" \".join(\"{:08x}\".format(x) for x in d[varkey])\n        return d\n\n    def ini_export(self, fp, i):\n        d = self.dict_export()\n        if (i < len(part_entry_type_name)):\n            ptyp_name = part_entry_type_name[i]\n        else:\n            ptyp_name = \"type {:02d}\".format(i)\n        fp.write(\"# Ambarella Firmware Packer section header file. Loosly based on AFT format.\\n\")\n        fp.write(\"# Stores partition with {:s}\\n\".format(ptyp_name))\n        fp.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n        varkey = 'mem_addr'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'version'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'build_date'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'flag1'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'flag2'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=4, width=1)\n\n\ncrc32_tab = [\n  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n  0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n  0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n  0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n  0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n  0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n  0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n  0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n  0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n  0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n  0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n  0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n  0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n  0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n  0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n  0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n  0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n  0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]\n\n\ndef amba_a9_part_entry_type_id(i):\n    if (i >= len(part_entry_type_id)):\n        return \"{:02d}\".format(i)\n    return part_entry_type_id[i]\n\n\ndef amba_calculate_crc32h_part(buf, pcrc):\n    \"\"\" A twist on crc32 hashing algorithm, probably different from original CRC32 due to a programming mistake.\n    \"\"\"\n    crc = pcrc\n    for octet in buf:\n        crc = crc32_tab[(crc ^ octet) & 0xff] ^ (crc >> 8)\n    return crc & 0xffffffff\n\n\ndef amba_calculate_crc32b_part(buf, pcrc):\n    \"\"\" A standard crc32b hashing algorithm, the same as used in ZIP/PNG.\n    \"\"\"\n    return zlib.crc32(buf, pcrc) & 0xffffffff\n\n\ndef amba_calculate_crc32(buf):\n    return amba_calculate_crc32b_part(buf, 0)\n\n\ndef amba_detect_format(po, fwmdlfile):\n    \"\"\" Detects which binary format the firmware module file has.\n    \"\"\"\n    #TODO make multiple formats support\n    # FC220 has different format (2016 - FwModA9Header longer 4 butes, 319 ints in FwModA9PostHeader)\n    return '2014'\n\n\n# We really need both i and ptyp params\ndef amba_extract_partition_head(po, e, i, ptyp):\n    fwpartfile = open(\"{:s}_part_{:s}.a9h\".format(po.ptprefix, ptyp), \"w\")\n    e.ini_export(fwpartfile, i)\n    fwpartfile.close()\n\n\ndef amba_read_part_head(po, i, ptyp):\n    e = FwModPartHeader()\n    e.magic = 0xA324EB90\n    fname = \"{:s}_part_{:s}.a9h\".format(po.ptprefix, ptyp)\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n        e.mem_addr = int(parser.get(\"asection\", \"mem_addr\"), 16)\n        e.flag1 = int(parser.get(\"asection\", \"flag1\"), 16)\n        e.flag2 = int(parser.get(\"asection\", \"flag2\"), 16)\n        version_s = parser.get(\"asection\", \"version\")\n        version_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)', version_s)\n        e.version = ((int(version_m.group(\"major\"), 10) & 0xffff) << 16) + (int(version_m.group(\"minor\"), 10) % 0xffff)\n        build_date_s = parser.get(\"asection\", \"build_date\")\n        build_date_m = re.search('(?P<year>[0-9]+)[-](?P<month>[0-9]+)[-](?P<day>[0-9]+)', build_date_s)\n        e.build_date = (\n          ((int(build_date_m.group(\"year\"), 10) & 0xffff) << 16) +\n          ((int(build_date_m.group(\"month\"), 10) & 0xff) << 8) +\n          (int(build_date_m.group(\"day\"), 10) & 0xff) )\n    del parser\n    return e\n\n\ndef amba_extract_mod_head(po, modhead, ptyp_names, modposthd):\n    fwpartfile = open(\"{:s}_header.a9h\".format(po.ptprefix), \"w\")\n    modhead.ini_export(fwpartfile)\n    fwpartfile.write(\"part_load={:s}\\n\".format(\",\".join(\"{:s}\".format(x) for x in ptyp_names)))\n    modposthd.ini_export(fwpartfile)\n    fwpartfile.close()\n\n\ndef amba_read_mod_head(po):\n    modhead = FwModA9Header()\n    modposthd = FwModA9PostHeader()\n    fname = \"{:s}_header.a9h\".format(po.ptprefix)\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n    ptyp_names = parser.get(\"asection\", \"part_load\").split(\",\")\n    part_sizes_s = parser.get(\"asection\", \"part_size\").split(\" \")\n    part_sizes = [int(n, 16) for n in part_sizes_s]\n    ver_info_s = parser.get(\"asection\", \"ver_info\")\n    ver_info_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)[-](?P<svn>[0-9A-Fa-f]+)', ver_info_s)\n    modhead.model_name = parser.get(\"asection\", \"model_name\").encode(\"utf-8\")\n    modhead.ver_info = (\n      ((int(ver_info_m.group(\"major\"), 10) & 0xff) << 24) +\n      ((int(ver_info_m.group(\"minor\"), 10) % 0xff) << 16) +\n      (int(ver_info_m.group(\"svn\"), 16) % 0xffff)\n    )\n    for i, n in enumerate(part_sizes):\n        modposthd.part_size[i] = n\n    del parser\n    return (modhead, ptyp_names, modposthd)\n\n\ndef amba_extract_partition_data(po, fwmdlfile, e, i, ptyp, hdcrc):\n    \"\"\" Extract partiton data to a file, using file input.\n\n    The initial cummulative checksum `hdcrc` can be None, which disables its computation.\n    \"\"\"\n    fwpartfile = open(\"{:s}_part_{:s}.a9s\".format(po.ptprefix, ptyp), \"wb\")\n    if (po.binhead):\n        fwpartfile.write((c_ubyte * sizeof(e)).from_buffer_copy(e))\n    ptcrc = 0\n    n = 0\n    while n < e.dt_len:\n        copy_buffer = fwmdlfile.read(min(1024 * 1024, e.dt_len - n))\n        if not copy_buffer:\n            break\n        n += len(copy_buffer)\n        fwpartfile.write(copy_buffer)\n        ptcrc = amba_calculate_crc32b_part(copy_buffer, ptcrc)\n        if hdcrc is not None:\n            hdcrc = amba_calculate_crc32h_part(copy_buffer, hdcrc)\n    fwpartfile.close()\n    if (n < e.dt_len):\n        raise_or_warn(po, ValueError(\"Partition {:d} truncated, {:d} out of {:d} bytes\".format(i, n, e.dt_len)))\n    if (ptcrc != e.crc32):\n        raise_or_warn(po, ValueError(\"Entry {:d} data checksum mismatch; got {:08X}, expected {:08X}.\"\n          .format(i, ptcrc, e.crc32)))\n    elif (po.verbose > 1):\n        print(\"{}: Entry {:2d} data checksum {:08X} matched OK\".format(po.fwmdlfile, i, ptcrc))\n    return hdcrc\n\n\ndef amba_extract_partition_data_mm(po, fwmdlmm, epos, e, i, ptyp, hdcrc):\n    \"\"\" Extract partiton data to a file, using memory mapped input file.\n\n    The initial cummulative checksum `hdcrc` can be None, which disables its computation.\n    \"\"\"\n    fwpartfile = open(\"{:s}_part_{:s}.a9s\".format(po.ptprefix, ptyp), \"wb\")\n    dtpos_beg = epos + sizeof(FwModPartHeader)\n    dtpos_end = epos + sizeof(FwModPartHeader) + e.dt_len\n    if (po.binhead):\n        dtpos_beg = epos\n    fwpartfile.write(fwmdlmm[dtpos_beg:dtpos_end])\n    fwpartfile.close()\n    dtpos_beg = epos + sizeof(FwModPartHeader)\n    ptcrc = amba_calculate_crc32(fwmdlmm[dtpos_beg:dtpos_end])\n    if hdcrc is not None:\n        hdcrc = amba_calculate_crc32h_part(fwmdlmm[dtpos_beg:dtpos_end], hdcrc)\n    if (ptcrc != e.crc32):\n        raise_or_warn(po, ValueError(\"Entry {:d} checksum mismatch; got {:08X}, expected {:08X}.\".format(i, ptcrc, e.crc32)))\n    elif (po.verbose > 1):\n        print(\"{}: Entry {:2d} data checksum {:08X} matched OK\".format(po.fwmdlfile, i, ptcrc))\n    return hdcrc\n\n\ndef amba_extract(po, fwmdlfile):\n    modhead = FwModA9Header()\n    fwmdlfile.seek(0, os.SEEK_END)\n    fwmdlfile_len = fwmdlfile.tell()\n    fwmdlfile.seek(0, os.SEEK_SET)\n    if fwmdlfile.readinto(modhead) != sizeof(modhead):\n        raise EOFError(\"Could not read firmware package file header.\")\n    if (po.verbose > 1):\n        print(\"{}: Header:\".format(po.fwmdlfile))\n        print(modhead)\n    hdcrc = 0xffffffff\n    i = 0\n    modentries = []\n    ptyp_names = []\n    while (True):\n        hde = FwModEntry()\n        if fwmdlfile.readinto(hde) != sizeof(hde):\n            raise EOFError(\"Could not read firmware package file header entries.\")\n        # If both values are multiplications of 1024, and 2nd is non-zero, then assume we're past end\n        # of entries array. Beyond entries array, there's an array of memory load addresses - and\n        # load addresses are always rounded to multiplication of a power of 2.\n        # Since specific Ambarella firmwares always have set number of partitions, we have to do\n        # such guessing if we want one tool to support all Ambarella firmwares.\n        if ((hde.dt_len & 0x3ff) == 0) and ((hde.crc32 & 0x3ff) == 0) and (hde.crc32 != 0):\n            fwmdlfile.seek(-sizeof(hde), os.SEEK_CUR)\n            break\n        if (sizeof(modhead) + i * sizeof(hde) + hde.dt_len >= fwmdlfile_len):\n            if (po.verbose > 1):\n                print(\"{}: Detection finished with entry larger than file; expecting {:d} entries\"\n                  .format(po.fwmdlfile, len(modentries)))\n            raise_or_warn(po, ValueError(\"Detection finished with unusual entry sizes, verify files.\"))\n            fwmdlfile.seek(-sizeof(hde), os.SEEK_CUR)\n            break\n        modentries.append(hde)\n        if (hde.dt_len > 0):\n            ptyp_names.append(amba_a9_part_entry_type_id(i))\n        i += 1\n        if (i > 128):\n            raise EOFError(\"Could not find header entries end marking.\")\n    if (po.verbose > 1):\n        print(\"{}: After detection, expecting {:d} entries\".format(po.fwmdlfile, len(modentries)))\n    if (po.verbose > 1):\n        print(\"{}: Entries:\".format(po.fwmdlfile))\n        print(modentries)\n\n    modposthd = FwModA9PostHeader()\n    if fwmdlfile.readinto(modposthd) != sizeof(modposthd):\n        raise EOFError(\"Could not read firmware package file header.\")\n    if (po.verbose > 1):\n        print(\"{}: Post Header:\".format(po.fwmdlfile))\n        print(modposthd)\n    amba_extract_mod_head(po, modhead, ptyp_names, modposthd)\n    i = -1\n    while True:\n        i += 1\n        # Skip unused modentries\n        if (i < len(modentries)):\n            hde = modentries[i]\n            if (hde.dt_len < 1):\n                continue\n        else:\n            # Do not show warning yet - maybe the file is at EOF\n            hde = FwModEntry()\n        epos = fwmdlfile.tell()\n        e = FwModPartHeader()\n        n = fwmdlfile.readinto(e)\n        if (n is None) or (n == 0):\n            # End Of File, correct ending\n            break\n        if n != sizeof(e):\n            raise EOFError(\"Could not read firmware package partition header, got {:d} out of {:d}.\"\n              .format(n, sizeof(e)))\n        if e.magic != 0xA324EB90:\n            raise_or_warn(po, ValueError(\"Invalid magic value in partition {:d} header.\".format(i)))\n        if (po.verbose > 1):\n            print(\"{}: Entry {}\".format(po.fwmdlfile, i))\n            print(e)\n        hdcrc = amba_calculate_crc32h_part((c_ubyte * sizeof(e)).from_buffer_copy(e), hdcrc)\n        if (e.dt_len < 16) or (e.dt_len > 128*1024*1024):\n            raise_or_warn(po, ValueError(\"Entry at {:d} has bad size, {:d} bytes\".format(epos, e.dt_len)))\n        # Warn if no more module entries were expected\n        if (i >= len(modentries)):\n            raise_or_warn(po, ValueError(\"Data continues after parsing all {:d} known partitions; header inconsistent.\".format(i)))\n        print(\"{}: Extracting entry {:2d}, pos {:8d}, len {:8d} bytes\".format(po.fwmdlfile, i, epos, e.dt_len))\n        ptyp = amba_a9_part_entry_type_id(i)\n        amba_extract_partition_head(po, e, i, ptyp)\n        hdcrc = amba_extract_partition_data(po, fwmdlfile, e, i, ptyp, hdcrc)\n        if (hdcrc != hde.crc32):\n            raise_or_warn(po, ValueError(\"Entry {:d} cummulative checksum mismatch; got {:08X}, expected {:08X}.\"\n              .format(i, hdcrc, hde.crc32)))\n        elif (po.verbose > 1):\n            print(\"{}: Entry {:2d} cummulative checksum {:08X} matched OK\".format(po.fwmdlfile, i, hdcrc))\n        # Check if the date makes sense\n        if ((e.build_date_year() < 1970) or (e.build_date_month() < 1) or\n          (e.build_date_month() > 12) or (e.build_date_day() < 1) or (e.build_date_day() > 31)):\n            raise_or_warn(po, ValueError(\"Entry {:d} date makes no sense.\".format(i)))\n        elif (e.build_date_year() < 2004):\n            raise_or_warn(po, ValueError(\"Entry {:d} date is from before Ambarella formed as company.\".format(i)))\n        # verify if padding area is completely filled with 0x00000000\n        if (e.padding[0] != 0x00000000) or (len(set(e.padding)) != 1):\n            raise_or_warn(po, ValueError(\"Partition {:d} header uses values from padded area in an unknown manner.\".format(i)))\n    # Now verify checksum in main header\n    hdcrc = hdcrc ^ 0xffffffff\n    if (hdcrc != modhead.crc32):\n        raise_or_warn(po, ValueError(\"Total cummulative checksum mismatch; got {:08X}, expected {:08X}.\".format(hdcrc, modhead.crc32)))\n    elif (po.verbose > 1):\n        print(\"{}: Total cummulative checksum {:08X} matched OK\".format(po.fwmdlfile, hdcrc))\n    return\n\n\ndef amba_search_extract(po, fwmdlfile):\n    fwmdlmm = mmap.mmap(fwmdlfile.fileno(), length=0, access=mmap.ACCESS_READ)\n    epos = -sizeof(FwModPartHeader)\n    prev_dtlen = 0\n    prev_dtpos = 0\n    i = 0\n    while True:\n        epos = fwmdlmm.find(b'\\x90\\xEB\\x24\\xA3', epos+sizeof(FwModPartHeader))\n        if (epos < 0):\n            break\n        epos -= 24  # pos of 'magic' within FwModPartHeader\n        if (epos < 0):\n            continue\n        dtpos = epos + sizeof(FwModPartHeader)\n        e = FwModPartHeader.from_buffer_copy(fwmdlmm[epos:dtpos])\n        if (e.dt_len < 16) or (e.dt_len > 128*1024*1024) or (e.dt_len > fwmdlmm.size()-dtpos):\n            print(\"{}: False positive - entry at {:d} has bad size, {:d} bytes\".format(po.fwmdlfile, epos, e.dt_len))\n            continue\n        print(\"{}: Extracting entry {:2d}, pos {:8d}, len {:8d} bytes\".format(po.fwmdlfile, i, epos, e.dt_len))\n        if (prev_dtpos+prev_dtlen > epos):\n            raise_or_warn(po, ValueError(\"Partition {:d} overlaps with previous by {:d} bytes\"\n              .format(i, prev_dtpos + prev_dtlen - epos)))\n        ptyp = \"{:02d}\".format(i)\n        amba_extract_partition_head(po, e, i, ptyp)\n        amba_extract_partition_data_mm(po, fwmdlmm, epos, e, i, ptyp, None)\n        prev_dtlen = e.dt_len\n        prev_dtpos = dtpos\n        i += 1\n    return\n\n\ndef get_amba_max_modentry(po, ptyp_names):\n    modentry_max = 0\n    for ptyp in ptyp_names:\n        if ptyp not in part_entry_type_id:\n            raise ValueError(\"Unrecognized partition name in 'part_load' option.\")\n        i = part_entry_type_id.index(ptyp)\n        if (modentry_max < i):\n            modentry_max = i\n    return modentry_max\n\n\ndef amba_partition_exists(po, i, ptyp, ptyp_names):\n    \"\"\" Checks if there are any partition data for given index and type.\n    \"\"\"\n    fname = \"{:s}_part_{:s}.a9s\".format(po.ptprefix, ptyp)\n    # Skip unused modentries\n    if ptyp not in ptyp_names:\n        if (po.verbose > 1):\n            print(\"{}: Entry {:2d} empty\".format(po.fwmdlfile, i))\n        return False\n    # Also skip nonexisting ones\n    if (os.stat(fname).st_size < 1):\n        raise_or_warn(po, ValueError(\"Partition {:d} marked as existing but empty\".format(i)))\n        return False\n    return True\n\n\ndef amba_merge_partition_data(po, fwmdlfile, e, i, ptyp):\n    \"\"\" Opens the partition file for given `ptyp`, and copies the data to `fwmdlfile`.\n\n    This also updates properties within the `e` entry class.\n    \"\"\"\n    fname = \"{:s}_part_{:s}.a9s\".format(po.ptprefix, ptyp)\n    fwpartfile = open(fname, 'rb')\n    ptcrc = 0\n    n = 0\n    while True:\n        copy_buffer = fwpartfile.read(1024 * 1024)\n        if not copy_buffer:\n            break\n        n += len(copy_buffer)\n        fwmdlfile.write(copy_buffer)\n        ptcrc = amba_calculate_crc32b_part(copy_buffer, ptcrc)\n    e.dt_len = n\n    e.crc32 = ptcrc\n    if (po.verbose > 1):\n        print(\"{}: Entry {:2d} checksum {:08X}\".format(po.fwmdlfile, i, ptcrc))\n    return\n\n\ndef amba_create(po, fwmdlfile):\n    # Read headers from INI files\n    (modhead, ptyp_names, modposthd) = amba_read_mod_head(po)\n    modentries = []\n    # Get amount of partition slots to allocate\n    modentry_max = get_amba_max_modentry(po, ptyp_names)\n    # Create module entry for each partition\n    for i in range(modentry_max+1):\n        hde = FwModEntry()\n        modentries.append(hde)\n    # Write the unfinished headers\n    fwmdlfile.write((c_ubyte * sizeof(modhead)).from_buffer_copy(modhead))\n    for hde in modentries:\n        fwmdlfile.write((c_ubyte * sizeof(hde)).from_buffer_copy(hde))\n    fwmdlfile.write((c_ubyte * sizeof(modposthd)).from_buffer_copy(modposthd))\n    # Write the partitions\n    part_heads = []\n    i = -1\n    while True:\n        i += 1\n        if (i >= len(modentries)):\n            break\n        hde = modentries[i]\n        ptyp = amba_a9_part_entry_type_id(i)\n        if not amba_partition_exists(po, i, ptyp, ptyp_names):\n            e = FwModPartHeader()\n            part_heads.append(e)\n            continue\n        e = amba_read_part_head(po, i, ptyp)\n        epos = fwmdlfile.tell()\n        # Write unfinished header\n        fwmdlfile.write((c_ubyte * sizeof(e)).from_buffer_copy(e))\n        # Copy partition data and compute CRC\n        amba_merge_partition_data(po, fwmdlfile, e, i, ptyp)\n        part_heads.append(e)\n        # Write final partition header\n        npos = fwmdlfile.tell()\n        fwmdlfile.seek(epos, os.SEEK_SET)\n        fwmdlfile.write((c_ubyte * sizeof(e)).from_buffer_copy(e))\n        fwmdlfile.seek(npos, os.SEEK_SET)\n        # Store file beginning header\n        hde.dt_len = sizeof(e) + e.dt_len\n        modentries[i] = hde\n    # Compute cummulative CRC32\n    if (po.verbose > 1):\n        print(\"{}: Recomputing checksums\".format(po.fwmdlfile))\n    hdcrc = 0xffffffff\n    i = -1\n    while True:\n        i += 1\n        if (i >= len(modentries)):\n            break\n        hde = modentries[i]\n        ptyp = amba_a9_part_entry_type_id(i)\n        fname = \"{:s}_part_{:s}.a9s\".format(po.ptprefix, ptyp)\n        if (hde.dt_len < 1):\n            continue\n        fwpartfile = open(fname, 'rb')\n        e = part_heads[i]\n        hdcrc = amba_calculate_crc32h_part((c_ubyte * sizeof(e)).from_buffer_copy(e), hdcrc)\n        n = 0\n        while n < e.dt_len:\n            copy_buffer = fwpartfile.read(min(1024 * 1024, e.dt_len - n))\n            if not copy_buffer:\n                break\n            n += len(copy_buffer)\n            hdcrc = amba_calculate_crc32h_part(copy_buffer, hdcrc)\n        hde.crc32 = hdcrc\n        modentries[i] = hde\n    hdcrc = hdcrc ^ 0xffffffff\n    modhead.crc32 = hdcrc\n    if (po.verbose > 1):\n        print(\"{}: Total cummulative checksum {:08X}\".format(po.fwmdlfile, hdcrc))\n    # Write all headers again\n    fwmdlfile.seek(0, os.SEEK_SET)\n    fwmdlfile.write((c_ubyte * sizeof(modhead)).from_buffer_copy(modhead))\n    for hde in modentries:\n        fwmdlfile.write((c_ubyte * sizeof(hde)).from_buffer_copy(hde))\n    fwmdlfile.write((c_ubyte * sizeof(modposthd)).from_buffer_copy(modposthd))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-m', '--fwmdlfile', type=str, required=True,\n          help=\"name of the firmware module file\")\n\n    parser.add_argument('-t', '--ptprefix', type=str,\n          help=(\"file name prefix for the single decomposed partitions \"\n           \"(defaults to base name of firmware module file)\"))\n\n    parser.add_argument('--binfmt', type=str, default='auto',\n          help=(\"set binary format version\"\n           \"(default is to detect it (auto); valid formats are 2014 and 2016)\"))\n\n    parser.add_argument('--binhead', action='store_true',\n          help=(\"leave (`-x`) or use (`-a`) binary header in front of partition\"\n           \"this leaves the original binary header before each partition\"\n           \"on extraction, and uses that header on module file creation;\"\n           \"you normally should have no need to use it\"))\n\n    parser.add_argument('-f', '--force-continue', action='store_true',\n          help=\"force continuing execution despite warning signs of issues\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by `-vvv`\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract firmware module file into partitions\")\n\n    subparser.add_argument('-s', '--search', action='store_true',\n          help=(\"search for partitions within firmware module and extract them \"\n           \"(works similar to `-x`, but uses brute-force search for partitions)\"))\n\n    subparser.add_argument('-a', '--add', action='store_true',\n          help=(\"add partition files to firmware module file \"\n           \"(works only on data created with `-x`; the `-s` is insufficient)\"))\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    if len(po.fwmdlfile) > 0 and po.ptprefix is None:\n        po.ptprefix = os.path.splitext(os.path.basename(po.fwmdlfile))[0]\n\n    if po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extraction\".format(po.fwmdlfile))\n        with open(po.fwmdlfile, 'rb') as fwmdlfile:\n            if po.binfmt == 'auto':\n                po.binfmt = amba_detect_format(po, fwmdlfile)\n            amba_extract(po, fwmdlfile)\n\n    elif po.search:\n        if (po.verbose > 0):\n            print(\"{}: Opening for search\".format(po.fwmdlfile))\n        with open(po.fwmdlfile, 'rb') as fwmdlfile:\n            amba_search_extract(po, fwmdlfile)\n\n    elif po.add:\n        if (po.verbose > 0):\n            print(\"{}: Opening for creation\".format(po.fwmdlfile))\n        with open(po.fwmdlfile, 'wb') as fwmdlfile:\n            amba_create(po, fwmdlfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "amba_romfs.py",
          "type": "blob",
          "size": 13.423828125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Ambarella Firmware ROMFS tool.\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport argparse\nimport configparser\nimport itertools\nimport sys\nimport mmap\nimport os\nimport re\nfrom ctypes import c_char, c_char_p, c_ubyte, c_uint\nfrom ctypes import cast, sizeof, LittleEndianStructure\nfrom time import gmtime, strftime\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# The ROMFS file consists of 3 sections:\n# 1. Main header, padded\n# 2. File entries, padded at end only\n# 3. File data, padded after each entry\n# Note that padding is a bit unusual - if a file\n# length is exact multiplication of 2048, the\n# entry is still padded (with another 2048 bytes).\n\nclass ROMFSPartitionHeader(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [('file_count', c_uint), # Amount of files stored\n              ('magic', c_uint), # magic identifier, 66FC328A\n              ('padding', c_ubyte * 2040)] # padded with 0xff\n\n  def dict_export(self):\n    d = dict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    varkey = 'padding'\n    d[varkey] = \"\".join(\"{:02X}\".format(x) for x in d[varkey])\n    return d\n\n  def __repr__(self):\n    d = self.dict_export()\n    from pprint import pformat\n    return pformat(d, indent=4, width=1)\n\n\nclass ROMFSFileEntry(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [('filename', c_char * 116),\n              ('offset', c_uint),\n              ('length', c_uint),\n              ('magic', c_uint)]\n\n  def filename_str(self):\n    return cast(self.filename, c_char_p).value.decode('utf-8')\n\n  def dict_export(self):\n    d = dict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    return d\n\n  def __repr__(self):\n    d = self.dict_export()\n    from pprint import pformat\n    return pformat(d, indent=4, width=1)\n\n\ndef romfs_padded_size(content_offs):\n    # if (content_offs % 2048) != 0: - no, padding is not done this way\n    return content_offs + 2048 - (content_offs % 2048)\n\n\ndef romfs_extract_filesystem_head(po, fshead, fsentries):\n    fname = \"{:s}/{:s}\".format(po.snglfdir, \"_header.a9t\")\n    os.makedirs(os.path.dirname(fname), exist_ok=True)\n    inifile = open(fname, \"w\")\n    inifile.write(\"# Ambarella Firmware ROMFS header file. Loosly based on AFT format.\\n\")\n    inifile.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n    inifile.write(\"filelist={:s}\\n\".format(\",\".join(\"{:s}\".format(x.filename_str()) for x in fsentries)))\n    inifile.close()\n\n\ndef romfs_read_filesystem_head(po):\n    fshead = ROMFSPartitionHeader()\n    fsentries = []\n    fname = \"{:s}/{:s}\".format(po.snglfdir, \"_header.a9t\")\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n    singlefnames = parser.get(\"asection\", \"filelist\").split(\",\")\n    for sfname in singlefnames:\n        fe = ROMFSFileEntry()\n        fe.filename = sfname.encode('utf-8')\n        fe.offset = sizeof(fshead)\n        fe.magic = 0x2387AB76\n        fsentries.append(fe)\n    fshead.magic = 0x66FC328A\n    fshead.file_count = len(fsentries)\n    for i in range(len(fshead.padding)):\n        fshead.padding[i] = 0xff\n    del parser\n    return fshead, fsentries\n\n\ndef romfs_recompute_filesystem_lengths(po, fshead, fsentries):\n    for i, fe in enumerate(fsentries):\n        fname = \"{:s}/{:s}\".format(po.snglfdir, fe.filename_str())\n        fe.length = os.stat(fname).st_size\n    fshead.file_count = len(fsentries)\n    return fshead, fsentries\n\n\ndef romfs_recompute_filesystem_offsets(po, fshead, fsentries):\n    content_offs = sizeof(fshead)\n    # ROMFSPartitionHeader is already padded, no need for action\n    content_offs = romfs_padded_size(content_offs + len(fsentries) * sizeof(ROMFSFileEntry))\n    for i, fe in enumerate(fsentries):\n        fe.offset = content_offs\n        content_offs = romfs_padded_size(content_offs + fe.length)\n    fshead.file_count = len(fsentries)\n    return fshead, fsentries\n\n\ndef romfs_extract_filesystem_entry(po, fwpartfile, i, fe):\n    if (po.verbose > 0):\n        print(\"{}: Extracting entry {:d}: {:s}, {:d} bytes\".format(po.fwpartfile, i, fe.filename_str(), fe.length))\n    fwpartfile.seek(fe.offset, 0)\n    fname = \"{:s}/{:s}\".format(po.snglfdir, fe.filename_str())\n    os.makedirs(os.path.dirname(fname), exist_ok=True)\n    singlefile = open(fname, \"wb\")\n    n = 0\n    while n < fe.length:\n        copy_buffer = fwpartfile.read(min(1024 * 1024, fe.length - n))\n        if not copy_buffer:\n            break\n        n += len(copy_buffer)\n        singlefile.write(copy_buffer)\n    singlefile.close()\n    if (n < fe.length):\n        eprint(\"{}: Warning: file {:d} truncated, {:d} out of {:d} bytes\".format(po.fwpartfile, i, n, fe.length))\n\n\ndef romfs_write_filesystem_entry(po, fwpartfile, i, fe):\n    if (po.verbose > 0):\n        print(\"{}: Writing entry {:d}: {:s}, {:d} bytes\".format(po.fwpartfile, i, fe.filename_str(), fe.length))\n    while (fwpartfile.tell() < fe.offset):\n        fwpartfile.write(b'\\xFF')\n    fname = \"{:s}/{:s}\".format(po.snglfdir, fe.filename_str())\n    singlefile = open(fname, \"rb\")\n    n = 0\n    while n < fe.length:\n        copy_buffer = singlefile.read(min(1024 * 1024, fe.length - n))\n        if not copy_buffer:\n            break\n        n += len(copy_buffer)\n        fwpartfile.write(copy_buffer)\n    singlefile.close()\n    if (n < fe.length):\n        eprint(\"{}: Warning: file {:d} truncated, {:d} out of {:d} bytes\".format(po.fwpartfile, i, n, fe.length))\n    content_offs = romfs_padded_size(fwpartfile.tell())\n    while (fwpartfile.tell() < content_offs):\n        fwpartfile.write(b'\\xFF')\n\n\ndef romfs_extract(po, fwpartfile):\n    fshead = ROMFSPartitionHeader()\n    if fwpartfile.readinto(fshead) != sizeof(fshead):\n        raise EOFError(\"Couldn't read ROMFS partition file header.\")\n    if (po.verbose > 1):\n        print(\"{}: Header:\".format(po.fwpartfile))\n        print(fshead)\n    if (fshead.magic != 0x66FC328A):\n        eprint(\"{}: Warning: magic value is {:08X} instead of {:08X}.\".format(po.fwpartfile, fshead.magic, 0x66FC328A))\n        raise EOFError(\"Invalid magic value in main header. The file does not store a ROMFS filesystem.\")\n    if (fshead.file_count < 1) or (fshead.file_count > 16*1024):\n        eprint(\"{}: Warning: filesystem stores alarming amount of files, which is {:d}\".format(po.fwpartfile, fshead.file_count))\n    # verify if padding area is completely filled with 0xff\n    if (fshead.padding[0] != 0xff) or (len(set(fshead.padding)) != 1):\n        eprint(\"{}: Warning: filesystem uses values from padded area in an unknown manner.\".format(po.fwpartfile))\n\n    fsentries = []\n    for i in range(fshead.file_count):\n        fe = ROMFSFileEntry()\n        if fwpartfile.readinto(fe) != sizeof(fe):\n            raise EOFError(\"Could not read filesystem file header entries.\")\n        if (fe.magic != 0x2387AB76):\n            eprint(\"{}: Warning: entry {:d} has magic value {:08X} instead of {:08X}.\".format(po.fwpartfile, i, fe.magic, 0x2387AB76))\n        if re.match(b'[0-9A-Za-z._-]', fe.filename) is None:\n            eprint(\"{}: Warning: entry {:d} has invalid file name; skipping.\".format(po.fwpartfile, i))\n            continue\n        if (fe.length < 0) or (fe.length > 128*1024*1024):\n            eprint(\"{}: Warning: entry {:d} has bad size, {:d} bytes; skipping.\".format(po.fwpartfile, i, fe.length))\n            continue\n        if (fe.offset < 0) or (fe.offset > 128*1024*1024):\n            eprint(\"{}: Warning: entry {:d} has bad offset, {:d} bytes; skipping.\".format(po.fwpartfile, i, fe.offset))\n            continue\n        fsentries.append(fe)\n\n    if (po.verbose > 2):\n        print(\"{}: Entries:\".format(po.fwpartfile))\n        print(fsentries)\n\n    romfs_extract_filesystem_head(po, fshead, fsentries)\n\n    for i, fe in enumerate(fsentries):\n        romfs_extract_filesystem_entry(po, fwpartfile, i, fe)\n\n\ndef romfs_search_extract(po, fwpartfile):\n    fshead = ROMFSPartitionHeader()\n    fwpartmm = mmap.mmap(fwpartfile.fileno(), length=0, access=mmap.ACCESS_READ)\n    fsentries = []\n    epos = -sizeof(ROMFSFileEntry)\n    prev_dtlen = 0\n    prev_dtpos = 0\n    i = 0\n    while True:\n        epos = fwpartmm.find(b'\\x76\\xAB\\x87\\x23', epos+sizeof(ROMFSFileEntry))\n        if (epos < 0):\n            break\n        epos -= 124 # pos of 'magic' within FwModPartHeader\n        if (epos < 0):\n            continue\n        fe = ROMFSFileEntry.from_buffer_copy(fwpartmm[epos:epos+sizeof(ROMFSFileEntry)])\n        dtpos = fe.offset\n        if (fe.length < 0) or (fe.length > 128*1024*1024) or (fe.length > fwpartmm.size()-dtpos):\n            print(\"{}: False positive - entry at {:d} has bad size, {:d} bytes\".format(po.fwpartfile, epos, fe.length))\n            continue\n        if (prev_dtpos < dtpos+fe.length) and (prev_dtpos+prev_dtlen > dtpos):\n            eprint(\"{}: File {:d} data overlaps with previous by {:d} bytes\".format(po.fwpartfile, i, prev_dtpos + prev_dtlen - dtpos))\n        fsentries.append(fe)\n        prev_dtlen = fe.length\n        prev_dtpos = dtpos\n        i += 1\n\n    if (po.verbose > 2):\n        print(\"{}: Entries:\".format(po.fwpartfile))\n        print(fsentries)\n\n    romfs_extract_filesystem_head(po, fshead, fsentries)\n\n    for i, fe in enumerate(fsentries):\n        romfs_extract_filesystem_entry(po, fwpartfile, i, fe)\n\n\ndef romfs_create(po, fwpartfile):\n    fshead, fsentries = romfs_read_filesystem_head(po)\n    if (po.verbose > 2):\n        print(\"{}: Entries:\".format(po.fwpartfile))\n        print(fsentries)\n    fshead, fsentries = romfs_recompute_filesystem_lengths(po, fshead, fsentries)\n    fshead, fsentries = romfs_recompute_filesystem_offsets(po, fshead, fsentries)\n    if fwpartfile.write(fshead) != sizeof(fshead):\n        raise EOFError(\"Couldn't write ROMFS partition file main header.\")\n    for i, fe in enumerate(fsentries):\n        if fwpartfile.write(fe) != sizeof(fe):\n          raise EOFError(\"Couldn't write ROMFS partition file entry header.\")\n    for i, fe in enumerate(fsentries):\n        romfs_write_filesystem_entry(po, fwpartfile, i, fe)\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-p', '--fwpartfile', type=str, required=True,\n          help=\"name of the firmware partition file\")\n\n    parser.add_argument('-d', '--snglfdir', type=str,\n          help=(\"directory for the single extracted files \"\n           \"(defaults to base name of firmware partition file)\"))\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    #subparser.add_argument('-l', '--list', action='store_true',\n    #      help=\"list single files stored within partition file\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract partition file into single files\")\n\n    subparser.add_argument('-s', '--search', action='store_true',\n          help=(\"search for files within partition and extract them \"\n            \"(works similar to -x, but uses brute-force search for file entries)\"))\n\n    subparser.add_argument('-a', '--add', action='store_true',\n          help=\"add single files to partition file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    if len(po.fwpartfile) > 0 and po.snglfdir is None:\n        po.snglfdir = os.path.splitext(os.path.basename(po.fwpartfile))[0]\n\n    if po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extraction\".format(po.fwpartfile))\n        with open(po.fwpartfile, 'rb') as fwpartfile:\n            romfs_extract(po, fwpartfile)\n\n    elif po.search:\n        if (po.verbose > 0):\n            print(\"{}: Opening for search\".format(po.fwpartfile))\n        with open(po.fwpartfile, 'rb') as fwpartfile:\n            romfs_search_extract(po, fwpartfile)\n\n    elif po.add:\n        if (po.verbose > 0):\n            print(\"{}: Opening for creation\".format(po.fwpartfile))\n        with open(po.fwpartfile, 'wb') as fwpartfile:\n            romfs_create(po, fwpartfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "amba_sys2elf.py",
          "type": "blob",
          "size": 10.2890625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Ambarella Firmware SYS partiton to ELF converter.\n\n Converts \"System Software\" partition from Ambarella a7/a9 firmware\n from a binary image form into ELF format. The ELF format can be then\n easily disassembled, as most tools can read ELF files.\n\n The Ambarella SDK contains an example system application, on which\n most products which use Ambarella SoC base their software.\n The application is linked and prepared like this:\n```\n  /usr/bin/arm-none-eabi-ld \\\n   -EL -p --no-undefined --gc-sections --no-wchar-size-warning \\\n   -nostdlib -nodefaultlibs -nostartfiles \\\n   -L/usr/lib/arm-none-eabi/lib/armv7-ar/thumb/fpu \\\n   -L/usr/lib/gcc/arm-none-eabi/4.9.3/armv7-ar/thumb/fpu \\\n   -o out/amba_app.elf -T ../output/app/amba_app.lds \\\n   --start-group --whole-archive \\\n   ../output/lib/libapp.a \\\n   ../output/lib/libapplib.a \\\n   ../vendors/ambarella/lib/libaudio.a \\\n   ../vendors/ambarella/lib/libaudio_sys.a \\\n   ../output/lib/libbsp.a \\\n   [...]\n   ../vendors/ambarella/lib/libthreadx.a \\\n   ../vendors/ambarella/lib/libusb.a \\\n   --no-whole-archive -lc -lnosys -lm -lgcc -lrdimon -lstdc++ \\\n   --end-group \\\n   app/AmbaVer_LinkInfo.o\n\n  /usr/bin/arm-none-eabi-nm -n -l out/amba_app.elf\n\n  /usr/bin/arm-none-eabi-objcopy -O binary out/amba_app.elf out/amba_app.bin\n```\n Note that the last command converts a linked ELF file into a binary memory\n image. The purpose of this tool is to revert that last operation, which makes\n it a lot easier to use tols like objdump or IDA Pro.\n\n The script uses an ELF template, which was prepared from example Ambarella SDK\n application by the command (mock_sect.bin is a random file with 32 bytes size):\n```\n  echo \"MockDataToUpdateUsingObjcopy\" > mock_sect.bin\n  /usr/bin/arm-none-eabi-objcopy \\\n   --remove-section \".comment\" \\\n   --update-section \".text=mock_sect.bin\" --change-section-address \".text=0xa0001000\" \\\n   --change-section-address \".ARM.exidx=0xa0001020\" \\\n   --update-section \".dsp_buf=mock_sect.bin\" --change-section-address \".dsp_buf=0xa0001020\" \\\n   --update-section \".data=mock_sect.bin\" --change-section-address \".data=0xa0001040\" \\\n   --change-section-address \"no_init=0xa0001060\" \\\n   --change-section-address \".bss.noinit=0xa0004000\" \\\n   --change-section-address \".bss=0xa03a8000\" \\\n   amba_app.elf amba_sys2elf_template.elf\n```\n\n This tool really uses arm_bin2elf to do the work; it just sets optimal\n initial parameters for the Ambarella A9 firmware input.\n\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.4.0\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport argparse\nimport configparser\nimport itertools\nimport os\nimport sys\n\nsys.path.insert(0, './')\nfrom arm_bin2elf import eprint, armfw_bin2elf, parse_section_param\n\n\nBUFSIZE = 8*1024\n\n\ndef syssw_read_base_address(po, fname):\n    mem_addr = 0\n    # Do not use basename - a9h file is in the same folder where a9s was\n    if (po.verbose > 1):\n        print(\"{}: Opening {:s}\".format(po.fwpartfile, fname))\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines) # This line adds section header to ini\n        parser.read_file(lines)\n        mem_addr = int(parser.get(\"asection\", \"mem_addr\"), 16)\n    del parser\n    return mem_addr\n\n\ndef find_in_stream(fstrm, btpattern):\n    bufsize = BUFSIZE\n    offs = 0\n    overlay_len = (len(btpattern) + 15) & 0xfff0\n    btbuf = b''\n    while True:\n        nxbuf = fstrm.read(bufsize)\n        if not nxbuf:\n            break\n        read_len = len(nxbuf)\n        btbuf = btbuf[:-overlay_len] + nxbuf\n        btpos = btbuf.find(btpattern)\n        if btpos >= 0:\n            assert len(btbuf) >= read_len\n            return offs - (len(btbuf) - read_len) + btpos\n        offs += read_len\n    return -1\n\n\ndef amba_find_default_code_data_bound(po, fwpartfile):\n    \"\"\" Find code-data bound which is characteristic to DJIs Ambarella firmware.\n\n    Within DJIs firmware the Ambarella sys partition has no exceptions defined,\n    but there is clear code-data boundary where last code instruction is `MOVS PC, LR`,\n    and beyond that lies array of shorts which starts with `0, 4`. This combination\n    is unique enough to find and use as the boundary position.\n    \"\"\"\n    boundary_pattern = b'\\x0E\\xF0\\xB0\\xE1\\x00\\x00\\x04\\x00'\n    filepos = find_in_stream(fwpartfile, boundary_pattern)\n    if filepos >= 0:\n        return filepos + 4\n    return None\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    # Parse command line options\n    # Set optimal options for Ambarella A9 ARM firmware\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-p', '--fwpartfile', type=str, required=True,\n          help=\"executable ARM firmware binary module file\")\n\n    parser.add_argument('-o', '--elffile', type=str,\n          help=(\"directory and file name of output ELF file \"\n           \"(default is base name of fwpartfile with extension switched to elf, in working dir)\"))\n\n    parser.add_argument('-t', '--tmpltfile', type=str, default=\"amba_sys2elf_template.elf\",\n          help=\"template ELF file to use header fields from (default is \\\"%(default)s\\\")\")\n\n    parser.add_argument('-l', '--addrspacelen', default=0x2000000, type=lambda x: int(x,0),\n          help=(\"set address space length after base; the tool will expect used \"\n            \"addresses to end at baseaddr+addrspacelen, so it influences size \"\n            \"of last section (defaults to 0x%(default)X)\"))\n\n    parser.add_argument('-s', '--section', action='append', metavar=\"SECT@ADDR:LEN\", type=parse_section_param,\n          help=(\"set section position and/or length; can be used to override \"\n           \"detection of sections; setting section .ARM.exidx will influence \"\n           \".text and .data, moving them and sizing to fit one before and one \"\n           \"after the .ARM.exidx. Parameters are: \"\n           \"SECT - a text name of the section, as defined in elf template; multiple sections \"\n           \"can be cloned from the same template section by adding index at end (ie. .bss2); \"\n           \"ADDR - is an address of the section within memory (not input file position); \"\n           \"LEN - is the length of the section (in both input file and memory, unless its \"\n           \"uninitialized section, in which case it is memory size as file size is 0)\"))\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('--inifile', type=str,\n          help=\"INI file name with base address (default is fwpartfile with a9h extension appended)\")\n\n    subparser.add_argument('-b', '--baseaddr', type=lambda x: int(x,0),\n          help=(\"set base address; first section will start at this \"\n            \"memory location (default is to get address from INI file)\"))\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-e', '--mkelf', action='store_true',\n          help=\"make ELF file from a binary image\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.expect_func_align = 4 # Full length instructions are used in Cortex A9 binary\n    po.expect_sect_align = 0x20 # This is how sections are aligned in Ambarella SDK\n    # For some reason, if no \"--section\" parameters are present, argparse leaves this unset\n    if po.section is None:\n        po.section = []\n    # Flatten the sections we got in arguments\n    po.section_addr = {}\n    po.section_size = {}\n    for sect in po.section:\n        po.section_addr.update(sect['addr'])\n        po.section_size.update(sect['len'])\n\n    po.basename = os.path.splitext(os.path.basename(po.fwpartfile))[0]\n    # What differs Ambarella BIN from other BINs is INI file with base address inside\n    if len(po.fwpartfile) > 0 and (po.inifile is None or len(po.inifile) == 0):\n        # Assume .a9h is in the same folder as .a9s - do not strip path for it\n        po.inifile = os.path.splitext(po.fwpartfile)[0] + \".a9h\"\n    if len(po.fwpartfile) > 0 and (po.elffile is None or len(po.elffile) == 0):\n        po.elffile = po.basename + \".elf\"\n\n    if po.mkelf:\n        if (po.verbose > 0):\n            print(\"{}: Opening for conversion to ELF\".format(po.fwpartfile))\n        # read base address from INI file which should be there after AMBA extraction\n        if po.baseaddr is None:\n            po.baseaddr = syssw_read_base_address(po, po.inifile)\n        with open(po.fwpartfile, 'rb') as fwpartfile:\n            if \".ARM.exidx\" not in po.section_addr:\n                sectname = \".ARM.exidx\"\n                bound_pos = amba_find_default_code_data_bound(po, fwpartfile)\n                if bound_pos is not None:\n                    if (po.verbose > 0):\n                        print(\"{}: Found Ambarella-specific '{:s}' location\".format(po.fwpartfile, sectname))\n                    po.section_addr[sectname] = po.baseaddr + bound_pos\n                    po.section_size[sectname] = 0\n                fwpartfile.seek(0, os.SEEK_SET)\n            armfw_bin2elf(po, fwpartfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "amba_sys2elf_template.elf",
          "type": "blob",
          "size": 5.01953125,
          "content": null
        },
        {
          "name": "amba_sys_hardcoder.py",
          "type": "blob",
          "size": 127.8671875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Ambarella Firmware SYS partiton hard-coded values editor.\n\nThe tool can parse Ambarella firmware SYS partition converted to ELF.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nOnly 'setValue' element in the exported file is really changeable,\nall the other data is just informational. This includes `maxValue` and\n`minValue` - they don't do anything and changing them in the JSON file\nwill not influence update operation.\n\nExported values:\n\nog_hardcoded.p3x_ambarella.*_authority_level -\n\n  Authority Level controls whether the module should respond to external\n  commands. Normally it is set to `1`, but if encryption keys verification\n  failed at startup, it is set to `0`. These parameters allow to change the\n  value, so that the camera continues to operate normally even if keys are\n  different or SHA204 chip is missing. There is no reason to keep the values\n  unchanged even if encryption pairing currently works fine - the changes might\n  become helpful in case of hardware malfunction in that area.\n\n  Here's an example AmbaShell log when there's an issue with encryption which\n  results in lowest Authority Level:\n  ```\n  [DJI_ENCRYPT] [DjiEncryptCheckA9]check a9 mac failed\n  [DJI_ENCRYPT] [DjiEncryptReGetA9Status]a9's encrypt status[1] verify state[0]\n  ```\n\nog_hardcoded.p3x_ambarella.vid_setting_bitrates_* -\n\n  These are bitrates used when encoding videos to SD-card. There are 27 sets,\n  and which one is used depends on options selected in mobile app and on\n  model of the drone. Specifics are not known at this point.\n\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.3\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport os\nimport re\nimport io\nimport collections\nimport struct\nimport enum\nimport json\n\nfrom ctypes import c_ubyte, c_uint8, c_int, sizeof, LittleEndianStructure\n\ntry:\n    import capstone\n    from capstone import CS_ARCH_ARM, CS_ARCH_ARM64, CS_ARCH_X86, CS_ARCH_MIPS\n    from capstone import CS_MODE_ARM, CS_MODE_V8, CS_MODE_32, CS_MODE_64, CS_MODE_MIPS32, CS_MODE_MIPS64\n    from capstone import CS_MODE_THUMB, CS_MODE_LITTLE_ENDIAN, CS_MODE_BIG_ENDIAN\n    if not callable(getattr(capstone, \"Cs\", None)):\n        raise ImportError(\"The capstone library provided is incorrect - lacks Cs\")\nexcept ImportError:\n    print(\"Warning:\")\n    print(\"This tool requires capstone to disassemble binary bytecode.\")\n    raise\n\ntry:\n    import keystone\n    from keystone.keystone_const import KS_ARCH_ARM, KS_ARCH_ARM64, KS_ARCH_X86, KS_ARCH_MIPS\n    from keystone.keystone_const import KS_MODE_ARM, KS_MODE_V8, KS_MODE_32, KS_MODE_64, KS_MODE_MIPS32, KS_MODE_MIPS64\n    from keystone.keystone_const import KS_MODE_THUMB, KS_MODE_LITTLE_ENDIAN, KS_MODE_BIG_ENDIAN\n    from keystone import KsError\n    if not callable(getattr(keystone, \"Ks\", None)):\n        raise ImportError(\"The keystone library provided is incorrect - lacks Ks\")\nexcept ImportError:\n    print(\"Warning:\")\n    print(\"This tool requires keystone-engine to re-compile patched assembly.\")\n    raise\n\nsys.path.insert(0, '../pyelftools')\ntry:\n    from elftools.elf.elffile import ELFFile\n    from elftools.elf.constants import SH_FLAGS\n    if not callable(getattr(ELFFile, \"write_changes\", None)):\n        raise ImportError(\"The pyelftools library provided has no write support\")\nexcept ImportError:\n    print(\"Warning:\")\n    print(\"This tool requires version of pyelftools with ELF write support.\")\n    print(\"Try `arm_bin2elf.py` for details.\")\n    raise\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass VarType(enum.Enum):\n    # Variable points to code line from asm regular expression\n    DIRECT_LINE_OF_CODE = enum.auto()\n    # Variable contains directly entered integer value\n    DIRECT_INT_VALUE = enum.auto()\n    # Variable represents assembler operand\n    DIRECT_OPERAND = enum.auto()\n    # Variable contains absolute address to a code chunk or function\n    ABSOLUTE_ADDR_TO_CODE = enum.auto()\n    # Variable contains absolute address to a global variable\n    ABSOLUTE_ADDR_TO_GLOBAL_DATA = enum.auto()\n    # Variable contains address to a code chunk relative to some base address\n    RELATIVE_ADDR_TO_CODE = enum.auto()\n    # Variable contains relative address to a global variable which contains\n    # absolute address to the code chunk\n    RELATIVE_ADDR_TO_PTR_TO_CODE = enum.auto()\n    # Variable contains address to a global variable relative to some base address\n    RELATIVE_ADDR_TO_GLOBAL_DATA = enum.auto()\n    # Variable contains relative address to a global variable which contains\n    # absolute address to the real value\n    RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA = enum.auto()\n    # Variable contains offset in unknown relation to some address, ie\n    # field position within a struct; obsolete - use the above instead\n    RELATIVE_OFFSET = enum.auto()\n    # Variable contains data not directly bound to any input offset\n    DETACHED_DATA = enum.auto()\n    # Variable which value is unused in current variant of the code\n    UNUSED_DATA = enum.auto()\n    # Internal variable of the tool, not to be used in pattern definitions\n    INTERNAL_DATA = enum.auto()\n\n\nclass DataVariety(enum.Enum):\n    UNKNOWN = enum.auto()\n    CHAR = enum.auto()\n    UINT8_T = enum.auto()\n    UINT16_T = enum.auto()\n    UINT32_T = enum.auto()\n    UINT64_T = enum.auto()\n    INT8_T = enum.auto()\n    INT16_T = enum.auto()\n    INT32_T = enum.auto()\n    INT64_T = enum.auto()\n    FLOAT = enum.auto()\n    DOUBLE = enum.auto()\n    STRUCT = enum.auto()\n\n\nclass CodeVariety(enum.Enum):\n    # Just a chunk of code, not a function start\n    CHUNK = enum.auto()\n    # The pointed place is a function start\n    FUNCTION = enum.auto()\n\n\nclass DummyStruct(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [('unk', c_uint8)]\n\n\n# List of architectures\n# based on ropstone by blasty\nelf_archs = [\n    {\n        'name'     : \"arm\",\n        'cs_const' : CS_ARCH_ARM,\n        'ks_const' : KS_ARCH_ARM,\n        'boundary' : 4,\n        'modes'    : [\n            {\n                'name'     : \"arm\",\n                'desc'     : \"ARMv7 processor mode\",\n                'cs_const' : CS_MODE_ARM,\n                'ks_const' : KS_MODE_ARM,\n            },\n            {\n                'name'     : \"armv8\",\n                'desc'     : \"ARMv8 processor mode\",\n                'cs_const' : CS_MODE_V8,\n                'ks_const' : KS_MODE_V8,\n            },\n            {\n                'name'     : \"thumb\",\n                'desc'     : \"THUMB processor mode\",\n                'cs_const' : CS_MODE_THUMB,\n                'ks_const' : KS_MODE_THUMB,\n                # this overrides the boundary of the parent architecture\n                'boundary' : 2,\n                # this adds a shift offset to the output addr to force THUMB mode\n                'retshift' : 1,\n            },\n            {\n                'name'     : \"le\",\n                'desc'     : \"Little endian\",\n                'byteorder': \"little\",\n                'cs_const' : CS_MODE_LITTLE_ENDIAN,\n                'ks_const' : KS_MODE_LITTLE_ENDIAN,\n            },\n            {\n                'name'     : \"be\",\n                'desc'     : \"Big endian\",\n                'byteorder': \"big\",\n                'cs_const' : CS_MODE_BIG_ENDIAN,\n                'ks_const' : KS_MODE_BIG_ENDIAN,\n            },\n        ]\n    },\n    {\n        'name'     : \"arm64\",\n        'cs_const' : CS_ARCH_ARM64,\n        'ks_const' : KS_ARCH_ARM64,\n        'boundary' : 4,\n        'modes'    : [\n            {\n                'name'     : \"le\",\n                'desc'     : \"Little Endian\",\n                'byteorder': \"little\",\n                'cs_const' : CS_MODE_LITTLE_ENDIAN,\n                'ks_const' : KS_MODE_LITTLE_ENDIAN,\n            },\n        ]\n    },\n    {\n        'name'     : \"mips\",\n        'cs_const' : CS_ARCH_MIPS,\n        'ks_const' : KS_ARCH_MIPS,\n        'boundary' : 4,\n        'modes'    : [\n            {\n                'name'     : \"32b\",\n                'desc'     : \"MIPS32\",\n                'cs_const' : CS_MODE_MIPS32,\n                'ks_const' : KS_MODE_MIPS32,\n            },\n            {\n                'name'     : \"64b\",\n                'desc'     : \"MIPS64\",\n                'cs_const' : CS_MODE_MIPS64,\n                'ks_const' : KS_MODE_MIPS64,\n            },\n            {\n                'name'     : \"le\",\n                'desc'     : \"Little endian\",\n                'byteorder': \"little\",\n                'cs_const' : CS_MODE_LITTLE_ENDIAN,\n                'ks_const' : KS_MODE_LITTLE_ENDIAN,\n            },\n            {\n                'name'     : \"be\",\n                'desc'     : \"Big endian\",\n                'byteorder': \"big\",\n                'cs_const' : CS_MODE_BIG_ENDIAN,\n                'ks_const' : KS_MODE_BIG_ENDIAN,\n            },\n        ]\n    },\n    {\n        'name'     : \"x86\",\n        'cs_const' : CS_ARCH_X86,\n        'ks_const' : KS_ARCH_X86,\n        'boundary' : 1,\n        'modes'    : [\n            {\n                'name'     : \"32b\",\n                'desc'     : \"x86 32bit\",\n                'byteorder': \"little\",\n                'cs_const' : CS_MODE_32,\n                'ks_const' : KS_MODE_32,\n            },\n            {\n                'name'     : \"64b\",\n                'desc'     : \"x86_64 64bit\",\n                'byteorder': \"little\",\n                'cs_const' : CS_MODE_64,\n                'ks_const' : KS_MODE_64,\n            },\n        ]\n    }\n]\n\n\n# Function with address to _msg_author_level\nre_func_DjiMsgAuthorLevelGet = {\n'name': \"DjiMsgAuthorLevelGet\",\n'version': \"P3X_FW_V01.01\",\n're': \"\"\"\nDjiMsgAuthorLevelGet:\n  ldr\tr0, \\[pc, #(?P<msg_author_level>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  bx\tlr\n\"\"\",\n'vars': {\n  'DjiMsgAuthorLevelGet':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'msg_author_level': {'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n},\n}\n\n\nre_func_DjiMsgSettingsInit = {\n'name': \"DjiMsgSettingsInit\",\n'version': \"P3X_FW_V01.01\",\n're': \"\"\"\nDjiMsgSettingsInit:\n  push\t{r4, r5, lr}\n  sub\tsp, sp, #0x14\n  mov\tr4, #0\n  mov\tr1, #0\n  strb\tr1, \\[sp, #0x11\\]\n  mov\tr1, #0\n  strb\tr1, \\[sp, #0x10\\]\n  mov\tr5, #0\n  ldr\tr0, \\[pc, #(?P<dji_msg_mutex>[0-9a-fx]+)\\]\n  bl\t#(?P<AmbaKAL_MutexCreate>[0-9a-fx]+)\n  movs\tr4, r0\n  cmp\tr4, #0\n  beq\t#(?P<loc_label02>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<printk_log_level>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  cmp\tr0, #0\n  bmi\t#(?P<loc_label03>[0-9a-fx]+)\n  mov\tr5, #0\n  mov\tr0, #1\n  movs\tr5, r0\n  bl\t#(?P<AmbaPrintk_Disabled>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_label03>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  str\tr0, \\[sp, #0xc\\]\n  ldr\tr0, \\[pc, #(?P<cstr_fmt_text1>[0-9a-fx]+)\\]\n  str\tr0, \\[sp, #8\\]\n  str\tr5, \\[sp, #4\\]\n  mov\tr0, #0\n  str\tr0, \\[sp\\]\n  mov\tr3, #0\n  mov\tr2, #1\n  mov\tr1, #1\n  mov\tr0, #1\n  bl\t#(?P<AmbaPrintk>[0-9a-fx]+)\nloc_label03:\n  movs\tr0, r4\n  b\t#(?P<loc_label06>[0-9a-fx]+)\nloc_label02:\n  mov\tr0, #0\n  bl\t#(?P<DjiMsgAuthorLevelSet>[0-9a-fx]+)\n  movs\tr4, r0\n  add\tr1, sp, #0x10\n  add\tr0, sp, #0x11\n  bl\t#(?P<DjiEncryptGetA9Status>[0-9a-fx]+)\n  cmp\tr0, #0\n  beq\t#(?P<loc_label09>[0-9a-fx]+)\n  mov\tr0, #(?P<encrypt_query_fail_authority_level>[0-9a-fx]+)\n  bl\t#(?P<DjiMsgAuthorLevelSet>[0-9a-fx]+)\nloc_label09:\n  ldrb\tr0, \\[sp, #0x11\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_label10>[0-9a-fx]+)\n  ldrb\tr0, \\[sp, #0x10\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_label10>[0-9a-fx]+)\n  mov\tr0, #(?P<verify_state_good_authority_level>[0-9a-fx]+)\n  bl\t#(?P<DjiMsgAuthorLevelSet>[0-9a-fx]+)\n  b\t#(?P<loc_label11>[0-9a-fx]+)\nloc_label10:\n  mov\tr0, #(?P<verify_state_bad_authority_level>[0-9a-fx]+)\n  bl\t#(?P<DjiMsgAuthorLevelSet>[0-9a-fx]+)\nloc_label11:\n  mov\tr5, #0\n  b\t#(?P<loc_label12>[0-9a-fx]+)\nloc_label13:\n  ldr\tr0, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  lsls\tr1, r5, #2\n  ldr\tr2, \\[pc, #(?P<unk_var02>[0-9a-fx]+)\\]\n  adds\tr1, r1, r2\n  mov\tr2, #1\n  str\tr2, \\[r0, r1\\]\n  adds\tr5, r5, #1\nloc_label12:\n  cmp\tr5, #4\n  blo\t#(?P<loc_label13>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_var03>[0-9a-fx]+)\\]\n  mov\tr1, #0\n  str\tr1, \\[r0\\]\n  ldr\tr0, \\[pc, #(?P<unk_var04>[0-9a-fx]+)\\]\n  mov\tr1, #1\n  str\tr1, \\[r0\\]\n  ldr\tr0, \\[pc, #(?P<msg_adjust_task_finished>[0-9a-fx]+)\\]\n  mov\tr1, #0\n  str\tr1, \\[r0\\]\n  ldr\tr0, \\[pc, #(?P<unk_var05>[0-9a-fx]+)\\]\n  mov\tr1, #0\n  str\tr1, \\[r0\\]\n  mov\tr2, #0x90\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var06>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #0x38\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var07>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #0xc\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var08>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #8\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var09>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dji_msg_mutex>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<unk_var10>[0-9a-fx]+)\\]\n  str\tr1, \\[r0, #(?P<unk_offs01>[0-9a-fx]+)\\]\n  movw\tr2, #0x1010\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var11>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #8\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var12>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #0xc\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var13>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #8\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var14>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #0x16\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var15>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_var16>[0-9a-fx]+)\\]\n  mov\tr1, #0\n  strb\tr1, \\[r0\\]\n  mov\tr2, #0x36\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var17>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_var18>[0-9a-fx]+)\\]\n  mov\tr1, #1\n  str\tr1, \\[r0\\]\n  mov\tr2, #0xc\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var19>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr2, #4\n  mov\tr1, #0\n  ldr\tr0, \\[pc, #(?P<unk_var20>[0-9a-fx]+)\\]\n  bl\t#(?P<memset_0>[0-9a-fx]+)\n  mov\tr0, #0\nloc_label06:\n  add\tsp, sp, #0x14\n  pop\t{r4, r5, pc}\n\"\"\",\n'vars': {\n  'DjiMsgSettingsInit':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'AmbaKAL_MutexCreate':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'AmbaPrintk_Disabled':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'AmbaPrintk':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'DjiMsgAuthorLevelSet':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'DjiEncryptGetA9Status':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memset_0':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'cstr_fmt_text1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_func_name':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dji_msg_mutex':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'msg_adjust_task_finished':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'printk_log_level':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'encrypt_query_fail_authority_level':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.p3x_ambarella\", 'minValue': \"0\", 'maxValue': \"2\", 'defaultValue': \"0\",\n    'description': \"AuthorityLevel established when SHA204 communication fail; 0-restricted,1-normal,2-superuser\"},\n  'verify_state_good_authority_level':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.p3x_ambarella\", 'minValue': \"0\", 'maxValue': \"2\", 'defaultValue': \"1\",\n    'description': \"AuthorityLevel established when encryption keys match; 0-restricted,1-normal,2-superuser\"},\n  'verify_state_bad_authority_level':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.p3x_ambarella\", 'minValue': \"0\", 'maxValue': \"2\", 'defaultValue': \"0\",\n    'description': \"AuthorityLevel established on encryption mismatch; 0-restricted,1-normal,2-superuser\"},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label09':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label11':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label12':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label13':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'unk_offs01':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'unk_var01':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var02':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var03':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var04':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var05':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var06':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var07':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var08':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var09':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var10':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var11':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var12':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var13':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var14':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var15':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var16':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var17':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var18':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var19':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var20':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n},\n}\n\n\nclass AmbaP3XBitrateTableEntry(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [('min', c_int),\n              ('avg', c_int),\n              ('max', c_int)]\n\n\nre_func_DjiUstVideoQualitySetInner = {\n'name': \"DjiUstVideoQualitySetInner\",\n'version': \"P3X_FW_V01.01\",\n're': \"\"\"\nDjiUstVideoQualitySetInner:\n  push\t{r4, r5, lr}\n  sub\tsp, sp, #0x14\n  movs\tr4, r0\n  ldr\tr0, \\[r4\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_label01>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_label02>[0-9a-fx]+)\n  blo\t#(?P<loc_label03>[0-9a-fx]+)\n  b\t#(?P<loc_label04>[0-9a-fx]+)\nloc_label01:\n  add\tr0, r2, r2, lsl #1\n  ldr\tr1, \\[pc, #(?P<vid_setting_bitrates>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r1, r0, lsl #2\\]\nloc_label06:\n  cmp\tr0, #0\n  beq\t#(?P<loc_label05>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  ldrsb\tr1, \\[r1, #0x12\\]\n  mov\tr2, #0x54\n  ldr\tr3, \\[pc, #(?P<vid_settings_ust>[0-9a-fx]+)\\]\n  smlabb\tr1, r1, r2, r3\n  str\tr0, \\[r1, #8\\]\nloc_label05:\n  mov\tr0, #0\nloc_label08:\n  add\tsp, sp, #0x14\n  pop\t{r4, r5, pc}\nloc_label03:\n  add\tr0, r2, r2, lsl #1\n  ldr\tr1, \\[pc, #(?P<vid_setting_bitrates>[0-9a-fx]+)\\]\n  adds\tr0, r1, r0, lsl #2\n  ldr\tr0, \\[r0, #4\\]\n  b\t#(?P<loc_label06>[0-9a-fx]+)\nloc_label02:\n  add\tr0, r2, r2, lsl #1\n  ldr\tr1, \\[pc, #(?P<vid_setting_bitrates>[0-9a-fx]+)\\]\n  adds\tr0, r1, r0, lsl #2\n  ldr\tr0, \\[r0, #8\\]\n  b\t#(?P<loc_label06>[0-9a-fx]+)\nloc_label04:\n  ldr\tr0, \\[pc, #(?P<printk_log_level>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  cmp\tr0, #0\n  bmi\t#(?P<loc_label07>[0-9a-fx]+)\n  mov\tr5, #0\n  mov\tr0, #1\n  movs\tr5, r0\n  bl\t#(?P<AmbaPrintk_Disabled>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_label07>[0-9a-fx]+)\n  ldr\tr0, \\[r4\\]\n  str\tr0, \\[sp, #0x10\\]\n  ldr\tr0, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  str\tr0, \\[sp, #0xc\\]\n  ldr\tr0, \\[pc, #(?P<cstr_fmt_text1>[0-9a-fx]+)\\]\n  str\tr0, \\[sp, #8\\]\n  str\tr5, \\[sp, #4\\]\n  mov\tr0, #0\n  str\tr0, \\[sp\\]\n  mov\tr3, #0\n  mov\tr2, #1\n  mov\tr1, #1\n  mov\tr0, #1\n  bl\t#(?P<AmbaPrintk>[0-9a-fx]+)\nloc_label07:\n  mvn\tr0, #0\n  b\t#(?P<loc_label08>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'DjiUstVideoQualitySetInner':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'cstr_fmt_text1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_func_name':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'AmbaPrintk_Disabled':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'AmbaPrintk':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label04':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label05':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label07':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'unk_var01':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'vid_settings_ust':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'vid_setting_bitrates':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'array': 27,\n    'struct': AmbaP3XBitrateTableEntry,\n    'public': \"og_hardcoded.p3x_ambarella\", 'minValue': \"1000000 1000000 1000000\", 'maxValue': \"64000000 64000000 64000000\",\n    'description': \"Bitrates used for h.264 video compression; 3 values: min, avg, max\"},\n  'printk_log_level':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n},\n}\n\n\nre_general_list = [\n  {'sect': \".text\", 'func': re_func_DjiMsgSettingsInit,},\n  {'sect': \".text\", 'func': re_func_DjiUstVideoQualitySetInner,},\n]\n\n\ndef get_asm_arch_by_name(arname):\n    global elf_archs\n    for arch in elf_archs:\n        if arch['name'] == arname:\n            return arch.copy()\n    return None\n\n\ndef get_asm_mode_by_name(arch, mdname):\n    for mode in arch['modes']:\n        if mode['name'] == mdname:\n            return mode\n    return None\n\n\ndef elf_march_to_asm_config(elfobj, submode=None):\n    \"\"\" Retrieves machine architecture for given elf.\n\n    Returns config for capstone and keystone.\n    \"\"\"\n    march = elfobj.get_machine_arch()\n    asm_arch = None\n    asm_modes = []\n    if march == \"x64\":\n        asm_arch = get_asm_arch_by_name(\"x86\")\n        asm_modes.append(get_asm_mode_by_name(asm_arch, \"64b\"))\n    elif march == \"x86\":\n        asm_arch = get_asm_arch_by_name(\"x86\")\n        asm_modes.append(get_asm_mode_by_name(asm_arch, \"32b\"))\n    elif march == \"ARM\":\n        asm_arch = get_asm_arch_by_name(\"arm\")\n        if elfobj.little_endian:\n            asm_modes.append(get_asm_mode_by_name(asm_arch, \"le\"))\n        else:\n            asm_modes.append(get_asm_mode_by_name(asm_arch, \"be\"))\n    elif march == \"MIPS\":\n        asm_arch = get_asm_arch_by_name(\"mips\")\n        asm_modes.append(get_asm_mode_by_name(asm_arch, \"32b\"))\n        if elfobj.little_endian:\n            asm_modes.append(get_asm_mode_by_name(asm_arch, \"le\"))\n        else:\n            asm_modes.append(get_asm_mode_by_name(asm_arch, \"be\"))\n    if submode is not None:\n        asm_modes.append(get_asm_mode_by_name(asm_arch, submode))\n    return (asm_arch, asm_modes,)\n\n\ndef get_arm_vma_relative_to_pc_register(asm_arch, section, address, size, offset_str):\n    \"\"\" Gets Virtual Memory Address associated with offet given within an asm instruction.\n\n    ARMs have a way of storing relative offsets which may be confusing at first.\n    \"\"\"\n    alignment = asm_arch['boundary']\n    # In ARM THUMB mode, alignment is 4\n    if (asm_arch['name'] == \"arm\") and (alignment == 2):\n        alignment = 4\n    if isinstance(offset_str, int):\n        offset_int = offset_str\n    else:\n        offset_int = int(offset_str, 0)\n    address = address - (address % alignment)\n    vma = address + size + asm_arch['boundary'] + offset_int\n    return vma - (vma % alignment)\n\ndef get_arm_vma_subtracted_from_pc_register(asm_arch, section, address, size, offset_str):\n    \"\"\" Gets Virt Mem Addr associated to offset subtracted from PC reg within an asm instruction.\n    \"\"\"\n    alignment = asm_arch['boundary']\n    # In ARM THUMB mode, alignment is 4\n    if (asm_arch['name'] == \"arm\") and (alignment == 2):\n        alignment = 4\n    if isinstance(offset_str, int):\n        offset_int = offset_str\n    else:\n        offset_int = int(offset_str, 0)\n    address = address - (address % alignment)\n    vma = address + size - offset_int\n    return vma - (vma % asm_arch['boundary'])\n\n\ndef get_arm_offset_val_relative_to_pc_register(asm_arch, address, size, vma):\n    \"\"\" Gets offset associated with Virt Mem Addr given to place into asm instruction.\n    \"\"\"\n    offset_val = vma - address - size - asm_arch['boundary']\n    return offset_val\n\n\ndef get_section_and_offset_from_address(asm_arch, elf_sections, address):\n    \"\"\" Gets Virtual Memory Address associated with offset given within an asm instruction.\n    \"\"\"\n    for sect_name, sect in elf_sections.items():\n        offset = address - sect['addr']\n        if (offset >= 0) and (offset < len(sect['data'])):\n            return sect_name, offset\n    return None, None\n\n\ndef armfw_elf_generic_objdump(po, elffh, asm_submode=None):\n    \"\"\" Dump executable in similar manner to objdump disassemble function.\n    \"\"\"\n    elfobj = ELFFile(elffh)\n\n    asm_arch, asm_modes = elf_march_to_asm_config(elfobj, asm_submode)\n    if len(asm_modes) < 1 or not isinstance(asm_modes[0], collections.abc.Mapping):\n        raise ValueError(\"ELF has unsupported machine type ({:s}).\".format(elfobj['e_machine']))\n\n    cs_mode = 0\n    retshift = 0\n    for mode in asm_modes:\n        cs_mode = cs_mode | mode['cs_const']\n        # check for mode specific overrides (only needed for THUMB atm)\n        if 'boundary' in mode:\n            asm_arch['boundary'] = mode['boundary']\n        if 'retshift' in mode:\n            retshift = mode['retshift']\n\n    cs = capstone.Cs(asm_arch['cs_const'], cs_mode)\n\n    # Get sections dictionary, so that we can easily access them by name\n    elf_sections = {}\n    for i in range(elfobj.num_sections()):\n        esection = elfobj.get_section(i)\n\n        if esection['sh_type'] != \"SHT_PROGBITS\":\n            continue\n\n        if not (esection['sh_flags'] & SH_FLAGS.SHF_ALLOC):\n            continue\n\n        if (po.verbose > 2):\n            print(\"{:s}: Found section {:s}\".format(po.elffile, esection.name))\n\n        section = {\n              'index': i,\n              'name': esection.name,\n              'addr': esection['sh_addr'],\n              'data': esection.data(),\n        }\n        elf_sections[section.name] = section\n\n        if (esection['sh_flags'] & SH_FLAGS.SHF_EXECINSTR):\n            sect_offs = 0\n            while sect_offs < len(section['data']):\n                for (address, size, mnemonic, op_str) in cs.disasm_lite(section['data'][sect_offs:], section['addr']+sect_offs):\n                    print(\"0x{:05x}:\\t{:s}\\t{:s}\".format(address, mnemonic, op_str))\n                    sect_offs += size\n                size = len(section['data']) - sect_offs\n                if size > asm_arch['boundary']:\n                    size = asm_arch['boundary']\n                address = section['addr']+sect_offs\n                if size > 0:\n                    print(\"0x{:05x}:\\tdcb\\t\".format(address), end='')\n                    for bt in section['data'][sect_offs:sect_offs+size]:\n                        print(\"0x{:02x} \".format(bt), end='')\n                    print(\"\")\n                sect_offs += size\n        else:\n            sect_offs = 0\n            while sect_offs < len(section['data']):\n                size = len(section['data']) - sect_offs\n                if size > 4:\n                    size = 4\n                address = section['addr']+sect_offs\n                if size > 0:\n                    print(\"0x{:05x}:\\tdcb\\t\".format(address), end='')\n                    for bt in section['data'][sect_offs:sect_offs+size]:\n                        print(\"0x{:02x} \".format(bt), end='')\n                    print(\"\")\n                sect_offs += size\n    return\n\n\ndef armfw_asm_search_strings_to_re_list(re_patterns):\n    \"\"\" Converts multiline regex string to a list of patterns.\n    \"\"\"\n    # Divide to lines\n    re_lines = re_patterns.split(sep=\"\\n\")\n    re_labels = {}\n    # Remove comments\n    re_lines = [s.split(\";\",1)[0] if \";\" in s else s for s in re_lines]\n    # Remove labels\n    for i, s in enumerate(re_lines):\n        re_label = re.search(r'^([a-zA-Z0-9_]+):(.*)$', s)\n        if re_label is not None:\n            re_lines[i] = re_label.group(2)\n            re_labels[re_label.group(1)] = i\n    # Strip whitespaces\n    re_lines = list(map(str.strip, re_lines))\n    # Later empty lines will be removed; update re_labels accordingly\n    reduced_line = 0\n    for s in re_lines:\n        if s == \"\":\n            for lab_name, lab_line in re_labels.items():\n                if (lab_line > reduced_line):\n                    re_labels[lab_name] = lab_line - 1\n        else:\n            reduced_line += 1\n    # Remove empty lines\n    return list(filter(None, re_lines)), re_labels\n\n\ndef armfw_elf_section_search_init(asm_arch, section, patterns):\n    \"\"\" Initialize search data.\n    \"\"\"\n    search = {}\n    search['asm_arch'] = asm_arch\n    search['section'] = section\n    search['name'] = patterns['name']\n    search['version'] = patterns['version']\n    re_lines, re_labels = armfw_asm_search_strings_to_re_list(patterns['re'])\n    search['re'] = re_lines\n    search['var_defs'] = patterns['vars'].copy()\n    for lab_name, lab_line in re_labels.items():\n        if lab_name in search['var_defs']:\n            var_def = search['var_defs'][lab_name]\n            var_def['line'] = lab_line\n    search['var_vals'] = {}\n    # Starting address of the current match\n    search['match_address'] = 0\n    # Binary size of each matched regex line\n    search['re_size'] = []\n    # Amount of lines already matched (aka current line)\n    search['match_lines'] = 0\n    search['best_match_address'] = 0\n    search['best_match_lines'] = 0\n    # List of datasets for full matches\n    search['full_matches'] = []\n    # Variant of the current variable length statement\n    search['varlen_inc'] = 0\n    # List of points where variable length lines were found\n    search['varlen_points'] = []\n    return search\n\n\ndef armfw_elf_section_search_reset(search):\n    \"\"\" Reset search data after matching failed.\n    \"\"\"\n    if search['best_match_lines'] < search['match_lines']:\n        search['best_match_address'] = search['match_address']\n        search['best_match_lines'] = search['match_lines']\n    search['var_vals'] = {}\n    search['match_address'] = 0\n    search['re_size'] = []\n    search['match_lines'] = 0\n    search['varlen_inc'] = 0\n    search['varlen_points'] = []\n    return search\n\n\ndef armfw_elf_section_search_varlen_point_mark(search, address, varlen_delta):\n    \"\"\" Add or update variable length point in given search results.\n    \"\"\"\n    # the search['match_address'], might be unset if we are matching first line;\n    # in that case, use address from func parameter\n    if search['match_lines'] < 1:\n        search['match_address'] = address\n    # do not change search['varlen_inc'], only the one which will be used\n    # if matching current one will fail\n    for varlen in search['varlen_points']:\n        if varlen['match_address'] != search['match_address']:\n            continue\n        if varlen['match_lines'] != search['match_lines']:\n            continue\n        if sum(varlen['re_size']) != sum(search['re_size']):\n            continue\n        # found pre-existing varlen point\n        varlen['varlen_delta'] = varlen_delta\n        if varlen_delta > 0:\n            varlen['varlen_inc'] += 1\n        return search\n    varlen = {}\n    varlen['var_vals'] = search['var_vals'].copy()\n    varlen['match_address'] = search['match_address'] # int value\n    varlen['re_size'] = search['re_size'].copy()\n    varlen['match_lines'] = search['match_lines'] # int value\n    varlen['varlen_inc'] = 1 # 0 is already being tested when this is added\n    varlen['varlen_delta'] = varlen_delta\n    search['varlen_points'].append(varlen)\n    return search\n\n\ndef armfw_elf_section_search_varlen_point_rewind(search):\n    \"\"\" Rewinds the search to last varlen entry which may be increased.\n    \"\"\"\n    if search['best_match_lines'] < search['match_lines']:\n        search['best_match_address'] = search['match_address']\n        search['best_match_lines'] = search['match_lines']\n    for varlen in reversed(search['varlen_points']):\n        if varlen['varlen_delta'] <= 0:\n            search['varlen_points'].pop()\n            continue\n        search['var_vals'] = varlen['var_vals'].copy()\n        search['match_address'] = varlen['match_address'] # int value\n        search['re_size'] = varlen['re_size'].copy()\n        search['match_lines'] = varlen['match_lines'] # int value\n        search['varlen_inc'] = varlen['varlen_inc']\n        return True\n    return False\n\n\ndef armfw_elf_section_search_progress(search, match_address, match_line_size):\n    \"\"\" Update search data after matching next line suceeded.\n    \"\"\"\n    search['match_lines'] += 1\n    if search['match_lines'] == 1:\n        search['match_address'] = match_address\n        search['re_size'] = []\n    search['varlen_inc'] = 0\n    search['re_size'].append(match_line_size)\n    if search['match_lines'] == len(search['re']):\n        search['full_matches'].append({\n          'address': search['match_address'],\n          're': search['re'],\n          're_size': search['re_size'],\n          'vars': search['var_vals'],\n        })\n        search['match_lines'] = 0\n    return search\n\n\ndef armfw_elf_section_search_print_unused_vars(search):\n    \"\"\" Show messages about unused variables defined in the regex.\n    To be used after a match is found.\n    \"\"\"\n    for var_name in search['var_defs']:\n        if var_name in search['var_vals']:\n            continue\n        var_val_found = False\n        # Handle vars with suffixes\n        for var_val_name in search['var_vals']:\n            if var_val_name.startswith(var_name+\"_\"):\n                var_val_found = True\n                break\n        if var_val_found:\n            continue\n        print(\"Variable '{:s}' defined but not used within matched regex\".format(var_name))\n\n\ndef armfw_elf_section_search_get_pattern(search):\n    \"\"\" Get regex pattern to match with next line.\n    \"\"\"\n    re_patterns = search['re']\n    match_lines = search['match_lines']\n    return re_patterns[match_lines]\n\n\ndef armfw_elf_section_search_get_next_search_pos(search, sect_offs):\n    \"\"\" Get position to start a next search before resetting current one.\n    \"\"\"\n    # We intentionally clean 're_size' only on reset,\n    # so that it could be used here even after full match\n    asm_arch = search['asm_arch']\n    if len(search['re_size']) > 0:\n        new_offs = search['match_address'] - search['section']['addr'] + \\\n          min(asm_arch['boundary'], search['re_size'][0])\n        return new_offs\n    else:\n        new_offs = sect_offs + asm_arch['boundary']\n        return new_offs - (new_offs % asm_arch['boundary'])\n\n\ndef variety_is_signed_int(var_variety):\n    return var_variety in (DataVariety.INT8_T, DataVariety.INT16_T, DataVariety.INT32_T, DataVariety.INT64_T,)\n\n\ndef variety_is_unsigned_int(var_variety):\n    return var_variety in (DataVariety.UINT8_T, DataVariety.UINT16_T, DataVariety.UINT32_T, DataVariety.UINT64_T,)\n\n\ndef variety_is_string(var_variety):\n    return var_variety in (DataVariety.CHAR,)\n\n\ndef variety_is_float(var_variety):\n    return var_variety in (DataVariety.FLOAT, DataVariety.DOUBLE,)\n\n\ndef armfw_elf_section_search_get_value_variety_size(var_variety):\n    \"\"\" Get expected size of the value\n    \"\"\"\n    if var_variety in (DataVariety.CHAR, DataVariety.UINT8_T, DataVariety.INT8_T,):\n        var_size = 1\n    elif var_variety in (DataVariety.UINT16_T, DataVariety.INT16_T,):\n        var_size = 2\n    elif var_variety in (DataVariety.UINT32_T, DataVariety.INT32_T, DataVariety.FLOAT,):\n        var_size = 4\n    elif var_variety in (DataVariety.UINT64_T, DataVariety.INT64_T, DataVariety.DOUBLE,):\n        var_size = 8\n    else:\n        var_size = 0\n    return var_size\n\n\ndef value_type_is_known_address(var_def):\n    \"\"\" Returns whether given type represents an address which can be referenced.\n\n    Only some addresses can be converted to global addresses by this tool; an address is known\n    if it either is global to begin with, or can be converted to global.\n    If the address is known, property 'value' field will hold the absolute address.\n    \"\"\"\n    if var_def['type'] in (VarType.RELATIVE_ADDR_TO_CODE, VarType.RELATIVE_ADDR_TO_PTR_TO_CODE,\n            VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,):\n        if 'baseaddr' not in var_def: return False\n        return var_def['baseaddr'] in (\"PC+\",\"PC-\",)\n    return var_def['type'] in (VarType.ABSOLUTE_ADDR_TO_CODE, VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA,\n        VarType.DIRECT_LINE_OF_CODE,)\n\n\ndef value_type_is_unknown_address(var_def):\n    \"\"\" Returns whether given type represents a relative address which cannot be referenced.\n\n    Only some addresses can be converted to global addresses by this tool; an address is known\n    if it either is global to begin with, or can be converted to global.\n    If the address is unknown, property 'value' field will hold offset relative to unknown base.\n    \"\"\"\n    if var_def['type'] in (VarType.ABSOLUTE_ADDR_TO_CODE, VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA,\n            VarType.DIRECT_LINE_OF_CODE, VarType.RELATIVE_OFFSET,\n            VarType.RELATIVE_ADDR_TO_CODE, VarType.RELATIVE_ADDR_TO_PTR_TO_CODE,\n            VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,):\n        return (not value_type_is_known_address(var_def))\n    return False\n\n\ndef armfw_elf_section_search_get_value_size(asm_arch, var_info):\n    \"\"\" Get expected item size and count of the value\n    \"\"\"\n    if var_info['variety'] in (DataVariety.STRUCT,):\n        var_size = sizeof(var_info['struct'])\n    else:\n        var_size = armfw_elf_section_search_get_value_variety_size(var_info['variety'])\n\n    if 'array' in var_info:\n        if isinstance(var_info['array'], int):\n            var_count = var_info['array']\n        elif isinstance(var_info['array'], tuple):\n            var_count = var_info['array'][1]\n        else:\n            # We have variable size array; just use static limit\n            var_count = 2048\n    else:\n        var_count = 1\n    return var_size, var_count\n\n\ndef prepare_simplified_asm_lines_from_pattern_list(asm_arch, glob_params_list, patterns_addr, pattern_lines, variab_size_select):\n    \"\"\" Given a list of patterns and variables to put inside, produces assembly code.\n\n    Removes regex-specific clauses and replaces named groups with values of variables.\n    \"\"\"\n    asm_lines = []\n    asm_addr_curr = patterns_addr\n    for pat_line in pattern_lines:\n        asm_line, code_size = prepare_asm_line_from_pattern(asm_arch, glob_params_list,\n          asm_addr_curr, '', pat_line, variab_size_select=variab_size_select)\n        asm_addr_curr += code_size\n        asm_lines.append(asm_line)\n    return asm_lines, (asm_addr_curr-patterns_addr)\n\n\ndef armfw_elf_create_dummy_single_param_for_patterns_with_best_match(asm_arch, var_info_orig, dummy_patt_base):\n    var_info = var_info_orig.copy()\n\n    if value_type_is_known_address(var_info):\n        var_count = 1\n    elif value_type_is_unknown_address(var_info):\n        var_count = 1\n    else:\n        var_count = 1\n        if 'array' in var_info:\n            if isinstance(var_info['array'], int):\n                var_count = var_info['array']\n            elif isinstance(var_info['array'], tuple):\n                var_count = var_info['array'][0] + (var_info['array'][1] - var_info['array'][0]) // 4\n            else:\n                # We have variable size array; just use minimum length\n                var_count = 1\n\n    var_limit_best = 0x20\n\n    # Predict value of each variable which leads to best size match\n    if 'setValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['setValue'])\n    elif ('maxValue' in var_info) and ('minValue' in var_info) and (variety_is_float(var_info['variety']) or\n      variety_is_unsigned_int(var_info['variety']) or variety_is_signed_int(var_info['variety'])):\n        var_info['value'] = (armfw_elf_search_value_string_to_native_type(var_info, var_info['maxValue'])\n                           + armfw_elf_search_value_string_to_native_type(var_info, var_info['minValue'])) // 2\n    elif 'defaultValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['defaultValue'])\n    elif 'maxValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['maxValue'])\n    elif value_type_is_known_address(var_info):\n        if 'line' in var_info:\n            var_info['value'] = dummy_patt_base + asm_arch['boundary'] * var_info['line']\n        else:\n            var_info['value'] = dummy_patt_base + var_limit_best\n    elif value_type_is_unknown_address(var_info):\n        # Relative address must be relatively small or it might not compile\n        var_info['value'] = var_limit_best\n    elif var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n        if variety_is_string(var_info['variety']):\n            # Direct string value - always treat as array\n            prop_ofs_val = \"a\" * var_count\n        else:\n            # Direct int value - either single value or array\n            if var_count < 2:\n                prop_ofs_val = var_limit_best\n            else:\n                prop_ofs_val = [var_limit_best] * var_count\n        var_info['value'] = prop_ofs_val\n    else:\n        # Anything else - either single value or array\n        if var_count < 2:\n            prop_ofs_val = var_limit_best\n        else:\n            prop_ofs_val = [var_limit_best] * var_count\n        var_info['value'] = prop_ofs_val\n\n    return var_info\n\n\ndef armfw_elf_create_dummy_params_list_for_patterns_with_best_match(asm_arch, patterns_list, pattern_vars):\n    dummy_patt_base = 0x10000\n    dummy_params_list = {}\n    for var_name, var_info_orig in pattern_vars.items():\n        var_info = armfw_elf_create_dummy_single_param_for_patterns_with_best_match(\n          asm_arch, var_info_orig, dummy_patt_base)\n        dummy_params_list[var_name] = var_info\n\n    return dummy_params_list, dummy_patt_base\n\n\ndef armfw_elf_create_dummy_single_param_for_patterns_with_short_values(asm_arch, var_info_orig, dummy_patt_base):\n    var_info = var_info_orig.copy()\n\n    if value_type_is_known_address(var_info):\n        var_count = 1\n    elif value_type_is_unknown_address(var_info):\n        var_count = 1\n    else:\n        var_count = 1\n        if 'array' in var_info:\n            if isinstance(var_info['array'], int):\n                var_count = var_info['array']\n            elif isinstance(var_info['array'], tuple):\n                var_count = var_info['array'][0]\n            else:\n                # We have variable size array; just use minimum length\n                var_count = 1\n\n    var_limit_min = 0x10\n\n    # Predict value of each variable which leads to shortest code\n    if 'minValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['minValue'])\n    elif 'setValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['setValue'])\n    elif 'defaultValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['defaultValue'])\n    elif 'maxValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['maxValue'])\n    elif value_type_is_known_address(var_info):\n        if 'line' in var_info:\n            var_info['value'] = dummy_patt_base + asm_arch['boundary'] * var_info['line']\n        else:\n            var_info['value'] = dummy_patt_base + var_limit_min\n    elif value_type_is_unknown_address(var_info):\n        # Relative address must be relatively small ot it might not compile\n        var_info['value'] = var_limit_min\n    elif var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n        if variety_is_string(var_info['variety']):\n            # Direct string value - always treat as array\n            prop_ofs_val = \"a\" * var_count\n        else:\n            # Direct int value - either single value or array\n            if var_count < 2:\n                prop_ofs_val = var_limit_min\n            else:\n                prop_ofs_val = [var_limit_min] * var_count\n        var_info['value'] = prop_ofs_val\n    else:\n        # Anything else - either single value or array\n        if var_count < 2:\n            prop_ofs_val = var_limit_min\n        else:\n            prop_ofs_val = [var_limit_min] * var_count\n        var_info['value'] = prop_ofs_val\n\n    return var_info\n\n\ndef armfw_elf_create_dummy_params_list_for_patterns_with_short_values(asm_arch, patterns_list, pattern_vars):\n    dummy_patt_base = 0x10000\n    dummy_params_list = {}\n    for var_name, var_info_orig in pattern_vars.items():\n        var_info = armfw_elf_create_dummy_single_param_for_patterns_with_short_values(\n          asm_arch, var_info_orig, dummy_patt_base)\n        dummy_params_list[var_name] = var_info\n    return dummy_params_list, dummy_patt_base\n\n\ndef armfw_elf_create_dummy_single_param_for_patterns_with_long_values(asm_arch, var_info_orig, dummy_patt_base):\n    var_info = var_info_orig.copy()\n\n    if value_type_is_known_address(var_info):\n        var_size = 3\n        var_count = 1\n    elif value_type_is_unknown_address(var_info):\n        var_size = 1\n        var_count = 1\n    else:\n        if var_info['variety'] in (DataVariety.STRUCT,):\n            var_size = sizeof(var_info['struct'])\n        else:\n            var_size = armfw_elf_section_search_get_value_variety_size(var_info['variety'])\n        var_count = 1\n        if 'array' in var_info:\n            if isinstance(var_info['array'], int):\n                var_count = var_info['array']\n            elif isinstance(var_info['array'], tuple):\n                var_count = var_info['array'][1]\n            else:\n                # We have variable size array; just use static limit\n                var_count = 2048\n\n    if var_size > 0:\n        var_limit_max = (2 << (var_size*8-1)) - 1\n    else:\n        var_limit_max = 0x7F\n\n    # Predict value of each variable which leads to longest code\n    if 'maxValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['maxValue'])\n    elif 'setValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['setValue'])\n    elif 'defaultValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['defaultValue'])\n    elif 'minValue' in var_info:\n        var_info['value'] = armfw_elf_search_value_string_to_native_type(var_info, var_info['minValue'])\n    elif value_type_is_known_address(var_info):\n        if 'line' in var_info:\n            var_info['value'] = dummy_patt_base + asm_arch['boundary'] * var_info['line']\n        else:\n            var_info['value'] = dummy_patt_base + var_limit_max\n    elif value_type_is_unknown_address(var_info):\n        # Relative address must be relatively small ot it might not compile\n        var_info['value'] = var_limit_max\n    elif var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n        if variety_is_string(var_info['variety']):\n            # Direct string value - always treat as array\n            prop_ofs_val = \"a\" * var_count\n        else:\n            # Direct int value - either single value or array\n            if var_count < 2:\n                prop_ofs_val = var_limit_max\n            else:\n                prop_ofs_val = [var_limit_max] * var_count\n        var_info['value'] = prop_ofs_val\n    else:\n        # Anything else - either single value or array\n        if var_count < 2:\n            prop_ofs_val = var_limit_max\n        else:\n            prop_ofs_val = [var_limit_max] * var_count\n        var_info['value'] = prop_ofs_val\n\n    return var_info\n\n\ndef armfw_elf_create_dummy_params_list_for_patterns_with_long_values(asm_arch, patterns_list, pattern_vars):\n    dummy_patt_base = 0x10000\n    dummy_params_list = {}\n    for var_name, var_info_orig in pattern_vars.items():\n        var_info = armfw_elf_create_dummy_single_param_for_patterns_with_long_values(\n          asm_arch, var_info_orig, dummy_patt_base)\n        dummy_params_list[var_name] = var_info\n    return dummy_params_list, dummy_patt_base\n\n\ndef armfw_elf_compute_pattern_code_length(asm_arch, patterns_list, pattern_vars, variab_size_select):\n    \"\"\" Returns estimated length in bytes of given asm patterns list.\n\n    Using this function should be avoided whenever possible. It tries hard to provide correct length,\n    but it is simply impossible - not only because of parameter values influencing the length, but also\n    because there are many binary equivalents to an instruction, and they have different lengths. Every\n    compiler prepares different code for some instructions.\n    \"\"\"\n    if variab_size_select == 'best':\n        dummy_params_list, dummy_patt_base = \\\n          armfw_elf_create_dummy_params_list_for_patterns_with_best_match(asm_arch, patterns_list, pattern_vars)\n    elif variab_size_select == 'long':\n        dummy_params_list, dummy_patt_base = \\\n          armfw_elf_create_dummy_params_list_for_patterns_with_long_values(asm_arch, patterns_list, pattern_vars)\n    elif variab_size_select == 'short':\n        dummy_params_list, dummy_patt_base = \\\n          armfw_elf_create_dummy_params_list_for_patterns_with_short_values(asm_arch, patterns_list, pattern_vars)\n    else:\n        raise ValueError(\"Unknown variable size param '{:s}' - internal error\".format(variab_size_select))\n\n    #print(\"Making code from re for len:\",\"; \".join(patterns_list))\n    asm_lines, _ = prepare_simplified_asm_lines_from_pattern_list(asm_arch, dummy_params_list, dummy_patt_base,\n      patterns_list, variab_size_select)\n    # Now compile our new code line to get proper length\n    #print(\"Compiling code for\",variab_size_select,\"len:\",\"; \".join(asm_lines))\n    bt_enc_data = armfw_asm_compile_lines(asm_arch, dummy_patt_base, asm_lines)\n    return len(bt_enc_data)\n\n\ndef armfw_elf_search_value_bytes_to_native_type(asm_arch, var_info, var_bytes):\n    \"\"\" Converts bytes to a variable described in info struct and architecture.\n    \"\"\"\n    # Get expected length of the value\n    var_size, var_count = armfw_elf_section_search_get_value_size(asm_arch, var_info)\n    if var_info['variety'] in (DataVariety.CHAR,):\n        # Native type is str\n        if 'array' in var_info:\n            var_nativ = [ var_bytes.rstrip(b\"\\0\").decode(\"ISO-8859-1\") ]\n        else:\n            var_nativ = [ var_bytes.decode(\"ISO-8859-1\") ]\n    elif variety_is_unsigned_int(var_info['variety']):\n        var_nativ = []\n        for i in range(len(var_bytes) // var_size):\n            var_nativ.append(int.from_bytes(var_bytes[i*var_size:(i+1)*var_size], byteorder=asm_arch['byteorder'], signed=False))\n    elif variety_is_signed_int(var_info['variety']):\n        var_nativ = []\n        for i in range(len(var_bytes) // var_size):\n            var_nativ.append(int.from_bytes(var_bytes[i*var_size:(i+1)*var_size], byteorder=asm_arch['byteorder'], signed=True))\n    elif variety_is_float(var_info['variety']):\n        var_nativ = []\n        for i in range(len(var_bytes) // var_size):\n            # struct.unpack() returns a typle, even if with only one item; so we add it to list via extend().\n            if var_size >= 8:\n                var_nativ.extend(struct.unpack(\"<d\", var_bytes[i*var_size:(i+1)*var_size]))\n            else:\n                var_nativ.extend(struct.unpack(\"<f\", var_bytes[i*var_size:(i+1)*var_size]))\n    elif var_info['variety'] in (DataVariety.STRUCT,):\n        var_nativ = []\n        prop_array_len = len(var_bytes) // var_size\n        for i in range(prop_array_len):\n            var_struct = var_info['struct'].from_buffer_copy(var_bytes[i*var_size:(i+1)*var_size])\n            var_nativ.append(var_struct)\n    else:\n        var_nativ = []\n\n    if len(var_nativ) == 1:\n        var_nativ = var_nativ[0]\n    elif len(var_nativ) < 1:\n        var_nativ = None\n\n    return var_nativ\n\ndef armfw_elf_search_value_native_type_to_bytes(asm_arch, var_info, var_nativ):\n    \"\"\" Converts native variable to bytes as described in info struct and architecture.\n    \"\"\"\n    # Get expected length of the value\n    var_size, var_count = armfw_elf_section_search_get_value_size(asm_arch, var_info)\n    if isinstance(var_nativ, str):\n        var_bytes = var_nativ.encode(\"ISO-8859-1\")\n    elif isinstance(var_nativ, int):\n        var_bytes = var_nativ.to_bytes(var_size, asm_arch['byteorder'])\n    elif isinstance(var_nativ, float):\n        if var_size >= 8:\n            var_bytes = struct.pack(\"<d\", var_nativ)\n        else:\n            var_bytes = struct.pack(\"<f\", var_nativ)\n    elif hasattr(var_nativ, \"_fields_\"): # check if we have a ctypes struct\n        var_bytes = (c_ubyte * sizeof(var_nativ)).from_buffer_copy(var_nativ)\n    elif hasattr(var_nativ, \"__len__\"): # check if we have an array\n        var_bytes = b''\n        for itm in var_nativ:\n            var_bytes.append(armfw_elf_search_value_native_type_to_bytes(asm_arch, var_info, itm))\n    else:\n        var_bytes = b''\n    return var_bytes\n\n\ndef armfw_elf_search_value_native_type_to_string(var_nativ):\n    \"\"\" Converts given native type to string or array of strings.\n    \"\"\"\n    if isinstance(var_nativ, str):\n        val_str = var_nativ\n    elif isinstance(var_nativ, int):\n        val_str = \"{:d}\".format(var_nativ)\n    elif isinstance(var_nativ, float):\n        val_str = \"{:f}\".format(var_nativ)\n    elif hasattr(var_nativ, \"_fields_\"): # check if we have a ctypes struct\n        val_str = \"\"\n        for field in var_nativ._fields_:\n            val_str += \"{:d} \".format(getattr(var_nativ, field[0]))\n        val_str = val_str.rstrip()\n    elif hasattr(var_nativ, \"__len__\"): # check if we have an array\n        val_str = []\n        for itm in var_nativ:\n            val_str.append(armfw_elf_search_value_native_type_to_string(itm))\n    else:\n        val_str = \"\"\n    return val_str\n\n\ndef armfw_elf_search_value_string_to_native_type(var_info, var_str):\n    \"\"\" Converts string value to native type.\n\n    Native type can be str, int, float, struct or array of int or float.\n    \"\"\"\n    if var_info['variety'] in (DataVariety.CHAR,):\n        var_nativ = str(var_str)\n    elif var_info['variety'] in (DataVariety.UINT8_T, DataVariety.UINT16_T,\n            DataVariety.UINT32_T, DataVariety.UINT64_T, DataVariety.INT8_T,\n            DataVariety.INT16_T, DataVariety.INT32_T, DataVariety.INT64_T,):\n        if isinstance(var_str, int):\n            # If we already got an int - no processing required (this happens if JSON value is not in quotes)\n            var_nativ = var_str\n        else:\n            var_nativ = []\n            for val_itm in var_str.split():\n                var_nativ.append(int(val_itm, 0))\n            if len(var_nativ) == 1:\n                var_nativ = var_nativ[0]\n    elif var_info['variety'] in (DataVariety.FLOAT, DataVariety.DOUBLE,):\n        if isinstance(var_str, float):\n            # If we already got a float - no processing required\n            var_nativ = var_str\n        else:\n            var_nativ = []\n            for val_itm in var_str.split():\n                var_nativ.append(float(val_itm))\n            if len(var_nativ) == 1:\n                var_nativ = var_nativ[0]\n    elif var_info['variety'] in (DataVariety.STRUCT,):\n        var_nativ = var_info['struct']()\n        for field, valstr in zip(var_nativ._fields_, var_str.split()):\n            # currently we only accept int values within struct\n            setattr(var_nativ, field[0], int(valstr, 0))\n    else:\n        var_nativ = None\n    return var_nativ\n\n\ndef get_matching_variable_from_patterns(patterns, var_type=None, var_variety=None, var_name=None, var_size=None, var_setValue=None, var_depend=None):\n    for v_name, var_info in patterns['vars'].items():\n        if var_type is not None and var_info['type'] != var_type:\n            continue\n        if var_variety is not None and var_info['variety'] != var_variety:\n            continue\n        if var_name is not None and v_name != var_name:\n            continue\n        if var_size is not None and var_info['size'] != var_size:\n            continue\n        if var_depend is not None:\n            if 'depend' in var_info:\n                # True means - any value, but must be set\n                if var_depend is True:\n                    pass\n                elif var_info['depend'] != var_depend:\n                    continue\n            else:\n                # False means - must not be set\n                if var_depend is False:\n                    pass\n                else:\n                    continue\n        if var_setValue is not None:\n            if 'setValue' not in var_info:\n                # if we cannot check setValue, consider this loose match\n                # That allows values merged together from definitions with\n                # different types, as long as only one has no setValue.\n                if var_setValue >= var_info['minValue']:\n                    if var_setValue <= var_info['maxValue']:\n                        loose_matched_patts = patterns\n                continue\n            if var_setValue != var_info['setValue']:\n                continue\n        return v_name\n    return None\n\n\ndef find_patterns_containing_variable(re_list, cfunc_ver=None, var_type=None, var_variety=None, var_sect=None, var_name=None, var_size=None, var_setValue=None, var_depend=None):\n    loose_matched_patts = None\n    for re_item in re_list:\n        if var_sect is not None and re_item['sect'] != var_sect:\n            continue\n        patterns = re_item['func']\n        if cfunc_ver is not None and patterns['version'] != cfunc_ver:\n            continue\n        v_name = get_matching_variable_from_patterns(patterns, var_type, var_variety, var_name, var_size, var_setValue, var_depend)\n        if v_name is not None:\n            return patterns\n    return loose_matched_patts\n\n\ndef find_patterns_diff(patterns_prev, patterns_next):\n    \"\"\" Given two patterns, returns a part which is different between them.\n\n    Assumes that patterns correspond to code of the same langth.\n    \"\"\"\n    #TODO we should get and compare labels as well\n    re_lines_prev, _ = armfw_asm_search_strings_to_re_list(patterns_prev['re'])\n    re_lines_next, _ = armfw_asm_search_strings_to_re_list(patterns_next['re'])\n    sp = 0\n    sn = 0\n    while sp < len(re_lines_prev) and sn < len(re_lines_next):\n        line_p = re_lines_prev[sp]\n        line_n = re_lines_next[sn]\n        if line_p != line_n:\n            break\n        sp += 1\n        sn += 1\n    ep = len(re_lines_prev) - 1\n    en = len(re_lines_next) - 1\n    while ep > sp and en > sn:\n        line_p = re_lines_prev[ep]\n        line_n = re_lines_next[en]\n        if line_p != line_n:\n            break\n        ep -= 1\n        en -= 1\n    patterns_diff = []\n    patterns_diff_prev = []\n    for i in range(sn, en+1):\n        line_n = re_lines_next[i]\n        patterns_diff.append(line_n)\n        line_p = re_lines_prev[i]\n        patterns_diff_prev.append(line_p)\n    return patterns_diff, re_lines_prev[0:sp], patterns_diff_prev\n\n\ndef armfw_asm_is_data_definition(asm_arch, asm_line):\n    \"\"\" Recognizes data definition assembly line, without fully interpreting data.\n\n    The fact that it doesn't interpret data means it will work for regex too\n    (though it might get signedness incorrectly).\n    \"\"\"\n    re_isdata = re.search(r'^(dc[bwdq])\\t(.*)$', asm_line)\n    if re_isdata is None:\n        return None, None, None\n    elif re_isdata.group(1) == 'dcb':\n        if re.match(r'\".+\"', re_isdata.group(2)):\n            dt_variety = DataVariety.CHAR\n        else:\n            dt_variety = DataVariety.UINT8_T\n        single_len = 1\n    elif re_isdata.group(1) == 'dcw':\n        if re.match(r'-[0-9]+\"', re_isdata.group(2)):\n            dt_variety = DataVariety.INT16_T\n        else:\n            dt_variety = DataVariety.UINT16_T\n        single_len = 2\n    elif re_isdata.group(1) == 'dcd':\n        if re.match(r'[0-9]+[.][0-9]+\"', re_isdata.group(2)):\n            dt_variety = DataVariety.FLOAT\n        if re.match(r'-[0-9]+\"', re_isdata.group(2)):\n            dt_variety = DataVariety.INT32_T\n        else:\n            dt_variety = DataVariety.UINT32_T\n        single_len = 4\n    elif re_isdata.group(1) == 'dcq':\n        if re.match(r'[0-9]+[.][0-9]+\"', re_isdata.group(2)):\n            dt_variety = DataVariety.DOUBLE\n        if re.match(r'-[0-9]+\"', re_isdata.group(2)):\n            dt_variety = DataVariety.INT64_T\n        else:\n            dt_variety = DataVariety.UINT64_T\n        single_len = 8\n\n    return single_len, dt_variety, re_isdata.group(2)\n\ndef armfw_asm_parse_data_definition(asm_arch, asm_line):\n    \"\"\" Recognizes data definition assembly line, returns data as bytes.\n    \"\"\"\n    single_len, dt_variety, data_part = armfw_asm_is_data_definition(asm_arch, asm_line)\n    if single_len is None:\n        return None\n    dt_bytes = b''\n    for dt_item in data_part.split(\",\"):\n        dt_sitem = dt_item.strip()\n        dt_btitem = None\n        try:\n            dt_btitem = int(dt_sitem, 0).to_bytes(single_len, byteorder=asm_arch['byteorder'])\n        except ValueError:\n            pass\n        if dt_btitem is None:\n            if dt_sitem.startswith('\"') and dt_sitem.endswith('\"'):\n                dt_btitem = dt_sitem[1:-1].encode()\n        if dt_btitem is None:\n            raise ValueError(\"Cannot convert data def part to bytes: \\\"{:s}\\\".\".format(dt_item))\n        dt_bytes += dt_btitem\n    return {'variety': dt_variety, 'item_size': single_len, 'value': dt_bytes}\n\n\ndef armfw_elf_data_definition_from_bytes(po, asm_arch, bt_data, bt_addr, pat_line, var_defs, var_size_inc=0):\n    \"\"\" Converts bytes into data definition, keeping format given in pattern line.\n\n    @asm_arch - Assembly architecture definition list.\n    @bt_data - bytes storing data for the definition; its length may exceed the definiton\n    @bt_addr - address of the definition in memory\n    @pat_line - regex pattern line containing the definition\n    @var_defs - definitions of variables which may be used in the pattern\n    @var_size_inc - variable length increase when the variable is an array of varying size\n    \"\"\"\n    if (po.verbose > 3):\n        print(\"Using Keystone arch=0x{:x} mode=0x{:x} for data def conv\".format(asm_arch['ks_const'], asm_arch['ks_mode']))\n    whole_size_min = armfw_elf_compute_pattern_code_length(asm_arch, [pat_line,], var_defs, 'short')\n    whole_size_max = armfw_elf_compute_pattern_code_length(asm_arch, [pat_line,], var_defs, 'long')\n    itm_size, itm_variety, _ = armfw_asm_is_data_definition(asm_arch, pat_line)\n\n    if whole_size_max > whole_size_min:\n        whole_size = whole_size_min + itm_size * var_size_inc\n    else:\n        whole_size = whole_size_min\n    if whole_size > whole_size_max:\n        whole_size = whole_size_max\n\n    if itm_size == 1:\n        mnemonic = 'dcb'\n    elif itm_size == 2:\n        mnemonic = 'dcw'\n    elif itm_size == 4:\n        mnemonic = 'dcd'\n    elif itm_size == 8:\n        mnemonic = 'dcq'\n    itm_count = whole_size // itm_size\n    op_list = []\n    if itm_variety == DataVariety.CHAR:\n        itm_merge = b\"\"\n        for i in range(itm_count):\n            curr_bt = bt_data[i*itm_size:(i+1)*itm_size]\n            curr_int = int.from_bytes(curr_bt, byteorder=asm_arch['byteorder'], signed=False)\n            if curr_int >= 32 and curr_int <= 127:\n                itm_merge += curr_bt\n            else:\n                if len(itm_merge) > 0:\n                    op_list.append(itm_merge)\n                    itm_merge = b\"\"\n                op_list.append(curr_int)\n        if len(itm_merge) > 0:\n            op_list.append(itm_merge)\n    else:\n        for i in range(itm_count):\n            op_list.append(int.from_bytes(bt_data[i*itm_size:(i+1)*itm_size], byteorder=asm_arch['byteorder'], signed=False))\n    op_list_str = []\n    for itm in op_list:\n        if isinstance(itm, int):\n            op_list_str.append(\"0x{:x}\".format(itm))\n        elif isinstance(itm, (bytes, bytearray)):\n            op_list_str.append(\"\\\"{:s}\\\"\".format(itm.decode()))\n        else:\n            raise ValueError(\"Unexpected type - internal error.\")\n    return bt_addr, whole_size, whole_size_max, mnemonic, \", \".join(op_list_str)\n\n\ndef armfw_elf_section_search_add_var(po, search, var_name, var_suffix, var_info, prop_ofs_val, prop_str, address, size):\n    \"\"\" Adds variable to current search results.\n\n       @search - the target search results\n       @var_name, @var_suffix - variable name and its suffix\n       @var_info - static info about the variable\n       @prop_ofs_val - offset or value to compare while validating the variable\n       @prop_str - real value of the variable, converted to string\n       @address - address to the initial finding place (not dereferenced if the place contained pointer to pointer)\n       @size - instruction size, if the variable is a value within code\n    \"\"\"\n    if var_name in search['var_vals']:\n        var_val = search['var_vals'][var_name+var_suffix]\n        if var_val['value'] != prop_ofs_val:\n            if (po.verbose > 3):\n                if isinstance(var_val['value'], int):\n                    old_val = \"0x{:0x}\".format(var_val['value'])\n                else:\n                    old_val = str(var_val['value'])\n                if isinstance(prop_ofs_val, int):\n                    new_val = \"0x{:0x}\".format(prop_ofs_val)\n                else:\n                    new_val = str(prop_ofs_val)\n                print(\"Mismatch on var '{:s}' value - is {:s}, now got {:s}\".format(var_name+var_suffix, old_val, new_val))\n            return False\n        if var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n            raise ValueError(\"Mismatch on var '{:s}' occurences - direct int value can only occur once\".format(var_name+var_suffix))\n    else:\n        var_def = search['var_defs'][var_name]\n        var_val = {\n          'str_value': prop_str,\n          'value': prop_ofs_val,\n          'address': address,\n          'line': search['match_lines'],\n          'cfunc_name': search['name'],\n          'cfunc_ver': search['version'],\n        }\n        var_val.update(var_def)\n        # For direct values, also store the regex matched to the line\n        if (var_info['type'] == VarType.DIRECT_INT_VALUE):\n            var_val['line'] = search['match_lines']\n        search['var_vals'][var_name+var_suffix] = var_val\n    return True\n\n\ndef armfw_elf_offset_or_value_to_value_bytes(asm_arch, elf_sections, var_info, prop_ofs_val):\n    \"\"\" Either convert the direct value to bytes, or get bytes from offset.\n    \"\"\"\n    # Get expected length of the value\n    prop_size, prop_count = armfw_elf_section_search_get_value_size(asm_arch, var_info)\n    if (var_info['type'] == VarType.DIRECT_INT_VALUE):\n        # Convert the direct value to bytes\n        if not isinstance(prop_ofs_val, list):\n            prop_ofs_val = [prop_ofs_val]\n        prop_bytes = b\"\"\n        for prop_var in prop_ofs_val:\n            prop_bytes += (prop_var).to_bytes(prop_size, byteorder=asm_arch['byteorder'])\n    elif (var_info['type'] in (VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_GLOBAL_DATA,\n      VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,)):\n        # Get bytes from offset\n        var_sect, var_offs = get_section_and_offset_from_address(asm_arch, elf_sections, prop_ofs_val)\n        if var_sect is not None:\n            var_data = elf_sections[var_sect]['data']\n            prop_bytes = var_data[var_offs:var_offs+prop_size*prop_count]\n        else:\n            prop_bytes = b\"\"\n    else:\n        prop_bytes = b\"\"\n    return prop_bytes\n\n\ndef armfw_elf_section_search_get_direct_int_or_offs(po, search, elf_sections, address, size, var_name, var_info, var_val, prop_size, prop_count):\n    \"\"\" For given variable, get direct int value or offset to value.\n    \"\"\"\n    if var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n        # for direct values, count is used\n        # we may alco encounter a string\n        if var_info['variety'] in (DataVariety.CHAR,):\n            prop_ofs_val = [ord(sing_var) for sing_var in var_val]\n            #prop_ofs_val = var_val\n        else:\n            if prop_count <= 1:\n                prop_ofs_val = int(var_val, 0)\n            else:\n                prop_ofs_val = [int(sing_var.strip(), 0) for sing_var in var_val.split(',')]\n    elif var_info['type'] in (VarType.ABSOLUTE_ADDR_TO_CODE, VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_OFFSET,):\n        prop_ofs_val = int(var_val, 0)\n    elif var_info['type'] in (VarType.RELATIVE_ADDR_TO_CODE, VarType.RELATIVE_ADDR_TO_GLOBAL_DATA,) and var_info['baseaddr'] in (\"PC+\",\"PC-\",):\n        if var_info['baseaddr'].endswith('-'):\n            prop_ofs_val = get_arm_vma_subtracted_from_pc_register(search['asm_arch'], search['section'], address, size, var_val)\n        else:\n            prop_ofs_val = get_arm_vma_relative_to_pc_register(search['asm_arch'], search['section'], address, size, var_val)\n    elif var_info['type'] in (VarType.RELATIVE_ADDR_TO_PTR_TO_CODE,VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,) and var_info['baseaddr'] in (\"PC+\",\"PC-\",):\n        if var_info['baseaddr'].endswith('-'):\n            prop_ofs_val = get_arm_vma_subtracted_from_pc_register(search['asm_arch'], search['section'], address, size, var_val)\n        else:\n            prop_ofs_val = get_arm_vma_relative_to_pc_register(search['asm_arch'], search['section'], address, size, var_val)\n        var_sect, var_offs = get_section_and_offset_from_address(search['asm_arch'], elf_sections, prop_ofs_val)\n        if var_sect is not None:\n            var_data = elf_sections[var_sect]['data']\n            prop_ofs_val = int.from_bytes(var_data[var_offs:var_offs+4], byteorder=search['asm_arch']['byteorder'], signed=False)\n        else:\n            raise ValueError(\"Address to uninitialized data found (0x{:06x}) in var '{:s}'.\".format(prop_ofs_val, var_name))\n    elif var_info['type'] in (VarType.DIRECT_OPERAND,):\n        prop_ofs_val = var_val\n    else:\n        raise NotImplementedError(\"Unexpected var '{:s}' type found while processing vars, '{:s}'.\"\n          .format(var_name, var_info['type'].name))\n    return prop_ofs_val\n\n\ndef armfw_elf_section_search_process_vars_from_code(po, search, elf_sections, address, size, re_code):\n    \"\"\" Process variable values from a code line and add them to search results.\n    \"\"\"\n    for var_name, var_val in re_code.groupdict().items():\n        var_info = search['var_defs'][var_name]\n        # Get expected length of the value\n        prop_size, prop_count = armfw_elf_section_search_get_value_size(search['asm_arch'], var_info)\n\n        # Get direct int value or offset to value\n        prop_ofs_val = armfw_elf_section_search_get_direct_int_or_offs(po, search,\n              elf_sections, address, size, var_name, var_info, var_val, prop_size, prop_count)\n\n        # Either convert the direct value to bytes, or get bytes from offset\n        prop_bytes = armfw_elf_offset_or_value_to_value_bytes(search['asm_arch'], elf_sections, var_info, prop_ofs_val)\n        # And convert further, to native type value\n        var_nativ = armfw_elf_search_value_bytes_to_native_type(search['asm_arch'], var_info, prop_bytes)\n        prop_str = armfw_elf_search_value_native_type_to_string(var_nativ)\n        if isinstance(prop_str, str):\n            if not armfw_elf_section_search_add_var(po, search, var_name, \"\", var_info, prop_ofs_val, prop_str, address, size):\n                return False\n        else: # array of strings\n            if var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n                for i in range(len(prop_str)):\n                    prop_sstr = prop_str[i]\n                    if not armfw_elf_section_search_add_var(po, search, var_name, \"_{:02d}\".format(i),\n                      var_info, prop_ofs_val[i], prop_sstr, address, size):\n                        return False\n            else:\n                for i in range(len(prop_str)):\n                    prop_sstr = prop_str[i]\n                    if not armfw_elf_section_search_add_var(po, search, var_name, \"_{:02d}\".format(i),\n                      var_info, prop_ofs_val + i*prop_size, prop_sstr, address, size):\n                        return False\n\n    # Now get variables associated to line of code, not anything within the code\n    for var_name, var_info in search['var_defs'].items():\n        # Add variables attached to code line (usually function name)\n        if var_info['type'] in (VarType.DIRECT_LINE_OF_CODE,) and 'line' in var_info and search['match_lines'] == var_info['line']:\n            # Get expected length of the value\n            prop_size, prop_count = armfw_elf_section_search_get_value_size(search['asm_arch'], var_info)\n            prop_ofs_val = address\n            prop_str = \"\"\n            if not armfw_elf_section_search_add_var(po, search, var_name, \"\", var_info, prop_ofs_val, prop_str, address, size):\n                return False\n        # Add variables detached from data (per-regex constants) or unused (used in different variant of the regex code)\n        if var_info['type'] in (VarType.DETACHED_DATA, VarType.UNUSED_DATA,):\n            # DETACHED_DATA with 'setValue' can be added on first line\n            if 'depend' not in var_info and search['match_lines'] == 0:\n                # Get expected length of the value\n                prop_size, prop_count = armfw_elf_section_search_get_value_size(search['asm_arch'], var_info)\n                prop_ofs_val = 0\n                prop_str = var_info['setValue']\n                if not armfw_elf_section_search_add_var(po, search, var_name, \"\", var_info, prop_ofs_val, prop_str, address, size):\n                    return False\n            # DETACHED_DATA which 'depend' on others must wait until all others are known - to last line\n            if 'depend' in var_info and search['match_lines']+1 == len(search['re']):\n                # Get expected length of the value\n                prop_size, prop_count = armfw_elf_section_search_get_value_size(search['asm_arch'], var_info)\n                prop_ofs_val = 0\n                prop_str = armfw_elf_paramvals_get_depend_value(search['var_vals'], var_info)\n                if not armfw_elf_section_search_add_var(po, search, var_name, \"\", var_info, prop_ofs_val, prop_str, address, size):\n                    return False\n\n    return True\n\n\ndef armfw_elf_section_search_block(po, search, sect_offs, elf_sections, cs, block_len):\n    \"\"\" Search for pattern in a block of ELF file section.\n        The function will try to save state and stop somewhere around given block_len.\n    \"\"\"\n    sect_limit = len(search['section']['data'])\n    if (sect_limit > sect_offs + block_len):\n        sect_limit = sect_offs + block_len\n    while sect_offs < sect_limit:\n        curr_pattern = armfw_elf_section_search_get_pattern(search)\n        curr_is_data, _, _ = armfw_asm_is_data_definition(search['asm_arch'], curr_pattern)\n        if curr_is_data is not None:\n            # now matching a data line; get its length\n            line_iter = [armfw_elf_data_definition_from_bytes(po,\n              search['asm_arch'],\n              search['section']['data'][sect_offs:],\n              search['section']['addr'] + sect_offs,\n              curr_pattern,\n              search['var_defs'],\n              search['varlen_inc']\n            ),]\n            for (address, size, max_size, mnemonic, op_str) in line_iter:\n                if size < max_size or search['varlen_inc'] > 0:\n                    search = armfw_elf_section_search_varlen_point_mark(search, address, max_size - size)\n                instruction_str = \"{:s}\\t{:s}\".format(mnemonic, op_str).strip()\n                if (po.verbose > 3) and (search['match_lines'] > 1):\n                    print(\"Current vs pattern {:3d} `{:s}` `{:s}`\"\n                      .format(search['match_lines'], instruction_str, curr_pattern))\n                re_code = re.search(curr_pattern, instruction_str)\n                # The block below is exactly the same as for normal instruction\n                match_ok = (re_code is not None)\n                if match_ok:\n                    match_ok = armfw_elf_section_search_process_vars_from_code(po, search, elf_sections, address, size, re_code)\n\n                if match_ok:\n                    if (po.verbose > 4):\n                        print(\"Match lines: {:d} @ {:x}\".format(search['match_lines'], address))\n                    search = armfw_elf_section_search_progress(search, address, size)\n                    if search['match_lines'] == 0: # This means we had a full match; we need to go back with offset to search for overlapping areas\n                        if (po.verbose > 2):\n                            armfw_elf_section_search_print_unused_vars(search)\n                        sect_offs = armfw_elf_section_search_get_next_search_pos(search, sect_offs)\n                        search = armfw_elf_section_search_reset(search)\n                        break\n                    curr_pattern = armfw_elf_section_search_get_pattern(search)\n                    sect_offs += size\n                    curr_is_data, _, _ = armfw_asm_is_data_definition(search['asm_arch'], curr_pattern)\n                    if curr_is_data is not None: break\n                else:\n                    # Breaking the loop is only expensive for ASM code; for data, we don't really care that much\n                    if armfw_elf_section_search_varlen_point_rewind(search):\n                        sect_offs = search['match_address'] - search['section']['addr'] + sum(search['re_size'])\n                    else:\n                        sect_offs = armfw_elf_section_search_get_next_search_pos(search, sect_offs)\n                        search = armfw_elf_section_search_reset(search)\n                    break\n        else:\n            # now matching an assembly code line\n            for (address, size, mnemonic, op_str) in cs.disasm_lite(search['section']['data'][sect_offs:], search['section']['addr'] + sect_offs):\n                instruction_str = \"{:s}\\t{:s}\".format(mnemonic, op_str).strip()\n                if (po.verbose > 3) and (search['match_lines'] > 1):\n                    print(\"Current vs pattern {:3d} `{:s}` `{:s}`\".format(search['match_lines'], instruction_str, curr_pattern))\n                re_code = re.search(curr_pattern, instruction_str)\n\n                match_ok = (re_code is not None)\n                if match_ok:\n                    match_ok = armfw_elf_section_search_process_vars_from_code(po, search, elf_sections, address, size, re_code)\n\n                if match_ok:\n                    #print(\"Match lines: {:d} @ {:x}\".format(search['match_lines'], address))\n                    search = armfw_elf_section_search_progress(search, address, size)\n                    if search['match_lines'] == 0: # This means we had a full match; we need to go back with offset to search for overlapping areas\n                        if (po.verbose > 2):\n                            armfw_elf_section_search_print_unused_vars(search)\n                        sect_offs = armfw_elf_section_search_get_next_search_pos(search, sect_offs)\n                        search = armfw_elf_section_search_reset(search)\n                        break\n                    curr_pattern = armfw_elf_section_search_get_pattern(search)\n                    sect_offs += size\n                    curr_is_data, _, _ = armfw_asm_is_data_definition(search['asm_arch'], curr_pattern)\n                    if curr_is_data is not None: break\n                else:\n                    # Breaking the loop is expensive; do it only if we had more than one line matched, to search for overlapping areas\n                    if search['match_lines'] > 0:\n                        if armfw_elf_section_search_varlen_point_rewind(search):\n                            sect_offs = search['match_address'] - search['section']['addr'] + sum(search['re_size'])\n                            break\n                        else:\n                            pev_sect_offs = sect_offs\n                            sect_offs = armfw_elf_section_search_get_next_search_pos(search, sect_offs)\n                            search = armfw_elf_section_search_reset(search)\n                            # Now try optimization - maybe we do not need to break the for() loop\n                            # but this is only possible if the next offset to search matches the offset of next instruction in for()\n                            if sect_offs != pev_sect_offs + size: break\n                            # And if the first line pattern happens to be code, not data\n                            curr_pattern = armfw_elf_section_search_get_pattern(search)\n                            curr_is_data, _, _ = armfw_asm_is_data_definition(search['asm_arch'], curr_pattern)\n                            if curr_is_data is not None: break\n                            # ok, it should be safe not to break here and start matching next assembly line\n                    else: # search['match_lines'] == 0\n                        sect_offs += size\n            else: # for loop finished by inability to decode next instruction\n                # We know that curr_is_data is None - otherwise we'd break the loop; so since we encoured\n                # invalid instruction, we are sure that the current matching failed and we should reset.\n                if armfw_elf_section_search_varlen_point_rewind(search):\n                    sect_offs = search['match_address'] - search['section']['addr'] + sum(search['re_size'])\n                else:\n                    sect_offs = armfw_elf_section_search_get_next_search_pos(search, sect_offs)\n                    search = armfw_elf_section_search_reset(search)\n    return (search, sect_offs)\n\n\ndef armfw_elf_whole_section_search(po, asm_arch, elf_sections, cs, sect_name, patterns, glob_params_list):\n    \"\"\" Search for pattern in ELF file section.\n        Return list of matching data.\n    \"\"\"\n    search = armfw_elf_section_search_init(asm_arch, elf_sections[sect_name], patterns)\n    # Prepare start offset\n    start_sect_offs = 0\n    for var_name, var_def in search['var_defs'].items():\n        # Find variable representing offset of first line in the pattern\n        if var_def['type'] not in (VarType.DIRECT_LINE_OF_CODE,):\n            continue\n        if 'line' not in var_def:\n            continue\n        if var_def['line'] != 0:\n            continue\n        # Check if that variable is in global vars\n        var_info = variable_info_from_value_name(glob_params_list, search['name'], var_name)\n        if var_info is None:\n            continue\n        if not value_type_is_known_address(var_info):\n            continue\n        # Use offset of the found variable\n        next_sect_addr = get_final_address_from_var_info(asm_arch, elf_sections, var_info)\n        if next_sect_addr is None:\n            continue\n        next_sect_name, next_sect_offs = get_section_and_offset_from_address(asm_arch, elf_sections, next_sect_addr)\n        if next_sect_name is None:\n            eprint(\"Pre-determined address of {:s} is outside of initialized sections (0x{:06x}); ignoring\"\n              .format(var_name, next_sect_addr))\n            continue\n        if next_sect_name != sect_name:\n            eprint(\"Pre-determined address of {:s} is in section '{:s}' instead of '{:s}'; ignoring\"\n              .format(var_name, next_sect_name, sect_name))\n            continue\n        if (po.verbose > 1):\n            print(\"Found pre-determined address of {:s} at 0x{:06x}\".format(var_name, var_info['value']))\n        start_sect_offs = next_sect_offs\n\n    if 'no_search' in patterns:\n        if patterns['no_search'] and start_sect_offs == 0:\n            eprint(\"The {:s} requires pre-determined address from previously found functions; no such address exists\"\n              .format(search['name']))\n            return []\n\n    sect_offs = start_sect_offs\n    sect_progress_treshold = 0\n    while sect_offs < len(search['section']['data']):\n        search, sect_offs = armfw_elf_section_search_block(po, search, sect_offs, elf_sections, cs, 65536)\n        # Print progress info\n        if (po.verbose > 1) and (sect_offs > sect_progress_treshold):\n            print(\"{:s}: Search for {:s} ver {:s}, progress {:3d}%\"\n              .format(po.elffile, search['name'], search['version'], sect_offs * 100 // len(search['section']['data'])))\n            sect_progress_treshold += len(search['section']['data']) / 10\n\n    # If had offset before search, and found at that exact offset - ignore further matches\n    if len(search['full_matches']) > 1 and start_sect_offs > 0:\n        first_match = search['full_matches'][0]\n        if first_match['address'] == search['section']['addr'] + start_sect_offs:\n            search['full_matches'] = [ first_match ]\n\n    if (po.verbose > 0):\n        if len(search['full_matches']) == 1:\n            print(\"{:s}: Pattern of {:s} ver {:s} located at 0x{:x}\"\n              .format(po.elffile, search['name'], search['version'], search['full_matches'][0]['address']))\n        elif len(search['full_matches']) > 1:\n            print(\"{:s}: Pattern of {:s} ver {:s} found {:d} times\"\n              .format(po.elffile, search['name'], search['version'], len(search['full_matches'])))\n        else:\n            print(\"{:s}: Pattern of {:s} ver {:s} was not found; closest was {:d} lines at 0x{:x}\"\n              .format(po.elffile, search['name'], search['version'], search['best_match_lines'], search['best_match_address']))\n\n    # If we have multiple matches, treat them based on a value set within the patterns definition; default is \"reject\"\n    if len(search['full_matches']) > 1:\n        if 'multiple' not in patterns or patterns['multiple'] == \"reject\":\n            # do not accept multiple matches\n            return []\n        elif patterns['multiple'] == \"depend\":\n            # convert public vars from subsequent matches to depend\n            for i, match in enumerate(search['full_matches'][1:]):\n                for var_name, var_info in match['vars'].items():\n                    if value_needs_global_name(var_name, var_info):\n                        del match['vars'][var_name]\n                        if 'public' in var_info and 'depend' not in var_info:\n                            var_info['depend'] = var_name\n                        var_name = \"{:s}_match{:02d}\".format(var_name, i+1)\n                        match['vars'][var_name] = var_info\n\n    return search['full_matches']\n\n\ndef armfw_elf_match_to_public_values(po, match):\n    params_list = {}\n    for var_name, var_info in match['vars'].items():\n        if 'public' in var_info:\n            if 'depend' in var_info:\n                if 'forceVisible' not in var_info or not var_info['forceVisible']:\n                    continue\n            par_name = var_info['public'] + '.' + var_name\n            par_info = var_info.copy()\n            par_info['name'] = var_name\n            params_list[par_name] = par_info\n    return params_list\n\n\ndef value_needs_global_name(var_name, var_info):\n    if var_info['variety'] in (DataVariety.UNKNOWN,):\n        return False\n    if var_info['type'] in (VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_GLOBAL_DATA,):\n        return True\n    if var_info['type'] in (VarType.DETACHED_DATA,):\n        return True\n    if var_info['variety'] in (CodeVariety.FUNCTION,):\n        return True\n    return False\n\n\ndef armfw_elf_match_to_global_values(po, match, cfunc_name):\n    params_list = {}\n    for var_name, var_info in match['vars'].items():\n        if value_needs_global_name(var_name, var_info):\n            par_info = var_info.copy()\n            var_full_name = var_name\n        else:\n            par_info = var_info.copy()\n            var_full_name = cfunc_name+'.'+var_name\n        par_info['name'] = var_full_name\n        params_list[var_full_name] = par_info\n    # Internal variables\n    if True:\n        var_name = '.re_size'\n        par_info = {'type': VarType.INTERNAL_DATA, 'variety': DataVariety.UNKNOWN}\n        var_full_name = cfunc_name+'.'+var_name\n        par_info['name'] = var_full_name\n        par_info['value'] = match['re_size']\n        par_info['cfunc_name'] = cfunc_name\n        params_list[var_full_name] = par_info\n    if True:\n        var_name = '.re'\n        par_info = {'type': VarType.INTERNAL_DATA, 'variety': DataVariety.UNKNOWN}\n        var_full_name = cfunc_name+'.'+var_name\n        par_info['name'] = var_full_name\n        par_info['value'] = match['re']\n        par_info['cfunc_name'] = cfunc_name\n        params_list[var_full_name] = par_info\n    return params_list\n\n\ndef armfw_asm_compile_lines(asm_arch, asm_addr, asm_lines):\n    ks = keystone.Ks(asm_arch['ks_const'], asm_arch['ks_mode'])\n    asm_ln_start = 0\n    bt_enc_data = b''\n    for asm_ln_curr in range(len(asm_lines)+1):\n        if asm_ln_curr < len(asm_lines):\n            curr_data = armfw_asm_parse_data_definition(asm_arch, asm_lines[asm_ln_curr])\n        else:\n            curr_data = {'value': b''}\n        if curr_data is not None:\n            # Compile any pending asm lines\n            if asm_ln_start < asm_ln_curr:\n                asm_addr_curr = asm_addr + len(bt_enc_data)\n                try:\n                    encoding, encoded_num = ks.asm(\"\\n\".join(asm_lines[asm_ln_start:asm_ln_curr]), addr=asm_addr_curr)\n                except KsError as e:\n                    encoded_num = e.get_asm_count()\n                    raise ValueError(\"Cannot compile all assembly lines: {:s}; compiled circa {:d} out of {:d}.\"\n                      .format(e.message, asm_ln_start+encoded_num, len(asm_lines)))\n                if encoded_num != asm_ln_curr-asm_ln_start:\n                    raise ValueError(\"Cannot compile all assembly lines; compiled circa {:d} out of {:d}.\"\n                      .format(asm_ln_start+encoded_num, len(asm_lines)))\n                bt_enc_data += bytes(encoding)\n            # Add data from the line at end\n            bt_enc_data += curr_data['value']\n            asm_ln_start = asm_ln_curr + 1\n    return bt_enc_data\n\n\ndef variable_info_from_value_name(glob_params_list, cfunc_name, var_name):\n    var_info = None\n    if var_name in glob_params_list:\n        var_info = glob_params_list[var_name]\n    elif cfunc_name+'.'+var_name in glob_params_list:\n        var_info = glob_params_list[cfunc_name+'.'+var_name]\n    else:\n        for var_name_iter, var_info_iter in glob_params_list.items():\n            if var_name_iter.endswith('.'+var_name):\n                var_info = var_info_iter\n                break\n    return var_info\n\n\ndef prepare_asm_line_from_pattern(asm_arch, glob_params_list, address, cfunc_name, pat_line, variab_size_select=None):\n    \"\"\" Given assembly pattern and list of variables, creates assembly line.\n\n    This function uses a list of variables to make compilable assembly line from a pattern.\n    \"\"\"\n    # List regex parameters used in that line\n    vars_used = re.findall(r'[(][?]P<([^>]+)>([^()]*([(][^()]+[)][^()]*)*)[)]', pat_line)\n    inaccurate_size = (variab_size_select is not None)\n    if not inaccurate_size:\n        instr_size = armfw_elf_compute_pattern_code_length(asm_arch, [pat_line,], glob_params_list, 'best')\n    else:\n        instr_size = asm_arch['boundary'] # not true, but good enough if we don't care about the code being properly executable\n    # Replace parameters with their values\n    asm_line = pat_line\n    for var_regex in vars_used:\n        var_name = var_regex[0]\n        var_info = variable_info_from_value_name(glob_params_list, cfunc_name, var_name)\n        if var_info is None:\n            raise ValueError(\"Parameter '{:s}' is required to compose assembly patch but was not found.\".format(var_name))\n        if (not inaccurate_size) and (var_info['cfunc_name'] != cfunc_name):\n            eprint(\"Warning: Parameter '{:s}' for function '{:s}' matched from other function '{:s}'.\"\n              .format(var_name,cfunc_name,var_info['cfunc_name']))\n\n        if (var_info['type'] in (VarType.DIRECT_INT_VALUE, VarType.ABSOLUTE_ADDR_TO_CODE,\n          VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_OFFSET,)):\n            prop_ofs_val = var_info['value']\n        elif (var_info['type'] in (VarType.RELATIVE_ADDR_TO_CODE, VarType.RELATIVE_ADDR_TO_PTR_TO_CODE,\n                VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,) and\n                var_info['baseaddr'] in (\"PC+\",\"PC-\",)):\n            prop_ofs_val = get_arm_offset_val_relative_to_pc_register(asm_arch, address, instr_size, var_info['value'])\n            if var_info['baseaddr'].endswith('-'): prop_ofs_val = -prop_ofs_val\n        elif (var_info['type'] in (VarType.DIRECT_OPERAND,)):\n            prop_ofs_val = var_info['value']\n        else:\n            raise NotImplementedError(\"Unexpected variable type found while preparimg ASM from pattern, '{:s}'.\"\n              .format(var_info['type'].name))\n        if isinstance(prop_ofs_val, int):\n            prop_ofs_val = [ prop_ofs_val ]\n        elif isinstance(prop_ofs_val, str):\n            prop_ofs_val = [ prop_ofs_val ]\n        var_value = None\n        if isinstance(prop_ofs_val, list):\n            var_value_list = []\n            for val in prop_ofs_val:\n                if isinstance(val, int):\n                    if (val >= 0):\n                        var_value_list.append(\"0x{:x}\".format(val))\n                    else:\n                        var_value_list.append(\"-0x{:x}\".format(-val))\n                elif isinstance(val, str):\n                    var_value_list.append(\"{:s}\".format(val))\n            var_value = ', '.join(var_value_list)\n        asm_line = re.sub(r'[(][?]P<'+var_name+r'>[^()]*([(][^()]+[)][^()]*)*[)]', var_value, asm_line)\n    if variab_size_select == 'long':\n        # Make optional square bracket clauses (with '?' after) to no longer be optional\n        # They will be matched again later and replaced by first char from inside\n        asm_line = re.sub(r'([^\\\\]\\[[^\\]]*?[^\\\\]\\])[?]', r'\\1', asm_line)\n        # Make optional curly bracket clauses (with '?' after) to no longer be optional\n        asm_line = re.sub(r'([^\\\\]\\([^\\)]*?[^\\\\]\\))[?]', r'\\1', asm_line)\n        # Make optional single bytes (with '?' after) to no longer be optional\n        asm_line = re.sub(r'([^\\\\\\[])[?]', r'\\1', asm_line)\n    elif variab_size_select == 'short':\n        # Remove optional regex square bracket clauses (with '?' after)\n        asm_line = re.sub(r'([^\\\\])\\[[^\\]]*?[^\\\\]\\][?]', r'\\1', asm_line)\n        # Remove optional regex curly bracket clauses (with '?' after)\n        asm_line = re.sub(r'([^\\\\])\\([^\\)]*?[^\\\\]\\)[?]', r'\\1', asm_line)\n        # Remove optional regex single bytes (with '?' after)\n        asm_line = re.sub(r'([^\\\\\\[])[?]', r'', asm_line)\n    else:\n        # Make optional square bracket clauses (with '?' after) to no longer be optional\n        asm_line = re.sub(r'([^\\\\]\\[[^\\]]*?[^\\\\]\\])[?]', r'\\1', asm_line)\n        # Make optional curly bracket clauses (with '?' after) to no longer be optional\n        asm_line = re.sub(r'([^\\\\]\\([^\\)]*?[^\\\\]\\))[?]', r'\\1', asm_line)\n        # Make optional single bytes (with '?' after) to no longer be optional\n        asm_line = re.sub(r'([^\\\\\\[])[?]', r'\\1', asm_line)\n    # Remove regex square bracket clauses with single char within brackets\n    asm_line = re.sub(r'([^\\\\])\\[([^\\\\])\\]', r'\\1\\2', asm_line)\n    # Replace regex square bracket clauses with multiple chars within brackets with first char\n    asm_line = re.sub(r'([^\\\\])\\[(.)[^\\]]*?[^\\\\]\\]', r'\\1\\2', asm_line)\n    # Remove escaping from remaining square brackets\n    asm_line = re.sub(r'\\\\([\\[\\]])', r'\\1', asm_line)\n    # Replace unnamed curly bracket clauses with alternatives ('|' within brackets) with first choice\n    asm_line = re.sub(r'([^\\\\])\\(([^\\|\\)\\?]*)[^\\)]*?[^\\\\]\\)', r'\\1\\2', asm_line)\n    return asm_line, instr_size\n\n\ndef prepare_asm_lines_from_pattern_list(asm_arch, glob_params_list, patterns_addr, cfunc_name, pattern_lines):\n    \"\"\" Given a list of patterns and variables to put inside, produces assembly code.\n\n    Removes regex-specific clauses and replaces named groups with values of variables.\n    \"\"\"\n    asm_lines = []\n    asm_addr_curr = patterns_addr\n    for pat_line in pattern_lines:\n        asm_line, code_size = prepare_asm_line_from_pattern(asm_arch, glob_params_list, asm_addr_curr, cfunc_name, pat_line)\n        asm_addr_curr += code_size\n        asm_lines.append(asm_line)\n    return asm_lines, (asm_addr_curr-patterns_addr)\n\n\ndef armfw_elf_value_pre_update_call(po, asm_arch, elf_sections, re_list, glob_params_list, var_info, new_value_str):\n    \"\"\" Calls update callback of a variable.\n    \"\"\"\n    new_var_nativ = armfw_elf_search_value_string_to_native_type(var_info, new_value_str)\n\n    if 'custom_params_callback' in var_info:\n        custom_params_update = var_info['custom_params_callback']\n        custom_params_update(asm_arch, elf_sections, re_list, glob_params_list, var_info, new_var_nativ)\n\n    # The global variable is named either exactly like property, or is preceded by function name\n    glob_var_info = variable_info_from_value_name(glob_params_list, var_info['cfunc_name'], var_info['name'])\n    if glob_var_info is None:\n        raise ValueError(\"Lost the variable to set, '{:s}' - internal error.\".format(var_info['name']))\n\n    if glob_var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n        # The value was taken directly from code - must be converted to int form\n        prop_bytes = armfw_elf_search_value_native_type_to_bytes(asm_arch, glob_var_info, new_var_nativ)\n        if len(prop_bytes) > 0:\n            if glob_var_info['variety'] in (DataVariety.CHAR,):\n                new_value = prop_bytes.decode(\"ISO-8859-1\")\n            else:\n                prop_pad = len(prop_bytes) % 4\n                if prop_pad != 0:\n                    prop_bytes = prop_bytes + (b\"\\0\" * (4 - prop_pad))\n                new_value = int.from_bytes(prop_bytes, byteorder=asm_arch['byteorder'], signed=False)\n        else:\n            new_value = None\n        if new_value is None:\n            raise ValueError(\"Unable to prepare direct int value from provided string value.\")\n        # Set new value of the global variable and generate the code with it\n        glob_var_info['value'] = new_value\n    elif glob_var_info['type'] in (VarType.DETACHED_DATA,):\n        if 'depend' in glob_var_info:\n            # there is no action to take here\n            pass\n        else:\n            # DETACHED_DATA with no dependency should store constant setValue, and that alue is used to select variant of cfunc\n            glob_re_var = glob_params_list[glob_var_info['cfunc_name']+'..re']\n            # For detached data, we need to find an assembly pattern with matching value, and then patch the asm code to look like it\n            patterns_next = find_patterns_containing_variable(re_list, cfunc_ver=glob_var_info['cfunc_ver'], var_name=glob_var_info['name'], var_setValue=str(new_var_nativ))\n            if patterns_next is None:\n                raise ValueError(\"Cannot find function modification which would allow to set the value of {:s}={:s}.\"\n                  .format(glob_var_info['name'],str(new_var_nativ)))\n            re_lines, re_labels = armfw_asm_search_strings_to_re_list(patterns_next['re'])\n            glob_re_var['value'] = re_lines\n            #for lab_name, lab_line in re_labels.items(): #TODO - update line numbers in label variables if this will be needed\n    else:\n        # No pre-update glob_var_info modifications needed for other types\n        pass\n    # We might have glob_params_list updated now, but pub_params_list has an outdated copy\n    if True:\n        for fld_name, fld_value in glob_var_info.items():\n            if fld_name in ('name',):\n                continue\n            var_info[fld_name] = fld_value\n\n\ndef get_final_address_from_var_info(asm_arch, elf_sections, var_info):\n    if var_info['type'] in (VarType.DIRECT_INT_VALUE, VarType.DIRECT_LINE_OF_CODE, VarType.DIRECT_OPERAND,):\n        return var_info['address']\n    elif var_info['type'] in (VarType.ABSOLUTE_ADDR_TO_CODE, VarType.RELATIVE_ADDR_TO_CODE,\n      VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_GLOBAL_DATA,):\n        return var_info['value']\n    elif var_info['type'] in (VarType.RELATIVE_ADDR_TO_PTR_TO_CODE, VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,):\n        return var_info['value']\n    return None\n\n\ndef armfw_elf_get_value_switching_patterns_update_bytes(po, asm_arch, elf_sections, re_list, glob_params_list, var_info, new_var_nativ):\n    \"\"\" Finds an assembly pattern with matching value, and then returns a binary patching which makes the asm code to look like it\n    \"\"\"\n    if (po.verbose > 3):\n        print(\"Using Keystone arch=0x{:x} mode=0x{:x} for switching pat update\".format(asm_arch['ks_const'], asm_arch['ks_mode']))\n    patterns_next = find_patterns_containing_variable(re_list, cfunc_ver=var_info['cfunc_ver'], var_name=var_info['name'], var_setValue=str(new_var_nativ))\n    patterns_prev = find_patterns_containing_variable(re_list, cfunc_ver=var_info['cfunc_ver'], var_type=var_info['type'], var_name=var_info['name'], var_setValue=var_info['setValue'])\n    # Get part of the pattern which is different between the current one and the one we want\n    patterns_diff = []\n    if patterns_prev != patterns_next:\n        patterns_diff, patterns_preced, patterns_diff_prev = find_patterns_diff(patterns_prev, patterns_next)\n    valbts = []\n    if len(patterns_diff) < 1:\n        return valbts\n    # From patterns preceding the diff, compute offset where the diff starts\n    glob_re_size = glob_params_list[var_info['cfunc_name']+'..re_size']['value']\n    # for DETACHED_DATA, 'address' identifies beginning of the whole matched block; add proper amount of instruction sizes to it\n    patterns_addr = var_info['address'] + sum(glob_re_size[0:len(patterns_preced)])\n    if (po.verbose > 2):\n        print(\"Making code re:\",\"; \".join(patterns_diff))\n    var_sect, var_offs = get_section_and_offset_from_address(asm_arch, elf_sections, patterns_addr)\n    if var_sect is None:\n        raise ValueError(\"Address to uninitialized data found (0x{:06x}) while updating '{:s}'.\".format(patterns_addr, var_info['name']))\n    asm_lines, bt_size_predict = prepare_asm_lines_from_pattern_list(asm_arch, glob_params_list, patterns_addr, var_info['cfunc_name'], patterns_diff)\n    if len(asm_lines) < 1:\n        raise ValueError(\"No assembly lines prepared - internal error.\")\n    # Now compile our new code line\n    if (po.verbose > 2):\n        print(\"Compiling code:\",\"; \".join(asm_lines))\n    bt_enc_data = armfw_asm_compile_lines(asm_arch, patterns_addr, asm_lines)\n    if len(bt_enc_data) != bt_size_predict:\n        raise ValueError(\"Compiled code size different than expected (got {:d} instead of {:d} bytes) - internal error.\"\n          .format(len(bt_enc_data),bt_size_predict))\n    bt_size_previous = sum(glob_re_size[len(patterns_preced):len(patterns_preced)+len(patterns_diff_prev)])\n    if len(bt_enc_data) != bt_size_previous:\n        raise ValueError(\"Compiled code size different than previous (got {:d} instead of {:d} bytes) - internal error.\"\n          .format(len(bt_enc_data),bt_size_previous))\n    valbt = {}\n    valbt['sect'] = var_sect\n    valbt['offs'] = var_offs\n    valbt['data'] = bt_enc_data\n    valbts.append(valbt)\n    return valbts\n\n\ndef armfw_elf_get_value_update_bytes(po, asm_arch, elf_sections, re_list, glob_params_list, var_info, par_strvalue_nx):\n    if (po.verbose > 3):\n        print(\"Using Keystone arch=0x{:x} mode=0x{:x} for value bytes update\".format(asm_arch['ks_const'], asm_arch['ks_mode']))\n    valbts = []\n    # Get expected length of the value\n    prop_size, prop_count = armfw_elf_section_search_get_value_size(asm_arch, var_info)\n    new_var_nativ = armfw_elf_search_value_string_to_native_type(var_info, par_strvalue_nx)\n\n    # not calling 'custom_params_callback' here - it should have been called before\n\n    if var_info['type'] in (VarType.DIRECT_INT_VALUE,):\n        # We are only changing one line, but use the whole multiline algorithm just for unification\n        #TODO make the possibility of multiple lines with one variable\n        glob_re = glob_params_list[var_info['cfunc_name']+'..re']['value']\n        patterns_list = [glob_re[var_info['line']],]\n        if len(patterns_list) > 0:\n            glob_re_size = glob_params_list[var_info['cfunc_name']+'..re_size']['value']\n            patterns_addr = var_info['address']\n            if (po.verbose > 2):\n                print(\"Making code re:\",\"; \".join(patterns_list))\n            var_sect, var_offs = get_section_and_offset_from_address(asm_arch, elf_sections, patterns_addr)\n            if var_sect is None:\n                raise ValueError(\"Address to uninitialized data found (0x{:06x}) while updating '{:s}'.\"\n                  .format(patterns_addr, var_info['name']))\n            asm_lines, bt_size_predict = prepare_asm_lines_from_pattern_list(asm_arch, glob_params_list,\n              patterns_addr, var_info['cfunc_name'], patterns_list)\n            # Now compile our new code line\n            if (po.verbose > 2):\n                print(\"Compiling code:\",\"; \".join(asm_lines))\n            bt_enc_data = armfw_asm_compile_lines(asm_arch, patterns_addr, asm_lines)\n            if len(bt_enc_data) != bt_size_predict:\n                raise ValueError(\"Compiled code size different than expected (got {:d} instead of {:d} bytes) - internal error.\"\n                  .format(len(bt_enc_data), bt_size_predict))\n            bt_size_previous = glob_re_size[var_info['line']]\n            if len(bt_enc_data) != bt_size_previous:\n                raise ValueError(\"Compiled code size different than previous (got {:d} instead of {:d} bytes) - internal error.\"\n                  .format(len(bt_enc_data), bt_size_previous))\n            valbt = {}\n            valbt['sect'] = var_sect\n            section = elf_sections[valbt['sect']]\n            valbt['offs'] = var_offs\n            valbt['data'] = bt_enc_data\n            valbts.append(valbt)\n            if (po.verbose > 3):\n                print(\"Offset 0x{:06x} data {:s}\".format(valbt['offs'], valbt['data'].hex()))\n    elif var_info['type'] in (VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, VarType.RELATIVE_ADDR_TO_GLOBAL_DATA,\n      VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA,):\n        # The value was referenced in code, but stored outside\n        bt_enc_data = armfw_elf_search_value_native_type_to_bytes(asm_arch, var_info, new_var_nativ)\n        if len(bt_enc_data) < 1:\n            raise ValueError(\"Unable to prepare bytes from provided string value.\")\n\n        # for \"*_ADDR_*\" types, 'value' stores address\n        var_sect, var_offs = get_section_and_offset_from_address(asm_arch, elf_sections, var_info['value'])\n        if var_sect is None:\n            raise ValueError(\"Address to uninitialized data found (0x{:06x}) while updating '{:s}'.\"\n              .format(var_info['value'], var_info['name']))\n        valbt = {}\n        valbt['sect'] = var_sect\n        section = elf_sections[valbt['sect']]\n        valbt['offs'] = var_offs\n        valbt['data'] = bytes(bt_enc_data)\n        valbts.append(valbt)\n    elif var_info['type'] in (VarType.DETACHED_DATA,):\n        if 'depend' in var_info:\n            # DETACHED_DATA which depends on other variables only has relation to code\n            # by other variables depending on it; this function should never be called for such veriable\n            raise ValueError(\"Unable to prepare bytes for '{:s}' because it represents detached data with dependants.\"\n              .format(var_info['name']))\n        else:\n            # For detached data, we need to find an assembly pattern with matching value, and then patch the asm code to look like it\n            valbts += armfw_elf_get_value_switching_patterns_update_bytes(po, asm_arch,\n              elf_sections, re_list, glob_params_list, var_info, new_var_nativ)\n    elif var_info['type'] in (VarType.UNUSED_DATA,):\n        # No binary change needed in regard to that variable\n        pass\n    else:\n        raise NotImplementedError(\"Unexpected variable type found while getting update bytes from it, '{:s}'.\"\n          .format(var_info['type'].name))\n\n    for valbt in valbts:\n        section = elf_sections[valbt['sect']]\n        if (valbt['offs'] < 0) or (valbt['offs'] + len(valbt['data']) > len(section['data'])):\n            raise ValueError(\"Got past section '{:s}' border - internal error.\".format(valbt['sect']))\n    return valbts\n\n\ndef armfw_elf_paramvals_extract_list(po, elffh, re_list, asm_submode=None):\n\n    elfobj = ELFFile(elffh)\n\n    asm_arch, asm_modes = elf_march_to_asm_config(elfobj, asm_submode)\n    if len(asm_modes) < 1 or not isinstance(asm_modes[0], collections.abc.Mapping):\n        raise ValueError(\"ELF has unsupported machine type ({:s}).\".format(elfobj['e_machine']))\n\n    cs_mode = 0\n    ks_mode = 0\n    retshift = 0\n    for mode in asm_modes:\n        cs_mode = cs_mode | mode['cs_const']\n        ks_mode = ks_mode | mode['ks_const']\n        # check for mode specific overrides\n        if 'byteorder' in mode:\n            asm_arch['byteorder'] = mode['byteorder']\n        if 'boundary' in mode:\n            asm_arch['boundary'] = mode['boundary']\n        if 'retshift' in mode:\n            retshift = mode['retshift']\n    asm_arch['cs_mode'] = cs_mode\n    asm_arch['ks_mode'] = ks_mode\n\n    cs = capstone.Cs(asm_arch['cs_const'], asm_arch['cs_mode'])\n\n    # Get sections dictionary, so that we can easily access them by name\n    elf_sections = {}\n    for i in range(elfobj.num_sections()):\n        section = elfobj.get_section(i)\n\n        if section['sh_type'] != \"SHT_PROGBITS\":\n            continue\n\n        if (po.verbose > 2):\n            print(\"{:s}: Found section {:s} at 0x{:06x}\".format(po.elffile, section.name, section['sh_addr']))\n\n        elf_sections[section.name] = {\n              'index' : i,\n              'name' : section.name,\n              'addr' : section['sh_addr'],\n              'data' : section.data(),\n        }\n\n    # Check if expected sections are there\n    expect_sections = ['.text', '.data']\n    for re_item in re_list:\n        if re_item['sect'] not in expect_sections:\n            expect_sections.append(re_item['sect'])\n    for sect_name in expect_sections:\n        if sect_name not in elf_sections:\n            raise ValueError(\"ELF does not contain expected section '{:s}'.\".format(sect_name))\n\n    # prepare list of parameter values\n    pub_params_list = {}\n    glob_params_list = {}\n    found_func_list = []\n    for re_item in re_list:\n        matches = armfw_elf_whole_section_search(po, asm_arch, elf_sections, cs, re_item['sect'], re_item['func'], glob_params_list)\n        for i, match in enumerate(matches):\n            if i == 0:\n                found_func_list.append(re_item['func'])\n                func_name = re_item['func']['name']\n            else:\n                func_name = \"{:s}_{:02d}\".format(re_item['func']['name'],i)\n            pub_params_list.update(armfw_elf_match_to_public_values(po, match))\n            glob_params_list.update(armfw_elf_match_to_global_values(po, match, func_name))\n\n    # verify if we've found all the functions we should have founded\n    missed_func_list = []\n    for re_item in re_list:\n        # skip items with name identical to one of these we've found\n        if re_item['func']['name'] in [re_func['name'] for re_func in found_func_list]:\n            continue\n        # skip function variants identified by DETACHED_DATA variable\n        detached_var_found = False\n        detached_var_name = get_matching_variable_from_patterns(re_item['func'], var_type=VarType.DETACHED_DATA, var_depend=False)\n        if detached_var_name is not None:\n            for re_func in found_func_list:\n                detached_match_name = get_matching_variable_from_patterns(re_func, var_type=VarType.DETACHED_DATA, var_name=detached_var_name)\n                if detached_match_name is not None:\n                    detached_var_found = True\n                    break\n        if detached_var_found:\n            continue\n        # skip items which have 'alt_name' pointing to a function we've found\n        alt_name_found = False\n        if 'alt_name' in re_item['func']:\n            for re_alt_name in re_item['func']['alt_name'].split(','):\n                for re_func in found_func_list:\n                    if re.fullmatch(re_alt_name, re_func['name']):\n                        alt_name_found = True\n                        break\n                if alt_name_found:\n                    break\n        if alt_name_found:\n            continue\n        # add only one variant of each function\n        if re_item['func']['name'] in [re_func['name'] for re_func in missed_func_list]:\n            continue\n        missed_func_list.append(re_item['func'])\n    for re_func in missed_func_list:\n        print(\"{:s}: Warning: No variant of function '{:s}' was found\".format(po.elffile, re_func['name']))\n    if len(missed_func_list) > 0:\n        print(\"{:s}: Warning: From expacted functions, {:d} were not found\".format(po.elffile, len(missed_func_list)))\n    else:\n        print(\"{:s}: All expected functions were found\".format(po.elffile))\n\n    return pub_params_list, glob_params_list, elf_sections, cs, elfobj, asm_arch\n\n\ndef armfw_elf_paramvals_export_simple_list(po, params_list, valfile):\n    valfile.write(\"{:s}\\t{:s}\\n\".format(\"Name\",\"Value\"))\n    for par_name, par_info in params_list.items():\n        valfile.write(\"{:s}\\t{:s}\\n\".format(par_name,par_info['str_value']))\n    if (po.verbose > 0):\n        print(\"{:s}: Listed {:d} hardcoded values\".format(po.elffile, len(params_list)))\n\n\ndef armfw_elf_ambavals_list(po, elffh):\n    global re_general_list\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    # print list of parameter values\n    armfw_elf_paramvals_export_simple_list(po, params_list, sys.stdout)\n\n\ndef armfw_elf_paramvals_export_mapfile(po, params_list, elf_sections, asm_arch, valfile):\n    valfile.write(\"  {:s}         {:s}\\n\".format(\"Address\",\"Publics by Value\"))\n    symbols_num = 0\n    for par_name, par_info in params_list.items():\n        if not value_type_is_known_address(par_info):\n            continue\n        if par_info['variety'] in (CodeVariety.CHUNK,):\n            continue\n        var_sect, var_offs = get_section_and_offset_from_address(asm_arch, elf_sections, par_info['value'])\n        if var_sect is None:\n            eprint(\"{:s}: Cannot retrieve offset for symbol '{:s}' at 0x{:08x}\".format(po.elffile, par_name, par_info['value']))\n            continue\n        var_sect_index = elf_sections[var_sect]['index']\n        valfile.write(\" {:04X}:{:08X}       {:s}\\n\".format(var_sect_index,var_offs,par_info['name']))\n        symbols_num += 1\n    if (po.verbose > 0):\n        print(\"{:s}: Map contains {:d} symbols\".format(po.elffile, symbols_num))\n\n\ndef armfw_elf_ambavals_mapfile(po, elffh):\n    global re_general_list\n    _, params_list, elf_sections, _, _, asm_arch = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    armfw_elf_paramvals_export_mapfile(po, params_list, elf_sections, asm_arch, sys.stdout)\n\n\ndef armfw_elf_paramvals_export_json(po, params_list, valfile):\n    valfile.write(\"[\\n\")\n    full_index = 0\n    for par_name, par_info in params_list.items():\n        if (full_index != 0):\n            valfile.write(\",\\n\")\n        valfile.write(\"\\t{\\n\")\n        for ppname in ('index',):\n            valfile.write(\"\\t\\t\\\"{:s}\\\" : {:d}\".format(ppname,full_index))\n        for ppname in ('description',):\n            valfile.write(\",\\n\")\n            valfile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,par_info[ppname]))\n        for ppname in ('hint1','hint2','hint3','hint4','hint5'):\n            if ppname not in par_info: continue\n            valfile.write(\",\\n\")\n            valfile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,par_info[ppname]))\n        for ppname in ('minValue', 'maxValue', 'defaultValue'):\n            if ppname not in par_info: continue\n            valfile.write(\",\\n\")\n            if re.fullmatch(r\"^(0[Xx][0-9a-fA-F]+|[0-9-]+|[0-9-]*[.][0-9]+)$\", par_info['str_value']):\n                valfile.write(\"\\t\\t\\\"{:s}\\\" : {:s}\".format(ppname,par_info[ppname]))\n            else:\n                valfile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,par_info[ppname]))\n        for ppname in ('setValue',):\n            valfile.write(\",\\n\")\n            if re.fullmatch(r\"^(0[Xx][0-9a-fA-F]+|[0-9-]+|[0-9-]*[.][0-9]+)$\", par_info['str_value']):\n                valfile.write(\"\\t\\t\\\"{:s}\\\" : {:s}\".format(ppname,par_info['str_value']))\n            else:\n                valfile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,par_info['str_value']))\n        for ppname in ('name',):\n            valfile.write(\",\\n\")\n            valfile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,par_name))\n        valfile.write(\"\\n\")\n        valfile.write(\"\\t}\")\n        full_index += 1\n    valfile.write(\"\\n\")\n    valfile.write(\"]\\n\")\n    if (po.verbose > 0):\n        print(\"{:s}: Extracted {:d} hardcoded values\".format(po.elffile, len(params_list)))\n\n\ndef armfw_elf_ambavals_extract(po, elffh):\n    \"\"\" Extracts all values from firmware to JSON format text file.\n    \"\"\"\n    global re_general_list\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    if len(params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    if not po.dry_run:\n        valfile = open(po.valfile, \"w\")\n    else:\n        valfile = io.StringIO()\n    armfw_elf_paramvals_export_json(po, params_list, valfile)\n    valfile.close()\n\n\ndef armfw_elf_paramvals_get_depend_value(glob_params_list, deppar_info):\n    par_strvalue_nx = None\n    for var_name_iter, var_info_iter in glob_params_list.items():\n        if deppar_info['depend'] != var_name_iter:\n            continue\n        if deppar_info['public'] != var_info_iter['public']:\n            continue\n        par_strvalue_nx = var_info_iter['str_value']\n        break\n    if par_strvalue_nx is None:\n        return None\n    if 'getter' not in deppar_info:\n        return None\n    get_value_from_depend_value = deppar_info['getter']\n    return get_value_from_depend_value(par_strvalue_nx)\n\n\ndef armfw_elf_paramvals_get_depend_list(glob_params_list, par_info, par_strvalue_nx):\n    \"\"\" Gets a list of depending values which should be updated if specific public param changed value.\n\n    Emulates the list format we get from JSON, so that the same update functions can be used as for\n    the parent public parameter.\n    \"\"\"\n    depend_list = []\n    for var_name_iter, var_info_iter in glob_params_list.items():\n        if 'depend' not in var_info_iter:\n            continue\n        if var_info_iter['depend'] != par_info['name']:\n            continue\n        if var_info_iter['public'] != par_info['public']:\n            continue\n        #deppar_name = var_info_iter['public']+'.'+var_name_iter\n        deppar_info = var_info_iter.copy()\n        #deppar_info['name'] = deppar_name\n        if 'getter' in deppar_info:\n            get_value_from_depend_value = deppar_info['getter']\n            deppar_info['setValue'] = get_value_from_depend_value(par_strvalue_nx)\n        if 'setValue' not in deppar_info:\n            raise ValueError(\"No 'setValue' and no 'getter' in '{:s}'.\".format(deppar_info['name']))\n        depend_list.append(deppar_info)\n    return depend_list\n\n\ndef armfw_elf_publicval_update(po, asm_arch, elf_sections, re_list, glob_params_list, par_info, par_strvalue_nx):\n    \"\"\" Updates given hardcoded value in ELF section data.\n    \"\"\"\n    if par_info['type'] in (VarType.DETACHED_DATA,) and 'depend' in par_info:\n        # Special case - a variable which has no directly associated data, only updates binary data by dependants\n        return True\n    valbts = armfw_elf_get_value_update_bytes(po, asm_arch, elf_sections,\n      re_list, glob_params_list, par_info, par_strvalue_nx)\n    update_performed = False\n    for valbt in valbts:\n        section = elf_sections[valbt['sect']]\n        old_beg = valbt['offs']\n        old_end = valbt['offs']+len(valbt['data'])\n        old_data = section['data'][old_beg:old_end]\n        if valbt['data'] != old_data:\n            update_performed = True\n            if (po.verbose > 1):\n                print(\"At 0x{:06x}, replacing {:s} -> {:s} to set {:s}\".format(\n                  section['addr'] + old_beg,old_data.hex(), valbt['data'].hex(), par_info['name']))\n            sect_data = section['data']\n            sect_data[old_beg:old_end] = valbt['data']\n    return update_performed\n\n\ndef armfw_elf_paramvals_update_list(po, asm_arch, re_list, pub_params_list, glob_params_list, elf_sections, nxparams_list):\n    update_list_a = [] # Params which others use ag 'getters' should be updated first\n    update_list_b = [] # Most parameters are updated as part of this list\n    update_list_c = [] # Some parameters have multiline changes and should be updated at end\n\n    # Get names of all variables which other depend on\n    depend_names_list = []\n    for par_info in glob_params_list:\n        if 'depend' in par_info:\n            if 'public' in par_info:\n                depend_names_list.append(par_info['public']+'.'+par_info['depend'])\n            else:\n                depend_names_list.append(par_info['depend'])\n\n    for nxpar in nxparams_list:\n        if nxpar['name'] not in pub_params_list:\n            eprint(\"{:s}: Value '{:s}' not found in ELF file.\".format(po.elffile,nxpar['name']))\n            continue\n        par_info = pub_params_list[nxpar['name']]\n        if par_info['name'] in depend_names_list:\n            update_list_a.append(nxpar)\n        elif par_info['type'] in (VarType.DETACHED_DATA,):\n            update_list_c.append(nxpar)\n        else:\n            update_list_b.append(nxpar)\n\n    for nxpar in update_list_a + update_list_b + update_list_c:\n        par_info = pub_params_list[nxpar['name']]\n        armfw_elf_value_pre_update_call(po, asm_arch, elf_sections, re_list, glob_params_list, par_info, nxpar['setValue'])\n        if True:\n            depparams_list = armfw_elf_paramvals_get_depend_list(glob_params_list, par_info, nxpar['setValue'])\n            for deppar in depparams_list:\n                armfw_elf_value_pre_update_call(po, asm_arch,\n                      elf_sections, re_list, glob_params_list, deppar, deppar['setValue'])\n\n    update_count = 0\n    # Update the params from priority lists\n    for nxpar in update_list_a + update_list_b + update_list_c:\n        par_info = pub_params_list[nxpar['name']]\n        update_performed = armfw_elf_publicval_update(po, asm_arch, elf_sections,\n          re_list, glob_params_list, par_info, nxpar['setValue'])\n        if update_performed:\n            depparams_list = armfw_elf_paramvals_get_depend_list(glob_params_list, par_info, nxpar['setValue'])\n            for deppar in depparams_list:\n                update_performed = armfw_elf_publicval_update(po, asm_arch,\n                  elf_sections, re_list, glob_params_list, deppar, deppar['setValue'])\n            update_count += 1\n\n    return update_count\n\n\ndef armfw_elf_ambavals_update(po, elffh):\n    \"\"\" Updates all hardcoded values in firmware from JSON format text file.\n    \"\"\"\n    global re_general_list\n    pub_params_list, glob_params_list, elf_sections, cs, elfobj, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    if len(pub_params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    with open(po.valfile) as valfile:\n        nxparams_list = json.load(valfile)\n    # Change section data buffers to bytearrays, so we can change them easily\n    for section_name, section in elf_sections.items():\n        section['data'] = bytearray(section['data'])\n    update_count = armfw_elf_paramvals_update_list(po, asm_arch, re_general_list,\n      pub_params_list, glob_params_list, elf_sections, nxparams_list)\n    if (po.verbose > 0):\n        print(\"{:s}: Updated {:d} out of {:d} hardcoded values\"\n          .format(po.elffile, update_count, len(pub_params_list)))\n    # Now update the ELF file\n    for section_name, section in elf_sections.items():\n        elfsect = elfobj.get_section_by_name(section_name)\n        elfsect.set_data(section['data'])\n        elfobj.set_section_by_name(section_name, elfsect)\n    if not po.dry_run:\n        elfobj.write_changes()\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-e', '--elffile', type=str, required=True,\n          help=\"input ELF firmware file name\")\n\n    parser.add_argument('-o', '--valfile', type=str,\n          help=(\"directory and file name of JSON with values list \"\n           \"(default is base name of elffile with extension switched to json, in working dir)\"))\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('-l', '--list', action='store_true',\n          help=\"list values stored in the firmware\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract values to infos json text file\")\n\n    subparser.add_argument('-u', '--update', action='store_true',\n          help=\"update values in binary fw from infos text file\")\n\n    subparser.add_argument('-d', '--objdump', action='store_true',\n          help=\"display asm like slightly primitive objdump\")\n\n    subparser.add_argument('--mapfile', action='store_true',\n          help=\"export known symbols to map file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.basename = os.path.splitext(os.path.basename(po.elffile))[0]\n\n    if len(po.elffile) > 0 and (po.valfile is None or len(po.valfile) == 0):\n        po.valfile = po.basename + \".json\"\n\n    if po.objdump:\n        if (po.verbose > 0):\n            print(\"{}: Opening for objdump\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_generic_objdump(po, elffh)\n\n    elif po.list:\n        if (po.verbose > 0):\n            print(\"{}: Opening for list\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_ambavals_list(po, elffh)\n\n    elif po.mapfile:\n        if (po.verbose > 0):\n            print(\"{}: Opening for mapfile generation\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_ambavals_mapfile(po, elffh)\n\n    elif po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extract\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_ambavals_extract(po, elffh)\n\n    elif po.update:\n        if (po.verbose > 0):\n            print(\"{}: Opening for update\".format(po.elffile))\n        with open(po.elffile, 'r+b') as elffh:\n            armfw_elf_ambavals_update(po, elffh)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "amba_ubifs.sh",
          "type": "blob",
          "size": 3.55859375,
          "content": "#!/bin/bash\n# -*- coding: utf-8 -*-\n\n# This scripts mounts a UBI disk image on a Linux host.\n#\n# The UBI filesystem is a bit different from all FATs, NTFSes and EXTs,\n# as it is especially designed for solid state devices. It requires\n# specific hardware operations to be accessible on the block device.\n# This means the (usually used for mounting images) loopback block device\n# will not work with UBIFS. To make it mount, a simulation of solid state\n# device is required. Fortunately - there is such simulator, called NANDSim.\n#\n# Please note that this script is for mounting whole UBI disk images,\n# not a single volume files (it mounts whole disks, not partitions).\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n#set -x\nset -e\n# $IMAGE is ubifs image file\nIMAGE=$1\nSKIP_ADD=0\n\n# the \"-d\" option can be used for dismount\nif [ \"${IMAGE}\" == \"-d\" ]; then\n  SKIP_ADD=1\n  IMAGE=\"DISMOUNT\"\nfi\n\nif [ ! \"${SKIP_ADD}\" -eq \"1\" ]; then\n  if [ ! -e \"${IMAGE}\" ]; then\n    echo \"${IMAGE}: Image file not found\"\n    exit 1\n  fi\nfi\n\nif [ -e /dev/ubi0_0 ]; then\n  echo \"${IMAGE}: UBI volume 0 already in place, removing\"\n  set +e\n  sudo umount /dev/ubi0_0\n  set -e\nfi\n\nif [ -e /dev/ubi0_1 ]; then\n  echo \"${IMAGE}: UBI volume 1 already in place, removing\"\n  set +e\n  sudo umount /dev/ubi0_1\n  set -e\nfi\n\nif [ -e /dev/ubi0 ]; then\n  echo \"${IMAGE}: UBI filesystem already attached, detaching\"\n  ubidetach -d 0\nfi\n\nif [ \"${SKIP_ADD}\" -eq \"1\" ]; then\n  echo \"${IMAGE}: Unloading modules\"\n  set +e\n  rmmod ubifs\n  rmmod nandsim\n  set -e\n  echo \"${IMAGE}: Done, all clear\"\n  exit 0\nfi\n\nif [ ! -b \"/dev/mtd0\" ]; then\n  echo \"${IMAGE}: Loading module to create mtd0\"\n  # size of created mtd is 256.0 MiB\n  #modprobe nandsim first_id_byte=0x2c second_id_byte=0xda third_id_byte=0x90 fourth_id_byte=0x95\n  # size of created mtd is 128.0 MiB\n  #modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95\n  # size of created mtd is 64MiB-2048\n  modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00 fourth_id_byte=0x15\nelse\n  echo \"${IMAGE}: Module for mtd0 already loaded\"\n  rmmod ubi\nfi\necho \"${IMAGE}: Loading image to simulated device\"\nflash_erase /dev/mtd0 0 0\n# Copy the image to simulated NAND array; on real hardware this only works with ubiformat,\n# but simulated NAND will have no issues accepting copy by dd.\n#ubiformat /dev/mtd0 --sub-page-size=512 --vid-hdr-offset=2048 -f ${IMAGE}\nsudo dd if=${IMAGE} of=/dev/mtd0 bs=$((1024*1024))\necho \"${IMAGE}: Attaching UBI filesystem\"\nmodprobe ubi\nubiattach -m 0 -d 0 --vid-hdr-offset=2048\nif [ ! -e /dev/ubi0_0 ]; then\n  echo \"${IMAGE}: No volumes found, loading UBI must've failed\"\n  exit 2\nfi\necho \"${IMAGE}: Mounting volumes\"\nmkdir -p \"/mnt/ubi0_0\"\nmount -t ubifs /dev/ubi0_0 \"/mnt/ubi0_0\"\n# volume 1 will not mount anyway; its alomst empty, likely swap\n#mkdir -p \"/mnt/ubi0_1\"\n#mount -t ubifs /dev/ubi0_1 \"/mnt/ubi0_1\"\n\nexit 0\n"
        },
        {
          "name": "arm_bin2elf.py",
          "type": "blob",
          "size": 30.7666015625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Binary firmware with ARM code to ELF converter.\n\n Converts BIN firmware with ARM code from a binary image form into\n ELF format. The ELF format can be then easily disassembled, as most\n tools can read ELF files.\n\n The BIN firmware is often linked and prepared like this:\n\n```\n  arm-none-eabi-ld \\\n   -EL -p --no-undefined --gc-sections \\\n   -nostdlib -nodefaultlibs -nostartfiles \\\n   -o out/firmware.elf -T custom_sections.lds \\\n   --start-group --whole-archive \\\n   lib/libapp.a \\\n   [...]\n   lib/libmain.a \\\n   --no-whole-archive -lc -lnosys -lm -lgcc -lrdimon -lstdc++ \\\n   --end-group\n\n  arm-none-eabi-nm -n -l out/firmware.elf\n\n  arm-none-eabi-objcopy -O binary out/firmware.elf out/firmware.bin\n```\n\n Note that the last command converts a linked ELF file into a binary\n memory image. The purpose of this tool is to revert that last operation,\n which makes it a lot easier to use tols like objdump or IDA Pro.\n\n The script uses an ELF template, which was prepared especially for BINs\n within DJI firmwares. It was made by compiling an example mock firmware,\n and then stripping all the data with use of objcopy.\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.3.1\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport os\nimport re\nfrom ctypes import c_uint, sizeof, LittleEndianStructure\n\nsys.path.insert(0, '../pyelftools')\ntry:\n    import elftools.elf.elffile\n    import elftools.elf.sections\n    if not callable(getattr(elftools.elf.elffile.ELFFile, \"write_changes\", None)):\n       raise ImportError(\"The pyelftools library provided has no write support\")\nexcept ImportError:\n    print(\"Warning:\")\n    print(\"This tool requires version of pyelftools with ELF write support.\")\n    print(\"Get it from https://github.com/mefistotelis/pyelftools.git\")\n    print(\"clone to upper level folder, '../pyelftools'.\")\n    raise\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass ExIdxEntry(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n      ('tboffs', c_uint),\n      ('entry', c_uint)\n    ]\n\n    def dict_export(self):\n        d = dict()\n        for (varkey, vartype) in self._fields_:\n            val = getattr(self, varkey)\n            d[varkey] = \"{:08X}\".format(val)\n        return d\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=4, width=1)\n\n\ndef sign_extend(value, bits):\n    \"\"\" Sign-extend an integer value from given amount of bits to full Python int\n    \"\"\"\n    sign_bit = 1 << (bits - 1)\n    return (value & (sign_bit - 1)) - (value & sign_bit)\n\n\ndef prel31_to_addr(ptr, refptr):\n    \"\"\" Convert a prel31 symbol to an absolute address\n    \"\"\"\n    offset = sign_extend(ptr, 31)\n    return c_uint(refptr + offset).value\n\n\ndef armfw_is_proper_ARMexidx_entry(po, fwpartfile, eexidx, memaddr_base, func_align, arr_pos, ent_pos):\n    \"\"\" Checks whether given ExIdxEntry object stores a proper entry of\n        .ARM.exidx section. The entries are described in detail in\n        \"Exception Handling ABI for the ARM Architecture\" document.\n        The function assumes that .text section with code is located before\n        the .ARM.exidx section, starting at memaddr_base.\n    \"\"\"\n    sectname = \".ARM.exidx\"\n    # Spec states clearly this offset is \"with bit 31 clear\"\n    if (eexidx.tboffs == 0) or (eexidx.tboffs & 0x80000000):\n        return False\n    glob_offs = prel31_to_addr(eexidx.tboffs, memaddr_base+ent_pos)\n    # Check if first word offset falls into \".text\" section and can be a function start\n    if (glob_offs <= memaddr_base) or (glob_offs >= memaddr_base+arr_pos) or ((glob_offs % func_align) != 0):\n        return False\n    #TODO we could also check if the handling function starts with STORE/STM instruction; it is very unlikely to start in different way\n    # Second word can be one of 3 things: table entry offset, exception entry itself or EXIDX_CANTUNWIND\n    # Check if second word contains EXIDX_CANTUNWIND value (0x01)\n    if (eexidx.entry == 0x01):\n        if (po.verbose > 2):\n            print(\"{}: Matching '{:s}' entry at 0x{:08x}: 0x{:08x} 0x{:08x} [CANTUNWIND]\"\n              .format(po.fwpartfile, sectname, ent_pos, glob_offs, eexidx.entry))\n        return True\n    # Check if second word contains exception handling entry itself\n    if (eexidx.entry & 0x80000000):\n        # According to specs, bits 30-28 should be zeros; personality routine and index are stored on lower bits\n        if (eexidx.entry & 0x70000000):\n            return False\n        if (po.verbose > 2):\n            print(\"{}: Matching '{:s}' entry at 0x{:08x}: 0x{:08x} 0x{:08x} [handling entry, idx 0x{:02x}]\"\n              .format(po.fwpartfile, sectname, ent_pos, glob_offs, eexidx.entry, (eexidx.entry >> 24) & 7))\n        return True\n    # Check if second word contains table entry start offset\n    # the offset is not to the .data segment, but to a separate .ARM.extab segment\n    # Let's assume this segment is somewhere adjacent to our .ARM.exidx segment\n    # Size of the table entry which is being pointed at is no less than 4 bytes\n    tbent_offs = prel31_to_addr(eexidx.entry, memaddr_base+ent_pos)\n    if ((tbent_offs >= memaddr_base+arr_pos-po.expect_sect_align*0x10) and (tbent_offs <= memaddr_base+arr_pos-4) or\n      (tbent_offs < memaddr_base+ent_pos+po.expect_sect_align*0x20) and (tbent_offs >= memaddr_base+ent_pos+sizeof(eexidx))):\n        # We can assume the table is aligned; we don't know the size of the entry, but it is multiplication of 4\n        if ((tbent_offs % 4) != 0):\n            return False\n        # Try to read at that offset - it should start with function address (so-called personality routine)\n        fwpartfile.seek(tbent_offs-memaddr_base, os.SEEK_SET)\n        pers_routine_offs = c_uint(0)\n        if fwpartfile.readinto(pers_routine_offs) != sizeof(pers_routine_offs):\n            return False\n        if (pers_routine_offs.value <= memaddr_base) or (pers_routine_offs.value >= memaddr_base+arr_pos) or ((pers_routine_offs.value % func_align) != 0):\n            return False\n        if (po.verbose > 2):\n            print(\"{}: Matching '{:s}' entry at 0x{:08x}: 0x{:08x} 0x{:08x} [table entry offs 0x{:08x}]\"\n              .format(po.fwpartfile, sectname, ent_pos, glob_offs, eexidx.entry, tbent_offs))\n        return True\n    return False\n\n\ndef armfw_detect_sect_ARMexidx(po, fwpartfile, memaddr_base, start_pos, func_align, sect_align):\n    \"\"\" Finds position and size of .ARM.exidx section. That section contains entries\n        used for exception handling, and have a particular structure that is quite easy\n        to detect, with minimal amount of false positives.\n    \"\"\"\n    sectname = \".ARM.exidx\"\n    eexidx = ExIdxEntry()\n    match_count = 0\n    match_pos = -1\n    match_entries = 0\n    reached_eof = False\n    pos = start_pos\n    assert sect_align >= sizeof(ExIdxEntry), \"Section alignment exceeds .ARM.exidx entry size\"\n    while (True):\n        # Check how many correct exception entries we have\n        entry_count = 0\n        entry_pos = pos\n        while (True):\n            fwpartfile.seek(entry_pos, os.SEEK_SET)\n            if fwpartfile.readinto(eexidx) != sizeof(eexidx):\n                reached_eof = True\n                break\n            if not armfw_is_proper_ARMexidx_entry(po, fwpartfile, eexidx, memaddr_base, func_align, pos, entry_pos):\n                break\n            entry_count += 1\n            entry_pos += sizeof(eexidx)\n        # Do not allow entry at EOF\n        if (reached_eof):\n            break\n        # verify if padding area is completely filled with 0x00\n        if (entry_count > 0):\n            if ((entry_pos % sect_align) > 0):\n                fwpartfile.seek(entry_pos, os.SEEK_SET)\n                padding = fwpartfile.read(sect_align - (entry_pos % sect_align))\n                if (padding[0] != 0x00) or (len(set(padding)) > 1):\n                    entry_count = 0\n        # If entry is ok, consider it a match\n        if entry_count > 0:\n            if (po.verbose > 1):\n                print(\"{}: Matching '{:s}' section at 0x{:08x}: {:d} exception entries\".format(po.fwpartfile,sectname,pos,entry_count))\n            match_pos = pos\n            match_entries = entry_count\n            match_count += 1\n        # Set position to search for next entry\n        pos += sect_align\n    if (match_count > 1):\n        eprint(\"{}: Warning: multiple ({:d}) matches found for section '{:s}' with alignment 0x{:02x}\"\n          .format(po.fwpartfile,match_count,sectname,sect_align))\n    if (match_count < 1):\n        return -1, 0\n    return match_pos, match_entries * sizeof(ExIdxEntry)\n\n\ndef armfw_detect_empty_sect_ARMexidx(po, fwpartfile, memaddr_base, start_pos, func_align, sect_align):\n    \"\"\" Finds position of empty .ARM.exidx section. This is a last resort solution, when the\n        section appears not to exist. In that case, we will try to find a zero-filled block\n        which ends at an aligned offset; it is likely that the place where .text ends and .data starts\n        will look like this.\n    \"\"\"\n    match_count = 0\n    match_pos = -1\n    pos = start_pos\n    while (True):\n        fwpartfile.seek(pos, os.SEEK_SET)\n        buf = fwpartfile.read(sect_align)\n        if len(buf) != sect_align:\n            break\n        buf_set = set(buf)\n        if (0x00 in buf_set) and (len(buf_set) == 1):\n            match_pos = pos + sect_align\n            match_count += 1\n        elif (match_count > 0):\n            break\n        # Set position to search for next entry\n        pos += sect_align\n    if (match_count < 1):\n        return -1, 0\n    return match_pos, 0\n\n\ndef armfw_bin2elf_settle_sect_ARMexidx(po, fwpartfile):\n    \"\"\" Find ARM exceptions index section and set it within `po`.\n\n    It is easy to find, if it has any entries.\n    \"\"\"\n    sectname = \".ARM.exidx\"\n    sect_align = po.expect_sect_align\n    if (sectname not in po.section_addr):\n        sect_pos, sect_len = armfw_detect_sect_ARMexidx(po, fwpartfile,  po.baseaddr, 0, po.expect_func_align, sect_align)\n        if (sect_pos < 0):\n            sect_align = (po.expect_sect_align >> 1)\n            sect_pos, sect_len = armfw_detect_sect_ARMexidx(po, fwpartfile,  po.baseaddr, 0, po.expect_func_align, sect_align)\n        if (sect_pos < 0):\n            if (po.verbose > 1):\n                eprint(\"{}: Warning: Real '{:s}' section not found, looking for empty one; consider manually providing its address\"\n                  .format(po.fwpartfile,sectname))\n            sect_align = po.expect_sect_align\n            sect_pos, sect_len = armfw_detect_empty_sect_ARMexidx(po, fwpartfile,  po.baseaddr, 0, po.expect_func_align, sect_align)\n        if (sect_pos < 0):\n            raise EOFError(\"No matches found for section '{:s}' in binary file.\".format(sectname))\n        po.section_addr[sectname] = po.baseaddr + sect_pos\n    else:\n        sect_pos = po.section_addr[sectname] - po.baseaddr\n        sect_len = po.expect_sect_align\n    if (sectname not in po.section_size):\n        po.section_size[sectname] = sect_len\n    else:\n        sect_len = po.section_size[sectname]\n    # Now we have position and length of the .ARM.exidx section within `po`\n    if (po.verbose > 1):\n        print(\"{}: Set '{:s}' section at mem addr 0x{:08x}, size 0x{:08x}\"\n          .format(po.fwpartfile,sectname,po.section_addr[sectname],po.section_size[sectname]))\n\n\ndef armfw_bin2elf_settle_sect_text(po, fwpartfile):\n    \"\"\" Find ARM Target Executable section and set it within `po`.\n\n    Let's assume that the .ARM.exidx section is located after .text section. While the .text section\n    usually contains interrupt table located at offset 0, it doesn't mean it's first - we can't assume that.\n    This is because interrupt vector address can be changed on most platforms. So RAM or MMIO sections can be\n    before .text. Anyway, if user did not provided any .bss params, there is no way for us to automatically\n    find any sections before .text, and since most platforms don't have them, let's assume there are none.\n    \"\"\"\n    sectname = \".ARM.exidx\"\n    assert sectname in po.section_addr, \"Settling '{:s}' not possible without '{:s}' settled\".format(\".text\",sectname)\n    sect_pos = po.section_addr[sectname] - po.baseaddr\n    # Make sure we will not realign sections by mistake; we will update alignment in file later\n    sect_align = 1\n\n    sectname = \".text\"\n    if (sectname not in po.section_addr):\n        if (sect_pos > po.expect_func_align * 8):\n            po.section_addr[sectname] = po.baseaddr + 0x0\n        else:\n            raise EOFError(\"No place for '{:s}' section before the '{:s}' section in binary file.\"\n              .format(sectname,\".ARM.exidx\"))\n    if (sectname not in po.section_size):\n        po.section_size[sectname] = sect_pos - (po.section_addr[sectname] - po.baseaddr)\n    if (po.verbose > 1):\n        print(\"{}: Set '{:s}' section at mem addr 0x{:08x}, size 0x{:08x}\"\n          .format(po.fwpartfile,sectname,po.section_addr[sectname],po.section_size[sectname]))\n\n\ndef armfw_bin2elf_settle_sect_data(po, fwpartfile):\n    \"\"\" Find Data section and set it within `po`.\n\n    After the .ARM.exidx section come .data section.\n    \"\"\"\n    sectname = \".ARM.exidx\"\n    assert sectname in po.section_addr, \"Settling '{:s}' not possible without '{:s}' settled\".format(\".data\", sectname)\n    sect_pos = po.section_addr[sectname] - po.baseaddr\n    sect_len = po.section_size[sectname]\n    # Make sure we will not realign sections by mistake; we will update alignment in file later\n    sect_align = 1\n\n    sectname = \".data\"\n    if (sectname not in po.section_addr):\n        sect_pos += sect_len\n        if (sect_pos % sect_align) != 0:\n            sect_pos += sect_align - (sect_pos % sect_align)\n        po.section_addr[sectname] = po.baseaddr + sect_pos\n    else:\n        sect_pos = po.section_addr[sectname] - po.baseaddr\n    if (sectname not in po.section_size):\n        fwpartfile.seek(0, os.SEEK_END)\n        sect_len = fwpartfile.tell() - sect_pos\n        po.section_size[sectname] = sect_len\n    else:\n        sect_len = po.section_size[sectname]\n    if (po.verbose > 1):\n        print(\"{}: Set '{:s}' section at mem addr 0x{:08x}, size 0x{:08x}\"\n          .format(po.fwpartfile,sectname,po.section_addr[sectname],po.section_size[sectname]))\n\n\ndef armfw_bin2elf_settle_sect_bss(po, fwpartfile):\n    \"\"\" Find Block Starting Symbol sections and set it within `po`.\n\n    This section stores statically allocated variables that are declared\n    but have not been assigned a value - so its content is not stored.\n    We can use it for defining any hardware-mapped areas as well.\n    Set position for .bss to the place where it should be\n    if it had the content stored. Allow multiple such sections.\n    \"\"\"\n    sectname = \".data\"\n    assert sectname in po.section_addr, \"Settling '{:s}' not possible without '{:s}' settled\".format(\".bss\", sectname)\n    sect_pos = po.section_addr[sectname] - po.baseaddr\n    sect_len = po.section_size[sectname]\n    sect_align = 1\n\n    if True:\n        sectname = \".bss\"\n        if (sectname not in po.section_addr):\n            sect_pos += sect_len\n            if (sect_pos % sect_align) != 0:\n                sect_pos += sect_align - (sect_pos % sect_align)\n            po.section_addr[sectname] = po.baseaddr + sect_pos\n        else:\n            sect_pos = po.section_addr[sectname] - po.baseaddr\n        if (sectname not in po.section_size):\n            sect_len = po.addrspacelen - sect_pos\n            if (sect_len < 0): sect_len = 0\n            po.section_size[sectname] = sect_len\n        else:\n            sect_len = po.section_size[sectname]\n        if (po.verbose > 1):\n            print(\"{}: Set '{:s}' section at mem addr 0x{:08x}, size 0x{:08x}\"\n              .format(po.fwpartfile,sectname,po.section_addr[sectname],po.section_size[sectname]))\n    # Allow more .bss sections, as long as size is provided\n    for sectname in po.section_size.keys():\n        if not re.search('^[.]bss[0-9]+$', sectname):\n            continue\n        if (sectname not in po.section_size):\n            break\n        if (sectname not in po.section_addr):\n            sect_pos += sect_len\n            if (sect_pos % sect_align) != 0:\n                sect_pos += sect_align - (sect_pos % sect_align)\n            po.section_addr[sectname] = po.baseaddr + sect_pos\n        else:\n            sect_pos = po.section_addr[sectname] - po.baseaddr\n        sect_len = po.section_size[sectname]\n        if (po.verbose > 1):\n            print(\"{}: Set '{:s}' section at mem addr 0x{:08x}, size 0x{:08x}\"\n              .format(po.fwpartfile,sectname,po.section_addr[sectname],po.section_size[sectname]))\n\n\ndef armfw_bin2elf_get_sections_order(po, addrspace_limit):\n    \"\"\" Prepare list of sections in the order of position.\n    \"\"\"\n    sections_order = []\n    for sortaddr in sorted(set(po.section_addr.values())):\n       if (sortaddr > addrspace_limit):\n           eprint(\"{}: Warning: sections placed beyond address space limit, like at 0x{:x}, were not created\"\n             .format(po.fwpartfile,sortaddr))\n           break\n       # First add sections with size equal zero\n       for sectname, addr in po.section_addr.items():\n           if addr == sortaddr:\n               if sectname in po.section_size.keys():\n                   if (po.section_size[sectname] < 1):\n                       sections_order.append(sectname)\n       # The non-zero sized section should be last\n       for sectname, addr in po.section_addr.items():\n           if addr == sortaddr:\n               if sectname not in sections_order:\n                   sections_order.append(sectname)\n    return sections_order\n\n\ndef armfw_bin2elf_copy_template(po):\n    \"\"\" Copy an ELF template to destination file name.\n    \"\"\"\n    #TODO this is old, non-pythonic code; use shutil instead?\n    elf_templt = open(po.tmpltfile, \"rb\")\n    if not po.dry_run:\n        elf_fh = open(po.elffile, \"wb\")\n    n = 0\n    while (1):\n        copy_buffer = elf_templt.read(1024 * 1024)\n        if not copy_buffer:\n            break\n        n += len(copy_buffer)\n        if not po.dry_run:\n            elf_fh.write(copy_buffer)\n    elf_templt.close()\n    if not po.dry_run:\n        elf_fh.close()\n    if (po.verbose > 1):\n        print(\"{}: ELF template '{:s}' copied to '{:s}', {:d} bytes\"\n          .format(po.fwpartfile, po.tmpltfile, po.elffile, n))\n\n\ndef armfw_bin2elf_get_sections_align(po, sections_order):\n    \"\"\" Figure out alignment of sections.\n\n    Needs to be called after addresses and sizes of sections are settled.\n    \"\"\"\n    # Keep it near expected alignment, but adjust if the size does not meet expectations\n    sections_align = {}\n    for sectname in sections_order:\n        sect_align = (po.expect_sect_align << 1)\n        while (po.section_addr[sectname] % sect_align) != 0: sect_align = (sect_align >> 1)\n        while (po.section_size[sectname] % sect_align) != 0: sect_align = (sect_align >> 1)\n        sections_align[sectname] = sect_align\n        if (po.verbose > 0):\n            print(\"{}: Section '{:s}' alignment set to 0x{:02x}\".format(po.fwpartfile, sectname, sections_align[sectname]))\n    return sections_align\n\n\ndef armfw_bin2elf_get_sections_pos(po, sections_order):\n    \"\"\" Prepare array of file positions.\n\n    We have an array of target memory addresses; make them into an array of file offsets. Since BIN\n    is a linear mem dump, addresses are the same as file offsets, only shifted by baseaddr.\n    \"\"\"\n    sections_pos = {}\n    for sectname in sections_order:\n        sect_pos = po.section_addr[sectname] - po.baseaddr\n        if (sect_pos < 0): sect_pos = 0\n        sections_pos[sectname] = sect_pos\n        if (po.verbose > 0):\n            print(\"{}: Section '{:s}' file position set to 0x{:08x}\"\n              .format(po.fwpartfile, sectname, sections_pos[sectname]))\n    return sections_pos\n\n\ndef armfw_bin2elf_update_sect_sizes(po, sections_order, addrspace_limit):\n    \"\"\" Prepare list of section sizes.\n    \"\"\"\n    sectaddr_next = po.baseaddr + po.addrspacelen + 1 # max size is larger than bin file size due to uninitialized sections (bss)\n    for sectname in reversed(sections_order):\n        sectpos_delta = sectaddr_next - po.section_addr[sectname]\n        # Distance between sorted sections cannot be negative\n        if sectname == sections_order[-1]:\n            assert sectpos_delta >= 0, \"Address space length too small to fit section '{:s}'\".format(sectname)\n        else:\n            assert sectpos_delta >= 0, \"Trusting addresses leads to negative distance after '{:s}'\".format(sectname)\n        # Do not allow to exceed limit imposed by address space bit length\n        if (po.section_addr[sectname] + sectpos_delta > addrspace_limit + 1 - po.expect_sect_align):\n            sectpos_delta = addrspace_limit + 1 - po.expect_sect_align - po.section_addr[sectname]\n        assert sectpos_delta >= 0, \"Trusting address limits leads to negative distance after '{:s}'\".format(sectname)\n        if sectname in po.section_size.keys():\n            if (po.section_size[sectname] > sectpos_delta):\n                eprint(\"{}: Warning: section '{:s}' size reduced to 0x{:x} due to overlapping\"\n                  .format(po.fwpartfile, sectname, sectpos_delta))\n                po.section_size[sectname] = sectpos_delta\n        else:\n            po.section_size[sectname] = sectpos_delta\n        sectaddr_next = po.section_addr[sectname]\n\n\ndef armfw_bin2elf_update_elffile(po, elf_fh, fwpartfile, sections_order, sections_pos, sections_align):\n    \"\"\" Update the opened ELF template into a proper final ELF file.\n    \"\"\"\n    # Update entry point in the ELF header\n    elfobj = elftools.elf.elffile.ELFFile(elf_fh)\n    elfobj.header['e_entry'] = po.baseaddr\n    # Update section sizes, including the uninitialized (.bss*) sections\n    for sectname in sections_order:\n        # This function always returns a copy of section object, or newly created section object; so no need to copy it again\n        sect = elfobj.get_section_by_name(sectname)\n        # If no such section found, maybe we've added number at end\n        sectname_m = None\n        if sect is None:\n            sectname_m = re.search('^(?P<name>[.].*[^0-9])(?P<num>[0-9]+)$', sectname)\n            if sectname_m.group('name') is not None:\n                sect = elfobj.get_section_by_name(sectname_m.group('name'))\n            if sect is not None:\n                sect.name = sectname\n                sectname_prev = '{:s}{:d}'.format(sectname_m.group('name'), int(sectname_m.group('num'), 10) - 1)\n                if elfobj.get_section_by_name(sectname_prev) is None:\n                    sectname_prev = sectname_m.group('name')\n                elfobj.insert_section_after(sectname_prev, sect)\n        if sect is None:\n            raise EOFError(\"Could not read section '{:s}' from binary file.\".format(sectname))\n        if (po.verbose > 0):\n            print(\"{}: Preparing ELF section '{:s}' from binary pos 0x{:08x}\"\n              .format(po.fwpartfile, sectname, sections_pos[sectname]))\n        sect.header['sh_addr'] = po.section_addr[sectname]\n        sect.header['sh_addralign'] = sections_align[sectname]\n        # for non-bss sections, size will be updated automatically when replacing data\n        if sect.header['sh_type'] == 'SHT_NOBITS':\n            sect.header['sh_size'] = po.section_size[sectname]\n        elif po.section_size[sectname] <= 0:\n            sect.set_data(b'')\n        else:\n            fwpartfile.seek(sections_pos[sectname], os.SEEK_SET)\n            data_buf = fwpartfile.read(po.section_size[sectname])\n            if not data_buf:\n                raise EOFError(\"Couldn't read section '{:s}' from binary file.\".format(sectname))\n            sect.set_data(data_buf)\n        if (po.verbose > 2):\n            print(\"{}: Updating section '{:s}' and shifting subsequent sections\".format(po.fwpartfile, sectname))\n        elfobj.set_section_by_name(sectname, sect)\n    if (po.verbose > 1):\n        print(\"{}: Writing changes to '{:s}'\".format(po.fwpartfile,po.elffile))\n    if not po.dry_run:\n        elfobj.write_changes()\n\n\ndef armfw_bin2elf(po, fwpartfile):\n    if (po.verbose > 0):\n        print(\"{}: Memory base address set to 0x{:08x}\".format(po.fwpartfile,po.baseaddr))\n    # detect position of each section in the binary file\n    if (po.verbose > 1):\n        print(\"{}: Searching for sections\".format(po.fwpartfile))\n    # currently we only support 32-bit arm; we'd need to read e_machine from template\n    # and check if it's EM_AARCH64 in order to support the 64-bit spaces\n    is_arm64 = False\n    # set addresses and sizes of sections within `po`\n    armfw_bin2elf_settle_sect_ARMexidx(po, fwpartfile)\n    armfw_bin2elf_settle_sect_text(po, fwpartfile)\n    armfw_bin2elf_settle_sect_data(po, fwpartfile)\n    armfw_bin2elf_settle_sect_bss(po, fwpartfile)\n\n    if is_arm64:\n        addrspace_limit = 2**64 - 1\n    else:\n        addrspace_limit = 2**32 - 1\n\n    sections_order = armfw_bin2elf_get_sections_order(po, addrspace_limit)\n    armfw_bin2elf_update_sect_sizes(po, sections_order, addrspace_limit)\n\n    sections_align = armfw_bin2elf_get_sections_align(po, sections_order)\n    sections_pos = armfw_bin2elf_get_sections_pos(po, sections_order)\n\n    # Create the ELF file from template\n    armfw_bin2elf_copy_template(po)\n    if (po.verbose > 0):\n        print(\"{}: Updating entry point and section headers\".format(po.fwpartfile))\n    if not po.dry_run:\n        elf_fh = open(po.elffile, 'r+b')\n    else:\n        elf_fh = open(po.tmpltfile, 'rb')\n    armfw_bin2elf_update_elffile(po, elf_fh, fwpartfile, sections_order, sections_pos, sections_align)\n    elf_fh.close()\n\n\ndef parse_section_param(s):\n    \"\"\" Parses the section parameter argument.\n    \"\"\"\n    sect = {'addr': {}, 'len': {},}\n    arg_m = re.search('(?P<name>[0-9A-Za-z._-]+)(@(?P<addr>[Xx0-9A-Fa-f]+))?(:(?P<len>[Xx0-9A-Fa-f]+))?', s)\n    # Convert to integer, detect base from prefix\n    if arg_m.group('addr') is not None:\n        sect['addr'][arg_m.group('name')] = int(arg_m.group('addr'), 0)\n    if arg_m.group('len') is not None:\n        sect['len'][arg_m.group('name')] = int(arg_m.group('len'), 0)\n    return sect\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-p', '--fwpartfile', type=str, required=True,\n          help=\"executable ARM firmware binary module file\")\n\n    parser.add_argument('-o', '--elffile', type=str,\n          help=(\"directory and file name of output ELF file \"\n           \"(default is base name of fwpartfile with extension switched to elf, in working dir)\"))\n\n    parser.add_argument('-t', '--tmpltfile', type=str, default=\"arm_bin2elf_template.elf\",\n          help=\"template ELF file to use header fields from (default is \\\"%(default)s\\\")\")\n\n    parser.add_argument('-l', '--addrspacelen', default=0x2000000, type=lambda x: int(x,0),\n          help=(\"set address space length after base; the tool will expect used \"\n            \"addresses to end at baseaddr+addrspacelen, so it influences size \"\n            \"of last section (defaults to max of 0x%(default)X and section ends computed \"\n            \"from '--section' params)\"))\n\n    parser.add_argument('-b', '--baseaddr', default=0x1000000, type=lambda x: int(x,0),\n          help=(\"set base address; first section from BIN file will start \"\n                 \"at this memory location (defaults to 0x%(default)X)\"))\n\n    parser.add_argument('-s', '--section', action='append', metavar='SECT@ADDR:LEN', type=parse_section_param,\n          help=(\"set section position and/or length; can be used to override \"\n           \"detection of sections; setting section .ARM.exidx will influence \"\n           \".text and .data, moving them and sizing to fit one before and one \"\n           \"after the .ARM.exidx. Parameters are: \"\n           \"SECT - a text name of the section, as defined in elf template; multiple sections \"\n           \"can be cloned from the same template section by adding index at end (ie. .bss2); \"\n           \"ADDR - is an address of the section within memory (not input file position); \"\n           \"LEN - is the length of the section (in both input file and memory, unless its \"\n           \"uninitialized section, in which case it is memory size as file size is 0)\"))\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-e', '--mkelf', action='store_true',\n          help=\"make ELF file from a binary image\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.expect_func_align = 2\n    po.expect_sect_align = 0x10\n    # For some reason, if no \"--section\" parameters are present, argparse leaves this unset\n    if po.section is None:\n        po.section = []\n    # Flatten the sections we got in arguments\n    po.section_addr = {}\n    po.section_size = {}\n    for sect in po.section:\n        po.section_addr.update(sect['addr'])\n        po.section_size.update(sect['len'])\n    # Getting end of last section, to update address space length if it is too small\n    if len(po.section_addr) > 0:\n        sect_last = max(po.section_addr, key=po.section_addr.get)\n        last_section_end = po.section_addr[sect_last] + po.section_size[sect_last] - po.baseaddr\n        if (last_section_end > po.addrspacelen):\n            po.addrspacelen = min(last_section_end, 0xFFFFFFFF)\n            if (po.verbose > 0):\n                print(\"{}: Address space length auto-expanded to 0x{:08X}\".format(po.fwpartfile, po.addrspacelen))\n\n    po.basename = os.path.splitext(os.path.basename(po.fwpartfile))[0]\n    if len(po.fwpartfile) > 0 and (po.elffile is None or len(po.elffile) == 0):\n        po.elffile = po.basename + \".elf\"\n\n    if po.mkelf:\n        if (po.verbose > 0):\n            print(\"{}: Opening for conversion to ELF\".format(po.fwpartfile))\n        with open(po.fwpartfile, 'rb') as fwpartfile:\n            armfw_bin2elf(po, fwpartfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "arm_bin2elf_template.elf",
          "type": "blob",
          "size": 5.01953125,
          "content": null
        },
        {
          "name": "comm_dat2pcap.py",
          "type": "blob",
          "size": 17.9990234375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Raw DUPC packets to PCap converter.\n\nThis tool parses Dji Unified Packet Container packets from input file,\nand puts the results into PCap file. Checksums within the packets are checked\nand only valid packets are accepted.\n\nThe script can also behave as a library to use the parser for other tasks.\n\nPCap files can be used with WireShark and other tools for packets analysis.\n\"\"\"\n\n# Copyright (C) 2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.2.1\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport errno\nimport os\nimport enum\nimport struct\nimport time\nimport datetime\nimport binascii\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass StateId(enum.Enum):\n    NO_PACKET = 0\n    IN_HEAD = 1\n    IN_BODY = 2\n    IN_TRAIL = 3\n    READY = 4\n    DAMAGED = 5  # No longer used - packet is damaged when done_packet is set\n    FINISH = 6\n\n\nclass PktInfo:\n    count_ok = 0\n    count_bad = 0\n    bytes_ok = 0\n    bytes_bad = 0\n\n\nclass PktState:\n    id = StateId.NO_PACKET\n    packet = bytearray()\n    done_packet = None\n    verbose = 0\n    pname = \"2pcap\"\n\n\ndef calc_pkt55_checksum(packet, plength):\n    crc = [\n      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,\n      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,\n      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,\n      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,\n      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,\n      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,\n      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,\n      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,\n      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,\n      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,\n      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,\n      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,\n      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,\n      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,\n      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,\n      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,\n      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,\n      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,\n      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,\n      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,\n      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,\n      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,\n      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,\n      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,\n      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,\n      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,\n      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,\n      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,\n      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,\n      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,\n      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,\n      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78,\n    ]\n\n    # Seeds\n    #v = 0x1012 # Naza M\n    #v = 0x1013 # Phantom 2\n    #v = 0x7000 # Naza M V2\n    v = 0x3692 # P3/P4/Mavic\n\n    for i in range(0, plength):\n        vv = v >> 8\n        v = vv ^ crc[((packet[i] ^ v) & 0xFF)]\n    return v\n\n\ndef calc_pkt55_hdr_checksum(seed, packet, plength):\n    arr_2A103 = [\n      0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83, 0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41,\n      0x9D, 0xC3, 0x21, 0x7F, 0xFC, 0xA2, 0x40, 0x1E, 0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC,\n      0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C, 0xFE, 0xA0, 0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62,\n      0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D, 0x7C, 0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF,\n      0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5, 0x84, 0xDA, 0x38, 0x66, 0xE5, 0xBB, 0x59, 0x07,\n      0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58, 0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4, 0x9A,\n      0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6, 0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24,\n      0xF8, 0xA6, 0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B, 0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9,\n      0x8C, 0xD2, 0x30, 0x6E, 0xED, 0xB3, 0x51, 0x0F, 0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD,\n      0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92, 0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50,\n      0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C, 0x6D, 0x33, 0xD1, 0x8F, 0x0C, 0x52, 0xB0, 0xEE,\n      0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1, 0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF, 0x2D, 0x73,\n      0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49, 0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B,\n      0x57, 0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4, 0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16,\n      0xE9, 0xB7, 0x55, 0x0B, 0x88, 0xD6, 0x34, 0x6A, 0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8,\n      0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9, 0xF7, 0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35,\n    ]\n\n    chksum = seed\n    for i in range(0, plength):\n        chksum = arr_2A103[((packet[i] ^ chksum) & 0xFF)]\n    return chksum\n\n\ndef calc_pktAB_checksum(cnst, packet, length):\n\n    result = packet[0]\n\n    for byte_ctr in range(1,(length )):\n        byte = packet[byte_ctr]\n        for bit_ctr in range(0, 8):\n            msb = result & 0x80\n            result = ((result << 1) | (byte >> 7)) & 0xFF\n            if msb == 0x80:\n                result = result ^ cnst\n            byte = (byte << 1) & 0xFF\n\n    for bit_ctr in range(0, 8):\n        msb = result & 0x80\n        result = (result << 1) & 0xFF\n        if msb == 0x80:\n            result = result ^ cnst\n    return result\n\n\nclass Formatter:\n    def __init__(self, out):\n        self.out = out\n\n    def fileno(self):\n        return self.out.fileno()\n\n    def close(self):\n        self.out.close()\n\n\nclass PcapFormatter(Formatter):\n    def __init__(self, out):\n        Formatter.__init__(self, out)\n        self.userdlt = 0\n\n    def write_header(self):\n        self.out.write(struct.pack(\"=IHHiIII\",\n            0xa1b2c3d4,   # magic number\n            2,            # major version number\n            4,            # minor version number\n            0,            # GMT to local correction\n            0,            # accuracy of timestamps\n            65535,        # max length of captured packets, in octets\n            147+self.userdlt, # data link type (DLT) - USER_0\n        ))\n        self.out.flush()\n\n    def write_packet(self, data, dtime=None):\n        if dtime is None:\n            dtime = datetime.datetime.now()\n        timestamp = int(time.mktime(dtime.timetuple()))\n        self.out.write(struct.pack(\"=IIII\",\n            timestamp,        # timestamp seconds\n            dtime.microsecond, # timestamp microseconds\n            len(data),        # number of octets of packet saved in file\n            len(data),        # actual length of packet\n        ))\n        self.out.write(data)\n        self.out.flush()\n\n\nclass HumanFormatter(Formatter):\n    def write_header(self):\n        pass\n\n    def write_packet(self, data, dtime=None):\n        self.out.write(binascii.hexlify(data).decode())\n        self.out.write(\"\\n\")\n        self.out.flush()\n\n\ndef is_packet_ready(state):\n    \"\"\" Returns whether a packet within the state is ready for storing.\n    \"\"\"\n    return (state.id == StateId.READY) and (len(state.packet) > 0)\n\n\ndef is_packet_damaged(state):\n    \"\"\" Returns whether a packet within the state is ready but damaged.\n    \"\"\"\n    return (state.done_packet is not None)\n\n\ndef is_packet_at_finish(state):\n    \"\"\" Returns whether the state informs processing should finish.\n    \"\"\"\n    return (state.id == StateId.FINISH)\n\n\ndef store_packet(out, state):\n    \"\"\" Write packet from given state into given output stream.\n\n        This function can be called when packet stored within the state\n        is ready. The packet is written to stream and removed from the state.\n    \"\"\"\n    if state.done_packet is None:\n        state.done_packet = state.packet\n        state.id = StateId.NO_PACKET\n        state.packet = bytearray()\n    try:\n        out.write_packet(state.done_packet)\n    except OSError as e:\n        # SIGPIPE indicates the fifo was closed\n        if e.errno == errno.SIGPIPE:\n            state.id = StateId.FINISH\n    state.done_packet = None\n    return state\n\n\ndef drop_packet(state):\n    \"\"\" Drop packet from given state without storing it.\n\n        This function can be called when packet stored within the state\n        should be removed.\n    \"\"\"\n    if state.done_packet is None:\n        state.id = StateId.NO_PACKET\n        state.packet = bytearray()\n    else:\n        state.done_packet = None\n    return state\n\n\ndef do_packetise_byte(byte, state, info):\n  \"\"\" Add byte to the packetize effort represented by state\n\n    The function adds byte to the packet contained within state,\n    or drops the byte if applicable. The processing of a new byte\n    is also reflected in statistics.\n\n    If state.id changes to READY or DAMAGED, the function expects caller\n    to remove existing packet before the next call.\n  \"\"\"\n\n  if state.id == StateId.NO_PACKET:\t# expect ideftifier - 55 or AB\n      if byte == 0x55 or byte == 0xAB:\n          if len(state.packet) > 0:\n              info.count_bad += 1\n              info.bytes_bad += len(state.packet)\n              if (state.verbose > 1):\n                  print(\"{}: Packet type {:02X} damaged - no data recognized; {} bytes\"\n                    .format(state.pname, state.packet[0], len(state.packet)))\n              state.done_packet = state.packet\n          state.packet = bytearray()\n          state.packet.append(byte)\n          state.id = StateId.IN_HEAD\n      else:\n          state.packet.append(byte)\n          # Make sure we do not gather too much rubbish\n          if len(state.packet) > 0x3ff:\n              info.count_bad += 1\n              info.bytes_bad += len(state.packet)\n              if (state.verbose > 1):\n                  print(\"{}: Packet type {:02X} damaged - no data recognized; {} bytes\"\n                    .format(state.pname, state.packet[0], len(state.packet)))\n              state.done_packet = state.packet\n              state.packet = bytearray()\n\n  elif state.id == StateId.IN_HEAD:\n      state.packet.append(byte)\n      # If got whole header for given packet type, switch to reading body\n      if state.packet[0] == 0x55 and len(state.packet) == 4:\n          # type 55 packet header has its own checksum\n          hdr_ccrc = calc_pkt55_hdr_checksum(0x77, state.packet, 3)\n          hdr_crc_pkt = struct.unpack(\"B\", state.packet[3:4])[0]\n          if hdr_ccrc == hdr_crc_pkt:\n              state.id = StateId.IN_BODY\n          else:\n              if (state.verbose > 1):\n                  print(\"{}: Packet type {:02X} skipped - bad head crc; {} bytes\"\n                    .format(state.pname, state.packet[0], len(state.packet)))\n              # stats will be updated later, just change state\n              state.id = StateId.NO_PACKET\n      elif state.packet[0] == 0xAB and len(state.packet) == 4:\n          state.id = StateId.IN_BODY\n\n  elif state.id == StateId.IN_BODY:\n      state.packet.append(byte)\n      # for packet type 0x55, 2 bits of size are in packet[2]\n      if state.packet[0] == 0x55:\n          len_pkt = struct.unpack(\"<H\", state.packet[1:3])[0] & 0x3ff\n      else:\n          len_pkt = state.packet[1]\n      if len(state.packet) == len_pkt-1:\n          state.id = StateId.IN_TRAIL\n      elif (len(state.packet) >= len_pkt):\n          if (state.verbose > 1):\n              print(\"{}: Packet type {:02X} skipped - shorter than header; {} bytes\"\n                .format(state.pname, state.packet[0], len(state.packet)))\n          state.id = StateId.NO_PACKET\n\n  elif state.id == StateId.IN_TRAIL:\n      state.packet.append(byte)\n      if state.packet[0] == 0x55:\n          ccrc = calc_pkt55_checksum(state.packet, len(state.packet) - 2)\n          crc_pkt = struct.unpack(\"<H\", state.packet[-2:])[0]\n          if ccrc == crc_pkt:\n              info.count_ok += 1\n              info.bytes_ok += len(state.packet)\n              state.id = StateId.READY\n          else:\n              info.count_bad += 1\n              info.bytes_bad += len(state.packet)\n              if (state.verbose > 1):\n                  print(\"{}: Packet type {:02X} damaged - bad crc; {} bytes\"\n                    .format(state.pname, state.packet[0], len(state.packet)))\n              state.done_packet = state.packet\n              state.packet = bytearray()\n              state.id = StateId.NO_PACKET\n      elif state.packet[0] == 0xAB:\n          ccrc = calc_pktAB_checksum(7, state.packet, len(state.packet) - 1)\n          crc_pkt = struct.unpack(\"B\", state.packet[-1:])[0]\n          if ccrc == crc_pkt:\n              info.count_ok += 1\n              info.bytes_ok += len(state.packet)\n              state.id = StateId.READY\n          else:\n              info.count_bad += 1\n              info.bytes_bad += len(state.packet)\n              if (state.verbose > 1):\n                  print(\"{}: Packet type {:02X} damaged - bad crc; {} bytes\"\n                    .format(state.pname, state.packet[0], len(state.packet)))\n              state.done_packet = state.packet\n              state.packet = bytearray()\n              state.id = StateId.NO_PACKET\n\n  else:\n      print(\"{}: Invalid packetise state {}\".format(state.pname,state.id))\n      state.id = StateId.FINISH\n\n  return state, info\n\n\ndef do_dat2pcap(po, datfile, pcapfile):\n    \"\"\" Reads raw packets from datfile and writes them into pcapfile with proper headers.\n    \"\"\"\n    # This might block until the other side of the fifo is opened\n    out = PcapFormatter(pcapfile)\n    out.userdlt = po.userdlt\n    out.write_header()\n\n    if (po.verbose > 1):\n        print(\"{}: Copying packets into {} ...\".format(po.datfile,po.pcapfile))\n\n    info = PktInfo()\n    state = PktState()\n    state.verbose = po.verbose\n    state.pname = po.datfile\n    count = 0\n\n    while True:\n        # The read() function in Python is ridiculously slow; instead of using it\n        # many times to read one byte, let's call it once for considerable buffer\n        btarr = datfile.read(4096)\n        if len(btarr) < 1: # eof\n            break\n        for bt in btarr:\n            count += 1\n            state, info = do_packetise_byte(bt, state, info)\n            if (is_packet_ready(state)):\n                state = store_packet(out, state)\n            elif (is_packet_damaged(state)):\n                if (po.storebad):\n                    state = store_packet(out, state)\n                else:\n                    state = drop_packet(state)\n        if (is_packet_at_finish(state)):\n            break\n        if (po.verbose > 2) and (count & 0xffff) == 0:\n            print(\"{}: Packets encountered: {:d} valid ({:d}b), {:d} damaged ({:d}b)\"\n              .format(state.pname, info.count_ok, info.bytes_ok, info.count_bad, info.bytes_bad))\n\n    if (po.verbose > 0):\n        print(\"{}: Packets encountered: {:d} valid ({:d}b), {:d} damaged ({:d}b)\"\n          .format(state.pname, info.count_ok, info.bytes_ok, info.count_bad, info.bytes_bad))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-p', '--pcapfile', default=\"\", type=str,\n          help=\"output to pcap file of given name\")\n\n    parser.add_argument('-u', '--userdlt', default=0, type=int,\n          help=(\"sets specific data link type of the DLT_USER protocol \"\n            \"(default is %(default)d; change it for complex wireshark configs)\"))\n\n    parser.add_argument('-e', '--storebad', action='store_true',\n          help=\"enables storing bad packets (ie. with bad checksums)\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    parser.add_argument('-d', '--datfile', default=\"\", type=str, required=True,\n          help=\"input from dat file (Raw DUPC/DUML) of given name\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    if po.userdlt > 15:\n        raise ValueError(\"There are only 15 DLT_USER slots.\")\n\n    po.command = ''\n    if len(po.datfile) > 0:\n        po.command = 'd'\n\n    po.basename = os.path.splitext(os.path.basename(po.datfile))[0]\n    if len(po.datfile) > 0 and len(po.pcapfile) == 0:\n        po.pcapfile = po.basename + \".pcap\"\n\n    if (po.command == 'd'):\n        if (po.verbose > 0):\n            print(\"{}: Opening Raw DUPC/DUML for conversion to PCap\".format(po.datfile))\n        with open(po.datfile, 'rb') as datfile:\n            with open(po.pcapfile, 'wb') as pcapfile:\n                do_dat2pcap(po, datfile, pcapfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "comm_dissector",
          "type": "tree",
          "content": null
        },
        {
          "name": "comm_mkdupc.py",
          "type": "blob",
          "size": 38.5634765625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DUPC Packet Builder.\n\n This script takes header fields and payload, and builds a proper DUPC\n packet from them.\n\n\"\"\"\n\n# Copyright (C) 2018 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.5.0\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport enum\nimport re\nfrom ctypes import c_char, c_int, c_ubyte, c_ushort, c_uint, c_float\nfrom ctypes import sizeof, addressof, byref, memmove, Array, LittleEndianStructure\nfrom collections import OrderedDict\n\nsys.path.insert(0, './')\nfrom comm_dat2pcap import (\n  calc_pkt55_hdr_checksum, calc_pkt55_checksum,\n  eprint,\n)\n\n\nclass DecoratedEnum(enum.Enum):\n    @classmethod\n    def from_name(cls, name):\n        for itm in cls:\n            if itm.name == name:\n                return itm\n        raise ValueError('{} is not a known value'.format(name))\n\n\nclass ACK_TYPE(DecoratedEnum):\n    NO_ACK_NEEDED = 0\n    ACK_BEFORE_EXEC = 1\n    ACK_AFTER_EXEC = 2\n\n\nclass COMM_DEV_TYPE(DecoratedEnum):\n    ANY = 0\n    CAMERA = 1\n    MOBILE_APP = 2\n    FLYCONTROLLER = 3\n    GIMBAL = 4\n    CENTER_BOARD = 5\n    REMOTE_RADIO = 6\n    WIFI = 7\n    LB_DM3XX_SKY = 8\n    LB_MCU_SKY = 9\n    PC = 10\n    BATTERY = 11\n    ESC = 12\n    DM368_GROUND = 13\n    OFDM_GROUND = 14\n    LB_68013_SKY = 15\n    SER_68013_GROUND = 16\n    MVO = 17\n    SVO = 18\n    LB_FPGA_SKY = 19\n    FPGA_GROUND = 20\n    FPGA_SIM = 21\n    STATION = 22\n    XU = 23\n    WTF = 24\n    IMU = 25\n    GPS = 26\n    WIFI_GROUND = 27\n    SIG_CVT = 28\n    PMU = 29\n    UNKNOWN30 = 30\n    WM330_OR_WM220 = 31\n\n\nclass ENCRYPT_TYPE(DecoratedEnum):\n    NO_ENC = 0\n    AES_128 = 1\n    SELF_DEF = 2\n    XOR = 3\n    DES_56 = 4\n    DES_112 = 5\n    AES_192 = 6\n    AES_256 = 7\n\n\nclass PACKET_TYPE(DecoratedEnum):\n    REQUEST = 0\n    RESPONSE = 1\n\n\nclass CMD_SET_TYPE(DecoratedEnum):\n    GENERAL = 0\n    SPECIAL = 1\n    CAMERA = 2\n    FLYCONTROLLER = 3\n    ZENMUSE = 4\n    CENTER_BOARD = 5\n    RADIO = 6\n    WIFI = 7\n    DM368 = 8\n    OFDM = 9\n    VO = 10\n    SIM = 11\n    ESC = 12\n    BATTERY = 13\n    DATA_RECORDER = 14\n    RTK = 15\n    AUTOTEST = 16\n    UNKNOWN17 = 17\n    UNKNOWN18 = 18\n    UNKNOWN19 = 19\n    UNKNOWN20 = 20\n    UNKNOWN21 = 21\n    UNKNOWN22 = 22\n    UNKNOWN23 = 23\n    UNKNOWN24 = 24\n    UNKNOWN25 = 25\n    UNKNOWN26 = 26\n    UNKNOWN27 = 27\n    UNKNOWN28 = 28\n    UNKNOWN29 = 29\n    UNKNOWN30 = 30\n    UNKNOWN31 = 31\n\n\nclass PacketProperties:\n    def __init__(self):\n        self.sender_type = COMM_DEV_TYPE.ANY\n        self.sender_index = 0\n        self.receiver_type = COMM_DEV_TYPE.ANY\n        self.receiver_index = 0\n        self.seq_num = 0\n        self.pack_type = PACKET_TYPE.REQUEST\n        self.ack_type = ACK_TYPE.NO_ACK_NEEDED\n        self.encrypt_type = ENCRYPT_TYPE.NO_ENC\n        self.cmd_set = CMD_SET_TYPE.GENERAL\n        self.cmd_id = 0\n        self.payload = bytes()\n\n\nclass DJICmdV1Header(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('sof', c_ubyte), # Start Of Field\n        ('ver_length_tag', c_ushort), # Protocol version and packet length\n        ('header_crc8', c_ubyte), # Checksum of preceding bytes\n        ('sender_info', c_ubyte), # Sender module identificator\n        ('receiver_info', c_ubyte), # Receiver module identificator\n        ('seq_num', c_ushort), # Sequence number of this command id\n        ('cmd_type_data', c_ubyte), # Packet type, required acknowledgement, encryption\n        ('cmd_set', c_ubyte), # Command Set selection\n        ('cmd_id', c_ubyte), # Specific command selection\n  ]\n\n  def __init__(self):\n    self.sof = 0x55\n    self.version = 1\n    self.whole_length = sizeof(self) + 2\n\n  def dict_export(self):\n    d = OrderedDict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    return d\n\n  def __repr__(self):\n    d = self.dict_export()\n    from pprint import pformat\n    return pformat(d, indent=0, width=160)\n\n  def __get_whole_length(self):\n        return self.ver_length_tag & 1023\n\n  def __set_whole_length(self, value):\n        self.ver_length_tag = (self.ver_length_tag & 64512) | (value & 1023)\n\n  whole_length = property(__get_whole_length, __set_whole_length)\n\n  def __get_version(self):\n        return (self.ver_length_tag & 64512) >> 10\n\n  def __set_version(self, value):\n        self.ver_length_tag = (self.ver_length_tag & 1023) | ((value & 63)  << 10)\n\n  version = property(__get_version, __set_version)\n\n  def __get_sender_type(self):\n        return self.sender_info & 31\n\n  def __set_sender_type(self, value):\n        self.sender_info = (self.sender_info & 224) | (value & 31)\n\n  sender_type = property(__get_sender_type, __set_sender_type)\n\n  def __get_sender_index(self):\n        return (self.sender_info & 224) >> 5\n\n  def __set_sender_index(self, value):\n        self.sender_info = (self.sender_info & 31) | ((value & 7) << 5)\n\n  sender_index = property(__get_sender_index, __set_sender_index)\n\n  def __get_receiver_type(self):\n        return self.receiver_info & 31\n\n  def __set_receiver_type(self, value):\n        self.receiver_info = (self.receiver_info & 224) | (value & 31)\n\n  receiver_type = property(__get_receiver_type, __set_receiver_type)\n\n  def __get_receiver_index(self):\n        return (self.receiver_info & 224) >> 5\n\n  def __set_receiver_index(self, value):\n        self.receiver_info = (self.receiver_info & 31) | ((value & 7) << 5)\n\n  receiver_index = property(__get_receiver_index, __set_receiver_index)\n\n  def __get_packet_type(self):\n        return (self.cmd_type_data)  >> 7\n\n  def __set_packet_type(self, value):\n        self.cmd_type_data = (self.cmd_type_data & 127) | ((value & 1) << 7)\n\n  packet_type = property(__get_packet_type, __set_packet_type)\n\n  def __get_ack_type(self):\n        return (self.cmd_type_data >> 5) & 3\n\n  def __set_ack_type(self, value):\n        self.cmd_type_data = (self.cmd_type_data & 159) | ((value & 3) << 5)\n\n  ack_type = property(__get_ack_type, __set_ack_type)\n\n  def __get_encrypt_type(self):\n        return (self.cmd_type_data & 7)\n\n  def __set_encrypt_type(self, value):\n        self.cmd_type_data = (self.cmd_type_data & 248) | (value & 7)\n\n  encrypt_type = property(__get_encrypt_type, __set_encrypt_type)\n\n\nclass DJICmdV1Footer(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('crc16', c_ushort),  # Whole packet checksum\n  ]\n\n  def dict_export(self):\n    d = dict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    return d\n\n  def __repr__(self):\n    d = self.dict_export()\n    from pprint import pformat\n    return pformat(d, indent=4, width=1)\n\n\nclass DJIPayload_Base(LittleEndianStructure):\n  _pack_ = 1\n\n  def dict_export(self):\n    d = OrderedDict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    return d\n\n  def __repr__(self):\n    d = self.dict_export()\n    if d.keys():\n        report = []\n        for k, v in d.items():\n            if isinstance(v, Array) and v._type_ == c_ubyte:\n                report.append(k.rjust(16) + ': ' + repr(bytes(v)))\n            else:\n                report.append(k.rjust(16) + ': ' + repr(v))\n    return \"\\n\".join(report)\n\n\nclass DJIPayload_General_VersionInquiryRe(DJIPayload_Base):\n  _fields_ = [\n        ('unknown0', c_ubyte),\n        ('unknown1', c_ubyte),\n        ('hw_version', c_char * 16),\n        ('ldr_version', c_uint),\n        ('app_version', c_uint),\n        ('unknown1A', c_uint),\n        ('unknown1E', c_ubyte),\n  ]\n\n\nclass DJIPayload_General_ChipRebootRe(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n  ]\n\n\nclass DJIPayload_General_EncryptCmd(DecoratedEnum):\n    GetChipState = 1\n    GetModuleState = 2\n    Config = 3\n    DoEncrypt = 4\n\n\nclass DJIPayload_General_EncryptOperType(DecoratedEnum):\n    WriteTarget = 0\n    WriteSH204 = 1\n    WriteAll = 2\n\n\nclass DJIPayload_General_EncryptGetStateRq(DJIPayload_Base):\n  # Matches both GetChipState and GetModuleState\n  _fields_ = [\n        ('command', c_ubyte),\n  ]\n\n\nclass DJIPayload_General_EncryptConfigRq(DJIPayload_Base):\n  # Matches only Config command\n  _fields_ = [\n        ('command', c_ubyte),\n        ('oper_type', c_ubyte),\n        ('config_magic', c_ubyte * 8),\n        ('mod_type', c_ubyte),\n        ('board_sn', c_ubyte * 10),\n        ('key', c_ubyte * 32),\n        ('secure_num', c_ubyte * 16),\n  ]\n\n\nclass DJIPayload_General_EncryptConfig3Rq(DJIPayload_Base):\n  # Matches only Config command\n  _fields_ = [\n        ('command', c_ubyte),\n        ('oper_type', c_ubyte),\n        ('config_magic', c_ubyte * 8),\n        ('m01_mod_type', c_ubyte),\n        ('m01_board_sn', c_ubyte * 10),\n        ('m01_key', c_ubyte * 32),\n        ('m01_secure_num', c_ubyte * 16),\n        ('m04_mod_type', c_ubyte),\n        ('m04_board_sn', c_ubyte * 10),\n        ('m04_key', c_ubyte * 32),\n        ('m04_secure_num', c_ubyte * 16),\n        ('m08_mod_type', c_ubyte),\n        ('m08_board_sn', c_ubyte * 10),\n        ('m08_key', c_ubyte * 32),\n        ('m08_secure_num', c_ubyte * 16),\n  ]\n\n\nclass DJIPayload_General_EncryptDoEncryptRq(DJIPayload_Base):\n  # Matches only DoEncrypt command\n  _fields_ = [\n      ('command', c_ubyte),\n      ('mod_type', c_ubyte),\n      ('data', c_ubyte * 32),\n  ]\n\n\nclass DJIPayload_General_EncryptGetChipStateRe(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('state_flags', c_ubyte),\n        ('m01_boardsn', c_ubyte * 10),\n        ('m04_boardsn', c_ubyte * 10),\n        ('m08_boardsn', c_ubyte * 10),\n  ]\n\n\nclass DJIPayload_General_EncryptGetModuleStateRe(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('state_flags', c_ubyte),\n  ]\n\n\nclass DJIPayload_General_EncryptConfigRe(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n  ]\n\n\nclass DJIPayload_FlyController_AssistantUnlockRq(DJIPayload_Base):\n  _fields_ = [\n        ('lock_state', c_uint),\n  ]\n\n\nclass DJIPayload_FlyController_AssistantUnlockRe(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoByIndex2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_index', c_ushort),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n  ]\n\n\n# We cannot define property name with variable size, so let's make const size one\nDJIPayload_FlyController_ParamMaxLen = 160\n\n\nclass DJIPayload_FlyController_ParamType(DecoratedEnum):\n    ubyte = 0x0\n    ushort = 0x1\n    ulong = 0x2\n    ulonglong = 0x3\n    byte = 0x4\n    short = 0x5\n    long = 0x6\n    longlong = 0x7\n    float = 0x8\n    double = 0x9\n    array = 0xa\n    bool = 0xb\n\n\nclass DJIPayload_FlyController_GetParamInfoEOL2015Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoU2015Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('type_id', c_ushort),\n        ('size', c_ushort),\n        ('attribute', c_ushort),\n        ('limit_min', c_uint),\n        ('limit_max', c_uint),\n        ('limit_def', c_uint),\n        ('name', c_char * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoI2015Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('type_id', c_ushort),\n        ('size', c_ushort),\n        ('attribute', c_ushort),\n        ('limit_min', c_int),\n        ('limit_max', c_int),\n        ('limit_def', c_int),\n        ('name', c_char * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoF2015Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('type_id', c_ushort),\n        ('size', c_ushort),\n        ('attribute', c_ushort),\n        ('limit_min', c_float),\n        ('limit_max', c_float),\n        ('limit_def', c_float),\n        ('name', c_char * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_ReadParamValByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n  ]\n\n\nclass DJIPayload_FlyController_ReadParamValByHash2015Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_ReadParamValByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n  ]\n\n\nclass DJIPayload_FlyController_ReadParamValByIndex2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal1ByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal2ByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * 2),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal4ByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * 4),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal8ByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * 8),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal16ByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * 16),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamValAnyByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('unknown1', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamValByIndex2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n        ('table_no', c_ushort),\n        ('param_index', c_ushort),\n        ('param_value', c_ubyte * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal1ByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * 1),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal2ByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * 2),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal4ByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * 4),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal8ByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * 8),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamVal16ByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * 16),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamValAnyByHash2015Rq(DJIPayload_Base):\n  _fields_ = [\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_WriteParamValByHash2015Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n        ('param_hash', c_uint),\n        ('param_value', c_ubyte * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_GetTblAttribute2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n  ]\n\nclass DJIPayload_FlyController_GetTblAttribute2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n        ('table_no', c_ushort),\n        ('entries_crc', c_uint),\n        ('entries_num', c_uint),\n  ]\n\n\nclass DJIPayload_FlyController_GetTblAttributeEOL2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoByIndex2017Rq(DJIPayload_Base):\n  _fields_ = [\n        ('table_no', c_ushort),\n        ('param_index', c_ushort),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoEOL2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoU2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n        ('table_no', c_ushort),\n        ('param_index', c_ushort),\n        ('type_id', c_ushort),\n        ('size', c_ushort),\n        ('limit_def', c_uint),\n        ('limit_min', c_uint),\n        ('limit_max', c_uint),\n        ('name', c_char * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoI2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n        ('table_no', c_ushort),\n        ('param_index', c_ushort),\n        ('type_id', c_ushort),\n        ('size', c_ushort),\n        ('limit_def', c_int),\n        ('limit_min', c_int),\n        ('limit_max', c_int),\n        ('name', c_char * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_FlyController_GetParamInfoF2017Re(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ushort),\n        ('table_no', c_ushort),\n        ('param_index', c_ushort),\n        ('type_id', c_ushort),\n        ('size', c_ushort),\n        ('limit_def', c_float),\n        ('limit_min', c_float),\n        ('limit_max', c_float),\n        ('name', c_char * DJIPayload_FlyController_ParamMaxLen),\n  ]\n\n\nclass DJIPayload_Gimbal_CalibCmd(DecoratedEnum):\n    JointCoarse = 1\n    LinearHall = 2\n\n\nclass DJIPayload_Gimbal_CalibRq(DJIPayload_Base):\n  _fields_ = [\n        ('command', c_ubyte),\n  ]\n\n\nclass DJIPayload_Gimbal_CalibRe(DJIPayload_Base):\n  _fields_ = [\n        ('status1', c_ubyte),\n        ('status2', c_ubyte),\n  ]\n\n\nclass DJIPayload_HDLink_WriteHardwareRegisterRq(DJIPayload_Base):\n  _fields_ = [\n        ('reg_address', c_ushort),\n        ('reg_value', c_ubyte),\n  ]\n\n\nclass DJIPayload_HDLink_WriteHardwareRegisterRe(DJIPayload_Base):\n  _fields_ = [\n        ('status', c_ubyte),\n  ]\n\n\ndef flyc_parameter_compute_hash(po, parname):\n    \"\"\" Computes hash from given flyc parameter name. Parameters are recognized by the FC by the hash.\n    \"\"\"\n    parhash = 0\n    parbt = parname.encode('gbk') # seriously, they should already know the world uses UTF now\n    for i in range(0, len(parname)):\n        ncode = parbt[i]\n        tmpval = (parhash & 0xffffffff) << 8\n        parhash = (tmpval + ncode) % 0xfffffffb\n    return parhash\n\n\ndef flyc_parameter_is_signed(type_id):\n    \"\"\" Returns whether flight param of given type is signed - should use \"I\" versions of packets.\n    \"\"\"\n    return (type_id >= DJIPayload_FlyController_ParamType.byte.value) and \\\n          (type_id <= DJIPayload_FlyController_ParamType.longlong.value)\n\n\ndef flyc_parameter_is_float(type_id):\n    \"\"\" Returns whether flight param of given type is float - should use \"F\" versions of packets.\n    \"\"\"\n    return (type_id == DJIPayload_FlyController_ParamType.float.value) or \\\n          (type_id == DJIPayload_FlyController_ParamType.double.value)\n\n\ndef encode_command_packet(sender_type, sender_index, receiver_type, receiver_index, seq_num, pack_type, ack_type, encrypt_type, cmd_set, cmd_id, payload):\n    \"\"\" Encodes command packet with given header fields and payload into c_ubyte array.\n\n      Accepts integer values of all the fields.\n    \"\"\"\n    pkthead = DJICmdV1Header()\n    pkthead.whole_length = sizeof(pkthead) + len(payload) + 2\n    pkthead.header_crc8 = calc_pkt55_hdr_checksum(0x77, (c_ubyte * 3).from_buffer_copy(pkthead), 3)\n    pkthead.sender_type = sender_type\n    pkthead.sender_index = sender_index\n    pkthead.receiver_type = receiver_type\n    pkthead.receiver_index = receiver_index\n    pkthead.seq_num = seq_num\n    pkthead.packet_type = pack_type\n    pkthead.ack_type = ack_type\n    pkthead.encrypt_type = encrypt_type\n    pkthead.cmd_set = cmd_set\n    pkthead.cmd_id = cmd_id\n    enc_data = (c_ubyte * pkthead.whole_length)()\n    memmove(addressof(enc_data), byref(pkthead), sizeof(pkthead))\n    pktpayload = (c_ubyte * len(payload)).from_buffer_copy(payload)\n    memmove(addressof(enc_data) + sizeof(pkthead), byref(pktpayload), sizeof(pktpayload))\n    pktfoot = DJICmdV1Footer()\n    pktfoot.crc16 = calc_pkt55_checksum(enc_data, sizeof(enc_data) - 2)\n    memmove(addressof(enc_data) + sizeof(pkthead) + sizeof(pktpayload), byref(pktfoot), sizeof(pktfoot))\n    return enc_data\n\n\ndef encode_command_packet_en(sender_type, sender_index, receiver_type, receiver_index, seq_num, pack_type, ack_type, encrypt_type, cmd_set, cmd_id, payload):\n    \"\"\" Encodes command packet with given header fields and payload into c_ubyte array.\n\n      A wrapper which accepts enums instead of integer fields for most values.\n    \"\"\"\n    return encode_command_packet(sender_type.value, sender_index, receiver_type.value, receiver_index,\n      seq_num, pack_type.value, ack_type.value, encrypt_type.value, cmd_set.value, cmd_id, payload)\n\n\ndef get_known_payload(pkthead, payload):\n    if pkthead.cmd_set == CMD_SET_TYPE.GENERAL.value and pkthead.packet_type == 0:\n        if (pkthead.cmd_id == 0x30):\n            if len(payload) >= sizeof(DJIPayload_General_EncryptConfig3Rq):\n                return DJIPayload_General_EncryptConfig3Rq.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_General_EncryptConfigRq):\n                return DJIPayload_General_EncryptConfigRq.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_General_EncryptGetStateRq):\n                return DJIPayload_General_EncryptGetStateRq.from_buffer_copy(payload)\n\n    if pkthead.cmd_set == CMD_SET_TYPE.GENERAL.value and pkthead.packet_type == 1:\n        if (pkthead.cmd_id == 0x01):\n            if len(payload) >= sizeof(DJIPayload_General_VersionInquiryRe):\n                return DJIPayload_General_VersionInquiryRe.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0x0b):\n            if len(payload) >= sizeof(DJIPayload_General_ChipRebootRe):\n                return DJIPayload_General_ChipRebootRe.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0x30):\n            if len(payload) >= sizeof(DJIPayload_General_EncryptGetChipStateRe):\n                return DJIPayload_General_EncryptGetChipStateRe.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_General_EncryptGetModuleStateRe):\n                return DJIPayload_General_EncryptGetModuleStateRe.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_General_EncryptConfigRe):\n                return DJIPayload_General_EncryptConfigRe.from_buffer_copy(payload)\n\n    if pkthead.cmd_set == CMD_SET_TYPE.FLYCONTROLLER.value and pkthead.packet_type == 0:\n        if (pkthead.cmd_id == 0xdf):\n            if len(payload) >= sizeof(DJIPayload_FlyController_AssistantUnlockRq):\n                return DJIPayload_FlyController_AssistantUnlockRq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe0):\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetTblAttribute2017Rq):\n                return DJIPayload_FlyController_GetTblAttribute2017Rq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe1):\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetParamInfoByIndex2017Rq):\n                return DJIPayload_FlyController_GetParamInfoByIndex2017Rq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe2):\n            if len(payload) >= sizeof(DJIPayload_FlyController_ReadParamValByIndex2017Rq):\n                return DJIPayload_FlyController_ReadParamValByIndex2017Rq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe3):\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal16ByIndex2017Rq):\n                return DJIPayload_FlyController_WriteParamValAnyByIndex2017Rq.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_WriteParamValAnyByIndex2017Rq), b'\\0'))\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal8ByIndex2017Rq):\n                return DJIPayload_FlyController_WriteParamVal16ByIndex2017Rq.from_buffer_copy(payload)\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal4ByIndex2017Rq):\n                return DJIPayload_FlyController_WriteParamVal8ByIndex2017Rq.from_buffer_copy(payload)\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal2ByIndex2017Rq):\n                return DJIPayload_FlyController_WriteParamVal4ByIndex2017Rq.from_buffer_copy(payload)\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal1ByIndex2017Rq):\n                return DJIPayload_FlyController_WriteParamVal2ByIndex2017Rq.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_FlyController_WriteParamVal1ByIndex2017Rq):\n                return DJIPayload_FlyController_WriteParamVal1ByIndex2017Rq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xf0):\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetParamInfoByIndex2015Rq):\n                return DJIPayload_FlyController_GetParamInfoByIndex2015Rq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xf8):\n            if len(payload) >= sizeof(DJIPayload_FlyController_ReadParamValByHash2015Rq):\n                return DJIPayload_FlyController_ReadParamValByHash2015Rq.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xf9):\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal16ByHash2015Rq):\n                return DJIPayload_FlyController_WriteParamValAnyByHash2015Rq.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_WriteParamValAnyByHash2015Rq), b'\\0'))\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal8ByHash2015Rq):\n                return DJIPayload_FlyController_WriteParamVal16ByHash2015Rq.from_buffer_copy(payload)\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal4ByHash2015Rq):\n                return DJIPayload_FlyController_WriteParamVal8ByHash2015Rq.from_buffer_copy(payload)\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal2ByHash2015Rq):\n                return DJIPayload_FlyController_WriteParamVal4ByHash2015Rq.from_buffer_copy(payload)\n            if len(payload) > sizeof(DJIPayload_FlyController_WriteParamVal1ByHash2015Rq):\n                return DJIPayload_FlyController_WriteParamVal2ByHash2015Rq.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_FlyController_WriteParamVal1ByHash2015Rq):\n                return DJIPayload_FlyController_WriteParamVal1ByHash2015Rq.from_buffer_copy(payload)\n\n    if pkthead.cmd_set == CMD_SET_TYPE.FLYCONTROLLER.value and pkthead.packet_type == 1:\n        if (pkthead.cmd_id == 0xdf):\n            if len(payload) >= sizeof(DJIPayload_FlyController_AssistantUnlockRe):\n                return DJIPayload_FlyController_AssistantUnlockRe.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe0):\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetTblAttribute2017Re):\n                return DJIPayload_FlyController_GetTblAttribute2017Re.from_buffer_copy(payload)\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetTblAttributeEOL2017Re):\n                return DJIPayload_FlyController_GetTblAttributeEOL2017Re.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe1):\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetParamInfoU2017Re)-DJIPayload_FlyController_ParamMaxLen+1:\n                out_payload = DJIPayload_FlyController_GetParamInfoU2017Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_GetParamInfoU2017Re), b'\\0'))\n                if flyc_parameter_is_signed(out_payload.type_id):\n                    return DJIPayload_FlyController_GetParamInfoI2017Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_GetParamInfoI2017Re), b'\\0'))\n                elif flyc_parameter_is_float(out_payload.type_id):\n                    return DJIPayload_FlyController_GetParamInfoF2017Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_GetParamInfoF2017Re), b'\\0'))\n                else:\n                    return out_payload\n            elif len(payload) >= sizeof(DJIPayload_FlyController_GetParamInfoEOL2017Re):\n                return DJIPayload_FlyController_GetParamInfoEOL2017Re.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xe2):\n            if len(payload) >= sizeof(DJIPayload_FlyController_ReadParamValByIndex2017Re)-DJIPayload_FlyController_ParamMaxLen+1:\n                return DJIPayload_FlyController_ReadParamValByIndex2017Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_ReadParamValByIndex2017Re), b'\\0'))\n        if (pkthead.cmd_id == 0xe3):\n            if len(payload) >= sizeof(DJIPayload_FlyController_WriteParamValByIndex2017Re)-DJIPayload_FlyController_ParamMaxLen+1:\n                return DJIPayload_FlyController_WriteParamValByIndex2017Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_WriteParamValByIndex2017Re), b'\\0'))\n        if (pkthead.cmd_id == 0xf0) or (pkthead.cmd_id == 0xf7):\n            if len(payload) >= sizeof(DJIPayload_FlyController_GetParamInfoU2015Re)-DJIPayload_FlyController_ParamMaxLen+1:\n                out_payload = DJIPayload_FlyController_GetParamInfoU2015Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_GetParamInfoU2015Re), b'\\0'))\n                if flyc_parameter_is_signed(out_payload.type_id):\n                    return DJIPayload_FlyController_GetParamInfoI2015Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_GetParamInfoI2015Re), b'\\0'))\n                elif flyc_parameter_is_float(out_payload.type_id):\n                    return DJIPayload_FlyController_GetParamInfoF2015Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_GetParamInfoF2015Re), b'\\0'))\n                else:\n                    return out_payload\n            elif len(payload) >= sizeof(DJIPayload_FlyController_GetParamInfoEOL2015Re):\n                return DJIPayload_FlyController_GetParamInfoEOL2015Re.from_buffer_copy(payload)\n        if (pkthead.cmd_id == 0xf8):\n            if len(payload) >= sizeof(DJIPayload_FlyController_ReadParamValByHash2015Re)-DJIPayload_FlyController_ParamMaxLen+1:\n                return DJIPayload_FlyController_ReadParamValByHash2015Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_ReadParamValByHash2015Re), b'\\0'))\n        if (pkthead.cmd_id == 0xf9):\n            if len(payload) >= sizeof(DJIPayload_FlyController_WriteParamValByHash2015Re)-DJIPayload_FlyController_ParamMaxLen+1:\n                return DJIPayload_FlyController_WriteParamValByHash2015Re.from_buffer_copy(payload.ljust(sizeof(DJIPayload_FlyController_WriteParamValByHash2015Re), b'\\0'))\n\n    if pkthead.cmd_set == CMD_SET_TYPE.ZENMUSE.value and pkthead.packet_type == 0:\n        if (pkthead.cmd_id == 0x08):\n            # Response for this packet often lacks type flag\n            if len(payload) >= sizeof(DJIPayload_Gimbal_CalibRe):\n                return DJIPayload_Gimbal_CalibRe.from_buffer_copy(payload)\n            elif len(payload) >= sizeof(DJIPayload_Gimbal_CalibRq):\n                return DJIPayload_Gimbal_CalibRq.from_buffer_copy(payload)\n\n    if pkthead.cmd_set == CMD_SET_TYPE.ZENMUSE.value and pkthead.packet_type == 1:\n        if (pkthead.cmd_id == 0x08):\n            if len(payload) >= sizeof(DJIPayload_Gimbal_CalibRe):\n                return DJIPayload_Gimbal_CalibRe.from_buffer_copy(payload)\n\n    if pkthead.cmd_set == CMD_SET_TYPE.OFDM.value and pkthead.packet_type == 0:\n        if (pkthead.cmd_id == 0x06):\n            if len(payload) >= sizeof(DJIPayload_HDLink_WriteHardwareRegisterRq):\n                return DJIPayload_HDLink_WriteHardwareRegisterRq.from_buffer_copy(payload)\n\n    if pkthead.cmd_set == CMD_SET_TYPE.OFDM.value and pkthead.packet_type == 1:\n        if (pkthead.cmd_id == 0x06):\n            if len(payload) >= sizeof(DJIPayload_HDLink_WriteHardwareRegisterRe):\n                return DJIPayload_HDLink_WriteHardwareRegisterRe.from_buffer_copy(payload)\n\n    return None\n\n\ndef do_build_packet(options):\n    pkt = encode_command_packet_en(options.sender_type, options.sender_index, options.receiver_type, options.receiver_index,\n      options.seq_num, options.pack_type, options.ack_type, options.encrypt_type, options.cmd_set, options.cmd_id, options.payload)\n    print(' '.join('{:02x}'.format(x) for x in pkt))\n\n\ndef parse_module_ident(s):\n    \"\"\" Parses module identification string in known formats.\n    \"\"\"\n    pat = re.compile(r\"^m?([0-9]{1,2})([0-9]{2})$\")\n    out = re.match(pat, s)\n    if out is None:\n        raise argparse.ArgumentTypeError(\"No 4-byte module ident\")\n    return out\n\n\ndef parse_module_type(s):\n    \"\"\" Parses module type string in known formats.\n    \"\"\"\n    pat = re.compile(r\"^[0-9]{1,2}$\")\n    try:\n        if re.search(pat, s):\n            return COMM_DEV_TYPE(int(s, 10))\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Numeric value out of range\")\n    try:\n        return COMM_DEV_TYPE.from_name(s.upper())\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Unrecognized name of enum item\")\n\n\ndef parse_ack_type(s):\n    \"\"\" Parses ack type string in known formats.\n    \"\"\"\n    pat = re.compile(r\"^[0-9]{1}$\")\n    try:\n        if re.search(pat, s):\n            return ACK_TYPE(int(s, 10))\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Numeric value out of range\")\n    try:\n        return ACK_TYPE.from_name(s.upper())\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Unrecognized name of enum item\")\n\n\ndef parse_encrypt_type(s):\n    \"\"\" Parses encrypt type string in known formats.\n    \"\"\"\n    pat = re.compile(r\"^[0-9]{1}$\")\n    try:\n        if re.search(pat, s):\n            return ENCRYPT_TYPE(int(s, 10))\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Numeric value out of range\")\n    try:\n        return ENCRYPT_TYPE.from_name(s.upper())\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Unrecognized name of enum item\")\n\n\ndef parse_packet_type(s):\n    \"\"\" Parses packet type string in known formats.\n    \"\"\"\n    pat = re.compile(r\"^[0-9]{1}$\")\n    try:\n        if re.search(pat, s):\n            return PACKET_TYPE(int(s, 10))\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Numeric value out of range\")\n    try:\n        return PACKET_TYPE.from_name(s.upper())\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Unrecognized name of enum item\")\n\n\ndef parse_cmd_set(s):\n    \"\"\" Parses command set string in known formats.\n    \"\"\"\n    pat = re.compile(r\"^[0-9]{1,3}$\")\n    try:\n        if re.search(pat, s):\n            return CMD_SET_TYPE(int(s, 10))\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Numeric value out of range\")\n    try:\n        return CMD_SET_TYPE.from_name(s.upper())\n    except Exception:\n        raise argparse.ArgumentTypeError(\"Unrecognized name of enum item\")\n\n\ndef main():\n    \"\"\" Main executable function.\n\n      Its task is to parse command line options and call a function which performs a task.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-n', '--seq_num', default=0, type=int,\n            help=\"sequence number of the packet (default is %(default)s)\")\n\n    parser.add_argument('-u', '--pack_type', default=\"Request\", type=parse_packet_type,\n            help=\"packet Type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-a', '--ack_type', default=\"No_ACK_Needed\", type=parse_ack_type,\n            help=\"acknowledgement type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-e', '--encrypt_type', default=\"NO_ENC\", type=parse_encrypt_type,\n            help=\"encryption type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-s', '--cmd_set', default=\"GENERAL\", type=parse_cmd_set,\n            help=\"command Set, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-i', '--cmd_id', default=0, type=int,\n            help=\"command ID (default is %(default)s)\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n            help=\"increases verbosity level; max level is set by -vvv\")\n\n    parser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n              .format(version=__version__, author=__author__),\n            help=\"display version information and exit\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-t', '--sender', type=parse_module_ident,\n            help=\"sender Type and Index, in TTII form\")\n\n    subparser.add_argument('-tt', '--sender_type', default=\"PC\", type=parse_module_type,\n            help=\"sender(transmitter) Type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-ti', '--sender_index', default=0, type=int,\n            help=\"sender(transmitter) Index (default is %(default)s)\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-r', '--receiver', type=parse_module_ident,\n            help=\"receiver Type and Index, in TTII form (ie. 0300)\")\n\n    subparser.add_argument('-rt', '--receiver_type', default=\"ANY\", type=parse_module_type,\n            help=\"receiver Type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-ri', '--receiver_index', default=0, type=int,\n            help=\"receiver index (default is %(default)s)\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-x', '--payload_hex', type=str,\n            help=\"provide payload as hex string\")\n\n    subparser.add_argument('-p', '--payload_bin', default=\"\", type=str,\n            help=\"provide binary payload directly (default payload is empty)\")\n\n    options = parser.parse_args()\n\n    if (options.payload_hex is not None):\n        options.payload = bytes.fromhex(options.payload_hex)\n    else:\n        options.payload = bytes(options.payload_bin, 'utf-8')\n\n    if (options.sender is not None):\n        options.sender_type = COMM_DEV_TYPE(int(options.sender.group(1), 10))\n        options.sender_index = int(options.sender.group(2), 10)\n\n    if (options.receiver is not None):\n        options.receiver_type = COMM_DEV_TYPE(int(options.receiver.group(1), 10))\n        options.receiver_index = int(options.receiver.group(2), 10)\n\n    do_build_packet(options)\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "comm_og_service_tool.py",
          "type": "blob",
          "size": 71.3916015625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" OGs Service Tool for Dji products.\n\n The script allows to trigger a few service functions of Dji drones.\n\"\"\"\n\n# Copyright (C) 2018 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.7\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport time\nimport struct\nimport hashlib\nimport argparse\nfrom ctypes import c_ubyte, sizeof\n\nsys.path.insert(0, './')\nfrom comm_serialtalk import (\n  do_send_request, do_receive_reply, SerialMock, open_usb\n)\nfrom comm_mkdupc import (\n  COMM_DEV_TYPE, PACKET_TYPE, ENCRYPT_TYPE, ACK_TYPE, CMD_SET_TYPE,\n  DecoratedEnum, PacketProperties, DJICmdV1Header,\n  get_known_payload, flyc_parameter_compute_hash,\n)\nimport comm_mkdupc as dupc  # for access to all the DJIPayload_* structs\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass PRODUCT_CODE(DecoratedEnum):\n    A2     =  0 # Released 2013-09-04 A2 Flight Controller\n    P330   =  1 # Released 2013-01-07 Phantom 1\n    P330V  =  2 # Released 2013-10-28 Phantom 2 Vision\n    P330Z  =  3 # Released 2013-12-15 Phantom 2 w/ Zenmuse H3-2D\n    P330VP =  4 # Released 2014-04-07 Phantom 2 Vision+\n    WM610  =  5 # Released 2014-11-13 Inspire 1\n    P3X    =  6 # Released 2015-03-09 Phantom 3 Professional\n    P3S    =  7 # Released 2015-03-09 Phantom 3 Advanced\n    MAT100 =  8 # Released 2015-06-08 Matrice 100\n    P3C    =  9 # Released 2015-08-04 Phantom 3 Standard\n    MG1    = 10 # Released 2015-11-27 Agras MG-1\n    WM325  = 11 # Released 2016-01-05 Phantom 3 4K\n    WM330  = 12 # Released 2016-03-02 Phantom 4 (now referenced as Phantom 4 Standard)\n    MAT600 = 13 # Released 2016-04-17 Matrice 600\n    WM220  = 14 # Released 2016-09-28 Mavic Pro (also includes Released 2017-08-24 Mavic Pro Platinum)\n    WM620  = 15 # Released 2016-11-16 Inspire 2\n    WM331  = 16 # Released 2016-11-16 Phantom 4 Pro\n    MAT200 = 17 # Released 2017-02-26 Matrice 200\n    MG1S   = 18 # Released 2017-03-28 Agras MG-1S\n    WM332  = 19 # Released 2017-04-13 Phantom 4 Advanced\n    WM100  = 20 # Released 2017-05-24 Spark\n    WM230  = 21 # Released 2018-01-23 Mavic Air\n    WM335  = 22 # Released 2018-05-08 Phantom 4 Pro V2\n    WM240  = 23 # Released 2018-08-23 Mavic 2 Pro/Zoom\n    WM245  = 24 # Released 2018-10-29 Mavic 2 Enterprise\n    WM246  = 25 # Released 2018-12-20 Mavic 2 Enterprise Dual\n    WM160  = 26 # Released 2019-10-30 Mavic Mini\n    WM231  = 27 # Released 2020-04-28 Mavic Air 2\n    WM232  = 28 # Released 2021-04-15 (MAVIC) AIR 2S\n    WM260  = 29 # Released 2021-11-05 (MAVIC) 3\n    WM247  = 30 # Released 2020-12-15 Mavic 2 Enterprise Advanced\n\n\nALT_PRODUCT_CODE = {\n    'S800': 'A2', # Released 2012-07-25 Hexacopter frame, often sold with Dji A2 Flight Controller\n    'S1000': 'A2', # Released 2014-02-24 Octocopter frame, often sold with Dji A2 Flight Controller\n    'S900': 'A2', # Released 2014-08-04 Hexacopter frame, often sold with Dji A2 Flight Controller\n    'PH3PRO': 'P3X',\n    'PH3ADV': 'P3S',\n    'PH3STD': 'P3C',\n    'P3XW': 'WM325',\n    'P4': 'WM330',\n    'PH4': 'WM330',\n    'PH4PRO': 'WM331',\n    'PH4ADV': 'WM332',\n    'SPARK': 'WM100',\n    'MAVIC': 'WM220',\n    'MAVAIR': 'WM230',\n    'M2P': 'WM240',\n    'M2Z': 'WM240',\n    'M2E': 'WM245',\n    'M2ED': 'WM246',\n    'M2EA': 'WM247',\n    'MMINI': 'WM160',\n    'MAVAIR2': 'WM231',\n    'MAVAIR2S': 'WM232',\n    'MAV3': 'WM260',\n}\n\n\nclass SERVICE_CMD(DecoratedEnum):\n    FlycParam = 0\n    GimbalCalib = 1\n    CameraCalib = 2\n\n\nclass FLYC_PARAM_CMD(DecoratedEnum):\n    LIST = 0\n    GET = 1\n    SET = 2\n\n\nclass GIMBAL_CALIB_CMD(DecoratedEnum):\n    JOINTCOARSE = 0\n    LINEARHALL = 1\n\n\nclass CAMERA_CALIB_CMD(DecoratedEnum):\n    ENCRYPTCHECK = 0\n    ENCRYPTPAIR = 1\n\n\nclass CAMERA_ENCRYPT_PAIR_TARGET(DecoratedEnum):\n    ALL = 0\n    CAMERA = 1\n    GIMBAL = 4\n    LB_DM3XX_SKY = 8\n\n\ndefault_32byte_key = bytes([ # Default key\n    0x56, 0x79, 0x6C, 0x0E, 0xEE, 0x0F, 0x38, 0x05, 0x20, 0xE0, 0xBE, 0x70, 0xF2, 0x77, 0xD9, 0x0B,\n    0x30, 0x72, 0x31, 0x67, 0x31, 0x6E, 0x61, 0x6C, 0x47, 0x61, 0x6E, 0x39, 0x73, 0x74, 0x61, 0x60,\n    ])\n\n\ndef detect_serial_port(po):\n    \"\"\" Detects the serial port device name of a Dji product.\n    \"\"\"\n    import serial.tools.list_ports\n    #TODO: detection unfinished\n    for comport in serial.tools.list_ports.comports():\n        print(comport.device)\n    return ''\n\n\ndef open_serial_port(po):\n    ser = None\n    if po.bulk:\n        ser = open_usb(po)\n    else:\n        # Open serial port\n        import serial\n        if po.port == 'auto':\n            port_name = detect_serial_port(po)\n        else:\n            port_name = po.port\n        if not po.dry_test:\n            ser = serial.Serial(port_name, baudrate=po.baudrate, timeout=0)\n        else:\n            ser = SerialMock(port_name, baudrate=po.baudrate, timeout=0)\n        if (po.verbose > 0):\n            print(\"Opened {} at {}\".format(ser.port, ser.baudrate))\n    return ser\n\n\ndef get_unique_sequence_number(po):\n    \"\"\" Returns a sequence number for packet.\n    \"\"\"\n    # This will be unique as long as we do 10ms delay between packets\n    return int(time.time()*100) & 0xffff\n\n\ndef send_request_and_receive_reply(po, ser, receiver_type, receiver_index, ack_type, cmd_set, cmd_id, payload, seqnum_check=True, retry_num=3):\n    global last_seq_num\n    if 'last_seq_num' not in globals():\n        last_seq_num = get_unique_sequence_number(po)\n\n    pktprop = PacketProperties()\n    pktprop.sender_type = COMM_DEV_TYPE.PC\n    pktprop.sender_index = 0\n    pktprop.receiver_type = receiver_type\n    pktprop.receiver_index = receiver_index\n    pktprop.seq_num = last_seq_num\n    pktprop.pack_type = PACKET_TYPE.REQUEST\n    pktprop.ack_type = ack_type\n    pktprop.encrypt_type = ENCRYPT_TYPE.NO_ENC\n    pktprop.cmd_set = cmd_set\n    pktprop.cmd_id = cmd_id\n    if hasattr(payload, '__len__'):\n        pktprop.payload = (c_ubyte * len(payload)).from_buffer_copy(payload)\n    else:\n        pktprop.payload = (c_ubyte * sizeof(payload)).from_buffer_copy(payload)\n\n    for nretry in range(0, retry_num):\n        pktreq = do_send_request(po, ser, pktprop)\n\n        if pktprop.ack_type == ACK_TYPE.NO_ACK_NEEDED: # Only wait for response if it was requested\n            pktrpl = None\n            break\n\n        pktrpl = do_receive_reply(po, ser, pktreq,\n          seqnum_check=(seqnum_check and not po.dry_test))\n\n        if pktrpl is not None:\n            break\n\n    last_seq_num += 1\n\n    if (po.verbose > 1):\n        if pktrpl is not None:\n            print(\"Received response packet:\")\n        else:\n            print(\"No response received.\")\n\n    if (po.verbose > 0):\n        if pktrpl is not None:\n            print(' '.join('{:02x}'.format(x) for x in pktrpl))\n\n    return pktrpl, pktreq\n\n\ndef receive_reply_for_request(po, ser, pktreq, seqnum_check=True):\n    \"\"\" Receives and returns response for given request packet.\n\n        Does not send the request, just waits for response.\n        To be used in cases when a packet triggers multiple responses.\n    \"\"\"\n    pktrpl = do_receive_reply(po, ser, pktreq, seqnum_check=seqnum_check)\n\n    if (po.verbose > 1):\n        if pktrpl is not None:\n            print(\"Received response packet:\")\n        else:\n            print(\"No response received.\")\n\n    if (po.verbose > 0):\n        if pktrpl is not None:\n            print(' '.join('{:02x}'.format(x) for x in pktrpl))\n\n    return pktrpl\n\ndef flyc_request_assistant_unlock(po, ser, val):\n    if (po.verbose > 0):\n        print(\"Sending Assistant Unlock request.\")\n    payload = dupc.DJIPayload_FlyController_AssistantUnlockRq()\n    payload.lock_state = val\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 0e 04 66 03 0a 9d a5 80 03 df 00 a7 92\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xdf,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on Assistant Unlock request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if rplpayload is None:\n        raise ConnectionError(\"Unrecognized response to Assistant Unlock request.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef flyc_param_request_2017_get_table_attribs(po, ser, table_no):\n    payload = dupc.DJIPayload_FlyController_GetTblAttribute2017Rq()\n    payload.table_no = table_no\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 19 04 e4 03 0a 9e a5 80 03 e0 00 00 00 00 2f 87 ca 7a 86 01 00 00 55 e7\"))\n        ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 03 0a a0 a5 80 03 e0 09 00 17 f4\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xe0,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on get table attribs request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise LookupError(\"Unrecognized response to get table attribs request.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef flyc_param_request_2017_get_param_info_by_index(po, ser, table_no, param_idx):\n    payload = dupc.DJIPayload_FlyController_GetParamInfoByIndex2017Rq()\n    payload.table_no = table_no\n    payload.param_index = param_idx\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 48 04 57 03 0a 1b 70 80 03 e1 00 00 00 00 82 \"\n              \"00 08 00 04 00 5c 8f da 40 0a d7 23 3c 00 00 c8 42 67 5f 63 6f 6e 66 69 67 2e 6d 72 5f 63 72 61 \"\n              \"66 74 2e 72 6f 74 6f 72 5f 36 5f 63 66 67 2e 74 68 72 75 73 74 00 8f a6\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xe1,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on parameter {:d} info by index request.\".format(param_idx))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    paraminfo = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (paraminfo is None):\n        raise ConnectionError(\"Unrecognized response to parameter {:d} info by index request.\".format(param_idx))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(paraminfo).__name__))\n        print(paraminfo)\n\n    return paraminfo\n\n\ndef flyc_param_request_2015_get_param_info_by_index(po, ser, param_idx):\n    payload = dupc.DJIPayload_FlyController_GetParamInfoByIndex2015Rq()\n    payload.param_index = param_idx\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 2e 04 a7 03 0a 77 45 80 03 f0 00 0a 00 10 00 \"\n              \"00 00 00 00 00 00 00 00 00 00 00 00 00 00 67 6c 6f 62 61 6c 2e 73 74 61 74 75 73 00 79 ac\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xf0,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on parameter {:d} info by index request.\".format(param_idx))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    paraminfo = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (paraminfo is None):\n        raise ConnectionError(\"Unrecognized response to parameter {:d} info by index request.\".format(param_idx))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(paraminfo).__name__))\n        print(paraminfo)\n\n    return paraminfo\n\n\ndef flyc_param_request_2015_get_param_info_by_hash(po, ser, param_name):\n    payload = dupc.DJIPayload_FlyController_GetParamInfoByHash2015Rq()\n    payload.param_hash = flyc_parameter_compute_hash(po,param_name)\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 43 04 74 03 0a ff 7c 80 03 f7 00 01 00 02 00 \"\n              \"0b 00 14 00 00 00 f4 01 00 00 78 00 00 00 67 5f 63 6f 6e 66 69 67 2e 66 6c 79 69 6e 67 5f 6c 69 \"\n              \"6d 69 74 2e 6d 61 78 5f 68 65 69 67 68 74 5f 30 00 5d 71\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xf7,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on parameter info by hash request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    paraminfo = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (paraminfo is None):\n        raise LookupError(\"Unrecognized response to parameter info by hash request.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(paraminfo).__name__))\n        print(paraminfo)\n\n    return paraminfo\n\n\ndef flyc_param_request_2015_read_param_value_by_hash(po, ser, param_name):\n    payload = dupc.DJIPayload_FlyController_ReadParamValByHash2015Rq()\n    payload.param_hash = flyc_parameter_compute_hash(po,param_name)\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 14 04 6d 03 0a 00 7d 80 03 f8 00 8a 23 71 03 f4 01 57 ee\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xf8,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on read parameter value by hash request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise LookupError(\"Unrecognized response to read parameter value by hash request.\")\n\n    if sizeof(rplpayload) <= 4:\n        raise ValueError(\"Response indicates parameter does not exist or has no retrievable value.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef flyc_param_request_2017_read_param_value_by_index(po, ser, table_no, param_idx):\n    payload = dupc.DJIPayload_FlyController_ReadParamValByIndex2017Rq()\n    payload.table_no = table_no\n    payload.unknown1 = 1\n    payload.param_index = param_idx\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 15 04 a9 03 0a 5a 6c 80 03 e2 00 00 00 00 9e 00 f4 01 10 b1\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xe2,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on parameter {:d} info by index request.\".format(param_idx))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized response to parameter {:d} info by index request.\".format(param_idx))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef do_assistant_unlock(po, ser):\n    try:\n        rplpayload = flyc_request_assistant_unlock(po, ser, 1)\n\n        if rplpayload.status != 0:\n            raise ValueError(\"Denial status {:d} returned from Assistant Unlock request.\".format(rplpayload.status))\n\n    except Exception as ex:\n        if (po.verbose > 0):\n            print(\"Error: \"+str(ex))\n        eprint(\"Assistant Unlock command failed; further commands may not work because of this.\")\n        return False\n\n    return True\n\n\ndef flyc_param_request_2017_write_param_value_by_index(po, ser, table_no, param_idx, param_val):\n    if len(param_val) > 16:\n        payload = dupc.DJIPayload_FlyController_WriteParamValAnyByIndex2017Rq()\n    elif len(param_val) > 8:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal16ByIndex2017Rq()\n    elif len(param_val) > 4:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal8ByIndex2017Rq()\n    elif len(param_val) > 2:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal4ByIndex2017Rq()\n    elif len(param_val) > 1:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal2ByIndex2017Rq()\n    else:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal1ByIndex2017Rq()\n    payload.table_no = table_no\n    payload.unknown1 = 1\n    payload.param_index = param_idx\n\n    if len(param_val) > 1:\n        payload.param_value = (c_ubyte * sizeof(payload.param_value)).from_buffer_copy(param_val)\n    else:\n        payload.param_value = (c_ubyte).from_buffer_copy(param_val)\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 15 04 a9 03 0a 1a de 80 03 e3 00 00 00 00 9e 00 f3 01 a7 40\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xe3,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on write parameter value by index request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise LookupError(\"Unrecognized response to write parameter value by index request.\")\n\n    if sizeof(rplpayload) <= 4:\n        raise ValueError(\"Response indicates parameter does not exist or is not writeable.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef flyc_param_request_2015_write_param_value_by_hash(po, ser, param_name, param_val):\n    if len(param_val) > 16:\n        payload = dupc.DJIPayload_FlyController_WriteParamValAnyByHash2015Rq()\n    elif len(param_val) > 8:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal16ByHash2015Rq()\n    elif len(param_val) > 4:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal8ByHash2015Rq()\n    elif len(param_val) > 2:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal4ByHash2015Rq()\n    elif len(param_val) > 1:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal2ByHash2015Rq()\n    else:\n        payload = dupc.DJIPayload_FlyController_WriteParamVal1ByHash2015Rq()\n    payload.param_hash = flyc_parameter_compute_hash(po, param_name)\n    payload.param_value = (c_ubyte * sizeof(payload.param_value)).from_buffer_copy(param_val)\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 14 04 6d 03 0a 37 c6 80 03 f9 00 8a 23 71 03 f3 01 dd dd\"))\n\n    pktrpl, _ = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.FLYCONTROLLER, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.FLYCONTROLLER, 0xf9,\n      payload)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on write parameter value by hash request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise LookupError(\"Unrecognized response to write parameter value by hash request.\")\n\n    if sizeof(rplpayload) <= 4:\n        raise ValueError(\"Response indicates parameter does not exist or is not writeable.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef flyc_param_info_limits_to_str(po, paraminfo):\n    if (isinstance(paraminfo, dupc.DJIPayload_FlyController_GetParamInfoU2015Re) or\n      isinstance(paraminfo, dupc.DJIPayload_FlyController_GetParamInfoU2017Re)):\n        limit_min = '{:d}'.format(paraminfo.limit_min)\n        limit_max = '{:d}'.format(paraminfo.limit_max)\n        limit_def = '{:d}'.format(paraminfo.limit_def)\n    elif (isinstance(paraminfo, dupc.DJIPayload_FlyController_GetParamInfoI2015Re) or\n      isinstance(paraminfo, dupc.DJIPayload_FlyController_GetParamInfoI2017Re)):\n        limit_min = '{:d}'.format(paraminfo.limit_min)\n        limit_max = '{:d}'.format(paraminfo.limit_max)\n        limit_def = '{:d}'.format(paraminfo.limit_def)\n    elif (isinstance(paraminfo, dupc.DJIPayload_FlyController_GetParamInfoF2015Re) or\n      isinstance(paraminfo, dupc.DJIPayload_FlyController_GetParamInfoF2017Re)):\n        limit_min = '{:f}'.format(paraminfo.limit_min)\n        limit_max = '{:f}'.format(paraminfo.limit_max)\n        limit_def = '{:f}'.format(paraminfo.limit_def)\n    else:\n        limit_min = \"n/a\"\n        limit_max = \"n/a\"\n        limit_def = \"n/a\"\n    return (limit_min, limit_max, limit_def)\n\n\ndef flyc_param_value_to_str(po, paraminfo, param_value):\n    if (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ubyte.value):\n        param_bs = bytes(param_value[:1])\n        value_str = \"{:d}\".format(struct.unpack(\"<B\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ushort.value):\n        param_bs = bytes(param_value[:2])\n        value_str = \"{:d}\".format(struct.unpack(\"<H\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ulong.value):\n        param_bs = bytes(param_value[:4])\n        value_str = \"{:d}\".format(struct.unpack(\"<L\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ulonglong.value):\n        param_bs = bytes(param_value[:8])\n        value_str = \"{:d}\".format(struct.unpack(\"<Q\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.byte.value):\n        param_bs = bytes(param_value[:1])\n        value_str = \"{:d}\".format(struct.unpack(\"<b\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.short.value):\n        param_bs = bytes(param_value[:2])\n        value_str = \"{:d}\".format(struct.unpack(\"<h\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.long.value):\n        param_bs = bytes(param_value[:4])\n        value_str = \"{:d}\".format(struct.unpack(\"<l\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.longlong.value):\n        param_bs = bytes(param_value[:8])\n        value_str = \"{:d}\".format(struct.unpack(\"<q\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.float.value):\n        param_bs = bytes(param_value[:4])\n        value_str = \"{:f}\".format(struct.unpack(\"<f\", param_bs)[0])\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.double.value):\n        param_bs = bytes(param_value[:8])\n        value_str = \"{:f}\".format(struct.unpack(\"<d\", param_bs)[0])\n    else: # array or future type\n        value_str = ' '.join('{:02x}'.format(x) for x in param_bs)\n    return value_str\n\n\ndef flyc_param_str_to_value(po, paraminfo, value_str):\n    if (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ubyte.value):\n        param_val = struct.pack(\"<B\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ushort.value):\n        param_val = struct.pack(\"<H\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ulong.value):\n        param_val = struct.pack(\"<L\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.ulonglong.value):\n        param_val = struct.pack(\"<Q\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.byte.value):\n        param_val = struct.pack(\"<b\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.short.value):\n        param_val = struct.pack(\"<h\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.long.value):\n        param_val = struct.pack(\"<l\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.longlong.value):\n        param_val = struct.pack(\"<q\", int(value_str,0))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.float.value):\n        param_val = struct.pack(\"<f\", float(value_str))\n    elif (paraminfo.type_id == dupc.DJIPayload_FlyController_ParamType.double.value):\n        param_val = struct.pack(\"<d\", float(value_str))\n    else: # array or future type\n        param_val = bytes.fromhex(value_str)\n    return param_val\n\n\ndef flyc_param_request_2015_print_response(po, idx, paraminfo, rplpayload):\n    if paraminfo is None:\n        # Print headers\n        if rplpayload is None:\n            param_val = \"\"\n        else:\n            param_val = \"value\"\n        if idx is None:\n            ident_str = \"hash\"\n        else:\n            ident_str = \"idx\"\n        if po.fmt == '2line':\n            print(\"{:10s} {:60s}\".format(ident_str, \"name\"))\n            print(\"{:6s} {:4s} {:6s} {:7s} {:7s} {:7s} {:7s}\".format(\n              \"typeId\", \"size\", \"attr\", \"min\", \"max\", \"deflt\", param_val))\n        elif po.fmt == 'tab':\n            print(\"{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\".format(\n              ident_str, \"name\", \"typeId\", \"size\", \"attr\", \"min\", \"max\", \"deflt\", param_val))\n        elif po.fmt == 'csv':\n            print(\"{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s}\".format(\n              ident_str, \"name\", \"typeId\", \"size\", \"attr\", \"min\", \"max\", \"deflt\", param_val))\n        elif po.fmt == '1line':\n            print(\"{:10s} {:60s} {:6s} {:4s} {:6s} {:7s} {:7s} {:7s} {:7s}\".format(\n              ident_str, \"name\", \"typeId\", \"size\", \"attr\", \"min\", \"max\", \"deflt\", param_val))\n        else: # po.fmt == 'simple':\n            pass\n    else:\n        # Print actual data\n        if rplpayload is None:\n            param_val = \"\"\n        else:\n            param_val = flyc_param_value_to_str(po, paraminfo, rplpayload.param_value)\n        if idx is None:\n            if rplpayload is not None:\n                ident_str = \"0x{:08x}\".format(rplpayload.param_hash)\n            else:\n                ident_str = \"n/a\"\n        else:\n            ident_str = \"{:d}\".format(idx)\n        # Convert limits to string before, so we can handle all types in the same way\n        (limit_min, limit_max, limit_def) = flyc_param_info_limits_to_str(po, paraminfo)\n\n        if po.fmt == '2line':\n            print(\"{:10s} {:60s}\".format(ident_str, paraminfo.name.decode(\"utf-8\")))\n            print(\"{:6d} {:4d} 0x{:04x} {:7s} {:7s} {:7s} {:7s}\".format(\n              paraminfo.type_id, paraminfo.size, paraminfo.attribute,\n              limit_min, limit_max, limit_def, param_val))\n        elif po.fmt == 'tab':\n            print(\"{:s}\\t{:s}\\t{:d}\\t{:d}\\t0x{:04x}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\".format(\n              ident_str, paraminfo.name.decode(\"utf-8\"),\n              paraminfo.type_id, paraminfo.size, paraminfo.attribute,\n              limit_min, limit_max, limit_def, param_val))\n        elif po.fmt == 'csv':\n            print(\"{:s};{:s};{:d};{:d};0x{:04x};{:s};{:s};{:s};{:s}\".format(\n              ident_str, paraminfo.name.decode(\"utf-8\"),\n              paraminfo.type_id, paraminfo.size, paraminfo.attribute,\n              limit_min, limit_max, limit_def, param_val))\n        #elif po.fmt == 'json': #TODO maybe output format similar to flyc_param_infos?\n        elif po.fmt == '1line':\n            print(\"{:10s} {:60s} {:6d} {:4d} 0x{:04x} {:7s} {:7s} {:7s} {:7s}\".format(\n              ident_str, paraminfo.name.decode(\"utf-8\"),\n              paraminfo.type_id, paraminfo.size, paraminfo.attribute,\n              limit_min, limit_max, limit_def, param_val))\n        else: # po.fmt == 'simple':\n            if rplpayload is None:\n                print(\"{:s} default = {:s} range = < {:s} .. {:s} >\"\n                  .format(paraminfo.name.decode(\"utf-8\"), limit_def, limit_min, limit_max))\n            else:\n                print(\"{:s} = {:s} range = < {:s} .. {:s} >\"\n                  .format(paraminfo.name.decode(\"utf-8\"), param_val, limit_min, limit_max))\n\n\ndef flyc_param_request_2017_print_response(po, idx, paraminfo, rplpayload):\n    if paraminfo is None:\n        # Print headers\n        if rplpayload is None:\n            param_val = \"\"\n        else:\n            param_val = \"value\"\n        if idx is None:\n            ident_str = \"hash\"\n        else:\n            ident_str = \"idx\"\n        if po.fmt == '2line':\n            print(\"{:10s} {:5s} {:60s}\".format(ident_str, \"tbl:idx\", \"name\"))\n            print(\"{:6s} {:4s} {:7s} {:7s} {:7s} {:7s}\".format(\n              \"typeId\", \"size\", \"min\", \"max\", \"deflt\", param_val))\n        elif po.fmt == 'tab':\n            print(\"{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\".format(\n              ident_str, \"tbl:idx\", \"name\", \"typeId\", \"size\", \"min\", \"max\", \"deflt\", param_val))\n        elif po.fmt == 'csv':\n            print(\"{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s}\".format(\n              ident_str, \"tbl:idx\", \"name\", \"typeId\", \"size\", \"min\", \"max\", \"deflt\", param_val))\n        elif po.fmt == '1line':\n            print(\"{:10s} {:5s} {:60s} {:6s} {:4s} {:7s} {:7s} {:7s} {:7s}\".format(\n              ident_str, \"tbl:idx\", \"name\", \"typeId\", \"size\", \"min\", \"max\", \"deflt\", param_val))\n        else: # po.fmt == 'simple':\n            pass\n    else:\n        # Print actual data\n        if rplpayload is None:\n            param_val = \"\"\n        else:\n            param_val = flyc_param_value_to_str(po, paraminfo, rplpayload.param_value)\n        if idx is None:\n            if rplpayload is None:\n                ident_str = \"n/a\"\n            elif hasattr(rplpayload, 'param_hash'):\n                ident_str = \"0x{:08x}\".format(rplpayload.param_hash)\n            else:\n                ident_str = \"0x{:08x}\".format(flyc_parameter_compute_hash(po,paraminfo.name.decode(\"utf-8\")))\n        else:\n            ident_str = \"{:d}\".format(idx)\n        tbl_str = \"{:d}:{:d}\".format(paraminfo.table_no, paraminfo.param_index)\n\n        # Convert limits to string before, so we can handle all types in the same way\n        (limit_min, limit_max, limit_def) = flyc_param_info_limits_to_str(po, paraminfo)\n\n        if po.fmt == '2line':\n            print(\"{:10s} {:5s} {:60s}\".format(ident_str, tbl_str, paraminfo.name.decode(\"utf-8\")))\n            print(\"{:6d} {:4d} {:7s} {:7s} {:7s} {:7s}\".format(\n              paraminfo.type_id, paraminfo.size,\n              limit_min, limit_max, limit_def, param_val))\n        elif po.fmt == 'tab':\n            print(\"{:s}\\t{:s}\\t{:s}\\t{:d}\\t{:d}\\t{:s}\\t{:s}\\t{:s}\\t{:s}\".format(\n              ident_str, tbl_str, paraminfo.name.decode(\"utf-8\"),\n              paraminfo.type_id, paraminfo.size,\n              limit_min, limit_max, limit_def, param_val))\n        elif po.fmt == 'csv':\n            print(\"{:s};{:s};{:s};{:d};{:d};{:s};{:s};{:s};{:s}\".format(\n              ident_str, tbl_str, paraminfo.name.decode(\"utf-8\"),\n              paraminfo.type_id, paraminfo.size,\n              limit_min, limit_max, limit_def, param_val))\n        #elif po.fmt == 'json': #TODO maybe output format similar to flyc_param_infos?\n        elif po.fmt == '1line':\n            print(\"{:10s} {:5s} {:60s} {:6d} {:4d} {:7s} {:7s} {:7s} {:7s}\".format(\n              ident_str, tbl_str, paraminfo.name.decode(\"utf-8\"),\n              paraminfo.type_id, paraminfo.size,\n              limit_min, limit_max, limit_def, param_val))\n        else: # po.fmt == 'simple':\n            if rplpayload is None:\n                print(\"{:s} default = {:s} range = < {:s} .. {:s} >\"\n                  .format(paraminfo.name.decode(\"utf-8\"), limit_def, limit_min, limit_max))\n            else:\n                print(\"{:s} = {:s} range = < {:s} .. {:s} >\"\n                  .format(paraminfo.name.decode(\"utf-8\"), param_val, limit_min, limit_max))\n\n\ndef do_flyc_param_request_2015_list(po, ser):\n    \"\"\" List flyc parameters on platforms with single, linear parameters table.\n\n        Tested on the following platforms and FW versions:\n        P3X_FW_V01.07.0060 (2018-07-22)\n    \"\"\"\n    # Print result data header\n    flyc_param_request_2015_print_response(po, True, None, None)\n\n    for idx in range(po.start, po.start+po.count):\n        rplpayload = flyc_param_request_2015_get_param_info_by_index(po, ser, idx)\n\n        if sizeof(rplpayload) <= 4:\n            if (po.verbose > 0):\n                print(\"Response on parameter {:d} indicates end of list.\".format(idx))\n            break\n        # Print the result data\n        flyc_param_request_2015_print_response(po, idx, rplpayload, None)\n\n\ndef do_flyc_param_request_2015_get(po, ser):\n    \"\"\" Get flyc parameter value on platforms with single, linear parameters table.\n\n        Tested on the following platforms and FW versions:\n        P3X_FW_V01.07.0060 (2018-07-22)\n    \"\"\"\n    # Get param info first, so we know type and size\n    paraminfo = flyc_param_request_2015_get_param_info_by_hash(po, ser, po.param_name)\n    # Now get the parameter value\n    rplpayload = flyc_param_request_2015_read_param_value_by_hash(po, ser, po.param_name)\n    # Print the result data\n    flyc_param_request_2015_print_response(po, None, None, True)\n    flyc_param_request_2015_print_response(po, None, paraminfo, rplpayload)\n\n\ndef do_flyc_param_request_2015_set(po, ser):\n    \"\"\" Set new value of flyc parameter on platforms with single, linear parameters table.\n\n        Tested on the following platforms and FW versions:\n        P3X_FW_V01.07.0060 (2018-07-22)\n    \"\"\"\n    # Get param info first, so we know type and size\n    paraminfo = flyc_param_request_2015_get_param_info_by_hash(po, ser, po.param_name)\n    # Now set the parameter value\n    param_val = flyc_param_str_to_value(po, paraminfo, po.param_value)\n    rplpayload = flyc_param_request_2015_write_param_value_by_hash(po, ser, po.param_name, param_val)\n    # Print the result data\n    flyc_param_request_2015_print_response(po, None, None, True)\n    flyc_param_request_2015_print_response(po, None, paraminfo, rplpayload)\n\n\ndef do_flyc_param_request_2017_list(po, ser):\n    \"\"\" List flyc parameters on platforms with multiple parameter tables.\n\n        Tested on the following platforms and FW versions:\n        WM100_FW_V01.00.0900 (2018-07-23)\n    \"\"\"\n    do_assistant_unlock(po, ser)\n    # Get info on tables first, so we can flatten them\n    table_attribs = []\n    for table_no in range(0, 255):\n        tab_attr = flyc_param_request_2017_get_table_attribs(po, ser, table_no)\n        if sizeof(tab_attr) <= 2:\n            if (po.verbose > 0):\n                print(\"Response on table no {:d} indicates end of list.\".format(table_no))\n            break\n        table_attribs.append(tab_attr)\n    # Print result data header\n    flyc_param_request_2017_print_response(po, True, None, None)\n    idx = 0\n    for tab_attr in table_attribs:\n        for tbl_idx in range(0, tab_attr.entries_num):\n            if idx > po.start+po.count:\n                break\n            if idx >= po.start:\n                rplpayload = flyc_param_request_2017_get_param_info_by_index(po, ser, tab_attr.table_no, tbl_idx)\n                if sizeof(rplpayload) <= 4:\n                    eprint(\"Response on parameter {:d} indicates end of list despite larger size reported.\".format(idx))\n                    # do not break - this may be error with one specific parameter\n                else:\n                    # Print the result data\n                    flyc_param_request_2017_print_response(po, idx, rplpayload, None)\n            idx += 1\n\n\ndef do_flyc_param_request_2017_get(po, ser):\n    \"\"\" Get flyc parameter value on platforms with multiple parameter tables.\n\n        Tested on the following platforms and FW versions:\n        WM100_FW_V01.00.0900 (2018-07-23)\n    \"\"\"\n    do_assistant_unlock(po, ser)\n    # Get param info first, so we know type and size\n    paraminfo = flyc_param_request_2015_get_param_info_by_hash(po, ser, po.param_name)\n    # Now get the parameter value\n    rplpayload = flyc_param_request_2015_read_param_value_by_hash(po, ser, po.param_name)\n    # Print the result data\n    flyc_param_request_2015_print_response(po, None, None, True)\n    flyc_param_request_2015_print_response(po, None, paraminfo, rplpayload)\n\n\ndef flyc_param_request_2017_get_param_info_by_name_search(po, ser, param_name):\n    # Get info on tables first, so we can flatten them\n    table_attribs = []\n    for table_no in range(0, 255):\n        tab_attr = flyc_param_request_2017_get_table_attribs(po, ser, table_no)\n        if sizeof(tab_attr) <= 2:\n            if (po.verbose > 0):\n                print(\"Response on table no {:d} indicates end of list.\".format(table_no))\n            break\n        table_attribs.append(tab_attr)\n    # Now find table location of our param\n    idx = 0\n    for tab_attr in table_attribs:\n        for tbl_idx in range(0, tab_attr.entries_num):\n            rplpayload = flyc_param_request_2017_get_param_info_by_index(po, ser, tab_attr.table_no, tbl_idx)\n            if sizeof(rplpayload) <= 4:\n                eprint(\"Response on parameter {:d} indicates end of list despite larger size reported.\".format(idx))\n                # do not break - this may be error with one specific parameter\n            elif rplpayload.name.decode(\"utf-8\") == param_name:\n                return rplpayload\n            idx += 1\n    raise LookupError(\"Parameter not found during parameter info by name search request.\")\n    return None # unreachble\n\n\ndef do_flyc_param_request_2017_get_alt(po, ser):\n    \"\"\" Get flyc parameter value on platforms with multiple parameter tables, alternative way.\n\n        Tested on the following platforms and FW versions:\n        WM100_FW_V01.00.0900 (2018-07-26)\n    \"\"\"\n    do_assistant_unlock(po, ser)\n    # Get param info first, so we know type and size\n    paraminfo = flyc_param_request_2017_get_param_info_by_name_search(po, ser, po.param_name)\n    # Now get the parameter value\n    rplpayload = flyc_param_request_2017_read_param_value_by_index(po, ser, paraminfo.table_no, paraminfo.param_index)\n    # Print the result data\n    flyc_param_request_2017_print_response(po, None, None, True)\n    flyc_param_request_2017_print_response(po, None, paraminfo, rplpayload)\n\n\ndef do_flyc_param_request_2017_set(po, ser):\n    \"\"\" Set new value of flyc parameter on platforms with multiple parameter tables.\n\n        Tested on the following platforms and FW versions:\n        WM100_FW_V01.00.0900 (2018-07-23)\n    \"\"\"\n    do_assistant_unlock(po, ser)\n    # Get param info first, so we know type and size\n    paraminfo = flyc_param_request_2015_get_param_info_by_hash(po, ser, po.param_name)\n    # Now set the parameter value\n    param_val = flyc_param_str_to_value(po, paraminfo, po.param_value)\n    rplpayload = flyc_param_request_2015_write_param_value_by_hash(po, ser, po.param_name, param_val)\n    # Print the result data\n    flyc_param_request_2015_print_response(po, None, None, True)\n    flyc_param_request_2015_print_response(po, None, paraminfo, rplpayload)\n\n\ndef do_flyc_param_request_2017_set_alt(po, ser):\n    \"\"\" Set new value of flyc parameter on platforms with multiple parameter tables, alternative way.\n\n        Tested on the following platforms and FW versions:\n        WM100_FW_V01.00.0900 (2018-07-27)\n    \"\"\"\n    do_assistant_unlock(po, ser)\n    # Get param info first, so we know type and size\n    paraminfo = flyc_param_request_2017_get_param_info_by_name_search(po, ser, po.param_name)\n    # Now set the parameter value\n    param_val = flyc_param_str_to_value(po, paraminfo, po.param_value)\n    rplpayload = flyc_param_request_2017_write_param_value_by_index(po, ser, paraminfo.table_no, paraminfo.param_index, param_val)\n    # Print the result data\n    flyc_param_request_2017_print_response(po, None, None, True)\n    flyc_param_request_2017_print_response(po, None, paraminfo, rplpayload)\n\n\ndef do_flyc_param_request(po):\n    ser = open_serial_port(po)\n\n    if po.product.value >= PRODUCT_CODE.WM330.value:\n        if po.subcmd == FLYC_PARAM_CMD.LIST:\n            do_flyc_param_request_2017_list(po, ser)\n        elif po.subcmd == FLYC_PARAM_CMD.GET:\n            if not po.alt:\n                do_flyc_param_request_2017_get(po, ser)\n            else:\n                do_flyc_param_request_2017_get_alt(po, ser)\n        elif po.subcmd == FLYC_PARAM_CMD.SET:\n            if not po.alt:\n                do_flyc_param_request_2017_set(po, ser)\n            else:\n                do_flyc_param_request_2017_set_alt(po, ser)\n        else:\n            raise ValueError(\"Unrecognized {:s} command: {:s}.\".format(po.svcmd.name, po.subcmd.name))\n    else:\n        if po.subcmd == FLYC_PARAM_CMD.LIST:\n            do_flyc_param_request_2015_list(po, ser)\n        elif po.subcmd == FLYC_PARAM_CMD.GET:\n            do_flyc_param_request_2015_get(po, ser)\n        elif po.subcmd == FLYC_PARAM_CMD.SET:\n            do_flyc_param_request_2015_set(po, ser)\n        else:\n            raise ValueError(\"Unrecognized {:s} command: {:s}.\".format(po.svcmd.name, po.subcmd.name))\n\n    ser.close()\n\n\ndef gimbal_calib_request_spark(po, ser, cmd):\n    payload = dupc.DJIPayload_Gimbal_CalibRq()\n    payload.command = cmd.value\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a 71 92 00 04 08 01 11 2c 70\"))\n\n    pktrpl, pktreq = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.GIMBAL, 0,\n      ACK_TYPE.ACK_BEFORE_EXEC,\n      CMD_SET_TYPE.ZENMUSE, 0x08,\n      payload, seqnum_check=False)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on calibration command {:s} request.\".format(cmd.name))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized response to calibration command {:s} request.\".format(cmd.name))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload, pktreq\n\ndef gimbal_calib_request_spark_receive_progress(po, ser, pktreq):\n\n    pktrpl = receive_reply_for_request(po, ser, pktreq, seqnum_check=False)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No progress tick on calibration request.\")\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized progress tick to calibration request.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed progress tick - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload\n\n\ndef gimbal_calib_request_spark_monitor_progress(po, ser, first_rplpayload, pktreq, expect_duration, pass_values):\n    if po.dry_test:\n        # use to test the code without a drone; packets are different for each calibration\n        if pass_values[0] == 16:\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a 71 92 00 04 08 01 11 2c 70\"))\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a 01 a3 00 04 08 10 07 65 5b\"))\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a 19 6d 00 04 08 01 11 6f f7\"))\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a 01 a3 00 04 08 10 07 65 5b\"))\n            # Final packet marking end of calibration\n            ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a f9 e0 00 04 08 10 01 42 79\"))\n        else: # pass_values[0] == 40\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a f1 df 00 04 08 14 0a 44 84\"))\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a f9 ff 00 04 08 19 0c 86 0a\"))\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a a9 1d 00 04 08 1b 0f 27 f3\"))\n            for x in range(4):\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a e1 80 00 04 08 28 0d d8 27\"))\n            # Final packet marking end of calibration\n            ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a 89 b0 00 04 08 28 01 0d 50\"))\n\n    rplpayload = first_rplpayload\n    curr_time = time.time()\n    # As timeout, use expected time + 50%\n    start_time = curr_time\n    timeout_time = curr_time + expect_duration * 1.5 / 1000\n    report_time = curr_time + expect_duration / 10000 # Aim at 10 reports in the run\n    ticks_received = 0\n    last_tick_time = curr_time\n    result = \"UNSURE\"\n    while True:\n\n        if rplpayload is not None:\n            ticks_received = ticks_received + 1\n            last_tick_time = curr_time\n            if rplpayload.status1 == pass_values[0] and rplpayload.status2 == pass_values[1]:\n                print(\"Concluding report received; calibration finished.\")\n                result = \"PASS\"\n                break\n\n        if curr_time > timeout_time:\n            print(\"Calibration time exceeded; calibration must have ended.\")\n            break\n\n        if curr_time > last_tick_time + expect_duration / 4000:\n            print(\"Progress reports stopped; calibration must have ended.\")\n            break\n\n        if curr_time > report_time + expect_duration / 10000:\n            print(\"Progress: received {:d} reports.\".format(ticks_received))\n            report_time = report_time + expect_duration / 10000\n\n        rplpayload = gimbal_calib_request_spark_receive_progress(po, ser, pktreq)\n\n        curr_time = time.time()\n\n    print(\"Summary: took {:0.1f} sec; received {:d} reports; result: {:s}.\".format(curr_time-start_time,ticks_received,result))\n\n\ndef do_gimbal_calib_request_spark_joint_coarse(po, ser):\n    \"\"\" Initiates Spark Gimbal Joint Coarse calibration.\n\n        Tested on the following platforms and FW versions:\n        WM100_FW_V01.00.0900 (2018-07-27)\n        WM230_FW_unknown (2019-03-31, report from bunchofbradys@github)\n        WM240_FW_V01.00.0200 (2020-02-28, report from Andris8888@slack)\n    \"\"\"\n\n    print(\"\\nInfo: The Gimbal will move through its boundary positions, then it will fine-tune its central position. It will take around 15 seconds.\\n\")\n\n    rplpayload, pktreq = gimbal_calib_request_spark(po, ser, dupc.DJIPayload_Gimbal_CalibCmd.JointCoarse)\n\n    print(\"Calibration process started; monitoring progress.\")\n\n    gimbal_calib_request_spark_monitor_progress(po, ser, rplpayload, pktreq, 15000, [16, 1])\n\n\ndef do_gimbal_calib_request_spark_linear_hall(po, ser):\n    \"\"\" Initiates Spark Gimbal Linear Hall calibration.\n\n        Tested on the following platforms and FW versions:\n        NONE\n    \"\"\"\n\n    print(\"\\nInfo: The Gimbal will slowly move through all positions in all axes, several times. It will take around 30 seconds.\\n\")\n\n    rplpayload, pktreq = gimbal_calib_request_spark(po, ser, dupc.DJIPayload_Gimbal_CalibCmd.LinearHall)\n\n    print(\"Calibration process started; monitoring progress.\")\n\n    gimbal_calib_request_spark_monitor_progress(po, ser, rplpayload, pktreq, 30000, [40, 1])\n\n\ndef gimbal_calib_request_p3x(po, ser):\n    # We don't really need any payload, but that one byte won't influence anything, so we may keep it\n    payload = dupc.DJIPayload_Gimbal_CalibRq()\n    payload.command = 0\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        pass # gimbal does not offer response to the auto calib request\n\n    # in P3X the response is hard-coded to go to MOBILE_APP, so we won't receive it\n    # nut we need to request it anyway - otherwise calibration will not start\n    pktrpl, pktreq = send_request_and_receive_reply(po, ser,\n      COMM_DEV_TYPE.GIMBAL, 0,\n      ACK_TYPE.ACK_BEFORE_EXEC,\n      CMD_SET_TYPE.ZENMUSE, 0x08,\n      payload, seqnum_check=False, retry_num=1)\n\n    if pktrpl is None:\n        # Allow no response as only MOBILE_APP can get it\n        #raise ConnectionError(\"No response on Auto Calibration request.\")\n        return None, pktreq\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized response to Auto Calibration request.\")\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload, pktreq\n\n\ndef do_gimbal_calib_request_p3x_autocal(po, ser):\n    \"\"\" Initiates Phantom 3 Gimbal Automatic Calibration.\n\n        In Ph3, this only calibrates yaw axis, which uses magnetic sensors.\n        Pitch and roll have resistive sensors, and these are not affected;\n        if there is misalignment in them, that usually means damaged potentiometer\n        or bent aluminium arm, not something you can solve with calibration.\n\n        Tested on the following platforms and FW versions:\n        None\n    \"\"\"\n\n    print(\"\\nInfo: The Gimbal will average its readings without movement, \"\n          \"then it will move Yaw arm through its boundary positions. \"\n          \"Then it will do limited pitch movement. \"\n          \"End of calibration will be marked by two beeps from gimbal motors. \"\n          \"It will take around 15 seconds.\\n\")\n\n    rplpayload, pktreq = gimbal_calib_request_p3x(po, ser)\n\n    print(\"Calibration process started; do not touch the drone for 15 seconds.\")\n    time.sleep(5)\n    print(\"Monitoring the progress is only possibe from a mobile app, so exiting.\")\n\n\ndef do_gimbal_calib_request(po):\n    ser = open_serial_port(po)\n\n    if po.product.value >= PRODUCT_CODE.WM220.value:\n        if po.subcmd == GIMBAL_CALIB_CMD.JOINTCOARSE:\n            do_gimbal_calib_request_spark_joint_coarse(po, ser)\n        elif po.subcmd == GIMBAL_CALIB_CMD.LINEARHALL:\n            do_gimbal_calib_request_spark_linear_hall(po, ser)\n        else:\n            raise ValueError(\"Unrecognized {:s} command: {:s}.\".format(po.svcmd.name, po.subcmd.name))\n    elif po.product.value >= PRODUCT_CODE.P330.value:\n        if po.subcmd == GIMBAL_CALIB_CMD.JOINTCOARSE:\n            do_gimbal_calib_request_p3x_autocal(po, ser)\n        elif po.subcmd == GIMBAL_CALIB_CMD.LINEARHALL:\n            raise ValueError(\"Gimbal in selected platform does not have Hall Effect sensors.\")\n        else:\n            raise ValueError(\"Unrecognized {:s} command: {:s}.\".format(po.svcmd.name, po.subcmd.name))\n    else:\n        raise ValueError(\"Calibration for selected platform is not supported.\")\n\n    ser.close()\n\n\ndef general_encrypt_get_state_request_p3x(po, ser, receiver_type, cmd):\n    \"\"\" Sends Encrypt GetChipState or Encrypt GetoduleState request.\n    \"\"\"\n    payload = dupc.DJIPayload_General_EncryptGetStateRq()\n    payload.command = cmd.value\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        if cmd == dupc.DJIPayload_General_EncryptCmd.GetChipState:\n            ser.mock_data_for_read(bytes.fromhex(\"55 2d 04 f2 01 0a e9 ab c0 00 30 00 07 30 34 38 \"\n                  \"4c 41 41 31 45 4a 51 30 34 38 4c 41 41 31 45 4a 51 30 34 38 4c 41 41 31 45 4a 51 94 fd\"))\n        else: # dupc.DJIPayload_General_EncryptCmd.GetModuleState\n            if receiver_type == COMM_DEV_TYPE.CAMERA:\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 01 0a ad 00 c0 00 30 00 03 84 5b\"))\n            elif receiver_type == COMM_DEV_TYPE.GIMBAL:\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 04 0a c5 10 80 00 30 00 33 e4 e1\"))\n            else: # COMM_DEV_TYPE.LB_DM3XX_SKY\n                ser.mock_data_for_read(bytes.fromhex(\"55 0f 04 a2 08 0a c6 0a c0 00 30 00 03 ba 92\"))\n\n    pktrpl, pktreq = send_request_and_receive_reply(po, ser,\n      receiver_type, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.GENERAL, 0x30,\n      payload, seqnum_check=True)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response on Encrypt {:s} request.\".format(cmd.name))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized response to Encrypt {:s} request.\".format(cmd.name))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload, pktreq\n\n\ndef general_encrypt_configure_request_p3x(po, ser, receiver_type, target_type, boardsn, enckey):\n    \"\"\" Sends Encrypt Pair/Configure request.\n    \"\"\"\n    payload = dupc.DJIPayload_General_EncryptConfigRq()\n    payload.command = dupc.DJIPayload_General_EncryptCmd.Config.value\n    payload.oper_type = dupc.DJIPayload_General_EncryptOperType.WriteAll.value\n    payload.config_magic = (c_ubyte * 8).from_buffer_copy(bytes([0xF0, 0xBD, 0xE3, 0x06, 0x81, 0x3E, 0x85, 0xCB]))\n    payload.mod_type = target_type.value\n    payload.board_sn = (c_ubyte * 10).from_buffer_copy(boardsn)\n    payload.key = (c_ubyte * 32).from_buffer_copy(enckey)\n    # MD5 of the board sn and key\n    md5_sum = hashlib.md5()\n    md5_sum.update(payload.board_sn)\n    md5_sum.update(payload.key)\n    payload.secure_num = (c_ubyte * 16).from_buffer_copy(md5_sum.digest())\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        if receiver_type == COMM_DEV_TYPE.CAMERA:\n            ser.mock_data_for_read(bytes.fromhex(\"55 0e 04 66 01 0a 00 ff 80 00 30 00 fa 57\"))\n        elif receiver_type == COMM_DEV_TYPE.GIMBAL:\n            ser.mock_data_for_read(bytes.fromhex(\"55 0e 04 66 04 0a 00 ff 80 00 30 00 9b c0\"))\n        else: # COMM_DEV_TYPE.LB_DM3XX_SKY\n            ser.mock_data_for_read(bytes.fromhex(\"55 0e 04 66 08 0a 00 ff 80 00 30 00 f9 fb\"))\n\n    pktrpl, pktreq = send_request_and_receive_reply(po, ser,\n      receiver_type, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.GENERAL, 0x30,\n      payload, seqnum_check=True)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response from {:s} during Encrypt Pair {:s} request.\".format(receiver_type.name, target_type.name))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized response from {:s} during Encrypt Pair {:s} request.\".format(receiver_type.name, target_type.name))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload, pktreq\n\n\ndef general_encrypt_configure_triple_request_p3x(po, ser, receiver_type, m01_boardsn, m01_enckey, m04_boardsn, m04_enckey, m08_boardsn, m08_enckey):\n    \"\"\" Sends Triple Encrypt Pair/Configure request.\n    \"\"\"\n    payload = dupc.DJIPayload_General_EncryptConfig3Rq()\n    payload.command = dupc.DJIPayload_General_EncryptCmd.Config.value\n    payload.oper_type = dupc.DJIPayload_General_EncryptOperType.WriteAll.value\n    payload.config_magic = (c_ubyte * 8).from_buffer_copy(bytes([0xF0, 0xBD, 0xE3, 0x06, 0x81, 0x3E, 0x85, 0xCB]))\n    payload.m01_mod_type = COMM_DEV_TYPE.CAMERA.value\n    payload.m01_board_sn = (c_ubyte * 10).from_buffer_copy(m01_boardsn)\n    payload.m01_key = (c_ubyte * 32).from_buffer_copy(m01_enckey)\n    payload.m04_mod_type = COMM_DEV_TYPE.GIMBAL.value\n    payload.m04_board_sn = (c_ubyte * 10).from_buffer_copy(m04_boardsn)\n    payload.m04_key = (c_ubyte * 32).from_buffer_copy(m04_enckey)\n    payload.m08_mod_type = COMM_DEV_TYPE.LB_DM3XX_SKY.value\n    payload.m08_board_sn = (c_ubyte * 10).from_buffer_copy(m08_boardsn)\n    payload.m08_key = (c_ubyte * 32).from_buffer_copy(m08_enckey)\n    # MD5 of the board sn and key\n    md5_sum = hashlib.md5()\n    md5_sum.update(payload.m01_board_sn)\n    md5_sum.update(payload.m01_key)\n    payload.m01_secure_num = (c_ubyte * 16).from_buffer_copy(md5_sum.digest())\n    md5_sum = hashlib.md5()\n    md5_sum.update(payload.m04_board_sn)\n    md5_sum.update(payload.m04_key)\n    payload.m04_secure_num = (c_ubyte * 16).from_buffer_copy(md5_sum.digest())\n    md5_sum = hashlib.md5()\n    md5_sum.update(payload.m08_board_sn)\n    md5_sum.update(payload.m08_key)\n    payload.m08_secure_num = (c_ubyte * 16).from_buffer_copy(md5_sum.digest())\n\n    if (po.verbose > 2):\n        print(\"Prepared request - {:s}:\".format(type(payload).__name__))\n        print(payload)\n\n    if po.dry_test:\n        # use to test the code without a drone\n        if receiver_type == COMM_DEV_TYPE.CAMERA:\n            ser.mock_data_for_read(bytes.fromhex(\"55 0e 04 66 01 0a 00 ff 80 00 30 00 fa 57\"))\n\n    pktrpl, pktreq = send_request_and_receive_reply(po, ser,\n      receiver_type, 0,\n      ACK_TYPE.ACK_AFTER_EXEC,\n      CMD_SET_TYPE.GENERAL, 0x30,\n      payload, seqnum_check=True)\n\n    if pktrpl is None:\n        raise ConnectionError(\"No response from {:s} during Triple Encrypt Pair request.\".format(receiver_type.name))\n\n    rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n    rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n\n    if (rplpayload is None):\n        raise ConnectionError(\"Unrecognized response from {:s} during Triple Encrypt Pair request.\".format(receiver_type.name))\n\n    if (po.verbose > 2):\n        print(\"Parsed response - {:s}:\".format(type(rplpayload).__name__))\n        print(rplpayload)\n\n    return rplpayload, pktreq\n\n\ndef do_camera_calib_request_p3x_encryptcheck(po, ser):\n    \"\"\" Verifies Phantom 3 Camera Encryption Pairing.\n\n        Tested on the following platforms and FW versions:\n        P3X_FW_V01.07.0060 (2018-08-18)\n    \"\"\"\n\n    result = True\n    # Get module states; if state_flags 0x01 and 0x02 are set, then that module has working encryption\n\n    modulestate, _ = general_encrypt_get_state_request_p3x(po, ser,\n          COMM_DEV_TYPE.CAMERA, dupc.DJIPayload_General_EncryptCmd.GetModuleState)\n\n    if (modulestate.state_flags & (0x01|0x02)) == (0x01|0x02):\n        print(\"Confirmed proper key storage within {:s}.\".format(COMM_DEV_TYPE.CAMERA.name))\n    elif (modulestate.state_flags & (0x01|0x02)) == (0x01):\n        print(\"Inconsistent key storage within {:s}.\".format(COMM_DEV_TYPE.CAMERA.name))\n        result = False\n    else: # This means no flag set (it is impossible to get only 0x02 without 0x01)\n        print(\"Uninitialized key verification system within {:s}.\".format(COMM_DEV_TYPE.CAMERA.name))\n        result = False\n\n    # When LB_DM3XX_SKY receives GetModuleState command, it sends DoEncrypt to\n    # CAMERA and compares result with encryption using local key.bin\n    modulestate, _ = general_encrypt_get_state_request_p3x(po, ser,\n          COMM_DEV_TYPE.LB_DM3XX_SKY, dupc.DJIPayload_General_EncryptCmd.GetModuleState)\n\n    if (modulestate.state_flags & (0x01|0x02)) == (0x01|0x02):\n        print(\"Confirmed proper communication between {:s} and {:s}.\"\n          .format(COMM_DEV_TYPE.LB_DM3XX_SKY.name, COMM_DEV_TYPE.CAMERA.name))\n    elif (modulestate.state_flags & (0x01|0x02)) == (0x01):\n        print(\"Inconsistent key encountered between {:s} and {:s}.\"\n          .format(COMM_DEV_TYPE.LB_DM3XX_SKY.name, COMM_DEV_TYPE.CAMERA.name))\n        result = False\n    else: # This means no flag set (it is impossible to get only 0x02 without 0x01)\n        print(\"No key file stored within {:s}.\".format(COMM_DEV_TYPE.LB_DM3XX_SKY.name))\n        result = False\n\n    modulestate, _ = general_encrypt_get_state_request_p3x(po, ser,\n          COMM_DEV_TYPE.GIMBAL, dupc.DJIPayload_General_EncryptCmd.GetModuleState)\n\n    if (modulestate.state_flags & (0x01|0x02)) == (0x01|0x02):\n        print(\"Confirmed proper key storage within {:s}.\".format(COMM_DEV_TYPE.GIMBAL.name))\n    elif (modulestate.state_flags & (0x01|0x02)) == (0x01):\n        print(\"Inconsistent key storage within {:s}.\".format(COMM_DEV_TYPE.GIMBAL.name))\n        result = False\n    else: # This means no flag set (it is impossible to get only 0x02 without 0x01)\n        print(\"Uninitialized key verification system within {:s}.\".format(COMM_DEV_TYPE.GIMBAL.name))\n        result = False\n\n    # Final recommendation\n    if result:\n        print(\"Encryption pairing NOT recommended.\")\n    else:\n        print(\"Encryption pairing NEEDED.\")\n\n\ndef do_camera_calib_request_p3x_encryptpair(po, ser):\n    \"\"\" Initiates Phantom 3 Camera Encryption Pairing.\n\n        Tested on the following platforms and FW versions:\n        None\n    \"\"\"\n\n    print(\"\\nInfo: The tool will retrieve Board Serial Numbers of {:s}, {:s} and {:s}; \".format(\n            COMM_DEV_TYPE.CAMERA.name, COMM_DEV_TYPE.GIMBAL.name, COMM_DEV_TYPE.LB_DM3XX_SKY.name) +\n        \"then it will write new encryption key to some of them. It will take around 1 second.\\n\")\n\n    print(\"WARNING: Do not use this command unless you know what you're doing! If SHA204 chip in your \"\n        \"gimbal has Config Zone locked (and all drones have it locked during production), this command \"\n        \"will just make encryption config inconsistent between the Camera and the SHA204 chip. \"\n        \"The camera will then enter Authority Level 0 and will ignore most commands.\\n\")\n\n    # Camera ChipState contains board serial numbersfor all 3 components\n    chipstate, _ = general_encrypt_get_state_request_p3x(po, ser,\n          COMM_DEV_TYPE.CAMERA, dupc.DJIPayload_General_EncryptCmd.GetChipState)\n\n    if not po.force:\n        raise ValueError(\"Use '--force' parameter if you really want to write new keys to the device.\")\n\n    print(\"Retrieved Board Serial Numbers; flashing new encryption key.\")\n\n    rplpayload, pktreq = general_encrypt_configure_triple_request_p3x(po, ser,\n          COMM_DEV_TYPE.CAMERA, chipstate.m01_boardsn, po.pairkey, chipstate.m04_boardsn,\n          po.pairkey, chipstate.m08_boardsn, po.pairkey)\n    if rplpayload.status != 0:\n        raise ValueError(\"Failure status {:d} returned from {:s} during Triple Encrypt Pair request.\"\n          .format(rplpayload.status,COMM_DEV_TYPE.CAMERA.name))\n\n    if False: # Do NOT send EncryptConfig to gimbal - camera should have sent it already\n        rplpayload, pktreq = general_encrypt_configure_request_p3x(po, ser,\n              COMM_DEV_TYPE.GIMBAL, COMM_DEV_TYPE.GIMBAL, chipstate.m04_boardsn, po.pairkey)\n        if rplpayload.status != 0:\n            raise ValueError(\"Failure status {:d} returned from {:s} during Encrypt Pair {:s} request.\"\n              .format(rplpayload.status,COMM_DEV_TYPE.GIMBAL.name,COMM_DEV_TYPE.GIMBAL.name))\n\n    if False: # Do NOT send EncryptConfig to DaVinci - camera should have sent it\n        rplpayload, pktreq = general_encrypt_configure_request_p3x(po, ser,\n              COMM_DEV_TYPE.LB_DM3XX_SKY, COMM_DEV_TYPE.LB_DM3XX_SKY, chipstate.m08_boardsn, po.pairkey)\n        if rplpayload.status != 0:\n            raise ValueError(\"Failure status {:d} returned from {:s} during Encrypt Pair {:s} request.\"\n              .format(rplpayload.status,COMM_DEV_TYPE.LB_DM3XX_SKY.name,COMM_DEV_TYPE.LB_DM3XX_SKY.name))\n\n    print(\"Pairing complete; try EncryptCheck command to verify.\")\n\n\ndef do_camera_calib_request(po):\n    ser = open_serial_port(po)\n\n    if po.product.value >= PRODUCT_CODE.WM100.value:\n        raise ValueError(\"Calibration for selected platform is not supported.\")\n    elif po.product.value >= PRODUCT_CODE.WM610.value:\n        if po.subcmd == CAMERA_CALIB_CMD.ENCRYPTCHECK:\n            do_camera_calib_request_p3x_encryptcheck(po, ser)\n        elif po.subcmd == CAMERA_CALIB_CMD.ENCRYPTPAIR:\n            if po.pairkey is None:\n                po.pairkey = default_32byte_key\n            if len(po.pairkey) != 32:\n                raise ValueError(\"Length of encryption key must be 32 bytes, not {:d}.\".format(len(po.pairkey)))\n            do_camera_calib_request_p3x_encryptpair(po, ser)\n        else:\n            raise ValueError(\"Unrecognized {:s} command: {:s}.\".format(po.svcmd.name, po.subcmd.name))\n    else:\n        raise ValueError(\"Calibration for selected platform is not supported.\")\n\n    ser.close()\n\n\ndef parse_product_code(s):\n    \"\"\" Parses product code string in known formats.\n    \"\"\"\n    s = s.upper()\n    if s in ALT_PRODUCT_CODE:\n        s = ALT_PRODUCT_CODE[s]\n    return s\n\n\ndef main():\n    \"\"\" Main executable function.\n\n      Its task is to parse command line options and call a function which performs serial communication.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('--port', type=str,\n            help=\"the serial port to write to and read from\")\n\n    subparser.add_argument('--bulk', action='store_true',\n            help=\"use usb bulk instead of serial connection\")\n\n    parser.add_argument('product', metavar='product',\n            choices=[i.name for i in PRODUCT_CODE], type=parse_product_code,\n            help=\"target product code name; one of: {:s}\"\n              .format(','.join(i.name for i in PRODUCT_CODE)))\n\n    parser.add_argument('-b', '--baudrate', default=9600, type=int,\n            help=\"the baudrate to use for the serial port (default is %(default)s)\")\n\n    parser.add_argument('-w', '--timeout', default=500, type=int,\n            help=\"how long to wait for answer, in miliseconds (default is %(default)s)\")\n\n    parser.add_argument('--dry-test', action='store_true',\n            help=(\"internal testing mode; do not use real serial interface \"\n              \"and use template answers from the drone\"))\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n            help=\"increases verbosity level; max level is set by -vvv\")\n\n    parser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n              .format(version=__version__, author=__author__),\n            help=\"display version information and exit\")\n\n    subparsers = parser.add_subparsers(dest='svcmd', metavar='command', required=True,\n            help=\"service command\")\n\n    subpar_flycpar = subparsers.add_parser('FlycParam',\n            help=\"flight controller parameters handling\")\n\n    subpar_flycpar_subcmd = subpar_flycpar.add_subparsers(dest='subcmd', required=True,\n            help=\"Flyc Param Command\")\n\n    subpar_flycpar_list = subpar_flycpar_subcmd.add_parser('list',\n            help=\"list FlyC Parameters\")\n    subpar_flycpar_list.add_argument('-s', '--start', default=0, type=int,\n            help=\"starting index\")\n    subpar_flycpar_list.add_argument('-c', '--count', default=100, type=int,\n            help=\"amount of entries to show\")\n    subpar_flycpar_list.add_argument('-f', '--fmt', default='simple', type=str,\n            choices=['simple', '1line', '2line', 'tab', 'csv'],\n            help=\"output format\")\n\n    subpar_flycpar_get = subpar_flycpar_subcmd.add_parser('get',\n            help=\"get value of FlyC Param\")\n    subpar_flycpar_get.add_argument('param_name', type=str,\n            help=\"name string of the requested parameter\")\n    subpar_flycpar_get.add_argument('--alt', action='store_true',\n            help=\"use alternative way; try in case the normal one does not work\")\n    subpar_flycpar_get.add_argument('-f', '--fmt', default='simple', type=str,\n            choices=['simple', '1line', '2line', 'tab', 'csv'],\n            help=\"output format\")\n\n    subpar_flycpar_set = subpar_flycpar_subcmd.add_parser('set',\n            help=\"update value of FlyC Param\")\n    subpar_flycpar_set.add_argument('param_name', type=str,\n            help=\"name string of the parameter\")\n    subpar_flycpar_set.add_argument('param_value', type=str,\n            help=\"new value of the parameter\")\n    subpar_flycpar_set.add_argument('--alt', action='store_true',\n            help=\"use alternative way; try in case the normal one does not work\")\n    subpar_flycpar_set.add_argument('-f', '--fmt', default='simple', type=str,\n            choices=['simple', '1line', '2line', 'tab', 'csv'],\n            help=\"output format\")\n\n    subpar_gimbcal = subparsers.add_parser('GimbalCalib',\n            help=\"gimbal calibration options\")\n\n    subpar_gimbcal_subcmd = subpar_gimbcal.add_subparsers(dest='subcmd', required=True,\n            help=\"gimbal calibration command\")\n\n    subpar_gimbcal_coarse = subpar_gimbcal_subcmd.add_parser('JointCoarse',\n            help=(\"gimbal Joint Coarse calibration; to be performed after \"\n              \"gimbal has been fixed or replaced, or is not straight\"))\n\n    subpar_gimbcal_hall = subpar_gimbcal_subcmd.add_parser('LinearHall',\n            help=(\"gimbal Linear Hall calibration; to be performed always \"\n              \"after JointCoarse calibration\"))\n\n    subpar_camcal = subparsers.add_parser('CameraCalib',\n            help=\"camera calibration options\")\n\n    subpar_camcal_subcmd = subpar_camcal.add_subparsers(dest='subcmd', required=True,\n            help=\"camera calibration Command\")\n\n    subpar_camcal_encryptcheck = subpar_camcal_subcmd.add_parser('EncryptCheck',\n            help=(\"verify encryption pairing between Camera, Gimbal and DM3xx; \"\n              \"returns whether pairing is required\"))\n\n    subpar_camcal_encryptpair = subpar_camcal_subcmd.add_parser('EncryptPair',\n            help=(\"set encryption key to pair the Camera, Gimbal or DM3xx; \"\n              \"to be performed after replacing software in any of these chips; \"\n              \"UNTESTED - may not work\"))\n\n    subpar_camcal_encryptpair.add_argument('-k', '--pairkey', type=bytes.fromhex,\n            help=\"provide 32-byte pairing key as hex string\")\n\n    subpar_camcal_encryptpair.add_argument('--force', action='store_true',\n            help=(\"forces the keys to be written, even if this could \"\n              \"lead to inconsistent keys due to their read-only copy\"))\n\n    po = parser.parse_args()\n\n    po.product = PRODUCT_CODE.from_name(po.product)\n    po.svcmd = SERVICE_CMD.from_name(po.svcmd)\n\n    if po.svcmd == SERVICE_CMD.FlycParam:\n        po.subcmd = FLYC_PARAM_CMD.from_name(po.subcmd.upper())\n        do_flyc_param_request(po)\n    elif po.svcmd == SERVICE_CMD.GimbalCalib:\n        po.subcmd = GIMBAL_CALIB_CMD.from_name(po.subcmd.upper())\n        do_gimbal_calib_request(po)\n    elif po.svcmd == SERVICE_CMD.CameraCalib:\n        po.subcmd = CAMERA_CALIB_CMD.from_name(po.subcmd.upper())\n        do_camera_calib_request(po)\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "comm_sbs_bqctrl.py",
          "type": "blob",
          "size": 151.3486328125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Smart Battery System communication tool.\n\nThis tool allows to interact with chips designed based on Smart Battery Data\nSpecification. It also supports some extensions to that specification\nimplemented by Texas Instruments in their BQ series gas gauge chips.\n\nUsage of this tool requires connection to SMBus lines (SDA,SCL,GND) of the\nSBS-compatible chip. SMBus communication uses I2C as a base, so most devices\nwith I2C bus can be used to establish the communication.\n\nThis tool was written with intent to be used on Raspberry Pi and its I2C bus.\nUsing a different device will require slight modifications to the code.\n\nYou do not need the TI EV2300 programmer to use this script.\n\nTo get address of the device, you may use `i2cdetect`. Don't be scared about\nthe interactive messages, SBS is a well defined protocol which isn't easy to\nbreak, especially when the chip is sealed. Probing will not accidently result\nin a packet which disables the battery forever.\n\nIf the battery already has I2C master device on the bus (like uC on battery\nboard), try not to turn on the battery for use with this program. The SBS chip\nshould wake from sleep to answer on requests from this program, and if the\nbattery is turned on, the constant communication from internal master will\ninterfere with packets sent by this tool. It can also cause the battery\nto enter temporary SMBus error mode. To avoid that, don't even press the\nbattery button while it is connected to I2C interface.\n\nThough in case of connection issues, you may try re-running the script when\nbattery is on. The uC of some batteries keeps the line shorted to high state\nwhen turned off.\n\nAnother thing to try on issues is using your bus through both SMBus API and\nI2C API, using \"--bus\" parameter.\n\nIf the script shows \"OSError: [Errno 74] Bad message\", the very likely\ncause is invalid I2C speed. Check how to change baud rate of your\nI2C bus device. Baud rate of 100kbps should work. The EV2300 usually\nuses baud rate of 66kbps, though for some chips it switches to 30kbps.\n\nIf the script shows \"OSError: [Errno 121] Remote I/O error\", that means\nthe device did not respond to a command. It's hard to say if there was no\nresponse at all, or only to a specific part. This one may also happen when\ntrying to access priviliged command in sealed state. Make sure you can see\nthe device with 'i2cdetect'. If not, check physical connections. Make sure\nthat no other device interferes with the communication - it is known that\neven unpowered EV2300 programmer connected to the bus can interfere with\nsignals on lines.\n\nOn Raspberry Pi, the \"Remote I/O error\" can sometimes disappear after\nstarting GPIO deamon with high sampling rate, ie. `sudo pigpiod -s 1`.\nConstant probing of the line affects its impedance, which may sometimes\nlead to such unusual effects.\n\nThere is also \"OSError: [Errno 5] Input/output error\" which tend to happen\ninterchangeably with \"Remote I/O error\", but only if the other side responds\nto part of the message.\n\nFinally, remember that cheap I2C devices can sometimes get into unuseable\nstate - make sure you reboot the Raspberry Pi, or re-connect the USB stick,\nif logic signal changes are visible but I2C still refuses to detect anything.\n\nTested devices:\n(these devices are confirmed)\nBQ30z55 fw 0.36, Mavic Pro battery, 2021-02-15, mefistotelis\n\nDevices verified with spec:\n(should work, but not actually tested)\nBQ30z50, BQ30z554\n\nFor other devices, only basic SBS functions are expected to work.\nUsing chip-specific commands on them may have undesired effects.\nTo make sure a command is safe, check Reference Manual of the chip\nand make sure the command is defined in the same way as in spec of\none of tested devices.\n\n\"\"\"\n__version__ = \"0.2.1\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport re\nimport sys\nimport time\nimport enum\nimport types\nimport struct\nimport hashlib\nimport argparse\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\nclass DecoratedEnum(enum.Enum):\n    @classmethod\n    def from_name(cls, name):\n        for itm in cls:\n            if itm.name == name:\n                return itm\n        raise ValueError(\"{} is not a known value\".format(name))\n\n\nclass ImprovisedCommand(types.SimpleNamespace):\n    def __hash__(self):\n        return hash(self.value)\n\n\nclass CHIP_TYPE(DecoratedEnum):\n    \"\"\" Smart Battery System chip type\n    \"\"\"\n    AUTO\t\t= 0\n    SBS\t\t\t= 1\n    # Texas Instruments BQ chips; lower 16 bits are DeviceType\n    BQGENERIC\t= 0x010000\n    BQ20z45\t\t= 0x010450\n    BQ30z50\t\t= 0x010500\n    BQ30z55\t\t= 0x010550\n    BQ30z554\t= 0x010554\n    BQ20z65\t\t= 0x010650\n    BQ3050\t\t= 0x013050\n    BQ3060\t\t= 0x013060\n    BQ40z307\t= 0x014307 # hw marking bq9003; custom chip for DJI\n    BQ40370\t\t= 0x019db2\n    # supported by BatteryManagementStudio-1.3\n    BQ35100\t\t= 0x010100 # hw marking bq8035;\n    BQ34110\t\t= 0x010110 # hw marking bq8035;\n    BQ34210\t\t= 0x010210 # hw marking bq8101;\n    BQ27220\t\t= 0x010220 # hw marking bq8101;\n    BQ27320\t\t= 0x010320 # hw marking bq8035;\n    BQ27421\t\t= 0x010421 # hw marking bq8101; seem to also be BQ27411 ?\n    BQ27425\t\t= 0x010425 # hw marking bq8036;\n    BQ27426\t\t= 0x010426 # hw marking bq8101;\n    BQ27510\t\t= 0x010510 # hw marking bq8035;\n    BQ27520\t\t= 0x010520 # hw marking bq8035;\n    BQ27530\t\t= 0x010530 # hw marking bq8035;\n    BQ27531\t\t= 0x010531 # hw marking bq8035;\n    BQ27532\t\t= 0x010532 # hw marking bq8035;\n    BQ27541\t\t= 0x010541 # hw marking bq8034;\n    BQ27542\t\t= 0x010542 # hw marking bq8034;\n    BQ27545\t\t= 0x010545 # hw marking bq8035;\n    BQ27546\t\t= 0x010546 # hw marking bq8034;\n    BQ27621\t\t= 0x010621 # hw marking bq8101;\n    BQ27742\t\t= 0x010742 # hw marking bq8037;\n    BQ78z100\t= 0x011100 # hw marking bq9002;\n    BQ27z561\t= 0x011561 # hw marking bq9035;\n    BQ78350\t\t= 0x011e9b # hw marking bq8030;\n    BQ28z610\t= 0x012610 # hw marking bq9002;\n    BQ40z50\t\t= 0x014500 # hw marking bq9000;\n    BQ40z60\t\t= 0x014600 # hw marking bq9000;\n    BQ40z80\t\t= 0x014800 # hw marking bq9006; seem to also be BQ40z70 ?\n    BQ4050\t\t= 0x019e34 # hw marking bq9000;\n    BQ769x2\t\t= 0x017692 # hw marking bq7692; BQ76942/BQ76952\n\n\nCHIP_TYPE.AUTO.__doc__\t\t= \"Automatic detection of the chip\"\nCHIP_TYPE.SBS.__doc__\t\t= \"Generic chip with SBS support\"\nCHIP_TYPE.BQGENERIC.__doc__\t= \"Unidentified chip from TI BQ family\"\nCHIP_TYPE.BQ30z55.__doc__\t= \"Texas Instruments BQ30z55 chip\"\nCHIP_TYPE.BQ20z65.__doc__\t= \"Texas Instruments BQ20z65 chip\"\nCHIP_TYPE.BQ3050.__doc__\t= \"Texas Instruments BQ3050 chip\"\nCHIP_TYPE.BQ3060.__doc__\t= \"Texas Instruments BQ3060 chip\"\nCHIP_TYPE.BQ40z307.__doc__\t= \"Texas Instruments BQ40z307 chip for DJI\"\nCHIP_TYPE.BQ40370.__doc__\t= \"Texas Instruments BQ40370 chip\"\nCHIP_TYPE.BQ35100.__doc__\t= \"Texas Instruments BQ35100 chip\"\nCHIP_TYPE.BQ34110.__doc__\t= \"Texas Instruments BQ34110 chip\"\nCHIP_TYPE.BQ34210.__doc__\t= \"Texas Instruments BQ34210 chip\"\nCHIP_TYPE.BQ27220.__doc__\t= \"Texas Instruments BQ27220 chip\"\nCHIP_TYPE.BQ27320.__doc__\t= \"Texas Instruments BQ27320 chip\"\nCHIP_TYPE.BQ27421.__doc__\t= \"Texas Instruments BQ27411/BQ27421 chip\"\nCHIP_TYPE.BQ27425.__doc__\t= \"Texas Instruments BQ27425 chip\"\nCHIP_TYPE.BQ27426.__doc__\t= \"Texas Instruments BQ27426 chip\"\nCHIP_TYPE.BQ27510.__doc__\t= \"Texas Instruments BQ27510 chip\"\nCHIP_TYPE.BQ27520.__doc__\t= \"Texas Instruments BQ27520 chip\"\nCHIP_TYPE.BQ27530.__doc__\t= \"Texas Instruments BQ27530 chip\"\nCHIP_TYPE.BQ27531.__doc__\t= \"Texas Instruments BQ27531 chip\"\nCHIP_TYPE.BQ27532.__doc__\t= \"Texas Instruments BQ27532 chip\"\nCHIP_TYPE.BQ27541.__doc__\t= \"Texas Instruments BQ27541 chip\"\nCHIP_TYPE.BQ27542.__doc__\t= \"Texas Instruments BQ27542 chip\"\nCHIP_TYPE.BQ27545.__doc__\t= \"Texas Instruments BQ27545 chip\"\nCHIP_TYPE.BQ27546.__doc__\t= \"Texas Instruments BQ27546 chip\"\nCHIP_TYPE.BQ27621.__doc__\t= \"Texas Instruments BQ27621 chip\"\nCHIP_TYPE.BQ27742.__doc__\t= \"Texas Instruments BQ27742 chip\"\nCHIP_TYPE.BQ78z100.__doc__\t= \"Texas Instruments BQ78z100 chip\"\nCHIP_TYPE.BQ27z561.__doc__\t= \"Texas Instruments BQ27z561 chip\"\nCHIP_TYPE.BQ78350.__doc__\t= \"Texas Instruments BQ78350 chip\"\nCHIP_TYPE.BQ28z610.__doc__\t= \"Texas Instruments BQ28z610 chip\"\nCHIP_TYPE.BQ40z50.__doc__\t= \"Texas Instruments BQ40z50 chip\"\nCHIP_TYPE.BQ40z60.__doc__\t= \"Texas Instruments BQ40z60 chip\"\nCHIP_TYPE.BQ40z80.__doc__\t= \"Texas Instruments BQ40z70/BQ40z80 chip\"\nCHIP_TYPE.BQ4050.__doc__\t= \"Texas Instruments BQ4050 chip\"\nCHIP_TYPE.BQ769x2.__doc__\t= \"Texas Instruments BQ76942/BQ76952 chip\"\n\n\nclass SBS_COMMAND(DecoratedEnum):\n    \"\"\" Smart Battery Data Specification 1.1 commands list\n\n    This is a list taken directly from specification.\n    \"\"\"\n    ManufacturerAccess\t\t= 0x00\n    RemainingCapacityAlarm\t= 0x01\n    RemainingTimeAlarm\t\t= 0x02\n    BatteryMode\t\t\t\t= 0x03\n    AtRate\t\t\t\t\t= 0x04\n    AtRateToFull\t\t\t= 0x05\n    AtRateToEmpty\t\t\t= 0x06\n    AtRateOK\t\t\t\t= 0x07\n    Temperature\t\t\t\t= 0x08\n    Voltage\t\t\t\t\t= 0x09\n    Current\t\t\t\t\t= 0x0a\n    AverageCurrent\t\t\t= 0x0b\n    MaxError\t\t\t\t= 0x0c\n    RelativeStateOfCharge\t= 0x0d\n    AbsoluteStateOfCharge\t= 0x0e\n    RemainingCapacity\t\t= 0x0f\n    FullChargeCapacity\t\t= 0x10\n    RunTimeToEmpty\t\t\t= 0x11\n    AverageTimeToEmpty\t\t= 0x12\n    AverageTimeToFull\t\t= 0x13\n    ChargingCurrent\t\t\t= 0x14\n    ChargingVoltage\t\t\t= 0x15\n    BatteryStatus\t\t\t= 0x16\n    CycleCount\t\t\t\t= 0x17\n    DesignCapacity\t\t\t= 0x18\n    DesignVoltage\t\t\t= 0x19\n    SpecificationInfo\t\t= 0x1a\n    ManufactureDate\t\t\t= 0x1b\n    SerialNumber\t\t\t= 0x1c\n    ManufacturerName\t\t= 0x20\n    DeviceName\t\t\t\t= 0x21\n    DeviceChemistry\t\t\t= 0x22\n    ManufacturerData\t\t= 0x23\n    OptionalMfgFunction5\t= 0x2f\n    OptionalMfgFunction4\t= 0x3c\n    OptionalMfgFunction3\t= 0x3d\n    OptionalMfgFunction2\t= 0x3e\n    OptionalMfgFunction1\t= 0x3f\n\n\nclass RAW_ADDRESS_SPACE_KIND_BQGENERIC(DecoratedEnum):\n    \"\"\" Address spaces used in BQ family SBS chips\n    \"\"\"\n    DataFlash\t\t\t\t= 0x00\n    InstructionFlash\t\t= 0x01\n\n\nclass MANUFACTURER_ACCESS_CMD_BQGENERIC(DecoratedEnum):\n    \"\"\" ManufacturerAccess sub-commands used in all BQ family SBS chips\n    \"\"\"\n    ManufacturerData\t\t= 0x00\n    DeviceType\t\t\t\t= 0x01\n    FirmwareVersion\t\t\t= 0x02\n    HardwareVersion\t\t\t= 0x03\n\n\nclass SBS_FLAG_BATTERY_MODE(DecoratedEnum):\n    \"\"\" Flags used in BatteryMode command\n    \"\"\"\n    INTERNAL_CHARGE_CONTROLLER\t= 0\n    PRIMARY_BATTERY_SUPPORT\t\t= 1\n    RESERVED2\t\t\t\t\t= 2\n    RESERVED3\t\t\t\t\t= 3\n    RESERVED4\t\t\t\t\t= 4\n    RESERVED5\t\t\t\t\t= 5\n    RESERVED6\t\t\t\t\t= 6\n    CONDITION_FLAG\t\t\t\t= 7\n    CHARGE_CONTROLLER_ENABLED\t= 8\n    PRIMARY_BATTERY\t\t\t\t= 9\n    RESERVED10\t\t\t\t\t= 10\n    RESERVED11\t\t\t\t\t= 11\n    RESERVED12\t\t\t\t\t= 12\n    ALARM_MODE\t\t\t\t\t= 13\n    CHARGER_MODE\t\t\t\t= 14\n    CAPACITY_MODE\t\t\t\t= 15\n\n\nclass SBS_FLAG_BATTERY_STATUS(DecoratedEnum):\n    \"\"\" Flags used in BatteryStatus command\n    \"\"\"\n    ERROR_CODE\t\t\t\t\t= 0\n    FULLY_DISCHARGED\t\t\t= 4\n    FULLY_CHARGED\t\t\t\t= 5\n    DISCHARGING\t\t\t\t\t= 6\n    INITIALIZED\t\t\t\t\t= 7\n    REMAINING_TIME_ALARM\t\t= 8\n    REMAINING_CAPACITY_ALARM\t= 9\n    RESERVED10\t\t\t\t\t= 10\n    TERMINATE_DISCHARGE_ALARM\t= 11\n    OVERTEMPERATURE_ALARM\t\t= 12\n    RESERVED13\t\t\t\t\t= 13\n    TERMINATE_CHARGE_ALARM\t\t= 14\n    OVER_CHARGED_ALARM\t\t\t= 15\n\n\nclass SBS_FLAG_SPECIFICATION_INFO(DecoratedEnum):\n    \"\"\" Flags used in SpecificationInfo command\n    \"\"\"\n    Revision\t\t\t\t\t= 0\n    Version\t\t\t\t\t\t= 4\n    VScale\t\t\t\t\t\t= 8\n    IPScale\t\t\t\t\t\t= 12\n\n\nclass MONITOR_GROUP(DecoratedEnum):\n    \"\"\" List of groups of commands/offsets.\n    \"\"\"\n    DeviceInfo       = 0x00\n    UsageInfo        = 0x01\n    ComputedInfo     = 0x02\n    StatusBits       = 0x03\n    AtRates          = 0x04\n    BQStatusBits     = 0x06\n    BQStatusBitsMA   = 0x07\n    BQCellVoltages   = 0x08\n    BQLifetimeData   = 0x09\n    BQLifetimeDataMA = 0x0a\n    ImpedanceTrack   = 0x0b\n    ImpedanceTrackMA = 0x0c\n    BQTurboMode      = 0x0f\n\n\n# Global variables, modified by chip drivers\nMANUFACTURER_ACCESS_CMD_BQ_INFO = {}\nMANUFACTURER_BLOCK_ACCESS_CMD_BQ_INFO = {}\nSBS_BATTERY_MODE_INFO = {}\nSBS_BATTERY_STATUS_INFO = {}\nSBS_SPECIFICATION_INFO = {}\nSBS_CMD_INFO = {}\nRAW_ADDRESS_SPACE_KIND_INFO = {}\nSBS_CMD_GROUPS = {}\nSBS_SEALING = {}\n\n\ndef reset_default_driver(po):\n  \"\"\" Sets global variables to no chip-specific driver loaded state.\n  \"\"\"\n  global MANUFACTURER_ACCESS_CMD_BQ_INFO\n  MANUFACTURER_ACCESS_CMD_BQ_INFO = {\n    MANUFACTURER_ACCESS_CMD_BQGENERIC.ManufacturerData : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"hex\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Output ManufacturerData().\"),\n    },\n    MANUFACTURER_ACCESS_CMD_BQGENERIC.DeviceType : {\n        'type'\t: \"uint16_blk\",\n        'unit'\t: {'scale':1,'name':\"hex\"},\n        'resp_location'\t: SBS_COMMAND.ManufacturerData,\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"IC device part number.\"),\n    },\n    MANUFACTURER_ACCESS_CMD_BQGENERIC.FirmwareVersion : {\n        'type'\t: \"byte[13]\",\n        'unit'\t: {'scale':None,'name':\"hex\"},\n        'resp_location'\t: SBS_COMMAND.ManufacturerData,\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Version of the firmware within the device. Major and \"\n            \"minor version numbers.\"),\n    },\n    MANUFACTURER_ACCESS_CMD_BQGENERIC.HardwareVersion : {\n        'type'\t: \"uint16_blk\",\n        'unit'\t: {'scale':1,'name':\"dec\"},\n        'resp_location'\t: SBS_COMMAND.ManufacturerData,\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"The IC hardware revision.\"),\n    },\n  }\n\n  global MANUFACTURER_BLOCK_ACCESS_CMD_BQ_INFO\n  MANUFACTURER_BLOCK_ACCESS_CMD_BQ_INFO = {\n  }\n\n  global SBS_BATTERY_MODE_INFO\n  SBS_BATTERY_MODE_INFO = {\n    SBS_FLAG_BATTERY_MODE.INTERNAL_CHARGE_CONTROLLER : {\n        # Data type associated with the field\n        # For strings, it also contains expected length (which can be exceeeded,\n        # as all strings are up to 32 bytes, but this causes a second read)\n        'type'\t: \"named_bitfield\",\n        # Measurement unit in which data type is stored\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        # Amount of bits in this field\n        'nbits'\t: 1,\n        # Names for possible values\n        'value_names'\t: [\"No support\",\"Supported\"],\n        # Access to the field\n        'access'\t: \"r\",\n        # Very short name of this field,\n        'tiny_name'\t: \"ICC\",\n        # Description, with first sentence making a short description,\n        'desc'\t: (\"Internal Charge Controller circuit available. The ICC \"\n            \"accepts power from the battery terminals but may regulate or \"\n            \"otherwise control the current and voltage that actually reaches \"\n            \"the battery’s cells. \"\n            \"When the bit is set, the CHARGE_CONTROLLER_ENABLED bit will be \"\n            \"available for activation and control of the actual internal \"\n            \"charger.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.PRIMARY_BATTERY_SUPPORT: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"No support\",\"Supported\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"PBS\",\n        'desc'\t: (\"Ability to act as primary or secondary battery. The \"\n            \"Primary/Secondary battery feature is used with batteries \"\n            \"containing internal discharge control mechanisms to allow \"\n            \"multiple batteries to be connected in parallel. This bit \"\n            \"indicates the presence of this internal control, while the \"\n            \"PRIMARY_BATTERY bit actually controls the on/off state of \"\n            \"this internal control.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED2: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED3: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED4: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED5: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED6: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.CONDITION_FLAG: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"No need\",\"Requested\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"CF\",\n        'desc'\t: (\"Battery requests a conditioning cycle. A conditioning \"\n            \"cycle may be requested because of the characteristics of the \"\n            \"battery chemistry and/or the electronics in combination with \"\n            \"the usage pattern. \"\n            \"This flag is the first signal from the Smart Battery that it \"\n            \"has limited ability to determine the present state-of-charge.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.CHARGE_CONTROLLER_ENABLED: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Disabled\",\"Enabled\"],\n        'access'\t: \"rw\",\n        'tiny_name'\t: \"CC\",\n        'desc'\t: (\"Battery pack's internal charge controller state. When \"\n            \"this bit is cleared, the internal charge controller is disabled. \"\n            \"This bit is active only when the INTERNAL_CHARGE_CONTROLLER bit \"\n            \"is set, indicating that this function is supported.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.PRIMARY_BATTERY: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Secondary\",\"Primary\"],\n        'access'\t: \"rw\",\n        'tiny_name'\t: \"PB\",\n        'desc'\t: (\"Operate as the pri/sec battery in a system. When this bit \"\n            \"is cleared, the battery operates in a secondary role. This bit \"\n            \"is active only when the PRIMARY_BATTERY_SUPPORT bit is set. The \"\n            \"optional Primary/Secondary battery feature is used with batteries \"\n            \"containing internal discharge control mechanisms to allow multiple \"\n            \"batteries to be connected in parallel.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED10: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED11: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.RESERVED12: {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"Rsvd\",\n        'desc'\t: (\"Reserved by SBS spec. This field cannot be used unless \"\n            \"future version of SBS specification defines its meaning.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.ALARM_MODE: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Tx enabled\",\"Tx disabled\"],\n        'access'\t: \"rw\",\n        'tiny_name'\t: \"AM\",\n        'desc'\t: (\"Don't master the SMBus and send AlarmWarning(). \"\n            \"When set, the Smart Battery will NOT master the SMBus and \"\n            \"messages will NOT be sent to the SMBus Host and the Smart Battery \"\n            \"Charger. Automatically cleared by the Smart Battery electronics \"\n            \"every 60 seconds.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.CHARGER_MODE: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Tx enabled\",\"Tx disabled\"],\n        'access'\t: \"rw\",\n        'tiny_name'\t: \"ChgM\",\n        'desc'\t: (\"Don't send ChargingCurrent() and ChargingVoltage(). \"\n            \"When set, the Smart Battery will NOT transmit charging values to \"\n            \"the Smart Battery Charger. When cleared, the Battery will transmit \"\n            \"the ChargingCurrent() and ChargingVoltage() values to the Smart \"\n            \"Battery Charger when charging is desired.\"),\n    },\n    SBS_FLAG_BATTERY_MODE.CAPACITY_MODE: {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Report in mAh\",\"Report in 10mWh\"],\n        'access'\t: \"rw\",\n        'tiny_name'\t: \"CapM\",\n        'desc'\t: (\"Capacity reporting unit, mA/mAh or 10mW/10mWh. After \"\n            \"changing this bit, all related values (such as AtRate()) should \"\n            \"be re-written while the new mode is active. This bit allows \"\n            \"power management systems to best match their electrical \"\n            \"characteristics with those reported by the battery. For example,\"\n            \" a switching power supply represents a constant power load, \"\n            \"whereas a linear supply is better represented by a constant \"\n            \"current model.\"),\n    },\n  }\n\n  global SBS_BATTERY_STATUS_INFO\n  SBS_BATTERY_STATUS_INFO = {\n    SBS_FLAG_BATTERY_STATUS.ERROR_CODE : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"dec\"},\n        'nbits'\t: 4,\n        'value_names'\t: [\"OK\", \"Busy\", \"Reserved Cmd\", \"Unsupported Cmd\",\n            \"Access Denied\", \"Over/Underflow\", \"Bad Size\", \"Unknown Error\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"EC\",\n        'desc'\t: (\"Function error code. Error code generated by function \"\n            \"of the last command.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.FULLY_DISCHARGED : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Not fully\",\"Fully\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"FD\",\n        'desc'\t: (\"Battery capacity is depleted. Cleared when \"\n            \"RelativeStateOfCharge() value rises above 20% again.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.FULLY_CHARGED : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Not fully\",\"Fully\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"FC\",\n        'desc'\t: (\"Battery is full. Set when further charge is not required.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.DISCHARGING : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"No\",\"Yes\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"DSG\",\n        'desc'\t: (\"Battery is discharging. This is set by both external \"\n            \"load and self-discharge, so it does not always indicate that \"\n            \"a discharge current is present.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.INITIALIZED : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Correct\",\"Recalibrate\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"INIT\",\n        'desc'\t: (\"State of calibration/configuration. Battery electronics \"\n            \"are first calibrated and configured at time of manufacture. This \"\n            \"flag is set when calibration or configuration information has \"\n            \"been lost, and accuracy is significantly impaired.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.REMAINING_TIME_ALARM : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Inactive\",\"Active\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"RTA\",\n        'desc'\t: (\"Remaining time to depletion alarm tripped. Set when \"\n            \"value of AverageTimeToEmpty() is less than the value \"\n            \"of RemainingTimeAlarm().\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.REMAINING_CAPACITY_ALARM : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Inactive\",\"Active\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"RCA\",\n        'desc'\t: (\"Remaining capacity alarm tripped. Set when \"\n            \"value of RemainingCapacity() is less than the value \"\n            \"of RemainingCapacityAlarm().\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.RESERVED10 : {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"ResA\",\n        'desc'\t: (\"Purpose undefined.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.TERMINATE_DISCHARGE_ALARM : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Inactive\",\"Active\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"TDA\",\n        'desc'\t: (\"Battery capacity is depleted. Stop Discharge As Soon As \"\n            \"Possible.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.OVERTEMPERATURE_ALARM : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Inactive\",\"Active\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"OTA\",\n        'desc'\t: (\"Temperature is above pre-set limit.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.RESERVED13 : {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'access'\t: \"-\",\n        'tiny_name'\t: \"ResD\",\n        'desc'\t: (\"Purpose undefined.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.TERMINATE_CHARGE_ALARM : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Inactive\",\"Active\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"TCA\",\n        'desc'\t: (\"Charging should be suspended. Stop Charging temporarily. \"\n            \"Charging may be re-started when conditions permit.\"),\n    },\n    SBS_FLAG_BATTERY_STATUS.OVER_CHARGED_ALARM : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'nbits'\t: 1,\n        'value_names'\t: [\"Inactive\",\"Active\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"OCA\",\n        'desc'\t: (\"Battery is fully charged. Stop charging.\"),\n    },\n  }\n\n  global SBS_SPECIFICATION_INFO\n  SBS_SPECIFICATION_INFO = {\n    SBS_FLAG_SPECIFICATION_INFO.Revision : {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"dec\"},\n        'nbits'\t: 4,\n        'access'\t: \"r\",\n        'tiny_name'\t: \"Rev\",\n        'desc'\t: (\"Supported SBS revision. Identifies revision of the \"\n            \"Smart Battery Specification document used to design this chip.\"),\n    },\n    SBS_FLAG_SPECIFICATION_INFO.Version : {\n        'type'\t: \"named_bitfield\",\n        'unit'\t: {'scale':1,'name':\"dec\"},\n        'nbits'\t: 4,\n        'value_names'\t: [\"v0-none\",\"v1.0\",\"v1.1\",\"v1.1+PEC\",\"vFuture4\",\n          \"vFuture5\",\"vFuture6\",\"vFuture7\"],\n        'access'\t: \"r\",\n        'tiny_name'\t: \"Ver\",\n        'desc'\t: (\"Supported SBS version. Identifies Smart Battery \"\n            \"Specification version used to design this chip.\"),\n    },\n    SBS_FLAG_SPECIFICATION_INFO.VScale : {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"dec\"},\n        'nbits'\t: 4,\n        'access'\t: \"r\",\n        'tiny_name'\t: \"VSc\",\n        'desc'\t: (\"Voltage scaling exponent. Multiplies voltages \"\n            \"by 10 ^ VScale.\"),\n    },\n    SBS_FLAG_SPECIFICATION_INFO.IPScale : {\n        'type'\t: \"int_bitfield\",\n        'unit'\t: {'scale':1,'name':\"dec\"},\n        'nbits'\t: 4,\n        'access'\t: \"r\",\n        'tiny_name'\t: \"IPSc\",\n        'desc'\t: (\"Current/capacity scaling exp. Multiplies currents \"\n            \"and capacities by 10 ^ IPScale.\"),\n    },\n  }\n\n  global SBS_CMD_INFO\n  SBS_CMD_INFO = {\n    SBS_COMMAND.ManufacturerAccess : {\n        # Data type associated with the function\n        'type'\t: \"uint16\",\n        # Measurement unit in which data type is stored\n        'unit'\t: {'scale':1,'name':\"variable\"},\n        # Tuple which contains all possible lists of sub-commands\n        # The getter algorithm should know which of these lists to use\n        # depending on chip model, and possibly other variables\n        'subcmd_infos'\t: (MANUFACTURER_ACCESS_CMD_BQ_INFO,),\n        # Access to the function in BQ seal modes: sealed, unsealed, full access;\n        # Access modes are defined this way in TI BQ chips, they're not part of SBS.\n        'access_per_seal'\t: (\"rw\",\"rw\",\"rw\",),\n        # Description, with first sentence making a short description,\n        'desc'\t: (\"Optional command, is implementation specific. \"\n            \"It may be used by a battery manufacturer or silicon supplier to \"\n            \"return specific version information, internal calibration \"\n            \"information, or some other manufacturer specific function.\"),\n        # Selection of an algorithm to read/write the value of this function\n        'getter'\t: \"write_word_subcommand\",\n    },\n    SBS_COMMAND.RemainingCapacityAlarm : {\n        'type'\t: \"uint16\",\n        'unit0'\t: {'scale':1,'name':\"mAh\"},\n        'unit1'\t: {'scale':10,'name':\"mWh\"},\n        'access_per_seal'\t: (\"rw\",\"rw\",\"rw\",),\n        'desc'\t: (\"Low Capacity alarm threshold value. Whenever the \"\n            \"RemainingCapacity() falls below the Low Capacity value, the \"\n            \"Smart Battery sends AlarmWarning() messages to the SMBus Host \"\n            \"with the REMAINING_CAPACITY_ALARM bit set. A Low Capacity value \"\n            \"of 0 disables this alarm. Unit depends on BatteryMode()'s \"\n            \"CAPACITY_MODE bit.\"),\n        'getter'\t: \"unit_select_on_capacity_mode\",\n    },\n    SBS_COMMAND.RemainingTimeAlarm : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"minutes\"},\n        'access_per_seal'\t: (\"rw\",\"rw\",\"rw\",),\n        'desc'\t: (\"Remaining Time alarm value. Whenever the AverageTimeToEmpty() \"\n            \"falls below the Remaining Time value, the Smart Battery sends \"\n            \"AlarmWarning() messages to the SMBus Host with the \"\n            \"REMAINING_TIME_ALARM bit set. A Remaining Time value of 0 \"\n            \"effectively disables this alarm.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.BatteryMode : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"bitfields\"},\n        'bitfields_info'\t: SBS_BATTERY_MODE_INFO,\n        'access_per_seal'\t: (\"rw\",\"rw\",\"rw\",),\n        'desc'\t: (\"Battery modes and capabilities. Selects the various battery \"\n            \"operational modes and reports the battery’s capabilities, modes, \"\n            \"and flags minor conditions requiring attention.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AtRate : {\n        'type'\t: \"int16\",\n        'unit'\t: {'scale':1,'name':\"mA\"},\n        'access_per_seal'\t: (\"rw\",\"rw\",\"rw\",),\n        'desc'\t: (\"The AtRate value used in calculations. First half of \"\n            \"a two-function call-set used to set the AtRate value used in \"\n            \"calculations made by the AtRateTimeToFull(), AtRateTimeToEmpty(), \"\n            \"and AtRateOK() functions. The AtRate value may be expressed in \"\n            \"either current (mA) or power (10mW) depending on the setting of \"\n            \"the BatteryMode()'s CAPACITY_MODE bit.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AtRateToFull : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"minutes\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Predicted remaining time to fully charge the battery. \"\n            \"Uses the previously written AtRate value.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AtRateToEmpty : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"minutes\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Predicted remaining operating time when discharging. \"\n            \"Uses the previously written AtRate value.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AtRateOK : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"boolean\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Whether can deliver an additional energy for 10 sec.\"\n            \"Uses the previously written AtRate value for additional energy \"\n            \"amount.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.Temperature : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':0.1,'name':\"K\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Cell-pack's internal temperature. The actual operational \"\n            \"temperature range will be defined at a pack level by a \"\n            \"particular manufacturer. Typically it will be in the range \"\n            \"of -20 degC to +75 degC.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.Voltage : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"mV\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Cell-pack voltage. Provides power management systems \"\n            \"with an accurate battery terminal voltage. Power management \"\n            \"systems can use this voltage, along with battery current \"\n            \"information, to characterize devices they control.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.Current : {\n        'type'\t: \"int16\",\n        'unit'\t: {'scale':1,'name':\"mA\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"The current being supplied/accepted through terminals. \"\n            \"Provides a snapshot for the power management system of the \"\n            \"current flowing into or out of the battery. This information \"\n            \"will be of particular use in power management systems because \"\n            \"they can characterize individual devices and \\\"tune\\\" their \"\n            \"operation.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AverageCurrent : {\n        'type'\t: \"int16\",\n        'unit'\t: {'scale':1,'name':\"mA\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"One-minute rolling average on the current flow. \"\n            \"Returns the rolling average based on the current being supplied \"\n            \"(or accepted) through the battery's terminals. This function \"\n            \"is expected to return meaningful values during the battery's \"\n            \"first minute of operation.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.MaxError : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"%\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Expected margin of error in charge calculation. \"\n            \"For example, when MaxError() returns 10% and RelativeStateOfCharge() \"\n            \"returns 50%, the Relative StateOfCharge() is actually between \"\n            \"50 and 60%. The MaxError() of a battery is expected to increase \"\n            \"until the Smart Battery identifies a condition that will give it \"\n            \"higher confidence in its own accuracy, like being fully charged. \"\n            \"The Battery can signal when MaxError() has become too high by \"\n            \"setting the CONDITION_FLAG bit in BatteryMode().\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.RelativeStateOfCharge : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"%\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Predicted remaining capacity, % of FullChargeCap().\"\n            \"Returns the predicted remaining battery capacity expressed as a \"\n            \"percentage of FullChargeCapacity(). This is is used to estimate \"\n            \"the amount of charge remaining in the battery. The problem with \"\n            \"this paradigm is that the tank size is variable.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AbsoluteStateOfCharge : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"%\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Predicted remaining capacity, % of DesignCap(). \"\n            \"Returns the predicted remaining battery capacity expressed as a \"\n            \"percentage of DesignCapacity(). This can return values greater \"\n            \"than 100%.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.RemainingCapacity : {\n        'type'\t: \"uint16\",\n        'unit0'\t: {'scale':1,'name':\"mAh\"},\n        'unit1'\t: {'scale':10,'name':\"mWh\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"rw\",),\n        'desc'\t: (\"Predicted remaining battery capacity. The capacity value \"\n            \"is expressed in either current (mAh at a C/5 discharge rate) or \"\n            \"power (10mWh at a P/5 discharge rate) depending on the setting \"\n            \"of the BatteryMode()'s CAPACITY_MODE bit.\"),\n        'getter'\t: \"unit_select_on_capacity_mode\",\n    },\n    SBS_COMMAND.FullChargeCapacity : {\n        'type'\t: \"uint16\",\n        'unit0'\t: {'scale':1,'name':\"mAh\"},\n        'unit1'\t: {'scale':10,'name':\"mWh\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"rw\",),\n        'desc'\t: (\"Predicted pack capacity when it is fully charged. \"\n            \"The value is expressed in either current (mAh at a C/5 discharge \"\n            \"rate) or power (10mWh at a P/5 discharge rate) depending on the \"\n            \"setting of the BatteryMode()'s CAPACITY_MODE bit.\"),\n        'getter'\t: \"unit_select_on_capacity_mode\",\n    },\n    SBS_COMMAND.RunTimeToEmpty : {\n        'type'\t: \"uint16\",\n        'unit0'\t: {'scale':1,'name':\"mAh\"},\n        'unit1'\t: {'scale':10,'name':\"mWh\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Remaining battery life at the present rate of discharge. \"\n            \"The value is calculated based on either current or power, \"\n            \"depending on the setting of the BatteryMode()'s CAPACITY_MODE \"\n            \"bit. This is an important distinction because use of the wrong \"\n            \"calculation mode may result in inaccurate return values.\"),\n        'getter'\t: \"unit_select_on_capacity_mode\",\n    },\n    SBS_COMMAND.AverageTimeToEmpty : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"minutes\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"One-minute rolling average of the remaining bat life. \"\n            \"The AverageTimeToEmpty() value is calculated based on either \"\n            \"current or power depending on the setting of the BatteryMode()'s \"\n            \"CAPACITY_MODE bit.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.AverageTimeToFull : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"minutes\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"One minute average of the remaining time until full. \"\n            \"This function can be used by the SMBus Host's power management \"\n            \"system to aid in its policy. It may also be used to find out \"\n            \"how long the system must be left on to achieve full charge.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.ChargingCurrent : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"mA\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"The desired charging rate to the Battery Charger. \"\n            \"This represents the maximum current which may be provided by \"\n            \"the Smart Battery Charger to permit the Battery to reach a \"\n            \"Fully Charged state.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.ChargingVoltage : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"mV\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"The desired charging voltage to the Battery Charger. \"\n            \"This represents the maximum voltage which may be provided by \"\n            \"the Smart Battery Charger to permit the Smart Battery to reach \"\n            \"a Fully Charged state.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.BatteryStatus : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"bitfields\"},\n        'bitfields_info'\t: SBS_BATTERY_STATUS_INFO,\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Battery's Alarm and Status bit flags. Some of the \"\n            \"BatteryStatus() flags (REMAINING_CAPACITY_ALARM and \"\n            \"REMAINING_TIME_ALARM) are calculated based on either current \"\n            \"or power depending on the setting of the BatteryMode()'s \"\n            \"CAPACITY_MODE bit.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.CycleCount : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"cycles\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Number of cycles the battery has experienced. A cycle \"\n            \"is defined as: An amount of discharge approximately equal \"\n            \"to the value of DesignCapacity.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.DesignCapacity : {\n        'type'\t: \"uint16\",\n        'unit0'\t: {'scale':1,'name':\"mAh\"},\n        'unit1'\t: {'scale':10,'name':\"mWh\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Theoretical capacity of a new pack. The value is expressed \"\n            \"in either current (mAh at a C/5 discharge rate) or power (10mWh \"\n            \"at a P/5 discharge rate) depending on the setting of the \"\n            \"BatteryMode()'s CAPACITY_MODE bit.\"),\n        'getter'\t: \"unit_select_on_capacity_mode\",\n    },\n    SBS_COMMAND.DesignVoltage : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"mV\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Theoretical voltage of a new pack. This can be used to \"\n            \"give additional information about a particular Smart Battery's \"\n            \"expected terminal voltage.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.SpecificationInfo : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"bitfields\"},\n        'bitfields_info'\t: SBS_SPECIFICATION_INFO,\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"SBS spec version, plus scaling for measures. \"\n            \"Returns the version number of the Smart Battery specification \"\n            \"the battery pack supports, as well as voltage and current and \"\n            \"capacity scaling information in a packed unsigned integer. \"\n            \"Power scaling is the product of the voltage scaling times the \"\n            \"current scaling.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.ManufactureDate : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"date547\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"The date the cell pack was manufactured. This provides \"\n            \"the system with information that can be used to uniquely \"\n            \"identify a particular battery.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.SerialNumber : {\n        'type'\t: \"uint16\",\n        'unit'\t: {'scale':1,'name':\"\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Serial number of the battery. This function is used to \"\n            \"identify a particular battery.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.ManufacturerName : {\n        'type'\t: \"string[8]\", # expected length, max is 32\n        'unit'\t: {'scale':None,'name':\"str\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"The battery's manufacturer's name. \"\n            \"The name can be displayed by the SMBus Host's power \"\n            \"management system display as both an identifier and as an \"\n            \"advertisement for the manufacturer.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.DeviceName : {\n        'type'\t: \"string[12]\",\n        'unit'\t: {'scale':None,'name':\"str\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Character string that contains the battery's name. \"\n            \"This returns the battery's name for display by the SMBus \"\n            \"Host's power management system as well as for identification \"\n            \"purposes.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.DeviceChemistry : {\n        'type'\t: \"string[4]\",\n        'unit'\t: {'scale':None,'name':\"str\"},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Character string that contains the battery's chemistry. \"\n            \"This function gives cell chemistry information for use by \"\n            \"charging systems.\"),\n        'getter'\t: \"simple\",\n    },\n    SBS_COMMAND.ManufacturerData : {\n        'type'\t: \"byte[]\",\n        'unit'\t: {'scale':None,'name':None},\n        'access_per_seal'\t: (\"r\",\"r\",\"r\",),\n        'desc'\t: (\"Manufacturer data contained in the battery. This may \"\n            \"be used to access the manufacturer's data area. The information \"\n            \"and its format are proprietary, but might include items such as: \"\n            \"lot codes, number of deep cycles, discharge patterns, deepest \"\n            \"discharge, etc.\"),\n        'getter'\t: \"simple\",\n    },\n  }\n\n  global RAW_ADDRESS_SPACE_KIND_INFO\n  RAW_ADDRESS_SPACE_KIND_INFO = {}\n\n  global SBS_CMD_GROUPS\n  SBS_CMD_GROUPS = {\n    MONITOR_GROUP.DeviceInfo : (\n        SBS_COMMAND.ManufactureDate,\n        SBS_COMMAND.SerialNumber,\n        SBS_COMMAND.ManufacturerName,\n        SBS_COMMAND.DeviceName,\n        SBS_COMMAND.DeviceChemistry,\n        SBS_COMMAND.DesignCapacity,\n        SBS_COMMAND.DesignVoltage,\n        SBS_COMMAND.RemainingCapacityAlarm,\n        SBS_COMMAND.RemainingTimeAlarm,\n        SBS_COMMAND.SpecificationInfo,\n    ),\n    MONITOR_GROUP.UsageInfo : (\n        SBS_COMMAND.Temperature,\n        SBS_COMMAND.Voltage,\n        SBS_COMMAND.Current,\n        SBS_COMMAND.AverageCurrent,\n        SBS_COMMAND.RemainingCapacity,\n        SBS_COMMAND.FullChargeCapacity,\n        SBS_COMMAND.MaxError,\n        SBS_COMMAND.CycleCount,\n    ),\n    MONITOR_GROUP.ComputedInfo : (\n        SBS_COMMAND.RelativeStateOfCharge,\n        SBS_COMMAND.AbsoluteStateOfCharge,\n        SBS_COMMAND.RunTimeToEmpty,\n        SBS_COMMAND.AverageTimeToEmpty,\n        SBS_COMMAND.AverageTimeToFull,\n        SBS_COMMAND.ChargingCurrent,\n        SBS_COMMAND.ChargingVoltage,\n    ),\n    MONITOR_GROUP.StatusBits : (\n        SBS_COMMAND.BatteryMode,\n        SBS_COMMAND.BatteryStatus,\n    ),\n    MONITOR_GROUP.AtRates : (\n        SBS_COMMAND.AtRate,\n        SBS_COMMAND.AtRateToFull,\n        SBS_COMMAND.AtRateToEmpty,\n        SBS_COMMAND.AtRateOK,\n    ),\n  }\n\n  global SBS_SEALING\n  SBS_SEALING = {}\n\n  pass # reset_default_driver() ends\n\nclass ChipMock(object):\n    def __init__(self, bus, chip=None):\n        self.bus = bus\n        self.reads = {}\n        self.reads_sub = {}\n        self.prep_static()\n\n    def prep_static(self):\n        # Only commands required to chip detection;\n        # After detection, imported chip file will replace this\n        self.add_read_sub(0x00, 0x02, bytes.fromhex(\n          \"0550 0036 0034 00 0380 0001 0083\")) # FirmwareVersion\n\n    def add_read(self, register, data):\n        self.reads[register] = data\n\n    def add_read_sub(self, register, subreg, data):\n        if register not in self.reads_sub.keys():\n            self.reads_sub[register] = {}\n        self.reads_sub[register][subreg] = data\n\n    def prep_read(self, cmd, cmdinf):\n        pass\n\n    def prep_read_sub(self, cmd, cmdinf, subcmd, subcmdinf):\n        if subcmd == MANUFACTURER_ACCESS_CMD_BQGENERIC.FirmwareVersion:\n            register = 0x2f\n            self.reads[register] = self.reads_sub[cmd.value][subcmd.value]\n\n    def do_read(self, i2c_addr, register):\n        data = bytes(self.reads[register])\n        return data\n\n    def prep_write(self, cmd, cmdinf):\n        pass\n\n    def prep_write_sub(self, cmd, cmdinf, subcmd, subcmdinf):\n        pass\n\n    def do_write(self, i2c_addr, register, value):\n        pass\n\n\nclass i2c_msg_mock(object):\n    def __init__(self, **kwargs):\n        vars(self).update(kwargs)\n\n    def __bytes__(self):\n        return bytes(self.buf[0:self.len])\n\n    @staticmethod\n    def read(address, length):\n        return i2c_msg_mock(addr=address, flags=0, len=length, buf=None)\n\n    @staticmethod\n    def write(address, buf):\n        return i2c_msg_mock(addr=address, flags=1, len=len(buf), buf=bytes(buf))\n\n\nclass SMBusMock(object):\n    \"\"\" Mock SMBus module, used for dry-run testing.\n\n    Implements PEC and block sizes, but for actual data requires mock chip.\n    \"\"\"\n    def __init__(self, busid=None, force=False):\n        self.address = None\n        self.busid = busid\n        self.force = force\n        self.pec = False\n        self.expect_block = False\n        self.mock = ChipMock(self)\n        self.mock_exception = None\n\n    def open(self, busid):\n        self.busid = busid\n\n    def close(self):\n        self.busid = None\n\n    def write_quick(self, i2c_addr, force=None):\n        pass\n\n    def read_byte(self, i2c_addr, force=None):\n        return 1\n\n    def write_byte(self, i2c_addr, value, force=None):\n        pass\n\n    def read_byte_data(self, i2c_addr, register, force=None):\n        data = self.do_mock_read(i2c_addr, register)\n        return data[0]\n\n    def write_byte_data(self, i2c_addr, register, value, force=None):\n        self.do_mock_write(i2c_addr, register, struct.pack('<B', value))\n\n    def read_word_data(self, i2c_addr, register, force=None):\n        data = self.do_mock_read(i2c_addr, register)\n        return struct.unpack('<H', data[0:2])[0]\n\n    def write_word_data(self, i2c_addr, register, value, force=None):\n        self.do_mock_write(i2c_addr, register, struct.pack('<H', value))\n\n    def write_dword_data(self, i2c_addr, register, value, force=None):\n        self.do_mock_write(i2c_addr, register, struct.pack('<L', value))\n\n    def process_call(self, i2c_addr, register, value, force=None):\n        pass\n\n    def read_block_data(self, i2c_addr, register, force=None):\n        data = self.do_mock_read(i2c_addr, register, is_block=True)\n        return data[1:data[0]+1]\n\n    def write_block_data(self, i2c_addr, register, data, force=None):\n        self.do_mock_write(i2c_addr, register, bytes(data), is_block=True)\n\n    def read_i2c_block_data(self, i2c_addr, register, length, force=None):\n        data = self.do_mock_read(i2c_addr, register, is_block=True)\n        data = data + bytes([data[-1]] * 32)\n        return data[0:length] # For some reason this doesn't start at 1\n\n    def write_i2c_block_data(self, i2c_addr, register, data, force=None):\n        self.do_mock_write(i2c_addr, register, bytes(data), is_block=True)\n\n    def i2c_rdwr(self, *i2c_msgs):\n        data = None\n        register = None\n        is_read = False\n        for msg in i2c_msgs:\n            if msg.flags == 1:\n                register = msg.buf[0]\n            else:\n                is_read = True\n        # msg stays assigned from last iteration\n        if is_read:\n            data = self.do_mock_read(msg.addr, register,\n              is_block=self.expect_block)\n            msg.buf = data\n        else:\n            self.do_mock_write(msg.addr, register, msg.buf[1:],\n              is_block=self.expect_block)\n\n    def add_mock_read(self, register, data):\n        self.mock.add_read(register, data)\n\n    def add_mock_read_sub(self, register, subreg, data):\n        self.mock.add_read_sub(register, subreg, data)\n\n    def add_mock_except(self, ex):\n        self.mock_exception = ex\n\n    def prep_expect_block(self, cmdinf):\n        if cmdinf is None or 'type' not in cmdinf:\n            resp_type = 'byte[]'\n        elif 'resp_location' in cmdinf:\n            resp_type = 'byte[]'\n        else:\n            resp_type = cmdinf['type']\n        self.expect_block = (resp_type.startswith(\"byte[\") or\n          resp_type.startswith(\"string\") or resp_type.endswith(\"_blk\"))\n\n    def prep_mock_read(self, cmd, subcmd=None):\n        cmdinf = SBS_CMD_INFO[cmd]\n        if 'subcmd_infos' in cmdinf:\n            subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n            self.prep_expect_block(subcmdinf)\n            self.mock.prep_read_sub(cmd, cmdinf, subcmd, subcmdinf)\n        else:\n            self.prep_expect_block(cmdinf)\n            self.mock.prep_read(cmd, cmdinf)\n\n    def do_mock_read(self, i2c_addr, register, is_block=False):\n        data = self.mock.do_read(i2c_addr, register)\n        if is_block: data = bytes([len(data)]) + data\n        if is_block and self.pec:\n            whole_packet = smbus_recreate_read_packet_data(i2c_addr,\n              register, data)\n            pec = crc8_ccitt_compute(whole_packet)\n            data = data + bytes([pec])\n        return data\n\n    def prep_mock_write(self, cmd, subcmd=None):\n        cmdinf = SBS_CMD_INFO[cmd]\n        if 'subcmd_infos' in cmdinf:\n            subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n            self.mock.prep_write_sub(cmd, cmdinf, subcmd, subcmdinf)\n        else:\n            self.mock.prep_write(cmd, cmdinf)\n\n    def do_mock_write(self, i2c_addr, register, value, is_block=False):\n        if self.mock_exception is not None:\n            ex = self.mock_exception\n            self.mock_exception = None\n            raise ex\n        self.mock.do_write(i2c_addr, register, value)\n\n\ndef crc8_ccitt_byte(crc, dt):\n    \"\"\" Add one byte to smbus PEC crc-8 calculation\n    \"\"\"\n    ncrc = crc ^ dt\n    for i in range(8):\n        if ( ncrc & 0x80 ) != 0:\n            ncrc <<= 1\n            ncrc ^= 0x07\n        else:\n            ncrc <<= 1\n    return ncrc & 0xff\n\ndef crc8_ccitt_compute(data):\n    crc = 0\n    for dt in data:\n        crc = crc8_ccitt_byte(crc, dt)\n    return crc\n\n\ndef str_exception_with_type(ex):\n    if type(ex).__name__ not in str(ex):\n        return \"{}: {}\".format(type(ex).__name__,str(ex))\n    return str(ex)\n\n\ndef is_ti_bq_chip(chip):\n    \"\"\" Returns whether the chip is Texas Instruments BQ chip\n\n    Also gives True if the chip awaits auto-detection.\n    \"\"\"\n    return chip.name.startswith(\"BQ\") or chip == CHIP_TYPE.AUTO\n\n\ndef type_str_value_length(type_str):\n    m = re.match(r'(byte|string)\\[([0-9]+|0x[0-9a-fA-F]+)\\]', type_str)\n    if m:\n        return int(m.group(2),0)\n    elif type_str in (\"int8\",\"uint8\",):\n        return 1\n    elif type_str in (\"int16\",\"uint16\",\"int16_blk\",\"uint16_blk\",):\n        return 2\n    elif type_str in (\"uint24\",\"uint24_blk\",):\n        return 3\n    elif type_str in (\"int32\",\"uint32\",\"int32_blk\",\"uint32_blk\",):\n        return 4\n    elif type_str in (\"float\",\"float_blk\",):\n        return 4\n    return 32\n\n\ndef bytes_to_type_str(b, type_str, endian=\"le\"):\n    if endian == \"be\":\n        endian = '>'\n    else:\n        endian = '<'\n    if type_str in (\"int8\",):\n        (v,) = struct.unpack(endian+'b', bytearray(b)[0:1])\n    elif type_str in (\"uint8\",):\n        (v,) = struct.unpack(endian+'B', bytearray(b)[0:1])\n    elif type_str in (\"int16\",\"int16_blk\",):\n        (v,) = struct.unpack(endian+'h', bytearray(b)[0:2])\n    elif type_str in (\"uint16\",\"uint16_blk\",):\n        (v,) = struct.unpack(endian+'H', bytearray(b)[0:2])\n    elif type_str in (\"uint24\",\"uint24_blk\",):\n        (v,) = struct.unpack(endian+'L', bytearray(b)[0:3]+bytes([0]))\n    elif type_str in (\"int32\",\"int32_blk\",):\n        (v,) = struct.unpack(endian+'l', bytearray(b)[0:4])\n    elif type_str in (\"uint32\",\"uint32_blk\",):\n        (v,) = struct.unpack(endian+'L', bytearray(b)[0:4])\n    elif type_str in (\"float\",\"float_blk\",):\n        (v,) = struct.unpack(endian+'f', bytearray(b)[0:4])\n    else:\n        v = b\n    return v\n\n\ndef type_str_to_bytes(v, type_str, endian=\"le\"):\n    if endian == \"be\":\n        endian = '>'\n    else:\n        endian = '<'\n    if type_str in (\"int8\",):\n        b = struct.pack(endian+'b', v)\n    elif type_str in (\"uint8\",):\n        b = struct.pack(endian+'B', v)\n    elif type_str in (\"int16\",\"int16_blk\",):\n        b = struct.pack(endian+'h', v)\n    elif type_str in (\"uint16\",\"uint16_blk\",):\n        b = struct.pack(endian+'H', v)\n    elif type_str in (\"uint24\",\"uint24_blk\",):\n        b = struct.pack(endian+'L', v)\n    elif type_str in (\"int32\",\"int32_blk\",):\n        b = struct.pack(endian+'l', v)\n    elif type_str in (\"uint32\",\"uint32_blk\",):\n        b = struct.pack(endian+'L', v)\n    elif type_str in (\"float\",\"float_blk\",):\n        b = struct.pack(endian+'f', v)\n    else:\n        b = bytes(v)\n    return b\n\n\ndef smbus_recreate_read_packet_data(dev_addr, cmd, resp_data):\n  \"\"\" Re-creates read command packet with response\n\n  The data is useful for PEC calculation.\n  \"\"\"\n  if isinstance(cmd, enum.Enum):\n      register = cmd.value\n  else:\n      register = int(cmd)\n  data = bytes([(dev_addr << 1) + 0, register, (dev_addr << 1) + 1]) + \\\n    bytes(resp_data)\n  return data\n\n\ndef smbus_recreate_write_packet_data(dev_addr, cmd, req_data):\n  \"\"\" Re-creates read command packet with response\n\n  The data is useful for PEC calculation.\n  \"\"\"\n  data = bytes([(dev_addr << 1) + 0, cmd.value]) + bytes(req_data)\n  return data\n\n\ndef smbus_open(bus_str, po):\n    \"\"\" Opens the System Managememnt Bus over I2C interface\n\n    The current implementation is for Rapsberry Pi.\n    \"\"\"\n    global bus\n    global i2c_msg\n    m = re.match(r'(smbus|i2c):([0-9]+)', bus_str)\n    if m:\n        po.api_type = str(m.group(1))\n        bus_index = int(m.group(2),0)\n        if po.dry_run:\n            bus = SMBusMock(bus_index)\n            bus.pec = True\n            if po.api_type == \"i2c\":\n                class i2c_msg(i2c_msg_mock):\n                    pass\n            return\n        import smbus2\n        bus = smbus2.SMBus(bus_index)\n        bus.pec = True\n        if po.api_type == \"i2c\":\n            from smbus2 import i2c_msg\n        return\n    raise ValueError(\"Unrecognized bus definition\")\n\n\ndef smbus_close():\n    \"\"\" Closes the System Managememnt Bus over I2C interface\n    \"\"\"\n    global bus\n    bus.close()\n    bus = None\n\n\ndef smbus_write_raw(bus, dev_addr, b, po):\n    if (po.verbose > 2):\n        print(\"Raw write: DATA={}\".format(\n          \" \".join('{:02x}'.format(x) for x in b)))\n\n    if po.api_type == \"i2c\":\n        if callable(getattr(bus, \"i2c_rdwr\", None)):\n            use_api_type = \"i2c\"\n        else:\n            print(\"No real raw write supported; using smbus write\")\n            use_api_type = \"smbus\"\n    else:\n        use_api_type = po.api_type\n\n    if use_api_type == \"smbus\":\n        # Try to send the raw data using normal smbus API\n        orig_pec = bus.pec\n        try:\n            bus.pec = False\n            if len(b) in (2,3):\n                (v,) = struct.unpack('<H', bytearray(bytes(b[1:]) + b'\\0')[0:2])\n                bus.write_word_data(dev_addr, b[0], v)\n            else:\n                raise NotImplementedError(\n                  \"No way of sending such raw data via smbus api\")\n        finally:\n            bus.pec = orig_pec\n    elif use_api_type == \"i2c\":\n        part_write = i2c_msg.write(dev_addr, b)\n        bus.i2c_rdwr(part_write)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\".format(po.api_type))\n\n\ndef smbus_read_word(bus, dev_addr, cmd, resp_type, po):\n    \"\"\" Read 16-bit integer from SMBus command, using READ_WORD protocol.\n    \"\"\"\n    if po.api_type == \"smbus\":\n        v = bus.read_word_data(dev_addr, cmd.value)\n        if (po.verbose > 2):\n            print(\"Raw {} response: 0x{:x}\".format(cmd.name, v))\n        if v < 0 or v > 65535:\n            raise ValueError((\n              \"Received value of command {} is beyond type {} bounds\"\n              ).format(cmd.name,resp_type))\n        if resp_type in (\"int16\",): # signed type support\n            if v > 32767:\n                v -= 65536\n    elif po.api_type == \"i2c\":\n        part_write = i2c_msg.write(dev_addr, [cmd.value])\n        part_read = i2c_msg.read(dev_addr, 2 + (1 if bus.pec else 0))\n        bus.i2c_rdwr(part_write, part_read)\n        b = bytes(part_read)\n        if (po.verbose > 2):\n            print(\"Raw {} response: {}\".format(cmd.name,\n              \" \".join('{:02x}'.format(x) for x in b)))\n        if len(b) > 2:\n            whole_packet = smbus_recreate_read_packet_data(dev_addr, cmd, b[0:2])\n            pec = crc8_ccitt_compute(whole_packet)\n            if b[2] != pec:\n                raise ValueError((\n                  \"Received {} from command {} with wrong PEC checksum\"\n                  ).format(resp_type,cmd.name))\n        v = bytes_to_type_str(b[0:2], resp_type)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\"\n          .format(po.api_type))\n    return v\n\n\ndef smbus_read_long(bus, dev_addr, cmd, resp_type, po):\n    \"\"\" Read 32-bit integer from SMBus command, reading just 4 bytes.\n    \"\"\"\n    if po.api_type == \"smbus\":\n        b = bus.read_i2c_block_data(dev_addr, cmd.value, 4)\n    elif po.api_type == \"i2c\":\n        part_write = i2c_msg.write(dev_addr, [cmd.value])\n        part_read = i2c_msg.read(dev_addr, 4 + (1 if bus.pec else 0))\n        bus.i2c_rdwr(part_write, part_read)\n        b = bytes(part_read)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\"\n          .format(po.api_type))\n\n    if (po.verbose > 2):\n        print(\"Raw {} response: {}\".format(cmd.name,\n          \" \".join('{:02x}'.format(x) for x in b)))\n\n    if len(b) > 4:\n        whole_packet = smbus_recreate_read_packet_data(dev_addr, cmd, b[0:4])\n        pec = crc8_ccitt_compute(whole_packet)\n        if b[4] != pec:\n            raise ValueError((\n              \"Received {} from command {} with wrong PEC checksum\"\n              ).format(resp_type,cmd.name))\n    return bytes_to_type_str(b, resp_type)\n\n\ndef smbus_read_block_for_basecmd(bus, dev_addr, cmd, basecmd_name, resp_type, po):\n    \"\"\" Read block from cmd, use basecmd_name for logging\n\n    Needed because request cmd isn't always clearly identifying what we're reading.\n    \"\"\"\n    expect_len = type_str_value_length(resp_type)\n    # Try reading expected length first\n    if po.api_type == \"smbus\":\n        # 32 is SMBus 2.0 limit, it is enforced by Linux kernel I2C module\n        expect_len = min(expect_len + 1 + (1 if bus.pec else 0), 32)\n        b = bus.read_i2c_block_data(dev_addr, cmd.value, expect_len)\n    elif po.api_type == \"i2c\":\n        # 36 = 32 sbs max len +2 subcmd +1 length, +1 PEC\n        expect_len = min(expect_len + 1 + (1 if bus.pec else 0), 36)\n        part_write = i2c_msg.write(dev_addr, [cmd.value])\n        part_read = i2c_msg.read(dev_addr, expect_len)\n        bus.i2c_rdwr(part_write, part_read)\n        b = bytes(part_read)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\".format(po.api_type))\n\n    # block starts with 1-byte lenght\n    if (len(b) < 1):\n        raise ValueError((\n          \"Received {} from command {} is too short to even have length\"\n          ).format(resp_type,basecmd_name))\n\n    # check if we meet the expected length restriction\n    if len(b) >= b[0] + 1:\n        pass # length expectations met\n    elif po.api_type == \"smbus\":\n        # 32 is SMBus 2.0 limit, it is enforced by Linux kernel I2C module\n        expect_len = 32\n        b = bus.read_i2c_block_data(dev_addr, cmd.value, expect_len)\n        if len(b) == 32 and b[0] in (32,33,34,):\n            # We've lost last bytes; but there is no other way - accept\n            # the truncated message. Otherwise communicating messages\n            # >  31-byte would just not work\n            if (po.verbose > 0):\n                print(\"Warning: Response truncated because of Smbus 2.0 constrains; adding zeros\")\n            b += b'\\0' * (b[0]-31)\n    elif po.api_type == \"i2c\":\n        # 36 = 32 sbs max len +2 subcmd +1 length, +1 PEC\n        expect_len = 32 + 2 + 1 + (1 if bus.pec else 0)\n        part_write = i2c_msg.write(dev_addr, [cmd.value])\n        part_read = i2c_msg.read(dev_addr, expect_len)\n        bus.i2c_rdwr(part_write, part_read)\n        b = bytes(part_read)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\"\n          .format(po.api_type))\n\n    if (po.verbose > 2):\n        print(\"Raw {} response: {}\".format(basecmd_name,\n          \" \".join('{:02x}'.format(x) for x in b)))\n\n    if len(b) < b[0] + 1:\n        raise ValueError(\"Received {} from command {} has invalid length\"\n          .format(resp_type,basecmd_name))\n\n    # check PEC crc-8 byte (unless the packet was so long that we didn't receive it)\n    if len(b) >= b[0] + 2:\n        whole_packet = smbus_recreate_read_packet_data(dev_addr, cmd, b[0:b[0]+1])\n        pec = crc8_ccitt_compute(whole_packet)\n        if b[b[0]+1] != pec:\n            raise ValueError(\"Received {} from command {} with wrong PEC checksum\"\n              .format(resp_type,basecmd_name))\n\n    # prepare data part of the message\n    v = bytes(b[1:b[0]+1])\n    return v\n\n\ndef smbus_read_block(bus, dev_addr, cmd, resp_type, po):\n    \"\"\" Read block from cmd\n    \"\"\"\n    return smbus_read_block_for_basecmd(bus, dev_addr, cmd, cmd.name, resp_type, po)\n\n\ndef smbus_read_word_blk(bus, dev_addr, cmd, resp_type, po):\n    \"\"\" Read 16-bit integer from SMBus command, using READ_BLOCK protocol.\n    \"\"\"\n    b = smbus_read_block_for_basecmd(bus, dev_addr, cmd, cmd.name, resp_type, po)\n    return bytes_to_type_str(b, resp_type)\n\n\ndef smbus_read_long_blk(bus, dev_addr, cmd, resp_type, po):\n    \"\"\" Read 32-bit integer from SMBus command, using READ_BLOCK protocol.\n    \"\"\"\n    b = smbus_read_block_for_basecmd(bus, dev_addr, cmd, cmd.name, resp_type, po)\n    return bytes_to_type_str(b, resp_type)\n\n\ndef smbus_write_word(bus, dev_addr, cmd, v, val_type, po):\n    if po.api_type == \"smbus\":\n        if val_type in (\"int16\",): # signed type support\n            if v < 0:\n                v += 65536\n        if v < 0 or v > 65535:\n            raise ValueError((\n              \"Value to write for command {} is beyond type {} bounds\"\n              ).format(cmd.name,val_type))\n        if (po.verbose > 2):\n            print(\"Write {}: {:02x} WORD=0x{:x}\".format(cmd.name, cmd.value, v))\n        bus.write_word_data(dev_addr, cmd.value, v)\n    elif po.api_type == \"i2c\":\n        b = type_str_to_bytes(v, val_type, endian=\"le\")\n        if (po.verbose > 2):\n            print(\"Write {}: CMD={:02x} WORD={}\".format(cmd.name,\n              cmd.value, \" \".join('{:02x}'.format(x) for x in b)))\n        if bus.pec:\n            whole_packet = smbus_recreate_write_packet_data(dev_addr, cmd, b)\n            pec = crc8_ccitt_compute(whole_packet)\n            b = bytes([cmd.value]) + b + bytes([pec])\n        else:\n            b = bytes([cmd.value]) + b\n        part_write = i2c_msg.write(dev_addr, b)\n        bus.i2c_rdwr(part_write)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\".format(po.api_type))\n\n\ndef smbus_write_long(bus, dev_addr, cmd, v, val_type, po):\n    if po.api_type == \"smbus\":\n        if val_type in (\"int32\",): # signed type support\n            if v < 0:\n                v += 0x100000000\n        if v < 0 or v > 0xFFFFFFFF:\n            raise ValueError((\n              \"Value to write for command {} is beyond type {} bounds\"\n              ).format(cmd.name,val_type))\n        if (po.verbose > 2):\n            print(\"Write {}: {:02x} LONG=0x{:x}\".format(cmd.name, cmd.value, v))\n        bus.write_dword_data(dev_addr, cmd.value, v)\n    elif po.api_type == \"i2c\":\n        b = type_str_to_bytes(v, val_type, endian=\"le\")\n        if (po.verbose > 2):\n            print(\"Write {}: CMD={:02x} LONG={}\".format(cmd.name,\n              cmd.value, \" \".join('{:02x}'.format(x) for x in b)))\n        if bus.pec:\n            whole_packet = smbus_recreate_write_packet_data(dev_addr, cmd, b)\n            pec = crc8_ccitt_compute(whole_packet)\n            b = bytes([cmd.value]) + b + bytes([pec])\n        else:\n            b = bytes([cmd.value]) + b\n        part_write = i2c_msg.write(dev_addr, b)\n        bus.i2c_rdwr(part_write)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\".format(po.api_type))\n\n\ndef smbus_write_block_for_basecmd(bus, dev_addr, cmd, v, basecmd_name, val_type, po):\n    \"\"\" Write block to cmd, use basecmd_name for logging\n    \"\"\"\n    b = v\n    if po.api_type == \"smbus\":\n        if (po.verbose > 2):\n            print(\"Write {}: {:02x} BLOCK={}\".format(basecmd_name,\n              cmd.value, \" \".join('{:02x}'.format(x) for x in b)))\n        bus.write_block_data(dev_addr, cmd.value, b)\n    elif po.api_type == \"i2c\":\n        if (po.verbose > 2):\n            print(\"Write {}: CMD={:02x} BLOCK={}\".format(basecmd_name,\n              cmd.value, \" \".join('{:02x}'.format(x) for x in b)))\n        if bus.pec:\n            whole_packet = smbus_recreate_write_packet_data(dev_addr, cmd, bytes([len(b)]) + b)\n            pec = crc8_ccitt_compute(whole_packet)\n            b = bytes([cmd.value,len(b)]) + b + bytes([pec])\n        else:\n            b = bytes([cmd.value,len(b)]) + b\n        part_write = i2c_msg.write(dev_addr, b)\n        bus.i2c_rdwr(part_write)\n    else:\n        raise NotImplementedError(\"Unsupported bus API type '{}'\".format(po.api_type))\n\n\ndef smbus_write_block(bus, dev_addr, cmd, v, val_type, po):\n    \"\"\" Write block to cmd\n    \"\"\"\n    smbus_write_block_for_basecmd(bus, dev_addr, cmd, v, cmd.name, val_type, po)\n\n\ndef smbus_write_word_blk(bus, dev_addr, cmd, v, val_type, po):\n    b = type_str_to_bytes(v, val_type)\n    smbus_write_block_for_basecmd(bus, dev_addr, cmd, b, cmd.name, val_type, po)\n\n\ndef smbus_write_long_blk(bus, dev_addr, cmd, v, val_type, po):\n    b = type_str_to_bytes(v, val_type)\n    smbus_write_block_for_basecmd(bus, dev_addr, cmd, b, cmd.name, val_type, po)\n\n\ndef smbus_read_raw_block_by_writing_word_subcmd(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po):\n    \"\"\" Read raw value of a sub-command, performing subcmd selection write first.\n\n    Used to access ManufacturerAccess sub-commands of the battery.\n    Returns bytes array received in response, without converting the type.\n    \"\"\"\n    # write sub-command to ManufacturerAccess\n    smbus_write_word(bus, dev_addr, cmd, subcmd.value, \"uint16\", po)\n    # Check if sleep needed inbetween requests\n    if resp_wait > 0:\n        time.sleep(resp_wait)\n    # This function should never be called for void type; if it was, error out\n    if resp_type == \"void\":\n        raise TypeError(\"Reading should not be called for a void response type\")\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    v = smbus_read_block_for_basecmd(bus, dev_addr, resp_cmd, basecmd_name, resp_type, po)\n    return v\n\n\ndef smbus_write_raw_block_by_writing_word_subcmd(bus, dev_addr, cmd, subcmd, v, resp_type, resp_cmd, resp_wait, po):\n    \"\"\" Write raw value of a sub-command, performing subcmd selection word write first.\n\n    Used to access ManufacturerAccess sub-commands of the battery.\n    Expects value to already be bytes array ready for sending.\n    \"\"\"\n    # write sub-command to ManufacturerAccess\n    smbus_write_word(bus, dev_addr, cmd, subcmd.value, \"uint16\", po)\n    # Check if sleep needed inbetween requests\n    if resp_wait > 0:\n        time.sleep(resp_wait)\n    # If the type to store is void, meaning we're writing to trigger switch - that's all\n    if resp_type == \"void\":\n        return\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    smbus_write_block_for_basecmd(bus, dev_addr, resp_cmd, v, basecmd_name, resp_type, po)\n\n\ndef smbus_read_raw_block_by_writing_block_subcmd(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po):\n    \"\"\" Read raw value of a sub-command, performing subcmd selection block write first.\n\n    Used to access ManufacturerBlockAccess sub-commands of the battery.\n    Returns bytes array received in response, without converting the type.\n    \"\"\"\n    # write sub-command to ManufacturerBlockAccess\n    smbus_write_word_blk(bus, dev_addr, cmd, subcmd.value, \"uint16_blk\", po)\n    # Check if sleep needed inbetween requests\n    if resp_wait > 0:\n        time.sleep(resp_wait)\n    # This function should never be called for void type; if it was, error out\n    if resp_type == \"void\":\n        raise TypeError(\"Reading should not be called for a void response type\")\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    v = smbus_read_block_for_basecmd(bus, dev_addr, resp_cmd, basecmd_name, resp_type, po)\n    return v\n\n\ndef smbus_perform_unseal_bq_sha1_hmac(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, sec_key_hex, po):\n    \"\"\" Execute Unseal or Full Access operation using SHA-1/HMAC algorithm, for BQ30 chips.\n    \"\"\"\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    if not resp_type.startswith(\"byte[\"):\n        # Command with unexpected params - cannot perform the auth\n        raise ValueError(\"Cannot perform SHA-1/HMAC auth with response type '{}'\".format(resp_type))\n    KD = bytes.fromhex(sec_key_hex)\n    if len(KD) != 16:\n        raise ValueError(\"Algorithm broken, length of unseal key KD is {} instead of {} bytes\".format(len(KD),16))\n    # write UnSealDevice/FullAccessDevice sub-command to ManufacturerAccess, then read 160-bit message M\n    if po.dry_run:\n        bus.prep_mock_read(cmd, subcmd)\n    M = smbus_read_raw_block_by_writing_word_subcmd(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po)\n    M = bytes(reversed(M))\n    if len(M) != 20:\n        raise ValueError(\"Algorithm broken, length of challenge message M is {} instead of {} bytes\".format(len(M),20))\n    # Generate SHA-1 input block B1 of 512 bytes (total input =128-bit unseal/full access key KD\n    # + 160 bit message M + 1 + 159 0s + 100100000)\n    B1 = KD + M # the rest will be added automatically to the message, as hashlib honors FIPS 180-2\n    if (po.verbose > 2):\n        print(\"Prepared {} B1={}\".format(basecmd_name, B1.hex()))\n    if len(B1) != 288//8:\n        raise ValueError(\"Algorithm broken, length of input block B1 is {} instead of {} bits\".format(len(B1)*8,288))\n    # Generate SHA-1 hash HMAC1 using B1\n    HMAC1 = hashlib.sha1(B1).digest()\n    if (po.verbose > 2):\n        print(\"Computed {} HMAC1={}\".format(basecmd_name,HMAC1.hex()))\n    # Generate SHA-1 input block B2 of 512 bytes (total input =128-bit unseal/full access key KD\n    # + 160 bit hash HMAC1 + 1 + 159 0s + 100100000)\n    B2 = KD + HMAC1 # the rest is added automatically in accordance to FIPS 180-2\n    # Generate SHA-1 hash HMAC2 using B2\n    HMAC2 = hashlib.sha1(B2).digest()\n    if (po.verbose > 2):\n        print(\"Computed {} HMAC2={}\".format(basecmd_name,HMAC2.hex()))\n    # Write 160-bit hash HMAC2 to ManufacturerInput()/Authenticate() in the format\n    # 0xAABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTT, where AA is LSB\n    HMAC2 = bytes(reversed(HMAC2))\n    if False: # re-creation of the whole packet, for debug\n        whole_packet = smbus_recreate_write_packet_data(dev_addr, resp_cmd, bytes([len(HMAC2)]) + HMAC2)\n        pec = crc8_ccitt_compute(whole_packet)\n        print(\"WHOLE:\", \" \".join('{:02x}'.format(x) for x in whole_packet), '{:02x}'.format(pec))\n    smbus_write_block_for_basecmd(bus, dev_addr, resp_cmd, HMAC2, basecmd_name, resp_type, po)\n    # Device compares hash HMAC2 with internal calculated hash HMAC3. If it matches, device\n    # allows UNSEALED/FULL ACCESS mode indicated with the OperationStatus()[SEC1],[SEC0] flags.\n    return\n\ndef smbus_perform_unseal_bq_2word_sckey(bus, dev_addr, cmd, resp_wait, sec_key_w0, sec_key_w1, vals, po):\n    \"\"\" Execute Unseal or Full Access operation using 2 Word MA commands, for BQ40 chips.\n    \"\"\"\n    subcmd0 = ImprovisedCommand(value=sec_key_w0, name=\"SecKeyWord{:x}\".format(0))\n    subcmd1 = ImprovisedCommand(value=sec_key_w1, name=\"SecKeyWord{:x}\".format(1))\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd0.name)\n    # Unsealing is a two-step command, performed by writing the first word\n    # of the unseal key to ManufacturerAccess() (MAC), followed by the second\n    # word of the unseal key to ManufacturerAccess(). The two words must be\n    # sent within 4 sec.\n    subcmdinf = {\n        'type'\t: \"void\",\n        'unit'\t: {'scale':None, 'name':\"hex\"},\n        'tiny_name'\t: \"SKeyUD\",\n        'desc'\t: \"Word of Security key.\",\n    }\n    # Make sure the command isn't just one of known commands; would be bad to start triggering random things\n    for ckcmd, ckcmdinfo in MANUFACTURER_BLOCK_ACCESS_CMD_BQ_INFO.items():\n        ckcmd_range = 1\n        if 'cmd_array' in ckcmdinfo:\n            ckcmd_range = ckcmdinfo['cmd_array']\n        if (subcmd0.value >= ckcmd.value) and (subcmd0.value < ckcmd.value + ckcmd_range):\n            raise ValueError(\"First word of security key (0x{:04x}) cannot be valid MAC command\".format(subcmd0.value))\n    v = b''\n    if True:\n        if po.dry_run:\n            bus.prep_mock_write(cmd, subcmd0)\n        u = smbus_write_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd0, subcmdinf, v, po)\n    if True:\n        if po.dry_run:\n            bus.prep_mock_write(cmd, subcmd1)\n        u = smbus_write_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd1, subcmdinf, v, po)\n    return\n\ndef smbus_read_block_val_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po):\n    \"\"\" Reads value of a sub-command which requires the subcmd selection write first.\n\n    Converts the received bytes to properly typed value, based on resp_type.\n    Handles retries, if neccessary.\n    \"\"\"\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    if (po.verbose > 2):\n        print(\"Query {}: {:02x} WORD=0x{:x}\".format(basecmd_name, cmd.value, subcmd.value))\n\n    b = None\n    for nretry in reversed(range(3)):\n        try:\n            b = smbus_read_raw_block_by_writing_word_subcmd(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po)\n        except Exception as ex:\n            if (nretry > 0) and (\n              (isinstance(ex, OSError) and ex.errno in (5,121,))\n              # 5 = Input/output error, sometimes just happens\n              # 121 = I/O error, usually means no ACK\n              ):\n                if (po.verbose > 2):\n                    print(\"Retrying due to error: \"+str_exception_with_type(ex))\n                pass\n            else:\n                raise\n        if b is None:\n            time.sleep(0.25)\n            continue\n        break\n\n    v = bytes_to_type_str(b, resp_type, \"le\")\n\n    return v\n\n\ndef smbus_write_block_val_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, v, stor_type, stor_cmd, stor_wait, po):\n    \"\"\" Writes value to a sub-command which requires the subcmd selection write first.\n\n    Converts the value v to proper bytes array for write, based on stor_type.\n    Handles retries, if neccessary.\n    \"\"\"\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    if (po.verbose > 2):\n        print(\"Store {}: {:02x} WORD=0x{:x}\".format(basecmd_name, cmd.value, subcmd.value))\n\n    b = type_str_to_bytes(v, stor_type, \"le\")\n\n    for nretry in reversed(range(1)):\n        try:\n            smbus_write_raw_block_by_writing_word_subcmd(bus, dev_addr, cmd, subcmd, b, stor_type, stor_cmd, stor_wait, po)\n        except Exception as ex:\n            if (nretry > 0) and (\n              (isinstance(ex, OSError) and ex.errno in (5,121,))\n              # 5 = Input/output error, sometimes just happens\n              # 121 = I/O error, usually means no ACK\n              ):\n                if (po.verbose > 2):\n                    print(\"Retrying due to error: \"+str_exception_with_type(ex))\n                pass\n            else:\n                raise\n        if b is None:\n            time.sleep(0.25)\n            continue\n        break\n\n    return\n\n\ndef smbus_read_macblock_val_by_writing_block_subcmd_first(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po):\n    \"\"\" Reads value of a sub-command which requires the subcmd selection write first, and expects sub-cmd at start of output.\n\n    Converts the received bytes to properly typed value, based on resp_type.\n    Handles retries, if neccessary.\n    \"\"\"\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    if (po.verbose > 2):\n        print(\"Query {}: {:02x} WORD=0x{:x}\".format(basecmd_name, cmd.value, subcmd.value))\n\n    b = None\n    expect_len = type_str_value_length(resp_type)\n    full_resp_type = \"byte[{}]\".format(expect_len+2)\n    for nretry in reversed(range(3)):\n        try:\n            full_b = smbus_read_raw_block_by_writing_block_subcmd(bus, dev_addr, cmd, subcmd, full_resp_type, resp_cmd, resp_wait, po)\n            subcmd_num = bytes_to_type_str(full_b[:2], \"uint16\", \"le\")\n            if subcmd_num != subcmd.value:\n                raise ValueError(\"Read claims the subcmd was 0x{:x} instead of 0x{:x}\".format(subcmd_num,subcmd.value))\n            b = full_b[2:]\n        except Exception as ex:\n            if (nretry > 0) and (\n              (isinstance(ex, OSError) and ex.errno in (5,121,)) or\n              # 5 = Input/output error, sometimes just happens\n              # 121 = I/O error, usually means no ACK\n              isinstance(ex, ValueError)\n              ):\n                if (po.verbose > 2):\n                    print(\"Retrying due to error: \"+str_exception_with_type(ex))\n                pass\n            else:\n                raise\n        if b is None:\n            time.sleep(0.25)\n            continue\n        break\n\n\n    v = bytes_to_type_str(b, resp_type, \"le\")\n\n    return v\n\n\ndef smbus_write_macblock_val_adding_block_subcmd_first(bus, dev_addr, cmd, subcmd, v, stor_type, stor_wait, po):\n    \"\"\" Writes value to a sub-command which requires the subcmd written at start of the data.\n\n    Converts the value v to proper bytes array for write, based on stor_type.\n    Handles retries, if neccessary.\n    \"\"\"\n    basecmd_name = \"{}.{}\".format(cmd.name,subcmd.name)\n    if (po.verbose > 2):\n        print(\"Store {}: {:02x} WORD=0x{:x}\".format(basecmd_name, cmd.value, subcmd.value))\n\n    b = type_str_to_bytes(v, stor_type, \"le\")\n    v = type_str_to_bytes(subcmd.value, \"uint16\", \"le\") + b[1:]\n    full_stor_type = \"byte[{}]\".format(len(v))\n\n    for nretry in reversed(range(1)):\n        try:\n            smbus_write_block_for_basecmd(bus, dev_addr, cmd, v, basecmd_name, full_stor_type, po)\n        except Exception as ex:\n            if (nretry > 0) and (\n              (isinstance(ex, OSError) and ex.errno in (5,121,))\n              # 5 = Input/output error, sometimes just happens\n              # 121 = I/O error, usually means no ACK\n              ):\n                if (po.verbose > 2):\n                    print(\"Retrying due to error: \"+str_exception_with_type(ex))\n                pass\n            else:\n                raise\n        if b is None:\n            time.sleep(0.25)\n            continue\n        break\n\n    return\n\n\ndef smbus_read_simple(bus, dev_addr, cmd, resp_type, resp_unit, retry_count, po):\n    \"\"\" Reads value of simple command from the battery.\n\n    Returns the value as either a number or byte array, depending on type.\n    \"\"\"\n    if po.dry_run:\n        bus.prep_mock_read(cmd)\n\n    v = None\n    for nretry in reversed(range(retry_count)):\n        try:\n            if resp_type in (\"int16\",\"uint16\",):\n                v = smbus_read_word(bus, dev_addr, cmd, resp_type, po)\n\n            elif resp_type in (\"int16_blk\",\"uint16_blk\",):\n                v = smbus_read_word_blk(bus, dev_addr, cmd, resp_type, po)\n\n            elif resp_type in (\"int32\",\"uint32\",):\n                v = smbus_read_long(bus, dev_addr, cmd, resp_type, po)\n\n            elif resp_type in (\"int24_blk\",\"uint24_blk\",\"int32_blk\",\"uint32_blk\",):\n                v = smbus_read_long_blk(bus, dev_addr, cmd, resp_type, po)\n\n            elif resp_type.startswith(\"string[\"):\n                v = smbus_read_block(bus, dev_addr, cmd, resp_type, po)\n\n            elif resp_type.startswith(\"byte[\"):\n                v = smbus_read_block(bus, dev_addr, cmd, resp_type, po)\n\n            else:\n                raise ValueError(\"Command {} type {} not supported in simple read\".format(cmd.name,resp_type))\n        except Exception as ex:\n            if (nretry > 0) and (\n              (isinstance(ex, OSError) and ex.errno in (5,121,)) or\n              # 5 = Input/output error, sometimes just happens\n              # 121 = I/O error, usually means no ACK\n              (isinstance(ex, ValueError)) # invalid length or checksum\n              ):\n                if (po.verbose > 2):\n                    print(\"Retrying due to error: \"+str_exception_with_type(ex))\n                pass\n            else:\n                raise\n        if v is None:\n            time.sleep(0.25)\n            continue\n        break\n\n    if (resp_unit['scale'] is not None) and (resp_unit['scale'] != 1):\n        if isinstance(v, int) or isinstance(v, float):\n            v *= resp_unit['scale']\n        else:\n            print(\"Warning: Cannot apply scaling to non-numeric value of {} command\".format(cmd.name))\n    return v, resp_unit['name']\n\n\ndef smbus_write_simple(bus, dev_addr, cmd, v, val_type, val_unit, retry_count, po):\n    \"\"\" Writes value of simple command to the battery.\n    \"\"\"\n    if (val_unit['scale'] is not None) and (val_unit['scale'] != 1):\n        if isinstance(v, int) or isinstance(v, float):\n            if val_type in (\"float\",\"float_blk\",):\n                v = v / val_unit['scale']\n            else:\n                v = v // val_unit['scale']\n        else:\n            raise ValueError(\"Cannot apply scaling to non-numeric value of {} command\".format(cmd.name))\n\n    if val_type in (\"int16\",\"uint16\",):\n        smbus_write_word(bus, dev_addr, cmd, v, val_type, po)\n\n    elif val_type in (\"int16_blk\",\"uint16_blk\",):\n        smbus_write_word_blk(bus, dev_addr, cmd, v, val_type, po)\n\n    elif val_type in (\"int32\",\"uint32\",):\n        smbus_write_long(bus, dev_addr, cmd, v, val_type, po)\n\n    elif val_type in (\"int32_blk\",\"uint32_blk\",):\n        smbus_write_long_blk(bus, dev_addr, cmd, v, val_type, po)\n\n    elif val_type.startswith(\"string[\"):\n        smbus_write_block(bus, dev_addr, cmd, v, val_type, po)\n\n    elif val_type.startswith(\"byte[\"):\n        smbus_write_block(bus, dev_addr, cmd, v, val_type, po)\n\n    else:\n        raise ValueError(\"Command {} type {} not supported in simple write\".format(cmd.name,val_type))\n\n    return val_unit['name']\n\n\ndef parse_sbs_command_value(cmd, subcmdinf, v, u, po):\n    \"\"\" Parse compound values to get list of sub-values\n    \"\"\"\n    cmdinf = SBS_CMD_INFO[cmd]\n    if (u == \"bitfields\"):\n        # We only support bitfields on integer value\n        vlist = {}\n        for fld in sorted(subcmdinf.keys(), key=lambda x:x.value):\n            fldinf = subcmdinf[fld]\n            # Prepare bit mask\n            bit_start = fld.value\n            bit_count = fldinf['nbits']\n            bit_mask = 0\n            for i in range(bit_count):\n                bit_mask = (bit_mask << 1) | 1\n            bit_mask = bit_mask << bit_start\n            fld_val = ((v & bit_mask) >> bit_start)\n            fld_unit = fldinf['unit']\n\n            if fld_unit['scale'] is not None:\n                fld_val *= fld_unit['scale']\n            vlist[fld] = {'val':fld_val,'uname':fld_unit['name'],}\n    elif u == \"struct\":\n        # We only support struct on byte array value\n        fld_start = 0\n        vlist = {}\n        for fld in sorted(subcmdinf.keys(), key=lambda x:x.value):\n            fldinf = subcmdinf[fld]\n            fld_buf = []\n            try:\n                for i in range((fldinf['nbits']+7) // 8):\n                    m = (fld_start // 8) + i\n                    r = (fld_start % 8)\n                    if r == 0:\n                        c = v[m]\n                    else:\n                        c = (v[m] >> r) + (v[m+1] << (8-r)) & 0xff\n                    fld_buf.append(c)\n            except IndexError as ex:\n                # Some structs can have fields at end which exist only in some versions\n                if ('optional' in fldinf) and fldinf['optional']:\n                    if (po.verbose > 2):\n                        print(\"Optional field {} does not exist\".format(fld.name))\n                    break\n                raise IndexError(\"Received block too short to contain '{}' field\".format(fld.name))\n            fld_type = fldinf['type']\n            fld_unit = fldinf['unit']\n\n            if fld_type in (\"int16\",\"uint16\",) and len(fld_buf) < 2:\n                if (po.verbose > 2):\n                    print(\"Zero-extending {} field {}\".format(fld_type,fld.name))\n                fld_buf.extend([0,0])\n            elif fld_type in (\"int32\",\"uint32\",) and len(fld_buf) < 4:\n                if (po.verbose > 2):\n                    print(\"Zero-extending {} field {}\".format(fld_type,fld.name))\n                fld_buf.extend([0,0,0,0])\n\n            if 'endian' in fldinf:\n                fld_val = bytes_to_type_str(fld_buf, fld_type, fldinf['endian'])\n            else:\n                fld_val = bytes_to_type_str(fld_buf, fld_type, \"le\")\n\n            if fld_unit['scale'] is not None:\n                fld_val *= fld_unit['scale']\n            vlist[fld] = {'val':fld_val,'uname':fld_unit['name'],}\n            fld_start += fldinf['nbits']\n    else:\n        vlist = None\n    return vlist\n\n\ndef is_printable_value_unit(uname):\n    return uname not in (\"boolean\", \"hex\", \"hexver\", \"dec\", \"dec02\", \"dec04\", \"date547\", \"str\", \"bitfields\", \"struct\",)\n\n\ndef command_value_to_string(cmdinf, subcmdinf, u, v, po):\n    if u in (\"bitfields\",\"struct\",\"hex\",):\n        if isinstance(v, list) or isinstance(v, bytes):\n            return \"hex:\" + \"\".join('{:02x}'.format(x) for x in v), u\n        else:\n            if 'nbits' in subcmdinf:\n                val_len = (subcmdinf['nbits']+3) // 4\n            elif 'type' in subcmdinf:\n                val_len = 2*type_str_value_length(subcmdinf['type'])\n            else:\n                val_len = 2*type_str_value_length(cmdinf['type'])\n            return \"0x{:0{}x}\".format(v,val_len), u\n    if u == \"hexver\":\n        if isinstance(v, list) or isinstance(v, bytes):\n            return \".\".join('{:02x}'.format(x) for x in v), u\n        else:\n            if 'nbits' in subcmdinf:\n                val_len = (subcmdinf['nbits']+3) // 4\n            elif 'type' in subcmdinf:\n                val_len = 2*type_str_value_length(subcmdinf['type'])\n            else:\n                val_len = 2*type_str_value_length(cmdinf['type'])\n            fmt_val = \"\"\n            while val_len > 0:\n                fmt_val += \"{:02x}.\".format(v & 0xff)\n                v <<= 8\n                val_len -= 2\n            return fmt_val[0:len(fmt_val)-1], u\n    if u in (\"dec02\",\"dec04\",):\n        return \"{:{}d}\".format(v,u[u.index('0'):]), u\n    if u == \"K\": # Temperature in Kelvin - convert to degC\n        return \"{:.2f}\".format(v - 273.15), \"degC\"\n    if u == \"date547\":\n        return \"{:d}-{:02d}-{:02d}\".format(1980 + ((v>>9)&0x7f), (v>>5)&0x0f, (v)&0x1f), \"date\"\n    if u in (\"str\",):\n        return \"{}\".format(bytes(v)), u\n    return \"{}\".format(v), u\n\n\ndef print_sbs_command_subfield_value(fld, lstfld, fields_info, name_width, po):\n    fldinf = fields_info[fld]\n    fld_short_desc = fldinf['desc'].split('.')[0]\n    val = lstfld['val']\n    # Do not show fields which have no read access, unless somehow they're non-zero\n    if (\"r\" not in fldinf['access']) and (val == 0):\n        return\n    # Prepare the value for formatting\n    fmt_val, fld_uname = command_value_to_string({'type':\"byte[1]\"}, fldinf, lstfld['uname'], val, po)\n    # Prepare the unit (or replace it with short name for flags)\n    if (not is_printable_value_unit(fld_uname)) and ('tiny_name' in fldinf):\n        fld_uname = \"[{}]\".format(fldinf['tiny_name'])\n    if fldinf['type'] == \"named_bitfield\":\n        fmt_val = \"{}={}\".format(fmt_val, fldinf['value_names'][val])\n\n    print(\" {:>{}s}:\\t{}\\t{}\\t{}\".format(fld.name, name_width, fmt_val, fld_uname, fld_short_desc))\n    if (po.explain):\n        print(\"Description: {}\".format(fldinf['desc']))\n    return\n\n\ndef group_fields_by_bits(enum_list, bits_group, bits_limit, po):\n    field_groups = []\n    all_bits = [x.value for x in enum_list]\n    for nbyte in range((bits_limit+bits_group-1)//bits_group):\n        fields_in_byte = []\n        for nbit in range(bits_group):\n            if bits_group*nbyte+nbit in all_bits:\n                for fld in (x for x in enum_list if x.value == bits_group*nbyte+nbit):\n                    fields_in_byte.append(fld)\n        if len(fields_in_byte) > 0:\n            field_groups.append(fields_in_byte)\n    return field_groups\n\n\ndef print_sbs_command_short_subfields(field_groups, l, fields_info, cell_width, bit_per_cell, display_mode, po):\n    field_lines = []\n    for fields_in_byte in reversed(field_groups):\n        field_strings = []\n        for fld in reversed(fields_in_byte):\n            fldinf = fields_info[fld]\n            lstfld = l[fld]\n            val = lstfld['val']\n            fldt = {}\n            if display_mode == 1:\n                fldt['str'] = \"{}={}\".format(fldinf['tiny_name'],val)\n                fldt['color'] = 34 if (\"r\" not in fldinf['access']) else 31 if val != 0 else 32\n            else:\n                if isinstance(val, list) or isinstance(val, bytes):\n                    fldt['str'] = \"{}={}\".format(fldinf['tiny_name'],\"\".join('{:02x}'.format(x) for x in val))\n                elif isinstance(val, float):\n                    fldt['str'] = \"{}={:g}\".format(fldinf['tiny_name'],val)\n                else:\n                    fldt['str'] = \"{}={:x}\".format(fldinf['tiny_name'],val)\n                fldt['color'] = 30 if (\"r\" not in fldinf['access']) else 37\n            fldt['nbits'] = fldinf['nbits']\n            field_strings.append(fldt)\n        field_lines.append(field_strings)\n    for field_strings in field_lines:\n        line_str = []\n        for i, fldt in enumerate(field_strings):\n            use_width = cell_width * (fldt['nbits']//bit_per_cell) - 2\n            line_str.append(\"\\x1b[1;{}m[{:>{}s}]\".format(fldt['color'], fldt['str'], use_width))\n        print(\"\".join(line_str),'\\x1b[0m')\n\n\ndef print_sbs_command_value_cust_inf_basecmd(cmd, cmdinf, subcmd, subcmdinf, v, l, s, u, basecmd_name, name_width, po):\n    if 'desc' in subcmdinf:\n        short_desc = subcmdinf['desc'].split('.')[0]\n    else:\n        short_desc = cmdinf['desc'].split('.')[0]\n\n    if name_width < 1:\n        name_width = 1\n    if True:\n        fmt_val, fld_uname = command_value_to_string(cmdinf, subcmdinf, u, v, po)\n        if (not is_printable_value_unit(fld_uname)) and ('tiny_name' in subcmdinf):\n            fld_uname = \"[{}]\".format(subcmdinf['tiny_name'])\n        print(\"{:{}s}\\t{}\\t{}\\t{}\".format(basecmd_name+\":\", name_width, fmt_val, fld_uname, short_desc))\n        if (po.explain):\n            print(\"Description: {}\".format(subcmdinf['desc'] if 'desc' in subcmdinf else cmdinf['desc']))\n\n    if u in (\"bitfields\",\"struct\",):\n        fields_info = s\n        if (po.short):\n            if u in (\"bitfields\",):\n                field_groups = group_fields_by_bits(l.keys(), 8, 64, po)\n                print_sbs_command_short_subfields(field_groups, l, fields_info, 9, 1, 1, po)\n            else:\n                field_groups = group_fields_by_bits(l.keys(), 64, 256, po)\n                print_sbs_command_short_subfields(field_groups, l, fields_info, 9, 8, 2, po)\n        else:\n            max_name_len = max([len(fld.name) for fld in l.keys()])\n            for fld in sorted(l.keys(), key=lambda x:x.value):\n                print_sbs_command_subfield_value(fld, l[fld], fields_info, max_name_len, po)\n    pass\n\n\ndef print_sbs_command_value_cust_inf(cmd, cmdinf, subcmd, subcmdinf, response, opts, name_width, po):\n    v = response['val']\n    l = response['list']\n    s = response['sinf']\n    u = response['uname']\n\n    # If reading from array-like command, hand-craft our own which includes the shift\n    if 'cmd_shift' in opts:\n        cmd = sbs_command_add_shift(cmd, cmdinf, opts['cmd_shift'], po)\n\n    if subcmd is not None:\n        # If reading from array-like command, hand-craft our own which includes the shift\n        if 'subcmd_shift' in opts:\n            subcmd = sbs_command_add_shift(subcmd, subcmdinf, opts['subcmd_shift'], po)\n\n    if subcmd is not None:\n        basecmd_name = re.sub('[^A-Z0-9]', '', cmd.name) + '.' + subcmd.name\n    else:\n        basecmd_name = cmd.name\n\n    print_sbs_command_value_cust_inf_basecmd(cmd, cmdinf, subcmd, subcmdinf, v, l, s, u, basecmd_name, name_width, po)\n\n\ndef print_sbs_command_value(cmd, subcmd, response, opts, name_width, po):\n    cmdinf = SBS_CMD_INFO[cmd]\n    subcmdinf = {}\n    if subcmd is not None:\n        subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n\n    print_sbs_command_value_cust_inf(cmd, cmdinf, subcmd, subcmdinf, response, opts, name_width, po)\n\n\ndef sbs_command_add_shift(cmd, cmdinf, cmd_shift, po):\n    \"\"\" Adds shift to array-like command\n\n    When reading from array-like command, we need to hand-craft our own 'cmd' which includes the shift.\n    \"\"\"\n    if 'cmd_array' not in cmdinf:\n        raise ValueError(\"Tried to add shift to non-array command '{}'\".format(cmd.name))\n    cmd_array_len = cmdinf['cmd_array']\n    if (cmd_shift < 0) or (cmd_shift >= cmd_array_len):\n        raise ValueError(\"Command {} array shift {} out of bounds\".format(cmd.name, cmd_shift))\n    return ImprovisedCommand(value=cmd.value+cmd_shift, name=\"{}{}\".format(cmd.name, cmd_shift))\n\n\ndef sbs_subcommand_get_info(cmd, subcmd):\n    cmdinf = SBS_CMD_INFO[cmd]\n    subcmdinf = {}\n    if 'subcmd_infos' in cmdinf:\n        for subgrp in cmdinf['subcmd_infos']:\n            if subcmd in subgrp.keys():\n                subcmdinf = subgrp[subcmd]\n                break\n    return subcmdinf\n\n\ndef sbs_command_check_access(cmd, cmdinf, opts, acc_type, po):\n    \"\"\" Checks if given command allows given access type\n    \"\"\"\n    if cmdinf['getter'] in (\"write_word_subcommand\",\"write_word_subcmd_mac_block\",):\n        can_access = sum((\"w\" in accstr) for accstr in cmdinf['access_per_seal'])\n        if can_access == 0:\n            return False\n        subcmd = opts['subcmd']\n        subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n        if 'access_per_seal' in subcmdinf:\n            can_access = sum((acc_type in accstr) for accstr in subcmdinf['access_per_seal'])\n    else:\n        can_access = sum((acc_type in accstr) for accstr in cmdinf['access_per_seal'])\n    return (can_access > 0)\n\n\ndef smbus_read_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, po):\n    \"\"\" Reads value of a sub-command by writing the subcmd index, then reading response location.\n\n    This is used to access ManufacturerAccess sub-commands of the battery.\n    Handles value scaling and its conversion to bytes. Handles retries as well.\n    \"\"\"\n    resp_type = subcmdinf['type']\n    if 'resp_location' in subcmdinf:\n        resp_cmd = subcmdinf['resp_location']\n    else:\n        resp_cmd = None\n    if 'resp_wait' in subcmdinf:\n        resp_wait = subcmdinf['resp_wait']\n    else:\n        resp_wait = 0\n\n    if po.dry_run:\n        bus.prep_mock_read(cmd, subcmd)\n\n    if (resp_type.startswith(\"byte[\") or resp_type.startswith(\"string\") or resp_type.endswith(\"_blk\")):\n        v = smbus_read_block_val_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, resp_type, resp_cmd, resp_wait, po)\n    else:\n        raise ValueError(\"Command {}.{} type {} not supported in sub-command read\".format(cmd.name,subcmd.name,resp_type))\n\n    resp_unit = subcmdinf['unit']\n    if (resp_unit['scale'] is not None) and (resp_unit['scale'] != 1):\n        if isinstance(v, int) or isinstance(v, float):\n            v *= resp_unit['scale']\n        else:\n            print(\"Warning: Cannot apply scaling to non-numeric value of {} command\".format(cmd.name))\n\n    return v, resp_unit['name']\n\n\ndef smbus_write_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, v, po):\n    \"\"\" Write value of a sub-command by writing the subcmd index, then writing to resp_location.\n\n    This is used to access ManufacturerAccess sub-commands of the battery.\n    Handles value scaling and its conversion to bytes. Handles retries as well.\n    \"\"\"\n    stor_type = subcmdinf['type']\n    if 'resp_location' in subcmdinf:\n        stor_cmd = subcmdinf['resp_location']\n    else:\n        stor_cmd = None\n    if 'resp_wait' in subcmdinf:\n        stor_wait = subcmdinf['resp_wait']\n    else:\n        stor_wait = 0\n\n    stor_unit = subcmdinf['unit']\n    if (stor_unit['scale'] is not None) and (stor_unit['scale'] != 1):\n        if isinstance(v, int) or isinstance(v, float):\n            if stor_type in (\"float\",\"float_blk\",):\n                v = v / stor_unit['scale']\n            else:\n                v = v // stor_unit['scale']\n        else:\n            raise ValueError(\"Cannot apply scaling to non-numeric value of {}.{} command\"\n              .format(cmd.name,subcmd.name))\n\n    if (stor_type.startswith(\"byte[\") or stor_type.startswith(\"string\") or\n      stor_type.endswith(\"_blk\") or stor_type in (\"void\",)):\n        smbus_write_block_val_by_writing_word_subcmd_first(bus, dev_addr,\n          cmd, subcmd, v, stor_type, stor_cmd, stor_wait, po)\n    else:\n        raise ValueError(\"Command {}.{} type {} not supported in sub-command write\"\n          .format(cmd.name, subcmd.name, stor_type))\n\n    return stor_unit['name']\n\n\ndef smbus_read_macblk_by_writing_block_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, po):\n    \"\"\" Reads value of a sub-command by writing the subcmd index,\n    then reading response which starts with the sub-command.\n\n    This is used to access ManufacturerBlockAccess sub-commands of the battery.\n    Handles value scaling and its conversion to bytes. Handles retries as well.\n    \"\"\"\n    resp_type = subcmdinf['type']\n    if 'resp_location' in subcmdinf:\n        resp_cmd = subcmdinf['resp_location']\n    else:\n        resp_cmd = cmd\n    if 'resp_wait' in subcmdinf:\n        resp_wait = subcmdinf['resp_wait']\n    else:\n        resp_wait = 0\n\n    if po.dry_run:\n        bus.prep_mock_read(cmd, subcmd)\n\n    if (resp_type.startswith(\"byte[\") or resp_type.startswith(\"string\") or resp_type.endswith(\"_blk\")):\n        v = smbus_read_macblock_val_by_writing_block_subcmd_first(bus, dev_addr,\n          cmd, subcmd, resp_type, resp_cmd, resp_wait, po)\n    else:\n        raise ValueError(\"Command {}.{} type {} not supported in block sub-command read\"\n          .format(cmd.name,subcmd.name,resp_type))\n\n    resp_unit = subcmdinf['unit']\n    if (resp_unit['scale'] is not None) and (resp_unit['scale'] != 1):\n        if isinstance(v, int) or isinstance(v, float):\n            v *= resp_unit['scale']\n        else:\n            print(\"Warning: Cannot apply scaling to non-numeric value of {} command\".format(cmd.name))\n\n    return v, resp_unit['name']\n\n\ndef smbus_write_macblk_with_block_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, v, po):\n    \"\"\" Write value of a sub-command by writing block data with the subcmd index before actual content.\n\n    This is used to access ManufacturerBlockAccess sub-commands of the battery.\n    Handles value scaling and its conversion to bytes. Handles retries as well.\n    \"\"\"\n    stor_type = subcmdinf['type']\n    # Separate response command is only in use when reading MAC Block values\n    if 'resp_wait' in subcmdinf:\n        stor_wait = subcmdinf['resp_wait']\n    else:\n        stor_wait = 0\n\n    stor_unit = subcmdinf['unit']\n    if (stor_unit['scale'] is not None) and (stor_unit['scale'] != 1):\n        if isinstance(v, int) or isinstance(v, float):\n            if stor_type in (\"float\",\"float_blk\",):\n                v = v / stor_unit['scale']\n            else:\n                v = v // stor_unit['scale']\n        else:\n            raise ValueError(\"Cannot apply scaling to non-numeric value of {}.{} command\"\n              .format(cmd.name,subcmd.name))\n\n    if (stor_type.startswith(\"byte[\") or stor_type.startswith(\"string\") or\n      stor_type.endswith(\"_blk\") or stor_type in (\"void\",)):\n        smbus_write_macblock_val_adding_block_subcmd_first(bus, dev_addr,\n          cmd, subcmd, v, stor_type, stor_wait, po)\n    else:\n        raise ValueError(\"Command {}.{} type {} not supported in block sub-command write\"\n          .format(cmd.name,subcmd.name,stor_type))\n\n    return stor_unit['name']\n\n\ndef smbus_read(bus, dev_addr, cmd, opts, vals, po):\n    \"\"\" Reads value of given command from the battery.\n\n    Selects proper getter function for the command given.\n    \"\"\"\n    cmdinf = SBS_CMD_INFO[cmd]\n    subinfgrp = None\n    if 'retry_count' in opts:\n        retry_count = opts['retry_count']\n    else:\n        retry_count = 3\n\n    if (po.verbose > 1):\n        print(\"Reading {} command at addr=0x{:x}, cmd=0x{:x}, type={}, opts={}\"\n          .format(cmdinf['getter'], dev_addr, cmd.value, cmdinf['type'], opts))\n\n    # If reading from array-like command, hand-craft our own which includes the shift\n    if 'cmd_shift' in opts:\n        cmd = sbs_command_add_shift(cmd, cmdinf, opts['cmd_shift'], po)\n\n    if not sbs_command_check_access(cmd, cmdinf, opts, \"r\", po):\n        print(\"Warning: Requested command does not provide read access; continuing anyway\")\n\n    if cmdinf['getter'] == \"simple\":\n        resp_unit = cmdinf['unit']\n        v, u = smbus_read_simple(bus, dev_addr, cmd, cmdinf['type'], resp_unit, retry_count, po)\n\n    elif cmdinf['getter'] == \"unit_select_on_capacity_mode\":\n        capacity_mode = None\n        if SBS_COMMAND.BatteryMode in vals.keys():\n            batt_mode = vals[SBS_COMMAND.BatteryMode]\n            capacity_mode_mask = 1 << SBS_FLAG_BATTERY_MODE.CAPACITY_MODE.value\n            capacity_mode = (batt_mode['val'] & capacity_mode_mask) != 0\n        if capacity_mode is None:\n            resp_unit = {'scale':1,'name':\"{:d}{:s}/{:d}{:s}\".format(\n                cmdinf['unit0']['scale'],cmdinf['unit0']['name'],\n                cmdinf['unit1']['scale'],cmdinf['unit1']['name'])}\n        elif capacity_mode:\n            resp_unit = cmdinf['unit1']\n        else:\n            resp_unit = cmdinf['unit0']\n        v, u = smbus_read_simple(bus, dev_addr, cmd, cmdinf['type'], resp_unit, retry_count, po)\n\n    elif cmdinf['getter'] in (\"write_word_subcommand\", \"write_word_subcmd_mac_block\",):\n        if 'subcmd' not in opts.keys():\n            raise ValueError(\"Command {} requires to provide sub-command\".format(cmd.name))\n        subcmd = opts['subcmd']\n        subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n        if len(subcmdinf) <= 0:\n            raise ValueError(\"Command {}.{} missing definition\".format(cmd.name,subcmd.name))\n\n        # If reading from array-like sub-command, hand-craft our own which includes the shift\n        if 'subcmd_shift' in opts:\n            subcmd = sbs_command_add_shift(subcmd, subcmdinf, opts['subcmd_shift'], po)\n\n        if cmdinf['getter'] == \"write_word_subcommand\":\n            if ('resp_location' in subcmdinf) or (subcmdinf['type'] == \"void\"):\n                # do write request with subcmd, then expect response at specific location\n                v, u = smbus_read_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, po)\n            else:\n                # do normal read, this is not a sub-command with different response location\n                v, u = smbus_read_simple(bus, dev_addr, cmd, subcmdinf['type'], subcmdinf['unit'], retry_count, po)\n        else: # cmdinf['getter'] == \"write_word_subcmd_mac_block\"\n            # do write request with subcmd, then expect block response at specific location starting with subcmd\n            v, u = smbus_read_macblk_by_writing_block_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, po)\n        if (u == \"struct\"):\n            subinfgrp = subcmdinf['struct_info']\n        elif (u == \"bitfields\"):\n            subinfgrp = subcmdinf['bitfields_info']\n\n    else:\n        raise ValueError(\"Command {} getter {} not supported\".format(cmd.name,cmdinf['getter']))\n\n    if not subinfgrp:\n        # Structs and bitfields types have only one list of sub-fields, so use it\n        if (u == \"struct\"):\n            subinfgrp = cmdinf['struct_info']\n        elif u == \"bitfields\":\n            subinfgrp = cmdinf['bitfields_info']\n\n    l = parse_sbs_command_value(cmd, subinfgrp, v, u, po)\n    return v, l, u, subinfgrp\n\n\ndef smbus_write(bus, dev_addr, cmd, v, opts, vals, po):\n    \"\"\" Write value to given command of the battery.\n\n    Selects proper getter function for the command given.\n    \"\"\"\n    cmdinf = SBS_CMD_INFO[cmd]\n    subinfgrp = None\n    if 'retry_count' in opts:\n        retry_count = opts['retry_count']\n    else:\n        retry_count = 1\n    if (po.verbose > 1):\n        print(\"Writing {} command at addr=0x{:x}, cmd=0x{:x}, type={}, v={}, opts={}\".format(\n          cmdinf['getter'], dev_addr, cmd.value, cmdinf['type'], v, opts))\n\n    if not sbs_command_check_access(cmd, cmdinf, opts, \"w\", po):\n        print(\"Warning: Requested command does not provide write access; continuing anyway\")\n\n    if cmdinf['getter'] == \"simple\":\n        stor_unit = cmdinf['unit']\n        u = smbus_write_simple(bus, dev_addr, cmd, v, cmdinf['type'], stor_unit, retry_count, po)\n\n    elif cmdinf['getter'] == \"unit_select_on_capacity_mode\":\n        capacity_mode = None\n        if SBS_COMMAND.BatteryMode in vals.keys():\n            batt_mode = vals[SBS_COMMAND.BatteryMode]\n            capacity_mode_mask = 1 << SBS_FLAG_BATTERY_MODE.CAPACITY_MODE.value\n            capacity_mode = (batt_mode['val'] & capacity_mode_mask) != 0\n        if capacity_mode is None:\n            stor_unit = {'scale':1,'name':\"{:d}{:s}/{:d}{:s}\".format(\n                cmdinf['unit0']['scale'],cmdinf['unit0']['name'],\n                cmdinf['unit1']['scale'],cmdinf['unit1']['name'])}\n        elif capacity_mode:\n            stor_unit = cmdinf['unit1']\n        else:\n            stor_unit = cmdinf['unit0']\n        u = smbus_write_simple(bus, dev_addr, cmd, v, cmdinf['type'], stor_unit, retry_count, po)\n\n    elif cmdinf['getter'] in (\"write_word_subcommand\", \"write_word_subcmd_mac_block\",):\n        if 'subcmd' not in opts.keys():\n            raise ValueError(\"Command {} requires to provide sub-command\".format(cmd.name))\n        subcmd = opts['subcmd']\n        subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n        if len(subcmdinf) <= 0:\n            raise ValueError(\"Command {}.{} missing definition\".format(cmd.name,subcmd.name))\n\n        if cmdinf['getter'] == \"write_word_subcommand\":\n            if ('resp_location' in subcmdinf) or (subcmdinf['type'] == \"void\"):\n                # do write request with subcmd, then do actual data write at specific location\n                # trigger (type == \"void\") is supported by this function as well\n                u = smbus_write_by_writing_word_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, v, po)\n            else:\n                # do normal write, this is not a sub-command with different value location\n                u = smbus_write_simple(bus, dev_addr, cmd, v, subcmdinf['type'], subcmdinf['unit'], retry_count, po)\n\n        else: # cmdinf['getter'] == \"write_word_subcmd_mac_block\"\n            # write block with actual data preceded by subcmd\n            u = smbus_write_macblk_with_block_subcmd_first(bus, dev_addr, cmd, subcmd, subcmdinf, v, po)\n\n        if (u == \"struct\"):\n            subinfgrp = subcmdinf['struct_info']\n        elif (u == \"bitfields\"):\n            subinfgrp = subcmdinf['bitfields_info']\n\n    else:\n        raise ValueError(\"Command {} getter {} not supported\".format(cmd.name,cmdinf['getter']))\n\n    if (not subinfgrp) and (u == \"bitfields\"):\n        # The 'bitfields' type has only one list of sub-fields, so use it\n        subinfgrp = cmdinf['bitfields_info']\n\n    return u, subinfgrp\n\n\ndef sbs_read_firmware_version_bq_sealed(bus, dev_addr, po):\n    \"\"\" Reads firmware version from BQ series chips\n\n    Uses the sequence which allows to read the FW version even in sealed mode.\n    The sequence used to do this read requires low-level access to the bus via\n    i2c commands which allows sending raw data. Not all smbus wrappers\n    available in various platforms have that support.\n\n    This function is designed to work even if command list for specific BQ chip was not loaded.\n    \"\"\"\n    cmd, subcmd = (SBS_COMMAND.ManufacturerAccess,MANUFACTURER_ACCESS_CMD_BQGENERIC.FirmwareVersion,)\n    cmdinf = SBS_CMD_INFO[cmd]\n    subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n\n    # Do 3 commands which pretend to write oversized buffer; this needs to be done within 4 seconds\n    for pre_cmd in (SBS_COMMAND.DeviceChemistry, SBS_COMMAND.ManufacturerName, SBS_COMMAND.DeviceChemistry):\n        # We are sending messages which are not correct commands - we expect to receive no ACK\n        # This is normal part of this routine; each of these commands should fail\n        if po.dry_run:\n            bus.add_mock_except(OSError(121,\"Simulated error\"))\n        try:\n            smbus_write_raw(bus, dev_addr, [pre_cmd.value, 62], po)\n            # If somehow we got no exception, raise one\n            raise ConnectionError(\"FW version acquire tripped as it expected NACK on a command\")\n        except OSError as ex:\n            if ex.errno not in (121,): # I/O error - usually means no ACK - this is what we expect\n                raise\n\n    # Now ManufacturerData() will contain FW version data which we can read; wait to make sure it's ready\n    time.sleep(0.35) # EV2300 software waits 350 ms; but documentation doesn't explicitly say to wait here\n    if po.dry_run:\n        bus.prep_mock_read(cmd, subcmd)\n\n    resp_cmd  = SBS_COMMAND.OptionalMfgFunction5 # ManufacturerInput/Authenticate\n    # Data length is 11 or 13 bytes\n    v = smbus_read_block_for_basecmd(bus, dev_addr, resp_cmd, subcmd.name, subcmdinf['type'], po)\n\n    return v\n\n\ndef smart_battery_bq_detect(vals, po):\n    global bus\n\n    v = None\n    for nretry in reversed(range(3)):\n        try:\n            v = sbs_read_firmware_version_bq_sealed(bus, po.dev_address, po)\n        except Exception as ex:\n            if (nretry > 0) and (\n              (isinstance(ex, OSError) and ex.errno in (5,121,)) or\n              # 5 = Input/output error, sometimes just happens\n              # 121 = I/O error, usually means no ACK\n              (isinstance(ex, ValueError)) or # invalid length or checksum\n              (isinstance(ex, ConnectionError)) # invalid response on initial writes\n              ):\n                if (po.verbose > 2):\n                    print(\"Retrying due to error: \"+str_exception_with_type(ex))\n                pass\n            else:\n                raise\n        # If we still have retries, accept only packets of certain length\n        if (nretry > 0) and (v is not None) and (len(v) not in (11,13,)):\n            if (po.verbose > 2):\n                print(\"Retrying because received data looks suspicious\")\n            v = None\n        if v is None:\n            time.sleep(0.35)\n            continue\n        break\n    chip = CHIP_TYPE.BQGENERIC\n    for chchip in CHIP_TYPE:\n        # Go through all TI chips\n        if (chchip.value & 0xff0000) != 0x010000:\n            continue\n        # Lower 16 bits of each enum are the DeviceNumber\n        if (v[0]<<8)+(v[1]) == chchip.value & 0xffff:\n            chip = chchip\n            break\n\n    return chip\n\n\ndef smart_battery_detect(vals, po):\n    chip = CHIP_TYPE.SBS\n    try:\n        chip = smart_battery_bq_detect(vals, po)\n    except Exception as ex:\n        print(\"Chip detection failded: {}\".format(str_exception_with_type(ex)))\n    if (po.verbose > 0):\n        print(\"Auto-selected chip: {}, {}\".format(chip.name,chip.__doc__))\n    return chip\n\n\ndef smart_battery_system_subcmd_define(subcmd_val, cmdinf, data_len):\n    if ('subcmd_infos' not in cmdinf) or (len(cmdinf['subcmd_infos']) < 1):\n        raise ValueError(\"The sub-cmd 0x{:02x} cannot be user-defined within requested command\".format(subcmd_val))\n    subcmd = ImprovisedCommand(value=subcmd_val, name=\"UserSubCmd{:02x}\".format(subcmd_val))\n    subgrp = cmdinf['subcmd_infos'][0]\n    subcmdinf = {\n        'type'\t: \"byte[{}]\".format(data_len),\n        'unit'\t: {'scale':None,'name':\"hex\"},\n        'access_per_seal'\t: (\"rw\",\"rw\",\"rw\",),\n        'tiny_name'\t: \"UsrSC\",\n        'desc'\t: \"User defined sub-command {:02x}.\".format(subcmd_val),\n    }\n    # Figure out response location\n    resp_location = None\n    for nxsubcmd, nxsubcmdinf in subgrp.items():\n        if 'resp_location' not in nxsubcmdinf:\n            continue\n        resp_location = nxsubcmdinf['resp_location']\n        break\n    if resp_location is not None:\n        subcmdinf['resp_location'] = resp_location\n    # Add info dict on the new sub-command\n    subgrp[subcmd] = subcmdinf\n    return subcmd\n\n\ndef smart_battery_system_command_from_text(cmd_str, po, define_new=False):\n    \"\"\" Converts SBS command from text to enum\n\n    Requires chip to be identified to properly map commands\n    which are not in base SBS specification.\n    \"\"\"\n    cmd_str_parts = cmd_str.split('.')\n    major_cmd_str = cmd_str_parts[0]\n    subcmd_str = None\n    if len(cmd_str_parts) > 1:\n        subcmd_str = cmd_str_parts[1]\n    cmd = None\n    if cmd is None: # Recognize major SBS command by name\n        if True:\n            for curr_cmd in SBS_CMD_INFO.keys():\n                if major_cmd_str == curr_cmd.name:\n                    cmd = curr_cmd\n                    break\n    if cmd is None: # Recognize major SBS command by number\n        try:\n            major_cmd_int = int(major_cmd_str,0)\n            for curr_cmd in SBS_CMD_INFO.keys():\n                if major_cmd_int == curr_cmd.value:\n                    cmd = curr_cmd\n                    break\n        except ValueError:\n            pass\n    if cmd is None:\n        raise ValueError(\"The command '{}' is either invalid or not supported by chip\".format(major_cmd_str))\n\n    subcmd = None\n    if subcmd_str is not None:\n        cmdinf = SBS_CMD_INFO[cmd]\n        if 'subcmd_infos' in cmdinf:\n            if subcmd is None: # Recognize SBS sub-command by name\n                if True:\n                    for subgrp in cmdinf['subcmd_infos']:\n                        for cur_subcmd in subgrp.keys():\n                            if subcmd_str == cur_subcmd.name:\n                                subcmd = cur_subcmd\n                                break\n                        if subcmd is not None:\n                            break\n            if subcmd is None: # Recognize SBS sub-command by number\n                try:\n                    subcmd_int = int(subcmd_str,0)\n                    for subgrp in cmdinf['subcmd_infos']:\n                        for cur_subcmd in subgrp.keys():\n                            if subcmd_int == cur_subcmd.value:\n                                subcmd = cur_subcmd\n                                break\n                        if subcmd is not None:\n                            break\n                except ValueError:\n                    pass\n            if subcmd is None and define_new: # Define new SBS sub-command\n                try:\n                    subcmd_int = int(subcmd_str,0)\n                    if (po.verbose > 0):\n                        print(\"Warning: Sub-command 0x{:02x} not recognized, creating user-definwd one\".format(subcmd_int))\n                    subcmd = smart_battery_system_subcmd_define(subcmd_int, cmdinf, 32)\n                except ValueError:\n                    pass\n\n    if subcmd_str is not None and subcmd is None:\n        raise ValueError(\"The sub-command '{}' is either invalid or not supported by chip\".format(subcmd_str))\n\n    return cmd, subcmd\n\n\ndef smart_battery_system_cmd_value_from_text(cmd, subcmd, nval_str, po):\n    raise NotImplementedError('Converting the string value to cmd/subcmd type is not implemented.')\n\n\ndef smart_battery_system_address_space_from_text(knd_str, addr, po):\n    \"\"\" Converts SBS address space name text to enum\n\n    Requires chip to be identified to properly map commands\n    which are not in base SBS specification.\n    \"\"\"\n    knd = None\n    if knd is None: # Recognize address space by name\n        if True:\n            for curr_knd in RAW_ADDRESS_SPACE_KIND_INFO.keys():\n                if knd_str == curr_knd.name:\n                    knd = curr_knd\n                    break\n    if knd is None:\n        raise ValueError(\"The address space '{}' is either invalid or not supported by chip\".format(knd_str))\n    return knd\n\n\ndef smart_battery_system_last_error(bus, dev_addr, vals, po):\n    \"\"\" Reads and prints value of last ERROR_CODE from the battery.\n    \"\"\"\n    cmd = SBS_COMMAND.BatteryStatus\n    subcmd = None\n    fld = SBS_FLAG_BATTERY_STATUS.ERROR_CODE\n    fldinf = SBS_BATTERY_STATUS_INFO[fld]\n    val = None\n    try:\n        v, l, u, s = smbus_read(bus, dev_addr, cmd, {'subcmd': subcmd,'retry_count':1}, vals, po)\n        response = {'val':v,'list':l,'sinf':s,'uname':u,}\n        vals[cmd if subcmd is None else subcmd] = response\n        val = l[fld]['val']\n        fmt_val = \"{}={}\".format(val, fldinf['value_names'][val])\n        print(\"Reported {}: {}\".format(fld.name,fmt_val))\n    except Exception as ex:\n        print(\"Could not read {} from the battery\".format(fld.name))\n        pass\n    if (po.explain):\n        if val == 0:\n            print((\"Explanation: If battery reports no error, but command did failed, \"\n              \"then the blame goes to the receiver side.\"))\n        elif is_ti_bq_chip(po.chip) and val == 3:\n            print((\"Explanation: The 'Unsupported command' error often means \"\n              \"that the command is unavailable in sealed mode. \"\n              \"But it may also be unsupported by the specific chip.\"))\n    return\n\n\ndef smart_battery_system_info(cmd_str, vals, po):\n    \"\"\" Prints info on the command/offces based on fields from its info dict.\n    \"\"\"\n    cmd, subcmd = smart_battery_system_command_from_text(cmd_str, po)\n    cmdinf = SBS_CMD_INFO[cmd]\n    subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n\n    if True:\n        print(\"Command/offset:\")\n        if subcmd is None:\n            print(\"  {} = 0x{:02x}\".format(cmd.name,cmd.value))\n        else:\n            print(\"  {}.{} = 0x{:02x}.0x{:04x}\".format(cmd.name,subcmd.name,cmd.value,subcmd.value))\n\n        print(\"Access:\")\n        aps = subcmdinf['access_per_seal'] if 'access_per_seal' in subcmdinf else cmdinf['access_per_seal']\n        if len(set(aps)) <= 1:\n            print(\"  Always '{}'\".format(aps[0].upper()))\n        else:\n            print(\"  Sealed '{}'; Unsealed  '{}'; Full Access  '{}'\"\n              .format(aps[0].upper(), aps[1].upper(), aps[2].upper()))\n        gtr = subcmdinf['getter'] if 'getter' in subcmdinf else cmdinf['getter']\n\n        if gtr == \"simple\":\n            print(\"  Read/Write by simple SMBus operations\")\n        elif gtr == \"unit_select_on_capacity_mode\":\n            print(\"  Read/Write by simple SMBus operations, but unit of the value depends on flags config\")\n        elif gtr == \"write_word_subcommand\":\n            print(\"  Access by first writing sub-command word to {}\".format(cmd.name))\n        elif gtr == \"write_word_subcmd_mac_block\":\n            print(\"  Access by writing sub-command; read in 2nd command, or append data to write (MAC block algorithm)\")\n        else:\n            print(\"  Access by special method '{}'\".format(gtr))\n\n        print(\"Type:\")\n        vtype = subcmdinf['type'] if 'type' in subcmdinf else cmdinf['type']\n        if vtype == \"void\":\n            print(\"  There is no value field in read/Write operations, it works as trigger\")\n        else:\n            print(\"  Read/Write value is of type '{}'\".format(vtype))\n        if gtr == \"unit_select_on_capacity_mode\":\n            vunits = []\n            if 'getter' in subcmdinf:\n                for n in range(16):\n                    if ('unit'+str(n)) not in subcmdinf:\n                        break\n                    vunits.append(subcmdinf['unit'+str(n)])\n            else:\n                for n in range(16):\n                    if ('unit'+str(n)) not in cmdinf:\n                        break\n                    vunits.append(cmdinf['unit'+str(n)])\n            vunit = {'scale': \" / \".join(str(vu['scale']) for vu in vunits), 'name': \" / \".join(vu['name'] for vu in vunits)}\n        else:\n            vunit = subcmdinf['unit'] if 'unit' in subcmdinf else cmdinf['unit']\n        if vunit['name'] is None and vunit['scale'] is None:\n            print(\"  The value has no unit or printing format preference\")\n        elif is_printable_value_unit(vunit):\n            print(\"  Physical unit of the value is '{}' with value scaler {}\".format(vunit['name'],vunit['scale']))\n        else:\n            print(\"  The value has no unit, but uses printing format '{}' with multiplier {}\".format(vunit['name'],vunit['scale']))\n\n        print(\"Description:\")\n        print(\" \", subcmdinf['desc'] if 'desc' in subcmdinf else cmdinf['desc'])\n\n    return\n\n\ndef smart_battery_system_read(cmd_str, vals, po):\n    \"\"\" Reads and prints value of the command from the battery.\n    \"\"\"\n    global bus\n    cmd, subcmd = smart_battery_system_command_from_text(cmd_str, po, define_new=True)\n    cmdinf = SBS_CMD_INFO[cmd]\n    opts = {'subcmd': subcmd}\n    v, l, u, s = smbus_read(bus, po.dev_address, cmd, opts, vals, po)\n    response = {'val':v,'list':l,'sinf':s,'uname':u,}\n    vals[cmd if subcmd is None else subcmd] = response\n    print_sbs_command_value(cmd, subcmd, response, opts, 0, po)\n\n\ndef smart_battery_system_trigger(cmd_str, vals, po):\n    \"\"\" Trigger a switch command within the battery.\n    \"\"\"\n    global bus\n    cmd, subcmd = smart_battery_system_command_from_text(cmd_str, po, define_new=True)\n    if subcmd is not None:\n        basecmd_name = re.sub('[^A-Z0-9]', '', cmd.name) + '.' + subcmd.name\n    else:\n        basecmd_name = cmd.name\n    cmdinf = SBS_CMD_INFO[cmd]\n    opts = {'subcmd': subcmd}\n    v = b''\n    try:\n        u, s = smbus_write(bus, po.dev_address, cmd, v, opts, vals, po)\n    except Exception as ex:\n        print(\"{:{}s}\\t{}\\t{}\\t{}\".format(basecmd_name+\":\", 1, \"trigger\", \"FAIL\", str_exception_with_type(ex)))\n        if (isinstance(ex, OSError)):\n            smart_battery_system_last_error(bus, po.dev_address, vals, po)\n        if (po.explain):\n            print(\"Description: {}\".format(cmdinf['desc']))\n        raise RuntimeError(\"Trigger failed on command {}\".format(basecmd_name))\n    print(\"{:{}s}\\t{}\\t{}\\t{}\".format(basecmd_name+\":\", 1, \"trigger\", \"SUCCESS\", \"Trigger switch write accepted\"))\n\n\ndef smart_battery_system_write(cmd_str, nval_str, vals, po):\n    \"\"\" Write value to a command within the battery.\n    \"\"\"\n    global bus\n    cmd, subcmd = smart_battery_system_command_from_text(cmd_str, po, define_new=True)\n    if subcmd is not None:\n        basecmd_name = re.sub('[^A-Z0-9]', '', cmd.name) + '.' + subcmd.name\n    else:\n        basecmd_name = cmd.name\n    cmdinf = SBS_CMD_INFO[cmd]\n    opts = {'subcmd': subcmd}\n    v = smart_battery_system_cmd_value_from_text(cmd, subcmd, nval_str, po)\n    try:\n        u, s = smbus_write(bus, po.dev_address, cmd, v, opts, vals, po)\n    except Exception as ex:\n        print(\"{:{}s}\\t{}\\t{}\\t{}\".format(basecmd_name+\":\", 1, \"write\", \"FAIL\", str_exception_with_type(ex)))\n        if (isinstance(ex, OSError)):\n            smart_battery_system_last_error(bus, po.dev_address, vals, po)\n        if (po.explain):\n            print(\"Description: {}\".format(cmdinf['desc']))\n        raise RuntimeError(\"Write failed to command {}\".format(basecmd_name))\n    print(\"{:{}s}\\t{}\\t{}\\t{}\".format(cmd.name+\":\", 1, \"write\", \"SUCCESS\", \"Value write accepted\"))\n\n\ndef smart_battery_system_raw_read(knd_str, addr, val_type, vals, po):\n    \"\"\" Reads and prints raw value from address space of the battery.\n    \"\"\"\n    global bus\n    knd = smart_battery_system_address_space_from_text(knd_str, addr, po)\n    kndinf = RAW_ADDRESS_SPACE_KIND_INFO[knd]\n\n    cmd, subcmd = (kndinf['read_cmd'],kndinf['read_subcmd'],)\n    cmdinf = SBS_CMD_INFO[cmd]\n    subcmd_shift = addr // kndinf['granularity']\n    opts = {'subcmd': subcmd, 'subcmd_shift': subcmd_shift}\n    v, l, u, s = smbus_read(bus, po.dev_address, cmd, opts, vals, po)\n    response = {'val':v,'list':l,'sinf':s,'uname':u,}\n    #vals[cmd if subcmd is None else subcmd] = response #TODO we need to store sub-index\n    response_tot_len = len(v)\n\n    # Create improvised data type if the user demanded\n    if val_type not in (\"byte[32]\",):\n        subcmd_pos = addr - subcmd_shift * kndinf['granularity']\n        s = {}\n        fld_nbytes = type_str_value_length(val_type)\n        if subcmd_pos > 0:\n            fld0 = ImprovisedCommand(value=0, name=\"UserVal{:02x}\".format(0))\n            s[fld0] = {\n                'type'\t: \"byte[{}]\".format(subcmd_pos),\n                'unit'\t: {'scale':None,'name':\"hex\"},\n                'nbits'\t: subcmd_pos * 8,\n                'access'\t: \"-\",\n                'tiny_name'\t: \"BefUD\",\n                'desc'\t: \"Data before user field.\",\n            }\n        if fld_nbytes > 0:\n            fld = ImprovisedCommand(value=subcmd_pos*8, name=\"UserVal{:02x}\".format(subcmd_pos))\n            s[fld] = {\n                'type'\t: val_type,\n                'unit'\t: {'scale':None,'name':None},\n                'nbits'\t: fld_nbytes * 8,\n                'access'\t: \"r\",\n                'tiny_name'\t: \"UsrDf\",\n                'desc'\t: \"User defined field.\",\n            }\n            if val_type in (\"uint8\",\"uint16\",\"uint32\",):\n                s[fld]['unit'] = {'scale':1,'name':\"hex\"}\n            elif val_type in (\"int8\",\"int16\",\"int32\",):\n                s[fld]['unit'] = {'scale':1,'name':\"dec\"}\n            elif val_type.startswith(\"string[\"):\n                s[fld]['unit'] = {'scale':None,'name':\"str\"}\n        if subcmd_pos+fld_nbytes < response_tot_len:\n            fld2 = ImprovisedCommand(value=(subcmd_pos+fld_nbytes)*8, name=\"UserVal{:02x}\".format(subcmd_pos+fld_nbytes))\n            s[fld2] = {\n                'type'\t: \"byte[{}]\".format(response_tot_len-subcmd_pos-fld_nbytes),\n                'unit'\t: {'scale':None,'name':\"hex\"},\n                'nbits'\t: (response_tot_len-subcmd_pos-fld_nbytes) * 8,\n                'access'\t: \"-\",\n                'tiny_name'\t: \"AftUD\",\n                'desc'\t: \"Data after user field.\",\n            }\n        u = \"struct\"\n        l = parse_sbs_command_value(cmd, s, v, u, po)\n        response = {'val':v,'list':l,'sinf':s,'uname':u,}\n\n    print_sbs_command_value(cmd, subcmd, response, opts, 0, po)\n\n\ndef smart_battery_system_raw_write(knd_str, addr, val_type, nval_str, vals, po):\n    \"\"\" Writes raw value to address space of the battery.\n    \"\"\"\n    raise NotImplementedError('Writing raw data is not implemented.')\n\n\ndef smart_battery_system_raw_backup(knd_str, fname, vals, po):\n    \"\"\" Reads raw data from address space of the battery, and stores in a file.\n    \"\"\"\n    global bus\n    addr = 0x0\n    knd = smart_battery_system_address_space_from_text(knd_str, addr, po)\n    kndinf = RAW_ADDRESS_SPACE_KIND_INFO[knd]\n\n    cmd, subcmd = (kndinf['read_cmd'],kndinf['read_subcmd'],)\n    subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n    addrspace_tot_len = subcmdinf['cmd_array'] * kndinf['granularity']\n    last_pct = -100\n\n    with open(fname, \"wb\") as addrsp_file:\n        while (addr < addrspace_tot_len):\n            if (po.verbose > 0) and (addr * 100 // addrspace_tot_len - last_pct >= 5):\n                last_pct = addr * 100 // addrspace_tot_len\n                print(\"Raw read {}: address=0x{:04X} progress={:d}%\".format(knd.name, addr, last_pct,))\n            subcmd_shift = addr // kndinf['granularity']\n            opts = {'subcmd': subcmd, 'subcmd_shift': subcmd_shift}\n            v, l, u, s = smbus_read(bus, po.dev_address, cmd, opts, vals, po)\n            response = {'val':v,'list':l,'sinf':s,'uname':u,}\n            #vals[cmd if subcmd is None else subcmd] = response #TODO we need to store sub-index\n            addrsp_file.write(v)\n            addr += len(v)\n\n    print(\"Raw read {}: done\".format(knd.name,))\n\n\ndef smart_battery_system_raw_restore(knd_str, fname, vals, po):\n    \"\"\" Writes raw data to address space of the battery, from a file.\n    \"\"\"\n    from functools import partial\n    global bus\n    addr = 0x0\n    knd = smart_battery_system_address_space_from_text(knd_str, addr, po)\n    kndinf = RAW_ADDRESS_SPACE_KIND_INFO[knd]\n\n    cmd, subcmd = (kndinf['read_cmd'],kndinf['read_subcmd'],)\n    subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n    addrspace_tot_len = subcmdinf['cmd_array'] * kndinf['granularity']\n    last_pct = -100\n\n    with open(fname, \"rb\") as addrsp_file:\n        for v in iter(partial(addrsp_file.read, 32), b''):\n            if (po.verbose > 0) and (addr * 100 // addrspace_tot_len - last_pct >= 5):\n                last_pct = addr * 100 // addrspace_tot_len\n                print(\"Raw write {}: address=0x{:04X} progress={:d}%\".format(knd.name, addr, last_pct,))\n            if (addr >= addrspace_tot_len):\n                print(\"Warning: File size exceeds address space size; excessive data ignored\")\n                break\n            subcmd_shift = addr // kndinf['granularity']\n            opts = {'subcmd': subcmd, 'subcmd_shift': subcmd_shift}\n            u, s = smbus_write(bus, po.dev_address, cmd, v, opts, vals, po)\n            addr += len(v)\n\n    print(\"Raw write {}: done\".format(knd.name,))\n\n\ndef smart_battery_system_monitor(mgroup_str, vals, po):\n    \"\"\" Reads and prints multiple values from the battery.\n    \"\"\"\n    global bus\n    mgroup = MONITOR_GROUP.from_name(mgroup_str)\n    names_width = 0\n    for cmd in SBS_CMD_GROUPS[mgroup]:\n        names_width = max(names_width, len(cmd.name))\n    for anycmd in SBS_CMD_GROUPS[mgroup]:\n        if anycmd in MANUFACTURER_ACCESS_CMD_BQ_INFO.keys():\n            cmd = SBS_COMMAND.ManufacturerAccess\n            subcmd = anycmd\n        else:\n            cmd = anycmd\n            subcmd = None\n        cmdinf = SBS_CMD_INFO[cmd]\n        opts = {'subcmd': subcmd}\n        try:\n            v, l, u, s = smbus_read(bus, po.dev_address, cmd, opts, vals, po)\n        except Exception as ex:\n            print(\"{:{}s}\\t{}\\t{}\\t{}\".format(cmd.name+\":\", names_width, \"n/a\", \"FAIL\", str_exception_with_type(ex)))\n            if (isinstance(ex, OSError)):\n                smart_battery_system_last_error(bus, po.dev_address, vals, po)\n            if (po.explain):\n                print(\"Description: {}\".format(cmdinf['desc']))\n            continue\n        response = {'val':v,'list':l,'sinf':s,'uname':u,}\n        vals[cmd if subcmd is None else subcmd] = response\n        print_sbs_command_value(cmd, subcmd, response, opts, names_width, po)\n    return\n\n\ndef smart_battery_system_sealing(seal_str, vals, po):\n    \"\"\" Change sealing state of the battery.\n    \"\"\"\n    global bus\n\n    if seal_str in SBS_SEALING:\n        auth = SBS_SEALING[seal_str]['auth']\n        cmd = SBS_SEALING[seal_str]['cmd']\n        subcmd = SBS_SEALING[seal_str]['subcmd']\n    else:\n        raise ValueError(\"Unrecognized target seal state\")\n\n    if True:\n        cmdinf = SBS_CMD_INFO[cmd]\n    if subcmd is not None:\n        subcmdinf = sbs_subcommand_get_info(cmd, subcmd)\n        if len(subcmdinf) <= 0:\n            raise ValueError(\"Command {}.{} missing definition\".format(cmd.name,subcmd.name))\n        resp_type = subcmdinf['type']\n    else:\n        subcmdinf = {}\n        resp_type = \"void\"\n\n    if 'resp_location' in subcmdinf:\n        resp_cmd = subcmdinf['resp_location']\n    else:\n        resp_cmd = None\n    if 'resp_wait' in subcmdinf:\n        resp_wait = subcmdinf['resp_wait']\n    else:\n        resp_wait = 0\n\n    checkcmd = SBS_SEALING[\"Check\"]\n    checkcmd_name = \"{}.{}\".format(checkcmd['cmd'].name,checkcmd['subcmd'].name)\n\n    if auth == \"SHA-1/HMAC\":\n        time.sleep(0.35)\n        smbus_perform_unseal_bq_sha1_hmac(bus, po.dev_address,\n          cmd, subcmd, resp_type, resp_cmd, resp_wait, po.sha1key, po)\n        time.sleep(0.35)\n    elif auth == \"2-Word SCKey\": # Two word key, where first word is written as MAC sub-command\n        time.sleep(0.35)\n        smbus_perform_unseal_bq_2word_sckey(bus, po.dev_address,\n          cmd, resp_wait, (po.i32key) & 0xffff, (po.i32key>>16) & 0xffff, vals, po)\n        time.sleep(0.35)\n    else: # No auth required - sealing or checking status\n        if resp_type == \"void\":\n            smbus_write_raw_block_by_writing_word_subcmd(bus, po.dev_address,\n              cmd, subcmd, b'', resp_type, resp_cmd, resp_wait, po)\n        else:\n            raise ValueError(\"No auth, but not void command; not sure what to do\")\n\n    smart_battery_system_read(checkcmd_name, vals, po)\n\n\ndef extract_r_commands_list():\n    \"\"\" Create lists of commands: for read, and everything else (not read).\n    \"\"\"\n    all_r_commands = []\n    all_nr_commands = []\n    for cmd, cmdinf in SBS_CMD_INFO.items():\n        can_access = sum((\"r\" in accstr) for accstr in cmdinf['access_per_seal'])\n        if 'subcmd_infos' in cmdinf:\n            for subgrp in cmdinf['subcmd_infos']:\n                for subcmd, subcmdinf in subgrp.items():\n                    if 'cmd_array' in subcmdinf:\n                        all_nr_commands.append(\"{}.{}\".format(cmd.name,subcmd.name))\n                        continue\n                    sub_can_access = sum((\"r\" in accstr) for accstr in subcmdinf['access_per_seal'])\n                    if sub_can_access > 0:\n                        all_r_commands.append(\"{}.{}\".format(cmd.name,subcmd.name))\n                    else:\n                        all_nr_commands.append(\"{}.{}\".format(cmd.name,subcmd.name))\n        elif 'cmd_array' in cmdinf:\n            all_nr_commands.append(cmd.name)\n        else:\n            if can_access > 0:\n                all_r_commands.append(cmd.name)\n            else:\n                all_nr_commands.append(cmd.name)\n    return all_r_commands, all_nr_commands\n\n\ndef extract_w_commands_list():\n    \"\"\" Create lists of commands: for write, and for trigger.\n    \"\"\"\n    all_w_commands = []\n    all_t_commands = []\n    for cmd, cmdinf in SBS_CMD_INFO.items():\n        can_access = sum((\"w\" in accstr) for accstr in cmdinf['access_per_seal'])\n        if 'subcmd_infos' in cmdinf:\n            for subgrp in cmdinf['subcmd_infos']:\n                for subcmd, subcmdinf in subgrp.items():\n                    if 'cmd_array' in subcmdinf:\n                        continue\n                    sub_can_access = sum((\"w\" in accstr) for accstr in subcmdinf['access_per_seal'])\n                    if sub_can_access > 0:\n                        if subcmdinf['type'] == \"void\":\n                            all_t_commands.append(\"{}.{}\".format(cmd.name,subcmd.name))\n                        else:\n                            all_w_commands.append(\"{}.{}\".format(cmd.name,subcmd.name))\n        elif 'cmd_array' in cmdinf:\n            pass\n        else:\n            if can_access > 0:\n                if cmdinf['type'] == \"void\":\n                    all_t_commands.append(cmd.name)\n                else:\n                    all_w_commands.append(cmd.name)\n    return all_w_commands, all_t_commands\n\n\ndef extract_raw_commands_list():\n    \"\"\" Create lists of raw commands: for read and write.\n    \"\"\"\n    raw_r_commands = []\n    for knd, kndinf in RAW_ADDRESS_SPACE_KIND_INFO.items():\n        can_access = sum((\"r\" in accstr) for accstr in kndinf['access_per_seal'])\n        if True:\n            if can_access > 0:\n                raw_r_commands.append(knd.name)\n\n    raw_w_commands = []\n    for knd, kndinf in RAW_ADDRESS_SPACE_KIND_INFO.items():\n        can_access = sum((\"w\" in accstr) for accstr in kndinf['access_per_seal'])\n        if True:\n            if can_access > 0:\n                raw_w_commands.append(knd.name)\n    return raw_r_commands, raw_w_commands\n\n\ndef parse_chip_type(s):\n    \"\"\" Parses chip type string in known formats.\n    \"\"\"\n    return s\n\n\ndef parse_addrspace_datatype(s):\n    \"\"\" Parses command/offset string in known formats.\n    \"\"\"\n    if s in (\"int8\", \"uint8\", \"int16\", \"uint16\", \"int32\", \"uint32\", \"float\",):\n        return s\n\n    if re.match(r'(byte|string)\\[([0-9]+|0x[0-9a-fA-F]+)\\]', s):\n        return s\n\n    raise argparse.ArgumentTypeError(\" invalid choice: '{}' (see '--help' for a list)\".format(s))\n\n\ndef parse_monitor_group(s):\n    \"\"\" Parses monitor group string in known formats.\n    \"\"\"\n    return s\n\ndriver_cache = dict()\n\ndef main(argv=sys.argv[1:]):\n    \"\"\" Main executable function.\n\n      Its task is to parse command line options and call a function which performs sniffing.\n    \"\"\"\n\n    global driver_cache\n\n    addrspace_datatypes = [ \"int8\", \"uint8\", \"int16\", \"uint16\", \"int32\", \"uint32\", \"float\", 'string[n]', 'byte[n]']\n\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-b', '--bus', default=\"i2c:1\", type=str,\n            help=(\"I2C/SMBus bus device selection; 'smbus' will use OS API \"\n              \"prepared for that protocol, while 'i2c' will use I2C messages, \"\n              \"constructing SMBus frames manually; after a colon, bus number \"\n              \"from your OS has to be provided (defaults to '%(default)s')\"))\n\n    parser.add_argument('-a', '--dev_address', default=0x0b, type=lambda x: int(x,0),\n            help=\"target SBS device address (defaults to 0x%(default)x)\")\n\n    parser.add_argument('-c', '--chip', metavar='model', choices=[i.name for i in CHIP_TYPE],\n            type=parse_chip_type,  default=CHIP_TYPE.AUTO.name,\n            help=\"target chip model; one of: {:s} (defaults to '%(default)s')\"\n              .format(', '.join(i.name for i in CHIP_TYPE)))\n\n    parser.add_argument(\"--dry-run\", action='store_true',\n            help=\"do not use real smbus device or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n            help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-s', '--short', action='store_true',\n            help=\"display only minimal description of values; to be used by \"\n              \"experienced users, who have no need for additional info\")\n\n    subparser.add_argument('-e', '--explain', action='store_true',\n            help=\"explain each value by providing description from spec\")\n\n    parser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n              .format(version=__version__, author=__author__),\n            help=\"display version information and exit\")\n\n    subparsers = parser.add_subparsers(dest='action', metavar='action',\n            help=\"action to take\", required=True)\n\n    subpar_info = subparsers.add_parser('info',\n            help=(\"displays information about specific command; when chip \"\n              \"auto-detect is disabled, this action does not require SMBus \"\n              \"connection; it just shows the shortened version of description \"\n              \"from manual, which is included in the tool\"))\n\n    subpar_info.add_argument('command', metavar='command', type=str,\n            help=(\"the command/offset name to show info about; \"\n              \"use 'info-list' action to see supported commands\"))\n\n    subpar_info_list = subparsers.add_parser('info-list',\n            help=(\"lists all commands on which 'info' action can be used; \"\n              \"the list changes with selected chip type; when chip auto-detect \"\n              \"is disabled, this action can be performed without connection\"))\n\n    subpar_read = subparsers.add_parser('read',\n            help=\"read value from a single command/offset of the battery\")\n\n    subpar_read.add_argument('command', metavar='command', type=str,\n            help=(\"the command/offset name to read from; \"\n              \"use 'read-list' action to see supported commands\"))\n\n    subpar_read_list = subparsers.add_parser('read-list',\n            help=(\"lists all commands on which 'read' action can be used; \"\n              \"the list changes with selected chip type; when chip auto-detect \"\n              \"is disabled, this action can be performed without connection\"))\n\n    subpar_trigger = subparsers.add_parser('trigger',\n            help=\"write to a trigger, command/offset of the battery which acts as a switch\")\n\n    subpar_trigger.add_argument('command', metavar='command', type=str,\n            help=(\"the command/offset name to trigger; \"\n              \"use 'trigger-list' action to see supported commands\"))\n\n    subpar_trigger_list = subparsers.add_parser('trigger-list',\n            help=(\"lists all commands on which 'trigger' action can be used; \"\n              \"the list changes with selected chip type; when chip auto-detect \"\n              \"is disabled, this action can be performed without connection\"))\n\n    subpar_write = subparsers.add_parser('write',\n            help=\"write value to a single command/offset of the battery\")\n\n    subpar_write.add_argument('command', metavar='command', type=str,\n            help=(\"the command/offset name to write to; \"\n              \"use 'write-list' action to see supported commands\"))\n\n    subpar_write.add_argument('newvalue', metavar='value', type=str,\n            help=\"new value to write to the command/offset\")\n\n    subpar_write_list = subparsers.add_parser('write-list',\n            help=(\"lists all commands on which 'write' action can be used; \"\n              \"the list changes with selected chip type; when chip auto-detect \"\n              \"is disabled, this action can be performed without connection\"))\n\n    subpar_raw_read = subparsers.add_parser('raw-read',\n            help=\"read raw value from an address space of the battery\")\n\n    subpar_raw_read.add_argument('addrspace', metavar='addrspace', type=str,\n            help=(\"the address space name to read from; use 'raw-read-list' \"\n              \"action to see supported addrspaces\"))\n\n    subpar_raw_read.add_argument('address', metavar='address', type=lambda x: int(x,0),\n            help=\"address within the space to read from\")\n\n    subpar_raw_read.add_argument('dttype', metavar='datatype', type=parse_addrspace_datatype,\n            help=\"data type at target offset; one of: {:s}\".format(', '.join(addrspace_datatypes)))\n\n\n    subpar_raw_read_list = subparsers.add_parser('raw-read-list',\n            help=(\"lists all address spaces on which 'raw-read' action can be used; \"\n              \"the list changes with selected chip type; when chip auto-detect \"\n              \"is disabled, this action can be performed without connection\"))\n\n    subpar_raw_write = subparsers.add_parser('raw-write',\n            help=\"write raw value into an address space of the battery\")\n\n    subpar_raw_write.add_argument('addrspace', metavar='addrspace', type=str,\n            help=(\"the address space name to write into; use 'raw-write-list' \"\n              \"action to see supported addrspaces\"))\n\n    subpar_raw_write.add_argument('address', metavar='address', type=lambda x: int(x,0),\n            help=\"address within the space to write to\")\n\n    subpar_raw_write.add_argument('dttype', metavar='datatype', type=parse_addrspace_datatype,\n            help=\"data type at target offset; one of: {:s}\".format(', '.join(addrspace_datatypes)))\n\n    subpar_raw_write.add_argument('newvalue', metavar='value', type=str,\n            help=\"new value to write at the address\")\n\n    subpar_raw_write_list = subparsers.add_parser('raw-write-list',\n            help=(\"lists all address spaces on which 'raw-write' action can be used; \"\n              \"the list changes with selected chip type; when chip auto-detect \"\n              \"is disabled, this action can be performed without connection\"))\n\n    subpar_raw_backup = subparsers.add_parser('raw-backup',\n            help=\"read whole raw address space and store it in a file\")\n\n    subpar_raw_backup.add_argument('addrspace', metavar='addrspace', type=str,\n            help=(\"the address space name to backup; use 'raw-read-list' \"\n              \"action to see supported addrspaces\"))\n\n    subpar_raw_backup.add_argument('fname', metavar='filename', type=str,\n            help=\"name of the file to write to\")\n\n    subpar_raw_restore = subparsers.add_parser('raw-restore',\n            help=\"write whole raw address space using values from a file\")\n\n    subpar_raw_restore.add_argument('addrspace', metavar='addrspace', type=str,\n            help=(\"the address space name to restore; use 'raw-write-list' \"\n              \"action to see supported addrspaces\"))\n\n    subpar_raw_restore.add_argument('fname', metavar='filename', type=str,\n            help=\"name of the file to read from\")\n\n    subpar_monitor = subparsers.add_parser('monitor',\n            help=(\"monitor value of a group of commands/offsets; \"\n              \"just reads all of the values from a group\"))\n\n    subpar_monitor.add_argument('cmdgroup', metavar='group',\n            choices=[i.name for i in MONITOR_GROUP], type=parse_monitor_group,\n            help=\"group of commands/offsets; one of: {:s}\".format(', '.join(i.name for i in MONITOR_GROUP)))\n\n    subpar_sealing = subparsers.add_parser('sealing',\n            help=\"change sealing state of BQ chip\")\n\n    sealing_choices = (\"Unseal\", \"Seal\", \"FullAccess\",)\n    subpar_sealing.add_argument('sealstate', metavar='state', choices=sealing_choices, type=str,\n            help=\"new sealing state; one of: {:s}\".format(', '.join(sealing_choices)))\n\n    subpar_sealing.add_argument('--sha1key', default='0123456789abcdeffedcba9876543210', type=str,\n            help=\"device key for SHA-1/HMAC Authentication (defaults to '%(default)s')\")\n\n    subpar_sealing.add_argument('--i32key', default=None, type=lambda x: int(x,0),\n            help=(\"device key for 32-bit integer (two word) Authentication \"\n              \"(defaults to 0x{:08x} for FullAccess, otherwise to 0x{:08x})\"\n              ).format(0xffffffff,0x36720414))\n\n    po = parser.parse_args(argv)\n\n    vals = {}\n\n    po.chip = CHIP_TYPE.from_name(po.chip)\n\n    po.offline_mode = False\n\n    # If specific chip type was provided, then some actions do not require SMBus connection\n    if po.action in ('info','info-list','read-list','trigger-list','write-list',) and (po.chip != CHIP_TYPE.AUTO):\n        if (po.verbose > 0):\n            print(\"Using offline mode\")\n        po.offline_mode = True\n    else:\n        if (po.verbose > 0):\n            print(\"Opening {}\".format(po.bus))\n        smbus_open(po.bus, po)\n\n    # Re-init global variables; then they are modified by specific chip driver, do it before detection\n    reset_default_driver(po)\n    if po.chip == CHIP_TYPE.AUTO:\n        po.chip = smart_battery_detect(vals, po)\n\n    if po.chip in driver_cache:\n        chip_file_code = driver_cache[po.chip]\n        exec(chip_file_code)\n    else:\n        if po.chip in (CHIP_TYPE.BQ30z50, CHIP_TYPE.BQ30z55, CHIP_TYPE.BQ30z554,):\n            fnames = [\"comm_sbs_chips/{}.py\".format(\"BQ30z554\")]\n        elif po.chip in (CHIP_TYPE.BQ40z50,):\n            fnames = [\"comm_sbs_chips/{}.py\".format(\"BQ40z50\")]\n        elif po.chip in (\"SBS\",):    # default\n            pass # do nothing, already loaded with reset_default_driver(po)\n        else:\n            fnames = [\"comm_sbs_chips/{}.py\".format(po.chip.name)]\n        driver_cache[po.chip] = list()\n        for fname in fnames:\n            try:\n                with open(fname, \"rb\") as source_file:\n                    chip_file_code = compile(source_file.read(), fname, \"exec\")\n                if (po.verbose > 0):\n                    print(\"Importing {}\".format(fname))\n                exec(chip_file_code)\n                driver_cache[po.chip] = chip_file_code\n            except IOError:\n                print(\"Warning: Could not open chip definition file '{}'\".format(fname))\n\n    if po.action == 'info':\n        smart_battery_system_info(po.command, vals, po)\n    elif po.action == 'info-list':\n        if (po.explain > 0):\n            print(\"Display info can be used on any of the following commands:\")\n        all_r_commands, all_nr_commands = extract_r_commands_list()\n        print(\"\\n\".join(sorted(all_r_commands+all_nr_commands)))\n    elif po.action == 'read-list':\n        if (po.explain > 0):\n            print(\"Read value can be used on any of the following commands:\")\n        all_r_commands, all_nr_commands = extract_r_commands_list()\n        print(\"\\n\".join(sorted(all_r_commands)))\n    elif po.action == 'trigger-list':\n        if (po.explain > 0):\n            print(\"Trigger can be sent to any of the following commands:\")\n        all_w_commands, all_t_commands = extract_w_commands_list()\n        print(\"\\n\".join(sorted(all_t_commands)))\n    elif po.action == 'write-list':\n        if (po.explain > 0):\n            print(\"Write value can be used on any of the following commands:\")\n        all_w_commands, all_t_commands = extract_w_commands_list()\n        print(\"\\n\".join(sorted(all_w_commands)))\n    elif po.action == 'raw-read-list':\n        if (po.explain > 0):\n            print(\"Raw Read can be used on any of the following address spaces:\")\n        raw_r_commands, raw_w_commands = extract_raw_commands_list()\n        print(\"\\n\".join(sorted(raw_r_commands)))\n    elif po.action == 'raw-write-list':\n        if (po.explain > 0):\n            print(\"Raw Write can be used on any of the following address spaces:\")\n        raw_r_commands, raw_w_commands = extract_raw_commands_list()\n        print(\"\\n\".join(sorted(raw_w_commands)))\n    elif po.action == 'read':\n        smart_battery_system_read(po.command, vals, po)\n    elif po.action == 'trigger':\n        smart_battery_system_trigger(po.command, vals, po)\n    elif po.action == 'write':\n        smart_battery_system_write(po.command, po.newvalue, vals, po)\n    elif po.action == 'raw-read':\n        smart_battery_system_raw_read(po.addrspace, po.address,\n          po.dttype, vals, po)\n    elif po.action == 'raw-write':\n        smart_battery_system_raw_write(po.addrspace, po.address,\n          po.dttype, po.newvalue, vals, po)\n    elif po.action == 'raw-backup':\n        smart_battery_system_raw_backup(po.addrspace, po.fname, vals, po)\n    elif po.action == 'raw-restore':\n        smart_battery_system_raw_restore(po.addrspace, po.fname, vals, po)\n    elif po.action == 'monitor':\n        smart_battery_system_monitor(po.cmdgroup, vals, po)\n    elif po.action == 'sealing':\n        if po.i32key is None:\n            if po.sealstate == \"FullAccess\":\n                po.i32key = 0xffffffff\n            else:\n                po.i32key = 0x36720414\n        smart_battery_system_sealing(po.sealstate, vals, po)\n    else:\n        raise NotImplementedError(\"Unsupported or missing command.\")\n\n    if not po.offline_mode:\n        smbus_close()\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str_exception_with_type(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "comm_sbs_chips",
          "type": "tree",
          "content": null
        },
        {
          "name": "comm_serial2pcap.py",
          "type": "blob",
          "size": 7.81640625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DJI serial bus sniffer with PCap output.\n\n This script captures data from two UARTs and attempts to packetise the\n streams. CRC is checked before the packet is passed to the PCap file/fifo.\n\n If the packets you are trying to capture are not compatible, you may capture\n the plain binary data instead (though you won't be able to interleave two streams):\n\n ```\n stty -F /dev/ttyS1 115200 cs8 -parenb -cstopb; cat /dev/ttyS1 | pv | cat > output.dat\n ```\n\n\"\"\"\n\n# Copyright (C) 2017 GlovePuppet <https://github.com/glovepuppet>\n# Copyright (C) 2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# Derived from:\n#\n# AVR / Arduino dynamic memory log analyis script.\n#\n# Copyright 2014 Matthijs Kooijman <matthijs@stdin.nl>\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n# This script is intended to read raw packets (currently only 802.15.4\n# packets prefixed by a length byte) from a serial port and output them\n# in pcap format.\n\n__version__ = \"0.5.0\"\n__author__ = \"GlovePuppet, Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport os\nimport sys\nimport serial\nimport select\nimport argparse\n\nsys.path.insert(0, './')\nfrom comm_dat2pcap import (\n  do_packetise_byte, store_packet, drop_packet,\n  is_packet_ready, is_packet_damaged, is_packet_at_finish,\n  PcapFormatter, HumanFormatter, PktInfo, PktState,\n  eprint,\n)\n\n\ndef open_fifo(options, name):\n    try:\n        os.mkfifo(name)\n    except FileExistsError:\n        pass\n    except Exception:\n        raise\n\n    if not options.quiet:\n        print(\"Waiting for fifo to be openend...\")\n    # This blocks until the other side of the fifo is opened\n    return open(name, 'wb')\n\n\ndef setup_output(options):\n    if options.fifo:\n        return PcapFormatter(open_fifo(options, options.fifo))\n    elif options.write_file:\n        return PcapFormatter(open(options.write_file, 'wb'))\n    else:\n        return HumanFormatter(sys.stdout)\n\n\ndef do_packetiser(ser, state, out, info):\n    num_bytes = ser.inWaiting()\n    while (num_bytes > 0):\n        # The read() function in Python is ridiculously slow; instead of using it\n        # many times to read one byte, let's call it once for considerable buffer\n        btarr = ser.read(min(num_bytes,4096))\n        for bt in btarr:\n            state, info = do_packetise_byte(bt, state, info)\n            if (is_packet_ready(state)):\n                state = store_packet(out, state)\n            elif (is_packet_damaged(state)):\n                if (out.storebad):\n                    state = store_packet(out, state)\n                else:\n                    state = drop_packet(state)\n        if (is_packet_at_finish(state)):\n            break\n        num_bytes = ser.inWaiting()\n    return state, info\n\n\ndef do_sniff_once(options):\n    # This might block until the other side of the fifo is opened\n    out = setup_output(options)\n    out.userdlt = options.userdlt\n    out.storebad = options.storebad\n    out.write_header()\n\n    ser1 = serial.Serial(options.port1, options.baudrate)\n    print(\"Opened {} at {}\".format(options.port1, options.baudrate))\n\n    ser2 = serial.Serial(options.port2, options.baudrate)\n    print(\"Opened {} at {}\".format(options.port2, options.baudrate))\n\n    if not options.quiet:\n        print(\"Waiting for packets...\")\n\n    info = PktInfo()\n\n    poll = select.poll()\n    # Wait to read data from serial, or until the fifo is closed\n    poll.register(ser1, select.POLLIN)\n    poll.register(ser2, select.POLLIN)\n    if not options.quiet:\n        poll.register(sys.stdin, select.POLLIN)\n    poll.register(out, select.POLLERR)\n\n    state1 = PktState()\n    state1.verbose = 0 if options.quiet else max(options.verbose, 1)\n    state1.pname = options.port1\n    state2 = PktState()\n    state2.verbose = 0 if options.quiet else max(options.verbose, 1)\n    state2.pname = options.port2\n\n    while True:\n        # Wait for something to do\n        events = poll.poll()\n\n        fds = [fd for (fd, evt) in events]\n        if out.fileno() in fds:\n            # Error on output, e.g. fifo closed on the other end\n            break\n\n        if ser1.fileno() in fds:\n            state1, info = do_packetiser(ser1, state1, out, info)\n\n        if ser2.fileno() in fds:\n            state2, info = do_packetiser(ser2, state2, out, info)\n\n        if sys.stdin.fileno() in fds:\n            input()\n            print(\"Captured {:d} packets ({:d}b), dropped {:d} fragments ({:d}b)\".format(info.count_ok,\n                info.bytes_ok, info.count_bad, info.bytes_bad))\n\n    ser1.close()\n    ser2.close()\n    out.close()\n\n    if not options.quiet:\n        print(\"Captured {:d} packets ({:d}b), dropped {:d} fragments ({:d}b)\".format(info.count_ok,\n            info.bytes_ok, info.count_bad, info.bytes_bad))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n      Its task is to parse command line options and call a function which performs sniffing.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('port1', type=str,\n            help=\"the first serial port to read from\")\n\n    parser.add_argument('port2', type=str,\n            help=\"the second serial port to read from\")\n\n    parser.add_argument('-b', '--baudrate', default=115200, type=int,\n            help=\"the baudrate to use for both serial ports (defaults to %(default)s)\")\n\n    parser.add_argument('-u', '--userdlt', default=0, type=int,\n            help=\"the data link type of the PCap DLT_USER protocol (defaults to %(default)s)\")\n\n    parser.add_argument('-e', '--storebad', action='store_true',\n            help=\"enables storing bad packets (ie. with bad checksums)\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-q', '--quiet', action='store_true',\n            help=\"do not output any informational messages\")\n\n    subparser.add_argument('-v', '--verbose', action='count', default=0,\n            help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-F', '--fifo',\n            help=(\"write output to a fifo instead of stdout; the fifo is created \"\n              \"if needed and capturing does not start until the other side of the fifo is opened\"))\n\n    subparser.add_argument('-w', '--write-file',\n            help=\"write output to a file instead of stdout\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n              .format(version=__version__, author=__author__),\n            help=\"display version information and exit\")\n\n    options = parser.parse_args()\n\n    try:\n        # If the fifo got closed, just start over again\n        while True:\n            do_sniff_once(options)\n    except KeyboardInterrupt:\n        pass\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "comm_serialtalk.py",
          "type": "blob",
          "size": 16.154296875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Utility to talk to DJI product via DUPC packets on serial interface.\n\n This script takes header fields and payload, and builds a proper DUPC\n packet from them. Then it sends it via given serial port and waits for an answer.\n\"\"\"\n\n# Copyright (C) 2018 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.6.0\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport argparse\nimport io\nimport sys\nimport time\nfrom ctypes import sizeof\n\nsys.path.insert(0, './')\nfrom comm_dat2pcap import (\n  do_packetise_byte, store_packet, drop_packet,\n  is_packet_ready, is_packet_damaged, is_packet_at_finish,\n  Formatter, PktInfo, PktState,\n  eprint,\n)\nfrom comm_mkdupc import (\n  parse_module_ident, parse_module_type, parse_ack_type,\n  parse_encrypt_type, parse_packet_type, parse_cmd_set,\n  encode_command_packet_en, get_known_payload,\n  DJICmdV1Header, PACKET_TYPE, COMM_DEV_TYPE,\n)\n\nclass ListFormatter():\n    def __init__(self):\n        self.pktlist = []\n\n    def write_header(self):\n        pass\n\n    def write_packet(self, data, dtime=None):\n        self.pktlist.append(data)\n\nclass SerialMock(io.RawIOBase):\n    def __init__( self, port='COM1', baudrate = 19200, timeout=1,\n                  bytesize = 8, parity = 'N', stopbits = 1, xonxoff=0,\n                  rtscts = 0):\n        self.name     = port\n        self.port     = port\n        self.timeout  = timeout\n        self.parity   = parity\n        self.baudrate = baudrate\n        self.bytesize = bytesize\n        self.stopbits = stopbits\n        self.xonxoff  = xonxoff\n        self.rtscts   = rtscts\n        self.is_open  = True\n        self._rxData = []\n        self._txData = []\n        self._wait_time = time.time()\n\n    def write( self, btarr ):\n        self._txData.append(btarr)\n\n    def read( self, n=1 ):\n        if time.time() < self._wait_time: return b\"\"\n        self._wait_time = time.time() + 0.05\n        if len(self._rxData) < 1: return b\"\"\n        btarr = self._rxData[0][0:n]\n        if len(btarr) >= len(self._rxData[0]):\n            del self._rxData[0]\n        else:\n            self._rxData[0] = self._rxData[0][n:]\n        return btarr\n\n    def mock_data_for_read( self, btarr ):\n        self._rxData.append(btarr)\n\n    def reset_input_buffer(self):\n        pass\n\n    @property\n    def in_waiting(self):\n        if time.time() < self._wait_time: return 0\n        if len(self._rxData) < 1: return 0\n        return len(self._rxData[0])\n\n\nclass SerialBulkWrap():\n    def __init__( self, dev, ep_in, ep_out, timeout=100):\n        self.name = 'BULK'\n        self.dev = dev\n        self.ep_in = ep_in\n        self.ep_out = ep_out\n        self.timeout = timeout\n        self.port = None\n        self.baudrate = None\n        self.port_open = False\n\n    def write( self, btarr ):\n        self.ep_out.write(btarr)\n\n    def read( self, n=1):\n        btarr = self.ep_in.read(self.ep_in.wMaxPacketSize,self.timeout)\n        return btarr\n\n    def close(self):\n        import usb.util\n        usb.util.dispose_resources(self.dev)\n\n    def reset_input_buffer(self):\n        pass\n\n    @property\n    def in_waiting(self):\n        return 1\n\n\ndef find_correct_device(dev):\n    # Ugly way of finding the correct bulk device.\n    # I truly wish this would be simpler.\n    import usb.util\n\n    for d in dev:\n        for cfg in d:\n            # see if we can get the interface description.\n            interface_description = usb.util.get_string(d, cfg.iConfiguration)\n\n            if \",\" in interface_description:\n                # UAVs\n                # They may have multiple \"bulk\" intefaces (all with the same\n                # bInterfaceSubClass), so we need to look for the \"ACM\" one\n                # (which is the DUML BULK interface)\n                interface_descriptions = interface_description.split(\",\")\n                try:\n                    interface_for_acm = interface_descriptions.index(\"acm\") + 1\n                except ValueError:\n                    print(\"no ACM (bulk) interface here.\")\n                    continue\n                print(\"using bInterfaceNumber %d\" % interface_for_acm)\n                for intf in cfg:\n                    if intf.bInterfaceNumber == interface_for_acm:\n                        assert intf.bInterfaceSubClass == 0x43, \"we expect the ACM inteface to be of the right bInterfaceSubclass\"\n                        return intf\n            elif \"_\" in interface_description:\n\n                # RM330: \"mtp_bulk_adb\"\n                #   Interface 0: mtp\n                #   Interface 1: bulk\n                #   Interface 2: adb\n\n                # but:\n                # RM510: \"mtp_bulk_adb\"\n                #   Interface 0: bulk\n                #   Interface 1: mtp\n                #   Interface 2: adb\n\n                # So we resort to look for a bulk interface based on subclass.\n                # (Same strategy doesn't work on e.g. wm260 because they\n                # have multiple bulk interfaces with the same subclass.)\n\n                interface_descriptions = interface_description.split(\"_\")\n                if \"bulk\" in interface_descriptions:\n                    interface_for_acm = interface_descriptions.index(\"bulk\")\n                    for intf in cfg:\n                        if intf.bInterfaceSubClass == 0x43:\n                            return intf\n                else:\n                    print(\"no BULK interface here.\")\n                    continue\n            else:\n                print(\"can't parse\", interface_descriptions)\n                continue\n\n    return None\n\n\ndef open_usb(po):\n    import usb.core\n    import usb.util\n    import usb.backend.libusb0 as myusb\n\n    mybackend = myusb.get_backend()\n    dev = usb.core.find(idVendor=0x2ca3, find_all = True, backend=mybackend)\n    intf = find_correct_device(dev)\n\n    assert intf is not None, \"Could not find any DJI BULK device\"\n\n    ep_out = usb.util.find_descriptor(\n        intf,\n        # match the first OUT endpoint\n        custom_match = \\\n        lambda e: \\\n            usb.util.endpoint_direction(e.bEndpointAddress) == \\\n            usb.util.ENDPOINT_OUT)\n\n    ep_in = usb.util.find_descriptor(\n        intf,\n        # match the first OUT endpoint\n        custom_match = \\\n        lambda e: \\\n            usb.util.endpoint_direction(e.bEndpointAddress) == \\\n            usb.util.ENDPOINT_IN)\n\n    if dev and ep_in and ep_out:\n        return SerialBulkWrap(dev,ep_in,ep_out, po.timeout)\n    else:\n        assert False, \"Could not find endpoints for bulk interface\"\n\n\ndef do_read_packets(ser, state, info):\n    out = ListFormatter()\n    num_bytes = ser.in_waiting\n    while (num_bytes > 0):\n        # The read() function in Python is ridiculously slow; instead of using it\n        # many times to read one byte, let's call it once for considerable buffer\n        btarr = ser.read(min(num_bytes,4096))\n        for bt in btarr:\n            state, info = do_packetise_byte(bt, state, info)\n            if (is_packet_ready(state)):\n                state = store_packet(out, state)\n            elif (is_packet_damaged(state)):\n                state = drop_packet(state)\n        if (is_packet_at_finish(state)):\n            break\n        num_bytes = ser.in_waiting\n        if ser.name == 'BULK':\n            num_bytes = 0\n    return state, out.pktlist, info\n\n\ndef packet_header_is_reply_for_request(rplhdr, reqhdr, responsebit_check=False, seqnum_check=True):\n    if (rplhdr.version != 1):\n        return False\n    if (rplhdr.cmd_set != reqhdr.cmd_set):\n        return False\n    if (rplhdr.cmd_id != reqhdr.cmd_id):\n        return False\n    if (rplhdr.sender_info != reqhdr.receiver_info):\n        return False\n    if (rplhdr.receiver_info != reqhdr.sender_info):\n        return False\n    if (rplhdr.seq_num != reqhdr.seq_num) and seqnum_check:\n        return False\n    # Many responses don't have the RESPONSE bit set\n    if (rplhdr.packet_type != PACKET_TYPE.RESPONSE) and responsebit_check:\n        return False\n    # Ack types should be different - respone should have NO_ACK; but in practice this varies\n    #if (rplhdr.ack_type != reqhdr.ack_type):\n    #    return False\n    return True\n\n\ndef find_reply_for_request(po, pktlist, pktreq, seqnum_check=True):\n    if len(pktlist) == 0:\n        return None\n    reqhdr = DJICmdV1Header.from_buffer_copy(pktreq)\n    for pktrpl in pktlist:\n        rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n        if packet_header_is_reply_for_request(rplhdr, reqhdr, seqnum_check=seqnum_check):\n            return pktrpl\n        if (po.verbose > 2):\n            print(\"Received unrelated packet:\")\n            print(' '.join('{:02x}'.format(x) for x in pktrpl))\n    return None\n\n\ndef do_send_request(po, ser, pktprop):\n    pktreq = encode_command_packet_en(pktprop.sender_type, pktprop.sender_index,\n      pktprop.receiver_type, pktprop.receiver_index, pktprop.seq_num,\n      pktprop.pack_type, pktprop.ack_type, pktprop.encrypt_type, pktprop.cmd_set,\n      pktprop.cmd_id, pktprop.payload)\n    if (po.verbose > 1):\n        print(\"Prepared binary packet:\")\n        print(' '.join('{:02x}'.format(x) for x in pktreq))\n\n    if (po.verbose > 0):\n        print(\"Sending packet...\")\n\n    ser.write(pktreq)\n\n    return pktreq\n\n\ndef do_receive_reply(po, ser, pktreq, seqnum_check=True):\n    \"\"\" Receive reply after sending packet pktreq to interface ser.\n    \"\"\"\n    ser.reset_input_buffer()\n    if (po.verbose > 1):\n        print(\"Waiting for reply...\")\n\n    info = PktInfo()\n\n    state = PktState()\n    state.verbose = po.verbose\n    state.pname = ser.port\n    pktrpl = None\n    show_stats = False\n    loop_end = False\n    timeout_time = time.time() + po.timeout / 1000\n\n    while not loop_end:\n        # Wait for something to do\n        if time.time() > timeout_time:\n            if (po.verbose > 0):\n                print(\"Timeout while waiting for reply.\")\n            show_stats = True\n            loop_end = True\n\n        if True:\n            state, pktlist, info = do_read_packets(ser, state, info)\n            pktrpl = find_reply_for_request(po, pktlist, pktreq, seqnum_check=seqnum_check)\n\n        if pktrpl is not None:\n            show_stats = True\n            loop_end = True\n\n        if (show_stats):\n            if (po.verbose > 0):\n                print(\"Retrieved {:d} packets ({:d}b), dropped {:d} fragments ({:d}b)\".format(\n                    info.count_ok, info.bytes_ok, info.count_bad, info.bytes_bad))\n            show_stats = False\n\n    return pktrpl\n\n\ndef do_send_request_receive_reply(po):\n    if not po.bulk:\n        # Open serial port\n        import serial\n        ser = serial.Serial(po.port, baudrate=po.baudrate, timeout=0)\n    else:\n        ser = open_usb(po)\n    if (po.verbose > 0):\n        print(\"Opened {} at {}\".format(ser.port, ser.baudrate))\n\n    pktreq = do_send_request(po, ser, po)\n\n    pktrpl = do_receive_reply(po, ser, pktreq, seqnum_check=(not po.loose_response))\n\n    if (po.verbose > 0):\n        if pktrpl is not None:\n            print(\"Received response packet:\")\n        else:\n            print(\"No response received.\")\n    if pktrpl is not None:\n        print(' '.join('{:02x}'.format(x) for x in pktrpl))\n\n        if (po.verbose > 0):\n            rplhdr = DJICmdV1Header.from_buffer_copy(pktrpl)\n            rplpayload = get_known_payload(rplhdr, pktrpl[sizeof(DJICmdV1Header):-2])\n            if (rplpayload is not None):\n                print(\"Parsed response  - {:s}:\".format(type(rplpayload).__name__))\n                print(rplpayload)\n\n    ser.close()\n\n\ndef main():\n    \"\"\" Main executable function.\n\n      Its task is to parse command line options and call a function which performs serial communication.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('--port', type=str,\n            help=\"the serial port to write to and read from\")\n\n    subparser.add_argument('--bulk', action='store_true',\n            help=\"use usb bulk instead of serial connection\")\n\n    parser.add_argument('-b', '--baudrate', default=9600, type=int,\n            help=\"the baudrate to use for the serial port (default is %(default)s)\")\n\n    parser.add_argument('-n', '--seq_num', default=0, type=int,\n            help=\"sequence number of the packet (default is %(default)s)\")\n\n    parser.add_argument('-u', '--pack_type', default=\"Request\", type=parse_packet_type,\n            help=\"packet Type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-a', '--ack_type', default=\"No_ACK_Needed\", type=parse_ack_type,\n            help=\"acknowledgement type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-e', '--encrypt_type', default=\"NO_ENC\", type=parse_encrypt_type,\n            help=\"encryption type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-s', '--cmd_set', default=\"GENERAL\", type=parse_cmd_set,\n            help=\"command Set, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-i', '--cmd_id', default=0, type=int,\n            help=\"command ID (default is %(default)s)\")\n\n    parser.add_argument('-w', '--timeout', default=2000, type=int,\n            help=\"how long to wait for answer, in miliseconds (default is %(default)s)\")\n\n    parser.add_argument('--loose-response', action=\"store_true\",\n            help=\"use loosen criteria when searching for response to the packet\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n            help=\"increases verbosity level; max level is set by -vvv\")\n\n    parser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n              .format(version=__version__, author=__author__),\n            help=\"display version information and exit\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-t', '--sender', type=parse_module_ident,\n            help=\"sender Type and Index, in TTII form\")\n\n    subparser.add_argument('-tt', '--sender_type', default=\"PC\", type=parse_module_type,\n            help=\"sender(transmitter) Type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-ti', '--sender_index', default=0, type=int,\n            help=\"sender(transmitter) Index (default is %(default)s)\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-r', '--receiver', type=parse_module_ident,\n            help=\"receiver Type and Index, in TTII form (ie. 0300)\")\n\n    subparser.add_argument('-rt', '--receiver_type', default=\"ANY\", type=parse_module_type,\n            help=\"receiver Type, either name or number (default is %(default)s)\")\n\n    parser.add_argument('-ri', '--receiver_index', default=0, type=int,\n            help=\"receiver index (default is %(default)s)\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-x', '--payload_hex', type=str,\n            help=\"provide payload as hex string\")\n\n    subparser.add_argument('-p', '--payload_bin', default=\"\", type=str,\n            help=\"provide binary payload directly (default payload is empty)\")\n\n    po = parser.parse_args()\n\n    if (po.payload_hex is not None):\n        po.payload = bytes.fromhex(po.payload_hex)\n    else:\n        po.payload = bytes(po.payload_bin, 'utf-8')\n\n    if (po.sender is not None):\n        po.sender_type = COMM_DEV_TYPE(int(po.sender.group(1), 10))\n        po.sender_index = int(po.sender.group(2), 10)\n\n    if (po.receiver is not None):\n        po.receiver_type = COMM_DEV_TYPE(int(po.receiver.group(1), 10))\n        po.receiver_index = int(po.receiver.group(2), 10)\n\n    do_send_request_receive_reply(po)\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dji_flyc_hardcoder.py",
          "type": "blob",
          "size": 160.3876953125,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Dji Flight Controller firmware binary hard-coded values editor.\n\nThe tool can parse Flight Controller firmware converted to ELF.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nOnly 'setValue' element in the exported file is really changeable,\nall the other data is just informational. This includes `maxValue` and\n`minValue` - they don't do anything and changing them in the JSON file\nwill not influence update operation.\n\nExported values:\n\nog_hardcoded.flyc.max_wp_dist_to_home -\n\n  Max distance from one waypoint to home point, in meters.\n  This value is also app limited and need Android App side patch.\n\nog_hardcoded.flyc.max_alt_above_home -\n\n  Max altitude relative to home point, in meters.\n  This value is also app limited and need Android App side patch.\n\nog_hardcoded.flyc.min_alt_below_home -\n\n  Min altitude relative to home point, in meters.\n  This value is also app limited and need Android App side patch.\n\nog_hardcoded.flyc.max_mission_path_len -\n\n  Maximum total length of mission trace, in meters.\n\nog_hardcoded.flyc.max_speed_pos -\n\n  Maximum speed used when doing autonomous flights; in meters per second [m/s]\".\n  This value should be positive - in represents the limit when calculated speed\n  vector is in positive direction.\n\nog_hardcoded.flyc.max_speed_neg -\n\n  Maximum negative speed used when doing autonomous flights; in meters\n  per second [m/s]\". This value should be lower than zero, and equal to\n  max_speed_pos in its absolute value.\n\n\"\"\"\n\n# Copyright (C) 2017,2018 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.1\"\n__author__ = \"Mefistotelis, Matioupi @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport argparse\nimport io\nimport json\nimport os\nimport re\nimport sys\n\nsys.path.insert(0, './')\nfrom amba_sys_hardcoder import eprint, elf_march_to_asm_config, \\\n  armfw_elf_whole_section_search, armfw_elf_match_to_public_values, \\\n  armfw_elf_paramvals_extract_list, armfw_elf_get_value_update_bytes, \\\n  armfw_elf_paramvals_get_depend_list, armfw_elf_publicval_update, \\\n  armfw_elf_paramvals_update_list, armfw_elf_generic_objdump, \\\n  armfw_asm_search_strings_to_re_list, armfw_elf_paramvals_export_json, \\\n  armfw_elf_paramvals_export_simple_list, armfw_elf_paramvals_export_mapfile, \\\n  VarType, DataVariety, CodeVariety, DummyStruct\n\n\ndef version_string_to_int_getter(val):\n  ver = re.search(r'^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)$', val)\n  ver_major = int(ver.group(1), 10)\n  ver_minor = int(ver.group(2), 10)\n  ver_mmtnc = int(ver.group(3), 10)\n  ver_revsn = int(ver.group(4), 10)\n  return (ver_major << 24) + (ver_minor << 16) + (ver_mmtnc << 8) + (ver_revsn)\n\ndef version_string_to_parts_getter(val, grp):\n  ver = re.search(r'^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)$', val)\n  return int(ver.group(grp), 10)\n\n\nre_func_wp_check_input_mission_validity_P3X_V01_05_0030 = {\n'name': \"wp_check_input_mission_validity\",\n'version': \"P3X_FW_V01.05.0030\",\n're': \"\"\"\nwp_check_input_mission_validity:\n  push\t{r4, r5, r6, r7, lr}\n  ldr\tr0, \\[pc, #(?P<byte_200084A4>[0-9a-fx]+)\\]\n  ldr\tr7, \\[pc, #(?P<byte_20005DF8>[0-9a-fx]+)\\]\n  movs\tr4, #0\n  vpush\t{d8}\n  sub\tsp, #0x1c\n  ldrb\tr0, \\[r0\\]\n  ldrb\tr1, \\[r7\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_8064122>[0-9a-fx]+)\n  b\t#(?P<loc_806438A>[0-9a-fx]+)\nloc_80640E2:\n  add.w\tr0, r4, r4, lsl #1\n  add.w\tr5, r7, r0, lsl #5\n  ldr\tr0, \\[r5, #0x54\\]\n  bl\t#(?P<calculate_cali_matrix>[0-9a-fx]+)\n  vmov\td8, r0, r1\n  ldr\tr0, \\[r5, #0x50\\]\n  bl\t#(?P<calculate_cali_matrix>[0-9a-fx]+)\n  vmov\td0, r0, r1\n  vstr\td8, \\[sp, #(?P<loc_var_28>[0-9a-fx]+)\\]\n  vstr\td0, \\[sp, #(?P<loc_var_30>[0-9a-fx]+)\\]\n  vldr\td0, \\[r5, #0x48\\]\n  mov\tr1, r4\n  vstr\td0, \\[sp\\]\n  vldr\td0, \\[r5, #0x40\\]\n  adr\tr0, #(?P<cstr_debug_log_l1h>[0-9a-fx]+)\n  vmov\tr2, r3, d0\n  bl\t#(?P<flight_rec_printf_send_c0E>[0-9a-fx]+)\n  adds\tr4, r4, #1\n  uxtb\tr4, r4\nloc_8064122:\n  ldrb\tr0, \\[r7\\]\n  cmp\tr0, r4\n  bhi\t#(?P<loc_80640E2>[0-9a-fx]+)\n  uxtb\tr0, r0\n  add.w\tr0, r0, r0, lsl #1\n  ldr\tr1, \\[pc, #(?P<byte_20005DF8>[0-9a-fx]+)\\]\n  add.w\tr0, r7, r0, lsl #5\n  adds\tr0, #0x40\n  movs\tr2, #0x60\n  adds\tr1, #0x40\n  bl\t#(?P<memcpy_0>[0-9a-fx]+)\n  movs\tr5, #0\n  b\t#(?P<loc_806429C>[0-9a-fx]+)\nloc_8064142:\n  add.w\tr0, r5, r5, lsl #1\n  add.w\tr6, r7, r0, lsl #5\n  add.w\tr4, r6, #0x40\n  vldr\td0, \\[r6, #0x40\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi_half>[0-9a-fx]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_808B480>[0-9a-fx]+)\nloc_80641D6:\n  blo\t#(?P<loc_80641D6>[0-9a-fx]+)\n  vldr\td0, \\[r4\\]\n  vldr\td1, \\[pc, #(?P<dbl_pi_half>[0-9a-fx]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_8086F86>[0-9a-fx]+)\n  blo\t#(?P<loc_80641D6>[0-9a-fx]+)\n  vldr\td0, \\[r4, #8\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi>[0-9a-fx]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_808B480>[0-9a-fx]+)\n  blo\t#(?P<loc_80641D6>[0-9a-fx]+)\n  vldr\td0, \\[r4, #8\\]\n  vldr\td1, \\[pc, #(?P<dbl_just_pi>[0-9a-fx]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_8086F86>[0-9a-fx]+)\n  blo\t#(?P<loc_80641D6>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<min_alt_below_home>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #0x10\\]\n  cmp\tr0, r1\n  bhi\t#(?P<loc_80641D6>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<max_alt_above_home>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  bgt\t#(?P<loc_80641D6>[0-9a-fx]+)\n  ldrsh.w\tr0, \\[r4, #0x18\\]\n  cmn.w\tr0, #0xb4\n  blt\t#(?P<loc_80641D6>[0-9a-fx]+)\n  cmp\tr0, #0xb4\n  bgt\t#(?P<loc_80641D6>[0-9a-fx]+)\n  ldrsh.w\tr0, \\[r4, #0x1a\\]\n  cmn.w\tr0, #0x384 ; 900\n  blt\t#(?P<loc_80641D6>[0-9a-fx]+)\n  cmp\tr0, #0\n  bgt\t#(?P<loc_80641D6>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0x1c\\]\n  cmp\tr0, #2\n  blo\t#(?P<loc_80641E0>[0-9a-fx]+)\nloc_80641D6:\n  mov\tr1, r5\n  adr\tr0, #(?P<cstr_wp_data_val_fail>[0-9a-fx]+)\n  bl\t#(?P<flight_rec_printf_send_c0E>[0-9a-fx]+)\n  b\t#(?P<loc_806432E>[0-9a-fx]+)\n  ; block of code here, 35 words in P3X_FW_V01.07.0060\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){32,48})\n  vmov\tr0, s0\n  ldr\tr1, \\[pc, #(?P<max_wp_dist_to_home>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  ble\t#(?P<loc_806423A>[0-9a-fx]+)\n  mov\tr1, r5\n  adr\tr0, #(?P<cstr_wp_dist_too_large>[0-9a-fx]+)\n  bl\t#(?P<flight_rec_printf_send_c0E>[0-9a-fx]+)\n  movs\tr0, #0xe6\n  b\t#(?P<loc_806421C>[0-9a-fx]+)\nloc_806423A:\n  ldrb\tr0, \\[r7, #0xd\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_8064248>[0-9a-fx]+)\n  ldrb\tr0, \\[r7\\]\n  subs\tr0, r0, #1\n  cmp\tr0, r5\n  beq\t#(?P<loc_8064298>[0-9a-fx]+)\nloc_8064248:\n  ldrb\tr0, \\[r7, #0xf\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_8064298>[0-9a-fx]+)\n  vldr\ts1, \\[r4, #0x14\\]\n  ldr\tr1, \\[pc, #(?P<flt_minus_twentytwo_dot_four>[0-9a-fx]+)\\]\n  vmov\tr0, s1\n  add\tr0, r1\n  ldr\tr1, \\[pc, #(?P<flt_positive_epsylon>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  blo\t#(?P<loc_806426A>[0-9a-fx]+)\n  ; block of code here, 29 words in P3X_FW_V01.07.0060\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){24,40})\n  adds\tr5, r5, #1\n  uxtb\tr5, r5\nloc_806429C:\n  ldrb\tr0, \\[r7\\]\n  cmp\tr0, r5\n  bhi.w\t#(?P<loc_8064142>[0-9a-fx]+)\n  bl\t#(?P<sub_8064078>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<byte_200081F8>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<max_mission_path_len>[0-9a-fx]+)\\]\n  vstr\ts0, \\[r0, #0x2bc\\]\n  vmov\tr0, s0\n  cmp\tr0, r1\n  ble\t#(?P<loc_80642D2>[0-9a-fx]+)\n  vmov\tr0, s0\n  bl\t#(?P<calculate_cali_matrix>[0-9a-fx]+)\n  vmov\td0, r0, r1\n  ldr\tr0, \\[pc, #(?P<cstr_total_dis_too_long>[0-9a-fx]+)\\]\n  vmov\tr2, r3, d0\n  bl\t#(?P<flight_rec_printf_send_c0E>[0-9a-fx]+)\n  movs\tr0, #0xe2\n  b\t#(?P<loc_806421C>[0-9a-fx]+)\n; The function continues\n\n\"\"\",\n'vars': {\n  'wp_check_input_mission_validity':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'calculate_cali_matrix':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'flight_rec_printf_send_c0E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memcpy_0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8064078':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_808B480':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8086F86':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_80640E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8064122':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8064142':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_80641D6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_80641E0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806421C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806423A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8064248':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806426A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8064298':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806429C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806432E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806438A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_80642D2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (32,48)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (24,40)},\n  'byte_200084A4':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'byte_20005DF8':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'cstr_debug_log_l1h':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_wp_data_val_fail':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dbl_just_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'cstr_wp_dist_too_large':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'flt_minus_twentytwo_dot_four':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT},\n  'flt_positive_epsylon':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT},\n  'cstr_total_dis_too_long':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'byte_200081F8':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'max_alt_above_home':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"1.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"1000.0\",\n    'description': \"Max altitude relative to home point\"},\n  'min_alt_below_home':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"-1.0\", 'maxValue': \"-1000000.0\", 'defaultValue': \"-200.0\",\n    'description': \"Min altitude relative to home point\"},\n  'max_wp_dist_to_home':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"10.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"2000.0\",\n    'description': \"Max distance from one waypoint to home point\"},\n  'max_mission_path_len':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"10.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"30000.0\",\n    'description': \"Max total length of mission\"},\n  'loc_var_28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'loc_var_30':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n},\n}\n\nre_func_wp_check_input_mission_validity_WM330_V03_01_10_93 = {\n'name': \"wp_check_input_mission_validity\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nwp_check_input_mission_validity:\n  (push[.]w|push)\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), lr}\n  ldr\t(r0|r6), \\[pc, #(?P<unk_2042AD08>[0-9a-fx]+)\\]\n  movs\t(r5|r4), #0\n  ; this beginning comes from WM100 and WM220; it is different in WM330\n  ;movs\tr5, #0\n  ;ldr\tr6, \\[pc, #(?P<byte_20428D08>[0-9a-fx]+)\\]\n  ;ldrb.w\tr1, \\[r0, #(?P<rel_byte_2042B3B0>[0-9a-fx]+)\\]\n  ;ldrb\tr0, \\[r6\\]\n  ;cmp\tr1, r0\n  ;bne\t#(?P<loc_4ADCD0>[0-9a-fx]+)\n  ;add.w\tr0, r0, r0, lsl #1\n  ;movs\tr2, #0x60\n  ;add.w\tr0, r6, r0, lsl #5\n  ;adds\tr0, #0x40\n  ;add.w\tr1, r6, #0x40\n  ;bl\t#(?P<sub_4BEB10>[0-9a-fx]+)\n  ;b\t#(?P<loc_4ADECE>[0-9a-fx]+)\n  ; this beginning comes from wm220_0306_v03.02.13.12:\n  ;movs\tr4, #0\n  ;ldr\tr0, \\[pc, #0x180\\]\n  ;sub\tsp, #0x24\n  ;adds\tr6, #0x10\n  ;ldrb.w\tr0, \\[r0, #0x6ac\\]\n  ;ldrb\tr1, \\[r6\\]\n  ;cmp\tr0, r1\n  ;beq\t#0x4852b4\n  ;b\t#0x485688\n  ;add.w\tr0, r4, r4, lsl #1\n  ;add.w\tr0, r6, r0, lsl #5\n  ;vldr\ts0, \\[r0, #0x54\\]\n  ;vcvt.f64.f32\td0, s0\n  ;vstr\td0, \\[sp, #0x18\\]\n  ;vldr\ts0, \\[r0, #0x50\\]\n  ;vcvt.f64.f32\td0, s0\n  ;vstr\td0, \\[sp, #0x10\\]\n  ;vldr\td0, \\[r0, #0x48\\]\n  ;vstr\td0, \\[sp, #8\\]\n  ;vldr\td0, \\[r0, #0x40\\]\n  ;vstr\td0, \\[sp\\]\n  ;bl\t#0x4c3c4a\n  ;ldr\tr3, \\[r0, #0xc\\]\n  ;movs\tr0, #0x28\n  ;adr\tr1, #0x13c\n  ;mov\tr2, r4\n  ;blx\tr3\n  ;adds\tr4, r4, #1\n  ;uxtb\tr4, r4\n  ;ldrb\tr0, \\[r6\\]\n  ;cmp\tr0, r4\n  ;bhi\t#0x485272\n  ;uxtb\tr0, r0\n  ;ldr\tr1, \\[pc, #0x74\\]\n  ;movs\tr2, #0x60\n  ;add.w\tr0, r0, r0, lsl #1\n  ;adds\tr1, #0x50\n  ;add.w\tr0, r6, r0, lsl #5\n  ;adds\tr0, #0x40\n  ;bl\t#0x4c4076\n  ;movs\tr5, #0\n  ;b\t#0x485574\n  ; the beginning from WM330 looks like the longer one; not pasted here\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){12,64})\nloc_4ADBE8:\n  add.w\tr0, r5, r5, lsl #1\n  add.w\tr7, r6, r0, lsl #5\n  add.w\tr4, r7, #0x40\n  vldr\td0, \\[r7, #0x40\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi_half>[0-9a-fx]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  blo\t#(?P<loc_val_fail2>[0-9a-fx]+)\n  vldr\td1, \\[pc, #(?P<dbl_pi_half>[0-9a-fx]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  ; this comes from WM100 and newer WM220:\n  ;bgt\t#(?P<loc_val_fail2>[0-9a-fx]+)\n  ; in from wm220_0306_v03.02.13.12, there is a long block of data+code, not listed here\n  dcw\t(?P<undefined_varlen_5>([0-9a-fx]+[, ]*){1,196})\n  vldr\td0, \\[r4, #8\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi>[0-9a-fx]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  blo\t#(?P<loc_val_fail>[0-9a-fx]+)\n  vldr\td1, \\[pc, #(?P<dbl_just_pi>[0-9a-fx]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  bgt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<min_alt_below_home>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #0x10\\]\n  cmp\tr0, r2\n  bhi\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<max_alt_above_home>[0-9a-fx]+)\\]\n  cmp\tr0, r2\n  bgt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ldrsh.w\tr0, \\[r4, #0x18\\]\n  cmn.w\tr0, #0xb4\n  blt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  cmp\tr0, #0xb4\n  bgt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ldrsh.w\tr0, \\[r4, #0x1a\\]\n  cmn.w\tr0, #0x384 ; 900\n  blt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  cmp\tr0, #0\n  bgt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ; this comes from WM100 and WM220; it is different in WM330\n  ;ldrsh.w\tr0, \\[r4, #0x1e\\]\n  ;movw\tr2, #0x5dc ; 1500\n  ;cmn\tr0, r2\n  ;blt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ;cmp\tr0, r2\n  ;bgt\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ;ldrb.w\tr0, \\[r4, #0x20\\]\n  ;cmp\tr0, #3\n  ;bhs\t#(?P<loc_val_fail>[0-9a-fx]+)\n  ;ldrb\tr0, \\[r4, #0x1c\\]\n  ;cmp\tr0, #2\n  ;blo\t#(?P<loc_chk_contn1>[0-9a-fx]+)\n  ; the block from WM330 is shorter; not pasted here\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){3,20})\nloc_val_fail:\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #(?P<log_tag1>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_wp_data_val_fail>[0-9a-fx]+)\n  mov\tr2, r5\n  blx\tr3\n  ; this comes from WM100 and WM220; it is different in WM330\nloc_ret1:\n  ;pop[.]w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), pc}\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){1,48})\nloc_chk_contn2:\n  cmp\tr0, #1\n  bne\t#(?P<loc_4ADCEE>[0-9a-fx]+)\nloc_chk_contn3:\n  ldrb\tr1, \\[r6\\]\n  subs\tr1, r1, #1\n  cmp\tr1, r5\n  beq\t#(?P<loc_4ADD0E>[0-9a-fx]+)\nloc_4ADCEE:\n  vmov\tr1, s0\n  ldr\tr2, \\[pc, #(?P<max_wp_dist_to_home>[0-9a-fx]+)\\]\n  cmp\tr1, r2\n  ble\t#(?P<loc_4ADD0A>[0-9a-fx]+)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #(?P<log_tag2>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_wp_dist_too_large>[0-9a-fx]+)\n  mov\tr2, r5\n  blx\tr3\n  movs\tr0, #0xe6\n  b\t#(?P<loc_ret1>[0-9a-fx]+)\nloc_4ADD0A:\n  cmp\tr0, #1\n  bne\t#(?P<loc_4ADD16>[0-9a-fx]+)\nloc_4ADD0E:\n  ldrb\tr0, \\[r6\\]\n  subs\tr0, r0, #1\n  cmp\tr0, r5\n  beq\t#(?P<loc_4ADD36>[0-9a-fx]+)\nloc_4ADD16:\n  ldrb\tr0, \\[r6, #(?P<rel_byte_20428D17>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_4ADD36>[0-9a-fx]+)\n  vldr\ts1, \\[r4, #0x14\\]\n  ldr\tr1, \\[pc, #(?P<flt_minus_twentytwo_dot_four>[0-9a-fx]+)\\]\n  vmov\tr0, s1\n  add\tr0, r1\n  ldr\tr1, \\[pc, #(?P<flt_positive_epsylon>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  blo\t#(?P<loc_4ADD38>[0-9a-fx]+)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ; some code and a large data block comes here\n  ; in wm220_0306_v03.02.13.12, it is 30 words long; in newer version, much longer\n  dcw\t(?P<undefined_varlen_4>([0-9a-fx]+[, ]*){28,240})\n  adds\tr5, r5, #1\n  uxtb\tr5, r5\nloc_4ADECE:\n  ldrb\tr1, \\[r6\\]\n  cmp\tr1, r5\n  bhi.w\t#(?P<loc_4ADBE8>[0-9a-fx]+)\n  bl\t#(?P<sub_4AD984>[0-9a-fx]+)\n  ldr\tr4, \\[pc, #(?P<unk_2042B108>[0-9a-fx]+)\\]\n  vmov\tr0, s0\n  ldr\tr1, \\[pc, #(?P<max_mission_path_len>[0-9a-fx]+)\\]\n  vstr\ts0, \\[r4, #(?P<rel_unk_var01>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  ble\t#(?P<loc_4ADF06>[0-9a-fx]+)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  vldr\ts0, \\[r4, #(?P<rel_unk_var01>[0-9a-fx]+)\\]\n  ldr\tr5, \\[r0, #0xc\\]\n  movs\tr0, #(?P<log_tag3>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<cstr_total_dis_too_long>[0-9a-fx]+)\\]\n  vcvt.f64.f32\td0, s0\n  vmov\tr2, r3, d0\n  blx\tr5\n  movs\tr0, #0xe2\n  b\t#(?P<loc_ret1>[0-9a-fx]+)\nloc_4ADF06:\n  movs\tr4, #0\n  b\t#(?P<loc_4ADF30>[0-9a-fx]+)\n; The function continues\n\"\"\",\n'vars': {\n  'wp_check_input_mission_validity':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  #'sub_4BEB10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4AD984':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_val_fail2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_val_fail':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_chk_contn1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_4ADCD0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADCEE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADD0A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADD0E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADD16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADD36':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADD38':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_4ADECE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADBE8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADF06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4ADF30':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (12,64)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (3,20)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,48)},\n  'undefined_varlen_4':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (28,240)},\n  'undefined_varlen_5':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,196)},\n  'log_tag1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'log_tag2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'log_tag3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  #'byte_20428D08':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_2042AD08':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'cstr_wp_data_val_fail':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dbl_just_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'cstr_wp_dist_too_large':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'flt_minus_twentytwo_dot_four':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT},\n  'flt_positive_epsylon':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT},\n  'cstr_total_dis_too_long':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'unk_2042B108':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'max_alt_above_home':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"1.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"1000.0\",\n    'description': \"Max altitude relative to home point\"},\n  'min_alt_below_home':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"-1.0\", 'maxValue': \"-1000000.0\", 'defaultValue': \"-200.0\",\n    'description': \"Min altitude relative to home point\"},\n  'max_wp_dist_to_home':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"10.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"2000.0\",\n    'description': \"Max distance from one waypoint to home point\"},\n  'max_mission_path_len':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"10.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"30000.0\",\n    'description': \"Max total length of mission\"},\n  #'rel_byte_2042B3B0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20428D17':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_unk_var01':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n},\n}\n\nre_func_wp_mission_data_verify_P3X_V01_05_0030 = {\n'name': \"wp_mission_data_verify\",\n'version': \"P3X_FW_V01.05.0030\",\n're': \"\"\"\nwp_mission_data_verify:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,4}), lr}\n  ldr\tr4, \\[pc, #(?P<byte_20005DF8>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  vpush\t{d8}\n  sub\tsp, #0xc\n  ldrb\tr2, \\[r0\\], #7\n  strb\tr2, \\[r4\\]\n  ldr\tr2, \\[r0, #-0x6\\]\n  str\tr2, \\[r4, #(?P<rel_dword_20005DFC>[0-9a-fx]+)\\]\n  ldr\tr2, \\[r0, #-0x2\\]\n  str\tr2, \\[r4, #(?P<rel_dword_20005E00>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #2\\]\n  strb\tr2, \\[r4, #(?P<rel_byte_20005E04>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #3\\]\n  strb\tr2, \\[r4, #(?P<rel_byte_20005E05>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #4\\]\n  strb\tr2, \\[r4, #(?P<rel_byte_20005E06>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #5\\]\n  strb\tr2, \\[r4, #(?P<rel_byte_20005E07>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #6\\]\n  strb\tr2, \\[r4, #(?P<rel_byte_20005E08>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #7\\]\n  strb\tr2, \\[r4, #(?P<rel_byte_20005E09>[0-9a-fx]+)\\]\n  ldr\tr2, \\[r0, #8\\]\n  str\tr2, \\[sp\\]\n  ldr\tr2, \\[r0, #0xc\\]\n  str\tr2, \\[sp, #4\\]\n  vldr\td0, \\[sp\\]\n  vstr\td0, \\[r4, #0x18\\]\n  ldr\tr2, \\[r0, #0x10\\]\n  str\tr2, \\[sp\\]\n  ldr\tr2, \\[r0, #0x14\\]\n  str\tr2, \\[sp, #4\\]\n  vldr\td0, \\[sp\\]\n  vstr\td0, \\[r4, #0x20\\]\n  ldr\tr2, \\[r0, #0x18\\]\n  str\tr2, \\[r4, #(?P<rel_dword_20005E20>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0, #0x1c\\]\n  subs\tr0, r0, #7\n  strb.w\tr2, \\[r4, #(?P<rel_byte_20005E24>[0-9a-fx]+)\\]\nloc_80643F0:\n  adds\tr2, r0, r1\n  adds\tr3, r4, r1\n  adds\tr1, r1, #1\n  ldrb.w\tr2, \\[r2, #0x24\\]\n  uxtb\tr1, r1\n  strb.w\tr2, \\[r3, #(?P<rel_byte_20005E25>[0-9a-fx]+)\\]\n  cmp\tr1, #0xf\n  blo\t#(?P<loc_80643F0>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #(?P<rel_byte_20005E05>[0-9a-fx]+)\\]\n  movs\tr5, #1\n  cbnz\tr0, #(?P<loc_806440C>[0-9a-fx]+)\n  strb\tr5, \\[r4, #(?P<rel_byte_20005E05>[0-9a-fx]+)\\]\n  ; the code above isn't really important and can be replaced by variable size data when needed\nloc_806440C:\n  ldrb\tr0, \\[r4\\]\n  subs\tr0, r0, #2\n  cmp\tr0, #0x63\n  bhs\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<rel_dword_20005DFC>[0-9a-fx]+)\\]\n  cmp.w\tr0, #0x40000000 ; 2.0\n  blt\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<max_speed_pos>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  bgt\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<max_speed_neg>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #(?P<rel_dword_20005E00>[0-9a-fx]+)\\]\n  cmp\tr0, r2\n  bhi\t#(?P<loc_8064478>[0-9a-fx]+)\n  cmp\tr0, r1\n  bgt\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #(?P<rel_byte_20005E04>[0-9a-fx]+)\\]\n  cmp\tr0, #5\n  bhs\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #(?P<rel_byte_20005E06>[0-9a-fx]+)\\]\n  cmp\tr0, #5\n  bhs\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #(?P<rel_byte_20005E07>[0-9a-fx]+)\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #(?P<rel_byte_20005E08>[0-9a-fx]+)\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_8064478>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #(?P<rel_byte_20005E09>[0-9a-fx]+)\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_8064478>[0-9a-fx]+)\n  vldr\td0, \\[r4, #0x18\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi_half>[0-9a-fx-]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_808B480>[0-9a-fx]+)\n  blo\t#(?P<loc_8064478>[0-9a-fx]+)\n  vldr\td0, \\[r4, #0x18\\]\n  vldr\td1, \\[pc, #(?P<dbl_pi_half>[0-9a-fx-]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  ; block of code, 187 words in P3X_FW_V01.07.0060 starting with:\n  ;bl\t#(?P<sub_8086F86>[0-9a-fx]+)\n  ; block of code, 189 words in P3X_FW_V01.10.0090 starting with:\n  ;b\t#0x8064a10\n  ;b\t#0x8064a6e\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){176,200})\n  vldr\td0, \\[r4, #0x20\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi>[0-9a-fx-]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_808B480>[0-9a-fx]+)\n  blo\t#(?P<loc_8064642>[0-9a-fx]+)\n  vldr\td0, \\[r4, #0x20\\]\n  vldr\td1, \\[pc, #(?P<dbl_just_pi>[0-9a-fx-]+)\\]\n  vmov\tr0, r1, d0\n  vmov\tr2, r3, d1\n  bl\t#(?P<sub_8086F86>[0-9a-fx]+)\n  blo\t#(?P<loc_8064642>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<min_alt_below_home_inst2>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #(?P<rel_dword_20005E20>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  bhi\t#(?P<loc_8064642>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<max_alt_above_home_inst2>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  bgt\t#(?P<loc_8064642>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #(?P<rel_byte_20005E24>[0-9a-fx]+)\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_8064642>[0-9a-fx]+)\n  vldr\ts0, \\[r4, #8\\]\n  vldr\ts1, \\[r4, #4\\]\n  vabs.f32\ts0, s0\n  vcmpe.f32\ts0, s1\n  vmrs\tapsr_nzcv, fpscr\n  ble\t#(?P<loc_8064652>[0-9a-fx]+)\nloc_8064642:\n  adr\tr0, #(?P<cstr_mission_info_data_invalid>[0-9a-fx]+)\n  bl\t#(?P<flight_rec_printf_send_c0E>[0-9a-fx]+)\n  movs\tr0, #0xe0\n; The function continues\n\"\"\",\n'vars': {\n  'wp_mission_data_verify':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_8064478':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_80643F0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_806440C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8064642':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8064652':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'sub_808B480':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8086F86':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'flight_rec_printf_send_c0E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (176,200)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20005DFC':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20005E00':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E04':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E05':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E06':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E07':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E08':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E09':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20005E20':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E24':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20005E25':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'byte_20005DF8':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'dbl_minus_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'cstr_mission_info_data_invalid':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dbl_just_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'max_speed_pos':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"1.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"15.0\",\n    'description': \"Max speed (positive value); in meters per second [m/s]\"},\n  'max_speed_neg':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"-1.0\", 'maxValue': \"-1000000.0\", 'defaultValue': \"-15.0\",\n    'description': \"Max speed (negative value); in meters per second [m/s]\"},\n  'max_alt_above_home_inst2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'depend': \"max_alt_above_home\", 'getter': (lambda val: val)},\n  'min_alt_below_home_inst2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'depend': \"min_alt_below_home\", 'getter': (lambda val: val)},\n},\n}\n\nre_func_wp_mission_data_verify_WM330_V03_01_10_93 = {\n'name': \"wp_mission_data_verify\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nwp_mission_data_verify:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,4}), lr}\n  ldr\tr4, \\[pc, #(?P<byte_20428D08>[0-9a-fx]+)\\]\n  ; block of code, 51 words in wm220_0306_v03.02.35.05\n  ; block of code, 42 words in wm330_0306_v03.01.10.93\n  ; below code example is from WM100\n  ;sub\tsp, #0x1c\n  ;ldrb\tr1, \\[r0\\]\n  ;movs\tr3, #0\n  ;strb\tr1, \\[r4\\]\n  ;ldr.w\tr1, \\[r0, #1\\]\n  ;str\tr1, \\[r4, #4\\]\n  ;ldr.w\tr1, \\[r0, #5\\]\n  ;str\tr1, \\[r4, #8\\]\n  ;ldrb\tr1, \\[r0, #9\\]\n  ;strb\tr1, \\[r4, #0xc\\]\n  ;ldrb\tr1, \\[r0, #0xa\\]\n  ;strb\tr1, \\[r4, #0xd\\]\n  ;ldrb\tr1, \\[r0, #0xb\\]\n  ;strb\tr1, \\[r4, #0xe\\]\n  ;ldrb\tr1, \\[r0, #0xc\\]\n  ;strb\tr1, \\[r4, #0xf\\]\n  ;ldrb\tr1, \\[r0, #0xd\\]\n  ;strb\tr1, \\[r4, #0x10\\]\n  ;ldrb\tr1, \\[r0, #0xe\\]\n  ;strb\tr1, \\[r4, #0x11\\]\n  ;ldr.w\tr2, \\[r0, #0x13\\]\n  ;ldr.w\tr1, \\[r0, #0xf\\]\n  ;strd\tr1, r2, \\[r4, #0x18\\]\n  ;ldr.w\tr2, \\[r0, #0x1b\\]\n  ;ldr.w\tr1, \\[r0, #0x17\\]\n  ;strd\tr1, r2, \\[r4, #0x20\\]\n  ;ldr.w\tr1, \\[r0, #0x1f\\]\n  ;str\tr1, \\[r4, #0x28\\]\n  ;ldrb.w\tr1, \\[r0, #0x23\\]\n  ;strb.w\tr1, \\[r4, #0x2c\\]\n  ;ldrb.w\tr1, \\[r0, #0x24\\]\n  ;strb.w\tr1, \\[r4, #0x2d\\]\n  ;ldrh.w\tr1, \\[r0, #0x25\\]\n  ;strh\tr1, \\[r4, #0x2e\\]\n  ;ldrh.w\tr1, \\[r0, #0x27\\]\n  ;strh\tr1, \\[r4, #0x30\\]\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){40,64})\nloc_4AE050:\n  adds\tr1, r0, r3\n  adds\tr2, r4, r3\n  adds\tr3, r3, #1\n  ldrb.w\tr1, \\[r1, #(?P<rel_unkn_val1>[0-9a-fx]+)\\]\n  uxtb\tr3, r3\n  cmp\tr3, #(?P<var_loop_limit1>[0-9a-fx]+) ; 0xa or 0xf\n  strb.w\tr1, \\[r2, #(?P<rel_unkn_val2>[0-9a-fx]+)\\]\n  blo\t#(?P<loc_4AE050>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0xd\\]\n  movs\t(r2|r1), #1\n  cbnz\tr0, #(?P<loc_4AE06C>[0-9a-fx]+)\n  strb\t(r2|r1), \\[r4, #0xd\\]\nloc_4AE06C:\n  ldrb\tr0, \\[r4\\]\n  subs\tr0, r0, #2\n  cmp\tr0, #0x63\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vldr\ts5, \\[r4, #4\\]\n  vmov\tr0, s5\n  cmp.w\tr0, #0x40000000 ; 2.0\n  blt\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vmov\tr0, s5\n  ldr\tr[12], \\[pc, #(?P<max_speed_pos>[0-9a-fx]+)\\]\n  cmp\tr0, r[12]\n  bgt\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vldr\ts4, \\[r4, #8\\]\n  ldr\tr3, \\[pc, #(?P<max_speed_neg>[0-9a-fx]+)\\]\n  vmov\tr0, s4\n  cmp\tr0, r3\n  bhi\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vmov\tr0, s4\n  cmp\tr0, r[12] ; either r1 or r2 is used\n  bgt\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0xc\\]\n  cmp\tr0, #(?P<max_unkn1_val>[0-9a-fx]+)\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0xe\\]\n  cmp\tr0, #(?P<max_unkn2_val>[0-9a-fx]+)\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0xf\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0x10\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #0x11\\]\n  cmp\tr0, #[32]\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vldr\td0, \\[r4, #0x18\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi_half>[0-9a-fx-]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  blo\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vldr\td1, \\[pc, #(?P<dbl_pi_half>[0-9a-fx-]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  bgt\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vldr\td0, \\[r4, #0x20\\]\n  vldr\td1, \\[pc, #(?P<dbl_minus_pi>[0-9a-fx-]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  blo\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vldr\td1, \\[pc, #(?P<dbl_just_pi>[0-9a-fx-]+)\\]\n  vcmpe.f64\td0, d1\n  vmrs\tapsr_nzcv, fpscr\n  bgt\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldr\tr[12], \\[pc, #(?P<min_alt_below_home_inst2>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #0x28\\]\n  cmp\tr0, r[12]\n  bhi\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldr\tr[12], \\[pc, #(?P<max_alt_above_home_inst2>[0-9a-fx]+)\\]\n  cmp\tr0, r[12]\n  bgt\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #0x2c\\]\n  cmp\tr0, #2\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n\"\"\",\n're_after': \"\"\" ; this code matches WM100 and WM220, but not WM330\n  ldrb.w\tr0, \\[r4, #0x2d\\]\n  cmp\tr0, #3\n  bhs\t#(?P<loc_4AE12C>[0-9a-fx]+)\n  vabs.f32\ts0, s4\n  vcmpe.f32\ts0, s5\n  vmrs\tapsr_nzcv, fpscr\n  ble\t#(?P<loc_4AE13E>[0-9a-fx]+)\nloc_4AE12C:\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr2, \\[r0, #0xc\\]\n  movs\tr0, #0x28\n; The function continues\n\"\"\",\n'vars': {\n  'wp_mission_data_verify':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_4AE050':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4AE06C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4AE12C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_4AE13E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (40,64)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'byte_20428D08':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_unkn_val1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_unkn_val2':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  #'rel_byte_2042B3B0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'var_loop_limit1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'max_unkn1_val':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'max_unkn2_val':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'dbl_just_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_minus_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'dbl_pi_half':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.DOUBLE},\n  'max_speed_pos':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"1.0\", 'maxValue': \"1000000.0\", 'defaultValue': \"15.0\",\n    'description': \"Max speed (positive value); in meters per second [m/s]\"},\n  'max_speed_neg':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"-1.0\", 'maxValue': \"-1000000.0\", 'defaultValue': \"-15.0\",\n    'description': \"Max speed (negative value); in meters per second [m/s]\"},\n  'max_alt_above_home_inst2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'depend': \"max_alt_above_home\", 'getter': (lambda val: val)},\n  'min_alt_below_home_inst2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.FLOAT,\n    'public': \"og_hardcoded.flyc\", 'depend': \"min_alt_below_home\", 'getter': (lambda val: val)},\n},\n}\n\n\nre_func_firmware_release_marking_WM330_V03_01_10_93 = {\n'name': \"firmware_release_marking\",\n'version': \"wm330_0306_v03.01.10.93\",\n# if multiple copies of the pattern are found, make public vars from subsequent ones depend on first\n'multiple': \"depend\",\n're': \"\"\"\n  dcb\t(?P<starter_odd_even>([0-9a-fx]+[, ]*){2,3})\n  dcb\t\"SDK-v(?P<sdk_version>[1-2][.][0-9]) BETA\"\n  dcb\t\" (?P<product_code>[A-Z][A-Z]?[0-9][0-9][0-9])-\"\n  dcb\t\"(?P<firmware_version>[0-9][0-9][.][0-9][0-9][.][0-9][0-9][.][0-9][0-9])\"\n\"\"\",\n'vars': {\n  'starter_odd_even':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T, 'array': (2,3)},\n  'sdk_version':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.CHAR, 'array': 3},\n  'product_code':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.CHAR, 'array': (4,5)},\n  'firmware_version':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.CHAR, 'array': 11,\n    'public': \"og_hardcoded.flyc\", 'minValue': \"00.00.00.00\", 'maxValue': \"99.99.99.99\",\n    'description': \"Firmware version number\"},\n},\n}\n\n\nre_func_check_activation_authority_WM220_V03_02_13_12 = {\n'name': \"check_activation_authority\",\n# No public properties - only here to avoid 'not found' warnings\n'version': \"wm220_0306_v03.02.13.12\",\n're': \"\"\"\ncheck_activation_authority:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){5,8}), lr}\n  movs\tr4, r0\n  beq\t#(?P<loc_510806>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #0x1b4\\]\n  ldrb.w\tr0, \\[r0, #0x90f\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_51080C>[0-9a-fx]+)\n  b\t#(?P<loc_510828>[0-9a-fx]+)\nloc_510806:\n  movs\tr0, #1\nlocret_510808:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){5,8}), pc}\nloc_51080C:\n  ldr\tr0, \\[r4\\]\n  sub.w\tr1, r0, #0x2700\n  subs\tr1, #0x66\n  beq\t#(?P<loc_5108A2>[0-9a-fx]+)\nloc_510844:\n  ldr\tr0, \\[r4\\]\n  bl\t#(?P<sub_51078E>[0-9a-fx]+)\n  ldr.w\tr8, \\[pc, #(?P<unkval_4350>[0-9a-fx]+)\\]\n  movs\tr6, #0\n  cmp\tr0, #2\n  mov\tr5, r0\n  bhs\t#(?P<loc_5108B4>[0-9a-fx]+)\n  str\tr5, \\[sp\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr7, \\[r0, #0xc\\]\n  add.w\tr1, r5, r5, lsl #2\n  ldr\tr0, \\[pc, #(?P<dword_20430DD0>[0-9a-fx]+)\\]\n  ldr\tr2, \\[r4, #4\\]\n  add.w\tr5, r0, r1, lsl #3\n  movs\tr0, #8\n  adr\tr1, #(?P<cstr_req_real>[0-9a-fx]+)\n  ldr\tr3, \\[r5, #4\\]\n  blx\tr7\n  strh.w\tr6, \\[r8\\]\n  str.w\tr6, \\[r8, #(?P<rel_dword_20404370>[0-9a-fx]+)\\]\n  str.w\tr6, \\[r8, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #4\\]\n  ldr\tr1, \\[r5, #4\\]\n  cmp\tr0, r1\n  bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  add.w\tr0, r5, #8\n  mov\tr4, r0\n  bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #8\n  adr\tr1, #(?P<cstr_dji_sdk_set_key_val>[0-9a-fx]+)\n  mov\tr2, r4\n  blx\tr3\nloc_51089E:\n  movs\tr0, #0\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108A2:\n  ldr\tr0, \\[r4, #4\\]\n  cmp\tr0, #2\n  bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_dji_demo_lala_haha>[0-9a-fx]+)\n  bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  b\t#(?P<loc_51089E>[0-9a-fx]+)\nloc_5108B0:\n  movs\tr0, #7\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108B4:\n  ldr\tr0, \\[r4\\]\n  mov\tr5, r8\n  ldr.w\tr1, \\[r8, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_5108C8>[0-9a-fx]+)\n  str\tr0, \\[r5, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #4\\]\n  str\tr0, \\[r5, #(?P<rel_dword_20404374>[0-9a-fx]+)\\]\n  strh\tr6, \\[r5\\]\nloc_5108C8:\n  ldrh\tr0, \\[r5\\]\n  adds\tr0, r0, #1\n  strh\tr0, \\[r5\\]\n  mov\tr0, r4\n  bl\t#(?P<sub_4DFB70>[0-9a-fx]+)\n  ldrh\tr1, \\[r5\\]\n  ldr\tr0, \\[pc, #(?P<unkval_9DE8>[0-9a-fx]+)\\]\n  cmp\tr1, #0xa\n  bhs\t#(?P<loc_5108E2>[0-9a-fx]+)\nloc_5108DC:\n  mov.w\tr0, #3\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108E2:\n  ldr.w\tr0, \\[r0, #(?P<rel_ctrl_tick>[0-9a-fx]+)\\]\n  bne\t#(?P<loc_5108EC>[0-9a-fx]+)\n  str\tr0, \\[r5, #(?P<rel_dword_20404378>[0-9a-fx]+)\\]\n  b\t#(?P<loc_5108FC>[0-9a-fx]+)\nloc_5108EC:\n  ldr\tr1, \\[r5, #(?P<rel_dword_20404378>[0-9a-fx]+)\\]\n  sub.w\tr0, r0, r1\n  cmp.w\tr0, #0x1f4 ; #500\n  bls\t#(?P<loc_5108FC>[0-9a-fx]+)\n  strh\tr6, \\[r5\\]\n  b\t#(?P<loc_5108DC>[0-9a-fx]+)\nloc_5108FC:\n  ldr\tr0, \\[r5, #(?P<rel_dword_20404370>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_510908>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_51090C>[0-9a-fx]+)\n  movs\tr0, #6\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_510908:\n  movs\tr0, #5\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_51090C:\n  movs\tr0, #4\n  b\t#(?P<locret_510808>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'check_activation_authority':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'dji_sdk_set_key':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4DFB70':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_51078E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_510806':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51080C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510828':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51089E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108A2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108B4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108C8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108DC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108EC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108FC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510908':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51090C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'locret_510808':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'cstr_dji_demo_lala_haha':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_dji_sdk_set_key_val':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_req_real':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dword_20430DD0':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'rel_ctrl_tick':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_2040436C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404370':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404374':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404378':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_word_20404352':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'unkval_4350':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkval_9DE8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n},\n}\n\nre_func_check_activation_authority_WM220_V03_01_10_93 = {\n'name': \"check_activation_authority\",\n'version': \"wm220_0306_v03.01.10.93\",\n're': \"\"\"\ncheck_activation_authority:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,8}), lr}\n  movs\tr4, r0\n  beq\t#(?P<loc_510806>[0-9a-fx]+)\n  bl\t#(?P<get_config>[0-9a-fx]+)\n  ldr\tr1, \\[r0, #0xc\\]\n  movs\tr0, #(?P<CONFIG_VAR_37a>[0-9a-fx]+)\n  blx\tr1\n  ldrb.w\tr0, \\[r0, #0x26\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_51080C>[0-9a-fx]+)\n  b\t#(?P<loc_510828>[0-9a-fx]+)\nloc_510806:\n  movs\tr0, #1\nlocret_510808:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,8}), pc}\nloc_51080C:\n  ldr\tr6, \\[pc, #(?P<mc_version_1>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #8\\]\n  cmp\tr0, r6\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;beq\t#(?P<loc_510828>[0-9a-fx]+)\n  ; block of code, in wm100_0306_v03.02.43.20:\n  ;beq\t#(?P<loc_510828>[0-9a-fx]+)\n  ;cmp.w   r0, #0x50505050\n  ;beq\t#(?P<loc_510828>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,8})\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr5, \\[r0, #4\\]\n  movs\tr0, #8\n  adr\tr1, #(?P<cstr_sdk_version_error>[0-9a-fx]+)\n  ldr\tr2, \\[r4, #8\\]\n  mov\tr3, r6\n  blx\tr5\n  movs\tr0, #8\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_510828:\n  bl\t#(?P<get_config>[0-9a-fx]+)\n  ldr\tr1, \\[r0, #0xc\\]\n  movs\tr0, #(?P<CONFIG_VAR_37b>[0-9a-fx]+)\n  blx\tr1\n  ldrb.w\tr0, \\[r0, #0x23\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_510844>[0-9a-fx]+)\n  ldr\tr0, \\[r4\\]\n  sub.w\tr1, r0, #0x2700\n  subs\tr1, #0x66\n  beq\t#(?P<loc_5108A2>[0-9a-fx]+)\nloc_510844:\n  ldr\tr0, \\[r4\\]\n  bl\t#(?P<sub_51078E>[0-9a-fx]+)\n  ldr.w\tr8, \\[pc, #(?P<unkval_4350>[0-9a-fx]+)\\]\n  movs\tr6, #0\n  cmp\tr0, #2\n  mov\tr5, r0\n  bhs\t#(?P<loc_5108B4>[0-9a-fx]+)\n  str\tr5, \\[sp\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr7, \\[r0, #0xc\\]\n  add.w\tr1, r5, r5, lsl #2\n  ldr\tr0, \\[pc, #(?P<dword_20430DD0>[0-9a-fx]+)\\]\n  ldr\tr2, \\[r4, #4\\]\n  add.w\tr5, r0, r1, lsl #3\n  movs\tr0, #8\n  adr\tr1, #(?P<cstr_req_real>[0-9a-fx]+)\n  ldr\tr3, \\[r5, #4\\]\n  blx\tr7\n  strh.w\tr6, \\[r8, #(?P<rel_word_20404352>[0-9a-fx]+)\\]\n  str.w\tr6, \\[r8, #(?P<rel_dword_20404370>[0-9a-fx]+)\\]\n  str.w\tr6, \\[r8, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #4\\]\n  ldr\tr1, \\[r5, #4\\]\n  cmp\tr0, r1\n  bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  add.w\tr0, r5, #8\n  mov\tr4, r0\n  bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #8\n  adr\tr1, #(?P<cstr_dji_sdk_set_key_val>[0-9a-fx]+)\n  mov\tr2, r4\n  blx\tr3\nloc_51089E:\n  movs\tr0, #0\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108A2:\n  ldr\tr0, \\[r4, #4\\]\n  cmp\tr0, #2\n  bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_dji_demo_lala_haha>[0-9a-fx]+)\n  bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  b\t#(?P<loc_51089E>[0-9a-fx]+)\nloc_5108B0:\n  movs\tr0, #7\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108B4:\n  ldr\tr0, \\[r4\\]\n  mov\tr5, r8\n  ldr.w\tr1, \\[r8, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_5108C8>[0-9a-fx]+)\n  str\tr0, \\[r5, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #4\\]\n  str\tr0, \\[r5, #(?P<rel_dword_20404374>[0-9a-fx]+)\\]\n  strh\tr6, \\[r5, #(?P<rel_word_20404352>[0-9a-fx]+)\\]\nloc_5108C8:\n  ldrh\tr0, \\[r5, #(?P<rel_word_20404352>[0-9a-fx]+)\\]\n  adds\tr0, r0, #1\n  strh\tr0, \\[r5, #(?P<rel_word_20404352>[0-9a-fx]+)\\]\n  mov\tr0, r4\n  bl\t#(?P<sub_4DFB70>[0-9a-fx]+)\n  ldrh\tr1, \\[r5, #(?P<rel_word_20404352>[0-9a-fx]+)\\]\n  ldr\tr0, \\[pc, #(?P<unkval_9DE8>[0-9a-fx]+)\\]\n  cmp\tr1, #0xa\n  bhs\t#(?P<loc_5108E2>[0-9a-fx]+)\nloc_5108DC:\n  mov.w\tr0, #3\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108E2:\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;ldr.w\tr0, \\[r0, #(?P<rel_ctrl_tick>[0-9a-fx]+)\\]\n  ; block of code and data, in wm100_0306_v03.02.43.20:\n  ;b\t#(?P<loc_5108E8>[0-9a-fx]+)\n  ;[...] - block of data here\n  ;loc_5108E8:\n  ;ldr.w\tr0, \\[r0, #(?P<rel_ctrl_tick>[0-9a-fx]+)\\]\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,204})\n  bne\t#(?P<loc_5108EC>[0-9a-fx]+)\n  str\tr0, \\[r5, #(?P<rel_dword_20404378>[0-9a-fx]+)\\]\n  b\t#(?P<loc_5108FC>[0-9a-fx]+)\nloc_5108EC:\n  ldr\tr1, \\[r5, #(?P<rel_dword_20404378>[0-9a-fx]+)\\]\n  sub.w\tr0, r0, r1\n  cmp.w\tr0, #0x1f4 ; #500\n  bls\t#(?P<loc_5108FC>[0-9a-fx]+)\n  strh\tr6, \\[r5, #2\\]\n  b\t#(?P<loc_5108DC>[0-9a-fx]+)\nloc_5108FC:\n  ldr\tr0, \\[r5, #(?P<rel_dword_20404370>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_510908>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_51090C>[0-9a-fx]+)\n  movs\tr0, #6\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_510908:\n  movs\tr0, #5\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_51090C:\n  movs\tr0, #4\n  b\t#(?P<locret_510808>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'check_activation_authority':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'dji_sdk_set_key':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_config':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4DFB70':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_51078E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_510806':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51080C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510828':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510844':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51089E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108A2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108B4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108C8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108DC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108EC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108FC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510908':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51090C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'locret_510808':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,204)},\n  'CONFIG_VAR_37a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T},\n  'CONFIG_VAR_37b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T},\n  'cstr_dji_demo_lala_haha':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_dji_sdk_set_key_val':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_req_real':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_sdk_version_error':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dword_20430DD0':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'rel_ctrl_tick':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_2040436C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404370':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404374':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404378':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_word_20404352':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'unkval_4350':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkval_9DE8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'mc_version_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\nre_func_check_activation_authority_WM330_V03_01_10_93 = {\n'name': \"check_activation_authority\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\ncheck_activation_authority:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){5,8}), lr}\n  movs\tr4, r0\n  beq\t#(?P<loc_510806>[0-9a-fx]+)\n  ldr\t(?P<regB>r[0-9]), \\[pc, #(?P<mc_version_1>[0-9a-fx]+)\\]\n  ldr\t(?P<regC>r[0-9]), \\[r4, #8\\]\n  cmp\t(?P<regC>r[0-9]), (?P<regB>r[0-9])\n  beq\t#(?P<loc_510828>[0-9a-fx]+)\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;movs\tr0, #8\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;movs\tr0, #0x70\n  ;adr\tr1, #(?P<cstr_sdk_version_error>[0-9a-fx]+)\n  ;bl\t#(?P<log_printf_debug>[0-9a-fx]+)\n  ;movs\tr0, #8\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,8})\nlocret_510808:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){5,8}), pc}\nloc_510806:\n  movs\tr0, #1\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_510828:\n  ldr\tr0, \\[pc, #(?P<g_real__aircraft_status>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_g_real__config__api_entry_cfg__cheat_backdoor>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_510844>[0-9a-fx]+)\n  ldr\tr0, \\[r4\\]\n  sub.w\tr1, r0, #0x2700\n  subs\tr1, #0x66\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;bne\t#(?P<loc_510844>[0-9a-fx]+)\n  ;ldr\tr0, \\[r4, #4\\]\n  ;cmp\tr0, #2\n  ;bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  ;adr\tr0, #(?P<cstr_dji_demo_lala_haha>[0-9a-fx]+)\n  ;bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  ;b\t#(?P<loc_51089E>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;beq\t#(?P<loc_5108A2>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,12})\nloc_510844:\n  ldr\tr0, \\[r4\\]\n  bl\t#(?P<sub_51078E>[0-9a-fx]+)\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;movs\tr5, #0\n  ;ldr\tr7, \\[pc, #(?P<unkval_4350>[0-9a-fx]+)\\]\n  ;mov\tr3, r0\n  ;cmp\tr0, #2\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;ldr\tr7, \\[pc, #(?P<unkval_4350>[0-9a-fx]+)\\]\n  ;movs\tr5, #0\n  ;cmp\tr0, #2\n  ;mov\tr3, r0\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){1,6})\n  bhs\t#(?P<loc_5108B4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_20430DD0>[0-9a-fx]+)\\]\n  add.w\tr1, r3, r3, lsl #2\n  add.w\tr6, r0, r1, lsl #3\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;adr\tr0, #(?P<cstr_req_real>[0-9a-fx]+)\n  ;ldr\tr2, \\[r6, #4\\]\n  ;ldr\tr1, \\[r4, #4\\]\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;ldr\tr1, \\[r4, #4\\]\n  ;adr\tr0, #(?P<cstr_req_real>[0-9a-fx]+)\n  ;ldr\tr2, \\[r6, #4\\]\n  dcw\t(?P<undefined_varlen_4>([0-9a-fx]+[, ]*){3,4})\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  strh\tr5, \\[r7\\]\n  str\tr5, \\[r7, #(?P<rel_dword_20404370>[0-9a-fx]+)\\]\n  str\tr5, \\[r7, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #4\\]\n  ldr\tr1, \\[r6, #4\\]\n  cmp\tr0, r1\n  bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  add.w\tr0, r6, #8\n  mov\tr4, r0\n  bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;mov\tr1, r4\n  ;adr\tr0, #(?P<cstr_dji_sdk_set_key_val>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;adr\tr0, #(?P<cstr_dji_sdk_set_key_val>[0-9a-fx]+)\n  ;mov\tr1, r4\n  dcw\t(?P<undefined_varlen_5>([0-9a-fx]+[, ]*){2,4})\n  bl\t#(?P<log_printf>[0-9a-fx]+)\nloc_51089E:\n  movs\tr0, #0\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;b\t#(?P<locret_510808>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;b\t#(?P<locret_510808>[0-9a-fx]+)\n  ;loc_5108A2:\n  ;ldr\tr0, \\[r4, #4\\]\n  ;cmp\tr0, #2\n  ;bhi\t#(?P<loc_5108B0>[0-9a-fx]+)\n  ;adr\tr0, #(?P<cstr_dji_demo_lala_haha>[0-9a-fx]+)\n  ;bl\t#(?P<dji_sdk_set_key>[0-9a-fx]+)\n  ;b\t#(?P<loc_51089E>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_6>([0-9a-fx]+[, ]*){1,16})\nloc_5108B0:\n  movs\tr0, #7\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108B4:\n  ldr\tr0, \\[r4\\]\n  ldr\tr1, \\[r7, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_5108C8>[0-9a-fx]+)\n  str\tr0, \\[r7, #(?P<rel_dword_2040436C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r4, #4\\]\n  str\tr0, \\[r7, #(?P<rel_dword_20404374>[0-9a-fx]+)\\]\n  strh\tr5, \\[r7\\]\nloc_5108C8:\n  ldrh\tr0, \\[r7\\]\n  adds\tr0, r0, #1\n  strh\tr0, \\[r7\\]\n  mov\tr0, r4\n  bl\t#(?P<sub_4DFB70>[0-9a-fx]+)\n  ldrh\tr1, \\[r7\\]\n  ldr\tr0, \\[pc, #(?P<unkval_9DE8>[0-9a-fx]+)\\]\n  cmp\tr1, #0xa\n  bhs\t#(?P<loc_5108E2>[0-9a-fx]+)\nloc_5108DC:\n  mov.w\tr0, #3\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_5108E2:\n  ; block of code, in P3X_FW_V01.07.0060_m0306:\n  ;ldr\tr0, \\[r0\\]\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;ldr.w\tr0, \\[r0, #(?P<rel_ctrl_tick>[0-9a-fx]+)\\]\n  dcw\t(?P<undefined_varlen_7>([0-9a-fx]+[, ]*){1,204})\n  bne\t#(?P<loc_5108EC>[0-9a-fx]+)\n  str\tr0, \\[r7, #(?P<rel_dword_20404378>[0-9a-fx]+)\\]\n  b\t#(?P<loc_5108FC>[0-9a-fx]+)\nloc_5108EC:\n  ldr\tr1, \\[r7, #(?P<rel_dword_20404378>[0-9a-fx]+)\\]\n  sub.w\tr0, r0, r1\n  cmp.w\tr0, #0x1f4 ; #500\n  bls\t#(?P<loc_5108FC>[0-9a-fx]+)\n  strh\tr5, \\[r7\\]\n  b\t#(?P<loc_5108DC>[0-9a-fx]+)\nloc_5108FC:\n  ldr\tr0, \\[r7, #(?P<rel_dword_20404370>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_510908>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_51090C>[0-9a-fx]+)\n  movs\tr0, #6\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_510908:\n  movs\tr0, #5\n  b\t#(?P<locret_510808>[0-9a-fx]+)\nloc_51090C:\n  movs\tr0, #4\n  b\t#(?P<locret_510808>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'check_activation_authority':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'dji_sdk_set_key':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'log_printf_debug':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'log_printf':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4DFB70':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_51078E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_510806':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510828':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510844':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51089E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108A2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108B4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108C8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108DC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108EC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5108FC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_510908':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_51090C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'locret_510808':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,12)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,6)},\n  'undefined_varlen_4':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (3,4)},\n  'undefined_varlen_5':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,4)},\n  'undefined_varlen_6':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,16)},\n  'undefined_varlen_7':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,204)},\n  #'CONFIG_VAR_37a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T},\n  #'CONFIG_VAR_37b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T},\n  'cstr_dji_demo_lala_haha':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_dji_sdk_set_key_val':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_req_real':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_sdk_version_error':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dword_20430DD0':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'g_real__aircraft_status':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'rel_g_real__config__api_entry_cfg__cheat_backdoor':\t{'type': VarType.RELATIVE_OFFSET, 'baseaddr': \"g_real__aircraft_status+\", 'variety': DataVariety.UNKNOWN},\n  #'rel_ctrl_tick':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_2040436C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404370':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404374':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20404378':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'unkval_4350':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkval_9DE8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'mc_version_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\n\nre_func_system_init_P3X_FW_V01_07_0060 = {\n'name': \"system_init\",\n'alt_name': \"imu_init\",\n'version': \"P3X_FW_V01.07.0060\",\n're': \"\"\"\nsystem_init:\n  push\t{r4, lr}\n  bl\t#(?P<hal_push_mc_version>[0-9a-fx]+)\n  bl\t#(?P<init_sub_7E88>[0-9a-fx]+)\n  bl\t#(?P<init_sub_CB9A>[0-9a-fx]+)\n  bl\t#(?P<init_sub_185C>[0-9a-fx]+)\n  bl\t#(?P<init_sub_61CA>[0-9a-fx]+)\n  bl\t#(?P<init_led>[0-9a-fx]+)\n  bl\t#(?P<init_fitler>[0-9a-fx]+)\n  bl\t#(?P<init_sub_CC58>[0-9a-fx]+)\n  bl\t#(?P<init_sub_17C4>[0-9a-fx]+)\n  bl\t#(?P<init_sub_142A>[0-9a-fx]+)\n  bl\t#(?P<init_sub_2E3E>[0-9a-fx]+)\n  bl\t#(?P<init_sub_9580>[0-9a-fx]+)\n  bl\t#(?P<request_esc_real_states>[0-9a-fx]+)\n  bl\t#(?P<init_temp_cali>[0-9a-fx]+)\n  bl\t#(?P<init_sub_FE48>[0-9a-fx]+)\n  pop.w\t{r4, lr}\n  b.w\t#(?P<init_sub_2052>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'system_init':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_push_mc_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_7E88':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_CB9A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_185C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_61CA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_led':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_fitler':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_CC58':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_17C4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_142A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_2E3E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_9580':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'request_esc_real_states':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_temp_cali':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_FE48':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'init_sub_2052':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n},\n}\n\nre_func_imu_init_WM220_V03_01_10_93 = {\n'name': \"imu_init\",\n'alt_name': \"system_init\",\n'version': \"wm220_0306_v03.01.10.93\",\n're': \"\"\"\nimu_init:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){7,10}), lr}\n  sub\tsp, #0x64\n  ; block of code, in wm220_0306_v03.02.13.12, 12 words:\n  ;bl\t#0x5130f2\n  ;bl\t#(?P<nullsub_53>[0-9a-fx]+)\n  ;ldr.w\tfp, \\[pc, #0x374\\]\n  ;movs\tr6, #0\n  ;ldr\tr5, \\[pc, #0x370\\]\n  ;mov.w\tsb, #1\n  ;mov\tr8, r6\n  ;loc_527BC4:\n  ;movs\tr0, #0xbb\n  ;muls\tr0, r6, r0\n  ;add.w\tr4, fp, r0, lsl #3\n  ;ldr.w\tr0, \\[r4, #(?P<unkstru_r4_field_46C>[0-9a-fx]+)\\]\n  ; block of code and data, in wm220_0306_v03.02.35.05, 290 words:\n  ;movs\tr1, #0x58\n  ;add\tr0, sp, #8\n  ;bl\t#(?P<memset_zero>[0-9a-fx]+)\n  ;movs\tr7, #0\n  ;bl\t#(?P<nullsub_53>[0-9a-fx]+)\n  ;bl\t#(?P<sub_50BF40>[0-9a-fx]+)\n  ;ldr.w\tsl, \\[pc, #(?P<imu_groups_p4>[0-9a-fx]+)\\]\n  ;sub.w\tsl, sl, #0xc\n  ;str.w\tr0, \\[sl, #(?P<rel_dword_20404528>[0-9a-fx]+)\\]\n  ;bl\t#(?P<getSystemTimerTickRate>[0-9a-fx]+)\n  ;movs\tr3, #0\n  ;str\tr0, \\[r4\\]\n  ;mov\tr2, r3\n  ;mov\tr1, r3\n  ;subw\tr0, pc, #(?P<sub_526EFA>[0-9a-fx]+) ; or adr.w\tr0, (sub_526EFA+1)\n  ;bl\t#(?P<timer_event_enable>[0-9a-fx]+)\n  ;ldr.w\tr8, \\[pc, #(?P<printf_s>[0-9a-fx]+)\\]\n  ;movs\tr6, #1\n  ;ldr.w\tfp, \\[pc, #(?P<unkvar_01>[0-9a-fx]+)\\]\n  ;movs\tr5, #0\n  ;loc_527BC4:\n  ;rsb\tr0, r7, r7, lsl #3\n  ;add.w\tr1, r0, r7, lsl #6\n  ;ldr\tr0, \\[pc, #(?P<imu_groups>[0-9a-fx]+)\\]\n  ;add.w\tr4, r0, r1, lsl #4\n  ;ldr.w\tr0, \\[r4, #(?P<unkstru_r4_field_46C>[0-9a-fx]+)\\]\n  ;b\t#(?P<loc_527DDC>[0-9a-fx]+)\n  ;dcd\t(?P<ptr_unk_5848FC>[0-9a-fx]+)\n  ;dcb\t\"miscali_%d \", 0\n  ;dcb\t\"miscali_init_cfg miscali_%d\",0\n  ;[...]\n  ;dcd\t(?P<ptr_printf_s>[0-9a-fx]+)\n  ;dcd\t(?P<ptr_unkvar_01>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_01>([0-9a-fx]+[, ]*){10,580})\n  cbnz\tr0, #(?P<loc_527DEA>[0-9a-fx]+)\n  ; block of code, in wm220_0306_v03.02.13.12, same as:\n  ; block of code, in wm220_0306_v03.02.35.05, 1 word:\n  ;subw\tr0, pc, #(?P<cstr_link_manual_cali_neg>[0-9a-fx]+)\n  ; block of code, in wm220_0306_v03.02.44.07, 1 word:\n  ;adr\tr0, #(?P<cstr_link_manual_cali>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_18>([0-9a-fx]+[, ]*){1,2})\n  bl\t#(?P<get_link_by_name>[0-9a-fx]+)\n  str.w\tr0, \\[r4, #(?P<unkstru_r4_field_46C>[0-9a-fx]+)\\]\nloc_527DEA:\n  ; block of code, in wm220_0306_v03.02.13.12, 37 words:\n  ;movs\tr7, #0\n  ;loc_513EDC:\n  ;movs\tr3, #1\n  ;rsb\tr1, r7, r7, lsl #3\n  ;movs\tr2, #0x10\n  ;add.w\tr0, r4, r1, lsl #4\n  ;add.w\tr1, r0, #0x6c\n  ;adds\tr0, #0xac\n  ;bl\t#0x426702\n  ;adds\tr7, r7, #1\n  ;cmp\tr7, #8\n  ;blo\t#(?P<loc_513EDC>[0-9a-fx]+)\n  ;movs\tr0, #0\n  ;loc_513EFA:\n  ;rsb\tr2, r0, r0, lsl #3\n  ;add.w\tr1, r4, r2, lsl #4\n  ;ldr\tr1, \\[r1, #0x68\\]\n  ;cbnz\tr1, #(?P<loc_513F0A>[0-9a-fx]+)\n  ;cmp\tr0, #7\n  ;bne\t#(?P<loc_514008>[0-9a-fx]+)\n  ;loc_513F0A:\n  ;adds\tr0, r0, #1\n  ;cmp\tr0, #8\n  ;blo\t#0x513efa\n  ;ldr.w\tr0, \\[r4, #0x3e8\\]\n  ;subs\tr0, r0, #1\n  ;cmp.w\tr0, #0x1f40\n  ;bhs\t#(?P<loc_514008>[0-9a-fx]+)\n  ;ldr.w\tip, \\[r5\\]\n  ; block of code and data, in wm220_0306_v03.02.35.05:\n  ;mov\tr0, r7\n  ;bl\t#(?P<sub_526D10>[0-9a-fx]+)\n  ;cmp\tr0, #0\n  ;bge\t#(?P<loc_527E08>[0-9a-fx]+)\n  ;ldrb\tr0, \\[r4, #0x1c\\]\n  ;movs\tr1, #3\n  ;orr\tr0, r0, #0x900000\n  ;bl\t#(?P<open_device>[0-9a-fx]+)\n  ;str\tr0, \\[r4, #0x64\\]\n  ;strb.w\tr5, \\[r4, #0x6c\\]\n  ;b\t#(?P<loc_527E0E>[0-9a-fx]+)\n  ;loc_527E08:\n  ;str\tr5, \\[r4, #0x64\\]\n  ;strb.w\tr6, \\[r4, #0x6c\\]\n  ;loc_527E0E:\n  ;mov\tr0, r7\n  ;bl\t#(?P<sub_526D52>[0-9a-fx]+)\n  ;cmp\tr0, #0\n  ;bge\t#(?P<loc_527E2C>[0-9a-fx]+)\n  ;ldrb\tr0, \\[r4, #0x1d\\]\n  ;movs\tr1, #3\n  ;orr\tr0, r0, #0x910000\n  ;bl\t#(?P<open_device>[0-9a-fx]+)\n  ;str\tr0, \\[r4, #0x68\\]\n  ;strb.w\tr5, \\[r4, #0x6d\\]\n  ;b\t#(?P<loc_527E32>[0-9a-fx]+)\n  ;loc_527E2C:\n  ;str\tr5, \\[r4, #0x68\\]\n  ;strb.w\tr6, \\[r4, #0x6d\\]\n  ;loc_527E32:\n  ;ldr\tr0, \\[r4, #0x64\\]\n  ;cbnz\tr0, #(?P<loc_527E3E>[0-9a-fx]+)\n  ;ldrb.w\tr0, \\[r4, #0x6c\\]\n  ;cmp\tr0, #0\n  ;beq\t#(?P<loc_527ED8>[0-9a-fx]+)\n  ;loc_527E3E:\n  ;ldr\tr0, \\[r4, #0x68\\]\n  ;cbnz\tr0, #(?P<loc_527E4A>[0-9a-fx]+)\n  ;ldrb.w\tr0, \\[r4, #0x6d\\]\n  ;cmp\tr0, #0\n  ;beq\t#(?P<loc_527ED8>[0-9a-fx]+)\n  ;loc_527E4A:\n  ;ldr.w\tr3, \\[r8\\]\n  dcw\t(?P<undefined_varlen_02>([0-9a-fx]+[, ]*){32,64})\n  movs\tr0, #7\n  adr\tr1, #(?P<cstr_imu_group_ok1>[0-9a-fx]+)\n  ; block of code, in wm220_0306_v03.02.13.12:\n  ;ldr.w\tr3, \\[r4, #0x3e8\\]\n  ;mov\tr7, r8\n  ;mov\tr2, r6\n  ; block of code and data, in wm220_0306_v03.02.35.05:\n  ;mov\tr2, r7\n  dcw\t(?P<undefined_varlen_03>([0-9a-fx]+[, ]*){1,6})\n  blx\t(r3|ip)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr(.w)?\t(r3|ip), \\[r0, #0xc\\]\n  movs\tr0, #0x39\n  adr\tr1, #(?P<cstr_imu_group_ok2>[0-9a-fx]+)\n  ; block of code, in wm220_0306_v03.02.13.12:\n  ;ldr.w\tr3, \\[r4, #0x3e8\\]\n  ;mov\tr2, (r7|r6)\n  ; block of code and data, in wm220_0306_v03.02.35.05:\n  ;mov\tr2, (r7|r6)\n  dcw\t(?P<undefined_varlen_04>([0-9a-fx]+[, ]*){1,4})\n  blx\t(r3|ip)\n  movs\tr1, #0xe0\n  add.w\tr0, r4, #(?P<unkstru_r4_field_350>[0-9a-fx]+)\n  bl\t#(?P<memset_zero>[0-9a-fx]+)\n  add[.]?w\tr0, r4, #(?P<unkstru_r4_field_70>[0-9a-fx]+)\n  movs\tr1, #0x38\n  mov\t(sb|sl), r0\n  bl\t#(?P<memset_zero>[0-9a-fx]+)\n  add.w\tr1, r4, #(?P<unkstru_r4_field_20>[0-9a-fx]+)\n  ldr.w\tr0, \\[(sl|r4), #(?P<rel_dword_20404528>[0-9a-fx]+)\\]\n  movs\tr3, #0\n  mov\tr2, (r7|r6)\n  strd\tr0, r1, \\[sp\\]\n  adds\tr1, r4, #4\n  add\tr0, sp, #8\n  bl\t#(?P<sub_5273E2>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_20404358>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r4\\]\n  ldr\tr0, \\[r0\\]\n  bic\tr0, r0, #0xff000000\n  orr.w\tr0, r0, r1, lsl #29\n  str.w\tr0, \\[r4, #(?P<unkstru_r4_field_34Ca>[0-9a-fx]+)\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr.w\tip, \\[r0, #0xc\\]\n  movs\tr0, #0xe\n  adr\tr1, #(?P<cstr_imu_group_sensor_id>[0-9a-fx]+)\n  ldr.w\tr3, \\[r4, #(?P<unkstru_r4_field_34Cb>[0-9a-fx]+)\\]\n  mov\tr2, (r7|r6)\n  blx\tip\n  uxth\tr2, (r7|r6)\n  mov\tr0, (sb|sl)\n  adr\tr1, #(?P<cstr_gyro_acc>[0-9a-fx]+)\n  bl\t#(?P<snprintf_sd_16>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<sub_527570>[0-9a-fx]+)\\]\n  add\tr2, sp, #8\n  mov\tr1, (sb|sl)\n  str.w\tr0, \\[r4, #(?P<unkstru_r4_field_80>[0-9a-fx]+)\\]\n  movs\tr0, #8\n  bl\t#(?P<hal_add_device_with_param>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.02.13.12:\n  ;cmp\tr0, #0\n  ;beq\t#(?P<loc_527F00>[0-9a-fx]+)\n  ; block of code and data, in wm220_0306_v03.02.35.05:\n  ;cbz\tr0, #(?P<loc_527F00>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_05>([0-9a-fx]+[, ]*){1,4})\n  strb.w\t(r5|r7), \\[r4, #(?P<unkstru_r4_field_A8>[0-9a-fx]+)\\]\nloc_527ED8:\n  ; block of code, in wm330_0306_v03.02.13.12:\n  ;adds\tr6, r6, #1\n  ;cmp\tr6, #2\n  ;blo\t#(?P<loc_527BC4>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;adds\tr7, r7, #1\n  ; block of code and data, in wm100_0306_v03.02.43.20:\n  ;adds\tr7, r7, #1\n  ;beq.w\t#(?P<loc_527BC4>[0-9a-fx]+)\n  ;cmp\tr7, #2\n  ;blo.w\t#(?P<loc_527BC4>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_06>([0-9a-fx]+[, ]*){1,8})\n  ldr.w\tsl, \\[pc, #(?P<byte_20404E10>[0-9a-fx]+)\\]\n  movs\tr7, #0\n  ; block of code, in wm330_0306_v03.02.13.12, 35 words:\n  ;loc_527F76:\n  ;movs\tr6, #0\n  ;add.w\tr0, r7, r7, lsl #4\n  ;add.w\tr1, r0, r7, lsl #5\n  ;add.w\tr4, sl, r1, lsl #3\n  ;loc_513FD2:\n  ;rsb\tr1, r6, r6, lsl #3\n  ;movs\tr3, #1\n  ;add.w\tr0, r4, r1, lsl #4\n  ;add.w\tr1, r0, #0x10\n  ;movs\tr2, #0x10\n  ;adds\tr0, #0x50\n  ;bl\t#0x426702\n  ;adds\tr6, r6, #1\n  ;cmp\tr6, #2\n  ;blo\t#(?P<loc_513FD2>[0-9a-fx]+)\n  ;ldr\tr0, \\[r4, #0xc\\]\n  ;cmp\tr0, #0\n  ;beq\t#(?P<loc_5140D6>[0-9a-fx]+)\n  ;ldr\tr0, \\[r4, #0x7c\\]\n  ;cmp\tr0, #0\n  ;beq\t#(?P<loc_5140D6>[0-9a-fx]+)\n  ;ldr.w\tr3, \\[r4, #0xec\\]\n  ;subs\tr0, r3, #1\n  ;cmp.w\tr0, #0x320\n  ;bhs\t#(?P<loc_5140D6>[0-9a-fx]+)\n  ;b\t#(?P<loc_527F2A>[0-9a-fx]+)\n  ;loc_514008:\n  ;b\t#(?P<loc_5140A4>[0-9a-fx]+)\n  ; block of code, in wm100_0306_v03.02.43.20:\n  ;loc_527EE6:\n  ;add.w\tr1, r7, r7, lsl #2\n  ;add.w\tr4, sl, r1, lsl #4\n  ;movs\tr1, #3\n  ;ldrb\tr0, \\[r4, #1\\]\n  ;orr\tr0, r0, #0x920000\n  ;bl\t#(?P<open_device>[0-9a-fx]+)\n  ;str\tr0, \\[r4, #0x10\\]\n  ;cbnz\tr0, #(?P<loc_527F2A>[0-9a-fx]+)\n  ;b\t#(?P<loc_527F24>[0-9a-fx]+)\n  ;loc_527F00:\n  ;movs\tr1, #0x32\n  ;mov\tr0, sb\n  ;bl\t#(?P<sub_524FE2>[0-9a-fx]+)\n  ;strb.w\tr6, \\[r4, #0xa8\\]\n  ;movs\tr2, #1\n  ;ldr\tr0, \\[r4, #0x64\\]\n  ;mov\tsb, fp\n  ;mov\tr1, fp\n  ;bl\t#(?P<enable_device>[0-9a-fx]+)\n  ;ldr\tr0, \\[r4, #0x68\\]\n  ;movs\tr2, #1\n  ;mov\tr1, sb\n  ;bl\t#(?P<enable_device>[0-9a-fx]+)\n  ;b\t#(?P<loc_527ED8>[0-9a-fx]+)\n  ;loc_527F24:\n  ;ldrb\tr0, \\[r4, #1\\]\n  ;cmp\tr0, #0x80\n  ;blo\t#(?P<loc_527F68>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_07>([0-9a-fx]+[, ]*){32,48})\nloc_527F2A:\n  ldr(.w)?\t(r3|r6), \\[(r8|r5)\\]\n  movs\tr0, #7\n  adr\tr1, #(?P<cstr_baro_group_ok1>[0-9a-fx]+)\n  mov\tr2, r7\n  blx\t(r3|r6)\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\t(r3|r6), \\[r0, #0xc\\]\n  movs\tr0, #0x39\n  adr\tr1, #(?P<cstr_baro_group_ok2>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.02.13.12:\n  ;ldr.w\tr3, \\[r4, #0xec\\]\n  ;mov\tr2, r7\n  ; block of code, in wm100_0306_v03.02.43.20:\n  ;mov\tr2, r7\n  dcw\t(?P<undefined_varlen_08>([0-9a-fx]+[, ]*){1,4})\n  blx\t(r3|r6)\n  add.w\tr0, r4, #(?P<unkstru_r4_field_14>[0-9a-fx]+)\n  movs\tr1, #0x38\n  mov\t(sb|r6), r0\n  bl\t#(?P<memset_zero>[0-9a-fx]+)\n  movs\tr2, #0\n  mov\tr0, (sb|r6)\n  adr\tr1, #(?P<cstr_baro>[0-9a-fx]+)\n  bl\t#(?P<snprintf_sd_16>[0-9a-fx]+)\n  movs\tr0, #9\n  mov\tr1, (sb|r6)\n  bl\t#(?P<hal_add_device>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.02.13.12:\n  ;cmp\tr0, #0\n  ; block of code, in wm100_0306_v03.02.43.20:\n  ;cbz\tr0, #(?P<loc_527F90>[0-9a-fx]+)\n  ;strb.w\tr5, \\[r4, #0x4d\\]\n  ;loc_527F68:\n  ;adds\tr7, r7, #1\n  ;beq\t#(?P<loc_527EE6>[0-9a-fx]+)\n  ;ldr.w\tsl, \\[pc, #(?P<byte_20404E10>[0-9a-fx]+)\\]\n  ;movs\tr7, #0\n  ;add.w\tsl, sl, #0x50\n  ;loc_527F76:\n  ;add.w\tr1, r7, r7, lsl #2\n  ;add.w\tr4, sl, r1, lsl #4\n  ;movs\tr1, #3\n  ;ldrb\tr0, \\[r4, #1\\]\n  ;orr\tr0, r0, #0x930000\n  ;bl\t#(?P<open_device>[0-9a-fx]+)\n  ;str\tr0, \\[r4, #0x10\\]\n  ;cbnz\tr0, #(?P<loc_527FAE>[0-9a-fx]+)\n  ;b\t#(?P<loc_527FA8>[0-9a-fx]+)\n  ;loc_527F90:\n  ;movs\tr1, #0x32\n  ;mov\tr0, sb\n  ;bl\t#(?P<sub_524FE2>[0-9a-fx]+)\n  ;strb.w\tr6, \\[r4, #0x4d\\]\n  ;movs\tr2, #1\n  ;ldr\tr0, \\[r4, #0x10\\]\n  ;mov\tr1, fp\n  ;bl\t#(?P<enable_device>[0-9a-fx]+)\n  ;b\t#(?P<loc_527F68>[0-9a-fx]+)\n  ;loc_527FA8:\n  ;ldrb\tr0, \\[r4, #1\\]\n  ;cmp\tr0, #0x80\n  ;blo\t#(?P<loc_527FEE>[0-9a-fx]+)\n  ;loc_527FAE:\n  ;ldr.w\tr3, \\[r8\\]\n  ;movs\tr0, #7\n  ;adr\tr1, #(?P<cstr_compass_group_ok1>[0-9a-fx]+)\n  ;mov\tr2, r7\n  ;blx\tr3\n  ;bl\t#(?P<get_logger>[0-9a-fx]+)\n  ;ldr\tr3, \\[r0, #0xc\\]\n  ;movs\tr0, #0x39\n  ;adr\tr1, #(?P<cstr_compass_group_ok2>[0-9a-fx]+)\n  ;mov\tr2, r7\n  ;blx\tr3\n  ;add.w\tr0, r4, #0x14\n  ;movs\tr1, #0x38\n  ;mov\tsb, r0\n  ;bl\t#(?P<memset_zero>[0-9a-fx]+)\n  ;movs\tr2, #0\n  ;mov\tr0, sb\n  ;adr\tr1, #(?P<cstr_compass>[0-9a-fx]+)\n  ;bl\t#(?P<snprintf_sd_16>[0-9a-fx]+)\n  ;movs\tr0, #0xa\n  ;mov\tr1, sb\n  ;bl\t#(?P<hal_add_device>[0-9a-fx]+)\n  ;cmp\tr0, #0\n  dcw\t(?P<undefined_varlen_10>([0-9a-fx]+[, ]*){1,72})\n  beq\t#(?P<loc_528066>[0-9a-fx]+)\n  strb.w\t(r5|r8), \\[r4, #(?P<unkstru_r4_field_4C>[0-9a-fx]+)\\]\nloc_527FEE:\n  adds\tr7, r7, #1\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;cmp\tr7, #3\n  ;blo\t#(?P<loc_527F76>[0-9a-fx]+)\n  ; block of code and data, in wm100_0306_v03.02.43.20:\n  ;beq\t#(?P<loc_527F76>[0-9a-fx]+)\n  ; block of code, in wm220_0306_v03.02.13.12:\n  ;beq\t#(?P<loc_527F76>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_11>([0-9a-fx]+[, ]*){1,4})\n  ldr\tr0, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  movs\tr2, #0\n  adr\tr1, #(?P<cstr_local>[0-9a-fx]+)\n  bl\t#(?P<hal_add_imu>[0-9a-fx]+)\n  subw\tr0, pc, #(?P<hal_push_mc_version>[0-9a-fx]+)\n  ldr\tr4, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  str\tr0, \\[r4, #0x1c\\] ; hal_stru_164C.push_version_cb\n  mov\tr0, r4\n  bl\t#(?P<sub_525DB0>[0-9a-fx]+)\n  mov\tr0, r4\n  bl\t#(?P<sub_525CF0>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_528032>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.02.13.12, same as:\n  ; block of code, in wm100_0306_v03.02.43.20, 5 words:\n  ;ldr(.w)?\tr3, \\[(r8|r5)\\]\n  ;movs\tr0, #7\n  ;ldrb\tr2, \\[r4, #0x40\\]! ; hal_stru_164C.local_imu_id_errno\n  ; block of code and data, in wm220_0306_v03.02.44.07:\n  dcw\t(?P<undefined_varlen_19>([0-9a-fx]+[, ]*){4,224})\n  adr\tr1, #(?P<cstr_warn_local_imu_id_error1>[0-9a-fx]+)\n  blx\tr3\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #0x39\n  adr\tr1, #(?P<cstr_warn_local_imu_id_error2>[0-9a-fx]+)\n  ldrb\tr2, \\[r4\\]\n  blx\tr3\nloc_528032:\n  ; block of code, in wm330_0306_v03.02.13.12:\n  ;bl\t#0x514408\n  ;bl\t#0x514610\n  ;ldr\tr1, \\[pc, #(?P<constval_2FA0000>[0-9a-fx]+)\\]\n  ;ldr\tr0, \\[pc, #(?P<unk_20404F50>[0-9a-fx]+)\\]\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ;ldr\tr2, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  ;adr\tr0, #(?P<cstr_link_auto_cali>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<link_cali_msg_callback>[0-9a-fx]+)\\]\n  ;adds\tr2, #0x44\n  ;bl\t#(?P<link_set_msg_callback>[0-9a-fx]+)\n  ;ldr\tr2, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  ;adr\tr0, #(?P<cstr_link_manual_cali>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<link_cali_msg_callback>[0-9a-fx]+)\\]\n  ;adds\tr2, #0x44\n  ;bl\t#(?P<link_set_msg_callback>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  ;movs\tr2, #0xc8\n  ;adds\tr1, #0x5c\n  ;sub.w\tr0, r1, #0x14\n  ;bl\t#(?P<sub_50B8C4>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<constval_2FA0000>[0-9a-fx]+)\\]\n  ;ldr\tr0, \\[pc, #(?P<unk_20404F50>[0-9a-fx]+)\\]\n  ; block of code and data, in wm100_0306_v03.02.43.20:\n  ;ldr\tr2, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  ;adr\tr0, #(?P<cstr_link_auto_cali>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<link_cali_msg_callback>[0-9a-fx]+)\\]\n  ;adds\tr2, #0x44\n  ;bl\t#(?P<link_set_msg_callback>[0-9a-fx]+)\n  ;ldr\tr2, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  ;adr\tr0, #(?P<cstr_link_manual_cali>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<link_cali_msg_callback>[0-9a-fx]+)\\]\n  ;adds\tr2, #0x44\n  ;bl\t#(?P<link_set_msg_callback>[0-9a-fx]+)\n  ;ldr\tr1, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  ;movs\tr2, #0xc8\n  ;adds\tr1, #0x5c\n  ;sub.w\tr0, r1, #0x14\n  ;bl\t#(?P<sub_50B8C4>[0-9a-fx]+)\n  ;ldr\tr0, \\[pc, #(?P<unk_20404F50>[0-9a-fx]+)\\]\n  ;ldr\tr1, \\[pc, #(?P<constval_2FA0000>[0-9a-fx]+)\\]\n  ;adds\tr0, #0xa0\n  dcw\t(?P<undefined_varlen_12>([0-9a-fx]+[, ]*){6,24})\n  bl\t#(?P<sub_526C66>[0-9a-fx]+)\n  add\tsp, #0x64\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){7,10}), pc}\n  ; the function continues - there are a few blocks after the pop\n  ; real end is with:\n  ;b\t#(?P<loc_527FEE>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'imu_init':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'enable_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'getSystemTimerTickRate':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_link_by_name':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_add_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_add_device_with_param':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_add_imu':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_push_mc_version':\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC-\", 'variety': CodeVariety.FUNCTION},\n  'snprintf_sd_16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memset_zero':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'nullsub_53':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'open_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'link_cali_msg_callback':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'link_set_msg_callback':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'printf_s':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_50B8C4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_50BF40':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_524FE2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_525CF0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_525DB0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_526C66':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_526D10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_526D52':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_526EFA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_5273E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_527570':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'timer_event_enable':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_513FD2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5140A4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_5140D6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527BC4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527DDC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527DEA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527E08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527E0E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527E2C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527E32':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527E3E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527E4A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527ED8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527EE6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527F00':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527F24':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527F2A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527F68':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527F76':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527F90':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527FA8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527FAE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_527FEE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_528032':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_528066':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_01':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (10,580)},\n  'undefined_varlen_02':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (32,64)},\n  'undefined_varlen_03':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,6)},\n  'undefined_varlen_04':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_05':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_06':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,8)},\n  'undefined_varlen_07':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (32,48)},\n  'undefined_varlen_08':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_10':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,72)},\n  'undefined_varlen_11':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_12':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (6,24)},\n  'undefined_varlen_18':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_19':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (4,224)},\n  'cstr_baro':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_baro_group_ok1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_baro_group_ok2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  #'cstr_compass':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  #'cstr_compass_group_ok1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  #'cstr_compass_group_ok2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_gyro_acc':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_imu_group_ok1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_imu_group_ok2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_imu_group_sensor_id':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_link_auto_cali':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_link_manual_cali':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # this is offset to `cstr_link_manual_cali` but computed by 'sub' function - so offset provided needs to be negated to get address\n  'cstr_link_manual_cali_neg':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC-\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_local':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_warn_local_imu_id_error1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_warn_local_imu_id_error2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'byte_20404E10':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT8_T},\n  #'constval_2FA0000':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'hal_stru_164C':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'imu_groups':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  # this is the pointer to `imu_groups`, same as above; but it gets misinterpreted by 4 bytes, so we define separate var as workaround:\n  'imu_groups_p4':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'unkstru_r4_field_14':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_20':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_4C':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_70':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_80':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_A8':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_34Ca':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_34Cb':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_350':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_46C':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  #'ptr_printf_s':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UNKNOWN},\n  #'ptr_unk_5848FC':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UNKNOWN},\n  #'ptr_unkvar_01':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UNKNOWN},\n  'dword_20404358':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'rel_dword_20404528':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  #'unk_20404F50':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkvar_01':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n},\n}\n\nre_func_imu_init_WM330_V03_01_10_93 = {\n'name': \"imu_init\",\n'alt_name': \"system_init\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nimu_init:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){7,10}), lr}\n  sub\tsp, #0x64\n  bl\t#(?P<sub_4E7D9E>[0-9a-fx]+)\n  ldr.w\tr8, \\[pc, #(?P<dword_20404E48>[0-9a-fx]+)\\]\n  movs\tr6, #0\n  ldr\tr7, \\[pc, #(?P<dword_514C70>[0-9a-fx]+)\\]\n  mov.w\tsl, #1\n  mov\tsb, r6\nloc_4E79F0:\n  rsb\tr0, r6, r6, lsl #3\n  movs\tr5, #0\n  add.w\tr1, r0, r0, lsl #2\n  ldr\tr0, \\[pc, #(?P<byte_204053B4>[0-9a-fx]+)\\]\n  add.w\tr4, r0, r1, lsl #5\nloc_4E7A00:\n  rsb\tr1, r5, r5, lsl #4\n  movs\tr3, #4\n  add.w\tr0, r4, r1, lsl #2\n  mov\tr2, r3\n  add.w\tr1, r0, #0x44\n  adds\tr0, #0x54\n  bl\t#(?P<sub_46EF10>[0-9a-fx]+)\n  adds\tr5, r5, #1\n  cmp\tr5, #0xa\n  blo\t#(?P<loc_4E7A00>[0-9a-fx]+)\n  movs\tr0, #0\n  mov\tr2, r4\nloc_4E7A20:\n  rsb\tr1, r0, r0, lsl #4\n  add.w\tr1, r2, r1, lsl #2\n  ldr\tr1, \\[r1, #0x6c\\]\n  b\t#(?P<loc_4E7B74>[0-9a-fx]+)\n  ;dcd\t(?P<unk_204397A0>[0-9a-fx]+)\n  ;dcb\t\"temp cali\",0\n  ;[...]\n  ;dcd\t(?P<dword_20404E48>[0-9a-fx]+)\n  ;dcd\t(?P<dword_514C70>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_01>([0-9a-fx]+[, ]*){10,580})\nloc_4E7B74:\n  cbnz\tr1, #(?P<loc_4E7BB4>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_4E7BB4>[0-9a-fx]+)\n  cmp\tr0, #8\n  beq\t#(?P<loc_4E7BB4>[0-9a-fx]+)\n  cmp\tr0, #9\n  beq\t#(?P<loc_4E7BB4>[0-9a-fx]+)\n  ldr.w\tr0, \\[r8\\]\n  mov\tr3, r6\n  ldr\tr1, \\[r7\\]\n  udiv\tr2, r0, r1\n  mls\tr1, r1, r2, r0\n  mov.w\tr2, #0x3e8\n  muls\tr1, r2, r1\n  ldr\tr2, \\[r7\\]\n  udiv\tr2, r1, r2\n  ldr\tr1, \\[r7\\]\n  udiv\tr1, r0, r1\n  adr\tr0, #(?P<cstr_fmt_imu_group_err1>[0-9a-fx]+)\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_fmt_imu_group_err2>[0-9a-fx]+)\n  mov\tr1, r6\n  bl\t#(?P<sub_4472FC>[0-9a-fx]+)\n  b\t#(?P<loc_4E7C46>[0-9a-fx]+)\nloc_4E7BB4:\n  adds\tr0, r0, #1\n  cmp\tr0, #0xa\n  blo.w\t#(?P<loc_4E7A20>[0-9a-fx]+)\n  ldr.w\tr0, \\[r8\\]\n  mov\tr5, sb\n  ldr\tr1, \\[r7\\]\n  mov\tr3, r6\n  udiv\tr2, r0, r1\n  mls\tr1, r1, r2, r0\n  mov.w\tr2, #0x3e8\n  muls\tr1, r2, r1\n  ldr\tr2, \\[r7\\]\n  udiv\tr2, r1, r2\n  ldr\tr1, \\[r7\\]\n  udiv\tr1, r0, r1\n  adr\tr0, #(?P<cstr_fmt_imu_group_ok1>[0-9a-fx]+)\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_fmt_imu_group_ok2>[0-9a-fx]+)\n  mov\tr1, r6\n  bl\t#(?P<sub_4472FC>[0-9a-fx]+)\n  movs\tr1, #0xe0\n  add.w\tr0, r4, #(?P<unkstru_r4_field_350>[0-9a-fx]+)\n  bl\t#(?P<memset_zero>[0-9a-fx]+)\n  add[.]?w\tr0, r4, #(?P<unkstru_r4_field_70>[0-9a-fx]+)\n  movs\tr1, #0x38\n  mov\tfp, r0\n  bl\t#(?P<memset_zero>[0-9a-fx]+)\n  movs\tr3, #0\n  mov\tr2, r6\n  adds\tr1, r4, #4\n  mov\tr0, sp\n  bl\t#(?P<sub_5273E2>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_20404358>[0-9a-fx]+)\\]\n  mov.w\tr1, #-1\n  str.w\tr1, \\[r4, #0x380\\]\n  uxth\tr2, r6\n  adr\tr1, #(?P<cstr_gyro_acc>[0-9a-fx]+) ; \"gyro_acc\"\n  ldr\tr0, \\[r0\\]\n  bfi\tr0, r6, #0x18, #8\n  str.w\tr0, \\[r4, #(?P<unkstru_r4_field_34Ca>[0-9a-fx]+)\\]\n  mov\tr0, fp\n  bl\t#(?P<snprintf_sd_16>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<sub_4E7792_p1>[0-9a-fx]+)\\]\n  movs\tr0, #0xa\n  mov\tr2, sp\n  str.w\tr1, \\[r4, #0x314\\]\n  mov\tr1, fp\n  bl\t#(?P<sub_4E591C>[0-9a-fx]+)\n  cmp\tr0, #0\n  beq\t#(?P<loc_4E7D40>[0-9a-fx]+)\n  strb.w\tr5, \\[r4, #0x374\\]\nloc_4E7C46:\n  ldr.w\tr0, \\[r4, #0x1d4\\]\n  cmp\tr0, #0\nloc_4E7C4C:\n  beq\t#(?P<loc_4E7D42>[0-9a-fx]+)\n  ldr.w\tr0, \\[r4, #0x288\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_4E7C4C>[0-9a-fx]+)\n  ldr.w\tr0, \\[r8\\]\n  mov\tr3, r6\n  ldr\tr1, \\[r7\\]\n  udiv\tr2, r0, r1\n  mls\tr1, r1, r2, r0\n  mov.w\tr2, #0x3e8\n  muls\tr1, r2, r1\n  ldr\tr2, \\[r7\\]\n  udiv\tr2, r1, r2\n  ldr\tr1, \\[r7\\]\n  udiv\tr1, r0, r1\n  adr\tr0, #(?P<cstr_fmt_imu_grp_baro_ok1>[0-9a-fx]+)\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_fmt_imu_grp_baro_ok2>[0-9a-fx]+)\n  mov\tr1, r6\n  bl\t#(?P<sub_4472FC>[0-9a-fx]+)\n  add.w\tr0, r4, #0x33c\n  movs\tr2, #0\n  mov\tr5, r0\n  adr\tr1, #(?P<cstr_baro>[0-9a-fx]+)\n  bl\t#(?P<snprintf_sd_16>[0-9a-fx]+)\n  movs\tr0, #0xb\n  mov\tr1, r5\n  bl\t#(?P<hal_add_device>[0-9a-fx]+)\n  cmp\tr0, #0\n  beq\t#(?P<loc_4E7D8E>[0-9a-fx]+)\n  strb.w\tsb, \\[r4, #0x375\\]\nloc_4E7CA4:\n  adds\tr6, r6, #1\n  cmp\tr6, #2\n  blo.w\t#(?P<loc_4E79F0>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  movs\tr2, #0\n  adr\tr1, #(?P<cstr_local>[0-9a-fx]+) ; \"_local\"\n  bl\t#(?P<hal_add_imu>[0-9a-fx]+)\n  subw\tr0, pc, #(?P<hal_push_mc_version>[0-9a-fx]+)\n  ldr\tr4, \\[pc, #(?P<hal_stru_164C>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  str\tr0, \\[r4, #0x1c\\] ; hal_stru_164C.push_version_cb\n  mov\tr0, r4\n  bl\t#(?P<sub_525DB0>[0-9a-fx]+)\n  mov\tr0, r4\n  bl\t#(?P<sub_525CF0>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_528032>[0-9a-fx]+)\n  ; block of code, in wm330_0306_v03.01.10.93:\n  ldr.w\tr0, \\[r8\\]\n  ldr\tr1, \\[r7\\]\n  ldrb\tr3, \\[r4, #(?P<rel_byte_204397E0>[0-9a-fx]+)\\]!\n  udiv\tr2, r0, r1\n  mls\tr1, r1, r2, r0\n  mov.w\tr2, #0x3e8\n  muls\tr1, r2, r1\n  ldr\tr2, \\[r7\\]\n  udiv\tr2, r1, r2\n  ldr\tr1, \\[r7\\]\n  udiv\tr1, r0, r1\n  adr\tr0, #(?P<cstr_fmt_warn_local_imu_id_errno1>[0-9a-fx]+)\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  ldrb\tr1, \\[r4\\]\n  adr\tr0, #(?P<cstr_fmt_warn_local_imu_id_errno2>[0-9a-fx]+)\n  bl\t#(?P<sub_4472FC>[0-9a-fx]+)\nloc_4E7D00:\n  bl\t#(?P<sub_4E7E14>[0-9a-fx]+)\n  ldr\tr4, \\[pc, #(?P<unk_554B84>[0-9a-fx]+)\\]\n  ldrd\tr0, r1, \\[r4, #0x18\\]\n  strd\tr0, r1, \\[sp, #0x58\\]\n  movs\tr1, #0\n  add\tr0, sp, #0x58\n  bl\t#(?P<sub_48E00A>[0-9a-fx]+)\n  ldr\tr5, \\[pc, #(?P<unk_204397A0>[0-9a-fx]+)\\]\n  adds\tr5, #0x44\n  mov\tr2, r5\n  str\tr0, \\[r5\\]\n  ldrd\tr0, r1, \\[r4, #0x20\\]\n  strd\tr0, r1, \\[sp, #0x58\\]\n  ldr\tr1, \\[pc, #(?P<sub_4E79A8>[0-9a-fx]+)\\]\n  add\tr0, sp, #0x58\n  bl\t#(?P<sub_48E034>[0-9a-fx]+)\n  movs\tr2, #0xc8\n  adds\tr0, r5, #4\n  add.w\tr1, r5, #0x18\n  bl\t#(?P<sub_48C064>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_20405C9C>[0-9a-fx]+)\\]\n  movs\tr1, #2\n  b\t#(?P<loc_4E7D44>[0-9a-fx]+)\nloc_4E7D40:\n  b\t#(?P<loc_4E7D4C>[0-9a-fx]+)\nloc_4E7D42:\n  b\t#(?P<loc_4E7D5A>[0-9a-fx]+)\nloc_4E7D44:\n  bl\t#(?P<sub_4E8656>[0-9a-fx]+)\n  add\tsp, #0x64\n  b\t#(?P<locret_4E762E>[0-9a-fx]+)\nloc_4E7D4C:\n  movs\tr1, #0x32\n  mov\tr0, fp\n  bl\t#(?P<sub_4E56BA>[0-9a-fx]+)\n  strb.w\tsl, \\[r4, #0x374\\]\n  b\t#(?P<loc_4E7C46>[0-9a-fx]+)\nloc_4E7D5A:\n  ldr.w\tr0, \\[r8\\]\n  mov\tr3, r6\n  ldr\tr1, \\[r7\\]\n  udiv\tr2, r0, r1\n  mls\tr1, r1, r2, r0\n  mov.w\tr2, #0x3e8\n  muls\tr1, r2, r1\n  ldr\tr2, \\[r7\\]\n  udiv\tr2, r1, r2\n  ldr\tr1, \\[r7\\]\n  udiv\tr1, r0, r1\n  adr\tr0, #(?P<cstr_fmt_imu_grp_baro_err1>[0-9a-fx]+)\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_fmt_imu_grp_baro_err2>[0-9a-fx]+)\n  mov\tr1, r6\n  bl\t#(?P<sub_4472FC>[0-9a-fx]+)\n  b\t#(?P<loc_4E7CA4>[0-9a-fx]+)\n  b\t#(?P<loc_4E7D8E>[0-9a-fx]+)\nloc_4E7D8E:\n  movs\tr1, #0x32\n  add.w\tr0, r4, #0x33c\n  bl\t#(?P<sub_4E56BA>[0-9a-fx]+)\n  strb.w\tsl, \\[r4, #0x375\\]\n  b\t#(?P<loc_4E7CA4>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'imu_init':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'snprintf_sd_16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4472FC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_46EF10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_48C064':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_48E00A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_48E034':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'log_printf':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E56BA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E591C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E7792_p1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E79A8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E7D9E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E7E14':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4E8656':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_525CF0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_525DB0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_5273E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memset_zero':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_add_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_add_imu':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_push_mc_version':\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC-\", 'variety': CodeVariety.FUNCTION},\n  'loc_4E79F0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7A00':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7A20':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7B74':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7BB4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7C46':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7C4C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7CA4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7D40':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7D42':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7D44':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7D4C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7D5A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4E7D8E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_528032':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'locret_4E762E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_01':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (10,580)},\n  'cstr_baro':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"<%d.%03d>imu group%d error**.\\r\\n\"\n  'cstr_fmt_imu_group_err1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"imu group%d error**.\"\n  'cstr_fmt_imu_group_err2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"<%d.%03d>imu group%d ok**.\\r\\n\"\n  'cstr_fmt_imu_group_ok1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"imu group%d ok**.\"\n  'cstr_fmt_imu_group_ok2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"<%d.%03d>imu group%d baro error**.\\r\\n\"\n  'cstr_fmt_imu_grp_baro_err1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"imu group%d baro error**.\"\n  'cstr_fmt_imu_grp_baro_err2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"<%d.%03d>imu group%d baro ok**.\\r\\n\"\n  'cstr_fmt_imu_grp_baro_ok1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"imu group%d baro ok**.\"\n  'cstr_fmt_imu_grp_baro_ok2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"<%d.%03d>Waring: Local imu ID erro %d!!\"...\n  'cstr_fmt_warn_local_imu_id_errno1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Waring: Local imu ID erro %d!!! \\r\\n\"\n  'cstr_fmt_warn_local_imu_id_errno2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_gyro_acc':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_local':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'byte_204053B4':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT8_T},\n  'dword_20404358':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'dword_20404E48':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'dword_514C70':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'hal_stru_164C':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'rel_byte_204397E0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UINT8_T},\n  'unk_20405C9C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'unk_204397A0':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'unk_554B84':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  'unkstru_r4_field_34Ca':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_350':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'unkstru_r4_field_70':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n},\n}\n\n\nre_func_hal_push_mc_version_P3X_FW_V01_07_0060 = {\n'name': \"hal_push_mc_version\",\n'version': \"P3X_FW_V01.07.0060\",\n'no_search': True,\n're': \"\"\"\nhal_push_mc_version:\n  ldr\tr1, \\[pc, #(?P<dword_2001C99C>[0-9a-fx]+)\\]\n  ldr\tr0, \\[pc, #(?P<mc_version_2>[0-9a-fx]+)\\]\n  str\tr0, \\[r1, #(?P<rel_mc_version>[0-9a-fx]+)\\]\n  bx\tlr\n\"\"\",\n'vars': {\n  'dword_2001C99C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'hal_push_mc_version':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_push_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'rel_mc_version':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UINT32_T},\n  'mc_version_2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\nre_func_hal_push_mc_version_WM330_V03_01_10_93 = {\n'name': \"hal_push_mc_version\",\n'version': \"wm330_0306_v03.01.10.93\",\n'no_search': True,\n're': \"\"\"\nhal_push_mc_version:\n  ldr\tr1, \\[pc, #(?P<mc_version_2>[0-9a-fx]+)\\]\n  b.w\t#(?P<hal_push_version>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'hal_push_mc_version':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'hal_push_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'mc_version_2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\n\nre_func_navi_init_WM330_V03_01_10_93 = {\n'name': \"navi_init\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nnavi_init:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,8}), lr}\n  adr\tr0, #(?P<cstr_build_datetime>[0-9a-fx]+)\n  ldr\tr4, \\[pc, #(?P<unkn_20418DE8>[0-9a-fx]+)\\]\n  ldm\tr0, {r0, r1, r2, r3}\n  stm.w\tsp, {r0, r1, r2, r3}\n  ldr\tr0, \\[pc, #(?P<mc_version_3a>[0-9a-fx]+)\\]\n  movs\tr1, #3\n  str.w\tr0, \\[r4, #(?P<rel_navi_version>[0-9a-fx]+)\\]\n  mov.w\tr0, #0x620000\n  bl\t#(?P<open_device>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<unkn_10620005>[0-9a-fx]+)\\]\n  add.w\tr2, r4, #(?P<rel_serial_nb_0>[0-9a-fx]+)\n  bl\t#(?P<enable_device>[0-9a-fx]+)\n  movs\tr0, #1\n  strb.w\tr0, \\[r4, #(?P<byte_20419720>[0-9a-fx]+)\\]\n  movs\tr0, #0\n  strb.w\tr0, \\[r4, #(?P<byte_20419721>[0-9a-fx]+)\\]\n  add.w\tr0, r4, #(?P<rel_serial_nb_1>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_navi>[0-9a-fx]+)\n  mov\tr5, r0\n  bl\t#(?P<strcpy_1>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_space1>[0-9a-fx]+)\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_product_model>[0-9a-fx]+)\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_space1>[0-9a-fx]+)\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  mov\tr1, sp\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  addw\tr0, r4, #(?P<rel_serial_nb_2>[0-9a-fx]+)\n  movs\tr1, #0x21\n  mov\tr5, r0\n  bl\t#(?P<sub_4EB780>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_20413254>[0-9a-fx]+)\\]\n  movs\tr2, #0x21\n  mov\tr1, r5\n  bl\t#(?P<sub_4EC598>[0-9a-fx]+)\n  bl\t#(?P<sub_44F07E>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_4B9060>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<word_20437EB4>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_byte_20437EDA>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_4B9060>[0-9a-fx]+)\n  ldr.w\tr0, \\[r4, #(?P<rel_dword_20436038>[0-9a-fx]+)\\]\n  orr\tr0, r0, #2\n  str.w\tr0, \\[r4, #(?P<rel_dword_20436038>[0-9a-fx]+)\\]\nloc_4B9060:\n  movs\tr0, #(?P<const_val_1>[0-9a-fx]+)\n  strb.w\tr0, \\[r4, #(?P<rel_byte_2041971F>[0-9a-fx]+)\\]\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,8}), pc}\n\"\"\",\n'vars': {\n  'navi_init':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'enable_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memcpy_0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'open_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'strcat':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'strcpy_1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4EB780':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_4EC598':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_44F07E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_4B9060':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  # \"20160707|163948\",0\n  'cstr_build_datetime':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"NAVI\"\n  'cstr_navi':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # ie. \"wm330v2\"\n  'cstr_product_model':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \" \"\n  'cstr_space1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'unk_20413254':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'word_20437EB4':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT16_T},\n  'byte_20419720':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'byte_20419721':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_serial_nb_0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_serial_nb_1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_serial_nb_2':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'unkn_20418DE8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkn_10620005':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_byte_2041971F':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_navi_version':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_unkn_1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_byte_20437EDA':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_20436038':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'const_val_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'mc_version_3a':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\nre_func_navi_init_WM220_V03_01_10_93 = {\n'name': \"navi_init\",\n'version': \"wm220_0306_v03.01.10.93\",\n're': \"\"\"\nnavi_init:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,8}), lr}\n  adr\tr0, #(?P<cstr_build_datetime>[0-9a-fx]+)\n  ldr\tr4, \\[pc, #(?P<unkn_20418DE8>[0-9a-fx]+)\\]\n  ldm\tr0, {r0, r1, r2, r3}\n  stm.w\tsp, {r0, r1, r2, r3}\n  ldr\tr0, \\[pc, #(?P<mc_version_3a>[0-9a-fx]+)\\]\n  movs\tr1, #3\n  str.w\tr0, \\[r4, #(?P<rel_navi_version>[0-9a-fx]+)\\]\n  mov.w\tr0, #0x620000\n  addw\tr4, r4, #(?P<rel_unkn_1>[0-9a-fx]+)\n  bl\t#(?P<open_device>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<serial_nb_0>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<unkn_10620005>[0-9a-fx]+)\\]\n  subs\tr2, #0x3a\n  bl\t#(?P<enable_device>[0-9a-fx]+)\n  movs\tr0, #1\n  strb\tr0, \\[r4, #(?P<byte_20419720>[0-9a-fx]+)\\]\n  movs\tr0, #0\n  strb\tr0, \\[r4, #(?P<byte_20419721>[0-9a-fx]+)\\]\n  ldr\tr0, \\[pc, #(?P<serial_nb_0>[0-9a-fx]+)\\]\n  adr\tr1, #(?P<cstr_navi>[0-9a-fx]+)\n  subs\tr0, #0x32\n  mov\tr5, r0\n  bl\t#(?P<strcpy_1>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_space1>[0-9a-fx]+)\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_product_model>[0-9a-fx]+)\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_space1>[0-9a-fx]+)\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  mov\tr1, sp\n  mov\tr0, r5\n  bl\t#(?P<strcat>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<serial_nb_0>[0-9a-fx]+)\\]\n  movs\tr2, #0x10\n  mov\tr1, sp\n  adds\tr0, #0x54\n  bl\t#(?P<memcpy_0>[0-9a-fx]+)\n  movs\tr0, #(?P<const_val_1>[0-9a-fx]+)\n  strb\tr0, \\[r4, #(?P<rel_byte_2041971F>[0-9a-fx]+)\\]\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,8}), pc}\n\"\"\",\n'vars': {\n  'navi_init':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'enable_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memcpy_0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'open_device':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'strcat':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'strcpy_1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'cstr_build_datetime':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_navi':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_product_model':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_space1':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'byte_20419720':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'byte_20419721':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'serial_nb_0':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkn_20418DE8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unkn_10620005':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_byte_2041971F':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_navi_version':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_unkn_1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'const_val_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'mc_version_3a':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\n\nre_func_init_config_table_version_WM330_V03_01_10_93 = {\n'name': \"init_config_table_version\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\ninit_config_table_version:\n  push\t{r4, lr}\n  ldr\tr4, \\[pc, #(?P<mc_version_3b>[0-9a-fx]+)\\]\n  bl\t#(?P<get_version_4384>[0-9a-fx]+)\n  cmp\tr0, r4\n  beq\t#(?P<loc_541300>[0-9a-fx]+)\n  mov\tr0, r4\n  bl\t#(?P<set_version_4384>[0-9a-fx]+)\n  movs\tr0, #1\n  pop\t{r4, pc}\nloc_541300:\n  movs\tr0, #0\n  pop\t{r4, pc}\n\"\"\",\n'vars': {\n  'init_config_table_version':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_version_4384':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_version_4384':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_541300':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'mc_version_3b':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\nre_func_init_config_table_version_WM220_V03_01_10_93 = {\n'name': \"init_config_table_version\",\n'version': \"wm220_0306_v03.01.10.93\",\n're': \"\"\"\ninit_config_table_version:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,4}), lr}\n  mov\tr0, sp\n  ; block of code, in wm220_0306_v03.02.35.05 is 4 words long:\n  ;bl\t#(?P<get_version_4384>[0-9a-fx]+)\n  ;bl\t#(?P<set_hw_version>[0-9a-fx]+)\n  ; block of code, in wm220_0306_v03.02.13.12 is 2 words long:\n  ;bl\t#(?P<get_version_4384>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){2,8})\n  ldr\tr0, \\[pc, #(?P<mc_version_3b>[0-9a-fx]+)\\]\n  ldr\tr1, \\[sp\\]\n  cmp\tr1, r0\n  bne\t#(?P<loc_5412EE>[0-9a-fx]+)\n  ldrb.w\tr1, \\[sp, #4\\]\n  cmp\tr1, #(?P<const_val_1a>[0-9a-fx]+)\n  beq\t#(?P<loc_541300>[0-9a-fx]+)\nloc_5412EE:\n  str\tr0, \\[sp\\]\n  movs\tr0, #(?P<const_val_1b>[0-9a-fx]+)\n  strb.w\tr0, \\[sp, #4\\]\n  mov\tr0, sp\n  bl\t#(?P<set_version_4384>[0-9a-fx]+)\n  movs\tr0, #1\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,4}), pc}\nloc_541300:\n  movs\tr0, #0\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,4}), pc}\n\"\"\",\n'vars': {\n  'init_config_table_version':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_version_4384':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_hw_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_version_4384':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_5412EE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_541300':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'const_val_1a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'const_val_1b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'mc_version_3b':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\n\nre_func_log_version_info_P3X_FW_V01_07_0060 = {\n'name': \"log_version_info\",\n'version': \"P3X_FW_V01.07.0060\",\n're': \"\"\"\nlog_version_info:\n  push\t{lr}\n  sub\tsp, #0x14\n  add\tr0, sp, #8\n  bl\t#(?P<get_mc_ident>[0-9a-fx]+)\n  add\tr2, sp, #8\n  adr\tr1, #(?P<cstr_fmt_mc_id>[0-9a-fx]+)\n  movs\tr0, #0xfe\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  movs\tr1, #(?P<mc_ver_revsn>[0-9a-fx]+)\n  movs\tr0, #(?P<mc_ver_mmtnc>[0-9a-fx]+)\n  strd\tr0, r1, \\[sp\\]\n  movs\tr3, #(?P<mc_ver_minor>[0-9a-fx]+)\n  movs\tr2, #(?P<mc_ver_major>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_fmt_mc_ver>[0-9a-fx]+)\n  movs\tr0, #0xfe\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_20404E98>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_battery_version>[0-9a-fx]+)\\]\n  uxtb\tr2, r0\n  ubfx\tr1, r0, #8, #8\n  strd\tr1, r2, \\[sp\\]\n  lsrs\tr2, r0, #0x18\n  ubfx\tr3, r0, #0x10, #8\n  adr\tr1, #(?P<cstr_fmt_bat_ver>[0-9a-fx]+)\n  movs\tr0, #0xfe\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  adr\tr2, #(?P<cstr_repo_revision>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_fmt_svn_ver>[0-9a-fx]+)\n  movs\tr0, #0xfe\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  adr\tr2, #(?P<cstr_repo_build_date>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_fmt_time>[0-9a-fx]+)\n  movs\tr0, #0xfe\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  add\tsp, #0x14\n  pop\t{pc}\n\"\"\",\n'vars': {\n  'log_version_info':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'log_printf_info':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_mc_ident':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  # \"Mc  ID  :%s\"\n  'cstr_fmt_mc_id':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Mc  Ver :v%d.%d.%d.%d\"\n  'cstr_fmt_mc_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Bat Ver :v%d.%d.%d.%d\"\n  'cstr_fmt_bat_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"svn Ver :%s\"\n  'cstr_fmt_svn_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Time    :%s\"\n  'cstr_fmt_time':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # ie. \"commit:2016-07-07 16:39:58 /build:2016-07-07 16:41:31 \",0\n  'cstr_repo_build_date':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # ie. \"f824fd4656cb8e42128d3450985004f754a3f2f3\",0\n  'cstr_repo_revision':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'byte_20435FE2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'dword_20404E98':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_battery_version':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'mc_ver_major':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,1))},\n  'mc_ver_minor':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,2))},\n  'mc_ver_mmtnc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,3))},\n  'mc_ver_revsn':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,4))},\n},\n}\n\nre_func_log_version_info_WM330_V03_01_10_93 = {\n'name': \"log_version_info\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nlog_version_info:\n  push\t{r0, r1, r2, r3, r4, lr}\n  ldr\tr0, \\[pc, #(?P<byte_20435FE2>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  ldr\tr2, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  adr\tr3, #(?P<cstr_fmt_mc_id>[0-9a-fx]+)\n  str\tr0, \\[sp\\]\n  movs\tr0, #3\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  movs\tr3, #(?P<mc_ver_revsn>[0-9a-fx]+)\n  movs\tr2, #(?P<mc_ver_mmtnc>[0-9a-fx]+)\n  movs\tr1, #(?P<mc_ver_minor>[0-9a-fx]+)\n  movs\tr0, #(?P<mc_ver_major>[0-9a-fx]+)\n  stm.w\tsp, {r0, r1, r2, r3}\n  ldr\tr2, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  adr\tr3, #(?P<cstr_fmt_mc_ver>[0-9a-fx]+)\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_20404E98>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_battery_version>[0-9a-fx]+)\\]\n  uxtb\tr2, r0\n  ubfx\tr1, r0, #8, #8\n  ubfx\tr3, r0, #0x10, #8\n  lsrs\tr0, r0, #0x18\n  strd\tr1, r2, \\[sp, #8\\]\n  strd\tr0, r3, \\[sp\\]\n  ldr\tr2, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  movs\tr0, #3\n  adr\tr3, #(?P<cstr_fmt_bat_ver>[0-9a-fx]+)\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_repo_revision>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  str\tr0, \\[sp\\]\n  movs\tr0, #3\n  adr\tr3, #(?P<cstr_fmt_svn_ver>[0-9a-fx]+)\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  adr\tr0, #(?P<cstr_repo_build_date>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<cstr_func_name>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  str\tr0, \\[sp\\]\n  movs\tr0, #3\n  adr\tr3, #(?P<cstr_fmt_time>[0-9a-fx]+)\n  bl\t#(?P<log_printf_info>[0-9a-fx]+)\n  pop\t{r0, r1, r2, r3, r4, pc}\n\"\"\",\n'vars': {\n  'log_version_info':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'log_printf_info':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  # \"log_system_info\"\n  'cstr_func_name':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Mc  ID  :%s\"\n  'cstr_fmt_mc_id':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Mc  Ver :v%d.%d.%d.%d\"\n  'cstr_fmt_mc_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Bat Ver :v%d.%d.%d.%d\"\n  'cstr_fmt_bat_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"svn Ver :%s\"\n  'cstr_fmt_svn_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # \"Time    :%s\"\n  'cstr_fmt_time':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # ie. \"commit:2016-07-07 16:39:58 /build:2016-07-07 16:41:31 \",0\n  'cstr_repo_build_date':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  # ie. \"f824fd4656cb8e42128d3450985004f754a3f2f3\",0\n  'cstr_repo_revision':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'byte_20435FE2':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'dword_20404E98':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_battery_version':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'mc_ver_major':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,1))},\n  'mc_ver_minor':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,2))},\n  'mc_ver_mmtnc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,3))},\n  'mc_ver_revsn':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,4))},\n},\n}\n\nre_func_log_version_info_WM220_V03_01_10_93 = {\n'name': \"log_version_info\",\n'version': \"wm220_0306_v03.01.10.93\",\n're': \"\"\"\nlog_version_info:\n  push\t{r2, r3, r4, r5, r6, lr}\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #5\n  adr\tr1, #(?P<cstr_fmt_mc_id>[0-9a-fx]+)\n  ldr\tr2, \\[pc, #(?P<serial_nb_0>[0-9a-fx]+)\\]\n  blx\tr3\n  movs\tr1, #(?P<mc_ver_revsn>[0-9a-fx]+)\n  movs\tr0, #(?P<mc_ver_mmtnc>[0-9a-fx]+)\n  strd\tr0, r1, \\[sp\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr4, \\[r0, #0xc\\]\n  movs\tr3, #(?P<mc_ver_minor>[0-9a-fx]+)\n  movs\tr2, #(?P<mc_ver_major>[0-9a-fx]+)\n  movs\tr0, #5\n  adr\tr1, #(?P<cstr_fmt_mc_ver>[0-9a-fx]+)\n  blx\tr4\n  ldr\tr5, \\[pc, #(?P<dword_20405E40>[0-9a-fx]+)\\]\n  ldrh\tr0, \\[r5, #(?P<rel_battery_version>[0-9a-fx]+)\\]\n  uxtb\tr1, r0\n  ubfx\tr0, r0, #8, #8\n  strd\tr0, r1, \\[sp\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr4, \\[r0, #0xc\\]\n  adr\tr1, #(?P<cstr_fmt_bat_ver>[0-9a-fx]+)\n  ldr\tr0, \\[r5, #(?P<rel_battery_version>[0-9a-fx]+)\\]\n  lsrs\tr2, r0, #0x18\n  ubfx\tr3, r0, #0x10, #8\n  movs\tr0, #5\n  blx\tr4\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  movs\tr0, #5\n  adr\tr2, #(?P<cstr_repo_revision>[0-9a-fx]+)\n  adr\tr1, #(?P<cstr_fmt_svn_ver>[0-9a-fx]+)\n  blx\tr3\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr3, \\[r0, #0xc\\]\n  add\tsp, #8\n  movs\tr0, #5\n  adr\tr2, #(?P<cstr_repo_build_date>[0-9a-fx]+)\n  pop.w\t{r4, r5, r6, lr}\n  adr\tr1, #(?P<cstr_fmt_time>[0-9a-fx]+)\n  bx\tr3\n\"\"\",\n'vars': {\n  'log_version_info':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'cstr_fmt_bat_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_fmt_mc_id':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_fmt_mc_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_fmt_svn_ver':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_fmt_time':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_repo_build_date':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_repo_revision':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'dword_20405E40':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_battery_version':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'serial_nb_0':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'mc_ver_major':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,1))},\n  'mc_ver_minor':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,2))},\n  'mc_ver_mmtnc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,3))},\n  'mc_ver_revsn':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': (lambda val: version_string_to_parts_getter(val,4))},\n},\n}\n\n\nre_func_version_check_sub1_WM330_V03_01_10_93 = {\n'name': \"version_check_sub1\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nversion_check_sub1:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){10,16}), lr}\n  ldr\tr5, \\[pc, #(?P<byte_20402ECE>[0-9a-fx]+)\\]\n  movs\tr0, #0\n  mov\tr4, r0\n  str\tr0, \\[sp\\]\n  str\tr0, \\[sp, #4\\]\n  str\tr0, \\[sp, #8\\]\n  strh.w\tr0, \\[sp, #0xc\\]\n  ldrb\tr1, \\[r5, #(?P<rel_byte_20402ECF>[0-9a-fx]+)\\]\n  cmp\tr1, #0\n  bne\t#(?P<locret_45FEE6>[0-9a-fx]+)\n  movs\tr6, #1\n  mov\tsb, r0\n  mov\tsl, sp\n  strb\tr6, \\[r5, #(?P<rel_byte_20402ECF>[0-9a-fx]+)\\]\nloc_45FE24:\n  bl\t#(?P<get_fmu_dm>[0-9a-fx]+)\n  ldr.w\tr3, \\[r0, #(?P<field_dm_callback_B4a>[0-9a-fx]+)\\]\n  add\tr2, sp, #0xc\n  mov\tr1, sp\n  mov\tr0, r4\n  blx\tr3\n  cbnz\tr0, #(?P<loc_45FE52>[0-9a-fx]+)\n  movs\tr1, #0\n  mov\tr0, sb\n  mov\tr2, sl\n  b\t#(?P<loc_45FE4A>[0-9a-fx]+)\nloc_45FE3E:\n  ldr.w\tr3, \\[r2, r1, lsl #2\\]\n  adds\tr1, r1, #1\n  uxtb\tr1, r1\n  strb.w\tr0, \\[r3, #(?P<field_var48_ofs38a>[0-9a-fx]+)\\]\nloc_45FE4A:\n  ldrh.w\tr3, \\[sp, #0xc\\]\n  cmp\tr1, r3\n  blo\t#(?P<loc_45FE3E>[0-9a-fx]+)\nloc_45FE52:\n  adds\tr4, r4, #1\n  uxtb\tr4, r4\n  cmp\tr4, #(?P<const_loop_limit_1>[0-9a-fx]+)\n  blo\t#(?P<loc_45FE24>[0-9a-fx]+)\n  movs\tr4, #0\n  mov\tfp, r5\n  b\t#(?P<loc_45FEDE>[0-9a-fx]+)\nloc_45FE60:\n  ldr\tr7, \\[pc, #(?P<pvstru_D61C>[0-9a-fx]+)\\]\n  add.w\tr5, r4, r4, lsl #1\n  add.w\tr8, r7, r5, lsl #2\n  ldr.w\tr0, \\[r8, #8\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_45FEDA>[0-9a-fx]+)\n  bl\t#(?P<get_fmu_dm>[0-9a-fx]+)\n  ldr.w\tr3, \\[r0, #(?P<field_dm_callback_B4b>[0-9a-fx]+)\\]\n  add\tr2, sp, #0xc\n  ldrb.w\tr0, \\[r7, r5, lsl #2\\]\n  mov\tr1, sp\n  blx\tr3\n  movs\tr0, #0\n  mov\tr7, sb\n  mov\tr5, sl\n  b\t#(?P<loc_45FEA0>[0-9a-fx]+)\nloc_45FE8C:\n  ldr.w\tr1, \\[r5, r0, lsl #2\\]\n  strb.w\tr6, \\[r1, #(?P<field_var48_ofs38b>[0-9a-fx]+)\\]\n  ldr.w\tr1, \\[r5, r0, lsl #2\\]\n  adds\tr0, r0, #1\n  uxtb\tr0, r0\n  strb.w\tr7, \\[r1, #(?P<field_var48_ofs3Aa>[0-9a-fx]+)\\]\nloc_45FEA0:\n  ldrh.w\tr1, \\[sp, #0xc\\]\n  cmp\tr0, r1\n  blo\t#(?P<loc_45FE8C>[0-9a-fx]+)\n  bl\t#(?P<get_fmu_dm>[0-9a-fx]+)\n  ldr.w\tr3, \\[r0, #(?P<field_dm_callback_B4c>[0-9a-fx]+)\\]\n  add\tr2, sp, #0xc\n  ldrb.w\tr0, \\[r8, #1\\]\n  mov\tr1, sp\n  blx\tr3\n  movs\tr0, #0\n  b\t#(?P<loc_45FED2>[0-9a-fx]+)\nloc_45FEBE:\n  ldr.w\tr1, \\[r5, r0, lsl #2\\]\n  strb.w\tr6, \\[r1, #(?P<field_var48_ofs38c>[0-9a-fx]+)\\]\n  ldr.w\tr1, \\[r5, r0, lsl #2\\]\n  adds\tr0, r0, #1\n  uxtb\tr0, r0\n  strb.w\tr7, \\[r1, #(?P<field_var48_ofs3Ab>[0-9a-fx]+)\\]\nloc_45FED2:\n  ldrh.w\tr1, \\[sp, #0xc\\]\n  cmp\tr0, r1\n  blo\t#(?P<loc_45FEBE>[0-9a-fx]+)\nloc_45FEDA:\n  adds\tr4, r4, #1\n  uxtb\tr4, r4\nloc_45FEDE:\n  ldrb.w\tr0, \\[fp\\]\n  cmp\tr4, r0\n  blo\t#(?P<loc_45FE60>[0-9a-fx]+)\nlocret_45FEE6:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){10,16}), pc}\n\"\"\",\n'vars': {\n  'version_check_sub1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_fmu_dm':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_45FE24':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FE3E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FE4A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FE52':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FE60':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FE8C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FEA0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FEBE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FED2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FEDA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FEDE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'locret_45FEE6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'field_dm_callback_B4a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_dm_callback_B4b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_dm_callback_B4c':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs38a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs38b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs38c':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Aa':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ab':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'const_loop_limit_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'byte_20402ECE':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'pvstru_D61C':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\",\n    'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'rel_byte_20402ECF':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n},\n}\n\nre_func_version_check_WM330_V03_01_10_93 = {\n'name': \"version_check\",\n'version': \"wm330_0306_v03.01.10.93\",\n're': \"\"\"\nversion_check:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,10}), lr}\n  mov\tr5, r0\n  ldr\tr0, \\[pc, #(?P<unkval_9DE8>[0-9a-fx]+)\\]\n  mov.w\tsb, #0\n  sub\tsp, #0x24\n  mov\tr4, sb\n  ldrb.w\tr0, \\[r0, #(?P<rel_simulator_running>[0-9a-fx]+)\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_45FF4E>[0-9a-fx]+)\n  bl\t#(?P<version_check_sub1>[0-9a-fx]+)\n  movs\tr0, #0\n  mov\tsl, sp\n  add.w\tr8, sp, #0x10\n  mov.w\tfp, #1\n  strb\tr0, \\[r5, #2\\]\n  b\t#(?P<loc_4600B2>[0-9a-fx]+)\nloc_45FF4E:\n  movs\tr0, #(?P<const_val_sim_a>[0-9a-fx]+)\n  strb\tr0, \\[r5\\]\n  strb\tr0, \\[r5, #1\\]\n  strb\tr4, \\[r5, #2\\]\n  b\t#(?P<loc_4601B0>[0-9a-fx]+)\nloc_45FF58:\n  ldr\tr6, \\[pc, #(?P<pvstru_D61C>[0-9a-fx]+)\\]\n  add.w\tr4, sb, sb, lsl #1\n  add.w\tr7, r6, r4, lsl #2\n  ldr\tr0, \\[r7, #8\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_45FFF4>[0-9a-fx]+)\n  movs\tr0, #0\n  str\tr0, \\[sp\\]\n  str\tr0, \\[sp, #4\\]\n  str\tr0, \\[sp, #8\\]\n  strh.w\tr0, \\[sp, #0xc\\]\n  str\tr0, \\[sp, #0x10\\]\n  str\tr0, \\[sp, #0x14\\]\n  str\tr0, \\[sp, #0x18\\]\n  strh.w\tr0, \\[sp, #0x1c\\]\n  bl\t#(?P<get_fmu_dm>[0-9a-fx]+)\n  ldr.w\tr3, \\[r0, #(?P<field_dm_callback_B4a>[0-9a-fx]+)\\] ; known values: 0xb4 0xb8\n  add\tr2, sp, #0xc\n  ldrb.w\tr0, \\[r6, r4, lsl #2\\]\n  mov\tr1, sp\n  blx\tr3\n  bl\t#(?P<get_fmu_dm>[0-9a-fx]+)\n  ldr.w\tr3, \\[r0, #(?P<field_dm_callback_B4b>[0-9a-fx]+)\\]\n  add\tr2, sp, #0x1c\n  add\tr1, sp, #0x10\n  ldrb\tr0, \\[r7, #1\\]\n  blx\tr3\n  ldrb.w\tr0, \\[r6, r4, lsl #2\\]\n  ldrb\tr1, \\[r7, #1\\]\n  cmp\tr0, r1\n  bne\t#(?P<loc_46003A>[0-9a-fx]+)\n  ldr\tr0, \\[r7, #4\\]\n  movs\tr4, #0\n  cbnz\tr0, #(?P<loc_46002C>[0-9a-fx]+)\n  movs\tr4, #1\n  mov\tr6, sl\n  b\t#(?P<loc_45FFEC>[0-9a-fx]+)\nloc_45FFB6:\n  ldr\tr0, \\[sp\\]\n  movs\tr2, #2\n  ldr\tr1, \\[r0, #(?P<field_var48_ofs34a>[0-9a-fx]+)\\]\n  ldr.w\tr0, \\[r6, r4, lsl #2\\]\n  ldr\tr0, \\[r0, #(?P<field_var48_ofs34b>[0-9a-fx]+)\\]\n  bl\t#(?P<sub_45FEEA>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_45FFE8>[0-9a-fx]+)\n  ldr.w\tr0, \\[r6, r4, lsl #2\\]\n  ldrb(.w)?\tr0, \\[r0, #(?P<field_var48_ofs0Ba>[0-9a-fx]+)\\]\n  lsls\tr0, r0, #0x1e\n  bne\t#(?P<loc_45FFD6>[0-9a-fx]+)\n  strb.w\tfp, \\[r5, #2\\]\nloc_45FFD6:\n  ldr.w\tr1, \\[r6, r4, lsl #2\\]\n  ldrb.w\tr0, \\[r1, #(?P<field_var48_ofs3Aa>[0-9a-fx]+)\\]\n  cmp\tr0, #0xc8\n  bhs\t#(?P<loc_45FFE8>[0-9a-fx]+)\n  adds\tr0, r0, #1\n  strb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ab>[0-9a-fx]+)\\]\nloc_45FFE8:\n  adds\tr4, r4, #1\n  uxth\tr4, r4\nloc_45FFEC:\n  ldrh.w\tr0, \\[sp, #0xc\\]\n  cmp\tr4, r0\n  blo\t#(?P<loc_45FFB6>[0-9a-fx]+)\nloc_45FFF4:\n  b\t#(?P<loc_4600AA>[0-9a-fx]+)\nloc_45FFF6:\n  ldr.w\tr0, \\[sl, r4, lsl #2\\]\n  mov\tr6, sl\n  ldrb\tr2, \\[r7, #2\\]\n  ldr\tr1, \\[r7, #4\\]\n  ldr\tr0, \\[r0, #(?P<field_var48_ofs34c>[0-9a-fx]+)\\]\n  bl\t#(?P<sub_45FEEA>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_460028>[0-9a-fx]+)\n  ldr.w\tr0, \\[r6, r4, lsl #2\\]\n  ldrb(.w)?\tr0, \\[r0, #(?P<field_var48_ofs0Bb>[0-9a-fx]+)\\]\n  lsls\tr0, r0, #0x1e\n  bne\t#(?P<loc_460016>[0-9a-fx]+)\n  strb.w\tfp, \\[r5, #2\\]\nloc_460016:\n  ldr.w\tr1, \\[r6, r4, lsl #2\\]\n  ldrb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ac>[0-9a-fx]+)\\]\n  cmp\tr0, #0xc8 ; 200\n  bhs\t#(?P<loc_460028>[0-9a-fx]+)\n  adds\tr0, r0, #1\n  ; block of code in wm220_0306_v03.01.10.93:\n  ;strb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ad>[0-9a-fx]+)\\]\n  ;loc_460028:\n  ;adds\tr4, r4, #1\n  ;b\t#(?P<loc_46002E>[0-9a-fx]+)\n  ;loc_46002C:\n  ;b\t#(?P<loc_460030>[0-9a-fx]+)\n  ; block of code in wm330_0306_v03.01.10.93:\n  ;b\t#loc_4D8E18\n  ;b\t#0x4d8e20\n  ;loc_4D8E18:\n  ;strb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ad>[0-9a-fx]+)\\]\n  ;loc_460028:\n  ;adds\tr4, r4, #1\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){5,8})\nloc_46002E:\n  uxth\tr4, r4\nloc_460030:\n  ldrh.w\tr0, \\[sp, #0xc\\]\n  cmp\tr4, r0\n  blo\t#(?P<loc_45FFF6>[0-9a-fx]+)\n  b\t#(?P<loc_4600AA>[0-9a-fx]+)\nloc_46003A:\n  movs\tr6, #0\n  b\t#(?P<loc_4600A2>[0-9a-fx]+)\nloc_46003E:\n  movs\tr4, #0\n  b\t#(?P<loc_460096>[0-9a-fx]+)\nloc_460042:\n  ldr.w\tr0, \\[r8, r4, lsl #2\\]\n  ldrb\tr2, \\[r7, #2\\]\n  ldr\tr1, \\[r0, #(?P<field_var48_ofs34d>[0-9a-fx]+)\\]\n  ldr.w\tr0, \\[sl, r6, lsl #2\\]\n  ldr\tr0, \\[r0, #(?P<field_var48_ofs34e>[0-9a-fx]+)\\]\n  bl\t#(?P<sub_45FEEA>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_460092>[0-9a-fx]+)\n  ldr.w\tr0, \\[sl, r6, lsl #2\\]\n  ldrb(.w)?\tr0, \\[r0, #(?P<field_var48_ofs0Bc>[0-9a-fx]+)\\]\n  lsls\tr0, r0, #0x1e\n  bne\t#(?P<loc_46006E>[0-9a-fx]+)\n  ldr.w\tr0, \\[r8, r4, lsl #2\\]\n  ldrb(.w)?\tr0, \\[r0, #(?P<field_var48_ofs0Bd>[0-9a-fx]+)\\]\n  lsls\tr0, r0, #0x1e\n  bne\t#(?P<loc_46006E>[0-9a-fx]+)\n  strb.w\tfp, \\[r5, #2\\]\nloc_46006E:\n  ldr.w\tr1, \\[sl, r6, lsl #2\\]\n  ldrb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ae>[0-9a-fx]+)\\]\n  cmp\tr0, #0xc8\n  bhs\t#(?P<loc_460080>[0-9a-fx]+)\n  adds\tr0, r0, #1\n  strb.w\tr0, \\[r1, #(?P<field_var48_ofs3Af>[0-9a-fx]+)\\]\nloc_460080:\n  ldr.w\tr1, \\[r8, r4, lsl #2\\]\n  ldrb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ag>[0-9a-fx]+)\\]\n  cmp\tr0, #0xc8 ; 200\n  bhs\t#(?P<loc_460092>[0-9a-fx]+)\n  adds\tr0, r0, #1\n  strb.w\tr0, \\[r1, #(?P<field_var48_ofs3Ah>[0-9a-fx]+)\\]\nloc_460092:\n  adds\tr4, r4, #1\n  uxth\tr4, r4\nloc_460096:\n  ldrh.w\tr0, \\[sp, #0x1c\\]\n  cmp\tr4, r0\n  blo\t#(?P<loc_460042>[0-9a-fx]+)\n  adds\tr6, r6, #1\n  uxth\tr6, r6\nloc_4600A2:\n  ldrh.w\tr0, \\[sp, #0xc\\]\n  cmp\tr6, r0\n  blo\t#(?P<loc_46003E>[0-9a-fx]+)\nloc_4600AA:\n  add.w\tr0, sb, #1\n  uxth.w\tsb, r0\nloc_4600B2:\n  ldr\tr1, \\[pc, #(?P<byte_20402ECE>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp\tsb, r1\n  blo.w\t#(?P<loc_45FF58>[0-9a-fx]+)\n  movs\tr6, #0\n  add\tr7, sp, #0x10\n  mov\tr8, r6\nloc_4600C2:\n  str.w\tr8, \\[sp, #0x10\\]\n  str.w\tr8, \\[sp, #0x14\\]\n  str.w\tr8, \\[sp, #0x18\\]\n  strh.w\tr8, \\[sp, #0xc\\]\n  bl\t#(?P<get_fmu_dm>[0-9a-fx]+)\n  ldr.w\tr3, \\[r0, #(?P<field_dm_callback_B4c>[0-9a-fx]+)\\]\n  add\tr2, sp, #0xc\n  add\tr1, sp, #0x10\n  uxtb\tr0, r6\n  blx\tr3\n  cbnz\tr0, #(?P<loc_460152>[0-9a-fx]+)\n  movs\tr4, #0\n  b\t#(?P<loc_460170>[0-9a-fx]+)\nloc_4600E8:\n  ldr.w\tr0, \\[r7, r4, lsl #2\\]\n  ldrb.w\tr1, \\[r0, #(?P<field_var48_ofs38a>[0-9a-fx]+)\\]\n  cbz\tr1, #(?P<loc_460154>[0-9a-fx]+)\n  cmp\tr6, #(3|5)\n  beq\t#(?P<loc_46016C>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r0, #(?P<field_var48_ofs3Ai>[0-9a-fx]+)\\]\n  cbz\tr1, #(?P<loc_460132>[0-9a-fx]+)\n  ldr\tr1, \\[r0, #(?P<field_var48_ofs34f>[0-9a-fx]+)\\]\n  cbnz\tr1, #(?P<loc_460108>[0-9a-fx]+)\n  ldrb.w\tr2, \\[r0, #(?P<field_var48_ofs39a>[0-9a-fx]+)\\]\n  cmp\tr2, #2\n  beq\t#(?P<loc_460164>[0-9a-fx]+)\nloc_460108:\n  ldrb.w\tr0, \\[r0, #(?P<field_var48_ofs39b>[0-9a-fx]+)\\]\n  cbz\tr0, #(?P<loc_460128>[0-9a-fx]+)\n  str\tr1, \\[sp\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr.w\tip, \\[r0, #0xc\\]\n  ; block of code in wm220_0306_v03.01.10.93:\n  ;adr\tr1, #(?P<cstr_fmt_ver_check_fail>[0-9a-fx]+)\n  ;ldr.w\tr0, \\[r7, r4, lsl #2\\]\n  ;ldrb\tr3, \\[r0, #0xa\\]\n  ;ldr.w\tr2, \\[r0, #2\\]\n  ;movs\tr0, #5\n  ; block of code in wm330_0306_v03.01.10.93:\n  ;ldr.w\tr0, \\[r7, r4, lsl #2\\]\n  ;ldrb.w\tr1, [r0, #0x2a]\n  ;ldr.w\tr2, [r0, #2]\n  ;movs\tr0, #4\n  ;and\tr3, r1, #0x7f\n  ;adr\tr1, #(?P<cstr_fmt_ver_check_fail>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){7,12})\n  blx\tip\nloc_460128:\n  ldr.w\tr1, \\[r7, r4, lsl #2\\]\n  strb.w\tr8, \\[r1, #(?P<field_var48_ofs39c>[0-9a-fx]+)\\]\n  b\t#(?P<loc_460164>[0-9a-fx]+)\nloc_460132:\n  ldrb.w\tr1, \\[r0, #(?P<field_var48_ofs39d>[0-9a-fx]+)\\]\n  cmp\tr1, #1\n  beq\t#(?P<loc_46015C>[0-9a-fx]+)\n  ldr\tr0, \\[r0, #(?P<field_var48_ofs34g>[0-9a-fx]+)\\]\n  str\tr0, \\[sp\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr.w\tip, \\[r0, #0xc\\]\n  ldr.w\tr0, \\[r7, r4, lsl #2\\]\n  ldrb(.w)?\t(r3|r1), \\[r0, #(?P<field_var48_ofs0Aa>[0-9a-fx]+)\\]\n  ; block of code in wm220_0306_v03.01.10.93:\n  ;ldr.w\tr2, \\[r0, #2\\]\n  ; block of code in wm330_0306_v03.01.10.93:\n  ;ldr.w\tr2, \\[r0, #2\\]\n  ;and\tr3, r1, #0x7f\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){2,4})\n  b\t#(?P<loc_460156>[0-9a-fx]+)\nloc_460152:\n  b\t#(?P<loc_460178>[0-9a-fx]+)\nloc_460154:\n  b\t#(?P<loc_46016C>[0-9a-fx]+)\nloc_460156:\n  movs\tr0, #(5|4)\n  adr\tr1, #(?P<cstr_fmt_ver_check_pass>[0-9a-fx]+)\n  blx\tip\nloc_46015C:\n  ldr.w\tr1, \\[r7, r4, lsl #2\\]\n  strb.w\tfp, \\[r1, #(?P<field_var48_ofs39e>[0-9a-fx]+)\\]\nloc_460164:\n  ldr.w\tr1, \\[r7, r4, lsl #2\\]\n  strb.w\tr8, \\[r1, #(?P<field_var48_ofs3Aj>[0-9a-fx]+)\\]\nloc_46016C:\n  adds\tr4, r4, #1\n  uxth\tr4, r4\nloc_460170:\n  ldrh.w\tr0, \\[sp, #0xc\\]\n  cmp\tr4, r0\n  blo\t#(?P<loc_4600E8>[0-9a-fx]+)\nloc_460178:\n  adds\tr6, r6, #1\n  uxth\tr6, r6\n  cmp\tr6, #(?P<const_loop_limit_1>[0-9a-fx]+) ; known values 0x23 0x24\n  blo\t#(?P<loc_4600C2>[0-9a-fx]+)\n  ldrb\tr0, \\[r5, #2\\]\n  cmp\tr0, #1\n  beq\t#(?P<loc_460192>[0-9a-fx]+)\n  movs\tr0, #(?P<const_val_sim_b>[0-9a-fx]+) ; known values 0x24 0x25\n  strb\tr0, \\[r5\\]\n  strb\tr0, \\[r5, #1\\]\n  strb.w\tr8, \\[r5, #2\\]\n  b\t#(?P<loc_4601B0>[0-9a-fx]+)\nloc_460192:\n  ldr\tr1, \\[pc, #(?P<byte_20402ECE>[0-9a-fx]+)\\]\n  ldrb\tr0, \\[r1, #(?P<rel_byte_20402ED0>[0-9a-fx]+)\\]\n  cmp\tr0, #0x32\n  bhs\t#(?P<loc_4601A0>[0-9a-fx]+)\n  adds\tr0, r0, #1\n  strb\tr0, \\[r1, #(?P<rel_byte_20402ED0>[0-9a-fx]+)\\]\n  b\t#(?P<loc_4601B0>[0-9a-fx]+)\nloc_4601A0:\n  strb.w\tr8, \\[r1, #(?P<rel_byte_20402ED0>[0-9a-fx]+)\\]\n  bl\t#(?P<get_logger>[0-9a-fx]+)\n  ldr\tr2, \\[r0, #4\\]\n  movs\tr0, #(5|4)\n  adr\tr1, #(?P<cstr_invalid_version>[0-9a-fx]+)\n  blx\tr2\nloc_4601B0:\n  add\tsp, #0x24\n  movs\tr0, #1\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){6,10}), pc}\n\"\"\",\n'vars': {\n  'version_check':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_fmu_dm':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_logger':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_45FEEA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'version_check_sub1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_45FF4E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FF58':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FFB6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FFD6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FFE8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FFEC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FFF4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_45FFF6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460016':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460028':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_46002C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_46002E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_460030':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_46003A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_46003E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460042':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_46006E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460080':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460092':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460096':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4600A2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4600AA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4600B2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4600C2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4600E8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460108':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460128':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460132':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460152':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460154':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460156':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_46015C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460164':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_46016C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460170':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460178':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_460192':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4601A0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_4601B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (5,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (7,12)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,4)},\n  #'cstr_fmt_ver_check_fail':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_fmt_ver_check_pass':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_invalid_version':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'const_val_sim_a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'const_val_sim_b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T},\n  'field_dm_callback_B4a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_dm_callback_B4b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_dm_callback_B4c':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34c':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34d':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34e':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34f':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs34g':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs38a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs39a':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs39b':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs39c':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs39d':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs39e':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs0Aa':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs0Ba':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs0Bb':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs0Bc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs0Bd':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Aa':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ab':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ac':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ae':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Af':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ag':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ah':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Ai':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'field_var48_ofs3Aj':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'const_loop_limit_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T},\n  'byte_20402ECE':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'pvstru_D61C':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\",\n    'variety': DataVariety.STRUCT, 'struct': DummyStruct},\n  'rel_byte_20402ED0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'rel_simulator_running':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'unkval_9DE8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n},\n}\n\nre_func_pvstru_D61C_WM330_V03_01_10_93 = {\n'name': \"pvstru_D61C\",\n'version': \"wm330_0306_v03.01.10.93\",\n'no_search': True,\n're': \"\"\"\npvstru_D61C:\n  ; array entry 0\n  dcb\t(0x5|0x3), (0x5|0x3), 0x2, 0x0\n  dcd\t(?P<pvstru_D61C_0_mc_version>[0-9a-fx]+)\n  dcd\t0x1\n\"\"\",\n'vars': {\n  'pvstru_D61C':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'pvstru_D61C_0_mc_version':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT32_T,\n    'public': \"og_hardcoded.flyc\", 'depend': \"firmware_version\", 'getter': version_string_to_int_getter},\n},\n}\n\n\nre_general_list = [\n  {'sect': \".text\", 'func': re_func_wp_check_input_mission_validity_P3X_V01_05_0030,},\n  {'sect': \".text\", 'func': re_func_wp_check_input_mission_validity_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_wp_mission_data_verify_P3X_V01_05_0030,},\n  {'sect': \".text\", 'func': re_func_wp_mission_data_verify_WM330_V03_01_10_93,},\n  {'sect': \".data\", 'func': re_func_firmware_release_marking_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_check_activation_authority_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_check_activation_authority_WM220_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_check_activation_authority_WM220_V03_02_13_12,},\n  {'sect': \".text\", 'func': re_func_system_init_P3X_FW_V01_07_0060,},\n  {'sect': \".text\", 'func': re_func_imu_init_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_imu_init_WM220_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_hal_push_mc_version_P3X_FW_V01_07_0060,},\n  {'sect': \".text\", 'func': re_func_hal_push_mc_version_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_navi_init_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_navi_init_WM220_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_init_config_table_version_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_init_config_table_version_WM220_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_log_version_info_P3X_FW_V01_07_0060,},\n  {'sect': \".text\", 'func': re_func_log_version_info_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_log_version_info_WM220_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_version_check_sub1_WM330_V03_01_10_93,},\n  {'sect': \".text\", 'func': re_func_version_check_WM330_V03_01_10_93,},\n  {'sect': \".data\", 'func': re_func_pvstru_D61C_WM330_V03_01_10_93,},\n]\n\ndef armfw_elf_flyc_list(po, elffh):\n    params_list, _, _, _, _, _ = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    # print list of parameter values\n    armfw_elf_paramvals_export_simple_list(po, params_list, sys.stdout)\n\n\ndef armfw_elf_flyc_mapfile(po, elffh):\n    _, params_list, elf_sections, _, _, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    armfw_elf_paramvals_export_mapfile(po, params_list, elf_sections, asm_arch, sys.stdout)\n\n\ndef armfw_elf_flyc_extract(po, elffh):\n    \"\"\" Extracts all values from firmware to JSON format text file.\n    \"\"\"\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    if len(params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    if not po.dry_run:\n        valfile = open(po.valfile, \"w\")\n    else:\n        valfile = io.StringIO()\n    armfw_elf_paramvals_export_json(po, params_list, valfile)\n    valfile.close()\n\n\ndef armfw_elf_flyc_update(po, elffh):\n    \"\"\" Updates all hardcoded values in firmware from JSON format text file.\n    \"\"\"\n    pub_params_list, glob_params_list, elf_sections, cs, elfobj, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    if len(pub_params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    with open(po.valfile) as valfile:\n        nxparams_list = json.load(valfile)\n    # Change section data buffers to bytearrays, so we can change them easily\n    for section_name, section in elf_sections.items():\n        section['data'] = bytearray(section['data'])\n    update_count = armfw_elf_paramvals_update_list(po, asm_arch, re_general_list,\n      pub_params_list, glob_params_list, elf_sections, nxparams_list)\n    if (po.verbose > 0):\n        print(\"{:s}: Updated {:d} out of {:d} hardcoded values\"\n          .format(po.elffile, update_count, len(pub_params_list)))\n    # Now update the ELF file\n    for section_name, section in elf_sections.items():\n        elfsect = elfobj.get_section_by_name(section_name)\n        elfsect.set_data(section['data'])\n        elfobj.set_section_by_name(section_name, elfsect)\n    if not po.dry_run:\n        elfobj.write_changes()\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-e', '--elffile', type=str, required=True,\n          help=\"input ELF firmware file name\")\n\n    parser.add_argument('-o', '--valfile', type=str,\n          help=(\"directory and file name of JSON with values list \"\n           \"(default is base name of elffile with extension switched to json, in working dir)\"))\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('-l', '--list', action='store_true',\n          help=\"list values stored in the firmware\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract values to infos json text file\")\n\n    subparser.add_argument('-u', '--update', action='store_true',\n          help=\"update values in binary fw from infos text file\")\n\n    subparser.add_argument('-d', '--objdump', action='store_true',\n          help=\"display asm like slightly primitive objdump\")\n\n    subparser.add_argument('--mapfile', action='store_true',\n          help=\"export known symbols to map file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.basename = os.path.splitext(os.path.basename(po.elffile))[0]\n\n    if len(po.elffile) > 0 and (po.valfile is None or len(po.valfile) == 0):\n        po.valfile = po.basename + \".json\"\n\n    if po.objdump:\n        if (po.verbose > 0):\n            print(\"{}: Opening for objdump\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_generic_objdump(po, elffh, 'thumb')\n\n    elif po.list:\n        if (po.verbose > 0):\n            print(\"{}: Opening for list\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_flyc_list(po, elffh)\n\n    elif po.mapfile:\n        if (po.verbose > 0):\n            print(\"{}: Opening for mapfile generation\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_flyc_mapfile(po, elffh)\n\n    elif po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extract\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_flyc_extract(po, elffh)\n\n    elif po.update:\n        if (po.verbose > 0):\n            print(\"{}: Opening for update\".format(po.elffile))\n        with open(po.elffile, 'r+b') as elffh:\n            armfw_elf_flyc_update(po, elffh)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dji_flyc_nofly_ed.py",
          "type": "blob",
          "size": 22.6318359375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DJI Flight Controller Firmware No Fly Zones Editor.\n\n    Note that the update function of this tool is unfinished; there was\n    no need to finish it as there are ways to disable all the NFZs.\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport os\nimport json\nfrom ctypes import c_int, c_ubyte, c_ushort, c_uint\nfrom ctypes import sizeof, LittleEndianStructure\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass NoFlyStorage:\n  none = 0x0\n  zone = 0x1\n  cord = 0x2\n\n\nclass FlycNoFlyZone(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('latitude', c_int),  # angular value * 1000000\n        ('longitude', c_int),\n        ('radius', c_ushort),\n        ('country_code', c_ushort),\n        ('class_id', c_ubyte),\n        ('area_id', c_ushort),\n        ('begin_at', c_ubyte),\n        ('end_at', c_ubyte),\n  ]\n\n  def dict_export(self):\n      d = dict()\n      for (varkey, vartype) in self._fields_:\n          d[varkey] = getattr(self, varkey)\n      return d\n\n  def __repr__(self):\n      d = self.dict_export()\n      from pprint import pformat\n      return pformat(d, indent=4, width=1)\n\n\nclass FlycNoFlyCoords(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('latitude', c_int),\n        ('longitude', c_int),\n  ]\n\n\ndef isclose(a, b, rel_tol=1e-09, abs_tol=0.0):\n    \"\"\" Equivalent to math.isclose(); use it if the script needs to work on Python < 3.5\n    \"\"\"\n    return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n\n\ndef flyc_nofly_is_proper_zone_entry(po, fwmdlfile, fwmdlfile_len, enfzone, func_align, data_align, pos, entry_pos):\n    \"\"\" Checks whether given FlycNoFlyZone object stores a proper entry of\n        flight controller no fly zones array.\n    \"\"\"\n    if (enfzone.begin_at != 0) or (enfzone.end_at != 0):\n        if (po.verbose > 2):\n            print(\"Rejected at {:06x} on begin_at/end_at check ({:d},{:d})\".format(entry_pos,enfzone.begin_at,enfzone.end_at))\n        return False\n    if (enfzone.radius < 30) or (enfzone.radius > 50000):\n        if (po.verbose > 2):\n            print(\"Rejected at {:06x} on radius check ({:d})\".format(entry_pos,enfzone.radius))\n        return False\n    if (enfzone.country_code > 2000):\n        if (po.verbose > 2):\n            print(\"Rejected at {:06x} on country check ({:d})\".format(entry_pos,enfzone.country_code))\n        return False\n    #if (enfzone.class_id < 30) or (enfzone.class_id > 30000):\n    if (enfzone.area_id <= 0):\n        if (po.verbose > 2):\n            print(\"Rejected at {:06x} on area_id check ({:d})\".format(entry_pos,enfzone.area_id))\n        return False\n    return flyc_nofly_is_proper_cord_entry(po, fwmdlfile, fwmdlfile_len, enfzone, func_align, data_align, pos, entry_pos)\n\n\ndef flyc_nofly_is_proper_cord_entry(po, fwmdlfile, fwmdlfile_len, enfcord, func_align, data_align, pos, entry_pos):\n    \"\"\" Checks whether given FlycNoFlyCoords object stores a proper entry of\n        flight controller no fly coordinates array.\n    \"\"\"\n    # Check if we're at ocean around (0.0,0.0), that is within rectangle (-8.0,-6.7) to (4.7,5.5)\n    if (enfcord.latitude >= -8000000) and (enfcord.latitude <= 4700000):\n        if (enfcord.longitude >= -6700000) and (enfcord.longitude <= 5500000):\n            if (po.verbose > 2):\n                print(\"Rejected at {:06x} on low coord ocean check ({:.6f},{:.6f})\"\n                  .format(entry_pos,enfcord.latitude/1000000.0,enfcord.longitude/1000000.0))\n            return False\n    # Check if coords are within valid angular range\n    if (enfcord.latitude < -90000000) or (enfcord.latitude > 90000000):\n        if (po.verbose > 2):\n            print(\"Rejected at {:06x} on latitude coord limit check ({:.6f},{:.6f})\"\n              .format(entry_pos,enfcord.latitude/1000000.0,enfcord.longitude/1000000.0))\n        return False\n    if (enfcord.longitude < -180000000) or (enfcord.longitude > 180000000):\n        if (po.verbose > 2):\n            print(\"Rejected at {:06x} on longitude coord limit check ({:.6f},{:.6f})\"\n              .format(entry_pos,enfcord.latitude/1000000.0,enfcord.longitude/1000000.0))\n        return False\n    return True\n\n\ndef flyc_nofly_zone_pos_search(po, fwmdlfile, start_pos, func_align, data_align, min_match_accepted):\n    \"\"\" Finds position of flight controller no fly zones in the binary.\n    \"\"\"\n    fwmdlfile.seek(0, os.SEEK_END)\n    fwmdlfile_len = fwmdlfile.tell()\n    enfzone = FlycNoFlyZone()\n    match_count = 0\n    match_pos = -1\n    match_entries = 0\n    reached_eof = False\n    pos = start_pos\n    while (True):\n        # Check how many correct zone entries we have\n        entry_count = 0\n        entry_pos = pos\n        while (True):\n            fwmdlfile.seek(entry_pos, os.SEEK_SET)\n            if fwmdlfile.readinto(enfzone) != sizeof(enfzone):\n                reached_eof = True\n                break\n            if not flyc_nofly_is_proper_zone_entry(po, fwmdlfile, fwmdlfile_len, enfzone, func_align, data_align, pos, entry_pos):\n                break\n            entry_count += 1\n            entry_pos += sizeof(enfzone)\n        # Do not allow entry at EOF\n        if (reached_eof):\n            break\n        # If entry is ok, consider it a match\n        if entry_count > min_match_accepted:\n            if (po.verbose > 1):\n                print(\"{}: Matching zones array at 0x{:08x}: {:d} entries\".format(po.mdlfile,pos,entry_count))\n            if (entry_count >= match_entries):\n                match_pos = pos\n                match_entries = entry_count\n            match_count += 1\n        # Set position to search for next entry\n        if entry_count >= min_match_accepted:\n            pos += entry_count * sizeof(enfzone)\n        else:\n            pos += data_align - (pos % data_align)\n    if (match_count > 1):\n        eprint(\"{}: Warning: multiple ({:d}) matches found for fly zones array with alignment 0x{:02x}\"\n          .format(po.mdlfile, match_count, data_align))\n    if (match_count < 1):\n        return -1, 0\n    return match_pos, match_entries\n\n\ndef flyc_nofly_cord_pos_search(po, fwmdlfile, start_pos, func_align, data_align, min_match_accepted):\n    \"\"\" Finds position of flight controller no fly coords in the binary.\n    \"\"\"\n    fwmdlfile.seek(0, os.SEEK_END)\n    fwmdlfile_len = fwmdlfile.tell()\n    enfcord = FlycNoFlyCoords()\n    match_count = 0\n    match_pos = -1\n    match_entries = 0\n    reached_eof = False\n    pos = start_pos\n    while (True):\n        # Check how many correct zone entries we have\n        entry_count = 0\n        entry_pos = pos\n        while (True):\n            fwmdlfile.seek(entry_pos, os.SEEK_SET)\n            if fwmdlfile.readinto(enfcord) != sizeof(enfcord):\n                reached_eof = True\n                break\n            # The array ends with int value storing its size\n            if (entry_count >= min_match_accepted) and (enfcord.latitude == entry_count):\n                break\n            if not flyc_nofly_is_proper_cord_entry(po, fwmdlfile, fwmdlfile_len, enfcord, func_align, data_align, pos, entry_pos):\n                break\n            entry_count += 1\n            entry_pos += sizeof(enfcord)\n        # Do not allow entry at EOF\n        if (reached_eof):\n            break\n        # If entry is ok, consider it a match\n        if entry_count > min_match_accepted:\n            if (po.verbose > 1):\n                print(\"{}: Matching coords array at 0x{:08x}: {:d} entries\".format(po.mdlfile, pos, entry_count))\n            if (entry_count >= match_entries):\n                match_pos = pos\n                match_entries = entry_count\n            match_count += 1\n        # Set position to search for next entry\n        if entry_count >= min_match_accepted:\n            pos += entry_count * sizeof(enfcord)\n        else:\n            pos += data_align - (pos % data_align)\n    if (match_count > 1):\n        eprint(\"{}: Warning: multiple ({:d}) matches found for fly coords array with alignment 0x{:02x}\"\n          .format(po.mdlfile, match_count, data_align))\n    if (match_count < 1):\n        return -1, 0\n    return match_pos, match_entries\n\n\ndef flyc_nofly_zone_template(po):\n    # Set coords at north pole; they should never stay at default value after all\n    # Set 'level' at 2; definition is: WARNING(0), CAN_UNLIMIT(1), CAN_NOT_UNLIMIT(2, 4), STRONG_WARNING(3)\n    parprop = {'area_id':60000,'type':0,'shape':0,'lat':90.0,'lng':0.0,'radius':30,\n        'warning':0,'level':2,'disable':0,'updated_at':1447945800,'begin_at':0,'end_at':0,\n        'name':\"\",'country':0,'city':\"\",'storage':NoFlyStorage.none,'points':None,\n    }\n    return parprop\n\n\ndef flyc_nofly_zone_get(po, fwmdlfile, index):\n  \"\"\" Returns array with properties of given no fly zone.\n  \"\"\"\n  parprop = flyc_nofly_zone_template(po)\n  enfzone = FlycNoFlyZone()\n  fwmdlfile.seek(po.nfzone_pos + sizeof(enfzone) * index, os.SEEK_SET)\n  if fwmdlfile.readinto(enfzone) != sizeof(enfzone):\n      raise EOFError(\"Cannot read nfzone entry.\")\n  parprop['area_id'] = enfzone.area_id\n  parprop['begin_at'] = enfzone.begin_at\n  parprop['end_at'] = enfzone.end_at\n  parprop['lat'] = enfzone.latitude/1000000.0\n  parprop['lng'] = enfzone.longitude/1000000.0\n  parprop['radius'] = enfzone.radius\n  parprop['country'] = enfzone.country_code\n  parprop['type'] = enfzone.class_id\n  parprop['storage'] |= NoFlyStorage.zone\n  return parprop\n\n\ndef flyc_nofly_cord_get(po, fwmdlfile, index):\n  \"\"\" Returns array with properties of given no fly coords.\n  \"\"\"\n  parprop = {'lat':90.0,'lng':0.0}\n  enfcord = FlycNoFlyCoords()\n  fwmdlfile.seek(po.nfcord_pos+sizeof(enfcord)*index, os.SEEK_SET)\n  if fwmdlfile.readinto(enfcord) != sizeof(enfcord):\n      raise EOFError(\"Cannot read nfcord entry.\")\n  parprop['lat'] = enfcord.latitude/1000000.0\n  parprop['lng'] = enfcord.longitude/1000000.0\n  return parprop\n\n\ndef flyc_nofly_merged_zones_array(po, fwmdlfile):\n  if (po.verbose > 0):\n     print(\"{}: Merging No Fly arrays...\".format(po.mdlfile))\n  nfzones = []\n  for i in range(0,po.nfzone_count):\n    parprop = flyc_nofly_zone_get(po, fwmdlfile, i)\n    nfzones.append(parprop)\n    #print(\"{:5d} {:10.6f} {:11.6f} {:5d} {:4d} {:d} {:d} {:d}\".format(parprop['area_id'],parprop['lat'],parprop['lng'],parprop['radius'],parprop['country'],parprop['type'],parprop['begin_at'],parprop['end_at']))\n  for i in range(0,po.nfcord_count):\n    parcord = flyc_nofly_cord_get(po, fwmdlfile, i)\n    parprop = next((parprop for parprop in nfzones if isclose(parprop[\"lat\"], parcord[\"lat\"], rel_tol=1e-3, abs_tol=1e-2) and isclose(parprop[\"lng\"], parcord[\"lng\"], rel_tol=1e-3, abs_tol=1e-2)), None)\n    if (parprop is None):\n       parprop = flyc_nofly_zone_template(po)\n       parprop['lat'] = parcord['lat']\n       parprop['lng'] = parcord['lng']\n       parprop['radius'] = 500\n       parprop['area_id'] = 30000 + i\n       nfzones.append(parprop)\n    parprop['storage'] |= NoFlyStorage.cord\n    #print(\"{:5d} {:10.6f} {:11.6f}\".format(i,parcord['lat'],parcord['lng']))\n  return sorted(nfzones, key=lambda k: -k['lat'])\n\n\ndef flyc_nofly_list(po, fwmdlfile):\n  \"\"\" Lists all flight controller no fly zones from firmware on screen table.\n  \"\"\"\n  (po.nfzone_pos, po.nfzone_count) = flyc_nofly_zone_pos_search(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align, po.min_match_accepted)\n  if po.nfzone_pos < 0:\n    raise ValueError(\"Flight controller no fly zones array signature not detected in input file.\")\n  (po.nfcord_pos, po.nfcord_count) = flyc_nofly_cord_pos_search(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align, po.min_match_accepted)\n  if po.nfcord_pos < 0:\n    raise ValueError(\"Flight controller no fly coords array signature not detected in input file.\")\n  nfzones = flyc_nofly_merged_zones_array(po, fwmdlfile)\n  for parprop in nfzones:\n     print(\"{:5d} {:10.6f} {:11.6f} {:5d} {:4d} {:s}{:s} {:d} {:d} {:d}\".format(parprop['area_id'],parprop['lat'],parprop['lng'],\n       parprop['radius'],parprop['country'],\"z\" if (parprop['storage'] & NoFlyStorage.zone) != 0 else \" \",\n       \"c\" if (parprop['storage'] & NoFlyStorage.cord) != 0 else \" \",parprop['type'],parprop['begin_at'],parprop['end_at']))\n  if (po.verbose > 0):\n     print(\"{}: Done listing.\".format(po.mdlfile))\n\n\ndef flyc_nofly_extract(po, fwmdlfile):\n  \"\"\" Extracts all flight controller no fly zones from firmware to JSON format text file.\n  \"\"\"\n  (po.nfzone_pos, po.nfzone_count) = flyc_nofly_zone_pos_search(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align, po.min_match_accepted)\n  if po.nfzone_pos < 0:\n    raise ValueError(\"Flight controller no fly zones array signature not detected in input file.\")\n  (po.nfcord_pos, po.nfcord_count) = flyc_nofly_cord_pos_search(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align, po.min_match_accepted)\n  if po.nfcord_pos < 0:\n    raise ValueError(\"Flight controller no fly coords array signature not detected in input file.\")\n  nfzones = flyc_nofly_merged_zones_array(po, fwmdlfile)\n  if (po.verbose > 0):\n     print(\"{}: Creating JSON file...\".format(po.mdlfile))\n  inffile = open(po.inffile, \"w\")\n  inffile.write(\"{\\\"release_limits\\\":[\\n\")\n  i = 0\n  for parprop in nfzones:\n    inffile.write(\"{\")\n    for ppname in ('area_id','type','shape',):\n       inffile.write(\"\\\"{:s}\\\":{:d}\".format(ppname,parprop[ppname]))\n       inffile.write(\",\")\n    for ppname in ('lat','lng',):\n       inffile.write(\"\\\"{:s}\\\":{:06f}\".format(ppname,parprop[ppname]))\n       inffile.write(\",\")\n    for ppname in ('radius','warning','level','disable','updated_at','begin_at','end_at',):\n       inffile.write(\"\\\"{:s}\\\":{:d}\".format(ppname,parprop[ppname]))\n       inffile.write(\",\")\n    for ppname in ('name',):\n       inffile.write(\"\\\"{:s}\\\":\\\"{:s}\\\"\".format(ppname,parprop[ppname]))\n       inffile.write(\",\")\n    for ppname in ('storage','country',):\n       inffile.write(\"\\\"{:s}\\\":{:d}\".format(ppname,parprop[ppname]))\n       inffile.write(\",\")\n    for ppname in ('city',):\n       inffile.write(\"\\\"{:s}\\\":\\\"{:s}\\\"\".format(ppname,parprop[ppname]))\n       inffile.write(\",\")\n    for ppname in ('points',):\n       inffile.write(\"\\\"{:s}\\\":{:s}\".format(ppname,parprop[ppname] if parprop[ppname] is not None else \"null\"))\n    if (i+1 < len(nfzones)):\n       inffile.write(\"},\\n\")\n    else:\n       inffile.write(\"}\\n\")\n    i += 1\n  inffile.write(\"]}\\n\")\n  inffile.close()\n  if (po.verbose > 0):\n     print(\"{}: Done exporting.\".format(po.mdlfile))\n\n\ndef flyc_nofly_update(po, fwmdlfile):\n  \"\"\" Updates all flight controller no fly zones in firmware from JSON format text file.\n  \"\"\"\n  (po.nfzone_pos, po.nfzone_count) = flyc_nofly_zone_pos_search(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align, po.min_match_accepted)\n  if po.nfzone_pos < 0:\n    raise ValueError(\"Flight controller no fly zones array signature not detected in input file.\")\n  (po.nfcord_pos, po.nfcord_count) = flyc_nofly_cord_pos_search(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align, po.min_match_accepted)\n  if po.nfcord_pos < 0:\n    raise ValueError(\"Flight controller no fly coords array signature not detected in input file.\")\n  #pvnfzones = flyc_nofly_merged_zones_array(po, fwmdlfile) # No need for merging, we will use separate lists\n  if (po.verbose > 0):\n     print(\"{}: Loading JSON file...\".format(po.mdlfile))\n  with open(po.inffile) as inffile:\n    nxnfzones = json.load(inffile)\n  nxnfzones = nxnfzones['release_limits']\n  update_zone_count = 0\n  update_cord_count = 0\n  if (True):\n      # Update the zones first\n      if (po.verbose > 1):\n          print(\"{}: Updating no fly zones array at 0x{:08x}: {:d} entries\".format(po.mdlfile,po.nfzone_pos,po.nfzone_count))\n      for i in range(0, po.nfzone_count):\n          pvparprop = flyc_nofly_zone_get(po, fwmdlfile, i)\n          # Match the current entry to user provided data\n          nxparprop = None\n          if (nxparprop is None):\n              for parprop in nxnfzones:\n                  if parprop['area_id'] == pvparprop['area_id']:\n                      nxparprop = parprop\n                      break\n          if (nxparprop is None):\n              eprint(\"{}: Warning: no fly zone not found in fw: area_id={:d}\".format(po.mdlfile,pvparprop['area_id']))\n              continue\n          update_pos = False\n          update_radius = False\n          update_country = False\n          update_limits = False\n          update_type = False\n          # compare properties to check what we want to update\n          if not isclose(nxparprop['lat'], pvparprop['lat']) or not isclose(nxparprop['lng'], pvparprop['lng']):\n              update_pos = True\n          if nxparprop['radius'] != pvparprop['radius']:\n              update_radius = True\n          if nxparprop['country'] != pvparprop['country']:\n              update_country = True\n          if nxparprop['begin_at'] != pvparprop['begin_at'] or nxparprop['end_at'] != pvparprop['end_at']:\n              update_limits = True\n          if nxparprop['type'] != pvparprop['type']:\n              update_type = True\n          if (update_pos):\n              eprint(\"{}: pos update not implemented.\".format(po.mdlfile)) # TODO\n          if (update_radius):\n              eprint(\"{}: radius update not implemented.\".format(po.mdlfile)) # TODO\n          if (update_country):\n              eprint(\"{}: country update not implemented.\".format(po.mdlfile)) # TODO\n          if (update_limits):\n              eprint(\"{}: limits update not implemented.\".format(po.mdlfile)) # TODO\n          if (update_type):\n              eprint(\"{}: type update not implemented.\".format(po.mdlfile)) # TODO\n      # Now do the same to coords\n      if (po.verbose > 1):\n          print(\"{}: Updating no fly coords array at 0x{:08x}: {:d} entries\".format(po.mdlfile,po.nfcord_pos,po.nfcord_count))\n      for i in range(0, po.nfcord_count):\n          pvparprop = flyc_nofly_cord_get(po, fwmdlfile, i)\n          # Match the current entry to user provided data\n          nxparprop = None\n          if (nxparprop is None):\n                  if isclose(parprop['lat'], pvparprop['lat']) and isclose(parprop['lng'], pvparprop['lng']):\n                      nxparprop = parprop\n                      break\n          # If not found, try accepting some variation\n          if (nxparprop is None):\n              for parprop in nxnfzones:\n                  if (isclose(parprop['lat'], pvparprop['lat'], rel_tol=1e-3, abs_tol=1e-2) and isclose(parprop['lng'], pvparprop['lng'], rel_tol=1e-3, abs_tol=1e-2)):\n                      nxparprop = parprop\n                      break\n          if (nxparprop is None):\n              eprint(\"{}: Warning: no fly coords not found in fw: area_id={:d}\".format(po.mdlfile,pvparprop['area_id']))\n              continue\n          update_pos = False\n          # compare properties to check what we want to update\n          # TODO does it really make sense for coord list to first search based on coords, then allow update it? Maybe remove/add from the list instead?\n          if not isclose(nxparprop['lat'], pvparprop['lat']) or not isclose(nxparprop['lng'], pvparprop['lng']):\n              update_pos = True\n          if (update_pos):\n              eprint(\"{}: Coords update not implemented.\".format(po.mdlfile)) # TODO\n  raise NotImplementedError('Not implemented - no data was updated.')\n  if (po.verbose > 0):\n      print(\"{}: Updated {:d} no fly zone entries and {:d} no fly coord entries\".format(po.mdlfile,update_zone_count,update_cord_count))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-m', '--mdlfile', type=str, required=True,\n          help=\"flight controller firmware binary module file\")\n\n    parser.add_argument('-i', '--inffile', type=str, default=\"flyc_forbid_areas.json\",\n          help=\"No Fly Zone Areas JSON file name (default is \\\"%(default)s\\\")\")\n\n    #parser.add_argument('-b', '--baseaddr', default=0x8020000, type=lambda x: int(x,0),\n    #      help=\"set base address; crucial for finding the array (default is 0x%(default)X)\")\n\n    #parser.add_argument('--bssaddr', default=0x20000000, type=lambda x: int(x,0),\n    #      help=\"set .bss start address; set to address where RAM starts (default is 0x%(default)X)\")\n\n    #parser.add_argument('--bsslen', default=0x4400000, type=lambda x: int(x,0),\n    #      help=\"set .bss length; set to size of RAM (default is 0x%(default)X)\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-l', '--list', action='store_true',\n          help=\"list no fly zones stored in the firmware\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract no fly zones array to json text file\")\n\n    subparser.add_argument('-u', '--update', action='store_true',\n          help=\"update no fly zones array in binary fw from areas json text file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.expect_func_align = 4\n    po.expect_data_align = 2\n    po.min_match_accepted = 60\n    po.nfzone_pos = -1\n    po.nfzone_count = 0\n    po.nfcord_pos = -1\n    po.nfcord_count = 0\n\n    if po.list:\n        if (po.verbose > 0):\n            print(\"{}: Opening for list display\".format(po.mdlfile))\n        with open(po.mdlfile, 'rb') as fwmdlfile:\n            flyc_nofly_list(po,fwmdlfile)\n\n    elif po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extraction\".format(po.mdlfile))\n        with open(po.mdlfile, 'rb') as fwmdlfile:\n            flyc_nofly_extract(po,fwmdlfile)\n\n    elif po.update:\n        if (po.verbose > 0):\n            print(\"{}: Opening for update\".format(po.mdlfile))\n        with open(po.mdlfile, 'r+b') as fwmdlfile:\n            flyc_nofly_update(po,fwmdlfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dji_flyc_param_ed.py",
          "type": "blob",
          "size": 46.9248046875,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DJI Flight Controller Firmware Parameters Array Editor.\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport os\nimport math\nimport re\nimport json\nfrom ctypes import c_char, c_int, c_ubyte, c_ushort, c_uint, c_float\nfrom ctypes import sizeof, LittleEndianStructure\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass Limits:\n  byte_min  = - (2 ** 7)\n  byte_max  = (2 ** 7) - 1\n  ubyte_min = 0\n  ubyte_max = (2 ** 8) - 1\n  short_min  = - (2 ** 15)\n  short_max  = (2 ** 15) - 1\n  ushort_min = 0\n  ushort_max = (2 ** 16) - 1\n  long_min  = - (2 ** 31)\n  long_max  = (2 ** 31) - 1\n  ulong_min = 0\n  ulong_max = (2 ** 32) - 1\n  longlong_min  = - (2 ** 63)\n  longlong_max  = (2 ** 63) - 1\n  ulonglong_min = 0\n  ulonglong_max = (2 ** 64) - 1\n\n\nclass ParamType:\n  ubyte = 0x0\n  ushort = 0x1\n  ulong = 0x2\n  ulonglong = 0x3\n  byte = 0x4\n  short = 0x5\n  long = 0x6\n  longlong = 0x7\n  float = 0x8\n  double = 0x9\n  array = 0xa\n  bool = 0xb\n\n\nclass FlycExportLimitF2015(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('min', c_float),\n        ('max', c_float),\n        ('deflt', c_float),\n  ]\n\n\nclass FlycExportLimitI2015(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('min', c_int),\n        ('max', c_int),\n        ('deflt', c_int),\n  ]\n\n\nclass FlycExportLimitU2015(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('min', c_uint),\n        ('max', c_uint),\n        ('deflt', c_uint),\n  ]\n\n\nclass FlycExportLimitF2017(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('deflt', c_float),\n        ('min', c_float),\n        ('max', c_float),\n  ]\n\n\nclass FlycExportLimitI2017(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('deflt', c_int),\n        ('min', c_int),\n        ('max', c_int),\n  ]\n\n\nclass FlycExportLimitU2017(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('deflt', c_uint),\n        ('min', c_uint),\n        ('max', c_uint),\n  ]\n\n\nclass FlycExportParam2015(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('nameptr', c_uint),  # Pointer to the name string of this parameter\n        ('valptr', c_uint),  # Pointer to where current value of the parameter is\n        ('valsize', c_uint),\n        ('type_id', c_uint),\n        ('limit_f', FlycExportLimitF2015),\n        ('limit_i', FlycExportLimitI2015),\n        ('limit_u', FlycExportLimitU2015),\n        ('attribute', c_uint),\n        ('callback', c_uint),\n  ]\n\n\nclass FlycExportParam2017(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('nameptr', c_uint),  # Pointer to the name string of this parameter\n        ('valptr', c_uint),  # Pointer to where current value of the parameter is\n        ('valsize', c_ushort),\n        ('type_id', c_ushort),\n        ('limit_f', FlycExportLimitF2017),\n        ('limit_i', FlycExportLimitI2017),\n        ('limit_u', FlycExportLimitU2017),\n        ('attribute', c_uint),\n        ('callback', c_uint),\n  ]\n\n\nclass FlycExportParam2018(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [\n        ('nameptr', c_uint),  # Pointer to the name string of this block\n        ('aliasptr', c_uint),\n        ('field_8', c_ushort),\n        ('valsize', c_ubyte),\n        ('field_B', c_ubyte),\n        ('attribute', c_ubyte),\n        ('field_D', c_ubyte),\n        ('type_id', c_ubyte),\n        ('field_F', c_ubyte),\n        ('limit_f', FlycExportLimitF2017),\n        ('limit_i', FlycExportLimitI2017),\n        ('limit_u', FlycExportLimitU2017),\n  ]\n\n\nclass FlycParamBlock2018(LittleEndianStructure):\n  \"\"\" The 2018 generation of drones introduced grouping of parameters into independent Blocks.\n      Each Block structure has its name, and points to an array of ExportParam entries.\n  \"\"\"\n  _pack_ = 1\n  _fields_ = [\n        ('nameptr', c_uint),  # Pointer to the name string of this block\n        ('blockid', c_uint),\n        ('field_8', c_uint),\n        ('params', c_uint),  # Pointer to parameters array\n        ('cmds', c_uint),  # Pointer to commands array\n        ('param_count', c_ushort),\n        ('cmd_count', c_ushort),\n        ('callback', c_uint),\n  ]\n\n\ndef isclose(a, b, rel_tol=1e-09, abs_tol=0.0):\n    \"\"\" Equivalent to math.isclose(); use it if the script needs to work on Python < 3.5\n    \"\"\"\n    return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n\n\ndef FlycExportParamFactory(ver):\n    if ver == 2015:\n        eexpar = FlycExportParam2015()\n    elif ver == 2017:\n        eexpar = FlycExportParam2017()\n    elif ver == 2018:\n        eexpar = FlycExportParam2018()\n    else:\n        raise ValueError(\"Unsupported flyc parameters format version.\")\n    return eexpar\n\n\ndef export_param_instance_to_ver(instn):\n    if isinstance(instn, FlycExportParam2015):\n        ver = 2015\n    elif isinstance(instn, FlycExportParam2017):\n        ver = 2017\n    elif isinstance(instn, FlycExportParam2018):\n        ver = 2018\n    else:\n        raise ValueError(\"Unsupported flyc parameters format version.\")\n    return ver\n\n\ndef flyc_param_limit_to_type(po, ver, type_id, fltval):\n    if (type_id == ParamType.ubyte):\n        if (fltval < Limits.ubyte_min):\n            return Limits.ubyte_min\n        elif (fltval > Limits.ubyte_max):\n            return Limits.ubyte_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.ushort):\n        if (fltval < Limits.ushort_min):\n            return Limits.ushort_min\n        elif (fltval > Limits.ushort_max):\n            return Limits.ushort_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.ulong):\n        if (fltval < Limits.ulong_min):\n            return Limits.ulong_min\n        elif (fltval > Limits.ulong_max):\n            return Limits.ulong_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.ulonglong):\n        if (fltval < Limits.ulonglong_min):\n            return Limits.ulonglong_min\n        elif (fltval > Limits.ulonglong_max):\n            return Limits.ulonglong_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.byte):\n        if (ver == 2017):\n            if (fltval < Limits.byte_min):\n                return Limits.byte_min\n            elif (fltval > Limits.ubyte_max): # This is alarming, but that's how it's really done\n                return Limits.ubyte_max\n            else:\n                return int(fltval) # DJI does not use round() here\n        else:\n            if (fltval < Limits.byte_min):\n                return Limits.byte_min\n            elif (fltval > Limits.byte_max):\n                return Limits.byte_max\n            else:\n                return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.short):\n        if (fltval < Limits.short_min):\n            return Limits.short_min\n        elif (fltval > Limits.short_max):\n            return Limits.short_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.long):\n        if (fltval < Limits.long_min):\n            return Limits.long_min\n        elif (fltval > Limits.long_max):\n            return Limits.long_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    if (type_id == ParamType.longlong):\n        if (fltval < Limits.longlong_min):\n            return Limits.longlong_min\n        elif (fltval > Limits.longlong_max):\n            return Limits.longlong_max\n        else:\n            return int(fltval) # DJI does not use round() here\n    return fltval\n\n\ndef flyc_param_limit_unsigned_int(po, eexpar):\n    return (eexpar.type_id == ParamType.ubyte) or \\\n       (eexpar.type_id == ParamType.ushort) or \\\n       (eexpar.type_id == ParamType.ulong) or \\\n       (eexpar.type_id == ParamType.ulonglong)\n\n\ndef flyc_param_limit_signed_int(po, eexpar):\n    return (eexpar.type_id == ParamType.byte) or \\\n       (eexpar.type_id == ParamType.short) or \\\n       (eexpar.type_id == ParamType.long) or \\\n       (eexpar.type_id == ParamType.longlong)\n\n\ndef flyc_param_get_proper_limit_min(po, eexpar):\n    if flyc_param_limit_unsigned_int(po, eexpar):\n        return eexpar.limit_u.min\n    if flyc_param_limit_signed_int(po, eexpar):\n        return eexpar.limit_i.min\n    return eexpar.limit_f.min\n\n\ndef flyc_param_get_proper_limit_max(po, eexpar):\n    if flyc_param_limit_unsigned_int(po, eexpar):\n        return eexpar.limit_u.max\n    if flyc_param_limit_signed_int(po, eexpar):\n        return eexpar.limit_i.max\n    return eexpar.limit_f.max\n\n\ndef flyc_param_get_proper_limit_deflt(po, eexpar):\n    if flyc_param_limit_unsigned_int(po, eexpar):\n        return eexpar.limit_u.deflt\n    if flyc_param_limit_signed_int(po, eexpar):\n        return eexpar.limit_i.deflt\n    return eexpar.limit_f.deflt\n\n\ndef address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, ptraddr):\n    \"\"\" Checks whether given value can be treated as a valid pointer to either code or initialized data.\n    \"\"\"\n    if (ptraddr < po.baseaddr) or (ptraddr >= po.baseaddr+fwmdlfile_len):\n        return False\n    # Values near zero should be treated as invalid even if within segment - interrupt table cannot be referenced\n    if (ptraddr < 128):\n        return False\n    return True\n\n\ndef address_is_pointer_to_bss(po, fwmdlfile, fwmdlfile_len, ptraddr):\n    \"\"\" Checks whether given value can be treated as a valid pointer to uninitialized data.\n    \"\"\"\n    if (ptraddr < po.bssaddr) or (ptraddr >= po.bssaddr+po.bsslen):\n        return False\n    # Values near zero should be treated as invalid even if within segment - interrupt table cannot be referenced\n    if (ptraddr < 128):\n        return False\n    return True\n\n\ndef flyc_parameter_entry_type_matches_size(po, eexpar):\n    if (eexpar.type_id == ParamType.ushort):\n       if (eexpar.valsize != 1) and (eexpar.valsize != 2) and (eexpar.valsize != 4) and (eexpar.valsize != 8):\n          if (po.verbose > 3):\n             print(\"{}: Rejection on bad ushort ({:d}) size ({:d})\".format(po.mdlfile,eexpar.type_id,eexpar.valsize))\n          return False\n    elif (eexpar.type_id == ParamType.ulong):\n       if (eexpar.valsize != 1) and (eexpar.valsize != 2) and (eexpar.valsize != 4) and (eexpar.valsize != 8):\n          if (po.verbose > 3):\n             print(\"{}: Rejection on bad ulong ({:d}) size ({:d})\".format(po.mdlfile,eexpar.type_id,eexpar.valsize))\n          return False\n    elif (eexpar.type_id == ParamType.bool):\n       if (eexpar.valsize != 1) and (eexpar.valsize != 2) and (eexpar.valsize != 4):\n          if (po.verbose > 3):\n             print(\"{}: Rejection on bad bool ({:d}) size ({:d})\".format(po.mdlfile,eexpar.type_id,eexpar.valsize))\n          return False\n    elif (eexpar.type_id <= ParamType.double):\n       if (eexpar.valsize != 1) and (eexpar.valsize != 2) and (eexpar.valsize != 4) and (eexpar.valsize != 8):\n          if (po.verbose > 3):\n             print(\"{}: Rejection on bad type ({:d}) size ({:d})\".format(po.mdlfile,eexpar.type_id,eexpar.valsize))\n          return False\n    elif (eexpar.type_id == ParamType.array):\n       # array needs to have multiple elements\n       if (eexpar.valsize < 2):\n          if (po.verbose > 3):\n             print(\"{}: Rejection on bad array ({:d}) size ({:d})\".format(po.mdlfile,eexpar.type_id,eexpar.valsize))\n          return False\n    else:\n       # unrecognized type\n       return False\n    return True\n\n\ndef flyc_parameter_limits_check_int_values_match_float_values(po, ver, eexpar):\n  if (flyc_param_limit_unsigned_int(po, eexpar)):\n     # Min unsigned vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, eexpar.type_id, eexpar.limit_f.min)\n     treshold = abs(limit_ftoi / 10000000) # ignore differences beyond 32bit float precision\n     if (abs(limit_ftoi - eexpar.limit_u.min) > treshold):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on min U-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_u.min,eexpar.limit_f.min))\n        return False\n     # Max unsigned vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, eexpar.type_id, eexpar.limit_f.max)\n     treshold = abs(limit_ftoi / 10000000) # ignore differences beyond 32bit float precision\n     if (abs(limit_ftoi - eexpar.limit_u.max) > treshold):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on max U-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_u.max,eexpar.limit_f.max))\n        return False\n     # Default unsigned vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, eexpar.type_id, eexpar.limit_f.deflt)\n     treshold = abs(limit_ftoi / 10000000) # ignore differences beyond 32bit float precision\n     if (abs(limit_ftoi - eexpar.limit_u.deflt) > treshold):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on deflt U-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_u.deflt,eexpar.limit_f.deflt))\n        return False\n  elif (flyc_param_limit_signed_int(po, eexpar)):\n     # Min signed vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, eexpar.type_id, eexpar.limit_f.min)\n     treshold = abs(limit_ftoi / 10000000) # ignore differences beyond 32bit float precision\n     if (abs(limit_ftoi - eexpar.limit_i.min) > treshold):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on min I-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_i.min,eexpar.limit_f.min))\n        return False\n     # Max signed vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, eexpar.type_id, eexpar.limit_f.max)\n     treshold = abs(limit_ftoi / 10000000) # ignore differences beyond 32bit float precision\n     if (abs(limit_ftoi - eexpar.limit_i.max) > treshold):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on max I-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_i.max,eexpar.limit_f.max))\n        return False\n     # Default signed vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, eexpar.type_id, eexpar.limit_f.deflt)\n     treshold = abs(limit_ftoi / 10000000) # ignore differences beyond 32bit float precision\n     if (abs(limit_ftoi - eexpar.limit_i.deflt) > treshold):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on deflt I-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_i.deflt,eexpar.limit_f.deflt))\n        return False\n  else: # in case of other types, int params are storing 32-bit signed value\n     # Min signed vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, ParamType.long, eexpar.limit_f.min)\n     if (limit_ftoi != eexpar.limit_i.min):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on min O-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_i.min,eexpar.limit_f.min))\n        return False\n     # Max signed vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, ParamType.long, eexpar.limit_f.max)\n     if (limit_ftoi != eexpar.limit_i.max):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on max O-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_i.max,eexpar.limit_f.max))\n        return False\n     # Default signed vs Float\n     limit_ftoi = flyc_param_limit_to_type(po, ver, ParamType.long, eexpar.limit_f.deflt)\n     if (abs(limit_ftoi - eexpar.limit_i.deflt) > 127):\n        if (po.verbose > 3):\n           print(\"{}: Rejection on deflt O-F {:d} {:d} {:f}\"\n             .format(po.mdlfile,limit_ftoi,eexpar.limit_i.deflt,eexpar.limit_f.deflt))\n        return False\n  return True\n\n\ndef flyc_parameter_limits_check_minmax_relations(po, ver, eexpar):\n  if math.isnan(eexpar.limit_f.min) or math.isnan(eexpar.limit_f.max) or math.isnan(eexpar.limit_f.deflt):\n      if (po.verbose > 3):\n         print(\"{}: Rejection on valid float check ({:f} {:f} {:f})\"\n           .format(po.mdlfile,eexpar.limit_f.min,eexpar.limit_f.deflt,eexpar.limit_f.max))\n      return False\n  if (eexpar.limit_f.min > eexpar.limit_f.max):\n      if (po.verbose > 3):\n         print(\"{}: Rejection on float min:max relation check ({:f}:{:f})\"\n           .format(po.mdlfile,eexpar.limit_f.min,eexpar.limit_f.max))\n      return False\n  # That would be a nice check, but the original parameters have errors and some of them would fail this test\n  #if (eexpar.limit_f.min > eexpar.limit_f.deflt):\n  #    if (po.verbose > 3):\n  #       print(\"{}: Rejection on float min:default relation check ({:f}:{:f})\".format(po.mdlfile,eexpar.limit_f.min,eexpar.limit_f.deflt))\n  #    return False\n  # That would be a nice check, but the original parameters have errors and some of them would fail this test\n  #if (eexpar.limit_f.deflt > eexpar.limit_f.max):\n  #    if (po.verbose > 3):\n  #       print(\"{}: Rejection on float default:max relation check ({:f}:{:f})\".format(po.mdlfile,eexpar.limit_f.deflt,eexpar.limit_f.max))\n  #    return False\n  return True\n\n\ndef flyc_parameter_limits_check_int_bitwise_identical(po, ver, eexpar):\n  \"\"\" limit_u and limit_i are bitwise identical; cast them to compare\n  \"\"\"\n  if (c_uint(eexpar.limit_i.min).value != eexpar.limit_u.min):\n      if (po.verbose > 3):\n         print(\"{}: Rejection on bitwise identical min I-U ({:d} {:d})\"\n           .format(po.mdlfile,eexpar.limit_i.min,eexpar.limit_u.min))\n      return False\n  if (c_uint(eexpar.limit_i.max).value != eexpar.limit_u.max):\n      if (po.verbose > 3):\n         print(\"{}: Rejection on bitwise identical max I-U ({:d} {:d})\"\n           .format(po.mdlfile,eexpar.limit_i.max,eexpar.limit_u.max))\n      return False\n  if (c_uint(eexpar.limit_i.deflt).value != eexpar.limit_u.deflt):\n      if (po.verbose > 3):\n         print(\"{}: Rejection on bitwise identical deflt I-U ({:d} {:d})\"\n           .format(po.mdlfile,eexpar.limit_i.deflt,eexpar.limit_u.deflt))\n      return False\n  return True\n\n\ndef flyc_is_proper_parameter_entry(po, fwmdlfile, fwmdlfile_len, eexpar, func_align, data_align, pos, entry_pos):\n  \"\"\" Checks whether given FlycExportParam object stores a proper entry of\n      flight controller parameters array.\n  \"\"\"\n  ver = export_param_instance_to_ver(eexpar)\n\n  if (False): # DEBUG code, to be enabled when searching for missing parameters\n      if (ver == 2018) and (entry_pos == 0x10F8DC): po.verbose = 4\n      else: po.verbose = 2\n\n  # Address to const string\n  if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eexpar.nameptr):\n      if (po.verbose > 2):\n          print(\"{}: At 0x{:08x}, rejected type {:d} on name pointer check (0x{:x})\"\n            .format(po.mdlfile, entry_pos, eexpar.type_id, eexpar.nameptr))\n      return False\n\n  if hasattr(eexpar, 'valptr'):\n      # Address to uninitialized variable\n      if not address_is_pointer_to_bss(po, fwmdlfile, fwmdlfile_len, eexpar.valptr):\n          if (eexpar.valptr != 0): # Value pointer can be NULL\n              if (po.verbose > 2):\n                  print(\"{}: At 0x{:08x}, rejected type {:d} on value pointer check (0x{:x})\"\n                    .format(po.mdlfile, entry_pos, eexpar.type_id, eexpar.valptr))\n              return False\n\n  if hasattr(eexpar, 'aliasptr'):\n      # Address to const string\n      if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eexpar.aliasptr):\n          if (eexpar.aliasptr != 0): # Alias pointer can be NULL\n              if (po.verbose > 2):\n                  print(\"{}: At 0x{:08x}, rejected type {:d} on alias pointer check (0x{:x})\"\n                    .format(po.mdlfile, entry_pos, eexpar.type_id, eexpar.aliasptr))\n              return False\n\n  # Size and type\n  if not flyc_parameter_entry_type_matches_size(po, eexpar):\n      if (po.verbose > 2):\n          print(\"{}: At 0x{:08x}, rejected type {:d} on size check ({:d})\"\n            .format(po.mdlfile, entry_pos, eexpar.type_id, eexpar.valsize))\n      return False\n\n  # Attribute used range\n  if (eexpar.attribute > 255):\n      if (po.verbose > 2):\n          print(\"{}: At 0x{:08x}, rejected type {:d} on attribute check ({:d})\"\n            .format(po.mdlfile, entry_pos, eexpar.type_id, eexpar.attribute))\n      return False\n\n  # Address to callback func\n  if hasattr(eexpar, 'callback'):\n      if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eexpar.callback):\n          if (eexpar.callback != 0): # Callback pointer can be NULL\n              if (po.verbose > 2):\n                  print(\"{}: At 0x{:08x}, rejected type {:d} on callback address check ({:d})\"\n                    .format(po.mdlfile, entry_pos, eexpar.type_id, eexpar.callback))\n              return False\n\n  # Limits\n  if not flyc_parameter_limits_check_minmax_relations(po, ver, eexpar):\n      if (po.verbose > 2):\n          print(\"{}: At 0x{:08x}, rejected type {:d} on min:default:max relation check\"\n            .format(po.mdlfile, entry_pos, eexpar.type_id))\n      return False\n  if not flyc_parameter_limits_check_int_values_match_float_values(po, ver, eexpar):\n      if (po.verbose > 2):\n          print(\"{}: At 0x{:08x}, rejected type {:d} on integer-vs-float similarity check\"\n            .format(po.mdlfile, entry_pos, eexpar.type_id))\n      return False\n\n  if not flyc_parameter_limits_check_int_bitwise_identical(po, ver, eexpar):\n      if (po.verbose > 2):\n          print(\"{}: At 0x{:08x}, rejected type {:d} on signed-unsigned bitwise same check\"\n            .format(po.mdlfile, entry_pos, eexpar.type_id))\n      return False\n  return True\n\n\ndef flyc_is_proper_parameter_block(po, fwmdlfile, fwmdlfile_len, eparblk, func_align, data_align, pos):\n    \"\"\" Checks whether given FlycParamBlock object stores a proper entry of\n        flight controller parameter block.\n    \"\"\"\n    # Address to const string\n    if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eparblk.nameptr):\n        return False\n\n    # Address to cmds array\n    if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eparblk.cmds):\n        if (eparblk.cmds != 0): # Cmds pointer can be NULL\n            return False\n\n    # Address to callback func\n    if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eparblk.callback):\n        if (eparblk.callback != 0): # Callback pointer can be NULL\n            return False\n\n    if (eparblk.cmd_count == 0) and (eparblk.cmds != 0):\n        return False\n    if (eparblk.cmd_count > 0) and (eparblk.cmds == 0):\n        return False\n\n    if (eparblk.param_count == 0):\n        return False\n\n    # Address to params array\n    if not address_is_pointer_to_initialized(po, fwmdlfile, fwmdlfile_len, eparblk.params):\n        return False\n\n    return True\n\n\ndef flyc_check_parameter_array_at(po, fwmdlfile, fwmdlfile_len, start_pos, func_align, data_align, ver):\n    \"\"\" Assuming given position is a parameter array, this function will return how many\n        proper entries it has.\n    \"\"\"\n    eexpar = FlycExportParamFactory(ver)\n    entry_count = 0\n    entry_pos = start_pos\n    while (True):\n        # Read possible struct\n        fwmdlfile.seek(entry_pos, os.SEEK_SET)\n        if fwmdlfile.readinto(eexpar) != sizeof(eexpar):\n            break\n        # Check if struct is valid\n        if not flyc_is_proper_parameter_entry(po, fwmdlfile, fwmdlfile_len,\n          eexpar, func_align, data_align, start_pos, entry_pos):\n            break\n        # If struct seem correct, check for its name string\n        fwmdlfile.seek(eexpar.nameptr - po.baseaddr, os.SEEK_SET)\n        eexpar_name_btarr = fwmdlfile.read(256).split(b'\\0',1)[0]\n        if (len(eexpar_name_btarr) < 2):\n            if (po.verbose > 3):\n                print(\"{}: At 0x{:08x}, rejected type {:d} on name len check ({:d})\"\n                  .format(po.mdlfile, entry_pos, eexpar.type_id, len(eexpar_name_btarr)))\n            break\n        if not re.match(b'^[0-9a-zA-z\\[\\]\\(\\)\\{\\} .,:*#_-]+$', eexpar_name_btarr):\n            if (po.verbose > 3):\n                print(\"{}: At 0x{:08x}, rejected type {:d} on name regex check\"\n                  .format(po.mdlfile, entry_pos, eexpar.type_id))\n            break\n        if (po.verbose > 2):\n            print(\"{}: Found entry '{:s}'\".format(po.mdlfile,eexpar_name_btarr.decode('UTF-8')))\n        # All correct\n        entry_count += 1\n        entry_pos += sizeof(eexpar)\n    return entry_count\n\n\ndef flyc_parameter_array_pos_search(po, fwmdlfile, start_pos, func_align, data_align, ver):\n    \"\"\" Finds position of flight controller parameters in the binary.\n        Searches only for specific version of the parameters format.\n    \"\"\"\n    fwmdlfile.seek(0, os.SEEK_END)\n    fwmdlfile_len = fwmdlfile.tell()\n    eexpar = FlycExportParamFactory(ver)\n    match_count = 0\n    match_pos = -1\n    match_entries = 0\n    pos = start_pos\n    while (True):\n        # Check how many correct parameter entries we have\n        entry_count = flyc_check_parameter_array_at(po, fwmdlfile, fwmdlfile_len, pos, func_align, data_align, ver)\n        # If entry is ok, consider it a match\n        if entry_count > 0:\n            if (po.verbose > 1):\n                print(\"{}: Matching parameters array at 0x{:08x}: {:d} entries, format {:d}\"\n                  .format(po.mdlfile, pos, entry_count, ver))\n            if (entry_count > match_entries):\n                match_pos = pos\n                match_entries = entry_count\n            match_count += 1\n        # Set position to search for next entry\n        if entry_count > 0:\n            pos += entry_count * sizeof(eexpar)\n        else:\n            pos += data_align\n        # Stop if we're at EOF\n        if (pos + sizeof(eexpar) > fwmdlfile_len):\n            break\n    if (match_count > 1):\n        eprint(\"{}: Warning: multiple ({:d}) matches found for parameters array with alignment 0x{:02x}\"\n          .format(po.mdlfile, match_count, data_align))\n    if (match_count < 1):\n        return {}, 0\n    return {match_pos: match_entries}, match_entries\n\n\ndef flyc_check_parameter_block_at(po, fwmdlfile, fwmdlfile_len, start_pos, func_align, data_align, ver):\n    \"\"\" Assuming given position is a parameter block, this function will read it and verify content.\n    \"\"\"\n    eparblk = FlycParamBlock2018()\n    fwmdlfile.seek(start_pos, os.SEEK_SET)\n    if fwmdlfile.readinto(eparblk) != sizeof(eparblk):\n        eparblk.param_count = 0\n        return eparblk\n    # Check if struct is valid\n    if not flyc_is_proper_parameter_block(po, fwmdlfile, fwmdlfile_len, eparblk, func_align, data_align, start_pos):\n        eparblk.param_count = 0\n        return eparblk\n    # If struct seem correct, check for its name string\n    fwmdlfile.seek(eparblk.nameptr - po.baseaddr, os.SEEK_SET)\n    eparblk_name_btarr = fwmdlfile.read(256).split(b'\\0',1)[0]\n    if (len(eparblk_name_btarr) < 2):\n        eparblk.param_count = 0\n        return eparblk\n    if not re.match(b'^[0-9a-zA-z\\[\\]\\(\\)\\{\\} .,:*#_-]+$', eparblk_name_btarr):\n        eparblk.param_count = 0\n        return eparblk\n    if (po.verbose > 2):\n        print(\"{}: Found entry '{:s}'\".format(po.mdlfile,eparblk_name_btarr.decode('UTF-8')))\n    return eparblk\n\n\ndef flyc_parameter_blocks_pos_search(po, fwmdlfile, start_pos, func_align, data_align, ver):\n    \"\"\" Finds position of flight controller parameter blocks in the binary.\n        Searches only for specific version of the parameters format.\n    \"\"\"\n    fwmdlfile.seek(0, os.SEEK_END)\n    fwmdlfile_len = fwmdlfile.tell()\n    matches = dict()\n    match_entries = 0\n    pos = start_pos\n    while (True):\n        entry_count = 0\n        eparblk = flyc_check_parameter_block_at(po, fwmdlfile, fwmdlfile_len, pos, func_align, data_align, ver)\n        if (eparblk.param_count > 0):\n            # Check how many correct parameter entries we have\n            match_pos = eparblk.params - po.baseaddr\n            entry_count = flyc_check_parameter_array_at(po, fwmdlfile, fwmdlfile_len, match_pos, func_align, data_align, ver)\n            # If entry is ok, add it to the list\n            if entry_count >= eparblk.param_count:\n                if (po.verbose > 1):\n                    print(\"{}: Matching parameter block at 0x{:08x}: {:d} entries, format {:d}\"\n                      .format(po.mdlfile, pos, entry_count, ver))\n                matches[match_pos] = entry_count\n                match_entries += entry_count\n            elif entry_count > 0:\n                if (po.verbose > 1):\n                    print(\"{}: Skipped parameter block at 0x{:08x} which was close to matching, format {:d}\"\n                      .format(po.mdlfile, pos, ver))\n                entry_count = 0\n        # Set position to search for next entry\n        if entry_count > 0:\n            pos += sizeof(eparblk)\n        else:\n            pos += data_align\n        # Stop if we're at EOF\n        if (pos + sizeof(eparblk) > fwmdlfile_len):\n            break\n    if (len(matches) > 1):\n        eprint(\"{}: Found {:d} parameter blocks with alignment 0x{:02x}\".format(po.mdlfile,len(matches),data_align))\n    return matches, match_entries\n\n\ndef flyc_parameter_array_pos_search_any(po, fwmdlfile, start_pos, func_align, data_align):\n    \"\"\" Finds position of flight controller parameters in the binary, in any version.\n    \"\"\"\n    (poslist, count) = flyc_parameter_array_pos_search(po, fwmdlfile, start_pos, func_align, data_align, 2015)\n    ver = 2015\n    (poslist_2017, count_2017) = flyc_parameter_array_pos_search(po, fwmdlfile, start_pos, func_align, data_align, 2017)\n    if count < count_2017:\n        ver = 2017\n        poslist = poslist_2017\n        count = count_2017\n    (poslist_2018, count_2018) = flyc_parameter_blocks_pos_search(po, fwmdlfile, start_pos, func_align, data_align, 2018)\n    if count < count_2018:\n        ver = 2018\n        poslist = poslist_2018\n        count = count_2018\n    return poslist, ver\n\n\ndef flyc_param_get(po, fwmdlfile, param_pos, index, ver):\n    \"\"\" Returns array with properties of given flight parameter.\n    \"\"\"\n    parprop = {'index': index, 'typeID' : 0, 'size' : 0, 'attribute' : 0,\n      'minValue' : 0, 'maxValue' : 0, 'defaultValue' : 0, 'name' : \"\", 'modify' : False,\n    }\n    eexpar = FlycExportParamFactory(ver)\n    fwmdlfile.seek(param_pos+sizeof(eexpar)*index, os.SEEK_SET)\n    if fwmdlfile.readinto(eexpar) != sizeof(eexpar):\n        raise EOFError(\"Cannot read parameter entry.\")\n\n    parprop['typeID'] = eexpar.type_id\n    parprop['size'] = eexpar.valsize\n    parprop['attribute'] = eexpar.attribute\n    if flyc_param_limit_unsigned_int(po, eexpar):\n        parprop['minValue'] = eexpar.limit_u.min\n        parprop['maxValue'] = eexpar.limit_u.max\n        parprop['defaultValue'] = eexpar.limit_u.deflt\n    elif flyc_param_limit_signed_int(po, eexpar):\n        parprop['minValue'] = eexpar.limit_i.min\n        parprop['maxValue'] = eexpar.limit_i.max\n        parprop['defaultValue'] = eexpar.limit_i.deflt\n    else:\n        parprop['minValue'] = eexpar.limit_f.min\n        parprop['maxValue'] = eexpar.limit_f.max\n        parprop['defaultValue'] = eexpar.limit_f.deflt\n    # Read property name\n    fwmdlfile.seek(eexpar.nameptr - po.baseaddr, os.SEEK_SET)\n    parprop['name'] = fwmdlfile.read(256).split(b'\\0',1)[0].decode('UTF-8')\n    # Read property alias name\n    if hasattr(eexpar, 'aliasptr') and (eexpar.aliasptr > 0):\n        fwmdlfile.seek(eexpar.aliasptr - po.baseaddr, os.SEEK_SET)\n        parprop['alias'] = fwmdlfile.read(256).split(b'\\0',1)[0].decode('UTF-8')\n    if ((eexpar.attribute & 0x0B) == 0x0B): # Just a guess\n        parprop['modify'] = True\n    return parprop\n\n\ndef flyc_param_set_type(po, fwmdlfile, param_pos, index, parprop, ver):\n    \"\"\" Updates parameter of given index with type from given parprop array.\n    \"\"\"\n    raise NotImplementedError('Changing variable type is dangerous; this is not supported.')\n\n\ndef flyc_param_set_attribs(po, fwmdlfile, param_pos, index, parprop, ver):\n    \"\"\" Updates parameter of given index with attribs from given parprop array.\n    \"\"\"\n    eexpar = FlycExportParamFactory(ver)\n    fwmdlfile.seek(param_pos+sizeof(eexpar)*index, os.SEEK_SET)\n    if fwmdlfile.readinto(eexpar) != sizeof(eexpar):\n        raise EOFError(\"Cannot read parameter entry.\")\n    eexpar.attribute = parprop['attribute']\n    fwmdlfile.seek(param_pos+sizeof(eexpar)*index, os.SEEK_SET)\n    fwmdlfile.write((c_ubyte * sizeof(eexpar)).from_buffer_copy(eexpar))\n\n\ndef flyc_param_set_limits(po, fwmdlfile, param_pos, index, parprop, ver):\n    \"\"\" Updates parameter of given index with limits from given parprop array.\n    \"\"\"\n    eexpar = FlycExportParamFactory(ver)\n    fwmdlfile.seek(param_pos+sizeof(eexpar)*index, os.SEEK_SET)\n    if fwmdlfile.readinto(eexpar) != sizeof(eexpar):\n        raise EOFError(\"Cannot read parameter entry.\")\n    if flyc_param_limit_unsigned_int(po, eexpar):\n        eexpar.limit_u.min = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['minValue'])\n        eexpar.limit_u.max = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['maxValue'])\n        eexpar.limit_u.deflt = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['defaultValue'])\n        eexpar.limit_i.min = c_int(eexpar.limit_u.min).value\n        eexpar.limit_i.max = c_int(eexpar.limit_u.max).value\n        eexpar.limit_i.deflt = c_int(eexpar.limit_u.deflt).value\n        eexpar.limit_f.min = float(eexpar.limit_u.min)\n        eexpar.limit_f.max = float(eexpar.limit_u.max)\n        eexpar.limit_f.deflt = float(eexpar.limit_u.deflt)\n        if (not isclose(eexpar.limit_u.min, float(parprop['minValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: min value {:f} bound to {:d}\"\n              .format(po.mdlfile,float(parprop['minValue']),eexpar.limit_u.min))\n        if (not isclose(eexpar.limit_u.max, float(parprop['maxValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: max value {:f} bound to {:d}\"\n              .format(po.mdlfile,float(parprop['maxValue']),eexpar.limit_u.max))\n        if (not isclose(eexpar.limit_u.deflt, float(parprop['defaultValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: dafault value {:f} bound to {:d}\"\n              .format(po.mdlfile,float(parprop['defaultValue']),eexpar.limit_u.deflt))\n    elif flyc_param_limit_signed_int(po, eexpar):\n        eexpar.limit_i.min = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['minValue'])\n        eexpar.limit_i.max = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['maxValue'])\n        eexpar.limit_i.deflt = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['defaultValue'])\n        eexpar.limit_u.min = c_uint(eexpar.limit_i.min).value\n        eexpar.limit_u.max = c_uint(eexpar.limit_i.max).value\n        eexpar.limit_u.deflt = c_uint(eexpar.limit_i.deflt).value\n        eexpar.limit_f.min = float(eexpar.limit_i.min)\n        eexpar.limit_f.max = float(eexpar.limit_i.max)\n        eexpar.limit_f.deflt = float(eexpar.limit_i.deflt)\n        if (not isclose(eexpar.limit_i.min, float(parprop['minValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: min value {:f} bound to {:d}\"\n              .format(po.mdlfile,float(parprop['minValue']),eexpar.limit_i.min))\n        if (not isclose(eexpar.limit_i.max, float(parprop['maxValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: max value {:f} bound to {:d}\"\n              .format(po.mdlfile,float(parprop['maxValue']),eexpar.limit_i.max))\n        if (not isclose(eexpar.limit_i.deflt, float(parprop['defaultValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: dafault value {:f} bound to {:d}\"\n              .format(po.mdlfile,float(parprop['defaultValue']),eexpar.limit_i.deflt))\n    else:\n        eexpar.limit_f.min = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['minValue'])\n        eexpar.limit_f.max = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['maxValue'])\n        eexpar.limit_f.deflt = flyc_param_limit_to_type(po, ver, eexpar.type_id, parprop['defaultValue'])\n        eexpar.limit_i.min = flyc_param_limit_to_type(po, ver, ParamType.long, parprop['minValue'])\n        eexpar.limit_i.max = flyc_param_limit_to_type(po, ver, ParamType.long, parprop['maxValue'])\n        eexpar.limit_i.deflt = flyc_param_limit_to_type(po, ver, ParamType.long, parprop['defaultValue'])\n        eexpar.limit_u.min = c_uint(eexpar.limit_i.min).value\n        eexpar.limit_u.max = c_uint(eexpar.limit_i.max).value\n        eexpar.limit_u.deflt = c_uint(eexpar.limit_i.deflt).value\n        if (not isclose(eexpar.limit_f.min, float(parprop['minValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: min value {:f} bound to {:f}\"\n              .format(po.mdlfile, float(parprop['minValue']), eexpar.limit_f.min))\n        if (not isclose(eexpar.limit_f.max, float(parprop['maxValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: max value {:f} bound to {:f}\"\n              .format(po.mdlfile, float(parprop['maxValue']), eexpar.limit_f.max))\n        if (not isclose(eexpar.limit_f.deflt, float(parprop['defaultValue']), rel_tol=1e-5, abs_tol=1e-5)):\n            eprint(\"{}: Warning: dafault value {:f} bound to {:f}\"\n              .format(po.mdlfile, float(parprop['defaultValue']), eexpar.limit_f.deflt))\n    fwmdlfile.seek(param_pos + sizeof(eexpar) * index, os.SEEK_SET)\n    fwmdlfile.write((c_ubyte * sizeof(eexpar)).from_buffer_copy(eexpar))\n\n\ndef flyc_list(po, fwmdlfile):\n    (po.param_poslist, po.param_ver) = \\\n      flyc_parameter_array_pos_search_any(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align)\n    if len(po.param_poslist) <= 0:\n        raise ValueError(\"Flight controller parameters array signature not detected in input file.\")\n    full_index = 0\n    for param_pos, param_count in po.param_poslist.items():\n        if (po.verbose > 1):\n            print(\"{}: Listing parameters array at 0x{:08x}: {:d} entries\".format(po.mdlfile, param_pos, param_count))\n        for i in range(0,param_count):\n            parprop = flyc_param_get(po, fwmdlfile, param_pos, i, po.param_ver)\n            parprop['index'] = full_index\n            print(\"{:3d} {:40s} {:2d} {:2d} 0x{:x} {:6.1f} {:6.1f} {:6.1f}\".format(\n              parprop['index'], parprop['name'], parprop['typeID'], parprop['size'],\n              parprop['attribute'], parprop['minValue'], parprop['maxValue'], parprop['defaultValue']))\n            full_index += 1\n    return\n\n\ndef flyc_extract(po, fwmdlfile):\n    \"\"\" Extracts all flight controller parameters from firmware to JSON format text file.\n    \"\"\"\n    (po.param_poslist, po.param_ver) = \\\n      flyc_parameter_array_pos_search_any(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align)\n    if len(po.param_poslist) <= 0:\n        raise ValueError(\"Flight controller parameters array signature not detected in input file.\")\n    inffile = open(po.inffile, \"w\")\n    inffile.write(\"[\\n\")\n    full_index = 0\n    for param_pos, param_count in po.param_poslist.items():\n        if (po.verbose > 1):\n            print(\"{}: Extracting parameters array at 0x{:08x}: {:d} entries\"\n              .format(po.mdlfile,param_pos,param_count))\n        for i in range(0,param_count):\n            parprop = flyc_param_get(po, fwmdlfile, param_pos, i, po.param_ver)\n            parprop['index'] = full_index\n            if (full_index != 0):\n                inffile.write(\",\\n\")\n            inffile.write(\"\\t{\\n\")\n            for ppname in ('index',):\n                inffile.write(\"\\t\\t\\\"{:s}\\\" : {:d}\".format(ppname,parprop[ppname]))\n            for ppname in ('typeID', 'size', 'attribute'):\n                inffile.write(\",\\n\")\n                inffile.write(\"\\t\\t\\\"{:s}\\\" : {:d}\".format(ppname,parprop[ppname]))\n            for ppname in ('minValue', 'maxValue', 'defaultValue'):\n                inffile.write(\",\\n\")\n                if (isinstance(parprop[ppname], float)):\n                    inffile.write(\"\\t\\t\\\"{:s}\\\" : {:.06f}\".format(ppname,parprop[ppname]))\n                else:\n                    inffile.write(\"\\t\\t\\\"{:s}\\\" : {:d}\".format(ppname,parprop[ppname]))\n            for ppname in ('name',):\n                inffile.write(\",\\n\")\n                inffile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,parprop[ppname]))\n            for ppname in ('alias',):\n                if ppname not in parprop: continue\n                inffile.write(\",\\n\")\n                inffile.write(\"\\t\\t\\\"{:s}\\\" : \\\"{:s}\\\"\".format(ppname,parprop[ppname]))\n            if parprop['modify']:\n                inffile.write(\",\\n\")\n                inffile.write(\"\\t\\t\\\"{:s}\\\" : {:s}\".format('modify','true'))\n            inffile.write(\"\\n\")\n            inffile.write(\"\\t}\")\n            full_index += 1\n    inffile.write(\"\\n\")\n    inffile.write(\"]\\n\")\n    inffile.close()\n\n\ndef flyc_update(po, fwmdlfile):\n  \"\"\" Updates all flight controller parameters in firmware from JSON format text file.\n  \"\"\"\n  (po.param_poslist, po.param_ver) = \\\n    flyc_parameter_array_pos_search_any(po, fwmdlfile, 0, po.expect_func_align, po.expect_data_align)\n  if len(po.param_poslist) <= 0:\n      raise ValueError(\"Flight controller parameters array signature not detected in input file.\")\n  with open(po.inffile) as inffile:\n      nxparprops = json.load(inffile)\n  update_count = 0\n  full_index = 0\n  param_pos_start_index = 0\n  for param_pos, param_count in po.param_poslist.items():\n      if (po.verbose > 1):\n          print(\"{}: Updating parameters array at 0x{:08x}: {:d} entries\"\n            .format(po.mdlfile,param_pos,param_count))\n      # Remember full index which corresponds to param_pos\n      param_pos_start_index = full_index\n      for i in range(0, param_count):\n          # get the param from binary file\n          pvparprop = flyc_param_get(po, fwmdlfile, param_pos, i, po.param_ver)\n          pvparprop['index'] = full_index\n          # find it in our update list\n          nxparprop = None\n          for parprop in nxparprops:\n              if (parprop['name'] == pvparprop['name']):\n                  nxparprop = parprop\n                  break\n          if (nxparprop is None):\n              eprint(\"{}: Warning: parameter not found in fw: \\\"{:s}\\\"\"\n                .format(po.mdlfile,pvparprop['name']))\n              continue\n          # compare properties to check what we want to update\n          update_type = False\n          update_attrib = False\n          update_limits = False # limits are: min, default, max value\n          for ppname in ('typeID', 'size'):\n              if (pvparprop[ppname] != nxparprop[ppname]):\n                  update_type = True\n                  update_limits = True\n          for ppname in ('attribute',):\n              if (pvparprop[ppname] != nxparprop[ppname]):\n                  update_attrib = True\n          for ppname in ('minValue', 'maxValue', 'defaultValue'):\n              if (isinstance(pvparprop[ppname], float)):\n                  if (not isclose(pvparprop[ppname], nxparprop[ppname], rel_tol=1e-5, abs_tol=1e-5)):\n                      #print(\"{}: Prop \\\"{:s}\\\" {:s} test: {:s} vs {:s}\".format(po.mdlfile,pvparprop['name'],ppname,str(pvparprop[ppname]),str(nxparprop[ppname])))\n                      update_limits = True\n              else:\n                  if (pvparprop[ppname] != nxparprop[ppname]):\n                      #print(\"{}: Prop \\\"{:s}\\\" {:s} test: {:s} vs {:s}\".format(po.mdlfile,pvparprop['name'],ppname,str(pvparprop[ppname]),str(nxparprop[ppname])))\n                      update_limits = True\n          if (update_type or update_attrib or update_limits):\n              if (po.verbose > 1):\n                  print(\"{}: Updating \\\"{:s}\\\" {:s}{:s}{:s}\".format(po.mdlfile,\n                    pvparprop['name'], \" type,\" if update_type else \"\",\n                    \" attribs,\" if update_attrib else \"\", \" limits,\" if update_limits else \"\"))\n              update_count += 1\n          # use index local to block, not the global index stored within property\n          pvparprop_i = pvparprop['index'] - param_pos_start_index\n          # do the update\n          if (update_type):\n              flyc_param_set_type(po, fwmdlfile, param_pos, pvparprop_i, nxparprop, po.param_ver)\n          if (update_attrib):\n              flyc_param_set_attribs(po, fwmdlfile, param_pos, pvparprop_i, nxparprop, po.param_ver)\n          if (update_limits):\n              flyc_param_set_limits(po, fwmdlfile, param_pos, pvparprop_i, nxparprop, po.param_ver)\n          full_index += 1\n  if (po.verbose > 0):\n      print(\"{}: Updated {:d} parameter entries\".format(po.mdlfile,update_count))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-m', '--mdlfile', type=str, required=True,\n          help=\"flight controller firmware binary module file\")\n\n    parser.add_argument('-i', '--inffile', type=str, default=\"flyc_param_infos\",\n          help=\"flight Parameter Info JSON file name (default is \\\"%(default)s\\\")\")\n\n    parser.add_argument('-b', '--baseaddr', default=0x8020000, type=lambda x: int(x,0),\n          help=\"set base address; crucial for finding the array (default is 0x%(default)X)\")\n\n    parser.add_argument('--bssaddr', default=0x20000000, type=lambda x: int(x,0),\n          help=\"set .bss start address; set to address where RAM starts (default is 0x%(default)X)\")\n\n    parser.add_argument('--bsslen', default=0x4400000, type=lambda x: int(x,0),\n          help=\"set .bss length; set to size of RAM (default is 0x%(default)X)\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-l', '--list', action='store_true',\n          help=\"list parameters stored in the firmware\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract parameters array to infos json text file\")\n\n    subparser.add_argument('-u', '--update', action='store_true',\n          help=\"update parameters array in binary fw from infos text file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.expect_func_align = 4\n    po.expect_data_align = 2\n    po.param_poslist = {}\n    po.param_ver = 2015\n\n    if po.list:\n        if (po.verbose > 0):\n            print(\"{}: Opening for list display\".format(po.mdlfile))\n        with open(po.mdlfile, 'rb') as fwmdlfile:\n            flyc_list(po,fwmdlfile)\n\n    elif po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extraction\".format(po.mdlfile))\n        with open(po.mdlfile, 'rb') as fwmdlfile:\n            flyc_extract(po,fwmdlfile)\n\n    elif po.update:\n        if (po.verbose > 0):\n            print(\"{}: Opening for update\".format(po.mdlfile))\n        with open(po.mdlfile, 'r+b') as fwmdlfile:\n            flyc_update(po,fwmdlfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dji_imah_fwsig.py",
          "type": "blob",
          "size": 63.640625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DJI Firmware IMaH Un-signer and Decryptor tool.\n\nAllows to decrypt and un-sign module from `.sig` file which starts with\n`IM*H`. Use this tool after untarring single modules from a firmware package,\nto decrypt its content.\n\n\"\"\"\n\n# Copyright (C) 2017  Freek van Tienen <freek.v.tienen@gmail.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.3.1\"\n__author__ = \"Freek van Tienen, Jan Dumon, Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport re\nimport os\nimport argparse\nimport configparser\nimport itertools\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import Counter\nfrom Crypto.Hash import SHA256\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\nfrom Crypto.Signature import pss\nfrom ctypes import c_char, c_int, c_ubyte, c_uint, c_ulonglong\nfrom ctypes import memmove, sizeof, addressof, Array, LittleEndianStructure\nfrom collections import OrderedDict\nfrom time import gmtime, strftime, strptime\nfrom copy import copy\n\n# All found keys\nkeys = {\n    # Encryption keys\n    \"RREK-2017-01\":  bytes([ # RR Encryption Key v1; published 2017-06-27 by Freek van Tienen\n        # This key is used for protecting storage of development keys, it typically encrypts a container\n        # with plaintext RIEK key inside.\n        # used for: WM330 FW V00.01.0000-V01.02.0499, WM220 FW V00.01.0000-V01.03.0600\n        0x37, 0xD6, 0xD9, 0x13, 0xE5, 0xD0, 0x80, 0x17, 0xE5, 0x12, 0x15, 0x45, 0x0C, 0x1E, 0x16, 0xE7\n    ]),\n    \"RIEK-2017-01\":  bytes([ # R&D Image Encryption Key v1; published 2017-06-27 by Freek van Tienen\n        # This key is used on many platforms, for pre-production development and engineering images;\n        # it is used as pre-production version of IAEK key\n        # used for: WM330 FW V00.01.0000-V01.02.0499, WM220 FW V00.01.0000-V01.03.0600\n        0xF1, 0x69, 0xC0, 0xF3, 0x8B, 0x2D, 0x9A, 0xDC, 0x65, 0xEE, 0x0C, 0x57, 0x83, 0x32, 0x94, 0xE9\n    ]),\n    \"IAEK\":  bytes([ # Inner Image encryption key; published 2022-11-29 by M4xw & adinbied\n        # This key is used on WM330/WM220's inner image encryption (normal.img of m0801 f.e.)\n        # and is referenced on some other platforms\n        0x89, 0x9D, 0x1B, 0x90, 0xB1, 0xAE, 0x9D, 0x92, 0xB6, 0x0D, 0xC1, 0xE1, 0x1A, 0xD4, 0x79, 0xA0\n    ]),\n    \"RUEK\":  bytes([ # RU Encryption Key v1; published 2017-06-27 by Freek van Tienen\n        0x9C, 0xDA, 0xF6, 0x27, 0x4E, 0xCB, 0x78, 0xF3, 0xED, 0xDC, 0xE5, 0x26, 0xBC, 0xEC, 0x66, 0xF8\n    ]),\n    \"DRAK\":  bytes([ # DR Auth Key v1; published 2017-06-27 by Freek van Tienen\n        0x6f, 0x70, 0x7f, 0x29, 0x62, 0x35, 0x1d, 0x75, 0xbc, 0x08, 0x9a, 0xc3, 0x4d, 0xa1, 0x19, 0xfa\n    ]),\n    \"SAAK\":  bytes([ # SDR_Auth Auth Key v1; published 2017-06-27 by Freek van Tienen\n        0x6f, 0x40, 0x2f, 0xb8, 0x62, 0x52, 0x05, 0xce, 0x9b, 0xdd, 0x58, 0x02, 0x17, 0xd2, 0x18, 0xd8\n    ]),\n    # There are multiple PUEK keys, as DJI tried changing them as soon as they are published,\n    # without fixing vulnerabilities which allowed to read them\n    \"PUEK-2017-07\":  bytes([ # Programming Update Enc Key whitebox AES v1; published 2017-10-25 by Freek van Tienen\n        # first use on 2017-07-28; used for: WM335 FW V01.00.1000-V01.00.5200,\n        # WM220 FW V01.04.0000-V01.04.0500, PM420 FW V01.01.0450-V01.01.0590,\n        0x63, 0xc4, 0x8e, 0x83, 0x26, 0x7e, 0xee, 0xc0, 0x3f, 0x33, 0x30, 0xad, 0xb2, 0x38, 0xdd, 0x6b\n    ]),\n    \"PUEK-2017-01\": bytes([ # Programming Update Enc Key Old Non-whitebox v1; published 2017-06-27 by Freek van Tienen\n        # used for: WM330 FW V00.01.0000-V01.02.0499, WM220 FW V00.01.0000-V01.03.0600\n        0x70, 0xe0, 0x03, 0x08, 0xe0, 0x4b, 0x0a, 0xe2, 0xce, 0x8e, 0x07, 0xd4, 0xd6, 0x21, 0x4b, 0xb6\n    ]),\n    \"TRIE-2021-06\":  bytes([ # TR Image Encryption key; published 2021-08-26 by OGs\n        # first use on 2021-06-15; used for: WM1605 FW\n        0xcb, 0x14, 0x0c, 0x12, 0x71, 0x03, 0x88, 0x34, 0xec, 0x0c, 0x0c, 0x3c, 0x2b, 0x69, 0x9d, 0xc2\n    ]),\n    \"TRIE-2019-11\":  bytes([ # TR Image Encryption key; published 2021-03-26 by Felix Domke\n        # first use on 2019-11-07; used for: WM160 FW, WM161 FW\n        0xf1, 0xe6, 0x30, 0x6d, 0x6c, 0x84, 0xf0, 0x9e, 0xd5, 0x59, 0x0f, 0x94, 0x73, 0xb1, 0x55, 0x26\n    ]),\n    \"TKIE-2021-06\":  bytes([ # Trusted Kernel Image Encryption key; published 2021-08-26 by OGs\n        # This key is used for images within m0100 module which store kernel and device tree\n        # first use on 2021-06-15; used for: WM1605 FW V01.00.0000-V01.01.0000,\n        0xf8, 0xb4, 0x3c, 0x6b, 0x0d, 0xcd, 0x3f, 0x5e, 0x90, 0xfc, 0x08, 0xd4, 0xdd, 0xea, 0xf3, 0x58\n    ]),\n    \"TKIE-2019-11\":  bytes([ # Trusted Kernel Image Encryption key; published 2021-03-26 by Felix Domke\n        # This key is used for images within m0100 module which store kernel and device tree\n        # first use on 2019-11-07; used for:\n        # WM160 FW V01.00.0200-V01.00.0500, WM161 FW V01.00.0000-V01.02.0300\n        0xb6, 0x28, 0x6a, 0x05, 0xfc, 0x3a, 0x02, 0xf0, 0x36, 0x51, 0x11, 0xf0, 0x20, 0x45, 0x03, 0xa3\n    ]),\n    \"TBIE-2021-06\":  bytes([ # Trusted Boot Image Encryption key; published 2021-06-25 by OGs\n        # first use on 2021-06-15; used for: WM1605 FW V01.00.0000-V01.01.0000,\n        0x06, 0xdc, 0x7b, 0x70, 0x7f, 0xc1, 0xdb, 0x86, 0x49, 0x8c, 0xaa, 0xda, 0xde, 0xdf, 0x56, 0xa1\n    ]),\n    \"TBIE-2020-04\":  bytes([ # Trusted Boot Image Encryption key; published 2021-06-25 by OGs\n        # first use on 2020-04-23; used for:\n        # RCS231 FW V01.00.0108-V02.00.1200,\n        # RC-N1-WM161B FW V04.11.0016,\n        # RCJS170 FW V01.01.0000,\n        # RCSS170 FW V01.01.0000,\n        0x48, 0xd6, 0xe8, 0xff, 0x1b, 0x7f, 0x20, 0x6e, 0x2d, 0xa7, 0x99, 0xc2, 0x7e, 0x5a, 0xd7, 0x0d\n    ]),\n    \"TBIE-2020-02\":  bytes([ # Trusted Kernel Image Encryption key; published 2021-11-19 by OGs\n        # first use on 2021-06-15; used for:\n        # WM230 FW (versions untested), WM232 (untested), PM430 (untested)\n        0x7b, 0xca, 0x59, 0x6f, 0x22, 0x73, 0xc5, 0x19, 0x5e, 0x41, 0x42, 0xaa, 0x3d, 0x20, 0x1e, 0x25\n    ]),\n    \"TBIE-2019-11\":  bytes([ # Trusted Boot Image Encryption key; published 2021-03-26 by Felix Domke\n        # first use on 2019-11-07; used for:\n        # WM160 FW V01.00.0200-V01.00.0500, WM161 FW V01.00.0000-V01.02.0300\n        0x54, 0xb8, 0xb9, 0xd7, 0x4c, 0x2b, 0x41, 0x46, 0x9c, 0x4d, 0xac, 0x3d, 0x16, 0xcc, 0x6f, 0x47\n    ]),\n    \"TBIE-2018-07\":  bytes([ # Trusted Boot Image Encryption key; published 2021-06-23 by fpv.wtf team\n        # first use on 2018-07-13; used for:\n        # WM240 FW V00.06.0000-V01.00.0670,\n        # WM245 FW V01.01.0000-V01.01.0800,\n        # WM246 FW V01.00.0000-V01.01.0800,\n        # GL150 FW V01.00.0600, LT150 FW V01.00.0600,\n        0xff, 0x94, 0x76, 0xf7, 0x8a, 0x89, 0xb9, 0x44, 0x9b, 0x6a, 0x90, 0x55, 0x64, 0x13, 0xb9, 0xc3\n    ]),\n    \"UFIE-2021-06\":  bytes([ # Update Firmware Image Encryption key; published 2021-08-26 by OGs\n        # first use on 2021-06-15; used for: WM1605 FW V01.00.0000-V01.01.0000,\n        0x84, 0x63, 0xf7, 0xb1, 0xa6, 0xaa, 0xa5, 0xec, 0xa3, 0x8a, 0x9a, 0xbc, 0x7b, 0x3d, 0x4b, 0xe2\n    ]),\n    \"UFIE-2020-04\":  bytes([ # UFI Encryption key; published 2021-06-20 by OGs\n        # first use on 2020-04-24; used for:\n        # WM170 FW V00.04.1009-V01.01.0000,\n        # GL170 FW V01.01.0000,\n        # WM231 FW V01.00.0113-V09.09.0902,\n        # WM232 FW V02.04.1640,\n        # PM430 FW, AG500 FW\n        # WM260 FW V01.00.0600\n        0xba, 0xb3, 0xcd, 0x72, 0x36, 0xb2, 0xe1, 0xd8, 0x66, 0x49, 0x35, 0xc9, 0xc2, 0x58, 0x8f, 0x3c\n    ]),\n    \"UFIE-2019-11\":  bytes([ # Update Firmware Image Encryption key; published 2021-03-26 by Felix Domke\n        # first use on 2019-11-07; used for:\n        # WM160 FW V01.00.0200-V01.00.0500, WM161 FW V01.00.0000-V01.02.0300,\n        # WM1615 FW V01.00.0360 \n        0xad, 0x45, 0xcd, 0x82, 0x13, 0xfb, 0x7e, 0x25, 0x5d, 0xbe, 0x45, 0x41, 0x70, 0xbc, 0x11, 0xa0\n    ]),\n    \"UFIE-2018-07\":  bytes([ # Update Firmware Image Encryption key; published 2021-06-20 by OGs\n        # first use on 2018-07-13; used for:\n        # WM240 FW V00.06.0000-V01.00.0670, RC240 FW V01.00.0640, WM241 FW,\n        # WM150 FW V01.01.0000, GL150 FW V01.00.0600, LT150 FW,\n        0x78, 0x09, 0x39, 0xe1, 0xbe, 0x11, 0x7a, 0x66, 0xd3, 0x58, 0x41, 0xe9, 0x5b, 0x06, 0xaa, 0xc0\n    ]),\n    \"UFIE-2018-01\":  bytes([ # Update Firmware Image Encryption key; published 2021-06-19 by OGs\n        # first use on 2018-01-26; used for: WM230 FW V00.02.0026-V01.00.0500,\n        # RC230 FW V01.00.0000-V01.00.0200,\n        0xcd, 0x3a, 0xa5, 0x72, 0x2a, 0x41, 0x0b, 0x6d, 0xba, 0x3d, 0xaf, 0x2e, 0x99, 0xf3, 0xd9, 0x6d\n    ]),\n    \"SLEK\":  bytes([ # Slack community Encryption Key; generated 2018-01-19 by Jan Dumon\n        0x56, 0x79, 0x6C, 0x0E, 0xEE, 0x0F, 0x38, 0x05, 0x20, 0xE0, 0xBE, 0x70, 0xF2, 0x77, 0xD9, 0x0B\n    ]),\n\n    # RSA authentication keys\n    \"PRAK-2018-01\":  bytes.fromhex(( # Provisioning RSA Auth Key v8; published 2021-09-30 by Mefistotelis\n        # first use on 2021-02-03; used for:\n        # RCS231 FW V01.00.0000\n        # RC-N1-WM161b FW V01.00.0000\n        # RCJS170 FW V01.00.0000\n        # RCSS170 FW V01.00.0000\n        \"400000008f73897091b44b1eeef365bc3b7bcca12798f87d0c1523cdca37eee2\"\n        \"5b83ef4750bc04025aeb0a929b9ed5e228242a866a7b5cfa3c0a9f2681553026\"\n        \"476976f9a31d72752b58a41ad4553bd007504dfa7247688140e130774d2d5952\"\n        \"48923396f571b2f7623d75dfa2901d18156e075f2fa176bb41dbeb2806600057\"\n        \"0f6f683e26c1afbe9b6f2d0e9928197d898665d318e21ab311e4fba035f65ed1\"\n        \"509ee505e0aa40a35e343ab5889113b03bfc2e5c4b6fefbe0445904e4c8a3cab\"\n        \"4379d45f24cefd7e05200a3e89c3fe5bfe7b13f4ef19f4ea747074cf2376e2f7\"\n        \"9b291b78e8840ee79fca2fd8f86bc41bedbbf8bd912c34aeb9168530f72aa54e\"\n        \"9f8d1c3bf5393d9de93e07ee517744ce5c94fc417ba10b462c653fe09fc656c3\"\n        \"5001af6ab59517f344899be9c1298688931c89d8eb941687bf6e11039ef93033\"\n        \"61c5ff4bad025f9dd6492c0b9fc61ec2b08bd3cfeb600f7cfb722911b15068a6\"\n        \"ae8cbeebcda57cebf2d6fc330528ca5bd14e8b70fb0d662d76470adb7fff076d\"\n        \"f3367534f3afd0604fc4714f730b3c63a59f995bef2df005f656be887d6369ca\"\n        \"b1614d66763b10ef50a7f6e3c6f55bd381d7c23924ecd6d3453902f8fbfb7ca5\"\n        \"2f63e44e6a3cb6193ec495527566387caaf3bb217725033b94352d925f5e94d4\"\n        \"d5005c48dda0e26a36a5a77efceef3eb2f3e55a996870c177f4d4d26163f04ba\"\n        \"c9d54d60bb162b5e03000000\"\n    )),\n    \"PRAK-2020-01\":  bytes.fromhex(( # Provisioning RSA Auth Key v7; published 2021-09-30 by Mefistotelis\n        # first use on 2020-01-08; used for:\n        # WM170 FW V00.04.1009-V01.01.0000,\n        # GL170 FW V01.01.0000,\n        # WM231 FW V01.00.0113-V09.09.0902,\n        # WM232 FW V02.04.1640\n        # WM260 FW V01.00.0600\n        \"40000000c73fb7ba092e1fef4344b95a4ed80566b2a3aaaca69e3f7847a7e6d5\"\n        \"896cf3b9f64e771b6c44f32e3fab2e91ab5834e48bbf8e8ad38038e810ab3dd5\"\n        \"1f8b54f677eb5917e9df95fb0fd97445b2c40beedbb4256ac5a381c8ae16a99f\"\n        \"bcfcb66cb2a350e0e137e7cd77d069bf2c7567a2e292bdda3071376b4695a77e\"\n        \"4e6910b15f7a11edf48c1b4a3122f7ac623574864e292f0c16403d30322dfe32\"\n        \"7cef7c35b0c76a4947c50f67a7ad4b4afc64a02eada67325d6d278eb3ab6b7a3\"\n        \"3caea718f66b730d3f263b9395884910fe3567f7a0e149673634f49b6abea872\"\n        \"7fad4066a548a836f431326ec8cc1e682d697cc958cf4872be3343007c31d9e4\"\n        \"a3878d6cfa3987c96ce786073abcca064f5c6657ffd5701b5d0748f5b6c1863e\"\n        \"b620ad7ded26509e4e23cd9afac0e049f3ad2a066dd9bbf0293bb22e2859964f\"\n        \"292ce6ba206628aa50a0bc7422541540b7efb9433c94c865b322f8a7aebe91e5\"\n        \"d212da29e4f434a35173b0999a7f792cce3e7ef7c51274b8776ef1a743b77983\"\n        \"aeee0b3701814b8ee640e7ec18fa9c15a3bb59de1086517bec5c4f8940b1001e\"\n        \"b4dccdefc113d4db345c7c2e129c867794cb9c32a06255dfb8be68763b0a0940\"\n        \"71df74e113d24e749a4008b6372fc5c87fcd781319a71f6ac60f5fa5dc2b2ce9\"\n        \"71318b45ac83ee882a0dbf22d09ab1da28bc5e828a0080f35279dc3fb5a83d16\"\n        \"5a981f8574e41e2d01000100\"\n    )),\n    \"PRAK-2019-09\":  bytes.fromhex(( # Provisioning RSA Auth Key v5; published 2021-04-02 by Felix Domke\n        # first use on 2020-06-09; used for:\n        # WM161 FW V01.00.0000\n        # WM1615 FW V01.00.0360\n        \"40000000a1f987bf9fd539732277b64b32f178d7a62106d20336f2888292ee28\"\n        \"3790524565232831d245919a3a88d92a754cafbb1b8ccaed67dec3a29e0f425b\"\n        \"28cda10838a170227343eec744f78f3b5d19e9823a08fe6ee539fa7c0538e498\"\n        \"5e5d7a281f6854a2f511541649f190defcc3c7cf614a45c798076306c0f5ae34\"\n        \"d9f54da1adfc8d1585e47d4ba363b8289e48c8337fc4e9e1749d84a86ca5139b\"\n        \"552a89657a4844d2b8c497989608746a95252479dd468298671e6c42dfbf5828\"\n        \"bde4f669b9553ee86e5189df3f3bc86ef7277bffc71cb824fd705e86296a671f\"\n        \"959ed1add22a1ad22818fdfbf3cc4ffc1547f29da481c9472805896456aeac5f\"\n        \"eaf6113e34ec07b8a297b1278aaf546a24ecc42479b6284eebc7b6450bc0c979\"\n        \"b0ed4a5d13dd035a4464125c838a8f0b34c53978dbc4e7280b6bc41d5f4f3d86\"\n        \"8f585fc161113460de573421469fdfd112e1890dd2aae587c3204022f2fbeda4\"\n        \"1dc324a125ae15adc5c14ff2c39d98e7e3b114d4c75474437732dde3cbdb7b02\"\n        \"20320a9fd46e2284d2dadf2b53b10cf1644bb470cdab38863601e80566960679\"\n        \"a4c4402454b3d7d97f6ee15bf7caea26f36888150485d38e598e21ac2e164e1b\"\n        \"5d27e62d254ffa520e6cc0ff61a7ac756f597a82474881578ffa47b8ce579d22\"\n        \"ce0b43a199f27a59f8a80b7cb9c0f9c3cf168f9095b5f5d862f2e174e30ed61e\"\n        \"4992e6594045d58001000100\"\n    )),\n    \"PRAK-2017-12\":  bytes.fromhex(( # Provisioning RSA Auth Key v3; published 2021-09-30 by Mefistotelis\n        # first use on 2017-12-14; used for:\n        # RC230 FW V01.00.0000,\n        # RC240 FW V01.00.0640,\n        # WM240 FW V00.06.0000-V01.00.0670 inside m090?,\n        # WM245 FW V01.01.0000-V01.01.0800 inside m090?,\n        # WM246 FW V01.00.0000-V01.01.0800 inside m090?,\n        \"40000000c3151641157d30448fee8958d684332e8b28213cdb05c923e06afe2d\"\n        \"13371b4887c2872f7fd674490e250017183a9fcfb4109fddd86a555fc874b08d\"\n        \"6419c4b7fa7e03b8f106a08f571e8c26a532fc23e1dd0d7fe4d496523b08bc50\"\n        \"d9238a6baab57d37a13f3afd91284c8b98e2b45ecb87bdcbe691d8764f907729\"\n        \"0b236c0d8df4b2eb3ba2f36671967aeefb4ec263c9e4d75006d97f60a5eb8848\"\n        \"4b42707d0a28b9a116526acf8bc98e7e97aaa09aa5e2c8b6aaab7a2c21283c73\"\n        \"d668ecd7f024b8ebbaf278a587b6a064525d0703c5b62e8df7b6565913cb87ff\"\n        \"b96ee578d8a5329c93831cc1857104a4f2ba9d5b0055a50305c46f469ad4641a\"\n        \"1fa98f9492bdfd94e094cbfcd95ab04bd7f3400010deed20cfcd361ddb2f5fda\"\n        \"87ada7285afb9cd7521953dadb73b288edfb00ecdd769e78d2ca4294646590c1\"\n        \"8d5954b846d00bfd682e30f970e10d1fe960e724023a05474ea68cd9738d582f\"\n        \"cb3918563ac85ba6417964fffaf1710a3d2f5d870b5024764812c2ab6ff24cf8\"\n        \"0ee6d220c716a337a4bcd9c904e17b5e9f226ef6994a350635ee8c7a6f13d820\"\n        \"f9b87c1ef8ba206e7856e17e1d9a7ed6b7b23c7c14009d9622a775de575fdc1d\"\n        \"d19e57df90c65c81a80cb05fa7318080a61dff9b0d852267d6e8c6fd531e2787\"\n        \"bab7ff29818a38f2e6c2b41698f11c3b2a0c4ac66a966a42ce3bce7c8d5f1ecc\"\n        \"9543ff55f309df3b01000100\"\n    )),\n    \"PRAK-2017-08\":  bytes.fromhex(( # Provisioning RSA Auth Key v2; published 2021-04-02 by Mefistotelis\n        # first use on 2017-08-24; used for:\n        # WM230 FW V00.02.0032-V01.00.0620,\n        # WM240 FW V00.06.0000-V01.00.0670 m0801,\n        # WM245 FW V01.01.0000-V01.01.0800 m0801,\n        # WM246 FW V01.00.0000-V01.01.0800 m0801,\n        # WM150 FW V01.00.0100,\n        # GL150 V01.00.0100-V01.00.0600,\n        # LT150 V01.00.0600\n        \"40000000dbe15b5badcde418e2dbd9e253d2b9aded7f187824b5677f0ee6a6c3\"\n        \"fcd2ea329421a5b0252c63af6df81ac0c6416ec926e2558f4f4460a4b3af3ecb\"\n        \"7fd4db4741c3602b900c495acff5f8651da895f4a60030b3be640f8382222793\"\n        \"a17c510a34a25f7ddb371a45f6bfce5b74e1d1fc63213e13190b515cde9066de\"\n        \"4253ced7bf8ff9d10bf63235d8717eda922e17e60cc61d652a05d84f0c04e61b\"\n        \"8b2098275c1bc4a571b7fc957dd6da62696b64ac0c2060566df583df5838bd4a\"\n        \"bb1acc762f53f23efbda511e38d47e212e875bbddc183b479d0322cb9d604399\"\n        \"f88c72a95365af728e783d1721750d8774b1752d65be4d2c4d2aa4c1e94f10c2\"\n        \"98890cf780c322c93a57b3e94512de8fdb48e0c0eeeb1bb0f2aa47a322471f19\"\n        \"41f1ba93daceac32d28134e7697c9913db1dbb9c021f7a72d6f361c235cca6d8\"\n        \"e6551300256958bc1ae469d6560acdcbf396b2a3de5b9c9c3098650795274119\"\n        \"23dc5eaa4e07882bf44deb8148cf0166999fae7d3dbb44a48e7d60405f8fc5c8\"\n        \"a16ffc979007dcbf6a8438b3e91d57602bffe994138bb34c8a0363fcb873556f\"\n        \"bbd17ffda86650c7dc4d7dc567a3c97ac1c3bdd6e803761352e2722e0da477c0\"\n        \"41782ef66cec1d8277ee0bc8e868b8a243b1ddee4409880d7e02ede5f1247d52\"\n        \"1820917aba93369e96f326c65fba2370ffc9db17aa3aefa062cc45e93e81d9cb\"\n        \"36748cd95224988901000100\"\n    )),\n    \"PRAK-2017-01\":  bytes.fromhex(( # Provisioning RSA Auth Key v1; published 2017-06-27 by Freek van Tienen\n        # first use on 2017-04-22; used for:\n        # WM335 FW V01.00.1000-V01.00.5200,\n        # WM220 FW V01.04.0000-V01.04.0500,\n        # PM420 FW V01.01.0450-V01.01.0590,\n        # WM100 FW V01.00.0000-V01.00.1000,\n        # WM620 FW V01.00.0000-V01.02.0500,\n        \"40000000c3151641157d30448fee8958d684332e8b28213cdb05c923e06afe2d\"\n        \"13371b4887c2872f7fd674490e250017183a9fcfb4109fddd86a555fc874b08d\"\n        \"6419c4b7fa7e03b8f106a08f571e8c26a532fc23e1dd0d7fe4d496523b08bc50\"\n        \"d9238a6baab57d37a13f3afd91284c8b98e2b45ecb87bdcbe691d8764f907729\"\n        \"0b236c0d8df4b2eb3ba2f36671967aeefb4ec263c9e4d75006d97f60a5eb8848\"\n        \"4b42707d0a28b9a116526acf8bc98e7e97aaa09aa5e2c8b6aaab7a2c21283c73\"\n        \"d668ecd7f024b8ebbaf278a587b6a064525d0703c5b62e8df7b6565913cb87ff\"\n        \"b96ee578d8a5329c93831cc1857104a4f2ba9d5b0055a50305c46f469ad4641a\"\n        \"1fa98f9492bdfd94e094cbfcd95ab04bd7f3400010deed20cfcd361ddb2f5fda\"\n        \"87ada7285afb9cd7521953dadb73b288edfb00ecdd769e78d2ca4294646590c1\"\n        \"8d5954b846d00bfd682e30f970e10d1fe960e724023a05474ea68cd9738d582f\"\n        \"cb3918563ac85ba6417964fffaf1710a3d2f5d870b5024764812c2ab6ff24cf8\"\n        \"0ee6d220c716a337a4bcd9c904e17b5e9f226ef6994a350635ee8c7a6f13d820\"\n        \"f9b87c1ef8ba206e7856e17e1d9a7ed6b7b23c7c14009d9622a775de575fdc1d\"\n        \"d19e57df90c65c81a80cb05fa7318080a61dff9b0d852267d6e8c6fd531e2787\"\n        \"bab7ff29818a38f2e6c2b41698f11c3b2a0c4ac66a966a42ce3bce7c8d5f1ecc\"\n        \"9543ff55f309df3b01000100\"\n    )),\n    \"RRAK\":  bytes.fromhex(( # R RSA Auth Key v1; published 2017-06-27 by Freek van Tienen\n        \"400000000f636a5011d4a936eb0347a6c5bfde3664f79bb8a59850da53b411ba\"\n        \"244cdb21d23db498f560acdeb8143bed386b52f78aa7b5f384da5cf233ad2ae4\"\n        \"6ba4c9f2ba5b348ea1b9b93e380e6e03c627be7ea5e11e5b257d15437a15d41e\"\n        \"c39a74fbab06412b8f87991d4f168d8f292c253a3e5c97304d625be35dfd8a14\"\n        \"79e7dea40b46e4c370df365a25ea159c7190d989c990abb86691c814eed2d45c\"\n        \"d9ed2f4e69383ab7a054ccde6a7845bcd7a386b1cf3d8cdbf7ce86989b30b11f\"\n        \"2d382435528cc7d3e5293e2afeacd910bc593b3aab2baabf87808b81c934f877\"\n        \"08557e3710e2674013d5eb590c83f4628580d27114d1b61c5e6e6a335389d456\"\n        \"e247f4b81a8658d0a5dcf23ac8bd867a1f25297154abf06ce9954b4db5bfc063\"\n        \"0473d985f5059cd909516ad6897739f3611fece7a6c2ddce9c8f418614ff2c64\"\n        \"1143e6e238ae15e953b081d31a35b985521d3e9651d7b3722dccfb0478dcda36\"\n        \"93a7b8be0d69757591415188c12a1dd99c53c71afa752594b5edb3c5cc64bd6f\"\n        \"4daf681afe17d4c1c48c82ef5b1c7106972503e9def3fe93f2df77bec5b580a6\"\n        \"19ff16b53609c3e0fc74719db7604d3d5766b14a08be33543c86e219dd09832e\"\n        \"ebeb4b8a13f78fe34a1c51222935cc4bcf05717a36621b432174c70977f7188a\"\n        \"cb2e373dcdffcc719019fd148ef263fc2172d1002b800cc5c2395224ef23baf4\"\n        \"4ad51bd6474071ab01000100\"\n    )),\n    \"GFAK\":  bytes.fromhex(( # Geofence Auth Key v1; published 2017-06-27 by Freek van Tienen\n        \"400000009b57a8886dc93e041e14808e38d810376d976948e8784b4ac0464881\"\n        \"fcc3ab99c61275391ec963ebd58e3d6a4ec460fc1ae1db270d9cf870fc879e63\"\n        \"3b7199e6a2f4872efafc1df27374b30219353f21d8972e75feb5040a50b2482f\"\n        \"256591df63c6aa56a63306b296ce118fb43a2e1592a35a4579044913a47fa1c6\"\n        \"843ffa057fb41b7d09e4a95d218abc39c66ce2968625e8a84265fef951bab8aa\"\n        \"23b2859fdffc26426ace8dc93fdd4c6384f5687440dd3bc8c7189ed6d463a9b5\"\n        \"468f4d70d54dfd76e680adc8ff84c394416e7d1f3a2378f993efc48a29995acd\"\n        \"1758300674a270c30ceacc1df68a3f52ca6712e8eabacf44f10519b9e3203190\"\n        \"c4e8e8a9bf87f1c9492838f0e7a42c665173144d03d475f1d94794937bb2da80\"\n        \"97b6ced0f9d370aa578aa92c297a19cd5a0854e97cf5a9d35f6645819a160718\"\n        \"f6c20702d35d4240ae9b0d2484065973890eddb4a8b4be19a8cdd7cc52557107\"\n        \"a65d2fc1bfe3c87a165d68ad2f5901390141c0fbf1aef7b2a89edd7507579b64\"\n        \"8387b94ebae2f15c96fe1e5ecff8cc85ce73a6f67cd7260bc7389807ecbaedba\"\n        \"0593168a03eebb4805fcc2b5b72b16e3fd8e9762fc7be10b7485d98d0986a813\"\n        \"d777fea808246d7e1a2a598717ddddc251013d68785e308e36d462139fd3a06a\"\n        \"d0c7493b1a1a9582ded7965588fd395556ea9113a8147c47edafe45a30a8b7da\"\n        \"ce0ded9e4732938001000100\"\n    )),\n    \"SLAK\": # Slack community Auth Key; generated 2018-01-19 by Jan Dumon\n\"\"\"-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7AF5tZo4gtcUG\nn//Vmk8XnDn2LadzEjZhTbs9h0X674aBqsri+EXPU+oBvpNvoyeisfX0Sckcg2xI\nD6CUQJeUD4PijT9tyhis2PRU40xEK7snEecAK25PMo12eHtFYZN8eZVeySmnlNyU\nbytlUrXEfRXXKzYq+cHVlOS2IQo2OXptWB4Ovd05C4fgi4DFblIBVjE/HzW6WJCP\nIDf53bnzxXW0ZTH2QGdnQVe0uYT5Bvjp8IU3HRSy1pLZ35u9f+kVLnLpRRhlHOmt\nxipIl1kxSGGkBkJJB76HdtcoOJC/O95Fl/qxSKzHjlg7Ku/gcUxmMZfvBi6Qih78\nkrJW0A+zAgMBAAECggEBALYZbtqj8qWBvGJuLkiIYprARGUpIhXZV2E7u6j38Lqi\nw13Dvpx1Xi2+LnMSbSpaO/+fwr3nmFMO28P0i8+ycqj4ztov5+N22L6A6rU7Popn\n93DdaxBsOpgex0jlnEz87w1YrI9H3ytUt9RHyX96ooy7rigA6VfCLPJacrm0xOf1\nOIoJeMnGTeMSQlAFR+JzU5qdHHTcWi1WFNekzBgmxIXp6zZUkep/9+mxD7V8kGT2\nMsJ/6IICe4euHA9lCpctYOPEs48yZBDljQfKD5FxVMUWBbXOhoCff99HeuW/4uVj\nAO2mFp293nnGIV0Ya5PyDtGd+w/n8kcehFcfbfTvzZkCgYEA4woDn+WBXCdAfxzP\nyUnMXEHB6189R9FTzoDwv7q3K48gH7ptJo9gq0+eycrMjlIGRiIkgyuukXD4FHvk\nkkYoQ51Xgvo6eTpADu1CffwvyTi/WBuaYqIBH/HMUvFOLZu/jmSEsusXMTDmZxb+\nWpox17h1qMtNlyIqOBLyHcmTsy8CgYEA0trrk6kwmZC2IjMLswX9uSc5t3CYuN6V\ng8OsES/68jmJxPYZTj0UidXms5P+V1LauFZelBcLaQjUSSmh1S95qYwM5ooi5bjJ\nHnVH/aaIJlKH2MBqMAkBx6EtXqzo/yqyyfEZvt8naM8OnqrKrvxUCfdVx0yf7M7v\nwECxxcgOGr0CgYBo198En781BwtJp8xsb5/nmpYqUzjBSXEiE3kZkOe1Pcrf2/87\np0pE0efJ19TOhCJRkMK7sBhVIY3uJ6hNxAgj8SzQVy1ZfgTG39msxCBtE7+IuHZ6\nxcUvM0Hfq38moJ286747wURcevBq+rtKq5oIvC3ZXMjf2e8VJeqYxtVmEQKBgAhf\n75lmz+pZiBJlqqJKq6AuAanajAZTuOaJ4AyytinmxSUQjULBRE6RM1+QkjqPrOZD\nb/A71hUu55ecUrQv9YoZaO3DMM2lAD/4coqNkbzL7F9cjRspUGvIaA/pmDuCS6Wf\nsOEW5e7QwojkybYXiZL3wu1uiq+SLI2bRDRR1NWVAoGANAp7zUGZXc1TppEAXhdx\njlzAas7J21vSgjyyY0lM3wHLwXlQLjzl3PgIAcHEyFGH1Vo0w9d1dPRSz81VSlBJ\nvzP8A7eBQVSGj/N5GXvARxUswtD0vQrJ3Ys0bDSVoiG4uLoEFihIN0y5Ln+6LZJQ\nRwjPBAdCSsU/99luMlK77z0=\n-----END PRIVATE KEY-----\"\"\",\n}\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass PlainCopyCipher:\n    def encrypt(self, plaintext):\n        return plaintext\n\n    def decrypt(self, ciphertext):\n        return ciphertext\n\n\nclass ImgPkgHeader(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n        ('magic', c_char * 4),              # 0 'IM*H'\n        ('header_version', c_uint),         # 4\n        ('size', c_uint),                   # 8\n        ('reserved', c_ubyte * 4),          # 12\n        ('header_size', c_uint),            # 16 Length of this header and following chunk headers\n        ('signature_size', c_uint),         # 20 Length of RSA signature located after chunk headers\n        ('payload_size', c_uint),           # 24 Length of the area after signature which contains data of all chunks\n        ('target_size', c_uint),            # 28\n        ('os', c_ubyte),                    # 32\n        ('arch', c_ubyte),                  # 33\n        ('compression', c_ubyte),           # 34\n        ('anti_version', c_ubyte),          # 35\n        ('auth_alg', c_uint),               # 36\n        ('auth_key', c_char * 4),           # 40 Auth key identifier\n        ('enc_key', c_char * 4),            # 44 Encryption key identifier\n        ('scram_key', c_ubyte * 16),        # 48 Encrypted Scramble key; used in versions > 0\n        ('name', c_char * 32),              # 64 Target Module name\n        ('type', c_char * 4),               # 96 Target Module type identifier; used in versions > 1\n        ('version', c_uint),                # 100\n        ('date', c_uint),                   # 104\n        ('encr_cksum', c_uint),             # 108 Checksum of encrypted data; used in versions > 1\n        ('reserved2', c_ubyte * 16),        # 112\n        ('userdata', c_char * 16),          # 128\n        ('entry', c_ubyte * 8),             # 144\n        ('plain_cksum', c_uint),            # 152 Checksum of decrypted (plaintext) data; used in versions > 1\n        ('chunk_num', c_uint),              # 156 Amount of chunks\n        ('payload_digest', c_ubyte * 32),   # 160 SHA256 of the payload\n    ]                                       # 192 is the end; chunk headers start after that\n\n    def get_format_version(self):\n        if self.magic != bytes(\"IM*H\", \"utf-8\"):\n            return 0\n        if self.header_version == 0x0000:\n            return 2016\n        elif self.header_version == 0x0001:\n            return 2017\n        elif self.header_version == 0x0002:\n            return 2018\n        else:\n            return 0\n\n    def set_format_version(self, ver):\n        if ver == 2016:\n            self.magic = bytes(\"IM*H\", \"utf-8\")\n            self.header_version = 0x0000\n        elif ver == 2017:\n            self.magic = bytes(\"IM*H\", \"utf-8\")\n            self.header_version = 0x0001\n        elif ver == 2018:\n            self.magic = bytes(\"IM*H\", \"utf-8\")\n            self.header_version = 0x0002\n        else:\n            raise ValueError(\"Unsupported image format version.\")\n\n    def update_payload_size(self, payload_size):\n        self.payload_size = payload_size\n        self.target_size = self.header_size + self.signature_size + self.payload_size\n        self.size = self.target_size\n\n    def dict_export(self):\n        d = OrderedDict()\n        for (varkey, vartype) in self._fields_:\n            if varkey.startswith('unk'):\n                continue\n            v = getattr(self, varkey)\n            if isinstance(v, Array) and v._type_ == c_ubyte:\n                d[varkey] = bytes(v)\n            else:\n                d[varkey] = v\n        varkey = 'name'\n        d[varkey] = d[varkey].decode(\"utf-8\")\n        varkey = 'auth_key'\n        d[varkey] = d[varkey].decode(\"utf-8\")\n        varkey = 'enc_key'\n        d[varkey] = d[varkey].decode(\"utf-8\")\n        varkey = 'type'\n        d[varkey] = d[varkey].decode(\"utf-8\")\n        return d\n\n    def ini_export(self, fp):\n        d = self.dict_export()\n        fp.write(\"# DJI Firmware Signer main header file.\\n\")\n        fp.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n        varkey = 'name'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'pkg_format'\n        fp.write(\"{:s}={:d}\\n\".format(varkey, self.get_format_version()))\n        varkey = 'version'\n        fp.write(\"{:s}={:02d}.{:02d}.{:02d}.{:02d}\\n\".format(varkey,\n          (d[varkey] >> 24) & 255, (d[varkey] >> 16) & 255, (d[varkey] >> 8) & 255, (d[varkey]) & 255))\n        varkey = 'anti_version'\n        fp.write(\"{:s}={:02d}.{:02d}.{:02d}.{:02d}\\n\".format(varkey,\n          (d[varkey] >> 24) & 255, (d[varkey] >> 16) & 255, (d[varkey] >> 8) & 255, (d[varkey]) & 255))\n        varkey = 'date'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, strftime(\"%Y-%m-%d\", strptime(\"{:x}\".format(d[varkey]), '%Y%m%d'))))\n        varkey = 'enc_key'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'auth_alg'\n        fp.write(\"{:s}={:d}\\n\".format(varkey, d[varkey]))\n        varkey = 'auth_key'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'os'\n        fp.write(\"{:s}={:d}\\n\".format(varkey, d[varkey]))\n        varkey = 'arch'\n        fp.write(\"{:s}={:d}\\n\".format(varkey, d[varkey]))\n        varkey = 'compression'\n        fp.write(\"{:s}={:d}\\n\".format(varkey, d[varkey]))\n        varkey = 'type'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey]))\n        varkey = 'userdata'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, d[varkey].decode(\"utf-8\"))) # not sure if string or binary\n        varkey = 'entry'\n        fp.write(\"{:s}={:s}\\n\".format(varkey, ''.join(\"{:02X}\".format(x) for x in d[varkey])))\n        #varkey = 'scram_key' # we will add the key later, as this one is encrypted\n        #fp.write(\"{:s}={:s}\\n\".format(varkey,\"\".join(\"{:02X}\".format(x) for x in d[varkey])))\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=0, width=160)\n\n\nclass ImgChunkHeader(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n        ('id', c_char * 4),          # 0\n        ('offset', c_uint),          # 4\n        ('size', c_uint),            # 8\n        ('attrib', c_uint),          # 12\n        ('address', c_ulonglong),    # 16\n        ('reserved', c_ubyte * 8),   # 24\n    ]                                # 32 is the end\n\n    def dict_export(self):\n        d = OrderedDict()\n        for (varkey, vartype) in self._fields_:\n            if varkey.startswith('unk'):\n                continue\n            v = getattr(self, varkey)\n            if isinstance(v, Array) and v._type_ == c_ubyte:\n                d[varkey] = bytes(v)\n            else:\n                d[varkey] = v\n        varkey = 'id'\n        d[varkey] = d[varkey].decode(\"utf-8\")\n        return d\n\n    def ini_export(self, fp):\n        d = self.dict_export()\n        fp.write(\"# DJI Firmware Signer chunk header file.\\n\")\n        fp.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n        varkey = 'id'\n        fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey]))\n        varkey = 'attrib'\n        fp.write(\"{:s}={:04X}\\n\".format(varkey,d[varkey]))\n        #varkey = 'offset'\n        #fp.write(\"{:s}={:04X}\\n\".format(varkey,d[varkey]))\n        varkey = 'address'\n        fp.write(\"{:s}={:08X}\\n\".format(varkey,d[varkey]))\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=0, width=160)\n\n\nclass ImgRSAPublicKey(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n        ('len', c_int),      # 0: Length of n[] in number of uint32_t\n        ('n0inv', c_uint),   # 4: -1 / n[0] mod 2^32\n        ('n', c_uint * 64),  # 8: modulus as little endian array\n        ('rr', c_uint * 64), # 264: R^2 as little endian array\n        ('exponent', c_int), # 520: 3 or 65537\n    ]\n\ndef raise_or_warn(po, ex):\n    \"\"\" Raise exception, unless force-continue parameter was used.\n    \"\"\"\n    if (po.force_continue):\n        eprint(\"{:s}: Warning: {:s} Continuing anyway.\".format(po.sigfile,str(ex)))\n    else:\n        raise ex\n\n\ndef combine_int_array(int_arr, bits_per_entry):\n    \"\"\" Makes one big numer out of an array of numbers.\n\n    Allows to make pythonic big number out of little endian number stored in parts\n    as a list.\n    \"\"\"\n    ans = 0\n    for i, val in enumerate(int_arr):\n        ans += (val << i*bits_per_entry)\n    return ans\n\n\ndef get_key_data(po, pkghead, enc_k_fourcc):\n    \"\"\" Returns encryption/authentication key array for given FourCC.\n\n    Accepts both string and variants of bytes.\n    \"\"\"\n    if hasattr(enc_k_fourcc, 'decode'):\n        enc_k_str = enc_k_fourcc.decode(\"utf-8\")\n    else:\n        enc_k_str = str(enc_k_fourcc)\n    enc_k_select = None\n\n    for kstr in po.key_select:\n        if enc_k_str == kstr[:4]:\n            enc_k_select = kstr\n            break\n\n    key_list = []\n    if enc_k_select is None:\n        if enc_k_str in keys:\n            enc_k_select = enc_k_str\n        else:\n            for kstr in keys:\n                if enc_k_str == kstr[:4]:\n                    key_list.append(kstr)\n\n    if enc_k_select is not None:\n        # Key selection was already made\n        pass\n    elif len(key_list) == 1:\n        # There is only one key to choose from\n        enc_k_select = key_list[0]\n    elif len(key_list) > 1:\n        # We have multiple matching keys; we do not have enough information to auto-choose correct one\n        # (the key needs to be selected based of FW package version, we only have FW module version)\n        enc_k_select = key_list[0]\n        if (po.show_multiple_keys_warn):\n            eprint(\"{}: Warning: '{:s}' matches multiple keys; using first, '{:s}'\"\n              .format(po.sigfile, enc_k_str, enc_k_select))\n            eprint(\"{}: Key choices: {:s}\".format(po.sigfile,\", \".join(key_list)))\n            po.show_multiple_keys_warn = False\n\n    if enc_k_select in keys.keys():\n        enc_key = keys[enc_k_select]\n    else:\n        enc_key = None\n    return enc_key\n\n\ndef imah_get_crypto_params(po, pkghead):\n    # Get the encryption key\n    enc_k_str = pkghead.enc_key.decode(\"utf-8\")\n    if enc_k_str != '':\n        enc_key = get_key_data(po, pkghead, enc_k_str)\n    else:\n        enc_key = bytes()\n    if enc_key is None:\n        eprint(\"{}: Warning: Cannot find enc_key '{:s}'\".format(po.sigfile,enc_k_str))\n        return (None, None, None)\n    # Prepare initial values for AES\n    if len(enc_key) == 0:\n        crypt_mode = AES.MODE_CBC\n        crypt_key = enc_key\n        crypt_iv = bytes(pkghead.scram_key)\n    elif pkghead.header_version == 2:\n        if (po.verbose > 3):\n            print(\"Key encryption key:\\n{:s}\".format(' '.join(\"{:02X}\".format(x) for x in enc_key)))\n        crypt_mode = AES.MODE_CTR\n        cipher = AES.new(enc_key, AES.MODE_ECB)\n        if (po.verbose > 3):\n            print(\"Encrypted Scramble key:\\n{:s}\".format(' '.join(\"{:02X}\".format(x) for x in pkghead.scram_key)))\n        crypt_key = cipher.decrypt(bytes(pkghead.scram_key))\n        # For CTR mode, 12 bytes of crypt_iv will be interpreted as nonce, and remaining 4 will be initial value of counter\n        crypt_iv = bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    elif pkghead.header_version == 1:\n        if (po.verbose > 3):\n            print(\"Key encryption key:\\n{:s}\".format(' '.join(\"{:02X}\".format(x) for x in enc_key)))\n        crypt_mode = AES.MODE_CBC\n        cipher = AES.new(enc_key, AES.MODE_CBC, bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))\n        if (po.verbose > 3):\n            print(\"Encrypted Scramble key:\\n{:s}\".format(' '.join(\"{:02X}\".format(x) for x in pkghead.scram_key)))\n        crypt_key = cipher.decrypt(bytes(pkghead.scram_key))\n        crypt_iv = bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    else:\n        crypt_mode = AES.MODE_CBC\n        crypt_key = enc_key\n        crypt_iv = bytes(pkghead.scram_key)\n    return (crypt_key, crypt_mode, crypt_iv)\n\n\ndef imah_get_auth_params(po, pkghead):\n    # Get the key\n    auth_k_str = pkghead.auth_key.decode(\"utf-8\")\n    auth_key_data = get_key_data(po, pkghead, auth_k_str)\n    if auth_key_data is None:\n        eprint(\"{}: Warning: Cannot find auth_key '{:s}'\".format(po.sigfile,auth_k_str))\n        return (None)\n    if isinstance(auth_key_data, str):\n        auth_key = RSA.importKey(auth_key_data)\n    elif len(auth_key_data) == sizeof(ImgRSAPublicKey):\n        auth_key_struct = ImgRSAPublicKey()\n        memmove(addressof(auth_key_struct), auth_key_data, sizeof(auth_key_struct))\n        auth_key_n = combine_int_array(auth_key_struct.n, 32)\n        auth_key = RSA.construct( (auth_key_n, auth_key_struct.exponent, ) )\n    else:\n        eprint(\"{}: Warning: Unrecognized format of auth_key '{:s}'\".format(po.sigfile,auth_k_str))\n        return (None)\n    return (auth_key)\n\n\ndef imah_compute_checksum(po, buf, start = 0):\n    cksum = start\n    for i in range(0, len(buf) // 4):\n        v = int.from_bytes(buf[i*4:i*4+4], byteorder='little')\n        cksum += v\n    # last dword\n    i = len(buf) // 4\n    if i*4 < len(buf):\n        last_buf = buf[i*4:i*4+4] + bytes(3 * [0])\n        v = int.from_bytes(last_buf[:4], byteorder='little')\n        cksum += v\n    return (cksum) & ((2 ** 32) - 1)\n\n\ndef imah_write_fwsig_head(po, pkghead, minames):\n    fname = \"{:s}_head.ini\".format(po.mdprefix)\n    fwheadfile = open(fname, \"w\")\n    pkghead.ini_export(fwheadfile)\n    # Prepare initial values for AES\n    if pkghead.header_version == 0: # Scramble key is used as initial vector\n        fwheadfile.write(\"{:s}={:s}\\n\".format('scramble_iv',' '.join(\"{:02X}\".format(x) for x in pkghead.scram_key)))\n    else:\n        crypt_key, _, _ = imah_get_crypto_params(po, pkghead)\n        if crypt_key is None: # Scramble key is used, but we cannot decrypt it\n            eprint(\"{}: Warning: Storing encrypted scramble key due to missing crypto config.\".format(po.sigfile))\n            fwheadfile.write(\"{:s}={:s}\\n\".format('scramble_key_encrypted',' '.join(\"{:02X}\".format(x) for x in pkghead.scram_key)))\n        else: # Store the decrypted scrable key\n            fwheadfile.write(\"{:s}={:s}\\n\".format('scramble_key',' '.join(\"{:02X}\".format(x) for x in crypt_key)))\n    # Store list of modules/chunks to include\n    fwheadfile.write(\"{:s}={:s}\\n\".format('modules',' '.join(minames)))\n    fwheadfile.close()\n\n\ndef imah_read_fwsig_head(po):\n    pkghead = ImgPkgHeader()\n    fname = \"{:s}_head.ini\".format(po.mdprefix)\n    parser = configparser.ConfigParser()\n\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n    # Set magic fields properly\n    pkgformat = int(parser.get(\"asection\", \"pkg_format\"))\n    pkghead.set_format_version(pkgformat)\n    # Set the rest of the fields\n    pkghead.name = bytes(parser.get(\"asection\", \"name\"), \"utf-8\")\n    pkghead.userdata = bytes(parser.get(\"asection\", \"userdata\"), \"utf-8\")\n    # The only person at Dji who knew how to store dates must have been fired\n    date_val = strptime(parser.get(\"asection\", \"date\"),\"%Y-%m-%d\")\n    pkghead.date = (\n        ((date_val.tm_year // 1000) << 28) |\n        (((date_val.tm_year % 1000) // 100) << 24) |\n        (((date_val.tm_year % 100) // 10) << 20) |\n        ((date_val.tm_year % 10) << 16) |\n        ((date_val.tm_mon // 10) << 12) |\n        ((date_val.tm_mon % 10) << 8) |\n        ((date_val.tm_mday // 10) << 4) |\n        (date_val.tm_mday % 10)\n    )\n    version_s = parser.get(\"asection\", \"version\")\n    version_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)[.](?P<build>[0-9]+)[.](?P<rev>[0-9]+)', version_s)\n    pkghead.version = (\n        ((int(version_m.group(\"major\"), 10) & 0xff) << 24) +\n        ((int(version_m.group(\"minor\"), 10) & 0xff) << 16) +\n        ((int(version_m.group(\"build\"), 10) & 0xff) << 8) +\n        ((int(version_m.group(\"rev\"), 10) & 0xff))\n    )\n    anti_version_s = parser.get(\"asection\", \"anti_version\")\n    anti_version_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)[.](?P<build>[0-9]+)[.](?P<rev>[0-9]+)', anti_version_s)\n    pkghead.anti_version = (\n        ((int(anti_version_m.group(\"major\"), 10) & 0xff) << 24) +\n        ((int(anti_version_m.group(\"minor\"), 10) & 0xff) << 16) +\n        ((int(anti_version_m.group(\"build\"), 10) & 0xff) << 8) +\n        ((int(anti_version_m.group(\"rev\"), 10) & 0xff))\n    )\n    pkghead.enc_key = bytes(parser.get(\"asection\", \"enc_key\"), \"utf-8\")\n    pkghead.auth_key = bytes(parser.get(\"asection\", \"auth_key\"), \"utf-8\")\n    pkghead.auth_alg = int(parser.get(\"asection\", \"auth_alg\"))\n    pkghead.os = int(parser.get(\"asection\", \"os\"))\n    pkghead.arch = int(parser.get(\"asection\", \"arch\"))\n    pkghead.compression = int(parser.get(\"asection\", \"compression\"))\n    pkghead.type = bytes(parser.get(\"asection\", \"type\"), \"utf-8\")\n    entry_bt = bytes.fromhex(parser.get(\"asection\", \"entry\"))\n    pkghead.entry = (c_ubyte * len(entry_bt)).from_buffer_copy(entry_bt)\n\n    if po.random_scramble:\n        scramble_needs_encrypt = (pkghead.header_version != 0)\n        scramble_key = os.urandom(16)\n        pkghead.scram_key = (c_ubyte * len(scramble_key)).from_buffer_copy(scramble_key)\n\n    elif pkghead.header_version == 0: # Scramble key is used as initial vector\n        scramble_needs_encrypt = False\n        scramble_iv = bytes.fromhex(parser.get(\"asection\", \"scramble_iv\"))\n        pkghead.scram_key = (c_ubyte * len(scramble_iv)).from_buffer_copy(scramble_iv)\n\n    else: # Scrable key should be encrypted\n        if parser.has_option(\"asection\", \"scramble_key\"):\n            scramble_needs_encrypt = True\n            scramble_key = bytes.fromhex(parser.get(\"asection\", \"scramble_key\"))\n        else: # Maybe we have pre-encrypted version?\n            scramble_needs_encrypt = False\n            scramble_key = bytes.fromhex(parser.get(\"asection\", \"scramble_key_encrypted\"))\n\n        if scramble_key is not None:\n            if len(scramble_key) > 0:\n                pkghead.scram_key = (c_ubyte * len(scramble_key)).from_buffer_copy(scramble_key)\n        else:\n            eprint(\"{}: Warning: Scramble key not found in header and not set to ramdom; zeros will be used.\"\n              .format(po.sigfile))\n\n    minames_s = parser.get(\"asection\", \"modules\")\n    minames = minames_s.split(' ')\n    pkghead.chunk_num = len(minames)\n    pkghead.header_size = sizeof(pkghead) + sizeof(ImgChunkHeader)*pkghead.chunk_num\n    pkghead.signature_size = 256\n    pkghead.update_payload_size(0)\n\n    del parser\n\n    if scramble_needs_encrypt:\n        # Get the encryption key\n        enc_k_str = pkghead.enc_key.decode(\"utf-8\")\n        enc_key = get_key_data(po, pkghead, enc_k_str)\n        if enc_key is None:\n            eprint(\"{}: Warning: Cannot find enc_key '{:s}'; scramble key left unencrypted.\"\n              .format(po.sigfile,enc_k_str))\n        else:\n            cipher = AES.new(enc_key, AES.MODE_CBC, bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))\n            crypt_key_enc = cipher.encrypt(bytes(pkghead.scram_key))\n            pkghead.scram_key = (c_ubyte * 16)(*list(crypt_key_enc))\n\n    return (pkghead, minames, pkgformat)\n\n\ndef imah_write_fwentry_head(po, i, e, miname, can_decrypt):\n    fname = \"{:s}_{:s}.ini\".format(po.mdprefix,miname)\n    fwheadfile = open(fname, \"w\")\n    e.ini_export(fwheadfile)\n    if not can_decrypt: # If we're exporting without decryption, we must retain decrypted size\n        fwheadfile.write(\"{:s}={:s}\\n\".format('size',\"{:d}\".format(e.size)))\n    fwheadfile.close()\n\n\ndef imah_read_fwentry_head(po, i, miname):\n    chunk = ImgChunkHeader()\n    fname = \"{:s}_{:s}.ini\".format(po.mdprefix,miname)\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n    id_s = parser.get(\"asection\", 'id')\n    chunk.id = bytes(id_s, \"utf-8\")\n    attrib_s = parser.get(\"asection\", 'attrib')\n    chunk.attrib = int(attrib_s, 16)\n    size_s = parser.get(\"asection\", 'size',fallback=\"0\")\n    chunk.size = int(size_s,0)\n    #offset_s = parser.get(\"asection\", 'offset')\n    #chunk.offset = int(offset_s, 16)\n    address_s = parser.get(\"asection\", 'address')\n    chunk.address = int(address_s, 16)\n    del parser\n    return (chunk)\n\n\ndef imah_unsign(po, fwsigfile):\n\n    # Decode the image header\n    pkghead = ImgPkgHeader()\n    if fwsigfile.readinto(pkghead) != sizeof(pkghead):\n        raise EOFError(\"Could not read signed image file header.\")\n\n    # Check the magic\n    pkgformat = pkghead.get_format_version()\n    if pkgformat == 0:\n        raise_or_warn(po, ValueError(\"Unexpected magic value in main header; input file is not a signed image.\"))\n\n    if pkghead.size != pkghead.target_size:\n        eprint(\"{}: Warning: Header field 'size' is different that 'target_size'; the tool is not designed to handle this.\"\n          .format(fwsigfile.name))\n\n    if not all(v == 0 for v in pkghead.reserved):\n        eprint(\"{}: Warning: Header field 'reserved' is non-zero; the tool is not designed to handle this.\"\n          .format(fwsigfile.name))\n\n    if not all(v == 0 for v in pkghead.reserved2):\n        eprint(\"{}: Warning: Header field 'reserved2' is non-zero; the tool is not designed to handle this.\"\n          .format(fwsigfile.name))\n\n    if pkgformat < 2018:\n        if pkghead.encr_cksum != 0:\n            eprint(\"{}: Warning: Header field 'encr_cksum' is non-zero; this is only allowed in newer formats.\"\n              .format(fwsigfile.name))\n\n        if pkghead.plain_cksum != 0:\n            eprint(\"{}: Warning: Header field 'plain_cksum' is non-zero; this is only allowed in newer formats.\"\n              .format(fwsigfile.name))\n\n    if (po.verbose > 0):\n        print(\"{}: Unpacking image...\".format(fwsigfile.name))\n    if (po.verbose > 1):\n        print(pkghead)\n\n    # Read chunk headers of the image\n    chunks = []\n    for i in range(0, pkghead.chunk_num):\n        chunk = ImgChunkHeader()\n        if fwsigfile.readinto(chunk) != sizeof(chunk):\n            raise EOFError(\"Could not read signed image chunk {:d} header.\".format(i))\n        chunks.append(chunk)\n\n    # Compute header hash and checksum; for checksum, we need a header without checksum stored\n    pkghead_nosum = copy(pkghead)\n    pkghead_nosum.encr_cksum = 0\n    checksum_enc = imah_compute_checksum(po, bytes(pkghead_nosum))\n    header_digest = SHA256.new()\n    header_digest.update(bytes(pkghead))\n    for i, chunk in enumerate(chunks):\n        header_digest.update(bytes(chunk))\n        checksum_enc = imah_compute_checksum(po, bytes(chunk), checksum_enc)\n    if (po.verbose > 2):\n        print(\"Computed header checksum 0x{:08X} and digest:\\n{:s}\"\n          .format(checksum_enc, ' '.join(\"{:02X}\".format(x) for x in header_digest.digest())))\n\n    if pkghead.signature_size != 256: # 2048 bit key length\n        raise_or_warn(po, ValueError(\"Signed image file head signature has unexpected size.\"))\n    head_signature = fwsigfile.read(pkghead.signature_size)\n    if len(head_signature) != pkghead.signature_size:\n        raise EOFError(\"Could not read signature of signed image file head.\")\n\n    auth_key = imah_get_auth_params(po, pkghead)\n    try:\n        if pkgformat >= 2018:\n            mgf = lambda x, y: pss.MGF1(x, y, SHA256)\n            salt_bytes = header_digest.digest_size\n            header_signer = pss.new(auth_key, mask_func=mgf, salt_bytes=salt_bytes)\n            # The PSS signer does not return value, just throws exception of a fail\n            header_signer.verify(header_digest, head_signature)\n            signature_match = True\n        else:\n            header_signer = PKCS1_v1_5.new(auth_key)\n            signature_match = header_signer.verify(header_digest, head_signature)\n    except Exception as ex:\n        print(\"{}: Warning: Image file head signature verification caused cryptographic exception: {}\"\n          .format(fwsigfile.name, str(ex)))\n        signature_match = False\n    if signature_match:\n        if (po.verbose > 1):\n            print(\"{}: Image file head signature verification passed.\".format(fwsigfile.name))\n    else:\n        raise_or_warn(po, ValueError(\"Image file head signature verification failed.\"))\n\n    # Finish computing encrypted data checksum; cannot do that during decryption as we would\n    # likely miss some padding, which is also included in the checksum\n    remain_enc_n = pkghead.payload_size\n    while remain_enc_n > 0:\n        copy_buffer = fwsigfile.read(min(1024 * 1024, remain_enc_n))\n        checksum_enc = imah_compute_checksum(po, copy_buffer, checksum_enc)\n        remain_enc_n -= 1024 * 1024\n    checksum_enc = (2 ** 32) - checksum_enc\n\n    if pkgformat < 2018:\n        pass # No checksums are used in these formats\n    elif pkghead.encr_cksum == checksum_enc:\n        if (po.verbose > 1):\n            print(\"{}: Encrypted data checksum 0x{:08X} matches.\".format(fwsigfile.name, checksum_enc))\n    else:\n        if (po.verbose > 1):\n            print(\"{}: Encrypted data checksum 0x{:08X}, expected 0x{:08X}.\"\n              .format(fwsigfile.name, checksum_enc, pkghead.encr_cksum))\n        raise_or_warn(po, ValueError(\"Encrypted data checksum verification failed.\"))\n\n    # Prepare array of names; \"0\" will mean empty index\n    minames = [\"0\"]*len(chunks)\n    # Name the modules after target component\n    for i, chunk in enumerate(chunks):\n        if chunk.size > 0:\n            d = chunk.dict_export()\n            minames[i] = \"{:s}\".format(d['id'])\n    # Rename targets in case of duplicates\n    minames_seen = set()\n    for i in range(len(minames)):\n        miname = minames[i]\n        if miname in minames_seen:\n            # Add suffix a..z to multiple uses of the same module\n            for miname_suffix in range(97,110):\n                if miname+chr(miname_suffix) not in minames_seen:\n                    break\n            # Show warning the first time duplicate is found\n            if (miname_suffix == 97):\n                eprint(\"{}: Warning: Found multiple chunks '{:s}'; invalid signed image.\"\n                  .format(fwsigfile.name, miname))\n            minames[i] = miname+chr(miname_suffix)\n        minames_seen.add(minames[i])\n    minames_seen = None\n\n    imah_write_fwsig_head(po, pkghead, minames)\n\n    crypt_key, crypt_mode, crypt_iv = imah_get_crypto_params(po, pkghead)\n    if (crypt_key is not None) and (po.verbose > 2):\n        print(\"Scramble key:\\n{:s}\".format(' '.join(\"{:02X}\".format(x) for x in crypt_key)))\n\n    # Output the chunks\n    checksum_dec = 0\n    num_skipped = 0\n    single_cipher = None # IMaH v1 creates a new cipher for each chunk, IMaH v2 reuses a single cipher\n    for i, chunk in enumerate(chunks):\n\n        chunk_fname = \"{:s}_{:s}.bin\".format(po.mdprefix, minames[i])\n\n        if (chunk.attrib & 0x01) or (pkghead.enc_key == b''): # Not encrypted chunk\n            cipher = PlainCopyCipher()\n            pad_cnt = 0\n            if (po.verbose > 0):\n                print(\"{}: Unpacking plaintext chunk '{:s}'...\".format(fwsigfile.name, minames[i]))\n            can_decrypt = True\n\n        elif crypt_key is not None: # Encrypted chunk (have key as well)\n            if crypt_mode == AES.MODE_CTR:\n                if single_cipher is None:\n                    init_cf = int.from_bytes(crypt_iv[12:16], byteorder='big')\n                    countf = Counter.new(32, crypt_iv[:12], initial_value=init_cf)\n                    cipher = AES.new(crypt_key, crypt_mode, counter=countf)\n                    single_cipher = cipher\n                else:\n                    cipher = single_cipher\n                dji_block_size = 32\n            else:\n                cipher = AES.new(crypt_key, crypt_mode, iv=crypt_iv)\n                # the data is really padded to 32, but we do not care as we reset state for every chunk\n                dji_block_size = AES.block_size\n            pad_cnt = (dji_block_size - chunk.size % dji_block_size) % dji_block_size\n            if (po.verbose > 0):\n                print(\"{}: Unpacking encrypted chunk '{:s}'...\".format(fwsigfile.name, minames[i]))\n            can_decrypt = True\n\n        else: # Missing encryption key\n            eprint(\"{}: Warning: Cannot decrypt chunk '{:s}'; crypto config missing.\"\n              .format(fwsigfile.name, minames[i]))\n            if (not po.force_continue):\n                num_skipped += 1\n                continue\n            if (po.verbose > 0):\n                print(\"{}: Copying still encrypted chunk '{:s}'...\".format(fwsigfile.name, minames[i]))\n            cipher = PlainCopyCipher()\n            pad_cnt = (AES.block_size - chunk.size % AES.block_size) % AES.block_size\n            can_decrypt = False\n\n        imah_write_fwentry_head(po, i, chunk, minames[i], can_decrypt)\n\n        if (po.verbose > 1):\n            print(str(chunk))\n\n        # Decrypt and write the data\n        fwsigfile.seek(pkghead.header_size + pkghead.signature_size + chunk.offset, 0)\n        fwitmfile = open(chunk_fname, \"wb\")\n        remain_enc_n = chunk.size + pad_cnt\n        remain_dec_n = chunk.size\n        if not can_decrypt: # If storing encrypted, include padding\n            remain_dec_n += pad_cnt\n        while remain_enc_n > 0:\n            # read block limit must be a multiplication of encryption block size\n            # ie AES.block_size is fixed at 16 bytes\n            copy_buffer = fwsigfile.read(min(1024 * 1024, remain_enc_n))\n            if not copy_buffer:\n                eprint(\"{}: Warning: Chunk '{:s}' truncated.\".format(fwsigfile.name, minames[i]))\n                num_skipped += 1\n                break\n            remain_enc_n -= len(copy_buffer)\n            copy_buffer = cipher.decrypt(copy_buffer)\n            checksum_dec = imah_compute_checksum(po, copy_buffer, checksum_dec)\n            if remain_dec_n >= len(copy_buffer):\n                fwitmfile.write(copy_buffer)\n                remain_dec_n -= len(copy_buffer)\n            else:\n                if (po.verbose > 2):\n                    print(\"Chunk padding: {:s}\".format(str(copy_buffer[-len(copy_buffer)+remain_dec_n:])))\n                fwitmfile.write(copy_buffer[:remain_dec_n])\n                remain_dec_n = 0\n        fwitmfile.close()\n\n    print(\"{}: Un-signed {:d} chunks, skipped/truncated {:d} chunks.\"\n      .format(fwsigfile.name,len(chunks)-num_skipped, num_skipped))\n    if pkgformat < 2018:\n        pass  # No checksums are used in these formats\n    elif pkghead.plain_cksum == checksum_dec:\n        if (po.verbose > 1):\n            print(\"{}: Decrypted chunks checksum 0x{:08X} matches.\".format(fwsigfile.name, checksum_dec))\n    else:\n        if (po.verbose > 1):\n            print(\"{}: Decrypted chunks checksum 0x{:08X}, expected 0x{:08X}.\"\n              .format(fwsigfile.name, checksum_dec, pkghead.plain_cksum))\n        raise_or_warn(po, ValueError(\"Decrypted chunks checksum verification failed.\"))\n    if num_skipped > 0:\n        raise_or_warn(po, ValueError(\"Some chunks were not extracted correctly.\"))\n\n\ndef imah_sign(po, fwsigfile):\n    # Read headers from INI files\n    (pkghead, minames, pkgformat) = imah_read_fwsig_head(po)\n    chunks = []\n    # Create header entry for each chunk\n    for i, miname in enumerate(minames):\n        if miname == \"0\":\n            chunk = ImgChunkHeader()\n        else:\n            chunk = imah_read_fwentry_head(po, i, miname)\n        chunks.append(chunk)\n    # Write the unfinished headers\n    fwsigfile.write(bytes(pkghead))\n    for chunk in chunks:\n        fwsigfile.write(bytes(chunk))\n    fwsigfile.write(b\"\\0\" * pkghead.signature_size)\n    # prepare encryption\n    crypt_key, crypt_mode, crypt_iv = imah_get_crypto_params(po, pkghead)\n    # Write module data\n    checksum_dec = 0\n    single_cipher = None  # IMaH v1 creates a new cipher for each chunk, IMaH v2 reuses a single cipher\n    payload_digest = SHA256.new()\n    for i, miname in enumerate(minames):\n        chunk = chunks[i]\n        chunk.offset = fwsigfile.tell() - pkghead.header_size - pkghead.signature_size\n        if miname == \"0\":\n            if (po.verbose > 0):\n                print(\"{}: Empty chunk index {:d}\".format(fwsigfile.name, i))\n            continue\n\n        if (chunk.attrib & 0x01) or (pkghead.enc_key == b''): # Not encrypted chunk\n            cipher = PlainCopyCipher()\n            if (po.verbose > 0):\n                print(\"{}: Packing plaintext chunk '{:s}'...\".format(fwsigfile.name, minames[i]))\n            can_decrypt = True\n\n        elif crypt_key is not None: # Encrypted chunk (have key as well)\n            if crypt_mode == AES.MODE_CTR:\n                if single_cipher is None:\n                    init_cf = int.from_bytes(crypt_iv[12:16], byteorder='big')\n                    countf = Counter.new(32, crypt_iv[:12], initial_value=init_cf)\n                    cipher = AES.new(crypt_key, crypt_mode, counter=countf)\n                    single_cipher = cipher\n                else:\n                    cipher = single_cipher\n            else:\n                cipher = AES.new(crypt_key, crypt_mode, iv=crypt_iv)\n            if (po.verbose > 0):\n                print(\"{}: Packing and encrypting chunk '{:s}'...\".format(fwsigfile.name, minames[i]))\n            can_decrypt = True\n\n        else: # Missing encryption key\n            eprint(\"{}: Warning: Cannot encrypt chunk '{:s}'; crypto config missing.\"\n              .format(fwsigfile.name, minames[i]))\n            raise_or_warn(po, ValueError(\"Unsupported encryption configuration.\"))\n            if (po.verbose > 0):\n                print(\"{}: Copying already encrypted chunk '{:s}'...\".format(fwsigfile.name, minames[i]))\n            cipher = PlainCopyCipher()\n            can_decrypt = False\n\n        if (po.verbose > 1):\n            print(str(chunk))\n\n        chunk_fname = \"{:s}_{:s}.bin\".format(po.mdprefix, miname)\n        # Copy chunk data and compute digest\n        fwitmfile = open(chunk_fname, \"rb\")\n        # Chunks in new formats are padded with zeros and then encrypted; for older formats,\n        # the padding rules are more convoluted, and also change slightly between platforms\n        if pkgformat >= 2018:\n            dji_block_size = 32\n        else:\n            dji_block_size = AES.block_size\n        decrypted_n = 0\n        while True:\n            # read block limit must be a multiplication of encryption block size\n            # ie AES.block_size is fixed at 16 bytes\n            copy_buffer = fwitmfile.read(1024 * 1024)\n            if not copy_buffer:\n                break\n            decrypted_n += len(copy_buffer)\n            # Pad the payload to AES.block_size = 16\n            if (len(copy_buffer) % dji_block_size) != 0:\n                pad_cnt = dji_block_size - (len(copy_buffer) % dji_block_size)\n                pad_buffer = b\"\\0\" * pad_cnt\n                copy_buffer += pad_buffer\n            checksum_dec = imah_compute_checksum(po, copy_buffer, checksum_dec)\n            copy_buffer = cipher.encrypt(copy_buffer)\n            payload_digest.update(copy_buffer)\n            fwsigfile.write(copy_buffer)\n        fwitmfile.close()\n        # Pad with zeros at end, for no real reason\n        dji_block_size = 32\n        if (fwsigfile.tell() - chunk.offset) % dji_block_size != 0:\n            pad_cnt = dji_block_size - ((fwsigfile.tell() - chunk.offset) % dji_block_size)\n            pad_buffer = b\"\\0\" * pad_cnt\n            payload_digest.update(pad_buffer) # why Dji includes padding in digest?\n            fwsigfile.write(pad_buffer)\n        # Update size of the chunk in header; skip that if the chunk was pre-encrypted and correct size was stored in INI\n        if can_decrypt or chunk.size == 0:\n            chunk.size = decrypted_n\n        elif (decrypted_n <= chunk.size) or (decrypted_n >= chunk.size + dji_block_size):\n            eprint(\"{}: Warning: Chunk '{:s}' size from INI is incorrect, ignoring\".format(fwsigfile.name,minames[i]))\n            chunk.size = decrypted_n\n        chunks[i] = chunk\n\n    pkghead.update_payload_size(fwsigfile.tell() - pkghead.header_size - pkghead.signature_size)\n    if pkgformat >= 2018:\n        pkghead.plain_cksum = checksum_dec\n        if (po.verbose > 1):\n            print(\"{}: Decrypted chunks checksum 0x{:08X} stored\".format(fwsigfile.name, checksum_dec))\n    pkghead.payload_digest = (c_ubyte * 32)(*list(payload_digest.digest()))\n    if (po.verbose > 2):\n        print(\"{}: Computed payload digest:\\n{:s}\".format(fwsigfile.name,\n          ' '.join(\"{:02X}\".format(x) for x in pkghead.payload_digest)))\n\n    # Compute encrypted data checksum; cannot do that during encryption as we\n    # need header with all fields filled, except of the checksum ofc.\n    checksum_enc = imah_compute_checksum(po, bytes(pkghead))\n    for i, chunk in enumerate(chunks):\n        checksum_enc = imah_compute_checksum(po, bytes(chunk), checksum_enc)\n    if (po.verbose > 2):\n        print(\"{}: Computed header checksum 0x{:08X}\".format(fwsigfile.name, checksum_enc))\n\n    if pkgformat >= 2018:\n        fwsigfile.seek(pkghead.header_size + pkghead.signature_size, os.SEEK_SET)\n        remain_enc_n = pkghead.payload_size\n        while remain_enc_n > 0:\n            copy_buffer = fwsigfile.read(min(1024 * 1024, remain_enc_n))\n            checksum_enc = imah_compute_checksum(po, copy_buffer, checksum_enc)\n            remain_enc_n -= 1024 * 1024\n        checksum_enc = (2 ** 32) - checksum_enc\n        pkghead.encr_cksum = checksum_enc\n        if (po.verbose > 1):\n            print(\"{}: Encrypted data checksum 0x{:08X} stored\".format(fwsigfile.name, checksum_enc))\n\n    # Write all headers again\n    fwsigfile.seek(0, os.SEEK_SET)\n    fwsigfile.write(bytes(pkghead))\n    if (po.verbose > 1):\n        print(str(pkghead))\n    for chunk in chunks:\n        fwsigfile.write(bytes(chunk))\n        if (po.verbose > 1):\n            print(str(chunk))\n\n    # Compute header hash, and use it to sign the header\n    header_digest = SHA256.new()\n    header_digest.update(bytes(pkghead))\n    for i, chunk in enumerate(chunks):\n        header_digest.update(bytes(chunk))\n    if (po.verbose > 2):\n        print(\"{}: Computed header digest:\\n{:s}\".format(fwsigfile.name,\n          ' '.join(\"{:02X}\".format(x) for x in header_digest.digest())))\n\n    auth_key = imah_get_auth_params(po, pkghead)\n    if not hasattr(auth_key, 'd'):\n        raise ValueError(\"Cannot compute image file head signature, auth key '{:s}' has no private part.\"\n          .format(pkghead.auth_key.decode(\"utf-8\")))\n\n    if pkgformat >= 2018:\n        mgf = lambda x, y: pss.MGF1(x, y, SHA256)\n        salt_bytes = header_digest.digest_size\n        header_signer = pss.new(auth_key, mask_func=mgf, salt_bytes=salt_bytes)\n    else:\n        header_signer = PKCS1_v1_5.new(auth_key)\n    head_signature = header_signer.sign(header_digest)\n    fwsigfile.write(head_signature)\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-i', '--sigfile', default=\"\", type=str,\n          help=(\"directory and file name of signed and encrypted IM*H firmware module \"\n            \"(default is base name of mdprefix with extension sig appended, in working dir)\"))\n\n    parser.add_argument('-m', '--mdprefix', default=\"\", type=str,\n          help=(\"directory and file name prefix for the single un-signed and unencrypted firmware module \"\n            \"(default is base name of sigfile with extension stripped, in working dir)\"))\n\n    parser.add_argument('-f', '--force-continue', action='store_true',\n          help=\"force continuing execution despite warning signs of issues\")\n\n    parser.add_argument('-r', '--random-scramble', action='store_true',\n          help=\"while signing, use random scramble vector instead of from INI\")\n\n    parser.add_argument('-k', '--key-select', default=[], action='append',\n          help=(\"select a specific key to be used for given four character code, \"\n            \"if multiple keys match this fourcc\"))\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('-u', '--unsign', action='store_true',\n          help=\"un-sign and decrypt the firmware module\")\n\n    subparser.add_argument('-s', '--sign', action='store_true',\n          help=\"sign and encrypt the firmware module\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    if len(po.sigfile) > 0 and len(po.mdprefix) == 0:\n        po.mdprefix = os.path.splitext(os.path.basename(po.sigfile))[0]\n    elif len(po.mdprefix) > 0 and len(po.sigfile) == 0:\n        po.sigfile = po.mdprefix + \".sig\"\n    po.show_multiple_keys_warn = True\n\n    if po.unsign:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extraction and un-signing\".format(po.sigfile))\n        with open(po.sigfile, 'rb') as fwsigfile:\n            imah_unsign(po, fwsigfile)\n\n    elif po.sign:\n        if (po.verbose > 0):\n            print(\"{}: Opening for creation and signing\".format(po.sigfile))\n        with open(po.sigfile, 'w+b') as fwsigfile:\n            imah_sign(po, fwsigfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dji_mvfc_fwpak.py",
          "type": "blob",
          "size": 14.09375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DJI Mavic Flight Controller Firmware Crypto tool.\n\nHandles the second level encryption used for Flight Controller modules\nin Mavic and newer drones.\n\"\"\"\n\n# Copyright (C) 2018  Jan Dumon <jan@crossbar.net>\n# Copyright (C) 2018  Freek van Tienen <freek.v.tienen@gmail.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.5.2\"\n__author__ = \"Jan Dumon, Freek van Tienen @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport re\nimport os\nimport hashlib\nimport binascii\nimport time\nimport argparse\nfrom Crypto.Cipher import AES\nfrom ctypes import c_char, c_int, c_ubyte, c_ushort, c_uint, c_ulonglong, c_float\nfrom ctypes import memmove, addressof, sizeof, Array, LittleEndianStructure\nfrom os.path import basename\n\nencrypt_key = bytes([0x96, 0x70, 0x9a, 0xD3, 0x26, 0x67, 0x4A, 0xC3, 0x82, 0xB6, 0x69, 0x27, 0xE6, 0xd8, 0x84, 0x21])\nencrypt_iv = bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\ndef eprint(*args, **kwargs):\n  print(*args, file=sys.stderr, **kwargs)\n\nclass EncHeader(LittleEndianStructure):\n    _pack_ = 1\n    _fields_ = [\n        ('target', c_ubyte),           # 0\n        ('unk0', c_uint),              # 1  Always 0x01000001\n        ('version', c_ubyte * 4),      # 5\n        ('unk1', c_ubyte),             # 9  Always 0x01\n        ('size', c_uint),              # 10\n        ('unk2', c_uint),              # 14 Always 0x00000000\n        ('time', c_uint),              # 18\n        ('unk3', c_ubyte),             # 22 Always 0x04\n        ('md5', c_ubyte * 16),         # 23\n        ('crc16', c_ushort),           # 39 end is 41\n    ]\n\n    def __init__(self):\n        self.unk0 = 0x01000001\n        self.unk1 = 0x01\n        self.unk2 = 0x00000000\n        self.unk3 = 0x04\n\n    def dict_export(self):\n        d = dict()\n        for (varkey, vartype) in self._fields_:\n            #if not varkey.startswith('unk'):\n            d[varkey] = getattr(self, varkey)\n        return d\n\n    def __repr__(self):\n        d = self.dict_export()\n        from pprint import pformat\n        return pformat(d, indent=4, width=1)\n\n    def getTarget(self):\n        tg_kind = self.target & 31\n        tg_model = (self.target >> 5) & 7\n        return (str(tg_kind).zfill(2) + str(tg_model).zfill(2))\n\n    def getVersion(self):\n        return ('v' + str(self.version[3]).zfill(2) + '.' + str(self.version[2]).zfill(2) + '.' + str(self.version[1]).zfill(2) + '.' + str(self.version[0]).zfill(2))\n\n    def getTime(self):\n        return (time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(self.time)))\n\n    def __str__(self):\n        s =  \"Target:     {:s}\\n\".format(self.getTarget())\n        s += \"Version:    {:s}\\n\".format(self.getVersion())\n        s += \"Time:       {:s}\\n\".format(self.getTime())\n        s += \"Size:       {:d}\\n\".format(self.size)\n        s += \"Data MD5:   {}\\n\".format(binascii.hexlify(self.md5))\n        s += \"Header CRC: {:04x}\".format(self.crc16)\n        return s\n\n\ndef calc_checksum(packet, plength):\n    crc = [0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,\n           0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,\n           0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,\n           0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,\n           0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,\n           0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,\n           0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,\n           0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,\n           0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,\n           0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,\n           0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,\n           0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,\n           0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,\n           0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,\n           0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,\n           0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78]\n\n    v = 0x3692\n\n    for i in range(0, plength):\n        vv = v >> 8\n        v = vv ^ crc[((packet[i] ^ v) & 0xFF)]\n    return v\n\ndef unpack(args):\n    header = EncHeader()\n    if args.input.readinto(header) != sizeof(header):\n        raise EOFError(\"Couldn't read image file header.\")\n\n    print(header)\n\n    if (header.crc16 == calc_checksum(bytes(header), 39)):\n        if (args.verbose > 0):\n            print(\"{}: CRC of the header verified.\".format(args.input.name))\n    elif (not args.force_continue):\n        raise ValueError(\"CRC of the header doesn't match!\")\n    else:\n        eprint(\"Warning: CRC of the header doesn't match!\")\n\n    blocks_count = (header.size + 255) // 256\n    data = args.input.read(blocks_count * 256)\n\n    # MD5 of the entire file\n    md5_sum = hashlib.md5()\n    md5_sum.update(header)\n    md5_sum.update(data)\n    md5_calc = md5_sum.digest()\n    md5_read = args.input.read(16)\n\n    if md5_calc == md5_read:\n        if (args.verbose > 0):\n            print(\"{}: File MD5 matches.\".format(args.input.name))\n    elif (not args.force_continue):\n        raise ValueError(\"File MD5 doesn't match!\")\n    else:\n        eprint(\"Warning: File MD5 doesn't match!\")\n\n    remaining = args.input.read()\n    if len(remaining) == 0:\n        if (args.verbose > 0):\n            print(\"{}: Trailing bytes verified.\".format(args.input.name))\n    elif (not args.force_continue):\n        raise ValueError(\"Expected no trailing bytes, got {:d}!\".format(len(remaining)))\n    else:\n        eprint(\"{}: Warning: Expected no trailing bytes, got {:d}!\".format(args.input.name,len(remaining)))\n\n    dec_buffer = bytes()\n    for i in range(blocks_count):\n        enc_buffer = data[(i * 256):((i + 1) * 256)]\n        cipher = AES.new(encrypt_key, AES.MODE_CBC, encrypt_iv)\n        dec_buffer += cipher.decrypt(enc_buffer)\n\n    md5_data = hashlib.md5()\n    md5_data.update(dec_buffer)\n    md5_calc = md5_data.digest()\n    if (args.verbose > 0):\n        print(\"{}: Decrypted data MD5:   {}\".format(args.input.name,binascii.hexlify(md5_calc)))\n\n    if md5_calc == bytes(header.md5):\n        if (args.verbose > 0):\n            print(\"{}: Decrypted data MD5 matches.\".format(args.input.name))\n    elif (not args.force_continue):\n        raise ValueError(\"Decrypted data MD5 does not match!\")\n    else:\n        eprint(\"{}: Warning: Decrypted data MD5 does not match!\".format(args.input.name))\n\n    if args.cmd == 'dec':\n        args.output.write(dec_buffer[:header.size])\n        args.output.close()\n        print(\"{}: Decrypted file to '{}'\".format(args.input.name,args.output.name))\n\n    return\n\n\ndef pack(args):\n    header = EncHeader()\n\n    data = args.input.read()\n\n    header.size = len(data)\n\n    # Target\n    if args.target == '0305':\n        header.target = (0x5 << 5) | (0x3)\n    elif args.target == '0306':\n        header.target = (0x6 << 5) | (0x3)\n    else:\n        raise ValueError(\"Unknown target: '{}'\".format(args.target))\n\n    # Timestamp\n    if args.time is None:\n        header.time = int(time.time())\n    else:\n        if args.time.isdigit():\n            t = int(args.time, 10)\n        else:\n            t = time.strptime(args.time, '%Y-%m-%d %H:%M:%S')\n            if t is None:\n                raise ValueError(\"Wrong format for time: '{}'\".format(args.time))\n            t = int(time.mktime(t))\n\n        header.time = t\n\n    ver = re.search('^v(\\d+).(\\d+).(\\d+).(\\d+)$', args.fwver)\n    if ver is None:\n        raise ValueError(\"Wrong firmware version string format (vAA.BB.CC.DD): '{}'\".format(args.fwver))\n\n    # Store module version\n    header.version[3] = int(ver.group(1), 10)\n    header.version[2] = int(ver.group(2), 10)\n    header.version[1] = int(ver.group(3), 10)\n    header.version[0] = int(ver.group(4), 10)\n\n    # Prepare for computing MD5 sum of decrypted data\n    # Obviously padding on last block is included in the decrypted data checksum.\n    # You decide whether it's made on purpose, or just programmed by an intern.\n    md5_dec = hashlib.md5()\n\n    # Encrypt the file\n    enc_buffer = bytes()\n    blocks_size = 256\n    pad_len = (blocks_size - (len(data) % blocks_size)) % blocks_size\n    blocks_count = (len(data) + 255) // 256\n    enc_block = 256 * b'\\0'\n    for i in range(blocks_count):\n        dec_block = data[(i * 256):((i + 1) * 256)]\n        if len(dec_block) < 256:\n            # Last block is padded by data from previous block; this is\n            # unlikely conscious decision; but that's how it was implemented\n            dec_block += enc_block[len(dec_block):256]\n        md5_dec.update(dec_block)\n        cipher = AES.new(encrypt_key, AES.MODE_CBC, encrypt_iv)\n        enc_block = cipher.encrypt(dec_block)\n        enc_buffer += enc_block\n\n    # Store MD5 of decrypted data\n    header.md5 = (c_ubyte * 16)(*(md5_dec.digest()))\n\n    # Calculate the header crc\n    header.crc16 = calc_checksum(bytes(header), 39)\n\n    print(header)\n\n    args.output.write(header)\n    args.output.write(enc_buffer)\n\n    # Prepare MD5 of the entire file\n    md5_enc = hashlib.md5()\n    md5_enc.update(header)\n    md5_enc.update(enc_buffer)\n    args.output.write(md5_enc.digest())\n\n    args.output.close()\n\n    print(\"{}: Encrypted file to '{}'\".format(args.input.name, args.output.name))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    subparsers = parser.add_subparsers(dest='cmd')\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    parser.add_argument('-f', '--force-continue', action='store_true',\n          help=\"force continuing execution despite warning signs of issues\")\n\n    parser_dec = subparsers.add_parser('dec',\n          help=\"decrypt\")\n    parser_dec.add_argument('-i', '--input', required=True, type=argparse.FileType('rb'),\n          help=\"name of the input encrypted FC firmware file\")\n    parser_dec.add_argument('-o', '--output', type=argparse.FileType('wb'),\n          help=\"name of the output decrypted firmware file\")\n\n    parser_enc = subparsers.add_parser('enc',\n          help=\"encrypt\")\n    parser_enc.add_argument('-i', '--input', required=True, type=argparse.FileType('rb'),\n          help=\"name of the input unencrypted FC firmware file\")\n    parser_enc.add_argument('-o', '--output', type=argparse.FileType('wb'),\n          help=\"name of the output encrypted firmware file\")\n    parser_enc.add_argument('-T', '--time',\n          help=(\"timestamp; if omitted, the current time will be used; the timestamp \"\n             \"is either a number (seconds since epoch) or in the following format: \"\n             \"\\\"year-month-day hour:min:sec\\\"\"))\n    parser_enc.add_argument('-V', '--fwver', required=True,\n          help=\"firmware version string in the form \\\"vAA.BB.CC.DD\\\"\")\n    parser_enc.add_argument('-t', '--target', required=True,\n          help=\"either 0305 or 0306\")\n\n    parser_inf = subparsers.add_parser('info',\n          help=\"show header information\")\n    parser_inf.add_argument('-i', '--input', required=True, type=argparse.FileType('rb'),\n          help=\"input file\")\n\n    args = parser.parse_args()\n\n    if args.cmd == 'info':\n        if (args.verbose > 0):\n            print(\"{}: Opening for info display\".format(args.input.name))\n        unpack(args)\n\n    elif args.cmd == 'dec':\n        if (args.verbose > 0):\n            print(\"{}: Opening for decryption\".format(args.input.name))\n        if args.output is None:\n            if \".encrypted.\" in basename(args.input.name):\n                file_out = basename(args.input.name).replace(\".encrypted\", \"\")\n            else:\n                file_out = os.path.splitext(basename(args.input.name))[0] + \".decrypted.bin\"\n            args.output = open(file_out, 'wb')\n        unpack(args)\n\n    elif args.cmd == 'enc':\n        if (args.verbose > 0):\n            print(\"{}: Opening for encryption\".format(args.input.name))\n        if args.output is None:\n            if \".decrypted.\" in basename(args.input.name):\n                file_out = basename(args.input.name).replace(\".decrypted\", \"\")\n            else:\n                file_out = os.path.splitext(basename(args.input.name))[0] + \".encrypted.bin\"\n            args.output = open(file_out, 'wb')\n        pack(args)\n\n    else:\n        raise NotImplementedError(\"Unknown command: '{}'.\".format(args.cmd))\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dji_xv4_fwcon.py",
          "type": "blob",
          "size": 34.5166015625,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" DJI 'xV4' Firmware Container tool.\n\nExtract and creates the firmware package files.\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.3.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport re\nimport os\nimport hashlib\nimport binascii\nimport argparse\nimport configparser\nimport itertools\nfrom ctypes import c_char, c_int, c_ubyte, c_ushort, c_uint\nfrom ctypes import sizeof, LittleEndianStructure\nfrom time import gmtime, strftime, strptime\nfrom calendar import timegm\nfrom Crypto.Cipher import AES\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\nclass DjiModuleTarget():\n    \"Stores identification info on module for specific target\"\n    def __init__(self, kind, model, name, desc):\n        self.kind = kind\n        self.model = model\n        self.name = name\n        self.desc = desc\n\n\ndji_targets = [\n    DjiModuleTarget( 1,-1, \"CAM\",     \"camera\"),\n    DjiModuleTarget( 1, 0, \"FC300X\",  \"camera 'Ambarella A9SE' App\"), # P3X\n    DjiModuleTarget( 1, 1, \"CAMLDR\",  \"camera 'Ambarella A9SE' Ldr\"), # P3X\n    DjiModuleTarget( 1, 2, \"CAMBST\",  \"camera BST\"),\n    DjiModuleTarget( 1, 4, \"CAMBCPU\", \"camera BCPU\"),\n    DjiModuleTarget( 1, 5, \"CAMLCPU\", \"camera LCPU\"),\n    DjiModuleTarget( 1, 6, \"ZQ7020\",  \"camera 'Xilinx Zynq 7020'\"),\n    DjiModuleTarget( 2,-1, \"MBAPP\",   \"mobile app\"),\n    DjiModuleTarget( 3,-1, \"MC\",      \"main controller\"),\n    DjiModuleTarget( 3, 5, \"MCLDR\",   \"main controller 'A3' ldr\"), # P3X\n    DjiModuleTarget( 3, 6, \"MCAPP\",   \"main controller 'A3' app\"), # P3X\n    DjiModuleTarget( 4,-1, \"GIMBAL\",  \"gimbal\"),\n    DjiModuleTarget( 4, 0, \"GIMBAL0\", \"gimbal mdl 0\"), # P3X\n    DjiModuleTarget( 5,-1, \"CENTER\",  \"central board\"),\n    DjiModuleTarget( 5, 0, \"CENTER0\", \"central board mdl 0\"),\n    DjiModuleTarget( 6,-1, \"RMRAD\",   \"remote radio\"),\n    DjiModuleTarget( 7,-1, \"WIFI\",    \"Wi-Fi\"),\n    DjiModuleTarget( 7, 0, \"WIFI0\",   \"Wi-Fi mdl 0\"),\n    DjiModuleTarget( 8,-1, \"VENC\",    \"video encoder in air\"),\n    DjiModuleTarget( 8, 0, \"DM368\",   \"video encoder 'DaVinci Dm368 Linux'\"), # P3X\n    DjiModuleTarget( 8, 1, \"IG810LB2\",\"video encoder 'IG810 LB2_ENC'\"),\n    DjiModuleTarget( 9,-1, \"LBMCA\",   \"lightbridge MCU in air\"),\n    DjiModuleTarget( 9, 0, \"MCA1765\", \"lightbridge MCU 'STM32F103'\"), # P3X, OSMO_X5R\n    DjiModuleTarget(10,-1, \"BATTFW\",  \"battery firmware\"),\n    DjiModuleTarget(11,-1, \"BATTMGR\", \"battery controller\"),\n    DjiModuleTarget(11, 0, \"BATTERY\", \"battery controller 1 app\"), # P3X\n    DjiModuleTarget(11, 1, \"BATTERY2\",\"battery controller 2 app\"),\n    DjiModuleTarget(12,-1, \"ESC\",     \"electronic speed control\"),\n    DjiModuleTarget(12, 0, \"ESC0\",    \"electronic speed control 0\"), # P3X\n    DjiModuleTarget(12, 1, \"ESC1\",    \"electronic speed control 1\"), # P3X\n    DjiModuleTarget(12, 2, \"ESC2\",    \"electronic speed control 2\"), # P3X\n    DjiModuleTarget(12, 3, \"ESC3\",    \"electronic speed control 3\"), # P3X\n    DjiModuleTarget(13, 0, \"VDEC\",    \"video decoder\"),\n    DjiModuleTarget(13, 0, \"DM365M0\", \"video decoder 'DaVinci Dm365 Linux'\"),\n    DjiModuleTarget(13, 1, \"DM365M1\", \"video decoder 'DaVinci Dm385 Linux'\"),\n    DjiModuleTarget(14,-1, \"LBMCG\",   \"lightbridge MCU on ground\"),\n    DjiModuleTarget(14, 0, \"MCG1765A\",\"lightbridge MCU 'LPC1765 GROUND LB2'\"),\n    DjiModuleTarget(15,-1, \"TXUSBC\",  \"transmitter usb controller\"),\n    DjiModuleTarget(15, 0, \"TX68013\", \"transmitter usb 'IG810 LB2_68013_TX'\"), # P3X\n    DjiModuleTarget(16,-1, \"RXUSBCG\", \"receiver usb controller\"),\n    DjiModuleTarget(16, 0, \"RX68013\", \"receiver usb 'IG810 LB2_68013_RX ground'\"), # GL300a\n    DjiModuleTarget(16, 1, \"RXCY2014\",\"receiver usb 'IG810 LB2_CY2014_RX ground'\"), # GL300b+\n    DjiModuleTarget(17,-1, \"MVOM\",    \"visual positioning\"),\n    DjiModuleTarget(17, 0, \"MVOMC4\",  \"visual positioning module 'camera'\"), # P3X\n    DjiModuleTarget(17, 1, \"MVOMS0\",  \"visual positioning module 'sonar'\"), # P3X\n    DjiModuleTarget(19,-1, \"FPGAA\",   \"lightbridge FPGA on air\"),\n    DjiModuleTarget(19, 0, \"FPGAA0\",  \"lightbridge FPGA on air model 0\"), # P3X\n    DjiModuleTarget(20,-1, \"FPGAG\",   \"lightbridge FPGA on ground\"),\n    DjiModuleTarget(20, 3, \"FPGAG3\",  \"lightbridge FPGA on ground 'LB2'\"),\n    DjiModuleTarget(25,-1, \"IMU\",     \"inertial measurement unit\"),\n    DjiModuleTarget(25, 0, \"IMUA3M0\", \"inertial measurement unit pt0\"),\n    DjiModuleTarget(25, 1, \"IMUA3M1\", \"inertial measurement unit pt1\"),\n    DjiModuleTarget(26,-1, \"RTK\",     \"real time kinematic\"),\n    DjiModuleTarget(26, 6, \"RTKAPP\",  \"real time kinematic App\"),\n    DjiModuleTarget(26, 7, \"RTKLDR\",  \"real time kinematic Ldr\"),\n    DjiModuleTarget(27,-1, \"WIFIGND\", \"Wi-Fi ground\"),\n    DjiModuleTarget(29,-1, \"PMU\",     \"power management unit\"),\n    DjiModuleTarget(29, 0, \"PMUA3LDR\",\"power management unit App\"),\n    DjiModuleTarget(29, 1, \"PMUA3APP\",\"power management unit Ldr\"),\n    DjiModuleTarget(30,-1, \"TESTA\",   \"test A\"),\n    DjiModuleTarget(31,-1, \"TESTB\",   \"test B\")\n]\n\nencrypt_aes128_key = bytes([0x96, 0x70, 0x9a, 0xD3, 0x26, 0x67, 0x4A, 0xC3, 0x82, 0xB6, 0x69, 0x27, 0xE6, 0xd8, 0x84, 0x21])\nencrypt_aes128_iv = bytes([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n\nclass FwPkgHeader(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [('magic', c_uint),\n              ('magic_ver', c_ushort),\n              ('hdrend_offs', c_ushort),\n              ('timestamp', c_uint),\n              ('manufacturer', c_char * 16),\n              ('model', c_char * 16),\n              ('entry_count', c_ushort),\n              ('ver_latest_enc', c_int),\n              ('ver_rollbk_enc', c_int),\n              ('padding', c_ubyte * 10)]\n\n  def set_ver_latest(self, ver):\n    self.ver_latest_enc = 0x5127A564 ^ ver ^ self.timestamp\n\n  def set_ver_rollbk(self, ver):\n    self.ver_rollbk_enc = 0x5127A564 ^ ver ^ self.timestamp\n\n  def get_format_version(self):\n    if self.magic == 0x12345678 and self.magic_ver == 0x0000:\n        # The versions are expected to be set properly for this magic_ver; that's surprising,\n        # as it means the values are invalid only for magic_ver == 1\n        if (self.ver_latest_enc != 0):\n            return 201412\n        else:\n            return 0\n    elif self.magic == 0x12345678 and self.magic_ver == 0x0001:\n        if (self.ver_latest_enc == 0 and self.ver_rollbk_enc == 0):\n            return 201502\n        else:\n            return 201507\n    # Higher magic_ver - allow any 16-bit, but hex digits must be within BCD range\n    elif self.magic == 0x12345678 and self.magic_ver >= 0x0002 and self.magic_ver <= 0xFFFF and \\\n      all(((self.magic_ver >> n) & 0xF <= 9) for n in range(0,16,4)):\n        return 201608\n    else:\n        return 0\n\n  def set_format_version(self, ver):\n    if ver == 201412:\n        self.magic = 0x12345678\n        self.magic_ver = 0x0000\n        self.set_ver_latest(0)\n        self.set_ver_rollbk(0)\n    elif ver == 201502:\n        self.magic = 0x12345678\n        self.magic_ver = 0x0001\n        self.ver_latest_enc = 0\n        self.ver_rollbk_enc = 0\n    elif ver == 201507:\n        self.magic = 0x12345678\n        self.magic_ver = 0x0001\n        self.set_ver_latest(0)\n        self.set_ver_rollbk(0)\n    elif ver == 201608:\n        self.magic = 0x12345678\n        self.magic_ver = 0x1130 # storing most common val; expected to be overwritten\n        self.set_ver_latest(0)\n        self.set_ver_rollbk(0)\n    else:\n        raise ValueError(\"Unsupported package format version.\")\n\n  def dict_export(self):\n    d = dict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    varkey = 'ver_latest'\n    d[varkey] = d['timestamp'] ^ d[varkey+\"_enc\"] ^ 0x5127A564\n    varkey = 'ver_rollbk'\n    d[varkey] = d['timestamp'] ^ d[varkey+\"_enc\"] ^ 0x5127A564\n    varkey = 'padding'\n    d[varkey] = \"\".join(\"{:02X}\".format(x) for x in d[varkey])\n    return d\n\n  def ini_export(self, fp):\n    d = self.dict_export()\n    fp.write(\"# DJI Firmware Container main header file.\\n\")\n    fp.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n    varkey = 'pkg_format'\n    fp.write(\"{:s}={:d}\\n\".format(varkey,self.get_format_version()))\n    if self.magic_ver >= 2:\n        varkey = 'magic_ver'\n        fp.write(\"{:s}={:04x}\\n\".format(varkey,self.magic_ver))\n    varkey = 'manufacturer'\n    fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey].decode(\"utf-8\")))\n    varkey = 'model'\n    fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey].decode(\"utf-8\")))\n    varkey = 'timestamp'\n    fp.write(\"{:s}={:s}\\n\".format(varkey,strftime(\"%Y-%m-%d %H:%M:%S\",gmtime(d[varkey]))))\n    varkey = 'ver_latest'\n    fp.write(\"{:s}={:02d}.{:02d}.{:04d}\\n\".format(varkey, (d[varkey]>>24)&255, (d[varkey]>>16)&255, (d[varkey])&65535))\n    varkey = 'ver_rollbk'\n    fp.write(\"{:s}={:02d}.{:02d}.{:04d}\\n\".format(varkey, (d[varkey]>>24)&255, (d[varkey]>>16)&255, (d[varkey])&65535))\n    #varkey = 'padding'\n    #fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey]))\n\n  def __repr__(self):\n    d = self.dict_export()\n    from pprint import pformat\n    return pformat(d, indent=4, width=1)\n\nclass FwPkgEntry(LittleEndianStructure):\n  _pack_ = 1\n  _fields_ = [('target', c_ubyte),\n              ('spcoding', c_ubyte),\n              ('reserved2', c_ushort),\n              ('version', c_uint),\n              ('dt_offs', c_uint),\n              ('stored_len', c_uint),\n              ('decrypted_len', c_uint),\n              ('stored_md5', c_ubyte * 16),\n              ('decrypted_md5', c_ubyte * 16)]\n  preencrypted = 0\n\n  def get_encrypt_type(self):\n      return (self.spcoding >> 4) & 0x0F\n\n  def set_encrypt_type(self, enctype):\n      self.spcoding = (self.spcoding & 0x0F) | ((enctype & 0x0F) << 4)\n\n  def get_splvalue(self):\n      return (self.spcoding) & 0x0F\n\n  def set_splvalue(self, splval):\n      self.spcoding = (self.spcoding & 0xF0) | (splval & 0x0F)\n\n  def target_name(self):\n    tg_kind = getattr(self, 'target') & 31\n    tg_model = (getattr(self, 'target') >> 5) & 7\n    module_info = next((mi for mi in dji_targets if mi.kind == tg_kind and mi.model == tg_model), None)\n    if (module_info is not None):\n        return module_info.desc\n    # If not found, try getting category\n    module_info = next((mi for mi in dji_targets if mi.kind == tg_kind and mi.model == -1), None)\n    if (module_info is not None):\n        return \"{:s} model {:02d}\".format(module_info.desc,tg_model)\n    # If category also not found, return as unknown device\n    return \"device kind {:02} model {:02}\".format(tg_kind,tg_model)\n\n  def hex_stored_md5(self):\n    varkey = 'stored_md5'\n    return \"\".join(\"{:02x}\".format(x) for x in getattr(self, varkey))\n\n  def hex_decrypted_md5(self):\n    varkey = 'decrypted_md5'\n    return \"\".join(\"{:02x}\".format(x) for x in getattr(self, varkey))\n\n  def dict_export(self):\n    d = dict()\n    for (varkey, vartype) in self._fields_:\n        d[varkey] = getattr(self, varkey)\n    varkey = 'version'\n    d[varkey] = \"{:02d}.{:02d}.{:04d}\".format((d[varkey]>>24)&255, (d[varkey]>>16)&255, (d[varkey])&65535)\n    varkey = 'stored_md5'\n    d[varkey] = \"\".join(\"{:02x}\".format(x) for x in d[varkey])\n    varkey = 'decrypted_md5'\n    d[varkey] = \"\".join(\"{:02x}\".format(x) for x in d[varkey])\n    varkey = 'target'\n    d[varkey] = \"m{:02d}{:02d}\".format(d[varkey]&31, (d[varkey]>>5)&7)\n    varkey = 'encrypt_type'\n    d[varkey] = self.get_encrypt_type()\n    varkey = 'splvalue'\n    d[varkey] = self.get_splvalue()\n    varkey = 'target_name'\n    d[varkey] = self.target_name()\n    return d\n\n  def ini_export(self, fp):\n    d = self.dict_export()\n    fp.write(\"# DJI Firmware Container module header file.\\n\")\n    fp.write(\"# Stores firmware for {:s}\\n\".format(d['target_name']))\n    fp.write(strftime(\"# Generated on %Y-%m-%d %H:%M:%S\\n\", gmtime()))\n    varkey = 'target'\n    fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey]))\n    varkey = 'version'\n    fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey]))\n    varkey = 'encrypt_type'\n    fp.write(\"{:s}={:d}\\n\".format(varkey,d[varkey]))\n    if (d[varkey] != 0):\n        # If we do not support encryption of given type, we may extract the file in encrypted form\n        varkey = 'preencrypted'\n        fp.write(\"{:s}={:d}\\n\".format(varkey,self.preencrypted))\n    if (self.preencrypted):\n        # We cannot compute decrypted MD5 for pre-encrypted files, so store them in INI file\n        varkey = 'decrypted_md5'\n        fp.write(\"{:s}={:s}\\n\".format(varkey,d[varkey]))\n    varkey = 'splvalue'\n    fp.write(\"{:s}={:d}\\n\".format(varkey,d[varkey]))\n    varkey = 'reserved2'\n    fp.write(\"{:s}={:04X}\\n\".format(varkey,d[varkey]))\n\n  def __repr__(self):\n    d = self.dict_export()\n    from pprint import pformat\n    return pformat(d, indent=4, width=1)\n\n\ncrc16_tab = [\n  0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,\n  0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,\n  0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,\n  0x9CC9, 0x8D40, 0xBFDB, 0xAE52, 0xDAED, 0xCB64, 0xF9FF, 0xE876,\n  0x2102, 0x308B, 0x0210, 0x1399, 0x6726, 0x76AF, 0x4434, 0x55BD,\n  0xAD4A, 0xBCC3, 0x8E58, 0x9FD1, 0xEB6E, 0xFAE7, 0xC87C, 0xD9F5,\n  0x3183, 0x200A, 0x1291, 0x0318, 0x77A7, 0x662E, 0x54B5, 0x453C,\n  0xBDCB, 0xAC42, 0x9ED9, 0x8F50, 0xFBEF, 0xEA66, 0xD8FD, 0xC974,\n  0x4204, 0x538D, 0x6116, 0x709F, 0x0420, 0x15A9, 0x2732, 0x36BB,\n  0xCE4C, 0xDFC5, 0xED5E, 0xFCD7, 0x8868, 0x99E1, 0xAB7A, 0xBAF3,\n  0x5285, 0x430C, 0x7197, 0x601E, 0x14A1, 0x0528, 0x37B3, 0x263A,\n  0xDECD, 0xCF44, 0xFDDF, 0xEC56, 0x98E9, 0x8960, 0xBBFB, 0xAA72,\n  0x6306, 0x728F, 0x4014, 0x519D, 0x2522, 0x34AB, 0x0630, 0x17B9,\n  0xEF4E, 0xFEC7, 0xCC5C, 0xDDD5, 0xA96A, 0xB8E3, 0x8A78, 0x9BF1,\n  0x7387, 0x620E, 0x5095, 0x411C, 0x35A3, 0x242A, 0x16B1, 0x0738,\n  0xFFCF, 0xEE46, 0xDCDD, 0xCD54, 0xB9EB, 0xA862, 0x9AF9, 0x8B70,\n  0x8408, 0x9581, 0xA71A, 0xB693, 0xC22C, 0xD3A5, 0xE13E, 0xF0B7,\n  0x0840, 0x19C9, 0x2B52, 0x3ADB, 0x4E64, 0x5FED, 0x6D76, 0x7CFF,\n  0x9489, 0x8500, 0xB79B, 0xA612, 0xD2AD, 0xC324, 0xF1BF, 0xE036,\n  0x18C1, 0x0948, 0x3BD3, 0x2A5A, 0x5EE5, 0x4F6C, 0x7DF7, 0x6C7E,\n  0xA50A, 0xB483, 0x8618, 0x9791, 0xE32E, 0xF2A7, 0xC03C, 0xD1B5,\n  0x2942, 0x38CB, 0x0A50, 0x1BD9, 0x6F66, 0x7EEF, 0x4C74, 0x5DFD,\n  0xB58B, 0xA402, 0x9699, 0x8710, 0xF3AF, 0xE226, 0xD0BD, 0xC134,\n  0x39C3, 0x284A, 0x1AD1, 0x0B58, 0x7FE7, 0x6E6E, 0x5CF5, 0x4D7C,\n  0xC60C, 0xD785, 0xE51E, 0xF497, 0x8028, 0x91A1, 0xA33A, 0xB2B3,\n  0x4A44, 0x5BCD, 0x6956, 0x78DF, 0x0C60, 0x1DE9, 0x2F72, 0x3EFB,\n  0xD68D, 0xC704, 0xF59F, 0xE416, 0x90A9, 0x8120, 0xB3BB, 0xA232,\n  0x5AC5, 0x4B4C, 0x79D7, 0x685E, 0x1CE1, 0x0D68, 0x3FF3, 0x2E7A,\n  0xE70E, 0xF687, 0xC41C, 0xD595, 0xA12A, 0xB0A3, 0x8238, 0x93B1,\n  0x6B46, 0x7ACF, 0x4854, 0x59DD, 0x2D62, 0x3CEB, 0x0E70, 0x1FF9,\n  0xF78F, 0xE606, 0xD49D, 0xC514, 0xB1AB, 0xA022, 0x92B9, 0x8330,\n  0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78,\n]\n\ndef dji_calculate_crc16_part(buf, pcrc):\n    \"\"\" A non-standard crc16 hashing algorithm, looks like 32-bit one from Ambarella simply cut down in bits.\n    \"\"\"\n    crc = pcrc\n    for octet in buf:\n        crc = crc16_tab[(crc ^ octet) & 0xff] ^ (crc >> 8)\n    return crc & 0xffff\n\n\ndef dji_decrypt_block(cipher_buf, enc_key, enc_iv):\n    \"\"\" Decrypts a buffer with AES in a DJI way.\n    \"\"\"\n    block_sz = 256\n    plain_buf = b\"\"\n    for cbpos in range(0, len(cipher_buf), block_sz):\n        # Reinit the crypto for each block, this is how Dji does it\n        crypto = AES.new(enc_key, AES.MODE_CBC, enc_iv)\n        plain_buf += crypto.decrypt(cipher_buf[cbpos:cbpos+block_sz])\n    return plain_buf, enc_iv\n\n\ndef dji_encrypt_block(cipher_buf, enc_key, enc_iv):\n    \"\"\" Encrypts a buffer with AES in a DJI way.\n    \"\"\"\n    block_sz = 256\n    plain_buf = b\"\"\n    for cbpos in range(0, len(cipher_buf), block_sz):\n        # Reinit the crypto for each block, this is how Dji does it\n        crypto = AES.new(enc_key, AES.MODE_CBC, enc_iv)\n        plain_buf += crypto.encrypt(cipher_buf[cbpos:cbpos+block_sz])\n    return plain_buf, enc_iv\n\n\ndef dji_write_fwpkg_head(po, pkghead, minames):\n    fname = \"{:s}_head.ini\".format(po.mdprefix)\n    fwheadfile = open(fname, \"w\")\n    pkghead.ini_export(fwheadfile)\n    fwheadfile.write(\"{:s}={:s}\\n\".format(\"modules\",' '.join(minames)))\n    fwheadfile.close()\n\n\ndef dji_read_fwpkg_head(po):\n    pkghead = FwPkgHeader()\n    fname = \"{:s}_head.ini\".format(po.mdprefix)\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n    # Set magic fields properly\n    pkgformat = parser.get(\"asection\", \"pkg_format\").encode(\"utf-8\")\n    pkghead.set_format_version(int(pkgformat))\n    if parser.has_option('asection', 'magic_ver'):\n        magicver_s = parser.get('asection', 'magic_ver')\n        pkghead.magic_ver = int(magicver_s,16)\n    # Set the rest of the fields\n    pkghead.manufacturer = parser.get(\"asection\", \"manufacturer\").encode(\"utf-8\")\n    pkghead.model = parser.get(\"asection\", \"model\").encode(\"utf-8\")\n    pkghead.timestamp = timegm(strptime(parser.get(\"asection\", \"timestamp\"),\"%Y-%m-%d %H:%M:%S\"))\n    ver_latest_s = parser.get(\"asection\", \"ver_latest\")\n    ver_latest_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)[.](?P<svn>[0-9A-Fa-f]+)', ver_latest_s)\n    pkghead.set_ver_latest(\n       ((int(ver_latest_m.group(\"major\"), 10) & 0xff) << 24) +\n       ((int(ver_latest_m.group(\"minor\"), 10) & 0xff) << 16) +\n       (int(ver_latest_m.group(\"svn\"), 10) & 0xffff)\n    )\n    ver_rollbk_s = parser.get(\"asection\", \"ver_rollbk\")\n    ver_rollbk_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)[.](?P<svn>[0-9A-Fa-f]+)', ver_rollbk_s)\n    pkghead.set_ver_rollbk(\n      ((int(ver_rollbk_m.group(\"major\"), 10) & 0xff) << 24) +\n      ((int(ver_rollbk_m.group(\"minor\"), 10) & 0xff) << 16) +\n      (int(ver_rollbk_m.group(\"svn\"), 10) & 0xffff)\n    )\n    minames_s = parser.get(\"asection\", \"modules\")\n    minames = minames_s.split(' ')\n    pkghead.entry_count = len(minames)\n    pkghead.hdrend_offs = sizeof(pkghead) + sizeof(FwPkgEntry)*pkghead.entry_count + sizeof(c_ushort)\n    del parser\n    return (pkghead, minames)\n\n\ndef dji_write_fwentry_head(po, i, e, miname):\n    fname = \"{:s}_{:s}.ini\".format(po.mdprefix,miname)\n    fwheadfile = open(fname, \"w\")\n    e.ini_export(fwheadfile)\n    fwheadfile.close()\n\n\ndef dji_read_fwentry_head(po, i, miname):\n    hde = FwPkgEntry()\n    fname = \"{:s}_{:s}.ini\".format(po.mdprefix,miname)\n    parser = configparser.ConfigParser()\n    with open(fname, \"r\") as lines:\n        lines = itertools.chain((\"[asection]\",), lines)  # This line adds section header to ini\n        parser.read_file(lines)\n    target_s = parser.get(\"asection\", \"target\")\n    target_m = re.search('m(?P<kind>[0-9]{2})(?P<model>[0-9]{2})', target_s)\n    hde.target = ((int(target_m.group(\"kind\"),10)&0x1f)) + ((int(target_m.group(\"model\"),10)&0x07)<<5)\n    version_s = parser.get(\"asection\", \"version\")\n    version_m = re.search('(?P<major>[0-9]+)[.](?P<minor>[0-9]+)[.](?P<svn>[0-9]+)', version_s)\n    hde.version = (\n      ((int(version_m.group(\"major\"), 10) & 0xff) << 24) +\n      ((int(version_m.group(\"minor\"), 10) % 0xff) << 16) +\n      (int(version_m.group(\"svn\"), 10) % 0xffff)\n    )\n    if parser.has_option(\"asection\", \"preencrypted\"):\n        hde.preencrypted = int(parser.get(\"asection\", \"preencrypted\"),10)\n    if (hde.preencrypted):\n        decrypted_md5_s = parser.get(\"asection\", \"decrypted_md5\")\n        hde.decrypted_md5 = (c_ubyte * 16).from_buffer_copy(binascii.unhexlify(decrypted_md5_s))\n    hde.set_encrypt_type( int(parser.get(\"asection\", \"encrypt_type\"),10) )\n    hde.set_splvalue( int(parser.get(\"asection\", \"splvalue\"),10) )\n    hde.reserved2 = int(parser.get(\"asection\", \"reserved2\"),16)\n    del parser\n    return (hde)\n\ndef dji_extract(po, fwpkgfile):\n    pkghead = FwPkgHeader()\n    if fwpkgfile.readinto(pkghead) != sizeof(pkghead):\n        raise EOFError(\"Could not read firmware package file header.\")\n    pkgformat = pkghead.get_format_version()\n    if pkgformat == 0:\n        if (not po.force_continue):\n            eprint(\"{}: Error: Unexpected magic value in main header; input file is not a firmware package.\".format(po.fwpkg))\n            exit(1)\n        eprint(\"{}: Warning: Unexpected magic value in main header; will try to extract anyway.\".format(po.fwpkg))\n    if (po.verbose > 1):\n        print(\"{}: Package format version {:d} detected\".format(po.fwpkg,pkgformat))\n    if (pkghead.ver_latest_enc == 0 and pkghead.ver_rollbk_enc == 0):\n        eprint(\"{}: Warning: Unversioned firmware package identified; this format is not fully supported.\".format(po.fwpkg))\n        # In this format, versions should be set from file name, and CRC16 of the header should be equal to values hard-coded in updater\n    if (po.verbose > 1):\n        print(\"{}: Header:\".format(po.fwpkg))\n        print(pkghead)\n    curhead_checksum = dji_calculate_crc16_part((c_ubyte * sizeof(pkghead)).from_buffer_copy(pkghead), 0x3692)\n\n    pkgmodules = []\n    for i in range(pkghead.entry_count):\n        hde = FwPkgEntry()\n        if fwpkgfile.readinto(hde) != sizeof(hde):\n            raise EOFError(\"Couldn't read firmware package file entry.\")\n        if (po.verbose > 1):\n            print(\"{}: Module index {:d}\".format(po.fwpkg,i))\n            print(hde)\n        curhead_checksum = dji_calculate_crc16_part((c_ubyte * sizeof(hde)).from_buffer_copy(hde), curhead_checksum)\n        if hde.stored_len != hde.decrypted_len:\n            eprint(\"{}: Warning: decrypted size differs from stored one, {:d} instead of {:d}; this is not supported.\"\n              .format(po.fwpkg,hde.decrypted_len,hde.stored_len))\n        chksum_enctype = hde.get_encrypt_type()\n        if (chksum_enctype != 0):\n            if (po.no_crypto):\n                hde.preencrypted = 1\n            elif (chksum_enctype == 1):\n                encrypt_key = encrypt_aes128_key\n                encrypt_iv  = encrypt_aes128_iv\n            else:\n                # Since we cannot decode the encryption, mark the entry as pre-encrypted to extract in encrypted form\n                eprint(\"{}: Warning: Unknown encryption {:d} in module {:d}, extracting encrypted.\"\n                  .format(po.fwpkg,chksum_enctype,i))\n                hde.preencrypted = 1\n        pkgmodules.append(hde)\n\n    pkghead_checksum = c_ushort()\n    if fwpkgfile.readinto(pkghead_checksum) != sizeof(pkghead_checksum):\n        raise EOFError(\"Couldn't read firmware package file header checksum.\")\n\n    if curhead_checksum != pkghead_checksum.value:\n        eprint(\"{}: Warning: Firmware package file header checksum did not match; should be {:04X}, found {:04X}.\"\n          .format(po.fwpkg, pkghead_checksum.value, curhead_checksum))\n    elif (po.verbose > 1):\n        print(\"{}: Headers checksum {:04X} matches.\".format(po.fwpkg,pkghead_checksum.value))\n\n    if fwpkgfile.tell() != pkghead.hdrend_offs:\n        eprint(\"{}: Warning: Header end offset does not match; should end at {}, ends at {}.\"\n          .format(po.fwpkg,pkghead.hdrend_offs,fwpkgfile.tell()))\n\n    # Prepare array of names; \"0\" will mean empty index\n    minames = [\"0\"]*len(pkgmodules)\n    # Name the modules after target component\n    for i, hde in enumerate(pkgmodules):\n        if hde.stored_len > 0:\n            d = hde.dict_export()\n            minames[i] = \"{:s}\".format(d['target'])\n    # Rename targets in case of duplicates\n    minames_seen = set()\n    for i in range(len(minames)):\n        miname = minames[i]\n        if miname in minames_seen:\n            # Add suffix a..z to multiple uses of the same module\n            for miname_suffix in range(97,110):\n                if miname+chr(miname_suffix) not in minames_seen:\n                    break\n            # Show warning the first time duplicate is found\n            if (miname_suffix == 97):\n                eprint(\"{}: Warning: Found multiple modules {:s}; invalid firmware.\".format(po.fwpkg,miname))\n            minames[i] = miname+chr(miname_suffix)\n        minames_seen.add(minames[i])\n    minames_seen = None\n\n    dji_write_fwpkg_head(po, pkghead, minames)\n\n    for i, hde in enumerate(pkgmodules):\n        if minames[i] == \"0\":\n            if (po.verbose > 0):\n                print(\"{}: Skipping module index {}, {} bytes\".format(po.fwpkg,i,hde.stored_len))\n            continue\n        if (po.verbose > 0):\n            print(\"{}: Extracting module index {}, {} bytes\".format(po.fwpkg,i,hde.stored_len))\n        chksum_enctype = hde.get_encrypt_type()\n        stored_chksum = hashlib.md5()\n        decrypted_chksum = hashlib.md5()\n        dji_write_fwentry_head(po, i, hde, minames[i])\n        fwitmfile = open(\"{:s}_{:s}.bin\".format(po.mdprefix,minames[i]), \"wb\")\n        fwpkgfile.seek(hde.dt_offs)\n        stored_n = 0\n        decrypted_n = 0\n        while stored_n < hde.stored_len:\n            # read block limit must be a multiplication of encryption block size\n            copy_buffer = fwpkgfile.read(min(1024 * 1024, hde.stored_len - stored_n))\n            if not copy_buffer:\n                break\n            stored_n += len(copy_buffer)\n            stored_chksum.update(copy_buffer)\n            if (chksum_enctype != 0) and (not hde.preencrypted):\n                copy_buffer, encrypt_iv = dji_decrypt_block(copy_buffer, encrypt_key, encrypt_iv)\n            fwitmfile.write(copy_buffer)\n            decrypted_n += len(copy_buffer)\n            decrypted_chksum.update(copy_buffer)\n        fwitmfile.close()\n        if (stored_chksum.hexdigest() != hde.hex_stored_md5()):\n            eprint(\"{}: Warning: Module index {:d} stored checksum mismatch; got {:s}, expected {:s}.\"\n              .format(po.fwpkg,i,stored_chksum.hexdigest(),hde.hex_stored_md5()))\n        if (not hde.preencrypted) and (decrypted_chksum.hexdigest() != hde.hex_decrypted_md5()):\n            eprint(\"{}: Warning: Module index {:d} decrypted checksum mismatch; got {:s}, expected {:s}.\"\n              .format(po.fwpkg,i,decrypted_chksum.hexdigest(),hde.hex_decrypted_md5()))\n            eprint(\"{}: Module index {:d} may be damaged due to bad decryption; use no-crypto option to leave it as-is.\"\n              .format(po.fwpkg,i))\n        if (not hde.preencrypted) and (decrypted_n != hde.decrypted_len):\n            eprint(\"{}: Warning: decrypted size mismatch, {:d} instead of {:d}.\"\n              .format(po.fwpkg,decrypted_n,hde.decrypted_len))\n        if (po.verbose > 1):\n            print(\"{}: Module index {:d} stored checksum {:s}\".format(po.fwpkg,i,stored_chksum.hexdigest()))\n    return\n\n\ndef dji_create(po, fwpkgfile):\n    # Read headers from INI files\n    (pkghead, minames) = dji_read_fwpkg_head(po)\n    pkgmodules = []\n    # Create module entry for each partition\n    for i, miname in enumerate(minames):\n        if miname == \"0\":\n            hde = FwPkgEntry()\n        else:\n            hde = dji_read_fwentry_head(po, i, miname)\n        pkgmodules.append(hde)\n    # Write the unfinished headers\n    if (po.verbose > 2):\n        print(\"{}: File map: 0x{:08x} FwPkgHeader\".format(po.fwpkg,fwpkgfile.tell()))\n    fwpkgfile.write((c_ubyte * sizeof(pkghead)).from_buffer_copy(pkghead))\n    for hde in pkgmodules:\n        if (po.verbose > 2):\n            print(\"{}: File map: 0x{:08x} FwPkgEntry[m{:02d}{:02d}]\".format(po.fwpkg,\n              fwpkgfile.tell(), getattr(hde, 'target') & 31, (getattr(hde, 'target') >> 5) & 7))\n        fwpkgfile.write((c_ubyte * sizeof(hde)).from_buffer_copy(hde))\n    fwpkgfile.write((c_ubyte * sizeof(c_ushort))())\n    # Write module data\n    for i, miname in enumerate(minames):\n        hde = pkgmodules[i]\n        if miname == \"0\":\n            if (po.verbose > 0):\n                print(\"{}: Empty module index {:d}\".format(po.fwpkg,i))\n            continue\n        if (po.verbose > 0):\n            print(\"{}: Copying module index {:d}\".format(po.fwpkg,i))\n        fname = \"{:s}_{:s}.bin\".format(po.mdprefix,miname)\n        # Skip unused pkgmodules\n        if (os.stat(fname).st_size < 1):\n            eprint(\"{}: Warning: module index {:d} empty\".format(po.fwpkg,i))\n            continue\n        chksum_enctype = hde.get_encrypt_type()\n        epos = fwpkgfile.tell()\n        # Check for data encryption\n        if (chksum_enctype != 0) and (not hde.preencrypted):\n            if (po.no_crypto):\n                if (not po.force_continue):\n                    eprint(\"{}: Error: Module {:d} needs encryption {:d}, but crypto is disabled.\"\n                      .format(po.fwpkg,chksum_enctype,i))\n                    exit(1)\n                eprint(\"{}: Warning: Module {:d} needs encryption {:d}, but crypto is disabled; switching to unencrypted.\"\n                  .format(po.fwpkg,chksum_enctype,i))\n                hde.set_encrypt_type(0)\n                chksum_enctype = hde.get_encrypt_type()\n            elif (chksum_enctype == 1):\n                encrypt_key = encrypt_aes128_key\n                encrypt_iv  = encrypt_aes128_iv\n            else:\n                if (not po.force_continue):\n                    eprint(\"{}: Error: Unknown encryption {:d} in module {:d}; cannot encrypt.\".format(po.fwpkg,chksum_enctype,i))\n                    exit(1)\n                eprint(\"{}: Warning: Unknown encryption {:d} in module {:d}; switching to unencrypted.\".format(po.fwpkg,chksum_enctype,i))\n                hde.set_encrypt_type(0)\n                chksum_enctype = hde.get_encrypt_type()\n        # Copy partition data and compute checksum\n        if (po.verbose > 2):\n            print(\"{}: File map: 0x{:08x} FwModuleData[m{:02d}{:02d}]\".format(po.fwpkg,\n              epos, getattr(hde, 'target') & 31, (getattr(hde, 'target') >> 5) & 7))\n        fwitmfile = open(fname, \"rb\")\n        stored_chksum = hashlib.md5()\n        decrypted_chksum = hashlib.md5()\n        decrypted_n = 0\n        while True:\n            # read block limit must be a multiplication of encryption block size\n            copy_buffer = fwitmfile.read(1024 * 1024)\n            if not copy_buffer:\n                break\n            decrypted_chksum.update(copy_buffer)\n            decrypted_n += len(copy_buffer)\n            if (chksum_enctype != 0) and (not hde.preencrypted):\n                copy_buffer, encrypt_iv = dji_encrypt_block(copy_buffer, encrypt_key, encrypt_iv)\n            stored_chksum.update(copy_buffer)\n            fwpkgfile.write(copy_buffer)\n        fwitmfile.close()\n        hde.dt_offs = epos\n        hde.stored_len = fwpkgfile.tell() - epos\n        # We do not support pre-encryption which changes length of data\n        # If we need it at some point, the only way is to store decrypted_len in INI file\n        hde.decrypted_len = decrypted_n\n        hde.stored_md5 = (c_ubyte * 16).from_buffer_copy(stored_chksum.digest())\n        if (hde.preencrypted):\n            # If the file is pre-encrypted, then it has to have encryption type and MD5 set from INI file\n            if (chksum_enctype == 0):\n                eprint(\"{}: Warning: Module {:d} marked as pre-encrypted, but with no encryption type.\".format(po.fwpkg,i))\n            if all([ v == 0 for v in hde.decrypted_md5 ]):\n                eprint(\"{}: Warning: Module {:d} marked as pre-encrypted, but decrypted MD5 is zeros.\".format(po.fwpkg,i))\n            else:\n                print(\"{}: Module {:d} marked as pre-encrypted; decrypted MD5 accepted w/o verification.\".format(po.fwpkg,i))\n        else:\n            # If the file is not pre-encrypted, then we should just use the MD5 we've computed\n            hde.decrypted_md5 = (c_ubyte * 16).from_buffer_copy(decrypted_chksum.digest())\n        pkgmodules[i] = hde\n    if (po.verbose > 2):\n        print(\"{}: File map: 0x{:08x} FwDataEnd\".format(po.fwpkg, fwpkgfile.tell()))\n    # Write all headers again\n    fwpkgfile.seek(0,os.SEEK_SET)\n    fwpkgfile.write((c_ubyte * sizeof(pkghead)).from_buffer_copy(pkghead))\n    curhead_checksum = dji_calculate_crc16_part((c_ubyte * sizeof(pkghead)).from_buffer_copy(pkghead), 0x3692)\n    for hde in pkgmodules:\n        fwpkgfile.write((c_ubyte * sizeof(hde)).from_buffer_copy(hde))\n        curhead_checksum = dji_calculate_crc16_part((c_ubyte * sizeof(hde)).from_buffer_copy(hde), curhead_checksum)\n    pkghead_checksum = c_ushort(curhead_checksum)\n    fwpkgfile.write((c_ubyte * sizeof(c_ushort)).from_buffer_copy(pkghead_checksum))\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-p', '--fwpkg', default=\"\", type=str, required=True,\n          help=\"name of the firmware package file\")\n\n    parser.add_argument('-m', '--mdprefix', default=\"\", type=str,\n          help=(\"directory and file name prefix for the single decomposed firmware modules \"\n           \"(default is base name of fwpkg with extension stripped, in working dir)\"))\n\n    parser.add_argument('-f', '--force-continue', action='store_true',\n          help=\"force continuing execution despite warning signs of issues\")\n\n    parser.add_argument('-c', '--no-crypto', action='store_true',\n          help=\"disable cryptography - do not encrypt/decrypt modules\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group()\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"extract firmware package into modules\")\n\n    subparser.add_argument('-a', '--add', action='store_true',\n          help=\"add module files to firmware package\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"display version information and exit\")\n\n    po = parser.parse_args()\n\n    if len(po.fwpkg) > 0 and len(po.mdprefix) == 0:\n        po.mdprefix = os.path.splitext(os.path.basename(po.fwpkg))[0]\n\n    if po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extraction\".format(po.fwpkg))\n        with open(po.fwpkg, 'rb') as fwpkgfile:\n            dji_extract(po, fwpkgfile)\n\n    elif po.add:\n        if (po.verbose > 0):\n            print(\"{}: Opening for creation\".format(po.fwpkg))\n        with open(po.fwpkg, 'wb') as fwpkgfile:\n            dji_create(po, fwpkgfile)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "dm3xx_encode_usb_hardcoder.py",
          "type": "blob",
          "size": 21.2021484375,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Dji DM3xx DaVinci encode_usb binary hard-coded values editor.\n\nThe tool can parse encode_usb ELF file from Dji Firmware module for\nTI DM3xx DaVinci Media Processor.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nOnly 'setValue' element in the exported file is really changeable,\nall the other data is just informational. This includes `maxValue` and\n`minValue` - they don't do anything and changing them in the JSON file\nwill not influence update operation.\n\nExported values:\n\nog_hardcoded.p3x_dm3xx.startup_encrypt_check_always_pass -\n\n  The binary does encryption check at startup by sending encrypt request\n  to camera (m0100) and comparing result with same data encrypted locally.\n  If the comparison fails (which means encryption keys are different),\n  the binary will continously retry encryption, generating considerable\n  CPU load and degrading video compression to 8FPS due to that.\n  This option, when set to 1, prevents the continous loop by always setting\n  encryption check status to \"passed\".\n\n  Here's an example DaVinci console log when there is no issue with encryption:\n  ```\n  Entry Encrypt qury mode\n  [...]\n  Encrypt passed!\n  ```\n  The second line should show within 100 lines after first one. If it never\n  shows, then there is an issue which results in continous retries.\n\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport os\nimport re\nimport io\nimport enum\nimport json\n\nsys.path.insert(0, './')\nfrom amba_sys_hardcoder import eprint, elf_march_to_asm_config, \\\n  armfw_elf_whole_section_search, armfw_elf_match_to_public_values, \\\n  armfw_elf_paramvals_extract_list, armfw_elf_get_value_update_bytes, \\\n  armfw_elf_paramvals_get_depend_list, armfw_elf_publicval_update, \\\n  armfw_elf_paramvals_update_list, armfw_elf_generic_objdump, \\\n  armfw_asm_search_strings_to_re_list, armfw_elf_paramvals_export_json, \\\n  armfw_elf_paramvals_export_simple_list, armfw_elf_paramvals_export_mapfile, \\\n  VarType, DataVariety, CodeVariety\n\n\ndef startup_encrypt_check_always_pass_params_update(asm_arch, elf_sections, re_list, glob_params_list, var_info, new_var_nativ):\n    \"\"\" Callback function to prepare 'startup_encrypt_check_always_pass' value change.\n    Sets global params required for the switch.\n    \"\"\"\n    glob_re = glob_params_list[var_info['cfunc_name']+'..re']['value']\n    glob_re_size = glob_params_list[var_info['cfunc_name']+'..re_size']['value']\n    var_encryptThrFxn = glob_params_list['encryptThrFxn']\n    if new_var_nativ == 1:\n        # Set variables requires to change original into encpass\n        patterns = re_func_encryptThrFxn_encpass\n        re_lines, re_labels = armfw_asm_search_strings_to_re_list(patterns['re'])\n        # First variable\n        var_bPassedEnc_name = 's_bPassedEnc'\n        var_bPassedEnc = glob_params_list['Encrypt_Request.s_bPassedEnc'].copy()\n        var_bPassedEnc['cfunc_name'] = var_info['cfunc_name']\n        var_bPassedEnc['name'] = var_bPassedEnc['cfunc_name']+'.'+var_bPassedEnc_name\n        var_bPassedEnc['line'] = None\n        var_bPassedEnc['address'] = None\n        var_bPassedEnc['value'] = None\n        for ln_num, ln_regex in enumerate(re_lines):\n            re_line = re.search(r'^.+P<'+var_bPassedEnc_name+'>.+$', ln_regex)\n            if re_line:\n                var_bPassedEnc['line'] = ln_num\n                var_bPassedEnc['address'] = var_encryptThrFxn['address'] + sum(glob_re_size[0:ln_num])\n                break\n        # Second variable\n        var_bPassedEnc_p_name = 's_bPassedEnc_p'\n        var_bPassedEnc_p = {'str_value': \"\", 'value': 0x0, 'address': None, 'line': None, 'cfunc_name': var_info['cfunc_name']}\n        var_bPassedEnc_p['value'] = glob_params_list['Encrypt_Request.s_bPassedEnc']['value']\n        var_bPassedEnc_p['name'] = var_bPassedEnc['cfunc_name']+'.'+var_bPassedEnc_p_name\n        var_bPassedEnc_p.update(patterns['vars'][var_bPassedEnc_p_name])\n        for ln_num, ln_regex in enumerate(re_lines):\n            re_line = re.search(r'^.+P<'+var_bPassedEnc_p_name+'>.+$', ln_regex)\n            if re_line:\n                var_bPassedEnc_p['line'] = ln_num\n                var_bPassedEnc_p['address'] = var_encryptThrFxn['address'] + sum(glob_re_size[0:ln_num])\n                break\n        # Make var_bPassedEnc point to var_bPassedEnc_p\n        var_bPassedEnc['value'] = var_bPassedEnc_p['address'] # var_encryptThrFxn['value'] + 13*4\n        # Store both variables\n        glob_params_list[var_bPassedEnc['name']] = var_bPassedEnc\n        glob_params_list[var_bPassedEnc_p['name']] = var_bPassedEnc_p\n    else:\n        # Set variables requires to change encpass back to original\n        pass\n\n\nre_func_encryptThrFxn_original = {\n'name': \"encryptThrFxn-original\",\n'version': \"P3X_FW_V01.07\",\n're': \"\"\"\nencryptThrFxn:\n  push\t{fp, lr}\n  add\tfp, sp, #4\n  sub\tsp, sp, #0x10\n  str\tr0, \\[fp, #-0x10\\]\n  ldr\tr0, \\[pc, #(?P<cstr_ent_query_md>[0-9a-fx]+)\\]\n  bl\t#(?P<puts>[0-9a-fx]+)\nloc_label1:\n  mov\tr0, #1\n  bl\t#(?P<Encrypt_Request>[0-9a-fx]+)\n  mov\tr3, r0\n  str\tr3, \\[fp, #-8\\]\n  ldr\tr3, \\[fp, #-8\\]\n  cmp\tr3, #0\n  bne\t#(?P<loc_label2>[0-9a-fx]+)\n  mov\tr0, #1\n  bl\t#(?P<sleep>[0-9a-fx]+)\n  b\t#(?P<loc_label1>[0-9a-fx]+)\nloc_label2:\n  ldr\tr0, \\[pc, #(?P<cstr_enc_pass>[0-9a-fx]+)\\]\n  bl\t#(?P<puts>[0-9a-fx]+)\n  sub\tsp, fp, #4\n  pop\t{fp, pc}\n\"\"\",\n'vars': {\n  'encryptThrFxn':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'startup_encrypt_check_always_pass':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.p3x_dm3xx\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"0\",\n    'custom_params_callback': startup_encrypt_check_always_pass_params_update,\n    'description': \"Set startup encryption test as passed even if it did not; 0-repeat forever on fail,1-force pass\"},\n  'cstr_ent_query_md':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_enc_pass':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'loc_label1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'puts':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sleep':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'Encrypt_Request':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n},\n}\n\nre_func_encryptThrFxn_encpass = {\n'name': \"encryptThrFxn-encpass\",\n'version': \"P3X_FW_V01.07\",\n're': \"\"\"\nencryptThrFxn:\n  push\t{fp, lr}\n  add\tfp, sp, #4\n  sub\tsp, sp, #0x10\n  str\tr0, \\[fp, #-0x10\\]\n  ldr\tr0, \\[pc, #(?P<cstr_ent_query_md>[0-9a-fx]+)\\]\n  bl\t#(?P<puts>[0-9a-fx]+)\nloc_label1:\n  mov\tr0, #1\n  bl\t#(?P<Encrypt_Request>[0-9a-fx]+)\n  mov\tr3, #1\n  ldr\tr0, \\[pc, #(?P<s_bPassedEnc>[0-9a-fx]+)\\]\n  strb\tr3, \\[r0\\]\n  cmp\tr3, #0\n  b\t#(?P<loc_label2>[0-9a-fx]+)\n  dcd\t(?P<s_bPassedEnc_p>[0-9a-fx]+)\n  bl\t#(?P<sleep>[0-9a-fx]+)\n  b\t#(?P<loc_label1>[0-9a-fx]+)\nloc_label2:\n  ldr\tr0, \\[pc, #(?P<cstr_enc_pass>[0-9a-fx]+)\\]\n  bl\t#(?P<puts>[0-9a-fx]+)\n  sub\tsp, fp, #4\n  pop\t{fp, pc}\n\"\"\",\n'vars': {\n  'encryptThrFxn':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'startup_encrypt_check_always_pass':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.p3x_dm3xx\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"1\",\n    'custom_params_callback': startup_encrypt_check_always_pass_params_update,\n    'description': \"Set startup encryption test as passed even if it did not; 0-repeat forever on fail,1-force pass\"},\n  'cstr_ent_query_md':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_enc_pass':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'loc_label1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'puts':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sleep':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'Encrypt_Request':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  's_bPassedEnc':\t\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n  's_bPassedEnc_p':\t{'type': VarType.ABSOLUTE_ADDR_TO_GLOBAL_DATA, 'variety': DataVariety.UINT32_T},\n},\n}\n\nre_func_Encrypt_Request = {\n'name': \"Encrypt_Request\",\n'version': \"P3X_FW_V01.07\",\n're': \"\"\"\nEncrypt_Request:\n  push\t{fp, lr}\n  add\tfp, sp, #4\n  sub\tsp, sp, #0x360\n  str\tr0, \\[fp, #-0x350\\]\n  sub\tr3, fp, #0x300\n  mov\tr0, r3\n  mov\tr1, #0x20\n  bl\t#(?P<GetRandomData>[0-9a-fx]+)\n  sub\tr3, fp, #0x34c\n  mov\tr0, r3\n  mov\tr1, #0\n  mov\tr2, #8\n  bl\t#(?P<memset>[0-9a-fx]+)\n  mov\tr3, #8\n  strb\tr3, \\[fp, #-0x34c\\]\n  mov\tr3, #1\n  strb\tr3, \\[fp, #-0x34b\\]\n  mov\tr3, #2\n  strb\tr3, \\[fp, #-0x34a\\]\n  mov\tr3, #0\n  strb\tr3, \\[fp, #-0x349\\]\n  mov\tr3, #0x30\n  strb\tr3, \\[fp, #-0x348\\]\n  mov\tr3, #0\n  strb\tr3, \\[fp, #-0x347\\]\n  bl\t#(?P<Enc_Serial_Get_CurSeq>[0-9a-fx]+)\n  mov\tr3, r0\n  mov\tr2, r3\n  ldr\tr3, \\[pc, #0x284\\]\n  sub\tr1, fp, #4\n  strh\tr2, \\[r1, r3\\]\n  sub\tr3, fp, #0x140\n  str\tr3, \\[fp, #-0x10\\]\n  ldr\tr2, \\[fp, #-0x10\\]\n  mov\tr3, #4\n  strb\tr3, \\[r2\\]\n  ldr\tr3, \\[fp, #-0x10\\]\n  add\tr3, r3, #1\n  str\tr3, \\[fp, #-0x10\\]\n  ldr\tr2, \\[fp, #-0x10\\]\n  mov\tr3, #8\n  strb\tr3, \\[r2\\]\n  ldr\tr3, \\[fp, #-0x10\\]\n  add\tr3, r3, #1\n  str\tr3, \\[fp, #-0x10\\]\n  sub\tr3, fp, #0x300\n  ldr\tr0, \\[fp, #-0x10\\]\n  mov\tr1, r3\n  mov\tr2, #0x20\n  bl\t#(?P<memcpy>[0-9a-fx]+)\n  ldr\tr3, \\[fp, #-0x10\\]\n  add\tr3, r3, #0x20\n  str\tr3, \\[fp, #-0x10\\]\n  ldr\tr2, \\[fp, #-0x10\\]\n  sub\tr3, fp, #0x140\n  rsb\tr3, r3, r2\n  str\tr3, \\[fp, #-0x14\\]\n  mov\tr3, #0\n  str\tr3, \\[fp, #-8\\]\n  b\t#(?P<loc_label02>[0-9a-fx]+)\n  sub\tr2, fp, #0x34c\n  sub\tr1, fp, #0x140\n  sub\tr3, fp, #0x26c\n  str\tr3, \\[sp\\]\n  sub\tr3, fp, #0x344\n  str\tr3, \\[sp, #4\\]\n  mov\tr3, #0x12c\n  str\tr3, \\[sp, #8\\]\n  mov\tr0, r2\n  ldr\tr2, \\[fp, #-0x14\\]\n  mov\tr3, #0x3e8\n  bl\t#(?P<Enc_Serial_SendWaitAck>[0-9a-fx]+)\n  mov\tr3, r0\n  cmp\tr3, #0\n  beq\t#(?P<loc_label03>[0-9a-fx]+)\n  ldr\tr3, \\[fp, #-8\\]\n  add\tr3, r3, #1\n  str\tr3, \\[fp, #-8\\]\n  ldr\tr2, \\[fp, #-8\\]\n  ldr\tr3, \\[fp, #-0x350\\]\n  cmp\tr2, r3\n  blo\t#(?P<loc_label01>[0-9a-fx]+)\n  ldr\tr2, \\[fp, #-8\\]\n  ldr\tr3, \\[fp, #-0x350\\]\n  cmp\tr2, r3\n  blo\t#(?P<loc_label04>[0-9a-fx]+)\n  mov\tr3, #0\n  str\tr3, \\[fp, #-0x354\\]\n  b\t#(?P<loc_label10>[0-9a-fx]+)\n  ldr\tr3, \\[fp, #-0x344\\]\n  cmp\tr3, #0x3a\n  bhi\t#(?P<loc_label05>[0-9a-fx]+)\n  mov\tr1, #0\n  str\tr1, \\[fp, #-0x354\\]\n  b\t#(?P<loc_label10>[0-9a-fx]+)\n  sub\tr3, fp, #0x26c\n  str\tr3, \\[fp, #-0x10\\]\n  ldr\tr3, \\[fp, #-0x10\\]\n  ldrb\tr3, \\[r3\\]\n  cmp\tr3, #0\n  moveq\tr3, #0\n  movne\tr3, #1\n  and\tr2, r3, #0xff\n  ldr\tr3, \\[fp, #-0x10\\]\n  add\tr3, r3, #1\n  str\tr3, \\[fp, #-0x10\\]\n  cmp\tr2, #0\n  beq\t#(?P<loc_label06>[0-9a-fx]+)\n  mov\tr3, #0\n  str\tr3, \\[fp, #-0x354\\]\n  b\t#(?P<loc_label10>[0-9a-fx]+)\n  sub\tr3, fp, #0x320\n  mov\tr0, r3\n  mov\tr1, #0x20\n  ldr\tr2, \\[pc, #(?P<cstr_fname_key>[0-9a-fx]+)\\]\n  bl\t#(?P<AesDecryptFromFile>[0-9a-fx]+)\n  mov\tr3, r0\n  cmp\tr3, #0\n  beq\t#(?P<loc_label07>[0-9a-fx]+)\n  mov\tr1, #0\n  str\tr1, \\[fp, #-0x354\\]\n  b\t#(?P<loc_label10>[0-9a-fx]+)\n  sub\tr3, fp, #0x340\n  sub\tr2, fp, #0x320\n  sub\tip, fp, #0x300\n  mov\tr0, r3\n  mov\tr1, #2\n  mov\tr3, ip\n  bl\t#(?P<CalMac>[0-9a-fx]+)\n  sub\tr3, fp, #0x340\n  mov\tr0, r3\n  ldr\tr1, \\[fp, #-0x10\\]\n  mov\tr2, #0x20\n  bl\t#(?P<memcmp>[0-9a-fx]+)\n  mov\tr3, r0\n  cmp\tr3, #0\n  beq\t#(?P<loc_label08>[0-9a-fx]+)\n  mov\tr3, #0\n  str\tr3, \\[fp, #-0x354\\]\n  b\t#(?P<loc_label10>[0-9a-fx]+)\n  ldr\tr3, \\[fp, #-0x10\\]\n  add\tr3, r3, #0x20\n  str\tr3, \\[fp, #-0x10\\]\n  sub\tr3, fp, #0x2d0\n  str\tr3, \\[fp, #-0xc\\]\n  ldr\tr0, \\[fp, #-0xc\\]\n  ldr\tr1, \\[fp, #-0x10\\]\n  mov\tr2, #0xa\n  bl\t#(?P<memcpy>[0-9a-fx]+)\n  ldr\tr3, \\[fp, #-0xc\\]\n  add\tr3, r3, #0xa\n  str\tr3, \\[fp, #-0xc\\]\n  ldr\tr3, \\[fp, #-0x10\\]\n  add\tr3, r3, #0xa\n  str\tr3, \\[fp, #-0x10\\]\n  sub\tr3, fp, #0x320\n  ldr\tr0, \\[fp, #-0xc\\]\n  mov\tr1, r3\n  mov\tr2, #0x20\n  bl\t#(?P<memcpy>[0-9a-fx]+)\n  ldr\tr3, \\[fp, #-0xc\\]\n  add\tr3, r3, #0x20\n  str\tr3, \\[fp, #-0xc\\]\n  ldr\tr2, \\[fp, #-0xc\\]\n  sub\tr3, fp, #0x2d0\n  rsb\tr3, r3, r2\n  mov\tr1, r3\n  sub\tr3, fp, #0x2d0\n  sub\tr2, fp, #0x2e0\n  mov\tr0, r3\n  bl\t#(?P<CalMD5>[0-9a-fx]+)\n  sub\tr3, fp, #0x2e0\n  mov\tr0, r3\n  ldr\tr1, \\[fp, #-0x10\\]\n  mov\tr2, #0x10\n  bl\t#(?P<memcmp>[0-9a-fx]+)\n  mov\tr3, r0\n  cmp\tr3, #0\n  beq\t#(?P<loc_label09>[0-9a-fx]+)\n  mov\tr1, #0\n  str\tr1, \\[fp, #-0x354\\]\n  b\t#(?P<loc_label10>[0-9a-fx]+)\n  ldr\tr3, \\[pc, #(?P<s_bPassedEnc>[0-9a-fx]+)\\]\n  mov\tr2, #1\n  strb\tr2, \\[r3\\]\n  mov\tr3, #1\n  str\tr3, \\[fp, #-0x354\\]\n  ldr\tr3, \\[fp, #-0x354\\]\n  mov\tr0, r3\n  sub\tsp, fp, #4\n  pop\t{fp, pc}\n\"\"\",\n'vars': {\n  'Encrypt_Request':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'cstr_fname_key':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label04':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label05':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label07':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label09':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'puts':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memset':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memcpy':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'memcmp':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sleep':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'GetRandomData':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'Enc_Serial_Get_CurSeq':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'Enc_Serial_SendWaitAck':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'AesDecryptFromFile':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'CalMac':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'CalMD5':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  's_bPassedEnc':\t\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT32_T},\n},\n}\n\nre_general_list = [\n  {'sect': \".text\", 'func': re_func_encryptThrFxn_original,},\n  {'sect': \".text\", 'func': re_func_encryptThrFxn_encpass,},\n  {'sect': \".text\", 'func': re_func_Encrypt_Request,},\n]\n\n\ndef armfw_elf_dm3xxvals_list(po, elffh):\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    # print list of parameter values\n    armfw_elf_paramvals_export_simple_list(po, params_list, sys.stdout)\n\n\ndef armfw_elf_dm3xxvals_mapfile(po, elffh):\n    _, params_list, elf_sections, _, _, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    armfw_elf_paramvals_export_mapfile(po, params_list, elf_sections, asm_arch, sys.stdout)\n\n\ndef armfw_elf_dm3xxvals_extract(po, elffh):\n    \"\"\" Extracts all values from firmware to JSON format text file.\n    \"\"\"\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    if len(params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    if not po.dry_run:\n        valfile = open(po.valfile, \"w\")\n    else:\n        valfile = io.StringIO()\n    armfw_elf_paramvals_export_json(po, params_list, valfile)\n    valfile.close()\n\n\ndef armfw_elf_dm3xxvals_update(po, elffh):\n    \"\"\" Updates all hardcoded values in firmware from JSON format text file.\n    \"\"\"\n    pub_params_list, glob_params_list, elf_sections, cs, elfobj, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'arm')\n    if len(pub_params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    with open(po.valfile) as valfile:\n        nxparams_list = json.load(valfile)\n    # Change section data buffers to bytearrays, so we can change them easily\n    for section_name, section in elf_sections.items():\n        section['data'] = bytearray(section['data'])\n    update_count = armfw_elf_paramvals_update_list(po, asm_arch, re_general_list, pub_params_list, glob_params_list, elf_sections, nxparams_list)\n    if (po.verbose > 0):\n        print(\"{:s}: Updated {:d} out of {:d} hardcoded values\"\n          .format(po.elffile,update_count,len(pub_params_list)))\n    # Now update the ELF file\n    for section_name, section in elf_sections.items():\n        elfsect = elfobj.get_section_by_name(section_name)\n        elfsect.set_data(section['data'])\n        elfobj.set_section_by_name(section_name, elfsect)\n    if not po.dry_run:\n        elfobj.write_changes()\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-e', '--elffile', type=str, required=True,\n          help=\"Input ELF firmware file name\")\n\n    parser.add_argument('-o', '--valfile', type=str,\n          help=\"Values list JSON file name\")\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"Do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"Increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('-l', '--list', action='store_true',\n          help=\"list values stored in the firmware\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"Extract values to infos json text file\")\n\n    subparser.add_argument('-u', '--update', action='store_true',\n          help=\"Update values in binary fw from infos text file\")\n\n    subparser.add_argument('-d', '--objdump', action='store_true',\n          help=\"display asm like slightly primitive objdump\")\n\n    subparser.add_argument('--mapfile', action='store_true',\n          help=\"export known symbols to map file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"Display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.basename = os.path.splitext(os.path.basename(po.elffile))[0]\n\n    if len(po.elffile) > 0 and (po.valfile is None or len(po.valfile) == 0):\n        po.valfile = po.basename + \".json\"\n\n    if po.objdump:\n        if (po.verbose > 0):\n            print(\"{}: Opening for objdump\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_generic_objdump(po, elffh)\n\n    elif po.list:\n        if (po.verbose > 0):\n            print(\"{}: Opening for list\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_dm3xxvals_list(po, elffh)\n\n    elif po.mapfile:\n        if (po.verbose > 0):\n            print(\"{}: Opening for mapfile generation\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_dm3xxvals_mapfile(po, elffh)\n\n    elif po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extract\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_dm3xxvals_extract(po, elffh)\n\n    elif po.update:\n        if (po.verbose > 0):\n            print(\"{}: Opening for update\".format(po.elffile))\n        with open(po.elffile, 'r+b') as elffh:\n            armfw_elf_dm3xxvals_update(po, elffh)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "lightbridge_stm32_hardcoder.py",
          "type": "blob",
          "size": 238.5,
          "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\" Dji Lightbridge STM32 micro-controller binary hard-coded values editor.\n\nThe tool can parse Lightbridge MCU firmware converted to ELF.\nIt finds certain hard-coded values in the binary data, and allows\nexporting or importing them.\n\nOnly 'setValue' element in the exported file is really changeable,\nall the other data is just informational. This includes `maxValue` and\n`minValue` - they don't do anything and changing them in the JSON file\nwill not influence update operation.\n\nExported values:\n\nog_hardcoded.lightbridge_stm32.packet_received_attenuation_override -\n\n  Allows to override attenuation value in an incomming packet command.\n  The firmware allows to set attenuation via DUML packet received from\n  another module of the drone, or RC. This parameter allows to replace\n  the value set by that packet with a constant number. Value of `0` means\n  the attenuation setting from packet should work as it originally does,\n  value of `1` will set the attenuation to `packet_received_attenuation_value`\n  and the value received in packet will be ignored.\n\nog_hardcoded.lightbridge_stm32.packet_received_attenuation_value -\n\n  Used as attenuation value when `packet_received_attenuation_override` is\n  set to `1`. The value is not scaled to board variant - which means specific\n  attenuation can mean different values of output power, depending on OFDM\n  board used. Increasing attenuation by 1 changes the output signal strength\n  by either -1 dBm or -0.25 dBm, depending on board variant. If override\n  function is disabled, this value has no effect.\n\nog_hardcoded.lightbridge_stm32.board_ad4_attenuation_tx?_* -\n\n  Sets attenuation value for `tx1` or `tx2` for either `fcc` or `ce` region.\n  Used on `ad4` OFDM board variant only.\n\n  There are several variants of OFDM boards supported by the firmware.\n  Each of these boards has different power output, so different attenuation\n  values are set to keep the power level in bound of CE or FCC regulations.\n  The values with `ad4` in name means board variant 4 with Analog Devices\n  transciever.\n\n  That chip is a double transciever, hence attenuation can be set for both\n  channels - `tx1` and `tx2`. Each of the channels is used to send and receive\n  data through one antenna within the drone. There are four antennas, and only\n  two are used at a specific time. The drone switches used antennas\n  automatically when a need arises. There are minor differences in default\n  attenuation values between channels; these are due to specifics of high\n  frequency signal progagation through the circuit board.\n\nog_hardcoded.lightbridge_stm32.board_ad5_attenuation_tx?_* -\n\n  Sets attenuation value for `tx1` or `tx2` for either `fcc` or `ce` region.\n  Used on `ad5` OFDM board variant only.\n\n  Look at previous values descriptions for detailed explanation.\n  The values with `ad5` in name means board variant 5 with Analog Devices\n  transciever.\n\nog_hardcoded.lightbridge_stm32.board_ar6_attenuation_tx?_* -\n\n  Sets attenuation value for `tx1` or `tx2` for either `fcc` or `ce` region.\n  Used on `ar6` OFDM board variant only.\n\n  Look at previous values descriptions for detailed explanation.\n  The values with `ar6` in name means board variant 6 with Artosyn AR8003\n  transciever.\n\nog_hardcoded.lightbridge_stm32.board_ar7_attenuation_tx?_* -\n\n  Sets attenuation value for `tx1` or `tx2` for either `fcc` or `ce` region.\n  Used on `ar7` OFDM board variant only.\n\n  Look at previous values descriptions for detailed explanation.\n  The values with `ar7` in name means board variant 7 with Artosyn AR8003\n  transciever.\n\nog_hardcoded.lightbridge_stm32.board_ad2_attenuation_tx?_* -\n\n  Sets attenuation value for `tx1` or `tx2` for either `fcc` or `ce` region.\n  Used on `ad2` OFDM board variant only.\n\n  Look at previous values descriptions for detailed explanation.\n  The values with `ad2` in name means board variant 2 with Analog Devices\n  transciever.\n\nog_hardcoded.lightbridge_stm32.power_zone_selection_override -\n\n  The C1 firmware within Remote Controller is responsinble for selecting\n  either FCC or CE power zone for both the RC and the drone. Selection is\n  made when the GPS coordinates are stable - then they are compared to\n  list of areas where FCC compliant power levels can be used. This causes\n  a flag to be set within a block of config data shared between RC and the\n  drone.\n\n  This value allows changing the behavior when power zone is about to be\n  selected from geo coordinates. Value of `0` means the value based on\n  GPS location will be stored in shared config block. Value of `1` will\n  cause the stored flag to be overriden and always set to a value which\n  corresponds to FCC power zone.\n\n\"\"\"\n\n# Copyright (C) 2016,2017 Mefistotelis <mefistotelis@gmail.com>\n# Copyright (C) 2018 Original Gangsters <https://dji-rev.slack.com/>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n__version__ = \"0.0.2\"\n__author__ = \"Mefistotelis @ Original Gangsters\"\n__license__ = \"GPL\"\n\nimport sys\nimport argparse\nimport os\nimport re\nimport io\nimport json\n\nfrom ctypes import c_char, c_int, c_ubyte, c_ushort, c_uint, c_ulonglong, c_float\nfrom ctypes import memmove, addressof, sizeof, Array, LittleEndianStructure\n\nsys.path.insert(0, './')\nfrom amba_sys_hardcoder import eprint, elf_march_to_asm_config, \\\n  armfw_elf_whole_section_search, armfw_elf_match_to_public_values, \\\n  armfw_elf_paramvals_extract_list, armfw_elf_get_value_update_bytes, \\\n  armfw_elf_paramvals_get_depend_list, armfw_elf_publicval_update, \\\n  armfw_elf_paramvals_update_list, armfw_elf_generic_objdump, \\\n  armfw_asm_search_strings_to_re_list, armfw_elf_paramvals_export_json, \\\n  armfw_elf_paramvals_export_simple_list, armfw_elf_paramvals_export_mapfile, \\\n  VarType, DataVariety, CodeVariety\n\n\ndef packet_received_attenuation_override_update(asm_arch, elf_sections, re_list, glob_params_list, var_info, new_var_nativ):\n    \"\"\" Callback function to prepare 'packet_received_attenuation_override_update' value change.\n    Changes variable type as required for the switch.\n    \"\"\"\n    glob_re = glob_params_list[var_info['cfunc_name']+'..re']['value']\n    glob_re_size = glob_params_list[var_info['cfunc_name']+'..re_size']['value']\n    # Multi-version support - get patterns for current version\n    if var_info['cfunc_ver'] == re_func_cmd_exec_set09_cmd12_P3X_V01_07_original['version']:\n        re_func_cmd_exec_set09_cmd12_CURR_original = re_func_cmd_exec_set09_cmd12_P3X_V01_07_original\n        re_func_cmd_exec_set09_cmd12_CURR_constatt = re_func_cmd_exec_set09_cmd12_P3X_V01_07_constatt\n    elif var_info['cfunc_ver'] == re_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_original['version']:\n        re_func_cmd_exec_set09_cmd12_CURR_original = re_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_original\n        re_func_cmd_exec_set09_cmd12_CURR_constatt = re_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_constatt\n    else:\n        raise ValueError(\"Unrecognized version of 'cmd_exec_set09_cmd12' - internal error.\")\n    # Note that the value we're modifying is not the one we got in var_info\n    var_name = 'packet_received_attenuation_value'\n    for cfunc_name in (re_func_cmd_exec_set09_cmd12_CURR_original['name'], re_func_cmd_exec_set09_cmd12_CURR_constatt['name'], ):\n        var_full_name = cfunc_name+'.'+var_name\n        if var_full_name in glob_params_list:\n            glob_var_info = glob_params_list[var_full_name]\n            break\n    if new_var_nativ == 0:\n        # Set variables requires to change constatt back to original\n        patterns = re_func_cmd_exec_set09_cmd12_CURR_original\n        re_var_info = patterns['vars'][var_name]\n        if glob_var_info['type'] != re_var_info['type']:\n            glob_var_info['type'] = re_var_info['type']\n            del glob_var_info['line']\n    else:\n        # Set variables requires to change original into constatt\n        patterns = re_func_cmd_exec_set09_cmd12_CURR_constatt\n        re_lines, re_labels = armfw_asm_search_strings_to_re_list(patterns['re'])\n        re_var_info = patterns['vars'][var_name]\n        if glob_var_info['type'] != re_var_info['type']:\n            for ln_num, ln_regex in enumerate(re_lines):\n                re_line = re.search(r'^.+P<'+var_name+'>.+$', ln_regex)\n                if re_line:\n                    glob_var_info['line'] = ln_num\n                    glob_var_info['address'] = var_info['address'] + sum(glob_re_size[0:ln_num])\n                    break\n            glob_var_info['type'] = re_var_info['type']\n\n\ndef version_string_to_int_getter(val):\n  ver = re.search(r'^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)$', val)\n  ver_major = int(ver.group(1),10)\n  ver_minor = int(ver.group(2),10)\n  ver_mmtnc = int(ver.group(3),10)\n  ver_revsn = int(ver.group(4),10)\n  return (ver_major << 24) + (ver_minor << 16) + (ver_mmtnc << 8) + (ver_revsn)\n\n\ndef version_int_to_string_getter(val):\n  if isinstance(val, str):\n      ver = int(val,10)\n  else:\n      ver = int(val)\n  ver_major = (ver >> 24) & 0xff\n  ver_minor = (ver >> 16) & 0xff\n  ver_mmtnc = (ver >>  8) & 0xff\n  ver_revsn = (ver      ) & 0xff\n  return \"{:02d}.{:02d}.{:02d}.{:02d}\".format(ver_major, ver_minor, ver_mmtnc, ver_revsn)\n\n\nre_func_cmd_exec_set09_cmd12_P3X_V01_07_original = {\n'name': \"cmd_exec_set09_cmd12-original\",\n'version': \"P3X_FW_V01.07\",\n're': \"\"\"\ncmd_exec_set09_cmd12:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), lr}\n  mov\tr5, r0\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;mov\tr6, r1\n  ;movs\tr0, #0\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;movs\tr0, #0\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,4})\n  (str|strb.w)\tr0, \\[sp\\]\n  add.w\tr4, r5, #0xb\n  bl\t#(?P<tcx_config_80105FA>[0-9a-fx]+)\n  ldrb\tr0, \\[r4\\]\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;lsrs\tr0, r0, #7\n  ;bne\t#(?P<loc_label01>[0-9a-fx]+)\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;lsls\tr0, r0, #0x18\n  ;bmi\t#(?P<loc_label01>[0-9a-fx]+)\n  ;movs\tr0, #0\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){2,4})\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  b\t#(?P<loc_label02>[0-9a-fx]+)\nloc_label01:\n  movs\tr0, #1\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  ldrb\t(?P<regB>r[0-9]), \\[r4\\]\n  and\tr0, (?P<regB>r[0-9]), #0x7f\n  bl\t#(?P<set_transciever_flag_20001A28_D>[0-9a-fx]+)\nloc_label02:\n  ldrb\t(?P<regC>r[0-9]), \\[r4, #1\\]\n  lsrs\tr0, (?P<regC>r[0-9]), #6\n  bl\t#(?P<set_transciever_flag_20001A28_A>[0-9a-fx]+)\n  ldrb\t(?P<regD>r[0-9]), \\[r4, #1\\]\n  and\tr0, (?P<regD>r[0-9]), #0x3f\n  bl\t#(?P<set_transciever_flag_20001A28_B>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #2\\]\n  bl\t#(?P<set_transciever_attenuation>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #3\\]\n  bl\t#(?P<set_transciever_flag_20001A28_C>[0-9a-fx]+)\n  movs\tr3, #1\n  mov\tr2, sp\n  mov\tr1, r5\n  ldr\tr0, \\[pc, #(?P<rel_func_packet_send>[0-9a-fx]+)\\] ; relative address to func packet_send\n  bl\t#(?P<packet_make_response>[0-9a-fx]+)\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), pc}\n\"\"\",\n'vars': {\n  'cmd_exec_set09_cmd12':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_received_attenuation_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"0\",\n    'custom_params_callback': packet_received_attenuation_override_update,\n    'description': \"What to do when received a packet with transceiver power set request; 0 - use the received attenuation value, 1 - override the value with constant one\"},\n  'packet_received_attenuation_value':\t{'type': VarType.UNUSED_DATA, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'setValue': \"40\",\n    'description': \"Constant attenuation value used when packet_received_attenuation_override is enabled; unit depends on OFDM board type\"},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,4)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regD':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  #'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'tcx_config_80105FA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_B':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_D':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_attenuation':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'rel_func_packet_send':\t\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'packet_make_response':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n},\n}\n\nre_func_cmd_exec_set09_cmd12_P3X_V01_07_constatt = {\n'name': \"cmd_exec_set09_cmd12-constatt\",\n'version': \"P3X_FW_V01.07\",\n're': \"\"\"\ncmd_exec_set09_cmd12:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), lr}\n  mov\tr5, r0\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;mov\tr6, r1\n  ;movs\tr0, #0\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;movs\tr0, #0\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,4})\n  (str|strb.w)\tr0, \\[sp\\]\n  add.w\tr4, r5, #0xb\n  bl\t#(?P<tcx_config_80105FA>[0-9a-fx]+)\n  ldrb\tr0, \\[r4\\]\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;lsrs\tr0, r0, #7\n  ;bne\t#(?P<loc_label01>[0-9a-fx]+)\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;lsls\tr0, r0, #0x18\n  ;bmi\t#(?P<loc_label01>[0-9a-fx]+)\n  ;movs\tr0, #0\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){2,4})\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  b\t#(?P<loc_label02>[0-9a-fx]+)\nloc_label01:\n  movs\tr0, #1\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  ldrb\t(?P<regB>r[0-9]), \\[r4\\]\n  and\tr0, (?P<regB>r[0-9]), #0x7f\n  bl\t#(?P<set_transciever_flag_20001A28_D>[0-9a-fx]+)\nloc_label02:\n  ldrb\t(?P<regC>r[0-9]), \\[r4, #1\\]\n  lsrs\tr0, (?P<regC>r[0-9]), #6\n  bl\t#(?P<set_transciever_flag_20001A28_A>[0-9a-fx]+)\n  ldrb\t(?P<regD>r[0-9]), \\[r4, #1\\]\n  and\tr0, (?P<regD>r[0-9]), #0x3f\n  bl\t#(?P<set_transciever_flag_20001A28_B>[0-9a-fx]+)\n  movs\tr0, #(?P<packet_received_attenuation_value>[0-9a-fx]+)\n  bl\t#(?P<set_transciever_attenuation>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #3\\]\n  bl\t#(?P<set_transciever_flag_20001A28_C>[0-9a-fx]+)\n  movs\tr3, #1\n  mov\tr2, sp\n  mov\tr1, r5\n  ldr\tr0, \\[pc, #(?P<rel_func_packet_send>[0-9a-fx]+)\\] ; relative address to func packet_send\n  bl\t#(?P<packet_make_response>[0-9a-fx]+)\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), pc}\n\"\"\",\n'vars': {\n  'cmd_exec_set09_cmd12':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_received_attenuation_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"1\",\n    'custom_params_callback': packet_received_attenuation_override_update,\n    'description': \"What to do when received a packet with transceiver power set request; 0 - use the received attenuation value, 1 - override the value with constant one\"},\n  'packet_received_attenuation_value':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\",\n    'description': \"Constant attenuation value used when packet_received_attenuation_override is enabled; unit depends on OFDM board type\"},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,4)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regD':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  #'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'tcx_config_80105FA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_B':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_D':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_attenuation':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'rel_func_packet_send':\t\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'packet_make_response':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n},\n}\n\nre_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_original = {\n'name': \"cmd_exec_set09_cmd12-original\",\n'version': \"C1_FW_V01.04-m1400\",\n're': \"\"\"\ncmd_exec_set09_cmd12:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), lr}\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;sub\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  ;mov\t(?P<regH>r[0-9]), r0\n  ;add.w\t(?P<regE>r[0-9]), r0, #0xb\n  ; in C1_FW_V01.06-m1400, the wildcard are lines:\n  ;mov\t(?P<regH>r[0-9]), r0\n  ;add.w\t(?P<regE>r[0-9]), r0, #0xb\n  ;sub\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  ;movs\tr0, #0\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;sub\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  ;mov\tr6, r0\n  ;mov\t(?P<regH>r[0-9]), r6\n  ;add.w\t(?P<regE>r[0-9]), (?P<regH>r[0-9]), #0xb\n  ;movs\tr0, #0\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){2,8})\n  bl\t#(?P<tcx_config_80105FA>[0-9a-fx]+)\n  ldrb\t(?P<regB>r[0-9]), \\[(?P<regE>r[0-9])\\]\n  (lsls|lsrs)\tr0, (?P<regB>r[0-9]), #(?P<bitshift1>[0-9a-fx]+)\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;bmi\t#(?P<loc_label01>[0-9a-fx]+)\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;cbnz\tr0, #(?P<loc_label01>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,2})\n  movs\tr0, #0\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  ; in C1_FW_V01.03-m1400, the wildcard are lines:\n  ;b\t#(?P<loc_label02>[0-9a-fx]+)\n  ;dcw\t0x0\n  ;dcd\t(?P<byte_100000A8>[0-9a-fx]+)\n  ;[...]\n  ;dcd\t(?P<word_1000000C>[0-9a-fx]+)\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;b\t#(?P<loc_label02>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_6>([0-9a-fx]+[, ]*){1,32})\nloc_label01:\n  movs\tr0, #1\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  ldrb\t(?P<regC>r[0-9]), \\[(?P<regE>r[0-9])\\]\n  and\tr0, (?P<regC>r[0-9]), #0x7f\n  bl\t#(?P<set_transciever_flag_20001A28_D>[0-9a-fx]+)\nloc_label02:\n  ldrb\t(?P<regD>r[0-9]), \\[(?P<regE>r[0-9]), #1\\]\n  and\tr0, (?P<regD>r[0-9]), #0x3f\n  bl\t#(?P<set_transciever_flag_20001A28_B>[0-9a-fx]+)\n  ldrb\tr0, \\[(?P<regE>r[0-9]), #2\\]\n  bl\t#(?P<set_transciever_attenuation>[0-9a-fx]+)\n  ldrb\tr0, \\[(?P<regE>r[0-9]), #3\\]\n  bl\t#(?P<set_transciever_flag_20001A28_C>[0-9a-fx]+)\n  ldrb\t(?P<regF>r[0-9]), \\[(?P<regH>r[0-9]), #8\\]\n  ubfx\t(?P<regI>r[0-9]), (?P<regF>r[0-9]), #5, #2\n  cmp\t(?P<regI>r[0-9]), #2\n  bne\t#(?P<loc_retlabel01>[0-9a-fx]+)\n  movs\t(?P<regG>r[0-9]), #0\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;strb.w\t(?P<regG>r[0-9]), \\[sp, #(?P<locvar_ptr_01>[0-9a-fx]+)\\]\n  ;orr\tr0, r0, #0x80\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;str\t(?P<regG>r[0-9]), \\[sp, #(?P<locvar_ptr_01>[0-9a-fx]+)\\]\n  ;ldrb\tr0, \\[(?P<regH>r[0-9]), #8\\]\n  ;bic\tr0, r0, #0x80\n  ;adds\tr0, #0x80\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){2,8})\n  strb\tr0, \\[(?P<regH>r[0-9]), #8\\]\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;mov\tr3, sp\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;add\tr3, sp, #4\n  dcw\t(?P<undefined_varlen_4>([0-9a-fx]+[, ]*){1,2})\n  movs\tr2, #1\n  add\tr1, sp, #(?P<locvar_ptr_01>[0-9a-fx]+)\n  mov\tr0, (?P<regH>r[0-9])\n  bl\t#(?P<packet_prepare_response>[0-9a-fx]+)\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;mov\tr0, sp\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;add\tr0, sp, #4\n  dcw\t(?P<undefined_varlen_5>([0-9a-fx]+[, ]*){1,2})\n  bl\t#(?P<packet_send>[0-9a-fx]+)\nloc_retlabel01:\n  add\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), pc}\n\"\"\",\n'vars': {\n  'cmd_exec_set09_cmd12':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_received_attenuation_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"0\",\n    'custom_params_callback': packet_received_attenuation_override_update,\n    'description': \"What to do when received a packet with transceiver power set request; 0 - use the received attenuation value, 1 - override the value with constant one\"},\n  'packet_received_attenuation_value':\t{'type': VarType.UNUSED_DATA, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'setValue': \"40\",\n    'description': \"Constant attenuation value used when packet_received_attenuation_override is enabled; unit depends on OFDM board type\"},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'undefined_varlen_4':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_5':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_6':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,32)},\n  'loc_frame_len':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'locvar_ptr_01':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'bitshift1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regD':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regE':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regF':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regG':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regH':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regI':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  #'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_retlabel01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'tcx_config_80105FA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_B':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_D':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_attenuation':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_send':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_prepare_response':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n},\n}\n\nre_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_constatt = {\n'name': \"cmd_exec_set09_cmd12-constatt\",\n'version': \"C1_FW_V01.04-m1400\",\n're': \"\"\"\ncmd_exec_set09_cmd12:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), lr}\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;sub\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  ;mov\t(?P<regH>r[0-9]), r0\n  ;add.w\t(?P<regE>r[0-9]), r0, #0xb\n  ; in C1_FW_V01.06-m1400, the wildcard are lines:\n  ;mov\t(?P<regH>r[0-9]), r0\n  ;add.w\t(?P<regE>r[0-9]), r0, #0xb\n  ;sub\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  ;movs\tr0, #0\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;sub\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  ;mov\tr6, r0\n  ;mov\t(?P<regH>r[0-9]), r6\n  ;add.w\t(?P<regE>r[0-9]), (?P<regH>r[0-9]), #0xb\n  ;movs\tr0, #0\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){2,8})\n  bl\t#(?P<tcx_config_80105FA>[0-9a-fx]+)\n  ldrb\t(?P<regB>r[0-9]), \\[(?P<regE>r[0-9])\\]\n  (lsls|lsrs)\tr0, (?P<regB>r[0-9]), #(?P<bitshift1>[0-9a-fx]+)\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;bmi\t#(?P<loc_label01>[0-9a-fx]+)\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;cbnz\tr0, #(?P<loc_label01>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,2})\n  movs\tr0, #0\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  ; in C1_FW_V01.03-m1400, the wildcard are lines:\n  ;b\t#(?P<loc_label02>[0-9a-fx]+)\n  ;dcw\t0x0\n  ;dcd\t(?P<byte_100000A8>[0-9a-fx]+)\n  ;[...]\n  ;dcd\t(?P<word_1000000C>[0-9a-fx]+)\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;b\t#(?P<loc_label02>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_6>([0-9a-fx]+[, ]*){1,32})\nloc_label01:\n  movs\tr0, #1\n  bl\t#(?P<set_transciever_flag_20001A28_E>[0-9a-fx]+)\n  ldrb\t(?P<regC>r[0-9]), \\[(?P<regE>r[0-9])\\]\n  and\tr0, (?P<regC>r[0-9]), #0x7f\n  bl\t#(?P<set_transciever_flag_20001A28_D>[0-9a-fx]+)\nloc_label02:\n  ldrb\t(?P<regD>r[0-9]), \\[(?P<regE>r[0-9]), #1\\]\n  and\tr0, (?P<regD>r[0-9]), #0x3f\n  bl\t#(?P<set_transciever_flag_20001A28_B>[0-9a-fx]+)\n  movs\tr0, #(?P<packet_received_attenuation_value>[0-9a-fx]+)\n  bl\t#(?P<set_transciever_attenuation>[0-9a-fx]+)\n  ldrb\tr0, \\[(?P<regE>r[0-9]), #3\\]\n  bl\t#(?P<set_transciever_flag_20001A28_C>[0-9a-fx]+)\n  ldrb\t(?P<regF>r[0-9]), \\[(?P<regH>r[0-9]), #8\\]\n  ubfx\t(?P<regI>r[0-9]), (?P<regF>r[0-9]), #5, #2\n  cmp\t(?P<regI>r[0-9]), #2\n  bne\t#(?P<loc_retlabel01>[0-9a-fx]+)\n  movs\t(?P<regG>r[0-9]), #0\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;strb.w\t(?P<regG>r[0-9]), \\[sp, #(?P<locvar_ptr_01>[0-9a-fx]+)\\]\n  ;orr\tr0, r0, #0x80\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;str\t(?P<regG>r[0-9]), \\[sp, #(?P<locvar_ptr_01>[0-9a-fx]+)\\]\n  ;ldrb\tr0, \\[(?P<regH>r[0-9]), #8\\]\n  ;bic\tr0, r0, #0x80\n  ;adds\tr0, #0x80\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){2,8})\n  strb\tr0, \\[(?P<regH>r[0-9]), #8\\]\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;mov\tr3, sp\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;add\tr3, sp, #4\n  dcw\t(?P<undefined_varlen_4>([0-9a-fx]+[, ]*){1,2})\n  movs\tr2, #1\n  add\tr1, sp, #(?P<locvar_ptr_01>[0-9a-fx]+)\n  mov\tr0, (?P<regH>r[0-9])\n  bl\t#(?P<packet_prepare_response>[0-9a-fx]+)\n  ; in C1_FW_V01.04-m1400, the wildcard are lines:\n  ;mov\tr0, sp\n  ; in C1_FW_V01.06-m1401, the wildcard are lines:\n  ;add\tr0, sp, #4\n  dcw\t(?P<undefined_varlen_5>([0-9a-fx]+[, ]*){1,2})\n  bl\t#(?P<packet_send>[0-9a-fx]+)\nloc_retlabel01:\n  add\tsp, #(?P<loc_frame_len>[0-9a-fx]+)\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){2,8}), pc}\n\"\"\",\n'vars': {\n  'cmd_exec_set09_cmd12':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_received_attenuation_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"1\",\n    'custom_params_callback': packet_received_attenuation_override_update,\n    'description': \"What to do when received a packet with transceiver power set request; 0 - use the received attenuation value, 1 - override the value with constant one\"},\n  'packet_received_attenuation_value':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\",\n    'description': \"Constant attenuation value used when packet_received_attenuation_override is enabled; unit depends on OFDM board type\"},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'undefined_varlen_4':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_5':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,2)},\n  'undefined_varlen_6':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,32)},\n  'loc_frame_len':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T},\n  'locvar_ptr_01':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.UNKNOWN},\n  'bitshift1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT8_T},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regD':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regE':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regF':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regG':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regH':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regI':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  #'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_retlabel01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'tcx_config_80105FA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_B':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_D':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_flag_20001A28_E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'set_transciever_attenuation':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_send':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_prepare_response':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n},\n}\n\nre_func_tcx_config_power_zone_P3X_V01_08 = {\n'name': \"tcx_config_power_zone\",\n'version': \"P3X_FW_V01.08\",\n# This function exists only in P3X_FW_V01.08.0080_m0900 and greater.\n# It is also not present in C1_FW. To hide warnings there, we will mark it\n# as alternative of a function which isn't really related, but it's present\n# in all C1 firmwares.\n'alt_name': \"update_tcx_power_zone_flag-.*\",\n're': \"\"\"\ntcx_config_power_zone:\n  ldr\tr1, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  push\t{r4, lr}\n  ldrb\tr2, \\[r1, #(?P<unk_var02>[0-9a-fx]+)\\]\n  cmp\tr0, r2\n  beq\t#(?P<loc_label_ret2>[0-9a-fx]+)\n  strb\tr0, \\[r1, #(?P<unk_var02>[0-9a-fx]+)\\]\n  cbz\tr0, #(?P<loc_label01>[0-9a-fx]+)\n  cmp\tr0, #1\n  bne\t#(?P<loc_label_ret2>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label09>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_label17>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label11>[0-9a-fx]+)\n  b\t#(?P<loc_label13>[0-9a-fx]+)\nloc_label01:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_board_ad4_ce>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_label03>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_board_ar6_ce>[0-9a-fx]+)\n  b\t#(?P<loc_label07>[0-9a-fx]+)\nloc_board_ad4_ce:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_ce>[0-9a-fx]+)\n  b\t#(?P<loc_board_ad_set_tx2a>[0-9a-fx]+)\nloc_label03:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_ce>[0-9a-fx]+)\nloc_board_ad_set_tx2a:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  b\t#(?P<loc_label06>[0-9a-fx]+)\nloc_board_ar6_ce:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\nloc_label06:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_label07:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_board_ar7>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  ; in P3X_FW_V01.08, wildcard data replaces one line:\n  ;bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,64})\n; Set attenuation values for board AD2 in CE zone\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_ce>[0-9a-fx]+)\n  b\t#(?P<loc_board_ad_set_tx2b>[0-9a-fx]+)\nloc_board_ar7:\n; Set attenuation values for board AR7 in CE zone\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_ce>[0-9a-fx]+)\n  b\t#(?P<loc_board_ar_set_tx2>[0-9a-fx]+)\nloc_label09:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_fcc>[0-9a-fx]+)\n  b\t#(?P<loc_label10>[0-9a-fx]+)\nloc_label17:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_fcc>[0-9a-fx]+)\nloc_label10:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  b\t#(?P<loc_label12>[0-9a-fx]+)\nloc_label11:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\nloc_label12:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_label13:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_label18>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_fcc>[0-9a-fx]+)\nloc_board_ad_set_tx2b:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\nloc_label15:\n  ; in wm330_0900_v03.01.00.01_20160422.fw_0900, the below wildcard is one line:\n  ;pop.w\t{r4, lr}\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,64})\nloc_j_ad936x_reg_sync_write:\n  b.w\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_label18:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_fcc>[0-9a-fx]+)\nloc_board_ar_set_tx2:\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  b\t#(?P<loc_label15>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{r4, pc}\n\"\"\",\n'vars': {\n  'tcx_config_power_zone':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad4_ce':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad_set_tx2a':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ar6_ce':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label07':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ar7':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label09':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label11':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label13':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label17':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label12':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad_set_tx2b':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label18':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ar_set_tx2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label15':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'unk_var01':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var02':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,64)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,64)},\n  'board_ad4_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"50\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad4_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"44\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"44\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"45\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar6_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"20\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar6_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"20\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"12\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"12\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ad2_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"44\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad2_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"45\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad4_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\",\n    'hint1': \"value of 0 means minimal attenuation and therefore max output power of the transceiver\"},\n  'board_ad4_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"5\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar6_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar6_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ad2_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad2_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"5\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar7_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"2\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"2\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n},\n}\n\n\nre_func_tcx_config_update1_P3X_V01_04 = {\n'name': \"tcx_config_update1\",\n'version': \"P3X_FW_V01.04\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  ldr\tr0, \\[pc, #(?P<ptr_ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\nloc_start:\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ptr_ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<ptr_active_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_start>[0-9a-fx]+)\n  movs\tr0, #0xe9 ; FPGA_REG_UNKN_E9\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  ; in P3X_FW_V01.04, the wildcard matches lines:\n  ;and\tr0, r0, #3\n  ;b\t#(?P<loc_800E78C>[0-9a-fx]+)\n  ;dcd\t... (x13)\n  ;loc_800E78C:\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,32})\n  cmp\tr0, #3\n  bne\t#(?P<loc_800FC36>[0-9a-fx]+)\n  movs\tr0, #0\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr0, r0, #8\n  ldr\tr1, \\[pc, #(?P<rel_fpga_reg_unkn00_value>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\n  mov\tr0, r1\n  ldrb\tr0, \\[r0\\]\n  orr\tr1, r0, #1\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ad_from_pkt_s1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ad_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<rel_fpga_reg_unkn00_value>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r0\\]\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_800FC36:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cbnz\tr0, #(?P<loc_800FD20>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_800FD20>[0-9a-fx]+)\n  movs\tr0, #0xe9 ; FPGA_REG_UNKN_E9\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr0, r0, #3\n  cmp\tr0, #3\n  bne\t#(?P<loc_800FD20>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  beq\t#(?P<loc_init_fcc>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FCD0>[0-9a-fx]+)\nloc_init_fcc:\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_800FCD0:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_800FD20:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #0x4c\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr4, r0, #1\n  mov\tr1, r4\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  cmp\tr0, #0x1a\n  beq\t#(?P<loc_state_ok>[0-9a-fx]+)\n  movs\tr0, #0x40 ; OFDM_TCX_REGISTER_ERR\n  bl\t#(?P<ofdm_tx_state_set_flag>[0-9a-fx]+)\n  bl\t#(?P<sub_800CCC8>[0-9a-fx]+)\nloc_state_ok:\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr4, r0, #0xfe\n  mov\tr1, r4\n  movs\tr0, #0\nloc_last_fpga_wr:\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_tx_state_set_flag':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800CCC8':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,32)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'ptr_ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'ptr_active_transciever_attenuation':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'active_transciever_attenuation':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_fpga_reg_unkn00_value':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_800FC36':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FCD0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FD20':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_init_fcc':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_start':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_state_ok':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad4_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\",\n    'hint1': \"value of 0 means minimal attenuation and therefore max output power of the transceiver\",\n    'hint2': \"in P3X_FW_V01.04, only one board type is suported\"},\n  'board_ad4_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad4_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"0\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad4_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"0\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n},\n}\n\nre_func_tcx_config_update1_P3X_V01_05 = {\n'name': \"tcx_config_update1\",\n'version': \"P3X_FW_V01.05\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\nloc_start:\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_start>[0-9a-fx]+)\n  movs\tr0, #0xe9 ; FPGA_REG_UNKN_E9\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr0, r0, #3\n  cmp\tr0, #3\n  bne\t#(?P<loc_800FC36>[0-9a-fx]+)\n  movs\tr0, #0\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr0, r0, #8\n  ldr\tr1, \\[pc, #(?P<rel_fpga_reg_unkn00_value>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\n  mov\tr0, r1\n  ldrb\tr0, \\[r0\\]\n  orr\tr1, r0, #1\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_not_ad_from_pkt>[0-9a-fx]+)\nloc_ad_from_pkt:\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ad_from_pkt_s1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ad_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_not_ad_from_pkt:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_ar_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_ar_from_pkt:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ar_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s2>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ar_from_pkt_s2:\n  b\t#(?P<loc_skip01>[0-9a-fx]+)\nloc_phase2_s5:\n  b\t#(?P<loc_800FC36>[0-9a-fx]+)\nloc_skip01:\n  ldr\tr0, \\[pc, #(?P<rel_fpga_reg_unkn00_value>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r0\\]\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_800FC36:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\nloc_800FC3E:\n  bne\t#(?P<loc_800FD20>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_800FD20>[0-9a-fx]+)\n  movs\tr0, #0xe9 ; FPGA_REG_UNKN_E9\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr0, r0, #3\n  cmp\tr0, #3\n  bne\t#(?P<loc_800FC3E>[0-9a-fx]+)\n\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  beq\t#(?P<loc_init_fcc>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  bne\t#(?P<loc_800FC82>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FCD0>[0-9a-fx]+)\nloc_800FC82:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  bne\t#(?P<loc_800FCA0>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FCD0>[0-9a-fx]+)\nloc_800FCA0:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  bne\t#(?P<loc_800FCD0>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar6_attenuation_fpga_ce>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_800FCD0:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_800FD02>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar7_attenuation_fpga_ce>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FDDC>[0-9a-fx]+)\nloc_800FD02:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_800FDDC>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FDDC>[0-9a-fx]+)\nloc_800FD20:\n  b\t#(?P<loc_800FDE6>[0-9a-fx]+)\nloc_init_fcc:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  bne\t#(?P<loc_800FD40>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FD8E>[0-9a-fx]+)\nloc_800FD40:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  bne\t#(?P<loc_800FD5E>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FD8E>[0-9a-fx]+)\nloc_800FD5E:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  bne\t#(?P<loc_800FD8E>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar6_attenuation_fpga_fcc>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_800FD8E:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_800FDC0>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar7_attenuation_fpga_fcc>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_fcc>[0-9a-fx]+) ; default was 0xa?\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_fcc>[0-9a-fx]+) ; default was 0xa?\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_800FDDC>[0-9a-fx]+)\nloc_800FDC0:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_800FDDC>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_800FDDC:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_800FDE6:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_byte_20001DAF>[0-9a-fx]+)\\]\n  cmp\tr0, #0xff\n  beq\t#(?P<loc_800FE4C>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_800FE08>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_800FE08>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_800FE4C>[0-9a-fx]+)\nloc_800FE08:\n  movs\tr0, #1\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\n  movs\tr0, #9 ; FPGA_REG_UNKN_09\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr0, r0, #0xf\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_byte_20001DAF>[0-9a-fx]+)\\]\n  and\tr1, r1, #0xf\n  cmp\tr0, r1\n  beq\t#(?P<loc_800FE46>[0-9a-fx]+)\n  movs\tr0, #9 ; FPGA_REG_UNKN_09\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr0, r0, #0xf0\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_byte_20001DAF>[0-9a-fx]+)\\]\n  and\tr1, r1, #0xf\n  orr.w\tr4, r0, r1\n  mov\tr1, r4\n  movs\tr0, #9 ; FPGA_REG_UNKN_09\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_800FE46:\n  movs\tr0, #2\n  bl\t#(?P<sub_800DD72>[0-9a-fx]+)\nloc_800FE4C:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #0x4c\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_20000190>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  adds\tr0, r0, #1\n  ldr\tr1, \\[pc, #(?P<dword_20000190>[0-9a-fx]+)\\]\n  str\tr0, \\[r1\\]\n  movs\tr1, #0xa\n  udiv\tr2, r0, r1\n  mls\tr0, r1, r2, r0\n  cbnz\tr0, #(?P<loc_label_ret2>[0-9a-fx]+)\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr4, r0, #1\n  mov\tr1, r4\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_st3_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_st3_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_st3_not_ad>[0-9a-fx]+)\nloc_st3_board_ad:\n  movs\tr1, #1\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  cmp\tr0, #0x1a\n  beq\t#(?P<loc_state_ok>[0-9a-fx]+)\n  movs\tr0, #0x40 ; OFDM_TCX_REGISTER_ERR\n  bl\t#(?P<ofdm_tx_state_set_flag>[0-9a-fx]+)\n  bl\t#(?P<sub_800CCC8>[0-9a-fx]+)\n  b\t#(?P<loc_state_ok>[0-9a-fx]+)\nloc_st3_not_ad:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_st3_board_ar>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_state_ok>[0-9a-fx]+)\nloc_st3_board_ar:\n  movs\tr1, #1\n  movs\tr0, #0x7c ; AR8003_REG_STATE_FLAGS\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  tst.w\tr0, #0x40\n  bne\t#(?P<loc_state_ok>[0-9a-fx]+)\n  movs\tr0, #0x40 ; OFDM_TCX_REGISTER_ERR\n  bl\t#(?P<ofdm_tx_state_set_flag>[0-9a-fx]+)\n  bl\t#(?P<sub_800CCC8>[0-9a-fx]+)\nloc_state_ok:\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr4, r0, #0xfe\n  mov\tr1, r4\n  movs\tr0, #0\n  b\t#(?P<loc_last_fpga_wr>[0-9a-fx]+)\nloc_label_ret2:\n  b\t#(?P<loc_label_ret1>[0-9a-fx]+)\nloc_last_fpga_wr:\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_tx_state_set_flag':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800DD72':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800CCC8':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'active_transciever_attenuation':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_byte_20001DAF':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_fpga_reg_unkn00_value':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'dword_20000190':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_not_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_skip01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FC36':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FC3E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FC82':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FCA0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FCD0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FD02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FD20':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FD40':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_init_fcc':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FD5E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FD8E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FDC0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FDDC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FDE6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FE08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FE46':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_800FE4C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_start':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last_fpga_wr':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_st3_board_ad':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_st3_not_ad':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_st3_board_ar':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_state_ok':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad4_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\",\n    'hint1': \"value of 0 means minimal attenuation and therefore max output power of the transceiver\",\n    'hint2': \"in P3X_FW_V01.05-V01.07, CE and FCC attenuation values are initially equal\"},\n  'board_ad4_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"5\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar6_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar6_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ad2_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad2_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"5\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar6_attenuation_fpga_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_ce\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_fpga_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_ce\", 'getter': (lambda val: val)},\n  'board_ad4_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad4_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 4 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad5_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"5\",\n    'description': \"Transceiver attenuation value for board type 5 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar6_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar6_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 6 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar7_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"10\",\n    'description': \"Transceiver attenuation value for board type 7 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ad2_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"4\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad2_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"5\",\n    'description': \"Transceiver attenuation value for board type 2 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar6_attenuation_fpga_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_fpga_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n},\n}\n\n\nre_func_tcx_config_update1_P3X_V01_08 = {\n'name': \"tcx_config_update1\",\n'version': \"P3X_FW_V01.08\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;ldr\tr4, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ; in P3X_FW_V01.11, the wildcard matches lines:\n  ;ldr\tr4, \\[pc, #(?P<unk_200019B8>[0-9a-fx]+)\\]\n  ;adds\tr4, #(?P<rel_unk_200019B8_shift>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,4})\n  ldrb.w\tr0, \\[r4, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  ldr\tr5, \\[pc, #(?P<tcx_byte_2000015C>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  movs\tr0, #0xe9 ; FPGA_REG_UNKN_E9\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  mvns\tr0, r0\n  lsls\tr0, r0, #0x1e\n  bne\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr0, r0, #8\n  strb\tr0, \\[r5, #(?P<rel_fpga_reg_unkn00_value>[0-9a-fx]+)\\]\n  orr\tr1, r0, #1\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_ar_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_ar_from_pkt>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_ad_from_pkt:\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ad_from_pkt_s1>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ad_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last4_dirct>[0-9a-fx]+)\nloc_ar_from_pkt:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s1>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_ar_from_pkt_s1:\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s2>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ar_from_pkt_s2:\n  movs\tr1, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\nloc_last4_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s4:\n  ldrb\tr1, \\[r5, #(?P<rel_fpga_reg_unkn00_value>[0-9a-fx]+)\\]\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\nloc_phase2_s5:\n  ldrb.w\tr0, \\[r4, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cbnz\tr0, #(?P<loc_phase2_j_s2>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #(?P<rel_tcx_control_attenuation_by_unkn1>[0-9a-fx]+)\\]\n  cbnz\tr0, #(?P<loc_phase2_j_s2>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_phase2_s2>[0-9a-fx]+)\n  movs\tr0, #0xe9 ; FPGA_REG_UNKN_E9\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  mvns\tr0, r0\n  lsls\tr0, r0, #0x1e\n  bne\t#(?P<loc_phase2_s2>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_ad4_dirct>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_ad5_dirct>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_ar6_dirct>[0-9a-fx]+)\n  b\t#(?P<loc_phase3_s1>[0-9a-fx]+)\nloc_ad4_dirct:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_cnup>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_cnup>[0-9a-fx]+)\n  b\t#(?P<loc_last_dirct>[0-9a-fx]+)\nloc_ad5_dirct:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_cnup>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_cnup>[0-9a-fx]+)\nloc_last_dirct:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\nloc_last2_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase3_s1:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_phase3_s3>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_ad2_dirct>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s1>[0-9a-fx]+)\nloc_phase2_j_s2:\n  b\t#(?P<loc_phase2_s2>[0-9a-fx]+)\nloc_phase3_s3:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar7_attenuation_fpga_cnup>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_cnup>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_cnup>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last3_dirct>[0-9a-fx]+)\nloc_ad2_dirct:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_cnup>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_cnup>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\nloc_last3_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s1:\n  ldr\tr0, \\[r4, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  strb\tr0, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\nloc_phase2_s2:\n  ldrb.w\tr0, \\[r4, #(?P<rel_byte_20001B23>[0-9a-fx]+)\\]\n  cmp\tr0, #0xff\n  beq\t#(?P<loc_phase4_s2>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_phase2_s3>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_phase2_s3>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_phase2_s3>[0-9a-fx]+)\n  b\t#(?P<loc_phase4_s2>[0-9a-fx]+)\nloc_ar6_dirct:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar6_attenuation_fpga_cnup>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_cnup>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_cnup>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last2_dirct>[0-9a-fx]+)\nloc_phase2_s3:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr0, #9 ; FPGA_REG_UNKN_09\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_byte_20001B23>[0-9a-fx]+)\\]\n  and\tr0, r0, #0xf\n  and\tr1, r1, #0xf\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase4_s1>[0-9a-fx]+)\n  movs\tr0, #9 ; FPGA_REG_UNKN_09\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  ; in P3X_FW_V01.11, the wildcard matches lines:\n  ;b\t#(?P<loc_skip_datablk1>[0-9a-fx]+)\n  ;dcw\t0\n  ;dcd\t(?P<data_ptr_unkn1>[0-9a-fx]+)\n  ;dcd\t(?P<data_val_unkn1>[0-9a-fx]+)\n  ;dcd\t(?P<data_val_unkn2>[0-9a-fx]+)\n  ;dcd\t(?P<data_ptr_unkn2>[0-9a-fx]+)\n  ;dcd\t(?P<data_ptr_unkn3>[0-9a-fx]+)\n  ;loc_skip_datablk1:\n  ;bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,16})\n  and\tr1, r0, #0xf0\n  ldrb.w\tr0, \\[r4, #(?P<rel_byte_20001B23>[0-9a-fx]+)\\]\n  and\tr0, r0, #0xf\n  orrs\tr1, r0\n  movs\tr0, #9 ; FPGA_REG_UNKN_09\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_phase4_s1:\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\nloc_phase4_s2:\n  ldrb.w\tr0, \\[r4, #0x6c\\]\n  cmp\tr0, #1\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;ldr\tr0, \\[r5, #(?P<rel_byte_r5p024>[0-9a-fx]+)\\]\n  ; in P3X_FW_V01.11, the wildcard matches lines:\n  ;ldrb.w\tr0, \\[r4, #(?P<rel_byte_r4p11a>[0-9a-fx]+)\\]\n  ;cmp\tr0, #0\n  ;bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ;ldr\tr0, \\[r5, #(?P<rel_byte_r5p024>[0-9a-fx]+)\\]\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){1,16})\n  movs\tr1, #0xa\n  adds\tr0, r0, #1\n  udiv\tr2, r0, r1\n  str\tr0, \\[r5, #(?P<rel_byte_r5p024>[0-9a-fx]+)\\]\n  mls\tr0, r1, r2, r0\n  cmp\tr0, #0\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr1, r0, #1\n  movs\tr0, #0\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_state_ad_check>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_state_ad_check>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_state_ad_check>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_state_ar_check>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_state_ar_check>[0-9a-fx]+)\n  b\t#(?P<loc_state_ok>[0-9a-fx]+)\nloc_state_ad_check:\n  movs\tr1, #1\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  cmp\tr0, #0x1a\n  beq\t#(?P<loc_state_ok>[0-9a-fx]+)\n  movs\tr0, #0x40 ; OFDM_TCX_REGISTER_ERR\n  bl\t#(?P<ofdm_tx_state_set_flag>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr2, r0\n  adr\tr1, #(?P<cstr_err_ad9363_reg17>[0-9a-fx]+)\n  b\t#(?P<loc_state_err>[0-9a-fx]+)\nloc_state_ar_check:\n  movs\tr1, #1\n  movs\tr0, #0x7c ; AR8003_REG_STATE_FLAGS\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  lsls\tr0, r0, #0x19\n  bmi\t#(?P<loc_state_ok>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x7c ; AR8003_REG_STATE_FLAGS\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  lsls\tr0, r0, #0x19\n  bmi\t#(?P<loc_state_ok>[0-9a-fx]+)\n  movs\tr0, #0x40 ; OFDM_TCX_REGISTER_ERR\n  bl\t#(?P<ofdm_tx_state_set_flag>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x7c ; AR8003_REG_STATE_FLAGS\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr2, r0\n  adr\tr1, #(?P<cstr_err_ar8003_reg7c>[0-9a-fx]+)\nloc_state_err:\n  movs\tr0, #3\n  bl\t#(?P<log_printf>[0-9a-fx]+)\n  bl\t#(?P<sub_800BD8A>[0-9a-fx]+)\nloc_state_ok:\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  and\tr1, r0, #0xfe\n  movs\tr0, #0\n  b.w\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_tx_state_set_flag':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'log_printf':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800BD8A':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,16)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,16)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_tcx_control_attenuation_by_unkn1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_byte_20001B23':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_fpga_reg_unkn00_value':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_byte_r5p024':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'tcx_byte_2000015C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_active_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'cstr_err_ad9363_reg17':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'cstr_err_ar8003_reg7c':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.CHAR, 'array': \"null_term\"},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last4_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad4_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad5_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last2_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase3_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_j_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase3_s3':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad2_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last3_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar6_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s3':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase4_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase4_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_state_ad_check':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_state_ar_check':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_state_err':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_state_ok':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad4_attenuation_tx1_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad4_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad4_attenuation_tx2_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad4_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ad5_attenuation_tx1_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad5_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad5_attenuation_tx2_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad5_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_tx1_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_tx2_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_tx1_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_tx2_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ad2_attenuation_tx1_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad2_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad2_attenuation_tx2_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad2_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_fpga_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_fpga_cnup':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n},\n}\n\nre_func_tcx_config_update1_C1_V01_03_m1400 = {\n'name': \"tcx_config_update1\",\n'version': \"C1_FW_V01.03-m1400\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  ldr\tr4, \\[pc, #(?P<unknown_anchor_point_01>[0-9a-fx]+)\\]\n  subs\tr4, #(?P<rel_ofdm_receiver_id>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  ldr\tr5, \\[pc, #(?P<tcx_byte_2000015C>[0-9a-fx]+)\\]\n  cbz\tr0, #(?P<loc_phase2_s5>[0-9a-fx]+)\n  ldrb.w\t(?P<regB>r[0-9]), \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\t(?P<regC>r[0-9]), \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\t(?P<regB>r[0-9]), (?P<regC>r[0-9])\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  strb\tr0, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ad_from_pkt_s1>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ad_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s4:\n  ldrb\tr2, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r4, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\nloc_phase2_s5:\n  ldrb.w\tr0, \\[r4, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cbnz\tr0, #(?P<loc_167B0>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_167B0>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  mov.w\tr2, #1\n  cmp\tr0, #0\n  bge\t#(?P<loc_16EBC>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ad3_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx2_fcc>[0-9a-fx]+)\n  b\t#(?P<loc_last_dirct>[0-9a-fx]+)\nloc_16EBC:\n  movs\tr1, #(?P<board_ad3_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx2_ce>[0-9a-fx]+)\nloc_last_dirct:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  strb\tr0, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\nloc_167B0:\n  ldrb.w\tr0, \\[r4, #0x64\\]\n  cmp\tr0, #0xff\n  beq\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #9\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r4, #0x64\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_167E2>[0-9a-fx]+)\n  ldrb.w\tr2, \\[r4, #0x64\\]\n  movs\tr1, #9\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_167E2:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  movs\tr0, #2\n  b.w\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'unknown_anchor_point_01':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_ofdm_receiver_id':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_fpga_reg_unkn15_value':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'tcx_byte_2000015C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_active_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_167B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_167E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EBC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad3_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n},\n}\n\nre_func_tcx_config_update1_C1_V01_04_m1400 = {\n'name': \"tcx_config_update1\",\n'version': \"C1_FW_V01.05-m1400\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  ldr\tr6, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r6, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  ldr\tr5, \\[pc, #(?P<tcx_byte_2000015C>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  ldrb.w\t(?P<regB>r[0-9]), \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\t(?P<regC>r[0-9]), \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\t(?P<regB>r[0-9]), (?P<regC>r[0-9])\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  strb\tr0, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_ar_from_pkt>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_ad_from_pkt:\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ad_from_pkt_s1>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ad_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last4_dirct>[0-9a-fx]+)\nloc_ar_from_pkt:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  ldrb.w\tr2, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s2>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ar_from_pkt_s2:\n  movs\tr1, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\nloc_last4_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s4:\n  ldrb\tr2, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\nloc_phase2_s5:\n  ldrb.w\tr0, \\[r6, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cbnz\tr0, #(?P<loc_j_167B0>[0-9a-fx]+)\n  ldr\tr0, \\[r6, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_167B0>[0-9a-fx]+)\n  ldr\tr4, \\[r6, #(?P<rel_dword_10004258>[0-9a-fx]+)\\]\n  cbnz\tr4, #(?P<loc_16E76>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  strb\tr0, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_16E76:\n  ldr\tr0, \\[r6, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bge\t#(?P<loc_16EBC>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_16EC4>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx2_fcc>[0-9a-fx]+)\n  b\t#(?P<loc_last_dirct>[0-9a-fx]+)\nloc_16E94:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #(?P<board_ar0_attenuation_fpga_ce>[0-9a-fx]+)\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last2_dirct>[0-9a-fx]+)\nloc_j_167B0:\n  b\t#(?P<loc_167B0>[0-9a-fx]+)\nloc_16EBC:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  beq\t#(?P<loc_16ECE>[0-9a-fx]+)\nloc_16EC4:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #0\n  beq\t#(?P<loc_16E94>[0-9a-fx]+)\n  b\t#(?P<loc_16EE2>[0-9a-fx]+)\nloc_16ECE:\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx2_ce>[0-9a-fx]+)\nloc_last_dirct:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\nloc_last2_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16EE2:\n  cbnz\tr4, #(?P<loc_phase2_s1>[0-9a-fx]+)\n  ldrb\tr2, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_phase2_s1:\n  ldr\tr0, \\[r6, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  strb\tr0, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\nloc_167B0:\n  ldrb.w\tr0, \\[r6, #0x64\\]\n  cmp\tr0, #0xff\n  beq\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #9\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #0x64\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_167E2>[0-9a-fx]+)\n  ldrb.w\tr2, \\[r6, #0x64\\]\n  movs\tr1, #9\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_167E2:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  movs\tr0, #2\n  b.w\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_10004258':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_fpga_reg_unkn15_value':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'tcx_byte_2000015C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_active_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last4_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last2_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_j_167B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_167B0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_167E2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E76':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E94':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EBC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EC4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16ECE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EE2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad3_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar0_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"17\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"17\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_fpga_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar0_attenuation_tx1_ce\", 'getter': (lambda val: val)},\n},\n}\n\n\nre_func_tcx_config_update1_C1_V01_06_m1400 = {\n'name': \"tcx_config_update1\",\n'version': \"C1_FW_V01.06-m1400\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  ldr\tr6, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r6, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  ldr\tr5, \\[pc, #(?P<tcx_byte_2000015C>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  ldrb.w\t(?P<regB>r[0-9]), \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\t(?P<regC>r[0-9]), \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\t(?P<regB>r[0-9]), (?P<regC>r[0-9])\n  beq\t#(?P<loc_phase2_s5>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  strb\tr0, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_ar_from_pkt>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_ad_from_pkt:\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ad_from_pkt_s1>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ad_from_pkt_s1:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last4_dirct>[0-9a-fx]+)\nloc_ar_from_pkt:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s1>[0-9a-fx]+)\n  ldrb.w\tr2, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_ar_from_pkt_s1:\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s2>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_ar_from_pkt_s2:\n  movs\tr1, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldrb.w\tr1, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\nloc_last4_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s4:\n  ldrb\tr2, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r6, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r5, #(?P<rel_active_transciever_attenuation>[0-9a-fx]+)\\]\nloc_phase2_s5:\n  ldrb.w\tr0, \\[r6, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldrb.w\tr0, \\[r6, #(?P<rel_tcx_control_attenuation_by_unkn1>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr0, \\[r6, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr.w\tr4, \\[r6, #(?P<rel_dword_10004258>[0-9a-fx]+)\\]\n  cbnz\tr4, #(?P<loc_16E76>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  strb\tr0, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_16E76:\n  ldr\tr0, \\[r6, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bge\t#(?P<loc_16EBC>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_16EC4>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx2_fcc>[0-9a-fx]+)\n  b\t#(?P<loc_last_dirct>[0-9a-fx]+)\nloc_16E94:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #(?P<board_ar0_attenuation_fpga_ce>[0-9a-fx]+)\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  b\t#(?P<loc_last2_dirct>[0-9a-fx]+)\nloc_16EBC:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  beq\t#(?P<loc_16ECE>[0-9a-fx]+)\nloc_16EC4:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #0\n  beq\t#(?P<loc_16E94>[0-9a-fx]+)\n  b\t#(?P<loc_16EE2>[0-9a-fx]+)\nloc_16ECE:\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad3_attenuation_tx2_ce>[0-9a-fx]+)\nloc_last_dirct:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\nloc_last2_dirct:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16EE2:\n  cbnz\tr4, #(?P<loc_phase2_s1>[0-9a-fx]+)\n  ldrb\tr2, \\[r5, #(?P<rel_fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_phase2_s1:\n  ldr\tr0, \\[r6, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  strb\tr0, \\[r5, #(?P<rel_transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'rel_dword_10004258':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_tcx_control_attenuation_by_unkn1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_fpga_reg_unkn15_value':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'tcx_byte_2000015C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_active_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ad_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last4_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_last2_dirct':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E76':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E94':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EBC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EC4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16ECE':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16EE2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad3_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad3_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar0_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"17\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"63\", 'defaultValue': \"17\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_fpga_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar0_attenuation_tx1_ce\", 'getter': (lambda val: val)},\n},\n}\n\nre_func_tcx_config_update1_C1_V01_05_m1401 = {\n'name': \"tcx_config_update1\",\n'version': \"C1_FW_V01.05-m1401\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  movs\tr4, #0\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_16DA2>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_16DA2>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\n  mov\tr0, r1\n  ldrb\tr0, \\[r0\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_16D16>[0-9a-fx]+)\nloc_ad_from_pkt:\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_16CF4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16CF4:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_16D16:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_phase2_s4>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr2, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_16D68>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16D68:\n  movs\tr1, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s4:\n  ldr\tr0, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_16DA2:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bne\t#(?P<loc_14D58>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_14D5E>[0-9a-fx]+)\n  bl\t#(?P<tx_sub_16A5C>[0-9a-fx]+)\n  mov\tr4, r0\n  cbnz\tr4, #(?P<loc_16DE8>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\n  mov\tr0, r1\n  ldrb\tr0, \\[r0\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_16DE8:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  cbz\tr0, #(?P<loc_16E0E>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_board_ad1_fcc>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_board_ar0_fcc>[0-9a-fx]+)\nloc_board_ad1_fcc:\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_14D42>[0-9a-fx]+)\nloc_board_ar0_fcc:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_14D10>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #(?P<board_ar0_attenuation_fpga_fcc>[0-9a-fx]+)\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_14D42>[0-9a-fx]+)\nloc_16E0E:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_board_ad1_ce>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_board_ar0_ce>[0-9a-fx]+)\nloc_board_ad1_ce:\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_14D10:\n  b\t#(?P<loc_14D42>[0-9a-fx]+)\nloc_board_ar0_ce:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_14D42>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #(?P<board_ar0_attenuation_fpga_ce>[0-9a-fx]+)\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ar0_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_14D42:\n  cbnz\tr4, #(?P<loc_phase2_s1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_phase2_s1:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  b\t#(?P<loc_14D5A>[0-9a-fx]+)\nloc_14D58:\n  b\t#(?P<loc_14D5E>[0-9a-fx]+)\nloc_14D5A:\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_14D5E:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tx_byte_20033B4>[0-9a-fx]+)\\]\n  cmp\tr0, #0xff\n  beq\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_14D78>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\nloc_14D78:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #9\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_tx_byte_20033B4>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_14D9E>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr2, \\[r0, #(?P<rel_tx_byte_20033B4>[0-9a-fx]+)\\]\n  movs\tr1, #9\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_14D9E:\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_16A5C':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_tx_byte_20033B4':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'fpga_reg_unkn15_value':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'active_transciever_attenuation':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad1_fcc':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ar0_fcc':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad1_ce':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ar0_ce':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D42':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D58':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D5A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D5E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D78':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_14D9E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16CF4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16DA2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16D16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16D68':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16DE8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E0E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad1_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 1 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad1_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 1 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad1_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 1 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad1_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 1 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ar0_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"6\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"6\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_fpga_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar0_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar0_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"17\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"17\",\n    'description': \"Transceiver attenuation value for board type 0 with Artosyn chip, change by 1 means 1 dBm\"},\n  'board_ar0_attenuation_fpga_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar0_attenuation_tx1_ce\", 'getter': (lambda val: val)},\n},\n}\n\nre_func_tcx_config_update1_C1_V01_06_m1401 = {\n'name': \"tcx_config_update1\",\n'version': \"C1_FW_V01.06-m1401\",\n're': \"\"\"\ntcx_config_update1:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), lr}\n  movs\tr4, #0\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  beq\t#(?P<loc_16D98>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_16DA2>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\n  mov\tr0, r1\n  ldrb\tr0, \\[r0\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  beq\t#(?P<loc_ad_from_pkt>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  bne\t#(?P<loc_16D16>[0-9a-fx]+)\nloc_ad_from_pkt:\n  movs\tr1, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_16CF4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16CF4:\n  movs\tr1, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_phase2_s4>[0-9a-fx]+)\nloc_16D16:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_phase2_s4>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_ar_from_pkt_s1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr2, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr1, #0xce ; FPGA_REG_UNKN_CE\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_ar_from_pkt_s1:\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_16D68>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16D68:\n  movs\tr1, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r1, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  cmp\tr0, r1\n  beq\t#(?P<loc_phase2_s4>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr1, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  movs\tr2, #1\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_phase2_s4:\n  ldr\tr0, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  b\t#(?P<loc_16D9A>[0-9a-fx]+)\nloc_16D98:\n  b\t#(?P<loc_16DA2>[0-9a-fx]+)\nloc_16D9A:\n  ldrb.w\tr0, \\[r0, #(?P<rel_transciever_attenuation>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<active_transciever_attenuation>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_16DA2:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_packet>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldrb.w\tr0, \\[r0, #(?P<rel_tcx_control_attenuation_by_unkn1>[0-9a-fx]+)\\]\n  cmp\tr0, #0\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r1\\]\n  cmp.w\tr1, r0, lsr #31\n  beq\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  bl\t#(?P<tx_sub_16A5C>[0-9a-fx]+)\n  mov\tr4, r0\n  cbnz\tr4, #(?P<loc_16DE8>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0xf\n  bl\t#(?P<spi_raw_ct16_dt8_read>[0-9a-fx]+)\n  ldr\tr1, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\n  mov\tr0, r1\n  ldrb\tr0, \\[r0\\]\n  orr\tr2, r0, #1\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_16DE8:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #0xc\\]\n  lsrs\tr0, r0, #0x1f\n  cbz\tr0, #(?P<loc_16E0E>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  bne\t#(?P<loc_16E2A>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx1_fcc>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx2_fcc>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_16E2A>[0-9a-fx]+)\nloc_16E0E:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #1\n  bne\t#(?P<loc_16E2A>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx1_ce>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad1_attenuation_tx2_ce>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_16E2A:\n  cbnz\tr4, #(?P<loc_phase2_s1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<fpga_reg_unkn15_value>[0-9a-fx]+)\\]\n  ldrb\tr2, \\[r0\\]\n  movs\tr1, #0\n  movs\tr0, #0xe\n  bl\t#(?P<spi_raw_ct16_dt8_write>[0-9a-fx]+)\nloc_phase2_s1:\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  lsrs\tr0, r0, #0x1f\n  ldr\tr1, \\[pc, #(?P<transceiver_pwr_mode_unk016C>[0-9a-fx]+)\\]\n  strb\tr0, \\[r1\\]\nloc_label_ret1:\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){1,8}), pc}\n\"\"\",\n'vars': {\n  'tcx_config_update1':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_raw_ct16_dt8_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_16A5C':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_control_attenuation_by_packet':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_tcx_control_attenuation_by_unkn1':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'fpga_reg_unkn15_value':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'transceiver_pwr_mode_unk016C':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'rel_transciever_attenuation':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'active_transciever_attenuation':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'loc_ad_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_ar_from_pkt_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_phase2_s1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16CF4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16D98':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16DA2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16D16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16D68':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16D9A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16DE8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E0E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_16E2A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad1_attenuation_tx1_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad1_attenuation_tx2_fcc':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"8\",\n    'description': \"Transceiver attenuation value for board type 3 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad1_attenuation_tx1_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 1 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n  'board_ad1_attenuation_tx2_ce':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"255\", 'defaultValue': \"36\",\n    'description': \"Transceiver attenuation value for board type 1 with Analog Devices chip, change by 1 means 0.25 dBm\"},\n},\n}\n\nre_func_update_tcx_power_zone_flag_C1_V01_05_m1400_original = {\n'name': \"update_tcx_power_zone_flag-original\",\n'version': \"C1_FW_V01.05-m1400\",\n# This function is only present in C1_FW, as the air part receives\n# the value set by RC and does not detect the zone by itself.\n# Bit 31 (0x1f) of transceiver_flags_1A28 variable is POWER_ZONE_FCC.\n're': \"\"\"\nupdate_tcx_power_zone_flag:\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr([.]w)?\tr2, \\[r1, #(?P<rel_tcx_dword_33C0>[0-9a-fx]+)\\]\n  lsls\tr2, r2, #0x1f\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr2, \\[r1, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  bfi\tr2, r0, #0x1f, #1\n  str\tr2, \\[r1, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\nloc_label_ret1:\n  bx\tlr\n\"\"\",\n'vars': {\n  'power_zone_selection_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"0\",\n    'description': \"What to do when power zone is about to be selected from geo coordinates; 0 - set the value based on geolocation, 1 - override the value and set to FCC\"},\n  'update_tcx_power_zone_flag':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_dword_33C0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_update_tcx_power_zone_flag_C1_V01_05_m1400_setfcc = {\n'name': \"update_tcx_power_zone_flag-setfcc\",\n'version': \"C1_FW_V01.05-m1400\",\n're': \"\"\"\nupdate_tcx_power_zone_flag:\n  ldr\tr1, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr([.]w)?\tr2, \\[r1, #(?P<rel_tcx_dword_33C0>[0-9a-fx]+)\\]\n  lsls\tr2, r2, #0x1f\n  bne\t#(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr2, \\[r1, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  orr\tr2, r2, #0x80000000\n  str\tr2, \\[r1, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\nloc_label_ret1:\n  bx\tlr\n\"\"\",\n'vars': {\n  'power_zone_selection_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"1\",\n    'description': \"What to do when power zone is about to be selected from geo coordinates; 0 - set the value based on geolocation, 1 - override the value and set to FCC\"},\n  'update_tcx_power_zone_flag':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'rel_tcx_dword_33C0':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_update_tcx_power_zone_flag_C1_V01_05_m1401_original = {\n'name': \"update_tcx_power_zone_flag-original\",\n'version': \"C1_FW_V01.05-m1401\",\n# This function is only present in C1_FW, as the air part receives\n# the value set by RC and does not detect the zone by itself.\n# Bit 31 (0x1f) of transceiver_flags_1A28 variable is POWER_ZONE_FCC.\n're': \"\"\"\nupdate_tcx_power_zone_flag:\n  push\t{lr}\n  mov\tr1, r0\n  bl\t#(?P<get_dword_33C0>[0-9a-fx]+)\n  and\tr0, r0, #1\n  cbnz\tr0, #(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  bfi\tr0, r1, #0x1f, #1\n  ldr\tr2, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  str\tr0, \\[r2, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\nloc_label_ret1:\n  pop\t{pc}\n\"\"\",\n'vars': {\n  'power_zone_selection_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"0\",\n    'description': \"What to do when power zone is about to be selected from geo coordinates; 0 - set the value based on geolocation, 1 - override the value and set to FCC\"},\n  'update_tcx_power_zone_flag':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'get_dword_33C0':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_update_tcx_power_zone_flag_C1_V01_05_m1401_setfcc = {\n'name': \"update_tcx_power_zone_flag-setfcc\",\n'version': \"C1_FW_V01.05-m1401\",\n're': \"\"\"\nupdate_tcx_power_zone_flag:\n  push\t{lr}\n  movs\tr1, #1\n  bl\t#(?P<get_dword_33C0>[0-9a-fx]+)\n  and\tr0, r0, #1\n  cbnz\tr0, #(?P<loc_label_ret1>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\n  bfi\tr0, r1, #0x1f, #1\n  ldr\tr2, \\[pc, #(?P<ofdm_receiver_id>[0-9a-fx]+)\\]\n  str\tr0, \\[r2, #(?P<rel_transceiver_flags_1A28>[0-9a-fx]+)\\]\nloc_label_ret1:\n  pop\t{pc}\n\"\"\",\n'vars': {\n  'power_zone_selection_override':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.INT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"0\", 'maxValue': \"1\", 'defaultValue': \"0\", 'setValue': \"1\",\n    'description': \"What to do when power zone is about to be selected from geo coordinates; 0 - set the value based on geolocation, 1 - override the value and set to FCC\"},\n  'update_tcx_power_zone_flag':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_receiver_id':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'get_dword_33C0':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'rel_transceiver_flags_1A28':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\n\nre_func_init_fpga_config_C1_V01_03_m1400 = {\n'name': \"init_fpga_config\",\n'version': \"P3X_FW_V01.03-m1400\", # Before V01.04, C1 firmware was part of P3X firmware\n# This pattern does not define anything meaningful.\n# It is here only to keep init_fpga_config defined for C1_FW versions.\n're': \"\"\"\ninit_fpga_config:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), lr}\n  movs\tr5, #0\n  movw\tr6, #0x313c\n  movs\tr4, #0\n  ldr\tr7, \\[pc, #(?P<ofdm_init_list_1>[0-9a-fx]+)\\]\nloc_145A0:\n  bl\t#(?P<WDT_Feed_cond>[0-9a-fx]+)\n  cmp\tr4, r6\n  bhs\t#(?P<loc_145B2>[0-9a-fx]+)\n  adds\tr0, r7, r4\n  adds\tr4, r4, #4\n  bl\t#(?P<sub_14B18>[0-9a-fx]+)\n  b\t#(?P<loc_145A0>[0-9a-fx]+)\nloc_145B2:\n  movs\tr2, #0\n  movs\tr1, #0x29\n  movs\tr0, #0x14\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0x17\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  cmp\tr0, #0x1a\n  beq\t#(?P<loc_1460A>[0-9a-fx]+)\n  movs\tr4, #0\n  movs\tr1, #0\n  movs\tr0, #0x5e\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  and.w\tr4, r4, r0, lsr #7\n  movs\tr1, #0\n  movw\tr0, #0x247\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ubfx\tr0, r0, #1, #1\n  ands\tr4, r0\n  movs\tr1, #0\n  movw\tr0, #0x287\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ubfx\tr0, r0, #1, #1\n  tst\tr4, r0\n  beq\t#(?P<loc_1460E>[0-9a-fx]+)\n  movs\tr2, #2\n  movs\tr1, #1\n  movs\tr0, #0xe\n; The function continues\n\"\"\",\n'vars': {\n  'init_fpga_config':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_14B18':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'WDT_Feed_cond':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_init_list_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'loc_145A0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_145B2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_1460A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_1460E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_init_fpga_config_C1_V01_05_m1400 = {\n'name': \"init_fpga_config\",\n'version': \"C1_FW_V01.05-m1400\",\n# This pattern does not define anything meaningful.\n# It is here only to keep init_fpga_config defined for C1_FW versions.\n're': \"\"\"\ninit_fpga_config:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), lr}\n  movs\tr6, #0\n  ;mov\tr5, r6\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){1,8})\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ; in C1_FW_V01.06 the wildcard is for 4 lines\n  ;cbz\tr0, #(?P<loc_15836>[0-9a-fx]+)\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #1\n  ;bne\t#(?P<loc_15BBA>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,8})\nloc_15836:\n  movs\tr0, #0xa\n  bl\t#(?P<sub_15D96>[0-9a-fx]+)\n  ldr\t(r4|r0), \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  ldr\tr0, \\[(r4|r0), #(?P<unk_var02>[0-9a-fx]+)\\]\n  orr\tr0, r0, #0x800000\n  str\tr0, \\[r4, #(?P<unk_var02>[0-9a-fx]+)\\]\n  movs\tr0, #1\n  bl\t#(?P<sub_15D96>[0-9a-fx]+)\n  ldr\tr0, \\[r4, #(?P<unk_var03>[0-9a-fx]+)\\]\n  orr\tr0, r0, #0x800000\n  str\tr0, \\[r4, #(?P<unk_var03>[0-9a-fx]+)\\]\nloc_15BBA:\n  ldr.w\t(sl|r8), \\[pc, #(?P<ofdm_init_list_2>[0-9a-fx]+)\\]\n  ; in C1_FW_V01.06 the wildcard is for 4 lines\n  ;movs\tr4, #0\n  ;ldr.w\tr8, \\[pc, #(?P<ofdm_init_list_1>[0-9a-fx]+)\\]\n  ;movw\tsb, #0x91c\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){2,8})\n  ; in earlier versions, they tend to switch order\n  movw\t(r7|sb), #(0x313c|0x91c)\n  (addw|add.w)\t(fp|sl), (sl|r8), (r7|#0x91c)\nloc_15BD0:\n  bl\t#(?P<WDT_Feed_cond>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #3\n  beq\t#(?P<loc_15BEC>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_15BF6>[0-9a-fx]+)\n; The function continues\n\"\"\",\n'vars': {\n  'init_fpga_config':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_15D96':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'WDT_Feed_cond':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  #'ofdm_init_list_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'ofdm_init_list_2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,8)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'unk_var01':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var02':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'unk_var03':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_15BF6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_15BBA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_15BEC':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_init_fpga_config_C1_V01_05_m1401 = {\n'name': \"init_fpga_config\",\n'version': \"C1_FW_V01.05-m1401\",\n# This pattern does not define anything meaningful.\n# It is here only to keep init_fpga_config defined for C1_FW versions.\n're': \"\"\"\ninit_fpga_config:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), lr}\n  mov[.]w\tr8, #0\n  movs\tr7, #0\n  movs\tr5, #0\n  movs\tr6, #0\n  movs\tr4, #0\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){2,8})\nloc_15836:\n  movs\tr0, #0xa\n  bl\t#(?P<sub_15D96>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0, #(?P<unk_var02>[0-9a-fx]+)\\]\n  orr\tr1, r0, #0x400000\n  ldr\tr0, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  str\tr1, \\[r0, #(?P<unk_var02>[0-9a-fx]+)\\]\n  movs\tr0, #1\n  bl\t#(?P<sub_15D96>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  subs\tr0, #0x80\n  ldr\tr0, \\[r0, #(?P<unk_var03>[0-9a-fx]+)\\]\n  orr\tr1, r0, #0x4000000\n  ldr\tr0, \\[pc, #(?P<unk_var01>[0-9a-fx]+)\\]\n  subs\tr0, #0x80\n  str\tr1, \\[r0, #(?P<unk_var03>[0-9a-fx]+)\\]\n  movs\tr7, #0\n  b\t#(?P<loc_CF74>[0-9a-fx]+)\n  movs\tr4, #0\n  b\t#(?P<loc_CE72>[0-9a-fx]+)\n  bl\t#(?P<WDT_Feed_cond>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ; Comparison to 1 is there only for older firmwares\n  ;cmp\tr0, #1\n  ;beq\t#(?P<loc_CE3E>[0-9a-fx]+)\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #3\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,8})\n  bne\t#(?P<loc_CE50>[0-9a-fx]+)\n  movw\tr0, #0x313c\n  cmp\tr4, r0\n; The function continues\n\"\"\",\n'vars': {\n  'init_fpga_config':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_15D96':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'WDT_Feed_cond':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (2,8)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,8)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'unk_var01':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_var02':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'unk_var03':\t{'type': VarType.RELATIVE_OFFSET, 'variety': DataVariety.INT32_T},\n  'loc_CF74':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_CE72':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_CE3E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_CE50':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_init_fpga_config_P3X_V01_01 = {\n'name': \"init_fpga_config\",\n'version': \"P3X_FW_V01.01\",\n# Attenuation values were added to this function in P3X_FW_V01.05; this variant is useless, just to remove warnings\n're': \"\"\"\ninit_fpga_config:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), lr}\n  mov.w\tr8, #0\n  movs\tr7, #0\n  movs\t(r4|r5), #0\n  movs\t(r5|r6), #0\n  movs\t(r6|r4), #0\n  nop\n  b\t#(?P<loc_label35>[0-9a-fx]+)\nloc_label01:\n  movs\tr6, #0\n  b\t#(?P<loc_label08>[0-9a-fx]+)\nloc_label03:\n  movw\tr0, #0x314c ; sizeof ofdm_init_list_2\n  cmp\tr6, r0\n  blo\t#(?P<loc_label06>[0-9a-fx]+)\n  b\t#(?P<loc_label09>[0-9a-fx]+) ; end for ofdm_init_list_2\nloc_label06:\n  ldr\tr0, \\[pc, #(?P<ofdm_init_list_2>[0-9a-fx]+)\\]\n  add.w\tr8, r0, r6\n  adds\tr6, r6, #4\n  mov\tr0, r8\n  bl\t#(?P<ofdm_init_instruction>[0-9a-fx]+)\nloc_label08:\n  b\t#(?P<loc_label03>[0-9a-fx]+)\nloc_label09:\n  nop\n  movs\tr2, #0\n  movs\tr1, #0x29\n  movs\tr0, #0x14 ; AD9363_REG_ENSM_CONFIG_1\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr4, r0\n  cmp\tr4, #0x1a\n  bne\t#(?P<loc_label18>[0-9a-fx]+)\n  movs\tr0, #1\n  b\t#(?P<loc_label17>[0-9a-fx]+)\nloc_label18:\n  movs\tr0, #0\nloc_label17:\n  mov\tr5, r0\n  movs\tr1, #0\n  movs\tr0, #0x5e\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr4, r0\n  and.w\tr5, r5, r4, lsr #7\n  movs\tr1, #0\n  movw\tr0, #0x247\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\t(r4|r5), r0\n  ubfx\tr0, (r4|r5), #1, #1\n  ands\tr5, r0\n  movs\tr1, #0\n  movw\tr0, #0x287\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr4, r0\n  ubfx\tr0, r4, #1, #1\n  ands\tr5, r0\n  cbz\tr5, #(?P<loc_label34>[0-9a-fx]+)\n  movs\tr0, #0xc8\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr0, #0x20 ; FPGA_REG_UNKN_20\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tsb, r0, #0xc\n  mov\tr1, sb\n  movs\tr0, #0x20 ; FPGA_REG_UNKN_20\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #2\n  movs\tr0, #1 ; FPGA_REG_UNKN_01\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<sub_800D7B8>[0-9a-fx]+)\n  nop\n  nop\n  movs\tr0, #1\nloc_label_ret1:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), pc}\nloc_label34:\n  nop\n  nop\n  adds\tr0, r7, #1\n  uxtb\tr7, r0\nloc_label35:\n  cmp\tr7, #3 ; num of retries\n  blt\t#(?P<loc_label01>[0-9a-fx]+)\n  movs\tr0, #0\n  b\t#(?P<loc_label_ret1>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'init_fpga_config':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_init_instruction':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800D7B8':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800C1E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'ofdm_init_list_2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label09':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label17':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label18':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label34':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label35':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n},\n}\n\nre_func_init_fpga_config_P3X_V01_05 = {\n'name': \"init_fpga_config\",\n'version': \"P3X_FW_V01.05\",\n're': \"\"\"\ninit_fpga_config:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), lr}\n  mov.w\tr8, #0\n  movs\tr7, #0\n  movs\t(r5|r4), #0\n  movs\t(r6|r5), #0\n  movs\t(r4|r6), #0\n  nop\n  b\t#(?P<loc_label35>[0-9a-fx]+)\nloc_label01:\n  movs\tr4, #0\n  b\t#(?P<loc_label08>[0-9a-fx]+)\nloc_label03:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_board_check_3>[0-9a-fx]+)\nloc_board_ad:\n  movw\tr0, #0x314c ; sizeof ofdm_init_list_2\n  cmp\tr4, r0\n  blo\t#(?P<loc_label06>[0-9a-fx]+)\n  b\t#(?P<loc_label09>[0-9a-fx]+) ; end for ofdm_init_list_2\nloc_label06:\n  ldr\tr0, \\[pc, #(?P<ofdm_init_list_2>[0-9a-fx]+)\\]\n  add.w\tr8, r0, r4\n  b\t#(?P<loc_label07>[0-9a-fx]+)\nloc_board_check_3:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label05>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_label11>[0-9a-fx]+)\nloc_label05:\n  movw\tr0, #0x91c ; sizeof ofdm_init_list_3\n  cmp\tr4, r0\n  blo\t#(?P<loc_label12>[0-9a-fx]+)\n  b\t#(?P<loc_label09>[0-9a-fx]+)\nloc_label12:\n  ldr\tr0, \\[pc, #0x280\\]\n  add.w\tr8, r0, r4\n  b\t#(?P<loc_label07>[0-9a-fx]+)\nloc_label11:\n  b\t#(?P<loc_label09>[0-9a-fx]+)\nloc_label07:\n  adds\tr4, r4, #4\n  mov\tr0, r8\n  bl\t#(?P<ofdm_init_instruction>[0-9a-fx]+)\nloc_label08:\n  b\t#(?P<loc_label03>[0-9a-fx]+)\nloc_label09:\n  nop\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label10>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  bne\t#(?P<loc_board_check_9>[0-9a-fx]+)\nloc_label10:\n  ldr\tr0, \\[pc, #0x260\\]\n  ldr\tr0, \\[r0\\]\n  ldr\tr1, \\[pc, #0x260\\]\n  cmp\tr0, r1\n  bne\t#(?P<loc_board_check_9>[0-9a-fx]+)\n  movs\tr4, #0\n  b\t#(?P<loc_label31>[0-9a-fx]+)\nloc_label32:\n  cmp\tr4, #0x38 ; sizeof ofdm_init_list_1\n  blo\t#(?P<loc_label14>[0-9a-fx]+)\n  b\t#(?P<loc_label33>[0-9a-fx]+)\nloc_label14:\n  ldr\tr0, \\[pc, #(?P<ofdm_init_list_1>[0-9a-fx]+)\\]\n  add.w\tr8, r0, r4\n  adds\tr4, r4, #4\n  mov\tr0, r8\n  bl\t#(?P<ofdm_init_instruction>[0-9a-fx]+)\nloc_label31:\n  b\t#(?P<loc_label32>[0-9a-fx]+)\nloc_label33:\n  nop\nloc_board_check_9:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  bne\t#(?P<loc_board_check_8>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_board_check_6>[0-9a-fx]+)\nloc_board_check_8:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  bne\t#(?P<loc_board_check_7>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_board_check_6>[0-9a-fx]+)\nloc_board_check_7:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  bne\t#(?P<loc_board_check_6>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar6_attenuation_fpga_init>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_board_check_6:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_board_check_5>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar7_attenuation_fpga_init>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  b\t#(?P<loc_board_check_4>[0-9a-fx]+)\nloc_board_check_5:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_board_check_4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_board_check_4:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label16>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_label16>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  bne\t#(?P<loc_board_check_2>[0-9a-fx]+)\nloc_label16:\n  movs\tr2, #0\n  movs\tr1, #0x29\n  movs\tr0, #0x14 ; AD9363_REG_ENSM_CONFIG_1\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr5, r0\n  cmp\tr5, #0x1a\n  bne\t#(?P<loc_label18>[0-9a-fx]+)\n  movs\tr0, #1\n  b\t#(?P<loc_label17>[0-9a-fx]+)\nloc_label18:\n  movs\tr0, #0\nloc_label17:\n  mov\tr6, r0\n  movs\tr1, #0\n  movs\tr0, #0x5e\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr5, r0\n  and.w\tr6, r6, r5, lsr #7\n  movs\tr1, #0\n  movw\tr0, #0x247\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr5, r0\n  ubfx\tr0, r5, #1, #1\n  ands\tr6, r0\n  movs\tr1, #0\n  movw\tr0, #0x287\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr5, r0\n  ubfx\tr0, r5, #1, #1\n  ands\tr6, r0\n  b\t#(?P<loc_label20>[0-9a-fx]+)\nloc_board_check_2:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label19>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_label20>[0-9a-fx]+)\nloc_label19:\n  movs\tr2, #0\n  movs\tr1, #0xc0\n  movs\tr0, #0x42 ; AR8003_REG_UNKN_42\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #0x40\n  movs\tr0, #0x42 ; AR8003_REG_UNKN_42\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #1\n  movs\tr0, #0x2a ; AR8003_REG_UNKN_2A\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr2, #0\n  mov\tr1, r2\n  movs\tr0, #0x2a ; AR8003_REG_UNKN_2A\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr0, #0xa\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0x7c\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  mov\tr5, r0\n  ubfx\tr6, r5, #6, #1\nloc_label20:\n  cbz\tr6, #(?P<loc_label34>[0-9a-fx]+)\n  movs\tr0, #0xc8\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr0, #0x20 ; FPGA_REG_UNKN_20\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tsb, r0, #0xc\n  mov\tr1, sb\n  movs\tr0, #0x20 ; FPGA_REG_UNKN_20\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #2\n  movs\tr0, #1 ; FPGA_REG_UNKN_01\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<sub_800D7B8>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label21>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_label22>[0-9a-fx]+)\nloc_label21:\n  bl\t#(?P<sub_800D414>[0-9a-fx]+)\n  bl\t#(?P<sub_800D7B8>[0-9a-fx]+)\nloc_label22:\n  nop\n  nop\n  movs\tr0, #1\nloc_label_ret1:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), pc}\nloc_label34:\n  nop\n  nop\n  adds\tr0, r7, #1\n  uxtb\tr7, r0\nloc_label35:\n  cmp\tr7, #3 ; num of retries\n  blt.w\t#(?P<loc_label01>[0-9a-fx]+)\n  movs\tr0, #0\n  b\t#(?P<loc_label_ret1>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'init_fpga_config':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_init_instruction':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800D414':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800D7B8':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800C1E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'ofdm_init_list_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'ofdm_init_list_2':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'loc_board_check_2':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_3':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_4':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_5':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_7':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_check_9':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label05':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label07':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label09':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label11':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label12':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label14':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label17':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label18':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label19':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label20':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label21':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label22':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label31':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label32':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label33':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label34':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label35':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad4_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad4_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad4_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad4_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ad5_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad5_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad5_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad5_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ad2_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad2_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad2_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad2_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_fpga_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_fpga_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n},\n}\n\nre_func_init_fpga_config_P3X_V01_08 = {\n'name': \"init_fpga_config\",\n'version': \"P3X_FW_V01.08\",\n're': \"\"\"\ninit_fpga_config:\n  push.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), lr}\n  mov.w\tr8, #0\n  mov\tr7, r8\nloc_label01:\n  movs\tr5, #0\n  mov\tr6, r5\nloc_label02:\n  movs\tr4, #0\nloc_label03:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_board_ad>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label05>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_label05>[0-9a-fx]+)\n  b\t#(?P<loc_label07>[0-9a-fx]+)\nloc_board_ad:\n  ldr\tr0, \\[pc, #(?P<byte_8016118>[0-9a-fx]+)\\]\n  b\t#(?P<loc_label06>[0-9a-fx]+)\nloc_label05:\n  ldr\tr0, \\[pc, #(?P<byte_8016318>[0-9a-fx]+)\\]\nloc_label06:\n  add.w\tr0, r0, r6, lsl #8\n  ldrb\tr1, \\[r0, r4\\]\n  uxtb\tr0, r4\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\nloc_label07:\n  adds\tr4, r4, #1\n  cmp\tr4, #0xff\n  bls\t#(?P<loc_label03>[0-9a-fx]+)\n  adds\tr6, r6, #1\n  cmp\tr6, #2\n  blo\t#(?P<loc_label02>[0-9a-fx]+)\n  ldr\tr6, \\[pc, #0x2d0\\]\n  movw\tr4, #0x293c\n  mov.w\tsl, #0x10c\n  add.w\tsb, r6, r4\nloc_label08:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label09>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_label09>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_label09>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label10>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_label10>[0-9a-fx]+)\n  b\t#(?P<loc_label12>[0-9a-fx]+)\nloc_label09:\n  cmp\tr5, r4\n  bhs\t#(?P<loc_label12>[0-9a-fx]+)\n  adds\tr0, r6, r5\n  b\t#(?P<loc_label11>[0-9a-fx]+)\nloc_label10:\n  cmp\tr5, sl\n  bhs\t#(?P<loc_label12>[0-9a-fx]+)\n  add.w\tr0, sb, r5\nloc_label11:\n  adds\tr5, r5, #4\n  bl\t#(?P<ofdm_init_instruction>[0-9a-fx]+)\n  b\t#(?P<loc_label08>[0-9a-fx]+)\nloc_label12:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label13>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  bne\t#(?P<loc_label15>[0-9a-fx]+)\nloc_label13:\n  ldr\tr0, \\[pc, #(?P<dword_200000FC>[0-9a-fx]+)\\]\n  ldr\tr1, \\[pc, #(?P<unk_1000910>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  cmp\tr0, r1\n  bne\t#(?P<loc_label15>[0-9a-fx]+)\n  ldr\tr5, \\[pc, #(?P<ofdm_init_list_1>[0-9a-fx]+)\\]\n  movs\tr4, #0\nloc_label14:\n  adds\tr0, r5, r4\n  adds\tr4, r4, #4\n  bl\t#(?P<ofdm_init_instruction>[0-9a-fx]+)\n  cmp\tr4, #0x38\n  blo\t#(?P<loc_label14>[0-9a-fx]+)\nloc_label15:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label16>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_label16>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_label16>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label19>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_label19>[0-9a-fx]+)\n  b\t#(?P<loc_label20>[0-9a-fx]+)\nloc_label16:\n  movs\tr2, #0\n  movs\tr1, #0x29\n  movs\tr0, #0x14 ; AD9363_REG_ENSM_CONFIG_1\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0x17 ; AD9363_REG_STATE\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  cmp\tr0, #0x1a\n  beq\t#(?P<loc_label18>[0-9a-fx]+)\n  movs\tr4, #0\nloc_label17:\n  movs\tr1, #0\n  movs\tr0, #0x5e\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  and.w\tr7, r4, r0, lsr #7\n  movs\tr1, #0\n  movw\tr0, #0x247\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ubfx\tr0, r0, #1, #1\n  ands\tr7, r0\n  movs\tr1, #0\n  movw\tr0, #0x287\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ubfx\tr0, r0, #1, #1\n  ands\tr7, r0\n  b\t#(?P<loc_label20>[0-9a-fx]+)\nloc_label18:\n  movs\tr4, #1\n  b\t#(?P<loc_label17>[0-9a-fx]+)\nloc_label19:\n  movs\tr2, #0\n  movs\tr1, #0xc0\n  movs\tr0, #0x42 ; AR8003_REG_UNKN_42\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #0x40\n  movs\tr0, #0x42 ; AR8003_REG_UNKN_42\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #1\n  movs\tr0, #0x2a ; AR8003_REG_UNKN_2A\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr2, #0\n  mov\tr1, r2\n  movs\tr0, #0x2a ; AR8003_REG_UNKN_2A\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr0, #0xa\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr1, #0\n  movs\tr0, #0x7c\n  bl\t#(?P<ad936x_reg_sync_read>[0-9a-fx]+)\n  ubfx\tr7, r0, #6, #1\nloc_label20:\n  cmp\tr7, #0\n  beq\t#(?P<loc_label29>[0-9a-fx]+)\n  movs\tr0, #0xc8\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr0, #0x20 ; FPGA_REG_UNKN_20\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr1, r0, #0xc\n  movs\tr0, #0x20 ; FPGA_REG_UNKN_20\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #2\n  movs\tr0, #1 ; FPGA_REG_UNKN_01\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<sub_800D7B8>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label21>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  bne\t#(?P<loc_label22>[0-9a-fx]+)\nloc_label21:\n  bl\t#(?P<sub_800D414>[0-9a-fx]+)\n  bl\t#(?P<sub_800D7B8>[0-9a-fx]+)\nloc_label22:\n  mov.w\tr0, #0x7d0\n  bl\t#(?P<sub_800C1E4>[0-9a-fx]+)\n  movs\tr0, #0\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  orr\tr1, r0, #1\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_label23>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_label24>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_label26>[0-9a-fx]+)\n  b\t#(?P<loc_label28>[0-9a-fx]+)\nloc_label23:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad4_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad4_attenuation_tx2_init>[0-9a-fx]+)\n  b\t#(?P<loc_label25>[0-9a-fx]+)\nloc_label24:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad5_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad5_attenuation_tx2_init>[0-9a-fx]+)\nloc_label25:\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\n  b\t#(?P<loc_label27>[0-9a-fx]+)\nloc_label26:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar6_attenuation_fpga_init>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar6_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #0xf0\n  movs\tr0, #0x6a ; AR8003_REG_UNKN_6A\nloc_label27:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_label28:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_label30>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_label31>[0-9a-fx]+)\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;b\t#(?P<loc_label33>[0-9a-fx]+)\n  ;loc_label29:\n  ;b\t#(?P<loc_label34>[0-9a-fx]+)\n  ; in wm330_0900_v04.03.00.00, the wildcard matches lines:\n  ;b\t#(?P<loc_label33>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,4})\nloc_label30:\n  movs\tr0, #1\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr1, #(?P<board_ar7_attenuation_fpga_init>[0-9a-fx]+)\n  movs\tr0, #0xce ; FPGA_REG_UNKN_CE\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #2\n  bl\t#(?P<tx_sub_800D3E4>[0-9a-fx]+)\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ar7_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x54 ; AR8003_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  ;movs\tr2, #0\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;movs\tr2, #0\n  ; in wm330_0900_v04.03.00.00, the wildcard matches lines:\n  ;loc_label29:\n  ;b\t#(?P<loc_label34>[0-9a-fx]+)\n  ;movs\tr2, #0\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,4})\n  movs\tr1, #(?P<board_ar7_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x5c ; AR8003_REG_TX2_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #0xf0\n  movs\tr0, #0x6a ; AR8003_REG_UNKN_6A\n  b\t#(?P<loc_label32>[0-9a-fx]+)\nloc_label31:\n  movs\tr2, #0\n  movs\tr1, #(?P<board_ad2_attenuation_tx1_init>[0-9a-fx]+)\n  movs\tr0, #0x73 ; AD9363_REG_TX1_ATTEN_0\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\n  movs\tr2, #1\n  movs\tr1, #(?P<board_ad2_attenuation_tx2_init>[0-9a-fx]+)\n  movs\tr0, #0x75 ; AD9363_REG_TX2_ATTEN_0\nloc_label32:\n  bl\t#(?P<ad936x_reg_sync_write>[0-9a-fx]+)\nloc_label33:\n  movs\tr0, #0\n  bl\t#(?P<spi_fpga_raw_read>[0-9a-fx]+)\n  and\tr1, r0, #0xfe\n  movs\tr0, #0 ; FPGA_REG_UNKN_00\n  bl\t#(?P<spi_fpga_raw_write>[0-9a-fx]+)\n  movs\tr0, #1\nloc_label_ret1:\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,12}), pc}\nloc_label34:\n  add.w\tr0, r8, #1\n  and\tr8, r0, #0xff\n  cmp.w\tr8, #3\n  blo.w\t#(?P<loc_label01>[0-9a-fx]+)\n  movs\tr0, #0\n  b\t#(?P<loc_label_ret1>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'init_fpga_config':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ad936x_reg_sync_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_write':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'spi_fpga_raw_read':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'ofdm_init_instruction':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'tx_sub_800D3E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800D414':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800D7B8':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_800C1E4':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'byte_8016118':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'byte_8016318':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'dword_200000FC':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'unk_1000910':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'ofdm_init_list_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UNKNOWN},\n  'loc_label01':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label02':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label03':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_board_ad':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label05':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label06':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label07':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label08':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label09':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label10':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label11':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label12':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label13':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label14':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label15':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label16':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label17':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label18':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label19':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label20':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label21':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label22':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label23':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label24':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label25':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label26':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label27':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label28':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label29':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label30':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label31':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label32':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_label33':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  #'loc_label34':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_label_ret1':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'board_ad4_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad4_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad4_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad4_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ad5_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad5_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad5_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad5_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ad2_attenuation_tx1_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad2_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ad2_attenuation_tx2_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ad2_attenuation_tx2_fcc\", 'getter': (lambda val: val)},\n  'board_ar6_attenuation_fpga_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar6_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n  'board_ar7_attenuation_fpga_init':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT8_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"board_ar7_attenuation_tx1_fcc\", 'getter': (lambda val: val)},\n},\n}\n\n\nre_func_cmd_exec_set00_cmd01b_P3X_V01_04 = {\n'name': \"cmd_exec_set00_cmd01b\",\n'version': \"P3X_FW_V01.04\",\n'alt_name': \"cmd_exec_set00_cmd01\",\n're': \"\"\"\ncmd_exec_set00_cmd01b:\n  (push|push.w)\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), lr}\n  mov\tr5, r0\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;mov\tr8, r1\n  ;movs\tr7, #0\n  ;mov\tr6, r5\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;movs\tr6, #0\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){1,8})\n  add.w\tr4, (?P<regB>r[0-9]), #0xb\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;ldrb\tr0, [r4, #1]\n  ;bic\tr0, r0, #0xf0\n  ;strb\tr0, [r4, #1]\n  ;ldrb\tr0, [r4, #1]\n  ;bic\tr0, r0, #0xf\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;movs\t(?P<regC>r[0-9]), #0 ; regC is r6\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,10})\n  adds\tr0, (?P<regC>r[0-9]), #1\n  strb\tr0, \\[r4, #1\\]\n  movs\tr1, #0x10\n  adds\tr0, r4, #2\n  bl\t#(?P<sub_8012360>[0-9a-fx]+)\n  ldrb\tr0, \\[(?P<regD>r[0-9]), #5\\] ; regD is r5 or r6\n  and\tr0, r0, #0x1f\n  cmp\tr0, #9\n  bne\t#(?P<loc_8012D84>[0-9a-fx]+)\n  bl\t#(?P<sub_8012372>[0-9a-fx]+)\n  str.w\tr0, \\[r4, #0x12\\]\n  ldr\tr0, \\[pc, #(?P<lb_mcu_version_1>[0-9a-fx]+)\\]\n  str.w\tr0, \\[r4, #0x16\\]\n  ; in P3X_FW_V01.04, the wildcard matches 1 line only:\n  ;b\t#(?P<loc_8011F72>[0-9a-fx]+)\n  ; in P3X_FW_V01.07, the wildcard matches 1 line plus data block:\n  ;b\t#(?P<loc_8011F72>[0-9a-fx]+)\n  ;dcd ... (x7)\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){1,16})\nloc_8012D84:\n  ldrb\tr0, \\[r6, #5\\]\n  and\tr0, r0, #0x1f\n  cmp\tr0, #0x13\n  ; in P3X_FW_V01.04, the wildcard matches lines:\n  ;bne\t#(?P<loc_8011F72>[0-9a-fx]+)\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;bne\t#(?P<loc_8011F72>[0-9a-fx]+)\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #4\n  ;beq\t#(?P<loc_8011F5C>[0-9a-fx]+)\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #5\n  ;bne\t#(?P<loc_8012DB0>[0-9a-fx]+)\n  dcw\t(?P<undefined_varlen_4>([0-9a-fx]+[, ]*){1,16})\nloc_8011F5C:\n  ldr\tr0, \\[pc, #(?P<dword_200000F8>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[r4, #0x12\\]\n  ldr\tr0, \\[pc, #(?P<dword_200000FC>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  ; in P3X_FW_V01.04, the wildcard matches lines:\n  ;str.w\tr0, \\[r4, #0x16\\]\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;str.w\tr0, \\[r4, #0x16\\]\n  ;b\t#(?P<loc_8011F72>[0-9a-fx]+)\n  ;loc_8012DB0:\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #6\n  ;beq\t#(?P<loc_8012DC8>[0-9a-fx]+)\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #7\n  ;beq\t#(?P<loc_8012DC8>[0-9a-fx]+)\n  ;bl\t#(?P<get_board_version>[0-9a-fx]+)\n  ;cmp\tr0, #2\n  ;bne\t#(?P<loc_8011F72>[0-9a-fx]+)\n  ;loc_8012DC8:\n  ;mvn\tr0, #1\n  ;str.w\tr0, \\[r4, #0x12\\]\n  ;str.w\tr0, \\[r4, #0x16\\]\n  dcw\t(?P<undefined_varlen_5>([0-9a-fx]+[, ]*){1,24})\nloc_8011F72:\n  movs\tr0, #1\n  str.w\tr0, \\[r4, #0x1a\\]\n  strb\tr7, \\[r4\\]\n  movs\tr3, #0x1e\n  mov\tr2, r4\n  mov\tr1, r5\n  ldr\tr0, \\[pc, #(?P<packet_send>[0-9a-fx]+)\\]\n  bl\t#(?P<packet_make_response>[0-9a-fx]+)\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), pc}\n\"\"\",\n'vars': {\n  'cmd_exec_set00_cmd01b':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8012360':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8012372':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_make_response':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_send':\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regD':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,10)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,16)},\n  'undefined_varlen_4':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,16)},\n  'undefined_varlen_5':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,24)},\n  'loc_8011F5C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8011F72':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8012D84':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8012DC8':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8012DB0':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'dword_200000F8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'dword_200000FC':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'lb_mcu_version_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"mcu_firmware_version\", 'getter': version_string_to_int_getter},\n  'mcu_firmware_version':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.CHAR, 'array': 11,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"00.00.00.00\", 'maxValue': \"99.99.99.99\",\n    'depend': \"lb_mcu_version_1\", 'getter': version_int_to_string_getter, 'forceVisible': True,\n    'description': \"Firmware version number\"},\n},\n}\n\nre_func_cmd_exec_set00_cmd01b_P3X_V01_08 = {\n'name': \"cmd_exec_set00_cmd01b\",\n'version': \"P3X_FW_V01.08\",\n'alt_name': \"cmd_exec_set00_cmd01\",\n're': \"\"\"\ncmd_exec_set00_cmd01b:\n  (push|push.w)\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), lr}\n  mov\tr5, r0\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;mov\tr8, r1\n  ;movs\tr7, #0\n  ;mov\tr6, r5\n  ;add.w\tr4, (?P<regB>r[0-9]), #0xb\n  ;ldrb\tr0, [r4, #1]\n  ;bic\tr0, r0, #0xf0\n  ;strb\tr0, [r4, #1]\n  ;ldrb\tr0, [r4, #1]\n  ;bic\tr0, r0, #0xf\n  ; in P3X_FW_V01.08, the wildcard matches lines:\n  ;movs\t(?P<regC>r[0-9]), #0 ; regC is r6\n  ;add.w\tr4, (?P<regB>r[0-9]), #0xb\n  dcw\t(?P<undefined_varlen_1>([0-9a-fx]+[, ]*){3,20})\n  adds\tr0, (?P<regC>r[0-9]), #1\n  strb\tr0, \\[r4, #1\\] ; struct offset PktPayload_VersionInquiry.field_0\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;movs\tr1, #0x10\n  ; in P3X_FW_V01.11, the wildcard matches lines:\n  ;movs r7, #1\n  ;str.w r7, \\[r4, #0x1e\\] ; struct offset PktPayload_VersionInquiry.field_1E\n  ;movs\tr1, #0x10\n  dcw\t(?P<undefined_varlen_2>([0-9a-fx]+[, ]*){1,6})\n  adds\tr0, r4, #2\n  bl\t#(?P<sub_8012360>[0-9a-fx]+)\n  ldrb\tr0, \\[(?P<regD>r[0-9]), #5\\] ; regD is r5 or r6\n  and\tr0, r0, #0x1f\n  cmp\tr0, #9\n  beq\t#(?P<loc_8011F26>[0-9a-fx]+)\n  cmp\tr0, #0x13\n  beq\t#(?P<loc_8011F32>[0-9a-fx]+)\n  b\t#(?P<loc_8011F76>[0-9a-fx]+)\nloc_8011F26:\n  bl\t#(?P<sub_8012372>[0-9a-fx]+)\n  str.w\tr0, \\[r4, #0x12\\] ; struct offset PktPayload_VersionInquiry.ldr_version\n  ldr\tr0, \\[pc, #(?P<lb_mcu_version_1>[0-9a-fx]+)\\]\n  b\t#(?P<loc_8011F72>[0-9a-fx]+)\nloc_8011F32:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #4\n  beq\t#(?P<loc_8011F5C>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #5\n  beq\t#(?P<loc_8011F5C>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #6\n  beq\t#(?P<loc_8011F6A>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #7\n  beq\t#(?P<loc_8011F6A>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cmp\tr0, #2\n  beq\t#(?P<loc_8011F6A>[0-9a-fx]+)\n  b\t#(?P<loc_8011F76>[0-9a-fx]+)\nloc_8011F5C:\n  ldr\tr0, \\[pc, #(?P<dword_200000F8>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[r4, #0x12\\] ; struct offset PktPayload_VersionInquiry.ldr_version\n  ldr\tr0, \\[pc, #(?P<dword_200000FC>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  b\t#(?P<loc_8011F72>[0-9a-fx]+)\nloc_8011F6A:\n  mvn\tr0, #1\n  str.w\tr0, \\[r4, #0x12\\] ; struct offset PktPayload_VersionInquiry.ldr_version\nloc_8011F72:\n  str.w\tr0, \\[r4, #0x16\\] ; struct offset PktPayload_VersionInquiry.app_version\nloc_8011F76:\n  ; in P3X_FW_V01.07, the wildcard matches lines:\n  ;movs\tr0, #1\n  ;str.w\tr0, \\[r4, #0x1a\\]\n  ; in P3X_FW_V01.11, the wildcard matches lines:\n  ;str.w\tr0, \\[r4, #0x1a\\] ; struct offset PktPayload_VersionInquiry.field_1A\n  dcw\t(?P<undefined_varlen_3>([0-9a-fx]+[, ]*){1,4})\n  strb\tr6, \\[r4\\] ; struct offset PktPayload_VersionInquiry.field_0\n  mov\tr2, r4\n  mov\tr1, r5\n  pop.w\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), lr}\n  movs\tr3, #(?P<packet_payload_len>[0-9a-fx]+) ; payload_len is 0x1e in v01.07 and 0x22 in v01.11\n  ldr\tr0, \\[pc, #(?P<packet_send>[0-9a-fx]+)\\]\n  b.w\t#(?P<packet_make_response>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'cmd_exec_set00_cmd01b':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8012360':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_8012372':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_make_response':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_send':\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'packet_payload_len':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T,},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regB':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regC':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'regD':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'undefined_varlen_1':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (3,20)},\n  'undefined_varlen_2':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,6)},\n  'undefined_varlen_3':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.INT16_T, 'array': (1,4)},\n  'loc_8011F26':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8011F32':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8011F5C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8011F6A':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8011F72':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_8011F76':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'dword_200000F8':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'dword_200000FC':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'lb_mcu_version_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"mcu_firmware_version\", 'getter': version_string_to_int_getter},\n  'mcu_firmware_version':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.CHAR, 'array': 11,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"00.00.00.00\", 'maxValue': \"99.99.99.99\",\n    'depend': \"lb_mcu_version_1\", 'getter': version_int_to_string_getter, 'forceVisible': True,\n    'description': \"Firmware version number\"},\n},\n}\n\nre_func_cmd_exec_set00_cmd01_C1_V01_04_m1400 = {\n'name': \"cmd_exec_set00_cmd01\",\n'version': \"C1_FW_V01.04-m1400\",\n'alt_name': \"cmd_exec_set00_cmd01b\",\n're': \"\"\"\ncmd_exec_set00_cmd01:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), lr}\n  ldr\tr1, \\[pc, #(?P<dword_10007F74>[0-9a-fx]+)\\]\n  mov\tr4, r0\n  ldrb\tr0, \\[r0, #8\\]\n  ldr\tr5, \\[r1\\]\n  ubfx\tr1, r0, #5, #2\n  sub\tsp, #0x50\n  cmp\tr1, #2\n  bne\t#(?P<loc_F3B6>[0-9a-fx]+)\n  orr\tr0, r0, #0x80\n  strb\tr0, \\[r4, #8\\]\n  movs\tr6, #0\n  strb.w\tr6, \\[sp\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_0\n  ldrb.w\tr0, \\[sp, #1\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1\n  movs\tr1, #0x10\n  bic\tr0, r0, #0xf0\n  adds\tr0, #0x10\n  bic\tr0, r0, #0xf\n  strb.w\tr0, \\[sp, #1\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1\n  add.w\tr0, sp, #2 ; payload_buf + struct offset PktPayload_VersionInquiry.hw_version\n  bl\t#(?P<sub_1F904>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #5\\]\n  and\tr0, r0, #0x1f\n  cmp\tr0, #0x14\n  beq\t#(?P<loc_F346>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_10007F74>[0-9a-fx]+)\\]\n  mvns\tr1, r5\n  subs\tr0, r0, #4\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  cmp\tr0, r1\n  beq\t#(?P<loc_F368>[0-9a-fx]+)\n  str.w\tr6, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  b\t#(?P<loc_F390>[0-9a-fx]+)\nloc_F346:\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbz\tr0, #(?P<loc_F35E>[0-9a-fx]+)\n  ldr\tr0, \\[pc, #(?P<dword_10000344>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  ldr\tr0, \\[pc, #(?P<dword_10000348>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\nloc_F358:\n  str.w\tr0, \\[sp, #0x16\\] ; payload_buf + struct offset PktPayload_VersionInquiry.app_version\n  b\t#(?P<loc_F39C>[0-9a-fx]+)\nloc_F35E:\n  mvn\tr0, #1\n  str.w\tr0, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  b\t#(?P<loc_F358>[0-9a-fx]+)\nloc_F368:\n  ldr\tr0, \\[pc, #(?P<byte_10000000>[0-9a-fx]+)\\]\n  ldrb\tr1, \\[r0\\]\n  ldr\tr0, \\[pc, #(?P<byte_10000006>[0-9a-fx]+)\\]\n  cbz\tr1, #(?P<loc_F376>[0-9a-fx]+)\n  ldrb\tr1, \\[r0\\]\n  cmp\tr1, #3\n  beq\t#(?P<loc_F3BA>[0-9a-fx]+)\nloc_F376:\n  ldr\tr2, \\[pc, #(?P<byte_10000008>[0-9a-fx]+)\\]\n  ldr.w\tr1, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  ldrb\tr0, \\[r0\\]\n  ldrb\tr2, \\[r2\\]\n  and\tr1, r1, #0xff00ff\n  orr.w\tr1, r1, r2, lsl #24\n  orr.w\tr0, r1, r0, lsl #8\nloc_F38C:\n  str.w\tr0, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\nloc_F390:\n  ldr\tr0, \\[pc, #(?P<lb_mcu_version_1>[0-9a-fx]+)\\]\n  str.w\tr0, \\[sp, #0x16\\] ; payload_buf + struct offset PktPayload_VersionInquiry.app_version\n  movs\tr0, #1\n  strb.w\tr0, \\[sp, #0x1e\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1E\nloc_F39C:\n  movw\tr0, #0x243\n  str.w\tr0, \\[sp, #0x1a\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1A\n  add\tr3, sp, #0x20\n  movs\tr2, #(?P<packet_payload_len>[0-9a-fx]+) ; sizeof(PktPayload_VersionInquiry)\n  mov\tr1, sp\n  mov\tr0, r4\n  bl\t#(?P<packet_prepare_response>[0-9a-fx]+)\n  add\tr0, sp, #0x20\n  bl\t#(?P<packet_send>[0-9a-fx]+)\nloc_F3B6:\n  add\tsp, #0x50\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), pc}\nloc_F3BA:\n  ldr.w\tr0, \\[sp, #0x12\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  and\tr0, r0, #0xff00ff\n  orr\tr0, r0, #0x3000300\n  b\t#(?P<loc_F38C>[0-9a-fx]+)\n\"\"\",\n'vars': {\n  'cmd_exec_set00_cmd01':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_1F904':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_prepare_response':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_send':\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'packet_payload_len':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T,},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'loc_F346':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F358':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F35E':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F368':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F376':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F38C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F390':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F39C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F3B6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F3BA':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'dword_10007F74':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'dword_10000344':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'dword_10000348':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'byte_10000000':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT8_T},\n  'byte_10000006':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT8_T},\n  'byte_10000008':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.UINT8_T},\n  'lb_mcu_version_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"mcu_firmware_version\", 'getter': version_string_to_int_getter},\n  'mcu_firmware_version':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.CHAR, 'array': 11,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"00.00.00.00\", 'maxValue': \"99.99.99.99\",\n    'depend': \"lb_mcu_version_1\", 'getter': version_int_to_string_getter, 'forceVisible': True,\n    'description': \"Firmware version number\"},\n},\n}\n\nre_func_cmd_exec_set00_cmd01_C1_V01_04_m1401 = {\n'name': \"cmd_exec_set00_cmd01\",\n'version': \"C1_FW_V01.04-m1401\",\n'alt_name': \"cmd_exec_set00_cmd01b\",\n're': \"\"\"\ncmd_exec_set00_cmd01:\n  push\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), lr}\n  sub\tsp, #0x50\n  mov\tr5, r0\n  ldr\tr0, \\[pc, #(?P<dword_10007F74>[0-9a-fx]+)\\]\n  ldr\tr6, \\[r0\\]\n  mov\tr4, r5\n  ldrb\tr0, \\[r4, #8\\]\n  ubfx\tr0, r0, #5, #2\n  cmp\tr0, #2\n  bne\t#(?P<loc_F3B6>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #8\\]\n  bic\tr0, r0, #0x80\n  adds\tr0, #0x80\n  strb\tr0, \\[r4, #8\\]\n  movs\tr0, #0\n  strb.w\tr0, \\[sp, #0x30\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_0\n  ldrb.w\tr0, \\[sp, #0x31\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1\n  bic\tr0, r0, #0xf0\n  adds\tr0, #0x10\n  strb.w\tr0, \\[sp, #0x31\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1\n  ldrb.w\tr0, \\[sp, #0x31\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1\n  bic\tr0, r0, #0xf\n  strb.w\tr0, \\[sp, #0x31\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1\n  movs\tr1, #0x10\n  add.w\tr0, sp, #0x32 ; payload_buf + struct offset PktPayload_VersionInquiry.hw_version\n  bl\t#(?P<sub_1F904>[0-9a-fx]+)\n  ldrb\tr0, \\[r4, #5\\]\n  and\tr0, r0, #0x1f\n  cmp\tr0, #0x14\n  bne\t#(?P<loc_F376>[0-9a-fx]+)\n  bl\t#(?P<get_board_version>[0-9a-fx]+)\n  cbnz\tr0, #(?P<loc_F346>[0-9a-fx]+)\n  mvn\tr0, #1\n  str.w\tr0, \\[sp, #0x42\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  str.w\tr0, \\[sp, #0x46\\] ; payload_buf + struct offset PktPayload_VersionInquiry.app_version\n  b\t#(?P<loc_F39C>[0-9a-fx]+)\nloc_F346:\n  ldr\tr0, \\[pc, #(?P<dword_10000344>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[sp, #0x42\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  ldr\tr0, \\[pc, #(?P<dword_10000348>[0-9a-fx]+)\\]\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[sp, #0x46\\] ; payload_buf + struct offset PktPayload_VersionInquiry.app_version\n  b\t#(?P<loc_F39C>[0-9a-fx]+)\nloc_F376:\n  ldr\tr0, \\[pc, #(?P<dword_10007F74>[0-9a-fx]+)\\]\n  subs\tr0, r0, #4\n  ldr\tr0, \\[r0\\]\n  str.w\tr0, \\[sp, #0x42\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  ldr.w\tr0, \\[sp, #0x42\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\n  mvns\tr1, r6\n  cmp\tr0, r1\n  beq\t#(?P<loc_F390>[0-9a-fx]+)\n  movs\tr0, #0\n  str.w\tr0, \\[sp, #0x42\\] ; payload_buf + struct offset PktPayload_VersionInquiry.ldr_version\nloc_F390:\n  ldr\tr0, \\[pc, #(?P<lb_mcu_version_1>[0-9a-fx]+)\\]\n  str.w\tr0, \\[sp, #0x46\\] ; payload_buf + struct offset PktPayload_VersionInquiry.app_version\n  movs\tr0, #1\n  strb.w\tr0, \\[sp, #0x4e\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1E\nloc_F39C:\n  movw\tr0, #0x243\n  str.w\tr0, \\[sp, #0x4a\\] ; payload_buf + struct offset PktPayload_VersionInquiry.field_1A\n  add\tr3, sp, #4 ; local resp_pkt\n  movs\tr2, #(?P<packet_payload_len>[0-9a-fx]+) ; sizeof(PktPayload_VersionInquiry)\n  add\tr1, sp, #0x30 ; payload_buf\n  mov\tr0, r4\n  bl\t#(?P<packet_prepare_response>[0-9a-fx]+)\n  add\tr0, sp, #4 ; local resp_pkt\n  bl\t#(?P<packet_send>[0-9a-fx]+)\nloc_F3B6:\n  add\tsp, #0x50\n  pop\t{(?P<regsA>(r[0-9]+[, ]*|[a-z][a-z][, ]*){3,5}), pc}\n\"\"\",\n'vars': {\n  'cmd_exec_set00_cmd01':\t{'type': VarType.DIRECT_LINE_OF_CODE, 'variety': CodeVariety.FUNCTION},\n  'sub_1F904':\t\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'get_board_version':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_prepare_response':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.FUNCTION},\n  'packet_send':\t{'type': VarType.RELATIVE_ADDR_TO_CODE, 'baseaddr': \"PC+\", 'variety': CodeVariety.FUNCTION},\n  'packet_payload_len':\t{'type': VarType.DIRECT_INT_VALUE, 'variety': DataVariety.UINT16_T,},\n  'regsA':\t{'type': VarType.DIRECT_OPERAND, 'variety': DataVariety.UNKNOWN},\n  'loc_F346':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F376':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F390':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F39C':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'loc_F3B6':\t{'type': VarType.ABSOLUTE_ADDR_TO_CODE, 'variety': CodeVariety.CHUNK},\n  'dword_10007F74':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'dword_10000344':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'dword_10000348':\t{'type': VarType.RELATIVE_ADDR_TO_PTR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T},\n  'lb_mcu_version_1':\t{'type': VarType.RELATIVE_ADDR_TO_GLOBAL_DATA, 'baseaddr': \"PC+\", 'variety': DataVariety.INT32_T,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'depend': \"mcu_firmware_version\", 'getter': version_string_to_int_getter},\n  'mcu_firmware_version':\t{'type': VarType.DETACHED_DATA, 'variety': DataVariety.CHAR, 'array': 11,\n    'public': \"og_hardcoded.lightbridge_stm32\", 'minValue': \"00.00.00.00\", 'maxValue': \"99.99.99.99\",\n    'depend': \"lb_mcu_version_1\", 'getter': version_int_to_string_getter, 'forceVisible': True,\n    'description': \"Firmware version number\"},\n},\n}\n\n\nre_general_list = [\n  {'sect': \".text\", 'func': re_func_cmd_exec_set09_cmd12_P3X_V01_07_original,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set09_cmd12_P3X_V01_07_constatt,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_original,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set09_cmd12_C1_V01_04_m1400_constatt,},\n  {'sect': \".text\", 'func': re_func_init_fpga_config_P3X_V01_01,},\n  {'sect': \".text\", 'func': re_func_init_fpga_config_P3X_V01_05,},\n  {'sect': \".text\", 'func': re_func_init_fpga_config_P3X_V01_08,},\n  {'sect': \".text\", 'func': re_func_init_fpga_config_C1_V01_03_m1400,},\n  {'sect': \".text\", 'func': re_func_init_fpga_config_C1_V01_05_m1400,},\n  {'sect': \".text\", 'func': re_func_init_fpga_config_C1_V01_05_m1401,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_P3X_V01_04,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_P3X_V01_05,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_P3X_V01_08,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_C1_V01_03_m1400,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_C1_V01_04_m1400,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_C1_V01_06_m1400,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_C1_V01_05_m1401,},\n  {'sect': \".text\", 'func': re_func_tcx_config_update1_C1_V01_06_m1401,},\n  {'sect': \".text\", 'func': re_func_tcx_config_power_zone_P3X_V01_08,},\n  {'sect': \".text\", 'func': re_func_update_tcx_power_zone_flag_C1_V01_05_m1400_original,},\n  {'sect': \".text\", 'func': re_func_update_tcx_power_zone_flag_C1_V01_05_m1400_setfcc,},\n  {'sect': \".text\", 'func': re_func_update_tcx_power_zone_flag_C1_V01_05_m1401_original,},\n  {'sect': \".text\", 'func': re_func_update_tcx_power_zone_flag_C1_V01_05_m1401_setfcc,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set00_cmd01b_P3X_V01_04,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set00_cmd01b_P3X_V01_08,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set00_cmd01_C1_V01_04_m1400,},\n  {'sect': \".text\", 'func': re_func_cmd_exec_set00_cmd01_C1_V01_04_m1401,},\n]\n\ndef armfw_elf_lbstm32_list(po, elffh):\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    # print list of parameter values\n    armfw_elf_paramvals_export_simple_list(po, params_list, sys.stdout)\n\n\ndef armfw_elf_lbstm32_mapfile(po, elffh):\n    _, params_list, elf_sections, _, _, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    armfw_elf_paramvals_export_mapfile(po, params_list, elf_sections, asm_arch, sys.stdout)\n\n\ndef armfw_elf_lbstm32_extract(po, elffh):\n    \"\"\" Extracts all values from firmware to JSON format text file.\n    \"\"\"\n    params_list, _, _, _, _, _ = armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    if len(params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    if not po.dry_run:\n        valfile = open(po.valfile, \"w\")\n    else:\n        valfile = io.StringIO()\n    armfw_elf_paramvals_export_json(po, params_list, valfile)\n    valfile.close()\n\n\ndef armfw_elf_lbstm32_update(po, elffh):\n    \"\"\" Updates all hardcoded values in firmware from JSON format text file.\n    \"\"\"\n    pub_params_list, glob_params_list, elf_sections, cs, elfobj, asm_arch = \\\n      armfw_elf_paramvals_extract_list(po, elffh, re_general_list, 'thumb')\n    if len(pub_params_list) <= 0:\n        raise ValueError(\"No known values found in ELF file.\")\n    with open(po.valfile) as valfile:\n        nxparams_list = json.load(valfile)\n    # Change section data buffers to bytearrays, so we can change them easily\n    for section_name, section in elf_sections.items():\n        section['data'] = bytearray(section['data'])\n    update_count = armfw_elf_paramvals_update_list(po, asm_arch,\n      re_general_list, pub_params_list, glob_params_list, elf_sections, nxparams_list)\n    if (po.verbose > 0):\n        print(\"{:s}: Updated {:d} out of {:d} hardcoded values\"\n          .format(po.elffile, update_count, len(pub_params_list)))\n    # Now update the ELF file\n    for section_name, section in elf_sections.items():\n        elfsect = elfobj.get_section_by_name(section_name)\n        elfsect.set_data(section['data'])\n        elfobj.set_section_by_name(section_name, elfsect)\n    if not po.dry_run:\n        elfobj.write_changes()\n\n\ndef main():\n    \"\"\" Main executable function.\n\n    Its task is to parse command line options and call a function which performs requested command.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__doc__.split('.')[0])\n\n    parser.add_argument('-e', '--elffile', type=str, required=True,\n          help=\"Input ELF firmware file name\")\n\n    parser.add_argument('-o', '--valfile', type=str,\n          help=\"Values list JSON file name\")\n\n    parser.add_argument('--dry-run', action='store_true',\n          help=\"Do not write any files or do permanent changes\")\n\n    parser.add_argument('-v', '--verbose', action='count', default=0,\n          help=\"Increases verbosity level; max level is set by -vvv\")\n\n    subparser = parser.add_mutually_exclusive_group(required=True)\n\n    subparser.add_argument('-l', '--list', action='store_true',\n          help=\"list values stored in the firmware\")\n\n    subparser.add_argument('-x', '--extract', action='store_true',\n          help=\"Extract values to infos json text file\")\n\n    subparser.add_argument('-u', '--update', action='store_true',\n          help=\"Update values in binary fw from infos text file\")\n\n    subparser.add_argument('-d', '--objdump', action='store_true',\n          help=\"display asm like slightly primitive objdump\")\n\n    subparser.add_argument('--mapfile', action='store_true',\n          help=\"export known symbols to map file\")\n\n    subparser.add_argument('--version', action='version', version=\"%(prog)s {version} by {author}\"\n            .format(version=__version__, author=__author__),\n          help=\"Display version information and exit\")\n\n    po = parser.parse_args()\n\n    po.basename = os.path.splitext(os.path.basename(po.elffile))[0]\n\n    if len(po.elffile) > 0 and (po.valfile is None or len(po.valfile) == 0):\n        po.valfile = po.basename + \".json\"\n\n    if po.objdump:\n        if (po.verbose > 0):\n            print(\"{}: Opening for objdump\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_generic_objdump(po, elffh, 'thumb')\n\n    elif po.list:\n        if (po.verbose > 0):\n            print(\"{}: Opening for list\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_lbstm32_list(po, elffh)\n\n    elif po.mapfile:\n        if (po.verbose > 0):\n            print(\"{}: Opening for mapfile generation\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_lbstm32_mapfile(po, elffh)\n\n    elif po.extract:\n        if (po.verbose > 0):\n            print(\"{}: Opening for extract\".format(po.elffile))\n        with open(po.elffile, 'rb') as elffh:\n            armfw_elf_lbstm32_extract(po, elffh)\n\n    elif po.update:\n        if (po.verbose > 0):\n            print(\"{}: Opening for update\".format(po.elffile))\n        with open(po.elffile, 'r+b') as elffh:\n            armfw_elf_lbstm32_update(po, elffh)\n\n    else:\n        raise NotImplementedError(\"Unsupported command.\")\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except Exception as ex:\n        eprint(\"Error: \"+str(ex))\n        if 0: raise\n        sys.exit(10)\n"
        },
        {
          "name": "supported_firmwares_xv4.csv",
          "type": "blob",
          "size": 61.3681640625,
          "content": "\"product\",\"binary file\",\"download page\",\"download link\",\"download name\",\"test flags\",\"publish date\",\"bin file size [B]\",\"comment\"\r\n\"A3\",\"A3_FW_V01.01.01.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.01.01.00.bin\",\"A3_FW_V01.01.01.00.bin\",3,\"2016-04-28\",1417866,\r\n\"A3\",\"A3_FW_V01.01.02.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.01.02.00.bin\",\"A3_FW_V01.01.02.00.bin\",3,\"2016-05-03\",1418414,\r\n\"A3\",\"A3_FW_V01.02.00.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.02.00.00.bin\",\"A3_FW_V01.02.00.00.bin\",3,\"2016-06-07\",2514146,\r\n\"A3\",\"A3_FW_V01.03.00.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.03.00.00.bin\",\"A3_FW_V01.03.00.00.bin\",3,\"2016-06-08\",2569494,\r\n\"A3\",\"A3_FW_V01.04.00.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.04.00.00.bin\",\"A3_FW_V01.04.00.00.bin\",3,\"2016-10-11\",2750770,\r\n\"A3\",\"A3_FW_V01.05.00.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.05.00.00.bin\",\"A3_FW_V01.05.00.00.bin\",3,\"2016-10-20\",2751026,\r\n\"A3\",\"A3_FW_V01.06.00.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.06.00.00.bin\",\"A3_FW_V01.06.00.00.bin\",3,\"2016-10-26\",3054546,\r\n\"A3\",\"A3_FW_V01.06.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.06.00.01.bin\",\"A3_FW_V01.06.00.01.bin\",3,\"2016-10-26\",1871978,\r\n\"A3\",\"A3_FW_V01.06.00.10.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V01.06.00.10.bin\",\"A3_FW_V01.06.00.10.bin\",3,\"2017-01-05\",4400390,\r\n\"A3\",\"A3_FW_V02.00.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/A3_FW_V02.00.00.01.bin\",\"A3_FW_V02.00.00.01.bin\",3,\"2016-07-08\",2691178,\r\n\"AI900\",\"A3_FW_V01.00.00.32.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3_A3_test/A3_FW_V01.00.00.32.bin\",\"A3_FW_V01.00.00.32.bin\",3,\"2017-01-03\",4404998,\r\n\"AI900\",\"AI900_FW_V01.05.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3/AI900_FW_V01.05.00.01.bin\",\"AI900_FW_V01.05.00.01.bin\",3,\"2016-12-22\",4382726,\r\n\"AI900_AGR\",\"AI900_AGR_FW_V01.00.00.29.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3_AGR/AI900_AGR_FW_V01.00.00.29.bin\",\"AI900_AGR_FW_V01.00.00.29.bin\",3,\"2016-09-28\",2805454,\r\n\"AI900_AGR\",\"AI900_AGR_FW_V01.00.00.80.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3_AGR/AI900_AGR_FW_V01.00.00.80.bin\",\"AI900_AGR_FW_V01.00.00.80.bin\",3,\"2016-11-16\",4209866,\r\n\"AI900_AGR\",\"AI900_AGR_FW_V01.00.00.81.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3_AGR/AI900_AGR_FW_V01.00.00.81.bin\",\"AI900_AGR_FW_V01.00.00.81.bin\",3,\"2016-11-17\",4209866,\r\n\"AI900_AGR\",\"AI900_AGR_FW_V01.00.00.83.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/A3_AGR/AI900_AGR_FW_V01.00.00.83.bin\",\"AI900_AGR_FW_V01.00.00.83.bin\",3,\"2016-11-18\",4209866,\r\n\"AM603\",\"AM603_FW_V01.00.00.43(ESC).bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.00.43(ESC).bin\",\"AM603_FW_V01.00.00.43(ESC).bin\",3,\"2016-10-19\",2835942,\r\n\"AM603\",\"AM603_FW_V01.00.00.43.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.00.43.bin\",\"AM603_FW_V01.00.00.43.bin\",3,\"2016-10-20\",3139462,\r\n\"AM603\",\"AM603_FW_V01.00.00.47.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.00.47.bin\",\"AM603_FW_V01.00.00.47.bin\",3,\"2016-10-20\",2843110,\r\n\"AM603\",\"AM603_FW_V01.00.00.51.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.00.51.bin\",\"AM603_FW_V01.00.00.51.bin\",3,\"2016-10-21\",2853350,\r\n\"AM603\",\"AM603_FW_V01.00.00.70.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.00.70.bin\",\"AM603_FW_V01.00.00.70.bin\",3,\"2016-11-07\",2874742,\r\n\"AM603\",\"AM603_FW_V01.00.00.80.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.00.80.bin\",\"AM603_FW_V01.00.00.80.bin\",3,\"2016-11-08\",2890358,\r\n\"AM603\",\"AM603_FW_V01.00.01.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V01.00.01.01.bin\",\"AM603_FW_V01.00.01.01.bin\",3,\"2016-12-22\",3120758,\r\n\"AM603\",\"AM603_FW_V02.00.00.12.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/AM603_FW_V02.00.00.12.bin\",\"AM603_FW_V02.00.00.12.bin\",3,\"2016-09-13\",2615082,\r\n\"AM603\",\"N3_FW_V01.00.01.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3_A3_test/N3_FW_V01.00.01.01.bin\",\"N3_FW_V01.00.01.01.bin\",3,\"2017-01-03\",3135862,\r\n\"AM603\",\"N3_FW_V01.01.01.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/N3/N3_FW_V01.01.01.00.bin\",\"N3_FW_V01.01.01.00.bin\",3,\"2017-01-05\",3133558,\r\n\"C1\",\"C1_FW_V00.01.0000_ForIN2.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_V00.01.0000_ForIN2.bin\",\"C1_FW_V00.01.0000_ForIN2.bin\",3,\"2016-08-29\",147328,\r\n\"C1\",\"C1_FW_V01.00.0004.bin\",,\"http://download.dji-innovations.com/downloads/lightbridge2/C1_FW_V01.00.0004.bin\",\"C1_FW_V01.00.0004.bin\",3,\"2015-10-09\",14013108,\r\n\"C1\",\"C1_FW_V01.00.0010.bin\",,\"http://dl.djicdn.com/downloads/lightbridge2/C1_FW_V01.00.0010.bin\",\"C1_FW_V01.00.0010.bin\",3,\"2015-12-07\",14029380,\r\n\"C1\",\"C1_FW_V01.01.0000.bin\",,\"https://dl.djicdn.com/downloads/lightbridge2/C1_FW_V01.01.0000.bin\",\"C1_FW_V01.01.0000.bin\",3,\"2016-09-06\",5780684,\r\n\"C1\",\"C1_FW_V01.01.0010.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_V01.01.0010.bin\",\"C1_FW_V01.01.0010.bin\",3,\"2016-03-02\",5503110,\r\n\"C1\",\"C1_FW_V01.01.0020.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_V01.01.0020.bin\",\"C1_FW_V01.01.0020.bin\",3,\"2016-04-01\",5780684,\r\n\"C1\",\"C1_FW_V01.01.0030.bin\",,\"https://dl.djicdn.com/downloads/lightbridge2/C1_FW_V01.01.0030.bin\",\"C1_FW_V01.01.0030.bin\",3,\"2017-07-08\",18933196,\n\"C1\",\"C1_FW_V01.01.0092.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_V01.01.0092.bin\",\"C1_FW_V01.01.0092.bin\",3,\"2016-03-29\",14169232,\r\n\"C1\",\"C1_FW_V01.01.0093.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_V01.01.0093.bin\",\"C1_FW_V01.01.0093.bin\",3,\"2016-05-25\",18933156,\r\n\"C1\",\"C1_FW_V01.02.0021.bin\",\"http://www.gerhard-weinberger.at/phpBB2/viewtopic.php?f=5&t=9\",,\"C1_FW_V01.02.0021.bin\",3,,,\r\n\"C1\",\"C1_FW_V01.03.00.21.bin\",,\"http://download.dji-innovations.com/downloads/inspire_1/C1_FW_V01.03.00.21.bin\",\"C1_FW_V01.03.00.21.bin\",3,\"2015-08-13\",21276620,\r\n\"C1\",\"C1_FW_V01.03.0020.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3/C1_FW_V01.03.0020.bin\",\"C1_FW_V01.03.0020.bin\",3,\"2015-09-07\",29847336,\r\n\"C1\",\"C1_FW_V01.04.0030.bin\",,\"http://download.dji-innovations.com/downloads/RC/C1_FW_V01.04.0030.bin\",\"C1_FW_V01.04.0030.bin\",3,\"2015-11-24\",29855300,\r\n\"C1\",\"C1_FW_V01.05.0070.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/C1_FW_V01.05.0070.bin\",\"C1_FW_V01.05.0070.bin\",3,\"2015-11-26\",29978860,\r\n\"C1\",\"C1_FW_V01.05.0072\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_V01.05.0072\",\"C1_FW_V01.05.0072\",3,\"2016-06-02\",18933196,\r\n\"C1\",\"C1_FW_V01.05.0080.bin\",,\"https://dl.djicdn.com/downloads/RC/C1_FW_V01.05.0080.bin\",\"C1_FW_V01.05.0080.bin\",3,\"2016-07-08\",29997840,\r\n\"C1\",\"C1_FW_V01.06.0000.bin\",,\"https://dl.djicdn.com/downloads/lightbridge2/C1_FW_V01.06.0000.bin\",\"C1_FW_V01.06.0000.bin\",3,\"2016-07-25\",30046440,\r\n\"C1\",\"C1_FW_V01.06.0020.bin\",\"http://resource.dj2006.net/document/2016050611715.txt\",,\"C1_FW_V01.06.0020.bin\",0,\"2016-04-29\",,\"mentioned in update file, but no longer available; no known source\"\r\n\"C1\",\"C1_FW_v00.00.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/C1_FW_v00.00.00.01.bin\",\"C1_FW_v00.00.00.01.bin\",3,\"2016-07-27\",18922252,\r\n\"C1\",\"C1_FW_v00.00.0001.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v00.00.0001.bin\",\"C1_FW_v00.00.0001.bin\",3,\"2016-09-02\",18979212,\r\n\"C1\",\"C1_FW_v01.01.0030.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0030.bin\",\"C1_FW_v01.01.0030.bin\",3,\"2016-09-14\",18983916,\r\n\"C1\",\"C1_FW_v01.01.0035.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0035.bin\",\"C1_FW_v01.01.0035.bin\",3,\"2016-09-14\",18977796,\r\n\"C1\",\"C1_FW_v01.01.0040.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0040.bin\",\"C1_FW_v01.01.0040.bin\",3,\"2016-09-20\",18981116,\r\n\"C1\",\"C1_FW_v01.01.0050.bin\",,\"https://dl.djicdn.com/downloads/lightbridge2/C1_FW_v01.01.0050.bin\",\"C1_FW_v01.01.0050.bin\",3,\"2017-07-08\",18922252,\n\"C1\",\"C1_FW_v01.01.0051.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0051.bin\",\"C1_FW_v01.01.0051.bin\",3,\"2016-11-25\",18989012,\r\n\"C1\",\"C1_FW_v01.01.0053.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0053.bin\",\"C1_FW_v01.01.0053.bin\",3,\"2016-12-06\",19002336,\r\n\"C1\",\"C1_FW_v01.01.0054.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0054.bin\",\"C1_FW_v01.01.0054.bin\",3,\"2016-12-08\",19002536,\r\n\"C1\",\"C1_FW_v01.01.0055.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0055.bin\",\"C1_FW_v01.01.0055.bin\",3,\"2016-12-29\",19014072,\r\n\"C1\",\"C1_FW_v01.01.0060.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0060.bin\",\"C1_FW_v01.01.0060.bin\",3,\"2016-03-02\",30044608,\r\n\"C1\",\"C1_FW_v01.01.0070.bin\",,\"http://dl.djicdn.com/downloads/lightbridge2/NEW+FIRMWARE+20161103/C1_FW_v01.01.0070.bin\",\"C1_FW_v01.01.0070.bin\",3,\"2016-11-03\",18988364,\n\"C1\",\"C1_FW_v01.01.0080.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0080.bin\",\"C1_FW_v01.01.0080.bin\",3,\"2016-03-15\",18989012,\r\n\"C1\",\"C1_FW_v01.01.0090.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/C1_FW_v01.01.0090.bin\",\"C1_FW_v01.01.0090.bin\",3,\"2016-03-24\",30046440,\r\n\"C1\",\"C1_FW_v01.05.0071.bin\",,\"https://dl.djicdn.com/downloads/RC/C1_FW_v01.05.0071.bin\",\"C1_FW_v01.05.0071.bin\",3,\"2016-02-02\",29979520,\r\n\"C1\",\"C1_FW_v01.06.0001.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.06.0001.bin\",\"C1_FW_v01.06.0001.bin\",3,\"2016-08-15\",30058336,\r\n\"C1\",\"C1_FW_v01.07.0000.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.07.0000.bin\",\"C1_FW_v01.07.0000.bin\",3,\"2016-08-26\",30058336,\r\n\"C1\",\"C1_FW_v01.07.0002.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.07.0002.bin\",\"C1_FW_v01.07.0002.bin\",3,\"2016-07-08\",30022496,\r\n\"C1\",\"C1_FW_v01.07.0030.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.07.0030.bin\",\"C1_FW_v01.07.0030.bin\",3,\"2016-07-14\",30023072,\r\n\"C1\",\"C1_FW_v01.07.0040.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.07.0040.bin\",\"C1_FW_v01.07.0040.bin\",3,\"2016-07-27\",30025824,\r\n\"C1\",\"C1_FW_v01.07.0050.bin\",,\"https://dl.djicdn.com/downloads/inspire_1/C1_FW_v01.07.0050.bin\",\"C1_FW_v01.07.0050.bin\",3,\"2017-07-08\",21318556,\n\"C1\",\"C1_FW_v01.07.0060.bin\",,\"http://dl.djicdn.com/downloads/inspire_1_rc/C1_FW_v01.07.0060.bin\",\"C1_FW_v01.07.0060.bin\",3,\"2016-11-10\",21318668,\n\"C1\",\"C1_FW_v01.08.0000.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.08.0000.bin\",\"C1_FW_v01.08.0000.bin\",3,\"2016-09-12\",30058336,\r\n\"C1\",\"C1_FW_v01.09.0000.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RC_TEST/C1_FW_v01.09.0000.bin\",\"C1_FW_v01.09.0000.bin\",3,\"2016-11-08\",30058312,\r\n\"C1\",\"C1_v00.01.00.00_20161012.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/C1_v00.01.00.00_20161012.bin\",\"C1_v00.01.00.00_20161012.bin\",3,\"2016-10-12\",405034,\r\n\"C1\",\"C1_v00.01.00.01_20161021.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/C1_v00.01.00.01_20161021.bin\",\"C1_v00.01.00.01_20161021.bin\",3,\"2016-10-21\",405034,\r\n\"C1\",\"C1_v00.01.00.01_20161104.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/C1_v00.01.00.01_20161104.bin\",\"C1_v00.01.00.01_20161104.bin\",3,\"2016-11-04\",394646,\r\n\"C1\",\"LBTX_FW_V01.01.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/LBTX_FW_V01.01.00.bin\",\"LBTX_FW_V01.01.00.bin\",3,\"2016-04-05\",9206870,\r\n\"C1\",\"LBTX_FW_V01.01.0010.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/LBTX_FW_V01.01.0010.bin\",\"LBTX_FW_V01.01.0010.bin\",3,\"2016-05-25\",9207638,\r\n\"C1\",\"LBTX_FW_V01.01.0030.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/LBTX_FW_V01.01.0030.bin\",\"LBTX_FW_V01.01.0030.bin\",3,\"2016-06-27\",9210642,\r\n\"C1\",\"LBTX_FW_V01.01.0031.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/LBTX_FW_V01.01.0031.bin\",\"LBTX_FW_V01.01.0031.bin\",3,\"2016-07-27\",9209002,\r\n\"C1\",\"LBTX_FW_V01.01.0040.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/LBTX_FW_V01.01.0040.bin\",\"LBTX_FW_V01.01.0040.bin\",3,\"2016-08-18\",9210650,\r\n\"C1\",\"LBTX_FW_V01.01.0041.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/LB2/LBTX_FW_V01.01.0041.bin\",\"LBTX_FW_V01.01.0041.bin\",3,\"2016-03-29\",9205798,\r\n\"ESC\",\"ESC_FW_V01.00.00.11.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ESC/ESC_FW_V01.00.00.11.bin\",\"ESC_FW_V01.00.00.11.bin\",3,\"2017-01-03\",128279,\r\n\"GL300E\",\"GL300E_RC_v00.01.04.01_20161019.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/GL300E_RC_v00.01.04.01_20161019.bin\",\"GL300E_RC_v00.01.04.01_20161019.bin\",3,\"2016-10-19\",216948,\r\n\"GL300E\",\"GL300E_RC_v00.01.05.00_20161024.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/GL300E_RC_v00.01.05.00_20161024.bin\",\"GL300E_RC_v00.01.05.00_20161024.bin\",3,\"2016-10-24\",153220,\r\n\"GL300E\",\"GL300E_v00.01.00.00_154968013.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/GL300E_v00.01.00.00_154968013.bin\",\"GL300E_v00.01.00.00_154968013.bin\",3,\"2016-09-21\",148920,\r\n\"GL300E\",\"p4pRC_v1.0.0.0_20161010.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/POMATO_RC/p4pRC_v1.0.0.0_20161010.bin\",\"p4pRC_v1.0.0.0_20161010.bin\",3,\"2016-10-11\",216948,\r\n\"HG300\",\"HG300_FW_V01.01.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.01.bin\",\"HG300_FW_V01.01.00.01.bin\",3,\"2016-04-29\",418926,\r\n\"HG300\",\"HG300_FW_V01.01.00.02.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.02.bin\",\"HG300_FW_V01.01.00.02.bin\",3,\"2016-05-06\",426486,\r\n\"HG300\",\"HG300_FW_V01.01.00.04.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.04.bin\",\"HG300_FW_V01.01.00.04.bin\",3,\"2016-05-19\",620666,\r\n\"HG300\",\"HG300_FW_V01.01.00.05.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.05.bin\",\"HG300_FW_V01.01.00.05.bin\",3,\"2016-05-31\",623138,\r\n\"HG300\",\"HG300_FW_V01.01.00.06.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.06.bin\",\"HG300_FW_V01.01.00.06.bin\",3,\"2016-06-01\",623138,\r\n\"HG300\",\"HG300_FW_V01.01.00.06_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.06_PC.bin\",\"HG300_FW_V01.01.00.06_PC.bin\",3,\"2016-06-03\",430122,\r\n\"HG300\",\"HG300_FW_V01.01.00.07.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.07.bin\",\"HG300_FW_V01.01.00.07.bin\",3,\"2016-06-17\",624550,\r\n\"HG300\",\"HG300_FW_V01.01.00.07_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.07_PC.bin\",\"HG300_FW_V01.01.00.07_PC.bin\",3,\"2016-06-16\",431534,\r\n\"HG300\",\"HG300_FW_V01.01.00.08.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.08.bin\",\"HG300_FW_V01.01.00.08.bin\",3,\"2016-06-23\",637434,\r\n\"HG300\",\"HG300_FW_V01.01.00.08_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.08_PC.bin\",\"HG300_FW_V01.01.00.08_PC.bin\",3,\"2016-06-23\",444418,\r\n\"HG300\",\"HG300_FW_V01.01.00.11.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.11.bin\",\"HG300_FW_V01.01.00.11.bin\",3,\"2016-06-30\",629178,\r\n\"HG300\",\"HG300_FW_V01.01.00.11_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.11_PC.bin\",\"HG300_FW_V01.01.00.11_PC.bin\",3,\"2016-06-30\",436162,\r\n\"HG300\",\"HG300_FW_V01.01.00.12.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.12.bin\",\"HG300_FW_V01.01.00.12.bin\",3,\"2016-07-05\",632106,\r\n\"HG300\",\"HG300_FW_V01.01.00.12_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.12_PC.bin\",\"HG300_FW_V01.01.00.12_PC.bin\",3,\"2016-07-05\",439090,\r\n\"HG300\",\"HG300_FW_V01.01.00.13.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.13.bin\",\"HG300_FW_V01.01.00.13.bin\",3,\"2016-07-11\",633690,\r\n\"HG300\",\"HG300_FW_V01.01.00.13_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.13_PC.bin\",\"HG300_FW_V01.01.00.13_PC.bin\",3,\"2016-07-11\",440674,\r\n\"HG300\",\"HG300_FW_V01.01.00.14.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.14.bin\",\"HG300_FW_V01.01.00.14.bin\",3,\"2016-07-19\",634802,\r\n\"HG300\",\"HG300_FW_V01.01.00.14_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.14_PC.bin\",\"HG300_FW_V01.01.00.14_PC.bin\",3,\"2016-07-19\",441786,\r\n\"HG300\",\"HG300_FW_V01.01.00.15.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.15.bin\",\"HG300_FW_V01.01.00.15.bin\",3,\"2016-07-21\",634950,\r\n\"HG300\",\"HG300_FW_V01.01.00.15_PC.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.15_PC.bin\",\"HG300_FW_V01.01.00.15_PC.bin\",3,\"2016-07-21\",441934,\r\n\"HG300\",\"HG300_FW_V01.01.00.16.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.16.bin\",\"HG300_FW_V01.01.00.16.bin\",3,\"2016-08-30\",641266,\r\n\"HG300\",\"HG300_FW_V01.01.00.17.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.17.bin\",\"HG300_FW_V01.01.00.17.bin\",3,\"2016-08-04\",637818,\r\n\"HG300\",\"HG300_FW_V01.01.00.18.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.18.bin\",\"HG300_FW_V01.01.00.18.bin\",3,\"2016-08-15\",638670,\r\n\"HG300\",\"HG300_FW_V01.01.00.19.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.19.bin\",\"HG300_FW_V01.01.00.19.bin\",3,\"2016-08-19\",640286,\r\n\"HG300\",\"HG300_FW_V01.01.00.21.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.21.bin\",\"HG300_FW_V01.01.00.21.bin\",3,\"2016-08-25\",640494,\r\n\"HG300\",\"HG300_FW_V01.01.00.22.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.22.bin\",\"HG300_FW_V01.01.00.22.bin\",3,\"2016-08-25\",641190,\r\n\"HG300\",\"HG300_FW_V01.01.00.23.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.23.bin\",\"HG300_FW_V01.01.00.23.bin\",3,\"2016-08-26\",641582,\r\n\"HG300\",\"HG300_FW_V01.01.00.24.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.24.bin\",\"HG300_FW_V01.01.00.24.bin\",3,\"2016-08-29\",641654,\r\n\"HG300\",\"HG300_FW_V01.01.00.30.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.30.bin\",\"HG300_FW_V01.01.00.30.bin\",3,\"2016-10-17\",641654,\r\n\"HG300\",\"HG300_FW_V01.01.00.30_1.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.01.00.30_1.bin\",\"HG300_FW_V01.01.00.30_1.bin\",3,\"2016-08-30\",641654,\r\n\"HG300\",\"HG300_FW_V01.02.00.31.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.02.00.31.bin\",\"HG300_FW_V01.02.00.31.bin\",3,\"2016-09-21\",645502,\r\n\"HG300\",\"HG300_FW_V01.02.00.33.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.02.00.33.bin\",\"HG300_FW_V01.02.00.33.bin\",3,\"2016-09-26\",660310,\r\n\"HG300\",\"HG300_FW_V01.02.00.34.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.02.00.34.bin\",\"HG300_FW_V01.02.00.34.bin\",3,\"2016-10-10\",660522,\r\n\"HG300\",\"HG300_FW_V01.02.00.40.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.02.00.40.bin\",\"HG300_FW_V01.02.00.40.bin\",3,\"2016-10-13\",660522,\r\n\"HG300\",\"HG300_FW_V01.03.00.41.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.41.bin\",\"HG300_FW_V01.03.00.41.bin\",3,\"2016-10-25\",660878,\r\n\"HG300\",\"HG300_FW_V01.03.00.42.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.42.bin\",\"HG300_FW_V01.03.00.42.bin\",3,\"2016-10-26\",660878,\r\n\"HG300\",\"HG300_FW_V01.03.00.43.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.43.bin\",\"HG300_FW_V01.03.00.43.bin\",3,\"2016-11-11\",661914,\r\n\"HG300\",\"HG300_FW_V01.03.00.43_3.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.43_3.bin\",\"HG300_FW_V01.03.00.43_3.bin\",3,\"2016-11-11\",661898,\r\n\"HG300\",\"HG300_FW_V01.03.00.44.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.44.bin\",\"HG300_FW_V01.03.00.44.bin\",3,\"2016-11-16\",660878,\r\n\"HG300\",\"HG300_FW_V01.03.00.45.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.45.bin\",\"HG300_FW_V01.03.00.45.bin\",3,\"2016-11-17\",662258,\r\n\"HG300\",\"HG300_FW_V01.03.00.45_new.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.45_new.bin\",\"HG300_FW_V01.03.00.45_new.bin\",3,\"2016-11-17\",661914,\r\n\"HG300\",\"HG300_FW_V01.03.00.46.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.46.bin\",\"HG300_FW_V01.03.00.46.bin\",3,\"2016-11-21\",662258,\r\n\"HG300\",\"HG300_FW_V01.03.00.50.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.03.00.50.bin\",\"HG300_FW_V01.03.00.50.bin\",3,\"2016-11-22\",662258,\r\n\"HG300\",\"HG300_FW_V01.04.00.51.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.51.bin\",\"HG300_FW_V01.04.00.51.bin\",3,\"2016-12-02\",662782,\r\n\"HG300\",\"HG300_FW_V01.04.00.52.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.52.bin\",\"HG300_FW_V01.04.00.52.bin\",3,\"2016-12-15\",663054,\r\n\"HG300\",\"HG300_FW_V01.04.00.53.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.53.bin\",\"HG300_FW_V01.04.00.53.bin\",3,\"2016-12-19\",663054,\r\n\"HG300\",\"HG300_FW_V01.04.00.54.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.54.bin\",\"HG300_FW_V01.04.00.54.bin\",3,\"2016-12-21\",663054,\r\n\"HG300\",\"HG300_FW_V01.04.00.55.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.55.bin\",\"HG300_FW_V01.04.00.55.bin\",3,\"2016-12-22\",662990,\r\n\"HG300\",\"HG300_FW_V01.04.00.56.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.56.bin\",\"HG300_FW_V01.04.00.56.bin\",3,\"2016-12-28\",663022,\r\n\"HG300\",\"HG300_FW_V01.04.00.60-4.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.60-4.bin\",\"HG300_FW_V01.04.00.60-4.bin\",3,\"2017-01-09\",663586,\r\n\"HG300\",\"HG300_FW_V01.04.00.60.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/HG300/HG300_FW_V01.04.00.60.bin\",\"HG300_FW_V01.04.00.60.bin\",3,\"2017-01-09\",663586,\r\n\"HG300\",\"HG300_FW_V01.05.00.70.bin\",,\"https://dl.djicdn.com/downloads/osmo+mobile/HG300_FW_V01.05.00.70.bin\",\"HG300_FW_V01.05.00.70.bin\",3,\"2017-07-08\",664558,\n\"HG300\",\"HG300_FW_V01.06.00.80.bin\",,\"https://dl.djicdn.com/downloads/osmo+mobile/20170605/HG300_FW_V01.06.00.80.bin\",\"HG300_FW_V01.06.00.80.bin\",3,\"2017-07-08\",667278,\n\"MATRICE100\",\"MATRICE100_FW_V01.02.00.60.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M100/MATRICE100_FW_V01.02.00.60.bin\",\"MATRICE100_FW_V01.02.00.60.bin\",3,\"2016-02-19\",1416854,\r\n\"MATRICE100\",\"MATRICE100_FW_V01.02.00.70.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M100/MATRICE100_FW_V01.02.00.70.bin\",\"MATRICE100_FW_V01.02.00.70.bin\",3,\"2016-02-29\",1417622,\r\n\"MATRICE100\",\"MATRICE100_FW_V01.02.00.80.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M100/MATRICE100_FW_V01.02.00.80.bin\",\"MATRICE100_FW_V01.02.00.80.bin\",3,\"2016-04-01\",1500122,\r\n\"MATRICE100\",\"MATRICE100_FW_V01.02.00.90.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M100/MATRICE100_FW_V01.02.00.90.bin\",\"MATRICE100_FW_V01.02.00.90.bin\",3,\"2016-03-31\",1505082,\r\n\"MATRICE100\",\"MATRICE100_FW_V01.03.01.00_pc.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M100/MATRICE100_FW_V01.03.01.00_pc.bin\",\"MATRICE100_FW_V01.03.01.00_pc.bin\",3,\"2016-04-11\",1505990,\r\n\"MATRICE100\",\"MATRICE100_FW_V01.03.02.55_pc.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M100/MATRICE100_FW_V01.03.02.55_pc.bin\",\"MATRICE100_FW_V01.03.02.55_pc.bin\",3,\"2016-07-01\",1414086,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.27.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.27.bin\",\"MATRICE600_FW_V01.00.00.27.bin\",3,\"2016-12-06\",3292363,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.27_nw.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.27_nw.bin\",\"MATRICE600_FW_V01.00.00.27_nw.bin\",3,\"2016-12-14\",3300555,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.28.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.28.bin\",\"MATRICE600_FW_V01.00.00.28.bin\",3,\"2017-01-04\",3263895,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.39.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.39.bin\",\"MATRICE600_FW_V01.00.00.39.bin\",3,\"2016-09-29\",3163827,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.39_nw.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.39_nw.bin\",\"MATRICE600_FW_V01.00.00.39_nw.bin\",3,\"2016-10-21\",2988247,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.42.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.42.bin\",\"MATRICE600_FW_V01.00.00.42.bin\",3,\"2016-10-21\",3110319,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.43.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.43.bin\",\"MATRICE600_FW_V01.00.00.43.bin\",3,\"2016-10-17\",3218763,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.44.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.44.bin\",\"MATRICE600_FW_V01.00.00.44.bin\",3,\"2016-10-26\",3226979,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.51.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.51.bin\",\"MATRICE600_FW_V01.00.00.51.bin\",3,\"2016-11-04\",3251347,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.53.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.53.bin\",\"MATRICE600_FW_V01.00.00.53.bin\",3,\"2016-11-10\",3267731,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.54.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.54.bin\",\"MATRICE600_FW_V01.00.00.54.bin\",3,\"2016-11-21\",3272851,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.56.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.56.bin\",\"MATRICE600_FW_V01.00.00.56.bin\",3,\"2016-12-14\",3300555,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.60.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.60.bin\",\"MATRICE600_FW_V01.00.00.60.bin\",3,\"2016-12-16\",3300555,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.00.80.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.00.80.bin\",\"MATRICE600_FW_V01.00.00.80.bin\",3,\"2016-12-19\",3300575,\r\n\"MATRICE600\",\"MATRICE600_FW_V01.00.0090.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/MATRICE600_FW_V01.00.0090.bin\",\"MATRICE600_FW_V01.00.0090.bin\",3,\"2016-12-19\",3062751,\r\n\"MATRICE600\",\"MATRICE600_FW_V02.00.00.21.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/UH/MATRICE600_FW_V02.00.00.21.bin\",\"MATRICE600_FW_V02.00.00.21.bin\",3,\"2016-12-19\",3505831,\r\n\"MATRICE600\",\"MATRICE600_FW_V02.00.00.95(polar).bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/UH/MATRICE600_FW_V02.00.00.95(polar).bin\",\"MATRICE600_FW_V02.00.00.95(polar).bin\",3,\"2017-01-04\",3263895,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.01.bin\",\"MATRICE600PRO_FW_V01.00.00.01.bin\",3,\"2016-04-18\",1911024,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.51.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.51.bin\",\"MATRICE600PRO_FW_V01.00.00.51.bin\",3,\"2016-08-18\",1843121,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.53.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.53.bin\",\"MATRICE600PRO_FW_V01.00.00.53.bin\",3,\"2016-05-05\",2941971,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.54.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.54.bin\",\"MATRICE600PRO_FW_V01.00.00.54.bin\",3,\"2016-06-08\",3016747,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.55.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.55.bin\",\"MATRICE600PRO_FW_V01.00.00.55.bin\",3,\"2016-08-18\",2993367,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.60.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.60.bin\",\"MATRICE600PRO_FW_V01.00.00.60.bin\",3,\"2016-09-27\",2988247,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.61.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.61.bin\",\"MATRICE600PRO_FW_V01.00.00.61.bin\",3,\"2016-09-28\",2988247,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.62.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.62.bin\",\"MATRICE600PRO_FW_V01.00.00.62.bin\",3,\"2016-09-29\",3166935,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.63.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.63.bin\",\"MATRICE600PRO_FW_V01.00.00.63.bin\",3,\"2016-10-26\",3236451,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.64.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.64.bin\",\"MATRICE600PRO_FW_V01.00.00.64.bin\",3,\"2016-11-08\",3260819,\r\n\"MATRICE600PRO\",\"MATRICE600PRO_FW_V01.00.00.80.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600PRO/MATRICE600PRO_FW_V01.00.00.80.bin\",\"MATRICE600PRO_FW_V01.00.00.80.bin\",3,\"2016-11-10\",3277203,\r\n\"MG1S\",\"MG1S_FW_V01.00.00.02.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/MG1S/MG1S_FW_V01.00.00.02.bin\",\"MG1S_FW_V01.00.00.02.bin\",3,\"2016-12-05\",116118,\r\n\"MG1S_RC\",\"MG1SRC_FW_V01.00.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/MG1S/MG1SRC_FW_V01.00.00.01.bin\",\"MG1SRC_FW_V01.00.00.01.bin\",3,\"2016-11-29\",3597071,\r\n\"OSMO\",\"OSMO_FW_V01.00.01.19.bin\",,\"http://download.dji-innovations.com/downloads/osmo/OSMO_FW_V01.00.01.19.bin\",\"OSMO_FW_V01.00.01.19.bin\",7,\"2015-10-26\",73067210,\r\n\"OSMO\",\"OSMO_FW_V01.04.01.80.bin\",,\"http://dl.djicdn.com/downloads/osmo/OSMO_FW_BUGFIX_V01.04.01.80.bin.zip\",\"OSMO_FW_BUGFIX_V01.04.01.80.bin.zip\",3,\"2015-12-28\",74656006,\"unfixed 01.04.01.80 may disable the device\"\r\n\"OSMO\",\"OSMO_FW_V01.05.01.88.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.88.bin\",\"OSMO_FW_V01.05.01.88.bin\",3,\"2016-01-31\",72625954,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.89.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.89.bin\",\"OSMO_FW_V01.05.01.89.bin\",3,\"2016-02-05\",72625954,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.92.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.92.bin\",\"OSMO_FW_V01.05.01.92.bin\",3,\"2016-02-25\",72627486,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.93.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.93.bin\",\"OSMO_FW_V01.05.01.93.bin\",3,\"2016-02-26\",72633866,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.94.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.94.bin\",\"OSMO_FW_V01.05.01.94.bin\",3,\"2016-03-02\",72634714,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.95.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.95.bin\",\"OSMO_FW_V01.05.01.95.bin\",3,\"2016-03-04\",72647002,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.96.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.96.bin\",\"OSMO_FW_V01.05.01.96.bin\",3,\"2016-03-10\",72778074,\r\n\"OSMO\",\"OSMO_FW_V01.05.01.97.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.01.97.bin\",\"OSMO_FW_V01.05.01.97.bin\",3,\"2016-03-11\",72787086,\r\n\"OSMO\",\"OSMO_FW_V01.05.02.00.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.05.02.00.bin\",\"OSMO_FW_V01.05.02.00.bin\",3,\"2016-03-16\",72787406,\r\n\"OSMO\",\"OSMO_FW_V01.06.02.10.bin\",,\"http://dl.djicdn.com/downloads/osmo/OSMO_FW_V01.06.02.10.zip\",\"OSMO_FW_V01.06.02.10.zip\",3,\"2016-03-24\",72786874,\r\n\"OSMO\",\"OSMO_FW_V01.08.02.30.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.08.02.30.bin\",\"OSMO_FW_V01.08.02.30.bin\",3,\"2016-06-16\",72772998,\r\n\"OSMO\",\"OSMO_FW_V01.08.02.35.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.08.02.35.bin\",\"OSMO_FW_V01.08.02.35.bin\",3,\"2016-09-23\",72140202,\r\n\"OSMO\",\"OSMO_FW_V01.08.02.36.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO/OSMO_FW_V01.08.02.36.bin\",\"OSMO_FW_V01.08.02.36.bin\",3,\"2016-09-24\",72140202,\r\n\"OSMO\",\"OSMO_FW_V01.08.02.40.bin\",,\"https://dl.djicdn.com/downloads/osmo/OSMO_FW_V01.08.02.40.zip\",\"OSMO_FW_V01.08.02.40.zip\",7,\"2016-09-26\",72140974,\r\n\"OSMO\",\"OSMO_FW_V01.10.02.60.bin\",,\"https://dl.djicdn.com/downloads/osmo/20170622/OSMO_FW_V01.10.02.60.bin\",\"OSMO_FW_V01.10.02.60.bin\",3,\"2017-07-08\",72159634,\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.03.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.03.bin\",\"OSMO_FC350Z_FW_V01.00.00.03.bin\",3,\"2016-05-30\",67523686,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.05.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.05.bin\",\"OSMO_FC350Z_FW_V01.00.00.05.bin\",3,\"2016-06-08\",67563474,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.06.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.06.bin\",\"OSMO_FC350Z_FW_V01.00.00.06.bin\",3,\"2016-06-29\",68046334,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.07.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.07.bin\",\"OSMO_FC350Z_FW_V01.00.00.07.bin\",7,\"2016-07-08\",68049190,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.08.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.08.bin\",\"OSMO_FC350Z_FW_V01.00.00.08.bin\",3,\"2016-07-22\",67132018,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.09.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.09.bin\",\"OSMO_FC350Z_FW_V01.00.00.09.bin\",3,\"2016-07-26\",67132018,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.11.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.11.bin\",\"OSMO_FC350Z_FW_V01.00.00.11.bin\",3,\"2016-08-04\",67136154,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.12.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.12.bin\",\"OSMO_FC350Z_FW_V01.00.00.12.bin\",3,\"2016-08-08\",67136154,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.13.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.13.bin\",\"OSMO_FC350Z_FW_V01.00.00.13.bin\",3,\"2016-08-15\",67139734,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.14.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.14.bin\",\"OSMO_FC350Z_FW_V01.00.00.14.bin\",3,\"2016-08-26\",67088422,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.15.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.15.bin\",\"OSMO_FC350Z_FW_V01.00.00.15.bin\",3,\"2016-08-15\",67139802,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.16.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.16.bin\",\"OSMO_FC350Z_FW_V01.00.00.16.bin\",3,\"2016-08-26\",67145270,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.17.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.17.bin\",\"OSMO_FC350Z_FW_V01.00.00.17.bin\",3,\"2016-08-29\",67145262,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.00.00.20.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.00.00.20.bin\",\"OSMO_FC350Z_FW_V01.00.00.20.bin\",3,\"2016-08-29\",67145262,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.01.00.21.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.01.00.21.bin\",\"OSMO_FC350Z_FW_V01.01.00.21.bin\",3,\"2016-09-06\",67145774,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.01.00.30.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.01.00.30.bin\",\"OSMO_FC350Z_FW_V01.01.00.30.bin\",3,\"2016-09-08\",67096178,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.02.00.32.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.02.00.32.bin\",\"OSMO_FC350Z_FW_V01.02.00.32.bin\",3,\"2016-09-30\",67096262,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.02.00.33.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.02.00.33.bin\",\"OSMO_FC350Z_FW_V01.02.00.33.bin\",3,\"2016-09-30\",67095734,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.02.00.38.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.02.00.38.bin\",\"OSMO_FC350Z_FW_V01.02.00.38.bin\",3,\"2016-10-08\",67095326,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.02.00.40.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.02.00.40.bin\",\"OSMO_FC350Z_FW_V01.02.00.40.bin\",3,\"2016-10-17\",67096702,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.03.00.50.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_Zoom/OSMO_FC350Z_FW_V01.03.00.50.bin\",\"OSMO_FC350Z_FW_V01.03.00.50.bin\",7,\"2016-11-14\",67113142,\r\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.04.00.70.bin\",,\"https://dl.djicdn.com/downloads/osmo-plus/OSMO_FC350Z_FW_V01.04.00.70.bin\",\"OSMO_FC350Z_FW_V01.04.00.70.bin\",3,\"2017-07-08\",67113466,\n\"OSMO_FC350Z\",\"OSMO_FC350Z_FW_V01.05.00.90.bin\",,\"https://dl.djicdn.com/downloads/osmo-plus/OSMO_FC350Z_FW_V01.05.00.90.bin\",\"OSMO_FC350Z_FW_V01.05.00.90.bin\",3,\"2017-07-08\",67121506,\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.02.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.02.bin\",\"OSMO_FC550_FW_V01.01.00.02.bin\",3,\"2016-02-19\",74040130,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.03.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.03.bin\",\"OSMO_FC550_FW_V01.01.00.03.bin\",3,\"2016-02-24\",74055210,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.04.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.04.bin\",\"OSMO_FC550_FW_V01.01.00.04.bin\",3,\"2016-02-24\",74055210,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.05.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.05.bin\",\"OSMO_FC550_FW_V01.01.00.05.bin\",3,\"2016-03-02\",74104246,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.07.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.07.bin\",\"OSMO_FC550_FW_V01.01.00.07.bin\",3,\"2016-03-14\",74425514,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.08.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.08.bin\",\"OSMO_FC550_FW_V01.01.00.08.bin\",3,\"2016-03-28\",74433598,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.09.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.09.bin\",\"OSMO_FC550_FW_V01.01.00.09.bin\",3,\"2016-04-01\",74482750,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.10.bin\",,\"https://dl.djicdn.com/downloads/osmo/OSMO_FC550_FW_V01.01.00.10.bin\",\"OSMO_FC550_FW_V01.01.00.10.bin\",3,\"2017-07-08\",74446638,\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.11.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.11.bin\",\"OSMO_FC550_FW_V01.01.00.11.bin\",3,\"2016-04-07\",74495042,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.01.00.13.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.01.00.13.bin\",\"OSMO_FC550_FW_V01.01.00.13.bin\",3,\"2016-04-14\",74441946,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.03.00.30.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5/OSMO_FC550_FW_V01.03.00.30.bin\",\"OSMO_FC550_FW_V01.03.00.30.bin\",7,\"2016-06-16\",74452422,\r\n\"OSMO_X5\",\"OSMO_FC550_FW_V01.03.00.40.bin\",,\"https://dl.djicdn.com/downloads/osmo/OSMO_FC550_FW_V01.03.00.40.zip\",\"OSMO_FC550_FW_V01.03.00.40.zip\",3,,,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.01.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5R/OSMO_FC550R_FW_V01.01.00.01.bin\",\"OSMO_FC550R_FW_V01.01.00.01.bin\",3,\"2016-04-14\",101404080,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.01.00.03.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5R/OSMO_FC550R_FW_V01.01.00.03.bin\",\"OSMO_FC550R_FW_V01.01.00.03.bin\",3,\"2016-04-22\",101659936,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.01.00.04.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5R/OSMO_FC550R_FW_V01.01.00.04.bin\",\"OSMO_FC550R_FW_V01.01.00.04.bin\",3,\"2016-04-26\",101644892,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.01.00.10.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5R/OSMO_FC550R_FW_V01.01.00.10.bin\",\"OSMO_FC550R_FW_V01.01.00.10.bin\",3,\"2016-05-04\",101775964,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.02.00.11.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5R/OSMO_FC550R_FW_V01.02.00.11.bin\",\"OSMO_FC550R_FW_V01.02.00.11.bin\",3,\"2016-05-09\",101775964,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.03.00.30.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/OSMO_X5R/OSMO_FC550R_FW_V01.03.00.30.bin\",\"OSMO_FC550R_FW_V01.03.00.30.bin\",3,\"2016-06-16\",101778676,\r\n\"OSMO_X5R\",\"OSMO_FC550R_FW_V01.03.00.40.bin\",,\"https://dl.djicdn.com/downloads/osmo/OSMO_FC550R_FW_V01.03.00.40.zip\",\"OSMO_FC550R_FW_V01.03.00.40.zip\",7,,,\"larger than others\"\r\n\"P3C\",\"P3C_FW_V01.00.0014_Beta.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3/P3C_FW_V01.00.0014_Beta.bin\",\"P3C_FW_V01.00.0014_Beta.bin\",7,,66441750,\r\n\"P3C\",\"P3C_FW_V01.00.0017_Beta.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3/P3C_FW_V01.00.0017_Beta.bin\",\"P3C_FW_V01.00.0017_Beta.bin\",3,,66084790,\r\n\"P3C\",\"P3C_FW_V01.00.0020.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3_standard/P3C_FW_V01.00.0020.bin\",\"P3C_FW_V01.00.0020.bin\",3,,66088886,\r\n\"P3C\",\"P3C_FW_V01.01.0030.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3_standard/P3C_FW_V01.01.0030.bin\",\"P3C_FW_V01.01.0030.bin\",3,,66489662,\r\n\"P3C\",\"P3C_FW_V01.02.0040.bin\",,\"http://dl.djicdn.com/downloads/phantom_3_standard/P3C_FW_V01.02.0040.bin\",\"P3C_FW_V01.02.0040.bin\",3,,66244554,\r\n\"P3C\",\"P3C_FW_V01.03.0050.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_standard/P3C_FW_V01.03.0050.bin\",\"P3C_FW_V01.03.0050.bin\",3,,66255014,\r\n\"P3C\",\"P3C_FW_V01.04.0050.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.04.0050.bin\",\"P3C_FW_V01.04.0050.bin\",3,\"2016-03-10\",57601574,\r\n\"P3C\",\"P3C_FW_V01.04.0060.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_standard/P3C_FW_V01.04.0060.bin\",\"P3C_FW_V01.04.0060.bin\",7,\"2016-03-09\",66465384,\r\n\"P3C\",\"P3C_FW_V01.05.0070.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_standard/P3C_FW_V01.05.0070.bin\",\"P3C_FW_V01.05.0070.bin\",3,\"2016-04-20\",66469044,\r\n\"P3C\",\"P3C_FW_V01.05.0074.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.05.0074.bin\",\"P3C_FW_V01.05.0074.bin\",3,\"2016-10-20\",8300602,\r\n\"P3C\",\"P3C_FW_V01.05.0075.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.05.0075.bin\",\"P3C_FW_V01.05.0075.bin\",3,\"2016-09-23\",66104000,\r\n\"P3C\",\"P3C_FW_V01.06.0080.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.06.0080.bin\",\"P3C_FW_V01.06.0080.bin\",3,\"2016-09-27\",66104664,\r\n\"P3C\",\"P3C_FW_V01.06.0083.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.06.0083.bin\",\"P3C_FW_V01.06.0083.bin\",3,\"2016-07-13\",66287552,\r\n\"P3C\",\"P3C_FW_V01.06.0086.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.06.0086.bin\",\"P3C_FW_V01.06.0086.bin\",3,\"2016-07-28\",66287552,\r\n\"P3C\",\"P3C_FW_V01.07.0082.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.07.0082.bin\",\"P3C_FW_V01.07.0082.bin\",3,\"2016-09-18\",66370300,\r\n\"P3C\",\"P3C_FW_V01.07.0084.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.07.0084.bin\",\"P3C_FW_V01.07.0084.bin\",3,\"2016-11-08\",66108728,\r\n\"P3C\",\"P3C_FW_V01.07.0086.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.07.0086.bin\",\"P3C_FW_V01.07.0086.bin\",3,\"2016-12-26\",876406,\r\n\"P3C\",\"P3C_FW_V01.07.0090.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P3C/P3C_FW_V01.07.0090.bin\",\"P3C_FW_V01.07.0090.bin\",3,\"2016-12-29\",66108728,\r\n\"P3C\",\"P3C_FW_V01.08.0100.bin\",,\"http://dl.djicdn.com/downloads/phantom_3_standard/20170111/P3C_FW_V01.08.0100.bin\",\"P3C_FW_V01.08.0100.bin\",3,\"2017-07-08\",66188652,\n\"P3C\",\"P3C_FW_V01.09.0200.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_standard/P3C_FW_V01.09.0200.bin\",\"P3C_FW_V01.09.0200.bin\",3,\"2017-07-08\",108371760,\n\"P3S\",\"P3S_FW_V01.01.0008.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Advanced_Firmware_v1.1.8_en.zip\",\"Phantom_3_Advanced_Firmware_v1.1.8_en.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.01.0009.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Advanced_Firmware_v1.1.9_en.zip\",\"Phantom_3_Advanced_Firmware_v1.1.9_en.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.02.0007.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Advanced_Firmware_v1.2.7_en.zip\",\"Phantom_3_Advanced_Firmware_v1.2.7_en.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.02.0008.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Advanced_Firmware_v1.2.8_en.zip\",\"Phantom_3_Advanced_Firmware_v1.2.8_en.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.03.0020.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/en/Phantom_3_Advanced_Firmware_v1.3.20__en.zip\",\"Phantom_3_Advanced_Firmware_v1.3.20__en.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.04.0010.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Advanced_Firmware_v1.4.0010_en.zip\",\"Phantom_3_Advanced_Firmware_v1.4.0010_en.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.05.0030.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3S_FW_V01.05.0030.zip\",\"P3S_FW_V01.05.0030.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.06.0040.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3S_FW_V01.06.0040.zip\",\"P3S_FW_V01.06.0040.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.07.0060.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3S_FW_V01.07.0060.zip\",\"P3S_FW_V01.07.0060.zip\",7,,,\r\n\"P3S\",\"P3S_FW_V01.08.0080.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_3/P3S_FW_V01.08.0080.zip\",\"P3S_FW_V01.08.0080.zip\",3,,,\r\n\"P3S\",\"P3S_FW_V01.09.0060.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_3/P3S_FW_V01.09.0060.zip\",\"P3S_FW_V01.09.0060.zip\",7,,,\r\n\"P3S\",\"P3S_FW_V01.10.0090.bin\",\"http://www.phantomhelp.com/Phantom-3-Advanced/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_3/P3S_FW_V01.10.0090.zip\",\"P3S_FW_V01.10.0090.zip\",3,,,\r\n\"P3SE\",\"P3SE_FW_V01.01.0000.bin\",,\"https://dl.djicdn.com/downloads/phantom_3/20170331/P3SE_FW_V01.01.0000.bin\",\"P3SE_FW_V01.01.0000.bin\",3,\"2017-07-08\",46801707,\n\"P3SE\",\"P3SE_FW_V01.02.0010.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_se/P3SE_FW_V01.02.0010.bin\",\"P3SE_FW_V01.02.0010.bin\",3,\"2017-07-08\",46803413,\n\"P3SE\",\"P3SE_FW_V01.03.0020.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_se/P3SE_FW_V01.03.0020.bin\",\"P3SE_FW_V01.03.0020.bin\",3,\"2017-07-08\",46829800,\n\"P3X\",\"P3X_FW_V01.01.0006.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Professional_Firmware_v1.1.6_en.zip\",\"Phantom_3_Professional_Firmware_v1.1.6_en.zip\",7,,,\r\n\"P3X\",\"P3X_FW_V01.01.0008.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Professional_Firmware_v1.1.8_en.zip\",\"Phantom_3_Professional_Firmware_v1.1.8_en.zip\",7,,,\r\n\"P3X\",\"P3X_FW_V01.01.0009.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Professional_Firmware_v1.1.9_en.zip\",\"Phantom_3_Professional_Firmware_v1.1.9_en.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.01.1003.bin\",,\"https://www.dropbox.com/s/375t56kblxmiqw0/P3X_FW_V01.01.1003.bin?dl=1\",,3,,,\"SDK supported firmware\"\r\n\"P3X\",\"P3X_FW_V01.01.1007.bin\",\"http://www.gerhard-weinberger.at/phpBB2/viewtopic.php?f=5&t=9\",,,3,,,\"developer build\"\r\n\"P3X\",\"P3X_FW_V01.02.0006.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Professional_Firmware_v1.2.6_en.zip\",\"Phantom_3_Professional_Firmware_v1.2.6_en.zip\",7,,,\r\n\"P3X\",\"P3X_FW_V01.03.0020.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Professional_Firmware_v1.3.20_en.zip\",\"Phantom_3_Professional_Firmware_v1.3.20_en.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.04.0001.bin\",\"http://www.gerhard-weinberger.at/phpBB2/viewtopic.php?f=5&t=9\",,\"tmp_17722-P3X_FW_V01.04.00011340809002.zip\",3,,,\"developer build\"\r\n\"P3X\",\"P3X_FW_V01.04.0005.bin\",\"http://www.gerhard-weinberger.at/phpBB2/viewtopic.php?f=5&t=9\",,\"tmp_17875-P3X_FW_V01.04.0005-184638096.rar\",3,,,\"developer build\"\r\n\"P3X\",\"P3X_FW_V01.04.0010.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://download.dji-innovations.com/downloads/phantom_3/en/Phantom_3_Professional_Firmware_v1.4.0010_en.zip\",\"Phantom_3_Professional_Firmware_v1.4.0010_en.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.05.0011.bin\",\"http://www.gerhard-weinberger.at/phpBB2/viewtopic.php?f=5&t=9\",,\"tmp_21167-P3X_FW_V01.05.0011-679456768.rar\",3,,,\"developer build\"\r\n\"P3X\",\"P3X_FW_V01.05.0030.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.05.0030.zip\",\"P3X_FW_V01.05.0030.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.06.0040.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.06.0040.zip\",\"P3X_FW_V01.06.0040.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.07.0043_beta.bin\",,,,3,,,\r\n\"P3X\",\"P3X_FW_V01.07.0060.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.07.0060.zip\",\"P3X_FW_V01.07.0060.zip\",3,,,\"interesting - mi01 not encrypted\"\r\n\"P3X\",\"P3X_FW_V01.08.0080.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.08.0080.zip\",\"P3X_FW_V01.08.0080.zip\",7,,,\"interesting - mi02 encrypted\"\r\n\"P3X\",\"P3X_FW_V01.09.0021.bin\",,\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.09.0021.zip\",\"P3X_FW_V01.09.0021.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.09.0060.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.09.0060.zip\",\"P3X_FW_V01.09.0060.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.10.0090.bin\",\"http://www.phantomhelp.com/Phantom-3-Professional/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3/P3X_FW_V01.10.0090.zip\",\"P3X_FW_V01.10.0090.zip\",3,,,\r\n\"P3X\",\"P3X_FW_V01.11.0020.bin\",\"http://www.dji.com/phantom-3-pro/info#downloads\",\"https://dl.djicdn.com/downloads/phantom_3/20170706/P3P_FW_V01.11.0020.bin.zip\",\"P3P_FW_V01.11.0020.bin.zip\",7,,,\"latest available\"\r\n\"P3XS\",\"P3XS_FW_RC_V01.03.0020.bin\",,\"http://download.dji-innovations.com/downloads/phantom_3/P3XS_FW_RC_V01.03.0020.bin\",\"P3XS_FW_RC_V01.03.0020.bin\",3,\"2017-07-08\",29847336,\n\"P3XW\",\"P3XW_FW_V01.00.0010.bin\",\"http://rc-fpv.pl/viewtopic.php?f=45&p=462003\",\"https://dl.djicdn.com/downloads/phantom_3_4k/P3XW_FW_V01.00.0010.bin\",\"P3XW_FW_V01.00.0010.bin\",3,\"2017-07-08\",66227706,\r\n\"P3XW\",\"P3XW_FW_V01.01.0000.bin\",\"http://www.phantomhelp.com/Phantom-3-4K/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_4k/P3XW_FW_V01.01.0000.bin\",\"P3XW_FW_V01.01.0000.bin\",7,,66218566,\r\n\"P3XW\",\"P3XW_FW_V01.02.0010.bin\",\"http://www.phantomhelp.com/Phantom-3-4K/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_3_4k/P3XW_FW_V01.02.0010.bin\",\"P3XW_FW_V01.02.0010.bin\",3,,66259164,\r\n\"P3XW\",\"P3XW_FW_V01.03.0010.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P34K/P3XW_FW_V01.03.0010.bin\",\"P3XW_FW_V01.03.0010.bin\",3,\"2016-03-10\",65853142,\r\n\"P3XW\",\"P3XW_FW_V01.03.0020.bin\",\"http://www.phantomhelp.com/Phantom-3-4K/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_3_4k/P3XW_FW_V01.03.0020.bin\",\"P3XW_FW_V01.03.0020.bin\",3,\"2016-03-09\",66263232,\r\n\"P3XW\",\"P3XW_FW_V01.04.0030.bin\",\"http://www.phantomhelp.com/Phantom-3-4K/#FirmwareArchive\",\"https://dl.djicdn.com/downloads/phantom_3_4k/P3XW_FW_V01.04.0030.bin\",\"P3XW_FW_V01.04.0030.bin\",3,,66266844,\r\n\"P3XW\",\"P3XW_FW_V01.04.0036.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P34K/P3XW_FW_V01.04.0036.bin\",\"P3XW_FW_V01.04.0036.bin\",3,\"2016-04-26\",66449328,\r\n\"P3XW\",\"P3XW_FW_V01.04.0037.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/P34K/P3XW_FW_V01.04.0037.bin\",\"P3XW_FW_V01.04.0037.bin\",3,\"2016-04-26\",7995634,\r\n\"P3XW\",\"P3XW_FW_V01.05.0040.bin\",\"http://www.phantomhelp.com/Phantom-3-4K/#FirmwareArchive\",\"http://dl.djicdn.com/downloads/phantom_3_4k/P3XW_FW_V01.05.0040.bin\",\"P3XW_FW_V01.05.0040.bin\",7,\"2016-05-09\",66449328,\r\n\"P3XW\",\"P3XW_FW_V01.06.0050.bin\",,\"https://dl.djicdn.com/downloads/phantom_3_4k/P3XW_FW_V01.06.0050.bin\",\"P3XW_FW_V01.06.0050.bin\",3,\"2017-07-08\",66383616,\n\"RTK\",\"RTK_FW_V01.00.00.13.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.13.bin\",\"RTK_FW_V01.00.00.13.bin\",3,\"2016-06-03\",27391808,\r\n\"RTK\",\"RTK_FW_V01.00.00.14.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.14.bin\",\"RTK_FW_V01.00.00.14.bin\",7,\"2016-06-07\",27391808,\r\n\"RTK\",\"RTK_FW_V01.00.00.15.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.15.bin\",\"RTK_FW_V01.00.00.15.bin\",3,\"2016-06-07\",27391808,\r\n\"RTK\",\"RTK_FW_V01.00.00.16.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.16.bin\",\"RTK_FW_V01.00.00.16.bin\",3,\"2016-06-07\",27391808,\r\n\"RTK\",\"RTK_FW_V01.00.00.17.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.17.bin\",\"RTK_FW_V01.00.00.17.bin\",3,\"2016-06-07\",27391808,\r\n\"RTK\",\"RTK_FW_V01.00.00.18.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.18.bin\",\"RTK_FW_V01.00.00.18.bin\",3,\"2016-10-21\",27391816,\r\n\"RTK\",\"RTK_FW_V01.00.00.19.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.19.bin\",\"RTK_FW_V01.00.00.19.bin\",7,\"2016-11-09\",27403112,\r\n\"RTK\",\"RTK_FW_V01.00.00.21.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/RTK/RTK_FW_V01.00.00.21.bin\",\"RTK_FW_V01.00.00.21.bin\",3,\"2016-12-28\",27392004,\r\n\"RTK\",\"RTK_FW_V01.00.0090.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/M600/RTK_FW_V01.00.0090.bin\",\"RTK_FW_V01.00.0090.bin\",3,\"2016-09-29\",27391816,\r\n\"WM610\",\"WM610_FW_V01.02.01.03.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/en/Inspire_1_Firmwarev1.2.01.03_en.zip\",\"Inspire_1_Firmwarev1.2.01.03_en.zip\",3,\"2015-05-04\",39302640,\r\n\"WM610\",\"WM610_FW_V01.02.01.03.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/cn/Inspire_1_Firmwarev1.2.01.03_cn.zip\",\"Inspire_1_Firmwarev1.2.01.03_cn.zip\",1,\"2015-05-04\",0,\r\n\"WM610\",\"WM610_FW_V01.02.01.06.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/en/Inspire_1_Firmwarev1.2.1.06_en.zip\",\"Inspire_1_Firmwarev1.2.1.06_en.zip\",3,\"2015-05-26\",39302772,\r\n\"WM610\",\"WM610_FW_V01.02.01.06.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/cn/Inspire_1_Firmwarev1.2.1.06_cn.zip\",\"Inspire_1_Firmwarev1.2.1.06_cn.zip\",1,\"2015-05-26\",0,\r\n\"WM610\",\"WM610_FW_V01.03.00.00.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/en/Inspire_1_Firmwarev1.3.0.00_en.zip\",\"Inspire_1_Firmwarev1.3.0.00_en.zip\",3,\"2015-08-03\",87206772,\r\n\"WM610\",\"WM610_FW_V01.03.00.00.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/cn/Inspire_1_Firmwarev1.3.0.00_cn.zip\",\"Inspire_1_Firmwarev1.3.0.00_cn.zip\",1,\"2015-08-03\",0,\r\n\"WM610\",\"WM610_FW_V01.04.00.10.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/en/Inspire_1_Firmwarev1.4.0.10_en.zip\",\"Inspire_1_Firmwarev1.4.0.10_en.zip\",3,\"2015-09-06\",65995754,\r\n\"WM610\",\"WM610_FW_V01.04.00.10.bin\",,\"http://dl.djicdn.com/downloads/inspire_1/cn/Inspire_1_Firmwarev1.4.0.10_cn.zip\",\"Inspire_1_Firmwarev1.4.0.10_cn.zip\",1,\"2015-09-06\",0,\r\n\"WM610\",\"WM610_FW_V01.05.00.30.bin\",,\"https://dl.djicdn.com/downloads/inspire_1/WM610_FW_V01.05.00.30.zip\",\"WM610_FW_V01.05.00.30.zip\",3,\"2015-12-07\",75899402,\r\n\"WM610\",\"WM610_FW_V01.06.00.40.bin\",,\"https://dl.djicdn.com/downloads/inspire_1/WM610_FW_V01.06.00.40.zip\",\"WM610_FW_V01.06.00.40.zip\",3,\"2015-12-22\",75904266,\r\n\"WM610\",\"WM610_FW_V01.07.00.90.bin\",,\"https://dl.djicdn.com/downloads/inspire_1/WM610_FW_V01.07.00.90.zip\",\"WM610_FW_V01.07.00.90.zip\",3,\"2016-03-16\",73866254,\r\n\"WM610\",\"WM610_FW_V01.08.00.92.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/inspire1/WM610_FW_V01.08.00.92.bin\",\"WM610_FW_V01.08.00.92.bin\",7,\"2016-03-24\",73871782,\r\n\"WM610\",\"WM610_FW_V01.08.01.00.bin\",,\"https://dl.djicdn.com/downloads/inspire_1/WM610_FW_V01.08.01.00.zip\",\"WM610_FW_V01.08.01.00.zip\",3,\"2016-09-29\",73871782,\r\n\"WM610\",\"WM610_FW_V01.11.01.50.bin\",,\"https://dl.djicdn.com/downloads/inspire_1/20170710/WM610_FW_V01.11.01.50.zip\",\"WM610_FW_V01.11.01.50.zip\",3,\"2017-07-10\",73350122,\r\n\"WM610_FC350Z\",\"WM610_FC350Z_FW_V01.09.01.40.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/Z3/WM610_FC350Z_FW_V01.09.01.40.bin\",\"WM610_FC350Z_FW_V01.09.01.40.bin\",3,\"2016-11-09\",64079390,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.00.00.30.bin\",,\"http://www.panorobot.com/dji/download/inspirepro/Inspire_1_Pro_Firmware_v1.0.0.30.zip\",\"Inspire_1_Pro_Firmware_v1.0.0.30.zip\",3,\"2015-09-30\",0,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.01.00.40.bin\",,\"http://www.panorobot.com/dji/download/inspirepro/Inspire_1_Pro_Firmware_v1.1.0.40.zip\",\"Inspire_1_Pro_Firmware_v1.1.0.40.zip\",3,\"2015-11-24\",0,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.02.00.50.bin\",,\"http://www.panorobot.com/dji/download/inspirepro/Inspire_1_Pro_Firmware_1210.zip\",\"Inspire_1_Pro_Firmware_1210.zip\",3,\"2015-12-10\",0,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.03.00.60.bin\",,\"http://www.panorobot.com/dji/download/inspirepro/WM610_FC550_FW_V01.03.00.60.zip\",\"WM610_FC550_FW_V01.03.00.60.zip\",3,\"2015-12-22\",0,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.04.00.70.bin\",,\"http://www.panorobot.com/dji/download/inspirepro/WM610_FC550_FW_V01.04.00.70.zip\",\"WM610_FC550_FW_V01.04.00.70.zip\",3,\"2016-03-15\",0,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.08.00.92.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/inspire1/WM610_FC550_FW_V01.08.00.92.bin\",\"WM610_FC550_FW_V01.08.00.92.bin\",3,\"2016-03-24\",70480246,\r\n\"WM610_FC550\",\"WM610_FC550_FW_V01.08.01.00.bin\",,\"http://www.panorobot.com/dji/download/inspirepro/WM610_FC550_FW_V01.08.01.00.zip\",\"WM610_FC550_FW_V01.08.01.00.zip\",3,\"2016-04-07\",0,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.01.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.01.bin\",\"ZT300_FW_V01.00.00.01.bin\",3,\"2016-05-30\",89974,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.02.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.02.bin\",\"ZT300_FW_V01.00.00.02.bin\",3,\"2016-06-03\",90486,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.03.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.03.bin\",\"ZT300_FW_V01.00.00.03.bin\",3,\"2016-06-03\",90486,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.04.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.04.bin\",\"ZT300_FW_V01.00.00.04.bin\",3,\"2016-06-03\",90486,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.05.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.05.bin\",\"ZT300_FW_V01.00.00.05.bin\",3,\"2016-06-07\",90486,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.06.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.06.bin\",\"ZT300_FW_V01.00.00.06.bin\",3,\"2016-07-06\",90230,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.07.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.07.bin\",\"ZT300_FW_V01.00.00.07.bin\",3,\"2016-07-07\",90998,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.08.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.08.bin\",\"ZT300_FW_V01.00.00.08.bin\",3,\"2016-07-11\",90998,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.10.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.10.bin\",\"ZT300_FW_V01.00.00.10.bin\",3,\"2016-07-13\",91254,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.11.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.11.bin\",\"ZT300_FW_V01.00.00.11.bin\",3,\"2016-07-28\",91254,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.12.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.12.bin\",\"ZT300_FW_V01.00.00.12.bin\",3,\"2016-08-26\",91254,\r\n\"ZT300\",\"ZT300_FW_V01.00.00.13.bin\",,\"https://s3-ap-northeast-1.amazonaws.com/dji-firmware-test/ZT300/ZT300_FW_V01.00.00.13.bin\",\"ZT300_FW_V01.00.00.13.bin\",3,\"2016-10-20\",91254,\r\n"
        },
        {
          "name": "symbols",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}