{
  "metadata": {
    "timestamp": 1736710135692,
    "page": 784,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gurnec/HashCheck",
      "stars": 1787,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2119140625,
          "content": "/HashCheck.sdf\r\n/HashCheck.opensdf\r\n*.vcxproj.user\r\n*.csproj.user\r\n*.suo\r\n/Bin\r\n/Obj\r\n/installer/*.exe\r\n/installer/*.exe.sha*\r\n/*.VC.db\r\n/*.VC.VC.opendb\r\n/packages\r\n/UnitTests/bin\r\n/UnitTests/obj\r\n/UnitTests/vectors\r\n"
        },
        {
          "name": "CHashCheck.cpp",
          "type": "blob",
          "size": 8.375,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"CHashCheck.hpp\"\r\n#include \"HashCheckUI.h\"\r\n#include \"HashCheckOptions.h\"\r\n\r\nCHashCheck::CHashCheck( )\r\n{\r\n    InterlockedIncrement(&g_cRefThisDll);\r\n    m_cRef = 1;\r\n    m_hList = NULL;\r\n    m_hMenuBitmap = g_uWinVer >= 0x0600 ?  // Vista+\r\n        (HBITMAP)LoadImage(g_hModThisDll, MAKEINTRESOURCE(IDI_MENUBITMAP), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION) :\r\n        NULL;\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::QueryInterface( REFIID riid, LPVOID *ppv )\r\n{\r\n\tif (IsEqualIID(riid, IID_IUnknown))\r\n\t{\r\n\t\t*ppv = this;\r\n\t}\r\n\telse if (IsEqualIID(riid, IID_IShellExtInit))\r\n\t{\r\n\t\t*ppv = (LPSHELLEXTINIT)this;\r\n\t}\r\n\telse if (IsEqualIID(riid, IID_IContextMenu))\r\n\t{\r\n\t\t*ppv = (LPCONTEXTMENU)this;\r\n\t}\r\n\telse if (IsEqualIID(riid, IID_IShellPropSheetExt))\r\n\t{\r\n\t\t*ppv = (LPSHELLPROPSHEETEXT)this;\r\n\t}\r\n\telse if (IsEqualIID(riid, IID_IDropTarget))\r\n\t{\r\n\t\t*ppv = (LPDROPTARGET)this;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t*ppv = NULL;\r\n\t\treturn(E_NOINTERFACE);\r\n\t}\r\n\r\n\tAddRef();\r\n\treturn(S_OK);\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::Initialize( LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdtobj, HKEY hkeyProgID )\r\n{\r\n\t// We'll be needing a buffer, and let's double it just to be safe\r\n\tTCHAR szPath[MAX_PATH << 1];\r\n\r\n\t// Make sure that we are working with a fresh list\r\n\tSLRelease(m_hList);\r\n\tm_hList = SLCreate();\r\n\r\n\t// This indent exists to facilitate diffing against the CmdOpen source\r\n\t{\r\n\t\tFORMATETC format = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };\r\n\t\tSTGMEDIUM medium;\r\n\r\n\t\tif (!pdtobj || pdtobj->GetData(&format, &medium) != S_OK)\r\n\t\t\treturn(E_INVALIDARG);\r\n\r\n\t\tif (HDROP hDrop = (HDROP)GlobalLock(medium.hGlobal))\r\n\t\t{\r\n\t\t\tUINT uDrops = DragQueryFile(hDrop, -1, NULL, 0);\r\n\r\n\t\t\tfor (UINT uDrop = 0; uDrop < uDrops; ++uDrop)\r\n\t\t\t{\r\n\t\t\t\tif (DragQueryFile(hDrop, uDrop, szPath, countof(szPath)))\r\n\t\t\t\t{\r\n\t\t\t\t\tSLAddStringI(m_hList, szPath);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tGlobalUnlock(medium.hGlobal);\r\n\t\t}\r\n\r\n\t\tReleaseStgMedium(&medium);\r\n\t}\r\n\r\n\r\n\t// If there was any failure, the list would be empty...\r\n\treturn((SLCheck(m_hList)) ? S_OK : E_INVALIDARG);\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::QueryContextMenu( HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags )\r\n{\r\n\tif (uFlags & (CMF_DEFAULTONLY | CMF_NOVERBS))\r\n\t\treturn(MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NULL, 0));\r\n\r\n\t// Ugly hack: work around a bug in Windows 5.x that causes a spurious\r\n\t// separator to be added when invoking the context menu from the Start Menu\r\n\tif (g_uWinVer < 0x0600 && !(uFlags & (0x20000 | CMF_EXPLORE)) && GetModuleHandleA(\"explorer.exe\"))\r\n\t\treturn(MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NULL, 0));\r\n\r\n\t// Load the menu display settings\r\n\tHASHCHECKOPTIONS opt;\r\n\topt.dwFlags = HCOF_MENUDISPLAY;\r\n\tOptionsLoad(&opt);\r\n\r\n\t// Do not show if the settings prohibit it\r\n\tif (opt.dwMenuDisplay == 2 || (opt.dwMenuDisplay == 1 && !(uFlags & CMF_EXTENDEDVERBS)))\r\n\t\treturn(MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NULL, 0));\r\n\r\n    if (! InsertMenu(hmenu, indexMenu, MF_SEPARATOR | MF_BYPOSITION, 0, NULL))\r\n        return(MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NULL, 0));\r\n\r\n\t// Load the localized menu text\r\n\tTCHAR szMenuText[MAX_STRINGMSG];\r\n\tLoadString(g_hModThisDll, IDS_HS_MENUTEXT, szMenuText, countof(szMenuText));\r\n\r\n    MENUITEMINFO mii;\r\n    mii.cbSize     = sizeof(mii);\r\n    mii.fMask      = MIIM_FTYPE | MIIM_ID | MIIM_STRING;\r\n    if (g_uWinVer >= 0x0600)  // prior to Vista, 32-bit bitmaps w/alpha channels don't render correctly in menus\r\n        mii.fMask |= MIIM_BITMAP;\r\n    mii.fType      = MFT_STRING;\r\n    mii.wID        = idCmdFirst;\r\n    mii.dwTypeData = szMenuText;\r\n    mii.hbmpItem   = m_hMenuBitmap;\r\n\tif (! InsertMenuItem(hmenu, indexMenu + 1, TRUE, &mii))\r\n\t\treturn(MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NULL, 0));\r\n\r\n    InsertMenu(hmenu, indexMenu + 2, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);\r\n\r\n\treturn(MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_NULL, 1));\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::InvokeCommand( LPCMINVOKECOMMANDINFO pici )\r\n{\r\n\t// Ignore string verbs (high word must be zero)\r\n\t// The only valid command index is 0 (low word must be zero)\r\n\tif (pici->lpVerb)\r\n\t\treturn(E_INVALIDARG);\r\n\r\n\t// Hand things over to HashSave, where all the work is done...\r\n\tHashSaveStart(pici->hwnd, m_hList);\r\n\r\n\t// HaveSave has AddRef'ed and now owns our list\r\n\tSLRelease(m_hList);\r\n\tm_hList = NULL;\r\n\r\n\treturn(S_OK);\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::GetCommandString( UINT_PTR idCmd, UINT uFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax )\r\n{\r\n\tstatic const  CHAR szVerbA[] =  \"cksum\";\r\n\tstatic const WCHAR szVerbW[] = L\"cksum\";\r\n\r\n\tif (idCmd != 0 || cchMax < countof(szVerbW))\r\n\t\treturn(E_INVALIDARG);\r\n\r\n\tswitch (uFlags)\r\n\t{\r\n\t\t// The help text (status bar text) should not contain any of the\r\n\t\t// characters added for the menu access keys.\r\n\r\n\t\tcase GCS_HELPTEXTA:\r\n\t\t{\r\n\t\t\tLoadStringA(g_hModThisDll, IDS_HS_MENUTEXT, (LPSTR)pszName, cchMax);\r\n\r\n\t\t\tLPSTR lpszSrcA = (LPSTR)pszName;\r\n\t\t\tLPSTR lpszDestA = (LPSTR)pszName;\r\n\r\n\t\t\twhile (*lpszSrcA && *lpszSrcA != '(' && *lpszSrcA != '.')\r\n\t\t\t{\r\n\t\t\t\tif (*lpszSrcA != '&')\r\n\t\t\t\t{\r\n\t\t\t\t\t*lpszDestA = *lpszSrcA;\r\n\t\t\t\t\t++lpszDestA;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++lpszSrcA;\r\n\t\t\t}\r\n\r\n\t\t\t*lpszDestA = 0;\r\n\t\t\treturn(S_OK);\r\n\t\t}\r\n\r\n\t\tcase GCS_HELPTEXTW:\r\n\t\t{\r\n\t\t\tLoadStringW(g_hModThisDll, IDS_HS_MENUTEXT, (LPWSTR)pszName, cchMax);\r\n\r\n\t\t\tLPWSTR lpszSrcW = (LPWSTR)pszName;\r\n\t\t\tLPWSTR lpszDestW = (LPWSTR)pszName;\r\n\r\n\t\t\twhile (*lpszSrcW && *lpszSrcW != L'(' && *lpszSrcW != L'.')\r\n\t\t\t{\r\n\t\t\t\tif (*lpszSrcW != L'&')\r\n\t\t\t\t{\r\n\t\t\t\t\t*lpszDestW = *lpszSrcW;\r\n\t\t\t\t\t++lpszDestW;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++lpszSrcW;\r\n\t\t\t}\r\n\r\n\t\t\t*lpszDestW = 0;\r\n\t\t\treturn(S_OK);\r\n\t\t}\r\n\r\n\t\tcase GCS_VERBA:\r\n\t\t{\r\n\t\t\tSSStaticCpyA((LPSTR)pszName, szVerbA);\r\n\t\t\treturn(S_OK);\r\n\t\t}\r\n\r\n\t\tcase GCS_VERBW:\r\n\t\t{\r\n\t\t\tSSStaticCpyW((LPWSTR)pszName, szVerbW);\r\n\t\t\treturn(S_OK);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(E_INVALIDARG);\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::AddPages( LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam )\r\n{\r\n\tPROPSHEETPAGE psp;\r\n\tpsp.dwSize = sizeof(psp);\r\n\tpsp.dwFlags = PSP_USECALLBACK | PSP_USEREFPARENT | PSP_USETITLE;\r\n\tpsp.hInstance = g_hModThisDll;\r\n\tpsp.pszTemplate = MAKEINTRESOURCE(IDD_HASHPROP);\r\n\tpsp.pszTitle = MAKEINTRESOURCE(IDS_HP_TITLE);\r\n\tpsp.pfnDlgProc = HashPropDlgProc;\r\n\tpsp.lParam = (LPARAM)m_hList;\r\n\tpsp.pfnCallback = HashPropCallback;\r\n\tpsp.pcRefParent = (PUINT)&g_cRefThisDll;\r\n\r\n\tif (ActivateManifest(FALSE))\r\n\t{\r\n\t\tpsp.dwFlags |= PSP_USEFUSIONCONTEXT;\r\n\t\tpsp.hActCtx = g_hActCtx;\r\n\t}\r\n\r\n\tHPROPSHEETPAGE hPage = CreatePropertySheetPage(&psp);\r\n\r\n\tif (hPage && !pfnAddPage(hPage, lParam))\r\n\t\tDestroyPropertySheetPage(hPage);\r\n\r\n\t// HashProp has AddRef'ed and now owns our list\r\n\tSLRelease(m_hList);\r\n\tm_hList = NULL;\r\n\r\n\treturn(S_OK);\r\n}\r\n\r\nSTDMETHODIMP CHashCheck::Drop( LPDATAOBJECT pdtobj, DWORD grfKeyState, POINTL pt, PDWORD pdwEffect )\r\n{\r\n\tFORMATETC format = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };\r\n\tSTGMEDIUM medium;\r\n\r\n\tUINT uThreads = 0;\r\n\r\n\tif (pdtobj && pdtobj->GetData(&format, &medium) == S_OK)\r\n\t{\r\n\t\tif (HDROP hDrop = (HDROP)GlobalLock(medium.hGlobal))\r\n\t\t{\r\n\t\t\tUINT uDrops = DragQueryFile(hDrop, -1, NULL, 0);\r\n\t\t\tUINT cchPath;\r\n\t\t\tLPTSTR lpszPath;\r\n\r\n\t\t\t// Reduce the likelihood of a race condition when trying to create\r\n\t\t\t// an activation context by creating it before creating threads\r\n\t\t\tActivateManifest(FALSE);\r\n\r\n\t\t\tfor (UINT uDrop = 0; uDrop < uDrops; ++uDrop)\r\n\t\t\t{\r\n\t\t\t\tif ( (cchPath = DragQueryFile(hDrop, uDrop, NULL, 0)) &&\r\n\t\t\t\t     (lpszPath = (LPTSTR)malloc((cchPath + 1) * sizeof(TCHAR))) )\r\n\t\t\t\t{\r\n\t\t\t\t\tInterlockedIncrement(&g_cRefThisDll);\r\n\r\n\t\t\t\t\tHANDLE hThread;\r\n\r\n\t\t\t\t\tif ( (DragQueryFile(hDrop, uDrop, lpszPath, cchPath + 1) == cchPath) &&\r\n\t\t\t\t\t     (!(GetFileAttributes(lpszPath) & FILE_ATTRIBUTE_DIRECTORY)) &&\r\n\t\t\t\t\t     (hThread = CreateThreadCRT(HashVerifyThread, lpszPath)) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// The thread should free lpszPath, not us\r\n\t\t\t\t\t\tCloseHandle(hThread);\r\n\t\t\t\t\t\t++uThreads;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfree(lpszPath);\r\n\t\t\t\t\t\tInterlockedDecrement(&g_cRefThisDll);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tGlobalUnlock(medium.hGlobal);\r\n\t\t}\r\n\r\n\t\tReleaseStgMedium(&medium);\r\n\t}\r\n\r\n\tif (uThreads)\r\n\t{\r\n\t\t// DROPEFFECT_LINK would work here as well; it really doesn't matter\r\n\t\t*pdwEffect = DROPEFFECT_COPY;\r\n\t\treturn(S_OK);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// We shouldn't ever be hitting this case\r\n\t\t*pdwEffect = DROPEFFECT_NONE;\r\n\t\treturn(E_INVALIDARG);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "CHashCheck.hpp",
          "type": "blob",
          "size": 1.88671875,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __CHASHCHECK_HPP__\r\n#define __CHASHCHECK_HPP__\r\n\r\n#include \"globals.h\"\r\n\r\nclass CHashCheck : public IShellExtInit, IContextMenu, IShellPropSheetExt, IDropTarget\r\n{\r\n\tprotected:\r\n\t\tCREF m_cRef;\r\n\t\tHSIMPLELIST m_hList;\r\n        HBITMAP m_hMenuBitmap;\r\n\r\n\tpublic:\r\n\t\tCHashCheck( );\r\n\t\t~CHashCheck() { InterlockedDecrement(&g_cRefThisDll); SLRelease(m_hList); if (m_hMenuBitmap) DeleteObject(m_hMenuBitmap); }\r\n\r\n\t\t// IUnknown members\r\n\t\tSTDMETHODIMP QueryInterface( REFIID, LPVOID * );\r\n\t\tSTDMETHODIMP_(ULONG) AddRef( ) { return(InterlockedIncrement(&m_cRef)); }\r\n\t\tSTDMETHODIMP_(ULONG) Release( )\r\n\t\t{\r\n\t\t\t// We need a non-volatile variable, hence the cRef variable\r\n\t\t\tLONG cRef = InterlockedDecrement(&m_cRef);\r\n\t\t\tif (cRef == 0) delete this;\r\n\t\t\treturn(cRef);\r\n\t\t}\r\n\r\n\t\t// IShellExtInit members\r\n\t\tSTDMETHODIMP Initialize( LPCITEMIDLIST, LPDATAOBJECT, HKEY );\r\n\r\n\t\t// IContextMenu members\r\n\t\tSTDMETHODIMP QueryContextMenu( HMENU, UINT, UINT, UINT, UINT );\r\n\t\tSTDMETHODIMP InvokeCommand( LPCMINVOKECOMMANDINFO );\r\n\t\tSTDMETHODIMP GetCommandString( UINT_PTR, UINT, UINT *, LPSTR, UINT );\r\n\r\n\t\t// IShellPropSheetExt members\r\n\t\tSTDMETHODIMP AddPages( LPFNADDPROPSHEETPAGE, LPARAM );\r\n\t\tSTDMETHODIMP ReplacePage( UINT, LPFNADDPROPSHEETPAGE, LPARAM ) { return(E_NOTIMPL); }\r\n\r\n\t\t// IDropTarget members\r\n\t\tSTDMETHODIMP DragEnter( LPDATAOBJECT, DWORD, POINTL, PDWORD )  { return(E_NOTIMPL); }\r\n\t\tSTDMETHODIMP DragOver( DWORD, POINTL, PDWORD )                 { return(E_NOTIMPL); }\r\n\t\tSTDMETHODIMP DragLeave( )                                      { return(E_NOTIMPL); }\r\n\t\tSTDMETHODIMP Drop( LPDATAOBJECT, DWORD, POINTL, PDWORD );\r\n};\r\n\r\ntypedef CHashCheck *LPCHASHCHECK;\r\n\r\n#endif\r\n"
        },
        {
          "name": "CHashCheckClassFactory.cpp",
          "type": "blob",
          "size": 0.9853515625,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"CHashCheckClassFactory.hpp\"\r\n#include \"CHashCheck.hpp\"\r\n\r\nSTDMETHODIMP CHashCheckClassFactory::QueryInterface( REFIID riid, LPVOID *ppv )\r\n{\r\n\tif (IsEqualIID(riid, IID_IUnknown))\r\n\t{\r\n\t\t*ppv = this;\r\n\t}\r\n\telse if (IsEqualIID(riid, IID_IClassFactory))\r\n\t{\r\n\t\t*ppv = (LPCLASSFACTORY)this;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t*ppv = NULL;\r\n\t\treturn(E_NOINTERFACE);\r\n\t}\r\n\r\n\tAddRef();\r\n\treturn(S_OK);\r\n}\r\n\r\nSTDMETHODIMP CHashCheckClassFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppv )\r\n{\r\n\t*ppv = NULL;\r\n\r\n\tif (pUnkOuter) return(CLASS_E_NOAGGREGATION);\r\n\r\n\tLPCHASHCHECK lpHashCheck = new CHashCheck;\r\n\tif (lpHashCheck == NULL) return(E_OUTOFMEMORY);\r\n\r\n\tHRESULT hr = lpHashCheck->QueryInterface(riid, ppv);\r\n\tlpHashCheck->Release();\r\n\treturn(hr);\r\n}\r\n"
        },
        {
          "name": "CHashCheckClassFactory.hpp",
          "type": "blob",
          "size": 1.1640625,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __CHASHCHECKCLASSFACTORY_HPP__\r\n#define __CHASHCHECKCLASSFACTORY_HPP__\r\n\r\n#include \"globals.h\"\r\n\r\nclass CHashCheckClassFactory : public IClassFactory\r\n{\r\n\tprotected:\r\n\t\tCREF m_cRef;\r\n\r\n\tpublic:\r\n\t\tCHashCheckClassFactory( ) { InterlockedIncrement(&g_cRefThisDll); m_cRef = 1; }\r\n\t\t~CHashCheckClassFactory( ) { InterlockedDecrement(&g_cRefThisDll); }\r\n\r\n\t\t// IUnknown members\r\n\t\tSTDMETHODIMP QueryInterface( REFIID, LPVOID * );\r\n\t\tSTDMETHODIMP_(ULONG) AddRef( ) { return(InterlockedIncrement(&m_cRef)); }\r\n\t\tSTDMETHODIMP_(ULONG) Release( )\r\n\t\t{\r\n\t\t\t// We need a non-volatile variable, hence the cRef variable\r\n\t\t\tLONG cRef = InterlockedDecrement(&m_cRef);\r\n\t\t\tif (cRef == 0) delete this;\r\n\t\t\treturn(cRef);\r\n\t\t}\r\n\r\n\t\t// IClassFactory members\r\n\t\tSTDMETHODIMP CreateInstance( LPUNKNOWN, REFIID, LPVOID * );\r\n\t\tSTDMETHODIMP LockServer( BOOL ) { return(E_NOTIMPL); }\r\n};\r\n\r\ntypedef CHashCheckClassFactory *LPCHASHCHECKCLASSFACTORY;\r\n\r\n#endif\r\n"
        },
        {
          "name": "GetHighMSB.h",
          "type": "blob",
          "size": 1.724609375,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __GETHIGHMSB_H__\r\n#define __GETHIGHMSB_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n// LODWORD/HIDWORD helper macros\r\n#define LODWORD(ull) ((DWORD)((ull) & 0xFFFFFFFF))\r\n#define HIDWORD(ull) ((DWORD)((ull) >> 32))\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n// -----------------------------------------------------------------------------\r\n// GetHighMSB\r\n// Gets the 1-based index of the most significant bit of the upper 32-bits of\r\n// a 64-bit integer; this is the smallest number by which the integer could be\r\n// shifted so that the upper 32-bits are unused.\r\n#if _MSC_VER >= 1310\r\n#ifndef __INTRIN_H_\r\nunsigned char _BitScanReverse( unsigned long *, unsigned long );\r\n#endif\r\n\r\n#pragma intrinsic(_BitScanReverse)\r\n\r\n__forceinline UINT GetHighMSB( PULARGE_INTEGER puli )\r\n{\r\n\tUINT uIndex;\r\n\r\n\tif (_BitScanReverse(&uIndex, puli->HighPart))\r\n\t\treturn(uIndex + 1);\r\n\telse\r\n\t\treturn(0);\r\n}\r\n\r\n#elif defined(_M_IX86)\r\n#pragma warning(push)\r\n#pragma warning(disable: 4035) // returns for inline asm functions\r\n\r\n__forceinline UINT GetHighMSB( PULARGE_INTEGER puli )\r\n{\r\n\tDWORD dwHigh = puli->HighPart;\r\n\r\n\t__asm\r\n\t{\r\n\t\tbsr         eax,dwHigh\r\n\t\tjnz         done\r\n\t\tor          eax,-1\r\n\t\tdone:\r\n\t\tinc         eax\r\n\t}\r\n}\r\n\r\n#pragma warning(pop)\r\n#endif\r\n// -----------------------------------------------------------------------------\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "HashCalc.c",
          "type": "blob",
          "size": 19.1123046875,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"HashCheckCommon.h\"\r\n#include \"HashCalc.h\"\r\n#include \"UnicodeHelpers.h\"\r\n#include \"libs/WinHash.h\"\r\n#include <Strsafe.h>\r\n\r\nstatic const TCHAR SAVE_DEFAULT_NAME[] = TEXT(\"checksums\");\r\n\r\n// Due to the stupidity of the x64 compiler, the code emitted for the non-inline\r\n// function is not as efficient as it is on x86\r\n#ifdef _M_IX86\r\n#undef SSChainNCpy2\r\n#define SSChainNCpy2 SSChainNCpy2F\r\n#endif\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tFunction declarations\r\n\\*============================================================================*/\r\n\r\n// Path processing\r\nVOID WINAPI HashCalcWalkDirectory( PHASHCALCCONTEXT phcctx, PTSTR pszPath, UINT cchPath );\r\n__forceinline BOOL WINAPI IsSpecialDirectoryName( PCTSTR pszPath );\r\n__forceinline BOOL WINAPI IsDoubleSlashPath( PCTSTR pszPath );\r\n\r\n// Save helpers\r\n__forceinline VOID WINAPI HashCalcSetSavePrefix( PHASHCALCCONTEXT phcctx, PTSTR pszSave );\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tPath processing\r\n\\*============================================================================*/\r\n\r\nBOOL WINAPI HashCalcPrepare( PHASHCALCCONTEXT phcctx )\r\n{\r\n\tPTSTR pszPrev = NULL;\r\n\tPTSTR pszCurrent, pszCurrentEnd;\r\n\tUINT cbCurrent, cchCurrent;\r\n\r\n\tSLReset(phcctx->hListRaw);\r\n\r\n\twhile (pszCurrent = SLGetDataAndStepEx(phcctx->hListRaw, &cbCurrent))\r\n\t{\r\n\t\tpszCurrentEnd = BYTEADD(pszCurrent, cbCurrent);\r\n\t\tcchCurrent = cbCurrent / sizeof(TCHAR) - 1;\r\n\r\n\t\t// Get rid of the trailing slash if there is one\r\n\t\tif (cchCurrent && *(pszCurrentEnd - 1) == TEXT('\\\\'))\r\n\t\t{\r\n\t\t\t*(--pszCurrentEnd) = 0;\r\n\t\t\t--cchCurrent;\r\n\t\t\tcbCurrent -= sizeof(TCHAR);\r\n\t\t}\r\n\r\n\t\tif (pszPrev == NULL)\r\n\t\t{\r\n\t\t\t// Initialize the cchPrefix (and cchMax) for the first time; since\r\n\t\t\t// we have stripped away the trailing slash (if there was one), we\r\n\t\t\t// are guaranteed that cchPrefix < cchCurrent for the first run,\r\n\t\t\t// and that cchPrefix < cchPrev for all other iterations\r\n\r\n\t\t\tPTSTR pszTail = StrRChr(pszCurrent, pszCurrentEnd, TEXT('\\\\'));\r\n\r\n\t\t\tif (pszTail)\r\n\t\t\t\tphcctx->cchPrefix = (UINT)(pszTail - pszCurrent) + 1;\r\n\t\t\telse\r\n\t\t\t\tphcctx->cchPrefix = 0;\r\n\r\n\t\t\t// For \"\\\\\" paths, we cannot cut off any of the first two slashes\r\n\t\t\tif (phcctx->cchPrefix == 2 && IsDoubleSlashPath(pszCurrent))\r\n\t\t\t\tphcctx->cchPrefix = 0;\r\n\r\n\t\t\tphcctx->cchMax = cchCurrent;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Or, just update cchPrefix\r\n\r\n\t\t\tUINT i, j = 0, k = 0;\r\n\r\n\t\t\tfor (i = 0; i < cchCurrent && i < phcctx->cchPrefix; ++i)\r\n\t\t\t{\r\n\t\t\t\tif (pszCurrent[i] != pszPrev[i])\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tif (pszCurrent[i] == TEXT('\\\\'))\r\n\t\t\t\t{\r\n\t\t\t\t\tj = i + 1;\r\n\t\t\t\t\t++k;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// For \"\\\\\" paths, we cannot cut off any of the first two slashes\r\n\t\t\tif (cchCurrent >= 2 && IsDoubleSlashPath(pszCurrent) && k < 3)\r\n\t\t\t\tphcctx->cchPrefix = 0;\r\n\t\t\telse\r\n\t\t\t\tphcctx->cchPrefix = j;\r\n\t\t}\r\n\r\n\t\tif (cchCurrent && phcctx->hList)\r\n\t\t{\r\n\t\t\t// Finally, we can do the actual work that's needed!\r\n\r\n\t\t\tif (GetFileAttributes(pszCurrent) & FILE_ATTRIBUTE_DIRECTORY)\r\n\t\t\t{\r\n\t\t\t\tif (cchCurrent < MAX_PATH_BUFFER - 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tmemcpy(phcctx->scratch.sz, pszCurrent, cbCurrent);\r\n\t\t\t\t\tHashCalcWalkDirectory(phcctx, phcctx->scratch.sz, cchCurrent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tPHASHCALCITEM pItem = SLAddItem(phcctx->hList, NULL, sizeof(HASHCALCITEM) + cbCurrent);\r\n\r\n\t\t\t\tif (pItem)\r\n\t\t\t\t{\r\n                    pItem->results.dwFlags = 0;\r\n\t\t\t\t\tpItem->cchPath = cchCurrent;\r\n\t\t\t\t\tmemcpy(pItem->szPath, pszCurrent, cbCurrent);\r\n\r\n\t\t\t\t\tif (phcctx->cchMax < cchCurrent)\r\n\t\t\t\t\t\tphcctx->cchMax = cchCurrent;\r\n\r\n\t\t\t\t\t++phcctx->cTotal;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n        if (phcctx->status == PAUSED)\r\n            WaitForSingleObject(phcctx->hUnpauseEvent, INFINITE);\r\n        if (phcctx->status == CANCEL_REQUESTED)\r\n\t\t\treturn(FALSE);\r\n\r\n\t\tpszPrev = pszCurrent;\r\n\t}\r\n    return(TRUE);\r\n}\r\n\r\nVOID WINAPI HashCalcWalkDirectory( PHASHCALCCONTEXT phcctx, PTSTR pszPath, UINT cchPath )\r\n{\r\n\tHANDLE hFind;\r\n\tWIN32_FIND_DATA finddata;\r\n\r\n\tPTSTR pszPathAppend = pszPath + cchPath;\r\n\t*pszPathAppend = TEXT('\\\\');\r\n\tSSCpy2Ch(++pszPathAppend, TEXT('*'), 0);\r\n\r\n\tif ((hFind = FindFirstFile(pszPath, &finddata)) == INVALID_HANDLE_VALUE)\r\n\t\treturn;\r\n\r\n\tdo\r\n\t{\r\n\t\t// Add 1 to the length since we are also going to count the slash that\r\n\t\t// was added at the end of the directory\r\n\t\tUINT cchLeaf = (UINT)SSLen(finddata.cFileName) + 1;\r\n\t\tUINT cchNew = cchPath + cchLeaf;\r\n\r\n        if (phcctx->status == PAUSED)\r\n            WaitForSingleObject(phcctx->hUnpauseEvent, INFINITE);\r\n\t\tif (phcctx->status == CANCEL_REQUESTED)\r\n\t\t\tbreak;\r\n\r\n\t\tif ( (!(finddata.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)) &&\r\n\t\t     (cchNew < MAX_PATH_BUFFER - 2) )\r\n\t\t{\r\n\t\t\tSSChainNCpy(pszPathAppend, finddata.cFileName, cchLeaf);\r\n\r\n\t\t\tif (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\r\n\t\t\t{\r\n\t\t\t\t// Directory: Recurse\r\n\t\t\t\tif (!IsSpecialDirectoryName(finddata.cFileName))\r\n\t\t\t\t\tHashCalcWalkDirectory(phcctx, pszPath, cchNew);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// File: Add to the list\r\n\t\t\t\tUINT cbPathBuffer = (cchNew + 1) * sizeof(TCHAR);\r\n\t\t\t\tPHASHCALCITEM pItem = SLAddItem(phcctx->hList, NULL, sizeof(HASHCALCITEM) + cbPathBuffer);\r\n\r\n\t\t\t\tif (pItem)\r\n\t\t\t\t{\r\n                    pItem->results.dwFlags = 0;\r\n\t\t\t\t\tpItem->cchPath = cchNew;\r\n\t\t\t\t\tmemcpy(pItem->szPath, pszPath, cbPathBuffer);\r\n\r\n\t\t\t\t\tif (phcctx->cchMax < cchNew)\r\n\t\t\t\t\t\tphcctx->cchMax = cchNew;\r\n\r\n\t\t\t\t\t++phcctx->cTotal;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} while (FindNextFile(hFind, &finddata));\r\n\r\n\tFindClose(hFind);\r\n}\r\n\r\nBOOL WINAPI IsSpecialDirectoryName( PCTSTR pszPath )\r\n{\r\n\t// TRUE if name is \".\" or \"..\"\r\n\r\n\t#ifdef UNICODE\r\n\treturn(\r\n\t\t(*((UPDWORD)pszPath) == WCHARS2DWORD(L'.', 0)) ||\r\n\t\t(*((UPDWORD)pszPath) == WCHARS2DWORD(L'.', L'.') && pszPath[2] == 0)\r\n\t);\r\n\t#else\r\n\treturn(\r\n\t\t(*((UPWORD)pszPath) == CHARS2WORD('.', 0)) ||\r\n\t\t(*((UPWORD)pszPath) == CHARS2WORD('.', '.') && pszPath[2] == 0)\r\n\t);\r\n\t#endif\r\n}\r\n\r\nBOOL WINAPI IsDoubleSlashPath( PCTSTR pszPath )\r\n{\r\n\t// TRUE if string starts with \"\\\\\"\r\n\r\n\t#ifdef UNICODE\r\n\treturn(*((UPDWORD)pszPath) == WCHARS2DWORD(L'\\\\', L'\\\\'));\r\n\t#else\r\n\treturn(*((UPWORD)pszPath) == CHARS2WORD('\\\\', '\\\\'));\r\n\t#endif\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tSave dialog\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashCalcInitSave( PHASHCALCCONTEXT phcctx )\r\n{\r\n\tHWND hWnd = phcctx->hWnd;\r\n\r\n\t// We can use the extended portion of the scratch buffer for the file name\r\n\tPTSTR pszFile = (PTSTR)phcctx->scratch.ext;\r\n\r\n\t// Default result value\r\n\tphcctx->hFileOut = INVALID_HANDLE_VALUE;\r\n\r\n\t// Load settings\r\n\tphcctx->opt.dwFlags = HCOF_FILTERINDEX | HCOF_SAVEENCODING;\r\n\tOptionsLoad(&phcctx->opt);\r\n\r\n\t// Initialize the struct for the first time, if needed\r\n\tif (phcctx->ofn.lStructSize == 0)\r\n\t{\r\n\t\tphcctx->ofn.lStructSize = sizeof(phcctx->ofn);\r\n\t\tphcctx->ofn.hwndOwner = hWnd;\r\n\t\tphcctx->ofn.lpstrFilter = HASH_FILE_FILTERS;\r\n\t\tphcctx->ofn.nFilterIndex = phcctx->opt.dwFilterIndex;\r\n\t\tphcctx->ofn.lpstrFile = pszFile;\r\n\t\tphcctx->ofn.nMaxFile = MAX_PATH_BUFFER + 10;\r\n\t\tphcctx->ofn.Flags = OFN_DONTADDTORECENT | OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;\r\n\t\tphcctx->ofn.lpstrDefExt = TEXT(\"\");\r\n\r\n\t\t// Set the initial file name\r\n\t\t{\r\n\t\t\tPTSTR pszOrigPath;\r\n\r\n\t\t\tSLReset(phcctx->hListRaw);\r\n\t\t\tpszOrigPath = SLGetDataAndStep(phcctx->hListRaw);\r\n\r\n\t\t\tif (SLCheck(phcctx->hListRaw))\r\n\t\t\t{\r\n\t\t\t\t// Multiple items were selected in Explorer\r\n\t\t\t\tSSChainNCpy2(\r\n\t\t\t\t\tpszFile,\r\n\t\t\t\t\tpszOrigPath, phcctx->cchPrefix,\r\n\t\t\t\t\tSAVE_DEFAULT_NAME, countof(SAVE_DEFAULT_NAME)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Only one item was selected in Explorer (may be a single\r\n\t\t\t\t// file or a directory containing multiple files)\r\n\t\t\t\tSSChainCpyCat(pszFile, pszOrigPath, g_szHashExtsTab[phcctx->ofn.nFilterIndex - 1]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// We should also do a sanity check to make sure that the filter index\r\n\t// is set to a valid value since we depend on that to determine the format\r\n\tif ( GetSaveFileName(&phcctx->ofn) &&\r\n\t     phcctx->ofn.nFilterIndex &&\r\n\t\t phcctx->ofn.nFilterIndex <= NUM_HASHES)\r\n\t{\r\n\t\t// Save the filter in the user's preferences\r\n\t\tif (phcctx->opt.dwFilterIndex != phcctx->ofn.nFilterIndex)\r\n\t\t{\r\n\t\t\tphcctx->opt.dwFilterIndex = phcctx->ofn.nFilterIndex;\r\n\t\t\tphcctx->opt.dwFlags = HCOF_FILTERINDEX;\r\n\t\t\tOptionsSave(&phcctx->opt);\r\n\t\t}\r\n\r\n\t\t// Extension fixup: Correct the extension to match the selected\r\n\t\t// type, but only if the extension was one of the 5 in the list\r\n\t\tif (phcctx->ofn.nFileExtension)\r\n\t\t{\r\n\t\t\tPTSTR pszExt = pszFile + phcctx->ofn.nFileExtension - 1;\r\n\r\n#define HASH_EXT_CMP_OR_op(alg) StrCmpI(pszExt, HASH_EXT_##alg) == 0 ||\r\n\t\t\tif (FOR_EACH_HASH(HASH_EXT_CMP_OR_op) FALSE)  // the FALSE is to ignore the last trailing ||\r\n\t\t\t{\r\n\t\t\t\tif (StrCmpI(pszExt, g_szHashExtsTab[phcctx->ofn.nFilterIndex - 1]))\r\n\t\t\t\t\tSSCpy(pszExt, g_szHashExtsTab[phcctx->ofn.nFilterIndex - 1]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Adjust the file paths for the output path, if necessary\r\n\t\tHashCalcSetSavePrefix(phcctx, pszFile);\r\n\r\n\t\t// Open the file for output\r\n\t\tphcctx->hFileOut = CreateFile(\r\n\t\t\tpszFile,\r\n\t\t\tFILE_APPEND_DATA | DELETE,\r\n\t\t\tFILE_SHARE_READ,\r\n\t\t\tNULL,\r\n\t\t\tCREATE_ALWAYS,\r\n\t\t\tFILE_ATTRIBUTE_NORMAL,\r\n\t\t\tNULL\r\n\t\t);\r\n\r\n\t\tif (phcctx->hFileOut != INVALID_HANDLE_VALUE)\r\n\t\t{\r\n\t\t\t// The actual format will be set when HashCalcWriteResult is called\r\n\t\t\tphcctx->szFormat[0] = 0;\r\n\r\n\t\t\tif (phcctx->opt.dwSaveEncoding == 1)\r\n\t\t\t{\r\n\t\t\t\t// Write the BOM for UTF-16LE\r\n\t\t\t\tWCHAR BOM = 0xFEFF;\r\n\t\t\t\tDWORD cbWritten;\r\n\t\t\t\tWriteFile(phcctx->hFileOut, &BOM, sizeof(WCHAR), &cbWritten, NULL);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tTCHAR szMessage[MAX_STRINGMSG];\r\n\t\t\tLoadString(g_hModThisDll, IDS_HC_SAVE_ERROR, szMessage, countof(szMessage));\r\n\t\t\tMessageBox(hWnd, szMessage, NULL, MB_OK | MB_ICONERROR);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nVOID WINAPI HashCalcSetSaveFormat( PHASHCALCCONTEXT phcctx )\r\n{\r\n\t// Set szFormat if necessary\r\n\tif (phcctx->szFormat[0] == 0)\r\n\t{\r\n\t\t// Did I ever mention that I hate SFV?\r\n\t\t// The reason we tracked cchMax was because of this idiotic format\r\n\t\tif (phcctx->ofn.nFilterIndex == 1)\r\n\t\t{\r\n\t\t\tStringCchPrintf(\r\n\t\t\t\tphcctx->szFormat,\r\n\t\t\t\tcountof(phcctx->szFormat),\r\n\t\t\t\tTEXT(\"%%-%ds %%s\\r\\n\"),\r\n\t\t\t\tphcctx->cchMax - phcctx->cchAdjusted\r\n\t\t\t);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSSStaticCpy(phcctx->szFormat, TEXT(\"%s *%s\\r\\n\"));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nBOOL WINAPI HashCalcWriteResult( PHASHCALCCONTEXT phcctx, PHASHCALCITEM pItem )\r\n{\r\n\tPCTSTR pszHash;                     // will be pointed to the hash name\r\n    WCHAR szWbuffer[MAX_PATH_BUFFER];   // wide-char buffer\r\n    CHAR  szAbuffer[MAX_PATH_BUFFER];   // narrow-char buffer\r\n#ifdef UNICODE\r\n#   define szTbuffer szWbuffer\r\n#else\r\n#   define szTbuffer szAbuffer\r\n#endif\r\n    PTSTR szTbufferAppend = szTbuffer;  // current end of the buffer used to build output\r\n    size_t cchLine = MAX_PATH_BUFFER;   // starts off as count of remaining TCHARS in the buffer\r\n    PVOID pvLine;                       // will be pointed to the buffer to write out\r\n    size_t cbLine;                      // will be line length in bytes, EXCLUDING nul terminator\r\n    BOOL bRetval = TRUE;\r\n\r\n\t// If the checksum to save isn't present in the results\r\n    if (! ((1 << (phcctx->ofn.nFilterIndex - 1)) & pItem->results.dwFlags))\r\n    {\r\n        // Start with a commented-out error message - \"; UNREADABLE:\"\r\n        WCHAR szUnreadable[MAX_STRINGRES];\r\n        LoadString(g_hModThisDll, IDS_HV_STATUS_UNREADABLE, szUnreadable, MAX_STRINGRES);\r\n        StringCchPrintfEx(szTbufferAppend, cchLine, &szTbufferAppend, &cchLine, 0, TEXT(\"; %s:\\r\\n\"), szUnreadable);\r\n\r\n        // We'll still output a hash, but it will be all 0's, that way Verify will indicate an mismatch\r\n        HashCalcClearInvalid(&pItem->results, TEXT('0'));\r\n        bRetval = FALSE;\r\n    }\r\n\r\n\t// Translate the filter index to a hash\r\n\tswitch (phcctx->ofn.nFilterIndex)\r\n\t{\r\n#define HASH_INDEX_TO_RESULTS_op(alg) \\\r\n        case alg:  pszHash = pItem->results.szHex##alg;  break;\r\n        FOR_EACH_HASH(HASH_INDEX_TO_RESULTS_op)\r\n\t\tdefault: return(FALSE);\r\n\t}\r\n\r\n\t// Format the line\r\n\t#define HashCalcFormat(a, b) StringCchPrintfEx(szTbufferAppend, cchLine, &szTbufferAppend, &cchLine, 0, phcctx->szFormat, a, b)\r\n\t(phcctx->ofn.nFilterIndex == 1) ?\r\n\t\tHashCalcFormat(pItem->szPath + phcctx->cchAdjusted, pszHash) : // SFV\r\n\t\tHashCalcFormat(pszHash, pItem->szPath + phcctx->cchAdjusted);  // everything else\r\n\t#undef HashCalcFormat\r\n\r\n#ifdef _TIMED\r\n    StringCchPrintfEx(szTbufferAppend, cchLine, NULL, &cchLine, 0,\r\n                      _T(\"; Elapsed: %d ms\\r\\n\"), pItem->dwElapsed);\r\n#endif\r\n\r\n\tcchLine = MAX_PATH_BUFFER - cchLine;  // from now on cchLine is the line length in bytes, EXCLUDING nul terminator\r\n\tif (cchLine > 0)\r\n\t{\r\n\t\t// Convert to the correct encoding\r\n\t\tswitch (phcctx->opt.dwSaveEncoding)\r\n\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t{\r\n\t\t\t\t// UTF-8\r\n\t\t\t\t#ifdef UNICODE\r\n\t\t\t\tcbLine = WStrToUTF8(szWbuffer, szAbuffer, MAX_PATH_BUFFER) - 1;\r\n\t\t\t\t#else\r\n\t\t\t\t         AStrToWStr(szAbuffer, szWbuffer, MAX_PATH_BUFFER));\r\n\t\t\t\tcbLine = WStrToUTF8(szWbuffer, szAbuffer, MAX_PATH_BUFFER)) - 1;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tpvLine = szAbuffer;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase 1:\r\n\t\t\t{\r\n\t\t\t\t// UTF-16\r\n\t\t\t\t#ifndef UNICODE\r\n\t\t\t\tcchLine = AStrToWStr(szAbuffer, szWbuffer, MAX_PATH_BUFFER) - 1;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tcbLine = cchLine * sizeof(WCHAR);\r\n\t\t\t\tpvLine = szWbuffer;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase 2:\r\n\t\t\t{\r\n\t\t\t\t// ANSI\r\n\t\t\t\t#ifdef UNICODE\r\n\t\t\t\tcbLine = WStrToAStr(szWbuffer, szAbuffer, MAX_PATH_BUFFER) - 1;\r\n\t\t\t\t#else\r\n\t\t\t\tcbLine = cchLine;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tpvLine = szAbuffer;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tdefault: return(FALSE);\r\n\t\t}\r\n\r\n\t\tif (cbLine > 0)\r\n\t\t{\r\n\t\t\tINT cbWritten;\r\n\t\t\tWriteFile(phcctx->hFileOut, pvLine, (DWORD)cbLine, &cbWritten, NULL);\r\n\t\t\tif (cbLine != cbWritten) return(FALSE);\r\n\t\t}\r\n\t\telse return(FALSE);\r\n\t}\r\n\telse return(FALSE);\r\n\r\n\treturn(bRetval);\r\n}\r\n\r\nVOID WINAPI HashCalcClearInvalid( PWHRESULTEX pwhres, WCHAR cInvalid )\r\n{\r\n#ifdef UNICODE\r\n#   define _tmemset wmemset\r\n#else\r\n#   define _tmemset memset\r\n#endif\r\n\r\n#define HASH_CLEAR_INVALID_op(alg)                                                \\\r\n    if (! (pwhres->dwFlags & WHEX_CHECK##alg))                                    \\\r\n    {                                                                             \\\r\n        _tmemset(pwhres->szHex##alg, cInvalid, countof(pwhres->szHex##alg) - 1);  \\\r\n        pwhres->szHex##alg[countof(pwhres->szHex##alg) - 1] = L'\\0';              \\\r\n    }\r\n    FOR_EACH_HASH(HASH_CLEAR_INVALID_op)\r\n}\r\n\r\n// This can only succeed on Windows Vista and later;\r\n// returns FALSE on failure\r\nBOOL WINAPI HashCalcDeleteFileByHandle(HANDLE hFile)\r\n{\r\n    if (hFile == INVALID_HANDLE_VALUE)\r\n        return(FALSE);\r\n\r\n    HMODULE hKernel32 = GetModuleHandle(TEXT(\"kernel32.dll\"));\r\n    if (hKernel32 == NULL)\r\n        return(FALSE);\r\n\r\n    typedef BOOL(WINAPI* PFN_SFIBH)(_In_ HANDLE, _In_ FILE_INFO_BY_HANDLE_CLASS, _In_ LPVOID, _In_ DWORD);\r\n    PFN_SFIBH pfnSetFileInformationByHandle = (PFN_SFIBH)GetProcAddress(hKernel32, \"SetFileInformationByHandle\");\r\n    if (pfnSetFileInformationByHandle == NULL)\r\n        return(FALSE);\r\n\r\n    FILE_DISPOSITION_INFO fdi;\r\n    fdi.DeleteFile = TRUE;\r\n    return(pfnSetFileInformationByHandle(hFile, FileDispositionInfo, &fdi, sizeof(fdi)));\r\n}\r\n\r\nVOID WINAPI HashCalcSetSavePrefix( PHASHCALCCONTEXT phcctx, PTSTR pszSave )\r\n{\r\n\t// We have to be careful here about case sensitivity since we are now\r\n\t// working with a user-provided path instead of a system-provided path...\r\n\r\n\t// We want to build new paths without resorting to using \"..\", as that is\r\n\t// ugly, fragile (often more so than absolute paths), and not to mention,\r\n\t// complicated to calculate.  This means that relative paths will be used\r\n\t// only for paths within the same line of ancestry.\r\n\r\n\tBOOL bMultiSel;\r\n\tPTSTR pszOrig;\r\n\tPTSTR pszTail;\r\n\r\n\t// First, grab one of the original paths to work with\r\n\tSLReset(phcctx->hListRaw);\r\n\tpszOrig = SLGetDataAndStep(phcctx->hListRaw);\r\n\tbMultiSel = SLCheck(phcctx->hListRaw);\r\n\r\n\t// Unfortunately, we also have to contend with the possibility that one of\r\n\t// these paths may be in short name format (e.g., if the user navigates to\r\n\t// %TEMP% on a NT 5.x system)\r\n\t{\r\n\t\t// The scratch buffer's sz members are large enough for us\r\n\t\tPTSTR pszOrigLong = (PTSTR)phcctx->scratch.szW;\r\n\t\tPTSTR pszSaveLong = (PTSTR)phcctx->scratch.szA;\r\n\r\n\t\t// Copy original path to scratch and terminate\r\n\t\tpszTail = SSChainNCpy(pszOrigLong, pszOrig, phcctx->cchPrefix);\r\n\t\tpszTail[0] = 0;\r\n\r\n\t\t// Copy output path to scratch and terminate\r\n\t\tpszTail = SSChainNCpy(pszSaveLong, pszSave, phcctx->ofn.nFileOffset);\r\n\t\tpszTail[0] = 0;\r\n\r\n\t\t// Normalize both paths to LFN\r\n\t\tGetLongPathName(pszOrigLong, pszOrigLong, MAX_PATH_BUFFER);\r\n\t\tGetLongPathName(pszSaveLong, pszSaveLong, MAX_PATH_BUFFER);\r\n\r\n\t\t// We will only handle the case where they are the same, to prevent our\r\n\t\t// re-prefixing from messing up the base behavior; it is not worth the\r\n\t\t// trouble to account for LFN for all cases--just let it fall through\r\n\t\t// to an absolute path.\r\n\t\tif (StrCmpNI(pszOrigLong, pszSaveLong, MAX_PATH_BUFFER) == 0)\r\n\t\t{\r\n\t\t\tphcctx->cchAdjusted = phcctx->cchPrefix;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (pszTail = StrRChr(pszSave, NULL, TEXT('\\\\')))\r\n\t{\r\n\t\tphcctx->cchAdjusted = (UINT)(pszTail - pszSave) + 1;\r\n\r\n\t\tif (phcctx->cchAdjusted <= phcctx->cchPrefix)\r\n\t\t{\r\n\t\t\tif (StrCmpNI(pszOrig, pszSave, phcctx->cchAdjusted) == 0)\r\n\t\t\t{\r\n\t\t\t\t// If the ouput prefix is the same as or a parent of the input\r\n\t\t\t\t// prefix...\r\n\r\n\t\t\t\tif (!(IsDoubleSlashPath(pszSave) && phcctx->cchAdjusted < 3))\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (!bMultiSel)\r\n\t\t{\r\n\t\t\t// We will make an exception for the case where the user selects\r\n\t\t\t// a single directory from the Shell and then saves the output in\r\n\t\t\t// that directory...\r\n\r\n\t\t\tBOOL bEqual;\r\n\r\n\t\t\t*pszTail = 0;\r\n\t\t\tbEqual = StrCmpNI(pszOrig, pszSave, phcctx->cchAdjusted) == 0;\r\n\t\t\t*pszTail = TEXT('\\\\');\r\n\r\n\t\t\tif (bEqual) return;\r\n\t\t}\r\n\t}\r\n\r\n\t// If we have reached this point, we need to use an absolute path\r\n\r\n\tif ( pszSave[1] == TEXT(':') && phcctx->cchPrefix > 2 &&\r\n\t     StrCmpNI(pszOrig, pszSave, 2) == 0 )\r\n\t{\r\n\t\t// Omit drive letter\r\n\t\tphcctx->cchAdjusted = 2;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Full absolute path\r\n\t\tphcctx->cchAdjusted = 0;\r\n\t}\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tProgress bar\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashCalcTogglePrep( PHASHCALCCONTEXT phcctx, BOOL bState )\r\n{\r\n\tDWORD dwStyle = (DWORD)GetWindowLongPtr(phcctx->hWndPBTotal, GWL_STYLE);\r\n\r\n\tif (bState)\r\n\t{\r\n\t\tdwStyle &= ~PBS_SMOOTH;\r\n\t\tdwStyle |= PBS_MARQUEE;\r\n\t\tphcctx->dwFlags |= HCF_MARQUEE;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdwStyle |= PBS_SMOOTH;\r\n\t\tdwStyle &= ~PBS_MARQUEE;\r\n\t\tphcctx->dwFlags &= ~HCF_MARQUEE;\r\n\t}\r\n\r\n\tSetWindowLongPtr(phcctx->hWndPBTotal, GWL_STYLE, dwStyle);\r\n\tSendMessage(phcctx->hWndPBTotal, PBM_SETMARQUEE, bState, MARQUEE_INTERVAL);\r\n\r\n\tif (!bState)\r\n\t\tSendMessage(phcctx->hWndPBTotal, PBM_SETRANGE32, 0, phcctx->cTotal);\r\n}\r\n"
        },
        {
          "name": "HashCalc.h",
          "type": "blob",
          "size": 4.68359375,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __HASHCALC_H__\r\n#define __HASHCALC_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n#include \"HashCheckOptions.h\"\r\n#include \"libs/WinHash.h\"\r\n\r\n/**\r\n * Much of what is in the HashCalc module used to reside within HashProp; with\r\n * the addition of HashSave, which shares a lot of code with HashProp (but not\r\n * with HashVerify), the shared portions were spun out of HashProp to form\r\n * HashCalc.\r\n *\r\n * This sharing was tailored to reduce code duplication (both non-compiled and\r\n * compiled duplication), so there will be a little bit of waste on the part\r\n * of HashSave (e.g., scratch.ext), but it is only a few dozen KB, and this\r\n * really does simplify things a lot.\r\n **/\r\n\r\n// Constants\r\n#define RESULTS_LEN 0x200\r\n#define SCRATCH_BUFFER_SIZE (MAX_PATH_BUFFER + RESULTS_LEN)\r\n\r\n// Scratch buffer\r\ntypedef struct {\r\n\tunion\r\n\t{\r\n\t\t#ifdef UNICODE\r\n\t\tWCHAR sz[SCRATCH_BUFFER_SIZE];\r\n\t\t#endif\r\n\t\tWCHAR szW[SCRATCH_BUFFER_SIZE];\r\n\t};\r\n\tunion\r\n\t{\r\n\t\t#ifndef UNICODE\r\n\t\tCHAR sz[SCRATCH_BUFFER_SIZE * 3];\r\n\t\t#endif\r\n\t\tCHAR szA[SCRATCH_BUFFER_SIZE * 3];\r\n\t};\r\n\tBYTE ext[0x10000];  // extra padding for batching large sets of small files\r\n} HASHCALCSCRATCH, *PHASHCALCSCRATCH;\r\n\r\n// Hash creation context\r\ntypedef struct {\r\n\t// Common block (see COMMONCONTEXT)\r\n\tWORKERTHREADSTATUS status;       // thread status\r\n\tDWORD              dwFlags;      // misc. status flags\r\n\tMSGCOUNT           cSentMsgs;    // number update messages sent by the worker\r\n\tMSGCOUNT           cHandledMsgs; // number update messages processed by the UI\r\n\tHWND               hWnd;         // handle of the dialog window\r\n\tHWND               hWndPBTotal;  // cache of the IDC_PROG_TOTAL progress bar handle\r\n\tHWND               hWndPBFile;   // cache of the IDC_PROG_FILE progress bar handle\r\n\tHANDLE             hThread;      // handle of the worker thread\r\n\tHANDLE             hUnpauseEvent;// handle of the event which signals when unpaused\r\n\tPFNWORKERMAIN      pfnWorkerMain;// worker function executed by the (non-GUI) thread\r\n\t// Members specific to HashCalc\r\n\tHSIMPLELIST        hListRaw;     // data from IShellExtInit\r\n\tHSIMPLELIST        hList;        // our expanded/processed data\r\n\tHANDLE             hFileOut;     // handle of the output file\r\n\tHFONT              hFont;        // fixed-width font for the results box: handle\r\n\tWNDPROC            wpSearchBox;  // original WNDPROC for the HashProp search box\r\n\tWNDPROC            wpResultsBox; // original WNDPROC for the HashProp results box\r\n\tUINT               cchMax;       // max length, in characters of the longest path (stupid SFV formatting)\r\n\tUINT               cchPrefix;    // number of characters to omit from the start of the path\r\n\tUINT               cchAdjusted;  // cchPrefix, adjusted for the path of the output file\r\n\tUINT               cTotal;       // total number of files\r\n\tUINT               cSuccess;     // total number of successfully hashed\r\n#ifdef _TIMED\r\n\tDWORD              dwElapsed;    // time in ms taken to compute hashes of all files\r\n#endif\r\n\tHASHCHECKOPTIONS   opt;          // HashCheck settings\r\n\tOPENFILENAME       ofn;          // struct used for the save dialog; this needs to persist\r\n\tTCHAR              szFormat[20]; // output format for wnsprintf\r\n\tUINT               obScratch;    // offset, in bytes, to the scratch, for update coalescing\r\n\tHASHCALCSCRATCH    scratch;      // scratch buffers\r\n} HASHCALCCONTEXT, *PHASHCALCCONTEXT;\r\n\r\n// Per-file data\r\ntypedef struct {\r\n\tUINT cchPath;                    // length of path in characters, not including NULL\r\n\tWHRESULTEX results;              // hash results\r\n#ifdef _TIMED\r\n\tDWORD dwElapsed;                 // time in ms taken to compute all hashes of one file\r\n#endif\r\n#pragma warning(suppress: 4200)      // nonstandard zero-sized array when compiling as C++\r\n\tTCHAR szPath[];                  // unaltered path\r\n} HASHCALCITEM, *PHASHCALCITEM;\r\n\r\n// Public functions\r\nBOOL WINAPI HashCalcPrepare( PHASHCALCCONTEXT phcctx );\r\nVOID WINAPI HashCalcInitSave( PHASHCALCCONTEXT phcctx );\r\nVOID WINAPI HashCalcSetSaveFormat( PHASHCALCCONTEXT phcctx );\r\nBOOL WINAPI HashCalcWriteResult( PHASHCALCCONTEXT phcctx, PHASHCALCITEM pItem );\r\nVOID WINAPI HashCalcClearInvalid( PWHRESULTEX pwhres, WCHAR cInvalid );\r\nBOOL WINAPI HashCalcDeleteFileByHandle( HANDLE hFile );\r\nVOID WINAPI HashCalcTogglePrep( PHASHCALCCONTEXT phcctx, BOOL bState );\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "HashCheck.bmp",
          "type": "blob",
          "size": 1.052734375,
          "content": null
        },
        {
          "name": "HashCheck.cpp",
          "type": "blob",
          "size": 18.328125,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"CHashCheck.hpp\"\r\n#include \"CHashCheckClassFactory.hpp\"\r\n#include \"RegHelpers.h\"\r\n#include \"libs/WinHash.h\"\r\n#include \"libs/Wow64.h\"\r\n#include <Strsafe.h>\r\n\r\n // Table of formerly supported Hash file extensions to be removed during install\r\nLPCTSTR szFormerHashExtsTab[] = {\r\n    _T(\".md4\")\r\n};\r\n\r\n// Bookkeeping globals (declared as extern in globals.h)\r\nHMODULE g_hModThisDll;\r\nCREF g_cRefThisDll;\r\n\r\n// Activation context cache (declared as extern in globals.h)\r\nvolatile BOOL g_bActCtxCreated;\r\nHANDLE g_hActCtx;\r\n\r\n// Major and minor Windows version (declared as extern in globals.h)\r\nUINT16 g_uWinVer;\r\n\r\n// Prototypes for the self-registration/install/uninstall helper functions\r\nSTDAPI DllRegisterServerEx( LPCTSTR );\r\nHRESULT Install( BOOL, BOOL );\r\nHRESULT Uninstall( );\r\nBOOL WINAPI InstallFile( LPCTSTR, LPTSTR, LPTSTR );\r\n\r\n\r\n#if defined(_USRDLL) && defined(_DLL)\r\n#pragma comment(linker, \"/entry:DllMain\")\r\n#endif\r\nextern \"C\" BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )\r\n{\r\n\tswitch (dwReason)\r\n\t{\r\n\t\tcase DLL_PROCESS_ATTACH:\r\n\t\t\tg_hModThisDll = hInstance;\r\n\t\t\tg_cRefThisDll = 0;\r\n\t\t\tg_bActCtxCreated = FALSE;\r\n\t\t\tg_hActCtx = INVALID_HANDLE_VALUE;\r\n\t\t\tg_uWinVer = SwapV16(LOWORD(GetVersion()));\r\n\t\t\t#ifndef _WIN64\r\n\t\t\tif (g_uWinVer < 0x0501) return(FALSE);\r\n\t\t\t#endif\r\n\t\t\t#ifdef _DLL\r\n\t\t\tDisableThreadLibraryCalls(hInstance);\r\n\t\t\t#endif\r\n\t\t\tbreak;\r\n\r\n\t\tcase DLL_PROCESS_DETACH:\r\n\t\t\tif (g_bActCtxCreated && g_hActCtx != INVALID_HANDLE_VALUE)\r\n\t\t\t\tReleaseActCtx(g_hActCtx);\r\n\t\t\tbreak;\r\n\r\n\t\tcase DLL_THREAD_ATTACH:\r\n\t\t\tbreak;\r\n\r\n\t\tcase DLL_THREAD_DETACH:\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn(TRUE);\r\n}\r\n\r\nSTDAPI DllCanUnloadNow( )\r\n{\r\n\treturn((g_cRefThisDll == 0) ? S_OK : S_FALSE);\r\n}\r\n\r\nSTDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )\r\n{\r\n\t*ppv = NULL;\r\n\r\n\tif (IsEqualIID(rclsid, CLSID_HashCheck))\r\n\t{\r\n\t\tLPCHASHCHECKCLASSFACTORY lpHashCheckClassFactory = new CHashCheckClassFactory;\r\n\t\tif (lpHashCheckClassFactory == NULL) return(E_OUTOFMEMORY);\r\n\r\n\t\tHRESULT hr = lpHashCheckClassFactory->QueryInterface(riid, ppv);\r\n\t\tlpHashCheckClassFactory->Release();\r\n\t\treturn(hr);\r\n\t}\r\n\r\n\treturn(CLASS_E_CLASSNOTAVAILABLE);\r\n}\r\n\r\nSTDAPI DllRegisterServerEx( LPCTSTR lpszModuleName )\r\n{\r\n\tHKEY hKey;\r\n\tTCHAR szBuffer[MAX_PATH << 1];\r\n\r\n\t// Register class\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"CLSID\\\\%s\"), CLSID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, NULL, CLSNAME_STR_HashCheck);\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"CLSID\\\\%s\\\\InprocServer32\"), CLSID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, NULL, lpszModuleName);\r\n\t\tRegSetSZ(hKey, TEXT(\"ThreadingModel\"), TEXT(\"Apartment\"));\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\t// Register context menu handler\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"AllFileSystemObjects\\\\ShellEx\\\\ContextMenuHandlers\\\\%s\"), CLSNAME_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, NULL, CLSID_STR_HashCheck);\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\t// Register property sheet handler\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"AllFileSystemObjects\\\\ShellEx\\\\PropertySheetHandlers\\\\%s\"), CLSNAME_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, NULL, CLSID_STR_HashCheck);\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\t// Register the HashCheck program ID\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, PROGID_STR_HashCheck, NULL, TRUE))\r\n\t{\r\n\t\tLoadString(g_hModThisDll, IDS_FILETYPE_DESC, szBuffer, countof(szBuffer));\r\n\t\tRegSetSZ(hKey, NULL, szBuffer);\r\n\r\n\t\tStringCchPrintf(szBuffer, countof(szBuffer), TEXT(\"@\\\"%s\\\",-%u\"), lpszModuleName, IDS_FILETYPE_DESC);\r\n\t\tRegSetSZ(hKey, TEXT(\"FriendlyTypeName\"), szBuffer);\r\n\r\n\t\tRegSetSZ(hKey, TEXT(\"AlwaysShowExt\"), TEXT(\"\"));\r\n\t\tRegSetSZ(hKey, TEXT(\"AppUserModelID\"), APP_USER_MODEL_ID);\r\n\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"%s\\\\DefaultIcon\"), PROGID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tStringCchPrintf(szBuffer, countof(szBuffer), TEXT(\"%s,-%u\"), lpszModuleName, IDI_FILETYPE);\r\n\t\tRegSetSZ(hKey, NULL, szBuffer);\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"%s\\\\shell\\\\open\\\\DropTarget\"), PROGID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\t// The DropTarget will be the primary way in which we are invoked\r\n\t\tRegSetSZ(hKey, TEXT(\"CLSID\"), CLSID_STR_HashCheck);\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"%s\\\\shell\\\\open\\\\command\"), PROGID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\t// This is a legacy fallback used only when DropTarget is unsupported\r\n\t\tStringCchPrintf(szBuffer, countof(szBuffer), TEXT(\"rundll32.exe \\\"%s\\\",HashVerify_RunDLL %%1\"), lpszModuleName, IDS_FILETYPE_DESC);\r\n\t\tRegSetSZ(hKey, NULL, szBuffer);\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"%s\\\\shell\\\\edit\\\\command\"), PROGID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, NULL, TEXT(\"notepad.exe %1\"));\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, TEXT(\"%s\\\\shell\"), PROGID_STR_HashCheck, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, NULL, TEXT(\"open\"));\r\n\t\tRegCloseKey(hKey);\r\n\t} else return(SELFREG_E_CLASS);\r\n\r\n\t// The actual association of .sfv/.md5/.sha1/.sha256/.sha512/.sha3-256/.sha3-512/.asc files with our program ID\r\n\t// will be handled by DllInstall, not DllRegisterServer.\r\n\r\n\t// Register approval\r\n\tif (hKey = RegOpen(HKEY_LOCAL_MACHINE, TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Shell Extensions\\\\Approved\"), NULL, TRUE))\r\n\t{\r\n\t\tRegSetSZ(hKey, CLSID_STR_HashCheck, CLSNAME_STR_HashCheck);\r\n\t\tRegCloseKey(hKey);\r\n\t}\r\n\r\n\treturn(S_OK);\r\n}\r\n\r\nSTDAPI DllRegisterServer( )\r\n{\r\n\tTCHAR szCurrentDllPath[MAX_PATH << 1];\r\n\tGetModuleFileName(g_hModThisDll, szCurrentDllPath, countof(szCurrentDllPath));\r\n\treturn(DllRegisterServerEx(szCurrentDllPath));\r\n}\r\n\r\nSTDAPI DllUnregisterServer( )\r\n{\r\n\tHKEY hKey;\r\n\tBOOL bClassRemoved = TRUE;\r\n\tBOOL bApprovalRemoved = FALSE;\r\n\r\n\t// Unregister class\r\n\tif (!RegDelete(HKEY_CLASSES_ROOT, TEXT(\"CLSID\\\\%s\"), CLSID_STR_HashCheck))\r\n\t\tbClassRemoved = FALSE;\r\n\r\n\t// Unregister handlers\r\n\tif (!Wow64CheckProcess())\r\n\t{\r\n\t\t/**\r\n\t\t * Registry reflection sucks; it means that if we try to unregister the\r\n\t\t * Wow64 extension, we'll also unregister the Win64 extension; the API\r\n\t\t * to disable reflection seems to only affect changes in value, not key\r\n\t\t * removals. :( This hack will disable the deletion of certain HKCR\r\n\t\t * keys in the case of 32-on-64, and it should be pretty safe--unless\r\n\t\t * the user had installed only the 32-bit extension without the 64-bit\r\n\t\t * extension on Win64 (which should be a very rare scenario), there\r\n\t\t * should be no undesirable effects to using this hack.\r\n\t\t **/\r\n\r\n\t\tif (!RegDelete(HKEY_CLASSES_ROOT, TEXT(\"AllFileSystemObjects\\\\ShellEx\\\\ContextMenuHandlers\\\\%s\"), CLSNAME_STR_HashCheck))\r\n\t\t\tbClassRemoved = FALSE;\r\n\r\n\t\tif (!RegDelete(HKEY_CLASSES_ROOT, TEXT(\"AllFileSystemObjects\\\\ShellEx\\\\PropertySheetHandlers\\\\%s\"), CLSNAME_STR_HashCheck))\r\n\t\t\tbClassRemoved = FALSE;\r\n\r\n\t\tif (!RegDelete(HKEY_CLASSES_ROOT, PROGID_STR_HashCheck, NULL))\r\n\t\t\tbClassRemoved = FALSE;\r\n\t}\r\n\r\n\t// Unregister approval\r\n\tif (hKey = RegOpen(HKEY_LOCAL_MACHINE, TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Shell Extensions\\\\Approved\"), NULL, FALSE))\r\n\t{\r\n\t\tLONG lResult = RegDeleteValue(hKey, CLSID_STR_HashCheck);\r\n\t\tbApprovalRemoved = (lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND);\r\n\t\tRegCloseKey(hKey);\r\n\t}\r\n\r\n\tif (!bClassRemoved) return(SELFREG_E_CLASS);\r\n\tif (!bApprovalRemoved) return(S_FALSE);\r\n\r\n\treturn(S_OK);\r\n}\r\n\r\nSTDAPI DllInstall( BOOL bInstall, LPCWSTR pszCmdLine )\r\n{\r\n\t// To install into System32\\ShellExt\r\n\t// regsvr32.exe /i /n HashCheck.dll\r\n\t//\r\n\t// To install without registering an uninstaller\r\n\t// regsvr32.exe /i:\"NoUninstall\" /n HashCheck.dll\r\n\t//\r\n\t// To install in-place (without copying the .dll anywhere)\r\n\t// regsvr32.exe /i:\"NoCopy\" /n HashCheck.dll\r\n\t//\r\n\t// To install with both options above\r\n\t// regsvr32.exe /i:\"NoUninstall NoCopy\" /n HashCheck.dll\r\n\t//\r\n\t// To uninstall\r\n\t// regsvr32.exe /u /i /n HashCheck.dll\r\n\t//\r\n\t// To install/uninstall silently\r\n\t// regsvr32.exe /s ...\r\n\t//\r\n\t// DllInstall can also be invoked from a RegisterDlls INF section or from\r\n\t// a UnregisterDlls INF section, if the registration flags are set to 2.\r\n\t// Consult the documentation for RegisterDlls/UnregisterDlls for details.\r\n\r\n\treturn( (bInstall) ?\r\n\t\tInstall(pszCmdLine == NULL || StrStrIW(pszCmdLine, L\"NoUninstall\") == NULL,\r\n                pszCmdLine == NULL || StrStrIW(pszCmdLine, L\"NoCopy\")      == NULL) :\r\n\t\tUninstall()\r\n\t);\r\n}\r\n\r\nHRESULT Install( BOOL bRegisterUninstaller, BOOL bCopyFile )\r\n{\r\n\tTCHAR szCurrentDllPath[MAX_PATH << 1];\r\n\tGetModuleFileName(g_hModThisDll, szCurrentDllPath, countof(szCurrentDllPath));\r\n\r\n\tTCHAR szSysDir[MAX_PATH + 0x20];\r\n\tUINT uSize = GetSystemDirectory(szSysDir, MAX_PATH);\r\n\r\n\tif (uSize && uSize < MAX_PATH)\r\n\t{\r\n\t\tLPTSTR lpszPath = szSysDir;\r\n\t\tLPTSTR lpszPathAppend = lpszPath + uSize;\r\n\r\n\t\tif (*(lpszPathAppend - 1) != TEXT('\\\\'))\r\n\t\t\t*lpszPathAppend++ = TEXT('\\\\');\r\n\r\n\t\tLPTSTR lpszTargetPath = (bCopyFile) ? lpszPath : szCurrentDllPath;\r\n\r\n\t\tif ( (!bCopyFile || InstallFile(szCurrentDllPath, lpszTargetPath, lpszPathAppend)) &&\r\n\t\t     DllRegisterServerEx(lpszTargetPath) == S_OK )\r\n\t\t{\r\n\t\t\tHKEY hKey, hKeySub;\r\n\r\n\t\t\t// Associate file extensions\r\n\t\t\tfor (UINT i = 0; i < countof(g_szHashExtsTab); ++i)\r\n\t\t\t{\r\n\t\t\t\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, g_szHashExtsTab[i], NULL, TRUE))\r\n\t\t\t\t{\r\n\t\t\t\t\tRegSetSZ(hKey, NULL, PROGID_STR_HashCheck);\r\n\t\t\t\t\tRegSetSZ(hKey, TEXT(\"PerceivedType\"), TEXT(\"text\"));\r\n\r\n\t\t\t\t\tif (hKeySub = RegOpen(hKey, TEXT(\"PersistentHandler\"), NULL, TRUE))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tRegSetSZ(hKeySub, NULL, TEXT(\"{5e941d80-bf96-11cd-b579-08002b30bfeb}\"));\r\n\t\t\t\t\t\tRegCloseKey(hKeySub);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tRegCloseKey(hKey);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n            // Disassociate former file extensions; see the comment in DllUnregisterServer for\r\n            // why this step is skipped for Wow64 processes\r\n            if (!Wow64CheckProcess())\r\n            {\r\n                for (UINT i = 0; i < countof(szFormerHashExtsTab); ++i)\r\n                {\r\n                    HKEY hKey;\r\n\r\n                    if (hKey = RegOpen(HKEY_CLASSES_ROOT, szFormerHashExtsTab[i], NULL, FALSE))\r\n                    {\r\n                        TCHAR szTemp[countof(PROGID_STR_HashCheck)];\r\n                        RegGetSZ(hKey, NULL, szTemp, sizeof(szTemp));\r\n                        if (_tcscmp(szTemp, PROGID_STR_HashCheck) == 0)\r\n                            RegDeleteValue(hKey, NULL);\r\n                        RegCloseKey(hKey);\r\n                    }\r\n                }\r\n            }\r\n\r\n\t\t\t// Uninstaller entries\r\n\t\t\tRegDelete(HKEY_LOCAL_MACHINE, TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\%s\"), CLSNAME_STR_HashCheck);\r\n\r\n\t\t\tif (bRegisterUninstaller && (hKey = RegOpen(HKEY_LOCAL_MACHINE, TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\%s\"), CLSNAME_STR_HashCheck, TRUE)))\r\n\t\t\t{\r\n\t\t\t\tTCHAR szUninstall[MAX_PATH << 1];\r\n\t\t\t\tStringCchPrintf(szUninstall, countof(szUninstall), TEXT(\"regsvr32.exe /u /i /n \\\"%s\\\"\"), lpszTargetPath);\r\n\r\n\t\t\t\tstatic const TCHAR szURLFull[] = TEXT(\"https://github.com/gurnec/HashCheck/issues\");\r\n\t\t\t\tTCHAR szURLBase[countof(szURLFull)];\r\n\t\t\t\tSSStaticCpy(szURLBase, szURLFull);\r\n\t\t\t\tszURLBase[35] = 0; // strlen(\"https://github.com/gurnec/HashCheck\")\r\n\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"DisplayIcon\"), lpszTargetPath);\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"DisplayName\"), TEXT(HASHCHECK_NAME_STR));\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"DisplayVersion\"), TEXT(HASHCHECK_VERSION_STR));\r\n\t\t\t\tRegSetDW(hKey, TEXT(\"EstimatedSize\"), 1073);\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"HelpLink\"), szURLFull);\r\n\t\t\t\tRegSetDW(hKey, TEXT(\"NoModify\"), 1);\r\n\t\t\t\tRegSetDW(hKey, TEXT(\"NoRepair\"), 1);\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"UninstallString\"), szUninstall);\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"URLInfoAbout\"), szURLBase);\r\n\t\t\t\tRegSetSZ(hKey, TEXT(\"URLUpdateInfo\"), TEXT(\"https://github.com/gurnec/HashCheck/releases/latest\"));\r\n\t\t\t\tRegCloseKey(hKey);\r\n\t\t\t}\r\n\r\n\t\t\treturn(S_OK);\r\n\r\n\t\t} // if copied & registered\r\n\r\n\t} // if valid sysdir\r\n\r\n\treturn(E_FAIL);\r\n}\r\n\r\nHRESULT Uninstall( )\r\n{\r\n\tHRESULT hr = S_OK;\r\n\r\n\tTCHAR szCurrentDllPath[MAX_PATH << 1];\r\n\tTCHAR szTemp[MAX_PATH << 1];\r\n\r\n\tLPTSTR lpszFileToDelete = szCurrentDllPath;\r\n\tLPTSTR lpszTempAppend = szTemp + GetModuleFileName(g_hModThisDll, szTemp, countof(szTemp));\r\n\r\n    StringCbCopy(szCurrentDllPath, sizeof(szCurrentDllPath), szTemp);\r\n\r\n#ifdef _WIN64\r\n    // If this 64-bit dll was installed to the default location,\r\n    // uninstall the 32-bit dll if it exists in its default location\r\n\r\n    TCHAR lpszDefInstallPath[MAX_PATH + 0x20];\r\n    UINT uSize = GetSystemDirectory(lpszDefInstallPath, MAX_PATH);\r\n\r\n    if (uSize && uSize < MAX_PATH)\r\n    {\r\n        LPTSTR lpszPathAppend = lpszDefInstallPath + uSize;\r\n\r\n        if (*(lpszPathAppend - 1) != TEXT('\\\\'))\r\n            *lpszPathAppend++ = TEXT('\\\\');\r\n\r\n        static const TCHAR szFolderAndFilename[] = TEXT(\"ShellExt\") TEXT(\"\\\\\") TEXT(HASHCHECK_FILENAME_STR);\r\n        SSStaticCpy(lpszPathAppend, szFolderAndFilename);\r\n\r\n        // If this 64-bit dll was installed to the default location\r\n        if (StrCmpI(szCurrentDllPath, lpszDefInstallPath) == 0)\r\n        {\r\n            TCHAR lpszSystemWow64[MAX_PATH + 0x20];\r\n            uSize = GetSystemWow64Directory(lpszSystemWow64, MAX_PATH);\r\n\r\n            if (uSize && uSize < MAX_PATH)\r\n            {\r\n                LPTSTR lpszSystemWow64Append = lpszSystemWow64 + uSize;\r\n\r\n                if (*(lpszSystemWow64Append - 1) != TEXT('\\\\'))\r\n                    SSCpy2Ch(lpszSystemWow64Append++, TEXT('\\\\'), 0);\r\n\r\n                StringCbCopyEx(lpszDefInstallPath, sizeof(lpszDefInstallPath), lpszSystemWow64, &lpszPathAppend, NULL, 0);\r\n\r\n                SSStaticCpy(lpszPathAppend, szFolderAndFilename);\r\n\r\n                // If the 32-bit dll exists in its default location\r\n                if (PathFileExists(lpszDefInstallPath))\r\n                {\r\n                    static const TCHAR szRegsvr32[] = TEXT(\"regsvr32.exe\");\r\n                    SSStaticCpy(lpszSystemWow64Append, szRegsvr32);\r\n                    // the lpszSystemWow64 buffer now contains the full regsvr32.exe path\r\n\r\n                    TCHAR lpszCommandLine[MAX_PATH + 0x20];\r\n                    LPTSTR lpszCommandLineAppend;\r\n                    \r\n                    static const TCHAR szCommandOpts[] = TEXT(\"regsvr32.exe /u /i /n /s \");\r\n                    lpszCommandLineAppend = SSStaticCpy(lpszCommandLine, szCommandOpts) - 1;\r\n\r\n                    StringCbCopy(lpszCommandLineAppend, sizeof(lpszCommandLine)-sizeof(szCommandOpts), lpszDefInstallPath);\r\n\r\n                    STARTUPINFO si;\r\n                    memset(&si, 0, sizeof(si));\r\n                    si.cb = sizeof(si);\r\n\r\n                    PROCESS_INFORMATION pi;\r\n                    memset(&pi, 0, sizeof(pi));\r\n\r\n                    if (!CreateProcess(lpszSystemWow64, lpszCommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))\r\n                        return E_FAIL;\r\n\r\n                    DWORD dwExit;\r\n                    WaitForSingleObject(pi.hProcess, INFINITE);\r\n                    GetExitCodeProcess(pi.hProcess, &dwExit);\r\n                    CloseHandle(pi.hThread);\r\n                    CloseHandle(pi.hProcess);\r\n\r\n                    if (dwExit != 0)\r\n                        return E_FAIL;\r\n                }\r\n            }\r\n        }\r\n    }\r\n#endif\r\n\r\n\t// Rename the DLL prior to scheduling it for deletion\r\n\t*lpszTempAppend++ = TEXT('.');\r\n\tSSCpy2Ch(lpszTempAppend, 0, 0);\r\n\r\n\tfor (TCHAR ch = TEXT('0'); ch <= TEXT('9'); ++ch)\r\n\t{\r\n\t\t*lpszTempAppend = ch;\r\n\r\n\t\tif (MoveFileEx(szCurrentDllPath, szTemp, MOVEFILE_REPLACE_EXISTING))\r\n\t\t{\r\n\t\t\tlpszFileToDelete = szTemp;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Schedule the DLL to be deleted at shutdown/reboot\r\n\tif (!MoveFileEx(lpszFileToDelete, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) hr = E_FAIL;\r\n\r\n\t// Unregister\r\n\tif (DllUnregisterServer() != S_OK) hr = E_FAIL;\r\n\r\n\t// Disassociate file extensions; see the comment in DllUnregisterServer for\r\n\t// why this step is skipped for Wow64 processes\r\n\tif (!Wow64CheckProcess())\r\n\t{\r\n\t\tfor (UINT i = 0; i < countof(g_szHashExtsTab); ++i)\r\n\t\t{\r\n\t\t\tHKEY hKey;\r\n\r\n\t\t\tif (hKey = RegOpen(HKEY_CLASSES_ROOT, g_szHashExtsTab[i], NULL, FALSE))\r\n\t\t\t{\r\n                RegGetSZ(hKey, NULL, szTemp, sizeof(szTemp));\r\n                if (_tcscmp(szTemp, PROGID_STR_HashCheck) == 0)\r\n                    RegDeleteValue(hKey, NULL);\r\n                RegCloseKey(hKey);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// We don't need the uninstall strings any more...\r\n\tRegDelete(HKEY_LOCAL_MACHINE, TEXT(\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\%s\"), CLSNAME_STR_HashCheck);\r\n\r\n\treturn(hr);\r\n}\r\n\r\nBOOL WINAPI InstallFile( LPCTSTR lpszSource, LPTSTR lpszDest, LPTSTR lpszDestAppend )\r\n{\r\n\tstatic const TCHAR szShellExt[] = TEXT(\"ShellExt\");\r\n\tstatic const TCHAR szDestFile[] = TEXT(\"\\\\\") TEXT(HASHCHECK_FILENAME_STR);\r\n\r\n\tSSStaticCpy(lpszDestAppend, szShellExt);\r\n\tlpszDestAppend += countof(szShellExt) - 1;\r\n\r\n\t// Create directory if necessary\r\n\tif (! PathFileExists(lpszDest))\r\n\t\tCreateDirectory(lpszDest, NULL);\r\n\r\n\tSSStaticCpy(lpszDestAppend, szDestFile);\r\n\tlpszDestAppend += countof(szDestFile) - 1;\r\n\r\n\t// No need to copy if the source and destination are the same\r\n\tif (StrCmpI(lpszSource, lpszDest) == 0)\r\n\t\treturn(TRUE);\r\n\r\n\t// If the destination file does not already exist, just copy\r\n\tif (! PathFileExists(lpszDest))\r\n\t\treturn(CopyFile(lpszSource, lpszDest, FALSE));\r\n\r\n\t// If destination file exists and cannot be overwritten\r\n\tTCHAR szTemp[MAX_PATH + 0x20];\r\n\tSIZE_T cbDest = BYTEDIFF(lpszDestAppend, lpszDest);\r\n\tLPTSTR lpszTempAppend = (LPTSTR)BYTEADD(szTemp, cbDest);\r\n\r\n\tStringCbCopy(szTemp, sizeof(szTemp), lpszDest);\r\n\t*lpszTempAppend++ = TEXT('.');\r\n\tSSCpy2Ch(lpszTempAppend, 0, 0);\r\n\r\n\tfor (TCHAR ch = TEXT('0'); ch <= TEXT('9'); ++ch)\r\n\t{\r\n\t\tif (CopyFile(lpszSource, lpszDest, FALSE))\r\n\t\t\treturn(TRUE);\r\n\r\n\t\t*lpszTempAppend = ch;\r\n\r\n\t\tif (MoveFileEx(lpszDest, szTemp, MOVEFILE_REPLACE_EXISTING))\r\n\t\t\tMoveFileEx(szTemp, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);\r\n\t}\r\n\r\n\treturn(FALSE);\r\n}\r\n"
        },
        {
          "name": "HashCheck.def",
          "type": "blob",
          "size": 0.2822265625,
          "content": "; Next base address: 0x1F030000\r\nLIBRARY HashCheck BASE=0x1F010000\r\n\r\nEXPORTS\r\n\tDllCanUnloadNow     PRIVATE\r\n\tDllGetClassObject   PRIVATE\r\n\tDllRegisterServer   PRIVATE\r\n\tDllUnregisterServer PRIVATE\r\n\tDllInstall          PRIVATE\r\n\tHashVerify_RunDLLW  PRIVATE\r\n\tShowOptions_RunDLLW PRIVATE\r\n"
        },
        {
          "name": "HashCheck.ico",
          "type": "blob",
          "size": 24.623046875,
          "content": null
        },
        {
          "name": "HashCheck.manifest",
          "type": "blob",
          "size": 0.4052734375,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r\n<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\r\n<dependency>\r\n\t<dependentAssembly>\r\n\t\t<assemblyIdentity\r\n\t\t\ttype=\"win32\"\r\n\t\t\tname=\"Microsoft.Windows.Common-Controls\"\r\n\t\t\tversion=\"6.0.0.0\"\r\n\t\t\tprocessorArchitecture=\"*\"\r\n\t\t\tpublicKeyToken=\"6595b64144ccf1df\"\r\n\t\t\tlanguage=\"*\"\r\n\t\t/>\r\n\t</dependentAssembly>\r\n</dependency>\r\n</assembly>\r\n"
        },
        {
          "name": "HashCheck.rc",
          "type": "blob",
          "size": 7.4541015625,
          "content": "//\r\n// NOTE: This file is encoded in UTF-8.\r\n//\r\n\r\n/**\r\n * Why does this resource script require version 6 or newer of the Resource\r\n * Compiler?  Microsoft's Resource Compiler (even the latest version from the\r\n * Longhorn SDK) will fail with a fatal error if #pragma code_page is used to\r\n * declare that the encoding of the resource script is double-byte Unicode\r\n * (UTF-16).  This behavior is very puzzling considering that version 5 of the\r\n * Resource Compiler found in Visual Studio 2002 thru 2005 can compile Unicode\r\n * resource scripts only if they are in the UTF-16 encoding.  So the Resource\r\n * Compiler forces the use of UTF-16, yet it does not support declaring that the\r\n * code page is UTF-16.  This is not a problem in Visual Studio 2002 thru 2005,\r\n * but in Visual Studio 6, the use of UTF-16 without the proper declaration\r\n * results in strange messages being printed by the development environment\r\n * during compilation.  As a result, it was decided that UTF-8 would be used\r\n * (which is supported only by version 6 or higher), since the Resource Compiler\r\n * does not reject the UTF-8 #pragma code_page declaration as it strangely and\r\n * mysteriously does with UTF-16.  If you do not plan on compiling with VS6, you\r\n * can simply convert from UTF-8 to UTF-16 and eliminate the #pragma code_page\r\n * declaration to enable compilation with older versions of the Resource\r\n * Compiler.\r\n **/\r\n\r\n#include <winresrc.h>\r\n#include \"HashCheckResources.h\"\r\n#include \"version.h\"\r\n\r\n// Remove the following line if using UTF-16 instead of UTF-8\r\n#pragma code_page(65001)\r\n\r\n#ifdef _DEBUG\r\n#define MY_VS_FF_DEBUG VS_FF_DEBUG\r\n#else\r\n#define MY_VS_FF_DEBUG 0x0L\r\n#endif\r\n\r\nLANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US\r\n\r\nVS_VERSION_INFO     VERSIONINFO\r\n    FILEVERSION     HASHCHECK_VERSION_FULL\r\n    PRODUCTVERSION  HASHCHECK_VERSION_FULL\r\n    FILEFLAGSMASK   VS_FFI_FILEFLAGSMASK\r\n    FILEFLAGS       MY_VS_FF_DEBUG\r\n    FILEOS          VOS_NT_WINDOWS32\r\n    FILETYPE        VFT_DLL\r\n    FILESUBTYPE     VFT2_UNKNOWN\r\n{\r\n\tBLOCK \"StringFileInfo\"\r\n\t{\r\n\t\tBLOCK \"040904b0\" // English (U.S.)\r\n\t\t{\r\n\t\t\tVALUE \"FileDescription\", HASHCHECK_NAME_STR\r\n\t\t\tVALUE \"FileVersion\", HASHCHECK_VERSION_STR ARCH_NAME_TAIL\r\n\t\t\tVALUE \"LegalCopyright\", \"Copyright © \" HASHCHECK_COPYRIGHT_STR\r\n\t\t\tVALUE \"OriginalFilename\", HASHCHECK_FILENAME_STR\r\n\t\t}\r\n\t}\r\n\tBLOCK \"VarFileInfo\"\r\n\t{\r\n\t\tVALUE \"Translation\", 0x0409, 0x04b0 // English (U.S.)\r\n\t}\r\n}\r\n\r\nLANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL\r\n\r\nIDD_HASHSAVE DIALOGEX 0, 0, 300, 28\r\n    STYLE    DS_MODALFRAME | DS_SHELLFONT | DS_CENTER | WS_POPUPWINDOW | WS_CAPTION | WS_MINIMIZEBOX\r\n    EXSTYLE  WS_EX_APPWINDOW\r\n    FONT     8, \"MS Shell Dlg\"\r\n{\r\n    CONTROL         \"\", IDC_PROG_TOTAL, \"msctls_progress32\", PBS_SMOOTH, 7,  7, 178, 6\r\n    CONTROL         \"\", IDC_PROG_FILE,  \"msctls_progress32\", PBS_SMOOTH, 7, 15, 178, 6\r\n    PUSHBUTTON      \"\", IDC_PAUSE,  189, 7, 50, 14, WS_TABSTOP | WS_GROUP\r\n    PUSHBUTTON      \"\", IDC_CANCEL, 243, 7, 50, 14, WS_TABSTOP\r\n}\r\n\r\nIDD_HASHPROP DIALOGEX 0, 0, 227, 218\r\n    STYLE    DS_SHELLFONT | WS_CAPTION\r\n    FONT     8, \"MS Shell Dlg\"\r\n{\r\n    GROUPBOX        \"\", IDC_STATUSBOX,     7, 158, 213,  32, WS_GROUP\r\n    CONTROL         \"\", IDC_PROG_TOTAL, \"msctls_progress32\", PBS_SMOOTH, 13, 169, 201, 6\r\n    CONTROL         \"\", IDC_PROG_FILE,  \"msctls_progress32\", PBS_SMOOTH, 13, 177, 201, 6\r\n    EDITTEXT            IDC_SEARCHBOX     13, 169, 147,  14, WS_TABSTOP | WS_DISABLED | NOT WS_VISIBLE | ES_AUTOHSCROLL\r\n    PUSHBUTTON      \"\", IDC_FIND_NEXT    164, 169,  50,  14, WS_TABSTOP | WS_DISABLED | NOT WS_VISIBLE\r\n    PUSHBUTTON      \"\", IDC_PAUSE,        62, 197,  50,  14, WS_TABSTOP | WS_GROUP\r\n    PUSHBUTTON      \"\", IDC_STOP,        116, 197,  50,  14, WS_TABSTOP\r\n    PUSHBUTTON      \"\", IDC_SAVE,        116, 197,  50,  14, WS_TABSTOP | WS_DISABLED | NOT WS_VISIBLE\r\n    PUSHBUTTON      \"\", IDC_OPTIONS,     170, 197,  50,  14, WS_TABSTOP\r\n    EDITTEXT            IDC_RESULTS,       7,   7, 213, 144, WS_TABSTOP | WS_GROUP | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_NOHIDESEL | ES_READONLY\r\n}\r\n\r\nIDD_HASHVERF DIALOGEX 0, 0, 400, 250\r\n    STYLE    DS_MODALFRAME | DS_SHELLFONT | DS_CENTER | WS_POPUPWINDOW | WS_CAPTION | WS_MINIMIZEBOX\r\n    EXSTYLE  WS_EX_APPWINDOW\r\n    FONT     8, \"MS Shell Dlg\"\r\n{\r\n    CONTROL         \"\", IDC_LIST, \"SysListView32\", WS_TABSTOP | WS_GROUP | WS_BORDER | LVS_OWNERDATA | LVS_REPORT | LVS_SHOWSELALWAYS, 7, 7, 386, 170\r\n    GROUPBOX        \"\", IDC_SUMMARY,              7, 184, 386, 38, WS_GROUP\r\n    LTEXT           \"\", IDC_MATCH_LABEL,         13, 195,  56,  8\r\n    RTEXT           \"\", IDC_MATCH_RESULTS,       73, 195, 104,  8\r\n    LTEXT           \"\", IDC_MISMATCH_LABEL,      13, 207,  56,  8\r\n    RTEXT           \"\", IDC_MISMATCH_RESULTS,    73, 207, 104,  8\r\n    LTEXT           \"\", IDC_UNREADABLE_LABEL,   223, 195,  56,  8\r\n    RTEXT           \"\", IDC_UNREADABLE_RESULTS, 283, 195, 104,  8\r\n    LTEXT           \"\", IDC_PENDING_LABEL,      223, 207,  56,  8\r\n    RTEXT           \"\", IDC_PENDING_RESULTS,    283, 207, 104,  8\r\n    CONTROL         \"\", IDC_PROG_TOTAL, \"msctls_progress32\", PBS_SMOOTH, 7, 229, 224, 6\r\n    CONTROL         \"\", IDC_PROG_FILE,  \"msctls_progress32\", PBS_SMOOTH, 7, 237, 224, 6\r\n    PUSHBUTTON      \"\", IDC_PAUSE,              235, 229,  50, 14, WS_TABSTOP | WS_GROUP\r\n    PUSHBUTTON      \"\", IDC_STOP,               289, 229,  50, 14, WS_TABSTOP\r\n    DEFPUSHBUTTON   \"\", IDC_EXIT,               343, 229,  50, 14, WS_TABSTOP\r\n}\r\n\r\nIDD_OPTIONS  DIALOGEX 10, 10, 200, 264\r\n    STYLE    DS_MODALFRAME | DS_SHELLFONT | WS_POPUPWINDOW | WS_CAPTION\r\n    FONT     8, \"MS Shell Dlg\"\r\n{\r\n    GROUPBOX        \"\", IDC_OPT_CM,              7,   7, 186, 58, WS_GROUP\r\n    AUTORADIOBUTTON \"\", IDC_OPT_CM_ALWAYS,      13,  20, 174, 10, WS_TABSTOP\r\n    AUTORADIOBUTTON \"\", IDC_OPT_CM_EXTENDED,    13,  34, 174, 10\r\n    AUTORADIOBUTTON \"\", IDC_OPT_CM_NEVER,       13,  48, 174, 10\r\n    GROUPBOX        \"\", IDC_OPT_ENCODING,        7,  72, 186, 58, WS_GROUP\r\n    AUTORADIOBUTTON \"\", IDC_OPT_ENCODING_UTF8,  13,  85, 174, 10, WS_TABSTOP\r\n    AUTORADIOBUTTON \"\", IDC_OPT_ENCODING_UTF16, 13,  99, 174, 10\r\n    AUTORADIOBUTTON \"\", IDC_OPT_ENCODING_ANSI,  13, 113, 174, 10\r\n    GROUPBOX        \"\", IDC_OPT_CHK,             7, 137, 186, 58, WS_GROUP\r\n    AUTOCHECKBOX \"C&RC-32\",IDC_OPT_CHK_CRC32,   13, 150,  54, 10, WS_TABSTOP\r\n    AUTOCHECKBOX     \"MD5\",IDC_OPT_CHK_MD5,     13, 164,  54, 10, WS_TABSTOP\r\n    AUTOCHECKBOX   \"SHA-1\",IDC_OPT_CHK_SHA1,    13, 178,  54, 10, WS_TABSTOP\r\n    AUTOCHECKBOX \"SHA-256\",IDC_OPT_CHK_SHA256,  73, 150,  54, 10, WS_TABSTOP\r\n    AUTOCHECKBOX \"SHA-512\",IDC_OPT_CHK_SHA512,  73, 164,  54, 10, WS_TABSTOP\r\n    AUTOCHECKBOX \"SHA3-256\",IDC_OPT_CHK_SHA3_256,133,150, 54, 10, WS_TABSTOP\r\n    AUTOCHECKBOX \"SHA3-512\",IDC_OPT_CHK_SHA3_512,133,164, 54, 10, WS_TABSTOP\r\n    GROUPBOX        \"\", IDC_OPT_FONT,            7, 202, 186, 34, WS_GROUP\r\n    CTEXT           \"\", IDC_OPT_FONT_PREVIEW,   13, 215, 100, 14, SS_CENTERIMAGE | SS_SUNKEN\r\n    PUSHBUTTON      \"\", IDC_OPT_FONT_CHANGE,   117, 215,  70, 14, WS_TABSTOP\r\n    CONTROL \"<a href=\"\"https://github.com/gurnec/HashCheck\"\">HashCheck</a>\", IDC_OPT_LINK, \"SysLink\", WS_TABSTOP | WS_GROUP, 13, 244, 70, 10\r\n    DEFPUSHBUTTON   \"\", IDC_OK,                 89, 243,  50, 14, WS_TABSTOP | WS_GROUP\r\n    PUSHBUTTON      \"\", IDC_CANCEL,            143, 243,  50, 14, WS_TABSTOP\r\n}\r\n\r\nIDR_RT_MANIFEST         RT_MANIFEST             \"HashCheck.manifest\"\r\nIDI_FILETYPE            ICON                    \"HashCheck.ico\"\r\nIDI_MENUBITMAP          BITMAP                  \"HashCheck.bmp\"\r\n\r\n#include \"HashCheckTranslations.rc\"\r\n"
        },
        {
          "name": "HashCheck.sln",
          "type": "blob",
          "size": 3.0068359375,
          "content": "﻿\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio 14\r\nVisualStudioVersion = 14.0.25420.1\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\"{2150E333-8FDC-42A3-9474-1A3956D46DE8}\") = \"Solution Items\", \"Solution Items\", \"{A3CCE2E5-7BD9-4381-9D92-BD06D96EA49B}\"\r\n\tProjectSection(SolutionItems) = preProject\r\n\t\t.gitignore = .gitignore\r\n\t\tappveyor.yml = appveyor.yml\r\n\t\tinstaller\\HashCheck.nsi = installer\\HashCheck.nsi\r\n\t\tlicense.txt = license.txt\r\n\t\tREADME.md = README.md\r\n\t\tupdate-version.py = update-version.py\r\n\tEndProjectSection\r\nEndProject\r\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"HashCheck\", \"HashCheck.vcxproj\", \"{DCAD938F-9032-4AF9-BA67-8C0CF309D986}\"\r\nEndProject\r\nProject(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"UnitTests\", \"UnitTests\\UnitTests.csproj\", \"{5BD2397A-F10B-4847-8814-E539FB04AC8F}\"\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tDebug|Win32 = Debug|Win32\r\n\t\tDebug|x64 = Debug|x64\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\t\tRelease|Win32 = Release|Win32\r\n\t\tRelease|x64 = Release|x64\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Debug|Any CPU.ActiveCfg = Debug|x64\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Debug|Win32.ActiveCfg = Debug|Win32\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Debug|Win32.Build.0 = Debug|Win32\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Debug|x64.ActiveCfg = Debug|x64\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Debug|x64.Build.0 = Debug|x64\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Release|Any CPU.ActiveCfg = Release|x64\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Release|Win32.ActiveCfg = Release|Win32\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Release|Win32.Build.0 = Release|Win32\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Release|x64.ActiveCfg = Release|x64\r\n\t\t{DCAD938F-9032-4AF9-BA67-8C0CF309D986}.Release|x64.Build.0 = Release|x64\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Debug|Win32.ActiveCfg = Debug|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Debug|Win32.Build.0 = Debug|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Debug|x64.ActiveCfg = Debug|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Debug|x64.Build.0 = Debug|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Release|Win32.ActiveCfg = Release|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Release|Win32.Build.0 = Release|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Release|x64.ActiveCfg = Release|Any CPU\r\n\t\t{5BD2397A-F10B-4847-8814-E539FB04AC8F}.Release|x64.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
        },
        {
          "name": "HashCheck.vcxproj",
          "type": "blob",
          "size": 12.400390625,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project DefaultTargets=\"Build\" ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup Label=\"ProjectConfigurations\">\r\n    <ProjectConfiguration Include=\"Debug|Win32\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Debug|x64\">\r\n      <Configuration>Debug</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|Win32\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>Win32</Platform>\r\n    </ProjectConfiguration>\r\n    <ProjectConfiguration Include=\"Release|x64\">\r\n      <Configuration>Release</Configuration>\r\n      <Platform>x64</Platform>\r\n    </ProjectConfiguration>\r\n  </ItemGroup>\r\n  <PropertyGroup Label=\"Globals\">\r\n    <ProjectGuid>{DCAD938F-9032-4AF9-BA67-8C0CF309D986}</ProjectGuid>\r\n    <RootNamespace>HashCheck</RootNamespace>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <UseDebugLibraries>true</UseDebugLibraries>\r\n    <PlatformToolset>v140</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <UseDebugLibraries>false</UseDebugLibraries>\r\n    <PlatformToolset>v140</PlatformToolset>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <UseDebugLibraries>true</UseDebugLibraries>\r\n    <PlatformToolset>v140</PlatformToolset>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\r\n    <ConfigurationType>DynamicLibrary</ConfigurationType>\r\n    <UseDebugLibraries>false</UseDebugLibraries>\r\n    <PlatformToolset>v140</PlatformToolset>\r\n    <WholeProgramOptimization>true</WholeProgramOptimization>\r\n    <CharacterSet>Unicode</CharacterSet>\r\n  </PropertyGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\r\n  <ImportGroup Label=\"ExtensionSettings\">\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n    <Import Project=\"HashCheckGlobalDefines.props\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n    <Import Project=\"HashCheckGlobalDefines.props\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n    <Import Project=\"HashCheckGlobalDefines.props\" />\r\n  </ImportGroup>\r\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\r\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\r\n    <Import Project=\"HashCheckGlobalDefines.props\" />\r\n  </ImportGroup>\r\n  <PropertyGroup Label=\"UserMacros\" />\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <OutDir>Bin\\$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>Obj\\$(Platform)\\$(Configuration)\\</IntDir>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <LinkIncremental>false</LinkIncremental>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <OutDir>Bin\\$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>Obj\\$(Platform)\\$(Configuration)\\</IntDir>\r\n    <GenerateManifest>false</GenerateManifest>\r\n    <LinkIncremental>false</LinkIncremental>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <OutDir>Bin\\$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>Obj\\$(Platform)\\$(Configuration)\\</IntDir>\r\n    <GenerateManifest>false</GenerateManifest>\r\n  </PropertyGroup>\r\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <OutDir>Bin\\$(Platform)\\$(Configuration)\\</OutDir>\r\n    <IntDir>Obj\\$(Platform)\\$(Configuration)\\</IntDir>\r\n    <GenerateManifest>false</GenerateManifest>\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <PreprocessorDefinitions>WIN32;__i386__;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SDLCheck>true</SDLCheck>\r\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\r\n    </ClCompile>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>WIN32;__i386__;NDEBUG;_WINDOWS;_UNICODE;UNICODE;BYTE_ORDER=LITTLE_ENDIAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n    </ResourceCompile>\r\n    <Link>\r\n      <AdditionalDependencies>shlwapi.lib;comctl32.lib;uxtheme.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <ModuleDefinitionFile>HashCheck.def</ModuleDefinitionFile>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <SetChecksum>true</SetChecksum>\r\n      <SubSystem>Windows</SubSystem>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\r\n    <ClCompile>\r\n      <Optimization>MaxSpeed</Optimization>\r\n      <IntrinsicFunctions>true</IntrinsicFunctions>\r\n      <PreprocessorDefinitions>WIN64;__amd64__;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\r\n      <FunctionLevelLinking>true</FunctionLevelLinking>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SDLCheck>true</SDLCheck>\r\n      <MultiProcessorCompilation>true</MultiProcessorCompilation>\r\n    </ClCompile>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>WIN64;__amd64__;NDEBUG;_WINDOWS;_UNICODE;UNICODE;BYTE_ORDER=LITTLE_ENDIAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n    </ResourceCompile>\r\n    <Link>\r\n      <AdditionalDependencies>shlwapi.lib;comctl32.lib;uxtheme.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <ModuleDefinitionFile>HashCheck.def</ModuleDefinitionFile>\r\n      <OptimizeReferences>true</OptimizeReferences>\r\n      <EnableCOMDATFolding>true</EnableCOMDATFolding>\r\n      <SetChecksum>true</SetChecksum>\r\n      <SubSystem>Windows</SubSystem>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <PreprocessorDefinitions>WIN32;__i386__;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SDLCheck>true</SDLCheck>\r\n    </ClCompile>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>WIN32;__i386__;_DEBUG;_WINDOWS;_UNICODE;UNICODE;BYTE_ORDER=LITTLE_ENDIAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n    </ResourceCompile>\r\n    <Link>\r\n      <AdditionalDependencies>shlwapi.lib;comctl32.lib;uxtheme.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <ModuleDefinitionFile>HashCheck.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\r\n    <ClCompile>\r\n      <Optimization>Disabled</Optimization>\r\n      <PreprocessorDefinitions>WIN64;__amd64__;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <MinimalRebuild>true</MinimalRebuild>\r\n      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\r\n      <WarningLevel>Level3</WarningLevel>\r\n      <SDLCheck>true</SDLCheck>\r\n    </ClCompile>\r\n    <ResourceCompile>\r\n      <PreprocessorDefinitions>WIN64;__amd64__;_DEBUG;_WINDOWS;_UNICODE;UNICODE;BYTE_ORDER=LITTLE_ENDIAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n      <Culture>0x0409</Culture>\r\n    </ResourceCompile>\r\n    <Link>\r\n      <AdditionalDependencies>shlwapi.lib;comctl32.lib;uxtheme.lib;%(AdditionalDependencies)</AdditionalDependencies>\r\n      <ModuleDefinitionFile>HashCheck.def</ModuleDefinitionFile>\r\n      <GenerateDebugInformation>true</GenerateDebugInformation>\r\n      <SubSystem>Windows</SubSystem>\r\n    </Link>\r\n  </ItemDefinitionGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"CHashCheck.cpp\" />\r\n    <ClCompile Include=\"CHashCheckClassFactory.cpp\" />\r\n    <ClCompile Include=\"HashCalc.c\" />\r\n    <ClCompile Include=\"HashCheck.cpp\" />\r\n    <ClCompile Include=\"HashCheckCommon.c\" />\r\n    <ClCompile Include=\"HashCheckOptions.c\" />\r\n    <ClCompile Include=\"HashProp.c\" />\r\n    <ClCompile Include=\"HashSave.cpp\" />\r\n    <ClCompile Include=\"HashVerify.cpp\" />\r\n    <ClCompile Include=\"libs\\crc32.c\" />\r\n    <ClCompile Include=\"libs\\IsFontAvailable.c\" />\r\n    <ClCompile Include=\"libs\\md5.c\" />\r\n    <ClCompile Include=\"libs\\sha1.c\" />\r\n    <ClCompile Include=\"libs\\sha2.c\" />\r\n    <ClCompile Include=\"libs\\sha3\\KeccakHash.c\" />\r\n    <ClCompile Include=\"libs\\sha3\\KeccakP-1600-opt64.c\" />\r\n    <ClCompile Include=\"libs\\sha3\\KeccakSponge.c\" />\r\n    <ClCompile Include=\"libs\\SimpleList.c\" />\r\n    <ClCompile Include=\"libs\\SimpleString.c\" />\r\n    <ClCompile Include=\"libs\\WinHash.cpp\" />\r\n    <ClCompile Include=\"libs\\Wow64.c\" />\r\n    <ClCompile Include=\"RegHelpers.c\" />\r\n    <ClCompile Include=\"SetAppID.c\" />\r\n    <ClCompile Include=\"IsSSD.c\" />\r\n    <ClCompile Include=\"UnicodeHelpers.c\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"HashCheck.def\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"CHashCheck.hpp\" />\r\n    <ClInclude Include=\"CHashCheckClassFactory.hpp\" />\r\n    <ClInclude Include=\"GetHighMSB.h\" />\r\n    <ClInclude Include=\"globals.h\" />\r\n    <ClInclude Include=\"HashCalc.h\" />\r\n    <ClInclude Include=\"HashCheckCommon.h\" />\r\n    <ClInclude Include=\"HashCheckOptions.h\" />\r\n    <ClInclude Include=\"HashCheckResources.h\" />\r\n    <ClInclude Include=\"HashCheckTranslations.h\" />\r\n    <ClInclude Include=\"HashCheckUI.h\" />\r\n    <ClInclude Include=\"IsSSD.h\" />\r\n    <ClInclude Include=\"libs\\IsFontAvailable.h\" />\r\n    <ClInclude Include=\"libs\\sha3\\KeccakHash.h\" />\r\n    <ClInclude Include=\"libs\\SimpleList.h\" />\r\n    <ClInclude Include=\"libs\\SimpleString.h\" />\r\n    <ClInclude Include=\"libs\\BitwiseIntrinsics.h\" />\r\n    <ClInclude Include=\"libs\\WinHash.h\" />\r\n    <ClInclude Include=\"libs\\WinIntrinsics.h\" />\r\n    <ClInclude Include=\"libs\\Wow64.h\" />\r\n    <ClInclude Include=\"RegHelpers.h\" />\r\n    <ClInclude Include=\"SetAppID.h\" />\r\n    <ClInclude Include=\"UnicodeHelpers.h\" />\r\n    <ClInclude Include=\"version.h\" />\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"HashCheck.rc\" />\r\n    <ResourceCompile Include=\"HashCheckTranslations.rc\">\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\r\n      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\r\n    </ResourceCompile>\r\n  </ItemGroup>\r\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\r\n  <ImportGroup Label=\"ExtensionTargets\">\r\n  </ImportGroup>\r\n</Project>"
        },
        {
          "name": "HashCheck.vcxproj.filters",
          "type": "blob",
          "size": 6.0390625,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ItemGroup>\r\n    <Filter Include=\"Source Files\">\r\n      <UniqueIdentifier>{15254295-37be-4bc7-b35c-abf3aac3a947}</UniqueIdentifier>\r\n      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Header Files\">\r\n      <UniqueIdentifier>{b59f8540-15b7-4509-a9e2-9f602524a0ca}</UniqueIdentifier>\r\n      <Extensions>h;hpp;hxx;hm;inl</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Resource Files\">\r\n      <UniqueIdentifier>{45153c32-63d7-41f0-a17b-ceeee36bed5d}</UniqueIdentifier>\r\n      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>\r\n    </Filter>\r\n    <Filter Include=\"Libraries\">\r\n      <UniqueIdentifier>{3d06f958-2b36-4a2d-a5a9-c4e7445f5196}</UniqueIdentifier>\r\n    </Filter>\r\n    <Filter Include=\"Libraries\\sha3\">\r\n      <UniqueIdentifier>{10750838-6937-43da-bede-5de87aa2ff94}</UniqueIdentifier>\r\n    </Filter>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClCompile Include=\"HashCheck.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CHashCheck.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"CHashCheckClassFactory.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HashCheckCommon.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HashCalc.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HashProp.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HashCheckOptions.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"RegHelpers.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"SetAppID.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"UnicodeHelpers.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\SimpleString.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\SimpleList.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\IsFontAvailable.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\Wow64.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\crc32.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\md5.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\sha1.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\sha2.c\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\WinHash.cpp\">\r\n      <Filter>Libraries</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HashSave.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"IsSSD.c\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"HashVerify.cpp\">\r\n      <Filter>Source Files</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\sha3\\KeccakHash.c\">\r\n      <Filter>Libraries\\sha3</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\sha3\\KeccakP-1600-opt64.c\">\r\n      <Filter>Libraries\\sha3</Filter>\r\n    </ClCompile>\r\n    <ClCompile Include=\"libs\\sha3\\KeccakSponge.c\">\r\n      <Filter>Libraries\\sha3</Filter>\r\n    </ClCompile>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <None Include=\"HashCheck.def\">\r\n      <Filter>Source Files</Filter>\r\n    </None>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ClInclude Include=\"CHashCheck.hpp\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"CHashCheckClassFactory.hpp\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HashCheckUI.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HashCheckCommon.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HashCalc.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HashCheckOptions.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"GetHighMSB.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"RegHelpers.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"SetAppID.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"UnicodeHelpers.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HashCheckResources.h\">\r\n      <Filter>Resource Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"globals.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"version.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\WinIntrinsics.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\SimpleString.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\SimpleList.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\IsFontAvailable.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\WinHash.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\Wow64.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"HashCheckTranslations.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\BitwiseIntrinsics.h\">\r\n      <Filter>Libraries</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"IsSSD.h\">\r\n      <Filter>Header Files</Filter>\r\n    </ClInclude>\r\n    <ClInclude Include=\"libs\\sha3\\KeccakHash.h\">\r\n      <Filter>Libraries\\sha3</Filter>\r\n    </ClInclude>\r\n  </ItemGroup>\r\n  <ItemGroup>\r\n    <ResourceCompile Include=\"HashCheck.rc\">\r\n      <Filter>Resource Files</Filter>\r\n    </ResourceCompile>\r\n    <ResourceCompile Include=\"HashCheckTranslations.rc\">\r\n      <Filter>Resource Files</Filter>\r\n    </ResourceCompile>\r\n  </ItemGroup>\r\n</Project>"
        },
        {
          "name": "HashCheckCommon.c",
          "type": "blob",
          "size": 15.85546875,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2016 Christopher Gurnee.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include <assert.h>\r\n#include \"globals.h\"\r\n#include \"HashCheckCommon.h\"\r\n#include \"GetHighMSB.h\"\r\n#include <Strsafe.h>\r\n\r\n#define PROGRESS_BAR_STEPS 300\r\n\r\nHANDLE __fastcall CreateThreadCRT( PVOID pThreadProc, PVOID pvParam )\r\n{\r\n\tif (!pThreadProc)\r\n\t{\r\n\t\t// If we have a NULL pThreadProc, then we are starting a worker thread,\r\n\t\t// and there is some initialization that we need to take care of...\r\n\r\n\t\tPCOMMONCONTEXT pcmnctx = pvParam;\r\n\t\tpcmnctx->status = ACTIVE;\r\n\t\tpcmnctx->cSentMsgs = 0;\r\n\t\tpcmnctx->cHandledMsgs = 0;\r\n\t\tpcmnctx->hWndPBTotal = GetDlgItem(pcmnctx->hWnd, IDC_PROG_TOTAL);\r\n\t\tpcmnctx->hWndPBFile = GetDlgItem(pcmnctx->hWnd, IDC_PROG_FILE);\r\n        if (pcmnctx->hUnpauseEvent == NULL)\r\n            pcmnctx->hUnpauseEvent = CreateEvent(NULL, TRUE, TRUE, NULL);\r\n\t\tSendMessage(pcmnctx->hWndPBFile, PBM_SETRANGE, 0, MAKELPARAM(0, PROGRESS_BAR_STEPS));\r\n\r\n\t\tpThreadProc = WorkerThreadStartup;\r\n\t}\r\n\r\n\treturn((HANDLE)_beginthreadex(\r\n\t\tNULL,\r\n\t\tBASE_STACK_SIZE,\r\n\t\tpThreadProc,\r\n\t\tpvParam,\r\n\t\t0,\r\n\t\tNULL\r\n\t));\r\n}\r\n\r\nHANDLE __fastcall OpenFileForReading( PCTSTR pszPath )\r\n{\r\n\treturn(CreateFile(\r\n\t\tpszPath,\r\n\t\tGENERIC_READ,\r\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\r\n\t\tNULL,\r\n\t\tOPEN_EXISTING,\r\n\t\tFILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\r\n\t\tNULL\r\n\t));\r\n}\r\n\r\nVOID __fastcall HCNormalizeString( PTSTR psz )\r\n{\r\n\tif (!psz) return;\r\n\r\n\twhile (*psz)\r\n\t{\r\n\t\tswitch (*psz)\r\n\t\t{\r\n\t\t\tcase TEXT('\\r'):\r\n\t\t\t\t*psz = TEXT('\\n');\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TEXT('\\t'):\r\n\t\t\tcase TEXT('\"'):\r\n\t\t\tcase TEXT('*'):\r\n\t\t\t\t*psz = TEXT(' ');\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TEXT('/'):\r\n\t\t\t\t*psz = TEXT('\\\\');\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t++psz;\r\n\t}\r\n}\r\n\r\nVOID WINAPI SetControlText( HWND hWnd, UINT uCtrlID, UINT uStringID )\r\n{\r\n\tTCHAR szBuffer[MAX_STRINGMSG];\r\n\tLoadString(g_hModThisDll, uStringID, szBuffer, countof(szBuffer));\r\n\tSetDlgItemText(hWnd, uCtrlID, szBuffer);\r\n}\r\n\r\nVOID WINAPI EnableControl( HWND hWnd, UINT uCtrlID, BOOL bEnable )\r\n{\r\n\tHWND hWndControl = GetDlgItem(hWnd, uCtrlID);\r\n\tShowWindow(hWndControl, (bEnable) ? SW_SHOW : SW_HIDE);\r\n\tEnableWindow(hWndControl, bEnable);\r\n}\r\n\r\nVOID WINAPI FormatFractionalResults( PTSTR pszFormat, PTSTR pszBuffer, UINT uPart, UINT uTotal )\r\n{\r\n\t// pszFormat must be at least MAX_STRINGRES TCHARs long\r\n\t// pszBuffer must be at least MAX_STRINGMSG TCHARs long\r\n\r\n\tif (*pszFormat == 0)\r\n\t{\r\n\t\tLoadString(\r\n\t\t\tg_hModThisDll,\r\n\t\t\t(uTotal == 1) ? IDS_HP_RESULT_FMT : IDS_HP_RESULTS_FMT,\r\n\t\t\tpszFormat,\r\n\t\t\tMAX_STRINGRES\r\n\t\t);\r\n\t}\r\n\r\n\tif (*pszFormat != TEXT('!'))\r\n\t\tStringCchPrintf(pszBuffer, MAX_STRINGMSG, pszFormat, uPart, uTotal);\r\n\telse\r\n\t\tStringCchPrintf(pszBuffer, MAX_STRINGMSG, pszFormat + 1, uTotal, uPart);\r\n}\r\n\r\nVOID WINAPI SetProgressBarPause( PCOMMONCONTEXT pcmnctx, WPARAM iState )\r\n{\r\n\t// For Windows Classic, we can change the color to indicate a pause\r\n\tCOLORREF clrProgress = (iState == PBST_NORMAL) ? CLR_DEFAULT : RGB(0xFF, 0x80, 0x00);\r\n\tSendMessage(pcmnctx->hWndPBTotal, PBM_SETBARCOLOR, 0, clrProgress);\r\n\tSendMessage(pcmnctx->hWndPBFile, PBM_SETBARCOLOR, 0, clrProgress);\r\n\r\n\t// Toggle the marquee animation if applicable\r\n\tif (pcmnctx->dwFlags & HCF_MARQUEE)\r\n\t\tSendMessage(pcmnctx->hWndPBTotal, PBM_SETMARQUEE, iState == PBST_NORMAL, MARQUEE_INTERVAL);\r\n\r\n\tif (g_uWinVer >= 0x0600)\r\n\t{\r\n\t\t// If this is Vista, we can also set the state\r\n\t\tSendMessage(pcmnctx->hWndPBTotal, PBM_SETSTATE, iState, 0);\r\n\t\tSendMessage(pcmnctx->hWndPBFile, PBM_SETSTATE, iState, 0);\r\n\r\n\t\t// Vista's progress bar is buggy--if you pause it while it is animating,\r\n\t\t// the color will not change (but it will stop animating), so it may\r\n\t\t// be necessary to send another PBM_SETSTATE to get it right\r\n        if (iState == PBST_PAUSED)\r\n            SetTimer(pcmnctx->hWnd, TIMER_ID_PAUSE, 750, NULL);\r\n\t}\r\n}\r\n\r\nVOID WINAPI WorkerThreadTogglePause( PCOMMONCONTEXT pcmnctx )\r\n{\r\n\tif (pcmnctx->status == ACTIVE)\r\n\t{\r\n        ResetEvent(pcmnctx->hUnpauseEvent);\r\n\t\tpcmnctx->status = PAUSED;\r\n\r\n\t\tif (!(pcmnctx->dwFlags & HCF_EXIT_PENDING))\r\n\t\t{\r\n\t\t\tSetControlText(pcmnctx->hWnd, IDC_PAUSE, IDS_HC_RESUME);\r\n\t\t\tSetProgressBarPause(pcmnctx, PBST_PAUSED);\r\n\t\t}\r\n\t}\r\n\telse if (pcmnctx->status == PAUSED)\r\n\t{\r\n\t\tpcmnctx->status = ACTIVE;\r\n\r\n\t\tif (!(pcmnctx->dwFlags & HCF_EXIT_PENDING))\r\n\t\t{\r\n\t\t\tSetControlText(pcmnctx->hWnd, IDC_PAUSE, IDS_HC_PAUSE);\r\n\t\t\tSetProgressBarPause(pcmnctx, PBST_NORMAL);\r\n\t\t}\r\n\r\n        SetEvent(pcmnctx->hUnpauseEvent);\r\n\t}\r\n}\r\n\r\nVOID WINAPI WorkerThreadStop( PCOMMONCONTEXT pcmnctx )\r\n{\r\n\tif (pcmnctx->status == INACTIVE || pcmnctx->status == CLEANUP_COMPLETED)\r\n\t\treturn;\r\n\r\n\t// If the thread is paused, unpause it\r\n    if (pcmnctx->status == PAUSED)\r\n    {\r\n        // Signal cancellation first, so that unpaused threads immediately exit\r\n        pcmnctx->status = CANCEL_REQUESTED;\r\n        SetEvent(pcmnctx->hUnpauseEvent);\r\n    }\r\n    else\r\n    {\r\n        // Signal cancellation\r\n        pcmnctx->status = CANCEL_REQUESTED;\r\n    }\r\n\r\n\t// Disable the control buttons\r\n\tif (! (pcmnctx->dwFlags & (HCF_EXIT_PENDING | HCF_RESTARTING)))\r\n\t{\r\n\t\tEnableWindow(GetDlgItem(pcmnctx->hWnd, IDC_PAUSE), FALSE);\r\n\t\tEnableWindow(GetDlgItem(pcmnctx->hWnd, IDC_STOP), FALSE);\r\n\t}\r\n}\r\n\r\nVOID WINAPI WorkerThreadCleanup( PCOMMONCONTEXT pcmnctx )\r\n{\r\n\tif (pcmnctx->status == CLEANUP_COMPLETED)\r\n\t\treturn;\r\n\r\n\t// There are only two times this function gets called:\r\n\t// Case 1: The worker thread has exited on its own, and this function\r\n\t// was invoked in response to the thread's exit notification.\r\n\t// Case 2: A forced abort was requested (app exit, settings change, etc.),\r\n\t// where this is called right after calling WorkerThreadStop to signal the\r\n\t// thread to exit.\r\n\r\n\tif (pcmnctx->hThread != NULL)\r\n\t{\r\n\t\tif (pcmnctx->status != INACTIVE)\r\n\t\t{\r\n\t\t\t// Forced abort, where the thread has been told to stop but has not yet\r\n\t\t\t// stopped. With the MS Concurrency runtime, there's no simple way to\r\n\t\t\t// terminate errant threads; it's better to abort the process than to\r\n\t\t\t// allow them to continue (maybe maxing out the CPU) in the background.\r\n\t\t\tif (WaitForSingleObject(pcmnctx->hThread, 10000) == WAIT_TIMEOUT)\r\n\t\t\t\tabort();\r\n\t\t}\r\n\r\n\t\tCloseHandle(pcmnctx->hThread);\r\n        pcmnctx->hThread = NULL;\r\n\t}\r\n\r\n    // If we're done with the Unpause event and it's open, close it\r\n    if (!(pcmnctx->dwFlags & HCF_RESTARTING) && pcmnctx->hUnpauseEvent != NULL)\r\n    {\r\n        CloseHandle(pcmnctx->hUnpauseEvent);\r\n        pcmnctx->hUnpauseEvent = NULL;\r\n    }\r\n\r\n\tpcmnctx->status = CLEANUP_COMPLETED;\r\n\r\n\tif (! (pcmnctx->dwFlags & (HCF_EXIT_PENDING | HCF_RESTARTING)))\r\n\t{\r\n\t\tstatic const UINT16 arCtrls[] =\r\n\t\t{\r\n\t\t\tIDC_PROG_TOTAL,\r\n\t\t\tIDC_PROG_FILE,\r\n\t\t\tIDC_PAUSE,\r\n\t\t\tIDC_STOP\r\n\t\t};\r\n\r\n\t\tUINT i;\r\n\r\n\t\tfor (i = 0; i < countof(arCtrls); ++i)\r\n\t\t\tEnableControl(pcmnctx->hWnd, arCtrls[i], FALSE);\r\n\t}\r\n}\r\n\r\nDWORD WINAPI WorkerThreadStartup( PCOMMONCONTEXT pcmnctx )\r\n{\r\n    pcmnctx->pfnWorkerMain(pcmnctx);\r\n\r\n\tpcmnctx->status = INACTIVE;\r\n\r\n\tif (! (pcmnctx->dwFlags & (HCF_EXIT_PENDING | HCF_RESTARTING)))\r\n\t\tPostMessage(pcmnctx->hWnd, HM_WORKERTHREAD_DONE, (WPARAM)pcmnctx, 0);\r\n\r\n\treturn(0);\r\n}\r\n\r\n// Post messages to update the progress bar. If there are multiple file-hashing threads,\r\n// then only the thread currently operating on the largest file updates the progress bar.\r\n__inline VOID UpdateProgressBar( HWND hWndPBFile, PCRITICAL_SECTION pCritSec,\r\n                                 PBOOL pbCurrentlyUpdating, volatile ULONGLONG* pcbCurrentMaxSize,\r\n                                 ULONGLONG cbFileSize, ULONGLONG cbFileRead, PUINT pLastProgress )\r\n{\r\n    if (pCritSec)  // if we're one among many file-hashing threads\r\n    {\r\n        // All the checks below outside of critical sections are innacurate; they're meant\r\n        // to quickly check if entering the critical section can be avoided, but they must\r\n        // be repeated inside the critical sections to avoid potential race conditions\r\n\r\n        if (*pbCurrentlyUpdating)\r\n        {\r\n            if (cbFileSize != *pcbCurrentMaxSize)\r\n            {\r\n                // Some other thread is now updating the progress bar\r\n                *pbCurrentlyUpdating = FALSE;\r\n                return;\r\n            }\r\n            UINT newProgress = (UINT) (PROGRESS_BAR_STEPS * cbFileRead / cbFileSize);\r\n            if (newProgress == *pLastProgress)\r\n                return;\r\n\r\n            EnterCriticalSection(pCritSec);\r\n            if (cbFileSize != *pcbCurrentMaxSize)\r\n            {\r\n                LeaveCriticalSection(pCritSec);\r\n                // Some other thread is now updating the progress bar\r\n                *pbCurrentlyUpdating = FALSE;\r\n                return;\r\n            }\r\n            // Special case for when this file has been completed:\r\n            if (cbFileRead == 0)\r\n                *pcbCurrentMaxSize = 0;  // relinquish progress bar control to the next largest file\r\n            PostMessage(hWndPBFile, PBM_SETPOS, newProgress, 0);\r\n            LeaveCriticalSection(pCritSec);\r\n            *pLastProgress = newProgress;\r\n        }\r\n        else  // if not *pbCurrentlyUpdating\r\n        {\r\n            if (cbFileSize > *pcbCurrentMaxSize)  // if we should take over updating the progress bar\r\n            {\r\n                UINT newProgress = (UINT)(PROGRESS_BAR_STEPS * cbFileRead / cbFileSize);\r\n                EnterCriticalSection(pCritSec);\r\n                if (cbFileSize > *pcbCurrentMaxSize)  // if we should definitely take over updating the progress bar\r\n                {\r\n                    *pcbCurrentMaxSize = cbFileSize;\r\n                    PostMessage(hWndPBFile, PBM_SETPOS, newProgress, 0);\r\n                }\r\n                LeaveCriticalSection(pCritSec);\r\n                *pbCurrentlyUpdating = TRUE;\r\n                *pLastProgress = newProgress;\r\n            }\r\n        }\r\n    }\r\n    else  // if we're the only file-hashing thread\r\n    {\r\n        UINT newProgress = (UINT)(PROGRESS_BAR_STEPS * cbFileRead / cbFileSize);\r\n        if (newProgress != *pLastProgress)\r\n        {\r\n            PostMessage(hWndPBFile, PBM_SETPOS, newProgress, 0);\r\n            *pLastProgress = newProgress;\r\n        }\r\n    }\r\n}\r\n\r\nVOID WINAPI WorkerThreadHashFile( PCOMMONCONTEXT pcmnctx, PCTSTR pszPath,\r\n                                  PWHCTXEX pwhctx, PWHRESULTEX pwhres, PBYTE pbuffer,\r\n                                  PFILESIZE pFileSize, LPARAM lParam,\r\n                                  PCRITICAL_SECTION pUpdateCritSec, volatile ULONGLONG* pcbCurrentMaxSize\r\n#ifdef _TIMED\r\n                                , PDWORD pdwElapsed\r\n#endif\r\n                                )\r\n{\r\n\tHANDLE hFile;\r\n\r\n\t// If the worker thread is working so fast that the UI cannot catch up,\r\n\t// pause for a bit to let things settle down\r\n\twhile (pcmnctx->cSentMsgs > pcmnctx->cHandledMsgs + 50)\r\n\t{\r\n\t\tSleep(50);\r\n        if (pcmnctx->status == PAUSED)\r\n            WaitForSingleObject(pcmnctx->hUnpauseEvent, INFINITE);\r\n\t\tif (pcmnctx->status == CANCEL_REQUESTED)\r\n\t\t\treturn;\r\n\t}\r\n\r\n    // This can happen if a user changes the hash selection in HashProp (if no\r\n    // new hashes were selected; we still want to run the throttling code above)\r\n    if (pwhctx->dwFlags == 0)\r\n    {\r\n#ifdef _TIMED\r\n        if (pdwElapsed)\r\n            *pdwElapsed = 0;\r\n#endif\r\n        return;\r\n    }\r\n\r\n\t// Indicate that we want lower-case results (TODO: make this an option)\r\n\tpwhctx->uCaseMode = WHFMT_LOWERCASE;\r\n\r\n\tif ((hFile = OpenFileForReading(pszPath)) != INVALID_HANDLE_VALUE)\r\n\t{\r\n\t\tULONGLONG cbFileSize, cbFileRead = 0;\r\n\t\tDWORD cbBufferRead;\r\n\t\tUINT lastProgress = 0;\r\n\t\tUINT8 cInner = 0;\r\n\r\n\t\tif (GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbFileSize))\r\n\t\t{\r\n\t\t\t// The progress bar is updates only once every 4 buffer reads; if\r\n\t\t\t// the file is small enough that it requires only one such cycle,\r\n\t\t\t// then do not bother with updating the progress bar; this improves\r\n\t\t\t// performance when working with large numbers of small files\r\n\t\t\tBOOL bUpdateProgress = cbFileSize >= READ_BUFFER_SIZE * 4,\r\n\t\t\t     bCurrentlyUpdating = FALSE;\r\n\r\n\t\t\t// If the caller provides a way to return the file size, then set\r\n\t\t\t// the file size; send a SETSIZE notification only if it was \"big\"\r\n\t\t\tif (pFileSize)\r\n\t\t\t{\r\n\t\t\t\tpFileSize->ui64 = cbFileSize;\r\n\t\t\t\tStrFormatKBSize(cbFileSize, pFileSize->sz, countof(pFileSize->sz));\r\n\t\t\t\tif (cbFileSize > READ_BUFFER_SIZE)\r\n\t\t\t\t    PostMessage(pcmnctx->hWnd, HM_WORKERTHREAD_SETSIZE, (WPARAM)pcmnctx, lParam != -1 ? lParam : (LPARAM)pFileSize);\r\n\t\t\t}\r\n#ifdef _TIMED\r\n            DWORD dwStarted;\r\n            if (pdwElapsed)\r\n                dwStarted = GetTickCount();\r\n#endif\r\n\t\t\t// Finally, read the file and calculate the checksum; the\r\n\t\t\t// progress bar is updated only once every 4 buffer reads (512K)\r\n\t\t\tWHInitEx(pwhctx);\r\n\r\n\t\t\tdo // Outer loop: keep going until the end\r\n\t\t\t{\r\n\t\t\t\tdo // Inner loop: break every 4 cycles or if the end is reached\r\n\t\t\t\t{\r\n                    if (pcmnctx->status == PAUSED)\r\n                        WaitForSingleObject(pcmnctx->hUnpauseEvent, INFINITE);\r\n\t\t\t\t\tif (pcmnctx->status == CANCEL_REQUESTED)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCloseHandle(hFile);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tReadFile(hFile, pbuffer, READ_BUFFER_SIZE, &cbBufferRead, NULL);\r\n\t\t\t\t\tWHUpdateEx(pwhctx, pbuffer, cbBufferRead);\r\n\t\t\t\t\tcbFileRead += cbBufferRead;\r\n\r\n\t\t\t\t} while (cbBufferRead == READ_BUFFER_SIZE && (++cInner & 0x03));\r\n\r\n\t\t\t\tif (bUpdateProgress)\r\n\t\t\t\t\tUpdateProgressBar(pcmnctx->hWndPBFile, pUpdateCritSec, &bCurrentlyUpdating,\r\n\t\t\t\t\t                  pcbCurrentMaxSize, cbFileSize, cbFileRead, &lastProgress);\r\n\r\n\t\t\t} while (cbBufferRead == READ_BUFFER_SIZE);\r\n\r\n\t\t\tWHFinishEx(pwhctx, pwhres);\r\n#ifdef _TIMED\r\n            if (pdwElapsed)\r\n                *pdwElapsed = GetTickCount() - dwStarted;\r\n#endif\r\n            // If we encountered a file read error\r\n            if (cbFileRead != cbFileSize)\r\n                // Clear the valid-results bits for the hashes we just calculated\r\n                // (they are set by WHFinishEx, but they're apparently *not* valid)\r\n                pwhres->dwFlags &= ~pwhctx->dwFlags;\r\n\r\n\t\t\tif (bUpdateProgress)\r\n\t\t\t\tUpdateProgressBar(pcmnctx->hWndPBFile, pUpdateCritSec, &bCurrentlyUpdating,\r\n\t\t\t\t                  pcbCurrentMaxSize, cbFileSize, 0, &lastProgress);\r\n\t\t}\r\n\r\n\t\tCloseHandle(hFile);\r\n\t}\r\n}\r\n\r\n__forceinline HANDLE WINAPI GetActCtx( HMODULE hModule, PCTSTR pszResourceName )\r\n{\r\n\t// Wraps away the silliness of CreateActCtx, including the fact that\r\n\t// it will fail if you do not provide a valid path string even if you\r\n\t// supply a valid module handle, which is quite silly since the path is\r\n\t// just going to get translated into a module handle anyway by the API.\r\n\r\n\tACTCTX ctx;\r\n\tTCHAR szModule[MAX_PATH << 1];\r\n\r\n\tGetModuleFileName(hModule, szModule, countof(szModule));\r\n\r\n\tctx.cbSize = sizeof(ctx);\r\n\tctx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID;\r\n\tctx.lpSource = szModule;\r\n\tctx.lpResourceName = pszResourceName;\r\n\tctx.hModule = hModule;\r\n\r\n\treturn(CreateActCtx(&ctx));\r\n}\r\n\r\nULONG_PTR WINAPI ActivateManifest( BOOL bActivate )\r\n{\r\n\tif (!g_bActCtxCreated)\r\n\t{\r\n\t\tg_bActCtxCreated = TRUE;\r\n\t\tg_hActCtx = GetActCtx(g_hModThisDll, MAKEINTRESOURCE(IDR_RT_MANIFEST));\r\n\t}\r\n\r\n\tif (g_hActCtx != INVALID_HANDLE_VALUE)\r\n\t{\r\n\t\tULONG_PTR uCookie;\r\n\r\n\t\tif (!bActivate)\r\n\t\t\treturn(1);  // Just indicate that we have a good g_hActCtx\r\n\t\telse if (ActivateActCtx(g_hActCtx, &uCookie))\r\n\t\t\treturn(uCookie);\r\n\t}\r\n\r\n\t// We can assume that zero is never a valid cookie value...\r\n\t// * http://support.microsoft.com/kb/830033\r\n\t// * http://blogs.msdn.com/jonwis/archive/2006/01/12/512405.aspx\r\n\treturn(0);\r\n}\r\n\r\nULONG_PTR __fastcall HostAddRef( )\r\n{\r\n\tLPUNKNOWN pUnknown;\r\n\r\n\tif (SHGetInstanceExplorer(&pUnknown) == S_OK)\r\n\t\treturn((ULONG_PTR)pUnknown);\r\n\telse\r\n\t\treturn(0);\r\n}\r\n\r\nVOID __fastcall HostRelease( ULONG_PTR uCookie )\r\n{\r\n\tif (uCookie)\r\n\t{\r\n\t\tLPUNKNOWN pUnknown = (LPUNKNOWN)uCookie;\r\n\t\tpUnknown->lpVtbl->Release(pUnknown);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "HashCheckCommon.h",
          "type": "blob",
          "size": 4.4326171875,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2016 Christopher Gurnee.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __HASHCHECKCOMMON_H__\r\n#define __HASHCHECKCOMMON_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n#include \"HashCheckUI.h\"\r\n#include \"libs/WinHash.h\"\r\n\r\n// Tuning constants\r\n#define MAX_PATH_BUFFER       0x800\r\n#define READ_BUFFER_SIZE      0x40000\r\n#define BASE_STACK_SIZE       0x1000\r\n#define MARQUEE_INTERVAL      100  // marquee progress bar animation interval\r\n\r\n// Progress bar states (Vista-only)\r\n#ifndef PBM_SETSTATE\r\n#define PBM_SETSTATE          (WM_USER + 16)\r\n#define PBST_NORMAL           0x0001\r\n#define PBST_PAUSED           0x0003\r\n#endif\r\n\r\n// Codes\r\n#define THREAD_SUSPEND_ERROR  ((DWORD)-1)\r\n#define TIMER_ID_PAUSE        1\r\n\r\n// Flags of DWORD width (which is an unsigned long)\r\n#define HCF_EXIT_PENDING      0x0001UL\r\n#define HCF_MARQUEE           0x0002UL\r\n#define HCF_RESTARTING        0x0004UL\r\n#define HVF_HAS_SET_TYPE      0x0008UL\r\n#define HVF_ITEM_HILITE       0x0010UL\r\n#define HPF_HAS_RESIZED       0x0008UL\r\n#define HPF_HLIST_PREPPED     0x0010UL\r\n#define HPF_INTERRUPTED       0x0020UL\r\n\r\n// Messages\r\n#define HM_WORKERTHREAD_DONE        (WM_APP + 0)  // wParam = ctx, lParam = 0\r\n#define HM_WORKERTHREAD_UPDATE      (WM_APP + 1)  // wParam = ctx, lParam = data\r\n#define HM_WORKERTHREAD_SETSIZE     (WM_APP + 2)  // wParam = ctx, lParam = filesize\r\n#define HM_WORKERTHREAD_TOGGLEPREP  (WM_APP + 3)  // wParam = ctx, lParam = state\r\n\r\n// Some convenient typedefs for worker thread control\r\ntypedef volatile UINT MSGCOUNT, *PMSGCOUNT;\r\ntypedef VOID (__fastcall *PFNWORKERMAIN)( PVOID );\r\n\r\n// Worker thread status\r\ntypedef volatile enum {\r\n\tINACTIVE,\r\n\tACTIVE,\r\n\tPAUSED,\r\n\tCANCEL_REQUESTED,\r\n\tCLEANUP_COMPLETED\r\n} WORKERTHREADSTATUS, *PWORKERTHREADSTATUS;\r\n\r\n// Worker thread context; all other contexts must start with this\r\ntypedef struct {\r\n\tWORKERTHREADSTATUS status;       // thread status\r\n\tDWORD              dwFlags;      // misc. status flags\r\n\tMSGCOUNT           cSentMsgs;    // number update messages sent by the worker\r\n\tMSGCOUNT           cHandledMsgs; // number update messages processed by the UI\r\n\tHWND               hWnd;         // handle of the dialog window\r\n\tHWND               hWndPBTotal;  // cache of the IDC_PROG_TOTAL progress bar handle\r\n\tHWND               hWndPBFile;   // cache of the IDC_PROG_FILE progress bar handle\r\n\tHANDLE             hThread;      // handle of the worker thread\r\n\tHANDLE             hUnpauseEvent;// handle of the event which signals when unpaused\r\n\tPFNWORKERMAIN      pfnWorkerMain;// worker function executed by the (non-GUI) thread\r\n} COMMONCONTEXT, *PCOMMONCONTEXT;\r\n\r\n// File size\r\ntypedef struct {\r\n\tULONGLONG ui64;  // uint64 representation\r\n\tTCHAR sz[32];    // string representation\r\n} FILESIZE, *PFILESIZE;\r\n\r\n// Convenience wrappers\r\nHANDLE __fastcall OpenFileForReading( PCTSTR pszPath );\r\n\r\n// Parsing helpers\r\nVOID __fastcall HCNormalizeString( PTSTR psz );\r\n\r\n// UI-related functions\r\nVOID WINAPI SetControlText( HWND hWnd, UINT uCtrlID, UINT uStringID );\r\nVOID WINAPI EnableControl( HWND hWnd, UINT uCtrlID, BOOL bEnable );\r\nVOID WINAPI FormatFractionalResults( PTSTR pszFormat, PTSTR pszBuffer, UINT uPart, UINT uTotal );\r\nVOID WINAPI SetProgressBarPause( PCOMMONCONTEXT pcmnctx, WPARAM iState );\r\n\r\n// Functions used by the main thread to control the worker thread\r\nVOID WINAPI WorkerThreadTogglePause( PCOMMONCONTEXT pcmnctx );\r\nVOID WINAPI WorkerThreadStop( PCOMMONCONTEXT pcmnctx );\r\nVOID WINAPI WorkerThreadCleanup( PCOMMONCONTEXT pcmnctx );\r\n\r\n// Worker thread functions\r\nDWORD WINAPI WorkerThreadStartup( PCOMMONCONTEXT pcmnctx );\r\nVOID WINAPI WorkerThreadHashFile( PCOMMONCONTEXT pcmnctx, PCTSTR pszPath,\r\n                                  PWHCTXEX pwhctx, PWHRESULTEX pwhres, PBYTE pbuffer,\r\n                                  PFILESIZE pFileSize, LPARAM lParam,\r\n                                  PCRITICAL_SECTION pUpdateCritSec, volatile ULONGLONG* pcbCurrentMaxSize\r\n#ifdef _TIMED\r\n                                , PDWORD pdwElapsed\r\n#endif\r\n                                );\r\n\r\n// Wrappers for SHGetInstanceExplorer\r\nULONG_PTR __fastcall HostAddRef( );\r\nVOID __fastcall HostRelease( ULONG_PTR uCookie );\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "HashCheckGlobalDefines.props",
          "type": "blob",
          "size": 0.8974609375,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <ImportGroup Label=\"PropertySheets\" />\r\n  <PropertyGroup Label=\"UserMacros\">\r\n    <TempCDefines>\r\n    </TempCDefines>\r\n  </PropertyGroup>\r\n  <PropertyGroup>\r\n    <_PropertySheetDisplayName>HashCheck Global Defines</_PropertySheetDisplayName>\r\n  </PropertyGroup>\r\n  <ItemDefinitionGroup>\r\n    <ClCompile />\r\n    <ClCompile>\r\n      <PreprocessorDefinitions>_WINDOWS;_UNICODE;UNICODE;_USRDLL;_WIN32_WINNT=0x0600;SL_ENABLE_LGBLK;SL_SMBLK_SIZE=0x1000;BYTE_ORDER=LITTLE_ENDIAN;KeccakP200_excluded;KeccakP400_excluded;KeccakP800_excluded;$(TempCDefines);%(PreprocessorDefinitions)</PreprocessorDefinitions>\r\n    </ClCompile>\r\n  </ItemDefinitionGroup>\r\n  <ItemGroup>\r\n    <BuildMacro Include=\"TempCDefines\">\r\n      <Value>$(TempCDefines)</Value>\r\n    </BuildMacro>\r\n  </ItemGroup>\r\n</Project>"
        },
        {
          "name": "HashCheckOptions.c",
          "type": "blob",
          "size": 12.66015625,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"HashCheckCommon.h\"\r\n#include \"HashCheckOptions.h\"\r\n#include \"libs/WinHash.h\"\r\n#include \"RegHelpers.h\"\r\n#include \"libs/IsFontAvailable.h\"\r\n#include <Strsafe.h>\r\n\r\n#define OPTIONS_KEYNAME TEXT(\"Software\\\\HashCheck\")\r\n\r\ntypedef struct {\r\n\tPHASHCHECKOPTIONS popt;\r\n\tHFONT hFont;\r\n\tBOOL bFontChanged;\r\n} OPTIONSCONTEXT, *POPTIONSCONTEXT;\r\n\r\nstatic const LOGFONT DEFAULT_FIXED_FONT =\r\n{\r\n\t-15,                        // lfHeight (expressed as -2 * PointSize)\r\n\t0,                          // lfWidth\r\n\t0,                          // lfEscapement\r\n\t0,                          // lfOrientation\r\n\tFW_REGULAR,                 // lfWeight\r\n\tFALSE,                      // lfItalic\r\n\tFALSE,                      // lfUnderline\r\n\tFALSE,                      // lfStrikeOut\r\n\tDEFAULT_CHARSET,            // lfCharSet\r\n\tOUT_DEFAULT_PRECIS,         // lfOutPrecision\r\n\tCLIP_DEFAULT_PRECIS,        // lfClipPrecision\r\n\tDEFAULT_QUALITY,            // lfQuality\r\n\tFIXED_PITCH | FF_DONTCARE,  // lfPitchAndFamily\r\n\tTEXT(\"Lucida Console\")      // lfFaceName[LF_FACESIZE]\r\n};\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tFunction declarations\r\n\\*============================================================================*/\r\n\r\n// Dialog general\r\nINT_PTR CALLBACK OptionsDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );\r\nVOID WINAPI OptionsDlgInit( HWND hWnd, POPTIONSCONTEXT poptctx );\r\n\r\n// Dialog commands\r\nVOID WINAPI ChangeFont( HWND hWnd, POPTIONSCONTEXT poptctx );\r\nBOOL WINAPI SaveSettings( HWND hWnd, POPTIONSCONTEXT poptctx );\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tPublic functions\r\n\\*============================================================================*/\r\n\r\nVOID CALLBACK ShowOptions_RunDLLW( HWND hWnd, HINSTANCE hInstance,\r\n                                   PWSTR pszCmdLine, INT nCmdShow )\r\n{\r\n\tHASHCHECKOPTIONS opt;\r\n\tOptionsDialog(hWnd, &opt);\r\n}\r\n\r\nVOID __fastcall OptionsDialog( HWND hWndOwner, PHASHCHECKOPTIONS popt )\r\n{\r\n\t// First, activate our manifest\r\n\tULONG_PTR uActCtxCookie = ActivateManifest(TRUE);\r\n\r\n\t// Initialize the dialog's context\r\n\tOPTIONSCONTEXT optctx = { popt, NULL, FALSE };\r\n\r\n\t// Show the options dialog; returning the results to our caller is handled\r\n\t// by the flags set in the caller's popt\r\n\tDialogBoxParam(\r\n\t\tg_hModThisDll,\r\n\t\tMAKEINTRESOURCE(IDD_OPTIONS),\r\n\t\thWndOwner,\r\n\t\tOptionsDlgProc,\r\n\t\t(LPARAM)&optctx\r\n\t);\r\n\r\n\t// Release the font handle, if the dialog created one\r\n\tif (optctx.hFont) DeleteObject(optctx.hFont);\r\n\r\n\t// Clean up the manifest activation\r\n\tDeactivateManifest(uActCtxCookie);\r\n}\r\n\r\nVOID __fastcall OptionsLoad( PHASHCHECKOPTIONS popt )\r\n{\r\n\tHKEY hKey;\r\n\r\n\tif (RegOpenKeyEx(HKEY_CURRENT_USER, OPTIONS_KEYNAME, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS)\r\n\t\thKey = NULL;\r\n\r\n\tif (popt->dwFlags & HCOF_FILTERINDEX)\r\n\t{\r\n\t\tif (!( hKey &&\r\n\t\t       RegGetDW(hKey, TEXT(\"FilterIndex\"), &popt->dwFilterIndex) &&\r\n\t\t\t   popt->dwFilterIndex && popt->dwFilterIndex <= NUM_HASHES))\r\n\t\t{\r\n\t\t\t// Fall back to default (SHA-256)\r\n\t\t\tpopt->dwFilterIndex = DEFAULT_HASH_ALGORITHM;\r\n\t\t}\r\n\t}\r\n\r\n\tif (popt->dwFlags & HCOF_MENUDISPLAY)\r\n\t{\r\n\t\tif (!( hKey &&\r\n\t\t       RegGetDW(hKey, TEXT(\"MenuDisplay\"), &popt->dwMenuDisplay) &&\r\n\t\t       popt->dwMenuDisplay < 3 ))\r\n\t\t{\r\n\t\t\t// Fall back to default (always show)\r\n\t\t\tpopt->dwMenuDisplay = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (popt->dwFlags & HCOF_SAVEENCODING)\r\n\t{\r\n\t\tif (!( hKey &&\r\n\t\t       RegGetDW(hKey, TEXT(\"SaveEncoding\"), &popt->dwSaveEncoding) &&\r\n\t\t       popt->dwSaveEncoding < 3 ))\r\n\t\t{\r\n\t\t\t// Fall back to default (UTF-8)\r\n\t\t\tpopt->dwSaveEncoding = 0;\r\n\t\t}\r\n\t}\r\n\r\n    if (popt->dwFlags & HCOF_CHECKSUMS)\r\n    {\r\n        if (!(hKey &&\r\n            RegGetDW(hKey, TEXT(\"Checksums\"), &popt->dwChecksums) &&\r\n            popt->dwChecksums > 0 && popt->dwChecksums <= WHEX_ALL))\r\n        {\r\n            // Fall back to default (CRC-32, SHA-1, both SHA-2's)\r\n            popt->dwChecksums = DEFAULT_HASH_ALGORITHMS;\r\n        }\r\n    }\r\n\r\n\tif (popt->dwFlags & HCOF_FONT)\r\n\t{\r\n\t\tDWORD dwType;\r\n\t\tDWORD cbData = sizeof(LOGFONT);\r\n\r\n\t\tif (!( hKey && ERROR_SUCCESS ==\r\n\t\t       RegQueryValueEx(hKey, TEXT(\"Font\"), NULL, &dwType, (PBYTE)&popt->lfFont, &cbData) &&\r\n\t\t       dwType == REG_BINARY && cbData == sizeof(LOGFONT)) )\r\n\t\t{\r\n\t\t\tHDC hDC;\r\n\r\n\t\t\t// Copy the default font (Lucida Console)\r\n\t\t\tmemcpy(&popt->lfFont, &DEFAULT_FIXED_FONT, sizeof(LOGFONT));\r\n\r\n\t\t\t// Use Consolas if it is available\r\n\t\t\tif (IsFontAvailable(TEXT(\"Consolas\")))\r\n\t\t\t{\r\n\t\t\t\tpopt->lfFont.lfHeight = -16;\r\n\t\t\t\tpopt->lfFont.lfQuality = CLEARTYPE_QUALITY;\r\n\t\t\t\tSSStaticCpy(popt->lfFont.lfFaceName, TEXT(\"Consolas\"));\r\n\t\t\t}\r\n\r\n\t\t\t// Convert our -2 * PointSize to device units\r\n\t\t\thDC = GetDC(NULL);\r\n\t\t\tpopt->lfFont.lfHeight = MulDiv(popt->lfFont.lfHeight, GetDeviceCaps(hDC, LOGPIXELSY), 144);\r\n\t\t\tReleaseDC(NULL, hDC);\r\n\t\t}\r\n\t}\r\n\r\n\tif (hKey)\r\n\t\tRegCloseKey(hKey);\r\n}\r\n\r\nVOID __fastcall OptionsSave( PHASHCHECKOPTIONS popt )\r\n{\r\n\tHKEY hKey;\r\n\r\n\t// Avoid creating the key if nothing is being set\r\n\tif (popt->dwFlags == 0)\r\n\t\treturn;\r\n\r\n\tif (hKey = RegOpen(HKEY_CURRENT_USER, OPTIONS_KEYNAME, NULL, TRUE))\r\n\t{\r\n\t\tif (popt->dwFlags & HCOF_FILTERINDEX)\r\n\t\t\tRegSetDW(hKey, TEXT(\"FilterIndex\"), popt->dwFilterIndex);\r\n\r\n\t\tif (popt->dwFlags & HCOF_MENUDISPLAY)\r\n\t\t\tRegSetDW(hKey, TEXT(\"MenuDisplay\"), popt->dwMenuDisplay);\r\n\r\n\t\tif (popt->dwFlags & HCOF_SAVEENCODING)\r\n\t\t\tRegSetDW(hKey, TEXT(\"SaveEncoding\"), popt->dwSaveEncoding);\r\n\r\n        if (popt->dwFlags & HCOF_CHECKSUMS)\r\n            RegSetDW(hKey, TEXT(\"Checksums\"), popt->dwChecksums);\r\n\r\n\t\tif (popt->dwFlags & HCOF_FONT)\r\n\t\t\tRegSetValueEx(hKey, TEXT(\"Font\"), 0, REG_BINARY, (PBYTE)&popt->lfFont, sizeof(LOGFONT));\r\n\r\n\t\tRegCloseKey(hKey);\r\n\t}\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog general\r\n\\*============================================================================*/\r\n\r\nINT_PTR CALLBACK OptionsDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\r\n{\r\n\tswitch (uMsg)\r\n\t{\r\n\t\tcase WM_INITDIALOG:\r\n\t\t{\r\n\t\t\tSetWindowLongPtr(hWnd, DWLP_USER, lParam);\r\n\t\t\tOptionsDlgInit(hWnd, (POPTIONSCONTEXT)lParam);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase WM_ENDSESSION:\r\n        {\r\n            if (wParam == FALSE)  // if TRUE, fall through to WM_CLOSE\r\n                break;\r\n        }\r\n\t\tcase WM_CLOSE:\r\n\t\t{\r\n\t\t\tgoto end_dialog;\r\n\t\t}\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t{\r\n\t\t\tPOPTIONSCONTEXT poptctx = (POPTIONSCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\tswitch (LOWORD(wParam))\r\n\t\t\t{\r\n\t\t\t\tcase IDC_OPT_FONT_CHANGE:\r\n\t\t\t\t\tChangeFont(hWnd, poptctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\r\n\t\t\t\tcase IDC_OK:\r\n                    if (SaveSettings(hWnd, poptctx) == FALSE)\r\n                        return(TRUE);  // don't close on save errors\r\n\t\t\t\tcase IDC_CANCEL:\r\n\t\t\t\t\tend_dialog: EndDialog(hWnd, 0);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n        case WM_NOTIFY:\r\n        {\r\n            PNMLINK pLinkCtrl = (PNMLINK)lParam;\r\n            if (pLinkCtrl->hdr.idFrom == IDC_OPT_LINK)\r\n                switch (pLinkCtrl->hdr.code)\r\n                {\r\n                    case NM_CLICK:\r\n                    case NM_RETURN:\r\n                        ShellExecute(hWnd, NULL, pLinkCtrl->item.szUrl, NULL, NULL, SW_SHOWNORMAL);\r\n                        return(TRUE);\r\n                }\r\n\r\n            break;\r\n        }\r\n\r\n\t}\r\n\r\n\treturn(FALSE);\r\n}\r\n\r\nVOID WINAPI OptionsDlgInit( HWND hWnd, POPTIONSCONTEXT poptctx )\r\n{\r\n\t// Load strings\r\n\t{\r\n\t\tstatic const UINT16 arStrMap[][2] =\r\n\t\t{\r\n\t\t\t{ IDC_OPT_CM,             IDS_OPT_CM             },\r\n\t\t\t{ IDC_OPT_CM_ALWAYS,      IDS_OPT_CM_ALWAYS      },\r\n\t\t\t{ IDC_OPT_CM_EXTENDED,    IDS_OPT_CM_EXTENDED    },\r\n\t\t\t{ IDC_OPT_CM_NEVER,       IDS_OPT_CM_NEVER       },\r\n\t\t\t{ IDC_OPT_ENCODING,       IDS_OPT_ENCODING       },\r\n\t\t\t{ IDC_OPT_ENCODING_UTF8,  IDS_OPT_ENCODING_UTF8  },\r\n\t\t\t{ IDC_OPT_ENCODING_UTF16, IDS_OPT_ENCODING_UTF16 },\r\n\t\t\t{ IDC_OPT_ENCODING_ANSI,  IDS_OPT_ENCODING_ANSI  },\r\n\t\t\t{ IDC_OPT_CHK,            IDS_OPT_CHK            },\r\n\t\t\t{ IDC_OPT_FONT,           IDS_OPT_FONT           },\r\n\t\t\t{ IDC_OPT_FONT_CHANGE,    IDS_OPT_FONT_CHANGE    },\r\n\t\t\t{ IDC_OK,                 IDS_OPT_OK             },\r\n\t\t\t{ IDC_CANCEL,             IDS_OPT_CANCEL         }\r\n\t\t};\r\n\r\n\t\tstatic const TCHAR szFormat[] = TEXT(\"%s (v\") TEXT(HASHCHECK_VERSION_STR) TEXT(\"/\") TEXT(ARCH_NAME_PART) TEXT(\")\");\r\n\r\n\t\tTCHAR szBuffer[MAX_STRINGMSG], szTitle[MAX_STRINGMSG];\r\n\t\tUINT i;\r\n\r\n\t\tfor (i = 0; i < countof(arStrMap); ++i)\r\n\t\t\tSetControlText(hWnd, arStrMap[i][0], arStrMap[i][1]);\r\n\r\n\t\tLoadString(g_hModThisDll, IDS_OPT_TITLE, szBuffer, countof(szBuffer));\r\n\t\tStringCchPrintf(szTitle, countof(szTitle), szFormat, szBuffer);\r\n\t\tSendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)szTitle);\r\n\t}\r\n\r\n\t// Load options\r\n\t{\r\n\t\tpoptctx->popt->dwFlags = HCOF_ALL;\r\n\t\tOptionsLoad(poptctx->popt);\r\n\t\tpoptctx->popt->dwFlags = 0;\r\n\r\n\t\tSendDlgItemMessage(hWnd, IDC_OPT_CM_FIRSTID + poptctx->popt->dwMenuDisplay,\r\n\t\t                   BM_SETCHECK, BST_CHECKED, 0);\r\n\r\n\t\tSendDlgItemMessage(hWnd, IDC_OPT_ENCODING_FIRSTID + poptctx->popt->dwSaveEncoding,\r\n\t\t                   BM_SETCHECK, BST_CHECKED, 0);\r\n\r\n#define HASH_OPT_SET_CHECKS_op(alg)                        \\\r\n        if (poptctx->popt->dwChecksums & WHEX_CHECK##alg)  \\\r\n            SendDlgItemMessage(hWnd, IDC_OPT_CHK_##alg, BM_SETCHECK, BST_CHECKED, 0);\r\n        FOR_EACH_HASH(HASH_OPT_SET_CHECKS_op)\r\n\r\n\t\tif (poptctx->hFont = CreateFontIndirect(&poptctx->popt->lfFont))\r\n\t\t\tSendDlgItemMessage(hWnd, IDC_OPT_FONT_PREVIEW, WM_SETFONT, (WPARAM)poptctx->hFont, FALSE);\r\n\r\n\t\tSetDlgItemText(hWnd, IDC_OPT_FONT_PREVIEW, poptctx->popt->lfFont.lfFaceName);\r\n\t}\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog commands\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI ChangeFont( HWND hWnd, POPTIONSCONTEXT poptctx )\r\n{\r\n\tHFONT hFont;\r\n\r\n\tCHOOSEFONT cf;\r\n\tcf.lStructSize = sizeof(cf);\r\n\tcf.hwndOwner = hWnd;\r\n\tcf.lpLogFont = &poptctx->popt->lfFont;\r\n\tcf.Flags = CF_FIXEDPITCHONLY | CF_FORCEFONTEXIST | CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS;\r\n\r\n\tif (ChooseFont(&cf) && (hFont = CreateFontIndirect(&poptctx->popt->lfFont)))\r\n\t{\r\n\t\t// Signal that a new font should be saved if \"OK\" is pressed\r\n\t\tpoptctx->bFontChanged = TRUE;\r\n\r\n\t\t// Update the preview\r\n\t\tSendDlgItemMessage(hWnd, IDC_OPT_FONT_PREVIEW, WM_SETFONT, (WPARAM)hFont, FALSE);\r\n\t\tSetDlgItemText(hWnd, IDC_OPT_FONT_PREVIEW, poptctx->popt->lfFont.lfFaceName);\r\n\r\n\t\t// Clean up\r\n\t\tif (poptctx->hFont) DeleteObject(poptctx->hFont);\r\n\t\tpoptctx->hFont = hFont;\r\n\t}\r\n}\r\n\r\nBOOL WINAPI SaveSettings( HWND hWnd, POPTIONSCONTEXT poptctx )\r\n{\r\n\tDWORD i;\r\n\r\n    // Get the user-selected value for dwChecksums\r\n    i = 0;\r\n#define HASH_OPT_GET_CHECKS_op(alg)                                                     \\\r\n    if (SendDlgItemMessage(hWnd, IDC_OPT_CHK_##alg, BM_GETCHECK, 0, 0) == BST_CHECKED)  \\\r\n        i |= WHEX_CHECK##alg;\r\n    FOR_EACH_HASH(HASH_OPT_GET_CHECKS_op)\r\n\r\n    // Ensure at least one is checked\r\n    if (i == 0)\r\n    {\r\n        TCHAR szError[MAX_STRINGMSG];\r\n        // \"Please select at least one checksum\"\r\n        LoadString(g_hModThisDll, IDS_OPT_CHK_ERROR, szError, countof(szError));\r\n        MessageBox(hWnd, szError, NULL, MB_ICONWARNING);\r\n        return(FALSE);\r\n    }\r\n\r\n    // If the value has changed, flag it for saving\r\n    if (i <= WHEX_ALL && poptctx->popt->dwChecksums != i)\r\n    {\r\n        poptctx->popt->dwFlags |= HCOF_CHECKSUMS;\r\n        poptctx->popt->dwChecksums = i;\r\n    }\r\n\r\n\t// Get the user-selected value for dwMenuDisplay\r\n\tfor (i = 0; i < 3; ++i)\r\n\t{\r\n\t\tif (SendDlgItemMessage(hWnd, IDC_OPT_CM_FIRSTID + i, BM_GETCHECK, 0, 0) == BST_CHECKED)\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t// If the value has changed, flag it for saving\r\n\tif (i < 3 && poptctx->popt->dwMenuDisplay != i)\r\n\t{\r\n\t\tpoptctx->popt->dwFlags |= HCOF_MENUDISPLAY;\r\n\t\tpoptctx->popt->dwMenuDisplay = i;\r\n\t}\r\n\r\n\t// Get the user-selected value for dwSaveEncoding\r\n\tfor (i = 0; i < 3; ++i)\r\n\t{\r\n\t\tif (SendDlgItemMessage(hWnd, IDC_OPT_ENCODING_FIRSTID + i, BM_GETCHECK, 0, 0) == BST_CHECKED)\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t// If the value has changed, flag it for saving\r\n\tif (i < 3 && poptctx->popt->dwSaveEncoding != i)\r\n\t{\r\n\t\tpoptctx->popt->dwFlags |= HCOF_SAVEENCODING;\r\n\t\tpoptctx->popt->dwSaveEncoding = i;\r\n\t}\r\n\r\n\t// Flag the font for saving if necessary\r\n\tif (poptctx->bFontChanged)\r\n\t\tpoptctx->popt->dwFlags |= HCOF_FONT;\r\n\r\n\tOptionsSave(poptctx->popt);\r\n\r\n    return(TRUE);\r\n}\r\n"
        },
        {
          "name": "HashCheckOptions.h",
          "type": "blob",
          "size": 1.3212890625,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __HASHCHECKOPTIONS_H__\r\n#define __HASHCHECKOPTIONS_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\n// Options struct\r\ntypedef struct {\r\n\tDWORD dwFlags;\r\n\tDWORD dwFilterIndex;\r\n\tDWORD dwMenuDisplay;\r\n\tDWORD dwSaveEncoding;\r\n\tDWORD dwChecksums;\r\n\tLOGFONT lfFont;\r\n} HASHCHECKOPTIONS, *PHASHCHECKOPTIONS;\r\n\r\n// Options flags\r\n#define HCOF_FILTERINDEX  0x00000001  // The dwFilterIndex member is valid\r\n#define HCOF_MENUDISPLAY  0x00000002  // The dwMenuDisplay member is valid\r\n#define HCOF_SAVEENCODING 0x00000004  // The dwSaveEncoding member is valid\r\n#define HCOF_FONT         0x00000008  // The lfFont member is valid\r\n#define HCOF_CHECKSUMS    0x00000010  // The dwChecksums member is valid\r\n#define HCOF_ALL          0x0000001F\r\n\r\n// Public functions\r\nVOID __fastcall OptionsDialog( HWND hWndOwner, PHASHCHECKOPTIONS popt );\r\nVOID __fastcall OptionsLoad( PHASHCHECKOPTIONS popt );\r\nVOID __fastcall OptionsSave( PHASHCHECKOPTIONS popt );\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "HashCheckResources.h",
          "type": "blob",
          "size": 2.705078125,
          "content": "#define IDC_STATIC                      -1\r\n\r\n#define IDR_RT_MANIFEST                 ISOLATIONAWARE_MANIFEST_RESOURCE_ID\r\n\r\n#define IDI_FILETYPE                    100\r\n#define IDI_MENUBITMAP                  101\r\n\r\n// Controls common to multiple dialogs\r\n#define IDC_PROG_TOTAL                  102\r\n#define IDC_PROG_FILE                   103\r\n#define IDC_PAUSE                       104\r\n#define IDC_STOP                        105\r\n#define IDC_OK                          IDOK\r\n#define IDC_CANCEL                      IDCANCEL\r\n\r\n// Hash creation/save (context menu) dialog\r\n#define IDD_HASHSAVE                    200\r\n\r\n// Hash calculation property sheet and controls\r\n// (some of these must be copied to HashProp.cs)\r\n#define IDD_HASHPROP                    300\r\n#define IDC_RESULTS                     301\r\n#define IDC_STATUSBOX                   302\r\n#define IDC_SEARCHBOX                   303\r\n#define IDC_FIND_NEXT                   304\r\n#define IDC_SAVE                        305\r\n#define IDC_OPTIONS                     306\r\n\r\n// Hash verification dialog and controls\r\n// (some of these must be copied to HashVerify.cs)\r\n#define IDD_HASHVERF                    400\r\n#define IDC_LIST                        401\r\n#define IDC_SUMMARY                     402\r\n#define IDC_MATCH_LABEL                 403\r\n#define IDC_MATCH_RESULTS               404\r\n#define IDC_MISMATCH_LABEL              405\r\n#define IDC_MISMATCH_RESULTS            406\r\n#define IDC_UNREADABLE_LABEL            407\r\n#define IDC_UNREADABLE_RESULTS          408\r\n#define IDC_PENDING_LABEL               409\r\n#define IDC_PENDING_RESULTS             410\r\n#define IDC_EXIT                        IDCANCEL\r\n\r\n// Options dialog\r\n#define IDD_OPTIONS                     500\r\n#define IDC_OPT_CM                      501\r\n#define IDC_OPT_CM_ALWAYS               502\r\n#define IDC_OPT_CM_EXTENDED             503\r\n#define IDC_OPT_CM_NEVER                504\r\n#define IDC_OPT_CM_FIRSTID              IDC_OPT_CM_ALWAYS\r\n#define IDC_OPT_ENCODING                505\r\n#define IDC_OPT_ENCODING_UTF8           506\r\n#define IDC_OPT_ENCODING_UTF16          507\r\n#define IDC_OPT_ENCODING_ANSI           508\r\n#define IDC_OPT_ENCODING_FIRSTID        IDC_OPT_ENCODING_UTF8\r\n#define IDC_OPT_CHK                     509\r\n#define IDC_OPT_CHK_CRC32               510\r\n#define IDC_OPT_CHK_MD5                 511\r\n#define IDC_OPT_CHK_SHA1                512\r\n#define IDC_OPT_CHK_SHA256              513\r\n#define IDC_OPT_CHK_SHA512              514\r\n#define IDC_OPT_CHK_SHA3_256            515\r\n#define IDC_OPT_CHK_SHA3_512            516\r\n#define IDC_OPT_FONT                    517\r\n#define IDC_OPT_FONT_CHANGE             518\r\n#define IDC_OPT_FONT_PREVIEW            519\r\n#define IDC_OPT_LINK                    520\r\n"
        },
        {
          "name": "HashCheckTranslations.h",
          "type": "blob",
          "size": 3.072265625,
          "content": "#define IDS_FILETYPE_DESC               0x4000\r\n\r\n#define IDS_HC_PAUSE                    0x4100\r\n#define IDS_HC_RESUME                   0x4101\r\n#define IDS_HC_STOP                     0x4102\r\n#define IDS_HC_RESULT_FMT               0x4103\r\n#define IDS_HC_RESULTS_FMT              0x4104\r\n#define IDS_HC_SAVE_ERROR               0x4105\r\n#define IDS_HC_OK                       0x4106\r\n#define IDS_HC_CANCEL                   0x4107\r\n\r\n#define IDS_HS_MENUTEXT                 0x4200\r\n#define IDS_HS_TITLE_FMT                0x4201\r\n#define IDS_HS_PAUSE                    IDS_HC_PAUSE\r\n#define IDS_HS_RESUME                   IDS_HC_RESUME\r\n#define IDS_HS_CANCEL                   IDS_HC_CANCEL\r\n\r\n#define IDS_HP_TITLE                    0x4300\r\n#define IDS_HP_STATUSBOX                0x4301\r\n#define IDS_HP_STATUSTEXT_FMT           0x4302\r\n#define IDS_HP_RESULT_FMT               IDS_HC_RESULT_FMT\r\n#define IDS_HP_RESULTS_FMT              IDS_HC_RESULTS_FMT\r\n#define IDS_HP_FIND                     0x4303\r\n#define IDS_HP_FIND_NOSTRING            0x4304\r\n#define IDS_HP_FIND_NOTFOUND            0x4305\r\n#define IDS_HP_PAUSE                    IDS_HC_PAUSE\r\n#define IDS_HP_RESUME                   IDS_HC_RESUME\r\n#define IDS_HP_STOP                     IDS_HC_STOP\r\n#define IDS_HP_SAVE                     0x4306\r\n#define IDS_HP_OPTIONS                  0x4307\r\n#define IDS_HP_FILELABEL                0x4308\r\n\r\n#define IDS_HV_LOADERROR_FMT            0x4400\r\n#define IDS_HV_SUMMARY                  0x4401\r\n#define IDS_HV_MATCH                    0x4402\r\n#define IDS_HV_MISMATCH                 0x4403\r\n#define IDS_HV_UNREADABLE               0x4404\r\n#define IDS_HV_PENDING                  0x4405\r\n#define IDS_HV_RESULT_FMT               IDS_HC_RESULT_FMT\r\n#define IDS_HV_RESULTS_FMT              IDS_HC_RESULTS_FMT\r\n#define IDS_HV_PAUSE                    IDS_HC_PAUSE\r\n#define IDS_HV_RESUME                   IDS_HC_RESUME\r\n#define IDS_HV_STOP                     IDS_HC_STOP\r\n#define IDS_HV_EXIT                     0x4406\r\n#define IDS_HV_COL_FILENAME             0x4407\r\n#define IDS_HV_COL_SIZE                 0x4408\r\n#define IDS_HV_COL_STATUS               0x4409\r\n#define IDS_HV_COL_EXPECTED             0x440A\r\n#define IDS_HV_COL_ACTUAL               0x440B\r\n#define IDS_HV_STATUS_MATCH             0x440C\r\n#define IDS_HV_STATUS_MISMATCH          0x440D\r\n#define IDS_HV_STATUS_UNREADABLE        0x440E\r\n\r\n#define IDS_OPT_TITLE                   0x4500\r\n#define IDS_OPT_CM                      0x4501\r\n#define IDS_OPT_CM_ALWAYS               0x4502\r\n#define IDS_OPT_CM_EXTENDED             0x4503\r\n#define IDS_OPT_CM_NEVER                0x4504\r\n#define IDS_OPT_ENCODING                0x4505\r\n#define IDS_OPT_ENCODING_UTF8           0x4506\r\n#define IDS_OPT_ENCODING_UTF16          0x4507\r\n#define IDS_OPT_ENCODING_ANSI           0x4508\r\n#define IDS_OPT_CHK                     0x4509\r\n#define IDS_OPT_CHK_ERROR               0x450A\r\n#define IDS_OPT_FONT                    0x450B\r\n#define IDS_OPT_FONT_CHANGE             0x450C\r\n#define IDS_OPT_OK                      IDS_HC_OK\r\n#define IDS_OPT_CANCEL                  IDS_HC_CANCEL\r\n"
        },
        {
          "name": "HashCheckTranslations.rc",
          "type": "blob",
          "size": 51.501953125,
          "content": "//\r\n// NOTE: This file is encoded in UTF-8.\r\n//\r\n\r\n#include \"HashCheckTranslations.h\"\r\n\r\n// English\r\nSTRINGTABLE LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US\r\n{\r\n\tIDS_FILETYPE_DESC        \"Checksum File\"           // shown in the \"Type\" column in Explorer for files associated with HashCheck\r\n\r\n\t// Strings used in multiple modules\r\n\tIDS_HC_PAUSE             \"&Pause\"\r\n\tIDS_HC_RESUME            \"&Resume\"\r\n\tIDS_HC_STOP              \"&Stop\"\r\n\tIDS_HC_RESULT_FMT        \"%u of %u file\"           // %u, %u == count, total; prefix with \"!\" to reverse the order (singular version)\r\n\tIDS_HC_RESULTS_FMT       \"%u of %u files\"          // %u, %u == count, total; prefix with \"!\" to reverse the order (plural version)\r\n\tIDS_HC_SAVE_ERROR        \"Cannot open checksum file for writing.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Cancel\"\r\n\r\n\t// Strings used exclusively in the HashSave module (context menu)\r\n\tIDS_HS_MENUTEXT          \"Create Chec&ksum File...\"\r\n\tIDS_HS_TITLE_FMT         \"Creating \"\"%s\"\"...\"      // %s == name of the checksum file\r\n\r\n\t// Strings used exclusively in the HashProp module (file properties tab)\r\n\tIDS_HP_TITLE             \"Checksums\"\r\n\tIDS_HP_STATUSBOX         \"Progress\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s successfully hashed\"  // %s == result summary in the form of IDS_HC_RESULT(S)_FMT\r\n\tIDS_HP_FIND              \"&Find\"\r\n\tIDS_HP_FIND_NOSTRING     \"Enter search text.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Text not found.\"\r\n\tIDS_HP_SAVE              \"&Save...\"\r\n\tIDS_HP_OPTIONS           \"&Options\"\r\n\tIDS_HP_FILELABEL         \"    File: \"              // should have the same width as \"SHA3-256: \"; may translate \"Name\" if \"File\" is too long\r\n\r\n\t// Strings used exclusively in the HashVerify module\r\n\tIDS_HV_LOADERROR_FMT     \"Cannot load \"\"%s\"\"\"      // %s == name of the checksum file\r\n\tIDS_HV_SUMMARY           \"Summary\"\r\n\tIDS_HV_MATCH             \"Match:\"\r\n\tIDS_HV_MISMATCH          \"Mismatch:\"\r\n\tIDS_HV_UNREADABLE        \"Unreadable:\"             // files that cannot be opened or fully read (summary label)\r\n\tIDS_HV_PENDING           \"Remaining:\"              // files that have not yet been checked\r\n\tIDS_HV_EXIT              \"E&xit\"\r\n\tIDS_HV_COL_FILENAME      \"File Name\"\r\n\tIDS_HV_COL_SIZE          \"Size\"\r\n\tIDS_HV_COL_STATUS        \"Status\"\r\n\tIDS_HV_COL_EXPECTED      \"Expected Checksum\"\r\n\tIDS_HV_COL_ACTUAL        \"Actual Checksum\"\r\n\tIDS_HV_STATUS_MATCH      \"MATCH\"\r\n\tIDS_HV_STATUS_MISMATCH   \"MISMATCH\"\r\n\tIDS_HV_STATUS_UNREADABLE \"UNREADABLE\"              // files that cannot be opened or fully read (status column text)\r\n\r\n\t// Strings for the options dialog\r\n\tIDS_OPT_TITLE            \"HashCheck Options\"\r\n\tIDS_OPT_CM               \"Shell integration\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Show HashCheck in the shortcut menu\"\r\n\tIDS_OPT_CM_EXTENDED      \"Show HashCheck in the &extended shortcut menu\"\r\n\tIDS_OPT_CM_NEVER         \"&Never show HashCheck in the shortcut menu\"\r\n\tIDS_OPT_ENCODING         \"Checksum file character encoding\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Save using U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Save using &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Save using &ANSI\"\r\n\tIDS_OPT_CHK              \"File properties checksums\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"File properties checksums font\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Change...\"\r\n}\r\n\r\n// 中文 (繁體)\r\nSTRINGTABLE LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"校驗檔\"\r\n\r\n\tIDS_HC_PAUSE             \"暫停(&P)\"\r\n\tIDS_HC_RESUME            \"繼續(&R)\"\r\n\tIDS_HC_STOP              \"停止(&S)\"\r\n\tIDS_HC_RESULT_FMT        \"%u / %u 個檔案 \"\r\n\tIDS_HC_RESULTS_FMT       \"%u / %u 個檔案\"\r\n\tIDS_HC_SAVE_ERROR        \"無法寫入校驗檔案。\"\r\n\tIDS_HC_OK                \"確定\"\r\n\tIDS_HC_CANCEL            \"取消\"\r\n\r\n\tIDS_HS_MENUTEXT          \"建立校驗檔案(&K)...\"\r\n\tIDS_HS_TITLE_FMT         \"正在建立 \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"檔案校驗\"\r\n\tIDS_HP_STATUSBOX         \"進度\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s 已計算完畢\"\r\n\tIDS_HP_FIND              \"尋找(&F)\"\r\n\tIDS_HP_FIND_NOSTRING     \"輸入搜尋文字。\"\r\n\tIDS_HP_FIND_NOTFOUND     \"未找到文字。\"\r\n\tIDS_HP_SAVE              \"儲存(&S)...\"\r\n\tIDS_HP_OPTIONS           \"選項(&O)\"\r\n\tIDS_HP_FILELABEL         \"    File: \"  // alternatively, \"　　檔案: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"無法載入 \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"摘要\"\r\n\tIDS_HV_MATCH             \"符合：\"\r\n\tIDS_HV_MISMATCH          \"不符合：\"\r\n\tIDS_HV_UNREADABLE        \"無法讀取：\"\r\n\tIDS_HV_PENDING           \"剩餘：\"\r\n\tIDS_HV_EXIT              \"關閉(&X)\"\r\n\tIDS_HV_COL_FILENAME      \"檔案\"\r\n\tIDS_HV_COL_SIZE          \"大小\"\r\n\tIDS_HV_COL_STATUS        \"狀態\"\r\n\tIDS_HV_COL_EXPECTED      \"預期校驗值\"\r\n\tIDS_HV_COL_ACTUAL        \"實際校驗值\"\r\n\tIDS_HV_STATUS_MATCH      \"符合\"\r\n\tIDS_HV_STATUS_MISMATCH   \"不符合\"\r\n\tIDS_HV_STATUS_UNREADABLE \"無法讀取\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck 選項\"\r\n\tIDS_OPT_CM               \"介面整合\"\r\n\tIDS_OPT_CM_ALWAYS        \"在右鍵選單顯示 HashCheck (&S)\"\r\n\tIDS_OPT_CM_EXTENDED      \"在右鍵延伸選單顯示 HashCheck (&E)\"\r\n\tIDS_OPT_CM_NEVER         \"不要在右鍵選單顯示 HashCheck (&N)\"\r\n\tIDS_OPT_ENCODING         \"校驗檔案編碼\"\r\n\tIDS_OPT_ENCODING_UTF8    \"使用 UTF-8 儲存(&T)\"\r\n\tIDS_OPT_ENCODING_UTF16   \"使用 UTF-16LE 儲存(&U)\"\r\n\tIDS_OPT_ENCODING_ANSI    \"使用 ANSI 儲存(&A)\"\r\n\tIDS_OPT_CHK              \"選擇校驗和\"\r\n\tIDS_OPT_CHK_ERROR        \"請選擇至少一種校驗和\"\r\n\tIDS_OPT_FONT             \"屬性頁面字型\"\r\n\tIDS_OPT_FONT_CHANGE      \"變更(&C)...\"\r\n}\r\n\r\n// 中文 (简体)\r\nSTRINGTABLE LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED\r\n{\r\n\tIDS_FILETYPE_DESC        \"文件校验信息\"\r\n\r\n\tIDS_HC_PAUSE             \"暂停(&P)\"\r\n\tIDS_HC_RESUME            \"继续(&R)\"\r\n\tIDS_HC_STOP              \"停止(&S)\"\r\n\tIDS_HC_RESULT_FMT        \"!%u 个文件中的 %u 个\"\r\n\tIDS_HC_RESULTS_FMT       \"!%u 个文件中的 %u 个\"\r\n\tIDS_HC_SAVE_ERROR        \"无法写入目标文件。\"\r\n\tIDS_HC_OK                \"确定\"\r\n\tIDS_HC_CANCEL            \"取消\"\r\n\r\n\tIDS_HS_MENUTEXT          \"创建校验信息文件(&K)...\"\r\n\tIDS_HS_TITLE_FMT         \"正在创建 \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"文件校验\"\r\n\tIDS_HP_STATUSBOX         \"进度\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s已计算完毕\"\r\n\tIDS_HP_FIND              \"查找(&F)\"\r\n\tIDS_HP_FIND_NOSTRING     \"请输入要搜索的字符。\"\r\n\tIDS_HP_FIND_NOTFOUND     \"未找到文本。\"\r\n\tIDS_HP_SAVE              \"保存(&S)...\"\r\n\tIDS_HP_OPTIONS           \"选项(&O)\"\r\n\tIDS_HP_FILELABEL         \"    File: \"  // alternatively, \"　　文件: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"无法载入 \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"摘要\"\r\n\tIDS_HV_MATCH             \"相符:\"\r\n\tIDS_HV_MISMATCH          \"不符合:\"\r\n\tIDS_HV_UNREADABLE        \"不可读取:\"\r\n\tIDS_HV_PENDING           \"待检测:\"\r\n\tIDS_HV_EXIT              \"退出(&X)\"\r\n\tIDS_HV_COL_FILENAME      \"文件名\"\r\n\tIDS_HV_COL_SIZE          \"大小\"\r\n\tIDS_HV_COL_STATUS        \"状态\"\r\n\tIDS_HV_COL_EXPECTED      \"期望校验值\"\r\n\tIDS_HV_COL_ACTUAL        \"实际校验值\"\r\n\tIDS_HV_STATUS_MATCH      \"相 符\"\r\n\tIDS_HV_STATUS_MISMATCH   \"不 符\"\r\n\tIDS_HV_STATUS_UNREADABLE \"无法读取\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck 选项\"\r\n\tIDS_OPT_CM               \"右键关联菜单\"\r\n\tIDS_OPT_CM_ALWAYS        \"总是在右键菜单中显示 HashCheck (&S)\"\r\n\tIDS_OPT_CM_EXTENDED      \"仅在扩展右键菜单中显示 HashCheck (&E)\"\r\n\tIDS_OPT_CM_NEVER         \"在右键菜单中不显示 HashCheck (&N)\"\r\n\tIDS_OPT_ENCODING         \"文件校验信息文件编码\"\r\n\tIDS_OPT_ENCODING_UTF8    \"使用 UTF-8 保存(&T)\"\r\n\tIDS_OPT_ENCODING_UTF16   \"使用 UTF-16LE 保存(&U)\"\r\n\tIDS_OPT_ENCODING_ANSI    \"使用当前 ANSI 代码页保存(&A)\"\r\n\tIDS_OPT_CHK              \"文件校验\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"属性页字体\"\r\n\tIDS_OPT_FONT_CHANGE      \"更改字体(&C)...\"\r\n}\r\n\r\n// čeština\r\nSTRINGTABLE LANGUAGE LANG_CZECH, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Soubor kontrolního součtu\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pozastavit\"\r\n\tIDS_HC_RESUME            \"&Obnovit\"\r\n\tIDS_HC_STOP              \"&Zastavit\"\r\n\tIDS_HC_RESULT_FMT        \"%u z %u souboru\"\r\n\tIDS_HC_RESULTS_FMT       \"%u ze %u souborů\"\r\n\tIDS_HC_SAVE_ERROR        \"Nemohu otevřít soubor kontrolního součtu pro zápis.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Storno\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Vytvoř soubor &kontrolního součtu...\"\r\n\tIDS_HS_TITLE_FMT         \"Vytvářím \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Kontrolní součty\"\r\n\tIDS_HP_STATUSBOX         \"Postup\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s úspěšných\"\r\n\tIDS_HP_FIND              \"&Hledej\"\r\n\tIDS_HP_FIND_NOSTRING     \"Vlož text k vyhledání.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Text nenalezen.\"\r\n\tIDS_HP_SAVE              \"&Ulož...\"\r\n\tIDS_HP_OPTIONS           \"&Nastavení\"\r\n\tIDS_HP_FILELABEL         \"  Soubor: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Nemohu načíst \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Souhrn\"\r\n\tIDS_HV_MATCH             \"Shodné:\"\r\n\tIDS_HV_MISMATCH          \"Odlišné:\"\r\n\tIDS_HV_UNREADABLE        \"Nečitelné:\"\r\n\tIDS_HV_PENDING           \"Zbývající:\"\r\n\tIDS_HV_EXIT              \"Z&avři\"\r\n\tIDS_HV_COL_FILENAME      \"Jméno souboru\"\r\n\tIDS_HV_COL_SIZE          \"Velikost\"\r\n\tIDS_HV_COL_STATUS        \"Stav\"\r\n\tIDS_HV_COL_EXPECTED      \"Očekávané součty\"\r\n\tIDS_HV_COL_ACTUAL        \"Aktuální součty\"\r\n\tIDS_HV_STATUS_MATCH      \"SHODA\"\r\n\tIDS_HV_STATUS_MISMATCH   \"ODLIŠNOST\"\r\n\tIDS_HV_STATUS_UNREADABLE \"NEČITELNOST\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck nastavení\"\r\n\tIDS_OPT_CM               \"Integrace\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Zobraz v kontextovém menu\"\r\n\tIDS_OPT_CM_EXTENDED      \"Zobraz v rozšířeném &kontextovém menu\"\r\n\tIDS_OPT_CM_NEVER         \"&Nezobrazuj v kontextovém menu\"\r\n\tIDS_OPT_ENCODING         \"Znaková sada souboru kontrolního součtu\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Ulož v U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Ulož v &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Ulož v &ANSI\"\r\n\tIDS_OPT_CHK              \"Kontrolní součty okna výstupu\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Font okna výstupu\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Výběr...\"\r\n}\r\n\r\n// Deutsch\r\nSTRINGTABLE LANGUAGE LANG_GERMAN, SUBLANG_NEUTRAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"Checksum Datei\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pause\"\r\n\tIDS_HC_RESUME            \"&Weiter\"\r\n\tIDS_HC_STOP              \"&Stop\"\r\n\tIDS_HC_RESULT_FMT        \"%u von %u Datei\"\r\n\tIDS_HC_RESULTS_FMT       \"%u von %u Dateien\"\r\n\tIDS_HC_SAVE_ERROR        \"Schreibfehler für Prüfsummen-Datei.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Abbrechen\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Erstelle &Prüfsummen-Datei...\"\r\n\tIDS_HS_TITLE_FMT         \"Erstelle \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Prüfsummen\"\r\n\tIDS_HP_STATUSBOX         \"Fortschritt\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s erfolgreich gehashed\"\r\n\tIDS_HP_FIND              \"S&uchen\"\r\n\tIDS_HP_FIND_NOSTRING     \"Suchtext eingeben.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Text nicht gefunden.\"\r\n\tIDS_HP_SAVE              \"&Speichern...\"\r\n\tIDS_HP_OPTIONS           \"&Optionen\"\r\n\tIDS_HP_FILELABEL         \"   Datei: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Kann \"\"%s\"\" nicht öffnen\"\r\n\tIDS_HV_SUMMARY           \"Report\"\r\n\tIDS_HV_MATCH             \"Übereinstimmung:\"\r\n\tIDS_HV_MISMATCH          \"Abweichung:\"\r\n\tIDS_HV_UNREADABLE        \"Unlesbar:\"\r\n\tIDS_HV_PENDING           \"Warteschlange:\"\r\n\tIDS_HV_EXIT              \"&Beenden\"\r\n\tIDS_HV_COL_FILENAME      \"Dateiname\"\r\n\tIDS_HV_COL_SIZE          \"Größe\"\r\n\tIDS_HV_COL_STATUS        \"Status\"\r\n\tIDS_HV_COL_EXPECTED      \"Erwarteter Hash\"\r\n\tIDS_HV_COL_ACTUAL        \"Tatsächlicher Hash\"\r\n\tIDS_HV_STATUS_MATCH      \"Übereinstimmung\"\r\n\tIDS_HV_STATUS_MISMATCH   \"Abweichung\"\r\n\tIDS_HV_STATUS_UNREADABLE \"Unlesbar\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck Optionen\"\r\n\tIDS_OPT_CM               \"Kontext-Menü Optionen\"\r\n\tIDS_OPT_CM_ALWAYS        \"HashCheck im &Kontext-Menü\"\r\n\tIDS_OPT_CM_EXTENDED      \"HashCheck im er&weiterten Kontext-Menü\"\r\n\tIDS_OPT_CM_NEVER         \"HashCheck &nicht im Kontext-Menü\"\r\n\tIDS_OPT_ENCODING         \"Zeichencodierung\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Speichere in U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Speichere in &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Speichere in &ANSI\"\r\n\tIDS_OPT_CHK              \"Dialogfeld Prüfsummen\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Dialogfeld Dateieigenschaften\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Schriftart...\"\r\n}\r\n\r\n// Ελληνικά\r\nSTRINGTABLE LANGUAGE LANG_GREEK, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Αρχείο Checksum\"\r\n\r\n\tIDS_HC_PAUSE             \"&Παύση\"\r\n\tIDS_HC_RESUME            \"&Συνέχεια\"\r\n\tIDS_HC_STOP              \"Σταμάτ&ημα\"\r\n\tIDS_HC_RESULT_FMT        \"%u από %u αρχείο\"\r\n\tIDS_HC_RESULTS_FMT       \"%u από %u αρχεία\"\r\n\tIDS_HC_SAVE_ERROR        \"Αδύνατο το άνοιγμα του αρχείου checksum για εγγραφή.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Άκυρο\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Δημιουργία αρχείου chec&ksum...\"\r\n\tIDS_HS_TITLE_FMT         \"Δημιουργία του «%s»...\"\r\n\r\n\tIDS_HP_TITLE             \"Αρχεία Checksum\"\r\n\tIDS_HP_STATUSBOX         \"Πρόοδος\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s\"\r\n\tIDS_HP_FIND              \"Εύ&ρεση\"\r\n\tIDS_HP_FIND_NOSTRING     \"Εισάγετε κείμενο αναζήτησης.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Δεν βρέθηκε κείμενο.\"\r\n\tIDS_HP_SAVE              \"&Αποθήκευση\"\r\n\tIDS_HP_OPTIONS           \"&Επιλογές\"\r\n\tIDS_HP_FILELABEL         \"  Αρχείο: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Αδύνατο το φόρτωμα του «%s»\"\r\n\tIDS_HV_SUMMARY           \"Σύνοψη\"\r\n\tIDS_HV_MATCH             \"Ταιριάζουν:\"\r\n\tIDS_HV_MISMATCH          \"Δεν ταιριάζουν:\"\r\n\tIDS_HV_UNREADABLE        \"Μη Αναγνώσιμα:\"\r\n\tIDS_HV_PENDING           \"Εκρρεμούν:\"\r\n\tIDS_HV_EXIT              \"Έ&ξοδος\"\r\n\tIDS_HV_COL_FILENAME      \"Όνομα Αρχείου\"\r\n\tIDS_HV_COL_SIZE          \"Μέγεθος\"\r\n\tIDS_HV_COL_STATUS        \"Κατάσταση\"\r\n\tIDS_HV_COL_EXPECTED      \"Αναμενόμενο Checksum\"\r\n\tIDS_HV_COL_ACTUAL        \"Πραγματικό Checksum\"\r\n\tIDS_HV_STATUS_MATCH      \"ΤΑΙΡΙΑΖΕΙ\"\r\n\tIDS_HV_STATUS_MISMATCH   \"ΔΕΝ ΤΑΙΡΙΑΖΕΙ\"\r\n\tIDS_HV_STATUS_UNREADABLE \"ΜΗ ΑΝΑΓΝΩΣΙΜΟ\"\r\n\r\n\tIDS_OPT_TITLE            \"Επιλογές HashCheck\"\r\n\tIDS_OPT_CM               \"Επιλογές Μενού Συντόμευσης\"\r\n\tIDS_OPT_CM_ALWAYS        \"Εμφάνιση στο &μενού συντόμευσης\"\r\n\tIDS_OPT_CM_EXTENDED      \"Εμφάνιση στο «SHIFT+&Δεξί κλικ» μενού\"\r\n\tIDS_OPT_CM_NEVER         \"&Να μην εμφανίζεται στο μενού συντόμευσης\"\r\n\tIDS_OPT_ENCODING         \"Κωδικοποίηση χαρακτήρων του αρχείου checksum\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Αποθήκευση με χρήση U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Αποθήκευση με χρήση &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Αποθήκευση με χρήση &ANSI\"\r\n\tIDS_OPT_CHK              \"Αρχεία Checksum\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Γραμματοσειρά Παραθύρου Ιδιοτήτων\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Γραμματοσειρά...\"\r\n}\r\n\r\n// español\r\nSTRINGTABLE LANGUAGE LANG_SPANISH, SUBLANG_NEUTRAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"Archivo de checksum\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pausar\"\r\n\tIDS_HC_RESUME            \"&Reanudar\"\r\n\tIDS_HC_STOP              \"&Detener\"\r\n\tIDS_HC_RESULT_FMT        \"%u de %u archivo\"\r\n\tIDS_HC_RESULTS_FMT       \"%u de %u archivos\"\r\n\tIDS_HC_SAVE_ERROR        \"No se puede escribir el archivo de checksum.\"\r\n\tIDS_HC_OK                \"Aceptar\"\r\n\tIDS_HC_CANCEL            \"Cancelar\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Crear archivo chec&ksum...\"\r\n\tIDS_HS_TITLE_FMT         \"Creando \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Checksum\"\r\n\tIDS_HP_STATUSBOX         \"Progreso\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s procesado(s) correctamente\"\r\n\tIDS_HP_FIND              \"&Buscar\"\r\n\tIDS_HP_FIND_NOSTRING     \"Texto a buscar.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Texto no encontrado.\"\r\n\tIDS_HP_SAVE              \"&Guardar...\"\r\n\tIDS_HP_OPTIONS           \"&Opciones\"\r\n\tIDS_HP_FILELABEL         \"  Nombre: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"No se puede abrir \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Resumen\"\r\n\tIDS_HV_MATCH             \"Correcto:\"\r\n\tIDS_HV_MISMATCH          \"Incorrecto:\"\r\n\tIDS_HV_UNREADABLE        \"Ilegible:\"\r\n\tIDS_HV_PENDING           \"Pendiente:\"\r\n\tIDS_HV_EXIT              \"&Salir\"\r\n\tIDS_HV_COL_FILENAME      \"Nombre de archivo\"\r\n\tIDS_HV_COL_SIZE          \"Tamaño\"\r\n\tIDS_HV_COL_STATUS        \"Estado\"\r\n\tIDS_HV_COL_EXPECTED      \"Checksum esperado\"\r\n\tIDS_HV_COL_ACTUAL        \"Checksum obtenido\"\r\n\tIDS_HV_STATUS_MATCH      \"CORRECTO\"\r\n\tIDS_HV_STATUS_MISMATCH   \"INCORRECTO\"\r\n\tIDS_HV_STATUS_UNREADABLE \"ILEGIBLE\"\r\n\r\n\tIDS_OPT_TITLE            \"Opciones de HashCheck\"\r\n\tIDS_OPT_CM               \"Integración con Windows\"\r\n\tIDS_OPT_CM_ALWAYS        \"Añadir HashCheck al menú &contextual\"\r\n\tIDS_OPT_CM_EXTENDED      \"Añadir HashCheck al menú contextual &extendido\"\r\n\tIDS_OPT_CM_NEVER         \"&No añadir HashCheck al menú contextual\"\r\n\tIDS_OPT_ENCODING         \"Codificación del archivo de checksum\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Guardar como U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Guardar como &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Guardar como &ANSI (idioma predeterminado)\"\r\n\tIDS_OPT_CHK              \"Checksum\"\r\n\tIDS_OPT_CHK_ERROR        \"Por favor seleccione al menos un checksum\"\r\n\tIDS_OPT_FONT             \"Fuente\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Cambiar...\"\r\n}\r\n\r\n// français\r\nSTRINGTABLE LANGUAGE LANG_FRENCH, SUBLANG_NEUTRAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"Fichier de vérification\"\r\n\r\n\tIDS_HC_PAUSE             \"&Suspendre\"\r\n\tIDS_HC_RESUME            \"&Reprendre\"\r\n\tIDS_HC_STOP              \"&Arrêter\"\r\n\tIDS_HC_RESULT_FMT        \"%u / %u fichier\"\r\n\tIDS_HC_RESULTS_FMT       \"%u / %u fichiers\"\r\n\tIDS_HC_SAVE_ERROR        \"Impossible d'enregistrer le fichier de vérification.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Annuler\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Créer un fichier de vérification...\"\r\n\tIDS_HS_TITLE_FMT         \"Création de \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Hachages\"\r\n\tIDS_HP_STATUSBOX         \"Progression\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s haché avec succès\"\r\n\tIDS_HP_FIND              \"&Rechercher\"\r\n\tIDS_HP_FIND_NOSTRING     \"Entrer le texte à rechercher ici.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Texte non trouvé.\"\r\n\tIDS_HP_SAVE              \"&Enregistrer\"\r\n\tIDS_HP_OPTIONS           \"&Options\"\r\n\tIDS_HP_FILELABEL         \"     Nom: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Impossible de charger \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Résumé\"\r\n\tIDS_HV_MATCH             \"Correct:\"\r\n\tIDS_HV_MISMATCH          \"Incorrect:\"\r\n\tIDS_HV_UNREADABLE        \"Illisible:\"\r\n\tIDS_HV_PENDING           \"Restant:\"\r\n\tIDS_HV_EXIT              \"&Quitter\"\r\n\tIDS_HV_COL_FILENAME      \"Nom de fichier\"\r\n\tIDS_HV_COL_SIZE          \"Taille\"\r\n\tIDS_HV_COL_STATUS        \"État\"\r\n\tIDS_HV_COL_EXPECTED      \"Hachage attendu\"\r\n\tIDS_HV_COL_ACTUAL        \"Hachage présent\"\r\n\tIDS_HV_STATUS_MATCH      \"CORRECT\"\r\n\tIDS_HV_STATUS_MISMATCH   \"INCORRECT\"\r\n\tIDS_HV_STATUS_UNREADABLE \"ILLISIBLE\"\r\n\r\n\tIDS_OPT_TITLE            \"Options de HashCheck\"\r\n\tIDS_OPT_CM               \"Intégration à l'Explorateur Windows\"\r\n\tIDS_OPT_CM_ALWAYS        \"Intégrer au menu cont&extuel\"\r\n\tIDS_OPT_CM_EXTENDED      \"Intégrer au menu conte&xtuel étendu\"\r\n\tIDS_OPT_CM_NEVER         \"&Ne pas intégrer au menu contextuel\"\r\n\tIDS_OPT_ENCODING         \"Codage des caractères\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Enregistrer avec U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Enregistrer avec &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Enregistrer avec &ANSI\"\r\n\tIDS_OPT_CHK              \"Hachages de l'onglet propriétés\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Police de l'onglet propriétés\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Modifier...\"\r\n}\r\n\r\n// italiano\r\nSTRINGTABLE LANGUAGE LANG_ITALIAN, SUBLANG_NEUTRAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"File di checksum\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pausa\"\r\n\tIDS_HC_RESUME            \"&Riprendi\"\r\n\tIDS_HC_STOP              \"&Ferma\"\r\n\tIDS_HC_RESULT_FMT        \"%u di %u file\"\r\n\tIDS_HC_RESULTS_FMT       \"%u di %u file\"\r\n\tIDS_HC_SAVE_ERROR        \"Impossibile aprire il file di checksum per la scrittura.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Annulla\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Crea file di chec&ksum...\"\r\n\tIDS_HS_TITLE_FMT         \"Creazione di \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Checksum\"\r\n\tIDS_HP_STATUSBOX         \"Progresso\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"Hash %s completato\"\r\n\tIDS_HP_FIND              \"&Trova\"\r\n\tIDS_HP_FIND_NOSTRING     \"Inserisci testo da ricercare.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Testo non trovato.\"\r\n\tIDS_HP_SAVE              \"&Salva...\"\r\n\tIDS_HP_OPTIONS           \"&Opzioni\"\r\n\tIDS_HP_FILELABEL         \"    File: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Impossibile caricare \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Sommario\"\r\n\tIDS_HV_MATCH             \"Completo:\"\r\n\tIDS_HV_MISMATCH          \"Danneggiato:\"\r\n\tIDS_HV_UNREADABLE        \"Mancante:\"\r\n\tIDS_HV_PENDING           \"Rimasti:\"\r\n\tIDS_HV_EXIT              \"E&sci\"\r\n\tIDS_HV_COL_FILENAME      \"Nome File\"\r\n\tIDS_HV_COL_SIZE          \"Dimensione\"\r\n\tIDS_HV_COL_STATUS        \"Stato\"\r\n\tIDS_HV_COL_EXPECTED      \"Checksum Previsto\"\r\n\tIDS_HV_COL_ACTUAL        \"Checksum Attuale\"\r\n\tIDS_HV_STATUS_MATCH      \"COMPLETO\"\r\n\tIDS_HV_STATUS_MISMATCH   \"DANNEGGIATO\"\r\n\tIDS_HV_STATUS_UNREADABLE \"MANCANTE\"\r\n\r\n\tIDS_OPT_TITLE            \"Opzioni HashCheck\"\r\n\tIDS_OPT_CM               \"Integrazione nella Shell\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Mostra HashCheck nel menù\"\r\n\tIDS_OPT_CM_EXTENDED      \"Mostra HashCheck nel menù &esteso\"\r\n\tIDS_OPT_CM_NEVER         \"&Non mostrare mai HashCheck nel menù\"\r\n\tIDS_OPT_ENCODING         \"Codifica dei caratteri del file di checksum\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Salva usando U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Salva usando &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Salva usando &ANSI\"\r\n\tIDS_OPT_CHK              \"Checksum\"\r\n\tIDS_OPT_CHK_ERROR        \"Seleziona almeno un checksum\"\r\n\tIDS_OPT_FONT             \"Tipo di carattere\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Cambia...\"\r\n}\r\n\r\n// 日本語\r\nSTRINGTABLE LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"チェックサムファイル\"\r\n\r\n\tIDS_HC_PAUSE             \"一時停止(&P)\"\r\n\tIDS_HC_RESUME            \"続行(&R)\"\r\n\tIDS_HC_STOP              \"停止(&S)\"\r\n\tIDS_HC_RESULT_FMT        \"!%u 個中の %u 個\"\r\n\tIDS_HC_RESULTS_FMT       \"!%u 個中の %u 個\"\r\n\tIDS_HC_SAVE_ERROR        \"チェックサムファイルの書き込みに失敗します。\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"キャンセル\"\r\n\r\n\tIDS_HS_MENUTEXT          \"チェックサムファイルの作成(&K)...\"\r\n\tIDS_HS_TITLE_FMT         \"\"\"%s\"\" を作成します...\"\r\n\r\n\tIDS_HP_TITLE             \"ハッシュ\"\r\n\tIDS_HP_STATUSBOX         \"ステータス\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%sファイルをハッシュに完了しました\"\r\n\tIDS_HP_FIND              \"検索(&F)\"\r\n\tIDS_HP_FIND_NOSTRING     \"検索するキーワードを入力してください。\"\r\n\tIDS_HP_FIND_NOTFOUND     \"指定したキーワードは見つかりません。\"\r\n\tIDS_HP_SAVE              \"保存(&S)...\"\r\n\tIDS_HP_OPTIONS           \"ｵﾌﾟｼｮﾝ(&O)\"\r\n\tIDS_HP_FILELABEL         \"    File: \"  // alternatively, \"  ﾌｧｲﾙ: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"\"\"%s\"\" の読み込みに失敗します\"\r\n\tIDS_HV_SUMMARY           \"概略\"\r\n\tIDS_HV_MATCH             \"一致:\"\r\n\tIDS_HV_MISMATCH          \"不一致:\"\r\n\tIDS_HV_UNREADABLE        \"読み込み失敗:\"\r\n\tIDS_HV_PENDING           \"未決:\"\r\n\tIDS_HV_EXIT              \"終了(&X)\"\r\n\tIDS_HV_COL_FILENAME      \"ファイス\"\r\n\tIDS_HV_COL_SIZE          \"サイズ\"\r\n\tIDS_HV_COL_STATUS        \"情報\"\r\n\tIDS_HV_COL_EXPECTED      \"予期のハッシュ\"\r\n\tIDS_HV_COL_ACTUAL        \"現在のハッシュ\"\r\n\tIDS_HV_STATUS_MATCH      \"合 う\"\r\n\tIDS_HV_STATUS_MISMATCH   \"違 う\"\r\n\tIDS_HV_STATUS_UNREADABLE \"読込失敗\"\r\n\r\n\tIDS_OPT_TITLE            \"ハッシュチェックオプション\"\r\n\tIDS_OPT_CM               \"コンテキストメニューオプション\"\r\n\tIDS_OPT_CM_ALWAYS        \"常にハッシュチェックを表示する(&S)\"\r\n\tIDS_OPT_CM_EXTENDED      \"拡張メニューでのみ表示する(&E)\"\r\n\tIDS_OPT_CM_NEVER         \"ハッシュチェックを表示しない(&N)\"\r\n\tIDS_OPT_ENCODING         \"チェックサムファイルのエンコード\"\r\n\tIDS_OPT_ENCODING_UTF8    \"UTF-8 で保存する(&T)\"\r\n\tIDS_OPT_ENCODING_UTF16   \"UTF-16LE で保存する(&U)\"\r\n\tIDS_OPT_ENCODING_ANSI    \"ANSI で保存する(&A)\"\r\n\tIDS_OPT_CHK              \"ハッシュ\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"プロパティシートフォント\"\r\n\tIDS_OPT_FONT_CHANGE      \"ﾌｫﾝﾄの変更(&C)...\"\r\n}\r\n\r\n// 한국어\r\nSTRINGTABLE LANGUAGE LANG_KOREAN, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"체크섬 파일\"\r\n\r\n\tIDS_HC_PAUSE             \"일시 중지(&P)\"\r\n\tIDS_HC_RESUME            \"다시 시작(&R)\"\r\n\tIDS_HC_STOP              \"중지(&S)\"\r\n\tIDS_HC_RESULT_FMT        \"%u / %u 파일\"\r\n\tIDS_HC_RESULTS_FMT       \"%u / %u 파일\"\r\n\tIDS_HC_SAVE_ERROR        \"체크섬 파일을 열 수 없습니다.\"\r\n\tIDS_HC_OK                \"확인\"\r\n\tIDS_HC_CANCEL            \"취소\"\r\n\r\n\tIDS_HS_MENUTEXT          \"체크섬 파일 만들기(&K)...\"\r\n\tIDS_HS_TITLE_FMT         \"\"\"%s\"\" 생성중...\"\r\n\r\n\tIDS_HP_TITLE             \"체크섬\"\r\n\tIDS_HP_STATUSBOX         \"진행\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s 해시 성공\"\r\n\tIDS_HP_FIND              \"찾기(&F)\"\r\n\tIDS_HP_FIND_NOSTRING     \"검색어 입력.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"찾지 못했습니다.\"\r\n\tIDS_HP_SAVE              \"저장(&S)...\"\r\n\tIDS_HP_OPTIONS           \"옵션(&O)\"\r\n\tIDS_HP_FILELABEL         \"    File: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"\"\"%s\"\" 불러올 수 없음\"\r\n\tIDS_HV_SUMMARY           \"요약\"\r\n\tIDS_HV_MATCH             \"일치:\"\r\n\tIDS_HV_MISMATCH          \"불일치:\"\r\n\tIDS_HV_UNREADABLE        \"판독 불가:\"\r\n\tIDS_HV_PENDING           \"미판독:\"\r\n\tIDS_HV_EXIT              \"닫기(&X)\"\r\n\tIDS_HV_COL_FILENAME      \"파일명\"\r\n\tIDS_HV_COL_SIZE          \"크기\"\r\n\tIDS_HV_COL_STATUS        \"상태\"\r\n\tIDS_HV_COL_EXPECTED      \"예상 체크섬\"\r\n\tIDS_HV_COL_ACTUAL        \"실제 체크섬\"\r\n\tIDS_HV_STATUS_MATCH      \"일치\"\r\n\tIDS_HV_STATUS_MISMATCH   \"불일치\"\r\n\tIDS_HV_STATUS_UNREADABLE \"판독 불가\"\r\n\r\n\tIDS_OPT_TITLE            \"해시 검사 옵션\"\r\n\tIDS_OPT_CM               \"셸 통합\"\r\n\tIDS_OPT_CM_ALWAYS        \"바로가기 메뉴에 해시검사 표시(&S)\"\r\n\tIDS_OPT_CM_EXTENDED      \"바로가기 확장 메뉴에서 해시검사 표시(&E)\"\r\n\tIDS_OPT_CM_NEVER         \"바로가기 메뉴에 해시검사 표시 안함(&N)\"\r\n\tIDS_OPT_ENCODING         \"체크섬 파일의 문자 인코딩\"\r\n\tIDS_OPT_ENCODING_UTF8    \"U&TF-8로 저장\"\r\n\tIDS_OPT_ENCODING_UTF16   \"&UTF-16LE로 저장\"\r\n\tIDS_OPT_ENCODING_ANSI    \"&ANSI로 저장\"\r\n\tIDS_OPT_CHK              \"체크섬\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"속성 시트 글꼴\"\r\n\tIDS_OPT_FONT_CHANGE      \"글꼴 변경(&C)...\"\r\n}\r\n\r\n// Nederlands\r\nSTRINGTABLE LANGUAGE LANG_DUTCH, SUBLANG_NEUTRAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"Controlegetalbestand\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pauzeren\"\r\n\tIDS_HC_RESUME            \"&Doorgaan\"\r\n\tIDS_HC_STOP              \"&Stop\"\r\n\tIDS_HC_RESULT_FMT        \"%u van %u bestand\"\r\n\tIDS_HC_RESULTS_FMT       \"%u van %u bestanden\"\r\n\tIDS_HC_SAVE_ERROR        \"Kan het controlegetalbestand niet openen om naar te schrijven.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Annuleren\"\r\n\r\n\tIDS_HS_MENUTEXT          \"&Creëer controlegetalbestand...\"\r\n\tIDS_HS_TITLE_FMT         \"Voortgang \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Controlegetallen\"\r\n\tIDS_HP_STATUSBOX         \"Voortgang\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s succesvol verwerkt\"\r\n\tIDS_HP_FIND              \"&Zoek\"\r\n\tIDS_HP_FIND_NOSTRING     \"Zoektekst invoeren.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Zoektekst niet gevonden.\"\r\n\tIDS_HP_SAVE              \"Op&slaan...\"\r\n\tIDS_HP_OPTIONS           \"&Opties\"\r\n\tIDS_HP_FILELABEL         \"    Naam: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Kan \"\"%s\"\" niet openen\"\r\n\tIDS_HV_SUMMARY           \"Samenvatting\"\r\n\tIDS_HV_MATCH             \"Gelijk:\"\r\n\tIDS_HV_MISMATCH          \"Ongelijk:\"\r\n\tIDS_HV_UNREADABLE        \"Onleesbaar:\"\r\n\tIDS_HV_PENDING           \"Resterend:\"\r\n\tIDS_HV_EXIT              \"&Afsluiten\"\r\n\tIDS_HV_COL_FILENAME      \"Naam\"\r\n\tIDS_HV_COL_SIZE          \"Grootte\"\r\n\tIDS_HV_COL_STATUS        \"Status\"\r\n\tIDS_HV_COL_EXPECTED      \"Verwacht\"\r\n\tIDS_HV_COL_ACTUAL        \"Werkelijk\"\r\n\tIDS_HV_STATUS_MATCH      \"GELIJK\"\r\n\tIDS_HV_STATUS_MISMATCH   \"ONGELIJK\"\r\n\tIDS_HV_STATUS_UNREADABLE \"ONLEESBAAR\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck opties\"\r\n\tIDS_OPT_CM               \"Snelmenu integratie\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Opnemen in het snelmenu\"\r\n\tIDS_OPT_CM_EXTENDED      \"Opnemen in het &uitgebreide snelmenu\"\r\n\tIDS_OPT_CM_NEVER         \"&Niet opnemen in het snelmenu\"\r\n\tIDS_OPT_ENCODING         \"Tekencodering controlegetalbestand\"\r\n\tIDS_OPT_ENCODING_UTF8    \"U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"&UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"&ANSI\"\r\n\tIDS_OPT_CHK              \"Controlegetallen eigenschappenblad\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Lettertype eigenschappenblad\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Wijzig...\"\r\n}\r\n\r\n// polski\r\nSTRINGTABLE LANGUAGE LANG_POLISH, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Plik sumy kontrolnej\"\r\n\r\n\tIDS_HC_PAUSE             \"&Wstrzymaj\"\r\n\tIDS_HC_RESUME            \"&Wznów\"\r\n\tIDS_HC_STOP              \"&Zatrzymaj\"\r\n\tIDS_HC_RESULT_FMT        \"%u z %u pliku\"\r\n\tIDS_HC_RESULTS_FMT       \"%u z %u plików\"\r\n\tIDS_HC_SAVE_ERROR        \"Nie można otworzyć pliku sumy kontrolnej do zapisu.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Anuluj\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Utwórz plik sumy &kontrolnej...\"\r\n\tIDS_HS_TITLE_FMT         \"Tworzę \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Sumy kontrolne\"\r\n\tIDS_HP_STATUSBOX         \"Postęp\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"Udane haszowanie %s\"\r\n\tIDS_HP_FIND              \"Zna&jdź\"\r\n\tIDS_HP_FIND_NOSTRING     \"Wprowadź szukany tekst.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Tekst nieodnaleziony.\"\r\n\tIDS_HP_SAVE              \"&Zapisz...\"\r\n\tIDS_HP_OPTIONS           \"&Opcje\"\r\n\tIDS_HP_FILELABEL         \"    Plik: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Nie mogę wczytać \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Sumowanie\"\r\n\tIDS_HV_MATCH             \"Dopasowane:\"\r\n\tIDS_HV_MISMATCH          \"Niezgodne:\"\r\n\tIDS_HV_UNREADABLE        \"Nieczytelne:\"\r\n\tIDS_HV_PENDING           \"Pozostało:\"\r\n\tIDS_HV_EXIT              \"Z&amknij\"\r\n\tIDS_HV_COL_FILENAME      \"Nazwa pliku\"\r\n\tIDS_HV_COL_SIZE          \"Rozmiar\"\r\n\tIDS_HV_COL_STATUS        \"Status\"\r\n\tIDS_HV_COL_EXPECTED      \"Spodziewana suma kontrolna\"\r\n\tIDS_HV_COL_ACTUAL        \"Aktualna suma kontrolna\"\r\n\tIDS_HV_STATUS_MATCH      \"ZGODNY\"\r\n\tIDS_HV_STATUS_MISMATCH   \"NIEZGODNY\"\r\n\tIDS_HV_STATUS_UNREADABLE \"NIECZYTELNY\"\r\n\r\n\tIDS_OPT_TITLE            \"Opcje HashCheck\"\r\n\tIDS_OPT_CM               \"Integracja z powłoką\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Pokaż HashCheck w menu skrótów\"\r\n\tIDS_OPT_CM_EXTENDED      \"Pokaż HashCheck w rozsz&erzonym menu skrótów\"\r\n\tIDS_OPT_CM_NEVER         \"&Nie pokazuj HashCheck w menu skrótów\"\r\n\tIDS_OPT_ENCODING         \"Kodowanie znaków w pliku sumy kontrolnej\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Zapisz jako U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Zapisz jako &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Zapisz jako &ANSI\"\r\n\tIDS_OPT_CHK              \"Sumy kontrolne\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Styl czcionki karty\"\r\n\tIDS_OPT_FONT_CHANGE      \"Zmień &czcionkę...\"\r\n}\r\n\r\n// Português (Brasil)\r\nSTRINGTABLE LANGUAGE LANG_PORTUGUESE, SUBLANG_PORTUGUESE_BRAZILIAN\r\n{\r\n\tIDS_FILETYPE_DESC        \"Arquivo de Checksum\"\r\n\r\n\tIDS_HC_PAUSE             \"P&ausar\"\r\n\tIDS_HC_RESUME            \"&Continuar\"\r\n\tIDS_HC_STOP              \"&Parar\"\r\n\tIDS_HC_RESULT_FMT        \"Arquivo %u de %u\"\r\n\tIDS_HC_RESULTS_FMT       \"%u de %u arquivos\"\r\n\tIDS_HC_SAVE_ERROR        \"Impossível abrir o arquivo de checksum para escrita.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Cancelar\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Criar Arquivo de Chec&ksum ...\"\r\n\tIDS_HS_TITLE_FMT         \"Criando \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Identificação digital\"\r\n\tIDS_HP_STATUSBOX         \"Progresso\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s - Identificação bem sucedida\"\r\n\tIDS_HP_FIND              \"&Procurar\"\r\n\tIDS_HP_FIND_NOSTRING     \"Entrar com o texto para procura.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Texto náo encontrado.\"\r\n\tIDS_HP_SAVE              \"&Salvar...\"\r\n\tIDS_HP_OPTIONS           \"&Opções\"\r\n\tIDS_HP_FILELABEL         \"    Nome: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Impossível carregar \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Sumário\"\r\n\tIDS_HV_MATCH             \"Iguais:\"\r\n\tIDS_HV_MISMATCH          \"Diferentes:\"\r\n\tIDS_HV_UNREADABLE        \"Ilegível:\"\r\n\tIDS_HV_PENDING           \"Pendente:\"\r\n\tIDS_HV_EXIT              \"&Sair\"\r\n\tIDS_HV_COL_FILENAME      \"Nome do Arquivo\"\r\n\tIDS_HV_COL_SIZE          \"Tamanho\"\r\n\tIDS_HV_COL_STATUS        \"Status\"\r\n\tIDS_HV_COL_EXPECTED      \"Checksum Esperado\"\r\n\tIDS_HV_COL_ACTUAL        \"Checksum Atual\"\r\n\tIDS_HV_STATUS_MATCH      \"IGUAIS\"\r\n\tIDS_HV_STATUS_MISMATCH   \"DIFERENTES\"\r\n\tIDS_HV_STATUS_UNREADABLE \"ILEGÍVEL\"\r\n\r\n\tIDS_OPT_TITLE            \"Opções do HashCheck\"\r\n\tIDS_OPT_CM               \"Opções do menu de contexto\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Exibir HashCheck no menu de contexto\"\r\n\tIDS_OPT_CM_EXTENDED      \"Exibir HashCheck no menu de contexto e&xtenso\"\r\n\tIDS_OPT_CM_NEVER         \"&Nunca exibir HashCheck no menu de contexto\"\r\n\tIDS_OPT_ENCODING         \"Gerando o arquivo de checksum\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Salvar - padrão U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Salvar - padrão &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Salvar - código de página padrão &ANSI\"\r\n\tIDS_OPT_CHK              \"Identificação digital\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Propriedades da Fonte\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Mudar...\"\r\n}\r\n\r\n// português (Portugal)\r\nSTRINGTABLE LANGUAGE LANG_PORTUGUESE, SUBLANG_PORTUGUESE\r\n{\r\n\tIDS_FILETYPE_DESC        \"Ficheiro Checksum\"\r\n\r\n\tIDS_HC_PAUSE             \"&Interromper\"\r\n\tIDS_HC_RESUME            \"&Resumir\"\r\n\tIDS_HC_STOP              \"&Parar\"\r\n\tIDS_HC_RESULT_FMT        \"%u de %u ficheiro\"\r\n\tIDS_HC_RESULTS_FMT       \"%u de %u ficheiros\"\r\n\tIDS_HC_SAVE_ERROR        \"Impossível abrir ficheiro de checksum para escrita.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Cancelar\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Criar ficheiro de Chec&ksum...\"\r\n\tIDS_HS_TITLE_FMT         \"Criando \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Checksums\"\r\n\tIDS_HP_STATUSBOX         \"Progresso\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"Hash de %s criada com sucesso\"\r\n\tIDS_HP_FIND              \"&Procurar\"\r\n\tIDS_HP_FIND_NOSTRING     \"Introduzir texto a procurar.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Texto não encontrado.\"\r\n\tIDS_HP_SAVE              \"&Guardar...\"\r\n\tIDS_HP_OPTIONS           \"&Opções\"\r\n\tIDS_HP_FILELABEL         \"    Nome: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Impossível carregar \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Summário\"\r\n\tIDS_HV_MATCH             \"Igualável:\"\r\n\tIDS_HV_MISMATCH          \"Inagualável:\"\r\n\tIDS_HV_UNREADABLE        \"Ilegível:\"\r\n\tIDS_HV_PENDING           \"Restantes:\"\r\n\tIDS_HV_EXIT              \"&Sair\"\r\n\tIDS_HV_COL_FILENAME      \"Nome do ficheiro\"\r\n\tIDS_HV_COL_SIZE          \"Tamanho\"\r\n\tIDS_HV_COL_STATUS        \"Estado\"\r\n\tIDS_HV_COL_EXPECTED      \"Checksum esperada\"\r\n\tIDS_HV_COL_ACTUAL        \"Checksum real\"\r\n\tIDS_HV_STATUS_MATCH      \"IGUALÁVEL\"\r\n\tIDS_HV_STATUS_MISMATCH   \"INAGUALÁVEL\"\r\n\tIDS_HV_STATUS_UNREADABLE \"ILEGÍVEL\"\r\n\r\n\tIDS_OPT_TITLE            \"Opções do HashCheck\"\r\n\tIDS_OPT_CM               \"Integração na Shell\"\r\n\tIDS_OPT_CM_ALWAYS        \"M&ostrar HashCheck no menu de atalho\"\r\n\tIDS_OPT_CM_EXTENDED      \"Mostrar HashCheck no menu de atalho &extendido\"\r\n\tIDS_OPT_CM_NEVER         \"&Nunca mostrar HashCheck no menu de atalho\"\r\n\tIDS_OPT_ENCODING         \"Codificação de caracteres dos ficheiros Checksum\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Guardar usando U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Guardar usando &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Guardar usando &ANSI\"\r\n\tIDS_OPT_CHK              \"Checksums da folha de propriedades\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Tipo de letra da folha de propriedades\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Mudar...\"\r\n}\r\n\r\n// română\r\nSTRINGTABLE LANGUAGE LANG_ROMANIAN, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Fişier sumă de control\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pauză\"\r\n\tIDS_HC_RESUME            \"&Continuă\"\r\n\tIDS_HC_STOP              \"&Opreşte\"\r\n\tIDS_HC_RESULT_FMT        \"%u din %u fişier\"\r\n\tIDS_HC_RESULTS_FMT       \"%u din %u fişiere\"\r\n\tIDS_HC_SAVE_ERROR        \"Nu pot deschide pentru scriere fişierul cu sume de control.\"\r\n\tIDS_HC_OK                \"Bine\"\r\n\tIDS_HC_CANCEL            \"Renunţă\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Crează fişier cu su&me de control...\"\r\n\tIDS_HS_TITLE_FMT         \"Creez \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Sume de control\"\r\n\tIDS_HP_STATUSBOX         \"Progres\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s sumă de control calculată cu succes\"\r\n\tIDS_HP_FIND              \"&Caută\"\r\n\tIDS_HP_FIND_NOSTRING     \"Introduceţi text de căutat.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Text negăsit.\"\r\n\tIDS_HP_SAVE              \"&Salvare...\"\r\n\tIDS_HP_OPTIONS           \"Optiu&ni\"\r\n\tIDS_HP_FILELABEL         \"  Fişier: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Nu pot încărca \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Sumar\"\r\n\tIDS_HV_MATCH             \"Potrivit:\"\r\n\tIDS_HV_MISMATCH          \"Diferit:\"\r\n\tIDS_HV_UNREADABLE        \"Necitit:\"\r\n\tIDS_HV_PENDING           \"Rămas(e):\"\r\n\tIDS_HV_EXIT              \"&Ieşire\"\r\n\tIDS_HV_COL_FILENAME      \"Nume fişier\"\r\n\tIDS_HV_COL_SIZE          \"Mărime\"\r\n\tIDS_HV_COL_STATUS        \"Stare\"\r\n\tIDS_HV_COL_EXPECTED      \"Suma de control aşteptată\"\r\n\tIDS_HV_COL_ACTUAL        \"Suma de control actuală\"\r\n\tIDS_HV_STATUS_MATCH      \"POTRIVIT\"\r\n\tIDS_HV_STATUS_MISMATCH   \"DIFERIT\"\r\n\tIDS_HV_STATUS_UNREADABLE \"NECITIT\"\r\n\r\n\tIDS_OPT_TITLE            \"Opţiuni HashCheck\"\r\n\tIDS_OPT_CM               \"Integrare interfaţă\"\r\n\tIDS_OPT_CM_ALWAYS        \"Arată HashCheck în meniul &scurtături\"\r\n\tIDS_OPT_CM_EXTENDED      \"Arată HashCheck în meniul scurtături &extins\"\r\n\tIDS_OPT_CM_NEVER         \"&Nu arată niciodata HashCheck în meniul scurtături\"\r\n\tIDS_OPT_ENCODING         \"Codare caracter pentru fişierul cu sume de control\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Salvează folosind U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Salvează folosind &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Salvează folosind &ANSI\"\r\n\tIDS_OPT_CHK              \"Proprietăţi sume de control\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Proprietăţi font\"\r\n\tIDS_OPT_FONT_CHANGE      \"Schimbă &Font...\"\r\n}\r\n\r\n// русский\r\nSTRINGTABLE LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Файл контрольной суммы\"\r\n\r\n\tIDS_HC_PAUSE             \"&Пауза\"\r\n\tIDS_HC_RESUME            \"Про&должить\"\r\n\tIDS_HC_STOP              \"&Стоп\"\r\n\tIDS_HC_RESULT_FMT        \"%u из %u файла\"\r\n\tIDS_HC_RESULTS_FMT       \"%u из %u файлов\"\r\n\tIDS_HC_SAVE_ERROR        \"Невозможно открыть для записи файл контрольной суммы.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Отмена\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Создать &файл контрольной суммы...\"\r\n\tIDS_HS_TITLE_FMT         \"Создание \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Контрольные суммы\"\r\n\tIDS_HP_STATUSBOX         \"Выполнение\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s прохешировано\"\r\n\tIDS_HP_FIND              \"&Найти\"\r\n\tIDS_HP_FIND_NOSTRING     \"Введите текст для поиска.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Текст не найден.\"\r\n\tIDS_HP_SAVE              \"&Сохранить...\"\r\n\tIDS_HP_OPTIONS           \"&Опции\"\r\n\tIDS_HP_FILELABEL         \"    Файл: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Невозможно открыть \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Результаты\"\r\n\tIDS_HV_MATCH             \"Совпали:\"\r\n\tIDS_HV_MISMATCH          \"Не совпали:\"\r\n\tIDS_HV_UNREADABLE        \"Не прочтены:\"\r\n\tIDS_HV_PENDING           \"Осталось:\"\r\n\tIDS_HV_EXIT              \"&Выход\"\r\n\tIDS_HV_COL_FILENAME      \"Имя файла\"\r\n\tIDS_HV_COL_SIZE          \"Размер\"\r\n\tIDS_HV_COL_STATUS        \"Статус\"\r\n\tIDS_HV_COL_EXPECTED      \"Ожидаемая контрольная сумма\"\r\n\tIDS_HV_COL_ACTUAL        \"Фактическая контрольная сумма\"\r\n\tIDS_HV_STATUS_MATCH      \"СОВПАЛ\"\r\n\tIDS_HV_STATUS_MISMATCH   \"НЕ СОВПАЛ\"\r\n\tIDS_HV_STATUS_UNREADABLE \"НЕ ПРОЧТЕН\"\r\n\r\n\tIDS_OPT_TITLE            \"Опции HashCheck\"\r\n\tIDS_OPT_CM               \"Интеграция в оболочку\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Отображать в меню ярлыков\"\r\n\tIDS_OPT_CM_EXTENDED      \"Отображать в &расширенном меню ярлыков\"\r\n\tIDS_OPT_CM_NEVER         \"&Не отображать в меню ярлыков\"\r\n\tIDS_OPT_ENCODING         \"Кодировка символов в файле контрольной суммы\"\r\n\tIDS_OPT_ENCODING_UTF8    \"&Сохранить как UTF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Сохрани&ть как UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Сохр&анить как ANSI\"\r\n\tIDS_OPT_CHK              \"Контрольные суммы в окне свойств\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Шрифт в окне свойств\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Изменить...\"\r\n}\r\n\r\n// svenska\r\nSTRINGTABLE LANGUAGE LANG_SWEDISH, SUBLANG_NEUTRAL\r\n{\r\n\tIDS_FILETYPE_DESC        \"Checksum-fil\"\r\n\r\n\tIDS_HC_PAUSE             \"&Pausa\"\r\n\tIDS_HC_RESUME            \"Å&teruppta\"\r\n\tIDS_HC_STOP              \"&Stopp\"\r\n\tIDS_HC_RESULT_FMT        \"%u av %u fil\"\r\n\tIDS_HC_RESULTS_FMT       \"%u av %u filer\"\r\n\tIDS_HC_SAVE_ERROR        \"Kan inte skriva till checksum-fil.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Avbryt\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Skapa chec&ksum-fil...\"\r\n\tIDS_HS_TITLE_FMT         \"Skapar \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Checksums\"\r\n\tIDS_HP_STATUSBOX         \"Utfört\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s framgångsrikt hashade\"\r\n\tIDS_HP_FIND              \"S&ök\"\r\n\tIDS_HP_FIND_NOSTRING     \"Skriv in sökord.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Sökord ej funnet.\"\r\n\tIDS_HP_SAVE              \"&Spara...\"\r\n\tIDS_HP_OPTIONS           \"&Inställningar\"\r\n\tIDS_HP_FILELABEL         \"     Fil: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Kan ej ladda \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Summering\"\r\n\tIDS_HV_MATCH             \"Match:\"\r\n\tIDS_HV_MISMATCH          \"Ej match:\"\r\n\tIDS_HV_UNREADABLE        \"Oläsbara:\"\r\n\tIDS_HV_PENDING           \"Remaining:\"\r\n\tIDS_HV_EXIT              \"A&vsluta\"\r\n\tIDS_HV_COL_FILENAME      \"Filnamn\"\r\n\tIDS_HV_COL_SIZE          \"Storlek\"\r\n\tIDS_HV_COL_STATUS        \"Status\"\r\n\tIDS_HV_COL_EXPECTED      \"Förväntad Checksum\"\r\n\tIDS_HV_COL_ACTUAL        \"Faktisk Checksum\"\r\n\tIDS_HV_STATUS_MATCH      \"MATCH\"\r\n\tIDS_HV_STATUS_MISMATCH   \"EJ MATCH\"\r\n\tIDS_HV_STATUS_UNREADABLE \"OLÄSBARA\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck Inställningar\"\r\n\tIDS_OPT_CM               \"Integration i operativsystemet\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Visa HashCheck i genvägsmenyn\"\r\n\tIDS_OPT_CM_EXTENDED      \"Visa HashCheck i den utökad&e genvägsmenyn\"\r\n\tIDS_OPT_CM_NEVER         \"Visa aldrig HashCheck i ge&nvägsmenyn\"\r\n\tIDS_OPT_ENCODING         \"Checksum-filens tecken tabell\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Spara med U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Spara med &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Spara med &ANSI\"\r\n\tIDS_OPT_CHK              \"Egenskapsidans checksums\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Egenskapsidans typsnitt\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Ändra...\"\r\n}\r\n\r\n// Türkçe\r\nSTRINGTABLE LANGUAGE LANG_TURKISH, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Checksum Dosyası\"\r\n\r\n\tIDS_HC_PAUSE             \"D&uraklat\"\r\n\tIDS_HC_RESUME            \"D&evam ettir\"\r\n\tIDS_HC_STOP              \"&Durdur\"\r\n\tIDS_HC_RESULT_FMT        \"%u / %u dosya\"\r\n\tIDS_HC_RESULTS_FMT       \"%u / %u dosya\"\r\n\tIDS_HC_SAVE_ERROR        \"Yazmak üzere checksum dosyası açılamadı.\"\r\n\tIDS_HC_OK                \"Tamam\"\r\n\tIDS_HC_CANCEL            \"İptal\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Chec&ksum oluştur...\"\r\n\tIDS_HS_TITLE_FMT         \"\"\"%s\"\" oluşturuluyor...\"\r\n\r\n\tIDS_HP_TITLE             \"Dosya Hash'leri\"\r\n\tIDS_HP_STATUSBOX         \"Süreç\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s başarı ile hash'lendi\"\r\n\tIDS_HP_FIND              \"&Bul\"\r\n\tIDS_HP_FIND_NOSTRING     \"Arama metnini girin.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Metin bulunamadı.\"\r\n\tIDS_HP_SAVE              \"&Kaydet...\"\r\n\tIDS_HP_OPTIONS           \"&Özellikler\"\r\n\tIDS_HP_FILELABEL         \"   Dosya: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"\"\"%s\"\" açılamıyor\"\r\n\tIDS_HV_SUMMARY           \"Özet\"\r\n\tIDS_HV_MATCH             \"Karşılaştırma:\"\r\n\tIDS_HV_MISMATCH          \"Uyumsuz:\"\r\n\tIDS_HV_UNREADABLE        \"Okunamaz:\"\r\n\tIDS_HV_PENDING           \"Bekleyen:\"\r\n\tIDS_HV_EXIT              \"&Çıkış\"\r\n\tIDS_HV_COL_FILENAME      \"Dosya İsmi\"\r\n\tIDS_HV_COL_SIZE          \"Boyut\"\r\n\tIDS_HV_COL_STATUS        \"Durum\"\r\n\tIDS_HV_COL_EXPECTED      \"Beklenen Checksum\"\r\n\tIDS_HV_COL_ACTUAL        \"Varolan Checksum\"\r\n\tIDS_HV_STATUS_MATCH      \"UYUMLU\"\r\n\tIDS_HV_STATUS_MISMATCH   \"UYUMSUZ\"\r\n\tIDS_HV_STATUS_UNREADABLE \"OKUNAMIYOR\"\r\n\r\n\tIDS_OPT_TITLE            \"HashCheck Özellikleri\"\r\n\tIDS_OPT_CM               \"Sağ tuş menü özellikleri\"\r\n\tIDS_OPT_CM_ALWAYS        \"&HashCheck'i sağ tuş menüsünde göster\"\r\n\tIDS_OPT_CM_EXTENDED      \"Hashcheck'i &gelişmiş sağ tuş menüsünde göster\"\r\n\tIDS_OPT_CM_NEVER         \"HashCheck'i a&sla sağ tuş menüsünde gösterme\"\r\n\tIDS_OPT_ENCODING         \"Checksum dosyası karakter kodlaması\"\r\n\tIDS_OPT_ENCODING_UTF8    \"U&TF-8 kullanarak kaydet\"\r\n\tIDS_OPT_ENCODING_UTF16   \"&UTF-16LE kullanarak kaydet\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Varsayılan &ANSI kod sayfasını kullanarak kaydet\"\r\n\tIDS_OPT_CHK              \"Dosya Hash'leri\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Özellik sayfası yazıtipi\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Yazıtipi'ni değiştir\"\r\n}\r\n\r\n// українська\r\nSTRINGTABLE LANGUAGE LANG_UKRAINIAN, SUBLANG_DEFAULT\r\n{\r\n\tIDS_FILETYPE_DESC        \"Файл контрольної суми\"\r\n\r\n\tIDS_HC_PAUSE             \"&Пауза\"\r\n\tIDS_HC_RESUME            \"Про&довжити\"\r\n\tIDS_HC_STOP              \"&Стоп\"\r\n\tIDS_HC_RESULT_FMT        \"%u з %u файла\"\r\n\tIDS_HC_RESULTS_FMT       \"%u з %u файлів\"\r\n\tIDS_HC_SAVE_ERROR        \"Неможливо відкрити для запису файл контрольної суми.\"\r\n\tIDS_HC_OK                \"OK\"\r\n\tIDS_HC_CANCEL            \"Скасувати\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Створити &файл контрольної суми...\"\r\n\tIDS_HS_TITLE_FMT         \"Створення \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Контрольні суми\"\r\n\tIDS_HP_STATUSBOX         \"Виконанння\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s прохешовано\"\r\n\tIDS_HP_FIND              \"З&найти\"\r\n\tIDS_HP_FIND_NOSTRING     \"Уведіть текст для пошуку.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"Текст не знайдений.\"\r\n\tIDS_HP_SAVE              \"&Зберегти...\"\r\n\tIDS_HP_OPTIONS           \"&Опції\"\r\n\tIDS_HP_FILELABEL         \"    Файл: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"Неможливо відкрити \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Результати\"\r\n\tIDS_HV_MATCH             \"Співпали:\"\r\n\tIDS_HV_MISMATCH          \"Не співпали:\"\r\n\tIDS_HV_UNREADABLE        \"Не прочитані:\"\r\n\tIDS_HV_PENDING           \"Лишилось:\"\r\n\tIDS_HV_EXIT              \"&Вихід\"\r\n\tIDS_HV_COL_FILENAME      \"Ім'я файла\"\r\n\tIDS_HV_COL_SIZE          \"Розмір\"\r\n\tIDS_HV_COL_STATUS        \"Статус\"\r\n\tIDS_HV_COL_EXPECTED      \"Чекалась контрольна сума\"\r\n\tIDS_HV_COL_ACTUAL        \"Фактична контрольна сума\"\r\n\tIDS_HV_STATUS_MATCH      \"СПІВПАВ\"\r\n\tIDS_HV_STATUS_MISMATCH   \"НЕ СПІВПАВ\"\r\n\tIDS_HV_STATUS_UNREADABLE \"НЕ ПРОЧИТАНИЙ\"\r\n\r\n\tIDS_OPT_TITLE            \"Опції HashCheck\"\r\n\tIDS_OPT_CM               \"Інтеграція до оболонки\"\r\n\tIDS_OPT_CM_ALWAYS        \"&Відображати у меню ярликів\"\r\n\tIDS_OPT_CM_EXTENDED      \"Відображати у &розширеному меню ярликів\"\r\n\tIDS_OPT_CM_NEVER         \"&Не відображати у меню ярликів\"\r\n\tIDS_OPT_ENCODING         \"Кодування символів у файлі контрольної суми\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Зберег&ти як UTF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Зберегти &як UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"&Зберегти як ANSI\"\r\n\tIDS_OPT_CHK              \"Контрольні суми\"\r\n\tIDS_OPT_CHK_ERROR        \"Please select at least one checksum\"\r\n\tIDS_OPT_FONT             \"Шрифт у вікні властивостей\"\r\n\tIDS_OPT_FONT_CHANGE      \"З&мінити...\"\r\n}\r\n\r\n// Català\r\nSTRINGTABLE LANGUAGE LANG_CATALAN, SUBLANG_CATALAN_CATALAN\r\n{\r\n\tIDS_FILETYPE_DESC        \"Fitxer de verificació\"\r\n\r\n\tIDS_HC_PAUSE             \"&Posa en pausa\"\r\n\tIDS_HC_RESUME            \"&Reprèn\"\r\n\tIDS_HC_STOP              \"&Atura\"\r\n\tIDS_HC_RESULT_FMT        \"%u d'%u fitxer\"\r\n\tIDS_HC_RESULTS_FMT       \"%u de %u fitxers\"\r\n\tIDS_HC_SAVE_ERROR        \"No es pot obrir el fitxer de verificació per escriure.\"\r\n\tIDS_HC_OK                \"D'acord\"\r\n\tIDS_HC_CANCEL            \"Cancel·la\"\r\n\r\n\tIDS_HS_MENUTEXT          \"Crea fitxer de verificació...\"\r\n\tIDS_HS_TITLE_FMT         \"Creant \"\"%s\"\"...\"\r\n\r\n\tIDS_HP_TITLE             \"Checksums\"\r\n\tIDS_HP_STATUSBOX         \"Progrés\"\r\n\tIDS_HP_STATUSTEXT_FMT    \"%s processats correctament\"\r\n\tIDS_HP_FIND              \"&Cerca\"\r\n\tIDS_HP_FIND_NOSTRING     \"Introdueix el text de cerca.\"\r\n\tIDS_HP_FIND_NOTFOUND     \"No s'ha trobat el text.\"\r\n\tIDS_HP_SAVE              \"&Desa...\"\r\n\tIDS_HP_OPTIONS           \"&Opcions\"\r\n\tIDS_HP_FILELABEL         \"  Fitxer: \"\r\n\r\n\tIDS_HV_LOADERROR_FMT     \"No es pot carregar \"\"%s\"\"\"\r\n\tIDS_HV_SUMMARY           \"Resum\"\r\n\tIDS_HV_MATCH             \"Coincideix:\"\r\n\tIDS_HV_MISMATCH          \"No coincideix:\"\r\n\tIDS_HV_UNREADABLE        \"Il·legible:\"\r\n\tIDS_HV_PENDING           \"Restants:\"\r\n\tIDS_HV_EXIT              \"&Surt\"\r\n\tIDS_HV_COL_FILENAME      \"Fitxer\"\r\n\tIDS_HV_COL_SIZE          \"Mida\"\r\n\tIDS_HV_COL_STATUS        \"Estat\"\r\n\tIDS_HV_COL_EXPECTED      \"Suma de verificació esperada\"\r\n\tIDS_HV_COL_ACTUAL        \"Suma de verificació actual\"\r\n\tIDS_HV_STATUS_MATCH      \"COINCIDEIX\"\r\n\tIDS_HV_STATUS_MISMATCH   \"NO COINCIDEIX\"\r\n\tIDS_HV_STATUS_UNREADABLE \"IL·LEGIBLE\"\r\n\r\n\tIDS_OPT_TITLE            \"Opcions de HashCheck\"\r\n\tIDS_OPT_CM               \"Integració amb Windows\"\r\n\tIDS_OPT_CM_ALWAYS        \"Mostra HashCheck en el menú &contextual\"\r\n\tIDS_OPT_CM_EXTENDED      \"Mostra HashCheck en el menú contextual &estès\"\r\n\tIDS_OPT_CM_NEVER         \"&No mostris mai HashCheck en el menú contextual\"\r\n\tIDS_OPT_ENCODING         \"Codificació de caràcters\"\r\n\tIDS_OPT_ENCODING_UTF8    \"Desa utilitzant U&TF-8\"\r\n\tIDS_OPT_ENCODING_UTF16   \"Desa utilitzant &UTF-16LE\"\r\n\tIDS_OPT_ENCODING_ANSI    \"Desa utilitzant &ANSI\"\r\n\tIDS_OPT_CHK              \"Checksums\"\r\n\tIDS_OPT_CHK_ERROR        \"Seleccioneu com a mínim un checksum, si us plau.\"\r\n\tIDS_OPT_FONT             \"Tipus de lletra\"\r\n\tIDS_OPT_FONT_CHANGE      \"&Canvia...\"\r\n}\r\n"
        },
        {
          "name": "HashCheckUI.h",
          "type": "blob",
          "size": 1.0087890625,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __HASHCHECKUI_H__\r\n#define __HASHCHECKUI_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\nHANDLE __fastcall CreateThreadCRT( PVOID pThreadProc, PVOID pvParam );\r\n\r\n// HashSave\r\nVOID WINAPI HashSaveStart( HWND hWndOwner, HSIMPLELIST hListInput );\r\n\r\n// HashProp\r\nUINT CALLBACK HashPropCallback( HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp );\r\nINT_PTR CALLBACK HashPropDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );\r\n\r\n// HashVerify\r\nDWORD WINAPI HashVerifyThread( PTSTR pszPath );\r\n\r\n// Activation context functions\r\nULONG_PTR WINAPI ActivateManifest( BOOL bActivate );\r\n\r\n__forceinline VOID WINAPI DeactivateManifest( ULONG_PTR uCookie )\r\n{\r\n\tif (uCookie)\r\n\t\tDeactivateActCtx(0, uCookie);\r\n}\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "HashProp.c",
          "type": "blob",
          "size": 28.3232421875,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"HashCheckCommon.h\"\r\n#include \"HashCalc.h\"\r\n#include \"libs/WinHash.h\"\r\n#include <Strsafe.h>\r\n#include <assert.h>\r\n\r\n// Control structures, from HashCalc.h\r\n#define  HASHPROPSCRATCH  HASHCALCSCRATCH\r\n#define PHASHPROPSCRATCH PHASHCALCSCRATCH\r\n#define  HASHPROPCONTEXT  HASHCALCCONTEXT\r\n#define PHASHPROPCONTEXT PHASHCALCCONTEXT\r\n#define  HASHPROPITEM     HASHCALCITEM\r\n#define PHASHPROPITEM    PHASHCALCITEM\r\n\r\n\r\n/*============================================================================*\\\r\n\tFunction declarations\r\n\\*============================================================================*/\r\n\r\n// Worker thread\r\nVOID __fastcall HashPropWorkerMain( PHASHPROPCONTEXT phpctx );\r\nVOID WINAPI HashPropRestart( PHASHPROPCONTEXT phpctx );\r\n\r\n// Dialog general\r\nVOID WINAPI HashPropDlgInit( PHASHPROPCONTEXT phpctx );\r\nVOID WINAPI HashPropFitDialog( HWND hWnd );\r\nVOID WINAPI HashPropForceLTR( HWND hWndEdit );\r\n\r\n// Dialog status\r\nLRESULT CALLBACK HashPropEditProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );\r\nLRESULT CALLBACK HashPropResultsProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\nVOID WINAPI HashPropUpdateResults( PHASHPROPCONTEXT phpctx, PHASHPROPITEM pItem );\r\nVOID WINAPI HashPropFinalStatus( PHASHPROPCONTEXT phpctx );\r\n\r\n// Dialog commands\r\nVOID WINAPI HashPropFindText( PHASHPROPCONTEXT phpctx, BOOL bIncremental );\r\nVOID WINAPI HashPropSaveResults( PHASHPROPCONTEXT phpctx );\r\nVOID WINAPI HashPropDoSaveResults( PHASHPROPCONTEXT phpctx );\r\nVOID WINAPI HashPropSaveResultsCleanup( PHASHPROPCONTEXT phpctx );\r\nVOID WINAPI HashPropOptions( PHASHPROPCONTEXT phpctx );\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tEntry points / main functions\r\n\\*============================================================================*/\r\n\r\nUINT CALLBACK HashPropCallback( HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp )\r\n{\r\n\tHSIMPLELIST hList = (HSIMPLELIST)(ppsp->lParam);\r\n\r\n\tswitch (uMsg)\r\n\t{\r\n\t\tcase PSPCB_ADDREF:\r\n\t\t\tSLAddRef(hList);\r\n\t\t\tbreak;\r\n\r\n\t\tcase PSPCB_RELEASE:\r\n\t\t\tSLRelease(hList);\r\n\t\t\tbreak;\r\n\r\n\t\tcase PSPCB_CREATE:\r\n\t\t{\r\n\t\t\tPHASHPROPCONTEXT phpctx = SLSetContextSize(hList, sizeof(HASHPROPCONTEXT));\r\n\r\n\t\t\tif (phpctx)\r\n\t\t\t{\r\n\t\t\t\tphpctx->status = INACTIVE;\r\n\t\t\t\tphpctx->hListRaw = hList;\r\n\t\t\t\treturn(1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn(0);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tWorker thread\r\n\\*============================================================================*/\r\n\r\nVOID __fastcall HashPropWorkerMain( PHASHPROPCONTEXT phpctx )\r\n{\r\n\t// Note that ALL message communication to and from the main window MUST\r\n\t// be asynchronous, or else there may be a deadlock.\r\n\r\n\tPHASHPROPITEM pItem;\r\n    WHCTXEX whctx;\r\n\r\n\t// Prep: if not already done, expand directories, establish prefix, etc.\r\n    if (! (phpctx->dwFlags & HPF_HLIST_PREPPED))\r\n    {\r\n        PostMessage(phpctx->hWnd, HM_WORKERTHREAD_TOGGLEPREP, (WPARAM)phpctx, TRUE);\r\n        if (! HashCalcPrepare(phpctx))\r\n            return;\r\n        phpctx->dwFlags |= HPF_HLIST_PREPPED;\r\n    }\r\n\tPostMessage(phpctx->hWnd, HM_WORKERTHREAD_TOGGLEPREP, (WPARAM)phpctx, FALSE);\r\n\r\n\t// Which checksum types we want to calculate\r\n    // (this is loaded earlier in HashPropDlgInit())\r\n    DWORD checksumFlags = (UINT8)phpctx->opt.dwChecksums;\r\n\r\n    // Read buffer\r\n    PBYTE pbBuffer = (PBYTE)VirtualAlloc(NULL, READ_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);\r\n    if (pbBuffer == NULL)\r\n        return;\r\n\r\n#ifdef _TIMED\r\n    DWORD dwStarted;\r\n    dwStarted = GetTickCount();\r\n#endif\r\n\r\n\twhile (pItem = SLGetDataAndStep(phpctx->hList))\r\n\t{\r\n        // Some results might already be present if the user changes which checksum types\r\n        // to calculate and we're going through the list a second+ time for all/some items;\r\n        // only calculate the checksums we don't already have (usually all those requested)\r\n        whctx.dwFlags = checksumFlags & ~pItem->results.dwFlags;\r\n\r\n\t\t// Get the hash\r\n\t\tWorkerThreadHashFile(\r\n\t\t\t(PCOMMONCONTEXT)phpctx,\r\n\t\t\tpItem->szPath,\r\n\t\t\t&whctx,\r\n\t\t\t&pItem->results,\r\n\t\t\tpbBuffer,\r\n\t\t\tNULL, 0, NULL, NULL\r\n#ifdef _TIMED\r\n          , &pItem->dwElapsed\r\n#endif\r\n        );\r\n\r\n        if (phpctx->status == PAUSED)\r\n            WaitForSingleObject(phpctx->hUnpauseEvent, INFINITE);\r\n\t\tif (phpctx->status == CANCEL_REQUESTED)\r\n\t\t\tbreak;\r\n\r\n\t\t// Update the UI\r\n\t\t++phpctx->cSentMsgs;\r\n\t\tPostMessage(phpctx->hWnd, HM_WORKERTHREAD_UPDATE, (WPARAM)phpctx, (LPARAM)pItem);\r\n\t}\r\n#ifdef _TIMED\r\n    phpctx->dwElapsed = GetTickCount() - dwStarted;\r\n#endif\r\n    VirtualFree(pbBuffer, 0, MEM_RELEASE);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog general\r\n\\*============================================================================*/\r\n\r\nINT_PTR CALLBACK HashPropDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\r\n{\r\n\tPHASHPROPCONTEXT phpctx;\r\n\r\n\tswitch (uMsg)\r\n\t{\r\n\t\tcase WM_INITDIALOG:\r\n\t\t{\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)SLGetContextData((HSIMPLELIST)(((LPPROPSHEETPAGE)lParam)->lParam));\r\n\r\n\t\t\t// Associate the window with the context and vice-versa\r\n\t\t\tphpctx->hWnd = hWnd;\r\n\t\t\tSetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)phpctx);\r\n\r\n\t\t\tHashPropDlgInit(phpctx);\r\n\r\n\t\t\tphpctx->pfnWorkerMain = HashPropWorkerMain;\r\n\t\t\tphpctx->hThread = CreateThreadCRT(NULL, phpctx);\r\n\r\n\t\t\tif (!phpctx->hThread)\r\n\t\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phpctx);\r\n\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase WM_SHOWWINDOW:\r\n\t\t{\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\tif (wParam && !(phpctx->dwFlags & HPF_HAS_RESIZED))\r\n\t\t\t{\r\n\t\t\t\t// We wait for WM_SHOWWINDOW because the reported size may not\r\n\t\t\t\t// be accurate during WM_INITDIALOG\r\n\t\t\t\tHashPropFitDialog(hWnd);\r\n\t\t\t\tphpctx->dwFlags |= HPF_HAS_RESIZED;\r\n\t\t\t}\r\n\r\n\t\t\tHashPropForceLTR(GetDlgItem(hWnd, IDC_RESULTS));\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_ENDSESSION:\r\n        {\r\n            if (wParam == FALSE)  // if TRUE, fall through to WM_DESTROY\r\n                break;\r\n        }\r\n\t\tcase WM_DESTROY:\r\n\t\t{\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\t// Undo the search box subclassing\r\n\t\t\tSetWindowLongPtr(\r\n\t\t\t\tGetDlgItem(hWnd, IDC_SEARCHBOX),\r\n\t\t\t\tGWLP_WNDPROC,\r\n\t\t\t\t(LONG_PTR)phpctx->wpSearchBox\r\n\t\t\t);\r\n\r\n            // Undo the results box subclassing\r\n            SetWindowLongPtr(\r\n                GetDlgItem(hWnd, IDC_RESULTS),\r\n                GWLP_WNDPROC,\r\n                (LONG_PTR)phpctx->wpResultsBox\r\n            );\r\n\r\n\t\t\t// Kill the worker thread; HCF_EXIT_PENDING indicates\r\n            // we don't need to do any further GUI updates\r\n\t\t\tphpctx->dwFlags |= HCF_EXIT_PENDING;\r\n\t\t\tWorkerThreadStop((PCOMMONCONTEXT)phpctx);\r\n\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phpctx);\r\n\r\n\t\t\t// Cleanup\r\n            HashPropSaveResultsCleanup(phpctx);\r\n\t\t\tif (phpctx->hFont) DeleteObject(phpctx->hFont);\r\n\t\t\tif (phpctx->hList) SLRelease(phpctx->hList);\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t{\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\tswitch (LOWORD(wParam))\r\n\t\t\t{\r\n\t\t\t\tcase IDC_SEARCHBOX:\r\n\t\t\t\t{\r\n\t\t\t\t\tif (HIWORD(wParam) == EN_CHANGE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tHashPropFindText(phpctx, TRUE);\r\n\t\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_FIND_NEXT:\r\n\t\t\t\t{\r\n\t\t\t\t\tHashPropFindText(phpctx, FALSE);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_PAUSE:\r\n\t\t\t\t{\r\n\t\t\t\t\tWorkerThreadTogglePause((PCOMMONCONTEXT)phpctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_STOP:\r\n\t\t\t\t{\r\n                    phpctx->dwFlags |= HPF_INTERRUPTED;\r\n\t\t\t\t\tWorkerThreadStop((PCOMMONCONTEXT)phpctx);\r\n                    HashPropSaveResultsCleanup(phpctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_SAVE:\r\n\t\t\t\t{\r\n\t\t\t\t\tHashPropSaveResults(phpctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_OPTIONS:\r\n\t\t\t\t{\r\n\t\t\t\t\tHashPropOptions(phpctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_RESULTS:\r\n\t\t\t\t{\r\n\t\t\t\t\tif (HIWORD(wParam) == EN_ALIGN_RTL_EC)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Do not allow the textbox to go into RTL; unfortunately,\r\n\t\t\t\t\t\t// we get this notification only if the order was changed\r\n\t\t\t\t\t\t// by a keyboard shortcut, not if it was changed by the\r\n\t\t\t\t\t\t// context menu--in fact, no notification of any sort\r\n\t\t\t\t\t\t// is sent when it is changed by the context menu, which\r\n\t\t\t\t\t\t// seems like it may be a bug in Windows.\r\n\t\t\t\t\t\tHashPropForceLTR((HWND)lParam);\r\n\t\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_TIMER:\r\n\t\t{\r\n\t\t\t// Vista: Workaround to fix their buggy progress bar\r\n\t\t\tKillTimer(hWnd, TIMER_ID_PAUSE);\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\t\t\tif (phpctx->status == PAUSED)\r\n\t\t\t\tSetProgressBarPause((PCOMMONCONTEXT)phpctx, PBST_PAUSED);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_DONE:\r\n\t\t{\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)wParam;\r\n\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phpctx);\r\n            if (phpctx->hFileOut != INVALID_HANDLE_VALUE)\r\n                HashPropDoSaveResults(phpctx);\r\n\t\t\tHashPropFinalStatus(phpctx);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_UPDATE:\r\n\t\t{\r\n\t\t\tphpctx = (PHASHPROPCONTEXT)wParam;\r\n\t\t\t++phpctx->cHandledMsgs;\r\n            // If we're restarting the worker thread, no need to update the GUI\r\n            if (phpctx->dwFlags & HCF_RESTARTING)\r\n            {\r\n                // Only restart the worker thread once we're caught up on handled messages\r\n                if (phpctx->cHandledMsgs >= phpctx->cSentMsgs)\r\n                    HashPropRestart(phpctx);\r\n            }\r\n            else\r\n                HashPropUpdateResults(phpctx, (PHASHPROPITEM)lParam);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_TOGGLEPREP:\r\n\t\t{\r\n\t\t\tHashCalcTogglePrep((PHASHPROPCONTEXT)wParam, (BOOL)lParam);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(FALSE);\r\n}\r\n\r\nLRESULT CALLBACK HashPropEditProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\r\n{\r\n\tPHASHPROPCONTEXT phpctx = (PHASHPROPCONTEXT)GetWindowLongPtr(\r\n\t\t(HWND)GetWindowLongPtr(hWnd, GWLP_HWNDPARENT),\r\n\t\tDWLP_USER\r\n\t);\r\n\r\n\tif (wParam == VK_RETURN)\r\n\t{\r\n\t\tif (uMsg == WM_GETDLGCODE)\r\n\t\t{\r\n\t\t\treturn(DLGC_WANTALLKEYS);\r\n\t\t}\r\n\t\telse if (uMsg >= WM_KEYFIRST && uMsg <= WM_KEYLAST)\r\n\t\t{\r\n\t\t\tif (uMsg == WM_KEYDOWN)\r\n\t\t\t\tHashPropFindText(phpctx, FALSE);\r\n\r\n\t\t\treturn(0);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(CallWindowProc(phpctx->wpSearchBox, hWnd, uMsg, wParam, lParam));\r\n}\r\n\r\nLRESULT CALLBACK HashPropResultsProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    PHASHPROPCONTEXT phpctx = (PHASHPROPCONTEXT)GetWindowLongPtr(\r\n        (HWND)GetWindowLongPtr(hWnd, GWLP_HWNDPARENT),\r\n        DWLP_USER\r\n    );\r\n\r\n    if (wParam == VK_ESCAPE)\r\n    {\r\n        if (uMsg == WM_GETDLGCODE)\r\n        {\r\n            return(DLGC_WANTALLKEYS);\r\n        }\r\n        else if (uMsg >= WM_KEYFIRST && uMsg <= WM_KEYLAST)\r\n        {\r\n            PostMessage(phpctx->hWnd, uMsg, wParam, lParam);\r\n\r\n            return(0);\r\n        }\r\n    }\r\n    else if (uMsg == WM_CHAR && wParam == 1)  // CTRL-a\r\n    {\r\n        SendMessage(hWnd, EM_SETSEL, 0, -1);\r\n\r\n        return(1);\r\n    }\r\n\r\n    return(CallWindowProc(phpctx->wpResultsBox, hWnd, uMsg, wParam, lParam));\r\n}\r\n\r\nVOID WINAPI HashPropDlgInit( PHASHPROPCONTEXT phpctx )\r\n{\r\n\tHWND hWnd = phpctx->hWnd;\r\n\tUINT i;\r\n\r\n\t// Load strings\r\n\t{\r\n\t\tstatic const UINT16 arStrMap[][2] =\r\n\t\t{\r\n\t\t\t{ IDC_STATUSBOX, IDS_HP_STATUSBOX },\r\n\t\t\t{ IDC_FIND_NEXT, IDS_HP_FIND      },\r\n\t\t\t{ IDC_PAUSE,     IDS_HP_PAUSE     },\r\n\t\t\t{ IDC_STOP,      IDS_HP_STOP      },\r\n\t\t\t{ IDC_SAVE,      IDS_HP_SAVE      },\r\n\t\t\t{ IDC_OPTIONS,   IDS_HP_OPTIONS   }\r\n\t\t};\r\n\r\n\t\tfor (i = 0; i < countof(arStrMap); ++i)\r\n\t\t\tSetControlText(hWnd, arStrMap[i][0], arStrMap[i][1]);\r\n\t}\r\n\r\n    // Load the two configuration items we need\r\n    phpctx->opt.dwFlags = HCOF_FONT | HCOF_CHECKSUMS;\r\n    OptionsLoad(&phpctx->opt);\r\n\r\n\t// Initialize the results text box\r\n\t{\r\n\t\t// Set the font\r\n\t\tif (phpctx->hFont = CreateFontIndirect(&phpctx->opt.lfFont))\r\n\t\t\tSendDlgItemMessage(hWnd, IDC_RESULTS, WM_SETFONT, (WPARAM)phpctx->hFont, FALSE);\r\n\r\n\t\t// Eliminate the text limit\r\n\t\tSendDlgItemMessage(hWnd, IDC_RESULTS, EM_SETLIMITTEXT, 0, 0);\r\n\r\n        // Subclass it to handle CTRL-a\r\n        phpctx->wpResultsBox = (WNDPROC)SetWindowLongPtr(\r\n            GetDlgItem(hWnd, IDC_RESULTS),\r\n            GWLP_WNDPROC,\r\n            (LONG_PTR)HashPropResultsProc\r\n        );\r\n\t}\r\n\r\n\t// Initialize the search text box\r\n\t{\r\n\t\t// Subclass it to handle pressing the return key\r\n\t\tphpctx->wpSearchBox = (WNDPROC)SetWindowLongPtr(\r\n\t\t\tGetDlgItem(hWnd, IDC_SEARCHBOX),\r\n\t\t\tGWLP_WNDPROC,\r\n\t\t\t(LONG_PTR)HashPropEditProc\r\n\t\t);\r\n\t}\r\n\r\n\t// Initialize miscellaneous stuff\r\n\t{\r\n\t\tphpctx->hList = SLCreateEx(TRUE);\r\n\t\tphpctx->dwFlags = 0;\r\n\t\tphpctx->cTotal = 0;\r\n\t\tphpctx->cSuccess = 0;\r\n\t\tphpctx->obScratch = 0;\r\n        phpctx->hThread = NULL;\r\n        phpctx->hUnpauseEvent = NULL;\r\n        phpctx->hFileOut = INVALID_HANDLE_VALUE;\r\n\t\tZeroMemory(&phpctx->ofn, sizeof(phpctx->ofn));\r\n\t}\r\n}\r\n\r\nVOID WINAPI HashPropFitDialog( HWND hWnd )\r\n{\r\n\tHWND hWndResults = GetDlgItem(hWnd, IDC_RESULTS);\r\n\tRECT rcDlg, rcTop, rcBottom;\r\n\tINT dy, dx, i;\r\n\r\n\tGetClientRect(hWnd, &rcDlg);\r\n\tGetWindowRect(hWndResults, &rcTop);\r\n\tGetWindowRect(GetDlgItem(hWnd, IDC_OPTIONS), &rcBottom);\r\n\r\n\t// This is kosher because a RECT is really just two POINTs...\r\n\tScreenToClient(hWnd, (PPOINT)&rcTop.left);\r\n\tScreenToClient(hWnd, (PPOINT)&rcTop.right);\r\n\tScreenToClient(hWnd, (PPOINT)&rcBottom.right);\r\n\r\n\t// Get the amount that we need to offset by...\r\n\tdy = (rcDlg.bottom - rcBottom.bottom) - (rcTop.top - rcDlg.top);\r\n\tdx = (rcDlg.right - rcTop.right) - (rcTop.left - rcDlg.left);\r\n\r\n\tif (dy > 0)\r\n\t{\r\n\t\t// Controls to move by dy\r\n\t\tstatic const UINT16 arCtrlsMY[] =\r\n\t\t{\r\n\t\t\tIDC_STATUSBOX,\r\n\t\t\tIDC_PROG_TOTAL,\r\n\t\t\tIDC_PROG_FILE,\r\n\t\t\tIDC_SEARCHBOX,\r\n\t\t\tIDC_FIND_NEXT,\r\n\t\t\tIDC_PAUSE,\r\n\t\t\tIDC_STOP,\r\n\t\t\tIDC_SAVE,\r\n\t\t\tIDC_OPTIONS\r\n\t\t};\r\n\r\n\t\t// Shift controls down by dy\r\n\t\tfor (i = 0; i < countof(arCtrlsMY); ++i)\r\n\t\t{\r\n\t\t\tHWND hWndCtrl = GetDlgItem(hWnd, arCtrlsMY[i]);\r\n\t\t\tGetWindowRect(hWndCtrl, &rcBottom);\r\n\t\t\tScreenToClient(hWnd, (PPOINT)&rcBottom.left);\r\n\t\t\tSetWindowPos(hWndCtrl, NULL, rcBottom.left, rcBottom.top + dy,\r\n\t\t\t             0, 0, SWP_NOSIZE | SWP_NOZORDER);\r\n\t\t}\r\n\r\n\t\t// Increase the height of the results box by dy\r\n\t\tSetWindowPos(hWndResults, NULL, 0, 0, rcTop.right - rcTop.left,\r\n\t\t             dy + rcTop.bottom - rcTop.top, SWP_NOMOVE | SWP_NOZORDER);\r\n\t}\r\n\r\n\tif (dx > 0)\r\n\t{\r\n\t\t// Controls to resize by dx\r\n\t\tstatic const UINT16 arCtrlsSX[] =\r\n\t\t{\r\n\t\t\tIDC_RESULTS,\r\n\t\t\tIDC_STATUSBOX,\r\n\t\t\tIDC_PROG_TOTAL,\r\n\t\t\tIDC_PROG_FILE,\r\n\t\t\tIDC_SEARCHBOX\r\n\t\t};\r\n\r\n\t\t// Controls to move by dx\r\n\t\tstatic const UINT16 arCtrlsMX[] =\r\n\t\t{\r\n\t\t\tIDC_FIND_NEXT,\r\n\t\t\tIDC_PAUSE,\r\n\t\t\tIDC_STOP,\r\n\t\t\tIDC_SAVE,\r\n\t\t\tIDC_OPTIONS\r\n\t\t};\r\n\r\n\t\t// Expand controls by dx\r\n\t\tfor (i = 0; i < countof(arCtrlsSX); ++i)\r\n\t\t{\r\n\t\t\tHWND hWndCtrl = GetDlgItem(hWnd, arCtrlsSX[i]);\r\n\t\t\tGetWindowRect(hWndCtrl, &rcBottom);\r\n\t\t\tScreenToClient(hWnd, (PPOINT)&rcBottom.left);\r\n\t\t\tScreenToClient(hWnd, (PPOINT)&rcBottom.right);\r\n\t\t\tSetWindowPos(hWndCtrl, NULL, 0, 0, dx + rcBottom.right - rcBottom.left,\r\n\t\t\t             rcBottom.bottom - rcBottom.top, SWP_NOMOVE | SWP_NOZORDER);\r\n\t\t}\r\n\r\n\t\t// Shift controls right by dx\r\n\t\tfor (i = 0; i < countof(arCtrlsMX); ++i)\r\n\t\t{\r\n\t\t\tHWND hWndCtrl = GetDlgItem(hWnd, arCtrlsMX[i]);\r\n\t\t\tGetWindowRect(hWndCtrl, &rcBottom);\r\n\t\t\tScreenToClient(hWnd, (PPOINT)&rcBottom.left);\r\n\t\t\tSetWindowPos(hWndCtrl, NULL, rcBottom.left + dx, rcBottom.top,\r\n\t\t\t             0, 0, SWP_NOSIZE | SWP_NOZORDER);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nVOID WINAPI HashPropForceLTR( HWND hWndEdit )\r\n{\r\n\tDWORD dwExStyle = (DWORD)GetWindowLongPtr(hWndEdit, GWL_EXSTYLE);\r\n\tdwExStyle &= ~(WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);\r\n\tSetWindowLongPtr(hWndEdit, GWL_EXSTYLE, dwExStyle);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog status\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashPropUpdateResults( PHASHPROPCONTEXT phpctx, PHASHPROPITEM pItem )\r\n{\r\n\tHWND hWnd = phpctx->hWnd;\r\n\tHWND hWndResults = GetDlgItem(hWnd, IDC_RESULTS);\r\n\r\n\t/**\r\n\t * It turns out that when hashing large numbers of small files, the\r\n\t * worker thread can far outpace the UI thread, leaving the UI thread\r\n\t * with a large backlog of updates; the solution is to keep track of\r\n\t * the size of this backlog so that steps can be taken to alleviate it.\r\n\t *\r\n\t * 1) cSentMsgs and cHandledMsgs are used to keep track of the backlog;\r\n\t *    cSentMsgs will always be >= to cHandledMsgs (there are no race\r\n\t *    conditions to worry about), and their difference is the number\r\n\t *    of updates pending in the queue AFTER the update currently being\r\n\t *    handled is completed; therefore, zero means no pending backlog.\r\n\t * 2) If there are more than 50 backlogged updates, the worker thread\r\n\t *    will throttle back enough to keep the backlog <= 50.\r\n\t * 3) If there is any backlog at all, results will be coalesced into\r\n\t *    batches to reduce the number of costly EM_REPLACESEL calls.\r\n\t * INVARIANT: the scratch buffer into which the results are coalesced\r\n\t *    has at least enough remaining space for adding the text results\r\n\t *    of a single file (it is cleared before returning if necessary)\r\n\t **/\r\n\r\n\tPTSTR pszScratchAppend;\r\n    size_t cchMaxBufferRequired = 0;  // max tchar count for text results of one file\r\n\r\n    // Check to see of any desired hashes are not present in the results\r\n    if (phpctx->opt.dwChecksums & ~pItem->results.dwFlags)\r\n        // Replace the invalid hashes with X's\r\n        HashCalcClearInvalid(&pItem->results, TEXT('X'));\r\n    else\r\n\t\t// Otherwise, we can increment the success count\r\n\t\t++phpctx->cSuccess;\r\n\r\n\t// Get the scratch buffer; we will be using the entire scratch struct\r\n\t// as a single monolithic buffer\r\n    pszScratchAppend = BYTEADD(&phpctx->scratch, phpctx->obScratch);\r\n\r\n\t// Copy the file label\r\n\tpszScratchAppend += LoadString(g_hModThisDll, IDS_HP_FILELABEL,\r\n\t\t                           pszScratchAppend, MAX_STRINGRES);\r\n    cchMaxBufferRequired += MAX_STRINGRES;\r\n\r\n\t// Copy the path, appending CRLF\r\n    pszScratchAppend = SSChainNCpy2(\r\n        pszScratchAppend,\r\n        pItem->szPath + phpctx->cchPrefix, pItem->cchPath - phpctx->cchPrefix,\r\n        CRLF, CCH_CRLF\r\n    );\r\n    cchMaxBufferRequired += MAX_PATH_BUFFER - phpctx->cchPrefix + CCH_CRLF;\r\n\r\n    // Copy the results\r\n    PTSTR pszScratchBeforeResults = pszScratchAppend;\r\n#define HASH_RESULT_APPEND_op(alg)                                              \\\r\n    if (phpctx->opt.dwChecksums & WHEX_CHECK##alg)                              \\\r\n        pszScratchAppend = SSChainNCpy3(                                        \\\r\n            pszScratchAppend,                                                   \\\r\n            HASH_RESULT_op(alg), sizeof(HASH_RESULT_op(alg))/sizeof(TCHAR) - 1, /* the \"- 1\" excludes the terminating NUL */ \\\r\n            pItem->results.szHex##alg, alg##_DIGEST_LENGTH * 2,                 \\\r\n            CRLF, CCH_CRLF                                                      \\\r\n        );\r\n    FOR_EACH_HASH(HASH_RESULT_APPEND_op)\r\n    cchMaxBufferRequired += pszScratchAppend - pszScratchBeforeResults;  // always the same length\r\n\r\n#ifndef _TIMED\r\n    // Append CRLF and a terminating NUL\r\n    pszScratchAppend = SSChainNCpy(\r\n        pszScratchAppend,\r\n        CRLF _T(\"\\0\"), CCH_CRLF + 1\r\n    );\r\n    cchMaxBufferRequired += CCH_CRLF + 1;\r\n    pszScratchAppend--;  // it now points to the terminating NUL\r\n#else\r\n    StringCchPrintfEx(pszScratchAppend, 30, &pszScratchAppend, NULL, 0, _T(\"Elapsed: %d ms\") CRLF CRLF, pItem->dwElapsed);\r\n    cchMaxBufferRequired += 30;\r\n#endif\r\n\r\n\t// Update the new buffer offset for use by the next update\r\n\tphpctx->obScratch = (UINT)BYTEDIFF(pszScratchAppend, &phpctx->scratch);\r\n\r\n\t// Determine if we can skip flushing the buffer\r\n\tif ( phpctx->cSentMsgs > phpctx->cHandledMsgs &&\r\n\t\t phpctx->obScratch + (cchMaxBufferRequired * sizeof(TCHAR)) <= sizeof(HASHPROPSCRATCH) )\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Flush the buffer to the text box\r\n\tphpctx->obScratch = 0;\r\n\tSendMessage(hWndResults, EM_SETSEL, -2, -2);\r\n\tSendMessage(hWndResults, EM_REPLACESEL, FALSE, (LPARAM)&phpctx->scratch);\r\n\r\n\t// ClearType will sometimes leave artifacts, so redraw if the user will\r\n\t// be looking at this text for a while\r\n\tif (phpctx->cSentMsgs == phpctx->cHandledMsgs)\r\n\t\tInvalidateRect(hWndResults, NULL, FALSE);\r\n\r\n\t// Yes, this means that if we defer the text box update, we also end up\r\n\t// deferring the progress bar update too, which is what we want; progress\r\n\t// bar updates are not deferred for unreadable files, but that is an edge\r\n\t// case that we should not dwell too much on.\r\n\tSendMessage(phpctx->hWndPBTotal, PBM_SETPOS, phpctx->cHandledMsgs, 0);\r\n}\r\n\r\nVOID WINAPI HashPropFinalStatus( PHASHPROPCONTEXT phpctx )\r\n{\r\n\tTCHAR szBuffer1[MAX_STRINGRES], szBuffer2[MAX_STRINGMSG], szBuffer3[MAX_STRINGMSG];\r\n\r\n\t// FormatFractionalResults expects an empty format buffer on the first call\r\n\tszBuffer1[0] = 0;\r\n\r\n\tFormatFractionalResults(szBuffer1, szBuffer2, phpctx->cSuccess, phpctx->cTotal);\r\n\r\n\tLoadString(\r\n\t\tg_hModThisDll,\r\n\t\tIDS_HP_STATUSTEXT_FMT,\r\n\t\tszBuffer1,\r\n\t\tcountof(szBuffer1)\r\n\t);\r\n\r\n\tStringCchPrintf(szBuffer3, countof(szBuffer3), szBuffer1, szBuffer2);\r\n\r\n#ifndef _TIMED\r\n\tSetDlgItemText(phpctx->hWnd, IDC_STATUSBOX, szBuffer3);\r\n#else\r\n    StringCchPrintf(szBuffer2, countof(szBuffer2), _T(\"%s in %d ms\"), szBuffer3, phpctx->dwElapsed);\r\n    SetDlgItemText(phpctx->hWnd, IDC_STATUSBOX, szBuffer2);\r\n#endif\r\n\r\n\t// Enable search controls\r\n\tEnableControl(phpctx->hWnd, IDC_SEARCHBOX, TRUE);\r\n\tEnableControl(phpctx->hWnd, IDC_FIND_NEXT, TRUE);\r\n\r\n\t// Enable the save button only if there exists completed results to save\r\n\tif (!(phpctx->dwFlags & HPF_INTERRUPTED) && phpctx->cSuccess > 0)\r\n\t\tEnableControl(phpctx->hWnd, IDC_SAVE, TRUE);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog commands\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashPropFindText( PHASHPROPCONTEXT phpctx, BOOL bIncremental )\r\n{\r\n\t// Since the SimpleList context for hList is unused (the hListRaw ctx\r\n\t// is the HP ctx), we might as well make use of that as an easy fussless\r\n\t// way to allocate memory without worrying about freeing it\r\n\r\n\tHWND hWndResults = GetDlgItem(phpctx->hWnd, IDC_RESULTS);\r\n\tHWND hWndSearch = GetDlgItem(phpctx->hWnd, IDC_SEARCHBOX);\r\n\r\n\tSIZE_T cchNeedle = SendMessage(hWndSearch, WM_GETTEXTLENGTH, 0, 0);\r\n\tPTSTR pszNeedle = SLSetContextSize(phpctx->hList, ((UINT)cchNeedle + 1) * sizeof(TCHAR));\r\n\tPTSTR pszHaystack;\r\n\tPTSTR pszFound = NULL;\r\n\r\n\tDWORD dwPos;\r\n\r\n\tif (bIncremental)\r\n\t\tSendMessage(hWndResults, EM_GETSEL, (WPARAM)&dwPos, (LPARAM)NULL);\r\n\telse\r\n\t\tSendMessage(hWndResults, EM_GETSEL, (WPARAM)NULL, (LPARAM)&dwPos);\r\n\r\n\tif (pszNeedle && SendMessage(hWndSearch, WM_GETTEXT, cchNeedle + 1, (LPARAM)pszNeedle))\r\n\t{\r\n\t\tHLOCAL hResults = (HLOCAL)SendMessage(hWndResults, EM_GETHANDLE, 0, 0);\r\n\r\n\t\t// Dangling whitespace should not affect search results\r\n\t\tStrTrim(pszNeedle, TEXT(\" \\t\\r\\n\"));\r\n\t\tcchNeedle = SSLen(pszNeedle);\r\n\r\n\t\tif (cchNeedle && hResults && (pszHaystack = LocalLock(hResults)))\r\n\t\t{\r\n\t\t\tpszFound = StrStrI(pszHaystack + dwPos, pszNeedle);\r\n\t\t\tif (!pszFound) pszFound = StrStrI(pszHaystack, pszNeedle);\r\n\r\n\t\t\tif (pszFound)\r\n\t\t\t{\r\n\t\t\t\tdwPos = (DWORD)(pszFound - pszHaystack);\r\n\t\t\t\tSendMessage(hWndResults, EM_SETSEL, dwPos, dwPos + cchNeedle);\r\n\t\t\t\tSendMessage(hWndResults, EM_SCROLLCARET, 0, 0);\r\n\t\t\t}\r\n\r\n\t\t\tLocalUnlock(hResults);\r\n\t\t}\r\n\t}\r\n\r\n\tif (cchNeedle == 0 && bIncremental)\r\n\t{\r\n\t\tSendMessage(hWndResults, EM_SETSEL, dwPos, dwPos);\r\n\t}\r\n\telse if (!pszFound)\r\n\t{\r\n\t\tTCHAR szBuffer[MAX_STRINGMSG];\r\n\r\n\t\tEDITBALLOONTIP ebt;\r\n\t\tebt.cbStruct = sizeof(ebt);\r\n\t\tebt.pszTitle = NULL;\r\n\t\tebt.pszText = szBuffer;\r\n\t\tebt.ttiIcon = TTI_NONE;\r\n\r\n\t\tLoadString(\r\n\t\t\tg_hModThisDll,\r\n\t\t\t(cchNeedle) ? IDS_HP_FIND_NOTFOUND : IDS_HP_FIND_NOSTRING,\r\n\t\t\tszBuffer,\r\n\t\t\tcountof(szBuffer)\r\n\t\t);\r\n\r\n\t\tSendMessage(hWndSearch, EM_SHOWBALLOONTIP, 0, (LPARAM)&ebt);\r\n\t}\r\n}\r\n\r\n\r\nVOID WINAPI HashPropSaveResults( PHASHPROPCONTEXT phpctx )\r\n{\r\n    assert(! (phpctx->dwFlags & HPF_INTERRUPTED));\r\n    assert(phpctx->cSuccess > 0);\r\n\r\n    // HashCalcInitSave will set the file handle\r\n    HashCalcInitSave(phpctx);\r\n\r\n    if (phpctx->hFileOut != INVALID_HANDLE_VALUE)\r\n    {\r\n        // If the last item in the list already has the desired hash computed\r\n        DWORD dwDesiredHash = 1 << (phpctx->ofn.nFilterIndex - 1);\r\n        if (((PHASHPROPITEM)SLGetDataLast(phpctx->hList))->results.dwFlags & dwDesiredHash)\r\n        {\r\n            HashPropDoSaveResults(phpctx);\r\n        }\r\n        else\r\n        {\r\n            // Ensure the desired hash is enabled, and begin generating the new hash(es)\r\n            assert(phpctx->status == CLEANUP_COMPLETED);\r\n            assert(phpctx->cHandledMsgs >= phpctx->cSentMsgs);\r\n            phpctx->opt.dwChecksums |= dwDesiredHash;\r\n            HashPropRestart(phpctx);\r\n            // HashPropDoSaveResults() is called when the worker thread posts a HM_WORKERTHREAD_DONE msg\r\n        }\r\n    }\r\n}\r\n\r\nVOID WINAPI HashPropDoSaveResults(PHASHPROPCONTEXT phpctx)\r\n{\r\n    assert(phpctx->hFileOut != INVALID_HANDLE_VALUE);\r\n\r\n\tif (! (phpctx->dwFlags & HPF_INTERRUPTED))\r\n\t{\r\n        HashCalcSetSaveFormat(phpctx);\r\n\r\n\t\tPHASHPROPITEM pItem;\r\n\r\n\t\tSLReset(phpctx->hList);\r\n\r\n\t\twhile (pItem = SLGetDataAndStep(phpctx->hList))\r\n\t\t\tHashCalcWriteResult(phpctx, pItem);\r\n\t}\r\n\r\n\tCloseHandle(phpctx->hFileOut);\r\n    phpctx->hFileOut = INVALID_HANDLE_VALUE;\r\n}\r\n\r\nVOID WINAPI HashPropSaveResultsCleanup( PHASHPROPCONTEXT phpctx )\r\n{\r\n    if (phpctx->hFileOut != INVALID_HANDLE_VALUE)\r\n    {\r\n        // Don't keep partially generated checksum files\r\n        BOOL bDeleted = HashCalcDeleteFileByHandle(phpctx->hFileOut);\r\n\r\n\t\tCloseHandle(phpctx->hFileOut);\r\n\r\n        // Should only happen on Windows XP\r\n        if (!bDeleted)\r\n            DeleteFile(phpctx->ofn.lpstrFile);\r\n\r\n        phpctx->hFileOut = INVALID_HANDLE_VALUE;\r\n\t}\r\n}\r\n\r\n\r\nVOID WINAPI HashPropOptions( PHASHPROPCONTEXT phpctx )\r\n{\r\n\tOptionsDialog(phpctx->hWnd, &phpctx->opt);\r\n\r\n    // Update the results, but only if a file save isn't in progress\r\n    if (phpctx->opt.dwFlags & HCOF_CHECKSUMS && phpctx->hFileOut == INVALID_HANDLE_VALUE)\r\n    {\r\n        phpctx->dwFlags |= HCF_RESTARTING;\r\n        WorkerThreadStop((PCOMMONCONTEXT)phpctx);\r\n        WorkerThreadCleanup((PCOMMONCONTEXT)phpctx);\r\n\r\n        if (phpctx->cHandledMsgs >= phpctx->cSentMsgs)\r\n            HashPropRestart(phpctx);\r\n        // Otherwise the call to HashPropRestart() is made following the\r\n        // last pending HM_WORKERTHREAD_UPDATE message in HashPropDlgProc()\r\n    }\r\n\r\n\tif (phpctx->opt.dwFlags & HCOF_FONT)\r\n\t{\r\n\t\tHFONT hFont = CreateFontIndirect(&phpctx->opt.lfFont);\r\n\r\n\t\tif (hFont)\r\n\t\t{\r\n\t\t\tSendDlgItemMessage(phpctx->hWnd, IDC_RESULTS, WM_SETFONT, (WPARAM)hFont, TRUE);\r\n\t\t\tif (phpctx->hFont) DeleteObject(phpctx->hFont);\r\n\t\t\tphpctx->hFont = hFont;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nVOID WINAPI HashPropRestart( PHASHPROPCONTEXT phpctx )\r\n{\r\n    // Reset these flags back to the default\r\n    phpctx->dwFlags &= ~(HCF_RESTARTING | HPF_INTERRUPTED);\r\n\r\n    // Just reset the list if it's fully loaded, else reload it from scratch\r\n    if (phpctx->dwFlags & HPF_HLIST_PREPPED)\r\n        SLReset(phpctx->hList);\r\n    else\r\n    {\r\n        SLRelease(phpctx->hList);\r\n        phpctx->hList = SLCreateEx(TRUE);\r\n        phpctx->cTotal = 0;\r\n    }\r\n\r\n    // Reset the GUI to its initial state\r\n    EnableControl( phpctx->hWnd, IDC_SAVE,       FALSE);\r\n    EnableControl( phpctx->hWnd, IDC_FIND_NEXT,  FALSE);\r\n    EnableControl( phpctx->hWnd, IDC_SEARCHBOX,  FALSE);\r\n    EnableControl( phpctx->hWnd, IDC_PROG_TOTAL, TRUE);\r\n    EnableControl( phpctx->hWnd, IDC_PROG_FILE,  TRUE);\r\n    EnableControl( phpctx->hWnd, IDC_PAUSE,      TRUE);\r\n    EnableControl( phpctx->hWnd, IDC_STOP,       TRUE);\r\n    SetDlgItemText(phpctx->hWnd, IDC_RESULTS,    TEXT(\"\"));\r\n    SetControlText(phpctx->hWnd, IDC_STATUSBOX,  IDS_HP_STATUSBOX);\r\n    SetControlText(phpctx->hWnd, IDC_PAUSE,      IDS_HC_PAUSE);\r\n    SetProgressBarPause((PCOMMONCONTEXT)phpctx,  PBST_NORMAL);\r\n    SendMessage(phpctx->hWndPBFile,  PBM_SETPOS, 0, 0);\r\n    SendMessage(phpctx->hWndPBTotal, PBM_SETPOS, 0, 0);\r\n\r\n    phpctx->cSuccess = 0;\r\n    phpctx->obScratch = 0;\r\n\r\n    phpctx->hThread = CreateThreadCRT(NULL, phpctx);\r\n\r\n    if (!phpctx->hThread)\r\n        WorkerThreadCleanup((PCOMMONCONTEXT)phpctx);\r\n}\r\n"
        },
        {
          "name": "HashSave.cpp",
          "type": "blob",
          "size": 13.232421875,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"HashCheckCommon.h\"\r\n#include \"HashCalc.h\"\r\n#include \"SetAppID.h\"\r\n#include \"IsSSD.h\"\r\n#include <Strsafe.h>\r\n#include <vector>\r\n#include <cassert>\r\n#include <algorithm>\r\n#ifdef USE_PPL\r\n#include <ppl.h>\r\n#include <concurrent_vector.h>\r\n#endif\r\n\r\n// Control structures, from HashCalc.h\r\n#define  HASHSAVESCRATCH  HASHCALCSCRATCH\r\n#define PHASHSAVESCRATCH PHASHCALCSCRATCH\r\n#define  HASHSAVECONTEXT  HASHCALCCONTEXT\r\n#define PHASHSAVECONTEXT PHASHCALCCONTEXT\r\n#define  HASHSAVEITEM     HASHCALCITEM\r\n#define PHASHSAVEITEM    PHASHCALCITEM\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tFunction declarations\r\n\\*============================================================================*/\r\n\r\n// Entry points / main functions\r\nDWORD WINAPI HashSaveThread( PHASHSAVECONTEXT phsctx );\r\n\r\n// Worker thread\r\nVOID __fastcall HashSaveWorkerMain( PHASHSAVECONTEXT phsctx );\r\n\r\n// Dialog general\r\nINT_PTR CALLBACK HashSaveDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );\r\nVOID WINAPI HashSaveDlgInit( PHASHSAVECONTEXT phsctx );\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tEntry points / main functions\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashSaveStart( HWND hWndOwner, HSIMPLELIST hListRaw )\r\n{\r\n\t// Explorer will be blocking as long as this function is running, so we\r\n\t// want to return as quickly as possible and leave the work up to the\r\n\t// thread that we are going to spawn\r\n\r\n\tPHASHSAVECONTEXT phsctx = (PHASHSAVECONTEXT)SLSetContextSize(hListRaw, sizeof(HASHSAVECONTEXT));\r\n\r\n\tif (phsctx)\r\n\t{\r\n\t\tHANDLE hThread;\r\n\r\n\t\tphsctx->hWnd = hWndOwner;\r\n\t\tphsctx->hListRaw = hListRaw;\r\n\r\n\t\tInterlockedIncrement(&g_cRefThisDll);\r\n\t\tSLAddRef(hListRaw);\r\n\r\n\t\tif (hThread = CreateThreadCRT(HashSaveThread, phsctx))\r\n\t\t{\r\n\t\t\tCloseHandle(hThread);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// If the thread creation was successful, the thread will be\r\n\t\t// responsible for decrementing the ref count\r\n\t\tSLRelease(hListRaw);\r\n\t\tInterlockedDecrement(&g_cRefThisDll);\r\n\t}\r\n}\r\n\r\nDWORD WINAPI HashSaveThread( PHASHSAVECONTEXT phsctx )\r\n{\r\n\t// First, activate our manifest and AddRef our host\r\n\tULONG_PTR uActCtxCookie = ActivateManifest(TRUE);\r\n\tULONG_PTR uHostCookie = HostAddRef();\r\n\r\n\t// Calling HashCalcPrepare with a NULL hList will cause it to calculate\r\n\t// and set cchPrefix, but it will not copy the data or walk the directories\r\n\t// (we will leave that for the worker thread to do); the reason we do a\r\n\t// limited scan now is so that we can show the file dialog (which requires\r\n\t// cchPrefix for the automatic name generation) as soon as possible\r\n\tphsctx->status = INACTIVE;\r\n\tphsctx->hList = NULL;\r\n\tHashCalcPrepare(phsctx);\r\n\r\n\t// Get a file name from the user\r\n\tZeroMemory(&phsctx->ofn, sizeof(phsctx->ofn));\r\n\tHashCalcInitSave(phsctx);\r\n\r\n\tif (phsctx->hFileOut != INVALID_HANDLE_VALUE)\r\n\t{\r\n        BOOL bDeletionFailed = TRUE;\r\n\t\tif (phsctx->hList = SLCreateEx(TRUE))\r\n\t\t{\r\n            bDeletionFailed = ! DialogBoxParam(\r\n\t\t\t\tg_hModThisDll,\r\n\t\t\t\tMAKEINTRESOURCE(IDD_HASHSAVE),\r\n\t\t\t\tNULL,\r\n\t\t\t\tHashSaveDlgProc,\r\n\t\t\t\t(LPARAM)phsctx\r\n\t\t\t);\r\n\r\n\t\t\tSLRelease(phsctx->hList);\r\n\t\t}\r\n\r\n\t\tCloseHandle(phsctx->hFileOut);\r\n\r\n        // Should only happen on Windows XP\r\n        if (bDeletionFailed)\r\n            DeleteFile(phsctx->ofn.lpstrFile);\r\n\t}\r\n\r\n\t// This must be the last thing that we free, since this is what supports\r\n\t// our context!\r\n\tSLRelease(phsctx->hListRaw);\r\n\r\n\t// Clean up the manifest activation and release our host\r\n\tDeactivateManifest(uActCtxCookie);\r\n\tHostRelease(uHostCookie);\r\n\r\n\tInterlockedDecrement(&g_cRefThisDll);\r\n\treturn(0);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tWorker thread\r\n\\*============================================================================*/\r\n\r\nVOID __fastcall HashSaveWorkerMain( PHASHSAVECONTEXT phsctx )\r\n{\r\n\t// Note that ALL message communication to and from the main window MUST\r\n\t// be asynchronous, or else there may be a deadlock.\r\n\r\n\t// Prep: expand directories, max path, etc. (prefix was set by earlier call)\r\n\tPostMessage(phsctx->hWnd, HM_WORKERTHREAD_TOGGLEPREP, (WPARAM)phsctx, TRUE);\r\n\tif (! HashCalcPrepare(phsctx))\r\n        return;\r\n    HashCalcSetSaveFormat(phsctx);\r\n\tPostMessage(phsctx->hWnd, HM_WORKERTHREAD_TOGGLEPREP, (WPARAM)phsctx, FALSE);\r\n\r\n    // Extract the slist into a vector for parallel_for_each\r\n    std::vector<PHASHSAVEITEM> vecpItems;\r\n    vecpItems.resize(phsctx->cTotal + 1);\r\n    SLBuildIndex(phsctx->hList, (PVOID*)vecpItems.data());\r\n    assert(vecpItems.back() == nullptr);\r\n    vecpItems.pop_back();\r\n    assert(vecpItems.back() != nullptr);\r\n\r\n#ifdef USE_PPL\r\n    const bool bMultithreaded = vecpItems.size() > 1 && IsSSD(vecpItems[0]->szPath);\r\n    concurrency::concurrent_vector<void*> vecBuffers;  // a vector of all allocated read buffers (one per thread)\r\n    DWORD dwBufferTlsIndex = TlsAlloc();               // TLS index of the current thread's read buffer\r\n    if (dwBufferTlsIndex == TLS_OUT_OF_INDEXES)\r\n        return;\r\n#else\r\n    constexpr bool bMultithreaded = false;\r\n#endif\r\n\r\n    PBYTE pbTheBuffer;  // file read buffer, used iff not multithreaded\r\n    if (! bMultithreaded)\r\n    {\r\n        pbTheBuffer = (PBYTE)VirtualAlloc(NULL, READ_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);\r\n        if (pbTheBuffer == NULL)\r\n            return;\r\n    }\r\n\r\n    // Initialize the progress bar update synchronization vars\r\n    CRITICAL_SECTION updateCritSec;\r\n    volatile ULONGLONG cbCurrentMaxSize = 0;\r\n    if (bMultithreaded)\r\n        InitializeCriticalSection(&updateCritSec);\r\n\r\n#ifdef _TIMED\r\n    DWORD dwStarted;\r\n    dwStarted = GetTickCount();\r\n#endif\r\n\r\n    class CanceledException {};\r\n\r\n    // concurrency::parallel_for_each(vecpItems.cbegin(), vecpItems.cend(), ...\r\n    auto per_file_worker = [&](PHASHSAVEITEM pItem)\r\n\t{\r\n        WHCTXEX whctx;\r\n\r\n        // Indicate which hash type we are after, see WHEX... values in WinHash.h\r\n        whctx.dwFlags = 1 << (phsctx->ofn.nFilterIndex - 1);\r\n\r\n        PBYTE pbBuffer;\r\n#ifdef USE_PPL\r\n        if (bMultithreaded)\r\n        {\r\n            // Allocate or retrieve the already-allocated read buffer for the current thread\r\n            pbBuffer = (PBYTE)TlsGetValue(dwBufferTlsIndex);\r\n            if (pbBuffer == NULL)\r\n            {\r\n                pbBuffer = (PBYTE)VirtualAlloc(NULL, READ_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);\r\n                if (pbBuffer == NULL)\r\n                    throw CanceledException();\r\n                // Cache the read buffer for the current thread\r\n                vecBuffers.push_back(pbBuffer);\r\n                TlsSetValue(dwBufferTlsIndex, pbBuffer);\r\n            }\r\n        }\r\n#endif\r\n\r\n#pragma warning(push)\r\n#pragma warning(disable: 4700 4703)  // potentially uninitialized local pointer variable 'pbBuffer' used\r\n\t\t// Get the hash\r\n\t\tWorkerThreadHashFile(\r\n\t\t\t(PCOMMONCONTEXT)phsctx,\r\n\t\t\tpItem->szPath,\r\n\t\t\t&whctx,\r\n\t\t\t&pItem->results,\r\n            bMultithreaded ? pbBuffer : pbTheBuffer,\r\n\t\t\tNULL, 0,\r\n            bMultithreaded ? &updateCritSec : NULL, &cbCurrentMaxSize\r\n#ifdef _TIMED\r\n          , &pItem->dwElapsed\r\n#endif\r\n        );\r\n\r\n        if (phsctx->status == PAUSED)\r\n            WaitForSingleObject(phsctx->hUnpauseEvent, INFINITE);\r\n\t\tif (phsctx->status == CANCEL_REQUESTED)\r\n            throw CanceledException();\r\n\r\n\t\t// Write the data\r\n\t\tHashCalcWriteResult(phsctx, pItem);\r\n\r\n\t\t// Update the UI\r\n\t\tInterlockedIncrement(&phsctx->cSentMsgs);\r\n\t\tPostMessage(phsctx->hWnd, HM_WORKERTHREAD_UPDATE, (WPARAM)phsctx, (LPARAM)pItem);\r\n    };\r\n#pragma warning(pop)\r\n\r\n    try\r\n    {\r\n#ifdef USE_PPL\r\n        if (bMultithreaded)\r\n            concurrency::parallel_for_each(vecpItems.cbegin(), vecpItems.cend(), per_file_worker);\r\n        else\r\n#endif\r\n            std::for_each(vecpItems.cbegin(), vecpItems.cend(), per_file_worker);\r\n    }\r\n    catch (CanceledException) {}  // ignore cancellation requests\r\n\r\n#ifdef _TIMED\r\n    if (phsctx->cTotal > 1 && phsctx->status != CANCEL_REQUESTED)\r\n    {\r\n        union {\r\n            CHAR  szA[MAX_STRINGMSG];\r\n            WCHAR szW[MAX_STRINGMSG];\r\n        } buffer;\r\n        size_t cbBufferLeft;\r\n        if (phsctx->opt.dwSaveEncoding == 1)  // UTF-16\r\n        {\r\n            StringCbPrintfExW(buffer.szW, sizeof(buffer), NULL, &cbBufferLeft, 0, L\"; Total elapsed: %d ms\\r\\n\", GetTickCount() - dwStarted);\r\n        }\r\n        else                                  // UTF-8 or ANSI\r\n        {\r\n            StringCbPrintfExA(buffer.szA, sizeof(buffer), NULL, &cbBufferLeft, 0,  \"; Total elapsed: %d ms\\r\\n\", GetTickCount() - dwStarted);\r\n        }\r\n        DWORD dwUnused;\r\n        WriteFile(phsctx->hFileOut, buffer.szA, (DWORD) (sizeof(buffer) - cbBufferLeft), &dwUnused, NULL);\r\n    }\r\n#endif\r\n\r\n#ifdef USE_PPL\r\n    if (bMultithreaded)\r\n    {\r\n        for (void* pBuffer : vecBuffers)\r\n            VirtualFree(pBuffer, 0, MEM_RELEASE);\r\n        DeleteCriticalSection(&updateCritSec);\r\n    }\r\n    else\r\n#endif\r\n        VirtualFree(pbTheBuffer, 0, MEM_RELEASE);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog general\r\n\\*============================================================================*/\r\n\r\nINT_PTR CALLBACK HashSaveDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\r\n{\r\n\tPHASHSAVECONTEXT phsctx;\r\n\r\n\tswitch (uMsg)\r\n\t{\r\n\t\tcase WM_INITDIALOG:\r\n\t\t{\r\n\t\t\tphsctx = (PHASHSAVECONTEXT)lParam;\r\n\r\n\t\t\t// Associate the window with the context and vice-versa\r\n\t\t\tphsctx->hWnd = hWnd;\r\n\t\t\tSetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)phsctx);\r\n\r\n\t\t\tSetAppIDForWindow(hWnd, TRUE);\r\n\r\n\t\t\tHashSaveDlgInit(phsctx);\r\n\r\n\t\t\tphsctx->pfnWorkerMain = (PFNWORKERMAIN)HashSaveWorkerMain;\r\n\t\t\tphsctx->hThread = CreateThreadCRT(NULL, phsctx);\r\n\r\n\t\t\tif (!phsctx->hThread)\r\n\t\t\t{\r\n\t\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phsctx);\r\n                BOOL bDeleted = HashCalcDeleteFileByHandle(phsctx->hFileOut);\r\n\t\t\t\tEndDialog(hWnd, bDeleted);\r\n\t\t\t}\r\n            if (WaitForSingleObject(phsctx->hThread, 1000) != WAIT_TIMEOUT)\r\n            {\r\n                WorkerThreadCleanup((PCOMMONCONTEXT)phsctx);\r\n                EndDialog(hWnd, TRUE);\r\n            }\r\n\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase WM_DESTROY:\r\n\t\t{\r\n\t\t\tSetAppIDForWindow(hWnd, FALSE);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_ENDSESSION:\r\n        {\r\n            if (wParam == FALSE)  // if TRUE, fall through to WM_CLOSE\r\n                break;\r\n        }\r\n\t\tcase WM_CLOSE:\r\n\t\t{\r\n\t\t\tphsctx = (PHASHSAVECONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\t\t\tgoto cleanup_and_exit;\r\n\t\t}\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t{\r\n\t\t\tphsctx = (PHASHSAVECONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\tswitch (LOWORD(wParam))\r\n\t\t\t{\r\n\t\t\t\tcase IDC_PAUSE:\r\n\t\t\t\t{\r\n\t\t\t\t\tWorkerThreadTogglePause((PCOMMONCONTEXT)phsctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_CANCEL:\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup_and_exit:\r\n\t\t\t\t\tphsctx->dwFlags |= HCF_EXIT_PENDING;\r\n\t\t\t\t\tWorkerThreadStop((PCOMMONCONTEXT)phsctx);\r\n\t\t\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phsctx);\r\n\r\n                    // Don't keep partially generated checksum files\r\n                    BOOL bDeleted = HashCalcDeleteFileByHandle(phsctx->hFileOut);\r\n\r\n\t\t\t\t\tEndDialog(hWnd, bDeleted);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_TIMER:\r\n\t\t{\r\n\t\t\t// Vista: Workaround to fix their buggy progress bar\r\n\t\t\tKillTimer(hWnd, TIMER_ID_PAUSE);\r\n\t\t\tphsctx = (PHASHSAVECONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\t\t\tif (phsctx->status == PAUSED)\r\n\t\t\t\tSetProgressBarPause((PCOMMONCONTEXT)phsctx, PBST_PAUSED);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_DONE:\r\n\t\t{\r\n\t\t\tphsctx = (PHASHSAVECONTEXT)wParam;\r\n\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phsctx);\r\n\t\t\tEndDialog(hWnd, TRUE);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_UPDATE:\r\n\t\t{\r\n\t\t\tphsctx = (PHASHSAVECONTEXT)wParam;\r\n\t\t\t++phsctx->cHandledMsgs;\r\n\t\t\tSendMessage(phsctx->hWndPBTotal, PBM_SETPOS, phsctx->cHandledMsgs, 0);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_TOGGLEPREP:\r\n\t\t{\r\n\t\t\tHashCalcTogglePrep((PHASHSAVECONTEXT)wParam, (BOOL)lParam);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(FALSE);\r\n}\r\n\r\nVOID WINAPI HashSaveDlgInit( PHASHSAVECONTEXT phsctx )\r\n{\r\n\tHWND hWnd = phsctx->hWnd;\r\n\r\n\t// Load strings\r\n\t{\r\n\t\tSetControlText(hWnd, IDC_PAUSE, IDS_HS_PAUSE);\r\n\t\tSetControlText(hWnd, IDC_CANCEL, IDS_HS_CANCEL);\r\n\t}\r\n\r\n\t// Set the window icon and title\r\n\t{\r\n\t\tPTSTR pszFileName = phsctx->ofn.lpstrFile + phsctx->ofn.nFileOffset;\r\n\t\tTCHAR szFormat[MAX_STRINGRES];\r\n\t\tLoadString(g_hModThisDll, IDS_HS_TITLE_FMT, szFormat, countof(szFormat));\r\n\t\tStringCchPrintf(phsctx->scratch.sz, countof(phsctx->scratch.sz), szFormat, pszFileName);\r\n\r\n\t\tSendMessage(\r\n\t\t\thWnd,\r\n\t\t\tWM_SETTEXT,\r\n\t\t\t0,\r\n\t\t\t(LPARAM)phsctx->scratch.sz\r\n\t\t);\r\n\r\n\t\tSendMessage(\r\n\t\t\thWnd,\r\n\t\t\tWM_SETICON,\r\n\t\t\tICON_BIG, // No need to explicitly set the small icon\r\n\t\t\t(LPARAM)LoadIcon(g_hModThisDll, MAKEINTRESOURCE(IDI_FILETYPE))\r\n\t\t);\r\n\t}\r\n\r\n\t// Initialize miscellaneous stuff\r\n\t{\r\n\t\tphsctx->dwFlags = 0;\r\n\t\tphsctx->cTotal = 0;\r\n        phsctx->hThread = NULL;\r\n        phsctx->hUnpauseEvent = NULL;\r\n    }\r\n}\r\n"
        },
        {
          "name": "HashVerify.cpp",
          "type": "blob",
          "size": 42.271484375,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"HashCheckCommon.h\"\r\n#include \"SetAppID.h\"\r\n#include \"UnicodeHelpers.h\"\r\n#include \"IsSSD.h\"\r\n#include <uxtheme.h>\r\n#include <Strsafe.h>\r\n#include <cassert>\r\n#include <algorithm>\r\n#ifdef USE_PPL\r\n#include <ppl.h>\r\n#include <concurrent_vector.h>\r\n#endif\r\n\r\n#define HV_COL_FILENAME 0\r\n#define HV_COL_SIZE     1\r\n#define HV_COL_STATUS   2\r\n#define HV_COL_EXPECTED 3\r\n#define HV_COL_ACTUAL   4\r\n#define HV_COL_FIRST    HV_COL_FILENAME\r\n#define HV_COL_LAST     HV_COL_ACTUAL\r\n\r\n#define HV_STATUS_NULL       0\r\n#define HV_STATUS_MATCH      1\r\n#define HV_STATUS_MISMATCH   2\r\n#define HV_STATUS_UNREADABLE 3\r\n\r\n#define LISTVIEW_EXSTYLES ( LVS_EX_HEADERDRAGDROP | \\\r\n                            LVS_EX_FULLROWSELECT  | \\\r\n                            LVS_EX_LABELTIP       | \\\r\n                            LVS_EX_DOUBLEBUFFER )\r\n\r\n// Fix up missing A/W aliases\r\n#ifdef UNICODE\r\n#define LPNMLVDISPINFO LPNMLVDISPINFOW\r\n#define StrCmpLogical StrCmpLogicalW\r\n#else\r\n#define LPNMLVDISPINFO LPNMLVDISPINFOA\r\n#define StrCmpLogical StrCmpIA\r\n#endif\r\n\r\n// Due to the stupidity of the x64 compiler, the code emitted for the non-inline\r\n// function is not as efficient as it is on x86\r\n#ifdef _M_IX86\r\n#undef SSChainNCpy2\r\n#define SSChainNCpy2 SSChainNCpy2F\r\n#endif\r\n\r\ntypedef struct {\r\n\tUINT               cMatch;       // number of matches\r\n\tUINT               cMismatch;    // number of mismatches\r\n\tUINT               cUnreadable;  // number of unreadable files\r\n} HASHVERIFYPREV, *PHASHVERIFYPREV;\r\n\r\ntypedef struct {\r\n\tINT                iColumn;      // column to sort\r\n\tBOOL               bReverse;     // reverse sort?\r\n} HASHVERIFYSORT, *PHASHVERIFYSORT;\r\n\r\ntypedef struct {\r\n\tFILESIZE           filesize;\r\n\tPTSTR              pszDisplayName;\r\n\tPTSTR              pszExpected;\r\n\tINT16              cchDisplayName;\r\n\tINT                nListviewIndex;\r\n\tBOOL               bBeenSeen;    // has the listview control asked for this item's info yet?\r\n\tUINT8              uState;\r\n\tUINT8              uStatusID;\r\n\tTCHAR              szActual[MAX_DIGEST_STRING_LENGTH];\r\n} HASHVERIFYITEM, *PHASHVERIFYITEM, *PHVITEM, **PPHVITEM;\r\n\r\ntypedef CONST HASHVERIFYITEM **PPCHVITEM;\r\n\r\ntypedef struct {\r\n\t// Common block (see COMMONCONTEXT)\r\n\tWORKERTHREADSTATUS status;       // thread status\r\n\tDWORD              dwFlags;      // misc. status flags\r\n\tMSGCOUNT           cSentMsgs;    // number update messages sent by the worker\r\n\tMSGCOUNT           cHandledMsgs; // number update messages processed by the UI\r\n\tHWND               hWnd;         // handle of the dialog window\r\n\tHWND               hWndPBTotal;  // cache of the IDC_PROG_TOTAL progress bar handle\r\n\tHWND               hWndPBFile;   // cache of the IDC_PROG_FILE progress bar handle\r\n\tHANDLE             hThread;      // handle of the worker thread\r\n\tHANDLE             hUnpauseEvent;// handle of the event which signals when unpaused\r\n\tPFNWORKERMAIN      pfnWorkerMain;// worker function executed by the (non-GUI) thread\r\n\t// Members specific to HashVerify\r\n\tHWND               hWndList;     // handle of the list\r\n\tHSIMPLELIST        hList;        // where we store all the data\r\n\tPPHVITEM           index;        // index of the items in the list\r\n\tPTSTR              pszPath;      // raw path, set by initial input\r\n\tPTSTR              pszFileData;  // raw file data, set by initial input\r\n\tHASHVERIFYSORT     sort;         // sort information\r\n\tBOOL               bFreshStates; // is our copy of the item states fresh?\r\n\tUINT               cTotal;       // total number of files\r\n\tUINT               cMatch;       // number of matches\r\n\tUINT               cMismatch;    // number of mismatches\r\n\tUINT               cUnreadable;  // number of unreadable files\r\n\tDWORD              dwStarted;    // GetTickCount() start time\r\n\tHASHVERIFYPREV     prev;         // previous update data, used for update coalescing\r\n\tUINT               uMaxBatch;    // maximum number of updates to coalesce\r\n    volatile DWORD     whctxFlags;   // WinHash library dwFlags (which checksums to use)\r\n\tTCHAR              szStatus[4][MAX_STRINGRES];\r\n} HASHVERIFYCONTEXT, *PHASHVERIFYCONTEXT;\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tFunction declarations\r\n\\*============================================================================*/\r\n\r\n// Data parsing functions\r\n__forceinline PBYTE WINAPI HashVerifyLoadData( PHASHVERIFYCONTEXT phvctx );\r\nVOID WINAPI HashVerifyParseData( PHASHVERIFYCONTEXT phvctx );\r\nBOOL WINAPI ValidateHexSequence( PTSTR psz, UINT cch );\r\n\r\n// Worker thread\r\nVOID __fastcall HashVerifyWorkerMain( PHASHVERIFYCONTEXT phvctx );\r\n\r\n// Dialog general\r\nINT_PTR CALLBACK HashVerifyDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );\r\nVOID WINAPI HashVerifyDlgInit( PHASHVERIFYCONTEXT phvctx );\r\n\r\n// Dialog status\r\nVOID WINAPI HashVerifyUpdateSummary( PHASHVERIFYCONTEXT phvctx, PHASHVERIFYITEM pItem );\r\n\r\n// List management\r\n__forceinline VOID WINAPI HashVerifyListInfo( PHASHVERIFYCONTEXT phvctx, LPNMLVDISPINFO pdi );\r\n__forceinline LONG_PTR WINAPI HashVerifySetColor( PHASHVERIFYCONTEXT phvctx, LPNMLVCUSTOMDRAW pcd );\r\n__forceinline LONG_PTR WINAPI HashVerifyFindItem( PHASHVERIFYCONTEXT phvctx, LPNMLVFINDITEM pfi );\r\n__forceinline VOID WINAPI HashVerifySortColumn( PHASHVERIFYCONTEXT phvctx, LPNMLISTVIEW plv );\r\n__forceinline VOID WINAPI HashVerifyReadStates( PHASHVERIFYCONTEXT phvctx );\r\n__forceinline VOID WINAPI HashVerifySetStates( PHASHVERIFYCONTEXT phvctx );\r\nINT __cdecl HashVerifySortCompare( PHASHVERIFYCONTEXT phvctx, PPCHVITEM ppItemA, PPCHVITEM ppItemB );\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tEntry points / main functions\r\n\\*============================================================================*/\r\n\r\nVOID CALLBACK HashVerify_RunDLLW( HWND hWnd, HINSTANCE hInstance,\r\n                                  PWSTR pszCmdLine, INT nCmdShow )\r\n{\r\n\tSIZE_T cchPath = SSLenW(pszCmdLine) + 1;\r\n\tPTSTR pszPath;\r\n\r\n\t// HashVerifyThread will try to free the path passed to it, as it expects\r\n\t// it to be allocated by malloc; it also expects g_cRefThisDll to be\r\n\t// incremented by the caller.\r\n\r\n\tif (pszPath = (PTSTR)malloc(cchPath * sizeof(TCHAR)))\r\n\t{\r\n\t\tif (WStrToTStr(pszCmdLine, pszPath, (UINT)cchPath))\r\n\t\t{\r\n\t\t\t++g_cRefThisDll;\r\n\t\t\tHashVerifyThread(pszPath);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfree(pszPath);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDWORD WINAPI HashVerifyThread( PTSTR pszPath )\r\n{\r\n\t// We will need to free the memory allocated for the data when done\r\n\tPBYTE pbRawData;\r\n\r\n\t// First, activate our manifest and AddRef our host\r\n\tULONG_PTR uActCtxCookie = ActivateManifest(TRUE);\r\n\tULONG_PTR uHostCookie = HostAddRef();\r\n\r\n\t// Allocate the context data that will persist across this session\r\n\tHASHVERIFYCONTEXT hvctx;\r\n\r\n\t// It's important that we zero the memory since an initial value of zero is\r\n\t// assumed for many of the elements\r\n\tZeroMemory(&hvctx, sizeof(hvctx));\r\n\r\n\t// Prep the path\r\n\tHCNormalizeString(pszPath);\r\n\tStrTrim(pszPath, TEXT(\" \"));\r\n\thvctx.pszPath = pszPath;\r\n\r\n\t// Load the raw data\r\n\tpbRawData = HashVerifyLoadData(&hvctx);\r\n\r\n\tif (hvctx.pszFileData && (hvctx.hList = SLCreateEx(TRUE)))\r\n\t{\r\n\t\tHashVerifyParseData(&hvctx);\r\n\r\n\t\tDialogBoxParam(\r\n\t\t\tg_hModThisDll,\r\n\t\t\tMAKEINTRESOURCE(IDD_HASHVERF),\r\n\t\t\tNULL,\r\n\t\t\tHashVerifyDlgProc,\r\n\t\t\t(LPARAM)&hvctx\r\n\t\t);\r\n\r\n\t\tSLRelease(hvctx.hList);\r\n\t}\r\n\telse if (*pszPath)\r\n\t{\r\n\t\t// Technically, we could reach this point by either having a file read\r\n\t\t// error or a memory allocation error, but I really don't feel like\r\n\t\t// doing separate messages for what are supposed to be rare edge cases.\r\n\t\tTCHAR szFormat[MAX_STRINGRES], szMessage[0x100];\r\n\t\tLoadString(g_hModThisDll, IDS_HV_LOADERROR_FMT, szFormat, countof(szFormat));\r\n\t\tStringCchPrintf(szMessage, countof(szMessage), szFormat, pszPath);\r\n\t\tMessageBox(NULL, szMessage, NULL, MB_OK | MB_ICONERROR);\r\n\t}\r\n\r\n\tfree(pbRawData);\r\n\tfree(pszPath);\r\n\r\n\t// Clean up the manifest activation and release our host\r\n\tDeactivateManifest(uActCtxCookie);\r\n\tHostRelease(uHostCookie);\r\n\r\n\tInterlockedDecrement(&g_cRefThisDll);\r\n\treturn(0);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tData parsing functions\r\n\\*============================================================================*/\r\n\r\nPBYTE WINAPI HashVerifyLoadData( PHASHVERIFYCONTEXT phvctx )\r\n{\r\n\tPBYTE pbRawData = NULL;\r\n\tHANDLE hFile;\r\n\r\n\tif ((hFile = OpenFileForReading(phvctx->pszPath)) != INVALID_HANDLE_VALUE)\r\n\t{\r\n\t\tLARGE_INTEGER cbRawData;\r\n\t\tDWORD cbBytesRead;\r\n\r\n\t\tif ( (GetFileSizeEx(hFile, &cbRawData)) &&\r\n\t\t     (pbRawData = (PBYTE)malloc(cbRawData.LowPart + sizeof(DWORD))) &&\r\n\t\t     (ReadFile(hFile, pbRawData, cbRawData.LowPart, &cbBytesRead, NULL)) &&\r\n\t\t     (cbRawData.LowPart == cbBytesRead) )\r\n\t\t{\r\n\t\t\t// When we allocated a block of memory for the file data, we\r\n\t\t\t// reserved a DWORD at the end for NULL termination and to serve as\r\n\t\t\t// the extra buffer needed by IsTextUTF8...\r\n\t\t\t*((UPDWORD)(pbRawData + cbRawData.LowPart)) = 0;\r\n\r\n\t\t\t// Prepare the data for the parser...\r\n\t\t\tphvctx->pszFileData = BufferToWStr(&pbRawData, cbRawData.LowPart);\r\n\t\t\tHCNormalizeString(phvctx->pszFileData);\r\n\t\t}\r\n\r\n\t\tCloseHandle(hFile);\r\n\t}\r\n\r\n\treturn(pbRawData);\r\n}\r\n\r\nVOID WINAPI HashVerifyParseData( PHASHVERIFYCONTEXT phvctx )\r\n{\r\n\tPTSTR pszData = phvctx->pszFileData;  // Points to the next line to process\r\n\r\n\tUINT cchChecksum;             // Expected length of the checksum in TCHARs\r\n\tBOOL bReverseFormat = FALSE;  // TRUE if using SFV's format of putting the checksum last\r\n\tBOOL bLinesRemaining = TRUE;  // TRUE if we have not reached the end of the data\r\n\r\n\t// Try to determine the file type from the extension\r\n\t{\r\n\t\tPTSTR pszExt = StrRChr(phvctx->pszPath, NULL, TEXT('.'));\r\n\r\n\t\tif (pszExt)\r\n\t\t{\r\n            do  // loops once; only here so there's something to break out of\r\n            {\r\n#define HASH_VERIFY_EXT_TYPE(alg)                           \\\r\n                if (StrCmpI(pszExt, HASH_EXT_##alg) == 0)   \\\r\n                {                                           \\\r\n                    phvctx->whctxFlags = WHEX_CHECK##alg;   \\\r\n                    cchChecksum = alg##_DIGEST_LENGTH * 2;  \\\r\n                    break;                                  \\\r\n                }\r\n                FOR_EACH_HASH(HASH_VERIFY_EXT_TYPE)\r\n            } while (FALSE);\r\n\r\n            // Special case for CRC-32\r\n            if (phvctx->whctxFlags == WHEX_CHECKCRC32)\r\n\t\t\t\tbReverseFormat = TRUE;\r\n\t\t}\r\n\t}\r\n\r\n\twhile (bLinesRemaining)\r\n\t{\r\n\t\tPTSTR pszStartOfLine;  // First non-whitespace character of the line\r\n\t\tPTSTR pszEndOfLine;    // Last non-whitespace character of the line\r\n\t\tPTSTR pszChecksum = NULL, pszFileName = NULL;\r\n\t\tINT16 cchPath;         // This INCLUDES the NULL terminator!\r\n\r\n\t\t// Step 1: Isolate the current line as a NULL-terminated string\r\n\t\t{\r\n\t\t\tpszStartOfLine = pszData;\r\n\r\n\t\t\t// Find the end of the line\r\n\t\t\twhile (*pszData && *pszData != TEXT('\\n'))\r\n\t\t\t\t++pszData;\r\n\r\n\t\t\t// Terminate it if necessary, otherwise flag the end of the data\r\n\t\t\tif (*pszData)\r\n\t\t\t\t*pszData = 0;\r\n\t\t\telse\r\n\t\t\t\tbLinesRemaining = FALSE;\r\n\r\n\t\t\tpszEndOfLine = pszData;\r\n\r\n\t\t\t// Strip spaces from the end of the line...\r\n\t\t\twhile (--pszEndOfLine >= pszStartOfLine && *pszEndOfLine == TEXT(' '))\r\n\t\t\t\t*pszEndOfLine = 0;\r\n\r\n\t\t\t// ...and from the start of the line\r\n\t\t\twhile (*pszStartOfLine == TEXT(' '))\r\n\t\t\t\t++pszStartOfLine;\r\n\r\n\t\t\t// Skip past this line's terminator; point at the remaining data\r\n\t\t\t++pszData;\r\n\t\t}\r\n\r\n\t\t// Step 2a: Parse the line as SFV\r\n\t\tif (bReverseFormat)\r\n\t\t{\r\n\t\t\tpszEndOfLine -= 7;\r\n\r\n\t\t\tif (pszEndOfLine > pszStartOfLine && ValidateHexSequence(pszEndOfLine, 8))\r\n\t\t\t{\r\n\t\t\t\tpszChecksum = pszEndOfLine;\r\n\r\n\t\t\t\t// Trim spaces between the checksum and the file name\r\n\t\t\t\twhile (--pszEndOfLine >= pszStartOfLine && *pszEndOfLine == TEXT(' '))\r\n\t\t\t\t\t*pszEndOfLine = 0;\r\n\r\n\t\t\t\t// Lines that begin with ';' are comments in SFV\r\n\t\t\t\tif (*pszStartOfLine && *pszStartOfLine != TEXT(';'))\r\n\t\t\t\t\tpszFileName = pszStartOfLine;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Step 2b: All other file formats\r\n\t\telse\r\n\t\t{\r\n\t\t\t// If we do not know the type yet, make a stab at detecting it\r\n\t\t\tif (phvctx->whctxFlags == 0)\r\n\t\t\t{\r\n\t\t\t\t// 32-bit algorithms (8-byte)\r\n\t\t\t\tif (ValidateHexSequence(pszStartOfLine, 8))\r\n\t\t\t\t{\r\n\t\t\t\t\tcchChecksum = 8;\r\n\t\t\t\t\tphvctx->whctxFlags = WHEX_ALL32;  // WHEX_CHECKCRC32\r\n\t\t\t\t}\r\n\t\t\t\t// 128-bit algorithms (32-byte)\r\n\t\t\t\telse if (ValidateHexSequence(pszStartOfLine, 32))\r\n\t\t\t\t{\r\n\t\t\t\t\tcchChecksum = 32;\r\n\t\t\t\t\tphvctx->whctxFlags = WHEX_ALL128;  // WHEX_CHECKMD5\r\n\t\t\t\t}\r\n\t\t\t\t// 160-bit algorithms (40-byte)\r\n\t\t\t\telse if (ValidateHexSequence(pszStartOfLine, 40))\r\n\t\t\t\t{\r\n\t\t\t\t\tcchChecksum = 40;\r\n\t\t\t\t\tphvctx->whctxFlags = WHEX_ALL160;  // WHEX_CHECKSHA1\r\n\t\t\t\t}\r\n\t\t\t\t// 256-bit algorithms (64-byte)\r\n\t\t\t\telse if (ValidateHexSequence(pszStartOfLine, 64))\r\n\t\t\t\t{\r\n\t\t\t\t\tcchChecksum = 64;\r\n\t\t\t\t\tphvctx->whctxFlags = WHEX_ALL256;  // WHEX_CHECKSHA256 | WHEX_CHECKSHA3_256\r\n\t\t\t\t}\r\n\t\t\t\t// 512-bit algorithms (128-byte)\r\n\t\t\t\telse if (ValidateHexSequence(pszStartOfLine, 128))\r\n\t\t\t\t{\r\n\t\t\t\t\tcchChecksum = 128;\r\n\t\t\t\t\tphvctx->whctxFlags = WHEX_ALL512;  // WHEX_CHECKSHA512 | WHEX_CHECKSHA3_512\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Parse the line\r\n\t\t\tif ( phvctx->whctxFlags && pszEndOfLine > pszStartOfLine + cchChecksum &&\r\n\t\t\t     ValidateHexSequence(pszStartOfLine, cchChecksum) )\r\n\t\t\t{\r\n\t\t\t\tpszChecksum = pszStartOfLine;\r\n\t\t\t\tpszStartOfLine += cchChecksum + 1;\r\n\r\n\t\t\t\t// Skip over spaces between the checksum and filename\r\n\t\t\t\twhile (*pszStartOfLine == TEXT(' '))\r\n\t\t\t\t\t++pszStartOfLine;\r\n\r\n\t\t\t\tif (*pszStartOfLine)\r\n\t\t\t\t\tpszFileName = pszStartOfLine;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Step 3: Do something useful with the results\r\n\t\tif (pszFileName && (cchPath = (INT16)(pszEndOfLine + 2 - pszFileName)) > 1)\r\n\t\t{\r\n\t\t\t// Since pszEndOfLine points to the character BEFORE the terminator,\r\n\t\t\t// cchLine == 1 + pszEnd - pszStart, and then +1 for the NULL\r\n\t\t\t// terminator means that we need to add 2 TCHARs to the length\r\n\r\n\t\t\t// By treating cchPath as INT16 and checking the sign, we ensure\r\n\t\t\t// that the path does not exceed 32K.\r\n\r\n\t\t\t// Create the new data block\r\n\t\t\tPHASHVERIFYITEM pItem = (PHASHVERIFYITEM)SLAddItem(phvctx->hList, NULL, sizeof(HASHVERIFYITEM));\r\n\r\n\t\t\t// Abort if we are out of memory\r\n\t\t\tif (!pItem) break;\r\n\r\n\t\t\tpItem->filesize.ui64 = -1;\r\n\t\t\tpItem->filesize.sz[0] = 0;\r\n\t\t\tpItem->pszDisplayName = pszFileName;\r\n\t\t\tpItem->pszExpected = pszChecksum;\r\n\t\t\tpItem->cchDisplayName = cchPath;\r\n\t\t\tpItem->nListviewIndex = phvctx->cTotal;\r\n\t\t\tpItem->bBeenSeen = FALSE;\r\n\t\t\tpItem->uStatusID = HV_STATUS_NULL;\r\n\t\t\tpItem->szActual[0] = 0;\r\n\r\n\t\t\t++phvctx->cTotal;\r\n\r\n\t\t} // If the current line was found to be valid\r\n\r\n\t} // Loop until there are no lines left\r\n\r\n\t// Build the index\r\n\tif ( phvctx->cTotal && (phvctx->index =\r\n\t     (PPHVITEM)SLSetContextSize(phvctx->hList, phvctx->cTotal * sizeof(PHVITEM))) )\r\n\t{\r\n\t\tSLBuildIndex(phvctx->hList, (PVOID*)phvctx->index);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tphvctx->cTotal = 0;\r\n\t}\r\n}\r\n\r\nBOOL WINAPI ValidateHexSequence( PTSTR psz, UINT cch )\r\n{\r\n\t// Check that the given hex string matches /[0-9A-Fa-f]{cch}\\b/, and if it\r\n\t// does, convert to lower-case and NULL-terminate it.\r\n\r\n\twhile (cch)\r\n\t{\r\n\t\tTCHAR ch = *psz;\r\n\r\n\t\tif (ch < TEXT('0'))\r\n\t\t{\r\n\t\t\treturn(FALSE);\r\n\t\t}\r\n\t\telse if (ch > TEXT('9'))\r\n\t\t{\r\n\t\t\tch |= 0x20; // Convert to lower-case\r\n\r\n\t\t\tif (ch < TEXT('a') || ch > TEXT('f'))\r\n\t\t\t\treturn(FALSE);\r\n\r\n\t\t\t*psz = ch;\r\n\t\t}\r\n\r\n\t\t++psz;\r\n\t\t--cch;\r\n\t}\r\n\r\n\tif (*psz == 0 || *psz == TEXT('\\n') || *psz == TEXT(' '))\r\n\t{\r\n\t\t*psz = 0;\r\n\t\treturn(TRUE);\r\n\t}\r\n\r\n\treturn(FALSE);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tWorker thread\r\n\\*============================================================================*/\r\n\r\nVOID __fastcall HashVerifyWorkerMain( PHASHVERIFYCONTEXT phvctx )\r\n{\r\n\t// Note that ALL message communication to and from the main window MUST\r\n\t// be asynchronous, or else there may be a deadlock\r\n\r\n\t// Initialize the path prefix length; used for building the full path\r\n\tPTSTR pszPathTail = StrRChr(phvctx->pszPath, NULL, TEXT('\\\\'));\r\n\tSIZE_T cchPathPrefix = (pszPathTail) ? pszPathTail + 1 - phvctx->pszPath : 0;\r\n\r\n#ifdef USE_PPL\r\n    // If the first file has an absolute path, use it for IsSSD(),\r\n    // otherwise use the checksum file itself\r\n    const bool bMultithreaded = phvctx->cTotal > 1 && IsSSD(\r\n        phvctx->index[0]->pszDisplayName[0] == TEXT('\\\\') ||\r\n        phvctx->index[0]->pszDisplayName[1] == TEXT(':') ?\r\n        phvctx->index[0]->pszDisplayName :\r\n        phvctx->pszPath);\r\n\r\n    concurrency::concurrent_vector<void*> vecBuffers;  // a vector of all allocated read buffers (one per thread)\r\n    DWORD dwBufferTlsIndex = TlsAlloc();               // TLS index of the current thread's read buffer\r\n    if (dwBufferTlsIndex == TLS_OUT_OF_INDEXES)\r\n        return;\r\n#else\r\n    constexpr bool bMultithreaded = false;\r\n#endif\r\n\r\n    PBYTE pbTheBuffer;  // filename/read buffer, used iff not multithreaded\r\n    if (! bMultithreaded)\r\n    {\r\n        pbTheBuffer = (PBYTE)VirtualAlloc(NULL, READ_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);\r\n        if (pbTheBuffer == NULL)\r\n            return;\r\n    }\r\n\r\n    // Initialize the progress bar update synchronization vars\r\n    CRITICAL_SECTION updateCritSec;\r\n    volatile ULONGLONG cbCurrentMaxSize = 0;\r\n    if (bMultithreaded)\r\n        InitializeCriticalSection(&updateCritSec);\r\n\r\n\t// We need to keep track of the thread's execution time so that we can do a\r\n\t// sound notification of completion when appropriate\r\n\tphvctx->dwStarted = GetTickCount();\r\n\r\n    class CanceledException {};\r\n\r\n    // concurrency::parallel_for_each(phvctx->index, phvctx->index + phvctx->cTotal, ...\r\n    auto per_file_worker = [&](PHASHVERIFYITEM pItem)\r\n\t{\r\n        PBYTE pbBuffer;\r\n#ifdef USE_PPL\r\n        if (bMultithreaded)\r\n        {\r\n            // Allocate or retrieve the already-allocated read buffer for the current thread\r\n            pbBuffer = (PBYTE)TlsGetValue(dwBufferTlsIndex);\r\n            if (pbBuffer == NULL)\r\n            {\r\n                pbBuffer = (PBYTE)VirtualAlloc(NULL, READ_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);\r\n                if (pbBuffer == NULL)\r\n                    throw CanceledException();\r\n                // Cache the read buffer for the current thread\r\n                vecBuffers.push_back(pbBuffer);\r\n                TlsSetValue(dwBufferTlsIndex, pbBuffer);\r\n            }\r\n        }\r\n        else\r\n#endif\r\n            pbBuffer = pbTheBuffer;\r\n\r\n\t\t// Part 1: Build the path\r\n\t\t{\r\n\t\t\tSIZE_T cchPrefix = cchPathPrefix;\r\n\r\n\t\t\t// Do not use the prefix if pszDisplayName is an absolute path\r\n\t\t\tif ( pItem->pszDisplayName[0] == TEXT('\\\\') ||\r\n\t\t\t     pItem->pszDisplayName[1] == TEXT(':') )\r\n\t\t\t{\r\n\t\t\t\tcchPrefix = 0;\r\n\t\t\t}\r\n\r\n\t\t\tSSChainNCpy2(\r\n                (PTSTR)pbBuffer,\r\n\t\t\t\tphvctx->pszPath, cchPrefix,\r\n\t\t\t\tpItem->pszDisplayName, pItem->cchDisplayName\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Part 2: Calculate the checksum(s)\r\n        WHCTXEX whctx;\r\n        WHRESULTEX whres;\r\n        whctx.dwFlags = phvctx->whctxFlags;\r\n        whres.dwFlags = 0;\r\n\t\tWorkerThreadHashFile(\r\n\t\t\t(PCOMMONCONTEXT)phvctx,\r\n            (PTSTR)pbBuffer,\r\n\t\t\t&whctx,\r\n\t\t\t&whres,\r\n            pbBuffer,\r\n\t\t\t&pItem->filesize,\r\n            pItem->nListviewIndex,\r\n            bMultithreaded ? &updateCritSec : NULL, &cbCurrentMaxSize\r\n#ifdef _TIMED\r\n          , NULL\r\n#endif\r\n        );\r\n\r\n        if (phvctx->status == PAUSED)\r\n            WaitForSingleObject(phvctx->hUnpauseEvent, INFINITE);\r\n\t\tif (phvctx->status == CANCEL_REQUESTED)\r\n            throw CanceledException();\r\n\r\n\t\t// Part 3: Do something with the results\r\n\t\tif (whres.dwFlags)\r\n\t\t{\r\n            UINT cHashes = 0;\r\n            DWORD dwMatched = 0;\r\n            PTSTR pszActual = NULL;\r\n\r\n#define HASH_VERIFY_ONE_HASH_op(alg)                                  \\\r\n            if (whres.dwFlags & WHEX_CHECK##alg)                      \\\r\n            {                                                         \\\r\n                cHashes++;                                            \\\r\n                if (! dwMatched)                                      \\\r\n                {                                                     \\\r\n                    pszActual = whres.szHex##alg;                     \\\r\n                    if (StrCmpI(pItem->pszExpected, pszActual) == 0)  \\\r\n                        dwMatched = WHEX_CHECK##alg;                  \\\r\n                }                                                     \\\r\n            }\r\n            FOR_EACH_HASH(HASH_VERIFY_ONE_HASH_op)\r\n\r\n            assert(cHashes > 0);  // should always be true since whres.dwFlags > 0\r\n            assert(pszActual);\r\n            if (dwMatched)\r\n            {\r\n                pItem->uStatusID = HV_STATUS_MATCH;\r\n                \r\n                StringCbCopy(pItem->szActual, sizeof(pItem->szActual), pszActual);\r\n                if (cHashes > 1 && phvctx->whctxFlags != dwMatched)\r\n                    phvctx->whctxFlags = dwMatched;\r\n            }\r\n            else\r\n            {\r\n                pItem->uStatusID = HV_STATUS_MISMATCH;\r\n                if (cHashes == 1)\r\n                    StringCbCopy(pItem->szActual, sizeof(pItem->szActual), pszActual);\r\n            }\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpItem->uStatusID = HV_STATUS_UNREADABLE;\r\n\t\t}\r\n\r\n\t\t// Part 4: Update the UI\r\n\t\t++phvctx->cSentMsgs;\r\n\t\tPostMessage(phvctx->hWnd, HM_WORKERTHREAD_UPDATE, (WPARAM)phvctx, (LPARAM)pItem);\r\n    };\r\n\r\n    try\r\n    {\r\n#ifdef USE_PPL\r\n        if (bMultithreaded)\r\n            concurrency::parallel_for_each(phvctx->index, phvctx->index + phvctx->cTotal, per_file_worker);\r\n        else\r\n#endif\r\n            std::for_each(phvctx->index, phvctx->index + phvctx->cTotal, per_file_worker);\r\n    }\r\n    catch (CanceledException) {}  // ignore cancellation requests\r\n\r\n#ifdef USE_PPL\r\n    if (bMultithreaded)\r\n    {\r\n        for (void* pBuffer : vecBuffers)\r\n            VirtualFree(pBuffer, 0, MEM_RELEASE);\r\n        DeleteCriticalSection(&updateCritSec);\r\n    }\r\n    else\r\n#endif\r\n        VirtualFree(pbTheBuffer, 0, MEM_RELEASE);\r\n\r\n\t// Play a sound to signal the normal, successful termination of operations,\r\n\t// but exempt operations that were nearly instantaneous\r\n\tif (phvctx->cTotal && GetTickCount() - phvctx->dwStarted >= 2000)\r\n\t\tMessageBeep(MB_ICONASTERISK);\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog general\r\n\\*============================================================================*/\r\n\r\nINT_PTR CALLBACK HashVerifyDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )\r\n{\r\n\tPHASHVERIFYCONTEXT phvctx;\r\n\r\n\tswitch (uMsg)\r\n\t{\r\n\t\tcase WM_INITDIALOG:\r\n\t\t{\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)lParam;\r\n\r\n\t\t\t// Associate the window with the context and vice-versa\r\n\t\t\tphvctx->hWnd = hWnd;\r\n\t\t\tSetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)phvctx);\r\n\r\n\t\t\tSetAppIDForWindow(hWnd, TRUE);\r\n\r\n\t\t\tHashVerifyDlgInit(phvctx);\r\n\r\n\t\t\tphvctx->pfnWorkerMain = (PFNWORKERMAIN)HashVerifyWorkerMain;\r\n\t\t\tphvctx->hThread = CreateThreadCRT(NULL, phvctx);\r\n\r\n\t\t\tif (!phvctx->hThread)\r\n\t\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phvctx);\r\n\r\n\t\t\t// Initialize the summary\r\n\t\t\tSendMessage(phvctx->hWndPBTotal, PBM_SETRANGE32, 0, phvctx->cTotal);\r\n\t\t\tHashVerifyUpdateSummary(phvctx, NULL);\r\n\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase WM_DESTROY:\r\n\t\t{\r\n\t\t\tSetAppIDForWindow(hWnd, FALSE);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_ENDSESSION:\r\n        {\r\n            if (wParam == FALSE)  // if TRUE, fall through to WM_CLOSE\r\n                break;\r\n        }\r\n\t\tcase WM_CLOSE:\r\n\t\t{\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\t\t\tgoto cleanup_and_exit;\r\n\t\t}\r\n\r\n\t\tcase WM_COMMAND:\r\n\t\t{\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\tswitch (LOWORD(wParam))\r\n\t\t\t{\r\n\t\t\t\tcase IDC_PAUSE:\r\n\t\t\t\t{\r\n\t\t\t\t\tWorkerThreadTogglePause((PCOMMONCONTEXT)phvctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_STOP:\r\n\t\t\t\t{\r\n\t\t\t\t\tWorkerThreadStop((PCOMMONCONTEXT)phvctx);\r\n\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase IDC_EXIT:\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup_and_exit:\r\n\t\t\t\t\tphvctx->dwFlags |= HCF_EXIT_PENDING;\r\n\t\t\t\t\tWorkerThreadStop((PCOMMONCONTEXT)phvctx);\r\n\t\t\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phvctx);\r\n\t\t\t\t\tEndDialog(hWnd, 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_NOTIFY:\r\n\t\t{\r\n\t\t\tLPNMHDR pnm = (LPNMHDR)lParam;\r\n\r\n\t\t\tif (pnm && pnm->idFrom == IDC_LIST)\r\n\t\t\t{\r\n\t\t\t\tphvctx = (PHASHVERIFYCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\r\n\t\t\t\tswitch (pnm->code)\r\n\t\t\t\t{\r\n\t\t\t\t\tcase LVN_GETDISPINFO:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tHashVerifyListInfo(phvctx, (LPNMLVDISPINFO)lParam);\r\n\t\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase NM_CUSTOMDRAW:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSetWindowLongPtr(hWnd, DWLP_MSGRESULT, HashVerifySetColor(phvctx, (LPNMLVCUSTOMDRAW)lParam));\r\n\t\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase LVN_ODFINDITEM:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSetWindowLongPtr(hWnd, DWLP_MSGRESULT, HashVerifyFindItem(phvctx, (LPNMLVFINDITEM)lParam));\r\n\t\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase LVN_COLUMNCLICK:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tHashVerifySortColumn(phvctx, (LPNMLISTVIEW)lParam);\r\n\t\t\t\t\t\treturn(TRUE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase LVN_ITEMCHANGED:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (((LPNMLISTVIEW)lParam)->uChanged & LVIF_STATE)\r\n\t\t\t\t\t\t\tphvctx->bFreshStates = FALSE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase LVN_ODSTATECHANGED:\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tphvctx->bFreshStates = FALSE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase WM_TIMER:\r\n\t\t{\r\n\t\t\t// Vista: Workaround to fix their buggy progress bar\r\n\t\t\tKillTimer(hWnd, TIMER_ID_PAUSE);\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)GetWindowLongPtr(hWnd, DWLP_USER);\r\n\t\t\tif (phvctx->status == PAUSED)\r\n\t\t\t\tSetProgressBarPause((PCOMMONCONTEXT)phvctx, PBST_PAUSED);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_DONE:\r\n\t\t{\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)wParam;\r\n\t\t\tWorkerThreadCleanup((PCOMMONCONTEXT)phvctx);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_UPDATE:\r\n\t\t{\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)wParam;\r\n\t\t\t++phvctx->cHandledMsgs;\r\n\t\t\tHashVerifyUpdateSummary(phvctx, (PHASHVERIFYITEM)lParam);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\r\n\t\tcase HM_WORKERTHREAD_SETSIZE:\r\n\t\t{\r\n\t\t\tphvctx = (PHASHVERIFYCONTEXT)wParam;\r\n\t\t\tassert(lParam >= 0 && (UINT)lParam < phvctx->cTotal);\r\n\t\t\tif (phvctx->index[lParam]->bBeenSeen)\r\n\t\t\t\tListView_RedrawItems(phvctx->hWndList, lParam, lParam);\r\n\t\t\treturn(TRUE);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(FALSE);\r\n}\r\n\r\nVOID WINAPI HashVerifyDlgInit( PHASHVERIFYCONTEXT phvctx )\r\n{\r\n\tHWND hWnd = phvctx->hWnd;\r\n\tUINT i;\r\n\r\n\t// Load strings\r\n\t{\r\n\t\tstatic const UINT16 arStrMap[][2] =\r\n\t\t{\r\n\t\t\t{ IDC_SUMMARY,          IDS_HV_SUMMARY    },\r\n\t\t\t{ IDC_MATCH_LABEL,      IDS_HV_MATCH      },\r\n\t\t\t{ IDC_MISMATCH_LABEL,   IDS_HV_MISMATCH   },\r\n\t\t\t{ IDC_UNREADABLE_LABEL, IDS_HV_UNREADABLE },\r\n\t\t\t{ IDC_PENDING_LABEL,    IDS_HV_PENDING    },\r\n\t\t\t{ IDC_PAUSE,            IDS_HV_PAUSE      },\r\n\t\t\t{ IDC_STOP,             IDS_HV_STOP       },\r\n\t\t\t{ IDC_EXIT,             IDS_HV_EXIT       }\r\n\t\t};\r\n\r\n\t\tfor (i = 0; i < countof(arStrMap); ++i)\r\n\t\t\tSetControlText(hWnd, arStrMap[i][0], arStrMap[i][1]);\r\n\t}\r\n\r\n\t// Set the window icon and title\r\n\t{\r\n\t\tPTSTR pszFileName = StrRChr(phvctx->pszPath, NULL, TEXT('\\\\'));\r\n\r\n\t\tif (!(pszFileName && *++pszFileName))\r\n\t\t\tpszFileName = phvctx->pszPath;\r\n\r\n\t\tSendMessage(\r\n\t\t\thWnd,\r\n\t\t\tWM_SETTEXT,\r\n\t\t\t0,\r\n\t\t\t(LPARAM)pszFileName\r\n\t\t);\r\n\r\n\t\tSendMessage(\r\n\t\t\thWnd,\r\n\t\t\tWM_SETICON,\r\n\t\t\tICON_BIG, // No need to explicitly set the small icon\r\n\t\t\t(LPARAM)LoadIcon(g_hModThisDll, MAKEINTRESOURCE(IDI_FILETYPE))\r\n\t\t);\r\n\t}\r\n\r\n\t// Initialize the list box\r\n\t{\r\n\t\ttypedef struct {\r\n\t\t\tUINT16 iStringID;\r\n\t\t\tUINT16 iAlign;\r\n\t\t\tUINT16 iWidth;\r\n\t\t} COLINFO, *PCOLINFO;\r\n\r\n\t\tstatic const COLINFO arCols[] =\r\n\t\t{\r\n\t\t\t{ IDS_HV_COL_FILENAME, LVCFMT_LEFT,  245 },\r\n\t\t\t{ IDS_HV_COL_SIZE,     LVCFMT_RIGHT,  64 },\r\n\t\t\t{ IDS_HV_COL_STATUS,   LVCFMT_CENTER, 64 },\r\n\t\t\t{ IDS_HV_COL_EXPECTED, LVCFMT_CENTER,  0 },\r\n\t\t\t{ IDS_HV_COL_ACTUAL,   LVCFMT_CENTER,  0 },\r\n\t\t};\r\n\r\n\t\t// We will be using the list window handle a lot throughout HashVerify,\r\n\t\t// so we should cache it to reduce the number of lookups\r\n\t\tphvctx->hWndList = GetDlgItem(hWnd, IDC_LIST);\r\n\r\n\t\tfor (i = 0; i < countof(arCols); ++i)\r\n\t\t{\r\n\t\t\tTCHAR szBuffer[MAX_STRINGRES];\r\n\t\t\tLVCOLUMN lvc;\r\n\t\t\tRECT rc;\r\n\r\n\t\t\tLoadString(g_hModThisDll, arCols[i].iStringID, szBuffer, countof(szBuffer));\r\n\r\n\t\t\trc.left = arCols[i].iWidth;\r\n\r\n\t\t\tif (rc.left == 0)\r\n\t\t\t{\r\n                if (phvctx->whctxFlags & WHEX_ALL512)\r\n                    rc.left = 512 + 20;\r\n                else if (phvctx->whctxFlags & WHEX_ALL256)\r\n                    rc.left = 256 + 20;\r\n                else if (phvctx->whctxFlags & WHEX_ALL160)\r\n                    rc.left = 160 + 20;\r\n                else if (phvctx->whctxFlags & WHEX_ALL128)\r\n                    rc.left = 128 + 20;\r\n                else if (phvctx->whctxFlags & WHEX_ALL32)\r\n                    rc.left =  32 + 20 + 40;  // extra size to accommodate the header labels\r\n\t\t\t}\r\n\r\n\t\t\tMapDialogRect(hWnd, &rc);\r\n\r\n\t\t\tlvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;\r\n\t\t\tlvc.fmt = arCols[i].iAlign;\r\n\t\t\tlvc.cx = rc.left;\r\n\t\t\tlvc.pszText = szBuffer;\r\n\r\n\t\t\tListView_InsertColumn(phvctx->hWndList, i, &lvc);\r\n\t\t}\r\n\r\n\t\tListView_SetExtendedListViewStyle(phvctx->hWndList, LISTVIEW_EXSTYLES);\r\n\t\tListView_SetItemCount(phvctx->hWndList, phvctx->cTotal);\r\n\r\n\t\t// Use the new-fangled list view style for Vista\r\n\t\tif (g_uWinVer >= 0x0600)\r\n\t\t\tSetWindowTheme(phvctx->hWndList, L\"Explorer\", NULL);\r\n\r\n\t\tphvctx->sort.iColumn = -1;\r\n\t}\r\n\r\n\t// Initialize the status strings\r\n\t{\r\n\t\tUINT i;\r\n\r\n\t\tfor (i = 1; i <= 3; ++i)\r\n\t\t{\r\n\t\t\tLoadString(\r\n\t\t\t\tg_hModThisDll,\r\n\t\t\t\ti + (IDS_HV_STATUS_MATCH - 1),\r\n\t\t\t\tphvctx->szStatus[i],\r\n\t\t\t\tcountof(phvctx->szStatus[i])\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Initialize miscellaneous stuff\r\n\t{\r\n\t\tphvctx->uMaxBatch = (phvctx->cTotal < (0x20 << 8)) ? 0x20 : phvctx->cTotal >> 8;\r\n\t\tphvctx->dwStarted = 0;\r\n        phvctx->hThread = NULL;\r\n        phvctx->hUnpauseEvent = NULL;\r\n\t}\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tDialog status\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashVerifyUpdateSummary( PHASHVERIFYCONTEXT phvctx, PHASHVERIFYITEM pItem )\r\n{\r\n\tHWND hWnd = phvctx->hWnd;\r\n\tTCHAR szFormat[MAX_STRINGRES], szBuffer[MAX_STRINGMSG];\r\n\r\n\t// If this is not the initial update and we are lagging, and our update\r\n\t// drought is not TOO long, then we should skip the update...\r\n    UINT cUnhandledMsgs = phvctx->cSentMsgs - phvctx->cHandledMsgs;\r\n    BOOL bUpdateUI = pItem == NULL || cUnhandledMsgs == 0 || cUnhandledMsgs > phvctx->uMaxBatch;\r\n\r\n\t// Update the list\r\n\tif (pItem)\r\n\t{\r\n\t\tswitch (pItem->uStatusID)\r\n\t\t{\r\n\t\t\tcase HV_STATUS_MATCH:\r\n\t\t\t\t++phvctx->cMatch;\r\n\t\t\t\tbreak;\r\n\t\t\tcase HV_STATUS_MISMATCH:\r\n\t\t\t\t++phvctx->cMismatch;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\t++phvctx->cUnreadable;\r\n\t\t}\r\n\r\n\t\tif (pItem->bBeenSeen)\r\n\t\t{\r\n\t\t\tListView_RedrawItems(\r\n\t\t\t\tphvctx->hWndList,\r\n\t\t\t\tpItem->nListviewIndex,\r\n\t\t\t\tpItem->nListviewIndex\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Update the counts and progress bar\r\n\tif (bUpdateUI)\r\n\t{\r\n\t\t// FormatFractionalResults expects an empty format buffer on the first call\r\n\t\tszFormat[0] = 0;\r\n\r\n\t\tif (!pItem || phvctx->prev.cMatch != phvctx->cMatch)\r\n\t\t{\r\n\t\t\tFormatFractionalResults(szFormat, szBuffer, phvctx->cMatch, phvctx->cTotal);\r\n\t\t\tSetDlgItemText(hWnd, IDC_MATCH_RESULTS, szBuffer);\r\n\t\t}\r\n\r\n\t\tif (!pItem || phvctx->prev.cMismatch != phvctx->cMismatch)\r\n\t\t{\r\n\t\t\tFormatFractionalResults(szFormat, szBuffer, phvctx->cMismatch, phvctx->cTotal);\r\n\t\t\tSetDlgItemText(hWnd, IDC_MISMATCH_RESULTS, szBuffer);\r\n\t\t}\r\n\r\n\t\tif (!pItem || phvctx->prev.cUnreadable != phvctx->cUnreadable)\r\n\t\t{\r\n\t\t\tFormatFractionalResults(szFormat, szBuffer, phvctx->cUnreadable, phvctx->cTotal);\r\n\t\t\tSetDlgItemText(hWnd, IDC_UNREADABLE_RESULTS, szBuffer);\r\n\t\t}\r\n\r\n\t\tFormatFractionalResults(szFormat, szBuffer, phvctx->cTotal - phvctx->cHandledMsgs, phvctx->cTotal);\r\n\t\tSetDlgItemText(hWnd, IDC_PENDING_RESULTS, szBuffer);\r\n\r\n\t\tSendMessage(phvctx->hWndPBTotal, PBM_SETPOS, phvctx->cHandledMsgs, 0);\r\n\r\n\t\t// Now that we've updated the UI, update the prev structure\r\n\t\tphvctx->prev.cMatch = phvctx->cMatch;\r\n\t\tphvctx->prev.cMismatch = phvctx->cMismatch;\r\n\t\tphvctx->prev.cUnreadable = phvctx->cUnreadable;\r\n\t}\r\n\r\n\t// Update the header\r\n\tif (!(phvctx->dwFlags & HVF_HAS_SET_TYPE))\r\n\t{\r\n\t\tPCTSTR pszSubtitle = NULL;\r\n\r\n\t\tswitch (phvctx->whctxFlags)\r\n\t\t{\r\n#define HASH_VERIFY_TITLE_op(alg)  \\\r\n\t\t\tcase WHEX_CHECK##alg:  pszSubtitle = HASH_NAME_##alg;  break;\r\n            FOR_EACH_HASH(HASH_VERIFY_TITLE_op)\r\n\t\t}\r\n\r\n\t\tif (pszSubtitle)\r\n\t\t{\r\n\t\t\tLoadString(g_hModThisDll, IDS_HV_SUMMARY, szFormat, countof(szFormat));\r\n#ifndef _TIMED\r\n\t\t\tStringCchPrintf(szBuffer, countof(szBuffer), TEXT(\"%s (%s)\"), szFormat, pszSubtitle);\r\n\t\t\tphvctx->dwFlags |= HVF_HAS_SET_TYPE;\r\n#else\r\n            StringCchPrintf(szBuffer, countof(szBuffer), TEXT(\"%s (%s) - %d ms\"), szFormat, pszSubtitle,\r\n                            phvctx->dwStarted ? GetTickCount() - phvctx->dwStarted : 0);\r\n#endif\r\n\t\t\tSetDlgItemText(hWnd, IDC_SUMMARY, szBuffer);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n/*============================================================================*\\\r\n\tList management\r\n\\*============================================================================*/\r\n\r\nVOID WINAPI HashVerifyListInfo( PHASHVERIFYCONTEXT phvctx, LPNMLVDISPINFO pdi )\r\n{\r\n\tif ((UINT)pdi->item.iItem >= phvctx->cTotal)\r\n\t\treturn;  // Invalid index; by casting to unsigned, we also catch negatives\r\n\r\n\tif (pdi->item.mask & LVIF_TEXT)\r\n\t{\r\n\t\tPHASHVERIFYITEM pItem = phvctx->index[pdi->item.iItem];\r\n\r\n\t\tswitch (pdi->item.iSubItem)\r\n\t\t{\r\n\t\t\tcase HV_COL_FILENAME: pdi->item.pszText = pItem->pszDisplayName;              break;\r\n\t\t\tcase HV_COL_SIZE:     pdi->item.pszText = pItem->filesize.sz;                 break;\r\n\t\t\tcase HV_COL_STATUS:   pdi->item.pszText = phvctx->szStatus[pItem->uStatusID]; break;\r\n\t\t\tcase HV_COL_EXPECTED: pdi->item.pszText = pItem->pszExpected;                 break;\r\n\t\t\tcase HV_COL_ACTUAL:   pdi->item.pszText = pItem->szActual;                    break;\r\n\t\t\tdefault:              pdi->item.pszText = TEXT(\"\");                           break;\r\n\t\t}\r\n        if (! pItem->bBeenSeen)\r\n            pItem->bBeenSeen = TRUE;\r\n\t}\r\n\r\n\tif (pdi->item.mask & LVIF_IMAGE)\r\n\t\tpdi->item.iImage = I_IMAGENONE;\r\n\r\n\t// We can (and should) ignore LVIF_STATE\r\n}\r\n\r\nLONG_PTR WINAPI HashVerifySetColor( PHASHVERIFYCONTEXT phvctx, LPNMLVCUSTOMDRAW pcd )\r\n{\r\n\tswitch (pcd->nmcd.dwDrawStage)\r\n\t{\r\n\t\tcase CDDS_PREPAINT:\r\n\t\t\treturn(CDRF_NOTIFYITEMDRAW);\r\n\r\n\t\tcase CDDS_ITEMPREPAINT:\r\n\t\t{\r\n\t\t\t// We need to determine the highlight state during the item stage\r\n\t\t\t// because this information becomes subitem-specific if we try to\r\n\t\t\t// retrieve it when we actually need it in the subitem stage\r\n\r\n\t\t\tif (g_uWinVer >= 0x0600 && IsAppThemed())\r\n\t\t\t{\r\n\t\t\t\t// Clear the highlight bit...\r\n\t\t\t\tphvctx->dwFlags &= ~HVF_ITEM_HILITE;\r\n\r\n\t\t\t\t// uItemState is buggy; if LVS_SHOWSELALWAYS is set, uItemState\r\n\t\t\t\t// will ALWAYS have the CDIS_SELECTED bit set, regardless of\r\n\t\t\t\t// whether the item is actually selected, so a more expensive\r\n\t\t\t\t// test for the LVIS_SELECTED bit is needed...\r\n\t\t\t\tif ( pcd->nmcd.uItemState & CDIS_HOT ||\r\n\t\t\t\t     ListView_GetItemState(pcd->nmcd.hdr.hwndFrom, pcd->nmcd.dwItemSpec, LVIS_SELECTED) )\r\n\t\t\t\t{\r\n\t\t\t\t\tphvctx->dwFlags |= HVF_ITEM_HILITE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn(CDRF_NOTIFYSUBITEMDRAW);\r\n\t\t}\r\n\r\n\t\tcase CDDS_ITEMPREPAINT | CDDS_SUBITEM:\r\n\t\t{\r\n\t\t\tPHASHVERIFYITEM pItem;\r\n\r\n\t\t\tif (pcd->nmcd.dwItemSpec >= phvctx->cTotal)\r\n\t\t\t\tbreak;  // Invalid index\r\n\r\n\t\t\tpItem = phvctx->index[pcd->nmcd.dwItemSpec];\r\n\r\n\t\t\t// By default, we use the default foreground and background colors\r\n\t\t\t// except when the item is a mismatch or is unreadable, in which\r\n\t\t\t// case, we change the foreground color\r\n\t\t\tswitch (pItem->uStatusID)\r\n\t\t\t{\r\n\t\t\t\tcase HV_STATUS_MISMATCH:\r\n\t\t\t\t\tpcd->clrText = RGB(0xC0, 0x00, 0x00);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase HV_STATUS_UNREADABLE:\r\n\t\t\t\t\tpcd->clrText = RGB(0x80, 0x80, 0x80);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpcd->clrText = CLR_DEFAULT;\r\n\t\t\t}\r\n\r\n\t\t\tpcd->clrTextBk = CLR_DEFAULT;\r\n\r\n\t\t\t// The status column, however, deserves special treatment\r\n\t\t\tif (pcd->iSubItem == HV_COL_STATUS)\r\n\t\t\t{\r\n\t\t\t\tif (phvctx->dwFlags & HVF_ITEM_HILITE)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Vista-style highlighting means that the foreground\r\n\t\t\t\t\t// color can show through, but not the background color\r\n\t\t\t\t\tif (pItem->uStatusID == HV_STATUS_MATCH)\r\n\t\t\t\t\t\tpcd->clrText = RGB(0x00, 0x80, 0x00);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tswitch (pItem->uStatusID)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase HV_STATUS_MATCH:\r\n\t\t\t\t\t\t\tpcd->clrText = RGB(0x00, 0x00, 0x00);\r\n\t\t\t\t\t\t\tpcd->clrTextBk = RGB(0x00, 0xE0, 0x00);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase HV_STATUS_MISMATCH:\r\n\t\t\t\t\t\t\tpcd->clrText = RGB(0xFF, 0xFF, 0xFF);\r\n\t\t\t\t\t\t\tpcd->clrTextBk = RGB(0xC0, 0x00, 0x00);\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase HV_STATUS_UNREADABLE:\r\n\t\t\t\t\t\t\tpcd->clrText = RGB(0x00, 0x00, 0x00);\r\n\t\t\t\t\t\t\tpcd->clrTextBk = RGB(0xFF, 0xE0, 0x00);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn(CDRF_DODEFAULT);\r\n}\r\n\r\nLONG_PTR WINAPI HashVerifyFindItem( PHASHVERIFYCONTEXT phvctx, LPNMLVFINDITEM pfi )\r\n{\r\n\tPHASHVERIFYITEM pItem;\r\n\tINT cchCompare, iStart = pfi->iStart;\r\n\tLONG_PTR i;\r\n\r\n\tif (pfi->lvfi.flags & (LVFI_PARAM | LVFI_NEARESTXY))\r\n\t\tgoto not_found;  // Unsupported search types\r\n\r\n\tif (!(pfi->lvfi.flags & (LVFI_PARTIAL | LVFI_STRING)))\r\n\t\tgoto not_found;  // No valid search type specified\r\n\r\n\t// According to the documentation, LVFI_STRING without a corresponding\r\n\t// LVFI_PARTIAL should match the FULL string, but when the user sends\r\n\t// keyboard input (which uses a partial match), the notification does not\r\n\t// have the LVFI_PARTIAL flag, so we should just always assume LVFI_PARTIAL\r\n\t// INT cchCompare = (pfi->lvfi.flags & LVFI_PARTIAL) ? 0 : 1;\r\n\t// cchCompare += SSLen(pfi->lvfi.psz);\r\n\t// The above code should have been correct, but it is not...\r\n\tcchCompare = (INT)SSLen(pfi->lvfi.psz);\r\n\r\n\t// Fix out-of-range indices; by casting to unsigned, we also catch negatives\r\n\tif ((UINT)iStart > phvctx->cTotal)\r\n\t\tiStart = phvctx->cTotal;\r\n\r\n\tfor (i = iStart; i < (INT)phvctx->cTotal; ++i)\r\n\t{\r\n\t\tpItem = phvctx->index[i];\r\n\t\tif (StrCmpNI(pItem->pszDisplayName, pfi->lvfi.psz, cchCompare) == 0)\r\n\t\t\treturn(i);\r\n\t}\r\n\r\n\tif (pfi->lvfi.flags & LVFI_WRAP)\r\n\t{\r\n\t\tfor (i = 0; i < iStart; ++i)\r\n\t\t{\r\n\t\t\tpItem = phvctx->index[i];\r\n\t\t\tif (StrCmpNI(pItem->pszDisplayName, pfi->lvfi.psz, cchCompare) == 0)\r\n\t\t\t\treturn(i);\r\n\t\t}\r\n\t}\r\n\r\n\tnot_found: return(-1);\r\n}\r\n\r\nVOID WINAPI HashVerifySortColumn( PHASHVERIFYCONTEXT phvctx, LPNMLISTVIEW plv )\r\n{\r\n\tif (phvctx->status != CLEANUP_COMPLETED)\r\n\t\treturn;  // Sorting is available only after the worker is done\r\n\r\n\t// Capture the current selection/focus state\r\n\tHashVerifyReadStates(phvctx);\r\n\r\n\tif (phvctx->sort.iColumn != plv->iSubItem)\r\n\t{\r\n\t\t// Change to a new column\r\n\t\tphvctx->sort.iColumn = plv->iSubItem;\r\n\t\tphvctx->sort.bReverse = FALSE;\r\n\t\tqsort_s(phvctx->index, phvctx->cTotal, sizeof(PHVITEM), (int(__cdecl*)(void*, const void*, const void*))HashVerifySortCompare, phvctx);\r\n\t}\r\n\telse if (phvctx->sort.bReverse)\r\n\t{\r\n\t\t// Clicking a column thrice in a row reverts to the original file order\r\n\t\tphvctx->sort.iColumn = -1;\r\n\t\tphvctx->sort.bReverse = FALSE;\r\n\r\n\t\t// We do need to validate phvctx->index to handle the edge case where\r\n\t\t// the list is really non-empty, but we are treating it as empty because\r\n\t\t// we could not allocate an index (qsort_s uses the given length while\r\n\t\t// SLBuildIndex uses the actual length); this is, admittedly, a very\r\n\t\t// extreme edge case, as it crops up only in an OOM situation where the\r\n\t\t// user tries to click-sort an empty list view!\r\n\t\tif (phvctx->index)\r\n\t\t\tSLBuildIndex(phvctx->hList, (PVOID*)phvctx->index);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Clicking a column twice in a row reverses the order; since we are\r\n\t\t// just reversing the order of an already-sorted column, we can just\r\n\t\t// naively flip the index\r\n\r\n\t\tif (phvctx->index)\r\n\t\t{\r\n\t\t\tPHVITEM pItemTemp;\r\n\t\t\tPPHVITEM ppItemLow = phvctx->index;\r\n\t\t\tPPHVITEM ppItemHigh = phvctx->index + phvctx->cTotal - 1;\r\n\r\n\t\t\twhile (ppItemHigh > ppItemLow)\r\n\t\t\t{\r\n\t\t\t\tpItemTemp = *ppItemLow;\r\n\t\t\t\t*ppItemLow = *ppItemHigh;\r\n\t\t\t\t*ppItemHigh = pItemTemp;\r\n\t\t\t\t++ppItemLow;\r\n\t\t\t\t--ppItemHigh;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tphvctx->sort.bReverse = TRUE;\r\n\t}\r\n\r\n\t// Restore the selection/focus state\r\n\tHashVerifySetStates(phvctx);\r\n\r\n\t// Update the UI\r\n\t{\r\n\t\tHWND hWndHeader = ListView_GetHeader(phvctx->hWndList);\r\n\t\tINT i;\r\n\r\n\t\tHDITEM hdi;\r\n\t\thdi.mask = HDI_FORMAT;\r\n\r\n\t\tfor (i = HV_COL_FIRST; i <= HV_COL_LAST; ++i)\r\n\t\t{\r\n\t\t\tHeader_GetItem(hWndHeader, i, &hdi);\r\n\t\t\thdi.fmt &= ~(HDF_SORTDOWN | HDF_SORTUP);\r\n\t\t\tif (phvctx->sort.iColumn == i)\r\n\t\t\t\thdi.fmt |= (phvctx->sort.bReverse) ? HDF_SORTDOWN : HDF_SORTUP;\r\n\t\t\tHeader_SetItem(hWndHeader, i, &hdi);\r\n\t\t}\r\n\r\n\t\t// Invalidate all items\r\n\t\tListView_RedrawItems(phvctx->hWndList, 0, phvctx->cTotal);\r\n\r\n\t\t// Set a light gray background on the sorted column\r\n\t\tListView_SetSelectedColumn(\r\n\t\t\tphvctx->hWndList,\r\n\t\t\t(phvctx->sort.iColumn != HV_COL_STATUS) ? phvctx->sort.iColumn : -1\r\n\t\t);\r\n\r\n\t\t// Unfortunately, the list does not automatically repaint all of the\r\n\t\t// areas affected by SetSelectedColumn, so it is necessary to force a\r\n\t\t// repaint of the list view's visible areas in order to avoid artifacts\r\n\t\tInvalidateRect(phvctx->hWndList, NULL, FALSE);\r\n\t}\r\n}\r\n\r\nVOID WINAPI HashVerifyReadStates( PHASHVERIFYCONTEXT phvctx )\r\n{\r\n\tif (!phvctx->bFreshStates)\r\n\t{\r\n\t\tUINT i;\r\n\r\n\t\tfor (i = 0; i < phvctx->cTotal; ++i)\r\n\t\t{\r\n\t\t\tphvctx->index[i]->uState = ListView_GetItemState(\r\n\t\t\t\tphvctx->hWndList,\r\n\t\t\t\ti,\r\n\t\t\t\tLVIS_FOCUSED | LVIS_SELECTED\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nVOID WINAPI HashVerifySetStates( PHASHVERIFYCONTEXT phvctx )\r\n{\r\n\tUINT i;\r\n\r\n\t// Optimize for the case where most items are unselected\r\n\tListView_SetItemState(phvctx->hWndList, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);\r\n\r\n\tfor (i = 0; i < phvctx->cTotal; ++i)\r\n\t{\r\n\t\tif (phvctx->index[i]->uState)\r\n\t\t{\r\n\t\t\tListView_SetItemState(\r\n\t\t\t\tphvctx->hWndList,\r\n\t\t\t\ti,\r\n\t\t\t\tphvctx->index[i]->uState,\r\n\t\t\t\tLVIS_FOCUSED | LVIS_SELECTED\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tphvctx->bFreshStates = TRUE;\r\n}\r\n\r\nINT __cdecl HashVerifySortCompare( PHASHVERIFYCONTEXT phvctx, PPCHVITEM ppItemA, PPCHVITEM ppItemB )\r\n{\r\n\tPHASHVERIFYITEM pItemA = *(PPHVITEM)ppItemA;\r\n\tPHASHVERIFYITEM pItemB = *(PPHVITEM)ppItemB;\r\n\r\n\tswitch (phvctx->sort.iColumn)\r\n\t{\r\n\t\tcase HV_COL_FILENAME:\r\n\t\t\treturn(StrCmpLogical(pItemA->pszDisplayName, pItemB->pszDisplayName));\r\n\r\n\t\tcase HV_COL_SIZE:\r\n\t\t\treturn(pItemA->filesize.ui64 < pItemB->filesize.ui64 ? -1 : (pItemA->filesize.ui64 == pItemB->filesize.ui64 ? 0 : 1));\r\n\r\n\t\tcase HV_COL_STATUS:\r\n\t\t\treturn((INT8)pItemA->uStatusID - (INT8)pItemB->uStatusID);\r\n\r\n\t\tcase HV_COL_EXPECTED:\r\n\t\t\treturn(StrCmpI(pItemA->pszExpected, pItemB->pszExpected));\r\n\r\n\t\tcase HV_COL_ACTUAL:\r\n\t\t\treturn(StrCmpI(pItemA->szActual, pItemB->szActual));\r\n\t}\r\n\r\n\treturn(0);\r\n}\r\n"
        },
        {
          "name": "IsSSD.c",
          "type": "blob",
          "size": 3.1689453125,
          "content": "/**\r\n* IsSSD function\r\n* Copyright (C) 2016 Christopher Gurnee.  All rights reserved.\r\n*\r\n* Please refer to readme.txt for information about this source code.\r\n* Please refer to license.txt for details about distribution and modification.\r\n*\r\n* Credit for this code goes to hatenablog.com user NyaRuRu; originally from:\r\n* http://nyaruru.hatenablog.com/entry/2012/09/29/063829\r\n**/\r\n\r\n#include \"globals.h\"\r\n#include \"IsSSD.h\"\r\n#include \"libs/SimpleString.h\"\r\n#include <Strsafe.h>\r\n\r\n// Tries to determine if the given file is stored on an SSD or other\r\n// device with a fast seek time; errs on the side of not-on-an-SSD\r\nBOOL IsSSD(LPCWCH lpszPath)\r\n{\r\n#ifdef FORCE_PPL\r\n    return(TRUE);\r\n#endif\r\n    TCHAR szMountPoint[MAX_PATH];\r\n    if (! GetVolumePathName(lpszPath, szMountPoint, MAX_PATH))\r\n        return(FALSE);\r\n\r\n    TCHAR szVolumeGUID[MAX_PATH];\r\n    if (! GetVolumeNameForVolumeMountPoint(szMountPoint, szVolumeGUID, MAX_PATH))\r\n        return(FALSE);\r\n\r\n    // Remove any trailing backslash\r\n    size_t cchVolumeGUIDLen;\r\n    StringCchLength(szVolumeGUID, MAX_PATH, &cchVolumeGUIDLen);\r\n    if (szVolumeGUID[cchVolumeGUIDLen - 1] == '\\\\')\r\n        szVolumeGUID[cchVolumeGUIDLen - 1] = '\\0';\r\n\r\n    HANDLE hVolume = CreateFile(\r\n        szVolumeGUID,\r\n        FILE_READ_ATTRIBUTES,\r\n        FILE_SHARE_READ | FILE_SHARE_WRITE,\r\n        NULL,\r\n        OPEN_EXISTING,\r\n        FILE_ATTRIBUTE_NORMAL,\r\n        NULL);\r\n    if (hVolume == INVALID_HANDLE_VALUE)\r\n        return(FALSE);\r\n\r\n    // There could be multiple extents on which this path resides; this checks only the first\r\n    VOLUME_DISK_EXTENTS vde;\r\n    DWORD cbIoControlReturned;\r\n    if (! DeviceIoControl(\r\n          hVolume,\r\n          IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,\r\n          NULL,\r\n          0,  \r\n          &vde,\r\n          sizeof(vde),\r\n          &cbIoControlReturned,\r\n          NULL))\r\n    {\r\n        CloseHandle(hVolume);\r\n        return(FALSE);\r\n    }\r\n\r\n    CloseHandle(hVolume);\r\n\r\n    TCHAR szPhysicalDrivePath[MAX_PATH];\r\n    static const TCHAR szPhysicalDrivePrefix[] = TEXT(\"\\\\\\\\.\\\\PhysicalDrive\");\r\n    SSStaticCpy(szPhysicalDrivePath, szPhysicalDrivePrefix);\r\n\r\n    StringCchPrintf(\r\n        szPhysicalDrivePath + countof(szPhysicalDrivePrefix) - 1,\r\n        MAX_PATH - countof(szPhysicalDrivePrefix),\r\n        TEXT(\"%d\"),\r\n        vde.Extents[0].DiskNumber);\r\n\r\n    HANDLE hPhysicalDrive = CreateFile(\r\n        szPhysicalDrivePath,\r\n        FILE_READ_ATTRIBUTES,\r\n        FILE_SHARE_READ | FILE_SHARE_WRITE,\r\n        NULL,\r\n        OPEN_EXISTING,\r\n        FILE_ATTRIBUTE_NORMAL,\r\n        NULL);\r\n    if (hPhysicalDrive == INVALID_HANDLE_VALUE)\r\n        return FALSE;\r\n\r\n    STORAGE_PROPERTY_QUERY spq;\r\n    spq.PropertyId = StorageDeviceSeekPenaltyProperty;\r\n    spq.QueryType  = PropertyStandardQuery;\r\n    DEVICE_SEEK_PENALTY_DESCRIPTOR dspd;\r\n    if (! DeviceIoControl(\r\n          hPhysicalDrive,\r\n          IOCTL_STORAGE_QUERY_PROPERTY,\r\n          &spq,\r\n          sizeof(spq),\r\n          &dspd,\r\n          sizeof(dspd),\r\n          &cbIoControlReturned,\r\n          NULL))\r\n    {\r\n        CloseHandle(hPhysicalDrive);\r\n        return(FALSE);\r\n    }\r\n\r\n    CloseHandle(hPhysicalDrive);\r\n\r\n    return(dspd.IncursSeekPenalty ? FALSE : TRUE);\r\n}\r\n"
        },
        {
          "name": "IsSSD.h",
          "type": "blob",
          "size": 0.421875,
          "content": "/**\r\n* IsSSD function\r\n* Copyright (C) 2016 Christopher Gurnee.  All rights reserved.\r\n*\r\n* Please refer to readme.txt for information about this source code.\r\n* Please refer to license.txt for details about distribution and modification.\r\n**/\r\n\r\n#ifndef __ISSSD_H__\r\n#define __ISSSD_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\nBOOL IsSSD(LPCWCH lpszPath);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.7138671875,
          "content": "# HashCheck Shell Extension #\r\n\r\n[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/gurnec/HashCheck?branch=master&svg=true)](https://ci.appveyor.com/project/gurnec/HashCheck)\r\n\r\n### Installation ###\r\n\r\nThe latest installer for Windows (Vista and later) can be found here:  \r\n<https://github.com/gurnec/HashCheck/releases/latest>\r\n\r\n#### Contributors ####\r\n\r\nKai Liu  \r\nChristopher Gurnee  \r\nDavid B. Trout  \r\nTim Schlueter\r\n\r\n\r\n## Building from source ##\r\n\r\n#### Compiler ####\r\n\r\nMicrosoft Visual Studio 2015 (the free Community edition works well).\r\n\r\n#### Localizations ####\r\n\r\nTranslation strings are stored as string table resources. These tables can be modified by editing [HashCheckTranslations.rc](HashCheckTranslations.rc).\r\n\r\n#### Translation Contributors ####\r\n\r\nCatalà: [@Hiro5](https://github.com/Hiro5)  \r\n中文 (简体): \"yumeyao\"  \r\n中文 (繁體): Jack Chang and [@Chocobo1](https://github.com/Chocobo1)  \r\nČeština: Václav Veselý  \r\nDeutsch: \"Rolf\"  \r\nΕλληνικά: \"XhmikosR\"  \r\nEspañol: \"Phare\"  \r\nFrançais: \"mooms\" and \"user_hidden\"  \r\nItaliano: \"Botta\" and [@scara](https://github.com/scara)  \r\n日本語: \"yumeyao\"  \r\n한국어: JaeHyung Lee  \r\nNederlands: \"Edwin\"  \r\nPolski: \"RedWine\"  \r\nPortuguês (Brasil): \"0d14r3\"  \r\nPortuguês (Portugal): \"LPCA\"  \r\nRomână: Oprea Nicolae, a.k.a. \"Jaff\"  \r\nPусский: Yurii Petrashko  \r\nSvenska: Stefan Friman  \r\nTürkçe: M. Ömer Gölgeli  \r\nYкраїнська: Yurii Petrashko\r\n\r\n#### License and miscellanea ####\r\n\r\nStandard 3-Clause BSD License.\r\n\r\nPlease refer to [license.txt](license.txt) for details about distribution and modification.\r\n\r\nThis software is based on software originally distributed at:  \r\n<http://code.kliu.org/hashcheck/>\r\n"
        },
        {
          "name": "RegHelpers.c",
          "type": "blob",
          "size": 2.732421875,
          "content": "/**\r\n * Registry Helper Functions\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"RegHelpers.h\"\r\n#include \"libs/Wow64.h\"\r\n#include \"libs/SimpleString.h\"\r\n#include <Strsafe.h>\r\n\r\n#define countof(x) (sizeof(x)/sizeof(x[0]))\r\n\r\nHKEY WINAPI RegOpen( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpSubst, BOOL bCreate )\r\n{\r\n\tHKEY hKeyRet = NULL;\r\n\tTCHAR szJoinedKey[0x7F];\r\n\tif (lpSubst) StringCchPrintf(szJoinedKey, countof(szJoinedKey), lpSubKey, lpSubst);\r\n\r\n    LONG lResult;\r\n    if (bCreate)\r\n        lResult = RegCreateKeyEx(hKey, (lpSubst) ? szJoinedKey : lpSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKeyRet, NULL);\r\n    else\r\n        lResult = RegOpenKeyEx(hKey, (lpSubst) ? szJoinedKey : lpSubKey, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyRet);\r\n\r\n\tif (lResult == ERROR_SUCCESS)\r\n\t{\r\n\t\tWow64DisableRegReflection(hKeyRet);\r\n\t\treturn(hKeyRet);\r\n\t}\r\n\r\n\treturn(NULL);\r\n}\r\n\r\nBOOL WINAPI RegDelete( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpSubst )\r\n{\r\n\tLONG lResult;\r\n\tTCHAR szJoinedKey[0x7F];\r\n\tif (lpSubst) StringCchPrintf(szJoinedKey, countof(szJoinedKey), lpSubKey, lpSubst);\r\n\r\n\tlResult = SHDeleteKey(hKey, (lpSubst) ? szJoinedKey : lpSubKey);\r\n\treturn(lResult == ERROR_SUCCESS || lResult == ERROR_FILE_NOT_FOUND);\r\n}\r\n\r\nBOOL WINAPI RegSetSZ( HKEY hKey, LPCTSTR lpValueName, LPCTSTR lpData )\r\n{\r\n\treturn(RegSetValueEx(hKey, lpValueName, 0, REG_SZ, (LPBYTE)lpData, ((DWORD)SSLen(lpData) + 1) * sizeof(lpData[0])) == ERROR_SUCCESS);\r\n}\r\n\r\nBOOL WINAPI RegSetDW( HKEY hKey, LPCTSTR lpValueName, DWORD dwData )\r\n{\r\n\treturn(RegSetValueEx(hKey, lpValueName, 0, REG_DWORD, (LPBYTE)&dwData, sizeof(dwData)) == ERROR_SUCCESS);\r\n}\r\n\r\nBOOL WINAPI RegGetSZ( HKEY hKey, LPCTSTR lpValueName, LPTSTR lpData, DWORD cbData )\r\n{\r\n\tDWORD dwType;\r\n\r\n\tif ( RegQueryValueEx(hKey, lpValueName, NULL, &dwType, (LPBYTE)lpData, &cbData) == ERROR_SUCCESS &&\r\n\t     dwType == REG_SZ && cbData >= sizeof(TCHAR) )\r\n\t{\r\n\t\t// The registry does not check for proper null termination, so in order\r\n\t\t// to prevent crashes in the case of a malformed registry entry, make\r\n\t\t// sure that, at the very least, the final character is a null\r\n\t\t*((LPTSTR)((LPBYTE)lpData + cbData - sizeof(TCHAR))) = 0;\r\n\t\treturn(TRUE);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlpData[0] = 0;\r\n\t\treturn(FALSE);\r\n\t}\r\n}\r\n\r\nBOOL WINAPI RegGetDW( HKEY hKey, LPCTSTR lpValueName, LPDWORD lpdwData )\r\n{\r\n\tDWORD cbData = sizeof(DWORD);\r\n\tDWORD dwType;\r\n\r\n\tif ( RegQueryValueEx(hKey, lpValueName, NULL, &dwType, (LPBYTE)lpdwData, &cbData) == ERROR_SUCCESS &&\r\n\t     dwType == REG_DWORD && cbData == sizeof(DWORD) )\r\n\t{\r\n\t\treturn(TRUE);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t*lpdwData = 0;\r\n\t\treturn(FALSE);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "RegHelpers.h",
          "type": "blob",
          "size": 0.7216796875,
          "content": "/**\r\n * Registry Helper Functions\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __REGHELPERS_H__\r\n#define __REGHELPERS_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n#include <shlwapi.h>\r\n\r\nHKEY WINAPI RegOpen( HKEY, LPCTSTR, LPCTSTR, BOOL );\r\nBOOL WINAPI RegDelete( HKEY, LPCTSTR, LPCTSTR );\r\nBOOL WINAPI RegSetSZ( HKEY, LPCTSTR, LPCTSTR );\r\nBOOL WINAPI RegSetDW( HKEY, LPCTSTR, DWORD );\r\nBOOL WINAPI RegGetSZ( HKEY, LPCTSTR, LPTSTR, DWORD );\r\nBOOL WINAPI RegGetDW( HKEY, LPCTSTR, LPDWORD );\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "SetAppID.c",
          "type": "blob",
          "size": 4.1806640625,
          "content": "/**\r\n * Sets the Application User Model ID for windows or processes on NT 6.1+\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"globals.h\"\r\n#include \"libs/SimpleString.h\"\r\n#include <propidl.h>\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n *\r\n * In order to build without requiring the installation of the NT 6.1 PSDK, it\r\n * is necessary to manually define a number of things...\r\n *\r\n *\r\n ******************************************************************************/\r\n\r\n\r\n#ifndef PROPERTYKEY_DEFINED\r\n#define PROPERTYKEY_DEFINED\r\ntypedef struct {\r\n\tGUID fmtid;\r\n\tDWORD pid;\r\n} PROPERTYKEY;\r\n\r\ntypedef const PROPERTYKEY *REFPROPERTYKEY;\r\n#endif\r\n\r\n#ifndef __propsys_h__\r\ntypedef interface IPropertyStore IPropertyStore;\r\n\r\ninterface IPropertyStore\r\n{\r\n\tCONST_VTBL struct IPropertyStoreVtbl\r\n\t{\r\n\t\tBEGIN_INTERFACE\r\n\r\n\t\tHRESULT ( STDMETHODCALLTYPE *QueryInterface )( IPropertyStore *This, REFIID riid, void **ppvObject );\r\n\t\tULONG ( STDMETHODCALLTYPE *AddRef )( IPropertyStore *This );\r\n\t\tULONG ( STDMETHODCALLTYPE *Release )( IPropertyStore *This );\r\n\t\tHRESULT ( STDMETHODCALLTYPE *GetCount )( IPropertyStore *This, DWORD *cProps );\r\n\t\tHRESULT ( STDMETHODCALLTYPE *GetAt )( IPropertyStore *This, DWORD iProp, PROPERTYKEY *pkey );\r\n\t\tHRESULT ( STDMETHODCALLTYPE *GetValue )( IPropertyStore *This, REFPROPERTYKEY key, PROPVARIANT *pv );\r\n\t\tHRESULT ( STDMETHODCALLTYPE *SetValue )( IPropertyStore *This, REFPROPERTYKEY key, PROPVARIANT *pv );\r\n\t\tHRESULT ( STDMETHODCALLTYPE *Commit )( IPropertyStore *This );\r\n\r\n\t\tEND_INTERFACE\r\n\r\n\t} *lpVtbl;\r\n};\r\n#endif\r\n\r\nstatic const IID IID_IPropertyStore = { 0x886d8eeb, 0x8cf2, 0x4446, { 0x8d, 0x02, 0xcd, 0xba, 0x1d, 0xbd, 0xcf, 0x99 } };\r\nstatic const PROPERTYKEY PKEY_AppUserModel_PreventPinning = { { 0x9f4c2855, 0x9f79, 0x4b39, { 0xa8, 0xd0, 0xe1, 0xd4, 0x2d, 0xe1, 0xd5, 0xf3 } }, 9 };\r\nstatic const PROPERTYKEY PKEY_AppUserModel_ID = { { 0x9f4c2855, 0x9f79, 0x4b39, { 0xa8, 0xd0, 0xe1, 0xd4, 0x2d, 0xe1, 0xd5, 0xf3 } }, 5 };\r\n\r\ntypedef HRESULT (WINAPI *PFNSCPEAUMID)( PCWSTR AppID );\r\ntypedef HRESULT (WINAPI *PFNSHGPSFW)( HWND hwnd, REFIID riid, void** ppv );\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n *\r\n * SetAppIDForWindow\r\n *\r\n *\r\n ******************************************************************************/\r\n\r\n\r\nVOID WINAPI SetAppIDForWindow( HWND hWnd, BOOL fEnable )\r\n{\r\n\tif (g_uWinVer >= 0x601)\r\n\t{\r\n\t\tIPropertyStore *pps;\r\n\r\n\t\tPFNSHGPSFW pfnSHGetPropertyStoreForWindow = (PFNSHGPSFW)\r\n\t\t\tGetProcAddress(GetModuleHandleA(\"SHELL32.dll\"), \"SHGetPropertyStoreForWindow\");\r\n\r\n\t\tif ( pfnSHGetPropertyStoreForWindow &&\r\n\t\t     SUCCEEDED(pfnSHGetPropertyStoreForWindow(hWnd, &IID_IPropertyStore, &pps)) )\r\n\t\t{\r\n\t\t\tPROPVARIANT propvars[2];\r\n\r\n\t\t\t// PropVariantInit is just a macro for a zeroing memset\r\n\t\t\tZeroMemory(propvars, sizeof(propvars));\r\n\r\n\t\t\tif (fEnable)\r\n\t\t\t{\r\n\t\t\t\t// InitPropVariantFrom* functions were introduced in NT6, and\r\n\t\t\t\t// should be avoided because of the extra SDK dependency and\r\n\t\t\t\t// because of the extra COM memory allocation (and cleanup),\r\n\t\t\t\t// which is unnecessary since we are running in-process.\r\n\r\n\t\t\t\tpropvars[0].vt = VT_BOOL;\r\n\t\t\t\tpropvars[0].boolVal = TRUE;\r\n\r\n\t\t\t\tpropvars[1].vt = VT_LPWSTR;\r\n\t\t\t\tpropvars[1].pwszVal = APP_USER_MODEL_ID;\r\n\t\t\t}\r\n\r\n\t\t\tpps->lpVtbl->SetValue(pps, &PKEY_AppUserModel_PreventPinning, &propvars[0]);\r\n\t\t\tpps->lpVtbl->SetValue(pps, &PKEY_AppUserModel_ID, &propvars[1]);\r\n\r\n\t\t\tpps->lpVtbl->Release(pps);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/*******************************************************************************\r\n *\r\n *\r\n * SetAppIDForProcess\r\n *\r\n *\r\n ******************************************************************************/\r\n\r\n\r\nVOID WINAPI SetAppIDForProcess( )\r\n{\r\n\tif (g_uWinVer >= 0x601)\r\n\t{\r\n\t\tPFNSCPEAUMID pfnSetCurrentProcessExplicitAppUserModelID = (PFNSCPEAUMID)\r\n\t\t\tGetProcAddress(GetModuleHandleA(\"SHELL32.dll\"), \"SetCurrentProcessExplicitAppUserModelID\");\r\n\r\n\t\tif (pfnSetCurrentProcessExplicitAppUserModelID)\r\n\t\t\tpfnSetCurrentProcessExplicitAppUserModelID(APP_USER_MODEL_ID);\r\n\t}\r\n}\r\n"
        },
        {
          "name": "SetAppID.h",
          "type": "blob",
          "size": 0.5361328125,
          "content": "/**\r\n * Sets the Application User Model ID for windows or processes on NT 6.1+\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __SETAPPID_H__\r\n#define __SETAPPID_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n\r\nVOID WINAPI SetAppIDForWindow( HWND hWnd, BOOL fEnable );\r\nVOID WINAPI SetAppIDForProcess( );\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "UnicodeHelpers.c",
          "type": "blob",
          "size": 2.744140625,
          "content": "/**\r\n * UTF-16/UTF-8 Helper Functions\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#include \"UnicodeHelpers.h\"\r\n#include \"libs/BitwiseIntrinsics.h\"\r\n\r\n#define GETWORD(p)  (*((UPWORD) (p)))\r\n#define GETDWORD(p) (*((UPDWORD)(p)))\r\n\r\nPBYTE __fastcall IsTextUTF8( PBYTE pbData )\r\n{\r\n\tPBYTE pbOriginal = pbData;\r\n\r\n\t// Step 1: Check for the BOM (signature)\r\n\r\n\tif (*pbData == 0xEF && GETWORD(pbData + 1) == 0xBFBB)\r\n\t\treturn(pbData + 3);\r\n\r\n\t// Step 2: If there is no BOM, then manually walk the string and sniff\r\n\r\n\t// We check for validity by masking out the data bits and testing if the\r\n\t// remaining bits match a valid control sequence... this is not a perfect\r\n\t// check, as it will pass overlong encodings (depending on your goal, you\r\n\t// might actually want to pass overlongs) since the cost of being pedantic\r\n\t// with overlongs is not worth it given the lack of substantial benefit.\r\n\r\n\twhile (*pbData)\r\n\t{\r\n\t\tif (*pbData < 0x80)\r\n\t\t\tpbData += 1; // Plain ASCII\r\n\t\telse if ((GETWORD(pbData) & 0xC0E0) == 0x80C0)\r\n\t\t\tpbData += 2; // Valid 2-byte UTF-8 sequence\r\n\t\telse if ((GETDWORD(pbData) & 0x00C0C0F0) == 0x008080E0)\r\n\t\t\tpbData += 3; // Valid 3-byte UTF-8 sequence\r\n\t\telse if ((GETDWORD(pbData) & 0xC0C0C0F8) == 0x808080F0)\r\n\t\t\tpbData += 4; // Valid 4-byte UTF-8 sequence (outside of UTF-16 range)\r\n\t\telse\r\n\t\t\treturn(NULL);\r\n\t}\r\n\r\n\treturn(pbOriginal);\r\n}\r\n\r\nPWSTR __fastcall BufferToWStr( PBYTE *ppbData, DWORD cbData )\r\n{\r\n\tPBYTE pbData = *ppbData;\r\n\tPWSTR pszResult;\r\n\r\n\t// Step 1: Find out if the buffer is a UTF-16 string\r\n\r\n\tINT iUnicodeTests = IS_TEXT_UNICODE;\r\n\tIsTextUnicode(pbData, cbData, &iUnicodeTests);\r\n\r\n\tif (iUnicodeTests & IS_TEXT_UNICODE)\r\n\t{\r\n\t\t// Reverse if necessary\r\n\t\tif (iUnicodeTests & IS_TEXT_UNICODE_REVERSE_MASK)\r\n\t\t\tSwapA16I((PWSTR)pbData, cbData / sizeof(WCHAR));\r\n\r\n\t\t// Skip the BOM if it exists\r\n\t\tif (iUnicodeTests & IS_TEXT_BOM)\r\n\t\t\tpbData += sizeof(WCHAR);\r\n\r\n\t\treturn((PWSTR)pbData);\r\n\t}\r\n\r\n\t// Step 2: If this is not UTF-16, then check if this is UTF-8 or ANSI, and\r\n\t// then convert as appropriate\r\n\r\n\tif (pszResult = malloc((cbData + 1) * sizeof(WCHAR)))\r\n\t{\r\n\t\tPBYTE pbScratch;\r\n\t\tUINT uCodePage;\r\n\r\n\t\t// Check for UTF-8 and select the appropriate conversion method\r\n\t\tif (pbScratch = IsTextUTF8(pbData))\r\n\t\t{\r\n\t\t\tuCodePage = CP_UTF8;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpbScratch = pbData;\r\n\t\t\tuCodePage = CP_ACP;\r\n\t\t}\r\n\r\n\t\t// Convert, and if successful, replace the old buffer with the new\r\n\t\tif (StrToWStrEx(pbScratch, pszResult, cbData + 1, uCodePage))\r\n\t\t{\r\n\t\t\tfree(pbData);\r\n\t\t\t*ppbData = (PBYTE)pszResult;\r\n\t\t\treturn(pszResult);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfree(pszResult);\r\n\t\t}\r\n\t}\r\n\r\n\treturn(NULL);\r\n}\r\n"
        },
        {
          "name": "UnicodeHelpers.h",
          "type": "blob",
          "size": 2.9208984375,
          "content": "/**\r\n * UTF-16/UTF-8 Helper Functions\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __UNICODEHELPERS_H__\r\n#define __UNICODEHELPERS_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <windows.h>\r\n#include \"libs/SimpleString.h\"\r\n\r\n/**\r\n * Helper Macros\r\n * Argument order: source, destination, count (follow the order in the name)\r\n **/\r\n\r\n#define WStrToStrEx(w, a, c, cp) WideCharToMultiByte(cp, 0, w, -1, a, c, NULL, NULL)\r\n#define StrToWStrEx(a, w, c, cp) MultiByteToWideChar(cp, 0, a, -1, w, c)\r\n\r\n#define WStrToAStr(w, a, c)      WideCharToMultiByte(CP_ACP,  0, w, -1, a, c, NULL, NULL)\r\n#define AStrToWStr(a, w, c)      MultiByteToWideChar(CP_ACP,  0, a, -1, w, c)\r\n#define WStrToUTF8(w, a, c)      WideCharToMultiByte(CP_UTF8, 0, w, -1, a, c, NULL, NULL)\r\n#define UTF8ToWStr(a, w, c)      MultiByteToWideChar(CP_UTF8, 0, a, -1, w, c)\r\n\r\n#ifdef UNICODE\r\n#define TStrToAStr               WStrToAStr\r\n#define AStrToTStr               AStrToWStr\r\n#define TStrToWStr(t, w, c)      SSCpyW(w, t)\r\n#define WStrToTStr(w, t, c)      SSCpyW(t, w)\r\n#else\r\n#define TStrToAStr(t, a, c)      SSCpyA(a, t)\r\n#define AStrToTStr(a, t, c)      SSCpyA(t, a)\r\n#define TStrToWStr               AStrToWStr\r\n#define WStrToTStr               WStrToAStr\r\n#endif\r\n\r\n/**\r\n * IsTextUnicode definitions\r\n **/\r\n\r\n#define IS_TEXT_UNICODE (IS_TEXT_UNICODE_UNICODE_MASK | IS_TEXT_UNICODE_REVERSE_MASK)\r\n#define IS_TEXT_BOM (IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE)\r\n\r\n/**\r\n * IsTextUTF8 - Checks if a string is UTF-8, and if it is, returns a pointer to\r\n * the start of the string (skipping the BOM if there is one); NULL is returned\r\n * if the string is not UTF-8.\r\n *\r\n * NOTE: To simplify bounds checking, the buffer passed to IsTextUTF8 needs to\r\n * be NULL-terminated and must extend at least 2 bytes past the NULL terminator!\r\n **/\r\n\r\nPBYTE __fastcall IsTextUTF8( PBYTE pbData );\r\n\r\n/**\r\n * BufferToWStr - Converts a malloc-allocated buffer to Unicode and returns\r\n * a pointer to the start of the new Unicode string, with any BOMs skipped;\r\n * NULL is returned if the operation failed.\r\n *\r\n * NOTE: BufferToWStr may re-allocate a larger buffer, in which case the\r\n * original buffer is freed and *ppbData will be a pointer to the new buffer\r\n * (otherwise, *ppbData will be unchanged); cbData should be the size, in bytes\r\n * of the data in the buffer, without any NULL terminations.\r\n *\r\n * NOTE: To simplify bounds checking, the buffer passed to BufferToWStr should\r\n * be at least 3 bytes larger than cbData, and the first 2 of these bytes\r\n * should be NULL (to serve as the termination of the string); the easiest way\r\n * to do this is to append a zero DWORD to the end of the string.\r\n **/\r\n\r\nPWSTR __fastcall BufferToWStr( PBYTE *ppbData, DWORD cbData );\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "UnitTests",
          "type": "tree",
          "content": null
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 3.88671875,
          "content": "version: 2.4.0.55\n\nimage: Visual Studio 2015\n\ncache:\n  - packages -> **\\packages.config\n\nbefore_build:\n  - cd \"%APPVEYOR_BUILD_FOLDER%\"\n  - nuget restore\n\nbuild_script:\n  - cd \"%APPVEYOR_BUILD_FOLDER%\"\n  # the NO_PPL (no-multithreading) debug versions\n  - msbuild HashCheck.sln /p:Configuration=Debug;Platform=Win32;TempCDefines=NO_PPL /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n  - msbuild HashCheck.sln /p:Configuration=Debug;Platform=x64;TempCDefines=NO_PPL   /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n  - copy Bin\\Win32\\Debug\\HashCheck.dll Bin\\Win32\\Debug\\HashCheck-no_ppl.dll\n  - copy Bin\\x64\\Debug\\HashCheck.dll Bin\\x64\\Debug\\HashCheck-no_ppl.dll\n  # the FORCE_PPL debug versions\n  - msbuild HashCheck.sln /p:Configuration=Debug;Platform=Win32;TempCDefines=FORCE_PPL /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n  - msbuild HashCheck.sln /p:Configuration=Debug;Platform=x64;TempCDefines=FORCE_PPL   /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n  # the release versions\n  - msbuild HashCheck.sln /p:Configuration=Release;Platform=Win32 /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n  - msbuild HashCheck.sln /p:Configuration=Release;Platform=x64   /logger:\"C:\\Program Files\\AppVeyor\\BuildAgent\\Appveyor.MSBuildLogger.dll\"\n\nbefore_test:\n  - cd \"%APPVEYOR_BUILD_FOLDER%\\UnitTests\"\n  - C:\\Python35-x64\\python get-sha-test-vectors.py\n  - C:\\Python35-x64\\python get-md5-test-vectors.py\n  - C:\\Python35-x64\\python gen-big-test-vector.py\n  # tests for disambiguating vectors of the same bit length\n  - copy vectors\\SHA256ShortMsg.rsp.sha256     vectors\\SHA256ShortMsg.rsp.asc\n  - copy vectors\\SHA3_256ShortMsg.rsp.sha3-256 vectors\\SHA3_256ShortMsg.rsp.asc\n  # negative tests\n  - copy mismatch.sha256   vectors\\\n  - copy mismatch.sha256   vectors\\mismatch.asc\n  - copy unreadable.sha256 vectors\\\n\ntest_script:\n  - cd \"%APPVEYOR_BUILD_FOLDER%\"\n  # the NO_PPL versions\n  - regsvr32 /i:\"NoCopy NoUninstall\" /n /s Bin\\Win32\\Debug\\HashCheck-no_ppl.dll\n  - packages\\xunit.runner.console.2.1.0\\tools\\xunit.console.x86 UnitTests\\bin\\Release\\UnitTests.dll -appveyor\n  - regsvr32 /i:\"NoCopy NoUninstall\" /n /s Bin\\x64\\Debug\\HashCheck-no_ppl.dll\n  - packages\\xunit.runner.console.2.1.0\\tools\\xunit.console UnitTests\\bin\\Release\\UnitTests.dll -appveyor\n  # the FORCE_PPL versions (before each test, delete the NO_PPL version to ensure it's not under test)\n  - regsvr32 /i:\"NoCopy NoUninstall\" /n /s Bin\\Win32\\Debug\\HashCheck.dll\n  - del Bin\\Win32\\Debug\\HashCheck-no_ppl.dll\n  - packages\\xunit.runner.console.2.1.0\\tools\\xunit.console.x86 UnitTests\\bin\\Release\\UnitTests.dll -appveyor\n  - regsvr32 /i:\"NoCopy NoUninstall\" /n /s Bin\\x64\\Debug\\HashCheck.dll\n  - del Bin\\x64\\Debug\\HashCheck-no_ppl.dll\n  - packages\\xunit.runner.console.2.1.0\\tools\\xunit.console UnitTests\\bin\\Release\\UnitTests.dll -appveyor\n  # the release versions (before each test, delete the FORCE_PPL version to ensure it's not under test)\n  - regsvr32 /i /n /s Bin\\Win32\\Release\\HashCheck.dll\n  - del Bin\\Win32\\Debug\\HashCheck.dll\n  - packages\\xunit.runner.console.2.1.0\\tools\\xunit.console.x86 UnitTests\\bin\\Release\\UnitTests.dll -appveyor\n  - regsvr32 /i /n /s Bin\\x64\\Release\\HashCheck.dll\n  - del Bin\\x64\\Debug\\HashCheck.dll\n  - packages\\xunit.runner.console.2.1.0\\tools\\xunit.console UnitTests\\bin\\Release\\UnitTests.dll -appveyor\n\nafter_test:\n  - cd \"%APPVEYOR_BUILD_FOLDER%\\installer\"\n  - '\"C:\\Program Files (x86)\\NSIS\\makensis\" HashCheck.nsi'\n  - copy HashCheckSetup-v*.exe \"%APPVEYOR_BUILD_FOLDER%\"\n  - ps: (Get-FileHash -Algorithm SHA256 HashCheckSetup-v*.exe).Hash.ToString().ToLower() + \" *\" + (dir HashCheckSetup-v*.exe).Name > ((dir HashCheckSetup-v*.exe).Name + \".sha256\")\n  - copy HashCheckSetup-v*.exe.sha256 \"%APPVEYOR_BUILD_FOLDER%\"\n\nartifacts:\n  - path: 'HashCheckSetup-v*.exe'\n    name: installer\n  - path: 'HashCheckSetup-v*.exe.sha256'\n    name: checksum\n"
        },
        {
          "name": "dev-inst-debug.bat",
          "type": "blob",
          "size": 0.2861328125,
          "content": "@echo off\r\nwhoami /groups /fo csv | find \"\"\"S-1-16-12288\"\"\" > NUL || echo Administrative privileges required. && exit /b 2\r\ncopy Bin\\x64\\Debug\\HashCheck.dll   C:\\Windows\\System32\\ShellExt\\HashCheck.dll || exit /b\r\ncopy Bin\\Win32\\Debug\\HashCheck.dll C:\\Windows\\SysWOW64\\ShellExt\\HashCheck.dll\r\n"
        },
        {
          "name": "dev-inst.bat",
          "type": "blob",
          "size": 0.2900390625,
          "content": "@echo off\r\nwhoami /groups /fo csv | find \"\"\"S-1-16-12288\"\"\" > NUL || echo Administrative privileges required. && exit /b 2\r\ncopy Bin\\x64\\Release\\HashCheck.dll   C:\\Windows\\System32\\ShellExt\\HashCheck.dll || exit /b\r\ncopy Bin\\Win32\\Release\\HashCheck.dll C:\\Windows\\SysWOW64\\ShellExt\\HashCheck.dll\r\n"
        },
        {
          "name": "globals.h",
          "type": "blob",
          "size": 1.84765625,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Copyright (C) Kai Liu.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n#ifndef __GLOBALS_H__\r\n#define __GLOBALS_H__\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"libs/WinIntrinsics.h\"\r\n\r\n#include <windows.h>\r\n#include <olectl.h>\r\n#include <shlobj.h>\r\n#include <shlwapi.h>\r\n#include <process.h>\r\n\r\n#include \"libs/SimpleString.h\"\r\n#include \"libs/SimpleList.h\"\r\n#include \"libs/BitwiseIntrinsics.h\"\r\n#include \"HashCheckResources.h\"\r\n#include \"HashCheckTranslations.h\"\r\n#include \"version.h\"\r\n\r\n// Define globals for bookkeeping this DLL instance\r\nextern HMODULE g_hModThisDll;\r\nextern CREF g_cRefThisDll;\r\n\r\n// Activation context cache, to reduce the number of CreateActCtx calls\r\nextern volatile BOOL g_bActCtxCreated;\r\nextern HANDLE g_hActCtx;\r\n\r\n// Major and minor Windows version\r\nextern UINT16 g_uWinVer;\r\n\r\n// Define the data and strings used for COM registration\r\nstatic const GUID CLSID_HashCheck = { 0x705977c7, 0x86cb, 0x4743, { 0xbf, 0xaf, 0x69, 0x08, 0xbd, 0x19, 0xb7, 0xb0 } };\r\n#define CLSID_STR_HashCheck         TEXT(\"{705977C7-86CB-4743-BFAF-6908BD19B7B0}\")\r\n#define CLSNAME_STR_HashCheck       TEXT(\"HashCheck Shell Extension\")\r\n#define PROGID_STR_HashCheck        TEXT(\"HashCheck\")\r\n\r\n// Application ID for the NT6.1+ taskbar\r\n#define APP_USER_MODEL_ID           L\"KL.HashCheck\"\r\n\r\n// Define helper macros\r\n#define countof(x)                  (sizeof(x)/sizeof(x[0]))\r\n#define BYTEDIFF(a, b)              ((PBYTE)(a) - (PBYTE)(b))\r\n#define BYTEADD(a, cb)              ((PVOID)((PBYTE)(a) + (cb)))\r\n\r\n// Max translation string lengths; increase this as necessary\r\n#define MAX_STRINGRES               0x20\r\n#define MAX_STRINGMSG               0x40\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "installer",
          "type": "tree",
          "content": null
        },
        {
          "name": "libs",
          "type": "tree",
          "content": null
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.650390625,
          "content": "HashCheck Shell Extension\r\n\r\nCopyright (C) 2008-2009 Kai Liu.  All rights reserved.\r\nCopyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\nCopyright (C) 2014 Software Development Laboratories (\"Fish\" (David B. Trout))\r\nCopyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification,\r\nare permitted provided that the following conditions are met:\r\n\r\n1. Redistributions of source code must retain the above copyright notice, this\r\n   list of conditions and the following disclaimer.\r\n\r\n2. Redistributions in binary form must reproduce the above copyright notice,\r\n   this list of conditions and the following disclaimer in the documentation\r\n   and/or other materials provided with the distribution.\r\n\r\n3. The name of the copyright holder may not be used to endorse or promote\r\n   products derived from this software without specific prior written\r\n   permission.\r\n\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER \"AS IS\" AND ANY EXPRESS OR\r\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\r\nEVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\r\nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\r\nIN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\r\nOF SUCH DAMAGE.\r\n"
        },
        {
          "name": "update-version.py",
          "type": "blob",
          "size": 6.3818359375,
          "content": "#!/usr/bin/python3\r\n#\r\n# Version updater\r\n# Copyright (C) 2016 Christopher Gurnee.  All rights reserved.\r\n#\r\n# Please refer to readme.md for information about this source code.\r\n# Please refer to license.txt for details about distribution and modification.\r\n#\r\n# Updates various version constants based on HASHCHECK_VERSION_STR in version.h\r\n\r\nimport sys, os, os.path, re, contextlib, atexit\r\nfrom warnings import warn\r\n\r\natexit.register(lambda: input('Press Enter to exit ...'))\r\n\r\n\r\n# When used in a 'with' statement, renames filename to filename.orig and opens filename for\r\n# writing. If an uncaught exception is raised, restores filename.orig, otherwise deletes it.\r\n@contextlib.contextmanager\r\ndef overwrite(filename, mode='w', *args, **kwargs):\r\n    try:\r\n        renamed = filename + '.orig'\r\n        os.rename(filename, renamed)\r\n    except FileNotFoundError:\r\n        renamed = None\r\n    try:\r\n        file = open(filename, mode, *args, **kwargs)\r\n    except:\r\n        if renamed:\r\n            os.rename(renamed, filename)\r\n        raise\r\n    try:\r\n        yield file\r\n    except:\r\n        file.close()\r\n        os.remove(filename)\r\n        if renamed:\r\n            os.rename(renamed, filename)\r\n        raise\r\n    file.close()\r\n    if renamed:\r\n        os.remove(renamed)\r\n\r\n\r\nos.chdir(os.path.dirname(__file__))\r\n\r\n# Get the \"authoritative\" version string from HASHCHECK_VERSION_STR in version.h\r\nmatch = None\r\nwith open('version.h', encoding='utf-8') as file:\r\n    for line in file:\r\n        match = re.match(r'#define\\s+HASHCHECK_VERSION_STR\\s+\"(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)((?:-\\w+)?)\"', line)\r\n        if match:\r\n            break\r\nif not match:\r\n    sys.exit('Valid version not found in version.h')\r\n\r\nmajor      = match.group(1)\r\nminor      = match.group(2)\r\npatch      = match.group(3)\r\nbuild      = match.group(4)\r\nprerelease = match.group(5)\r\ndef full_version():\r\n    return '.'.join((major, minor, patch, build)) + prerelease\r\n\r\nprint('v' + full_version())\r\n\r\n# Compare the authoritative version with the one in appveyor.yml; since this file\r\n# is updated last, it will be the same iff the authoritative version wasn't changed\r\nmatch = None\r\nwith open('appveyor.yml', encoding='utf-8') as file:\r\n    for line in file:\r\n        match = re.match(r'version:\\s*(\\S+)\\s*$', line)\r\n        if match:\r\n            if match.group(1) == full_version():\r\n                if input('Version is unchanged, increment build number (Y/n)? ').strip().lower() == 'n':\r\n                    sys.exit(0)\r\n                build = str(int(build) + 1)\r\n                print('v' + full_version())\r\n            break\r\n\r\n# Update the 3 version constants in version.h\r\nfound_version_full   = 0\r\nfound_version_str    = 0\r\nfound_linker_version = 0\r\nwith overwrite('version.h', encoding='utf-8', newline='') as out_file:\r\n    with open('version.h.orig', encoding='utf-8', newline='') as in_file:\r\n        for line in in_file:\r\n            (line, subs) = re.subn(r'^#define\\s+HASHCHECK_VERSION_FULL\\s+[\\d,]+',\r\n                                     '#define HASHCHECK_VERSION_FULL ' + ','.join((major, minor, patch, build)), line)\r\n            found_version_full   += subs\r\n            (line, subs) = re.subn(r'^#define\\s+HASHCHECK_VERSION_STR\\s+\"[\\d.\\w-]*\"',\r\n                                     '#define HASHCHECK_VERSION_STR \"' + full_version() + '\"', line)\r\n            found_version_str    += subs\r\n            (line, subs) = re.subn(r'^#pragma\\s+comment\\s*\\(\\s*linker\\s*,\\s*\"/version:[\\d+.]+\"\\s*\\)',\r\n                                     '#pragma comment(linker, \"/version:{}.{}\")'.format(major, minor), line)\r\n            found_linker_version += subs\r\n            out_file.write(line)\r\nif found_version_full   != 1:\r\n    warn('found {} HASHCHECK_VERSION_FULL defines in version.h'.format(found_version_full))\r\nif found_version_str    != 1:\r\n    warn('found {} HASHCHECK_VERSION_STR defines in version.h'.format(found_version_str))\r\nif found_linker_version != 1:\r\n    warn('found {} linker /version lines in version.h'.format(found_linker_version))\r\n\r\n# Update the 4 version constants in HashCheck.nsi\r\nfound_outfile             = 0\r\nfound_product_version     = 0\r\nfound_version_key_product = 0\r\nfound_version_key_file    = 0\r\nwith overwrite(r'installer\\HashCheck.nsi', encoding='utf-8', newline='') as out_file:\r\n    with open(r'installer\\HashCheck.nsi.orig', encoding='utf-8', newline='') as in_file:\r\n        for line in in_file:\r\n            (line, subs) = re.subn(r'^OutFile\\s*\"HashCheckSetup-v[\\d.\\w-]+.exe\"',\r\n                                     'OutFile \"HashCheckSetup-v' + full_version() + '.exe\"', line)\r\n            found_outfile             += subs\r\n            (line, subs) = re.subn(r'^VIProductVersion\\s+\"[\\d.\\w-]+\"',\r\n                                     'VIProductVersion \"' + full_version() + '\"', line)\r\n            found_product_version     += subs\r\n            (line, subs) = re.subn(r'^VIAddVersionKey\\s+/LANG=\\${LANG_ENGLISH}\\s+\"ProductVersion\"\\s+\"[\\d.\\w-]+\"',\r\n                                     'VIAddVersionKey /LANG=${LANG_ENGLISH} \"ProductVersion\" \"' + full_version() + '\"', line)\r\n            found_version_key_product += subs\r\n            (line, subs) = re.subn(r'VIAddVersionKey\\s+/LANG=\\${LANG_ENGLISH}\\s+\"FileVersion\"\\s+\"[\\d.\\w-]+\"',\r\n                                    'VIAddVersionKey /LANG=${LANG_ENGLISH} \"FileVersion\" \"' + full_version() + '\"', line)\r\n            found_version_key_file    += subs\r\n            out_file.write(line)\r\nif found_outfile             != 1:\r\n    warn('found {} OutFile statements in HashCheck.nsi'.format(found_outfile))\r\nif found_product_version     != 1:\r\n    warn('found {} VIProductVersion\\'s in HashCheck.nsi'.format(found_product_version))\r\nif found_version_key_product != 1:\r\n    warn('found {} ProductVersion VIAddVersionKeys defines in HashCheck.nsi'.format(found_version_key_product))\r\nif found_version_key_file    != 1:\r\n    warn('found {} FileVersion VIAddVersionKeys defines in HashCheck.nsi'.format(found_version_key_file))\r\n\r\n# Lastly, update the one version line in appveyor\r\nfound_version = 0\r\nwith overwrite('appveyor.yml', encoding='utf-8', newline='') as out_file:\r\n    with open('appveyor.yml.orig', encoding='utf-8', newline='') as in_file:\r\n        for line in in_file:\r\n            (line, subs) = re.subn(r'^version:\\s*\\S+', 'version: ' + full_version(), line)\r\n            found_version += subs\r\n            out_file.write(line)\r\nif found_version != 1:\r\n    warn('found {} version lines in appveyor.yml'.format(found_version))\r\n\r\nprint('Done.')\r\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 1.62109375,
          "content": "/**\r\n * HashCheck Shell Extension\r\n * Original work copyright (C) Kai Liu.  All rights reserved.\r\n * Modified work copyright (C) 2014, 2016 Christopher Gurnee.  All rights reserved.\r\n * Modified work copyright (C) 2016 Tim Schlueter.  All rights reserved.\r\n *\r\n * Please refer to readme.txt for information about this source code.\r\n * Please refer to license.txt for details about distribution and modification.\r\n **/\r\n\r\n// Full name; this will appear in the version info and control panel\r\n#define HASHCHECK_NAME_STR \"HashCheck Shell Extension\"\r\n\r\n// Full version: MUST be in the form of major,minor,revision,build\r\n#define HASHCHECK_VERSION_FULL 2,4,0,55\r\n\r\n// String version: May be any suitable string\r\n#define HASHCHECK_VERSION_STR \"2.4.0.55\"\r\n\r\n#ifdef _USRDLL\r\n// PE version: MUST be in the form of major.minor\r\n#pragma comment(linker, \"/version:2.4\")\r\n#endif\r\n\r\n// Tail portion of the copyright string for the version resource\r\n#define HASHCHECK_COPYRIGHT_STR \"2008-2016 Kai Liu, Christopher Gurnee, Tim Schlueter, et al. All rights reserved.\"\r\n\r\n// Name of the DLL\r\n#define HASHCHECK_FILENAME_STR \"HashCheck.dll\"\r\n\r\n// Architecture names\r\n#if defined(_M_IX86)\r\n#define ARCH_NAME_TAIL \" (x86-32)\"\r\n#define ARCH_NAME_FULL \"x86-32\"\r\n#define ARCH_NAME_PART \"x86\"\r\n#elif defined(_M_AMD64) || defined(_M_X64)\r\n#define ARCH_NAME_TAIL \" (x86-64)\"\r\n#define ARCH_NAME_FULL \"x86-64\"\r\n#define ARCH_NAME_PART \"x64\"\r\n#elif defined(_M_IA64)\r\n#define ARCH_NAME_TAIL \" (IA-64)\"\r\n#define ARCH_NAME_FULL \"IA-64\"\r\n#define ARCH_NAME_PART ARCH_NAME_FULL\r\n#else\r\n#define ARCH_NAME_TAIL \"\"\r\n#define ARCH_NAME_FULL \"Unspecified\"\r\n#define ARCH_NAME_PART ARCH_NAME_FULL\r\n#endif\r\n"
        }
      ]
    }
  ]
}