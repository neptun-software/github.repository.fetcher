{
  "metadata": {
    "timestamp": 1736710104526,
    "page": 727,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjczMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "h2o/picohttpparser",
      "stars": 1870,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.1640625,
          "content": "# requires clang-format >= 3.6\nBasedOnStyle: \"LLVM\"\nIndentWidth: 4\nColumnLimit: 132\nBreakBeforeBraces: Linux\nAllowShortFunctionsOnASingleLine: None\nSortIncludes: false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0419921875,
          "content": "test-bin\nxcuserdata\n*.xccheckout\n.DS_Store\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0810546875,
          "content": "[submodule \"picotest\"]\n\tpath = picotest\n\turl = https://github.com/h2o/picotest.git\n"
        },
        {
          "name": "Jamfile",
          "type": "blob",
          "size": 0.15234375,
          "content": "project picohttpparser ;\n\nlib picohttpparser : picohttpparser.c ;\n\nunit-test test\n\t: picohttpparser picotest/picotest.c test.c\n\t: <testing.launcher>prove ;\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.5419921875,
          "content": "#\n# Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n#                         Shigeo Mitsunari\n#\n# The software is licensed under either the MIT License (below) or the Perl\n# license.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to\n# deal in the Software without restriction, including without limitation the\n# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n# sell copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n# IN THE SOFTWARE.\n\nCC?=gcc\nPROVE?=prove\nCFLAGS=-Wall -fsanitize=address,undefined\nTEST_ENV=\"UBSAN_OPTIONS=print_stacktrace=1:halt_on_error=1\"\n\nall:\n\ntest: test-bin\n\tenv $(TEST_ENV) $(PROVE) -v ./test-bin\n\ntest-bin: picohttpparser.c picotest/picotest.c test.c\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^\n\nclean:\n\trm -f test-bin\n\n.PHONY: test\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.2412109375,
          "content": "PicoHTTPParser\n=============\n\nCopyright (c) 2009-2014 [Kazuho Oku](https://github.com/kazuho), [Tokuhiro Matsuno](https://github.com/tokuhirom), [Daisuke Murase](https://github.com/typester), [Shigeo Mitsunari](https://github.com/herumi)\n\nPicoHTTPParser is a tiny, primitive, fast HTTP request/response parser.\n\nUnlike most parsers, it is stateless and does not allocate memory by itself.\nAll it does is accept pointer to buffer and the output structure, and setups the pointers in the latter to point at the necessary portions of the buffer.\n\nThe code is widely deployed within Perl applications through popular modules that use it, including [Plack](https://metacpan.org/pod/Plack), [Starman](https://metacpan.org/pod/Starman), [Starlet](https://metacpan.org/pod/Starlet), [Furl](https://metacpan.org/pod/Furl).  It is also the HTTP/1 parser of [H2O](https://github.com/h2o/h2o).\n\nCheck out [test.c] to find out how to use the parser.\n\nThe software is dual-licensed under the Perl License or the MIT License.\n\nUsage\n-----\n\nThe library exposes four functions: `phr_parse_request`, `phr_parse_response`, `phr_parse_headers`, `phr_decode_chunked`.\n\n### phr_parse_request\n\nThe example below reads an HTTP request from socket `sock` using `read(2)`, parses it using `phr_parse_request`, and prints the details.\n\n```c\nchar buf[4096], *method, *path;\nint pret, minor_version;\nstruct phr_header headers[100];\nsize_t buflen = 0, prevbuflen = 0, method_len, path_len, num_headers;\nssize_t rret;\n\nwhile (1) {\n    /* read the request */\n    while ((rret = read(sock, buf + buflen, sizeof(buf) - buflen)) == -1 && errno == EINTR)\n        ;\n    if (rret <= 0)\n        return IOError;\n    prevbuflen = buflen;\n    buflen += rret;\n    /* parse the request */\n    num_headers = sizeof(headers) / sizeof(headers[0]);\n    pret = phr_parse_request(buf, buflen, &method, &method_len, &path, &path_len,\n                             &minor_version, headers, &num_headers, prevbuflen);\n    if (pret > 0)\n        break; /* successfully parsed the request */\n    else if (pret == -1)\n        return ParseError;\n    /* request is incomplete, continue the loop */\n    assert(pret == -2);\n    if (buflen == sizeof(buf))\n        return RequestIsTooLongError;\n}\n\nprintf(\"request is %d bytes long\\n\", pret);\nprintf(\"method is %.*s\\n\", (int)method_len, method);\nprintf(\"path is %.*s\\n\", (int)path_len, path);\nprintf(\"HTTP version is 1.%d\\n\", minor_version);\nprintf(\"headers:\\n\");\nfor (i = 0; i != num_headers; ++i) {\n    printf(\"%.*s: %.*s\\n\", (int)headers[i].name_len, headers[i].name,\n           (int)headers[i].value_len, headers[i].value);\n}\n```\n\n### phr_parse_response, phr_parse_headers\n\n`phr_parse_response` and `phr_parse_headers` provide similar interfaces as `phr_parse_request`.  `phr_parse_response` parses an HTTP response, and `phr_parse_headers` parses the headers only.\n\n### phr_decode_chunked\n\nThe example below decodes incoming data in chunked-encoding.  The data is decoded in-place.\n\n```c\nstruct phr_chunked_decoder decoder = {}; /* zero-clear */\nchar *buf = malloc(4096);\nsize_t size = 0, capacity = 4096, rsize;\nssize_t rret, pret;\n\n/* set consume_trailer to 1 to discard the trailing header, or the application\n * should call phr_parse_headers to parse the trailing header */\ndecoder.consume_trailer = 1;\n\ndo {\n    /* expand the buffer if necessary */\n    if (size == capacity) {\n        capacity *= 2;\n        buf = realloc(buf, capacity);\n        assert(buf != NULL);\n    }\n    /* read */\n    while ((rret = read(sock, buf + size, capacity - size)) == -1 && errno == EINTR)\n        ;\n    if (rret <= 0)\n        return IOError;\n    /* decode */\n    rsize = rret;\n    pret = phr_decode_chunked(&decoder, buf + size, &rsize);\n    if (pret == -1)\n        return ParseError;\n    size += rsize;\n} while (pret == -2);\n\n/* successfully decoded the chunked data */\nassert(pret >= 0);\nprintf(\"decoded data is at %p (%zu bytes)\\n\", buf, size);\n```\n\nBenchmark\n---------\n\n![benchmark results](http://i.gyazo.com/a85c18d3162dfb46b485bb41e0ad443a.png)\n\nThe benchmark code is from [fukamachi/fast-http@6b91103](https://github.com/fukamachi/fast-http/tree/6b9110347c7a3407310c08979aefd65078518478).\n\nThe internals of picohttpparser has been described to some extent in [my blog entry]( http://blog.kazuhooku.com/2014/11/the-internals-h2o-or-how-to-write-fast.html).\n"
        },
        {
          "name": "bench.c",
          "type": "blob",
          "size": 3.6806640625,
          "content": "/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <assert.h>\n#include <stdio.h>\n#include \"picohttpparser.h\"\n\n#define REQ                                                                                                                        \\\n    \"GET /wp-content/uploads/2010/03/hello-kitty-darth-vader-pink.jpg HTTP/1.1\\r\\n\"                                                \\\n    \"Host: www.kittyhell.com\\r\\n\"                                                                                                  \\\n    \"User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; ja-JP-mac; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3 \"             \\\n    \"Pathtraq/0.9\\r\\n\"                                                                                                             \\\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\"                                                  \\\n    \"Accept-Language: ja,en-us;q=0.7,en;q=0.3\\r\\n\"                                                                                 \\\n    \"Accept-Encoding: gzip,deflate\\r\\n\"                                                                                            \\\n    \"Accept-Charset: Shift_JIS,utf-8;q=0.7,*;q=0.7\\r\\n\"                                                                            \\\n    \"Keep-Alive: 115\\r\\n\"                                                                                                          \\\n    \"Connection: keep-alive\\r\\n\"                                                                                                   \\\n    \"Cookie: wp_ozh_wsa_visits=2; wp_ozh_wsa_visit_lasttime=xxxxxxxxxx; \"                                                          \\\n    \"__utma=xxxxxxxxx.xxxxxxxxxx.xxxxxxxxxx.xxxxxxxxxx.xxxxxxxxxx.x; \"                                                             \\\n    \"__utmz=xxxxxxxxx.xxxxxxxxxx.x.x.utmccn=(referral)|utmcsr=reader.livedoor.com|utmcct=/reader/|utmcmd=referral\\r\\n\"             \\\n    \"\\r\\n\"\n\nint main(void)\n{\n    const char *method;\n    size_t method_len;\n    const char *path;\n    size_t path_len;\n    int minor_version;\n    struct phr_header headers[32];\n    size_t num_headers;\n    int i, ret;\n\n    for (i = 0; i < 10000000; i++) {\n        num_headers = sizeof(headers) / sizeof(headers[0]);\n        ret = phr_parse_request(REQ, sizeof(REQ) - 1, &method, &method_len, &path, &path_len, &minor_version, headers, &num_headers,\n                                0);\n        assert(ret == sizeof(REQ) - 1);\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "picohttpparser.c",
          "type": "blob",
          "size": 26.7236328125,
          "content": "/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include <assert.h>\n#include <stddef.h>\n#include <string.h>\n#ifdef __SSE4_2__\n#ifdef _MSC_VER\n#include <nmmintrin.h>\n#else\n#include <x86intrin.h>\n#endif\n#endif\n#include \"picohttpparser.h\"\n\n#if __GNUC__ >= 3\n#define likely(x) __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#else\n#define likely(x) (x)\n#define unlikely(x) (x)\n#endif\n\n#ifdef _MSC_VER\n#define ALIGNED(n) _declspec(align(n))\n#else\n#define ALIGNED(n) __attribute__((aligned(n)))\n#endif\n\n#define IS_PRINTABLE_ASCII(c) ((unsigned char)(c)-040u < 0137u)\n\n#define CHECK_EOF()                                                                                                                \\\n    if (buf == buf_end) {                                                                                                          \\\n        *ret = -2;                                                                                                                 \\\n        return NULL;                                                                                                               \\\n    }\n\n#define EXPECT_CHAR_NO_CHECK(ch)                                                                                                   \\\n    if (*buf++ != ch) {                                                                                                            \\\n        *ret = -1;                                                                                                                 \\\n        return NULL;                                                                                                               \\\n    }\n\n#define EXPECT_CHAR(ch)                                                                                                            \\\n    CHECK_EOF();                                                                                                                   \\\n    EXPECT_CHAR_NO_CHECK(ch);\n\n#define ADVANCE_TOKEN(tok, toklen)                                                                                                 \\\n    do {                                                                                                                           \\\n        const char *tok_start = buf;                                                                                               \\\n        static const char ALIGNED(16) ranges2[16] = \"\\000\\040\\177\\177\";                                                            \\\n        int found2;                                                                                                                \\\n        buf = findchar_fast(buf, buf_end, ranges2, 4, &found2);                                                                    \\\n        if (!found2) {                                                                                                             \\\n            CHECK_EOF();                                                                                                           \\\n        }                                                                                                                          \\\n        while (1) {                                                                                                                \\\n            if (*buf == ' ') {                                                                                                     \\\n                break;                                                                                                             \\\n            } else if (unlikely(!IS_PRINTABLE_ASCII(*buf))) {                                                                      \\\n                if ((unsigned char)*buf < '\\040' || *buf == '\\177') {                                                              \\\n                    *ret = -1;                                                                                                     \\\n                    return NULL;                                                                                                   \\\n                }                                                                                                                  \\\n            }                                                                                                                      \\\n            ++buf;                                                                                                                 \\\n            CHECK_EOF();                                                                                                           \\\n        }                                                                                                                          \\\n        tok = tok_start;                                                                                                           \\\n        toklen = buf - tok_start;                                                                                                  \\\n    } while (0)\n\nstatic const char *token_char_map = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n                                    \"\\0\\1\\0\\1\\1\\1\\1\\1\\0\\0\\1\\1\\0\\1\\1\\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\"\n                                    \"\\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\1\\1\"\n                                    \"\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\1\\0\\1\\0\"\n                                    \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n                                    \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n                                    \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n                                    \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\nstatic const char *findchar_fast(const char *buf, const char *buf_end, const char *ranges, size_t ranges_size, int *found)\n{\n    *found = 0;\n#if __SSE4_2__\n    if (likely(buf_end - buf >= 16)) {\n        __m128i ranges16 = _mm_loadu_si128((const __m128i *)ranges);\n\n        size_t left = (buf_end - buf) & ~15;\n        do {\n            __m128i b16 = _mm_loadu_si128((const __m128i *)buf);\n            int r = _mm_cmpestri(ranges16, ranges_size, b16, 16, _SIDD_LEAST_SIGNIFICANT | _SIDD_CMP_RANGES | _SIDD_UBYTE_OPS);\n            if (unlikely(r != 16)) {\n                buf += r;\n                *found = 1;\n                break;\n            }\n            buf += 16;\n            left -= 16;\n        } while (likely(left != 0));\n    }\n#else\n    /* suppress unused parameter warning */\n    (void)buf_end;\n    (void)ranges;\n    (void)ranges_size;\n#endif\n    return buf;\n}\n\nstatic const char *get_token_to_eol(const char *buf, const char *buf_end, const char **token, size_t *token_len, int *ret)\n{\n    const char *token_start = buf;\n\n#ifdef __SSE4_2__\n    static const char ALIGNED(16) ranges1[16] = \"\\0\\010\"    /* allow HT */\n                                                \"\\012\\037\"  /* allow SP and up to but not including DEL */\n                                                \"\\177\\177\"; /* allow chars w. MSB set */\n    int found;\n    buf = findchar_fast(buf, buf_end, ranges1, 6, &found);\n    if (found)\n        goto FOUND_CTL;\n#else\n    /* find non-printable char within the next 8 bytes, this is the hottest code; manually inlined */\n    while (likely(buf_end - buf >= 8)) {\n#define DOIT()                                                                                                                     \\\n    do {                                                                                                                           \\\n        if (unlikely(!IS_PRINTABLE_ASCII(*buf)))                                                                                   \\\n            goto NonPrintable;                                                                                                     \\\n        ++buf;                                                                                                                     \\\n    } while (0)\n        DOIT();\n        DOIT();\n        DOIT();\n        DOIT();\n        DOIT();\n        DOIT();\n        DOIT();\n        DOIT();\n#undef DOIT\n        continue;\n    NonPrintable:\n        if ((likely((unsigned char)*buf < '\\040') && likely(*buf != '\\011')) || unlikely(*buf == '\\177')) {\n            goto FOUND_CTL;\n        }\n        ++buf;\n    }\n#endif\n    for (;; ++buf) {\n        CHECK_EOF();\n        if (unlikely(!IS_PRINTABLE_ASCII(*buf))) {\n            if ((likely((unsigned char)*buf < '\\040') && likely(*buf != '\\011')) || unlikely(*buf == '\\177')) {\n                goto FOUND_CTL;\n            }\n        }\n    }\nFOUND_CTL:\n    if (likely(*buf == '\\015')) {\n        ++buf;\n        EXPECT_CHAR('\\012');\n        *token_len = buf - 2 - token_start;\n    } else if (*buf == '\\012') {\n        *token_len = buf - token_start;\n        ++buf;\n    } else {\n        *ret = -1;\n        return NULL;\n    }\n    *token = token_start;\n\n    return buf;\n}\n\nstatic const char *is_complete(const char *buf, const char *buf_end, size_t last_len, int *ret)\n{\n    int ret_cnt = 0;\n    buf = last_len < 3 ? buf : buf + last_len - 3;\n\n    while (1) {\n        CHECK_EOF();\n        if (*buf == '\\015') {\n            ++buf;\n            CHECK_EOF();\n            EXPECT_CHAR('\\012');\n            ++ret_cnt;\n        } else if (*buf == '\\012') {\n            ++buf;\n            ++ret_cnt;\n        } else {\n            ++buf;\n            ret_cnt = 0;\n        }\n        if (ret_cnt == 2) {\n            return buf;\n        }\n    }\n\n    *ret = -2;\n    return NULL;\n}\n\n#define PARSE_INT(valp_, mul_)                                                                                                     \\\n    if (*buf < '0' || '9' < *buf) {                                                                                                \\\n        buf++;                                                                                                                     \\\n        *ret = -1;                                                                                                                 \\\n        return NULL;                                                                                                               \\\n    }                                                                                                                              \\\n    *(valp_) = (mul_) * (*buf++ - '0');\n\n#define PARSE_INT_3(valp_)                                                                                                         \\\n    do {                                                                                                                           \\\n        int res_ = 0;                                                                                                              \\\n        PARSE_INT(&res_, 100)                                                                                                      \\\n        *valp_ = res_;                                                                                                             \\\n        PARSE_INT(&res_, 10)                                                                                                       \\\n        *valp_ += res_;                                                                                                            \\\n        PARSE_INT(&res_, 1)                                                                                                        \\\n        *valp_ += res_;                                                                                                            \\\n    } while (0)\n\n/* returned pointer is always within [buf, buf_end), or null */\nstatic const char *parse_token(const char *buf, const char *buf_end, const char **token, size_t *token_len, char next_char,\n                               int *ret)\n{\n    /* We use pcmpestri to detect non-token characters. This instruction can take no more than eight character ranges (8*2*8=128\n     * bits that is the size of a SSE register). Due to this restriction, characters `|` and `~` are handled in the slow loop. */\n    static const char ALIGNED(16) ranges[] = \"\\x00 \"  /* control chars and up to SP */\n                                             \"\\\"\\\"\"   /* 0x22 */\n                                             \"()\"     /* 0x28,0x29 */\n                                             \",,\"     /* 0x2c */\n                                             \"//\"     /* 0x2f */\n                                             \":@\"     /* 0x3a-0x40 */\n                                             \"[]\"     /* 0x5b-0x5d */\n                                             \"{\\xff\"; /* 0x7b-0xff */\n    const char *buf_start = buf;\n    int found;\n    buf = findchar_fast(buf, buf_end, ranges, sizeof(ranges) - 1, &found);\n    if (!found) {\n        CHECK_EOF();\n    }\n    while (1) {\n        if (*buf == next_char) {\n            break;\n        } else if (!token_char_map[(unsigned char)*buf]) {\n            *ret = -1;\n            return NULL;\n        }\n        ++buf;\n        CHECK_EOF();\n    }\n    *token = buf_start;\n    *token_len = buf - buf_start;\n    return buf;\n}\n\n/* returned pointer is always within [buf, buf_end), or null */\nstatic const char *parse_http_version(const char *buf, const char *buf_end, int *minor_version, int *ret)\n{\n    /* we want at least [HTTP/1.<two chars>] to try to parse */\n    if (buf_end - buf < 9) {\n        *ret = -2;\n        return NULL;\n    }\n    EXPECT_CHAR_NO_CHECK('H');\n    EXPECT_CHAR_NO_CHECK('T');\n    EXPECT_CHAR_NO_CHECK('T');\n    EXPECT_CHAR_NO_CHECK('P');\n    EXPECT_CHAR_NO_CHECK('/');\n    EXPECT_CHAR_NO_CHECK('1');\n    EXPECT_CHAR_NO_CHECK('.');\n    PARSE_INT(minor_version, 1);\n    return buf;\n}\n\nstatic const char *parse_headers(const char *buf, const char *buf_end, struct phr_header *headers, size_t *num_headers,\n                                 size_t max_headers, int *ret)\n{\n    for (;; ++*num_headers) {\n        CHECK_EOF();\n        if (*buf == '\\015') {\n            ++buf;\n            EXPECT_CHAR('\\012');\n            break;\n        } else if (*buf == '\\012') {\n            ++buf;\n            break;\n        }\n        if (*num_headers == max_headers) {\n            *ret = -1;\n            return NULL;\n        }\n        if (!(*num_headers != 0 && (*buf == ' ' || *buf == '\\t'))) {\n            /* parsing name, but do not discard SP before colon, see\n             * http://www.mozilla.org/security/announce/2006/mfsa2006-33.html */\n            if ((buf = parse_token(buf, buf_end, &headers[*num_headers].name, &headers[*num_headers].name_len, ':', ret)) == NULL) {\n                return NULL;\n            }\n            if (headers[*num_headers].name_len == 0) {\n                *ret = -1;\n                return NULL;\n            }\n            ++buf;\n            for (;; ++buf) {\n                CHECK_EOF();\n                if (!(*buf == ' ' || *buf == '\\t')) {\n                    break;\n                }\n            }\n        } else {\n            headers[*num_headers].name = NULL;\n            headers[*num_headers].name_len = 0;\n        }\n        const char *value;\n        size_t value_len;\n        if ((buf = get_token_to_eol(buf, buf_end, &value, &value_len, ret)) == NULL) {\n            return NULL;\n        }\n        /* remove trailing SPs and HTABs */\n        const char *value_end = value + value_len;\n        for (; value_end != value; --value_end) {\n            const char c = *(value_end - 1);\n            if (!(c == ' ' || c == '\\t')) {\n                break;\n            }\n        }\n        headers[*num_headers].value = value;\n        headers[*num_headers].value_len = value_end - value;\n    }\n    return buf;\n}\n\nstatic const char *parse_request(const char *buf, const char *buf_end, const char **method, size_t *method_len, const char **path,\n                                 size_t *path_len, int *minor_version, struct phr_header *headers, size_t *num_headers,\n                                 size_t max_headers, int *ret)\n{\n    /* skip first empty line (some clients add CRLF after POST content) */\n    CHECK_EOF();\n    if (*buf == '\\015') {\n        ++buf;\n        EXPECT_CHAR('\\012');\n    } else if (*buf == '\\012') {\n        ++buf;\n    }\n\n    /* parse request line */\n    if ((buf = parse_token(buf, buf_end, method, method_len, ' ', ret)) == NULL) {\n        return NULL;\n    }\n    do {\n        ++buf;\n        CHECK_EOF();\n    } while (*buf == ' ');\n    ADVANCE_TOKEN(*path, *path_len);\n    do {\n        ++buf;\n        CHECK_EOF();\n    } while (*buf == ' ');\n    if (*method_len == 0 || *path_len == 0) {\n        *ret = -1;\n        return NULL;\n    }\n    if ((buf = parse_http_version(buf, buf_end, minor_version, ret)) == NULL) {\n        return NULL;\n    }\n    if (*buf == '\\015') {\n        ++buf;\n        EXPECT_CHAR('\\012');\n    } else if (*buf == '\\012') {\n        ++buf;\n    } else {\n        *ret = -1;\n        return NULL;\n    }\n\n    return parse_headers(buf, buf_end, headers, num_headers, max_headers, ret);\n}\n\nint phr_parse_request(const char *buf_start, size_t len, const char **method, size_t *method_len, const char **path,\n                      size_t *path_len, int *minor_version, struct phr_header *headers, size_t *num_headers, size_t last_len)\n{\n    const char *buf = buf_start, *buf_end = buf_start + len;\n    size_t max_headers = *num_headers;\n    int r;\n\n    *method = NULL;\n    *method_len = 0;\n    *path = NULL;\n    *path_len = 0;\n    *minor_version = -1;\n    *num_headers = 0;\n\n    /* if last_len != 0, check if the request is complete (a fast countermeasure\n       againt slowloris */\n    if (last_len != 0 && is_complete(buf, buf_end, last_len, &r) == NULL) {\n        return r;\n    }\n\n    if ((buf = parse_request(buf, buf_end, method, method_len, path, path_len, minor_version, headers, num_headers, max_headers,\n                             &r)) == NULL) {\n        return r;\n    }\n\n    return (int)(buf - buf_start);\n}\n\nstatic const char *parse_response(const char *buf, const char *buf_end, int *minor_version, int *status, const char **msg,\n                                  size_t *msg_len, struct phr_header *headers, size_t *num_headers, size_t max_headers, int *ret)\n{\n    /* parse \"HTTP/1.x\" */\n    if ((buf = parse_http_version(buf, buf_end, minor_version, ret)) == NULL) {\n        return NULL;\n    }\n    /* skip space */\n    if (*buf != ' ') {\n        *ret = -1;\n        return NULL;\n    }\n    do {\n        ++buf;\n        CHECK_EOF();\n    } while (*buf == ' ');\n    /* parse status code, we want at least [:digit:][:digit:][:digit:]<other char> to try to parse */\n    if (buf_end - buf < 4) {\n        *ret = -2;\n        return NULL;\n    }\n    PARSE_INT_3(status);\n\n    /* get message including preceding space */\n    if ((buf = get_token_to_eol(buf, buf_end, msg, msg_len, ret)) == NULL) {\n        return NULL;\n    }\n    if (*msg_len == 0) {\n        /* ok */\n    } else if (**msg == ' ') {\n        /* Remove preceding space. Successful return from `get_token_to_eol` guarantees that we would hit something other than SP\n         * before running past the end of the given buffer. */\n        do {\n            ++*msg;\n            --*msg_len;\n        } while (**msg == ' ');\n    } else {\n        /* garbage found after status code */\n        *ret = -1;\n        return NULL;\n    }\n\n    return parse_headers(buf, buf_end, headers, num_headers, max_headers, ret);\n}\n\nint phr_parse_response(const char *buf_start, size_t len, int *minor_version, int *status, const char **msg, size_t *msg_len,\n                       struct phr_header *headers, size_t *num_headers, size_t last_len)\n{\n    const char *buf = buf_start, *buf_end = buf + len;\n    size_t max_headers = *num_headers;\n    int r;\n\n    *minor_version = -1;\n    *status = 0;\n    *msg = NULL;\n    *msg_len = 0;\n    *num_headers = 0;\n\n    /* if last_len != 0, check if the response is complete (a fast countermeasure\n       against slowloris */\n    if (last_len != 0 && is_complete(buf, buf_end, last_len, &r) == NULL) {\n        return r;\n    }\n\n    if ((buf = parse_response(buf, buf_end, minor_version, status, msg, msg_len, headers, num_headers, max_headers, &r)) == NULL) {\n        return r;\n    }\n\n    return (int)(buf - buf_start);\n}\n\nint phr_parse_headers(const char *buf_start, size_t len, struct phr_header *headers, size_t *num_headers, size_t last_len)\n{\n    const char *buf = buf_start, *buf_end = buf + len;\n    size_t max_headers = *num_headers;\n    int r;\n\n    *num_headers = 0;\n\n    /* if last_len != 0, check if the response is complete (a fast countermeasure\n       against slowloris */\n    if (last_len != 0 && is_complete(buf, buf_end, last_len, &r) == NULL) {\n        return r;\n    }\n\n    if ((buf = parse_headers(buf, buf_end, headers, num_headers, max_headers, &r)) == NULL) {\n        return r;\n    }\n\n    return (int)(buf - buf_start);\n}\n\nenum {\n    CHUNKED_IN_CHUNK_SIZE,\n    CHUNKED_IN_CHUNK_EXT,\n    CHUNKED_IN_CHUNK_DATA,\n    CHUNKED_IN_CHUNK_CRLF,\n    CHUNKED_IN_TRAILERS_LINE_HEAD,\n    CHUNKED_IN_TRAILERS_LINE_MIDDLE\n};\n\nstatic int decode_hex(int ch)\n{\n    if ('0' <= ch && ch <= '9') {\n        return ch - '0';\n    } else if ('A' <= ch && ch <= 'F') {\n        return ch - 'A' + 0xa;\n    } else if ('a' <= ch && ch <= 'f') {\n        return ch - 'a' + 0xa;\n    } else {\n        return -1;\n    }\n}\n\nssize_t phr_decode_chunked(struct phr_chunked_decoder *decoder, char *buf, size_t *_bufsz)\n{\n    size_t dst = 0, src = 0, bufsz = *_bufsz;\n    ssize_t ret = -2; /* incomplete */\n\n    decoder->_total_read += bufsz;\n\n    while (1) {\n        switch (decoder->_state) {\n        case CHUNKED_IN_CHUNK_SIZE:\n            for (;; ++src) {\n                int v;\n                if (src == bufsz)\n                    goto Exit;\n                if ((v = decode_hex(buf[src])) == -1) {\n                    if (decoder->_hex_count == 0) {\n                        ret = -1;\n                        goto Exit;\n                    }\n                    /* the only characters that may appear after the chunk size are BWS, semicolon, or CRLF */\n                    switch (buf[src]) {\n                    case ' ':\n                    case '\\011':\n                    case ';':\n                    case '\\012':\n                    case '\\015':\n                        break;\n                    default:\n                        ret = -1;\n                        goto Exit;\n                    }\n                    break;\n                }\n                if (decoder->_hex_count == sizeof(size_t) * 2) {\n                    ret = -1;\n                    goto Exit;\n                }\n                decoder->bytes_left_in_chunk = decoder->bytes_left_in_chunk * 16 + v;\n                ++decoder->_hex_count;\n            }\n            decoder->_hex_count = 0;\n            decoder->_state = CHUNKED_IN_CHUNK_EXT;\n        /* fallthru */\n        case CHUNKED_IN_CHUNK_EXT:\n            /* RFC 7230 A.2 \"Line folding in chunk extensions is disallowed\" */\n            for (;; ++src) {\n                if (src == bufsz)\n                    goto Exit;\n                if (buf[src] == '\\012')\n                    break;\n            }\n            ++src;\n            if (decoder->bytes_left_in_chunk == 0) {\n                if (decoder->consume_trailer) {\n                    decoder->_state = CHUNKED_IN_TRAILERS_LINE_HEAD;\n                    break;\n                } else {\n                    goto Complete;\n                }\n            }\n            decoder->_state = CHUNKED_IN_CHUNK_DATA;\n        /* fallthru */\n        case CHUNKED_IN_CHUNK_DATA: {\n            size_t avail = bufsz - src;\n            if (avail < decoder->bytes_left_in_chunk) {\n                if (dst != src)\n                    memmove(buf + dst, buf + src, avail);\n                src += avail;\n                dst += avail;\n                decoder->bytes_left_in_chunk -= avail;\n                goto Exit;\n            }\n            if (dst != src)\n                memmove(buf + dst, buf + src, decoder->bytes_left_in_chunk);\n            src += decoder->bytes_left_in_chunk;\n            dst += decoder->bytes_left_in_chunk;\n            decoder->bytes_left_in_chunk = 0;\n            decoder->_state = CHUNKED_IN_CHUNK_CRLF;\n        }\n        /* fallthru */\n        case CHUNKED_IN_CHUNK_CRLF:\n            for (;; ++src) {\n                if (src == bufsz)\n                    goto Exit;\n                if (buf[src] != '\\015')\n                    break;\n            }\n            if (buf[src] != '\\012') {\n                ret = -1;\n                goto Exit;\n            }\n            ++src;\n            decoder->_state = CHUNKED_IN_CHUNK_SIZE;\n            break;\n        case CHUNKED_IN_TRAILERS_LINE_HEAD:\n            for (;; ++src) {\n                if (src == bufsz)\n                    goto Exit;\n                if (buf[src] != '\\015')\n                    break;\n            }\n            if (buf[src++] == '\\012')\n                goto Complete;\n            decoder->_state = CHUNKED_IN_TRAILERS_LINE_MIDDLE;\n        /* fallthru */\n        case CHUNKED_IN_TRAILERS_LINE_MIDDLE:\n            for (;; ++src) {\n                if (src == bufsz)\n                    goto Exit;\n                if (buf[src] == '\\012')\n                    break;\n            }\n            ++src;\n            decoder->_state = CHUNKED_IN_TRAILERS_LINE_HEAD;\n            break;\n        default:\n            assert(!\"decoder is corrupt\");\n        }\n    }\n\nComplete:\n    ret = bufsz - src;\nExit:\n    if (dst != src)\n        memmove(buf + dst, buf + src, bufsz - src);\n    *_bufsz = dst;\n    /* if incomplete but the overhead of the chunked encoding is >=100KB and >80%, signal an error */\n    if (ret == -2) {\n        decoder->_total_overhead += bufsz - dst;\n        if (decoder->_total_overhead >= 100 * 1024 && decoder->_total_read - decoder->_total_overhead < decoder->_total_read / 4)\n            ret = -1;\n    }\n    return ret;\n}\n\nint phr_decode_chunked_is_in_data(struct phr_chunked_decoder *decoder)\n{\n    return decoder->_state == CHUNKED_IN_CHUNK_DATA;\n}\n\n#undef CHECK_EOF\n#undef EXPECT_CHAR\n#undef ADVANCE_TOKEN\n"
        },
        {
          "name": "picohttpparser.h",
          "type": "blob",
          "size": 3.4541015625,
          "content": "/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#ifndef picohttpparser_h\n#define picohttpparser_h\n\n#include <stdint.h>\n#include <sys/types.h>\n\n#ifdef _MSC_VER\n#define ssize_t intptr_t\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* contains name and value of a header (name == NULL if is a continuing line\n * of a multiline header */\nstruct phr_header {\n    const char *name;\n    size_t name_len;\n    const char *value;\n    size_t value_len;\n};\n\n/* returns number of bytes consumed if successful, -2 if request is partial,\n * -1 if failed */\nint phr_parse_request(const char *buf, size_t len, const char **method, size_t *method_len, const char **path, size_t *path_len,\n                      int *minor_version, struct phr_header *headers, size_t *num_headers, size_t last_len);\n\n/* ditto */\nint phr_parse_response(const char *_buf, size_t len, int *minor_version, int *status, const char **msg, size_t *msg_len,\n                       struct phr_header *headers, size_t *num_headers, size_t last_len);\n\n/* ditto */\nint phr_parse_headers(const char *buf, size_t len, struct phr_header *headers, size_t *num_headers, size_t last_len);\n\n/* should be zero-filled before start */\nstruct phr_chunked_decoder {\n    size_t bytes_left_in_chunk; /* number of bytes left in current chunk */\n    char consume_trailer;       /* if trailing headers should be consumed */\n    char _hex_count;\n    char _state;\n    uint64_t _total_read;\n    uint64_t _total_overhead;\n};\n\n/* the function rewrites the buffer given as (buf, bufsz) removing the chunked-\n * encoding headers.  When the function returns without an error, bufsz is\n * updated to the length of the decoded data available.  Applications should\n * repeatedly call the function while it returns -2 (incomplete) every time\n * supplying newly arrived data.  If the end of the chunked-encoded data is\n * found, the function returns a non-negative number indicating the number of\n * octets left undecoded, that starts from the offset returned by `*bufsz`.\n * Returns -1 on error.\n */\nssize_t phr_decode_chunked(struct phr_chunked_decoder *decoder, char *buf, size_t *bufsz);\n\n/* returns if the chunked decoder is in middle of chunked data */\nint phr_decode_chunked_is_in_data(struct phr_chunked_decoder *decoder);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "picohttpparser.xcodeproj",
          "type": "tree",
          "content": null
        },
        {
          "name": "picotest",
          "type": "commit",
          "content": null
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 21.3623046875,
          "content": "/* use `make test` to run the test */\n/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"picotest/picotest.h\"\n#include \"picohttpparser.h\"\n\nstatic int bufis(const char *s, size_t l, const char *t)\n{\n    return strlen(t) == l && memcmp(s, t, l) == 0;\n}\n\nstatic char *inputbuf; /* point to the end of the buffer */\n\nstatic void test_request(void)\n{\n    const char *method;\n    size_t method_len;\n    const char *path;\n    size_t path_len;\n    int minor_version;\n    struct phr_header headers[4];\n    size_t num_headers;\n\n#define PARSE(s, last_len, exp, comment)                                                                                           \\\n    do {                                                                                                                           \\\n        size_t slen = sizeof(s) - 1;                                                                                               \\\n        note(comment);                                                                                                             \\\n        num_headers = sizeof(headers) / sizeof(headers[0]);                                                                        \\\n        memcpy(inputbuf - slen, s, slen);                                                                                          \\\n        ok(phr_parse_request(inputbuf - slen, slen, &method, &method_len, &path, &path_len, &minor_version, headers, &num_headers, \\\n                             last_len) == (exp == 0 ? (int)slen : exp));                                                           \\\n    } while (0)\n\n    PARSE(\"GET / HTTP/1.0\\r\\n\\r\\n\", 0, 0, \"simple\");\n    ok(num_headers == 0);\n    ok(bufis(method, method_len, \"GET\"));\n    ok(bufis(path, path_len, \"/\"));\n    ok(minor_version == 0);\n\n    PARSE(\"GET / HTTP/1.0\\r\\n\\r\", 0, -2, \"partial\");\n\n    PARSE(\"GET /hoge HTTP/1.1\\r\\nHost: example.com\\r\\nCookie: \\r\\n\\r\\n\", 0, 0, \"parse headers\");\n    ok(num_headers == 2);\n    ok(bufis(method, method_len, \"GET\"));\n    ok(bufis(path, path_len, \"/hoge\"));\n    ok(minor_version == 1);\n    ok(bufis(headers[0].name, headers[0].name_len, \"Host\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"example.com\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"Cookie\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"\"));\n\n    PARSE(\"GET /hoge HTTP/1.1\\r\\nHost: example.com\\r\\nUser-Agent: \\343\\201\\262\\343/1.0\\r\\n\\r\\n\", 0, 0, \"multibyte included\");\n    ok(num_headers == 2);\n    ok(bufis(method, method_len, \"GET\"));\n    ok(bufis(path, path_len, \"/hoge\"));\n    ok(minor_version == 1);\n    ok(bufis(headers[0].name, headers[0].name_len, \"Host\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"example.com\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"User-Agent\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"\\343\\201\\262\\343/1.0\"));\n\n    PARSE(\"GET / HTTP/1.0\\r\\nfoo: \\r\\nfoo: b\\r\\n  \\tc\\r\\n\\r\\n\", 0, 0, \"parse multiline\");\n    ok(num_headers == 3);\n    ok(bufis(method, method_len, \"GET\"));\n    ok(bufis(path, path_len, \"/\"));\n    ok(minor_version == 0);\n    ok(bufis(headers[0].name, headers[0].name_len, \"foo\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"foo\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"b\"));\n    ok(headers[2].name == NULL);\n    ok(bufis(headers[2].value, headers[2].value_len, \"  \\tc\"));\n\n    PARSE(\"GET / HTTP/1.0\\r\\nfoo : ab\\r\\n\\r\\n\", 0, -1, \"parse header name with trailing space\");\n\n    PARSE(\"GET\", 0, -2, \"incomplete 1\");\n    ok(method == NULL);\n    PARSE(\"GET \", 0, -2, \"incomplete 2\");\n    ok(bufis(method, method_len, \"GET\"));\n    PARSE(\"GET /\", 0, -2, \"incomplete 3\");\n    ok(path == NULL);\n    PARSE(\"GET / \", 0, -2, \"incomplete 4\");\n    ok(bufis(path, path_len, \"/\"));\n    PARSE(\"GET / H\", 0, -2, \"incomplete 5\");\n    PARSE(\"GET / HTTP/1.\", 0, -2, \"incomplete 6\");\n    PARSE(\"GET / HTTP/1.0\", 0, -2, \"incomplete 7\");\n    ok(minor_version == -1);\n    PARSE(\"GET / HTTP/1.0\\r\", 0, -2, \"incomplete 8\");\n    ok(minor_version == 0);\n\n    PARSE(\"GET /hoge HTTP/1.0\\r\\n\\r\", strlen(\"GET /hoge HTTP/1.0\\r\\n\\r\") - 1, -2, \"slowloris (incomplete)\");\n    PARSE(\"GET /hoge HTTP/1.0\\r\\n\\r\\n\", strlen(\"GET /hoge HTTP/1.0\\r\\n\\r\\n\") - 1, 0, \"slowloris (complete)\");\n\n    PARSE(\" / HTTP/1.0\\r\\n\\r\\n\", 0, -1, \"empty method\");\n    PARSE(\"GET  HTTP/1.0\\r\\n\\r\\n\", 0, -1, \"empty request-target\");\n\n    PARSE(\"GET / HTTP/1.0\\r\\n:a\\r\\n\\r\\n\", 0, -1, \"empty header name\");\n    PARSE(\"GET / HTTP/1.0\\r\\n :a\\r\\n\\r\\n\", 0, -1, \"header name (space only)\");\n\n    PARSE(\"G\\0T / HTTP/1.0\\r\\n\\r\\n\", 0, -1, \"NUL in method\");\n    PARSE(\"G\\tT / HTTP/1.0\\r\\n\\r\\n\", 0, -1, \"tab in method\");\n    PARSE(\":GET / HTTP/1.0\\r\\n\\r\\n\", 0, -1, \"invalid method\");\n    PARSE(\"GET /\\x7fhello HTTP/1.0\\r\\n\\r\\n\", 0, -1, \"DEL in uri-path\");\n    PARSE(\"GET / HTTP/1.0\\r\\na\\0b: c\\r\\n\\r\\n\", 0, -1, \"NUL in header name\");\n    PARSE(\"GET / HTTP/1.0\\r\\nab: c\\0d\\r\\n\\r\\n\", 0, -1, \"NUL in header value\");\n    PARSE(\"GET / HTTP/1.0\\r\\na\\033b: c\\r\\n\\r\\n\", 0, -1, \"CTL in header name\");\n    PARSE(\"GET / HTTP/1.0\\r\\nab: c\\033\\r\\n\\r\\n\", 0, -1, \"CTL in header value\");\n    PARSE(\"GET / HTTP/1.0\\r\\n/: 1\\r\\n\\r\\n\", 0, -1, \"invalid char in header value\");\n    PARSE(\"GET /\\xa0 HTTP/1.0\\r\\nh: c\\xa2y\\r\\n\\r\\n\", 0, 0, \"accept MSB chars\");\n    ok(num_headers == 1);\n    ok(bufis(method, method_len, \"GET\"));\n    ok(bufis(path, path_len, \"/\\xa0\"));\n    ok(minor_version == 0);\n    ok(bufis(headers[0].name, headers[0].name_len, \"h\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"c\\xa2y\"));\n\n    PARSE(\"GET / HTTP/1.0\\r\\n\\x7c\\x7e: 1\\r\\n\\r\\n\", 0, 0, \"accept |~ (though forbidden by SSE)\");\n    ok(num_headers == 1);\n    ok(bufis(headers[0].name, headers[0].name_len, \"\\x7c\\x7e\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"1\"));\n\n    PARSE(\"GET / HTTP/1.0\\r\\n\\x7b: 1\\r\\n\\r\\n\", 0, -1, \"disallow {\");\n\n    PARSE(\"GET / HTTP/1.0\\r\\nfoo: a \\t \\r\\n\\r\\n\", 0, 0, \"exclude leading and trailing spaces in header value\");\n    ok(bufis(headers[0].value, headers[0].value_len, \"a\"));\n\n    PARSE(\"GET   /   HTTP/1.0\\r\\n\\r\\n\", 0, 0, \"accept multiple spaces between tokens\");\n\n#undef PARSE\n}\n\nstatic void test_response(void)\n{\n    int minor_version;\n    int status;\n    const char *msg;\n    size_t msg_len;\n    struct phr_header headers[4];\n    size_t num_headers;\n\n#define PARSE(s, last_len, exp, comment)                                                                                           \\\n    do {                                                                                                                           \\\n        size_t slen = sizeof(s) - 1;                                                                                               \\\n        note(comment);                                                                                                             \\\n        num_headers = sizeof(headers) / sizeof(headers[0]);                                                                        \\\n        memcpy(inputbuf - slen, s, slen);                                                                                          \\\n        ok(phr_parse_response(inputbuf - slen, slen, &minor_version, &status, &msg, &msg_len, headers, &num_headers, last_len) ==  \\\n           (exp == 0 ? (int)slen : exp));                                                                                          \\\n    } while (0)\n\n    PARSE(\"HTTP/1.0 200 OK\\r\\n\\r\\n\", 0, 0, \"simple\");\n    ok(num_headers == 0);\n    ok(status == 200);\n    ok(minor_version == 0);\n    ok(bufis(msg, msg_len, \"OK\"));\n\n    PARSE(\"HTTP/1.0 200 OK\\r\\n\\r\", 0, -2, \"partial\");\n\n    PARSE(\"HTTP/1.1 200 OK\\r\\nHost: example.com\\r\\nCookie: \\r\\n\\r\\n\", 0, 0, \"parse headers\");\n    ok(num_headers == 2);\n    ok(minor_version == 1);\n    ok(status == 200);\n    ok(bufis(msg, msg_len, \"OK\"));\n    ok(bufis(headers[0].name, headers[0].name_len, \"Host\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"example.com\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"Cookie\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"\"));\n\n    PARSE(\"HTTP/1.0 200 OK\\r\\nfoo: \\r\\nfoo: b\\r\\n  \\tc\\r\\n\\r\\n\", 0, 0, \"parse multiline\");\n    ok(num_headers == 3);\n    ok(minor_version == 0);\n    ok(status == 200);\n    ok(bufis(msg, msg_len, \"OK\"));\n    ok(bufis(headers[0].name, headers[0].name_len, \"foo\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"foo\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"b\"));\n    ok(headers[2].name == NULL);\n    ok(bufis(headers[2].value, headers[2].value_len, \"  \\tc\"));\n\n    PARSE(\"HTTP/1.0 500 Internal Server Error\\r\\n\\r\\n\", 0, 0, \"internal server error\");\n    ok(num_headers == 0);\n    ok(minor_version == 0);\n    ok(status == 500);\n    ok(bufis(msg, msg_len, \"Internal Server Error\"));\n    ok(msg_len == sizeof(\"Internal Server Error\") - 1);\n\n    PARSE(\"H\", 0, -2, \"incomplete 1\");\n    PARSE(\"HTTP/1.\", 0, -2, \"incomplete 2\");\n    PARSE(\"HTTP/1.1\", 0, -2, \"incomplete 3\");\n    ok(minor_version == -1);\n    PARSE(\"HTTP/1.1 \", 0, -2, \"incomplete 4\");\n    ok(minor_version == 1);\n    PARSE(\"HTTP/1.1 2\", 0, -2, \"incomplete 5\");\n    PARSE(\"HTTP/1.1 200\", 0, -2, \"incomplete 6\");\n    ok(status == 0);\n    PARSE(\"HTTP/1.1 200 \", 0, -2, \"incomplete 7\");\n    ok(status == 200);\n    PARSE(\"HTTP/1.1 200 O\", 0, -2, \"incomplete 8\");\n    PARSE(\"HTTP/1.1 200 OK\\r\", 0, -2, \"incomplete 9\");\n    ok(msg == NULL);\n    PARSE(\"HTTP/1.1 200 OK\\r\\n\", 0, -2, \"incomplete 10\");\n    ok(bufis(msg, msg_len, \"OK\"));\n    PARSE(\"HTTP/1.1 200 OK\\n\", 0, -2, \"incomplete 11\");\n    ok(bufis(msg, msg_len, \"OK\"));\n\n    PARSE(\"HTTP/1.1 200 OK\\r\\nA: 1\\r\", 0, -2, \"incomplete 11\");\n    ok(num_headers == 0);\n    PARSE(\"HTTP/1.1 200 OK\\r\\nA: 1\\r\\n\", 0, -2, \"incomplete 12\");\n    ok(num_headers == 1);\n    ok(bufis(headers[0].name, headers[0].name_len, \"A\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"1\"));\n\n    PARSE(\"HTTP/1.0 200 OK\\r\\n\\r\", strlen(\"HTTP/1.0 200 OK\\r\\n\\r\") - 1, -2, \"slowloris (incomplete)\");\n    PARSE(\"HTTP/1.0 200 OK\\r\\n\\r\\n\", strlen(\"HTTP/1.0 200 OK\\r\\n\\r\\n\") - 1, 0, \"slowloris (complete)\");\n\n    PARSE(\"HTTP/1. 200 OK\\r\\n\\r\\n\", 0, -1, \"invalid http version\");\n    PARSE(\"HTTP/1.2z 200 OK\\r\\n\\r\\n\", 0, -1, \"invalid http version 2\");\n    PARSE(\"HTTP/1.1  OK\\r\\n\\r\\n\", 0, -1, \"no status code\");\n\n    PARSE(\"HTTP/1.1 200\\r\\n\\r\\n\", 0, 0, \"accept missing trailing whitespace in status-line\");\n    ok(bufis(msg, msg_len, \"\"));\n    PARSE(\"HTTP/1.1 200X\\r\\n\\r\\n\", 0, -1, \"garbage after status 1\");\n    PARSE(\"HTTP/1.1 200X \\r\\n\\r\\n\", 0, -1, \"garbage after status 2\");\n    PARSE(\"HTTP/1.1 200X OK\\r\\n\\r\\n\", 0, -1, \"garbage after status 3\");\n\n    PARSE(\"HTTP/1.1 200 OK\\r\\nbar: \\t b\\t \\t\\r\\n\\r\\n\", 0, 0, \"exclude leading and trailing spaces in header value\");\n    ok(bufis(headers[0].value, headers[0].value_len, \"b\"));\n\n    PARSE(\"HTTP/1.1   200   OK\\r\\n\\r\\n\", 0, 0, \"accept multiple spaces between tokens\");\n\n#undef PARSE\n}\n\nstatic void test_headers(void)\n{\n    /* only test the interface; the core parser is tested by the tests above */\n\n    struct phr_header headers[4];\n    size_t num_headers;\n\n#define PARSE(s, last_len, exp, comment)                                                                                           \\\n    do {                                                                                                                           \\\n        note(comment);                                                                                                             \\\n        num_headers = sizeof(headers) / sizeof(headers[0]);                                                                        \\\n        ok(phr_parse_headers(s, strlen(s), headers, &num_headers, last_len) == (exp == 0 ? (int)strlen(s) : exp));                 \\\n    } while (0)\n\n    PARSE(\"Host: example.com\\r\\nCookie: \\r\\n\\r\\n\", 0, 0, \"simple\");\n    ok(num_headers == 2);\n    ok(bufis(headers[0].name, headers[0].name_len, \"Host\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"example.com\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"Cookie\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"\"));\n\n    PARSE(\"Host: example.com\\r\\nCookie: \\r\\n\\r\\n\", 1, 0, \"slowloris\");\n    ok(num_headers == 2);\n    ok(bufis(headers[0].name, headers[0].name_len, \"Host\"));\n    ok(bufis(headers[0].value, headers[0].value_len, \"example.com\"));\n    ok(bufis(headers[1].name, headers[1].name_len, \"Cookie\"));\n    ok(bufis(headers[1].value, headers[1].value_len, \"\"));\n\n    PARSE(\"Host: example.com\\r\\nCookie: \\r\\n\\r\", 0, -2, \"partial\");\n\n    PARSE(\"Host: e\\7fample.com\\r\\nCookie: \\r\\n\\r\", 0, -1, \"error\");\n\n#undef PARSE\n}\n\nstatic void test_chunked_at_once(int line, int consume_trailer, const char *encoded, const char *decoded, ssize_t expected)\n{\n    struct phr_chunked_decoder dec = {0};\n    char *buf;\n    size_t bufsz;\n    ssize_t ret;\n\n    dec.consume_trailer = consume_trailer;\n\n    note(\"testing at-once, source at line %d\", line);\n\n    buf = strdup(encoded);\n    bufsz = strlen(buf);\n\n    ret = phr_decode_chunked(&dec, buf, &bufsz);\n\n    ok(ret == expected);\n    ok(bufsz == strlen(decoded));\n    ok(bufis(buf, bufsz, decoded));\n    if (expected >= 0) {\n        if (ret == expected)\n            ok(bufis(buf + bufsz, ret, encoded + strlen(encoded) - ret));\n        else\n            ok(0);\n    }\n\n    free(buf);\n}\n\nstatic void test_chunked_per_byte(int line, int consume_trailer, const char *encoded, const char *decoded, ssize_t expected)\n{\n    struct phr_chunked_decoder dec = {0};\n    char *buf = malloc(strlen(encoded) + 1);\n    size_t bytes_to_consume = strlen(encoded) - (expected >= 0 ? expected : 0), bytes_ready = 0, bufsz, i;\n    ssize_t ret;\n\n    dec.consume_trailer = consume_trailer;\n\n    note(\"testing per-byte, source at line %d\", line);\n\n    for (i = 0; i < bytes_to_consume - 1; ++i) {\n        buf[bytes_ready] = encoded[i];\n        bufsz = 1;\n        ret = phr_decode_chunked(&dec, buf + bytes_ready, &bufsz);\n        if (ret != -2) {\n            ok(0);\n            goto cleanup;\n        }\n        bytes_ready += bufsz;\n    }\n    strcpy(buf + bytes_ready, encoded + bytes_to_consume - 1);\n    bufsz = strlen(buf + bytes_ready);\n    ret = phr_decode_chunked(&dec, buf + bytes_ready, &bufsz);\n    ok(ret == expected);\n    bytes_ready += bufsz;\n    ok(bytes_ready == strlen(decoded));\n    ok(bufis(buf, bytes_ready, decoded));\n    if (expected >= 0) {\n        if (ret == expected)\n            ok(bufis(buf + bytes_ready, expected, encoded + bytes_to_consume));\n        else\n            ok(0);\n    }\n\ncleanup:\n    free(buf);\n}\n\nstatic void test_chunked_failure(int line, const char *encoded, ssize_t expected)\n{\n    struct phr_chunked_decoder dec = {0};\n    char *buf = strdup(encoded);\n    size_t bufsz, i;\n    ssize_t ret;\n\n    note(\"testing failure at-once, source at line %d\", line);\n    bufsz = strlen(buf);\n    ret = phr_decode_chunked(&dec, buf, &bufsz);\n    ok(ret == expected);\n\n    note(\"testing failure per-byte, source at line %d\", line);\n    memset(&dec, 0, sizeof(dec));\n    for (i = 0; encoded[i] != '\\0'; ++i) {\n        buf[0] = encoded[i];\n        bufsz = 1;\n        ret = phr_decode_chunked(&dec, buf, &bufsz);\n        if (ret == -1) {\n            ok(ret == expected);\n            goto cleanup;\n        } else if (ret == -2) {\n            /* continue */\n        } else {\n            ok(0);\n            goto cleanup;\n        }\n    }\n    ok(ret == expected);\n\ncleanup:\n    free(buf);\n}\n\nstatic void (*chunked_test_runners[])(int, int, const char *, const char *, ssize_t) = {test_chunked_at_once, test_chunked_per_byte,\n                                                                                        NULL};\n\nstatic void test_chunked(void)\n{\n    size_t i;\n\n    for (i = 0; chunked_test_runners[i] != NULL; ++i) {\n        chunked_test_runners[i](__LINE__, 0, \"b\\r\\nhello world\\r\\n0\\r\\n\", \"hello world\", 0);\n        chunked_test_runners[i](__LINE__, 0, \"6\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\n\", \"hello world\", 0);\n        chunked_test_runners[i](__LINE__, 0, \"6;comment=hi\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\n\", \"hello world\", 0);\n        chunked_test_runners[i](__LINE__, 0, \"6 ; comment\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\n\", \"hello world\", 0);\n        chunked_test_runners[i](__LINE__, 0, \"6\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\na: b\\r\\nc: d\\r\\n\\r\\n\", \"hello world\",\n                                sizeof(\"a: b\\r\\nc: d\\r\\n\\r\\n\") - 1);\n        chunked_test_runners[i](__LINE__, 0, \"b\\r\\nhello world\\r\\n0\\r\\n\", \"hello world\", 0);\n    }\n\n    note(\"failures\");\n    test_chunked_failure(__LINE__, \"z\\r\\nabcdefg\", -1);\n    if (sizeof(size_t) == 8) {\n        test_chunked_failure(__LINE__, \"6\\r\\nhello \\r\\nffffffffffffffff\\r\\nabcdefg\", -2);\n        test_chunked_failure(__LINE__, \"6\\r\\nhello \\r\\nfffffffffffffffff\\r\\nabcdefg\", -1);\n    }\n    test_chunked_failure(__LINE__, \"1x\\r\\na\\r\\n0\\r\\n\", -1);\n}\n\nstatic void test_chunked_consume_trailer(void)\n{\n    size_t i;\n\n    for (i = 0; chunked_test_runners[i] != NULL; ++i) {\n        chunked_test_runners[i](__LINE__, 1, \"b\\r\\nhello world\\r\\n0\\r\\n\", \"hello world\", -2);\n        chunked_test_runners[i](__LINE__, 1, \"6\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\n\", \"hello world\", -2);\n        chunked_test_runners[i](__LINE__, 1, \"6;comment=hi\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\n\", \"hello world\", -2);\n        chunked_test_runners[i](__LINE__, 1, \"b\\r\\nhello world\\r\\n0\\r\\n\\r\\n\", \"hello world\", 0);\n        chunked_test_runners[i](__LINE__, 1, \"b\\nhello world\\n0\\n\\n\", \"hello world\", 0);\n        chunked_test_runners[i](__LINE__, 1, \"6\\r\\nhello \\r\\n5\\r\\nworld\\r\\n0\\r\\na: b\\r\\nc: d\\r\\n\\r\\n\", \"hello world\", 0);\n    }\n}\n\nstatic void test_chunked_leftdata(void)\n{\n#define NEXT_REQ \"GET / HTTP/1.1\\r\\n\\r\\n\"\n\n    struct phr_chunked_decoder dec = {0};\n    dec.consume_trailer = 1;\n    char buf[] = \"5\\r\\nabcde\\r\\n0\\r\\n\\r\\n\" NEXT_REQ;\n    size_t bufsz = sizeof(buf) - 1;\n\n    ssize_t ret = phr_decode_chunked(&dec, buf, &bufsz);\n    ok(ret >= 0);\n    ok(bufsz == 5);\n    ok(memcmp(buf, \"abcde\", 5) == 0);\n    ok(ret == sizeof(NEXT_REQ) - 1);\n    ok(memcmp(buf + bufsz, NEXT_REQ, sizeof(NEXT_REQ) - 1) == 0);\n\n#undef NEXT_REQ\n}\n\nstatic ssize_t do_test_chunked_overhead(size_t chunk_len, size_t chunk_count, const char *extra)\n{\n    struct phr_chunked_decoder dec = {0};\n    char buf[1024];\n    size_t bufsz;\n    ssize_t ret;\n\n    for (size_t i = 0; i < chunk_count; ++i) {\n        /* build and feed the chunk header */\n        bufsz = (size_t)sprintf(buf, \"%zx%s\\r\\n\", chunk_len, extra);\n        if ((ret = phr_decode_chunked(&dec, buf, &bufsz)) != -2)\n            goto Exit;\n        assert(bufsz == 0);\n        /* build and feed the chunk boby */\n        memset(buf, 'A', chunk_len);\n        bufsz = chunk_len;\n        if ((ret = phr_decode_chunked(&dec, buf, &bufsz)) != -2)\n            goto Exit;\n        assert(bufsz == chunk_len);\n        /* build and feed the chunk end (CRLF) */\n        strcpy(buf, \"\\r\\n\");\n        bufsz = 2;\n        if ((ret = phr_decode_chunked(&dec, buf, &bufsz)) != -2)\n            goto Exit;\n        assert(bufsz == 0);\n    }\n\n    /* build and feed the end chunk */\n    strcpy(buf, \"0\\r\\n\\r\\n\");\n    bufsz = 5;\n    ret = phr_decode_chunked(&dec, buf, &bufsz);\n    assert(bufsz == 0);\n\nExit:\n    return ret;\n}\n\nstatic void test_chunked_overhead(void)\n{\n    ok(do_test_chunked_overhead(100, 10000, \"\") == 2 /* consume trailer is not set */);\n    ok(do_test_chunked_overhead(10, 100000, \"\") == 2 /* consume trailer is not set */);\n    ok(do_test_chunked_overhead(1, 1000000, \"\") == -1);\n\n    ok(do_test_chunked_overhead(10, 100000, \"; tiny=1\") == 2 /* consume trailer is not set */);\n    ok(do_test_chunked_overhead(10, 100000, \"; large=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == -1);\n}\n\nint main(void)\n{\n    long pagesize = sysconf(_SC_PAGESIZE);\n    assert(pagesize >= 1);\n\n    inputbuf = mmap(NULL, pagesize * 3, PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0);\n    assert(inputbuf != MAP_FAILED);\n    inputbuf += pagesize * 2;\n    ok(mprotect(inputbuf - pagesize, pagesize, PROT_READ | PROT_WRITE) == 0);\n\n    subtest(\"request\", test_request);\n    subtest(\"response\", test_response);\n    subtest(\"headers\", test_headers);\n    subtest(\"chunked\", test_chunked);\n    subtest(\"chunked-consume-trailer\", test_chunked_consume_trailer);\n    subtest(\"chunked-leftdata\", test_chunked_leftdata);\n    subtest(\"chunked-overhead\", test_chunked_overhead);\n\n    munmap(inputbuf - pagesize * 2, pagesize * 3);\n\n    return done_testing();\n}\n"
        }
      ]
    }
  ]
}