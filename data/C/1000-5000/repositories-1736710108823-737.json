{
  "metadata": {
    "timestamp": 1736710108823,
    "page": 737,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "chobits/ngx_http_proxy_connect_module",
      "stars": 1862,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4638671875,
          "content": "/* \n * Copyright (C) 2010-2017 Alibaba Group Holding Limited\n * Copyright (C) 2010-2017 Peng Qi <fengmo.q@gmail.com>\n * Copyright (C) 2015-2017 Xiaochen Wang <wangxiaochen0@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.7958984375,
          "content": "name\n====\n\nThis module provides support for [the CONNECT method request](https://tools.ietf.org/html/rfc7231#section-4.3.6).\nThis method is mainly used to [tunnel SSL requests](https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling) through proxy servers.\n\nTable of Contents\n=================\n\n   * [name](#name)\n   * [Example](#example)\n      * [configuration example](#configuration-example)\n        * [example for curl](#example-for-curl)\n      * [configuration example for CONNECT request in https](#configuration-example-for-connect-request-in-https)\n        * [example for curl (CONNECT request in https)](#example-for-curl-connect-request-in-https)\n        * [example for browser](#example-for-browser)\n      * [example for basic authentication](#example-for-basic-authentication)\n      * [example for proxying WebSocket](#example-for-proxying-websocket)\n   * [Install](#install)\n      * [select patch](#select-patch)\n      * [build nginx](#build-nginx)\n         * [build as a dynamic module](#build-as-a-dynamic-module)\n      * [build OpenResty](#build-openresty)\n   * [Test Suite](#test-suite)\n   * [Error Log](#error-log)\n   * [Directive](#directive)\n      * [proxy_connect](#proxy_connect)\n      * [proxy_connect_allow](#proxy_connect_allow)\n      * [proxy_connect_connect_timeout](#proxy_connect_connect_timeout)\n      * [proxy_connect_data_timeout](#proxy_connect_data_timeout)\n      * [proxy_connect_read_timeout(deprecated)](#proxy_connect_read_timeout)\n      * [proxy_connect_send_timeout(deprecated)](#proxy_connect_send_timeout)\n      * [proxy_connect_address](#proxy_connect_address)\n      * [proxy_connect_bind](#proxy_connect_bind)\n      * [proxy_connect_response](#proxy_connect_response)\n   * [Variables](#variables)\n      * [$connect_host](#connect_host)\n      * [$connect_port](#connect_port)\n      * [$connect_addr](#connect_addr)\n      * [$proxy_connect_connect_timeout](#proxy_connect_connect_timeout-1)\n      * [$proxy_connect_data_timeout](#proxy_connect_data_timeout-1)\n      * [$proxy_connect_read_timeout(deprecated)](#proxy_connect_read_timeout-1)\n      * [$proxy_connect_send_timeout(deprecated)](#proxy_connect_send_timeout-1)\n      * [$proxy_connect_resolve_time](#proxy_connect_resolve_time)\n      * [$proxy_connect_connect_time](#proxy_connect_connect_time)\n      * [$proxy_connect_first_byte_time](#proxy_connect_first_byte_time)\n      * [$proxy_connect_response](#proxy_connect_response-1)\n   * [Compatibility](#compatibility)\n      * [Nginx Compatibility](#nginx-compatibility)\n      * [OpenResty Compatibility](#openresty-compatibility)\n      * [Tengine Compatibility](#tengine-compatibility)\n   * [FAQ](#faq)\n   * [Known Issues](#known-issues)\n   * [See Also](#see-also)\n   * [Author](#author)\n   * [License](#license)\n\nExample\n=======\n\nConfiguration Example\n---------------------\n\n```nginx\nserver {\n    listen                         3128;\n\n    # dns resolver used by forward proxying\n    resolver                       8.8.8.8;\n\n    # forward proxy for CONNECT requests\n    proxy_connect;\n    proxy_connect_allow            443 563;\n    proxy_connect_connect_timeout  10s;\n    proxy_connect_data_timeout     10s;\n\n    # defined by yourself for non-CONNECT requests\n    # Example: reverse proxy for non-CONNECT requests\n    location / {\n        proxy_pass http://$host;\n        proxy_set_header Host $host;\n    }\n}\n```\n\n* The `resolver` directive MUST be configured globally in `server {}` block (or `http {}` block).\n* Any `location {}` block, `upstream {}` block and any other standard backend/upstream directives, such as `proxy_pass`, do not impact the functionality of this module. (The proxy_connect module only executes the logic for requests that use the CONNECT method and that have a data flow under this tunnel.)\n  * If you dont want to handle non-CONNECT requests, you can modify `location {}` block as following:\n    ```\n    location / {\n        return 403 \"Non-CONNECT requests are forbidden\";\n    }\n    ```\n\nExample for curl\n----------------\n\nWith above configuration([configuration example](#configuration-example)\n), you can get any https website via HTTP CONNECT tunnel. A simple test with command `curl` is as following:\n\n```\n$ curl https://github.com/ -v -x 127.0.0.1:3128\n*   Trying 127.0.0.1...                                           -.\n* Connected to 127.0.0.1 (127.0.0.1) port 3128 (#0)                | curl creates TCP connection with nginx (with proxy_connect module).\n* Establish HTTP proxy tunnel to github.com:443                   -'\n> CONNECT github.com:443 HTTP/1.1                                 -.\n> Host: github.com:443                                         (1) | curl sends CONNECT request to create tunnel.\n> User-Agent: curl/7.43.0                                          |\n> Proxy-Connection: Keep-Alive                                    -'\n>\n< HTTP/1.0 200 Connection Established                             .- nginx replies 200 that tunnel is established.\n< Proxy-agent: nginx                                           (2)|  (The client is now being proxied to the remote host. Any data sent\n<                                                                 '-  to nginx is now forwarded, unmodified, to the remote host)\n\n* Proxy replied OK to CONNECT request\n* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256  -.\n* Server certificate: github.com                                   |\n* Server certificate: DigiCert SHA2 Extended Validation Server CA  | curl sends \"https://github.com\" request via tunnel,\n* Server certificate: DigiCert High Assurance EV Root CA           | proxy_connect module will proxy data to remote host (github.com).\n> GET / HTTP/1.1                                                   |\n> Host: github.com                                             (3) |\n> User-Agent: curl/7.43.0                                          |\n> Accept: */*                                                     -'\n>\n< HTTP/1.1 200 OK                                                 .-\n< Date: Fri, 11 Aug 2017 04:13:57 GMT                             |\n< Content-Type: text/html; charset=utf-8                          |  Any data received from remote host will be sent to client\n< Transfer-Encoding: chunked                                      |  by proxy_connect module.\n< Server: GitHub.com                                           (4)|\n< Status: 200 OK                                                  |\n< Cache-Control: no-cache                                         |\n< Vary: X-PJAX                                                    |\n...                                                               |\n... <other response headers & response body> ...                  |\n...                                                               '-\n```\n\nThe sequence diagram of above example is as following:\n\n```\n  curl                     nginx (proxy_connect)            github.com\n    |                             |                          |\n(1) |-- CONNECT github.com:443 -->|                          |\n    |                             |                          |\n    |                             |----[ TCP connection ]--->|\n    |                             |                          |\n(2) |<- HTTP/1.1 200           ---|                          |\n    |   Connection Established    |                          |\n    |                             |                          |\n    |                                                        |\n    ========= CONNECT tunnel has been established. ===========\n    |                                                        |\n    |                             |                          |\n    |                             |                          |\n    |   [ SSL stream       ]      |                          |\n(3) |---[ GET / HTTP/1.1   ]----->|   [ SSL stream       ]   |\n    |   [ Host: github.com ]      |---[ GET / HTTP/1.1   ]-->.\n    |                             |   [ Host: github.com ]   |\n    |                             |                          |\n    |                             |                          |\n    |                             |                          |\n    |                             |   [ SSL stream       ]   |\n    |   [ SSL stream       ]      |<--[ HTTP/1.1 200 OK  ]---'\n(4) |<--[ HTTP/1.1 200 OK  ]------|   [ < html page >    ]   |\n    |   [ < html page >    ]      |                          |\n    |                             |                          |\n```\n\n\nconfiguration example for CONNECT request in HTTPS\n--------------------------------------------------\n\n```nginx\nserver {\n    listen                         3128 ssl;\n\n    # self signed certificate generated via openssl command\n    ssl_certificate_key            /path/to/server.key;\n    ssl_certificate                /path/to/server.crt;\n    ssl_session_cache              shared:SSL:1m;\n\n    # dns resolver used by forward proxying\n    resolver                       8.8.8.8;\n\n    # forward proxy for CONNECT request\n    proxy_connect;\n    proxy_connect_allow            443 563;\n    proxy_connect_connect_timeout  10s;\n    proxy_connect_data_timeout     10s;\n\n    # defined by yourself for non-CONNECT request\n    # Example: reverse proxy for non-CONNECT requests\n    location / {\n        proxy_pass http://$host;\n        proxy_set_header Host $host;\n    }\n}\n```\n\nexample for curl (CONNECT request in https)\n-------------------------------------------\n\n\nWith above configuration([configuration example for CONNECT request in https](#configuration-example-for-connect-request-in-https)), you can get any https website via HTTPS CONNECT tunnel(CONNECT request in https). A simple test with command `curl` is as following:\n\nTips on using curl command:\n\n* `-x https://...` makes curl send CONNECT request in https.\n* `--proxy-insecure` disables ssl signature verification for ssl connection established with nginx proxy_connect server(`https://localhost:3128`), but it does not disable verification with proxied backend server(`https://nginx.org` in the example below).\n  * If you want to disable signature verfication with proxied backend server, you can use `-k` option.\n\n<details><summary>output of curl command :point_left: </summary>\n<p>\n\n```\n$ curl https://nginx.org/ -sv -o/dev/null -x https://localhost:3128 --proxy-insecure\n*   Trying 127.0.0.1:3128...\n* TCP_NODELAY set\n* Connected to localhost (127.0.0.1) port 3128 (#0)\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n*   CAfile: /etc/ssl/certs/ca-certificates.crt\n  CApath: /etc/ssl/certs\n} [5 bytes data]\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n} [512 bytes data]\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n{ [112 bytes data]\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n{ [799 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n{ [300 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n{ [4 bytes data]\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n} [37 bytes data]\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n} [1 bytes data]\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n} [16 bytes data]\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n{ [16 bytes data]\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server accepted to use http/1.1\n* Proxy certificate:\n*  subject: C=AU; ST=Some-State; O=Internet Widgits Pty Ltd\n*  start date: Nov 25 08:36:38 2022 GMT\n*  expire date: Nov 25 08:36:38 2023 GMT\n*  issuer: C=AU; ST=Some-State; O=Internet Widgits Pty Ltd\n*  SSL certificate verify result: self signed certificate (18), continuing anyway.\n* allocate connect buffer!\n* Establish HTTP proxy tunnel to nginx.org:443\n} [5 bytes data]\n> CONNECT nginx.org:443 HTTP/1.1\n> Host: nginx.org:443\n> User-Agent: curl/7.68.0\n> Proxy-Connection: Keep-Alive\n>\n{ [5 bytes data]\n< HTTP/1.1 200 Connection Established\n< Proxy-agent: nginx\n<\n* Proxy replied 200 to CONNECT request\n* CONNECT phase completed!\n* ALPN, offering h2\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n*   CAfile: /etc/ssl/certs/ca-certificates.crt\n  CApath: /etc/ssl/certs\n} [5 bytes data]\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n} [512 bytes data]\n* CONNECT phase completed!\n* CONNECT phase completed!\n{ [5 bytes data]\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n{ [80 bytes data]\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n{ [2749 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n{ [300 bytes data]\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n{ [4 bytes data]\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n} [37 bytes data]\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n} [1 bytes data]\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n} [16 bytes data]\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n{ [16 bytes data]\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server accepted to use http/1.1\n* Server certificate:\n*  subject: CN=nginx.org\n*  start date: Dec  9 15:29:31 2022 GMT\n*  expire date: Mar  9 15:29:30 2023 GMT\n*  subjectAltName: host \"nginx.org\" matched cert's \"nginx.org\"\n*  issuer: C=US; O=Let's Encrypt; CN=R3\n*  SSL certificate verify ok.\n} [5 bytes data]\n> GET / HTTP/1.1\n> Host: nginx.org\n> User-Agent: curl/7.68.0\n> Accept: */*\n>\n{ [5 bytes data]\n* Mark bundle as not supporting multiuse\n< HTTP/1.1 200 OK\n< Server: nginx/1.21.5\n< Date: Mon, 06 Mar 2023 06:05:24 GMT\n< Content-Type: text/html; charset=utf-8\n< Content-Length: 7488\n< Last-Modified: Tue, 28 Feb 2023 21:07:43 GMT\n< Connection: keep-alive\n< Keep-Alive: timeout=15\n< ETag: \"63fe6d1f-1d40\"\n< Accept-Ranges: bytes\n<\n{ [7488 bytes data]\n* Connection #0 to host localhost left intact\n```\n\n</p>\n</details>\n\nExample for browser\n-------------------\n\nYou can configure your browser to use this nginx as PROXY server.\n\n* Google Chrome HTTPS PROXY SETTING: [guide & config](https://github.com/chobits/ngx_http_proxy_connect_module/issues/22#issuecomment-346941271) for how to configure this module working under SSL layer.\n\n\nExample for Basic Authentication\n--------------------------------\n\nWe can do access control on CONNECT request using nginx auth basic module.  \nSee [this guide](https://github.com/chobits/ngx_http_proxy_connect_module/issues/42#issuecomment-502985437) for more details.\n\n\nExample for proxying WebSocket\n------------------------------\n\n* Note that nginx has its own WebSocket reverse proxy module, which is is not limited to the CONNECT tunnel, see [nginx.org doc: Nginx WebSocket proxying](https://nginx.org/en/docs/http/websocket.html) and [nginx.com blog: NGINX as a WebSocket Proxy](https://www.nginx.com/blog/websocket-nginx/).\n* This module enables the WebSocket protocol to work over the CONNECT tunnel, see https://github.com/chobits/ngx_http_proxy_connect_module/issues/267#issuecomment-1575449174\n\n\nInstall\n=======\n\nSelect patch\n------------\n\n* Select right patch for building:\n * All patch files have been included in `patch/` directory of this module. You dont need to download the patch directly from web page.\n\n| nginx version | enable REWRITE phase | patch |\n| --: | --: | --: |\n| 1.4.x ~ 1.12.x   | NO  | [proxy_connect.patch](patch/proxy_connect.patch) |\n| 1.4.x ~ 1.12.x   | YES | [proxy_connect_rewrite.patch](patch/proxy_connect_rewrite.patch) |\n| 1.13.x ~ 1.14.x  | NO  | [proxy_connect_1014.patch](patch/proxy_connect_1014.patch) |\n| 1.13.x ~ 1.14.x  | YES | [proxy_connect_rewrite_1014.patch](patch/proxy_connect_rewrite_1014.patch) |\n| 1.15.2           | YES | [proxy_connect_rewrite_1015.patch](patch/proxy_connect_rewrite_1015.patch) |\n| 1.15.4 ~ 1.16.x  | YES | [proxy_connect_rewrite_101504.patch](patch/proxy_connect_rewrite_101504.patch) |\n| 1.17.x ~ 1.18.x  | YES | [proxy_connect_rewrite_1018.patch](patch/proxy_connect_rewrite_1018.patch) |\n| 1.19.x ~ 1.21.0  | YES | [proxy_connect_rewrite_1018.patch](patch/proxy_connect_rewrite_1018.patch) |\n| 1.21.1 ~ 1.22.x  | YES | [proxy_connect_rewrite_102101.patch](patch/proxy_connect_rewrite_102101.patch) |\n| 1.23.x ~ 1.24.0  | YES | [proxy_connect_rewrite_102101.patch](patch/proxy_connect_rewrite_102101.patch) |\n| 1.25.0 ~ 1.26.x  | YES | [proxy_connect_rewrite_102101.patch](patch/proxy_connect_rewrite_102101.patch) |\n| 1.27.1           | YES | [proxy_connect_rewrite_102101.patch](patch/proxy_connect_rewrite_102101.patch) |\n\n| OpenResty version | enable REWRITE phase | patch |\n| --: | --: | --: |\n| 1.13.6 | NO  | [proxy_connect_1014.patch](patch/proxy_connect_1014.patch) |\n| 1.13.6 | YES | [proxy_connect_rewrite_1014.patch](patch/proxy_connect_rewrite_1014.patch) |\n| 1.15.8 | YES | [proxy_connect_rewrite_101504.patch](patch/proxy_connect_rewrite_101504.patch) |\n| 1.17.8 | YES | [proxy_connect_rewrite_1018.patch](patch/proxy_connect_rewrite_1018.patch) |\n| 1.19.3 | YES | [proxy_connect_rewrite_1018.patch](patch/proxy_connect_rewrite_1018.patch) |\n| 1.21.4 | YES | [proxy_connect_rewrite_102101.patch](patch/proxy_connect_rewrite_102101.patch) |\n| 1.25.3 | YES | [proxy_connect_rewrite_102101.patch](patch/proxy_connect_rewrite_102101.patch) |\n\n\n* `proxy_connect_<VERSION>.patch` disables nginx REWRITE phase for CONNECT request by default, which means `if`, `set`, `rewrite_by_lua` and other REWRITE phase directives cannot be used.\n* `proxy_connect_rewrite_<VERSION>.patch` enables these REWRITE phase directives.\n\nBuild nginx\n-----------\n\n* Build nginx with this module from source:\n\n```bash\n$ wget http://nginx.org/download/nginx-1.9.2.tar.gz\n$ tar -xzvf nginx-1.9.2.tar.gz\n$ cd nginx-1.9.2/\n$ patch -p1 < /path/to/ngx_http_proxy_connect_module/patch/proxy_connect.patch\n$ ./configure --add-module=/path/to/ngx_http_proxy_connect_module\n$ make && make install\n```\n\nBuild as a dynamic module\n-------------------------\n\n* Starting from nginx 1.9.11, you can also compile this module as a dynamic module, by using the `--add-dynamic-module=PATH` option instead of `--add-module=PATH` on the `./configure` command line.\n\n```bash\n$ wget http://nginx.org/download/nginx-1.9.12.tar.gz\n$ tar -xzvf nginx-1.9.12.tar.gz\n$ cd nginx-1.9.12/\n$ patch -p1 < /path/to/ngx_http_proxy_connect_module/patch/proxy_connect.patch\n$ ./configure --add-dynamic-module=/path/to/ngx_http_proxy_connect_module\n$ make && make install\n```\n\n* And then you can explicitly load the module in your nginx.conf via the `load_module` directive, for example,\n\n```\nload_module /path/to/modules/ngx_http_proxy_connect_module.so;\n```\n\n* :exclamation: Note that the ngx_http_proxy_connect_module.so file MUST be loaded by nginx binary that is compiled with the .so file at the same time.\n\n\nBuild OpenResty\n---------------\n\n* Build OpenResty with this module from source:\n\n```bash\n$ wget https://openresty.org/download/openresty-1.19.3.1.tar.gz\n$ tar -zxvf openresty-1.19.3.1.tar.gz\n$ cd openresty-1.19.3.1\n$ ./configure --add-module=/path/to/ngx_http_proxy_connect_module\n$ patch -d build/nginx-1.19.3/ -p 1 < /path/to/ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_101504.patch\n$ make && make install\n```\n\nTest Suite\n==========\n\n* To run the whole test suite:\n\n```bash\n$ hg clone http://hg.nginx.org/nginx-tests/\n\n# If you use latest lua-nginx-module that needs lua-resty-core and\n# lua-resty-lrucache, you should add \"lua_package_path ...;\" directive\n# into nginx.conf of test cases. You can use the following command:\n#\n# $ export TEST_NGINX_GLOBALS_HTTP='lua_package_path \"/path/to/nginx/lib/lua/?.lua;;\";'\n\n$ export TEST_NGINX_BINARY=/path/to/nginx/binary\n$ prove -v -I /path/to/nginx-tests/lib /path/to/ngx_http_proxy_connect_module/t/\n```\n\n* For the complete process of building and testing this module, see:\n  * workflow files: [here](https://github.com/chobits/ngx_http_proxy_connect_module/tree/master/.github/workflows)\n  * runs from all workflows: [here](https://github.com/chobits/ngx_http_proxy_connect_module/actions)\n\nError Log\n=========\n\nThis module logs its own error message beginning with `\"proxy_connect:\"` string.  \nSome typical error logs are shown as following:\n\n* The proxy_connect module tries to establish tunnel connection with backend server, but the TCP connection timeout occurs.\n\n```\n2019/08/07 17:27:20 [error] 19257#0: *1 proxy_connect: upstream connect timed out (peer:216.58.200.4:443) while connecting to upstream, client: 127.0.0.1, server: , request: \"CONNECT www.google.com:443 HTTP/1.1\", host: \"www.google.com:443\"\n```\n\nDirective\n=========\n\nproxy_connect\n-------------\n\nSyntax: **proxy_connect**  \nDefault: `none`  \nContext: `server`  \n\nEnable \"CONNECT\" HTTP method support.\n\nproxy_connect_allow\n-------------------\n\nSyntax: **proxy_connect_allow `all | [port ...] | [port-range ...]`**  \nDefault: `443 563`  \nContext: `server`  \n\nThis directive specifies a list of port numbers or ranges to which the proxy CONNECT method may connect.  \nBy default, only the default https port (443) and the default snews port (563) are enabled.  \nUsing this directive will override this default and allow connections to the listed ports only.\n\nThe value `all` will allow all ports to proxy.\n\nThe value `port` will allow specified port to proxy.\n\nThe value `port-range` will allow specified range of port to proxy, for example:\n\n```\nproxy_connect_allow 1000-2000 3000-4000; # allow range of port from 1000 to 2000, from 3000 to 4000.\n```\n\nproxy_connect_connect_timeout\n-----------------------------\n\nSyntax: **proxy_connect_connect_timeout `time`**  \nDefault: `none`  \nContext: `server`  \n\nDefines a timeout for establishing a connection with a proxied server.\n\nproxy_connect_data_timeout\n--------------------------\n\nSyntax: **proxy_connect_data_timeout `time`**  \nDefault: `60s`  \nContext: `server`  \n\nSets the timeout between two successive read or write operations on client or proxied server connections. If no data is transmitted within this time, the connection is closed.\n\nproxy_connect_read_timeout\n--------------------------\n\nSyntax: **proxy_connect_read_timeout `time`**  \nDefault: `60s`  \nContext: `server`  \n\nDeprecated.\n\nIt has the same function as the directive `proxy_connect_data_timeout` for compatibility. You can configure only one of the directives (`proxy_connect_data_timeout` or `proxy_connect_read_timeout`).\n\nproxy_connect_send_timeout\n--------------------------\n\nSyntax: **proxy_connect_send_timeout `time`**  \nDefault: `60s`  \nContext: `server`  \n\nDeprecated.\n\nIt has no function.\n\nproxy_connect_address\n---------------------\n\nSyntax: **proxy_connect_address `address | off`**  \nDefault: `none`  \nContext: `server`  \n\nSpecifiy an IP address of the proxied server. The address can contain variables.  \nThe special value off is equal to none, which uses the IP address resolved from host name of CONNECT request line.  \n\nNOTE: If using `set $<nginx variable>` and `proxy_connect_address $<nginx variable>` together, you should use `proxy_connect_rewrite.patch` instead, see [Install](#install) for more details.\n\nproxy_connect_bind\n------------------\n\nSyntax: **proxy_connect_bind `address [transparent] | off`**  \nDefault: `none`  \nContext: `server`  \n\nMakes outgoing connections to a proxied server originate from the specified local IP address with an optional port.  \nParameter value can contain variables. The special value off is equal to none, which allows the system to auto-assign the local IP address and port.\n\nThe transparent parameter allows outgoing connections to a proxied server originate from a non-local IP address, for example, from a real IP address of a client:\n\n```\nproxy_connect_bind $remote_addr transparent;\n\n```\n\nIn order for this parameter to work, it is usually necessary to run nginx worker processes with the [superuser](http://nginx.org/en/docs/ngx_core_module.html#user) privileges. On Linux it is not required (1.13.8) as if the transparent parameter is specified, worker processes inherit the CAP_NET_RAW capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the proxied server.\n\nNOTE: If using `set $<nginx variable>` and `proxy_connect_bind $<nginx variable>` together, you should use `proxy_connect_rewrite.patch` instead, see [Install](#install) for more details.\n\nproxy_connect_response\n----------------------\n\nSyntax: **proxy_connect_response `CONNECT response`**  \nDefault: `HTTP/1.1 200 Connection Established\\r\\nProxy-agent: nginx\\r\\n\\r\\n`  \nContext: `server`\n\nSet the response of CONNECT request.\n\nNote that it is only used for CONNECT request, it cannot modify the data flow over CONNECT tunnel.\n\nFor example:\n\n```\nproxy_connect_response \"HTTP/1.1 200 Connection Established\\r\\nProxy-agent: nginx\\r\\nX-Proxy-Connected-Addr: $connect_addr\\r\\n\\r\\n\";\n\n```\n\nThe `curl` command test case with above config is as following:\n\n```\n$ curl https://github.com -sv -x localhost:3128\n* Connected to localhost (127.0.0.1) port 3128 (#0)\n* allocate connect buffer!\n* Establish HTTP proxy tunnel to github.com:443\n> CONNECT github.com:443 HTTP/1.1\n> Host: github.com:443\n> User-Agent: curl/7.64.1\n> Proxy-Connection: Keep-Alive\n>\n< HTTP/1.1 200 Connection Established            --.\n< Proxy-agent: nginx                               | custom CONNECT response\n< X-Proxy-Connected-Addr: 13.229.188.59:443      --'\n...\n\n```\n\n\nVariables\n=========\n\n$connect_host\n-------------\n\nhost name from CONNECT request line.\n\n$connect_port\n-------------\n\nport from CONNECT request line.\n\n$connect_addr\n-------------\n\nIP address and port of the remote host, e.g. \"192.168.1.5:12345\".\nIP address is resolved from host name of CONNECT request line.\n\n$proxy_connect_connect_timeout\n------------------------------\n\nGet or set timeout of [`proxy_connect_connect_timeout` directive](#proxy_connect_connect_timeout).\n\nFor example:\n\n```nginx\n# Set default value\n\nproxy_connect_connect_timeout   10s;\nproxy_connect_data_timeout      10s;\n\n# Overlap default value\n\nif ($host = \"test.com\") {\n    set $proxy_connect_connect_timeout  \"10ms\";\n    set $proxy_connect_data_timeout     \"10ms\";\n}\n```\n\n$proxy_connect_data_timeout\n---------------------------\n\nGet or set a timeout of [`proxy_connect_data_timeout` directive](#proxy_connect_data_timeout).\n\n$proxy_connect_read_timeout\n---------------------------\n\nDeprecated. \nIt still can get or set a timeout of [`proxy_connect_data_timeout` directive](#proxy_connect_data_timeout) for compatibility.\n\n$proxy_connect_send_timeout\n---------------------------\n\nDeprecated.\nIt has no function.\n\n$proxy_connect_resolve_time\n---------------------------\n\nKeeps time spent on name resolving; the time is kept in seconds with millisecond resolution.\n\n* Value of \"\" means this module does not work on this request.\n* Value of \"-\" means name resolving failed.\n\n\n$proxy_connect_connect_time\n---------------------------\n\nKeeps time spent on establishing a connection with the upstream server; the time is kept in seconds with millisecond resolution.\n\n* Value of \"\" means this module does not work on this request.\n* Value of \"-\" means name resolving or connecting failed.\n\n\n$proxy_connect_first_byte_time\n---------------------------\n\nKeeps time to receive the first byte of data from the upstream server; the time is kept in seconds with millisecond resolution.\n\n* Value of \"\" means this module does not work on this request.\n* Value of \"-\" means name resolving, connecting or receving failed.\n\n\n$proxy_connect_response\n---------------------------\n\nGet or set the response of CONNECT request.  \nThe default response of CONNECT request is \"HTTP/1.1 200 Connection Established\\r\\nProxy-agent: nginx\\r\\n\\r\\n\".\n\nNote that it is only used for CONNECT request, it cannot modify the data flow over CONNECT tunnel.\n\nFor example:\n\n```nginx\n\n# modify default Proxy-agent header\nset $proxy_connect_response \"HTTP/1.1 200\\r\\nProxy-agent: nginx/1.19\\r\\n\\r\\n\";\n```\n\nThe variable value does not support nginx variables. You can use lua-nginx-module to construct string that contains nginx variable. For example:\n\n```nginx\n\n# The CONNECT response may be \"HTTP/1.1 200\\r\\nProxy-agent: nginx/1.19.6\\r\\n\\r\\n\"\n\nrewrite_by_lua '\n    ngx.var.proxy_connect_response =\n      string.format(\"HTTP/1.1 200\\\\r\\\\nProxy-agent: nginx/%s\\\\r\\\\n\\\\r\\\\n\", ngx.var.nginx_version)\n';\n```\n\nAlso note that `set` or `rewrite_by_lua*` directive is run during the REWRITE phase, which is ahead of dns resolving phase. It cannot get right value of some variables, for example, `$connect_addr` value is `nil`. In such case, you should use [`proxy_connect_response` directive](#proxy_connect_response) instead.\n\n\nCompatibility\n=============\n\nNginx Compatibility\n-------------------\n\nThe latest module is compatible with the following versions of nginx:\n\n* 1.27.1  (mainline version of 1.27.x)\n* 1.26.2  (version of 1.26.x)\n* 1.24.0  (version of 1.24.x)\n* 1.22.1  (version of 1.22.x)\n* 1.20.2  (version of 1.20.x)\n* 1.18.0  (version of 1.18.x)\n* 1.16.1  (version of 1.16.x)\n* 1.14.2  (version of 1.14.x)\n* 1.12.1  (version of 1.12.x)\n* 1.10.3  (version of 1.10.x)\n* 1.8.1   (version of 1.8.x)\n* 1.6.3   (version of 1.6.x)\n* 1.4.7   (version of 1.4.x)\n\nOpenResty Compatibility\n-----------------------\n\nThe latest module is compatible with the following versions of OpenResty:\n\n* 1.25.3 (version: 1.25.3.1)\n* 1.21.4 (version: 1.21.4.3)\n* 1.19.3 (version: 1.19.3.1)\n* 1.17.8 (version: 1.17.8.2)\n* 1.15.8 (version: 1.15.8.1)\n* 1.13.6 (version: 1.13.6.2)\n\nTengine Compatibility\n---------------------\n\nThis module has been integrated into Tengine 2.3.0.  \n\n* [Tengine ngx_http_proxy_connect_module documentation](http://tengine.taobao.org/document/proxy_connect.html)\n* [Merged pull request for Tengine 2.3.0](https://github.com/alibaba/tengine/pull/1210).\n\nFAQ\n===\n\nSee [FAQ page](https://github.com/chobits/ngx_http_proxy_connect_module/wiki/FAQ).\n\nKnown Issues\n============\n\n* In HTTP/2, the CONNECT method is not supported. It only supports the CONNECT method request in HTTP/1.x and HTTPS.\n\nSee Also\n========\n\n* [HTTP tunnel - Wikipedia](https://en.wikipedia.org/wiki/HTTP_tunnel)\n* [CONNECT method in HTTP/1.1](https://tools.ietf.org/html/rfc7231#section-4.3.6)\n* [CONNECT method in HTTP/2](https://httpwg.org/specs/rfc7540.html#CONNECT)\n\nAuthor\n======\n* [Peng Qi](https://github.com/jinglong): original author. He contributed this module to [Tengine](https://github.com/tengine) in this [pull request](https://github.com/alibaba/tengine/pull/335/).  \n* [Xiaochen Wang](https://github.com/chobits): current maintainer. Rebuild this module for nginx.\n\nLICENSE\n=======\n\nSee [LICENSE](https://github.com/chobits/ngx_http_proxy_connect_module/blob/master/LICENSE) for details.\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 0.4306640625,
          "content": "ngx_addon_name=ngx_http_proxy_connect_module\n\nif test -n \"$ngx_module_link\"; then\n    ngx_module_type=HTTP\n    ngx_module_name=ngx_http_proxy_connect_module\n    ngx_module_srcs=\"$ngx_addon_dir/ngx_http_proxy_connect_module.c\"\n\n    . auto/module\nelse\n    HTTP_MODULES=\"$HTTP_MODULES ngx_http_proxy_connect_module\"\n    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_proxy_connect_module.c\"\nfi\n\nhave=NGX_HTTP_PROXY_CONNECT . auto/have\n"
        },
        {
          "name": "ngx_http_proxy_connect_module.c",
          "type": "blob",
          "size": 63.474609375,
          "content": "/*\n * Copyright (C) 2010-2013 Alibaba Group Holding Limited\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include <nginx.h>\n\n\n#define NGX_HTTP_PROXY_CONNECT_ESTABLISTHED     \\\n    \"HTTP/1.1 200 Connection Established\\r\\n\"   \\\n    \"Proxy-agent: nginx\\r\\n\\r\\n\"\n\n\ntypedef struct ngx_http_proxy_connect_upstream_s\n    ngx_http_proxy_connect_upstream_t;\ntypedef struct ngx_http_proxy_connect_address_s\n    ngx_http_proxy_connect_address_t;\n\ntypedef void (*ngx_http_proxy_connect_upstream_handler_pt)(\n    ngx_http_request_t *r, ngx_http_proxy_connect_upstream_t *u);\n\n\ntypedef struct {\n    ngx_flag_t                           accept_connect;\n    ngx_flag_t                           allow_port_all;\n    ngx_array_t                         *allow_ports;\n\n    ngx_msec_t                           data_timeout;\n    ngx_msec_t                           send_timeout;\n    ngx_msec_t                           connect_timeout;\n\n    size_t                               send_lowat;\n    size_t                               buffer_size;\n\n    ngx_http_complex_value_t            *address;\n    ngx_http_proxy_connect_address_t    *local;\n\n    ngx_http_complex_value_t            *response;\n} ngx_http_proxy_connect_loc_conf_t;\n\n\ntypedef struct {\n    ngx_msec_t                       resolve_time;\n    ngx_msec_t                       connect_time;\n    ngx_msec_t                       first_byte_time;\n\n    /* TODO:\n    off_t                            bytes_received;\n    off_t                            bytes_sent;\n    */\n} ngx_http_proxy_connect_upstream_state_t;\n\n\nstruct ngx_http_proxy_connect_upstream_s {\n    ngx_http_proxy_connect_loc_conf_t             *conf;\n\n    ngx_http_proxy_connect_upstream_handler_pt     read_event_handler;\n    ngx_http_proxy_connect_upstream_handler_pt     write_event_handler;\n\n    ngx_peer_connection_t                          peer;\n\n    ngx_http_request_t                            *request;\n\n    ngx_http_upstream_resolved_t                  *resolved;\n\n    ngx_buf_t                                      from_client;\n\n    ngx_output_chain_ctx_t                         output;\n\n    ngx_buf_t                                      buffer;\n\n    /* 1: DNS resolving succeeded */\n    ngx_flag_t                                     _resolved;\n\n    /* 1: connection established */\n    ngx_flag_t                                     connected;\n\n    ngx_msec_t                                     start_time;\n\n    ngx_http_proxy_connect_upstream_state_t        state;\n};\n\nstruct ngx_http_proxy_connect_address_s {\n    ngx_addr_t                      *addr;\n    ngx_http_complex_value_t        *value;\n#if (NGX_HAVE_TRANSPARENT_PROXY)\n    ngx_uint_t                       transparent; /* unsigned  transparent:1; */\n#endif\n};\n\ntypedef struct {\n    ngx_http_proxy_connect_upstream_t           *u;\n\n    ngx_flag_t                      send_established;\n    ngx_flag_t                      send_established_done;\n\n    ngx_buf_t                       buf;    /* CONNECT response */\n\n    ngx_msec_t                      connect_timeout;\n    ngx_msec_t                      send_timeout;\n    ngx_msec_t                      data_timeout;\n\n} ngx_http_proxy_connect_ctx_t;\n\n\nstatic ngx_int_t ngx_http_proxy_connect_init(ngx_conf_t *cf);\nstatic ngx_int_t ngx_http_proxy_connect_add_variables(ngx_conf_t *cf);\nstatic ngx_int_t ngx_http_proxy_connect_connect_addr_variable(\n    ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data);\nstatic char *ngx_http_proxy_connect(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_http_proxy_connect_allow(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic void *ngx_http_proxy_connect_create_loc_conf(ngx_conf_t *cf);\nstatic char *ngx_http_proxy_connect_merge_loc_conf(ngx_conf_t *cf, void *parent,\n    void *child);\nstatic void ngx_http_proxy_connect_write_downstream(ngx_http_request_t *r);\nstatic void ngx_http_proxy_connect_read_downstream(ngx_http_request_t *r);\nstatic void ngx_http_proxy_connect_send_handler(ngx_http_request_t *r);\nstatic ngx_int_t ngx_http_proxy_connect_allow_handler(ngx_http_request_t *r,\n    ngx_http_proxy_connect_loc_conf_t *plcf);\nstatic char* ngx_http_proxy_connect_bind(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic ngx_int_t ngx_http_proxy_connect_set_local(ngx_http_request_t *r,\n  ngx_http_proxy_connect_upstream_t *u, ngx_http_proxy_connect_address_t *local);\nstatic ngx_int_t ngx_http_proxy_connect_variable_get_time(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\nstatic void ngx_http_proxy_connect_variable_set_time(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_http_proxy_connect_resolve_time_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_http_proxy_connect_connect_time_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_http_proxy_connect_first_byte_time_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_http_proxy_connect_variable_get_response(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\nstatic void ngx_http_proxy_connect_variable_set_response(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data);\n\nstatic ngx_int_t ngx_http_proxy_connect_sock_ntop(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u);\nstatic ngx_int_t ngx_http_proxy_connect_create_peer(ngx_http_request_t *r,\n    ngx_http_upstream_resolved_t *ur);\n\n\n\nstatic ngx_command_t  ngx_http_proxy_connect_commands[] = {\n\n    { ngx_string(\"proxy_connect\"),\n      NGX_HTTP_SRV_CONF|NGX_CONF_NOARGS,\n      ngx_http_proxy_connect,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, accept_connect),\n      NULL },\n\n    { ngx_string(\"proxy_connect_allow\"),\n      NGX_HTTP_SRV_CONF|NGX_CONF_1MORE,\n      ngx_http_proxy_connect_allow,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"proxy_connect_data_timeout\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, data_timeout),\n      NULL },\n\n    { ngx_string(\"proxy_connect_read_timeout\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, data_timeout),\n      NULL },\n\n    { ngx_string(\"proxy_connect_send_timeout\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, send_timeout),\n      NULL },\n\n    { ngx_string(\"proxy_connect_connect_timeout\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, connect_timeout),\n      NULL },\n\n    { ngx_string(\"proxy_connect_send_lowat\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, send_lowat),\n      NULL },\n\n    { ngx_string(\"proxy_connect_address\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_http_set_complex_value_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, address),\n      NULL },\n\n    { ngx_string(\"proxy_connect_bind\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE12,\n      ngx_http_proxy_connect_bind,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, local),\n      NULL },\n\n    { ngx_string(\"proxy_connect_response\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_http_set_complex_value_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_proxy_connect_loc_conf_t, response),\n      NULL },\n\n    ngx_null_command\n};\n\n\nstatic ngx_http_module_t  ngx_http_proxy_connect_module_ctx = {\n    ngx_http_proxy_connect_add_variables,   /* preconfiguration */\n    ngx_http_proxy_connect_init,            /* postconfiguration */\n\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n\n    ngx_http_proxy_connect_create_loc_conf, /* create location configuration */\n    ngx_http_proxy_connect_merge_loc_conf   /* merge location configuration */\n};\n\n\nngx_module_t  ngx_http_proxy_connect_module = {\n    NGX_MODULE_V1,\n    &ngx_http_proxy_connect_module_ctx,     /* module context */\n    ngx_http_proxy_connect_commands,        /* module directives */\n    NGX_HTTP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_http_variable_t  ngx_http_proxy_connect_vars[] = {\n\n    { ngx_string(\"connect_addr\"), NULL,\n      ngx_http_proxy_connect_connect_addr_variable,\n      0, NGX_HTTP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_connect_timeout\"),\n      ngx_http_proxy_connect_variable_set_time,\n      ngx_http_proxy_connect_variable_get_time,\n      offsetof(ngx_http_proxy_connect_ctx_t, connect_timeout),\n      NGX_HTTP_VAR_NOCACHEABLE|NGX_HTTP_VAR_CHANGEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_data_timeout\"),\n      ngx_http_proxy_connect_variable_set_time,\n      ngx_http_proxy_connect_variable_get_time,\n      offsetof(ngx_http_proxy_connect_ctx_t, data_timeout),\n      NGX_HTTP_VAR_NOCACHEABLE|NGX_HTTP_VAR_CHANGEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_read_timeout\"),\n      ngx_http_proxy_connect_variable_set_time,\n      ngx_http_proxy_connect_variable_get_time,\n      offsetof(ngx_http_proxy_connect_ctx_t, data_timeout),\n      NGX_HTTP_VAR_NOCACHEABLE|NGX_HTTP_VAR_CHANGEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_send_timeout\"),\n      ngx_http_proxy_connect_variable_set_time,\n      ngx_http_proxy_connect_variable_get_time,\n      offsetof(ngx_http_proxy_connect_ctx_t, send_timeout),\n      NGX_HTTP_VAR_NOCACHEABLE|NGX_HTTP_VAR_CHANGEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_resolve_time\"), NULL,\n      ngx_http_proxy_connect_resolve_time_variable, 0,\n      NGX_HTTP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_connect_time\"), NULL,\n      ngx_http_proxy_connect_connect_time_variable, 0,\n      NGX_HTTP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_first_byte_time\"), NULL,\n      ngx_http_proxy_connect_first_byte_time_variable, 0,\n      NGX_HTTP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"proxy_connect_response\"),\n      ngx_http_proxy_connect_variable_set_response,\n      ngx_http_proxy_connect_variable_get_response,\n      offsetof(ngx_http_proxy_connect_ctx_t, buf),\n      NGX_HTTP_VAR_NOCACHEABLE|NGX_HTTP_VAR_CHANGEABLE, 0 },\n\n    { ngx_null_string, NULL, NULL, 0, 0, 0 }\n};\n\n\n#if 1\n\n#if defined(nginx_version) && nginx_version >= 1005008\n#define __ngx_sock_ntop ngx_sock_ntop\n#else\n#define __ngx_sock_ntop(sa, slen, p, len, port) ngx_sock_ntop(sa, p, len, port)\n#endif\n\n/*\n * #if defined(nginx_version) && nginx_version <= 1009015\n *\n * from src/core/ngx_inet.c: ngx_inet_set_port & ngx_parse_addr_port\n *\n * redefined to __ngx_inet_set_port & __ngx_parse_addr_port to\n * avoid too many `#if nginx_version > ...` macro\n */\nstatic void\n__ngx_inet_set_port(struct sockaddr *sa, in_port_t port)\n{\n    struct sockaddr_in   *sin;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6  *sin6;\n#endif\n\n    switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        sin6 = (struct sockaddr_in6 *) sa;\n        sin6->sin6_port = htons(port);\n        break;\n#endif\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    case AF_UNIX:\n        break;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) sa;\n        sin->sin_port = htons(port);\n        break;\n    }\n}\n\n\nstatic ngx_int_t\n__ngx_parse_addr_port(ngx_pool_t *pool, ngx_addr_t *addr, u_char *text,\n    size_t len)\n{\n    u_char     *p, *last;\n    size_t      plen;\n    ngx_int_t   rc, port;\n\n    rc = ngx_parse_addr(pool, addr, text, len);\n\n    if (rc != NGX_DECLINED) {\n        return rc;\n    }\n\n    last = text + len;\n\n#if (NGX_HAVE_INET6)\n    if (len && text[0] == '[') {\n\n        p = ngx_strlchr(text, last, ']');\n\n        if (p == NULL || p == last - 1 || *++p != ':') {\n            return NGX_DECLINED;\n        }\n\n        text++;\n        len -= 2;\n\n    } else\n#endif\n\n    {\n        p = ngx_strlchr(text, last, ':');\n\n        if (p == NULL) {\n            return NGX_DECLINED;\n        }\n    }\n\n    p++;\n    plen = last - p;\n\n    port = ngx_atoi(p, plen);\n\n    if (port < 1 || port > 65535) {\n        return NGX_DECLINED;\n    }\n\n    len -= plen + 1;\n\n    rc = ngx_parse_addr(pool, addr, text, len);\n\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    __ngx_inet_set_port(addr->sockaddr, (in_port_t) port);\n\n    return NGX_OK;\n}\n\n#endif\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_get_peer(ngx_peer_connection_t *pc, void *data)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_test_connect(ngx_connection_t *c)\n{\n    int        err;\n    socklen_t  len;\n\n#if (NGX_HAVE_KQUEUE)\n\n    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT)  {\n        if (c->write->pending_eof || c->read->pending_eof) {\n            if (c->write->pending_eof) {\n                err = c->write->kq_errno;\n\n            } else {\n                err = c->read->kq_errno;\n            }\n\n            c->log->action = \"connecting to upstream\";\n            (void) ngx_connection_error(c, err,\n                              \"proxy_connet: upstream connect failed (kevent)\");\n            return NGX_ERROR;\n        }\n\n    } else\n#endif\n    {\n        err = 0;\n        len = sizeof(int);\n\n        /*\n         * BSDs and Linux return 0 and set a pending error in err\n         * Solaris returns -1 and sets errno\n         */\n\n        if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, (void *) &err, &len)\n            == -1)\n        {\n            err = ngx_errno;\n        }\n\n        if (err) {\n            c->log->action = \"connecting to upstream\";\n            (void) ngx_connection_error(c, err,\n                                      \"proxy_connect: upstream connect failed\");\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_proxy_connect_finalize_request(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u, ngx_int_t rc)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: finalize upstream request: %i\", rc);\n\n    r->keepalive = 0;\n\n    if (u->resolved && u->resolved->ctx) {\n        ngx_resolve_name_done(u->resolved->ctx);\n        u->resolved->ctx = NULL;\n    }\n\n    if (u->peer.free && u->peer.sockaddr) {\n        u->peer.free(&u->peer, u->peer.data, 0);\n        u->peer.sockaddr = NULL;\n    }\n\n    if (u->peer.connection) {\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"proxy_connect: close upstream connection: %d\",\n                       u->peer.connection->fd);\n\n        if (u->peer.connection->pool) {\n            ngx_destroy_pool(u->peer.connection->pool);\n        }\n\n        ngx_close_connection(u->peer.connection);\n    }\n\n    u->peer.connection = NULL;\n\n    if (rc == NGX_DECLINED) {\n        return;\n    }\n\n    r->connection->log->action = \"sending to client\";\n\n    if (rc == NGX_HTTP_REQUEST_TIME_OUT\n        || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST)\n    {\n        ngx_http_finalize_request(r, rc);\n        return;\n    }\n\n    if (u->connected && rc >= NGX_HTTP_SPECIAL_RESPONSE) {\n        rc = NGX_ERROR;\n    }\n\n    ngx_http_finalize_request(r, rc);\n}\n\n\nstatic void\nngx_http_proxy_connect_send_connection_established(ngx_http_request_t *r)\n{\n    ngx_int_t                              n;\n    ngx_buf_t                             *b;\n    ngx_connection_t                      *c;\n    ngx_http_core_loc_conf_t              *clcf;\n    ngx_http_proxy_connect_upstream_t     *u;\n    ngx_http_proxy_connect_ctx_t          *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n    c = r->connection;\n    u = ctx->u;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: send 200 connection established\");\n\n    u->connected = 1;\n\n    if (u->state.connect_time == (ngx_msec_t) -1) {\n        u->state.connect_time = ngx_current_msec - u->start_time;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    b = &ctx->buf;\n\n    /* modify CONNECT response via proxy_connect_response directive */\n    {\n    ngx_str_t                               resp;\n    ngx_http_proxy_connect_loc_conf_t      *plcf;\n\n    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_connect_module);\n\n    if (plcf->response\n        && ngx_http_complex_value(r, plcf->response, &resp) == NGX_OK)\n    {\n        if (resp.len > 0) {\n            b->pos = resp.data;\n            b->last = b->pos + resp.len;\n        }\n    }\n    }\n\n    ctx->send_established = 1;\n\n    for (;;) {\n        n = c->send(c, b->pos, b->last - b->pos);\n\n        if (n >= 0) {\n\n            r->headers_out.status = 200;    /* fixed that $status is 000 */\n\n            b->pos += n;\n\n            if (b->pos == b->last) {\n                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                              \"proxy_connect: sent 200 connection established\");\n\n                if (c->write->timer_set) {\n                    ngx_del_timer(c->write);\n                }\n\n                ctx->send_established_done = 1;\n\n                r->write_event_handler =\n                                        ngx_http_proxy_connect_write_downstream;\n                r->read_event_handler = ngx_http_proxy_connect_read_downstream;\n\n                if (ngx_handle_write_event(c->write, clcf->send_lowat)\n                    != NGX_OK)\n                {\n                    ngx_http_proxy_connect_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n                    return;\n                }\n\n                if (r->header_in->last > r->header_in->pos || c->read->ready) {\n                    r->read_event_handler(r);\n                    return;\n                }\n\n                return;\n            }\n\n            /* keep sending more data */\n            continue;\n        }\n\n        /* NGX_ERROR || NGX_AGAIN */\n        break;\n    }\n\n    if (n == NGX_ERROR) {\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_ERROR);\n        return;\n    }\n\n    /* n == NGX_AGAIN */\n\n    r->write_event_handler = ngx_http_proxy_connect_send_handler;\n\n    ngx_add_timer(c->write, ctx->data_timeout);\n\n    if (ngx_handle_write_event(c->write, clcf->send_lowat) != NGX_OK) {\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return;\n    }\n\n    return;\n}\n\n\nstatic void\nngx_http_proxy_connect_tunnel(ngx_http_request_t *r,\n    ngx_uint_t from_upstream, ngx_uint_t do_write)\n{\n    char                               *recv_action, *send_action;\n    size_t                              size;\n    ssize_t                             n;\n    ngx_buf_t                          *b;\n    ngx_uint_t                          flags;\n    ngx_connection_t                   *c, *pc, *dst, *src;\n    ngx_http_proxy_connect_ctx_t       *ctx;\n    ngx_http_proxy_connect_upstream_t  *u;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    c = r->connection;\n    u = ctx->u;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"proxy_connect: tunnel fu:%ui write:%ui\",\n                   from_upstream, do_write);\n\n    pc = u->peer.connection;\n\n    if (from_upstream) {\n        src = pc;\n        dst = c;\n        b = &u->buffer;\n        recv_action = \"proxying and reading from upstream\";\n        send_action = \"proxying and sending to client\";\n\n    } else {\n        src = c;\n        dst = pc;\n        b = &u->from_client;\n\n        if (r->header_in->last > r->header_in->pos) {\n            b = r->header_in;\n            b->end = b->last;\n            do_write = 1;\n        }\n\n        if (b->start == NULL) {\n            b->start = ngx_palloc(r->pool, u->conf->buffer_size);\n            if (b->start == NULL) {\n                ngx_http_proxy_connect_finalize_request(r, u, NGX_ERROR);\n                return;\n            }\n\n            b->pos = b->start;\n            b->last = b->start;\n            b->end = b->start + u->conf->buffer_size;\n            b->temporary = 1;\n        }\n        recv_action = \"proxying and reading from client\";\n        send_action = \"proxying and sending to upstream\";\n    }\n\n    for ( ;; ) {\n\n        if (do_write) {\n\n            size = b->last - b->pos;\n\n            if (size && dst->write->ready) {\n                c->log->action = send_action;\n\n                n = dst->send(dst, b->pos, size);\n\n                if (n == NGX_AGAIN) {\n                    break;\n                }\n\n                if (n == NGX_ERROR) {\n                    ngx_http_proxy_connect_finalize_request(r, u, NGX_ERROR);\n                    return;\n                }\n\n                if (n > 0) {\n                    b->pos += n;\n\n                    if (b->pos == b->last) {\n                        b->pos = b->start;\n                        b->last = b->start;\n                    }\n                }\n            }\n        }\n\n        size = b->end - b->last;\n\n        if (size && src->read->ready) {\n\n            c->log->action = recv_action;\n\n            n = src->recv(src, b->last, size);\n\n            if (n == NGX_AGAIN || n == 0) {\n                break;\n            }\n\n            if (n > 0) {\n                do_write = 1;\n                b->last += n;\n\n                if (from_upstream) {\n                    if (u->state.first_byte_time == (ngx_msec_t) -1) {\n                        u->state.first_byte_time = ngx_current_msec\n                            - u->start_time;\n                    }\n                }\n\n                continue;\n            }\n\n            if (n == NGX_ERROR) {\n                src->read->eof = 1;\n            }\n        }\n\n        break;\n    }\n\n    c->log->action = \"proxying connection\";\n\n    /* test finalize */\n\n    if ((pc->read->eof && u->buffer.pos == u->buffer.last)\n        || (c->read->eof && u->from_client.pos == u->from_client.last)\n        || (c->read->eof && pc->read->eof))\n    {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                       \"proxy_connect: tunnel done\");\n        ngx_http_proxy_connect_finalize_request(r, u, 0);\n        return;\n    }\n\n    flags = src->read->eof ? NGX_CLOSE_EVENT : 0;\n\n    if (ngx_handle_read_event(src->read, flags) != NGX_OK) {\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_ERROR);\n        return;\n    }\n\n    if (dst) {\n        if (ngx_handle_write_event(dst->write, 0) != NGX_OK) {\n            ngx_http_proxy_connect_finalize_request(r, u, NGX_ERROR);\n            return;\n        }\n\n        if (!c->read->delayed && !pc->read->delayed) {\n            ngx_add_timer(c->write, ctx->data_timeout);\n\n        } else if (c->write->timer_set) {\n            ngx_del_timer(c->write);\n        }\n    }\n}\n\n\nstatic void\nngx_http_proxy_connect_read_downstream(ngx_http_request_t *r)\n{\n    ngx_http_proxy_connect_ctx_t       *ctx;\n\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy connect read downstream\");\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (r->connection->read->timedout) {\n        r->connection->timedout = 1;\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: client read timed out\");\n        ngx_http_proxy_connect_finalize_request(r, ctx->u,\n                                                NGX_HTTP_REQUEST_TIME_OUT);\n        return;\n    }\n\n    ngx_http_proxy_connect_tunnel(r, 0, 0);\n}\n\n\nstatic void\nngx_http_proxy_connect_write_downstream(ngx_http_request_t *r)\n{\n    ngx_http_proxy_connect_ctx_t       *ctx;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy connect write downstream\");\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (r->connection->write->timedout) {\n        r->connection->timedout = 1;\n        ngx_connection_error(r->connection, NGX_ETIMEDOUT,\n                             \"proxy_connect: connection timed out\");\n        ngx_http_proxy_connect_finalize_request(r, ctx->u,\n                                                NGX_HTTP_REQUEST_TIME_OUT);\n        return;\n    }\n\n    ngx_http_proxy_connect_tunnel(r, 1, 1);\n}\n\n\nstatic void\nngx_http_proxy_connect_read_upstream(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u)\n{\n    ngx_connection_t                    *c;\n    ngx_http_proxy_connect_ctx_t        *ctx;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: upstream read handler\");\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    c = u->peer.connection;\n\n    if (c->read->timedout) {\n        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                      \"proxy_connect: upstream read timed out (peer:%V)\",\n                      u->peer.name);\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_GATEWAY_TIME_OUT);\n        return;\n    }\n\n    if (!ctx->send_established &&\n        ngx_http_proxy_connect_test_connect(c) != NGX_OK)\n    {\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        return;\n    }\n\n    if (u->buffer.start == NULL) {\n        u->buffer.start = ngx_palloc(r->pool, u->conf->buffer_size);\n        if (u->buffer.start == NULL) {\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        u->buffer.pos = u->buffer.start;\n        u->buffer.last = u->buffer.start;\n        u->buffer.end = u->buffer.start + u->conf->buffer_size;\n        u->buffer.temporary = 1;\n    }\n\n    if (!ctx->send_established_done) {\n        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        return;\n    }\n\n    ngx_http_proxy_connect_tunnel(r, 1, 0);\n}\n\n\nstatic void\nngx_http_proxy_connect_write_upstream(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u)\n{\n    ngx_connection_t  *c;\n    ngx_http_proxy_connect_ctx_t          *ctx;\n\n    c = u->peer.connection;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: upstream write handler %s\",\n                   u->connected ? \"\" : \"(connect)\");\n\n    if (c->write->timedout) {\n        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                      \"proxy_connect: upstream %s timed out (peer:%V)\",\n                      u->connected ? \"write\" : \"connect\", u->peer.name);\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                                NGX_HTTP_GATEWAY_TIME_OUT);\n        return;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (c->write->timer_set) {\n        ngx_del_timer(c->write);\n    }\n\n    if (!ctx->send_established &&\n        ngx_http_proxy_connect_test_connect(c) != NGX_OK)\n    {\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        return;\n    }\n\n    if (!ctx->send_established) {\n        ngx_http_proxy_connect_send_connection_established(r);\n        return;\n    }\n\n    if (!ctx->send_established_done) {\n        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n\n        return;\n    }\n\n    ngx_http_proxy_connect_tunnel(r, 0, 1);\n}\n\n\nstatic void\nngx_http_proxy_connect_send_handler(ngx_http_request_t *r)\n{\n    ngx_connection_t                 *c;\n    ngx_http_proxy_connect_ctx_t     *ctx;\n\n    c = r->connection;\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: send connection established handler\");\n\n    if (c->write->timedout) {\n        c->timedout = 1;\n        ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                      \"proxy_connect: client write timed out\");\n        ngx_http_proxy_connect_finalize_request(r, ctx->u,\n                                                NGX_HTTP_REQUEST_TIME_OUT);\n        return;\n    }\n\n    if (ctx->buf.pos != ctx->buf.last) {\n        ngx_http_proxy_connect_send_connection_established(r);\n    }\n}\n\n\nstatic void\nngx_http_proxy_connect_upstream_handler(ngx_event_t *ev)\n{\n    ngx_connection_t                    *c;\n    ngx_http_request_t                  *r;\n    ngx_http_log_ctx_t                  *lctx;\n    ngx_http_proxy_connect_upstream_t   *u;\n\n    c = ev->data;\n    u = c->data;\n\n    r = u->request;\n    c = r->connection;\n\n    lctx = c->log->data;\n    lctx->current_request = r;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"proxy_connect: upstream handler: \\\"%V:%V\\\"\",\n                   &r->connect_host, &r->connect_port);\n\n    if (ev->write) {\n        u->write_event_handler(r, u);\n\n    } else {\n        u->read_event_handler(r, u);\n    }\n\n    ngx_http_run_posted_requests(c);\n}\n\n\nstatic void\nngx_http_proxy_connect_process_connect(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u)\n{\n    ngx_int_t                        rc;\n    ngx_connection_t                *c;\n    ngx_peer_connection_t           *pc;\n    ngx_http_upstream_resolved_t    *ur;\n    ngx_http_proxy_connect_ctx_t    *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    r->connection->log->action = \"connecting to upstream\";\n\n    if (ngx_http_proxy_connect_set_local(r, u, u->conf->local) != NGX_OK) {\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return;\n    }\n\n    pc = &u->peer;\n    ur = u->resolved;\n\n    pc->sockaddr = ur->sockaddr;\n    pc->socklen = ur->socklen;\n    pc->name = &ur->host;\n\n    pc->get = ngx_http_proxy_connect_get_peer;\n\n    u->start_time = ngx_current_msec;\n    u->state.connect_time = (ngx_msec_t) -1;\n    u->state.first_byte_time = (ngx_msec_t) -1;\n\n    rc = ngx_event_connect_peer(&u->peer);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: ngx_event_connect_peer() returns %i\", rc);\n\n    /*\n     * We do not retry next upstream if current connecting fails.\n     * So there is no ngx_http_proxy_connect_upstream_next() function\n     */\n\n    if (rc == NGX_ERROR) {\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return;\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: no live connection\");\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        return;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: connection error\");\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        return;\n    }\n\n    /* rc == NGX_OK || rc == NGX_AGAIN || rc == NGX_DONE */\n\n    c = pc->connection;\n\n    c->data = u;\n\n    c->write->handler = ngx_http_proxy_connect_upstream_handler;\n    c->read->handler = ngx_http_proxy_connect_upstream_handler;\n\n    u->write_event_handler = ngx_http_proxy_connect_write_upstream;\n    u->read_event_handler = ngx_http_proxy_connect_read_upstream;\n\n    c->sendfile &= r->connection->sendfile;\n    c->log = r->connection->log;\n\n    if (c->pool == NULL) {\n\n        c->pool = ngx_create_pool(128, r->connection->log);\n        if (c->pool == NULL) {\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n    }\n\n    c->pool->log = c->log;\n    c->read->log = c->log;\n    c->write->log = c->log;\n\n    if (rc == NGX_AGAIN) {\n        ngx_add_timer(c->write, ctx->connect_timeout);\n        return;\n    }\n\n    ngx_http_proxy_connect_send_connection_established(r);\n}\n\n\nstatic void\nngx_http_proxy_connect_resolve_handler(ngx_resolver_ctx_t *ctx)\n{\n    ngx_connection_t                            *c;\n    ngx_http_request_t                          *r;\n    ngx_http_upstream_resolved_t                *ur;\n    ngx_http_proxy_connect_upstream_t           *u;\n\n#if defined(nginx_version) && nginx_version >= 1013002\n    ngx_uint_t run_posted = ctx->async;\n#endif\n\n    u = ctx->data;\n    r = u->request;\n    ur = u->resolved;\n    c = r->connection;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: resolve handler\");\n\n    if (ctx->state) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: %V could not be resolved (%i: %s)\",\n                      &ctx->name, ctx->state,\n                      ngx_resolver_strerror(ctx->state));\n\n        ngx_http_proxy_connect_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY);\n        goto failed;\n    }\n\n    ur->naddrs = ctx->naddrs;\n    ur->addrs = ctx->addrs;\n\n#if (NGX_DEBUG)\n    {\n#   if defined(nginx_version) && nginx_version >= 1005008\n    ngx_uint_t  i;\n    ngx_str_t   addr;\n    u_char      text[NGX_SOCKADDR_STRLEN];\n\n    addr.data = text;\n\n    for (i = 0; i < ctx->naddrs; i++) {\n        addr.len = ngx_sock_ntop(ur->addrs[i].sockaddr, ur->addrs[i].socklen,\n                                 text, NGX_SOCKADDR_STRLEN, 0);\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"proxy_connect: name was resolved to %V\", &addr);\n    }\n#   else\n    ngx_uint_t  i;\n    in_addr_t   addr;\n\n    for (i = 0; i < ctx->naddrs; i++) {\n        addr = ntohl(ctx->addrs[i]);\n\n        ngx_log_debug4(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                       \"proxy_connect: name was resolved to %ud.%ud.%ud.%ud\",\n                       (addr >> 24) & 0xff, (addr >> 16) & 0xff,\n                       (addr >> 8) & 0xff, addr & 0xff);\n    }\n#   endif\n    }\n#endif\n\n    if (ngx_http_proxy_connect_create_peer(r, ur) != NGX_OK) {\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                                NGX_HTTP_INTERNAL_SERVER_ERROR);\n        goto failed;\n    }\n\n    ngx_resolve_name_done(ctx);\n    ur->ctx = NULL;\n\n    u->_resolved = 1;\n\n    if (u->state.resolve_time == (ngx_msec_t) -1) {\n        u->state.resolve_time = ngx_current_msec - u->start_time;\n    }\n\n    ngx_http_proxy_connect_process_connect(r, u);\n\nfailed:\n\n#if defined(nginx_version) && nginx_version >= 1013002\n    if (run_posted) {\n        ngx_http_run_posted_requests(c);\n    }\n#else\n    ngx_http_run_posted_requests(c);\n#endif\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_create_peer(ngx_http_request_t *r,\n    ngx_http_upstream_resolved_t *ur)\n{\n    u_char                                      *p;\n    ngx_int_t                                    i, len;\n    socklen_t                                    socklen;\n    struct sockaddr                             *sockaddr;\n\n    i = ngx_random() % ur->naddrs;  /* i<-0 for ur->naddrs == 1 */\n\n#if defined(nginx_version) && nginx_version >= 1005008\n\n    socklen = ur->addrs[i].socklen;\n\n    sockaddr = ngx_palloc(r->pool, socklen);\n    if (sockaddr == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(sockaddr, ur->addrs[i].sockaddr, socklen);\n\n    switch (sockaddr->sa_family) {\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        ((struct sockaddr_in6 *) sockaddr)->sin6_port = htons(ur->port);\n        break;\n#endif\n    default: /* AF_INET */\n        ((struct sockaddr_in *) sockaddr)->sin_port = htons(ur->port);\n    }\n\n#else\n    /* for nginx older than 1.5.8 */\n\n    socklen = sizeof(struct sockaddr_in);\n\n    sockaddr = ngx_pcalloc(r->pool, socklen);\n    if (sockaddr == NULL) {\n        return NGX_ERROR;\n    }\n\n    ((struct sockaddr_in *) sockaddr)->sin_family = AF_INET;\n    ((struct sockaddr_in *) sockaddr)->sin_addr.s_addr = ur->addrs[i];\n    ((struct sockaddr_in *) sockaddr)->sin_port = htons(ur->port);\n\n#endif\n\n    p = ngx_pnalloc(r->pool, NGX_SOCKADDR_STRLEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    len = __ngx_sock_ntop(sockaddr, socklen, p, NGX_SOCKADDR_STRLEN, 1);\n\n    ur->sockaddr = sockaddr;\n    ur->socklen = socklen;\n\n    ur->host.data = p;\n    ur->host.len = len;\n    ur->naddrs = 1;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_upstream_create(ngx_http_request_t *r,\n    ngx_http_proxy_connect_ctx_t *ctx)\n{\n    ngx_http_proxy_connect_upstream_t       *u;\n\n    u = ngx_pcalloc(r->pool, sizeof(ngx_http_proxy_connect_upstream_t));\n    if (u == NULL) {\n        return NGX_ERROR;\n    }\n\n    ctx->u = u;\n\n    u->peer.log = r->connection->log;\n    u->peer.log_error = NGX_ERROR_ERR;\n\n    u->request = r;\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_proxy_connect_check_broken_connection(ngx_http_request_t *r,\n    ngx_event_t *ev)\n{\n    int                                 n;\n    char                                buf[1];\n    ngx_err_t                           err;\n    ngx_int_t                           event;\n    ngx_connection_t                   *c;\n    ngx_http_proxy_connect_ctx_t       *ctx;\n    ngx_http_proxy_connect_upstream_t  *u;\n\n    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ev->log, 0,\n                   \"proxy_connect: check client, write event:%d, \\\"%V:%V\\\"\",\n                   ev->write, &r->connect_host, &r->connect_port);\n\n    c = r->connection;\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n    u = ctx->u;\n\n    if (c->error) {\n        if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {\n\n            event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;\n\n            if (ngx_del_event(ev, event, 0) != NGX_OK) {\n                ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return;\n            }\n        }\n\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_CLIENT_CLOSED_REQUEST);\n\n        return;\n    }\n\n#if (NGX_HAVE_KQUEUE)\n\n    if (ngx_event_flags & NGX_USE_KQUEUE_EVENT) {\n\n        if (!ev->pending_eof) {\n            return;\n        }\n\n        ev->eof = 1;\n        c->error = 1;\n\n        if (ev->kq_errno) {\n            ev->error = 1;\n        }\n\n        if (u->peer.connection) {\n            ngx_log_error(NGX_LOG_INFO, ev->log, ev->kq_errno,\n                          \"proxy_connect: kevent() reported that client \"\n                          \"prematurely closed connection, so upstream \"\n                          \" connection is closed too\");\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_CLIENT_CLOSED_REQUEST);\n            return;\n        }\n\n        ngx_log_error(NGX_LOG_INFO, ev->log, ev->kq_errno,\n                      \"proxy_connect: kevent() reported that client \"\n                      \"prematurely closed connection\");\n\n        if (u->peer.connection == NULL) {\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_CLIENT_CLOSED_REQUEST);\n        }\n\n        return;\n    }\n\n#endif\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n\n    err = ngx_socket_errno;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ev->log, err,\n                   \"proxy_connect: client recv(): %d\", n);\n\n    if (ev->write && (n >= 0 || err == NGX_EAGAIN)) {\n        return;\n    }\n\n    if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {\n\n        event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;\n\n        if (ngx_del_event(ev, event, 0) != NGX_OK) {\n            ngx_http_proxy_connect_finalize_request(r, u,\n                                               NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return;\n        }\n    }\n\n    if (n > 0) {\n        return;\n    }\n\n    if (n == -1) {\n        if (err == NGX_EAGAIN) {\n            return;\n        }\n\n        ev->error = 1;\n\n    } else { /* n == 0 */\n        err = 0;\n    }\n\n    ev->eof = 1;\n    c->error = 1;\n\n    if (u->peer.connection) {\n        ngx_log_error(NGX_LOG_INFO, ev->log, err,\n                      \"proxy_connect: client prematurely closed connection, \"\n                      \"so upstream connection is closed too\");\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                           NGX_HTTP_CLIENT_CLOSED_REQUEST);\n        return;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, ev->log, err,\n                  \"proxy_connect: client prematurely closed connection\");\n\n    if (u->peer.connection == NULL) {\n        ngx_http_proxy_connect_finalize_request(r, u,\n                                           NGX_HTTP_CLIENT_CLOSED_REQUEST);\n    }\n}\n\n\nstatic void\nngx_http_proxy_connect_rd_check_broken_connection(ngx_http_request_t *r)\n{\n    ngx_http_proxy_connect_check_broken_connection(r, r->connection->read);\n}\n\n\nstatic void\nngx_http_proxy_connect_wr_check_broken_connection(ngx_http_request_t *r)\n{\n    ngx_http_proxy_connect_check_broken_connection(r, r->connection->write);\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_handler(ngx_http_request_t *r)\n{\n    ngx_url_t                            url;\n    ngx_int_t                            rc;\n    ngx_resolver_ctx_t                  *rctx, temp;\n    ngx_http_core_loc_conf_t            *clcf;\n    ngx_http_proxy_connect_ctx_t        *ctx;\n    ngx_http_proxy_connect_upstream_t   *u;\n    ngx_http_proxy_connect_loc_conf_t   *plcf;\n\n    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_connect_module);\n\n    if (r->method != NGX_HTTP_CONNECT || !plcf->accept_connect) {\n        return NGX_DECLINED;\n    }\n\n    rc = ngx_http_proxy_connect_allow_handler(r, plcf);\n\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);;\n\n    if (ngx_http_proxy_connect_upstream_create(r, ctx) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    u = ctx->u;\n\n    u->conf = plcf;\n\n    ngx_memzero(&url, sizeof(ngx_url_t));\n\n    if (plcf->address) {\n        if (ngx_http_complex_value(r, plcf->address, &url.url) != NGX_OK) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (url.url.len == 0 || url.url.data == NULL) {\n            url.url.len = r->connect_host.len;\n            url.url.data = r->connect_host.data;\n        }\n\n    } else {\n        url.url.len = r->connect_host.len;\n        url.url.data = r->connect_host.data;\n    }\n\n    url.default_port = r->connect_port_n;\n    url.no_resolve = 1;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"proxy_connect: connect handler: parse url: %V\" , &url.url);\n\n    if (ngx_parse_url(r->pool, &url) != NGX_OK) {\n        if (url.err) {\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"proxy_connect: %s in connect host \\\"%V\\\"\",\n                          url.err, &url.url);\n            return NGX_HTTP_FORBIDDEN;\n        }\n\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->read_event_handler = ngx_http_proxy_connect_rd_check_broken_connection;\n    r->write_event_handler = ngx_http_proxy_connect_wr_check_broken_connection;\n\n    /* NOTE:\n     *   We use only one address in u->resolved,\n     *   and u->resolved.host is \"<address:port>\" format.\n     */\n\n    u->resolved = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t));\n    if (u->resolved == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* rc = NGX_DECLINED */\n\n    if (url.addrs) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"proxy_connect: upstream address given directly\");\n\n        u->resolved->sockaddr = url.addrs[0].sockaddr;\n        u->resolved->socklen = url.addrs[0].socklen;\n#if defined(nginx_version) && nginx_version >= 1011007\n        u->resolved->name = url.addrs[0].name;\n#endif\n        u->resolved->naddrs = 1;\n    }\n\n    u->resolved->host = url.host;\n    u->resolved->port = (in_port_t) (url.no_port ? r->connect_port_n : url.port);\n    u->resolved->no_port = url.no_port;\n\n    if (u->resolved->sockaddr) {\n\n        rc = ngx_http_proxy_connect_sock_ntop(r, u);\n\n        if (rc != NGX_OK) {\n            return rc;\n        }\n\n        r->main->count++;\n\n        ngx_http_proxy_connect_process_connect(r, u);\n\n        return NGX_DONE;\n    }\n\n    ngx_str_t *host = &url.host;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    temp.name = *host;\n\n    u->start_time = ngx_current_msec;\n    u->state.resolve_time = (ngx_msec_t) -1;\n\n    rctx = ngx_resolve_start(clcf->resolver, &temp);\n    if (rctx == NULL) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: failed to start the resolver\");\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (rctx == NGX_NO_RESOLVER) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: no resolver defined to resolve %V\",\n                      &r->connect_host);\n        return NGX_HTTP_BAD_GATEWAY;\n    }\n\n    rctx->name = *host;\n#if !defined(nginx_version) || nginx_version < 1005008\n    rctx->type = NGX_RESOLVE_A;\n#endif\n    rctx->handler = ngx_http_proxy_connect_resolve_handler;\n    rctx->data = u;\n    rctx->timeout = clcf->resolver_timeout;\n\n    u->resolved->ctx = rctx;\n\n    r->main->count++;\n\n    if (ngx_resolve_name(rctx) != NGX_OK) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"proxy_connect: fail to run resolver immediately\");\n\n        u->resolved->ctx = NULL;\n        r->main->count--;\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    return NGX_DONE;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_sock_ntop(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u)\n{\n    u_char                          *p;\n    ngx_int_t                        len;\n    ngx_http_upstream_resolved_t    *ur;\n\n    ur = u->resolved;\n\n    /* fix u->resolved->host to \"<address:port>\" format */\n\n    p = ngx_pnalloc(r->pool, NGX_SOCKADDR_STRLEN);\n    if (p == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    len = __ngx_sock_ntop(ur->sockaddr, ur->socklen, p, NGX_SOCKADDR_STRLEN, 1);\n\n    u->resolved->host.data = p;\n    u->resolved->host.len = len;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_allow_handler(ngx_http_request_t *r,\n    ngx_http_proxy_connect_loc_conf_t *plcf)\n{\n    ngx_uint_t  i, allow;\n    in_port_t   (*ports)[2];\n\n    allow = 0;\n\n    if (plcf->allow_port_all) {\n        allow = 1;\n\n    } else if (plcf->allow_ports) {\n        ports = plcf->allow_ports->elts;\n\n        for (i = 0; i < plcf->allow_ports->nelts; i++) {\n            /*\n             * connect_port == port\n             * OR\n             * port <= connect_port <= eport\n             */\n            if ((ports[i][1] == 0 && r->connect_port_n == ports[i][0])\n                || (ports[i][0] <= r->connect_port_n && r->connect_port_n <= ports[i][1]))\n            {\n                allow = 1;\n                break;\n            }\n        }\n\n    } else {\n        if (r->connect_port_n == 443 || r->connect_port_n == 563) {\n            allow = 1;\n        }\n    }\n\n    if (allow == 0) {\n        return NGX_HTTP_FORBIDDEN;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_http_proxy_connect_allow(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    u_char                              *p;\n    in_port_t                           *ports;\n    ngx_int_t                            port, eport;\n    ngx_uint_t                           i;\n    ngx_str_t                           *value;\n    ngx_http_proxy_connect_loc_conf_t   *plcf = conf;\n\n    if (plcf->allow_ports != NGX_CONF_UNSET_PTR) {\n        return \"is duplicate\";\n    }\n\n    plcf->allow_ports = ngx_array_create(cf->pool, 2, sizeof(in_port_t[2]));\n    if (plcf->allow_ports == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        if (value[i].len == 3 && ngx_strncmp(value[i].data, \"all\", 3) == 0) {\n            plcf->allow_port_all = 1;\n            continue;\n        }\n\n        p = ngx_strlchr(value[i].data, value[i].data + value[i].len, '-');\n\n        if (p != NULL) {\n            port = ngx_atoi(value[i].data, p - value[i].data);\n            p++;\n            eport = ngx_atoi(p, value[i].data + value[i].len - p);\n\n            if (port == NGX_ERROR || port < 1 || port > 65535\n                || eport == NGX_ERROR || eport < 1 || eport > 65535\n                || port > eport)\n            {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid port range \\\"%V\\\" in \\\"%V\\\" directive\",\n                                   &value[i], &cmd->name);\n                return  NGX_CONF_ERROR;\n            }\n\n        } else {\n\n            port = ngx_atoi(value[i].data, value[i].len);\n\n            if (port == NGX_ERROR || port < 1 || port > 65535) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid value \\\"%V\\\" in \\\"%V\\\" directive\",\n                                   &value[i], &cmd->name);\n                return  NGX_CONF_ERROR;\n            }\n\n            eport = 0;\n        }\n\n        ports = ngx_array_push(plcf->allow_ports);\n        if (ports == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        ports[0] = port;\n        ports[1] = eport;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_http_proxy_connect(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_http_core_loc_conf_t            *clcf;\n    ngx_http_proxy_connect_loc_conf_t   *pclcf;\n\n    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n    clcf->handler = ngx_http_proxy_connect_handler;\n\n    pclcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_proxy_connect_module);\n    pclcf->accept_connect = 1;\n\n    return NGX_CONF_OK;\n}\n\n\nchar *\nngx_http_proxy_connect_bind(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf)\n{\n    char  *p = conf;\n\n    ngx_int_t                           rc;\n    ngx_str_t                          *value;\n    ngx_http_complex_value_t            cv;\n    ngx_http_proxy_connect_address_t  **plocal, *local;\n    ngx_http_compile_complex_value_t    ccv;\n\n    plocal = (ngx_http_proxy_connect_address_t **) (p + cmd->offset);\n\n    if (*plocal != NGX_CONF_UNSET_PTR) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (cf->args->nelts == 2 && ngx_strcmp(value[1].data, \"off\") == 0) {\n        *plocal = NULL;\n        return NGX_CONF_OK;\n    }\n\n    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));\n\n    ccv.cf = cf;\n    ccv.value = &value[1];\n    ccv.complex_value = &cv;\n\n    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    local = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_connect_address_t));\n    if (local == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *plocal = local;\n\n    if (cv.lengths) {\n        local->value = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));\n        if (local->value == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *local->value = cv;\n\n    } else {\n        local->addr = ngx_palloc(cf->pool, sizeof(ngx_addr_t));\n        if (local->addr == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        rc = __ngx_parse_addr_port(cf->pool, local->addr, value[1].data,\n                                   value[1].len);\n\n        switch (rc) {\n        case NGX_OK:\n            local->addr->name = value[1];\n            break;\n\n        case NGX_DECLINED:\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid address \\\"%V\\\"\", &value[1]);\n            /* fall through */\n\n        default:\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    if (cf->args->nelts > 2) {\n        if (ngx_strcmp(value[2].data, \"transparent\") == 0) {\n#if (NGX_HAVE_TRANSPARENT_PROXY)\n            local->transparent = 1;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"transparent proxying is not supported \"\n                               \"on this platform, ignored\");\n#endif\n        } else {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid parameter \\\"%V\\\"\", &value[2]);\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_set_local(ngx_http_request_t *r,\n    ngx_http_proxy_connect_upstream_t *u, ngx_http_proxy_connect_address_t *local)\n{\n    ngx_int_t    rc;\n    ngx_str_t    val;\n    ngx_addr_t  *addr;\n\n    if (local == NULL) {\n        u->peer.local = NULL;\n        return NGX_OK;\n    }\n\n#if (NGX_HAVE_TRANSPARENT_PROXY)\n    u->peer.transparent = local->transparent;\n#endif\n\n    if (local->value == NULL) {\n        u->peer.local = local->addr;\n        return NGX_OK;\n    }\n\n    if (ngx_http_complex_value(r, local->value, &val) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (val.len == 0) {\n        return NGX_OK;\n    }\n\n    addr = ngx_palloc(r->pool, sizeof(ngx_addr_t));\n    if (addr == NULL) {\n        return NGX_ERROR;\n    }\n\n    rc = __ngx_parse_addr_port(r->pool, addr, val.data, val.len);\n    if (rc == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    if (rc != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: invalid local address \\\"%V\\\"\", &val);\n        return NGX_OK;\n    }\n\n    addr->name = val;\n    u->peer.local = addr;\n\n    return NGX_OK;\n}\n\n\nstatic void *\nngx_http_proxy_connect_create_loc_conf(ngx_conf_t *cf)\n{\n    ngx_http_proxy_connect_loc_conf_t  *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_connect_loc_conf_t));\n    if (conf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * set by ngx_pcalloc():\n     *\n     *     conf->address = NULL;\n     */\n\n    conf->accept_connect = NGX_CONF_UNSET;\n    conf->allow_port_all = NGX_CONF_UNSET;\n    conf->allow_ports = NGX_CONF_UNSET_PTR;\n\n    conf->connect_timeout = NGX_CONF_UNSET_MSEC;\n    conf->send_timeout = NGX_CONF_UNSET_MSEC;\n    conf->data_timeout = NGX_CONF_UNSET_MSEC;\n\n    conf->send_lowat = NGX_CONF_UNSET_SIZE;\n    conf->buffer_size = NGX_CONF_UNSET_SIZE;\n\n    conf->local = NGX_CONF_UNSET_PTR;\n\n    return conf;\n}\n\n\nstatic char *\nngx_http_proxy_connect_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_http_proxy_connect_loc_conf_t    *prev = parent;\n    ngx_http_proxy_connect_loc_conf_t    *conf = child;\n\n    ngx_conf_merge_value(conf->accept_connect, prev->accept_connect, 0);\n    ngx_conf_merge_value(conf->allow_port_all, prev->allow_port_all, 0);\n    ngx_conf_merge_ptr_value(conf->allow_ports, prev->allow_ports, NULL);\n\n    ngx_conf_merge_msec_value(conf->connect_timeout,\n                              prev->connect_timeout, 60000);\n\n    ngx_conf_merge_msec_value(conf->send_timeout, prev->send_timeout, 60000);\n\n    ngx_conf_merge_msec_value(conf->data_timeout, prev->data_timeout, 60000);\n\n    ngx_conf_merge_size_value(conf->send_lowat, prev->send_lowat, 0);\n\n    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size, 16384);\n\n    if (conf->address == NULL) {\n        conf->address = prev->address;\n    }\n\n    ngx_conf_merge_ptr_value(conf->local, prev->local, NULL);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_connect_addr_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n\n    ngx_http_proxy_connect_upstream_t     *u;\n    ngx_http_proxy_connect_ctx_t          *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    u = ctx->u;\n\n    if (u == NULL || u->peer.name == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->len = u->peer.name->len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = u->peer.name->data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_variable_get_time(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char                          *p;\n    ngx_msec_t                      *msp, ms;\n    ngx_http_proxy_connect_ctx_t    *ctx;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    msp = (ngx_msec_t *) ((char *) ctx + data);\n    ms = *msp;\n\n    p = ngx_pnalloc(r->pool, NGX_TIME_T_LEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = ngx_sprintf(p, \"%M\", ms) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_proxy_connect_variable_set_time(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    ngx_str_t                        s;\n    ngx_msec_t                      *msp, ms;\n    ngx_http_proxy_connect_ctx_t    *ctx;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return;\n    }\n\n    s.len = v->len;\n    s.data = v->data;\n\n    ms = ngx_parse_time(&s, 0);\n\n    if (ms == (ngx_msec_t) NGX_ERROR) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: invalid msec \\\"%V\\\" (ctx offset=%ui)\",\n                      &s, data);\n        return;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n#if 0\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"proxy_connect: no ctx found\");\n#endif\n        return;\n    }\n\n    msp = (ngx_msec_t *) ((char *) ctx + data);\n\n    *msp = ms;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_resolve_time_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char                             *p;\n    size_t                              len;\n    ngx_msec_int_t                      ms;\n    ngx_http_proxy_connect_ctx_t       *ctx;\n    ngx_http_proxy_connect_upstream_t  *u;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return NGX_OK;\n    }\n\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    u = ctx->u;\n\n    if (u == NULL || !u->resolved) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    len = NGX_TIME_T_LEN + 4;\n\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->data = p;\n\n    ms = u->state.resolve_time;\n\n    if (ms != -1) {\n        ms = ngx_max(ms, 0);\n        p = ngx_sprintf(p, \"%T.%03M\", (time_t) ms / 1000, ms % 1000);\n\n    } else {\n        *p++ = '-';\n    }\n\n    v->len = p - v->data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_connect_time_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char                             *p;\n    size_t                              len;\n    ngx_msec_int_t                      ms;\n    ngx_http_proxy_connect_ctx_t       *ctx;\n    ngx_http_proxy_connect_upstream_t  *u;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return NGX_OK;\n    }\n\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    u = ctx->u;\n\n    if (u == NULL || !u->connected) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    len = NGX_TIME_T_LEN + 4;\n\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->data = p;\n\n    ms = u->state.connect_time;\n\n    if (ms != -1) {\n        ms = ngx_max(ms, 0);\n        p = ngx_sprintf(p, \"%T.%03M\", (time_t) ms / 1000, ms % 1000);\n\n    } else {\n        *p++ = '-';\n    }\n\n    v->len = p - v->data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_first_byte_time_variable(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char                             *p;\n    size_t                              len;\n    ngx_msec_int_t                      ms;\n    ngx_http_proxy_connect_ctx_t       *ctx;\n    ngx_http_proxy_connect_upstream_t  *u;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return NGX_OK;\n    }\n\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    u = ctx->u;\n\n    if (u == NULL || !u->connected) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    len = NGX_TIME_T_LEN + 4;\n\n    p = ngx_pnalloc(r->pool, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->data = p;\n\n    ms = u->state.first_byte_time;\n\n    if (ms != -1) {\n        ms = ngx_max(ms, 0);\n        p = ngx_sprintf(p, \"%T.%03M\", (time_t) ms / 1000, ms % 1000);\n\n    } else {\n        *p++ = '-';\n    }\n\n    v->len = p - v->data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_variable_get_response(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    ngx_http_proxy_connect_ctx_t       *ctx;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return NGX_OK;\n    }\n\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = ctx->buf.pos;\n    v->len = ctx->buf.last - ctx->buf.pos;\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_proxy_connect_variable_set_response(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    ngx_http_proxy_connect_ctx_t       *ctx;\n\n    if (r->method != NGX_HTTP_CONNECT) {\n        return;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_connect_module);\n\n    if (ctx == NULL) {\n        return;\n    }\n\n    ctx->buf.pos = (u_char *) v->data;\n    ctx->buf.last = ctx->buf.pos + v->len;\n}\n\nstatic ngx_int_t\nngx_http_proxy_connect_add_variables(ngx_conf_t *cf)\n{\n    ngx_http_variable_t  *var, *v;\n\n    for (v = ngx_http_proxy_connect_vars; v->name.len; v++) {\n        var = ngx_http_add_variable(cf, &v->name, v->flags);\n        if (var == NULL) {\n            return NGX_ERROR;\n        }\n\n        *var = *v;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_post_read_handler(ngx_http_request_t *r)\n{\n    ngx_http_proxy_connect_ctx_t      *ctx;\n    ngx_http_proxy_connect_loc_conf_t *pclcf;\n\n    if (r->method == NGX_HTTP_CONNECT) {\n\n        pclcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_connect_module);\n\n        if (!pclcf->accept_connect) {\n            ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,\n                          \"proxy_connect: client sent connect method\");\n            return NGX_HTTP_NOT_ALLOWED;\n        }\n\n        /* init ctx */\n\n        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_proxy_connect_ctx_t));\n        if (ctx == NULL) {\n            return NGX_ERROR;\n        }\n\n        ctx->buf.pos = (u_char *) NGX_HTTP_PROXY_CONNECT_ESTABLISTHED;\n        ctx->buf.last = ctx->buf.pos +\n                        sizeof(NGX_HTTP_PROXY_CONNECT_ESTABLISTHED) - 1;\n        ctx->buf.memory = 1;\n\n        ctx->connect_timeout = pclcf->connect_timeout;\n        ctx->send_timeout = pclcf->send_timeout;\n        ctx->data_timeout = pclcf->data_timeout;\n\n        ngx_http_set_ctx(r, ctx, ngx_http_proxy_connect_module);\n    }\n\n    return NGX_DECLINED;\n}\n\n\nstatic ngx_int_t\nngx_http_proxy_connect_init(ngx_conf_t *cf)\n{\n    ngx_http_core_main_conf_t  *cmcf;\n    ngx_http_handler_pt        *h;\n\n    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);\n\n    h = ngx_array_push(&cmcf->phases[NGX_HTTP_POST_READ_PHASE].handlers);\n    if (h == NULL) {\n        return NGX_ERROR;\n    }\n\n    *h = ngx_http_proxy_connect_post_read_handler;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "patch",
          "type": "tree",
          "content": null
        },
        {
          "name": "t",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}