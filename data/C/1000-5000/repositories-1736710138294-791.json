{
  "metadata": {
    "timestamp": 1736710138294,
    "page": 791,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sheredom/utf8.h",
      "stars": 1779,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0400390625,
          "content": "BasedOnStyle: LLVM\r\nSortIncludes: false\r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0166015625,
          "content": "*.DS_Store\nbuild\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1826171875,
          "content": "This is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.681640625,
          "content": "# ðŸ“š utf8.h\n\n[![Actions Status](https://github.com/sheredom/utf8.h/workflows/CMake/badge.svg)](https://github.com/sheredom/utf8.h/actions)\n[![Build status](https://ci.appveyor.com/api/projects/status/phfjjahhs9j4gxvs?svg=true)](https://ci.appveyor.com/project/sheredom/utf8-h)\n[![Sponsor](https://img.shields.io/badge/ðŸ’œ-sponsor-blueviolet)](https://github.com/sponsors/sheredom)\n\nA simple one header solution to supporting utf8 strings in C and C++.\n\nFunctions provided from the C header string.h but with a utf8* prefix instead of the str* prefix:\n\n[API function docs](#api-function-docs)\n\nstring.h | utf8.h | complete | C++14 constexpr\n---------|--------|---------|---------\nstrcat | utf8cat | &#10004; |\nstrchr | utf8chr | &#10004; | &#10004;\nstrcmp | utf8cmp | &#10004; | &#10004;\nstrcoll | utf8coll | |\nstrcpy | utf8cpy | &#10004; |\nstrcspn | utf8cspn | &#10004; | &#10004;\nstrdup | utf8dup | &#10004; |\nstrfry | utf8fry | |\nstrlen | utf8len | &#10004; | &#10004;\nstrnlen | utf8nlen | &#10004; | &#10004;\nstrncat | utf8ncat | &#10004; |\nstrncmp | utf8ncmp | &#10004; | &#10004;\nstrncpy | utf8ncpy | &#10004; |\nstrndup | utf8ndup | &#10004; |\nstrpbrk | utf8pbrk | &#10004; | &#10004;\nstrrchr | utf8rchr | &#10004; | &#10004;\nstrsep | utf8sep | |\nstrspn | utf8spn | &#10004; | &#10004;\nstrstr | utf8str | &#10004; | &#10004;\nstrtok | utf8tok | |\nstrxfrm | utf8xfrm | |\n\nFunctions provided from the C header strings.h but with a utf8* prefix instead of the str* prefix:\n\nstrings.h | utf8.h | complete | C++14 constexpr\n----------|--------|---------|---------\nstrcasecmp | utf8casecmp | ~~&#10004;~~ | &#10004;\nstrncasecmp | utf8ncasecmp | ~~&#10004;~~ | &#10004;\nstrcasestr | utf8casestr | ~~&#10004;~~ | &#10004;\n\nFunctions provided that are unique to utf8.h:\n\nutf8.h | complete | C++14 constexpr\n-------|---------|---------\nutf8codepoint | &#10004; | &#10004;\nutf8rcodepoint | &#10004; | &#10004;\nutf8size | &#10004; | &#10004;\nutf8size\\_lazy | &#10004; | &#10004;\nutf8nsize\\_lazy | &#10004; | &#10004;\nutf8valid | &#10004; | &#10004;\nutf8nvalid | &#10004; | &#10004;\nutf8makevalid | &#10004; |\nutf8codepointsize | &#10004; | &#10004;\nutf8catcodepoint | &#10004; |\nutf8isupper |  ~~&#10004;~~ | &#10004;\nutf8islower | ~~&#10004;~~ | &#10004;\nutf8lwr | ~~&#10004;~~ |\nutf8upr | ~~&#10004;~~ |\nutf8lwrcodepoint | ~~&#10004;~~ | &#10004;\nutf8uprcodepoint | ~~&#10004;~~ | &#10004;\n\n## Usage ##\n\nJust `#include \"utf8.h\"` in your code!\n\nThe current supported platforms are Linux, macOS and Windows.\n\nThe current supported compilers are gcc, clang, MSVC's cl.exe, and clang-cl.exe.\n\n## Design ##\n\nThe utf8.h API matches the string.h API as much as possible by design. There are a few major differences though.\n\nutf8.h uses char8_t* in C++ 20 instead of char*\n\nAnywhere in the string.h or strings.h documentation where it refers to 'bytes' I have changed that to utf8 codepoints. For instance, utf8len will return the number of utf8 codepoints in a utf8 string - which does not necessarily equate to the number of bytes.\n\n## API function docs ##\n\n```c\nint utf8casecmp(const void *src1, const void *src2);\n```\nReturn less than 0, 0, greater than 0 if `src1 < src2`, `src1 == src2`,\n`src1 > src2` respectively, case insensitive.\n\n```c\nvoid *utf8cat(void *dst, const void *src);\n```\nAppend the utf8 string `src` onto the utf8 string `dst`.\n\n```c\nvoid *utf8chr(const void *src, utf8_int32_t chr);\n```\nFind the first match of the utf8 codepoint `chr` in the utf8 string `src`.\n\n```c\nint utf8cmp(const void *src1, const void *src2);\n```\nReturn less than 0, 0, greater than 0 if `src1 < src2`,   \n`src1 == src2`, `src1 > src2` respectively.\n\n```c\nvoid *utf8cpy(void *dst, const void *src);\n```\nCopy the utf8 string `src` onto the memory allocated in `dst`.\n\n```c\nsize_t utf8cspn(const void *src, const void *reject);\n```\nNumber of utf8 codepoints in the utf8 string `src` that consists entirely   \nof utf8 codepoints not from the utf8 string `reject`.\n\n```c\nvoid *utf8dup(const void *src);\n```\nDuplicate the utf8 string `src` by getting its size, `malloc`ing a new buffer   \ncopying over the data, and returning that. Or 0 if `malloc` failed.\n\n```c\nsize_t utf8len(const void *str);\n```\nNumber of utf8 codepoints in the utf8 string `str`,   \n**excluding** the null terminating byte.\n\n```c\nsize_t utf8nlen(const void *str, size_t n);\n```\nSimilar to `utf8len`, except that only at most `n` bytes of `src` are looked.\n\n```c\nint utf8ncasecmp(const void *src1, const void *src2, size_t n);\n```\nReturn less than 0, 0, greater than 0 if `src1 < src2`, `src1 == src2`,   \n`src1 > src2` respectively, case insensitive. Checking at most `n`   \nbytes of each utf8 string.\n\n```c\nvoid *utf8ncat(void *dst, const void *src, size_t n);\n```\nAppend the utf8 string `src` onto the utf8 string `dst`,   \nwriting at most `n+1` bytes. Can produce an invalid utf8   \nstring if `n` falls partway through a utf8 codepoint.\n\n```c\nint utf8ncmp(const void *src1, const void *src2, size_t n);\n```\nReturn less than 0, 0, greater than 0 if `src1 < src2`,   \n`src1 == src2`, `src1 > src2` respectively. Checking at most `n`   \nbytes of each utf8 string.\n\n```c\nvoid *utf8ncpy(void *dst, const void *src, size_t n);\n```\nCopy the utf8 string `src` onto the memory allocated in `dst`.   \nCopies at most `n` bytes. If `n` falls partway through a utf8\ncodepoint, or if `dst` doesn't have enough room for a null\nterminator, the final string will be cut short to preserve\nutf8 validity.\n\n```c\nvoid *utf8pbrk(const void *str, const void *accept);\n```\nLocates the first occurrence in the utf8 string `str` of any byte in the   \nutf8 string `accept`, or 0 if no match was found.\n\n```c\nvoid *utf8rchr(const void *src, utf8_int32_t chr);\n```\nFind the last match of the utf8 codepoint `chr` in the utf8 string `src`.\n\n```c\nsize_t utf8size(const void *str);\n```\nNumber of bytes in the utf8 string `str`,   \nincluding the null terminating byte.\n\n```c\nsize_t utf8size_lazy(const void *str);\n```\nSimilar to `utf8size`, except that the null terminating byte is **excluded**.\n\n```c\nsize_t utf8nsize_lazy(const void *str, size_t n);\n```\nSimilar to `utf8size`, except that only at most `n` bytes of `src` are looked and\nthe null terminating byte is **excluded**.\n\n```c\nsize_t utf8spn(const void *src, const void *accept);\n```\nNumber of utf8 codepoints in the utf8 string `src` that consists entirely   \nof utf8 codepoints from the utf8 string `accept`.\n\n```c\nvoid *utf8str(const void *haystack, const void *needle);\n```\nThe position of the utf8 string `needle` in the utf8 string `haystack`.\n\n```c\nvoid *utf8casestr(const void *haystack, const void *needle);\n```\nThe position of the utf8 string `needle` in the utf8 string `haystack`, \ncase insensitive.\n\n```c\nvoid *utf8valid(const void *str);\n```\nReturn 0 on success, or the position of the invalid utf8 codepoint on failure.\n\n```c\nvoid *utf8nvalid(const void *str, size_t n);\n```\nSimilar to `utf8valid`, except that only at most `n` bytes of `src` are looked.\n\n```c\nint utf8makevalid(void *str, utf8_int32_t replacement);\n```\nReturn 0 on success. Makes the `str` valid by replacing invalid sequences with\nthe 1-byte `replacement` codepoint.\n\n```c\nvoid *utf8codepoint(const void *str, utf8_int32_t *out_codepoint);\n```\nSets out_codepoint to the current utf8 codepoint in `str`, and returns the\naddress of the next utf8 codepoint after the current one in `str`.\n\n```c\nvoid *utf8rcodepoint(const void *str, utf8_int32_t *out_codepoint);\n```\nSets out_codepoint to the current utf8 codepoint in `str`, and returns the\naddress of the previous utf8 codepoint before the current one in `str`.\n\n```c\nsize_t utf8codepointsize(utf8_int32_t chr);\n```\nReturns the size of the given codepoint in bytes.\n\n```c\nvoid *utf8catcodepoint(void *utf8_restrict str, utf8_int32_t chr, size_t n);\n```\nWrite a codepoint to the given string, and return the address to the next\nplace after the written codepoint. Pass how many bytes left in the buffer to\nn. If there is not enough space for the codepoint, this function returns\nnull.\n\n```c\nint utf8islower(utf8_int32_t chr);\n```\nReturns 1 if the given character is lowercase, or 0 if it is not.\n\n```c\nint utf8isupper(utf8_int32_t chr);\n```\nReturns 1 if the given character is uppercase, or 0 if it is not.\n\n```c\nvoid utf8lwr(void *utf8_restrict str);\n```\nTransform the given string into all lowercase codepoints.\n\n```c\nvoid utf8upr(void *utf8_restrict str);\n```\nTransform the given string into all uppercase codepoints.\n\n```c\nutf8_int32_t utf8lwrcodepoint(utf8_int32_t cp);\n```\nMake a codepoint lower case if possible.\n\n```c\nutf8_int32_t utf8uprcodepoint(utf8_int32_t cp);\n```\nMake a codepoint upper case if possible.\n\n## Codepoint Case\n\nVarious functions provided will do case insensitive compares, or transform utf8\nstrings from one case to another. Given the vastness of unicode, and the authors\nlack of understanding beyond latin codepoints on whether case means anything,\nthe following categories are the only ones that will be checked in case\ninsensitive code:\n\n* [ASCII](https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block))\n* [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block))\n* [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n* [Latin Extended-B](https://en.wikipedia.org/wiki/Latin_Extended-B)\n* [Greek and Coptic](https://en.wikipedia.org/wiki/Greek_and_Coptic)\n* [Cyrillic](https://en.wikipedia.org/wiki/Cyrillic_(Unicode_block))\n\n## Todo ##\n\n- Implement utf8coll (akin to strcoll).\n- Implement utf8fry (akin to strfry).\n- Investigate adding dst buffer sizes for utf8cpy and utf8cat to catch overwrites (as suggested by [@FlohOfWoe](https://twitter.com/FlohOfWoe) in https://twitter.com/FlohOfWoe/status/618669237771608064)\n\n## License ##\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 1.4140625,
          "content": "version: '{build}'\n\nskip_tags: true\nskip_branch_with_pr: true\n\ninstall: []\n\nenvironment:\n  matrix:\n    - VSVERSION: Visual Studio 9 2008\n    - VSVERSION: Visual Studio 10 2010\n    - VSVERSION: Visual Studio 11 2012\n    - VSVERSION: Visual Studio 12 2013\n    - VSVERSION: Visual Studio 14 2015\n    - VSVERSION: Visual Studio 15 2017\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n    - VSVERSION: Visual Studio 16 2019\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n\nplatform:\n  - Win32\n  - x64\n\nmatrix:\n  exclude:\n    - platform: x64\n      VSVERSION: Visual Studio 9 2008\n    # VS 2019 / 64-bit is tested in GitHub Actions instead.\n    - platform: x64\n      VSVERSION: Visual Studio 16 2019\n\nconfiguration:\n  - Debug\n  # Removed to reduce configuration explosion.\n  # - RelWithDebInfo\n  # - MinSizeRel\n  - Release\n\nbuild_script:\n  - md build\n  - cd build\n  - if NOT \"%VSVERSION%\"==\"Visual Studio 16 2019\" if \"%PLATFORM%\"==\"x64\" cmake -G \"%VSVERSION% Win64\" ../test\n  - if NOT \"%VSVERSION%\"==\"Visual Studio 16 2019\" if \"%PLATFORM%\"==\"Win32\" cmake -G \"%VSVERSION%\" ../test\n  - if \"%VSVERSION%\"==\"Visual Studio 16 2019\" cmake -G \"%VSVERSION%\" -A \"%PLATFORM%\" ../test\n  - msbuild /m /p:Configuration=\"%CONFIGURATION%\" /p:Platform=\"%PLATFORM%\" utf8.sln\n  - copy %CONFIGURATION%\\utf8_test.exe utf8_test.exe\n  - copy %CONFIGURATION%\\utf8_no_malloc_test.exe utf8_no_malloc_test.exe\n\ntest_script:\n  - utf8_test.exe\n  - utf8_no_malloc_test.exe\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "utf8.h",
          "type": "blob",
          "size": 48.7998046875,
          "content": "/* The latest version of this library is available on GitHub;\n * https://github.com/sheredom/utf8.h */\n\n/* This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/> */\n\n#ifndef SHEREDOM_UTF8_H_INCLUDED\n#define SHEREDOM_UTF8_H_INCLUDED\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n\n/* disable warning: no function prototype given: converting '()' to '(void)' */\n#pragma warning(disable : 4255)\n\n/* disable warning: '__cplusplus' is not defined as a preprocessor macro,\n * replacing with '0' for '#if/#elif' */\n#pragma warning(disable : 4668)\n\n/* disable warning: bytes padding added after construct */\n#pragma warning(disable : 4820)\n#endif\n\n#if defined(__cplusplus)\n#if defined(_MSC_VER)\n#define utf8_cplusplus _MSVC_LANG\n#else\n#define utf8_cplusplus __cplusplus\n#endif\n#endif\n\n#include <stddef.h>\n#include <stdlib.h>\n\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n#if defined(_MSC_VER) && (_MSC_VER < 1920)\ntypedef __int32 utf8_int32_t;\n#else\n#include <stdint.h>\ntypedef int32_t utf8_int32_t;\n#endif\n\n#if defined(__clang__)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n\n#if __has_warning(\"-Wunsafe-buffer-usage\")\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"\n#endif\n#endif\n\n#ifdef utf8_cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__TINYC__)\n#define UTF8_ATTRIBUTE(a) __attribute((a))\n#else\n#define UTF8_ATTRIBUTE(a) __attribute__((a))\n#endif\n\n#if defined(_MSC_VER)\n#define utf8_nonnull\n#define utf8_pure\n#define utf8_restrict __restrict\n#define utf8_weak __inline\n#elif defined(__clang__) || defined(__GNUC__)\n#define utf8_nonnull UTF8_ATTRIBUTE(nonnull)\n#define utf8_pure UTF8_ATTRIBUTE(pure)\n#define utf8_restrict __restrict__\n#define utf8_weak UTF8_ATTRIBUTE(weak)\n#elif defined(__TINYC__)\n#define utf8_nonnull UTF8_ATTRIBUTE(nonnull)\n#define utf8_pure UTF8_ATTRIBUTE(pure)\n#define utf8_restrict\n#define utf8_weak UTF8_ATTRIBUTE(weak)\n#elif defined(__IAR_SYSTEMS_ICC__)\n#define utf8_nonnull\n#define utf8_pure UTF8_ATTRIBUTE(pure)\n#define utf8_restrict __restrict\n#define utf8_weak UTF8_ATTRIBUTE(weak)\n#else\n#error Non clang, non gcc, non MSVC, non tcc, non iar compiler found!\n#endif\n\n#ifdef utf8_cplusplus\n#define utf8_null NULL\n#else\n#define utf8_null 0\n#endif\n\n#if defined(utf8_cplusplus) && utf8_cplusplus >= 201402L && (!defined(_MSC_VER) || (defined(_MSC_VER) && _MSC_VER >= 1910))\n#define utf8_constexpr14 constexpr\n#define utf8_constexpr14_impl constexpr\n#else\n/* constexpr and weak are incompatible. so only enable one of them */\n#define utf8_constexpr14 utf8_weak\n#define utf8_constexpr14_impl\n#endif\n\n#if defined(utf8_cplusplus) && utf8_cplusplus >= 202002L && defined(__cpp_char8_t)\nusing utf8_int8_t = char8_t; /* Introduced in C++20 */\n#else\ntypedef char utf8_int8_t;\n#endif\n\n/* Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >\n * src2 respectively, case insensitive. */\nutf8_constexpr14 utf8_nonnull utf8_pure int\nutf8casecmp(const utf8_int8_t *src1, const utf8_int8_t *src2);\n\n/* Append the utf8 string src onto the utf8 string dst. */\nutf8_nonnull utf8_weak utf8_int8_t *\nutf8cat(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src);\n\n/* Find the first match of the utf8 codepoint chr in the utf8 string src. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8chr(const utf8_int8_t *src, utf8_int32_t chr);\n\n/* Return less than 0, 0, greater than 0 if src1 < src2,\n * src1 == src2, src1 > src2 respectively. */\nutf8_constexpr14 utf8_nonnull utf8_pure int utf8cmp(const utf8_int8_t *src1,\n                                                    const utf8_int8_t *src2);\n\n/* Copy the utf8 string src onto the memory allocated in dst. */\nutf8_nonnull utf8_weak utf8_int8_t *\nutf8cpy(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src);\n\n/* Number of utf8 codepoints in the utf8 string src that consists entirely\n * of utf8 codepoints not from the utf8 string reject. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t\nutf8cspn(const utf8_int8_t *src, const utf8_int8_t *reject);\n\n/* Duplicate the utf8 string src by getting its size, malloc'ing a new buffer\n * copying over the data, and returning that. Or 0 if malloc failed. */\nutf8_weak utf8_int8_t *utf8dup(const utf8_int8_t *src);\n\n/* Number of utf8 codepoints in the utf8 string str,\n * excluding the null terminating byte. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t utf8len(const utf8_int8_t *str);\n\n/* Similar to utf8len, except that only at most n bytes of src are looked. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t utf8nlen(const utf8_int8_t *str,\n                                                        size_t n);\n\n/* Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >\n * src2 respectively, case insensitive. Checking at most n bytes of each utf8\n * string. */\nutf8_constexpr14 utf8_nonnull utf8_pure int\nutf8ncasecmp(const utf8_int8_t *src1, const utf8_int8_t *src2, size_t n);\n\n/* Append the utf8 string src onto the utf8 string dst,\n * writing at most n+1 bytes. Can produce an invalid utf8\n * string if n falls partway through a utf8 codepoint. */\nutf8_nonnull utf8_weak utf8_int8_t *\nutf8ncat(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src,\n         size_t n);\n\n/* Return less than 0, 0, greater than 0 if src1 < src2,\n * src1 == src2, src1 > src2 respectively. Checking at most n\n * bytes of each utf8 string. */\nutf8_constexpr14 utf8_nonnull utf8_pure int\nutf8ncmp(const utf8_int8_t *src1, const utf8_int8_t *src2, size_t n);\n\n/* Copy the utf8 string src onto the memory allocated in dst.\n * Copies at most n bytes. If n falls partway through a utf8\n * codepoint, or if dst doesn't have enough room for a null\n * terminator, the final string will be cut short to preserve\n * utf8 validity. */\n\nutf8_nonnull utf8_weak utf8_int8_t *\nutf8ncpy(utf8_int8_t *utf8_restrict dst, const utf8_int8_t *utf8_restrict src,\n         size_t n);\n\n/* Similar to utf8dup, except that at most n bytes of src are copied. If src is\n * longer than n, only n bytes are copied and a null byte is added.\n *\n * Returns a new string if successful, 0 otherwise */\nutf8_weak utf8_int8_t *utf8ndup(const utf8_int8_t *src, size_t n);\n\n/* Locates the first occurrence in the utf8 string str of any byte in the\n * utf8 string accept, or 0 if no match was found. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8pbrk(const utf8_int8_t *str, const utf8_int8_t *accept);\n\n/* Find the last match of the utf8 codepoint chr in the utf8 string src. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8rchr(const utf8_int8_t *src, int chr);\n\n/* Number of bytes in the utf8 string str,\n * including the null terminating byte. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t utf8size(const utf8_int8_t *str);\n\n/* Similar to utf8size, except that the null terminating byte is excluded. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t\nutf8size_lazy(const utf8_int8_t *str);\n\n/* Similar to utf8size, except that only at most n bytes of src are looked and\n * the null terminating byte is excluded. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t\nutf8nsize_lazy(const utf8_int8_t *str, size_t n);\n\n/* Number of utf8 codepoints in the utf8 string src that consists entirely\n * of utf8 codepoints from the utf8 string accept. */\nutf8_constexpr14 utf8_nonnull utf8_pure size_t\nutf8spn(const utf8_int8_t *src, const utf8_int8_t *accept);\n\n/* The position of the utf8 string needle in the utf8 string haystack. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8str(const utf8_int8_t *haystack, const utf8_int8_t *needle);\n\n/* The position of the utf8 string needle in the utf8 string haystack, case\n * insensitive. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8casestr(const utf8_int8_t *haystack, const utf8_int8_t *needle);\n\n/* Return 0 on success, or the position of the invalid\n * utf8 codepoint on failure. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8valid(const utf8_int8_t *str);\n\n/* Similar to utf8valid, except that only at most n bytes of src are looked. */\nutf8_constexpr14 utf8_nonnull utf8_pure utf8_int8_t *\nutf8nvalid(const utf8_int8_t *str, size_t n);\n\n/* Given a null-terminated string, makes the string valid by replacing invalid\n * codepoints with a 1-byte replacement. Returns 0 on success. */\nutf8_nonnull utf8_weak int utf8makevalid(utf8_int8_t *str,\n                                         const utf8_int32_t replacement);\n\n/* Sets out_codepoint to the current utf8 codepoint in str, and returns the\n * address of the next utf8 codepoint after the current one in str. */\nutf8_constexpr14 utf8_nonnull utf8_int8_t *\nutf8codepoint(const utf8_int8_t *utf8_restrict str,\n              utf8_int32_t *utf8_restrict out_codepoint);\n\n/* Calculates the size of the next utf8 codepoint in str. */\nutf8_constexpr14 utf8_nonnull size_t\nutf8codepointcalcsize(const utf8_int8_t *str);\n\n/* Returns the size of the given codepoint in bytes. */\nutf8_constexpr14 size_t utf8codepointsize(utf8_int32_t chr);\n\n/* Write a codepoint to the given string, and return the address to the next\n * place after the written codepoint. Pass how many bytes left in the buffer to\n * n. If there is not enough space for the codepoint, this function returns\n * null. */\nutf8_nonnull utf8_weak utf8_int8_t *\nutf8catcodepoint(utf8_int8_t *str, utf8_int32_t chr, size_t n);\n\n/* Returns 1 if the given character is lowercase, or 0 if it is not. */\nutf8_constexpr14 int utf8islower(utf8_int32_t chr);\n\n/* Returns 1 if the given character is uppercase, or 0 if it is not. */\nutf8_constexpr14 int utf8isupper(utf8_int32_t chr);\n\n/* Transform the given string into all lowercase codepoints. */\nutf8_nonnull utf8_weak void utf8lwr(utf8_int8_t *utf8_restrict str);\n\n/* Transform the given string into all uppercase codepoints. */\nutf8_nonnull utf8_weak void utf8upr(utf8_int8_t *utf8_restrict str);\n\n/* Make a codepoint lower case if possible. */\nutf8_constexpr14 utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp);\n\n/* Make a codepoint upper case if possible. */\nutf8_constexpr14 utf8_int32_t utf8uprcodepoint(utf8_int32_t cp);\n\n/* Sets out_codepoint to the current utf8 codepoint in str, and returns the\n * address of the previous utf8 codepoint before the current one in str. */\nutf8_constexpr14 utf8_nonnull utf8_int8_t *\nutf8rcodepoint(const utf8_int8_t *utf8_restrict str,\n               utf8_int32_t *utf8_restrict out_codepoint);\n\n/* Duplicate the utf8 string src by getting its size, calling alloc_func_ptr to\n * copy over data to a new buffer, and returning that. Or 0 if alloc_func_ptr\n * returned null. */\nutf8_weak utf8_int8_t *utf8dup_ex(const utf8_int8_t *src,\n                                  utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *,\n                                                                 size_t),\n                                  utf8_int8_t *user_data);\n\n/* Similar to utf8dup, except that at most n bytes of src are copied. If src is\n * longer than n, only n bytes are copied and a null byte is added.\n *\n * Returns a new string if successful, 0 otherwise. */\nutf8_weak utf8_int8_t *utf8ndup_ex(const utf8_int8_t *src, size_t n,\n                                   utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *,\n                                                                  size_t),\n                                   utf8_int8_t *user_data);\n\n#undef utf8_weak\n#undef utf8_pure\n#undef utf8_nonnull\n\nutf8_constexpr14_impl int utf8casecmp(const utf8_int8_t *src1,\n                                      const utf8_int8_t *src2) {\n  utf8_int32_t src1_lwr_cp = 0, src2_lwr_cp = 0, src1_upr_cp = 0,\n               src2_upr_cp = 0, src1_orig_cp = 0, src2_orig_cp = 0;\n\n  for (;;) {\n    src1 = utf8codepoint(src1, &src1_orig_cp);\n    src2 = utf8codepoint(src2, &src2_orig_cp);\n\n    /* lower the srcs if required */\n    src1_lwr_cp = utf8lwrcodepoint(src1_orig_cp);\n    src2_lwr_cp = utf8lwrcodepoint(src2_orig_cp);\n\n    /* lower the srcs if required */\n    src1_upr_cp = utf8uprcodepoint(src1_orig_cp);\n    src2_upr_cp = utf8uprcodepoint(src2_orig_cp);\n\n    /* check if the lowered codepoints match */\n    if ((0 == src1_orig_cp) && (0 == src2_orig_cp)) {\n      return 0;\n    } else if ((src1_lwr_cp == src2_lwr_cp) || (src1_upr_cp == src2_upr_cp)) {\n      continue;\n    }\n\n    /* if they don't match, then we return the difference between the characters\n     */\n    return src1_lwr_cp - src2_lwr_cp;\n  }\n}\n\nutf8_int8_t *utf8cat(utf8_int8_t *utf8_restrict dst,\n                     const utf8_int8_t *utf8_restrict src) {\n  utf8_int8_t *d = dst;\n  /* find the null terminating byte in dst */\n  while ('\\0' != *d) {\n    d++;\n  }\n\n  /* overwriting the null terminating byte in dst, append src byte-by-byte */\n  while ('\\0' != *src) {\n    *d++ = *src++;\n  }\n\n  /* write out a new null terminating byte into dst */\n  *d = '\\0';\n\n  return dst;\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8chr(const utf8_int8_t *src,\n                                           utf8_int32_t chr) {\n  utf8_int8_t c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};\n\n  if (0 == chr) {\n    /* being asked to return position of null terminating byte, so\n     * just run s to the end, and return! */\n    while ('\\0' != *src) {\n      src++;\n    }\n    return (utf8_int8_t *)src;\n  } else if (0 == ((utf8_int32_t)0xffffff80 & chr)) {\n    /* 1-byte/7-bit ascii\n     * (0b0xxxxxxx) */\n    c[0] = (utf8_int8_t)chr;\n  } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {\n    /* 2-byte/11-bit utf8 code point\n     * (0b110xxxxx 0b10xxxxxx) */\n    c[0] = (utf8_int8_t)(0xc0 | (utf8_int8_t)(chr >> 6));\n    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n  } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {\n    /* 3-byte/16-bit utf8 code point\n     * (0b1110xxxx 0b10xxxxxx 0b10xxxxxx) */\n    c[0] = (utf8_int8_t)(0xe0 | (utf8_int8_t)(chr >> 12));\n    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));\n    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n  } else { /* if (0 == ((int)0xffe00000 & chr)) { */\n    /* 4-byte/21-bit utf8 code point\n     * (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx) */\n    c[0] = (utf8_int8_t)(0xf0 | (utf8_int8_t)(chr >> 18));\n    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 12) & 0x3f));\n    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));\n    c[3] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n  }\n\n  /* we've made c into a 2 utf8 codepoint string, one for the chr we are\n   * seeking, another for the null terminating byte. Now use utf8str to\n   * search */\n  return utf8str(src, c);\n}\n\nutf8_constexpr14_impl int utf8cmp(const utf8_int8_t *src1,\n                                  const utf8_int8_t *src2) {\n  while (('\\0' != *src1) || ('\\0' != *src2)) {\n    if (*src1 < *src2) {\n      return -1;\n    } else if (*src1 > *src2) {\n      return 1;\n    }\n\n    src1++;\n    src2++;\n  }\n\n  /* both utf8 strings matched */\n  return 0;\n}\n\nutf8_constexpr14_impl int utf8coll(const utf8_int8_t *src1,\n                                   const utf8_int8_t *src2);\n\nutf8_int8_t *utf8cpy(utf8_int8_t *utf8_restrict dst,\n                     const utf8_int8_t *utf8_restrict src) {\n  utf8_int8_t *d = dst;\n\n  /* overwriting anything previously in dst, write byte-by-byte\n   * from src */\n  while ('\\0' != *src) {\n    *d++ = *src++;\n  }\n\n  /* append null terminating byte */\n  *d = '\\0';\n\n  return dst;\n}\n\nutf8_constexpr14_impl size_t utf8cspn(const utf8_int8_t *src,\n                                      const utf8_int8_t *reject) {\n  size_t chars = 0;\n\n  while ('\\0' != *src) {\n    const utf8_int8_t *r = reject;\n    size_t offset = 0;\n\n    while ('\\0' != *r) {\n      /* checking that if *r is the start of a utf8 codepoint\n       * (it is not 0b10xxxxxx) and we have successfully matched\n       * a previous character (0 < offset) - we found a match */\n      if ((0x80 != (0xc0 & *r)) && (0 < offset)) {\n        return chars;\n      } else {\n        if (*r == src[offset]) {\n          /* part of a utf8 codepoint matched, so move our checking\n           * onwards to the next byte */\n          offset++;\n          r++;\n        } else {\n          /* r could be in the middle of an unmatching utf8 code point,\n           * so we need to march it on to the next character beginning, */\n\n          do {\n            r++;\n          } while (0x80 == (0xc0 & *r));\n\n          /* reset offset too as we found a mismatch */\n          offset = 0;\n        }\n      }\n    }\n\n    /* found a match at the end of *r, so didn't get a chance to test it */\n    if (0 < offset) {\n      return chars;\n    }\n\n    /* the current utf8 codepoint in src did not match reject, but src\n     * could have been partway through a utf8 codepoint, so we need to\n     * march it onto the next utf8 codepoint starting byte */\n    do {\n      src++;\n    } while ((0x80 == (0xc0 & *src)));\n    chars++;\n  }\n\n  return chars;\n}\n\nutf8_int8_t *utf8dup(const utf8_int8_t *src) {\n  return utf8dup_ex(src, utf8_null, utf8_null);\n}\n\nutf8_int8_t *utf8dup_ex(const utf8_int8_t *src,\n                        utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *, size_t),\n                        utf8_int8_t *user_data) {\n  utf8_int8_t *n = utf8_null;\n\n  /* figure out how many bytes (including the terminator) we need to copy first\n   */\n  size_t bytes = utf8size(src);\n\n  if (alloc_func_ptr) {\n    n = alloc_func_ptr(user_data, bytes);\n  } else {\n#if !defined(UTF8_NO_STD_MALLOC)\n    n = (utf8_int8_t *)malloc(bytes);\n#else\n    return utf8_null;\n#endif\n  }\n\n  if (utf8_null == n) {\n    /* out of memory so we bail */\n    return utf8_null;\n  } else {\n    bytes = 0;\n\n    /* copy src byte-by-byte into our new utf8 string */\n    while ('\\0' != src[bytes]) {\n      n[bytes] = src[bytes];\n      bytes++;\n    }\n\n    /* append null terminating byte */\n    n[bytes] = '\\0';\n    return n;\n  }\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8fry(const utf8_int8_t *str);\n\nutf8_constexpr14_impl size_t utf8len(const utf8_int8_t *str) {\n  return utf8nlen(str, SIZE_MAX);\n}\n\nutf8_constexpr14_impl size_t utf8nlen(const utf8_int8_t *str, size_t n) {\n  const utf8_int8_t *t = str;\n  size_t length = 0;\n\n  while ((size_t)(str - t) < n && '\\0' != *str) {\n    if (0xf0 == (0xf8 & *str)) {\n      /* 4-byte utf8 code point (began with 0b11110xxx) */\n      str += 4;\n    } else if (0xe0 == (0xf0 & *str)) {\n      /* 3-byte utf8 code point (began with 0b1110xxxx) */\n      str += 3;\n    } else if (0xc0 == (0xe0 & *str)) {\n      /* 2-byte utf8 code point (began with 0b110xxxxx) */\n      str += 2;\n    } else { /* if (0x00 == (0x80 & *s)) { */\n      /* 1-byte ascii (began with 0b0xxxxxxx) */\n      str += 1;\n    }\n\n    /* no matter the bytes we marched s forward by, it was\n     * only 1 utf8 codepoint */\n    length++;\n  }\n\n  if ((size_t)(str - t) > n) {\n    length--;\n  }\n  return length;\n}\n\nutf8_constexpr14_impl int utf8ncasecmp(const utf8_int8_t *src1,\n                                       const utf8_int8_t *src2, size_t n) {\n  utf8_int32_t src1_lwr_cp = 0, src2_lwr_cp = 0, src1_upr_cp = 0,\n               src2_upr_cp = 0, src1_orig_cp = 0, src2_orig_cp = 0;\n\n  do {\n    const utf8_int8_t *const s1 = src1;\n    const utf8_int8_t *const s2 = src2;\n\n    /* first check that we have enough bytes left in n to contain an entire\n     * codepoint */\n    if (0 == n) {\n      return 0;\n    }\n\n    if ((1 == n) && ((0xc0 == (0xe0 & *s1)) || (0xc0 == (0xe0 & *s2)))) {\n      const utf8_int32_t c1 = (0xe0 & *s1);\n      const utf8_int32_t c2 = (0xe0 & *s2);\n\n      if (c1 != c2) {\n        return c1 - c2;\n      } else {\n        return 0;\n      }\n    }\n\n    if ((2 >= n) && ((0xe0 == (0xf0 & *s1)) || (0xe0 == (0xf0 & *s2)))) {\n      const utf8_int32_t c1 = (0xf0 & *s1);\n      const utf8_int32_t c2 = (0xf0 & *s2);\n\n      if (c1 != c2) {\n        return c1 - c2;\n      } else {\n        return 0;\n      }\n    }\n\n    if ((3 >= n) && ((0xf0 == (0xf8 & *s1)) || (0xf0 == (0xf8 & *s2)))) {\n      const utf8_int32_t c1 = (0xf8 & *s1);\n      const utf8_int32_t c2 = (0xf8 & *s2);\n\n      if (c1 != c2) {\n        return c1 - c2;\n      } else {\n        return 0;\n      }\n    }\n\n    src1 = utf8codepoint(src1, &src1_orig_cp);\n    src2 = utf8codepoint(src2, &src2_orig_cp);\n    n -= utf8codepointsize(src1_orig_cp);\n\n    src1_lwr_cp = utf8lwrcodepoint(src1_orig_cp);\n    src2_lwr_cp = utf8lwrcodepoint(src2_orig_cp);\n\n    src1_upr_cp = utf8uprcodepoint(src1_orig_cp);\n    src2_upr_cp = utf8uprcodepoint(src2_orig_cp);\n\n    /* check if the lowered codepoints match */\n    if ((0 == src1_orig_cp) && (0 == src2_orig_cp)) {\n      return 0;\n    } else if ((src1_lwr_cp == src2_lwr_cp) || (src1_upr_cp == src2_upr_cp)) {\n      continue;\n    }\n\n    /* if they don't match, then we return the difference between the characters\n     */\n    return src1_lwr_cp - src2_lwr_cp;\n  } while (0 < n);\n\n  /* both utf8 strings matched */\n  return 0;\n}\n\nutf8_int8_t *utf8ncat(utf8_int8_t *utf8_restrict dst,\n                      const utf8_int8_t *utf8_restrict src, size_t n) {\n  utf8_int8_t *d = dst;\n\n  /* find the null terminating byte in dst */\n  while ('\\0' != *d) {\n    d++;\n  }\n\n  /* overwriting the null terminating byte in dst, append src byte-by-byte\n   * stopping if we run out of space */\n  while (('\\0' != *src) && (0 != n--)) {\n    *d++ = *src++;\n  }\n\n  /* write out a new null terminating byte into dst */\n  *d = '\\0';\n\n  return dst;\n}\n\nutf8_constexpr14_impl int utf8ncmp(const utf8_int8_t *src1,\n                                   const utf8_int8_t *src2, size_t n) {\n  while ((0 != n--) && (('\\0' != *src1) || ('\\0' != *src2))) {\n    if (*src1 < *src2) {\n      return -1;\n    } else if (*src1 > *src2) {\n      return 1;\n    }\n\n    src1++;\n    src2++;\n  }\n\n  /* both utf8 strings matched */\n  return 0;\n}\n\nutf8_int8_t *utf8ncpy(utf8_int8_t *utf8_restrict dst,\n                      const utf8_int8_t *utf8_restrict src, size_t n) {\n  utf8_int8_t *d = dst;\n  size_t index = 0, check_index = 0;\n\n  if (n == 0) {\n    return dst;\n  }\n\n  /* overwriting anything previously in dst, write byte-by-byte\n   * from src */\n  for (index = 0; index < n; index++) {\n    d[index] = src[index];\n    if ('\\0' == src[index]) {\n      break;\n    }\n  }\n\n  for (check_index = index - 1;\n       check_index > 0 && 0x80 == (0xc0 & d[check_index]); check_index--) {\n    /* just moving the index */\n  }\n\n  if (check_index < index &&\n      ((index - check_index) < utf8codepointcalcsize(&d[check_index]) ||\n       (index - check_index) == n)) {\n    index = check_index;\n  }\n\n  /* append null terminating byte */\n  for (; index < n; index++) {\n    d[index] = 0;\n  }\n\n  return dst;\n}\n\nutf8_int8_t *utf8ndup(const utf8_int8_t *src, size_t n) {\n  return utf8ndup_ex(src, n, utf8_null, utf8_null);\n}\n\nutf8_int8_t *utf8ndup_ex(const utf8_int8_t *src, size_t n,\n                         utf8_int8_t *(*alloc_func_ptr)(utf8_int8_t *, size_t),\n                         utf8_int8_t *user_data) {\n  utf8_int8_t *c = utf8_null;\n  size_t bytes = 0;\n\n  /* Find the end of the string or stop when n is reached */\n  while ('\\0' != src[bytes] && bytes < n) {\n    bytes++;\n  }\n\n  /* In case bytes is actually less than n, we need to set it\n   * to be used later in the copy byte by byte. */\n  n = bytes;\n\n  if (alloc_func_ptr) {\n    c = alloc_func_ptr(user_data, bytes + 1);\n  } else {\n#if !defined(UTF8_NO_STD_MALLOC)\n    c = (utf8_int8_t *)malloc(bytes + 1);\n#else\n    c = utf8_null;\n#endif\n  }\n\n  if (utf8_null == c) {\n    /* out of memory so we bail */\n    return utf8_null;\n  }\n\n  bytes = 0;\n\n  /* copy src byte-by-byte into our new utf8 string */\n  while ('\\0' != src[bytes] && bytes < n) {\n    c[bytes] = src[bytes];\n    bytes++;\n  }\n\n  /* append null terminating byte */\n  c[bytes] = '\\0';\n  return c;\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8rchr(const utf8_int8_t *src, int chr) {\n\n  utf8_int8_t *match = utf8_null;\n  utf8_int8_t c[5] = {'\\0', '\\0', '\\0', '\\0', '\\0'};\n\n  if (0 == chr) {\n    /* being asked to return position of null terminating byte, so\n     * just run s to the end, and return! */\n    while ('\\0' != *src) {\n      src++;\n    }\n    return (utf8_int8_t *)src;\n  } else if (0 == ((int)0xffffff80 & chr)) {\n    /* 1-byte/7-bit ascii\n     * (0b0xxxxxxx) */\n    c[0] = (utf8_int8_t)chr;\n  } else if (0 == ((int)0xfffff800 & chr)) {\n    /* 2-byte/11-bit utf8 code point\n     * (0b110xxxxx 0b10xxxxxx) */\n    c[0] = (utf8_int8_t)(0xc0 | (utf8_int8_t)(chr >> 6));\n    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n  } else if (0 == ((int)0xffff0000 & chr)) {\n    /* 3-byte/16-bit utf8 code point\n     * (0b1110xxxx 0b10xxxxxx 0b10xxxxxx) */\n    c[0] = (utf8_int8_t)(0xe0 | (utf8_int8_t)(chr >> 12));\n    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));\n    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n  } else { /* if (0 == ((int)0xffe00000 & chr)) { */\n    /* 4-byte/21-bit utf8 code point\n     * (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx) */\n    c[0] = (utf8_int8_t)(0xf0 | (utf8_int8_t)(chr >> 18));\n    c[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 12) & 0x3f));\n    c[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));\n    c[3] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n  }\n\n  /* we've created a 2 utf8 codepoint string in c that is\n   * the utf8 character asked for by chr, and a null\n   * terminating byte */\n\n  while ('\\0' != *src) {\n    size_t offset = 0;\n\n    while ((src[offset] == c[offset]) && ('\\0' != src[offset])) {\n      offset++;\n    }\n\n    if ('\\0' == c[offset]) {\n      /* we found a matching utf8 code point */\n      match = (utf8_int8_t *)src;\n      src += offset;\n\n      if ('\\0' == *src) {\n        break;\n      }\n    } else {\n      src += offset;\n\n      /* need to march s along to next utf8 codepoint start\n       * (the next byte that doesn't match 0b10xxxxxx) */\n      if ('\\0' != *src) {\n        do {\n          src++;\n        } while (0x80 == (0xc0 & *src));\n      }\n    }\n  }\n\n  /* return the last match we found (or 0 if no match was found) */\n  return match;\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8pbrk(const utf8_int8_t *str,\n                                            const utf8_int8_t *accept) {\n  while ('\\0' != *str) {\n    const utf8_int8_t *a = accept;\n    size_t offset = 0;\n\n    while ('\\0' != *a) {\n      /* checking that if *a is the start of a utf8 codepoint\n       * (it is not 0b10xxxxxx) and we have successfully matched\n       * a previous character (0 < offset) - we found a match */\n      if ((0x80 != (0xc0 & *a)) && (0 < offset)) {\n        return (utf8_int8_t *)str;\n      } else {\n        if (*a == str[offset]) {\n          /* part of a utf8 codepoint matched, so move our checking\n           * onwards to the next byte */\n          offset++;\n          a++;\n        } else {\n          /* r could be in the middle of an unmatching utf8 code point,\n           * so we need to march it on to the next character beginning, */\n\n          do {\n            a++;\n          } while (0x80 == (0xc0 & *a));\n\n          /* reset offset too as we found a mismatch */\n          offset = 0;\n        }\n      }\n    }\n\n    /* we found a match on the last utf8 codepoint */\n    if (0 < offset) {\n      return (utf8_int8_t *)str;\n    }\n\n    /* the current utf8 codepoint in src did not match accept, but src\n     * could have been partway through a utf8 codepoint, so we need to\n     * march it onto the next utf8 codepoint starting byte */\n    do {\n      str++;\n    } while ((0x80 == (0xc0 & *str)));\n  }\n\n  return utf8_null;\n}\n\nutf8_constexpr14_impl size_t utf8size(const utf8_int8_t *str) {\n  return utf8size_lazy(str) + 1;\n}\n\nutf8_constexpr14_impl size_t utf8size_lazy(const utf8_int8_t *str) {\n  return utf8nsize_lazy(str, SIZE_MAX);\n}\n\nutf8_constexpr14_impl size_t utf8nsize_lazy(const utf8_int8_t *str, size_t n) {\n  size_t size = 0;\n  while (size < n && '\\0' != str[size]) {\n    size++;\n  }\n  return size;\n}\n\nutf8_constexpr14_impl size_t utf8spn(const utf8_int8_t *src,\n                                     const utf8_int8_t *accept) {\n  size_t chars = 0;\n\n  while ('\\0' != *src) {\n    const utf8_int8_t *a = accept;\n    size_t offset = 0;\n\n    while ('\\0' != *a) {\n      /* checking that if *r is the start of a utf8 codepoint\n       * (it is not 0b10xxxxxx) and we have successfully matched\n       * a previous character (0 < offset) - we found a match */\n      if ((0x80 != (0xc0 & *a)) && (0 < offset)) {\n        /* found a match, so increment the number of utf8 codepoints\n         * that have matched and stop checking whether any other utf8\n         * codepoints in a match */\n        chars++;\n        src += offset;\n        offset = 0;\n        break;\n      } else {\n        if (*a == src[offset]) {\n          offset++;\n          a++;\n        } else {\n          /* a could be in the middle of an unmatching utf8 codepoint,\n           * so we need to march it on to the next character beginning, */\n          do {\n            a++;\n          } while (0x80 == (0xc0 & *a));\n\n          /* reset offset too as we found a mismatch */\n          offset = 0;\n        }\n      }\n    }\n\n    /* found a match at the end of *a, so didn't get a chance to test it */\n    if (0 < offset) {\n      chars++;\n      src += offset;\n      continue;\n    }\n\n    /* if a got to its terminating null byte, then we didn't find a match.\n     * Return the current number of matched utf8 codepoints */\n    if ('\\0' == *a) {\n      return chars;\n    }\n  }\n\n  return chars;\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8str(const utf8_int8_t *haystack,\n                                           const utf8_int8_t *needle) {\n  utf8_int32_t throwaway_codepoint = 0;\n\n  /* if needle has no utf8 codepoints before the null terminating\n   * byte then return haystack */\n  if ('\\0' == *needle) {\n    return (utf8_int8_t *)haystack;\n  }\n\n  while ('\\0' != *haystack) {\n    const utf8_int8_t *maybeMatch = haystack;\n    const utf8_int8_t *n = needle;\n\n    while (*haystack == *n && (*haystack != '\\0' && *n != '\\0')) {\n      n++;\n      haystack++;\n    }\n\n    if ('\\0' == *n) {\n      /* we found the whole utf8 string for needle in haystack at\n       * maybeMatch, so return it */\n      return (utf8_int8_t *)maybeMatch;\n    } else {\n      /* h could be in the middle of an unmatching utf8 codepoint,\n       * so we need to march it on to the next character beginning\n       * starting from the current character */\n      haystack = utf8codepoint(maybeMatch, &throwaway_codepoint);\n    }\n  }\n\n  /* no match */\n  return utf8_null;\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8casestr(const utf8_int8_t *haystack,\n                                               const utf8_int8_t *needle) {\n  /* if needle has no utf8 codepoints before the null terminating\n   * byte then return haystack */\n  if ('\\0' == *needle) {\n    return (utf8_int8_t *)haystack;\n  }\n\n  for (;;) {\n    const utf8_int8_t *maybeMatch = haystack;\n    const utf8_int8_t *n = needle;\n    utf8_int32_t h_cp = 0, n_cp = 0;\n\n    /* Get the next code point and track it */\n    const utf8_int8_t *nextH = haystack = utf8codepoint(haystack, &h_cp);\n    n = utf8codepoint(n, &n_cp);\n\n    while ((0 != h_cp) && (0 != n_cp)) {\n      h_cp = utf8lwrcodepoint(h_cp);\n      n_cp = utf8lwrcodepoint(n_cp);\n\n      /* if we find a mismatch, bail out! */\n      if (h_cp != n_cp) {\n        break;\n      }\n\n      haystack = utf8codepoint(haystack, &h_cp);\n      n = utf8codepoint(n, &n_cp);\n    }\n\n    if (0 == n_cp) {\n      /* we found the whole utf8 string for needle in haystack at\n       * maybeMatch, so return it */\n      return (utf8_int8_t *)maybeMatch;\n    }\n\n    if (0 == h_cp) {\n      /* no match */\n      return utf8_null;\n    }\n\n    /* Roll back to the next code point in the haystack to test */\n    haystack = nextH;\n  }\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8valid(const utf8_int8_t *str) {\n  return utf8nvalid(str, SIZE_MAX);\n}\n\nutf8_constexpr14_impl utf8_int8_t *utf8nvalid(const utf8_int8_t *str,\n                                              size_t n) {\n  const utf8_int8_t *t = str;\n  size_t consumed = 0;\n\n  while ((void)(consumed = (size_t)(str - t)), consumed < n && '\\0' != *str) {\n    const size_t remaining = n - consumed;\n\n    if (0xf0 == (0xf8 & *str)) {\n      /* ensure that there's 4 bytes or more remaining */\n      if (remaining < 4) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure each of the 3 following bytes in this 4-byte\n       * utf8 codepoint began with 0b10xxxxxx */\n      if ((0x80 != (0xc0 & str[1])) || (0x80 != (0xc0 & str[2])) ||\n          (0x80 != (0xc0 & str[3]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure that our utf8 codepoint ended after 4 bytes */\n      if ((remaining != 4) && (0x80 == (0xc0 & str[4]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure that the top 5 bits of this 4-byte utf8\n       * codepoint were not 0, as then we could have used\n       * one of the smaller encodings */\n      if ((0 == (0x07 & str[0])) && (0 == (0x30 & str[1]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* 4-byte utf8 code point (began with 0b11110xxx) */\n      str += 4;\n    } else if (0xe0 == (0xf0 & *str)) {\n      /* ensure that there's 3 bytes or more remaining */\n      if (remaining < 3) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure each of the 2 following bytes in this 3-byte\n       * utf8 codepoint began with 0b10xxxxxx */\n      if ((0x80 != (0xc0 & str[1])) || (0x80 != (0xc0 & str[2]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure that our utf8 codepoint ended after 3 bytes */\n      if ((remaining != 3) && (0x80 == (0xc0 & str[3]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure that the top 5 bits of this 3-byte utf8\n       * codepoint were not 0, as then we could have used\n       * one of the smaller encodings */\n      if ((0 == (0x0f & str[0])) && (0 == (0x20 & str[1]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* 3-byte utf8 code point (began with 0b1110xxxx) */\n      str += 3;\n    } else if (0xc0 == (0xe0 & *str)) {\n      /* ensure that there's 2 bytes or more remaining */\n      if (remaining < 2) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure the 1 following byte in this 2-byte\n       * utf8 codepoint began with 0b10xxxxxx */\n      if (0x80 != (0xc0 & str[1])) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure that our utf8 codepoint ended after 2 bytes */\n      if ((remaining != 2) && (0x80 == (0xc0 & str[2]))) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* ensure that the top 4 bits of this 2-byte utf8\n       * codepoint were not 0, as then we could have used\n       * one of the smaller encodings */\n      if (0 == (0x1e & str[0])) {\n        return (utf8_int8_t *)str;\n      }\n\n      /* 2-byte utf8 code point (began with 0b110xxxxx) */\n      str += 2;\n    } else if (0x00 == (0x80 & *str)) {\n      /* 1-byte ascii (began with 0b0xxxxxxx) */\n      str += 1;\n    } else {\n      /* we have an invalid 0b1xxxxxxx utf8 code point entry */\n      return (utf8_int8_t *)str;\n    }\n  }\n\n  return utf8_null;\n}\n\nint utf8makevalid(utf8_int8_t *str, const utf8_int32_t replacement) {\n  utf8_int8_t *read = str;\n  utf8_int8_t *write = read;\n  const utf8_int8_t r = (utf8_int8_t)replacement;\n  utf8_int32_t codepoint = 0;\n\n  if (replacement > 0x7f) {\n    return -1;\n  }\n\n  while ('\\0' != *read) {\n    if (0xf0 == (0xf8 & *read)) {\n      /* ensure each of the 3 following bytes in this 4-byte\n       * utf8 codepoint began with 0b10xxxxxx */\n      if ((0x80 != (0xc0 & read[1])) || (0x80 != (0xc0 & read[2])) ||\n          (0x80 != (0xc0 & read[3]))) {\n        *write++ = r;\n        read++;\n        continue;\n      }\n\n      /* 4-byte utf8 code point (began with 0b11110xxx) */\n      read = utf8codepoint(read, &codepoint);\n      write = utf8catcodepoint(write, codepoint, 4);\n    } else if (0xe0 == (0xf0 & *read)) {\n      /* ensure each of the 2 following bytes in this 3-byte\n       * utf8 codepoint began with 0b10xxxxxx */\n      if ((0x80 != (0xc0 & read[1])) || (0x80 != (0xc0 & read[2]))) {\n        *write++ = r;\n        read++;\n        continue;\n      }\n\n      /* 3-byte utf8 code point (began with 0b1110xxxx) */\n      read = utf8codepoint(read, &codepoint);\n      write = utf8catcodepoint(write, codepoint, 3);\n    } else if (0xc0 == (0xe0 & *read)) {\n      /* ensure the 1 following byte in this 2-byte\n       * utf8 codepoint began with 0b10xxxxxx */\n      if (0x80 != (0xc0 & read[1])) {\n        *write++ = r;\n        read++;\n        continue;\n      }\n\n      /* 2-byte utf8 code point (began with 0b110xxxxx) */\n      read = utf8codepoint(read, &codepoint);\n      write = utf8catcodepoint(write, codepoint, 2);\n    } else if (0x00 == (0x80 & *read)) {\n      /* 1-byte ascii (began with 0b0xxxxxxx) */\n      read = utf8codepoint(read, &codepoint);\n      write = utf8catcodepoint(write, codepoint, 1);\n    } else {\n      /* if we got here then we've got a dangling continuation (0b10xxxxxx) */\n      *write++ = r;\n      read++;\n      continue;\n    }\n  }\n\n  *write = '\\0';\n\n  return 0;\n}\n\nutf8_constexpr14_impl utf8_int8_t *\nutf8codepoint(const utf8_int8_t *utf8_restrict str,\n              utf8_int32_t *utf8_restrict out_codepoint) {\n  if (0xf0 == (0xf8 & str[0])) {\n    /* 4 byte utf8 codepoint */\n    *out_codepoint = ((0x07 & str[0]) << 18) | ((0x3f & str[1]) << 12) |\n                     ((0x3f & str[2]) << 6) | (0x3f & str[3]);\n    str += 4;\n  } else if (0xe0 == (0xf0 & str[0])) {\n    /* 3 byte utf8 codepoint */\n    *out_codepoint =\n        ((0x0f & str[0]) << 12) | ((0x3f & str[1]) << 6) | (0x3f & str[2]);\n    str += 3;\n  } else if (0xc0 == (0xe0 & str[0])) {\n    /* 2 byte utf8 codepoint */\n    *out_codepoint = ((0x1f & str[0]) << 6) | (0x3f & str[1]);\n    str += 2;\n  } else {\n    /* 1 byte utf8 codepoint otherwise */\n    *out_codepoint = str[0];\n    str += 1;\n  }\n\n  return (utf8_int8_t *)str;\n}\n\nutf8_constexpr14_impl size_t utf8codepointcalcsize(const utf8_int8_t *str) {\n  if (0xf0 == (0xf8 & str[0])) {\n    /* 4 byte utf8 codepoint */\n    return 4;\n  } else if (0xe0 == (0xf0 & str[0])) {\n    /* 3 byte utf8 codepoint */\n    return 3;\n  } else if (0xc0 == (0xe0 & str[0])) {\n    /* 2 byte utf8 codepoint */\n    return 2;\n  }\n\n  /* 1 byte utf8 codepoint otherwise */\n  return 1;\n}\n\nutf8_constexpr14_impl size_t utf8codepointsize(utf8_int32_t chr) {\n  if (0 == ((utf8_int32_t)0xffffff80 & chr)) {\n    return 1;\n  } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {\n    return 2;\n  } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {\n    return 3;\n  } else { /* if (0 == ((int)0xffe00000 & chr)) { */\n    return 4;\n  }\n}\n\nutf8_int8_t *utf8catcodepoint(utf8_int8_t *str, utf8_int32_t chr, size_t n) {\n  if (0 == ((utf8_int32_t)0xffffff80 & chr)) {\n    /* 1-byte/7-bit ascii\n     * (0b0xxxxxxx) */\n    if (n < 1) {\n      return utf8_null;\n    }\n    str[0] = (utf8_int8_t)chr;\n    str += 1;\n  } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {\n    /* 2-byte/11-bit utf8 code point\n     * (0b110xxxxx 0b10xxxxxx) */\n    if (n < 2) {\n      return utf8_null;\n    }\n    str[0] = (utf8_int8_t)(0xc0 | (utf8_int8_t)((chr >> 6) & 0x1f));\n    str[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n    str += 2;\n  } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {\n    /* 3-byte/16-bit utf8 code point\n     * (0b1110xxxx 0b10xxxxxx 0b10xxxxxx) */\n    if (n < 3) {\n      return utf8_null;\n    }\n    str[0] = (utf8_int8_t)(0xe0 | (utf8_int8_t)((chr >> 12) & 0x0f));\n    str[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));\n    str[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n    str += 3;\n  } else { /* if (0 == ((int)0xffe00000 & chr)) { */\n    /* 4-byte/21-bit utf8 code point\n     * (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx) */\n    if (n < 4) {\n      return utf8_null;\n    }\n    str[0] = (utf8_int8_t)(0xf0 | (utf8_int8_t)((chr >> 18) & 0x07));\n    str[1] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 12) & 0x3f));\n    str[2] = (utf8_int8_t)(0x80 | (utf8_int8_t)((chr >> 6) & 0x3f));\n    str[3] = (utf8_int8_t)(0x80 | (utf8_int8_t)(chr & 0x3f));\n    str += 4;\n  }\n\n  return str;\n}\n\nutf8_constexpr14_impl int utf8islower(utf8_int32_t chr) {\n  return chr != utf8uprcodepoint(chr);\n}\n\nutf8_constexpr14_impl int utf8isupper(utf8_int32_t chr) {\n  return chr != utf8lwrcodepoint(chr);\n}\n\nvoid utf8lwr(utf8_int8_t *utf8_restrict str) {\n  utf8_int32_t cp = 0;\n  utf8_int8_t *pn = utf8codepoint(str, &cp);\n\n  while (cp != 0) {\n    const utf8_int32_t lwr_cp = utf8lwrcodepoint(cp);\n    const size_t size = utf8codepointsize(lwr_cp);\n\n    if (lwr_cp != cp) {\n      utf8catcodepoint(str, lwr_cp, size);\n    }\n\n    str = pn;\n    pn = utf8codepoint(str, &cp);\n  }\n}\n\nvoid utf8upr(utf8_int8_t *utf8_restrict str) {\n  utf8_int32_t cp = 0;\n  utf8_int8_t *pn = utf8codepoint(str, &cp);\n\n  while (cp != 0) {\n    const utf8_int32_t lwr_cp = utf8uprcodepoint(cp);\n    const size_t size = utf8codepointsize(lwr_cp);\n\n    if (lwr_cp != cp) {\n      utf8catcodepoint(str, lwr_cp, size);\n    }\n\n    str = pn;\n    pn = utf8codepoint(str, &cp);\n  }\n}\n\nutf8_constexpr14_impl utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp) {\n  if (((0x0041 <= cp) && (0x005a >= cp)) ||\n      ((0x00c0 <= cp) && (0x00d6 >= cp)) ||\n      ((0x00d8 <= cp) && (0x00de >= cp)) ||\n      ((0x0391 <= cp) && (0x03a1 >= cp)) ||\n      ((0x03a3 <= cp) && (0x03ab >= cp)) ||\n      ((0x0410 <= cp) && (0x042f >= cp))) {\n    cp += 32;\n  } else if ((0x0400 <= cp) && (0x040f >= cp)) {\n    cp += 80;\n  } else if (((0x0100 <= cp) && (0x012f >= cp)) ||\n             ((0x0132 <= cp) && (0x0137 >= cp)) ||\n             ((0x014a <= cp) && (0x0177 >= cp)) ||\n             ((0x0182 <= cp) && (0x0185 >= cp)) ||\n             ((0x01a0 <= cp) && (0x01a5 >= cp)) ||\n             ((0x01de <= cp) && (0x01ef >= cp)) ||\n             ((0x01f8 <= cp) && (0x021f >= cp)) ||\n             ((0x0222 <= cp) && (0x0233 >= cp)) ||\n             ((0x0246 <= cp) && (0x024f >= cp)) ||\n             ((0x03d8 <= cp) && (0x03ef >= cp)) ||\n             ((0x0460 <= cp) && (0x0481 >= cp)) ||\n             ((0x048a <= cp) && (0x04ff >= cp))) {\n    cp |= 0x1;\n  } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||\n             ((0x0179 <= cp) && (0x017e >= cp)) ||\n             ((0x01af <= cp) && (0x01b0 >= cp)) ||\n             ((0x01b3 <= cp) && (0x01b6 >= cp)) ||\n             ((0x01cd <= cp) && (0x01dc >= cp))) {\n    cp += 1;\n    cp &= ~0x1;\n  } else {\n    switch (cp) {\n    default:\n      break;\n    case 0x0178:\n      cp = 0x00ff;\n      break;\n    case 0x0243:\n      cp = 0x0180;\n      break;\n    case 0x018e:\n      cp = 0x01dd;\n      break;\n    case 0x023d:\n      cp = 0x019a;\n      break;\n    case 0x0220:\n      cp = 0x019e;\n      break;\n    case 0x01b7:\n      cp = 0x0292;\n      break;\n    case 0x01c4:\n      cp = 0x01c6;\n      break;\n    case 0x01c7:\n      cp = 0x01c9;\n      break;\n    case 0x01ca:\n      cp = 0x01cc;\n      break;\n    case 0x01f1:\n      cp = 0x01f3;\n      break;\n    case 0x01f7:\n      cp = 0x01bf;\n      break;\n    case 0x0187:\n      cp = 0x0188;\n      break;\n    case 0x018b:\n      cp = 0x018c;\n      break;\n    case 0x0191:\n      cp = 0x0192;\n      break;\n    case 0x0198:\n      cp = 0x0199;\n      break;\n    case 0x01a7:\n      cp = 0x01a8;\n      break;\n    case 0x01ac:\n      cp = 0x01ad;\n      break;\n    case 0x01b8:\n      cp = 0x01b9;\n      break;\n    case 0x01bc:\n      cp = 0x01bd;\n      break;\n    case 0x01f4:\n      cp = 0x01f5;\n      break;\n    case 0x023b:\n      cp = 0x023c;\n      break;\n    case 0x0241:\n      cp = 0x0242;\n      break;\n    case 0x03fd:\n      cp = 0x037b;\n      break;\n    case 0x03fe:\n      cp = 0x037c;\n      break;\n    case 0x03ff:\n      cp = 0x037d;\n      break;\n    case 0x037f:\n      cp = 0x03f3;\n      break;\n    case 0x0386:\n      cp = 0x03ac;\n      break;\n    case 0x0388:\n      cp = 0x03ad;\n      break;\n    case 0x0389:\n      cp = 0x03ae;\n      break;\n    case 0x038a:\n      cp = 0x03af;\n      break;\n    case 0x038c:\n      cp = 0x03cc;\n      break;\n    case 0x038e:\n      cp = 0x03cd;\n      break;\n    case 0x038f:\n      cp = 0x03ce;\n      break;\n    case 0x0370:\n      cp = 0x0371;\n      break;\n    case 0x0372:\n      cp = 0x0373;\n      break;\n    case 0x0376:\n      cp = 0x0377;\n      break;\n    case 0x03f4:\n      cp = 0x03b8;\n      break;\n    case 0x03cf:\n      cp = 0x03d7;\n      break;\n    case 0x03f9:\n      cp = 0x03f2;\n      break;\n    case 0x03f7:\n      cp = 0x03f8;\n      break;\n    case 0x03fa:\n      cp = 0x03fb;\n      break;\n    }\n  }\n\n  return cp;\n}\n\nutf8_constexpr14_impl utf8_int32_t utf8uprcodepoint(utf8_int32_t cp) {\n  if (((0x0061 <= cp) && (0x007a >= cp)) ||\n      ((0x00e0 <= cp) && (0x00f6 >= cp)) ||\n      ((0x00f8 <= cp) && (0x00fe >= cp)) ||\n      ((0x03b1 <= cp) && (0x03c1 >= cp)) ||\n      ((0x03c3 <= cp) && (0x03cb >= cp)) ||\n      ((0x0430 <= cp) && (0x044f >= cp))) {\n    cp -= 32;\n  } else if ((0x0450 <= cp) && (0x045f >= cp)) {\n    cp -= 80;\n  } else if (((0x0100 <= cp) && (0x012f >= cp)) ||\n             ((0x0132 <= cp) && (0x0137 >= cp)) ||\n             ((0x014a <= cp) && (0x0177 >= cp)) ||\n             ((0x0182 <= cp) && (0x0185 >= cp)) ||\n             ((0x01a0 <= cp) && (0x01a5 >= cp)) ||\n             ((0x01de <= cp) && (0x01ef >= cp)) ||\n             ((0x01f8 <= cp) && (0x021f >= cp)) ||\n             ((0x0222 <= cp) && (0x0233 >= cp)) ||\n             ((0x0246 <= cp) && (0x024f >= cp)) ||\n             ((0x03d8 <= cp) && (0x03ef >= cp)) ||\n             ((0x0460 <= cp) && (0x0481 >= cp)) ||\n             ((0x048a <= cp) && (0x04ff >= cp))) {\n    cp &= ~0x1;\n  } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||\n             ((0x0179 <= cp) && (0x017e >= cp)) ||\n             ((0x01af <= cp) && (0x01b0 >= cp)) ||\n             ((0x01b3 <= cp) && (0x01b6 >= cp)) ||\n             ((0x01cd <= cp) && (0x01dc >= cp))) {\n    cp -= 1;\n    cp |= 0x1;\n  } else {\n    switch (cp) {\n    default:\n      break;\n    case 0x00ff:\n      cp = 0x0178;\n      break;\n    case 0x0180:\n      cp = 0x0243;\n      break;\n    case 0x01dd:\n      cp = 0x018e;\n      break;\n    case 0x019a:\n      cp = 0x023d;\n      break;\n    case 0x019e:\n      cp = 0x0220;\n      break;\n    case 0x0292:\n      cp = 0x01b7;\n      break;\n    case 0x01c6:\n      cp = 0x01c4;\n      break;\n    case 0x01c9:\n      cp = 0x01c7;\n      break;\n    case 0x01cc:\n      cp = 0x01ca;\n      break;\n    case 0x01f3:\n      cp = 0x01f1;\n      break;\n    case 0x01bf:\n      cp = 0x01f7;\n      break;\n    case 0x0188:\n      cp = 0x0187;\n      break;\n    case 0x018c:\n      cp = 0x018b;\n      break;\n    case 0x0192:\n      cp = 0x0191;\n      break;\n    case 0x0199:\n      cp = 0x0198;\n      break;\n    case 0x01a8:\n      cp = 0x01a7;\n      break;\n    case 0x01ad:\n      cp = 0x01ac;\n      break;\n    case 0x01b9:\n      cp = 0x01b8;\n      break;\n    case 0x01bd:\n      cp = 0x01bc;\n      break;\n    case 0x01f5:\n      cp = 0x01f4;\n      break;\n    case 0x023c:\n      cp = 0x023b;\n      break;\n    case 0x0242:\n      cp = 0x0241;\n      break;\n    case 0x037b:\n      cp = 0x03fd;\n      break;\n    case 0x037c:\n      cp = 0x03fe;\n      break;\n    case 0x037d:\n      cp = 0x03ff;\n      break;\n    case 0x03f3:\n      cp = 0x037f;\n      break;\n    case 0x03ac:\n      cp = 0x0386;\n      break;\n    case 0x03ad:\n      cp = 0x0388;\n      break;\n    case 0x03ae:\n      cp = 0x0389;\n      break;\n    case 0x03af:\n      cp = 0x038a;\n      break;\n    case 0x03cc:\n      cp = 0x038c;\n      break;\n    case 0x03cd:\n      cp = 0x038e;\n      break;\n    case 0x03ce:\n      cp = 0x038f;\n      break;\n    case 0x0371:\n      cp = 0x0370;\n      break;\n    case 0x0373:\n      cp = 0x0372;\n      break;\n    case 0x0377:\n      cp = 0x0376;\n      break;\n    case 0x03d1:\n      cp = 0x0398;\n      break;\n    case 0x03d7:\n      cp = 0x03cf;\n      break;\n    case 0x03f2:\n      cp = 0x03f9;\n      break;\n    case 0x03f8:\n      cp = 0x03f7;\n      break;\n    case 0x03fb:\n      cp = 0x03fa;\n      break;\n    }\n  }\n\n  return cp;\n}\n\nutf8_constexpr14_impl utf8_int8_t *\nutf8rcodepoint(const utf8_int8_t *utf8_restrict str,\n               utf8_int32_t *utf8_restrict out_codepoint) {\n  const utf8_int8_t *s = (const utf8_int8_t *)str;\n\n  if (0xf0 == (0xf8 & s[0])) {\n    /* 4 byte utf8 codepoint */\n    *out_codepoint = ((0x07 & s[0]) << 18) | ((0x3f & s[1]) << 12) |\n                     ((0x3f & s[2]) << 6) | (0x3f & s[3]);\n  } else if (0xe0 == (0xf0 & s[0])) {\n    /* 3 byte utf8 codepoint */\n    *out_codepoint =\n        ((0x0f & s[0]) << 12) | ((0x3f & s[1]) << 6) | (0x3f & s[2]);\n  } else if (0xc0 == (0xe0 & s[0])) {\n    /* 2 byte utf8 codepoint */\n    *out_codepoint = ((0x1f & s[0]) << 6) | (0x3f & s[1]);\n  } else {\n    /* 1 byte utf8 codepoint otherwise */\n    *out_codepoint = s[0];\n  }\n\n  do {\n    s--;\n  } while ((0 != (0x80 & s[0])) && (0x80 == (0xc0 & s[0])));\n\n  return (utf8_int8_t *)s;\n}\n\n#undef utf8_restrict\n#undef utf8_constexpr14\n#undef utf8_null\n\n#ifdef utf8_cplusplus\n} /* extern \"C\" */\n#endif\n\n#if defined(__clang__)\n#pragma clang diagnostic pop\n#endif\n\n#endif /* SHEREDOM_UTF8_H_INCLUDED */\n"
        }
      ]
    }
  ]
}