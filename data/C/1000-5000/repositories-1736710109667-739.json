{
  "metadata": {
    "timestamp": 1736710109667,
    "page": 739,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "B-Con/crypto-algorithms",
      "stars": 1860,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.5390625,
          "content": "crypto-algorithms\n=================\n\n\nAbout\n---\nThese are basic implementations of standard cryptography algorithms, written by Brad Conte (brad@bradconte.com) from scratch and without any cross-licensing. They exist to provide publically accessible, restriction-free implementations of popular cryptographic algorithms, like AES and SHA-1. These are primarily intended for educational and pragmatic purposes (such as comparing a specification to actual implementation code, or for building an internal application that computes test vectors for a product). The algorithms have been tested against standard test vectors.\n\nThis code is released into the public domain free of any restrictions. The author requests acknowledgement if the code is used, but does not require it. This code is provided free of any liability and without any quality claims by the author.\n\nNote that these are *not* cryptographically secure implementations. They have no resistence to side-channel attacks and should not be used in contexts that need cryptographically secure implementations.\n\nThese algorithms are not optimized for speed or space. They are primarily designed to be easy to read, although some basic optimization techniques have been employed.\n\nBuilding\n---\nThe source code for each algorithm will come in a pair of a source code file and a header file. There should be no inter-header file dependencies, no additional libraries, no platform-specific header files, or any other complicating matters. Compiling them should be as easy as adding the relevent source code to the project."
        },
        {
          "name": "aes.c",
          "type": "blob",
          "size": 41.3681640625,
          "content": "/*********************************************************************\n* Filename:   aes.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    This code is the implementation of the AES algorithm and\n              the CTR, CBC, and CCM modes of operation it can be used in.\n               AES is, specified by the NIST in in publication FIPS PUB 197,\n              availible at:\n               * http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf .\n              The CBC and CTR modes of operation are specified by\n              NIST SP 800-38 A, available at:\n               * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf .\n              The CCM mode of operation is specified by NIST SP80-38 C, available at:\n               * http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"aes.h\"\n\n#include <stdio.h>\n\n/****************************** MACROS ******************************/\n// The least significant byte of the word is rotated to the end.\n#define KE_ROTWORD(x) (((x) << 8) | ((x) >> 24))\n\n#define TRUE  1\n#define FALSE 0\n\n/**************************** DATA TYPES ****************************/\n#define AES_128_ROUNDS 10\n#define AES_192_ROUNDS 12\n#define AES_256_ROUNDS 14\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid ccm_prepare_first_ctr_blk(BYTE counter[], const BYTE nonce[], int nonce_len, int payload_len_store_size);\nvoid ccm_prepare_first_format_blk(BYTE buf[], int assoc_len, int payload_len, int payload_len_store_size, int mac_len, const BYTE nonce[], int nonce_len);\nvoid ccm_format_assoc_data(BYTE buf[], int *end_of_buf, const BYTE assoc[], int assoc_len);\nvoid ccm_format_payload_data(BYTE buf[], int *end_of_buf, const BYTE payload[], int payload_len);\n\n/**************************** VARIABLES *****************************/\n// This is the specified AES SBox. To look up a substitution value, put the first\n// nibble in the first index (row) and the second nibble in the second index (column).\nstatic const BYTE aes_sbox[16][16] = {\n\t{0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76},\n\t{0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0},\n\t{0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15},\n\t{0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75},\n\t{0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84},\n\t{0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF},\n\t{0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8},\n\t{0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2},\n\t{0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73},\n\t{0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB},\n\t{0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79},\n\t{0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08},\n\t{0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A},\n\t{0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E},\n\t{0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF},\n\t{0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16}\n};\n\nstatic const BYTE aes_invsbox[16][16] = {\n\t{0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB},\n\t{0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB},\n\t{0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E},\n\t{0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25},\n\t{0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92},\n\t{0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84},\n\t{0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06},\n\t{0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B},\n\t{0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73},\n\t{0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E},\n\t{0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B},\n\t{0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4},\n\t{0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F},\n\t{0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF},\n\t{0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61},\n\t{0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D}\n};\n\n// This table stores pre-calculated values for all possible GF(2^8) calculations.This\n// table is only used by the (Inv)MixColumns steps.\n// USAGE: The second index (column) is the coefficient of multiplication. Only 7 different\n// coefficients are used: 0x01, 0x02, 0x03, 0x09, 0x0b, 0x0d, 0x0e, but multiplication by\n// 1 is negligible leaving only 6 coefficients. Each column of the table is devoted to one\n// of these coefficients, in the ascending order of value, from values 0x00 to 0xFF.\nstatic const BYTE gf_mul[256][6] = {\n\t{0x00,0x00,0x00,0x00,0x00,0x00},{0x02,0x03,0x09,0x0b,0x0d,0x0e},\n\t{0x04,0x06,0x12,0x16,0x1a,0x1c},{0x06,0x05,0x1b,0x1d,0x17,0x12},\n\t{0x08,0x0c,0x24,0x2c,0x34,0x38},{0x0a,0x0f,0x2d,0x27,0x39,0x36},\n\t{0x0c,0x0a,0x36,0x3a,0x2e,0x24},{0x0e,0x09,0x3f,0x31,0x23,0x2a},\n\t{0x10,0x18,0x48,0x58,0x68,0x70},{0x12,0x1b,0x41,0x53,0x65,0x7e},\n\t{0x14,0x1e,0x5a,0x4e,0x72,0x6c},{0x16,0x1d,0x53,0x45,0x7f,0x62},\n\t{0x18,0x14,0x6c,0x74,0x5c,0x48},{0x1a,0x17,0x65,0x7f,0x51,0x46},\n\t{0x1c,0x12,0x7e,0x62,0x46,0x54},{0x1e,0x11,0x77,0x69,0x4b,0x5a},\n\t{0x20,0x30,0x90,0xb0,0xd0,0xe0},{0x22,0x33,0x99,0xbb,0xdd,0xee},\n\t{0x24,0x36,0x82,0xa6,0xca,0xfc},{0x26,0x35,0x8b,0xad,0xc7,0xf2},\n\t{0x28,0x3c,0xb4,0x9c,0xe4,0xd8},{0x2a,0x3f,0xbd,0x97,0xe9,0xd6},\n\t{0x2c,0x3a,0xa6,0x8a,0xfe,0xc4},{0x2e,0x39,0xaf,0x81,0xf3,0xca},\n\t{0x30,0x28,0xd8,0xe8,0xb8,0x90},{0x32,0x2b,0xd1,0xe3,0xb5,0x9e},\n\t{0x34,0x2e,0xca,0xfe,0xa2,0x8c},{0x36,0x2d,0xc3,0xf5,0xaf,0x82},\n\t{0x38,0x24,0xfc,0xc4,0x8c,0xa8},{0x3a,0x27,0xf5,0xcf,0x81,0xa6},\n\t{0x3c,0x22,0xee,0xd2,0x96,0xb4},{0x3e,0x21,0xe7,0xd9,0x9b,0xba},\n\t{0x40,0x60,0x3b,0x7b,0xbb,0xdb},{0x42,0x63,0x32,0x70,0xb6,0xd5},\n\t{0x44,0x66,0x29,0x6d,0xa1,0xc7},{0x46,0x65,0x20,0x66,0xac,0xc9},\n\t{0x48,0x6c,0x1f,0x57,0x8f,0xe3},{0x4a,0x6f,0x16,0x5c,0x82,0xed},\n\t{0x4c,0x6a,0x0d,0x41,0x95,0xff},{0x4e,0x69,0x04,0x4a,0x98,0xf1},\n\t{0x50,0x78,0x73,0x23,0xd3,0xab},{0x52,0x7b,0x7a,0x28,0xde,0xa5},\n\t{0x54,0x7e,0x61,0x35,0xc9,0xb7},{0x56,0x7d,0x68,0x3e,0xc4,0xb9},\n\t{0x58,0x74,0x57,0x0f,0xe7,0x93},{0x5a,0x77,0x5e,0x04,0xea,0x9d},\n\t{0x5c,0x72,0x45,0x19,0xfd,0x8f},{0x5e,0x71,0x4c,0x12,0xf0,0x81},\n\t{0x60,0x50,0xab,0xcb,0x6b,0x3b},{0x62,0x53,0xa2,0xc0,0x66,0x35},\n\t{0x64,0x56,0xb9,0xdd,0x71,0x27},{0x66,0x55,0xb0,0xd6,0x7c,0x29},\n\t{0x68,0x5c,0x8f,0xe7,0x5f,0x03},{0x6a,0x5f,0x86,0xec,0x52,0x0d},\n\t{0x6c,0x5a,0x9d,0xf1,0x45,0x1f},{0x6e,0x59,0x94,0xfa,0x48,0x11},\n\t{0x70,0x48,0xe3,0x93,0x03,0x4b},{0x72,0x4b,0xea,0x98,0x0e,0x45},\n\t{0x74,0x4e,0xf1,0x85,0x19,0x57},{0x76,0x4d,0xf8,0x8e,0x14,0x59},\n\t{0x78,0x44,0xc7,0xbf,0x37,0x73},{0x7a,0x47,0xce,0xb4,0x3a,0x7d},\n\t{0x7c,0x42,0xd5,0xa9,0x2d,0x6f},{0x7e,0x41,0xdc,0xa2,0x20,0x61},\n\t{0x80,0xc0,0x76,0xf6,0x6d,0xad},{0x82,0xc3,0x7f,0xfd,0x60,0xa3},\n\t{0x84,0xc6,0x64,0xe0,0x77,0xb1},{0x86,0xc5,0x6d,0xeb,0x7a,0xbf},\n\t{0x88,0xcc,0x52,0xda,0x59,0x95},{0x8a,0xcf,0x5b,0xd1,0x54,0x9b},\n\t{0x8c,0xca,0x40,0xcc,0x43,0x89},{0x8e,0xc9,0x49,0xc7,0x4e,0x87},\n\t{0x90,0xd8,0x3e,0xae,0x05,0xdd},{0x92,0xdb,0x37,0xa5,0x08,0xd3},\n\t{0x94,0xde,0x2c,0xb8,0x1f,0xc1},{0x96,0xdd,0x25,0xb3,0x12,0xcf},\n\t{0x98,0xd4,0x1a,0x82,0x31,0xe5},{0x9a,0xd7,0x13,0x89,0x3c,0xeb},\n\t{0x9c,0xd2,0x08,0x94,0x2b,0xf9},{0x9e,0xd1,0x01,0x9f,0x26,0xf7},\n\t{0xa0,0xf0,0xe6,0x46,0xbd,0x4d},{0xa2,0xf3,0xef,0x4d,0xb0,0x43},\n\t{0xa4,0xf6,0xf4,0x50,0xa7,0x51},{0xa6,0xf5,0xfd,0x5b,0xaa,0x5f},\n\t{0xa8,0xfc,0xc2,0x6a,0x89,0x75},{0xaa,0xff,0xcb,0x61,0x84,0x7b},\n\t{0xac,0xfa,0xd0,0x7c,0x93,0x69},{0xae,0xf9,0xd9,0x77,0x9e,0x67},\n\t{0xb0,0xe8,0xae,0x1e,0xd5,0x3d},{0xb2,0xeb,0xa7,0x15,0xd8,0x33},\n\t{0xb4,0xee,0xbc,0x08,0xcf,0x21},{0xb6,0xed,0xb5,0x03,0xc2,0x2f},\n\t{0xb8,0xe4,0x8a,0x32,0xe1,0x05},{0xba,0xe7,0x83,0x39,0xec,0x0b},\n\t{0xbc,0xe2,0x98,0x24,0xfb,0x19},{0xbe,0xe1,0x91,0x2f,0xf6,0x17},\n\t{0xc0,0xa0,0x4d,0x8d,0xd6,0x76},{0xc2,0xa3,0x44,0x86,0xdb,0x78},\n\t{0xc4,0xa6,0x5f,0x9b,0xcc,0x6a},{0xc6,0xa5,0x56,0x90,0xc1,0x64},\n\t{0xc8,0xac,0x69,0xa1,0xe2,0x4e},{0xca,0xaf,0x60,0xaa,0xef,0x40},\n\t{0xcc,0xaa,0x7b,0xb7,0xf8,0x52},{0xce,0xa9,0x72,0xbc,0xf5,0x5c},\n\t{0xd0,0xb8,0x05,0xd5,0xbe,0x06},{0xd2,0xbb,0x0c,0xde,0xb3,0x08},\n\t{0xd4,0xbe,0x17,0xc3,0xa4,0x1a},{0xd6,0xbd,0x1e,0xc8,0xa9,0x14},\n\t{0xd8,0xb4,0x21,0xf9,0x8a,0x3e},{0xda,0xb7,0x28,0xf2,0x87,0x30},\n\t{0xdc,0xb2,0x33,0xef,0x90,0x22},{0xde,0xb1,0x3a,0xe4,0x9d,0x2c},\n\t{0xe0,0x90,0xdd,0x3d,0x06,0x96},{0xe2,0x93,0xd4,0x36,0x0b,0x98},\n\t{0xe4,0x96,0xcf,0x2b,0x1c,0x8a},{0xe6,0x95,0xc6,0x20,0x11,0x84},\n\t{0xe8,0x9c,0xf9,0x11,0x32,0xae},{0xea,0x9f,0xf0,0x1a,0x3f,0xa0},\n\t{0xec,0x9a,0xeb,0x07,0x28,0xb2},{0xee,0x99,0xe2,0x0c,0x25,0xbc},\n\t{0xf0,0x88,0x95,0x65,0x6e,0xe6},{0xf2,0x8b,0x9c,0x6e,0x63,0xe8},\n\t{0xf4,0x8e,0x87,0x73,0x74,0xfa},{0xf6,0x8d,0x8e,0x78,0x79,0xf4},\n\t{0xf8,0x84,0xb1,0x49,0x5a,0xde},{0xfa,0x87,0xb8,0x42,0x57,0xd0},\n\t{0xfc,0x82,0xa3,0x5f,0x40,0xc2},{0xfe,0x81,0xaa,0x54,0x4d,0xcc},\n\t{0x1b,0x9b,0xec,0xf7,0xda,0x41},{0x19,0x98,0xe5,0xfc,0xd7,0x4f},\n\t{0x1f,0x9d,0xfe,0xe1,0xc0,0x5d},{0x1d,0x9e,0xf7,0xea,0xcd,0x53},\n\t{0x13,0x97,0xc8,0xdb,0xee,0x79},{0x11,0x94,0xc1,0xd0,0xe3,0x77},\n\t{0x17,0x91,0xda,0xcd,0xf4,0x65},{0x15,0x92,0xd3,0xc6,0xf9,0x6b},\n\t{0x0b,0x83,0xa4,0xaf,0xb2,0x31},{0x09,0x80,0xad,0xa4,0xbf,0x3f},\n\t{0x0f,0x85,0xb6,0xb9,0xa8,0x2d},{0x0d,0x86,0xbf,0xb2,0xa5,0x23},\n\t{0x03,0x8f,0x80,0x83,0x86,0x09},{0x01,0x8c,0x89,0x88,0x8b,0x07},\n\t{0x07,0x89,0x92,0x95,0x9c,0x15},{0x05,0x8a,0x9b,0x9e,0x91,0x1b},\n\t{0x3b,0xab,0x7c,0x47,0x0a,0xa1},{0x39,0xa8,0x75,0x4c,0x07,0xaf},\n\t{0x3f,0xad,0x6e,0x51,0x10,0xbd},{0x3d,0xae,0x67,0x5a,0x1d,0xb3},\n\t{0x33,0xa7,0x58,0x6b,0x3e,0x99},{0x31,0xa4,0x51,0x60,0x33,0x97},\n\t{0x37,0xa1,0x4a,0x7d,0x24,0x85},{0x35,0xa2,0x43,0x76,0x29,0x8b},\n\t{0x2b,0xb3,0x34,0x1f,0x62,0xd1},{0x29,0xb0,0x3d,0x14,0x6f,0xdf},\n\t{0x2f,0xb5,0x26,0x09,0x78,0xcd},{0x2d,0xb6,0x2f,0x02,0x75,0xc3},\n\t{0x23,0xbf,0x10,0x33,0x56,0xe9},{0x21,0xbc,0x19,0x38,0x5b,0xe7},\n\t{0x27,0xb9,0x02,0x25,0x4c,0xf5},{0x25,0xba,0x0b,0x2e,0x41,0xfb},\n\t{0x5b,0xfb,0xd7,0x8c,0x61,0x9a},{0x59,0xf8,0xde,0x87,0x6c,0x94},\n\t{0x5f,0xfd,0xc5,0x9a,0x7b,0x86},{0x5d,0xfe,0xcc,0x91,0x76,0x88},\n\t{0x53,0xf7,0xf3,0xa0,0x55,0xa2},{0x51,0xf4,0xfa,0xab,0x58,0xac},\n\t{0x57,0xf1,0xe1,0xb6,0x4f,0xbe},{0x55,0xf2,0xe8,0xbd,0x42,0xb0},\n\t{0x4b,0xe3,0x9f,0xd4,0x09,0xea},{0x49,0xe0,0x96,0xdf,0x04,0xe4},\n\t{0x4f,0xe5,0x8d,0xc2,0x13,0xf6},{0x4d,0xe6,0x84,0xc9,0x1e,0xf8},\n\t{0x43,0xef,0xbb,0xf8,0x3d,0xd2},{0x41,0xec,0xb2,0xf3,0x30,0xdc},\n\t{0x47,0xe9,0xa9,0xee,0x27,0xce},{0x45,0xea,0xa0,0xe5,0x2a,0xc0},\n\t{0x7b,0xcb,0x47,0x3c,0xb1,0x7a},{0x79,0xc8,0x4e,0x37,0xbc,0x74},\n\t{0x7f,0xcd,0x55,0x2a,0xab,0x66},{0x7d,0xce,0x5c,0x21,0xa6,0x68},\n\t{0x73,0xc7,0x63,0x10,0x85,0x42},{0x71,0xc4,0x6a,0x1b,0x88,0x4c},\n\t{0x77,0xc1,0x71,0x06,0x9f,0x5e},{0x75,0xc2,0x78,0x0d,0x92,0x50},\n\t{0x6b,0xd3,0x0f,0x64,0xd9,0x0a},{0x69,0xd0,0x06,0x6f,0xd4,0x04},\n\t{0x6f,0xd5,0x1d,0x72,0xc3,0x16},{0x6d,0xd6,0x14,0x79,0xce,0x18},\n\t{0x63,0xdf,0x2b,0x48,0xed,0x32},{0x61,0xdc,0x22,0x43,0xe0,0x3c},\n\t{0x67,0xd9,0x39,0x5e,0xf7,0x2e},{0x65,0xda,0x30,0x55,0xfa,0x20},\n\t{0x9b,0x5b,0x9a,0x01,0xb7,0xec},{0x99,0x58,0x93,0x0a,0xba,0xe2},\n\t{0x9f,0x5d,0x88,0x17,0xad,0xf0},{0x9d,0x5e,0x81,0x1c,0xa0,0xfe},\n\t{0x93,0x57,0xbe,0x2d,0x83,0xd4},{0x91,0x54,0xb7,0x26,0x8e,0xda},\n\t{0x97,0x51,0xac,0x3b,0x99,0xc8},{0x95,0x52,0xa5,0x30,0x94,0xc6},\n\t{0x8b,0x43,0xd2,0x59,0xdf,0x9c},{0x89,0x40,0xdb,0x52,0xd2,0x92},\n\t{0x8f,0x45,0xc0,0x4f,0xc5,0x80},{0x8d,0x46,0xc9,0x44,0xc8,0x8e},\n\t{0x83,0x4f,0xf6,0x75,0xeb,0xa4},{0x81,0x4c,0xff,0x7e,0xe6,0xaa},\n\t{0x87,0x49,0xe4,0x63,0xf1,0xb8},{0x85,0x4a,0xed,0x68,0xfc,0xb6},\n\t{0xbb,0x6b,0x0a,0xb1,0x67,0x0c},{0xb9,0x68,0x03,0xba,0x6a,0x02},\n\t{0xbf,0x6d,0x18,0xa7,0x7d,0x10},{0xbd,0x6e,0x11,0xac,0x70,0x1e},\n\t{0xb3,0x67,0x2e,0x9d,0x53,0x34},{0xb1,0x64,0x27,0x96,0x5e,0x3a},\n\t{0xb7,0x61,0x3c,0x8b,0x49,0x28},{0xb5,0x62,0x35,0x80,0x44,0x26},\n\t{0xab,0x73,0x42,0xe9,0x0f,0x7c},{0xa9,0x70,0x4b,0xe2,0x02,0x72},\n\t{0xaf,0x75,0x50,0xff,0x15,0x60},{0xad,0x76,0x59,0xf4,0x18,0x6e},\n\t{0xa3,0x7f,0x66,0xc5,0x3b,0x44},{0xa1,0x7c,0x6f,0xce,0x36,0x4a},\n\t{0xa7,0x79,0x74,0xd3,0x21,0x58},{0xa5,0x7a,0x7d,0xd8,0x2c,0x56},\n\t{0xdb,0x3b,0xa1,0x7a,0x0c,0x37},{0xd9,0x38,0xa8,0x71,0x01,0x39},\n\t{0xdf,0x3d,0xb3,0x6c,0x16,0x2b},{0xdd,0x3e,0xba,0x67,0x1b,0x25},\n\t{0xd3,0x37,0x85,0x56,0x38,0x0f},{0xd1,0x34,0x8c,0x5d,0x35,0x01},\n\t{0xd7,0x31,0x97,0x40,0x22,0x13},{0xd5,0x32,0x9e,0x4b,0x2f,0x1d},\n\t{0xcb,0x23,0xe9,0x22,0x64,0x47},{0xc9,0x20,0xe0,0x29,0x69,0x49},\n\t{0xcf,0x25,0xfb,0x34,0x7e,0x5b},{0xcd,0x26,0xf2,0x3f,0x73,0x55},\n\t{0xc3,0x2f,0xcd,0x0e,0x50,0x7f},{0xc1,0x2c,0xc4,0x05,0x5d,0x71},\n\t{0xc7,0x29,0xdf,0x18,0x4a,0x63},{0xc5,0x2a,0xd6,0x13,0x47,0x6d},\n\t{0xfb,0x0b,0x31,0xca,0xdc,0xd7},{0xf9,0x08,0x38,0xc1,0xd1,0xd9},\n\t{0xff,0x0d,0x23,0xdc,0xc6,0xcb},{0xfd,0x0e,0x2a,0xd7,0xcb,0xc5},\n\t{0xf3,0x07,0x15,0xe6,0xe8,0xef},{0xf1,0x04,0x1c,0xed,0xe5,0xe1},\n\t{0xf7,0x01,0x07,0xf0,0xf2,0xf3},{0xf5,0x02,0x0e,0xfb,0xff,0xfd},\n\t{0xeb,0x13,0x79,0x92,0xb4,0xa7},{0xe9,0x10,0x70,0x99,0xb9,0xa9},\n\t{0xef,0x15,0x6b,0x84,0xae,0xbb},{0xed,0x16,0x62,0x8f,0xa3,0xb5},\n\t{0xe3,0x1f,0x5d,0xbe,0x80,0x9f},{0xe1,0x1c,0x54,0xb5,0x8d,0x91},\n\t{0xe7,0x19,0x4f,0xa8,0x9a,0x83},{0xe5,0x1a,0x46,0xa3,0x97,0x8d}\n};\n\n/*********************** FUNCTION DEFINITIONS ***********************/\n// XORs the in and out buffers, storing the result in out. Length is in bytes.\nvoid xor_buf(const BYTE in[], BYTE out[], size_t len)\n{\n\tsize_t idx;\n\n\tfor (idx = 0; idx < len; idx++)\n\t\tout[idx] ^= in[idx];\n}\n\n/*******************\n* AES - CBC\n*******************/\nint aes_encrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n{\n\tBYTE buf_in[AES_BLOCK_SIZE], buf_out[AES_BLOCK_SIZE], iv_buf[AES_BLOCK_SIZE];\n\tint blocks, idx;\n\n\tif (in_len % AES_BLOCK_SIZE != 0)\n\t\treturn(FALSE);\n\n\tblocks = in_len / AES_BLOCK_SIZE;\n\n\tmemcpy(iv_buf, iv, AES_BLOCK_SIZE);\n\n\tfor (idx = 0; idx < blocks; idx++) {\n\t\tmemcpy(buf_in, &in[idx * AES_BLOCK_SIZE], AES_BLOCK_SIZE);\n\t\txor_buf(iv_buf, buf_in, AES_BLOCK_SIZE);\n\t\taes_encrypt(buf_in, buf_out, key, keysize);\n\t\tmemcpy(&out[idx * AES_BLOCK_SIZE], buf_out, AES_BLOCK_SIZE);\n\t\tmemcpy(iv_buf, buf_out, AES_BLOCK_SIZE);\n\t}\n\n\treturn(TRUE);\n}\n\nint aes_encrypt_cbc_mac(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n{\n\tBYTE buf_in[AES_BLOCK_SIZE], buf_out[AES_BLOCK_SIZE], iv_buf[AES_BLOCK_SIZE];\n\tint blocks, idx;\n\n\tif (in_len % AES_BLOCK_SIZE != 0)\n\t\treturn(FALSE);\n\n\tblocks = in_len / AES_BLOCK_SIZE;\n\n\tmemcpy(iv_buf, iv, AES_BLOCK_SIZE);\n\n\tfor (idx = 0; idx < blocks; idx++) {\n\t\tmemcpy(buf_in, &in[idx * AES_BLOCK_SIZE], AES_BLOCK_SIZE);\n\t\txor_buf(iv_buf, buf_in, AES_BLOCK_SIZE);\n\t\taes_encrypt(buf_in, buf_out, key, keysize);\n\t\tmemcpy(iv_buf, buf_out, AES_BLOCK_SIZE);\n\t\t// Do not output all encrypted blocks.\n\t}\n\n\tmemcpy(out, buf_out, AES_BLOCK_SIZE);   // Only output the last block.\n\n\treturn(TRUE);\n}\n\nint aes_decrypt_cbc(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n{\n\tBYTE buf_in[AES_BLOCK_SIZE], buf_out[AES_BLOCK_SIZE], iv_buf[AES_BLOCK_SIZE];\n\tint blocks, idx;\n\n\tif (in_len % AES_BLOCK_SIZE != 0)\n\t\treturn(FALSE);\n\n\tblocks = in_len / AES_BLOCK_SIZE;\n\n\tmemcpy(iv_buf, iv, AES_BLOCK_SIZE);\n\n\tfor (idx = 0; idx < blocks; idx++) {\n\t\tmemcpy(buf_in, &in[idx * AES_BLOCK_SIZE], AES_BLOCK_SIZE);\n\t\taes_decrypt(buf_in, buf_out, key, keysize);\n\t\txor_buf(iv_buf, buf_out, AES_BLOCK_SIZE);\n\t\tmemcpy(&out[idx * AES_BLOCK_SIZE], buf_out, AES_BLOCK_SIZE);\n\t\tmemcpy(iv_buf, buf_in, AES_BLOCK_SIZE);\n\t}\n\n\treturn(TRUE);\n}\n\n/*******************\n* AES - CTR\n*******************/\nvoid increment_iv(BYTE iv[], int counter_size)\n{\n\tint idx;\n\n\t// Use counter_size bytes at the end of the IV as the big-endian integer to increment.\n\tfor (idx = AES_BLOCK_SIZE - 1; idx >= AES_BLOCK_SIZE - counter_size; idx--) {\n\t\tiv[idx]++;\n\t\tif (iv[idx] != 0 || idx == AES_BLOCK_SIZE - counter_size)\n\t\t\tbreak;\n\t}\n}\n\n// Performs the encryption in-place, the input and output buffers may be the same.\n// Input may be an arbitrary length (in bytes).\nvoid aes_encrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n{\n\tsize_t idx = 0, last_block_length;\n\tBYTE iv_buf[AES_BLOCK_SIZE], out_buf[AES_BLOCK_SIZE];\n\n\tif (in != out)\n\t\tmemcpy(out, in, in_len);\n\n\tmemcpy(iv_buf, iv, AES_BLOCK_SIZE);\n\tlast_block_length = in_len - AES_BLOCK_SIZE;\n\n\tif (in_len > AES_BLOCK_SIZE) {\n\t\tfor (idx = 0; idx < last_block_length; idx += AES_BLOCK_SIZE) {\n\t\t\taes_encrypt(iv_buf, out_buf, key, keysize);\n\t\t\txor_buf(out_buf, &out[idx], AES_BLOCK_SIZE);\n\t\t\tincrement_iv(iv_buf, AES_BLOCK_SIZE);\n\t\t}\n\t}\n\n\taes_encrypt(iv_buf, out_buf, key, keysize);\n\txor_buf(out_buf, &out[idx], in_len - idx);   // Use the Most Significant bytes.\n}\n\nvoid aes_decrypt_ctr(const BYTE in[], size_t in_len, BYTE out[], const WORD key[], int keysize, const BYTE iv[])\n{\n\t// CTR encryption is its own inverse function.\n\taes_encrypt_ctr(in, in_len, out, key, keysize, iv);\n}\n\n/*******************\n* AES - CCM\n*******************/\n// out_len = payload_len + assoc_len\nint aes_encrypt_ccm(const BYTE payload[], WORD payload_len, const BYTE assoc[], unsigned short assoc_len,\n                    const BYTE nonce[], unsigned short nonce_len, BYTE out[], WORD *out_len,\n                    WORD mac_len, const BYTE key_str[], int keysize)\n{\n\tBYTE temp_iv[AES_BLOCK_SIZE], counter[AES_BLOCK_SIZE], mac[16], *buf;\n\tint end_of_buf, payload_len_store_size;\n\tWORD key[60];\n\n\tif (mac_len != 4 && mac_len != 6 && mac_len != 8 && mac_len != 10 &&\n\t   mac_len != 12 && mac_len != 14 && mac_len != 16)\n\t\treturn(FALSE);\n\n\tif (nonce_len < 7 || nonce_len > 13)\n\t\treturn(FALSE);\n\n\tif (assoc_len > 32768 /* = 2^15 */)\n\t\treturn(FALSE);\n\n\tbuf = (BYTE*)malloc(payload_len + assoc_len + 48 /*Round both payload and associated data up a block size and add an extra block.*/);\n\tif (! buf)\n\t\treturn(FALSE);\n\n\t// Prepare the key for usage.\n\taes_key_setup(key_str, key, keysize);\n\n\t// Format the first block of the formatted data.\n\tpayload_len_store_size = AES_BLOCK_SIZE - 1 - nonce_len;\n\tccm_prepare_first_format_blk(buf, assoc_len, payload_len, payload_len_store_size, mac_len, nonce, nonce_len);\n\tend_of_buf = AES_BLOCK_SIZE;\n\n\t// Format the Associated Data, aka, assoc[].\n\tccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len);\n\n\t// Format the Payload, aka payload[].\n\tccm_format_payload_data(buf, &end_of_buf, payload, payload_len);\n\n\t// Create the first counter block.\n\tccm_prepare_first_ctr_blk(counter, nonce, nonce_len, payload_len_store_size);\n\n\t// Perform the CBC operation with an IV of zeros on the formatted buffer to calculate the MAC.\n\tmemset(temp_iv, 0, AES_BLOCK_SIZE);\n\taes_encrypt_cbc_mac(buf, end_of_buf, mac, key, keysize, temp_iv);\n\n\t// Copy the Payload and MAC to the output buffer.\n\tmemcpy(out, payload, payload_len);\n\tmemcpy(&out[payload_len], mac, mac_len);\n\n\t// Encrypt the Payload with CTR mode with a counter starting at 1.\n\tmemcpy(temp_iv, counter, AES_BLOCK_SIZE);\n\tincrement_iv(temp_iv, AES_BLOCK_SIZE - 1 - mac_len);   // Last argument is the byte size of the counting portion of the counter block. /*BUG?*/\n\taes_encrypt_ctr(out, payload_len, out, key, keysize, temp_iv);\n\n\t// Encrypt the MAC with CTR mode with a counter starting at 0.\n\taes_encrypt_ctr(&out[payload_len], mac_len, &out[payload_len], key, keysize, counter);\n\n\tfree(buf);\n\t*out_len = payload_len + mac_len;\n\n\treturn(TRUE);\n}\n\n// plaintext_len = ciphertext_len - mac_len\n// Needs a flag for whether the MAC matches.\nint aes_decrypt_ccm(const BYTE ciphertext[], WORD ciphertext_len, const BYTE assoc[], unsigned short assoc_len,\n                    const BYTE nonce[], unsigned short nonce_len, BYTE plaintext[], WORD *plaintext_len,\n                    WORD mac_len, int *mac_auth, const BYTE key_str[], int keysize)\n{\n\tBYTE temp_iv[AES_BLOCK_SIZE], counter[AES_BLOCK_SIZE], mac[16], mac_buf[16], *buf;\n\tint end_of_buf, plaintext_len_store_size;\n\tWORD key[60];\n\n\tif (ciphertext_len <= mac_len)\n\t\treturn(FALSE);\n\n\tbuf = (BYTE*)malloc(assoc_len + ciphertext_len /*ciphertext_len = plaintext_len + mac_len*/ + 48);\n\tif (! buf)\n\t\treturn(FALSE);\n\n\t// Prepare the key for usage.\n\taes_key_setup(key_str, key, keysize);\n\n\t// Copy the plaintext and MAC to the output buffers.\n\t*plaintext_len = ciphertext_len - mac_len;\n\tplaintext_len_store_size = AES_BLOCK_SIZE - 1 - nonce_len;\n\tmemcpy(plaintext, ciphertext, *plaintext_len);\n\tmemcpy(mac, &ciphertext[*plaintext_len], mac_len);\n\n\t// Prepare the first counter block for use in decryption.\n\tccm_prepare_first_ctr_blk(counter, nonce, nonce_len, plaintext_len_store_size);\n\n\t// Decrypt the Payload with CTR mode with a counter starting at 1.\n\tmemcpy(temp_iv, counter, AES_BLOCK_SIZE);\n\tincrement_iv(temp_iv, AES_BLOCK_SIZE - 1 - mac_len);   // (AES_BLOCK_SIZE - 1 - mac_len) is the byte size of the counting portion of the counter block.\n\taes_decrypt_ctr(plaintext, *plaintext_len, plaintext, key, keysize, temp_iv);\n\n\t// Setting mac_auth to NULL disables the authentication check.\n\tif (mac_auth != NULL) {\n\t\t// Decrypt the MAC with CTR mode with a counter starting at 0.\n\t\taes_decrypt_ctr(mac, mac_len, mac, key, keysize, counter);\n\n\t\t// Format the first block of the formatted data.\n\t\tplaintext_len_store_size = AES_BLOCK_SIZE - 1 - nonce_len;\n\t\tccm_prepare_first_format_blk(buf, assoc_len, *plaintext_len, plaintext_len_store_size, mac_len, nonce, nonce_len);\n\t\tend_of_buf = AES_BLOCK_SIZE;\n\n\t\t// Format the Associated Data into the authentication buffer.\n\t\tccm_format_assoc_data(buf, &end_of_buf, assoc, assoc_len);\n\n\t\t// Format the Payload into the authentication buffer.\n\t\tccm_format_payload_data(buf, &end_of_buf, plaintext, *plaintext_len);\n\n\t\t// Perform the CBC operation with an IV of zeros on the formatted buffer to calculate the MAC.\n\t\tmemset(temp_iv, 0, AES_BLOCK_SIZE);\n\t\taes_encrypt_cbc_mac(buf, end_of_buf, mac_buf, key, keysize, temp_iv);\n\n\t\t// Compare the calculated MAC against the MAC embedded in the ciphertext to see if they are the same.\n\t\tif (! memcmp(mac, mac_buf, mac_len)) {\n\t\t\t*mac_auth = TRUE;\n\t\t}\n\t\telse {\n\t\t\t*mac_auth = FALSE;\n\t\t\tmemset(plaintext, 0, *plaintext_len);\n\t\t}\n\t}\n\n\tfree(buf);\n\n\treturn(TRUE);\n}\n\n// Creates the first counter block. First byte is flags, then the nonce, then the incremented part.\nvoid ccm_prepare_first_ctr_blk(BYTE counter[], const BYTE nonce[], int nonce_len, int payload_len_store_size)\n{\n\tmemset(counter, 0, AES_BLOCK_SIZE);\n\tcounter[0] = (payload_len_store_size - 1) & 0x07;\n\tmemcpy(&counter[1], nonce, nonce_len);\n}\n\nvoid ccm_prepare_first_format_blk(BYTE buf[], int assoc_len, int payload_len, int payload_len_store_size, int mac_len, const BYTE nonce[], int nonce_len)\n{\n\t// Set the flags for the first byte of the first block.\n\tbuf[0] = ((((mac_len - 2) / 2) & 0x07) << 3) | ((payload_len_store_size - 1) & 0x07);\n\tif (assoc_len > 0)\n\t\tbuf[0] += 0x40;\n\t// Format the rest of the first block, storing the nonce and the size of the payload.\n\tmemcpy(&buf[1], nonce, nonce_len);\n\tmemset(&buf[1 + nonce_len], 0, AES_BLOCK_SIZE - 1 - nonce_len);\n\tbuf[15] = payload_len & 0x000000FF;\n\tbuf[14] = (payload_len >> 8) & 0x000000FF;\n}\n\nvoid ccm_format_assoc_data(BYTE buf[], int *end_of_buf, const BYTE assoc[], int assoc_len)\n{\n\tint pad;\n\n\tbuf[*end_of_buf + 1] = assoc_len & 0x00FF;\n\tbuf[*end_of_buf] = (assoc_len >> 8) & 0x00FF;\n\t*end_of_buf += 2;\n\tmemcpy(&buf[*end_of_buf], assoc, assoc_len);\n\t*end_of_buf += assoc_len;\n\tpad = AES_BLOCK_SIZE - (*end_of_buf % AES_BLOCK_SIZE); /*BUG?*/\n\tmemset(&buf[*end_of_buf], 0, pad);\n\t*end_of_buf += pad;\n}\n\nvoid ccm_format_payload_data(BYTE buf[], int *end_of_buf, const BYTE payload[], int payload_len)\n{\n\tint pad;\n\n\tmemcpy(&buf[*end_of_buf], payload, payload_len);\n\t*end_of_buf += payload_len;\n\tpad = *end_of_buf % AES_BLOCK_SIZE;\n\tif (pad != 0)\n\t\tpad = AES_BLOCK_SIZE - pad;\n\tmemset(&buf[*end_of_buf], 0, pad);\n\t*end_of_buf += pad;\n}\n\n/*******************\n* AES\n*******************/\n/////////////////\n// KEY EXPANSION\n/////////////////\n\n// Substitutes a word using the AES S-Box.\nWORD SubWord(WORD word)\n{\n\tunsigned int result;\n\n\tresult = (int)aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F];\n\tresult += (int)aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8;\n\tresult += (int)aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16;\n\tresult += (int)aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24;\n\treturn(result);\n}\n\n// Performs the action of generating the keys that will be used in every round of\n// encryption. \"key\" is the user-supplied input key, \"w\" is the output key schedule,\n// \"keysize\" is the length in bits of \"key\", must be 128, 192, or 256.\nvoid aes_key_setup(const BYTE key[], WORD w[], int keysize)\n{\n\tint Nb=4,Nr,Nk,idx;\n\tWORD temp,Rcon[]={0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,\n\t                  0x40000000,0x80000000,0x1b000000,0x36000000,0x6c000000,0xd8000000,\n\t                  0xab000000,0x4d000000,0x9a000000};\n\n\tswitch (keysize) {\n\t\tcase 128: Nr = 10; Nk = 4; break;\n\t\tcase 192: Nr = 12; Nk = 6; break;\n\t\tcase 256: Nr = 14; Nk = 8; break;\n\t\tdefault: return;\n\t}\n\n\tfor (idx=0; idx < Nk; ++idx) {\n\t\tw[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) |\n\t\t\t\t   ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3]));\n\t}\n\n\tfor (idx = Nk; idx < Nb * (Nr+1); ++idx) {\n\t\ttemp = w[idx - 1];\n\t\tif ((idx % Nk) == 0)\n\t\t\ttemp = SubWord(KE_ROTWORD(temp)) ^ Rcon[(idx-1)/Nk];\n\t\telse if (Nk > 6 && (idx % Nk) == 4)\n\t\t\ttemp = SubWord(temp);\n\t\tw[idx] = w[idx-Nk] ^ temp;\n\t}\n}\n\n/////////////////\n// ADD ROUND KEY\n/////////////////\n\n// Performs the AddRoundKey step. Each round has its own pre-generated 16-byte key in the\n// form of 4 integers (the \"w\" array). Each integer is XOR'd by one column of the state.\n// Also performs the job of InvAddRoundKey(); since the function is a simple XOR process,\n// it is its own inverse.\nvoid AddRoundKey(BYTE state[][4], const WORD w[])\n{\n\tBYTE subkey[4];\n\n\t// memcpy(subkey,&w[idx],4); // Not accurate for big endian machines\n\t// Subkey 1\n\tsubkey[0] = w[0] >> 24;\n\tsubkey[1] = w[0] >> 16;\n\tsubkey[2] = w[0] >> 8;\n\tsubkey[3] = w[0];\n\tstate[0][0] ^= subkey[0];\n\tstate[1][0] ^= subkey[1];\n\tstate[2][0] ^= subkey[2];\n\tstate[3][0] ^= subkey[3];\n\t// Subkey 2\n\tsubkey[0] = w[1] >> 24;\n\tsubkey[1] = w[1] >> 16;\n\tsubkey[2] = w[1] >> 8;\n\tsubkey[3] = w[1];\n\tstate[0][1] ^= subkey[0];\n\tstate[1][1] ^= subkey[1];\n\tstate[2][1] ^= subkey[2];\n\tstate[3][1] ^= subkey[3];\n\t// Subkey 3\n\tsubkey[0] = w[2] >> 24;\n\tsubkey[1] = w[2] >> 16;\n\tsubkey[2] = w[2] >> 8;\n\tsubkey[3] = w[2];\n\tstate[0][2] ^= subkey[0];\n\tstate[1][2] ^= subkey[1];\n\tstate[2][2] ^= subkey[2];\n\tstate[3][2] ^= subkey[3];\n\t// Subkey 4\n\tsubkey[0] = w[3] >> 24;\n\tsubkey[1] = w[3] >> 16;\n\tsubkey[2] = w[3] >> 8;\n\tsubkey[3] = w[3];\n\tstate[0][3] ^= subkey[0];\n\tstate[1][3] ^= subkey[1];\n\tstate[2][3] ^= subkey[2];\n\tstate[3][3] ^= subkey[3];\n}\n\n/////////////////\n// (Inv)SubBytes\n/////////////////\n\n// Performs the SubBytes step. All bytes in the state are substituted with a\n// pre-calculated value from a lookup table.\nvoid SubBytes(BYTE state[][4])\n{\n\tstate[0][0] = aes_sbox[state[0][0] >> 4][state[0][0] & 0x0F];\n\tstate[0][1] = aes_sbox[state[0][1] >> 4][state[0][1] & 0x0F];\n\tstate[0][2] = aes_sbox[state[0][2] >> 4][state[0][2] & 0x0F];\n\tstate[0][3] = aes_sbox[state[0][3] >> 4][state[0][3] & 0x0F];\n\tstate[1][0] = aes_sbox[state[1][0] >> 4][state[1][0] & 0x0F];\n\tstate[1][1] = aes_sbox[state[1][1] >> 4][state[1][1] & 0x0F];\n\tstate[1][2] = aes_sbox[state[1][2] >> 4][state[1][2] & 0x0F];\n\tstate[1][3] = aes_sbox[state[1][3] >> 4][state[1][3] & 0x0F];\n\tstate[2][0] = aes_sbox[state[2][0] >> 4][state[2][0] & 0x0F];\n\tstate[2][1] = aes_sbox[state[2][1] >> 4][state[2][1] & 0x0F];\n\tstate[2][2] = aes_sbox[state[2][2] >> 4][state[2][2] & 0x0F];\n\tstate[2][3] = aes_sbox[state[2][3] >> 4][state[2][3] & 0x0F];\n\tstate[3][0] = aes_sbox[state[3][0] >> 4][state[3][0] & 0x0F];\n\tstate[3][1] = aes_sbox[state[3][1] >> 4][state[3][1] & 0x0F];\n\tstate[3][2] = aes_sbox[state[3][2] >> 4][state[3][2] & 0x0F];\n\tstate[3][3] = aes_sbox[state[3][3] >> 4][state[3][3] & 0x0F];\n}\n\nvoid InvSubBytes(BYTE state[][4])\n{\n\tstate[0][0] = aes_invsbox[state[0][0] >> 4][state[0][0] & 0x0F];\n\tstate[0][1] = aes_invsbox[state[0][1] >> 4][state[0][1] & 0x0F];\n\tstate[0][2] = aes_invsbox[state[0][2] >> 4][state[0][2] & 0x0F];\n\tstate[0][3] = aes_invsbox[state[0][3] >> 4][state[0][3] & 0x0F];\n\tstate[1][0] = aes_invsbox[state[1][0] >> 4][state[1][0] & 0x0F];\n\tstate[1][1] = aes_invsbox[state[1][1] >> 4][state[1][1] & 0x0F];\n\tstate[1][2] = aes_invsbox[state[1][2] >> 4][state[1][2] & 0x0F];\n\tstate[1][3] = aes_invsbox[state[1][3] >> 4][state[1][3] & 0x0F];\n\tstate[2][0] = aes_invsbox[state[2][0] >> 4][state[2][0] & 0x0F];\n\tstate[2][1] = aes_invsbox[state[2][1] >> 4][state[2][1] & 0x0F];\n\tstate[2][2] = aes_invsbox[state[2][2] >> 4][state[2][2] & 0x0F];\n\tstate[2][3] = aes_invsbox[state[2][3] >> 4][state[2][3] & 0x0F];\n\tstate[3][0] = aes_invsbox[state[3][0] >> 4][state[3][0] & 0x0F];\n\tstate[3][1] = aes_invsbox[state[3][1] >> 4][state[3][1] & 0x0F];\n\tstate[3][2] = aes_invsbox[state[3][2] >> 4][state[3][2] & 0x0F];\n\tstate[3][3] = aes_invsbox[state[3][3] >> 4][state[3][3] & 0x0F];\n}\n\n/////////////////\n// (Inv)ShiftRows\n/////////////////\n\n// Performs the ShiftRows step. All rows are shifted cylindrically to the left.\nvoid ShiftRows(BYTE state[][4])\n{\n\tint t;\n\n\t// Shift left by 1\n\tt = state[1][0];\n\tstate[1][0] = state[1][1];\n\tstate[1][1] = state[1][2];\n\tstate[1][2] = state[1][3];\n\tstate[1][3] = t;\n\t// Shift left by 2\n\tt = state[2][0];\n\tstate[2][0] = state[2][2];\n\tstate[2][2] = t;\n\tt = state[2][1];\n\tstate[2][1] = state[2][3];\n\tstate[2][3] = t;\n\t// Shift left by 3\n\tt = state[3][0];\n\tstate[3][0] = state[3][3];\n\tstate[3][3] = state[3][2];\n\tstate[3][2] = state[3][1];\n\tstate[3][1] = t;\n}\n\n// All rows are shifted cylindrically to the right.\nvoid InvShiftRows(BYTE state[][4])\n{\n\tint t;\n\n\t// Shift right by 1\n\tt = state[1][3];\n\tstate[1][3] = state[1][2];\n\tstate[1][2] = state[1][1];\n\tstate[1][1] = state[1][0];\n\tstate[1][0] = t;\n\t// Shift right by 2\n\tt = state[2][3];\n\tstate[2][3] = state[2][1];\n\tstate[2][1] = t;\n\tt = state[2][2];\n\tstate[2][2] = state[2][0];\n\tstate[2][0] = t;\n\t// Shift right by 3\n\tt = state[3][3];\n\tstate[3][3] = state[3][0];\n\tstate[3][0] = state[3][1];\n\tstate[3][1] = state[3][2];\n\tstate[3][2] = t;\n}\n\n/////////////////\n// (Inv)MixColumns\n/////////////////\n\n// Performs the MixColums step. The state is multiplied by itself using matrix\n// multiplication in a Galios Field 2^8. All multiplication is pre-computed in a table.\n// Addition is equivilent to XOR. (Must always make a copy of the column as the original\n// values will be destoyed.)\nvoid MixColumns(BYTE state[][4])\n{\n\tBYTE col[4];\n\n\t// Column 1\n\tcol[0] = state[0][0];\n\tcol[1] = state[1][0];\n\tcol[2] = state[2][0];\n\tcol[3] = state[3][0];\n\tstate[0][0] = gf_mul[col[0]][0];\n\tstate[0][0] ^= gf_mul[col[1]][1];\n\tstate[0][0] ^= col[2];\n\tstate[0][0] ^= col[3];\n\tstate[1][0] = col[0];\n\tstate[1][0] ^= gf_mul[col[1]][0];\n\tstate[1][0] ^= gf_mul[col[2]][1];\n\tstate[1][0] ^= col[3];\n\tstate[2][0] = col[0];\n\tstate[2][0] ^= col[1];\n\tstate[2][0] ^= gf_mul[col[2]][0];\n\tstate[2][0] ^= gf_mul[col[3]][1];\n\tstate[3][0] = gf_mul[col[0]][1];\n\tstate[3][0] ^= col[1];\n\tstate[3][0] ^= col[2];\n\tstate[3][0] ^= gf_mul[col[3]][0];\n\t// Column 2\n\tcol[0] = state[0][1];\n\tcol[1] = state[1][1];\n\tcol[2] = state[2][1];\n\tcol[3] = state[3][1];\n\tstate[0][1] = gf_mul[col[0]][0];\n\tstate[0][1] ^= gf_mul[col[1]][1];\n\tstate[0][1] ^= col[2];\n\tstate[0][1] ^= col[3];\n\tstate[1][1] = col[0];\n\tstate[1][1] ^= gf_mul[col[1]][0];\n\tstate[1][1] ^= gf_mul[col[2]][1];\n\tstate[1][1] ^= col[3];\n\tstate[2][1] = col[0];\n\tstate[2][1] ^= col[1];\n\tstate[2][1] ^= gf_mul[col[2]][0];\n\tstate[2][1] ^= gf_mul[col[3]][1];\n\tstate[3][1] = gf_mul[col[0]][1];\n\tstate[3][1] ^= col[1];\n\tstate[3][1] ^= col[2];\n\tstate[3][1] ^= gf_mul[col[3]][0];\n\t// Column 3\n\tcol[0] = state[0][2];\n\tcol[1] = state[1][2];\n\tcol[2] = state[2][2];\n\tcol[3] = state[3][2];\n\tstate[0][2] = gf_mul[col[0]][0];\n\tstate[0][2] ^= gf_mul[col[1]][1];\n\tstate[0][2] ^= col[2];\n\tstate[0][2] ^= col[3];\n\tstate[1][2] = col[0];\n\tstate[1][2] ^= gf_mul[col[1]][0];\n\tstate[1][2] ^= gf_mul[col[2]][1];\n\tstate[1][2] ^= col[3];\n\tstate[2][2] = col[0];\n\tstate[2][2] ^= col[1];\n\tstate[2][2] ^= gf_mul[col[2]][0];\n\tstate[2][2] ^= gf_mul[col[3]][1];\n\tstate[3][2] = gf_mul[col[0]][1];\n\tstate[3][2] ^= col[1];\n\tstate[3][2] ^= col[2];\n\tstate[3][2] ^= gf_mul[col[3]][0];\n\t// Column 4\n\tcol[0] = state[0][3];\n\tcol[1] = state[1][3];\n\tcol[2] = state[2][3];\n\tcol[3] = state[3][3];\n\tstate[0][3] = gf_mul[col[0]][0];\n\tstate[0][3] ^= gf_mul[col[1]][1];\n\tstate[0][3] ^= col[2];\n\tstate[0][3] ^= col[3];\n\tstate[1][3] = col[0];\n\tstate[1][3] ^= gf_mul[col[1]][0];\n\tstate[1][3] ^= gf_mul[col[2]][1];\n\tstate[1][3] ^= col[3];\n\tstate[2][3] = col[0];\n\tstate[2][3] ^= col[1];\n\tstate[2][3] ^= gf_mul[col[2]][0];\n\tstate[2][3] ^= gf_mul[col[3]][1];\n\tstate[3][3] = gf_mul[col[0]][1];\n\tstate[3][3] ^= col[1];\n\tstate[3][3] ^= col[2];\n\tstate[3][3] ^= gf_mul[col[3]][0];\n}\n\nvoid InvMixColumns(BYTE state[][4])\n{\n\tBYTE col[4];\n\n\t// Column 1\n\tcol[0] = state[0][0];\n\tcol[1] = state[1][0];\n\tcol[2] = state[2][0];\n\tcol[3] = state[3][0];\n\tstate[0][0] = gf_mul[col[0]][5];\n\tstate[0][0] ^= gf_mul[col[1]][3];\n\tstate[0][0] ^= gf_mul[col[2]][4];\n\tstate[0][0] ^= gf_mul[col[3]][2];\n\tstate[1][0] = gf_mul[col[0]][2];\n\tstate[1][0] ^= gf_mul[col[1]][5];\n\tstate[1][0] ^= gf_mul[col[2]][3];\n\tstate[1][0] ^= gf_mul[col[3]][4];\n\tstate[2][0] = gf_mul[col[0]][4];\n\tstate[2][0] ^= gf_mul[col[1]][2];\n\tstate[2][0] ^= gf_mul[col[2]][5];\n\tstate[2][0] ^= gf_mul[col[3]][3];\n\tstate[3][0] = gf_mul[col[0]][3];\n\tstate[3][0] ^= gf_mul[col[1]][4];\n\tstate[3][0] ^= gf_mul[col[2]][2];\n\tstate[3][0] ^= gf_mul[col[3]][5];\n\t// Column 2\n\tcol[0] = state[0][1];\n\tcol[1] = state[1][1];\n\tcol[2] = state[2][1];\n\tcol[3] = state[3][1];\n\tstate[0][1] = gf_mul[col[0]][5];\n\tstate[0][1] ^= gf_mul[col[1]][3];\n\tstate[0][1] ^= gf_mul[col[2]][4];\n\tstate[0][1] ^= gf_mul[col[3]][2];\n\tstate[1][1] = gf_mul[col[0]][2];\n\tstate[1][1] ^= gf_mul[col[1]][5];\n\tstate[1][1] ^= gf_mul[col[2]][3];\n\tstate[1][1] ^= gf_mul[col[3]][4];\n\tstate[2][1] = gf_mul[col[0]][4];\n\tstate[2][1] ^= gf_mul[col[1]][2];\n\tstate[2][1] ^= gf_mul[col[2]][5];\n\tstate[2][1] ^= gf_mul[col[3]][3];\n\tstate[3][1] = gf_mul[col[0]][3];\n\tstate[3][1] ^= gf_mul[col[1]][4];\n\tstate[3][1] ^= gf_mul[col[2]][2];\n\tstate[3][1] ^= gf_mul[col[3]][5];\n\t// Column 3\n\tcol[0] = state[0][2];\n\tcol[1] = state[1][2];\n\tcol[2] = state[2][2];\n\tcol[3] = state[3][2];\n\tstate[0][2] = gf_mul[col[0]][5];\n\tstate[0][2] ^= gf_mul[col[1]][3];\n\tstate[0][2] ^= gf_mul[col[2]][4];\n\tstate[0][2] ^= gf_mul[col[3]][2];\n\tstate[1][2] = gf_mul[col[0]][2];\n\tstate[1][2] ^= gf_mul[col[1]][5];\n\tstate[1][2] ^= gf_mul[col[2]][3];\n\tstate[1][2] ^= gf_mul[col[3]][4];\n\tstate[2][2] = gf_mul[col[0]][4];\n\tstate[2][2] ^= gf_mul[col[1]][2];\n\tstate[2][2] ^= gf_mul[col[2]][5];\n\tstate[2][2] ^= gf_mul[col[3]][3];\n\tstate[3][2] = gf_mul[col[0]][3];\n\tstate[3][2] ^= gf_mul[col[1]][4];\n\tstate[3][2] ^= gf_mul[col[2]][2];\n\tstate[3][2] ^= gf_mul[col[3]][5];\n\t// Column 4\n\tcol[0] = state[0][3];\n\tcol[1] = state[1][3];\n\tcol[2] = state[2][3];\n\tcol[3] = state[3][3];\n\tstate[0][3] = gf_mul[col[0]][5];\n\tstate[0][3] ^= gf_mul[col[1]][3];\n\tstate[0][3] ^= gf_mul[col[2]][4];\n\tstate[0][3] ^= gf_mul[col[3]][2];\n\tstate[1][3] = gf_mul[col[0]][2];\n\tstate[1][3] ^= gf_mul[col[1]][5];\n\tstate[1][3] ^= gf_mul[col[2]][3];\n\tstate[1][3] ^= gf_mul[col[3]][4];\n\tstate[2][3] = gf_mul[col[0]][4];\n\tstate[2][3] ^= gf_mul[col[1]][2];\n\tstate[2][3] ^= gf_mul[col[2]][5];\n\tstate[2][3] ^= gf_mul[col[3]][3];\n\tstate[3][3] = gf_mul[col[0]][3];\n\tstate[3][3] ^= gf_mul[col[1]][4];\n\tstate[3][3] ^= gf_mul[col[2]][2];\n\tstate[3][3] ^= gf_mul[col[3]][5];\n}\n\n/////////////////\n// (En/De)Crypt\n/////////////////\n\nvoid aes_encrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize)\n{\n\tBYTE state[4][4];\n\n\t// Copy input array (should be 16 bytes long) to a matrix (sequential bytes are ordered\n\t// by row, not col) called \"state\" for processing.\n\t// *** Implementation note: The official AES documentation references the state by\n\t// column, then row. Accessing an element in C requires row then column. Thus, all state\n\t// references in AES must have the column and row indexes reversed for C implementation.\n\tstate[0][0] = in[0];\n\tstate[1][0] = in[1];\n\tstate[2][0] = in[2];\n\tstate[3][0] = in[3];\n\tstate[0][1] = in[4];\n\tstate[1][1] = in[5];\n\tstate[2][1] = in[6];\n\tstate[3][1] = in[7];\n\tstate[0][2] = in[8];\n\tstate[1][2] = in[9];\n\tstate[2][2] = in[10];\n\tstate[3][2] = in[11];\n\tstate[0][3] = in[12];\n\tstate[1][3] = in[13];\n\tstate[2][3] = in[14];\n\tstate[3][3] = in[15];\n\n\t// Perform the necessary number of rounds. The round key is added first.\n\t// The last round does not perform the MixColumns step.\n\tAddRoundKey(state,&key[0]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[4]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[8]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[12]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[16]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[20]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[24]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[28]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[32]);\n\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[36]);\n\tif (keysize != 128) {\n\t\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[40]);\n\t\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[44]);\n\t\tif (keysize != 192) {\n\t\t\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[48]);\n\t\t\tSubBytes(state); ShiftRows(state); MixColumns(state); AddRoundKey(state,&key[52]);\n\t\t\tSubBytes(state); ShiftRows(state); AddRoundKey(state,&key[56]);\n\t\t}\n\t\telse {\n\t\t\tSubBytes(state); ShiftRows(state); AddRoundKey(state,&key[48]);\n\t\t}\n\t}\n\telse {\n\t\tSubBytes(state); ShiftRows(state); AddRoundKey(state,&key[40]);\n\t}\n\n\t// Copy the state to the output array.\n\tout[0] = state[0][0];\n\tout[1] = state[1][0];\n\tout[2] = state[2][0];\n\tout[3] = state[3][0];\n\tout[4] = state[0][1];\n\tout[5] = state[1][1];\n\tout[6] = state[2][1];\n\tout[7] = state[3][1];\n\tout[8] = state[0][2];\n\tout[9] = state[1][2];\n\tout[10] = state[2][2];\n\tout[11] = state[3][2];\n\tout[12] = state[0][3];\n\tout[13] = state[1][3];\n\tout[14] = state[2][3];\n\tout[15] = state[3][3];\n}\n\nvoid aes_decrypt(const BYTE in[], BYTE out[], const WORD key[], int keysize)\n{\n\tBYTE state[4][4];\n\n\t// Copy the input to the state.\n\tstate[0][0] = in[0];\n\tstate[1][0] = in[1];\n\tstate[2][0] = in[2];\n\tstate[3][0] = in[3];\n\tstate[0][1] = in[4];\n\tstate[1][1] = in[5];\n\tstate[2][1] = in[6];\n\tstate[3][1] = in[7];\n\tstate[0][2] = in[8];\n\tstate[1][2] = in[9];\n\tstate[2][2] = in[10];\n\tstate[3][2] = in[11];\n\tstate[0][3] = in[12];\n\tstate[1][3] = in[13];\n\tstate[2][3] = in[14];\n\tstate[3][3] = in[15];\n\n\t// Perform the necessary number of rounds. The round key is added first.\n\t// The last round does not perform the MixColumns step.\n\tif (keysize > 128) {\n\t\tif (keysize > 192) {\n\t\t\tAddRoundKey(state,&key[56]);\n\t\t\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[52]);InvMixColumns(state);\n\t\t\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[48]);InvMixColumns(state);\n\t\t}\n\t\telse {\n\t\t\tAddRoundKey(state,&key[48]);\n\t\t}\n\t\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[44]);InvMixColumns(state);\n\t\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[40]);InvMixColumns(state);\n\t}\n\telse {\n\t\tAddRoundKey(state,&key[40]);\n\t}\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[36]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[32]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[28]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[24]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[20]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[16]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[12]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[8]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[4]);InvMixColumns(state);\n\tInvShiftRows(state);InvSubBytes(state);AddRoundKey(state,&key[0]);\n\n\t// Copy the state to the output array.\n\tout[0] = state[0][0];\n\tout[1] = state[1][0];\n\tout[2] = state[2][0];\n\tout[3] = state[3][0];\n\tout[4] = state[0][1];\n\tout[5] = state[1][1];\n\tout[6] = state[2][1];\n\tout[7] = state[3][1];\n\tout[8] = state[0][2];\n\tout[9] = state[1][2];\n\tout[10] = state[2][2];\n\tout[11] = state[3][2];\n\tout[12] = state[0][3];\n\tout[13] = state[1][3];\n\tout[14] = state[2][3];\n\tout[15] = state[3][3];\n}\n\n/*******************\n** AES DEBUGGING FUNCTIONS\n*******************/\n/*\n// This prints the \"state\" grid as a linear hex string.\nvoid print_state(BYTE state[][4])\n{\n\tint idx,idx2;\n\n\tfor (idx=0; idx < 4; idx++)\n\t\tfor (idx2=0; idx2 < 4; idx2++)\n\t\t\tprintf(\"%02x\",state[idx2][idx]);\n\tprintf(\"\\n\");\n}\n\n// This prints the key (4 consecutive ints) used for a given round as a linear hex string.\nvoid print_rnd_key(WORD key[])\n{\n\tint idx;\n\n\tfor (idx=0; idx < 4; idx++)\n\t\tprintf(\"%08x\",key[idx]);\n\tprintf(\"\\n\");\n}\n*/\n"
        },
        {
          "name": "aes.h",
          "type": "blob",
          "size": 7.4111328125,
          "content": "/*********************************************************************\r\n* Filename:   aes.h\r\n* Author:     Brad Conte (brad AT bradconte.com)\r\n* Copyright:\r\n* Disclaimer: This code is presented \"as is\" without any guarantees.\r\n* Details:    Defines the API for the corresponding AES implementation.\r\n*********************************************************************/\r\n\r\n#ifndef AES_H\r\n#define AES_H\r\n\r\n/*************************** HEADER FILES ***************************/\r\n#include <stddef.h>\r\n\r\n/****************************** MACROS ******************************/\r\n#define AES_BLOCK_SIZE 16               // AES operates on 16 bytes at a time\r\n\r\n/**************************** DATA TYPES ****************************/\r\ntypedef unsigned char BYTE;            // 8-bit byte\r\ntypedef unsigned int WORD;             // 32-bit word, change to \"long\" for 16-bit machines\r\n\r\n/*********************** FUNCTION DECLARATIONS **********************/\r\n///////////////////\r\n// AES\r\n///////////////////\r\n// Key setup must be done before any AES en/de-cryption functions can be used.\r\nvoid aes_key_setup(const BYTE key[],          // The key, must be 128, 192, or 256 bits\r\n                   WORD w[],                  // Output key schedule to be used later\r\n                   int keysize);              // Bit length of the key, 128, 192, or 256\r\n\r\nvoid aes_encrypt(const BYTE in[],             // 16 bytes of plaintext\r\n                 BYTE out[],                  // 16 bytes of ciphertext\r\n                 const WORD key[],            // From the key setup\r\n                 int keysize);                // Bit length of the key, 128, 192, or 256\r\n\r\nvoid aes_decrypt(const BYTE in[],             // 16 bytes of ciphertext\r\n                 BYTE out[],                  // 16 bytes of plaintext\r\n                 const WORD key[],            // From the key setup\r\n                 int keysize);                // Bit length of the key, 128, 192, or 256\r\n\r\n///////////////////\r\n// AES - CBC\r\n///////////////////\r\nint aes_encrypt_cbc(const BYTE in[],          // Plaintext\r\n                    size_t in_len,            // Must be a multiple of AES_BLOCK_SIZE\r\n                    BYTE out[],               // Ciphertext, same length as plaintext\r\n                    const WORD key[],         // From the key setup\r\n                    int keysize,              // Bit length of the key, 128, 192, or 256\r\n                    const BYTE iv[]);         // IV, must be AES_BLOCK_SIZE bytes long\r\n\r\n// Only output the CBC-MAC of the input.\r\nint aes_encrypt_cbc_mac(const BYTE in[],      // plaintext\r\n                        size_t in_len,        // Must be a multiple of AES_BLOCK_SIZE\r\n                        BYTE out[],           // Output MAC\r\n                        const WORD key[],     // From the key setup\r\n                        int keysize,          // Bit length of the key, 128, 192, or 256\r\n                        const BYTE iv[]);     // IV, must be AES_BLOCK_SIZE bytes long\r\n\r\n///////////////////\r\n// AES - CTR\r\n///////////////////\r\nvoid increment_iv(BYTE iv[],                  // Must be a multiple of AES_BLOCK_SIZE\r\n                  int counter_size);          // Bytes of the IV used for counting (low end)\r\n\r\nvoid aes_encrypt_ctr(const BYTE in[],         // Plaintext\r\n                     size_t in_len,           // Any byte length\r\n                     BYTE out[],              // Ciphertext, same length as plaintext\r\n                     const WORD key[],        // From the key setup\r\n                     int keysize,             // Bit length of the key, 128, 192, or 256\r\n                     const BYTE iv[]);        // IV, must be AES_BLOCK_SIZE bytes long\r\n\r\nvoid aes_decrypt_ctr(const BYTE in[],         // Ciphertext\r\n                     size_t in_len,           // Any byte length\r\n                     BYTE out[],              // Plaintext, same length as ciphertext\r\n                     const WORD key[],        // From the key setup\r\n                     int keysize,             // Bit length of the key, 128, 192, or 256\r\n                     const BYTE iv[]);        // IV, must be AES_BLOCK_SIZE bytes long\r\n\r\n///////////////////\r\n// AES - CCM\r\n///////////////////\r\n// Returns True if the input parameters do not violate any constraint.\r\nint aes_encrypt_ccm(const BYTE plaintext[],              // IN  - Plaintext.\r\n                    WORD plaintext_len,                  // IN  - Plaintext length.\r\n                    const BYTE associated_data[],        // IN  - Associated Data included in authentication, but not encryption.\r\n                    unsigned short associated_data_len,  // IN  - Associated Data length in bytes.\r\n                    const BYTE nonce[],                  // IN  - The Nonce to be used for encryption.\r\n                    unsigned short nonce_len,            // IN  - Nonce length in bytes.\r\n                    BYTE ciphertext[],                   // OUT - Ciphertext, a concatination of the plaintext and the MAC.\r\n                    WORD *ciphertext_len,                // OUT - The length of the ciphertext, always plaintext_len + mac_len.\r\n                    WORD mac_len,                        // IN  - The desired length of the MAC, must be 4, 6, 8, 10, 12, 14, or 16.\r\n                    const BYTE key[],                    // IN  - The AES key for encryption.\r\n                    int keysize);                        // IN  - The length of the key in bits. Valid values are 128, 192, 256.\r\n\r\n// Returns True if the input parameters do not violate any constraint.\r\n// Use mac_auth to ensure decryption/validation was preformed correctly.\r\n// If authentication does not succeed, the plaintext is zeroed out. To overwride\r\n// this, call with mac_auth = NULL. The proper proceedure is to decrypt with\r\n// authentication enabled (mac_auth != NULL) and make a second call to that\r\n// ignores authentication explicitly if the first call failes.\r\nint aes_decrypt_ccm(const BYTE ciphertext[],             // IN  - Ciphertext, the concatination of encrypted plaintext and MAC.\r\n                    WORD ciphertext_len,                 // IN  - Ciphertext length in bytes.\r\n                    const BYTE assoc[],                  // IN  - The Associated Data, required for authentication.\r\n                    unsigned short assoc_len,            // IN  - Associated Data length in bytes.\r\n                    const BYTE nonce[],                  // IN  - The Nonce to use for decryption, same one as for encryption.\r\n                    unsigned short nonce_len,            // IN  - Nonce length in bytes.\r\n                    BYTE plaintext[],                    // OUT - The plaintext that was decrypted. Will need to be large enough to hold ciphertext_len - mac_len.\r\n                    WORD *plaintext_len,                 // OUT - Length in bytes of the output plaintext, always ciphertext_len - mac_len .\r\n                    WORD mac_len,                        // IN  - The length of the MAC that was calculated.\r\n                    int *mac_auth,                       // OUT - TRUE if authentication succeeded, FALSE if it did not. NULL pointer will ignore the authentication.\r\n                    const BYTE key[],                    // IN  - The AES key for decryption.\r\n                    int keysize);                        // IN  - The length of the key in BITS. Valid values are 128, 192, 256.\r\n\r\n///////////////////\r\n// Test functions\r\n///////////////////\r\nint aes_test();\r\nint aes_ecb_test();\r\nint aes_cbc_test();\r\nint aes_ctr_test();\r\nint aes_ccm_test();\r\n\r\n#endif   // AES_H\r\n"
        },
        {
          "name": "aes_test.c",
          "type": "blob",
          "size": 9.7470703125,
          "content": "/*********************************************************************\r\n* Filename:   aes_test.c\r\n* Author:     Brad Conte (brad AT bradconte.com)\r\n* Copyright:\r\n* Disclaimer: This code is presented \"as is\" without any guarantees.\r\n* Details:    Performs known-answer tests on the corresponding AES\r\n              implementation. These tests do not encompass the full\r\n              range of available test vectors and are not sufficient\r\n              for FIPS-140 certification. However, if the tests pass\r\n              it is very, very likely that the code is correct and was\r\n              compiled properly. This code also serves as\r\n\t          example usage of the functions.\r\n*********************************************************************/\r\n\r\n/*************************** HEADER FILES ***************************/\r\n#include <stdio.h>\r\n#include <memory.h>\r\n#include \"aes.h\"\r\n\r\n/*********************** FUNCTION DEFINITIONS ***********************/\r\nvoid print_hex(BYTE str[], int len)\r\n{\r\n\tint idx;\r\n\r\n\tfor(idx = 0; idx < len; idx++)\r\n\t\tprintf(\"%02x\", str[idx]);\r\n}\r\n\r\nint aes_ecb_test()\r\n{\r\n\tWORD key_schedule[60], idx;\r\n\tBYTE enc_buf[128];\r\n\tBYTE plaintext[2][16] = {\r\n\t\t{0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},\r\n\t\t{0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51}\r\n\t};\r\n\tBYTE ciphertext[2][16] = {\r\n\t\t{0xf3,0xee,0xd1,0xbd,0xb5,0xd2,0xa0,0x3c,0x06,0x4b,0x5a,0x7e,0x3d,0xb1,0x81,0xf8},\r\n\t\t{0x59,0x1c,0xcb,0x10,0xd4,0x10,0xed,0x26,0xdc,0x5b,0xa7,0x4a,0x31,0x36,0x28,0x70}\r\n\t};\r\n\tBYTE key[1][32] = {\r\n\t\t{0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4}\r\n\t};\r\n\tint pass = 1;\r\n\r\n\t// Raw ECB mode.\r\n\t//printf(\"* ECB mode:\\n\");\r\n\taes_key_setup(key[0], key_schedule, 256);\r\n\t//printf(  \"Key          : \");\r\n\t//print_hex(key[0], 32);\r\n\r\n\tfor(idx = 0; idx < 2; idx++) {\r\n\t\taes_encrypt(plaintext[idx], enc_buf, key_schedule, 256);\r\n\t\t//printf(\"\\nPlaintext    : \");\r\n\t\t//print_hex(plaintext[idx], 16);\r\n\t\t//printf(\"\\n-encrypted to: \");\r\n\t\t//print_hex(enc_buf, 16);\r\n\t\tpass = pass && !memcmp(enc_buf, ciphertext[idx], 16);\r\n\r\n\t\taes_decrypt(ciphertext[idx], enc_buf, key_schedule, 256);\r\n\t\t//printf(\"\\nCiphertext   : \");\r\n\t\t//print_hex(ciphertext[idx], 16);\r\n\t\t//printf(\"\\n-decrypted to: \");\r\n\t\t//print_hex(enc_buf, 16);\r\n\t\tpass = pass && !memcmp(enc_buf, plaintext[idx], 16);\r\n\r\n\t\t//printf(\"\\n\\n\");\r\n\t}\r\n\r\n\treturn(pass);\r\n}\r\n\r\nint aes_cbc_test()\r\n{\r\n\tWORD key_schedule[60];\r\n\tBYTE enc_buf[128];\r\n\tBYTE plaintext[1][32] = {\r\n\t\t{0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51}\r\n\t};\r\n\tBYTE ciphertext[1][32] = {\r\n\t\t{0xf5,0x8c,0x4c,0x04,0xd6,0xe5,0xf1,0xba,0x77,0x9e,0xab,0xfb,0x5f,0x7b,0xfb,0xd6,0x9c,0xfc,0x4e,0x96,0x7e,0xdb,0x80,0x8d,0x67,0x9f,0x77,0x7b,0xc6,0x70,0x2c,0x7d}\r\n\t};\r\n\tBYTE iv[1][16] = {\r\n\t\t{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f}\r\n\t};\r\n\tBYTE key[1][32] = {\r\n\t\t{0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4}\r\n\t};\r\n\tint pass = 1;\r\n\r\n\t//printf(\"* CBC mode:\\n\");\r\n\taes_key_setup(key[0], key_schedule, 256);\r\n\r\n\t//printf(  \"Key          : \");\r\n\t//print_hex(key[0], 32);\r\n\t//printf(\"\\nIV           : \");\r\n\t//print_hex(iv[0], 16);\r\n\r\n\taes_encrypt_cbc(plaintext[0], 32, enc_buf, key_schedule, 256, iv[0]);\r\n\t//printf(\"\\nPlaintext    : \");\r\n\t//print_hex(plaintext[0], 32);\r\n\t//printf(\"\\n-encrypted to: \");\r\n\t//print_hex(enc_buf, 32);\r\n\t//printf(\"\\nCiphertext   : \");\r\n\t//print_hex(ciphertext[0], 32);\r\n\tpass = pass && !memcmp(enc_buf, ciphertext[0], 32);\r\n\r\n\taes_decrypt_cbc(ciphertext[0], 32, enc_buf, key_schedule, 256, iv[0]);\r\n\t//printf(\"\\nCiphertext   : \");\r\n\t//print_hex(ciphertext[0], 32);\r\n\t//printf(\"\\n-decrypted to: \");\r\n\t//print_hex(enc_buf, 32);\r\n\t//printf(\"\\nPlaintext   : \");\r\n\t//print_hex(plaintext[0], 32);\r\n\tpass = pass && !memcmp(enc_buf, plaintext[0], 32);\r\n\r\n\t//printf(\"\\n\\n\");\r\n\treturn(pass);\r\n}\r\n\r\nint aes_ctr_test()\r\n{\r\n\tWORD key_schedule[60];\r\n\tBYTE enc_buf[128];\r\n\tBYTE plaintext[1][32] = {\r\n\t\t{0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51}\r\n\t};\r\n\tBYTE ciphertext[1][32] = {\r\n\t\t{0x60,0x1e,0xc3,0x13,0x77,0x57,0x89,0xa5,0xb7,0xa7,0xf5,0x04,0xbb,0xf3,0xd2,0x28,0xf4,0x43,0xe3,0xca,0x4d,0x62,0xb5,0x9a,0xca,0x84,0xe9,0x90,0xca,0xca,0xf5,0xc5}\r\n\t};\r\n\tBYTE iv[1][16] = {\r\n\t\t{0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff},\r\n\t};\r\n\tBYTE key[1][32] = {\r\n\t\t{0x60,0x3d,0xeb,0x10,0x15,0xca,0x71,0xbe,0x2b,0x73,0xae,0xf0,0x85,0x7d,0x77,0x81,0x1f,0x35,0x2c,0x07,0x3b,0x61,0x08,0xd7,0x2d,0x98,0x10,0xa3,0x09,0x14,0xdf,0xf4}\r\n\t};\r\n\tint pass = 1;\r\n\r\n\t//printf(\"* CTR mode:\\n\");\r\n\taes_key_setup(key[0], key_schedule, 256);\r\n\r\n\t//printf(  \"Key          : \");\r\n\t//print_hex(key[0], 32);\r\n\t//printf(\"\\nIV           : \");\r\n\t//print_hex(iv[0], 16);\r\n\r\n\taes_encrypt_ctr(plaintext[0], 32, enc_buf, key_schedule, 256, iv[0]);\r\n\t//printf(\"\\nPlaintext    : \");\r\n\t//print_hex(plaintext[0], 32);\r\n\t//printf(\"\\n-encrypted to: \");\r\n\t//print_hex(enc_buf, 32);\r\n\tpass = pass && !memcmp(enc_buf, ciphertext[0], 32);\r\n\r\n\taes_decrypt_ctr(ciphertext[0], 32, enc_buf, key_schedule, 256, iv[0]);\r\n\t//printf(\"\\nCiphertext   : \");\r\n\t//print_hex(ciphertext[0], 32);\r\n\t//printf(\"\\n-decrypted to: \");\r\n\t//print_hex(enc_buf, 32);\r\n\tpass = pass && !memcmp(enc_buf, plaintext[0], 32);\r\n\r\n\t//printf(\"\\n\\n\");\r\n\treturn(pass);\r\n}\r\n\r\nint aes_ccm_test()\r\n{\r\n\tint mac_auth;\r\n\tWORD enc_buf_len;\r\n\tBYTE enc_buf[128];\r\n\tBYTE plaintext[3][32] = {\r\n\t\t{0x20,0x21,0x22,0x23},\r\n\t\t{0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f},\r\n\t\t{0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37}\r\n\t};\r\n\tBYTE assoc[3][32] = {\r\n\t\t{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07},\r\n\t\t{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},\r\n\t\t{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13}\r\n\t};\r\n\tBYTE ciphertext[3][32 + 16] = {\r\n\t\t{0x71,0x62,0x01,0x5b,0x4d,0xac,0x25,0x5d},\r\n\t\t{0xd2,0xa1,0xf0,0xe0,0x51,0xea,0x5f,0x62,0x08,0x1a,0x77,0x92,0x07,0x3d,0x59,0x3d,0x1f,0xc6,0x4f,0xbf,0xac,0xcd},\r\n\t\t{0xe3,0xb2,0x01,0xa9,0xf5,0xb7,0x1a,0x7a,0x9b,0x1c,0xea,0xec,0xcd,0x97,0xe7,0x0b,0x61,0x76,0xaa,0xd9,0xa4,0x42,0x8a,0xa5,0x48,0x43,0x92,0xfb,0xc1,0xb0,0x99,0x51}\r\n\t};\r\n\tBYTE iv[3][16] = {\r\n\t\t{0x10,0x11,0x12,0x13,0x14,0x15,0x16},\r\n\t\t{0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17},\r\n\t\t{0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b}\r\n\t};\r\n\tBYTE key[1][32] = {\r\n\t\t{0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f}\r\n\t};\r\n\tint pass = 1;\r\n\r\n\t//printf(\"* CCM mode:\\n\");\r\n\t//printf(\"Key           : \");\r\n\t//print_hex(key[0], 16);\r\n\r\n\t//print_hex(plaintext[0], 4);\r\n\t//print_hex(assoc[0], 8);\r\n\t//print_hex(ciphertext[0], 8);\r\n\t//print_hex(iv[0], 7);\r\n\t//print_hex(key[0], 16);\r\n\r\n\taes_encrypt_ccm(plaintext[0], 4, assoc[0], 8, iv[0], 7, enc_buf, &enc_buf_len, 4, key[0], 128);\r\n\t//printf(\"\\nNONCE        : \");\r\n\t//print_hex(iv[0], 7);\r\n\t//printf(\"\\nAssoc. Data  : \");\r\n\t//print_hex(assoc[0], 8);\r\n\t//printf(\"\\nPayload       : \");\r\n\t//print_hex(plaintext[0], 4);\r\n\t//printf(\"\\n-encrypted to: \");\r\n\t//print_hex(enc_buf, enc_buf_len);\r\n\tpass = pass && !memcmp(enc_buf, ciphertext[0], enc_buf_len);\r\n\r\n\taes_decrypt_ccm(ciphertext[0], 8, assoc[0], 8, iv[0], 7, enc_buf, &enc_buf_len, 4, &mac_auth, key[0], 128);\r\n\t//printf(\"\\n-Ciphertext  : \");\r\n\t//print_hex(ciphertext[0], 8);\r\n\t//printf(\"\\n-decrypted to: \");\r\n\t//print_hex(enc_buf, enc_buf_len);\r\n\t//printf(\"\\nAuthenticated: %d \", mac_auth);\r\n\tpass = pass && !memcmp(enc_buf, plaintext[0], enc_buf_len) && mac_auth;\r\n\r\n\r\n\taes_encrypt_ccm(plaintext[1], 16, assoc[1], 16, iv[1], 8, enc_buf, &enc_buf_len, 6, key[0], 128);\r\n\t//printf(\"\\n\\nNONCE        : \");\r\n\t//print_hex(iv[1], 8);\r\n\t//printf(\"\\nAssoc. Data  : \");\r\n\t//print_hex(assoc[1], 16);\r\n\t//printf(\"\\nPayload      : \");\r\n\t//print_hex(plaintext[1], 16);\r\n\t//printf(\"\\n-encrypted to: \");\r\n\t//print_hex(enc_buf, enc_buf_len);\r\n\tpass = pass && !memcmp(enc_buf, ciphertext[1], enc_buf_len);\r\n\r\n\taes_decrypt_ccm(ciphertext[1], 22, assoc[1], 16, iv[1], 8, enc_buf, &enc_buf_len, 6, &mac_auth, key[0], 128);\r\n\t//printf(\"\\n-Ciphertext  : \");\r\n\t//print_hex(ciphertext[1], 22);\r\n\t//printf(\"\\n-decrypted to: \");\r\n\t//print_hex(enc_buf, enc_buf_len);\r\n\t//printf(\"\\nAuthenticated: %d \", mac_auth);\r\n\tpass = pass && !memcmp(enc_buf, plaintext[1], enc_buf_len) && mac_auth;\r\n\r\n\r\n\taes_encrypt_ccm(plaintext[2], 24, assoc[2], 20, iv[2], 12, enc_buf, &enc_buf_len, 8, key[0], 128);\r\n\t//printf(\"\\n\\nNONCE        : \");\r\n\t//print_hex(iv[2], 12);\r\n\t//printf(\"\\nAssoc. Data  : \");\r\n\t//print_hex(assoc[2], 20);\r\n\t//printf(\"\\nPayload      : \");\r\n\t//print_hex(plaintext[2], 24);\r\n\t//printf(\"\\n-encrypted to: \");\r\n\t//print_hex(enc_buf, enc_buf_len);\r\n\tpass = pass && !memcmp(enc_buf, ciphertext[2], enc_buf_len);\r\n\r\n\taes_decrypt_ccm(ciphertext[2], 32, assoc[2], 20, iv[2], 12, enc_buf, &enc_buf_len, 8, &mac_auth, key[0], 128);\r\n\t//printf(\"\\n-Ciphertext  : \");\r\n\t//print_hex(ciphertext[2], 32);\r\n\t//printf(\"\\n-decrypted to: \");\r\n\t//print_hex(enc_buf, enc_buf_len);\r\n\t//printf(\"\\nAuthenticated: %d \", mac_auth);\r\n\tpass = pass && !memcmp(enc_buf, plaintext[2], enc_buf_len) && mac_auth;\r\n\r\n\t//printf(\"\\n\\n\");\r\n\treturn(pass);\r\n}\r\n\r\nint aes_test()\r\n{\r\n\tint pass = 1;\r\n\r\n\tpass = pass && aes_ecb_test();\r\n\tpass = pass && aes_cbc_test();\r\n\tpass = pass && aes_ctr_test();\r\n\tpass = pass && aes_ccm_test();\r\n\r\n\treturn(pass);\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n\tprintf(\"AES Tests: %s\\n\", aes_test() ? \"SUCCEEDED\" : \"FAILED\");\r\n\r\n\treturn(0);\r\n}\r\n"
        },
        {
          "name": "arcfour.c",
          "type": "blob",
          "size": 1.3193359375,
          "content": "/*********************************************************************\n* Filename:   arcfour.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the ARCFOUR encryption algorithm.\n              Algorithm specification can be found here:\n               * http://en.wikipedia.org/wiki/RC4\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include \"arcfour.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid arcfour_key_setup(BYTE state[], const BYTE key[], int len)\n{\n\tint i, j;\n\tBYTE t;\n\n\tfor (i = 0; i < 256; ++i)\n\t\tstate[i] = i;\n\tfor (i = 0, j = 0; i < 256; ++i) {\n\t\tj = (j + state[i] + key[i % len]) % 256;\n\t\tt = state[i];\n\t\tstate[i] = state[j];\n\t\tstate[j] = t;\n\t}\n}\n\n// This does not hold state between calls. It always generates the\n// stream starting from the first  output byte.\nvoid arcfour_generate_stream(BYTE state[], BYTE out[], size_t len)\n{\n\tint i, j;\n\tsize_t idx;\n\tBYTE t;\n\n\tfor (idx = 0, i = 0, j = 0; idx < len; ++idx)  {\n\t\ti = (i + 1) % 256;\n\t\tj = (j + state[i]) % 256;\n\t\tt = state[i];\n\t\tstate[i] = state[j];\n\t\tstate[j] = t;\n\t\tout[idx] = state[(state[i] + state[j]) % 256];\n\t}\n}\n"
        },
        {
          "name": "arcfour.h",
          "type": "blob",
          "size": 1.2080078125,
          "content": "/*********************************************************************\n* Filename:   arcfour.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding ARCFOUR implementation.\n*********************************************************************/\n\n#ifndef ARCFOUR_H\n#define ARCFOUR_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\n\n/*********************** FUNCTION DECLARATIONS **********************/\n// Input: state - the state used to generate the keystream\n//        key - Key to use to initialize the state\n//        len - length of key in bytes (valid lenth is 1 to 256)\nvoid arcfour_key_setup(BYTE state[], const BYTE key[], int len);\n\n// Pseudo-Random Generator Algorithm\n// Input: state - the state used to generate the keystream\n//        out - Must be allocated to be of at least \"len\" length\n//        len - number of bytes to generate\nvoid arcfour_generate_stream(BYTE state[], BYTE out[], size_t len);\n\n#endif   // ARCFOUR_H\n"
        },
        {
          "name": "arcfour_test.c",
          "type": "blob",
          "size": 1.59375,
          "content": "/*********************************************************************\n* Filename:   arcfour_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding ARCFOUR\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include \"arcfour.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint rc4_test()\n{\n\tBYTE state[256];\n\tBYTE key[3][10] = {{\"Key\"}, {\"Wiki\"}, {\"Secret\"}};\n\tBYTE stream[3][10] = {{0xEB,0x9F,0x77,0x81,0xB7,0x34,0xCA,0x72,0xA7,0x19},\n\t                      {0x60,0x44,0xdb,0x6d,0x41,0xb7},\n\t                      {0x04,0xd4,0x6b,0x05,0x3c,0xa8,0x7b,0x59}};\n\tint stream_len[3] = {10,6,8};\n\tBYTE buf[1024];\n\tint idx;\n\tint pass = 1;\n\n\t// Only test the output stream. Note that the state can be reused.\n\tfor (idx = 0; idx < 3; idx++) {\n\t\tarcfour_key_setup(state, key[idx], strlen(key[idx]));\n\t\tarcfour_generate_stream(state, buf, stream_len[idx]);\n\t\tpass = pass && !memcmp(stream[idx], buf, stream_len[idx]);\n\t}\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"ARCFOUR tests: %s\\n\", rc4_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        },
        {
          "name": "base64.c",
          "type": "blob",
          "size": 3.84375,
          "content": "/*********************************************************************\n* Filename:   base64.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the Base64 encoding algorithm.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include \"base64.h\"\n\n/****************************** MACROS ******************************/\n#define NEWLINE_INVL 76\n\n/**************************** VARIABLES *****************************/\n// Note: To change the charset to a URL encoding, replace the '+' and '/' with '*' and '-'\nstatic const BYTE charset[]={\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"};\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nBYTE revchar(char ch)\n{\n\tif (ch >= 'A' && ch <= 'Z')\n\t\tch -= 'A';\n\telse if (ch >= 'a' && ch <='z')\n\t\tch = ch - 'a' + 26;\n\telse if (ch >= '0' && ch <='9')\n\t\tch = ch - '0' + 52;\n\telse if (ch == '+')\n\t\tch = 62;\n\telse if (ch == '/')\n\t\tch = 63;\n\n\treturn(ch);\n}\n\nsize_t base64_encode(const BYTE in[], BYTE out[], size_t len, int newline_flag)\n{\n\tsize_t idx, idx2, blks, blk_ceiling, left_over, newline_count = 0;\n\n\tblks = (len / 3);\n\tleft_over = len % 3;\n\n\tif (out == NULL) {\n\t\tidx2 = blks * 4 ;\n\t\tif (left_over)\n\t\t\tidx2 += 4;\n\t\tif (newline_flag)\n\t\t\tidx2 += len / 57;   // (NEWLINE_INVL / 4) * 3 = 57. One newline per 57 input bytes.\n\t}\n\telse {\n\t\t// Since 3 input bytes = 4 output bytes, determine out how many even sets of\n\t\t// 3 bytes the input has.\n\t\tblk_ceiling = blks * 3;\n\t\tfor (idx = 0, idx2 = 0; idx < blk_ceiling; idx += 3, idx2 += 4) {\n\t\t\tout[idx2]     = charset[in[idx] >> 2];\n\t\t\tout[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)];\n\t\t\tout[idx2 + 2] = charset[((in[idx + 1] & 0x0f) << 2) | (in[idx + 2] >> 6)];\n\t\t\tout[idx2 + 3] = charset[in[idx + 2] & 0x3F];\n\t\t\t// The offical standard requires a newline every 76 characters.\n\t\t\t// (Eg, first newline is character 77 of the output.)\n\t\t\tif (((idx2 - newline_count + 4) % NEWLINE_INVL == 0) && newline_flag) {\n\t\t\t\tout[idx2 + 4] = '\\n';\n\t\t\t\tidx2++;\n\t\t\t\tnewline_count++;\n\t\t\t}\n\t\t}\n\n\t\tif (left_over == 1) {\n\t\t\tout[idx2]     = charset[in[idx] >> 2];\n\t\t\tout[idx2 + 1] = charset[(in[idx] & 0x03) << 4];\n\t\t\tout[idx2 + 2] = '=';\n\t\t\tout[idx2 + 3] = '=';\n\t\t\tidx2 += 4;\n\t\t}\n\t\telse if (left_over == 2) {\n\t\t\tout[idx2]     = charset[in[idx] >> 2];\n\t\t\tout[idx2 + 1] = charset[((in[idx] & 0x03) << 4) | (in[idx + 1] >> 4)];\n\t\t\tout[idx2 + 2] = charset[(in[idx + 1] & 0x0F) << 2];\n\t\t\tout[idx2 + 3] = '=';\n\t\t\tidx2 += 4;\n\t\t}\n\t}\n\n\treturn(idx2);\n}\n\nsize_t base64_decode(const BYTE in[], BYTE out[], size_t len)\n{\n\tBYTE ch;\n\tsize_t idx, idx2, blks, blk_ceiling, left_over;\n\n\tif (in[len - 1] == '=')\n\t\tlen--;\n\tif (in[len - 1] == '=')\n\t\tlen--;\n\n\tblks = len / 4;\n\tleft_over = len % 4;\n\n\tif (out == NULL) {\n\t\tif (len >= 77 && in[NEWLINE_INVL] == '\\n')   // Verify that newlines where used.\n\t\t\tlen -= len / (NEWLINE_INVL + 1);\n\t\tblks = len / 4;\n\t\tleft_over = len % 4;\n\n\t\tidx = blks * 3;\n\t\tif (left_over == 2)\n\t\t\tidx ++;\n\t\telse if (left_over == 3)\n\t\t\tidx += 2;\n\t}\n\telse {\n\t\tblk_ceiling = blks * 4;\n\t\tfor (idx = 0, idx2 = 0; idx2 < blk_ceiling; idx += 3, idx2 += 4) {\n\t\t\tif (in[idx2] == '\\n')\n\t\t\t\tidx2++;\n\t\t\tout[idx]     = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4);\n\t\t\tout[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2);\n\t\t\tout[idx + 2] = (revchar(in[idx2 + 2]) << 6) | revchar(in[idx2 + 3]);\n\t\t}\n\n\t\tif (left_over == 2) {\n\t\t\tout[idx]     = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4);\n\t\t\tidx++;\n\t\t}\n\t\telse if (left_over == 3) {\n\t\t\tout[idx]     = (revchar(in[idx2]) << 2) | ((revchar(in[idx2 + 1]) & 0x30) >> 4);\n\t\t\tout[idx + 1] = (revchar(in[idx2 + 1]) << 4) | (revchar(in[idx2 + 2]) >> 2);\n\t\t\tidx += 2;\n\t\t}\n\t}\n\n\treturn(idx);\n}\n"
        },
        {
          "name": "base64.h",
          "type": "blob",
          "size": 1.1474609375,
          "content": "/*********************************************************************\n* Filename:   base64.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding Base64 implementation.\n*********************************************************************/\n\n#ifndef BASE64_H\n#define BASE64_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\n\n/*********************** FUNCTION DECLARATIONS **********************/\n// Returns the size of the output. If called with out = NULL, will just return\n// the size of what the output would have been (without a terminating NULL).\nsize_t base64_encode(const BYTE in[], BYTE out[], size_t len, int newline_flag);\n\n// Returns the size of the output. If called with out = NULL, will just return\n// the size of what the output would have been (without a terminating NULL).\nsize_t base64_decode(const BYTE in[], BYTE out[], size_t len);\n\n#endif   // BASE64_H\n"
        },
        {
          "name": "base64_test.c",
          "type": "blob",
          "size": 2.400390625,
          "content": "/*********************************************************************\n* Filename:   blowfish_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding Base64\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include \"base64.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint base64_test()\n{\n\tBYTE text[3][1024] = {{\"fo\"},\n\t                      {\"foobar\"},\n\t                      {\"Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.\"}};\n\tBYTE code[3][1024] = {{\"Zm8=\"},\n\t                      {\"Zm9vYmFy\"},\n\t                      {\"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\\nIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg\\ndGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu\\ndWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo\\nZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\"}};\n\tBYTE buf[1024];\n\tsize_t buf_len;\n\tint pass = 1;\n\tint idx;\n\n\tfor (idx = 0; idx < 3; idx++) {\n\t\tbuf_len = base64_encode(text[idx], buf, strlen(text[idx]), 1);\n\t\tpass = pass && ((buf_len == strlen(code[idx])) &&\n\t\t                 (buf_len == base64_encode(text[idx], NULL, strlen(text[idx]), 1)));\n\t\tpass = pass && !strcmp(code[idx], buf);\n\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tbuf_len = base64_decode(code[idx], buf, strlen(code[idx]));\n\t\tpass = pass && ((buf_len == strlen(text[idx])) &&\n\t\t                (buf_len == base64_decode(code[idx], NULL, strlen(code[idx]))));\n\t\tpass = pass && !strcmp(text[idx], buf);\n\t}\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"Base64 tests: %s\\n\", base64_test() ? \"PASSED\" : \"FAILED\");\n\n\treturn 0;\n}\n"
        },
        {
          "name": "blowfish.c",
          "type": "blob",
          "size": 16.0654296875,
          "content": "/*********************************************************************\n* Filename:   blowfish.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the Blowfish encryption algorithm.\n              Modes of operation (such as CBC) are not included.\n              Algorithm specification can be found here:\n               * http://www.schneier.com/blowfish.html\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"blowfish.h\"\n\n/****************************** MACROS ******************************/\n#define F(x,t) t = keystruct->s[0][(x) >> 24]; \\\n               t += keystruct->s[1][((x) >> 16) & 0xff]; \\\n               t ^= keystruct->s[2][((x) >> 8) & 0xff]; \\\n               t += keystruct->s[3][(x) & 0xff];\n#define swap(r,l,t) t = l; l = r; r = t;\n#define ITERATION(l,r,t,pval) l ^= keystruct->p[pval]; F(l,t); r^= t; swap(r,l,t);\n\n/**************************** VARIABLES *****************************/\nstatic const WORD p_perm[18] = {\n   0x243F6A88,0x85A308D3,0x13198A2E,0x03707344,0xA4093822,0x299F31D0,0x082EFA98,\n   0xEC4E6C89,0x452821E6,0x38D01377,0xBE5466CF,0x34E90C6C,0xC0AC29B7,0xC97C50DD,\n   0x3F84D5B5,0xB5470917,0x9216D5D9,0x8979FB1B\n};\n\nstatic const WORD s_perm[4][256] = { {\n   0xD1310BA6,0x98DFB5AC,0x2FFD72DB,0xD01ADFB7,0xB8E1AFED,0x6A267E96,0xBA7C9045,0xF12C7F99,\n   0x24A19947,0xB3916CF7,0x0801F2E2,0x858EFC16,0x636920D8,0x71574E69,0xA458FEA3,0xF4933D7E,\n   0x0D95748F,0x728EB658,0x718BCD58,0x82154AEE,0x7B54A41D,0xC25A59B5,0x9C30D539,0x2AF26013,\n   0xC5D1B023,0x286085F0,0xCA417918,0xB8DB38EF,0x8E79DCB0,0x603A180E,0x6C9E0E8B,0xB01E8A3E,\n   0xD71577C1,0xBD314B27,0x78AF2FDA,0x55605C60,0xE65525F3,0xAA55AB94,0x57489862,0x63E81440,\n   0x55CA396A,0x2AAB10B6,0xB4CC5C34,0x1141E8CE,0xA15486AF,0x7C72E993,0xB3EE1411,0x636FBC2A,\n   0x2BA9C55D,0x741831F6,0xCE5C3E16,0x9B87931E,0xAFD6BA33,0x6C24CF5C,0x7A325381,0x28958677,\n   0x3B8F4898,0x6B4BB9AF,0xC4BFE81B,0x66282193,0x61D809CC,0xFB21A991,0x487CAC60,0x5DEC8032,\n   0xEF845D5D,0xE98575B1,0xDC262302,0xEB651B88,0x23893E81,0xD396ACC5,0x0F6D6FF3,0x83F44239,\n   0x2E0B4482,0xA4842004,0x69C8F04A,0x9E1F9B5E,0x21C66842,0xF6E96C9A,0x670C9C61,0xABD388F0,\n   0x6A51A0D2,0xD8542F68,0x960FA728,0xAB5133A3,0x6EEF0B6C,0x137A3BE4,0xBA3BF050,0x7EFB2A98,\n   0xA1F1651D,0x39AF0176,0x66CA593E,0x82430E88,0x8CEE8619,0x456F9FB4,0x7D84A5C3,0x3B8B5EBE,\n   0xE06F75D8,0x85C12073,0x401A449F,0x56C16AA6,0x4ED3AA62,0x363F7706,0x1BFEDF72,0x429B023D,\n   0x37D0D724,0xD00A1248,0xDB0FEAD3,0x49F1C09B,0x075372C9,0x80991B7B,0x25D479D8,0xF6E8DEF7,\n   0xE3FE501A,0xB6794C3B,0x976CE0BD,0x04C006BA,0xC1A94FB6,0x409F60C4,0x5E5C9EC2,0x196A2463,\n   0x68FB6FAF,0x3E6C53B5,0x1339B2EB,0x3B52EC6F,0x6DFC511F,0x9B30952C,0xCC814544,0xAF5EBD09,\n   0xBEE3D004,0xDE334AFD,0x660F2807,0x192E4BB3,0xC0CBA857,0x45C8740F,0xD20B5F39,0xB9D3FBDB,\n   0x5579C0BD,0x1A60320A,0xD6A100C6,0x402C7279,0x679F25FE,0xFB1FA3CC,0x8EA5E9F8,0xDB3222F8,\n   0x3C7516DF,0xFD616B15,0x2F501EC8,0xAD0552AB,0x323DB5FA,0xFD238760,0x53317B48,0x3E00DF82,\n   0x9E5C57BB,0xCA6F8CA0,0x1A87562E,0xDF1769DB,0xD542A8F6,0x287EFFC3,0xAC6732C6,0x8C4F5573,\n   0x695B27B0,0xBBCA58C8,0xE1FFA35D,0xB8F011A0,0x10FA3D98,0xFD2183B8,0x4AFCB56C,0x2DD1D35B,\n   0x9A53E479,0xB6F84565,0xD28E49BC,0x4BFB9790,0xE1DDF2DA,0xA4CB7E33,0x62FB1341,0xCEE4C6E8,\n   0xEF20CADA,0x36774C01,0xD07E9EFE,0x2BF11FB4,0x95DBDA4D,0xAE909198,0xEAAD8E71,0x6B93D5A0,\n   0xD08ED1D0,0xAFC725E0,0x8E3C5B2F,0x8E7594B7,0x8FF6E2FB,0xF2122B64,0x8888B812,0x900DF01C,\n   0x4FAD5EA0,0x688FC31C,0xD1CFF191,0xB3A8C1AD,0x2F2F2218,0xBE0E1777,0xEA752DFE,0x8B021FA1,\n   0xE5A0CC0F,0xB56F74E8,0x18ACF3D6,0xCE89E299,0xB4A84FE0,0xFD13E0B7,0x7CC43B81,0xD2ADA8D9,\n   0x165FA266,0x80957705,0x93CC7314,0x211A1477,0xE6AD2065,0x77B5FA86,0xC75442F5,0xFB9D35CF,\n   0xEBCDAF0C,0x7B3E89A0,0xD6411BD3,0xAE1E7E49,0x00250E2D,0x2071B35E,0x226800BB,0x57B8E0AF,\n   0x2464369B,0xF009B91E,0x5563911D,0x59DFA6AA,0x78C14389,0xD95A537F,0x207D5BA2,0x02E5B9C5,\n   0x83260376,0x6295CFA9,0x11C81968,0x4E734A41,0xB3472DCA,0x7B14A94A,0x1B510052,0x9A532915,\n   0xD60F573F,0xBC9BC6E4,0x2B60A476,0x81E67400,0x08BA6FB5,0x571BE91F,0xF296EC6B,0x2A0DD915,\n   0xB6636521,0xE7B9F9B6,0xFF34052E,0xC5855664,0x53B02D5D,0xA99F8FA1,0x08BA4799,0x6E85076A\n},{\n   0x4B7A70E9,0xB5B32944,0xDB75092E,0xC4192623,0xAD6EA6B0,0x49A7DF7D,0x9CEE60B8,0x8FEDB266,\n   0xECAA8C71,0x699A17FF,0x5664526C,0xC2B19EE1,0x193602A5,0x75094C29,0xA0591340,0xE4183A3E,\n   0x3F54989A,0x5B429D65,0x6B8FE4D6,0x99F73FD6,0xA1D29C07,0xEFE830F5,0x4D2D38E6,0xF0255DC1,\n   0x4CDD2086,0x8470EB26,0x6382E9C6,0x021ECC5E,0x09686B3F,0x3EBAEFC9,0x3C971814,0x6B6A70A1,\n   0x687F3584,0x52A0E286,0xB79C5305,0xAA500737,0x3E07841C,0x7FDEAE5C,0x8E7D44EC,0x5716F2B8,\n   0xB03ADA37,0xF0500C0D,0xF01C1F04,0x0200B3FF,0xAE0CF51A,0x3CB574B2,0x25837A58,0xDC0921BD,\n   0xD19113F9,0x7CA92FF6,0x94324773,0x22F54701,0x3AE5E581,0x37C2DADC,0xC8B57634,0x9AF3DDA7,\n   0xA9446146,0x0FD0030E,0xECC8C73E,0xA4751E41,0xE238CD99,0x3BEA0E2F,0x3280BBA1,0x183EB331,\n   0x4E548B38,0x4F6DB908,0x6F420D03,0xF60A04BF,0x2CB81290,0x24977C79,0x5679B072,0xBCAF89AF,\n   0xDE9A771F,0xD9930810,0xB38BAE12,0xDCCF3F2E,0x5512721F,0x2E6B7124,0x501ADDE6,0x9F84CD87,\n   0x7A584718,0x7408DA17,0xBC9F9ABC,0xE94B7D8C,0xEC7AEC3A,0xDB851DFA,0x63094366,0xC464C3D2,\n   0xEF1C1847,0x3215D908,0xDD433B37,0x24C2BA16,0x12A14D43,0x2A65C451,0x50940002,0x133AE4DD,\n   0x71DFF89E,0x10314E55,0x81AC77D6,0x5F11199B,0x043556F1,0xD7A3C76B,0x3C11183B,0x5924A509,\n   0xF28FE6ED,0x97F1FBFA,0x9EBABF2C,0x1E153C6E,0x86E34570,0xEAE96FB1,0x860E5E0A,0x5A3E2AB3,\n   0x771FE71C,0x4E3D06FA,0x2965DCB9,0x99E71D0F,0x803E89D6,0x5266C825,0x2E4CC978,0x9C10B36A,\n   0xC6150EBA,0x94E2EA78,0xA5FC3C53,0x1E0A2DF4,0xF2F74EA7,0x361D2B3D,0x1939260F,0x19C27960,\n   0x5223A708,0xF71312B6,0xEBADFE6E,0xEAC31F66,0xE3BC4595,0xA67BC883,0xB17F37D1,0x018CFF28,\n   0xC332DDEF,0xBE6C5AA5,0x65582185,0x68AB9802,0xEECEA50F,0xDB2F953B,0x2AEF7DAD,0x5B6E2F84,\n   0x1521B628,0x29076170,0xECDD4775,0x619F1510,0x13CCA830,0xEB61BD96,0x0334FE1E,0xAA0363CF,\n   0xB5735C90,0x4C70A239,0xD59E9E0B,0xCBAADE14,0xEECC86BC,0x60622CA7,0x9CAB5CAB,0xB2F3846E,\n   0x648B1EAF,0x19BDF0CA,0xA02369B9,0x655ABB50,0x40685A32,0x3C2AB4B3,0x319EE9D5,0xC021B8F7,\n   0x9B540B19,0x875FA099,0x95F7997E,0x623D7DA8,0xF837889A,0x97E32D77,0x11ED935F,0x16681281,\n   0x0E358829,0xC7E61FD6,0x96DEDFA1,0x7858BA99,0x57F584A5,0x1B227263,0x9B83C3FF,0x1AC24696,\n   0xCDB30AEB,0x532E3054,0x8FD948E4,0x6DBC3128,0x58EBF2EF,0x34C6FFEA,0xFE28ED61,0xEE7C3C73,\n   0x5D4A14D9,0xE864B7E3,0x42105D14,0x203E13E0,0x45EEE2B6,0xA3AAABEA,0xDB6C4F15,0xFACB4FD0,\n   0xC742F442,0xEF6ABBB5,0x654F3B1D,0x41CD2105,0xD81E799E,0x86854DC7,0xE44B476A,0x3D816250,\n   0xCF62A1F2,0x5B8D2646,0xFC8883A0,0xC1C7B6A3,0x7F1524C3,0x69CB7492,0x47848A0B,0x5692B285,\n   0x095BBF00,0xAD19489D,0x1462B174,0x23820E00,0x58428D2A,0x0C55F5EA,0x1DADF43E,0x233F7061,\n   0x3372F092,0x8D937E41,0xD65FECF1,0x6C223BDB,0x7CDE3759,0xCBEE7460,0x4085F2A7,0xCE77326E,\n   0xA6078084,0x19F8509E,0xE8EFD855,0x61D99735,0xA969A7AA,0xC50C06C2,0x5A04ABFC,0x800BCADC,\n   0x9E447A2E,0xC3453484,0xFDD56705,0x0E1E9EC9,0xDB73DBD3,0x105588CD,0x675FDA79,0xE3674340,\n   0xC5C43465,0x713E38D8,0x3D28F89E,0xF16DFF20,0x153E21E7,0x8FB03D4A,0xE6E39F2B,0xDB83ADF7\n},{\n   0xE93D5A68,0x948140F7,0xF64C261C,0x94692934,0x411520F7,0x7602D4F7,0xBCF46B2E,0xD4A20068,\n   0xD4082471,0x3320F46A,0x43B7D4B7,0x500061AF,0x1E39F62E,0x97244546,0x14214F74,0xBF8B8840,\n   0x4D95FC1D,0x96B591AF,0x70F4DDD3,0x66A02F45,0xBFBC09EC,0x03BD9785,0x7FAC6DD0,0x31CB8504,\n   0x96EB27B3,0x55FD3941,0xDA2547E6,0xABCA0A9A,0x28507825,0x530429F4,0x0A2C86DA,0xE9B66DFB,\n   0x68DC1462,0xD7486900,0x680EC0A4,0x27A18DEE,0x4F3FFEA2,0xE887AD8C,0xB58CE006,0x7AF4D6B6,\n   0xAACE1E7C,0xD3375FEC,0xCE78A399,0x406B2A42,0x20FE9E35,0xD9F385B9,0xEE39D7AB,0x3B124E8B,\n   0x1DC9FAF7,0x4B6D1856,0x26A36631,0xEAE397B2,0x3A6EFA74,0xDD5B4332,0x6841E7F7,0xCA7820FB,\n   0xFB0AF54E,0xD8FEB397,0x454056AC,0xBA489527,0x55533A3A,0x20838D87,0xFE6BA9B7,0xD096954B,\n   0x55A867BC,0xA1159A58,0xCCA92963,0x99E1DB33,0xA62A4A56,0x3F3125F9,0x5EF47E1C,0x9029317C,\n   0xFDF8E802,0x04272F70,0x80BB155C,0x05282CE3,0x95C11548,0xE4C66D22,0x48C1133F,0xC70F86DC,\n   0x07F9C9EE,0x41041F0F,0x404779A4,0x5D886E17,0x325F51EB,0xD59BC0D1,0xF2BCC18F,0x41113564,\n   0x257B7834,0x602A9C60,0xDFF8E8A3,0x1F636C1B,0x0E12B4C2,0x02E1329E,0xAF664FD1,0xCAD18115,\n   0x6B2395E0,0x333E92E1,0x3B240B62,0xEEBEB922,0x85B2A20E,0xE6BA0D99,0xDE720C8C,0x2DA2F728,\n   0xD0127845,0x95B794FD,0x647D0862,0xE7CCF5F0,0x5449A36F,0x877D48FA,0xC39DFD27,0xF33E8D1E,\n   0x0A476341,0x992EFF74,0x3A6F6EAB,0xF4F8FD37,0xA812DC60,0xA1EBDDF8,0x991BE14C,0xDB6E6B0D,\n   0xC67B5510,0x6D672C37,0x2765D43B,0xDCD0E804,0xF1290DC7,0xCC00FFA3,0xB5390F92,0x690FED0B,\n   0x667B9FFB,0xCEDB7D9C,0xA091CF0B,0xD9155EA3,0xBB132F88,0x515BAD24,0x7B9479BF,0x763BD6EB,\n   0x37392EB3,0xCC115979,0x8026E297,0xF42E312D,0x6842ADA7,0xC66A2B3B,0x12754CCC,0x782EF11C,\n   0x6A124237,0xB79251E7,0x06A1BBE6,0x4BFB6350,0x1A6B1018,0x11CAEDFA,0x3D25BDD8,0xE2E1C3C9,\n   0x44421659,0x0A121386,0xD90CEC6E,0xD5ABEA2A,0x64AF674E,0xDA86A85F,0xBEBFE988,0x64E4C3FE,\n   0x9DBC8057,0xF0F7C086,0x60787BF8,0x6003604D,0xD1FD8346,0xF6381FB0,0x7745AE04,0xD736FCCC,\n   0x83426B33,0xF01EAB71,0xB0804187,0x3C005E5F,0x77A057BE,0xBDE8AE24,0x55464299,0xBF582E61,\n   0x4E58F48F,0xF2DDFDA2,0xF474EF38,0x8789BDC2,0x5366F9C3,0xC8B38E74,0xB475F255,0x46FCD9B9,\n   0x7AEB2661,0x8B1DDF84,0x846A0E79,0x915F95E2,0x466E598E,0x20B45770,0x8CD55591,0xC902DE4C,\n   0xB90BACE1,0xBB8205D0,0x11A86248,0x7574A99E,0xB77F19B6,0xE0A9DC09,0x662D09A1,0xC4324633,\n   0xE85A1F02,0x09F0BE8C,0x4A99A025,0x1D6EFE10,0x1AB93D1D,0x0BA5A4DF,0xA186F20F,0x2868F169,\n   0xDCB7DA83,0x573906FE,0xA1E2CE9B,0x4FCD7F52,0x50115E01,0xA70683FA,0xA002B5C4,0x0DE6D027,\n   0x9AF88C27,0x773F8641,0xC3604C06,0x61A806B5,0xF0177A28,0xC0F586E0,0x006058AA,0x30DC7D62,\n   0x11E69ED7,0x2338EA63,0x53C2DD94,0xC2C21634,0xBBCBEE56,0x90BCB6DE,0xEBFC7DA1,0xCE591D76,\n   0x6F05E409,0x4B7C0188,0x39720A3D,0x7C927C24,0x86E3725F,0x724D9DB9,0x1AC15BB4,0xD39EB8FC,\n   0xED545578,0x08FCA5B5,0xD83D7CD3,0x4DAD0FC4,0x1E50EF5E,0xB161E6F8,0xA28514D9,0x6C51133C,\n   0x6FD5C7E7,0x56E14EC4,0x362ABFCE,0xDDC6C837,0xD79A3234,0x92638212,0x670EFA8E,0x406000E0\n},{\n   0x3A39CE37,0xD3FAF5CF,0xABC27737,0x5AC52D1B,0x5CB0679E,0x4FA33742,0xD3822740,0x99BC9BBE,\n   0xD5118E9D,0xBF0F7315,0xD62D1C7E,0xC700C47B,0xB78C1B6B,0x21A19045,0xB26EB1BE,0x6A366EB4,\n   0x5748AB2F,0xBC946E79,0xC6A376D2,0x6549C2C8,0x530FF8EE,0x468DDE7D,0xD5730A1D,0x4CD04DC6,\n   0x2939BBDB,0xA9BA4650,0xAC9526E8,0xBE5EE304,0xA1FAD5F0,0x6A2D519A,0x63EF8CE2,0x9A86EE22,\n   0xC089C2B8,0x43242EF6,0xA51E03AA,0x9CF2D0A4,0x83C061BA,0x9BE96A4D,0x8FE51550,0xBA645BD6,\n   0x2826A2F9,0xA73A3AE1,0x4BA99586,0xEF5562E9,0xC72FEFD3,0xF752F7DA,0x3F046F69,0x77FA0A59,\n   0x80E4A915,0x87B08601,0x9B09E6AD,0x3B3EE593,0xE990FD5A,0x9E34D797,0x2CF0B7D9,0x022B8B51,\n   0x96D5AC3A,0x017DA67D,0xD1CF3ED6,0x7C7D2D28,0x1F9F25CF,0xADF2B89B,0x5AD6B472,0x5A88F54C,\n   0xE029AC71,0xE019A5E6,0x47B0ACFD,0xED93FA9B,0xE8D3C48D,0x283B57CC,0xF8D56629,0x79132E28,\n   0x785F0191,0xED756055,0xF7960E44,0xE3D35E8C,0x15056DD4,0x88F46DBA,0x03A16125,0x0564F0BD,\n   0xC3EB9E15,0x3C9057A2,0x97271AEC,0xA93A072A,0x1B3F6D9B,0x1E6321F5,0xF59C66FB,0x26DCF319,\n   0x7533D928,0xB155FDF5,0x03563482,0x8ABA3CBB,0x28517711,0xC20AD9F8,0xABCC5167,0xCCAD925F,\n   0x4DE81751,0x3830DC8E,0x379D5862,0x9320F991,0xEA7A90C2,0xFB3E7BCE,0x5121CE64,0x774FBE32,\n   0xA8B6E37E,0xC3293D46,0x48DE5369,0x6413E680,0xA2AE0810,0xDD6DB224,0x69852DFD,0x09072166,\n   0xB39A460A,0x6445C0DD,0x586CDECF,0x1C20C8AE,0x5BBEF7DD,0x1B588D40,0xCCD2017F,0x6BB4E3BB,\n   0xDDA26A7E,0x3A59FF45,0x3E350A44,0xBCB4CDD5,0x72EACEA8,0xFA6484BB,0x8D6612AE,0xBF3C6F47,\n   0xD29BE463,0x542F5D9E,0xAEC2771B,0xF64E6370,0x740E0D8D,0xE75B1357,0xF8721671,0xAF537D5D,\n   0x4040CB08,0x4EB4E2CC,0x34D2466A,0x0115AF84,0xE1B00428,0x95983A1D,0x06B89FB4,0xCE6EA048,\n   0x6F3F3B82,0x3520AB82,0x011A1D4B,0x277227F8,0x611560B1,0xE7933FDC,0xBB3A792B,0x344525BD,\n   0xA08839E1,0x51CE794B,0x2F32C9B7,0xA01FBAC9,0xE01CC87E,0xBCC7D1F6,0xCF0111C3,0xA1E8AAC7,\n   0x1A908749,0xD44FBD9A,0xD0DADECB,0xD50ADA38,0x0339C32A,0xC6913667,0x8DF9317C,0xE0B12B4F,\n   0xF79E59B7,0x43F5BB3A,0xF2D519FF,0x27D9459C,0xBF97222C,0x15E6FC2A,0x0F91FC71,0x9B941525,\n   0xFAE59361,0xCEB69CEB,0xC2A86459,0x12BAA8D1,0xB6C1075E,0xE3056A0C,0x10D25065,0xCB03A442,\n   0xE0EC6E0E,0x1698DB3B,0x4C98A0BE,0x3278E964,0x9F1F9532,0xE0D392DF,0xD3A0342B,0x8971F21E,\n   0x1B0A7441,0x4BA3348C,0xC5BE7120,0xC37632D8,0xDF359F8D,0x9B992F2E,0xE60B6F47,0x0FE3F11D,\n   0xE54CDA54,0x1EDAD891,0xCE6279CF,0xCD3E7E6F,0x1618B166,0xFD2C1D05,0x848FD2C5,0xF6FB2299,\n   0xF523F357,0xA6327623,0x93A83531,0x56CCCD02,0xACF08162,0x5A75EBB5,0x6E163697,0x88D273CC,\n   0xDE966292,0x81B949D0,0x4C50901B,0x71C65614,0xE6C6C7BD,0x327A140A,0x45E1D006,0xC3F27B9A,\n   0xC9AA53FD,0x62A80F00,0xBB25BFE2,0x35BDD2F6,0x71126905,0xB2040222,0xB6CBCF7C,0xCD769C2B,\n   0x53113EC0,0x1640E3D3,0x38ABBD60,0x2547ADF0,0xBA38209C,0xF746CE76,0x77AFA1C5,0x20756060,\n   0x85CBFE4E,0x8AE88DD8,0x7AAAF9B0,0x4CF9AA7E,0x1948C25C,0x02FB8A8C,0x01C36AE4,0xD6EBE1F9,\n   0x90D4F869,0xA65CDEA0,0x3F09252D,0xC208E69F,0xB74E6132,0xCE77E25B,0x578FDFE3,0x3AC372E6\n} };\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid blowfish_encrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct)\n{\n   WORD l,r,t; //,i;\n\n   l = (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]);\n   r = (in[4] << 24) | (in[5] << 16) | (in[6] << 8) | (in[7]);\n\n   ITERATION(l,r,t,0);\n   ITERATION(l,r,t,1);\n   ITERATION(l,r,t,2);\n   ITERATION(l,r,t,3);\n   ITERATION(l,r,t,4);\n   ITERATION(l,r,t,5);\n   ITERATION(l,r,t,6);\n   ITERATION(l,r,t,7);\n   ITERATION(l,r,t,8);\n   ITERATION(l,r,t,9);\n   ITERATION(l,r,t,10);\n   ITERATION(l,r,t,11);\n   ITERATION(l,r,t,12);\n   ITERATION(l,r,t,13);\n   ITERATION(l,r,t,14);\n   l ^= keystruct->p[15]; F(l,t); r^= t; //Last iteration has no swap()\n   r ^= keystruct->p[16];\n   l ^= keystruct->p[17];\n\n   out[0] = l >> 24;\n   out[1] = l >> 16;\n   out[2] = l >> 8;\n   out[3] = l;\n   out[4] = r >> 24;\n   out[5] = r >> 16;\n   out[6] = r >> 8;\n   out[7] = r;\n}\n\nvoid blowfish_decrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct)\n{\n   WORD l,r,t; //,i;\n\n   l = (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]);\n   r = (in[4] << 24) | (in[5] << 16) | (in[6] << 8) | (in[7]);\n\n   ITERATION(l,r,t,17);\n   ITERATION(l,r,t,16);\n   ITERATION(l,r,t,15);\n   ITERATION(l,r,t,14);\n   ITERATION(l,r,t,13);\n   ITERATION(l,r,t,12);\n   ITERATION(l,r,t,11);\n   ITERATION(l,r,t,10);\n   ITERATION(l,r,t,9);\n   ITERATION(l,r,t,8);\n   ITERATION(l,r,t,7);\n   ITERATION(l,r,t,6);\n   ITERATION(l,r,t,5);\n   ITERATION(l,r,t,4);\n   ITERATION(l,r,t,3);\n   l ^= keystruct->p[2]; F(l,t); r^= t; //Last iteration has no swap()\n   r ^= keystruct->p[1];\n   l ^= keystruct->p[0];\n\n   out[0] = l >> 24;\n   out[1] = l >> 16;\n   out[2] = l >> 8;\n   out[3] = l;\n   out[4] = r >> 24;\n   out[5] = r >> 16;\n   out[6] = r >> 8;\n   out[7] = r;\n}\n\nvoid blowfish_key_setup(const BYTE user_key[], BLOWFISH_KEY *keystruct, size_t len)\n{\n   BYTE block[8];\n   int idx,idx2;\n\n   // Copy over the constant init array vals (so the originals aren't destroyed).\n   memcpy(keystruct->p,p_perm,sizeof(WORD) * 18);\n   memcpy(keystruct->s,s_perm,sizeof(WORD) * 1024);\n\n   // Combine the key with the P box. Assume key is standard 448 bits (56 bytes) or less.\n   for (idx = 0, idx2 = 0; idx < 18; ++idx, idx2 += 4)\n      keystruct->p[idx] ^= (user_key[idx2 % len] << 24) | (user_key[(idx2+1) % len] << 16)\n                           | (user_key[(idx2+2) % len] << 8) | (user_key[(idx2+3) % len]);\n   // Re-calculate the P box.\n   memset(block, 0, 8);\n   for (idx = 0; idx < 18; idx += 2) {\n      blowfish_encrypt(block,block,keystruct);\n      keystruct->p[idx] = (block[0] << 24) | (block[1] << 16) | (block[2] << 8) | block[3];\n      keystruct->p[idx+1]=(block[4] << 24) | (block[5] << 16) | (block[6] << 8) | block[7];\n   }\n   // Recalculate the S-boxes.\n   for (idx = 0; idx < 4; ++idx) {\n      for (idx2 = 0; idx2 < 256; idx2 += 2) {\n         blowfish_encrypt(block,block,keystruct);\n         keystruct->s[idx][idx2] = (block[0] << 24) | (block[1] << 16) |\n                                   (block[2] << 8) | block[3];\n         keystruct->s[idx][idx2+1] = (block[4] << 24) | (block[5] << 16) |\n                                     (block[6] << 8) | block[7];\n      }\n   }\n}\n"
        },
        {
          "name": "blowfish.h",
          "type": "blob",
          "size": 1.263671875,
          "content": "/*********************************************************************\n* Filename:   blowfish.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding Blowfish implementation.\n*********************************************************************/\n\n#ifndef BLOWFISH_H\n#define BLOWFISH_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/****************************** MACROS ******************************/\n#define BLOWFISH_BLOCK_SIZE 8           // Blowfish operates on 8 bytes at a time\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\ntypedef unsigned int  WORD;             // 32-bit word, change to \"long\" for 16-bit machines\n\ntypedef struct {\n   WORD p[18];\n   WORD s[4][256];\n} BLOWFISH_KEY;\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid blowfish_key_setup(const BYTE user_key[], BLOWFISH_KEY *keystruct, size_t len);\nvoid blowfish_encrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct);\nvoid blowfish_decrypt(const BYTE in[], BYTE out[], const BLOWFISH_KEY *keystruct);\n\n#endif   // BLOWFISH_H\n"
        },
        {
          "name": "blowfish_test.c",
          "type": "blob",
          "size": 2.5712890625,
          "content": "/*********************************************************************\n* Filename:   blowfish_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding Blowfish\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include \"blowfish.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint blowfish_test()\n{\n\tBYTE key1[8]  = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n\tBYTE key2[8]  = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};\n\tBYTE key3[24] = {0xF0,0xE1,0xD2,0xC3,0xB4,0xA5,0x96,0x87,\n\t                 0x78,0x69,0x5A,0x4B,0x3C,0x2D,0x1E,0x0F,\n\t                 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77};\n\tBYTE p1[BLOWFISH_BLOCK_SIZE] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n\tBYTE p2[BLOWFISH_BLOCK_SIZE] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};\n\tBYTE p3[BLOWFISH_BLOCK_SIZE] = {0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};\n\n\tBYTE c1[BLOWFISH_BLOCK_SIZE] = {0x4e,0xf9,0x97,0x45,0x61,0x98,0xdd,0x78};\n\tBYTE c2[BLOWFISH_BLOCK_SIZE] = {0x51,0x86,0x6f,0xd5,0xb8,0x5e,0xcb,0x8a};\n\tBYTE c3[BLOWFISH_BLOCK_SIZE] = {0x05,0x04,0x4b,0x62,0xfa,0x52,0xd0,0x80};\n\n\tBYTE enc_buf[BLOWFISH_BLOCK_SIZE];\n\tBLOWFISH_KEY key;\n\tint pass = 1;\n\n\t// Test vector 1.\n\tblowfish_key_setup(key1, &key, BLOWFISH_BLOCK_SIZE);\n\tblowfish_encrypt(p1, enc_buf, &key);\n\tpass = pass && !memcmp(c1, enc_buf, BLOWFISH_BLOCK_SIZE);\n\tblowfish_decrypt(c1, enc_buf, &key);\n\tpass = pass && !memcmp(p1, enc_buf, BLOWFISH_BLOCK_SIZE);\n\n\t// Test vector 2.\n\tblowfish_key_setup(key2, &key, BLOWFISH_BLOCK_SIZE);\n\tblowfish_encrypt(p2, enc_buf, &key);\n\tpass = pass && !memcmp(c2, enc_buf, BLOWFISH_BLOCK_SIZE);\n\tblowfish_decrypt(c2, enc_buf, &key);\n\tpass = pass && !memcmp(p2, enc_buf, BLOWFISH_BLOCK_SIZE);\n\n\t// Test vector 3.\n\tblowfish_key_setup(key3, &key, 24);\n\tblowfish_encrypt(p3, enc_buf, &key);\n\tpass = pass && !memcmp(c3, enc_buf, BLOWFISH_BLOCK_SIZE);\n\tblowfish_decrypt(c3, enc_buf, &key);\n\tpass = pass && !memcmp(p3, enc_buf, BLOWFISH_BLOCK_SIZE);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"Blowfish tests: %s\\n\", blowfish_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        },
        {
          "name": "des.c",
          "type": "blob",
          "size": 12.3251953125,
          "content": "/*********************************************************************\n* Filename:   des.c\n* Author:     Brad Conte (brad AT radconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the DES encryption algorithm.\n              Modes of operation (such as CBC) are not included.\n              The formal NIST algorithm specification can be found here:\n               * http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"des.h\"\n\n/****************************** MACROS ******************************/\n// Obtain bit \"b\" from the left and shift it \"c\" places from the right\n#define BITNUM(a,b,c) (((a[(b)/8] >> (7 - (b%8))) & 0x01) << (c))\n#define BITNUMINTR(a,b,c) ((((a) >> (31 - (b))) & 0x00000001) << (c))\n#define BITNUMINTL(a,b,c) ((((a) << (b)) & 0x80000000) >> (c))\n\n// This macro converts a 6 bit block with the S-Box row defined as the first and last\n// bits to a 6 bit block with the row defined by the first two bits.\n#define SBOXBIT(a) (((a) & 0x20) | (((a) & 0x1f) >> 1) | (((a) & 0x01) << 4))\n\n/**************************** VARIABLES *****************************/\nstatic const BYTE sbox1[64] = {\n\t14,  4,  13,  1,   2, 15,  11,  8,   3, 10,   6, 12,   5,  9,   0,  7,\n\t 0, 15,   7,  4,  14,  2,  13,  1,  10,  6,  12, 11,   9,  5,   3,  8,\n\t 4,  1,  14,  8,  13,  6,   2, 11,  15, 12,   9,  7,   3, 10,   5,  0,\n\t15, 12,   8,  2,   4,  9,   1,  7,   5, 11,   3, 14,  10,  0,   6, 13\n};\nstatic const BYTE sbox2[64] = {\n\t15,  1,   8, 14,   6, 11,   3,  4,   9,  7,   2, 13,  12,  0,   5, 10,\n\t 3, 13,   4,  7,  15,  2,   8, 14,  12,  0,   1, 10,   6,  9,  11,  5,\n\t 0, 14,   7, 11,  10,  4,  13,  1,   5,  8,  12,  6,   9,  3,   2, 15,\n\t13,  8,  10,  1,   3, 15,   4,  2,  11,  6,   7, 12,   0,  5,  14,  9\n};\nstatic const BYTE sbox3[64] = {\n\t10,  0,   9, 14,   6,  3,  15,  5,   1, 13,  12,  7,  11,  4,   2,  8,\n\t13,  7,   0,  9,   3,  4,   6, 10,   2,  8,   5, 14,  12, 11,  15,  1,\n\t13,  6,   4,  9,   8, 15,   3,  0,  11,  1,   2, 12,   5, 10,  14,  7,\n\t 1, 10,  13,  0,   6,  9,   8,  7,   4, 15,  14,  3,  11,  5,   2, 12\n};\nstatic const BYTE sbox4[64] = {\n\t 7, 13,  14,  3,   0,  6,   9, 10,   1,  2,   8,  5,  11, 12,   4, 15,\n\t13,  8,  11,  5,   6, 15,   0,  3,   4,  7,   2, 12,   1, 10,  14,  9,\n\t10,  6,   9,  0,  12, 11,   7, 13,  15,  1,   3, 14,   5,  2,   8,  4,\n\t 3, 15,   0,  6,  10,  1,  13,  8,   9,  4,   5, 11,  12,  7,   2, 14\n};\nstatic const BYTE sbox5[64] = {\n\t 2, 12,   4,  1,   7, 10,  11,  6,   8,  5,   3, 15,  13,  0,  14,  9,\n\t14, 11,   2, 12,   4,  7,  13,  1,   5,  0,  15, 10,   3,  9,   8,  6,\n\t 4,  2,   1, 11,  10, 13,   7,  8,  15,  9,  12,  5,   6,  3,   0, 14,\n\t11,  8,  12,  7,   1, 14,   2, 13,   6, 15,   0,  9,  10,  4,   5,  3\n};\nstatic const BYTE sbox6[64] = {\n\t12,  1,  10, 15,   9,  2,   6,  8,   0, 13,   3,  4,  14,  7,   5, 11,\n\t10, 15,   4,  2,   7, 12,   9,  5,   6,  1,  13, 14,   0, 11,   3,  8,\n\t 9, 14,  15,  5,   2,  8,  12,  3,   7,  0,   4, 10,   1, 13,  11,  6,\n\t 4,  3,   2, 12,   9,  5,  15, 10,  11, 14,   1,  7,   6,  0,   8, 13\n};\nstatic const BYTE sbox7[64] = {\n\t 4, 11,   2, 14,  15,  0,   8, 13,   3, 12,   9,  7,   5, 10,   6,  1,\n\t13,  0,  11,  7,   4,  9,   1, 10,  14,  3,   5, 12,   2, 15,   8,  6,\n\t 1,  4,  11, 13,  12,  3,   7, 14,  10, 15,   6,  8,   0,  5,   9,  2,\n\t 6, 11,  13,  8,   1,  4,  10,  7,   9,  5,   0, 15,  14,  2,   3, 12\n};\nstatic const BYTE sbox8[64] = {\n\t13,  2,   8,  4,   6, 15,  11,  1,  10,  9,   3, 14,   5,  0,  12,  7,\n\t 1, 15,  13,  8,  10,  3,   7,  4,  12,  5,   6, 11,   0, 14,   9,  2,\n\t 7, 11,   4,  1,   9, 12,  14,  2,   0,  6,  10, 13,  15,  3,   5,  8,\n\t 2,  1,  14,  7,   4, 10,   8, 13,  15, 12,   9,  0,   3,  5,   6, 11\n};\n\n/*********************** FUNCTION DEFINITIONS ***********************/\n// Initial (Inv)Permutation step\nvoid IP(WORD state[], const BYTE in[])\n{\n\tstate[0] = BITNUM(in,57,31) | BITNUM(in,49,30) | BITNUM(in,41,29) | BITNUM(in,33,28) |\n\t\t\t\t  BITNUM(in,25,27) | BITNUM(in,17,26) | BITNUM(in,9,25) | BITNUM(in,1,24) |\n\t\t\t\t  BITNUM(in,59,23) | BITNUM(in,51,22) | BITNUM(in,43,21) | BITNUM(in,35,20) |\n\t\t\t\t  BITNUM(in,27,19) | BITNUM(in,19,18) | BITNUM(in,11,17) | BITNUM(in,3,16) |\n\t\t\t\t  BITNUM(in,61,15) | BITNUM(in,53,14) | BITNUM(in,45,13) | BITNUM(in,37,12) |\n\t\t\t\t  BITNUM(in,29,11) | BITNUM(in,21,10) | BITNUM(in,13,9) | BITNUM(in,5,8) |\n\t\t\t\t  BITNUM(in,63,7) | BITNUM(in,55,6) | BITNUM(in,47,5) | BITNUM(in,39,4) |\n\t\t\t\t  BITNUM(in,31,3) | BITNUM(in,23,2) | BITNUM(in,15,1) | BITNUM(in,7,0);\n\n\tstate[1] = BITNUM(in,56,31) | BITNUM(in,48,30) | BITNUM(in,40,29) | BITNUM(in,32,28) |\n\t\t\t\t  BITNUM(in,24,27) | BITNUM(in,16,26) | BITNUM(in,8,25) | BITNUM(in,0,24) |\n\t\t\t\t  BITNUM(in,58,23) | BITNUM(in,50,22) | BITNUM(in,42,21) | BITNUM(in,34,20) |\n\t\t\t\t  BITNUM(in,26,19) | BITNUM(in,18,18) | BITNUM(in,10,17) | BITNUM(in,2,16) |\n\t\t\t\t  BITNUM(in,60,15) | BITNUM(in,52,14) | BITNUM(in,44,13) | BITNUM(in,36,12) |\n\t\t\t\t  BITNUM(in,28,11) | BITNUM(in,20,10) | BITNUM(in,12,9) | BITNUM(in,4,8) |\n\t\t\t\t  BITNUM(in,62,7) | BITNUM(in,54,6) | BITNUM(in,46,5) | BITNUM(in,38,4) |\n\t\t\t\t  BITNUM(in,30,3) | BITNUM(in,22,2) | BITNUM(in,14,1) | BITNUM(in,6,0);\n}\n\nvoid InvIP(WORD state[], BYTE in[])\n{\n\tin[0] = BITNUMINTR(state[1],7,7) | BITNUMINTR(state[0],7,6) | BITNUMINTR(state[1],15,5) |\n\t\t\t  BITNUMINTR(state[0],15,4) | BITNUMINTR(state[1],23,3) | BITNUMINTR(state[0],23,2) |\n\t\t\t  BITNUMINTR(state[1],31,1) | BITNUMINTR(state[0],31,0);\n\n\tin[1] = BITNUMINTR(state[1],6,7) | BITNUMINTR(state[0],6,6) | BITNUMINTR(state[1],14,5) |\n\t\t\t  BITNUMINTR(state[0],14,4) | BITNUMINTR(state[1],22,3) | BITNUMINTR(state[0],22,2) |\n\t\t\t  BITNUMINTR(state[1],30,1) | BITNUMINTR(state[0],30,0);\n\n\tin[2] = BITNUMINTR(state[1],5,7) | BITNUMINTR(state[0],5,6) | BITNUMINTR(state[1],13,5) |\n\t\t\t  BITNUMINTR(state[0],13,4) | BITNUMINTR(state[1],21,3) | BITNUMINTR(state[0],21,2) |\n\t\t\t  BITNUMINTR(state[1],29,1) | BITNUMINTR(state[0],29,0);\n\n\tin[3] = BITNUMINTR(state[1],4,7) | BITNUMINTR(state[0],4,6) | BITNUMINTR(state[1],12,5) |\n\t\t\t  BITNUMINTR(state[0],12,4) | BITNUMINTR(state[1],20,3) | BITNUMINTR(state[0],20,2) |\n\t\t\t  BITNUMINTR(state[1],28,1) | BITNUMINTR(state[0],28,0);\n\n\tin[4] = BITNUMINTR(state[1],3,7) | BITNUMINTR(state[0],3,6) | BITNUMINTR(state[1],11,5) |\n\t\t\t  BITNUMINTR(state[0],11,4) | BITNUMINTR(state[1],19,3) | BITNUMINTR(state[0],19,2) |\n\t\t\t  BITNUMINTR(state[1],27,1) | BITNUMINTR(state[0],27,0);\n\n\tin[5] = BITNUMINTR(state[1],2,7) | BITNUMINTR(state[0],2,6) | BITNUMINTR(state[1],10,5) |\n\t\t\t  BITNUMINTR(state[0],10,4) | BITNUMINTR(state[1],18,3) | BITNUMINTR(state[0],18,2) |\n\t\t\t  BITNUMINTR(state[1],26,1) | BITNUMINTR(state[0],26,0);\n\n\tin[6] = BITNUMINTR(state[1],1,7) | BITNUMINTR(state[0],1,6) | BITNUMINTR(state[1],9,5) |\n\t\t\t  BITNUMINTR(state[0],9,4) | BITNUMINTR(state[1],17,3) | BITNUMINTR(state[0],17,2) |\n\t\t\t  BITNUMINTR(state[1],25,1) | BITNUMINTR(state[0],25,0);\n\n\tin[7] = BITNUMINTR(state[1],0,7) | BITNUMINTR(state[0],0,6) | BITNUMINTR(state[1],8,5) |\n\t\t\t  BITNUMINTR(state[0],8,4) | BITNUMINTR(state[1],16,3) | BITNUMINTR(state[0],16,2) |\n\t\t\t  BITNUMINTR(state[1],24,1) | BITNUMINTR(state[0],24,0);\n}\n\nWORD f(WORD state, const BYTE key[])\n{\n\tBYTE lrgstate[6]; //,i;\n\tWORD t1,t2;\n\n\t// Expantion Permutation\n\tt1 = BITNUMINTL(state,31,0) | ((state & 0xf0000000) >> 1) | BITNUMINTL(state,4,5) |\n\t\t  BITNUMINTL(state,3,6) | ((state & 0x0f000000) >> 3) | BITNUMINTL(state,8,11) |\n\t\t  BITNUMINTL(state,7,12) | ((state & 0x00f00000) >> 5) | BITNUMINTL(state,12,17) |\n\t\t  BITNUMINTL(state,11,18) | ((state & 0x000f0000) >> 7) | BITNUMINTL(state,16,23);\n\n\tt2 = BITNUMINTL(state,15,0) | ((state & 0x0000f000) << 15) | BITNUMINTL(state,20,5) |\n\t\t  BITNUMINTL(state,19,6) | ((state & 0x00000f00) << 13) | BITNUMINTL(state,24,11) |\n\t\t  BITNUMINTL(state,23,12) | ((state & 0x000000f0) << 11) | BITNUMINTL(state,28,17) |\n\t\t  BITNUMINTL(state,27,18) | ((state & 0x0000000f) << 9) | BITNUMINTL(state,0,23);\n\n\tlrgstate[0] = (t1 >> 24) & 0x000000ff;\n\tlrgstate[1] = (t1 >> 16) & 0x000000ff;\n\tlrgstate[2] = (t1 >> 8) & 0x000000ff;\n\tlrgstate[3] = (t2 >> 24) & 0x000000ff;\n\tlrgstate[4] = (t2 >> 16) & 0x000000ff;\n\tlrgstate[5] = (t2 >> 8) & 0x000000ff;\n\n\t// Key XOR\n\tlrgstate[0] ^= key[0];\n\tlrgstate[1] ^= key[1];\n\tlrgstate[2] ^= key[2];\n\tlrgstate[3] ^= key[3];\n\tlrgstate[4] ^= key[4];\n\tlrgstate[5] ^= key[5];\n\n\t// S-Box Permutation\n\tstate = (sbox1[SBOXBIT(lrgstate[0] >> 2)] << 28) |\n\t\t\t  (sbox2[SBOXBIT(((lrgstate[0] & 0x03) << 4) | (lrgstate[1] >> 4))] << 24) |\n\t\t\t  (sbox3[SBOXBIT(((lrgstate[1] & 0x0f) << 2) | (lrgstate[2] >> 6))] << 20) |\n\t\t\t  (sbox4[SBOXBIT(lrgstate[2] & 0x3f)] << 16) |\n\t\t\t  (sbox5[SBOXBIT(lrgstate[3] >> 2)] << 12) |\n\t\t\t  (sbox6[SBOXBIT(((lrgstate[3] & 0x03) << 4) | (lrgstate[4] >> 4))] << 8) |\n\t\t\t  (sbox7[SBOXBIT(((lrgstate[4] & 0x0f) << 2) | (lrgstate[5] >> 6))] << 4) |\n\t\t\t\tsbox8[SBOXBIT(lrgstate[5] & 0x3f)];\n\n\t// P-Box Permutation\n\tstate = BITNUMINTL(state,15,0) | BITNUMINTL(state,6,1) | BITNUMINTL(state,19,2) |\n\t\t\t  BITNUMINTL(state,20,3) | BITNUMINTL(state,28,4) | BITNUMINTL(state,11,5) |\n\t\t\t  BITNUMINTL(state,27,6) | BITNUMINTL(state,16,7) | BITNUMINTL(state,0,8) |\n\t\t\t  BITNUMINTL(state,14,9) | BITNUMINTL(state,22,10) | BITNUMINTL(state,25,11) |\n\t\t\t  BITNUMINTL(state,4,12) | BITNUMINTL(state,17,13) | BITNUMINTL(state,30,14) |\n\t\t\t  BITNUMINTL(state,9,15) | BITNUMINTL(state,1,16) | BITNUMINTL(state,7,17) |\n\t\t\t  BITNUMINTL(state,23,18) | BITNUMINTL(state,13,19) | BITNUMINTL(state,31,20) |\n\t\t\t  BITNUMINTL(state,26,21) | BITNUMINTL(state,2,22) | BITNUMINTL(state,8,23) |\n\t\t\t  BITNUMINTL(state,18,24) | BITNUMINTL(state,12,25) | BITNUMINTL(state,29,26) |\n\t\t\t  BITNUMINTL(state,5,27) | BITNUMINTL(state,21,28) | BITNUMINTL(state,10,29) |\n\t\t\t  BITNUMINTL(state,3,30) | BITNUMINTL(state,24,31);\n\n\t// Return the final state value\n\treturn(state);\n}\n\nvoid des_key_setup(const BYTE key[], BYTE schedule[][6], DES_MODE mode)\n{\n\tWORD i, j, to_gen, C, D;\n\tconst WORD key_rnd_shift[16] = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};\n\tconst WORD key_perm_c[28] = {56,48,40,32,24,16,8,0,57,49,41,33,25,17,\n\t                             9,1,58,50,42,34,26,18,10,2,59,51,43,35};\n\tconst WORD key_perm_d[28] = {62,54,46,38,30,22,14,6,61,53,45,37,29,21,\n\t                             13,5,60,52,44,36,28,20,12,4,27,19,11,3};\n\tconst WORD key_compression[48] = {13,16,10,23,0,4,2,27,14,5,20,9,\n\t                                  22,18,11,3,25,7,15,6,26,19,12,1,\n\t                                  40,51,30,36,46,54,29,39,50,44,32,47,\n\t                                  43,48,38,55,33,52,45,41,49,35,28,31};\n\n\t// Permutated Choice #1 (copy the key in, ignoring parity bits).\n\tfor (i = 0, j = 31, C = 0; i < 28; ++i, --j)\n\t\tC |= BITNUM(key,key_perm_c[i],j);\n\tfor (i = 0, j = 31, D = 0; i < 28; ++i, --j)\n\t\tD |= BITNUM(key,key_perm_d[i],j);\n\n\t// Generate the 16 subkeys.\n\tfor (i = 0; i < 16; ++i) {\n\t\tC = ((C << key_rnd_shift[i]) | (C >> (28-key_rnd_shift[i]))) & 0xfffffff0;\n\t\tD = ((D << key_rnd_shift[i]) | (D >> (28-key_rnd_shift[i]))) & 0xfffffff0;\n\n\t\t// Decryption subkeys are reverse order of encryption subkeys so\n\t\t// generate them in reverse if the key schedule is for decryption useage.\n\t\tif (mode == DES_DECRYPT)\n\t\t\tto_gen = 15 - i;\n\t\telse /*(if mode == DES_ENCRYPT)*/\n\t\t\tto_gen = i;\n\t\t// Initialize the array\n\t\tfor (j = 0; j < 6; ++j)\n\t\t\tschedule[to_gen][j] = 0;\n\t\tfor (j = 0; j < 24; ++j)\n\t\t\tschedule[to_gen][j/8] |= BITNUMINTR(C,key_compression[j],7 - (j%8));\n\t\tfor ( ; j < 48; ++j)\n\t\t\tschedule[to_gen][j/8] |= BITNUMINTR(D,key_compression[j] - 28,7 - (j%8));\n\t}\n}\n\nvoid des_crypt(const BYTE in[], BYTE out[], const BYTE key[][6])\n{\n\tWORD state[2],idx,t;\n\n\tIP(state,in);\n\n\tfor (idx=0; idx < 15; ++idx) {\n\t\tt = state[1];\n\t\tstate[1] = f(state[1],key[idx]) ^ state[0];\n\t\tstate[0] = t;\n\t}\n\t// Perform the final loop manually as it doesn't switch sides\n\tstate[0] = f(state[1],key[15]) ^ state[0];\n\n\tInvIP(state,out);\n}\n\nvoid three_des_key_setup(const BYTE key[], BYTE schedule[][16][6], DES_MODE mode)\n{\n\tif (mode == DES_ENCRYPT) {\n\t\tdes_key_setup(&key[0],schedule[0],mode);\n\t\tdes_key_setup(&key[8],schedule[1],!mode);\n\t\tdes_key_setup(&key[16],schedule[2],mode);\n\t}\n\telse /*if (mode == DES_DECRYPT*/ {\n\t\tdes_key_setup(&key[16],schedule[0],mode);\n\t\tdes_key_setup(&key[8],schedule[1],!mode);\n\t\tdes_key_setup(&key[0],schedule[2],mode);\n\t}\n}\n\nvoid three_des_crypt(const BYTE in[], BYTE out[], const BYTE key[][16][6])\n{\n\tdes_crypt(in,out,key[0]);\n\tdes_crypt(out,out,key[1]);\n\tdes_crypt(out,out,key[2]);\n}\n"
        },
        {
          "name": "des.h",
          "type": "blob",
          "size": 1.44921875,
          "content": "/*********************************************************************\n* Filename:   des.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding DES implementation.\n              Note that encryption and decryption are defined by how\n              the key setup is performed, the actual en/de-cryption is\n              performed by the same function.\n*********************************************************************/\n\n#ifndef DES_H\n#define DESH\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/****************************** MACROS ******************************/\n#define DES_BLOCK_SIZE 8                // DES operates on 8 bytes at a time\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\ntypedef unsigned int  WORD;             // 32-bit word, change to \"long\" for 16-bit machines\n\ntypedef enum {\n\tDES_ENCRYPT,\n\tDES_DECRYPT\n} DES_MODE;\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid des_key_setup(const BYTE key[], BYTE schedule[][6], DES_MODE mode);\nvoid des_crypt(const BYTE in[], BYTE out[], const BYTE key[][6]);\n\nvoid three_des_key_setup(const BYTE key[], BYTE schedule[][16][6], DES_MODE mode);\nvoid three_des_crypt(const BYTE in[], BYTE out[], const BYTE key[][16][6]);\n\n#endif   // DES_H\n"
        },
        {
          "name": "des_test.c",
          "type": "blob",
          "size": 3.294921875,
          "content": "/*********************************************************************\n* Filename:   des_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding DES\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include \"des.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint des_test()\n{\n\tBYTE pt1[DES_BLOCK_SIZE] = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xE7};\n\tBYTE pt2[DES_BLOCK_SIZE] = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF};\n\tBYTE pt3[DES_BLOCK_SIZE] = {0x54,0x68,0x65,0x20,0x71,0x75,0x66,0x63};\n\tBYTE ct1[DES_BLOCK_SIZE] = {0xc9,0x57,0x44,0x25,0x6a,0x5e,0xd3,0x1d};\n\tBYTE ct2[DES_BLOCK_SIZE] = {0x85,0xe8,0x13,0x54,0x0f,0x0a,0xb4,0x05};\n\tBYTE ct3[DES_BLOCK_SIZE] = {0xc9,0x57,0x44,0x25,0x6a,0x5e,0xd3,0x1d};\n\tBYTE ct4[DES_BLOCK_SIZE] = {0xA8,0x26,0xFD,0x8C,0xE5,0x3B,0x85,0x5F};\n\tBYTE key1[DES_BLOCK_SIZE] = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF};\n\tBYTE key2[DES_BLOCK_SIZE] = {0x13,0x34,0x57,0x79,0x9B,0xBC,0xDF,0xF1};\n\tBYTE three_key1[DES_BLOCK_SIZE * 3] = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t                                       0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t                                       0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF};\n\tBYTE three_key2[DES_BLOCK_SIZE * 3] = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,\n\t                                       0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,\n\t                                       0x45,0x67,0x89,0xAB,0xCD,0xEF,0x01,0x23};\n\n\tBYTE schedule[16][6];\n\tBYTE three_schedule[3][16][6];\n\tBYTE buf[DES_BLOCK_SIZE];\n\tint pass = 1;\n\n\tdes_key_setup(key1, schedule, DES_ENCRYPT);\n\tdes_crypt(pt1, buf, schedule);\n\tpass = pass && !memcmp(ct1, buf, DES_BLOCK_SIZE);\n\n\tdes_key_setup(key1, schedule, DES_DECRYPT);\n\tdes_crypt(ct1, buf, schedule);\n\tpass = pass && !memcmp(pt1, buf, DES_BLOCK_SIZE);\n\n\tdes_key_setup(key2, schedule, DES_ENCRYPT);\n\tdes_crypt(pt2, buf, schedule);\n\tpass = pass && !memcmp(ct2, buf, DES_BLOCK_SIZE);\n\n\tdes_key_setup(key2, schedule, DES_DECRYPT);\n\tdes_crypt(ct2, buf, schedule);\n\tpass = pass && !memcmp(pt2, buf, DES_BLOCK_SIZE);\n\n\tthree_des_key_setup(three_key1, three_schedule, DES_ENCRYPT);\n\tthree_des_crypt(pt1, buf, three_schedule);\n\tpass = pass && !memcmp(ct3, buf, DES_BLOCK_SIZE);\n\n\tthree_des_key_setup(three_key1, three_schedule, DES_DECRYPT);\n\tthree_des_crypt(ct3, buf, three_schedule);\n\tpass = pass && !memcmp(pt1, buf, DES_BLOCK_SIZE);\n\n\tthree_des_key_setup(three_key2, three_schedule, DES_ENCRYPT);\n\tthree_des_crypt(pt3, buf, three_schedule);\n\tpass = pass && !memcmp(ct4, buf, DES_BLOCK_SIZE);\n\n\tthree_des_key_setup(three_key2, three_schedule, DES_DECRYPT);\n\tthree_des_crypt(ct4, buf, three_schedule);\n\tpass = pass && !memcmp(pt3, buf, DES_BLOCK_SIZE);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"DES test: %s\\n\", des_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        },
        {
          "name": "md2.c",
          "type": "blob",
          "size": 3.068359375,
          "content": "/*********************************************************************\n* Filename:   md2.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the MD2 hashing algorithm.\n\t\t\t\t  Algorithm specification can be found here:\n\t\t\t\t   * http://tools.ietf.org/html/rfc1319 .\n              Input is  little endian byte order.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"md2.h\"\n\n/**************************** VARIABLES *****************************/\nstatic const BYTE s[256] = {\n\t41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6,\n\t19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188,\n\t76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24,\n\t138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251,\n\t245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63,\n\t148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50,\n\t39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165,\n\t181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210,\n\t150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157,\n\t112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27,\n\t96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15,\n\t85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197,\n\t234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65,\n\t129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123,\n\t8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233,\n\t203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228,\n\t166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237,\n\t31, 26, 219, 153, 141, 51, 159, 17, 131, 20\n};\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid md2_transform(MD2_CTX *ctx, BYTE data[])\n{\n\tint j,k,t;\n\n\t//memcpy(&ctx->state[16], data);\n\tfor (j=0; j < 16; ++j) {\n\t\tctx->state[j + 16] = data[j];\n\t\tctx->state[j + 32] = (ctx->state[j+16] ^ ctx->state[j]);\n\t}\n\n\tt = 0;\n\tfor (j = 0; j < 18; ++j) {\n\t\tfor (k = 0; k < 48; ++k) {\n\t\t\tctx->state[k] ^= s[t];\n\t\t\tt = ctx->state[k];\n\t\t}\n\t\tt = (t+j) & 0xFF;\n\t}\n\n\tt = ctx->checksum[15];\n\tfor (j=0; j < 16; ++j) {\n\t\tctx->checksum[j] ^= s[data[j] ^ t];\n\t\tt = ctx->checksum[j];\n\t}\n}\n\nvoid md2_init(MD2_CTX *ctx)\n{\n\tint i;\n\n\tfor (i=0; i < 48; ++i)\n\t\tctx->state[i] = 0;\n\tfor (i=0; i < 16; ++i)\n\t\tctx->checksum[i] = 0;\n\tctx->len = 0;\n}\n\nvoid md2_update(MD2_CTX *ctx, const BYTE data[], size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tctx->data[ctx->len] = data[i];\n\t\tctx->len++;\n\t\tif (ctx->len == MD2_BLOCK_SIZE) {\n\t\t\tmd2_transform(ctx, ctx->data);\n\t\t\tctx->len = 0;\n\t\t}\n\t}\n}\n\nvoid md2_final(MD2_CTX *ctx, BYTE hash[])\n{\n\tint to_pad;\n\n\tto_pad = MD2_BLOCK_SIZE - ctx->len;\n\n\twhile (ctx->len < MD2_BLOCK_SIZE)\n\t\tctx->data[ctx->len++] = to_pad;\n\n\tmd2_transform(ctx, ctx->data);\n\tmd2_transform(ctx, ctx->checksum);\n\n\tmemcpy(hash, ctx->state, MD2_BLOCK_SIZE);\n}\n"
        },
        {
          "name": "md2.h",
          "type": "blob",
          "size": 1.05078125,
          "content": "/*********************************************************************\n* Filename:   md2.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding MD2 implementation.\n*********************************************************************/\n\n#ifndef MD2_H\n#define MD2_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/****************************** MACROS ******************************/\n#define MD2_BLOCK_SIZE 16\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\n\ntypedef struct {\n   BYTE data[16];\n   BYTE state[48];\n   BYTE checksum[16];\n   int len;\n} MD2_CTX;\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid md2_init(MD2_CTX *ctx);\nvoid md2_update(MD2_CTX *ctx, const BYTE data[], size_t len);\nvoid md2_final(MD2_CTX *ctx, BYTE hash[]);   // size of hash must be MD2_BLOCK_SIZE\n\n#endif   // MD2_H\n"
        },
        {
          "name": "md2_test.c",
          "type": "blob",
          "size": 2.0654296875,
          "content": "/*********************************************************************\n* Filename:   md2_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding MD2\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <string.h>\n#include <memory.h>\n#include \"md2.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint md2_test()\n{\n\tBYTE text1[] = {\"abc\"};\n\tBYTE text2[] = {\"abcdefghijklmnopqrstuvwxyz\"};\n\tBYTE text3_1[] = {\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcde\"};\n\tBYTE text3_2[] = {\"fghijklmnopqrstuvwxyz0123456789\"};\n\tBYTE hash1[MD2_BLOCK_SIZE] = {0xda,0x85,0x3b,0x0d,0x3f,0x88,0xd9,0x9b,0x30,0x28,0x3a,0x69,0xe6,0xde,0xd6,0xbb};\n\tBYTE hash2[MD2_BLOCK_SIZE] = {0x4e,0x8d,0xdf,0xf3,0x65,0x02,0x92,0xab,0x5a,0x41,0x08,0xc3,0xaa,0x47,0x94,0x0b};\n\tBYTE hash3[MD2_BLOCK_SIZE] = {0xda,0x33,0xde,0xf2,0xa4,0x2d,0xf1,0x39,0x75,0x35,0x28,0x46,0xc3,0x03,0x38,0xcd};\n\tBYTE buf[16];\n\tMD2_CTX ctx;\n\tint pass = 1;\n\n\tmd2_init(&ctx);\n\tmd2_update(&ctx, text1, strlen(text1));\n\tmd2_final(&ctx, buf);\n\tpass = pass && !memcmp(hash1, buf, MD2_BLOCK_SIZE);\n\n\t// Note that the MD2 object can be re-used.\n\tmd2_init(&ctx);\n\tmd2_update(&ctx, text2, strlen(text2));\n\tmd2_final(&ctx, buf);\n\tpass = pass && !memcmp(hash2, buf, MD2_BLOCK_SIZE);\n\n\t// Note that the data is added in two chunks.\n\tmd2_init(&ctx);\n\tmd2_update(&ctx, text3_1, strlen(text3_1));\n\tmd2_update(&ctx, text3_2, strlen(text3_2));\n\tmd2_final(&ctx, buf);\n\tpass = pass && !memcmp(hash3, buf, MD2_BLOCK_SIZE);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"MD2 tests: %s\\n\", md2_test() ? \"SUCCEEDED\" : \"FAILED\");\n}\n"
        },
        {
          "name": "md5.c",
          "type": "blob",
          "size": 5.6953125,
          "content": "/*********************************************************************\n* Filename:   md5.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the MD5 hashing algorithm.\n\t\t\t\t  Algorithm specification can be found here:\n\t\t\t\t   * http://tools.ietf.org/html/rfc1321\n\t\t\t\t  This implementation uses little endian byte order.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"md5.h\"\n\n/****************************** MACROS ******************************/\n#define ROTLEFT(a,b) ((a << b) | (a >> (32-b)))\n\n#define F(x,y,z) ((x & y) | (~x & z))\n#define G(x,y,z) ((x & z) | (y & ~z))\n#define H(x,y,z) (x ^ y ^ z)\n#define I(x,y,z) (y ^ (x | ~z))\n\n#define FF(a,b,c,d,m,s,t) { a += F(b,c,d) + m + t; \\\n                            a = b + ROTLEFT(a,s); }\n#define GG(a,b,c,d,m,s,t) { a += G(b,c,d) + m + t; \\\n                            a = b + ROTLEFT(a,s); }\n#define HH(a,b,c,d,m,s,t) { a += H(b,c,d) + m + t; \\\n                            a = b + ROTLEFT(a,s); }\n#define II(a,b,c,d,m,s,t) { a += I(b,c,d) + m + t; \\\n                            a = b + ROTLEFT(a,s); }\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid md5_transform(MD5_CTX *ctx, const BYTE data[])\n{\n\tWORD a, b, c, d, m[16], i, j;\n\n\t// MD5 specifies big endian byte order, but this implementation assumes a little\n\t// endian byte order CPU. Reverse all the bytes upon input, and re-reverse them\n\t// on output (in md5_final()).\n\tfor (i = 0, j = 0; i < 16; ++i, j += 4)\n\t\tm[i] = (data[j]) + (data[j + 1] << 8) + (data[j + 2] << 16) + (data[j + 3] << 24);\n\n\ta = ctx->state[0];\n\tb = ctx->state[1];\n\tc = ctx->state[2];\n\td = ctx->state[3];\n\n\tFF(a,b,c,d,m[0],  7,0xd76aa478);\n\tFF(d,a,b,c,m[1], 12,0xe8c7b756);\n\tFF(c,d,a,b,m[2], 17,0x242070db);\n\tFF(b,c,d,a,m[3], 22,0xc1bdceee);\n\tFF(a,b,c,d,m[4],  7,0xf57c0faf);\n\tFF(d,a,b,c,m[5], 12,0x4787c62a);\n\tFF(c,d,a,b,m[6], 17,0xa8304613);\n\tFF(b,c,d,a,m[7], 22,0xfd469501);\n\tFF(a,b,c,d,m[8],  7,0x698098d8);\n\tFF(d,a,b,c,m[9], 12,0x8b44f7af);\n\tFF(c,d,a,b,m[10],17,0xffff5bb1);\n\tFF(b,c,d,a,m[11],22,0x895cd7be);\n\tFF(a,b,c,d,m[12], 7,0x6b901122);\n\tFF(d,a,b,c,m[13],12,0xfd987193);\n\tFF(c,d,a,b,m[14],17,0xa679438e);\n\tFF(b,c,d,a,m[15],22,0x49b40821);\n\n\tGG(a,b,c,d,m[1],  5,0xf61e2562);\n\tGG(d,a,b,c,m[6],  9,0xc040b340);\n\tGG(c,d,a,b,m[11],14,0x265e5a51);\n\tGG(b,c,d,a,m[0], 20,0xe9b6c7aa);\n\tGG(a,b,c,d,m[5],  5,0xd62f105d);\n\tGG(d,a,b,c,m[10], 9,0x02441453);\n\tGG(c,d,a,b,m[15],14,0xd8a1e681);\n\tGG(b,c,d,a,m[4], 20,0xe7d3fbc8);\n\tGG(a,b,c,d,m[9],  5,0x21e1cde6);\n\tGG(d,a,b,c,m[14], 9,0xc33707d6);\n\tGG(c,d,a,b,m[3], 14,0xf4d50d87);\n\tGG(b,c,d,a,m[8], 20,0x455a14ed);\n\tGG(a,b,c,d,m[13], 5,0xa9e3e905);\n\tGG(d,a,b,c,m[2],  9,0xfcefa3f8);\n\tGG(c,d,a,b,m[7], 14,0x676f02d9);\n\tGG(b,c,d,a,m[12],20,0x8d2a4c8a);\n\n\tHH(a,b,c,d,m[5],  4,0xfffa3942);\n\tHH(d,a,b,c,m[8], 11,0x8771f681);\n\tHH(c,d,a,b,m[11],16,0x6d9d6122);\n\tHH(b,c,d,a,m[14],23,0xfde5380c);\n\tHH(a,b,c,d,m[1],  4,0xa4beea44);\n\tHH(d,a,b,c,m[4], 11,0x4bdecfa9);\n\tHH(c,d,a,b,m[7], 16,0xf6bb4b60);\n\tHH(b,c,d,a,m[10],23,0xbebfbc70);\n\tHH(a,b,c,d,m[13], 4,0x289b7ec6);\n\tHH(d,a,b,c,m[0], 11,0xeaa127fa);\n\tHH(c,d,a,b,m[3], 16,0xd4ef3085);\n\tHH(b,c,d,a,m[6], 23,0x04881d05);\n\tHH(a,b,c,d,m[9],  4,0xd9d4d039);\n\tHH(d,a,b,c,m[12],11,0xe6db99e5);\n\tHH(c,d,a,b,m[15],16,0x1fa27cf8);\n\tHH(b,c,d,a,m[2], 23,0xc4ac5665);\n\n\tII(a,b,c,d,m[0],  6,0xf4292244);\n\tII(d,a,b,c,m[7], 10,0x432aff97);\n\tII(c,d,a,b,m[14],15,0xab9423a7);\n\tII(b,c,d,a,m[5], 21,0xfc93a039);\n\tII(a,b,c,d,m[12], 6,0x655b59c3);\n\tII(d,a,b,c,m[3], 10,0x8f0ccc92);\n\tII(c,d,a,b,m[10],15,0xffeff47d);\n\tII(b,c,d,a,m[1], 21,0x85845dd1);\n\tII(a,b,c,d,m[8],  6,0x6fa87e4f);\n\tII(d,a,b,c,m[15],10,0xfe2ce6e0);\n\tII(c,d,a,b,m[6], 15,0xa3014314);\n\tII(b,c,d,a,m[13],21,0x4e0811a1);\n\tII(a,b,c,d,m[4],  6,0xf7537e82);\n\tII(d,a,b,c,m[11],10,0xbd3af235);\n\tII(c,d,a,b,m[2], 15,0x2ad7d2bb);\n\tII(b,c,d,a,m[9], 21,0xeb86d391);\n\n\tctx->state[0] += a;\n\tctx->state[1] += b;\n\tctx->state[2] += c;\n\tctx->state[3] += d;\n}\n\nvoid md5_init(MD5_CTX *ctx)\n{\n\tctx->datalen = 0;\n\tctx->bitlen = 0;\n\tctx->state[0] = 0x67452301;\n\tctx->state[1] = 0xEFCDAB89;\n\tctx->state[2] = 0x98BADCFE;\n\tctx->state[3] = 0x10325476;\n}\n\nvoid md5_update(MD5_CTX *ctx, const BYTE data[], size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tctx->data[ctx->datalen] = data[i];\n\t\tctx->datalen++;\n\t\tif (ctx->datalen == 64) {\n\t\t\tmd5_transform(ctx, ctx->data);\n\t\t\tctx->bitlen += 512;\n\t\t\tctx->datalen = 0;\n\t\t}\n\t}\n}\n\nvoid md5_final(MD5_CTX *ctx, BYTE hash[])\n{\n\tsize_t i;\n\n\ti = ctx->datalen;\n\n\t// Pad whatever data is left in the buffer.\n\tif (ctx->datalen < 56) {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 56)\n\t\t\tctx->data[i++] = 0x00;\n\t}\n\telse if (ctx->datalen >= 56) {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 64)\n\t\t\tctx->data[i++] = 0x00;\n\t\tmd5_transform(ctx, ctx->data);\n\t\tmemset(ctx->data, 0, 56);\n\t}\n\n\t// Append to the padding the total message's length in bits and transform.\n\tctx->bitlen += ctx->datalen * 8;\n\tctx->data[56] = ctx->bitlen;\n\tctx->data[57] = ctx->bitlen >> 8;\n\tctx->data[58] = ctx->bitlen >> 16;\n\tctx->data[59] = ctx->bitlen >> 24;\n\tctx->data[60] = ctx->bitlen >> 32;\n\tctx->data[61] = ctx->bitlen >> 40;\n\tctx->data[62] = ctx->bitlen >> 48;\n\tctx->data[63] = ctx->bitlen >> 56;\n\tmd5_transform(ctx, ctx->data);\n\n\t// Since this implementation uses little endian byte ordering and MD uses big endian,\n\t// reverse all the bytes when copying the final state to the output hash.\n\tfor (i = 0; i < 4; ++i) {\n\t\thash[i]      = (ctx->state[0] >> (i * 8)) & 0x000000ff;\n\t\thash[i + 4]  = (ctx->state[1] >> (i * 8)) & 0x000000ff;\n\t\thash[i + 8]  = (ctx->state[2] >> (i * 8)) & 0x000000ff;\n\t\thash[i + 12] = (ctx->state[3] >> (i * 8)) & 0x000000ff;\n\t}\n}\n"
        },
        {
          "name": "md5.h",
          "type": "blob",
          "size": 1.158203125,
          "content": "/*********************************************************************\n* Filename:   md5.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding MD5 implementation.\n*********************************************************************/\n\n#ifndef MD5_H\n#define MD5_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/****************************** MACROS ******************************/\n#define MD5_BLOCK_SIZE 16               // MD5 outputs a 16 byte digest\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\ntypedef unsigned int  WORD;             // 32-bit word, change to \"long\" for 16-bit machines\n\ntypedef struct {\n   BYTE data[64];\n   WORD datalen;\n   unsigned long long bitlen;\n   WORD state[4];\n} MD5_CTX;\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid md5_init(MD5_CTX *ctx);\nvoid md5_update(MD5_CTX *ctx, const BYTE data[], size_t len);\nvoid md5_final(MD5_CTX *ctx, BYTE hash[]);\n\n#endif   // MD5_H\n"
        },
        {
          "name": "md5_test.c",
          "type": "blob",
          "size": 2.0478515625,
          "content": "/*********************************************************************\n* Filename:   md5_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding MD5\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include <string.h>\n#include \"md5.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint md5_test()\n{\n\tBYTE text1[] = {\"\"};\n\tBYTE text2[] = {\"abc\"};\n\tBYTE text3_1[] = {\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcde\"};\n\tBYTE text3_2[] = {\"fghijklmnopqrstuvwxyz0123456789\"};\n\tBYTE hash1[MD5_BLOCK_SIZE] = {0xd4,0x1d,0x8c,0xd9,0x8f,0x00,0xb2,0x04,0xe9,0x80,0x09,0x98,0xec,0xf8,0x42,0x7e};\n\tBYTE hash2[MD5_BLOCK_SIZE] = {0x90,0x01,0x50,0x98,0x3c,0xd2,0x4f,0xb0,0xd6,0x96,0x3f,0x7d,0x28,0xe1,0x7f,0x72};\n\tBYTE hash3[MD5_BLOCK_SIZE] = {0xd1,0x74,0xab,0x98,0xd2,0x77,0xd9,0xf5,0xa5,0x61,0x1c,0x2c,0x9f,0x41,0x9d,0x9f};\n\tBYTE buf[16];\n\tMD5_CTX ctx;\n\tint pass = 1;\n\n\tmd5_init(&ctx);\n\tmd5_update(&ctx, text1, strlen(text1));\n\tmd5_final(&ctx, buf);\n\tpass = pass && !memcmp(hash1, buf, MD5_BLOCK_SIZE);\n\n\t// Note the MD5 object can be reused.\n\tmd5_init(&ctx);\n\tmd5_update(&ctx, text2, strlen(text2));\n\tmd5_final(&ctx, buf);\n\tpass = pass && !memcmp(hash2, buf, MD5_BLOCK_SIZE);\n\n\t// Note the data is being added in two chunks.\n\tmd5_init(&ctx);\n\tmd5_update(&ctx, text3_1, strlen(text3_1));\n\tmd5_update(&ctx, text3_2, strlen(text3_2));\n\tmd5_final(&ctx, buf);\n\tpass = pass && !memcmp(hash3, buf, MD5_BLOCK_SIZE);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"MD5 tests: %s\\n\", md5_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        },
        {
          "name": "rot-13.c",
          "type": "blob",
          "size": 1.2353515625,
          "content": "/*********************************************************************\n* Filename:   rot-13.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the ROT-13 encryption algorithm.\n\t\t\t\t  Algorithm specification can be found here:\n\t\t\t\t   *\n\t\t\t\t  This implementation uses little endian byte order.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <string.h>\n#include \"rot-13.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid rot13(char str[])\n{\n   int case_type, idx, len;\n\n   for (idx = 0, len = strlen(str); idx < len; idx++) {\n      // Only process alphabetic characters.\n      if (str[idx] < 'A' || (str[idx] > 'Z' && str[idx] < 'a') || str[idx] > 'z')\n         continue;\n      // Determine if the char is upper or lower case.\n      if (str[idx] >= 'a')\n         case_type = 'a';\n      else\n         case_type = 'A';\n      // Rotate the char's value, ensuring it doesn't accidentally \"fall off\" the end.\n      str[idx] = (str[idx] + 13) % (case_type + 26);\n      if (str[idx] < 26)\n         str[idx] += case_type;\n   }\n}\n"
        },
        {
          "name": "rot-13.h",
          "type": "blob",
          "size": 0.7431640625,
          "content": "/*********************************************************************\n* Filename:   rot-13.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding ROT-13 implementation.\n*********************************************************************/\n\n#ifndef ROT13_H\n#define ROT13_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/*********************** FUNCTION DECLARATIONS **********************/\n// Performs IN PLACE rotation of the input. Assumes input is NULL terminated.\n// Preserves each charcter's case. Ignores non alphabetic characters.\nvoid rot13(char str[]);\n\n#endif   // ROT13_H\n"
        },
        {
          "name": "rot-13_test.c",
          "type": "blob",
          "size": 1.3486328125,
          "content": "/*********************************************************************\n* Filename:   rot-13_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding ROT-13\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <string.h>\n#include \"rot-13.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint rot13_test()\n{\n\tchar text[] = {\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"};\n\tchar code[] = {\"NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\"};\n\tchar buf[1024];\n\tint pass = 1;\n\n\t// To encode, just apply ROT-13.\n\tstrcpy(buf, text);\n\trot13(buf);\n\tpass = pass && !strcmp(code, buf);\n\n\t// To decode, just re-apply ROT-13.\n\trot13(buf);\n\tpass = pass && !strcmp(text, buf);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"ROT-13 tests: %s\\n\", rot13_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        },
        {
          "name": "sha1.c",
          "type": "blob",
          "size": 3.8486328125,
          "content": "/*********************************************************************\n* Filename:   sha1.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the SHA1 hashing algorithm.\n              Algorithm specification can be found here:\n               * http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf\n              This implementation uses little endian byte order.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"sha1.h\"\n\n/****************************** MACROS ******************************/\n#define ROTLEFT(a, b) ((a << b) | (a >> (32 - b)))\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid sha1_transform(SHA1_CTX *ctx, const BYTE data[])\n{\n\tWORD a, b, c, d, e, i, j, t, m[80];\n\n\tfor (i = 0, j = 0; i < 16; ++i, j += 4)\n\t\tm[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 8) + (data[j + 3]);\n\tfor ( ; i < 80; ++i) {\n\t\tm[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]);\n\t\tm[i] = (m[i] << 1) | (m[i] >> 31);\n\t}\n\n\ta = ctx->state[0];\n\tb = ctx->state[1];\n\tc = ctx->state[2];\n\td = ctx->state[3];\n\te = ctx->state[4];\n\n\tfor (i = 0; i < 20; ++i) {\n\t\tt = ROTLEFT(a, 5) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i];\n\t\te = d;\n\t\td = c;\n\t\tc = ROTLEFT(b, 30);\n\t\tb = a;\n\t\ta = t;\n\t}\n\tfor ( ; i < 40; ++i) {\n\t\tt = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[1] + m[i];\n\t\te = d;\n\t\td = c;\n\t\tc = ROTLEFT(b, 30);\n\t\tb = a;\n\t\ta = t;\n\t}\n\tfor ( ; i < 60; ++i) {\n\t\tt = ROTLEFT(a, 5) + ((b & c) ^ (b & d) ^ (c & d))  + e + ctx->k[2] + m[i];\n\t\te = d;\n\t\td = c;\n\t\tc = ROTLEFT(b, 30);\n\t\tb = a;\n\t\ta = t;\n\t}\n\tfor ( ; i < 80; ++i) {\n\t\tt = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[3] + m[i];\n\t\te = d;\n\t\td = c;\n\t\tc = ROTLEFT(b, 30);\n\t\tb = a;\n\t\ta = t;\n\t}\n\n\tctx->state[0] += a;\n\tctx->state[1] += b;\n\tctx->state[2] += c;\n\tctx->state[3] += d;\n\tctx->state[4] += e;\n}\n\nvoid sha1_init(SHA1_CTX *ctx)\n{\n\tctx->datalen = 0;\n\tctx->bitlen = 0;\n\tctx->state[0] = 0x67452301;\n\tctx->state[1] = 0xEFCDAB89;\n\tctx->state[2] = 0x98BADCFE;\n\tctx->state[3] = 0x10325476;\n\tctx->state[4] = 0xc3d2e1f0;\n\tctx->k[0] = 0x5a827999;\n\tctx->k[1] = 0x6ed9eba1;\n\tctx->k[2] = 0x8f1bbcdc;\n\tctx->k[3] = 0xca62c1d6;\n}\n\nvoid sha1_update(SHA1_CTX *ctx, const BYTE data[], size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tctx->data[ctx->datalen] = data[i];\n\t\tctx->datalen++;\n\t\tif (ctx->datalen == 64) {\n\t\t\tsha1_transform(ctx, ctx->data);\n\t\t\tctx->bitlen += 512;\n\t\t\tctx->datalen = 0;\n\t\t}\n\t}\n}\n\nvoid sha1_final(SHA1_CTX *ctx, BYTE hash[])\n{\n\tWORD i;\n\n\ti = ctx->datalen;\n\n\t// Pad whatever data is left in the buffer.\n\tif (ctx->datalen < 56) {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 56)\n\t\t\tctx->data[i++] = 0x00;\n\t}\n\telse {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 64)\n\t\t\tctx->data[i++] = 0x00;\n\t\tsha1_transform(ctx, ctx->data);\n\t\tmemset(ctx->data, 0, 56);\n\t}\n\n\t// Append to the padding the total message's length in bits and transform.\n\tctx->bitlen += ctx->datalen * 8;\n\tctx->data[63] = ctx->bitlen;\n\tctx->data[62] = ctx->bitlen >> 8;\n\tctx->data[61] = ctx->bitlen >> 16;\n\tctx->data[60] = ctx->bitlen >> 24;\n\tctx->data[59] = ctx->bitlen >> 32;\n\tctx->data[58] = ctx->bitlen >> 40;\n\tctx->data[57] = ctx->bitlen >> 48;\n\tctx->data[56] = ctx->bitlen >> 56;\n\tsha1_transform(ctx, ctx->data);\n\n\t// Since this implementation uses little endian byte ordering and MD uses big endian,\n\t// reverse all the bytes when copying the final state to the output hash.\n\tfor (i = 0; i < 4; ++i) {\n\t\thash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;\n\t}\n}\n"
        },
        {
          "name": "sha1.h",
          "type": "blob",
          "size": 1.1748046875,
          "content": "/*********************************************************************\n* Filename:   sha1.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding SHA1 implementation.\n*********************************************************************/\n\n#ifndef SHA1_H\n#define SHA1_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/****************************** MACROS ******************************/\n#define SHA1_BLOCK_SIZE 20              // SHA1 outputs a 20 byte digest\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\ntypedef unsigned int  WORD;             // 32-bit word, change to \"long\" for 16-bit machines\n\ntypedef struct {\n\tBYTE data[64];\n\tWORD datalen;\n\tunsigned long long bitlen;\n\tWORD state[5];\n\tWORD k[4];\n} SHA1_CTX;\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid sha1_init(SHA1_CTX *ctx);\nvoid sha1_update(SHA1_CTX *ctx, const BYTE data[], size_t len);\nvoid sha1_final(SHA1_CTX *ctx, BYTE hash[]);\n\n#endif   // SHA1_H\n"
        },
        {
          "name": "sha1_test.c",
          "type": "blob",
          "size": 2.0341796875,
          "content": "/*********************************************************************\n* Filename:   sha1_test.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding SHA1\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include <string.h>\n#include \"sha1.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint sha1_test()\n{\n\tBYTE text1[] = {\"abc\"};\n\tBYTE text2[] = {\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"};\n\tBYTE text3[] = {\"aaaaaaaaaa\"};\n\tBYTE hash1[SHA1_BLOCK_SIZE] = {0xa9,0x99,0x3e,0x36,0x47,0x06,0x81,0x6a,0xba,0x3e,0x25,0x71,0x78,0x50,0xc2,0x6c,0x9c,0xd0,0xd8,0x9d};\n\tBYTE hash2[SHA1_BLOCK_SIZE] = {0x84,0x98,0x3e,0x44,0x1c,0x3b,0xd2,0x6e,0xba,0xae,0x4a,0xa1,0xf9,0x51,0x29,0xe5,0xe5,0x46,0x70,0xf1};\n\tBYTE hash3[SHA1_BLOCK_SIZE] = {0x34,0xaa,0x97,0x3c,0xd4,0xc4,0xda,0xa4,0xf6,0x1e,0xeb,0x2b,0xdb,0xad,0x27,0x31,0x65,0x34,0x01,0x6f};\n\tBYTE buf[SHA1_BLOCK_SIZE];\n\tint idx;\n\tSHA1_CTX ctx;\n\tint pass = 1;\n\n\tsha1_init(&ctx);\n\tsha1_update(&ctx, text1, strlen(text1));\n\tsha1_final(&ctx, buf);\n\tpass = pass && !memcmp(hash1, buf, SHA1_BLOCK_SIZE);\n\n\tsha1_init(&ctx);\n\tsha1_update(&ctx, text2, strlen(text2));\n\tsha1_final(&ctx, buf);\n\tpass = pass && !memcmp(hash2, buf, SHA1_BLOCK_SIZE);\n\n\tsha1_init(&ctx);\n\tfor (idx = 0; idx < 100000; ++idx)\n\t   sha1_update(&ctx, text3, strlen(text3));\n\tsha1_final(&ctx, buf);\n\tpass = pass && !memcmp(hash3, buf, SHA1_BLOCK_SIZE);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"SHA1 tests: %s\\n\", sha1_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        },
        {
          "name": "sha256.c",
          "type": "blob",
          "size": 5.1396484375,
          "content": "/*********************************************************************\n* Filename:   sha256.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Implementation of the SHA-256 hashing algorithm.\n              SHA-256 is one of the three algorithms in the SHA2\n              specification. The others, SHA-384 and SHA-512, are not\n              offered in this implementation.\n              Algorithm specification can be found here:\n               * http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf\n              This implementation uses little endian byte order.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdlib.h>\n#include <memory.h>\n#include \"sha256.h\"\n\n/****************************** MACROS ******************************/\n#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))\n#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))\n\n#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))\n#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))\n#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))\n#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))\n#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))\n\n/**************************** VARIABLES *****************************/\nstatic const WORD k[64] = {\n\t0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,\n\t0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,\n\t0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,\n\t0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,\n\t0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,\n\t0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,\n\t0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,\n\t0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2\n};\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nvoid sha256_transform(SHA256_CTX *ctx, const BYTE data[])\n{\n\tWORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];\n\n\tfor (i = 0, j = 0; i < 16; ++i, j += 4)\n\t\tm[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);\n\tfor ( ; i < 64; ++i)\n\t\tm[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];\n\n\ta = ctx->state[0];\n\tb = ctx->state[1];\n\tc = ctx->state[2];\n\td = ctx->state[3];\n\te = ctx->state[4];\n\tf = ctx->state[5];\n\tg = ctx->state[6];\n\th = ctx->state[7];\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tt1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];\n\t\tt2 = EP0(a) + MAJ(a,b,c);\n\t\th = g;\n\t\tg = f;\n\t\tf = e;\n\t\te = d + t1;\n\t\td = c;\n\t\tc = b;\n\t\tb = a;\n\t\ta = t1 + t2;\n\t}\n\n\tctx->state[0] += a;\n\tctx->state[1] += b;\n\tctx->state[2] += c;\n\tctx->state[3] += d;\n\tctx->state[4] += e;\n\tctx->state[5] += f;\n\tctx->state[6] += g;\n\tctx->state[7] += h;\n}\n\nvoid sha256_init(SHA256_CTX *ctx)\n{\n\tctx->datalen = 0;\n\tctx->bitlen = 0;\n\tctx->state[0] = 0x6a09e667;\n\tctx->state[1] = 0xbb67ae85;\n\tctx->state[2] = 0x3c6ef372;\n\tctx->state[3] = 0xa54ff53a;\n\tctx->state[4] = 0x510e527f;\n\tctx->state[5] = 0x9b05688c;\n\tctx->state[6] = 0x1f83d9ab;\n\tctx->state[7] = 0x5be0cd19;\n}\n\nvoid sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)\n{\n\tWORD i;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tctx->data[ctx->datalen] = data[i];\n\t\tctx->datalen++;\n\t\tif (ctx->datalen == 64) {\n\t\t\tsha256_transform(ctx, ctx->data);\n\t\t\tctx->bitlen += 512;\n\t\t\tctx->datalen = 0;\n\t\t}\n\t}\n}\n\nvoid sha256_final(SHA256_CTX *ctx, BYTE hash[])\n{\n\tWORD i;\n\n\ti = ctx->datalen;\n\n\t// Pad whatever data is left in the buffer.\n\tif (ctx->datalen < 56) {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 56)\n\t\t\tctx->data[i++] = 0x00;\n\t}\n\telse {\n\t\tctx->data[i++] = 0x80;\n\t\twhile (i < 64)\n\t\t\tctx->data[i++] = 0x00;\n\t\tsha256_transform(ctx, ctx->data);\n\t\tmemset(ctx->data, 0, 56);\n\t}\n\n\t// Append to the padding the total message's length in bits and transform.\n\tctx->bitlen += ctx->datalen * 8;\n\tctx->data[63] = ctx->bitlen;\n\tctx->data[62] = ctx->bitlen >> 8;\n\tctx->data[61] = ctx->bitlen >> 16;\n\tctx->data[60] = ctx->bitlen >> 24;\n\tctx->data[59] = ctx->bitlen >> 32;\n\tctx->data[58] = ctx->bitlen >> 40;\n\tctx->data[57] = ctx->bitlen >> 48;\n\tctx->data[56] = ctx->bitlen >> 56;\n\tsha256_transform(ctx, ctx->data);\n\n\t// Since this implementation uses little endian byte ordering and SHA uses big endian,\n\t// reverse all the bytes when copying the final state to the output hash.\n\tfor (i = 0; i < 4; ++i) {\n\t\thash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;\n\t\thash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;\n\t}\n}\n"
        },
        {
          "name": "sha256.h",
          "type": "blob",
          "size": 1.1865234375,
          "content": "/*********************************************************************\n* Filename:   sha256.h\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Defines the API for the corresponding SHA1 implementation.\n*********************************************************************/\n\n#ifndef SHA256_H\n#define SHA256_H\n\n/*************************** HEADER FILES ***************************/\n#include <stddef.h>\n\n/****************************** MACROS ******************************/\n#define SHA256_BLOCK_SIZE 32            // SHA256 outputs a 32 byte digest\n\n/**************************** DATA TYPES ****************************/\ntypedef unsigned char BYTE;             // 8-bit byte\ntypedef unsigned int  WORD;             // 32-bit word, change to \"long\" for 16-bit machines\n\ntypedef struct {\n\tBYTE data[64];\n\tWORD datalen;\n\tunsigned long long bitlen;\n\tWORD state[8];\n} SHA256_CTX;\n\n/*********************** FUNCTION DECLARATIONS **********************/\nvoid sha256_init(SHA256_CTX *ctx);\nvoid sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len);\nvoid sha256_final(SHA256_CTX *ctx, BYTE hash[]);\n\n#endif   // SHA256_H\n"
        },
        {
          "name": "sha256_test.c",
          "type": "blob",
          "size": 2.3515625,
          "content": "/*********************************************************************\n* Filename:   sha256.c\n* Author:     Brad Conte (brad AT bradconte.com)\n* Copyright:\n* Disclaimer: This code is presented \"as is\" without any guarantees.\n* Details:    Performs known-answer tests on the corresponding SHA1\n\t          implementation. These tests do not encompass the full\n\t          range of available test vectors, however, if the tests\n\t          pass it is very, very likely that the code is correct\n\t          and was compiled properly. This code also serves as\n\t          example usage of the functions.\n*********************************************************************/\n\n/*************************** HEADER FILES ***************************/\n#include <stdio.h>\n#include <memory.h>\n#include <string.h>\n#include \"sha256.h\"\n\n/*********************** FUNCTION DEFINITIONS ***********************/\nint sha256_test()\n{\n\tBYTE text1[] = {\"abc\"};\n\tBYTE text2[] = {\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"};\n\tBYTE text3[] = {\"aaaaaaaaaa\"};\n\tBYTE hash1[SHA256_BLOCK_SIZE] = {0xba,0x78,0x16,0xbf,0x8f,0x01,0xcf,0xea,0x41,0x41,0x40,0xde,0x5d,0xae,0x22,0x23,\n\t                                 0xb0,0x03,0x61,0xa3,0x96,0x17,0x7a,0x9c,0xb4,0x10,0xff,0x61,0xf2,0x00,0x15,0xad};\n\tBYTE hash2[SHA256_BLOCK_SIZE] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,\n\t                                 0xa3,0x3c,0xe4,0x59,0x64,0xff,0x21,0x67,0xf6,0xec,0xed,0xd4,0x19,0xdb,0x06,0xc1};\n\tBYTE hash3[SHA256_BLOCK_SIZE] = {0xcd,0xc7,0x6e,0x5c,0x99,0x14,0xfb,0x92,0x81,0xa1,0xc7,0xe2,0x84,0xd7,0x3e,0x67,\n\t                                 0xf1,0x80,0x9a,0x48,0xa4,0x97,0x20,0x0e,0x04,0x6d,0x39,0xcc,0xc7,0x11,0x2c,0xd0};\n\tBYTE buf[SHA256_BLOCK_SIZE];\n\tSHA256_CTX ctx;\n\tint idx;\n\tint pass = 1;\n\n\tsha256_init(&ctx);\n\tsha256_update(&ctx, text1, strlen(text1));\n\tsha256_final(&ctx, buf);\n\tpass = pass && !memcmp(hash1, buf, SHA256_BLOCK_SIZE);\n\n\tsha256_init(&ctx);\n\tsha256_update(&ctx, text2, strlen(text2));\n\tsha256_final(&ctx, buf);\n\tpass = pass && !memcmp(hash2, buf, SHA256_BLOCK_SIZE);\n\n\tsha256_init(&ctx);\n\tfor (idx = 0; idx < 100000; ++idx)\n\t   sha256_update(&ctx, text3, strlen(text3));\n\tsha256_final(&ctx, buf);\n\tpass = pass && !memcmp(hash3, buf, SHA256_BLOCK_SIZE);\n\n\treturn(pass);\n}\n\nint main()\n{\n\tprintf(\"SHA-256 tests: %s\\n\", sha256_test() ? \"SUCCEEDED\" : \"FAILED\");\n\n\treturn(0);\n}\n"
        }
      ]
    }
  ]
}