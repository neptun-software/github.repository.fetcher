{
  "metadata": {
    "timestamp": 1736709832297,
    "page": 300,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jhawthorn/fzy",
      "stars": 3007,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.1328125,
          "content": "IndentWidth: 8\nUseTab: Always\nBreakBeforeBraces: Attach\nIndentCaseLabels: true\nAllowShortFunctionsOnASingleLine: false\nColumnLimit: 100\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0576171875,
          "content": "fzy\nfzytest\n*.o\n*.d\nconfig.h\ntest/acceptance/vendor/bundle\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.634765625,
          "content": "dist: trusty\nsudo: false\nlanguage: c\n\nmatrix:\n   include:\n       - os: linux\n         arch: amd64\n         compiler: clang\n       - os: linux\n         arch: ppc64le\n         compiler: clang\n       - os: osx\n         arch: amd64\n         compiler: clang\n       - os: linux\n         arch: amd64\n         compiler: gcc \n       - os: linux\n         arch: ppc64le\n         compiler: gcc \n       - os: osx\n         arch: amd64\n         compiler: gcc \nscript: make && make check\njobs:\n  include:\n    - stage: Acceptance Test\n      language: ruby\n      rvm: 2.5.1\n      script: make acceptance\n      addons:\n        apt:\n          packages:\n          - tmux\n"
        },
        {
          "name": "ALGORITHM.md",
          "type": "blob",
          "size": 6.6279296875,
          "content": "\nThis document describes the scoring algorithm of fzy as well as the algorithm\nof other similar projects.\n\n# Matching vs Scoring\n\nI like to split the problem a fuzzy matchers into two subproblems: matching and scoring.\n\nMatching determines which results are eligible for the list.\nAll the projects here consider this to be the same problem, matching the\ncandidate strings against the search string with any number of gaps.\n\nScoring determines the order in which the results are sorted.\nSince scoring is tasked with finding what the human user intended, there is no\ncorrect solution. As a result there are large variety in scoring strategies.\n\n# fzy's matching\n\nGenerally, more time is taken in matching rather than scoring, so it is\nimportant that matching be as fast as possible. If this were case sensitive it\nwould be a simple loop calling strchr, but since it needs to be case\ninsensitive.\n\n# fzy's scoring\n\nfzy treats scoring as a modified [edit\ndistance](https://en.wikipedia.org/wiki/Edit_distance) problem of calculating\nthe\n[Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance).\nEdit distance is the measure of how different two strings are in terms of\ninsertions, deletions, and substitutions. This is the same problems as [DNA\nsequence alignment](https://en.wikipedia.org/wiki/Sequence_alignment). Fuzzy\nmatching is a simpler problem which only accepts insertions, not deletions or\nsubstitutions.\n\nfzy's scoring is a dynamic programming algorithm similar to\n[Wagner–Fischer](https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm)\nand\n[Needleman–Wunsch](https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm).\n\nDynamic programming requires the observation that the result is based on the\nresult of subproblems.\n\nFzy borrows heavily from concepts in bioinformatics to performs scoring.\n\nFzy builds a `n`-by-`m` matrix, where `n` is the length of the search string\nand `m` the length of the candidate string. Each position `(i,j)` in the matrix\nstores the score for matching the first `i` characters of the search with the\nfirst `j` characters of the candidate.\n\nFzy calculates an affine gap penalty, this means simply that we assign a\nconstant penalty for having a gap and a linear penalty for the length of the\ngap.\nInspired by the [Gotoh algorithm\n(pdf)](http://www.cs.unibo.it/~dilena/LabBII/Papers/AffineGaps.pdf), fzy\ncomputes a second `D` (for diagonal) matrix in parallel with the score matrix.\nThe `D` matrix computes the best score which *ends* in a match. This allows\nboth computation of the penalty for starting a gap and the score for a\nconsecutive match.\n\nUsing [this \nalgorithm](https://github.com/jhawthorn/fzy/blob/master/src/match.c#L105) fzy \nis able to score based on the optimal match.\n\n* Gaps (negative score)\n  * at the start of the match\n  * at the end of the match\n  * within the match\n* Matches (positive score)\n  * consecutive\n  * following a slash\n  * following a space, underscore, or dash (the start of a word)\n  * capital letter (the start of a CamelCase word)\n  * following a dot (often a file extension)\n\n\n\n# Other fuzzy finders\n\n## TextMate\n\nTextMate deserves immense credit for popularizing fuzzy finding from inside\ntext editors. It's influence can be found in the command-t project, various\nother editors use command-t for file finding, and the 't' command in the github\nweb interface.\n\n* https://github.com/textmate/textmate/blob/master/Frameworks/text/src/ranker.cc\n\n## command-t, ctrlp-cmatcher\n\nCommand-t is a plugin first released in 2010 intending to bring TextMate's\n\"Go to File\" feature to vim.\n\nAnecdotally, this algorithm works very well. The recursive nature makes it a little hard to \n\nThe wy `last_idx` is suspicious.\n\n* https://github.com/wincent/command-t/blob/master/ruby/command-t/match.c\n* https://github.com/JazzCore/ctrlp-cmatcher/blob/master/autoload/fuzzycomt.c\n\n## Length of shortest first match: fzf\nhttps://github.com/junegunn/fzf/blob/master/src/algo/algo.go\n\nFzy scores based on the size of the greedy shortest match. fzf finds its match\nby the first match appearing in the candidate string. It has some cleverness to\nfind if there is a shorter match contained in that search, but it isn't\nguaranteed to find the shortest match in the string.\n\nExample results for the search \"abc\"\n\n* <tt>**AXXBXXC**xxabc</tt>\n* <tt>xxxxxxx**AXBXC**</tt>\n* <tt>xxxxxxxxx**ABC**</tt>\n\n## Length of first match: ctrlp, pick, selecta (`<= 0.0.6`)\n\nThese score based on the length of the first match in the candidate. This is\nprobably the simplest useful algorithm. This has the advantage that the heavy\nlifting can be performed by the regex engine, which is faster than implementing\nanything natively in ruby or Vim script.\n\n## Length of shortest match: pick\n\nPick has a method, `min_match`, to find the absolute shortest match in a string.\nThis will find better results than the finders, at the expense of speed, as backtracking is required.\n\n## selecta (latest master)\nhttps://github.com/garybernhardt/selecta/commit/d874c99dd7f0f94225a95da06fc487b0fa5b9edc\nhttps://github.com/garybernhardt/selecta/issues/80\n\nSelecta doesn't compare all possible matches, but only the shortest match from the same start location.\nThis can lead to inconsistent results.\n\nExample results for the search \"abc\"\n\n* <tt>x**AXXXXBC**</tt>\n* <tt>x**ABXC**x</tt>\n* <tt>x**ABXC**xbc</tt>\n\nThe third result here should have been scored the same as the first, but the\nlower scoring but shorter match is what is measured.\n\n\n## others\n\n* https://github.com/joshaven/string_score/blob/master/coffee/string_score.coffee (first match + heuristics)\n* https://github.com/atom/fuzzaldrin/blob/master/src/scorer.coffee (modified version of string_score)\n* https://github.com/jeancroy/fuzzaldrin-plus/blob/master/src/scorer.coffee (Smith Waterman)\n\n\n# Possible fzy Algorithm Improvements\n\n## Case sensitivity\n\nfzy currently treats all searches as case-insensitive. However, scoring prefers\nmatches on uppercase letters to help find CamelCase candidates. It might be\ndesirable to support a case sensitive flag or \"smart case\" searching.\n\n## Faster matching\n\nMatching is currently performed using the standard lib's `strpbrk`, which has a\nvery simple implementation (at least in glibc).\n\nGlibc has an extremely clever `strchr` implementation which searches the haystack\nstring by [word](https://en.wikipedia.org/wiki/Word_(computer_architecture)), a\n4 or 8 byte `long int`, instead of by byte. It tests if a word is likely to\ncontain either the search char or the null terminator using bit twiddling.\n\nA similar method could probably be written to perform to find a character in a\nstring case-insensitively.\n\n* https://sourceware.org/git/?p=glibc.git;a=blob;f=string/strchr.c;h=f73891d439dcd8a08954fad4d4615acac4e0eb85;hb=HEAD\n\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.642578125,
          "content": "## 1.0 (2018-09-23)\n\nFeatures:\n\n  - Support UTF-8\n  - Support readline-like editing\n  - Quit on Esc\n  - Redraw on terminal resize\n  - Bracketed paste escapes are ignored\n\nPerformance:\n\n  - Initialize tty interface before reading stdin\n\n## 0.9 (2017-04-17)\n\nFeatures:\n\n  - Support Ctrl-k and Ctrl-j for movement\n\nPerformance:\n\n  - Use threads to parallelize sorting\n  - Improve parallelism of searching and scoring\n\nInternal:\n\n  - Fix test suite on i386\n  - Replace test suite with greatest\n  - Add property tests\n  - Add acceptance tests\n\n## 0.8 (2017-01-01)\n\nBugfixes:\n\n  - Fix cursor position shifing upwards when input has less than 2 items.\n\n## 0.7 (2016-08-03)\n\nBugfixes:\n\n  - Fixed a segfault when encountering non-ascii characters\n  - Fixed building against musl libc\n\n## 0.6 (2016-07-26)\n\nPerformance:\n\n  - Use threads to parallelize searching and scoring\n  - Read all pending input from tty before searching\n  - Use a lookup table for computing bonuses\n\nBugfixes:\n\n  - Fixed command line parsing on ARM\n  - Fix error when autocompleting and there are no matches\n\n## 0.5 (2016-06-11)\n\nBugfixes:\n\n  - Made sorting stable on all platforms\n\n## 0.4 (May 19, 2016)\n\nFeatures:\n\n  - Add `-q`/`--query` for specifying initial query\n\nBugfixes:\n\n  - Fixed last line of results not being cleared on exit\n  - Check errors when opening the TTY device\n\n## 0.3 (April 25, 2016)\n\nBugfixes:\n\n  - Runs properly in a terminal with -icrnl\n\n## 0.2 (October 19, 2014)\n\nFeatures:\n\n  - Allow specifying custom prompt\n\nPerformance:\n\n  - Reduce memory usage on large sets\n\nBugfixes:\n\n  - Terminal is properly reset on exit\n  - Fixed make install on OS X\n\n## 0.1 (September 20, 2014)\n\nInitial release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 John Hawthorn\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.4873046875,
          "content": "VERSION=1.0\n\nCPPFLAGS=-DVERSION=\\\"${VERSION}\\\" -D_GNU_SOURCE\nCFLAGS+=-MD -Wall -Wextra -g -std=c99 -O3 -pedantic -Ideps -Werror=vla\nPREFIX?=/usr/local\nMANDIR?=$(PREFIX)/share/man\nBINDIR?=$(PREFIX)/bin\nDEBUGGER?=\n\nINSTALL=install\nINSTALL_PROGRAM=$(INSTALL)\nINSTALL_DATA=${INSTALL} -m 644\n\nLIBS=-lpthread\nOBJECTS=src/fzy.o src/match.o src/tty.o src/choices.o src/options.o src/tty_interface.o\nTHEFTDEPS = deps/theft/theft.o deps/theft/theft_bloom.o deps/theft/theft_mt.o deps/theft/theft_hash.o\nTESTOBJECTS=test/fzytest.c test/test_properties.c test/test_choices.c test/test_match.c src/match.o src/choices.o src/options.o $(THEFTDEPS)\n\nall: fzy\n\ntest/fzytest: $(TESTOBJECTS)\n\t$(CC) $(CFLAGS) $(CCFLAGS) -Isrc -o $@ $(TESTOBJECTS) $(LIBS)\n\nacceptance: fzy\n\tcd test/acceptance && bundle --quiet && bundle exec ruby acceptance_test.rb\n\ntest: check\ncheck: test/fzytest\n\t$(DEBUGGER) ./test/fzytest\n\nfzy: $(OBJECTS)\n\t$(CC) $(CFLAGS) $(CCFLAGS) -o $@ $(OBJECTS) $(LIBS)\n\n%.o: %.c config.h\n\t$(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<\n\nconfig.h: src/config.def.h\n\tcp src/config.def.h config.h\n\ninstall: fzy\n\tmkdir -p $(DESTDIR)$(BINDIR)\n\tcp fzy $(DESTDIR)$(BINDIR)/\n\tchmod 755 ${DESTDIR}${BINDIR}/fzy\n\tmkdir -p $(DESTDIR)$(MANDIR)/man1\n\tcp fzy.1 $(DESTDIR)$(MANDIR)/man1/\n\tchmod 644 ${DESTDIR}${MANDIR}/man1/fzy.1\n\nfmt:\n\tclang-format -i src/*.c src/*.h\n\nclean:\n\trm -f fzy test/fzytest src/*.o src/*.d deps/*/*.o\n\nveryclean: clean\n\trm -f config.h\n\n.PHONY: test check all clean veryclean install fmt acceptance\n\n-include $(OBJECTS:.o=.d)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.0078125,
          "content": "![fzy](http://i.hawth.ca/u/fzy-github.svg)\n\n**fzy** is a fast, simple fuzzy text selector for the terminal with an advanced scoring algorithm.\n\n[Try it out online!](http://jhawthorn.github.io/fzy-demo)\n\n![](http://i.hawth.ca/u/fzy_animated_demo.svg)\n\n<blockquote>\nIt's been kind of life-changing.\n-<a href=\"https://github.com/graygilmore/\">@graygilmore</a>\n</blockquote>\n\n<blockquote>\nfzy works great btw\n-<a href=\"https://twitter.com/alexblackie/status/719297828892188672\">@alexblackie</a>\n</blockquote>\n\n [![Build Status](https://github.com/jhawthorn/fzy/workflows/CI/badge.svg)](https://github.com/jhawthorn/fzy/actions)\n\n## Why use this over fzf, pick, selecta, ctrlp, ...?\n\nfzy is faster and shows better results than other fuzzy finders.\n\nMost other fuzzy matchers sort based on the length of a match. fzy tries to\nfind the result the user intended. It does this by favouring matches on\nconsecutive letters and starts of words. This allows matching using acronyms or\ndifferent parts of the path.\n\nA gory comparison of the sorting used by fuzzy finders can be found in [ALGORITHM.md](ALGORITHM.md)\n\nfzy is designed to be used both as an editor plugin and on the command line.\nRather than clearing the screen, fzy displays its interface directly below the current cursor position, scrolling the screen if necessary.\n\n## Installation\n\n**macOS**\n\nUsing Homebrew\n\n    brew install fzy\n\nUsing MacPorts\n\n    sudo port install fzy\n\n**[Arch Linux](https://www.archlinux.org/packages/?sort=&q=fzy&maintainer=&flagged=)/MSYS2**: `pacman -S fzy`\n\n**[FreeBSD](https://www.freebsd.org/cgi/ports.cgi?query=fzy&stype=all)**: `pkg install fzy`\n\n**[Gentoo Linux](https://packages.gentoo.org/packages/app-shells/fzy)**: `emerge -av app-shells/fzy`\n\n**[Ubuntu](https://packages.ubuntu.com/search?keywords=fzy&searchon=names&suite=bionic&section=all)/[Debian](https://packages.debian.org/search?keywords=fzy&searchon=names&suite=all&section=all)**: `apt-get install fzy`\n\n**[pkgsrc](http://pkgsrc.se/misc/fzy) (NetBSD and others)**: `pkgin install fzy`\n\n**[openSUSE](https://software.opensuse.org/package/fzy)**: `zypper in fzy`\n\n### From source\n\n    make\n    sudo make install\n\nThe `PREFIX` environment variable can be used to specify the install location,\nthe default is `/usr/local`.\n\n## Usage\n\nfzy is a drop in replacement for [selecta](https://github.com/garybernhardt/selecta), and can be used with its [usage examples](https://github.com/garybernhardt/selecta#usage-examples).\n\n### Use with Vim\n\nfzy can be easily integrated with vim.\n\n``` vim\nfunction! FzyCommand(choice_command, vim_command)\n  try\n    let output = system(a:choice_command . \" | fzy \")\n  catch /Vim:Interrupt/\n    \" Swallow errors from ^C, allow redraw! below\n  endtry\n  redraw!\n  if v:shell_error == 0 && !empty(output)\n    exec a:vim_command . ' ' . output\n  endif\nendfunction\n\nnnoremap <leader>e :call FzyCommand(\"find . -type f\", \":e\")<cr>\nnnoremap <leader>v :call FzyCommand(\"find . -type f\", \":vs\")<cr>\nnnoremap <leader>s :call FzyCommand(\"find . -type f\", \":sp\")<cr>\n```\n\nAny program can be used to filter files presented through fzy. [ag (the silver searcher)](https://github.com/ggreer/the_silver_searcher) can be used to ignore files specified by `.gitignore`.\n\n``` vim\nnnoremap <leader>e :call FzyCommand(\"ag . --silent -l -g ''\", \":e\")<cr>\nnnoremap <leader>v :call FzyCommand(\"ag . --silent -l -g ''\", \":vs\")<cr>\nnnoremap <leader>s :call FzyCommand(\"ag . --silent -l -g ''\", \":sp\")<cr>\n```\n\n## Sorting\n\nfzy attempts to present the best matches first. The following considerations are weighted when sorting:\n\nIt prefers consecutive characters: `file` will match <tt><b>file</b></tt> over <tt><b>fil</b>t<b>e</b>r</tt>.\n\nIt prefers matching the beginning of words: `amp` is likely to match <tt><b>a</b>pp/<b>m</b>odels/<b>p</b>osts.rb</tt>.\n\nIt prefers shorter matches: `abce` matches <tt><b>abc</b>d<b>e</b>f</tt> over <tt><b>abc</b> d<b>e</b></tt>.\n\nIt prefers shorter candidates: `test` matches <tt><b>test</b>s</tt> over <tt><b>test</b>ing</b></tt>.\n\n## See Also\n\n* [fzy.js](https://github.com/jhawthorn/fzy.js) Javascript port\n\n\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "fzy.1",
          "type": "blob",
          "size": 2.330078125,
          "content": ".TH FZY 1 \"2018-09-23\" \"fzy 1.0\"\n.SH NAME\nfzy \\- A fuzzy text selector menu for the terminal.\n.SH SYNOPSIS\n.B fzy\n.IR [OPTION]...\n.SH DESCRIPTION\n.B fzy is a fuzzy text selector/file finder for the terminal using a search\nsimilar to that of TextMate or CmdT.\n\nfzy reads a list of newline-separated items from stdin to be displayed as a\nmenu in the terminal.\nUpon pressing ENTER, the currently selected item is printed to stdout.\n\nEntering text narrows the items using fuzzy matching. Results are sorted using\nheuristics for the best match.\n\n.SH OPTIONS\n.TP\n.BR \\-l \", \" \\-\\-lines =\\fILINES\\fR\nHow many lines of items to display. If unspecified, defaults to 10 lines.\n.\n.TP\n.BR \\-p \", \" \\-\\-prompt =\\fIPROMPT\\fR\nInput prompt (default: '> ')\n.\n.TP\n.BR \\-s \", \" \\-\\-show-scores\nShow the scores for each item.\n.\n.TP\n.BR \\-t \", \" \\-\\-tty =\\fITTY\\fR\nUse TTY instead of the default tty device (/dev/tty).\n.\n.TP\n.BR \\-q \", \" \\-\\-query =\\fIQUERY\\fR\nUse QUERY as the initial search query.\n.\n.TP\n.BR \\-e \", \" \\-\\-show-matches =\\fIQUERY\\fR\nNon-interactive mode. Print the matches in sorted order for QUERY to stdout.\n.\n.TP\n.BR \\-0 \", \" \\-\\-read-null\nRead input delimited by ASCII NUL characters.\n.\n.TP\n.BR \\-h \", \" \\-\\-help\nUsage help.\n.\n.TP\n.BR \\-v \", \" \\-\\-version\nUsage help.\n.\n.SH KEYS\n.\n.TP\n.BR \"ENTER\"\nPrint the selected item to stdout and exit\n.TP\n.BR \"Ctrl+c, Ctrl+g, Esc\"\nExit with status 1, without making a selection.\n.TP\n.BR \"Up Arrow, Ctrl+p, Ctrl+k\"\nSelect the previous item\n.TP\n.BR \"Down Arrow, Ctrl+n, Ctrl+j\"\nSelect the next item\n.TP\nTab\nReplace the current search string with the selected item\n.TP\n.BR \"Backspace, Ctrl+h\"\nDelete the character before the cursor\n.TP\n.BR Ctrl+w\nDelete the word before the cursor\n.TP\n.BR Ctrl+u\nDelete the entire line\n.\n.SH USAGE EXAMPLES\n.\n.TP\n.BR \"ls | fzy\"\nPresent a menu of items in the current directory\n.TP\n.BR \"ls | fzy -l 25\"\nSame as above, but show 25 lines of items\n.TP\n.BR \"vi $(find -type f | fzy)\"\nList files under the current directory and open the one selected in vi.\n.TP\n.BR \"cd $(find -type d | fzy)\"\nPresent all directories under current path, and change to the one selected.\n.TP\n.BR \"ps aux | fzy | awk '{ print $2 }' | xargs kill\"\nList running processes, kill the selected process\n.TP\n.BR \"git checkout $(git branch | cut -c 3- | fzy)\"\nSame as above, but switching git branches.\n.SH AUTHOR\nJohn Hawthorn <john.hawthorn@gmail.com>\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}