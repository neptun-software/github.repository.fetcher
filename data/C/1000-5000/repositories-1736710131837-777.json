{
  "metadata": {
    "timestamp": 1736710131837,
    "page": 777,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jech/polipo",
      "stars": 1801,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.056640625,
          "content": "polipo\npolipo\\.exe\ncore\n*.o\npolipo.html\npolipo.info\nhtml/\n"
        },
        {
          "name": ".hgignore",
          "type": "blob",
          "size": 0.0458984375,
          "content": "syntax: glob\n\npolipo\npolipo.info\ncore\nhtml\n*.o\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 25.150390625,
          "content": "Polipo 1.1.2 (unreleased):\n\n  * Implemented support for SOCKS5 authenticatin (thanks to Amir Hossein\n    and Heinrich Hartmann).\n  * Implement support for the OPTIONS method (thanks to Jan Kraetzschmar).\n  * Implemented support for binding the server side to a specific address\n    (thanks to Sashka Nochkin).\n  * Add configuration variable dnsNameServerPort (thanks to Julio\n    Sangrador-Paton).\n  * Fix a bug that could prevent the on-disk cache from being written out.\n    Thanks to David Bonnes.\n  * Allow POST with no Content-Length.  Thanks to Jamie Jones.\n  * Windows build fixes.\n  * Added support for musl, removed support for Linux libc5.\n  * Dropped support for very old OpenBSD versions.\n  * Fixed the syntax of the generated Warning headers.\n\n14 May 2014: Polipo 1.1.1:\n\n  * Fix a typo that would cause a crash when connecting to a SOCKS\n    server identified by a DNS CNAME.  Thanks to soflare.\n  * Fix a typo that could cause an infinite loop when tunnelling.\n    Thanks to xnoreq for the extensive debugging session.\n  * Fix incorrect error handling that would cause a crash when sending\n    PUT or POST to the local server.\n  * Various improvements to the Windows port.  Thanks to xnoreq.\n\n14 April 2014: Polipo 1.1.0:\n\n  * Proper va_list handling for AMD64 and other RISC-like architectures\n    (Juliusz Chroboczek and Aleksandar Kuktin).\n  * Implemented work-around for broken Content-Range headers.\n  * Use 1024 instead of 32 as the length of the listen queue.\n  * Implemented the ability to control the permissions set on the log file.\n  * Implemented the ability to scrub private information from logs.\n  * Fixed a bug that could cause incorrect logging to syslog (thanks\n    to Sami Farin).\n  * Tweaked the portable version of mktime_gmt.  This will hopefully\n    fix the time issues on Windows.  Thanks to MaxWell and Greg.\n  * Changed chunk allocator to use larger arenas on 64-bit arches.\n  * Fixed a bug that could prevent saving objects on disk.  Thanks to\n    Ming Fu.\n  * Fixed a bug that could prevent parsing large headers.  Thanks to\n    Ming Fu.\n  * Fixed an issue that could cause crash messages to go into the disk\n    cache.\n  * Fixed a bug that could cause the default chunk memory to be incorrect\n    on FreeBSD machines.  Thanks to Frank Behrens.\n  * Fixed a number of bugs in the validation of Range requests.  Thanks to\n    Ken Brazier.\n  * Inhibited range requests for non-200 instances, as this breaks some\n    client software.  Thanks to Ken Brazier.\n  * Fix a integer overflow in processing client requests.\n  * Implement authentication on tunnelled connections.  Thanks to\n    Stephen Dolan.\n  * Implement ability to include Cache-Control: no-transform in all\n    requests.  Thanks to Nick Osborn.\n  * Fix a bug in the DNS code that would cause us to ignore CNAMES\n    after a DNS timeout.\n  * Fixed a crash that occurs when a server sends a malformed\n    Cache-Control: header (CVE-2009-3305). Thanks to Stefan Fritsch.\n  * Removed support for read-only caches.  Nobody ever used it.\n  * Changed the default value of diskCacheWriteoutOnClose to 64kB.\n  * Cleaned up naming of Windows support functions. Thanks to Honglei Jiang.\n  * Added support for forbidden tunnels (thanks to Richard Zidlicky).\n  * Fixed a bug that prevented parsing of extremely long literal IPv6\n    addresses (thanks to Jan Braun).\n  * Added support for DOS-style absolute pathnames.  Thanks to Gisle Vanem.\n  * Fixed a bug that could cause infinite revalidation loops.  Thanks to\n    David Rothlisberger.\n  * Fixed a bug that could provide incorrect caching information to clients.\n    Thanks to William Manley.\n  * Support MSVC 2010.  Thanks to Greg Hazel.\n  * Work-around buggy clients that send HTTP:// in uppercase.  Thanks\n    to David Rothlisberger.\n  * Save Cache-Control values to the disk cache.  Thanks to Ruben Alleres.\n  * Allow ~ in logFile.  Thanks to P.J. Hades.\n  * Fixed a bug that could cause infinite revalidation loops with servers\n    that perform sloppy packetisation (IIS, I'm looking at you).\n  * Fail expectations on the local interface.  This might or might not be\n    what CVE-2011-3596 is about, difficult to say since nobody is speaking\n    to me.\n\n31 January 2010: Polipo 1.0.4.1:\n\n  Cherry-picked fixes from 1.0.5.  Thanks to Julien Cristau.\n\n  * Fixed an integer overflow that may lead to a crash\n    (http://secunia.com/advisories/37607/). Discovered by Jeremy Brown.\n    (CVE-2009-4413)\n  * Fixed a crash that occurs when a server sends a malformed\n    Cache-Control: header (CVE-2009-3305). Patch from Stefan Fritsch.\n  * Prevent an infinite loop when a bodyless 204 or 1xx response is encountered\n  * Don't crash when we get an error while waiting for 100 continue status.\n\n8 January 2008: Polipo 1.0.4:\n\n  * Fixed the handling of tunnels with a parent proxy (thanks to\n    Richard Å puta).\n  * Fixed a bug that could cause connections to be shut down when\n    a server used the old (RFC 2068) semantics of ``100 Continue''\n    (thanks to Thomas Wiesel).\n  * Fixed a crash when a request URL was larger than 10 kB (thanks to\n    Fabian Keil).\n  * Fixed a possible failure to read client requests larger than one\n    chunk.\n\n6 October 2007: Polipo 1.0.3\n\n  * Changed the default for chunkMemory: it is now 24 MB or\n    one-quarter of physical memory, whichever is smaller.\n  * Support for logging to syslog (thanks to Nix).\n  * Made atom reference counts 32-bit longs; this should fix\n    problems that people were seeing when running Polipo with\n    humongous in-memory caches.\n  * Added Git, Jabber and CVS to default tunnelAllowedPorts.\n  * Fixed a bug that could cause URL matching to fail when using\n    anchored regular expressions (thanks to phuel).\n\n26 August 2007: Polipo 1.0.2:\n\n  * Fixed a crash that could happen with entities more than 2GB in\n    size.  Such entities are still not supported, but Polipo\n    should no longer crash.\n  * Minor HTTP compliance fixes, due to testing with Co-Advisor.\n  * Fixed a crash that would happen when a POST request was aborted\n    by the server.  Reported by Tero Pelander.\n  * Worked around a DNS-related bug that I'm unable to track down,\n    waiting for a proper fix.\n\n25 June 2007: Polipo 1.0.1:\n\n  * Made Polipo slightly more aggressive when speaking to\n    HTTP/1.0 servers (thanks to Fabian Keil for noticing that).\n  * Fixed a crash that would happen when a client used\n    Cache-Control: only-if-cached, and the object was not in cache.\n    (Reported by F. Zappa, A. Patala and V. Ghosal.)\n  * Fixed a descriptor leak when running under Windows.\n  * Made Polipo optionally drop connections after servicing\n    a number of connections (maxConnectionAge and maxConnectionRequests).\n\n6 March 2007: Polipo 1.0.0\n\n  * No changes since 0.9.99.2.\n\n7 February 2007: Polipo 0.9.99.2\n\n  * Fixed a buffer overflow in urlDirname (the 0.9 branch is not\n    vulnerable) (reported by J. P. Larocque).\n  * Implemented use of IPv6 temporary source addresses (Frank Behrens).\n  * Disabled use of unaligned range requests by default.  This is\n    controlled by the variable allowUnalignedRangeRequests (reported\n    by Chris Moore).\n  * Fixed descriptor leaks in SOCKS error handling (reported by\n    Roger Dingledine).\n  * Implemented maxSideBuffering.\n\n6 February 2007: Polipo 0.9.12\n\n  * Fixed incorrect caching of redirects (reported by Lawrence Lu).\n  * Fixed a possible hang when falling back to gethostbyname\n    (reported by Chris Moore).\n\n28 December 2006: Polipo 0.9.99.1\n\n  * Validation improvements and bug fixes.\n  * Don't use cached data when receiving the output from an HTTP/1.0 CGI.\n  * Allowed tunnelling of IMAP and POP traffic by default.\n  * Changed the disk cache expiry and indexing functions to use chunks.\n  * Made the disk cache unreadable by others by default.\n  * Fixed a bug that could cause stale data to be served after\n    a connection failure (reported by Hondza).\n  * Fixed computation of age and rtt for pipelined requests.\n  * Fixed incorrect cachability of redirects (reported by J.-P. Larocque).\n  * Fixed a bug that would cause uncachable objects to become\n    cachable after being reloaded from the on-disk cache (reported\n    by J.-P. Larocque).\n  * Implemented dontTrustVaryETag.\n\n7 December 2006: Polipo 0.9.11\n\n  * Fixed a crash that could happen when a network interface went down\n    while a DNS query was in progress (reported by Francesco Zappa).\n\n20 November 2006: Polipo 0.9.99.0:\n\n  * Implemented large buffers for headers larger than a chunk's worth.\n  * Made the HTTP parser lax by default (ignores unknown headers).\n  * Implemented the infrastructure for local POST requests and\n    implemented a real configuration interface (thanks to Theo Honohan).\n  * Made timeouts user-configurable and enforced an invariant between\n    timeouts.\n  * Made logging configurable at runtime (thanks to Frank Behrens).\n  * Implemented the infrastructure for asynchronous handling of \n    forbidden URLs.\n  * Implemented the ability to redirect instead of returning an\n    error for forbidden URLs.\n  * Implemented support for Squid-style redirectors.\n  * Implemented User-configurable uncacheable URLs, analogous to\n    forbidden URLs (thanks to Joachim Haga).\n  * Implemented the ability to avoid caching pages with cookies\n    and redirects.\n  * Implemented maxPipelineTrain, which can be used to moderate\n  * Polipo's eagerness to pipeline.\n  * Unified parentHost and parentPort into parentProxy.\n  * Ported Polipo to native Windows (thanks to Dan Kennedy).\n  * Implemented disableVia.\n  * Implemented SOCKS support.\n  * Made disableVia and cacheIsShared to be true by default.\n  * Increased the default value of serverMaxSlots to 8.\n  * Made the disk cache code quote all characters except for a\n    small number of ``known safe'' ones.  This is an incompatible\n    change to the on-disk format.\n  * Changed HTTP parser to pass all Pragma headers to the next\n    hop; this should make some media players work through Polipo.\n  * Changed the connection scheduler to avoid pipelining when\n    there are idle connections to a given server.\n  * Made Polipo obey parentProxy when tunnelling (proxying https).\n  * Changed the default value of allowedPorts to be slightly more\n    permissive.\n  * Implemented tweakables for selectively disabling parts of the\n    configuration interface.  Indexing and listing known servers\n    are now disabled by default.\n  * Hide variables containing passwords.\n  * Fixed a bug that could cause incorrect validation when speaking\n    to an HTTP/1.0 server.\n  * Fixed a bug that could cause incorrect validation of Vary objects.\n  * Fixed a crash in the redirector code.\n  * Made disableVia the default, and changed the default value of idleTime.\n  * Made polipo delay serving of partial objects until after a\n    a successful validation.  This should fix Mozilla's prefetching.\n  * On 64-bit platforms, made CHUNK_SIZE default to 8kB.\n\n2 September 2006: Polipo 0.9.10:\n\n  * Fixed a crash when a client closes a connection at just the\n    wrong time.\n  * Fixed a crash that could happen when a server returned incorrect\n    headers and closed the connection at just the wrong time.\n  * Fixed restarting of connections on a server-side read error;\n    this should avoid the ``connection reset by peer'' problem.\n  * Corrected work-around for DNS servers that export both AAAA and CNAME.\n  * Fix incorrect error handling when overflowing the buffer when saving\n    an entity to disk.\n  * IPv6 tweaks for OpenBSD (thanks to Jun-ichiro itojun Hagino).\n  * Fixed incorrect error-handling on failure to parse a date.\n  * Fixed a deadlock when a tunnel is shut down and the buffer is\n    full.\n  * Fixed an incorrect use of va_start (guaranteed crash on AMD64).\n  * Fixed a possible race condition with a heavily pipelining client.\n  * Fixed a crash due to incorrect handling of write errors in POST.\n\n23 September 2005: Polipo 0.9.9:\n\n  * Fixed a bug that could cause objects to be incorrectly\n    determined to be dynamic (thanks to Joachim B. Haga).\n  * Fixed a bug that could cause the local web server to expose\n    files that are not under the local root (thanks to Wessel\n    Dankers).\n  * Fixed an off-by-one bug when parsing NL-terminated headers.\n  * Made Polipo forget about failures when finishing on the client side.\n  * Polipo now sends Host headers even when speaking to an upstream\n    proxy.  Some proxies take RFC 2616 literally, and require that\n    (thanks to Zoltan Ivanfi).\n  * Fixed some bugs in staleness computation, and implemented\n    server-side max-age directives (oops!) (thanks to Charley Chu).\n\n24 January 2005: Polipo 0.9.8:\n\n  * Backported the lax HTTP parser from the head branch.\n  * Fixed a race condition that could cause a crash if a single\n    object was being superseded twice at the same time.\n  * Fixed an incorrect test that caused Polipo to pipeline to all\n    HTTP/1.1 servers, even when they were determined as broken (thanks\n    to Daniel Koukola).\n  * Implemented maxPipelineTrain.\n  * Tweaked for uclibc (thanks to Detlef Riekenberg).\n\n27 December 2004: Polipo 0.9.7:\n\n  * Fixed a possible crash when tunnelling.\n  * Fixed spurious updates of object sizes when connection is dropped\n    by the client.\n  * Fixed parsing of URLs with explicit port number (thanks to\n    Frank Behrens).\n  * Fixed a possible crash when exiting POST in error.\n  * Fixed a protocol violation when an empty object is not superseded.\n\n31 October 2004: Polipo 0.9.6:\n  * Fixed a possible crash in ServeObject.\n  * Fixed two possible crashes when relaxTransparency is not false.\n  * Modified the config file parser to make it possible to have\n    backslashes in atoms.\n  * Fixed a violated invariant (leading to a crash) when superseding\n    objects.\n  * Fixed a possible crash in ClientFinish when a pipelined request\n    carries no object.\n  * Fixed a bug in handling of client-side Expect: 100-continue\n    (reported by Charley Chu).\n  * Fixed a scheduling bug that caused server-side requests to be\n    issued in the order opposite to a client-side pipeline (many\n    thanks to Joachim Haga).\n  * Abort when the config file couldn't be parsed (thanks to\n    Joachim Haga).\n  * Fixed error handling in POST and PUT requests, which could\n    cause a crash on an I/O error.\n\n17 June 2004: Polipo 0.9.5:\n  * Implemented upstream proxy authentication (HTTP Basic only).\n  * Fixed a possible crash when unable to schedule servicing a request.\n  * Fixed a possible crash when tunnelling (proxying https).\n  * Fixed signedness issues to make allowedClients work on PPC\n    (from Gergely Nagy).\n\n10 May 2004: Polipo 0.9.4:\n  * Fixed a bug (introduced in 0.9.3) that could cause a crash when\n    the download of an object was interrupted and then immediately restarted.\n  * Fixed a bug that could cause stale non-200 replies to be served.\n  * Fixed compilation on FreeBSD 5.2.1 (from Samuel Tardieu).\n  * Fixed definition of *_ROOT in diskcache.c\n\n6 April 2004: Polipo 0.9.3:\n  * Fix incorrect handling of EPIPE when tunnelling; this could cause\n    crashes if a peer closed a connection when we're writing.\n  * Fix a race condition that could cause ``error message lost in transit''\n    errors if a request was cancelled during connect.\n  * Check for exitFlag in workToDo: faster reaction to signals.\n\n28 March 2004: Polipo 0.9.2:\n  * Fixed a bug that could cause crashes when writing out small\n    objects (thanks to Frank Behrens).\n  * Made buffer allocation in httpParseHeaders dynamic.\n  * Fixed the declaration of pipelineAdditionalRequests.\n  * Fixed a bug that could cause empty directories to be missed\n    when expiring the disk cache.\n  * Switched the forbidden file to use extended regexps, the\n    previous usage was non-portable (thanks to Frank Behrens).\n\n9 March 2004: Polipo 0.9.1:\n  * Fixed a bug that could cause chunked encoding failures when\n    going from a 1.0 server to a 1.1 client.\n  * Fixed a bug that prevented comments after some config lines\n    (thanks to Tom Huckstep).\n  * Fixed a possible buffer overflow in dnsDecodeReply.\n  * Fixed portability to systems where rmdir returns EEXIST\n    instead of ENOTEMPTY.\n  * Fixed error handling on fork failures in fillSpecialObject.\n  * Fixed handling of EINTR in wait in specialRequestHandler.\n  * Fixed a bug that caused objects with no headers to fail.\n  * Fixed a minor memory leak in the config file parser.\n  * Minor build fixes for NetBSD.\n  * Added the 68020 and later to the list of architectures that\n    support unaligned access.\n\n18 February 2004: Polipo 0.9:\n  * Reworked the DNS code to parse ids even when a reply's qdcount\n    is 0.  No longer falls back to gethostbyname when DNS server\n    returns FormErr.\n  * Made the DNS code parse resolv.conf.\n\n11 Feburary 2004: Polipo 0.8.99.3:\n  * Minor changes to work around Cygwin mis-design.\n  * Fixed printing of n-state variables.\n  * Fixed proxyOffline handling.\n  * Fixed a bug that would cause errors to be reported with the\n    wrong content-type.\n  * Fixed a bug that would cause ``object vanished'' errors when\n    using HEAD for revalidation.\n  * Fixed a bug that could cause failed requests due to ``client\n    reset connection'' errors.\n\n24 January 2004: Polipo 0.8.99.2:\n  * Cleaned up authentication.\n  * Made authenticated replies cachable in one of the cases allowed\n    by RFC 2616.\n  * Fixed a bug that could, under some circumstances, cause a\n    password-protected object to be cached and returned to a\n    non-authorized client.\n  * Implemented 100-continue, controlled by the variable expectContinue.\n  * Implemented tristate, 4- and 5-state variables.  Split\n    proxyOffline into proxyOffline and relaxTransparency.  This is\n    an incompatible change to the config file format.\n  * Cleaned up the handling of allowed port ranges.  New\n    configuration variable allowedPorts (and new type intlist).\n  * Implemented tunnelling through the CONNECT method (https proxying).\n  * Will now read a request body on error (avoids a deadlock).\n  * Reworked the PUT/POST code to read the reply eagerly rather\n    than waiting for the write to finish (avoids writing the full\n    body on error and avoids the same deadlock as above).\n  * Made server addresses sticky: will now remember which of a\n    servers addresses worked last time, and use that address first.\n\n16 january 2004: Polipo 0.8.99.1:\n  * Fixed an expiry bug that caused DNS queries to be repeated on\n    each request.\n  * Added the variable ``preciseExpiry'' that prevents trusting\n    the mtime during expiry.\n\n14 January 2004: Polipo 0.8.99.0:\n  * Implemented IP address-based authentication.\n  * Implemented HTTP ``basic'' authentication.\n  * Implemented variable body offsets for the on-disk cache; this\n    makes the on-disk cache format incompatible with previous versions.\n  * Made the number of server slots configurable.\n  * Partially rewrote the disk cache code.\n  * Fixed a file descriptor leak in the early error handling code.\n  * Fixed a bug in the base64 encoder; this makes the on-disk cache\n    format incompatible with previous versions.\n  * Implemented proper reporting for 100-Continue replies\n    (100-Continue is not implemented yet).\n  * Made the number of server slots configurable at runtime.\n\n9 January 2004: Polipo 0.8.4:\n  * Log file is now line buffered.\n  * Will reopen the log file on SIGUSR1 and SIGUSR2.\n  * censoredHeaders now defaults to none, and censorReferer to 0.\n  * Fixed a memory allocation bug that could cause a crash.\n\n21 December 2003: Polipo 0.8.3:\n  * Fixed a potential buffer overflow on C89 systems in snnprintf.\n  * Fixed checking of Via headers.\n  * Added configurable log file.\n  * Added code to run as a daemon.\n  * Made the resolver grok names ending in a ``.''.\n  * Changed Makefile to fit Debian better.\n\n7 December 2003: Polipo 0.8.2:\n  * Implemented a version of fts for SVR4 systems.\n  * Implemented a version of mktime_gmt that doesn't use setenv.\n  * Fixed code used to determine FQDN.\n  * More unaligned access fixes.\n  * Disabled queryIPv6 when there is no IPv6 support in kernel.\n  * Enabled IPv6 support by default on FreeBSD and NetBSD.\n\n2 December 2003: Polipo 0.8.1:\n\n  * Fix a possible crash when doing a POST on a busy server.\n  * Fix a possible crash when socket(2) fails; implement switching\n    to a different address when socket(2) fails (e.g. when\n    accessing a double-stack host from an IPv4-only client).\n  * Fix a problem with servers stuck in the ``probing'' state.\n  * Work around a bug in Konqueror that strips question marks from\n    URLs.\n  * Fix incorrect error handling when dealing with connection\n    failures.\n  * Fix a compile problem in dns.c.\n  * Remove dependency on SSL, include MD5 code instead.\n  * Fix signedness of s_maxage.\n\n23 November 2003: Polipo 0.8:\n\n  * IPv6 support, on both the client and server side, including\n    DNS support and RFC 2732.\n  * Reworked the DNS code.\n  * Made it possible to compile without any particular resolver\n    and without the on-disk cache.\n  * Fixed a problem with the chunking encoder.\n  * Made the config file parser grok octal and hex values, allowed\n    colons and tildes in unquoted strings.\n  * Implemented tilde expansion in some config variables.\n  * Made Polipo slightly less eager to honour range requests for\n    dynamic instances.  Marked generated objects as dynamic. These\n    changes should solve some of the problems with PMM.\n  * Implemented the If-Range header (on both the client and server side).\n  * Implemented support for range requests smaller than one chunk\n    (and hence for pmmSize being smaller than CHUNK_SIZE).\n  * Fixed a bug that caused a deadlock (until a server timeout)\n    when doing a POST/PUT request with no free connection slots.\n  * Fixed a problem when diskCacheRoot didn't end in `/'.\n  * Fixed a refcounting problem that could cause Polipo to crash\n    on a DNS timeout.\n  * Fixed an alignment problem that could cause crashes on \n    architectures that don't like unaligned memory accesses\n    (thanks to Rob Byrnes).\n  * Fixed a bug with the disk cache that caused spurious ``disk\n    entry changed behind our back'' warnings (and in principle\n    could cause data corruption, although that's very unlikely).\n  * Made opening connections slightly less aggressive -- Polipo\n    would sometimes open two connections where only one was needed.\n  * Modified client-side code to notice client shutdowns earlier\n    and notify the server side straight away.\n\n7 October 2003: Polipo 0.7\n\n  * Made the Request function a method of objects.\n  * Fixed a bug that could sometimes cause data corruption.\n  * Fixed a bug that could cause sending of incorrect data to\n    the client on a range request.\n  * Fixed POST and PUT requests.\n  * Fixed a bug that could sometimes cause a POST request to use a\n    stale connection.\n  * Included code to do poor man's multiplexing.\n  * Will now open multiple connections to non-persistent servers.\n  * Fixed a bug that could lead to idle connections dying without\n    being noticed.\n  * Fixed probing for pipelining.\n  * Actually use the new time function introduced in 0.5.\n  * Fixed a bug in strcasecmp_n.\n  * forbiddenFile can now be a directory.\n\n26 September 2003: Polipo 0.6\n\n  * Fixed precondition handling.\n  * Fixed a bug that could lead to lockups when revalidating an object.\n\n27 June 2003: Polipo 0.5\n\n  * Made the presence of a reader or writer explicit on the client side.\n  * Reworked closing client connections.\n  * Reworked reporting of server-side errors.\n  * Made buffer allocation lazy; idle clients and servers no longer\n    use up buffers.\n  * Reworked UTC time handling to use timegm(3) when available.\n\n12 March 2003: Polipo 0.4\n\n  * Implemented expiry of the on-disk cache.\n  * Implemented reliable aborting of connections; Polipo should no\n  * longer deadlock when a server falls into a black hole.\n  * Changed direct reads to be more aggressive by using readv in\n    three pieces.\n  * Changed serving of chunked data to be more eager about\n    serving a chunk's end marker.\n  * Implemented better reporting of DNS errors.\n  * Fixed a deadlock with pipelining on the client side.\n  * Removed most of the remaining copies when reading on the\n  * server side.\n  * Fixed a bug that caused some headers to disappear in transit.\n  * Fixed a possible livelock when reading chunked encoding.\n  * Fixed an overflow when pipelining on the server side.\n  * Fixed generation of indexes from the on-disk cache.\n  * Fixed a DNS crash when falling back on gethostbyname.\n\n1 March 2003: Polipo 0.3\n\n  * Implemented retrying of timed-out DNS requests.\n  * Implemented configuration mechanisms for case-insensitive atoms,\n    time values and atom lists; censoredHeaders can now be configured.\n  * No longer censors User-Agent.  Blame Beppe and Alain.\n  * Changed the handling of hop-by-hop HTTP headers to deal with multiple\n    Connection headers.\n  * Made client-side errors and successful revalidation no longer\n    close the connection.\n  * Fixed a bug that caused the allocation of an extraneous 2MB (!)\n    at startup.  Polipo can run in 100KB once again.\n  * Fixed a refcounting bug and some incorrect frees that could\n    lead to crashes when recovering from a server-side error.\n  * Fixed a bug with POST/PUT that could trigger a failed assertion.\n  * Made sure that POST/PUT don't get scheduled in multiple pieces.\n\n17 February 2003: Polipo 0.2\n\n  * Fixed an incorrect assertion that could cause crashes when the\n    server is fast.\n  * Fixed (hopefully) logic for 304 replies.\n  * Minor tweaks to scheduling that cause some speed increase when the\n    client is pipelining and the server is fast.\n  * Minor bug fixes and cleanups.\n  * Macro-ified do_log and friends.\n\n3 February 2003: Polipo 0.1\n\n  * Initial public release.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0458984375,
          "content": "Copyright (c) 2003-2008 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 1.9814453125,
          "content": "Polipo installation instructions\n================================\n\n1. Building and running polipo\n------------------------------\n\n    $ make all\n    $ su -c 'make install'\n    $ man polipo\n    $ polipo &\n\nIf you want Polipo to put itself into the background, you may replace\nthe last line with:\n\n    $ polipo daemonise=true logFile=\"/var/log/polipo.log\"\n\nOn SVR4 systems (Solaris, HP/UX), you will need to use one of the\nfollowing (whichever works):\n\n    $ make PLATFORM_DEFINES=-DSVR4 all\n    $ make PLATFORM_DEFINES=-DSVR4 LDLIBS='-lsocket -lnsl -lresolv' all\n\nYou can also use Polipo without installing:\n\n    $ make\n    $ nroff -man polipo.man | more\n    $ ./polipo &\n\nFor information about building on Windows, please see the file README.Windows.\n\n2. Configuring your user-agent\n------------------------------\n\nOnce polipo is running, configure your user-agent (web browser) to use\nthe proxy on `http://localhost:8123/'.  Depending on the user-agent,\nthis is done either by setting the environment variable http_proxy,\ne.g.\n\n    $ http_proxy=http://localhost:8123; export http_proxy\n\nor by using the browser's ``preferences'' menu.\n\n3. Configuring polipo\n---------------------\n\nIf you want to use an on-disk cache, you will need to create its root\ndirectory:\n\n    $ mkdir /var/cache/polipo/\n\nYou should then arrange for cron to run the following on a regular\nbasis:\n\n    killall -USR1 polipo\n    sleep 1\n    polipo -x\n    killall -USR2 polipo\n\nIf you want to use a configuration file, you should put it in one of\nthe locations `/etc/polipo/config' or `~/.polipo'; you can also use\nthe `-c' flag to put it in a non-standard location.  See the file\n`config.sample' for an example.\n\nYou might also want to create a forbidden URLs file, which you should\nput either in one of `/etc/polipo/forbidden' or `~/.polipo-forbidden';\nyou can set the variable `forbiddenFile' in your config file if you\nwant to put it in a non-standard location.  See `forbidden.sample' for\nan example.\n\n\nJuliusz Chroboczek\n<jch@pps.univ-paris-diderot.fr>\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.9072265625,
          "content": "PREFIX = /usr/local\nBINDIR = $(PREFIX)/bin\nMANDIR = $(PREFIX)/man\nINFODIR = $(PREFIX)/info\nLOCAL_ROOT = /usr/share/polipo/www\nDISK_CACHE_ROOT = /var/cache/polipo\n\n# To compile with Unix CC:\n\n# CDEBUGFLAGS=-O\n\n# To compile with GCC:\n\n# CC = gcc\nCDEBUGFLAGS = -Os -g -Wall -fno-strict-aliasing\n\n# To compile on a pure POSIX system:\n\n# CC = c89\n# CC = c99\n# CDEBUGFLAGS=-O\n\n# To compile with icc 7, you need -restrict.  (Their bug.)\n\n# CC=icc\n# CDEBUGFLAGS = -O -restrict\n\n# On System V (Solaris, HP/UX) you need the following:\n\n# PLATFORM_DEFINES = -DSVR4\n\n# On Solaris, you need the following:\n\n# LDLIBS = -lsocket -lnsl -lresolv\n\n# On mingw, you need\n\n# EXE=.exe\n# LDLIBS = -lws2_32\n\nFILE_DEFINES = -DLOCAL_ROOT=\\\"$(LOCAL_ROOT)/\\\" \\\n               -DDISK_CACHE_ROOT=\\\"$(DISK_CACHE_ROOT)/\\\"\n\n# You may optionally also add any of the following to DEFINES:\n#\n#  -DNO_DISK_CACHE to compile out the on-disk cache and local web server;\n#  -DNO_IPv6 to avoid using the RFC 3493 API and stick to stock\n#      Berkeley sockets;\n#  -DHAVE_IPv6 to force the use of the RFC 3493 API on systems other\n#      than GNU/Linux and BSD (let me know if it works);\n#  -DNO_FANCY_RESOLVER to compile out the asynchronous name resolution\n#      code;\n#  -DNO_STANDARD_RESOLVER to compile out the code that falls back to\n#      gethostbyname/getaddrinfo when DNS requests fail;\n#  -DNO_TUNNEL to compile out the code that handles CONNECT requests;\n#  -DNO_SOCKS to compile out the SOCKS gateway code.\n#  -DNO_FORBIDDEN to compile out the all of the forbidden URL code\n#  -DNO_REDIRECTOR to compile out the Squid-style redirector code\n#  -DNO_SYSLOG to compile out logging to syslog\n\nDEFINES = $(FILE_DEFINES) $(PLATFORM_DEFINES)\n\nCFLAGS = $(MD5INCLUDES) $(CDEBUGFLAGS) $(DEFINES) $(EXTRA_DEFINES)\n\nSRCS = util.c event.c io.c chunk.c atom.c object.c log.c diskcache.c main.c \\\n       config.c local.c http.c client.c server.c auth.c tunnel.c \\\n       http_parse.c parse_time.c dns.c forbidden.c \\\n       md5import.c md5.c ftsimport.c fts_compat.c socks.c mingw.c\n\nOBJS = util.o event.o io.o chunk.o atom.o object.o log.o diskcache.o main.o \\\n       config.o local.o http.o client.o server.o auth.o tunnel.o \\\n       http_parse.o parse_time.o dns.o forbidden.o \\\n       md5import.o ftsimport.o socks.o mingw.o\n\npolipo$(EXE): $(OBJS)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o polipo$(EXE) $(OBJS) $(MD5LIBS) $(LDLIBS)\n\nftsimport.o: ftsimport.c fts_compat.c\n\nmd5import.o: md5import.c md5.c\n\n.PHONY: all install install.binary install.man\n\nall: polipo$(EXE) polipo.info html/index.html localindex.html\n\ninstall: install.binary install.man\n\ninstall.binary: all\n\tmkdir -p $(TARGET)$(BINDIR)\n\tmkdir -p $(TARGET)$(LOCAL_ROOT)\n\tmkdir -p $(TARGET)$(LOCAL_ROOT)/doc\n\trm -f $(TARGET)$(BINDIR)/polipo\n\tcp -f polipo $(TARGET)$(BINDIR)/\n\tcp -f html/* $(TARGET)$(LOCAL_ROOT)/doc\n\tcp -f localindex.html $(TARGET)$(LOCAL_ROOT)/index.html\n\ninstall.man: all\n\tmkdir -p $(TARGET)$(MANDIR)/man1\n\tmkdir -p $(TARGET)$(INFODIR)\n\tcp -f polipo.man $(TARGET)$(MANDIR)/man1/polipo.1\n\tcp polipo.info $(TARGET)$(INFODIR)/\n\tinstall-info --info-dir=$(TARGET)$(INFODIR) polipo.info\n\n\npolipo.info: polipo.texi\n\tmakeinfo polipo.texi\n\nhtml/index.html: polipo.texi\n\tmkdir -p html\n\tmakeinfo --html -o html polipo.texi\n\npolipo.html: polipo.texi\n\tmakeinfo --html --no-split --no-headers -o polipo.html polipo.texi\n\npolipo.pdf: polipo.texi\n\ttexi2pdf polipo.texi\n\npolipo.ps.gz: polipo.ps\n\tgzip -c polipo.ps > polipo.ps.gz\n\npolipo.ps: polipo.dvi\n\tdvips -Pwww -o polipo.ps polipo.dvi\n\npolipo.dvi: polipo.texi\n\ttexi2dvi polipo.texi\n\npolipo.man.html: polipo.man\n\trman -f html polipo.man > polipo.man.html\n\nTAGS: $(SRCS)\n\tetags $(SRCS)\n\n.PHONY: clean\n\nclean:\n\t-rm -f polipo$(EXE) *.o *~ core TAGS gmon.out\n\t-rm -f polipo.cp polipo.fn polipo.log polipo.vr\n\t-rm -f polipo.cps polipo.info* polipo.pg polipo.toc polipo.vrs\n\t-rm -f polipo.aux polipo.dvi polipo.ky polipo.ps polipo.tp\n\t-rm -f polipo.dvi polipo.ps polipo.ps.gz polipo.pdf polipo.html\n\t-rm -rf ./html/\n\t-rm -f polipo.man.html\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.7275390625,
          "content": "Polipo is no longer maintained\n==============================\n\nPolipo is no longer maintained.  Sorry.\n\n\nOriginal Polipo README\n======================\n\nPolipo is single-threaded, non blocking caching web proxy that has\nvery modest resource needs.  See the file INSTALL for installation\ninstructions.  See the texinfo manual (available as HTML after\ninstallation) for more information.\n\nCurrent information about Polipo can be found on the Polipo web page,\n\n    http://www.pps.univ-paris-diderot.fr/~jch/software/polipo/\n\nFurther inquiries should be sent to the Polipo-users mailing list:\n\n    <polipo-users@lists.sourceforge.net>\n\nPlease see the Polipo web page for subscription information.\n\n\nJuliusz Chroboczek\n<jch@pps.univ-paris-diderot.fr>\n"
        },
        {
          "name": "README.Windows",
          "type": "blob",
          "size": 1.23046875,
          "content": "Building Polipo on Windows\n==========================\n\nThere are two distinct ports of Polipo to Windows -- a port using the\nCygwin emulation libraries, and an experimental native port using Mingw.\n\nThe Cygwin port is identical to the Unix binary.  Build it just like\nyou would build under Unix -- just type ``make all'' in the directory\nwhere you untarred the Polipo sources.\n\nIn order to build the native port, cd to the Polipo directory, and do\n\n    make EXE=.exe LDLIBS=-lwsock32\n\nor, if you've got a regex library,\n\n    make EXE=.exe EXTRA_DEFINES=-DHAVE_REGEX LDLIBS=\"-lwsock32 -lregex\"\n\nIn order to cross-compile from a Unix system, you will probably need\nto point make at the right compiler:\n\n    make EXE=.exe CC=i586-mingw32msvc-gcc LDLIBS=-lwsock32\n\nThe native port currently attempts to access files in locations that\nare typical for a Unix system; for example, it will attempt to read a\nconfiguration file /etc/polipo/config on the current drive.  You will\nprobably need to point it at your config file with an explicit ``-c''\ncommand-line argument, and define at least the following configuration\nvariables:\n\n    dnsNameServer\n    diskCacheRoot\n    forbiddenFile\n\nHelp with solving this issue would be very much appreciated.\n\n\nJuliusz Chroboczek\n"
        },
        {
          "name": "atom.c",
          "type": "blob",
          "size": 8.806640625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n/* Atoms are interned, read-only reference-counted strings.\n\n   Interned means that equality of atoms is equivalent to structural\n   equality -- you don't need to strcmp, you just compare the AtomPtrs.\n   This property is used throughout Polipo, e.g. to speed up the HTTP\n   parser.\n\n   Polipo's atoms may contain NUL bytes -- you can use internAtomN to\n   store any random binary data within an atom.  However, Polipo always\n   terminates your data, so if you store textual data in an atom, you\n   may use the result of atomString as though it were a (read-only)\n   C string.\n\n*/\n\nstatic AtomPtr *atomHashTable;\nint used_atoms;\n\nvoid\ninitAtoms()\n{\n    atomHashTable = calloc((1 << LOG2_ATOM_HASH_TABLE_SIZE),\n                           sizeof(AtomPtr));\n\n    if(atomHashTable == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate atom hash table.\\n\");\n        exit(1);\n    }\n    used_atoms = 0;\n}\n\nAtomPtr\ninternAtomN(const char *string, int n)\n{\n    AtomPtr atom;\n    int h;\n\n    if(n < 0 || n >= (1 << (8 * sizeof(unsigned short))))\n        return NULL;\n\n    h = hash(0, string, n, LOG2_ATOM_HASH_TABLE_SIZE);\n    atom = atomHashTable[h];\n    while(atom) {\n        if(atom->length == n &&\n           (n == 0 || memcmp(atom->string, string, n) == 0))\n            break;\n        atom = atom->next;\n    }\n\n    if(!atom) {\n        atom = malloc(sizeof(AtomRec) - 1 + n + 1);\n        if(atom == NULL) {\n            return NULL;\n        }\n        atom->refcount = 0;\n        atom->length = n;\n        /* Atoms are used both for binary data and strings.  To make\n           their use as strings more convenient, atoms are always\n           NUL-terminated. */\n        memcpy(atom->string, string, n);\n        atom->string[n] = '\\0';\n        atom->next = atomHashTable[h];\n        atomHashTable[h] = atom;\n        used_atoms++;\n    }\n    do_log(D_ATOM_REFCOUNT, \"A 0x%lx %d++\\n\",\n           (unsigned long)atom, atom->refcount);\n    atom->refcount++;\n    return atom;\n}\n\nAtomPtr\ninternAtom(const char *string)\n{\n    return internAtomN(string, strlen(string));\n}\n\nAtomPtr\natomCat(AtomPtr atom, const char *string)\n{\n    char buf[128];\n    char *s = buf;\n    AtomPtr newAtom;\n    int n = strlen(string);\n    if(atom->length + n > 128) {\n        s = malloc(atom->length + n + 1);\n        if(s == NULL)\n            return NULL;\n    }\n    memcpy(s, atom->string, atom->length);\n    memcpy(s + atom->length, string, n);\n    newAtom = internAtomN(s, atom->length + n);\n    if(s != buf) free(s);\n    return newAtom;\n}\n\nint\natomSplit(AtomPtr atom, char c, AtomPtr *return1, AtomPtr *return2)\n{\n    char *p;\n    AtomPtr atom1, atom2;\n    p = memchr(atom->string, c, atom->length);\n    if(p == NULL)\n        return 0;\n    atom1 = internAtomN(atom->string, p - atom->string);\n    if(atom1 == NULL)\n        return -ENOMEM;\n    atom2 = internAtomN(p + 1, atom->length - (p + 1 - atom->string));\n    if(atom2 == NULL) {\n        releaseAtom(atom1);\n        return -ENOMEM;\n    }\n    *return1 = atom1;\n    *return2 = atom2;\n    return 1;\n}\n\nAtomPtr\ninternAtomLowerN(const char *string, int n)\n{\n    char *s;\n    char buf[100];\n    AtomPtr atom;\n\n    if(n < 0 || n >= 50000)\n        return NULL;\n\n    if(n < 100) {\n        s = buf;\n    } else {\n        s = malloc(n);\n        if(s == NULL)\n            return NULL;\n    }\n\n    lwrcpy(s, string, n);\n    atom = internAtomN(s, n);\n    if(s != buf) free(s);\n    return atom;\n}\n\nAtomPtr\nretainAtom(AtomPtr atom)\n{\n    if(atom == NULL)\n        return NULL;\n\n    do_log(D_ATOM_REFCOUNT, \"A 0x%lx %d++\\n\",\n           (unsigned long)atom, atom->refcount);\n    assert(atom->refcount >= 1 && atom->refcount < LARGE_ATOM_REFCOUNT);\n    atom->refcount++;\n    return atom;\n}\n\nvoid\nreleaseAtom(AtomPtr atom)\n{\n    if(atom == NULL)\n        return;\n\n    do_log(D_ATOM_REFCOUNT, \"A 0x%lx %d--\\n\",\n           (unsigned long)atom, atom->refcount);\n    assert(atom->refcount >= 1 && atom->refcount < LARGE_ATOM_REFCOUNT);\n\n    atom->refcount--;\n\n    if(atom->refcount == 0) {\n        int h = hash(0, atom->string, atom->length, LOG2_ATOM_HASH_TABLE_SIZE);\n        assert(atomHashTable[h] != NULL);\n\n        if(atom == atomHashTable[h]) {\n            atomHashTable[h] = atom->next;\n            free(atom);\n        } else {\n            AtomPtr previous = atomHashTable[h];\n            while(previous->next) {\n                if(previous->next == atom)\n                    break;\n                previous = previous->next;\n            }\n            assert(previous->next != NULL);\n            previous->next = atom->next;\n            free(atom);\n        }\n        used_atoms--;\n    }\n}\n\nAtomPtr\ninternAtomF(const char *format, ...)\n{\n    char *s;\n    char buf[150];\n    int n;\n    va_list args;\n    AtomPtr atom = NULL;\n\n    va_start(args, format);\n    n = vsnprintf(buf, 150, format, args);\n    va_end(args);\n    if(n >= 0 && n < 150) {\n        atom = internAtomN(buf, n);\n    } else {\n        va_start(args, format);\n        s = vsprintf_a(format, args);\n        va_end(args);\n        if(s != NULL) {\n            atom = internAtom(s);\n            free(s);\n        }\n    }\n    return atom;\n}\n\nstatic AtomPtr\ninternAtomErrorV(int e, const char *f, va_list args)\n{\n    \n    char *es = pstrerror(e);\n    AtomPtr atom;\n    char *s1, *s2;\n    int n, rc;\n    va_list args_copy;\n\n    if(f) {\n        va_copy(args_copy, args);\n        s1 = vsprintf_a(f, args_copy);\n        va_end(args_copy);\n        if(s1 == NULL)\n            return NULL;\n        n = strlen(s1);\n    } else {\n        s1 = NULL;\n        n = 0;\n    }\n\n    s2 = malloc(n + 70);\n    if(s2 == NULL) {\n        free(s1);\n        return NULL;\n    }\n    if(s1) {\n        strcpy(s2, s1);\n        free(s1);\n    }\n\n    rc = snprintf(s2 + n, 69, f ? \": %s\" : \"%s\", es);\n    if(rc < 0 || rc >= 69) {\n        free(s2);\n        return NULL;\n    }\n\n    atom = internAtomN(s2, n + rc);\n    free(s2);\n    return atom;\n}\n\nAtomPtr\ninternAtomError(int e, const char *f, ...)\n{\n    AtomPtr atom;\n    va_list args;\n    va_start(args, f);\n    atom = internAtomErrorV(e, f, args);\n    va_end(args);\n    return atom;\n}\n\nchar *\natomString(AtomPtr atom)\n{\n    if(atom)\n        return atom->string;\n    else\n        return \"(null)\";\n}\n\nAtomListPtr\nmakeAtomList(AtomPtr *atoms, int n)\n{\n    AtomListPtr list;\n    list = malloc(sizeof(AtomListRec));\n    if(list == NULL) return NULL;\n    list->length = 0;\n    list->size = 0;\n    list->list = NULL;\n    if(n > 0) {\n        int i;\n        list->list = malloc(n * sizeof(AtomPtr));\n        if(list->list == NULL) {\n            free(list);\n            return NULL;\n        }\n        list->size = n;\n        for(i = 0; i < n; i++)\n            list->list[i] = atoms[i];\n        list->length = n;\n    }\n    return list;\n}\n\nvoid\ndestroyAtomList(AtomListPtr list)\n{\n    int i;\n    if(list->list) {\n        for(i = 0; i < list->length; i++)\n            releaseAtom(list->list[i]);\n        list->length = 0;\n        free(list->list);\n        list->list = NULL;\n        list->size = 0;\n    }\n    assert(list->size == 0);\n    free(list);\n}\n\nint\natomListMember(AtomPtr atom, AtomListPtr list)\n{\n    int i;\n    for(i = 0; i < list->length; i++) {\n        if(atom == list->list[i])\n            return 1;\n    }\n    return 0;\n}\n\nvoid\natomListCons(AtomPtr atom, AtomListPtr list)\n{\n    if(list->list == NULL) {\n        assert(list->size == 0);\n        list->list = malloc(5 * sizeof(AtomPtr));\n        if(list->list == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate AtomList\\n\");\n            return;\n        }\n        list->size = 5;\n    }\n    if(list->size <= list->length) {\n        AtomPtr *new_list;\n        int n = (2 * list->length + 1);\n        new_list = realloc(list->list, n * sizeof(AtomPtr));\n        if(new_list == NULL) {\n            do_log(L_ERROR, \"Couldn't realloc AtomList\\n\");\n            return;\n        }\n        list->list = new_list;\n        list->size = n;\n    }\n    list->list[list->length] = atom;\n    list->length++;\n}\n\n"
        },
        {
          "name": "atom.h",
          "type": "blob",
          "size": 2.1708984375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ntypedef struct _Atom {\n    unsigned int refcount;\n    struct _Atom *next;\n    unsigned short length;\n    char string[1];\n} AtomRec, *AtomPtr;\n\ntypedef struct _AtomList {\n    int length;\n    int size;\n    AtomPtr *list;\n} AtomListRec, *AtomListPtr;\n\n#define LOG2_ATOM_HASH_TABLE_SIZE 10\n#define LARGE_ATOM_REFCOUNT 0xFFFFFF00U\n\nextern int used_atoms;\n\nvoid initAtoms(void);\nAtomPtr internAtom(const char *string);\nAtomPtr internAtomN(const char *string, int n);\nAtomPtr internAtomLowerN(const char *string, int n);\nAtomPtr atomCat(AtomPtr atom, const char *string);\nint atomSplit(AtomPtr atom, char c, AtomPtr *return1, AtomPtr *return2);\nAtomPtr retainAtom(AtomPtr atom);\nvoid releaseAtom(AtomPtr atom);\nAtomPtr internAtomError(int e, const char *f, ...)\n     ATTRIBUTE ((format (printf, 2, 3)));\nAtomPtr internAtomF(const char *format, ...)\n     ATTRIBUTE ((format (printf, 1, 2)));\nchar *atomString(AtomPtr) ATTRIBUTE ((pure));\nAtomListPtr makeAtomList(AtomPtr *atoms, int n);\nvoid destroyAtomList(AtomListPtr list);\nint atomListMember(AtomPtr atom, AtomListPtr list)\n    ATTRIBUTE ((pure));\nvoid atomListCons(AtomPtr atom, AtomListPtr list);\n"
        },
        {
          "name": "auth.c",
          "type": "blob",
          "size": 3.091796875,
          "content": "/*\nCopyright (c) 2004-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nint\nbuildClientAuthHeaders(AtomPtr url, char *word,\n                       AtomPtr *message_return, AtomPtr *headers_return)\n{\n    int code;\n    char *h;\n    AtomPtr message, headers;\n    if(urlIsLocal(url->string, url->length)) {\n        code = 401;\n        message = internAtomF(\"Server authentication %s\", word);\n        h = \"WWW-Authenticate\";\n    } else {\n        code = 407;\n        message = internAtomF(\"Proxy authentication %s\", word);\n        h = \"Proxy-Authenticate\";\n    }\n    headers = internAtomF(\"\\r\\n%s: Basic realm=\\\"%s\\\"\",\n                          h, authRealm->string);\n    if(message_return)\n        *message_return = message;\n    else\n        releaseAtom(message);\n    *headers_return = headers;\n    return code;\n}\n\nint\ncheckClientAuth(AtomPtr auth, AtomPtr url,\n                AtomPtr *message_return, AtomPtr *headers_return)\n{\n    int code = 0;\n    AtomPtr message = NULL, headers = NULL;\n\n    if(authRealm == NULL || authCredentials == NULL)\n        return 0;\n\n    if(auth == NULL)\n        code = buildClientAuthHeaders(url, \"required\", &message, &headers);\n    else if(auth->length >= 6 || lwrcmp(auth->string, \"basic \", 6) == 0) {\n        if(b64cmp(auth->string + 6, auth->length - 6,\n                  authCredentials->string, authCredentials->length) == 0)\n            return 0;\n        code = buildClientAuthHeaders(url, \"incorrect\", &message, &headers);\n    } else {\n        code = buildClientAuthHeaders(url, NULL, NULL, &headers);\n        message = internAtom(\"Unexpected authentication scheme\");\n    }\n\n    *message_return = message;\n    *headers_return = headers;\n    return code;\n}\n\nint\nbuildServerAuthHeaders(char* buf, int n, int size, AtomPtr authCredentials)\n{\n    char authbuf[4 * 128 + 3];\n    int authlen;\n\n    if(authCredentials->length >= 3 * 128)\n        return -1;\n    authlen = b64cpy(authbuf, parentAuthCredentials->string,\n                     parentAuthCredentials->length, 0);\n    n = snnprintf(buf, n, size, \"\\r\\nProxy-Authorization: Basic \");\n    n = snnprint_n(buf, n, size, authbuf, authlen);\n    return n;\n}\n"
        },
        {
          "name": "auth.h",
          "type": "blob",
          "size": 1.1630859375,
          "content": "/*\nCopyright (c) 2004-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nint checkClientAuth(AtomPtr, AtomPtr, AtomPtr*, AtomPtr*);\nint buildServerAuthHeaders(char*, int, int, AtomPtr);\n"
        },
        {
          "name": "chunk.c",
          "type": "blob",
          "size": 11.4287109375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#define MB (1024 * 1024)\nint chunkLowMark = 0, \n    chunkCriticalMark = 0,\n    chunkHighMark = 0;\n\nvoid\npreinitChunks()\n{\n    CONFIG_VARIABLE(chunkLowMark, CONFIG_INT,\n                    \"Low mark for chunk memory (0 = auto).\");\n    CONFIG_VARIABLE(chunkCriticalMark, CONFIG_INT,\n                    \"Critical mark for chunk memory (0 = auto).\");\n    CONFIG_VARIABLE(chunkHighMark, CONFIG_INT,\n                    \"High mark for chunk memory.\");\n}\n\nstatic void\ninitChunksCommon()\n{\n#define ROUND_CHUNKS(a) a = (((unsigned long)(a) + CHUNK_SIZE - 1) / CHUNK_SIZE) * CHUNK_SIZE;\n    int q;\n\n    if(CHUNK_SIZE != 1 << log2_ceil(CHUNK_SIZE)) {\n        do_log(L_ERROR, \"CHUNK SIZE %d is not a power of two.\\n\", CHUNK_SIZE);\n        exit(1);\n    }\n\n    ROUND_CHUNKS(chunkHighMark);\n    ROUND_CHUNKS(chunkCriticalMark);\n    ROUND_CHUNKS(chunkLowMark);\n\n    if(chunkHighMark < 8 * CHUNK_SIZE) {\n        int mem = physicalMemory();\n        if(mem > 0)\n            chunkHighMark = mem / 4;\n        else\n            chunkHighMark = 24 * MB;\n        chunkHighMark = MIN(chunkHighMark, 24 * MB);\n        chunkHighMark = MAX(chunkHighMark, 8 * CHUNK_SIZE);\n    }\n\n    if(chunkHighMark < MB / 2)\n        fprintf(stderr,\n                \"Warning: little chunk memory (%d bytes)\\n\", chunkHighMark);\n\n    q = 0;\n    if(chunkLowMark <= 0) q = 1;\n    if(chunkLowMark < 4 * CHUNK_SIZE ||\n       chunkLowMark > chunkHighMark - 4 * CHUNK_SIZE) {\n        chunkLowMark = MIN(chunkHighMark - 4 * CHUNK_SIZE,\n                           chunkHighMark * 3 / 4);\n        ROUND_CHUNKS(chunkLowMark);\n        if(!q) do_log(L_WARN, \"Inconsistent chunkLowMark -- setting to %d.\\n\",\n                      chunkLowMark);\n    }\n\n    q = 0;\n    if(chunkCriticalMark <= 0) q = 1;\n    if(chunkCriticalMark >= chunkHighMark - 2 * CHUNK_SIZE ||\n       chunkCriticalMark <= chunkLowMark + 2 * CHUNK_SIZE) {\n        chunkCriticalMark =\n            MIN(chunkHighMark - 2 * CHUNK_SIZE,\n                chunkLowMark + (chunkHighMark - chunkLowMark) * 15 / 16);\n        ROUND_CHUNKS(chunkCriticalMark);\n        if(!q) do_log(L_WARN, \"Inconsistent chunkCriticalMark -- \"\n                      \"setting to %d.\\n\", chunkCriticalMark);\n    }\n#undef ROUND_CHUNKS\n}\n\n\nint used_chunks = 0;\n\nstatic void\nmaybe_free_chunks(int arenas, int force)\n{\n    if(force || used_chunks >= CHUNKS(chunkHighMark)) {\n        discardObjects(force, force);\n    }\n\n    if(arenas)\n        free_chunk_arenas();\n\n    if(used_chunks >= CHUNKS(chunkLowMark) && !objectExpiryScheduled) {\n        TimeEventHandlerPtr event;\n        event = scheduleTimeEvent(1, discardObjectsHandler, 0, NULL);\n        if(event)\n            objectExpiryScheduled = 1;\n    }\n}\n    \n\n\n#ifdef MALLOC_CHUNKS\n\nvoid\ninitChunks(void)\n{\n    do_log(L_WARN, \"Warning: using malloc(3) for chunk allocation.\\n\");\n    used_chunks = 0;\n    initChunksCommon();\n}\n\nvoid\nfree_chunk_arenas()\n{\n    return;\n}\n\nvoid *\nget_chunk()\n{\n    void *chunk;\n\n    if(used_chunks > CHUNKS(chunkHighMark))\n        maybe_free_chunks(0, 0);\n    if(used_chunks > CHUNKS(chunkHighMark))\n        return NULL;\n    chunk = malloc(CHUNK_SIZE);\n    if(!chunk) {\n        maybe_free_chunks(1, 1);\n        chunk = malloc(CHUNK_SIZE);\n        if(!chunk)\n            return NULL;\n    }\n    used_chunks++;\n    return chunk;\n}\n\nvoid *\nmaybe_get_chunk()\n{\n    void *chunk;\n    if(used_chunks > CHUNKS(chunkHighMark))\n        return NULL;\n    chunk = malloc(CHUNK_SIZE);\n    if(chunk)\n        used_chunks++;\n    return chunk;\n}\n\nvoid\ndispose_chunk(void *chunk)\n{\n    assert(chunk != NULL);\n    free(chunk);\n    used_chunks--;\n}\n\nvoid\nfree_chunks()\n{\n    return;\n}\n\nint\ntotalChunkArenaSize()\n{\n    return used_chunks * CHUNK_SIZE;\n}\n#else\n\n#ifdef WIN32 /*MINGW*/\n#define MAP_FAILED NULL\n#define getpagesize() (64 * 1024)\nstatic void *\nalloc_arena(size_t size)\n{\n    return VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n}\nstatic int\nfree_arena(void *addr, size_t size)\n{\n    int rc;\n    rc = VirtualFree(addr, size, MEM_RELEASE);\n    if(!rc)\n        rc = -1;\n    return rc;\n}\n#else\n#ifndef MAP_FAILED\n#define MAP_FAILED ((void*)((long int)-1))\n#endif\nstatic void *\nalloc_arena(size_t size)\n{\n    return mmap(NULL, size, PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n}\nstatic int\nfree_arena(void *addr, size_t size)\n{\n    return munmap(addr, size);\n}\n#endif\n\n/* Memory is organised into a number of chunks of ARENA_CHUNKS chunks\n   each.  Every arena is pointed at by a struct _ChunkArena. */\n/* If currentArena is not NULL, it points at the last arena used,\n   which gives very fast dispose/get sequences. */\n\n#define DEFINE_FFS(type, ffs_name) \\\nint                           \\\nffs_name(type i)              \\\n{                             \\\n    int n;                    \\\n    if(i == 0) return 0;      \\\n    n = 1;                    \\\n    while((i & 1) == 0) {     \\\n        i >>= 1;              \\\n        n++;                  \\\n    }                         \\\n    return n;                 \\\n}\n\n#if defined(DEFAULT_ARENA_BITMAPS) + defined(LONG_ARENA_BITMAPS) + defined(LONG_LONG_ARENA_BITMAPS) > 1\n#error \"Multiple sizes of arenas defined\"\n#endif\n\n#if defined(DEFAULT_ARENA_BITMAPS) + defined(LONG_ARENA_BITMAPS) + defined(LONG_LONG_ARENA_BITMAPS) == 0\n#ifdef HAVE_FFSL\n/* This gives us 32-bit arena bitmaps on LP32, and 64-bit ones on LP64 */\n#define LONG_ARENA_BITMAPS\n#else\n#define DEFAULT_ARENA_BITMAPS\n#endif\n#endif\n\n#if defined(DEFAULT_ARENA_BITMAPS)\n\n#ifndef HAVE_FFS\nDEFINE_FFS(int, ffs)\n#endif\ntypedef unsigned int ChunkBitmap;\n#define BITMAP_FFS(bitmap) (ffs(bitmap))\n\n#elif defined(LONG_ARENA_BITMAPS)\n\n#ifndef HAVE_FFSL\nDEFINE_FFS(long, ffsl)\n#endif\ntypedef unsigned long ChunkBitmap;\n#define BITMAP_FFS(bitmap) (ffsl(bitmap))\n\n#elif defined(LONG_LONG_ARENA_BITMAPS)\n\n#ifndef HAVE_FFSLL\nDEFINE_FFS(long long, ffsll)\n#endif\ntypedef unsigned long long ChunkBitmap;\n#define BITMAP_FFS(bitmap) (ffsll(bitmap))\n\n#else\n\n#error \"You lose\"\n\n#endif\n\n#define ARENA_CHUNKS ((unsigned)sizeof(ChunkBitmap) * 8)\n#define EMPTY_BITMAP (~(ChunkBitmap)0)\n#define BITMAP_BIT(i) (((ChunkBitmap)1) << (i))\n\nstatic int pagesize;\ntypedef struct _ChunkArena {\n    ChunkBitmap bitmap;\n    char *chunks;\n} ChunkArenaRec, *ChunkArenaPtr;\n\nstatic ChunkArenaPtr chunkArenas, currentArena;\nstatic int numArenas;\n#define CHUNK_IN_ARENA(chunk, arena)                                    \\\n    ((arena)->chunks &&                                                 \\\n     (char*)(chunk) >= (arena)->chunks &&                               \\\n     (char*)(chunk) < (arena)->chunks + (ARENA_CHUNKS * CHUNK_SIZE))\n\n#define CHUNK_ARENA_INDEX(chunk, arena)                                 \\\n    ((unsigned)((unsigned long)(((char*)(chunk) - (arena)->chunks)) /   \\\n                CHUNK_SIZE))\n\nvoid\ninitChunks(void)\n{\n    int i;\n    used_chunks = 0;\n    initChunksCommon();\n    pagesize = getpagesize();\n    if((CHUNK_SIZE * ARENA_CHUNKS) % pagesize != 0) {\n        do_log(L_ERROR,\n               \"The arena size %d (%d x %d) \"\n               \"is not a multiple of the page size %d.\\n\",\n                ARENA_CHUNKS * CHUNK_SIZE, ARENA_CHUNKS, CHUNK_SIZE, pagesize);\n        abort();\n    }\n    numArenas = \n        (CHUNKS(chunkHighMark) + (ARENA_CHUNKS - 1)) / ARENA_CHUNKS;\n    chunkArenas = malloc(numArenas * sizeof(ChunkArenaRec));\n    if(chunkArenas == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate chunk arenas.\\n\");\n        exit (1);\n    }\n    for(i = 0; i < numArenas; i++) {\n        chunkArenas[i].bitmap = EMPTY_BITMAP;\n        chunkArenas[i].chunks = NULL;\n    }\n    currentArena = NULL;\n}\n\nstatic ChunkArenaPtr\nfindArena()\n{\n    ChunkArenaPtr arena = NULL;\n    int i;\n\n    for(i = 0; i < numArenas; i++) {\n        arena = &(chunkArenas[i]);\n        if(arena->bitmap != 0)\n            break;\n        else\n            arena = NULL;\n    }\n\n    assert(arena != NULL);\n\n    if(!arena->chunks) {\n        void *p;\n        p = alloc_arena(CHUNK_SIZE * ARENA_CHUNKS);\n        if(p == MAP_FAILED) {\n            do_log_error(L_ERROR, errno, \"Couldn't allocate chunk\");\n            maybe_free_chunks(1, 1);\n            return NULL;\n        }\n        arena->chunks = p;\n    }\n    return arena;\n}\n\nvoid *\nget_chunk()\n{\n    unsigned i;\n    ChunkArenaPtr arena = NULL;\n\n    if(currentArena && currentArena->bitmap != 0) {\n        arena = currentArena;\n    } else {\n        if(used_chunks >= CHUNKS(chunkHighMark))\n            maybe_free_chunks(0, 0);\n\n        if(used_chunks >= CHUNKS(chunkHighMark))\n            return NULL;\n        \n        arena = findArena();\n        if(!arena)\n            return NULL;\n        currentArena = arena;\n    }\n    i = BITMAP_FFS(arena->bitmap) - 1;\n    arena->bitmap &= ~BITMAP_BIT(i);\n    used_chunks++;\n    return arena->chunks + CHUNK_SIZE * i;\n}\n\nvoid *\nmaybe_get_chunk()\n{\n    unsigned i;\n    ChunkArenaPtr arena = NULL;\n\n    if(currentArena && currentArena->bitmap != 0) {\n        arena = currentArena;\n    } else {\n        if(used_chunks >= CHUNKS(chunkHighMark))\n            return NULL;\n\n        arena = findArena();\n        if(!arena)\n            return NULL;\n        currentArena = arena;\n    }\n    i = BITMAP_FFS(arena->bitmap) - 1;\n    arena->bitmap &= ~BITMAP_BIT(i);\n    used_chunks++;\n    return arena->chunks + CHUNK_SIZE * i;\n}\n\nvoid\ndispose_chunk(void *chunk)\n{\n    ChunkArenaPtr arena = NULL;\n    unsigned i;\n\n    assert(chunk != NULL);\n\n    if(currentArena && CHUNK_IN_ARENA(chunk, currentArena)) {\n        arena = currentArena;\n    } else {\n        for(i = 0; i < numArenas; i++) {\n            arena = &(chunkArenas[i]);\n            if(CHUNK_IN_ARENA(chunk, arena))\n                break;\n        }\n        assert(arena != NULL);\n        currentArena = arena;\n    }\n\n    i = CHUNK_ARENA_INDEX(chunk, arena);\n    arena->bitmap |= BITMAP_BIT(i);\n    used_chunks--;\n}\n\nvoid\nfree_chunk_arenas()\n{\n    ChunkArenaPtr arena;\n    int i, rc;\n\n    for(i = 0; i < numArenas; i++) {\n        arena = &(chunkArenas[i]);\n        if(arena->bitmap == EMPTY_BITMAP && arena->chunks) {\n            rc = free_arena(arena->chunks, CHUNK_SIZE * ARENA_CHUNKS);\n            if(rc < 0) {\n                do_log_error(L_ERROR, errno, \"Couldn't unmap memory\");\n                continue;\n            }\n            arena->chunks = NULL;\n        }\n    }\n    if(currentArena && currentArena->chunks == NULL)\n        currentArena = NULL;\n}\n\nint\ntotalChunkArenaSize()\n{\n    ChunkArenaPtr arena;\n    int i, size = 0;\n\n    for(i = 0; i < numArenas; i++) {\n        arena = &(chunkArenas[i]);\n        if(arena->chunks)\n            size += (CHUNK_SIZE * ARENA_CHUNKS);\n    }\n    return size;\n}\n#endif\n"
        },
        {
          "name": "chunk.h",
          "type": "blob",
          "size": 1.7744140625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* A larger chunk size gets you better I/O throughput, at the cost of\n   higer memory usage.  We assume you've got plenty of memory if you've\n   got 64-bit longs. */\n\n#ifndef CHUNK_SIZE\n#ifdef ULONG_MAX\n#if ULONG_MAX > 4294967295UL\n#define CHUNK_SIZE (8 * 1024)\n#else\n#define CHUNK_SIZE (4 * 1024)\n#endif\n#else\n#define CHUNK_SIZE (4 * 1024)\n#endif\n#endif\n\n#define CHUNKS(bytes) ((unsigned long)(bytes) / CHUNK_SIZE)\n\nextern int chunkLowMark, chunkHighMark, chunkCriticalMark;\nextern int used_chunks;\n\nvoid preinitChunks(void);\nvoid initChunks(void);\nvoid *get_chunk(void) ATTRIBUTE ((malloc));\nvoid *maybe_get_chunk(void) ATTRIBUTE ((malloc));\n\nvoid dispose_chunk(void *chunk);\nvoid free_chunk_arenas(void);\nint totalChunkArenaSize(void);\n"
        },
        {
          "name": "client.c",
          "type": "blob",
          "size": 70.3828125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nstatic int \nhttpAcceptAgain(TimeEventHandlerPtr event)\n{\n    FdEventHandlerPtr newevent;\n    int fd = *(int*)event->data;\n\n    newevent = schedule_accept(fd, httpAccept, NULL);\n    if(newevent == NULL) {\n        free_chunk_arenas();\n        newevent = schedule_accept(fd, httpAccept, NULL);\n        if(newevent == NULL) {\n            do_log(L_ERROR, \"Couldn't schedule accept.\\n\");\n            polipoExit();\n        }\n    }\n    return 1;\n}\n\nint\nhttpAccept(int fd, FdEventHandlerPtr event, AcceptRequestPtr request)\n{\n    int rc;\n    HTTPConnectionPtr connection;\n    TimeEventHandlerPtr timeout;\n\n    if(fd < 0) {\n        if(-fd == EINTR || -fd == EAGAIN || -fd == EWOULDBLOCK)\n            return 0;\n        do_log_error(L_ERROR, -fd, \"Couldn't establish listening socket\");\n        if(-fd == EMFILE || -fd == ENOMEM || -fd == ENOBUFS) {\n            TimeEventHandlerPtr again = NULL;\n            do_log(L_WARN, \"Refusing client connections for one second.\\n\");\n            free_chunk_arenas();\n            again = scheduleTimeEvent(1, httpAcceptAgain, \n                                      sizeof(request->fd), &request->fd);\n            if(!again) {\n                do_log(L_ERROR, \"Couldn't schedule accept -- sleeping.\\n\");\n                sleep(1);\n                again = scheduleTimeEvent(1, httpAcceptAgain, \n                                          sizeof(request->fd), &request->fd);\n                if(!again) {\n                    do_log(L_ERROR, \"Couldn't schedule accept -- aborting.\\n\");\n                    polipoExit();\n                }\n            }\n            return 1;\n        } else {\n            polipoExit();\n            return 1;\n        }\n    }\n\n    if(allowedNets) {\n        if(netAddressMatch(fd, allowedNets) != 1) {\n            do_log(L_WARN, \"Refusing connection from unauthorised net\\n\");\n            CLOSE(fd);\n            return 0;\n        }\n    }\n\n    rc = setNonblocking(fd, 1);\n    if(rc < 0) {\n        do_log_error(L_WARN, errno, \"Couldn't set non blocking mode\");\n        CLOSE(fd);\n        return 0;\n    }\n    rc = setNodelay(fd, 1);\n    if(rc < 0) \n        do_log_error(L_WARN, errno, \"Couldn't disable Nagle's algorithm\");\n\n    connection = httpMakeConnection();\n\n    timeout = scheduleTimeEvent(clientTimeout, httpTimeoutHandler,\n                                sizeof(connection), &connection);\n    if(!timeout) {\n        CLOSE(fd);\n        free(connection);\n        return 0;\n    }\n\n    connection->fd = fd;\n    connection->timeout = timeout;\n\n    do_log(D_CLIENT_CONN, \"Accepted client connection 0x%lx\\n\",\n           (unsigned long)connection);\n\n    connection->flags = CONN_READER;\n\n    do_stream_buf(IO_READ | IO_NOTNOW, connection->fd, 0,\n                  &connection->reqbuf, CHUNK_SIZE,\n                  httpClientHandler, connection);\n    return 0;\n}\n\n/* Abort a client connection.  It is only safe to abort the requests\n   if we know the connection is closed. */\nvoid\nhttpClientAbort(HTTPConnectionPtr connection, int closed)\n{\n    HTTPRequestPtr request = connection->request;\n\n    pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLOUT);\n    if(closed) {\n        while(request) {\n            if(request->chandler) {\n                request->error_code = 500;\n                request->error_message = internAtom(\"Connection finishing\");\n                abortConditionHandler(request->chandler);\n                request->chandler = NULL;\n            }\n            request = request->next;\n        }\n    }\n}\n\n/* s != 0 specifies that the connection must be shut down.  It is 1 in\n   order to linger the connection, 2 to close it straight away. */\nvoid\nhttpClientFinish(HTTPConnectionPtr connection, int s)\n{\n    HTTPRequestPtr request = connection->request;\n\n    assert(!(request && request->request \n             && request->request->request != request));\n\n    if(s == 0) {\n        if(!request || !(request->flags & REQUEST_PERSISTENT))\n            s = 1;\n    }\n\n    httpConnectionDestroyBuf(connection);\n\n    connection->flags &= ~CONN_WRITER;\n\n    if(connection->flags & CONN_SIDE_READER) {\n        /* We're in POST or PUT and the reader isn't done yet.\n           Wait for the read side to close the connection. */\n        assert(request && (connection->flags & CONN_READER));\n        if(s >= 2) {\n            pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLIN);\n        } else {\n            pokeFdEvent(connection->fd, -EDOGRACEFUL, POLLIN);\n        }\n        return;\n    }\n\n    if(connection->timeout) \n        cancelTimeEvent(connection->timeout);\n    connection->timeout = NULL;\n\n    if(request) {\n        HTTPRequestPtr requestee;\n\n        requestee = request->request;\n        if(requestee) {\n            request->request = NULL;\n            requestee->request = NULL;\n        }\n        if(requestee)\n            httpServerClientReset(requestee);\n        if(request->chandler) {\n            request->error_code = 500;\n            request->error_message = internAtom(\"Connection finishing\");\n            abortConditionHandler(request->chandler);\n            request->chandler = NULL;\n        }\n            \n        if(request->object) {\n            if(request->object->requestor == request)\n                request->object->requestor = NULL;\n            releaseObject(request->object);\n            request->object = NULL;\n        }\n        httpDequeueRequest(connection);\n        httpDestroyRequest(request);\n        request = NULL;\n\n    }\n\n    connection->len = -1;\n    connection->offset = 0;\n    connection->te = TE_IDENTITY;\n\n    if(!s) {\n        assert(connection->fd > 0);\n        connection->serviced++;\n        httpSetTimeout(connection, clientTimeout);\n        if(!(connection->flags & CONN_READER)) {\n            if(connection->reqlen == 0)\n                httpConnectionDestroyReqbuf(connection);\n            else if((connection->flags & CONN_BIGREQBUF) &&\n                    connection->reqlen < CHUNK_SIZE)\n                httpConnectionUnbigifyReqbuf(connection);\n            connection->flags |= CONN_READER;\n            httpSetTimeout(connection, clientTimeout);\n            do_stream_buf(IO_READ | IO_NOTNOW |\n                          (connection->reqlen ? IO_IMMEDIATE : 0),\n                          connection->fd, connection->reqlen,\n                          &connection->reqbuf,\n                          (connection->flags & CONN_BIGREQBUF) ?\n                          bigBufferSize : CHUNK_SIZE,\n                          httpClientHandler, connection);\n        }\n        /* The request has already been validated when it first got\n           into the queue */\n        if(connection->request) {\n            if(connection->request->object != NULL)\n                httpClientNoticeRequest(connection->request, 1);\n            else\n                assert(connection->flags & CONN_READER);\n        }\n        return;\n    }\n    \n    do_log(D_CLIENT_CONN, \"Closing client connection 0x%lx\\n\",\n           (unsigned long)connection);\n\n    if(connection->flags & CONN_READER) {\n        httpSetTimeout(connection, 10);\n        if(connection->fd < 0) return;\n        if(s >= 2) {\n            pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLIN);\n        } else {\n            pokeFdEvent(connection->fd, -EDOGRACEFUL, POLLIN);\n        }\n        return;\n    }\n    while(1) {\n        HTTPRequestPtr requestee;\n        request = connection->request;\n        if(!request)\n            break;\n        requestee = request->request;\n        request->request = NULL;\n        if(requestee) {\n            requestee->request = NULL;\n            httpServerClientReset(requestee);\n        }\n        if(request->chandler)\n            abortConditionHandler(request->chandler);\n        request->chandler = NULL;\n        if(request->object && request->object->requestor == request)\n            request->object->requestor = NULL;\n        httpDequeueRequest(connection);\n        httpDestroyRequest(request);\n    }\n    httpConnectionDestroyReqbuf(connection);\n    if(connection->timeout)\n        cancelTimeEvent(connection->timeout);\n    connection->timeout = NULL;\n    if(connection->fd >= 0) {\n        if(s >= 2)\n            CLOSE(connection->fd);\n        else\n            lingeringClose(connection->fd);\n    }\n    connection->fd = -1;\n    free(connection);\n}\n\n/* Extremely baroque implementation of close: we need to synchronise\n   between the writer and the reader.  */\n\nstatic char client_shutdown_buffer[17];\n\nstatic int httpClientDelayedShutdownHandler(TimeEventHandlerPtr);\n\nstatic int\nhttpClientDelayedShutdown(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr handler;\n\n    assert(connection->flags & CONN_READER);\n    handler = scheduleTimeEvent(1, httpClientDelayedShutdownHandler,\n                                sizeof(connection), &connection);\n    if(!handler) {\n        do_log(L_ERROR, \n               \"Couldn't schedule delayed shutdown -- freeing memory.\");\n        free_chunk_arenas();\n        handler = scheduleTimeEvent(1, httpClientDelayedShutdownHandler,\n                                    sizeof(connection), &connection);\n        if(!handler) {\n            do_log(L_ERROR, \n                   \"Couldn't schedule delayed shutdown -- aborting.\\n\");\n            polipoExit();\n        }\n    }\n    return 1;\n}\n\nstatic int\nhttpClientShutdownHandler(int status,\n                          FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->data;\n\n    assert(connection->flags & CONN_READER);\n\n    if(!(connection->flags & CONN_WRITER)) {\n        connection->flags &= ~CONN_READER;\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n        if(status && status != -EDOGRACEFUL)\n            httpClientFinish(connection, 2);\n        else\n            httpClientFinish(connection, 1);\n        return 1;\n    }\n\n    httpClientDelayedShutdown(connection);\n    return 1;\n}\n\nstatic int \nhttpClientDelayedShutdownHandler(TimeEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n    assert(connection->flags & CONN_READER);\n\n    if(!(connection->flags & CONN_WRITER)) {\n        connection->flags &= ~CONN_READER;\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n        httpClientFinish(connection, 1);\n        return 1;\n    }\n    do_stream(IO_READ | IO_NOTNOW, connection->fd, \n              0, client_shutdown_buffer, 17, \n              httpClientShutdownHandler, connection);\n    return 1;\n}\n\nint\nhttpClientHandler(int status,\n                  FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->data;\n    int i, body;\n    int bufsize = \n        (connection->flags & CONN_BIGREQBUF) ? bigBufferSize : CHUNK_SIZE;\n\n    assert(connection->flags & CONN_READER);\n\n    /* There's no point trying to do something with this request if\n       the client has shut the connection down -- HTTP doesn't do\n       half-open connections. */\n    if(status != 0) {\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n        if(!(connection->flags & CONN_WRITER)) {\n            connection->flags &= ~CONN_READER;\n            if(status > 0 || status == -ECONNRESET || status == -EDOSHUTDOWN)\n                httpClientFinish(connection, 2);\n            else\n                httpClientFinish(connection, 1);\n            return 1;\n        }\n        httpClientAbort(connection, status > 0 || status == -ECONNRESET);\n        connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    i = findEndOfHeaders(connection->reqbuf, 0, request->offset, &body);\n    connection->reqlen = request->offset;\n\n    if(i >= 0) {\n        connection->reqbegin = i;\n        httpClientHandlerHeaders(event, request, connection);\n        return 1;\n    }\n\n    if(connection->reqlen >= bufsize) {\n        int rc = 0;\n        if(!(connection->flags & CONN_BIGREQBUF))\n            rc = httpConnectionBigifyReqbuf(connection);\n        if((connection->flags & CONN_BIGREQBUF) &&\n           connection->reqlen < bigBufferSize) {\n            do_stream(IO_READ, connection->fd, connection->reqlen,\n                      connection->reqbuf, bigBufferSize,\n                      httpClientHandler, connection);\n            return 1;\n        }\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n        if(rc < 0) {\n            do_log(L_ERROR, \"Couldn't allocate big buffer.\\n\");\n            httpClientNewError(connection, METHOD_UNKNOWN, 0, 400, \n                               internAtom(\"Couldn't allocate big buffer\"));\n        } else {\n            do_log(L_ERROR, \"Couldn't find end of client's headers.\\n\");\n            httpClientNewError(connection, METHOD_UNKNOWN, 0, 400, \n                               internAtom(\"Couldn't find end of headers\"));\n        }\n        return 1;\n    }\n    httpSetTimeout(connection, clientTimeout);\n    return 0;\n}\n\nint\nhttpClientRawErrorHeaders(HTTPConnectionPtr connection,\n                          int code, AtomPtr message,\n                          int close, AtomPtr headers)\n{\n    int fd = connection->fd;\n    int n;\n    char *url; int url_len;\n    char *etag;\n\n    assert(connection->flags & CONN_WRITER);\n    assert(code != 0);\n\n    if(close >= 0) {\n        if(connection->request)\n            close = \n                close || !(connection->request->flags & REQUEST_PERSISTENT);\n        else\n            close = 1;\n    }\n    if(connection->request && connection->request->object) {\n        url = connection->request->object->key;\n        url_len = connection->request->object->key_size;\n        etag = connection->request->object->etag;\n    } else {\n        url = NULL;\n        url_len = 0;\n        etag = NULL;\n    }\n\n    if(connection->buf == NULL) {\n        connection->buf = get_chunk();\n        if(connection->buf == NULL) {\n            httpClientFinish(connection, 1);\n            return 1;\n        }\n    }\n\n    n = httpWriteErrorHeaders(connection->buf, CHUNK_SIZE, 0,\n                              connection->request &&\n                              connection->request->method != METHOD_HEAD,\n                              code, message, close > 0, headers,\n                              url, url_len, etag);\n    if(n <= 0) {\n        shutdown(connection->fd, 1);\n        if(close >= 0)\n            httpClientFinish(connection, 1);\n        return 1;\n    }\n\n    httpSetTimeout(connection, clientTimeout);\n    do_stream(IO_WRITE, fd, 0, connection->buf, n, \n              close > 0 ? httpErrorStreamHandler :\n              close == 0 ? httpErrorNocloseStreamHandler :\n              httpErrorNofinishStreamHandler,\n              connection);\n\n    return 1;\n}\n\nint\nhttpClientRawError(HTTPConnectionPtr connection, int code, AtomPtr message,\n                   int close)\n{\n    return httpClientRawErrorHeaders(connection, code, message, close, NULL);\n}\n\nint\nhttpClientNoticeErrorHeaders(HTTPRequestPtr request, int code, AtomPtr message,\n                             AtomPtr headers)\n{\n    if(request->error_message)\n        releaseAtom(request->error_message);\n    if(request->error_headers)\n        releaseAtom(request->error_headers);\n    request->error_code = code;\n    request->error_message = message;\n    request->error_headers = headers;\n    httpClientNoticeRequest(request, 0);\n    return 1;\n}\n\nint\nhttpClientNoticeError(HTTPRequestPtr request, int code, AtomPtr message)\n{\n    return httpClientNoticeErrorHeaders(request, code, message, NULL);\n}\n\nint\nhttpClientError(HTTPRequestPtr request, int code, AtomPtr message)\n{\n    if(request->error_message)\n        releaseAtom(request->error_message);\n    request->error_code = code;\n    request->error_message = message;\n    if(request->chandler) {\n        abortConditionHandler(request->chandler);\n        request->chandler = NULL;\n    } else if(request->object)\n        notifyObject(request->object);\n    return 1;\n}\n\n/* This may be called from object handlers. */\nint\nhttpClientLeanError(HTTPRequestPtr request, int code, AtomPtr message)\n{\n    if(request->error_message)\n        releaseAtom(request->error_message);\n    request->error_code = code;\n    request->error_message = message;\n    return 1;\n}\n\n\nint\nhttpClientNewError(HTTPConnectionPtr connection, int method, int persist,\n                   int code, AtomPtr message)\n{\n    HTTPRequestPtr request;\n    request = httpMakeRequest();\n    if(request == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate error request.\\n\");\n        httpClientFinish(connection, 1);\n        return 1;\n    }\n    request->method = method;\n    if(persist)\n        request->flags |= REQUEST_PERSISTENT;\n    else\n        request->flags &= ~REQUEST_PERSISTENT;\n    request->error_code = code;\n    request->error_message = message;\n\n    httpQueueRequest(connection, request);\n    httpClientNoticeRequest(request, 0);\n    return 1;\n}\n        \nint\nhttpErrorStreamHandler(int status,\n                       FdEventHandlerPtr event,\n                       StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n\n    if(status == 0 && !streamRequestDone(srequest))\n        return 0;\n\n    httpClientFinish(connection, 1);\n    return 1;\n}\n\nint\nhttpErrorNocloseStreamHandler(int status,\n                              FdEventHandlerPtr event,\n                              StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n\n    if(status == 0 && !streamRequestDone(srequest))\n        return 0;\n\n    httpClientFinish(connection, 0);\n    return 1;\n}\n\nint\nhttpErrorNofinishStreamHandler(int status,\n                               FdEventHandlerPtr event,\n                               StreamRequestPtr srequest)\n{\n    if(status == 0 && !streamRequestDone(srequest))\n        return 0;\n\n    return 1;\n}\n\nint\nhttpClientHandlerHeaders(FdEventHandlerPtr event, StreamRequestPtr srequest,\n                         HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request;\n    int rc;\n    int method, version;\n    AtomPtr url = NULL;\n    int start;\n    int code;\n    AtomPtr message;\n\n    start = 0;\n    /* Work around clients working around NCSA lossage. */\n    if(connection->reqbuf[0] == '\\n')\n        start = 1;\n    else if(connection->reqbuf[0] == '\\r' && connection->reqbuf[1] == '\\n')\n        start = 2;\n\n    httpSetTimeout(connection, -1);\n    rc = httpParseClientFirstLine(connection->reqbuf, start,\n                                  &method, &url, &version);\n    if(rc <= 0) {\n        do_log(L_ERROR, \"Couldn't parse client's request line\\n\");\n        code = 400;\n        message =  internAtom(\"Error in request line\");\n        goto fail;\n    }\n\n    do_log(D_CLIENT_REQ, \"Client request: \");\n    do_log_n(D_CLIENT_REQ, connection->reqbuf, rc - 1);\n    do_log(D_CLIENT_REQ, \"\\n\");\n\n    if(version != HTTP_10 && version != HTTP_11) {\n        do_log(L_ERROR, \"Unknown client HTTP version\\n\");\n        code = 400;\n        message = internAtom(\"Error in first request line\");\n        goto fail;\n    }\n\n    if(method == METHOD_UNKNOWN) {\n        code = 501;\n        message =  internAtom(\"Method not implemented\");\n        goto fail;\n    }\n\n    request = httpMakeRequest();\n    if(request == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate client request.\\n\");\n        code = 500;\n        message = internAtom(\"Couldn't allocate client request\");\n        goto fail;\n    }\n\n    if(connection->version != HTTP_UNKNOWN && version != connection->version) {\n        do_log(L_WARN, \"Client version changed!\\n\");\n    }\n\n    connection->version = version;\n    request->flags = REQUEST_PERSISTENT;\n    request->method = method;\n    request->cache_control = no_cache_control;\n    httpQueueRequest(connection, request);\n    connection->reqbegin = rc;\n    return httpClientRequest(request, url);\n\n fail:\n    if(url) releaseAtom(url);\n    shutdown(connection->fd, 0);\n    connection->reqlen = 0;\n    connection->reqbegin = 0;\n    httpConnectionDestroyReqbuf(connection);\n    connection->flags &= ~CONN_READER;\n    httpClientNewError(connection, METHOD_UNKNOWN, 0, code, message);\n    return 1;\n\n}\n\nstatic int\nhttpClientRequestDelayed(TimeEventHandlerPtr event)\n{\n    HTTPRequestPtr request = *(HTTPRequestPtr*)event->data;\n    AtomPtr url;\n    url = internAtomN(request->object->key, request->object->key_size);\n    if(url == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate url.\\n\");\n        abortObject(request->object, 503, internAtom(\"Couldn't allocate url\"));\n        return 1;\n    }\n    httpClientRequest(request, url);\n    return 1;\n}\n\nint\ndelayedHttpClientRequest(HTTPRequestPtr request)\n{\n    TimeEventHandlerPtr event;\n    event = scheduleTimeEvent(-1, httpClientRequestDelayed,\n                              sizeof(request), &request);\n    if(!event)\n        return -1;\n    return 1;\n}\n\nint\nhttpClientRequest(HTTPRequestPtr request, AtomPtr url)\n{\n    HTTPConnectionPtr connection = request->connection;\n    int i, rc;\n    int body_len, body_te;\n    AtomPtr headers;\n    CacheControlRec cache_control;\n    AtomPtr via, expect, auth;\n    HTTPConditionPtr condition;\n    HTTPRangeRec range;\n\n    assert(!request->chandler);\n    assert(connection->reqbuf);\n\n    i = httpParseHeaders(1, url,\n                         connection->reqbuf, connection->reqbegin, request,\n                         &headers, &body_len, \n                         &cache_control, &condition, &body_te,\n                         NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n                         &expect, &range, NULL, NULL, &via, &auth);\n    if(i < 0) {\n        releaseAtom(url);\n        do_log(L_ERROR, \"Couldn't parse client headers.\\n\");\n        shutdown(connection->fd, 0);\n        request->flags &= ~REQUEST_PERSISTENT;\n        connection->flags &= ~CONN_READER;\n        httpClientNoticeError(request, 503,\n                              internAtom(\"Couldn't parse client headers\"));\n        return 1;\n    }\n\n    connection->reqbegin = i;\n\n    if(body_len < 0) {\n        if(request->method == METHOD_GET || request->method == METHOD_HEAD ||\n           request->method == METHOD_POST || request->method == METHOD_OPTIONS ||\n           request->method == METHOD_DELETE)\n            body_len = 0;\n    }\n    connection->bodylen = body_len;\n    connection->reqte = body_te;\n\n    if(authRealm) {\n        AtomPtr message = NULL;\n        AtomPtr challenge = NULL;\n        int code = checkClientAuth(auth, url, &message, &challenge);\n        if(auth) {\n            releaseAtom(auth);\n            auth = NULL;\n        }\n        if(expect) {\n            releaseAtom(expect);\n            expect = NULL;\n        }\n        if(code) {\n            request->flags |= REQUEST_FORCE_ERROR;\n            httpClientDiscardBody(connection);\n            httpClientNoticeErrorHeaders(request, code, message, challenge);\n            return 1;\n        }\n    }\n\n    if(auth) {\n        releaseAtom(auth);\n        auth = NULL;\n    }\n\n    if(expect) {\n        if(expect == atom100Continue && REQUEST_SIDE(request)) {\n            request->flags |= REQUEST_WAIT_CONTINUE;\n        } else {\n            httpClientDiscardBody(connection);\n            httpClientNoticeError(request, 417,\n                                  internAtom(\"Expectation failed\"));\n            releaseAtom(expect);\n            return 1;\n        }\n        releaseAtom(expect);\n    }\n\n    request->from = range.from < 0 ? 0 : range.from;\n    request->to = range.to;\n    request->cache_control = cache_control;\n    request->via = via;\n    request->headers = headers;\n    request->condition = condition;\n    request->object = NULL;\n\n    if(connection->serviced > 500)\n        request->flags &= ~REQUEST_PERSISTENT;\n\n    if(request->method == METHOD_CONNECT) {\n        if(connection->flags & CONN_WRITER) {\n            /* For now */\n            httpClientDiscardBody(connection);\n            httpClientNoticeError(request, 500,\n                                  internAtom(\"Pipelined CONNECT \"\n                                             \"not supported\"));\n            return 1;\n        }\n        if(connection->flags & CONN_BIGREQBUF) {\n            /* For now */\n            httpClientDiscardBody(connection);\n            httpClientNoticeError(request, 500,\n                                  internAtom(\"CONNECT over big buffer \"\n                                             \"not supported\"));\n            return 1;\n        }\n        connection->flags &= ~CONN_READER;\n        do_tunnel(connection->fd, connection->reqbuf, \n                  connection->reqbegin, connection->reqlen, url);\n        connection->fd = -1;\n        connection->reqbuf = NULL;\n        connection->reqlen = 0;\n        connection->reqbegin = 0;\n        httpClientFinish(connection, 2);\n        return 1;\n    }\n\n    rc = urlForbidden(url, httpClientRequestContinue, request);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Couldn't schedule httpClientRequestContinue.\\n\");\n        httpClientDiscardBody(connection);\n        httpClientNoticeError(request, 500,\n                              internAtom(\"Couldn't schedule \"\n                                         \"httpClientRequestContinue\"));\n        return 1;\n    }\n    return 1;\n}\n\nint\nhttpClientRequestContinue(int forbidden_code, AtomPtr url,\n                          AtomPtr forbidden_message, AtomPtr forbidden_headers,\n                          void *closure)\n{\n    HTTPRequestPtr request = (HTTPRequestPtr)closure;\n    HTTPConnectionPtr connection = request->connection;\n    RequestFunction requestfn;\n    ObjectPtr object = NULL;\n\n    if(forbidden_code < 0) {\n        releaseAtom(url);\n        httpClientDiscardBody(connection);\n        httpClientNoticeError(request, 500, \n                              internAtomError(-forbidden_code,\n                                              \"Couldn't test for forbidden \"\n                                              \"URL\"));\n        return 1;\n    }\n\n    if(forbidden_code) {\n        releaseAtom(url);\n        httpClientDiscardBody(connection);\n        httpClientNoticeErrorHeaders(request,\n                                     forbidden_code, forbidden_message,\n                                     forbidden_headers);\n        return 1;\n    }\n\n    requestfn = \n        urlIsLocal(url->string, url->length) ? \n        httpLocalRequest :\n        httpServerRequest;\n\n    if(request->method == METHOD_POST || request->method == METHOD_PUT ||\n       request->method == METHOD_OPTIONS || request->method == METHOD_DELETE) {\n        do {\n            object = findObject(OBJECT_HTTP, url->string, url->length);\n            if(object) {\n                privatiseObject(object, 0);\n                releaseObject(object);\n            }\n        } while(object);\n        request->object = makeObject(OBJECT_HTTP, url->string, url->length,\n                                     0, 0, requestfn, NULL);\n        if(request->object == NULL) {\n            httpClientDiscardBody(connection);\n            httpClientNoticeError(request, 503,\n                                  internAtom(\"Couldn't allocate object\"));\n            return 1;\n        }\n        if(requestfn == httpLocalRequest)\n            request->object->flags |= OBJECT_LOCAL;\n        return httpClientSideRequest(request);\n    }\n\n    if(request->cache_control.flags & CACHE_AUTHORIZATION) {\n        do {\n            object = makeObject(OBJECT_HTTP, url->string, url->length, 0, 0,\n                                requestfn, NULL);\n            if(object && object->flags != OBJECT_INITIAL) {\n                if(!(object->cache_control & CACHE_PUBLIC)) {\n                    privatiseObject(object, 0);\n                    releaseObject(object);\n                    object = NULL;\n                } else\n                    break;\n            }\n        } while(object == NULL);\n        if(object)\n            object->flags |= OBJECT_LINEAR;\n    } else {\n        object = findObject(OBJECT_HTTP, url->string, url->length);\n        if(!object)\n            object = makeObject(OBJECT_HTTP, url->string, url->length, 1, 1,\n                                requestfn, NULL);\n    }\n    releaseAtom(url);\n    url = NULL;\n\n    if(!object) {\n        do_log(L_ERROR, \"Couldn't allocate object.\\n\");\n        httpClientDiscardBody(connection);\n        httpClientNoticeError(request, 503,\n                              internAtom(\"Couldn't allocate object\"));\n        return 1;\n    }\n\n    if(object->request == httpLocalRequest) {\n        object->flags |= OBJECT_LOCAL;\n    } else {\n        if(disableProxy) {\n            httpClientDiscardBody(connection);\n            httpClientNoticeError(request, 403,\n                                  internAtom(\"Proxying disabled\"));\n            releaseObject(object);\n            return 1;\n        }\n\n        if(!checkVia(proxyName, request->via)) {\n            httpClientDiscardBody(connection);\n            httpClientNoticeError(request, 504, \n                                  internAtom(\"Proxy loop detected\"));\n            releaseObject(object);\n            return 1;\n        }\n    }\n\n    request->object = object;\n\n    httpClientDiscardBody(connection);\n    httpClientNoticeRequest(request, 0);\n    return 1;\n}\n\nstatic int httpClientDelayed(TimeEventHandlerPtr handler);\n\nint\nhttpClientDiscardBody(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr handler;\n\n    assert(connection->reqoffset == 0);\n    assert(connection->flags & CONN_READER);\n\n    if(connection->reqte != TE_IDENTITY)\n        goto fail;\n\n    if(connection->bodylen < 0)\n        goto fail;\n\n    if(connection->bodylen < connection->reqlen - connection->reqbegin) {\n        connection->reqbegin += connection->bodylen;\n        connection->bodylen = 0;\n    } else {\n        connection->bodylen -= connection->reqlen - connection->reqbegin;\n        connection->reqbegin = 0;\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n    }\n    connection->reqte = TE_UNKNOWN;\n\n    if(connection->bodylen > 0) {\n        httpSetTimeout(connection, clientTimeout);\n        do_stream_buf(IO_READ | IO_NOTNOW,\n                      connection->fd, connection->reqlen,\n                      &connection->reqbuf, CHUNK_SIZE,\n                      httpClientDiscardHandler, connection);\n        return 1;\n    }\n\n    if(connection->reqlen > connection->reqbegin) {\n        memmove(connection->reqbuf, connection->reqbuf + connection->reqbegin,\n                connection->reqlen - connection->reqbegin);\n        connection->reqlen -= connection->reqbegin;\n        connection->reqbegin = 0;\n    } else {\n        connection->reqlen = 0;\n        connection->reqbegin = 0;\n    }\n\n    httpSetTimeout(connection, clientTimeout);\n    /* We need to delay in order to make sure the previous request\n       gets queued on the server side.  IO_NOTNOW isn't strong enough\n       for that due to IO_IMMEDIATE. */\n    handler = scheduleTimeEvent(-1, httpClientDelayed,\n                                sizeof(connection), &connection);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule reading from client.\");\n        goto fail;\n    }\n    return 1;\n\n fail:\n    connection->reqlen = 0;\n    connection->reqbegin = 0;\n    connection->bodylen = 0;\n    connection->reqte = TE_UNKNOWN;\n    shutdown(connection->fd, 2);\n    handler = scheduleTimeEvent(-1, httpClientDelayed,\n                                sizeof(connection), &connection);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule reading from client.\");\n        connection->flags &= ~CONN_READER;\n    }\n    return 1;\n}\n\nstatic int\nhttpClientDelayed(TimeEventHandlerPtr event)\n{\n     HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n\n     /* IO_NOTNOW is unfortunate, but needed to avoid starvation if a\n        client is pipelining a lot of requests. */\n     if(connection->reqlen > 0) {\n         int bufsize;\n         if((connection->flags & CONN_BIGREQBUF) &&\n            connection->reqlen < CHUNK_SIZE)\n             httpConnectionUnbigifyReqbuf(connection);\n         /* Don't read new requests if buffer is big. */\n         bufsize = (connection->flags & CONN_BIGREQBUF) ?\n             connection->reqlen : CHUNK_SIZE;\n         do_stream(IO_READ | IO_IMMEDIATE | IO_NOTNOW,\n                   connection->fd, connection->reqlen,\n                   connection->reqbuf, bufsize,\n                   httpClientHandler, connection);\n     } else {\n         httpConnectionDestroyReqbuf(connection);\n         do_stream_buf(IO_READ | IO_NOTNOW,\n                       connection->fd, 0,\n                       &connection->reqbuf, CHUNK_SIZE,\n                       httpClientHandler, connection);\n     }\n     return 1;\n}\n\nint\nhttpClientDiscardHandler(int status,\n                         FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->data;\n\n    assert(connection->flags & CONN_READER);\n    if(status) {\n        if(status < 0 && status != -EPIPE && status != -ECONNRESET)\n            do_log_error(L_ERROR, -status, \"Couldn't read from client\");\n        connection->bodylen = -1;\n        return httpClientDiscardBody(connection);\n    }\n\n    assert(request->offset > connection->reqlen);\n    connection->reqlen = request->offset;\n\n    httpClientDiscardBody(connection);\n    return 1;\n}\n\nint\nhttpClientNoticeRequest(HTTPRequestPtr request, int novalidate)\n{\n    HTTPConnectionPtr connection = request->connection;\n    ObjectPtr object = request->object;\n    int serveNow = (request == connection->request);\n    int validate = 0;\n    int conditional = 0;\n    int local, haveData;\n    int rc;\n\n    assert(!request->chandler);\n\n    if(request->error_code) {\n        if((request->flags & REQUEST_FORCE_ERROR) || REQUEST_SIDE(request) ||\n           request->object == NULL ||\n           (request->object->flags & OBJECT_LOCAL) ||\n           (request->object->flags & OBJECT_ABORTED) ||\n           (relaxTransparency < 1 && !proxyOffline)) {\n            if(serveNow) {\n                connection->flags |= CONN_WRITER;\n                return httpClientRawErrorHeaders(connection,\n                                                 request->error_code, \n                                                 retainAtom(request->\n                                                            error_message),\n                                                 0, request->error_headers);\n            } else {\n                return 1;\n            }\n        }\n    }\n\n    if(REQUEST_SIDE(request)) {\n        assert(!(request->flags & REQUEST_REQUESTED));\n        if(serveNow) {\n            assert(!request->chandler);\n            request->chandler =\n                conditionWait(&request->object->condition, \n                              httpClientGetHandler,\n                              sizeof(request), &request);\n            if(request->chandler == NULL) {\n                do_log(L_ERROR, \"Couldn't register condition handler.\\n\");\n                connection->flags |= CONN_WRITER;\n                httpClientRawError(connection, 500,\n                                   internAtom(\"Couldn't register \"\n                                              \"condition handler\"),\n                                   0);\n                return 1;\n            }\n            connection->flags |= CONN_WRITER;\n            rc = object->request(request->object,\n                                 request->method,\n                                 request->from, request->to, \n                                 request,\n                                 request->object->request_closure);\n        }\n        return 1;\n    }\n\n    local = urlIsLocal(object->key, object->key_size);\n    objectFillFromDisk(object, request->from,\n                       request->method == METHOD_HEAD ? 0 : 1);\n\n    /* The spec doesn't strictly forbid 206 for non-200 instances, but doing\n       that breaks some client software. */\n    if(object->code && object->code != 200) {\n        request->from = 0;\n        request->to = -1;\n    }\n\n    if(request->condition && request->condition->ifrange) {\n        if(!object->etag || \n           strcmp(object->etag, request->condition->ifrange) != 0) {\n            request->from = 0;\n            request->to = -1;\n        }\n    }\n\n    if(object->flags & OBJECT_DYNAMIC) {\n        request->from = 0;\n        request->to = -1;\n    }\n\n    if(request->method == METHOD_HEAD)\n        haveData = !(request->object->flags & OBJECT_INITIAL);\n    else\n        haveData = \n            (request->object->length >= 0 && \n             request->object->length <= request->from) ||\n            (objectHoleSize(request->object, request->from) == 0);\n\n    if(request->flags & REQUEST_REQUESTED)\n        validate = 0;\n    else if(novalidate || (!local && proxyOffline))\n        validate = 0;\n    else if(local)\n        validate = \n            objectMustRevalidate(request->object, &request->cache_control);\n    else if(request->cache_control.flags & CACHE_ONLY_IF_CACHED)\n        validate = 0;\n    else if((request->object->flags & OBJECT_FAILED) &&\n            !(object->flags & OBJECT_INPROGRESS) &&\n            !relaxTransparency)\n        validate = 1;\n    else if(request->method != METHOD_HEAD &&\n            !objectHasData(object, request->from, request->to) &&\n            !(object->flags & OBJECT_INPROGRESS))\n        validate = 1;\n    else if(objectMustRevalidate((relaxTransparency <= 1 ? \n                                  request->object : NULL),\n                                 &request->cache_control))\n        validate = 1;\n    else\n        validate = 0;\n\n    if(request->cache_control.flags & CACHE_ONLY_IF_CACHED) {\n        validate = 0;\n        if(!haveData) {\n            if(serveNow) {\n                connection->flags |= CONN_WRITER;\n                return httpClientRawError(connection, 504,\n                                          internAtom(\"Object not in cache\"),\n                                          0);\n            } else\n                return 1;\n        }\n    }\n\n    if(!(request->object->flags & OBJECT_VALIDATING) &&\n       ((!validate && haveData) ||\n        (request->object->flags & OBJECT_FAILED))) {\n        if(serveNow) {\n            connection->flags |= CONN_WRITER;\n            lockChunk(request->object, request->from / CHUNK_SIZE);\n            return httpServeObject(connection);\n        } else {\n            return 1;\n        }\n    }\n\n    if((request->flags & REQUEST_REQUESTED) &&\n       !(request->object->flags & OBJECT_INPROGRESS)) {\n        /* This can happen either because the server side ran out of\n           memory, or because it is using HEAD validation.  We mark\n           the object to be fetched again. */\n        request->flags &= ~REQUEST_REQUESTED;\n    }\n\n    if(serveNow) {\n        connection->flags |= CONN_WRITER;\n        if(!local && proxyOffline)\n            return httpClientRawError(connection, 502, \n                                      internAtom(\"Disconnected operation \"\n                                                 \"and object not in cache\"),\n                                      0);\n        request->chandler =\n            conditionWait(&request->object->condition, httpClientGetHandler, \n                          sizeof(request), &request);\n        if(request->chandler == NULL) {\n            do_log(L_ERROR, \"Couldn't register condition handler.\\n\");\n            return httpClientRawError(connection, 503,\n                                      internAtom(\"Couldn't register \"\n                                                 \"condition handler\"), 0);\n        }\n    }\n\n    if(request->object->flags & OBJECT_VALIDATING)\n        return 1;\n\n    conditional = (haveData && request->method == METHOD_GET);\n    if(!mindlesslyCacheVary && (request->object->cache_control & CACHE_VARY))\n        conditional = conditional && (request->object->etag != NULL);\n\n    conditional =\n        conditional && !(request->object->cache_control & CACHE_MISMATCH);\n\n    if(!(request->object->flags & OBJECT_INPROGRESS))\n        request->object->flags |= OBJECT_VALIDATING;\n    rc = request->object->request(request->object,\n                                  conditional ? METHOD_CONDITIONAL_GET : \n                                  request->method,\n                                  request->from, request->to, request,\n                                  request->object->request_closure);\n    if(rc < 0) {\n        if(request->chandler)\n            unregisterConditionHandler(request->chandler);\n        request->chandler = NULL;\n        request->object->flags &= ~OBJECT_VALIDATING;\n        request->object->flags |= OBJECT_FAILED;\n        if(request->error_message)\n            releaseAtom(request->error_message);\n        request->error_code = 503;\n        request->error_message = internAtom(\"Couldn't schedule get\");\n    }\n    return 1;\n}\n\nstatic int\nhttpClientNoticeRequestDelayed(TimeEventHandlerPtr event)\n{\n    HTTPRequestPtr request = *(HTTPRequestPtr*)event->data;\n    httpClientNoticeRequest(request, 0);\n    return 1;\n}\n\nint\ndelayedHttpClientNoticeRequest(HTTPRequestPtr request)\n{\n    TimeEventHandlerPtr event;\n    event = scheduleTimeEvent(-1, httpClientNoticeRequestDelayed,\n                              sizeof(request), &request);\n    if(!event)\n        return -1;\n    return 1;\n}\n\nint\nhttpClientContinueDelayed(TimeEventHandlerPtr event)\n{\n    static char httpContinue[] = \"HTTP/1.1 100 Continue\\r\\n\\r\\n\";\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n\n    do_stream(IO_WRITE, connection->fd, 0, httpContinue, 25,\n              httpErrorNofinishStreamHandler, connection);\n    return 1;\n}\n\nint\ndelayedHttpClientContinue(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr event;\n    event = scheduleTimeEvent(-1, httpClientContinueDelayed,\n                              sizeof(connection), &connection);\n    if(!event)\n        return -1;\n    return 1;\n}\n\nint\nhttpClientGetHandler(int status, ConditionHandlerPtr chandler)\n{\n    HTTPRequestPtr request = *(HTTPRequestPtr*)chandler->data;\n    HTTPConnectionPtr connection = request->connection;\n    ObjectPtr object = request->object;\n    int rc;\n\n    assert(request == connection->request);\n\n    if(request->request) {\n        assert(request->object->flags & OBJECT_INPROGRESS);\n        assert(!request->request->object ||\n               request->request->object == request->object);\n    }\n\n    if(status < 0) {\n        object->flags &= ~OBJECT_VALIDATING; /* for now */\n        if(request->request && request->request->request == request)\n            httpServerClientReset(request->request);\n        lockChunk(object, request->from / CHUNK_SIZE);\n        request->chandler = NULL;\n        rc = delayedHttpServeObject(connection);\n        if(rc < 0) {\n            unlockChunk(object, request->from / CHUNK_SIZE);\n            do_log(L_ERROR, \"Couldn't schedule serving.\\n\");\n            abortObject(object, 503, internAtom(\"Couldn't schedule serving\"));\n        }\n        return 1;\n    }\n\n    if(object->flags & OBJECT_VALIDATING)\n        return 0;\n\n    if(request->error_code) {\n        lockChunk(object, request->from / CHUNK_SIZE);\n        request->chandler = NULL;\n        rc = delayedHttpServeObject(connection);\n        if(rc < 0) {\n            unlockChunk(object, request->from / CHUNK_SIZE);\n            do_log(L_ERROR, \"Couldn't schedule serving.\\n\");\n            abortObject(object, 503, internAtom(\"Couldn't schedule serving\"));\n        }\n        return 1;\n    }\n\n    if(request->flags & REQUEST_WAIT_CONTINUE) {\n        if(request->request && \n           !(request->request->flags & REQUEST_WAIT_CONTINUE)) {\n            request->flags &= ~REQUEST_WAIT_CONTINUE;\n            delayedHttpClientContinue(connection);\n        }\n        return 0;\n    }\n\n    /* See httpServerHandlerHeaders */\n    if((object->flags & OBJECT_SUPERSEDED) &&\n       /* Avoid superseding loops. */\n       !(request->flags & REQUEST_SUPERSEDED) &&\n       request->request && request->request->can_mutate) {\n        ObjectPtr new_object = retainObject(request->request->can_mutate);\n        if(object->requestor == request) {\n            if(new_object->requestor == NULL)\n                new_object->requestor = request;\n            object->requestor = NULL;\n            /* Avoid superseding the same request more than once. */\n            request->flags |= REQUEST_SUPERSEDED;\n        }\n        request->chandler = NULL;\n        releaseObject(object);\n        request->object = new_object;\n        request->request->object = new_object;\n        /* We're handling the wrong object now.  It's simpler to\n           rebuild the whole data structure from scratch rather than\n           trying to compensate. */\n        rc = delayedHttpClientNoticeRequest(request);\n        if(rc < 0) {\n            do_log(L_ERROR, \"Couldn't schedule noticing of request.\");\n            abortObject(object, 500,\n                        internAtom(\"Couldn't schedule \"\n                                   \"noticing of request\"));\n            /* We're probably out of memory.  What can we do? */\n            shutdown(connection->fd, 1);\n        }\n        return 1;\n    }\n\n    if(object->requestor != request && !(object->flags & OBJECT_ABORTED)) {\n        /* Make sure we don't serve an object that is stale for us\n           unless we're the requestor. */\n        if((object->flags & (OBJECT_LINEAR | OBJECT_MUTATING)) ||\n           objectMustRevalidate(object, &request->cache_control)) {\n           if(object->flags & OBJECT_INPROGRESS)\n               return 0;\n           rc = delayedHttpClientNoticeRequest(request);\n           if(rc < 0) {\n               do_log(L_ERROR, \"Couldn't schedule noticing of request.\");\n               abortObject(object, 500,\n                           internAtom(\"Couldn't schedule \"\n                                      \"noticing of request\"));\n           } else {\n               request->chandler = NULL;\n               return 1;\n           }\n        }\n    }\n\n    if(object->flags & (OBJECT_INITIAL | OBJECT_VALIDATING)) {\n        if(object->flags & (OBJECT_INPROGRESS | OBJECT_VALIDATING)) {\n            return 0;\n        } else if(object->flags & OBJECT_FAILED) {\n            if(request->error_code)\n                abortObject(object, \n                            request->error_code, \n                            retainAtom(request->error_message));\n            else {\n                abortObject(object, 500,\n                            internAtom(\"Error message lost in transit\"));\n            }\n        } else {\n            /* The request was pruned by httpServerDiscardRequests */\n            if(chandler == request->chandler) {\n                int rc;\n                request->chandler = NULL;\n                rc = delayedHttpClientNoticeRequest(request);\n                if(rc < 0)\n                    abortObject(object, 500,\n                                internAtom(\"Couldn't allocate \"\n                                           \"delayed notice request\"));\n                else\n                    return 1;\n            } else {\n                abortObject(object, 500,\n                            internAtom(\"Wrong request pruned -- \"\n                                       \"this shouldn't happen\"));\n            }\n        }\n    }\n\n    if(request->object->flags & OBJECT_DYNAMIC) {\n        if(objectHoleSize(request->object, 0) == 0) {\n            request->from = 0;\n            request->to = -1;\n        } else {\n            /* We really should request again if that is not the case */\n        }\n    }\n\n    lockChunk(object, request->from / CHUNK_SIZE);\n    request->chandler = NULL;\n    rc = delayedHttpServeObject(connection);\n    if(rc < 0) {\n        unlockChunk(object, request->from / CHUNK_SIZE);\n        do_log(L_ERROR, \"Couldn't schedule serving.\\n\");\n        abortObject(object, 503, internAtom(\"Couldn't schedule serving\"));\n    }\n    return 1;\n}\n\nint\nhttpClientSideRequest(HTTPRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->connection;\n\n    if(request->from < 0 || request->to >= 0) {\n        httpClientNoticeError(request, 501,\n                              internAtom(\"Partial requests not implemented\"));\n        httpClientDiscardBody(connection);\n        return 1;\n    }\n    if(connection->reqte != TE_IDENTITY) {\n        httpClientNoticeError(request, 501,\n                              internAtom(\"Chunked requests not implemented\"));\n        httpClientDiscardBody(connection);\n        return 1;\n    }\n    if(connection->bodylen < 0) {\n        httpClientNoticeError(request, 502,\n                              internAtom(\"POST or PUT without \"\n                                         \"Content-Length\"));\n        httpClientDiscardBody(connection);\n        return 1;\n    }\n    if(connection->reqlen < 0) {\n        httpClientNoticeError(request, 502,\n                              internAtom(\"Incomplete POST or PUT\"));\n        httpClientDiscardBody(connection);\n        return 1;\n    }\n        \n    return httpClientNoticeRequest(request, 0);\n}\n\nint \nhttpClientSideHandler(int status,\n                      FdEventHandlerPtr event,\n                      StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    HTTPRequestPtr requestee;\n    HTTPConnectionPtr server;\n    int push;\n    int code;\n    AtomPtr message = NULL;\n\n    assert(connection->flags & CONN_SIDE_READER);\n\n    if((request->object->flags & OBJECT_ABORTED) || \n       !(request->object->flags & OBJECT_INPROGRESS)) {\n        code = request->object->code;\n        message = retainAtom(request->object->message);\n        goto fail;\n    }\n        \n    if(status < 0) {\n        do_log_error(L_ERROR, -status, \"Reading from client\");\n        code = 502;\n        message = internAtomError(-status, \"Couldn't read from client\");\n        goto fail;\n    }\n\n    requestee = request->request;\n    server = requestee->connection;\n\n    push = MIN(srequest->offset - connection->reqlen, \n               connection->bodylen - connection->reqoffset);\n    if(push > 0) {\n        connection->reqlen += push;\n        httpServerDoSide(server);\n        return 1;\n    }\n\n    if(server->reqoffset >= connection->bodylen) {\n        connection->flags &= ~(CONN_READER | CONN_SIDE_READER);\n        return 1;\n    }\n\n    assert(status);\n    do_log(L_ERROR, \"Incomplete client request.\\n\");\n    code = 502;\n    message = internAtom(\"Incomplete client request\");\n\n fail:\n    request->error_code = code;\n    if(request->error_message)\n        releaseAtom(request->error_message);\n    request->error_message = message;\n    if(request->error_headers)\n        releaseAtom(request->error_headers);\n    request->error_headers = NULL;\n\n    if(request->request) {\n        shutdown(request->request->connection->fd, 2);\n        pokeFdEvent(request->request->connection->fd, -ESHUTDOWN, POLLOUT);\n    }\n    notifyObject(request->object);\n    connection->flags &= ~CONN_SIDE_READER;\n    httpClientDiscardBody(connection);\n    return 1;\n}\n\nint \nhttpServeObject(HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n    ObjectPtr object = request->object;\n    int i = request->from / CHUNK_SIZE;\n    int j = request->from % CHUNK_SIZE;\n    int n, len, rc;\n    int bufsize = CHUNK_SIZE;\n    int condition_result;\n\n    object->atime = current_time.tv_sec;\n    objectMetadataChanged(object, 0);\n\n    httpSetTimeout(connection, -1);\n\n    if((request->error_code && relaxTransparency <= 0) ||\n       object->flags & OBJECT_INITIAL) {\n        object->flags &= ~OBJECT_FAILED;\n        unlockChunk(object, i);\n        if(request->error_code)\n            return httpClientRawError(connection,\n                                      request->error_code, \n                                      retainAtom(request->error_message), 0);\n        else\n            return httpClientRawError(connection,\n                                      500, internAtom(\"Object vanished.\"), 0);\n    }\n\n    if(!(object->flags & OBJECT_INPROGRESS) && object->code == 0) {\n        if(object->flags & OBJECT_INITIAL) {\n            unlockChunk(object, i);\n            return httpClientRawError(connection, 503,\n                                      internAtom(\"Error message lost\"), 0);\n                                      \n        } else {\n            unlockChunk(object, i);\n            do_log(L_ERROR, \"Internal proxy error: object has no code.\\n\");\n            return httpClientRawError(connection, 500,\n                                      internAtom(\"Internal proxy error: \"\n                                                 \"object has no code\"), 0);\n        }\n    }\n\n    condition_result = httpCondition(object, request->condition);\n\n    if(condition_result == CONDITION_FAILED) {\n        unlockChunk(object, i);\n        return httpClientRawError(connection, 412,\n                                  internAtom(\"Precondition failed\"), 0);\n    } else if(condition_result == CONDITION_NOT_MODIFIED) {\n        unlockChunk(object, i);\n        return httpClientRawError(connection, 304,\n                                  internAtom(\"Not modified\"), 0);\n    }\n\n    objectFillFromDisk(object, request->from,\n                       (request->method == METHOD_HEAD ||\n                        condition_result != CONDITION_MATCH) ? 0 : 1);\n\n    if(((object->flags & OBJECT_LINEAR) &&\n        (object->requestor != connection->request)) ||\n       ((object->flags & OBJECT_SUPERSEDED) &&\n        !(object->flags & OBJECT_LINEAR))) {\n        if(request->request) {\n            request->request->request = NULL;\n            request->request = NULL;\n            request->object->requestor = NULL;\n        }\n        object = makeObject(OBJECT_HTTP,\n                            object->key, object->key_size, 1, 0,\n                            object->request, NULL);\n        if(request->object->requestor == request)\n            request->object->requestor = NULL;\n        unlockChunk(request->object, i);\n        releaseObject(request->object);\n        request->object = NULL;\n        if(object == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate object.\");\n            return httpClientRawError(connection, 501,\n                                      internAtom(\"Couldn't allocate object\"), \n                                      1);\n        }\n        if(urlIsLocal(object->key, object->key_size)) {\n            object->flags |= OBJECT_LOCAL;\n            object->request = httpLocalRequest;\n        }\n        request->object = object;\n        connection->flags &= ~CONN_WRITER;\n        return httpClientNoticeRequest(request, 1);\n    }\n\n    if(object->flags & OBJECT_ABORTED) {\n        unlockChunk(object, i);\n        return httpClientNoticeError(request, object->code, \n                                     retainAtom(object->message));\n    }\n\n    if(connection->buf == NULL)\n        connection->buf = get_chunk();\n    if(connection->buf == NULL) {\n        unlockChunk(object, i);\n        do_log(L_ERROR, \"Couldn't allocate client buffer.\\n\");\n        connection->flags &= ~CONN_WRITER;\n        httpClientFinish(connection, 1);\n        return 1;\n    }\n\n    if(object->length >= 0 && request->to >= object->length)\n        request->to = object->length;\n\n    if(request->from > 0 || request->to >= 0) {\n        if(request->method == METHOD_HEAD) {\n            request->to = request->from;\n        } else if(request->to < 0) {\n            if(object->length >= 0)\n                request->to = object->length;\n        }\n    }\n\n again:\n\n    connection->len = 0;\n\n    if((request->from <= 0 && request->to < 0) || \n       request->method == METHOD_HEAD) {\n        n = snnprintf(connection->buf, 0, bufsize,\n                      \"HTTP/1.1 %d %s\",\n                      object->code, atomString(object->message));\n    } else {\n        if((object->length >= 0 && request->from >= object->length) ||\n           (request->to >= 0 && request->from >= request->to)) {\n            unlockChunk(object, i);\n            return httpClientRawError(connection, 416,\n                                      internAtom(\"Requested range \"\n                                                 \"not satisfiable\"),\n                                      0);\n        } else {\n            n = snnprintf(connection->buf, 0, bufsize,\n                          \"HTTP/1.1 206 Partial content\");\n        }\n    }\n\n    n = httpWriteObjectHeaders(connection->buf, n, bufsize,\n                               object, request->from, request->to);\n    if(n < 0)\n        goto fail;\n\n    if(request->method != METHOD_HEAD && \n       condition_result != CONDITION_NOT_MODIFIED &&\n       request->to < 0 && object->length < 0) {\n        if(connection->version == HTTP_11) {\n            connection->te = TE_CHUNKED;\n            n = snnprintf(connection->buf, n, bufsize,\n                          \"\\r\\nTransfer-Encoding: chunked\");\n        } else {\n            request->flags &= ~REQUEST_PERSISTENT;\n        }\n    }\n        \n    if(object->age < current_time.tv_sec) {\n        n = snnprintf(connection->buf, n, bufsize,\n                      \"\\r\\nAge: %d\",\n                      (int)(current_time.tv_sec - object->age));\n    }\n    n = snnprintf(connection->buf, n, bufsize,\n                  \"\\r\\nConnection: %s\",\n                  (request->flags & REQUEST_PERSISTENT) ? \n                  \"keep-alive\" : \"close\");\n\n    if(!(object->flags & OBJECT_LOCAL)) {\n        if((object->flags & OBJECT_FAILED) && !proxyOffline) {\n            n = snnprintf(connection->buf, n, bufsize,\n                          \"\\r\\nWarning: 111 %s:%d \\\"Revalidation failed\\\"\",\n                          proxyName->string, proxyPort);\n            if(request->error_code)\n                n = snnprintf(connection->buf, n, bufsize,\n                              \" (%d %s)\",\n                              request->error_code, \n                              atomString(request->error_message));\n            object->flags &= ~OBJECT_FAILED;\n        } else if(proxyOffline && \n                  objectMustRevalidate(object, &request->cache_control)) {\n            n = snnprintf(connection->buf, n, bufsize,\n                          \"\\r\\nWarning: 112 %s:%d \\\"Disconnected operation\\\"\",\n                          proxyName->string, proxyPort);\n        } else if(objectIsStale(object, &request->cache_control)) {\n            n = snnprintf(connection->buf, n, bufsize,\n                          \"\\r\\nWarning: 110 %s:%d \\\"Object is stale\\\"\",\n                          proxyName->string, proxyPort);\n        } else if(object->expires < 0 && object->max_age < 0 &&\n                  object->age < current_time.tv_sec - 24 * 3600) {\n            n = snnprintf(connection->buf, n, bufsize,\n                          \"\\r\\nWarning: 113 %s:%d \\\"Heuristic expiration\\\"\",\n                          proxyName->string, proxyPort);\n        }\n    }\n\n    n = snnprintf(connection->buf, n, bufsize, \"\\r\\n\\r\\n\");\n    \n    if(n < 0)\n        goto fail;\n    \n    connection->offset = request->from;\n\n    if(request->method == METHOD_HEAD || \n       condition_result == CONDITION_NOT_MODIFIED ||\n       (object->flags & OBJECT_ABORTED)) {\n        len = 0;\n    } else {\n        if(i < object->numchunks) {\n            if(object->chunks[i].size <= j)\n                len = 0;\n            else\n                len = object->chunks[i].size - j;\n        } else {\n            len = 0;\n        }\n        if(request->to >= 0)\n            len = MIN(len, request->to - request->from);\n    }\n\n    connection->offset = request->from;\n    httpSetTimeout(connection, clientTimeout);\n    do_log(D_CLIENT_DATA, \"Serving on 0x%lx for 0x%lx: offset %d len %d\\n\",\n           (unsigned long)connection, (unsigned long)object,\n           connection->offset, len);\n    do_stream_h(IO_WRITE |\n                (connection->te == TE_CHUNKED && len > 0 ? IO_CHUNKED : 0),\n                connection->fd, 0, \n                connection->buf, n,\n                object->chunks[i].data + j, len,\n                httpServeObjectStreamHandler, connection);\n    return 1;\n\n fail:\n    rc = 0;\n    connection->len = 0;\n    if(!(connection->flags & CONN_BIGBUF))\n        rc = httpConnectionBigify(connection);\n    if(rc > 0) {\n        bufsize = bigBufferSize;\n        goto again;\n    }\n    unlockChunk(object, i);\n    return httpClientRawError(connection, 500,\n                              rc == 0 ?\n                              internAtom(\"No space for headers\") :\n                              internAtom(\"Couldn't allocate big buffer\"), 0);\n}\n\nstatic int\nhttpServeObjectDelayed(TimeEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n    httpServeObject(connection);\n    return 1;\n}\n\nint\ndelayedHttpServeObject(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr event;\n\n    assert(connection->request->object->chunks[connection->request->from / \n                                               CHUNK_SIZE].locked > 0);\n\n    event = scheduleTimeEvent(-1, httpServeObjectDelayed,\n                              sizeof(connection), &connection);\n    if(!event) return -1;\n    return 1;\n}\n\nstatic int\nhttpServeObjectFinishHandler(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n\n    (void)request;\n    assert(!request->chandler);\n\n    if(status == 0 && !streamRequestDone(srequest))\n        return 0;\n\n    httpSetTimeout(connection, -1);\n\n    if(status < 0) {\n        do_log(L_ERROR, \"Couldn't terminate chunked reply\\n\");\n        httpClientFinish(connection, 1);\n    } else {\n        httpClientFinish(connection, 0);\n    }\n    return 1;\n}\n\nint\nhttpServeChunk(HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n    ObjectPtr object = request->object;\n    int i = connection->offset / CHUNK_SIZE;\n    int j = connection->offset - (i * CHUNK_SIZE);\n    int to, len, len2, end;\n    int rc;\n\n    /* This must be called with chunk i locked. */\n    assert(object->chunks[i].locked > 0);\n\n    if(object->flags & OBJECT_ABORTED)\n        goto fail;\n\n    if(object->length >= 0 && request->to >= 0)\n        to = MIN(request->to, object->length);\n    else if(object->length >= 0)\n        to = object->length;\n    else if(request->to >= 0)\n        to = request->to;\n    else\n        to = -1;\n\n    len = 0;\n    if(i < object->numchunks)\n        len = object->chunks[i].size - j;\n\n    if(request->method != METHOD_HEAD && \n       len < CHUNK_SIZE && connection->offset + len < to) {\n        objectFillFromDisk(object, connection->offset + len, 2);\n        len = object->chunks[i].size - j;\n    }\n\n    if(to >= 0)\n        len = MIN(len, to - connection->offset);\n\n    if(len <= 0) {\n        if(to >= 0 && connection->offset >= to) {\n            if(request->chandler) {\n                unregisterConditionHandler(request->chandler);\n                request->chandler = NULL;\n            }\n            unlockChunk(object, i);\n            if(connection->te == TE_CHUNKED) {\n                httpSetTimeout(connection, clientTimeout);\n                do_stream(IO_WRITE | IO_CHUNKED | IO_END,\n                          connection->fd, 0, NULL, 0,\n                          httpServeObjectFinishHandler, connection);\n            } else {\n                httpClientFinish(connection,\n                                 !(object->length >= 0 &&\n                                   connection->offset >= object->length));\n            }\n            return 1;\n        } else {\n            if(!request->chandler) {\n                request->chandler =\n                    conditionWait(&object->condition, \n                                  httpServeObjectHandler,\n                                  sizeof(connection), &connection);\n                if(!request->chandler) {\n                    do_log(L_ERROR, \"Couldn't register condition handler\\n\");\n                    goto fail;\n                }\n            }\n            if(!(object->flags & OBJECT_INPROGRESS)) {\n                if(object->flags & OBJECT_SUPERSEDED) {\n                    goto fail;\n                }\n                if(REQUEST_SIDE(request)) goto fail;\n                rc = object->request(object, request->method,\n                                     connection->offset, -1, request,\n                                     object->request_closure);\n                if(rc <= 0) goto fail;\n            }\n            return 1;\n        }\n    } else {\n        /* len > 0 */\n        if(request->method != METHOD_HEAD)\n            objectFillFromDisk(object, (i + 1) * CHUNK_SIZE, 1);\n        if(request->chandler) {\n            unregisterConditionHandler(request->chandler);\n            request->chandler = NULL;\n        }\n        len2 = 0;\n        if(j + len == CHUNK_SIZE && object->numchunks > i + 1) {\n            len2 = object->chunks[i + 1].size;\n            if(to >= 0)\n                len2 = MIN(len2, to - (i + 1) * CHUNK_SIZE);\n        }\n        /* Lock early -- httpServerRequest may get_chunk */\n        if(len2 > 0)\n            lockChunk(object, i + 1);\n        if(object->length >= 0 && \n           connection->offset + len + len2 == object->length)\n            end = 1;\n        else\n            end = 0;\n        /* Prefetch */\n        if(!(object->flags & OBJECT_INPROGRESS) && !REQUEST_SIDE(request)) {\n            if(object->chunks[i].size < CHUNK_SIZE &&\n               to >= 0 && connection->offset + len + 1 < to)\n                object->request(object, request->method,\n                                connection->offset + len, -1, request,\n                                object->request_closure);\n            else if(i + 1 < object->numchunks &&\n                    object->chunks[i + 1].size == 0 &&\n                    to >= 0 && (i + 1) * CHUNK_SIZE + 1 < to)\n                object->request(object, request->method,\n                                (i + 1) * CHUNK_SIZE, -1, request,\n                                object->request_closure);\n        }\n        if(len2 == 0) {\n            httpSetTimeout(connection, clientTimeout);\n            do_log(D_CLIENT_DATA, \n                   \"Serving on 0x%lx for 0x%lx: offset %d len %d\\n\",\n                   (unsigned long)connection, (unsigned long)object,\n                   connection->offset, len);\n            /* IO_NOTNOW in order to give other clients a chance to run. */\n            do_stream(IO_WRITE | IO_NOTNOW |\n                      (connection->te == TE_CHUNKED ? IO_CHUNKED : 0) |\n                      (end ? IO_END : 0),\n                      connection->fd, 0, \n                      object->chunks[i].data + j, len,\n                      httpServeObjectStreamHandler, connection);\n        } else {\n            httpSetTimeout(connection, clientTimeout);\n            do_log(D_CLIENT_DATA, \n                   \"Serving on 0x%lx for 0x%lx: offset %d len %d + %d\\n\",\n                   (unsigned long)connection, (unsigned long)object,\n                   connection->offset, len, len2);\n            do_stream_2(IO_WRITE | IO_NOTNOW |\n                        (connection->te == TE_CHUNKED ? IO_CHUNKED : 0) |\n                        (end ? IO_END : 0),\n                        connection->fd, 0, \n                        object->chunks[i].data + j, len,\n                        object->chunks[i + 1].data, len2,\n                        httpServeObjectStreamHandler2, connection);\n        }            \n        return 1;\n    }\n\n    abort();\n\n fail:\n    unlockChunk(object, i);\n    if(request->chandler)\n        unregisterConditionHandler(request->chandler);\n    request->chandler = NULL;\n    httpClientFinish(connection, 1);\n    return 1;\n}\n\nstatic int\nhttpServeChunkDelayed(TimeEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n    httpServeChunk(connection);\n    return 1;\n}\n\nint\ndelayedHttpServeChunk(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr event;\n    event = scheduleTimeEvent(-1, httpServeChunkDelayed,\n                              sizeof(connection), &connection);\n    if(!event) return -1;\n    return 1;\n}\n\nint\nhttpServeObjectHandler(int status, ConditionHandlerPtr chandler)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)chandler->data;\n    HTTPRequestPtr request = connection->request;\n    int rc;\n\n    if((request->object->flags & OBJECT_ABORTED) || status < 0) {\n        shutdown(connection->fd, 1);\n        httpSetTimeout(connection, 10);\n        /* httpServeChunk will take care of the error. */\n    }\n\n    httpSetTimeout(connection, -1);\n\n    request->chandler = NULL;\n    rc = delayedHttpServeChunk(connection);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Couldn't schedule serving.\\n\");\n        abortObject(request->object, 503, \n                    internAtom(\"Couldn't schedule serving\"));\n    }\n    return 1;\n}\n\nstatic int\nhttpServeObjectStreamHandlerCommon(int kind, int status,\n                                   FdEventHandlerPtr event,\n                                   StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    int condition_result = httpCondition(request->object, request->condition);\n    int i = connection->offset / CHUNK_SIZE;\n\n    assert(!request->chandler);\n\n    if(status == 0 && !streamRequestDone(srequest)) {\n        httpSetTimeout(connection, clientTimeout);\n        return 0;\n    }\n\n    httpSetTimeout(connection, -1);\n\n    unlockChunk(request->object, i);\n    if(kind == 2)\n        unlockChunk(request->object, i + 1);\n\n    if(status) {\n        if(status < 0) {\n            do_log_error(status == -ECONNRESET ? D_IO : L_ERROR, \n                         -status, \"Couldn't write to client\");\n            if(status == -EIO || status == -ESHUTDOWN)\n                httpClientFinish(connection, 2);\n            else\n                httpClientFinish(connection, 1);\n        } else {\n            do_log(D_IO, \"Couldn't write to client: short write.\\n\");\n            httpClientFinish(connection, 2);\n        }\n        return 1;\n    }\n\n    if(srequest->operation & IO_CHUNKED) {\n        assert(srequest->offset > 2);\n        connection->offset += srequest->offset - 2;\n    } else {\n        connection->offset += srequest->offset;\n    }\n    request->flags &= ~REQUEST_REQUESTED;\n\n    if(request->object->flags & OBJECT_ABORTED) {\n        httpClientFinish(connection, 1);\n        return 1;\n    }\n\n    if(connection->request->method == METHOD_HEAD ||\n       condition_result == CONDITION_NOT_MODIFIED) {\n        httpClientFinish(connection, 0);\n        return 1;\n    }\n\n    if(srequest->operation & IO_END)\n        httpClientFinish(connection, 0);\n    else {\n        httpConnectionDestroyBuf(connection);\n        lockChunk(connection->request->object,\n                  connection->offset / CHUNK_SIZE);\n        httpServeChunk(connection);\n    }\n    return 1;\n}\n\nint\nhttpServeObjectStreamHandler(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest)\n{\n    return httpServeObjectStreamHandlerCommon(1, status, event, srequest);\n}\n\nint\nhttpServeObjectStreamHandler2(int status,\n                              FdEventHandlerPtr event,\n                              StreamRequestPtr srequest)\n{\n    return httpServeObjectStreamHandlerCommon(2, status, event, srequest);\n}\n"
        },
        {
          "name": "client.h",
          "type": "blob",
          "size": 3.3828125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nint httpAccept(int, FdEventHandlerPtr, AcceptRequestPtr);\nvoid httpClientFinish(HTTPConnectionPtr connection, int s);\nint httpClientHandler(int, FdEventHandlerPtr, StreamRequestPtr);\nint httpClientNoticeError(HTTPRequestPtr, int code, struct _Atom *message);\nint httpClientError(HTTPRequestPtr, int code, struct _Atom *message);\nint httpClientNewError(HTTPConnectionPtr, int method, int persist, \n                       int code, struct _Atom *message);\nint httpClientRawError(HTTPConnectionPtr, int, struct _Atom*, int close);\nint httpErrorStreamHandler(int status,\n                           FdEventHandlerPtr event,\n                           StreamRequestPtr request);\nint httpErrorNocloseStreamHandler(int status,\n                                  FdEventHandlerPtr event,\n                                  StreamRequestPtr request);\nint httpErrorNofinishStreamHandler(int status,\n                                   FdEventHandlerPtr event,\n                                   StreamRequestPtr request);\nint httpClientRequest(HTTPRequestPtr request, AtomPtr url);\nint httpClientRequestContinue(int forbidden_code, AtomPtr url,\n                              AtomPtr forbidden_message,\n                              AtomPtr forbidden_headers,\n                              void *closure);\nint httpClientDiscardBody(HTTPConnectionPtr connection);\nint httpClientDiscardHandler(int, FdEventHandlerPtr, StreamRequestPtr);\nint httpClientGetHandler(int, ConditionHandlerPtr);\nint httpClientHandlerHeaders(FdEventHandlerPtr event, \n                                StreamRequestPtr request,\n                                HTTPConnectionPtr connection);\nint httpClientNoticeRequest(HTTPRequestPtr request, int);\nint httpServeObject(HTTPConnectionPtr);\nint delayedHttpServeObject(HTTPConnectionPtr connection);\nint httpServeObjectStreamHandler(int status, \n                                 FdEventHandlerPtr event,\n                                 StreamRequestPtr request);\nint httpServeObjectStreamHandler2(int status, \n                                  FdEventHandlerPtr event,\n                                  StreamRequestPtr request);\nint httpServeObjectHandler(int, ConditionHandlerPtr);\nint httpClientSideRequest(HTTPRequestPtr request);\nint  httpClientSideHandler(int status,\n                           FdEventHandlerPtr event,\n                           StreamRequestPtr srequest);\n"
        },
        {
          "name": "config.c",
          "type": "blob",
          "size": 24.1376953125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nConfigVariablePtr configVariables = NULL;\n\nstatic ConfigVariablePtr\nfindConfigVariable(AtomPtr name)\n{\n    ConfigVariablePtr var;\n    var = configVariables;\n    while(var != NULL) {\n        if(var->name == name)\n            break;\n        var = var->next;\n    }\n    return var;\n}\n\nvoid\ndeclareConfigVariable(AtomPtr name, int type, void *value, \n                      int (*setter)(ConfigVariablePtr, void*), char *help)\n{\n    ConfigVariablePtr var, previous, next;\n\n    var = findConfigVariable(name);\n\n    if(var) {\n        do_log(L_ERROR, \n               \"Configuration variable %s declared multiple times.\\n\",\n               name->string);\n        if(var->type != type) {\n            exit(1);\n        }\n    }\n\n    var = malloc(sizeof(ConfigVariableRec));\n    if(var == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate config variable.\\n\");\n        exit(1);\n    }\n\n    var->name = retainAtom(name);\n    var->type = type;\n    switch(type) {\n    case CONFIG_INT: case CONFIG_OCTAL: case CONFIG_HEX: case CONFIG_TIME:\n    case CONFIG_BOOLEAN: case CONFIG_TRISTATE: case CONFIG_TETRASTATE:\n    case CONFIG_PENTASTATE:\n        var->value.i = value; break;\n    case CONFIG_FLOAT: var->value.f = value; break;\n    case CONFIG_ATOM: case CONFIG_ATOM_LOWER: case CONFIG_PASSWORD:\n        var->value.a = value; break;\n    case CONFIG_INT_LIST:\n        var->value.il = value; break;\n    case CONFIG_ATOM_LIST: case CONFIG_ATOM_LIST_LOWER: \n        var->value.al = value; break;\n    default: abort();\n    }\n    var->setter = setter;\n    var->help = help;\n\n    previous = NULL;\n    next = configVariables;\n    while(next && strcmp(next->name->string, var->name->string) < 0) {\n        previous = next;\n        next = next->next;\n    }\n    if(next && strcmp(next->name->string, var->name->string) == 0) {\n        do_log(L_ERROR, \"Variable %s declared multiple times.\\n\",\n               next->name->string);\n        abort();\n    }\n    if(previous == NULL) {\n        var->next = configVariables;\n        configVariables = var;\n    } else {\n        var->next = next;\n        previous->next = var;\n    }\n}\n\nstatic void\nprintString(FILE *out, char *string, int html)\n{\n    if(html) {\n        char buf[512];\n        int i;\n        i = htmlString(buf, 0, 512, string, strlen(string));\n        if(i < 0) {\n            fprintf(out, \"(overflow)\");\n            return;\n        }\n        fwrite(buf, 1, i, out);\n    } else {\n        fprintf(out, \"%s\", string);\n    }\n}\n\nstatic void\nprintVariable(FILE *out, ConfigVariablePtr var, int html, int parseable)\n{\n    int i;\n\n    switch(var->type) {\n    case CONFIG_INT: fprintf(out, \"%d\", *var->value.i); break;\n    case CONFIG_OCTAL: fprintf(out, \"0%o\", *var->value.i); break;\n    case CONFIG_HEX: fprintf(out, \"0x%x\", *var->value.i); break;\n    case CONFIG_TIME:\n        {\n            int v = *var->value.i;\n            if(v == 0) {\n                fprintf(out, \"0s\");\n            } else {\n                if(v >= 3600 * 24) fprintf(out, \"%dd\", v/(3600*24));\n                v = v % (3600 * 24);\n                if(v >= 3600) fprintf(out, \"%dh\", v / 3600);\n                v = v % 3600;\n                if(v >= 60) fprintf(out, \"%dm\", v / 60);\n                v = v % 60;\n                if(v > 0) fprintf(out, \"%ds\", v);\n            }\n        }\n        break;\n    case CONFIG_BOOLEAN:\n        switch(*var->value.i) {\n        case 0: fprintf(out, \"false\"); break;\n        case 1: fprintf(out, \"true\"); break;\n        default: fprintf(out, \"???\"); break;\n        }\n        break;\n    case CONFIG_TRISTATE:\n        switch(*var->value.i) {\n        case 0: fprintf(out, \"false\"); break;\n        case 1: fprintf(out, \"maybe\"); break;\n        case 2: fprintf(out, \"true\"); break;\n        default: fprintf(out, \"???\"); break;\n        }\n        break;\n    case CONFIG_TETRASTATE:\n        switch(*var->value.i) {\n        case 0: fprintf(out, \"false\"); break;\n        case 1: fprintf(out, \"reluctantly\"); break;\n        case 2: fprintf(out, \"happily\"); break;\n        case 3: fprintf(out, \"true\"); break;\n        default: fprintf(out, \"???\"); break;\n        }\n        break;\n    case CONFIG_PENTASTATE:\n        switch(*var->value.i) {\n        case 0: fprintf(out, \"no\"); break;\n        case 1: fprintf(out, \"reluctantly\"); break;\n        case 2: fprintf(out, \"maybe\"); break;\n        case 3: fprintf(out, \"happily\"); break;\n        case 4: fprintf(out, \"true\"); break;\n        default: fprintf(out, \"???\"); break;\n        }\n        break;\n    case CONFIG_FLOAT: fprintf(out, \"%f\", *var->value.f); break;\n    case CONFIG_ATOM: case CONFIG_ATOM_LOWER:\n        if(*var->value.a) {\n            if((*var->value.a)->length > 0) {\n                printString(out, (*var->value.a)->string, html);\n            } else {\n                if(!parseable)\n                    fprintf(out, \"(empty)\");\n            }\n        } else {\n            if(!parseable)\n                fprintf(out, \"(none)\");\n        }\n        break;\n    case CONFIG_PASSWORD:\n        if(!parseable)\n            fprintf(out, \"(hidden)\");\n        break;\n    case CONFIG_INT_LIST:\n        if((*var->value.il) == NULL) {\n            if(!parseable)\n                fprintf(out, \"(not set)\");\n        } else if((*var->value.il)->length == 0) {\n            if(!parseable)\n                fprintf(out, \"(empty list)\");\n        } else {\n            for(i = 0; i < (*var->value.il)->length; i++) {\n                int from = (*var->value.il)->ranges[i].from;\n                int to = (*var->value.il)->ranges[i].to;\n                assert(from <= to);\n                if(from == to)\n                    fprintf(out, \"%d\", from);\n                else\n                    fprintf(out, \"%d-%d\", from, to);\n                if(i < (*var->value.il)->length - 1)\n                    fprintf(out, \", \");\n            }\n        }\n        break;\n    case CONFIG_ATOM_LIST: case CONFIG_ATOM_LIST_LOWER:\n        if((*var->value.al) == NULL) {\n            if(!parseable)\n                fprintf(out, \"(not set)\");\n        } else if((*var->value.al)->length == 0) {\n            if(!parseable)\n                fprintf(out, \"(empty list)\");\n        } else {\n            for(i = 0; i < (*var->value.al)->length; i++) {\n                AtomPtr atom = (*var->value.al)->list[i];\n                if(atom) {\n                    if(atom->length > 0)\n                        printString(out, atom->string, html);\n                    else {\n                        if(!parseable)\n                            fprintf(out, \"(empty)\");\n                    }\n                } else {\n                    if(!parseable)\n                        fprintf(out, \"(none)\");\n                }\n                if(i < (*var->value.al)->length - 1)\n                    fprintf(out, \", \");\n            }\n        }\n        break;\n    default: abort();\n    }\n}\n\nstatic void\nprintVariableForm(FILE *out, ConfigVariablePtr var)\n{\n    char *disabled = \"\";\n    int i;\n    \n    if(disableConfiguration || !var->setter) disabled = \"disabled=true\";\n\n    fprintf(out, \"<form method=POST action=\\\"config?\\\">\");\n  \n    switch(var->type) {\n    case CONFIG_INT: case CONFIG_OCTAL: case CONFIG_HEX:\n    case CONFIG_TIME: case CONFIG_FLOAT: case CONFIG_ATOM:\n    case CONFIG_ATOM_LOWER: case CONFIG_PASSWORD:\n    case CONFIG_INT_LIST: case CONFIG_ATOM_LIST: case CONFIG_ATOM_LIST_LOWER:\n        fprintf(out, \"<input value=\\\"\");\n        printVariable(out, var, 1, 1);\n        fprintf(out, \"\\\"%s size=14 name=%s %s>\\n\",\n                var->type == CONFIG_PASSWORD ? \" type=password\" : \"\",\n                var->name->string, disabled);\n        break;\n\n    case CONFIG_BOOLEAN:\n        {\n            static char *states[] = {\"false\", \"true\"};\n            \n            fprintf(out, \"<select name=%s %s>\", var->name->string, disabled);\n            for(i=0; i < sizeof(states) / sizeof(states[0]); i++) {\n                if(*var->value.i == i) {\n                    fprintf(out, \"<option selected>%s</option>\", states[i]);\n                } else {\n                    fprintf(out, \"<option>%s</option>\", states[i]);\n                }\n            }\n            fprintf(out, \"</select>\");\n            if(var->setter)\n                fprintf(out, \"<input type=\\\"submit\\\" value=\\\"set\\\"\\n>\");\n            break;\n        }\n    \n    case CONFIG_TRISTATE:\n        {\n            static char *states[] = {\"false\", \"maybe\", \"true\"};\n            \n            fprintf(out, \"<select name=%s %s>\", var->name->string, disabled);\n            for(i=0; i < sizeof(states) / sizeof(states[0]); i++) {\n                if(*var->value.i == i) {\n                    fprintf(out, \"<option selected>%s</option>\", states[i]);\n                } else {\n                    fprintf(out, \"<option>%s</option>\", states[i]);\n                }\n            }\n            fprintf(out, \"</select>\");\n            if(var->setter)\n                fprintf(out, \"<input type=\\\"submit\\\" value=\\\"set\\\"\\n>\");\n            break;\n        }\n\n    case CONFIG_TETRASTATE:\n        {\n            static char *states[] =\n                {\"false\", \"reluctantly\", \"happily\", \"true\"};\n            \n            fprintf(out, \"<select name=%s %s>\", var->name->string, disabled);\n            for(i=0; i <sizeof(states) / sizeof(states[0]); i++) {\n                if(*var->value.i == i) {\n                    fprintf(out, \"<option selected>%s</option>\", states[i]);\n                } else {\n                    fprintf(out, \"<option>%s</option>\", states[i]);\n                }\n            }\n            fprintf(out, \"</select>\");\n            if(var->setter)\n                fprintf(out, \"<input type=\\\"submit\\\" value=\\\"set\\\"\\n>\");\n            break;\n        }\n\n    case CONFIG_PENTASTATE:\n        {\n            static char *states[] =\n                {\"no\", \"reluctantly\", \"maybe\", \"happily\", \"true\"};\n\n            fprintf(out, \"<select name=%s %s>\", var->name->string, disabled);\n            for(i=0; i < sizeof(states) / sizeof(states[0]); i++) {\n                if(*var->value.i == i) {\n                    fprintf(out, \"<option selected>%s</option>\", states[i]);\n                } else {\n                    fprintf(out, \"<option>%s</option>\", states[i]);\n                }\n            }\n            fprintf(out, \"</select>\");\n            if(var->setter)\n                fprintf(out,\"<input type=\\\"submit\\\" value=\\\"set\\\"\\n>\");\n            break;\n        }\n    default: abort();\n    }\n    fprintf(out, \"</form>\");\n}\n\n\n\n\n\nvoid\nprintConfigVariables(FILE *out, int html)\n{\n    ConfigVariablePtr var;\n    int entryno = 0;\n\n#define PRINT_SEP() \\\n    do {if(html) fprintf(out, \"</td><td>\"); else fprintf(out, \" \");} while(0)\n\n    if(html) {\n        fprintf(out, \"<table>\\n\");\n        fprintf(out, \"<tbody>\\n\");\n    }\n\n    if(html) {\n        alternatingHttpStyle(out, \"configlist\");\n        fprintf(out,\n                \"<table id=configlist>\\n\"\n                \"<thead>\\n\"\n                \"<tr><th>variable name</th>\"\n                \"<th>current value</th>\"\n                \"<th>new value</th>\"\n                \"<th>description</th>\\n\"\n                \"</thead><tbody>\\n\"\n);\n    }\n\n    /* configFile is not a config variable, for obvious bootstrapping reasons.\n       CHUNK_SIZE is hardwired for now. */\n\n    fprintf(out,\n\t    html ?\n\t    \"<tr class=\\\"even\\\"><td>configFile</td><td>%s</td><td></td><td>\"\n\t    \"Configuration file.</td></tr>\\n\" :\n\t    \"configFile %s Configuration file.\\n\",\n\t    configFile && configFile->length > 0 ?\n\t    configFile->string : \"(none)\");\n    fprintf(out,\n\t    html ?\n\t    \"<tr class=\\\"odd\\\"><td>CHUNK_SIZE</td><td>%d</td><td></td><td>\"\n\t    \"Unit of chunk memory allocation.</td></tr>\\n\" :\n\t    \"CHUNK_SIZE %d Unit of chunk memory allocation.\\n\", CHUNK_SIZE);\n    \n    var = configVariables;\n    while(var != NULL) {\n      if(html) {\n          if(entryno % 2)\n              fprintf(out, \"<tr class=odd>\");\n          else\n              fprintf(out, \"<tr class=even>\");\n          fprintf(out, \"<td>\");\n      }\n\n      fprintf(out, \"%s\", var->name->string);\n\n      fprintf(out, html ? \"<br/>\" : \" \"); \n      \n      fprintf(out, html ? \"<i>\" : \"\");    \n      \n      switch(var->type) {\n      case CONFIG_INT: case CONFIG_OCTAL: case CONFIG_HEX:\n\t  fprintf(out, \"integer\"); break;\n      case CONFIG_TIME: fprintf(out, \"time\"); break;\n      case CONFIG_BOOLEAN: fprintf(out, \"boolean\"); break;\n      case CONFIG_TRISTATE: fprintf(out, \"tristate\"); break;\n      case CONFIG_TETRASTATE: fprintf(out, \"4-state\"); break;\n      case CONFIG_PENTASTATE: fprintf(out, \"5-state\"); break;\n      case CONFIG_FLOAT: fprintf(out, \"float\"); break;\n      case CONFIG_ATOM: case CONFIG_ATOM_LOWER: case CONFIG_PASSWORD:\n          fprintf(out, \"atom\"); break;\n      case CONFIG_INT_LIST: fprintf(out, \"intlist\"); break;\n      case CONFIG_ATOM_LIST: case CONFIG_ATOM_LIST_LOWER:\n\t  fprintf(out, \"list\"); break;\n      default: abort();\n      }\n        \n      fprintf(out, html ? \"</i>\" : \"\");\n\n      PRINT_SEP();\n\n      printVariable(out, var, html, 0);\n\n      PRINT_SEP();\n\t\n      if(html) {\n\tprintVariableForm(out, var);\n\tPRINT_SEP();\n      }\n\n      fprintf(out, \"%s\", var->help?var->help:\"\");\n      if(html)\n\tfprintf(out, \"</td></tr>\\n\");\n      else\n\tfprintf(out, \"\\n\");\n\n      entryno++;\n      var = var->next;\n    }\n    if(html) {\n        fprintf(out, \"</tbody>\\n\");\n        fprintf(out, \"</table>\\n\");\n    }\n    return;\n#undef PRINT_SEP\n}\n\nstatic int\nskipWhitespace(char *buf, int i)\n{\n    while(buf[i] == ' ' || buf[i] == '\\t' || buf[i] == '\\r')\n        i++;\n    return i;\n}\n\nstatic int\nparseInt(char *buf, int offset, int *value_return)\n{\n    char *p;\n    int value;\n\n    value = strtol(buf + offset, &p, 0);\n    if(p <= buf + offset)\n        return -1;\n\n    *value_return = value;\n    return p - buf;\n}\n\nstatic struct config_state { char *name; int value; }\nstates[] = \n    { { \"false\", 0 }, \n      { \"no\", 0 },\n      { \"reluctantly\", 1 },\n      { \"seldom\", 1 },\n      { \"rarely\", 1 },\n      { \"lazily\", 1 },\n      { \"maybe\", 2 },\n      { \"perhaps\", 2 },\n      { \"happily\", 3 },\n      { \"often\", 3 },\n      { \"eagerly\", 3 },\n      { \"true\", 4 },\n      { \"yes\", 4 } };\n\nstatic int\nparseState(char *buf, int offset, int kind)\n{\n    int i = offset;\n    int n;\n    int state = -1;\n\n    while(letter(buf[i]))\n        i++;\n    for(n = 0; n < sizeof(states) / sizeof(states[0]); n++) {\n        if(strlen(states[n].name) == i - offset &&\n           lwrcmp(buf + offset, states[n].name, i - offset) == 0) {\n            state = states[n].value;\n            break;\n        }\n    }\n    if(state < 0)\n        return -1;\n\n    switch(kind) {\n    case CONFIG_BOOLEAN:\n        if(state == 0) return 0;\n        else if(state == 4) return 1;\n        else return -1;\n        break;\n    case CONFIG_TRISTATE:\n        if(state == 0) return 0;\n        else if(state == 2) return 1;\n        else if(state == 4) return 2;\n        else return -1;\n        break;\n    case CONFIG_TETRASTATE:\n        if(state == 0) return 0;\n        else if(state == 1) return 1;\n        else if(state == 3) return 2;\n        else if(state == 4) return 3;\n        else return -1;\n        break;\n    case CONFIG_PENTASTATE:\n        return state;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic int\nparseAtom(char *buf, int offset, AtomPtr *value_return, int insensitive)\n{\n    int y0, i, j, k;\n    AtomPtr atom;\n    int escape = 0;\n    char *s;\n\n    i = offset;\n    if(buf[i] == '\\\"') {\n        i++;\n        y0 = i;\n        while(buf[i] != '\\\"' && buf[i] != '\\n' && buf[i] != '\\0') {\n            if(buf[i] == '\\\\' && buf[i + 1] != '\\0') {\n                escape = 1;\n                i += 2;\n            } else\n                i++;\n        }\n        if(buf[i] != '\\\"')\n            return -1;\n        j = i + 1;\n    } else {\n        y0 = i;\n        while(letter(buf[i]) || digit(buf[i]) || \n              buf[i] == '_' || buf[i] == '-' || buf[i] == '~' ||\n              buf[i] == '.' || buf[i] == ':' || buf[i] == '/')\n            i++;\n        j = i;\n    }\n\n    if(escape) {\n        s = malloc(i - y0);\n        if(s == NULL) return -1;\n        k = 0;\n        j = y0;\n        while(j < i) {\n            if(buf[j] == '\\\\' && j <= i - 2) {\n                s[k++] = buf[j + 1];\n                j += 2;\n            } else\n                s[k++] = buf[j++];\n        }\n        if(insensitive)\n            atom = internAtomLowerN(s, k);\n        else\n            atom = internAtomN(s, k);\n        free(s);\n        j++;\n    } else {\n        if(insensitive)\n            atom = internAtomLowerN(buf + y0, i - y0);\n        else\n            atom = internAtomN(buf + y0, i - y0);\n    }\n    *value_return = atom;\n    return j;\n}\n\nstatic int\nparseTime(char *line, int i, int *value_return)\n{\n    int v = 0, w;\n    while(1) {\n        if(!digit(line[i]))\n            break;\n        w = atoi(line + i);\n        while(digit(line[i])) i++;\n        switch(line[i]) {\n        case 'd': v += w * 24 * 3600; i++; break;\n        case 'h': v += w * 3600; i++; break;\n        case 'm': v += w * 60; i++; break;\n        case 's': v += w; i++; break;\n        default: v += w; goto done;\n        }\n    }\n done:\n    *value_return = v;\n    return i;\n}\n\nint\nparseConfigLine(char *line, char *filename, int lineno, int set)\n{\n    int x0, x1;\n    int i, from, to;\n    AtomPtr name, value;\n    ConfigVariablePtr var;\n    int iv;\n    float fv;\n    AtomPtr av;\n    AtomListPtr alv;\n    IntListPtr ilv;\n\n    i = skipWhitespace(line, 0);\n    if(line[i] == '\\n' || line[i] == '\\0' || line[i] == '#')\n        return 0;\n\n    x0 = i;\n    while(letter(line[i]) || digit(line[i]))\n        i++;\n    x1 = i;\n\n    i = skipWhitespace(line, i);\n    if(line[i] != '=') {\n        goto syntax;\n    }\n    i++;\n    i = skipWhitespace(line, i);\n\n    name = internAtomN(line + x0, x1 - x0);\n    var = findConfigVariable(name);\n    releaseAtom(name);\n\n    if(set && var->setter == NULL)\n        return -2;\n \n    if(var == NULL) {\n        if(!set) {\n            do_log(L_ERROR, \"%s:%d: unknown config variable \",\n                   filename, lineno);\n            do_log_n(L_ERROR, line + x0, x1 - x0);\n            do_log(L_ERROR, \"\\n\");\n        }\n        return -1;\n    }\n    \n    i = skipWhitespace(line, i);\n    switch(var->type) {\n    case CONFIG_INT: case CONFIG_OCTAL: case CONFIG_HEX:\n        i = parseInt(line, i, &iv);\n        if(i < 0) goto syntax;\n        if(set)\n            var->setter(var, &iv);\n        else\n            *var->value.i = iv;\n    break;\n    case CONFIG_TIME:\n        i = parseTime(line, i, &iv);\n        if(i < 0) goto syntax;\n        i = skipWhitespace(line, i);\n        if(line[i] != '\\n' && line[i] != '\\0' && line[i] != '#')\n            goto syntax;\n        if(set)\n            var->setter(var, &iv);\n        else\n            *var->value.i = iv;\n        break;\n    case CONFIG_BOOLEAN:\n    case CONFIG_TRISTATE:\n    case CONFIG_TETRASTATE:\n    case CONFIG_PENTASTATE:\n        iv = parseState(line, i, var->type);\n        if(iv < 0)\n            goto syntax;\n        if(set)\n            var->setter(var, &iv);\n        else\n            *var->value.i = iv;\n        break;\n    case CONFIG_FLOAT: \n        if(!digit(line[i]) && line[i] != '.')\n            goto syntax;\n        fv = atof(line + i);\n        if(set)\n            var->setter(var, &fv);\n        else\n            *var->value.f = fv;\n        break;\n    case CONFIG_ATOM: case CONFIG_ATOM_LOWER: case CONFIG_PASSWORD:\n        i = parseAtom(line, i, &av, (var->type == CONFIG_ATOM_LOWER));\n        if(i < 0) goto syntax;\n        if(!av) {\n            if(!set)\n                do_log(L_ERROR, \"%s:%d: couldn't allocate atom.\\n\",\n                       filename, lineno);\n            return -1;\n        }\n        i = skipWhitespace(line, i);\n        if(line[i] != '\\n' && line[i] != '\\0' && line[i] != '#') {\n            releaseAtom(av);\n            goto syntax;\n        }\n        if(set)\n            var->setter(var, &av);\n        else {\n            if(*var->value.a) releaseAtom(*var->value.a);\n            *var->value.a = av;\n        }\n        break;\n    case CONFIG_INT_LIST:\n        ilv = makeIntList(0);\n        if(ilv == NULL) {\n            if(!set)\n                do_log(L_ERROR, \"%s:%d: couldn't allocate int list.\\n\",\n                       filename, lineno);\n            return -1;\n        }\n        while(1) {\n            i = parseInt(line, i, &from);\n            if(i < 0) goto syntax;\n            to = from;\n            i = skipWhitespace(line, i);\n            if(line[i] == '-') {\n                i = skipWhitespace(line, i + 1);\n                i = parseInt(line, i, &to);\n                if(i < 0) {\n                    destroyIntList(ilv);\n                    goto syntax;\n                }\n                i = skipWhitespace(line, i);\n            }\n            intListCons(from, to, ilv);\n            if(line[i] == '\\n' || line[i] == '\\0' || line[i] == '#')\n                break;\n            if(line[i] != ',') {\n                destroyIntList(ilv);\n                goto syntax;\n            }\n            i = skipWhitespace(line, i + 1);\n        }\n        if(set)\n            var->setter(var, &ilv);\n        else {\n            if(*var->value.il) destroyIntList(*var->value.il);\n            *var->value.il = ilv;\n        }\n        break;\n    case CONFIG_ATOM_LIST: case CONFIG_ATOM_LIST_LOWER:\n        alv = makeAtomList(NULL, 0);\n        if(alv == NULL) {\n            if(!set)\n                do_log(L_ERROR, \"%s:%d: couldn't allocate atom list.\\n\",\n                       filename, lineno);\n            return -1;\n        }\n        while(1) {\n            i = parseAtom(line, i, &value, \n                          (var->type == CONFIG_ATOM_LIST_LOWER));\n            if(i < 0) goto syntax;\n            if(!value) {\n                if(!set)\n                    do_log(L_ERROR, \"%s:%d: couldn't allocate atom.\\n\",\n                           filename, lineno);\n                return -1;\n            }\n            atomListCons(value, alv);\n            i = skipWhitespace(line, i);\n            if(line[i] == '\\n' || line[i] == '\\0' || line[i] == '#')\n                break;\n            if(line[i] != ',') {\n                destroyAtomList(alv);\n                goto syntax;\n            }\n            i = skipWhitespace(line, i + 1);\n        }\n        if(set)\n            var->setter(var, &alv);\n        else {\n            if(*var->value.al) destroyAtomList(*var->value.al);\n            *var->value.al = alv;\n        }\n        break;\n    default: abort();\n    }\n    return 1;\n\n syntax:\n    if(!set)\n        do_log(L_ERROR, \"%s:%d: parse error.\\n\", filename, lineno);\n    return -1;\n}\n\nint\nparseConfigFile(AtomPtr filename)\n{\n    char buf[512];\n    int lineno;\n    FILE *f;\n\n    if(!filename || filename->length == 0)\n        return 0;\n    f = fopen(filename->string, \"r\");\n    if(f == NULL) {\n        do_log_error(L_ERROR, errno, \"Couldn't open config file %s\",\n                     filename->string);\n        return -1;\n    }\n\n    lineno = 1;\n    while(1) {\n        char *s;\n        s = fgets(buf, 512, f);\n        if(s == NULL) {\n            fclose(f);\n            return 1;\n        }\n        parseConfigLine(buf, filename->string, lineno, 0);\n        lineno++;\n    }\n}\n\nint\nconfigIntSetter(ConfigVariablePtr var, void* value)\n{\n    assert(var->type <= CONFIG_PENTASTATE);\n    *var->value.i = *(int*)value;\n    return 1;\n}\n\nint\nconfigFloatSetter(ConfigVariablePtr var, void* value)\n{\n    assert(var->type == CONFIG_FLOAT);\n    *var->value.i = *(float*)value;\n    return 1;\n}\n\n\nint\nconfigAtomSetter(ConfigVariablePtr var, void* value)\n{\n    assert(var->type == CONFIG_ATOM || var->type == CONFIG_ATOM_LOWER ||\n           var->type == CONFIG_PASSWORD);\n    if(*var->value.a)\n        releaseAtom(*var->value.a);\n    *var->value.a = *(AtomPtr*)value;\n    return 1;\n}\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 2.455078125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#define CONFIG_INT 0\n#define CONFIG_OCTAL 1\n#define CONFIG_HEX 2\n#define CONFIG_TIME 3\n#define CONFIG_BOOLEAN 4\n#define CONFIG_TRISTATE 5\n#define CONFIG_TETRASTATE 6\n#define CONFIG_PENTASTATE 7\n#define CONFIG_FLOAT 8\n#define CONFIG_ATOM 9\n#define CONFIG_ATOM_LOWER 10\n#define CONFIG_PASSWORD 11\n#define CONFIG_INT_LIST 12\n#define CONFIG_ATOM_LIST 13\n#define CONFIG_ATOM_LIST_LOWER 14\n\ntypedef struct _ConfigVariable {\n    AtomPtr name;\n    int type;\n    union {\n        int *i;\n        float *f;\n        struct _Atom **a;\n        struct _AtomList **al;\n        struct _IntList **il;\n    } value;\n    int (*setter)(struct _ConfigVariable*, void*);\n    char *help;\n    struct _ConfigVariable *next;\n} ConfigVariableRec, *ConfigVariablePtr;\n\n#define CONFIG_VARIABLE(name, type, help) \\\n    CONFIG_VARIABLE_SETTABLE(name, type, NULL, help)\n\n#define CONFIG_VARIABLE_SETTABLE(name, type, setter, help) \\\n    declareConfigVariable(internAtom(#name), type, &name, setter, help)\n\nvoid declareConfigVariable(AtomPtr name, int type, void *value, \n                           int (*setter)(ConfigVariablePtr, void*),\n                           char *help);\nvoid printConfigVariables(FILE *out, int html);\nint parseConfigLine(char *line, char *filename, int lineno, int set);\nint parseConfigFile(AtomPtr);\nint configIntSetter(ConfigVariablePtr, void*);\nint configFloatSetter(ConfigVariablePtr, void*);\nint configAtomSetter(ConfigVariablePtr, void*);\n"
        },
        {
          "name": "config.sample",
          "type": "blob",
          "size": 4.119140625,
          "content": "# Sample configuration file for Polipo. -*-sh-*-\n\n# You should not need to use a configuration file; all configuration\n# variables have reasonable defaults.  If you want to use one, you\n# can copy this to /etc/polipo/config or to ~/.polipo and modify.\n\n# This file only contains some of the configuration variables; see the\n# list given by ``polipo -v'' and the manual for more.\n\n\n### Basic configuration\n### *******************\n\n# Uncomment one of these if you want to allow remote clients to\n# connect:\n\n# proxyAddress = \"::0\"        # both IPv4 and IPv6\n# proxyAddress = \"0.0.0.0\"    # IPv4 only\n\n# Uncomment this if you want your Polipo to bind to a specific IP:\n\n# proxyOutgoingAddress = \"134.157.168.1\"\n\n# If you do that, you'll want to restrict the set of hosts allowed to\n# connect:\n\n# allowedClients = 127.0.0.1, 134.157.168.57\n# allowedClients = 127.0.0.1, 134.157.168.0/24\n\n# Uncomment this if you want your Polipo to identify itself by\n# something else than the host name:\n\n# proxyName = \"polipo.example.org\"\n\n# Uncomment this if there's only one user using this instance of Polipo:\n\n# cacheIsShared = false\n\n# Uncomment this if you want to use a parent proxy:\n\n# parentProxy = \"squid.example.org:3128\"\n\n# Uncomment this if you want to use a parent SOCKS proxy:\n\n# socksParentProxy = \"localhost:9050\"\n# socksProxyType = socks5\n\n# Uncomment this if you want to scrub private information from the log:\n\n# scrubLogs = true\n\n\n### Memory\n### ******\n\n# Uncomment this if you want Polipo to use a ridiculously small amount\n# of memory (a hundred C-64 worth or so):\n\n# chunkHighMark = 819200\n# objectHighMark = 128\n\n# Uncomment this if you've got plenty of memory:\n\n# chunkHighMark = 50331648\n# objectHighMark = 16384\n\n\n### On-disk data\n### ************\n\n# Uncomment this if you want to disable the on-disk cache:\n\n# diskCacheRoot = \"\"\n\n# Uncomment this if you want to put the on-disk cache in a\n# non-standard location:\n\n# diskCacheRoot = \"~/.polipo-cache/\"\n\n# Uncomment this if you want to disable the local web server:\n\n# localDocumentRoot = \"\"\n\n# Uncomment this if you want to enable the pages under /polipo/index?\n# and /polipo/servers?.  This is a serious privacy leak if your proxy\n# is shared.\n\n# disableIndexing = false\n# disableServersList = false\n\n\n### Domain Name System\n### ******************\n\n# Uncomment this if you want to contact IPv4 hosts only (and make DNS\n# queries somewhat faster):\n\n# dnsQueryIPv6 = no\n\n# Uncomment this if you want Polipo to prefer IPv4 to IPv6 for\n# double-stack hosts:\n\n# dnsQueryIPv6 = reluctantly\n\n# Uncomment this to disable Polipo's DNS resolver and use the system's\n# default resolver instead.  If you do that, Polipo will freeze during\n# every DNS query:\n\n# dnsUseGethostbyname = yes\n\n\n### HTTP\n### ****\n\n# Uncomment this if you want to enable detection of proxy loops.\n# This will cause your hostname (or whatever you put into proxyName\n# above) to be included in every request:\n\n# disableVia=false\n\n# Uncomment this if you want to slightly reduce the amount of\n# information that you leak about yourself:\n\n# censoredHeaders = from, accept-language\n# censorReferer = maybe\n\n# Uncomment this if you're paranoid.  This will break a lot of sites,\n# though:\n\n# censoredHeaders = set-cookie, cookie, cookie2, from, accept-language\n# censorReferer = true\n\n# Uncomment this if you want to use Poor Man's Multiplexing; increase\n# the sizes if you're on a fast line.  They should each amount to a few\n# seconds' worth of transfer; if pmmSize is small, you'll want\n# pmmFirstSize to be larger.\n\n# Note that PMM is somewhat unreliable.\n\n# pmmFirstSize = 16384\n# pmmSize = 8192\n\n# Uncomment this if your user-agent does something reasonable with\n# Warning headers (most don't):\n\n# relaxTransparency = maybe\n\n# Uncomment this if you never want to revalidate instances for which\n# data is available (this is not a good idea):\n\n# relaxTransparency = yes\n\n# Uncomment this if you have no network:\n\n# proxyOffline = yes\n\n# Uncomment this if you want to avoid revalidating instances with a\n# Vary header (this is not a good idea):\n\n# mindlesslyCacheVary = true\n\n# Uncomment this if you want to add a no-transform directive to all\n# outgoing requests.\n\n# alwaysAddNoTransform = true\n"
        },
        {
          "name": "dirent_compat.c",
          "type": "blob",
          "size": 3.1455078125,
          "content": "/*\r\n\r\n    Implementation of POSIX directory browsing functions and types for Win32.\r\n\r\n    Author:  Kevlin Henney (kevlin@acm.org, kevlin@curbralan.com)\r\n    History: Created March 1997. Updated June 2003.\r\n    Rights:  See end of file.\r\n\r\n*/\r\n\r\n#ifdef WIN32\r\n\r\n#include \"dirent_compat.h\"\r\n#include <errno.h>\r\n#include <io.h> /* _findfirst and _findnext set errno iff they return -1 */\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n{\r\n#endif\r\n\r\nstruct DIR\r\n{\r\n    long                handle; /* -1 for failed rewind */\r\n    struct _finddata_t  info;\r\n    struct dirent       result; /* d_name null iff first time */\r\n    char                *name;  /* null-terminated char string */\r\n};\r\n\r\nDIR *opendir(const char *name)\r\n{\r\n    DIR *dir = 0;\r\n\r\n    if(name && name[0])\r\n    {\r\n        size_t base_length = strlen(name);\r\n        const char *all = /* search pattern must end with suitable wildcard */\r\n            strchr(\"/\\\\\", name[base_length - 1]) ? \"*\" : \"/*\";\r\n\r\n        if((dir = (DIR *) malloc(sizeof *dir)) != 0 &&\r\n           (dir->name = (char *) malloc(base_length + strlen(all) + 1)) != 0)\r\n        {\r\n            strcat(strcpy(dir->name, name), all);\r\n\r\n            if((dir->handle = (long) _findfirst(dir->name, &dir->info)) != -1)\r\n            {\r\n                dir->result.d_name = 0;\r\n            }\r\n            else /* rollback */\r\n            {\r\n                free(dir->name);\r\n                free(dir);\r\n                dir = 0;\r\n            }\r\n        }\r\n        else /* rollback */\r\n        {\r\n            free(dir);\r\n            dir   = 0;\r\n            errno = ENOMEM;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        errno = EINVAL;\r\n    }\r\n\r\n    return dir;\r\n}\r\n\r\nint closedir(DIR *dir)\r\n{\r\n    int result = -1;\r\n\r\n    if(dir)\r\n    {\r\n        if(dir->handle != -1)\r\n        {\r\n            result = _findclose(dir->handle);\r\n        }\r\n\r\n        free(dir->name);\r\n        free(dir);\r\n    }\r\n\r\n    if(result == -1) /* map all errors to EBADF */\r\n    {\r\n        errno = EBADF;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nstruct dirent *readdir(DIR *dir)\r\n{\r\n    struct dirent *result = 0;\r\n\r\n    if(dir && dir->handle != -1)\r\n    {\r\n        if(!dir->result.d_name || _findnext(dir->handle, &dir->info) != -1)\r\n        {\r\n            result         = &dir->result;\r\n            result->d_name = dir->info.name;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        errno = EBADF;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvoid rewinddir(DIR *dir)\r\n{\r\n    if(dir && dir->handle != -1)\r\n    {\r\n        _findclose(dir->handle);\r\n        dir->handle = (long) _findfirst(dir->name, &dir->info);\r\n        dir->result.d_name = 0;\r\n    }\r\n    else\r\n    {\r\n        errno = EBADF;\r\n    }\r\n}\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n\r\n/*\r\n\r\n    Copyright Kevlin Henney, 1997, 2003. All rights reserved.\r\n\r\n    Permission to use, copy, modify, and distribute this software and its\r\n    documentation for any purpose is hereby granted without fee, provided\r\n    that this copyright and permissions notice appear in all copies and\r\n    derivatives.\r\n    \r\n    This software is supplied \"as is\" without express or implied warranty.\r\n\r\n    But that said, if there are any problems please get in touch.\r\n\r\n*/\r\n"
        },
        {
          "name": "dirent_compat.h",
          "type": "blob",
          "size": 1.0390625,
          "content": "#ifndef DIRENT_INCLUDED\r\n#define DIRENT_INCLUDED\r\n\r\n/*\r\n\r\n    Declaration of POSIX directory browsing functions and types for Win32.\r\n\r\n    Author:  Kevlin Henney (kevlin@acm.org, kevlin@curbralan.com)\r\n    History: Created March 1997. Updated June 2003.\r\n    Rights:  See end of file.\r\n    \r\n*/\r\n\r\n#ifdef __cplusplus\r\nextern \"C\"\r\n{\r\n#endif\r\n\r\ntypedef struct DIR DIR;\r\n\r\nstruct dirent\r\n{\r\n    char *d_name;\r\n};\r\n\r\nDIR           *opendir(const char *);\r\nint           closedir(DIR *);\r\nstruct dirent *readdir(DIR *);\r\nvoid          rewinddir(DIR *);\r\n\r\n/*\r\n\r\n    Copyright Kevlin Henney, 1997, 2003. All rights reserved.\r\n\r\n    Permission to use, copy, modify, and distribute this software and its\r\n    documentation for any purpose is hereby granted without fee, provided\r\n    that this copyright and permissions notice appear in all copies and\r\n    derivatives.\r\n    \r\n    This software is supplied \"as is\" without express or implied warranty.\r\n\r\n    But that said, if there are any problems please get in touch.\r\n\r\n*/\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "diskcache.c",
          "type": "blob",
          "size": 68.76953125,
          "content": "/*\nCopyright (c) 2003-2010 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifndef NO_DISK_CACHE\n\n#include \"md5import.h\"\n\nint maxDiskEntries = 32;\n\n/* Because the functions in this file can be called during object\n   expiry, we cannot use get_chunk. */\n\nAtomPtr diskCacheRoot;\nAtomPtr localDocumentRoot;\n\nDiskCacheEntryPtr diskEntries = NULL, diskEntriesLast = NULL;\nint numDiskEntries = 0;\nint diskCacheDirectoryPermissions = 0700;\nint diskCacheFilePermissions = 0600;\nint diskCacheWriteoutOnClose = (64 * 1024);\n\nint maxDiskCacheEntrySize = -1;\n\nint diskCacheUnlinkTime = 32 * 24 * 60 * 60;\nint diskCacheTruncateTime = 4 * 24 * 60 * 60 + 12 * 60 * 60;\nint diskCacheTruncateSize =  1024 * 1024;\nint preciseExpiry = 0;\n\nstatic DiskCacheEntryRec negativeEntry = {\n    NULL, NULL,\n    -1, -1, -1, -1, 0, 0, NULL, NULL\n};\n\n#ifndef LOCAL_ROOT\n#define LOCAL_ROOT \"/usr/share/polipo/www/\"\n#endif\n\n#ifndef DISK_CACHE_ROOT\n#define DISK_CACHE_ROOT \"/var/cache/polipo/\"\n#endif\n\nstatic int maxDiskEntriesSetter(ConfigVariablePtr, void*);\nstatic int atomSetterFlush(ConfigVariablePtr, void*);\nstatic int reallyWriteoutToDisk(ObjectPtr object, int upto, int max);\n\nvoid \npreinitDiskcache()\n{\n    diskCacheRoot = internAtom(DISK_CACHE_ROOT);\n    localDocumentRoot = internAtom(LOCAL_ROOT);\n\n    CONFIG_VARIABLE_SETTABLE(diskCacheDirectoryPermissions, CONFIG_OCTAL,\n                             configIntSetter,\n                             \"Access rights for new directories.\");\n    CONFIG_VARIABLE_SETTABLE(diskCacheFilePermissions, CONFIG_OCTAL,\n                             configIntSetter,\n                             \"Access rights for new cache files.\");\n    CONFIG_VARIABLE_SETTABLE(diskCacheWriteoutOnClose, CONFIG_INT,\n                             configIntSetter,\n                             \"Number of bytes to write out eagerly.\");\n    CONFIG_VARIABLE_SETTABLE(diskCacheRoot, CONFIG_ATOM, atomSetterFlush,\n                             \"Root of the disk cache.\");\n    CONFIG_VARIABLE_SETTABLE(localDocumentRoot, CONFIG_ATOM, atomSetterFlush,\n                             \"Root of the local tree.\");\n    CONFIG_VARIABLE_SETTABLE(maxDiskEntries, CONFIG_INT, maxDiskEntriesSetter,\n                    \"File descriptors used by the on-disk cache.\");\n    CONFIG_VARIABLE(diskCacheUnlinkTime, CONFIG_TIME,\n                    \"Time after which on-disk objects are removed.\");\n    CONFIG_VARIABLE(diskCacheTruncateTime, CONFIG_TIME,\n                    \"Time after which on-disk objects are truncated.\");\n    CONFIG_VARIABLE(diskCacheTruncateSize, CONFIG_INT, \n                    \"Size to which on-disk objects are truncated.\");\n    CONFIG_VARIABLE(preciseExpiry, CONFIG_BOOLEAN,\n                    \"Whether to consider all files for purging.\");\n    CONFIG_VARIABLE_SETTABLE(maxDiskCacheEntrySize, CONFIG_INT,\n                             configIntSetter,\n                             \"Maximum size of objects cached on disk.\");\n}\n\nstatic int\nmaxDiskEntriesSetter(ConfigVariablePtr var, void *value)\n{\n    int i;\n    assert(var->type == CONFIG_INT && var->value.i == &maxDiskEntries);\n    i = *(int*)value;\n    if(i < 0 || i > 1000000)\n        return -3;\n    maxDiskEntries = i;\n    while(numDiskEntries > maxDiskEntries)\n        destroyDiskEntry(diskEntriesLast->object, 0);\n    return 1;\n}\n\nstatic int\natomSetterFlush(ConfigVariablePtr var, void *value)\n{\n    discardObjects(1, 0);\n    return configAtomSetter(var, value);\n}\n\nstatic int\ncheckRoot(AtomPtr root)\n{\n    struct stat ss;\n    int rc;\n\n    if(!root || root->length == 0)\n        return 0;\n\n#ifdef WIN32  /* Require \"x:/\" or \"x:\\\\\" */\n    rc = isalpha(root->string[0]) && (root->string[1] == ':') &&\n         ((root->string[2] == '/') || (root->string[2] == '\\\\'));\n    if(!rc) {\n        return -2;\n    }\n#else\n    if(root->string[0] != '/') {\n        return -2;\n    }\n#endif\n\n    rc = stat(root->string, &ss);\n    if(rc < 0)\n        return -1;\n    else if(!S_ISDIR(ss.st_mode)) {\n        errno = ENOTDIR;\n        return -1;\n    }\n    return 1;\n}\n\nstatic AtomPtr\nmaybeAddSlash(AtomPtr atom)\n{\n    AtomPtr newAtom = NULL;\n    if(!atom) return NULL;\n    if(atom->length > 0 && atom->string[atom->length - 1] != '/') {\n        newAtom = atomCat(atom, \"/\");\n        releaseAtom(atom);\n        return newAtom;\n    }\n    return atom;\n}\n\nvoid\ninitDiskcache()\n{\n    int rc;\n\n    diskCacheRoot = expandTilde(maybeAddSlash(diskCacheRoot));\n    rc = checkRoot(diskCacheRoot);\n    if(rc <= 0) {\n        switch(rc) {\n        case 0: break;\n        case -1: do_log_error(L_WARN, errno, \"Disabling disk cache\"); break;\n        case -2: \n            do_log(L_WARN, \"Disabling disk cache: path %s is not absolute.\\n\",\n                   diskCacheRoot->string); \n            break;\n        default: abort();\n        }\n        releaseAtom(diskCacheRoot);\n        diskCacheRoot = NULL;\n    }\n\n    localDocumentRoot = expandTilde(maybeAddSlash(localDocumentRoot));\n    rc = checkRoot(localDocumentRoot);\n    if(rc <= 0) {\n        switch(rc) {\n        case 0: break;\n        case -1: do_log_error(L_WARN, errno, \"Disabling local tree\"); break;\n        case -2: \n            do_log(L_WARN, \"Disabling local tree: path is not absolute.\\n\"); \n            break;\n        default: abort();\n        }\n        releaseAtom(localDocumentRoot);\n        localDocumentRoot = NULL;\n    }\n}\n\n#ifdef DEBUG_DISK_CACHE\n#define CHECK_ENTRY(entry) check_entry((entry))\nstatic void\ncheck_entry(DiskCacheEntryPtr entry)\n{\n    if(entry && entry->fd < 0)\n        assert(entry == &negativeEntry);\n    if(entry && entry->fd >= 0) {\n        assert((!entry->previous) == (entry == diskEntries));\n        assert((!entry->next) == (entry == diskEntriesLast));\n        if(entry->size >= 0)\n            assert(entry->size + entry->body_offset >= entry->offset);\n        assert(entry->body_offset >= 0);\n        if(entry->offset >= 0) {\n            off_t offset;\n            offset = lseek(entry->fd, 0, SEEK_CUR);\n            assert(offset == entry->offset);\n        }\n        if(entry->size >= 0) {\n            int rc;\n            struct stat ss;\n            rc = fstat(entry->fd, &ss);\n            assert(rc >= 0);\n            assert(ss.st_size == entry->size + entry->body_offset);\n        }\n    }\n}\n#else\n#define CHECK_ENTRY(entry) do {} while(0)\n#endif\n\nint\ndiskEntrySize(ObjectPtr object)\n{\n    struct stat buf;\n    int rc;\n    DiskCacheEntryPtr entry = object->disk_entry;\n\n    if(!entry || entry == &negativeEntry)\n        return -1;\n\n    if(entry->size >= 0)\n        return entry->size;\n\n    rc = fstat(entry->fd, &buf);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't stat\");\n        return -1;\n    }\n\n    if(buf.st_size <= entry->body_offset)\n        entry->size = 0;\n    else\n        entry->size =  buf.st_size - entry->body_offset;\n    CHECK_ENTRY(entry);\n    if(object->length >= 0 && entry->size == object->length)\n        object->flags |= OBJECT_DISK_ENTRY_COMPLETE;\n    return entry->size;\n}\n\nstatic int\nentrySeek(DiskCacheEntryPtr entry, off_t offset)\n{\n    off_t rc;\n\n    CHECK_ENTRY(entry);\n    assert(entry != &negativeEntry);\n    if(entry->offset == offset)\n        return 1;\n    if(offset > entry->body_offset) {\n        /* Avoid extending the file by mistake */\n        if(entry->size < 0)\n            diskEntrySize(entry->object);\n        if(entry->size < 0)\n            return -1;\n        if(entry->size + entry->body_offset < offset)\n            return -1;\n    }\n    rc = lseek(entry->fd, offset, SEEK_SET);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't seek\");\n        entry->offset = -1;\n        return -1;\n    }\n    entry->offset = offset;\n    return 1;\n}\n\n/* Given a local URL, constructs the filename where it can be found. */\n\nint\nlocalFilename(char *buf, int n, char *key, int len)\n{\n    int i, j;\n    if(len <= 0 || key[0] != '/') return -1;\n\n    if(urlIsSpecial(key, len)) return -1;\n\n    if(checkRoot(localDocumentRoot) <= 0)\n        return -1;\n\n    if(n <= localDocumentRoot->length)\n        return -1;\n\n    i = 0;\n    if(key[i] != '/')\n        return -1;\n\n    memcpy(buf, localDocumentRoot->string, localDocumentRoot->length);\n    j = localDocumentRoot->length;\n    if(buf[j - 1] == '/')\n        j--;\n\n    while(i < len) {\n        if(j >= n - 1)\n            return -1;\n        if(key[i] == '/' && i < len - 2)\n            if(key[i + 1] == '.' && \n               (key[i + 2] == '.' || key[i + 2] == '/'))\n                return -1;\n        buf[j++] = key[i++];\n    }\n\n    if(buf[j - 1] == '/') {\n        if(j >= n - 11)\n            return -1;\n        memcpy(buf + j, \"index.html\", 10);\n        j += 10;\n    }\n\n    buf[j] = '\\0';\n    return j;\n}\n\nstatic void\nmd5(unsigned char *restrict key, int len, unsigned char *restrict dst)\n{\n    static MD5_CTX ctx;\n    MD5Init(&ctx);\n    MD5Update(&ctx, key, len);\n    MD5Final(&ctx);\n    memcpy(dst, ctx.digest, 16);\n}\n\n/* Check whether a character can be stored in a filename.  This is\n   needed since we want to support deficient file systems. */\nstatic int\nfssafe(char c)\n{\n    if(c <= 31 || c >= 127)\n        return 0;\n    if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||\n       (c >= '0' && c <= '9') ||  c == '.' || c == '-' || c == '_')\n        return 1;\n    return 0;\n}\n\n/* Given a URL, returns the directory name within which all files\n   starting with this URL can be found. */\nstatic int\nurlDirname(char *buf, int n, const char *url, int len)\n{\n    int i, j;\n    if(len < 8)\n        return -1;\n    if(lwrcmp(url, \"http://\", 7) != 0)\n        return -1;\n\n    if(checkRoot(diskCacheRoot) <= 0)\n        return -1;\n\n    if(n <= diskCacheRoot->length)\n        return -1;\n\n    memcpy(buf, diskCacheRoot->string, diskCacheRoot->length);\n    j = diskCacheRoot->length;\n\n    if(buf[j - 1] != '/')\n        buf[j++] = '/';\n\n    for(i = 7; i < len; i++) {\n        if(i >= len || url[i] == '/')\n            break;\n        if(url[i] == '.' && i != len - 1 && url[i + 1] == '.')\n            return -1;\n        if(url[i] == '%' || !fssafe(url[i])) {\n            if(j + 3 >= n) return -1;\n            buf[j++] = '%';\n            buf[j++] = i2h((url[i] & 0xF0) >> 4);\n            buf[j++] = i2h(url[i] & 0x0F);\n        } else {\n            buf[j++] = url[i]; if(j >= n) return -1;\n        }\n    }\n    buf[j++] = '/'; if(j >= n) return -1;\n    buf[j] = '\\0';\n    return j;\n}\n\n/* Given a URL, returns the filename where the cached data can be\n   found. */\nstatic int\nurlFilename(char *restrict buf, int n, const char *url, int len)\n{\n    int j;\n    unsigned char md5buf[18];\n    j = urlDirname(buf, n, url, len);\n    if(j < 0 || j + 24 >= n)\n        return -1;\n    md5((unsigned char*)url, len, md5buf);\n    b64cpy(buf + j, (char*)md5buf, 16, 1);\n    buf[j + 24] = '\\0';\n    return j + 24;\n}\n\nstatic char *\ndirnameUrl(char *url, int n, char *name, int len)\n{\n    int i, j, k, c1, c2;\n    k = diskCacheRoot->length;\n    if(len < k)\n        return NULL;\n    if(memcmp(name, diskCacheRoot->string, k) != 0)\n        return NULL;\n    if(n < 8)\n        return NULL;\n    memcpy(url, \"http://\", 7);\n    if(name[len - 1] == '/')\n        len --;\n    j = 7;\n    for(i = k; i < len; i++) {\n        if(name[i] == '%') {\n            if(i >= len - 2)\n                return NULL;\n            c1 = h2i(name[i + 1]);\n            c2 = h2i(name[i + 2]);\n            if(c1 < 0 || c2 < 0)\n                return NULL;\n            url[j++] = c1 * 16 + c2; if(j >= n) goto fail;\n            i += 2;             /* skip extra digits */\n        } else if(i < len - 1 && \n                  name[i] == '.' && name[i + 1] == '/') {\n                return NULL;\n        } else if(i == len - 1 && name[i] == '.') {\n            return NULL;\n        } else {\n            url[j++] = name[i]; if(j >= n) goto fail;\n        }\n    }\n    url[j++] = '/'; if(j >= n) goto fail;\n    url[j] = '\\0';\n    return url;\n\n fail:\n    return NULL;\n}\n\n/* Create a file and all intermediate directories. */\nstatic int\ncreateFile(const char *name, int path_start)\n{\n    int fd;\n    char buf[1024];\n    int n;\n    int rc;\n\n    if(name[path_start] == '/')\n        path_start++;\n\n    if(path_start < 2 || name[path_start - 1] != '/' ) {\n        do_log(L_ERROR, \"Incorrect name %s (%d).\\n\", name, path_start);\n        return -1;\n    }\n\n    fd = open(name, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n\t      diskCacheFilePermissions);\n    if(fd >= 0)\n        return fd;\n    if(errno != ENOENT) {\n        do_log_error(L_ERROR, errno, \"Couldn't create disk file %s\", name);\n        return -1;\n    }\n    \n    n = path_start;\n    while(name[n] != '\\0' && n < 1024) {\n        while(name[n] != '/' && name[n] != '\\0' && n < 512)\n            n++;\n        if(name[n] != '/' || n >= 1024)\n            break;\n        memcpy(buf, name, n + 1);\n        buf[n + 1] = '\\0';\n        rc = mkdir(buf, diskCacheDirectoryPermissions);\n        if(rc < 0 && errno != EEXIST) {\n            do_log_error(L_ERROR, errno, \"Couldn't create directory %s\", buf);\n            return -1;\n        }\n        n++;\n    }\n    fd = open(name, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n\t      diskCacheFilePermissions);\n    if(fd < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't create file %s\", name);\n        return -1;\n    }\n\n    return fd;\n}\n\nstatic int\nchooseBodyOffset(int n, ObjectPtr object)\n{\n    int length = MAX(object->size, object->length);\n    int body_offset;\n\n    if(object->length >= 0 && object->length + n < 4096 - 4)\n        return -1;              /* no gap for small objects */\n\n    if(n <= 128)\n        body_offset = 256;\n    else if(n <= 192)\n        body_offset = 384;\n    else if(n <= 256)\n        body_offset = 512;\n    else if(n <= 384)\n        body_offset = 768;\n    else if(n <= 512)\n        body_offset = 1024;\n    else if(n <= 1024)\n        body_offset = 2048;\n    else if(n < 2048)\n        body_offset = 4096;\n    else\n        body_offset = ((n + 32 + 4095) / 4096 + 1) * 4096;\n\n    /* Tweak the gap so that we don't use up a full disk block for\n       a small tail */\n    if(object->length >= 0 && object->length < 64 * 1024) {\n        int last = (body_offset + object->length) % 4096;\n        int gap = body_offset - n - 32;\n        if(last < gap / 2)\n            body_offset -= last;\n    }\n\n    /* Rewriting large objects is expensive -- don't use small gaps.\n       This has the additional benefit of block-aligning large bodies. */\n    if(length >= 64 * 1024) {\n        int min_gap, min_offset;\n        if(length >= 512 * 1024)\n            min_gap = 4096;\n        else if(length >= 256 * 1024)\n            min_gap = 2048;\n        else\n            min_gap = 1024;\n\n        min_offset = ((n + 32 + min_gap - 1) / min_gap + 1) * min_gap;\n        body_offset = MAX(body_offset, min_offset);\n    }\n\n    return body_offset;\n}\n \n/* Assumes the file descriptor is at offset 0.  Returns -1 on failure,\n   otherwise the offset at which the file descriptor is left. */\n/* If chunk is not null, it should be the first chunk of the object,\n   and will be written out in the same operation if possible. */\nstatic int\nwriteHeaders(int fd, int *body_offset_return,\n             ObjectPtr object, char *chunk, int chunk_len)\n{\n    int n, rc, error = -1;\n    int body_offset = *body_offset_return;\n    char *buf = NULL;\n    int buf_is_chunk = 0;\n    int bufsize = 0;\n\n    if(object->flags & OBJECT_LOCAL)\n        return -1;\n\n    if(body_offset > CHUNK_SIZE)\n        goto overflow;\n\n    /* get_chunk might trigger object expiry */\n    bufsize = CHUNK_SIZE;\n    buf_is_chunk = 1;\n    buf = maybe_get_chunk();\n    if(!buf) {\n        bufsize = 2048;\n        buf_is_chunk = 0;\n        buf = malloc(2048);\n        if(buf == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate buffer.\\n\");\n            return -1;\n        }\n    }\n\n format_again:\n    n = snnprintf(buf, 0, bufsize, \"HTTP/1.1 %3d %s\",\n                  object->code, object->message->string);\n\n    n = httpWriteObjectHeaders(buf, n, bufsize, object, 0, -1);\n    if(n < 0)\n        goto overflow;\n\n    n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Location: \");\n    n = snnprint_n(buf, n, bufsize, object->key, object->key_size);\n\n    if(object->age >= 0 && object->age != object->date) {\n        n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Date: \");\n        n = format_time(buf, n, bufsize, object->age);\n    }\n\n    if(object->atime >= 0) {\n        n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Access: \");\n        n = format_time(buf, n, bufsize, object->atime);\n    }\n\n    if(n < 0)\n        goto overflow;\n\n    if(body_offset < 0)\n        body_offset = chooseBodyOffset(n, object);\n\n    if(body_offset > bufsize)\n        goto overflow;\n\n    if(body_offset > 0 && body_offset != n + 4)\n        n = snnprintf(buf, n, bufsize, \"\\r\\nX-Polipo-Body-Offset: %d\",\n                      body_offset);\n\n    n = snnprintf(buf, n, bufsize, \"\\r\\n\\r\\n\");\n    if(n < 0)\n        goto overflow;\n\n    if(body_offset < 0)\n        body_offset = n;\n    if(n > body_offset) {\n        error = -2;\n        goto fail;\n    }\n\n    if(n < body_offset)\n        memset(buf + n, 0, body_offset - n);\n\n again:\n#ifdef HAVE_READV_WRITEV\n    if(chunk_len > 0) {\n        struct iovec iov[2];\n        iov[0].iov_base = buf;\n        iov[0].iov_len = body_offset;\n        iov[1].iov_base = chunk;\n        iov[1].iov_len = chunk_len;\n        rc = writev(fd, iov, 2);\n    } else\n#endif\n        rc = write(fd, buf, body_offset);\n\n    if(rc < 0 && errno == EINTR)\n        goto again;\n\n    if(rc < body_offset)\n        goto fail;\n    if(object->length >= 0 && \n       rc - body_offset >= object->length)\n        object->flags |= OBJECT_DISK_ENTRY_COMPLETE;\n\n    *body_offset_return = body_offset;\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return rc;\n\n overflow:\n    if(bufsize < bigBufferSize) {\n        char *oldbuf = buf;\n        buf = malloc(bigBufferSize);\n        if(!buf) {\n            do_log(L_ERROR, \"Couldn't allocate big buffer.\\n\");\n            goto fail;\n        }\n        bufsize = bigBufferSize;\n        if(oldbuf) {\n            if(buf_is_chunk)\n                dispose_chunk(oldbuf);\n            else\n                free(oldbuf);\n        }\n        buf_is_chunk = 0;\n        goto format_again;\n    }\n    /* fall through */\n\n fail:\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return error;\n}\n\ntypedef struct _MimeEntry {\n    char *extension;\n    char *mime;\n} MimeEntryRec;\n\nstatic const MimeEntryRec mimeEntries[] = {\n    { \"html\", \"text/html\" },\n    { \"htm\", \"text/html\" },\n    { \"text\", \"text/plain\" },\n    { \"txt\", \"text/plain\" },\n    { \"png\", \"image/png\" },\n    { \"gif\", \"image/gif\" },\n    { \"jpeg\", \"image/jpeg\" },\n    { \"jpg\", \"image/jpeg\" },\n    { \"ico\", \"image/x-icon\" },\n    { \"pdf\", \"application/pdf\" },\n    { \"ps\", \"application/postscript\" },\n    { \"tar\", \"application/x-tar\" },\n    { \"pac\", \"application/x-ns-proxy-autoconfig\" },\n    { \"css\", \"text/css\" },\n    { \"js\",  \"application/x-javascript\" },\n    { \"xml\", \"text/xml\" },\n    { \"swf\", \"application/x-shockwave-flash\" },\n};\n\nstatic char*\nlocalObjectMimeType(ObjectPtr object, char **encoding_return)\n{\n    char *name = object->key;\n    int nlen = object->key_size;\n    int i;\n\n    assert(nlen >= 1);\n\n    if(name[nlen - 1] == '/') {\n        *encoding_return = NULL;\n        return \"text/html\";\n    }\n\n    if(nlen < 3) {\n        *encoding_return = NULL;\n        return \"application/octet-stream\";\n    }\n\n    if(memcmp(name + nlen - 3, \".gz\", 3) == 0) {\n        *encoding_return = \"x-gzip\";\n        nlen -= 3;\n    } else if(memcmp(name + nlen - 2, \".Z\", 2) == 0) {\n        *encoding_return = \"x-compress\";\n        nlen -= 2;\n    } else {\n        *encoding_return = NULL;\n    }\n\n    for(i = 0; i < sizeof(mimeEntries) / sizeof(mimeEntries[0]); i++) {\n        int len = strlen(mimeEntries[i].extension);\n        if(nlen > len && \n           name[nlen - len - 1] == '.' &&\n           memcmp(name + nlen - len, mimeEntries[i].extension, len) == 0)\n            return mimeEntries[i].mime;\n    }\n\n    return \"application/octet-stream\";\n}\n\n/* Same interface as validateEntry -- see below */\nint\nvalidateLocalEntry(ObjectPtr object, int fd,\n                   int *body_offset_return, off_t *offset_return)\n{\n    struct stat ss;\n    char buf[512];\n    int n, rc;\n    char *encoding;\n\n    rc = fstat(fd, &ss);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't stat\");\n        return -1;\n    }\n\n    if(S_ISREG(ss.st_mode)) {\n        if(!(ss.st_mode & S_IROTH) ||\n           (object->length >= 0 && object->length != ss.st_size) ||\n           (object->last_modified >= 0 && \n            object->last_modified != ss.st_mtime))\n            return -1;\n    } else {\n        notifyObject(object);\n        return -1;\n    }\n    \n    n = snnprintf(buf, 0, 512, \"%lx-%lx-%lx\",\n                  (unsigned long)ss.st_ino,\n                  (unsigned long)ss.st_size,\n                  (unsigned long)ss.st_mtime);\n    if(n >= 512)\n        n = -1;\n\n    if(n > 0 && object->etag) {\n        if(strlen(object->etag) != n ||\n           memcmp(object->etag, buf, n) != 0)\n            return -1;\n    }\n\n    if(!(object->flags & OBJECT_INITIAL)) {\n        if(!object->last_modified && !object->etag)\n            return -1;\n    }\n       \n    if(object->flags & OBJECT_INITIAL) {\n        object->length = ss.st_size;\n        object->last_modified = ss.st_mtime;\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->code = 200;\n        if(n > 0)\n            object->etag = strdup(buf); /* okay if fails */\n        object->message = internAtom(\"Okay\");\n        n = snnprintf(buf, 0, 512,\n                      \"\\r\\nServer: Polipo\"\n                      \"\\r\\nContent-Type: %s\",\n                      localObjectMimeType(object, &encoding));\n        if(encoding != NULL)\n            n = snnprintf(buf, n, 512,\n                          \"\\r\\nContent-Encoding: %s\", encoding);\n        if(n < 0)\n            return -1;\n        object->headers = internAtomN(buf, n);\n        if(object->headers == NULL)\n            return -1;\n        object->flags &= ~OBJECT_INITIAL;\n    }\n\n    if(body_offset_return)\n        *body_offset_return = 0;\n    if(offset_return)\n        *offset_return = 0;\n    return 0;\n}\n\n/* Assumes fd is at offset 0.\n   Returns -1 if not valid, 1 if metadata should be written out, 0\n   otherwise. */\nint\nvalidateEntry(ObjectPtr object, int fd, \n              int *body_offset_return, off_t *offset_return)\n{\n    char *buf;\n    int buf_is_chunk, bufsize;\n    int rc, n;\n    int dummy;\n    int code;\n    AtomPtr headers;\n    time_t date, last_modified, expires, polipo_age, polipo_access;\n    int length;\n    off_t offset = -1;\n    int body_offset;\n    char *etag;\n    AtomPtr via;\n    CacheControlRec cache_control;\n    char *location;\n    AtomPtr message;\n    int dirty = 0;\n\n    if(object->flags & OBJECT_LOCAL)\n        return validateLocalEntry(object, fd,\n                                  body_offset_return, offset_return);\n\n    if(!(object->flags & OBJECT_PUBLIC) && (object->flags & OBJECT_INITIAL))\n        return 0;\n\n    /* get_chunk might trigger object expiry */\n    bufsize = CHUNK_SIZE;\n    buf_is_chunk = 1;\n    buf = maybe_get_chunk();\n    if(!buf) {\n        bufsize = 2048;\n        buf_is_chunk = 0;\n        buf = malloc(2048);\n        if(buf == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate buffer.\\n\");\n            return -1;\n        }\n    }\n\n again:\n    rc = read(fd, buf, bufsize);\n    if(rc < 0) {\n        if(errno == EINTR)\n            goto again;\n        do_log_error(L_ERROR, errno, \"Couldn't read disk entry\");\n        goto fail;\n    }\n    offset = rc;\n\n parse_again:\n    n = findEndOfHeaders(buf, 0, rc, &dummy);\n    if(n < 0) {\n        char *oldbuf = buf;\n        if(bufsize < bigBufferSize) {\n            buf = malloc(bigBufferSize);\n            if(!buf) {\n                do_log(L_ERROR, \"Couldn't allocate big buffer.\\n\");\n                goto fail;\n            }\n            bufsize = bigBufferSize;\n            memcpy(buf, oldbuf, offset);\n            if(buf_is_chunk)\n                dispose_chunk(oldbuf);\n            else\n                free(oldbuf);\n            buf_is_chunk = 0;\n        again2:\n            rc = read(fd, buf + offset, bufsize - offset);\n            if(rc < 0) {\n                if(errno == EINTR)\n                    goto again2;\n                do_log_error(L_ERROR, errno, \"Couldn't read disk entry\");\n                goto fail;\n            }\n            offset += rc;\n            goto parse_again;\n        }\n        do_log(L_ERROR, \"Couldn't parse disk entry.\\n\");\n        goto fail;\n    }\n\n    rc = httpParseServerFirstLine(buf, &code, &dummy, &message);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Couldn't parse disk entry.\\n\");\n        goto fail;\n    }\n\n    if(object->code != 0 && object->code != code) {\n        releaseAtom(message);\n        goto fail;\n    }\n\n    rc = httpParseHeaders(0, NULL, buf, rc, NULL,\n                          &headers, &length, &cache_control, NULL, NULL,\n                          &date, &last_modified, &expires, &polipo_age,\n                          &polipo_access, &body_offset,\n                          NULL, &etag, NULL,\n                          NULL, NULL, &location, &via, NULL);\n    if(rc < 0) {\n        releaseAtom(message);\n        goto fail;\n    }\n    if(body_offset < 0)\n        body_offset = n;\n\n    if(!location || strlen(location) != object->key_size ||\n       memcmp(location, object->key, object->key_size) != 0) {\n        do_log(L_ERROR, \"Inconsistent cache file for %s.\\n\", scrub(location));\n        goto invalid;\n    }\n\n    if(polipo_age < 0)\n        polipo_age = date;\n\n    if(polipo_age < 0) {\n        do_log(L_ERROR, \"Undated disk entry for %s.\\n\", scrub(location));\n        goto invalid;\n    }\n\n    if(!(object->flags & OBJECT_INITIAL)) {\n        if((last_modified >= 0) != (object->last_modified >= 0))\n            goto invalid;\n\n        if((object->cache_control & CACHE_MISMATCH) ||\n           (cache_control.flags & CACHE_MISMATCH))\n            goto invalid;\n\n        if(last_modified >= 0 && object->last_modified >= 0 &&\n           last_modified != object->last_modified)\n            goto invalid;\n\n        if(length >= 0 && object->length >= 0)\n            if(length != object->length)\n                goto invalid;\n\n        if(!!etag != !!object->etag)\n            goto invalid;\n\n        if(etag && object->etag && strcmp(etag, object->etag) != 0)\n            goto invalid;\n\n        /* If we don't have a usable ETag, and either CACHE_VARY or we\n           don't have a last-modified date, we validate disk entries by\n           using their date. */\n        if(!(etag && object->etag) &&\n           (!(last_modified >= 0 && object->last_modified >= 0) ||\n            ((cache_control.flags & CACHE_VARY) ||\n             (object->cache_control & CACHE_VARY)))) {\n            if(date >= 0 && date != object->date)\n                goto invalid;\n            if(polipo_age >= 0 && polipo_age != object->age)\n                goto invalid;\n        }\n        if((object->cache_control & CACHE_VARY) && dontTrustVaryETag >= 1) {\n            /* Check content-type to work around mod_gzip bugs */\n            if(!httpHeaderMatch(atomContentType, object->headers, headers) ||\n               !httpHeaderMatch(atomContentEncoding, object->headers, headers))\n                goto invalid;\n        }\n    }\n\n    if(location)\n        free(location);\n\n    if(headers) {\n        if(!object->headers)\n            object->headers = headers;\n        else\n            releaseAtom(headers);\n    }\n\n    if(object->code == 0) {\n        object->code = code;\n        object->message = retainAtom(message);\n    }\n    if(object->date <= date)\n        object->date = date;\n    else \n        dirty = 1;\n    if(object->last_modified < 0)\n        object->last_modified = last_modified;\n    if(object->expires < 0)\n        object->expires = expires;\n    else if(object->expires > expires)\n        dirty = 1;\n    if(object->age < 0)\n        object->age = polipo_age;\n    else if(object->age > polipo_age)\n        dirty = 1;\n    if(object->atime <= polipo_access)\n        object->atime = polipo_access;\n    else\n        dirty = 1;\n\n    object->cache_control |= cache_control.flags;\n    object->max_age = cache_control.max_age;\n    object->s_maxage = cache_control.s_maxage;\n\n    if(object->age < 0) object->age = object->date;\n    if(object->age < 0) object->age = 0; /* a long time ago */\n    if(object->length < 0) object->length = length;\n    if(!object->etag)\n        object->etag = etag;\n    else {\n        if(etag)\n            free(etag);\n    }\n    releaseAtom(message);\n\n    if(object->flags & OBJECT_INITIAL) object->via = via;\n    object->flags &= ~OBJECT_INITIAL;\n    if(offset > body_offset) {\n        /* We need to make sure we don't invoke object expiry recursively */\n        objectSetChunks(object, 1);\n        if(object->numchunks >= 1) {\n            if(object->chunks[0].data == NULL)\n                object->chunks[0].data = maybe_get_chunk();\n            if(object->chunks[0].data)\n                objectAddData(object, buf + body_offset,\n                              0, MIN(offset - body_offset, CHUNK_SIZE));\n        }\n    }\n\n    httpTweakCachability(object);\n\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    if(body_offset_return) *body_offset_return = body_offset;\n    if(offset_return) *offset_return = offset;\n    return dirty;\n\n invalid:\n    releaseAtom(message);\n    if(etag) free(etag);\n    if(location) free(location);\n    if(via) releaseAtom(via);\n    /* fall through */\n\n fail:\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return -1;\n}\n\nvoid\ndirtyDiskEntry(ObjectPtr object)\n{\n    DiskCacheEntryPtr entry = object->disk_entry;\n    if(entry && entry != &negativeEntry) entry->metadataDirty = 1;\n}\n\nint\nrevalidateDiskEntry(ObjectPtr object)\n{\n    DiskCacheEntryPtr entry = object->disk_entry;\n    int rc;\n    int body_offset;\n\n    if(!entry || entry == &negativeEntry)\n        return 1;\n\n    CHECK_ENTRY(entry);\n    rc = entrySeek(entry, 0);\n    if(rc < 0) return 0;\n\n    rc = validateEntry(object, entry->fd, &body_offset, &entry->offset);\n    if(rc < 0) {\n        destroyDiskEntry(object, 0);\n        return 0;\n    }\n    if(body_offset != entry->body_offset) {\n        do_log(L_WARN, \"Inconsistent body offset (%d != %d).\\n\",\n               body_offset, entry->body_offset);\n        destroyDiskEntry(object, 0);\n        return 0;\n    }\n\n    entry->metadataDirty |= !!rc;\n    CHECK_ENTRY(entry);\n    return 1;\n}\n\nstatic DiskCacheEntryPtr\nmakeDiskEntry(ObjectPtr object, int create)\n{\n    DiskCacheEntryPtr entry = NULL;\n    char buf[1024];\n    int fd = -1;\n    int negative = 0, size = -1, name_len = -1;\n    char *name = NULL;\n    off_t offset = -1;\n    int body_offset = -1;\n    int rc;\n    int local = (object->flags & OBJECT_LOCAL) != 0;\n    int dirty = 0;\n\n   if(local && create)\n       return NULL;\n\n    if(!local && !(object->flags & OBJECT_PUBLIC))\n        return NULL;\n\n    if(maxDiskCacheEntrySize >= 0) {\n        if(object->length > 0) {\n            if(object->length > maxDiskCacheEntrySize)\n                return NULL;\n        } else {\n            if(object->size > maxDiskCacheEntrySize)\n                return NULL;\n        }\n    }\n\n    if(object->disk_entry) {\n        entry = object->disk_entry;\n        CHECK_ENTRY(entry);\n        if(entry != &negativeEntry) {\n            /* We'll keep the entry -- put it at the front. */\n            if(entry != diskEntries && entry != &negativeEntry) {\n                entry->previous->next = entry->next;\n                if(entry->next)\n                    entry->next->previous = entry->previous;\n                else\n                    diskEntriesLast = entry->previous;\n                entry->next = diskEntries;\n                diskEntries->previous = entry;\n                entry->previous = NULL;\n                diskEntries = entry;\n            }\n            return entry;\n        } else {\n            if(entry == &negativeEntry) {\n                negative = 1;\n                if(!create) return NULL;\n                object->disk_entry = NULL;\n            }\n            entry = NULL;\n            destroyDiskEntry(object, 0);\n        }\n    }\n\n    if(numDiskEntries > maxDiskEntries)\n        destroyDiskEntry(diskEntriesLast->object, 0);\n\n    if(!local) {\n        if(diskCacheRoot == NULL || diskCacheRoot->length <= 0)\n            return NULL;\n        name_len = urlFilename(buf, 1024, object->key, object->key_size);\n        if(name_len < 0) return NULL;\n        if(!negative)\n            fd = open(buf, O_RDWR | O_BINARY);\n        if(fd >= 0) {\n            rc = validateEntry(object, fd, &body_offset, &offset);\n            if(rc >= 0) {\n                dirty = rc;\n            } else {\n                close(fd);\n                fd = -1;\n                rc = unlink(buf);\n                if(rc < 0 && errno != ENOENT) {\n                    do_log_error(L_WARN,  errno,\n                                 \"Couldn't unlink stale disk entry %s\", \n                                 scrub(buf));\n                    /* But continue -- it's okay to have stale entries. */\n                }\n            }\n        }\n\n        if(fd < 0 && create && name_len > 0 && \n           !(object->flags & OBJECT_INITIAL)) {\n            fd = createFile(buf, diskCacheRoot->length);\n            if(fd < 0)\n                return NULL;\n\n            if(fd >= 0) {\n                char *data = NULL;\n                int dsize = 0;\n                if(object->numchunks > 0) {\n                    data = object->chunks[0].data;\n                    dsize = object->chunks[0].size;\n                }\n                rc = writeHeaders(fd, &body_offset, object, data, dsize);\n                if(rc < 0) {\n                    do_log_error(L_ERROR, errno, \"Couldn't write headers\");\n                    rc = unlink(buf);\n                    if(rc < 0 && errno != ENOENT)\n                        do_log_error(L_ERROR, errno,\n                                     \"Couldn't unlink truncated entry %s\", \n                                     scrub(buf));\n                    close(fd);\n                    return NULL;\n                }\n                assert(rc >= body_offset);\n                size = rc - body_offset;\n                offset = rc;\n                dirty = 0;\n            }\n        }\n    } else {\n        /* local */\n        if(localDocumentRoot == NULL || localDocumentRoot->length == 0)\n            return NULL;\n\n        name_len = \n            localFilename(buf, 1024, object->key, object->key_size);\n        if(name_len < 0)\n            return NULL;\n        fd = open(buf, O_RDONLY | O_BINARY);\n        if(fd >= 0) {\n            if(validateEntry(object, fd, &body_offset, NULL) < 0) {\n                close(fd);\n                fd = -1;\n            }\n        }\n        offset = 0;\n    }\n\n    if(fd < 0) {\n        object->disk_entry = &negativeEntry;\n        return NULL;\n    }\n    assert(body_offset >= 0);\n\n    name = strdup_n(buf, name_len);\n    if(name == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate name.\\n\");\n        close(fd);\n        fd = -1;\n        return NULL;\n    }\n\n    entry = malloc(sizeof(DiskCacheEntryRec));\n    if(entry == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate entry.\\n\");\n        free(name);\n        close(fd);\n        return NULL;\n    }\n\n    entry->filename = name;\n    entry->object = object;\n    entry->fd = fd;\n    entry->body_offset = body_offset;\n    entry->local = local;\n    entry->offset = offset;\n    entry->size = size;\n    entry->metadataDirty = dirty;\n\n    entry->next = diskEntries;\n    if(diskEntries)\n        diskEntries->previous = entry;\n    diskEntries = entry;\n    if(diskEntriesLast == NULL)\n        diskEntriesLast = entry;\n    entry->previous = NULL;\n    numDiskEntries++;\n\n    object->disk_entry = entry;\n\n    CHECK_ENTRY(entry);\n    return entry;\n}\n\n/* Rewrite a disk cache entry, used when the body offset needs to change. */\nstatic int\nrewriteEntry(ObjectPtr object)\n{\n    int old_body_offset = object->disk_entry->body_offset;\n    int fd, rc, n;\n    DiskCacheEntryPtr entry;\n    char* buf;\n    int buf_is_chunk, bufsize;\n    int offset;\n\n    fd = dup(object->disk_entry->fd);\n    if(fd < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't duplicate file descriptor\");\n        return -1;\n    }\n\n    rc = destroyDiskEntry(object, 1);\n    if(rc < 0) {\n        close(fd);\n        return -1;\n    }\n    entry = makeDiskEntry(object, 1);\n    if(!entry) {\n        close(fd);\n        return -1;\n    }\n\n    offset = diskEntrySize(object);\n    if(offset < 0) {\n        close(fd);\n        return -1;\n    }\n\n    bufsize = CHUNK_SIZE;\n    buf_is_chunk = 1;\n    buf = maybe_get_chunk();\n    if(!buf) {\n        bufsize = 2048;\n        buf_is_chunk = 0;\n        buf = malloc(2048);\n        if(buf == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate buffer.\\n\");\n            close(fd);\n            return -1;\n        }\n    }\n\n    rc = lseek(fd, old_body_offset + offset, SEEK_SET);\n    if(rc < 0)\n        goto done;\n\n    while(1) {\n        CHECK_ENTRY(entry);\n        n = read(fd, buf, bufsize);\n        if(n < 0 && errno == EINTR)\n            continue;\n        if(n <= 0)\n            goto done;\n        rc = entrySeek(entry, entry->body_offset + offset);\n        if(rc < 0)\n            goto done;\n    write_again:\n        rc = write(entry->fd, buf, n);\n        if(rc >= 0) {\n            entry->offset += rc;\n            entry->size += rc;\n        } else if(errno == EINTR) {\n            goto write_again;\n        }\n        if(rc < n)\n            goto done;\n    }\n\n done:\n    CHECK_ENTRY(entry);\n    if(object->length >= 0 && entry->size == object->length)\n        object->flags |= OBJECT_DISK_ENTRY_COMPLETE;\n    close(fd);\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n    return 1;\n}\n            \nint\ndestroyDiskEntry(ObjectPtr object, int d)\n{\n    DiskCacheEntryPtr entry = object->disk_entry;\n    int rc, urc = 1;\n\n    assert(!entry || !entry->local || !d);\n\n    if(d && !entry)\n        entry = makeDiskEntry(object, 0);\n\n    CHECK_ENTRY(entry);\n\n    if(!entry || entry == &negativeEntry) {\n        return 1;\n    }\n\n    assert(entry->object == object);\n\n    if(maxDiskCacheEntrySize >= 0 && object->size > maxDiskCacheEntrySize) {\n        /* See writeoutToDisk */\n        d = 1;\n    }\n\n    if(d) {\n        entry->object->flags &= ~OBJECT_DISK_ENTRY_COMPLETE;\n        if(entry->filename) {\n            urc = unlink(entry->filename);\n            if(urc < 0)\n                do_log_error(L_WARN, errno, \n                             \"Couldn't unlink %s\", scrub(entry->filename));\n        }\n    } else {\n        if(entry && entry->metadataDirty)\n            writeoutMetadata(object);\n        makeDiskEntry(object, 0);\n        /* rewriteDiskEntry may change the disk entry */\n        entry = object->disk_entry;\n        if(entry == NULL || entry == &negativeEntry)\n            return 0;\n        if(diskCacheWriteoutOnClose > 0) {\n            reallyWriteoutToDisk(object, -1, diskCacheWriteoutOnClose);\n            entry = object->disk_entry;\n            if(entry == NULL || entry == &negativeEntry)\n                return 0;\n        }\n    }\n again:\n    rc = close(entry->fd);\n    if(rc < 0 && errno == EINTR)\n        goto again;\n\n    entry->fd = -1;\n\n    if(entry->filename)\n        free(entry->filename);\n    entry->filename = NULL;\n\n    if(entry->previous)\n        entry->previous->next = entry->next;\n    else\n        diskEntries = entry->next;\n    if(entry->next)\n        entry->next->previous = entry->previous;\n    else\n        diskEntriesLast = entry->previous;\n\n    numDiskEntries--;\n    assert(numDiskEntries >= 0);\n\n    free(entry);\n    object->disk_entry = NULL;\n    if(urc < 0)\n        return -1;\n    else\n        return 1;\n}\n\nObjectPtr \nobjectGetFromDisk(ObjectPtr object)\n{\n    DiskCacheEntryPtr entry = makeDiskEntry(object, 0);\n    if(!entry) return NULL;\n    return object;\n}\n\n\nint \nobjectFillFromDisk(ObjectPtr object, int offset, int chunks)\n{\n    DiskCacheEntryPtr entry;\n    int rc, result;\n    int i, j, k;\n    int complete;\n\n    if(object->type != OBJECT_HTTP)\n        return 0;\n\n    if(object->flags & OBJECT_LINEAR)\n        return 0;\n\n    if(object->length >= 0) {\n        chunks = MIN(chunks, \n                     (object->length - offset + CHUNK_SIZE - 1) / CHUNK_SIZE);\n    }\n\n    rc = objectSetChunks(object, offset / CHUNK_SIZE + chunks);\n    if(rc < 0)\n        return 0;\n\n    complete = 1;\n    if(object->flags & OBJECT_INITIAL) {\n        complete = 0;\n    } else if((object->length < 0 || object->size < object->length) &&\n              object->size < (offset / CHUNK_SIZE + chunks) * CHUNK_SIZE) {\n        complete = 0;\n    } else {\n        for(k = 0; k < chunks; k++) {\n            int s;\n            i = offset / CHUNK_SIZE + k;\n            s = MIN(CHUNK_SIZE, object->size - i * CHUNK_SIZE);\n            if(object->chunks[i].size < s) {\n                complete = 0;\n                break;\n            }\n        }\n    }\n\n    if(complete)\n        return 1;\n\n    /* This has the side-effect of revalidating the entry, which is\n       what makes HEAD requests work. */\n    entry = makeDiskEntry(object, 0);\n    if(!entry)\n        return 0;\n                \n    for(k = 0; k < chunks; k++) {\n        i = offset / CHUNK_SIZE + k;\n        if(!object->chunks[i].data)\n            object->chunks[i].data = get_chunk();\n        if(!object->chunks[i].data) {\n            chunks = k;\n            break;\n        }\n        lockChunk(object, i);\n    }\n\n    result = 0;\n\n    for(k = 0; k < chunks; k++) {\n        int o;\n        i = offset / CHUNK_SIZE + k;\n        j = object->chunks[i].size;\n        o = i * CHUNK_SIZE + j;\n\n        if(object->chunks[i].size == CHUNK_SIZE)\n            continue;\n\n        if(entry->size >= 0 && entry->size <= o)\n            break;\n\n        if(entry->offset != entry->body_offset + o) {\n            rc = entrySeek(entry, entry->body_offset + o);\n            if(rc < 0) {\n                result = 0;\n                break;\n            }\n        }\n\n        CHECK_ENTRY(entry);\n        again:\n        rc = read(entry->fd, object->chunks[i].data + j, CHUNK_SIZE - j);\n        if(rc < 0) {\n            if(errno == EINTR)\n                goto again;\n            entry->offset = -1;\n            do_log_error(L_ERROR, errno, \"Couldn't read\");\n            break;\n        }\n\n        entry->offset += rc;\n        object->chunks[i].size += rc;\n        if(object->size < o + rc)\n            object->size = o + rc;\n\n        if(entry->object->length >= 0 && entry->size < 0 &&\n           entry->offset - entry->body_offset == entry->object->length)\n            entry->size = entry->object->length;\n            \n        if(rc < CHUNK_SIZE - j) {\n            /* Paranoia: the read may have been interrupted half-way. */\n            if(entry->size < 0) {\n                if(rc == 0 ||\n                   (entry->object->length >= 0 &&\n                    entry->object->length == \n                    entry->offset - entry->body_offset))\n                    entry->size = entry->offset - entry->body_offset;\n                break;\n            } else if(entry->size != entry->offset - entry->body_offset) {\n                if(rc == 0 || \n                   entry->size < entry->offset - entry->body_offset) {\n                    do_log(L_WARN,\n                           \"Disk entry size changed behind our back: \"\n                           \"%ld -> %ld (%d).\\n\",\n                           (long)entry->size,\n                           (long)entry->offset - entry->body_offset,\n                           object->size);\n                    entry->size = -1;\n                }\n            }\n            break;\n        }\n\n        CHECK_ENTRY(entry);\n        result = 1;\n    }\n\n    CHECK_ENTRY(object->disk_entry);\n    for(k = 0; k < chunks; k++) {\n        i = offset / CHUNK_SIZE + k;\n        unlockChunk(object, i);\n    }\n\n    if(result > 0) {\n        notifyObject(object);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint \nwriteoutToDisk(ObjectPtr object, int upto, int max)\n{\n    if(maxDiskCacheEntrySize >= 0 && object->size > maxDiskCacheEntrySize) {\n        /* An object was created with an unknown length, and then grew\n           beyond maxDiskCacheEntrySize.  Destroy the disk entry. */\n        destroyDiskEntry(object, 1);\n        return 0;\n    }\n\n    return reallyWriteoutToDisk(object, upto, max);\n}\n        \nstatic int \nreallyWriteoutToDisk(ObjectPtr object, int upto, int max)\n{\n    DiskCacheEntryPtr entry;\n    int rc;\n    int i, j;\n    int offset;\n    int bytes = 0;\n\n    if(upto < 0)\n        upto = object->size;\n\n    if((object->cache_control & CACHE_NO_STORE) || \n       (object->flags & OBJECT_LOCAL))\n        return 0;\n\n    if((object->flags & OBJECT_DISK_ENTRY_COMPLETE) && !object->disk_entry)\n        return 0;\n\n    entry = makeDiskEntry(object, 1);\n    if(!entry) return 0;\n\n    assert(!entry->local);\n\n    if(object->flags & OBJECT_DISK_ENTRY_COMPLETE)\n        goto done;\n\n    diskEntrySize(object);\n    if(entry->size < 0)\n        return 0;\n\n    if(object->length >= 0 && entry->size >= object->length) {\n        object->flags |= OBJECT_DISK_ENTRY_COMPLETE;\n        goto done;\n    }\n\n    if(entry->size >= upto)\n        goto done;\n\n    offset = entry->size;\n\n    /* Avoid a seek in case we start writing at the beginning */\n    if(offset == 0 && entry->metadataDirty) {\n        writeoutMetadata(object);\n        /* rewriteDiskEntry may change the entry */\n        entry = makeDiskEntry(object, 0);\n        if(entry == NULL)\n            return 0;\n    }\n\n    rc = entrySeek(entry, offset + entry->body_offset);\n    if(rc < 0) return 0;\n\n    do {\n        if(max >= 0 && bytes >= max)\n            break;\n        CHECK_ENTRY(entry);\n        assert(entry->offset == offset + entry->body_offset);\n        i = offset / CHUNK_SIZE;\n        j = offset % CHUNK_SIZE;\n        if(i >= object->numchunks)\n            break;\n        if(object->chunks[i].size <= j)\n            break;\n    again:\n        rc = write(entry->fd, object->chunks[i].data + j,\n                   object->chunks[i].size - j);\n        if(rc < 0) {\n            if(errno == EINTR)\n                goto again;\n            do_log_error(L_ERROR, errno, \"Couldn't write disk entry\");\n            break;\n        }\n        entry->offset += rc;\n        offset += rc;\n        bytes += rc;\n        if(entry->size < offset)\n            entry->size = offset;\n    } while(j + rc >= CHUNK_SIZE);\n\n done:\n    CHECK_ENTRY(entry);\n    if(entry->metadataDirty)\n        writeoutMetadata(object);\n\n    return bytes;\n}\n\nint \nwriteoutMetadata(ObjectPtr object)\n{\n    DiskCacheEntryPtr entry;\n    int rc;\n\n    if((object->cache_control & CACHE_NO_STORE) || \n       (object->flags & OBJECT_LOCAL))\n        return 0;\n    \n    entry = makeDiskEntry(object, 0);\n    if(entry == NULL || entry == &negativeEntry)\n        goto fail;\n\n    assert(!entry->local);\n\n    rc = entrySeek(entry, 0);\n    if(rc < 0) goto fail;\n\n    rc = writeHeaders(entry->fd, &entry->body_offset, object, NULL, 0);\n    if(rc == -2) {\n        rc = rewriteEntry(object);\n        if(rc < 0) return 0;\n        return 1;\n    }\n    if(rc < 0) goto fail;\n    entry->offset = rc;\n    entry->metadataDirty = 0;\n    return 1;\n\n fail:\n    /* We need this in order to avoid trying to write this entry out\n       multiple times. */\n    if(entry && entry != &negativeEntry)\n        entry->metadataDirty = 0;\n    return 0;\n}\n\nstatic void\nmergeDobjects(DiskObjectPtr dst, DiskObjectPtr src)\n{\n    if(dst->filename == NULL) {\n        dst->filename = src->filename;\n        dst->body_offset = src->body_offset;\n    } else\n        free(src->filename);\n    free(src->location);\n    if(dst->length < 0)\n        dst->length = src->length;\n    if(dst->size < 0)\n        dst->size = src->size;\n    if(dst->age < 0)\n        dst->age = src->age;\n    if(dst->date < 0)\n        dst->date = src->date;\n    if(dst->last_modified < 0)\n        dst->last_modified = src->last_modified;\n    free(src);\n}\n\nDiskObjectPtr\nreadDiskObject(char *filename, struct stat *sb)\n{\n    int fd, rc, n, dummy, code;\n    int length, size;\n    time_t date, last_modified, age, atime, expires;\n    char *location = NULL, *fn = NULL;\n    DiskObjectPtr dobject;\n    char *buf;\n    int buf_is_chunk, bufsize;\n    int body_offset;\n    struct stat ss;\n\n    fd = -1;\n\n    if(sb == NULL) {\n        rc = stat(filename, &ss);\n        if(rc < 0) {\n            do_log_error(L_WARN, errno, \"Couldn't stat %s\", scrub(filename));\n            return NULL;\n        }\n        sb = &ss;\n    }\n\n    buf_is_chunk = 1;\n    bufsize = CHUNK_SIZE;\n    buf = get_chunk();\n    if(buf == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate buffer.\\n\");\n        return NULL;\n    }\n\n    if(S_ISREG(sb->st_mode)) {\n        fd = open(filename, O_RDONLY | O_BINARY);\n        if(fd < 0)\n            goto fail;\n    again:\n        rc = read(fd, buf, bufsize);\n        if(rc < 0)\n            goto fail;\n        \n        n = findEndOfHeaders(buf, 0, rc, &dummy);\n        if(n < 0) {\n            long lrc;\n            if(buf_is_chunk) {\n                dispose_chunk(buf);\n                buf_is_chunk = 0;\n                bufsize = bigBufferSize;\n                buf = malloc(bigBufferSize);\n                if(buf == NULL)\n                    goto fail2;\n                lrc = lseek(fd, 0, SEEK_SET);\n                if(lrc < 0)\n                    goto fail;\n                goto again;\n            }\n            goto fail;\n        }\n        \n        rc = httpParseServerFirstLine(buf, &code, &dummy, NULL);\n        if(rc < 0)\n            goto fail;\n\n        rc = httpParseHeaders(0, NULL, buf, rc, NULL,\n                              NULL, &length, NULL, NULL, NULL, \n                              &date, &last_modified, &expires, &age,\n                              &atime, &body_offset, NULL,\n                              NULL, NULL, NULL, NULL, &location, NULL, NULL);\n        if(rc < 0 || location == NULL)\n            goto fail;\n        if(body_offset < 0)\n            body_offset = n;\n    \n        size = sb->st_size - body_offset;\n        if(size < 0)\n            size = 0;\n    } else if(S_ISDIR(sb->st_mode)) {\n        char *n;\n        n = dirnameUrl(buf, 512, (char*)filename, strlen(filename));\n        if(n == NULL)\n            goto fail;\n        location = strdup(n);\n        if(location == NULL)\n            goto fail;\n        length = -1;\n        size = -1;\n        body_offset = -1;\n        age = -1;\n        atime = -1;\n        date = -1;\n        last_modified = -1;\n        expires = -1;\n    } else {\n        goto fail;\n    }\n\n    dobject = malloc(sizeof(DiskObjectRec));\n    if(!dobject)\n        goto fail;\n    \n    fn = strdup(filename);\n    if(!fn)\n        goto fail;\n\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n\n    dobject->location = location;\n    dobject->filename = fn;\n    dobject->length = length;\n    dobject->body_offset = body_offset;\n    dobject->size = size;\n    dobject->age = age;\n    dobject->access = atime;\n    dobject->date = date;\n    dobject->last_modified = last_modified;\n    dobject->expires = expires;\n    if(fd >= 0) close(fd);\n    return dobject;\n\n fail:\n    if(buf_is_chunk)\n        dispose_chunk(buf);\n    else\n        free(buf);\n fail2:\n    if(fd >= 0) close(fd);\n    if(location) free(location);\n    return NULL;\n}    \n    \n\nDiskObjectPtr\nprocessObject(DiskObjectPtr dobjects, char *filename, struct stat *sb)\n{\n    DiskObjectPtr dobject = NULL;\n    int c = 0;\n\n    dobject = readDiskObject((char*)filename, sb);\n    if(dobject == NULL)\n        return dobjects;\n\n    if(!dobjects ||\n       (c = strcmp(dobject->location, dobjects->location)) <= 0) {\n        if(dobjects && c == 0) {\n            mergeDobjects(dobjects, dobject);\n        } else {\n            dobject->next = dobjects;\n            dobjects = dobject;\n        }\n    } else {\n        DiskObjectPtr other = dobjects;\n        while(other->next) {\n            c = strcmp(dobject->location, other->next->location);\n            if(c < 0)\n                break;\n            other = other->next;\n        }\n        if(strcmp(dobject->location, other->location) == 0) {\n            mergeDobjects(other, dobject);\n        } else {\n            dobject->next = other->next;\n            other->next = dobject;\n        }\n    }\n    return dobjects;\n}\n\n/* Determine whether p is below root */\nstatic int\nfilter(DiskObjectPtr p, const char *root, int n, int recursive)\n{\n    char *cp;\n    int m = strlen(p->location);\n    if(m < n)\n        return 0;\n    if(memcmp(root, p->location, n) != 0)\n        return 0;\n    if(recursive)\n        return 1;\n    if(m == 0 || p->location[m - 1] == '/')\n        return 1;\n    cp = strchr(p->location + n, '/');\n    if(cp && cp - p->location != m - 1)\n        return 0;\n    return 1;\n}\n\n/* Filter out all disk objects that are not under root */\nDiskObjectPtr\nfilterDiskObjects(DiskObjectPtr from, const char *root, int recursive)\n{\n    int n = strlen(root);\n    DiskObjectPtr p, q;\n\n    while(from && !filter(from, root, n, recursive)) {\n        p = from;\n        from = p->next;\n        free(p->location);\n        free(p);\n    }\n\n    p = from;\n    while(p && p->next) {\n        if(!filter(p->next, root, n, recursive)) {\n            q = p->next;\n            p->next = q->next;\n            free(q->location);\n            free(q);\n        } else {\n            p = p->next;\n        }\n    }\n    return from;\n}\n\nDiskObjectPtr\ninsertRoot(DiskObjectPtr from, const char *root)\n{\n    DiskObjectPtr p;\n\n    p = from;\n    while(p) {\n        if(strcmp(root, p->location) == 0)\n            return from;\n        p = p->next;\n    }\n\n    p = malloc(sizeof(DiskObjectRec));\n    if(!p) return from;\n    p->location = strdup(root);\n    if(p->location == NULL) {\n        free(p);\n        return from;\n    }\n    p->filename = NULL;\n    p->length = -1;\n    p->size = -1;\n    p->age = -1;\n    p->access = -1;\n    p->last_modified = -1;\n    p->expires = -1;\n    p->next = from;\n    return p;\n}\n\n/* Insert all missing directories in a sorted list of dobjects */\nDiskObjectPtr\ninsertDirs(DiskObjectPtr from)\n{\n    DiskObjectPtr p, q, new;\n    int n, m;\n    char *cp;\n\n    p = NULL; q = from;\n    while(q) {\n        n = strlen(q->location);\n        if(n > 0 && q->location[n - 1] != '/') {\n            cp = strrchr(q->location, '/');\n            m = cp - q->location + 1;\n            if(cp && (!p || strlen(p->location) < m ||\n                      memcmp(p->location, q->location, m) != 0)) {\n                new = malloc(sizeof(DiskObjectRec));\n                if(!new) break;\n                new->location = strdup_n(q->location, m);\n                if(new->location == NULL) {\n                    free(new);\n                    break;\n                }\n                new->filename = NULL;\n                new->length = -1;\n                new->size = -1;\n                new->age = -1;\n                new->access = -1;\n                new->last_modified = -1;\n                new->expires = -1;\n                new->next = q;\n                if(p)\n                    p->next = new;\n                else\n                    from = new;\n            }\n        }\n        p = q;\n        q = q->next;\n    }\n    return from;\n}\n        \nvoid\nindexDiskObjects(FILE *out, const char *root, int recursive)\n{\n    int n, i, isdir;\n    DIR *dir;\n    struct dirent *dirent;\n    char buf[1024];\n    char *fts_argv[2];\n    FTS *fts;\n    FTSENT *fe;\n    DiskObjectPtr dobjects = NULL;\n    char *of = root[0] == '\\0' ? \"\" : \" of \";\n\n    fprintf(out, \"<!DOCTYPE HTML PUBLIC \"\n            \"\\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n            \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n            \"<html><head>\\n\"\n            \"<title>%s%s%s</title>\\n\"\n            \"</head><body>\\n\"\n            \"<h1>%s%s%s</h1>\\n\",\n            recursive ? \"Recursive index\" : \"Index\", of, root,\n            recursive ? \"Recursive index\" : \"Index\", of, root);\n\n    if(diskCacheRoot == NULL || diskCacheRoot->length <= 0) {\n        fprintf(out, \"<p>No <tt>diskCacheRoot</tt>.</p>\\n\");\n        goto trailer;\n    }\n\n    if(diskCacheRoot->length >= 1024) {\n        fprintf(out,\n                \"<p>The value of <tt>diskCacheRoot</tt> is \"\n                \"too long (%d).</p>\\n\",\n                diskCacheRoot->length);\n        goto trailer;\n    }\n\n    if(strlen(root) < 8) {\n        memcpy(buf, diskCacheRoot->string, diskCacheRoot->length);\n        buf[diskCacheRoot->length] = '\\0';\n        n = diskCacheRoot->length;\n    } else {\n        n = urlDirname(buf, 1024, root, strlen(root));\n    }\n    if(n > 0) {\n        if(recursive) {\n            dir = NULL;\n            fts_argv[0] = buf;\n            fts_argv[1] = NULL;\n            fts = fts_open(fts_argv, FTS_LOGICAL, NULL);\n            if(fts) {\n                while(1) {\n                    fe = fts_read(fts);\n                    if(!fe) break;\n                    if(fe->fts_info != FTS_DP)\n                        dobjects =\n                            processObject(dobjects,\n                                          fe->fts_path,\n                                          fe->fts_info == FTS_NS ||\n                                          fe->fts_info == FTS_NSOK ?\n                                          fe->fts_statp : NULL);\n                }\n                fts_close(fts);\n            }\n        } else {\n            dir = opendir(buf);\n            if(dir) {\n                while(1) {\n                    dirent = readdir(dir);\n                    if(!dirent) break;\n                    if(n + strlen(dirent->d_name) < 1024) {\n                        strcpy(buf + n, dirent->d_name);\n                    } else {\n                        continue;\n                    }\n                    dobjects = processObject(dobjects, buf, NULL);\n                }\n                closedir(dir);\n            } else {\n                fprintf(out, \"<p>Couldn't open directory: %s (%d).</p>\\n\",\n                        strerror(errno), errno);\n                goto trailer;\n            }\n        }\n    }\n\n    if(dobjects) {\n        int entryno;\n        dobjects = insertRoot(dobjects, root);\n        dobjects = insertDirs(dobjects);\n        dobjects = filterDiskObjects(dobjects, root, recursive);\n        buf[0] = '\\0';\n        alternatingHttpStyle(out, \"diskcachelist\");\n        fprintf(out, \"<table id=diskcachelist>\\n\");\n        fprintf(out, \"<tbody>\\n\");\n        entryno = 0;\n        while(dobjects) {\n            DiskObjectPtr dobject = dobjects;\n            i = strlen(dobject->location);\n            isdir = (i == 0 || dobject->location[i - 1] == '/');\n            if(entryno % 2)\n                fprintf(out, \"<tr class=odd>\");\n            else\n                fprintf(out, \"<tr class=even>\");\n            if(dobject->size >= 0) {\n                fprintf(out, \"<td><a href=\\\"%s\\\"><tt>\",\n                        dobject->location);\n                htmlPrint(out,\n                          dobject->location, strlen(dobject->location));\n                fprintf(out, \"</tt></a></td> \");\n                if(dobject->length >= 0) {\n                    if(dobject->size == dobject->length)\n                        fprintf(out, \"<td>%d</td> \", dobject->length);\n                    else\n                        fprintf(out, \"<td>%d/%d</td> \",\n                               dobject->size, dobject->length);\n                } else {\n                    /* Avoid a trigraph. */\n                    fprintf(out, \"<td>%d/<em>??\" \"?</em></td> \", dobject->size);\n                }\n                if(dobject->last_modified >= 0) {\n                    struct tm *tm = gmtime(&dobject->last_modified);\n                    if(tm == NULL)\n                        n = -1;\n                    else\n                        n = strftime(buf, 1024, \"%d.%m.%Y\", tm);\n                } else\n                    n = -1;\n                if(n > 0) {\n                    buf[n] = '\\0';\n                    fprintf(out, \"<td>%s</td> \", buf);\n                } else {\n                    fprintf(out, \"<td></td>\");\n                }\n                \n                if(dobject->date >= 0) {\n                    struct tm *tm = gmtime(&dobject->date);\n                    if(tm == NULL)\n                        n = -1;\n                    else\n                        n = strftime(buf, 1024, \"%d.%m.%Y\", tm);\n                } else\n                    n = -1;\n                if(n > 0) {\n                    buf[n] = '\\0';\n                    fprintf(out, \"<td>%s</td>\", buf);\n                } else {\n                    fprintf(out, \"<td></td>\");\n                }\n            } else {\n                fprintf(out, \"<td><tt>\");\n                htmlPrint(out, dobject->location,\n                          strlen(dobject->location));\n                fprintf(out, \"</tt></td><td></td><td></td><td></td>\");\n            }\n            if(isdir) {\n                fprintf(out, \"<td><a href=\\\"/polipo/index?%s\\\">plain</a></td>\"\n                        \"<td><a href=\\\"/polipo/recursive-index?%s\\\">\"\n                        \"recursive</a></td>\",\n                        dobject->location, dobject->location);\n            }\n            fprintf(out, \"</tr>\\n\");\n            entryno++;\n            dobjects = dobject->next;\n            free(dobject->location);\n            free(dobject->filename);\n            free(dobject);\n        }\n        fprintf(out, \"</tbody>\\n\");\n        fprintf(out, \"</table>\\n\");\n    }\n\n trailer:\n    fprintf(out, \"<p><a href=\\\"/polipo/\\\">back</a></p>\\n\");\n    fprintf(out, \"</body></html>\\n\");\n    return;\n}\n\nstatic int\ncheckForZeroes(char *buf, int n)\n{\n    int i, j;\n    unsigned long *lbuf = (unsigned long *)buf;\n    assert(n % sizeof(unsigned long) == 0);\n\n    for(i = 0; i * sizeof(unsigned long) < n; i++) {\n        if(lbuf[i] != 0L)\n            return i * sizeof(unsigned long);\n    }\n    for(j = 0; i * sizeof(unsigned long) + j < n; j++) {\n        if(buf[i * sizeof(unsigned long) + j] != 0)\n            break;\n    }\n\n    return i * sizeof(unsigned long) + j;\n}\n\nstatic int\ncopyFile(int from, char *filename, int n)\n{\n    char *buf;\n    int to, offset, nread, nzeroes, rc;\n\n    buf = malloc(CHUNK_SIZE);\n    if(buf == NULL)\n        return -1;\n\n    to = open(filename, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n\t      diskCacheFilePermissions);\n    if(to < 0) {\n        free(buf);\n        return -1;\n    }\n\n    offset = 0;\n    while(offset < n) {\n        nread = read(from, buf, MIN(CHUNK_SIZE, n - offset));\n        if(nread <= 0)\n            break;\n        nzeroes = checkForZeroes(buf, nread & -8);\n        if(nzeroes > 0) {\n            /* I like holes */\n            rc = lseek(to, nzeroes, SEEK_CUR);\n            if(rc != offset + nzeroes) {\n                if(rc < 0)\n                    do_log_error(L_ERROR, errno, \"Couldn't extend file\");\n                else\n                    do_log(L_ERROR, \n                           \"Couldn't extend file: \"\n                           \"unexpected offset %d != %d + %d.\\n\",\n                           rc, offset, nread);\n                break;\n            }\n        }\n        if(nread > nzeroes) {\n            rc = write(to, buf + nzeroes, nread - nzeroes);\n            if(rc != nread - nzeroes) {\n                if(rc < 0)\n                    do_log_error(L_ERROR, errno, \"Couldn't write\");\n                else\n                    do_log(L_ERROR, \"Short write.\\n\");\n                break;\n            }\n        }\n        offset += nread;\n    }\n    free(buf);\n    close(to);\n    if(offset <= 0)\n        unlink(filename);       /* something went wrong straight away */\n    return 1;\n}\n\nstatic long int\nexpireFile(char *filename, struct stat *sb,\n           int *considered, int *unlinked, int *truncated)\n{\n    DiskObjectPtr dobject = NULL;\n    time_t t;\n    int fd, rc;\n    long int ret = sb->st_size;\n\n    if(!preciseExpiry) {\n        t = sb->st_mtime;\n        if(t > current_time.tv_sec + 1) {\n            do_log(L_WARN, \"File %s has access time in the future.\\n\",\n                   filename);\n            t = current_time.tv_sec;\n        }\n        \n        if(t > current_time.tv_sec - diskCacheUnlinkTime &&\n           (sb->st_size < diskCacheTruncateSize ||\n            t > current_time.tv_sec - diskCacheTruncateTime))\n            return ret;\n    }\n    \n    (*considered)++;\n\n    dobject = readDiskObject(filename, sb);\n    if(!dobject) {\n        do_log(L_ERROR, \"Incorrect disk entry %s -- removing.\\n\",\n               scrub(filename));\n        rc = unlink(filename);\n        if(rc < 0) {\n            do_log_error(L_ERROR, errno,\n                         \"Couldn't unlink %s\", scrub(filename));\n            return ret;\n        } else {\n            (*unlinked)++;\n            return 0;\n        }\n    }\n    \n    t = dobject->access;\n    if(t < 0) t = dobject->age;\n    if(t < 0) t = dobject->date;\n    \n    if(t > current_time.tv_sec)\n        do_log(L_WARN, \n               \"Disk entry %s (%s) has access time in the future.\\n\",\n               scrub(dobject->location), scrub(dobject->filename));\n    \n    if(t < current_time.tv_sec - diskCacheUnlinkTime) {\n        rc = unlink(dobject->filename);\n        if(rc < 0) {\n            do_log_error(L_ERROR, errno, \"Couldn't unlink %s\",\n                         scrub(filename));\n        } else {\n            (*unlinked)++;\n            ret = 0;\n        }\n    } else if(dobject->size > \n              diskCacheTruncateSize + 4 * dobject->body_offset && \n              t < current_time.tv_sec - diskCacheTruncateTime) {\n        /* We need to copy rather than simply truncate in place: the\n           latter would confuse a running polipo. */\n        fd = open(dobject->filename, O_RDONLY | O_BINARY, 0);\n        rc = unlink(dobject->filename);\n        if(rc < 0) {\n            do_log_error(L_ERROR, errno, \"Couldn't unlink %s\",\n                         scrub(filename));\n            close(fd);\n            fd = -1;\n        } else {\n            (*unlinked)++;\n            copyFile(fd, dobject->filename,\n                     dobject->body_offset + diskCacheTruncateSize);\n            close(fd);\n            (*unlinked)--;\n            (*truncated)++;\n            ret = sb->st_size - dobject->body_offset + diskCacheTruncateSize;\n        }\n    }\n    free(dobject->location);\n    free(dobject->filename);\n    free(dobject);\n    return ret;\n}\n    \nvoid\nexpireDiskObjects()\n{\n    int rc;\n    char *fts_argv[2];\n    FTS *fts;\n    FTSENT *fe;\n    int files = 0, considered = 0, unlinked = 0, truncated = 0;\n    int dirs = 0, rmdirs = 0;\n    long left = 0, total = 0;\n\n    if(diskCacheRoot == NULL || \n       diskCacheRoot->length <= 0 || diskCacheRoot->string[0] != '/')\n        return;\n\n    fts_argv[0] = diskCacheRoot->string;\n    fts_argv[1] = NULL;\n    fts = fts_open(fts_argv, FTS_LOGICAL, NULL);\n    if(fts == NULL) {\n        do_log_error(L_ERROR, errno, \"Couldn't fts_open disk cache\");\n    } else {\n        while(1) {\n            gettimeofday(&current_time, NULL);\n\n            fe = fts_read(fts);\n            if(!fe) break;\n\n            if(fe->fts_info == FTS_D)\n                continue;\n\n            if(fe->fts_info == FTS_DP || fe->fts_info == FTS_DC ||\n               fe->fts_info == FTS_DNR) {\n                if(fe->fts_accpath[0] == '/' &&\n                   strlen(fe->fts_accpath) <= diskCacheRoot->length)\n                    continue;\n                dirs++;\n                rc = rmdir(fe->fts_accpath);\n                if(rc >= 0)\n                    rmdirs++;\n                else if(errno != ENOTEMPTY && errno != EEXIST)\n                    do_log_error(L_ERROR, errno,\n                                 \"Couldn't remove directory %s\",\n                                 scrub(fe->fts_accpath));\n                continue;\n            } else if(fe->fts_info == FTS_NS) {\n                do_log_error(L_ERROR, fe->fts_errno, \"Couldn't stat file %s\",\n                             scrub(fe->fts_accpath));\n                continue;\n            } else if(fe->fts_info == FTS_ERR) {\n                do_log_error(L_ERROR, fe->fts_errno,\n                             \"Couldn't fts_read disk cache\");\n                break;\n            }\n\n            if(!S_ISREG(fe->fts_statp->st_mode)) {\n                do_log(L_ERROR, \"Unexpected file %s type 0%o.\\n\", \n                       fe->fts_accpath, (unsigned int)fe->fts_statp->st_mode);\n                continue;\n            }\n\n            files++;\n            left += expireFile(fe->fts_accpath, fe->fts_statp,\n                               &considered, &unlinked, &truncated);\n            total += fe->fts_statp->st_size;\n        }\n        fts_close(fts);\n    }\n\n    printf(\"Disk cache purged.\\n\");\n    printf(\"%d files, %d considered, %d removed, %d truncated \"\n           \"(%ldkB -> %ldkB).\\n\",\n           files, considered, unlinked, truncated, total/1024, left/1024);\n    printf(\"%d directories, %d removed.\\n\", dirs, rmdirs);\n    return;\n}\n\n#else\n\nvoid\npreinitDiskcache()\n{\n    return;\n}\n\nvoid\ninitDiskcache()\n{\n    return;\n}\n\nint\nwriteoutToDisk(ObjectPtr object, int upto, int max)\n{\n    return 0;\n}\n\nint\ndestroyDiskEntry(ObjectPtr object, int d)\n{\n    return 0;\n}\n\nObjectPtr\nobjectGetFromDisk(ObjectPtr object)\n{\n    return NULL;\n}\n\nint\nobjectFillFromDisk(ObjectPtr object, int offset, int chunks)\n{\n    return 0;\n}\n\nint\nrevalidateDiskEntry(ObjectPtr object)\n{\n    return 0;\n}\n\nvoid\ndirtyDiskEntry(ObjectPtr object)\n{\n    return;\n}\n\nvoid\nexpireDiskObjects()\n{\n    do_log(L_ERROR, \"Disk cache not supported in this version.\\n\");\n}\n\nint\ndiskEntrySize(ObjectPtr object)\n{\n    return -1;\n}\n#endif\n"
        },
        {
          "name": "diskcache.h",
          "type": "blob",
          "size": 2.32421875,
          "content": "/*\nCopyright (c) 2003-2010 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nextern int maxDiskEntries;\n\nextern AtomPtr diskCacheRoot;\nextern AtomPtr additionalDiskCacheRoot;\n\ntypedef struct _DiskCacheEntry {\n    char *filename;\n    ObjectPtr object;\n    int fd;\n    off_t offset;\n    off_t size;\n    int body_offset;\n    short local;\n    short metadataDirty;\n    struct _DiskCacheEntry *next;\n    struct _DiskCacheEntry *previous;\n} *DiskCacheEntryPtr, DiskCacheEntryRec;\n\ntypedef struct _DiskObject {\n    char *location;\n    char *filename;\n    int body_offset;\n    int length;\n    int size;\n    time_t age;\n    time_t access;\n    time_t date;\n    time_t last_modified;\n    time_t expires;\n    struct _DiskObject *next;\n} DiskObjectRec, *DiskObjectPtr;\n\nstruct stat;\n\nextern int maxDiskCacheEntrySize;\n\nvoid preinitDiskcache(void);\nvoid initDiskcache(void);\nint destroyDiskEntry(ObjectPtr object, int);\nint diskEntrySize(ObjectPtr object);\nObjectPtr objectGetFromDisk(ObjectPtr);\nint objectFillFromDisk(ObjectPtr object, int offset, int chunks);\nint writeoutMetadata(ObjectPtr object);\nint writeoutToDisk(ObjectPtr object, int upto, int max);\nvoid dirtyDiskEntry(ObjectPtr object);\nint revalidateDiskEntry(ObjectPtr object);\nDiskObjectPtr readDiskObject(char *filename, struct stat *sb);\nvoid indexDiskObjects(FILE *out, const char *root, int r);\nvoid expireDiskObjects(void);\n"
        },
        {
          "name": "dns.c",
          "type": "blob",
          "size": 49.947265625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifndef NO_STANDARD_RESOLVER\n#ifndef NO_FANCY_RESOLVER\nint dnsUseGethostbyname = 1;\n#else \nconst int dnsUseGethostbyname = 3;\n#endif\n#else\n#ifndef NO_FANCY_RESOLVER\nconst int dnsUseGethostbyname = 0;\n#else\n#error use no resolver at all?\n#endif\n#endif\n\n#ifndef NO_FANCY_RESOLVER\nAtomPtr dnsNameServer = NULL;\nint dnsMaxTimeout = 60;\nint dnsNameServerPort = 53;\n#endif\n\n#ifndef NO_STANDARD_RESOLVER\nint dnsGethostbynameTtl = 1200;\n#endif\n\nint dnsNegativeTtl = 120;\n\n#ifdef HAVE_IPv6\nint dnsQueryIPv6 = 2;\n#else\nconst int dnsQueryIPv6 = 0;\n#endif\n\ntypedef struct _DnsQuery {\n    unsigned id;\n    AtomPtr name;\n    ObjectPtr object;\n    AtomPtr inet4, inet6;\n    time_t ttl4, ttl6;\n    time_t time;\n    int timeout;\n    TimeEventHandlerPtr timeout_handler;\n    struct _DnsQuery *next;\n} DnsQueryRec, *DnsQueryPtr;\n\nunion {\n    struct sockaddr sa;\n    struct sockaddr_in sin;\n#ifdef HAVE_IPv6\n    struct sockaddr_in6 sin6;\n#endif\n} nameserverAddress_storage;\n\n#ifndef NO_FANCY_RESOLVER\nstatic AtomPtr atomLocalhost, atomLocalhostDot;\n\n#define nameserverAddress nameserverAddress_storage.sa\n\nstatic DnsQueryPtr inFlightDnsQueries;\nstatic DnsQueryPtr inFlightDnsQueriesLast;\n#endif\n\nstatic int really_do_gethostbyname(AtomPtr name, ObjectPtr object);\nstatic int really_do_dns(AtomPtr name, ObjectPtr object);\n\n#ifndef NO_FANCY_RESOLVER\nstatic int stringToLabels(char *buf, int offset, int n, char *string);\nstatic int labelsToString(char *buf, int offset, int n, char *d, \n                          int m, int *j_return);\nstatic int dnsBuildQuery(int id, char *buf, int offset, int n,\n                         AtomPtr name, int af);\nstatic int dnsReplyHandler(int abort, FdEventHandlerPtr event);\nstatic int dnsReplyId(char *buf, int offset, int n, int *id_return);\nstatic int dnsDecodeReply(char *buf, int offset, int n,\n                          int *id_return,\n                          AtomPtr *name_return, AtomPtr *value_return,\n                          int *af_return, unsigned *ttl_return);\nstatic int dnsHandler(int status, ConditionHandlerPtr chandler);\nstatic int dnsGethostbynameFallback(int id, AtomPtr message);\nstatic int sendQuery(DnsQueryPtr query);\n\nstatic int idSeed;\n#endif\n\n#if !defined(NO_FANCY_RESOLVER) && !defined(WIN32)\nstatic int\nparseResolvConf(char *filename)\n{\n    FILE *f;\n    char buf[512];\n    char *p, *q;\n    int n;\n    AtomPtr nameserver = NULL;\n\n    f = fopen(filename, \"r\");\n    if(f == NULL) {\n        do_log_error(L_ERROR, errno, \"DNS: couldn't open %s\", filename);\n        return 0;\n    }\n\n    while(1) {\n        p = fgets(buf, 512, f);\n        if(p == NULL)\n            break;\n\n        n = strlen(buf);\n        if(buf[n - 1] != '\\n') {\n            int c;\n            do_log(L_WARN, \"DNS: overly long line in %s -- skipping.\\n\",\n                   filename);\n            do {\n                c = fgetc(f);\n                if(c == EOF)\n                    break;\n            } while(c != '\\n');\n            if(c == EOF)\n                break;\n        }\n        \n        while(*p == ' ' || *p == '\\t')\n            p++;\n        if(strcasecmp_n(\"nameserver\", p, 10) != 0)\n            continue;\n        p += 10;\n        while(*p == ' ' || *p == '\\t')\n            p++;\n        q = p;\n        while(*q == '.' || *q == ':' || digit(*q) || letter(*q))\n            q++;\n        if(*q != ' ' && *q != '\\t' && *q != '\\r' && *q != '\\n') {\n            do_log(L_WARN, \"DNS: couldn't parse line in %s -- skipping.\\n\",\n                   filename);\n            continue;\n        }\n        nameserver = internAtomLowerN(p, q - p);\n        break;\n    }\n\n    fclose(f);\n    if(nameserver) {\n        dnsNameServer = nameserver;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n#endif\n\nvoid\npreinitDns()\n{\n#ifdef HAVE_IPv6\n    int fd;\n#endif\n\n    assert(sizeof(struct in_addr) == 4);\n#ifdef HAVE_IPv6\n    assert(sizeof(struct in6_addr) == 16);\n#endif\n\n#ifndef NO_STANDARD_RESOLVER\n    CONFIG_VARIABLE(dnsGethostbynameTtl, CONFIG_TIME,\n                    \"TTL for gethostbyname addresses.\");\n#endif\n\n#ifdef HAVE_IPv6\n    fd = socket(PF_INET6, SOCK_STREAM, 0);\n    if(fd < 0) {\n        if(errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {\n            dnsQueryIPv6 = 0;\n        } else {\n            do_log_error(L_WARN, errno, \"DNS: couldn't create socket\");\n        }\n    } else {\n        close(fd);\n    }\n#endif\n\n#ifndef NO_FANCY_RESOLVER\n#ifndef WIN32\n    parseResolvConf(\"/etc/resolv.conf\");\n#endif\n    if(dnsNameServer == NULL || dnsNameServer->string[0] == '\\0')\n        dnsNameServer = internAtom(\"127.0.0.1\");\n    CONFIG_VARIABLE(dnsMaxTimeout, CONFIG_TIME,\n                    \"Max timeout for DNS queries.\");\n    CONFIG_VARIABLE(dnsNegativeTtl, CONFIG_TIME,\n                    \"TTL for negative DNS replies with no TTL.\");\n    CONFIG_VARIABLE(dnsNameServer, CONFIG_ATOM_LOWER,\n                    \"The name server to use.\");\n    CONFIG_VARIABLE(dnsNameServerPort, CONFIG_INT,\n                    \"The name server port to use.\");\n#ifndef NO_STANDARD_RESOLVER\n    CONFIG_VARIABLE(dnsUseGethostbyname, CONFIG_TETRASTATE,\n                    \"Use the system resolver.\");\n#endif\n#endif\n\n#ifdef HAVE_IPv6\n    CONFIG_VARIABLE(dnsQueryIPv6, CONFIG_TETRASTATE,\n                    \"Query for IPv6 addresses.\");\n#endif\n}\n\nvoid\ninitDns()\n{\n#ifndef NO_FANCY_RESOLVER\n    int rc;\n    struct timeval t;\n    struct sockaddr_in *sin = (struct sockaddr_in*)&nameserverAddress;\n#ifdef HAVE_IPv6\n    struct sockaddr_in6 *sin6 = (struct sockaddr_in6*)&nameserverAddress;\n#endif\n\n    atomLocalhost = internAtom(\"localhost\");\n    atomLocalhostDot = internAtom(\"localhost.\");\n    inFlightDnsQueries = NULL;\n    inFlightDnsQueriesLast = NULL;\n\n    gettimeofday(&t, NULL);\n    idSeed = t.tv_usec & 0xFFFF;\n    sin->sin_family = AF_INET;\n    sin->sin_port = htons(dnsNameServerPort);\n    rc = inet_aton(dnsNameServer->string, &sin->sin_addr);\n#ifdef HAVE_IPv6\n    if(rc != 1) {\n        sin6->sin6_family = AF_INET6;\n        sin6->sin6_port = htons(dnsNameServerPort);\n        rc = inet_pton(AF_INET6, dnsNameServer->string, &sin6->sin6_addr);\n    }\n#endif\n    if(rc != 1) {\n        do_log(L_ERROR, \"DNS: couldn't parse name server %s.\\n\",\n               dnsNameServer->string);\n        exit(1);\n    }\n#endif\n}\n\nint\ndo_gethostbyname(char *origname,\n                 int count,\n                 int (*handler)(int, GethostbynameRequestPtr),\n                 void *data)\n{\n    ObjectPtr object;\n    int n = strlen(origname);\n    AtomPtr name;\n    GethostbynameRequestRec request;\n    int done, rc;\n\n    memset(&request, 0, sizeof(request));\n    request.name = NULL;\n    request.addr = NULL;\n    request.error_message = NULL;\n    request.count = count;\n    request.handler = handler;\n    request.data = data;\n\n    if(n <= 0 || n > 131) {\n        if(n <= 0) {\n            request.error_message = internAtom(\"empty name\");\n            do_log(L_ERROR, \"Empty DNS name.\\n\");\n            done = handler(-EINVAL, &request);\n        } else {\n            request.error_message = internAtom(\"name too long\");\n            do_log(L_ERROR, \"DNS name too long.\\n\");\n            done = handler(-ENAMETOOLONG, &request);\n        }\n        assert(done);\n        releaseAtom(request.error_message);\n        return 1;\n    }\n\n    if(origname[n - 1] == '.')\n        n--;\n\n    name = internAtomLowerN(origname, n);\n\n    if(name == NULL) {\n        request.error_message = internAtom(\"couldn't allocate name\");\n        do_log(L_ERROR, \"Couldn't allocate DNS name.\\n\");\n        done = handler(-ENOMEM, &request);\n        assert(done);\n        releaseAtom(request.error_message);\n        return 1;\n    }\n\n    request.name = name;\n    request.addr = NULL;\n    request.error_message = NULL;\n    request.count = count;\n    request.object = NULL;\n    request.handler = handler;\n    request.data = data;\n\n    object = findObject(OBJECT_DNS, name->string, name->length);\n    if(object == NULL || objectMustRevalidate(object, NULL)) {\n        if(object) {\n            privatiseObject(object, 0);\n            releaseObject(object);\n        }\n        object = makeObject(OBJECT_DNS, name->string, name->length, 1, 0,\n                            NULL, NULL);\n        if(object == NULL) {\n            request.error_message = internAtom(\"Couldn't allocate object\");\n            do_log(L_ERROR, \"Couldn't allocate DNS object.\\n\");\n            done = handler(-ENOMEM, &request);\n            assert(done);\n            releaseAtom(name);\n            releaseAtom(request.error_message);\n            return 1;\n        }\n    }\n\n    if((object->flags & (OBJECT_INITIAL | OBJECT_INPROGRESS)) ==\n       OBJECT_INITIAL) {\n        if(dnsUseGethostbyname >= 3)\n            rc = really_do_gethostbyname(name, object);\n        else\n            rc = really_do_dns(name, object);\n        if(rc < 0) {\n            assert(!(object->flags & (OBJECT_INITIAL | OBJECT_INPROGRESS)));\n            goto fail;\n        }\n    }\n\n    if(dnsUseGethostbyname >= 3)\n        assert(!(object->flags & OBJECT_INITIAL));\n\n#ifndef NO_FANCY_RESOLVER    \n    if(object->flags & OBJECT_INITIAL) {\n        ConditionHandlerPtr chandler;\n        assert(object->flags & OBJECT_INPROGRESS);\n        request.object = object;\n        chandler = conditionWait(&object->condition, dnsHandler,\n                                 sizeof(request), &request);\n        if(chandler == NULL)\n            goto fail;\n        return 1;\n    }\n#endif\n\n    if(object->headers && object->headers->length > 0) {\n        if(object->headers->string[0] == DNS_A)\n            assert(((object->headers->length - 1) % \n                    sizeof(HostAddressRec)) == 0);\n        else\n            assert(object->headers->string[0] == DNS_CNAME);\n        request.addr = retainAtom(object->headers);\n    } else if(object->message) {\n        request.error_message = retainAtom(object->message);\n    }\n\n    releaseObject(object);\n\n    if(request.addr && request.addr->length > 0)\n        done = handler(1, &request);\n    else\n        done = handler(-EDNS_HOST_NOT_FOUND, &request);\n    assert(done);\n\n    releaseAtom(request.addr); request.addr = NULL;\n    releaseAtom(request.name); request.name = NULL;\n    releaseAtom(request.error_message); request.error_message = NULL;\n    return 1;\n\n fail:\n    releaseNotifyObject(object);\n    done = handler(-errno, &request);\n    assert(done);\n    releaseAtom(name);\n    return 1;\n}\n\nstatic int\ndnsDelayedErrorNotifyHandler(TimeEventHandlerPtr event)\n{\n    int done;\n    GethostbynameRequestRec request =\n        *(GethostbynameRequestPtr)event->data;\n    done = request.handler(-EDNS_HOST_NOT_FOUND, &request);\n    assert(done);\n    releaseAtom(request.name); request.name = NULL;\n    releaseAtom(request.addr); request.addr = NULL;\n    releaseAtom(request.error_message); request.error_message = NULL;\n    return 1;\n}\n    \nstatic int\ndnsDelayedDoneNotifyHandler(TimeEventHandlerPtr event)\n{\n    int done;\n    GethostbynameRequestRec request = *(GethostbynameRequestPtr)event->data;\n    done = request.handler(1, &request);\n    assert(done);\n    releaseAtom(request.name); request.name = NULL;\n    releaseAtom(request.addr); request.addr = NULL;\n    releaseAtom(request.error_message); request.error_message = NULL;\n    return 1;\n}\n\nstatic int\ndnsDelayedNotify(int error, GethostbynameRequestPtr request)\n{\n    TimeEventHandlerPtr handler;\n\n    if(error)\n        handler = scheduleTimeEvent(0,\n                                    dnsDelayedErrorNotifyHandler,\n                                    sizeof(*request), request);\n    else\n        handler = scheduleTimeEvent(0,\n                                    dnsDelayedDoneNotifyHandler,\n                                    sizeof(*request), request);\n    if(handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule DNS notification.\\n\");\n        return -1;\n    }\n    return 1;\n}\n\n#ifdef HAVE_IPv6\nAtomPtr\nrfc2732(AtomPtr name)\n{\n    char buf[40]; /* 8*4 (hexdigits) + 7 (colons) + 1 ('\\0') */\n    int rc;\n    AtomPtr a = NULL;\n\n    if(name->length < 40+2 && \n       name->string[0] == '[' && name->string[name->length - 1] == ']') {\n        struct in6_addr in6a;\n        memcpy(buf, name->string + 1, name->length - 2);\n        buf[name->length - 2] = '\\0';\n        rc = inet_pton(AF_INET6, buf, &in6a);\n        if(rc == 1) {\n            char s[1 + sizeof(HostAddressRec)];\n            memset(s, 0, sizeof(s));\n            s[0] = DNS_A;\n            s[1] = 6;\n            memcpy(s + 2, &in6a, 16);\n            a = internAtomN(s, 1 + sizeof(HostAddressRec));\n            if(a == NULL)\n                return NULL;\n        }\n    }\n    return a;\n}\n\n/* Used for sorting host addresses depending on the value of dnsQueryIPv6 */\nint\ncompare_hostaddr(const void *av, const void *bv)\n{\n    const HostAddressRec *a = av, *b = bv;\n    int r;\n    if(a->af == 4) {\n        if(b->af == 4)\n            r = 0;\n        else\n            r = -1;\n    } else {\n        if(b->af == 6)\n            r = 0;\n        else\n            r = 1;\n    }\n    if(dnsQueryIPv6 >= 2)\n        return -r;\n    else\n        return r;\n}\n\n#ifndef NO_STANDARD_RESOLVER\nstatic int\nreally_do_gethostbyname(AtomPtr name, ObjectPtr object)\n{\n    struct addrinfo *ai, *entry, hints;\n    int rc;\n    int error, i;\n    char buf[1024];\n    AtomPtr a;\n\n    a = rfc2732(name);\n    if(a) {\n        object->headers = a;\n        object->age = current_time.tv_sec;\n        object->expires = current_time.tv_sec + 240;\n        object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n        notifyObject(object);\n        return 0;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_protocol = IPPROTO_TCP;\n    if(dnsQueryIPv6 <= 0)\n        hints.ai_family = AF_INET;\n    else if(dnsQueryIPv6 >= 3)\n        hints.ai_family = AF_INET6;\n\n    rc = getaddrinfo(name->string, NULL, &hints, &ai);\n\n    switch(rc) {\n    case 0: error = 0; break;\n    case EAI_FAMILY:\n#ifdef EAI_ADDRFAMILY\n    case EAI_ADDRFAMILY:\n#endif\n    case EAI_SOCKTYPE:\n        error = EAFNOSUPPORT; break;\n    case EAI_BADFLAGS: error = EINVAL; break;\n    case EAI_SERVICE: error = EDNS_NO_RECOVERY; break;\n#ifdef EAI_NONAME\n    case EAI_NONAME:\n#endif\n#ifdef EAI_NODATA\n    case EAI_NODATA:\n#endif\n        error = EDNS_NO_ADDRESS; break;\n    case EAI_FAIL: error = EDNS_NO_RECOVERY; break;\n    case EAI_AGAIN: error = EDNS_TRY_AGAIN; break;\n#ifdef EAI_MEMORY\n    case EAI_MEMORY: error = ENOMEM; break;\n#endif\n    case EAI_SYSTEM: error = errno; break;\n    default: error = EUNKNOWN;\n    }\n\n    if(error == EDNS_NO_ADDRESS) {\n        object->headers = NULL;\n        object->age = current_time.tv_sec;\n        object->expires = current_time.tv_sec + dnsNegativeTtl;\n        object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n        notifyObject(object);\n        return 0;\n    } else if(error) {\n        do_log_error(L_ERROR, error, \"Getaddrinfo failed\");\n        object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(object, 404,\n                    internAtomError(error, \"Getaddrinfo failed\"));\n        notifyObject(object);\n        return 0;\n    }\n\n    entry = ai;\n    buf[0] = DNS_A;\n    i = 0;\n    while(entry) {\n        HostAddressRec host;\n        int host_valid = 0;\n        if(entry->ai_family == AF_INET && entry->ai_protocol == IPPROTO_TCP) {\n            if(dnsQueryIPv6 < 3) {\n                host.af = 4;\n                memset(host.data, 0, sizeof(host.data));\n                memcpy(&host.data,\n                       &((struct sockaddr_in*)entry->ai_addr)->sin_addr, \n                       4);\n                host_valid = 1;\n            }\n        } else if(entry->ai_family == AF_INET6 && \n                  entry->ai_protocol == IPPROTO_TCP) {\n            if(dnsQueryIPv6 > 0) {\n                host.af = 6;\n                memset(&host.data, 0, sizeof(host.data));\n                memcpy(&host.data,\n                       &((struct sockaddr_in6*)entry->ai_addr)->sin6_addr, \n                       16);\n                host_valid = 1;\n            }\n        }\n        if(host_valid) {\n            if(i >= 1024 / sizeof(HostAddressRec) - 2) {\n                do_log(L_ERROR, \"Too many addresses for host %s\\n\", \n                       name->string);\n                break;\n            }\n            memcpy(buf + 1 + i * sizeof(HostAddressRec), \n                   &host, sizeof(HostAddressRec));\n            i++;\n        }\n        entry = entry->ai_next;\n    }\n    freeaddrinfo(ai);\n    if(i == 0) {\n        do_log(L_ERROR, \"Getaddrinfo returned no useful addresses\\n\");\n        object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(object, 404,\n                    internAtom(\"Getaddrinfo returned no useful addresses\"));\n        notifyObject(object);\n        return 0;\n    }\n\n    if(1 <= dnsQueryIPv6 && dnsQueryIPv6 <= 2)\n        qsort(buf + 1, i, sizeof(HostAddressRec), compare_hostaddr);\n\n    a = internAtomN(buf, 1 + i * sizeof(HostAddressRec));\n    if(a == NULL) {\n        object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(object, 501, internAtom(\"Couldn't allocate address\"));\n        notifyObject(object);\n        return 0;\n    }\n    object->headers = a;\n    object->age = current_time.tv_sec;\n    object->expires = current_time.tv_sec + dnsGethostbynameTtl;\n    object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n    notifyObject(object);\n    return 0;\n}\n#endif\n    \n#else\n\n#ifndef NO_STANDARD_RESOLVER\nstatic int\nreally_do_gethostbyname(AtomPtr name, ObjectPtr object)\n{\n    struct hostent *host;\n    char *s;\n    AtomPtr a;\n    int i, j;\n    int error;\n\n    host = gethostbyname(name->string);\n    if(host == NULL) {\n        switch(h_errno) {\n        case HOST_NOT_FOUND: error = EDNS_HOST_NOT_FOUND; break;\n#ifdef NO_ADDRESS\n        case NO_ADDRESS: error = EDNS_NO_ADDRESS; break;\n#endif\n        case NO_RECOVERY: error = EDNS_NO_RECOVERY; break;\n        case TRY_AGAIN: error = EDNS_TRY_AGAIN; break;\n        default: error = EUNKNOWN; break;\n        }\n        if(error == EDNS_HOST_NOT_FOUND) {\n            object->headers = NULL;\n            object->age = current_time.tv_sec;\n            object->expires = current_time.tv_sec + dnsNegativeTtl;\n            object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n            object->flags &= ~OBJECT_INPROGRESS;\n            notifyObject(object);\n            return 0;\n        } else {\n            do_log_error(L_ERROR, error, \"Gethostbyname failed\");\n            abortObject(object, 404, \n                        internAtomError(error, \"Gethostbyname failed\"));\n            object->flags &= ~OBJECT_INPROGRESS;\n            notifyObject(object);\n            return 0;\n        }\n    }\n    if(host->h_addrtype != AF_INET) {\n        do_log(L_ERROR, \"Address is not AF_INET.\\n\");\n        object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(object, 404, internAtom(\"Address is not AF_INET\"));\n        notifyObject(object);\n        return -1;\n    }\n    if(host->h_length != sizeof(struct in_addr)) {\n        do_log(L_ERROR, \"Address size inconsistent.\\n\");\n        object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(object, 404, internAtom(\"Address size inconsistent\"));\n        notifyObject(object);\n        return 0;\n    }\n    i = 0;\n    while(host->h_addr_list[i] != NULL) i++;\n    s = malloc(1 + i * sizeof(HostAddressRec));\n    if(s == NULL) {\n        a = NULL;\n    } else {\n        memset(s, 0, 1 + i * sizeof(HostAddressRec));\n        s[0] = DNS_A;\n        for(j = 0; j < i; j++) {\n            s[j * sizeof(HostAddressRec) + 1] = 4;\n            memcpy(&s[j * sizeof(HostAddressRec) + 2], host->h_addr_list[j],\n                   sizeof(struct in_addr));\n        }\n        a = internAtomN(s, i * sizeof(HostAddressRec) + 1);\n        free(s);\n    }\n    if(!a) {\n        object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(object, 501, internAtom(\"Couldn't allocate address\"));\n        notifyObject(object);\n        return 0;\n    }\n    object->headers = a;\n    object->age = current_time.tv_sec;\n    object->expires = current_time.tv_sec + dnsGethostbynameTtl;\n    object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n    notifyObject(object);\n    return 0;\n\n}\n#endif\n\n#endif\n\n#ifdef NO_STANDARD_RESOLVER\nstatic int\nreally_do_gethostbyname(AtomPtr name, ObjectPtr object)\n{\n    abort();\n}\n#endif\n\n#ifndef NO_FANCY_RESOLVER\n\nstatic int dnsSocket = -1;\nstatic FdEventHandlerPtr dnsSocketHandler = NULL;\n\nstatic int\ndnsHandler(int status, ConditionHandlerPtr chandler)\n{\n    GethostbynameRequestRec request = *(GethostbynameRequestPtr)chandler->data;\n    ObjectPtr object = request.object;\n\n    assert(!(object->flags & OBJECT_INPROGRESS));\n\n    if(object->headers) {\n        request.addr = retainAtom(object->headers);\n        dnsDelayedNotify(0, &request);\n    } else {\n        if(object->message)\n            request.error_message = retainAtom(object->message);\n        dnsDelayedNotify(1, &request);\n    }\n    releaseObject(object);\n    return 1;\n}\n\nstatic int\nqueryInFlight(DnsQueryPtr query)\n{\n    DnsQueryPtr other;\n    other = inFlightDnsQueries;\n    while(other) {\n        if(other == query)\n            return 1;\n        other = other->next;\n    }\n    return 0;\n}\n\nstatic void\nremoveQuery(DnsQueryPtr query)\n{\n    DnsQueryPtr previous;\n    if(query == inFlightDnsQueries) {\n        inFlightDnsQueries = query->next;\n        if(inFlightDnsQueries == NULL)\n            inFlightDnsQueriesLast = NULL;\n    } else {\n        previous = inFlightDnsQueries;\n        while(previous->next) {\n            if(previous->next == query)\n                break;\n            previous = previous->next;\n        }\n        assert(previous->next != NULL);\n        previous->next = query->next;\n        if(previous->next == NULL)\n            inFlightDnsQueriesLast = previous;\n    }\n}\n\nstatic void\ninsertQuery(DnsQueryPtr query) \n{\n    if(inFlightDnsQueriesLast)\n        inFlightDnsQueriesLast->next = query;\n    else\n        inFlightDnsQueries = query;\n    inFlightDnsQueriesLast = query;\n}\n\nstatic DnsQueryPtr\nfindQuery(int id, AtomPtr name)\n{\n    DnsQueryPtr query;\n    query = inFlightDnsQueries;\n    while(query) {\n        if(query->id == id && (name == NULL || query->name == name))\n            return query;\n        query = query->next;\n    }\n    return NULL;\n}\n\nstatic int\ndnsTimeoutHandler(TimeEventHandlerPtr event)\n{\n    DnsQueryPtr query = *(DnsQueryPtr*)event->data;\n    ObjectPtr object = query->object;\n    int rc;\n\n    /* People are reporting that this does happen.  And I have no idea why. */\n    if(!queryInFlight(query)) {\n        do_log(L_ERROR, \"BUG: timing out martian query (%s, flags: 0x%x).\\n\",\n               scrub(query->name->string), (unsigned)object->flags);\n        return 1;\n    }\n\n    query->timeout = MAX(10, query->timeout * 2);\n\n    if(query->timeout > dnsMaxTimeout) {\n        abortObject(object, 501, internAtom(\"Timeout\"));\n        goto fail;\n    } else {\n        rc = sendQuery(query);\n        if(rc < 0) {\n            if(rc != -EWOULDBLOCK && rc != -EAGAIN && rc != -ENOBUFS) {\n                abortObject(object, 501,\n                            internAtomError(-rc,\n                                            \"Couldn't send DNS query\"));\n                goto fail;\n            }\n            /* else let it timeout */\n        }\n        query->timeout_handler =\n            scheduleTimeEvent(query->timeout, dnsTimeoutHandler,\n                              sizeof(query), &query);\n        if(query->timeout_handler == NULL) {\n            do_log(L_ERROR, \"Couldn't schedule DNS timeout handler.\\n\");\n            abortObject(object, 501,\n                        internAtom(\"Couldn't schedule DNS timeout handler\"));\n            goto fail;\n        }\n        return 1;\n    }\n\n fail:\n    removeQuery(query);\n    object->flags &= ~OBJECT_INPROGRESS;\n    if(query->inet4) releaseAtom(query->inet4);\n    if(query->inet6) releaseAtom(query->inet6);\n    free(query);\n    releaseNotifyObject(object);\n    return 1;\n}\n\nstatic int\nestablishDnsSocket()\n{\n    int rc;\n#ifdef HAVE_IPv6\n    int inet6 = (nameserverAddress.sa_family == AF_INET6);\n    int pf = inet6 ? PF_INET6 : PF_INET;\n    int sa_size = \n        inet6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in);\n#else\n    int pf = PF_INET;\n    int sa_size = sizeof(struct sockaddr_in);\n#endif\n\n    if(dnsSocket < 0) {\n        assert(!dnsSocketHandler);\n        dnsSocket = socket(pf, SOCK_DGRAM, 0);\n        if(dnsSocket < 0) {\n            do_log_error(L_ERROR, errno, \"Couldn't create DNS socket\");\n            return -errno;\n        }\n\n        rc = connect(dnsSocket, &nameserverAddress, sa_size);\n        if(rc < 0) {\n            CLOSE(dnsSocket);\n            dnsSocket = -1;\n            do_log_error(L_ERROR, errno, \"Couldn't create DNS \\\"connection\\\"\");\n            return -errno;\n        }\n    }\n\n    if(!dnsSocketHandler) {\n        dnsSocketHandler = \n            registerFdEvent(dnsSocket, POLLIN, dnsReplyHandler, 0, NULL);\n        if(dnsSocketHandler == NULL) {\n            do_log(L_ERROR, \"Couldn't register DNS socket handler.\\n\");\n            CLOSE(dnsSocket);\n            dnsSocket = -1;\n            return -ENOMEM;\n        }\n    }\n\n    return 1;\n}\n\nstatic int\nsendQuery(DnsQueryPtr query)\n{\n    char buf[512];\n    int buflen;\n    int rc;\n    int af[2];\n    int i;\n\n    if(dnsSocket < 0)\n        return -1;\n\n    if(dnsQueryIPv6 <= 0) {\n        af[0] = 4; af[1] = 0;\n    } else if(dnsQueryIPv6 <= 2) {\n        af[0] = 4; af[1] = 6;\n    } else {\n        af[0] = 6; af[1] = 0;\n    }\n\n    for(i = 0; i < 2; i++) {\n        if(af[i] == 0)\n            continue;\n        if(af[i] == 4 && query->inet4)\n            continue;\n        else if(af[i] == 6 && query->inet6)\n            continue;\n\n        buflen = dnsBuildQuery(query->id, buf, 0, 512, query->name, af[i]);\n        if(buflen <= 0) {\n            do_log(L_ERROR, \"Couldn't build DNS query.\\n\");\n            return buflen;\n        }\n\n        rc = send(dnsSocket, buf, buflen, 0);\n        if(rc < buflen) {\n            if(rc >= 0) {\n                do_log(L_ERROR, \"Couldn't send DNS query: partial send.\\n\");\n                return -EAGAIN;\n            } else {\n                do_log_error(L_ERROR, errno, \"Couldn't send DNS query\");\n                return -errno;\n            }\n        }\n    }\n    return 1;\n}\n\nstatic int\nreally_do_dns(AtomPtr name, ObjectPtr object)\n{\n    int rc;\n    DnsQueryPtr query;\n    AtomPtr message = NULL;\n    int id;\n    AtomPtr a = NULL;\n\n    if(a == NULL) {\n        if(name == atomLocalhost || name == atomLocalhostDot) {\n            char s[1 + sizeof(HostAddressRec)];\n            memset(s, 0, sizeof(s));\n            s[0] = DNS_A;\n            s[1] = 4;\n            s[2] = 127;\n            s[3] = 0;\n            s[4] = 0;\n            s[5] = 1;\n            a = internAtomN(s, 1 + sizeof(HostAddressRec));\n            if(a == NULL) {\n                abortObject(object, 501,\n                            internAtom(\"Couldn't allocate address\"));\n                notifyObject(object);\n                errno = ENOMEM;\n                return -1;\n            }\n        }\n    }\n\n    if(a == NULL) {\n        struct in_addr ina;\n        rc = inet_aton(name->string, &ina);\n        if(rc == 1) {\n            char s[1 + sizeof(HostAddressRec)];\n            memset(s, 0, sizeof(s));\n            s[0] = DNS_A;\n            s[1] = 4;\n            memcpy(s + 2, &ina, 4);\n            a = internAtomN(s, 1 + sizeof(HostAddressRec));\n            if(a == NULL) {\n                abortObject(object, 501,\n                            internAtom(\"Couldn't allocate address\"));\n                notifyObject(object);\n                errno = ENOMEM;\n                return -1;\n            }\n        }\n    }\n#ifdef HAVE_IPv6\n    if(a == NULL)\n        a = rfc2732(name);\n#endif\n\n    if(a) {\n        object->headers = a;\n        object->age = current_time.tv_sec;\n        object->expires = current_time.tv_sec + 240;\n        object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n        notifyObject(object);\n        return 0;\n    }\n\n    rc = establishDnsSocket();\n    if(rc < 0) {\n        do_log_error(L_ERROR, -rc, \"Couldn't establish DNS socket.\\n\");\n        message = internAtomError(-rc, \"Couldn't establish DNS socket\");\n        goto fallback;\n    }\n\n    /* The id is used to speed up detecting replies to queries that\n       are no longer current -- see dnsReplyHandler. */\n    id = (idSeed++) & 0xFFFF;\n\n    query = malloc(sizeof(DnsQueryRec));\n    if(query == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate DNS query.\\n\");\n        message = internAtom(\"Couldn't allocate DNS query\");\n        goto fallback;\n    }\n    query->id = id;\n    query->inet4 = NULL;\n    query->inet6 = NULL;\n    query->name = name;\n    query->time = current_time.tv_sec;\n    query->object = retainObject(object);\n    query->timeout = 4;\n    query->timeout_handler = NULL;\n    query->next = NULL;\n\n    query->timeout_handler = \n        scheduleTimeEvent(query->timeout, dnsTimeoutHandler,\n                          sizeof(query), &query);\n    if(query->timeout_handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule DNS timeout handler.\\n\");\n        message = internAtom(\"Couldn't schedule DNS timeout handler\");\n        goto free_fallback;\n    }\n    insertQuery(query);\n\n    object->flags |= OBJECT_INPROGRESS;\n    rc = sendQuery(query);\n    if(rc < 0) {\n        if(rc != -EWOULDBLOCK && rc != -EAGAIN && rc != -ENOBUFS) {\n            object->flags &= ~OBJECT_INPROGRESS;\n            message = internAtomError(-rc, \"Couldn't send DNS query\");\n            goto remove_fallback;\n        }\n        /* else let it timeout */\n    }\n    releaseAtom(message);\n    return 1;\n\n remove_fallback:\n    removeQuery(query);\n free_fallback:\n    releaseObject(query->object);\n    cancelTimeEvent(query->timeout_handler);\n    free(query);\n fallback:\n    if(dnsUseGethostbyname >= 1) {\n        releaseAtom(message);\n        do_log(L_WARN, \"Falling back on gethostbyname.\\n\");\n        return really_do_gethostbyname(name, object);\n    } else {\n        abortObject(object, 501, message);\n        notifyObject(object);\n        return 1;\n    }\n}\n\nstatic int\ndnsReplyHandler(int abort, FdEventHandlerPtr event)\n{\n    int fd = event->fd;\n    char buf[2048];\n    int len, rc;\n    ObjectPtr object;\n    unsigned ttl = 0;\n    AtomPtr name, value, message = NULL;\n    int id;\n    int af;\n    DnsQueryPtr query;\n    AtomPtr cname = NULL;\n\n    if(abort) {\n        dnsSocketHandler = NULL;\n        rc = establishDnsSocket();\n        if(rc < 0) {\n            do_log(L_ERROR, \"Couldn't reestablish DNS socket.\\n\");\n            /* At this point, we should abort all in-flight\n               DNS requests.  Oh, well, they'll timeout anyway. */\n        }\n        return 1;\n    }\n\n    len = recv(fd, buf, 2048, 0);\n    if(len <= 0) {\n        if(errno == EINTR || errno == EAGAIN) return 0;\n        /* This is where we get ECONNREFUSED for an ICMP port unreachable */\n        do_log_error(L_ERROR, errno, \"DNS: recv failed\");\n        dnsGethostbynameFallback(-1, message);\n        return 0;\n    }\n\n    /* This could be a late reply to a query that timed out and was\n       resent, a reply to a query that timed out, or a reply to an\n       AAAA query when we already got a CNAME reply to the associated\n       A.  We filter such replies straight away, without trying to\n       parse them. */\n    rc = dnsReplyId(buf, 0, len, &id);\n    if(rc < 0) {\n        do_log(L_WARN, \"Short DNS reply.\\n\");\n        return 0;\n    }\n    if(!findQuery(id, NULL)) {\n        return 0;\n    }\n\n    rc = dnsDecodeReply(buf, 0, len, &id, &name, &value, &af, &ttl);\n    if(rc < 0) {\n        assert(value == NULL);\n        /* We only want to fallback on gethostbyname if we received a\n           reply that we could not understand.  What about truncated\n           replies? */\n        if(rc < 0) {\n            do_log_error(L_WARN, -rc, \"DNS\");\n            if(dnsUseGethostbyname >= 2 ||\n               (dnsUseGethostbyname && \n                (rc != -EDNS_HOST_NOT_FOUND && rc != -EDNS_NO_RECOVERY &&\n                 rc != -EDNS_FORMAT))) {\n                dnsGethostbynameFallback(id, message);\n                return 0;\n            } else {\n                message = internAtom(pstrerror(-rc));\n            }\n        } else {\n            assert(name != NULL && id >= 0 && af >= 0);\n        }\n    }\n\n    query = findQuery(id, name);\n    if(query == NULL) {\n        /* Duplicate id ? */\n        releaseAtom(value);\n        releaseAtom(name);\n        return 0;\n    }\n\n    /* We're going to use the information in this reply.  If it was an\n       error, construct an empty atom to distinguish it from information\n       we're still waiting for. */\n    if(value == NULL)\n        value = internAtom(\"\");\n\n again:\n    if(af == 4) {\n        if(query->inet4 == NULL) {\n            query->inet4 = value;\n            query->ttl4 = current_time.tv_sec + ttl;\n        } else\n            releaseAtom(value);\n    } else if(af == 6) {\n        if(query->inet6 == NULL) {\n            query->inet6 = value;\n            query->ttl6 = current_time.tv_sec + ttl;\n        } else\n            releaseAtom(value);\n    } else if(af == 0) {\n        /* Ignore errors in this case. */\n        if(query->inet4 && query->inet4->length == 0) {\n            releaseAtom(query->inet4);\n            query->inet4 = NULL;\n        }\n        if(query->inet6 && query->inet6->length == 0) {\n            releaseAtom(query->inet6);\n            query->inet6 = NULL;\n        }\n        if(query->inet4 || query->inet6) {\n            do_log(L_WARN, \"Host %s has both %s and CNAME -- \"\n                   \"ignoring CNAME.\\n\", scrub(query->name->string),\n                   query->inet4 ? \"A\" : \"AAAA\");\n            releaseAtom(value);\n            value = internAtom(\"\");\n            af = query->inet4 ? 4 : 6;\n            goto again;\n        } else {\n            cname = value;\n        }\n    }\n\n    if(rc >= 0 && !cname &&\n       ((dnsQueryIPv6 < 3 && query->inet4 == NULL) ||\n        (dnsQueryIPv6 > 0 && query->inet6 == NULL)))\n        return 0;\n\n    /* This query is complete */\n\n    cancelTimeEvent(query->timeout_handler);\n    object = query->object;\n\n    if(object->flags & OBJECT_INITIAL) {\n        assert(!object->headers);\n        if(cname) {\n            assert(query->inet4 == NULL && query->inet6 == NULL);\n            object->headers = cname;\n            object->expires = current_time.tv_sec + ttl;\n        } else if((!query->inet4 || query->inet4->length == 0) &&\n                  (!query->inet6 || query->inet6->length == 0)) {\n            releaseAtom(query->inet4);\n            releaseAtom(query->inet6);\n            object->expires = current_time.tv_sec + dnsNegativeTtl;\n            abortObject(object, 500, retainAtom(message));\n        } else if(!query->inet4 || query->inet4->length == 0) {\n            object->headers = query->inet6;\n            object->expires = query->ttl6;\n            releaseAtom(query->inet4);\n        } else if(!query->inet6 || query->inet6->length == 0) {\n            object->headers = query->inet4;\n            object->expires = query->ttl4;\n            releaseAtom(query->inet6);\n        } else {\n            /* need to merge results */\n            char buf[1024];\n            if(query->inet4->length + query->inet6->length > 1024) {\n                releaseAtom(query->inet4);\n                releaseAtom(query->inet6);\n                abortObject(object, 500, internAtom(\"DNS reply too long\"));\n            } else {\n                if(dnsQueryIPv6 <= 1) {\n                    memcpy(buf, query->inet4->string, query->inet4->length);\n                    memcpy(buf + query->inet4->length,\n                           query->inet6->string + 1, query->inet6->length - 1);\n                } else {\n                    memcpy(buf, query->inet6->string, query->inet6->length);\n                    memcpy(buf + query->inet6->length,\n                           query->inet4->string + 1, query->inet4->length - 1);\n                }\n                object->headers =\n                    internAtomN(buf, \n                                query->inet4->length + \n                                query->inet6->length - 1);\n                if(object->headers == NULL)\n                    abortObject(object, 500, \n                                internAtom(\"Couldn't allocate DNS atom\"));\n            }\n            object->expires = MIN(query->ttl4, query->ttl6);\n        }\n        object->age = current_time.tv_sec;\n        object->flags &= ~(OBJECT_INITIAL | OBJECT_INPROGRESS);\n    } else {\n        do_log(L_WARN, \"DNS object ex nihilo for %s.\\n\",\n               scrub(query->name->string));\n    }\n    \n    removeQuery(query);\n    free(query);\n\n    releaseAtom(name);\n    releaseAtom(message);\n    releaseNotifyObject(object);\n    return 0;\n}\n\nstatic int\ndnsGethostbynameFallback(int id, AtomPtr message)\n{\n    DnsQueryPtr query, previous;\n    ObjectPtr object;\n\n    if(inFlightDnsQueries == NULL) {\n        releaseAtom(message);\n        return 1;\n    }\n\n    query = NULL;\n    if(id < 0 || inFlightDnsQueries->id == id) {\n        previous = NULL;\n        query = inFlightDnsQueries;\n    } else {\n        previous = inFlightDnsQueries;\n        while(previous->next) {\n            if(previous->next->id == id) {\n                query = previous->next;\n                break;\n            }\n            previous = previous->next;\n        }\n        if(!query) {\n            previous = NULL;\n            query = inFlightDnsQueries;\n        }\n    }\n\n    if(previous == NULL) {\n        inFlightDnsQueries = query->next;\n        if(inFlightDnsQueries == NULL)\n            inFlightDnsQueriesLast = NULL;\n    } else {\n        previous->next = query->next;\n        if(query->next == NULL)\n            inFlightDnsQueriesLast = NULL;\n    }\n\n    object = makeObject(OBJECT_DNS, query->name->string, query->name->length,\n                        1, 0, NULL, NULL);\n    if(!object) {\n        do_log(L_ERROR, \"Couldn't make DNS object.\\n\");\n        releaseAtom(query->name);\n        releaseAtom(message);\n        releaseObject(query->object);\n        cancelTimeEvent(query->timeout_handler);\n        free(query);\n        return -1;\n    }\n    if(dnsUseGethostbyname >= 1) {\n        releaseAtom(message);\n        do_log(L_WARN, \"Falling back to using system resolver.\\n\");\n        really_do_gethostbyname(retainAtom(query->name), object);\n    } else {\n        releaseAtom(object->message);\n        object->message = message;\n        object->flags &= ~OBJECT_INPROGRESS;\n        releaseNotifyObject(object);\n    }\n    cancelTimeEvent(query->timeout_handler);\n    releaseAtom(query->name);\n    if(query->inet4) releaseAtom(query->inet4);\n    if(query->inet6) releaseAtom(query->inet6);\n    releaseObject(query->object);\n    free(query);\n    return 1;\n}\n\nstatic int\nstringToLabels(char *buf, int offset, int n, char *string)\n{\n    int i = offset;\n    int j = 0, k = 0;\n    while(1) {\n        while(string[k] != '.' && string[k] != '\\0')\n            k++;\n        if(k >= j + 256) return -1;\n        buf[i] = (unsigned char)(k - j); i++; if(i >= n) return -1;\n        while(j < k) {\n            buf[i] = string[j]; i++; j++; if(i >= n) return -1;\n        }\n        if(string[j] == '\\0') {\n            buf[i] = '\\0';\n            i++; if(i >= n) return -1;\n            break;\n        }\n        j++; k++;\n    }\n\n    return i;\n}\n\n#ifdef UNALIGNED_ACCESS\n#define DO_NTOHS(_d, _s) _d = ntohs(*(unsigned short*)(_s));\n#define DO_NTOHL(_d, _s) _d = ntohl(*(unsigned*)(_s))\n#define DO_HTONS(_d, _s) *(unsigned short*)(_d) = htons(_s);\n#define DO_HTONL(_d, _s) *(unsigned*)(_d) = htonl(_s)\n#else\n#define DO_NTOHS(_d, _s) \\\n    do { unsigned short _dd; \\\n         memcpy(&(_dd), (_s), sizeof(unsigned short)); \\\n         _d = ntohs(_dd); } while(0)\n#define DO_NTOHL(_d, _s) \\\n    do { unsigned _dd; \\\n         memcpy(&(_dd), (_s), sizeof(unsigned)); \\\n         _d = ntohl(_dd); } while(0)\n#define DO_HTONS(_d, _s) \\\n    do { unsigned short _dd; \\\n         _dd = htons(_s); \\\n         memcpy((_d), &(_dd), sizeof(unsigned short)); } while(0);\n#define DO_HTONL(_d, _s) \\\n    do { unsigned _dd; \\\n         _dd = htonl(_s); \\\n         memcpy((_d), &(_dd), sizeof(unsigned)); } while(0);\n#endif\n\nstatic int\nlabelsToString(char *buf, int offset, int n, char *d, int m, int *j_return)\n{\n    int i = offset, j, k;\n    int ll, rc;\n\n    j = 0;\n    while(1) {\n        if(i >= n) return -1;\n        ll = *(unsigned char*)&buf[i]; i++;\n        if(ll == 0) {\n            break;\n        }\n        if((ll & (3 << 6)) == (3 << 6)) {\n            /* RFC 1035, 4.1.4 */\n            int o;\n            if(i >= n) return -1;\n            o = (ll & ~(3 << 6)) << 8 | *(unsigned char*)&buf[i];\n            i++;\n            rc = labelsToString(buf, o, n, &d[j], m - j, &k);\n            if(rc < 0)\n                return -1;\n            j += k;\n            break;\n        } else if((ll & (3 << 6)) == 0) {\n            for(k = 0; k < ll; k++) {\n                if(i >= n || j >= m) return -1;\n                d[j++] = buf[i++];\n            }\n            if(i >= n) return -1;\n            if(buf[i] != '\\0') {\n                if(j >= m) return -1;\n                d[j++] = '.';\n            }\n        } else {\n            return -1;\n        }\n    }\n    *j_return = j;\n    return i;\n}\n\nstatic int\ndnsBuildQuery(int id, char *buf, int offset, int n, AtomPtr name, int af)\n{\n    int i = offset;\n    int type;\n    switch(af) {\n    case 4: type = 1; break;\n    case 6: type = 28; break;\n    default: return -EINVAL;\n    }\n\n    if(i + 12 >= n) return -1;\n    DO_HTONS(&buf[i], id); i += 2;\n    DO_HTONS(&buf[i], 1<<8); i += 2;\n    DO_HTONS(&buf[i], 1); i += 2;\n    DO_HTONS(&buf[i], 0); i += 2;\n    DO_HTONS(&buf[i], 0); i += 2;\n    DO_HTONS(&buf[i], 0); i += 2;\n\n    i = stringToLabels(buf, i, n, name->string);\n    if(i < 0) return -ENAMETOOLONG;\n    \n    if(i + 4 >= n) return -ENAMETOOLONG;\n    DO_HTONS(&buf[i], type); i += 2;\n    DO_HTONS(&buf[i], 1); i += 2;\n    return i;\n}\n\nstatic int\ndnsReplyId(char *buf, int offset, int n, int *id_return)\n{\n    if(n - offset < 12)\n        return -1;\n    DO_NTOHS(*id_return, &buf[offset]);\n    return 1;\n}\n\nstatic int\ndnsDecodeReply(char *buf, int offset, int n, int *id_return,\n               AtomPtr *name_return, AtomPtr *value_return,\n               int *af_return, unsigned *ttl_return)\n{\n    int i = offset, j, m;\n    int id = -1, b23, qdcount, ancount, nscount, arcount, rdlength;\n    int class, type;\n    unsigned int ttl;\n    char b[2048];\n    int af = -1;\n    AtomPtr name = NULL, value;\n    char addresses[1024];\n    int addr_index = 0;\n    int error = EDNS_NO_ADDRESS;\n    unsigned final_ttl = 7 * 24 * 3600;\n    int dnserror;\n\n    if(n - i < 12) {\n        error = EDNS_INVALID;\n        goto fail;\n    }\n\n    DO_NTOHS(id, &buf[i]); i += 2;\n    DO_NTOHS(b23, &buf[i]); i += 2;\n    DO_NTOHS(qdcount, &buf[i]); i += 2;\n    DO_NTOHS(ancount, &buf[i]); i += 2;\n    DO_NTOHS(nscount, &buf[i]); i += 2;\n    DO_NTOHS(arcount, &buf[i]); i += 2;\n\n    do_log(D_DNS, \n           \"DNS id %d, b23 0x%x, qdcount %d, ancount %d, \"\n           \"nscount %d, arcount %d\\n\",\n           id, b23, qdcount, ancount, nscount, arcount);\n\n    if((b23 & (0xF870)) != 0x8000) {\n        do_log(L_ERROR, \"Incorrect DNS reply (b23 = 0x%x).\\n\", b23);\n        error = EDNS_INVALID;\n        goto fail;\n    }\n\n    dnserror = b23 & 0xF;\n\n    if(b23 & 0x200) {\n        do_log(L_WARN, \"Truncated DNS reply (b23 = 0x%x).\\n\", b23);\n    }\n\n    if(dnserror || qdcount != 1) {\n        if(!dnserror)\n            do_log(L_ERROR, \n                   \"Unexpected number %d of DNS questions.\\n\", qdcount);\n        if(dnserror == 1)\n            error = EDNS_FORMAT;\n        else if(dnserror == 2)\n            error = EDNS_NO_RECOVERY;\n        else if(dnserror == 3)\n            error = EDNS_HOST_NOT_FOUND;\n        else if(dnserror == 4 || dnserror == 5)\n            error = EDNS_REFUSED;\n        else if(dnserror == 0)\n            error = EDNS_INVALID;\n        else\n            error = EUNKNOWN;\n        goto fail;\n    }\n\n    /* We do this early, so that we can return the address family to\n       the caller in case of error. */\n    i = labelsToString(buf, i, n, b, 2048, &m);\n    if(i < 0) {\n        error = EDNS_FORMAT;\n        goto fail;\n    }\n    DO_NTOHS(type, &buf[i]); i += 2;\n    DO_NTOHS(class, &buf[i]); i += 2;\n\n    if(type == 1)\n        af = 4;\n    else if(type == 28)\n        af = 6;\n    else {\n        error = EDNS_FORMAT;\n        goto fail;\n    }\n\n    do_log(D_DNS, \"DNS q: \");\n    do_log_n(D_DNS, b, m);\n    do_log(D_DNS, \" (%d, %d)\\n\", type, class);\n    name = internAtomLowerN(b, m);\n    if(name == NULL) {\n        error = ENOMEM;\n        goto fail;\n    }\n\n    if(class != 1) {\n        error = EDNS_FORMAT;\n        goto fail;\n    }\n\n#define PARSE_ANSWER(kind, label) \\\ndo { \\\n    i = labelsToString(buf, i, 1024, b, 2048, &m); \\\n    if(i < 0) goto label; \\\n    DO_NTOHS(type, &buf[i]); i += 2; if(i > 1024) goto label; \\\n    DO_NTOHS(class, &buf[i]); i += 2; if(i > 1024) goto label; \\\n    DO_NTOHL(ttl, &buf[i]); i += 4; if(i > 1024) goto label; \\\n    DO_NTOHS(rdlength, &buf[i]); i += 2; if(i > 1024) goto label; \\\n    do_log(D_DNS, \"DNS \" kind \": \"); \\\n    do_log_n(D_DNS, b, m); \\\n    do_log(D_DNS, \" (%d, %d): %d bytes, ttl %u\\n\", \\\n           type, class, rdlength, ttl); \\\n   } while(0)\n\n\n    for(j = 0; j < ancount; j++) {\n        PARSE_ANSWER(\"an\", fail);\n        if(strcasecmp_n(name->string, b, m) == 0) {\n            if(class != 1) {\n                do_log(D_DNS, \"DNS: %s: unknown class %d.\\n\", \n                       name->string, class);\n                error = EDNS_UNSUPPORTED;\n                goto cont;\n            }\n            if(type == 1 || type == 28) {\n                if((type == 1 && rdlength != 4) ||\n                   (type == 28 && rdlength != 16)) {\n                    do_log(L_ERROR, \n                           \"DNS: %s: unexpected length %d of %s record.\\n\",\n                           scrub(name->string),\n                           rdlength, type == 1 ? \"A\" : \"AAAA\");\n                    error = EDNS_INVALID;\n                    if(rdlength <= 0 || rdlength >= 32)\n                        goto fail;\n                    goto cont;\n                }\n                if(af == 0) {\n                    do_log(L_WARN, \"DNS: %s: host has both A and CNAME -- \"\n                           \"ignoring CNAME.\\n\", scrub(name->string));\n                    addr_index = 0;\n                    af = -1;\n                }\n                if(type == 1) {\n                    if(af < 0)\n                        af = 4;\n                    else if(af == 6) {\n                        do_log(L_WARN, \"Unexpected AAAA reply.\\n\");\n                        goto cont;\n                    }\n                } else {\n                    if(af < 0)\n                        af = 6;\n                    else if(af == 4) {\n                        do_log(L_WARN, \"Unexpected A reply.\\n\");\n                        goto cont;\n                    }\n                }\n\n                if(addr_index == 0) {\n                    addresses[0] = DNS_A;\n                    addr_index++;\n                } else {\n                    if(addr_index > 1000) {\n                        error = EDNS_INVALID;\n                        goto fail;\n                    }\n                }\n                assert(addresses[0] == DNS_A);\n                if(final_ttl > ttl)\n                    final_ttl = ttl;\n                memset(&addresses[addr_index], 0, sizeof(HostAddressRec));\n                if(type == 1) {\n                    addresses[addr_index] = 4;\n                    memcpy(addresses + addr_index + 1, buf + i, 4);\n                } else {\n                    addresses[addr_index] = 6;\n                    memcpy(addresses + addr_index + 1, buf + i, 16);\n                }\n                addr_index += sizeof(HostAddressRec);\n            } else if(type == 5) {\n                int j, k;\n                if(af != 0 && addr_index > 0) {\n                    do_log(L_WARN, \"DNS: host has both CNAME and A -- \"\n                           \"ignoring CNAME.\\n\");\n                    goto cont;\n                }\n                af = 0;\n\n                if(addr_index != 0) {\n                    /* Only warn if the CNAMEs are not identical */\n                    char tmp[512]; int jj, kk;\n                    assert(addresses[0] == DNS_CNAME);\n                    jj = labelsToString(buf, i, n,\n                                        tmp, 512, &kk);\n                    if(jj < 0 ||\n                       kk != strlen(addresses + 1) ||\n                       memcmp(addresses + 1, tmp, kk) != 0) {\n                        do_log(L_WARN, \"DNS: \"\n                               \"%s: host has multiple CNAMEs -- \"\n                               \"ignoring subsequent.\\n\",\n                               scrub(name->string));\n\n                    }\n                    goto cont;\n                }\n                addresses[0] = DNS_CNAME;\n                addr_index++;\n                j = labelsToString(buf, i, n,\n                                   addresses + 1, 1020, &k);\n                if(j < 0) {\n                    addr_index = 0;\n                    error = ENAMETOOLONG;\n                    continue;\n                }\n                addr_index = k + 1;\n            } else {\n                error = EDNS_NO_ADDRESS;\n                i += rdlength;\n                continue;\n            }\n\n        }\n    cont:\n        i += rdlength;\n    }\n\n#if (LOGGING_MAX & D_DNS)\n    for(j = 0; j < nscount; j++) {\n        PARSE_ANSWER(\"ns\", nofail);\n        i += rdlength;\n    }\n\n    for(j = 0; j < arcount; j++) {\n        PARSE_ANSWER(\"ar\", nofail);\n        i += rdlength;\n    }\n\n nofail:\n#endif\n\n#undef PARSE_ANSWER\n\n    do_log(D_DNS, \"DNS: %d bytes\\n\", addr_index);\n    if(af < 0)\n        goto fail;\n\n    value = internAtomN(addresses, addr_index);\n    if(value == NULL) {\n        error = ENOMEM;\n        goto fail;\n    }\n\n    assert(af >= 0);\n    *id_return = id;\n    *name_return = name;\n    *value_return = value;\n    *af_return = af;\n    *ttl_return = final_ttl;\n    return 1;\n\n fail:\n    *id_return = id;\n    *name_return = name;\n    *value_return = NULL;\n    *af_return = af;\n    return -error;\n}\n\n#else\n\nstatic int\nreally_do_dns(AtomPtr name, ObjectPtr object)\n{\n    abort();\n}\n\n#endif\n"
        },
        {
          "name": "dns.h",
          "type": "blob",
          "size": 1.734375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nextern char *nameServer;\nextern int useGethostbyname;\n\n#define DNS_A 0\n#define DNS_CNAME 1\n\ntypedef struct _GethostbynameRequest {\n    AtomPtr name;\n    AtomPtr addr;\n    AtomPtr error_message;\n    int count;\n    ObjectPtr object;\n    int (*handler)(int, struct _GethostbynameRequest*);\n    void *data;\n} GethostbynameRequestRec, *GethostbynameRequestPtr;\n\n/* Note that this requires no alignment */\ntypedef struct _HostAddress {\n    char af;                     /* 4 or 6 */\n    char data[16];\n} HostAddressRec, *HostAddressPtr;\n\nvoid preinitDns(void);\nvoid initDns(void);\nint do_gethostbyname(char *name, int count,\n                     int (*handler)(int, GethostbynameRequestPtr), void *data);\n"
        },
        {
          "name": "event.c",
          "type": "blob",
          "size": 20.2197265625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifdef HAVE_FORK\nstatic volatile sig_atomic_t exitFlag = 0;\n#else\nstatic int exitFlag = 0;\n#endif\nstatic int in_signalCondition = 0;\n\nstatic TimeEventHandlerPtr timeEventQueue;\nstatic TimeEventHandlerPtr timeEventQueueLast;\n\nstruct timeval current_time;\nstruct timeval null_time = {0,0};\n\nstatic int fdEventSize = 0;\nstatic int fdEventNum = 0;\nstatic struct pollfd *poll_fds = NULL;\nstatic FdEventHandlerPtr *fdEvents = NULL, *fdEventsLast = NULL;\nint diskIsClean = 1;\n\nstatic int fds_invalid = 0;\n\nstatic inline int\ntimeval_cmp(struct timeval *t1, struct timeval *t2)\n{\n    if(t1->tv_sec < t2->tv_sec)\n        return -1;\n    else if(t1->tv_sec > t2->tv_sec)\n        return +1;\n    else if(t1->tv_usec < t2->tv_usec)\n        return -1;\n    else if(t1->tv_usec > t2->tv_usec)\n        return +1;\n    else\n        return 0;\n}\n\nstatic inline void\ntimeval_minus(struct timeval *d,\n              const struct timeval *s1, const struct timeval *s2)\n{\n    if(s1->tv_usec >= s2->tv_usec) {\n        d->tv_usec = s1->tv_usec - s2->tv_usec;\n        d->tv_sec = s1->tv_sec - s2->tv_sec;\n    } else {\n        d->tv_usec = s1->tv_usec + 1000000 - s2->tv_usec;\n        d->tv_sec = s1->tv_sec - s2->tv_sec - 1;\n    }\n}\n\nint\ntimeval_minus_usec(const struct timeval *s1, const struct timeval *s2)\n{\n    return (s1->tv_sec - s2->tv_sec) * 1000000 + s1->tv_usec - s2->tv_usec;\n}\n\n#ifdef HAVE_FORK\nstatic void\nsigexit(int signo)\n{\n    if(signo == SIGUSR1)\n        exitFlag = 1;\n    else if(signo == SIGUSR2)\n        exitFlag = 2;\n    else\n        exitFlag = 3;\n}\n#endif\n\nvoid\ninitEvents()\n{\n#ifdef HAVE_FORK\n    struct sigaction sa;\n    sigset_t ss;\n\n    sigemptyset(&ss);\n    sa.sa_handler = SIG_IGN;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGPIPE, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = sigexit;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGTERM, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = sigexit;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGHUP, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = sigexit;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGINT, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = sigexit;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGUSR1, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = sigexit;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGUSR2, &sa, NULL);\n#endif\n\n    timeEventQueue = NULL;\n    timeEventQueueLast = NULL;\n    fdEventSize = 0;\n    fdEventNum = 0;\n    poll_fds = NULL;\n    fdEvents = NULL;\n    fdEventsLast = NULL;\n}\n\nvoid\nuninitEvents(void)\n{\n#ifdef HAVE_FORK\n    struct sigaction sa;\n    sigset_t ss;\n\n    sigemptyset(&ss);\n    sa.sa_handler = SIG_DFL;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGTERM, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = SIG_DFL;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGHUP, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = SIG_DFL;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGINT, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = SIG_DFL;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGUSR1, &sa, NULL);\n\n    sigemptyset(&ss);\n    sa.sa_handler = SIG_DFL;\n    sa.sa_mask = ss;\n    sa.sa_flags = 0;\n    sigaction(SIGUSR2, &sa, NULL);\n#endif\n}\n\n#ifdef HAVE_FORK\nvoid\ninterestingSignals(sigset_t *ss)\n{\n    sigemptyset(ss);\n    sigaddset(ss, SIGTERM);\n    sigaddset(ss, SIGHUP);\n    sigaddset(ss, SIGINT);\n    sigaddset(ss, SIGUSR1);\n    sigaddset(ss, SIGUSR2);\n}\n#endif\n\nvoid\ntimeToSleep(struct timeval *time)\n{\n    if(!timeEventQueue) {\n        time->tv_sec = ~0L;\n        time->tv_usec = ~0L;\n    } else {\n        *time = timeEventQueue->time;\n    }\n}\n\nstatic TimeEventHandlerPtr\nenqueueTimeEvent(TimeEventHandlerPtr event)\n{\n    TimeEventHandlerPtr otherevent;\n\n    /* We try to optimise two cases -- the event happens very soon, or\n       it happens after most of the other events. */\n    if(timeEventQueue == NULL ||\n       timeval_cmp(&event->time, &timeEventQueue->time) < 0) {\n        /* It's the first event */\n        event->next = timeEventQueue;\n        event->previous = NULL;\n        if(timeEventQueue) {\n            timeEventQueue->previous = event;\n        } else {\n            timeEventQueueLast = event;\n        }\n        timeEventQueue = event;\n    } else if(timeval_cmp(&event->time, &timeEventQueueLast->time) >= 0) {\n        /* It's the last one */\n        event->next = NULL;\n        event->previous = timeEventQueueLast;\n        timeEventQueueLast->next = event;\n        timeEventQueueLast = event;\n    } else {\n        /* Walk from the end */\n        otherevent = timeEventQueueLast;\n        while(otherevent->previous &&\n              timeval_cmp(&event->time, &otherevent->previous->time) < 0) {\n            otherevent = otherevent->previous;\n        }\n        event->next = otherevent;\n        event->previous = otherevent->previous;\n        if(otherevent->previous) {\n            otherevent->previous->next = event;\n        } else {\n            timeEventQueue = event;\n        }\n        otherevent->previous = event;\n    }\n    return event;\n}\n\nTimeEventHandlerPtr\nscheduleTimeEvent(int seconds,\n                  int (*handler)(TimeEventHandlerPtr), int dsize, void *data)\n{\n    struct timeval when;\n    TimeEventHandlerPtr event;\n\n    if(seconds >= 0) {\n        when = current_time;\n        when.tv_sec += seconds;\n    } else {\n        when.tv_sec = 0;\n        when.tv_usec = 0;\n    }\n\n    event = malloc(sizeof(TimeEventHandlerRec) - 1 + dsize);\n    if(event == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate time event handler -- \"\n               \"discarding all objects.\\n\");\n        exitFlag = 2;\n        return NULL;\n    }\n\n    event->time = when;\n    event->handler = handler;\n    /* Let the compiler optimise the common case */\n    if(dsize == sizeof(void*))\n        memcpy(event->data, data, sizeof(void*));\n    else if(dsize > 0)\n        memcpy(event->data, data, dsize);\n\n    return enqueueTimeEvent(event);\n}\n\nvoid\ncancelTimeEvent(TimeEventHandlerPtr event)\n{\n    if(event == timeEventQueue)\n        timeEventQueue = event->next;\n    if(event == timeEventQueueLast)\n        timeEventQueueLast = event->previous;\n    if(event->next)\n        event->next->previous = event->previous;\n    if(event->previous)\n        event->previous->next = event->next;\n    free(event);\n}\n\nint\nallocateFdEventNum(int fd)\n{\n    int i;\n    if(fdEventNum < fdEventSize) {\n        i = fdEventNum;\n        fdEventNum++;\n    } else {\n        struct pollfd *new_poll_fds;\n        FdEventHandlerPtr *new_fdEvents, *new_fdEventsLast;\n        int new_size = 3 * fdEventSize / 2 + 1;\n\n        new_poll_fds = realloc(poll_fds, new_size * sizeof(struct pollfd));\n        if(!new_poll_fds)\n            return -1;\n        new_fdEvents = realloc(fdEvents, new_size * sizeof(FdEventHandlerPtr));\n        if(!new_fdEvents)\n            return -1;\n        new_fdEventsLast = realloc(fdEventsLast, \n                                   new_size * sizeof(FdEventHandlerPtr));\n        if(!new_fdEventsLast)\n            return -1;\n\n        poll_fds = new_poll_fds;\n        fdEvents = new_fdEvents;\n        fdEventsLast = new_fdEventsLast;\n        fdEventSize = new_size;\n        i = fdEventNum;\n        fdEventNum++;\n    }\n\n    poll_fds[i].fd = fd;\n    poll_fds[i].events = POLLERR | POLLHUP | POLLNVAL;\n    poll_fds[i].revents = 0;\n    fdEvents[i] = NULL;\n    fdEventsLast[i] = NULL;\n    fds_invalid = 1;\n    return i;\n}\n\nvoid\ndeallocateFdEventNum(int i)\n{\n    if(i < fdEventNum - 1) {\n        memmove(&poll_fds[i], &poll_fds[i + 1], \n                (fdEventNum - i - 1) * sizeof(struct pollfd));\n        memmove(&fdEvents[i], &fdEvents[i + 1],\n                (fdEventNum - i - 1) * sizeof(FdEventHandlerPtr));\n        memmove(&fdEventsLast[i], &fdEventsLast[i + 1],\n                (fdEventNum - i - 1) * sizeof(FdEventHandlerPtr));\n    }\n    fdEventNum--;\n    fds_invalid = 1;\n}\n\nFdEventHandlerPtr \nmakeFdEvent(int fd, int poll_events, \n            int (*handler)(int, FdEventHandlerPtr), int dsize, void *data)\n{\n    FdEventHandlerPtr event;\n\n    event = malloc(sizeof(FdEventHandlerRec) - 1 + dsize);\n    if(event == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate fd event handler -- \"\n               \"discarding all objects.\\n\");\n        exitFlag = 2;\n        return NULL;\n    }\n    event->fd = fd;\n    event->poll_events = poll_events;\n    event->handler = handler;\n    /* Let the compiler optimise the common cases */\n    if(dsize == sizeof(void*))\n        memcpy(event->data, data, sizeof(void*));\n    else if(dsize == sizeof(StreamRequestRec))\n        memcpy(event->data, data, sizeof(StreamRequestRec));\n    else if(dsize > 0)\n        memcpy(event->data, data, dsize);\n    return event;\n}\n\nFdEventHandlerPtr\nregisterFdEventHelper(FdEventHandlerPtr event)\n{\n    int i;\n    int fd = event->fd;\n\n    for(i = 0; i < fdEventNum; i++)\n        if(poll_fds[i].fd == fd)\n            break;\n\n    if(i >= fdEventNum)\n        i = allocateFdEventNum(fd);\n    if(i < 0) {\n        free(event);\n        return NULL;\n    }\n\n    event->next = NULL;\n    event->previous = fdEventsLast[i];\n    if(fdEvents[i] == NULL) {\n        fdEvents[i] = event;\n    } else {\n        fdEventsLast[i]->next = event;\n    }\n    fdEventsLast[i] = event;\n    poll_fds[i].events |= event->poll_events;\n\n    return event;\n}\n\nFdEventHandlerPtr \nregisterFdEvent(int fd, int poll_events, \n                int (*handler)(int, FdEventHandlerPtr), int dsize, void *data)\n{\n    FdEventHandlerPtr event;\n\n    event = makeFdEvent(fd, poll_events, handler, dsize, data);\n    if(event == NULL)\n        return NULL;\n\n    return registerFdEventHelper(event);\n}\n\nstatic int\nrecomputePollEvents(FdEventHandlerPtr event) \n{\n    int pe = 0;\n    while(event) {\n        pe |= event->poll_events;\n        event = event->next;\n    }\n    return pe | POLLERR | POLLHUP | POLLNVAL;\n}\n\nstatic void\nunregisterFdEventI(FdEventHandlerPtr event, int i)\n{\n    assert(i < fdEventNum && poll_fds[i].fd == event->fd);\n\n    if(fdEvents[i] == event) {\n        assert(!event->previous);\n        fdEvents[i] = event->next;\n    } else {\n        event->previous->next = event->next;\n    }\n\n    if(fdEventsLast[i] == event) {\n        assert(!event->next);\n        fdEventsLast[i] = event->previous;\n    } else {\n        event->next->previous = event->previous;\n    }\n\n    free(event);\n\n    if(fdEvents[i] == NULL) {\n        deallocateFdEventNum(i);\n    } else {\n        poll_fds[i].events = recomputePollEvents(fdEvents[i]) | \n            POLLERR | POLLHUP | POLLNVAL;\n    }\n}\n\nvoid \nunregisterFdEvent(FdEventHandlerPtr event)\n{\n    int i;\n\n    for(i = 0; i < fdEventNum; i++) {\n        if(poll_fds[i].fd == event->fd) {\n            unregisterFdEventI(event, i);\n            return;\n        }\n    }\n    abort();\n}\n\nvoid\nrunTimeEventQueue()\n{\n    TimeEventHandlerPtr event;\n    int done;\n\n    while(timeEventQueue && \n          timeval_cmp(&timeEventQueue->time, &current_time) <= 0) {\n        event = timeEventQueue;\n        timeEventQueue = event->next;\n        if(timeEventQueue)\n            timeEventQueue->previous = NULL;\n        else\n            timeEventQueueLast = NULL;\n        done = event->handler(event);\n        assert(done);\n        free(event);\n    }\n}\n\nstatic FdEventHandlerPtr\nfindEventHelper(int revents, FdEventHandlerPtr events)\n{\n    FdEventHandlerPtr event = events;\n    while(event) {\n        if(revents & event->poll_events)\n            return event;\n        event = event->next;\n    }\n    return NULL;\n}\n\n\n\nstatic FdEventHandlerPtr\nfindEvent(int revents, FdEventHandlerPtr events)\n{\n    FdEventHandlerPtr event;\n\n    assert(!(revents & POLLNVAL));\n    \n    if((revents & POLLHUP) || (revents & POLLERR)) {\n        event = findEventHelper(POLLOUT, events);\n        if(event) return event;\n\n        event = findEventHelper(POLLIN, events);\n        if(event) return event;\n        return NULL;\n    }\n\n    if(revents & POLLOUT) {\n        event = findEventHelper(POLLOUT, events);\n        if(event) return event;\n    }\n\n    if(revents & POLLIN) {\n        event = findEventHelper(POLLIN, events);\n        if(event) return event;\n    }\n    return NULL;\n}\n\ntypedef struct _FdEventHandlerPoke {\n    int fd;\n    int what;\n    int status;\n} FdEventHandlerPokeRec, *FdEventHandlerPokePtr;\n\nstatic int\npokeFdEventHandler(TimeEventHandlerPtr tevent)\n{\n    FdEventHandlerPokePtr poke = (FdEventHandlerPokePtr)tevent->data;\n    int fd = poke->fd;\n    int what = poke->what;\n    int status = poke->status;\n    int done;\n    FdEventHandlerPtr event, next;\n    int i;\n\n    for(i = 0; i < fdEventNum; i++) {\n        if(poll_fds[i].fd == fd)\n            break;\n    }\n\n    if(i >= fdEventNum)\n        return 1;\n\n    event = fdEvents[i];\n    while(event) {\n        next = event->next;\n        if(event->poll_events & what) {\n            done = event->handler(status, event);\n            if(done) {\n                if(fds_invalid)\n                    unregisterFdEvent(event);\n                else\n                    unregisterFdEventI(event, i);\n            }\n            if(fds_invalid)\n                break;\n        }\n        event = next;\n    }\n    return 1;\n}\n\nvoid \npokeFdEvent(int fd, int status, int what)\n{\n    TimeEventHandlerPtr handler;\n    FdEventHandlerPokeRec poke;\n\n    poke.fd = fd;\n    poke.status = status;\n    poke.what = what;\n\n    handler = scheduleTimeEvent(0, pokeFdEventHandler,\n                                sizeof(poke), &poke);\n    if(!handler) {\n        do_log(L_ERROR, \"Couldn't allocate handler.\\n\");\n    }\n}\n\nint\nworkToDo()\n{\n    struct timeval sleep_time;\n    int rc;\n\n    if(exitFlag)\n        return 1;\n\n    timeToSleep(&sleep_time);\n    gettimeofday(&current_time, NULL);\n    if(timeval_cmp(&sleep_time, &current_time) <= 0)\n        return 1;\n    rc = poll(poll_fds, fdEventNum, 0);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't poll\");\n        return 1;\n    }\n    return(rc >= 1);\n}\n    \nvoid\neventLoop()\n{\n    struct timeval sleep_time, timeout;\n    int rc, i, done, n;\n    FdEventHandlerPtr event;\n    int fd0;\n\n    gettimeofday(&current_time, NULL);\n\n    while(1) {\n    again:\n        if(exitFlag) {\n            if(exitFlag < 3)\n                reopenLog();\n            if(exitFlag >= 2) {\n                discardObjects(1, 0);\n                if(exitFlag >= 3)\n                    return;\n                free_chunk_arenas();\n            } else {\n                writeoutObjects(1);\n            }\n            initForbidden();\n            exitFlag = 0;\n        }\n\n        timeToSleep(&sleep_time);\n        if(sleep_time.tv_sec == -1) {\n            rc = poll(poll_fds, fdEventNum, \n                      diskIsClean ? -1 : idleTime * 1000);\n        } else if(timeval_cmp(&sleep_time, &current_time) <= 0) {\n            runTimeEventQueue();\n            continue;\n        } else {\n            gettimeofday(&current_time, NULL);\n            if(timeval_cmp(&sleep_time, &current_time) <= 0) {\n                runTimeEventQueue();\n                continue;\n            } else {\n                int t;\n                timeval_minus(&timeout, &sleep_time, &current_time);\n                t = timeout.tv_sec * 1000 + (timeout.tv_usec + 999) / 1000;\n                rc = poll(poll_fds, fdEventNum,\n                          diskIsClean ? t : MIN(idleTime * 1000, t));\n            }\n        }\n\n        gettimeofday(&current_time, NULL);\n\n        if(rc < 0) {\n            if(errno == EINTR) {\n                continue;\n            } else if(errno == ENOMEM) {\n                free_chunk_arenas();\n                do_log(L_ERROR, \n                       \"Couldn't poll: out of memory.  \"\n                       \"Sleeping for one second.\\n\");\n                sleep(1);\n            } else {\n                do_log_error(L_ERROR, errno, \"Couldn't poll\");\n                exitFlag = 3;\n            }\n            continue;\n        }\n\n        if(rc == 0) {\n            if(!diskIsClean) {\n                timeToSleep(&sleep_time);\n                if(timeval_cmp(&sleep_time, &current_time) > 0)\n                    writeoutObjects(0);\n            }\n            continue;\n        }\n\n        /* Rather than tracking all changes to the in-memory cache, we\n           assume that something changed whenever we see any activity. */\n        diskIsClean = 0;\n\n        fd0 = \n            (current_time.tv_usec ^ (current_time.tv_usec >> 16)) % fdEventNum;\n        n = rc;\n        for(i = 0; i < fdEventNum; i++) {\n            int j = (i + fd0) % fdEventNum;\n            if(n <= 0)\n                break;\n            if(poll_fds[j].revents) {\n                n--;\n                event = findEvent(poll_fds[j].revents, fdEvents[j]);\n                if(!event)\n                    continue;\n                done = event->handler(0, event);\n                if(done) {\n                    if(fds_invalid)\n                        unregisterFdEvent(event);\n                    else\n                        unregisterFdEventI(event, j);\n                }\n                if(fds_invalid) {\n                    fds_invalid = 0;\n                    goto again;\n                } \n            }\n        }\n    }\n}\n\nvoid\ninitCondition(ConditionPtr condition)\n{\n    condition->handlers = NULL;\n}\n\nConditionPtr\nmakeCondition(void)\n{\n    ConditionPtr condition;\n    condition = malloc(sizeof(ConditionRec));\n    if(condition == NULL)\n        return NULL;\n    initCondition(condition);\n    return condition;\n}\n\nConditionHandlerPtr\nconditionWait(ConditionPtr condition,\n              int (*handler)(int, ConditionHandlerPtr),\n              int dsize, void *data)\n{\n    ConditionHandlerPtr chandler;\n\n    assert(!in_signalCondition);\n\n    chandler = malloc(sizeof(ConditionHandlerRec) - 1 + dsize);\n    if(!chandler)\n        return NULL;\n\n    chandler->condition = condition;\n    chandler->handler = handler;\n    /* Let the compiler optimise the common case */\n    if(dsize == sizeof(void*))\n        memcpy(chandler->data, data, sizeof(void*));\n    else if(dsize > 0)\n        memcpy(chandler->data, data, dsize);\n\n    if(condition->handlers)\n        condition->handlers->previous = chandler;\n    chandler->next = condition->handlers;\n    chandler->previous = NULL;\n    condition->handlers = chandler;\n    return chandler;\n}\n\nvoid\nunregisterConditionHandler(ConditionHandlerPtr handler)\n{\n    ConditionPtr condition = handler->condition;\n\n    assert(!in_signalCondition);\n\n    if(condition->handlers == handler)\n        condition->handlers = condition->handlers->next;\n    if(handler->next)\n        handler->next->previous = handler->previous;\n    if(handler->previous)\n        handler->previous->next = handler->next;\n\n    free(handler);\n}\n\nvoid \nabortConditionHandler(ConditionHandlerPtr handler)\n{\n    int done;\n    done = handler->handler(-1, handler);\n    assert(done);\n    unregisterConditionHandler(handler);\n}\n\nvoid\nsignalCondition(ConditionPtr condition)\n{\n    ConditionHandlerPtr handler;\n    int done;\n\n    assert(!in_signalCondition);\n    in_signalCondition++;\n\n    handler = condition->handlers;\n    while(handler) {\n        ConditionHandlerPtr next = handler->next;\n        done = handler->handler(0, handler);\n        if(done) {\n            if(handler == condition->handlers)\n                condition->handlers = next;\n            if(next)\n                next->previous = handler->previous;\n            if(handler->previous)\n                handler->previous->next = next;\n            else\n                condition->handlers = next;\n            free(handler);\n        }\n        handler = next;\n    }\n    in_signalCondition--;\n}\n\nvoid\npolipoExit()\n{\n    exitFlag = 3;\n}\n"
        },
        {
          "name": "event.h",
          "type": "blob",
          "size": 3.404296875,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nextern struct timeval current_time;\nextern struct timeval null_time;\nextern int diskIsClean;\n\ntypedef struct _TimeEventHandler {\n    struct timeval time;\n    struct _TimeEventHandler *previous, *next;\n    int (*handler)(struct _TimeEventHandler*);\n    char data[1];\n} TimeEventHandlerRec, *TimeEventHandlerPtr;\n\ntypedef struct _FdEventHandler {\n    short fd;\n    short poll_events;\n    struct _FdEventHandler *previous, *next;\n    int (*handler)(int, struct _FdEventHandler*);\n    char data[1];\n} FdEventHandlerRec, *FdEventHandlerPtr;\n\ntypedef struct _ConditionHandler {\n    struct _Condition *condition;\n    struct _ConditionHandler *previous, *next;\n    int (*handler)(int, struct _ConditionHandler*);\n    char data[1];\n} ConditionHandlerRec, *ConditionHandlerPtr;\n\ntypedef struct _Condition {\n    ConditionHandlerPtr handlers;\n} ConditionRec, *ConditionPtr;\n\nvoid initEvents(void);\nvoid uninitEvents(void);\n#ifdef HAVE_FORK\nvoid interestingSignals(sigset_t *ss);\n#endif\n\nTimeEventHandlerPtr scheduleTimeEvent(int seconds,\n                                      int (*handler)(TimeEventHandlerPtr),\n                                      int dsize, void *data);\n\nint timeval_minus_usec(const struct timeval *s1, const struct timeval *s2)\n     ATTRIBUTE((pure));\nvoid cancelTimeEvent(TimeEventHandlerPtr);\nint allocateFdEventNum(int fd);\nvoid deallocateFdEventNum(int i);\nvoid timeToSleep(struct timeval *);\nvoid runTimeEventQueue(void);\nFdEventHandlerPtr makeFdEvent(int fd, int poll_events, \n                              int (*handler)(int, FdEventHandlerPtr), \n                              int dsize, void *data);\nFdEventHandlerPtr registerFdEvent(int fd, int poll_events,\n                                  int (*handler)(int, FdEventHandlerPtr),\n                                  int dsize, void *data);\nFdEventHandlerPtr registerFdEventHelper(FdEventHandlerPtr event);\nvoid unregisterFdEvent(FdEventHandlerPtr event);\nvoid pokeFdEvent(int fd, int status, int what);\nint workToDo(void);\nvoid eventLoop(void);\nConditionPtr makeCondition(void);\nvoid initCondition(ConditionPtr);\nvoid signalCondition(ConditionPtr condition);\nConditionHandlerPtr \nconditionWait(ConditionPtr condition,\n              int (*handler)(int, ConditionHandlerPtr),\n              int dsize, void *data);\nvoid unregisterConditionHandler(ConditionHandlerPtr);\nvoid abortConditionHandler(ConditionHandlerPtr);\nvoid polipoExit(void);\n"
        },
        {
          "name": "forbidden.c",
          "type": "blob",
          "size": 21.90625,
          "content": "/*\nCopyright (c) 2003-2010 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifndef NO_FORBIDDEN\n\n#include <regex.h>\n#include <assert.h>\n\ntypedef struct _Domain {\n    int length;\n    char domain[1];\n} DomainRec, *DomainPtr;\n\nAtomPtr forbiddenFile = NULL;\nAtomPtr forbiddenUrl = NULL;\nint forbiddenRedirectCode = 302;\n\nAtomPtr redirector = NULL;\nint redirectorRedirectCode = 302;\n\nDomainPtr *forbiddenDomains = NULL;\nregex_t *forbiddenRegex = NULL;\n\nAtomPtr uncachableFile = NULL;\nDomainPtr *uncachableDomains = NULL;\nregex_t *uncachableRegex = NULL;\n\nAtomPtr forbiddenTunnelsFile = NULL;\nDomainPtr *forbiddenTunnelsDomains = NULL;\nregex_t *forbiddenTunnelsRegex = NULL;\n\n\n/* these three are only used internally by {parse,read}DomainFile */\n/* to avoid having to pass it all as parameters */\nstatic DomainPtr *domains;\nstatic char *regexbuf;\nstatic int rlen, rsize, dlen, dsize;\n\n#ifndef NO_REDIRECTOR\nstatic pid_t redirector_pid = 0;\nstatic int redirector_read_fd = -1, redirector_write_fd = -1;\n#define REDIRECTOR_BUFFER_SIZE 1024\nstatic char *redirector_buffer = NULL;\nRedirectRequestPtr redirector_request_first = NULL,\n    redirector_request_last = NULL;\n#endif\n\nstatic int atomSetterForbidden(ConfigVariablePtr, void*);\n\nvoid\npreinitForbidden(void)\n{\n    CONFIG_VARIABLE_SETTABLE(forbiddenUrl, CONFIG_ATOM, configAtomSetter,\n                             \"URL to which forbidden requests \"\n                             \"should be redirected.\");\n    CONFIG_VARIABLE_SETTABLE(forbiddenRedirectCode, CONFIG_INT,\n                             configIntSetter,\n                             \"Redirect code, 301 or 302.\");\n    CONFIG_VARIABLE_SETTABLE(forbiddenFile, CONFIG_ATOM, atomSetterForbidden,\n                             \"File specifying forbidden URLs.\");\n#ifndef NO_REDIRECTOR\n    CONFIG_VARIABLE_SETTABLE(redirector, CONFIG_ATOM, atomSetterForbidden,\n                             \"Squid-style redirector.\");\n    CONFIG_VARIABLE_SETTABLE(redirectorRedirectCode, CONFIG_INT,\n                             configIntSetter,\n                             \"Redirect code to use with redirector.\");\n#endif\n    CONFIG_VARIABLE_SETTABLE(uncachableFile, CONFIG_ATOM, atomSetterForbidden,\n                             \"File specifying uncachable URLs.\");\n\n    CONFIG_VARIABLE_SETTABLE(forbiddenTunnelsFile, CONFIG_ATOM, atomSetterForbidden,\n                             \"File specifying forbidden tunnels.\");\n}\n\nstatic int\natomSetterForbidden(ConfigVariablePtr var, void *value)\n{\n    initForbidden();\n    return configAtomSetter(var, value);\n}\n\nint\nreadDomainFile(char *filename)\n{\n    FILE *in;\n    char buf[512];\n    char *rs;\n    int i, j, is_regex, start;\n\n    in = fopen(filename, \"r\");\n    if(in == NULL) {\n        if(errno != ENOENT)\n            do_log_error(L_ERROR, errno, \"Couldn't open file %s\", filename);\n        return -1;\n    }\n\n    while(1) {\n        rs = fgets(buf, 512, in);\n        if(rs == NULL)\n            break;\n        for(i = 0; i < 512; i++) {\n            if(buf[i] != ' ' && buf[i] != '\\t')\n                break;\n        }\n        start = i;\n        for(i = start; i < 512; i++) {\n            if(buf[i] == '#' || buf[i] == '\\r' || buf[i] == '\\n')\n                break;\n        }\n        while(i > start) {\n            if(buf[i - 1] != ' ' && buf[i - 1] != '\\t')\n                break;\n            i--;\n        }\n\n        if(i <= start)\n            continue;\n\n        /* The significant part of the line is now between start and i */\n\n        is_regex = 0;\n        for(j = start; j < i; j++) {\n            if(buf[j] == '\\\\' || buf[j] == '*' || buf[j] == '/') {\n                is_regex = 1;\n                break;\n            }\n        }\n\n        if(is_regex) {\n            while(rlen + i - start + 8 >= rsize) {\n                char *new_regexbuf;\n                new_regexbuf = realloc(regexbuf, rsize * 2 + 1);\n                if(new_regexbuf == NULL) {\n                    do_log(L_ERROR, \"Couldn't reallocate regex.\\n\");\n                    fclose(in);\n                    return -1;\n                }\n                regexbuf = new_regexbuf;\n                rsize = rsize * 2 + 1;\n            }\n            if(rlen != 0)\n                rlen = snnprintf(regexbuf, rlen, rsize, \"|\");\n            rlen = snnprintf(regexbuf, rlen, rsize, \"(\");\n            rlen = snnprint_n(regexbuf, rlen, rsize, buf + start, i - start);\n            rlen = snnprintf(regexbuf, rlen, rsize, \")\");\n        } else {\n            DomainPtr new_domain;\n            if(dlen >= dsize - 1) {\n                DomainPtr *new_domains;\n                new_domains = realloc(domains, (dsize * 2 + 1) *\n                                      sizeof(DomainPtr));\n                if(new_domains == NULL) {\n                    do_log(L_ERROR,\n                           \"Couldn't reallocate domain list.\\n\");\n                    fclose(in);\n                    return -1;\n                }\n                domains = new_domains;\n                dsize = dsize * 2 + 1;\n            }\n            new_domain = malloc(sizeof(DomainRec) - 1 + i - start);\n            if(new_domain == NULL) {\n                do_log(L_ERROR, \"Couldn't allocate domain.\\n\");\n                fclose(in);\n                return -1;\n            }\n            new_domain->length = i - start;\n            memcpy(new_domain->domain, buf + start, i - start);\n            domains[dlen++] = new_domain;\n        }\n    }\n    fclose(in);\n    return 1;\n}\n\nvoid\nparseDomainFile(AtomPtr file,\n                DomainPtr **domains_return, regex_t **regex_return)\n{\n    struct stat ss;\n    regex_t *regex;\n    int rc;\n\n    if(*domains_return) {\n        DomainPtr *domain = *domains_return;\n        while(*domain) {\n            free(*domain);\n            domain++;\n        }\n        free(*domains_return);\n        *domains_return = NULL;\n    }\n\n    if(*regex_return) {\n        regfree(*regex_return);\n        *regex_return = NULL;\n    }\n\n    if(!file || file->length == 0)\n        return;\n\n    domains = malloc(64 * sizeof(DomainPtr));\n    if(domains == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate domain list.\\n\");\n        return;\n    }\n    dlen = 0;\n    dsize = 64;\n\n    regexbuf = malloc(512);\n    if(regexbuf == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate regex.\\n\");\n        free(domains);\n        return;\n    }\n    rlen = 0;\n    rsize = 512;\n\n    rc = stat(file->string, &ss);\n    if(rc < 0) {\n        if(errno != ENOENT)\n            do_log_error(L_WARN, errno, \"Couldn't stat file %s\", file->string);\n    } else {\n        if(!S_ISDIR(ss.st_mode))\n            readDomainFile(file->string);\n        else {\n            char *fts_argv[2];\n            FTS *fts;\n            FTSENT *fe;\n            fts_argv[0] = file->string;\n            fts_argv[1] = NULL;\n            fts = fts_open(fts_argv, FTS_LOGICAL, NULL);\n            if(fts) {\n                while(1) {\n                    fe = fts_read(fts);\n                    if(!fe) break;\n                    if(fe->fts_info != FTS_D && fe->fts_info != FTS_DP &&\n                       fe->fts_info != FTS_DC && fe->fts_info != FTS_DNR)\n                        readDomainFile(fe->fts_accpath);\n                }\n                fts_close(fts);\n            } else {\n                do_log_error(L_ERROR, errno,\n                             \"Couldn't scan directory %s\", file->string);\n            }\n        }\n    }\n\n    if(dlen > 0) {\n        domains[dlen] = NULL;\n    } else {\n        free(domains);\n        domains = NULL;\n    }\n\n    if(rlen > 0) {\n        regex = malloc(sizeof(regex_t));\n        rc = regcomp(regex, regexbuf, REG_EXTENDED | REG_NOSUB);\n        if(rc != 0) {\n            char errbuf[100];\n            regerror(rc, regex, errbuf, 100);\n            do_log(L_ERROR, \"Couldn't compile regex: %s.\\n\", errbuf);\n            free(regex);\n            regex = NULL;\n        }\n    } else {\n        regex = NULL;\n    }\n    free(regexbuf);\n\n    *domains_return = domains;\n    *regex_return = regex;\n\n    return;\n}\n\nvoid\ninitForbidden(void)\n{\n    redirectorKill();\n\n    if(forbiddenFile)\n        forbiddenFile = expandTilde(forbiddenFile);\n\n    if(forbiddenFile == NULL) {\n        forbiddenFile = expandTilde(internAtom(\"~/.polipo-forbidden\"));\n        if(forbiddenFile) {\n            if(access(forbiddenFile->string, F_OK) < 0) {\n                releaseAtom(forbiddenFile);\n                forbiddenFile = NULL;\n            }\n        }\n    }\n\n    if(forbiddenFile == NULL) {\n        if(access(\"/etc/polipo/forbidden\", F_OK) >= 0)\n            forbiddenFile = internAtom(\"/etc/polipo/forbidden\");\n    }\n\n    parseDomainFile(forbiddenFile, &forbiddenDomains, &forbiddenRegex);\n\n\n    if(uncachableFile)\n        uncachableFile = expandTilde(uncachableFile);\n\n    if(uncachableFile == NULL) {\n        uncachableFile = expandTilde(internAtom(\"~/.polipo-uncachable\"));\n        if(uncachableFile) {\n            if(access(uncachableFile->string, F_OK) < 0) {\n                releaseAtom(uncachableFile);\n                uncachableFile = NULL;\n            }\n        }\n    }\n\n    if(uncachableFile == NULL) {\n        if(access(\"/etc/polipo/uncachable\", F_OK) >= 0)\n            uncachableFile = internAtom(\"/etc/polipo/uncachable\");\n    }\n\n    parseDomainFile(uncachableFile, &uncachableDomains, &uncachableRegex);\n\n    if(forbiddenTunnelsFile)\n        forbiddenTunnelsFile = expandTilde(forbiddenTunnelsFile);\n    \n    if(forbiddenTunnelsFile == NULL) {\n        forbiddenTunnelsFile = expandTilde(internAtom(\"~/.polipo-forbiddenTunnels\"));\n        if(forbiddenTunnelsFile) {\n            if(access(forbiddenTunnelsFile->string, F_OK) < 0) {\n                releaseAtom(forbiddenTunnelsFile);\n                forbiddenTunnelsFile = NULL;\n            }\n        }\n    }\n    \n    if(forbiddenTunnelsFile == NULL) {\n        if(access(\"/etc/polipo/forbiddenTunnels\", F_OK) >= 0)\n            forbiddenTunnelsFile = internAtom(\"/etc/polipo/forbiddenTunnels\");\n    }\n    \n    parseDomainFile(forbiddenTunnelsFile, &forbiddenTunnelsDomains, &forbiddenTunnelsRegex);\n    \n    return;\n}\n\nint\ntunnelIsMatched(char *url, int lurl, char *hostname, int lhost)\n{\n    DomainPtr *domain, *domains;\n    \n    domains=forbiddenTunnelsDomains;\n    if (domains) {\n\tdomain = domains;\n\twhile(*domain) {\n\t    if (lhost == (*domain)->length && \n\t\tmemcmp(hostname, (*domain)->domain, lhost)==0)\n\t\treturn 1;\n\t    domain++;\n\t}\n    }\n\n    if(forbiddenTunnelsRegex) {\n\tif(!regexec(forbiddenTunnelsRegex, url, 0, NULL, 0))\n\t    return 1;\n    }\n    return 0;\n}\n\nint\nurlIsMatched(char *url, int length, DomainPtr *domains, regex_t *regex)\n{\n    /* This requires url to be NUL-terminated. */\n    assert(url[length] == '\\0');\n\n    if(length < 8)\n        return 0;\n\n    if(lwrcmp(url, \"http://\", 7) != 0)\n        return 0;\n\n    if(domains) {\n        int i;\n        DomainPtr *domain;\n        for(i = 8; i < length; i++) {\n            if(url[i] == '/')\n                break;\n        }\n        domain = domains;\n        while(*domain) {\n            if((*domain)->length <= (i - 7) &&\n               (url[i - (*domain)->length - 1] == '.' ||\n                url[i - (*domain)->length - 1] == '/') &&\n               memcmp(url + i - (*domain)->length,\n                      (*domain)->domain,\n                      (*domain)->length) == 0)\n                return 1;\n            domain++;\n        }\n    }\n\n    if(regex)\n        return !regexec(regex, url, 0, NULL, 0);\n\n    return 0;\n}\n\nint\nurlIsUncachable(char *url, int length)\n{\n    return urlIsMatched(url, length, uncachableDomains, uncachableRegex);\n}\n\nint\nurlForbidden(AtomPtr url,\n             int (*handler)(int, AtomPtr, AtomPtr, AtomPtr, void*),\n             void *closure)\n{\n    int forbidden = urlIsMatched(url->string, url->length,\n                                 forbiddenDomains, forbiddenRegex);\n    int code = 0;\n    AtomPtr message = NULL, headers = NULL;\n\n\n    if(forbidden) {\n        message = internAtomF(\"Forbidden URL %s\", url->string);\n        if(forbiddenUrl) {\n            code = forbiddenRedirectCode;\n            headers = internAtomF(\"\\r\\nLocation: %s\", forbiddenUrl->string);\n        } else {\n            code = 403;\n        }\n    }\n\n#ifndef NO_REDIRECTOR\n    if(code == 0 && redirector) {\n        RedirectRequestPtr request;\n        request = malloc(sizeof(RedirectRequestRec));\n        if(request == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate redirect request.\\n\");\n            goto done;\n        }\n        request->url = url;\n        request->handler = handler;\n        request->data = closure;\n        if(redirector_request_first == NULL)\n            redirector_request_first = request;\n        else\n            redirector_request_last->next = request;\n        redirector_request_last = request;\n        request->next = NULL;\n        if(request == redirector_request_first)\n            redirectorTrigger();\n        return 1;\n    }\n\n#endif\n\n done:\n    handler(code, url, message, headers, closure);\n    return 1;\n}\n\n#ifndef NO_REDIRECTOR\nstatic void\nlogExitStatus(int status)\n{\n    if(WIFEXITED(status) && WEXITSTATUS(status) == 142)\n        /* See child code in runRedirector */\n        do_log(L_ERROR, \"Couldn't start redirector.\\n\");\n    else {\n        char *reason =\n            WIFEXITED(status) ? \"with status\" :\n            WIFSIGNALED(status) ? \"on signal\" :\n            \"with unknown status\";\n        int value =\n            WIFEXITED(status) ? WEXITSTATUS(status) :\n            WIFSIGNALED(status) ? WTERMSIG(status) :\n            status;\n        do_log(L_ERROR,\n               \"Redirector exited %s %d.\\n\", reason, value);\n    }\n}\n\nvoid\nredirectorKill(void)\n{\n    int rc, status, dead;\n\n    if(redirector_read_fd >= 0) {\n        rc = waitpid(redirector_pid, &status, WNOHANG);\n        dead = (rc > 0);\n        close(redirector_read_fd);\n        redirector_read_fd = -1;\n        close(redirector_write_fd);\n        redirector_write_fd = -1;\n        if(!dead) {\n            rc = kill(redirector_pid, SIGTERM);\n            if(rc < 0 && errno != ESRCH) {\n                do_log_error(L_ERROR, errno, \"Couldn't kill redirector\");\n                redirector_pid = -1;\n                return;\n            }\n            do {\n                rc = waitpid(redirector_pid, &status, 0);\n            } while(rc < 0 && errno == EINTR);\n            if(rc < 0)\n                do_log_error(L_ERROR, errno,\n                             \"Couldn't wait for redirector's death\");\n        } else\n            logExitStatus(status);\n        redirector_pid = -1;\n    }\n}\n\nstatic void\nredirectorDestroyRequest(RedirectRequestPtr request)\n{\n    assert(redirector_request_first == request);\n    redirector_request_first = request->next;\n    if(redirector_request_first == NULL)\n        redirector_request_last = NULL;\n    free(request);\n}\n\nvoid\nredirectorTrigger(void)\n{\n    RedirectRequestPtr request = redirector_request_first;\n    int rc;\n\n    if(!request)\n        return;\n\n    if(redirector_read_fd < 0) {\n        rc = runRedirector(&redirector_pid,\n                           &redirector_read_fd, &redirector_write_fd);\n        if(rc < 0) {\n            request->handler(rc, request->url, NULL, NULL, request->data);\n            redirectorDestroyRequest(request);\n            return;\n        }\n    }\n    do_stream_2(IO_WRITE, redirector_write_fd, 0,\n                request->url->string, request->url->length,\n                \"\\n\", 1,\n                redirectorStreamHandler1, request);\n}\n\nint\nredirectorStreamHandler1(int status,\n                         FdEventHandlerPtr event,\n                         StreamRequestPtr srequest)\n{\n    RedirectRequestPtr request = (RedirectRequestPtr)srequest->data;\n\n    if(status) {\n        if(status >= 0)\n            status = -EPIPE;\n        do_log_error(L_ERROR, -status, \"Write to redirector failed\");\n        goto fail;\n    }\n\n    if(!streamRequestDone(srequest))\n        return 0;\n\n    do_stream(IO_READ, redirector_read_fd, 0,\n              redirector_buffer, REDIRECTOR_BUFFER_SIZE,\n              redirectorStreamHandler2, request);\n    return 1;\n\n fail:\n    request->handler(status < 0 ? status : -EPIPE,\n                     request->url, NULL, NULL, request->data);\n    redirectorDestroyRequest(request);\n    redirectorKill();\n    return 1;\n}\n\nint\nredirectorStreamHandler2(int status,\n                         FdEventHandlerPtr event,\n                         StreamRequestPtr srequest)\n{\n    RedirectRequestPtr request = (RedirectRequestPtr)srequest->data;\n    char *c;\n    AtomPtr message;\n    AtomPtr headers;\n    int code;\n\n    if(status < 0) {\n        do_log_error(L_ERROR, -status, \"Read from redirector failed\");\n        request->handler(status, request->url, NULL, NULL, request->data);\n        goto kill;\n    }\n    c = memchr(redirector_buffer, '\\n', srequest->offset);\n    if(!c) {\n        if(!status && srequest->offset < REDIRECTOR_BUFFER_SIZE)\n            return 0;\n        do_log(L_ERROR, \"Redirector returned incomplete reply.\\n\");\n        request->handler(-EREDIRECTOR, request->url, NULL, NULL, request->data);\n        goto kill;\n    }\n    *c = '\\0';\n\n    if(srequest->offset > c + 1 - redirector_buffer)\n        do_log(L_WARN, \"Stray bytes in redirector output.\\n\");\n\n    if(c > redirector_buffer + 1 &&\n       (c - redirector_buffer != request->url->length ||\n        memcmp(redirector_buffer, request->url->string,\n               request->url->length) != 0)) {\n        code = redirectorRedirectCode;\n        message = internAtom(\"Redirected by external redirector\");\n        if(message == NULL) {\n            request->handler(-ENOMEM, request->url, NULL, NULL, request->data);\n            goto kill;\n        }\n\n        headers = internAtomF(\"\\r\\nLocation: %s\", redirector_buffer);\n        if(headers == NULL) {\n            releaseAtom(message);\n            request->handler(-ENOMEM, request->url, NULL, NULL, request->data);\n            goto kill;\n        }\n    } else {\n        code = 0;\n        message = NULL;\n        headers = NULL;\n    }\n    request->handler(code, request->url,\n                     message, headers, request->data);\n    goto cont;\n\n cont:\n    redirectorDestroyRequest(request);\n    redirectorTrigger();\n    return 1;\n\n kill:\n    redirectorKill();\n    goto cont;\n}\n\nint\nrunRedirector(pid_t *pid_return, int *read_fd_return, int *write_fd_return)\n{\n    int rc, rc2, status;\n    pid_t pid;\n    int filedes1[2], filedes2[2];\n    sigset_t ss, old_mask;\n\n    assert(redirector);\n\n    if(redirector_buffer == NULL) {\n        redirector_buffer = malloc(REDIRECTOR_BUFFER_SIZE);\n        if(redirector_buffer == NULL)\n            return -errno;\n    }\n\n    rc = pipe(filedes1);\n    if(rc < 0) {\n        rc = -errno;\n        goto fail1;\n    }\n\n\n    rc = pipe(filedes2);\n    if(rc < 0) {\n        rc = -errno;\n        goto fail2;\n    }\n\n    fflush(stdout);\n    fflush(stderr);\n    flushLog();\n\n    interestingSignals(&ss);\n    do {\n        rc = sigprocmask(SIG_BLOCK, &ss, &old_mask);\n    } while (rc < 0 && errno == EINTR);\n    if(rc < 0) {\n        rc = -errno;\n        goto fail3;\n    }\n\n    pid = fork();\n    if(pid < 0) {\n        rc = -errno;\n        goto fail4;\n    }\n\n    if(pid > 0) {\n        do {\n            rc = sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        } while(rc < 0 && errno == EINTR);\n\n        if(rc < 0) {\n            rc = -errno;\n            goto fail4;\n        }\n\n        rc = setNonblocking(filedes1[1], 1);\n        if(rc >= 0)\n            rc = setNonblocking(filedes2[0], 1);\n        if(rc < 0) {\n            rc = -errno;\n            goto fail4;\n        }\n\n        /* This is completely unnecesary -- if the redirector cannot be\n           started, redirectorStreamHandler1 will get EPIPE straight away --,\n           but it improves error messages somewhat. */\n        rc = waitpid(pid, &status, WNOHANG);\n        if(rc > 0) {\n            logExitStatus(status);\n            rc = -EREDIRECTOR;\n            goto fail4;\n        } else if(rc < 0) {\n            rc = -errno;\n            goto fail4;\n        }\n\n        *read_fd_return = filedes2[0];\n        *write_fd_return = filedes1[1];\n\n        *pid_return = pid;\n        /* This comes at the end so that the fail* labels can work */\n        close(filedes1[0]);\n        close(filedes2[1]);\n    } else {\n        close(filedes1[1]);\n        close(filedes2[0]);\n        uninitEvents();\n        do {\n            rc = sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        } while (rc < 0 && errno == EINTR);\n        if(rc < 0)\n            exit(142);\n\n        if(filedes1[0] != 0)\n            dup2(filedes1[0], 0);\n        if(filedes2[1] != 1)\n            dup2(filedes2[1], 1);\n\n        execlp(redirector->string, redirector->string, (char*)NULL);\n        exit(142);\n        /* NOTREACHED */\n    }\n    return 1;\n\n fail4:\n    do {\n        rc2 = sigprocmask(SIG_SETMASK, &old_mask, NULL);\n    } while(rc2 < 0 && errno == EINTR);\n fail3:\n    close(filedes2[0]);\n    close(filedes2[1]);\n fail2:\n    close(filedes1[0]);\n    close(filedes1[1]);\n fail1:\n    free(redirector_buffer);\n    redirector_buffer = NULL;\n    return rc;\n}\n\n#else\n\nvoid\nredirectorKill(void)\n{\n    return;\n}\n\n#endif\n\n#else\n\nvoid\npreinitForbidden()\n{\n    return;\n}\n\nvoid\ninitForbidden()\n{\n    return;\n}\n\nint\ntunnelIsMatched(char *url, int lurl, char *hostname, int lhost)\n{\n    return 0;\n}\n\nint\nurlIsUncachable(char *url, int length)\n{\n    return 0;\n}\n\nint\nurlForbidden(AtomPtr url,\n             int (*handler)(int, AtomPtr, AtomPtr, AtomPtr, void*),\n             void *closure)\n{\n    handler(0, url, NULL, NULL, closure);\n    return 1;\n}\n\n#endif\n"
        },
        {
          "name": "forbidden.h",
          "type": "blob",
          "size": 2.044921875,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nextern AtomPtr forbiddenUrl;\nextern int forbiddenRedirectCode;\n\ntypedef struct _RedirectRequest {\n    AtomPtr url;\n    struct _RedirectRequest *next;\n    int (*handler)(int, AtomPtr, AtomPtr, AtomPtr, void*);\n    void *data;\n} RedirectRequestRec, *RedirectRequestPtr;\n\nvoid preinitForbidden(void);\nvoid initForbidden(void);\nint urlIsUncachable(char *url, int length);\nint urlForbidden(AtomPtr url,\n                 int (*handler)(int, AtomPtr, AtomPtr, AtomPtr, void*),\n                 void *closure);\nvoid redirectorKill(void);\nint redirectorStreamHandler1(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest);\nint redirectorStreamHandler2(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest);\nvoid redirectorTrigger(void);\nint \nrunRedirector(pid_t *pid_return, int *read_fd_return, int *write_fd_return);\n\nint tunnelIsMatched(char *url, int lurl, char *hostname, int lhost);\n"
        },
        {
          "name": "forbidden.sample",
          "type": "blob",
          "size": 0.439453125,
          "content": "# Sample forbidden URLs file for polipo.  -*-sh-*-\n# Put this in /etc/polipo/forbidden or in ~/.polipo-forbidden.\n\n# Forbid all hosts belonging to a given domain name:\n\n#counter.com\n#hitbox.com\n#doubleclick.net\n#www.cashcount.com\n\n# Forbid all hosts contaning a string matching a given regex.  Note\n# that you need to quote dots, so that a regex is not misinterpreted\n# as a domain name.\n\n#^http://[^/]*counter\\.com\n#/ads/\n#/phpAdsNew\n#counting\\.php\n"
        },
        {
          "name": "fts_compat.c",
          "type": "blob",
          "size": 7.798828125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* This file implements just enough of the fts family of functions\n   to make Polipo happy. */\n\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n#ifndef _WIN32\n#include <unistd.h>\n#include <dirent.h>\n#else\n#include \"dirent_compat.h\"\n#endif\n#include <sys/stat.h>\n#include <errno.h>\n#include <string.h>\n\n#include \"fts_compat.h\"\n\nstatic char *\ngetcwd_a()\n{\n    char buf[256];\n    char *ret;\n    ret = getcwd(buf, 256);\n    if(ret == NULL)\n        return NULL;\n    return strdup(buf);\n}\n\nstatic char *\nmkfilename(const char *path, char *filename)\n{\n    int n = strlen(path);\n    char *buf = malloc(n + 1 + strlen(filename) + 1);\n    if(buf == NULL)\n        return NULL;\n    memcpy(buf, path, n);\n    if(buf[n - 1] != '/')\n        buf[n++] = '/';\n    strcpy(buf + n, filename);\n    return buf;\n}\n\nstatic int\nsplit(const char *path, int *slash_return, int *dlen, int *blen)\n{\n    int len; int slash;\n    len = strlen(path);\n    while(len > 0 && path[len - 1] == '/')\n        len--;\n    if(len == 0)\n        return -1;\n    slash = len - 1;\n    while(slash >= 0 && path[slash] != '/')\n        slash--;\n\n    if(slash_return) *slash_return = slash;\n    if(dlen) *dlen = slash + 1;\n    if(blen) *blen = len - slash - 1;\n    return 1;\n}\n\nstatic char *\nbasename_a(const char *path)\n{\n    int blen, slash;\n    char *b;\n    int rc;\n\n    rc = split(path, &slash, NULL, &blen);\n    if(rc < 0 || blen == 0)\n        return NULL;\n\n    b = malloc(blen + 1);\n    if(b == NULL)\n        return NULL;\n    memcpy(b, path + slash + 1, blen);\n    b[blen] = '\\0';\n    return b;\n}\n\nstatic char *\ndirname_a(const char *path)\n{\n    int dlen;\n    int rc;\n    char *d;\n\n    rc = split(path, NULL, &dlen, NULL);\n    if(rc < 0)\n        return NULL;\n\n    d = malloc(dlen + 1);\n    if(d == NULL)\n        return NULL;\n    memcpy(d, path, dlen);\n    d[dlen] = '\\0';\n    return d;\n}\n\n#if defined(__svr4__) || defined(SVR4)\nstatic int\ndirfd(DIR *dir)\n{\n    return dir->dd_fd;\n}\n#endif\n\n/*\n * Make the directory identified by the argument the current directory.\n */\n#ifdef WIN32 /*MINGW*/\nint\nchange_to_dir(DIR *dir)\n{\n    errno = ENOSYS;\n    return -1;\n}\n#else\nint\nchange_to_dir(DIR *dir)\n{\n    return fchdir(dirfd(dir));\n}\n#endif\n\nFTS*\nfts_open(char * const *path_argv, int options,\n         int (*compar)(const FTSENT **, const FTSENT **))\n{\n    FTS *fts;\n    DIR *dir;\n    char *cwd;\n    int rc;\n\n    if(options != FTS_LOGICAL || compar != NULL || path_argv[1] != NULL) {\n        errno = ENOSYS;\n        return NULL;\n    }\n\n    dir = opendir(path_argv[0]);\n    if(dir == NULL)\n        return NULL;\n\n    fts = calloc(sizeof(FTS), 1);\n    if(fts == NULL) {\n        int save = errno;\n        closedir(dir);\n        errno = save;\n        return NULL;\n    }\n\n    cwd = getcwd_a();\n    if(cwd == NULL) {\n        int save = errno;\n        free(fts);\n        closedir(dir);\n        errno = save;\n        return NULL;\n    }\n\n    rc = change_to_dir(dir);\n    if(rc < 0) {\n        int save = errno;\n        free(cwd);\n        free(fts);\n        closedir(dir);\n        errno = save;\n        return NULL;\n    }\n\n    fts->depth = 0;\n    fts->dir[0] = dir;\n    fts->cwd0 = cwd;\n    fts->cwd = strdup(path_argv[0]);\n    return fts;\n}\n\nint\nfts_close(FTS *fts)\n{\n    int save = 0;\n    int rc;\n\n    if(fts->ftsent.fts_path) {\n        free(fts->ftsent.fts_path);\n        fts->ftsent.fts_path = NULL;\n    }\n\n    if(fts->dname) {\n        free(fts->dname);\n        fts->dname = NULL;\n    }\n\n    rc = chdir(fts->cwd0);\n    if(rc < 0)\n        save = errno;\n\n    while(fts->depth >= 0) {\n        closedir(fts->dir[fts->depth]);\n        fts->depth--;\n    }\n\n    free(fts->cwd0);\n    if(fts->cwd) free(fts->cwd);\n    free(fts);\n\n    if(rc < 0) {\n        errno = save;\n        return -1;\n    }\n    return 0;\n}\n\nFTSENT *\nfts_read(FTS *fts)\n{\n    struct dirent *dirent;\n    int rc;\n    char *name;\n    char buf[1024];\n\n    if(fts->ftsent.fts_path) {\n        free(fts->ftsent.fts_path);\n        fts->ftsent.fts_path = NULL;\n    }\n\n    if(fts->dname) {\n        free(fts->dname);\n        fts->dname = NULL;\n    }\n\n again:\n    dirent = readdir(fts->dir[fts->depth]);\n    if(dirent == NULL) {\n        char *newcwd = NULL;\n        closedir(fts->dir[fts->depth]);\n        fts->dir[fts->depth] = NULL;\n        fts->depth--;\n        if(fts->depth >= 0) {\n            fts->dname = basename_a(fts->cwd);\n            if(fts->dname == NULL)\n                goto error;\n            newcwd = dirname_a(fts->cwd);\n            if(newcwd == NULL)\n                goto error;\n        }\n        if(fts->cwd) free(fts->cwd);\n        fts->cwd = NULL;\n        if(fts->depth < 0)\n            return NULL;\n        rc = change_to_dir(fts->dir[fts->depth]);\n        if(rc < 0) {\n            free(newcwd);\n            goto error;\n        }\n        fts->cwd = newcwd;\n        name = fts->dname;\n        fts->ftsent.fts_info = FTS_DP;\n        goto done;\n    }\n\n    name = dirent->d_name;\n\n again2:\n    rc = stat(name, &fts->ftstat);\n    if(rc < 0) {\n        fts->ftsent.fts_info = FTS_NS;\n        goto error2;\n    }\n\n    if(S_ISDIR(fts->ftstat.st_mode)) {\n        char *newcwd;\n        DIR *dir;\n\n        if(strcmp(name, \".\") == 0 || strcmp(name, \"..\") == 0)\n            goto again;\n\n        if(fts->depth >= FTS_MAX_DEPTH) {\n            errno = ENFILE;\n            goto error;\n        }\n        dir = opendir(dirent->d_name);\n        if(dir == NULL) {\n            if(errno == EACCES) {\n                fts->ftsent.fts_info = FTS_DNR;\n                goto error2;\n            } else\n                goto error;\n        }\n        newcwd = mkfilename(fts->cwd, dirent->d_name);\n        rc = change_to_dir(dir);\n        if(rc < 0) {\n            free(newcwd);\n            goto error;\n        }\n        free(fts->cwd);\n        fts->cwd = newcwd;\n        fts->ftsent.fts_info = FTS_D;\n        fts->depth++;\n        fts->dir[fts->depth] = dir;\n        goto done;\n    } else if(S_ISREG(fts->ftstat.st_mode)) {\n        fts->ftsent.fts_info = FTS_F;\n        goto done;\n#ifdef S_ISLNK\n    } else if(S_ISLNK(fts->ftstat.st_mode)) {\n        int rc;\n        rc = readlink(name, buf, 1024);\n        if(rc < 0)\n            goto error;\n        if(rc >= 1023) {\n            errno = ENAMETOOLONG;\n            goto error;\n        }\n        buf[rc] = '\\0';\n        name = buf;\n        if(access(buf, F_OK) >= 0)\n            goto again2;\n        fts->ftsent.fts_info = FTS_SLNONE;\n        goto done;\n#endif\n    } else {\n        fts->ftsent.fts_info = FTS_DEFAULT;\n        goto done;\n    }\n    \n done:\n    if(fts->cwd == NULL)\n        fts->cwd = getcwd_a();\n    if(fts->cwd == NULL) goto error;\n    fts->ftsent.fts_path = mkfilename(fts->cwd, name);\n    if(fts->ftsent.fts_path == NULL) goto error;\n    fts->ftsent.fts_accpath = name;\n    fts->ftsent.fts_statp = &fts->ftstat;\n    return &fts->ftsent;\n\n error:\n    fts->ftsent.fts_info = FTS_ERR;\n error2:\n    fts->ftsent.fts_errno = errno;\n    return &fts->ftsent;\n}\n"
        },
        {
          "name": "fts_compat.h",
          "type": "blob",
          "size": 1.8662109375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#ifndef _FTS_COMPAT_H\n#define _FTS_COMPAT_H\n\n#ifndef FTS_MAX_DEPTH\n#define FTS_MAX_DEPTH 4\n#endif\n\n#define FTS_LOGICAL 1\n\n#define FTS_F 1\n#define FTS_D 2\n#define FTS_DP 3\n#define FTS_DC 4\n#define FTS_NS 5\n#define FTS_NSOK 6\n#define FTS_DNR 7\n#define FTS_SLNONE 8\n#define FTS_DEFAULT 9\n#define FTS_ERR 10\n\nstruct _FTSENT {\n    unsigned short fts_info;\n    char *fts_path;\n    char *fts_accpath;\n    struct stat *fts_statp;\n    int fts_errno;\n};\n\ntypedef struct _FTSENT FTSENT;\n\nstruct _FTS {\n    int depth;\n    DIR *dir[FTS_MAX_DEPTH];\n    char *cwd0, *cwd;\n    struct _FTSENT ftsent;\n    struct stat ftstat;\n    char *dname;\n};\n\ntypedef struct _FTS FTS;\n\nFTS* fts_open(char * const *path_argv, int options,\n              int (*compar)(const FTSENT **, const FTSENT **));\nint fts_close(FTS *fts);\nFTSENT * fts_read(FTS *fts);\n\n#endif\n"
        },
        {
          "name": "ftsimport.c",
          "type": "blob",
          "size": 0.158203125,
          "content": "#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include \"polipo.h\"\n\n#ifndef HAVE_FTS\n#include \"fts_compat.c\"\n#else\nstatic int dummy ATTRIBUTE((unused));\n#endif\n\n"
        },
        {
          "name": "ftsimport.h",
          "type": "blob",
          "size": 0.0693359375,
          "content": "#ifdef HAVE_FTS\n#include <fts.h>\n#else\n#include \"fts_compat.h\"\n#endif\n\n"
        },
        {
          "name": "http.c",
          "type": "blob",
          "size": 30.537109375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nint disableProxy = 0;\nAtomPtr proxyName = NULL;\nint proxyPort = 8123;\n\nint clientTimeout = 120;\nint serverTimeout = 90;\nint serverIdleTimeout = 45;\n\nint bigBufferSize = (32 * 1024);\n\nAtomPtr displayName = NULL;\n\nAtomPtr authRealm = NULL;\nAtomPtr authCredentials = NULL;\n\nAtomPtr parentAuthCredentials = NULL;\n\nAtomListPtr allowedClients = NULL;\nNetAddressPtr allowedNets = NULL;\n\nIntListPtr allowedPorts = NULL;\nIntListPtr tunnelAllowedPorts = NULL;\nint expectContinue = 1;\nint dontTrustVaryETag = 1;\n\nAtomPtr atom100Continue;\n\nint disableVia = 1;\n\n/* 0 means that all failures lead to errors.  1 means that failures to\n   connect are reported in a Warning header when stale objects are\n   served.  2 means that only missing data is fetched from the net,\n   stale data is served without revalidation (browser-side\n   Cache-Control directives are still honoured).  3 means that no\n   connections are ever attempted. */\n\nint proxyOffline = 0;\nint relaxTransparency = 0;\nAtomPtr proxyAddress = NULL;\n\nstatic int timeoutSetter(ConfigVariablePtr var, void *value);\n\nvoid\npreinitHttp()\n{\n    proxyAddress = internAtom(\"127.0.0.1\");\n    CONFIG_VARIABLE_SETTABLE(disableProxy, CONFIG_BOOLEAN, configIntSetter,\n                             \"Whether to be a web server only.\");\n    CONFIG_VARIABLE_SETTABLE(proxyOffline, CONFIG_BOOLEAN, configIntSetter,\n                             \"Avoid contacting remote servers.\");\n    CONFIG_VARIABLE_SETTABLE(relaxTransparency, CONFIG_TRISTATE, \n                             configIntSetter,\n                             \"Avoid contacting remote servers.\");\n    CONFIG_VARIABLE(proxyPort, CONFIG_INT,\n                    \"The TCP port on which the proxy listens.\");\n    CONFIG_VARIABLE(proxyAddress, CONFIG_ATOM_LOWER,\n                    \"The IP address on which the proxy listens.\");\n    CONFIG_VARIABLE_SETTABLE(proxyName, CONFIG_ATOM_LOWER, configAtomSetter,\n                             \"The name by which the proxy is known.\");\n    CONFIG_VARIABLE_SETTABLE(clientTimeout, CONFIG_TIME, \n                             timeoutSetter, \"Client-side timeout.\");\n    CONFIG_VARIABLE_SETTABLE(serverTimeout, CONFIG_TIME,\n                             timeoutSetter, \"Server-side timeout.\");\n    CONFIG_VARIABLE_SETTABLE(serverIdleTimeout, CONFIG_TIME,\n                             timeoutSetter, \"Server-side idle timeout.\");\n    CONFIG_VARIABLE(authRealm, CONFIG_ATOM,\n                    \"Authentication realm.\");\n    CONFIG_VARIABLE(displayName, CONFIG_ATOM,\n                    \"Server name displayed on error pages.\");\n    CONFIG_VARIABLE(authCredentials, CONFIG_PASSWORD,\n                    \"username:password.\");\n    CONFIG_VARIABLE(parentAuthCredentials, CONFIG_PASSWORD,\n                    \"username:password.\");\n    CONFIG_VARIABLE(allowedClients, CONFIG_ATOM_LIST_LOWER,\n                    \"Networks from which clients are allowed to connect.\");\n    CONFIG_VARIABLE(tunnelAllowedPorts, CONFIG_INT_LIST,\n                    \"Ports to which tunnelled connections are allowed.\");\n    CONFIG_VARIABLE(allowedPorts, CONFIG_INT_LIST,\n                    \"Ports to which connections are allowed.\");\n    CONFIG_VARIABLE(expectContinue, CONFIG_TRISTATE,\n                    \"Send Expect-Continue to servers.\");\n    CONFIG_VARIABLE(bigBufferSize, CONFIG_INT,\n                    \"Size of big buffers (max size of headers).\");\n    CONFIG_VARIABLE_SETTABLE(disableVia, CONFIG_BOOLEAN, configIntSetter,\n                             \"Don't use Via headers.\");\n    CONFIG_VARIABLE(dontTrustVaryETag, CONFIG_TRISTATE,\n                    \"Whether to trust the ETag when there's Vary.\");\n    preinitHttpParser();\n}\n\nstatic int\ntimeoutSetter(ConfigVariablePtr var, void *value)\n{\n    configIntSetter(var, value);\n    if(clientTimeout <= serverTimeout)\n        clientTimeout = serverTimeout + 1;\n    return 1;\n}\n\nvoid\ninitHttp()\n{\n    char *buf = NULL;\n    int namelen;\n    int n;\n    struct hostent *host;\n\n    initHttpParser();\n\n    atom100Continue = internAtom(\"100-continue\");\n\n    if(clientTimeout <= serverTimeout) {\n        clientTimeout = serverTimeout + 1;\n        do_log(L_WARN, \"Value of clientTimeout too small -- setting to %d.\\n\",\n               clientTimeout);\n    }\n\n    if(displayName == NULL)\n        displayName = internAtom(\"Polipo\");\n\n    if(authCredentials != NULL && authRealm == NULL)\n        authRealm = internAtom(\"Polipo\");\n\n    if(allowedClients) {\n        allowedNets = parseNetAddress(allowedClients);\n        if(allowedNets == NULL)\n            exit(1);\n    }\n\n    if(allowedPorts == NULL) {\n        allowedPorts = makeIntList(0);\n        if(allowedPorts == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate allowedPorts.\\n\");\n            exit(1);\n        }\n        intListCons(80, 100, allowedPorts);\n        intListCons(1024, 0xFFFF, allowedPorts);\n    }\n\n    if(tunnelAllowedPorts == NULL) {\n        tunnelAllowedPorts = makeIntList(0);\n        if(tunnelAllowedPorts == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate tunnelAllowedPorts.\\n\");\n            exit(1);\n        }\n        intListCons(22, 22, tunnelAllowedPorts);   /* ssh */\n        intListCons(80, 80, tunnelAllowedPorts);   /* HTTP */\n        intListCons(109, 110, tunnelAllowedPorts); /* POP 2 and 3*/\n        intListCons(143, 143, tunnelAllowedPorts); /* IMAP 2/4 */\n        intListCons(443, 443, tunnelAllowedPorts); /* HTTP/SSL */\n        intListCons(873, 873, tunnelAllowedPorts); /* rsync */\n        intListCons(993, 993, tunnelAllowedPorts); /* IMAP/SSL */\n        intListCons(995, 995, tunnelAllowedPorts); /* POP/SSL */\n        intListCons(2401, 2401, tunnelAllowedPorts); /* CVS */\n        intListCons(5222, 5223, tunnelAllowedPorts); /* Jabber */\n        intListCons(9418, 9418, tunnelAllowedPorts); /* Git */\n    }\n\n    if(proxyName)\n        return;\n\n    buf = get_chunk();\n    if(buf == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate chunk for host name.\\n\");\n        goto fail;\n    }\n\n    n = gethostname(buf, CHUNK_SIZE);\n    if(n != 0) {\n        do_log_error(L_WARN, errno, \"Gethostname\");\n        strcpy(buf, \"polipo\");\n        goto success;\n    }\n    /* gethostname doesn't necessarily NUL-terminate on overflow */\n    buf[CHUNK_SIZE - 1] = '\\0';\n\n    if(strcmp(buf, \"(none)\") == 0 ||\n       strcmp(buf, \"localhost\") == 0 ||\n       strcmp(buf, \"localhost.localdomain\") == 0) {\n        do_log(L_WARN, \"Couldn't determine host name -- using ``polipo''.\\n\");\n        strcpy(buf, \"polipo\");\n        goto success;\n    }\n\n    if(strchr(buf, '.') != NULL)\n        goto success;\n\n    host = gethostbyname(buf);\n    if(host == NULL) {\n        goto success;\n    }\n\n    if(host->h_addrtype != AF_INET)\n        goto success;\n\n    host = gethostbyaddr(host->h_addr_list[0], host->h_length,  AF_INET);\n\n    if(!host || !host->h_name || strcmp(host->h_name, \"localhost\") == 0 ||\n       strcmp(host->h_name, \"localhost.localdomain\") == 0)\n        goto success;\n\n    namelen = strlen(host->h_name);\n    if(namelen >= CHUNK_SIZE) {\n        do_log(L_ERROR, \"Host name too long.\\n\");\n        goto success;\n    }\n\n    memcpy(buf, host->h_name, namelen + 1);\n\n success:\n    proxyName = internAtom(buf);\n    if(proxyName == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate proxy name.\\n\");\n        goto fail;\n    }\n    dispose_chunk(buf);\n    return;\n\n fail:\n    if(buf)\n        dispose_chunk(buf);\n    exit(1);\n    return;\n}\n\nint\nhttpSetTimeout(HTTPConnectionPtr connection, int secs)\n{\n    TimeEventHandlerPtr new;\n\n    if(connection->timeout)\n        cancelTimeEvent(connection->timeout);\n    connection->timeout = NULL;\n\n    if(secs > 0) {\n        new = scheduleTimeEvent(secs, httpTimeoutHandler,\n                                sizeof(connection), &connection);\n        if(!new) {\n            do_log(L_ERROR, \"Couldn't schedule timeout for connection 0x%lx\\n\",\n                   (unsigned long)connection);\n            return -1;\n        }\n    } else {\n        new = NULL;\n    }\n\n    connection->timeout = new;\n    return 1;\n}\n\nint \nhttpTimeoutHandler(TimeEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n\n    if(connection->fd >= 0) {\n        int rc;\n        rc = shutdown(connection->fd, 2);\n        if(rc < 0 && errno != ENOTCONN)\n                do_log_error(L_ERROR, errno, \"Timeout: shutdown failed\");\n        pokeFdEvent(connection->fd, -EDOTIMEOUT, POLLIN | POLLOUT);\n    }\n    connection->timeout = NULL;\n    return 1;\n}\n\nint\nhttpWriteObjectHeaders(char *buf, int offset, int len,\n                       ObjectPtr object, int from, int to)\n{\n    int n = offset;\n    CacheControlRec cache_control;\n\n    cache_control.flags = object->cache_control;\n    cache_control.max_age = object->max_age;\n    cache_control.s_maxage = object->s_maxage;\n    cache_control.max_stale = -1;\n    cache_control.min_fresh = -1;\n\n    if(from <= 0 && to < 0) {\n        if(object->length >= 0) {\n            n = snnprintf(buf, n, len,\n                          \"\\r\\nContent-Length: %d\", object->length);\n        }\n    } else {\n        if(to >= 0) {\n            n = snnprintf(buf, n, len,\n                          \"\\r\\nContent-Length: %d\", to - from);\n        }\n    }\n\n    if(from > 0 || to > 0) {\n        if(object->length >= 0) {\n            if(from >= to) {\n                n = snnprintf(buf, n, len,\n                              \"\\r\\nContent-Range: bytes */%d\",\n                              object->length);\n            } else {\n                n = snnprintf(buf, n, len,\n                              \"\\r\\nContent-Range: bytes %d-%d/%d\",\n                              from, to - 1, \n                              object->length);\n            }\n        } else {\n            if(to >= 0) {\n                n = snnprintf(buf, n, len,\n                              \"\\r\\nContent-Range: bytes %d-/*\",\n                              from);\n            } else {\n                n = snnprintf(buf, n, len,\n                              \"\\r\\nContent-Range: bytes %d-%d/*\",\n                              from, to);\n            }\n        }\n    }\n        \n    if(object->etag) {\n        n = snnprintf(buf, n, len, \"\\r\\nETag: \\\"%s\\\"\", object->etag);\n    }\n    if((object->flags & OBJECT_LOCAL) || object->date >= 0) {\n        n = snnprintf(buf, n, len, \"\\r\\nDate: \");\n        n = format_time(buf, n, len, \n                        (object->flags & OBJECT_LOCAL) ?\n                        current_time.tv_sec : object->date);\n        if(n < 0)\n            goto fail;\n    }\n\n    if(object->last_modified >= 0) {\n        n = snnprintf(buf, n, len, \"\\r\\nLast-Modified: \");\n        n = format_time(buf, n, len, object->last_modified);\n        if(n < 0)\n            goto fail;\n    }\n\n    if(object->expires >= 0) {\n        n = snnprintf(buf, n, len, \"\\r\\nExpires: \");\n        n = format_time(buf, n, len, object->expires);\n        if(n < 0)\n            goto fail;\n    }\n\n    n = httpPrintCacheControl(buf, n, len,\n                              object->cache_control, &cache_control);\n    if(n < 0)\n        goto fail;\n\n    if(!disableVia && object->via)\n        n = snnprintf(buf, n, len, \"\\r\\nVia: %s\", object->via->string);\n\n    if(object->headers)\n        n = snnprint_n(buf, n, len, object->headers->string,\n                       object->headers->length);\n\n    if(n < len)\n        return n;\n    else\n        return -1;\n\n fail:\n    return -1;\n}\n\nstatic int\ncachePrintSeparator(char *buf, int offset, int len,\n                    int subsequent)\n{\n    int n = offset;\n    if(subsequent)\n        n = snnprintf(buf, offset, len, \", \");\n    else\n        n = snnprintf(buf, offset, len, \"\\r\\nCache-Control: \");\n    return n;\n}\n\nint\nhttpPrintCacheControl(char *buf, int offset, int len,\n                      int flags, CacheControlPtr cache_control)\n{\n    int n = offset;\n    int sub = 0;\n\n#define PRINT_SEP() \\\n    do {\\\n        n = cachePrintSeparator(buf, n, len, sub); \\\n        sub = 1; \\\n    } while(0)\n\n    if(cache_control)\n        flags |= cache_control->flags;\n\n    if(flags & CACHE_NO) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"no-cache\");\n    }\n    if(flags & CACHE_PUBLIC) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"public\");\n    }\n    if(flags & CACHE_PRIVATE) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"private\");\n    }\n    if(flags & CACHE_NO_STORE) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"no-store\");\n    }\n    if(flags & CACHE_NO_TRANSFORM) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"no-transform\");\n    }\n    if(flags & CACHE_MUST_REVALIDATE) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"must-revalidate\");\n    }\n    if(flags & CACHE_PROXY_REVALIDATE) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"proxy-revalidate\");\n    }\n    if(flags & CACHE_ONLY_IF_CACHED) {\n        PRINT_SEP();\n        n = snnprintf(buf, n, len, \"only-if-cached\");\n    }\n    if(cache_control) {\n        if(cache_control->max_age >= 0) {\n            PRINT_SEP();\n            n = snnprintf(buf, n, len, \"max-age=%d\",\n                          cache_control->max_age);\n        }\n        if(cache_control->s_maxage >= 0) {\n            PRINT_SEP();\n            n = snnprintf(buf, n, len, \"s-maxage=%d\", \n                          cache_control->s_maxage);\n        }\n        if(cache_control->min_fresh > 0) {\n            PRINT_SEP();\n            n = snnprintf(buf, n, len, \"min-fresh=%d\",\n                          cache_control->min_fresh);\n        }\n        if(cache_control->max_stale > 0) {\n            PRINT_SEP();\n            n = snnprintf(buf, n, len, \"max-stale=%d\",\n                          cache_control->min_fresh);\n        }\n    }\n    return n;\n#undef PRINT_SEP\n}\n\nchar *\nhttpMessage(int code)\n{\n    switch(code) {\n    case 200:\n        return \"Okay\";\n    case 206:\n        return \"Partial content\";\n    case 300:\n        return \"Multiple choices\";\n    case 301:\n        return \"Moved permanently\";\n    case 302:\n        return \"Found\";\n    case 303:\n        return \"See other\";\n    case 304:\n        return \"Not changed\";\n    case 307:\n        return \"Temporary redirect\";\n    case 401:\n        return \"Authentication Required\";\n    case 403:\n        return \"Forbidden\";\n    case 404:\n        return \"Not found\";\n    case 405:\n        return \"Method not allowed\";\n    case 407:\n        return \"Proxy authentication required\";\n    default:\n        return \"Unknown error code\";\n    }\n}\n\nint\nhtmlString(char *buf, int n, int len, char *s, int slen)\n{\n    int i = 0;\n    while(i < slen && n + 5 < len) {\n        switch(s[i]) {\n        case '&':\n            buf[n++] = '&'; buf[n++] = 'a'; buf[n++] = 'm'; buf[n++] = 'p';\n            buf[n++] = ';';\n            break;\n        case '<':\n            buf[n++] = '&'; buf[n++] = 'l'; buf[n++] = 't'; buf[n++] = ';';\n            break;\n        case '>':\n            buf[n++] = '&'; buf[n++] = 'g'; buf[n++] = 't'; buf[n++] = ';';\n            break;\n        case '\"':\n            buf[n++] = '&'; buf[n++] = 'q'; buf[n++] = 'u'; buf[n++] = 'o';\n            buf[n++] = 't'; buf[n++] = ';';\n            break;\n        case '\\0':\n            break;\n        default:\n            buf[n++] = s[i];\n        }\n        i++;\n    }\n    return n;\n}\n\nvoid\nhtmlPrint(FILE *out, char *s, int slen)\n{\n    int i;\n    for(i = 0; i < slen; i++) {\n        switch(s[i]) {\n        case '&':\n            fputs(\"&amp;\", out);\n            break;\n        case '<':\n            fputs(\"&lt;\", out);\n            break;\n        case '>':\n            fputs(\"&gt;\", out);\n            break;\n        default:\n            fputc(s[i], out);\n        }\n    }\n}\n\nHTTPConnectionPtr\nhttpMakeConnection()\n{\n    HTTPConnectionPtr connection;\n    connection = malloc(sizeof(HTTPConnectionRec));\n    if(connection == NULL)\n        return NULL;\n    connection->flags = 0;\n    connection->fd = -1;\n    connection->buf = NULL;\n    connection->len = 0;\n    connection->offset = 0;\n    connection->request = NULL;\n    connection->request_last = NULL;\n    connection->serviced = 0;\n    connection->version = HTTP_UNKNOWN;\n    connection->time = current_time.tv_sec;\n    connection->timeout = NULL;\n    connection->te = TE_IDENTITY;\n    connection->reqbuf = NULL;\n    connection->reqlen = 0;\n    connection->reqbegin = 0;\n    connection->reqoffset = 0;\n    connection->bodylen = -1;\n    connection->reqte = TE_IDENTITY;\n    connection->chunk_remaining = 0;\n    connection->server = NULL;\n    connection->pipelined = 0;\n    connection->connecting = 0;\n    connection->server = NULL;\n    return connection;\n}\n\nvoid\nhttpDestroyConnection(HTTPConnectionPtr connection)\n{\n    assert(connection->flags == 0);\n    httpConnectionDestroyBuf(connection);\n    assert(!connection->request);\n    assert(!connection->request_last);\n    httpConnectionDestroyReqbuf(connection);\n    assert(!connection->timeout);\n    assert(!connection->server);\n    free(connection);\n}\n\nvoid\nhttpConnectionDestroyBuf(HTTPConnectionPtr connection)\n{\n    if(connection->buf) {\n        if(connection->flags & CONN_BIGBUF)\n            free(connection->buf);\n        else\n            dispose_chunk(connection->buf);\n    }\n    connection->flags &= ~CONN_BIGBUF;\n    connection->buf = NULL;\n}\n\nvoid\nhttpConnectionDestroyReqbuf(HTTPConnectionPtr connection)\n{\n    if(connection->reqbuf) {\n        if(connection->flags & CONN_BIGREQBUF)\n            free(connection->reqbuf);\n        else\n            dispose_chunk(connection->reqbuf);\n    }\n    connection->flags &= ~CONN_BIGREQBUF;\n    connection->reqbuf = NULL;\n}\n\nHTTPRequestPtr \nhttpMakeRequest()\n{\n    HTTPRequestPtr request;\n    request = malloc(sizeof(HTTPRequestRec));\n    if(request == NULL)\n        return NULL;\n    request->flags = 0;\n    request->connection = NULL;\n    request->object = NULL;\n    request->method = METHOD_UNKNOWN;\n    request->from = 0;\n    request->to = -1;\n    request->cache_control = no_cache_control;\n    request->condition = NULL;\n    request->via = NULL;\n    request->chandler = NULL;\n    request->can_mutate = NULL;\n    request->error_code = 0;\n    request->error_message = NULL;\n    request->error_headers = NULL;\n    request->headers = NULL;\n    request->time0 = null_time;\n    request->time1 = null_time;\n    request->request = NULL;\n    request->next = NULL;\n    return request;\n}\n\nvoid\nhttpDestroyRequest(HTTPRequestPtr request)\n{\n    if(request->object)\n        releaseObject(request->object);\n    if(request->condition)\n        httpDestroyCondition(request->condition);\n    releaseAtom(request->via);\n    assert(request->chandler == NULL);\n    releaseAtom(request->error_message);\n    releaseAtom(request->headers);\n    releaseAtom(request->error_headers);\n    assert(request->request == NULL);\n    assert(request->next == NULL);\n    free(request);\n}\n\nvoid\nhttpQueueRequest(HTTPConnectionPtr connection, HTTPRequestPtr request)\n{\n    assert(request->next == NULL && request->connection == NULL);\n    request->connection = connection;\n    if(connection->request_last) {\n        assert(connection->request);\n        connection->request_last->next = request;\n        connection->request_last = request;\n    } else {\n        assert(!connection->request_last);\n        connection->request = request;\n        connection->request_last = request;\n    }\n}\n\nHTTPRequestPtr\nhttpDequeueRequest(HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n    if(request) {\n        assert(connection->request_last);\n        connection->request = request->next;\n        if(!connection->request) connection->request_last = NULL;\n        request->next = NULL;\n    }\n    return request;\n}\n\nint\nhttpConnectionBigify(HTTPConnectionPtr connection)\n{\n    char *bigbuf;\n    assert(!(connection->flags & CONN_BIGBUF));\n\n    if(bigBufferSize <= CHUNK_SIZE)\n        return 0;\n\n    bigbuf = malloc(bigBufferSize);\n    if(bigbuf == NULL)\n        return -1;\n    if(connection->len > 0)\n        memcpy(bigbuf, connection->buf, connection->len);\n    if(connection->buf)\n        dispose_chunk(connection->buf);\n    connection->buf = bigbuf;\n    connection->flags |= CONN_BIGBUF;\n    return 1;\n}\n\nint\nhttpConnectionBigifyReqbuf(HTTPConnectionPtr connection)\n{\n    char *bigbuf;\n    assert(!(connection->flags & CONN_BIGREQBUF));\n\n    if(bigBufferSize <= CHUNK_SIZE)\n        return 0;\n\n    bigbuf = malloc(bigBufferSize);\n    if(bigbuf == NULL)\n        return -1;\n    if(connection->reqlen > 0)\n        memcpy(bigbuf, connection->reqbuf, connection->reqlen);\n    if(connection->reqbuf)\n        dispose_chunk(connection->reqbuf);\n    connection->reqbuf = bigbuf;\n    connection->flags |= CONN_BIGREQBUF;\n    return 1;\n}\n\nint\nhttpConnectionUnbigify(HTTPConnectionPtr connection)\n{\n    char *buf;\n    assert(connection->flags & CONN_BIGBUF);\n    assert(connection->len < CHUNK_SIZE);\n\n    buf = get_chunk();\n    if(buf == NULL)\n        return -1;\n    if(connection->len > 0)\n        memcpy(buf, connection->buf, connection->len);\n    free(connection->buf);\n    connection->buf = buf;\n    connection->flags &= ~CONN_BIGBUF;\n    return 1;\n}\n\nint\nhttpConnectionUnbigifyReqbuf(HTTPConnectionPtr connection)\n{\n    char *buf;\n    assert(connection->flags & CONN_BIGREQBUF);\n    assert(connection->reqlen < CHUNK_SIZE);\n\n    buf = get_chunk();\n    if(buf == NULL)\n        return -1;\n    if(connection->reqlen > 0)\n        memcpy(buf, connection->reqbuf, connection->reqlen);\n    free(connection->reqbuf);\n    connection->reqbuf = buf;\n    connection->flags &= ~CONN_BIGREQBUF;\n    return 1;\n}\n\nHTTPConditionPtr \nhttpMakeCondition()\n{\n    HTTPConditionPtr condition;\n    condition = malloc(sizeof(HTTPConditionRec));\n    if(condition == NULL)\n        return NULL;\n    condition->ims = -1;\n    condition->inms = -1;\n    condition->im = NULL;\n    condition->inm = NULL;\n    condition->ifrange = NULL;\n    return condition;\n}\n\nvoid\nhttpDestroyCondition(HTTPConditionPtr condition)\n{\n    if(condition->inm)\n        free(condition->inm);\n    if(condition->im)\n        free(condition->im);\n    if(condition->ifrange)\n        free(condition->ifrange);\n    free(condition);\n}\n        \nint\nhttpCondition(ObjectPtr object, HTTPConditionPtr condition)\n{\n    int rc = CONDITION_MATCH;\n\n    assert(!(object->flags & OBJECT_INITIAL));\n\n    if(!condition) return CONDITION_MATCH;\n\n    if(condition->ims >= 0) {\n        if(object->last_modified < 0 ||\n           condition->ims < object->last_modified)\n            return rc;\n        else\n            rc = CONDITION_NOT_MODIFIED;\n    }\n\n    if(condition->inms >= 0) {\n        if(object->last_modified < 0 || \n           condition->inms >= object->last_modified)\n            return rc;\n        else\n            rc = CONDITION_FAILED;\n    }\n\n    if(condition->inm) {\n        if(!object->etag || strcmp(object->etag, condition->inm) != 0)\n            return rc;\n        else\n            rc = CONDITION_NOT_MODIFIED;\n    }\n\n    if(condition->im) {\n        if(!object->etag || strcmp(object->etag, condition->im) != 0)\n            rc = CONDITION_FAILED;\n        else\n            return rc;\n    }\n\n    return rc;\n}\n\nint\nhttpWriteErrorHeaders(char *buf, int size, int offset, int do_body,\n                      int code, AtomPtr message, int close, AtomPtr headers,\n                      char *url, int url_len, char *etag)\n{\n    int n, m, i;\n    char *body;\n    char htmlMessage[100];\n    char timeStr[100];\n\n    assert(code != 0);\n\n    i = htmlString(htmlMessage, 0, 100, message->string, message->length);\n    if(i < 0)\n        strcpy(htmlMessage, \"(Couldn't format message)\");\n    else\n        htmlMessage[MIN(i, 99)] = '\\0';\n\n    if(code != 304) {\n        body = get_chunk();\n        if(!body) {\n            do_log(L_ERROR, \"Couldn't allocate body buffer.\\n\");\n            return -1;\n        }\n        m = snnprintf(body, 0, CHUNK_SIZE,\n                      \"<!DOCTYPE HTML PUBLIC \"\n                      \"\\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n                      \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\"\n                      \"\\n<html><head>\"\n                      \"\\n<title>Proxy %s: %3d %s.</title>\"\n                      \"\\n</head><body>\"\n                      \"\\n<h1>%3d %s</h1>\"\n                      \"\\n<p>The following %s\",\n                      code >= 400 ? \"error\" : \"result\",\n                      code, htmlMessage,\n                      code, htmlMessage,\n                      code >= 400 ? \n                      \"error occurred\" :\n                      \"status was returned\");\n        if(url_len > 0) {\n            m = snnprintf(body, m, CHUNK_SIZE,\n                          \" while trying to access <strong>\");\n            m = htmlString(body, m, CHUNK_SIZE, url, url_len);\n            m = snnprintf(body, m, CHUNK_SIZE, \"</strong>\");\n        }\n\n        {\n            /* On BSD systems, tv_sec is a long. */\n            const time_t ct = current_time.tv_sec;\n                                             /*Mon, 24 Sep 2004 17:46:35 GMT*/\n            strftime(timeStr, sizeof(timeStr), \"%a, %d %b %Y %H:%M:%S %Z\",\n                     localtime(&ct));\n        }\n        \n        m = snnprintf(body, m, CHUNK_SIZE,\n                      \":<br><br>\"\n                      \"\\n<strong>%3d %s</strong></p>\"\n                      \"\\n<hr>Generated %s by %s on <em>%s:%d</em>.\"\n                      \"\\n</body></html>\\r\\n\",\n                      code, htmlMessage,\n                      timeStr, displayName->string, proxyName->string, proxyPort);\n        if(m <= 0 || m >= CHUNK_SIZE) {\n            do_log(L_ERROR, \"Couldn't write error body.\\n\");\n            dispose_chunk(body);\n            return -1;\n        }\n    } else {\n        body = NULL;\n        m = 0;\n    }\n\n    n = snnprintf(buf, 0, size,\n                 \"HTTP/1.1 %3d %s\"\n                 \"\\r\\nConnection: %s\"\n                 \"\\r\\nDate: \",\n                  code, atomString(message),\n                  close ? \"close\" : \"keep-alive\");\n    n = format_time(buf, n, size, current_time.tv_sec);\n    if(code != 304) {\n        n = snnprintf(buf, n, size,\n                      \"\\r\\nContent-Type: text/html\"\n                      \"\\r\\nContent-Length: %d\", m);\n    } else {\n        if(etag)\n            n = snnprintf(buf, n, size, \"\\r\\nETag: \\\"%s\\\"\", etag);\n    }\n\n    if(code != 304 && code != 412) {\n        n = snnprintf(buf, n, size,\n                      \"\\r\\nExpires: 0\"\n                      \"\\r\\nCache-Control: no-cache\"\n                      \"\\r\\nPragma: no-cache\");\n    }\n\n    if(headers)\n        n = snnprint_n(buf, n, size,\n                      headers->string, headers->length);\n\n    n = snnprintf(buf, n, size, \"\\r\\n\\r\\n\");\n\n    if(n < 0 || n >= size) {\n        do_log(L_ERROR, \"Couldn't write error.\\n\");\n        dispose_chunk(body);\n        return -1;\n    }\n\n    if(code != 304 && do_body) {\n        if(m > 0) memcpy(buf + n, body, m);\n        n += m;\n    }\n\n    if(body)\n        dispose_chunk(body);\n\n    return n;\n}\n\nAtomListPtr\nurlDecode(char *buf, int n)\n{\n    char mybuf[500];\n    int i, j = 0;\n    AtomListPtr list;\n    AtomPtr atom;\n\n    list = makeAtomList(NULL, 0);\n    if(list == NULL)\n        return NULL;\n\n    i = 0;\n    while(i < n) {\n        if(buf[i] == '%') {\n            int a, b;\n            if(i + 3 > n)\n                goto fail;\n            a = h2i(buf[i + 1]);\n            b = h2i(buf[i + 2]);\n            if(a < 0 || b < 0)\n                goto fail;\n            mybuf[j++] = (char)((a << 4) | b);\n            i += 3;\n            if(j >= 500) goto fail;\n        } else if(buf[i] == '&') {\n            atom = internAtomN(mybuf, j);\n            if(atom == NULL)\n                goto fail;\n            atomListCons(atom, list);\n            j = 0;\n            i++;\n        } else {\n            mybuf[j++] = buf[i++];\n            if(j >= 500) goto fail;\n        }\n    }\n\n    atom = internAtomN(mybuf, j);\n    if(atom == NULL)\n        goto fail;\n    atomListCons(atom, list);\n    return list;\n\n fail:\n    destroyAtomList(list);\n    return NULL;\n}\n\nvoid\nhttpTweakCachability(ObjectPtr object)\n{\n    int code = object->code;\n\n    if((object->cache_control & CACHE_AUTHORIZATION) &&\n       !(object->cache_control & CACHE_PUBLIC)) {\n        object->cache_control |= CACHE_NO_HIDDEN;\n        object->flags |= OBJECT_LINEAR;\n    }\n\n    /* This is not required by RFC 2616 -- but see RFC 3143 2.1.1.  We\n       manically avoid caching replies that we don't know how to\n       handle, even if Expires or Cache-Control says otherwise.  As to\n       known uncacheable replies, we obey Cache-Control and default to\n       allowing sharing but not caching. */\n    if(code != 200 && code != 206 && \n       code != 300 && code != 301 && code != 302 && code != 303 &&\n       code != 304 && code != 307 &&\n       code != 403 && code != 404 && code != 405 && code != 416) {\n        object->cache_control |= (CACHE_NO_HIDDEN | CACHE_MISMATCH);\n        object->flags |= OBJECT_LINEAR;\n    } else if(code != 200 && code != 206 &&\n              code != 300 && code != 301 && code != 304 &&\n              code != 410) {\n        if(object->expires < 0 && !(object->cache_control & CACHE_PUBLIC)) {\n            object->cache_control |= CACHE_NO_HIDDEN;\n        }\n    } else if(dontCacheRedirects && (code == 301 || code == 302)) {\n        object->cache_control |= CACHE_NO_HIDDEN;\n    }\n\n    if(urlIsUncachable(object->key, object->key_size)) {\n        object->cache_control |= CACHE_NO_HIDDEN;\n    }\n\n    if((object->cache_control & CACHE_NO_STORE) != 0) {\n        object->cache_control |= CACHE_NO_HIDDEN;\n    }\n\n    if(object->cache_control & CACHE_VARY) {\n        if(!object->etag || dontTrustVaryETag >= 2) {\n            object->cache_control |= CACHE_MISMATCH;\n        }\n    }\n}\n\nint\nhttpHeaderMatch(AtomPtr header, AtomPtr headers1, AtomPtr headers2)\n{\n    int rc1, b1, e1, rc2, b2, e2;\n\n    /* Short cut if both sets of headers are identical */\n    if(headers1 == headers2)\n        return 1;\n\n    rc1 = httpFindHeader(header, headers1->string, headers1->length,\n                         &b1, &e1);\n    rc2 = httpFindHeader(header, headers2->string, headers2->length,\n                         &b2, &e2);\n\n    if(rc1 == 0 && rc2 == 0)\n        return 1;\n\n    if(rc1 == 0 || rc2 == 0)\n        return 0;\n\n    if(e1 - b1 != e2 - b2)\n        return 0;\n\n    if(memcmp(headers1->string + b1, headers2->string + b2, e1 - b1) != 0)\n        return 0;\n\n    return 1;\n}\n"
        },
        {
          "name": "http.h",
          "type": "blob",
          "size": 5.8662109375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ntypedef struct _HTTPCondition {\n    time_t ims;\n    time_t inms;\n    char *im;\n    char *inm;\n    char *ifrange;\n} HTTPConditionRec, *HTTPConditionPtr;\n\ntypedef struct _HTTPRequest {\n    int flags;\n    struct _HTTPConnection *connection;\n    ObjectPtr object;\n    int method;\n    int from;\n    int to;\n    CacheControlRec cache_control;\n    HTTPConditionPtr condition;\n    AtomPtr via;\n    struct _ConditionHandler *chandler;\n    ObjectPtr can_mutate;\n    int error_code;\n    struct _Atom *error_message;\n    struct _Atom *error_headers;\n    AtomPtr headers;\n    struct timeval time0, time1;\n    struct _HTTPRequest *request;\n    struct _HTTPRequest *next;\n} HTTPRequestRec, *HTTPRequestPtr;\n\n/* request->flags */\n/* If not present, drop the connection after this request. */\n#define REQUEST_PERSISTENT 1\n/* This client-side request has already been requested on the server-side. */\n#define REQUEST_REQUESTED 2\n/* This request is waiting for continue from the server. */\n#define REQUEST_WAIT_CONTINUE 4\n/* Force an error unconditionally -- used for client auth failures. */\n#define REQUEST_FORCE_ERROR 8\n/* This server-side request was pipelined. */\n#define REQUEST_PIPELINED 16\n/* This client-side request has already switched objects once. */\n#define REQUEST_SUPERSEDED 32\n\ntypedef struct _HTTPConnection {\n    int flags;\n    int fd;\n    char *buf;\n    int len;\n    int offset;\n    HTTPRequestPtr request;\n    HTTPRequestPtr request_last;\n    int serviced;\n    int version;\n    int time;\n    TimeEventHandlerPtr timeout;\n    int te;\n    char *reqbuf;\n    int reqlen;\n    int reqbegin;\n    int reqoffset;\n    int bodylen;\n    int reqte;\n    /* For server connections */\n    int chunk_remaining;\n    struct _HTTPServer *server;\n    int pipelined;\n    int connecting;\n} HTTPConnectionRec, *HTTPConnectionPtr;\n\n/* connection->flags */\n#define CONN_READER 1\n#define CONN_WRITER 2\n#define CONN_SIDE_READER 4\n#define CONN_BIGBUF 8\n#define CONN_BIGREQBUF 16\n\n/* request->method */\n#define METHOD_UNKNOWN -1\n#define METHOD_NONE -1\n#define METHOD_GET 0\n#define METHOD_HEAD 1\n#define METHOD_CONDITIONAL_GET 2\n#define METHOD_CONNECT 3\n#define METHOD_POST 4\n#define METHOD_PUT 5\n#define METHOD_OPTIONS 6\n#define METHOD_DELETE 7\n\n#define REQUEST_SIDE(request) ((request)->method >= METHOD_POST)\n\n/* server->version */\n#define HTTP_10 0\n#define HTTP_11 1\n#define HTTP_UNKNOWN -1\n\n/* connection->te */\n#define TE_IDENTITY 0\n#define TE_CHUNKED 1\n#define TE_UNKNOWN -1\n\n/* connection->connecting */\n#define CONNECTING_DNS 1\n#define CONNECTING_CONNECT 2\n#define CONNECTING_SOCKS 3\n\n/* the results of a conditional request.  200, 304 and 412. */\n#define CONDITION_MATCH 0\n#define CONDITION_NOT_MODIFIED 1\n#define CONDITION_FAILED 2\n\nextern int disableProxy;\nextern AtomPtr proxyName;\nextern int proxyPort;\nextern int clientTimeout, serverTimeout, serverIdleTimeout;\nextern int bigBufferSize;\nextern AtomPtr proxyAddress;\nextern int proxyOffline;\nextern int relaxTransparency;\nextern AtomPtr authRealm;\nextern AtomPtr authCredentials;\nextern AtomPtr parentAuthCredentials;\nextern AtomListPtr allowedClients;\nextern NetAddressPtr allowedNets;\nextern IntListPtr allowedPorts;\nextern IntListPtr tunnelAllowedPorts;\nextern int expectContinue;\nextern AtomPtr atom100Continue;\nextern int disableVia;\nextern int dontTrustVaryETag;\n\nvoid preinitHttp(void);\nvoid initHttp(void);\n\nint httpTimeoutHandler(TimeEventHandlerPtr);\nint httpSetTimeout(HTTPConnectionPtr connection, int secs);\nint httpWriteObjectHeaders(char *buf, int offset, int len, \n                           ObjectPtr object, int from, int to);\nint httpPrintCacheControl(char*, int, int, int, CacheControlPtr);\nchar *httpMessage(int) ATTRIBUTE((pure));\nint htmlString(char *buf, int n, int len, char *s, int slen);\nvoid htmlPrint(FILE *out, char *s, int slen);\nHTTPConnectionPtr httpMakeConnection(void);\nvoid httpDestroyConnection(HTTPConnectionPtr connection);\nvoid httpConnectionDestroyBuf(HTTPConnectionPtr connection);\nvoid httpConnectionDestroyReqbuf(HTTPConnectionPtr connection);\nHTTPRequestPtr httpMakeRequest(void);\nvoid httpDestroyRequest(HTTPRequestPtr request);\nvoid httpQueueRequest(HTTPConnectionPtr, HTTPRequestPtr);\nHTTPRequestPtr httpDequeueRequest(HTTPConnectionPtr connection);\nint httpConnectionBigify(HTTPConnectionPtr);\nint httpConnectionBigifyReqbuf(HTTPConnectionPtr);\nint httpConnectionUnbigify(HTTPConnectionPtr);\nint httpConnectionUnbigifyReqbuf(HTTPConnectionPtr);\nHTTPConditionPtr httpMakeCondition(void);\nvoid httpDestroyCondition(HTTPConditionPtr condition);\nint httpCondition(ObjectPtr, HTTPConditionPtr);\nint httpWriteErrorHeaders(char *buf, int size, int offset, int do_body,\n                          int code, AtomPtr message, int close, AtomPtr,\n                          char *url, int url_len, char *etag);\nAtomListPtr urlDecode(char*, int);\nvoid httpTweakCachability(ObjectPtr);\nint httpHeaderMatch(AtomPtr header, AtomPtr headers1, AtomPtr headers2);\n"
        },
        {
          "name": "http_parse.c",
          "type": "blob",
          "size": 46.6728515625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nstatic int getNextWord(const char *buf, int i, int *x_return, int *y_return);\nstatic int getNextToken(const char *buf, int i, int *x_return, int *y_return);\nstatic int getNextTokenInList(const char *buf, int i, \n                              int *x_return, int *y_return,\n                              int *z_return, int *t_return,\n                              int *end_return);\n\nstatic AtomPtr atomConnection, atomProxyConnection, atomContentLength,\n    atomHost, atomAcceptRange, atomTE,\n    atomReferer, atomProxyAuthenticate, atomProxyAuthorization,\n    atomKeepAlive, atomTrailer, atomDate, atomExpires,\n    atomIfModifiedSince, atomIfUnmodifiedSince, atomIfRange, atomLastModified,\n    atomIfMatch, atomIfNoneMatch, atomAge, atomTransferEncoding, \n    atomETag, atomCacheControl, atomPragma, atomContentRange, atomRange,\n    atomVia, atomVary, atomExpect, atomAuthorization,\n    atomSetCookie, atomCookie, atomCookie2,\n    atomXPolipoDate, atomXPolipoAccess, atomXPolipoLocation, \n    atomXPolipoBodyOffset;\n\nAtomPtr atomContentType, atomContentEncoding;\n\nint censorReferer = 0;\nint laxHttpParser = 1;\n\nstatic AtomListPtr censoredHeaders;\n\nvoid\npreinitHttpParser()\n{\n    CONFIG_VARIABLE_SETTABLE(censorReferer, CONFIG_TRISTATE, configIntSetter,\n                             \"Censor referer headers.\");\n    censoredHeaders = makeAtomList(NULL, 0);\n    if(censoredHeaders == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate censored atoms.\\n\");\n        exit(1);\n    }\n    CONFIG_VARIABLE(censoredHeaders, CONFIG_ATOM_LIST_LOWER,\n                    \"Headers to censor.\");\n    CONFIG_VARIABLE_SETTABLE(laxHttpParser, CONFIG_BOOLEAN, configIntSetter,\n                             \"Ignore unknown HTTP headers.\");\n}\n\nvoid\ninitHttpParser()\n{\n#define A(name, value) name = internAtom(value); if(!name) goto fail;\n    /* These must be in lower-case */\n    A(atomConnection, \"connection\");\n    A(atomProxyConnection, \"proxy-connection\");\n    A(atomContentLength, \"content-length\");\n    A(atomHost, \"host\");\n    A(atomAcceptRange, \"accept-range\");\n    A(atomTE, \"te\");\n    A(atomReferer, \"referer\");\n    A(atomProxyAuthenticate, \"proxy-authenticate\");\n    A(atomProxyAuthorization, \"proxy-authorization\");\n    A(atomKeepAlive, \"keep-alive\");\n    A(atomTrailer, \"trailer\");\n    A(atomDate, \"date\");\n    A(atomExpires, \"expires\");\n    A(atomIfModifiedSince, \"if-modified-since\");\n    A(atomIfUnmodifiedSince, \"if-unmodified-since\");\n    A(atomIfRange, \"if-range\");\n    A(atomLastModified, \"last-modified\");\n    A(atomIfMatch, \"if-match\");\n    A(atomIfNoneMatch, \"if-none-match\");\n    A(atomAge, \"age\");\n    A(atomTransferEncoding, \"transfer-encoding\");\n    A(atomETag, \"etag\");\n    A(atomCacheControl, \"cache-control\");\n    A(atomPragma, \"pragma\");\n    A(atomContentRange, \"content-range\");\n    A(atomRange, \"range\");\n    A(atomVia, \"via\");\n    A(atomContentType, \"content-type\");\n    A(atomContentEncoding, \"content-encoding\");\n    A(atomVary, \"vary\");\n    A(atomExpect, \"expect\");\n    A(atomAuthorization, \"authorization\");\n    A(atomSetCookie, \"set-cookie\");\n    A(atomCookie, \"cookie\");\n    A(atomCookie2, \"cookie2\");\n    A(atomXPolipoDate, \"x-polipo-date\");\n    A(atomXPolipoAccess, \"x-polipo-access\");\n    A(atomXPolipoLocation, \"x-polipo-location\");\n    A(atomXPolipoBodyOffset, \"x-polipo-body-offset\");\n#undef A\n    return;\n\n fail:\n    do_log(L_ERROR, \"Couldn't allocate atom.\\n\");\n    exit(1);\n}\n\nstatic int\ngetNextWord(const char *restrict buf, int i, int *x_return, int *y_return)\n{\n    int x, y;\n    while(buf[i] == ' ') i++;\n    if(buf[i] == '\\n' || buf[i] == '\\r') return -1;\n    x = i;\n    while(buf[i] > 32 && buf[i] < 127) i++;\n    y = i;\n\n    *x_return = x;\n    *y_return = y;\n\n    return 0;\n}\n\nstatic int\nskipComment(const char *restrict buf, int i)\n{\n    assert(buf[i] == '(');\n\n    i++;\n    while(1) {\n        if(buf[i] == '\\\\' && buf[i + 1] == ')') i+=2;\n        else if(buf[i] == ')') return i + 1;\n        else if(buf[i] == '\\n') {\n            if(buf[i + 1] == ' ' || buf[i + 1] == '\\t')\n                i += 2;\n            else\n                return -1;\n        } else if(buf[i] == '\\r') {\n            if(buf[i + 1] != '\\n') return -1;\n            if(buf[i + 2] == ' ' || buf[i + 2] == '\\t')\n                i += 3;\n            else\n                return -1;\n        } else {\n            i++;\n        }\n    }\n    return i;\n}\n            \n\nstatic int\nskipWhitespace(const char *restrict buf, int i)\n{\n    while(1) {\n        if(buf[i] == ' ' || buf[i] == '\\t')\n            i++;\n        else  if(buf[i] == '(') {\n            i = skipComment(buf, i);\n            if(i < 0) return -1;\n        } else if(buf[i] == '\\n') {\n            if(buf[i + 1] == ' ' || buf[i + 1] == '\\t')\n                i += 2;\n            else\n                return i;\n        } else if(buf[i] == '\\r' && buf[i + 1] == '\\n') {\n            if(buf[i + 2] == ' ' || buf[i + 2] == '\\t')\n                i += 3;\n            else\n                return i;\n        } else\n            return i;\n    }\n}\n\nstatic int\ngetNextToken(const char *restrict buf, int i, int *x_return, int *y_return)\n{\n    int x, y;\n again:\n    while(buf[i] == ' ' || buf[i] == '\\t')\n        i++;\n    if(buf[i] == '(') {\n        i++;\n        while(buf[i] != ')') {\n            if(buf[i] == '\\n' || buf[i] == '\\r')\n                return -1;\n            if(buf[i] == '\\\\' && buf[i + 1] != '\\n' && buf[i + 1] != '\\r')\n                buf += 2;\n            else\n                buf++;\n        }\n        goto again;\n    }\n    if(buf[i] == '\\n') {\n        if(buf[i + 1] == ' ' || buf[i + 1] == '\\t') {\n            i += 2;\n            goto again;\n        } else {\n            return -1;\n        }\n    }\n    if(buf[i] == '\\r') {\n        if(buf[i + 1] == '\\n' && (buf[i + 2] == ' ' || buf[i + 2] == '\\t')) {\n            i += 3;\n            goto again;\n        } else {\n            return -1;\n        }\n    }\n    x = i;\n    while(buf[i] > 32 && buf[i] < 127) {\n        switch(buf[i]) {\n        case '(': case ')': case '<': case '>': case '@':\n        case ',': case ';': case ':': case '\\\\': case '/':\n        case '[': case ']': case '?': case '=':\n        case '{': case '}': case ' ': case '\\t':\n            goto out;\n        default:\n            i++;\n        }\n    }\n out:\n    y = i;\n\n    *x_return = x;\n    *y_return = y;\n\n    return y;\n}\n\nstatic int\ngetNextETag(const char * restrict buf, int i, \n            int *x_return, int *y_return, int *weak_return)\n{\n    int weak = 0;\n    int x, y;\n    while(buf[i] == ' ' || buf[i] == '\\t')\n        i++;\n    if(buf[i] == 'W' && buf[i + 1] == '/') {\n        weak = 1;\n        i += 2;\n    }\n    if(buf[i] == '\"')\n        i++;\n    else\n        return -1;\n\n    x = i;\n    while(buf[i] != '\"') {\n        if(buf[i] == '\\r' || buf[i] == '\\n')\n            return -1;\n        i++;\n    }\n    y = i;\n    i++;\n\n    *x_return = x;\n    *y_return = y;\n    *weak_return = weak;\n    return i;\n}\n\nstatic int\ngetNextTokenInList(const char *restrict buf, int i, \n                   int *x_return, int *y_return,\n                   int *z_return, int *t_return,\n                   int *end_return)\n{\n    int j, x, y, z = -1, t = -1, end;\n    j = getNextToken(buf, i, &x, &y);\n    if(j < 0)\n        return -1;\n    while(buf[j] == ' ' || buf[j] == '\\t')\n        j++;\n\n    if(buf[j] == '=') {\n        j++;\n        while(buf[j] == ' ' || buf[j] == '\\t')\n            j++;\n        z = j;\n        while(buf[j] != ',' && buf[j] != '\\n' && buf[j] != '\\r')\n            j++;\n    }\n\n    if(buf[j] == '\\n' || buf[j] == '\\r') {\n        if(buf[j] == '\\r') {\n            if(buf[j + 1] != '\\n')\n                return -1;\n            j += 2;\n        } else\n            j++;\n        end = 1;\n        if(buf[j] == ' ' || buf[j] == '\\t') {\n            while(buf[j] == ' ' || buf[j] == '\\t')\n                j++;\n            end = 0;\n        }\n    } else if(buf[j] == ',') {\n        j++;\n        while(buf[j] == ' ' || buf[j] == '\\t')\n            j++;\n        end = 0;\n    } else {\n        return -1;\n    }\n\n    *x_return = x;\n    *y_return = y;\n    if(z_return)\n        *z_return = z;\n    if(t_return)\n        *t_return = t;\n    *end_return = end;\n    return j;\n}\n\nstatic inline int\ntoken_compare(const char *buf, int start, int end, const char *s)\n{\n    return (strcasecmp_n(s, buf + start, end - start) == 0);\n}\n\nstatic int\nskipEol(const char *restrict buf, int i)\n{\n    while(buf[i] == ' ')\n        i++;\n    if(buf[i] == '\\n')\n        return i + 1;\n    else if(buf[i] == '\\r') {\n        if(buf[i + 1] == '\\n')\n            return i + 2;\n        else\n            return -1;\n    } else {\n        return -1;\n    }\n}\n    \nstatic int\nskipToEol(const char *restrict buf, int i, int *start_return)\n{\n    while(buf[i] != '\\n' && buf[i] != '\\r')\n        i++;\n    if(buf[i] == '\\n') {\n        *start_return = i;\n        return i + 1;\n    } else if(buf[i] == '\\r') {\n        if(buf[i + 1] == '\\n') {\n            *start_return = i;\n            return i + 2;\n        } else {\n            return -1;\n        }\n    }\n    return -1;\n}\n\nstatic int\ngetHeaderValue(const char *restrict buf, int start, \n               int *value_start_return, int *value_end_return)\n{\n    int i, j, k;\n\n    while(buf[start] == ' ' || buf[start] == '\\t')\n        start++;\n    i = start;\n again:\n    j = skipToEol(buf, i, &k);\n    if(j < 0)\n        return -1;\n    if(buf[j] == ' ' || buf[j] == '\\t') {\n        i = j + 1;\n        goto again;\n    }\n    *value_start_return = start;\n    *value_end_return = k;\n    return j;\n}\n    \nint\nhttpParseClientFirstLine(const char *restrict buf, int offset,\n                         int *method_return,\n                         AtomPtr *url_return,\n                         int *version_return)\n{\n    int i = 0;\n    int x, y;\n    int method;\n    AtomPtr url;\n    int version = HTTP_UNKNOWN;\n    int eol;\n\n    i = offset;\n    i = getNextWord(buf, i, &x, &y);\n    if(i < 0) return -1;\n    if(y == x + 3 && memcmp(buf + x, \"GET\", 3) == 0)\n        method = METHOD_GET;\n    else if(y == x + 4 && memcmp(buf + x, \"HEAD\", 4) == 0)\n        method = METHOD_HEAD;\n    else if(y == x + 4 && memcmp(buf + x, \"POST\", 4) == 0)\n        method = METHOD_POST;\n    else if(y == x + 3 && memcmp(buf + x, \"PUT\", 3) == 0)\n        method = METHOD_PUT;\n    else if(y == x + 7 && memcmp(buf + x, \"CONNECT\", 7) == 0)\n        method = METHOD_CONNECT;\n    else if(y == x + 7 && memcmp(buf + x, \"OPTIONS\", 7) == 0)\n        method = METHOD_OPTIONS;\n    else if(y == x + 6 && memcmp(buf + x, \"DELETE\", 6) == 0)\n        method = METHOD_DELETE;\n    else\n        method = METHOD_UNKNOWN;\n\n    i = getNextWord(buf, y + 1, &x, &y);\n    if(i < 0) return -1;\n\n    url = internAtomN(buf + x, y - x);\n\n    i = getNextWord(buf, y + 1, &x, &y);\n    if(i < 0) {\n        releaseAtom(url);\n        return -1;\n    }\n\n    if(y == x + 8) {\n        if(memcmp(buf + x, \"HTTP/1.\", 7) != 0)\n            version = HTTP_UNKNOWN;\n        else if(buf[x + 7] == '0')\n            version = HTTP_10;\n        else if(buf[x + 7] >= '1' && buf[x + 7] <= '9')\n            version = HTTP_11;\n        else\n            version = HTTP_UNKNOWN;\n    }\n\n    eol = skipEol(buf, y);\n    if(eol < 0) return -1;\n        \n    *method_return = method;\n    if(url_return)\n        *url_return = url;\n    else\n        releaseAtom(url);\n    *version_return = version;\n    return eol;\n}\n\nint\nhttpParseServerFirstLine(const char *restrict buf, \n                         int *status_return,\n                         int *version_return,\n                         AtomPtr *message_return)\n{\n    int i = 0;\n    int x, y, eol;\n    int status;\n    int version = HTTP_UNKNOWN;\n    \n    i = getNextWord(buf, 0, &x, &y);\n    if(i < 0)\n        return -1;\n    if(y == x + 8 && memcmp(buf + x, \"HTTP/1.0\", 8) == 0)\n        version = HTTP_10;\n    else if(y >= x + 8 && memcmp(buf + x, \"HTTP/1.\", 7) == 0)\n        version = HTTP_11;\n    else\n        version = HTTP_UNKNOWN;\n\n    i = getNextWord(buf, y + 1, &x, &y);\n    if(i < 0) return -1;\n    if(y == x + 3)\n        status = atol(buf + x);\n    else return -1;\n\n    i = skipToEol(buf, y, &eol);\n    if(i < 0) return -1;\n        \n    *status_return = status;\n    *version_return = version;\n    if(message_return) {\n        /* Netscape enterprise bug */\n        if(eol > y)\n            *message_return = internAtomN(buf + y + 1, eol - y - 1);\n        else\n            *message_return = internAtom(\"No message\");\n    }\n    return i;\n}\n\nstatic int\nparseInt(const char *restrict buf, int start, int *val_return)\n{\n    int i = start, val = 0;\n    if(!digit(buf[i]))\n        return -1;\n    while(digit(buf[i])) {\n        val = val * 10 + (buf[i] - '0');\n        i++;\n    }\n    *val_return = val;\n    return i;\n}\n\n/* Returned *name_start_return is -1 at end of headers, -2 if the line\n   couldn't be parsed. */\nstatic int\nparseHeaderLine(const char *restrict buf, int start,\n                int *name_start_return, int *name_end_return,\n                int *value_start_return, int *value_end_return)\n{\n    int i;\n    int name_start, name_end, value_start, value_end;\n\n    if(buf[start] == '\\n') {\n        *name_start_return = -1;\n        return start + 1;\n    }\n    if(buf[start] == '\\r' && buf[start + 1] == '\\n') {\n        *name_start_return = -1;\n        return start + 2;\n    }\n\n    i = getNextToken(buf, start, &name_start, &name_end);\n    if(i < 0 || buf[i] != ':')\n        goto syntax;\n    i++;\n    while(buf[i] == ' ' || buf[i] == '\\t')\n        i++;\n\n    i = getHeaderValue(buf, i, &value_start, &value_end);\n    if(i < 0)\n        goto syntax;\n\n    *name_start_return = name_start;\n    *name_end_return = name_end;\n    *value_start_return = value_start;\n    *value_end_return = value_end;\n    return i;\n\n syntax:\n    i = start;\n    while(1) {\n        if(buf[i] == '\\n') {\n            i++;\n            break;\n        }\n        if(buf[i] == '\\r' && buf[i + 1] == '\\n') {\n            i += 2;\n            break;\n        }\n        i++;\n    }\n    *name_start_return = -2;\n    return i;\n}\n\nint\nfindEndOfHeaders(const char *restrict buf, int from, int to, int *body_return) \n{\n    int i = from;\n    int eol = 0;\n    while(i < to) {\n        if(buf[i] == '\\n') {\n            if(eol) {\n                *body_return = i + 1;\n                return eol;\n            }\n            eol = i;\n            i++;\n        } else if(buf[i] == '\\r') {\n            if(i < to - 1 && buf[i + 1] == '\\n') {\n                if(eol) {\n                    *body_return = eol;\n                    return i + 2;\n                }\n                eol = i;\n                i += 2;\n            } else {\n                eol = 0;\n                i++;\n            }\n        } else {\n            eol = 0;\n            i++;\n        }\n    }\n    return -1;\n}\n\nstatic int\nparseContentRange(const char *restrict buf, int i, \n                  int *from_return, int *to_return, int *full_len_return)\n{\n    int j;\n    int from, to, full_len;\n\n    i = skipWhitespace(buf, i);\n    if(i < 0) return -1;\n    if(!token_compare(buf, i, i + 5, \"bytes\")) {\n        do_log(L_WARN, \"Incorrect Content-Range header -- chugging along.\\n\");\n    } else {\n        i += 5;\n    }\n    i = skipWhitespace(buf, i);\n    if(buf[i] == '*') {\n        from = 0;\n        to = -1;\n        i++;\n    } else {\n        i = parseInt(buf, i, &from);\n        if(i < 0) return -1;\n        if(buf[i] != '-') return -1;\n        i++;\n        i = parseInt(buf, i, &to);\n        if(i < 0) return -1;\n        to = to + 1;\n    }\n    if(buf[i] != '/')\n        return -1;\n    i++;\n    if(buf[i] == '*')\n        full_len = -1;\n    else {\n        i = parseInt(buf, i, &full_len);\n        if(i < 0) return -1;\n    }\n    j = skipEol(buf, i);\n    if(j < 0)\n        return -1;\n\n    *from_return = from;\n    *to_return = to;\n    *full_len_return = full_len;\n    return i;\n}\n\nstatic int\nparseRange(const char *restrict buf, int i, \n           int *from_return, int *to_return)\n{\n    int j;\n    int from, to;\n\n    i = skipWhitespace(buf, i);\n    if(i < 0)\n        return -1;\n    if(!token_compare(buf, i, i + 6, \"bytes=\"))\n        return -1;\n    i += 6;\n    i = skipWhitespace(buf, i);\n    if(buf[i] == '-') {\n        from = 0;\n    } else {\n        i = parseInt(buf, i, &from);\n        if(i < 0) return -1;\n    }\n    if(buf[i] != '-')\n        return -1;\n    i++;\n    j = parseInt(buf, i, &to);\n    if(j < 0) \n        to = -1;\n    else {\n        to = to + 1;\n        i = j;\n    }\n    j = skipEol(buf, i);\n    if(j < 0) return -1;\n    *from_return = from;\n    *to_return = to;\n    return i;\n}\n\nstatic void\nparseCacheControl(const char *restrict buf, \n                  int token_start, int token_end,\n                  int v_start, int v_end, int *age_return)\n{\n    if(v_start <= 0 || !digit(buf[v_start])) {\n        do_log(L_WARN, \"Couldn't parse Cache-Control: \");\n        do_log_n(L_WARN, buf + token_start,\n                 (v_end >= 0 ? v_end : token_end) -\n                 token_start);\n        do_log(L_WARN, \"\\n\");\n    } else\n        *age_return = atoi(buf + v_start);\n}\n\nstatic int\nurlSameHost(const char *url1, int len1, const char *url2, int len2)\n{\n    int i;\n    if(len1 < 7 || len2 < 7)\n        return 0;\n    if(memcmp(url1 + 4, \"://\", 3) != 0 || memcmp(url2 + 4, \"://\", 3) != 0)\n        return 0;\n\n    i = 7;\n    while(i < len1 && i < len2 && url1[i] != '/' && url2[i] != '/') {\n        if((url1[i] | 0x20) != (url2[i] | 0x20))\n            break;\n        i++;\n    }\n\n    if((i == len1 || url1[i] == '/') && ((i == len2 || url2[i] == '/')))\n        return 1;\n    return 0;\n}\n\nstatic char *\nresize_hbuf(char *hbuf, int *size, char *hbuf_small)\n{\n    int new_size = 2 * *size;\n    char *new_hbuf;\n\n    if(new_size <= *size)\n        goto fail;\n\n    if(hbuf == hbuf_small) {\n        new_hbuf = malloc(new_size);\n        if(new_hbuf == NULL) goto fail;\n        memcpy(new_hbuf, hbuf, *size);\n    } else {\n        new_hbuf = realloc(hbuf, new_size);\n        if(new_hbuf == NULL) goto fail;\n    }\n    *size = new_size;\n    return new_hbuf;\n\n fail:\n    if(hbuf != hbuf_small)\n        free(hbuf);\n    *size = 0;\n    return NULL;\n}\n\nint\nhttpParseHeaders(int client, AtomPtr url,\n                 const char *buf, int start, HTTPRequestPtr request,\n                 AtomPtr *headers_return,\n                 int *len_return, CacheControlPtr cache_control_return,\n                 HTTPConditionPtr *condition_return, int *te_return,\n                 time_t *date_return, time_t *last_modified_return,\n                 time_t *expires_return, time_t *polipo_age_return,\n                 time_t *polipo_access_return, int *polipo_body_offset_return,\n                 int *age_return, char **etag_return, AtomPtr *expect_return,\n                 HTTPRangePtr range_return, HTTPRangePtr content_range_return,\n                 char **location_return, AtomPtr *via_return,\n                 AtomPtr *auth_return)\n{\n    int local = url ? urlIsLocal(url->string, url->length) : 0;\n    char hbuf_small[512];\n    char *hbuf = hbuf_small;\n    int hbuf_size = 512, hbuf_length = 0;\n    int i, j,\n        name_start, name_end, value_start, value_end, \n        token_start, token_end, end;\n    AtomPtr name = NULL;\n    time_t date = -1, last_modified = -1, expires = -1, polipo_age = -1,\n        polipo_access = -1, polipo_body_offset = -1;\n    int len = -1;\n    CacheControlRec cache_control;\n    char *endptr;\n    int te = TE_IDENTITY;\n    int age = -1;\n    char *etag = NULL, *ifrange = NULL;\n    int persistent = (!request || (request->connection->version != HTTP_10));\n    char *location = NULL;\n    AtomPtr via = NULL;\n    AtomPtr auth = NULL;\n    AtomPtr expect = NULL;\n    HTTPConditionPtr condition;\n    time_t ims = -1, inms = -1;\n    char *im = NULL, *inm = NULL;\n    AtomListPtr hopToHop = NULL;\n    HTTPRangeRec range = {-1, -1, -1}, content_range = {-1, -1, -1};\n    int haveCacheControl = 0;\n \n#define RESIZE_HBUF() \\\n    do { \\\n        hbuf = resize_hbuf(hbuf, &hbuf_size, hbuf_small); \\\n        if(hbuf == NULL) \\\n            goto fail; \\\n    } while(0)\n\n    cache_control.flags = 0;\n    cache_control.max_age = -1;\n    cache_control.s_maxage = -1;\n    cache_control.min_fresh = -1;\n    cache_control.max_stale = -1;\n    \n    i = start;\n\n    while(1) {\n        i = parseHeaderLine(buf, i,\n                            &name_start, &name_end, &value_start, &value_end);\n        if(i < 0) {\n            do_log(L_ERROR, \"Couldn't find end of header line.\\n\");\n            goto fail;\n        }\n\n        if(name_start == -1)\n            break;\n\n        if(name_start < 0)\n            continue;\n\n        name = internAtomLowerN(buf + name_start, name_end - name_start);\n\n        if(name == atomConnection) {\n            j = getNextTokenInList(buf, value_start, \n                                   &token_start, &token_end, NULL, NULL,\n                                   &end);\n            while(1) {\n                if(j < 0) {\n                    do_log(L_ERROR, \"Couldn't parse Connection: \");\n                    do_log_n(L_ERROR, buf + value_start, \n                             value_end - value_start);\n                    do_log(L_ERROR, \".\\n\");\n                    goto fail;\n                }\n                if(token_compare(buf, token_start, token_end, \"close\")) {\n                    persistent = 0;\n                } else if(token_compare(buf, token_start, token_end, \n                                        \"keep-alive\")) {\n                    persistent = 1;\n                } else {\n                    if(hopToHop == NULL)\n                        hopToHop = makeAtomList(NULL, 0);\n                    if(hopToHop == NULL) {\n                        do_log(L_ERROR, \"Couldn't allocate atom list.\\n\");\n                        goto fail;\n                    }\n                    atomListCons(internAtomLowerN(buf + token_start,\n                                                  token_end - token_start),\n                                 hopToHop);\n                }\n                if(end)\n                    break;\n                j = getNextTokenInList(buf, j, \n                                       &token_start, &token_end, NULL, NULL,\n                                       &end);\n            }\n        } else if(name == atomCacheControl)\n            haveCacheControl = 1;\n\n        releaseAtom(name);\n        name = NULL;\n    }\n    \n    i = start;\n\n    while(1) {\n        i = parseHeaderLine(buf, i, \n                            &name_start, &name_end, &value_start, &value_end);\n        if(i < 0) {\n            do_log(L_ERROR, \"Couldn't find end of header line.\\n\");\n            goto fail;\n        }\n\n        if(name_start == -1)\n            break;\n\n        if(name_start < 0) {\n            do_log(L_WARN, \"Couldn't parse header line.\\n\");\n            if(laxHttpParser)\n                continue;\n            else\n                goto fail;\n        }\n\n        name = internAtomLowerN(buf + name_start, name_end - name_start);\n        \n        if(name == atomProxyConnection) {\n            j = getNextTokenInList(buf, value_start, \n                                   &token_start, &token_end, NULL, NULL,\n                                   &end);\n            while(1) {\n                if(j < 0) {\n                    do_log(L_WARN, \"Couldn't parse Proxy-Connection:\");\n                    do_log_n(L_WARN, buf + value_start, \n                             value_end - value_start);\n                    do_log(L_WARN, \".\\n\");\n                    persistent = 0;\n                    break;\n                }\n                if(token_compare(buf, token_start, token_end, \"close\")) {\n                    persistent = 0;\n                } else if(token_compare(buf, token_start, token_end, \n                                        \"keep-alive\")) {\n                    persistent = 1;\n                }\n                if(end)\n                    break;\n                j = getNextTokenInList(buf, j, \n                                       &token_start, &token_end, NULL, NULL,\n                                       &end);\n            }\n        } else if(name == atomContentLength) {\n            j = skipWhitespace(buf, value_start);\n            if(j < 0) {\n                do_log(L_WARN, \"Couldn't parse Content-Length: \\n\");\n                do_log_n(L_WARN, buf + value_start, value_end - value_start);\n                do_log(L_WARN, \".\\n\");\n                len = -1;\n            } else {\n                errno = 0;\n                len = strtol(buf + value_start, &endptr, 10);\n                if(errno == ERANGE || endptr <= buf + value_start) {\n                    do_log(L_WARN, \"Couldn't parse Content-Length: \\n\");\n                    do_log_n(L_WARN, buf + value_start, \n                             value_end - value_start);\n                    do_log(L_WARN, \".\\n\");\n                    len = -1;\n                }\n            }\n        } else if((!local && name == atomProxyAuthorization) ||\n                  (local && name == atomAuthorization)) {\n            if(auth_return) {\n                auth = internAtomN(buf + value_start, value_end - value_start);\n                if(auth == NULL) {\n                    do_log(L_ERROR, \"Couldn't allocate authorization.\\n\");\n                    goto fail;\n                }\n            }\n        } else if(name == atomReferer) {\n            int h;\n            if(censorReferer == 0 || \n               (censorReferer == 1 && url != NULL &&\n                urlSameHost(url->string, url->length,\n                            buf + value_start, value_end - value_start))) {\n                while(hbuf_length > hbuf_size - 2)\n                    RESIZE_HBUF();\n                hbuf[hbuf_length++] = '\\r';\n                hbuf[hbuf_length++] = '\\n';\n                do {\n                    h = snnprint_n(hbuf, hbuf_length, hbuf_size,\n                                   buf + name_start, value_end - name_start);\n                    if(h < 0) RESIZE_HBUF();\n                } while(h < 0);\n                hbuf_length = h;\n            }\n        } else if(name == atomTrailer) {\n            do_log(L_ERROR, \"Trailers present.\\n\");\n            goto fail;\n        } else if(name == atomDate || name == atomExpires ||\n                  name == atomIfModifiedSince || \n                  name == atomIfUnmodifiedSince ||\n                  name == atomLastModified ||\n                  name == atomXPolipoDate || name == atomXPolipoAccess) {\n            time_t t;\n            j = parse_time(buf, value_start, value_end, &t);\n            if(j < 0) {\n                if(name != atomExpires) {\n                    do_log(L_WARN, \"Couldn't parse %s: \", name->string);\n                    do_log_n(L_WARN, buf + value_start,\n                             value_end - value_start);\n                    do_log(L_WARN, \"\\n\");\n                }\n                t = -1;\n            }\n            if(name == atomDate) {\n                if(t >= 0)\n                    date = t;\n            } else if(name == atomExpires) {\n                if(t >= 0)\n                    expires = t;\n                else\n                    expires = 0;\n            } else if(name == atomLastModified)\n                last_modified = t;\n            else if(name == atomIfModifiedSince)\n                ims = t;\n            else if(name == atomIfUnmodifiedSince)\n                inms = t;\n            else if(name == atomXPolipoDate)\n                polipo_age = t;\n            else if(name == atomXPolipoAccess)\n                polipo_access = t;\n        } else if(name == atomAge) {\n            j = skipWhitespace(buf, value_start);\n            if(j < 0) {\n                age = -1;\n            } else {\n                errno = 0;\n                age = strtol(buf + value_start, &endptr, 10);\n                if(errno == ERANGE || endptr <= buf + value_start)\n                    age = -1;\n            }\n            if(age < 0) {\n                do_log(L_WARN, \"Couldn't parse age: \\n\");\n                do_log_n(L_WARN, buf + value_start, value_end - value_start);\n                do_log(L_WARN, \" -- ignored.\\n\");\n            }\n        } else if(name == atomXPolipoBodyOffset) {\n            j = skipWhitespace(buf, value_start);\n            if(j < 0) {\n                do_log(L_ERROR, \"Couldn't parse body offset.\\n\");\n                goto fail;\n            } else {\n                errno = 0;\n                polipo_body_offset = strtol(buf + value_start, &endptr, 10);\n                if(errno == ERANGE || endptr <= buf + value_start) {\n                    do_log(L_ERROR, \"Couldn't parse body offset.\\n\");\n                    goto fail;\n                }\n            }\n        } else if(name == atomTransferEncoding) {\n            if(token_compare(buf, value_start, value_end, \"identity\"))\n                te = TE_IDENTITY;\n            else if(token_compare(buf, value_start, value_end, \"chunked\"))\n                te = TE_CHUNKED;\n            else\n                te = TE_UNKNOWN;\n        } else if(name == atomETag ||\n                  name == atomIfNoneMatch || name == atomIfMatch ||\n                  name == atomIfRange) {\n            int x, y;\n            int weak;\n            char *e;\n            j = getNextETag(buf, value_start, &x, &y, &weak);\n            if(j < 0) {\n                if(buf[value_start] != '\\r' && buf[value_start] != '\\n')\n                    do_log(L_ERROR, \"Couldn't parse ETag.\\n\");\n            } else if(weak) {\n                do_log(L_WARN, \"Server returned weak ETag -- ignored.\\n\");\n            } else {\n                e = strdup_n(buf + x, y - x);\n                if(e == NULL) goto fail;\n                if(name == atomETag) {\n                    if(!etag)\n                        etag = e;\n                    else\n                        free(e);\n                } else if(name == atomIfNoneMatch) {\n                    if(!inm)\n                        inm = e;\n                    else\n                        free(e);\n                } else if(name == atomIfMatch) {\n                    if(!im)\n                        im = e;\n                    else\n                        free(e);\n                } else if(name == atomIfRange) {\n                    if(!ifrange)\n                        ifrange = e;\n                    else\n                        free(e);\n                } else {\n                    abort();\n                }\n            }\n        } else if(name == atomCacheControl) {\n            int v_start, v_end;\n            j = getNextTokenInList(buf, value_start, \n                                   &token_start, &token_end, \n                                   &v_start, &v_end,\n                                   &end);\n            while(1) {\n                if(j < 0) {\n                    do_log(L_WARN, \"Couldn't parse Cache-Control.\\n\");\n                    cache_control.flags |= CACHE_NO;\n                    break;\n                }\n                if(token_compare(buf, token_start, token_end, \"no-cache\")) {\n                    cache_control.flags |= CACHE_NO;\n                } else if(token_compare(buf, token_start, token_end,\n                                        \"public\")) {\n                    cache_control.flags |= CACHE_PUBLIC;\n                } else if(token_compare(buf, token_start, token_end, \n                                        \"private\")) {\n                    cache_control.flags |= CACHE_PRIVATE;\n                } else if(token_compare(buf, token_start, token_end, \n                                        \"no-store\")) {\n                    cache_control.flags |= CACHE_NO_STORE;\n                } else if(token_compare(buf, token_start, token_end, \n                                        \"no-transform\")) {\n                    cache_control.flags |= CACHE_NO_TRANSFORM;\n                } else if(token_compare(buf, token_start, token_end,\n                                        \"must-revalidate\") ||\n                          token_compare(buf, token_start, token_end,\n                                        \"must-validate\")) { /* losers */\n                    cache_control.flags |= CACHE_MUST_REVALIDATE;\n                } else if(token_compare(buf, token_start, token_end, \n                                        \"proxy-revalidate\")) {\n                    cache_control.flags |= CACHE_PROXY_REVALIDATE;\n                } else if(token_compare(buf, token_start, token_end,\n                                        \"only-if-cached\")) {\n                    cache_control.flags |= CACHE_ONLY_IF_CACHED;\n                } else if(token_compare(buf, token_start, token_end,\n                                        \"max-age\") ||\n                          token_compare(buf, token_start, token_end,\n                                        \"maxage\") || /* losers */\n                          token_compare(buf, token_start, token_end,\n                                        \"s-maxage\") ||\n                          token_compare(buf, token_start, token_end,\n                                        \"min-fresh\")) {\n                    parseCacheControl(buf, token_start, token_end,\n                                      v_start, v_end,\n                                      &cache_control.max_age);\n                } else if(token_compare(buf, token_start, token_end,\n                                        \"max-stale\")) {\n                    parseCacheControl(buf, token_start, token_end,\n                                      v_start, v_end,\n                                      &cache_control.max_stale);\n                } else {\n                    do_log(L_WARN, \"Unsupported Cache-Control directive \");\n                    do_log_n(L_WARN, buf + token_start, \n                             (v_end >= 0 ? v_end : token_end) - token_start);\n                    do_log(L_WARN, \" -- ignored.\\n\");\n                }\n                if(end)\n                    break;\n                j = getNextTokenInList(buf, j, \n                                       &token_start, &token_end,\n                                       &v_start, &v_end,\n                                       &end);\n            }\n        } else if(name == atomContentRange) {\n            if(!client) {\n                j = parseContentRange(buf, value_start, \n                                      &content_range.from, &content_range.to, \n                                      &content_range.full_length);\n                if(j < 0) {\n                    do_log(L_ERROR, \"Couldn't parse Content-Range: \");\n                    do_log_n(L_ERROR, buf + value_start, \n                             value_end - value_start);\n                    do_log(L_ERROR, \"\\n\");\n                    goto fail;\n                }\n            } else {\n                do_log(L_ERROR, \"Content-Range from client.\\n\");\n                goto fail;\n            }\n        } else if(name == atomRange) {\n            if(client) {\n                j = parseRange(buf, value_start, &range.from, &range.to);\n                if(j < 0) {\n                    do_log(L_WARN, \"Couldn't parse Range -- ignored.\\n\");\n                    range.from = -1;\n                    range.to = -1;\n                }\n            } else {\n                do_log(L_WARN, \"Range from server -- ignored\\n\");\n            }\n        } else if(name == atomXPolipoLocation) {\n            if(location_return) {\n                location = \n                    strdup_n(buf + value_start, value_end - value_start);\n                if(location == NULL) {\n                    do_log(L_ERROR, \"Couldn't allocate location.\\n\");\n                    goto fail;\n                }\n            }\n        } else if(name == atomVia) {\n            if(via_return) {\n                AtomPtr new_via, full_via;\n                new_via =\n                    internAtomN(buf + value_start, value_end - value_start);\n                if(new_via == NULL) {\n                    do_log(L_ERROR, \"Couldn't allocate via.\\n\");\n                    goto fail;\n                }\n                if(via) {\n                    full_via =\n                        internAtomF(\"%s, %s\", via->string, new_via->string);\n                    releaseAtom(new_via);\n                    if(full_via == NULL) {\n                        do_log(L_ERROR, \"Couldn't allocate via\");\n                        goto fail;\n                    }\n                    releaseAtom(via);\n                    via = full_via;\n                } else {\n                    via = new_via;\n                }\n            }\n        } else if(name == atomExpect) {\n            if(expect_return) {\n                expect = internAtomLowerN(buf + value_start, \n                                          value_end - value_start);\n                if(expect == NULL) {\n                    do_log(L_ERROR, \"Couldn't allocate expect.\\n\");\n                    goto fail;\n                }\n            }\n        } else {\n            if(!client && name == atomContentType) {\n                if(token_compare(buf, value_start, value_end,\n                                 \"multipart/byteranges\")) {\n                    do_log(L_ERROR, \n                           \"Server returned multipart/byteranges -- yuck!\\n\");\n                    goto fail;\n                }\n            } \n            if(name == atomVary) {\n                if(!token_compare(buf, value_start, value_end, \"host\") &&\n                   !token_compare(buf, value_start, value_end, \"*\")) {\n                    /* What other vary headers should be ignored? */\n                    do_log(L_VARY, \"Vary header present (\");\n                    do_log_n(L_VARY,\n                             buf + value_start, value_end - value_start);\n                    do_log(L_VARY, \").\\n\");\n                }\n                cache_control.flags |= CACHE_VARY;\n            } else if(name == atomAuthorization) {\n                cache_control.flags |= CACHE_AUTHORIZATION;\n            } \n\n            if(name == atomPragma) {\n                /* Pragma is only defined for the client, and the only\n                   standard value is no-cache (RFC 1945, 10.12).\n                   However, we honour a Pragma: no-cache for both the client\n                   and the server when there's no Cache-Control header.  In\n                   all cases, we pass the Pragma header to the next hop. */\n                if(!haveCacheControl) {\n                    j = getNextTokenInList(buf, value_start,\n                                           &token_start, &token_end, NULL, NULL,\n                                           &end);\n                    while(1) {\n                        if(j < 0) {\n                            do_log(L_WARN, \"Couldn't parse Pragma.\\n\");\n                            cache_control.flags |= CACHE_NO;\n                            break;\n                        }\n                        if(token_compare(buf, token_start, token_end,\n                                         \"no-cache\"))\n                            cache_control.flags = CACHE_NO;\n                        if(end)\n                            break;\n                        j = getNextTokenInList(buf, j, &token_start, &token_end,\n                                               NULL, NULL, &end);\n                    }\n                }\n            }\n            if(!client &&\n               (name == atomSetCookie || \n                name == atomCookie || name == atomCookie2))\n                cache_control.flags |= CACHE_COOKIE;\n\n            if(hbuf) {\n                if(name != atomConnection && name != atomHost &&\n                   name != atomAcceptRange && name != atomTE &&\n                   name != atomProxyAuthenticate &&\n                   name != atomKeepAlive &&\n                   (!hopToHop || !atomListMember(name, hopToHop)) &&\n                   !atomListMember(name, censoredHeaders)) {\n                    int h;\n                    while(hbuf_length > hbuf_size - 2)\n                        RESIZE_HBUF();\n                    hbuf[hbuf_length++] = '\\r';\n                    hbuf[hbuf_length++] = '\\n';\n                    do {\n                        h = snnprint_n(hbuf, hbuf_length, hbuf_size,\n                                       buf + name_start, \n                                       value_end - name_start);\n                        if(h < 0) RESIZE_HBUF();\n                    } while(h < 0);\n                    hbuf_length = h;\n                }\n            }\n        }\n        releaseAtom(name);\n        name = NULL;\n    }\n\n    if(headers_return) {\n        AtomPtr pheaders = NULL; \n        pheaders = internAtomN(hbuf, hbuf_length);\n        if(!pheaders)\n            goto fail;\n        *headers_return = pheaders;\n    }\n    if(hbuf != hbuf_small)\n        free(hbuf);\n    hbuf = NULL;\n    hbuf_size = 0;\n\n    if(request)\n        if(!persistent)\n            request->flags &= ~REQUEST_PERSISTENT;\n\n    if(te != TE_IDENTITY) len = -1;\n    if(len_return) *len_return = len;\n    if(cache_control_return) *cache_control_return = cache_control;\n    if(condition_return) {\n        if(ims >= 0 || inms >= 0 || im || inm || ifrange) {\n            condition = httpMakeCondition();\n            if(condition) {\n                condition->ims = ims;\n                condition->inms = inms;\n                condition->im = im;\n                condition->inm = inm;\n                condition->ifrange = ifrange;\n            } else {\n                do_log(L_ERROR, \"Couldn't allocate condition.\\n\");\n                if(im) free(im);\n                if(inm) free(inm);\n            }\n        } else {\n            condition = NULL;\n        }\n        *condition_return = condition;\n    } else {\n        assert(!im && !inm);\n    }\n            \n    if(te_return) *te_return = te;\n    if(date_return) *date_return = date;\n    if(last_modified_return) *last_modified_return = last_modified;\n    if(expires_return) *expires_return = expires;\n    if(polipo_age_return) *polipo_age_return = polipo_age;\n    if(polipo_access_return) *polipo_access_return = polipo_access;\n    if(polipo_body_offset_return)\n        *polipo_body_offset_return = polipo_body_offset;\n    if(age_return) *age_return = age;\n    if(etag_return)\n        *etag_return = etag;\n    else {\n        if(etag) free(etag);\n    }\n    if(range_return) *range_return = range;\n    if(content_range_return) *content_range_return = content_range;\n    if(location_return) {\n        *location_return = location;\n    } else {\n        if(location)\n            free(location);\n    }\n    if(via_return)\n        *via_return = via;\n    else {\n        if(via)\n            releaseAtom(via);\n    }\n    if(expect_return)\n        *expect_return = expect;\n    else {\n        if(expect)\n            releaseAtom(expect);\n    }\n    if(auth_return)\n        *auth_return = auth;\n    else {\n        if(auth)\n            releaseAtom(auth);\n    }\n    if(hopToHop) destroyAtomList(hopToHop);\n    return i;\n\n fail:\n    if(hbuf && hbuf != hbuf_small) free(hbuf);\n    if(name) releaseAtom(name);\n    if(etag) free(etag);\n    if(location) free(location);\n    if(via) releaseAtom(via);\n    if(expect) releaseAtom(expect);\n    if(auth) releaseAtom(auth);\n    if(hopToHop) destroyAtomList(hopToHop);\n        \n    return -1;\n#undef RESIZE_HBUF\n}\n\nint\nhttpFindHeader(AtomPtr header, const char *headers, int hlen,\n               int *value_begin_return, int *value_end_return)\n{\n    int len = header->length;\n    int i = 0;\n\n    while(i + len + 1 < hlen) {\n        if(headers[i + len] == ':' &&\n           lwrcmp(headers + i, header->string, len) == 0) {\n            int j = i + len + 1, k;\n            while(j < hlen && headers[j] == ' ')\n                j++;\n            k = j;\n            while(k < hlen && headers[k] != '\\n' && headers[k] != '\\r')\n                k++;\n            *value_begin_return = j;\n            *value_end_return = k;\n            return 1;\n        } else {\n            while(i < hlen && headers[i] != '\\n' && headers[i] != '\\r')\n                i++;\n            i++;\n            if(i < hlen && headers[i] == '\\n')\n                i++;\n        }\n    }\n    return 0;\n}\n\nint\nparseUrl(const char *url, int len,\n         int *x_return, int *y_return, int *port_return, int *z_return)\n{\n    int x, y, z, port = -1, i = 0;\n\n    if(len >= 7 && lwrcmp(url, \"http://\", 7) == 0) {\n        x = 7;\n        if(x < len && url[x] == '[') {\n            /* RFC 2732 */\n            for(i = x + 1; i < len; i++) {\n                if(url[i] == ']') {\n                    i++;\n                    break;\n                }\n                if((url[i] != ':') && !letter(url[i]) && !digit(url[i]))\n                    break;\n            }\n        } else {\n            for(i = x; i < len; i++)\n                if(url[i] == ':' || url[i] == '/')\n                    break;\n        }\n        y = i;\n\n        if(i < len && url[i] == ':') {\n            int j;\n            j = atoi_n(url, i + 1, len, &port);\n            if(j < 0) {\n                port = 80;\n            } else {\n                    i = j;\n            }\n        } else {\n            port = 80;\n        }\n    } else {\n        x = -1;\n        y = -1;\n    }\n\n    z = i;\n\n    *x_return = x;\n    *y_return = y;\n    *port_return = port;\n    *z_return = z;\n    return 0;\n}\n\nint\nurlIsLocal(const char *url, int len)\n{\n    return (len > 0 && url[0] == '/');\n}\n\nint\nurlIsSpecial(const char *url, int len)\n{\n    return (len >= 8 && memcmp(url, \"/polipo/\", 8) == 0);\n}\n\nint\nparseChunkSize(const char *restrict buf, int i, int end,\n               int *chunk_size_return)\n{\n    int v, d;\n    v = h2i(buf[i]);\n    if(v < 0)\n        return -1;\n\n    i++;\n\n    while(i < end) {\n        d = h2i(buf[i]);\n        if(d < 0)\n            break;\n        v = v * 16 + d;\n        i++;\n    }\n\n    while(i < end) {\n        if(buf[i] == ' ' || buf[i] == '\\t')\n            i++;\n        else\n            break;\n    }\n\n    if(i >= end - 1)\n        return 0;\n\n    if(buf[i] != '\\r' || buf[i + 1] != '\\n')\n        return -1;\n\n    i += 2;\n\n    if(v == 0) {\n        if(i >= end - 1)\n            return 0;\n        if(buf[i] != '\\r') {\n            do_log(L_ERROR, \"Trailers present!\\n\");\n            return -1;\n        }\n        i++;\n        if(buf[i] != '\\n')\n            return -1;\n        i++;\n    }\n\n    *chunk_size_return = v;\n    return i;\n}\n\n\nint\ncheckVia(AtomPtr name, AtomPtr via)\n{\n    int i;\n    char *v;\n    if(via == NULL || via->length == 0)\n        return 1;\n\n    v = via->string;\n\n    i = 0;\n    while(i < via->length) {\n        while(v[i] == ' ' || v[i] == '\\t' || v[i] == ',' ||\n              v[i] == '\\r' || v[i] == '\\n' ||\n              digit(v[i]) || v[i] == '.')\n            i++;\n        if(i + name->length > via->length)\n            break;\n        if(memcmp(v + i, name->string, name->length) == 0) {\n            char c = v[i + name->length];\n            if(c == '\\0' || c == ' ' || c == '\\t' || c == ',' ||\n               c == '\\r' || c == '\\n')\n                return 0;\n        }\n        i++;\n        while(letter(v[i]) || digit(v[i]) || v[i] == '.')\n            i++;\n    }\n    return 1;\n}\n"
        },
        {
          "name": "http_parse.h",
          "type": "blob",
          "size": 2.5576171875,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ntypedef struct HTTPRange {\n    int from;\n    int to;\n    int full_length;\n} HTTPRangeRec, *HTTPRangePtr;\n\nextern int censorReferer;\nextern AtomPtr atomContentType, atomContentEncoding;\n\nvoid preinitHttpParser(void);\nvoid initHttpParser(void);\nint httpParseClientFirstLine(const char *buf, int offset,\n                             int *method_return,\n                             AtomPtr *url_return,\n                             int *version_return);\nint httpParseServerFirstLine(const char *buf, \n                             int *status_return,\n                             int *version_return,\n                             AtomPtr *message_return);\n\nint findEndOfHeaders(const char *buf, int from, int to, int *body_return);\n\nint httpParseHeaders(int, AtomPtr, const char *, int, HTTPRequestPtr,\n                     AtomPtr*, int*, CacheControlPtr, \n                     HTTPConditionPtr *, int*,\n                     time_t*, time_t*, time_t*, time_t*, time_t*,\n                     int*, int*, char**, AtomPtr*,\n                     HTTPRangePtr, HTTPRangePtr, char**, AtomPtr*, AtomPtr*);\nint httpFindHeader(AtomPtr header, const char *headers, int hlen,\n                   int *value_begin_return, int *value_end_return);\nint parseUrl(const char *url, int len,\n             int *x_return, int *y_return, int *port_return, int *z_return);\nint urlIsLocal(const char *url, int len);\nint urlIsSpecial(const char *url, int len);\nint parseChunkSize(const char *buf, int i, int end, int *chunk_size_return);\nint checkVia(AtomPtr, AtomPtr);\n"
        },
        {
          "name": "io.c",
          "type": "blob",
          "size": 31.203125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifdef HAVE_IPv6\n#ifdef IPV6_PREFER_TEMPADDR\n#define HAVE_IPV6_PREFER_TEMPADDR 1\n#endif\n#endif\n\n#ifdef HAVE_IPV6_PREFER_TEMPADDR\nint useTemporarySourceAddress = 1;\n#endif\n\nAtomPtr proxyOutgoingAddress = NULL;\n\nvoid\npreinitIo()\n{\n#ifdef HAVE_IPV6_PREFER_TEMPADDR\n    CONFIG_VARIABLE_SETTABLE(useTemporarySourceAddress, CONFIG_TRISTATE,\n                             configIntSetter,\n                             \"Prefer IPv6 temporary source address.\");\n#endif\n\n    CONFIG_VARIABLE(proxyOutgoingAddress, CONFIG_ATOM_LOWER,\n                    \"The IP address which the proxy connects from.\");\n\n#ifdef HAVE_WINSOCK\n    /* Load the winsock dll */\n    WSADATA wsaData;\n    WORD wVersionRequested = MAKEWORD(2, 2);\n    int err = WSAStartup( wVersionRequested, &wsaData );\n    if (err != 0) {\n        do_log_error(L_ERROR, err, \"Couldn't load winsock dll\");\n        exit(-1);\n    }\n#endif\n    return;\n}\n\nvoid\ninitIo()\n{\n    return;\n}\n\nFdEventHandlerPtr\ndo_stream(int operation, int fd, int offset, char *buf, int len,\n          int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n          void *data)\n{\n    assert(len > offset || (operation & (IO_END | IO_IMMEDIATE)));\n    return schedule_stream(operation, fd, offset, \n                           NULL, 0, buf, len, NULL, 0, NULL, 0, NULL,\n                           handler, data);\n}\n\nFdEventHandlerPtr\ndo_stream_2(int operation, int fd, int offset, \n            char *buf, int len, char *buf2, int len2,\n            int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n            void *data)\n{\n    assert(len + len2 > offset || (operation & (IO_END | IO_IMMEDIATE)));\n    return schedule_stream(operation, fd, offset,\n                           NULL, 0, buf, len, buf2, len2, NULL, 0, NULL,\n                           handler, data);\n}\n\nFdEventHandlerPtr\ndo_stream_3(int operation, int fd, int offset, \n            char *buf, int len, char *buf2, int len2, char *buf3, int len3,\n            int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n            void *data)\n{\n    assert(len + len2 > offset || (operation & (IO_END | IO_IMMEDIATE)));\n    return schedule_stream(operation, fd, offset,\n                           NULL, 0, buf, len, buf2, len2, buf3, len3, NULL,\n                           handler, data);\n}\n\nFdEventHandlerPtr\ndo_stream_h(int operation, int fd, int offset,\n            char *header, int hlen, char *buf, int len,\n            int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n            void *data)\n{\n    assert(hlen + len > offset || (operation & (IO_END | IO_IMMEDIATE)));\n    return schedule_stream(operation, fd, offset, \n                           header, hlen, buf, len, NULL, 0, NULL, 0, NULL,\n                           handler, data);\n}\n\nFdEventHandlerPtr\ndo_stream_buf(int operation, int fd, int offset, char **buf_location, int len,\n              int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n              void *data)\n{\n    assert((len > offset || (operation & (IO_END | IO_IMMEDIATE)))\n           && len <= CHUNK_SIZE);\n    return schedule_stream(operation, fd, offset,\n                           NULL, 0, *buf_location, len, \n                           NULL, 0, NULL, 0, buf_location,\n                           handler, data);\n}\n\nstatic int\nchunkHeaderLen(int i)\n{\n    if(i <= 0)\n        return 0;\n    if(i < 0x10)\n        return 3;\n    else if(i < 0x100)\n        return 4;\n    else if(i < 0x1000)\n        return 5;\n    else if(i < 0x10000)\n        return 6;\n    else\n        abort();\n}\n\nstatic int\nchunkHeader(char *buf, int buflen, int i)\n{\n    int n;\n    if(i <= 0)\n        return 0;\n    n = snprintf(buf, buflen, \"%x\\r\\n\", i);\n    return n;\n}\n\n\nFdEventHandlerPtr\nschedule_stream(int operation, int fd, int offset,\n                char *header, int hlen,\n                char *buf, int len, char *buf2, int len2, char *buf3, int len3,\n                char **buf_location,\n                int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n                void *data)\n{\n    StreamRequestRec request;\n    FdEventHandlerPtr event;\n    int done;\n\n    request.operation = operation;\n    request.fd = fd;\n    if(len3) {\n        assert(hlen == 0 && buf_location == NULL);\n        request.u.b.len3 = len3;\n        request.u.b.buf3 = buf3;\n        request.operation |= IO_BUF3;\n    } else if(buf_location) {\n        assert(hlen == 0);\n        request.u.l.buf_location = buf_location;\n        request.operation |= IO_BUF_LOCATION;\n    } else {\n        request.u.h.hlen = hlen;\n        request.u.h.header = header;\n    }\n    request.buf = buf;\n    request.len = len;\n    request.buf2 = buf2;\n    request.len2 = len2;\n    if((operation & IO_CHUNKED) || \n       (!(request.operation & (IO_BUF3 | IO_BUF_LOCATION)) && hlen > 0)) {\n        assert(offset == 0);\n        request.offset = -hlen;\n        if(operation & IO_CHUNKED)\n            request.offset += -chunkHeaderLen(len + len2);\n    } else {\n        request.offset = offset;\n    }\n    request.handler = handler;\n    request.data = data;\n    event = makeFdEvent(fd, \n                        (operation & IO_MASK) == IO_WRITE ?\n                        POLLOUT : POLLIN, \n                        do_scheduled_stream, \n                        sizeof(StreamRequestRec), &request);\n    if(!event) {\n        done = (*handler)(-ENOMEM, NULL, &request);\n        assert(done);\n        return NULL;\n    }\n\n    if(!(operation & IO_NOTNOW)) {\n        done = event->handler(0, event);\n        if(done) {\n            free(event);\n            return NULL;\n        }\n    } \n\n    if(operation & IO_IMMEDIATE) {\n        assert(hlen == 0 && !(operation & IO_CHUNKED));\n        done = (*handler)(0, event, &request);\n        if(done) {\n            free(event);\n            return NULL;\n        }\n    }\n    event = registerFdEventHelper(event);\n    return event;\n}\n\nstatic const char *endChunkTrailer = \"\\r\\n0\\r\\n\\r\\n\";\n\nint\ndo_scheduled_stream(int status, FdEventHandlerPtr event)\n{\n    StreamRequestPtr request = (StreamRequestPtr)&event->data;\n    int rc, done, i;\n    struct iovec iov[6];\n    int chunk_header_len;\n    char chunk_header[10];\n    int len12 = request->len + request->len2;\n    int len123 = \n        request->len + request->len2 + \n        ((request->operation & IO_BUF3) ? request->u.b.len3 : 0);\n\n    if(status) {\n        done = request->handler(status, event, request);\n        return done;\n    }\n\n    i = 0;\n\n    if(request->offset < 0) {\n        assert((request->operation & (IO_MASK | IO_BUF3 | IO_BUF_LOCATION)) == \n               IO_WRITE);\n        if(request->operation & IO_CHUNKED) {\n            chunk_header_len = chunkHeaderLen(len123);\n        } else {\n            chunk_header_len = 0;\n        }\n\n        if(request->offset < -chunk_header_len) {\n            assert(request->offset >= -(request->u.h.hlen + chunk_header_len));\n            iov[i].iov_base = request->u.h.header;\n            iov[i].iov_len = -request->offset - chunk_header_len;\n            i++;\n        }\n\n        if(chunk_header_len > 0) {\n            chunkHeader(chunk_header, 10, len123);\n            if(request->offset < -chunk_header_len) {\n                iov[i].iov_base = chunk_header;\n                iov[i].iov_len = chunk_header_len;\n            } else {\n                iov[i].iov_base = chunk_header + \n                    chunk_header_len + request->offset;\n                iov[i].iov_len = -request->offset;\n            }\n            i++;\n        }\n    }\n\n    if(request->len > 0) {\n        if(request->buf == NULL && \n           (request->operation & IO_BUF_LOCATION)) {\n            assert(*request->u.l.buf_location == NULL);\n            request->buf = *request->u.l.buf_location = get_chunk();\n            if(request->buf == NULL) {\n                done = request->handler(-ENOMEM, event, request);\n                return done;\n            }\n        }\n        if(request->offset <= 0) {\n            iov[i].iov_base = request->buf;\n            iov[i].iov_len = request->len;\n            i++;\n        } else if(request->offset < request->len) {\n            iov[i].iov_base = request->buf + request->offset;\n            iov[i].iov_len = request->len - request->offset;\n            i++;\n        }\n    }\n\n    if(request->len2 > 0) {\n        if(request->offset <= request->len) {\n            iov[i].iov_base = request->buf2;\n            iov[i].iov_len = request->len2;\n            i++;\n        } else if(request->offset < request->len + request->len2) {\n            iov[i].iov_base = request->buf2 + request->offset - request->len;\n            iov[i].iov_len = request->len2 - request->offset + request->len;\n            i++;\n        }\n    }\n\n    if((request->operation & IO_BUF3) && request->u.b.len3 > 0) {\n        if(request->offset <= len12) {\n            iov[i].iov_base = request->u.b.buf3;\n            iov[i].iov_len = request->u.b.len3;\n            i++;\n        } else if(request->offset < len12 + request->u.b.len3) {\n            iov[i].iov_base = request->u.b.buf3 + request->offset - len12;\n            iov[i].iov_len = request->u.b.len3 - request->offset + len12;\n            i++;\n        }\n    }\n\n    if((request->operation & IO_CHUNKED)) {\n        int l;\n        const char *trailer;\n        if(request->operation & IO_END) {\n            if(len123 == 0) {\n                trailer = endChunkTrailer + 2;\n                l = 5;\n            } else {\n                trailer = endChunkTrailer;\n                l = 7;\n            }\n        } else {\n            trailer = endChunkTrailer;\n            l = 2;\n        }\n\n        if(request->offset <= len123) {\n            iov[i].iov_base = (char*)trailer;\n            iov[i].iov_len = l;\n            i++;\n        } else if(request->offset < len123 + l) {\n            iov[i].iov_base = \n                (char*)endChunkTrailer + request->offset - len123;\n            iov[i].iov_len = l - request->offset + len123;\n            i++;\n        }\n    }\n\n    assert(i > 0);\n\n    if((request->operation & IO_MASK) == IO_WRITE) {\n        if(i > 1) \n            rc = WRITEV(request->fd, iov, i);\n        else\n            rc = WRITE(request->fd, iov[0].iov_base, iov[0].iov_len);\n    } else {\n        if(i > 1) \n            rc = READV(request->fd, iov, i);\n        else\n            rc = READ(request->fd, iov[0].iov_base, iov[0].iov_len);\n    }\n\n    if(rc > 0) {\n        request->offset += rc;\n        if(request->offset < 0) return 0;\n        done = request->handler(0, event, request);\n        return done;\n    } else if(rc == 0 || errno == EPIPE) {\n        done = request->handler(1, event, request);\n    } else if(errno == EAGAIN || errno == EINTR) {\n        return 0;\n    } else if(errno == EFAULT || errno == EBADF) {\n        abort();\n    } else {\n        done = request->handler(-errno, event, request);\n    }\n    assert(done);\n    return done;\n}\n\nint\nstreamRequestDone(StreamRequestPtr request)\n{\n    int len123 = \n        request->len + request->len2 +\n        ((request->operation & IO_BUF3) ? request->u.b.len3 : 0);\n\n    if(request->offset < 0)\n        return 0;\n    else if(request->offset < len123)\n        return 0;\n    else if(request->operation & IO_CHUNKED) {\n        if(request->operation & IO_END) {\n            if(request->offset < len123 + (len123 ? 7 : 5))\n                return 0;\n        } else {\n            if(request->offset < len123 + 2)\n                return 0;\n        }\n    }\n\n    return 1;\n}\n\nstatic int\nserverSocket_outgoingIP(int fd)\n{\n        int rc;\n        unsigned long int bind_addr_saddr = inet_addr (proxyOutgoingAddress->string);\n        struct sockaddr_in local_sockaddr_in[] = {{ 0 }};\n\n        local_sockaddr_in->sin_family = AF_INET;\n        local_sockaddr_in->sin_addr.s_addr = bind_addr_saddr;\n        local_sockaddr_in->sin_port = htons (0);\n\n        rc = bind(fd, (struct sockaddr *)local_sockaddr_in, sizeof (struct sockaddr));\n        if(rc != 0) {\n            do_log_error(L_WARN, errno, \"Couldn't bind outgoing IP %s\", proxyOutgoingAddress->string);\n        }\n\n        return rc;\n}\n\nstatic int\nserverSocket(int af)\n{\n    int fd, rc;\n    if(af == 4) {\n        fd = socket(PF_INET, SOCK_STREAM, 0);\n    } else if(af == 6) {\n#ifdef HAVE_IPv6\n        fd = socket(PF_INET6, SOCK_STREAM, 0);\n#else\n        fd = -1;\n        errno = EAFNOSUPPORT;\n#endif\n    } else {\n        abort();\n    }\n\n    if(fd >= 0) {\n        if(proxyOutgoingAddress != NULL) {\n            serverSocket_outgoingIP(fd);\n        }\n\n        rc = setNonblocking(fd, 1);\n        if(rc < 0) {\n            int errno_save = errno;\n            CLOSE(fd);\n            errno = errno_save;\n            return -1;\n        }\n#ifdef HAVE_IPV6_PREFER_TEMPADDR\n\tif (af == 6 && useTemporarySourceAddress != 1) {\n            int value;\n            value = (useTemporarySourceAddress == 2) ? 1 : 0;\n            rc = setsockopt(fd, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR,\n                            &value, sizeof(value));\n            if (rc < 0) {\n                /* no error, warning only */\n                do_log_error(L_WARN, errno, \"Couldn't set IPV6CTL_USETEMPADDR\");\n            }\n\t}\n\n#endif\n    }\n    return fd;\n}\n\nFdEventHandlerPtr\ndo_connect(AtomPtr addr, int index, int port,\n           int (*handler)(int, FdEventHandlerPtr, ConnectRequestPtr),\n           void *data)\n{\n    ConnectRequestRec request;\n    FdEventHandlerPtr event;\n    int done, fd, af;\n\n    assert(addr->length > 0 && addr->string[0] == DNS_A);\n    assert(addr->length % sizeof(HostAddressRec) == 1);\n\n    if(index >= (addr->length - 1)/ sizeof(HostAddressRec))\n        index = 0;\n\n    request.firstindex = index;\n    request.port = port;\n    request.handler = handler;\n    request.data = data;\n again:\n    af = addr->string[1 + index * sizeof(HostAddressRec)];\n    fd = serverSocket(af);\n\n    request.fd = fd;\n    request.af = af;\n    request.addr = addr;\n    request.index = index;\n\n    if(fd < 0) {\n        int n = (addr->length - 1) / sizeof(HostAddressRec);\n        if(errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT) {\n            if((index + 1) % n != request.firstindex) {\n                index = (index + 1) % n;\n                goto again;\n            }\n        }\n        do_log_error(L_ERROR, errno, \"Couldn't create socket\");\n        done = (*handler)(-errno, NULL, &request);\n        assert(done);\n        return NULL;\n    }\n\n    /* POLLIN is apparently needed on Windows */\n    event = registerFdEvent(fd, POLLIN | POLLOUT,\n                            do_scheduled_connect,\n                            sizeof(ConnectRequestRec), &request);\n    if(event == NULL) {\n        done = (*handler)(-ENOMEM, NULL, &request);\n        assert(done);\n        return NULL;\n    }\n\n    done = event->handler(0, event);\n    if(done) {\n        unregisterFdEvent(event);\n        return NULL;\n    }\n    return event;\n}\n\nint\ndo_scheduled_connect(int status, FdEventHandlerPtr event)\n{\n    ConnectRequestPtr request = (ConnectRequestPtr)&event->data;\n    AtomPtr addr = request->addr;\n    int done;\n    int rc;\n    HostAddressPtr host;\n    struct sockaddr_in servaddr;\n#ifdef HAVE_IPv6\n    struct sockaddr_in6 servaddr6;\n#endif\n\n    assert(addr->length > 0 && addr->string[0] == DNS_A);\n    assert(addr->length % sizeof(HostAddressRec) == 1);\n    assert(request->index < (addr->length - 1) / sizeof(HostAddressRec));\n\n    if(status) {\n        done = request->handler(status, event, request);\n        if(done) {\n            releaseAtom(addr);\n            request->addr = NULL;\n            return 1;\n        }\n        return 0;\n    }\n\n again:\n    host = (HostAddressPtr)&addr->string[1 + \n                                         request->index * \n                                         sizeof(HostAddressRec)];\n    if(host->af != request->af) {\n        int newfd;\n        /* Ouch.  Our socket has a different protocol than the host\n           address. */\n        CLOSE(request->fd);\n        newfd = serverSocket(host->af);\n        if(newfd < 0) {\n            if(errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT) {\n                int n = request->addr->length / sizeof(HostAddressRec);\n                if((request->index + 1) % n != request->firstindex) {\n                    request->index = (request->index + 1) % n;\n                    goto again;\n                }\n            }\n            request->fd = -1;\n            done = request->handler(-errno, event, request);\n            assert(done);\n            return 1;\n        }\n        if(newfd != request->fd) {\n            request->fd = dup2(newfd, request->fd);\n            CLOSE(newfd);\n            if(request->fd < 0) {\n                done = request->handler(-errno, event, request);\n                assert(done);\n                return 1;\n            }\n        }\n        request->af = host->af;\n    }\n    switch(host->af) {\n    case 4:\n        memset(&servaddr, 0, sizeof(servaddr));\n        servaddr.sin_family = AF_INET;\n        servaddr.sin_port = htons(request->port);\n        memcpy(&servaddr.sin_addr, &host->data, sizeof(struct in_addr));\n        rc = connect(request->fd,\n                     (struct sockaddr*)&servaddr, sizeof(servaddr));\n        break;\n    case 6:\n#ifdef HAVE_IPv6\n        memset(&servaddr6, 0, sizeof(servaddr6));\n        servaddr6.sin6_family = AF_INET6;\n        servaddr6.sin6_port = htons(request->port);\n        memcpy(&servaddr6.sin6_addr, &host->data, sizeof(struct in6_addr));\n        rc = connect(request->fd,\n                     (struct sockaddr*)&servaddr6, sizeof(servaddr6));\n#else\n        rc = -1;\n        errno = EAFNOSUPPORT;\n#endif\n        break;\n    default:\n        abort();\n    }\n        \n    if(rc >= 0 || errno == EISCONN) {\n        done = request->handler(1, event, request);\n        assert(done);\n        releaseAtom(request->addr);\n        request->addr = NULL;\n        return 1;\n    }\n\n    if(errno == EINPROGRESS || errno == EINTR) {\n        return 0;\n    } else if(errno == EFAULT || errno == EBADF) {\n        abort();\n    } else {\n        int n = request->addr->length / sizeof(HostAddressRec);\n        if((request->index + 1) % n != request->firstindex) {\n            request->index = (request->index + 1) % n;\n            goto again;\n        }\n        done = request->handler(-errno, event, request);\n        assert(done);\n        releaseAtom(request->addr);\n        request->addr = NULL;\n        return 1;\n    }\n}\n\nFdEventHandlerPtr\ndo_accept(int fd,\n          int (*handler)(int, FdEventHandlerPtr, AcceptRequestPtr),\n          void *data)\n{\n    FdEventHandlerPtr event;\n    int done;\n\n    event = schedule_accept(fd, handler, data);\n    if(event == NULL) {\n        done = (*handler)(-ENOMEM, NULL, NULL);\n        assert(done);\n    }\n\n    /* But don't invoke it now - this will delay accept if under load. */\n    return event;\n}\n\nFdEventHandlerPtr\nschedule_accept(int fd,\n                int (*handler)(int, FdEventHandlerPtr, AcceptRequestPtr),\n                void *data)\n{\n    FdEventHandlerPtr event;\n    AcceptRequestRec request;\n    int done;\n\n    request.fd = fd;\n    request.handler = handler;\n    request.data = data;\n    event = registerFdEvent(fd, POLLIN, \n                            do_scheduled_accept, sizeof(request), &request);\n    if(!event) {\n        done = (*handler)(-ENOMEM, NULL, NULL);\n        assert(done);\n    }\n    return event;\n}\n\nint\ndo_scheduled_accept(int status, FdEventHandlerPtr event)\n{\n    AcceptRequestPtr request = (AcceptRequestPtr)&event->data;\n    int rc, done;\n    socklen_t len;\n    struct sockaddr_in addr;\n\n    if(status) {\n        done = request->handler(status, event, request);\n        if(done) return done;\n    }\n\n    len = sizeof(struct sockaddr_in);\n\n    rc = accept(request->fd, (struct sockaddr*)&addr, &len);\n\n    if(rc >= 0)\n        done = request->handler(rc, event, request);\n    else\n        done = request->handler(-errno, event, request);\n    return done;\n}\n\nFdEventHandlerPtr\ncreate_listener(char *address, int port,\n                int (*handler)(int, FdEventHandlerPtr, AcceptRequestPtr),\n                void *data)\n{\n    int fd, rc;\n    int one = 1;\n    int done;\n    struct sockaddr_in addr;\n#ifdef HAVE_IPv6\n    int inet6 = 1;\n    struct sockaddr_in6 addr6;\n#else\n    int inet6 = 0;\n#endif\n\n    if(inet6 && address) {\n        struct in_addr buf;\n        rc = inet_aton(address, &buf);\n        if(rc == 1)\n            inet6 = 0;\n    }\n    fd = -1;\n    errno = EAFNOSUPPORT;\n\n#ifdef HAVE_IPv6\n    if(inet6) {\n        fd = socket(PF_INET6, SOCK_STREAM, 0);\n    }\n#endif\n\n    if(fd < 0 && (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT)) {\n        inet6 = 0;\n        fd = socket(PF_INET, SOCK_STREAM, 0);\n    }\n\n    if(fd < 0) {\n        done = (*handler)(-errno, NULL, NULL);\n        assert(done);\n        return NULL;\n    }\n\n#ifndef WIN32\n    /* on WIN32 SO_REUSEADDR allows two sockets bind to the same port */\n    rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one));\n    if(rc < 0) do_log_error(L_WARN, errno, \"Couldn't set SO_REUSEADDR\");\n#endif\n\n    if(inet6) {\n#ifdef HAVE_IPv6\n        rc = setV6only(fd, 0);\n        if(rc < 0)\n            /* Reportedly OpenBSD returns an error for that.  So only\n               log it as a debugging message. */\n            do_log_error(D_CLIENT_CONN, errno, \"Couldn't reset IPV6_V6ONLY\");\n\n        memset(&addr6, 0, sizeof(addr6));\n        rc = inet_pton(AF_INET6, address, &addr6.sin6_addr);\n        if(rc != 1) {\n            done = (*handler)(rc == 0 ? -ESYNTAX : -errno, NULL, NULL);\n            assert(done);\n            return NULL;\n        }\n        addr6.sin6_family = AF_INET6;\n        addr6.sin6_port = htons(port);\n        rc = bind(fd, (struct sockaddr*)&addr6, sizeof(addr6));\n#else\n        rc = -1;\n        errno = EAFNOSUPPORT;\n#endif\n    } else {\n        memset(&addr, 0, sizeof(addr));\n        rc = inet_aton(address, &addr.sin_addr);\n        if(rc != 1) {\n            done = (*handler)(rc == 0 ? -ESYNTAX : -errno, NULL, NULL);\n            assert(done);\n            return NULL;\n        }\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(port);\n        rc = bind(fd, (struct sockaddr*)&addr, sizeof(addr));\n    }\n\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't bind\");\n        CLOSE(fd);\n        done = (*handler)(-errno, NULL, NULL);\n        assert(done);\n        return NULL;\n    }\n\n    rc = setNonblocking(fd, 1);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't set non blocking mode\");\n        CLOSE(fd);\n        done = (*handler)(-errno, NULL, NULL);\n        assert(done);\n        return NULL;\n    }\n        \n    rc = listen(fd, 1024);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't listen\");\n        CLOSE(fd);\n        done = (*handler)(-errno, NULL, NULL);\n        assert(done);\n        return NULL;\n    }\n\n    do_log(L_INFO, \"Established listening socket on port %d.\\n\", port);\n\n    return schedule_accept(fd, handler, data);\n}\n\n#ifndef SOL_TCP\n/* BSD */\n#define SOL_TCP IPPROTO_TCP\n#endif\n\nint\nsetNonblocking(int fd, int nonblocking)\n{\n#ifdef WIN32 /*MINGW*/\n    return win32_setnonblocking(fd, nonblocking);\n#else\n    int rc;\n    rc = fcntl(fd, F_GETFL, 0);\n    if(rc < 0)\n        return -1;\n\n    rc = fcntl(fd, F_SETFL, nonblocking?(rc | O_NONBLOCK):(rc & ~O_NONBLOCK));\n    if(rc < 0)\n        return -1;\n\n    return 0;\n#endif\n}\n\nint\nsetNodelay(int fd, int nodelay)\n{\n    int val = nodelay ? 1 : 0;\n    int rc;\n    rc = setsockopt(fd, SOL_TCP, TCP_NODELAY, (char *)&val, sizeof(val));\n    if(rc < 0)\n        return -1;\n    return 0;\n}\n\n#ifdef IPV6_V6ONLY\nint\nsetV6only(int fd, int v6only)\n{\n    int val = v6only ? 1 : 0;\n    int rc;\n    rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&val, sizeof(val));\n    if(rc < 0)\n        return -1;\n    return 0;\n}\n#else\nint\nsetV6only(int fd, int v6only)\n{\n    return 0;\n}\n#endif\n\ntypedef struct _LingeringClose {\n    int fd;\n    FdEventHandlerPtr handler;\n    TimeEventHandlerPtr timeout;\n} LingeringCloseRec, *LingeringClosePtr;\n\nstatic int\nlingeringCloseTimeoutHandler(TimeEventHandlerPtr event)\n{\n    LingeringClosePtr l = *(LingeringClosePtr*)event->data;\n    assert(l->timeout == event);\n    l->timeout = NULL;\n    if(l->handler)\n        pokeFdEvent(l->fd, -ESHUTDOWN, POLLIN | POLLOUT);\n    else {\n        CLOSE(l->fd);\n        free(l);\n    }\n    return 1;\n}\n\nstatic int\nlingeringCloseHandler(int status, FdEventHandlerPtr event)\n{\n    LingeringClosePtr l = *(LingeringClosePtr*)event->data;\n    char buf[17];\n    int rc;\n\n    assert(l->handler == event);\n\n    l->handler = NULL;\n    if(status && status != -EDOGRACEFUL)\n        goto done;\n\n    rc = READ(l->fd, &buf, 17);\n    if(rc == 0 || (rc < 0 && errno != EAGAIN && errno != EINTR))\n        goto done;\n\n    /* The client is still sending data.  Ignore it in order to let\n       TCP's flow control do its work.  The timeout will close the\n       connection. */\n    return 1;\n\n done:\n    if(l->timeout) {\n        cancelTimeEvent(l->timeout);\n        l->timeout = NULL;\n    }\n    CLOSE(l->fd);\n    free(l);\n    return 1;\n}\n\nint\nlingeringClose(int fd)\n{\n    int rc;\n    LingeringClosePtr l;\n\n    rc = shutdown(fd, 1);\n    if(rc < 0) {\n        if(errno != ENOTCONN) {\n            do_log_error(L_ERROR, errno, \"Shutdown failed\");\n        } else if(errno == EFAULT || errno == EBADF) {\n            abort();\n        }\n        CLOSE(fd);\n        return 1;\n    }\n\n    l = malloc(sizeof(LingeringCloseRec));\n    if(l == NULL)\n        goto fail;\n    l->fd = fd;\n    l->handler = NULL;\n    l->timeout = NULL;\n\n    l->timeout = scheduleTimeEvent(10, lingeringCloseTimeoutHandler,\n                                   sizeof(LingeringClosePtr), &l);\n    if(l->timeout == NULL) {\n        free(l);\n        goto fail;\n    }\n\n    l->handler = registerFdEvent(fd, POLLIN,\n                                 lingeringCloseHandler,\n                                 sizeof(LingeringClosePtr), &l);\n    if(l->handler == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule lingering close handler.\\n\");\n        /* But don't close -- the timeout will do its work. */\n    }\n    return 1;\n\n fail:\n    do_log(L_ERROR, \"Couldn't schedule lingering close.\\n\");\n    CLOSE(fd);\n    return 1;\n}\n\nNetAddressPtr\nparseNetAddress(AtomListPtr list)\n{\n    NetAddressPtr nl;\n    int i, rc, rc6;\n    char buf[100];\n    struct in_addr ina;\n#ifdef HAVE_IPv6\n    struct in6_addr ina6;\n#endif\n\n    nl = malloc((list->length + 1) * sizeof(NetAddressRec));\n    if(nl == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate network list.\\n\");\n        return NULL;\n    }\n\n    for(i = 0; i < list->length; i++) {\n        int prefix;\n        char *s = list->list[i]->string, *p;\n        int n = list->list[i]->length;\n        char *suffix;\n\n        while(*s == ' ' || *s == '\\t') {\n            s++;\n            n--;\n        }\n\n        if(n >= 100) {\n            do_log(L_ERROR, \"Network name too long.\\n\");\n            goto fail;\n        }\n        p = memchr(s, '/', n);\n        if(p) {\n            memcpy(buf, s, p - s);\n            buf[p - s] = '\\0';\n            prefix = strtol(p + 1, &suffix, 10);\n        } else {\n            char *s1, *s2;\n            prefix = -1;\n            strcpy(buf, s);\n            s1 = strchr(s, ' ');\n            s2 = strchr(s, '\\t');\n            if(s1 == NULL) suffix = s2;\n            else if(s2 == NULL) suffix = s1;\n            else if(s1 < s2) suffix = s1;\n            else suffix = s2;\n            if(suffix == NULL)\n                suffix = s + n;\n        }\n\n        if(!isWhitespace(suffix)) {\n            do_log(L_ERROR, \"Couldn't parse network %s.\\n\", buf);\n            goto fail;\n        }\n\n        rc = 0; rc6 = 0;\n        rc = inet_aton(buf, &ina);\n#ifdef HAVE_IPv6\n        if(rc == 0) {\n            rc6 = inet_pton(AF_INET6, buf, &ina6);\n        }\n#endif\n        if(rc == 0 && rc6 == 0) {\n            do_log(L_ERROR, \"Couldn't parse network %s.\\n\", buf);\n            goto fail;\n        }\n        nl[i].prefix = prefix;\n        if(rc) {\n            nl[i].af = 4;\n            memcpy(nl[i].data, &ina, 4);\n        } else {\n#ifdef HAVE_IPv6\n            nl[i].af = 6;\n            memcpy(nl[i].data, &ina6, 16);\n#else\n            abort();\n#endif\n        }\n    }\n    nl[i].af = 0;\n    return nl;\n\n fail:\n    free(nl);\n    return NULL;\n}\n\n/* Returns 1 if the first n bits of a and b are equal */\nstatic int\nbitmatch(const unsigned char *a, const unsigned char *b, int n)\n{\n    if(n >= 8) {\n        if(memcmp(a, b, n / 8) != 0)\n            return 0;\n    }\n\n    if(n % 8 != 0) {\n        int mask = (~0) << (8 - n % 8);\n        if((a[n / 8] & mask) != (b[n / 8] & mask))\n            return 0;\n    }\n\n    return 1;\n}\n\n/* Returns 1 if the address in data is in list */\nstatic int\nmatch(int af, unsigned char *data, NetAddressPtr list)\n{\n    int i;\n#ifdef HAVE_IPv6\n    static const unsigned char v6mapped[] =\n        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF };\n#endif\n\n    i = 0;\n    while(list[i].af != 0) {\n        if(af == 4 && list[i].af == 4) {\n            if(bitmatch(data, list[i].data,\n                        list[i].prefix >= 0 ? list[i].prefix : 32))\n                return 1;\n#ifdef HAVE_IPv6\n        } else if(af == 6 && list[i].af == 6) {\n            if(bitmatch(data, list[i].data,\n                        list[i].prefix >= 0 ? list[i].prefix : 128))\n                return 1;\n        } else if(af == 6 && list[i].af == 4) {\n            if(bitmatch(data, v6mapped, 96)) {\n                if(bitmatch(data + 12, list[i].data,\n                            list[i].prefix >= 0 ? list[i].prefix : 32))\n                    return 1;\n            }\n        } else if(af == 4 && list[i].af == 6) {\n            if(bitmatch(list[i].data, v6mapped, 96)) {\n                if(bitmatch(data, list[i].data + 12,\n                            list[i].prefix >= 96 ?\n                            list[i].prefix - 96 : 32))\n                    return 1;\n            }\n#endif\n        } else {\n            abort();\n        }\n        i++;\n    }\n    return 0;\n}\n\nint\nnetAddressMatch(int fd, NetAddressPtr list)\n{\n    int rc;\n    socklen_t len;\n    struct sockaddr_in sain;\n#ifdef HAVE_IPv6\n    struct sockaddr_in6 sain6;\n#endif\n\n    len = sizeof(sain);\n    rc = getpeername(fd, (struct sockaddr*)&sain, &len);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't get peer name\");\n        return -1;\n    }\n\n    if(sain.sin_family == AF_INET) {\n        return match(4, (unsigned char*)&sain.sin_addr, list);\n#ifdef HAVE_IPv6\n    } else if(sain.sin_family == AF_INET6) {\n        len = sizeof(sain6);\n        rc = getpeername(fd, (struct sockaddr*)&sain6, &len);\n        if(rc < 0) {\n            do_log_error(L_ERROR, errno, \"Couldn't get peer name\");\n            return -1;\n        }\n        if(sain6.sin6_family != AF_INET6) {\n            do_log(L_ERROR, \"Inconsistent peer name\");\n            return -1;\n        }\n        return match(6, (unsigned char*)&sain6.sin6_addr, list);\n#endif\n    } else {\n        do_log(L_ERROR, \"Unknown address family %d\\n\", sain.sin_family);\n        return -1;\n    }\n    return 0;\n}\n\n\n        \n        \n\n    \n"
        },
        {
          "name": "io.h",
          "type": "blob",
          "size": 5.0458984375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* request->operation */\n#define IO_READ 0\n#define IO_WRITE 1\n#define IO_MASK 0xFF\n/* Do not initiate operation now -- wait for the poll loop. */\n#define IO_NOTNOW 0x100\n/* Call the progress handler once if no data arrives immediately. */\n#define IO_IMMEDIATE 0x200\n/* Emit a chunk length before every write operation */\n#define IO_CHUNKED 0x400\n/* Emit a zero-length chunk at the end if chunked */\n#define IO_END 0x800\n\n/* Internal -- header is really buf3 */\n#define IO_BUF3 0x1000\n/* Internal -- header is really buf_location */\n#define IO_BUF_LOCATION 0x2000\n\ntypedef struct _StreamRequest {\n    short operation;\n    short fd;\n    int offset;\n    int len;\n    int len2;\n    union {\n        struct {\n            int hlen;\n            char *header;\n        } h;\n        struct {\n            int len3;\n            char *buf3;\n        } b;\n        struct {\n            char **buf_location;\n        } l;\n    } u;\n    char *buf;\n    char *buf2;\n    int (*handler)(int, FdEventHandlerPtr, struct _StreamRequest*);\n    void *data;\n} StreamRequestRec, *StreamRequestPtr;\n\ntypedef struct _ConnectRequest {\n    int fd;\n    int af;\n    struct _Atom *addr;\n    int firstindex;\n    int index;\n    int port;\n    int (*handler)(int, FdEventHandlerPtr, struct _ConnectRequest*);\n    void *data;\n} ConnectRequestRec, *ConnectRequestPtr;\n\ntypedef struct _AcceptRequest {\n    int fd;\n    int (*handler)(int, FdEventHandlerPtr, struct _AcceptRequest*);\n    void *data;\n} AcceptRequestRec, *AcceptRequestPtr;\n\nvoid preinitIo();\nvoid initIo();\n\nFdEventHandlerPtr\ndo_stream(int operation, int fd, int offset, char *buf, int len,\n          int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n          void *data);\n\nFdEventHandlerPtr\ndo_stream_h(int operation, int fd, int offset, \n            char *header, int hlen, char *buf, int len,\n            int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n            void *data);\n\nFdEventHandlerPtr\ndo_stream_2(int operation, int fd, int offset, \n            char *buf, int len, char *buf2, int len2,\n            int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n            void *data);\n\nFdEventHandlerPtr\ndo_stream_3(int operation, int fd, int offset, \n            char *buf, int len, char *buf2, int len2, char *buf3, int len3,\n            int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n            void *data);\n\nFdEventHandlerPtr\ndo_stream_buf(int operation, int fd, int offset, char **buf_location, int len,\n              int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n              void *data);\n\nFdEventHandlerPtr\nschedule_stream(int operation, int fd, int offset,\n                char *header, int hlen,\n                char *buf, int len, char *buf2, int len2, char *buf3, int len3,\n                char **buf_location,\n                int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n                void *data);\n\nint do_scheduled_stream(int, FdEventHandlerPtr);\nint streamRequestDone(StreamRequestPtr);\n\nFdEventHandlerPtr\ndo_connect(struct _Atom *addr, int index, int port,\n           int (*handler)(int, FdEventHandlerPtr, ConnectRequestPtr),\n           void *data);\n\nint do_scheduled_connect(int, FdEventHandlerPtr event);\n\nFdEventHandlerPtr\ndo_accept(int fd,\n          int (*handler)(int, FdEventHandlerPtr, AcceptRequestPtr),\n          void* data);\n\nFdEventHandlerPtr \nschedule_accept(int fd,\n                int (*handler)(int, FdEventHandlerPtr, AcceptRequestPtr),\n                void* data);\n\nint do_scheduled_accept(int, FdEventHandlerPtr event);\n\nFdEventHandlerPtr\ncreate_listener(char *address, int port,\n                int (*handler)(int, FdEventHandlerPtr, AcceptRequestPtr),\n                void *data);\nint setNonblocking(int fd, int nonblocking);\nint setNodelay(int fd, int nodelay);\nint setV6only(int fd, int v6only);\nint lingeringClose(int fd);\n\ntypedef struct _NetAddress {\n    int prefix;\n    int af;\n    unsigned char data[16];\n} NetAddressRec, *NetAddressPtr;\n\nNetAddressPtr parseNetAddress(AtomListPtr list);\nint netAddressMatch(int fd, NetAddressPtr list) ATTRIBUTE ((pure));\n\n"
        },
        {
          "name": "local.c",
          "type": "blob",
          "size": 24.2822265625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nint disableLocalInterface = 0;\nint disableConfiguration = 0;\nint disableIndexing = 1;\nint disableServersList = 1;\n\nAtomPtr atomInitForbidden;\nAtomPtr atomReopenLog;\nAtomPtr atomDiscardObjects;\nAtomPtr atomWriteoutObjects;\nAtomPtr atomFreeChunkArenas;\n\nvoid\npreinitLocal()\n{\n    atomInitForbidden = internAtom(\"init-forbidden\");\n    atomReopenLog = internAtom(\"reopen-log\");\n    atomDiscardObjects = internAtom(\"discard-objects\");\n    atomWriteoutObjects = internAtom(\"writeout-objects\");\n    atomFreeChunkArenas = internAtom(\"free-chunk-arenas\");\n\n    /* These should not be settable for obvious reasons */\n    CONFIG_VARIABLE(disableLocalInterface, CONFIG_BOOLEAN,\n                    \"Disable the local configuration pages.\");\n    CONFIG_VARIABLE(disableConfiguration, CONFIG_BOOLEAN,\n                    \"Disable reconfiguring Polipo at runtime.\");\n    CONFIG_VARIABLE(disableIndexing, CONFIG_BOOLEAN,\n                    \"Disable indexing of the local cache.\");\n    CONFIG_VARIABLE(disableServersList, CONFIG_BOOLEAN,\n                    \"Disable the list of known servers.\");\n}\n\nstatic void fillSpecialObject(ObjectPtr, void (*)(FILE*, char*), void*);\n\nint\nhttpLocalRequest(ObjectPtr object, int method, int from, int to,\n                 HTTPRequestPtr requestor, void *closure)\n{\n    if(object->requestor == NULL)\n        object->requestor = requestor;\n\n    if(!disableLocalInterface && urlIsSpecial(object->key, object->key_size))\n        return httpSpecialRequest(object, method, from, to, \n                                  requestor, closure);\n\n    if(method >= METHOD_POST) {\n        abortObject(object, 405, internAtom(\"Method not allowed\"));\n    } else if(object->flags & OBJECT_INITIAL) {\n        /* objectFillFromDisk already did the real work but we have to\n           make sure we don't get into an infinite loop. */\n        abortObject(object, 404, internAtom(\"Not found\"));\n    }\n    object->age = current_time.tv_sec;\n    object->date = current_time.tv_sec;\n\n    object->flags &= ~OBJECT_VALIDATING;\n    notifyObject(object);\n    return 1;\n}\n\nvoid\nalternatingHttpStyle(FILE *out, char *id)\n{\n    fprintf(out,\n            \"<style type=\\\"text/css\\\">\\n\"\n            \"#%s tbody tr.even td { background-color: #eee; }\\n\"\n            \"#%s tbody tr.odd  td { background-color: #fff; }\\n\"\n            \"</style>\\n\", id, id);\n}\n\nstatic void\nprintConfig(FILE *out, char *dummy)\n{\n    fprintf(out,\n            \"<!DOCTYPE HTML PUBLIC \"\n            \"\\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n            \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n            \"<html><head>\\n\"\n            \"<title>Polipo configuration</title>\\n\"\n            \"</head><body>\\n\"\n            \"<h1>Polipo configuration</h1>\\n\");\n    printConfigVariables(out, 1);\n    fprintf(out, \"<p><a href=\\\"/polipo/\\\">back</a></p>\");\n    fprintf(out, \"</body></html>\\n\");\n}\n\n#ifndef NO_DISK_CACHE\n\nstatic void\nrecursiveIndexDiskObjects(FILE *out, char *root)\n{\n    indexDiskObjects(out, root, 1);\n}\n\nstatic void\nplainIndexDiskObjects(FILE *out, char *root)\n{\n    indexDiskObjects(out, root, 0);\n}\n#endif\n\nstatic void\nserversList(FILE *out, char *dummy)\n{\n    listServers(out);\n}\n\nstatic int\nmatchUrl(char *base, ObjectPtr object)\n{\n    int n = strlen(base);\n    if(object->key_size < n)\n        return 0;\n    if(memcmp(base, object->key, n) != 0)\n        return 0;\n    return (object->key_size == n) || (((char*)object->key)[n] == '?');\n}\n    \nint \nhttpSpecialRequest(ObjectPtr object, int method, int from, int to,\n                   HTTPRequestPtr requestor, void *closure)\n{\n    char buffer[1024];\n    int hlen;\n\n    if(method >= METHOD_POST) {\n        return httpSpecialSideRequest(object, method, from, to,\n                                      requestor, closure);\n    }\n\n    if(!(object->flags & OBJECT_INITIAL)) {\n        privatiseObject(object, 0);\n        supersedeObject(object);\n        object->flags &= ~(OBJECT_VALIDATING | OBJECT_INPROGRESS);\n        notifyObject(object);\n        return 1;\n    }\n\n    hlen = snnprintf(buffer, 0, 1024,\n                     \"\\r\\nServer: polipo\"\n                     \"\\r\\nContent-Type: text/html\");\n    object->date = current_time.tv_sec;\n    object->age = current_time.tv_sec;\n    object->headers = internAtomN(buffer, hlen);\n    object->code = 200;\n    object->message = internAtom(\"Okay\");\n    object->flags &= ~OBJECT_INITIAL;\n    object->flags |= OBJECT_DYNAMIC;\n\n    if(object->key_size == 8 && memcmp(object->key, \"/polipo/\", 8) == 0) {\n        objectPrintf(object, 0,\n                     \"<!DOCTYPE HTML PUBLIC \"\n                     \"\\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n                     \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n                     \"<html><head>\\n\"\n                     \"<title>Polipo</title>\\n\"\n                     \"</head><body>\\n\"\n                     \"<h1>Polipo</h1>\\n\"\n                     \"<p><a href=\\\"status?\\\">Status report</a>.</p>\\n\"\n                     \"<p><a href=\\\"config?\\\">Current configuration</a>.</p>\\n\"\n                     \"<p><a href=\\\"servers?\\\">Known servers</a>.</p>\\n\"\n#ifndef NO_DISK_CACHE\n                     \"<p><a href=\\\"index?\\\">Disk cache index</a>.</p>\\n\"\n#endif\n                     \"</body></html>\\n\");\n        object->length = object->size;\n    } else if(matchUrl(\"/polipo/status\", object)) {\n        objectPrintf(object, 0,\n                     \"<!DOCTYPE HTML PUBLIC \"\n                     \"\\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n                     \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n                     \"<html><head>\\n\"\n                     \"<title>Polipo status report</title>\\n\"\n                     \"</head><body>\\n\"\n                     \"<h1>Polipo proxy on %s:%d: status report</h1>\\n\"\n                     \"<p>The %s proxy on %s:%d is %s.</p>\\n\"\n                     \"<p>There are %d public and %d private objects \"\n                     \"currently in memory using %d KB in %d chunks \"\n                     \"(%d KB allocated).</p>\\n\"\n                     \"<p>There are %d atoms.</p>\"\n                     \"<p><form method=POST action=\\\"/polipo/status?\\\">\"\n                     \"<input type=submit name=\\\"init-forbidden\\\" \"\n                     \"value=\\\"Read forbidden file\\\"></form>\\n\"\n                     \"<form method=POST action=\\\"/polipo/status?\\\">\"\n                     \"<input type=submit name=\\\"writeout-objects\\\" \"\n                     \"value=\\\"Write out in-memory cache\\\"></form>\\n\"\n                     \"<form method=POST action=\\\"/polipo/status?\\\">\"\n                     \"<input type=submit name=\\\"discard-objects\\\" \"\n                     \"value=\\\"Discard in-memory cache\\\"></form>\\n\"\n                     \"<form method=POST action=\\\"/polipo/status?\\\">\"\n                     \"<input type=submit name=\\\"reopen-log\\\" \"\n                     \"value=\\\"Reopen log file\\\"></form>\\n\"\n                     \"<form method=POST action=\\\"/polipo/status?\\\">\"\n                     \"<input type=submit name=\\\"free-chunk-arenas\\\" \"\n                     \"value=\\\"Free chunk arenas\\\"></form></p>\\n\"\n                     \"<p><a href=\\\"/polipo/\\\">back</a></p>\"\n                     \"</body></html>\\n\",\n                     proxyName->string, proxyPort,\n                     cacheIsShared ? \"shared\" : \"private\",\n                     proxyName->string, proxyPort,\n                     proxyOffline ? \"off line\" :\n                     (relaxTransparency ? \n                      \"on line (transparency relaxed)\" :\n                      \"on line\"),\n                     publicObjectCount, privateObjectCount,\n                     used_chunks * CHUNK_SIZE / 1024, used_chunks,\n                     totalChunkArenaSize() / 1024,\n                     used_atoms);\n        object->expires = current_time.tv_sec;\n        object->length = object->size;\n    } else if(matchUrl(\"/polipo/config\", object)) {\n        fillSpecialObject(object, printConfig, NULL);\n        object->expires = current_time.tv_sec + 5;\n#ifndef NO_DISK_CACHE\n    } else if(matchUrl(\"/polipo/index\", object)) {\n        int len;\n        char *root;\n        if(disableIndexing) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            notifyObject(object);\n            return 1;\n        }\n        len = MAX(0, object->key_size - 14);\n        root = strdup_n((char*)object->key + 14, len);\n        if(root == NULL) {\n            abortObject(object, 503, internAtom(\"Couldn't allocate root\"));\n            notifyObject(object);\n            return 1;\n        }\n        writeoutObjects(1);\n        fillSpecialObject(object, plainIndexDiskObjects, root);\n        free(root);\n        object->expires = current_time.tv_sec + 5;\n    } else if(matchUrl(\"/polipo/recursive-index\", object)) {\n        int len;\n        char *root;\n        if(disableIndexing) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            notifyObject(object);\n            return 1;\n        }\n        len = MAX(0, object->key_size - 24);\n        root = strdup_n((char*)object->key + 24, len);\n        if(root == NULL) {\n            abortObject(object, 503, internAtom(\"Couldn't allocate root\"));\n            notifyObject(object);\n            return 1;\n        }\n        writeoutObjects(1);\n        fillSpecialObject(object, recursiveIndexDiskObjects, root);\n        free(root);\n        object->expires = current_time.tv_sec + 20;\n#endif\n    } else if(matchUrl(\"/polipo/servers\", object)) {\n        if(disableServersList) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            notifyObject(object);\n            return 1;\n        }\n        fillSpecialObject(object, serversList, NULL);\n        object->expires = current_time.tv_sec + 2;\n    } else {\n        abortObject(object, 404, internAtom(\"Not found\"));\n    }\n\n    object->flags &= ~OBJECT_VALIDATING;\n    notifyObject(object);\n    return 1;\n}\n\nint \nhttpSpecialSideRequest(ObjectPtr object, int method, int from, int to,\n                       HTTPRequestPtr requestor, void *closure)\n{\n    HTTPConnectionPtr client = requestor->connection;\n\n    assert(client->request == requestor);\n\n    if(method != METHOD_POST) {\n        httpClientError(requestor, 405, internAtom(\"Method not allowed\"));\n        requestor->connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    if(requestor->flags & REQUEST_WAIT_CONTINUE) {\n        httpClientError(requestor, 417, internAtom(\"Expectation failed\"));\n        requestor->connection->flags &= ~CONN_READER;\n        return 1;\n    }\n\n    return httpSpecialDoSide(requestor);\n}\n\nint\nhttpSpecialDoSide(HTTPRequestPtr requestor)\n{\n    HTTPConnectionPtr client = requestor->connection;\n\n    if(client->reqlen - client->reqbegin >= client->bodylen) {\n        AtomPtr data;\n        data = internAtomN(client->reqbuf + client->reqbegin,\n                           client->reqlen - client->reqbegin);\n        client->reqbegin = 0;\n        client->reqlen = 0;\n        if(data == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate data.\\n\");\n            httpClientError(requestor, 500,\n                            internAtom(\"Couldn't allocate data\"));\n            return 1;\n        }\n        httpSpecialDoSideFinish(data, requestor);\n        return 1;\n    }\n\n    if(client->reqlen - client->reqbegin >= CHUNK_SIZE) {\n        httpClientError(requestor, 500, internAtom(\"POST too large\"));\n        return 1;\n    }\n\n    if(client->reqbegin > 0 && client->reqlen > client->reqbegin) {\n        memmove(client->reqbuf, client->reqbuf + client->reqbegin,\n                client->reqlen - client->reqbegin);\n    }\n    client->reqlen -= client->reqbegin;\n    client->reqbegin = 0;\n\n    do_stream(IO_READ | IO_NOTNOW, client->fd,\n              client->reqlen, client->reqbuf, CHUNK_SIZE,\n              httpSpecialClientSideHandler, client);\n    return 1;\n}\n\nint\nhttpSpecialClientSideHandler(int status,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    int push;\n\n    if((request->object->flags & OBJECT_ABORTED) || \n       !(request->object->flags & OBJECT_INPROGRESS)) {\n        httpClientDiscardBody(connection);\n        httpClientError(request, 503, internAtom(\"Post aborted\"));\n        return 1;\n    }\n        \n    if(status < 0) {\n        do_log_error(L_ERROR, -status, \"Reading from client\");\n        if(status == -EDOGRACEFUL)\n            httpClientFinish(connection, 1);\n        else\n            httpClientFinish(connection, 2);\n        return 1;\n    }\n\n    push = MIN(srequest->offset - connection->reqlen,\n               connection->bodylen - connection->reqoffset);\n    if(push > 0) {\n        connection->reqlen += push;\n        httpSpecialDoSide(request);\n    }\n\n    do_log(L_ERROR, \"Incomplete client request.\\n\");\n    connection->flags &= ~CONN_READER;\n    httpClientRawError(connection, 502,\n                       internAtom(\"Incomplete client request\"), 1);\n    return 1;\n}\n\nint\nhttpSpecialDoSideFinish(AtomPtr data, HTTPRequestPtr requestor)\n{\n    ObjectPtr object = requestor->object;\n\n    if(matchUrl(\"/polipo/config\", object)) {\n        AtomListPtr list = NULL;\n        int i, rc;\n\n        if(disableConfiguration) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            goto out;\n        }\n\n        list = urlDecode(data->string, data->length);\n        if(list == NULL) {\n            abortObject(object, 400,\n                        internAtom(\"Couldn't parse variable to set\"));\n            goto out;\n        }\n        for(i = 0; i < list->length; i++) {\n            rc = parseConfigLine(list->list[i]->string, NULL, 0, 1);\n            if(rc < 0) {\n                abortObject(object, 400,\n                            rc == -1 ?\n                            internAtom(\"Couldn't parse variable to set\") :\n                            internAtom(\"Variable is not settable\"));\n                destroyAtomList(list);\n                goto out;\n            }\n        }\n        destroyAtomList(list);\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->headers = internAtom(\"\\r\\nLocation: /polipo/config?\");\n        object->code = 303;\n        object->message = internAtom(\"Done\");\n        object->flags &= ~OBJECT_INITIAL;\n        object->length = 0;\n    } else if(matchUrl(\"/polipo/status\", object)) {\n        AtomListPtr list = NULL;\n        int i;\n\n        if(disableConfiguration) {\n            abortObject(object, 403, internAtom(\"Action not allowed\"));\n            goto out;\n        }\n\n        list = urlDecode(data->string, data->length);\n        if(list == NULL) {\n            abortObject(object, 400,\n                        internAtom(\"Couldn't parse action\"));\n            goto out;\n        }\n        for(i = 0; i < list->length; i++) {\n            char *equals = \n                memchr(list->list[i]->string, '=', list->list[i]->length);\n            AtomPtr name = \n                equals ? \n                internAtomN(list->list[i]->string, \n                            equals - list->list[i]->string) :\n                retainAtom(list->list[i]);\n            if(name == atomInitForbidden)\n                initForbidden();\n            else if(name == atomReopenLog)\n                reopenLog();\n            else if(name == atomDiscardObjects)\n                discardObjects(1, 0);\n            else if(name == atomWriteoutObjects)\n                writeoutObjects(1);\n            else if(name == atomFreeChunkArenas)\n                free_chunk_arenas();\n            else {\n                abortObject(object, 400, internAtomF(\"Unknown action %s\",\n                                                     name->string));\n                releaseAtom(name);\n                destroyAtomList(list);\n                goto out;\n            }\n            releaseAtom(name);\n        }\n        destroyAtomList(list);\n        object->date = current_time.tv_sec;\n        object->age = current_time.tv_sec;\n        object->headers = internAtom(\"\\r\\nLocation: /polipo/status?\");\n        object->code = 303;\n        object->message = internAtom(\"Done\");\n        object->flags &= ~OBJECT_INITIAL;\n        object->length = 0;\n    } else {\n        abortObject(object, 405, internAtom(\"Method not allowed\"));\n    }\n\n out:\n    releaseAtom(data);\n    notifyObject(object);\n    requestor->connection->flags &= ~CONN_READER;\n    return 1;\n}\n\n#ifdef HAVE_FORK\nstatic void\nfillSpecialObject(ObjectPtr object, void (*fn)(FILE*, char*), void* closure)\n{\n    int rc;\n    int filedes[2];\n    pid_t pid;\n    sigset_t ss, old_mask;\n\n    if(object->flags & OBJECT_INPROGRESS)\n        return;\n\n    rc = pipe(filedes);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't create pipe\");\n        abortObject(object, 503,\n                    internAtomError(errno, \"Couldn't create pipe\"));\n        return;\n    }\n\n    fflush(stdout);\n    fflush(stderr);\n    flushLog();\n\n    /* Block signals that we handle specially until the child can\n       disable the handlers. */\n    interestingSignals(&ss);\n    /* I'm a little confused.  POSIX doesn't allow EINTR here, but I\n       think that both Linux and SVR4 do. */\n    do {\n        rc = sigprocmask(SIG_BLOCK, &ss, &old_mask);\n    } while (rc < 0 && errno == EINTR);\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Sigprocmask failed\");\n        abortObject(object, 503, internAtomError(errno, \"Sigprocmask failed\"));\n        close(filedes[0]);\n        close(filedes[1]);\n        return;\n    }\n    \n    pid = fork();\n    if(pid < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't fork\");\n        abortObject(object, 503, internAtomError(errno, \"Couldn't fork\"));\n        close(filedes[0]);\n        close(filedes[1]);\n        do {\n            rc = sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        } while (rc < 0 && errno == EINTR);\n        if(rc < 0) {\n            do_log_error(L_ERROR, errno, \"Couldn't restore signal mask\");\n            polipoExit();\n        }\n        return;\n    }\n\n    if(pid > 0) {\n        SpecialRequestPtr request;\n        close(filedes[1]);\n        do {\n            rc = sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        } while (rc < 0 && errno == EINTR);\n        if(rc < 0) {\n            do_log_error(L_ERROR, errno, \"Couldn't restore signal mask\");\n            polipoExit();\n            return;\n        }\n\n        request = malloc(sizeof(SpecialRequestRec));\n        if(request == NULL) {\n            kill(pid, SIGTERM);\n            close(filedes[0]);\n            abortObject(object, 503,\n                        internAtom(\"Couldn't allocate request\\n\"));\n            notifyObject(object);\n            return;\n        } else {\n            request->buf = get_chunk();\n            if(request->buf == NULL) {\n                kill(pid, SIGTERM);\n                close(filedes[0]);\n                free(request);\n                abortObject(object, 503,\n                            internAtom(\"Couldn't allocate request\\n\"));\n                notifyObject(object);\n                return;\n            }\n        }\n        object->flags |= OBJECT_INPROGRESS;\n        retainObject(object);\n        request->object = object;\n        request->fd = filedes[0];\n        request->pid = pid;\n        request->offset = 0;\n        /* Under any sensible scheduler, the child will run before the\n           parent.  So no need for IO_NOTNOW. */\n        do_stream(IO_READ, filedes[0], 0, request->buf, CHUNK_SIZE,\n                  specialRequestHandler, request);\n    } else {\n        /* child */\n        close(filedes[0]);\n        uninitEvents();\n        do {\n            rc = sigprocmask(SIG_SETMASK, &old_mask, NULL);\n        } while (rc < 0 && errno == EINTR);\n        if(rc < 0)\n            exit(1);\n\n        if(filedes[1] != 1)\n            dup2(filedes[1], 1);\n\n        (*fn)(stdout, closure);\n        exit(0);\n    }\n}\n\nint\nspecialRequestHandler(int status, \n                      FdEventHandlerPtr event, StreamRequestPtr srequest)\n{\n    SpecialRequestPtr request = srequest->data;\n    int rc;\n    int killed = 0;\n\n    if(status < 0) {\n        kill(request->pid, SIGTERM);\n        killed = 1;\n        request->object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(request->object, 502,\n                    internAtomError(-status, \"Couldn't read from client\"));\n        goto done;\n    }\n\n    if(srequest->offset > 0) {\n        rc = objectAddData(request->object, request->buf, \n                           request->offset, srequest->offset);\n        if(rc < 0) {\n            kill(request->pid, SIGTERM);\n            killed = 1;\n            request->object->flags &= ~OBJECT_INPROGRESS;\n            abortObject(request->object, 503,\n                        internAtom(\"Couldn't add data to connection\"));\n            goto done;\n        }\n        request->offset += srequest->offset;\n    }\n    if(status) {\n        request->object->flags &= ~OBJECT_INPROGRESS;\n        request->object->length = request->object->size;\n        goto done;\n    }\n\n    /* If we're the only person interested in this object, let's abort\n       it now. */\n    if(request->object->refcount <= 1) {\n        kill(request->pid, SIGTERM);\n        killed = 1;\n        request->object->flags &= ~OBJECT_INPROGRESS;\n        abortObject(request->object, 500, internAtom(\"Aborted\"));\n        goto done;\n    }\n    notifyObject(request->object);\n    do_stream(IO_READ | IO_NOTNOW, request->fd, 0, request->buf, CHUNK_SIZE,\n              specialRequestHandler, request);\n    return 1;\n\n done:\n    close(request->fd);\n    dispose_chunk(request->buf);\n    releaseNotifyObject(request->object);\n    /* That's a blocking wait.  It shouldn't block for long, as we've\n       either already killed the child, or else we got EOF from it. */\n    do {\n        rc = waitpid(request->pid, &status, 0);\n    } while(rc < 0 && errno == EINTR);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Wait for %d: %d\\n\", (int)request->pid, errno);\n    } else {\n        int normal = \n            (WIFEXITED(status) && WEXITSTATUS(status) == 0) ||\n            (killed && WIFSIGNALED(status) && WTERMSIG(status) == SIGTERM);\n        char *reason =\n            WIFEXITED(status) ? \"with status\" : \n            WIFSIGNALED(status) ? \"on signal\" :\n            \"with unknown status\";\n        int value =\n            WIFEXITED(status) ? WEXITSTATUS(status) :\n            WIFSIGNALED(status) ? WTERMSIG(status) :\n            status;\n        do_log(normal ? D_CHILD : L_ERROR, \n               \"Child %d exited %s %d.\\n\",\n               (int)request->pid, reason, value);\n    }\n    free(request);\n    return 1;\n}\n#else\nstatic void\nfillSpecialObject(ObjectPtr object, void (*fn)(FILE*, char*), void* closure)\n{\n    FILE *tmp = NULL;\n    char *buf = NULL;\n    int rc, len, offset;\n\n    if(object->flags & OBJECT_INPROGRESS)\n        return;\n\n    buf = get_chunk();\n    if(buf == NULL) {\n        abortObject(object, 503, internAtom(\"Couldn't allocate chunk\"));\n        goto done;\n    }\n\n    tmp = tmpfile();\n    if(tmp == NULL) {\n        abortObject(object, 503, internAtom(pstrerror(errno)));\n        goto done;\n    }\n\n    (*fn)(tmp, closure);\n    fflush(tmp);\n\n    rewind(tmp);\n    offset = 0;\n    while(1) {\n        len = fread(buf, 1, CHUNK_SIZE, tmp);\n        if(len <= 0 && ferror(tmp)) {\n            abortObject(object, 503, internAtom(pstrerror(errno)));\n            goto done;\n        }\n        if(len <= 0)\n            break;\n\n        rc = objectAddData(object, buf, offset, len);\n        if(rc < 0) {\n            abortObject(object, 503, internAtom(\"Couldn't add data to object\"));\n            goto done;\n        }\n\n        offset += len;\n    }\n\n    object->length = offset;\n\n done:\n    if(buf)\n        dispose_chunk(buf);\n    if(tmp)\n        fclose(tmp);\n    notifyObject(object);\n}\n#endif\n"
        },
        {
          "name": "local.h",
          "type": "blob",
          "size": 2.0947265625,
          "content": "/*\nCopyright (c) 2003, 2004 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ntypedef struct _SpecialRequest {\n    ObjectPtr object;\n    int fd;\n    void *buf;\n    int offset;\n    pid_t pid;\n} SpecialRequestRec, *SpecialRequestPtr;\n\nextern int disableConfiguration;\nextern int disableIndexing;\n\nvoid preinitLocal(void);\nvoid alternatingHttpStyle(FILE *out, char *id);\nint httpLocalRequest(ObjectPtr object, int method, int from, int to,\n                     HTTPRequestPtr, void *);\nint httpSpecialRequest(ObjectPtr object, int method, int from, int to,\n                       HTTPRequestPtr, void*);\nint httpSpecialSideRequest(ObjectPtr object, int method, int from, int to,\n                           HTTPRequestPtr requestor, void *closure);\nint specialRequestHandler(int status, \n                          FdEventHandlerPtr event, StreamRequestPtr request);\nint httpSpecialDoSide(HTTPRequestPtr requestor);\nint httpSpecialClientSideHandler(int status,\n                                 FdEventHandlerPtr event,\n                                 StreamRequestPtr srequest);\nint httpSpecialDoSideFinish(AtomPtr data, HTTPRequestPtr requestor);\n"
        },
        {
          "name": "localindex.html",
          "type": "blob",
          "size": 0.2978515625,
          "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n \"http://www.w3.org/TR/html4/loose.dtd\">\n<html><head>\n<title>Welcome to Polipo</title>\n</head><body>\n<h1>Welcome to Polipo</h1>\n\n<p><a href=\"doc/\">The Polipo manual</a>.\n\n<p><a href=\"polipo/\">The configuration interface</a>.\n\n</body></html>\n\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 11.4521484375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifdef HAVE_SYSLOG\n#include <syslog.h>\n#endif\n\nstatic int logLevel = LOGGING_DEFAULT;\nstatic int logSyslog = 0;\nstatic AtomPtr logFile = NULL;\nstatic FILE *logF;\nstatic int logFilePermissions = 0640;\nint scrubLogs = 0;\n\n#ifdef HAVE_SYSLOG\nstatic AtomPtr logFacility = NULL;\nstatic int facility;\n#endif\n\n#define STR(x) XSTR(x)\n#define XSTR(x) #x\n\nstatic void initSyslog(void);\n\n#ifdef HAVE_SYSLOG\nstatic char *syslogBuf;\nstatic int syslogBufSize;\nstatic int syslogBufLength;\n\nstatic int translateFacility(AtomPtr facility);\nstatic int translatePriority(int type);\nstatic void accumulateSyslogV(int type, const char *f, va_list args);\nstatic void accumulateSyslogN(int type, const char *s, int len);\n#endif\n\nvoid\npreinitLog()\n{\n    CONFIG_VARIABLE_SETTABLE(logLevel, CONFIG_HEX, configIntSetter,\n                             \"Logging level (max = \" STR(LOGGING_MAX) \").\");\n    CONFIG_VARIABLE(logFile, CONFIG_ATOM, \"Log file (stderr if empty and logSyslog is unset, /var/log/polipo if empty and daemonise is true).\");\n    CONFIG_VARIABLE(logFilePermissions, CONFIG_OCTAL,\n                    \"Access rights of the logFile.\");\n    CONFIG_VARIABLE_SETTABLE(scrubLogs, CONFIG_BOOLEAN, configIntSetter,\n                             \"If true, don't include URLs in logs.\");\n\n#ifdef HAVE_SYSLOG\n    CONFIG_VARIABLE(logSyslog, CONFIG_BOOLEAN, \"Log to syslog.\");\n    CONFIG_VARIABLE(logFacility, CONFIG_ATOM, \"Syslog facility to use.\");\n    logFacility = internAtom(\"user\");\n#endif\n\n    logF = stderr;\n}\n\nint\nloggingToStderr(void) {\n    return(logF == stderr);\n}\n\nstatic FILE *\nopenLogFile(void)\n{\n    int fd;\n    FILE *f;\n\n    fd = open(logFile->string, O_WRONLY | O_CREAT | O_APPEND,\n              logFilePermissions);\n    if(fd < 0)\n        return NULL;\n\n    f = fdopen(fd, \"a\");\n    if(f == NULL) {\n        int saved_errno = errno;\n        close(fd);\n        errno = saved_errno;\n        return NULL;\n    }\n\n    setvbuf(f, NULL, _IOLBF, 0);\n    return f;\n}\n\nvoid\ninitLog(void)\n{\n    if(daemonise && logFile == NULL && !logSyslog)\n        logFile = internAtom(\"/var/log/polipo\");\n\n    if(logFile != NULL && logFile->length > 0) {\n        FILE *f;\n        logFile = expandTilde(logFile);\n        f = openLogFile();\n        if(f == NULL) {\n            do_log_error(L_ERROR, errno, \"Couldn't open log file %s\",\n                         logFile->string);\n            exit(1);\n        }\n        logF = f;\n    }\n\n    if(logSyslog) {\n        initSyslog();\n\n        if(logFile == NULL) {\n            logF = NULL;\n        }\n    }\n}\n\n#ifdef HAVE_SYSLOG\nstatic void\ninitSyslog()\n{\n    if(logSyslog) {\n        facility = translateFacility(logFacility);\n        closelog();\n        openlog(\"polipo\", LOG_PID, facility);\n\n        if(!syslogBuf) {\n            syslogBuf = strdup(\"\");\n            syslogBufSize = 1;\n        }\n    }\n}\n\n/* Map a user-provided name to a syslog facility.\n\n   This is rendered quite ugly because POSIX hardly defines any, but we\n   should allow any the local system knows about. */\n\nstatic int\ntranslateFacility(AtomPtr facility)\n{\n    typedef struct\n    {\n        const char *name;\n        int facility;\n    } FacilitiesRec;\n\n    /* List of all known valid syslog facilities.\n\n       This list is terminated by a NULL facility name. */\n\n    FacilitiesRec facilities[] = {\n        /* These are all the facilities found in glibc 2.5. */\n#ifdef LOG_AUTH\n        { \"auth\", LOG_AUTH },\n#endif\n#ifdef LOG_AUTHPRIV\n        { \"authpriv\", LOG_AUTHPRIV },\n#endif\n#ifdef LOG_CRON\n        { \"cron\", LOG_CRON },\n#endif\n#ifdef LOG_DAEMON\n        { \"daemon\", LOG_DAEMON },\n#endif\n#ifdef LOG_FTP\n        { \"ftp\", LOG_FTP },\n#endif\n#ifdef LOG_KERN\n        { \"kern\", LOG_KERN },\n#endif\n#ifdef LOG_LPR\n        { \"lpr\", LOG_LPR },\n#endif\n#ifdef LOG_MAIL\n        { \"mail\", LOG_MAIL },\n#endif\n#ifdef LOG_NEWS\n        { \"news\", LOG_NEWS },\n#endif\n#ifdef LOG_SYSLOG\n        { \"syslog\", LOG_SYSLOG },\n#endif\n#ifdef LOG_uucp\n        { \"uucp\", LOG_UUCP },\n#endif\n        /* These are required by POSIX. */\n        { \"user\", LOG_USER },\n        { \"local0\", LOG_LOCAL0 },\n        { \"local1\", LOG_LOCAL1 },\n        { \"local2\", LOG_LOCAL2 },\n        { \"local3\", LOG_LOCAL3 },\n        { \"local4\", LOG_LOCAL4 },\n        { \"local5\", LOG_LOCAL5 },\n        { \"local6\", LOG_LOCAL6 },\n        { \"local7\", LOG_LOCAL7 },\n        { NULL, 0 }};\n\n    FacilitiesRec *current;\n\n    /* It would be more fitting to return LOG_DAEMON, but POSIX does not\n       guarantee the existence of that facility. */\n\n    if(!facility) {\n        return LOG_USER;\n    }\n\n    current = facilities;\n    while(current->name) {\n        if(!strcmp(current->name, atomString(facility))) {\n            return current->facility;\n        }\n        current++;\n    }\n\n    /* This will go to stderr because syslog is not yet initialized. */\n    do_log(L_ERROR, \"Specified logFacility %s nonexistent on this system.\",\n           atomString(facility));\n\n    return LOG_USER;\n}\n\n/* Translate a Polipo error type into a syslog priority. */\n\nstatic int\ntranslatePriority(int type)\n{\n    typedef struct\n    {\n        int type;\n        int priority;\n    } PrioritiesRec;\n\n    /* The list is terminated with a type of zero. */\n\n    PrioritiesRec priorities[] = {{ L_ERROR, LOG_ERR },\n                                  { L_WARN, LOG_WARNING },\n                                  { L_INFO, LOG_NOTICE },\n                                  { L_FORBIDDEN, LOG_DEBUG },\n                                  { L_UNCACHEABLE, LOG_DEBUG },\n                                  { L_SUPERSEDED, LOG_DEBUG },\n                                  { L_VARY, LOG_DEBUG },\n                                  { L_TUNNEL, LOG_NOTICE },\n                                  { 0, 0 }};\n    PrioritiesRec *current;\n\n    current = priorities;\n    while(current->type) {\n        if(current->type == type) {\n            return current->priority;\n        }\n        current++;\n    }\n\n    return LOG_DEBUG;\n}\n\nstatic int\nexpandSyslog(int len)\n{\n    int newsize;\n    char *newbuf;\n\n    if(len < 0)\n        newsize = syslogBufSize * 2;\n    else\n        newsize = syslogBufLength + len + 1;\n\n    newbuf = realloc(syslogBuf, newsize);\n    if(!newbuf)\n        return -1;\n\n    syslogBuf = newbuf;\n    syslogBufSize = newsize;\n    return 1;\n}\n\nstatic void\nmaybeFlushSyslog(int type)\n{\n    char *linefeed;\n    while(1) {\n        linefeed = memchr(syslogBuf, '\\n', syslogBufLength);\n        if(linefeed == NULL)\n            break;\n        *linefeed = '\\0';\n        syslog(translatePriority(type), \"%s\", syslogBuf);\n        linefeed++;\n        syslogBufLength -= (linefeed - syslogBuf);\n        if(syslogBufLength > 0)\n            memmove(syslogBuf, linefeed, syslogBufLength);\n    }\n}\n\nstatic void\naccumulateSyslogV(int type, const char *f, va_list args)\n{\n    int rc;\n    va_list args_copy;\n\n again:\n    va_copy(args_copy, args);\n    rc = vsnprintf(syslogBuf + syslogBufLength,\n                   syslogBufSize - syslogBufLength,\n                   f, args_copy);\n    va_end(args_copy);\n\n    if(rc < 0 || rc >= syslogBufSize - syslogBufLength) {\n        rc = expandSyslog(rc);\n        if(rc < 0)\n            return;\n        goto again;\n    }\n\n    syslogBufLength += rc;\n\n    maybeFlushSyslog(type);\n}\n\nstatic void\naccumulateSyslogN(int type, const char *s, int len)\n{\n    while(syslogBufSize - syslogBufLength <= len)\n        expandSyslog(len);\n\n    memcpy(syslogBuf + syslogBufLength, s, len);\n    syslogBufLength += len;\n    syslogBuf[syslogBufLength] = '\\0';\n\n    maybeFlushSyslog(type);\n}\n\n#else\nstatic void\ninitSyslog()\n{\n    return;\n}\n#endif\n\n/* Flush any messages waiting to be logged. */\nvoid flushLog()\n{\n    if(logF)\n        fflush(logF);\n\n#ifdef HAVE_SYSLOG\n    /* There shouldn't really be anything here, but let's be paranoid.\n       We can't pick a good value for `type', so just invent one. */\n    if(logSyslog && syslogBuf[0] != '\\0') {\n        accumulateSyslogN(L_INFO, \"\\n\", 1);\n    }\n\n    assert(syslogBufLength == 0);\n#endif\n}\n\nvoid\nreopenLog()\n{\n    if(logFile && logFile->length > 0) {\n        FILE *f;\n        f = openLogFile();\n        if(f == NULL) {\n            do_log_error(L_ERROR, errno, \"Couldn't reopen log file %s\",\n                         logFile->string);\n            exit(1);\n        }\n        fclose(logF);\n        logF = f;\n    }\n\n    if(logSyslog)\n        initSyslog();\n}\n\nvoid\nreally_do_log(int type, const char *f, ...)\n{\n    va_list args;\n\n    va_start(args, f);\n    if(type & LOGGING_MAX & logLevel)\n        really_do_log_v(type, f, args);\n    va_end(args);\n}\n\nvoid\nreally_do_log_v(int type, const char *f, va_list args)\n{\n    va_list args_copy;\n\n    if(type & LOGGING_MAX & logLevel) {\n        if(logF)\n        {\n            va_copy(args_copy, args);\n            vfprintf(logF, f, args_copy);\n            va_end(args_copy);\n        }\n#ifdef HAVE_SYSLOG\n        if(logSyslog) {\n            va_copy(args_copy, args);\n            accumulateSyslogV(type, f, args_copy);\n            va_end(args_copy);\n        }\n#endif\n    }\n}\n\nvoid\nreally_do_log_error(int type, int e, const char *f, ...)\n{\n    va_list args;\n    va_start(args, f);\n    if(type & LOGGING_MAX & logLevel)\n        really_do_log_error_v(type, e, f, args);\n    va_end(args);\n}\n\nvoid\nreally_do_log_error_v(int type, int e, const char *f, va_list args)\n{\n    va_list args_copy;\n\n    if((type & LOGGING_MAX & logLevel) != 0) {\n        char *es = pstrerror(e);\n        if(es == NULL)\n            es = \"Unknown error\";\n\n        if(logF) {\n            va_copy(args_copy, args);\n            vfprintf(logF, f, args_copy);\n            fprintf(logF, \": %s\\n\", es);\n            va_end(args_copy);\n        }\n#ifdef HAVE_SYSLOG\n        if(logSyslog) {\n            char msg[256];\n            int n = 0;\n\n            va_copy(args_copy, args);\n            n = snnvprintf(msg, n, 256, f, args_copy);\n            va_end(args_copy);\n            n = snnprintf(msg, n, 256, \": \");\n            n = snnprint_n(msg, n, 256, es, strlen (es));\n            n = snnprintf(msg, n, 256, \"\\n\");\n            /* Overflow? Vanishingly unlikely; truncate at 255. */\n            if(n < 0 || n > 256) {\n                n = 256;\n                msg[255] = '\\0';\n            }\n            else\n                msg[n] = '\\0';\n\n            accumulateSyslogN(type, msg, n);\n        }\n#endif\n    }\n}\n\nvoid\nreally_do_log_n(int type, const char *s, int n)\n{\n    if((type & LOGGING_MAX & logLevel) != 0) {\n        if(logF) {\n            fwrite(s, n, 1, logF);\n        }\n#ifdef HAVE_SYSLOG\n        if(logSyslog)\n            accumulateSyslogN(type, s, n);\n#endif\n    }\n}\n\nconst char *\nscrub(const char *message)\n{\n    if(scrubLogs)\n        return \"(scrubbed)\";\n    else\n        return message;\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 4.427734375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#define L_ERROR 0x1\n#define L_WARN 0x2\n#define L_INFO 0x4\n#define L_FORBIDDEN 0x8\n#define L_UNCACHEABLE 0x10\n#define L_SUPERSEDED 0x20\n#define L_VARY 0x40\n#define L_TUNNEL 0x80\n\n#define D_SERVER_CONN 0x100\n#define D_SERVER_REQ 0x200\n#define D_CLIENT_CONN 0x400\n#define D_CLIENT_REQ 0x800\n#define D_ATOM_REFCOUNT 0x1000\n#define D_REFCOUNT 0x2000\n#define D_LOCK 0x4000\n#define D_OBJECT 0x8000\n#define D_OBJECT_DATA 0x10000\n#define D_SERVER_OFFSET 0x20000\n#define D_CLIENT_DATA 0x40000\n#define D_DNS 0x80000\n#define D_CHILD 0x100000\n#define D_IO 0x200000\n\n#define LOGGING_DEFAULT (L_ERROR | L_WARN | L_INFO)\n#define LOGGING_MAX 0xFF\n\nextern int scrubLogs;\n\nvoid preinitLog(void);\nvoid initLog(void);\nvoid reopenLog(void);\nvoid flushLog(void);\nint loggingToStderr(void);\n\nvoid really_do_log(int type, const char *f, ...)\n    ATTRIBUTE ((format (printf, 2, 3)));\nvoid really_do_log_v(int type, const char *f, va_list args)\n    ATTRIBUTE ((format (printf, 2, 0)));\nvoid really_do_log_n(int type, const char *s, int n);\nvoid really_do_log_error(int type, int e, const char *f, ...)\n    ATTRIBUTE ((format (printf, 3, 4)));\nvoid really_do_log_error_v(int type, int e, const char *f, va_list args)\n    ATTRIBUTE ((format (printf, 3, 0)));\nconst char *scrub(const char *message);\n\n#ifdef __GNUC__\n#define DO_BACKTRACE()                  \\\n  do {                                  \\\n    int n;                              \\\n    void *buffer[10];                   \\\n    n = backtrace(buffer, 5);           \\\n    fflush(stderr);                     \\\n    backtrace_symbols_fd(buffer, n, 2); \\\n } while(0)\n#else\n#define DO_BACKTRACE() /* */\n#endif\n\n/* These are macros because it's important that they should be\n   optimised away. */\n\n#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n\n#define do_log(_type, ...)                                           \\\n    do {                                                             \\\n        if((_type) & (LOGGING_MAX)) really_do_log((_type), __VA_ARGS__); \\\n    } while(0)\n#define do_log_error(_type, _e, ...)                                 \\\n    do {                                                             \\\n        if((_type) & (LOGGING_MAX))                                  \\\n            really_do_log_error((_type), (_e), __VA_ARGS__);         \\\n    } while(0)\n\n#elif defined(__GNUC__)\n\n#define do_log(_type, _args...)                                \\\n    do {                                                       \\\n        if((_type) & (LOGGING_MAX)) really_do_log((_type), _args); \\\n    } while(0)\n#define do_log_error(_type, _e, _args...)                      \\\n    do {                                                       \\\n        if((_type) & (LOGGING_MAX))                            \\\n            really_do_log_error((_type), (_e), _args);         \\\n    } while(0)\n\n#else\n\n/* No variadic macros -- let's hope inline works. */\n\nstatic inline void \ndo_log(int type, const char *f, ...)\n{\n    va_list args;\n\n    va_start(args, f);\n    if((type & (LOGGING_MAX)) != 0)\n        really_do_log_v(type, f, args);\n    va_end(args);\n}\n\nstatic inline void\ndo_log_error(int type, int e, const char *f, ...)\n{\n    va_list args;\n\n    va_start(args, f);\n    if((type & (LOGGING_MAX)) != 0)\n        really_do_log_error_v(type, e, f, args);\n    va_end(args);\n}    \n\n#endif\n\n#define do_log_n(_type, _s, _n) \\\n    do { \\\n        if((_type) & (LOGGING_MAX)) really_do_log_n((_type), (_s), (_n)); \\\n    } while(0)\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 4.4755859375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nAtomPtr configFile = NULL;\nAtomPtr pidFile = NULL;\nint daemonise = 0;\n\nstatic void\nusage(char *argv0)\n{\n    fprintf(stderr, \n            \"%s [ -h ] [ -v ] [ -x ] [ -c filename ] [ -- ] [ var=val... ]\\n\",\n            argv0);\n    fprintf(stderr, \"  -h: display this message.\\n\");\n    fprintf(stderr, \"  -v: display the list of configuration variables.\\n\");\n    fprintf(stderr, \"  -x: perform expiry on the disk cache.\\n\");\n    fprintf(stderr, \"  -c: specify the configuration file to use.\\n\");\n}\n\nint\nmain(int argc, char **argv)\n{\n    FdEventHandlerPtr listener;\n    int i;\n    int rc;\n    int expire = 0, printConfig = 0;\n\n    initAtoms();\n    CONFIG_VARIABLE(daemonise, CONFIG_BOOLEAN, \"Run as a daemon\");\n    CONFIG_VARIABLE(pidFile, CONFIG_ATOM, \"File with pid of running daemon.\");\n\n    preinitChunks();\n    preinitLog();\n    preinitObject();\n    preinitIo();\n    preinitDns();\n    preinitServer();\n    preinitHttp();\n    preinitDiskcache();\n    preinitLocal();\n    preinitForbidden();\n    preinitSocks();\n\n    i = 1;\n    while(i < argc) {\n        if(argv[i][0] != '-')\n            break;\n        if(strcmp(argv[i], \"--\") == 0) {\n            i++;\n            break;\n        } else if(strcmp(argv[i], \"-h\") == 0) {\n            usage(argv[0]);\n            exit(0);\n        } else if(strcmp(argv[i], \"-v\") == 0) {\n            printConfig = 1;\n            i++;\n        } else if(strcmp(argv[i], \"-x\") == 0) {\n            expire = 1;\n            i++;\n        } else if(strcmp(argv[i], \"-c\") == 0) {\n            i++;\n            if(i >= argc) {\n                usage(argv[0]);\n                exit(1);\n            }\n            if(configFile)\n                releaseAtom(configFile);\n            configFile = internAtom(argv[i]);\n            i++;\n        } else {\n            usage(argv[0]);\n            exit(1);\n        }\n    }\n\n    if(configFile)\n        configFile = expandTilde(configFile);\n\n    if(configFile == NULL) {\n        configFile = expandTilde(internAtom(\"~/.polipo\"));\n        if(configFile)\n            if(access(configFile->string, F_OK) < 0) {\n                releaseAtom(configFile);\n                configFile = NULL;\n            }\n    }\n\n    if(configFile == NULL) {\n        if(access(\"/etc/polipo/config\", F_OK) >= 0)\n            configFile = internAtom(\"/etc/polipo/config\");\n        if(configFile && access(configFile->string, F_OK) < 0) {\n            releaseAtom(configFile);\n            configFile = NULL;\n        }\n    }\n\n    rc = parseConfigFile(configFile);\n    if(rc < 0)\n        exit(1);\n\n    while(i < argc) {\n        rc = parseConfigLine(argv[i], \"command line\", 0, 0);\n        if(rc < 0)\n            exit(1);\n        i++;\n    }\n\n    initChunks();\n    initLog();\n    initObject();\n    if(!expire && !printConfig)\n        initEvents();\n    initIo();\n    initDns();\n    initHttp();\n    initServer();\n    initDiskcache();\n    initForbidden();\n    initSocks();\n\n    if(printConfig) {\n        printConfigVariables(stdout, 0);\n        exit(0);\n    }\n\n    if(expire) {\n        expireDiskObjects();\n        exit(0);\n    }\n\n    if(daemonise)\n        do_daemonise(loggingToStderr());\n\n    if(pidFile) {\n        pidFile = expandTilde(pidFile);\n        writePid(pidFile->string);\n    }\n\n    listener = create_listener(proxyAddress->string, \n                               proxyPort, httpAccept, NULL);\n    if(!listener) {\n        if(pidFile) unlink(pidFile->string);\n        exit(1);\n    }\n\n    eventLoop();\n\n    if(pidFile) unlink(pidFile->string);\n    return 0;\n}\n"
        },
        {
          "name": "md5.c",
          "type": "blob",
          "size": 11.6865234375,
          "content": "/*\n ***********************************************************************\n ** md5.c -- the source code for MD5 routines                         **\n ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **\n ** Created: 2/17/90 RLR                                              **\n ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **\n ** Revised (for MD5): RLR 4/27/91                                    **\n **   -- G modified to have y&~z instead of y&z                       **\n **   -- FF, GG, HH modified to add in last register done             **\n **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **\n **   -- distinct additive constant for each step                     **\n **   -- round 4 added, working mod 7                                 **\n ***********************************************************************\n */\n\n/*\n ***********************************************************************\n ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **\n **                                                                   **\n ** License to copy and use this software is granted provided that    **\n ** it is identified as the \"RSA Data Security, Inc. MD5 Message-     **\n ** Digest Algorithm\" in all material mentioning or referencing this  **\n ** software or this function.                                        **\n **                                                                   **\n ** License is also granted to make and use derivative works          **\n ** provided that such works are identified as \"derived from the RSA  **\n ** Data Security, Inc. MD5 Message-Digest Algorithm\" in all          **\n ** material mentioning or referencing the derived work.              **\n **                                                                   **\n ** RSA Data Security, Inc. makes no representations concerning       **\n ** either the merchantability of this software or the suitability    **\n ** of this software for any particular purpose.  It is provided \"as  **\n ** is\" without express or implied warranty of any kind.              **\n **                                                                   **\n ** These notices must be retained in any copies of any part of this  **\n ** documentation and/or software.                                    **\n ***********************************************************************\n */\n\n#include \"md5.h\"\n\n/*\n ***********************************************************************\n **  Message-digest routines:                                         **\n **  To form the message digest for a message M                       **\n **    (1) Initialize a context buffer mdContext using MD5Init        **\n **    (2) Call MD5Update on mdContext and M                          **\n **    (3) Call MD5Final on mdContext                                 **\n **  The message digest is now in mdContext->digest[0...15]           **\n ***********************************************************************\n */\n\n/* forward declaration */\nstatic void Transform (UINT4 *, UINT4 *);\n\n#ifdef\t__STDC__\nstatic const\n#else\nstatic\n#endif\nunsigned char PADDING[64] = {\n  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n/* F, G, H and I are basic MD5 functions */\n#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))\n#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define I(x, y, z) ((y) ^ ((x) | (~z)))\n\n/* ROTATE_LEFT rotates x left n bits */\n#if\tdefined(FAST_MD5) && defined(__GNUC__) && defined(mc68000)\n/*\n * If we're on a 68000 based CPU and using a GNU C compiler with\n * inline assembly code, we can speed this up a bit.\n */\ninline UINT4 ROTATE_LEFT(UINT4 x, int n)\n{   \n    asm(\"roll %2,%0\" : \"=d\" (x) : \"0\" (x), \"Ir\" (n));\n    return x;\n}\n#else\n#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))\n#endif\n\n\n/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */\n/* Rotation is separate from addition to prevent recomputation */\n#define FF(a, b, c, d, x, s, ac) \\\n  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \\\n   (a) = ROTATE_LEFT ((a), (s)); \\\n   (a) += (b); \\\n  }\n#define GG(a, b, c, d, x, s, ac) \\\n  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \\\n   (a) = ROTATE_LEFT ((a), (s)); \\\n   (a) += (b); \\\n  }\n#define HH(a, b, c, d, x, s, ac) \\\n  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \\\n   (a) = ROTATE_LEFT ((a), (s)); \\\n   (a) += (b); \\\n  }\n#define II(a, b, c, d, x, s, ac) \\\n  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \\\n   (a) = ROTATE_LEFT ((a), (s)); \\\n   (a) += (b); \\\n  }\n\n/* The routine MD5Init initializes the message-digest context\n   mdContext. All fields are set to zero.\n */\nvoid MD5Init (mdContext)\nMD5_CTX *mdContext;\n{\n  mdContext->i[0] = mdContext->i[1] = (UINT4)0;\n\n  /* Load magic initialization constants.\n   */\n  mdContext->buf[0] = (UINT4)0x67452301;\n  mdContext->buf[1] = (UINT4)0xefcdab89;\n  mdContext->buf[2] = (UINT4)0x98badcfe;\n  mdContext->buf[3] = (UINT4)0x10325476;\n}\n\n/* The routine MD5Update updates the message-digest context to\n   account for the presence of each of the characters inBuf[0..inLen-1]\n   in the message whose digest is being computed.\n */\nvoid MD5Update (mdContext, inBuf, inLen)\nMD5_CTX *mdContext;\nunsigned const char *inBuf;\nunsigned int inLen;\n{\n  UINT4 in[16];\n  int mdi;\n  unsigned int i, ii;\n\n  /* compute number of bytes mod 64 */\n  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);\n\n  /* update number of bits */\n  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])\n    mdContext->i[1]++;\n  mdContext->i[0] += ((UINT4)inLen << 3);\n  mdContext->i[1] += ((UINT4)inLen >> 29);\n\n  while (inLen--) {\n    /* add new character to buffer, increment mdi */\n    mdContext->in[mdi++] = *inBuf++;\n\n    /* transform if necessary */\n    if (mdi == 0x40) {\n      for (i = 0, ii = 0; i < 16; i++, ii += 4)\n        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |\n                (((UINT4)mdContext->in[ii+2]) << 16) |\n                (((UINT4)mdContext->in[ii+1]) << 8) |\n                ((UINT4)mdContext->in[ii]);\n      Transform (mdContext->buf, in);\n      mdi = 0;\n    }\n  }\n}\n\n/* The routine MD5Final terminates the message-digest computation and\n   ends with the desired message digest in mdContext->digest[0...15].\n */\n\nvoid MD5Final (mdContext)\nMD5_CTX *mdContext;\n{\n  UINT4 in[16];\n  int mdi;\n  unsigned int i, ii;\n  unsigned int padLen;\n\n  /* save number of bits */\n  in[14] = mdContext->i[0];\n  in[15] = mdContext->i[1];\n\n  /* compute number of bytes mod 64 */\n  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);\n\n  /* pad out to 56 mod 64 */\n  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);\n  MD5Update (mdContext, PADDING, padLen);\n\n  /* append length in bits and transform */\n  for (i = 0, ii = 0; i < 14; i++, ii += 4)\n    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |\n            (((UINT4)mdContext->in[ii+2]) << 16) |\n            (((UINT4)mdContext->in[ii+1]) << 8) |\n            ((UINT4)mdContext->in[ii]);\n  Transform (mdContext->buf, in);\n\n  /* store buffer in digest */\n  for (i = 0, ii = 0; i < 4; i++, ii += 4) {\n    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);\n    mdContext->digest[ii+1] =\n      (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);\n    mdContext->digest[ii+2] =\n      (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);\n    mdContext->digest[ii+3] =\n      (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);\n  }\n}\n\n/* Basic MD5 step. Transforms buf based on in.\n */\nstatic void Transform (buf, in)\nUINT4 *buf;\nUINT4 *in;\n{\n  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];\n\n  /* Round 1 */\n#define S11 7\n#define S12 12\n#define S13 17\n#define S14 22\n\n  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */\n  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */\n  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */\n  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */\n  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */\n  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */\n  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */\n  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */\n  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */\n  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */\n  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */\n  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */\n  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */\n  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */\n  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */\n  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */\n\n  /* Round 2 */\n#define S21 5\n#define S22 9\n#define S23 14\n#define S24 20\n  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */\n  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */\n  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */\n  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */\n  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */\n  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */\n  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */\n  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */\n  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */\n  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */\n  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */\n  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */\n  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */\n  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */\n  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */\n  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */\n\n  /* Round 3 */\n#define S31 4\n#define S32 11\n#define S33 16\n#define S34 23\n  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */\n  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */\n  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */\n  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */\n  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */\n  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */\n  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */\n  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */\n  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */\n  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */\n  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */\n  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */\n  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */\n  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */\n  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */\n  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */\n\n  /* Round 4 */\n#define S41 6\n#define S42 10\n#define S43 15\n#define S44 21\n  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */\n  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */\n  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */\n  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */\n  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */\n  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */\n  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */\n  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */\n  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */\n  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */\n  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */\n  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */\n  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */\n  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */\n  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */\n  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\n/*\n ***********************************************************************\n ** End of md5.c                                                      **\n ******************************** (cut) ********************************\n */\n"
        },
        {
          "name": "md5.h",
          "type": "blob",
          "size": 2.873046875,
          "content": "/*\n ***********************************************************************\n ** md5.h -- header file for implementation of MD5                    **\n ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **\n ** Created: 2/17/90 RLR                                              **\n ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **\n ** Revised (for MD5): RLR 4/27/91                                    **\n ***********************************************************************\n */\n\n/*\n ***********************************************************************\n ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **\n **                                                                   **\n ** License to copy and use this software is granted provided that    **\n ** it is identified as the \"RSA Data Security, Inc. MD5 Message-     **\n ** Digest Algorithm\" in all material mentioning or referencing this  **\n ** software or this function.                                        **\n **                                                                   **\n ** License is also granted to make and use derivative works          **\n ** provided that such works are identified as \"derived from the RSA  **\n ** Data Security, Inc. MD5 Message-Digest Algorithm\" in all          **\n ** material mentioning or referencing the derived work.              **\n **                                                                   **\n ** RSA Data Security, Inc. makes no representations concerning       **\n ** either the merchantability of this software or the suitability    **\n ** of this software for any particular purpose.  It is provided \"as  **\n ** is\" without express or implied warranty of any kind.              **\n **                                                                   **\n ** These notices must be retained in any copies of any part of this  **\n ** documentation and/or software.                                    **\n ***********************************************************************\n */\n\n#ifdef HAS_STDINT_H\n#include <stdint.h>\n#elif defined(HAS_INTTYPES_H)\n#include <inttypes.h>\n#endif\n\n/* typedef a 32-bit type */\ntypedef uint32_t UINT4;\n\n/* Data structure for MD5 (Message-Digest) computation */\ntypedef struct {\n  UINT4 i[2];                   /* number of _bits_ handled mod 2^64 */\n  UINT4 buf[4];                                    /* scratch buffer */\n  unsigned char in[64];                              /* input buffer */\n  unsigned char digest[16];     /* actual digest after MD5Final call */\n} MD5_CTX;\n\nvoid MD5Init (MD5_CTX *mdContext);\nvoid MD5Update (MD5_CTX *, unsigned const char *, unsigned int);\nvoid MD5Final (MD5_CTX *);\n\n/*\n ***********************************************************************\n ** End of md5.h                                                      **\n ******************************** (cut) ********************************\n */\n"
        },
        {
          "name": "md5import.c",
          "type": "blob",
          "size": 0.2685546875,
          "content": "#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <stdlib.h>\n\n#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#define HAS_STDINT_H\n#else\ntypedef unsigned int my_uint32_t;\n#undef uint32_t\n#define uint32_t my_uint32_t\n#endif\n#include \"md5.c\"\n#undef uint32_t\n"
        },
        {
          "name": "md5import.h",
          "type": "blob",
          "size": 0.201171875,
          "content": "#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#define HAS_STDINT_H\n#else\ntypedef unsigned int my_uint32_t;\n#undef uint32_t\n#define uint32_t my_uint32_t\n#endif\n#include \"md5.h\"\n#undef uint32_t\n"
        },
        {
          "name": "mingw.c",
          "type": "blob",
          "size": 12.9853515625,
          "content": "/*\nCopyright (c) 2006 by Dan Kennedy.\nCopyright (c) 2006 by Juliusz Chroboczek.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifndef WIN32 /*MINGW*/\n\nstatic int dummy ATTRIBUTE((unused));\n\n#else\n\n#undef poll\n#undef socket\n#undef connect\n#undef accept\n#undef shutdown\n#undef getpeername\n#undef sleep\n#undef inet_aton\n#undef gettimeofday\n#undef stat\n\n/* Windows needs this header file for the implementation of inet_aton() */\n#include <ctype.h>\n\n/* _snprintf and friends have broken NULL termination semantics */\nint win32_snprintf(char* dest, size_t count, const char* format, ...)\n{\n    int r;\n    va_list args;\n    va_start(args, format);\n    r = _vsnprintf(dest, count, format, args);\n    va_end(args);\n    if (count > 0) {\n        dest[count-1] = '\\0';\n    }\n    return r;\n}\n\n/* \n * Check whether \"cp\" is a valid ascii representation of an Internet address\n * and convert to a binary address.  Returns 1 if the address is valid, 0 if\n * not.  This replaces inet_addr, the return value from which cannot\n * distinguish between failure and a local broadcast address.\n *\n * This implementation of the standard inet_aton() function was copied \n * (with trivial modifications) from the OpenBSD project.\n */\nint\nwin32_inet_aton(const char *cp, struct in_addr *addr)\n{\n    register unsigned int val;\n    register int base, n;\n    register char c;\n    unsigned int parts[4];\n    register unsigned int *pp = parts;\n\n    assert(sizeof(val) == 4);\n\n    c = *cp;\n    while(1) {\n        /*\n         * Collect number up to ``.''.\n         * Values are specified as for C:\n         * 0x=hex, 0=octal, isdigit=decimal.\n         */\n        if(!isdigit(c))\n            return (0);\n        val = 0; base = 10;\n        if(c == '0') {\n            c = *++cp;\n            if(c == 'x' || c == 'X')\n                base = 16, c = *++cp;\n            else\n                base = 8;\n        }\n        while(1) {\n            if(isascii(c) && isdigit(c)) {\n                val = (val * base) + (c - '0');\n                c = *++cp;\n            } else if(base == 16 && isascii(c) && isxdigit(c)) {\n                val = (val << 4) |\n                    (c + 10 - (islower(c) ? 'a' : 'A'));\n                c = *++cp;\n            } else\n                break;\n        }\n        if(c == '.') {\n            /*\n             * Internet format:\n             *    a.b.c.d\n             *    a.b.c    (with c treated as 16 bits)\n             *    a.b    (with b treated as 24 bits)\n             */\n            if(pp >= parts + 3)\n                return (0);\n            *pp++ = val;\n            c = *++cp;\n        } else\n            break;\n    }\n    /*\n     * Check for trailing characters.\n     */\n    if(c != '\\0' && (!isascii(c) || !isspace(c)))\n        return (0);\n    /*\n     * Concoct the address according to\n     * the number of parts specified.\n     */\n    n = pp - parts + 1;\n    switch(n) {\n\n    case 0:\n        return (0);        /* initial nondigit */\n\n    case 1:                /* a -- 32 bits */\n        break;\n\n    case 2:                /* a.b -- 8.24 bits */\n        if((val > 0xffffff) || (parts[0] > 0xff))\n            return (0);\n        val |= parts[0] << 24;\n        break;\n\n    case 3:                /* a.b.c -- 8.8.16 bits */\n        if((val > 0xffff) || (parts[0] > 0xff) || (parts[1] > 0xff))\n            return (0);\n        val |= (parts[0] << 24) | (parts[1] << 16);\n        break;\n\n    case 4:                /* a.b.c.d -- 8.8.8.8 bits */\n        if((val > 0xff) || (parts[0] > 0xff) ||\n           (parts[1] > 0xff) || (parts[2] > 0xff))\n            return (0);\n        val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);\n        break;\n    }\n    if(addr)\n        addr->s_addr = htonl(val);\n    return (1);\n}\n\nunsigned int\nwin32_sleep(unsigned int seconds)\n{\n    Sleep(seconds * 1000);\n    return 0;\n}\n\nint\nwin32_gettimeofday(struct timeval *tv, char *tz)\n{\n    const long long EPOCHFILETIME = (116444736000000000LL);\n    FILETIME        ft;\n    LARGE_INTEGER   li;\n    long long        t;\n\n    /* This implementation doesn't support the timezone parameter. That's Ok,\n     * as at present polipo always passed NULL as the second arg. We\n     * also need to make sure that we have at least 8 bytes of space to\n     * do the math in - otherwise there will be overflow errors.\n     */\n    assert(tz == NULL);\n    assert(sizeof(t) == 8);\n\n    if(tv) {\n        GetSystemTimeAsFileTime(&ft);\n        li.LowPart  = ft.dwLowDateTime;\n        li.HighPart = ft.dwHighDateTime;\n        t  = li.QuadPart;       /* In 100-nanosecond intervals */\n        t -= EPOCHFILETIME;     /* Offset to the Epoch time */\n        t /= 10;                /* In microseconds */\n        tv->tv_sec  = (long)(t / 1000000);\n        tv->tv_usec = (long)(t % 1000000);\n    }\n    return 0;\n}\n\nint win32_poll(struct pollfd *fds, unsigned int nfds, int timo)\n{\n    struct timeval timeout, *toptr;\n    fd_set ifds, ofds, efds, *ip, *op;\n    int i, rc;\n\n    /* Set up the file-descriptor sets in ifds, ofds and efds. */\n    FD_ZERO(&ifds);\n    FD_ZERO(&ofds);\n    FD_ZERO(&efds);\n    for (i = 0, op = ip = 0; i < nfds; ++i) {\n\tfds[i].revents = 0;\n\tif(fds[i].events & (POLLIN|POLLPRI)) {\n\t\tip = &ifds;\n\t\tFD_SET(fds[i].fd, ip);\n\t}\n\tif(fds[i].events & POLLOUT) {\n\t\top = &ofds;\n\t\tFD_SET(fds[i].fd, op);\n\t}\n\tFD_SET(fds[i].fd, &efds);\n    } \n\n    /* Set up the timeval structure for the timeout parameter */\n    if(timo < 0) {\n\ttoptr = 0;\n    } else {\n\ttoptr = &timeout;\n\ttimeout.tv_sec = timo / 1000;\n\ttimeout.tv_usec = (timo - timeout.tv_sec * 1000) * 1000;\n    }\n\n#ifdef DEBUG_POLL\n    printf(\"Entering select() sec=%ld usec=%ld ip=%lx op=%lx\\n\",\n           (long)timeout.tv_sec, (long)timeout.tv_usec, (long)ip, (long)op);\n#endif\n    rc = select(0, ip, op, &efds, toptr);\n#ifdef DEBUG_POLL\n    printf(\"Exiting select rc=%d\\n\", rc);\n#endif\n\n    if(rc <= 0)\n\treturn rc;\n\n    if(rc > 0) {\n        for (i = 0; i < nfds; ++i) {\n            int fd = fds[i].fd;\n    \tif(fds[i].events & (POLLIN|POLLPRI) && FD_ISSET(fd, &ifds))\n    \t\tfds[i].revents |= POLLIN;\n    \tif(fds[i].events & POLLOUT && FD_ISSET(fd, &ofds))\n    \t\tfds[i].revents |= POLLOUT;\n    \tif(FD_ISSET(fd, &efds))\n    \t\t/* Some error was detected ... should be some way to know. */\n    \t\tfds[i].revents |= POLLHUP;\n#ifdef DEBUG_POLL\n        printf(\"%d %d %d revent = %x\\n\", \n                FD_ISSET(fd, &ifds), FD_ISSET(fd, &ofds), FD_ISSET(fd, &efds), \n                fds[i].revents\n        );\n#endif\n        }\n    }\n    return rc;\n}\n\nint win32_close_socket(SOCKET fd) {\n    int rc;\n\n    rc = closesocket(fd);\n    return 0;\n}\n\nstatic void\nset_errno(int winsock_err)\n{\n    switch(winsock_err) {\n        case WSAEWOULDBLOCK:\n            errno = EAGAIN;\n            break;\n        default:\n            errno = winsock_err;\n            break;\n    }\n}\n\nint win32_write_socket(SOCKET fd, void *buf, int n)\n{\n    int rc = send(fd, buf, n, 0);\n    if(rc == SOCKET_ERROR) {\n        set_errno(WSAGetLastError());\n    }\n    return rc;\n}\n\nint win32_read_socket(SOCKET fd, void *buf, int n)\n{\n    int rc = recv(fd, buf, n, 0);\n    if(rc == SOCKET_ERROR) {\n        set_errno(WSAGetLastError());\n    }\n    return rc;\n}\n\n\n/*\n * Set the \"non-blocking\" flag on socket fd to the value specified by\n * the second argument (i.e. if the nonblocking argument is non-zero, the\n * socket is set to non-blocking mode). Zero is returned if the operation\n * is successful, other -1.\n */\nint\nwin32_setnonblocking(SOCKET fd, int nonblocking)\n{\n    int rc;\n\n    unsigned long mode = 1;\n    rc = ioctlsocket(fd, FIONBIO, &mode);\n    if(rc != 0) {\n        set_errno(WSAGetLastError());\n    }\n    return (rc == 0 ? 0 : -1);\n}\n\n/*\n * A wrapper around the socket() function. The purpose of this wrapper\n * is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\nSOCKET\nwin32_socket(int domain, int type, int protocol)\n{\n    SOCKET fd = socket(domain, type, protocol);\n    if(fd == INVALID_SOCKET) {\n        set_errno(WSAGetLastError());\n    }\n    return fd;\n}\n\nstatic void\nset_connect_errno(int winsock_err)\n{\n    switch(winsock_err) {\n        case WSAEINVAL:\n        case WSAEALREADY:\n        case WSAEWOULDBLOCK:\n            errno = EINPROGRESS;\n            break;\n        default:\n            errno = winsock_err;\n            break;\n    }\n}\n\n/*\n * A wrapper around the connect() function. The purpose of this wrapper\n * is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\nint\nwin32_connect(SOCKET fd, struct sockaddr *addr, socklen_t addr_len)\n{\n    int rc = connect(fd, addr, addr_len);\n    assert(rc == 0 || rc == SOCKET_ERROR);\n    if(rc == SOCKET_ERROR) {\n        set_connect_errno(WSAGetLastError());\n    }\n    return rc;\n}\n\n/*\n * A wrapper around the accept() function. The purpose of this wrapper\n * is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\nSOCKET\nwin32_accept(SOCKET fd, struct sockaddr *addr, socklen_t *addr_len)\n{\n    SOCKET newfd = accept(fd, addr, addr_len);\n    if(newfd == INVALID_SOCKET) {\n        set_errno(WSAGetLastError());\n        newfd = -1;\n    }\n    return newfd;\n}\n\n/*\n * A wrapper around the shutdown() function. The purpose of this wrapper\n * is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\nint\nwin32_shutdown(SOCKET fd, int mode)\n{\n    int rc = shutdown(fd, mode);\n    assert(rc == 0 || rc == SOCKET_ERROR);\n    if(rc == SOCKET_ERROR) {\n        set_errno(WSAGetLastError());\n    }\n    return rc;\n}\n\n/*\n * A wrapper around the getpeername() function. The purpose of this wrapper\n * is to ensure that the global errno symbol is set if an error occurs,\n * even if we are using winsock.\n */\nint\nwin32_getpeername(SOCKET fd, struct sockaddr *name, socklen_t *namelen)\n{\n    int rc = getpeername(fd, name, namelen);\n    assert(rc == 0 || rc == SOCKET_ERROR);\n    if(rc == SOCKET_ERROR) {\n        set_errno(WSAGetLastError());\n    }\n    return rc;\n}\n\n/* Stat doesn't work on directories if the name ends in a slash. */\n\nint\nwin32_stat(const char *filename, struct stat *ss)\n{\n    int len, rc, saved_errno;\n    char *noslash;\n\n    len = strlen(filename);\n    if(len <= 1 || filename[len - 1] != '/')\n        return stat(filename, ss);\n\n    noslash = malloc(len);\n    if(noslash == NULL)\n        return -1;\n\n    memcpy(noslash, filename, len - 1);\n    noslash[len - 1] = '\\0';\n\n    rc = stat(noslash, ss);\n    saved_errno = errno;\n    free(noslash);\n    errno = saved_errno;\n    return rc;\n}\n#endif /* #ifdef WIN32 MINGW */\n\n#ifndef HAVE_READV_WRITEV\n\nint\npolipo_writev(int fd, const struct iovec *vector, int count)\n{\n    int rc;                     /* Return Code */\n    if(count == 1) {\n        rc = WRITE(fd, vector->iov_base, vector->iov_len);\n    } else {\n        int n = 0;              /* Total bytes to write */\n        char *buf = 0;          /* Buffer to copy to before writing */\n        int i;                  /* Counter var for looping over vector[] */\n        int offset = 0;        /* Offset for copying to buf */\n\n        /* Figure out the required buffer size */\n        for(i = 0; i < count; i++) {\n            n += vector[i].iov_len;\n        }\n\n        /* Allocate the buffer. If the allocation fails, bail out */\n        buf = malloc(n);\n        if(!buf) {\n            errno = ENOMEM;\n            return -1;\n        }\n\n        /* Copy the contents of the vector array to the buffer */\n        for(i = 0; i < count; i++) {\n            memcpy(&buf[offset], vector[i].iov_base, vector[i].iov_len);\n            offset += vector[i].iov_len;\n        }\n        assert(offset == n);\n\n        /* Write the entire buffer to the socket and free the allocation */\n        rc = WRITE(fd, buf, n);\n        free(buf);\n    }\n    return rc;\n}\n\nint\npolipo_readv(int fd, const struct iovec *vector, int count)\n{\n    int ret = 0;                     /* Return value */\n    int i;\n    for(i = 0; i < count; i++) {\n        int n = vector[i].iov_len;\n        int rc = READ(fd, vector[i].iov_base, n);\n        if(rc == n) {\n            ret += rc;\n        } else {\n            if(rc < 0) {\n                ret = (ret == 0 ? rc : ret);\n            } else {\n                ret += rc;\n            }\n            break;\n        }\n    }\n    return ret;\n}\n#endif\n"
        },
        {
          "name": "mingw.h",
          "type": "blob",
          "size": 6.390625,
          "content": "/*\nCopyright (c) 2006 by Dan Kennedy.\nCopyright (c) 2006 by Juliusz Chroboczek.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* \n * Polipo was originally designed to run on Unix-like systems. This\n * header file (and it's accompanying implementation file mingw.c) contain\n * code that allows polipo to run on Microsoft Windows too. \n *\n * The target MS windows compiler is Mingw (MINimal Gnu for Windows). The\n * code in this file probably get's us pretty close to MSVC also, but\n * this has not been tested. To build polipo for Mingw, define the MINGW\n * symbol. For Unix or Unix-like systems, leave it undefined.\n */\n\n#ifdef WIN32 /*MINGW*/\n\n/* Unfortunately, there's no hiding it. */\n#define HAVE_WINSOCK 1\n\n#ifndef WINVER\n#define WINVER 0x0501\n#endif\n\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x0501\n#endif\n\n#ifndef _WIN32_WINDOWS\n#define _WIN32_WINDOWS 0x0410\n#endif\n\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x0700\n#endif\n\n/* At time of writing, a fair bit of stuff doesn't work under Mingw.\n * Hopefully they will be fixed later (especially the disk-cache).\n */\n#define NO_IPv6 1\n\n#define S_IROTH S_IREAD\n\n/* Pull in winsock2.h for (almost) berkeley sockets. */\n#include <winsock2.h>\n\n// here we smash the errno defines so we can smash the socket functions later to smash errno. yay!\n#ifdef ENOTCONN\n  #undef ENOTCONN\n#endif\n#ifdef EWOULDBLOCK\n  #undef EWOULDBLOCK\n#endif\n#ifdef ENOBUFS\n  #undef ENOBUFS\n#endif\n#ifdef ECONNRESET\n  #undef ECONNRESET\n#endif\n#ifdef EAFNOSUPPORT\n  #undef EAFNOSUPPORT\n#endif\n#ifdef EPROTONOSUPPORT\n  #undef EPROTONOSUPPORT\n#endif\n#ifdef EINPROGRESS\n  #undef EINPROGRESS\n#endif\n#ifdef EISCONN\n  #undef EISCONN\n#endif\n#define ENOTCONN        WSAENOTCONN\n#define EWOULDBLOCK     WSAEWOULDBLOCK\n#define ENOBUFS         WSAENOBUFS\n#define ECONNRESET      WSAECONNRESET\n#define ESHUTDOWN       WSAESHUTDOWN\n#define EAFNOSUPPORT    WSAEAFNOSUPPORT\n#define EPROTONOSUPPORT WSAEPROTONOSUPPORT\n#define EINPROGRESS     WSAEINPROGRESS\n#define EISCONN         WSAEISCONN\n\n\n#include <direct.h>\n#include <io.h>\n#include <process.h>\n\n/* winsock doesn't feature poll(), so there is a version implemented\n * in terms of select() in mingw.c. The following definitions\n * are copied from linux man pages. A poll() macro is defined to\n * call the version in mingw.c.\n */\n#define POLLIN      0x0001    /* There is data to read */\n#define POLLPRI     0x0002    /* There is urgent data to read */\n#define POLLOUT     0x0004    /* Writing now will not block */\n#define POLLERR     0x0008    /* Error condition */\n#define POLLHUP     0x0010    /* Hung up */\n#define POLLNVAL    0x0020    /* Invalid request: fd not open */\nstruct pollfd {\n    SOCKET fd;        /* file descriptor */\n    short events;     /* requested events */\n    short revents;    /* returned events */\n};\n#define poll(x, y, z)        win32_poll(x, y, z)\n\n/* These wrappers do nothing special except set the global errno variable if\n * an error occurs (winsock doesn't do this by default). They set errno\n * to unix-like values (i.e. WSAEWOULDBLOCK is mapped to EAGAIN), so code\n * outside of this file \"shouldn't\" have to worry about winsock specific error\n * handling.\n */\n#define socket(x, y, z)      win32_socket(x, y, z)\n#define connect(x, y, z)     win32_connect(x, y, z)\n#define accept(x, y, z)      win32_accept(x, y, z)\n#define shutdown(x, y)       win32_shutdown(x, y)\n#define getpeername(x, y, z) win32_getpeername(x, y, z)\n\n/* Wrapper macros to call misc. functions mingw is missing */\n#define sleep(x)             win32_sleep(x)\n#define inet_aton(x, y)      win32_inet_aton(x, y)\n#define gettimeofday(x, y)   win32_gettimeofday(x, y)\n#define stat(x, y)           win32_stat(x, y)\n#define snprintf             win32_snprintf\n\n#define mkdir(x, y) mkdir(x)\n#define getcwd _getcwd\n#define getpid _getpid\n#ifndef S_ISDIR\n#define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)\n#endif\n#ifndef S_ISREG\n#define S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)\n#endif\n\n/* Winsock uses int instead of the usual socklen_t */\ntypedef int socklen_t;\n\n/* Function prototypes for functions in mingw.c */\nunsigned int win32_sleep(unsigned int);\nint     win32_inet_aton(const char *, struct in_addr *);\nint     win32_gettimeofday(struct timeval *, char *);\nint     win32_poll(struct pollfd *, unsigned int, int);\nSOCKET  win32_socket(int, int, int);\nint     win32_connect(SOCKET, struct sockaddr*, socklen_t);\nSOCKET  win32_accept(SOCKET, struct sockaddr*, socklen_t *);\nint     win32_shutdown(SOCKET, int);\nint     win32_getpeername(SOCKET, struct sockaddr*, socklen_t *);\nint     win32_snprintf(char* dest, size_t count, const char* format, ...);\n\n/* Three socket specific macros */\n#define READ(x, y, z)  win32_read_socket(x, y, z)\n#define WRITE(x, y, z) win32_write_socket(x, y, z)\n#define CLOSE(x)       win32_close_socket(x)\n\nint win32_read_socket(SOCKET, void *, int);\nint win32_write_socket(SOCKET, void *, int);\nint win32_close_socket(SOCKET);\n\nint win32_setnonblocking(SOCKET, int);\nint win32_stat(const char*, struct stat*);\n#endif\n\n#ifndef HAVE_READV_WRITEV\n/*\n * The HAVE_READV_WRITEV symbol should be defined if the system features\n * the vector IO functions readv() and writev() and those functions may\n * be legally used with sockets.\n */\nstruct iovec {\n    void *iov_base;   /* Starting address */\n    size_t iov_len;   /* Number of bytes */\n};\n#define WRITEV(x, y, z) polipo_writev(x, y, z)\n#define READV(x, y, z)  polipo_readv(x, y, z)\nint polipo_readv(int fd, const struct iovec *vector, int count);\nint polipo_writev(int fd, const struct iovec *vector, int count);\n#endif\n"
        },
        {
          "name": "object.c",
          "type": "blob",
          "size": 28.9228515625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nint mindlesslyCacheVary = 0;\nint objectHashTableSize = 0;\nint log2ObjectHashTableSize;\n\nstatic ObjectPtr object_list = NULL;\nstatic ObjectPtr object_list_end = NULL;\n\nint objectExpiryScheduled;\n\nint publicObjectCount;\nint privateObjectCount;\nint cacheIsShared = 1;\nint publicObjectLowMark = 0, objectHighMark = 2048;\n\nstatic ObjectPtr *objectHashTable;\nint maxExpiresAge = (30 * 24 + 1) * 3600;\nint maxAge = (14 * 24 + 1) * 3600;\nfloat maxAgeFraction = 0.1;\nint maxNoModifiedAge = 23 * 60;\nint maxWriteoutWhenIdle = 64 * 1024;\nint maxObjectsWhenIdle = 32;\nint idleTime = 20;\nint dontCacheCookies = 0;\n\nvoid\npreinitObject()\n{\n    CONFIG_VARIABLE_SETTABLE(idleTime, CONFIG_TIME, configIntSetter,\n                             \"Time to remain idle before writing out.\");\n    CONFIG_VARIABLE_SETTABLE(maxWriteoutWhenIdle, CONFIG_INT, configIntSetter,\n                             \"Amount of data to write at a time when idle.\");\n    CONFIG_VARIABLE_SETTABLE(maxObjectsWhenIdle, CONFIG_INT, configIntSetter,\n                             \"Number of objects to write at a time \"\n                             \"when idle.\");\n    CONFIG_VARIABLE_SETTABLE(cacheIsShared, CONFIG_BOOLEAN, configIntSetter,\n                             \"If false, ignore s-maxage and private.\");\n    CONFIG_VARIABLE_SETTABLE(mindlesslyCacheVary, CONFIG_BOOLEAN,\n                             configIntSetter,\n                             \"If true, mindlessly cache negotiated objects.\");\n    CONFIG_VARIABLE(objectHashTableSize, CONFIG_INT,\n                    \"Size of the object hash table (0 = auto).\");\n    CONFIG_VARIABLE(objectHighMark, CONFIG_INT,\n                    \"High object count mark.\");\n    CONFIG_VARIABLE(publicObjectLowMark, CONFIG_INT,\n                    \"Low object count mark (0 = auto).\");\n    CONFIG_VARIABLE_SETTABLE(maxExpiresAge, CONFIG_TIME, configIntSetter,\n                             \"Max age for objects with Expires header.\");\n    CONFIG_VARIABLE_SETTABLE(maxAge, CONFIG_TIME, configIntSetter,\n                             \"Max age for objects without Expires header.\");\n    CONFIG_VARIABLE_SETTABLE(maxAgeFraction, CONFIG_FLOAT, configFloatSetter,\n                             \"Fresh fraction of modification time.\");\n    CONFIG_VARIABLE_SETTABLE(maxNoModifiedAge, CONFIG_TIME, configIntSetter,\n                             \"Max age for objects without Last-modified.\");\n    CONFIG_VARIABLE_SETTABLE(dontCacheCookies, CONFIG_BOOLEAN, configIntSetter,\n                             \"Work around cachable cookies.\");\n}\n\nvoid\ninitObject()\n{\n    int q;\n    if(objectHighMark < 16) {\n        objectHighMark = 16;\n        do_log(L_WARN, \"Impossibly low objectHighMark -- setting to %d.\\n\",\n               objectHighMark);\n    }\n\n    q = 0;\n    if(publicObjectLowMark == 0) q = 1;\n    if(publicObjectLowMark < 8 || publicObjectLowMark >= objectHighMark - 4) {\n        publicObjectLowMark = objectHighMark / 2;\n        if(!q)\n            do_log(L_WARN, \"Impossible publicObjectLowMark value -- \"\n                   \"setting to %d.\\n\", publicObjectLowMark);\n    }\n\n    q = 1;\n    if(objectHashTableSize <= objectHighMark / 2 ||\n       objectHashTableSize > objectHighMark * 1024) {\n        if(objectHashTableSize != 0) q = 0;\n        objectHashTableSize = objectHighMark * 16;\n    }\n    log2ObjectHashTableSize = log2_ceil(objectHashTableSize);\n    objectHashTableSize = 1 << log2ObjectHashTableSize;\n    if(!q)\n        do_log(L_WARN, \"Suspicious objectHashTableSize value -- \"\n               \"setting to %d.\\n\", objectHashTableSize);\n\n    object_list = NULL;\n    object_list_end = NULL;\n    publicObjectCount = 0;\n    privateObjectCount = 0;\n    objectHashTable = calloc(1 << log2ObjectHashTableSize,\n                             sizeof(ObjectPtr));\n    if(!objectHashTable) {\n        do_log(L_ERROR, \"Couldn't allocate object hash table.\\n\");\n        exit(1);\n    }\n}\n\nObjectPtr\nfindObject(int type, const void *key, int key_size)\n{\n    int h;\n    ObjectPtr object;\n\n    if(key_size >= 50000)\n        return NULL;\n\n    h = hash(type, key, key_size, log2ObjectHashTableSize);\n    object = objectHashTable[h];\n    if(!object)\n        return NULL;\n    if(object->type != type || object->key_size != key_size ||\n       memcmp(object->key, key, key_size) != 0) {\n        return NULL;\n    }\n    if(object->next)\n        object->next->previous = object->previous;\n    if(object->previous)\n        object->previous->next = object->next;\n    if(object_list == object)\n        object_list = object->next;\n    if(object_list_end == object)\n        object_list_end = object->previous;\n    object->previous = NULL;\n    object->next = object_list;\n    if(object_list)\n        object_list->previous = object;\n    object_list = object;\n    if(!object_list_end)\n        object_list_end = object;\n    return retainObject(object);\n}\n\nObjectPtr\nmakeObject(int type, const void *key, int key_size, int public, int fromdisk,\n           RequestFunction request, void* request_closure)\n{\n    ObjectPtr object;\n    int h;\n\n    object = findObject(type, key, key_size);\n    if(object != NULL) {\n        if(public)\n            return object;\n        else\n            privatiseObject(object, 0);\n    }\n\n    if(publicObjectCount + privateObjectCount >= objectHighMark) {\n        if(!objectExpiryScheduled)\n            discardObjects(0, 0);\n        if(publicObjectCount + privateObjectCount >= objectHighMark) {\n            return NULL;\n        }\n    }\n\n    if(publicObjectCount >= publicObjectLowMark && \n       !objectExpiryScheduled) {\n        TimeEventHandlerPtr event;\n        event = scheduleTimeEvent(-1, discardObjectsHandler, 0, NULL);\n        if(event)\n            objectExpiryScheduled = 1;\n        else\n            do_log(L_ERROR, \"Couldn't schedule object expiry.\\n\");\n    }\n\n    object = malloc(sizeof(ObjectRec));\n    if(object == NULL)\n        return NULL;\n\n    object->type = type;\n    object->request = request;\n    object->request_closure = request_closure;\n    object->key = malloc(key_size + 1);\n    if(object->key == NULL) {\n        free(object);\n        return NULL;\n    }\n    memcpy(object->key, key, key_size);\n    /* In order to make it more convenient to use keys as strings,\n       they are NUL-terminated. */\n    object->key[key_size] = '\\0';\n    object->key_size = key_size;\n    object->flags = (public?OBJECT_PUBLIC:0) | OBJECT_INITIAL;\n    if(public) {\n        h = hash(object->type, object->key, object->key_size, \n                 log2ObjectHashTableSize);\n        if(objectHashTable[h]) {\n            writeoutToDisk(objectHashTable[h], objectHashTable[h]->size, -1);\n            privatiseObject(objectHashTable[h], 0);\n            assert(!objectHashTable[h]);\n        }\n        objectHashTable[h] = object;\n        object->next = object_list;\n        object->previous = NULL;\n        if(object_list)\n            object_list->previous = object;\n        object_list = object;\n        if(!object_list_end)\n            object_list_end = object;\n    } else {\n        object->next = NULL;\n        object->previous = NULL;\n    }\n    object->abort_data = NULL;\n    object->code = 0;\n    object->message = NULL;\n    initCondition(&object->condition);\n    object->headers = NULL;\n    object->via = NULL;\n    object->numchunks = 0;\n    object->chunks = NULL;\n    object->length = -1;\n    object->date = -1;\n    object->age = -1;\n    object->expires = -1;\n    object->last_modified = -1;\n    object->atime = -1;\n    object->etag = NULL;\n    object->cache_control = 0;\n    object->max_age = -1;\n    object->s_maxage = -1;\n    object->size = 0;\n    object->requestor = NULL;\n    object->disk_entry = NULL;\n    if(object->flags & OBJECT_PUBLIC)\n        publicObjectCount++;\n    else\n        privateObjectCount++;\n    object->refcount = 1;\n\n    if(public && fromdisk)\n        objectGetFromDisk(object);\n    return object;\n}\n\nvoid \nobjectMetadataChanged(ObjectPtr object, int revalidate)\n{\n    if(revalidate) {\n        revalidateDiskEntry(object);\n    } else {\n        object->flags &= ~OBJECT_DISK_ENTRY_COMPLETE;\n        dirtyDiskEntry(object);\n    }\n    return;\n}\n\nObjectPtr\nretainObject(ObjectPtr object)\n{\n    do_log(D_REFCOUNT, \"O 0x%lx %d++\\n\",\n           (unsigned long)object, object->refcount);\n    object->refcount++;\n    return object;\n}\n\nvoid\nreleaseObject(ObjectPtr object)\n{\n    do_log(D_REFCOUNT, \"O 0x%lx %d--\\n\",\n           (unsigned long)object, object->refcount);\n    object->refcount--;\n    if(object->refcount == 0) {\n        assert(!object->condition.handlers && \n               !(object->flags & OBJECT_INPROGRESS));\n        if(!(object->flags & OBJECT_PUBLIC))\n            destroyObject(object);\n    }\n}\n\nvoid\nreleaseNotifyObject(ObjectPtr object)\n{\n    do_log(D_REFCOUNT, \"O 0x%lx %d--\\n\",\n           (unsigned long)object, object->refcount);\n    object->refcount--;\n    if(object->refcount > 0) {\n        notifyObject(object);\n    } else {\n        assert(!object->condition.handlers && \n               !(object->flags & OBJECT_INPROGRESS));\n        if(!(object->flags & OBJECT_PUBLIC))\n            destroyObject(object);\n    }\n}\n\nvoid \nlockChunk(ObjectPtr object, int i)\n{\n    do_log(D_LOCK, \"Lock 0x%lx[%d]: \", (unsigned long)object, i);\n    assert(i >= 0);\n    if(i >= object->numchunks)\n        objectSetChunks(object, i + 1);\n    object->chunks[i].locked++;\n    do_log(D_LOCK, \"%d\\n\", object->chunks[i].locked);\n}\n\nvoid \nunlockChunk(ObjectPtr object, int i)\n{\n    do_log(D_LOCK, \"Unlock 0x%lx[%d]: \", (unsigned long)object, i);\n    assert(i >= 0 && i < object->numchunks);\n    assert(object->chunks[i].locked > 0);\n    object->chunks[i].locked--;\n    do_log(D_LOCK, \"%d\\n\", object->chunks[i].locked);\n}\n\nint\nobjectSetChunks(ObjectPtr object, int numchunks)\n{\n    int n;\n\n    if(numchunks <= object->numchunks)\n        return 0;\n\n    if(object->length >= 0)\n        n = MAX(numchunks, (object->length + (CHUNK_SIZE - 1)) / CHUNK_SIZE);\n    else\n        n = MAX(numchunks, \n                MAX(object->numchunks + 2, object->numchunks * 5 / 4));\n    \n    if(n == 0) {\n        assert(object->chunks == NULL);\n    } else if(object->numchunks == 0) {\n        object->chunks = calloc(n, sizeof(ChunkRec));\n        if(object->chunks == NULL) {\n            return -1;\n        }\n        object->numchunks = n;\n    } else {\n        ChunkPtr newchunks;\n        newchunks = realloc(object->chunks, n * sizeof(ChunkRec));\n        if(newchunks == NULL)\n            return -1;\n        memset(newchunks + object->numchunks, 0,\n               (n - object->numchunks) * sizeof(ChunkRec));\n        object->chunks = newchunks;\n        object->numchunks = n;\n    }\n    return 0;\n}\n\nObjectPtr\nobjectPartial(ObjectPtr object, int length, struct _Atom *headers)\n{\n    object->headers = headers;\n\n    if(length >= 0) {\n        if(object->size > length) {\n            abortObject(object, 502,\n                        internAtom(\"Inconsistent Content-Length\"));\n            notifyObject(object);\n            return object;\n        }\n    }\n\n    if(length >= 0)\n        object->length = length;\n\n    object->flags &= ~OBJECT_INITIAL;\n    revalidateDiskEntry(object);\n    notifyObject(object);\n    return object;\n}\n\nstatic int\nobjectAddChunk(ObjectPtr object, const char *data, int offset, int plen)\n{\n    int i = offset / CHUNK_SIZE;\n    int rc;\n\n    assert(offset % CHUNK_SIZE == 0);\n    assert(plen <= CHUNK_SIZE);\n\n    if(object->numchunks <= i) {\n        rc = objectSetChunks(object, i + 1);\n        if(rc < 0)\n            return -1;\n    }\n\n    lockChunk(object, i);\n\n    if(object->chunks[i].data == NULL) {\n        object->chunks[i].data = get_chunk();\n        if(object->chunks[i].data == NULL)\n            goto fail;\n    }\n\n    if(object->chunks[i].size >= plen) {\n        unlockChunk(object, i);\n        return 0;\n    }\n\n    if(object->size < offset + plen)\n        object->size = offset + plen;\n    object->chunks[i].size = plen;\n    memcpy(object->chunks[i].data, data, plen);\n    unlockChunk(object, i);\n    return 0;\n\n fail:\n    unlockChunk(object, i);\n    return -1;\n}\n\nstatic int\nobjectAddChunkEnd(ObjectPtr object, const char *data, int offset, int plen)\n{\n    int i = offset / CHUNK_SIZE;\n    int rc;\n\n    assert(offset % CHUNK_SIZE != 0 && \n           offset % CHUNK_SIZE + plen <= CHUNK_SIZE);\n\n    if(object->numchunks <= i) {\n        rc = objectSetChunks(object, i + 1);\n        if(rc < 0)\n            return -1;\n    }\n\n    lockChunk(object, i);\n\n    if(object->chunks[i].data == NULL)\n        object->chunks[i].data = get_chunk();\n    if(object->chunks[i].data == NULL)\n        goto fail;\n\n    if(offset > object->size) {\n        goto fail;\n    }\n\n    if(object->chunks[i].size < offset % CHUNK_SIZE) {\n        goto fail;\n    }\n\n    if(object->size < offset + plen)\n        object->size = offset + plen;\n    object->chunks[i].size = offset % CHUNK_SIZE + plen;\n    memcpy(object->chunks[i].data + (offset % CHUNK_SIZE),\n           data, plen);\n\n    unlockChunk(object, i);\n    return 0;\n\n fail:\n    unlockChunk(object, i);\n    return -1;\n}\n\nint\nobjectAddData(ObjectPtr object, const char *data, int offset, int len)\n{\n    int rc;\n\n    do_log(D_OBJECT_DATA, \"Adding data to 0x%lx (%d) at %d: %d bytes\\n\",\n           (unsigned long)object, object->length, offset, len);\n\n    if(len == 0)\n        return 1;\n\n    if(object->length >= 0) {\n        if(offset + len > object->length) {\n            do_log(L_ERROR, \n                   \"Inconsistent object length (%d, should be at least %d).\\n\",\n                   object->length, offset + len);\n            object->length = offset + len;\n        }\n    }\n            \n    object->flags &= ~OBJECT_FAILED;\n\n    if(offset + len >= object->numchunks * CHUNK_SIZE) {\n        rc = objectSetChunks(object, (offset + len - 1) / CHUNK_SIZE + 1);\n        if(rc < 0) {\n            return -1;\n        }\n    }\n\n    if(offset % CHUNK_SIZE != 0) {\n        int plen = CHUNK_SIZE - offset % CHUNK_SIZE;\n        if(plen >= len)\n            plen = len;\n        rc = objectAddChunkEnd(object, data, offset, plen);\n        if(rc < 0) {\n            return -1;\n        }            \n        offset += plen;\n        data += plen;\n        len -= plen;\n    }\n\n    while(len > 0) {\n        int plen = (len >= CHUNK_SIZE) ? CHUNK_SIZE : len;\n        rc = objectAddChunk(object, data, offset, plen);\n        if(rc < 0) {\n            return -1;\n        }\n        offset += plen;\n        data += plen;\n        len -= plen;\n    }\n\n    return 1;\n}\n\nvoid\nobjectPrintf(ObjectPtr object, int offset, const char *format, ...)\n{\n    char *buf;\n    int rc;\n\n    va_list args;\n    va_start(args, format);\n    buf = vsprintf_a(format, args);\n    va_end(args);\n\n    if(buf == NULL) {\n        abortObject(object, 500, internAtom(\"Couldn't allocate string\"));\n        return;\n    }\n\n    rc = objectAddData(object, buf, offset, strlen(buf));\n    free(buf);\n    if(rc < 0)\n        abortObject(object, 500, internAtom(\"Couldn't add data to object\"));\n}\n\nint \nobjectHoleSize(ObjectPtr object, int offset)\n{\n    int size = 0, i;\n\n    if(offset < 0 || offset / CHUNK_SIZE >= object->numchunks)\n        return -1;\n\n    if(offset % CHUNK_SIZE != 0) {\n        if(object->chunks[offset / CHUNK_SIZE].size > offset % CHUNK_SIZE)\n            return 0;\n        else {\n            size += CHUNK_SIZE - offset % CHUNK_SIZE;\n            offset += CHUNK_SIZE - offset % CHUNK_SIZE;\n            if(offset < 0) {\n                /* Overflow */\n                return -1;\n            }\n        }\n    }\n\n    for(i = offset / CHUNK_SIZE; i < object->numchunks; i++) {\n        if(object->chunks[i].size == 0)\n            size += CHUNK_SIZE;\n        else\n            break;\n    }\n    if(i >= object->numchunks)\n        return -1;\n    return size;\n}\n\n\n/* Returns 2 if the data is wholly in memory, 1 if it's available on disk.\n   If the client request was a Range request, from & to specify the requested\n   range; otherwise 'from' is 0 and 'to' is -1. */\nint\nobjectHasData(ObjectPtr object, int from, int to)\n{\n    int first, last, i, upto;\n\n    if(to < 0) {\n        if(object->length >= 0)\n            to = object->length;\n        else\n            return 0;\n    }\n\n    first = from / CHUNK_SIZE;\n    last = to / CHUNK_SIZE;\n\n    if(from >= to)\n        return 2;\n\n    if(to > object->size) {\n        upto = to;\n        goto disk;\n    }\n\n    if(last > object->numchunks ||\n       object->chunks[last].size > to % CHUNK_SIZE) {\n        upto = to;\n        goto disk;\n    }\n\n    for(i = last - 1; i >= first; i--) {\n        if(object->chunks[i].size < CHUNK_SIZE) {\n            upto = (i + 1) * CHUNK_SIZE;\n            goto disk;\n        }\n    }\n\n    return 2;\n\n disk:\n    if(object->flags & OBJECT_DISK_ENTRY_COMPLETE)\n        return 1;\n\n    if(diskEntrySize(object) >= upto)\n        return 1;\n\n    return 0;\n}\n\nvoid\ndestroyObject(ObjectPtr object)\n{\n    int i;\n\n    assert(object->refcount == 0 && !object->requestor);\n    assert(!object->condition.handlers && \n           (object->flags & OBJECT_INPROGRESS) == 0);\n\n    if(object->disk_entry)\n        destroyDiskEntry(object, 0);\n\n    if(object->flags & OBJECT_PUBLIC) {\n        privatiseObject(object, 0);\n    } else {\n        object->type = -1;\n        if(object->message) releaseAtom(object->message);\n        if(object->key) free(object->key);\n        if(object->headers) releaseAtom(object->headers);\n        if(object->etag) free(object->etag);\n        if(object->via) releaseAtom(object->via);\n        for(i = 0; i < object->numchunks; i++) {\n            assert(!object->chunks[i].locked);\n            if(object->chunks[i].data)\n                dispose_chunk(object->chunks[i].data);\n            object->chunks[i].data = NULL;\n            object->chunks[i].size = 0;\n        }\n        if(object->chunks) free(object->chunks);\n        privateObjectCount--;\n        free(object);\n    }\n}\n\nvoid\nprivatiseObject(ObjectPtr object, int linear) \n{\n    int i, h;\n    if(!(object->flags & OBJECT_PUBLIC)) {\n        if(linear)\n            object->flags |= OBJECT_LINEAR;\n        return;\n    }\n\n    if(object->disk_entry)\n        destroyDiskEntry(object, 0);\n    object->flags &= ~OBJECT_PUBLIC;\n\n    for(i = 0; i < object->numchunks; i++) {\n        if(object->chunks[i].locked)\n            break;\n        if(object->chunks[i].data) {\n            object->chunks[i].size = 0;\n            dispose_chunk(object->chunks[i].data);\n            object->chunks[i].data = NULL;\n        }\n    }\n\n    h = hash(object->type, object->key, object->key_size, \n             log2ObjectHashTableSize);\n    assert(objectHashTable[h] == object);\n    objectHashTable[h] = NULL;\n\n    if(object->previous)\n        object->previous->next = object->next;\n    if(object_list == object)\n        object_list = object->next;\n    if(object->next)\n        object->next->previous = object->previous;\n    if(object_list_end == object)\n        object_list_end = object->previous;\n    object->previous = NULL;\n    object->next = NULL;\n\n    publicObjectCount--;\n    privateObjectCount++;\n\n    if(object->refcount == 0)\n        destroyObject(object);\n    else {\n        if(linear)\n            object->flags |= OBJECT_LINEAR;\n    }\n}\n\nvoid\nabortObject(ObjectPtr object, int code, AtomPtr message)\n{\n    int i;\n\n    assert(code != 0);\n\n    object->flags &= ~(OBJECT_INITIAL | OBJECT_VALIDATING);\n    object->flags |= OBJECT_ABORTED;\n    object->code = code;\n    if(object->message) releaseAtom(object->message);\n    object->message = message;\n    object->length = 0;\n    object->date = object->age;\n    object->expires = object->age;\n    object->last_modified = -1;\n    if(object->etag) free(object->etag);\n    object->etag = NULL;\n    if(object->headers) releaseAtom(object->headers); \n    object->headers = NULL;\n    object->size = 0;\n    for(i = 0; i < object->numchunks; i++) {\n        if(object->chunks[i].data) {\n            if(!object->chunks[i].locked) {\n                dispose_chunk(object->chunks[i].data);\n                object->chunks[i].data = NULL;\n                object->chunks[i].size = 0;\n            }\n        }\n    }\n    privatiseObject(object, 0);\n}\n\nvoid \nsupersedeObject(ObjectPtr object)\n{\n    object->flags |= OBJECT_SUPERSEDED;\n    destroyDiskEntry(object, 1);\n    privatiseObject(object, 0);\n    notifyObject(object);\n}\n\nvoid\nnotifyObject(ObjectPtr object) \n{\n    retainObject(object);\n    signalCondition(&object->condition);\n    releaseObject(object);\n}\n\nint\ndiscardObjectsHandler(TimeEventHandlerPtr event)\n{\n    return discardObjects(0, 0);\n}\n\nvoid\nwriteoutObjects(int all)\n{\n    ObjectPtr object = object_list;\n    int bytes;\n    int objects;\n    int n;\n\n    if(diskIsClean) return;\n\n    objects = 0;\n    bytes = 0;\n    while(object) {\n        do {\n            if(!all) {\n                if(objects >= maxObjectsWhenIdle || \n                   bytes >= maxWriteoutWhenIdle) {\n                    if(workToDo()) return;\n                    objects = 0;\n                    bytes = 0;\n                }\n            }\n            n = writeoutToDisk(object, -1, all ? -1 : maxWriteoutWhenIdle);\n            bytes += n;\n        } while(!all && n == maxWriteoutWhenIdle);\n        objects++;\n        object = object->next;\n    }\n    diskIsClean = 1;\n}\n\nint\ndiscardObjects(int all, int force)\n{\n    ObjectPtr object;\n    int i;\n    static int in_discardObjects = 0;\n    TimeEventHandlerPtr event;\n\n    if(in_discardObjects)\n        return 0;\n\n    in_discardObjects = 1;\n    \n    if(all || force || used_chunks >= CHUNKS(chunkHighMark) ||\n       publicObjectCount >= publicObjectLowMark ||\n       publicObjectCount + privateObjectCount >= objectHighMark) {\n        object = object_list_end;\n        while(object && \n              (all || force || used_chunks >= CHUNKS(chunkLowMark))) {\n            if(force || ((object->flags & OBJECT_PUBLIC) &&\n                         object->numchunks > CHUNKS(chunkLowMark) / 4)) {\n                int j;\n                for(j = 0; j < object->numchunks; j++) {\n                    if(object->chunks[j].locked) {\n                        break;\n                    }\n                    if(object->chunks[j].size < CHUNK_SIZE) {\n                        continue;\n                    }\n                    writeoutToDisk(object, (j + 1) * CHUNK_SIZE, -1);\n                    dispose_chunk(object->chunks[j].data);\n                    object->chunks[j].data = NULL;\n                    object->chunks[j].size = 0;\n                }\n            }\n            object = object->previous;\n        }\n        \n        i = 0;\n        object = object_list_end;\n        while(object && \n              (all || force ||\n               used_chunks - i > CHUNKS(chunkLowMark) ||\n               used_chunks > CHUNKS(chunkCriticalMark) ||\n               publicObjectCount > publicObjectLowMark)) {\n            ObjectPtr next_object = object->previous;\n            if(object->refcount == 0) {\n                i += object->numchunks;\n                writeoutToDisk(object, object->size, -1);\n                privatiseObject(object, 0);\n            } else if(all || force) {\n                writeoutToDisk(object, object->size, -1);\n                destroyDiskEntry(object, 0);\n            }\n            object = next_object;\n        }\n\n        object = object_list_end;\n        if(force || used_chunks > CHUNKS(chunkCriticalMark)) {\n            if(used_chunks > CHUNKS(chunkCriticalMark)) {\n                do_log(L_WARN, \n                       \"Short on chunk memory -- \"\n                       \"attempting to punch holes \"\n                       \"in the middle of objects.\\n\");\n            }\n            while(object && \n                  (force || used_chunks > CHUNKS(chunkCriticalMark))) {\n                if(force || (object->flags & OBJECT_PUBLIC)) {\n                    int j;\n                    for(j = object->numchunks - 1; j >= 0; j--) {\n                        if(object->chunks[j].locked)\n                            continue;\n                        if(object->chunks[j].size < CHUNK_SIZE)\n                            continue;\n                        writeoutToDisk(object, (j + 1) * CHUNK_SIZE, -1);\n                        dispose_chunk(object->chunks[j].data);\n                        object->chunks[j].data = NULL;\n                        object->chunks[j].size = 0;\n                    }\n                }\n                object = object->previous;\n            }\n        }\n        event = scheduleTimeEvent(2, discardObjectsHandler, 0, NULL);\n        if(event) {\n            objectExpiryScheduled = 1;\n        } else {\n            objectExpiryScheduled = 0;\n            do_log(L_ERROR, \"Couldn't schedule object expiry.\\n\");\n        }\n    } else {\n        objectExpiryScheduled = 0;\n    }\n\n    if(all) {\n        if(privateObjectCount + publicObjectCount != 0) {\n            do_log(L_WARN,\n                   \"Discarded all objects, \"\n                   \"%d + %d objects left (%d chunks and %d atoms used).\\n\",\n                   publicObjectCount, privateObjectCount,\n                   used_chunks, used_atoms);\n        } else if(used_chunks != 0) {\n            do_log(L_WARN,\n                   \"Discarded all objects, \"\n                   \"%d chunks and %d atoms left.\\n\",\n                   used_chunks, used_atoms);\n        }\n        diskIsClean = 1;\n    }\n\n    in_discardObjects = 0;\n    return 1;\n}\n\nCacheControlRec no_cache_control = {0, -1, -1, -1, -1};\n\nint\nobjectIsStale(ObjectPtr object, CacheControlPtr cache_control)\n{\n    int stale = 0x7FFFFFFF;\n    int flags;\n    int max_age, s_maxage;\n    time_t date;\n\n    if(object->flags & OBJECT_INITIAL)\n        return 0;\n\n    if(object->date >= 0)\n        date = object->date;\n    else if(object->age >= 0)\n        date = object->age;\n    else\n        date = current_time.tv_sec;\n\n    if(cache_control == NULL)\n        cache_control = &no_cache_control;\n    flags = object->cache_control | cache_control->flags;\n\n    if(cache_control->max_age >= 0) {\n        if(object->max_age >= 0)\n            max_age = MIN(cache_control->max_age, object->max_age);\n        else\n            max_age = cache_control->max_age;\n    } else\n        max_age = object->max_age;\n\n    if(cache_control->s_maxage >= 0) {\n        if(object->s_maxage >= 0)\n            s_maxage = MIN(cache_control->s_maxage, object->s_maxage);\n        else\n            s_maxage = cache_control->s_maxage;\n    } else\n        s_maxage = object->s_maxage;\n    \n    if(max_age >= 0)\n        stale = MIN(stale, object->age + max_age);\n\n    if(cacheIsShared && s_maxage >= 0)\n        stale = MIN(stale, object->age + s_maxage);\n\n    if(object->expires >= 0 || object->max_age >= 0)\n        stale = MIN(stale, object->age + maxExpiresAge);\n    else\n        stale = MIN(stale, object->age + maxAge);\n\n    /* RFC 2616 14.9.3: server-side max-age overrides expires */\n\n    if(object->expires >= 0 && object->max_age < 0) {\n        /* This protects against clock skew */\n        stale = MIN(stale, object->age + object->expires - date);\n    }\n\n    if(object->expires < 0 && object->max_age < 0) {\n        /* No server-side information -- heuristic expiration */\n        if(object->last_modified >= 0)\n            /* Again, take care of clock skew */\n            stale = MIN(stale,\n                        object->age +\n                        (date - object->last_modified) * maxAgeFraction);\n        else\n            stale = MIN(stale, object->age + maxNoModifiedAge);\n    }\n\n    if(!(flags & CACHE_MUST_REVALIDATE) &&\n       !(cacheIsShared && (flags & CACHE_PROXY_REVALIDATE))) {\n        /* Client side can relax transparency */\n        if(cache_control->min_fresh >= 0) {\n            if(cache_control->max_stale >= 0)\n                stale = MIN(stale - cache_control->min_fresh,\n                            stale + cache_control->max_stale);\n            else\n                stale = stale - cache_control->min_fresh;\n        } else if(cache_control->max_stale >= 0) {\n            stale = stale + cache_control->max_stale;\n        }\n    }\n\n    return current_time.tv_sec > stale;\n}\n\nint\nobjectMustRevalidate(ObjectPtr object, CacheControlPtr cache_control)\n{\n    int flags;\n\n    if(cache_control == NULL)\n        cache_control = &no_cache_control;\n    if(object)\n        flags = object->cache_control | cache_control->flags;\n    else\n        flags = cache_control->flags;\n    \n    if(flags & (CACHE_NO | CACHE_NO_HIDDEN | CACHE_NO_STORE))\n        return 1;\n\n    if(cacheIsShared && (flags & CACHE_PRIVATE))\n        return 1;\n\n    if(!mindlesslyCacheVary && (flags & CACHE_VARY))\n        return 1;\n\n    if(dontCacheCookies && (flags & CACHE_COOKIE))\n        return 1;\n\n    if(object)\n        return objectIsStale(object, cache_control);\n\n    return 0;\n}\n\n"
        },
        {
          "name": "object.h",
          "type": "blob",
          "size": 6.0947265625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#undef MAX\n#undef MIN\n\n#define MAX(x,y) ((x)<=(y)?(y):(x))\n#define MIN(x,y) ((x)<=(y)?(x):(y))\n\nstruct _HTTPRequest;\n\n#if defined(USHRT_MAX) && CHUNK_SIZE <= USHRT_MAX\ntypedef unsigned short chunk_size_t;\n#else\ntypedef unsigned int chunk_size_t;\n#endif\n\ntypedef struct _Chunk {\n    short int locked;\n    chunk_size_t size;\n    char *data;\n} ChunkRec, *ChunkPtr;\n\nstruct _Object;\n\ntypedef int (*RequestFunction)(struct _Object *, int, int, int,\n                               struct _HTTPRequest*, void*);\n\ntypedef struct _Object {\n    short refcount;\n    unsigned char type;\n    RequestFunction request;\n    void *request_closure;\n    char *key;\n    unsigned short key_size;\n    unsigned short flags;\n    unsigned short code;\n    void *abort_data;\n    struct _Atom *message;\n    int length;\n    time_t date;\n    time_t age;\n    time_t expires;\n    time_t last_modified;\n    time_t atime;\n    char *etag;\n    unsigned short cache_control;\n    int max_age;\n    int s_maxage;\n    struct _Atom *headers;\n    struct _Atom *via;\n    int size;\n    int numchunks;\n    ChunkPtr chunks;\n    void *requestor;\n    struct _Condition condition;\n    struct _DiskCacheEntry *disk_entry;\n    struct _Object *next, *previous;\n} ObjectRec, *ObjectPtr;\n\ntypedef struct _CacheControl {\n    int flags;\n    int max_age;\n    int s_maxage;\n    int min_fresh;\n    int max_stale;\n} CacheControlRec, *CacheControlPtr;\n\nextern int cacheIsShared;\nextern int mindlesslyCacheVary;\n\nextern CacheControlRec no_cache_control;\nextern int objectExpiryScheduled;\nextern int publicObjectCount;\nextern int privateObjectCount;\nextern int idleTime;\n\nextern const time_t time_t_max;\n\nextern int publicObjectLowMark, objectHighMark;\n\nextern int log2ObjectHashTableSize;\n\n/* object->type */\n#define OBJECT_HTTP 1\n#define OBJECT_DNS 2\n\n/* object->flags */\n/* object is public */\n#define OBJECT_PUBLIC 1\n/* object hasn't got any headers yet */\n#define OBJECT_INITIAL 2\n/* a server connection is already taking care of the object */\n#define OBJECT_INPROGRESS 4\n/* the object has been superseded -- don't try to fetch it */\n#define OBJECT_SUPERSEDED 8\n/* the object is private and aditionally can only be used by its requestor */\n#define OBJECT_LINEAR 16\n/* the object is currently being validated */\n#define OBJECT_VALIDATING 32\n/* object has been aborted */\n#define OBJECT_ABORTED 64\n/* last object request was a failure */\n#define OBJECT_FAILED 128\n/* Object is a local file */\n#define OBJECT_LOCAL 256\n/* The object's data has been entirely written out to disk */\n#define OBJECT_DISK_ENTRY_COMPLETE 512\n/* The object is suspected to be dynamic -- don't PMM */\n#define OBJECT_DYNAMIC 1024\n/* Used for synchronisation between client and server. */\n#define OBJECT_MUTATING 2048\n\n/* object->cache_control and connection->cache_control */\n/* RFC 2616 14.9 */\n/* Non-standard: like no-cache, but kept internally */\n#define CACHE_NO_HIDDEN 1\n/* no-cache */\n#define CACHE_NO 2\n/* public */\n#define CACHE_PUBLIC 4\n/* private */\n#define CACHE_PRIVATE 8\n/* no-store */\n#define CACHE_NO_STORE 16\n/* no-transform */\n#define CACHE_NO_TRANSFORM 32\n/* must-revalidate */\n#define CACHE_MUST_REVALIDATE 64\n/* proxy-revalidate */\n#define CACHE_PROXY_REVALIDATE 128\n/* only-if-cached */\n#define CACHE_ONLY_IF_CACHED 256\n/* set if Vary header; treated as no-cache */\n#define CACHE_VARY 512\n/* set if Authorization header; treated specially */\n#define CACHE_AUTHORIZATION 1024\n/* set if cookie */\n#define CACHE_COOKIE 2048\n/* set if this object should never be combined with another resource */\n#define CACHE_MISMATCH 4096\n\nstruct _HTTPRequest;\n\nvoid preinitObject(void);\nvoid initObject(void);\nObjectPtr findObject(int type, const void *key, int key_size);\nObjectPtr makeObject(int type, const void *key, int key_size,\n                     int public, int fromdisk,\n                     int (*request)(ObjectPtr, int, int, int, \n                                    struct _HTTPRequest*, void*), void*);\nvoid objectMetadataChanged(ObjectPtr object, int dirty);\nObjectPtr retainObject(ObjectPtr);\nvoid releaseObject(ObjectPtr);\nint objectSetChunks(ObjectPtr object, int numchunks);\nvoid lockChunk(ObjectPtr, int);\nvoid unlockChunk(ObjectPtr, int);\nvoid destroyObject(ObjectPtr object);\nvoid privatiseObject(ObjectPtr object, int linear);\nvoid abortObject(ObjectPtr object, int code, struct _Atom *message);\nvoid supersedeObject(ObjectPtr);\nvoid notifyObject(ObjectPtr);\nvoid releaseNotifyObject(ObjectPtr);\nObjectPtr objectPartial(ObjectPtr object, int length, struct _Atom *headers);\nint objectHoleSize(ObjectPtr object, int offset)\n    ATTRIBUTE ((pure));\nint objectHasData(ObjectPtr object, int from, int to)\n    ATTRIBUTE ((pure));\nint objectAddData(ObjectPtr object, const char *data, int offset, int len);\nvoid objectPrintf(ObjectPtr object, int offset, const char *format, ...)\n     ATTRIBUTE ((format (printf, 3, 4)));\nint discardObjectsHandler(TimeEventHandlerPtr);\nvoid writeoutObjects(int);\nint discardObjects(int all, int force);\nint objectIsStale(ObjectPtr object, CacheControlPtr cache_control)\n    ATTRIBUTE ((pure));\nint objectMustRevalidate(ObjectPtr object, CacheControlPtr cache_control)\n    ATTRIBUTE ((pure));\n"
        },
        {
          "name": "parse_time.c",
          "type": "blob",
          "size": 5.6005859375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nconst time_t time_t_max = ((time_t)~(1U << 31));\n\nstatic inline int\nd2i(char c)\n{\n    if(c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic int\nparse_int(const char *buf, int i, int len, int *val_return)\n{\n    int val, d;\n\n    if(i >= len)\n        return -1;\n\n    val = d2i(buf[i]);\n    if(val < 0)\n        return -1;\n    else\n        i++;\n\n    while(i < len) {\n        d = d2i(buf[i]);\n        if(d < 0)\n            break;\n        val = val * 10 + d;\n        i++;\n    }\n    *val_return = val;\n    return i;\n}\n\nstatic const char month_names[12][3] = {\n    \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\",\n    \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\",\n};\n\nstatic int\nskip_word(const char *buf, int i, int len)\n{\n    if(i >= len)\n        return -1;\n\n    if(!letter(buf[i]))\n       return -1;\n\n    while(i < len) {\n        if(!letter(buf[i]))\n            break;\n        i++;\n    }\n\n    return i;\n}\n\nstatic int\nparse_month(const char *buf, int i, int len, int *val_return)\n{\n    int j, k, l;\n    j = skip_word(buf, i, len);\n    if(j != i + 3)\n        return -1;\n    for(k = 0; k < 12; k++) {\n        for(l = 0; l < 3; l++) {\n            if(lwr(buf[i + l]) != month_names[k][l])\n                break;\n        }\n        if(l == 3)\n            break;\n    }\n    if(k >= 12)\n        return -1;\n    *val_return = k;\n    return j;\n}\n\nstatic int\nissep(char c)\n{\n    return c == ' ' || c == '\\t' || c == ',' || c == ':' || c == '-';\n}\n\nint\nskip_separator(const char *buf, int i, int len)\n{\n    if(i >= len)\n        return -1;\n\n    if(issep(buf[i]))\n        i++;\n    else\n        return -1;\n\n    while(i < len) {\n        if(issep(buf[i]))\n            i++;\n        else\n            break;\n    }\n    return i;\n}\n\nint\nparse_time(const char *buf, int offset, int len, time_t *time_return)\n{\n    struct tm tm;\n    time_t t;\n    int i = offset;\n\n    i = skip_word(buf, i, len); if(i < 0) return -1;\n    i = skip_separator(buf, i, len); if(i < 0) return -1;\n\n    if(i >= len)\n        return -1;\n\n    if(d2i(buf[i]) >= 0) {\n        i = parse_int(buf, i, len, &tm.tm_mday); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_month(buf, i, len, &tm.tm_mon); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_year); if(i < 0) return -1;\n        if(tm.tm_year < 100)\n            tm.tm_year += 1900;\n        if(tm.tm_year < 1937)\n            tm.tm_year += 100;\n        if(tm.tm_year < 1937)\n            return -1;\n\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_hour); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_min); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_sec); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = skip_word(buf, i, len); if(i < 0) return -1;\n    } else {                    /* funny American format */\n        i = parse_month(buf, i, len, &tm.tm_mon); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_mday); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_hour); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_min); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_sec); if(i < 0) return -1;\n        i = skip_separator(buf, i, len); if(i < 0) return -1;\n        i = parse_int(buf, i, len, &tm.tm_year); if(i < 0) return -1;\n        if(tm.tm_year < 100)\n            tm.tm_year += 1900;\n        if(tm.tm_year < 1937)\n            tm.tm_year += 100;\n        if(tm.tm_year < 1937 || tm.tm_year > 2040)\n            return -1;\n    }\n\n    if(tm.tm_year < 2038) {\n        tm.tm_year -= 1900;\n        tm.tm_isdst = -1;\n        t = mktime_gmt(&tm);\n        if(t == -1)\n            return -1;\n    } else {\n        t = time_t_max;\n    }\n\n    *time_return = t;\n    return i;\n}\n\nint\nformat_time(char *buf, int i, int len, time_t t)\n{\n    struct tm *tm;\n    int rc;\n\n    if(i < 0 || i > len)\n        return -1;\n\n    tm = gmtime(&t);\n    if(tm == NULL)\n        return -1;\n    rc = strftime(buf + i, len - i, \"%a, %d %b %Y %H:%M:%S GMT\", tm);\n    if(rc <= 0)                 /* yes, that's <= */\n        return -1;\n    return i + rc;\n}\n"
        },
        {
          "name": "parse_time.h",
          "type": "blob",
          "size": 1.2158203125,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* XXX */\nextern const time_t time_t_max;\n\nint parse_time(const char *buf, int i, int len, time_t *time_return);\nint format_time(char *buf, int i, int len, time_t t);\n"
        },
        {
          "name": "polipo.h",
          "type": "blob",
          "size": 4.5615234375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#ifndef WIN32\n#include <sys/param.h>\n#endif\n\n#include <limits.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <assert.h>\n#ifndef _WIN32\n#include <unistd.h>\n#include <sys/time.h>\n#include <dirent.h>\n#else\n#include \"dirent_compat.h\"\n#endif\n#include <fcntl.h>\n#include <time.h>\n#include <sys/stat.h>\n#ifndef WIN32 /*MINGW*/\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <poll.h>\n#include <sys/wait.h>\n#include <sys/ioctl.h>\n#include <signal.h>\n#endif\n\n#ifdef __MINGW32__\n#define MINGW\n#endif\n\n#ifndef MAP_ANONYMOUS\n#define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n/* nothing */\n#elif defined(__GNUC__)\n#define inline __inline\n#if  (__GNUC__ >= 3)\n#define restrict __restrict\n#else\n#define restrict /**/\n#endif\n#else\n#define inline /**/\n#define restrict /**/\n#endif\n\n#if defined(__GNUC__) && (__GNUC__ >= 3)\n#define ATTRIBUTE(x) __attribute__(x)\n#else\n#define ATTRIBUTE(x) /**/\n#endif\n\n/* Musl doesn't have a specific test, so assume musl if Linux and neither\n   __GLIBC__ nor __UCLIBC__ */\n\n#if defined __linux\n#define HAVE_TM_GMTOFF\n#define HAVE_SETENV\n#define HAVE_ASPRINTF\n#define HAVE_MEMRCHR\n#ifdef __GLIBC__\n#define HAVE_FTS\n#endif\n#ifndef __UCLIBC__\n#define HAVE_FFSL\n#define HAVE_FFSLL\n#define HAVE_TIMEGM\n#endif\n#endif\n\n#ifdef BSD\n#define HAVE_TM_GMTOFF\n#define HAVE_FTS\n#define HAVE_SETENV\n#endif\n\n#ifdef __CYGWIN__\n#define HAVE_SETENV\n#define HAVE_ASPRINTF\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#define HAVE_TZSET\n\n#if _POSIX_VERSION >= 200112L\n#define HAVE_SETENV\n#endif\n\n#ifndef NO_IPv6\n\n#ifdef __GLIBC__\n#if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)\n#define HAVE_IPv6\n#endif\n#endif\n\n#ifdef __FreeBSD__\n#define HAVE_ASPRINTF\n#if __FreeBSD_version >= 400000\n#define HAVE_IPv6\n#define HAVE_TIMEGM\n#endif\n#if __FreeBSD_version >= 503001\n#define HAVE_FFSL\n#endif\n#endif\n\n#ifdef __NetBSD__\n#if __NetBSD_Version__ >= 105000000\n#define HAVE_IPv6\n#endif\n#if __NetBSD_Version__ >= 200000000\n#define HAVE_TIMEGM\n#define HAVE_ASPRINTF\n#endif\n#endif\n\n#ifdef __OpenBSD__\n/* OpenBSD 2.3 and later */\n#define HAVE_IPv6\n#define HAVE_ASPRINTF\n#endif\n\n#ifdef __APPLE__\n#define HAVE_ASPRINTF\n#define HAVE_IPv6\n#define HAVE_TIMEGM\n#define HAVE_FFSL\n#endif\n\n#endif\n\n#if defined(i386) || defined(__mc68020__) || defined(__x86_64__)\n#define UNALIGNED_ACCESS\n#endif\n\n#ifndef WIN32 /*MINGW*/\n#define HAVE_FORK\n#ifndef NO_SYSLOG\n#define HAVE_SYSLOG\n#endif\n#define HAVE_READV_WRITEV\n#define HAVE_FFS\n#define READ(x, y, z) read(x, y, z)\n#define WRITE(x, y, z) write(x, y, z)\n#define CLOSE(x) close(x)\n#else\n#ifndef HAVE_REGEX\n#define NO_FORBIDDEN\n#endif\n#ifndef MINGW\n#define HAVE_MKGMTIME\n#endif\n#endif\n\n#ifdef HAVE_READV_WRITEV\n#define WRITEV(x, y, z) writev(x, y, z)\n#define READV(x, y, z)  readv(x, y, z)\n#endif\n\n#ifndef HAVE_FORK\n#define NO_REDIRECTOR\n#endif\n\n#include \"mingw.h\"\n\n#include \"ftsimport.h\"\n#include \"atom.h\"\n#include \"util.h\"\n#include \"config.h\"\n#include \"event.h\"\n#include \"io.h\"\n#include \"socks.h\"\n#include \"chunk.h\"\n#include \"object.h\"\n#include \"dns.h\"\n#include \"http.h\"\n#include \"client.h\"\n#include \"local.h\"\n#include \"diskcache.h\"\n#include \"server.h\"\n#include \"http_parse.h\"\n#include \"parse_time.h\"\n#include \"forbidden.h\"\n#include \"log.h\"\n#include \"auth.h\"\n#include \"tunnel.h\"\n\nextern AtomPtr configFile;\nextern int daemonise;\nextern AtomPtr pidFile;\n"
        },
        {
          "name": "polipo.man",
          "type": "blob",
          "size": 2.0166015625,
          "content": ".TH POLIPO 1\n.SH NAME\npolipo \\- a caching web proxy\n.SH SYNOPSIS\n.B polipo\n[\n.B \\-h\n|\n.B \\-v\n|\n.B \\-x\n] [\n.B \\-c\n.I config\n] [\n.IB var=val\n]...\n.SH DESCRIPTION\nPolipo is a caching HTTP proxy.  It listens to requests for web pages\nfrom your browser and forwards them to web servers, and forwards the\nservers' replies to your browser.  In the process, it optimises and\ncleans up the network traffic.\n.PP\nBy default, Polipo listens on TCP port 8123.  Please configure your\nweb browser to use the proxy on \n.B localhost \nport 8123.\n.SH OPTIONS\n.TP\n.B \\-h\nDisplay help and exit.\n.TP\n.B \\-v\nDisplay the list of configuration variables and exit.\n.TP\n.B \\-x\nPurge the on-disk cache and exit.\n.TP\n.B \\-c\nSelect an alternate configuration file.\n.TP\n.IB var = val\nChange the value of a configuration variable.\n.SH FILES\n.TP\n.B /etc/polipo/config\nThe default location of Polipo's configuration file.\n.TP\n.B /etc/polipo/forbidden\nThe default location of the list of forbidden URLs.\n.TP\n.B /var/cache/polipo/\nThe default location of the on-disk cache.\n.TP\n.B /usr/share/polipo/www/\nThe default root of the local web space.\n.SH SIGNALS\n.TP \n.B SIGUSR1\nwrite out all in-memory objects to disk and reload the forbidden URLs file.\n.TP \n.B SIGUSR2\nwrite out all in-memory objects to disk, discard all in-memory\nobjects, and reload the forbidden URLs file.\n.TP \n.B SIGTERM, SIGINT, SIGHUP\nwrite out all in-memory objects to disk and quit.\n.SH SECURITY\nThe internal web server will follow symbolic links that point outside\nthe local document tree.  You should run Polipo in a chroot jail if that\nis a problem.\n.PP\nThere is no reason to run Polipo as root.\n.SH FULL DOCUMENTATION\nThe full manual for Polipo is maintained in a texinfo file, and is\nnormally available through a web server internal to Polipo.  Please\nmake sure that Polipo is running, and point your favourite web browser\nat\n.IP\nhttp://localhost:8123/\n.PP\nAlternatively, you may type\n.IP\n$ info polipo\n.PP\nat a shell prompt, or\n.IP\nC-h i m polipo RET\n.PP\nin\n.BR Emacs .\n.SH AUTHOR\nPolipo was written by Juliusz Chroboczek.\n"
        },
        {
          "name": "polipo.texi",
          "type": "blob",
          "size": 81.783203125,
          "content": "\\input texinfo @c -*-texinfo-*-\n@c %**start of header\n@setfilename polipo.info\n@settitle The Polipo Manual\n@afourpaper\n@c %**end of header\n\n@dircategory Network Applications\n@direntry\n* Polipo: (polipo).                     The Polipo caching web proxy.\n@end direntry\n\n@copying\nCopyright @copyright{} 2003 -- 2014 by Juliusz Chroboczek.\n@end copying\n\n@titlepage\n@title The Polipo Manual\n@author Juliusz Chroboczek\n@page\n@vskip 0pt plus 1fill\nPolipo is a caching web proxy designed to be used as a personal\ncache or a cache shared among a few users.\n@vskip 0pt plus 1fill\n\n@insertcopying\n\n@end titlepage\n\n@contents\n\n@ifnottex\n@node Top, Background, (dir), (dir)\n@top Polipo\n\nPolipo is a caching web proxy designed to be used as a personal\ncache or a cache shared among a few users.\n\n@ifhtml\nThe latest version of Polipo can be found on \n@uref{http://www.pps.univ-paris-diderot.fr/~jch/software/polipo/,the Polipo web page}.\n@end ifhtml\n\nThis manual was written by\n@uref{http://www.pps.univ-paris-diderot.fr/~jch/,,Juliusz Chroboczek}.\n\n@end ifnottex\n\n@menu\n* Background::                  Background information.\n* Running::                     Running Polipo\n* Network::                     Polipo and the network.\n* Caching::                     Caching.\n* Memory usage::                Limiting Polipo's memory usage.\n* Copying::                     Your rights and mine.\n* Variable index::              Variable index.\n* Concept index::               Concept index.\n@end menu\n\n@node Background, Running, Top, Top\n@chapter Background\n\n@menu\n* The web::                     The web and HTTP.\n* Proxies and caches::          Proxies and caches.\n* Latency and throughput::      Optimise latency, not throughput.\n* Network traffic::             Be nice to the net.\n* Partial instances::           Don't discard data.\n* POST and PUT::                Other requests\n@end menu\n\n@node The web, Proxies and caches, Background, Background\n@section The web and HTTP\n@cindex URL\n@cindex resource\n@cindex instance\n@cindex entity\n@cindex HTTP\n\nThe web is a wide-scale decentralised distributed hypertext system,\nsomething that's obviously impossible to achieve reliably.\n\nThe web is a collection of @dfn{resources} which are identified by\n@dfn{URLs}, strings starting with @code{http://}.  At any point in\ntime, a resource has a certain value, which is called an\n@dfn{instance} of the resource.\n\nThe fundamental protocol of the web is HTTP, a simple request/response\nprotocol.  With HTTP, a client can make a request for a resource to a\nserver, and the server replies with an @dfn{entity}, which is an\non-the-wire representation of an instance or of a fragment thereof.\n\n@node Proxies and caches, Latency and throughput, The web, Background\n@section Proxies and caches\n@cindex proxy\n@cindex caching\n\nA proxy is a program that acts as both a client and a server.  It\nlistens for client requests and forwards them to servers, and forwards\nthe servers' replies to clients.\n\nAn HTTP proxy can optimise web traffic away by @dfn{caching} server\nreplies, storing them in memory in case they are needed again.  If a\nreply has been cached, a later client request may, under some\nconditions, be satisfied without going to the source again.\n\nIn addition to taking the shortcuts made possible by caching, proxies\ncan improve performance by generating better network traffic than the\nclient applications would do.\n\nProxies are also useful in ways unrelated to raw performance.  A proxy\ncan be used to contact a server that is not directly accessible to the\nclient, for example because there is a firewall in the way\n(@pxref{Parent proxies}), or because the client and the server use\ndifferent lower layer protocols (for example IPv4 and IPv6).  Another\ncommon application of proxies is to modify the data sent to servers\nand returned to clients, for example by censoring headers that expose\ntoo much about the client's identity (@pxref{Censoring headers}) or\nremoving advertisements from the data returned by the server\n(@pxref{Forbidden}).\n\nPolipo is a caching HTTP proxy that was originally designed as\na @dfn{personal} proxy, i.e.@: a proxy that is used by a single user\nor a small group of users.  However, it has successfully been used by\nlarger groups.\n\n@node Latency and throughput, Network traffic, Proxies and caches, Background\n@section Latency and throughput\n@cindex throughput\n@cindex latency\n\nMost network benchmarks consider @dfn{throughput}, or the average\namount of data being pushed around per unit of time.  While important\nfor batch applications (for example benchmarks), average throughput is\nmostly irrelevant when it comes to interactive web usage.  What is more\nimportant is a transaction's median @dfn{latency}, or whether the data\nstarts to trickle down before the user gets annoyed.\n\nTypical web caches optimise for throughput --- for example, by\nconsulting sibling caches before accessing a remote resource.  By\ndoing so, they significantly add to the median latency, and therefore\nto the average user frustration.\n\nPolipo was designed to minimise latency.\n\n@node Network traffic, Partial instances, Latency and throughput, Background\n@section Network traffic\n\nThe web was developed by people who were interested in text processing\nrather than in networking and, unsurprisingly enough, the first\nversions of the HTTP protocol did not make very good use of network\nresources.  The main problem in HTTP/0.9 and early versions of\nHTTP/1.0 was that a separate TCP connection (``virtual circuit'' for\nthem telecom people) was created for every entity transferred.\n\nOpening multiple TCP connections has significant performance\nimplications.  Obviously, connection setup and teardown require\nadditional packet exchanges which increase network usage and, more\nimportantly, latency.\n\nLess obviously, TCP is not optimised for that sort of usage.  TCP aims\nto avoid network @dfn{congestion}, a situation in which the network\nbecomes unusable due to overly aggressive traffic patterns.  A correct\nTCP implementation will very carefully probe the network at the\nbeginning of every connection, which means that a TCP connection is\nvery slow during the first couple of kilobytes transferred, and only\ngets up to speed later.  Because most HTTP entities are small (in the\n1 to 10 kilobytes range), HTTP/0.9 uses TCP where it is most inefficient.\n\n@menu\n* Persistent connections::      Don't shut connections down.\n* Pipelining::                  Send a bunch of requests at once.\n* Poor Mans Multiplexing::      Split requests.\n@end menu\n\n@node Persistent connections, Pipelining, Network traffic, Network traffic\n@subsection Persistent connections\n@cindex persistent connection\n@cindex keep-alive connection\n\nLater HTTP versions allow the transfer of multiple entities on a\nsingle connection.  A connection that carries multiple entities is\nsaid to be @dfn{persistent} (or sometimes @dfn{keep-alive}).\nUnfortunately, persistent connections are an optional feature of HTTP,\neven in version 1.1.\n\nPolipo will attempt to use persistent connections on the server side,\nand will honour persistent connection requests from clients.\n\n@node Pipelining, Poor Mans Multiplexing, Persistent connections, Network traffic\n@subsection Pipelining\n@cindex Pipelining\n\nWith persistent connections it becomes possible to @dfn{pipeline} or\n@dfn{stream} requests, i.e. to send multiple requests on a single\nconnection without waiting for the replies to come back.  Because this\ntechnique gets the requests to the server faster, it reduces latency.\nAdditionally, because multiple requests can often be sent in a single\npacket, pipelining reduces network traffic.\n\nPipelining is a fairly common technique@footnote{The X11 protocol\nfundamentally relies on pipelining.  NNTP does support pipelining.\nSMTP doesn't, while ESMTP makes it an option.  FTP does support\npipelining on the control connection.}, but it is not supported by\nHTTP/1.0.  HTTP/1.1 makes pipelining support compulsory in every\nserver implementation that can use persistent connections, but there\nare a number of buggy servers that claim to implement HTTP/1.1 but\ndon't support pipelining.\n\nPolipo carefully probes for pipelining support in a server and uses\npipelining if it believes that it is reliable.  Polipo also deeply\nenjoys being pipelined at by a client@footnote{Other client-side\nimplementations of HTTP that make use of pipelining include\n@uref{http://www.opera.com/,,Opera},\n@uref{http://www.mozilla.org,,Mozilla}, APT (the package downloader\nused by @uref{http://www.debian.org,,Debian} GNU/Linux) and LFTP.}.\n\n@node Poor Mans Multiplexing,  , Pipelining, Network traffic\n@subsection Poor Man's Multiplexing\n@cindex Poor Man's Multiplexing\n@cindex multiplexing\n\nA major weakness of the HTTP protocol is its inability to share a\nsingle connection between multiple simultaneous transactions --- to\n@dfn{multiplex} a number of transactions over a single connection.  In\nHTTP, a client can either request all instances sequentially, which\nsignificantly increases latency, or else open multiple concurrent\nconnections, with all the problems that this implies\n(@pxref{Persistent connections}).\n\nPoor Man's Multiplexing (PMM) is a technique that simulates\nmultiplexing by requesting an instance in multiple segments; because\nthe segments are fetched in independent transactions, they can be\ninterleaved with requests for other resources.\n\nObviously, PMM only makes sense in the presence of persistent\nconnections; additionally, it is only effective in the presence of\npipelining (@pxref{Pipelining}).\n\nPMM poses a number of reliability issues.  If the resource being\nfetched is dynamic, it is quite possible that it will change between\nsegments; thus, an implementation making use of PMM needs to be able\nto switch to full-resource retrieval when it detects a dynamic\nresource.\n\nPolipo supports PMM, but it is disabled it by default (@pxref{PMM}).\n\n@node Partial instances, POST and PUT, Network traffic, Background\n@section Caching partial instances\n@cindex partial instance\n@cindex range request\n\nA partial instance is an instance that is being cached but only part\nof which is available in the local cache.  There are three ways in\nwhich partial instances can arise: client applications requesting only\npart of an instance (Adobe's Acrobat Reader plugin is famous for\nthat), a server dropping a connection mid-transfer (because it is\nshort on resources, or, surprisingly often, because it is buggy), a\nclient dropping a connection (usually because the user pressed\n@emph{stop}).\n\nWhen an instance is requested that is only partially cached, it is\npossible to request just the missing data by using a feature of HTTP\nknown as a @dfn{range} request.  While support for range requests is\noptional, most servers honour them in case of static data (data that\nare stored on disk, rather then being generated on the fly e.g.@: by a\nCGI script).\n\nCaching partial instances has a number of positive effects.  Obviously,\nit reduces the amount of data transmitted as the available data\nneedn't be fetched again.  Because it prevents partial data from being\ndiscarded, it makes it reasonable for a proxy to unconditionally abort\na download when requested by the user, and therefore reduces network\ntraffic.\n\nPolipo caches arbitrary partial instances in its in-memory cache.  It\nwill only store the initial segment of a partial instance (from its\nbeginning up to its first hole) in its on-disk cache, though.  In\neither case, it will attempt to use range requests to fetch the\nmissing data.\n\n@node POST and PUT, , Partial instances, Background\n@section Other requests\n@cindex GET request\n@cindex HEAD request\n@cindex PUT request\n@cindex POST request\n@cindex OPTIONS request\n@cindex DELETE request\n@cindex PROPFIND request\n\nThe previous sections pretend that there is only one kind of request\nin HTTP --- the @samp{GET} request.  In fact, there are some others.\n\nThe @samp{HEAD} request method retrieves data about an resource.  Polipo\ndoes not normally use @samp{HEAD}, but will fall back to using it for\nvalidation it if finds that a given server fails to cooperate with its\nstandard validation methods (@pxref{Cache transparency}).  Polipo will\ncorrectly reply to a client's @samp{HEAD} request.\n\nThe @samp{POST} method is used to request that the server should do\nsomething rather than merely sending an entity; it is usually used\nwith HTML forms that have an effect@footnote{HTML forms should use the\n@samp{GET} method when the form has no side-effect as this makes the\nresults cacheable.}.  The @samp{PUT} method is used to replace an\nresource with a different instance; it is typically used by web\npublishing applications.\n\n@samp{POST}, @samp{PUT}, @samp{OPTIONS} and @samp{DELETE} requests are handled by\nPolipo pretty much like @samp{GET} and @samp{HEAD}; however, for various\nreasons, some precautions must be taken.  In particular, any cached data\nfor the resource they refer to must be discarded, and they can never be\npipelined.\n\nFinally, HTTP/1.1 includes a convenient backdoor with the\n@samp{CONNECT} method.  For more information, please see\n@ref{Tunnelling connections}.\n\nPolipo does not currently handle the more exotic methods such as\n@samp{PROPFIND}.\n\n@node Running, Network, Background, Top\n@chapter Running Polipo\n\n@menu\n* Polipo Invocation::           Starting Polipo.\n* Browser configuration::       Configuring your browser.\n* Stopping::                    Stopping and refreshing Polipo.\n* Local server::                The local web server and web interface.\n@end menu\n\n@node Polipo Invocation, Browser configuration, Running, Running\n@section Starting Polipo\n@cindex invocation\n\nBy default, Polipo runs as a normal foreground job in a terminal in\nwhich it can log random ``How do you do?'' messages.  With the right\nconfiguration options, Polipo can run as a daemon.\n\nPolipo is run with the following command line:\n@example\n$ polipo [ -h ] [ -v ] [ -x ] [ -c @var{config} ] [ @var{var}=@var{val}... ]\n@end example\nAll flags are optional.  The flag @option{-h} causes Polipo to print a\nshort help message and to quit.  The flag @option{-v} causes Polipo to\nlist all of its configuration variables and quit.  The flag\n@option{-x} causes Polipo to purge its on-disk cache and then quit\n(@pxref{Purging}).  The flag @option{-c} specifies the configuration\nfile to use (by default @file{~/.polipo} or\n@file{/etc/polipo/config}).  Finally, Polipo's configuration can be\nchanged on the command line by assigning values to given configuration\nvariables.\n\n@menu\n* Configuring Polipo::          Plenty of options.\n* Daemon::                      Running in the background.\n* Logging::                     Funnelling status messages.\n@end menu\n\n@node Configuring Polipo, Daemon, Polipo Invocation, Polipo Invocation\n@subsection Configuration\n@cindex runtime configuration\n@cindex variable\n@cindex configuration variable\n@cindex configuration file\n\nThere is a number of variables that you can tweak in order to\nconfigure Polipo, and they should all be described in this manual\n(@pxref{Variable index}).  You can display the complete, most\nup-to-date list of configuration variables by using the @option{-v}\ncommand line flag or by accessing the ``current configuration'' page\nof Polipo's web interface (@pxref{Web interface}).  Configuration\nvariables can be set either on the command line or else in the\nconfiguration file given by the @option{-c} command-line flag.\n\nConfiguration variables are typed, and @option{-v} will display their\ntypes.  The type can be of one of the following:\n@itemize @bullet\n@item\n@samp{integer} or @samp{float}: a numeric value;\n\n@item\n@samp{boolean}: a truth value, one of @samp{true} or @samp{false};\n\n@item\n@samp{tristate}: one of @samp{false}, @samp{maybe} or @samp{true};\n\n@item\n@samp{4-state}, one of @samp{false}, @samp{reluctantly},\n@samp{happily} or @samp{true};\n\n@item\n@samp{5-state}, one of @samp{false}, @samp{reluctantly}, @samp{maybe},\n@samp{happily} or @samp{true};\n\n@item\n@samp{atom}, a string written within double quotes @samp{\"});\n\n@item\n@samp{list}, a comma-separated list of strings;\n\n@item\n@samp{intlist}, a comma-separated list of integers and ranges of\nintegers (of the form `@var{n}--@var{m}').\n@end itemize\n\nThe configuration file has a very simple syntax.  All blank lines are\nignored, as are lines starting with a hash sign @samp{#}.  Other lines\nmust be of the form\n@example\n@var{var} = @var{val}\n@end example\nwhere @var{var} is a variable to set and @var{val} is the value to set\nit to.\n\nIt is possible to change the configuration of a running polipo by\nusing the local configuration interface (@pxref{Web interface}).\n\n@node Daemon, Logging, Configuring Polipo, Polipo Invocation\n@subsection Running as a daemon\n@cindex daemon\n@cindex terminal\n@cindex pid\n@vindex daemonise\n@vindex pidFile\n\nIf the configuration variable @code{daemonise} is set to true, Polipo\nwill run as a daemon: it will fork and detach from its controlling\nterminal (if any).  The variable @code{daemonise} defaults to false.\n\nWhen Polipo is run as a daemon, it can be useful to get it to\natomically write its @emph{pid} to a file.  If the variable\n@code{pidFile} is defined, it should be the name of a file where\nPolipo will write its @emph{pid}.  If the file already exists when it\nis started, Polipo will refuse to run.\n\n@node Logging,  , Daemon, Polipo Invocation\n@subsection Logging\n@cindex logging\n@vindex logLevel\n@vindex logFile\n@vindex logFilePermissions\n@vindex logSyslog\n@vindex logFacility\n@vindex scrubLogs\n\nWhen it encounters a difficulty, Polipo will print a friendly message.\nThe location where these messages go is controlled by the\nconfiguration variables @code{logFile} and @code{logSyslog}.\nIf @code{logSyslog} is @code{true}, error messages go to the system log\nfacility given by @code{logFacility}.  If @code{logFile} is set, it is\nthe name of a file where all output will accumulate.  If @code{logSyslog}\nis @code{false} and @code{logFile} is empty, messages go to the error\noutput of the process (normally the terminal).\n\nThe variable @code{logFile} defaults to empty if @code{daemonise} is\nfalse, and to @samp{/var/log/polipo} otherwise.  The variable\n@code{logSyslog} defaults to @code{false}, and @code{logFacility}\ndefaults to @samp{user}.\n\nIf @code{logFile} is set, then the variable @code{logFilePermissions}\ncontrols the Unix permissions with which the log file will be created if\nit doesn't exist.  It defaults to 0640.\n\nThe amount of logging is controlled by the variable @code{logLevel}.\nPlease see the file @samp{log.h} in the Polipo sources for the\npossible values of @code{logLevel}.\n\nKeeping extensive logs on your users browsing habits is probably\na serere violation of their privacy.  If the variable @code{scrubLogs}\nis set, then Polipo will scrub most, if not all, private information\nfrom its logs.\n\n@node Browser configuration, Stopping, Polipo Invocation, Running\n@section Configuring your browser\n@cindex browser configuration\n@cindex user-agent configuration\n\nTelling your user-agent (web browser) to use Polipo is an operation\nthat depends on the browser.  Many user-agents will transparently use\nPolipo if the environment variable @samp{http_proxy} points at it;\ne.g.@:\n@example\n$ export http_proxy=http://localhost:8123/\n@end example\nNetscape Navigator, Mozilla, Mozilla Firefox, KDE's Konqueror and\nprobably other browsers require that you configure them manually\nthrough their @emph{Preferences} or @emph{Configure} menu.\n\nIf your user-agent sports such options, tell it to use persistent\nconnections when speaking to proxies, to speak HTTP/1.1 and to use\nHTTP/1.1 pipelining.\n\n@node Stopping, Local server, Browser configuration, Running\n@section Stopping Polipo and getting it to reload\n@cindex signals\n@cindex shutting down\n@cindex stopping\n\nPolipo will shut down cleanly if it receives @code{SIGHUP},\n@code{SIGTERM} or @code{SIGINT} signals; this will normally happen\nwhen a Polipo in the foreground receives a @code{^C} key press, when\nyour system shuts down, or when you use the @code{kill} command with\nno flags.  Polipo will then write-out all its in-memory data to disk\nand quit.\n\nIf Polipo receives the @code{SIGUSR1} signal, it will write out all\nthe in-memory data to disk (but won't discard them), reopen the log\nfile, and then reload the forbidden URLs file (@pxref{Forbidden}).\n\nFinally, if Polipo receives the @code{SIGUSR2} signal, it will write\nout all the in-memory data to disk and discard as much of the memory\ncache as possible.  It will then reopen the log file and reload the\nforbidden URLs file.\n\n@node Local server,  , Stopping, Running\n@section The local web server\n@vindex localDocumentRoot\n@vindex disableProxy\n@cindex web server\n@cindex local server\n\nPolipo includes a local web server, which is accessible on the same\nport as the one the proxy listens to.  Therefore, by default you can\naccess Polipo's local web server as @samp{http://localhost:8123/}.\n\nThe data for the local web server can be configured by setting\n@code{localDocumentRoot}, which defaults to\n@file{/usr/share/polipo/www/}.  Setting this variable to @samp{\"\"}\nwill disable the local server.\n\nPolipo assumes that the local web tree doesn't change behind its back.\nIf you change any of the local files, you will need to notify Polipo\nby sending it a @code{SIGUSR2} signal (@pxref{Stopping}).\n\nIf you use polipo as a publicly accessible web server, you might want\nto set the variable @code{disableProxy}, which will prevent it from\nacting as a web proxy.  (You will also want to set\n@code{disableLocalInterface} (@pxref{Web interface}), and perhaps run\nPolipo in a @emph{chroot} jail.)\n\n@menu\n* Web interface::               The web interface.\n@end menu\n\n@node Web interface,  , Local server, Local server\n@subsection The web interface\n@cindex runtime configuration\n@cindex web interface\n@vindex disableLocalInterface\n@vindex disableConfiguration\n@vindex disableServersList\n\nThe subtree of the local web space rooted at\n@samp{http://localhost:8123/polipo/} is treated specially: URLs under\nthis root do not correspond to on-disk files, but are generated by\nPolipo on-the-fly.  We call this subtree Polipo's @dfn{local web\ninterface}.\n\nThe page @samp{http://localhost:8123/polipo/config?} contains the\nvalues of all configuration variables, and allows setting most of them.\n\nThe page @samp{http://localhost:8123/polipo/status?} provides a summary\nstatus report about the running Polipo, and allows performing a number\nof actions on the proxy, notably flushing the in-memory cache.\n\nThe page @samp{http://localhost:8123/polipo/servers?} contains the list\nof known servers, and the statistics maintained about them\n(@pxref{Server statistics}).\n\nThe pages starting with @samp{http://localhost:8123/polipo/index?}\ncontain indices of the disk cache.  For example, the following page\ncontains the index of the cached pages from the server of some random\ncompany:\n@example\nhttp://localhost:8123/polipo/index?http://www.microsoft.com/\n@end example\nThe pages starting with\n@samp{http://localhost:8123/polipo/recursive-index?} contain recursive\nindices of various servers.  This functionality is disabled by\ndefault, and can be enabled by setting the variable\n@code{disableIndexing}.\n\nIf you have multiple users, you will probably want to disable the\nlocal interface by setting the variable @code{disableLocalInterface}.\nYou may also selectively control setting of variables, indexing and\nlisting known servers by setting the variables\n@code{disableConfiguration}, @code{disableIndexing} and\n@code{disableServersList}.\n\n@node Network, Caching, Running, Top\n@chapter Polipo and the network\n\n@menu\n* Client connections::          Speaking to clients\n* Contacting servers::          Contacting servers.\n* HTTP tuning::                 Tuning at the HTTP level.\n* Offline browsing::            Browsing with poor connectivity.\n* Server statistics::           Polipo keeps statistics about servers.\n* Server-side behaviour::       Tuning the server-side behaviour.\n* PMM::                         Poor Man's Multiplexing.\n* Forbidden::                   You can forbid some URLs.\n* DNS::                         How Polipo finds hosts.\n* Parent proxies::              Fetching data from other proxies.\n* Tuning POST and PUT::         Tuning POST and PUT requests.\n* Tunnelling connections::      Tunnelling foreign protocols and https.\n@end menu\n\n@node Client connections, Contacting servers, Network, Network\n@section Client connections\n\n@vindex proxyAddress\n@vindex proxyPort\n@vindex proxyName\n@vindex displayName\n@cindex address\n@cindex port\n@cindex IPv6\n@cindex proxy loop\n@cindex loop\n@cindex proxy name\n@cindex via\n@cindex loopback address\n@cindex security\n\nThere are three fundamental values that control how Polipo speaks to\nclients.  The variable @code{proxyAddress}, defines the IP address on\nwhich Polipo will listen; by default, its value is the @dfn{loopback\naddress} @code{\"127.0.0.1\"}, meaning that Polipo will listen on the\nIPv4 loopback interface (the local host) only.  By setting this\nvariable to a global IP address or to one of the special values\n@code{\"::\"} or @code{\"0.0.0.0\"}, it is possible to allow Polipo to\nserve remote clients.  This is likely to be a security hole unless you\nset @code{allowedClients} to a reasonable value (@pxref{Access control}).\n\nNote that the type of address that you specify for @code{proxyAddress}\nwill determine whether Polipo listens to IPv4 or IPv6.  Currently, the\nonly way to have Polipo listen to both protocols is to specify the\nIPv6 unspecified address (@code{\"::\"}) for @code{proxyAddress}.\n\nThe variable @code{proxyPort}, by default 8123, defines the TCP port\non which Polipo will listen.\n\nThe variable @code{proxyName}, which defaults to the host name of the\nmachine on which Polipo is running, defines the @dfn{name} of the\nproxy.  This can be an arbitrary string that should be unique among\nall instances of Polipo that you are running.  Polipo uses it in error\nmessages and optionally for detecting proxy loops (by using the\n@samp{Via} HTTP header, @pxref{Censoring headers}). Finally, the\n@code{displayName} variable specifies the name used in user-visible\nerror messages (default ``Polipo'').\n\n@menu\n* Access control::              Deciding who can connect.\n@end menu\n\n@node Access control,  , Client connections, Client connections\n@subsection Access control\n@vindex proxyAddress\n@vindex authCredentials\n@vindex authRealm\n@vindex allowedClients\n@cindex access control\n@cindex authentication\n@cindex loopback address\n@cindex security\n@cindex username\n@cindex password\n\nBy making it possible to have Polipo listen on a non-routable address\n(for example the loopback address @samp{127.0.0.1}), the variable\n@code{proxyAddress} provides a very crude form of @dfn{access\ncontrol}: the ability to decide which hosts are allowed to connect.\n\nA finer form of access control can be implemented by specifying\nexplicitly a number of client addresses or ranges of addresses\n(networks) that a client is allowed to connect from.  This is done\nby setting the variable @code{allowedClients}.\n\nEvery entry in @code{allowedClients} can be an IP address, for example\n@samp{134.157.168.57} or @samp{::1}.  It can also be a network\naddress, i.e.@: an IP address and the number of bits in the network\nprefix, for example @samp{134.157.168.0/24} or\n@samp{2001:660:116::/48}.  Typical uses of @samp{allowedClients}\nvariable include\n@example\nallowedClients = 127.0.0.1, ::1, 134.157.168.0/24, 2001:660:116::/48\n@end example\nor, for an IPv4-only version of Polipo,\n@example\nallowedClients = 127.0.0.1, 134.157.168.0/24\n@end example\n\nA different form of access control can be implemented by requiring\neach client to @dfn{authenticate}, i.e.@: to prove its identity before\nconnecting.  Polipo currently only implements the most insecure form\nof authentication, @dfn{HTTP basic authentication}, which sends\nusernames and passwords in clear over the network.  HTTP basic\nauthentication is required when the variable @code{authCredentials} is\nnot null; its value should be of the form @samp{username:password}.\n\nNote that both IP-based authentication and HTTP basic authentication\nare insecure: the former is vulnerable to IP address spoofing, the\nlatter to replay attacks.  If you need to access Polipo over the\npublic Internet, the only secure option is to have it listen over the\nloopback interface only and use an ssh tunnel (@pxref{Parent\nproxies})@footnote{It is not quite clear to me whether HTTP digest\nauthentication is worth implementing.  On the one hand, if implemented\ncorrectly, it appears to provide secure authentication; on the other\nhand, and unlike ssh or SSL, it doesn't make any attempt at ensuring\nprivacy, and its optional integrity guarantees are impossible to\nimplement without significantly impairing latency.}.\n\n@node Contacting servers, HTTP tuning, Client connections, Network\n@section Contacting servers\n\n@cindex multiple addresses\n@cindex IPv6\n@vindex useTemporarySourceAddress\n@vindex proxyOutgoingAddress\n\nA server can have multiple addresses, for example if it is\n@dfn{multihomed} (connected to multiple networks) or if it can speak\nboth IPv4 and IPv6.  Polipo will try all of a hosts addresses in turn;\nonce it has found one that works, it will stick to that address until\nit fails again.\n\nIf your host has multiple IP addresses, you can specify an IP address\nto use for outgoing connections with the @code{proxyOutgoingAddress}\nvariable.  If not specified (the default), it will be determined by\nthe host OS.\n\nIf connecting via IPv6 there is the possibility to use temporary\nsource addresses to increase privacy (RFC@tie{}3041). The variable\n@code{useTemporarySourceAddress} controls the use of temporary\naddresses for outgoing connections; if set to @code{true}\ntemporary addresses are preferred, if set to @code{false} static addresses\nare used and if set to @code{maybe} (the default) the operation\nsystem default is in effect. This setting is not available\non all operation systems.\n\n@menu\n* Allowed ports::               Where the proxy is allowed to connect.\n@end menu\n\n@node Allowed ports,  , Contacting servers, Contacting servers\n@subsection Allowed ports\n\n@cindex Allowed ports\n@cindex Forbidden ports\n@cindex ports\n@vindex allowedPorts\n\nA TCP service is identified not only by the IP address of the machine\nit is running on, but also by a small integer, the TCP @dfn{port} it\nis @dfn{listening} on.  Normally, web servers listen on port 80, but\nit is not uncommon to have them listen on different ports; Polipo's\ninternal web server, for example, listens on port 8123 by default.\n\nThe variable @code{allowedPorts} contains the list of ports that\nPolipo will accept to connect to on behalf of clients; it defaults to\n@samp{80-100, 1024-65535}.  Set this variable to @samp{1-65535} if your\nclients (and the web pages they consult!) are fully trusted.  (The\nvariable @code{allowedPorts} is not considered for tunnelled\nconnections; @pxref{Tunnelling connections}).\n\n@node HTTP tuning, Offline browsing, Contacting servers, Network\n@section Tuning at the HTTP level\n@cindex HTTP\n@cindex headers\n\n@menu\n* Tuning the HTTP parser::      Tuning parsing of HTTP headers.\n* Censoring headers::           Censoring HTTP headers.\n* Intermediate proxies::        Adjusting intermediate proxy behaviour.\n@end menu\n\n@node Tuning the HTTP parser, Censoring headers, HTTP tuning, HTTP tuning\n@subsection Tuning the HTTP parser\n@vindex laxHttpParser\n@vindex bigBufferSize\n\nAs a number of HTTP servers and CGI scripts serve incorrect HTTP\nheaders, Polipo uses a @emph{lax} parser, meaning that incorrect HTTP\nheaders will be ignored (a warning will be logged by default).  If the\nvariable @code{laxHttpParser} is not set (it is set by default),\nPolipo will use a @emph{strict} parser, and refuse to serve an\ninstance unless it could parse all the headers.\n\nWhen the amount of headers exceeds one chunk's worth (@pxref{Chunk\nmemory}), Polipo will allocate a @dfn{big buffer} in order to store\nthe headers.  The size of big buffers, and therefore the maximum\namount of headers Polipo can parse, is specified by the variable\n@code{bigBufferSize} (32@dmn{kB} by default).\n\n@node Censoring headers, Intermediate proxies, Tuning the HTTP parser, HTTP tuning\n@subsection Censoring headers\n@cindex privacy\n@cindex anonymity\n@cindex Referer\n@cindex cookies\n@vindex censorReferer\n@vindex censoredHeaders\n@vindex proxyName\n@vindex disableVia\n\nPolipo offers the option to censor given HTTP headers in both client\nrequests and server replies.  The main application of this feature is\nto very slightly improve the user's privacy by eliminating cookies and\nsome content-negotiation headers.\n\nIt is important to understand that these features merely make it\nslightly more difficult to gather statistics about the user's\nbehaviour.  While they do not actually prevent such statistics from\nbeing collected, they might make it less cost-effective to do so.\n\nThe general mechanism is controlled by the variable\n@code{censoredHeaders}, the value of which is a case-insensitive list\nof headers to unconditionally censor.  By default, it is empty, but\nI recommend that you set it to @samp{From, Accept-Language}.  Adding\nheaders such as @samp{Set-Cookie}, @samp{Set-Cookie2}, @samp{Cookie},\n@samp{Cookie2} or @samp{User-Agent} to this list will probably break\nmany web sites.\n\nThe case of the @samp{Referer}@footnote{HTTP contains many mistakes\nand even one spelling error.} header is treated specially because many\nsites will refuse to serve pages when it is not provided.  If\n@code{censorReferer} is @code{false} (the default), @samp{Referer}\nheaders are passed unchanged to the server.  If @code{censorReferer}\nis @code{maybe}, @samp{Referer} headers are passed to the server only\nwhen they refer to the same host as the resource being fetched.  If\n@code{censorReferer} is @code{true}, all @samp{Referer} headers are\ncensored.  I recommend setting @code{censorReferer} to @code{maybe}.\n\nAnother header that can have privacy implications is the @samp{Via}\nheader, which is used to specify the chain of proxies through which\na given request has passed.  Polipo will generate @samp{Via} headers\nif the variable @code{disableVia} is @code{false} (it is true by\ndefault).  If you choose to generate @samp{Via} headers, you may want\nto set the @code{proxyName} variable to some innocuous string\n(@pxref{Client connections}).\n\n@menu\n* Censor Accept-Language::      Why Accept-Language is evil.\n@end menu\n\n@node Censor Accept-Language,  , Censoring headers, Censoring headers\n@subsubsection Why censor Accept-Language\n@cindex negotiation\n@cindex content negotiation\n@cindex Accept-Language\n\nRecent versions of HTTP include a mechanism known as @dfn{content\nnegotiation} which allows a user-agent and a server to negotiate the\nbest representation (instance) for a given resource.  For example, a\nserver that provides both PNG and GIF versions of an image will serve\nthe PNG version to user-agents that support PNG, and the GIF version\nto Internet Explorer.\n\nContent negotiation requires that a client should send with every\nsingle request a number of headers specifying the user's cultural and\ntechnical preferences.  Most of these headers do not expose sensitive\ninformation (who cares whether your browser supports PNG?).  The\n@samp{Accept-Language} header, however, is meant to convey the user's\nlinguistic preferences.  In some cases, this information is sufficient\nto pinpoint with great precision the user's origins and even his\npolitical or religious opinions; think, for example, of the\nimplications of sending @samp{Accept-Language: yi} or @samp{ar_PS}.\n\nAt any rate, @samp{Accept-Language} is not useful.  Its design is\nbased on the assumption that language is merely another representation\nfor the same information, and @samp{Accept-Language} simply carries a\nprioritised list of languages, which is not enough to usefully\ndescribe a literate user's preferences.  A typical French user, for\nexample, will prefer an English-language original to a French\n(mis-)translation, while still wanting to see French language texts\nwhen they are original.  Such a situation cannot be described by the\nsimple-minded @samp{Accept-Language} header.\n\n@node Intermediate proxies,  , Censoring headers, HTTP tuning\n@subsection Adjusting intermediate proxy behaviour\n@vindex alwaysAddNoTransform\n@cindex intermediate proxies\n\nImplementors of intermediate caches (proxies) have found it useful to\nconvert the media type of certain entity bodies. A non-transparent\nproxy might, for example, convert between image formats in order to\nsave cache space or to reduce the amount of traffic on a slow link.\n\nIf @code{alwaysAddNoTransform} is true (it is false by default),\nPolipo will add a 'no-transform' cache control directive to all\noutgoing requests. This directive forbids (compliant) intermediate\ncaches from responding with an object that was compressed or\ntransformed in any way.\n\n@node Offline browsing, Server statistics, HTTP tuning, Network\n@section Offline browsing\n@vindex proxyOffline\n@cindex offline browsing\n@cindex browsing offline\n@cindex connectivity\n@cindex warning\n@cindex shift-click\n\nIn an ideal world, all machines would have perfect connectivity to the\nnetwork at all times and servers would never crash.  In the real\nworld, it may be necessary to avoid hitting the network and have\nPolipo serve stale objects from its cache.\n\nSetting @code{proxyOffline} to @code{true} prevents Polipo from\ncontacting remote servers, no matter what.  This setting is suitable\nwhen you have no network connection whatsoever.\n\nIf @code{proxyOffline} is false, Polipo's caching behaviour is\ncontrolled by a number of variables documented in @ref{Tweaking validation}.\n\n@node Server statistics, Server-side behaviour, Offline browsing, Network\n@section Server statistics\n@vindex serverExpireTime\n@cindex server statistics\n@cindex round-trip time\n@cindex transfer rate\n\nIn order to decide when to pipeline requests (@pxref{Pipelining}) and\nwhether to perform Poor Man's Multiplexing \n(@pxref{Poor Mans Multiplexing}), Polipo needs to keep statistics\nabout servers.  These include the server's ability to handle\npersistent connections, the server's ability to handle pipelined\nrequests, the round-trip time to the server, and the server's transfer\nrate.  The statistics are accessible from Polipo's web interface\n(@pxref{Web interface}). \n\nThe variable @samp{serverExpireTime} (default 1 day) specifies how\nlong such information remains valid.  If a server has not been\naccessed for a time interval of at least @code{serverExpireTime},\ninformation about it will be discarded.\n\nAs Polipo will eventually recover from incorrect information about a\nserver, this value can be made fairly large.  The reason why it exists\nat all is to limit the amount of memory used up by information about\nservers.\n\n@node Server-side behaviour, PMM, Server statistics, Network\n@section Tweaking server-side behaviour\n@vindex serverSlots\n@vindex serverSlots1\n@vindex serverMaxSlots\n@vindex smallRequestTime\n@vindex replyUnpipelineTime\n@vindex replyUnpipelineSize\n@vindex maxPipelineTrain\n@vindex pipelineAdditionalRequests\n@vindex maxSideBuffering\n@cindex small request\n@cindex large request\n@cindex breaking pipelines\n\nThe most important piece of information about a server is whether it\nsupports persistent connections.  If this is the case, Polipo will\nopen at most @code{serverSlots} connections to that server\n(@code{serverSlots1} if the server only implements HTTP/1.0), and\nattempt to pipeline; if not, Polipo will hit the server harder,\nopening up to @code{serverMaxSlots} connections.\n\nAnother use of server information is to decide whether to pipeline\nadditional requests on a connection that already has in-flight\nrequests.  This is controlled by the variable\n@code{pipelineAdditionalRequests}; if it is @code{false}, no\nadditional requests will be pipelined.  If it is @code{true},\nadditional requests will be pipelined whenever possible.  If it is\n@code{maybe} (the default), additional requests will only be pipelined\nfollowing @dfn{small} requests, where a small request one whose\ndownload is estimated to take no more than @code{smallRequestTime}\n(default 5@dmn{s}).\n\nSometimes, a request has been pipelined after a request that prompts a\nvery large reply from the server; when that happens, the pipeline\nneeds be broken in order to reduce latency.  A reply is @dfn{large}\nand will cause a pipeline to be broken if either its size is at least\n@code{replyUnpipelineSize} (default one megabyte) or else the server's\ntransfer rate is known and the body is expected to take at least\n@code{replyUnpipelineTime} to download (default 15@dmn{s}).\n\nThe variable @code{maxPipelineTrain} defines the maximum number of\nrequests that will be pipelined in a single write (default 10).\nSetting this variable to a very low value might (or might not) fix\ninteraction with some unreliable servers that the normal heuristics\nare unable to detect.\n\nThe variable @code{maxSideBuffering} specifies how much data will be\nbuffered in a PUT or POST request; it defaults to 1500 bytes.  Setting\nthis variable to 0 may cause some media players that abuse the HTTP\nprotocol to work.\n\n@node PMM, Forbidden, Server-side behaviour, Network\n@section Poor Man's Multiplexing\n@cindex Poor Man's Multiplexing\n@cindex multiplexing\n@vindex pmmSize\n@vindex pmmFirstSize\n\nBy default, Polipo does not use Poor Man's Multiplexing (@pxref{Poor\nMans Multiplexing}).  If the variable @code{pmmSize} is set to a\npositive value, Polipo will use PMM when speaking to servers that are\nknown to support pipelining.  It will request resources by segments of\n@code{pmmSize} bytes.  The first segment requested has a size of\n@code{pmmFirstSize}, which defaults to twice @code{pmmSize}.\n\nPMM is an intrinsically unreliable technique.  Polipo makes heroic\nefforts to make it at least usable, requesting that the server disable\nPMM when not useful (by using the @samp{If-Range} header) and\ndisabling it on its own if a resource turns out to be dynamic.\nNotwithstanding these precautions, unless the server\ncooperates@footnote{More precisely, unless CGI scripts cooperate.},\nyou will see failures when using PMM, which will usually result in\nblank pages and broken image icons; hitting @emph{Reload} on your\nbrowser will usually cause Polipo to notice that something went wrong\nand correct the problem.\n\n@node Forbidden, DNS, PMM, Network\n@section Forbidden and redirected URLs\n@cindex forbidden\n@cindex redirect\n@cindex web counter\n@cindex counter\n@cindex web bug\n@cindex bug\n@cindex advertisement\n@cindex web ad\n@cindex banner ad\n\nThe web contains advertisements that a user-agent is supposed to\ndownload together with the requested pages.  Not only do\nadvertisements pollute the user's brain, pushing them around takes\ntime and uses up network bandwidth.\n\nMany so-called content providers also track user activities by using\n@dfn{web bugs}, tiny embedded images that cause a server to log where\nthey are requested from.  Such images can be detected because they are\nusually uncacheable (@pxref{Cache transparency}) and therefore logged\nby Polipo by default.\n\nPolipo can be configured to prevent certain URLs from reaching the\nbrowser, either by returning a @emph{forbidden} error message to the\nuser, or by @emph{redirecting} such URLs to some other URL.\n\nSome content providers attempt to subvert content filtering as well as \nmalware scans by tunnelling their questionable content as https or other \nencrypted protocols. Other content providers are so clueless as to inject \ncontent from external providers into supposedly safe webpages.\nPolipo has therefore the ability to selectively block tunneled connections \nbased on hostname and port information. \n\n@menu\n* Internal forbidden list::     Specifying forbidden URLs.\n* External redirectors::        Using an external redirector.\n* Forbidden Tunnels::           Specifying hosts forbidden for tunnelling.\n@end menu\n\n@node Internal forbidden list, External redirectors, Forbidden, Forbidden\n@subsection Internal forbidden list\n@cindex forbidden\n@cindex redirect\n@vindex forbiddenFile\n@vindex forbiddenUrl\n@vindex forbiddenRedirectCode\n\nThe file pointed at by the variable @code{forbiddenFile} (defaults to\n@file{~/.polipo-forbidden} or @file{/etc/polipo/forbidden}, whichever\nexists) specifies the set of URLs that should never be fetched.  If\n@code{forbiddenFile} is a directory, it will be recursively searched\nfor files with forbidden URLs.\n\nEvery line in a file listing forbidden URLs can either be a domain\nname --- a string that doesn't contain any of @samp{/}, @samp{*} or\n@samp{\\} ---, or a POSIX extended regular expression.  Blank lines are\nignored, as are those that start with a hash sign @samp{#}.\n\nBy default, whenever it attempts to fetch a forbidden URL, the browser\nwill receive a @emph{403 forbidden} error from Polipo.  Some users\nprefer to have the browser display a different page or an image.\n\nIf @code{forbiddenUrl} is not null, it should represent a URL to which\nall forbidden URLs will be redirected.  The kind of redirection used\nis specified by @code{forbiddenRedirectCode}; if this is 302 (the\ndefault) the redirection will be marked as temporary, if 301 it will\nbe a permanent one.\n\n@node External redirectors, Forbidden Tunnels, Internal forbidden list, Forbidden\n@subsection External redirectors\n@cindex forbidden\n@cindex redirect\n@cindex redirector\n@cindex Squid-style redirector\n@cindex Adzapper\n@vindex redirector\n@vindex redirectorRedirectCode\n\nPolipo can also use an external process (a @dfn{Squid-style\nredirector}) to determine which URLs should be redirected.  The name\nof the redirector binary is determined from the variable\n@code{redirector}, and the kind of redirection generated is specified\nby @code{redirectorRedirectCode}, which should be 302 (the default) or\n301.\n\nFor example, to use Adzapper to redirect ads to an innocuous image, just set\n@example\nredirector = /usr/bin/adzapper\n@end example\n\n@node Forbidden Tunnels,  , External redirectors, Forbidden\n@subsection Forbidden Tunnels\n\nPolipo does by default allow tunnelled connections \n(@pxref{Tunnelling connections}), however sometimes it is desirable to \nblock connections selectively. \n\nBecause polipo does only pass through tunnelled connections filtering is \npossible based on hostname and port information only. Filtering based on \nprotocol specific types of information like pathname is not possible.\n\nObviously the web browser (and other software) must be configured to use \npolipo as tunneling proxy for this to work. The tunnelled traffic is neither\ntouched nor inspected in any way by polipo, thus encryption, certification \nand all other security and integrity guarantees implemented in the browser\nare not in any way affected.\n\nThe file pointed at by the variable @code{forbiddenTunnelsFile} (defaults to\n@file{~/.polipo-forbiddenTunnels} or @file{/etc/polipo/forbiddenTunnels}, \nwhichever exists) specifies the set of tunnel specifications that should\nbe blocked.\n\nEvery line in a file listing forbidden Tunnels can either be a domain\nname --- a string that doesn't contain any of @samp{/}, @samp{*} or\n@samp{\\} ---, or a POSIX extended regular expression.  Blank lines are\nignored, as are those that start with a hash sign @samp{#}.\n\nEntries in the form of regular expressions will be matched against\ntunnel reqeusts of the form @code{hostname:portnumber}.\n\nTunnelled and blocked connections will be logged if the configuration variable\n@code{logLevel} is set to a value such that @code{((logLevel & 0x80) !=0)} \n\nExample @code{forbiddenTunnelsFile} :\n@example\n# simple case, exact match of hostnames\nwww.massfuel.com\n\n# match hostname against regexp\n\\.hitbox\\.\n\n# match hostname and port against regexp\n# this will block tunnels to example.com but also  www.example.com\n# for ports in the range 600-999\n# Also watch for effects of 'tunnelAllowedPorts'\nexample.com\\:[6-9][0-9][0-9]\n\n# random examples\n\\.liveperson\\.\n\\.atdmt\\.com\n.*doubleclick\\.net\n.*webtrekk\\.de\n^count\\..*\n.*\\.offerstrategy\\.com\n.*\\.ivwbox\\.de\n.*adwords.*\n.*\\.sitestat\\.com\n\\.xiti\\.com\nwebtrekk\\..*\n@end example\n\n@node DNS, Parent proxies, Forbidden, Network\n@section The domain name service\n@cindex DNS\n@cindex name server\n@cindex gethostbyname\n@cindex resolver\n@cindex IPv6\n@vindex dnsMaxTimeout\n@vindex dnsUseGethostbyname\n@vindex dnsNameServer\n@vindex dnsNameServerPort\n@vindex dnsNegativeTtl\n@vindex dnsGethostbynameTtl\n@vindex dnsQueryIPv6\n\nThe low-level protocols beneath HTTP identify machines by IP\naddresses, sequences of four 8-bit integers such as\n@samp{199.232.41.10}@footnote{Or sequences of eight 16-bit integers if\nyou are running IPv6.}.  HTTP, on the other hand, and most application \nprotocols, manipulate host names, strings such as @samp{www.polipo.org}.\n\nThe @dfn{domain name service} (DNS) is a distributed database that\nmaps host names to IP addresses.  When an application wants to make\nuse of the DNS, it invokes a @dfn{resolver}, a local library or\nprocess that contacts remote name servers.\n\nPolipo usually tries to speak the DNS protocol itself rather than\nusing the system resolver@footnote{The Unix interface to the resolver\nis provided by the @code{gethostbyname}(3) library call\n(@code{getaddrinfo}(3) on recent systems), which was designed at\na time when a host lookup consisted in searching for one of five hosts\nin a @samp{HOSTS.TXT} file.  The @code{gethostbyname} call is\n@dfn{blocking}, meaning that all activity must cease while a host\nlookup is in progress.  When the call eventually returns, it doesn't\nprovide a @dfn{time to live} (TTL) value to indicate how long the\naddress may be cached.  For these reasons, @code{gethostbyname} is\nhardly useful for programs that need to contact more than a few hosts.\n(Recent systems replace @code{gethostbyname}(3) by\n@code{getaddrinfo}(3), which is reentrant.  While this removes one\nimportant problem that multi-threaded programs encounter, it doesn't\nsolve any of the other issues with @code{gethostbyname}.)}.  Its\nprecise behaviour is controlled by the value of\n@code{dnsUseGethostbyname}.  If @code{dnsUseGethostbyname} is\n@code{false}, Polipo never uses the system resolver.  If it is\n@code{reluctantly} (the default), Polipo tries to speak DNS and falls\nback to the system resolver if a name server could not be contacted.\nIf it is @code{happily}, Polipo tries to speak DNS, and falls back to\nthe system resolver if the host couldn't be found for any reason (this\nis not a good idea for shared proxies).  Finally, if\n@code{dnsUseGethostbyname} is @code{true}, Polipo never tries to speak\nDNS itself and uses the system resolver straight away (this is not\nrecommended).\n\nIf the internal DNS support is used, Polipo must be given a recursive\nname server to speak to.  By default, this information is taken from\nthe @samp{/etc/resolv.conf} file at startup; however, if you wish to use\na different name server, you may set the @code{dnsNameServer} and\noptionally @code{dnsNameServerPort} variables to an IP address and port\nnumber of a listening DNS server@footnote{While Polipo does its own\ncaching of DNS data, I recommend that you run a local caching name server.\nI am very happy with @uref{http://www.thekelleys.org.uk/dnsmasq/doc.html,,@code{dnsmasq}}.}.\n\nWhen the reply to a DNS request is late to come, Polipo will retry\nmultiple times using an exponentially increasing timeout.  The maximum\ntimeout used before Polipo gives up is defined by @code{dnsMaxTimeout}\n(default 60@dmn{s}); the total time before Polipo gives up on a DNS\nquery will be roughly twice @code{dnsMaxTimeout}.\n\nThe variable @code{dnsNegativeTtl} specifies the time during which\nnegative DNS information (information that a host @emph{doesn't}\nexist) will be cached; this defaults to 120@dmn{s}.  Increasing this\nvalue reduces both latency and network traffic but may cause a failed\nhost not to be noticed when it comes back up.\n\nThe variable @code{dnsQueryIPv6} specifies whether to query for IPv4\nor IPv6 addresses.  If @code{dnsQueryIPv6} is @code{false}, only IPv4\naddresses are queried.  If @code{dnsQueryIPv6} is @code{reluctantly},\nboth types of addresses are queried, but IPv4 addresses are preferred.\nIf @code{dnsQueryIPv6} is @code{happily} (the default), IPv6 addresses\nare preferred.  Finally, if @code{dnsQueryIPv6} is @code{true}, only\nIPv6 addresses are queried.\n\nIf the system resolver is used, the value @code{dnsGethostbynameTtl}\nspecifies the time during which a @code{gethostbyname} reply will be\ncached (default 5 minutes).\n\n@node Parent proxies, Tuning POST and PUT, DNS, Network\n@section Parent proxies\n\nPolipo will usually fetch instances directly from source servers as\nthis configuration minimises latency.  In some cases, however, it may\nbe useful to have Polipo fetch instances from a @dfn{parent} proxy.\n\nPolipo can use two protocols to speak to a parent proxy: HTTP and\nSOCKS.  When configured to use both HTTP and SOCKS proxying, Polipo\nwill contact an HTTP proxy over SOCKS --- in other words, SOCKS is\nconsidered as being at a lower (sub)layer than HTTP.\n\n@menu\n* HTTP parent proxies::         Using an HTTP parent proxy.\n* SOCKS parent proxies::        Using a SOCKS4a parent proxy.\n@end menu\n\n@node HTTP parent proxies, SOCKS parent proxies, Parent proxies, Parent proxies\n@subsection HTTP parent proxies\n@vindex parentProxy\n@vindex parentAuthCredentials\n@cindex parent proxy\n@cindex upstream proxy\n@cindex firewall\n@cindex authentication\n\nThe variable @code{parentProxy} specifies the hostname and port number\nof an HTTP parent proxy; it should have the form @samp{host:port}.\n\nIf the parent proxy requires authorisation, the username and password\nshould be specified in the variable @code{parentAuthCredentials} in\nthe form @samp{username:password}.  Only @emph{Basic} authentication\nis supported, which is vulnerable to replay attacks.\n\nThe main application of the parent proxy support is to cross\nfirewalls.  Given a machine, say @code{trurl}, with unrestricted\naccess to the web, the following evades a firewall by using an\nencrypted compressed @code{ssh} link:\n@example\n$ ssh -f -C -L 8124:localhost:8123 trurl polipo\n$ polipo parentProxy=localhost:8124\n@end example\n\n@node SOCKS parent proxies,  , HTTP parent proxies, Parent proxies\n@subsection SOCKS parent proxies\n@cindex SOCKS\n@vindex socksParentProxy\n@vindex socksAuthCredentials\n@vindex socksProxyType\n\nThe variable @code{socksParentProxy} specifies the hostname and port\nnumber of a SOCKS parent proxy; it should have the form\n@samp{host:port}.  The variant of the SOCKS protocol being used is\ndefined by @code{socksProxyType}, which can be either @samp{socks4a}\nor @samp{socks5}; the latter value specifies ``SOCKS5 with\nhostnames'', and is the default.\n\nThe variable @code{socksAuthCredentials} can be used if your SOCKS\nproxy requires authentication.  For SOCKS4 and 4a, it is just\na username; for SOCKS5 it is of the form @samp{username:password}.\n\nThe main application of the SOCKS support is to use\n@uref{http://tor.eff.org,,Tor} to evade overly restrictive or\nmisconfigured firewalls.  Assuming you have a Tor client running on\nthe local host listening on the default port (9050), the following\nuses Tor for all outgoing HTTP traffic:\n@example\n$ polipo socksParentProxy=localhost:9050\n@end example\n\n@node Tuning POST and PUT, Tunnelling connections, Parent proxies, Network\n@section Tuning POST and PUT requests\n@cindex POST request\n@cindex PUT request\n@vindex expectContinue\n\nThe main assumption behind the design of the HTTP protocol is that\nrequests are idempotent: since a request can be repeated by a client,\na server is allowed to drop a connection at any time.  This fact, more\nthan anything else, explains the amazing scalability of the protocol.\n\nThis assumption breaks down in the case of POST requests.  Indeed, a\nPOST request usually causes some action to be performed (a page to be\nprinted, a significant amount of money to be transferred from your\nbank account, or, in Florida, a vote to be registered), and such a\nrequest should not be repeated.\n\nThe only solution to this problem is to reserve HTTP to idempotent\nactivities, and use reliable protocols for action-effecting ones.\nNotwithstanding that, HTTP/1.1 makes a weak attempt at making POST\nrequests slightly more reliable and efficient than they are in\nHTTP/1.0.\n\nWhen speaking to an HTTP/1.1 server, an HTTP client is allowed to\nrequest that the server check @emph{a priori} whether it intends to\nhonour a POST request.  This is done by sending @dfn{an expectation},\na specific header with the request, @samp{Expect: 100-continue}, and\nwaiting for either an error message or a @samp{100 Continue} reply\nfrom the server.  If the latter arrives, the client is welcome to send\nthe rest of the POST request@footnote{This, of course, is only part of\nthe story.  Additionally, the server is not required to reply with\n@samp{100 Continue}, hence the client must implement a timeout.\nFurthermore, according to the obsolete RFC2068, the server is\nallowed to spontaneously send @samp{100 Continue}, so the client must\nbe prepared to ignore such a reply at any time.}.\n\nPolipo's behaviour w.r.t.@: client expectations is controlled by the\nvariable @code{expectContinue}.  If this variable is false, Polipo\nwill never send an expectation to the server; if a client sends an\nexpectation, Polipo will fail the expectation straight away, causing\nthe client (if correctly implemented) to retry with no expectation.\nIf @code{expectContinue} is @code{maybe} (the default), Polipo will\nbehave in a standards-compliant manner: it will forward expectations\nto the server when allowed to do so, and fail client expectations\notherwise.  Finally, if @code{expectContinue} is @code{true}, Polipo\nwill always send expectations when it is reasonable to do so; this\nviolates the relevant standards and will break some websites, but\nmight decrease network traffic under some circumstances.\n\n@node Tunnelling connections,  , Tuning POST and PUT, Network\n@section Tunnelling connections\n@cindex tunnel\n@cindex tunnelling proxy\n@cindex https\n@cindex HTTP/SSL\n@cindex rsync\n@cindex CONNECT\n@vindex tunnelAllowedPorts\n\nPolipo is an HTTP proxy; it proxies HTTP traffic, and clients using\nother protocols should either establish a direct connection to the\nserver or use an @emph{ad hoc} proxy.\n\nIn many circumstances, however, it is not possible to establish\na direct connection to the server, for example due to mis-configured\nfirewalls or when trying to access the IPv4 Internet from an IPv6-only\nhost.  In such situations, it is possible to have Polipo behave as\na @emph{tunnelling} proxy --- a proxy that merely forwards traffic\nbetween the client and the server without understanding it.  Polipo\nenters tunnel mode when the client requests it by using the HTTP\n@samp{CONNECT} method.\n\nMost web browsers will use this technique for HTTP over SSL if\nconfigured to use Polipo as their `https proxy'.  More generally, the\nauthor has successfully used it to cross mis-configured firewalls\nusing OpenSSH, rsync, Jabber, IRC, etc.\n\nThe variable @code{tunnelAllowedPorts} specifies the set of ports that\nPolipo will accept to tunnel traffic to.  It defaults to allowing ssh,\nHTTP, https, rsync, IMAP, imaps, POP, pops, Jabber, CVS and Git traffic.\n\nIt is possible to selectively block tunneled connections, \n@pxref{Forbidden Tunnels}\n\n@node Caching, Memory usage, Network, Top\n@chapter Caching\n\n@menu\n* Cache transparency::          Fresh and stale data.\n* Memory cache::                The in-memory cache.\n* Disk cache::                  The on-disk cache.\n@end menu\n\n@node Cache transparency, Memory cache, Caching, Caching\n@section Cache transparency and validation\n@cindex transparent cache\n@cindex cache transparency\n@cindex out-of-date instances\n@cindex validation\n@cindex revalidation\n@cindex expire\n@cindex stale\n@cindex fresh\n\nIf resources on a server change, it is possible for a cached instance\nto become out-of date.  Ideally, a cache would be perfectly\n@dfn{transparent}, meaning that it never serves an out-of-date\ninstance; in a universe with a finite speed of signal propagation,\nhowever, this ideal is impossible to achieve.\n\nIf a caching proxy decides that a cached instance is new enough to\nlikely still be valid, it will directly serve the instance to the\nclient; we then say that the cache decided that the instance is\n@dfn{fresh}.  When an instance is @dfn{stale} (not fresh), the cache\nwill check with the upstream server whether the resource has changed;\nwe say that the cached instance is being @dfn{revalidated}.\n\nIn HTTP/1.1, responsibility for revalidation is shared between the\nclient, the server and the proxy itself.  The client can override\nrevalidation policy by using the @samp{Cache-Control}\nheader@footnote{Or the obsolete @samp{Pragma} header.}; for example,\nsome user-agents will request end-to-end revalidation in this way when\nthe user shift-clicks on @emph{reload}.  The server may choose to\nspecify revalidation policy by using the @samp{Expires} and\n@samp{Cache-Control} headers.  As to the proxy, it needs to choose a\nrevalidation policy for instances with neither server- nor client-side\ncache control information.  Of course, nothing (except the HTTP/1.1\nspec, but that is easily ignored) prevents a proxy from overriding the\nclient's and server's cache control directives.\n\n@menu\n* Tuning validation::           Tuning Polipo's validation behaviour.\n* Tweaking validation::         Further tweaking of validation.\n@end menu\n\n@node Tuning validation, Tweaking validation, Cache transparency, Cache transparency\n@subsection Tuning validation behaviour\n@cindex age\n@vindex maxAge\n@vindex maxAgeFraction\n@vindex maxExpiresAge\n@vindex maxNoModifiedAge\n\nPolipo's revalidation behaviour is controlled by a number of\nvariables.  In the following, an resource's @dfn{age} is the time since\nit was last validated, either because it was fetched from the server\nor because it was revalidated.\n\nThe policy defining when cached instances become stale in the absence\nof server-provided information is controlled by the variables\n@code{maxAge}, @code{maxAgeFraction}, @code{maxExpiresAge} and\n@code{maxNoModifiedAge}.  If an instance has an @samp{Expires} header,\nit becomes stale at the date given by that header, or when its age\nbecomes larger than @code{maxExpiresAge}, whichever happens first.  If\nan instance has no @samp{Expires} header but has a @samp{LastModified}\nheader, it becomes stale when its age reaches either\n@code{maxAgeFraction} of the time since it was last modified or else\nthe absolute value @code{maxAge}, whichever happens first.  Finally,\nif an instance has neither @samp{Expires} nor @samp{Last-Modified}, it\nwill become stale when its age reaches @code{maxNoModifiedAge}.\n\n@node Tweaking validation,  , Tuning validation, Cache transparency\n@subsection Further tweaking of validation behaviour\n@cindex uncachable\n@cindex vary\n@vindex cacheIsShared\n@vindex mindlesslyCacheVary\n@vindex uncachableFile\n@vindex dontCacheCookies\n@vindex dontCacheRedirects\n@vindex dontTrustVaryETag\n\nIf @code{cacheIsShared} is false (it is true by default), Polipo will\nignore the server-side @samp{Cache-Control} directives @samp{private},\n@samp{s-maxage} and @samp{proxy-must-revalidate}.  This is highly\ndesirable behaviour when the proxy is used by just one user, but might\nbreak some sites if the proxy is shared.\n\nWhen connectivity is very poor, the variable @code{relaxTransparency}\ncan be used to cause Polipo to serve stale instances under some\ncircumstances.  If @code{relaxTransparency} is @code{false} (the\ndefault), all stale instances are validated (@pxref{Cache\ntransparency}), and failures to connect are reported to the client.\nThis is the default mode of operation of most other proxies, and the\nleast likely to surprise the user.\n\nIf @code{relaxTransparency} is @code{maybe}, all stale instances are\nstill validated, but a failure to connect is only reported as an error\nif no data is available in the cache.  If a connection fails and stale\ndata is available, it is served to the client with a suitable HTTP/1.1\n@samp{Warning} header.  Current user-agents do not provide visible\nindication of such warnings, however, and this setting will typically\ncause the browser to display stale data with no indication that\nanything went wrong.  It is useful when you are consulting a live web\nsite but don't want to be bothered with failed revalidations.\n\nIf @code{relaxTransparency} is @code{true}, missing data is fetched\nfrom remote servers, but stale data are unconditionally served with no\nvalidation.  Client-side @samp{Cache-Control} directives are still\nhonoured, which means that you can force an end-to-end revalidation\nfrom the browser's interface (typically by shift-clicking on\n``reload'').  This setting is only useful if you have very bad network\nconnectivity or are consulting a very slow web site or one that\nprovides incorrect cache control information@footnote{This is for\nexample the case of @code{www.microsoft.com}, and also of websites\ngenerated by a popular Free content management system written in\nPython.} and are willing to manually revalidate pages that you suspect\nare stale.\n\nIf @code{mindlesslyCacheVary} is true, the presence of a @samp{Vary}\nheader (which indicates that content-negotiation occurred,\n@pxref{Censor Accept-Language}) is ignored, and cached negotiated\ninstances are mindlessly returned to the client.  If it is false (the\ndefault), negotiated instances are revalidated on every client\nrequest.\n\nUnfortunately, a number of servers (most notably some versions of\nApache's @code{mod_deflate} module) send objects with a @samp{ETag}\nheader that will confuse Polipo in the presence of a @samp{Vary}\nheader.  Polipo will make a reasonable check for consistency if\n@samp{dontTrustVaryETag} is set to @samp{maybe} (the default); it will\nsystematically ignore @samp{ETag} headers on objects with @samp{Vary}\nheaders if it is set to @samp{true}.\n\nA number of websites incorrectly mark variable resources as cachable;\nsuch issues can be worked around in polipo by manually marking given\ncategories of objects as uncachable.  If @code{dontCacheCookies} is\ntrue, all pages carrying HTTP cookies will be treated as uncachable.\nIf @code{dontCacheRedirects} is true, all redirects (301 and 302) will\nbe treated as uncachable.  Finally, if everything else fails, a list\nof uncachable URLs can be given in the file specified by\n@code{uncachableFile}, which has the same format as the\n@code{forbiddenFile} (@pxref{Internal forbidden list}).  If not\nspecified, its location defaults to @samp{~/.polipo-uncachable} or\n@samp{/etc/polipo/uncachable}, whichever exists.\n\n@node Memory cache, Disk cache, Cache transparency, Caching\n@section The in-memory cache\n\nThe in-memory cache consists of a list of HTTP and DNS objects\nmaintained in least-recently used order.  An index to the in-memory\ncache is maintained as a (closed) hash table.\n\nWhen the in-memory cache grows beyond a certain size (controlled by a\nnumber of variables, @pxref{Memory usage}), or when a hash table\ncollision occurs, resources are written out to disk.\n\n@node Disk cache,  , Memory cache, Caching\n@section The on-disk cache\n@cindex filesystem\n@cindex NFS\n@vindex diskCacheRoot\n@vindex maxDiskEntries\n@vindex diskCacheWriteoutOnClose\n@vindex diskCacheFilePermissions\n@vindex diskCacheDirectoryPermissions\n@vindex maxDiskCacheEntrySize\n\nThe on-disk cache consists in a filesystem subtree rooted at\na location defined by the variable @code{diskCacheRoot}, by default\n@code{\"/var/cache/polipo/\"}.  This directory should normally be\nwriteable, readable and seekable by the user running Polipo.  While it\nis best to use a local filesystem for the on-disk cache, a NFSv3- or\nAFS-mounted filesystem should be safe in most implementations.  Do not\nuse NFSv2, as it will cause cache corruption @footnote{Polipo assumes\nthat @samp{open(O_CREAT | O_EXCL)} works reliably.}.\n\nIf @code{diskCacheRoot} is an empty string, no disk cache is used.\n\nThe value @code{maxDiskEntries} (32 by default) is the absolute\nmaximum of file descriptors held open for on-disk objects.  When this\nlimit is reached, Polipo will close descriptors on\na least-recently-used basis.  This value should be set to be slightly\nlarger than the number of resources that you expect to be live at\na single time; defining the right notion of liveness is left as an\nexercise for the interested reader.\n\nThe value @code{diskCacheWriteoutOnClose} (64@dmn{kB} by default) is\nthe amount of data that Polipo will write out when closing a disk\nfile.  Writing out data when closing a file can avoid subsequently\nreopening it, but causes unnecessary work if the instance is later\nsuperseded.\n\nThe integers @code{diskCacheDirectoryPermissions} and\n@code{diskCacheFilePermissions} are the Unix filesystem permissions\nwith which files and directories are created in the on-disk cache;\nthey default to @samp{0700} and @samp{0600} respectively.\n\nThe variable @code{maxDiskCacheEntrySize} specifies the maximum size,\nin bytes, of an instance that is stored in the on-disk cache.  If set\nto -1 (the default), all objects are stored in the on-disk cache,\n\n@menu\n* Asynchronous writing::        Writing out data when idle.\n* Purging::                     Purging the on-disk cache.\n* Disk format::                 Format of the on-disk cache.\n* Modifying the on-disk cache::\n@end menu\n\n@node Asynchronous writing, Purging, Disk cache, Disk cache\n@subsection Asynchronous writing\n@vindex idleTime\n@vindex maxObjectsWhenIdle\n@vindex maxWriteoutWhenIdle\n\nWhen Polipo runs out of memory (@pxref{Limiting memory usage}), it\nwill start discarding instances from its memory cache.  If a disk\ncache has been configured, it will write out any instance that it\ndiscards.  Any memory allocation that prompted the purge must then\nwait for the write to complete.\n\nIn order to avoid the latency hit that this causes, Polipo will\npreemptively write out instances to the disk cache whenever it is\nidle.  The integer @code{idleTime} specifies the time during which\nPolipo will remain idle before it starts writing out random objects to\nthe on-disk cache; this value defaults to 20@dmn{s}.  You may want to\ndecrease this value for a busy cache with little memory, or increase\nit if your cache is often idle and has a lot of memory.\n\nThe value @code{maxObjectsWhenIdle} (default 32) specifies the maximum\nnumber of instances that an idle Polipo will write out without\nchecking whether there's any new work to do.  The value\n@code{maxWriteoutWhenIdle} specifies the maximum amount of data\n(default 64@dmn{kB}) that Polipo will write out without checking for\nnew activity.  Increasing these values will make asynchronous\nwrite-out slightly faster, at the cost of possibly increasing Polipo's\nlatency in some rare circumstances.\n\n@node Purging, Disk format, Asynchronous writing, Disk cache\n@subsection Purging the on-disk cache\n@cindex purging\n@vindex diskCacheUnlinkTime\n@vindex diskCacheTruncateTime\n@vindex diskCacheTruncateSize\n@vindex preciseExpiry\n\nPolipo never removes a file in its on-disk cache, except when it finds\nthat the instance that it represents has been superseded by a newer\nversion.  In order to keep the on-disk cache from growing without\nbound, it is necessary to @dfn{purge} it once in a while.  Purging the\ncache typically consists in removing some files, truncating large\nfiles (@pxref{Partial instances}) or moving them to off-line storage.\n\nPolipo itself can be used to purge its on-disk cache; this is done by\ninvoking Polipo with the @option{-x} flag.  This can safely be done\nwhen Polipo is running (@pxref{Modifying the on-disk cache}).\n\nFor a purge to be effective, it is necessary to cause Polipo to\nwrite-out its in-memory cache to disk (@pxref{Stopping}).\nAdditionally, Polipo will not necessarily notice the changed files\nuntil it attempts to access them; thus, you will want it to discard\nits in-memory cache after performing the purge.  The safe way to\nperform a purge is therefore:\n@example\n$ kill -USR1 @var{polipo-pid}\n$ sleep 1\n$ polipo -x\n$ kill -USR2 @var{polipo-pid}\n@end example\n\nThe behaviour of the @option{-x} flag is controlled by three\nconfiguration variables.  The variable @code{diskCacheUnlinkTime}\nspecifies the time during which an on-disk entry should remain unused\nbefore it is eligible for removal; it defaults to 32 days.  \n\nThe variable @code{diskCacheTruncateTime} specifies the time for which\nan on-disk entry should remain unused before it is eligible for\ntruncation; it defaults to 4 days and a half.  The variable\n@code{diskCacheTruncateSize} specifies the size at which files are\ntruncated after they have not been accessed for\n@code{diskCacheTruncateTime}; it defaults to 1@dmn{MB}.\n\nUsually, Polipo uses a file's modification time in order to determine\nwhether it is old enough to be expirable.  This heuristic can be\ndisabled by setting the variable @code{preciseExpiry} to true.\n\n@node Disk format, Modifying the on-disk cache, Purging, Disk cache\n@subsection Format of the on-disk cache\n@vindex DISK_CACHE_BODY_OFFSET\n@cindex on-disk file\n@cindex on-disk cache\n\nThe on-disk cache consists of a collection of files, one per instance.\nThe format of an on-disk resource is similar to that of an HTTP\nmessage: it starts with an HTTP status line, followed by HTTP headers,\nfollowed by a blank line (@samp{\\r\\n\\r\\n}).  The blank line is\noptionally followed by a number of binary zeroes.  The body of the\ninstance follows.\n\nThe headers of an on-disk file have a few minor differences with HTTP\nmessages.  Obviously, there is never a @samp{Transfer-Encoding} line.\nA few additional headers are used by Polipo for its internal\nbookkeeping:\n@itemize\n@item \n@samp{X-Polipo-Location}: this is the URL of the resource stored in this\nfile.  This is always present.\n\n@item\n@samp{X-Polipo-Date}: this is Polipo's estimation of the date at which\nthis instance was last validated, and is used for generating the\n@samp{Age} header of HTTP messages.  This is optional, and only stored\nif different from the instance's date.\n\n@item\n@samp{X-Polipo-Access}: this is the date when the instance was last\naccessed by Polipo, and is used for cache purging (@pxref{Purging}).\nThis is optional, and is absent if the instance was never accessed.\n\n@item\n@samp{X-Polipo-Body-Offset}: the presence of this line indicates that\nthe blank line following the headers is followed by a number of zero\nbytes.  Its value is an integer, which indicates the offset since the\nbeginning of the file at which the instance body actually starts.\nThis line is optional, and if absent the body starts immediately after\nthe blank line.\n\n@end itemize\n\n@node Modifying the on-disk cache,  , Disk format, Disk cache\n@subsection Modifying the on-disk cache\n@cindex on-disk cache\n\nIt is safe to modify the on-disk cache while Polipo is running as long\nas no file is ever modified in place.  More precisely, the only safe\noperations are to unlink (remove, delete) files in the disk cache, or\nto atomically add new files to the cache (by performing an exclusive\nopen, or by using one of the @samp{link} or @samp{rename} system\ncalls).  It is @emph{not} safe to truncate a file in place.\n\n@node Memory usage, Copying, Caching, Top\n@chapter Memory usage\n@cindex memory\n\nPolipo uses two distinct pools of memory, the @dfn{chunk pool} and\nthe @dfn{malloc pool}.\n\n@menu\n* Chunk memory::                Chunk memory.\n* Malloc memory::               Malloc memory.\n* Limiting memory usage::       Limiting Polipo's memory usage.\n@end menu\n\n@node Chunk memory, Malloc memory, Memory usage, Memory usage\n@section Chunk memory\n\n@vindex CHUNK_SIZE\n@vindex MALLOC_CHUNKS\n@cindex chunk\n@cindex memory\n\nMost of the memory used by Polipo is stored in chunks, fixed-size\nblocks of memory; the size of a chunk is defined by the compile-time\nconstant @code{CHUNK_SIZE}, and defaults to 4096 bytes on 32-bit\nplatforms, 8192 on 64-bit ones.  Chunks are used for storing object\ndata (bodies of instances) and for temporary I/O buffers.  Increasing\nthe chunk size increases performance somewhat, but at the cost of\nlarger granularity of allocation and hence larger memory usage.\n\nBy default, Polipo uses a hand-crafted memory allocator based on\n@code{mmap}(2) (@code{VirtualAlloc} under Windows) for allocating\nchunks; while this is very slightly faster than the stock memory\nallocator, its main benefit is that it limits memory fragmentation.\nIt is possible to disable the chunk allocator, and use\n@code{malloc}(3) for all memory allocation, by defining\n@code{MALLOC_CHUNKS} at compile time; this is probably only useful for\ndebugging.\n\nThere is one assumption made about @code{CHUNK_SIZE}:\n@code{CHUNK_SIZE} multiplied by the number of bits in an\n@code{unsigned long} (actually in a @code{ChunkBitmap} --- see\n@file{chunk.c}) must be a multiple of the page size, which is 4096 on\nmost systems (8192 on Alpha, and apparently 65536 on Windows).\n\nAs all network I/O will be performed in units of one to two chunks,\n@code{CHUNK_SIZE} should be at least equal to your network interface's\nMTU (typically 1500 bytes).  Additionally, as much I/O will be done at\n@code{CHUNK_SIZE}-aligned addresses, @code{CHUNK_SIZE} should ideally\nbe a multiple of the page size.\n\nIn summary, 2048, 4096, 8192 and 16384 are good choices for\n@code{CHUNK_SIZE}.\n\n@node Malloc memory, Limiting memory usage, Chunk memory, Memory usage\n@section Malloc allocation\n@cindex malloc\n@cindex memory\n\nPolipo uses the standard @code{malloc}(3) memory allocator for\nallocating small data structures (up to 100 bytes), small strings and\natoms (unique strings).\n\n@node Limiting memory usage,  , Malloc memory, Memory usage\n@section Limiting Polipo's memory usage\n@cindex limiting memory\n@cindex memory\n\nPolipo is designed to work well when given little memory, but will\nhappily scale to larger configurations.  For that reason, you need to\ninform it of the amount of memory it can use.\n\n@menu\n* Limiting chunk usage::        Discard objects when low on chunks.\n* Limiting object usage::       Limit the number of objects.\n* OS usage limits::             Don't impose OS limits.\n@end menu\n\n@node Limiting chunk usage, Limiting object usage, Limiting memory usage, Limiting memory usage\n@subsection Limiting chunk usage\n\n@vindex chunkHighMark\n@vindex chunkCriticalMark\n@vindex chunkLowMark\n@vindex CHUNK_SIZE\n@cindex memory\n@cindex chunk\n\nYou can limit Polipo's usage of chunk memory by setting\n@code{chunkHighMark} and @code{chunkLowMark}.\n\nThe value @code{chunkHighMark} is the absolute maximum number of bytes\nof allocated chunk memory.  When this value is reached, Polipo will try\nto purge objects from its in-memory cache; if that fails to free memory,\nPolipo will start dropping connections.  This value defaults to\n24@dmn{MB} or one quarter of the machine's physical memory, whichever is\nless.\n\nWhen chunk usage falls back below @code{chunkLowMark}, Polipo will\nstop discarding in-memory objects.  The value\n@code{chunkCriticalMark}, which should be somewhere between\n@code{chunkLowMark} and @code{chunkHighMark}, specifies the value\nabove which Polipo will make heroic efforts to free memory, including\npunching holes in the middle of instances, but without dropping\nconnections.\n\nUnless set explicitly, both @code{chunkLowMark} and\n@code{chunkCriticalMark} are computed automatically from\n@code{chunkHighMark}.\n\n@node Limiting object usage, OS usage limits, Limiting chunk usage, Limiting memory usage\n@subsection Limiting object usage\n\n@vindex objectHighMark\n@vindex publicObjectLowMark\n@vindex objectHashTableSize\n\nBesides limiting chunk usage, it is possible to limit Polipo's memory\nusage by bounding the number of objects it keeps in memory at any given\ntime.  This is done with @code{objectHighMark} and\n@code{publicObjectLowMark}.\n\nThe value @code{objectHighMark} is the absolute maximum of objects\nheld in memory (including resources and server addresses).  When the\nnumber of in-memory objects that haven't been superseded yet falls\nbelow @code{publicObjectLowMark}, Polipo will stop writing out objects\nto disk (superseded objects are discarded as soon as possible).\n\nOn 32-bit architectures, every object costs 108 bytes of memory, plus\nstorage for every globally unique header that is not handled specially\n(hopefully negligible), plus an overhead of one word (4 bytes) for\nevery chunk of data in the object.\n\nYou may also want to change @code{objectHashTableSize}.  This is the\nsize of the hash table used for holding objects; it should be a power\nof two and defaults to eight times @code{objectHighMark}.  Increasing\nthis value will reduce the number of objects being written out to disk\ndue to hash table collisions.  Every hash table entry costs one word.\n\n@node OS usage limits,  , Limiting object usage, Limiting memory usage\n@subsection OS usage limits\n@cindex usage limit\n@cindex ulimit\n@cindex OOM killer\n\nMany operating systems permit limiting a process' memory usage by\nsetting a @dfn{usage limit}; on most Unix-like systems, this is done\nwith the @option{-v} option to the @command{ulimit} command.\nTypically, the effect is to cause calls to the @code{malloc} and\n@code{mmap} library functions to fail.\n\nPolipo will usually react gracefully to failures to allocate\nmemory@footnote{There are exactly three places in the code where\nPolipo will give up and exit if out of memory; all three are extremely\nunlikely to happen in practice.}.  Nonetheless, you should avoid using\nOS limits to limit Polipo's memory usage: when it hits an OS limit,\nPolipo cannot allocate the memory needed to schedule recovery from the\nout-of-memory condition, and has no choice other than to drop a\nconnection.\n\nUnfortunately, some operating system kernels (notably certain Linux\nreleases) fail to fail an allocation if no usage limit is given;\ninstead, they either crash when memory is exhausted, or else start\nkilling random processes with no advance warning@footnote{How I wish\nfor a @samp{SIGXMEM} signal.}.  On such systems, imposing an\n(unrealistically large) usage limit on Polipo is the safe thing to do.\n\n@node Copying, Variable index, Memory usage, Top\n@unnumbered Copying\nYou are allowed to do anything you wish with Polipo as long as you\ndon't deny my right to be recognised as its author and you don't blame\nme if anything goes wrong.\n\nMore formally, Polipo is distributed under the following terms:\n\n@quotation\nCopyright @copyright{} 2003--2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n@end quotation\nThe last sentence is what happens when you allow lawyers to have it\ntheir way with a language.\n\n@node Variable index, Concept index, Copying, Top\n@unnumbered Variable index\n@printindex vr\n\n@node Concept index,  , Variable index, Top\n@unnumbered Concept index\n@printindex cp\n\n@bye\n"
        },
        {
          "name": "server.c",
          "type": "blob",
          "size": 95.458984375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\nint serverExpireTime =  24 * 60 * 60;\nint smallRequestTime = 10;\nint replyUnpipelineTime = 20;\nint replyUnpipelineSize = 1024 * 1024;\nint pipelineAdditionalRequests = 1;\nint maxPipelineTrain = 10;\nAtomPtr parentProxy = NULL;\nAtomPtr parentHost = NULL;\nint parentPort = -1;\nint pmmFirstSize = 0, pmmSize = 0;\nint serverSlots = 2;\nint serverSlots1 = 4;\nint serverMaxSlots = 8;\nint dontCacheRedirects = 0;\nint maxSideBuffering = 1500;\nint maxConnectionAge = 1260;\nint maxConnectionRequests = 400;\nint alwaysAddNoTransform = 0;\n\nstatic HTTPServerPtr servers = 0;\n\nstatic int httpServerContinueConditionHandler(int, ConditionHandlerPtr);\nstatic int initParentProxy(void);\nstatic int parentProxySetter(ConfigVariablePtr var, void *value);\nstatic void httpServerDelayedFinish(HTTPConnectionPtr);\nstatic int allowUnalignedRangeRequests = 0;\n\nvoid\npreinitServer(void)\n{\n    CONFIG_VARIABLE_SETTABLE(parentProxy, CONFIG_ATOM_LOWER, parentProxySetter,\n                    \"Parent proxy (host:port).\");\n    CONFIG_VARIABLE(serverExpireTime, CONFIG_TIME,\n                    \"Time during which server data is valid.\");\n    CONFIG_VARIABLE_SETTABLE(smallRequestTime, CONFIG_TIME, configIntSetter,\n                             \"Estimated time for a small request.\");\n    CONFIG_VARIABLE_SETTABLE(replyUnpipelineTime, CONFIG_TIME, configIntSetter,\n                             \"Estimated time for a pipeline break.\");\n    CONFIG_VARIABLE_SETTABLE(replyUnpipelineSize, CONFIG_INT, configIntSetter,\n                    \"Size for a pipeline break.\");\n    CONFIG_VARIABLE_SETTABLE(pipelineAdditionalRequests, CONFIG_TRISTATE,\n                             configIntSetter,\n                             \"Pipeline requests on an active connection.\");\n    CONFIG_VARIABLE_SETTABLE(maxPipelineTrain, CONFIG_INT,\n                             configIntSetter,\n                             \"Maximum number of requests \"\n                             \"pipelined at a time.\");\n    CONFIG_VARIABLE(pmmFirstSize, CONFIG_INT,\n                    \"The size of the first PMM chunk.\");\n    CONFIG_VARIABLE(pmmSize, CONFIG_INT,\n                    \"The size of a PMM chunk.\");\n    CONFIG_VARIABLE(serverSlots, CONFIG_INT,\n                    \"Maximum number of connections per server.\");\n    CONFIG_VARIABLE(serverSlots1, CONFIG_INT,\n                    \"Maximum number of connections per HTTP/1.0 server.\");\n    CONFIG_VARIABLE(serverMaxSlots, CONFIG_INT,\n                    \"Maximum number of connections per broken server.\");\n    CONFIG_VARIABLE(dontCacheRedirects, CONFIG_BOOLEAN,\n                    \"If true, don't cache redirects.\");\n    CONFIG_VARIABLE_SETTABLE(allowUnalignedRangeRequests,\n                             CONFIG_BOOLEAN, configIntSetter,\n                             \"Allow unaligned range requests (unreliable).\");\n    CONFIG_VARIABLE_SETTABLE(maxSideBuffering,\n                             CONFIG_INT, configIntSetter,\n                             \"Maximum buffering for PUT and POST requests.\");\n    CONFIG_VARIABLE_SETTABLE(maxConnectionAge,\n                             CONFIG_TIME, configIntSetter,\n                             \"Maximum age of a server-side connection.\");\n    CONFIG_VARIABLE_SETTABLE(maxConnectionRequests,\n                             CONFIG_INT, configIntSetter,\n                             \"Maximum number of requests on a server-side connection.\");\n    CONFIG_VARIABLE(alwaysAddNoTransform, CONFIG_BOOLEAN,\n                    \"If true, add a no-transform directive to all requests.\");\n}\n\nstatic int\nparentProxySetter(ConfigVariablePtr var, void *value)\n{\n    configAtomSetter(var, value);\n    initParentProxy();\n    return 1;\n}\n\nstatic void\ndiscardServer(HTTPServerPtr server)\n{\n    HTTPServerPtr previous;\n    assert(!server->request);\n\n    if(server == servers)\n        servers = server->next;\n    else {\n        previous = servers;\n        while(previous->next != server)\n            previous = previous->next;\n        previous->next = server->next;\n    }\n\n    if(server->connection)\n        free(server->connection);\n    if(server->idleHandler)\n        free(server->idleHandler);\n    if(server->name)\n        free(server->name);\n\n    free(server);\n}\n\nstatic int\nhttpServerIdle(HTTPServerPtr server)\n{\n    int i;\n    if(server->request) \n        return 0;\n    for(i = 0; i < server->maxslots; i++)\n        if(server->connection[i])\n            return 0;\n    return 1;\n}\n\nstatic int\nexpireServersHandler(TimeEventHandlerPtr event)\n{\n    HTTPServerPtr server, next;\n    TimeEventHandlerPtr e;\n    server = servers;\n    while(server) {\n        next = server->next;\n        if(httpServerIdle(server) &&\n           server->time + serverExpireTime < current_time.tv_sec)\n            discardServer(server);\n        server = next;\n    }\n    e = scheduleTimeEvent(serverExpireTime / 60 + 60, \n                          expireServersHandler, 0, NULL);\n    if(!e) {\n        do_log(L_ERROR, \"Couldn't schedule server expiry.\\n\");\n        polipoExit();\n    }\n    return 1;\n}\n\nstatic int\nroundSize(int size)\n{\n    return (size + CHUNK_SIZE - 1) / CHUNK_SIZE * CHUNK_SIZE;\n}\n\nstatic int\ninitParentProxy()\n{\n    AtomPtr host, port_atom;\n    int rc, port;\n\n    if(parentHost) {\n        releaseAtom(parentHost);\n        parentHost = NULL;\n    }\n    if(parentPort >= 0)\n        parentPort = -1;\n\n    if(parentProxy != NULL && parentProxy->length == 0) {\n        releaseAtom(parentProxy);\n        parentProxy = NULL;\n    }\n\n    if(parentProxy == NULL)\n        return 1;\n\n    rc = atomSplit(parentProxy, ':', &host, &port_atom);\n    if(rc <= 0) {\n        do_log(L_ERROR, \"Couldn't parse parentProxy.\");\n        releaseAtom(parentProxy);\n        parentProxy = NULL;\n        return -1;\n    }\n\n    port = atoi(port_atom->string);\n    if(port <= 0 || port >= 0x10000) {\n        releaseAtom(host);\n        releaseAtom(port_atom);\n        do_log(L_ERROR, \"Couldn't parse parentProxy.\");\n        releaseAtom(parentProxy);\n        parentProxy = NULL;\n        return -1;\n    }\n\n    parentHost = host;\n    parentPort = port;\n    return 1;\n}\n\nvoid\ninitServer(void)\n{\n    TimeEventHandlerPtr event;\n    servers = NULL;\n\n    if(pmmFirstSize || pmmSize) {\n        if(pmmSize == 0) pmmSize = pmmFirstSize;\n        if(pmmFirstSize == 0) pmmFirstSize = pmmSize;\n        pmmSize = roundSize(pmmSize);\n        pmmFirstSize = roundSize(pmmFirstSize);\n    }\n\n    if(serverMaxSlots < 1)\n        serverMaxSlots = 1;\n    if(serverSlots < 1)\n        serverSlots = 1;\n    if(serverSlots > serverMaxSlots)\n        serverSlots = serverMaxSlots;\n    if(serverSlots1 < serverSlots)\n        serverSlots1 = serverSlots;\n    if(serverSlots1 > serverMaxSlots)\n        serverSlots1 = serverMaxSlots;\n\n    initParentProxy();\n\n    event = scheduleTimeEvent(serverExpireTime / 60 + 60, expireServersHandler,\n                              0, NULL);\n    if(event == NULL) {\n        do_log(L_ERROR, \"Couldn't schedule server expiry.\\n\");\n        exit(1);\n    }\n}\n\nstatic HTTPServerPtr\ngetServer(char *name, int port, int proxy)\n{\n    HTTPServerPtr server;\n    int i;\n\n    server = servers;\n    while(server) {\n        if(strcmp(server->name, name) == 0 && server->port == port &&\n           server->isProxy == proxy) {\n            if(httpServerIdle(server) &&\n               server->time +  serverExpireTime < current_time.tv_sec) {\n                discardServer(server);\n                server = NULL;\n                break;\n            } else {\n                server->time = current_time.tv_sec;\n                return server;\n            }\n        }\n        server = server->next;\n    }\n    \n    server = malloc(sizeof(HTTPServerRec));\n    if(server == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate server.\\n\");\n        return NULL;\n    }\n\n    server->connection = malloc(serverMaxSlots * sizeof(HTTPConnectionPtr));\n    if(server->connection == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate server.\\n\");\n        free(server);\n        return NULL;\n    }\n\n    server->idleHandler = malloc(serverMaxSlots * sizeof(FdEventHandlerPtr));\n    if(server->connection == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate server.\\n\");\n        free(server->connection);\n        free(server);\n        return NULL;\n    }\n\n    server->maxslots = serverMaxSlots;\n\n    server->name = strdup(name);\n    if(server->name == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate server name.\\n\");\n        free(server);\n        return NULL;\n    }\n\n    server->port = port;\n    server->addrindex = 0;\n    server->isProxy = proxy;\n    server->version = HTTP_UNKNOWN;\n    server->persistent = 0;\n    server->pipeline = 0;\n    server->time = current_time.tv_sec;\n    server->rtt = -1;\n    server->rate = -1;\n    server->numslots = MIN(serverSlots, server->maxslots);\n    for(i = 0; i < server->maxslots; i++) {\n        server->connection[i] = NULL;\n        server->idleHandler[i] = NULL;\n    }\n    server->request = NULL;\n    server->request_last = NULL;\n    server->lies = 0;\n\n    server->next = servers;\n    servers = server;\n    return server;\n}\n\nint\nhttpServerQueueRequest(HTTPServerPtr server, HTTPRequestPtr request)\n{\n    assert(request->request && request->request->request == request);\n    assert(request->connection == NULL);\n    if(server->request) {\n        server->request_last->next = request;\n        server->request_last = request;\n    } else {\n        server->request_last = request;\n        server->request = request;\n    }\n    return 1;\n}\n\nvoid\nhttpServerAbort(HTTPConnectionPtr connection, int fail,\n                int code, AtomPtr message)\n{\n    HTTPRequestPtr request = connection->request;\n    if(request) {\n        if(request->request) {\n            httpClientError(request->request, code, retainAtom(message));\n        }\n        if(fail) {\n            request->object->flags |= OBJECT_FAILED;\n            if(request->object->flags & OBJECT_INITIAL)\n                abortObject(request->object, code, retainAtom(message));\n            notifyObject(request->object);\n        }\n    }\n    releaseAtom(message);\n    if(!connection->connecting)\n        httpServerFinish(connection, 1, 0);\n}\n\nvoid\nhttpServerAbortRequest(HTTPRequestPtr request, int fail,\n                       int code, AtomPtr message)\n{\n    if(request->connection && request == request->connection->request) {\n        httpServerAbort(request->connection, fail, code, message);\n    } else {\n        HTTPRequestPtr requestor = request->request;\n        if(requestor) {\n            requestor->request = NULL;\n            request->request = NULL;\n            httpClientError(requestor, code, retainAtom(message));\n        }\n        if(fail) {\n            request->object->flags |= OBJECT_FAILED;\n            if(request->object->flags & OBJECT_INITIAL)\n                abortObject(request->object, code, retainAtom(message));\n            notifyObject(request->object);\n        }\n        releaseAtom(message);\n    }\n}\n\nvoid \nhttpServerClientReset(HTTPRequestPtr request)\n{\n    if(request->connection && \n       request->connection->fd >= 0 &&\n       !request->connection->connecting &&\n       request->connection->request == request)\n        pokeFdEvent(request->connection->fd, -ECLIENTRESET, POLLIN | POLLOUT);\n}\n\n\nint\nhttpMakeServerRequest(char *name, int port, ObjectPtr object, \n                  int method, int from, int to, HTTPRequestPtr requestor)\n{\n    HTTPServerPtr server;\n    HTTPRequestPtr request;\n    int rc;\n\n    assert(!(object->flags & OBJECT_INPROGRESS));\n\n    if(parentHost) {\n        server = getServer(parentHost->string, parentPort, 1);\n    } else {\n        server = getServer(name, port, 0);\n    }\n    if(server == NULL) return -1;\n\n    object->flags |= OBJECT_INPROGRESS;\n    object->requestor = requestor;\n\n    request = httpMakeRequest();\n    if(!request) {\n        do_log(L_ERROR, \"Couldn't allocate request.\\n\");\n        return -1;\n    }\n\n    /* Because we allocate objects in chunks, we cannot have data that\n       doesn't start at a chunk boundary. */\n    if(from % CHUNK_SIZE != 0) {\n        if(allowUnalignedRangeRequests) {\n            objectFillFromDisk(object, from / CHUNK_SIZE * CHUNK_SIZE, 1);\n            if(objectHoleSize(object, from - 1) != 0)\n                from = from / CHUNK_SIZE * CHUNK_SIZE;\n        } else {\n            from = from / CHUNK_SIZE * CHUNK_SIZE;\n        }\n    }\n\n    request->object = retainObject(object);\n    request->method = method;\n    if(method == METHOD_CONDITIONAL_GET) {\n        if(server->lies > 0)\n            request->method = METHOD_HEAD;\n    }\n    request->flags =\n        REQUEST_PERSISTENT |\n        (expectContinue ? (requestor->flags & REQUEST_WAIT_CONTINUE) : 0);\n    request->from = from;\n    request->to = to;\n    request->request = requestor;\n    requestor->request = request;\n    request->cache_control = requestor->cache_control;\n    request->time0 = null_time;\n    request->time1 = null_time;\n\n    rc = httpServerQueueRequest(server, request);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Couldn't queue request.\\n\");\n        request->request = NULL;\n        requestor->request = NULL;\n        object->flags &= ~(OBJECT_INPROGRESS | OBJECT_VALIDATING);\n        releaseNotifyObject(object);\n        httpDestroyRequest(request);\n        return 1;\n    }\n\n    if(request->flags & REQUEST_WAIT_CONTINUE) {\n        if(server->version == HTTP_10) {\n            httpServerAbortRequest(request, 1,\n                                   417, internAtom(\"Expectation failed\"));\n            return 1;\n        }\n    } else if(expectContinue >= 2 && server->version == HTTP_11) {\n        if(request->method == METHOD_POST || request->method == METHOD_PUT ||\n           request->method == METHOD_OPTIONS || request->method == METHOD_DELETE)\n            request->flags |= REQUEST_WAIT_CONTINUE;\n    }\n        \n again:\n    rc = httpServerTrigger(server);\n    if(rc < 0) {\n        /* We must be very short on memory.  If there are any requests\n           queued, we abort one and try again.  If there aren't, we\n           give up. */\n        do_log(L_ERROR, \"Couldn't trigger server -- out of memory?\\n\");\n        if(server->request) {\n            httpServerAbortRequest(server->request, 1, 503,\n                                   internAtom(\"Couldn't trigger server\"));\n            goto again;\n        }\n    }\n    return 1;\n}\n\nint\nhttpServerConnection(HTTPServerPtr server)\n{\n    HTTPConnectionPtr connection;\n    int i;\n\n    connection = httpMakeConnection();\n    if(connection == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate server connection.\\n\");\n        return -1;\n    }\n    connection->server = server;\n\n    for(i = 0; i < server->numslots; i++) {\n        if(!server->connection[i]) {\n            server->connection[i] = connection;\n            break;\n        }\n    }\n    assert(i < server->numslots);\n    \n    connection->request = NULL;\n    connection->request_last = NULL;\n\n    do_log(D_SERVER_CONN, \"C... %s:%d.\\n\",\n           scrub(connection->server->name), connection->server->port);\n    httpSetTimeout(connection, serverTimeout);\n    if(socksParentProxy) {\n        connection->connecting = CONNECTING_SOCKS;\n        do_socks_connect(server->name, connection->server->port,\n                         httpServerSocksHandler, connection);\n    } else {\n        connection->connecting = CONNECTING_DNS;\n        do_gethostbyname(server->name, 0,\n                         httpServerConnectionDnsHandler,\n                         connection);\n    }\n    return 1;\n}\n\nint\nhttpServerConnectionDnsHandler(int status, GethostbynameRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->data;\n\n    httpSetTimeout(connection, -1);\n\n    if(status <= 0) {\n        AtomPtr message;\n        message = internAtomF(\"Host %s lookup failed: %s\",\n                              request->name ?\n                              request->name->string : \"(unknown)\",\n                              request->error_message ?\n                              request->error_message->string :\n                              pstrerror(-status));\n        do_log(L_ERROR, \"Host %s lookup failed: %s (%d).\\n\", \n               request->name ?\n               scrub(request->name->string) : \"(unknown)\",\n               request->error_message ?\n               request->error_message->string :\n               pstrerror(-status), -status);\n        connection->connecting = 0;\n        if(connection->server->request)\n            httpServerAbortRequest(connection->server->request, 1, 504,\n                                   retainAtom(message));\n        httpServerAbort(connection, 1, 502, message);\n        return 1;\n    }\n\n    if(request->addr->string[0] == DNS_CNAME) {\n        if(request->count > 10) {\n            AtomPtr message = internAtom(\"DNS CNAME loop\");\n            do_log(L_ERROR, \"DNS CNAME loop.\\n\");\n            connection->connecting = 0;\n            if(connection->server->request)\n                httpServerAbortRequest(connection->server->request, 1, 504,\n                                       retainAtom(message));\n            httpServerAbort(connection, 1, 504, message);\n            return 1;\n        }\n            \n        httpSetTimeout(connection, serverTimeout);\n        do_gethostbyname(request->addr->string + 1, request->count + 1,\n                         httpServerConnectionDnsHandler,\n                         connection);\n        return 1;\n    }\n\n    connection->connecting = CONNECTING_CONNECT;\n    httpSetTimeout(connection, serverTimeout);\n    do_connect(retainAtom(request->addr), connection->server->addrindex,\n               connection->server->port,\n               httpServerConnectionHandler, connection);\n    return 1;\n}\n\nint\nhttpServerConnectionHandler(int status,\n                            FdEventHandlerPtr event,\n                            ConnectRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->data;\n\n    assert(connection->fd < 0);\n    if(request->fd >= 0) {\n        int rc;\n        connection->fd = request->fd;\n        connection->server->addrindex = request->index;\n        rc = setNodelay(connection->fd, 1);\n        if(rc < 0)\n            do_log_error(L_WARN, errno, \"Couldn't disable Nagle's algorithm\");\n    }\n\n    return httpServerConnectionHandlerCommon(status, connection);\n}\n\nint\nhttpServerSocksHandler(int status, SocksRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->data;\n\n    assert(connection->fd < 0);\n    if(request->fd >= 0) {\n        connection->fd = request->fd;\n        connection->server->addrindex = 0;\n    }\n    return httpServerConnectionHandlerCommon(status, connection);\n}\n\nint\nhttpServerConnectionHandlerCommon(int status, HTTPConnectionPtr connection)\n{\n    httpSetTimeout(connection, -1);\n\n    if(status < 0) {\n        AtomPtr message = \n            internAtomError(-status, \"Connect to %s:%d failed\",\n                            connection->server->name,\n                            connection->server->port);\n        if(status != -ECLIENTRESET)\n            do_log_error(L_ERROR, -status, \"Connect to %s:%d failed\",\n                         scrub(connection->server->name),\n                         connection->server->port);\n        connection->connecting = 0;\n        if(connection->server->request)\n            httpServerAbortRequest(connection->server->request,\n                                   status != -ECLIENTRESET, 504, \n                                   retainAtom(message));\n        httpServerAbort(connection, status != -ECLIENTRESET, 504, message);\n        return 1;\n    }\n\n    do_log(D_SERVER_CONN, \"C    %s:%d.\\n\",\n           scrub(connection->server->name), connection->server->port);\n\n    connection->connecting = 0;\n    /* serverTrigger will take care of inserting any timeouts */\n    httpServerTrigger(connection->server);\n    return 1;\n}\n\nint\nhttpServerIdleHandler(int a, FdEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n    HTTPServerPtr server = connection->server;\n    int i;\n\n    assert(!connection->request);\n\n    do_log(D_SERVER_CONN, \"Idle connection to %s:%d died.\\n\", \n           scrub(connection->server->name), connection->server->port);\n\n    for(i = 0; i < server->maxslots; i++) {\n        if(connection == server->connection[i]) {\n            server->idleHandler[i] = NULL;\n            break;\n        }\n    }\n    assert(i < server->maxslots);\n\n    httpServerAbort(connection, 1, 504, internAtom(\"Timeout\"));\n    return 1;\n}\n\n/* Discard aborted requests at the head of the queue. */\nstatic void\nhttpServerDiscardRequests(HTTPServerPtr server)\n{\n    HTTPRequestPtr request;\n    while(server->request && !server->request->request) {\n        request = server->request;\n        server->request = request->next;\n        request->next = NULL;\n        if(server->request == NULL)\n            server->request_last = NULL;\n        request->object->flags &= ~(OBJECT_INPROGRESS | OBJECT_VALIDATING);\n        releaseNotifyObject(request->object);\n        request->object = NULL;\n        httpDestroyRequest(request);\n    }\n}\n\nstatic int\npipelineIsSmall(HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n\n    if(pipelineAdditionalRequests <= 0)\n        return 0;\n    else if(pipelineAdditionalRequests >= 2)\n        return 1;\n\n    if(!request)\n        return 1;\n    if(request->next || !(request->flags & REQUEST_PERSISTENT))\n        return 0;\n    if(request->method == METHOD_HEAD || \n       request->method == METHOD_CONDITIONAL_GET)\n        return 1;\n    if(request->to >= 0 && connection->server->rate > 0 &&\n       request->to - request->from < connection->server->rate * \n       smallRequestTime)\n        return 1;\n    return 0;\n}\n\nstatic int\nnumRequests(HTTPServerPtr server)\n{\n    int n = 0;\n    HTTPRequestPtr request = server->request;\n    while(request) {\n        n++;\n        request = request->next;\n    }\n    return n;\n}\n\nHTTPConnectionPtr\nhttpServerGetConnection(HTTPServerPtr server, int *idle_return)\n{\n    int i, j;\n    int connecting = 0, empty = 0, idle = 0;\n\n    j = -1;\n    /* Try to find an idle connection */\n    for(i = 0; i < server->numslots; i++) {\n        if(server->connection[i]) {\n            if(!server->connection[i]->connecting) {\n                if(!server->connection[i]->request) {\n                    if(server->idleHandler[i])\n                        unregisterFdEvent(server->idleHandler[i]);\n                    server->idleHandler[i] = NULL;\n                    if(j < 0) j = i;\n                    idle++;\n                }\n            } else\n                connecting++;\n        } else\n            empty++;\n    }\n\n    if(j >= 0) {\n        *idle_return = idle;\n        return server->connection[j];\n    }\n\n    /* If there's an empty slot, schedule connection creation */\n    if(empty) {\n        /* Don't open a connection if there are already enough in\n           progress, except if the server doesn't do persistent\n           connections and there's only one in progress. */\n        if((connecting == 0 || (server->persistent <= 0 && connecting <= 1)) ||\n           connecting < numRequests(server)) {\n            httpServerConnection(server);\n        }\n    }\n\n    /* Find a connection that can accept additional requests */\n    if(server->version == HTTP_11 && server->pipeline >= 4) {\n        for(i = 0; i < serverSlots; i++) {\n            if(server->connection[i] && !server->connection[i]->connecting &&\n               pipelineIsSmall(server->connection[i])) {\n                if(server->idleHandler[i])\n                    unregisterFdEvent(server->idleHandler[i]);\n                server->idleHandler[i] = NULL;\n                *idle_return = 0;\n                return server->connection[i];\n            }\n        }\n    }\n    *idle_return = idle;\n    return NULL;\n}\n\nint\nhttpServerTrigger(HTTPServerPtr server)\n{\n    HTTPConnectionPtr connection;\n    HTTPRequestPtr request;\n    int idle, n, i, rc, numidle;\n\n    while(server->request) {\n        httpServerDiscardRequests(server);\n\n        if(!server->request)\n            break;\n\n        if(REQUEST_SIDE(server->request)) {\n            rc = httpServerSideRequest(server);\n            /* If rc is 0, httpServerSideRequest didn't dequeue this\n               request.  Go through the scheduling loop again, come\n               back later. */\n            if(rc <= 0) break;\n            continue;\n        }\n        connection = httpServerGetConnection(server, &numidle);\n        if(!connection) break;\n\n        /* If server->pipeline <= 0, we don't do pipelining.  If\n           server->pipeline is 1, then we are ready to start probing\n           for pipelining on the server; we then send exactly two\n           requests in what is hopefully a single packet to check\n           whether the server has the nasty habit of discarding its\n           input buffers after each request.\n           If server->pipeline is 2 or 3, the pipelining probe is in\n           progress on this server, and we don't pipeline anything\n           until it succeeds.  When server->pipeline >= 4, pipelining\n           is believed to work on this server. */\n        if(server->version != HTTP_11 || server->pipeline <= 0 ||\n           server->pipeline == 2 || server->pipeline == 3) {\n            if(connection->pipelined == 0)\n                n = 1;\n            else\n                n = 0;\n        } else if(server->pipeline == 1) {\n            if(connection->pipelined == 0)\n                n = MIN(2, maxPipelineTrain);\n            else\n                n = 0;\n        } else {\n            n = maxPipelineTrain;\n        }\n\n        /* Don't pipeline if there are more idle connections */\n        if(numidle >= 2)\n            n = MIN(n, 1);\n    \n        idle = !connection->pipelined;\n        i = 0;\n        while(server->request && connection->pipelined < n) {\n            httpServerDiscardRequests(server);\n            if(!server->request) break;\n            request = server->request;\n            assert(request->request->request == request);\n            rc = httpWriteRequest(connection, request, -1);\n            if(rc < 0) {\n                if(i == 0)\n                    httpServerAbortRequest(request, rc != -ECLIENTRESET, 502,\n                                           internAtom(\"Couldn't \"\n                                                      \"write request\"));\n                break;\n            }\n            do_log(D_SERVER_CONN, \"W: \");\n            do_log_n(D_SERVER_CONN, \n                     request->object->key, request->object->key_size);\n            do_log(D_SERVER_CONN, \" (%d)\\n\", request->method);\n            if(connection->pipelined > 0)\n                request->flags |= REQUEST_PIPELINED;\n            request->time0 = current_time;\n            i++;\n            server->request = request->next;\n            request->next = NULL;\n            if(server->request == NULL)\n                server->request_last = NULL;\n            httpQueueRequest(connection, request);\n            connection->pipelined++;\n        }\n        if(server->persistent > 0 && server->pipeline == 1 && i >= 2)\n            server->pipeline = 2;\n\n        if(i > 0) httpServerSendRequest(connection);\n\n        if(idle && connection->pipelined > 0)\n            httpServerReply(connection, 0);\n\n        if(i == 0) break;\n    }\n\n    for(i = 0; i < server->maxslots; i++) {\n        if(server->connection[i] &&\n           !server->connection[i]->connecting &&\n           !server->connection[i]->request) {\n            /* Artificially age any fresh connections that aren't used\n               straight away; this is necessary for the logic for POST and \n               the logic that determines whether a given request should be \n               restarted. */\n            if(server->connection[i]->serviced == 0)\n                server->connection[i]->serviced = 1;\n            if(!server->idleHandler[i])\n                server->idleHandler[i] = \n                    registerFdEvent(server->connection[i]->fd, POLLIN,\n                                    httpServerIdleHandler,\n                                    sizeof(HTTPConnectionPtr),\n                                    &server->connection[i]);\n            if(!server->idleHandler[i]) {\n                do_log(L_ERROR, \"Couldn't register idle handler.\\n\");\n                httpServerFinish(server->connection[i], 1, 0);\n            }\n            httpSetTimeout(server->connection[i], serverIdleTimeout);\n        }\n    }\n\n    return 1;\n}\n\nint\nhttpServerSideRequest(HTTPServerPtr server)\n{\n    HTTPRequestPtr request = server->request;\n    HTTPConnectionPtr connection;\n    HTTPRequestPtr requestor = request->request;\n    HTTPConnectionPtr client = requestor->connection;\n    int rc, i, freeslots, idle, connecting;\n\n    assert(REQUEST_SIDE(request));\n\n    connection = NULL;\n    freeslots = 0;\n    idle = -1;\n    connecting = 0;\n\n    /* Find a fresh connection */\n    for(i = 0; i < server->numslots; i++) {\n        if(!server->connection[i])\n            freeslots++;\n        else if(!server->connection[i]->connecting) {\n            if(!server->connection[i]->request) {\n                if(server->connection[i]->serviced == 0) {\n                    if(server->idleHandler[i])\n                        unregisterFdEvent(server->idleHandler[i]);\n                    server->idleHandler[i] = NULL;\n                    connection = server->connection[i];\n                    break;\n                } else {\n                    idle = i;\n                }\n            }\n        } else {\n            connecting++;\n        }\n    }\n\n    if(!connection) {\n        /* Make sure that a fresh connection will be established at some\n           point, then wait until httpServerTrigger calls us again. */\n        if(freeslots) {\n            httpServerConnection(server);\n        } else {\n            if(idle >= 0) {\n                /* Shutdown a random idle connection */\n                pokeFdEvent(server->connection[idle]->fd, \n                            -EDOSHUTDOWN, POLLIN | POLLOUT);\n            }\n        }\n        return 0;\n    }\n\n    rc = httpWriteRequest(connection, request, client->bodylen);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Couldn't write POST or PUT request.\\n\");\n        httpServerAbortRequest(request, rc != -ECLIENTRESET, 502,\n                               internAtom(\"Couldn't write request\"));\n        return 0;\n    }\n    server->request = request->next;\n    request->next = NULL;\n    if(server->request == NULL)\n        server->request_last = NULL;\n    httpQueueRequest(connection, request);\n    connection->pipelined = 1;\n    request->time0 = current_time;\n    connection->reqoffset = 0;\n    connection->bodylen = client->bodylen;\n    httpServerDoSide(connection);\n    return 1;\n}\n\nint \nhttpServerDoSide(HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n    HTTPRequestPtr requestor = request->request;\n    HTTPConnectionPtr client = requestor->connection;\n    int len = MIN(client->reqlen - client->reqbegin,\n                  connection->bodylen - connection->reqoffset);\n    int doflush = \n        len > 0 &&\n        (len >= maxSideBuffering ||\n         client->reqbegin > 0 ||\n         (connection->reqoffset + client->reqlen - client->reqbegin) >=\n         connection->bodylen);\n    int done = connection->reqoffset >= connection->bodylen;\n\n    assert(connection->bodylen >= 0);\n\n    httpSetTimeout(connection, 60);\n\n    if(connection->reqlen > 0) {\n        /* Send the headers, but don't send any part of the body if\n           we're in wait_continue. */\n        do_stream_2(IO_WRITE,\n                    connection->fd, 0,\n                    connection->reqbuf, connection->reqlen,\n                    client->reqbuf + client->reqbegin, \n                    (request->flags & REQUEST_WAIT_CONTINUE) ? 0 : len,\n                    httpServerSideHandler2, connection);\n        httpServerReply(connection, 0);\n    } else if(request->object->flags & OBJECT_ABORTED) {\n        if(connection->reqbuf)\n            dispose_chunk(connection->reqbuf);\n        connection->reqbuf = NULL;\n        connection->reqlen = 0;\n        pokeFdEvent(connection->fd, -ESHUTDOWN, POLLIN);\n        if(client->flags & CONN_READER) {\n            client->flags |= CONN_SIDE_READER;\n            do_stream(IO_READ | IO_IMMEDIATE | IO_NOTNOW,\n                      client->fd, 0, NULL, 0,\n                      httpClientSideHandler, client);\n        }\n    } else if(!(request->flags & REQUEST_WAIT_CONTINUE) && doflush) {\n        /* Make sure there's a reqbuf, as httpServerFinish uses\n           it to determine if there's a writer. */\n        if(connection->reqbuf == NULL)\n            connection->reqbuf = get_chunk();\n        assert(connection->reqbuf != NULL);\n        do_stream(IO_WRITE,\n                  connection->fd, 0,\n                  client->reqbuf + client->reqbegin, len,\n                  httpServerSideHandler, connection);\n    } else {\n        if(connection->reqbuf) {\n            httpConnectionDestroyReqbuf(connection);\n            connection->reqlen = 0;\n        }\n        if(request->flags & REQUEST_WAIT_CONTINUE) {\n            ConditionHandlerPtr chandler;\n            do_log(D_SERVER_CONN, \"W... %s:%d.\\n\",\n                   scrub(connection->server->name), connection->server->port);\n            chandler = \n                conditionWait(&request->object->condition,\n                              httpServerContinueConditionHandler,\n                              sizeof(connection), &connection);\n            if(chandler)\n                return 1;\n            else\n                do_log(L_ERROR, \"Couldn't register condition handler.\\n\");\n            /* Fall through -- the client side will clean up. */\n        }\n        client->flags |= CONN_SIDE_READER;\n        do_stream(IO_READ | (done ? IO_IMMEDIATE : 0 ) | IO_NOTNOW,\n                  client->fd, client->reqlen,\n                  client->reqbuf, CHUNK_SIZE,\n                  httpClientSideHandler, client);\n    }\n    return 1;\n}\n\nstatic int\nhttpClientDelayedDoSideHandler(TimeEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n    httpServerDoSide(connection);\n    return 1;\n}\n\nstatic int\nhttpServerDelayedDoSide(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr handler;\n    handler = scheduleTimeEvent(0, httpClientDelayedDoSideHandler,\n                                sizeof(connection), &connection);\n    if(!handler) {\n        do_log(L_ERROR, \"Couldn't schedule DoSide -- freeing memory.\\n\");\n        free_chunk_arenas();\n        handler = scheduleTimeEvent(0, httpClientDelayedDoSideHandler,\n                                    sizeof(connection), &connection);\n        if(!handler)\n            do_log(L_ERROR, \"Couldn't schedule DoSide.\\n\");\n        /* Somebody will hopefully end up timing out. */\n        return 1;\n    }\n    return 1;\n}\n\nstatic int\nhttpServerSideHandlerCommon(int kind, int status,\n                            FdEventHandlerPtr event,\n                            StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    HTTPRequestPtr requestor = request->request;\n    HTTPConnectionPtr client = requestor->connection;\n    int bodylen;\n\n    assert(request->object->flags & OBJECT_INPROGRESS);\n\n    if(status) {\n        do_log_error(L_ERROR, -status, \"Couldn't write to server\");\n        httpConnectionDestroyReqbuf(connection);\n        if(status != -ECLIENTRESET)\n            shutdown(connection->fd, 2);\n        abortObject(request->object, 502,\n                    internAtom(\"Couldn't write to server\"));\n        /* Let the read side handle the error */\n        httpServerDoSide(connection);\n        return 1;\n    }\n\n    assert(srequest->offset > 0);\n\n    if(kind == 2) {\n        if(srequest->offset < connection->reqlen)\n            return 0;\n        bodylen = srequest->offset - connection->reqlen;\n        connection->reqlen = 0;\n        httpConnectionDestroyReqbuf(connection);\n    } else {\n        bodylen = srequest->offset;\n    }\n\n\n    assert(client->reqbegin + bodylen <= client->reqlen);\n\n    if(client->reqlen > client->reqbegin + bodylen)\n        memmove(client->reqbuf, client->reqbuf + client->reqbegin + bodylen,\n                client->reqlen - client->reqbegin - bodylen);\n    client->reqlen -= bodylen + client->reqbegin;\n    client->reqbegin = 0;\n    connection->reqoffset += bodylen;\n    httpServerDoSide(connection);\n    return 1;\n}\n\nint\nhttpServerSideHandler(int status,\n                      FdEventHandlerPtr event,\n                      StreamRequestPtr srequest)\n{\n    return httpServerSideHandlerCommon(1, status, event, srequest);\n}\n\nint\nhttpServerSideHandler2(int status,\n                       FdEventHandlerPtr event,\n                       StreamRequestPtr srequest)\n{\n    return httpServerSideHandlerCommon(2, status, event, srequest);\n}\n\nstatic int\nhttpServerContinueConditionHandler(int status, ConditionHandlerPtr chandler)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)chandler->data;\n\n    if(connection->request->flags & REQUEST_WAIT_CONTINUE)\n        return 0;\n    httpServerDelayedDoSide(connection);\n    return 1;\n}\n\n/* s is 0 to keep the connection alive, 1 to shutdown the connection */\nvoid\nhttpServerFinish(HTTPConnectionPtr connection, int s, int offset)\n{\n    HTTPServerPtr server = connection->server;\n    HTTPRequestPtr request = connection->request;\n    int i;\n\n    if(request) {\n        assert(connection->pipelined >= 1);\n        assert((connection->pipelined > 1) == (request->next != NULL));\n    } else {\n        assert(connection->pipelined == 0);\n    }\n\n    if(!s && (!connection->request ||\n                  !(connection->request->flags & REQUEST_PERSISTENT)))\n        s = 1;\n\n    if(connection->serviced >= maxConnectionRequests ||\n       connection->time < current_time.tv_sec - maxConnectionAge)\n        s = 1;\n\n    if(connection->reqbuf) {\n        /* As most normal requests go out in a single packet, this is\n           extremely unlikely to happen.  As for POST/PUT requests,\n           they are not pipelined, so this can only happen if the\n           server sent an error reply early. */\n        assert(connection->fd >= 0);\n        shutdown(connection->fd, 1);\n        pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLOUT);\n        httpServerDelayedFinish(connection);\n        goto done;\n    }\n\n    if(request) {\n        /* Update statistics about the server */\n        int size = -1, d = -1, rtt = -1, rate = -1;\n        if(connection->offset > 0 && request->from >= 0)\n            size = connection->offset - request->from;\n        if(request->time1.tv_sec != null_time.tv_sec) {\n            d = timeval_minus_usec(&current_time, &request->time1);\n            if(!(request->flags & REQUEST_PIPELINED) &&\n               request->time0.tv_sec != null_time.tv_sec)\n                rtt = timeval_minus_usec(&request->time1, &request->time0);\n            if(size >= 8192 && d > 50000)\n                rate = ((double)size / (double)d) * 1000000.0 + 0.5;\n        }\n        request->time0 = null_time;\n        request->time1 = null_time;\n\n        if(rtt >= 0) {\n            if(server->rtt >= 0)\n                server->rtt = (3 * server->rtt + rtt + 2) / 4;\n            else\n                server->rtt = rtt;\n        }\n        if(rate >= 0) {\n            if(server->rate >= 0)\n                server->rate = (3 * server->rate + rate + 2) / 4;\n            else\n                server->rate = rate;\n        }\n\n        httpDequeueRequest(connection);\n        connection->pipelined--;\n        request->object->flags &= ~(OBJECT_INPROGRESS | OBJECT_VALIDATING);\n        if(request->request) {\n            request->request->request = NULL;\n            request->request = NULL;\n        }\n        releaseNotifyObject(request->object);\n        request->object = NULL;\n        httpDestroyRequest(request);\n    }\n\n    do_log(D_SERVER_CONN, \"Done with server %s:%d connection (%d)\\n\",\n           scrub(connection->server->name), connection->server->port, s);\n\n    assert(offset <= connection->len);\n\n    if(!s) {\n        if(offset < connection->len) {\n            assert(connection->buf != NULL);\n            if(!connection->pipelined) {\n                do_log(L_WARN, \n                       \"Closing connection to %s:%d: \"\n                       \"%d stray bytes of data.\\n\",\n                       scrub(server->name), server->port,\n                       connection->len - offset);\n                s = 1;\n            } else {\n                memmove(connection->buf, connection->buf + offset,\n                        connection->len - offset);\n                connection->len = connection->len - offset;\n                if((connection->flags & CONN_BIGBUF) &&\n                   connection->len <= CHUNK_SIZE)\n                    httpConnectionUnbigify(connection);\n            }\n        } else {\n            connection->len = 0;\n        }\n    }\n\n    connection->server->time = current_time.tv_sec;\n    connection->serviced++;\n\n    if(s) {\n        if(connection->timeout)\n            cancelTimeEvent(connection->timeout);\n        connection->timeout = NULL;\n        httpConnectionDestroyBuf(connection);\n        if(connection->fd >= 0)\n            CLOSE(connection->fd);\n        connection->fd = -1;\n        server->persistent -= 1;\n        if(server->persistent < -5)\n            server->numslots = MIN(server->maxslots, serverMaxSlots);\n        if(connection->request) {\n            HTTPRequestPtr req;\n            do_log(D_SERVER_CONN, \"Restarting pipeline to %s:%d.\\n\",\n                   scrub(server->name), server->port);\n            if(server->pipeline == 2)\n                server->pipeline -= 20;\n            else\n                server->pipeline -= 5;\n            req = connection->request;\n            while(req) {\n                req->connection = NULL;\n                req = req->next;\n            }\n            if(server->request)\n                connection->request_last->next = server->request;\n            else\n                server->request_last = connection->request_last;\n            server->request = connection->request;\n            connection->request = NULL;\n            connection->request_last = NULL;\n        }\n        /* Make sure we don't get confused into thinking a probe\n           is in progress. */\n        if(server->pipeline == 2 || server->pipeline == 3)\n            server->pipeline = 1;\n        for(i = 0; i < server->maxslots; i++)\n            if(connection == server->connection[i])\n                break;\n        assert(i < server->maxslots);\n        if(server->idleHandler[i])\n            unregisterFdEvent(server->idleHandler[i]);\n        server->idleHandler[i] = NULL;\n        server->connection[i] = NULL;\n        free(connection);\n    } else {\n        server->persistent += 1;\n        if(server->persistent > 0)\n            server->numslots = MIN(server->maxslots,\n                                   server->version == HTTP_10 ?\n                                   serverSlots1 : serverSlots);\n        httpSetTimeout(connection, serverTimeout);\n        /* See httpServerTrigger */\n        if(connection->pipelined ||\n           (server->version == HTTP_11 && server->pipeline <= 0) ||\n           (server->pipeline == 3)) {\n            server->pipeline++;\n        }\n        if(connection->pipelined) {\n            httpServerReply(connection, 1);\n        } else {\n            httpConnectionDestroyBuf(connection);\n        }\n    }\n\n done:\n    httpServerTrigger(server);\n}\n\nstatic int\nhttpServerDelayedFinishHandler(TimeEventHandlerPtr event)\n{\n    HTTPConnectionPtr connection = *(HTTPConnectionPtr*)event->data;\n    httpServerFinish(connection, 1, 0);\n    return 1;\n}\n\nstatic void\nhttpServerDelayedFinish(HTTPConnectionPtr connection)\n{\n    TimeEventHandlerPtr handler;\n\n    handler = scheduleTimeEvent(1, httpServerDelayedFinishHandler,\n                                sizeof(connection), &connection);\n    if(!handler) {\n        do_log(L_ERROR,\n               \"Couldn't schedule delayed finish -- freeing memory.\");\n        free_chunk_arenas();\n        handler = scheduleTimeEvent(1, httpServerDelayedFinishHandler,\n                                    sizeof(connection), &connection);\n        if(!handler) {\n            do_log(L_ERROR,\n                   \"Couldn't schedule delayed finish -- aborting.\\n\");\n            polipoExit();\n        }\n    }\n}\n\nvoid\nhttpServerReply(HTTPConnectionPtr connection, int immediate)\n{\n    assert(connection->pipelined > 0);\n\n    if(connection->request->request == NULL) {\n        do_log(L_WARN, \"Aborting pipeline on %s:%d.\\n\",\n               scrub(connection->server->name), connection->server->port);\n        httpServerFinish(connection, 1, 0);\n        return;\n    }\n\n    do_log(D_SERVER_CONN, \"R: %s (%d)\\n\",\n           scrub(connection->request->object->key),\n           connection->request->method);\n\n    if(connection->len == 0)\n        httpConnectionDestroyBuf(connection);\n\n    httpSetTimeout(connection, serverTimeout);\n    do_stream_buf(IO_READ | (immediate ? IO_IMMEDIATE : 0) | IO_NOTNOW,\n                  connection->fd, connection->len,\n                  &connection->buf, CHUNK_SIZE,\n                  httpServerReplyHandler, connection);\n}\n\nint\nhttpConnectionPipelined(HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n    int i = 0;\n    while(request) {\n        i++;\n        request = request->next;\n    }\n    return i;\n}\n\nvoid\nhttpServerUnpipeline(HTTPRequestPtr request)\n{\n    HTTPConnectionPtr connection = request->connection;\n    HTTPServerPtr server = connection->server;\n\n    request->flags &= ~REQUEST_PERSISTENT;\n    if(request->next) {\n        HTTPRequestPtr req;\n        do_log(L_WARN,\n               \"Restarting pipeline to %s:%d.\\n\", \n               scrub(connection->server->name), connection->server->port);\n        req = request->next;\n        while(req) {\n            req->connection = NULL;\n            req = req->next;\n        }\n        if(server->request)\n            connection->request_last->next = server->request;\n        else\n            server->request_last = connection->request_last;\n        server->request = request->next;\n        request->next = NULL;\n        connection->request_last = request;\n    }\n    connection->pipelined = httpConnectionPipelined(connection);\n}\n\nvoid\nhttpServerRestart(HTTPConnectionPtr connection)\n{\n    HTTPServerPtr server = connection->server;\n    HTTPRequestPtr request = connection->request;\n\n    if(request) {\n        HTTPRequestPtr req;\n        if(request->next)\n            do_log(L_WARN,\n                   \"Restarting pipeline to %s:%d.\\n\", \n                   scrub(connection->server->name), connection->server->port);\n        req = request;\n        while(req) {\n            req->connection = NULL;\n            req = req->next;\n        }\n        if(server->request)\n            connection->request_last->next = server->request;\n        else\n            server->request_last = connection->request_last;\n        server->request = request;\n        connection->request = NULL;\n        connection->request_last = NULL;\n    }\n    connection->pipelined = 0;\n    httpServerFinish(connection, 1, 0);\n}\n\nint\nhttpServerRequest(ObjectPtr object, int method, int from, int to, \n                  HTTPRequestPtr requestor, void *closure)\n{\n    int rc;\n    char name[132];\n    int port;\n    int x, y, z;\n\n    assert(from >= 0 && (to < 0 || to > from));\n    assert(closure == NULL);\n    assert(!(object->flags & OBJECT_LOCAL));\n    assert(object->type == OBJECT_HTTP);\n\n    if(object->flags & OBJECT_INPROGRESS)\n        return 1;\n\n    if(requestor->flags & REQUEST_REQUESTED)\n        return 0;\n\n    assert(requestor->request == NULL);\n\n    if(proxyOffline)\n        return -1;\n\n    rc = parseUrl(object->key, object->key_size, &x, &y, &port, &z);\n    \n    if(rc < 0 || x < 0 || y < 0 || y - x > 131) {\n        do_log(L_ERROR, \"Couldn't parse URL %s\\n\", scrub(object->key));\n        abortObject(object, 400, internAtom(\"Couldn't parse URL\"));\n        notifyObject(object);\n        return 1;\n    }\n\n    if(!intListMember(port, allowedPorts)) {\n        do_log(L_ERROR, \"Attempted connection to port %d.\\n\", port);\n        abortObject(object, 403, internAtom(\"Forbidden port\"));\n        notifyObject(object);\n        return 1;\n    }\n\n    memcpy(name, ((char*)object->key) + x, y - x);\n    name[y - x] = '\\0';\n\n    requestor->flags |= REQUEST_REQUESTED;\n    rc = httpMakeServerRequest(name, port, object, method, from, to,\n                               requestor);\n                                   \n    if(rc < 0) {\n        abortObject(object, \n                    503, internAtom(\"Couldn't schedule server request\"));\n        notifyObject(object);\n        return 1;\n    }\n\n    return 1;\n}\n\nint\nhttpWriteRequest(HTTPConnectionPtr connection, HTTPRequestPtr request,\n                 int bodylen)\n{\n    ObjectPtr object = request->object;\n    int from = request->from, to = request->to, method = request->method;\n    char *url = object->key, *m;\n    int url_size = object->key_size;\n    int x, y, port, z, location_size;\n    char *location;\n    int l, n, rc, bufsize;\n\n    assert(method != METHOD_NONE);\n\n    if(request->method == METHOD_GET || \n       request->method == METHOD_CONDITIONAL_GET) {\n        if(to >= 0) {\n            assert(to >= from);\n            if(to == from) {\n                do_log(L_ERROR, \"Requesting empty segment?\\n\");\n                return -1;\n            }\n        }\n\n        if(object->flags & OBJECT_DYNAMIC) {\n            from = 0;\n            to = -1;\n        } else {\n            objectFillFromDisk(object, from / CHUNK_SIZE * CHUNK_SIZE, 1);\n            l = objectHoleSize(request->object, from);\n            if(l > 0) {\n                if(to <= 0 || to > from + l)\n                    to = from + l;\n            }\n\n            if(pmmSize && connection->server->pipeline >= 4) {\n                if(from == 0)\n                    to = to < 0 ? pmmFirstSize : MIN(to, pmmFirstSize);\n                else\n                    to = to < 0 ? from + pmmSize : MIN(to, from + pmmSize);\n            }\n\n            if(from % CHUNK_SIZE != 0)\n                if(objectHoleSize(object, from - 1) != 0)\n                    from = from / CHUNK_SIZE * CHUNK_SIZE;\n        }\n    }\n\n    rc = parseUrl(url, url_size, &x, &y, &port, &z);\n\n    if(rc < 0 || x < 0 || y < 0) {\n        return -1;\n    }\n\n    if(connection->reqbuf == NULL) {\n        connection->reqbuf = get_chunk();\n        if(connection->reqbuf == NULL)\n            return -1;\n        connection->reqlen = 0;\n    }\n\n    if(method == METHOD_CONDITIONAL_GET &&\n       object->last_modified < 0 && object->etag == NULL)\n        method = request->method = METHOD_GET;\n\n again:\n    bufsize = \n        (connection->flags & CONN_BIGREQBUF) ? bigBufferSize : CHUNK_SIZE;\n    n = connection->reqlen;\n    switch(method) {\n    case METHOD_GET:\n    case METHOD_CONDITIONAL_GET: m = \"GET\"; break;\n    case METHOD_HEAD: m = \"HEAD\"; break;\n    case METHOD_POST: m = \"POST\"; break;\n    case METHOD_PUT: m = \"PUT\"; break;\n    case METHOD_OPTIONS: m = \"OPTIONS\"; break;\n    case METHOD_DELETE: m = \"DELETE\"; break;\n    default: abort();\n    }\n    n = snnprintf(connection->reqbuf, n, bufsize, \"%s \", m);\n\n    if(connection->server->isProxy) {\n        n = snnprint_n(connection->reqbuf, n, bufsize,\n                       url, url_size);\n    } else {\n        if(url_size - z == 0) {\n            location = \"/\";\n            location_size = 1;\n        } else {\n            location = url + z;\n            location_size = url_size - z;\n        }\n        \n        n = snnprint_n(connection->reqbuf, n, bufsize, \n                       location, location_size);\n    }\n    \n    do_log(D_SERVER_REQ, \"Server request: \");\n    do_log_n(D_SERVER_REQ, url + x, y - x);\n    do_log(D_SERVER_REQ, \": \");\n    do_log_n(D_SERVER_REQ, connection->reqbuf, n);\n    do_log(D_SERVER_REQ, \" (method %d from %d to %d, 0x%lx for 0x%lx)\\n\",\n           method, from, to,\n           (unsigned long)connection, (unsigned long)object);\n\n    n = snnprintf(connection->reqbuf, n, bufsize, \" HTTP/1.1\");\n\n    n = snnprintf(connection->reqbuf, n, bufsize, \"\\r\\nHost: \");\n    n = snnprint_n(connection->reqbuf, n, bufsize, url + x, y - x);\n    if(port != 80)\n        n = snnprintf(connection->reqbuf, n, bufsize, \":%d\", port);\n\n    if(connection->server->isProxy && parentAuthCredentials) {\n        n = buildServerAuthHeaders(connection->reqbuf, n, bufsize,\n                                   parentAuthCredentials);\n    }\n\n    if(bodylen >= 0)\n        n = snnprintf(connection->reqbuf, n, bufsize,\n                      \"\\r\\nContent-Length: %d\", bodylen);\n\n    if(request->flags & REQUEST_WAIT_CONTINUE)\n        n = snnprintf(connection->reqbuf, n, bufsize,\n                      \"\\r\\nExpect: 100-continue\");\n\n    if(method != METHOD_HEAD && (from > 0 || to >= 0)) {\n        if(to >= 0) {\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nRange: bytes=%d-%d\", from, to - 1);\n        } else {\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nRange: bytes=%d-\", from);\n        }\n    }\n\n    if(method == METHOD_GET && object->etag && (from > 0 || to >= 0)) {\n        if(request->request && request->request->request == request &&\n           request->request->from == 0 && request->request->to == -1 &&\n           pmmSize == 0 && pmmFirstSize == 0)\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nIf-Range: \\\"%s\\\"\", object->etag);\n    }\n\n    if(method == METHOD_CONDITIONAL_GET) {\n        if(object->last_modified >= 0) {\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nIf-Modified-Since: \");\n            n = format_time(connection->reqbuf, n, bufsize,\n                            object->last_modified);\n        }\n        if(object->etag) {\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nIf-None-Match: \\\"%s\\\"\", object->etag);\n        }\n    }\n\n    n = httpPrintCacheControl(connection->reqbuf, n, bufsize,\n                              alwaysAddNoTransform ? CACHE_NO_TRANSFORM : 0,\n\t\t\t      &request->cache_control);\n    if(n < 0)\n        goto fail;\n\n    if(request->request && request->request->headers) {\n        n = snnprint_n(connection->reqbuf, n, bufsize,\n                       request->request->headers->string, \n                       request->request->headers->length);\n    }\n    if(!disableVia) {\n        if(request->request && request->request->via) {\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nVia: %s, 1.1 %s\",\n                          request->request->via->string, proxyName->string);\n        } else {\n            n = snnprintf(connection->reqbuf, n, bufsize,\n                          \"\\r\\nVia: 1.1 %s\",\n                          proxyName->string);\n        }\n    }\n\n    n = snnprintf(connection->reqbuf, n, bufsize,\n                  \"\\r\\nConnection: %s\\r\\n\\r\\n\",\n                  (request->flags & REQUEST_PERSISTENT) ? \n                  \"keep-alive\" : \"close\");\n    if(n < 0 || n >= bufsize - 1)\n        goto fail;\n    connection->reqlen = n;\n    return n;\n\n fail:\n    rc = 0;\n    if(!(connection->flags & CONN_BIGREQBUF))\n        rc = httpConnectionBigifyReqbuf(connection);\n    if(rc == 1)\n        goto again;\n    return -1;\n}\n\nint\nhttpServerHandler(int status,\n                  FdEventHandlerPtr event,\n                  StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n\n    assert(connection->request->object->flags & OBJECT_INPROGRESS);\n\n    if(connection->reqlen == 0) {\n        do_log(D_SERVER_REQ, \"Writing aborted on 0x%lx\\n\",\n               (unsigned long)connection);\n        goto fail;\n    }\n\n    if(status == 0 && !streamRequestDone(srequest)) {\n        httpSetTimeout(connection, serverTimeout);\n        return 0;\n    }\n\n    httpConnectionDestroyReqbuf(connection);\n\n    if(status) {\n        if(connection->serviced >= 1) {\n            httpServerRestart(connection);\n            return 1;\n        }\n        if(status < 0 && status != -ECONNRESET && status != -EPIPE)\n            do_log_error(L_ERROR, -status,\n                         \"Couldn't send request to server\");\n        goto fail;\n    }\n\n    return 1;\n\n fail:\n    httpConnectionDestroyReqbuf(connection);\n    shutdown(connection->fd, 2);\n    pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLIN);\n    httpSetTimeout(connection, 60);\n    return 1;\n}\n\nint\nhttpServerSendRequest(HTTPConnectionPtr connection)\n{\n    assert(connection->server);\n\n    if(connection->reqlen == 0) {\n        do_log(D_SERVER_REQ, \n               \"Writing aborted on 0x%lx\\n\", (unsigned long)connection);\n        httpConnectionDestroyReqbuf(connection);\n        shutdown(connection->fd, 2);\n        pokeFdEvent(connection->fd, -EDOSHUTDOWN, POLLIN | POLLOUT);\n        return -1;\n    }\n\n    httpSetTimeout(connection, serverTimeout);\n    do_stream(IO_WRITE, connection->fd, 0,\n              connection->reqbuf, connection->reqlen,\n              httpServerHandler, connection);\n    return 1;\n}\n\nint\nhttpServerReplyHandler(int status,\n                       FdEventHandlerPtr event, \n                       StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    int i, body;\n    int bufsize = \n        (connection->flags & CONN_BIGBUF) ? bigBufferSize : CHUNK_SIZE;\n\n    assert(request->object->flags & OBJECT_INPROGRESS);\n    if(status < 0) {\n        if(connection->serviced >= 1) {\n            httpServerRestart(connection);\n            return 1;\n        }\n        if(status != -ECLIENTRESET)\n            do_log_error(L_ERROR, -status, \"Read from server failed\");\n        httpServerAbort(connection, status != -ECLIENTRESET, 502, \n                        internAtomError(-status, \"Read from server failed\"));\n        return 1;\n    }\n\n    i = findEndOfHeaders(connection->buf, 0, srequest->offset, &body);\n    connection->len = srequest->offset;\n\n    if(i >= 0) {\n        request->time1 = current_time;\n        return httpServerHandlerHeaders(status, event, srequest, connection);\n    }\n\n    if(status) {\n        if(connection->serviced >= 1) {\n            httpServerRestart(connection);\n            return 1;\n        }\n        if(status < 0) {\n            do_log(L_ERROR, \n                   \"Error reading server headers: %d\\n\", -status);\n            httpServerAbort(connection, status != -ECLIENTRESET, 502, \n                            internAtomError(-status, \n                                            \"Error reading server headers\"));\n        } else\n            httpServerAbort(connection, 1, 502, \n                            internAtom(\"Server dropped connection\"));\n        return 1;\n    }\n\n    if(connection->len >= bufsize) {\n        int rc = 0;\n        if(!(connection->flags & CONN_BIGBUF))\n            rc = httpConnectionBigify(connection);\n        if(rc == 0) {\n            do_log(L_ERROR, \"Couldn't find end of server's headers.\\n\");\n            httpServerAbort(connection, 1, 502,\n                            internAtom(\"Couldn't find end \"\n                                       \"of server's headers\"));\n            return 1;\n        } else if(rc < 0) {\n            do_log(L_ERROR, \"Couldn't allocate big buffer.\\n\");\n            httpServerAbort(connection, 1, 500,\n                            internAtom(\"Couldn't allocate big buffer\"));\n            return 1;\n        }\n        /* Can't just return 0 -- buf has moved. */\n        do_stream(IO_READ,\n                  connection->fd, connection->len,\n                  connection->buf, bigBufferSize,\n                  httpServerReplyHandler, connection);\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nhttpServerHandlerHeaders(int eof,\n                         FdEventHandlerPtr event,\n                         StreamRequestPtr srequest, \n                         HTTPConnectionPtr connection)\n{\n    HTTPRequestPtr request = connection->request;\n    ObjectPtr object = request->object;\n    int rc;\n    int code, version;\n    int full_len;\n    AtomPtr headers;\n    int len;\n    int te;\n    CacheControlRec cache_control;\n    int age = -1;\n    time_t date, last_modified, expires;\n    struct timeval *init_time;\n    char *etag;\n    AtomPtr via, new_via;\n    int expect_body;\n    HTTPRangeRec content_range;\n    ObjectPtr new_object = NULL, old_object = NULL;\n    int supersede = 0;\n    AtomPtr message = NULL;\n    int suspectDynamic;\n    AtomPtr url = NULL;\n\n    assert(request->object->flags & OBJECT_INPROGRESS);\n    assert(eof >= 0);\n\n    httpSetTimeout(connection, -1);\n\n    if(request->flags & REQUEST_WAIT_CONTINUE) {\n        do_log(D_SERVER_CONN, \"W   %s:%d.\\n\",\n               connection->server->name, connection->server->port);\n        request->flags &= ~REQUEST_WAIT_CONTINUE;\n    }\n\n    rc = httpParseServerFirstLine(connection->buf, &code, &version, &message);\n    if(rc <= 0) {\n        do_log(L_ERROR, \"Couldn't parse server status line.\\n\");\n        httpServerAbort(connection, 1, 502,\n                        internAtom(\"Couldn't parse server status line\"));\n        return 1;\n    }\n\n    do_log(D_SERVER_REQ, \"Server status: \");\n    do_log_n(D_SERVER_REQ, connection->buf, \n             connection->buf[rc - 1] == '\\r' ? rc - 2 : rc - 2);\n    do_log(D_SERVER_REQ, \" (0x%lx for 0x%lx)\\n\",\n           (unsigned long)connection, (unsigned long)object);\n\n    if(version != HTTP_10 && version != HTTP_11) {\n        do_log(L_ERROR, \"Unknown server HTTP version\\n\");\n        httpServerAbort(connection, 1, 502,\n                        internAtom(\"Unknown server HTTP version\"));\n        releaseAtom(message);\n        return 1;\n    } \n\n    connection->version = version;\n    connection->server->version = version;\n    request->flags |= REQUEST_PERSISTENT;\n\n    url = internAtomN(object->key, object->key_size);    \n    rc = httpParseHeaders(0, url, connection->buf, rc, request,\n                          &headers, &len, &cache_control, NULL, &te,\n                          &date, &last_modified, &expires, NULL, NULL, NULL,\n                          &age, &etag, NULL, NULL, &content_range,\n                          NULL, &via, NULL);\n    if(rc < 0) {\n        do_log(L_ERROR, \"Couldn't parse server headers\\n\");\n        releaseAtom(url);\n        releaseAtom(message);\n        httpServerAbort(connection, 1, 502, \n                        internAtom(\"Couldn't parse server headers\"));\n        return 1;\n    }\n\n    if(date < 0)\n        date = current_time.tv_sec;\n\n    if(code == 100) {\n        releaseAtom(url);\n        releaseAtom(message);\n        /* We've already reset wait_continue above, but we must still\n           ensure that the writer notices. */\n        notifyObject(request->object);\n        connection->len -= rc;\n        if(connection->len > 0)\n            memmove(connection->buf, connection->buf + rc, connection->len);\n        httpServerReply(connection, 1);\n        return 1;\n    }\n\n    if(code == 101) {\n        httpServerAbort(connection, 1, 501,\n                        internAtom(\"Upgrade not implemented\"));\n        goto fail;\n    }\n\n    if(via && !checkVia(proxyName, via)) {\n        httpServerAbort(connection, 1, 504, internAtom(\"Proxy loop detected\"));\n        goto fail;\n    }\n    full_len = content_range.full_length;\n\n    if(code == 206) {\n        if(content_range.from == -1 || content_range.to == -1) {\n            do_log(L_ERROR, \"Partial content without range.\\n\");\n            httpServerAbort(connection, 1, 502,\n                            internAtom(\"Partial content without range\"));\n            goto fail;\n        }\n        if(len >= 0 && len != content_range.to - content_range.from) {\n            do_log(L_ERROR, \"Inconsistent partial content.\\n\");\n            httpServerAbort(connection, 1, 502,\n                            internAtom(\"Inconsistent partial content\"));\n            goto fail;\n        }\n    } else if(code < 400 && \n              (content_range.from >= 0 || content_range.to >= 0 || \n               content_range.full_length >= 0)) {\n        do_log(L_WARN, \"Range without partial content.\\n\");\n        /* Damn anakata. */\n        content_range.from = -1;\n        content_range.to = -1;\n        content_range.full_length = -1;\n    } else if(code != 304 && code != 412) {\n        full_len = len;\n    }\n\n    if(te != TE_IDENTITY && te != TE_CHUNKED) {\n        do_log(L_ERROR, \"Unsupported transfer-encoding\\n\");\n        httpServerAbort(connection, 1, 502,\n                        internAtom(\"Unsupported transfer-encoding\"));\n        goto fail;\n    }\n\n    if(code == 304) {\n        if(request->method != METHOD_CONDITIONAL_GET) {\n            do_log(L_ERROR, \"Unexpected \\\"not changed\\\" reply from server\\n\");\n            httpServerAbort(connection, 1, 502,\n                            internAtom(\"Unexpected \\\"not changed\\\" \"\n                                       \"reply from server\"));\n            goto fail;\n        }\n        if(object->etag && !etag) {\n            /* RFC 2616 10.3.5.  Violated by some front-end proxies. */\n            do_log(L_WARN, \"\\\"Not changed\\\" reply with no ETag.\\n\");\n        } \n    }\n\n    if(code == 412) {\n        if(request->method != METHOD_CONDITIONAL_GET ||\n           (!object->etag && !object->last_modified)) {\n            do_log(L_ERROR, \n                   \"Unexpected \\\"precondition failed\\\" reply from server.\\n\");\n            httpServerAbort(connection, 1, 502,\n                            internAtom(\"Unexpected \\\"precondition failed\\\" \"\n                                       \"reply from server\"));\n            goto fail;\n        }\n    }\n\n    releaseAtom(url);\n\n    /* Okay, we're going to accept this reply. */\n\n    if((code == 200 || code == 206 || code == 304 || code == 412) &&\n       (cache_control.flags & (CACHE_NO | CACHE_NO_STORE) ||\n        cache_control.max_age == 0 ||\n        (cacheIsShared && cache_control.s_maxage == 0) ||\n        (expires >= 0 && expires <= object->age))) {\n        do_log(L_UNCACHEABLE, \"Uncacheable object %s (%d)\\n\",\n               scrub(object->key), cache_control.flags);\n    }\n\n    if(request->time0.tv_sec != null_time.tv_sec)\n        init_time = &request->time0;\n    else\n        init_time = &current_time;\n    age = MIN(init_time->tv_sec - age, init_time->tv_sec);\n\n    if(request->method == METHOD_HEAD || \n       code < 200 || code == 204 || code == 304)\n        expect_body = 0;\n    else if(te == TE_IDENTITY)\n        expect_body = (len != 0);\n    else\n        expect_body = 1;\n\n    connection->chunk_remaining = -1;\n    connection->te = te;\n\n    old_object = object;\n\n    connection->server->lies--;\n\n    if(object->cache_control & CACHE_MISMATCH)\n        supersede = 1;\n\n    if(code == 304 || code == 412) {\n        if((object->etag && etag && strcmp(object->etag, etag) != 0) ||\n           (object->last_modified >= 0 && last_modified >= 0 &&\n            object->last_modified != last_modified)) {\n            do_log(L_ERROR, \"Inconsistent \\\"%s\\\" reply for %s\\n\",\n                   code == 304 ? \"not changed\":\"precondition failed\",\n                   scrub(object->key));\n            object->flags |= OBJECT_DYNAMIC;\n            supersede = 1;\n        }\n    } else if(!(object->flags & OBJECT_INITIAL)) {\n        if((object->last_modified < 0 || last_modified < 0) &&\n           (!object->etag || !etag))\n            supersede = 1;\n        else if(object->last_modified != last_modified)\n            supersede = 1;\n        else if(object->etag || etag) {\n            /* We need to be permissive here so as to deal with some\n               front-end proxies that discard ETags on partial\n               replies but not on full replies. */\n            if(etag && object->etag && strcmp(object->etag, etag) != 0)\n                supersede = 1;\n            else if(!object->etag)\n                supersede = 1;\n        }\n\n        if(!supersede && (object->cache_control & CACHE_VARY) &&\n           dontTrustVaryETag >= 1) {\n            /* Check content-type to work around mod_gzip bugs */\n            if(!httpHeaderMatch(atomContentType, object->headers, headers) ||\n               !httpHeaderMatch(atomContentEncoding, object->headers, headers))\n                supersede = 1;\n        }\n\n        if(full_len < 0 && te == TE_IDENTITY) {\n            /* It's an HTTP/1.0 CGI.  Be afraid. */\n            if(expect_body && content_range.from < 0 && content_range.to < 0)\n                supersede = 1;\n        }\n\n        if(!supersede && object->length >= 0 && full_len >= 0 &&\n                object->length != full_len) {\n            do_log(L_WARN, \"Inconsistent length.\\n\");\n            supersede = 1;\n        }\n\n        if(!supersede &&\n           ((object->last_modified >= 0 && last_modified >= 0) ||\n            (object->etag && etag))) {\n            if(request->method == METHOD_CONDITIONAL_GET) {\n                do_log(L_WARN, \"Server ignored conditional request.\\n\");\n                connection->server->lies += 10;\n                /* Drop the connection? */\n            }\n        }\n    } else if(code == 416) {\n        do_log(L_ERROR, \"Unexpected \\\"range not satisfiable\\\" reply\\n\");\n        httpServerAbort(connection, 1, 502,\n                        internAtom(\"Unexpected \\\"range not satisfiable\\\" \"\n                                   \"reply\"));\n        /* The object may be superseded.  Make sure the next request\n           won't be partial. */\n        abortObject(object, 502, \n                    internAtom(\"Unexpected \\\"range not satisfiable\\\" reply\"));\n        return 1;\n    }\n\n    if(object->flags & OBJECT_INITIAL)\n        supersede = 0;\n\n    if(supersede) {\n        do_log(L_SUPERSEDED,\n               \"Superseding object %s (%d %d %d %s -> %d %d %d %s)\\n\",\n               scrub(old_object->key),\n               object->code, object->length, (int)object->last_modified,\n               object->etag ? object->etag : \"(none)\",\n               code, full_len, (int)last_modified,\n               etag ? etag : \"(none)\");\n        privatiseObject(old_object, 0);\n        new_object = makeObject(object->type, object->key, \n                                object->key_size, 1, 0, \n                                object->request, NULL);\n        if(new_object == NULL) {\n            do_log(L_ERROR, \"Couldn't allocate object\\n\");\n            httpServerAbort(connection, 1, 500,\n                            internAtom(\"Couldn't allocate object\"));\n            return 1;\n        }\n        if(urlIsLocal(new_object->key, new_object->key_size))\n            new_object->flags |= OBJECT_LOCAL;\n    } else {\n        new_object = object;\n    }\n\n    suspectDynamic =\n        (!etag && last_modified < 0) ||\n        (cache_control.flags &\n         (CACHE_NO_HIDDEN | CACHE_NO | CACHE_NO_STORE |\n          (cacheIsShared ? CACHE_PRIVATE : 0))) ||\n        (cache_control.max_age >= 0 && cache_control.max_age <= 2) ||\n        (cacheIsShared && \n         cache_control.s_maxage >= 0 && cache_control.s_maxage <= 5) ||\n        (old_object->last_modified >= 0 && old_object->expires >= 0 && \n         (old_object->expires - old_object->last_modified <= 1)) ||\n        (supersede && (old_object->date - date <= 5));\n\n    if(suspectDynamic)\n        new_object->flags |= OBJECT_DYNAMIC;\n    else if(!supersede)\n        new_object->flags &= ~OBJECT_DYNAMIC;\n    else if(old_object->flags & OBJECT_DYNAMIC)\n        new_object->flags |= OBJECT_DYNAMIC;\n\n    new_object->age = age;\n    new_object->cache_control |= cache_control.flags;\n    new_object->max_age = cache_control.max_age;\n    new_object->s_maxage = cache_control.s_maxage;\n    new_object->flags &= ~OBJECT_FAILED;\n\n    if(date >= 0)\n        new_object->date = date;\n    if(last_modified >= 0)\n        new_object->last_modified = last_modified;\n    if(expires >= 0)\n        new_object->expires = expires;\n    if(new_object->etag == NULL)\n        new_object->etag = etag;\n    else\n        free(etag);\n\n    switch(code) {\n    case 200:\n    case 300: case 301: case 302: case 303: case 307:\n    case 403: case 404: case 405: case 401:\n        if(new_object->message) releaseAtom(new_object->message);\n        new_object->code = code;\n        new_object->message = message;\n        break;\n    case 206: case 304: case 412:\n        if(new_object->code != 200 || !new_object->message) {\n            if(new_object->message) releaseAtom(new_object->message);\n            new_object->code = 200;\n            new_object->message = internAtom(\"OK\");\n        }\n        releaseAtom(message);\n        break;\n    default:\n        if(new_object->message) releaseAtom(new_object->message);\n        new_object->code = code;\n        new_object->message = retainAtom(message);\n        break;\n    }\n\n    httpTweakCachability(new_object);\n\n    if(!via)\n        new_via = internAtomF(\"%s %s\",\n                              version == HTTP_11 ? \"1.1\" : \"1.0\",\n                              proxyName->string);\n    else\n        new_via = internAtomF(\"%s, %s %s\", via->string,\n                              version == HTTP_11 ? \"1.1\" : \"1.0\",\n                              proxyName->string);\n    if(new_via == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate Via.\\n\");\n    } else {\n        if(new_object->via) releaseAtom(new_object->via);\n        new_object->via = new_via;\n    }\n\n    if(new_object->flags & OBJECT_INITIAL) {\n        objectPartial(new_object, full_len, headers);\n    } else {\n        if(new_object->length < 0)\n            new_object->length = full_len;\n        /* XXX -- RFC 2616 13.5.3 */\n        releaseAtom(headers);\n    }\n\n    if(supersede) {\n        assert(new_object != old_object);\n        supersedeObject(old_object);\n    }\n\n    if(new_object != old_object) {\n        if(new_object->flags & OBJECT_INPROGRESS) {\n            /* Make sure we don't fetch this object two times at the\n               same time.  Just drop the connection. */\n            releaseObject(new_object);\n            httpServerFinish(connection, 1, 0);\n            return 1;\n        }\n        old_object->flags &= ~OBJECT_VALIDATING;\n        new_object->flags |= OBJECT_INPROGRESS;\n        /* Signal the client side to switch to the new object -- see\n           httpClientGetHandler.  If it doesn't, we'll give up on this\n           request below. */\n        new_object->flags |= OBJECT_MUTATING;\n        request->can_mutate = new_object;\n        notifyObject(old_object);\n        request->can_mutate = NULL;\n        new_object->flags &= ~OBJECT_MUTATING;\n        old_object->flags &= ~OBJECT_INPROGRESS;\n        if(request->object == old_object) {\n            if(request->request)\n                request->request->request = NULL;\n            request->request = NULL;\n            request->object = new_object;\n        } else {\n            assert(request->object == new_object);\n        }\n        releaseNotifyObject(old_object);\n        old_object = NULL;\n        object = new_object;\n    } else {\n        objectMetadataChanged(new_object, 0);\n    }\n\n    if(object->flags & OBJECT_VALIDATING) {\n        object->flags &= ~OBJECT_VALIDATING;\n        notifyObject(object);\n    }\n\n    if(!expect_body) {\n        httpServerFinish(connection, 0, rc);\n        return 1;\n    }\n\n    if(request->request == NULL) {\n        httpServerFinish(connection, 1, 0);\n        return 1;\n    }\n\n    if(code == 412) {\n        /* 412 replies contain a useless body.  For now, we\n           drop the connection. */\n        httpServerFinish(connection, 1, 0);\n        return 1;\n    }\n\n\n    if(request->flags & REQUEST_PERSISTENT) {\n        if(request->method != METHOD_HEAD && \n           connection->te == TE_IDENTITY && len < 0) {\n            do_log(L_ERROR, \"Persistent reply with no Content-Length\\n\");\n            /* That's potentially dangerous, as we could start reading\n               arbitrary data into the object.  Unfortunately, some\n               servers do that. */\n            request->flags &= ~REQUEST_PERSISTENT;\n        }\n    }\n\n    /* we're getting a body */\n    if(content_range.from > 0)\n        connection->offset = content_range.from;\n    else\n        connection->offset = 0;\n\n    if(content_range.to >= 0)\n        request->to = content_range.to;\n\n    do_log(D_SERVER_OFFSET, \"0x%lx(0x%lx): offset = %d\\n\",\n           (unsigned long)connection, (unsigned long)object,\n           connection->offset);\n\n    if(connection->len > rc) {\n        rc = connectionAddData(connection, rc);\n        if(rc) {\n            if(rc < 0) {\n                if(rc == -2) {\n                    do_log(L_ERROR, \"Couldn't parse chunk size.\\n\");\n                    httpServerAbort(connection, 1, 502,\n                                    internAtom(\"Couldn't parse chunk size\"));\n                } else {\n                    do_log(L_ERROR, \"Couldn't add data to connection.\\n\");\n                    httpServerAbort(connection, 1, 500, \n                                    internAtom(\"Couldn't add data \"\n                                               \"to connection\"));\n                }\n                return 1;\n            } else {\n                if(code != 206) {\n                    if(object->length < 0) {\n                        object->length = object->size;\n                        objectMetadataChanged(object, 0);\n                    } else if(object->length != object->size) {\n                        httpServerAbort(connection, 1, 500, \n                                        internAtom(\"Inconsistent \"\n                                                   \"object size\"));\n                        object->length = -1;\n                        return 1;\n                    }\n                }\n                httpServerFinish(connection, 0, 0);\n                return 1;\n            }\n        }\n    } else {\n        connection->len = 0;\n    }\n\n    if(eof) {\n        if(connection->te == TE_CHUNKED ||\n           (object->length >= 0 && \n            connection->offset < object->length)) {\n            do_log(L_ERROR, \"Server closed connection.\\n\");\n            httpServerAbort(connection, 1, 502,\n                            internAtom(\"Server closed connection\"));\n            return 1;\n        } else {\n            if(code != 206 && eof > 0 && object->length < 0) {\n                object->length = object->size;\n                objectMetadataChanged(object, 0);\n            }\n            httpServerFinish(connection, 1, 0);\n            return 1;\n        }\n    } else {\n        return httpServerReadData(connection, 1);\n    }\n    return 0;\n\n fail:\n    releaseAtom(url);\n    releaseAtom(message);\n    if(headers)\n        releaseAtom(headers);\n    if(etag)\n        free(etag);\n    if(via)\n        releaseAtom(via);\n    return 1;\n}\n\nint\nhttpServerIndirectHandlerCommon(HTTPConnectionPtr connection, int eof)\n{\n    HTTPRequestPtr request = connection->request;\n\n    assert(eof >= 0);\n    assert(request->object->flags & OBJECT_INPROGRESS);\n\n    if(connection->len > 0) {\n        int rc;\n        rc = connectionAddData(connection, 0);\n        if(rc) {\n            if(rc < 0) {\n                if(rc == -2) {\n                    do_log(L_ERROR, \"Couldn't parse chunk size.\\n\");\n                    httpServerAbort(connection, 1, 502,\n                                    internAtom(\"Couldn't parse chunk size\"));\n                } else {\n                    do_log(L_ERROR, \"Couldn't add data to connection.\\n\");\n                    httpServerAbort(connection, 1, 500,\n                                    internAtom(\"Couldn't add data \"\n                                               \"to connection\"));\n                }\n                return 1;\n            } else {\n                if(request->to < 0) {\n                    if(request->object->length < 0) {\n                        request->object->length = request->object->size;\n                        objectMetadataChanged(request->object, 0);\n                    } else if(request->object->length != \n                              request->object->size) {\n                        request->object->length = -1;\n                        httpServerAbort(connection, 1, 502,\n                                        internAtom(\"Inconsistent \"\n                                                   \"object size\"));\n                        return 1;\n                    }\n                }\n                httpServerFinish(connection, 0, 0);\n            }\n            return 1;\n        }\n    }\n\n    if(eof && connection->len == 0) {\n        if(connection->te == TE_CHUNKED ||\n           (request->to >= 0 && connection->offset < request->to)) {\n            do_log(L_ERROR, \"Server dropped connection.\\n\");\n            httpServerAbort(connection, 1, 502, \n                            internAtom(\"Server dropped connection\"));\n            return 1;\n        } else {\n            if(request->object->length < 0 && eof > 0 &&\n               (request->to < 0 || request->to > request->object->size)) {\n                request->object->length = request->object->size;\n                objectMetadataChanged(request->object, 0);\n            }\n            httpServerFinish(connection, 1, 0);\n            return 1;\n        }\n    } else {\n        return httpServerReadData(connection, 0);\n    }\n}\n\nint\nhttpServerIndirectHandler(int status,\n                          FdEventHandlerPtr event, \n                          StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    assert(connection->request->object->flags & OBJECT_INPROGRESS);\n\n    httpSetTimeout(connection, -1);\n    if(status < 0) {\n        if(status != -ECLIENTRESET)\n            do_log_error(L_ERROR, -status, \"Read from server failed\");\n        httpServerAbort(connection, status != -ECLIENTRESET, 502,\n                        internAtomError(-status, \"Read from server failed\"));\n        return 1;\n    }\n\n    connection->len = srequest->offset;\n\n    return httpServerIndirectHandlerCommon(connection, status);\n}\n\nint\nhttpServerReadData(HTTPConnectionPtr connection, int immediate)\n{\n    HTTPRequestPtr request = connection->request;\n    ObjectPtr object = request->object;\n    int to = -1;\n\n    assert(object->flags & OBJECT_INPROGRESS);\n\n    if(request->request == NULL) {\n        httpServerFinish(connection, 1, 0);\n        return 1;\n    }\n\n    if(request->to >= 0)\n        to = request->to;\n    else\n        to = object->length;\n\n    if(to >= 0 && to == connection->offset) {\n        httpServerFinish(connection, 0, 0);\n        return 1;\n    }\n\n    if(connection->len == 0 &&\n       ((connection->te == TE_IDENTITY && to > connection->offset) ||\n        (connection->te == TE_CHUNKED && connection->chunk_remaining > 0))) {\n        /* Read directly into the object */\n        int i = connection->offset / CHUNK_SIZE;\n        int j = connection->offset % CHUNK_SIZE;\n        int end, len, more;\n        /* See httpServerDirectHandlerCommon if you change this */\n        if(connection->te == TE_CHUNKED) {\n            len = connection->chunk_remaining;\n            /* The logic here is that we want more to just fit the\n               chunk header if we're doing a large read, but do a\n               large read if we would otherwise do a small one.  The\n               magic constant 2000 comes from the assumption that the\n               server uses chunks that have a size that are a power of\n               two (possibly including the chunk header), and that we\n               want a full ethernet packet to fit into our read. */\n            more = (len >= 2000 ? 20 : MIN(2048 - len, CHUNK_SIZE));\n        } else {\n            len = to - connection->offset;\n            /* We read more data only when there is a reasonable\n               chance of there being another reply coming. */\n            more = (connection->pipelined > 1) ? CHUNK_SIZE : 0;\n        }\n        end = len + connection->offset;\n\n        httpConnectionDestroyBuf(connection);\n\n        /* The order of allocation is important in case we run out of\n           memory. */\n        lockChunk(object, i);\n        if(object->chunks[i].data == NULL)\n            object->chunks[i].data = get_chunk();\n        if(object->chunks[i].data && object->chunks[i].size >= j) {\n            if(len + j > CHUNK_SIZE) {\n                lockChunk(object, i + 1);\n                if(object->chunks[i + 1].data == NULL)\n                    object->chunks[i + 1].data = get_chunk();\n                /* Unless we're grabbing all len of data, we do not\n                   want to do an indirect read immediately afterwards. */\n                if(more && len + j <= 2 * CHUNK_SIZE) {\n                    if(!connection->buf)\n                        connection->buf = get_chunk(); /* checked below */\n                }\n                if(object->chunks[i + 1].data) {\n                    do_stream_3(IO_READ | IO_NOTNOW, connection->fd, j,\n                                object->chunks[i].data, CHUNK_SIZE,\n                                object->chunks[i + 1].data,\n                                MIN(CHUNK_SIZE,\n                                    end - (i + 1) * CHUNK_SIZE),\n                                connection->buf, connection->buf ? more : 0,\n                                httpServerDirectHandler2, connection);\n                    return 1;\n                }\n                unlockChunk(object, i + 1);\n            }\n            if(more && len + j <= CHUNK_SIZE) {\n                if(!connection->buf)\n                    connection->buf = get_chunk();\n            }\n            do_stream_2(IO_READ | IO_NOTNOW, connection->fd, j,\n                        object->chunks[i].data,\n                        MIN(CHUNK_SIZE, end - i * CHUNK_SIZE),\n                        connection->buf, connection->buf ? more : 0,\n                        httpServerDirectHandler, connection);\n            return 1;\n        } else {\n            unlockChunk(object, i);\n        }\n    }\n       \n    if(connection->len == 0)\n        httpConnectionDestroyBuf(connection);\n\n    httpSetTimeout(connection, serverTimeout);\n    do_stream_buf(IO_READ | IO_NOTNOW |\n                  ((immediate && connection->len) ? IO_IMMEDIATE : 0),\n                  connection->fd, connection->len,\n                  &connection->buf,\n                  (connection->te == TE_CHUNKED ? \n                   MIN(2048, CHUNK_SIZE) : CHUNK_SIZE),\n                  httpServerIndirectHandler, connection);\n    return 1;\n}\n\nint\nhttpServerDirectHandlerCommon(int kind, int status,\n                              FdEventHandlerPtr event, \n                              StreamRequestPtr srequest)\n{\n    HTTPConnectionPtr connection = srequest->data;\n    HTTPRequestPtr request = connection->request;\n    ObjectPtr object = request->object;\n    int i = connection->offset / CHUNK_SIZE;\n    int to, end, end1;\n\n    assert(request->object->flags & OBJECT_INPROGRESS);\n\n    httpSetTimeout(connection, -1);\n\n    if(status < 0) {\n        unlockChunk(object, i);\n        if(kind == 2) unlockChunk(object, i + 1);\n        if(status != -ECLIENTRESET)\n            do_log_error(L_ERROR, -status, \"Read from server failed\");\n        httpServerAbort(connection, status != -ECLIENTRESET, 502,\n                        internAtomError(-status, \"Read from server failed\"));\n        return 1;\n    }\n\n    /* We have incestuous knowledge of the decisions made in\n       httpServerReadData */\n    if(request->to >= 0)\n        to = request->to;\n    else\n        to = object->length;\n    if(connection->te == TE_CHUNKED)\n        end = connection->offset + connection->chunk_remaining;\n    else\n        end = to;\n    /* The amount of data actually read into the object */\n    end1 = MIN(end, i * CHUNK_SIZE + MIN(kind * CHUNK_SIZE, srequest->offset));\n\n    assert(end >= 0);\n    assert(end1 >= i * CHUNK_SIZE);\n    assert(end1 - 2 * CHUNK_SIZE <= i * CHUNK_SIZE);\n\n    object->chunks[i].size = \n        MAX(object->chunks[i].size, MIN(end1 - i * CHUNK_SIZE, CHUNK_SIZE));\n    if(kind == 2 && end1 > (i + 1) * CHUNK_SIZE) {\n        object->chunks[i + 1].size =\n            MAX(object->chunks[i + 1].size, end1 - (i + 1) * CHUNK_SIZE);\n    }\n    if(connection->te == TE_CHUNKED) {\n        connection->chunk_remaining -= (end1 - connection->offset);\n        assert(connection->chunk_remaining >= 0);\n    }\n    connection->offset = end1;\n    object->size = MAX(object->size, end1);\n    unlockChunk(object, i);\n    if(kind == 2) unlockChunk(object, i + 1);\n\n    if(i * CHUNK_SIZE + srequest->offset > end1) {\n        connection->len = i * CHUNK_SIZE + srequest->offset - end1;\n        return httpServerIndirectHandlerCommon(connection, status);\n    } else {\n        notifyObject(object);\n        if(status) {\n            if(connection->te == TE_CHUNKED ||\n               (end >= 0 && connection->offset < end)) {\n                do_log(L_ERROR, \"Server dropped connection.\\n\");\n                httpServerAbort(connection, 1, 502, \n                                internAtom(\"Server dropped connection\"));\n            } else\n                httpServerFinish(connection, 1, 0);\n            return 1;\n        } else {\n            return httpServerReadData(connection, 0);\n        }\n    }\n}\n\nint\nhttpServerDirectHandler(int status,\n                        FdEventHandlerPtr event, \n                        StreamRequestPtr srequest)\n{\n    return httpServerDirectHandlerCommon(1, status, event, srequest);\n}\n    \nint\nhttpServerDirectHandler2(int status,\n                         FdEventHandlerPtr event, \n                         StreamRequestPtr srequest)\n{\n    return httpServerDirectHandlerCommon(2, status, event, srequest);\n}\n\n/* Add the data accumulated in connection->buf into the object in\n   connection->request.  Returns 0 in the normal case, 1 if the TE is\n   self-terminating and we're done, -1 if there was a problem with\n   objectAddData, -2 if there was a problem with the data. */\nint\nconnectionAddData(HTTPConnectionPtr connection, int skip)\n{\n    HTTPRequestPtr request = connection->request;\n    ObjectPtr object = request->object;\n    int rc;\n\n    if(connection->te == TE_IDENTITY) {\n        int len;\n        \n        len = connection->len - skip;\n        if(object->length >= 0) {\n            len = MIN(object->length - connection->offset, len);\n        }\n        if(request->to >= 0)\n            len = MIN(request->to - connection->offset, len);\n        if(len > 0) {\n            rc = objectAddData(object, connection->buf + skip,\n                               connection->offset, len);\n            if(rc < 0)\n                return -1;\n            connection->offset += len;\n            connection->len -= (len + skip);\n            do_log(D_SERVER_OFFSET, \"0x%lx(0x%lx): offset = %d\\n\",\n                   (unsigned long)connection, (unsigned long)object,\n                   connection->offset);\n        }\n\n        if(connection->len > 0 && skip + len > 0) {\n            memmove(connection->buf,\n                    connection->buf + skip + len, connection->len);\n        }\n\n        if((object->length >= 0 && object->length <= connection->offset) ||\n           (request->to >= 0 && request->to <= connection->offset)) {\n            notifyObject(object);\n            return 1;\n        } else {\n            if(len > 0)\n                notifyObject(object);\n            return 0;\n        }\n    } else if(connection->te == TE_CHUNKED) {\n        int i = skip, j, size;\n        /* connection->chunk_remaining is 0 at the end of a chunk, -1\n           after the CR/LF pair ending a chunk, and -2 after we've\n           seen a chunk of length 0. */\n        if(connection->chunk_remaining > -2) {\n            while(1) {\n                if(connection->chunk_remaining <= 0) {\n                    if(connection->chunk_remaining == 0) {\n                        if(connection->len < i + 2)\n                            break;\n                        if(connection->buf[i] != '\\r' ||\n                           connection->buf[i + 1] != '\\n')\n                            return -1;\n                        i += 2;\n                        connection->chunk_remaining = -1;\n                    }\n                    if(connection->len < i + 2)\n                        break;\n                    j = parseChunkSize(connection->buf, i,\n                                       connection->len, &size);\n                    if(j < 0)\n                        return -2;\n                    if(j == 0)\n                        break;\n                    else\n                        i = j;\n                    if(size == 0) {\n                        connection->chunk_remaining = -2;\n                        break;\n                    } else {\n                        connection->chunk_remaining = size;\n                    }\n                } else {\n                    /* connection->chunk_remaining > 0 */\n                    size = MIN(connection->chunk_remaining,\n                               connection->len - i);\n                    if(size <= 0)\n                        break;\n                    rc = objectAddData(object, connection->buf + i,\n                                       connection->offset, size);\n                    connection->offset += size;\n                    if(rc < 0)\n                        return -1;\n                    i += size;\n                    connection->chunk_remaining -= size;\n                    do_log(D_SERVER_OFFSET, \"0x%lx(0x%lx): offset = %d\\n\",\n                           (unsigned long)connection, \n                           (unsigned long)object,\n                           connection->offset);\n                }\n            }\n        }\n        connection->len -= i;\n        if(connection->len > 0)\n            memmove(connection->buf, connection->buf + i, connection->len);\n        if(i > 0 || connection->chunk_remaining == -2)\n            notifyObject(object);\n        if(connection->chunk_remaining == -2)\n            return 1;\n        else\n            return 0;\n    } else {\n        abort();\n    }\n}\n\nvoid\nlistServers(FILE *out)\n{\n    HTTPServerPtr server;\n    int i, n, m, entry;\n\n    fprintf(out, \"<!DOCTYPE HTML PUBLIC \"\n            \"\\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \"\n            \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n            \"<html><head>\\n\"\n            \"\\r\\n<title>Known servers</title>\\n\"\n           \"</head><body>\\n\"\n            \"<h1>Known servers</h1>\\n\");\n\n    alternatingHttpStyle(out, \"servers\");\n    fprintf(out, \"<table id=servers>\\n\");\n    fprintf(out, \"<thead><tr><th>Server</th>\"\n            \"<th>Version</th>\"\n            \"<th>Persistent</th>\"\n            \"<th>Pipeline</th>\"\n            \"<th>Connections</th>\"\n            \"<th></th>\"\n            \"<th>rtt</th>\"\n            \"<th>rate</th>\"\n            \"</tr></thead>\\n\");\n    fprintf(out, \"<tbody>\\n\");\n    server = servers;\n    entry = 0;\n    while(server) {\n        fprintf(out, \"<tr class=\\\"%s\\\">\", entry % 2 == 0 ? \"even\" : \"odd\");\n        if(server->port == 80)\n            fprintf(out, \"<td>%s</td>\", server->name);\n        else\n            fprintf(out, \"<td>%s:%d</td>\", server->name, server->port);\n\n        if(server->version == HTTP_11)\n            fprintf(out, \"<td>1.1</td>\");\n        else if(server->version == HTTP_10)\n            fprintf(out, \"<td>1.0</td>\");\n        else\n            fprintf(out, \"<td>unknown</td>\");\n\n        if(server->persistent < 0)\n            fprintf(out, \"<td>no</td>\");\n        else if(server->persistent > 0)\n            fprintf(out, \"<td>yes</td>\");\n        else\n            fprintf(out, \"<td>unknown</td>\");\n\n        if(server->version != HTTP_11 || server->persistent <= 0)\n            fprintf(out, \"<td></td>\");\n        else if(server->pipeline < 0)\n            fprintf(out, \"<td>no</td>\");\n        else if(server->pipeline >= 0 && server->pipeline <= 1)\n            fprintf(out, \"<td>unknown</td>\");\n        else if(server->pipeline == 2 || server->pipeline == 3)\n            fprintf(out, \"<td>probing</td>\");\n        else \n            fprintf(out, \"<td>yes</td>\");\n\n        n = 0; m = 0;\n        for(i = 0; i < server->maxslots; i++)\n            if(server->connection[i] && !server->connection[i]->connecting) {\n                if(i < server->numslots)\n                    n++;\n                else\n                    m++;\n            }\n            \n        fprintf(out, \"<td>%d/%d\", n, server->numslots);\n        if(m)\n            fprintf(out, \" + %d</td>\", m);\n        else\n            fprintf(out, \"</td>\");\n\n        if(server->lies > 0)\n            fprintf(out, \"<td>(%d lies)</td>\", (server->lies + 9) / 10);\n        else\n            fprintf(out, \"<td></td>\");\n\n        if(server->rtt > 0)\n            fprintf(out, \"<td>%.3f</td>\", (double)server->rtt / 1000000.0);\n        else\n            fprintf(out, \"<td></td>\");\n        if(server->rate > 0)\n            fprintf(out, \"<td>%d</td>\", server->rate);\n        else\n            fprintf(out, \"<td></td>\");\n\n        fprintf(out, \"</tr>\\n\");\n        server = server->next;\n        entry++;\n    }\n    fprintf(out, \"</tbody>\\n\");\n    fprintf(out, \"</table>\\n\");\n    fprintf(out, \"<p><a href=\\\"/polipo/\\\">back</a></p>\");\n    fprintf(out, \"</body></html>\\n\");\n}\n"
        },
        {
          "name": "server.h",
          "type": "blob",
          "size": 4.435546875,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nextern int serverExpireTime, dontCacheRedirects;\n\ntypedef struct _HTTPServer {\n    char *name;\n    int port;\n    int addrindex;\n    int isProxy;\n    int version;\n    int persistent;\n    int pipeline;\n    int lies;\n    int rtt;\n    int rate;\n    time_t time;\n    int numslots;\n    int maxslots;\n    HTTPConnectionPtr *connection;\n    FdEventHandlerPtr *idleHandler;\n    HTTPRequestPtr request, request_last;\n    struct _HTTPServer *next;\n} HTTPServerRec, *HTTPServerPtr;\n\nextern AtomPtr parentHost;\nextern int parentPort;\n\nvoid preinitServer(void);\nvoid initServer(void);\n\nvoid httpServerAbortHandler(ObjectPtr object);\nint httpMakeServerRequest(char *name, int port, ObjectPtr object, \n                          int method, int from, int to,\n                          HTTPRequestPtr requestor);\nint httpServerQueueRequest(HTTPServerPtr server, HTTPRequestPtr request);\nint httpServerTrigger(HTTPServerPtr server);\nint httpServerSideRequest(HTTPServerPtr server);\nint  httpServerDoSide(HTTPConnectionPtr connection);\nint httpServerSideHandler(int status,\n                          FdEventHandlerPtr event,\n                          StreamRequestPtr srequest);\nint httpServerSideHandler2(int status,\n                           FdEventHandlerPtr event,\n                           StreamRequestPtr srequest);\nint httpServerConnectionDnsHandler(int status, \n                                   GethostbynameRequestPtr request);\nint httpServerConnectionHandler(int status,\n                                FdEventHandlerPtr event,\n                                ConnectRequestPtr request);\nint httpServerSocksHandler(int status, SocksRequestPtr request);\nint httpServerConnectionHandlerCommon(int status,\n                                      HTTPConnectionPtr connection);\nvoid httpServerFinish(HTTPConnectionPtr connection, int s, int offset);\n\nvoid httpServerReply(HTTPConnectionPtr connection, int immediate);\nvoid httpServerAbort(HTTPConnectionPtr connection, int, int, struct _Atom *);\nvoid httpServerAbortRequest(HTTPRequestPtr request, int, int, struct _Atom *);\nvoid httpServerClientReset(HTTPRequestPtr request);\nvoid httpServerUnpipeline(HTTPRequestPtr request);\nint\nhttpServerSendRequest(HTTPConnectionPtr connection);\nint\nhttpServerHandler(int status, \n                    FdEventHandlerPtr event,\n                    StreamRequestPtr request);\nint\nhttpServerReplyHandler(int status,\n                       FdEventHandlerPtr event, \n                       StreamRequestPtr request);\nint\nhttpServerIndirectHandler(int status,\n                          FdEventHandlerPtr event, \n                          StreamRequestPtr request);\nint\nhttpServerDirectHandler(int status,\n                        FdEventHandlerPtr event, \n                        StreamRequestPtr request);\nint\nhttpServerDirectHandler2(int status,\n                         FdEventHandlerPtr event, \n                         StreamRequestPtr request);\nint httpServerRequest(ObjectPtr object, int method, int from, int to,\n                      HTTPRequestPtr, void*);\nint httpServerHandlerHeaders(int eof,\n                             FdEventHandlerPtr event,\n                             StreamRequestPtr request, \n                             HTTPConnectionPtr connection);\nint httpServerReadData(HTTPConnectionPtr, int);\nint connectionAddData(HTTPConnectionPtr connection, int skip);\nint \nhttpWriteRequest(HTTPConnectionPtr connection, HTTPRequestPtr request, int);\n\nvoid listServers(FILE*);\n"
        },
        {
          "name": "socks.c",
          "type": "blob",
          "size": 16.2587890625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifdef NO_SOCKS\n\nAtomPtr socksParentProxy = NULL;\n\nvoid\npreinitSocks()\n{\n    return;\n}\n\nvoid\ninitSocks()\n{\n    return;\n}\n\nint\ndo_socks_connect(char *name, int port,\n                 int (*handler)(int, SocksRequestPtr),\n                 void *data)\n{\n    SocksRequestRec request;\n    request.name = internAtomLowerN(name, strlen(name));\n    request.port = port;\n    request.handler = handler;\n    request.buf = NULL;\n    request.data = data;\n\n    handler(-ENOSYS, &request);\n    releaseAtom(request.name);\n    return 1;\n}\n\n#else\n\nint authed = -1;\nAtomPtr socksParentProxy = NULL;\nAtomPtr socksProxyHost = NULL;\nint socksProxyPort = -1;\nAtomPtr socksProxyAddress = NULL;\nint socksProxyAddressIndex = -1;\nAtomPtr socksUserName = NULL;\nAtomPtr socksPassWord = NULL;\nAtomPtr socksProxyType = NULL;\nAtomPtr aSocks4a, aSocks5;\n\nstatic int socksParentProxySetter(ConfigVariablePtr, void*);\nstatic int socksProxyTypeSetter(ConfigVariablePtr, void*);\nstatic int do_socks_connect_common(SocksRequestPtr);\nstatic int socksDnsHandler(int, GethostbynameRequestPtr);\nstatic int socksConnectHandler(int, FdEventHandlerPtr, ConnectRequestPtr);\nstatic int socksWriteHandler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int socksReadHandler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int socks5ReadHandler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int socks5ReadHandlerAuth(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int socks5WriteHandler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int socks5ReadHandler2(int, FdEventHandlerPtr, StreamRequestPtr);\n\nvoid\npreinitSocks()\n{\n    AtomPtr socksAuthCredentials = internAtom(\"\");\n\n    aSocks4a = internAtom(\"socks4a\");\n    aSocks5 = internAtom(\"socks5\");\n    socksProxyType = retainAtom(aSocks5);\n    socksUserName = internAtom(\"\");\n    socksPassWord = internAtom(\"\");\n\n    CONFIG_VARIABLE_SETTABLE(socksParentProxy, CONFIG_ATOM_LOWER,\n                             socksParentProxySetter,\n                             \"SOCKS parent proxy (host:port)\");\n    CONFIG_VARIABLE_SETTABLE(socksAuthCredentials, CONFIG_PASSWORD,\n                             configAtomSetter,\n                             \"SOCKS4a (or SOCKS5) credentials username:password\");\n    CONFIG_VARIABLE_SETTABLE(socksProxyType, CONFIG_ATOM_LOWER,\n                             socksProxyTypeSetter,\n                             \"One of socks4a or socks5\");\n\n\n    // infer username and password from credentials\n    int rc = atomSplit(socksAuthCredentials, ':', &socksUserName, &socksPassWord);\n    if (rc < 0) {\n      do_log(L_ERROR, \"Error splitting credentials\");\n      exit(1);\n    } else if (rc == 0) {\n      // separator ':' not found\n      socksUserName = socksAuthCredentials;\n      releaseAtom(socksPassWord);\n      socksPassWord = NULL;\n    } else {\n      // split successfull: free memory\n      releaseAtom(socksAuthCredentials);\n    }\n}\n\nstatic int\nsocksParentProxySetter(ConfigVariablePtr var, void *value)\n{\n    configAtomSetter(var, value);\n    initSocks();\n    return 1;\n}\n\nstatic int\nsocksProxyTypeSetter(ConfigVariablePtr var, void *value)\n{\n    if(*var->value.a != aSocks4a && *var->value.a != aSocks5) {\n        do_log(L_ERROR, \"Unknown socksProxyType %s\\n\", (*var->value.a)->string);\n        return -1;\n    }\n\n    return configAtomSetter(var, value);\n}\n\nvoid\ninitSocks()\n{\n    int port = -1;\n    AtomPtr host = NULL, port_atom;\n    int rc;\n\n    if(socksParentProxy != NULL && socksParentProxy->length == 0) {\n        releaseAtom(socksParentProxy);\n        socksParentProxy = NULL;\n    }\n\n    if(socksParentProxy) {\n        rc = atomSplit(socksParentProxy, ':', &host, &port_atom);\n        if(rc <= 0) {\n            do_log(L_ERROR, \"Couldn't parse socksParentProxy\");\n            exit(1);\n        }\n        port = atoi(port_atom->string);\n        releaseAtom(port_atom);\n    }\n\n    if(socksProxyHost)\n        releaseAtom(socksProxyHost);\n    socksProxyHost = host;\n    socksProxyPort = port;\n    if(socksProxyAddress)\n        releaseAtom(socksProxyAddress);\n    socksProxyAddress = NULL;\n    socksProxyAddressIndex = -1;\n\n    if(socksProxyType != aSocks4a && socksProxyType != aSocks5) {\n        do_log(L_ERROR, \"Unknown socksProxyType %s\\n\", socksProxyType->string);\n        exit(1);\n    }\n}\n\nstatic void\ndestroySocksRequest(SocksRequestPtr request)\n{\n    releaseAtom(request->name);\n    if(request->buf)\n        free(request->buf);\n    free(request);\n}\n\nint\ndo_socks_connect(char *name, int port,\n                 int (*handler)(int, SocksRequestPtr),\n                 void *data)\n{\n    SocksRequestPtr request = malloc(sizeof(SocksRequestRec));\n    SocksRequestRec request_nomem;\n    if(request == NULL)\n        goto nomem;\n\n    request->name = internAtomLowerN(name, strlen(name));\n    if(request->name == NULL) {\n        free(request);\n        goto nomem;\n    }\n\n    request->port = port;\n    request->fd = -1;\n    request->handler = handler;\n    request->buf = NULL;\n    request->data = data;\n\n    if(socksProxyAddress == NULL) {\n        do_gethostbyname(socksProxyHost->string, 0,\n                         socksDnsHandler,\n                         request);\n        return 1;\n    }\n\n    return do_socks_connect_common(request);\n\n nomem:\n    request_nomem.name = internAtomLowerN(name, strlen(name));\n    request_nomem.port = port;\n    request_nomem.handler = handler;\n    request_nomem.buf = NULL;\n    request_nomem.data = data;\n\n    handler(-ENOMEM, &request_nomem);\n    releaseAtom(request_nomem.name);\n    return 1;\n}\n\nstatic int\ndo_socks_connect_common(SocksRequestPtr request)\n{\n    assert(socksProxyAddressIndex >= 0);\n\n    do_connect(retainAtom(socksProxyAddress),\n               socksProxyAddressIndex,\n               socksProxyPort,\n               socksConnectHandler, request);\n    return 1;\n}\n\nstatic int\nsocksDnsHandler(int status, GethostbynameRequestPtr grequest)\n{\n    SocksRequestPtr request = grequest->data;\n    if(status <= 0) {\n        request->handler(status, request);\n        destroySocksRequest(request);\n        return 1;\n    }\n\n    if(grequest->addr->string[0] == DNS_CNAME) {\n        if(grequest->count > 10) {\n            do_log(L_ERROR, \"DNS CNAME loop.\\n\");\n            request->handler(-EDNS_CNAME_LOOP, request);\n            destroySocksRequest(request);\n            return 1;\n        }\n        do_gethostbyname(grequest->addr->string + 1, grequest->count + 1,\n                         socksDnsHandler, request);\n        return 1;\n    }\n\n\n    socksProxyAddress = retainAtom(grequest->addr);\n    socksProxyAddressIndex = 0;\n\n    do_socks_connect_common(request);\n    return 1;\n}\n\nstatic int\nsocksConnectHandler(int status,\n                    FdEventHandlerPtr event,\n                    ConnectRequestPtr crequest)\n{\n    SocksRequestPtr request = crequest->data;\n    int rc;\n\n    if(status < 0) {\n        request->handler(status, request);\n        destroySocksRequest(request);\n        return 1;\n    }\n\n    assert(request->fd < 0);\n    request->fd = crequest->fd;\n    socksProxyAddressIndex = crequest->index;\n\n    rc = setNodelay(request->fd, 1);\n    if(rc < 0)\n        do_log_error(L_WARN, errno, \"Couldn't disable Nagle's algorithm\");\n\n    if(socksProxyType == aSocks4a) {\n        request->buf = malloc(8 +\n                              socksUserName->length + 1 +\n                              request->name->length + 1);\n        if(request->buf == NULL) {\n            CLOSE(request->fd);\n            request->fd = -1;\n            request->handler(-ENOMEM, request);\n            destroySocksRequest(request);\n            return 1;\n        }\n\n        request->buf[0] = 4;        /* VN */\n        request->buf[1] = 1;        /* CD = REQUEST */\n        request->buf[2] = (request->port >> 8) & 0xFF;\n        request->buf[3] = request->port & 0xFF;\n        request->buf[4] = request->buf[5] = request->buf[6] = 0;\n        request->buf[7] = 3;\n\n        memcpy(request->buf + 8, socksUserName->string, socksUserName->length);\n        request->buf[8 + socksUserName->length] = '\\0';\n\n        memcpy(request->buf + 8 + socksUserName->length + 1,\n               request->name->string, request->name->length);\n        request->buf[8 + socksUserName->length + 1 + request->name->length] =\n            '\\0';\n\n        do_stream(IO_WRITE, request->fd, 0, request->buf,\n                  8 + socksUserName->length + 1 + request->name->length + 1,\n                  socksWriteHandler, request);\n    } else if(socksProxyType == aSocks5) {\n        request->buf = malloc(8); /* 8 needed for the subsequent read */\n        if(request->buf == NULL) {\n            CLOSE(request->fd);\n            request->fd = -1;\n            request->handler(-ENOMEM, request);\n            destroySocksRequest(request);\n            return 1;\n        }\n        request->buf[0] = 5;             /* ver */\n        request->buf[1] = 1;             /* nmethods */\n\tif (socksPassWord == NULL) {\n            request->buf[2] = 0;             /* no authentication required */\n\t} else {\n            request->buf[2] = 2;             /* username/password */\n\t}\n        do_stream(IO_WRITE, request->fd, 0, request->buf, 3,\n                  socksWriteHandler, request);\n    } else {\n        request->handler(-EUNKNOWN, request);\n    }\n    return 1;\n}\n\nstatic int\nsocksWriteHandler(int status,\n                  FdEventHandlerPtr event,\n                  StreamRequestPtr srequest)\n{\n    SocksRequestPtr request = srequest->data;\n\n    if(status < 0)\n        goto error;\n\n    if(!streamRequestDone(srequest)) {\n        if(status) {\n            status = -ESOCKS_PROTOCOL;\n            goto error;\n        }\n        return 0;\n    }\n\n    int (*readHandler)(int, FdEventHandlerPtr, StreamRequestPtr) = NULL;\n    if (socksProxyType == aSocks4a){\n      readHandler = socksReadHandler;\n    } else if (socksPassWord == NULL) {\n      readHandler = socks5ReadHandler;\n    } else if (socksPassWord != NULL) {\n      readHandler = socks5ReadHandlerAuth;\n    }\n\n    do_stream(IO_READ | IO_NOTNOW, request->fd, 0, request->buf, 8, readHandler, request);\n    return 1;\n\n error:\n    CLOSE(request->fd);\n    request->fd = -1;\n    request->handler(status, request);\n    destroySocksRequest(request);\n    return 1;\n}\n\nstatic int\nsocksReadHandler(int status,\n                 FdEventHandlerPtr event,\n                 StreamRequestPtr srequest)\n{\n    SocksRequestPtr request = srequest->data;\n\n    if(status < 0)\n        goto error;\n\n    if(srequest->offset < 8) {\n        if(status) {\n            status = -ESOCKS_PROTOCOL;\n            goto error;\n        }\n        return 0;\n    }\n\n    if(request->buf[0] != 0 || request->buf[1] != 90) {\n        if(request->buf[1] >= 91 && request->buf[1] <= 93)\n            status = -(ESOCKS_PROTOCOL + request->buf[1] - 90);\n        else\n            status = -ESOCKS_PROTOCOL;\n        goto error;\n    }\n\n    request->handler(1, request);\n    destroySocksRequest(request);\n    return 1;\n\n error:\n    CLOSE(request->fd);\n    request->fd = -1;\n    request->handler(status, request);\n    destroySocksRequest(request);\n    return 1;\n}\n\nstatic int\nsocks5ReadHandlerAuth(int status,\n                  FdEventHandlerPtr event,\n                  StreamRequestPtr srequest)\n{\n    SocksRequestPtr request = srequest->data;\n\n    if(status < 0)\n        goto error;\n\n    if(srequest->offset < 2) {\n        if(status) {\n            status = -ESOCKS_PROTOCOL;\n            goto error;\n        }\n        return 0;\n    }\n\n    if(request->buf[0] != 5 || request->buf[1] != 2) {\n        status = -ESOCKS_PROTOCOL;\n        goto error;\n    }\n\n    free(request->buf);\n    request->buf = malloc(5 + socksUserName->length + socksPassWord->length);\n    if(request->buf == NULL) {\n        status = -ENOMEM;\n        goto error;\n    }\n\n    request->buf[0] = 1;\t/* ver */\n    request->buf[1] = socksUserName->length;\t/* username length */\n    memcpy(request->buf + 2, socksUserName->string, socksUserName->length);\n    request->buf[2 + socksUserName->length] = socksPassWord->length;\t/* password length */\n    memcpy(request->buf + 3 + socksUserName->length, socksPassWord->string, socksPassWord->length);\n\n    do_stream(IO_WRITE, request->fd, 0,\n              request->buf, 3 + socksUserName->length + socksPassWord->length,\n              socks5WriteHandler, request);\n    return 1;\n\n error:\n    CLOSE(request->fd);\n    request->fd = -1;\n    request->handler(status, request);\n    destroySocksRequest(request);\n    return 1;\n}\n\n\nstatic int\nsocks5ReadHandler(int status,\n                  FdEventHandlerPtr event,\n                  StreamRequestPtr srequest)\n{\n    SocksRequestPtr request = srequest->data;\n\n    if(status < 0)\n        goto error;\n\n    if(srequest->offset < 2) {\n        if(status) {\n            status = -ESOCKS_PROTOCOL;\n            goto error;\n        }\n        return 0;\n    }\n\n    if(request->buf[1] != 0 ||\n       (socksPassWord != NULL && request->buf[0] != 1) || // user/pass: need ver 1\n       (socksPassWord == NULL && request->buf[0] != 5))   // no-auth:   need ver 5\n      {\n        status = -ESOCKS_PROTOCOL;\n        goto error;\n    }\n    authed = 1;\n    free(request->buf);\n    request->buf = malloc(5 + request->name->length + 2);\n    if(request->buf == NULL) {\n        status = -ENOMEM;\n        goto error;\n    }\n\n    request->buf[0] = 5;        /* ver */\n    request->buf[1] = 1;        /* cmd */\n    request->buf[2] = 0;        /* rsv */\n    request->buf[3] = 3;        /* atyp */\n    request->buf[4] = request->name->length;\n    memcpy(request->buf + 5, request->name->string, request->name->length);\n    request->buf[5 + request->name->length] = (request->port >> 8) & 0xFF;\n    request->buf[5 + request->name->length + 1] = request->port & 0xFF;\n\n    do_stream(IO_WRITE, request->fd, 0,\n              request->buf, 5 + request->name->length + 2,\n              socks5WriteHandler, request);\n    return 1;\n\n error:\n    CLOSE(request->fd);\n    request->fd = -1;\n    request->handler(status, request);\n    destroySocksRequest(request);\n    return 1;\n}\n\nstatic int\nsocks5WriteHandler(int status,\n                   FdEventHandlerPtr event,\n                   StreamRequestPtr srequest)\n{\n    SocksRequestPtr request = srequest->data;\n\n    if(status < 0)\n        goto error;\n\n    if(!streamRequestDone(srequest)) {\n        if(status) {\n            status = -ESOCKS_PROTOCOL;\n            goto error;\n        }\n        return 0;\n    }\n\n    do_stream(IO_READ | IO_NOTNOW, request->fd, 0, request->buf, 10,\n              ((socksPassWord != NULL) && (authed == -1) ? socks5ReadHandler : socks5ReadHandler2),\n\t      request);\n    return 1;\n\n error:\n    request->handler(status, request);\n    destroySocksRequest(request);\n    return 1;\n}\n\nstatic int\nsocks5ReadHandler2(int status,\n                   FdEventHandlerPtr event,\n                   StreamRequestPtr srequest)\n{\n    SocksRequestPtr request = srequest->data;\n    authed = -1;\n    if(status < 0)\n        goto error;\n\n    if(srequest->offset < 4) {\n        if(status) {\n            status = -ESOCKS_PROTOCOL;\n            goto error;\n        }\n        return 0;\n    }\n\n    if(request->buf[0] != 5) {\n        status = -ESOCKS_PROTOCOL;\n        goto error;\n    }\n\n    if(request->buf[1] != 0) {\n        status = -(ESOCKS5_BASE + request->buf[1]);\n        goto error;\n    }\n\n    if(request->buf[3] != 1) {\n        status = -ESOCKS_PROTOCOL;\n        goto error;\n    }\n\n    if(srequest->offset < 10)\n        return 0;\n\n    request->handler(1, request);\n    destroySocksRequest(request);\n    return 1;\n\n error:\n    CLOSE(request->fd);\n    request->fd = -1;\n    request->handler(status, request);\n    destroySocksRequest(request);\n    return 1;\n}\n\n#endif\n"
        },
        {
          "name": "socks.h",
          "type": "blob",
          "size": 1.3896484375,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nextern AtomPtr socksParentProxy;\n\ntypedef struct _SocksRequest {\n    AtomPtr name;\n    int port;\n    int fd;\n    int (*handler)(int, struct _SocksRequest*);\n    char *buf;\n    void *data;\n} SocksRequestRec, *SocksRequestPtr;\n\nvoid preinitSocks(void);\nvoid initSocks(void);\nint do_socks_connect(char*, int, int (*)(int, SocksRequestPtr), void*);\n"
        },
        {
          "name": "tunnel.c",
          "type": "blob",
          "size": 16.98828125,
          "content": "/*\nCopyright (c) 2004-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n#ifdef NO_TUNNEL\n\nvoid\ndo_tunnel(int fd, char *buf, int offset, int len, AtomPtr url)\n{\n    int n;\n    assert(buf);\n\n    n = httpWriteErrorHeaders(buf, CHUNK_SIZE, 0, 1,\n                              501, internAtom(\"CONNECT not available \"\n                                              \"in this version.\"),\n                              1, NULL, url->string, url->length, NULL);\n    releaseAtom(url);\n    if(n >= 0) {\n        /* This is completely wrong.  The write is non-blocking, and we \n           don't reschedule it if it fails.  But then, if the write\n           blocks, we'll simply drop the connection with no error message. */\n        write(fd, buf, n);\n    }\n    dispose_chunk(buf);\n    lingeringClose(fd);\n    return;\n}\n\n#else\n\nstatic void tunnelDispatch(TunnelPtr);\nstatic int tunnelRead1Handler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int tunnelRead2Handler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int tunnelWrite1Handler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int tunnelWrite2Handler(int, FdEventHandlerPtr, StreamRequestPtr);\nstatic int tunnelDnsHandler(int, GethostbynameRequestPtr);\nstatic int tunnelConnectionHandler(int, FdEventHandlerPtr, ConnectRequestPtr);\nstatic int tunnelSocksHandler(int, SocksRequestPtr);\nstatic int tunnelHandlerCommon(int, TunnelPtr);\nstatic int tunnelError(TunnelPtr, int, AtomPtr);\n\nstatic int\ncircularBufferFull(CircularBufferPtr buf)\n{\n    if(buf->head == buf->tail - 1)\n        return 1;\n    if(buf->head == CHUNK_SIZE - 1 && buf->tail == 0)\n        return 1;\n    return 0;\n}\n\nstatic int\ncircularBufferEmpty(CircularBufferPtr buf)\n{\n     return buf->head == buf->tail;\n}\n\nstatic void\nlogTunnel(TunnelPtr tunnel, int blocked)\n{\n    do_log(L_TUNNEL,\"tunnel %s:%d %s\\n\", tunnel->hostname->string, tunnel->port,\n\t   blocked ? \"blocked\" : \"allowed\");\n}\n\nstatic TunnelPtr\nmakeTunnel(int fd, char *buf, int offset, int len)\n{\n    TunnelPtr tunnel;\n    assert(offset < CHUNK_SIZE);\n\n    tunnel = malloc(sizeof(TunnelRec));\n    if(tunnel == NULL)\n        return NULL;\n\n    tunnel->hostname = NULL;\n    tunnel->port = -1;\n    tunnel->flags = 0;\n    tunnel->fd1 = fd;\n    tunnel->fd2 = -1;\n    tunnel->buf1.buf = buf;\n    if(offset == len) {\n        tunnel->buf1.tail = 0;\n        tunnel->buf1.head = 0;\n    } else {\n        tunnel->buf1.tail = offset;\n        tunnel->buf1.head = len;\n    }\n    tunnel->buf2.buf = NULL;\n    tunnel->buf2.tail = 0;\n    tunnel->buf2.head = 0;\n    return tunnel;\n}\n\nstatic void\ndestroyTunnel(TunnelPtr tunnel)\n{\n    assert(tunnel->fd1 < 0 && tunnel->fd2 < 0);\n    releaseAtom(tunnel->hostname);\n    if(tunnel->buf1.buf)\n        dispose_chunk(tunnel->buf1.buf);\n    if(tunnel->buf2.buf)\n        dispose_chunk(tunnel->buf2.buf);\n    free(tunnel);\n}\n\nvoid \ndo_tunnel(int fd, char *buf, int offset, int len, AtomPtr url)\n{\n    TunnelPtr tunnel;\n    int port;\n    char *p, *q;\n\n    tunnel = makeTunnel(fd, buf, offset, len);\n    if(tunnel == NULL) {\n        do_log(L_ERROR, \"Couldn't allocate tunnel.\\n\");\n        releaseAtom(url);\n        dispose_chunk(buf);\n        CLOSE(fd);\n        return;\n    }\n\n    if(proxyOffline) {\n        do_log(L_INFO, \"Attemted CONNECT when disconnected.\\n\");\n        releaseAtom(url);\n        tunnelError(tunnel, 502,\n                    internAtom(\"Cannot CONNECT when disconnected.\"));\n        return;\n    }\n\n    p = memrchr(url->string, ':', url->length);\n    q = NULL;\n    if(p)\n        port = strtol(p + 1, &q, 10);\n    if(!p || q != url->string + url->length) {\n        do_log(L_ERROR, \"Couldn't parse CONNECT.\\n\");\n        releaseAtom(url);\n        tunnelError(tunnel, 400, internAtom(\"Couldn't parse CONNECT\"));\n        return;\n    }\n    tunnel->hostname = internAtomLowerN(url->string, p - url->string);\n    if(tunnel->hostname == NULL) {\n        releaseAtom(url);\n        tunnelError(tunnel, 501, internAtom(\"Couldn't allocate hostname\"));\n        return;\n    }\n\n    if(!intListMember(port, tunnelAllowedPorts)) {\n        releaseAtom(url);\n        tunnelError(tunnel, 403, internAtom(\"Forbidden port\"));\n        return;\n    }\n    tunnel->port = port;\n    \n    if (tunnelIsMatched(url->string, url->length, \n\t\t\ttunnel->hostname->string, tunnel->hostname->length)) {\n        releaseAtom(url);\n        tunnelError(tunnel, 403, internAtom(\"Forbidden tunnel\"));\n\tlogTunnel(tunnel,1);\n        return;\n    }\n    \n    logTunnel(tunnel,0);\n    \n    releaseAtom(url);\n\n    if(socksParentProxy)\n        do_socks_connect(parentHost ?\n                         parentHost->string : tunnel->hostname->string,\n                         parentHost ? parentPort : tunnel->port,\n                         tunnelSocksHandler, tunnel);\n    else\n        do_gethostbyname(parentHost ?\n                         parentHost->string : tunnel->hostname->string, 0,\n                         tunnelDnsHandler, tunnel);\n}\n\nstatic int\ntunnelDnsHandler(int status, GethostbynameRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n\n    if(status <= 0) {\n        tunnelError(tunnel, 504,\n                    internAtomError(-status, \n                                    \"Host %s lookup failed\",\n                                    atomString(tunnel->hostname)));\n        return 1;\n    }\n\n    if(request->addr->string[0] == DNS_CNAME) {\n        if(request->count > 10)\n            tunnelError(tunnel, 504, internAtom(\"CNAME loop\"));\n        do_gethostbyname(request->addr->string + 1, request->count + 1,\n                         tunnelDnsHandler, tunnel);\n        return 1;\n    }\n\n    do_connect(retainAtom(request->addr), 0,\n               parentHost ? parentPort : tunnel->port,\n               tunnelConnectionHandler, tunnel);\n    return 1;\n}\n\nstatic int\ntunnelConnectionHandler(int status,\n                        FdEventHandlerPtr event,\n                        ConnectRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n    int rc;\n\n    if(status < 0) {\n        tunnelError(tunnel, 504, internAtomError(-status, \"Couldn't connect\"));\n        return 1;\n    }\n\n    rc = setNodelay(request->fd, 1);\n    if(rc < 0)\n        do_log_error(L_WARN, errno, \"Couldn't disable Nagle's algorithm\");\n\n    return tunnelHandlerCommon(request->fd, tunnel);\n}\n\nstatic int\ntunnelSocksHandler(int status, SocksRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n\n    if(status < 0) {\n        tunnelError(tunnel, 504, internAtomError(-status, \"Couldn't connect\"));\n        return 1;\n    }\n\n    return tunnelHandlerCommon(request->fd, tunnel);\n}\n\nstatic int\ntunnelHandlerParent(int fd, TunnelPtr tunnel)\n{\n    char *message;\n    int n;\n\n    if(tunnel->buf1.buf == NULL)\n        tunnel->buf1.buf = get_chunk();\n    if(tunnel->buf1.buf == NULL) {\n        message = \"Couldn't allocate buffer\";\n        goto fail;\n    }\n    if(tunnel->buf1.tail != tunnel->buf1.head) {\n        message = \"Pipelined connect to parent proxy not implemented\";\n        goto fail;\n    }\n\n    n = snnprintf(tunnel->buf1.buf, tunnel->buf1.tail, CHUNK_SIZE,\n                  \"CONNECT %s:%d HTTP/1.1\\r\\nHost: %s\",\n                  tunnel->hostname->string, tunnel->port, tunnel->hostname->string);\n    if (tunnel->port != 443)\n        n = snnprintf(tunnel->buf1.buf, n, CHUNK_SIZE, \":%d\", tunnel->port);\n    if (parentAuthCredentials)\n        n = buildServerAuthHeaders(tunnel->buf1.buf, n, CHUNK_SIZE,\n                                   parentAuthCredentials);\n    n = snnprintf(tunnel->buf1.buf, n, CHUNK_SIZE, \"\\r\\n\\r\\n\");\n\n    if(n < 0) {\n        message = \"Buffer overflow\";\n        goto fail;\n    }\n    tunnel->buf1.head = n;\n    tunnelDispatch(tunnel);\n    return 1;\n\n fail:\n    CLOSE(fd);\n    tunnel->fd2 = -1;\n    tunnelError(tunnel, 501, internAtom(message));\n    return 1;\n}\n\nstatic int\ntunnelHandlerCommon(int fd, TunnelPtr tunnel)\n{\n    const char *message = \"HTTP/1.1 200 Tunnel established\\r\\n\\r\\n\";\n\n    tunnel->fd2 = fd;\n\n    if(parentHost)\n        return tunnelHandlerParent(fd, tunnel);\n\n    if(tunnel->buf2.buf == NULL)\n        tunnel->buf2.buf = get_chunk();\n    if(tunnel->buf2.buf == NULL) {\n        CLOSE(fd);\n        tunnelError(tunnel, 501, internAtom(\"Couldn't allocate buffer\"));\n        return 1;\n    }\n\n    memcpy(tunnel->buf2.buf, message, MIN(CHUNK_SIZE - 1, strlen(message)));\n    tunnel->buf2.head = MIN(CHUNK_SIZE - 1, strlen(message));\n\n    tunnelDispatch(tunnel);\n    return 1;\n}\n\nstatic void\nbufRead(int fd, CircularBufferPtr buf,\n        int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n        void *data)\n{\n    int tail;\n\n    if(buf->tail == 0)\n        tail = CHUNK_SIZE - 1;\n    else\n        tail = buf->tail - 1;\n\n    if(buf->head == 0)\n        do_stream_buf(IO_READ | IO_NOTNOW,\n                      fd, 0,\n                      &buf->buf, tail,\n                      handler, data);\n    else if(buf->tail > buf->head)\n        do_stream(IO_READ | IO_NOTNOW,\n                  fd, buf->head,\n                  buf->buf, tail,\n                  handler, data);\n    else \n        do_stream_2(IO_READ | IO_NOTNOW,\n                    fd, buf->head,\n                    buf->buf, CHUNK_SIZE,\n                    buf->buf, tail,\n                    handler, data);\n}\n\nstatic void\nbufWrite(int fd, CircularBufferPtr buf,\n        int (*handler)(int, FdEventHandlerPtr, StreamRequestPtr),\n        void *data)\n{\n    if(buf->head > buf->tail)\n        do_stream(IO_WRITE,\n                  fd, buf->tail,\n                  buf->buf, buf->head,\n                  handler, data);\n    else\n        do_stream_2(IO_WRITE,\n                    fd, buf->tail,\n                    buf->buf, CHUNK_SIZE,\n                    buf->buf, buf->head,\n                    handler, data);\n}\n                    \nstatic void\ntunnelDispatch(TunnelPtr tunnel)\n{\n    if(circularBufferEmpty(&tunnel->buf1)) {\n        if(tunnel->buf1.buf && \n           !(tunnel->flags & (TUNNEL_READER1 | TUNNEL_WRITER2))) {\n            dispose_chunk(tunnel->buf1.buf);\n            tunnel->buf1.buf = NULL;\n            tunnel->buf1.head = tunnel->buf1.tail = 0;\n        }\n    }\n\n    if(circularBufferEmpty(&tunnel->buf2)) {\n        if(tunnel->buf2.buf &&\n           !(tunnel->flags & (TUNNEL_READER2 | TUNNEL_WRITER1))) {\n            dispose_chunk(tunnel->buf2.buf);\n            tunnel->buf2.buf = NULL;\n            tunnel->buf2.head = tunnel->buf2.tail = 0;\n        }\n    }\n\n    if(tunnel->fd1 >= 0) {\n        if(!(tunnel->flags & (TUNNEL_READER1 | TUNNEL_EOF1)) && \n           !circularBufferFull(&tunnel->buf1)) {\n            tunnel->flags |= TUNNEL_READER1;\n            bufRead(tunnel->fd1, &tunnel->buf1, tunnelRead1Handler, tunnel);\n        }\n        if(!(tunnel->flags & (TUNNEL_WRITER1 | TUNNEL_EPIPE1)) &&\n           !circularBufferEmpty(&tunnel->buf2)) {\n            tunnel->flags |= TUNNEL_WRITER1;\n            /* There's no IO_NOTNOW in bufWrite, so it might close the\n               file descriptor straight away.  Wait until we're\n               rescheduled. */\n            bufWrite(tunnel->fd1, &tunnel->buf2, tunnelWrite1Handler, tunnel);\n            return;\n        }\n        if(tunnel->fd2 < 0 || (tunnel->flags & TUNNEL_EOF2)) {\n            if(!(tunnel->flags & TUNNEL_EPIPE1))\n                shutdown(tunnel->fd1, 1);\n            tunnel->flags |= TUNNEL_EPIPE1;\n        } else if(tunnel->fd1 < 0 || (tunnel->flags & TUNNEL_EPIPE2)) {\n            if(!(tunnel->flags & TUNNEL_EOF1))\n                shutdown(tunnel->fd1, 0);\n            tunnel->flags |= TUNNEL_EOF1;\n        }\n        if((tunnel->flags & TUNNEL_EOF1) && (tunnel->flags & TUNNEL_EPIPE1)) {\n            if(!(tunnel->flags & (TUNNEL_READER1 | TUNNEL_WRITER1))) {\n                CLOSE(tunnel->fd1);\n                tunnel->fd1 = -1;\n            }\n        }\n    }\n\n    if(tunnel->fd2 >= 0) {\n        if(!(tunnel->flags & (TUNNEL_READER2 | TUNNEL_EOF2)) && \n           !circularBufferFull(&tunnel->buf2)) {\n            tunnel->flags |= TUNNEL_READER2;\n            bufRead(tunnel->fd2, &tunnel->buf2, tunnelRead2Handler, tunnel);\n        }\n        if(!(tunnel->flags & (TUNNEL_WRITER2 | TUNNEL_EPIPE2)) &&\n           !circularBufferEmpty(&tunnel->buf1)) {\n            tunnel->flags |= TUNNEL_WRITER2;\n            bufWrite(tunnel->fd2, &tunnel->buf1, tunnelWrite2Handler, tunnel);\n            return;\n        }\n        if(tunnel->fd1 < 0 || (tunnel->flags & TUNNEL_EOF1)) {\n            if(!(tunnel->flags & TUNNEL_EPIPE2))\n                shutdown(tunnel->fd2, 1);\n            tunnel->flags |= TUNNEL_EPIPE2;\n        } else if(tunnel->fd1 < 0 || (tunnel->flags & TUNNEL_EPIPE1)) {\n            if(!(tunnel->flags & TUNNEL_EOF2))\n                shutdown(tunnel->fd2, 0);\n            tunnel->flags |= TUNNEL_EOF2;\n        }\n        if((tunnel->flags & TUNNEL_EOF2) && (tunnel->flags & TUNNEL_EPIPE2)) {\n            if(!(tunnel->flags & (TUNNEL_READER2 | TUNNEL_WRITER2))) {\n                CLOSE(tunnel->fd2);\n                tunnel->fd2 = -1;\n            }\n        }\n    }\n\n    if(tunnel->fd1 < 0 && tunnel->fd2 < 0)\n        destroyTunnel(tunnel);\n    else\n        assert(tunnel->flags & (TUNNEL_READER1 | TUNNEL_WRITER1 |\n                                TUNNEL_READER2 | TUNNEL_WRITER2));\n}\n\nstatic int\ntunnelRead1Handler(int status, \n                   FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n    if(status) {\n        if(status < 0 && status != -EPIPE && status != -ECONNRESET)\n            do_log_error(L_ERROR, -status, \"Couldn't read from client\");\n        tunnel->flags |= TUNNEL_EOF1;\n        goto done;\n    }\n    tunnel->buf1.head = request->offset % CHUNK_SIZE;\n done:\n    /* Keep buffer empty to avoid a deadlock */\n    if((tunnel->flags & TUNNEL_EPIPE2))\n        tunnel->buf1.tail = tunnel->buf1.head;\n    tunnel->flags &= ~TUNNEL_READER1;\n    tunnelDispatch(tunnel);\n    return 1;\n}\n\nstatic int\ntunnelRead2Handler(int status, \n                   FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n    if(status) {\n        if(status < 0 && status != -EPIPE && status != -ECONNRESET)\n            do_log_error(L_ERROR, -status, \"Couldn't read from server\");\n        tunnel->flags |= TUNNEL_EOF2;\n        goto done;\n    }\n    tunnel->buf2.head = request->offset % CHUNK_SIZE;\ndone:\n    /* Keep buffer empty to avoid a deadlock */\n    if((tunnel->flags & TUNNEL_EPIPE1))\n        tunnel->buf2.tail = tunnel->buf2.head;\n    tunnel->flags &= ~TUNNEL_READER2;\n    tunnelDispatch(tunnel);\n    return 1;\n}\n\nstatic int\ntunnelWrite1Handler(int status,\n                   FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n    if(status || (tunnel->flags & TUNNEL_EPIPE1)) {\n        tunnel->flags |= TUNNEL_EPIPE1;\n        if(status < 0 && status != -EPIPE)\n            do_log_error(L_ERROR, -status, \"Couldn't write to client\");\n        /* Empty the buffer to avoid a deadlock */\n        tunnel->buf2.tail = tunnel->buf2.head;\n        goto done;\n    }\n    tunnel->buf2.tail = request->offset % CHUNK_SIZE;\n done:\n    tunnel->flags &= ~TUNNEL_WRITER1;\n    tunnelDispatch(tunnel);\n    return 1;\n}\n        \nstatic int\ntunnelWrite2Handler(int status,\n                   FdEventHandlerPtr event, StreamRequestPtr request)\n{\n    TunnelPtr tunnel = request->data;\n    if(status || (tunnel->flags & TUNNEL_EPIPE2)) {\n        tunnel->flags |= TUNNEL_EPIPE2;\n        if(status < 0 && status != -EPIPE)\n            do_log_error(L_ERROR, -status, \"Couldn't write to server\");\n        /* Empty the buffer to avoid a deadlock */\n        tunnel->buf1.tail = tunnel->buf1.head;\n        goto done;\n    }\n    tunnel->buf1.tail = request->offset % CHUNK_SIZE;\n done:\n    tunnel->flags &= ~TUNNEL_WRITER2;\n    tunnelDispatch(tunnel);\n    return 1;\n}\n        \nstatic int\ntunnelError(TunnelPtr tunnel, int code, AtomPtr message)\n{\n    int n;\n    if(tunnel->fd2 > 0) {\n        CLOSE(tunnel->fd2);\n        tunnel->fd2 = -1;\n    }\n\n    if(tunnel->buf2.buf == NULL)\n        tunnel->buf2.buf = get_chunk();\n    if(tunnel->buf2.buf == NULL)\n        goto fail;\n\n    n = httpWriteErrorHeaders(tunnel->buf2.buf, CHUNK_SIZE - 1, 0,\n                              1, code, message, 1, NULL,\n                              NULL, 0, NULL);\n\n    if(n <= 0) goto fail;\n\n    tunnel->buf2.head = n;\n\n    tunnelDispatch(tunnel);\n    return 1;\n\n fail:\n    CLOSE(tunnel->fd1);\n    tunnel->fd1 = -1;\n    tunnelDispatch(tunnel);\n    return 1;\n}\n#endif\n"
        },
        {
          "name": "tunnel.h",
          "type": "blob",
          "size": 1.6376953125,
          "content": "/*\nCopyright (c) 2004-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ntypedef struct _CircularBuffer {\n    int head;\n    int tail;\n    char *buf;\n} CircularBufferRec, *CircularBufferPtr;\n\n#define TUNNEL_READER1 1\n#define TUNNEL_WRITER1 2\n#define TUNNEL_EOF1 4\n#define TUNNEL_EPIPE1 8\n#define TUNNEL_READER2 16\n#define TUNNEL_WRITER2 32\n#define TUNNEL_EOF2 64\n#define TUNNEL_EPIPE2 128\n\ntypedef struct _Tunnel {\n    AtomPtr hostname;\n    int port;\n    int flags;\n    int fd1;\n    CircularBufferRec buf1;\n    int fd2;\n    CircularBufferRec buf2;\n} TunnelRec, *TunnelPtr;\n\nvoid do_tunnel(int fd, char *buf, int offset, int len, AtomPtr url);\n\nvoid listTunnels(FILE *out);\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 17.7666015625,
          "content": "/*\nCopyright (c) 2003-2007 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n#include \"polipo.h\"\n\n/* Note that this is different from GNU's strndup(3). */\nchar *\nstrdup_n(const char *restrict buf, int n)\n{\n    char *s;\n    s = malloc(n + 1);\n    if(s == NULL)\n        return NULL;\n    memcpy(s, buf, n);\n    s[n] = '\\0';\n    return s;\n}\n\nint\nsnnprintf(char *restrict buf, int n, int len, const char *format, ...)\n{\n    va_list args;\n    int rc;\n    va_start(args, format);\n    rc = snnvprintf(buf, n, len, format, args);\n    va_end(args);\n    return rc;\n}\n\nint\nsnnvprintf(char *restrict buf, int n, int len, const char *format, va_list args)\n{\n    int rc = -1;\n    va_list args_copy;\n\n    if(n < 0) return -2;\n    if(n < len) {\n        va_copy(args_copy, args);\n        rc = vsnprintf(buf + n, len - n, format, args_copy);\n        va_end(args_copy);\n    }\n    if(rc >= 0 && n + rc <= len)\n        return n + rc;\n    else\n        return -1;\n}\n\nint\nsnnprint_n(char *restrict buf, int n, int len, const char *s, int slen)\n{\n    int i = 0;\n    if(n < 0) return -2;\n    while(i < slen && n < len)\n        buf[n++] = s[i++];\n    if(n < len)\n        return n;\n    else\n        return -1;\n}\n\nint\nletter(char c)\n{\n    if(c >= 'A' && c <= 'Z') return 1;\n    if(c >= 'a' && c <= 'z') return 1;\n    return 0;\n}\n\nint\ndigit(char c)\n{\n    if(c >= '0' && c <= '9')\n        return 1;\n    return 0;\n}\n\nchar\nlwr(char a)\n{\n    if(a >= 'A' && a <= 'Z')\n        return a | 0x20;\n    else\n        return a;\n}\n\nchar *\nlwrcpy(char *restrict dst, const char *restrict src, int n)\n{\n    int i;\n    for(i = 0; i < n; i++)\n        dst[i] = lwr(src[i]);\n    return dst;\n}\n\nint\nlwrcmp(const char *as, const char *bs, int n)\n{\n    int i;\n    for(i = 0; i < n; i++) {\n        char a = lwr(as[i]), b = lwr(bs[i]);\n        if(a < b)\n            return -1;\n        else if(a > b)\n            return 1;\n    }\n    return 0;\n}\n\nint\nstrcasecmp_n(const char *string, const char *buf, int n)\n{\n    int i;\n    i = 0;\n    while(string[i] != '\\0' && i < n) {\n        char a = lwr(string[i]), b = lwr(buf[i]);\n        if(a < b)\n            return -1;\n        else if(a > b)\n            return 1;\n        i++;\n    }\n    if(string[i] == '\\0' && i == n)\n        return 0;\n    else if(i == n)\n        return 1;\n    else\n        return -1;\n}\n\nint\natoi_n(const char *restrict string, int n, int len, int *value_return)\n{\n    int i = n;\n    int val = 0;\n\n    if(i >= len || !digit(string[i]))\n        return -1;\n\n    while(i < len && digit(string[i])) {\n        val = val * 10 + (string[i] - '0');\n        i++;\n    }\n    *value_return = val;\n    return i;\n}\n\nint \nisWhitespace(const char *string)\n{\n    while(*string != '\\0') {\n        if(*string == ' ' || *string == '\\t')\n            string++;\n        else\n            return 0;\n    }\n    return 1;\n}\n\n#ifndef HAVE_MEMRCHR\nvoid *\nmemrchr(const void *s, int c, size_t n)\n{\n    const unsigned char *ss = s;\n    unsigned char cc = c;\n    size_t i;\n    for(i = 1; i <= n; i++)\n        if(ss[n - i] == cc)\n            return (void*)(ss + n - i);\n    return NULL;\n}\n#endif\n\nint\nh2i(char h) \n{\n    if(h >= '0' && h <= '9')\n        return h - '0';\n    else if(h >= 'a' && h <= 'f')\n        return h - 'a' + 10;\n    else if(h >= 'A' && h <= 'F')\n        return h - 'A' + 10;\n    else\n        return -1;\n}\n    \nchar\ni2h(int i)\n{\n    if(i < 0 || i >= 16)\n        return '?';\n    if(i < 10)\n        return i + '0';\n    else\n        return i - 10 + 'A';\n}\n\n/* floor(log2(x)) */\nint\nlog2_floor(int x) \n{\n    int i, j;\n\n    assert(x > 0);\n\n    i = 0;\n    j = 1;\n    while(2 * j <= x) {\n        i++;\n        j *= 2;\n    }\n    return i;\n}\n\n/* ceil(log2(x)) */\nint\nlog2_ceil(int x) \n{\n    int i, j;\n\n    assert(x > 0);\n\n    i = 0;\n    j = 1;\n    while(j < x) {\n        i++;\n        j *= 2;\n    }\n    return i;\n}\n\n#ifdef HAVE_ASPRINTF\nchar *\nvsprintf_a(const char *f, va_list args)\n{\n    char *r;\n    int rc;\n    va_list args_copy;\n\n    va_copy(args_copy, args);\n    rc = vasprintf(&r, f, args_copy);\n    va_end(args_copy);\n    if(rc < 0)\n        return NULL;\n    return r;\n    \n}\n\n#else\n\nchar*\nvsprintf_a(const char *f, va_list args)\n{\n    int n, size;\n    char buf[64];\n    char *string;\n    va_list args_copy;\n\n    va_copy(args_copy, args);\n    n = vsnprintf(buf, 64, f, args_copy);\n    va_end(args_copy);\n    if(n >= 0 && n < 64) {\n        return strdup_n(buf, n);\n    }\n    if(n >= 64)\n        size = n + 1;\n    else\n        size = 96;\n\n    while(1) {\n        string = malloc(size);\n        if(!string)\n            return NULL;\n        va_copy(args_copy, args);\n        n = vsnprintf(string, size, f, args_copy);\n        va_end(args_copy);\n        if(n >= 0 && n < size) {\n            return string;\n        } else if(n >= size)\n            size = n + 1;\n        else\n            size = size * 3 / 2;\n        free(string);\n        if(size > 16 * 1024)\n            return NULL;\n    }\n    /* NOTREACHED */\n}\n#endif\n\nchar*\nsprintf_a(const char *f, ...)\n{\n    char *s;\n    va_list args;\n    va_start(args, f);\n    s = vsprintf_a(f, args);\n    va_end(args);\n    return s;\n}    \n\nunsigned int\nhash(unsigned int seed, const void *restrict key, int key_size,\n     unsigned int hash_size)\n{\n    int i;\n    unsigned int h;\n\n    h = seed;\n    for(i = 0; i < key_size; i++)\n        h = (h << 5) + (h >> (hash_size - 5)) +\n            ((unsigned char*)key)[i];\n    return h & ((1 << hash_size) - 1);\n}\n\nchar *\npstrerror(int e)\n{\n    char *s;\n    static char buf[20];\n\n    switch(e) {\n    case EDOSHUTDOWN: s = \"Immediate shutdown requested\"; break;\n    case EDOGRACEFUL: s = \"Graceful shutdown requested\"; break;\n    case EDOTIMEOUT: s = \"Timeout\"; break;\n    case ECLIENTRESET: s = \"Connection reset by client\"; break;\n    case ESYNTAX: s = \"Incorrect syntax\"; break;\n    case EREDIRECTOR: s = \"Redirector error\"; break;\n    case EDNS_HOST_NOT_FOUND: s = \"Host not found\"; break;\n    case EDNS_NO_ADDRESS: s = \"No address\"; break;\n    case EDNS_NO_RECOVERY: s = \"Permanent name server failure\"; break;\n    case EDNS_TRY_AGAIN: s = \"Temporary name server failure\"; break;\n    case EDNS_INVALID: s = \"Invalid reply from name server\"; break;\n    case EDNS_UNSUPPORTED: s = \"Unsupported DNS reply\"; break;\n    case EDNS_FORMAT: s = \"Invalid DNS query\"; break;\n    case EDNS_REFUSED: s = \"DNS query refused by server\"; break;\n    case EDNS_CNAME_LOOP: s = \"DNS CNAME loop\"; break;\n#ifndef NO_SOCKS\n    case ESOCKS_PROTOCOL: s = \"SOCKS protocol error\"; break;\n    case ESOCKS_REJECT_FAIL: s = \"SOCKS request rejected or failed\"; break;\n    case ESOCKS_REJECT_IDENTD: s = \"SOCKS request rejected: \"\n                                   \"server couldn't connect to identd\";\n        break;\n    case ESOCKS_REJECT_UID_MISMATCH: s = \"SOCKS request rejected: \"\n                                         \"uid mismatch\";\n        break;\n    case ESOCKS5_BASE: s = \"SOCKS success\"; break;\n    case ESOCKS5_BASE + 1: s = \"General SOCKS server failure\"; break;\n    case ESOCKS5_BASE + 2: s = \"SOCKS connection not allowed\"; break;\n    case ESOCKS5_BASE + 3: s = \"SOCKS error: network unreachable\"; break;\n    case ESOCKS5_BASE + 4: s = \"SOCKS error: host unreachable\"; break;\n    case ESOCKS5_BASE + 5: s = \"SOCKS error: connection refused\"; break;\n    case ESOCKS5_BASE + 6: s = \"SOCKS error: TTL expired\"; break;\n    case ESOCKS5_BASE + 7: s = \"SOCKS command not supported\"; break;\n    case ESOCKS5_BASE + 8: s = \"SOCKS error: address type not supported\";\n        break;\n#endif\n    case EUNKNOWN: s = \"Unknown error\"; break;\n    default: s = NULL; break;\n    }\n    if(!s) s = strerror(e);\n#ifdef WIN32 /*MINGW*/\n    if(!s) {\n        if(e >= WSABASEERR && e <= WSABASEERR + 2000) {\n            /* This should be okay, as long as the caller discards the\n               pointer before another error occurs. */\n            snprintf(buf, 20, \"Winsock error %d\", e);\n            s = buf;\n        }\n    }\n#endif\n    if(!s) {\n        snprintf(buf, 20, \"Unknown error %d\", e);\n        s = buf;\n    }\n    return s;\n}\n\n/* Like mktime(3), but UTC rather than local time */\n#if defined(HAVE_TIMEGM)\ntime_t\nmktime_gmt(struct tm *tm)\n{\n    return timegm(tm);\n}\n#elif defined(HAVE_MKGMTIME)\ntime_t\nmktime_gmt(struct tm *tm)\n{\n    return _mkgmtime(tm);\n}\n#elif defined(HAVE_TM_GMTOFF)\ntime_t\nmktime_gmt(struct tm *tm)\n{\n    time_t t;\n    struct tm *ltm;\n\n    t = mktime(tm);\n    if(t < 0)\n        return -1;\n    ltm = localtime(&t);\n    if(ltm == NULL)\n        return -1;\n    return t + ltm->tm_gmtoff;\n}\n#elif defined(HAVE_TZSET)\n#ifdef HAVE_SETENV\n/* Taken from the Linux timegm(3) man page. */\ntime_t\nmktime_gmt(struct tm *tm)\n{\n    time_t t;\n    char *tz;\n\n    tz = getenv(\"TZ\");\n    setenv(\"TZ\", \"GMT\", 1);\n    tzset();\n    t = mktime(tm);\n    if(tz)\n        setenv(\"TZ\", tz, 1);\n    else\n        unsetenv(\"TZ\");\n    tzset();\n    return t;\n}\n#else\ntime_t\nmktime_gmt(struct tm *tm)\n{\n    time_t t;\n    char *tz;\n    static char *old_tz = NULL;\n\n    tz = getenv(\"TZ\");\n    putenv(\"TZ=GMT\");\n    tzset();\n    t = mktime(tm);\n    if(old_tz)\n        free(old_tz);\n    if(tz)\n        old_tz = sprintf_a(\"TZ=%s\", tz);\n    else\n        old_tz = strdup(\"TZ\");  /* XXX - non-portable? */\n    if(old_tz)\n        putenv(old_tz);\n    tzset();\n    return t;\n}\n#endif\n#else\n#error no mktime_gmt implementation on this platform\n#endif\n\n\nAtomPtr\nexpandTilde(AtomPtr filename)\n{\n    char *buf;\n    char *home;\n    int len;\n    AtomPtr ret;\n\n    if(filename == NULL || filename->length < 1 ||\n       filename->string[0] != '~' || filename->string[1] != '/')\n        return filename;\n    \n    home = getenv(\"HOME\");\n    if(home == NULL) {\n        return NULL;\n    }\n    len = strlen(home);\n    buf = malloc(len + 1 + 1 + filename->length - 2);\n    if(buf == NULL) {\n        do_log(L_ERROR, \"Could not allocate buffer.\\n\");\n        return NULL;\n    }\n\n    memcpy(buf, home, len);\n    if(buf[len - 1] != '/')\n        buf[len++] = '/';\n    memcpy(buf + len, filename->string + 2, filename->length - 2);\n    len += filename->length - 2;\n    ret = internAtomN(buf, len);\n    free(buf);\n    if(ret != NULL)\n        releaseAtom(filename);\n    return ret;\n}\n\n#ifdef HAVE_FORK\nvoid\ndo_daemonise(int noclose)\n{\n    int rc;\n\n    fflush(stdout);\n    fflush(stderr);\n\n    rc = fork();\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't fork\");\n        exit(1);\n    }\n\n    if(rc > 0)\n        exit(0);\n\n    if(!noclose) {\n        int fd;\n        close(0);\n        close(1);\n        close(2);\n        /* Leaving the default file descriptors free is not a good\n           idea, as it will cause library functions such as abort to\n           thrash the on-disk cache. */\n        fd = open(\"/dev/null\", O_RDONLY);\n        if(fd > 0) {\n            dup2(fd, 0);\n            close(fd);\n        }\n        fd = open(\"/dev/null\", O_WRONLY);\n        if(fd >= 0) {\n            if(fd != 1)\n                dup2(fd, 1);\n            if(fd != 2)\n                dup2(fd, 2);\n            if(fd != 1 && fd != 2)\n                close(fd);\n        }\n    }\n    rc = setsid();\n    if(rc < 0) {\n        do_log_error(L_ERROR, errno, \"Couldn't create new session\");\n        exit(1);\n    }\n}\n\n#elif defined(WIN32)\n\nvoid\ndo_daemonise(int noclose)\n{\n\tdo_log(L_INFO, \"Detaching console\");\n\tFreeConsole();\n}\n\n#else\n\nvoid\ndo_daemonise(int noclose)\n{\n    do_log(L_ERROR, \"Cannot daemonise on this platform\");\n    exit(1);\n}\n#endif\n\n\nvoid\nwritePid(char *pidfile)\n{\n    int fd, n, rc;\n    char buf[16];\n\n    fd = open(pidfile, O_WRONLY | O_CREAT | O_EXCL, 0666);\n    if(fd < 0) {\n        do_log_error(L_ERROR, errno, \n                     \"Couldn't create pid file %s\", pidfile);\n        exit(1);\n    }\n    n = snprintf(buf, 16, \"%ld\\n\", (long)getpid());\n    if(n < 0 || n >= 16) {\n        close(fd);\n        unlink(pidfile);\n        do_log(L_ERROR, \"Couldn't format pid.\\n\");\n        exit(1);\n    }\n    rc = write(fd, buf, n);\n    if(rc != n) {\n        close(fd);\n        unlink(pidfile);\n        do_log_error(L_ERROR, errno, \"Couldn't write pid\");\n        exit(1);\n    }\n\n    close(fd);\n    return;\n}\n\nstatic const char b64[64] =\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n/* \"/\" replaced with \"-\" */\nstatic const char b64fss[64] =\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\";\n\nint\nb64cpy(char *restrict dst, const char *restrict src, int n, int fss)\n{\n    const char *b = fss ? b64fss: b64;\n    int i, j;\n\n    j = 0;\n    for(i = 0; i < n; i += 3) {\n        unsigned char a0, a1, a2;\n        a0 = src[i];\n        a1 = i < n - 1 ? src[i + 1] : 0;\n        a2 = i < n - 2 ? src[i + 2] : 0;\n        dst[j++] = b[(a0 >> 2) & 0x3F];\n        dst[j++] = b[((a0 << 4) & 0x30) | ((a1 >> 4) & 0x0F)];\n        if(i < n - 1)\n            dst[j++] = b[((a1 << 2) & 0x3C) | ((a2 >> 6) & 0x03)];\n        else\n            dst[j++] = '=';\n        if(i < n - 2)\n            dst[j++] = b[a2 & 0x3F];\n        else\n            dst[j++] = '=';\n    }\n    return j;\n}\n\nint\nb64cmp(const char *restrict a, int an, const char *restrict b, int bn)\n{\n    char *buf;\n    int r;\n\n    if(an % 4 != 0)\n        return -1;\n    if((bn + 2) / 3 != an / 4)\n        return -1;\n    buf = malloc(an);\n    if(buf == NULL)\n        return -1;\n    b64cpy(buf, b, bn, 0);\n    r = memcmp(buf, a, an);\n    free(buf);\n    return r;\n}\n\nIntListPtr\nmakeIntList(int size)\n{\n    IntListPtr list;\n    if(size <= 0)\n        size = 4;\n\n    list = malloc(sizeof(IntListRec));\n    if(list == NULL)\n        return NULL;\n\n    list->ranges = malloc(size * sizeof(IntRangeRec));\n    if(list->ranges == NULL) {\n        free(list);\n        return NULL;\n    }\n\n    list->length = 0;\n    list->size = size;\n    return list;\n}\n\nvoid\ndestroyIntList(IntListPtr list)\n{\n    free(list->ranges);\n    free(list);\n}\n\nint\nintListMember(int n, IntListPtr list)\n{\n    int lo = 0, hi = list->length - 1;\n    int mid;\n    while(hi >= lo) {\n        mid = (hi + lo) / 2;\n        if(list->ranges[mid].from > n)\n            hi = mid - 1;\n        else if(list->ranges[mid].to < n)\n            lo = mid + 1;\n        else\n            return 1;\n    }\n    return 0;\n}\n\nstatic int\ndeleteRange(IntListPtr list, int i)\n{\n    assert(list->length > i);\n    if(list->length > i + 1)\n        memmove(list->ranges + i, list->ranges + i + 1,\n                (list->length - i - 1) * sizeof(IntRangeRec));\n    list->length--;\n    return 1;\n}\n\nstatic int\ninsertRange(int from, int to, IntListPtr list, int i)\n{\n    assert(i >= 0 && i <= list->length);\n    assert(i == 0 || list->ranges[i - 1].to < from - 1);\n    assert(i == list->length || list->ranges[i].from > to + 1);\n\n    if(list->length >= list->size) {\n        int newsize = list->size * 2 + 1;\n        IntRangePtr newranges = \n            realloc(list->ranges, newsize * sizeof(IntRangeRec));\n        if(newranges == NULL)\n            return -1;\n        list->size = newsize;\n        list->ranges = newranges;\n    }\n\n    if(i < list->length)\n        memmove(list->ranges + i + 1, list->ranges + i,\n                list->length - i);\n    list->length++;\n    list->ranges[i].from = from;\n    list->ranges[i].to = to;\n    return 1;\n}\n\nstatic int\nmaybeMergeRanges(IntListPtr list, int i)\n{\n    int rc;\n\n    while(i > 0 && list->ranges[i].from <= list->ranges[i - 1].to + 1) {\n            list->ranges[i - 1].from = \n                MIN(list->ranges[i - 1].from, list->ranges[i].from);\n            list->ranges[i - 1].to =\n                MAX(list->ranges[i - 1].to, list->ranges[i].to);\n            rc = deleteRange(list, i);\n            if(rc < 0) return -1;\n            i--;\n    }\n\n    while(i < list->length - 1 && \n          list->ranges[i].to >= list->ranges[i + 1].from - 1) {\n            list->ranges[i + 1].from = \n                MIN(list->ranges[i + 1].from, list->ranges[i].from);\n            list->ranges[i - 1].to =\n                MAX(list->ranges[i + 1].to, list->ranges[i].to);\n            rc = deleteRange(list, i);\n            if(rc < 0) return -1;\n    }\n    return 1;\n}\n\nint\nintListCons(int from, int to, IntListPtr list)\n{\n    int i;\n\n    /* Don't bother with the dichotomy. */\n    for(i = 0; i < list->length; i++) {\n        if(list->ranges[i].to >= from - 1)\n            break;\n    }\n\n    if(i < list->length && \n       (from >= list->ranges[i].from - 1 || to <= list->ranges[i].to + 1)) {\n        if(from <= list->ranges[i].from)\n            list->ranges[i].from = from;\n        if(to >= list->ranges[i].to)\n            list->ranges[i].to = to;\n        return maybeMergeRanges(list, i);\n    }\n    return insertRange(from, to, list, i);\n}\n\n/* Return the amount of physical memory on the box, -1 if unknown or\n   over two gigs. */\n#ifdef __linux\n\n#include <sys/sysinfo.h>\nint\nphysicalMemory()\n{\n    int rc;\n    struct sysinfo info;\n\n    rc = sysinfo(&info);\n    if(rc < 0)\n        return -1;\n\n    if(info.totalram <= 0x7fffffff / info.mem_unit)\n        return (int)(info.totalram * info.mem_unit);\n\n    return -1;\n}\n\n#elif defined(__FreeBSD__)\n\n#include <sys/sysctl.h>\nint\nphysicalMemory()\n{\n    unsigned long membytes;\n    size_t len;\n    int res;\n\n    len = sizeof(membytes);\n    res = sysctlbyname(\"hw.physmem\", &membytes, &len, NULL, 0);\n    if (res || membytes > INT_MAX)\n        return -1;\n\n    return (int)membytes;\n}\n\n#else\n\nint\nphysicalMemory()\n{\n    return -1;\n}\n#endif\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 4.2197265625,
          "content": "/*\nCopyright (c) 2003-2006 by Juliusz Chroboczek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/* These are Polipo's error codes.  They need to be positive integers,\n   and must not collide with possible errno values.\n   Starting at 2^16 should be safe enough. */\n\n#define E0 (1 << 16)\n#define E1 (2 << 16)\n#define E2 (3 << 16)\n#define E3 (4 << 16)\n#define EUNKNOWN (E0)\n#define EDOSHUTDOWN (E0 + 1)\n#define EDOGRACEFUL (E0 + 2)\n#define EDOTIMEOUT (E0 + 3)\n#define ECLIENTRESET (E0 + 4)\n#define ESYNTAX (E0 + 5)\n#define EREDIRECTOR (E0 + 6)\n#define EDNS_HOST_NOT_FOUND (E1)\n#define EDNS_NO_ADDRESS (E1 + 1)\n#define EDNS_NO_RECOVERY (E1 + 2)\n#define EDNS_TRY_AGAIN (E1 + 3)\n#define EDNS_INVALID (E1 + 4)\n#define EDNS_UNSUPPORTED (E1 + 5)\n#define EDNS_FORMAT (E1 + 6)\n#define EDNS_REFUSED (E1 + 7)\n#define EDNS_CNAME_LOOP (E1 + 8)\n#define ESOCKS_PROTOCOL (E2)\n/* These correspond to SOCKS status codes 91 through 93 */\n#define ESOCKS_REJECT_FAIL (E2 + 1)\n#define ESOCKS_REJECT_IDENTD (E2 + 2)\n#define ESOCKS_REJECT_UID_MISMATCH (E2 + 3)\n/* (ESOCKS5_BASE + n) corresponds to SOCKS5 status code n (0 to 8) */\n#define ESOCKS5_BASE (E3)\n\ntypedef struct _IntRange {\n    int from;\n    int to;\n} IntRangeRec, *IntRangePtr;\n\ntypedef struct _IntList {\n    int length;\n    int size;\n    IntRangePtr ranges;\n} IntListRec, *IntListPtr;\n\nchar *strdup_n(const char *restrict buf, int n) ATTRIBUTE ((malloc));\nint snnprintf(char *restrict buf, int n, int len, const char *format, ...)\n     ATTRIBUTE ((format (printf, 4, 5)));\nint snnvprintf(char *restrict buf, int n, int len, const char *format, va_list args)\n     ATTRIBUTE ((format (printf, 4, 0)));\nint snnprint_n(char *restrict buf, int n, int len, const char *s, int slen);\nint digit(char) ATTRIBUTE ((const));\nint letter(char) ATTRIBUTE ((const));\nchar lwr(char) ATTRIBUTE ((const));\nchar* lwrcpy(char *restrict dst, const char *restrict src, int n);\nint lwrcmp(const char *as, const char *bs, int n) ATTRIBUTE ((pure));\nint strcasecmp_n(const char *string, const char *buf, int n)\n     ATTRIBUTE ((pure));\nint atoi_n(const char *restrict string, int n, int len, int *value_return);\nint isWhitespace(const char *string) ATTRIBUTE((pure));\n#ifndef HAVE_MEMRCHR\nvoid *memrchr(const void *s, int c, size_t n) ATTRIBUTE ((pure));\n#endif\nint h2i(char h) ATTRIBUTE ((const));\nchar i2h(int i) ATTRIBUTE ((const));\nint log2_floor(int x) ATTRIBUTE ((const));\nint log2_ceil(int x) ATTRIBUTE ((const));\nchar* vsprintf_a(const char *f, va_list args)\n    ATTRIBUTE ((malloc, format (printf, 1, 0)));\nchar* sprintf_a(const char *f, ...)\n    ATTRIBUTE ((malloc, format (printf, 1, 2)));\nunsigned int hash(unsigned seed, const void *restrict key, int key_size, \n                  unsigned int hash_size)\n     ATTRIBUTE ((pure));\nchar *pstrerror(int e);\ntime_t mktime_gmt(struct tm *tm) ATTRIBUTE ((pure));\nAtomPtr expandTilde(AtomPtr filename);\nvoid do_daemonise(int noclose);\nvoid writePid(char *pidfile);\nint b64cpy(char *restrict dst, const char *restrict src, int n, int fss);\nint b64cmp(const char *restrict a, int an, const char *restrict b, int bn)\n    ATTRIBUTE ((pure));\nIntListPtr makeIntList(int size) ATTRIBUTE ((malloc));\nvoid destroyIntList(IntListPtr list);\nint intListMember(int n, IntListPtr list) ATTRIBUTE ((pure));\nint intListCons(int from, int to, IntListPtr list);\nint physicalMemory(void);\n"
        }
      ]
    }
  ]
}