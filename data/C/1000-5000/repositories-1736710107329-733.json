{
  "metadata": {
    "timestamp": 1736710107329,
    "page": 733,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "luigirizzo/netmap",
      "stars": 1865,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.349609375,
          "content": "BasedOnStyle: LLVM\nAllowShortIfStatementsOnASingleLine: false\nAlignConsecutiveAssignments: true\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: TopLevelDefinitions\nBreakBeforeBraces: Linux\nConstructorInitializerIndentWidth: 8\nContinuationIndentWidth: 4\nIndentCaseLabels: false\nIndentWidth: 8\nSortIncludes: false\nUseTab: ForIndentation\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.16015625,
          "content": "*.o\n*.d\n.*.cmd\n*.ko\n*.mod.c\n*.orig\n.*.swp\nconfig\ntags\ncscope.*\nmodules.order\nModule.symvers\n.tmp_versions\ncache/\ncnic_if.h\ne1000/\ne1000e*/\nforcedeth.c\nxen-netfront.c\nr8169.c\nget-drivers\nigb*/\nixgbe*/\nvmxnet*/\nlog/\nscripts/conf\nvirtio_net.c\nconfig.log\nKbuild\nnetmap.mak\nconfig.status\ndrivers.mak\npatches\nget-*\nnetmap-tmpdir\nnetmap_linux_config.h\nnetmap-tmp.c\ni40e*/\nveth.c\nfailed-patches\napps/lb/lb\napps/nmreplay/nmreplay\napps/tlem/tlem\napps/bridge/bridge\napps/bridge/bridge-b\napps/pkt-gen/pkt-gen\napps/pkt-gen/pkt-gen-b\nutils/test_select\nutils/testcsum\nutils/testlock\nutils/testmmap\nutils/vale-ctl\nutils/test_nm\nutils/cygwin1.dll\nutils/ctrl-api-test\nutils/functional\nutils/fd_server\nutils/get_tx_rings_avail_sends\nutils/get_tx_rings_max_sends\nutils/extmem-example\nexamples/pkt-gen.exe\nexamples/pkt-gen.exe.stackdump\nexamples/pkt-gen-b.exe\nexamples/pkt-gen-b.exe.stackdump\nbuild*/\nLINUX/tmp-patches\nLINUX/veth.c\n*.gcno\n*.core\n*.suo\n*.sdf\n*.opensdf\n*~\ncscope.out\n*.7\ndefault-config.mak\ndrv-subdir.mak\nread-vars.mak\n!LINUX/default-config.mak\n!LINUX/drv-subdir.mak\n!LINUX/read-vars.mak\n!LINUX/final-patches/*\nLINUX/scripts/conf\nconfig.mak\n*.rej\nutils/producer\n.cache.mk\nutils/sync_kloop_test\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.716796875,
          "content": "dist: xenial\nsudo: required\nlanguage: c\nenv:\n  - KERNEL_VERSION=local ARCH=x86_64\n  - KERNEL_VERSION=3.0   ARCH=x86_64\n  - KERNEL_VERSION=3.1   ARCH=x86_64\n  - KERNEL_VERSION=3.2   ARCH=x86_64\n  - KERNEL_VERSION=3.3   ARCH=x86_64\n  - KERNEL_VERSION=3.4   ARCH=x86_64\n  - KERNEL_VERSION=3.5   ARCH=x86_64\n  - KERNEL_VERSION=3.6   ARCH=x86_64\n  - KERNEL_VERSION=3.7   ARCH=x86_64\n  - KERNEL_VERSION=3.8   ARCH=x86_64\n  - KERNEL_VERSION=3.9   ARCH=x86_64\n  - KERNEL_VERSION=3.10.108  ARCH=x86_64\n  - KERNEL_VERSION=3.11  ARCH=x86_64\n  - KERNEL_VERSION=3.12  ARCH=x86_64\n  - KERNEL_VERSION=3.13  ARCH=x86_64\n  - KERNEL_VERSION=3.14  ARCH=x86_64\n  - KERNEL_VERSION=3.15  ARCH=x86_64\n  - KERNEL_VERSION=3.16  ARCH=x86_64\n  - KERNEL_VERSION=3.17  ARCH=x86_64\n  - KERNEL_VERSION=3.18  ARCH=x86_64\n  - KERNEL_VERSION=3.19  ARCH=x86_64\n  - KERNEL_VERSION=4.0   ARCH=x86_64\n  - KERNEL_VERSION=4.1   ARCH=x86_64\n  - KERNEL_VERSION=4.2   ARCH=x86_64\n  - KERNEL_VERSION=4.3   ARCH=x86_64\n  - KERNEL_VERSION=4.4   ARCH=x86_64\n  - KERNEL_VERSION=4.5   ARCH=x86_64\n  - KERNEL_VERSION=4.6   ARCH=x86_64\n  - KERNEL_VERSION=4.7   ARCH=x86_64\n  - KERNEL_VERSION=4.8   ARCH=x86_64\n  - KERNEL_VERSION=4.9   ARCH=x86_64\n  - KERNEL_VERSION=4.10  ARCH=x86_64\n  - KERNEL_VERSION=4.11  ARCH=x86_64\n  - KERNEL_VERSION=4.12  ARCH=x86_64\n  - KERNEL_VERSION=4.13  ARCH=x86_64\n  - KERNEL_VERSION=4.14  ARCH=x86_64\n  - KERNEL_VERSION=4.15  ARCH=x86_64\n  - KERNEL_VERSION=4.16  ARCH=x86_64\n  - KERNEL_VERSION=4.17  ARCH=x86_64\n  - KERNEL_VERSION=4.18  ARCH=x86_64\n  - KERNEL_VERSION=4.19  ARCH=x86_64\n  - KERNEL_VERSION=4.20  ARCH=x86_64\n  - KERNEL_VERSION=3.16  ARCH=i386\nscript:\n  - \"./ci/build-linux $KERNEL_VERSION $ARCH\"\n  - \"[ ${KERNEL_VERSION} != local ] || ./ci/run-integration-tests\"\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 0.5234375,
          "content": "all:\n\n-include netmap.mak\n\nCOMPAT_ARGS=$(if $(KSRC),--kernel-dir=$(KSRC),)\\\n\t    $(if $(SRC),--kernel-sources=$(SRC),)\\\n\t    $(if $(NODRIVERS),--no-drivers)\n\n\nnetmap.mak:\n\t@echo 'The new way to build netmap is to run the provided configure script first,'\n\t@echo 'followed by make.'\nifneq ($(MAKECMDGOALS),clean)\nifneq ($(MAKECMDGOALS),distclean)\n\t@echo 'We run configure for you now, with compatible arguments, and restart make.'\n\t@echo 'Please run configure again if this is not what you want.'\n\t./configure $(COMPAT_ARGS)\nendif\nendif\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.26953125,
          "content": "Copyright (C) 2011-2017 University of Pisa\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in the\n     documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\nOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\nOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n"
        },
        {
          "name": "LINUX",
          "type": "tree",
          "content": null
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.84375,
          "content": "# $Id$\n# targets to build tarballs and diffs\n\n# build a distribution\n\nRELEASE_SRCS := ./sys/net ./sys/dev ./sys/modules ./examples\nRELEASE_SRCS += ./README* ./LINUX ./OSX\nRELEASE_EXCL := --exclude .svn --exclude examples/testmod\nRELEASE_EXCL += --exclude connlib\\*\nRELEASE_EXCL += --exclude if_epair.diff\n#RELEASE_EXCL += --exclude \\*-patches\nRELEASE_EXCL += --exclude \\*bnx2x\\* --exclude \\*mellanox\\* --exclude \\*mlx4\\*\nRELEASE_EXCL += --exclude OSX\n\nall:\n\t@echo \"What do you want to do ?\"\n\n\ndiff-head:\n\t(cd ~/FreeBSD/head ; \\\n\tsvn diff sys/conf sys/dev sbin/ifconfig ) > head-netmap.diff\n\n# XXX remember to patch sbin/ifconfig if not done yet\ndiff-r8:\n\t(cd ~/FreeBSD/RELENG_8 ; \\\n\tsvn diff sys/conf sys/dev sbin/ifconfig ) > r8-netmap.diff\n\nrelease:\n\tD=`date +%Y%m%d` && tar cvzf /tmp/$${D}-netmap.tgz \\\n\t\t-s'/^./netmap-release/' $(RELEASE_EXCL) $(RELEASE_SRCS)\n"
        },
        {
          "name": "PORTING",
          "type": "blob",
          "size": 7.2724609375,
          "content": "# $Id$\n\nAdding netmap support to network device drivers\n------------------------------------------------\n\nNetmap requires some small modifications to device drivers\nto support the new API. You will need to add small patches\nin 3-4 places in the original source, and implement typically\n5 new functions.\n\nDevice driver patches\n------------------------\n+ in the initial part of the source, after the device-specific\n  headers and prototypes have been declared, add the following\n    <pre>\n\t+#if defined(DEV_NETMAP) || defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)\n\t+#include <dev/netmap/if_re_netmap.h>\n\t+#endif /* !DEV_NETMAP */\n    </pre>\n    The place is typically ... in FreeBSD, and\n    ... on Linux.\n\n    The header really contains the new functions that implement\n    the netmap API. Including them inline simplifies the building\n    as it does not require to insert additional dependencies in the\n    build system.\n\n    On FreeBSD DEV_NETMAP is sufficient to detect whether netmap extensions\n    should be compiled in, whereas CONFIG_NETMAP and CONFIG_NETMAP_MODULE\n    are the Linux equivalent.\n\n    If a driver is made of multiple source files, you will need to include\n    the additional header in all the (few) patched files, preferably using\n    a macro such as NETMAP_FOO_MAIN to indicate the file where the\n    new functions should be compiled in.\n\n+ near the end of the attach routine, once the ifnet/net_device structure\n  has been filled and initialized, add\n    <pre>\n\t+#ifdef DEV_NETMAP\n\t+\tfoo_netmap_attach(adapter);\n\t+#endif /* DEV_NETMAP */\n    </pre>\n  The argument is either the ifnet or the private device descriptor.\n  This is in foo_attach() on FreeBSD, and somewhere in the path of\n  foo_probe() in Linux\n\n+ near the code called on device removal, add\n    <pre>\n\t+#ifdef DEV_NETMAP\n\t+\tnetmap_detach(ifp);\n\t+#endif /* DEV_NETMAP */\n    </pre>\n\n+ after the tx/rx rings have been initialized, add a patch like this:\n    <pre>\n\t+#ifdef DEV_NETMAP\n\t+\tfoo_netmap_config(priv);\n\t+#endif /* DEV_NETMAP */\n    </pre>\n    The argument is typically the private device descriptor, or even\n    the struct ifnet/net_device.\n\n+ in the interrupt dispatch routines, something like\n    <pre>\n\t+#ifdef DEV_NETMAP\n\t+       int dummy;\n\t+       if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, &dummy))\n\t+               return true;\n\t+#endif /* DEV_NETMAP */\n\t...\n\t+#ifdef DEV_NETMAP\n\t+       if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))\n\t+               return true; /* seems to be ignored */\n\t+#endif /* DEV_NETMAP */\n     </pre>\n     to skip the normal processing and instead wake up the process in\n     charge of doing I/O\n\nNew functions\n----------------\nThe new functions serve to register the netmap-enabled device driver,\nsupport the enable/disable of netmap mode, attach netmap buffers to the\nNIC rings, and finally implement the handlers (*_txsync(), *_rxsync())\ncalled by the system calls.\n\n* foo_netmap_attach()\n    This is a relatively mechanical function. The purpose is to fetch from\n    the device descriptor information on the number of rings and buffers,\n    the way locks are used, and invoke netmap_attach().\n\n* foo_netmap_config()\n    This function is in charge of (over)writing the NIC rings with\n    pointers to the netmap buffers. Although this is device dependent,\n    we can often ignore the locking issue and expect that the locking is\n    already taken care of by the caller.\n\n    foo_netmap_config() only needs to run if the card is in netmap mode.\n    A quick way to check is to call netmap_ring_init() on one of the rings,\n    if the function returns NULL we can immediately exit.\n    Otherwise, we should run a couple of nested loops (on the rings,\n    and then on the buffers) to fill the NIC descriptors with the\n    addresses of the (preallocated) netmap buffers.\n\n    For the TX rings this can even be a no-op because these rings are\n    typically uninitialized, and the pointers can be overridden in the\n    txsync() routine.\n\n    For the receive ring, the operation is more critical because the\n    buffers should be available by the time the NIC is enabled.\n\n    Note that the device driver typically maintains head and tail pointers\n    to indicate which buffers are used. It might be convenient to retain\n    these indexes because may of the support routines, watchdogs etc.\n    depends on their values.\n\n    We should note that, especially on the receive ring, there might be\n    an offset between the indexes used in the netmap ring and those used\n    in the NIC ring (which might even be non-contiguous).\n\n* foo_netmap_reg()\n    support entering/exiting of netmap mode. Typically, lock, stop the device,\n    set/clear the netmap flag, and restart the device.\n    An unfortunate side effect of stopping and restarting the device is that\n    in many drivers the link is reinitialized, causing long delays for the\n    speed negotiations and spanning tree setup.\n\n\n* foo_netmap_txsync()\n\n* foo_netmap_rxsync()\n\n---------------\nPorting to different platforms\n--------------------------------\n\nNetmap runs on various operating systems, using a common core and OS specific\nfunctions where needed. The core has been originally developed under FreeBSD\nso we tend to follow FreeBSD kernel coding style and APIs.\n\nAmong the things that change between platforms we have\n- locking\n- native packet representation\n- network interfaces APIs\n\nDatapath from netmap host ring to host stack\n--------------------------------------------\npackets injected in the host ring e.g. netmap:eth0^ go through the following path:\n- application puts packets in the host netmap ring\n- application calls poll() or NIOCTXSYNC\n- kernel runs netmap.c :: netmap_txsync_to_host() which:\n  - calls netmap.c :: netmap_grab_packets() to extract packets from\n    the ring, encapsulate into mbufs through m_devget(), and store them\n    into a queue. There is a copy involved here, so the netmap buffer\n    can be freed immediately.\n  - calls netmap.c :: netmap_send_up() which dequeues each packet\n    and sends each through NM_SEND_UP() which is redefined on each architecture\n    XXX netmap_send_up() could be made OS-specific to handle batches\n On windows:\n    m_devget() is win_make_mbuf() we could probably create a new NDIS packet\n\tinstead and save the second copy later.\n\n    NM_SEND_UP is netmap_windows.c :: send_up_to_stack()\n\tcalls injectPacket which only uses the payload and frees the mbuf\n\t(the filter is not involved, only provides injectPacket)\n\nDatapath from host stack to netmap host ring\n---------------------------------------------\n\nXXX check documentation\nOS-dependent intercept:\nFreeBSD: ifp->if_transmit = netmap_transmit\nLinux: ndo_start_xmit = generic_ndo_start_xmit (?)\nWindows: filter.c :: FilterReceiveNetBufferLists() calls netmap_windows.c :: windows_generic_rx_handler\n\tXXX on windows it must be cleaned up\n\twe can use generic_rx_handler if the mbuf has the right queue number.\n\tIt probably has not unless we have a special case for host rings\n\nThe wrappers create an mbuf if needed, then do an mbq_enqueue(kring->rx_queue)\nand a notify to eventually clean up the data. This is done under mbq_lock.\n\nXXX it would be more efficient by copying packets in the netmap ring,\nbut not sure if we may have someone concurrently manipulating the ring.\nThis can be fixed though.\n\nLater, netmap_rxsync_from_host() copies from mbufs to the ring, stores\nthe mbufs in a list for later purge.\n\n\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.583984375,
          "content": "# Netmap: a framework for fast packet I/O\n\n## Introduction\n\nNetmap is a an framework for very fast packet I/O from userspace.\nVALE is an equally fast in-kernel L2 software switch using the netmap API.\nBoth are implemented as a single kernel module for FreeBSD and Linux.\nNetmap/VALE can handle tens of millions of packets per second, matching\nthe speed of 10G and 40G ports even with minimum sized frames.\n\nTo learn about netmap, you can use the following resources:\n\n* the man pages (https://www.freebsd.org/cgi/man.cgi?query=netmap&sektion=4 or\n`share/man/man4/netmap.4` in this repository)\n* the [papers](#references).\n* the tutorials, available at https://github.com/netmap-unipi/netmap-tutorial\n\nThis repository contains source code (BSD-Copyright) for FreeBSD, Linux and\nWindows.\nNetmap, VALE and related applications are already included in FreeBSD\nsince version 10.x. FreeBSD users should use the code included in the\nFreeBSD src tree rather than the one in this repository, although the two\ncodebases are mostly aligned.\n\n## Why should I use netmap?\n\nNetmap is mostly useful for userspace applications that must deal with raw\npackets: traffic generators, sinks, monitors, loggers, software switches\nand routers, generic middleboxes, interconnection of virtual machines.\n\nThe `apps/` directory includes `pkt-gen.c` (a fast traffic generator/receiver)\nand `bridge.c`, a simple bidirectional interconnect between two ports.\nThe kernel module itself implements a learning ethernet bridge.\n\nMore resources are hosted on other repositories. For example\nhttps://github.com/luigirizzo/netmap-libpcap contains a netmap-enabled version\nof libpcap (which is also included in FreeBSD distribution) so you can run\nany libpcap client on top of netmap at much higher speeds than using bpf.\nThe https://github.com/luigirizzo/netmap-ipfw repository contains\na userspace version of ipfw and dummynet which can handle several\nmillion packets per second in a single thread\n\nQEMU has native netmap support, so it can interconnect VMs at high speed\nthrough netmap ports (e.g., using VALE ports or netmap pipes).\nFor maximum performance, it is also possible to pass-through any netmap port\ninto a QEMU VM, as described [here](README.ptnetmap.md).\nAlso the FreeBSD bhyve hypervisor has native support for netmap.\n\nNetmap alone **does not** accelerate your TCP. For that you need to implement\nyour own tcp/ip stack probably using some of the techniques indicated\nbelow to reduce the processing costs.\n\n## Architecture\n\nnetmap uses a number of techniques to establish a fast and efficient path\nbetween applications and the network. In order of importance:\n\n* I/O batching\n* efficient device drivers\n* pre-allocated tx/rx buffers\n* memory mapped buffers\n\nDespite the name, memory mapping is NOT the key feature for netmap's\nspeed; systems that do not apply all these techniques do not achieve\nthe same speed _and_ efficiency.\n\nNetmap clients use a select()-able file descriptor to synchronize\nwith the network card/software switch, and exchange multiple packets\nper system call through device-independent memory mapped buffers and\ndescriptors. Device drivers are completely in the kernel, and the system\ndoes not rely on IOMMU or other special mechanisms.\n\n\n## Installation instructions\n\nA single kernel module implements the core Netmap functions, including\nthe VALE switch and access to physical NICS using unmodified device drivers\n(at the price of much lower performance than netmap-aware drivers).\n\nNetmap-aware device drivers are needed to use netmap at high speed\non ethernet ports.  To date, we have support for Intel ixgbe (10G),\nixl (10/40G), e1000/e1000e/igb (1G), Realtek 8169 (1G) and Nvidia (1G).\nFreeBSD has also native netmap support in the Chelsio 10/40G cards.\n\n### FreeBSD\nFreeBSD already includes netmap kernel support by\ndefault since version 11.\nIf your kernel configuration does not include netmap, you can enable it\nby adding a `dev netmap` line, and rebuilding the kernel.\nAlternatively, you can build standalone modules (netmap, ixgbe, em, lem,\nre, igb, ...).\n\nFreeBSD users will find the netmap example applications\nin `src/tools/tools/netmap/` within the FreeBSD src tree.\n\n\n### Linux\n\nThe `./configure && make` build system in the LINUX/\ndirectory will let you patch device driver sources and build\nsome netmap-enabled device drivers.\nPlease look [here](LINUX/README.md) for more instructions.\n\nMake sure you have kernel headers matching your installed kernel.\nThe sources for e1000e, igb, ixgbe and i40e will be downloaded\nfrom the Intel e1000 project on sourceforce.\nIf you need the netmap enabled drivers for e1000, veth, forcedeth,\nvirtio-net or r8169 you will also need the full kernel sources.\n\nLinux users can find the netmap example applications in the `apps/`\ndirectory in this repository.\n\n#### Step 1\n\nConfigure netmap. To compile Netmap/VALE and the Intel drivers above:\n\n\t./configure\n\n(This will also download the Intel driver sources from sourceforce).\nTo compile only Netmap/VALE (using unmodified drivers):\n\n\t./configure --no-drivers # only netmap, no unmodified drivers\n\nIf you need the full kernel sources and you have installed them in\n/a/b/c/linux-A.B.C/, then you should do\n\n\t./configure --kernel-dir=/a/b/c/linux-A.B.C/ # netmap+device drivers\n\nYou can omit --kernel-dir if your kernel sources are in a standard place.\n\nIf you use distribution packages, full sources and headers  may be in\ndifferent places contain headers (e.g., on debian systems). Use\n\n\t./configure --kernel-sources=/a/b/c/linux-sources-A.B/ --kernel-dir=/a/b/c/linux-headers-A.B/\n\n#### Step 2\n\nBuild kernel modules and sample applications:\n\n\tmake\n\n#### Step 3\n\nInstall the new modules and the applications:\n\n\tsudo make install\n\nTo have the new netmap-enabled driver modules alongside the original\nones, you may want to add `--driver-suffix=-netmap` to the configure\ncommand above. The new drivers will then be called `e1000e-netmap`,\n`ixgbe-netmap`, and so on.\n\n### Windows\n\nNetmap has been ported to Windows in summer 2015 by Alessio Faina as part of\nhis Master thesis. You may take a look [here](WINDOWS/README.txt) for details,\nbut please be aware that the port has been left behind for years, and is\ncurrently unmantained.\n\n## Applications\n\nThe directory `apps/` contains some programs that use the netmap API\n\n* `pkt-gen.c`\ta packet generator/receiver working at line rate at 10Gbit/s\n* `vale-ctl.c`\tutility to configure ports of a VALE switch\n* `bridge.c`\ta utility that bridges two interfaces or one interface\n\t\twith the host stack\n\nFor libpcap and other applications look at the extra/ directory.\n\n## Testing\n\n`pkt-gen` is a generic test program which can act as a sender or receiver.\nIt has a large number of options, but the simplest form is:\n\n    pkt-gen -i ix0 -f rx\t# receive and print stats\n    pkt-gen -i ix0 -f tx -l 60\t# send a stream of 60-byte packets\n\n(replace ix0 with the name of the interface or VALE port).\nThis should be able to work at line rate (up to 14.88 Mpps on 10\nGbit/interfaces, even higher on VALE) but note the following\n\n## Operating Speed\n\nNetmap is able to send packets at very high rates, and for simple\npacket transmission and reception, speed generally not limited by\nthe CPU but by other factors (link speed, bus or NIC hw limitations).\n\nFor a physical link, the maximum number of packets per second can\nbe computed with the formula:\n\n\tpps = line_rate / (672 + 8 * pkt_size)\n\nwhere \"line_rate\" is the nominal link rate (e.g 10 Gbit/s) and\npkt_size is the actual packet size including MAC headers and CRC.\nThe following table summarizes some results (in Mpps)\n\n\t\t\tLINE RATE\n    pkt_size \t100M\t1G\t10G\t40G\n\n          64\t.1488\t1.488\t14.88\t59.52\n         128\t.0589\t0.589\t 5.89\t23.58\n         256\t.0367\t0.367\t 3.67\t14.70\n         512\t.0209\t0.209\t 2.09\t 8.38\n        1024\t.0113\t0.113\t 1.13\t 4.51\n        1518\t.0078\t0.078\t 0.78\t 3.12\n\nOn VALE ports, there is no physical link and the throughput is\nlimited by CPU or memory depending on the packet size.\n\n## Common problems\n\nBefore reporting slow send or receive speed on a physical interface,\ncheck ALL of the following:\n\n### Cannot set the device in netmap mode:\n* make sure that the netmap module and drivers are correctly\n    loaded and can allocate all the memory they need (check into\n    /var/log/messages or equivalent)\n* check permissions on `/dev/netmap`\n* make sure the interface is up before invoking `pkt-gen`\n\n### Sender does not transmit\n* some switches/interfaces take a long time to (re)negotiate\nthe link after starting `pkt-gen`; in case, use the -w N option\nto increase the initial delay to N seconds;\n\nThis may cause inability to transmit, or lost packets for\nthe first few seconds of transmission\n\n### Receiver does not receive\n* make sure traffic uses a broadcast MAC addresses, or the UNICAST\naddress of the receiving interface, or the receiving interface is in\npromiscuous mode (this must be done with ifconfig; `pkt-gen` does not\nchange the operating mode)\n\n### Lower speed than line rate\n* check that your CPUs are running at the maximum clock rate\nand are not throttled down by the governor/powerd.\nOn Linux:\n\n\tlscpu # shows current cpu speed\n\tsudo apt-get install cpufrequtils\n\n* make sure that the sender/receiver interfaces and switch have\nflow control (FC) disabled (either via sysctl or ethtool).\nIf FC is enabled and the receiving end is unable to cope\nwith the traffic, the driver will try to slow down transmission,\nsometimes to very low rates.\n\n* a lot of hardware is not able to sustain line rate. For instance,\nixgbe has problems with receiving frames that are not multiple\nof 64 bytes (with/without CRC depending on the driver); also on\ntransmissions, ixgbe tops at about 12.5 Mpps unless the driver\nprefetches tx descriptors. igb does line rate in all configurations.\ne1000/e1000e vary between 1.15 and 1.32 Mpps. re/r8169 is\nextremely slow in sending (max 4-500 Kpps)\n\n### Host rings do not work\n\n* disable NIC offloads, because netmap does not support them and\npackets exchanged between netmap and the kernel stack can be dropped\nbecause of invalid checksums. On FreeBSD offloads can be disabled with\na command like\n\n\tsudo ifconfig vtnet0 -txcsum -rxcsum -tso4 -tso6 -lro -txcsum6 -rxcsum6\n\nCheck [here](LINUX/README.md) for the corresponding Linux command.\n\n\n## Credits\n\nNetmap and VALE are projects of the Universita` di Pisa,\npartially supported by various entities including:\nIntel Research Berkeley, EU FP7 projects CHANGE and OPENLAB,\nNetapp/Silicon Valley Community Foundation, ICSI\n\nAuthors:\n* Luigi Rizzo\n\nContributors (https://github.com/netmap-unipi/netmap/graphs/contributors):\n\n* Giuseppe Lettieri\n* Michio Honda\n* Marta Carbone\n* Gaetano Catalli\n* Matteo Landi\n* Vincenzo Maffione\n* Stefano Garzarella\n* Alessio Faina\n\n## References\n\nThere are a few academic papers describing netmap, VALE and applications.\nYou can find the papers at http://info.iet.unipi.it/~luigi/research.html\n\n* Luigi Rizzo,\n\tnetmap: a novel framework for fast packet I/O,\n\tUsenix ATC'12, Boston, June 2012\n\n* Luigi Rizzo,\n\tRevisiting network I/O APIs: the netmap framework,\n\tCommunications of the ACM 55 (3), 45-51, March 2012\n\n* Luigi Rizzo, Marta Carbone, Gaetano Catalli,\n\tTransparent acceleration of software packet forwarding using netmap,\n\tIEEE Infocom 2012, Orlando, March 2012\n\n* Luigi Rizzo, Giuseppe Lettieri,\n\tVALE: a switched ethernet for virtual machines,\n\tACM Conext 2012, Nice, Dec. 2012\n\n* Luigi Rizzo, Giuseppe Lettieri, Vincenzo Maffione,\n\tSpeeding up packet I/O in virtual machines,\n\tIEEE/ACM ANCS 2013, San Jose, Oct. 2013\n\n* Stefano Garzarella, Giuseppe Lettieri, Luigi Rizzo,\n\tVirtual device passthrough for high speed VM networking\n\tIEEE/ACM ANCS 2015, Oakland, May 2015\n\n* Vincenzo Maffione, Luigi Rizzo, Giuseppe Lettieri,\n\tFlexible virtual machine networking using netmap passthrough\n\tIEEE Lanman 2016, Rome, June 2016\n"
        },
        {
          "name": "README.ptnetmap.md",
          "type": "blob",
          "size": 10.4013671875,
          "content": "# Netmap passthrough howto\n\n## 1. Introduction\n\nThis document describes how to configure netmap passthrough, a technology\nthat enables very fast network I/O (up to 30 Mpps and more) for QEMU Virtual\nMachines.\nWith netmap passthrough you can make an arbitrary netmap port (physical NIC,\nVALE port, pipe endpoint, monitor, ...) available inside a VM. In this way\nyour (unmodified) netmap application can run isolated inside a VM, without\nlosing the performance advantages of netmap. In particular you will still\nable to zerocopy across the passed-through netmap ports (a.k.a. ptnetmap\nports).\nNetmap passthrough requires support in both host (hypervisor) and guest OS.\nHost needs a ptnetmap-capable hypervisor like QEMU (Linux host with KVM\nenabled) or bhyve (FreeBSD host). Guest OS requires some ptnetmap drivers that\nare already included with netmap, although not enabled by default.\nGuest OS ptnetmap drivers are available for both Linux and FreeBSD guests.\n\nNetmap passthrough is an enabler technology for Network Function\nVirtualization, as it can be used to build chains of VMs for high-rate\nmiddlebox packet processing. Given the variety\nof netmap ports you can decide to connect the VMs together through\nzerocopy ports (i.e. netmap pipes), or with copy for untrusted VMs\n(i.e. VALE ports). You can get NIC-independent NIC passthrough by\ndirectly passing a dedicated physical netmap port to a VM.\n\nMore information about ptnetmap are available in these slides:\n\n* https://github.com/vmaffione/netmap-tutorial/blob/master/virtualization.pdf\n\nand in these papers\n\n* http://info.iet.unipi.it/~luigi/papers/20160613-ptnet.pdf\n* http://info.iet.unipi.it/~luigi/papers/20150315-netmap-passthrough.pdf (older)\n\nand in section 7 of this document.\n\n## 2. Configure Linux host and QEMU for ptnetmap\n\nOn the Linux host, configure, build and install netmap normally:\n\n\tgit clone https://github.com/luigirizzo/netmap.git\n\tcd netmap\n\t./configure [options]\n\tmake\n\tsudo make install\n\nDownload, build and install the ptnetmap-enabled QEMU:\n\n\tgit clone https://github.com/netmap-unipi/qemu\n\tcd qemu\n\t./configure --target-list=x86_64-softmmu --enable-kvm --enable-vhost-net --disable-werror --enable-netmap\n\tmake\n\tsudo make install\n\nLoad the netmap\n\n\tsudo modprobe netmap\n\nExample to run a VM passing through a VALE port (vale1:10):\n\n\tsudo qemu-system-x86_64 img.qcow2 -enable-kvm -smp 2 -m 2G -vga std -device ptnet-pci,netdev=data10,mac=00:AA:BB:CC:0a:0a -netdev netmap,ifname=vale1:10,id=data10,passthrough=on\n\nExample to run a VM passing though the \"left\" endpoints of two pipes endpoints\n(the \"right\" endpoints can be connected to other VMs or netmap programs running\ndirectly on the host.\n\n\tsudo qemu-system-x86_64 img.qcow2 -enable-kvm -smp 2 -m 2G -vga std -device ptnet-pci,netdev=data1,mac=00:AA:BB:CC:0b:01 -netdev netmap,ifname=netmap:pipe0{1,id=data1,passthrough=on -device ptnet-pci,netdev=data1,mac=00:AA:BB:CC:0b:02 -netdev netmap,ifname=netmap:pipe1{1,id=data1,passthrough=on\n\n\n## 3. Configure FreeBSD host and bhyve for ptnetmap\nTODO\n\n\n## 4. Configure Linux guest for ptnetmap\n\nIn the Linux guest, compile, build and install netmap with ptnetmap support:\n\n\tgit clone https://github.com/luigirizzo/netmap.git\n\tcd netmap\n\t./configure --enable-ptnetmap\n\tmake\n\tsudo make install\n\nLoad netmap module\n\n\tsudo rmmod netmap  # Possibly remove a previous netmap module:\n\tsudo modprobe netmap\n\nAs the netmap module is loaded, a new network interface will show up for each\npassed-through netmap port, (e.g. 'ens4'). You can check that an interface is\na netmap passthrough one checking the driver:\n\n\tethtool -i ens4\n\t  driver: ptnetmap-guest-drivers\n\t  version:\n\t  [...]\n\nA guest ptnetmap port behaves like any other netmap ports. You can use pkt-gen\nto test transmission;\n\n\tsudo pkt-gen -i ens4 -f tx\n\n\n## 5. Use ptnetmap with FreeBSD guests\n\nNetmap passthrough guest drivers are already included with netmap from FreeBSD\n12 versions. When running FreeBSD guest with ptnetmap ports (e.g. using QEMU as\ndescribed above), an interface called \"ptnet$N\" will show up for each passed\nthrough port.\nIf you want to use ptnetmap with older FreeBSD guests you can just update your\nFreeBSD source tree with the updated netmap code from github and rebuild your\nkernel.\n\n\n## 6. ptnetmap tunables\n\nWhile ptnetmap is mainly designed for the VMs to run middleboxes applications\n(e.g. firewall, DDoS prevention, load balancing, IDS, typically carried out\nby network operators), it also offers good performance when VMs run TCP/UDP\nuser applications. To make this possible, virtualized offloadings are\nsupported using the virtio-net header defined by the VirtIO standard\n(http://docs.oasis-open.org/virtio/virtio/v1.0/cs04/virtio-v1.0-cs04.html#x1-1680006).\nWhen the header is enabled in the guest OS and supported by the VM network\nbackend (e.g. VALE port and TAP devices both support it), two VMs on the\nsame host (e.g. connected through a VALE switch) can exchange TSO packets\n(up to 64KB each) without the need to perform any TCP segmentation or\ncomputing TCP checksums.\nThis header is the key for very high TCP VM-to-VM throughput (20+ Gbps),\nand it is stored before the ethernet header of each packet sent or received\nby your VMs.\nIf you want to use ptnetmap mainly to run middleboxes application (which\nis the common case), you should disable the virtio-net header in the guest\nOS:\n\n\t# echo 0 > /sys/module/netmap/parameters/ptnet_vnet_hdr\n\nThis step is needed to avoid performance issues in case your datapath exits the\nhypervisor host through a physical NIC or goes through netmap ports that don't\nsupport the virtio-net header.\n\n\n## 7. Some background about ptnetmap\n\nNetmap is a framework for high performance network I/O. It exposes an\nhardware-independent API which allows userspace application to directly interact\nwith NIC hardware rings, in order to receive and transmit Ethernet frames.\nRings are always accessed in the context of system calls and NIC interrupts\nare used to notify applications about NIC processing completion.\nThe performance boost of netmap w.r.t. traditional socket API primarily comes\nfrom: (i) batching, since it is possible to send/receive hundreds of packets\nwith a single system call, (ii) preallocation of packet buffers and memory\nmapping of those in the application address space.\n\nSeveral netmap extension have been developed to support virtualization.\nNetmap support for various paravirtualized drivers - e.g. virtio-net, Xen\nnetfront/netback - allows netmap applications to run in the guest over fast\nparavirtualized I/O devices.\n\nThe Virtual Ethernet (VALE) software switch, which supports scalable high\nperformance local communication (over 20 Mpps between two switch ports), can\nthen be used to connect together multiple VMs.\n\nHowever, in a typical scenario with two communicating netmap applications\nrunning in different VMs (on the same host) connected through a VALE switch,\nthe journey of a packet is still quite convoluted. As a matter of facts,\nwhile netmap is fast on both the host (the VALE switch) and the guest\n(interaction between application and the emulated device), each packet still\nneeds to be processed from the hypervisor, which needs to emulate the\ndevice model used in the guest (e.g. e1000, virtio-net). The emulation\ninvolves device-specific overhead - queue processing, format conversions,\npacket copies, address translations, etc. As a consequence, the maximum\npacket rate between the two VMs is often limited by 2-5 Mpps.\n\nTo overcome these limitations, ptnetmap has been introduced as a passthrough\ntechnique to completely avoid hypervisor processing in the packet\ndatapath, unblocking the full potential of netmap also for virtual machine\nenvironments.\nWith ptnetmap, a netmap port on the host can be exposed to the guest in a\nprotected way, so that netmap applications in the guest can directly access\nthe rings and packet buffers of the host port, avoiding all the extra overhead\ninvolved in the emulation of network devices. System calls issued by guest\napplications on ptnetmap ports are served by kernel threads (one\nper ring) running in the netmap host.\n\nSimilarly to VirtIO paravirtualization, synchronization between\nguest netmap (driver) and host netmap (kernel threads) happens through a\nshared memory area called Communication Status Block (CSB), which is used\nto store producer-consumer state and notification suppression flags.\n\nTwo notification mechanisms needs to be supported by the hypervisor to allow\nguest and host netmap to wake up each other.\nOn QEMU/bhyve, notifications from guest to host are implemented with accesses\nto I/O registers which cause a trap in the hypervisor. Notifications in the\nother direction are implemented using KVM/bhyve interrupt injection mechanisms.\nMSI-X interrupts are used since they have less overhead than traditional\nPCI interrupts.\n\nSince I/O register accesses and interrupts are very expensive in the common\ncase of hardware assisted virtualization, they are suppressed when not needed,\ni.e. each time the host (or the guest) is actively polling the CSB to\ncheck for more work. From an high-level perspective, the system tries to\ndynamically switch between polling operation under high load, and\ninterrupt-based operation under lower loads.\n\nThe original ptnetmap implementation required ptnetmap-enabled virtio-net/e1000\ndrivers. Only the notification functionalities of those devices were reused,\nwhile the datapath (e.g. e1000 rings or virtio-net Virtual Queues) was\ncompletely bypassed.\n\nThe ptnet device has been introduced as a cleaner approach to ptnetmap that\nalso adds the ability to interact with the standard TCP/IP network stack\nand supports multi-ring netmap ports. The introduction of a new device model\ndoes not limit the adoption of this solution, since ptnet drivers are\ndistributed together with netmap, and hypervisor modifications are needed in\nany case.\n\nThe ptnet device belongs to the classes of paravirtualized devices, like\nvirtio-net. Unlike virtio-net, however, ptnet does not define an interface\nto exchange packets (datapath), but the existing netmap API is used instead.\nHowever, a CSB - cleaned up and extended to support an arbitrary number of\nrings - is still used for producer-consumer synchronization and notification\nsuppression.\n\nA number of device registers are used for configuration (number of rings and\nslots, device MAC address, supported features, ...) while \"kick\" registers\nare used for guest-to-host notifications.\nThe ptnetmap kthread infrastructure, moreover, has been already extended to\nsupport an arbitrary number of rings, where currently each ring is served\nby a different kernel thread.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.20703125,
          "content": "Reporting a Vulnerability\n=========================\n\nPlease report suspected vulnerabilities to giuseppe.lettieri@unipi.it. You will receive a response as soon as possible.\nPatches will target the master branch.\n"
        },
        {
          "name": "WINDOWS",
          "type": "tree",
          "content": null
        },
        {
          "name": "apps",
          "type": "tree",
          "content": null
        },
        {
          "name": "ci",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.208984375,
          "content": "#!/bin/sh\n\nos=$(uname -s)\ntopdir=$(cd $(dirname $0); pwd)\n\ncase $os in\n\tLinux)\n\t\t$topdir/LINUX/configure \"$@\";;\n\tFreeBSD)\n\t\t$topdir/FreeBSD/configure \"$@\";;\n\t*)\n\t\techo \"Sorry, $os is not supported\"\n\t\texit 1;;\nesac\n"
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "libnetmap",
          "type": "tree",
          "content": null
        },
        {
          "name": "pre-commit",
          "type": "blob",
          "size": 2.5556640625,
          "content": "#!/bin/bash\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=4b825dc642cb6eb9a060e54bf8d69288fbee4904\nfi\n\n# If you want to allow non-ASCII filenames set this variable to true.\nallownonascii=$(git config --bool hooks.allownonascii)\n\n# Redirect output to stderr.\nexec 1>&2\n\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n\nTo be portable it is advisable to rename the file.\n\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n\n########### netmap specific checks ############\nfiles=\"sys/dev/netmap/netmap_vale.c sys/dev/netmap/netmap_monitor.c sys/dev/netmap/netmap_pipe.c sys/dev/netmap/netmap.c sys/dev/netmap/netmap_generic.c sys/dev/netmap/netmap_freebsd.c sys/dev/netmap/netmap_legacy.c LINUX/netmap_linux.c LINUX/bsd_glue.h LINUX/i40e_netmap_linux.h LINUX/if_e1000_netmap.h LINUX/if_e1000e_netmap.h LINUX/if_igb_netmap.h LINUX/if_re_netmap_linux.h LINUX/ixgbe_netmap_linux.h LINUX/veth_netmap.h LINUX/virtio_netmap.h LINUX/netmap_ptnet.c LINUX/forcedeth_netmap.h apps/bridge/bridge.c apps/lb/lb.c apps/vale-ctl/vale-ctl.c apps/dedup/dedup.c apps/include/ctrs.h\"\n\nfor f in $files; do\n\tERR=$(git grep --line-number \"^\\(     \\)\\+\" $f | head -n1)\n\tif [ \"$ERR\" != \"\" ]; then\n\t\techo \"Wrong indentation in $f\"\n\t\techo \"$ERR\"\n\t\texit 1\n\tfi\ndone\n\nfor f in $files; do\n\tERR=$(git grep --line-number \" \\+$\" $f | head -n1)\n\tif [ \"$ERR\" != \"\" ]; then\n\t\techo \"Trailing whitespaces in $f\"\n\t\techo \"$ERR\"\n\t\texit 1\n\tfi\ndone\n\nfor f in $files; do\n\tERR=$(git grep --line-number \"^[$(printf '\\t') ]\\+$\" $f | head -n1)\n\tif [ \"$ERR\" != \"\" ]; then\n\t\techo \"Line with only spaces or tabs in $f\"\n\t\techo \"$ERR\"\n\t\texit 1\n\tfi\ndone\n########### end of netmap specific checks ############\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against \":(exclude)LINUX/final-patches\"\n"
        },
        {
          "name": "share",
          "type": "tree",
          "content": null
        },
        {
          "name": "sys",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}