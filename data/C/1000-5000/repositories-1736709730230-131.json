{
  "metadata": {
    "timestamp": 1736709730230,
    "page": 131,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "libjpeg-turbo/libjpeg-turbo",
      "stars": 3833,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.140625,
          "content": "/appveyor.yml export-ignore\n/.gitattributes export-ignore\n/.github export-ignore\n*.ppm binary\n*.pgm binary\n/ChangeLog.md conflict-marker-size=8\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 24.2587890625,
          "content": "Building libjpeg-turbo\n======================\n\n\nBuild Requirements\n------------------\n\n\n### All Systems\n\n- [CMake](https://cmake.org) v2.8.12 or later\n\n- [NASM](https://nasm.us) or [Yasm](https://yasm.tortall.net)\n  (if building x86 or x86-64 SIMD extensions)\n  * If using NASM, 2.13 or later is required.\n  * If using Yasm, 1.2.0 or later is required.\n  * NASM 2.15 or later is required if building libjpeg-turbo with Intel\n    Control-flow Enforcement Technology (CET) support.\n  * If building on macOS, NASM or Yasm can be obtained from\n    [MacPorts](https://macports.org) or [Homebrew](https://brew.sh).\n     - NOTE: Currently, if it is desirable to hide the SIMD function symbols in\n       Mac executables or shared libraries that statically link with\n       libjpeg-turbo, then NASM 2.14 or later or Yasm must be used when\n       building libjpeg-turbo.\n  * If NASM or Yasm is not in your `PATH`, then you can specify the full path\n    to the assembler by using either the `CMAKE_ASM_NASM_COMPILER` CMake\n    variable or the `ASM_NASM` environment variable.  On Windows, use forward\n    slashes rather than backslashes in the path (for example,\n    **c:/nasm/nasm.exe**).\n  * NASM and Yasm are located in the CRB (Code Ready Builder) or PowerTools\n    repository on Red Hat Enterprise Linux 8+ and derivatives, which is not\n    enabled by default.\n\n### Un*x Platforms (including Linux, Mac, FreeBSD, Solaris, and Cygwin)\n\n- GCC v4.1 (or later) or Clang recommended for best performance\n\n- If building the TurboJPEG Java wrapper, JDK or OpenJDK 1.5 or later is\n  required.  Most modern Linux distributions, as well as Solaris 10 and later,\n  include JDK or OpenJDK.  For other systems, you can obtain the Oracle Java\n  Development Kit from\n  <https://oracle.com/java/technologies/downloads>.\n\n  * If using JDK 11 or later, CMake 3.10.x or later must also be used.\n\n### Windows\n\n- Microsoft Visual C++ 2005 or later\n\n  If you don't already have Visual C++, then the easiest way to get it is by\n  installing\n  [Visual Studio Community Edition](https://visualstudio.microsoft.com),\n  which includes everything necessary to build libjpeg-turbo.\n\n  * You can also download and install the standalone Windows SDK (for Windows 7\n    or later), which includes command-line versions of the 32-bit and 64-bit\n    Visual C++ compilers.\n  * If you intend to build libjpeg-turbo from the command line, then add the\n    appropriate compiler and SDK directories to the `INCLUDE`, `LIB`, and\n    `PATH` environment variables.  This is generally accomplished by\n    executing `vcvars32.bat` or `vcvars64.bat`, which are located in the same\n    directory as the compiler.\n  * If built with Visual C++ 2015 or later, the libjpeg-turbo static libraries\n    cannot be used with earlier versions of Visual C++, and vice versa.\n  * The libjpeg API DLL (**jpeg{version}.dll**) will depend on the C run-time\n    DLLs corresponding to the version of Visual C++ that was used to build it.\n\n   ... OR ...\n\n- MinGW\n\n  [MSYS2](https://msys2.org) or [tdm-gcc](https://jmeubank.github.io/tdm-gcc)\n  recommended if building on a Windows machine.  Both distributions install a\n  Start Menu link that can be used to launch a command prompt with the\n  appropriate compiler paths automatically set.\n\n- If building the TurboJPEG Java wrapper, JDK 1.5 or later is required.  This\n  can be downloaded from\n  <https://oracle.com/java/technologies/downloads>.\n\n  * If using JDK 11 or later, CMake 3.10.x or later must also be used.\n\n\nSub-Project Builds\n------------------\n\nThe libjpeg-turbo build system does not support being included as a sub-project\nusing the CMake `add_subdirectory()` function.  Use the CMake\n`ExternalProject_Add()` function instead.\n\n\nOut-of-Tree Builds\n------------------\n\nBinary objects, libraries, and executables are generated in the directory from\nwhich CMake is executed (the \"binary directory\"), and this directory need not\nnecessarily be the same as the libjpeg-turbo source directory.  You can create\nmultiple independent binary directories, in which different versions of\nlibjpeg-turbo can be built from the same source tree using different compilers\nor settings.  In the sections below, *{build_directory}* refers to the binary\ndirectory, whereas *{source_directory}* refers to the libjpeg-turbo source\ndirectory.  For in-tree builds, these directories are the same.\n\n\nNinja\n-----\n\nIf using Ninja, then replace `make` or `nmake` with `ninja`, and replace the\nCMake generator (specified with the `-G` option) with `Ninja`, in all of the\nprocedures and recipes below.\n\n\nBuild Procedure\n---------------\n\nNOTE: The build procedures below assume that CMake is invoked from the command\nline, but all of these procedures can be adapted to the CMake GUI as\nwell.\n\n\n### Un*x\n\nThe following procedure will build libjpeg-turbo on Unix and Unix-like systems.\n(On Solaris, this generates a 32-bit build.  See \"Build Recipes\" below for\n64-bit build instructions.)\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" [additional CMake flags] {source_directory}\n    make\n\nThis will generate the following files under *{build_directory}*:\n\n**libjpeg.a**<br>\nStatic link library for the libjpeg API\n\n**libjpeg.so.{version}** (Linux, Unix)<br>\n**libjpeg.{version}.dylib** (Mac)<br>\n**cygjpeg-{version}.dll** (Cygwin)<br>\nShared library for the libjpeg API\n\nBy default, *{version}* is 62.2.0, 7.2.0, or 8.1.2, depending on whether\nlibjpeg v6b (default), v7, or v8 emulation is enabled.  If using Cygwin,\n*{version}* is 62, 7, or 8.\n\n**libjpeg.so** (Linux, Unix)<br>\n**libjpeg.dylib** (Mac)<br>\nDevelopment symlink for the libjpeg API\n\n**libjpeg.dll.a** (Cygwin)<br>\nImport library for the libjpeg API\n\n**libturbojpeg.a**<br>\nStatic link library for the TurboJPEG API\n\n**libturbojpeg.so.0.2.0** (Linux, Unix)<br>\n**libturbojpeg.0.2.0.dylib** (Mac)<br>\n**cygturbojpeg-0.dll** (Cygwin)<br>\nShared library for the TurboJPEG API\n\n**libturbojpeg.so** (Linux, Unix)<br>\n**libturbojpeg.dylib** (Mac)<br>\nDevelopment symlink for the TurboJPEG API\n\n**libturbojpeg.dll.a** (Cygwin)<br>\nImport library for the TurboJPEG API\n\n\n### Visual C++ (Command Line)\n\n    cd {build_directory}\n    cmake -G\"NMake Makefiles\" -DCMAKE_BUILD_TYPE=Release [additional CMake flags] {source_directory}\n    nmake\n\nThis will build either a 32-bit or a 64-bit version of libjpeg-turbo, depending\non which version of **cl.exe** is in the `PATH`.\n\nThe following files will be generated under *{build_directory}*:\n\n**jpeg-static.lib**<br>\nStatic link library for the libjpeg API\n\n**jpeg{version}.dll**<br>\nDLL for the libjpeg API\n\n**jpeg.lib**<br>\nImport library for the libjpeg API\n\n**turbojpeg-static.lib**<br>\nStatic link library for the TurboJPEG API\n\n**turbojpeg.dll**<br>\nDLL for the TurboJPEG API\n\n**turbojpeg.lib**<br>\nImport library for the TurboJPEG API\n\n*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or\nv8 emulation is enabled.\n\n\n### Visual C++ (IDE)\n\nChoose the appropriate CMake generator option for your version of Visual Studio\n(run `cmake` with no arguments for a list of available generators.)  For\ninstance:\n\n    cd {build_directory}\n    cmake -G\"Visual Studio 10\" [additional CMake flags] {source_directory}\n\nNOTE: Add \"Win64\" to the generator name (for example, \"Visual Studio 10 Win64\")\nto build a 64-bit version of libjpeg-turbo.  A separate build directory must be\nused for 32-bit and 64-bit builds.\n\nYou can then open **ALL_BUILD.vcproj** in Visual Studio and build one of the\nconfigurations in that project (\"Debug\", \"Release\", etc.) to generate a full\nbuild of libjpeg-turbo.\n\nThis will generate the following files under *{build_directory}*:\n\n**{configuration}/jpeg-static.lib**<br>\nStatic link library for the libjpeg API\n\n**{configuration}/jpeg{version}.dll**<br>\nDLL for the libjpeg API\n\n**{configuration}/jpeg.lib**<br>\nImport library for the libjpeg API\n\n**{configuration}/turbojpeg-static.lib**<br>\nStatic link library for the TurboJPEG API\n\n**{configuration}/turbojpeg.dll**<br>\nDLL for the TurboJPEG API\n\n**{configuration}/turbojpeg.lib**<br>\nImport library for the TurboJPEG API\n\n*{configuration}* is Debug, Release, RelWithDebInfo, or MinSizeRel, depending\non the configuration you built in the IDE, and *{version}* is 62, 7, or 8,\ndepending on whether libjpeg v6b (default), v7, or v8 emulation is enabled.\n\n\n### MinGW\n\nNOTE: This assumes that you are building on a Windows machine using the MSYS\nenvironment.  If you are cross-compiling on a Un*x platform (including Mac and\nCygwin), then see \"Build Recipes\" below.\n\n    cd {build_directory}\n    cmake -G\"MSYS Makefiles\" [additional CMake flags] {source_directory}\n    make\n\nThis will generate the following files under *{build_directory}*:\n\n**libjpeg.a**<br>\nStatic link library for the libjpeg API\n\n**libjpeg-{version}.dll**<br>\nDLL for the libjpeg API\n\n**libjpeg.dll.a**<br>\nImport library for the libjpeg API\n\n**libturbojpeg.a**<br>\nStatic link library for the TurboJPEG API\n\n**libturbojpeg.dll**<br>\nDLL for the TurboJPEG API\n\n**libturbojpeg.dll.a**<br>\nImport library for the TurboJPEG API\n\n*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or\nv8 emulation is enabled.\n\n\n### Debug Build\n\nAdd `-DCMAKE_BUILD_TYPE=Debug` to the CMake command line.  Or, if building\nwith NMake, remove `-DCMAKE_BUILD_TYPE=Release` (Debug builds are the default\nwith NMake.)\n\n\n### libjpeg v7 or v8 API/ABI Emulation\n\nAdd `-DWITH_JPEG7=1` to the CMake command line to build a version of\nlibjpeg-turbo that is API/ABI-compatible with libjpeg v7.  Add `-DWITH_JPEG8=1`\nto the CMake command line to build a version of libjpeg-turbo that is\nAPI/ABI-compatible with libjpeg v8.  See [README.md](README.md) for more\ninformation about libjpeg v7 and v8 emulation.\n\n\n### Arithmetic Coding Support\n\nSince the patent on arithmetic coding has expired, this functionality has been\nincluded in this release of libjpeg-turbo.  libjpeg-turbo's implementation is\nbased on the implementation in libjpeg v8, but it works when emulating libjpeg\nv7 or v6b as well.  The default is to enable both arithmetic encoding and\ndecoding, but those who have philosophical objections to arithmetic coding can\nadd `-DWITH_ARITH_ENC=0` or `-DWITH_ARITH_DEC=0` to the CMake command line to\ndisable encoding or decoding (respectively.)\n\n\n### TurboJPEG Java Wrapper\n\nAdd `-DWITH_JAVA=1` to the CMake command line to incorporate an optional Java\nNative Interface (JNI) wrapper into the TurboJPEG shared library and build the\nJava front-end classes to support it.  This allows the TurboJPEG shared library\nto be used directly from Java applications.  See [java/README](java/README) for\nmore details.\n\nIf Java is not in your `PATH`, or if you wish to use an alternate JDK to\nbuild/test libjpeg-turbo, then (prior to running CMake) set the `JAVA_HOME`\nenvironment variable to the location of the JDK that you wish to use.  The\n`Java_JAVAC_EXECUTABLE`, `Java_JAVA_EXECUTABLE`, and `Java_JAR_EXECUTABLE`\nCMake variables can also be used to specify alternate commands or locations for\njavac, jar, and java (respectively.)  You can also set the\n`CMAKE_JAVA_COMPILE_FLAGS` CMake variable or the `JAVAFLAGS` environment\nvariable to specify arguments that should be passed to the Java compiler when\nbuilding the TurboJPEG classes, and the `JAVAARGS` CMake variable to specify\narguments that should be passed to the JRE when running the TurboJPEG Java unit\ntests.\n\n\nBuild Recipes\n-------------\n\n\n### 32-bit Build on 64-bit Linux/Unix\n\nUse export/setenv to set the following environment variables before running\nCMake:\n\n    CFLAGS=-m32\n    LDFLAGS=-m32\n\n\n### 64-bit Build on Solaris\n\nUse export/setenv to set the following environment variables before running\nCMake:\n\n    CFLAGS=-m64\n    LDFLAGS=-m64\n\n\n### Other Compilers\n\nOn Un*x systems, prior to running CMake, you can set the `CC` environment\nvariable to the command used to invoke the C compiler.\n\n\n### 32-bit MinGW Build on Un*x (including Mac and Cygwin)\n\nCreate a file called **toolchain.cmake** under *{build_directory}*, with the\nfollowing contents:\n\n    set(CMAKE_SYSTEM_NAME Windows)\n    set(CMAKE_SYSTEM_PROCESSOR X86)\n    set(CMAKE_C_COMPILER {mingw_binary_path}/i686-w64-mingw32-gcc)\n    set(CMAKE_RC_COMPILER {mingw_binary_path}/i686-w64-mingw32-windres)\n\n*{mingw\\_binary\\_path}* is the directory under which the MinGW binaries are\nlocated (usually **/usr/bin**.)  Next, execute the following commands:\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \\\n      -DCMAKE_INSTALL_PREFIX={install_path} \\\n      [additional CMake flags] {source_directory}\n    make\n\n*{install\\_path}* is the path under which the libjpeg-turbo binaries should be\ninstalled.\n\n\n### 64-bit MinGW Build on Un*x (including Mac and Cygwin)\n\nCreate a file called **toolchain.cmake** under *{build_directory}*, with the\nfollowing contents:\n\n    set(CMAKE_SYSTEM_NAME Windows)\n    set(CMAKE_SYSTEM_PROCESSOR AMD64)\n    set(CMAKE_C_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-gcc)\n    set(CMAKE_RC_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-windres)\n\n*{mingw\\_binary\\_path}* is the directory under which the MinGW binaries are\nlocated (usually **/usr/bin**.)  Next, execute the following commands:\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \\\n      -DCMAKE_INSTALL_PREFIX={install_path} \\\n      [additional CMake flags] {source_directory}\n    make\n\n*{install\\_path}* is the path under which the libjpeg-turbo binaries should be\ninstalled.\n\n\nBuilding libjpeg-turbo for iOS\n------------------------------\n\niOS platforms, such as the iPhone and iPad, use Arm processors, and all\ncurrently supported models include Neon instructions.  Thus, they can take\nadvantage of libjpeg-turbo's SIMD extensions to significantly accelerate JPEG\ncompression/decompression.  This section describes how to build libjpeg-turbo\nfor these platforms.\n\n\n### Armv8 (64-bit)\n\n**Xcode 5 or later required, Xcode 6.3.x or later recommended**\n\nThe following script demonstrates how to build libjpeg-turbo to run on the\niPhone 5S/iPad Mini 2/iPad Air and newer.\n\n    IOS_PLATFORMDIR=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform\n    IOS_SYSROOT=($IOS_PLATFORMDIR/Developer/SDKs/iPhoneOS*.sdk)\n    export CFLAGS=\"-Wall -miphoneos-version-min=8.0 -funwind-tables\"\n\n    cd {build_directory}\n\n    cmake -G\"Unix Makefiles\" \\\n      -DCMAKE_C_COMPILER=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang \\\n      -DCMAKE_OSX_ARCHITECTURES=arm64 \\\n      -DCMAKE_OSX_SYSROOT=${IOS_SYSROOT[0]} \\\n      [additional CMake flags] {source_directory}\n    make\n\nReplace `iPhoneOS` with `iPhoneSimulator` and `-miphoneos-version-min` with\n`-miphonesimulator-version-min` to build libjpeg-turbo for the iOS simulator on\nMacs with Apple silicon CPUs.\n\n\nBuilding libjpeg-turbo for Android\n----------------------------------\n\nBuilding libjpeg-turbo for Android platforms requires v13b or later of the\n[Android NDK](https://developer.android.com/ndk).\n\n\n### Armv7 (32-bit)\n\n**NDK r19 or later with Clang recommended**\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r16b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={the minimum version of Android to support-- for example,\n      \"16\", \"19\", etc.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=armeabi-v7a \\\n      -DANDROID_ARM_MODE=arm \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_ASM_FLAGS=\"--target=arm-linux-androideabi${ANDROID_VERSION}\" \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\n### Armv8 (64-bit)\n\n**Clang recommended**\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r14b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={the minimum version of Android to support.  \"21\" or later\n      is required for a 64-bit build.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=arm64-v8a \\\n      -DANDROID_ARM_MODE=arm \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_ASM_FLAGS=\"--target=aarch64-linux-android${ANDROID_VERSION}\" \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\n### x86 (32-bit)\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r14b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={The minimum version of Android to support-- for example,\n      \"16\", \"19\", etc.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=x86 \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\n### x86-64 (64-bit)\n\nThe following is a general recipe script that can be modified for your specific\nneeds.\n\n    # Set these variables to suit your needs\n    NDK_PATH={full path to the NDK directory-- for example,\n      /opt/android/android-ndk-r16b}\n    TOOLCHAIN={\"gcc\" or \"clang\"-- \"gcc\" must be used with NDK r14b and earlier,\n      and \"clang\" must be used with NDK r17c and later}\n    ANDROID_VERSION={the minimum version of Android to support.  \"21\" or later\n      is required for a 64-bit build.}\n\n    cd {build_directory}\n    cmake -G\"Unix Makefiles\" \\\n      -DANDROID_ABI=x86_64 \\\n      -DANDROID_PLATFORM=android-${ANDROID_VERSION} \\\n      -DANDROID_TOOLCHAIN=${TOOLCHAIN} \\\n      -DCMAKE_TOOLCHAIN_FILE=${NDK_PATH}/build/cmake/android.toolchain.cmake \\\n      [additional CMake flags] {source_directory}\n    make\n\n\nAdvanced CMake Options\n----------------------\n\nTo list and configure other CMake options not specifically mentioned in this\nguide, run\n\n    ccmake {source_directory}\n\nor\n\n    cmake-gui {source_directory}\n\nfrom the build directory after initially configuring the build.  CCMake is a\ntext-based interactive version of CMake, and CMake-GUI is a GUI version.  Both\nwill display all variables that are relevant to the libjpeg-turbo build, their\ncurrent values, and a help string describing what they do.\n\n\nInstalling libjpeg-turbo\n========================\n\nYou can use the build system to install libjpeg-turbo (as opposed to creating\nan installer package.)  To do this, run `make install` or `nmake install`\n(or build the \"install\" target in the Visual Studio IDE.)  Running\n`make uninstall` or `nmake uninstall` (or building the \"uninstall\" target in\nthe Visual Studio IDE) will uninstall libjpeg-turbo.\n\nThe `CMAKE_INSTALL_PREFIX` CMake variable can be modified in order to install\nlibjpeg-turbo into a directory of your choosing.  If you don't specify\n`CMAKE_INSTALL_PREFIX`, then the default is:\n\n**c:\\libjpeg-turbo**<br>\nVisual Studio 32-bit build\n\n**c:\\libjpeg-turbo64**<br>\nVisual Studio 64-bit build\n\n**c:\\libjpeg-turbo-gcc**<br>\nMinGW 32-bit build\n\n**c:\\libjpeg-turbo-gcc64**<br>\nMinGW 64-bit build\n\n**/opt/libjpeg-turbo**<br>\nUn*x\n\nThe default value of `CMAKE_INSTALL_PREFIX` causes the libjpeg-turbo files to\nbe installed with a directory structure resembling that of the official\nlibjpeg-turbo binary packages.  Changing the value of `CMAKE_INSTALL_PREFIX`\n(for instance, to **/usr/local**) causes the libjpeg-turbo files to be\ninstalled with a directory structure that conforms to GNU standards.\n\nThe `CMAKE_INSTALL_BINDIR`, `CMAKE_INSTALL_DATAROOTDIR`,\n`CMAKE_INSTALL_DOCDIR`, `CMAKE_INSTALL_INCLUDEDIR`, `CMAKE_INSTALL_JAVADIR`,\n`CMAKE_INSTALL_LIBDIR`, and `CMAKE_INSTALL_MANDIR` CMake variables allow a\nfiner degree of control over where specific files in the libjpeg-turbo\ndistribution should be installed.  These directory variables can either be\nspecified as absolute paths or as paths relative to `CMAKE_INSTALL_PREFIX` (for\ninstance, setting `CMAKE_INSTALL_DOCDIR` to **doc** would cause the\ndocumentation to be installed in **${CMAKE\\_INSTALL\\_PREFIX}/doc**.)  If a\ndirectory variable contains the name of another directory variable in angle\nbrackets, then its final value will depend on the final value of that other\nvariable.  For instance, the default value of `CMAKE_INSTALL_MANDIR` is\n**\\<CMAKE\\_INSTALL\\_DATAROOTDIR\\>/man**.\n\n\nCreating Distribution Packages\n==============================\n\nThe following commands can be used to create various types of distribution\npackages:\n\n\nLinux\n-----\n\n    make rpm\n\nCreate Red Hat-style binary RPM package.  Requires RPM v4 or later.\n\n    make srpm\n\nThis runs `make dist` to create a pristine source tarball, then creates a\nRed Hat-style source RPM package from the tarball.  Requires RPM v4 or later.\n\n    make deb\n\nCreate Debian-style binary package.  Requires dpkg.\n\n\nMac\n---\n\n    make dmg\n\nCreate Mac package/disk image.  This requires pkgbuild and productbuild, which\nare installed by default on OS X/macOS 10.7 and later.\n\nIn order to create a Mac package/disk image that contains universal\nx86-64/Arm binaries, set the following CMake variable:\n\n* `SECONDARY_BUILD`: Directory containing a cross-compiled x86-64 or Armv8\n  (64-bit) iOS or macOS build of libjpeg-turbo to include in the universal\n  binaries\n\nYou should first use CMake to configure the cross-compiled x86-64 or Armv8\nsecondary build of libjpeg-turbo (see \"Building libjpeg-turbo for iOS\" above,\nif applicable) in a build directory that matches the one specified in the\naforementioned CMake variable.  Next, configure the primary (native) build of\nlibjpeg-turbo as an out-of-tree build, specifying the aforementioned CMake\nvariable, and build it.  Once the primary build has been built, run `make dmg`\nfrom the build directory.  The packaging system will build the secondary build,\nuse lipo to combine it with the primary build into a single set of universal\nbinaries, then package the universal binaries.\n\n\nWindows\n-------\n\nIf using NMake:\n\n    cd {build_directory}\n    nmake installer\n\nIf using MinGW:\n\n    cd {build_directory}\n    make installer\n\nIf using the Visual Studio IDE, build the \"installer\" target.\n\nThe installer package (libjpeg-turbo-*{version}*[-gcc|-vc][64].exe) will be\nlocated under *{build_directory}*.  If building using the Visual Studio IDE,\nthen the installer package will be located in a subdirectory with the same name\nas the configuration you built (such as *{build_directory}*\\Debug\\ or\n*{build_directory}*\\Release\\).\n\nBuilding a Windows installer requires the\n[Nullsoft Install System](https://nsis.sourceforge.io).  makensis.exe should\nbe in your `PATH`.\n\n\nRegression testing\n==================\n\nThe most common way to test libjpeg-turbo is by invoking `make test` (Un*x) or\n`nmake test` (Windows command line) or by building the \"RUN_TESTS\" target\n(Visual Studio IDE), once the build has completed.  This runs a series of tests\nto ensure that mathematical compatibility has been maintained between\nlibjpeg-turbo and libjpeg v6b.  This also invokes the TurboJPEG unit tests,\nwhich ensure that the colorspace extensions, YUV encoding, decompression\nscaling, and other features of the TurboJPEG C and Java APIs are working\nproperly (and, by extension, that the equivalent features of the underlying\nlibjpeg API are also working.)\n\nInvoking `make testclean` (Un*x) or `nmake testclean` (Windows command line) or\nbuilding the \"testclean\" target (Visual Studio IDE) will clean up the output\nimages generated by the tests.\n\nOn Un*x platforms, more extensive tests of the TurboJPEG C and Java wrappers\ncan be run by invoking `make tjtest`.  These extended TurboJPEG tests\nessentially iterate through all of the available features of the TurboJPEG APIs\nthat are not covered by the TurboJPEG unit tests (including the lossless\ntransform options) and compare the images generated by each feature to images\ngenerated using the equivalent feature in the libjpeg API.  The extended\nTurboJPEG tests are meant to test for regressions in the TurboJPEG wrappers,\nnot in the underlying libjpeg API library.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 88.3701171875,
          "content": "cmake_minimum_required(VERSION 2.8.12...3.28)\n\nif(CMAKE_EXECUTABLE_SUFFIX)\n  set(CMAKE_EXECUTABLE_SUFFIX_TMP ${CMAKE_EXECUTABLE_SUFFIX})\nendif()\n\nproject(libjpeg-turbo C)\nset(VERSION 3.1.1)\nset(COPYRIGHT_YEAR \"1991-2024\")\nstring(REPLACE \".\" \";\" VERSION_TRIPLET ${VERSION})\nlist(GET VERSION_TRIPLET 0 VERSION_MAJOR)\nlist(GET VERSION_TRIPLET 1 VERSION_MINOR)\nlist(GET VERSION_TRIPLET 2 VERSION_REVISION)\nfunction(pad_number NUMBER OUTPUT_LEN)\n  string(LENGTH \"${${NUMBER}}\" INPUT_LEN)\n  if(INPUT_LEN LESS OUTPUT_LEN)\n    math(EXPR ZEROES \"${OUTPUT_LEN} - ${INPUT_LEN} - 1\")\n    set(NUM ${${NUMBER}})\n    foreach(C RANGE ${ZEROES})\n      set(NUM \"0${NUM}\")\n    endforeach()\n    set(${NUMBER} ${NUM} PARENT_SCOPE)\n  endif()\nendfunction()\nset(TMP_VERSION_MINOR ${VERSION_MINOR})\nset(TMP_VERSION_REVISION ${VERSION_REVISION})\npad_number(TMP_VERSION_MINOR 3)\npad_number(TMP_VERSION_REVISION 3)\nset(LIBJPEG_TURBO_VERSION_NUMBER\n  ${VERSION_MAJOR}${TMP_VERSION_MINOR}${TMP_VERSION_REVISION})\nset(MSVC_LIKE 0)\nif(MSVC OR CMAKE_C_SIMULATE_ID STREQUAL \"MSVC\")\n  set(MSVC_LIKE 1)\nendif()\n\n# The libjpeg-turbo build system has never supported and will never support\n# being integrated into another build system using add_subdirectory(), because\n# doing so would require that we (minimally):\n#\n# 1. avoid using certain CMake variables, such as CMAKE_SOURCE_DIR,\n#    CMAKE_BINARY_DIR, and CMAKE_PROJECT_NAME;\n# 2. avoid using implicit include directories and relative paths;\n# 3. optionally provide a way to skip the installation of libjpeg-turbo\n#    components when the 'install' target is built;\n# 4. optionally provide a way to postfix target names, to avoid namespace\n#    conflicts;\n# 5. restructure the top-level CMakeLists.txt so that it properly sets the\n#    PROJECT_VERSION variable; and\n# 6. design automated regression tests to ensure that new commits don't break\n#    any of the above.\n#\n# Even if we did all of that, issues would still arise, because it is\n# impossible for an upstream build system to anticipate the widely varying\n# needs of every downstream build system.  That's why the CMake\n# ExternalProject_Add() function exists.  Downstream projects that wish to\n# integrate libjpeg-turbo as a subdirectory should either use\n# ExternalProject_Add() or make downstream modifications to the libjpeg-turbo\n# build system to suit their specific needs.  Please do not file bug reports,\n# feature requests, or pull requests regarding this.\nif(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n  message(FATAL_ERROR \"The libjpeg-turbo build system cannot be integrated into another build system using add_subdirectory().  Use ExternalProject_Add() instead.\")\nendif()\n\n# CMake 3.14 and later sets CMAKE_MACOSX_BUNDLE to TRUE by default when\n# CMAKE_SYSTEM_NAME is iOS, tvOS, or watchOS, which breaks the libjpeg-turbo\n# build.  (Specifically, when CMAKE_MACOSX_BUNDLE is TRUE, executables for\n# Apple platforms are built as application bundles, which causes CMake to\n# complain that our install() directives for executables do not specify a\n# BUNDLE DESTINATION.  Even if CMake did not complain, building executables as\n# application bundles would break our iOS packages.)\nset(CMAKE_MACOSX_BUNDLE FALSE)\n\nget_property(GENERATOR_IS_MULTI_CONFIG GLOBAL PROPERTY\n  GENERATOR_IS_MULTI_CONFIG)\n# If the GENERATOR_IS_MULTI_CONFIG property doesn't exist (CMake < 3.9), then\n# set the GENERATOR_IS_MULTI_CONFIG variable manually if the generator is\n# Visual Studio or Xcode (the only multi-config generators in CMake < 3.9).\nif(NOT GENERATOR_IS_MULTI_CONFIG AND (MSVC_IDE OR XCODE))\n  set(GENERATOR_IS_MULTI_CONFIG TRUE)\nendif()\n\nstring(TIMESTAMP DEFAULT_BUILD \"%Y%m%d\")\nset(BUILD ${DEFAULT_BUILD} CACHE STRING \"Build string (default: ${DEFAULT_BUILD})\")\n\n# NOTE: On Windows, this does nothing except when using MinGW or Cygwin.\n# CMAKE_BUILD_TYPE has no meaning in Visual Studio, and it always defaults to\n# Debug when using NMake.\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release)\nendif()\nmessage(STATUS \"CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}\")\n\nmessage(STATUS \"VERSION = ${VERSION}, BUILD = ${BUILD}\")\n\ninclude(cmakescripts/PackageInfo.cmake)\n\n# Detect CPU type and whether we're building 64-bit or 32-bit code\nmath(EXPR BITS \"${CMAKE_SIZEOF_VOID_P} * 8\")\nstring(TOLOWER ${CMAKE_SYSTEM_PROCESSOR} CMAKE_SYSTEM_PROCESSOR_LC)\nset(COUNT 1)\nforeach(ARCH ${CMAKE_OSX_ARCHITECTURES})\n  if(COUNT GREATER 1)\n    message(FATAL_ERROR \"libjpeg-turbo contains assembly code, so it cannot be built with multiple values in CMAKE_OSX_ARCHITECTURES.\")\n  endif()\n  math(EXPR COUNT \"${COUNT}+1\")\nendforeach()\nif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"x86_64\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"amd64\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"i[0-9]86\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"x86\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"ia32\")\n  if(BITS EQUAL 64 OR CMAKE_C_COMPILER_ABI MATCHES \"ELF X32\")\n    set(CPU_TYPE x86_64)\n  else()\n    set(CPU_TYPE i386)\n  endif()\n  if(NOT CMAKE_SYSTEM_PROCESSOR STREQUAL ${CPU_TYPE})\n    set(CMAKE_SYSTEM_PROCESSOR ${CPU_TYPE})\n  endif()\nelseif(CMAKE_SYSTEM_PROCESSOR_LC STREQUAL \"aarch64\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"^arm\")\n  if(BITS EQUAL 64)\n    set(CPU_TYPE arm64)\n  else()\n    set(CPU_TYPE arm)\n  endif()\nelseif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"^ppc\" OR\n  CMAKE_SYSTEM_PROCESSOR_LC MATCHES \"^powerpc\")\n  set(CPU_TYPE powerpc)\nelse()\n  set(CPU_TYPE ${CMAKE_SYSTEM_PROCESSOR_LC})\nendif()\nif(CMAKE_OSX_ARCHITECTURES MATCHES \"x86_64\" OR\n  CMAKE_OSX_ARCHITECTURES MATCHES \"arm64\" OR\n  CMAKE_OSX_ARCHITECTURES MATCHES \"i386\")\n  set(CPU_TYPE ${CMAKE_OSX_ARCHITECTURES})\nendif()\nif(CMAKE_OSX_ARCHITECTURES MATCHES \"ppc\")\n  set(CPU_TYPE powerpc)\nendif()\nif(MSVC_IDE AND CMAKE_GENERATOR_PLATFORM MATCHES \"arm64\")\n  set(CPU_TYPE arm64)\nendif()\n\nmessage(STATUS \"${BITS}-bit build (${CPU_TYPE})\")\n\n\n###############################################################################\n# INSTALL DIRECTORIES\n###############################################################################\n\nif(WIN32)\n  if(MSVC_LIKE)\n    set(CMAKE_INSTALL_DEFAULT_PREFIX \"c:/${CMAKE_PROJECT_NAME}\")\n  else()\n    set(CMAKE_INSTALL_DEFAULT_PREFIX \"c:/${CMAKE_PROJECT_NAME}-gcc\")\n  endif()\n  if(BITS EQUAL 64)\n    set(CMAKE_INSTALL_DEFAULT_PREFIX \"${CMAKE_INSTALL_DEFAULT_PREFIX}64\")\n  endif()\nelse()\n  if(NOT CMAKE_INSTALL_DEFAULT_PREFIX)\n    set(CMAKE_INSTALL_DEFAULT_PREFIX /opt/${CMAKE_PROJECT_NAME})\n  endif()\nendif()\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${CMAKE_INSTALL_DEFAULT_PREFIX}\" CACHE PATH\n    \"Directory into which to install ${CMAKE_PROJECT_NAME} (default: ${CMAKE_INSTALL_DEFAULT_PREFIX})\"\n    FORCE)\nendif()\nmessage(STATUS \"CMAKE_INSTALL_PREFIX = ${CMAKE_INSTALL_PREFIX}\")\n\n# When the prefix is /opt/${CMAKE_PROJECT_NAME}, we assume that an \"official\"\n# build is being created, and thus we install things into specific locations.\n\nif(CMAKE_INSTALL_PREFIX STREQUAL \"${CMAKE_INSTALL_DEFAULT_PREFIX}\")\n  set(CMAKE_INSTALL_DEFAULT_DATAROOTDIR \"\")\n  set(CMAKE_INSTALL_DEFAULT_DOCDIR \"<CMAKE_INSTALL_DATAROOTDIR>/doc\")\n  set(CMAKE_INSTALL_DEFAULT_JAVADIR \"<CMAKE_INSTALL_DATAROOTDIR>/classes\")\n  if(UNIX AND NOT APPLE)\n    if(BITS EQUAL 64)\n      set(CMAKE_INSTALL_DEFAULT_LIBDIR \"lib64\")\n    elseif(CMAKE_C_COMPILER_ABI MATCHES \"ELF X32\")\n      set(CMAKE_INSTALL_DEFAULT_LIBDIR \"libx32\")\n    else()\n      set(CMAKE_INSTALL_DEFAULT_LIBDIR \"lib32\")\n    endif()\n  endif()\nendif()\n\ninclude(cmakescripts/GNUInstallDirs.cmake)\n\nmacro(report_directory var)\n  if(CMAKE_INSTALL_${var} STREQUAL CMAKE_INSTALL_FULL_${var})\n    message(STATUS \"CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}}\")\n  else()\n    message(STATUS \"CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}} (${CMAKE_INSTALL_FULL_${var}})\")\n  endif()\n  mark_as_advanced(CLEAR CMAKE_INSTALL_${var})\nendmacro()\n\nset(DIRLIST \"BINDIR;DATAROOTDIR;DOCDIR;INCLUDEDIR;LIBDIR\")\nif(UNIX)\n  list(APPEND DIRLIST \"MANDIR\")\nendif()\nforeach(dir ${DIRLIST})\n  report_directory(${dir})\nendforeach()\n\n\n###############################################################################\n# CONFIGURATION OPTIONS\n###############################################################################\n\nmacro(boolean_number var)\n  if(${var})\n    set(${var} 1 ${ARGN})\n  else()\n    set(${var} 0 ${ARGN})\n  endif()\nendmacro()\n\noption(ENABLE_SHARED \"Build shared libraries\" TRUE)\nboolean_number(ENABLE_SHARED)\noption(ENABLE_STATIC \"Build static libraries\" TRUE)\nboolean_number(ENABLE_STATIC)\noption(REQUIRE_SIMD\n  \"Generate a fatal error if SIMD extensions are not available for this platform (default is to fall back to a non-SIMD build)\"\n  FALSE)\nboolean_number(REQUIRE_SIMD)\noption(WITH_ARITH_DEC\n  \"Include arithmetic decoding support when emulating the libjpeg v6b API/ABI\"\n  TRUE)\nboolean_number(WITH_ARITH_DEC)\noption(WITH_ARITH_ENC\n  \"Include arithmetic encoding support when emulating the libjpeg v6b API/ABI\"\n  TRUE)\nboolean_number(WITH_ARITH_ENC)\nif(CMAKE_C_COMPILER_ABI MATCHES \"ELF X32\")\n  set(WITH_JAVA 0)\nelse()\n  option(WITH_JAVA\n    \"Build Java wrapper for the TurboJPEG API library (implies ENABLE_SHARED=1)\"\n    FALSE)\n  boolean_number(WITH_JAVA)\nendif()\noption(WITH_JPEG7\n  \"Emulate libjpeg v7 API/ABI (this makes ${CMAKE_PROJECT_NAME} backward-incompatible with libjpeg v6b)\"\n  FALSE)\nboolean_number(WITH_JPEG7)\noption(WITH_JPEG8\n  \"Emulate libjpeg v8 API/ABI (this makes ${CMAKE_PROJECT_NAME} backward-incompatible with libjpeg v6b)\"\n  FALSE)\nboolean_number(WITH_JPEG8)\noption(WITH_SIMD \"Include SIMD extensions, if available for this platform\" TRUE)\nboolean_number(WITH_SIMD)\noption(WITH_TURBOJPEG\n  \"Include the TurboJPEG API library and associated test programs\" TRUE)\nboolean_number(WITH_TURBOJPEG)\noption(WITH_FUZZ \"Build fuzz targets\" FALSE)\n\nmacro(report_option var desc)\n  if(${var})\n    message(STATUS \"${desc} enabled (${var} = ${${var}})\")\n  else()\n    message(STATUS \"${desc} disabled (${var} = ${${var}})\")\n  endif()\nendmacro()\n\nif(WITH_JAVA)\n  set(ENABLE_SHARED 1)\nendif()\n\n# Explicitly setting CMAKE_POSITION_INDEPENDENT_CODE=FALSE disables PIC for all\n# targets, which will cause the shared library builds to fail.  Thus, if shared\n# libraries are enabled and CMAKE_POSITION_INDEPENDENT_CODE is explicitly set\n# to FALSE, we need to unset it, thus restoring the default behavior\n# (automatically using PIC for shared library targets.)\nif(DEFINED CMAKE_POSITION_INDEPENDENT_CODE AND\n  NOT CMAKE_POSITION_INDEPENDENT_CODE AND ENABLE_SHARED)\n  unset(CMAKE_POSITION_INDEPENDENT_CODE CACHE)\nendif()\n\nreport_option(ENABLE_SHARED \"Shared libraries\")\nreport_option(ENABLE_STATIC \"Static libraries\")\n\nif(ENABLE_SHARED)\n  set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_FULL_LIBDIR})\nendif()\n\nif(WITH_JPEG8 OR WITH_JPEG7)\n  set(WITH_ARITH_ENC 1)\n  set(WITH_ARITH_DEC 1)\nendif()\n\nif(WITH_ARITH_DEC)\n  set(D_ARITH_CODING_SUPPORTED 1)\nendif()\nreport_option(WITH_ARITH_DEC \"Arithmetic decoding support\")\n\nif(WITH_ARITH_ENC)\n  set(C_ARITH_CODING_SUPPORTED 1)\nendif()\nreport_option(WITH_ARITH_ENC \"Arithmetic encoding support\")\n\nreport_option(WITH_TURBOJPEG \"TurboJPEG API library\")\nreport_option(WITH_JAVA \"TurboJPEG Java wrapper\")\n\nif(NOT WITH_JPEG8)\n  set(MEM_SRCDST_FUNCTIONS \"global:  jpeg_mem_dest;  jpeg_mem_src;\")\nendif()\n\n# 0: Original libjpeg v6b/v7/v8 API/ABI\n#\n# libjpeg v6b/v7 API/ABI emulation:\n# 1: + In-memory source/destination managers (libjpeg-turbo 1.3.x)\n# 2: + Partial image decompression functions (libjpeg-turbo 1.5.x)\n# 3: + ICC functions (libjpeg-turbo 2.0.x)\n# 4: + 12-bit-per-sample and lossless functions (libjpeg-turbo 3.0.x)\n#\n# libjpeg v8 API/ABI emulation:\n# 1: + Partial image decompression functions (libjpeg-turbo 1.5.x)\n# 2: + ICC functions (libjpeg-turbo 2.0.x)\n# 3: + 12-bit-per-sample and lossless functions (libjpeg-turbo 3.0.x)\nset(SO_AGE 3)\nif(NOT WITH_JPEG8)\n  set(SO_AGE 4)\nendif()\n\nif(WITH_JPEG8)\n  set(JPEG_LIB_VERSION 80)\nelseif(WITH_JPEG7)\n  set(JPEG_LIB_VERSION 70)\nelse()\n  set(JPEG_LIB_VERSION 62)\nendif()\n\nmath(EXPR JPEG_LIB_VERSION_DIV10 \"${JPEG_LIB_VERSION} / 10\")\nmath(EXPR JPEG_LIB_VERSION_MOD10 \"${JPEG_LIB_VERSION} % 10\")\nif(JPEG_LIB_VERSION STREQUAL \"62\")\n  set(DEFAULT_SO_MAJOR_VERSION ${JPEG_LIB_VERSION})\nelse()\n  set(DEFAULT_SO_MAJOR_VERSION ${JPEG_LIB_VERSION_DIV10})\nendif()\nif(JPEG_LIB_VERSION STREQUAL \"80\")\n  set(DEFAULT_SO_MINOR_VERSION 2)\nelse()\n  set(DEFAULT_SO_MINOR_VERSION 0)\nendif()\n\n# This causes SO_MAJOR_VERSION/SO_MINOR_VERSION to reset to defaults if\n# WITH_JPEG7 or WITH_JPEG8 has changed.\nif((DEFINED WITH_JPEG7_INT AND NOT WITH_JPEG7 EQUAL WITH_JPEG7_INT) OR\n  (DEFINED WITH_JPEG8_INT AND NOT WITH_JPEG8 EQUAL WITH_JPEG8_INT))\n  set(FORCE_SO_VERSION \"FORCE\")\nendif()\nset(WITH_JPEG7_INT ${WITH_JPEG7} CACHE INTERNAL \"\")\nset(WITH_JPEG8_INT ${WITH_JPEG8} CACHE INTERNAL \"\")\n\nset(SO_MAJOR_VERSION ${DEFAULT_SO_MAJOR_VERSION} CACHE STRING\n  \"Major version of the libjpeg API shared library (default: ${DEFAULT_SO_MAJOR_VERSION})\"\n  ${FORCE_SO_VERSION})\nset(SO_MINOR_VERSION ${DEFAULT_SO_MINOR_VERSION} CACHE STRING\n  \"Minor version of the libjpeg API shared library (default: ${DEFAULT_SO_MINOR_VERSION})\"\n  ${FORCE_SO_VERSION})\n\nset(JPEG_LIB_VERSION_DECIMAL \"${JPEG_LIB_VERSION_DIV10}.${JPEG_LIB_VERSION_MOD10}\")\nmessage(STATUS \"Emulating libjpeg API/ABI v${JPEG_LIB_VERSION_DECIMAL} (WITH_JPEG7 = ${WITH_JPEG7}, WITH_JPEG8 = ${WITH_JPEG8})\")\nmessage(STATUS \"libjpeg API shared library version = ${SO_MAJOR_VERSION}.${SO_AGE}.${SO_MINOR_VERSION}\")\n\n# Because the TurboJPEG API library uses versioned symbols and changes the\n# names of functions whenever they are modified in a backward-incompatible\n# manner, it is always backward-ABI-compatible with itself, so the major and\n# minor SO versions don't change.  However, we increase the middle number (the\n# SO \"age\") whenever functions are added to the API, because adding functions\n# affects forward API/ABI compatibility.\nset(TURBOJPEG_SO_MAJOR_VERSION 0)\n# 0: TurboJPEG 1.3.x API\n# 1: TurboJPEG 1.4.x API\n#    The TurboJPEG 1.5.x API modified some of the function prototypes, adding\n#    the const keyword in front of pointers to unmodified buffers, but that did\n#    not affect forward API/ABI compatibility.\n# 2: TurboJPEG 2.0.x API\n#    The TurboJPEG 2.1.x API modified the behavior of the tjDecompressHeader3()\n#    function so that it accepts \"abbreviated table specification\" (AKA\n#    \"tables-only\") datastreams as well as JPEG images, but that did not affect\n#    forward API/ABI compatibility.\n# 3: TurboJPEG 3.0.x API\n# 4: TurboJPEG 3.1.x API\nset(TURBOJPEG_SO_AGE 4)\nset(TURBOJPEG_SO_VERSION 0.${TURBOJPEG_SO_AGE}.0)\n\n\n###############################################################################\n# COMPILER SETTINGS\n###############################################################################\n\nstring(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)\n\nif(MSVC_LIKE)\n  option(WITH_CRT_DLL\n    \"Link all ${CMAKE_PROJECT_NAME} libraries and executables with the C run-time DLL (msvcr*.dll) instead of the static C run-time library (libcmt*.lib.)  The default is to use the C run-time DLL only with the libraries and executables that need it.\"\n    FALSE)\n  boolean_number(WITH_CRT_DLL)\n  if(NOT WITH_CRT_DLL)\n    # Use the static C library for all build types\n    if(CMAKE_VERSION VERSION_EQUAL \"3.15\" OR\n      CMAKE_VERSION VERSION_GREATER \"3.15\")\n      if(CMAKE_BUILD_TYPE_UC STREQUAL \"DEBUG\")\n        set(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreadedDebug)\n      elseif(MSVC_IDE)\n        set(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\n      else()\n        set(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreaded)\n      endif()\n      message(STATUS \"Visual C++ run-time library: ${CMAKE_MSVC_RUNTIME_LIBRARY} (WITH_CRT_DLL = ${WITH_CRT_DLL})\")\n    elseif(MSVC)\n      foreach(var CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE\n        CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO)\n        if(${var} MATCHES \"/MD\")\n          string(REGEX REPLACE \"/MD\" \"/MT\" ${var} \"${${var}}\")\n        endif()\n      endforeach()\n    endif()\n  endif()\n  add_definitions(-D_CRT_NONSTDC_NO_WARNINGS)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n  # Use the maximum optimization level for release builds\n  foreach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO)\n    if(${var} MATCHES \"-O2\")\n      string(REGEX REPLACE \"-O2\" \"-O3\" ${var} \"${${var}}\")\n    endif()\n  endforeach()\nendif()\n\nif(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\")\n  if(CMAKE_C_COMPILER_ID MATCHES \"SunPro\")\n    # Use the maximum optimization level for release builds\n    foreach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO)\n      if(${var} MATCHES \"-xO3\")\n        string(REGEX REPLACE \"-xO3\" \"-xO5\" ${var} \"${${var}}\")\n      endif()\n      if(${var} MATCHES \"-xO2\")\n        string(REGEX REPLACE \"-xO2\" \"-xO5\" ${var} \"${${var}}\")\n      endif()\n    endforeach()\n  endif()\nendif()\n\nset(EFFECTIVE_C_FLAGS \"${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE_UC}}\")\nmessage(STATUS \"Compiler flags = ${EFFECTIVE_C_FLAGS}\")\n\nset(EFFECTIVE_LD_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS_${CMAKE_BUILD_TYPE_UC}}\")\nmessage(STATUS \"Linker flags = ${EFFECTIVE_LD_FLAGS}\")\n\ninclude(CheckCSourceCompiles)\ninclude(CheckIncludeFiles)\ninclude(CheckTypeSize)\n\ncheck_type_size(\"size_t\" SIZE_T)\ncheck_type_size(\"unsigned long\" UNSIGNED_LONG)\n\nif(SIZE_T EQUAL UNSIGNED_LONG)\n  check_c_source_compiles(\"int main(int argc, char **argv) { unsigned long a = argc;  return __builtin_ctzl(a); }\"\n    HAVE_BUILTIN_CTZL)\nendif()\nif(MSVC_LIKE)\n  check_include_files(\"intrin.h\" HAVE_INTRIN_H)\nendif()\n\nif(UNIX)\n  if(CMAKE_CROSSCOMPILING)\n    set(RIGHT_SHIFT_IS_UNSIGNED 0)\n  else()\n    include(CheckCSourceRuns)\n    check_c_source_runs(\"\n      #include <stdio.h>\n      #include <stdlib.h>\n      static int is_shifting_signed (long arg) {\n        long res = arg >> 4;\n        if (res == -0x7F7E80CL)\n          return 1; /* right shift is signed */\n        /* see if unsigned-shift hack will fix it. */\n        /* we can't just test exact value since it depends on width of long... */\n        res |= 0xFFFFFFFFL << (32-4);\n        if (res == -0x7F7E80CL)\n          return 0; /* right shift is unsigned */\n        printf(\\\"Right shift isn't acting as I expect it to.\\\\\\\\n\\\");\n        printf(\\\"I fear the JPEG software will not work at all.\\\\\\\\n\\\\\\\\n\\\");\n        return 0; /* try it with unsigned anyway */\n      }\n      int main (void) {\n        exit(is_shifting_signed(-0x7F7E80B1L));\n      }\" RIGHT_SHIFT_IS_UNSIGNED)\n  endif()\nendif()\n\nif(NOT MSVC OR CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n  check_c_source_compiles(\"extern const int table[1]; const int __attribute__((visibility(\\\"hidden\\\"))) table[1] = { 0 }; int main(void) { return table[0]; }\"\n    HIDDEN_WORKS)\n  if(HIDDEN_WORKS)\n    set(HIDDEN \"__attribute__((visibility(\\\"hidden\\\")))\")\n    message(STATUS \"HIDDEN = ${HIDDEN}\")\n  endif()\nendif()\n\nif(MSVC)\n  set(INLINE_OPTIONS \"__inline;inline\")\nelse()\n  set(INLINE_OPTIONS \"__inline__;inline\")\nendif()\noption(FORCE_INLINE \"Force function inlining\" TRUE)\nboolean_number(FORCE_INLINE)\nif(FORCE_INLINE)\n  if(MSVC)\n    list(INSERT INLINE_OPTIONS 0 \"__forceinline\")\n  else()\n    list(INSERT INLINE_OPTIONS 0 \"inline __attribute__((always_inline))\")\n    list(INSERT INLINE_OPTIONS 0 \"__inline__ __attribute__((always_inline))\")\n  endif()\nendif()\nforeach(inline ${INLINE_OPTIONS})\n  check_c_source_compiles(\"${inline} static int foo(void) { return 0; } int main(void) { return foo(); }\"\n    INLINE_WORKS)\n  if(INLINE_WORKS)\n    set(INLINE ${inline})\n    break()\n  endif()\nendforeach()\nif(NOT INLINE_WORKS)\n  message(FATAL_ERROR \"Could not determine how to inline functions.\")\nendif()\nmessage(STATUS \"INLINE = ${INLINE} (FORCE_INLINE = ${FORCE_INLINE})\")\n\nif(MSVC)\n  set(THREAD_LOCAL \"__declspec(thread)\")\nelse()\n  set(THREAD_LOCAL \"__thread\")\nendif()\ncheck_c_source_compiles(\"static ${THREAD_LOCAL} int i;  int main(void) { i = 0;  return i; }\"\n  HAVE_THREAD_LOCAL)\nif(HAVE_THREAD_LOCAL)\n  message(STATUS \"THREAD_LOCAL = ${THREAD_LOCAL}\")\nelse()\n  message(WARNING \"Thread-local storage is not available.  The TurboJPEG API library's global error handler will not be thread-safe.\")\n  unset(THREAD_LOCAL)\nendif()\n\nif(UNIX AND NOT APPLE)\n  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map \"VERS_1 { global: *; };\")\n  set(CMAKE_REQUIRED_FLAGS\n    \"-Wl,--version-script,${CMAKE_CURRENT_BINARY_DIR}/conftest.map\")\n  check_c_source_compiles(\"int main(void) { return 0; }\" HAVE_VERSION_SCRIPT)\n  set(CMAKE_REQUIRED_FLAGS)\n  file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map)\n  if(HAVE_VERSION_SCRIPT)\n    message(STATUS \"Linker supports GNU-style version scripts\")\n    set(MAPFLAG \"-Wl,--version-script,\")\n    set(TJMAPFLAG \"-Wl,--version-script,\")\n  else()\n    message(STATUS \"Linker does not support GNU-style version scripts\")\n    if(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\")\n      # The Solaris linker doesn't like our version script for the libjpeg API\n      # library, but the version script for the TurboJPEG API library should\n      # still work.\n      file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map\n        \"VERS_1 { global: foo;  local: *; }; VERS_2 { global: foo2; } VERS_1;\")\n      set(CMAKE_REQUIRED_FLAGS \"-Wl,-M,${CMAKE_CURRENT_BINARY_DIR}/conftest.map -shared\")\n      check_c_source_compiles(\"int foo() { return 0; } int foo2() { return 2; }\"\n        HAVE_MAPFILE)\n      set(CMAKE_REQUIRED_FLAGS)\n      file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map)\n      if(HAVE_MAPFILE)\n        message(STATUS \"Linker supports mapfiles\")\n        set(TJMAPFLAG \"-Wl,-M,\")\n      else()\n        message(STATUS \"Linker does not support mapfiles\")\n      endif()\n    endif()\n  endif()\nendif()\n\n# Generate files\nconfigure_file(src/jversion.h.in jversion.h)\nif(UNIX)\n  configure_file(src/libjpeg.map.in libjpeg.map)\nendif()\n\n# Include directories and compiler definitions\ninclude_directories(${CMAKE_CURRENT_BINARY_DIR}\n  ${CMAKE_CURRENT_SOURCE_DIR}/src)\n\n\n###############################################################################\n# TARGETS\n###############################################################################\n\nif(CMAKE_EXECUTABLE_SUFFIX_TMP)\n  set(CMAKE_EXECUTABLE_SUFFIX ${CMAKE_EXECUTABLE_SUFFIX_TMP})\nendif()\nmessage(STATUS \"CMAKE_EXECUTABLE_SUFFIX = ${CMAKE_EXECUTABLE_SUFFIX}\")\n\nset(JPEG16_SOURCES src/jcapistd.c src/jccolor.c src/jcdiffct.c src/jclossls.c\n  src/jcmainct.c src/jcprepct.c src/jcsample.c src/jdapistd.c src/jdcolor.c\n  src/jddiffct.c src/jdlossls.c src/jdmainct.c src/jdpostct.c src/jdsample.c\n  src/jutils.c)\nset(JPEG12_SOURCES ${JPEG16_SOURCES} src/jccoefct.c src/jcdctmgr.c\n  src/jdcoefct.c src/jddctmgr.c src/jdmerge.c src/jfdctfst.c src/jfdctint.c\n  src/jidctflt.c src/jidctfst.c src/jidctint.c src/jidctred.c src/jquant1.c\n  src/jquant2.c)\nset(JPEG_SOURCES ${JPEG12_SOURCES} src/jcapimin.c src/jchuff.c src/jcicc.c\n  src/jcinit.c src/jclhuff.c src/jcmarker.c src/jcmaster.c src/jcomapi.c\n  src/jcparam.c src/jcphuff.c src/jctrans.c src/jdapimin.c src/jdatadst.c\n  src/jdatasrc.c src/jdhuff.c src/jdicc.c src/jdinput.c src/jdlhuff.c\n  src/jdmarker.c src/jdmaster.c src/jdphuff.c src/jdtrans.c src/jerror.c\n  src/jfdctflt.c src/jmemmgr.c src/jmemnobs.c src/jpeg_nbits.c)\n\nif(WITH_ARITH_ENC OR WITH_ARITH_DEC)\n  set(JPEG_SOURCES ${JPEG_SOURCES} src/jaricom.c)\nendif()\n\nif(WITH_ARITH_ENC)\n  set(JPEG_SOURCES ${JPEG_SOURCES} src/jcarith.c)\nendif()\n\nif(WITH_ARITH_DEC)\n  set(JPEG_SOURCES ${JPEG_SOURCES} src/jdarith.c)\nendif()\n\nif(WITH_SIMD)\n  add_subdirectory(simd)\n  if(NEON_INTRINSICS)\n    add_definitions(-DNEON_INTRINSICS)\n  endif()\nelse()\n  message(STATUS \"SIMD extensions: None (WITH_SIMD = ${WITH_SIMD})\")\nendif()\n\n# We have to generate these here, because if the build system tries and fails\n# to enable the SIMD extensions, the value of WITH_SIMD will have changed.\nconfigure_file(src/jconfig.h.in jconfig.h)\nconfigure_file(src/jconfigint.h.in jconfigint.h)\n\nif(WITH_SIMD)\n  message(STATUS \"SIMD extensions: ${CPU_TYPE} (WITH_SIMD = ${WITH_SIMD})\")\n  if(MSVC_IDE OR XCODE)\n    set_source_files_properties(${SIMD_OBJS} PROPERTIES GENERATED 1)\n  endif()\n  set(SIMD_TARGET_OBJECTS $<TARGET_OBJECTS:simd>)\nendif()\n\nif(WITH_JAVA)\n  add_subdirectory(java)\nendif()\n\nif(ENABLE_SHARED)\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(jpeg12 OBJECT ${JPEG12_SOURCES})\n  set_property(TARGET jpeg12 PROPERTY COMPILE_FLAGS \"-DBITS_IN_JSAMPLE=12\")\n  set_target_properties(jpeg12 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n  add_library(jpeg16 OBJECT ${JPEG16_SOURCES})\n  set_property(TARGET jpeg16 PROPERTY COMPILE_FLAGS \"-DBITS_IN_JSAMPLE=16\")\n  set_target_properties(jpeg16 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n  add_subdirectory(sharedlib)\nendif()\n\nif(ENABLE_STATIC)\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(jpeg12-static OBJECT ${JPEG12_SOURCES})\n  set_property(TARGET jpeg12-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=12\")\n  add_library(jpeg16-static OBJECT ${JPEG16_SOURCES})\n  set_property(TARGET jpeg16-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=16\")\n  add_library(jpeg-static STATIC ${JPEG_SOURCES} ${SIMD_TARGET_OBJECTS}\n    ${SIMD_OBJS} $<TARGET_OBJECTS:jpeg12-static>\n    $<TARGET_OBJECTS:jpeg16-static>)\n  if(NOT MSVC_LIKE)\n    set_target_properties(jpeg-static PROPERTIES OUTPUT_NAME jpeg)\n  endif()\nendif()\n\nif(WITH_TURBOJPEG)\n  if(ENABLE_SHARED)\n    set(TURBOJPEG_SOURCES ${JPEG_SOURCES} ${SIMD_TARGET_OBJECTS} ${SIMD_OBJS}\n      src/turbojpeg.c src/transupp.c src/jdatadst-tj.c src/jdatasrc-tj.c\n      src/rdbmp.c src/rdppm.c src/wrbmp.c src/wrppm.c $<TARGET_OBJECTS:jpeg12>\n      $<TARGET_OBJECTS:jpeg16>)\n    set(TJMAPFILE ${CMAKE_CURRENT_SOURCE_DIR}/src/turbojpeg-mapfile)\n    if(WITH_JAVA)\n      set(TURBOJPEG_SOURCES ${TURBOJPEG_SOURCES} java/turbojpeg-jni.c)\n      include_directories(${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2})\n      set(TJMAPFILE ${CMAKE_CURRENT_SOURCE_DIR}/src/turbojpeg-mapfile.jni)\n    endif()\n    if(MSVC_LIKE)\n      configure_file(${CMAKE_SOURCE_DIR}/win/turbojpeg.rc.in\n        ${CMAKE_BINARY_DIR}/win/turbojpeg.rc)\n      set(TURBOJPEG_SOURCES ${TURBOJPEG_SOURCES}\n        ${CMAKE_BINARY_DIR}/win/turbojpeg.rc)\n    endif()\n    add_library(turbojpeg12 OBJECT src/rdppm.c src/wrppm.c)\n    set_property(TARGET turbojpeg12 PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=12 -DPPM_SUPPORTED\")\n    set_target_properties(turbojpeg12 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n    add_library(turbojpeg16 OBJECT src/rdppm.c src/wrppm.c)\n    set_property(TARGET turbojpeg16 PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED\")\n    set_target_properties(turbojpeg16 PROPERTIES POSITION_INDEPENDENT_CODE 1)\n    add_library(turbojpeg SHARED ${TURBOJPEG_SOURCES}\n      $<TARGET_OBJECTS:turbojpeg12> $<TARGET_OBJECTS:turbojpeg16>)\n    set_property(TARGET turbojpeg PROPERTY COMPILE_FLAGS\n      \"-DBMP_SUPPORTED -DPPM_SUPPORTED\")\n    if(WIN32)\n      set_target_properties(turbojpeg PROPERTIES DEFINE_SYMBOL DLLDEFINE)\n    endif()\n    if(MINGW)\n      set_target_properties(turbojpeg PROPERTIES LINK_FLAGS -Wl,--kill-at)\n    endif()\n    if(APPLE AND (NOT CMAKE_OSX_DEPLOYMENT_TARGET OR\n                  CMAKE_OSX_DEPLOYMENT_TARGET VERSION_GREATER 10.4))\n      if(NOT CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG)\n        set(CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG \"-Wl,-rpath,\")\n      endif()\n      set_target_properties(turbojpeg PROPERTIES MACOSX_RPATH 1)\n    endif()\n    set_target_properties(turbojpeg PROPERTIES\n      SOVERSION ${TURBOJPEG_SO_MAJOR_VERSION} VERSION ${TURBOJPEG_SO_VERSION})\n    if(TJMAPFLAG)\n      set_target_properties(turbojpeg PROPERTIES\n        LINK_FLAGS \"${TJMAPFLAG}${TJMAPFILE}\")\n    endif()\n\n    add_executable(tjunittest src/tjunittest.c src/tjutil.c src/md5/md5.c\n      src/md5/md5hl.c)\n    target_link_libraries(tjunittest turbojpeg)\n\n    add_executable(tjbench src/tjbench.c src/tjutil.c)\n    target_link_libraries(tjbench turbojpeg)\n    if(UNIX)\n      target_link_libraries(tjbench m)\n    endif()\n\n    add_executable(tjcomp src/tjcomp.c)\n    target_link_libraries(tjcomp turbojpeg)\n\n    add_executable(tjdecomp src/tjdecomp.c)\n    target_link_libraries(tjdecomp turbojpeg)\n\n    add_executable(tjtran src/tjtran.c)\n    target_link_libraries(tjtran turbojpeg)\n\n    add_custom_target(tjdoc COMMAND doxygen -s ../doc/doxygen.config\n      WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/src)\n  endif()\n\n  if(ENABLE_STATIC)\n    add_library(turbojpeg12-static OBJECT src/rdppm.c src/wrppm.c)\n    set_property(TARGET turbojpeg12-static PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=12 -DPPM_SUPPORTED\")\n    add_library(turbojpeg16-static OBJECT src/rdppm.c src/wrppm.c)\n    set_property(TARGET turbojpeg16-static PROPERTY COMPILE_FLAGS\n      \"-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED\")\n    add_library(turbojpeg-static STATIC ${JPEG_SOURCES} ${SIMD_TARGET_OBJECTS}\n      ${SIMD_OBJS} src/turbojpeg.c src/transupp.c src/jdatadst-tj.c\n      src/jdatasrc-tj.c src/rdbmp.c src/rdppm.c src/wrbmp.c src/wrppm.c\n      $<TARGET_OBJECTS:jpeg12-static> $<TARGET_OBJECTS:jpeg16-static>\n      $<TARGET_OBJECTS:turbojpeg12-static>\n      $<TARGET_OBJECTS:turbojpeg16-static>)\n    set_property(TARGET turbojpeg-static PROPERTY COMPILE_FLAGS\n      \"-DBMP_SUPPORTED -DPPM_SUPPORTED\")\n    if(NOT MSVC_LIKE)\n      set_target_properties(turbojpeg-static PROPERTIES OUTPUT_NAME turbojpeg)\n    endif()\n\n    add_executable(tjunittest-static src/tjunittest.c src/tjutil.c\n      src/md5/md5.c src/md5/md5hl.c)\n    target_link_libraries(tjunittest-static turbojpeg-static)\n\n    add_executable(tjbench-static src/tjbench.c src/tjutil.c)\n    target_link_libraries(tjbench-static turbojpeg-static)\n    if(UNIX)\n      target_link_libraries(tjbench-static m)\n    endif()\n  endif()\nendif()\n\nif(WIN32)\n  set(USE_SETMODE \"-DUSE_SETMODE\")\nendif()\nset(CDJPEG_COMPILE_FLAGS\n  \"-DBMP_SUPPORTED -DGIF_SUPPORTED -DPPM_SUPPORTED -DTARGA_SUPPORTED ${USE_SETMODE}\")\n\nif(ENABLE_STATIC)\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(cjpeg12-static OBJECT src/rdppm.c)\n  set_property(TARGET cjpeg12-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED\")\n  add_library(cjpeg16-static OBJECT src/rdppm.c)\n  set_property(TARGET cjpeg16-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=16 -DGIF_SUPPORTED -DPPM_SUPPORTED\")\n  add_executable(cjpeg-static src/cjpeg.c src/cdjpeg.c src/rdbmp.c src/rdgif.c\n    src/rdppm.c src/rdswitch.c src/rdtarga.c $<TARGET_OBJECTS:cjpeg12-static>\n    $<TARGET_OBJECTS:cjpeg16-static>)\n  set_property(TARGET cjpeg-static PROPERTY COMPILE_FLAGS\n    ${CDJPEG_COMPILE_FLAGS})\n  target_link_libraries(cjpeg-static jpeg-static)\n\n  # Compile a separate version of these source files with 12-bit and 16-bit\n  # data precision.\n  add_library(djpeg12-static OBJECT src/rdcolmap.c src/wrgif.c src/wrppm.c)\n  set_property(TARGET djpeg12-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED\")\n  add_library(djpeg16-static OBJECT src/wrppm.c)\n  set_property(TARGET djpeg16-static PROPERTY COMPILE_FLAGS\n    \"-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED\")\n  add_executable(djpeg-static src/djpeg.c src/cdjpeg.c src/rdcolmap.c\n    src/rdswitch.c src/wrbmp.c src/wrgif.c src/wrppm.c src/wrtarga.c\n    $<TARGET_OBJECTS:djpeg12-static> $<TARGET_OBJECTS:djpeg16-static>)\n  set_property(TARGET djpeg-static PROPERTY COMPILE_FLAGS\n    ${CDJPEG_COMPILE_FLAGS})\n  target_link_libraries(djpeg-static jpeg-static)\n\n  add_executable(jpegtran-static src/jpegtran.c src/cdjpeg.c src/rdswitch.c\n    src/transupp.c)\n  target_link_libraries(jpegtran-static jpeg-static)\n  set_property(TARGET jpegtran-static PROPERTY COMPILE_FLAGS \"${USE_SETMODE}\")\n\n  add_executable(example-static src/example.c)\n  target_link_libraries(example-static jpeg-static)\nendif()\n\nadd_executable(rdjpgcom src/rdjpgcom.c)\n\nadd_executable(wrjpgcom src/wrjpgcom.c)\n\n\n###############################################################################\n# TESTS\n###############################################################################\n\nif(WITH_FUZZ)\n  add_subdirectory(fuzz)\nendif()\n\nadd_executable(strtest src/strtest.c)\n\nadd_subdirectory(src/md5)\n\nif(GENERATOR_IS_MULTI_CONFIG)\n  set(OBJDIR \"\\${CTEST_CONFIGURATION_TYPE}/\")\nelse()\n  set(OBJDIR \"\")\nendif()\n\nenable_testing()\n\nif(WITH_JAVA)\n  add_test(TJUnitTest\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest)\n  add_test(TJUnitTest-yuv\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -yuv)\n  add_test(TJUnitTest-yuv-nopad\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -yuv -noyuvpad)\n  add_test(TJUnitTest-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -lossless)\n  add_test(TJUnitTest-bi\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi)\n  add_test(TJUnitTest-bi-yuv\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi -yuv)\n  add_test(TJUnitTest-bi-yuv-nopad\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi -yuv -noyuvpad)\n  add_test(TJUnitTest-bi-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bi -lossless)\n  add_test(TJUnitTest-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -bmp)\n  add_test(TJUnitTest12\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 12)\n  add_test(TJUnitTest12-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 12 -lossless)\n  add_test(TJUnitTest12-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 12 -bmp)\n  add_test(TJUnitTest2-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 2)\n  add_test(TJUnitTest2-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 2 -bmp)\n  add_test(TJUnitTest3-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 3)\n  add_test(TJUnitTest3-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 3 -bmp)\n  add_test(TJUnitTest4-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 4)\n  add_test(TJUnitTest4-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 4 -bmp)\n  add_test(TJUnitTest5-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 5)\n  add_test(TJUnitTest5-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 5 -bmp)\n  add_test(TJUnitTest6-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 6)\n  add_test(TJUnitTest6-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 6 -bmp)\n  add_test(TJUnitTest7-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 7)\n  add_test(TJUnitTest7-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 7 -bmp)\n  add_test(TJUnitTest9-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 9)\n  add_test(TJUnitTest9-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 9 -bmp)\n  add_test(TJUnitTest10-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 10)\n  add_test(TJUnitTest10-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 10 -bmp)\n  add_test(TJUnitTest11-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 11)\n  add_test(TJUnitTest11-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 11 -bmp)\n  add_test(TJUnitTest13-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 13)\n  add_test(TJUnitTest13-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 13 -bmp)\n  add_test(TJUnitTest14-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 14)\n  add_test(TJUnitTest14-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 14 -bmp)\n  add_test(TJUnitTest15-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 15)\n  add_test(TJUnitTest15-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 15 -bmp)\n  add_test(TJUnitTest16-lossless\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 16)\n  add_test(TJUnitTest16-bmp\n    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar\n      -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}\n      TJUnitTest -precision 16 -bmp)\nendif()\n\nset(TEST_LIBTYPES \"\")\nif(ENABLE_SHARED)\n  set(TEST_LIBTYPES ${TEST_LIBTYPES} shared)\nendif()\nif(ENABLE_STATIC)\n  set(TEST_LIBTYPES ${TEST_LIBTYPES} static)\nendif()\n\nset(TESTIMAGES ${CMAKE_CURRENT_SOURCE_DIR}/testimages)\nif(CMAKE_CROSSCOMPILING)\n  file(RELATIVE_PATH TESTIMAGES ${CMAKE_CURRENT_BINARY_DIR} ${TESTIMAGES})\nendif()\n\n# The output of the floating point DCT/IDCT algorithms differs depending on the\n# type of floating point math used, so the FLOATTEST8 and FLOATTEST12 CMake\n# variables must be set in order to tell the testing system which floating\n# point results it should expect:\n#\n# sse = validate against the expected results from the libjpeg-turbo SSE SIMD\n#       extensions\n# no-fp-contract = validate against the expected results from the C code when\n#                  floating point expression contraction is disabled (the\n#                  default with Clang 13 and earlier, when building for\n#                  platforms that lack fused multiply-add [FMA] instructions,\n#                  or when passing -ffp-contract=off to GCC or Clang)\n# fp-contract = validate against the expected results from the C code when\n#               floating point expression contraction is enabled (the default\n#               with Clang 14 and later, with GCC when building for platforms\n#               that have fused multiply-add [FMA] instructions, or when\n#               passing -ffp-contract=fast to GCC or -ffp-contract=on to Clang)\n# 387 = validate against the expected results from the C code when the 387 FPU\n#       is being used for floating point math (which is generally the default\n#       with x86 compilers)\n# msvc = validate against the expected results from the C code when compiled\n#        with a 32-bit version of Visual C++\n\nif(CPU_TYPE STREQUAL \"x86_64\" OR CPU_TYPE STREQUAL \"i386\")\n  if(WITH_SIMD)\n    set(DEFAULT_FLOATTEST8 sse)\n  elseif(CPU_TYPE STREQUAL \"x86_64\")\n    set(DEFAULT_FLOATTEST8 no-fp-contract)\n  endif()\nelseif(CPU_TYPE STREQUAL \"powerpc\" OR CPU_TYPE STREQUAL \"arm64\")\n  if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    if(CMAKE_C_COMPILER_ID MATCHES \"AppleClang\")\n      # Xcode 14.3 and later\n      set(MIN_FP_CONTRACT_VERSION 14.0.1)\n    else()\n      set(MIN_FP_CONTRACT_VERSION 14.0.0)\n    endif()\n    if(CMAKE_C_COMPILER_VERSION VERSION_EQUAL ${MIN_FP_CONTRACT_VERSION} OR\n      CMAKE_C_COMPILER_VERSION VERSION_GREATER ${MIN_FP_CONTRACT_VERSION})\n      set(DEFAULT_FLOATTEST8 fp-contract)\n    else()\n      set(DEFAULT_FLOATTEST8 no-fp-contract)\n    endif()\n  elseif(CMAKE_COMPILER_IS_GNUCC)\n    set(DEFAULT_FLOATTEST8 fp-contract)\n  endif()\n# else we can't really set an intelligent default for FLOATTEST8.  The\n# appropriate value could be no-fp-contract, fp-contract, 387, or msvc,\n# depending on the compiler and compiler options.  We leave it to the user to\n# set FLOATTEST8 manually.\nendif()\n\n# This causes FLOATTEST8 to reset to the default value if WITH_SIMD has\n# changed.\nif(DEFINED WITH_SIMD_INT AND NOT WITH_SIMD EQUAL WITH_SIMD_INT)\n  set(FORCE_FLOATTEST8 \"FORCE\")\nendif()\nset(WITH_SIMD_INT ${WITH_SIMD} CACHE INTERNAL \"\")\nset(FLOATTEST8 ${DEFAULT_FLOATTEST8} CACHE STRING\n  \"The type of floating point math used by the 8-bit-per-sample floating point DCT/IDCT algorithms.  This tells the testing system which numerical results it should expect from those tests.  [sse = libjpeg-turbo x86/x86-64 SIMD extensions, no-fp-contract = generic FPU with floating point expression contraction disabled, fp-contract = generic FPU with floating point expression contraction enabled, 387 = 387 FPU, msvc = 32-bit Visual Studio] (default = ${DEFAULT_FLOATTEST8})\"\n  ${FORCE_FLOATTEST8})\nmessage(STATUS \"FLOATTEST8 = ${FLOATTEST8}\")\n\nif(FLOATTEST8)\n  string(TOUPPER ${FLOATTEST8} FLOATTEST8_UC)\n  string(REGEX REPLACE \"-\" \"_\" FLOATTEST8_UC ${FLOATTEST8_UC})\n  string(TOLOWER ${FLOATTEST8} FLOATTEST8)\n  if(NOT FLOATTEST8 STREQUAL \"sse\" AND\n    NOT FLOATTEST8 STREQUAL \"no-fp-contract\" AND\n    NOT FLOATTEST8 STREQUAL \"fp-contract\" AND NOT FLOATTEST8 STREQUAL \"387\" AND\n    NOT FLOATTEST8 STREQUAL \"msvc\")\n    message(FATAL_ERROR \"\\\"${FLOATTEST8}\\\" is not a valid value for FLOATTEST8.\")\n  endif()\nendif()\n\nif(CPU_TYPE STREQUAL \"x86_64\")\n  set(DEFAULT_FLOATTEST12 no-fp-contract)\nelseif(CPU_TYPE STREQUAL \"powerpc\" OR CPU_TYPE STREQUAL \"arm64\")\n  if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    if(CMAKE_C_COMPILER_ID MATCHES \"AppleClang\")\n      # Xcode 14.3 and later\n      set(MIN_FP_CONTRACT_VERSION 14.0.1)\n    else()\n      set(MIN_FP_CONTRACT_VERSION 14.0.0)\n    endif()\n    if(CMAKE_C_COMPILER_VERSION VERSION_EQUAL ${MIN_FP_CONTRACT_VERSION} OR\n      CMAKE_C_COMPILER_VERSION VERSION_GREATER ${MIN_FP_CONTRACT_VERSION})\n      set(DEFAULT_FLOATTEST12 fp-contract)\n    else()\n      set(DEFAULT_FLOATTEST12 no-fp-contract)\n    endif()\n  elseif(CMAKE_COMPILER_IS_GNUCC)\n    set(DEFAULT_FLOATTEST12 fp-contract)\n  endif()\n# else we can't really set an intelligent default for FLOATTEST12.  The\n# appropriate value could be no-fp-contract, fp-contract, or something else,\n# depending on the compiler and compiler options.  We leave it to the user to\n# set FLOATTEST12 manually.\nendif()\n\nset(FLOATTEST12 ${DEFAULT_FLOATTEST12} CACHE STRING\n  \"The type of floating point math used by the 12-bit-per-sample floating point DCT/IDCT algorithms.  This tells the testing system which numerical results it should expect from those tests.  [sse = libjpeg-turbo x86/x86-64 SIMD extensions, no-fp-contract = generic FPU with floating point expression contraction disabled, fp-contract = generic FPU with floating point expression contraction enabled, 387 = 387 FPU, msvc = 32-bit Visual Studio] (default = ${DEFAULT_FLOATTEST12})\")\nmessage(STATUS \"FLOATTEST12 = ${FLOATTEST12}\")\n\nif(FLOATTEST12)\n  string(TOUPPER ${FLOATTEST12} FLOATTEST12_UC)\n  string(REGEX REPLACE \"-\" \"_\" FLOATTEST12_UC ${FLOATTEST12_UC})\n  string(TOLOWER ${FLOATTEST12} FLOATTEST12)\n  if(NOT FLOATTEST12 STREQUAL \"sse\" AND\n    NOT FLOATTEST12 STREQUAL \"no-fp-contract\" AND\n    NOT FLOATTEST12 STREQUAL \"fp-contract\" AND\n    NOT FLOATTEST12 STREQUAL \"387\" AND\n    NOT FLOATTEST12 STREQUAL \"msvc\")\n    message(FATAL_ERROR \"\\\"${FLOATTEST12}\\\" is not a valid value for FLOATTEST12.\")\n  endif()\nendif()\n\nforeach(libtype ${TEST_LIBTYPES})\n  if(libtype STREQUAL \"static\")\n    set(suffix -static)\n  endif()\n  if(WITH_TURBOJPEG)\n    add_test(NAME tjunittest-${libtype}\n      COMMAND tjunittest${suffix})\n    add_test(NAME tjunittest-${libtype}-alloc\n      COMMAND tjunittest${suffix} -alloc)\n    add_test(NAME tjunittest-${libtype}-yuv\n      COMMAND tjunittest${suffix} -yuv)\n    add_test(NAME tjunittest-${libtype}-yuv-alloc\n      COMMAND tjunittest${suffix} -yuv -alloc)\n    add_test(NAME tjunittest-${libtype}-yuv-nopad\n      COMMAND tjunittest${suffix} -yuv -noyuvpad)\n    add_test(NAME tjunittest-${libtype}-lossless\n      COMMAND tjunittest${suffix} -lossless)\n    add_test(NAME tjunittest-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -lossless -alloc)\n    add_test(NAME tjunittest-${libtype}-bmp\n      COMMAND tjunittest${suffix} -bmp)\n    add_test(NAME tjunittest12-${libtype}\n      COMMAND tjunittest${suffix} -precision 12)\n    add_test(NAME tjunittest12-${libtype}-alloc\n      COMMAND tjunittest${suffix} -precision 12 -alloc)\n    add_test(NAME tjunittest12-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 12 -lossless)\n    add_test(NAME tjunittest12-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 12 -lossless -alloc)\n    add_test(NAME tjunittest12-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 12 -bmp)\n    add_test(NAME tjunittest2-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 2)\n    add_test(NAME tjunittest2-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 2 -alloc)\n    add_test(NAME tjunittest2-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 2 -bmp)\n    add_test(NAME tjunittest3-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 3)\n    add_test(NAME tjunittest3-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 3 -alloc)\n    add_test(NAME tjunittest3-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 3 -bmp)\n    add_test(NAME tjunittest4-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 4)\n    add_test(NAME tjunittest4-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 4 -alloc)\n    add_test(NAME tjunittest4-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 4 -bmp)\n    add_test(NAME tjunittest5-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 5)\n    add_test(NAME tjunittest5-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 5 -alloc)\n    add_test(NAME tjunittest5-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 5 -bmp)\n    add_test(NAME tjunittest6-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 6)\n    add_test(NAME tjunittest6-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 6 -alloc)\n    add_test(NAME tjunittest6-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 6 -bmp)\n    add_test(NAME tjunittest7-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 7)\n    add_test(NAME tjunittest7-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 7 -alloc)\n    add_test(NAME tjunittest7-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 7 -bmp)\n    add_test(NAME tjunittest9-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 9)\n    add_test(NAME tjunittest9-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 9 -alloc)\n    add_test(NAME tjunittest9-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 9 -bmp)\n    add_test(NAME tjunittest10-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 10)\n    add_test(NAME tjunittest10-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 10 -alloc)\n    add_test(NAME tjunittest10-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 10 -bmp)\n    add_test(NAME tjunittest11-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 11)\n    add_test(NAME tjunittest11-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 11 -alloc)\n    add_test(NAME tjunittest11-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 11 -bmp)\n    add_test(NAME tjunittest13-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 13)\n    add_test(NAME tjunittest13-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 13 -alloc)\n    add_test(NAME tjunittest13-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 13 -bmp)\n    add_test(NAME tjunittest14-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 14)\n    add_test(NAME tjunittest14-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 14 -alloc)\n    add_test(NAME tjunittest14-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 14 -bmp)\n    add_test(NAME tjunittest15-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 15)\n    add_test(NAME tjunittest15-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 15 -alloc)\n    add_test(NAME tjunittest15-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 15 -bmp)\n    add_test(NAME tjunittest16-${libtype}-lossless\n      COMMAND tjunittest${suffix} -precision 16)\n    add_test(NAME tjunittest16-${libtype}-lossless-alloc\n      COMMAND tjunittest${suffix} -precision 16 -alloc)\n    add_test(NAME tjunittest16-${libtype}-bmp\n      COMMAND tjunittest${suffix} -precision 16 -bmp)\n\n    foreach(sample_bits 8 12)\n\n      if(sample_bits EQUAL 12)\n        set(tjbench tjbench12)\n        set(testout testout12${suffix})\n\n        set(MD5_PPM_GRAY_TILE 2f799249148b1a9d0e61fa4408f6c397)\n        set(MD5_PPM_420_8x8_TILE b25684e1af37be504ee3fd137757353f)\n        set(MD5_PPM_420_16x16_TILE 2c1af444a63d19167eb3f4c1fa7f1b67)\n        set(MD5_PPM_420_32x32_TILE cce091fe18688f39bc0b5ba29238e1e2)\n        set(MD5_PPM_420_64x64_TILE f770ec8f710a014606dee662bc88606d)\n        set(MD5_PPM_420_128x128_TILE a841bc82e9eda34cbdefe53f808b339c)\n        set(MD5_PPM_420M_8x8_TILE 9de845a8d805affb9ae3a7b2712eaa46)\n        set(MD5_PPM_420M_TILE 455d273be0e229b9c8aabb16481bce5b)\n        set(MD5_PPM_422_8x8_TILE 5e9f784a98a7eae2789ea1458ed43748)\n        set(MD5_PPM_422_16x16_TILE c8df65a792d371a30c8fb7352f320314)\n        set(MD5_PPM_422_32x32_TILE b523b630237e3305a5c4d353ff4ee19b)\n        set(MD5_PPM_422_64x64_TILE eb30bdd20337079745b039e24e613bfd)\n        set(MD5_PPM_422_128x128_TILE 7997458635973b004da46863e2da55ea)\n        set(MD5_PPM_422M_8x8_TILE f8443fffd32cce7681dd36010ce43c07)\n        set(MD5_PPM_422M_TILE a0d45368343a63ca2c8ee87cc4ef9ded)\n        set(MD5_PPM_444_TILE 2f571a032e4dbc8ef40f75219d336b0b)\n      else()\n        set(tjbench tjbench)\n        set(testout testout${suffix})\n\n        set(MD5_PPM_GRAY_TILE 2c3b567086e6ca0c5e6d34ad8d6f6fe8)\n        set(MD5_PPM_420_8x8_TILE efca1bdf0226df01777137778cf986ec)\n        set(MD5_PPM_420_16x16_TILE 8c92c7453870d9e11c6d1dec3a8c9101)\n        set(MD5_PPM_420_32x32_TILE 3f7651872a95e469d1c7115f1b11ecef)\n        set(MD5_PPM_420_64x64_TILE f64c71af03fdea12363b62f1a3096aab)\n        set(MD5_PPM_420_128x128_TILE 5a5ef57517558c671bf5e75793588d69)\n        set(MD5_PPM_420M_8x8_TILE 66bd869b315a32a00fef1a025661ce72)\n        set(MD5_PPM_420M_TILE bf9ec2ab4875abb2efcce8f876fe2c2a)\n        set(MD5_PPM_422_8x8_TILE c300553ce1b3b90fd414ec96b62fe988)\n        set(MD5_PPM_422_16x16_TILE 6559ddb1191f5b2d3eb41081b254c4e0)\n        set(MD5_PPM_422_32x32_TILE 58691797f4584c4c5ed5965a6bb9aec0)\n        set(MD5_PPM_422_64x64_TILE 7f9e34942ae46af7b784f459ec133f5e)\n        set(MD5_PPM_422_128x128_TILE 6afcb77580d85dd3eacb04b3c2bc7710)\n        set(MD5_PPM_422M_8x8_TILE 55df1f96bcfb631aedeb940cf3f011f5)\n        set(MD5_PPM_422M_TILE 6502031018c2d2f69bc6353347f8df4d)\n        set(MD5_PPM_444_TILE 87bd58005eec73f0f313c8e38d0d793c)\n      endif()\n\n      # Test compressing from/decompressing to an arbitrary subregion of a\n      # larger image buffer\n      add_test(NAME ${tjbench}-${libtype}-tile-cp\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n          ${TESTIMAGES}/testorig.ppm ${testout}_tile.ppm)\n      add_test(NAME ${tjbench}-${libtype}-tile\n        COMMAND tjbench${suffix} ${testout}_tile.ppm 95\n          -precision ${sample_bits} -rgb -quiet -tile -benchtime 0.01\n          -warmup 0)\n      set_tests_properties(${tjbench}-${libtype}-tile\n        PROPERTIES DEPENDS ${tjbench}-${libtype}-tile-cp)\n\n      foreach(tile 8 16 32 64 128)\n        add_test(NAME ${tjbench}-${libtype}-tile-gray-${tile}x${tile}-cmp\n          COMMAND md5cmp ${MD5_PPM_GRAY_TILE}\n            ${testout}_tile_GRAY_Q95_${tile}x${tile}.ppm)\n        foreach(subsamp 420 422)\n          add_test(NAME ${tjbench}-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp\n            COMMAND md5cmp ${MD5_PPM_${subsamp}_${tile}x${tile}_TILE}\n              ${testout}_tile_${subsamp}_Q95_${tile}x${tile}.ppm)\n        endforeach()\n        add_test(NAME ${tjbench}-${libtype}-tile-444-${tile}x${tile}-cmp\n          COMMAND md5cmp ${MD5_PPM_444_TILE}\n            ${testout}_tile_444_Q95_${tile}x${tile}.ppm)\n        foreach(subsamp gray 420 422 444)\n          set_tests_properties(\n            ${tjbench}-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp\n            PROPERTIES DEPENDS ${tjbench}-${libtype}-tile)\n        endforeach()\n      endforeach()\n\n      add_test(NAME ${tjbench}-${libtype}-tilem-cp\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n          ${TESTIMAGES}/testorig.ppm ${testout}_tilem.ppm)\n      add_test(NAME ${tjbench}-${libtype}-tilem\n        COMMAND tjbench${suffix} ${testout}_tilem.ppm 95\n          -precision ${sample_bits} -rgb -fastupsample -quiet -tile\n          -benchtime 0.01 -warmup 0)\n      set_tests_properties(${tjbench}-${libtype}-tilem\n        PROPERTIES DEPENDS ${tjbench}-${libtype}-tilem-cp)\n\n      add_test(NAME ${tjbench}-${libtype}-tile-420m-8x8-cmp\n        COMMAND md5cmp ${MD5_PPM_420M_8x8_TILE}\n          ${testout}_tilem_420_Q95_8x8.ppm)\n      add_test(NAME ${tjbench}-${libtype}-tile-422m-8x8-cmp\n        COMMAND md5cmp ${MD5_PPM_422M_8x8_TILE}\n          ${testout}_tilem_422_Q95_8x8.ppm)\n      foreach(tile 16 32 64 128)\n        foreach(subsamp 420 422)\n          add_test(NAME ${tjbench}-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp\n            COMMAND md5cmp ${MD5_PPM_${subsamp}M_TILE}\n              ${testout}_tilem_${subsamp}_Q95_${tile}x${tile}.ppm)\n        endforeach()\n      endforeach()\n      foreach(tile 8 16 32 64 128)\n        foreach(subsamp 420 422)\n          set_tests_properties(\n            ${tjbench}-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp\n            PROPERTIES DEPENDS ${tjbench}-${libtype}-tilem)\n        endforeach()\n      endforeach()\n\n    endforeach()\n\n  endif()\n\n  # These tests are carefully crafted to provide full coverage of as many of\n  # the underlying algorithms as possible (including all of the\n  # SIMD-accelerated ones.)\n\n  macro(add_bittest PROG NAME ARGS OUTFILE INFILE MD5SUM)\n    if(${PROG} STREQUAL \"cjpeg16\")\n      set(ACTUAL_ARGS \"${ARGS};-precision;16\")\n    elseif(${PROG} STREQUAL \"cjpeg12\")\n      set(ACTUAL_ARGS \"${ARGS};-precision;12\")\n    else()\n      set(ACTUAL_ARGS ${ARGS})\n    endif()\n    string(REGEX REPLACE \"16\" \"\" ACTUAL_PROG ${PROG})\n    string(REGEX REPLACE \"12\" \"\" ACTUAL_PROG ${ACTUAL_PROG})\n    add_test(NAME ${PROG}-${libtype}-${NAME}\n      COMMAND ${ACTUAL_PROG}${suffix} ${ACTUAL_ARGS} -outfile ${OUTFILE}\n        ${INFILE})\n    add_test(NAME ${PROG}-${libtype}-${NAME}-cmp\n      COMMAND md5cmp ${MD5SUM} ${OUTFILE})\n    set_tests_properties(${PROG}-${libtype}-${NAME}-cmp PROPERTIES\n      DEPENDS ${PROG}-${libtype}-${NAME})\n    if(${ARGC} GREATER 6)\n      set(DEPENDS ${ARGN})\n      set_tests_properties(${PROG}-${libtype}-${NAME} PROPERTIES\n        DEPENDS ${DEPENDS})\n    endif()\n  endmacro()\n\n  set(MD5_JPEG_LOSSLESS fe99437df4e9976fe5e841969242b208)\n  set(MD5_PPM_LOSSLESS 01d9642a2b8723fefebbe9cb074ccd02)\n\n  # Lossless (all arguments other than -lossless and -restart should have no\n  # effect)\n  add_bittest(cjpeg16 lossless\n    \"-lossless;4;-restart;1;-quality;1;-grayscale;-optimize;-dct;float;-smooth;100;-baseline;-qslots;1,0,0;-sample;1x2,3x4,2x1\"\n    testout16_lossless.jpg ${TESTIMAGES}/testorig.ppm\n    ${MD5_JPEG_LOSSLESS})\n  add_bittest(djpeg16 lossless\n    \"-fast;-scale;1/8;-dct;float;-dither;none;-nosmooth;-onepass\"\n    testout16_lossless.ppm testout16_lossless.jpg\n    ${MD5_PPM_LOSSLESS} cjpeg16-${libtype}-lossless)\n\n  foreach(sample_bits 8 12)\n\n    if(sample_bits EQUAL 12)\n      set(cjpeg cjpeg12)\n      set(djpeg djpeg12)\n      set(jpegtran jpegtran12)\n      set(testout testout12${suffix})\n\n      set(TESTORIG testorig12.jpg)\n      set(MD5_JPEG_RGB_ISLOW 9d7369207c520d37f2c1cbfcb82b2964)\n      set(MD5_JPEG_RGB_ISLOW2 e619791332a99813bdca9f56fd60f9f9)\n      set(MD5_PPM_RGB_ISLOW f3301d2219783b8b3d942b7239fa50c0)\n      set(MD5_JPEG_422_IFAST_OPT 7322e3bd2f127f7de4b40d4480ce60e4)\n      set(MD5_PPM_422_IFAST 79807fa552899e66a04708f533e16950)\n      set(MD5_JPEG_440_ISLOW e25c1912e38367be505a89c410c1c2d2)\n      set(MD5_PPM_440_ISLOW e7d2e26288870cfcb30f3114ad01e380)\n      set(MD5_PPM_422M_IFAST 07737bfe8a7c1c87aaa393a0098d16b0)\n      set(MD5_JPEG_420_IFAST_Q100_PROG 9447cef4803d9b0f74bcf333cc710a29)\n      set(MD5_PPM_420_Q100_IFAST 1b3730122709f53d007255e8dfd3305e)\n      set(MD5_PPM_420M_Q100_IFAST 980a1a3c5bf9510022869d30b7d26566)\n      set(MD5_JPEG_GRAY_ISLOW 235c90707b16e2e069f37c888b2636d9)\n      set(MD5_PPM_GRAY_ISLOW 7213c10af507ad467da5578ca5ee1fca)\n      set(MD5_PPM_GRAY_ISLOW_RGB e96ee81c30a6ed422d466338bd3de65d)\n      set(MD5_JPEG_420S_IFAST_OPT 7af8e60be4d9c227ec63ac9b6630855e)\n\n      set(MD5_JPEG_3x2_FLOAT_PROG_SSE a8c17daf77b457725ec929e215b603f8)\n      set(MD5_PPM_3x2_FLOAT_SSE 42876ab9e5c2f76a87d08db5fbd57956)\n      set(MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT\n        a8c17daf77b457725ec929e215b603f8)\n      set(MD5_PPM_3x2_FLOAT_NO_FP_CONTRACT ${MD5_PPM_3x2_FLOAT_SSE})\n      set(MD5_JPEG_3x2_FLOAT_PROG_FP_CONTRACT\n        ${MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT})\n      if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT 2da9de6ae869e88b8372de815d366b03)\n      else()\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT ${MD5_PPM_3x2_FLOAT_SSE})\n      endif()\n      set(MD5_JPEG_3x2_FLOAT_PROG_387 bc6dbbefac2872f6b9d6c4a0ae60c3c0)\n      set(MD5_PPM_3x2_FLOAT_387 bcc5723c61560463ac60f772e742d092)\n      set(MD5_JPEG_3x2_FLOAT_PROG_MSVC e27840755870fa849872e58aa0cd1400)\n      set(MD5_PPM_3x2_FLOAT_MSVC 6c2880b83bb1aa41dfe330e7a9768690)\n\n      set(MD5_JPEG_3x2_IFAST_PROG 1396cc2b7185cfe943d408c9d305339e)\n      set(MD5_PPM_3x2_IFAST 3975985ef6eeb0a2cdc58daa651ccc00)\n      set(MD5_PPM_420M_ISLOW_2_1 4ca6be2a6f326ff9eaab63e70a8259c0)\n      set(MD5_PPM_420M_ISLOW_15_8 12aa9f9534c1b3d7ba047322226365eb)\n      set(MD5_PPM_420M_ISLOW_13_8 f7e22817c7b25e1393e4ec101e9d4e96)\n      set(MD5_PPM_420M_ISLOW_11_8 800a16f9f4dc9b293197bfe11be10a82)\n      set(MD5_PPM_420M_ISLOW_9_8 06b7a92a9bc69f4dc36ec40f1937d55c)\n      set(MD5_PPM_420M_ISLOW_7_8 3ec444a14a4ab4eab88ffc49c48eca43)\n      set(MD5_PPM_420M_ISLOW_3_4 3e726b7ea872445b19437d1c1d4f0d93)\n      set(MD5_PPM_420M_ISLOW_5_8 a8a771abdc94301d20ffac119b2caccd)\n      set(MD5_PPM_420M_ISLOW_1_2 b419124dd5568b085787234866102866)\n      set(MD5_PPM_420M_ISLOW_3_8 343d19015531b7bbe746124127244fa8)\n      set(MD5_PPM_420M_ISLOW_1_4 35fd59d866e44659edfa3c18db2a3edb)\n      set(MD5_PPM_420M_ISLOW_1_8 ccaed48ac0aedefda5d4abe4013f4ad7)\n      set(MD5_JPEG_LOSSLESS 8473501f5bb7c826524472c858bf4fcd)\n      set(MD5_PPM_LOSSLESS 1da3fb2620e5a4e258e0fcb891bc67e8)\n      set(MD5_PPM_420_ISLOW_SKIP15_31 86664cd9dc956536409e44e244d20a97)\n      set(MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71\n        452a21656115a163029cfba5c04fa76a)\n      set(MD5_PPM_444_ISLOW_SKIP1_6 ef63901f71ef7a75cd78253fc0914f84)\n      set(MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13\n        15b173fb5872d9575572fbcc1b05956f)\n      set(MD5_JPEG_CROP cdb35ff4b4519392690ea040c56ea99c)\n\n      set(MD5_JPEG_EXAMPLE_COMPRESS 5e502da0c3c0f957a58c536f31e973dc)\n      set(MD5_PPM_EXAMPLE_DECOMPRESS 70194fdcb73370ee7ba0db868d0c6fc8)\n    else()\n      set(cjpeg cjpeg)\n      set(djpeg djpeg)\n      set(jpegtran jpegtran)\n      set(testout testout${suffix})\n\n      set(TESTORIG testorig.jpg)\n      set(MD5_JPEG_RGB_ISLOW 1d44a406f61da743b5fd31c0a9abdca3)\n      set(MD5_JPEG_RGB_ISLOW2 b811e5ad807beb9384e51ef6a47f715d)\n      set(MD5_PPM_RGB_ISLOW 00a257f5393fef8821f2b88ac7421291)\n      set(MD5_BMP_RGB_ISLOW_565 f07d2e75073e4bb10f6c6f4d36e2e3be)\n      set(MD5_BMP_RGB_ISLOW_565D 4cfa0928ef3e6bb626d7728c924cfda4)\n      set(MD5_JPEG_422_IFAST_OPT 2540287b79d913f91665e660303ab2c8)\n      set(MD5_PPM_422_IFAST 35bd6b3f833bad23de82acea847129fa)\n      set(MD5_JPEG_440_ISLOW 538bc02bd4b4658fd85de6ece6cbeda6)\n      set(MD5_PPM_440_ISLOW 11e7eab7ef7ef3276934bb7e7b6bb377)\n      set(MD5_PPM_422M_IFAST 8dbc65323d62cca7c91ba02dd1cfa81d)\n      set(MD5_BMP_422M_IFAST_565 3294bd4d9a1f2b3d08ea6020d0db7065)\n      set(MD5_BMP_422M_IFAST_565D da98c9c7b6039511be4a79a878a9abc1)\n      set(MD5_JPEG_420_IFAST_Q100_PROG 0ba15f9dab81a703505f835f9dbbac6d)\n      set(MD5_PPM_420_Q100_IFAST 5a732542015c278ff43635e473a8a294)\n      set(MD5_PPM_420M_Q100_IFAST ff692ee9323a3b424894862557c092f1)\n      set(MD5_JPEG_GRAY_ISLOW 72b51f894b8f4a10b3ee3066770aa38d)\n      set(MD5_PPM_GRAY_ISLOW 8d3596c56eace32f205deccc229aa5ed)\n      set(MD5_PPM_GRAY_ISLOW_RGB 116424ac07b79e5e801f00508eab48ec)\n      set(MD5_BMP_GRAY_ISLOW_565 12f78118e56a2f48b966f792fedf23cc)\n      set(MD5_BMP_GRAY_ISLOW_565D bdbbd616441a24354c98553df5dc82db)\n      set(MD5_JPEG_420S_IFAST_OPT 388708217ac46273ca33086b22827ed8)\n\n      set(MD5_JPEG_3x2_FLOAT_PROG_SSE 343e3f8caf8af5986ebaf0bdc13b5c71)\n      set(MD5_PPM_3x2_FLOAT_SSE 1a75f36e5904d6fc3a85a43da9ad89bb)\n      set(MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT\n        9bca803d2042bd1eb03819e2bf92b3e5)\n      set(MD5_PPM_3x2_FLOAT_NO_FP_CONTRACT f6bfab038438ed8f5522fbd33595dcdc)\n      set(MD5_JPEG_3x2_FLOAT_PROG_FP_CONTRACT\n        ${MD5_JPEG_3x2_FLOAT_PROG_NO_FP_CONTRACT})\n      if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT ${MD5_PPM_3x2_FLOAT_NO_FP_CONTRACT})\n      else()\n        set(MD5_PPM_3x2_FLOAT_FP_CONTRACT 0e917a34193ef976b679a6b069b1be26)\n      endif()\n      set(MD5_JPEG_3x2_FLOAT_PROG_387 1657664a410e0822c924b54f6f65e6e9)\n      set(MD5_PPM_3x2_FLOAT_387 cb0a1f027f3d2917c902b5640214e025)\n      set(MD5_JPEG_3x2_FLOAT_PROG_MSVC 7999ce9cd0ee9b6c7043b7351ab7639d)\n      set(MD5_PPM_3x2_FLOAT_MSVC 28cdc448a6b75e97892f0e0f8d4b21f3)\n\n      set(MD5_JPEG_3x2_IFAST_PROG 1ee5d2c1a77f2da495f993c8c7cceca5)\n      set(MD5_PPM_3x2_IFAST fd283664b3b49127984af0a7f118fccd)\n      set(MD5_JPEG_420_ISLOW_ARI e986fb0a637a8d833d96e8a6d6d84ea1)\n      set(MD5_JPEG_444_ISLOW_PROGARI 0a8f1c8f66e113c3cf635df0a475a617)\n      set(MD5_PPM_420M_IFAST_ARI 57251da28a35b46eecb7177d82d10e0e)\n      set(MD5_JPEG_420_ISLOW 9a68f56bc76e466aa7e52f415d0f4a5f)\n      set(MD5_PPM_420M_ISLOW_2_1 9f9de8c0612f8d06869b960b05abf9c9)\n      set(MD5_PPM_420M_ISLOW_15_8 b6875bc070720b899566cc06459b63b7)\n      set(MD5_PPM_420M_ISLOW_13_8 bc3452573c8152f6ae552939ee19f82f)\n      set(MD5_PPM_420M_ISLOW_11_8 d8cc73c0aaacd4556569b59437ba00a5)\n      set(MD5_PPM_420M_ISLOW_9_8 d25e61bc7eac0002f5b393aa223747b6)\n      set(MD5_PPM_420M_ISLOW_7_8 ddb564b7c74a09494016d6cd7502a946)\n      set(MD5_PPM_420M_ISLOW_3_4 8ed8e68808c3fbc4ea764fc9d2968646)\n      set(MD5_PPM_420M_ISLOW_5_8 a3363274999da2366a024efae6d16c9b)\n      set(MD5_PPM_420M_ISLOW_1_2 e692a315cea26b988c8e8b29a5dbcd81)\n      set(MD5_PPM_420M_ISLOW_3_8 79eca9175652ced755155c90e785a996)\n      set(MD5_PPM_420M_ISLOW_1_4 79cd778f8bf1a117690052cacdd54eca)\n      set(MD5_PPM_420M_ISLOW_1_8 391b3d4aca640c8567d6f8745eb2142f)\n      set(MD5_BMP_420_ISLOW_256 4980185e3776e89bd931736e1cddeee6)\n      set(MD5_BMP_420_ISLOW_565 bf9d13e16c4923b92e1faa604d7922cb)\n      set(MD5_BMP_420_ISLOW_565D 6bde71526acc44bcff76f696df8638d2)\n      set(MD5_BMP_420M_ISLOW_565 8dc0185245353cfa32ad97027342216f)\n      set(MD5_BMP_420M_ISLOW_565D ce034037d212bc403330df6f915c161b)\n      set(MD5_JPEG_LOSSLESS fc777b82d42d835ae1282ba1ee87c209)\n      set(MD5_PPM_LOSSLESS 64072f1dbdc5b3a187777788604971a5)\n      set(MD5_PPM_420_ISLOW_SKIP15_31 c4c65c1e43d7275cd50328a61e6534f0)\n      set(MD5_PPM_420_ISLOW_ARI_SKIP16_139 087c6b123db16ac00cb88c5b590bb74a)\n      set(MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71\n        26eb36ccc7d1f0cb80cdabb0ac8b5d99)\n      set(MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 886c6775af22370257122f8b16207e6d)\n      set(MD5_PPM_444_ISLOW_SKIP1_6 5606f86874cf26b8fcee1117a0a436a6)\n      set(MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13\n        db87dc7ce26bcdc7a6b56239ce2b9d6c)\n      set(MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 cb57b32bd6d03e35432362f7bf184b6d)\n      set(MD5_JPEG_CROP b4197f377e621c4e9b1d20471432610d)\n\n      set(MD5_JPEG_EXAMPLE_COMPRESS 95d4d72e2ef127332654c2599afb47bf)\n      set(MD5_PPM_EXAMPLE_DECOMPRESS dea1d7bbc37e39adf628342c86096641)\n    endif()\n\n    # CC: null  SAMP: fullsize  FDCT: islow  ENT: huff\n    add_bittest(${cjpeg} rgb-islow \"-rgb;-dct;int;-icc;${TESTIMAGES}/test1.icc\"\n      ${testout}_rgb_islow.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_RGB_ISLOW})\n\n    # CC: null  SAMP: fullsize  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} rgb-islow\n      \"-dct;int;-ppm;-icc;${testout}_rgb_islow.icc\"\n      ${testout}_rgb_islow.ppm ${testout}_rgb_islow.jpg\n      ${MD5_PPM_RGB_ISLOW} ${cjpeg}-${libtype}-rgb-islow)\n\n    add_test(NAME ${djpeg}-${libtype}-rgb-islow-icc-cmp\n      COMMAND md5cmp b06a39d730129122e85c1363ed1bbc9e ${testout}_rgb_islow.icc)\n    set_tests_properties(${djpeg}-${libtype}-rgb-islow-icc-cmp PROPERTIES\n      DEPENDS ${djpeg}-${libtype}-rgb-islow)\n\n    add_bittest(${jpegtran} icc \"-copy;all;-icc;${TESTIMAGES}/test3.icc\"\n      ${testout}_rgb_islow2.jpg ${testout}_rgb_islow.jpg\n      ${MD5_JPEG_RGB_ISLOW2} ${cjpeg}-${libtype}-rgb-islow)\n\n    if(sample_bits EQUAL 8)\n      # CC: RGB->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} rgb-islow-565 \"-dct;int;-rgb565;-dither;none;-bmp\"\n        ${testout}_rgb_islow_565.bmp ${testout}_rgb_islow.jpg\n        ${MD5_BMP_RGB_ISLOW_565} ${cjpeg}-${libtype}-rgb-islow)\n\n      # CC: RGB->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} rgb-islow-565D \"-dct;int;-rgb565;-bmp\"\n        ${testout}_rgb_islow_565D.bmp ${testout}_rgb_islow.jpg\n        ${MD5_BMP_RGB_ISLOW_565D} ${cjpeg}-${libtype}-rgb-islow)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize/h2v1  FDCT: ifast  ENT: 2-pass huff\n    add_bittest(${cjpeg} 422-ifast-opt \"-sample;2x1;-dct;fast;-opt\"\n      ${testout}_422_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_422_IFAST_OPT})\n\n    # CC: YCC->RGB  SAMP: fullsize/h2v1 fancy  IDCT: ifast  ENT: huff\n    add_bittest(${djpeg} 422-ifast \"-dct;fast\"\n      ${testout}_422_ifast.ppm ${testout}_422_ifast_opt.jpg\n      ${MD5_PPM_422_IFAST} ${cjpeg}-${libtype}-422-ifast-opt)\n\n    # CC: RGB->YCC  SAMP: fullsize/h1v2  FDCT: islow  ENT: huff\n    add_bittest(${cjpeg} 440-islow \"-sample;1x2;-dct;int\"\n      ${testout}_440_islow.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_440_ISLOW})\n\n    # CC: YCC->RGB  SAMP: fullsize/h1v2 fancy  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} 440-islow \"-dct;int\"\n      ${testout}_440_islow.ppm ${testout}_440_islow.jpg\n      ${MD5_PPM_440_ISLOW} ${cjpeg}-${libtype}-440-islow)\n\n    # CC: YCC->RGB  SAMP: h2v1 merged  IDCT: ifast  ENT: huff\n    add_bittest(${djpeg} 422m-ifast \"-dct;fast;-nosmooth\"\n      ${testout}_422m_ifast.ppm ${testout}_422_ifast_opt.jpg\n      ${MD5_PPM_422M_IFAST} ${cjpeg}-${libtype}-422-ifast-opt)\n\n    if(sample_bits EQUAL 8)\n      # CC: YCC->RGB565  SAMP: h2v1 merged  IDCT: ifast  ENT: huff\n      add_bittest(${djpeg} 422m-ifast-565\n        \"-dct;int;-nosmooth;-rgb565;-dither;none;-bmp\"\n        ${testout}_422m_ifast_565.bmp ${testout}_422_ifast_opt.jpg\n        ${MD5_BMP_422M_IFAST_565} ${cjpeg}-${libtype}-422-ifast-opt)\n\n      # CC: YCC->RGB565 (dithered)  SAMP: h2v1 merged  IDCT: ifast  ENT: huff\n      add_bittest(${djpeg} 422m-ifast-565D \"-dct;int;-nosmooth;-rgb565;-bmp\"\n        ${testout}_422m_ifast_565D.bmp ${testout}_422_ifast_opt.jpg\n        ${MD5_BMP_422M_IFAST_565D} ${cjpeg}-${libtype}-422-ifast-opt)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize/h2v2  FDCT: ifast  ENT: prog huff\n    add_bittest(${cjpeg} 420-q100-ifast-prog\n      \"-sample;2x2;-quality;100;-dct;fast;-scans;${TESTIMAGES}/test.scan\"\n      ${testout}_420_q100_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_420_IFAST_Q100_PROG})\n\n    # CC: YCC->RGB  SAMP: fullsize/h2v2 fancy  IDCT: ifast  ENT: prog huff\n    add_bittest(${djpeg} 420-q100-ifast-prog \"-dct;fast\"\n      ${testout}_420_q100_ifast.ppm ${testout}_420_q100_ifast_prog.jpg\n      ${MD5_PPM_420_Q100_IFAST} ${cjpeg}-${libtype}-420-q100-ifast-prog)\n\n    # CC: YCC->RGB  SAMP: h2v2 merged  IDCT: ifast  ENT: prog huff\n    add_bittest(${djpeg} 420m-q100-ifast-prog \"-dct;fast;-nosmooth\"\n      ${testout}_420m_q100_ifast.ppm ${testout}_420_q100_ifast_prog.jpg\n      ${MD5_PPM_420M_Q100_IFAST} ${cjpeg}-${libtype}-420-q100-ifast-prog)\n\n    # CC: RGB->Gray  SAMP: fullsize  FDCT: islow  ENT: huff\n    add_bittest(${cjpeg} gray-islow \"-gray;-dct;int\"\n      ${testout}_gray_islow.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_GRAY_ISLOW})\n\n    # CC: Gray->Gray  SAMP: fullsize  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} gray-islow \"-dct;int\"\n      ${testout}_gray_islow.ppm ${testout}_gray_islow.jpg\n      ${MD5_PPM_GRAY_ISLOW} ${cjpeg}-${libtype}-gray-islow)\n\n    # CC: Gray->RGB  SAMP: fullsize  IDCT: islow  ENT: huff\n    add_bittest(${djpeg} gray-islow-rgb \"-dct;int;-rgb\"\n      ${testout}_gray_islow_rgb.ppm ${testout}_gray_islow.jpg\n      ${MD5_PPM_GRAY_ISLOW_RGB} ${cjpeg}-${libtype}-gray-islow)\n\n    if(sample_bits EQUAL 8)\n      # CC: Gray->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} gray-islow-565 \"-dct;int;-rgb565;-dither;none;-bmp\"\n        ${testout}_gray_islow_565.bmp ${testout}_gray_islow.jpg\n        ${MD5_BMP_GRAY_ISLOW_565} ${cjpeg}-${libtype}-gray-islow)\n\n      # CC: Gray->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} gray-islow-565D \"-dct;int;-rgb565;-bmp\"\n        ${testout}_gray_islow_565D.bmp ${testout}_gray_islow.jpg\n        ${MD5_BMP_GRAY_ISLOW_565D} ${cjpeg}-${libtype}-gray-islow)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize smooth/h2v2 smooth  FDCT: islow\n    # ENT: 2-pass huff\n    add_bittest(${cjpeg} 420s-ifast-opt \"-sample;2x2;-smooth;1;-dct;int;-opt\"\n      ${testout}_420s_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_420S_IFAST_OPT})\n\n    if(FLOATTEST${sample_bits})\n      # CC: RGB->YCC  SAMP: fullsize/int  FDCT: float  ENT: prog huff\n      add_bittest(${cjpeg} 3x2-float-prog \"-sample;3x2;-dct;float;-prog\"\n        ${testout}_3x2_float_prog.jpg ${TESTIMAGES}/testorig.ppm\n        ${MD5_JPEG_3x2_FLOAT_PROG_${FLOATTEST${sample_bits}_UC}})\n\n      # CC: YCC->RGB  SAMP: fullsize/int  IDCT: float  ENT: prog huff\n      add_bittest(${djpeg} 3x2-float-prog \"-dct;float\"\n        ${testout}_3x2_float.ppm ${testout}_3x2_float_prog.jpg\n        ${MD5_PPM_3x2_FLOAT_${FLOATTEST${sample_bits}_UC}}\n        ${cjpeg}-${libtype}-3x2-float-prog)\n    endif()\n\n    # CC: RGB->YCC  SAMP: fullsize/int  FDCT: ifast  ENT: prog huff\n    add_bittest(${cjpeg} 3x2-ifast-prog \"-sample;3x2;-dct;fast;-prog\"\n      ${testout}_3x2_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_3x2_IFAST_PROG})\n\n    # CC: YCC->RGB  SAMP: fullsize/int  IDCT: ifast  ENT: prog huff\n    add_bittest(${djpeg} 3x2-ifast-prog \"-dct;fast\"\n      ${testout}_3x2_ifast.ppm ${testout}_3x2_ifast_prog.jpg\n      ${MD5_PPM_3x2_IFAST} ${cjpeg}-${libtype}-3x2-ifast-prog)\n\n    if(WITH_ARITH_ENC AND sample_bits EQUAL 8)\n      # CC: YCC->RGB  SAMP: fullsize/h2v2  FDCT: islow  ENT: arith\n      add_bittest(${cjpeg} 420-islow-ari \"-dct;int;-arithmetic\"\n        ${testout}_420_islow_ari.jpg ${TESTIMAGES}/testorig.ppm\n        ${MD5_JPEG_420_ISLOW_ARI})\n\n      add_bittest(${jpegtran} 420-islow-ari \"-arithmetic\"\n        ${testout}_420_islow_ari2.jpg ${TESTIMAGES}/testimgint.jpg\n        ${MD5_JPEG_420_ISLOW_ARI})\n\n      # CC: YCC->RGB  SAMP: fullsize  FDCT: islow  ENT: prog arith\n      add_bittest(${cjpeg} 444-islow-progari\n        \"-sample;1x1;-dct;int;-prog;-arithmetic\"\n        ${testout}_444_islow_progari.jpg ${TESTIMAGES}/testorig.ppm\n        ${MD5_JPEG_444_ISLOW_PROGARI})\n    endif()\n\n    if(WITH_ARITH_DEC AND sample_bits EQUAL 8)\n      # CC: RGB->YCC  SAMP: h2v2 merged  IDCT: ifast  ENT: arith\n      add_bittest(${djpeg} 420m-ifast-ari \"-fast;-skip;1,20;-ppm\"\n        ${testout}_420m_ifast_ari.ppm ${TESTIMAGES}/testimgari.jpg\n        ${MD5_PPM_420M_IFAST_ARI})\n\n      add_bittest(${jpegtran} 420-islow \"\"\n        ${testout}_420_islow.jpg ${TESTIMAGES}/testimgari.jpg\n        ${MD5_JPEG_420_ISLOW})\n    endif()\n\n    # 2/1--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 16x16 islow  ENT: huff\n    # 15/8--  CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 15x15 islow  ENT: huff\n    # 13/8--  CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 13x13 islow  ENT: huff\n    # 11/8--  CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 11x11 islow  ENT: huff\n    # 9/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 9x9 islow  ENT: huff\n    # 7/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 7x7 islow/14x14 islow\n    #         ENT: huff\n    # 3/4--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 6x6 islow/12x12 islow\n    #         ENT: huff\n    # 5/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 5x5 islow/10x10 islow\n    #         ENT: huff\n    # 1/2--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 4x4 islow/8x8 islow\n    #         ENT: huff\n    # 3/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 3x3 islow/6x6 islow\n    #         ENT: huff\n    # 1/4--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 2x2 islow/4x4 islow\n    #         ENT: huff\n    # 1/8--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 1x1 islow/2x2 islow\n    #         ENT: huff\n    foreach(scale 2_1 15_8 13_8 11_8 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8)\n      string(REGEX REPLACE \"_\" \"/\" scalearg ${scale})\n      add_bittest(${djpeg} 420m-islow-${scale}\n        \"-dct;int;-scale;${scalearg};-nosmooth;-ppm\"\n        ${testout}_420m_islow_${scale}.ppm ${TESTIMAGES}/${TESTORIG}\n        ${MD5_PPM_420M_ISLOW_${scale}})\n    endforeach()\n\n    if(sample_bits EQUAL 8)\n      # CC: YCC->RGB (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420-islow-256 \"-dct;int;-colors;256;-bmp\"\n        ${testout}_420_islow_256.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420_ISLOW_256})\n\n      # CC: YCC->RGB565  SAMP: h2v2 fancy  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420-islow-565 \"-dct;int;-rgb565;-dither;none;-bmp\"\n        ${testout}_420_islow_565.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420_ISLOW_565})\n\n      # CC: YCC->RGB565 (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420-islow-565D \"-dct;int;-rgb565;-bmp\"\n        ${testout}_420_islow_565D.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420_ISLOW_565D})\n\n      # CC: YCC->RGB565  SAMP: h2v2 merged  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420m-islow-565\n        \"-dct;int;-nosmooth;-rgb565;-dither;none;-bmp\"\n        ${testout}_420m_islow_565.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420M_ISLOW_565})\n\n      # CC: YCC->RGB565 (dithered)  SAMP: h2v2 merged  IDCT: islow  ENT: huff\n      add_bittest(${djpeg} 420m-islow-565D \"-dct;int;-nosmooth;-rgb565;-bmp\"\n        ${testout}_420m_islow_565D.bmp ${TESTIMAGES}/${TESTORIG}\n        ${MD5_BMP_420M_ISLOW_565D})\n    endif()\n\n    # Lossless (all arguments other than -lossless and -restart should have no\n    # effect)\n    add_bittest(${cjpeg} lossless\n      \"-lossless;4;-restart;1;-quality;1;-grayscale;-optimize;-dct;float;-smooth;100;-baseline;-qslots;1,0,0;-sample;1x2,3x4,2x1\"\n      ${testout}_lossless.jpg ${TESTIMAGES}/testorig.ppm\n      ${MD5_JPEG_LOSSLESS})\n    add_bittest(${djpeg} lossless\n      \"-fast;-scale;1/8;-dct;float;-dither;none;-nosmooth;-onepass\"\n      ${testout}_lossless.ppm ${testout}_lossless.jpg\n      ${MD5_PPM_LOSSLESS} ${cjpeg}-${libtype}-lossless)\n\n    # Partial decode tests.  These tests are designed to cover all of the\n    # possible code paths in jpeg_skip_scanlines().\n\n    # Context rows: Yes  Intra-iMCU row: Yes  iMCU row prefetch: No\n    # ENT: huff\n    add_bittest(${djpeg} 420-islow-skip15_31 \"-dct;int;-skip;15,31;-ppm\"\n      ${testout}_420_islow_skip15,31.ppm ${TESTIMAGES}/${TESTORIG}\n      ${MD5_PPM_420_ISLOW_SKIP15_31})\n\n    # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: Yes\n    # ENT: arith\n    if(WITH_ARITH_DEC AND sample_bits EQUAL 8)\n      add_bittest(${djpeg} 420-islow-ari-skip16_139\n        \"-dct;int;-skip;16,139;-ppm\"\n        ${testout}_420_islow_ari_skip16,139.ppm ${TESTIMAGES}/testimgari.jpg\n        ${MD5_PPM_420_ISLOW_ARI_SKIP16_139})\n    endif()\n\n    # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No\n    # ENT: prog huff\n    add_test(NAME ${cjpeg}-${libtype}-420-islow-prog\n      COMMAND cjpeg${suffix} -dct int -prog -precision ${sample_bits}\n        -outfile ${testout}_420_islow_prog.jpg ${TESTIMAGES}/testorig.ppm)\n    add_bittest(${djpeg} 420-islow-prog-crop62x62_71_71\n      \"-dct;int;-crop;62x62+71+71;-ppm\"\n      ${testout}_420_islow_prog_crop62x62,71,71.ppm\n      ${testout}_420_islow_prog.jpg ${MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71}\n      ${cjpeg}-${libtype}-420-islow-prog)\n\n    # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No\n    # ENT: arith\n    if(WITH_ARITH_DEC AND sample_bits EQUAL 8)\n      add_bittest(${djpeg} 420-islow-ari-crop53x53_4_4\n        \"-dct;int;-crop;53x53+4+4;-ppm\"\n        ${testout}_420_islow_ari_crop53x53,4,4.ppm ${TESTIMAGES}/testimgari.jpg\n        ${MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4})\n    endif()\n\n    # Context rows: No   Intra-iMCU row: Yes  ENT: huff\n    add_test(NAME ${cjpeg}-${libtype}-444-islow\n      COMMAND cjpeg${suffix} -dct int -sample 1x1 -precision ${sample_bits}\n        -outfile ${testout}_444_islow.jpg ${TESTIMAGES}/testorig.ppm)\n    add_bittest(${djpeg} 444-islow-skip1_6 \"-dct;int;-skip;1,6;-ppm\"\n      ${testout}_444_islow_skip1,6.ppm ${testout}_444_islow.jpg\n      ${MD5_PPM_444_ISLOW_SKIP1_6} ${cjpeg}-${libtype}-444-islow)\n\n    # Context rows: No   Intra-iMCU row: No   ENT: prog huff\n    add_test(NAME ${cjpeg}-${libtype}-444-islow-prog\n      COMMAND cjpeg${suffix} -dct int -prog -precision ${sample_bits}\n        -sample 1x1 -outfile ${testout}_444_islow_prog.jpg\n        ${TESTIMAGES}/testorig.ppm)\n    add_bittest(${djpeg} 444-islow-prog-crop98x98_13_13\n      \"-dct;int;-crop;98x98+13+13;-ppm\"\n      ${testout}_444_islow_prog_crop98x98,13,13.ppm\n      ${testout}_444_islow_prog.jpg ${MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13}\n      ${cjpeg}-${libtype}-444-islow-prog)\n\n    # Context rows: No   Intra-iMCU row: No   ENT: arith\n    if(WITH_ARITH_ENC AND sample_bits EQUAL 8)\n      add_test(NAME ${cjpeg}-${libtype}-444-islow-ari\n        COMMAND cjpeg${suffix} -dct int -arithmetic -sample 1x1\n          -precision ${sample_bits} -outfile ${testout}_444_islow_ari.jpg\n          ${TESTIMAGES}/testorig.ppm)\n      if(WITH_ARITH_DEC)\n        add_bittest(${djpeg} 444-islow-ari-crop37x37_0_0\n          \"-dct;int;-crop;37x37+0+0;-ppm\"\n          ${testout}_444_islow_ari_crop37x37,0,0.ppm\n          ${testout}_444_islow_ari.jpg ${MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0}\n          ${cjpeg}-${libtype}-444-islow-ari)\n      endif()\n    endif()\n\n    add_bittest(${jpegtran} crop \"-crop;120x90+20+50;-transpose;-perfect\"\n      ${testout}_crop.jpg ${TESTIMAGES}/${TESTORIG}\n      ${MD5_JPEG_CROP})\n\n    unset(EXAMPLE_12BIT_ARG)\n    if(sample_bits EQUAL 12)\n      set(EXAMPLE_12BIT_ARG \"-precision;12\")\n    endif()\n\n    add_test(NAME example-${sample_bits}bit-${libtype}-compress\n      COMMAND example${suffix} compress -q 95 ${EXAMPLE_12BIT_ARG}\n        ${testout}-example.jpg)\n    add_test(NAME example-${sample_bits}bit-${libtype}-compress-cmp\n      COMMAND md5cmp ${MD5_JPEG_EXAMPLE_COMPRESS} ${testout}-example.jpg)\n    set_tests_properties(example-${sample_bits}bit-${libtype}-compress-cmp\n      PROPERTIES DEPENDS example-${sample_bits}bit-${libtype}-compress)\n\n    add_test(NAME example-${sample_bits}bit-${libtype}-decompress\n      COMMAND example${suffix} decompress ${EXAMPLE_12BIT_ARG}\n        ${TESTIMAGES}/${TESTORIG} ${testout}-example.ppm)\n    add_test(NAME example-${sample_bits}bit-${libtype}-decompress-cmp\n      COMMAND md5cmp ${MD5_PPM_EXAMPLE_DECOMPRESS} ${testout}-example.ppm)\n    set_tests_properties(example-${sample_bits}bit-${libtype}-decompress-cmp\n      PROPERTIES DEPENDS example-${sample_bits}bit-${libtype}-decompress)\n\n  endforeach()\n\nendforeach()\n\nadd_custom_target(testclean COMMAND ${CMAKE_COMMAND} -P\n  ${CMAKE_CURRENT_SOURCE_DIR}/cmakescripts/testclean.cmake)\n\nconfigure_file(test/croptest.in test/croptest @ONLY)\nadd_custom_target(croptest\n  COMMAND echo croptest\n  COMMAND ${BASH} ${CMAKE_CURRENT_BINARY_DIR}/test/croptest)\n\nif(WITH_TURBOJPEG)\n  configure_file(test/tjbenchtest.in test/tjbenchtest @ONLY)\n  configure_file(test/tjcomptest.in test/tjcomptest @ONLY)\n  configure_file(test/tjdecomptest.in test/tjdecomptest @ONLY)\n  configure_file(test/tjtrantest.in test/tjtrantest @ONLY)\n  if(WIN32)\n    set(BASH bash)\n  endif()\n  add_custom_target(tjtest COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=8 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/test/tjbenchtest)\n  add_custom_target(tjtest12 COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=12 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/test/tjbenchtest)\n  add_custom_target(tjtest16 COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=2 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=3 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=4 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=5 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=6 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=7 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=9 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=10 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=11 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=13 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=14 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=15 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    COMMAND ${CMAKE_COMMAND} -DWITH_JAVA=${WITH_JAVA}\n    -DPRECISION=16 -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjbenchtest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/test/tjbenchtest)\n  add_custom_target(tjexampletest COMMAND ${CMAKE_COMMAND}\n    -DWITH_JAVA=${WITH_JAVA}\n    -P ${CMAKE_SOURCE_DIR}/cmakescripts/tjexampletest.cmake\n    DEPENDS ${CMAKE_SOURCE_DIR}/cmakescripts/tjexampletest.cmake\n      ${CMAKE_CURRENT_BINARY_DIR}/test/tjcomptest\n      ${CMAKE_CURRENT_BINARY_DIR}/test/tjdecomptest\n      ${CMAKE_CURRENT_BINARY_DIR}/test/tjtrantest)\nendif()\n\n\n###############################################################################\n# INSTALLATION\n###############################################################################\n\nset(EXE ${CMAKE_EXECUTABLE_SUFFIX})\n\nif(WITH_TURBOJPEG)\n  if(ENABLE_SHARED)\n    install(TARGETS turbojpeg EXPORT ${CMAKE_PROJECT_NAME}Targets\n      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib\n      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib\n      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin)\n    install(TARGETS tjbench\n      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin)\n    if(NOT CMAKE_VERSION VERSION_LESS \"3.1\" AND MSVC_LIKE AND\n      CMAKE_C_LINKER_SUPPORTS_PDB)\n      install(FILES \"$<TARGET_PDB_FILE:turbojpeg>\"\n        DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin OPTIONAL)\n    endif()\n  endif()\n  if(ENABLE_STATIC)\n    install(TARGETS turbojpeg-static EXPORT ${CMAKE_PROJECT_NAME}Targets\n      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib)\n    if(NOT ENABLE_SHARED)\n      if(GENERATOR_IS_MULTI_CONFIG)\n        set(DIR \"${CMAKE_CURRENT_BINARY_DIR}/\\${CMAKE_INSTALL_CONFIG_NAME}\")\n      else()\n        set(DIR ${CMAKE_CURRENT_BINARY_DIR})\n      endif()\n      install(PROGRAMS ${DIR}/tjbench-static${EXE}\n        DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME tjbench${EXE})\n    endif()\n  endif()\n  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/src/turbojpeg.h\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT include)\nendif()\n\nif(ENABLE_STATIC)\n  install(TARGETS jpeg-static EXPORT ${CMAKE_PROJECT_NAME}Targets\n    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT lib)\n  if(NOT ENABLE_SHARED)\n    if(GENERATOR_IS_MULTI_CONFIG)\n      set(DIR \"${CMAKE_CURRENT_BINARY_DIR}/\\${CMAKE_INSTALL_CONFIG_NAME}\")\n    else()\n      set(DIR ${CMAKE_CURRENT_BINARY_DIR})\n    endif()\n    install(PROGRAMS ${DIR}/cjpeg-static${EXE}\n      DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME cjpeg${EXE})\n    install(PROGRAMS ${DIR}/djpeg-static${EXE}\n      DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME djpeg${EXE})\n    install(PROGRAMS ${DIR}/jpegtran-static${EXE}\n      DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin RENAME jpegtran${EXE})\n  endif()\nendif()\n\ninstall(TARGETS rdjpgcom wrjpgcom\n  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT bin)\n\ninstall(FILES ${CMAKE_CURRENT_SOURCE_DIR}/README.ijg\n  ${CMAKE_CURRENT_SOURCE_DIR}/README.md\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/example.c\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/tjcomp.c\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/tjdecomp.c\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/tjtran.c\n  ${CMAKE_CURRENT_SOURCE_DIR}/doc/libjpeg.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/doc/structure.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/doc/usage.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/doc/wizard.txt\n  ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.md DESTINATION ${CMAKE_INSTALL_DOCDIR}\n  COMPONENT doc)\nif(WITH_JAVA)\n  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/java/TJComp.java\n    ${CMAKE_CURRENT_SOURCE_DIR}/java/TJDecomp.java\n    ${CMAKE_CURRENT_SOURCE_DIR}/java/TJTran.java\n    DESTINATION ${CMAKE_INSTALL_DOCDIR} COMPONENT doc)\nendif()\n\nif(UNIX OR MINGW)\n  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/doc/cjpeg.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/doc/djpeg.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/doc/jpegtran.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/doc/rdjpgcom.1\n    ${CMAKE_CURRENT_SOURCE_DIR}/doc/wrjpgcom.1\n    DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT man)\nendif()\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/libjpeg.pc\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig COMPONENT lib)\nif(WITH_TURBOJPEG)\n  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/libturbojpeg.pc\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig COMPONENT lib)\nendif()\ninstall(FILES\n  ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/${CMAKE_PROJECT_NAME}Config.cmake\n  ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/${CMAKE_PROJECT_NAME}ConfigVersion.cmake\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${CMAKE_PROJECT_NAME}\n  COMPONENT lib)\ninstall(EXPORT ${CMAKE_PROJECT_NAME}Targets\n  NAMESPACE ${CMAKE_PROJECT_NAME}::\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${CMAKE_PROJECT_NAME}\n  COMPONENT lib)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/jconfig.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/jerror.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/jmorecfg.h\n  ${CMAKE_CURRENT_SOURCE_DIR}/src/jpeglib.h\n  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT include)\n\ninclude(cmakescripts/BuildPackages.cmake)\n\nconfigure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/cmakescripts/cmake_uninstall.cmake.in\"\n  \"cmake_uninstall.cmake\" IMMEDIATE @ONLY)\n\nadd_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P cmake_uninstall.cmake)\n"
        },
        {
          "name": "ChangeLog.md",
          "type": "blob",
          "size": 117.53515625,
          "content": "3.1.1\n=====\n\n### Significant changes relative to 3.1.0:\n\n1. Hardened the libjpeg API against hypothetical calling applications that may\nerroneously change the value of the `data_precision` field in\n`jpeg_compress_struct` or `jpeg_decompress_struct` after calling\n`jpeg_start_compress()` or `jpeg_start_decompress()`.\n\n\n3.1.0\n=====\n\n### Significant changes relative to 3.1 beta1:\n\n1. Fixed an issue in the TurboJPEG API whereby, when generating a\nlossless JPEG image with more than 8 bits per sample, specifying a point\ntransform value greater than 7 resulted in an error (\"Parameter value out of\nrange\") unless `TJPARAM_PRECISION`/`TJ.PARAM_PRECISION` was specified before\n`TJPARAM_LOSSLESSPT`/`TJ.PARAM_LOSSLESSPT`.\n\n2. Fixed a regression introduced by 1.4 beta1[3] that prevented\n`jpeg_set_defaults()` from resetting the Huffman tables to default (baseline)\nvalues if Huffman table optimization or progressive mode was previously enabled\nin the same libjpeg instance.\n\n3. Fixed an issue whereby lossless JPEG compression could not be disabled if it\nwas previously enabled in a libjpeg or TurboJPEG instance.\n`jpeg_set_defaults()` now disables lossless JPEG compression in a libjpeg\ninstance, and setting `TJPARAM_LOSSLESS`/`TJ.PARAM_LOSSLESS` to `0` now\ndisables lossless JPEG compression in a TurboJPEG instance.\n\n\n3.1 beta1\n=========\n\n### Significant changes relative to 3.0.4:\n\n1. The libjpeg-turbo source tree has been reorganized to make it easier to find\nthe README files, license information, and build instructions.  The\ndocumentation for the libjpeg API library and associated programs has been\nmoved into the **doc/** subdirectory, all C source code and headers have been\nmoved into a new **src/** subdirectory, and test scripts have been moved into a\nnew **test/** subdirectory.\n\n2. cjpeg no longer allows GIF input files to be converted into\n12-bit-per-sample JPEG files.  That was never a useful feature, since GIF\nimages have at most 256 colors referenced from a palette of 8-bit-per-component\nRGB values.\n\n3. Added support for lossless JPEG images with 2 to 15 bits per sample to the\nlibjpeg and TurboJPEG APIs.  When creating or decompressing a lossless JPEG\nimage and when loading or saving a PBMPLUS image, functions/methods specific to\n8-bit samples now handle 8-bit samples with 2 to 8 bits of data precision\n(specified using the `data_precision` field in `jpeg_compress_struct` or\n`jpeg_decompress_struct` or using `TJPARAM_PRECISION`/`TJ.PARAM_PRECISION`),\nfunctions/methods specific to 12-bit samples now handle 12-bit samples with 9\nto 12 bits of data precision, and functions/methods specific to 16-bit samples\nnow handle 16-bit samples with 13 to 16 bits of data precision.  Refer to\n[libjpeg.txt](doc/libjpeg.txt), [usage.txt](doc/usage.txt), and the TurboJPEG\nAPI documentation for more details.\n\n4. All deprecated constants and methods in the TurboJPEG Java API have been\nremoved.\n\n5. TJBench command-line arguments are now more consistent with those of cjpeg,\ndjpeg, and jpegtran.  More specifically:\n\n     - `-copynone` has been replaced with `-copy none`.\n     - `-fastdct` has been replaced with `-dct fast`.\n     - `-fastupsample` has been replaced with `-nosmooth`.\n     - `-hflip` and `-vflip` have been replaced with\n`-flip {horizontal|vertical}`.\n     - `-limitscans` has been replaced with `-maxscans`, which allows the scan\nlimit to be specified.\n     - `-rgb`, `-bgr`, `-rgbx`, `-bgrx`, `-xbgr`, `-xrgb`, and `-cmyk` have\nbeen replaced with `-pixelformat {rgb|bgr|rgbx|bgrx|xbgr|xrgb|cmyk}`.\n     - `-rot90`, `-rot180`, and `-rot270` have been replaced with\n`-rotate {90|180|270}`.\n     - `-stoponwarning` has been replaced with `-strict`.\n     - British spellings for `gray` (`grey`) and `optimize` (`optimise`) are\nnow allowed.\n\n    The old command-line arguments are deprecated and will be removed in a\nfuture release.  TJBench command-line arguments can now be abbreviated as well.\n(Where possible, the abbreviations are the same as those supported by cjpeg,\ndjpeg, and jpegtran.)\n\n6. Added a new TJBench option (`-pixelformat gray`) that can be used to test\nthe performance of compressing/decompressing a grayscale JPEG image from/to a\npacked-pixel grayscale image.\n\n7. Fixed an issue whereby, if `TJPARAM_NOREALLOC` was set, TurboJPEG\ncompression and lossless transformation functions ignored the JPEG buffer\nsize(s) passed to them and assumed that the JPEG buffer(s) had been allocated\nto a worst-case size returned by `tj3JPEGBufSize()`.  This behavior was never\ndocumented, although the documentation was unclear regarding whether the JPEG\nbuffer size should be specified if a JPEG buffer is pre-allocated to a\nworst-case size.\n\n8. The TurboJPEG C and Java APIs have been improved in the following ways:\n\n     - New image I/O methods (`TJCompressor.loadSourceImage()` and\n`TJDecompressor.saveImage()`) have been added to the Java API.  These methods\nwork similarly to the `tj3LoadImage*()` and `tj3SaveImage*()` functions in the\nC API.\n     - The TurboJPEG lossless transformation function and methods now add\nrestart markers to all destination images if\n`TJPARAM_RESTARTBLOCKS`/`TJ.PARAM_RESTARTBLOCKS` or\n`TJPARAM_RESTARTROWS`/`TJ.PARAM_RESTARTROWS` is set.\n     - New functions/methods (`tj3SetICCProfile()` /\n`TJCompressor.setICCProfile()` / `TJTransformer.setICCProfile()` and\n`tj3GetICCProfile()` / `TJDecompressor.getICCProfile()`) can be used to embed\nand retrieve ICC profiles.\n     - A new parameter (`TJPARAM_SAVEMARKERS`/`TJ.PARAM_SAVEMARKERS`) can be\nused to specify the types of markers that will be copied from the source image\nto the destination image during lossless transformation if\n`TJXOPT_COPYNONE`/`TJTransform.OPT_COPYNONE` is not specified.\n     - A new convenience function/method (`tj3TransformBufSize()` /\n`TJTransformer.bufSize()`) can be used to compute the worst-case destination\nbuffer size for a given lossless transform, taking into account cropping,\ntransposition of the width and height, grayscale conversion, and the embedded\nor extracted ICC profile.\n\n9. TJExample has been replaced with three programs (TJComp, TJDecomp, and\nTJTran) that demonstrate how to approximate the functionality of cjpeg, djpeg,\nand jpegtran using the TurboJPEG C and Java APIs.\n\n\n3.0.4\n=====\n\n### Significant changes relative to 3.0.3:\n\n1. Fixed an issue whereby the CPU usage of the default marker processor in the\ndecompressor grew exponentially with the number of markers.  This caused an\nunreasonable slow-down in `jpeg_read_header()` if an application called\n`jpeg_save_markers()` to save markers of a particular type and then attempted\nto decompress a JPEG image containing an excessive number of markers of that\ntype.\n\n2. Hardened the default marker processor in the decompressor to guard against\nan issue (exposed by 3.0 beta2[6]) whereby attempting to decompress a\nspecially-crafted malformed JPEG image (specifically an image with a complete\n12-bit-per-sample Start Of Frame segment followed by an incomplete\n8-bit-per-sample Start Of Frame segment) using buffered-image mode and input\nprefetching caused a segfault if the `fill_input_buffer()` method in the\ncalling application's custom source manager incorrectly returned `FALSE` in\nresponse to a prematurely-terminated JPEG data stream.\n\n3. Fixed an issue in cjpeg whereby, when generating a 12-bit-per-sample or\n16-bit-per-sample lossless JPEG image, specifying a point transform value\ngreater than 7 resulted in an error (\"Invalid progressive/lossless parameters\")\nunless the `-precision` option was specified before the `-lossless` option.\n\n4. Fixed a regression introduced by 3.0.3[3] that made it impossible for\ncalling applications to generate 12-bit-per-sample arithmetic-coded lossy JPEG\nimages using the TurboJPEG API.\n\n5. Fixed an error (\"Destination buffer is not large enough\") that occurred when\nattempting to generate a full-color lossless JPEG image using the TurboJPEG\nJava API's `byte[] TJCompressor.compress()` method if the value of\n`TJ.PARAM_SUBSAMP` was not `TJ.SAMP_444`.\n\n6. Fixed a segfault in djpeg that occurred if a negative width was specified\nwith the `-crop` option.  Since the cropping region width was read into an\nunsigned 32-bit integer, a negative width was interpreted as a very large\nvalue.  With certain negative width and positive left boundary values, the\nbounds checks in djpeg and `jpeg_crop_scanline()` overflowed and did not detect\nthe out-of-bounds width, which caused a buffer overrun in the upsampling or\ncolor conversion routine.  Both bounds checks now use 64-bit integers to guard\nagainst overflow, and djpeg now checks for negative numbers when it parses the\ncrop specification from the command line.\n\n7. Fixed an issue whereby the TurboJPEG lossless transformation function and\nmethods checked the specified cropping region against the source image\ndimensions and level of chrominance subsampling rather than the destination\nimage dimensions and level of chrominance subsampling, which caused some\ncropping regions to be unduly rejected when performing 90-degree rotation,\n270-degree rotation, transposition, transverse transposition, or grayscale\nconversion.\n\n8. Fixed a regression, introduced by 3.0 beta2[4], that prevented the\n`tjTransform()` backward compatibility function from copying extra markers from\nthe source image to the destination image.\n\n9. Fixed an issue whereby the TurboJPEG lossless transformation function and\nmethods did not honor `TJXOPT_COPYNONE`/`TJTransform.OPT_COPYNONE` unless it\nwas specified for all lossless transforms.\n\n\n3.0.3\n=====\n\n### Significant changes relative to 3.0.2:\n\n1. Fixed an issue in the build system, introduced in 3.0.2, that caused all\nlibjpeg-turbo components to depend on the Visual C++ run-time DLL when built\nwith Visual C++ and CMake 3.15 or later, regardless of value of the\n`WITH_CRT_DLL` CMake variable.\n\n2. The x86-64 SIMD extensions now include support for Intel Control-flow\nEnforcement Technology (CET), which is enabled automatically if CET is enabled\nin the C compiler.\n\n3. Fixed a regression introduced by 3.0 beta2[6] that made it impossible for\ncalling applications to supply custom Huffman tables when generating\n12-bit-per-component lossy JPEG images using the libjpeg API.\n\n4. Fixed a segfault that occurred when attempting to use the jpegtran `-drop`\noption with a specially-crafted malformed input image or drop image\n(specifically an image in which all of the scans contain fewer components than\nthe number of components specified in the Start Of Frame segment.)\n\n\n3.0.2\n=====\n\n### Significant changes relative to 3.0.1:\n\n1. Fixed a signed integer overflow in the `tj3CompressFromYUV8()`,\n`tj3DecodeYUV8()`, `tj3DecompressToYUV8()`, and `tj3EncodeYUV8()` functions,\ndetected by the Clang and GCC undefined behavior sanitizers, that could be\ntriggered by setting the `align` parameter to an unreasonably large value.\nThis issue did not pose a security threat, but removing the warning made it\neasier to detect actual security issues, should they arise in the future.\n\n2. Introduced a new parameter (`TJPARAM_MAXMEMORY` in the TurboJPEG C API and\n`TJ.PARAM_MAXMEMORY` in the TurboJPEG Java API) and a corresponding TJBench\noption (`-maxmemory`) for specifying the maximum amount of memory (in\nmegabytes) that will be allocated for intermediate buffers, which are used with\nprogressive JPEG compression and decompression, Huffman table optimization,\nlossless JPEG compression, and lossless transformation.  The new parameter and\noption serve the same purpose as the `max_memory_to_use` field in the\n`jpeg_memory_mgr` struct in the libjpeg API, the `JPEGMEM` environment\nvariable, and the cjpeg/djpeg/jpegtran `-maxmemory` option.\n\n3. Introduced a new parameter (`TJPARAM_MAXPIXELS` in the TurboJPEG C API and\n`TJ.PARAM_MAXPIXELS` in the TurboJPEG Java API) and a corresponding TJBench\noption (`-maxpixels`) for specifying the maximum number of pixels that the\ndecompression, lossless transformation, and packed-pixel image loading\nfunctions/methods will process.\n\n4. Fixed an error (\"Unsupported color conversion request\") that occurred when\nattempting to decompress a 3-component lossless JPEG image without an Adobe\nAPP14 marker.  The decompressor now assumes that a 3-component lossless JPEG\nimage without an Adobe APP14 marker uses the RGB colorspace if its component\nIDs are 1, 2, and 3.\n\n\n3.0.1\n=====\n\n### Significant changes relative to 3.0.0:\n\n1. The x86-64 SIMD functions now use a standard stack frame, prologue, and\nepilogue so that debuggers and profilers can reliably capture backtraces from\nwithin the functions.\n\n2. Fixed two minor issues in the interblock smoothing algorithm that caused\nmathematical (but not necessarily perceptible) edge block errors when\ndecompressing progressive JPEG images exactly two DCT blocks in width or that\nuse vertical chrominance subsampling.\n\n3. Fixed a regression introduced by 3.0 beta2[6] that, in rare cases, caused\nthe C Huffman encoder (which is not used by default on x86 and Arm CPUs) to\ngenerate incorrect results if the Neon SIMD extensions were explicitly disabled\nat build time (by setting the `WITH_SIMD` CMake variable to `0`) in an AArch64\nbuild of libjpeg-turbo.\n\n\n3.0.0\n=====\n\n### Significant changes relative to 3.0 beta2:\n\n1. The TurboJPEG API now supports 4:4:1 (transposed 4:1:1) chrominance\nsubsampling, which allows losslessly transposed or rotated 4:1:1 JPEG images to\nbe losslessly cropped, partially decompressed, or decompressed to planar YUV\nimages.\n\n2. Fixed various segfaults and buffer overruns (CVE-2023-2804) that occurred\nwhen attempting to decompress various specially-crafted malformed\n12-bit-per-component and 16-bit-per-component lossless JPEG images using color\nquantization or merged chroma upsampling/color conversion.  The underlying\ncause of these issues was that the color quantization and merged chroma\nupsampling/color conversion algorithms were not designed with lossless\ndecompression in mind.  Since libjpeg-turbo explicitly does not support color\nconversion when compressing or decompressing lossless JPEG images, merged\nchroma upsampling/color conversion never should have been enabled for such\nimages.  Color quantization is a legacy feature that serves little or no\npurpose with lossless JPEG images, so it is also now disabled when\ndecompressing such images.  (As a result, djpeg can no longer decompress a\nlossless JPEG image into a GIF image.)\n\n3. Fixed an oversight in 1.4 beta1[8] that caused various segfaults and buffer\noverruns when attempting to decompress various specially-crafted malformed\n12-bit-per-component JPEG images using djpeg with both color quantization and\nRGB565 color conversion enabled.\n\n4. Fixed an issue whereby `jpeg_crop_scanline()` sometimes miscalculated the\ndownsampled width for components with 4x2 or 2x4 subsampling factors if\ndecompression scaling was enabled.  This caused the components to be upsampled\nincompletely, which caused the color converter to read from uninitialized\nmemory.  With 12-bit data precision, this caused a buffer overrun or underrun\nand subsequent segfault if the sample value read from uninitialized memory was\noutside of the valid sample range.\n\n5. Fixed a long-standing issue whereby the `tj3Transform()` function, when used\nwith the `TJXOP_TRANSPOSE`, `TJXOP_TRANSVERSE`, `TJXOP_ROT90`, or\n`TJXOP_ROT270` transform operation and without automatic JPEG destination\nbuffer (re)allocation or lossless cropping, computed the worst-case transformed\nJPEG image size based on the source image dimensions rather than the\ntransformed image dimensions.  If a calling program allocated the JPEG\ndestination buffer based on the transformed image dimensions, as the API\ndocumentation instructs, and attempted to transform a specially-crafted 4:2:2,\n4:4:0, 4:1:1, or 4:4:1 JPEG source image containing a large amount of metadata,\nthe issue caused `tj3Transform()` to overflow the JPEG destination buffer\nrather than fail gracefully.  The issue could be worked around by setting\n`TJXOPT_COPYNONE`.  Note that, irrespective of this issue, `tj3Transform()`\ncannot reliably transform JPEG source images that contain a large amount of\nmetadata unless automatic JPEG destination buffer (re)allocation is used or\n`TJXOPT_COPYNONE` is set.\n\n6. Fixed a regression introduced by 3.0 beta2[6] that prevented the djpeg\n`-map` option from working when decompressing 12-bit-per-component lossy JPEG\nimages.\n\n7. Fixed an issue that caused the C Huffman encoder (which is not used by\ndefault on x86 and Arm CPUs) to read from uninitialized memory when attempting\nto transform a specially-crafted malformed arithmetic-coded JPEG source image\ninto a baseline Huffman-coded JPEG destination image.\n\n\n2.1.91 (3.0 beta2)\n==================\n\n### Significant changes relative to 2.1.5.1:\n\n1. Significantly sped up the computation of optimal Huffman tables.  This\nspeeds up the compression of tiny images by as much as 2x and provides a\nnoticeable speedup for images as large as 256x256 when using optimal Huffman\ntables.\n\n2. All deprecated fields, constructors, and methods in the TurboJPEG Java API\nhave been removed.\n\n3. Arithmetic entropy coding is now supported with 12-bit-per-component JPEG\nimages.\n\n4. Overhauled the TurboJPEG API to address long-standing limitations and to\nmake the API more extensible and intuitive:\n\n     - All C function names are now prefixed with `tj3`, and all version\nsuffixes have been removed from the function names.  Future API overhauls will\nincrement the prefix to `tj4`, etc., thus retaining backward API/ABI\ncompatibility without versioning each individual function.\n     - Stateless boolean flags have been replaced with stateful integer API\nparameters, the values of which persist between function calls.  New\nfunctions/methods (`tj3Set()`/`TJCompressor.set()`/`TJDecompressor.set()` and\n`tj3Get()`/`TJCompressor.get()`/`TJDecompressor.get()`) can be used to set and\nquery the value of a particular API parameter.\n     - The JPEG quality and subsampling are now implemented using API\nparameters rather than stateless function arguments (C) or dedicated set/get\nmethods (Java.)\n     - `tj3DecompressHeader()` now stores all relevant information about the\nJPEG image, including the width, height, subsampling type, entropy coding\nalgorithm, etc., in API parameters rather than returning that information\nthrough pointer arguments.\n     - `TJFLAG_LIMITSCANS`/`TJ.FLAG_LIMITSCANS` has been reimplemented as an\nAPI parameter (`TJPARAM_SCANLIMIT`/`TJ.PARAM_SCANLIMIT`) that allows the number\nof scans to be specified.\n     - Huffman table optimization can now be specified using a new API\nparameter (`TJPARAM_OPTIMIZE`/`TJ.PARAM_OPTIMIZE`), a new transform option\n(`TJXOPT_OPTIMIZE`/`TJTransform.OPT_OPTIMIZE`), and a new TJBench option\n(`-optimize`.)\n     - Arithmetic entropy coding can now be specified or queried, using a new\nAPI parameter (`TJPARAM_ARITHMETIC`/`TJ.PARAM_ARITHMETIC`), a new transform\noption (`TJXOPT_ARITHMETIC`/`TJTransform.OPT_ARITHMETIC`), and a new TJBench\noption (`-arithmetic`.)\n     - The restart marker interval can now be specified, using new API\nparameters (`TJPARAM_RESTARTROWS`/`TJ.PARAM_RESTARTROWS` and\n`TJPARAM_RESTARTBLOCKS`/`TJ.PARAM_RESTARTBLOCKS`) and a new TJBench option\n(`-restart`.)\n     - Pixel density can now be specified or queried, using new API parameters\n(`TJPARAM_XDENSITY`/`TJ.PARAM_XDENSITY`,\n`TJPARAM_YDENSITY`/`TJ.PARAM_YDENSITY`, and\n`TJPARAM_DENSITYUNITS`/`TJ.PARAM_DENSITYUNITS`.)\n     - The accurate DCT/IDCT algorithms are now the default for both\ncompression and decompression, since the \"fast\" algorithms are considered to be\na legacy feature.  (The \"fast\" algorithms do not pass the ISO compliance tests,\nand those algorithms are not any faster than the accurate algorithms on modern\nx86 CPUs.)\n     - All C initialization functions have been combined into a single function\n(`tj3Init()`) that accepts an integer argument specifying the subsystems to\ninitialize.\n     - All C functions now use the `const` keyword for pointer arguments that\npoint to unmodified buffers (and for both dimensions of pointer arguments that\npoint to sets of unmodified buffers.)\n     - All C functions now use `size_t` rather than `unsigned long` to\nrepresent buffer sizes, for compatibility with `malloc()` and to avoid\ndisparities in the size of `unsigned long` between LP64 (Un*x) and LLP64\n(Windows) operating systems.\n     - All C buffer size functions now return 0 if an error occurs, rather than\ntrying to awkwardly return -1 in an unsigned data type (which could easily be\nmisinterpreted as a very large value.)\n     - Decompression scaling is now enabled explicitly, using a new\nfunction/method (`tj3SetScalingFactor()`/`TJDecompressor.setScalingFactor()`),\nrather than implicitly using awkward \"desired width\"/\"desired height\"\narguments.\n     - Partial image decompression has been implemented, using a new\nfunction/method (`tj3SetCroppingRegion()`/`TJDecompressor.setCroppingRegion()`)\nand a new TJBench option (`-crop`.)\n     - The JPEG colorspace can now be specified explicitly when compressing,\nusing a new API parameter (`TJPARAM_COLORSPACE`/`TJ.PARAM_COLORSPACE`.)  This\nallows JPEG images with the RGB and CMYK colorspaces to be created.\n     - TJBench no longer generates error/difference images, since identical\nfunctionality is already available in ImageMagick.\n     - JPEG images with unknown subsampling configurations can now be\nfully decompressed into packed-pixel images or losslessly transformed (with the\nexception of lossless cropping.)  They cannot currently be partially\ndecompressed or decompressed into planar YUV images.\n     - `tj3Destroy()` now silently accepts a NULL handle.\n     - `tj3Alloc()` and `tj3Free()` now return/accept void pointers, as\n`malloc()` and `free()` do.\n     - The C image I/O functions now accept a TurboJPEG instance handle, which\nis used to transmit/receive API parameter values and to receive error\ninformation.\n\n5. Added support for 8-bit-per-component, 12-bit-per-component, and\n16-bit-per-component lossless JPEG images.  A new libjpeg API function\n(`jpeg_enable_lossless()`), TurboJPEG API parameters\n(`TJPARAM_LOSSLESS`/`TJ.PARAM_LOSSLESS`,\n`TJPARAM_LOSSLESSPSV`/`TJ.PARAM_LOSSLESSPSV`, and\n`TJPARAM_LOSSLESSPT`/`TJ.PARAM_LOSSLESSPT`), and a cjpeg/TJBench option\n(`-lossless`) can be used to create a lossless JPEG image.  (Decompression of\nlossless JPEG images is handled automatically.)  Refer to\n[libjpeg.txt](doc/libjpeg.txt), [usage.txt](doc/usage.txt), and the TurboJPEG\nAPI documentation for more details.\n\n6. Added support for 12-bit-per-component (lossy and lossless) and\n16-bit-per-component (lossless) JPEG images to the libjpeg and TurboJPEG APIs:\n\n     - The existing `data_precision` field in `jpeg_compress_struct` and\n`jpeg_decompress_struct` has been repurposed to enable the creation of\n12-bit-per-component and 16-bit-per-component JPEG images or to detect whether\na 12-bit-per-component or 16-bit-per-component JPEG image is being\ndecompressed.\n     - New 12-bit-per-component and 16-bit-per-component versions of\n`jpeg_write_scanlines()` and `jpeg_read_scanlines()`, as well as new\n12-bit-per-component versions of `jpeg_write_raw_data()`,\n`jpeg_skip_scanlines()`, `jpeg_crop_scanline()`, and `jpeg_read_raw_data()`,\nprovide interfaces for compressing from/decompressing to 12-bit-per-component\nand 16-bit-per-component packed-pixel and planar YUV image buffers.\n     - New 12-bit-per-component and 16-bit-per-component compression,\ndecompression, and image I/O functions/methods have been added to the TurboJPEG\nAPI, and a new API parameter (`TJPARAM_PRECISION`/`TJ.PARAM_PRECISION`) can be\nused to query the data precision of a JPEG image.  (YUV functions are currently\nlimited to 8-bit data precision but can be expanded to accommodate 12-bit data\nprecision in the future, if such is deemed beneficial.)\n     - A new cjpeg and TJBench command-line argument (`-precision`) can be used\nto create a 12-bit-per-component or 16-bit-per-component JPEG image.\n(Decompression and transformation of 12-bit-per-component and\n16-bit-per-component JPEG images is handled automatically.)\n\n    Refer to [libjpeg.txt](doc/libjpeg.txt), [usage.txt](doc/usage.txt), and\nthe TurboJPEG API documentation for more details.\n\n\n2.1.5.1\n=======\n\n### Significant changes relative to 2.1.5:\n\n1. The SIMD dispatchers in libjpeg-turbo 2.1.4 and prior stored the list of\nsupported SIMD instruction sets in a global variable, which caused an innocuous\nrace condition whereby the variable could have been initialized multiple times\nif `jpeg_start_*compress()` was called simultaneously in multiple threads.\nlibjpeg-turbo 2.1.5 included an undocumented attempt to fix this race condition\nby making the SIMD support variable thread-local.  However, that caused another\nissue whereby, if `jpeg_start_*compress()` was called in one thread and\n`jpeg_read_*()` or `jpeg_write_*()` was called in a second thread, the SIMD\nsupport variable was never initialized in the second thread.  On x86 systems,\nthis led the second thread to incorrectly assume that AVX2 instructions were\nalways available, and when it attempted to use those instructions on older x86\nCPUs that do not support them, an illegal instruction error occurred.  The SIMD\ndispatchers now ensure that the SIMD support variable is initialized before\ndispatching based on its value.\n\n\n2.1.5\n=====\n\n### Significant changes relative to 2.1.4:\n\n1. Fixed issues in the build system whereby, when using the Ninja Multi-Config\nCMake generator, a static build of libjpeg-turbo (a build in which\n`ENABLE_SHARED` is `0`) could not be installed, a Windows installer could not\nbe built, and the Java regression tests failed.\n\n2. Fixed a regression introduced by 2.0 beta1[15] that caused a buffer overrun\nin the progressive Huffman encoder when attempting to transform a\nspecially-crafted malformed 12-bit-per-component JPEG image into a progressive\n12-bit-per-component JPEG image using a 12-bit-per-component build of\nlibjpeg-turbo (`-DWITH_12BIT=1`.)  Given that the buffer overrun was fully\ncontained within the progressive Huffman encoder structure and did not cause a\nsegfault or other user-visible errant behavior, given that the lossless\ntransformer (unlike the decompressor) is not generally exposed to arbitrary\ndata exploits, and given that 12-bit-per-component builds of libjpeg-turbo are\nuncommon, this issue did not likely pose a security risk.\n\n3. Fixed an issue whereby, when using a 12-bit-per-component build of\nlibjpeg-turbo (`-DWITH_12BIT=1`), passing samples with values greater than 4095\nor less than 0 to `jpeg_write_scanlines()` caused a buffer overrun or underrun\nin the RGB-to-YCbCr color converter.\n\n4. Fixed a floating point exception that occurred when attempting to use the\njpegtran `-drop` and `-trim` options to losslessly transform a\nspecially-crafted malformed JPEG image.\n\n5. Fixed an issue in `tjBufSizeYUV2()` whereby it returned a bogus result,\nrather than throwing an error, if the `align` parameter was not a power of 2.\nFixed a similar issue in `tjCompressFromYUV()` whereby it generated a corrupt\nJPEG image in certain cases, rather than throwing an error, if the `align`\nparameter was not a power of 2.\n\n6. Fixed an issue whereby `tjDecompressToYUV2()`, which is a wrapper for\n`tjDecompressToYUVPlanes()`, used the desired YUV image dimensions rather than\nthe actual scaled image dimensions when computing the plane pointers and\nstrides to pass to `tjDecompressToYUVPlanes()`.  This caused a buffer overrun\nand subsequent segfault if the desired image dimensions exceeded the scaled\nimage dimensions.\n\n7. Fixed an issue whereby, when decompressing a 12-bit-per-component JPEG image\n(`-DWITH_12BIT=1`) using an alpha-enabled output color space such as\n`JCS_EXT_RGBA`, the alpha channel was set to 255 rather than 4095.\n\n8. Fixed an issue whereby the Java version of TJBench did not accept a range of\nquality values.\n\n9. Fixed an issue whereby, when `-progressive` was passed to TJBench, the JPEG\ninput image was not transformed into a progressive JPEG image prior to\ndecompression.\n\n\n2.1.4\n=====\n\n### Significant changes relative to 2.1.3:\n\n1. Fixed a regression introduced in 2.1.3 that caused build failures with\nVisual Studio 2010.\n\n2. The `tjDecompressHeader3()` function in the TurboJPEG C API and the\n`TJDecompressor.setSourceImage()` method in the TurboJPEG Java API now accept\n\"abbreviated table specification\" (AKA \"tables-only\") datastreams, which can be\nused to prime the decompressor with quantization and Huffman tables that can be\nused when decompressing subsequent \"abbreviated image\" datastreams.\n\n3. libjpeg-turbo now performs run-time detection of AltiVec instructions on\nOS X/PowerPC systems if AltiVec instructions are not enabled at compile time.\nThis allows both AltiVec-equipped (PowerPC G4 and G5) and non-AltiVec-equipped\n(PowerPC G3) CPUs to be supported using the same build of libjpeg-turbo.\n\n4. Fixed an error (\"Bogus virtual array access\") that occurred when attempting\nto decompress a progressive JPEG image with a height less than or equal to one\niMCU (8 * the vertical sampling factor) using buffered-image mode with\ninterblock smoothing enabled.  This was a regression introduced by\n2.1 beta1[6(b)].\n\n5. Fixed two issues that prevented partial image decompression from working\nproperly with buffered-image mode:\n\n     - Attempting to call `jpeg_crop_scanline()` after\n`jpeg_start_decompress()` but before `jpeg_start_output()` resulted in an error\n(\"Improper call to JPEG library in state 207\".)\n     - Attempting to use `jpeg_skip_scanlines()` resulted in an error (\"Bogus\nvirtual array access\") under certain circumstances.\n\n\n2.1.3\n=====\n\n### Significant changes relative to 2.1.2:\n\n1. Fixed a regression introduced by 2.0 beta1[7] whereby cjpeg compressed PGM\ninput files into full-color JPEG images unless the `-grayscale` option was\nused.\n\n2. cjpeg now automatically compresses GIF and 8-bit BMP input files into\ngrayscale JPEG images if the input files contain only shades of gray.\n\n3. The build system now enables the intrinsics implementation of the AArch64\n(Arm 64-bit) Neon SIMD extensions by default when using GCC 12 or later.\n\n4. Fixed a segfault that occurred while decompressing a 4:2:0 JPEG image using\nthe merged (non-fancy) upsampling algorithms (that is, with\n`cinfo.do_fancy_upsampling` set to `FALSE`) along with `jpeg_crop_scanline()`.\nSpecifically, the segfault occurred if the number of bytes remaining in the\noutput buffer was less than the number of bytes required to represent one\nuncropped scanline of the output image.  For that reason, the issue could only\nbe reproduced using the libjpeg API, not using djpeg.\n\n\n2.1.2\n=====\n\n### Significant changes relative to 2.1.1:\n\n1. Fixed a regression introduced by 2.1 beta1[13] that caused the remaining\nGAS implementations of AArch64 (Arm 64-bit) Neon SIMD functions (which are used\nby default with GCC for performance reasons) to be placed in the `.rodata`\nsection rather than in the `.text` section.  This caused the GNU linker to\nautomatically place the `.rodata` section in an executable segment, which\nprevented libjpeg-turbo from working properly with other linkers and also\nrepresented a potential security risk.\n\n2. Fixed an issue whereby the `tjTransform()` function incorrectly computed the\niMCU size for 4:4:4 JPEG images with non-unary sampling factors and thus unduly\nrejected some cropping regions, even though those regions aligned with 8x8 iMCU\nboundaries.\n\n3. Fixed a regression introduced by 2.1 beta1[13] that caused the build system\nto enable the Arm Neon SIMD extensions when targetting Armv6 and other legacy\narchitectures that do not support Neon instructions.\n\n4. libjpeg-turbo now performs run-time detection of AltiVec instructions on\nFreeBSD/PowerPC systems if AltiVec instructions are not enabled at compile\ntime.  This allows both AltiVec-equipped and non-AltiVec-equipped CPUs to be\nsupported using the same build of libjpeg-turbo.\n\n5. cjpeg now accepts a `-strict` argument similar to that of djpeg and\njpegtran, which causes the compressor to abort if an LZW-compressed GIF input\nimage contains incomplete or corrupt image data.\n\n\n2.1.1\n=====\n\n### Significant changes relative to 2.1.0:\n\n1. Fixed a regression introduced in 2.1.0 that caused build failures with\nnon-GCC-compatible compilers for Un*x/Arm platforms.\n\n2. Fixed a regression introduced by 2.1 beta1[13] that prevented the Arm 32-bit\n(AArch32) Neon SIMD extensions from building unless the C compiler flags\nincluded `-mfloat-abi=softfp` or `-mfloat-abi=hard`.\n\n3. Fixed an issue in the AArch32 Neon SIMD Huffman encoder whereby reliance on\nundefined C compiler behavior led to crashes (\"SIGBUS: illegal alignment\") on\nAndroid systems when running AArch32/Thumb builds of libjpeg-turbo built with\nrecent versions of Clang.\n\n4. Added a command-line argument (`-copy icc`) to jpegtran that causes it to\ncopy only the ICC profile markers from the source file and discard any other\nmetadata.\n\n5. libjpeg-turbo should now build and run on CHERI-enabled architectures, which\nuse capability pointers that are larger than the size of `size_t`.\n\n6. Fixed a regression (CVE-2021-37972) introduced by 2.1 beta1[5] that caused a\nsegfault in the 64-bit SSE2 Huffman encoder when attempting to losslessly\ntransform a specially-crafted malformed JPEG image.\n\n\n2.1.0\n=====\n\n### Significant changes relative to 2.1 beta1:\n\n1. Fixed a regression (CVE-2021-29390) introduced by 2.1 beta1[6(b)] whereby\nattempting to decompress certain progressive JPEG images with one or more\ncomponent planes of width 8 or less caused a buffer overrun.\n\n2. Fixed a regression introduced by 2.1 beta1[6(b)] whereby attempting to\ndecompress a specially-crafted malformed progressive JPEG image caused the\nblock smoothing algorithm to read from uninitialized memory.\n\n3. Fixed an issue in the Arm Neon SIMD Huffman encoders that caused the\nencoders to generate incorrect results when using the Clang compiler with\nVisual Studio.\n\n4. Fixed a floating point exception (CVE-2021-20205) that occurred when\nattempting to compress a specially-crafted malformed GIF image with a specified\nimage width of 0 using cjpeg.\n\n5. Fixed a regression introduced by 2.0 beta1[15] whereby attempting to\ngenerate a progressive JPEG image on an SSE2-capable CPU using a scan script\ncontaining one or more scans with lengths divisible by 32 and non-zero\nsuccessive approximation low bit positions would, under certain circumstances,\nresult in an error (\"Missing Huffman code table entry\") and an invalid JPEG\nimage.\n\n6. Introduced a new flag (`TJFLAG_LIMITSCANS` in the TurboJPEG C API and\n`TJ.FLAG_LIMIT_SCANS` in the TurboJPEG Java API) and a corresponding TJBench\ncommand-line argument (`-limitscans`) that causes the TurboJPEG decompression\nand transform functions/operations to return/throw an error if a progressive\nJPEG image contains an unreasonably large number of scans.  This allows\napplications that use the TurboJPEG API to guard against an exploit of the\nprogressive JPEG format described in the report\n[\"Two Issues with the JPEG Standard\"](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n7. The PPM reader now throws an error, rather than segfaulting (due to a buffer\noverrun, CVE-2021-46822) or generating incorrect pixels, if an application\nattempts to use the `tjLoadImage()` function to load a 16-bit binary PPM file\n(a binary PPM file with a maximum value greater than 255) into a grayscale\nimage buffer or to load a 16-bit binary PGM file into an RGB image buffer.\n\n8. Fixed an issue in the PPM reader that caused incorrect pixels to be\ngenerated when using the `tjLoadImage()` function to load a 16-bit binary PPM\nfile into an extended RGB image buffer.\n\n9. Fixed an issue whereby, if a JPEG buffer was automatically re-allocated by\none of the TurboJPEG compression or transform functions and an error\nsubsequently occurred during compression or transformation, the JPEG buffer\npointer passed by the application was not updated when the function returned.\n\n\n2.0.90 (2.1 beta1)\n==================\n\n### Significant changes relative to 2.0.6:\n\n1. The build system, x86-64 SIMD extensions, and accelerated Huffman codec now\nsupport the x32 ABI on Linux, which allows for using x86-64 instructions with\n32-bit pointers.  The x32 ABI is generally enabled by adding `-mx32` to the\ncompiler flags.\n\n     Caveats:\n     - CMake 3.9.0 or later is required in order for the build system to\nautomatically detect an x32 build.\n     - Java does not support the x32 ABI, and thus the TurboJPEG Java API will\nautomatically be disabled with x32 builds.\n\n2. Added Loongson MMI SIMD implementations of the RGB-to-grayscale, 4:2:2 fancy\nchroma upsampling, 4:2:2 and 4:2:0 merged chroma upsampling/color conversion,\nand fast integer DCT/IDCT algorithms.  Relative to libjpeg-turbo 2.0.x, this\nspeeds up:\n\n     - the compression of RGB source images into grayscale JPEG images by\napproximately 20%\n     - the decompression of 4:2:2 JPEG images by approximately 40-60% when\nusing fancy upsampling\n     - the decompression of 4:2:2 and 4:2:0 JPEG images by approximately\n15-20% when using merged upsampling\n     - the compression of RGB source images by approximately 30-45% when using\nthe fast integer DCT\n     - the decompression of JPEG images into RGB destination images by\napproximately 2x when using the fast integer IDCT\n\n    The overall decompression speedup for RGB images is now approximately\n2.3-3.7x (compared to 2-3.5x with libjpeg-turbo 2.0.x.)\n\n3. 32-bit (Armv7 or Armv7s) iOS builds of libjpeg-turbo are no longer\nsupported, and the libjpeg-turbo build system can no longer be used to package\nsuch builds.  32-bit iOS apps cannot run in iOS 11 and later, and the App Store\nno longer allows them.\n\n4. 32-bit (i386) OS X/macOS builds of libjpeg-turbo are no longer supported,\nand the libjpeg-turbo build system can no longer be used to package such\nbuilds.  32-bit Mac applications cannot run in macOS 10.15 \"Catalina\" and\nlater, and the App Store no longer allows them.\n\n5. The SSE2 (x86 SIMD) and C Huffman encoding algorithms have been\nsignificantly optimized, resulting in a measured average overall compression\nspeedup of 12-28% for 64-bit code and 22-52% for 32-bit code on various Intel\nand AMD CPUs, as well as a measured average overall compression speedup of\n0-23% on platforms that do not have a SIMD-accelerated Huffman encoding\nimplementation.\n\n6. The block smoothing algorithm that is applied by default when decompressing\nprogressive Huffman-encoded JPEG images has been improved in the following\nways:\n\n     - The algorithm is now more fault-tolerant.  Previously, if a particular\nscan was incomplete, then the smoothing parameters for the incomplete scan\nwould be applied to the entire output image, including the parts of the image\nthat were generated by the prior (complete) scan.  Visually, this had the\neffect of removing block smoothing from lower-frequency scans if they were\nfollowed by an incomplete higher-frequency scan.  libjpeg-turbo now applies\nblock smoothing parameters to each iMCU row based on which scan generated the\npixels in that row, rather than always using the block smoothing parameters for\nthe most recent scan.\n     - When applying block smoothing to DC scans, a Gaussian-like kernel with a\n5x5 window is used to reduce the \"blocky\" appearance.\n\n7. Added SIMD acceleration for progressive Huffman encoding on Arm platforms.\nThis speeds up the compression of full-color progressive JPEGs by about 30-40%\non average (relative to libjpeg-turbo 2.0.x) when using modern Arm CPUs.\n\n8. Added configure-time and run-time auto-detection of Loongson MMI SIMD\ninstructions, so that the Loongson MMI SIMD extensions can be included in any\nMIPS64 libjpeg-turbo build.\n\n9. Added fault tolerance features to djpeg and jpegtran, mainly to demonstrate\nmethods by which applications can guard against the exploits of the JPEG format\ndescribed in the report\n[\"Two Issues with the JPEG Standard\"](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n     - Both programs now accept a `-maxscans` argument, which can be used to\nlimit the number of allowable scans in the input file.\n     - Both programs now accept a `-strict` argument, which can be used to\ntreat all warnings as fatal.\n\n10. CMake package config files are now included for both the libjpeg and\nTurboJPEG API libraries.  This facilitates using libjpeg-turbo with CMake's\n`find_package()` function.  For example:\n\n        find_package(libjpeg-turbo CONFIG REQUIRED)\n\n        add_executable(libjpeg_program libjpeg_program.c)\n        target_link_libraries(libjpeg_program PUBLIC libjpeg-turbo::jpeg)\n\n        add_executable(libjpeg_program_static libjpeg_program.c)\n        target_link_libraries(libjpeg_program_static PUBLIC\n          libjpeg-turbo::jpeg-static)\n\n        add_executable(turbojpeg_program turbojpeg_program.c)\n        target_link_libraries(turbojpeg_program PUBLIC\n          libjpeg-turbo::turbojpeg)\n\n        add_executable(turbojpeg_program_static turbojpeg_program.c)\n        target_link_libraries(turbojpeg_program_static PUBLIC\n          libjpeg-turbo::turbojpeg-static)\n\n11. Since the Unisys LZW patent has long expired, cjpeg and djpeg can now\nread/write both LZW-compressed and uncompressed GIF files (feature ported from\njpeg-6a and jpeg-9d.)\n\n12. jpegtran now includes the `-wipe` and `-drop` options from jpeg-9a and\njpeg-9d, as well as the ability to expand the image size using the `-crop`\noption.  Refer to jpegtran.1 or usage.txt for more details.\n\n13. Added a complete intrinsics implementation of the Arm Neon SIMD extensions,\nthus providing SIMD acceleration on Arm platforms for all of the algorithms\nthat are SIMD-accelerated on x86 platforms.  This new implementation is\nsignificantly faster in some cases than the old GAS implementation--\ndepending on the algorithms used, the type of CPU core, and the compiler.  GCC,\nas of this writing, does not provide a full or optimal set of Neon intrinsics,\nso for performance reasons, the default when building libjpeg-turbo with GCC is\nto continue using the GAS implementation of the following algorithms:\n\n     - 32-bit RGB-to-YCbCr color conversion\n     - 32-bit fast and accurate inverse DCT\n     - 64-bit RGB-to-YCbCr and YCbCr-to-RGB color conversion\n     - 64-bit accurate forward and inverse DCT\n     - 64-bit Huffman encoding\n\n    A new CMake variable (`NEON_INTRINSICS`) can be used to override this\ndefault.\n\n    Since the new intrinsics implementation includes SIMD acceleration\nfor merged upsampling/color conversion, 1.5.1[5] is no longer necessary and has\nbeen reverted.\n\n14. The Arm Neon SIMD extensions can now be built using Visual Studio.\n\n15. The build system can now be used to generate a universal x86-64 + Armv8\nlibjpeg-turbo SDK package for both iOS and macOS.\n\n\n2.0.6\n=====\n\n### Significant changes relative to 2.0.5:\n\n1. Fixed \"using JNI after critical get\" errors that occurred on Android\nplatforms when using any of the YUV encoding/compression/decompression/decoding\nmethods in the TurboJPEG Java API.\n\n2. Fixed or worked around multiple issues with `jpeg_skip_scanlines()`:\n\n     - Fixed segfaults (CVE-2020-35538) or \"Corrupt JPEG data: premature end of\ndata segment\" errors in `jpeg_skip_scanlines()` that occurred when\ndecompressing 4:2:2 or 4:2:0 JPEG images using merged (non-fancy)\nupsampling/color conversion (that is, when setting `cinfo.do_fancy_upsampling`\nto `FALSE`.)  2.0.0[6] was a similar fix, but it did not cover all cases.\n     - `jpeg_skip_scanlines()` now throws an error if two-pass color\nquantization is enabled.  Two-pass color quantization never worked properly\nwith `jpeg_skip_scanlines()`, and the issues could not readily be fixed.\n     - Fixed an issue whereby `jpeg_skip_scanlines()` always returned 0 when\nskipping past the end of an image.\n\n3. The Arm 64-bit (Armv8) Neon SIMD extensions can now be built using MinGW\ntoolchains targetting Arm64 (AArch64) Windows binaries.\n\n4. Fixed unexpected visual artifacts that occurred when using\n`jpeg_crop_scanline()` and interblock smoothing while decompressing only the DC\nscan of a progressive JPEG image.\n\n5. Fixed an issue whereby libjpeg-turbo would not build if 12-bit-per-component\nJPEG support (`WITH_12BIT`) was enabled along with libjpeg v7 or libjpeg v8\nAPI/ABI emulation (`WITH_JPEG7` or `WITH_JPEG8`.)\n\n\n2.0.5\n=====\n\n### Significant changes relative to 2.0.4:\n\n1. Worked around issues in the MIPS DSPr2 SIMD extensions that caused failures\nin the libjpeg-turbo regression tests.  Specifically, the\n`jsimd_h2v1_downsample_dspr2()` and `jsimd_h2v2_downsample_dspr2()` functions\nin the MIPS DSPr2 SIMD extensions are now disabled until/unless they can be\nfixed, and other functions that are incompatible with big endian MIPS CPUs are\ndisabled when building libjpeg-turbo for such CPUs.\n\n2. Fixed an oversight in the `TJCompressor.compress(int)` method in the\nTurboJPEG Java API that caused an error (\"java.lang.IllegalStateException: No\nsource image is associated with this instance\") when attempting to use that\nmethod to compress a YUV image.\n\n3. Fixed an issue (CVE-2020-13790) in the PPM reader that caused a buffer\noverrun in cjpeg, TJBench, or the `tjLoadImage()` function if one of the values\nin a binary PPM/PGM input file exceeded the maximum value defined in the file's\nheader and that maximum value was less than 255.  libjpeg-turbo 1.5.0 already\nincluded a similar fix for binary PPM/PGM files with maximum values greater\nthan 255.\n\n4. The TurboJPEG API library's global error handler, which is used in functions\nsuch as `tjBufSize()` and `tjLoadImage()` that do not require a TurboJPEG\ninstance handle, is now thread-safe on platforms that support thread-local\nstorage.\n\n\n2.0.4\n=====\n\n### Significant changes relative to 2.0.3:\n\n1. Fixed a regression in the Windows packaging system (introduced by\n2.0 beta1[2]) whereby, if both the 64-bit libjpeg-turbo SDK for GCC and the\n64-bit libjpeg-turbo SDK for Visual C++ were installed on the same system, only\none of them could be uninstalled.\n\n2. Fixed a signed integer overflow and subsequent segfault that occurred when\nattempting to decompress images with more than 715827882 pixels using the\n64-bit C version of TJBench.\n\n3. Fixed out-of-bounds write in `tjDecompressToYUV2()` and\n`tjDecompressToYUVPlanes()` (sometimes manifesting as a double free) that\noccurred when attempting to decompress grayscale JPEG images that were\ncompressed with a sampling factor other than 1 (for instance, with\n`cjpeg -grayscale -sample 2x2`).\n\n4. Fixed a regression introduced by 2.0.2[5] that caused the TurboJPEG API to\nincorrectly identify some JPEG images with unusual sampling factors as 4:4:4\nJPEG images.  This was known to cause a buffer overflow when attempting to\ndecompress some such images using `tjDecompressToYUV2()` or\n`tjDecompressToYUVPlanes()`.\n\n5. Fixed an issue (CVE-2020-17541), detected by ASan, whereby attempting to\nlosslessly transform a specially-crafted malformed JPEG image containing an\nextremely-high-frequency coefficient block (junk image data that could never be\ngenerated by a legitimate JPEG compressor) could cause the Huffman encoder's\nlocal buffer to be overrun. (Refer to 1.4.0[9] and 1.4beta1[15].)  Given that\nthe buffer overrun was fully contained within the stack and did not cause a\nsegfault or other user-visible errant behavior, and given that the lossless\ntransformer (unlike the decompressor) is not generally exposed to arbitrary\ndata exploits, this issue did not likely pose a security risk.\n\n6. The Arm 64-bit (Armv8) Neon SIMD assembly code now stores constants in a\nseparate read-only data section rather than in the text section, to support\nexecute-only memory layouts.\n\n\n2.0.3\n=====\n\n### Significant changes relative to 2.0.2:\n\n1. Fixed \"using JNI after critical get\" errors that occurred on Android\nplatforms when passing invalid arguments to certain methods in the TurboJPEG\nJava API.\n\n2. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that was known to cause an illegal\ninstruction exception, in rare cases, on CPUs that lack support for CPUID leaf\n07H (or on which the maximum CPUID leaf has been limited by way of a BIOS\nsetting.)\n\n3. The 4:4:0 (h1v2) fancy (smooth) chroma upsampling algorithm in the\ndecompressor now uses a similar bias pattern to that of the 4:2:2 (h2v1) fancy\nchroma upsampling algorithm, rounding up or down the upsampled result for\nalternate pixels rather than always rounding down.  This ensures that,\nregardless of whether a 4:2:2 JPEG image is rotated or transposed prior to\ndecompression (in the frequency domain) or after decompression (in the spatial\ndomain), the final image will be similar.\n\n4. Fixed an integer overflow and subsequent segfault that occurred when\nattempting to compress or decompress images with more than 1 billion pixels\nusing the TurboJPEG API.\n\n5. Fixed a regression introduced by 2.0 beta1[15] whereby attempting to\ngenerate a progressive JPEG image on an SSE2-capable CPU using a scan script\ncontaining one or more scans with lengths divisible by 16 would result in an\nerror (\"Missing Huffman code table entry\") and an invalid JPEG image.\n\n6. Fixed an issue whereby `tjDecodeYUV()` and `tjDecodeYUVPlanes()` would throw\nan error (\"Invalid progressive parameters\") or a warning (\"Inconsistent\nprogression sequence\") if passed a TurboJPEG instance that was previously used\nto decompress a progressive JPEG image.\n\n\n2.0.2\n=====\n\n### Significant changes relative to 2.0.1:\n\n1. Fixed a regression introduced by 2.0.1[5] that prevented a runtime search\npath (rpath) from being embedded in the libjpeg-turbo shared libraries and\nexecutables for macOS and iOS.  This caused a fatal error of the form\n\"dyld: Library not loaded\" when attempting to use one of the executables,\nunless `DYLD_LIBRARY_PATH` was explicitly set to the location of the\nlibjpeg-turbo shared libraries.\n\n2. Fixed an integer overflow and subsequent segfault (CVE-2018-20330) that\noccurred when attempting to load a BMP file with more than 1 billion pixels\nusing the `tjLoadImage()` function.\n\n3. Fixed a buffer overrun (CVE-2018-19664) that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image to a 256-color BMP using\ndjpeg.\n\n4. Fixed a floating point exception that occurred when attempting to\ndecompress a specially-crafted malformed JPEG image with a specified image\nwidth or height of 0 using the C version of TJBench.\n\n5. The TurboJPEG API will now decompress 4:4:4 JPEG images with 2x1, 1x2, 3x1,\nor 1x3 luminance and chrominance sampling factors.  This is a non-standard way\nof specifying 1x subsampling (normally 4:4:4 JPEGs have 1x1 luminance and\nchrominance sampling factors), but the JPEG format and the libjpeg API both\nallow it.\n\n6. Fixed a regression introduced by 2.0 beta1[7] that caused djpeg to generate\nincorrect PPM images when used with the `-colors` option.\n\n7. Fixed an issue whereby a static build of libjpeg-turbo (a build in which\n`ENABLE_SHARED` is `0`) could not be installed using the Visual Studio IDE.\n\n8. Fixed a severe performance issue in the Loongson MMI SIMD extensions that\noccurred when compressing RGB images whose image rows were not 64-bit-aligned.\n\n\n2.0.1\n=====\n\n### Significant changes relative to 2.0.0:\n\n1. Fixed a regression introduced with the new CMake-based Un*x build system,\nwhereby jconfig.h could cause compiler warnings of the form\n`\"HAVE_*_H\" redefined` if it was included by downstream Autotools-based\nprojects that used `AC_CHECK_HEADERS()` to check for the existence of locale.h,\nstddef.h, or stdlib.h.\n\n2. The `jsimd_quantize_float_dspr2()` and `jsimd_convsamp_float_dspr2()`\nfunctions in the MIPS DSPr2 SIMD extensions are now disabled at compile time\nif the soft float ABI is enabled.  Those functions use instructions that are\nincompatible with the soft float ABI.\n\n3. Fixed a regression in the SIMD feature detection code, introduced by\nthe AVX2 SIMD extensions (2.0 beta1[1]), that caused libjpeg-turbo to crash on\nWindows 7 if Service Pack 1 was not installed.\n\n4. Fixed out-of-bounds read in cjpeg that occurred when attempting to compress\na specially-crafted malformed color-index (8-bit-per-sample) Targa file in\nwhich some of the samples (color indices) exceeded the bounds of the Targa\nfile's color table.\n\n5. Fixed an issue whereby installing a fully static build of libjpeg-turbo\n(a build in which `CFLAGS` contains `-static` and `ENABLE_SHARED` is `0`) would\nfail with \"No valid ELF RPATH or RUNPATH entry exists in the file.\"\n\n\n2.0.0\n=====\n\n### Significant changes relative to 2.0 beta1:\n\n1. The TurboJPEG API can now decompress CMYK JPEG images that have subsampled M\nand Y components (not to be confused with YCCK JPEG images, in which the C/M/Y\ncomponents have been transformed into luma and chroma.)   Previously, an error\nwas generated (\"Could not determine subsampling type for JPEG image\") when such\nan image was passed to `tjDecompressHeader3()`, `tjTransform()`,\n`tjDecompressToYUVPlanes()`, `tjDecompressToYUV2()`, or the equivalent Java\nmethods.\n\n2. Fixed an issue (CVE-2018-11813) whereby a specially-crafted malformed input\nfile (specifically, a file with a valid Targa header but incomplete pixel data)\nwould cause cjpeg to generate a JPEG file that was potentially thousands of\ntimes larger than the input file.  The Targa reader in cjpeg was not properly\ndetecting that the end of the input file had been reached prematurely, so after\nall valid pixels had been read from the input, the reader injected dummy pixels\nwith values of 255 into the JPEG compressor until the number of pixels\nspecified in the Targa header had been compressed.  The Targa reader in cjpeg\nnow behaves like the PPM reader and aborts compression if the end of the input\nfile is reached prematurely.  Because this issue only affected cjpeg and not\nthe underlying library, and because it did not involve any out-of-bounds reads\nor other exploitable behaviors, it was not believed to represent a security\nthreat.\n\n3. Fixed an issue whereby the `tjLoadImage()` and `tjSaveImage()` functions\nwould produce a \"Bogus message code\" error message if the underlying bitmap and\nPPM readers/writers threw an error that was specific to the readers/writers\n(as opposed to a general libjpeg API error.)\n\n4. Fixed an issue (CVE-2018-1152) whereby a specially-crafted malformed BMP\nfile, one in which the header specified an image width of 1073741824 pixels,\nwould trigger a floating point exception (division by zero) in the\n`tjLoadImage()` function when attempting to load the BMP file into a\n4-component image buffer.\n\n5. Fixed an issue whereby certain combinations of calls to\n`jpeg_skip_scanlines()` and `jpeg_read_scanlines()` could trigger an infinite\nloop when decompressing progressive JPEG images that use vertical chroma\nsubsampling (for instance, 4:2:0 or 4:4:0.)\n\n6. Fixed a segfault in `jpeg_skip_scanlines()` that occurred when decompressing\na 4:2:2 or 4:2:0 JPEG image using the merged (non-fancy) upsampling algorithms\n(that is, when setting `cinfo.do_fancy_upsampling` to `FALSE`.)\n\n7. The new CMake-based build system will now disable the MIPS DSPr2 SIMD\nextensions if it detects that the compiler does not support DSPr2 instructions.\n\n8. Fixed out-of-bounds read in cjpeg (CVE-2018-14498) that occurred when\nattempting to compress a specially-crafted malformed color-index\n(8-bit-per-sample) BMP file in which some of the samples (color indices)\nexceeded the bounds of the BMP file's color table.\n\n9. Fixed a signed integer overflow in the progressive Huffman decoder, detected\nby the Clang and GCC undefined behavior sanitizers, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\ndid not pose a security threat, but removing the warning made it easier to\ndetect actual security issues, should they arise in the future.\n\n\n1.5.90 (2.0 beta1)\n==================\n\n### Significant changes relative to 1.5.3:\n\n1. Added AVX2 SIMD implementations of the colorspace conversion, chroma\ndownsampling and upsampling, integer quantization and sample conversion, and\naccurate integer DCT/IDCT algorithms.  When using the accurate integer DCT/IDCT\nalgorithms on AVX2-equipped CPUs, the compression of RGB images is\napproximately 13-36% (avg. 22%) faster (relative to libjpeg-turbo 1.5.x) with\n64-bit code and 11-21% (avg. 17%) faster with 32-bit code, and the\ndecompression of RGB images is approximately 9-35% (avg. 17%) faster with\n64-bit code and 7-17% (avg. 12%) faster with 32-bit code.  (As tested on a\n3 GHz Intel Core i7.  Actual mileage may vary.)\n\n2. Overhauled the build system to use CMake on all platforms, and removed the\nautotools-based build system.  This decision resulted from extensive\ndiscussions within the libjpeg-turbo community.  libjpeg-turbo traditionally\nused CMake only for Windows builds, but there was an increasing amount of\ndemand to extend CMake support to other platforms.  However, because of the\nunique nature of our code base (the need to support different assemblers on\neach platform, the need for Java support, etc.), providing dual build systems\nas other OSS imaging libraries do (including libpng and libtiff) would have\ncreated a maintenance burden.  The use of CMake greatly simplifies some aspects\nof our build system, owing to CMake's built-in support for various assemblers,\nJava, and unit testing, as well as generally fewer quirks that have to be\nworked around in order to implement our packaging system.  Eliminating\nautotools puts our project slightly at odds with the traditional practices of\nthe OSS community, since most \"system libraries\" tend to be built with\nautotools, but it is believed that the benefits of this move outweigh the\nrisks.  In addition to providing a unified build environment, switching to\nCMake allows for the use of various build tools and IDEs that aren't supported\nunder autotools, including XCode, Ninja, and Eclipse.  It also eliminates the\nneed to install autotools via MacPorts/Homebrew on OS X and allows\nlibjpeg-turbo to be configured without the use of a terminal/command prompt.\nExtensive testing was conducted to ensure that all features provided by the\nautotools-based build system are provided by the new build system.\n\n3. The libjpeg API in this version of libjpeg-turbo now includes two additional\nfunctions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can\nbe used to extract ICC profile data from a JPEG file while decompressing or to\nembed ICC profile data in a JPEG file while compressing or transforming.  This\neliminates the need for downstream projects, such as color management libraries\nand browsers, to include their own glueware for accomplishing this.\n\n4. Improved error handling in the TurboJPEG API library:\n\n     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API\nthat allows compression/decompression/transform error messages to be retrieved\nin a thread-safe manner.  Retrieving error messages from global functions, such\nas `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those\nfunctions will only throw errors if passed an invalid argument or if a memory\nallocation failure occurs, thread safety is not as much of a concern.\n     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API\nand a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that\ncan be used to determine the severity of the last\ncompression/decompression/transform error.  This allows applications to\nchoose whether to ignore warnings (non-fatal errors) from the underlying\nlibjpeg API or to treat them as fatal.\n     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and\n`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to\nimmediately halt a compression/decompression/transform operation if it\nencounters a warning from the underlying libjpeg API (the default behavior is\nto allow the operation to complete unless a fatal error is encountered.)\n\n5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`\nand `TJ.FLAG_PROGRESSIVE`, respectively) that causes compression and transform\noperations to generate progressive JPEG images.  Additionally, a new transform\noption (`TJXOPT_PROGRESSIVE` in the C API and `TJTransform.OPT_PROGRESSIVE` in\nthe Java API) has been introduced, allowing progressive JPEG images to be\ngenerated by selected transforms in a multi-transform operation.\n\n6. Introduced a new transform option in the TurboJPEG API (`TJXOPT_COPYNONE` in\nthe C API and `TJTransform.OPT_COPYNONE` in the Java API) that allows the\ncopying of markers (including Exif and ICC profile data) to be disabled for a\nparticular transform.\n\n7. Added two functions to the TurboJPEG C API (`tjLoadImage()` and\n`tjSaveImage()`) that can be used to load/save a BMP or PPM/PGM image to/from a\nmemory buffer with a specified pixel format and layout.  These functions\nreplace the project-private (and slow) bmp API, which was previously used by\nTJBench, and they also provide a convenient way for first-time users of\nlibjpeg-turbo to quickly develop a complete JPEG compression/decompression\nprogram.\n\n8. The TurboJPEG C API now includes a new convenience array (`tjAlphaOffset[]`)\nthat contains the alpha component index for each pixel format (or -1 if the\npixel format lacks an alpha component.)  The TurboJPEG Java API now includes a\nnew method (`TJ.getAlphaOffset()`) that returns the same value.  In addition,\nthe `tjRedOffset[]`, `tjGreenOffset[]`, and `tjBlueOffset[]` arrays-- and the\ncorresponding `TJ.getRedOffset()`, `TJ.getGreenOffset()`, and\n`TJ.getBlueOffset()` methods-- now return -1 for `TJPF_GRAY`/`TJ.PF_GRAY`\nrather than 0.  This allows programs to easily determine whether a pixel format\nhas red, green, blue, and alpha components.\n\n9. Added a new example (tjexample.c) that demonstrates the basic usage of the\nTurboJPEG C API.  This example mirrors the functionality of TJExample.java.\nBoth files are now included in the libjpeg-turbo documentation.\n\n10. Fixed two signed integer overflows in the arithmetic decoder, detected by\nthe Clang undefined behavior sanitizer, that could be triggered by attempting\nto decompress a specially-crafted malformed JPEG image.  These issues did not\npose a security threat, but removing the warnings makes it easier to detect\nactual security issues, should they arise in the future.\n\n11. Fixed a bug in the merged 4:2:0 upsampling/dithered RGB565 color conversion\nalgorithm that caused incorrect dithering in the output image.  This algorithm\nnow produces bitwise-identical results to the unmerged algorithms.\n\n12. The SIMD function symbols for x86[-64]/ELF, MIPS/ELF, macOS/x86[-64] (if\nlibjpeg-turbo is built with Yasm), and iOS/Arm[64] builds are now private.\nThis prevents those symbols from being exposed in applications or shared\nlibraries that link statically with libjpeg-turbo.\n\n13. Added Loongson MMI SIMD implementations of the RGB-to-YCbCr and\nYCbCr-to-RGB colorspace conversion, 4:2:0 chroma downsampling, 4:2:0 fancy\nchroma upsampling, integer quantization, and accurate integer DCT/IDCT\nalgorithms.  When using the accurate integer DCT/IDCT, this speeds up the\ncompression of RGB images by approximately 70-100% and the decompression of RGB\nimages by approximately 2-3.5x.\n\n14. Fixed a build error when building with older MinGW releases (regression\ncaused by 1.5.1[7].)\n\n15. Added SIMD acceleration for progressive Huffman encoding on SSE2-capable\nx86 and x86-64 platforms.  This speeds up the compression of full-color\nprogressive JPEGs by about 85-90% on average (relative to libjpeg-turbo 1.5.x)\nwhen using modern Intel and AMD CPUs.\n\n\n1.5.3\n=====\n\n### Significant changes relative to 1.5.2:\n\n1. Fixed a NullPointerException in the TurboJPEG Java wrapper that occurred\nwhen using the YUVImage constructor that creates an instance backed by separate\nimage planes and allocates memory for the image planes.\n\n2. Fixed an issue whereby the Java version of TJUnitTest would fail when\ntesting BufferedImage encoding/decoding on big endian systems.\n\n3. Fixed a segfault in djpeg that would occur if an output format other than\nPPM/PGM was selected along with the `-crop` option.  The `-crop` option now\nworks with the GIF and Targa formats as well (unfortunately, it cannot be made\nto work with the BMP and RLE formats due to the fact that those output engines\nwrite scanlines in bottom-up order.)  djpeg will now exit gracefully if an\noutput format other than PPM/PGM, GIF, or Targa is selected along with the\n`-crop` option.\n\n4. Fixed an issue (CVE-2017-15232) whereby `jpeg_skip_scanlines()` would\nsegfault if color quantization was enabled.\n\n5. TJBench (both C and Java versions) will now display usage information if any\ncommand-line argument is unrecognized.  This prevents the program from silently\nignoring typos.\n\n6. Fixed an access violation in tjbench.exe (Windows) that occurred when the\nprogram was used to decompress an existing JPEG image.\n\n7. Fixed an ArrayIndexOutOfBoundsException in the TJExample Java program that\noccurred when attempting to decompress a JPEG image that had been compressed\nwith 4:1:1 chrominance subsampling.\n\n8. Fixed an issue whereby, when using `jpeg_skip_scanlines()` to skip to the\nend of a single-scan (non-progressive) image, subsequent calls to\n`jpeg_consume_input()` would return `JPEG_SUSPENDED` rather than\n`JPEG_REACHED_EOI`.\n\n9. `jpeg_crop_scanline()` now works correctly when decompressing grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).\n\n\n1.5.2\n=====\n\n### Significant changes relative to 1.5.1:\n\n1. Fixed a regression introduced by 1.5.1[7] that prevented libjpeg-turbo from\nbuilding with Android NDK platforms prior to android-21 (5.0).\n\n2. Fixed a regression introduced by 1.5.1[1] that prevented the MIPS DSPR2 SIMD\ncode in libjpeg-turbo from building.\n\n3. Fixed a regression introduced by 1.5 beta1[11] that prevented the Java\nversion of TJBench from outputting any reference images (the `-nowrite` switch\nwas accidentally enabled by default.)\n\n4. libjpeg-turbo should now build and run with full AltiVec SIMD acceleration\non PowerPC-based AmigaOS 4 and OpenBSD systems.\n\n5. Fixed build and runtime errors on Windows that occurred when building\nlibjpeg-turbo with libjpeg v7 API/ABI emulation and the in-memory\nsource/destination managers.  Due to an oversight, the `jpeg_skip_scanlines()`\nand `jpeg_crop_scanline()` functions were not being included in jpeg7.dll when\nlibjpeg-turbo was built with `-DWITH_JPEG7=1` and `-DWITH_MEMSRCDST=1`.\n\n6. Fixed \"Bogus virtual array access\" error that occurred when using the\nlossless crop feature in jpegtran or the TurboJPEG API, if libjpeg-turbo was\nbuilt with libjpeg v7 API/ABI emulation.  This was apparently a long-standing\nbug that has existed since the introduction of libjpeg v7/v8 API/ABI emulation\nin libjpeg-turbo v1.1.\n\n7. The lossless transform features in jpegtran and the TurboJPEG API will now\nalways attempt to adjust the Exif image width and height tags if the image size\nchanged as a result of the transform.  This behavior has always existed when\nusing libjpeg v8 API/ABI emulation.  It was supposed to be available with\nlibjpeg v7 API/ABI emulation as well but did not work properly due to a bug.\nFurthermore, there was never any good reason not to enable it with libjpeg v6b\nAPI/ABI emulation, since the behavior is entirely internal.  Note that\n`-copy all` must be passed to jpegtran in order to transfer the Exif tags from\nthe source image to the destination image.\n\n8. Fixed several memory leaks in the TurboJPEG API library that could occur\nif the library was built with certain compilers and optimization levels\n(known to occur with GCC 4.x and clang with `-O1` and higher but not with\nGCC 5.x or 6.x) and one of the underlying libjpeg API functions threw an error\nafter a TurboJPEG API function allocated a local buffer.\n\n9. The libjpeg-turbo memory manager will now honor the `max_memory_to_use`\nstructure member in jpeg\\_memory\\_mgr, which can be set to the maximum amount\nof memory (in bytes) that libjpeg-turbo should use during decompression or\nmulti-pass (including progressive) compression.  This limit can also be set\nusing the `JPEGMEM` environment variable or using the `-maxmemory` switch in\ncjpeg/djpeg/jpegtran (refer to the respective man pages for more details.)\nThis has been a documented feature of libjpeg since v5, but the\n`malloc()`/`free()` implementation of the memory manager (jmemnobs.c) never\nimplemented the feature.  Restricting libjpeg-turbo's memory usage is useful\nfor two reasons:  it allows testers to more easily work around the 2 GB limit\nin libFuzzer, and it allows developers of security-sensitive applications to\nmore easily defend against one of the progressive JPEG exploits (LJT-01-004)\nidentified in\n[this report](https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf).\n\n10. TJBench will now run each benchmark for 1 second prior to starting the\ntimer, in order to improve the consistency of the results.  Furthermore, the\n`-warmup` option is now used to specify the amount of warmup time rather than\nthe number of warmup iterations.\n\n11. Fixed an error (`short jump is out of range`) that occurred when assembling\nthe 32-bit x86 SIMD extensions with NASM versions prior to 2.04.  This was a\nregression introduced by 1.5 beta1[12].\n\n\n1.5.1\n=====\n\n### Significant changes relative to 1.5.0:\n\n1. Previously, the undocumented `JSIMD_FORCE*` environment variables could be\nused to force-enable a particular SIMD instruction set if multiple instruction\nsets were available on a particular platform.  On x86 platforms, where CPU\nfeature detection is bulletproof and multiple SIMD instruction sets are\navailable, it makes sense for those environment variables to allow forcing the\nuse of an instruction set only if that instruction set is available.  However,\nsince the ARM implementations of libjpeg-turbo can only use one SIMD\ninstruction set, and since their feature detection code is less bulletproof\n(parsing /proc/cpuinfo), it makes sense for the `JSIMD_FORCENEON` environment\nvariable to bypass the feature detection code and really force the use of NEON\ninstructions.  A new environment variable (`JSIMD_FORCEDSPR2`) was introduced\nin the MIPS implementation for the same reasons, and the existing\n`JSIMD_FORCENONE` environment variable was extended to that implementation.\nThese environment variables provide a workaround for those attempting to test\nARM and MIPS builds of libjpeg-turbo in QEMU, which passes through\n/proc/cpuinfo from the host system.\n\n2. libjpeg-turbo previously assumed that AltiVec instructions were always\navailable on PowerPC platforms, which led to \"illegal instruction\" errors when\nrunning on PowerPC chips that lack AltiVec support (such as the older 7xx/G3\nand newer e5500 series.)  libjpeg-turbo now examines /proc/cpuinfo on\nLinux/Android systems and enables AltiVec instructions only if the CPU supports\nthem.  It also now provides two environment variables, `JSIMD_FORCEALTIVEC` and\n`JSIMD_FORCENONE`, to force-enable and force-disable AltiVec instructions in\nenvironments where /proc/cpuinfo is an unreliable means of CPU feature\ndetection (such as when running in QEMU.)  On OS X, libjpeg-turbo continues to\nassume that AltiVec support is always available, which means that libjpeg-turbo\ncannot be used with G3 Macs unless you set the environment variable\n`JSIMD_FORCENONE` to `1`.\n\n3. Fixed an issue whereby 64-bit ARM (AArch64) builds of libjpeg-turbo would\ncrash when built with recent releases of the Clang/LLVM compiler.  This was\ncaused by an ABI conformance issue in some of libjpeg-turbo's 64-bit NEON SIMD\nroutines.  Those routines were incorrectly using 64-bit instructions to\ntransfer a 32-bit JDIMENSION argument, whereas the ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fancy upsampling is now supported when decompressing JPEG images that use\n4:4:0 (h1v2) chroma subsampling.  These images are generated when losslessly\nrotating or transposing JPEG images that use 4:2:2 (h2v1) chroma subsampling.\nThe h1v2 fancy upsampling algorithm is not currently SIMD-accelerated.\n\n5. If merged upsampling isn't SIMD-accelerated but YCbCr-to-RGB conversion is,\nthen libjpeg-turbo will now disable merged upsampling when decompressing YCbCr\nJPEG images into RGB or extended RGB output images.  This significantly speeds\nup the decompression of 4:2:0 and 4:2:2 JPEGs on ARM platforms if fancy\nupsampling is not used (for example, if the `-nosmooth` option to djpeg is\nspecified.)\n\n6. The TurboJPEG API will now decompress 4:2:2 and 4:4:0 JPEG images with\n2x2 luminance sampling factors and 2x1 or 1x2 chrominance sampling factors.\nThis is a non-standard way of specifying 2x subsampling (normally 4:2:2 JPEGs\nhave 2x1 luminance and 1x1 chrominance sampling factors, and 4:4:0 JPEGs have\n1x2 luminance and 1x1 chrominance sampling factors), but the JPEG format and\nthe libjpeg API both allow it.\n\n7. Fixed an unsigned integer overflow in the libjpeg memory manager, detected\nby the Clang undefined behavior sanitizer, that could be triggered by\nattempting to decompress a specially-crafted malformed JPEG image.  This issue\naffected only 32-bit code and did not pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n8. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers when attempting to decompress\nspecially-crafted malformed JPEG images.  None of these issues posed a security\nthreat, but removing the warnings makes it easier to detect actual security\nissues, should they arise in the future.\n\n9. Fixed an out-of-bounds array reference, introduced by 1.4.90[2] (partial\nimage decompression) and detected by the Clang undefined behavior sanitizer,\nthat could be triggered by a specially-crafted malformed JPEG image with more\nthan four components.  Because the out-of-bounds reference was still within the\nsame structure, it was not known to pose a security threat, but removing the\nwarning makes it easier to detect actual security issues, should they arise in\nthe future.\n\n10. Fixed another ABI conformance issue in the 64-bit ARM (AArch64) NEON SIMD\ncode.  Some of the routines were incorrectly reading and storing data below the\nstack pointer, which caused segfaults in certain applications under specific\ncircumstances.\n\n\n1.5.0\n=====\n\n### Significant changes relative to 1.5 beta1:\n\n1. Fixed an issue whereby a malformed motion-JPEG frame could cause the \"fast\npath\" of libjpeg-turbo's Huffman decoder to read from uninitialized memory.\n\n2. Added libjpeg-turbo version and build information to the global string table\nof the libjpeg and TurboJPEG API libraries.  This is a common practice in other\ninfrastructure libraries, such as OpenSSL and libpng, because it makes it easy\nto examine an application binary and determine which version of the library the\napplication was linked against.\n\n3. Fixed a couple of issues in the PPM reader that would cause buffer overruns\nin cjpeg if one of the values in a binary PPM/PGM input file exceeded the\nmaximum value defined in the file's header and that maximum value was greater\nthan 255.  libjpeg-turbo 1.4.2 already included a similar fix for ASCII PPM/PGM\nfiles.  Note that these issues were not security bugs, since they were confined\nto the cjpeg program and did not affect any of the libjpeg-turbo libraries.\n\n4. Fixed an issue whereby attempting to decompress a JPEG file with a corrupt\nheader using the `tjDecompressToYUV2()` function would cause the function to\nabort without returning an error and, under certain circumstances, corrupt the\nstack.  This only occurred if `tjDecompressToYUV2()` was called prior to\ncalling `tjDecompressHeader3()`, or if the return value from\n`tjDecompressHeader3()` was ignored (both cases represent incorrect usage of\nthe TurboJPEG API.)\n\n5. Fixed an issue in the ARM 32-bit SIMD-accelerated Huffman encoder that\nprevented the code from assembling properly with clang.\n\n6. The `jpeg_stdio_src()`, `jpeg_mem_src()`, `jpeg_stdio_dest()`, and\n`jpeg_mem_dest()` functions in the libjpeg API will now throw an error if a\nsource/destination manager has already been assigned to the compress or\ndecompress object by a different function or by the calling program.  This\nprevents these functions from attempting to reuse a source/destination manager\nstructure that was allocated elsewhere, because there is no way to ensure that\nit would be big enough to accommodate the new source/destination manager.\n\n\n1.4.90 (1.5 beta1)\n==================\n\n### Significant changes relative to 1.4.2:\n\n1. Added full SIMD acceleration for PowerPC platforms using AltiVec VMX\n(128-bit SIMD) instructions.  Although the performance of libjpeg-turbo on\nPowerPC was already good, due to the increased number of registers available\nto the compiler vs. x86, it was still possible to speed up compression by about\n3-4x and decompression by about 2-2.5x (relative to libjpeg v6b) through the\nuse of AltiVec instructions.\n\n2. Added two new libjpeg API functions (`jpeg_skip_scanlines()` and\n`jpeg_crop_scanline()`) that can be used to partially decode a JPEG image.  See\n[libjpeg.txt](doc/libjpeg.txt) for more details.\n\n3. The TJCompressor and TJDecompressor classes in the TurboJPEG Java API now\nimplement the Closeable interface, so those classes can be used with a\ntry-with-resources statement.\n\n4. The TurboJPEG Java classes now throw unchecked idiomatic exceptions\n(IllegalArgumentException, IllegalStateException) for unrecoverable errors\ncaused by incorrect API usage, and those classes throw a new checked exception\ntype (TJException) for errors that are passed through from the C library.\n\n5. Source buffers for the TurboJPEG C API functions, as well as the\n`jpeg_mem_src()` function in the libjpeg API, are now declared as const\npointers.  This facilitates passing read-only buffers to those functions and\nensures the caller that the source buffer will not be modified.  This should\nnot create any backward API or ABI incompatibilities with prior libjpeg-turbo\nreleases.\n\n6. The MIPS DSPr2 SIMD code can now be compiled to support either FR=0 or FR=1\nFPUs.\n\n7. Fixed additional negative left shifts and other issues reported by the GCC\nand Clang undefined behavior sanitizers.  Most of these issues affected only\n32-bit code, and none of them was known to pose a security threat, but removing\nthe warnings makes it easier to detect actual security issues, should they\narise in the future.\n\n8. Removed the unnecessary `.arch` directive from the ARM64 NEON SIMD code.\nThis directive was preventing the code from assembling using the clang\nintegrated assembler.\n\n9. Fixed a regression caused by 1.4.1[6] that prevented 32-bit and 64-bit\nlibjpeg-turbo RPMs from being installed simultaneously on recent Red Hat/Fedora\ndistributions.  This was due to the addition of a macro in jconfig.h that\nallows the Huffman codec to determine the word size at compile time.  Since\nthat macro differs between 32-bit and 64-bit builds, this caused a conflict\nbetween the i386 and x86_64 RPMs (any differing files, other than executables,\nare not allowed when 32-bit and 64-bit RPMs are installed simultaneously.)\nSince the macro is used only internally, it has been moved into jconfigint.h.\n\n10. The x86-64 SIMD code can now be disabled at run time by setting the\n`JSIMD_FORCENONE` environment variable to `1` (the other SIMD implementations\nalready had this capability.)\n\n11. Added a new command-line argument to TJBench (`-nowrite`) that prevents the\nbenchmark from outputting any images.  This removes any potential operating\nsystem overhead that might be caused by lazy writes to disk and thus improves\nthe consistency of the performance measurements.\n\n12. Added SIMD acceleration for Huffman encoding on SSE2-capable x86 and x86-64\nplatforms.  This speeds up the compression of full-color JPEGs by about 10-15%\non average (relative to libjpeg-turbo 1.4.x) when using modern Intel and AMD\nCPUs.  Additionally, this works around an issue in the clang optimizer that\nprevents it (as of this writing) from achieving the same performance as GCC\nwhen compiling the C version of the Huffman encoder\n(<https://llvm.org/bugs/show_bug.cgi?id=16035>).  For the purposes of\nbenchmarking or regression testing, SIMD-accelerated Huffman encoding can be\ndisabled by setting the `JSIMD_NOHUFFENC` environment variable to `1`.\n\n13. Added ARM 64-bit (ARMv8) NEON SIMD implementations of the commonly-used\ncompression algorithms (including the accurate integer forward DCT and h2v2 &\nh2v1 downsampling algorithms, which are not accelerated in the 32-bit NEON\nimplementation.)  This speeds up the compression of full-color JPEGs by about\n75% on average on a Cavium ThunderX processor and by about 2-2.5x on average on\nCortex-A53 and Cortex-A57 cores.\n\n14. Added SIMD acceleration for Huffman encoding on NEON-capable ARM 32-bit\nand 64-bit platforms.\n\n    For 32-bit code, this speeds up the compression of full-color JPEGs by\nabout 30% on average on a typical iOS device (iPhone 4S, Cortex-A9) and by\nabout 6-7% on average on a typical Android device (Nexus 5X, Cortex-A53 and\nCortex-A57), relative to libjpeg-turbo 1.4.x.  Note that the larger speedup\nunder iOS is due to the fact that iOS builds use LLVM, which does not optimize\nthe C Huffman encoder as well as GCC does.\n\n    For 64-bit code, NEON-accelerated Huffman encoding speeds up the\ncompression of full-color JPEGs by about 40% on average on a typical iOS device\n(iPhone 5S, Apple A7) and by about 7-8% on average on a typical Android device\n(Nexus 5X, Cortex-A53 and Cortex-A57), in addition to the speedup described in\n[13] above.\n\n    For the purposes of benchmarking or regression testing, SIMD-accelerated\nHuffman encoding can be disabled by setting the `JSIMD_NOHUFFENC` environment\nvariable to `1`.\n\n15. pkg-config (.pc) scripts are now included for both the libjpeg and\nTurboJPEG API libraries on Un*x systems.  Note that if a project's build system\nrelies on these scripts, then it will not be possible to build that project\nwith libjpeg or with a prior version of libjpeg-turbo.\n\n16. Optimized the ARM 64-bit (ARMv8) NEON SIMD decompression routines to\nimprove performance on CPUs with in-order pipelines.  This speeds up the\ndecompression of full-color JPEGs by nearly 2x on average on a Cavium ThunderX\nprocessor and by about 15% on average on a Cortex-A53 core.\n\n17. Fixed an issue in the accelerated Huffman decoder that could have caused\nthe decoder to read past the end of the input buffer when a malformed,\nspecially-crafted JPEG image was being decompressed.  In prior versions of\nlibjpeg-turbo, the accelerated Huffman decoder was invoked (in most cases) only\nif there were > 128 bytes of data in the input buffer.  However, it is possible\nto construct a JPEG image in which a single Huffman block is over 430 bytes\nlong, so this version of libjpeg-turbo activates the accelerated Huffman\ndecoder only if there are > 512 bytes of data in the input buffer.\n\n18. Fixed a memory leak in tjunittest encountered when running the program\nwith the `-yuv` option.\n\n\n1.4.2\n=====\n\n### Significant changes relative to 1.4.1:\n\n1. Fixed an issue whereby cjpeg would segfault if a Windows bitmap with a\nnegative width or height was used as an input image (Windows bitmaps can have\na negative height if they are stored in top-down order, but such files are\nrare and not supported by libjpeg-turbo.)\n\n2. Fixed an issue whereby, under certain circumstances, libjpeg-turbo would\nincorrectly encode certain JPEG images when quality=100 and the fast integer\nforward DCT were used.  This was known to cause `make test` to fail when the\nlibrary was built with `-march=haswell` on x86 systems.\n\n3. Fixed an issue whereby libjpeg-turbo would crash when built with the latest\n& greatest development version of the Clang/LLVM compiler.  This was caused by\nan x86-64 ABI conformance issue in some of libjpeg-turbo's 64-bit SSE2 SIMD\nroutines.  Those routines were incorrectly using a 64-bit `mov` instruction to\ntransfer a 32-bit JDIMENSION argument, whereas the x86-64 ABI allows the upper\n(unused) 32 bits of a 32-bit argument's register to be undefined.  The new\nClang/LLVM optimizer uses load combining to transfer multiple adjacent 32-bit\nstructure members into a single 64-bit register, and this exposed the ABI\nconformance issue.\n\n4. Fixed a bug in the MIPS DSPr2 4:2:0 \"plain\" (non-fancy and non-merged)\nupsampling routine that caused a buffer overflow (and subsequent segfault) when\ndecompressing a 4:2:0 JPEG image whose scaled output width was less than 16\npixels.  The \"plain\" upsampling routines are normally only used when\ndecompressing a non-YCbCr JPEG image, but they are also used when decompressing\na JPEG image whose scaled output height is 1.\n\n5. Fixed various negative left shifts and other issues reported by the GCC and\nClang undefined behavior sanitizers.  None of these was known to pose a\nsecurity threat, but removing the warnings makes it easier to detect actual\nsecurity issues, should they arise in the future.\n\n\n1.4.1\n=====\n\n### Significant changes relative to 1.4.0:\n\n1. tjbench now properly handles CMYK/YCCK JPEG files.  Passing an argument of\n`-cmyk` (instead of, for instance, `-rgb`) will cause tjbench to internally\nconvert the source bitmap to CMYK prior to compression, to generate YCCK JPEG\nfiles, and to internally convert the decompressed CMYK pixels back to RGB after\ndecompression (the latter is done automatically if a CMYK or YCCK JPEG is\npassed to tjbench as a source image.)  The CMYK<->RGB conversion operation is\nnot benchmarked.  NOTE: The quick & dirty CMYK<->RGB conversions that tjbench\nuses are suitable for testing only.  Proper conversion between CMYK and RGB\nrequires a color management system.\n\n2. `make test` now performs additional bitwise regression tests using tjbench,\nmainly for the purpose of testing compression from/decompression to a subregion\nof a larger image buffer.\n\n3. `make test` no longer tests the regression of the floating point DCT/IDCT\nby default, since the results of those tests can vary if the algorithms in\nquestion are not implemented using SIMD instructions on a particular platform.\nSee the comments in [Makefile.am](Makefile.am) for information on how to\nre-enable the tests and to specify an expected result for them based on the\nparticulars of your platform.\n\n4. The NULL color conversion routines have been significantly optimized,\nwhich speeds up the compression of RGB and CMYK JPEGs by 5-20% when using\n64-bit code and 0-3% when using 32-bit code, and the decompression of those\nimages by 10-30% when using 64-bit code and 3-12% when using 32-bit code.\n\n5. Fixed an \"illegal instruction\" error that occurred when djpeg from a\nSIMD-enabled libjpeg-turbo MIPS build was executed with the `-nosmooth` option\non a MIPS machine that lacked DSPr2 support.  The MIPS SIMD routines for h2v1\nand h2v2 merged upsampling were not properly checking for the existence of\nDSPr2.\n\n6. Performance has been improved significantly on 64-bit non-Linux and\nnon-Windows platforms (generally 10-20% faster compression and 5-10% faster\ndecompression.)  Due to an oversight, the 64-bit version of the accelerated\nHuffman codec was not being compiled in when libjpeg-turbo was built on\nplatforms other than Windows or Linux.  Oops.\n\n7. Fixed an extremely rare bug in the Huffman encoder that caused 64-bit\nbuilds of libjpeg-turbo to incorrectly encode a few specific test images when\nquality=98, an optimized Huffman table, and the accurate integer forward DCT\nwere used.\n\n8. The Windows (CMake) build system now supports building only static or only\nshared libraries.  This is accomplished by adding either `-DENABLE_STATIC=0` or\n`-DENABLE_SHARED=0` to the CMake command line.\n\n9. TurboJPEG API functions will now return an error code if a warning is\ntriggered in the underlying libjpeg API.  For instance, if a JPEG file is\ncorrupt, the TurboJPEG decompression functions will attempt to decompress\nas much of the image as possible, but those functions will now return -1 to\nindicate that the decompression was not entirely successful.\n\n10. Fixed a bug in the MIPS DSPr2 4:2:2 fancy upsampling routine that caused a\nbuffer overflow (and subsequent segfault) when decompressing a 4:2:2 JPEG image\nin which the right-most MCU was 5 or 6 pixels wide.\n\n\n1.4.0\n=====\n\n### Significant changes relative to 1.4 beta1:\n\n1. Fixed a build issue on OS X PowerPC platforms (md5cmp failed to build\nbecause OS X does not provide the `le32toh()` and `htole32()` functions.)\n\n2. The non-SIMD RGB565 color conversion code did not work correctly on big\nendian machines.  This has been fixed.\n\n3. Fixed an issue in `tjPlaneSizeYUV()` whereby it would erroneously return 1\ninstead of -1 if `componentID` was > 0 and `subsamp` was `TJSAMP_GRAY`.\n\n3. Fixed an issue in `tjBufSizeYUV2()` whereby it would erroneously return 0\ninstead of -1 if `width` was < 1.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM64 platforms (see 1.4 beta1[5].)\n\n6. The `close()` method in the TJCompressor and TJDecompressor Java classes is\nnow idempotent.  Previously, that method would call the native `tjDestroy()`\nfunction even if the TurboJPEG instance had already been destroyed.  This\ncaused an exception to be thrown during finalization, if the `close()` method\nhad already been called.  The exception was caught, but it was still an\nexpensive operation.\n\n7. The TurboJPEG API previously generated an error (`Could not determine\nsubsampling type for JPEG image`) when attempting to decompress grayscale JPEG\nimages that were compressed with a sampling factor other than 1 (for instance,\nwith `cjpeg -grayscale -sample 2x2`).  Subsampling technically has no meaning\nwith grayscale JPEGs, and thus the horizontal and vertical sampling factors\nfor such images are ignored by the decompressor.  However, the TurboJPEG API\nwas being too rigid and was expecting the sampling factors to be equal to 1\nbefore it treated the image as a grayscale JPEG.\n\n8. cjpeg, djpeg, and jpegtran now accept an argument of `-version`, which will\nprint the library version and exit.\n\n9. Referring to 1.4 beta1[15], another extremely rare circumstance was\ndiscovered under which the Huffman encoder's local buffer can be overrun\nwhen a buffered destination manager is being used and an\nextremely-high-frequency block (basically junk image data) is being encoded.\nEven though the Huffman local buffer was increased from 128 bytes to 136 bytes\nto address the previous issue, the new issue caused even the larger buffer to\nbe overrun.  Further analysis reveals that, in the absolute worst case (such as\nsetting alternating AC coefficients to 32767 and -32768 in the JPEG scanning\norder), the Huffman encoder can produce encoded blocks that approach double the\nsize of the unencoded blocks.  Thus, the Huffman local buffer was increased to\n256 bytes, which should prevent any such issue from re-occurring in the future.\n\n10. The new `tjPlaneSizeYUV()`, `tjPlaneWidth()`, and `tjPlaneHeight()`\nfunctions were not actually usable on any platform except OS X and Windows,\nbecause those functions were not included in the libturbojpeg mapfile.  This\nhas been fixed.\n\n11. Restored the `JPP()`, `JMETHOD()`, and `FAR` macros in the libjpeg-turbo\nheader files.  The `JPP()` and `JMETHOD()` macros were originally implemented\nin libjpeg as a way of supporting non-ANSI compilers that lacked support for\nprototype parameters.  libjpeg-turbo has never supported such compilers, but\nsome software packages still use the macros to define their own prototypes.\nSimilarly, libjpeg-turbo has never supported MS-DOS and other platforms that\nhave far symbols, but some software packages still use the `FAR` macro.  A\npretty good argument can be made that this is a bad practice on the part of the\nsoftware in question, but since this affects more than one package, it's just\neasier to fix it here.\n\n12. Fixed issues that were preventing the ARM 64-bit SIMD code from compiling\nfor iOS, and included an ARMv8 architecture in all of the binaries installed by\nthe \"official\" libjpeg-turbo SDK for OS X.\n\n\n1.3.90 (1.4 beta1)\n==================\n\n### Significant changes relative to 1.3.1:\n\n1. New features in the TurboJPEG API:\n\n     - YUV planar images can now be generated with an arbitrary line padding\n(previously only 4-byte padding, which was compatible with X Video, was\nsupported.)\n     - The decompress-to-YUV function has been extended to support image\nscaling.\n     - JPEG images can now be compressed from YUV planar source images.\n     - YUV planar images can now be decoded into RGB or grayscale images.\n     - 4:1:1 subsampling is now supported.  This is mainly included for\ncompatibility, since 4:1:1 is not fully accelerated in libjpeg-turbo and has no\nsignificant advantages relative to 4:2:0.\n     - CMYK images are now supported.  This feature allows CMYK source images\nto be compressed to YCCK JPEGs and YCCK or CMYK JPEGs to be decompressed to\nCMYK destination images.  Conversion between CMYK/YCCK and RGB or YUV images is\nnot supported.  Such conversion requires a color management system and is thus\nout of scope for a codec library.\n     - The handling of YUV images in the Java API has been significantly\nrefactored and should now be much more intuitive.\n     - The Java API now supports encoding a YUV image from an arbitrary\nposition in a large image buffer.\n     - All of the YUV functions now have a corresponding function that operates\non separate image planes instead of a unified image buffer.  This allows for\ncompressing/decoding from or decompressing/encoding to a subregion of a larger\nYUV image.  It also allows for handling YUV formats that swap the order of the\nU and V planes.\n\n2. Added SIMD acceleration for DSPr2-capable MIPS platforms.  This speeds up\nthe compression of full-color JPEGs by 70-80% on such platforms and\ndecompression by 25-35%.\n\n3. If an application attempts to decompress a Huffman-coded JPEG image whose\nheader does not contain Huffman tables, libjpeg-turbo will now insert the\ndefault Huffman tables.  In order to save space, many motion JPEG video frames\nare encoded without the default Huffman tables, so these frames can now be\nsuccessfully decompressed by libjpeg-turbo without additional work on the part\nof the application.  An application can still override the Huffman tables, for\ninstance to re-use tables from a previous frame of the same video.\n\n4. The Mac packaging system now uses pkgbuild and productbuild rather than\nPackageMaker (which is obsolete and no longer supported.)  This means that\nOS X 10.6 \"Snow Leopard\" or later must be used when packaging libjpeg-turbo,\nalthough the packages produced can be installed on OS X 10.5 \"Leopard\" or\nlater.  OS X 10.4 \"Tiger\" is no longer supported.\n\n5. The Huffman encoder now uses `clz` and `bsr` instructions for bit counting\non ARM platforms rather than a lookup table.  This reduces the memory footprint\nby 64k, which may be important for some mobile applications.  Out of four\nAndroid devices that were tested, two demonstrated a small overall performance\nloss (~3-4% on average) with ARMv6 code and a small gain (also ~3-4%) with\nARMv7 code when enabling this new feature, but the other two devices\ndemonstrated a significant overall performance gain with both ARMv6 and ARMv7\ncode (~10-20%) when enabling the feature.  Actual mileage may vary.\n\n6. Worked around an issue with Visual C++ 2010 and later that caused incorrect\npixels to be generated when decompressing a JPEG image to a 256-color bitmap,\nif compiler optimization was enabled when libjpeg-turbo was built.  This caused\nthe regression tests to fail when doing a release build under Visual C++ 2010\nand later.\n\n7. Improved the accuracy and performance of the non-SIMD implementation of the\nfloating point inverse DCT (using code borrowed from libjpeg v8a and later.)\nThe accuracy of this implementation now matches the accuracy of the SSE/SSE2\nimplementation.  Note, however, that the floating point DCT/IDCT algorithms are\nmainly a legacy feature.  They generally do not produce significantly better\naccuracy than the accurate integer DCT/IDCT algorithms, and they are quite a\nbit slower.\n\n8. Added a new output colorspace (`JCS_RGB565`) to the libjpeg API that allows\nfor decompressing JPEG images into RGB565 (16-bit) pixels.  If dithering is not\nused, then this code path is SIMD-accelerated on ARM platforms.\n\n9. Numerous obsolete features, such as support for non-ANSI compilers and\nsupport for the MS-DOS memory model, were removed from the libjpeg code,\ngreatly improving its readability and making it easier to maintain and extend.\n\n10. Fixed a segfault that occurred when calling `output_message()` with\n`msg_code` set to `JMSG_COPYRIGHT`.\n\n11. Fixed an issue whereby wrjpgcom was allowing comments longer than 65k\ncharacters to be passed on the command line, which was causing it to generate\nincorrect JPEG files.\n\n12. Fixed a bug in the build system that was causing the Windows version of\nwrjpgcom to be built using the rdjpgcom source code.\n\n13. Restored 12-bit-per-component JPEG support.  A 12-bit version of\nlibjpeg-turbo can now be built by passing an argument of `--with-12bit` to\nconfigure (Unix) or `-DWITH_12BIT=1` to cmake (Windows.)  12-bit JPEG support\nis included only for convenience.  Enabling this feature disables all of the\nperformance features in libjpeg-turbo, as well as arithmetic coding and the\nTurboJPEG API.  The resulting library still contains the other libjpeg-turbo\nfeatures (such as the colorspace extensions), but in general, it performs no\nfaster than libjpeg v6b.\n\n14. Added ARM 64-bit SIMD acceleration for the YCC-to-RGB color conversion\nand IDCT algorithms (both are used during JPEG decompression.)  For\nreasons (probably related to clang), this code cannot currently be compiled for\niOS.\n\n15. Fixed an extremely rare bug (CVE-2014-9092) that could cause the Huffman\nencoder's local buffer to overrun when a very high-frequency MCU is compressed\nusing quality 100 and no subsampling, and when the JPEG output buffer is being\ndynamically resized by the destination manager.  This issue was so rare that,\neven with a test program specifically designed to make the bug occur (by\ninjecting random high-frequency YUV data into the compressor), it was\nreproducible only once in about every 25 million iterations.\n\n16. Fixed an oversight in the TurboJPEG C wrapper:  if any of the JPEG\ncompression functions was called repeatedly with the same\nautomatically-allocated destination buffer, then TurboJPEG would erroneously\nassume that the `jpegSize` parameter was equal to the size of the buffer, when\nin fact that parameter was probably equal to the size of the most recently\ncompressed JPEG image.  If the size of the previous JPEG image was not as large\nas the current JPEG image, then TurboJPEG would unnecessarily reallocate the\ndestination buffer.\n\n\n1.3.1\n=====\n\n### Significant changes relative to 1.3.0:\n\n1. On Un*x systems, `make install` now installs the libjpeg-turbo libraries\ninto /opt/libjpeg-turbo/lib32 by default on any 32-bit system, not just x86,\nand into /opt/libjpeg-turbo/lib64 by default on any 64-bit system, not just\nx86-64.  You can override this by overriding either the `prefix` or `libdir`\nconfigure variables.\n\n2. The Windows installer now places a copy of the TurboJPEG DLLs in the same\ndirectory as the rest of the libjpeg-turbo binaries.  This was mainly done\nto support TurboVNC 1.3, which bundles the DLLs in its Windows installation.\nWhen using a 32-bit version of CMake on 64-bit Windows, it is impossible to\naccess the c:\\WINDOWS\\system32 directory, which made it impossible for the\nTurboVNC build scripts to bundle the 64-bit TurboJPEG DLL.\n\n3. Fixed a bug whereby attempting to encode a progressive JPEG with arithmetic\nentropy coding (by passing arguments of `-progressive -arithmetic` to cjpeg or\njpegtran, for instance) would result in an error, `Requested feature was\nomitted at compile time`.\n\n4. Fixed a couple of issues (CVE-2013-6629 and CVE-2013-6630) whereby malformed\nJPEG images would cause libjpeg-turbo to use uninitialized memory during\ndecompression.\n\n5. Fixed an error (`Buffer passed to JPEG library is too small`) that occurred\nwhen calling the TurboJPEG YUV encoding function with a very small (< 5x5)\nsource image, and added a unit test to check for this error.\n\n6. The Java classes should now build properly under Visual Studio 2010 and\nlater.\n\n7. Fixed an issue that prevented SRPMs generated using the in-tree packaging\ntools from being rebuilt on certain newer Linux distributions.\n\n8. Numerous minor fixes to eliminate compilation and build/packaging system\nwarnings, fix cosmetic issues, improve documentation clarity, and other general\nsource cleanup.\n\n\n1.3.0\n=====\n\n### Significant changes relative to 1.3 beta1:\n\n1. `make test` now works properly on FreeBSD, and it no longer requires the\nmd5sum executable to be present on other Un*x platforms.\n\n2. Overhauled the packaging system:\n\n     - To avoid conflict with vendor-supplied libjpeg-turbo packages, the\nofficial RPMs and DEBs for libjpeg-turbo have been renamed to\n\"libjpeg-turbo-official\".\n     - The TurboJPEG libraries are now located under /opt/libjpeg-turbo in the\nofficial Linux and Mac packages, to avoid conflict with vendor-supplied\npackages and also to streamline the packaging system.\n     - Release packages are now created with the directory structure defined\nby the configure variables `prefix`, `bindir`, `libdir`, etc. (Un\\*x) or by the\n`CMAKE_INSTALL_PREFIX` variable (Windows.)  The exception is that the docs are\nalways located under the system default documentation directory on Un\\*x and\nMac systems, and on Windows, the TurboJPEG DLL is always located in the Windows\nsystem directory.\n     - To avoid confusion, official libjpeg-turbo packages on Linux/Unix\nplatforms (except for Mac) will always install the 32-bit libraries in\n/opt/libjpeg-turbo/lib32 and the 64-bit libraries in /opt/libjpeg-turbo/lib64.\n     - Fixed an issue whereby, in some cases, the libjpeg-turbo executables on\nUn*x systems were not properly linking with the shared libraries installed by\nthe same package.\n     - Fixed an issue whereby building the \"installer\" target on Windows when\n`WITH_JAVA=1` would fail if the TurboJPEG JAR had not been previously built.\n     - Building the \"install\" target on Windows now installs files into the\nsame places that the installer does.\n\n3. Fixed a Huffman encoder bug that prevented I/O suspension from working\nproperly.\n\n\n1.2.90 (1.3 beta1)\n==================\n\n### Significant changes relative to 1.2.1:\n\n1. Added support for additional scaling factors (3/8, 5/8, 3/4, 7/8, 9/8, 5/4,\n11/8, 3/2, 13/8, 7/4, 15/8, and 2) when decompressing.  Note that the IDCT will\nnot be SIMD-accelerated when using any of these new scaling factors.\n\n2. The TurboJPEG dynamic library is now versioned.  It was not strictly\nnecessary to do so, because TurboJPEG uses versioned symbols, and if a function\nchanges in an ABI-incompatible way, that function is renamed and a legacy\nfunction is provided to maintain backward compatibility.  However, certain\nLinux distro maintainers have a policy against accepting any library that isn't\nversioned.\n\n3. Extended the TurboJPEG Java API so that it can be used to compress a JPEG\nimage from and decompress a JPEG image to an arbitrary position in a large\nimage buffer.\n\n4. The `tjDecompressToYUV()` function now supports the `TJFLAG_FASTDCT` flag.\n\n5. The 32-bit supplementary package for amd64 Debian systems now provides\nsymlinks in /usr/lib/i386-linux-gnu for the TurboJPEG libraries in /usr/lib32.\nThis allows those libraries to be used on MultiArch-compatible systems (such as\nUbuntu 11 and later) without setting the linker path.\n\n6. The TurboJPEG Java wrapper should now find the JNI library on Mac systems\nwithout having to pass `-Djava.library.path=/usr/lib` to java.\n\n7. TJBench has been ported to Java to provide a convenient way of validating\nthe performance of the TurboJPEG Java API.  It can be run with\n`java -cp turbojpeg.jar TJBench`.\n\n8. cjpeg can now be used to generate JPEG files with the RGB colorspace\n(feature ported from jpeg-8d.)\n\n9. The width and height in the `-crop` argument passed to jpegtran can now be\nsuffixed with `f` to indicate that, when the upper left corner of the cropping\nregion is automatically moved to the nearest iMCU boundary, the bottom right\ncorner should be moved by the same amount.  In other words, this feature causes\njpegtran to strictly honor the specified width/height rather than the specified\nbottom right corner (feature ported from jpeg-8d.)\n\n10. JPEG files using the RGB colorspace can now be decompressed into grayscale\nimages (feature ported from jpeg-8d.)\n\n11. Fixed a regression caused by 1.2.1[7] whereby the build would fail with\nmultiple \"Mismatch in operand sizes\" errors when attempting to build the x86\nSIMD code with NASM 0.98.\n\n12. The in-memory source/destination managers (`jpeg_mem_src()` and\n`jpeg_mem_dest()`) are now included by default when building libjpeg-turbo with\nlibjpeg v6b or v7 emulation, so that programs can take advantage of these\nfunctions without requiring the use of the backward-incompatible libjpeg v8\nABI.  The \"age number\" of the libjpeg-turbo library on Un*x systems has been\nincremented by 1 to reflect this.  You can disable this feature with a\nconfigure/CMake switch in order to retain strict API/ABI compatibility with the\nlibjpeg v6b or v7 API/ABI (or with previous versions of libjpeg-turbo.)  See\n[README.md](README.md) for more details.\n\n13. Added ARMv7s architecture to libjpeg.a and libturbojpeg.a in the official\nlibjpeg-turbo binary package for OS X, so that those libraries can be used to\nbuild applications that leverage the faster CPUs in the iPhone 5 and iPad 4.\n\n\n1.2.1\n=====\n\n### Significant changes relative to 1.2.0:\n\n1. Creating or decoding a JPEG file that uses the RGB colorspace should now\nproperly work when the input or output colorspace is one of the libjpeg-turbo\ncolorspace extensions.\n\n2. When libjpeg-turbo was built without SIMD support and merged (non-fancy)\nupsampling was used along with an alpha-enabled colorspace during\ndecompression, the unused byte of the decompressed pixels was not being set to\n0xFF.  This has been fixed.  TJUnitTest has also been extended to test for the\ncorrect behavior of the colorspace extensions when merged upsampling is used.\n\n3. Fixed a bug whereby the libjpeg-turbo SSE2 SIMD code would not preserve the\nupper 64 bits of xmm6 and xmm7 on Win64 platforms, which violated the Win64\ncalling conventions.\n\n4. Fixed a regression (CVE-2012-2806) caused by 1.2.0[6] whereby decompressing\ncorrupt JPEG images (specifically, images in which the component count was\nerroneously set to a large value) would cause libjpeg-turbo to segfault.\n\n5. Worked around a severe performance issue with \"Bobcat\" (AMD Embedded APU)\nprocessors.  The `MASKMOVDQU` instruction, which was used by the libjpeg-turbo\nSSE2 SIMD code, is apparently implemented in microcode on AMD processors, and\nit is painfully slow on Bobcat processors in particular.  Eliminating the use\nof this instruction improved performance by an order of magnitude on Bobcat\nprocessors and by a small amount (typically 5%) on AMD desktop processors.\n\n6. Added SIMD acceleration for performing 4:2:2 upsampling on NEON-capable ARM\nplatforms.  This speeds up the decompression of 4:2:2 JPEGs by 20-25% on such\nplatforms.\n\n7. Fixed a regression caused by 1.2.0[2] whereby, on Linux/x86 platforms\nrunning the 32-bit SSE2 SIMD code in libjpeg-turbo, decompressing a 4:2:0 or\n4:2:2 JPEG image into a 32-bit (RGBX, BGRX, etc.) buffer without using fancy\nupsampling would produce several incorrect columns of pixels at the right-hand\nside of the output image if each row in the output image was not evenly\ndivisible by 16 bytes.\n\n8. Fixed an issue whereby attempting to build the SIMD extensions with Xcode\n4.3 on OS X platforms would cause NASM to return numerous errors of the form\n\"'%define' expects a macro identifier\".\n\n9. Added flags to the TurboJPEG API that allow the caller to force the use of\neither the fast or the accurate DCT/IDCT algorithms in the underlying codec.\n\n\n1.2.0\n=====\n\n### Significant changes relative to 1.2 beta1:\n\n1. Fixed build issue with Yasm on Unix systems (the libjpeg-turbo build system\nwas not adding the current directory to the assembler include path, so Yasm\nwas not able to find jsimdcfg.inc.)\n\n2. Fixed out-of-bounds read in SSE2 SIMD code that occurred when decompressing\na JPEG image to a bitmap buffer whose size was not a multiple of 16 bytes.\nThis was more of an annoyance than an actual bug, since it did not cause any\nactual run-time problems, but the issue showed up when running libjpeg-turbo in\nvalgrind.  See <http://crbug.com/72399> for more information.\n\n3. Added a compile-time macro (`LIBJPEG_TURBO_VERSION`) that can be used to\ncheck the version of libjpeg-turbo against which an application was compiled.\n\n4. Added new RGBA/BGRA/ABGR/ARGB colorspace extension constants (libjpeg API)\nand pixel formats (TurboJPEG API), which allow applications to specify that,\nwhen decompressing to a 4-component RGB buffer, the unused byte should be set\nto 0xFF so that it can be interpreted as an opaque alpha channel.\n\n5. Fixed regression issue whereby DevIL failed to build against libjpeg-turbo\nbecause libjpeg-turbo's distributed version of jconfig.h contained an `INLINE`\nmacro, which conflicted with a similar macro in DevIL.  This macro is used only\ninternally when building libjpeg-turbo, so it was moved into config.h.\n\n6. libjpeg-turbo will now correctly decompress erroneous CMYK/YCCK JPEGs whose\nK component is assigned a component ID of 1 instead of 4.  Although these files\nare in violation of the spec, other JPEG implementations handle them\ncorrectly.\n\n7. Added ARMv6 and ARMv7 architectures to libjpeg.a and libturbojpeg.a in\nthe official libjpeg-turbo binary package for OS X, so that those libraries can\nbe used to build both OS X and iOS applications.\n\n\n1.1.90 (1.2 beta1)\n==================\n\n### Significant changes relative to 1.1.1:\n\n1. Added a Java wrapper for the TurboJPEG API.  See [java/README](java/README)\nfor more details.\n\n2. The TurboJPEG API can now be used to scale down images during\ndecompression.\n\n3. Added SIMD routines for RGB-to-grayscale color conversion, which\nsignificantly improves the performance of grayscale JPEG compression from an\nRGB source image.\n\n4. Improved the performance of the C color conversion routines, which are used\non platforms for which SIMD acceleration is not available.\n\n5. Added a function to the TurboJPEG API that performs lossless transforms.\nThis function is implemented using the same back end as jpegtran, but it\nperforms transcoding entirely in memory and allows multiple transforms and/or\ncrop operations to be batched together, so the source coefficients only need to\nbe read once.  This is useful when generating image tiles from a single source\nJPEG.\n\n6. Added tests for the new TurboJPEG scaled decompression and lossless\ntransform features to tjbench (the TurboJPEG benchmark, formerly called\n\"jpgtest\".)\n\n7. Added support for 4:4:0 (transposed 4:2:2) subsampling in TurboJPEG, which\nwas necessary in order for it to read 4:2:2 JPEG files that had been losslessly\ntransposed or rotated 90 degrees.\n\n8. All legacy VirtualGL code has been re-factored, and this has allowed\nlibjpeg-turbo, in its entirety, to be re-licensed under a BSD-style license.\n\n9. libjpeg-turbo can now be built with Yasm.\n\n10. Added SIMD acceleration for ARM Linux and iOS platforms that support\nNEON instructions.\n\n11. Refactored the TurboJPEG C API and documented it using Doxygen.  The\nTurboJPEG 1.2 API uses pixel formats to define the size and component order of\nthe uncompressed source/destination images, and it includes a more efficient\nversion of `TJBUFSIZE()` that computes a worst-case JPEG size based on the\nlevel of chrominance subsampling.  The refactored implementation of the\nTurboJPEG API now uses the libjpeg memory source and destination managers,\nwhich allows the TurboJPEG compressor to grow the JPEG buffer as necessary.\n\n12. Eliminated errors in the output of jpegtran on Windows that occurred when\nthe application was invoked using I/O redirection\n(`jpegtran <input.jpg >output.jpg`.)\n\n13. The inclusion of libjpeg v7 and v8 emulation as well as arithmetic coding\nsupport in libjpeg-turbo v1.1.0 introduced several new error constants in\njerror.h, and these were mistakenly enabled for all emulation modes, causing\nthe error enum in libjpeg-turbo to sometimes have different values than the\nsame enum in libjpeg.  This represents an ABI incompatibility, and it caused\nproblems with rare applications that took specific action based on a particular\nerror value.  The fix was to include the new error constants conditionally\nbased on whether libjpeg v7 or v8 emulation was enabled.\n\n14. Fixed an issue whereby Windows applications that used libjpeg-turbo would\nfail to compile if the Windows system headers were included before jpeglib.h.\nThis issue was caused by a conflict in the definition of the INT32 type.\n\n15. Fixed 32-bit supplementary package for amd64 Debian systems, which was\nbroken by enhancements to the packaging system in 1.1.\n\n16. When decompressing a JPEG image using an output colorspace of\n`JCS_EXT_RGBX`, `JCS_EXT_BGRX`, `JCS_EXT_XBGR`, or `JCS_EXT_XRGB`,\nlibjpeg-turbo will now set the unused byte to 0xFF, which allows applications\nto interpret that byte as an alpha channel (0xFF = opaque).\n\n\n1.1.1\n=====\n\n### Significant changes relative to 1.1.0:\n\n1. Fixed a 1-pixel error in row 0, column 21 of the luminance plane generated\nby `tjEncodeYUV()`.\n\n2. libjpeg-turbo's accelerated Huffman decoder previously ignored unexpected\nmarkers found in the middle of the JPEG data stream during decompression.  It\nwill now hand off decoding of a particular block to the unaccelerated Huffman\ndecoder if an unexpected marker is found, so that the unaccelerated Huffman\ndecoder can generate an appropriate warning.\n\n3. Older versions of MinGW64 prefixed symbol names with underscores by\ndefault, which differed from the behavior of 64-bit Visual C++.  MinGW64 1.0\nhas adopted the behavior of 64-bit Visual C++ as the default, so to accommodate\nthis, the libjpeg-turbo SIMD function names are no longer prefixed with an\nunderscore when building with MinGW64.  This means that, when building\nlibjpeg-turbo with older versions of MinGW64, you will now have to add\n`-fno-leading-underscore` to the `CFLAGS`.\n\n4. Fixed a regression bug in the NSIS script that caused the Windows installer\nbuild to fail when using the Visual Studio IDE.\n\n5. Fixed a bug in `jpeg_read_coefficients()` whereby it would not initialize\n`cinfo->image_width` and `cinfo->image_height` if libjpeg v7 or v8 emulation\nwas enabled.  This specifically caused the jpegoptim program to fail if it was\nlinked against a version of libjpeg-turbo that was built with libjpeg v7 or v8\nemulation.\n\n6. Eliminated excessive I/O overhead that occurred when reading BMP files in\ncjpeg.\n\n7. Eliminated errors in the output of cjpeg on Windows that occurred when the\napplication was invoked using I/O redirection (`cjpeg <inputfile >output.jpg`.)\n\n\n1.1.0\n=====\n\n### Significant changes relative to 1.1 beta1:\n\n1. The algorithm used by the SIMD quantization function cannot produce correct\nresults when the JPEG quality is >= 98 and the fast integer forward DCT is\nused.  Thus, the non-SIMD quantization function is now used for those cases,\nand libjpeg-turbo should now produce identical output to libjpeg v6b in all\ncases.\n\n2. Despite the above, the fast integer forward DCT still degrades somewhat for\nJPEG qualities greater than 95, so the TurboJPEG wrapper will now automatically\nuse the accurate integer forward DCT when generating JPEG images of quality 96\nor greater.  This reduces compression performance by as much as 15% for these\nhigh-quality images but is necessary to ensure that the images are perceptually\nlossless.  It also ensures that the library can avoid the performance pitfall\ncreated by [1].\n\n3. Ported jpgtest.cxx to pure C to avoid the need for a C++ compiler.\n\n4. Fixed visual artifacts in grayscale JPEG compression caused by a typo in\nthe RGB-to-luminance lookup tables.\n\n5. The Windows distribution packages now include the libjpeg run-time programs\n(cjpeg, etc.)\n\n6. All packages now include jpgtest.\n\n7. The TurboJPEG dynamic library now uses versioned symbols.\n\n8. Added two new TurboJPEG API functions, `tjEncodeYUV()` and\n`tjDecompressToYUV()`, to replace the somewhat hackish `TJ_YUV` flag.\n\n\n1.0.90 (1.1 beta1)\n==================\n\n### Significant changes relative to 1.0.1:\n\n1. Added emulation of the libjpeg v7 and v8 APIs and ABIs.  See\n[README.md](README.md) for more details.  This feature was sponsored by\nCamTrace SAS.\n\n2. Created a new CMake-based build system for the Visual C++ and MinGW builds.\n\n3. Grayscale bitmaps can now be compressed from/decompressed to using the\nTurboJPEG API.\n\n4. jpgtest can now be used to test decompression performance with existing\nJPEG images.\n\n5. If the default install prefix (/opt/libjpeg-turbo) is used, then\n`make install` now creates /opt/libjpeg-turbo/lib32 and\n/opt/libjpeg-turbo/lib64 sym links to duplicate the behavior of the binary\npackages.\n\n6. All symbols in the libjpeg-turbo dynamic library are now versioned, even\nwhen the library is built with libjpeg v6b emulation.\n\n7. Added arithmetic encoding and decoding support (can be disabled with\nconfigure or CMake options)\n\n8. Added a `TJ_YUV` flag to the TurboJPEG API, which causes both the compressor\nand decompressor to output planar YUV images.\n\n9. Added an extended version of `tjDecompressHeader()` to the TurboJPEG API,\nwhich allows the caller to determine the type of subsampling used in a JPEG\nimage.\n\n10. Added further protections against invalid Huffman codes.\n\n\n1.0.1\n=====\n\n### Significant changes relative to 1.0.0:\n\n1. The Huffman decoder will now handle erroneous Huffman codes (for instance,\nfrom a corrupt JPEG image.)  Previously, these would cause libjpeg-turbo to\ncrash under certain circumstances.\n\n2. Fixed typo in SIMD dispatch routines that was causing 4:2:2 upsampling to\nbe used instead of 4:2:0 when decompressing JPEG images using SSE2 code.\n\n3. The configure script will now automatically determine whether the\n`INCOMPLETE_TYPES_BROKEN` macro should be defined.\n\n\n1.0.0\n=====\n\n### Significant changes relative to 0.0.93:\n\n1. 2983700: Further FreeBSD build tweaks (no longer necessary to specify\n`--host` when configuring on a 64-bit system)\n\n2. Created symlinks in the Unix/Linux packages so that the TurboJPEG\ninclude file can always be found in /opt/libjpeg-turbo/include, the 32-bit\nstatic libraries can always be found in /opt/libjpeg-turbo/lib32, and the\n64-bit static libraries can always be found in /opt/libjpeg-turbo/lib64.\n\n3. The Unix/Linux distribution packages now include the libjpeg run-time\nprograms (cjpeg, etc.) and man pages.\n\n4. Created a 32-bit supplementary package for amd64 Debian systems, which\ncontains just the 32-bit libjpeg-turbo libraries.\n\n5. Moved the libraries from */lib32 to */lib in the i386 Debian package.\n\n6. Include distribution package for Cygwin\n\n7. No longer necessary to specify `--without-simd` on non-x86 architectures,\nand unit tests now work on those architectures.\n\n\n0.0.93\n======\n\n### Significant changes relative to 0.0.91:\n\n1. 2982659: Fixed x86-64 build on FreeBSD systems\n\n2. 2988188: Added support for Windows 64-bit systems\n\n\n0.0.91\n======\n\n### Significant changes relative to 0.0.90:\n\n1. Added documentation to .deb packages\n\n2. 2968313: Fixed data corruption issues when decompressing large JPEG images\nand/or using buffered I/O with the libjpeg-turbo decompressor\n\n\n0.0.90\n======\n\nInitial release\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 5.48828125,
          "content": "libjpeg-turbo Licenses\n======================\n\nlibjpeg-turbo is covered by two compatible BSD-style open source licenses:\n\n- The IJG (Independent JPEG Group) License, which is listed in\n  [README.ijg](README.ijg)\n\n  This license applies to the libjpeg API library and associated programs,\n  including any code inherited from libjpeg and any modifications to that\n  code.  Note that the libjpeg-turbo SIMD source code bears the\n  [zlib License](https://opensource.org/licenses/Zlib), but in the context of\n  the overall libjpeg API library, the terms of the zlib License are subsumed\n  by the terms of the IJG License.\n\n- The Modified (3-clause) BSD License, which is listed below\n\n  This license applies to the TurboJPEG API library and associated programs, as\n  well as the build system.  Note that the TurboJPEG API library wraps the\n  libjpeg API library, so in the context of the overall TurboJPEG API library,\n  both the terms of the IJG License and the terms of the Modified (3-clause)\n  BSD License apply.\n\n\nComplying with the libjpeg-turbo Licenses\n=========================================\n\nThis section provides a roll-up of the libjpeg-turbo licensing terms, to the\nbest of our understanding.  This is not a license in and of itself.  It is\nintended solely for clarification.\n\n1.  If you are distributing a modified version of the libjpeg-turbo source,\n    then:\n\n    1.  You cannot alter or remove any existing copyright or license notices\n        from the source.\n\n        **Origin**\n        - Clause 1 of the IJG License\n        - Clause 1 of the Modified BSD License\n        - Clauses 1 and 3 of the zlib License\n\n    2.  You must add your own copyright notice to the header of each source\n        file you modified, so others can tell that you modified that file.  (If\n        there is not an existing copyright header in that file, then you can\n        simply add a notice stating that you modified the file.)\n\n        **Origin**\n        - Clause 1 of the IJG License\n        - Clause 2 of the zlib License\n\n    3.  You must include the IJG README file, and you must not alter any of the\n        copyright or license text in that file.\n\n        **Origin**\n        - Clause 1 of the IJG License\n\n2.  If you are distributing only libjpeg-turbo binaries without the source, or\n    if you are distributing an application that statically links with\n    libjpeg-turbo, then:\n\n    1.  Your product documentation must include a message stating:\n\n        This software is based in part on the work of the Independent JPEG\n        Group.\n\n        **Origin**\n        - Clause 2 of the IJG license\n\n    2.  If your binary distribution includes or uses the TurboJPEG API, then\n        your product documentation must include the text of the Modified BSD\n        License (see below.)\n\n        **Origin**\n        - Clause 2 of the Modified BSD License\n\n3.  You cannot use the name of the IJG or The libjpeg-turbo Project or the\n    contributors thereof in advertising, publicity, etc.\n\n    **Origin**\n    - IJG License\n    - Clause 3 of the Modified BSD License\n\n4.  The IJG and The libjpeg-turbo Project do not warrant libjpeg-turbo to be\n    free of defects, nor do we accept any liability for undesirable\n    consequences resulting from your use of the software.\n\n    **Origin**\n    - IJG License\n    - Modified BSD License\n    - zlib License\n\n\nThe Modified (3-clause) BSD License\n===================================\n\nCopyright (C)2009-2024 D. R. Commander.  All Rights Reserved.<br>\nCopyright (C)2015 Viktor Szathmry.  All Rights Reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n- Neither the name of the libjpeg-turbo Project nor the names of its\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\",\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\n\nWhy Two Licenses?\n=================\n\nThe zlib License could have been used instead of the Modified (3-clause) BSD\nLicense, and since the IJG License effectively subsumes the distribution\nconditions of the zlib License, this would have effectively placed\nlibjpeg-turbo binary distributions under the IJG License.  However, the IJG\nLicense specifically refers to the Independent JPEG Group and does not extend\nattribution and endorsement protections to other entities.  Thus, it was\ndesirable to choose a license that granted us the same protections for new code\nthat were granted to the IJG for code derived from their software.\n"
        },
        {
          "name": "README.ijg",
          "type": "blob",
          "size": 12.4990234375,
          "content": "libjpeg-turbo note:  This file has been modified by The libjpeg-turbo Project\nto include only information relevant to libjpeg-turbo, to wordsmith certain\nsections, and to remove impolitic language that existed in the libjpeg v8\nREADME.  It is included only for reference.  Please see README.md for\ninformation specific to libjpeg-turbo.\n\n\nThe Independent JPEG Group's JPEG software\n==========================================\n\nThis distribution contains a release of the Independent JPEG Group's free JPEG\nsoftware.  You are welcome to redistribute this software and to use it for any\npurpose, subject to the conditions under LEGAL ISSUES, below.\n\nThis software is the work of Tom Lane, Guido Vollbeding, Philip Gladstone,\nBill Allombert, Jim Boucher, Lee Crocker, Bob Friesenhahn, Ben Jackson,\nJulian Minguillon, Luis Ortiz, George Phillips, Davide Rossi, Ge' Weijers,\nand other members of the Independent JPEG Group.\n\nIJG is not affiliated with the ISO/IEC JTC1/SC29/WG1 standards committee\n(also known as JPEG, together with ITU-T SG16).\n\n\nDOCUMENTATION ROADMAP\n=====================\n\nThis file contains the following sections:\n\nOVERVIEW            General description of JPEG and the IJG software.\nLEGAL ISSUES        Copyright, lack of warranty, terms of distribution.\nREFERENCES          Where to learn more about JPEG.\nARCHIVE LOCATIONS   Where to find newer versions of this software.\nFILE FORMAT WARS    Software *not* to get.\nTO DO               Plans for future IJG releases.\n\nOther documentation files in the distribution are:\n\nUser documentation:\n  doc/usage.txt         Usage instructions for cjpeg, djpeg, jpegtran,\n                        rdjpgcom, and wrjpgcom.\n  doc/*.1               Unix-style man pages for programs (same info as\n                        usage.txt).\n  doc/wizard.txt        Advanced usage instructions for JPEG wizards only.\n  doc/change.log        Version-to-version change highlights.\nProgrammer and internal documentation:\n  doc/libjpeg.txt       How to use the JPEG library in your own programs.\n  src/example.c         Sample code for calling the JPEG library.\n  doc/structure.txt     Overview of the JPEG library's internal structure.\n  doc/coderules.txt     Coding style rules --- please read if you contribute\n                        code.\n\nPlease read at least usage.txt.  Some information can also be found in the JPEG\nFAQ (Frequently Asked Questions) article.  See ARCHIVE LOCATIONS below to find\nout where to obtain the FAQ article.\n\nIf you want to understand how the JPEG code works, we suggest reading one or\nmore of the REFERENCES, then looking at the documentation files (in roughly\nthe order listed) before diving into the code.\n\n\nOVERVIEW\n========\n\nThis package contains C software to implement JPEG image encoding, decoding,\nand transcoding.  JPEG (pronounced \"jay-peg\") is a standardized compression\nmethod for full-color and grayscale images.  JPEG's strong suit is compressing\nphotographic images or other types of images that have smooth color and\nbrightness transitions between neighboring pixels.  Images with sharp lines or\nother abrupt features may not compress well with JPEG, and a higher JPEG\nquality may have to be used to avoid visible compression artifacts with such\nimages.\n\nJPEG is normally lossy, meaning that the output pixels are not necessarily\nidentical to the input pixels.  However, on photographic content and other\n\"smooth\" images, very good compression ratios can be obtained with no visible\ncompression artifacts, and extremely high compression ratios are possible if\nyou are willing to sacrifice image quality (by reducing the \"quality\" setting\nin the compressor.)\n\nThis software implements JPEG baseline, extended-sequential, progressive, and\nlossless compression processes.  Provision is made for supporting all variants\nof these processes, although some uncommon parameter settings aren't\nimplemented yet.  We have made no provision for supporting the hierarchical\nprocesses defined in the standard.\n\nWe provide a set of library routines for reading and writing JPEG image files,\nplus two sample applications \"cjpeg\" and \"djpeg\", which use the library to\nperform conversion between JPEG and some other popular image file formats.\nThe library is intended to be reused in other applications.\n\nIn order to support file conversion and viewing software, we have included\nconsiderable functionality beyond the bare JPEG coding/decoding capability;\nfor example, the color quantization modules are not strictly part of JPEG\ndecoding, but they are essential for output to colormapped file formats.  These\nextra functions can be compiled out of the library if not required for a\nparticular application.\n\nWe have also included \"jpegtran\", a utility for lossless transcoding between\ndifferent JPEG processes, and \"rdjpgcom\" and \"wrjpgcom\", two simple\napplications for inserting and extracting textual comments in JFIF files.\n\nThe emphasis in designing this software has been on achieving portability and\nflexibility, while also making it fast enough to be useful.  In particular,\nthe software is not intended to be read as a tutorial on JPEG.  (See the\nREFERENCES section for introductory material.)  Rather, it is intended to\nbe reliable, portable, industrial-strength code.  We do not claim to have\nachieved that goal in every aspect of the software, but we strive for it.\n\nWe welcome the use of this software as a component of commercial products.\nNo royalty is required, but we do ask for an acknowledgement in product\ndocumentation, as described under LEGAL ISSUES.\n\n\nLEGAL ISSUES\n============\n\nIn plain English:\n\n1. We don't promise that this software works.  (But if you find any bugs,\n   please let us know!)\n2. You can use this software for whatever you want.  You don't have to pay us.\n3. You may not pretend that you wrote this software.  If you use it in a\n   program, you must acknowledge somewhere in your documentation that\n   you've used the IJG code.\n\nIn legalese:\n\nThe authors make NO WARRANTY or representation, either express or implied,\nwith respect to this software, its quality, accuracy, merchantability, or\nfitness for a particular purpose.  This software is provided \"AS IS\", and you,\nits user, assume the entire risk as to its quality and accuracy.\n\nThis software is copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\nAll Rights Reserved except as specified below.\n\nPermission is hereby granted to use, copy, modify, and distribute this\nsoftware (or portions thereof) for any purpose, without fee, subject to these\nconditions:\n(1) If any part of the source code for this software is distributed, then this\nREADME file must be included, with this copyright and no-warranty notice\nunaltered; and any additions, deletions, or changes to the original files\nmust be clearly indicated in accompanying documentation.\n(2) If only executable code is distributed, then the accompanying\ndocumentation must state that \"this software is based in part on the work of\nthe Independent JPEG Group\".\n(3) Permission for use of this software is granted only if the user accepts\nfull responsibility for any undesirable consequences; the authors accept\nNO LIABILITY for damages of any kind.\n\nThese conditions apply to any software derived from or based on the IJG code,\nnot just to the unmodified library.  If you use our work, you ought to\nacknowledge us.\n\nPermission is NOT granted for the use of any IJG author's name or company name\nin advertising or publicity relating to this software or products derived from\nit.  This software may be referred to only as \"the Independent JPEG Group's\nsoftware\".\n\nWe specifically permit and encourage the use of this software as the basis of\ncommercial products, provided that all warranty or liability claims are\nassumed by the product vendor.\n\n\nREFERENCES\n==========\n\nWe recommend reading one or more of these references before trying to\nunderstand the innards of the JPEG software.\n\nThe best short technical introduction to the JPEG compression algorithm is\n        Wallace, Gregory K.  \"The JPEG Still Picture Compression Standard\",\n        Communications of the ACM, April 1991 (vol. 34 no. 4), pp. 30-44.\n(Adjacent articles in that issue discuss MPEG motion picture compression,\napplications of JPEG, and related topics.)  If you don't have the CACM issue\nhandy, a PDF file containing a revised version of Wallace's article is\navailable at http://www.ijg.org/files/Wallace.JPEG.pdf.  The file (actually\na preprint for an article that appeared in IEEE Trans. Consumer Electronics)\nomits the sample images that appeared in CACM, but it includes corrections\nand some added material.  Note: the Wallace article is copyright ACM and IEEE,\nand it may not be used for commercial purposes.\n\nA somewhat less technical, more leisurely introduction to JPEG can be found in\n\"The Data Compression Book\" by Mark Nelson and Jean-loup Gailly, published by\nM&T Books (New York), 2nd ed. 1996, ISBN 1-55851-434-1.  This book provides\ngood explanations and example C code for a multitude of compression methods\nincluding JPEG.  It is an excellent source if you are comfortable reading C\ncode but don't know much about data compression in general.  The book's JPEG\nsample code is far from industrial-strength, but when you are ready to look\nat a full implementation, you've got one here...\n\nThe best currently available description of JPEG is the textbook \"JPEG Still\nImage Data Compression Standard\" by William B. Pennebaker and Joan L.\nMitchell, published by Van Nostrand Reinhold, 1993, ISBN 0-442-01272-1.\nPrice US$59.95, 638 pp.  The book includes the complete text of the ISO JPEG\nstandards (DIS 10918-1 and draft DIS 10918-2).\n\nThe original JPEG standard is divided into two parts, Part 1 being the actual\nspecification, while Part 2 covers compliance testing methods.  Part 1 is\ntitled \"Digital Compression and Coding of Continuous-tone Still Images,\nPart 1: Requirements and guidelines\" and has document numbers ISO/IEC IS\n10918-1, ITU-T T.81.  Part 2 is titled \"Digital Compression and Coding of\nContinuous-tone Still Images, Part 2: Compliance testing\" and has document\nnumbers ISO/IEC IS 10918-2, ITU-T T.83.\n\nThe JPEG standard does not specify all details of an interchangeable file\nformat.  For the omitted details, we follow the \"JFIF\" conventions, revision\n1.02.  JFIF version 1 has been adopted as ISO/IEC 10918-5 (05/2013) and\nRecommendation ITU-T T.871 (05/2011): Information technology - Digital\ncompression and coding of continuous-tone still images: JPEG File Interchange\nFormat (JFIF).  It is available as a free download in PDF file format from\nhttps://www.iso.org/standard/54989.html and http://www.itu.int/rec/T-REC-T.871.\nA PDF file of the older JFIF 1.02 specification is available at\nhttp://www.w3.org/Graphics/JPEG/jfif3.pdf.\n\nThe TIFF 6.0 file format specification can be obtained from\nhttp://mirrors.ctan.org/graphics/tiff/TIFF6.ps.gz.  The JPEG incorporation\nscheme found in the TIFF 6.0 spec of 3-June-92 has a number of serious\nproblems.  IJG does not recommend use of the TIFF 6.0 design (TIFF Compression\ntag 6).  Instead, we recommend the JPEG design proposed by TIFF Technical Note\n#2 (Compression tag 7).  Copies of this Note can be obtained from\nhttp://www.ijg.org/files/.  It is expected that the next revision\nof the TIFF spec will replace the 6.0 JPEG design with the Note's design.\nAlthough IJG's own code does not support TIFF/JPEG, the free libtiff library\nuses our library to implement TIFF/JPEG per the Note.\n\n\nARCHIVE LOCATIONS\n=================\n\nThe \"official\" archive site for this software is www.ijg.org.\nThe most recent released version can always be found there in\ndirectory \"files\".\n\nThe JPEG FAQ (Frequently Asked Questions) article is a source of some\ngeneral information about JPEG.  It is available at\nhttp://www.faqs.org/faqs/jpeg-faq.\n\n\nFILE FORMAT COMPATIBILITY\n=========================\n\nThis software implements ITU T.81 | ISO/IEC 10918 with some extensions from\nITU T.871 | ISO/IEC 10918-5 (JPEG File Interchange Format-- see REFERENCES).\nInformally, the term \"JPEG image\" or \"JPEG file\" most often refers to JFIF or\na subset thereof, but there are other formats containing the name \"JPEG\" that\nare incompatible with the original JPEG standard or with JFIF (for instance,\nJPEG 2000 and JPEG XR).  This software therefore does not support these\nformats.  Indeed, one of the original reasons for developing this free software\nwas to help force convergence on a common, interoperable format standard for\nJPEG files.\n\nJFIF is a minimal or \"low end\" representation.  TIFF/JPEG (TIFF revision 6.0 as\nmodified by TIFF Technical Note #2) can be used for \"high end\" applications\nthat need to record a lot of additional data about an image.\n\n\nTO DO\n=====\n\nPlease send bug reports, offers of help, etc. to jpeg-info@jpegclub.org.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.3671875,
          "content": "Background\n==========\n\nlibjpeg-turbo is a JPEG image codec that uses SIMD instructions to accelerate\nbaseline JPEG compression and decompression on x86, x86-64, Arm, PowerPC, and\nMIPS systems, as well as progressive JPEG compression on x86, x86-64, and Arm\nsystems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg,\nall else being equal.  On other types of systems, libjpeg-turbo can still\noutperform libjpeg by a significant amount, by virtue of its highly-optimized\nHuffman coding routines.  In many cases, the performance of libjpeg-turbo\nrivals that of proprietary high-speed JPEG codecs.\n\nlibjpeg-turbo implements both the traditional libjpeg API as well as the less\npowerful but more straightforward TurboJPEG API.  libjpeg-turbo also features\ncolorspace extensions that allow it to compress from/decompress to 32-bit and\nbig-endian pixel buffers (RGBX, XBGR, etc.), as well as a full-featured Java\ninterface.\n\nlibjpeg-turbo was originally based on libjpeg/SIMD, an MMX-accelerated\nderivative of libjpeg v6b developed by Miyasaka Masaru.  The TigerVNC and\nVirtualGL projects made numerous enhancements to the codec in 2009, and in\nearly 2010, libjpeg-turbo spun off into an independent project, with the goal\nof making high-speed JPEG compression/decompression technology available to a\nbroader range of users and developers.  libjpeg-turbo is an ISO/IEC and ITU-T\nreference implementation of the JPEG standard.\n\nMore information about libjpeg-turbo can be found at\n<https://libjpeg-turbo.org>.\n\n\nFunding\n=======\n\nlibjpeg-turbo is an independent open source project, but we rely on patronage\nand funded development in order to maintain that independence.  The easiest way\nto ensure that libjpeg-turbo remains community-focused and free of any one\norganization's agenda is to\n[sponsor our project through GitHub](https://github.com/sponsors/libjpeg-turbo).\nAll sponsorship money goes directly toward funding the labor necessary to\nmaintain libjpeg-turbo, support the user community, and implement bug fixes and\nstrategically important features.\n\n[![Sponsor libjpeg-turbo](https://img.shields.io/github/sponsors/libjpeg-turbo?label=Sponsor&logo=GitHub)](https://github.com/sponsors/libjpeg-turbo)\n\n\nLicense\n=======\n\nlibjpeg-turbo is covered by three compatible BSD-style open source licenses.\nRefer to [LICENSE.md](LICENSE.md) for a roll-up of license terms.\n\n\nBuilding libjpeg-turbo\n======================\n\nRefer to [BUILDING.md](BUILDING.md) for complete instructions.\n\n\nUsing libjpeg-turbo\n===================\n\nlibjpeg-turbo includes two APIs that can be used to compress and decompress\nJPEG images:\n\n- **TurboJPEG API**<br>\n  This API provides an easy-to-use interface for compressing and decompressing\n  JPEG images in memory.  It also provides some functionality that would not be\n  straightforward to achieve using the underlying libjpeg API, such as\n  generating planar YUV images and performing multiple simultaneous lossless\n  transforms on an image.  The Java interface for libjpeg-turbo is written on\n  top of the TurboJPEG API.  The TurboJPEG API is recommended for first-time\n  users of libjpeg-turbo.  Refer to [tjcomp.c](src/tjcomp.c),\n  [tjdecomp.c](src/tjdecomp.c), [tjtran.c](src/tjtran.c),\n  [TJComp.java](java/TJComp.java), [TJDecomp.java](java/TJDecomp.java), and\n  [TJTran.java](java/TJTran.java) for examples of its usage and to\n  <https://libjpeg-turbo.org/Documentation/Documentation> for API\n  documentation.\n\n- **libjpeg API**<br>\n  This is the de facto industry-standard API for compressing and decompressing\n  JPEG images.  It is more difficult to use than the TurboJPEG API but also\n  more powerful.  The libjpeg API implementation in libjpeg-turbo is both\n  API/ABI-compatible and mathematically compatible with libjpeg v6b.  It can\n  also optionally be configured to be API/ABI-compatible with libjpeg v7 and v8\n  (see below.)  Refer to [cjpeg.c](src/cjpeg.c) and [djpeg.c](src/djpeg.c) for\n  examples of its usage and to [libjpeg.txt](doc/libjpeg.txt) for API\n  documentation.\n\nThere is no significant performance advantage to either API when both are used\nto perform similar operations.\n\nColorspace Extensions\n---------------------\n\nlibjpeg-turbo includes extensions that allow JPEG images to be compressed\ndirectly from (and decompressed directly to) buffers that use BGR, BGRX,\nRGBX, XBGR, and XRGB pixel ordering.  This is implemented with ten new\ncolorspace constants:\n\n    JCS_EXT_RGB   /* red/green/blue */\n    JCS_EXT_RGBX  /* red/green/blue/x */\n    JCS_EXT_BGR   /* blue/green/red */\n    JCS_EXT_BGRX  /* blue/green/red/x */\n    JCS_EXT_XBGR  /* x/blue/green/red */\n    JCS_EXT_XRGB  /* x/red/green/blue */\n    JCS_EXT_RGBA  /* red/green/blue/alpha */\n    JCS_EXT_BGRA  /* blue/green/red/alpha */\n    JCS_EXT_ABGR  /* alpha/blue/green/red */\n    JCS_EXT_ARGB  /* alpha/red/green/blue */\n\nSetting `cinfo.in_color_space` (compression) or `cinfo.out_color_space`\n(decompression) to one of these values will cause libjpeg-turbo to read the\nred, green, and blue values from (or write them to) the appropriate position in\nthe pixel when compressing from/decompressing to an RGB buffer.\n\nYour application can check for the existence of these extensions at compile\ntime with:\n\n    #ifdef JCS_EXTENSIONS\n\nAt run time, attempting to use these extensions with a libjpeg implementation\nthat does not support them will result in a \"Bogus input colorspace\" error.\nApplications can trap this error in order to test whether run-time support is\navailable for the colorspace extensions.\n\nWhen using the RGBX, BGRX, XBGR, and XRGB colorspaces during decompression, the\nX byte is undefined, and in order to ensure the best performance, libjpeg-turbo\ncan set that byte to whatever value it wishes.  If an application expects the X\nbyte to be used as an alpha channel, then it should specify `JCS_EXT_RGBA`,\n`JCS_EXT_BGRA`, `JCS_EXT_ABGR`, or `JCS_EXT_ARGB`.  When these colorspace\nconstants are used, the X byte is guaranteed to be 0xFF, which is interpreted\nas opaque.\n\nYour application can check for the existence of the alpha channel colorspace\nextensions at compile time with:\n\n    #ifdef JCS_ALPHA_EXTENSIONS\n\n[jcstest.c](src/jcstest.c), located in the libjpeg-turbo source tree,\ndemonstrates how to check for the existence of the colorspace extensions at\ncompile time and run time.\n\nlibjpeg v7 and v8 API/ABI Emulation\n-----------------------------------\n\nWith libjpeg v7 and v8, new features were added that necessitated extending the\ncompression and decompression structures.  Unfortunately, due to the exposed\nnature of those structures, extending them also necessitated breaking backward\nABI compatibility with previous libjpeg releases.  Thus, programs that were\nbuilt to use libjpeg v7 or v8 did not work with libjpeg-turbo, since it is\nbased on the libjpeg v6b code base.  Although libjpeg v7 and v8 are not\nas widely used as v6b, enough programs (including a few Linux distros) made\nthe switch that there was a demand to emulate the libjpeg v7 and v8 ABIs\nin libjpeg-turbo.  It should be noted, however, that this feature was added\nprimarily so that applications that had already been compiled to use libjpeg\nv7+ could take advantage of accelerated baseline JPEG encoding/decoding\nwithout recompiling.  libjpeg-turbo does not claim to support all of the\nlibjpeg v7+ features, nor to produce identical output to libjpeg v7+ in all\ncases (see below.)\n\nBy passing an argument of `-DWITH_JPEG7=1` or `-DWITH_JPEG8=1` to `cmake`, you\ncan build a version of libjpeg-turbo that emulates the libjpeg v7 or v8 ABI, so\nthat programs that are built against libjpeg v7 or v8 can be run with\nlibjpeg-turbo.  The following section describes which libjpeg v7+ features are\nsupported and which aren't.\n\n### Support for libjpeg v7 and v8 Features\n\n#### Fully supported\n\n- **libjpeg API: IDCT scaling extensions in decompressor**<br>\n  libjpeg-turbo supports IDCT scaling with scaling factors of 1/8, 1/4, 3/8,\n  1/2, 5/8, 3/4, 7/8, 9/8, 5/4, 11/8, 3/2, 13/8, 7/4, 15/8, and 2/1 (only 1/4\n  and 1/2 are SIMD-accelerated.)\n\n- **libjpeg API: Arithmetic coding**\n\n- **libjpeg API: In-memory source and destination managers**<br>\n  See notes below.\n\n- **cjpeg: Separate quality settings for luminance and chrominance**<br>\n  Note that the libpjeg v7+ API was extended to accommodate this feature only\n  for convenience purposes.  It has always been possible to implement this\n  feature with libjpeg v6b (see rdswitch.c for an example.)\n\n- **cjpeg: 32-bit BMP support**\n\n- **cjpeg: `-rgb` option**\n\n- **jpegtran: Lossless cropping**\n\n- **jpegtran: `-perfect` option**\n\n- **jpegtran: Forcing width/height when performing lossless crop**\n\n- **rdjpgcom: `-raw` option**\n\n- **rdjpgcom: Locale awareness**\n\n\n#### Not supported\n\nNOTE:  As of this writing, extensive research has been conducted into the\nusefulness of DCT scaling as a means of data reduction and SmartScale as a\nmeans of quality improvement.  Readers are invited to peruse the research at\n<https://libjpeg-turbo.org/About/SmartScale> and draw their own conclusions,\nbut it is the general belief of our project that these features have not\ndemonstrated sufficient usefulness to justify inclusion in libjpeg-turbo.\n\n- **libjpeg API: DCT scaling in compressor**<br>\n  `cinfo.scale_num` and `cinfo.scale_denom` are silently ignored.\n  There is no technical reason why DCT scaling could not be supported when\n  emulating the libjpeg v7+ API/ABI, but without the SmartScale extension (see\n  below), only scaling factors of 1/2, 8/15, 4/7, 8/13, 2/3, 8/11, 4/5, and\n  8/9 would be available, which is of limited usefulness.\n\n- **libjpeg API: SmartScale**<br>\n  `cinfo.block_size` is silently ignored.\n  SmartScale is an extension to the JPEG format that allows for DCT block\n  sizes other than 8x8.  Providing support for this new format would be\n  feasible (particularly without full acceleration.)  However, until/unless\n  the format becomes either an official industry standard or, at minimum, an\n  accepted solution in the community, we are hesitant to implement it, as\n  there is no sense of whether or how it might change in the future.  It is\n  our belief that SmartScale has not demonstrated sufficient usefulness as a\n  lossless format nor as a means of quality enhancement, and thus our primary\n  interest in providing this feature would be as a means of supporting\n  additional DCT scaling factors.\n\n- **libjpeg API: Fancy downsampling in compressor**<br>\n  `cinfo.do_fancy_downsampling` is silently ignored.\n  This requires the DCT scaling feature, which is not supported.\n\n- **jpegtran: Scaling**<br>\n  This requires both the DCT scaling and SmartScale features, which are not\n  supported.\n\n- **Lossless RGB JPEG files**<br>\n  This requires the SmartScale feature, which is not supported.\n\n### What About libjpeg v9?\n\nlibjpeg v9 introduced yet another field to the JPEG compression structure\n(`color_transform`), thus making the ABI backward incompatible with that of\nlibjpeg v8.  This new field was introduced solely for the purpose of supporting\nlossless SmartScale encoding.  Furthermore, there was actually no reason to\nextend the API in this manner, as the color transform could have just as easily\nbeen activated by way of a new JPEG colorspace constant, thus preserving\nbackward ABI compatibility.\n\nOur research (see link above) has shown that lossless SmartScale does not\ngenerally accomplish anything that can't already be accomplished better with\nexisting, standard lossless formats.  Therefore, at this time it is our belief\nthat there is not sufficient technical justification for software projects to\nupgrade from libjpeg v8 to libjpeg v9, and thus there is not sufficient\ntechnical justification for us to emulate the libjpeg v9 ABI.\n\nIn-Memory Source/Destination Managers\n-------------------------------------\n\nBy default, libjpeg-turbo 1.3 and later includes the `jpeg_mem_src()` and\n`jpeg_mem_dest()` functions, even when not emulating the libjpeg v8 API/ABI.\nPreviously, it was necessary to build libjpeg-turbo from source with libjpeg v8\nAPI/ABI emulation in order to use the in-memory source/destination managers,\nbut several projects requested that those functions be included when emulating\nthe libjpeg v6b API/ABI as well.  This allows the use of those functions by\nprograms that need them, without breaking ABI compatibility for programs that\ndon't, and it allows those functions to be provided in the \"official\"\nlibjpeg-turbo binaries.\n\nNote that, on most Un*x systems, the dynamic linker will not look for a\nfunction in a library until that function is actually used.  Thus, if a program\nis built against libjpeg-turbo 1.3+ and uses `jpeg_mem_src()` or\n`jpeg_mem_dest()`, that program will not fail if run against an older version\nof libjpeg-turbo or against libjpeg v7- until the program actually tries to\ncall `jpeg_mem_src()` or `jpeg_mem_dest()`.  Such is not the case on Windows.\nIf a program is built against the libjpeg-turbo 1.3+ DLL and uses\n`jpeg_mem_src()` or `jpeg_mem_dest()`, then it must use the libjpeg-turbo 1.3+\nDLL at run time.\n\nBoth cjpeg and djpeg have been extended to allow testing the in-memory\nsource/destination manager functions.  See their respective man pages for more\ndetails.\n\n\nMathematical Compatibility\n==========================\n\nFor the most part, libjpeg-turbo should produce identical output to libjpeg\nv6b.  There are two exceptions:\n\n1. When decompressing a JPEG image that uses 4:4:0 chrominance subsampling, the\noutputs of libjpeg v6b and libjpeg-turbo can differ because libjpeg-turbo\nimplements a \"fancy\" (smooth) 4:4:0 upsampling algorithm and libjpeg did not.\n\n2. When using the floating point DCT/IDCT, the outputs of libjpeg v6b and\nlibjpeg-turbo can differ for the following reasons:\n\n    - The SSE/SSE2 floating point DCT implementation in libjpeg-turbo is ever\n      so slightly more accurate than the implementation in libjpeg v6b, but not\n      by any amount perceptible to human vision (generally in the range of 0.01\n      to 0.08 dB gain in PNSR.)\n\n    - When not using the SIMD extensions, libjpeg-turbo uses the more accurate\n      (and slightly faster) floating point IDCT algorithm introduced in libjpeg\n      v8a as opposed to the algorithm used in libjpeg v6b.  It should be noted,\n      however, that this algorithm basically brings the accuracy of the\n      floating point IDCT in line with the accuracy of the accurate integer\n      IDCT.  The floating point DCT/IDCT algorithms are mainly a legacy\n      feature, and they do not produce significantly more accuracy than the\n      accurate integer algorithms.  (To put numbers on this, the typical\n      difference in PNSR between the two algorithms is less than 0.10 dB,\n      whereas changing the quality level by 1 in the upper range of the quality\n      scale is typically more like a 1.0 dB difference.)\n\n    - If the floating point algorithms in libjpeg-turbo are not implemented\n      using SIMD instructions on a particular platform, then the accuracy of\n      the floating point DCT/IDCT can depend on the compiler settings.\n\nWhile libjpeg-turbo does emulate the libjpeg v8 API/ABI, under the hood it is\nstill using the same algorithms as libjpeg v6b, so there are several specific\ncases in which libjpeg-turbo cannot be expected to produce the same output as\nlibjpeg v8:\n\n- When decompressing using scaling factors of 1/2 and 1/4, because libjpeg v8\n  implements those scaling algorithms differently than libjpeg v6b does, and\n  libjpeg-turbo's SIMD extensions are based on the libjpeg v6b behavior.\n\n- When using chrominance subsampling, because libjpeg v8 implements this\n  with its DCT/IDCT scaling algorithms rather than with a separate\n  downsampling/upsampling algorithm.  In our testing, the subsampled/upsampled\n  output of libjpeg v8 is less accurate than that of libjpeg v6b for this\n  reason.\n\n- When decompressing using a scaling factor > 1 and merged (AKA \"non-fancy\" or\n  \"non-smooth\") chrominance upsampling, because libjpeg v8 does not support\n  merged upsampling with scaling factors > 1.\n\n\nPerformance Pitfalls\n====================\n\nRestart Markers\n---------------\n\nThe optimized Huffman decoder in libjpeg-turbo does not handle restart markers\nin a way that makes the rest of the libjpeg infrastructure happy, so it is\nnecessary to use the slow Huffman decoder when decompressing a JPEG image that\nhas restart markers.  This can cause the decompression performance to drop by\nas much as 20%, but the performance will still be much greater than that of\nlibjpeg.  Many consumer packages, such as Photoshop, use restart markers when\ngenerating JPEG images, so images generated by those programs will experience\nthis issue.\n\nFast Integer Forward DCT at High Quality Levels\n-----------------------------------------------\n\nThe algorithm used by the SIMD-accelerated quantization function cannot produce\ncorrect results whenever the fast integer forward DCT is used along with a JPEG\nquality of 98-100.  Thus, libjpeg-turbo must use the non-SIMD quantization\nfunction in those cases.  This causes performance to drop by as much as 40%.\nIt is therefore strongly advised that you use the accurate integer forward DCT\nwhenever encoding images with a JPEG quality of 98 or higher.\n\n\nMemory Debugger Pitfalls\n========================\n\nValgrind and Memory Sanitizer (MSan) can generate false positives\n(specifically, incorrect reports of uninitialized memory accesses) when used\nwith libjpeg-turbo's SIMD extensions.  It is generally recommended that the\nSIMD extensions be disabled, either by passing an argument of `-DWITH_SIMD=0`\nto `cmake` when configuring the build or by setting the environment variable\n`JSIMD_FORCENONE` to `1` at run time, when testing libjpeg-turbo with Valgrind,\nMSan, or other memory debuggers.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 3.8291015625,
          "content": "install:\n  - cmd: >-\n      if not exist c:\\installers mkdir c:\\installers\n\n      mkdir c:\\temp\n\n      if not exist c:\\installers\\nasm-2.10.01-win32.zip curl -fSL -o c:\\installers\\nasm-2.10.01-win32.zip https://nasm.us/pub/nasm/releasebuilds/2.10.01/win32/nasm-2.10.01-win32.zip\n\n      7z x c:\\installers\\nasm-2.10.01-win32.zip -oc:\\ > c:\\installers\\nasm.install.log\n\n      if not exist c:\\installers\\i686-6.4.0-release-posix-dwarf-rt_v5-rev0.7z curl -fSL -o c:\\installers\\i686-6.4.0-release-posix-dwarf-rt_v5-rev0.7z \"https://sourceforge.net/projects/mingw-w64/files/Toolchains targetting Win32/Personal Builds/mingw-builds/6.4.0/threads-posix/dwarf/i686-6.4.0-release-posix-dwarf-rt_v5-rev0.7z\"\n\n      md \"c:\\Program Files (x86)\\mingw-w64\\i686-6.4.0-posix-dwarf-rt_v5-rev0\"\n\n      7z x c:\\installers\\i686-6.4.0-release-posix-dwarf-rt_v5-rev0.7z -o\"c:\\Program Files (x86)\\mingw-w64\\i686-6.4.0-posix-dwarf-rt_v5-rev0\" > c:\\installers\\mingw32.install.log\n\n      if not exist c:\\installers\\x86_64-6.4.0-release-posix-seh-rt_v5-rev0.7z curl -fSL -o c:\\installers\\x86_64-6.4.0-release-posix-seh-rt_v5-rev0.7z \"https://sourceforge.net/projects/mingw-w64/files/Toolchains targetting Win64/Personal Builds/mingw-builds/6.4.0/threads-posix/seh/x86_64-6.4.0-release-posix-seh-rt_v5-rev0.7z\"\n\n      md \"c:\\Program Files\\mingw-w64\\x86_64-6.4.0-posix-seh-rt_v5-rev0\"\n\n      7z x c:\\installers\\x86_64-6.4.0-release-posix-seh-rt_v5-rev0.7z -o\"c:\\Program Files\\mingw-w64\\x86_64-6.4.0-posix-seh-rt_v5-rev0\" > c:\\installers\\mingw64.install.log\n\n      set PATH=c:\\nasm-2.10.01;c:\\Program Files (x86)\\NSIS;c:\\msys64\\usr\\bin;%PATH%\n\n      \"c:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n\n      set INCLUDE\n\n      set LIB\n\n      set PATH\n\n      set MSYSTEM=MINGW32\n\n      bash -c \"pacman --noconfirm -S zip\"\n\n      mklink /d \"%ProgramData%\\Oracle\\Java32\" \"c:\\Program Files (x86)\\Java\\jdk1.8.0\"\n\n      git clone --depth=1 https://github.com/libjpeg-turbo/buildscripts.git -b %APPVEYOR_REPO_BRANCH% c:/buildscripts\n\ncache:\n  - c:\\installers\\nasm-2.10.01-win32.zip -> appveyor.yml\n  - c:\\installers\\i686-6.4.0-release-posix-dwarf-rt_v5-rev0.7z -> appveyor.yml\n  - c:\\installers\\x86_64-6.4.0-release-posix-seh-rt_v5-rev0.7z -> appveyor.yml\n\nbuild_script:\n  - cmd: >-\n      for /f %%i in ('\"cygpath %CD%\"') do set MINGWPATH=%%i\n\n      bash c:/buildscripts/buildljt -d %MINGWPATH% -b /c/ljt.nightly -v\n\n      cmake --build . --target clean\n\n      md win64\n\n      cd win64\n\n      bash c:/buildscripts/setupscripts/win64 -DCMAKE_C_FLAGS='-DWIN32 -D_WINDOWS -W4 -wd4100 -wd4127 -wd4245 -wd4324 -wd4701 -wd4702 -wd4706 -WX'\n\n      cd ..\n\n      ninja\n\n      move c:\\ljt.nightly\\files\\*.tar.gz .\n\n      move c:\\ljt.nightly\\files\\*.exe .\n\n      move c:\\ljt.nightly\\files\\*.html .\n\n      move c:\\ljt.nightly\\log-windows.txt .\n\n      zip libjpeg-turbo-installers.zip libjpeg-turbo-*.exe\n\nartifacts:\n  - path: '*.tar.gz'\n    name: Source tarball\n\n  - path: '*-gcc*.exe'\n    name: SDK for MinGW\n\n  - path: '*-vc*.exe'\n    name: SDK for Visual C++\n\n  - path: '*.zip'\n    name: All libjpeg-turbo installers\n\n  - path: 'log-windows.txt'\n    name: Build log\n\n  - path: 'index.html'\n    name: MD5 checksums\n\ntest: off\n\ndeploy:\n  - provider: Webhook\n    url: https://app.signpath.io/API/v1/3bc964ce-257b-4362-829f-1df1f087f5a0/Integrations/AppVeyor?ProjectSlug=libjpeg-turbo&SigningPolicySlug=release-signing\n    authorization:\n      secure: rrx5wnu5VWQqrFZJv75WdPc1H5gyYqp7cV/xVhsx1TnVR7VyUaVEiCYm/64Fcx1zmEPHGyEBrlrbjuRHgDjURA==\n    on:\n      appveyor_repo_tag: true\n  - provider: S3\n    access_key_id:\n      secure: Z74OYogQ6bNV/I+6b5ZEXig74+6MW2WLER0v/bPM/uk=\n    secret_access_key:\n      secure: cyGZhHVCFwZ9jgf5lXoW69mVtECmqwx3eLo61ha8ueWbMYlHho7lwDXwVvxOFiCa\n    bucket: libjpeg-turbo-pr\n    region:\n      secure: qSElYBgBRcEUf88M6Osthw==\n    folder: $(APPVEYOR_REPO_BRANCH)/windows\n    set_public: true\n    remove_files: true\n"
        },
        {
          "name": "cmakescripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "java",
          "type": "tree",
          "content": null
        },
        {
          "name": "release",
          "type": "tree",
          "content": null
        },
        {
          "name": "sharedlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "simd",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testimages",
          "type": "tree",
          "content": null
        },
        {
          "name": "win",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}