{
  "metadata": {
    "timestamp": 1736709965267,
    "page": 517,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "emersion/mako",
      "stars": 2298,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".builds",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1259765625,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\nindent_style = tab\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "/subprojects/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0400390625,
          "content": "MIT License\n\nCopyright (c) 2018 emersion\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.8017578125,
          "content": "# mako\n\nA lightweight notification daemon for Wayland. Works on Sway.\n\n<p align=\"center\">\n  <img src=\"https://sr.ht/meoc.png\" alt=\"mako screenshot\">\n</p>\n\nmako implements the [FreeDesktop Notifications Specification][spec].\n\nFeel free to join the IRC channel: #emersion on irc.libera.chat.\n\n## Running\n\n\n`mako` will run automatically when a notification is emitted. This happens via\nD-Bus activation, so you don't really need to explicitly start it up (this also\nallows delaying its startup time and speed up system startup).\n\nIf you have several notification daemons installed though, you might want to\nexplicitly start this one. Some ways of achieving this is:\n\n- If you're using Sway you can start mako on launch by putting `exec mako` in\n  your configuration file.\n\n- If you are not using systemd, you might need to manually start a dbus user\n  session: `dbus-daemon --session --address=unix:path=$XDG_RUNTIME_DIR/bus`\n\n## Configuration\n\n`mako` can be extensively configured and customized - feel free to read more\nusing the command `man 5 mako`\n\nFor control of mako during runtime, `makoctl` can be used; see `man makoctl`\n\n## Building\n\nInstall dependencies:\n\n* meson (build-time dependency)\n* wayland\n* pango\n* cairo\n* systemd, elogind or [basu] (for the sd-bus library)\n* gdk-pixbuf (optional, for icons support)\n* dbus (runtime dependency, user-session support is required)\n* scdoc (optional, for man pages)\n* jq (optional, runtime dependency)\n\nThen run:\n\n```shell\nmeson build\nninja -C build\nbuild/mako\n```\n\n<p align=\"center\">\n  <img src=\"https://sr.ht/frOL.jpg\" alt=\"mako\">\n</p>\n\n## I have a question!\n\nSee the [faq section in the wiki](https://github.com/emersion/mako/wiki/Frequently-asked-questions).\n\n## License\n\nMIT\n\n[spec]: https://specifications.freedesktop.org/notification-spec/latest/\n[basu]: https://github.com/emersion/basu\n"
        },
        {
          "name": "cairo-pixbuf.c",
          "type": "blob",
          "size": 2.458984375,
          "content": "#include \"cairo-pixbuf.h\"\n\ncairo_surface_t *create_cairo_surface_from_gdk_pixbuf(const GdkPixbuf *gdkbuf) {\n\tint chan = gdk_pixbuf_get_n_channels(gdkbuf);\n\tif (chan < 3) {\n\t\treturn NULL;\n\t}\n\n\tconst guint8* gdkpix = gdk_pixbuf_read_pixels(gdkbuf);\n\tif (!gdkpix) {\n\t\treturn NULL;\n\t}\n\tgint w = gdk_pixbuf_get_width(gdkbuf);\n\tgint h = gdk_pixbuf_get_height(gdkbuf);\n\tint stride = gdk_pixbuf_get_rowstride(gdkbuf);\n\n\tcairo_format_t fmt = (chan == 3) ? CAIRO_FORMAT_RGB24 : CAIRO_FORMAT_ARGB32;\n\tcairo_surface_t * cs = cairo_image_surface_create(fmt, w, h);\n\tcairo_surface_flush(cs);\n\tif (!cs || cairo_surface_status(cs) != CAIRO_STATUS_SUCCESS) {\n\t\treturn NULL;\n\t}\n\n\tint cstride = cairo_image_surface_get_stride(cs);\n\tunsigned char *cpix = cairo_image_surface_get_data(cs);\n\n\tif (chan == 3) {\n\t\tfor (int i = h; i; --i) {\n\t\t\tconst guint8 *gp = gdkpix;\n\t\t\tunsigned char *cp = cpix;\n\t\t\tconst guint8* end = gp + 3*w;\n\t\t\twhile (gp < end) {\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\t\t\tcp[0] = gp[2];\n\t\t\t\tcp[1] = gp[1];\n\t\t\t\tcp[2] = gp[0];\n#else\n\t\t\t\tcp[1] = gp[0];\n\t\t\t\tcp[2] = gp[1];\n\t\t\t\tcp[3] = gp[2];\n#endif\n\t\t\t\tgp += 3;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t\tgdkpix += stride;\n\t\t\tcpix += cstride;\n\t\t}\n\t} else {\n\t\t/* premul-color = alpha/255 * color/255 * 255 = (alpha*color)/255\n\t\t * (z/255) = z/256 * 256/255     = z/256 (1 + 1/255)\n\t\t *         = z/256 + (z/256)/255 = (z + z/255)/256\n\t\t *         # recurse once\n\t\t *         = (z + (z + z/255)/256)/256\n\t\t *         = (z + z/256 + z/256/255) / 256\n\t\t *         # only use 16bit uint operations, loose some precision,\n\t\t *         # result is floored.\n\t\t *       ->  (z + z>>8)>>8\n\t\t *         # add 0x80/255 = 0.5 to convert floor to round\n\t\t *       =>  (z+0x80 + (z+0x80)>>8 ) >> 8\n\t\t * ------\n\t\t * tested as equal to lround(z/255.0) for uint z in [0..0xfe02]\n\t\t */\n#define PREMUL_ALPHA(x,a,b,z) { z = a * b + 0x80; x = (z + (z >> 8)) >> 8; }\n\t\tfor (int i = h; i; --i) {\n\t\t\tconst guint8 *gp = gdkpix;\n\t\t\tunsigned char *cp = cpix;\n\t\t\tconst guint8* end = gp + 4*w;\n\t\t\tguint z1, z2, z3;\n\t\t\twhile (gp < end) {\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\t\t\tPREMUL_ALPHA(cp[0], gp[2], gp[3], z1);\n\t\t\t\tPREMUL_ALPHA(cp[1], gp[1], gp[3], z2);\n\t\t\t\tPREMUL_ALPHA(cp[2], gp[0], gp[3], z3);\n\t\t\t\tcp[3] = gp[3];\n#else\n\t\t\t\tPREMUL_ALPHA(cp[1], gp[0], gp[3], z1);\n\t\t\t\tPREMUL_ALPHA(cp[2], gp[1], gp[3], z2);\n\t\t\t\tPREMUL_ALPHA(cp[3], gp[2], gp[3], z3);\n\t\t\t\tcp[0] = gp[3];\n#endif\n\t\t\t\tgp += 4;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t\tgdkpix += stride;\n\t\t\tcpix += cstride;\n\t\t}\n#undef PREMUL_ALPHA\n\t}\n\tcairo_surface_mark_dirty(cs);\n\treturn cs;\n}\n"
        },
        {
          "name": "config.c",
          "type": "blob",
          "size": 29.1015625,
          "content": "#include <getopt.h>\n#include <libgen.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <wordexp.h>\n#include <unistd.h>\n\n#include \"config.h\"\n#include \"criteria.h\"\n#include \"string-util.h\"\n#include \"types.h\"\n\nstatic int32_t max(int32_t a, int32_t b) {\n\treturn (a > b) ? a : b;\n}\n\nvoid init_default_config(struct mako_config *config) {\n\twl_list_init(&config->criteria);\n\tstruct mako_criteria *new_criteria = create_criteria(config);\n\tinit_default_style(&new_criteria->style);\n\tnew_criteria->raw_string = strdup(\"(root)\");\n\n\t// Hide grouped notifications by default, and put the group count in\n\t// their format...\n\tnew_criteria = create_criteria(config);\n\tinit_empty_style(&new_criteria->style);\n\tnew_criteria->grouped = true;\n\tnew_criteria->spec.grouped = true;\n\tnew_criteria->style.invisible = true;\n\tnew_criteria->style.spec.invisible = true;\n\tnew_criteria->style.format = strdup(\"(%g) <b>%s</b>\\n%b\");\n\tnew_criteria->style.spec.format = true;\n\tnew_criteria->raw_string = strdup(\"(default grouped)\");\n\n\t// ...but make the first one in the group visible.\n\tnew_criteria = create_criteria(config);\n\tinit_empty_style(&new_criteria->style);\n\tnew_criteria->group_index = 0;\n\tnew_criteria->spec.group_index = true;\n\tnew_criteria->style.invisible = false;\n\tnew_criteria->style.spec.invisible = true;\n\tnew_criteria->raw_string = strdup(\"(default group-index=0)\");\n\n\t// Define the default format for the hidden placeholder notification.\n\tnew_criteria = create_criteria(config);\n\tinit_empty_style(&new_criteria->style);\n\tnew_criteria->hidden = true;\n\tnew_criteria->spec.hidden = true;\n\tnew_criteria->style.format = strdup(\"(%h more)\");\n\tnew_criteria->style.spec.format = true;\n\tnew_criteria->raw_string = strdup(\"(default hidden)\");\n\n\tinit_empty_style(&config->superstyle);\n\n\tconfig->max_history = 5;\n\tconfig->sort_criteria = MAKO_SORT_CRITERIA_TIME;\n\tconfig->sort_asc = 0;\n}\n\nvoid finish_config(struct mako_config *config) {\n\tstruct mako_criteria *criteria, *tmp;\n\twl_list_for_each_safe(criteria, tmp, &config->criteria, link) {\n\t\tdestroy_criteria(criteria);\n\t}\n\n\tfinish_style(&config->superstyle);\n}\n\nvoid init_default_style(struct mako_style *style) {\n\tstyle->width = 300;\n\tstyle->height = 100;\n\n\tstyle->outer_margin.top = 0;\n\tstyle->outer_margin.right = 0;\n\tstyle->outer_margin.bottom = 0;\n\tstyle->outer_margin.left = 0;\n\n\tstyle->margin.top = 10;\n\tstyle->margin.right = 10;\n\tstyle->margin.bottom = 10;\n\tstyle->margin.left = 10;\n\n\tstyle->padding.top = 5;\n\tstyle->padding.right = 5;\n\tstyle->padding.bottom = 5;\n\tstyle->padding.left = 5;\n\n\tstyle->border_size = 2;\n\tstyle->border_radius = 0;\n\n#ifdef HAVE_ICONS\n\tstyle->icons = true;\n#else\n\tstyle->icons = false;\n#endif\n\tstyle->max_icon_size = 64;\n\tstyle->icon_path = strdup(\"\");  // hicolor and pixmaps are implicit.\n\n\tstyle->font = strdup(\"monospace 10\");\n\tstyle->markup = true;\n\tstyle->format = strdup(\"<b>%s</b>\\n%b\");\n\tstyle->text_alignment = PANGO_ALIGN_LEFT;\n\n\tstyle->actions = true;\n\tstyle->default_timeout = 0;\n\tstyle->ignore_timeout = false;\n\n\tstyle->colors.background = 0x285577FF;\n\tstyle->colors.text = 0xFFFFFFFF;\n\tstyle->colors.border = 0x4C7899FF;\n\tstyle->colors.progress.value = 0x5588AAFF;\n\tstyle->colors.progress.operator = CAIRO_OPERATOR_OVER;\n\n\tstyle->group_criteria_spec.none = true;\n\tstyle->invisible = false;\n\tstyle->history = true;\n\tstyle->icon_location = MAKO_ICON_LOCATION_LEFT;\n\n\tstyle->output = strdup(\"\");\n\tstyle->layer = ZWLR_LAYER_SHELL_V1_LAYER_TOP;\n\tstyle->max_visible = 5;\n\n\tstyle->anchor =\n\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP | ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;\n\n\tstyle->button_bindings.left.action = MAKO_BINDING_INVOKE_ACTION;\n\tstyle->button_bindings.left.action_name = strdup(DEFAULT_ACTION_KEY);\n\tstyle->button_bindings.right.action = MAKO_BINDING_DISMISS;\n\tstyle->button_bindings.middle.action = MAKO_BINDING_NONE;\n\tstyle->touch_binding.action = MAKO_BINDING_DISMISS;\n\n\t// Everything in the default config is explicitly specified.\n\tmemset(&style->spec, true, sizeof(struct mako_style_spec));\n}\n\nvoid init_empty_style(struct mako_style *style) {\n\tmemset(style, 0, sizeof(struct mako_style));\n}\n\nstatic void finish_binding(struct mako_binding *binding) {\n\tfree(binding->command);\n\tfree(binding->action_name);\n}\n\nvoid finish_style(struct mako_style *style) {\n\tfinish_binding(&style->button_bindings.left);\n\tfinish_binding(&style->button_bindings.middle);\n\tfinish_binding(&style->button_bindings.right);\n\tfinish_binding(&style->touch_binding);\n\tfinish_binding(&style->notify_binding);\n\tfree(style->icon_path);\n\tfree(style->font);\n\tfree(style->format);\n\tfree(style->output);\n}\n\nstatic void copy_binding(struct mako_binding *dst,\n\t\tconst struct mako_binding *src) {\n\tfinish_binding(dst);\n\n\t*dst = *src;\n\tif (src->command != NULL) {\n\t\tdst->command = strdup(src->command);\n\t}\n\tif (src->action_name != NULL) {\n\t\tdst->action_name = strdup(src->action_name);\n\t}\n}\n\n// Update `target` with the values specified in `style`. If a failure occurs,\n// `target` will remain unchanged.\nbool apply_style(struct mako_style *target, const struct mako_style *style) {\n\t// Try to duplicate strings up front in case allocation fails and we have\n\t// to bail without changing `target`.\n\tchar *new_font = NULL;\n\tchar *new_format = NULL;\n\tchar *new_icon_path = NULL;\n\tchar *new_output = NULL;\n\n\tif (style->spec.font) {\n\t\tnew_font = strdup(style->font);\n\t\tif (new_font == NULL) {\n\t\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (style->spec.format) {\n\t\tnew_format = strdup(style->format);\n\t\tif (new_format == NULL) {\n\t\t\tfree(new_font);\n\t\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (style->spec.icon_path) {\n\t\tnew_icon_path = strdup(style->icon_path);\n\t\tif (new_icon_path == NULL) {\n\t\t\tfree(new_format);\n\t\t\tfree(new_font);\n\t\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (style->spec.output) {\n\t\tnew_output = strdup(style->output);\n\t\tif (new_output == NULL) {\n\t\t\tfree(new_format);\n\t\t\tfree(new_font);\n\t\t\tfree(new_icon_path);\n\t\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Now on to actually setting things!\n\n\tif (style->spec.width) {\n\t\ttarget->width = style->width;\n\t\ttarget->spec.width = true;\n\t}\n\n\tif (style->spec.height) {\n\t\ttarget->height = style->height;\n\t\ttarget->spec.height = true;\n\t}\n\n\tif (style->spec.outer_margin) {\n\t\ttarget->outer_margin = style->outer_margin;\n\t\ttarget->spec.outer_margin = true;\n\t}\n\n\tif (style->spec.margin) {\n\t\ttarget->margin = style->margin;\n\t\ttarget->spec.margin = true;\n\t}\n\n\tif (style->spec.padding) {\n\t\ttarget->padding = style->padding;\n\t\ttarget->spec.padding = true;\n\t}\n\n\tif (style->spec.border_size) {\n\t\ttarget->border_size = style->border_size;\n\t\ttarget->spec.border_size = true;\n\t}\n\n\tif (style->spec.icons) {\n\t\ttarget->icons = style->icons;\n\t\ttarget->spec.icons = true;\n\t}\n\n\tif (style->spec.max_icon_size) {\n\t\ttarget->max_icon_size = style->max_icon_size;\n\t\ttarget->spec.max_icon_size = true;\n\t}\n\n\tif (style->spec.icon_path) {\n\t\tfree(target->icon_path);\n\t\ttarget->icon_path = new_icon_path;\n\t\ttarget->spec.icon_path = true;\n\t}\n\n\tif (style->spec.font) {\n\t\tfree(target->font);\n\t\ttarget->font = new_font;\n\t\ttarget->spec.font = true;\n\t}\n\n\tif (style->spec.markup) {\n\t\ttarget->markup = style->markup;\n\t\ttarget->spec.markup = true;\n\t}\n\n\tif (style->spec.format) {\n\t\tfree(target->format);\n\t\ttarget->format = new_format;\n\t\ttarget->spec.format = true;\n\t}\n\n\tif (style->spec.text_alignment) {\n\t\ttarget->text_alignment = style->text_alignment;\n\t\ttarget->spec.text_alignment = true;\n\t}\n\n\tif (style->spec.actions) {\n\t\ttarget->actions = style->actions;\n\t\ttarget->spec.actions = true;\n\t}\n\n\tif (style->spec.default_timeout) {\n\t\ttarget->default_timeout = style->default_timeout;\n\t\ttarget->spec.default_timeout = true;\n\t}\n\n\tif (style->spec.ignore_timeout) {\n\t\ttarget->ignore_timeout = style->ignore_timeout;\n\t\ttarget->spec.ignore_timeout = true;\n\t}\n\n\tif (style->spec.colors.background) {\n\t\ttarget->colors.background = style->colors.background;\n\t\ttarget->spec.colors.background = true;\n\t}\n\n\tif (style->spec.colors.text) {\n\t\ttarget->colors.text = style->colors.text;\n\t\ttarget->spec.colors.text = true;\n\t}\n\n\tif (style->spec.colors.border) {\n\t\ttarget->colors.border = style->colors.border;\n\t\ttarget->spec.colors.border = true;\n\t}\n\n\tif (style->spec.colors.progress) {\n\t\ttarget->colors.progress = style->colors.progress;\n\t\ttarget->spec.colors.progress = true;\n\t}\n\n\tif (style->spec.group_criteria_spec) {\n\t\ttarget->group_criteria_spec = style->group_criteria_spec;\n\t\ttarget->spec.group_criteria_spec = true;\n\t}\n\n\tif (style->spec.invisible) {\n\t\ttarget->invisible = style->invisible;\n\t\ttarget->spec.invisible = true;\n\t}\n\n\tif (style->spec.history) {\n\t\ttarget->history = style->history;\n\t\ttarget->spec.history = true;\n\t}\n\n\tif (style->spec.icon_location) {\n\t\ttarget->icon_location = style->icon_location;\n\t\ttarget->spec.icon_location = true;\n\t}\n\n\tif (style->border_radius) {\n\t\ttarget->border_radius = style->border_radius;\n\t\ttarget->spec.border_radius = true;\n\t}\n\n\tif (style->spec.output) {\n\t\tfree(target->output);\n\t\ttarget->output = new_output;\n\t\ttarget->spec.output = true;\n\t}\n\n\tif (style->spec.anchor) {\n\t\ttarget->anchor = style->anchor;\n\t\ttarget->spec.anchor = true;\n\t}\n\n\tif (style->spec.layer) {\n\t\ttarget->layer = style->layer;\n\t\ttarget->spec.layer = true;\n\t}\n\n\tif (style->spec.max_visible) {\n\t\ttarget->max_visible = style->max_visible;\n\t\ttarget->spec.max_visible = true;\n\t}\n\n\tif (style->spec.button_bindings.left) {\n\t\tcopy_binding(&target->button_bindings.left, &style->button_bindings.left);\n\t\ttarget->spec.button_bindings.left = true;\n\t}\n\tif (style->spec.button_bindings.middle) {\n\t\tcopy_binding(&target->button_bindings.middle, &style->button_bindings.middle);\n\t\ttarget->spec.button_bindings.middle = true;\n\t}\n\tif (style->spec.button_bindings.right) {\n\t\tcopy_binding(&target->button_bindings.right, &style->button_bindings.right);\n\t\ttarget->spec.button_bindings.right = true;\n\t}\n\n\tif (style->spec.touch_binding) {\n\t\tcopy_binding(&target->touch_binding, &style->touch_binding);\n\t\ttarget->spec.touch_binding = true;\n\t}\n\n\tif (style->spec.notify_binding) {\n\t\tcopy_binding(&target->notify_binding, &style->notify_binding);\n\t\ttarget->spec.notify_binding = true;\n\t}\n\n\treturn true;\n}\n\n// Given a config and a style in which to store the information, this will\n// calculate a style that has the maximum value of all the configured criteria\n// styles (including the default as a base), for values where it makes sense to\n// have a maximum. Those that don't make sense will be unchanged. Usually, you\n// want to pass an empty style as the target.\nbool apply_superset_style(\n\t\tstruct mako_style *target, struct mako_config *config) {\n\t// Specify eveything that we'll be combining.\n\ttarget->spec.width = true;\n\ttarget->spec.height = true;\n\ttarget->spec.outer_margin = true;\n\ttarget->spec.margin = true;\n\ttarget->spec.padding = true;\n\ttarget->spec.border_size = true;\n\ttarget->spec.icons = true;\n\ttarget->spec.max_icon_size = true;\n\ttarget->spec.default_timeout = true;\n\ttarget->spec.markup = true;\n\ttarget->spec.actions = true;\n\ttarget->spec.history = true;\n\ttarget->spec.format = true;\n\n\tfree(target->format);\n\n\t// The \"format\" needs enough space for one of each specifier.\n\ttarget->format = calloc(1, (2 * strlen(VALID_FORMAT_SPECIFIERS)) + 1);\n\tchar *target_format_pos = target->format;\n\n\t// Now we loop over the criteria and add together those fields.\n\t// We can't use apply_style, because it simply overwrites each field.\n\tstruct mako_criteria *criteria;\n\twl_list_for_each(criteria, &config->criteria, link) {\n\t\tstruct mako_style *style = &criteria->style;\n\n\t\t// We can cheat and skip checking whether any of these are specified,\n\t\t// since we're looking for the max and unspecified ones will be\n\t\t// initialized to zero.\n\t\ttarget->width = max(style->width, target->width);\n\t\ttarget->height = max(style->height, target->height);\n\t\ttarget->outer_margin.top = max(style->outer_margin.top, target->outer_margin.top);\n\t\ttarget->outer_margin.right = max(style->outer_margin.right, target->outer_margin.right);\n\t\ttarget->outer_margin.bottom =\n\t\t\tmax(style->outer_margin.bottom, target->outer_margin.bottom);\n\t\ttarget->outer_margin.left = max(style->outer_margin.left, target->outer_margin.left);\n\t\ttarget->margin.top = max(style->margin.top, target->margin.top);\n\t\ttarget->margin.right = max(style->margin.right, target->margin.right);\n\t\ttarget->margin.bottom =\n\t\t\tmax(style->margin.bottom, target->margin.bottom);\n\t\ttarget->margin.left = max(style->margin.left, target->margin.left);\n\t\ttarget->padding.top = max(style->padding.top, target->padding.top);\n\t\ttarget->padding.right = max(style->padding.right, target->padding.right);\n\t\ttarget->padding.bottom =\n\t\t\tmax(style->padding.bottom, target->padding.bottom);\n\t\ttarget->padding.left = max(style->padding.left, target->padding.left);\n\t\ttarget->border_size = max(style->border_size, target->border_size);\n\t\ttarget->icons = style->icons || target->icons;\n\t\ttarget->max_icon_size = max(style->max_icon_size, target->max_icon_size);\n\t\ttarget->default_timeout =\n\t\t\tmax(style->default_timeout, target->default_timeout);\n\n\t\ttarget->markup |= style->markup;\n\t\ttarget->actions |= style->actions;\n\t\ttarget->history |= style->history;\n\n\t\t// We do need to be safe about this one though.\n\t\tif (style->spec.format) {\n\t\t\tchar *format_pos = style->format;\n\t\t\tchar current_specifier[3] = {0};\n\t\t\twhile (*format_pos) {\n\t\t\t\tformat_pos = strstr(format_pos, \"%\");\n\t\t\t\tif (!format_pos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// We only want to add the format specifier to the target if we\n\t\t\t\t// haven't already seen it.\n\t\t\t\t// Need to copy the specifier into its own string to use strstr\n\t\t\t\t// here, because there's no way to limit how much of the string\n\t\t\t\t// it uses in the comparison.\n\t\t\t\tmemcpy(&current_specifier, format_pos, 2);\n\t\t\t\tif (!strstr(target->format, current_specifier)) {\n\t\t\t\t\tmemcpy(target_format_pos, format_pos, 2);\n\t\t\t\t\ttarget_format_pos += 2; // This needs to go to the next slot.\n\t\t\t\t}\n\n\t\t\t\t++format_pos; // Enough to move to the next match.\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic char *expand_config_path(const char *path) {\n\tif (strncmp(path, \"/\", 1) == 0) {\n\t\treturn strdup(path);\n\t}\n\n\tif (strncmp(path, \"~/\", 2) != 0) {\n\t\tfprintf(stderr, \"Config path must start with / or ~/\\n\");\n\t\treturn NULL;\n\t}\n\n\tconst char *home = getenv(\"HOME\");\n\tif (home == NULL) {\n\t\tfprintf(stderr, \"HOME env var not set\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn mako_asprintf(\"%s/%s\", home, path + 2);\n}\n\nstatic bool apply_config_option(struct mako_config *config, const char *name,\n\t\tconst char *value) {\n\tif (strcmp(name, \"sort\") == 0) {\n\t\tif (strcmp(value, \"+priority\") == 0) {\n\t\t\tconfig->sort_criteria |= MAKO_SORT_CRITERIA_URGENCY;\n\t\t\tconfig->sort_asc |= MAKO_SORT_CRITERIA_URGENCY;\n\t\t} else if (strcmp(value, \"-priority\") == 0) {\n\t\t\tconfig->sort_criteria |= MAKO_SORT_CRITERIA_URGENCY;\n\t\t\tconfig->sort_asc &= ~MAKO_SORT_CRITERIA_URGENCY;\n\t\t} else if (strcmp(value, \"+time\") == 0) {\n\t\t\tconfig->sort_criteria |= MAKO_SORT_CRITERIA_TIME;\n\t\t\tconfig->sort_asc |= MAKO_SORT_CRITERIA_TIME;\n\t\t} else if (strcmp(value, \"-time\") == 0) {\n\t\t\tconfig->sort_criteria |= MAKO_SORT_CRITERIA_TIME;\n\t\t\tconfig->sort_asc &= ~MAKO_SORT_CRITERIA_TIME;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} else if (strcmp(name, \"max-history\") == 0) {\n\t\treturn parse_int(value, &config->max_history);\n\t} else if (strcmp(name, \"include\") == 0) {\n\t\tchar *path = expand_config_path(value);\n\t\treturn path && load_config_file(config, path) == 0;\n\t}\n\n\treturn false;\n}\n\nstatic bool has_prefix(const char *str, const char *prefix) {\n\treturn strncmp(str, prefix, strlen(prefix)) == 0;\n}\n\nstatic bool apply_style_option(struct mako_style *style, const char *name,\n\t\tconst char *value) {\n\tstruct mako_style_spec *spec = &style->spec;\n\n\tif (strcmp(name, \"font\") == 0) {\n\t\tfree(style->font);\n\t\treturn spec->font = !!(style->font = strdup(value));\n\t} else if (strcmp(name, \"background-color\") == 0) {\n\t\treturn spec->colors.background =\n\t\t\tparse_color(value, &style->colors.background);\n\t} else if (strcmp(name, \"text-color\") == 0) {\n\t\treturn spec->colors.text = parse_color(value, &style->colors.text);\n\t} else if (strcmp(name, \"width\") == 0) {\n\t\treturn spec->width = parse_int_ge(value, &style->width, 1);\n\t} else if (strcmp(name, \"height\") == 0) {\n\t\treturn spec->height = parse_int_ge(value, &style->height, 1);\n\t} else if (strcmp(name, \"outer-margin\") == 0) {\n\t\treturn spec->outer_margin = parse_directional(value, &style->outer_margin);\n\t} else if (strcmp(name, \"margin\") == 0) {\n\t\treturn spec->margin = parse_directional(value, &style->margin);\n\t} else if (strcmp(name, \"padding\") == 0) {\n\t\tspec->padding = parse_directional(value, &style->padding);\n\t\tif (spec->border_radius && spec->padding) {\n\t\t\tstyle->padding.left = max(style->border_radius, style->padding.left);\n\t\t\tstyle->padding.right = max(style->border_radius, style->padding.right);\n\t\t}\n\t\treturn spec->padding;\n\t} else if (strcmp(name, \"border-size\") == 0) {\n\t\treturn spec->border_size = parse_int_ge(value, &style->border_size, 0);\n\t} else if (strcmp(name, \"border-color\") == 0) {\n\t\treturn spec->colors.border = parse_color(value, &style->colors.border);\n\t} else if (strcmp(name, \"progress-color\") == 0) {\n\t\treturn spec->colors.progress = parse_mako_color(value, &style->colors.progress);\n\t} else if (strcmp(name, \"icons\") == 0) {\n#ifdef HAVE_ICONS\n\t\treturn spec->icons =\n\t\t\tparse_boolean(value, &style->icons);\n#else\n\t\tfprintf(stderr, \"Icon support not built in, ignoring icons setting.\\n\");\n\t\treturn true;\n#endif\n\t} else if (strcmp(name, \"icon-location\") == 0) {\n\t\tif (!strcmp(value, \"left\")) {\n\t\t\tstyle->icon_location = MAKO_ICON_LOCATION_LEFT;\n\t\t} else if (!strcmp(value, \"right\")) {\n\t\t\tstyle->icon_location = MAKO_ICON_LOCATION_RIGHT;\n\t\t} else if (!strcmp(value, \"top\")) {\n\t\t\tstyle->icon_location = MAKO_ICON_LOCATION_TOP;\n\t\t} else if (!strcmp(value, \"bottom\")) {\n\t\t\tstyle->icon_location = MAKO_ICON_LOCATION_BOTTOM;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\treturn spec->icon_location = true;\n\t} else if (strcmp(name, \"max-icon-size\") == 0) {\n\t\treturn spec->max_icon_size =\n\t\t\tparse_int_ge(value, &style->max_icon_size, 1);\n\t} else if (strcmp(name, \"icon-path\") == 0) {\n\t\tfree(style->icon_path);\n\t\treturn spec->icon_path = !!(style->icon_path = strdup(value));\n\t} else if (strcmp(name, \"markup\") == 0) {\n\t\treturn spec->markup = parse_boolean(value, &style->markup);\n\t} else if (strcmp(name, \"actions\") == 0) {\n\t\treturn spec->actions = parse_boolean(value, &style->actions);\n\t} else if (strcmp(name, \"format\") == 0) {\n\t\tfree(style->format);\n\t\treturn spec->format = parse_format(value, &style->format);\n\t} else if (strcmp(name, \"text-alignment\") == 0) {\n\t\tif (strcmp(value, \"left\") == 0) {\n\t\t\tstyle->text_alignment = PANGO_ALIGN_LEFT;\n\t\t} else if (strcmp(value, \"center\") == 0) {\n\t\t\tstyle->text_alignment = PANGO_ALIGN_CENTER;\n\t\t} else if (strcmp(value, \"right\") == 0) {\n\t\t\tstyle->text_alignment = PANGO_ALIGN_RIGHT;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tstyle->spec.text_alignment = true;\n\t\treturn true;\n\t} else if (strcmp(name, \"default-timeout\") == 0) {\n\t\treturn spec->default_timeout =\n\t\t\tparse_int_ge(value, &style->default_timeout, 0);\n\t} else if (strcmp(name, \"ignore-timeout\") == 0) {\n\t\treturn spec->ignore_timeout =\n\t\t\tparse_boolean(value, &style->ignore_timeout);\n\t} else if (strcmp(name, \"group-by\") == 0) {\n\t\treturn spec->group_criteria_spec =\n\t\t\tparse_criteria_spec(value, &style->group_criteria_spec);\n\t} else if (strcmp(name, \"invisible\") == 0) {\n\t\treturn spec->invisible = parse_boolean(value, &style->invisible);\n\t} else if (strcmp(name, \"history\") == 0) {\n\t\treturn spec->history = parse_boolean(value, &style->history);\n\t} else if (strcmp(name, \"border-radius\") == 0) {\n\t\tspec->border_radius = parse_int_ge(value, &style->border_radius, 0);\n\t\tif (spec->border_radius && spec->padding) {\n\t\t\tstyle->padding.left = max(style->border_radius, style->padding.left);\n\t\t\tstyle->padding.right = max(style->border_radius, style->padding.right);\n\t\t}\n\t\treturn spec->border_radius;\n\t} else if (strcmp(name, \"max-visible\") == 0) {\n\t\treturn style->spec.max_visible = parse_int(value, &style->max_visible);\n\t} else if (strcmp(name, \"output\") == 0) {\n\t\tfree(style->output);\n\t\tstyle->output = strdup(value);\n\t\tstyle->spec.output = true;\n\t\treturn true;\n\t} else if (strcmp(name, \"layer\") == 0) {\n\t\tif (strcmp(value, \"background\") == 0) {\n\t\t\tstyle->layer = ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND;\n\t\t} else if (strcmp(value, \"bottom\") == 0) {\n\t\t\tstyle->layer = ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM;\n\t\t} else if (strcmp(value, \"top\") == 0) {\n\t\t\tstyle->layer = ZWLR_LAYER_SHELL_V1_LAYER_TOP;\n\t\t} else if (strcmp(value, \"overlay\") == 0) {\n\t\t\tstyle->layer = ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\tstyle->spec.layer = true;\n\t\treturn true;\n\t} else if (strcmp(name, \"anchor\") == 0) {\n\t\treturn spec->anchor = parse_anchor(value, &style->anchor);\n\t} else if (has_prefix(name, \"on-\")) {\n\t\tstruct mako_binding binding = {0};\n\t\tif (strcmp(value, \"none\") == 0) {\n\t\t\tbinding.action = MAKO_BINDING_NONE;\n\t\t} else if (strcmp(value, \"dismiss\") == 0) {\n\t\t\tbinding.action = MAKO_BINDING_DISMISS;\n\t\t} else if (strcmp(value, \"dismiss --no-history\") == 0) {\n\t\t\tbinding.action = MAKO_BINDING_DISMISS_NO_HISTORY;\n\t\t} else if (strcmp(value, \"dismiss-all\") == 0) {\n\t\t\tbinding.action = MAKO_BINDING_DISMISS_ALL;\n\t\t} else if (strcmp(value, \"dismiss-group\") == 0) {\n\t\t\tbinding.action = MAKO_BINDING_DISMISS_GROUP;\n\t\t} else if (strcmp(value, \"invoke-default-action\") == 0) {\n\t\t\tbinding.action = MAKO_BINDING_INVOKE_ACTION;\n\t\t\tbinding.action_name = strdup(DEFAULT_ACTION_KEY);\n\t\t} else if (has_prefix(value, \"invoke-action \")) {\n\t\t\tbinding.action = MAKO_BINDING_INVOKE_ACTION;\n\t\t\tbinding.action_name = strdup(value + strlen(\"invoke-action \"));\n\t\t} else if (has_prefix(value, \"exec \")) {\n\t\t\tbinding.action = MAKO_BINDING_EXEC;\n\t\t\tbinding.command = strdup(value + strlen(\"exec \"));\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (strcmp(name, \"on-button-left\") == 0) {\n\t\t\tcopy_binding(&style->button_bindings.left, &binding);\n\t\t\tstyle->spec.button_bindings.left = true;\n\t\t} else if (strcmp(name, \"on-button-right\") == 0) {\n\t\t\tcopy_binding(&style->button_bindings.right, &binding);\n\t\t\tstyle->spec.button_bindings.right = true;\n\t\t} else if (strcmp(name, \"on-button-middle\") == 0) {\n\t\t\tcopy_binding(&style->button_bindings.middle, &binding);\n\t\t\tstyle->spec.button_bindings.middle = true;\n\t\t} else if (strcmp(name, \"on-touch\") == 0) {\n\t\t\tcopy_binding(&style->touch_binding, &binding);\n\t\t\tstyle->spec.touch_binding = true;\n\t\t} else if (strcmp(name, \"on-notify\") == 0) {\n\t\t\tcopy_binding(&style->notify_binding, &binding);\n\t\t\tstyle->spec.notify_binding = true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool apply_global_option(struct mako_config *config, const char *name,\n\t\tconst char *value) {\n\tstruct mako_criteria *global = global_criteria(config);\n\treturn apply_style_option(&global->style, name, value) ||\n\t\tapply_config_option(config, name, value);\n}\n\nstatic bool file_exists(const char *path) {\n\treturn path && access(path, R_OK) != -1;\n}\n\nstatic char *get_default_config_path() {\n\tconst char *home = getenv(\"HOME\");\n\tif (home == NULL) {\n\t\tfprintf(stderr, \"HOME env var not set\\n\");\n\t\treturn NULL;\n\t}\n\n\tconst char *config_home = getenv(\"XDG_CONFIG_HOME\");\n\tchar *config_home_fallback = NULL;\n\tif (config_home == NULL || config_home[0] == '\\0') {\n\t\tconfig_home_fallback = mako_asprintf(\"%s/.config\", home);\n\t\tconfig_home = config_home_fallback;\n\t}\n\n\tchar *config_paths[] = {\n\t\tmako_asprintf(\"%s/.mako/config\", home),\n\t\tmako_asprintf(\"%s/mako/config\", config_home),\n\t};\n\n\tsize_t config_paths_len = sizeof(config_paths) / sizeof(config_paths[0]);\n\tchar *found_path = NULL;\n\tfor (size_t i = 0; i < config_paths_len; ++i) {\n\t\tchar *path = config_paths[i];\n\t\tif (file_exists(path)) {\n\t\t\tfound_path = strdup(path);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (size_t i = 0; i < config_paths_len; ++i) {\n\t\tfree(config_paths[i]);\n\t}\n\tfree(config_home_fallback);\n\n\treturn found_path;\n}\n\nint load_config_file(struct mako_config *config, char *path) {\n\tFILE *f = fopen(path, \"r\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Unable to open %s for reading\\n\", path);\n\t\tfree(path);\n\t\treturn -1;\n\t}\n\tconst char *base = basename(path);\n\n\tint ret = 0;\n\tint lineno = 0;\n\tchar *line = NULL;\n\tchar *section = NULL;\n\n\t// Until we hit the first criteria section, we want to be modifying the\n\t// root criteria's style. We know it's always the first one in the list.\n\tstruct mako_criteria *criteria =\n\t\twl_container_of(config->criteria.next, criteria, link);\n\n\tsize_t n = 0;\n\twhile (getline(&line, &n, f) > 0) {\n\t\t++lineno;\n\t\tif (line[0] == '\\0' || line[0] == '\\n' || line[0] == '#') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (line[strlen(line) - 1] == '\\n') {\n\t\t\tline[strlen(line) - 1] = '\\0';\n\t\t}\n\n\t\tif (line[0] == '[' && line[strlen(line) - 1] == ']') {\n\t\t\t// Since we hit the end of the previous criteria section, validate\n\t\t\t// that it doesn't break any rules before moving on.\n\t\t\tif (criteria != NULL && !validate_criteria(criteria)) {\n\t\t\t\tfprintf(stderr, \"Invalid configuration in criteria: [%s]\\n\",\n\t\t\t\t\t\tcriteria->raw_string);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree(section);\n\t\t\tsection = strndup(line + 1, strlen(line) - 2);\n\t\t\tcriteria = create_criteria(config);\n\t\t\tif (!parse_criteria(section, criteria)) {\n\t\t\t\tfprintf(stderr, \"[%s:%d] Invalid criteria definition\\n\", base,\n\t\t\t\t\t\tlineno);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *eq = strchr(line, '=');\n\t\tif (!eq) {\n\t\t\tfprintf(stderr, \"[%s:%d] Expected key=value\\n\", base, lineno);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tbool valid_option = false;\n\t\teq[0] = '\\0';\n\n\t\tvalid_option = apply_style_option(&criteria->style, line, eq + 1);\n\n\t\tif (!valid_option && section == NULL) {\n\t\t\tvalid_option = apply_config_option(config, line, eq + 1);\n\t\t}\n\n\t\tif (!valid_option) {\n\t\t\tfprintf(stderr, \"[%s:%d] Failed to parse option '%s'\\n\",\n\t\t\t\tbase, lineno, line);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Validate the final criteria section since there was no opening bracket\n\t// after it to do this in the loop.\n\tif (ret != -1 && criteria != NULL && !validate_criteria(criteria)) {\n\t\tfprintf(stderr, \"Invalid configuration in criteria: [%s]\\n\",\n\t\t\t\tcriteria->raw_string);\n\t\tret = -1;\n\t}\n\n\tfree(section);\n\tfree(line);\n\tfclose(f);\n\tfree(path);\n\treturn ret;\n}\n\nint parse_config_arguments(struct mako_config *config, int argc, char **argv) {\n\tstatic const struct option long_options[] = {\n\t\t{\"help\", no_argument, 0, 'h'},\n\t\t{\"config\", required_argument, 0, 'c'},\n\t\t{\"font\", required_argument, 0, 0},\n\t\t{\"background-color\", required_argument, 0, 0},\n\t\t{\"text-color\", required_argument, 0, 0},\n\t\t{\"width\", required_argument, 0, 0},\n\t\t{\"height\", required_argument, 0, 0},\n\t\t{\"outer-margin\", required_argument, 0, 0},\n\t\t{\"margin\", required_argument, 0, 0},\n\t\t{\"padding\", required_argument, 0, 0},\n\t\t{\"border-size\", required_argument, 0, 0},\n\t\t{\"border-color\", required_argument, 0, 0},\n\t\t{\"border-radius\", required_argument, 0, 0},\n\t\t{\"progress-color\", required_argument, 0, 0},\n\t\t{\"icons\", required_argument, 0, 0},\n\t\t{\"icon-location\", required_argument, 0, 0},\n\t\t{\"icon-path\", required_argument, 0, 0},\n\t\t{\"max-icon-size\", required_argument, 0, 0},\n\t\t{\"markup\", required_argument, 0, 0},\n\t\t{\"actions\", required_argument, 0, 0},\n\t\t{\"format\", required_argument, 0, 0},\n\t\t{\"max-visible\", required_argument, 0, 0},\n\t\t{\"max-history\", required_argument, 0, 0},\n\t\t{\"history\", required_argument, 0, 0},\n\t\t{\"default-timeout\", required_argument, 0, 0},\n\t\t{\"ignore-timeout\", required_argument, 0, 0},\n\t\t{\"output\", required_argument, 0, 0},\n\t\t{\"layer\", required_argument, 0, 0},\n\t\t{\"anchor\", required_argument, 0, 0},\n\t\t{\"sort\", required_argument, 0, 0},\n\t\t{\"group-by\", required_argument, 0, 0},\n\t\t{\"on-button-left\", required_argument, 0, 0},\n\t\t{\"on-button-right\", required_argument, 0, 0},\n\t\t{\"on-button-middle\", required_argument, 0, 0},\n\t\t{\"on-touch\", required_argument, 0, 0},\n\t\t{0},\n\t};\n\n\toptind = 1;\n\tchar *config_arg = NULL;\n\tint opt_status = 0;\n\twhile (1) {\n\t\tint option_index = -1;\n\t\tint c = getopt_long(argc, argv, \"hc:\", long_options, &option_index);\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t} else if (c == 'h') {\n\t\t\topt_status = 1;\n\t\t\tbreak;\n\t\t} else if (c == 'c') {\n\t\t\tfree(config_arg);\n\t\t\tconfig_arg = strdup(optarg);\n\t\t} else if (c != 0) {\n\t\t\topt_status = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt_status != 0) {\n\t\tfree(config_arg);\n\t\treturn opt_status;\n\t}\n\n\tchar *config_path = config_arg ? config_arg : get_default_config_path();\n\tif (config_path) {\n\t\tint config_status = load_config_file(config, config_path);\n\t\tif (config_status < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\toptind = 1;\n\twhile (1) {\n\t\tint option_index = -1;\n\t\tint c = getopt_long(argc, argv, \"hc:\", long_options, &option_index);\n\t\tif (c < 0) {\n\t\t\tbreak;\n\t\t} else if (c == 'h' || c == 'c') {\n\t\t\tcontinue;\n\t\t} else if (c != 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tconst char *name = long_options[option_index].name;\n\t\tif (!apply_global_option(config, name, optarg)) {\n\t\t\tfprintf(stderr, \"Failed to parse option '%s'\\n\", name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// Returns zero on success, negative on error, positive if we should exit\n// immediately due to something the user asked for (like help).\nint reload_config(struct mako_config *config, int argc, char **argv) {\n\tstruct mako_config new_config = {0};\n\tinit_default_config(&new_config);\n\n\tint args_status = parse_config_arguments(&new_config, argc, argv);\n\n\tif (args_status > 0) {\n\t\tfinish_config(&new_config);\n\t\treturn args_status;\n\t} else if (args_status < 0) {\n\t\tfprintf(stderr, \"Failed to parse config\\n\");\n\t\tfinish_config(&new_config);\n\t\treturn -1;\n\t}\n\n\tapply_superset_style(&new_config.superstyle, &new_config);\n\n\tfinish_config(config);\n\t*config = new_config;\n\n\t// We have to rebuild the wl_list that contains the criteria, as it is\n\t// currently pointing to local memory instead of the location of the real\n\t// criteria struct.\n\twl_list_init(&config->criteria);\n\twl_list_insert_list(&config->criteria, &new_config.criteria);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "criteria.c",
          "type": "blob",
          "size": 15.642578125,
          "content": "#include <assert.h>\n#include <regex.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <wayland-client.h>\n\n#include \"enum.h\"\n#include \"mako.h\"\n#include \"config.h\"\n#include \"criteria.h\"\n#include \"mode.h\"\n#include \"notification.h\"\n#include \"surface.h\"\n#include \"wayland.h\"\n\nstruct mako_criteria *create_criteria(struct mako_config *config) {\n\tstruct mako_criteria *criteria = calloc(1, sizeof(struct mako_criteria));\n\tif (criteria == NULL) {\n\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\twl_list_insert(config->criteria.prev, &criteria->link);\n\treturn criteria;\n}\n\nvoid destroy_criteria(struct mako_criteria *criteria) {\n\twl_list_remove(&criteria->link);\n\n\tfinish_style(&criteria->style);\n\tfree(criteria->app_name);\n\tfree(criteria->app_icon);\n\tfree(criteria->category);\n\tfree(criteria->desktop_entry);\n\tfree(criteria->summary);\n\tregfree(&criteria->summary_pattern);\n\tfree(criteria->body);\n\tregfree(&criteria->body_pattern);\n\tfree(criteria->raw_string);\n\tfree(criteria->output);\n\tfree(criteria->mode);\n\tfree(criteria);\n}\n\nstatic bool match_regex_criteria(regex_t *pattern, char *value) {\n\tint ret = regexec(pattern, value, 0, NULL, 0);\n\tif (ret != 0) {\n\t\tif (ret != REG_NOMATCH) {\n\t\t\tsize_t errlen = regerror(ret, pattern, NULL, 0);\n\t\t\tchar errbuf[errlen];\n\t\t\tregerror(ret, pattern, errbuf, sizeof(errbuf));\n\t\t\tfprintf(stderr, \"failed to match regex: %s\\n\", errbuf);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool match_criteria(struct mako_criteria *criteria,\n\t\tstruct mako_notification *notif) {\n\tstruct mako_criteria_spec spec = criteria->spec;\n\n\tif (spec.none) {\n\t\t// `none` short-circuits all other criteria.\n\t\treturn false;\n\t}\n\n\tif (spec.hidden &&\n\t\t\tcriteria->hidden != notif->hidden) {\n\t\treturn false;\n\t}\n\n\tif (spec.app_name &&\n\t\t\tstrcmp(criteria->app_name, notif->app_name) != 0) {\n\t\treturn false;\n\t}\n\n\tif (spec.app_icon &&\n\t\t\tstrcmp(criteria->app_icon, notif->app_icon) != 0) {\n\t\treturn false;\n\t}\n\n\tif (spec.actionable &&\n\t\t\tcriteria->actionable == wl_list_empty(&notif->actions)) {\n\t\treturn false;\n\t}\n\n\tif (spec.expiring &&\n\t\t\tcriteria->expiring != (notif->requested_timeout != 0)) {\n\t\treturn false;\n\t}\n\n\tif (spec.urgency &&\n\t\t\tcriteria->urgency != notif->urgency) {\n\t\treturn false;\n\t}\n\n\tif (spec.category &&\n\t\t\tstrcmp(criteria->category, notif->category) != 0) {\n\t\treturn false;\n\t}\n\n\tif (spec.desktop_entry &&\n\t\t\tstrcmp(criteria->desktop_entry, notif->desktop_entry) != 0) {\n\t\treturn false;\n\t}\n\n\tif (spec.summary &&\n\t\t\tstrcmp(criteria->summary, notif->summary) != 0) {\n\t\treturn false;\n\t}\n\n\tif (spec.summary_pattern) {\n\t\tbool ret = match_regex_criteria(&criteria->summary_pattern, notif->summary);\n\t\tif (!ret) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (spec.body &&\n\t\t\tstrcmp(criteria->body, notif->body) != 0) {\n\t\treturn false;\n\t}\n\n\tif (spec.body_pattern) {\n\t\tbool ret = match_regex_criteria(&criteria->body_pattern, notif->body);\n\t\tif (!ret) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (spec.group_index &&\n\t\t\tcriteria->group_index != notif->group_index) {\n\t\treturn false;\n\t}\n\n\tif (spec.grouped &&\n\t\t\tcriteria->grouped != (notif->group_index >= 0)) {\n\t\treturn false;\n\t}\n\n\tif (spec.anchor && (notif->surface == NULL ||\n\t\t\tcriteria->anchor != notif->surface->anchor)) {\n\t\treturn false;\n\t}\n\n\tif (spec.output && (notif->surface == NULL ||\n\t\t\t\tnotif->surface->surface_output == NULL ||\n\t\t\t\tstrcmp(criteria->output, notif->surface->surface_output->name) != 0)) {\n\t\treturn false;\n\t}\n\n\tif (spec.mode && !has_mode(notif->state, criteria->mode)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool parse_criteria(const char *string, struct mako_criteria *criteria) {\n\t// Create space to build up the current token that we're reading. We know\n\t// that no single token can ever exceed the length of the entire criteria\n\t// string, so that's a safe length to use for the buffer.\n\tint token_max_length = strlen(string) + 1;\n\tchar token[token_max_length];\n\tmemset(token, 0, token_max_length);\n\tsize_t token_location = 0;\n\n\tenum mako_parse_state state = MAKO_PARSE_STATE_NORMAL;\n\tconst char *location = string;\n\n\tchar ch;\n\twhile ((ch = *location++) != '\\0') {\n\t\tswitch (state) {\n\t\tcase MAKO_PARSE_STATE_ESCAPE:\n\t\tcase MAKO_PARSE_STATE_QUOTE_ESCAPE:\n\t\t\ttoken[token_location] = ch;\n\t\t\t++token_location;\n\t\t\tstate &= ~MAKO_PARSE_STATE_ESCAPE; // These work as a bitmask.\n\t\t\tbreak;\n\n\t\tcase MAKO_PARSE_STATE_QUOTE:\n\t\t\tswitch (ch) {\n\t\t\tcase '\\\\':\n\t\t\t\tstate = MAKO_PARSE_STATE_QUOTE_ESCAPE;\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tstate = MAKO_PARSE_STATE_NORMAL;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\tdefault:\n\t\t\t\ttoken[token_location] = ch;\n\t\t\t\t++token_location;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MAKO_PARSE_STATE_NORMAL:\n\t\t\tswitch (ch) {\n\t\t\tcase '\\\\':\n\t\t\t\tstate = MAKO_PARSE_STATE_ESCAPE;\n\t\t\t\tbreak;\n\t\t\tcase '\"':\n\t\t\t\tstate = MAKO_PARSE_STATE_QUOTE;\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\t\t// New token, apply the old one and reset our state.\n\t\t\t\tif (!apply_criteria_field(criteria, token)) {\n\t\t\t\t\t// An error should have been printed already.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tmemset(token, 0, token_max_length);\n\t\t\t\ttoken_location = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttoken[token_location] = ch;\n\t\t\t\t++token_location;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MAKO_PARSE_STATE_FORMAT:\n\t\t\t// Unsupported state for this parser.\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (state != MAKO_PARSE_STATE_NORMAL) {\n\t\tif (state & MAKO_PARSE_STATE_QUOTE) {\n\t\t\tfprintf(stderr, \"Unmatched quote in criteria definition\\n\");\n\t\t\treturn false;\n\t\t} else if (state & MAKO_PARSE_STATE_ESCAPE) {\n\t\t\tfprintf(stderr, \"Trailing backslash in criteria definition\\n\");\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Got confused parsing criteria definition\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Apply the last token, which will be left in the buffer after we hit the\n\t// final NULL. We know it's valid since we just checked for that.\n\tif (!apply_criteria_field(criteria, token)) {\n\t\t// An error should have been printed by this point, we don't need to.\n\t\treturn false;\n\t}\n\n\t// All user-specified criteria are implicitly unhidden by default. This\n\t// prevents any criteria sections that don't explicitly set `hidden` from\n\t// styling the hidden pseudo-notification.\n\tif (!criteria->spec.hidden) {\n\t\tcriteria->hidden = false;\n\t\tcriteria->spec.hidden = true;\n\t}\n\n\tcriteria->raw_string = strdup(string);\n\treturn true;\n}\n\n// Takes a token from the criteria string that looks like \"key=value\", figures\n// out which field of the criteria \"key\" refers to, and sets it to \"value\".\n// Any further equal signs are assumed to be part of the value. If there is no .\n// equal sign present, the field is treated as a boolean, with a leading\n// exclamation point signifying negation.\n//\n// Note that the token will be consumed.\nbool apply_criteria_field(struct mako_criteria *criteria, char *token) {\n\tchar *key = token;\n\tchar *value = strstr(key, \"=\");\n\tbool bare_key = !value;\n\n\tif (*key == '\\0') {\n\t\treturn true;\n\t}\n\n\tif (value) {\n\t\t// Skip past the equal sign to the value itself.\n\t\t*value = '\\0';\n\t\t++value;\n\t} else {\n\t\t// If there's no value, assume it's a boolean, and set the value\n\t\t// appropriately. This allows uniform parsing later on.\n\t\tif (*key == '!') {\n\t\t\t// Negated boolean, skip past the exclamation point.\n\t\t\t++key;\n\t\t\tvalue = \"false\";\n\t\t} else {\n\t\t\tvalue = \"true\";\n\t\t}\n\t}\n\n\t// Now apply the value to the appropriate member of the criteria.\n\t// If the value was omitted, only try to match against boolean fields.\n\t// Otherwise, anything is fair game. This helps to return a better error\n\t// message.\n\n\tif (!bare_key) {\n\t\tif (strcmp(key, \"app-name\") == 0) {\n\t\t\tcriteria->app_name = strdup(value);\n\t\t\tcriteria->spec.app_name = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"app-icon\") == 0) {\n\t\t\tcriteria->app_icon = strdup(value);\n\t\t\tcriteria->spec.app_icon = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"urgency\") == 0) {\n\t\t\tif (!parse_urgency(value, &criteria->urgency)) {\n\t\t\t\tfprintf(stderr, \"Invalid urgency value '%s'\", value);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcriteria->spec.urgency = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"category\") == 0) {\n\t\t\tcriteria->category = strdup(value);\n\t\t\tcriteria->spec.category = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"desktop-entry\") == 0) {\n\t\t\tcriteria->desktop_entry = strdup(value);\n\t\t\tcriteria->spec.desktop_entry = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"group-index\") == 0) {\n\t\t\tif (!parse_int(value, &criteria->group_index)) {\n\t\t\t\tfprintf(stderr, \"Invalid group-index value '%s'\", value);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcriteria->spec.group_index = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"summary\") == 0) {\n\t\t\tcriteria->summary = strdup(value);\n\t\t\tcriteria->spec.summary = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"summary~\") == 0) {\n\t\t\tif (regcomp(&criteria->summary_pattern, value,\n\t\t\t\t\tREG_EXTENDED | REG_NOSUB)) {\n\t\t\t\tfprintf(stderr, \"Invalid summary~ regex '%s'\\n\", value);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcriteria->spec.summary_pattern = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"body\") == 0) {\n\t\t\tcriteria->body = strdup(value);\n\t\t\tcriteria->spec.body = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"body~\") == 0) {\n\t\t\tif (regcomp(&criteria->body_pattern, value,\n\t\t\t\t\tREG_EXTENDED | REG_NOSUB)) {\n\t\t\t\tfprintf(stderr, \"Invalid body~ regex '%s'\\n\", value);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcriteria->spec.body_pattern = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"anchor\") == 0) {\n\t\t\treturn criteria->spec.anchor =\n\t\t\t\tparse_anchor(value, &criteria->anchor);\n\t\t} else if (strcmp(key, \"output\") == 0) {\n\t\t\tcriteria->output = strdup(value);\n\t\t\tcriteria->spec.output = true;\n\t\t\treturn true;\n\t\t} else if (strcmp(key, \"mode\") == 0) {\n\t\t\tcriteria->mode = strdup(value);\n\t\t\tcriteria->spec.mode = true;\n\t\t\treturn true;\n\t\t} else {\n\t\t\t// Anything left must be one of the boolean fields, defined using\n\t\t\t// standard syntax. Continue on.\n\t\t}\n\t}\n\n\tif (strcmp(key, \"actionable\") == 0) {\n\t\tif (!parse_boolean(value, &criteria->actionable)) {\n\t\t\tfprintf(stderr, \"Invalid value '%s' for boolean field '%s'\\n\",\n\t\t\t\t\tvalue, key);\n\t\t\treturn false;\n\t\t}\n\t\tcriteria->spec.actionable = true;\n\t\treturn true;\n\t} else if (strcmp(key, \"expiring\") == 0){\n\t\tif (!parse_boolean(value, &criteria->expiring)) {\n\t\t\tfprintf(stderr, \"Invalid value '%s' for boolean field '%s'\\n\",\n\t\t\t\t\tvalue, key);\n\t\t\treturn false;\n\t\t}\n\t\tcriteria->spec.expiring = true;\n\t\treturn true;\n\t} else if (strcmp(key, \"grouped\") == 0) {\n\t\tif (!parse_boolean(value, &criteria->grouped)) {\n\t\t\tfprintf(stderr, \"Invalid value '%s' for boolean field '%s'\\n\",\n\t\t\t\t\tvalue, key);\n\t\t\treturn false;\n\t\t}\n\t\tcriteria->spec.grouped = true;\n\t\treturn true;\n\t} else if (strcmp(key, \"hidden\") == 0) {\n\t\tif (!parse_boolean(value, &criteria->hidden)) {\n\t\t\tfprintf(stderr, \"Invalid value '%s' for boolean field '%s'\\n\",\n\t\t\t\t\tvalue, key);\n\t\t\treturn false;\n\t\t}\n\t\tcriteria->spec.hidden = true;\n\t\treturn true;\n\t} else {\n\t\tif (bare_key) {\n\t\t\tfprintf(stderr, \"Invalid boolean criteria field '%s'\\n\", key);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Invalid criteria field '%s'\\n\", key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tassert(false && \"Criteria parser fell through\");\n}\n\n// Retrieve the global criteria from a given mako_config. This just so happens\n// to be the first criteria in the list.\nstruct mako_criteria *global_criteria(struct mako_config *config) {\n\tstruct mako_criteria *criteria =\n\t\twl_container_of(config->criteria.next, criteria, link);\n\treturn criteria;\n}\n\n// Iterate through `criteria_list`, applying the style from each matching\n// criteria to `notif`. Returns the number of criteria that matched, or -1 if\n// a failure occurs.\nssize_t apply_each_criteria(struct wl_list *criteria_list,\n\t\tstruct mako_notification *notif) {\n\tssize_t match_count = 0;\n\n\tstruct mako_criteria *criteria;\n\twl_list_for_each(criteria, criteria_list, link) {\n\t\tif (!match_criteria(criteria, notif)) {\n\t\t\tcontinue;\n\t\t}\n\t\t++match_count;\n\n\t\tif (!apply_style(&notif->style, &criteria->style)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tstruct mako_surface *surface;\n\twl_list_for_each(surface, &notif->state->surfaces, link) {\n\t\tif (!strcmp(surface->configured_output, notif->style.output) &&\n\t\t\t\tsurface->anchor == notif->style.anchor &&\n\t\t\t\tsurface->layer == notif->style.layer) {\n\t\t\tnotif->surface = surface;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!notif->surface) {\n\t\tnotif->surface = create_surface(notif->state, notif->style.output,\n\t\t\tnotif->style.layer, notif->style.anchor);\n\t}\n\n\treturn match_count;\n}\n\n// Given a notification and a criteria spec, create a criteria that matches the\n// specified fields of that notification. Unlike create_criteria, this new\n// criteria will not be automatically inserted into the configuration. It is\n// instead intended to be used for comparing notifications. The spec will be\n// copied, so the caller is responsible for doing whatever it needs to do with\n// the original after the call completes.\nstruct mako_criteria *create_criteria_from_notification(\n\t\tstruct mako_notification *notif, struct mako_criteria_spec *spec) {\n\tstruct mako_criteria *criteria = calloc(1, sizeof(struct mako_criteria));\n\tif (criteria == NULL) {\n\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\twl_list_init(&criteria->link);\n\n\tmemcpy(&criteria->spec, spec, sizeof(struct mako_criteria_spec));\n\n\t// We only really need to copy the ones that are in the spec, but it\n\t// doesn't hurt anything to do the rest and it makes this code much nicer\n\t// to look at.\n\tcriteria->app_name = strdup(notif->app_name);\n\tcriteria->app_icon = strdup(notif->app_icon);\n\tcriteria->actionable = !wl_list_empty(&notif->actions);\n\tcriteria->expiring = (notif->requested_timeout != 0);\n\tcriteria->urgency = notif->urgency;\n\tcriteria->category = strdup(notif->category);\n\tcriteria->desktop_entry = strdup(notif->desktop_entry);\n\tcriteria->summary = strdup(notif->summary);\n\tcriteria->body = strdup(notif->body);\n\tcriteria->group_index = notif->group_index;\n\tcriteria->grouped = (notif->group_index >= 0);\n\tcriteria->hidden = notif->hidden;\n\n\treturn criteria;\n}\n\n\n// To keep the behavior of criteria predictable, there are a few rules that we\n// have to impose on what can be modified depending on what was matched.\nbool validate_criteria(struct mako_criteria *criteria) {\n\tchar * invalid_option = NULL;\n\n\tif (criteria->spec.grouped ||\n\t\t\tcriteria->spec.group_index ||\n\t\t\tcriteria->spec.output ||\n\t\t\tcriteria->spec.anchor) {\n\t\tif (criteria->style.spec.anchor) {\n\t\t\tinvalid_option = \"anchor\";\n\t\t} else if (criteria->style.spec.output) {\n\t\t\tinvalid_option = \"output\";\n\t\t} else if (criteria->style.spec.group_criteria_spec) {\n\t\t\tinvalid_option = \"group-by\";\n\t\t}\n\n\t\tif (invalid_option) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Setting `%s` is not allowed when matching `grouped`, \"\n\t\t\t\t\t\"`group-index`, `output`, or `anchor`\\n\",\n\t\t\t\t\tinvalid_option);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstruct mako_criteria_spec copy = {0};\n\tmemcpy(&copy, &criteria->spec, sizeof(struct mako_criteria_spec));\n\tcopy.output = false;\n\tcopy.anchor = false;\n\tcopy.hidden = false;\n\tbool any_but_surface = mako_criteria_spec_any(&copy);\n\n\tif (criteria->style.max_visible && any_but_surface) {\n\t\tfprintf(stderr, \"Setting `max_visible` is allowed only for `output` \"\n\t\t\t\t\"and/or `anchor`\\n\");\n\t\treturn false;\n\t}\n\n\t// Hidden is almost always specified, need to look at the actual value.\n\tif (criteria->hidden && any_but_surface) {\n\t\tfprintf(stderr, \"Can only set `hidden` along with `output` \"\n\t\t\t\t\"and/or `anchor`\\n\");\n\t\treturn false;\n\t}\n\n\tif (criteria->spec.summary && criteria->spec.summary_pattern) {\n\t\tfprintf(stderr, \"Cannot set both `summary` and `summary~`\\n\");\n\t\treturn false;\n\t}\n\n\tif (criteria->spec.body && criteria->spec.body_pattern) {\n\t\tfprintf(stderr, \"Cannot set both `body` and `body~`\\n\");\n\t\treturn false;\n\t}\n\n\tif (criteria->style.spec.group_criteria_spec) {\n\t\tstruct mako_criteria_spec *spec = &criteria->style.group_criteria_spec;\n\n\t\tif (spec->group_index) {\n\t\t\tinvalid_option = \"group-index\";\n\t\t} else if (spec->grouped) {\n\t\t\tinvalid_option = \"grouped\";\n\t\t} else if (spec->anchor) {\n\t\t\tinvalid_option = \"anchor\";\n\t\t} else if (spec->output) {\n\t\t\tinvalid_option = \"output\";\n\t\t}\n\n\t\tif (invalid_option) {\n\t\t\tfprintf(stderr, \"`%s` cannot be used in `group-by`\\n\",\n\t\t\t\t\tinvalid_option);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n"
        },
        {
          "name": "dbus",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "event-loop.c",
          "type": "blob",
          "size": 6.1083984375,
          "content": "#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/timerfd.h>\n#include <signal.h>\n#include <sys/signalfd.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"event-loop.h\"\n\nstatic int init_signalfd() {\n\tsigset_t mask;\n\tint sfd;\n\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGINT);\n\tsigaddset(&mask, SIGTERM);\n\tsigaddset(&mask, SIGQUIT);\n\n\tif (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {\n\t\tfprintf(stderr, \"sigprocmask: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif ((sfd = signalfd(-1, &mask, SFD_NONBLOCK)) == -1) {\n\t\tfprintf(stderr, \"signalfd: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}\n\nbool init_event_loop(struct mako_event_loop *loop, sd_bus *bus,\n\t\tstruct wl_display *display) {\n\tif ((loop->sfd = init_signalfd()) == -1) {\n\t\treturn false;\n\t}\n\n\tloop->fds[MAKO_EVENT_SIGNAL] = (struct pollfd){\n\t\t.fd = loop->sfd,\n\t\t.events = POLLIN,\n\t};\n\n\tloop->fds[MAKO_EVENT_DBUS] = (struct pollfd){\n\t\t.fd = sd_bus_get_fd(bus),\n\t\t.events = POLLIN,\n\t};\n\n\tloop->fds[MAKO_EVENT_WAYLAND] = (struct pollfd){\n\t\t.fd = wl_display_get_fd(display),\n\t\t.events = POLLIN,\n\t};\n\n\tloop->fds[MAKO_EVENT_TIMER] = (struct pollfd){\n\t\t.fd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC),\n\t\t.events = POLLIN,\n\t};\n\n\tloop->bus = bus;\n\tloop->display = display;\n\twl_list_init(&loop->timers);\n\n\treturn true;\n}\n\nvoid finish_event_loop(struct mako_event_loop *loop) {\n\tclose(loop->fds[MAKO_EVENT_TIMER].fd);\n\tloop->fds[MAKO_EVENT_TIMER].fd = -1;\n\n\tstruct mako_timer *timer, *tmp;\n\twl_list_for_each_safe(timer, tmp, &loop->timers, link) {\n\t\tdestroy_timer(timer);\n\t}\n}\n\nstatic void timespec_add(struct timespec *t, int delta_ms) {\n\tstatic const long ms = 1000000, s = 1000000000;\n\n\tint delta_ms_low = delta_ms % 1000;\n\tint delta_s_high = delta_ms / 1000;\n\n\tt->tv_sec += delta_s_high;\n\n\tt->tv_nsec += (long)delta_ms_low * ms;\n\tif (t->tv_nsec >= s) {\n\t\tt->tv_nsec -= s;\n\t\t++t->tv_sec;\n\t}\n}\n\nstatic bool timespec_less(struct timespec *t1, struct timespec *t2) {\n\tif (t1->tv_sec != t2->tv_sec) {\n\t\treturn t1->tv_sec < t2->tv_sec;\n\t}\n\treturn t1->tv_nsec < t2->tv_nsec;\n}\n\nstatic void update_event_loop_timer(struct mako_event_loop *loop) {\n\tint timer_fd = loop->fds[MAKO_EVENT_TIMER].fd;\n\tif (timer_fd < 0) {\n\t\treturn;\n\t}\n\n\tbool updated = false;\n\tstruct mako_timer *timer;\n\twl_list_for_each(timer, &loop->timers, link) {\n\t\tif (loop->next_timer == NULL ||\n\t\t\t\ttimespec_less(&timer->at, &loop->next_timer->at)) {\n\t\t\tloop->next_timer = timer;\n\t\t\tupdated = true;\n\t\t}\n\t}\n\n\tif (updated) {\n\t\tstruct itimerspec delay = { .it_value = loop->next_timer->at };\n\t\terrno = 0;\n\t\tint ret = timerfd_settime(timer_fd, TFD_TIMER_ABSTIME, &delay, NULL);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"failed to timerfd_settime(): %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t}\n}\n\nstruct mako_timer *add_event_loop_timer(struct mako_event_loop *loop,\n\t\tint delay_ms, mako_event_loop_timer_func_t func, void *data) {\n\tstruct mako_timer *timer = calloc(1, sizeof(struct mako_timer));\n\tif (timer == NULL) {\n\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\ttimer->event_loop = loop;\n\ttimer->func = func;\n\ttimer->user_data = data;\n\twl_list_insert(&loop->timers, &timer->link);\n\n\tclock_gettime(CLOCK_MONOTONIC, &timer->at);\n\ttimespec_add(&timer->at, delay_ms);\n\n\tupdate_event_loop_timer(loop);\n\treturn timer;\n}\n\nvoid destroy_timer(struct mako_timer *timer) {\n\tif (timer == NULL) {\n\t\treturn;\n\t}\n\tstruct mako_event_loop *loop = timer->event_loop;\n\n\tif (loop->next_timer == timer) {\n\t\tloop->next_timer = NULL;\n\t}\n\n\twl_list_remove(&timer->link);\n\tfree(timer);\n\n\tupdate_event_loop_timer(loop);\n}\n\nstatic void handle_event_loop_timer(struct mako_event_loop *loop) {\n\tint timer_fd = loop->fds[MAKO_EVENT_TIMER].fd;\n\tuint64_t expirations;\n\tssize_t n = read(timer_fd, &expirations, sizeof(expirations));\n\tif (n < 0) {\n\t\tfprintf(stderr, \"failed to read from timer FD\\n\");\n\t\treturn;\n\t}\n\n\tstruct mako_timer *timer = loop->next_timer;\n\tif (timer == NULL) {\n\t\treturn;\n\t}\n\n\tmako_event_loop_timer_func_t func = timer->func;\n\tvoid *user_data = timer->user_data;\n\tdestroy_timer(timer);\n\n\tfunc(user_data);\n}\n\nint run_event_loop(struct mako_event_loop *loop) {\n\tloop->running = true;\n\n\tint ret = 0;\n\n\t// Unprocessed messages can be queued up by synchronous sd_bus methods. We\n\t// need to process these.\n\tdo {\n\t\tret = sd_bus_process(loop->bus, NULL);\n\t} while (ret > 0);\n\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\twhile (loop->running) {\n\t\terrno = 0;\n\n\t\t// Wayland requests can be generated while handling non-Wayland events.\n\t\t// We need to flush these.\n\t\tdo {\n\t\t\tret = wl_display_dispatch_pending(loop->display);\n\t\t\twl_display_flush(loop->display);\n\t\t} while (ret > 0);\n\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"failed to dispatch pending Wayland events\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// Same for D-Bus.\n\t\tsd_bus_flush(loop->bus);\n\n\t\tret = poll(loop->fds, MAKO_EVENT_COUNT, -1);\n\t\tif (!loop->running) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"failed to poll(): %s\\n\", strerror(errno));\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (size_t i = 0; i < MAKO_EVENT_COUNT; ++i) {\n\t\t\tif (loop->fds[i].revents & POLLHUP) {\n\t\t\t\tloop->running = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (loop->fds[i].revents & POLLERR) {\n\t\t\t\tfprintf(stderr, \"failed to poll() socket %zu\\n\", i);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!loop->running || ret < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (loop->fds[MAKO_EVENT_SIGNAL].revents & POLLIN) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (loop->fds[MAKO_EVENT_DBUS].revents & POLLIN) {\n\t\t\tdo {\n\t\t\t\tret = sd_bus_process(loop->bus, NULL);\n\t\t\t} while (ret > 0);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr, \"failed to process D-Bus: %s\\n\",\n\t\t\t\t\tstrerror(-ret));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (loop->fds[MAKO_EVENT_DBUS].revents & POLLOUT) {\n\t\t\tret = sd_bus_flush(loop->bus);\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr, \"failed to flush D-Bus: %s\\n\",\n\t\t\t\t\tstrerror(-ret));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (loop->fds[MAKO_EVENT_WAYLAND].revents & POLLIN) {\n\t\t\tret = wl_display_dispatch(loop->display);\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr, \"failed to read Wayland events\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (loop->fds[MAKO_EVENT_WAYLAND].revents & POLLOUT) {\n\t\t\tret = wl_display_flush(loop->display);\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr, \"failed to flush Wayland events\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (loop->fds[MAKO_EVENT_TIMER].revents & POLLIN) {\n\t\t\thandle_event_loop_timer(loop);\n\t\t}\n\t}\n\treturn ret;\n}\n"
        },
        {
          "name": "fr.emersion.mako.service.in",
          "type": "blob",
          "size": 0.068359375,
          "content": "[D-BUS Service]\nName=org.freedesktop.Notifications\nExec=@bindir@/mako\n"
        },
        {
          "name": "icon.c",
          "type": "blob",
          "size": 8.36328125,
          "content": "#include <assert.h>\n#include <errno.h>\n#include <fnmatch.h>\n#include <glob.h>\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n#include <cairo/cairo.h>\n\n#include \"mako.h\"\n#include \"icon.h\"\n#include \"string-util.h\"\n#include \"wayland.h\"\n\n#ifdef HAVE_ICONS\n\n#include <gdk-pixbuf/gdk-pixbuf.h>\n#include \"cairo-pixbuf.h\"\n\nstatic bool validate_icon_name(const char* icon_name) {\n\tint icon_len = strlen(icon_name);\n\tif (icon_len > 1024) {\n\t\treturn false;\n\t}\n\tint index;\n\tfor (index = 0; index < icon_len; index ++) {\n\t\tbool is_number = icon_name[index] >= '0' && icon_name[index] <= '9';\n\t\tbool is_abc = (icon_name[index] >= 'A' && icon_name[index] <= 'Z') ||\n\t\t\t\t(icon_name[index] >= 'a' && icon_name[index] <= 'z');\n\t\tbool is_other = icon_name[index] == '-'\n\t\t\t\t|| icon_name[index] == '.' || icon_name[index] == '_';\n\n\t\tbool is_legal = is_number || is_abc || is_other;\n\t\tif (!is_legal) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic GdkPixbuf *load_image(const char *path) {\n\tif (strlen(path) == 0) {\n\t\treturn NULL;\n\t}\n\tGError *err = NULL;\n\tGdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(path, &err);\n\tif (!pixbuf) {\n\t\tfprintf(stderr, \"Failed to load icon (%s)\\n\", err->message);\n\t\tg_error_free(err);\n\t\treturn NULL;\n\t}\n\treturn pixbuf;\n}\n\nstatic GdkPixbuf *load_image_data(struct mako_image_data *image_data) {\n\tGdkPixbuf *pixbuf = gdk_pixbuf_new_from_data(image_data->data, GDK_COLORSPACE_RGB,\n\t\t\timage_data->has_alpha, image_data->bits_per_sample, image_data->width,\n\t\t\timage_data->height, image_data->rowstride, NULL, NULL);\n\tif (!pixbuf) {\n\t\tfprintf(stderr, \"Failed to load icon\\n\");\n\t\treturn NULL;\n\t}\n\treturn pixbuf;\n}\n\nstatic double fit_to_square(int width, int height, int square_size) {\n\tdouble longest = width > height ? width : height;\n\treturn longest > square_size ? square_size/longest : 1.0;\n}\n\nstatic char hex_val(char digit) {\n\tassert(isxdigit(digit));\n\tif (digit >= 'a') {\n\t\treturn digit - 'a' + 10;\n\t} else if (digit >= 'A') {\n\t\treturn digit - 'A' + 10;\n\t} else {\n\t\treturn digit - '0';\n\t}\n}\n\nstatic void url_decode(char *dst, const char *src) {\n\twhile (src[0]) {\n\t\tif (src[0] == '%' && isxdigit(src[1]) && isxdigit(src[2])) {\n\t\t\tdst[0] = 16*hex_val(src[1]) + hex_val(src[2]);\n\t\t\tdst++; src += 3;\n\t\t} else {\n\t\t\tdst[0] = src[0];\n\t\t\tdst++; src++;\n\t\t}\n\t}\n\tdst[0] = '\\0';\n}\n\n// Attempt to find a full path for a notification's icon_name, which may be:\n// - An absolute path, which will simply be returned (as a new string)\n// - A file:// URI, which will be converted to an absolute path\n// - A Freedesktop icon name, which will be resolved within the configured\n//   `icon-path` using something that looks vaguely like the algorithm defined\n//   in the icon theme spec (https://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html)\n//\n// Returns the resolved path, or NULL if it was unable to find an icon. The\n// return value must be freed by the caller.\nstatic char *resolve_icon(struct mako_notification *notif) {\n\tchar *icon_name = notif->app_icon;\n\tif (icon_name[0] == '\\0') {\n\t\treturn NULL;\n\t}\n\tif (icon_name[0] == '/') {\n\t\treturn strdup(icon_name);\n\t}\n\tif (strstr(icon_name, \"file://\") == icon_name) {\n\t\t// Chop off the scheme and URL decode\n\t\tchar *icon_path = malloc(strlen(icon_name) + 1 - strlen(\"file://\"));\n\t\tif (icon_path == NULL) {\n\t\t\treturn icon_path;\n\t\t}\n\n\t\turl_decode(icon_path, icon_name + strlen(\"file://\"));\n\t\treturn icon_path;\n\t}\n\n\t// Determine the largest scale factor of any attached output.\n\tint32_t max_scale = 1;\n\tstruct mako_output *output = NULL;\n\twl_list_for_each(output, &notif->state->outputs, link) {\n\t\tif (output->scale > max_scale) {\n\t\t\tmax_scale = output->scale;\n\t\t}\n\t}\n\n\tstatic const char fallback[] = \"%s:/usr/share/icons/hicolor\";\n\tchar *search = mako_asprintf(fallback, notif->style.icon_path);\n\n\tchar *saveptr = NULL;\n\tchar *theme_path = strtok_r(search, \":\", &saveptr);\n\n\t// Match all icon files underneath of the theme_path followed by any icon\n\t// size and category subdirectories. This pattern assumes that all the\n\t// files in the icon path are valid icon types.\n\tstatic const char pattern_fmt[] = \"%s/*/*/%s.*\";\n\n\tchar *icon_path = NULL;\n\tint32_t last_icon_size = 0;\n\n\tif (!validate_icon_name(icon_name)) {\n\t\treturn NULL;\n\t}\n\n\twhile (theme_path) {\n\t\tif (strlen(theme_path) == 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tglob_t icon_glob = {0};\n\t\tchar *pattern = mako_asprintf(pattern_fmt, theme_path, icon_name);\n\n\t\t// Disable sorting because we're going to do our own anyway.\n\t\tint found = glob(pattern, GLOB_NOSORT, NULL, &icon_glob);\n\t\tsize_t found_count = 0;\n\t\tif (found == 0) {\n\t\t\t// The value of gl_pathc isn't guaranteed to be usable if glob\n\t\t\t// returns non-zero.\n\t\t\tfound_count = icon_glob.gl_pathc;\n\t\t}\n\n\t\tfor (size_t i = 0; i < found_count; ++i) {\n\t\t\tchar *relative_path = icon_glob.gl_pathv[i];\n\n\t\t\t// Find the end of the current search path and walk to the next\n\t\t\t// path component. Hopefully this will be the icon resolution\n\t\t\t// subdirectory.\n\t\t\trelative_path += strlen(theme_path);\n\t\t\twhile (relative_path[0] == '/') {\n\t\t\t\t++relative_path;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tint32_t icon_size = strtol(relative_path, NULL, 10);\n\t\t\tif (errno || icon_size == 0) {\n\t\t\t\t// Try second level subdirectory if failed.\n\t\t\t\terrno = 0;\n\t\t\t\twhile (relative_path[0] != '/') {\n\t\t\t\t\t++relative_path;\n\t\t\t\t}\n\t\t\t\t++relative_path;\n\t\t\t\ticon_size = strtol(relative_path, NULL, 10);\n\t\t\t\tif (errno || icon_size == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint32_t icon_scale = 1;\n\t\t\tchar *scale_str = strchr(relative_path, '@');\n\t\t\tif (scale_str != NULL) {\n\t\t\t\ticon_scale = strtol(scale_str + 1, NULL, 10);\n\t\t\t}\n\n\t\t\tif (icon_size == notif->style.max_icon_size &&\n\t\t\t\t\ticon_scale == max_scale) {\n\t\t\t\t// If we find an exact match, we're done.\n\t\t\t\tfree(icon_path);\n\t\t\t\ticon_path = strdup(icon_glob.gl_pathv[i]);\n\t\t\t\tbreak;\n\t\t\t} else if (icon_size < notif->style.max_icon_size * max_scale &&\n\t\t\t\t\ticon_size > last_icon_size) {\n\t\t\t\t// Otherwise, if this icon is small enough to fit but bigger\n\t\t\t\t// than the last best match, choose it on a provisional basis.\n\t\t\t\t// We multiply by max_scale to increase the odds of finding an\n\t\t\t\t// icon which looks sharp on the highest-scale output.\n\t\t\t\tfree(icon_path);\n\t\t\t\ticon_path = strdup(icon_glob.gl_pathv[i]);\n\t\t\t\tlast_icon_size = icon_size;\n\t\t\t}\n\t\t}\n\n\t\tfree(pattern);\n\t\tglobfree(&icon_glob);\n\n\t\tif (icon_path) {\n\t\t\t// The spec says that if we find any match whatsoever in a theme,\n\t\t\t// we should stop there to avoid mixing icons from different\n\t\t\t// themes even if one is a better size.\n\t\t\tbreak;\n\t\t}\n\t\ttheme_path = strtok_r(NULL, \":\", &saveptr);\n\t}\n\n\tif (icon_path == NULL) {\n\t\t// Finally, fall back to looking in /usr/share/pixmaps. These are\n\t\t// unsized icons, which may lead to downscaling, but some apps are\n\t\t// still using it.\n\t\tstatic const char pixmaps_fmt[] = \"/usr/share/pixmaps/%s.*\";\n\n\t\tchar *pattern = mako_asprintf(pixmaps_fmt, icon_name);\n\n\t\tglob_t icon_glob = {0};\n\t\tint found = glob(pattern, GLOB_NOSORT, NULL, &icon_glob);\n\n\t\tif (found == 0 && icon_glob.gl_pathc > 0) {\n\t\t\ticon_path = strdup(icon_glob.gl_pathv[0]);\n\t\t}\n\t\tfree(pattern);\n\t\tglobfree(&icon_glob);\n\t}\n\n\tfree(search);\n\treturn icon_path;\n}\n\nstruct mako_icon *create_icon(struct mako_notification *notif) {\n\tGdkPixbuf *image = NULL;\n\tif (notif->image_data != NULL) {\n\t\timage = load_image_data(notif->image_data);\n\t}\n\n\tif (image == NULL) {\n\t\tchar *path = resolve_icon(notif);\n\t\tif (path == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\timage = load_image(path);\n\t\tfree(path);\n\t\tif (image == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tint image_width = gdk_pixbuf_get_width(image);\n\tint image_height = gdk_pixbuf_get_height(image);\n\n\tstruct mako_icon *icon = calloc(1, sizeof(struct mako_icon));\n\ticon->scale = fit_to_square(\n\t\t\timage_width, image_height, notif->style.max_icon_size);\n\ticon->width = image_width * icon->scale;\n\ticon->height = image_height * icon->scale;\n\n\ticon->image = create_cairo_surface_from_gdk_pixbuf(image);\n\tg_object_unref(image);\n\tif (icon->image == NULL) {\n\t\tfree(icon);\n\t\treturn NULL;\n\t}\n\n\treturn icon;\n}\n#else\nstruct mako_icon *create_icon(struct mako_notification *notif) {\n\treturn NULL;\n}\n#endif\n\nvoid draw_icon(cairo_t *cairo, struct mako_icon *icon,\n\t\tdouble xpos, double ypos, double scale) {\n\tcairo_save(cairo);\n\tcairo_scale(cairo, scale*icon->scale, scale*icon->scale);\n\tcairo_set_source_surface(cairo, icon->image, xpos/icon->scale, ypos/icon->scale);\n\tcairo_paint(cairo);\n\tcairo_restore(cairo);\n}\n\nvoid destroy_icon(struct mako_icon *icon) {\n\tif (icon != NULL) {\n\t\tif (icon->image != NULL) {\n\t\t\tcairo_surface_destroy(icon->image);\n\t\t}\n\t\tfree(icon);\n\t}\n}\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 4.8701171875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"config.h\"\n#include \"dbus.h\"\n#include \"mako.h\"\n#include \"mode.h\"\n#include \"notification.h\"\n#include \"render.h\"\n#include \"surface.h\"\n#include \"wayland.h\"\n\nstatic const char usage[] =\n\t\"Usage: mako [options...]\\n\"\n\t\"\\n\"\n\t\"  -h, --help                          Show help message and quit.\\n\"\n\t\"  -c, --config <path>                 Path to config file.\\n\"\n\t\"      --font <font>                   Font family and size.\\n\"\n\t\"      --background-color <color>      Background color.\\n\"\n\t\"      --text-color <color>            Text color.\\n\"\n\t\"      --width <px>                    Notification width.\\n\"\n\t\"      --height <px>                   Max notification height.\\n\"\n\t\"      --outer-margin <px>[,<px>...]   Outer margin values, comma separated.\\n\"\n\t\"                                      Up to four values, with the same\\n\"\n\t\"                                      meaning as in CSS.\\n\"\n\t\"      --margin <px>[,<px>...]         Margin values, comma separated.\\n\"\n\t\"                                      Up to four values, with the same\\n\"\n\t\"                                      meaning as in CSS.\\n\"\n\t\"      --padding <px>[,<px>...]        Padding values, comma separated.\\n\"\n\t\"                                      Up to four values, with the same\\n\"\n\t\"                                      meaning as in CSS.\\n\"\n\t\"      --border-size <px>              Border size.\\n\"\n\t\"      --border-color <color>          Border color.\\n\"\n\t\"      --border-radius <px>            Corner radius\\n\"\n\t\"      --progress-color <color>        Progress indicator color.\\n\"\n\t\"      --icons <0|1>                   Show icons in notifications.\\n\"\n\t\"      --icon-path <path>[:<path>...]  Icon search path, colon delimited.\\n\"\n\t\"      --max-icon-size <px>            Set max size of icons.\\n\"\n\t\"      --markup <0|1>                  Enable/disable markup.\\n\"\n\t\"      --actions <0|1>                 Enable/disable application action\\n\"\n\t\"                                      execution.\\n\"\n\t\"      --format <format>               Format string.\\n\"\n\t\"      --hidden-format <format>        Format string.\\n\"\n\t\"      --max-visible <n>               Max number of visible notifications.\\n\"\n\t\"      --max-history <n>               Max size of history buffer.\\n\"\n\t\"      --history <0|1>                 Add expired notifications to history.\\n\"\n\t\"      --sort <sort_criteria>          Sorts incoming notifications by time\\n\"\n\t\"                                      and/or priority in ascending(+) or\\n\"\n\t\"                                      descending(-) order.\\n\"\n\t\"      --default-timeout <timeout>     Default timeout in milliseconds.\\n\"\n\t\"      --ignore-timeout <0|1>          Enable/disable notification timeout.\\n\"\n\t\"      --output <name>                 Show notifications on this output.\\n\"\n\t\"      --layer <layer>                 Arrange notifications at this layer.\\n\"\n\t\"      --anchor <position>             Position on output to put notifications.\\n\"\n\t\"\\n\"\n\t\"Colors can be specified with the format #RRGGBB or #RRGGBBAA.\\n\";\n\nstatic bool init(struct mako_state *state) {\n\tif (!init_dbus(state)) {\n\t\treturn false;\n\t}\n\tif (!init_wayland(state)) {\n\t\tfinish_dbus(state);\n\t\treturn false;\n\t}\n\tif (!init_event_loop(&state->event_loop, state->bus, state->display)) {\n\t\tfinish_dbus(state);\n\t\tfinish_wayland(state);\n\t\treturn false;\n\t}\n\twl_list_init(&state->notifications);\n\twl_list_init(&state->history);\n\twl_array_init(&state->current_modes);\n\tconst char *mode = \"default\";\n\tset_modes(state, &mode, 1);\n\treturn true;\n}\n\nstatic void finish(struct mako_state *state) {\n\tchar **mode_ptr;\n\twl_array_for_each(mode_ptr, &state->current_modes) {\n\t\tfree(*mode_ptr);\n\t}\n\twl_array_release(&state->current_modes);\n\n\tstruct mako_notification *notif, *tmp;\n\twl_list_for_each_safe(notif, tmp, &state->notifications, link) {\n\t\tdestroy_notification(notif);\n\t}\n\twl_list_for_each_safe(notif, tmp, &state->history, link) {\n\t\tdestroy_notification(notif);\n\t}\n\n\tstruct mako_surface *surface, *stmp;\n\twl_list_for_each_safe(surface, stmp, &state->surfaces, link) {\n\t\tdestroy_surface(surface);\n\t}\n\tfinish_event_loop(&state->event_loop);\n\tfinish_wayland(state);\n\tfinish_dbus(state);\n}\n\nstatic struct mako_event_loop *event_loop = NULL;\n\nint main(int argc, char *argv[]) {\n\tstruct mako_state state = {0};\n\n\tstate.argc = argc;\n\tstate.argv = argv;\n\n\twl_list_init(&state.surfaces);\n\n\t// This is a bit wasteful, but easier than special-casing the reload.\n\tinit_default_config(&state.config);\n\tint ret = reload_config(&state.config, argc, argv);\n\n\tif (ret < 0) {\n\t\tfinish_config(&state.config);\n\t\treturn EXIT_FAILURE;\n\t} else if (ret > 0) {\n\t\tfinish_config(&state.config);\n\t\tprintf(\"%s\", usage);\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tif (!init(&state)) {\n\t\tfinish_config(&state.config);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tevent_loop = &state.event_loop;\n\n\tret = run_event_loop(&state.event_loop);\n\n\tfinish(&state);\n\tfinish_config(&state.config);\n\n\treturn ret < 0 ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "makoctl",
          "type": "blob",
          "size": 4.96875,
          "content": "#!/bin/sh -eu\n\nusage() {\n\techo \"Usage: makoctl <command> [options...]\"\n\techo \"\"\n\techo \"Commands:\"\n\techo \"  dismiss [-n id]                Dismiss the notification with the\"\n\techo \"                                 given id, or the last notification\"\n\techo \"                                 if none is given\"\n\techo \"          [-a|--all]             Dismiss all notifications\"\n\techo \"          [-g|--group]           Dismiss all the notifications\"\n\techo \"                                 in the last notification's group\"\n\techo \"  restore                        Restore the most recently expired\"\n\techo \"                                 notification from the history buffer\"\n\techo \"  invoke [-n id] [action]        Invoke an action on the notification\"\n\techo \"                                 with the given id, or the last\"\n\techo \"                                 notification if none is given\"\n\techo \"  menu [-n id] <prog> [arg ...]  Use <prog> [args ...] to select one\"\n\techo \"                                 action to be invoked on the notification\"\n\techo \"                                 with the given id, or the last\"\n\techo \"                                 notification if none is given\"\n\techo \"  list                           List notifications\"\n\techo \"  history                        List history\"\n\techo \"  reload                         Reload the configuration file\"\n\techo \"  mode                           List modes\"\n\techo \"  mode [-a mode]... [-r mode]... Add/remove modes\"\n\techo \"  mode [-t mode]...              Toggle modes (add if not present, remove if present)\"\n\techo \"  mode -s mode...                Set modes\"\n\techo \"  help                           Show this help\"\n}\n\nBUSCTL=busctl\nif ! type $BUSCTL >/dev/null 2>&1; then\n\tBUSCTL=basuctl\nfi\nif ! type $BUSCTL >/dev/null 2>&1; then\n\techo >&2 \"$0: busctl or basuctl is required\"\n\texit 1\nfi\n\ncall() {\n\t$BUSCTL -j --user call org.freedesktop.Notifications /fr/emersion/Mako \\\n\t\tfr.emersion.Mako -- \"$@\"\n}\n\nrequire_jq() {\n\tif ! type jq >/dev/null 2>&1; then\n\t\techo >&2 \"$0: jq is required to use this command\"\n\t\texit 1\n\tfi\n}\n\nif [ $# -eq 0 ]; then\n\tusage\n\texit 1\nfi\n\ncase \"$1\" in\n\"dismiss\")\n\tall=0\n\tgroup=0\n\tid=0\n\twhile [ $# -gt 1 ]; do\n\t\tcase \"$2\" in\n\t\t\"-a\"|\"--all\")\n\t\t\tall=1\n\t\t\t;;\n\t\t\"-g\"|\"--group\")\n\t\t\tgroup=1\n\t\t\t;;\n\t\t\"-n\")\n\t\t\tif [ $# -lt 3 ]; then\n\t\t\t\techo >&2 \"$0: Expected <id> after '-n'\"\n\t\t\t\texit 1\n\t\t\tfi\n\t\t\tid=$3\n\t\t\tshift\n\t\t\t;;\n\t\t*)\n\t\t\techo >&2 \"$0: Unrecognized option: $2\"\n\t\t\texit 1\n\t\t\t;;\n\t\tesac\n\t\tshift\n\tdone\n\n\tif [ $all -eq 1 ]; then\n\t\tcall DismissAllNotifications\n\telse\n\t\tcall DismissNotification \"ub\" \"$id\" \"$group\"\n\tfi\n\t;;\n\"invoke\")\n\tid=0\n\tif [ $# -gt 1 ] && [ \"$2\" = \"-n\" ]; then\n\t\tid=\"$3\"\n\t\tshift 2\n\tfi\n\n\taction=\"default\"\n\tif [ $# -gt 1 ]; then\n\t\taction=\"$2\"\n\tfi\n\n\tcall InvokeAction \"us\" \"$id\" \"$action\"\n\t;;\n\"restore\")\n\tcall RestoreNotification\n\t;;\n\"menu\")\n\tshift 1\n\trequire_jq\n\tif [ $# -gt 1 ] && [ \"$1\" = \"-n\" ]; then\n\t\tid=\"$2\"\n\t\tactions=\"$(call ListNotifications | jq --arg id \"$id\" -re '.data[0][] | select(.id.data==($id | tonumber)) | .actions.data')\"\n\t\tshift 2\n\telse\n\t\tactions=\"$(call ListNotifications | jq -re '.data[0][0].actions.data')\"\n\t\tid=\"0\"\n\tfi\n\tif [ \"$(jq -rn \"$actions | length\")\" -eq \"0\" ]; then\n\t\techo >&2 \"$0: No actions found\"\n\t\texit 1\n\tfi\n\n\tsel=\"$(jq -rn \"$actions|values[]\" | \"$@\")\"\n\tsel=\"$(jq -rn --arg sel \"$sel\" \"$actions|to_entries[]|select(.value == \\$sel).key\")\"\n\tif [ -z \"$sel\" ]; then\n\t\techo >&2 \"$0: No action selected\"\n\t\texit 1\n\telse\n\t\tcall InvokeAction \"us\" \"$id\" \"$sel\"\n\tfi\n\t;;\n\"list\")\n\tcall ListNotifications\n\t;;\n\"history\")\n\tcall ListHistory\n\t;;\n\"reload\")\n\tcall Reload\n\t;;\n\"set-mode\") # deprecated\n\tcall SetMode \"s\" \"$2\"\n\t;;\n\"mode\")\n\tshift 1\n\trequire_jq\n\tmodes=\"$(call ListModes | jq '.data[0]')\"\n\tadd_remove_toggle_flag=0\n\tset_flag=0\n\twhile getopts a:r:t:s name; do\n\t\tcase \"$name\" in\n\t\ta)\n\t\t\tadd_remove_toggle_flag=1\n\t\t\tmodes=\"$(echo \"$modes\" | jq --arg mode \"$OPTARG\" '. += [$mode]')\"\n\t\t\t;;\n\t\tr)\n\t\t\tadd_remove_toggle_flag=1\n\t\t\tmodes=\"$(echo \"$modes\" | jq --arg mode \"$OPTARG\" 'del(.[] | select(. == $mode))')\"\n\t\t\t;;\n\t\tt)\n\t\t\tadd_remove_toggle_flag=1\n\t\t\tmodes=\"$(echo \"$modes\" | jq --arg mode \"$OPTARG\" '. |= if any(.[]; . == $mode) then map(select(. != $mode)) else . + [$mode] end')\"\n\t\t\t;;\n\t\ts)\n\t\t\tset_flag=1\n\t\t\t;;\n\t\t?)\n\t\t\texit 1\n\t\tesac\n\tdone\n\tshift $(($OPTIND - 1))\n\tif [ \"$add_remove_toggle_flag\" = 1 ] && [ \"$set_flag\" = 1 ]; then\n\t\techo >&2 \"makoctl: -a/-r/-t and -s cannot be used together\"\n\t\texit 1\n\tfi\n\tif [ \"$set_flag\" = 1 ]; then\n\t\tmodes=\"$(jq -n '$ARGS.positional' --args \"$@\")\"\n\telif [ $# -gt 0 ]; then\n\t\techo >&2 \"makoctl: positional arguments can only be used with -s\"\n\t\texit 1\n\tfi\n\tif [ \"$add_remove_toggle_flag\" = 1 ] || [ \"$set_flag\" = 1 ]; then\n\t\tmodes=\"$(echo \"$modes\" | jq '. | unique')\"\n\t\tmodes_len=\"$(echo \"$modes\" | jq '. | length')\"\n\t\tmodes_args=$(echo \"$modes\" | jq -r '@sh')\n\t\t# Required to behave properly when mode names contain spaces\n\t\teval set -- $modes_args\n\t\tcall SetModes \"as\" \"$modes_len\" \"$@\"\n\tfi\n\techo \"$modes\" | jq -r '.[]'\n\t;;\n\"help\"|\"--help\"|\"-h\")\n\tusage\n\t;;\n*)\n\techo \"makoctl: unrecognized command '$1'\"\n\texit 1\n\t;;\nesac\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 2.53125,
          "content": "project(\n\t'mako',\n\t'c',\n\tversion: '1.9.0',\n\tlicense: 'MIT',\n\tmeson_version: '>=0.60.0',\n\tdefault_options: [\n\t\t'c_std=c11',\n\t\t'warning_level=2',\n\t\t'werror=true',\n\t],\n)\n\nadd_project_arguments([\n\t'-D_POSIX_C_SOURCE=200809L',\n\n\t'-Wundef',\n\n\t'-Wno-unused-parameter',\n\t'-Wno-missing-braces',\n], language: 'c')\n\nmako_inc = include_directories('include')\n\ncc = meson.get_compiler('c')\n\ncairo = dependency('cairo')\npango = dependency('pango')\npangocairo = dependency('pangocairo')\nglib = dependency('glib-2.0')\ngobject = dependency('gobject-2.0')\nrealtime = cc.find_library('rt')\nwayland_client = dependency('wayland-client')\nwayland_protos = dependency('wayland-protocols', version: '>=1.32')\nwayland_cursor = dependency('wayland-cursor')\n\nepoll = dependency('', required: false)\nif (not cc.has_function('timerfd_create', prefix: '#include <sys/timerfd.h>') or\n\t\tnot cc.has_function('signalfd', prefix: '#include <sys/signalfd.h>'))\n\tepoll = dependency('epoll-shim')\nendif\n\nif get_option('sd-bus-provider') == 'auto'\n\tassert(get_option('auto_features').auto(), 'sd-bus-provider must not be set to auto since auto_features != auto')\n\tsdbus = dependency('libsystemd', 'libelogind', 'basu')\nelse\n\tsdbus = dependency(get_option('sd-bus-provider'))\nendif\nadd_project_arguments('-DHAVE_' + sdbus.name().to_upper(), language: 'c')\n\ngdk_pixbuf = dependency('gdk-pixbuf-2.0', required: get_option('icons'))\nif gdk_pixbuf.found()\n\tadd_project_arguments('-DHAVE_ICONS', language: 'c')\nendif\n\nsubdir('contrib/completions')\nsubdir('protocol')\n\nsrc_files = [\n\t'config.c',\n\t'event-loop.c',\n\t'dbus/dbus.c',\n\t'dbus/mako.c',\n\t'dbus/xdg.c',\n\t'main.c',\n\t'mode.c',\n\t'notification.c',\n\t'pool-buffer.c',\n\t'render.c',\n\t'wayland.c',\n\t'criteria.c',\n\t'types.c',\n\t'surface.c',\n\t'icon.c',\n\t'string-util.c',\n]\n\nif gdk_pixbuf.found()\n\tsrc_files += 'cairo-pixbuf.c'\nendif\n\nexecutable(\n\t'mako',\n\tfiles(src_files) + protocols_src,\n\tdependencies: [\n\t\tcairo,\n\t\tepoll,\n\t\tgdk_pixbuf,\n\t\tsdbus,\n\t\tpango,\n\t\tpangocairo,\n\t\tglib,\n\t\tgobject,\n\t\trealtime,\n\t\twayland_client,\n\t\twayland_cursor,\n\t],\n\tinclude_directories: [mako_inc],\n\tinstall: true,\n)\n\ninstall_data(\n\t'makoctl',\n\tinstall_dir: get_option('bindir'),\n\tinstall_mode: 'rwxr-xr-x',\n)\n\nconf_data = configuration_data()\nconf_data.set('bindir', get_option('prefix') / get_option('bindir'))\n\nconfigure_file(\n\tconfiguration: conf_data,\n\tinput: 'fr.emersion.mako.service.in',\n\toutput: '@BASENAME@',\n\tinstall_dir: get_option('datadir') + '/dbus-1/services',\n)\n\nsubdir('doc')\n\nsummary({\n\t'sd-bus provider': sdbus.name(),\n\t'Icons': gdk_pixbuf.found(),\n\t'Man pages': scdoc.found(),\n}, bool_yn: true)\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 0.62109375,
          "content": "option('sd-bus-provider', type: 'combo', choices: ['auto', 'libsystemd', 'libelogind', 'basu'], value: 'auto', description: 'Provider of the sd-bus library')\noption('icons', type: 'feature', value: 'auto', description: 'Enable icon support')\noption('man-pages', type: 'feature', value: 'auto', description: 'Generate and install man pages')\noption('fish-completions', type: 'boolean', value: false, description: 'Install fish completions')\noption('zsh-completions', type: 'boolean', value: false, description: 'Install zsh completions')\noption('bash-completions', type: 'boolean', value: false, description: 'Install bash completions')\n"
        },
        {
          "name": "mode.c",
          "type": "blob",
          "size": 0.8427734375,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <wayland-util.h>\n\n#include \"mako.h\"\n#include \"mode.h\"\n\nbool has_mode(struct mako_state *state, const char *mode) {\n\tconst char **mode_ptr;\n\twl_array_for_each(mode_ptr, &state->current_modes) {\n\t\tif (strcmp(*mode_ptr, mode) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid set_modes(struct mako_state *state, const char **modes, size_t modes_len) {\n\tchar **mode_ptr;\n\twl_array_for_each(mode_ptr, &state->current_modes) {\n\t\tfree(*mode_ptr);\n\t}\n\tstate->current_modes.size = 0;\n\n\tfor (size_t i = 0; i < modes_len; i++) {\n\t\t// Drop duplicate entries\n\t\tbool dup = false;\n\t\tfor (size_t j = 0; j < i; j++) {\n\t\t\tif (strcmp(modes[i], modes[j]) == 0) {\n\t\t\t\tdup = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dup) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar **dst = wl_array_add(&state->current_modes, sizeof(char *));\n\t\t*dst = strdup(modes[i]);\n\t}\n}\n"
        },
        {
          "name": "notification.c",
          "type": "blob",
          "size": 15.275390625,
          "content": "#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <pango/pangocairo.h>\n#include <wayland-client.h>\n#include <linux/input-event-codes.h>\n\n#include \"config.h\"\n#include \"criteria.h\"\n#include \"dbus.h\"\n#include \"event-loop.h\"\n#include \"mako.h\"\n#include \"notification.h\"\n#include \"icon.h\"\n#include \"string-util.h\"\n#include \"wayland.h\"\n\nbool hotspot_at(struct mako_hotspot *hotspot, int32_t x, int32_t y) {\n\treturn x >= hotspot->x &&\n\t\ty >= hotspot->y &&\n\t\tx < hotspot->x + hotspot->width &&\n\t\ty < hotspot->y + hotspot->height;\n}\n\nvoid reset_notification(struct mako_notification *notif) {\n\tstruct mako_action *action, *tmp;\n\twl_list_for_each_safe(action, tmp, &notif->actions, link) {\n\t\twl_list_remove(&action->link);\n\t\tfree(action->key);\n\t\tfree(action->title);\n\t\tfree(action);\n\t}\n\n\tnotif->urgency = MAKO_NOTIFICATION_URGENCY_UNKNOWN;\n\tnotif->progress = -1;\n\n\tdestroy_timer(notif->timer);\n\tnotif->timer = NULL;\n\n\tfree(notif->app_name);\n\tfree(notif->app_icon);\n\tfree(notif->summary);\n\tfree(notif->body);\n\tfree(notif->category);\n\tfree(notif->desktop_entry);\n\tfree(notif->tag);\n\tif (notif->image_data != NULL) {\n\t\tfree(notif->image_data->data);\n\t\tfree(notif->image_data);\n\t}\n\n\tnotif->app_name = strdup(\"\");\n\tnotif->app_icon = strdup(\"\");\n\tnotif->summary = strdup(\"\");\n\tnotif->body = strdup(\"\");\n\tnotif->category = strdup(\"\");\n\tnotif->desktop_entry = strdup(\"\");\n\tnotif->tag = strdup(\"\");\n\n\tnotif->image_data = NULL;\n\n\tdestroy_icon(notif->icon);\n\tnotif->icon = NULL;\n}\n\nstruct mako_notification *create_notification(struct mako_state *state) {\n\tstruct mako_notification *notif =\n\t\tcalloc(1, sizeof(struct mako_notification));\n\tif (notif == NULL) {\n\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tnotif->state = state;\n\t++state->last_id;\n\tnotif->id = state->last_id;\n\twl_list_init(&notif->actions);\n\twl_list_init(&notif->link);\n\treset_notification(notif);\n\n\t// Start ungrouped.\n\tnotif->group_index = -1;\n\n\treturn notif;\n}\n\nvoid destroy_notification(struct mako_notification *notif) {\n\twl_list_remove(&notif->link);\n\n\treset_notification(notif);\n\n\tfree(notif->app_name);\n\tfree(notif->app_icon);\n\tfree(notif->summary);\n\tfree(notif->body);\n\tfree(notif->category);\n\tfree(notif->desktop_entry);\n\tfree(notif->tag);\n\n\tfinish_style(&notif->style);\n\tfree(notif);\n}\n\nvoid close_notification(struct mako_notification *notif,\n\t\tenum mako_notification_close_reason reason,\n\t\tbool add_to_history) {\n\tnotify_notification_closed(notif, reason);\n\twl_list_remove(&notif->link);  // Remove so regrouping works...\n\twl_list_init(&notif->link);  // ...but destroy will remove again.\n\n\tstruct mako_criteria *notif_criteria = create_criteria_from_notification(\n\t\t\tnotif, &notif->style.group_criteria_spec);\n\tif (notif_criteria) {\n\t\tgroup_notifications(notif->state, notif_criteria);\n\t\tdestroy_criteria(notif_criteria);\n\t}\n\n\tif (!notif->style.history ||\n\t\tnotif->state->config.max_history <= 0) {\n\t\tdestroy_notification(notif);\n\t\treturn;\n\t}\n\n\tdestroy_timer(notif->timer);\n\tnotif->timer = NULL;\n\n\tif (add_to_history) {\n\t\twl_list_insert(&notif->state->history, &notif->link);\n\t\twhile (wl_list_length(&notif->state->history) >\n\t\t\tnotif->state->config.max_history) {\n\t\t\tstruct mako_notification *n =\n\t\t\t\twl_container_of(notif->state->history.prev, n, link);\n\t\t\tdestroy_notification(n);\n\t\t}\n\t} else {\n\t\tdestroy_notification(notif);\n\t}\n}\n\nstruct mako_notification *get_notification(struct mako_state *state,\n\t\tuint32_t id) {\n\tstruct mako_notification *notif;\n\twl_list_for_each(notif, &state->notifications, link) {\n\t\tif (notif->id == id) {\n\t\t\treturn notif;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct mako_notification *get_tagged_notification(struct mako_state *state,\n\t\tconst char *tag, const char *app_name) {\n\tstruct mako_notification *notif;\n\twl_list_for_each(notif, &state->notifications, link) {\n\t\tif (notif->tag && strlen(notif->tag) != 0 &&\n\t\t\tstrcmp(notif->tag, tag) == 0 &&\n\t\t\tstrcmp(notif->app_name, app_name) == 0) {\n\t\t\treturn notif;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid close_group_notifications(struct mako_notification *top_notif,\n\t       enum mako_notification_close_reason reason) {\n\tstruct mako_state *state = top_notif->state;\n\n\tif (top_notif->style.group_criteria_spec.none) {\n\t\t// No grouping, just close the notification\n\t\tclose_notification(top_notif, reason, true);\n\t\treturn;\n\t}\n\n\tstruct mako_criteria *notif_criteria = create_criteria_from_notification(\n\t\ttop_notif, &top_notif->style.group_criteria_spec);\n\n\tstruct mako_notification *notif, *tmp;\n\twl_list_for_each_safe(notif, tmp, &state->notifications, link) {\n\t\tif (match_criteria(notif_criteria, notif)) {\n\t\t\tclose_notification(notif, reason, true);\n\t\t}\n\t}\n\n\tdestroy_criteria(notif_criteria);\n}\n\nvoid close_all_notifications(struct mako_state *state,\n\t\tenum mako_notification_close_reason reason) {\n\tstruct mako_notification *notif, *tmp;\n\twl_list_for_each_safe(notif, tmp, &state->notifications, link) {\n\t\tclose_notification(notif, reason, true);\n\t}\n}\n\nstatic size_t trim_space(char *dst, const char *src) {\n\tsize_t src_len = strlen(src);\n\tconst char *start = src;\n\tconst char *end = src + src_len;\n\n\twhile (start != end && isspace(start[0])) {\n\t\t++start;\n\t}\n\n\twhile (end != start && isspace(end[-1])) {\n\t\t--end;\n\t}\n\n\tsize_t trimmed_len = end - start;\n\tmemmove(dst, start, trimmed_len);\n\tdst[trimmed_len] = '\\0';\n\treturn trimmed_len;\n}\n\nstatic const char *escape_markup_char(char c) {\n\tswitch (c) {\n\tcase '&': return \"&amp;\";\n\tcase '<': return \"&lt;\";\n\tcase '>': return \"&gt;\";\n\tcase '\\'': return \"&apos;\";\n\tcase '\"': return \"&quot;\";\n\t}\n\treturn NULL;\n}\n\nstatic size_t escape_markup(const char *s, char *buf) {\n\tsize_t len = 0;\n\twhile (s[0] != '\\0') {\n\t\tconst char *replacement = escape_markup_char(s[0]);\n\t\tif (replacement != NULL) {\n\t\t\tsize_t replacement_len = strlen(replacement);\n\t\t\tif (buf != NULL) {\n\t\t\t\tmemcpy(buf + len, replacement, replacement_len);\n\t\t\t}\n\t\t\tlen += replacement_len;\n\t\t} else {\n\t\t\tif (buf != NULL) {\n\t\t\t\tbuf[len] = s[0];\n\t\t\t}\n\t\t\t++len;\n\t\t}\n\t\t++s;\n\t}\n\tif (buf != NULL) {\n\t\tbuf[len] = '\\0';\n\t}\n\treturn len;\n}\n\n// Any new format specifiers must also be added to VALID_FORMAT_SPECIFIERS.\n\nchar *format_hidden_text(char variable, bool *markup, void *data) {\n\tstruct mako_hidden_format_data *format_data = data;\n\tswitch (variable) {\n\tcase 'h':\n\t\treturn mako_asprintf(\"%zu\", format_data->hidden);\n\tcase 't':\n\t\treturn mako_asprintf(\"%zu\", format_data->count);\n\t}\n\treturn NULL;\n}\n\nchar *format_notif_text(char variable, bool *markup, void *data) {\n\tstruct mako_notification *notif = data;\n\tswitch (variable) {\n\tcase 'a':\n\t\treturn strdup(notif->app_name);\n\tcase 'i':\n\t\treturn mako_asprintf(\"%d\", notif->id);\n\tcase 's':\n\t\treturn strdup(notif->summary);\n\tcase 'b':\n\t\t*markup = notif->style.markup;\n\t\treturn strdup(notif->body);\n\tcase 'g':\n\t\treturn mako_asprintf(\"%d\", notif->group_count);\n\t}\n\treturn NULL;\n}\n\nsize_t format_text(const char *format, char *buf, mako_format_func_t format_func, void *data) {\n\tsize_t len = 0;\n\n\tconst char *last = format;\n\twhile (1) {\n\t\tchar *current = strchr(last, '%');\n\t\tif (current == NULL || current[1] == '\\0') {\n\t\t\tsize_t tail_len = strlen(last);\n\t\t\tif (buf != NULL) {\n\t\t\t\tmemcpy(buf + len, last, tail_len + 1);\n\t\t\t}\n\t\t\tlen += tail_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tsize_t chunk_len = current - last;\n\t\tif (buf != NULL) {\n\t\t\tmemcpy(buf + len, last, chunk_len);\n\t\t}\n\t\tlen += chunk_len;\n\n\t\tchar *value = NULL;\n\t\tbool markup = false;\n\n\t\tif (current[1] == '%') {\n\t\t\tvalue = strdup(\"%\");\n\t\t} else {\n\t\t\tvalue =\tformat_func(current[1], &markup, data);\n\t\t}\n\t\tif (value == NULL) {\n\t\t\tvalue = strdup(\"\");\n\t\t}\n\n\t\tsize_t value_len;\n\t\tif (!markup || !pango_parse_markup(value, -1, 0, NULL, NULL, NULL, NULL)) {\n\t\t\tchar *escaped = NULL;\n\t\t\tif (buf != NULL) {\n\t\t\t\tescaped = buf + len;\n\t\t\t}\n\t\t\tvalue_len = escape_markup(value, escaped);\n\t\t} else {\n\t\t\tvalue_len = strlen(value);\n\t\t\tif (buf != NULL) {\n\t\t\t\tmemcpy(buf + len, value, value_len);\n\t\t\t}\n\t\t}\n\t\tfree(value);\n\n\t\tlen += value_len;\n\t\tlast = current + 2;\n\t}\n\n\tif (buf != NULL) {\n\t\ttrim_space(buf, buf);\n\t}\n\treturn len;\n}\n\nstatic const struct mako_binding *get_button_binding(struct mako_style *style,\n\t\tuint32_t button) {\n\tswitch (button) {\n\tcase BTN_LEFT:\n\t\treturn &style->button_bindings.left;\n\tcase BTN_RIGHT:\n\t\treturn &style->button_bindings.right;\n\tcase BTN_MIDDLE:\n\t\treturn &style->button_bindings.middle;\n\t}\n\treturn NULL;\n}\n\nstatic void try_invoke_action(struct mako_notification *notif,\n\t\tconst char *target_action,\n\t\tconst struct mako_binding_context *ctx) {\n\tstruct mako_action *action;\n\twl_list_for_each(action, &notif->actions, link) {\n\t\tif (strcmp(action->key, target_action) == 0) {\n\t\t\tchar *activation_token = NULL;\n\t\t\tif (ctx != NULL) {\n\t\t\t\tactivation_token = create_xdg_activation_token(\n\t\t\t\t\tctx->surface, ctx->seat, ctx->serial);\n\t\t\t}\n\t\t\tnotify_action_invoked(action, activation_token);\n\t\t\tfree(activation_token);\n\t\t\tbreak;\n\t\t}\n\t}\n\tclose_notification(notif, MAKO_NOTIFICATION_CLOSE_DISMISSED, true);\n}\n\nvoid notification_execute_binding(struct mako_notification *notif,\n\t\tconst struct mako_binding *binding,\n\t\tconst struct mako_binding_context *ctx) {\n\tswitch (binding->action) {\n\tcase MAKO_BINDING_NONE:\n\t\tbreak;\n\tcase MAKO_BINDING_DISMISS:\n\t\tclose_notification(notif, MAKO_NOTIFICATION_CLOSE_DISMISSED, true);\n\t\tbreak;\n\tcase MAKO_BINDING_DISMISS_NO_HISTORY:\n\t\tclose_notification(notif, MAKO_NOTIFICATION_CLOSE_DISMISSED, false);\n\t\tbreak;\n\tcase MAKO_BINDING_DISMISS_GROUP:\n\t\tclose_group_notifications(notif, MAKO_NOTIFICATION_CLOSE_DISMISSED);\n\t\tbreak;\n\tcase MAKO_BINDING_DISMISS_ALL:\n\t\tclose_all_notifications(notif->state, MAKO_NOTIFICATION_CLOSE_DISMISSED);\n\t\tbreak;\n\tcase MAKO_BINDING_INVOKE_ACTION:\n\t\tassert(binding->action_name != NULL);\n\t\ttry_invoke_action(notif, binding->action_name, ctx);\n\t\tbreak;\n\tcase MAKO_BINDING_EXEC:\n\t\tassert(binding->command != NULL);\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tperror(\"fork failed\");\n\t\t\tbreak;\n\t\t} else if (pid == 0) {\n\t\t\t// Double-fork to avoid SIGCHLD issues\n\t\t\tpid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\tperror(\"fork failed\");\n\t\t\t\t_exit(1);\n\t\t\t} else if (pid == 0) {\n\t\t\t\t// We pass variables using additional sh arguments. To convert\n\t\t\t\t// back the arguments to variables, insert a short script\n\t\t\t\t// preamble before the user's command.\n\t\t\t\tconst char setup_vars[] = \"id=\\\"$1\\\"\\n\";\n\n\t\t\t\tchar *cmd = mako_asprintf(\"%s%s\", setup_vars, binding->command);\n\n\t\t\t\tchar id_str[32];\n\t\t\t\tsnprintf(id_str, sizeof(id_str), \"%\" PRIu32, notif->id);\n\n\t\t\t\tchar *const argv[] = { \"sh\", \"-c\", cmd, \"sh\", id_str, NULL };\n\t\t\t\texecvp(\"sh\", argv);\n\t\t\t\tperror(\"exec failed\");\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\tif (waitpid(pid, NULL, 0) < 0) {\n\t\t\tperror(\"waitpid failed\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid notification_handle_button(struct mako_notification *notif, uint32_t button,\n\t\tenum wl_pointer_button_state state,\n\t\tconst struct mako_binding_context *ctx) {\n\tif (state != WL_POINTER_BUTTON_STATE_PRESSED) {\n\t\treturn;\n\t}\n\n\tconst struct mako_binding *binding =\n\t\tget_button_binding(&notif->style, button);\n\tif (binding != NULL) {\n\t\tnotification_execute_binding(notif, binding, ctx);\n\t}\n}\n\nvoid notification_handle_touch(struct mako_notification *notif,\n\t\tconst struct mako_binding_context *ctx) {\n\tnotification_execute_binding(notif, &notif->style.touch_binding, ctx);\n}\n\n/*\n * Searches through the notifications list and returns the next position at\n * which to insert. If no results for the specified urgency are found,\n * it will return the closest link searching in the direction specified.\n * (-1 for lower, 1 or upper).\n */\nstatic struct wl_list *get_last_notif_by_urgency(struct wl_list *notifications,\n\t\tenum mako_notification_urgency urgency, int direction) {\n\tenum mako_notification_urgency current = urgency;\n\n\tif (wl_list_empty(notifications)) {\n\t\treturn notifications;\n\t}\n\n\twhile (current <= MAKO_NOTIFICATION_URGENCY_CRITICAL &&\n\t\tcurrent >= MAKO_NOTIFICATION_URGENCY_UNKNOWN) {\n\t\tstruct mako_notification *notif;\n\t\twl_list_for_each_reverse(notif, notifications, link) {\n\t\t\tif (notif->urgency == current) {\n\t\t\t\treturn &notif->link;\n\t\t\t}\n\t\t}\n\t\tcurrent += direction;\n\t}\n\n\treturn notifications;\n}\n\nvoid insert_notification(struct mako_state *state, struct mako_notification *notif) {\n\tstruct mako_config *config = &state->config;\n\tstruct wl_list *insert_node;\n\n\tif (config->sort_criteria == MAKO_SORT_CRITERIA_TIME &&\n\t\t\t!(config->sort_asc & MAKO_SORT_CRITERIA_TIME)) {\n\t\tinsert_node = &state->notifications;\n\t} else if (config->sort_criteria == MAKO_SORT_CRITERIA_TIME &&\n\t\t\t(config->sort_asc & MAKO_SORT_CRITERIA_TIME)) {\n\t\tinsert_node = state->notifications.prev;\n\t} else if (config->sort_criteria & MAKO_SORT_CRITERIA_URGENCY) {\n\t\tint direction = (config->sort_asc & MAKO_SORT_CRITERIA_URGENCY) ? -1 : 1;\n\t\tint offset = 0;\n\t\tif (!(config->sort_asc & MAKO_SORT_CRITERIA_TIME)) {\n\t\t\toffset = direction;\n\t\t}\n\t\tinsert_node = get_last_notif_by_urgency(&state->notifications,\n\t\t\tnotif->urgency + offset, direction);\n\t} else {\n\t\tinsert_node = &state->notifications;\n\t}\n\n\twl_list_insert(insert_node, &notif->link);\n}\n\n// Iterate through all of the current notifications and group any that share\n// the same values for all of the criteria fields in `spec`. Returns the number\n// of notifications in the resulting group, or -1 if something goes wrong\n// with criteria.\nint group_notifications(struct mako_state *state, struct mako_criteria *criteria) {\n\tstruct wl_list matches = {0};\n\twl_list_init(&matches);\n\n\t// Now we're going to find all of the matching notifications and stick\n\t// them in a different list. Removing the first one from the global list\n\t// is technically unnecessary, since it will go back in the same place, but\n\t// it makes the rest of this logic nicer.\n\tstruct wl_list *location = NULL;  // The place we're going to reinsert them.\n\tstruct mako_notification *notif = NULL, *tmp = NULL;\n\tsize_t count = 0;\n\twl_list_for_each_safe(notif, tmp, &state->notifications, link) {\n\t\tif (!match_criteria(criteria, notif)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!location) {\n\t\t\tlocation = notif->link.prev;\n\t\t}\n\n\t\twl_list_remove(&notif->link);\n\t\twl_list_insert(matches.prev, &notif->link);\n\t\tnotif->group_index = count++;\n\t}\n\n\t// If count is zero, we don't need to worry about changing anything. The\n\t// notification's style has its grouping criteria set to none.\n\n\tif (count == 1) {\n\t\t// If we matched a single notification, it means that it has grouping\n\t\t// criteria set, but didn't have any others to group with. This makes\n\t\t// it ungrouped just as if it had no grouping criteria. If this is a\n\t\t// new notification, its index is already set to -1. However, this also\n\t\t// happens when a notification had been part of a group and all the\n\t\t// others have closed, so we need to set it anyway.\n\t\t// We can't use the current pointer, wl_list_for_each_safe clobbers it.\n\t\tnotif = wl_container_of(matches.prev, notif, link);\n\t\tnotif->group_index = -1;\n\t}\n\n\t// Now we need to rematch criteria for all of the grouped notifications,\n\t// in case it changes their styles. We also take this opportunity to record\n\t// the total number of notifications in the group, so that it can be used\n\t// in the notifications' format.\n\t// We can't skip this even if there was only a single match, as we may be\n\t// removing the second-to-last notification of a group, and still need to\n\t// potentially change style now that the matched one isn't in a group\n\t// anymore.\n\twl_list_for_each(notif, &matches, link) {\n\t\tnotif->group_count = count;\n\t}\n\n\t// Place all of the matches back into the list where the first one was\n\t// originally.\n\twl_list_insert_list(location, &matches);\n\n\t// We don't actually re-apply criteria here, that will happen just before\n\t// we render each notification anyway.\n\n\treturn count;\n}\n"
        },
        {
          "name": "pool-buffer.c",
          "type": "blob",
          "size": 3.1435546875,
          "content": "#include <cairo/cairo.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <time.h>\n#include <unistd.h>\n#include <wayland-client.h>\n#include <string.h>\n\n#include \"pool-buffer.h\"\n\nstatic void randname(char *buf) {\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\tlong r = ts.tv_nsec;\n\tfor (int i = 0; i < 6; ++i) {\n\t\tbuf[i] = 'A'+(r&15)+(r&16)*2;\n\t\tr >>= 5;\n\t}\n}\n\nstatic int anonymous_shm_open(void) {\n\tchar name[] = \"/mako-XXXXXX\";\n\tint retries = 100;\n\n\tdo {\n\t\trandname(name + strlen(name) - 6);\n\n\t\t--retries;\n\t\t// shm_open guarantees that O_CLOEXEC is set\n\t\tint fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);\n\t\tif (fd >= 0) {\n\t\t\tshm_unlink(name);\n\t\t\treturn fd;\n\t\t}\n\t} while (retries > 0 && errno == EEXIST);\n\n\treturn -1;\n}\n\nstatic int create_shm_file(off_t size) {\n\tint fd = anonymous_shm_open();\n\tif (fd < 0) {\n\t\treturn fd;\n\t}\n\n\tif (ftruncate(fd, size) < 0) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic void buffer_handle_release(void *data, struct wl_buffer *wl_buffer) {\n\tstruct pool_buffer *buffer = data;\n\tbuffer->busy = false;\n}\n\nstatic const struct wl_buffer_listener buffer_listener = {\n\t.release = buffer_handle_release,\n};\n\nstatic struct pool_buffer *create_buffer(struct wl_shm *shm,\n\t\tstruct pool_buffer *buf, int32_t width, int32_t height) {\n\tconst enum wl_shm_format wl_fmt = WL_SHM_FORMAT_ARGB8888;\n\tconst cairo_format_t cairo_fmt = CAIRO_FORMAT_ARGB32;\n\n\tuint32_t stride = cairo_format_stride_for_width(cairo_fmt, width);\n\tsize_t size = stride * height;\n\n\tvoid *data = NULL;\n\tif (size > 0) {\n\t\tint fd = create_shm_file(size);\n\t\tif (fd == -1) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdata = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (data == MAP_FAILED) {\n\t\t\tclose(fd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstruct wl_shm_pool *pool = wl_shm_create_pool(shm, fd, size);\n\t\tbuf->buffer =\n\t\t\twl_shm_pool_create_buffer(pool, 0, width, height, stride, wl_fmt);\n\t\twl_buffer_add_listener(buf->buffer, &buffer_listener, buf);\n\t\twl_shm_pool_destroy(pool);\n\n\t\tclose(fd);\n\t}\n\n\tbuf->data = data;\n\tbuf->size = size;\n\tbuf->width = width;\n\tbuf->height = height;\n\tbuf->surface = cairo_image_surface_create_for_data(data, cairo_fmt, width,\n\t\theight, stride);\n\tbuf->cairo = cairo_create(buf->surface);\n\tbuf->pango = pango_cairo_create_context(buf->cairo);\n\treturn buf;\n}\n\nvoid finish_buffer(struct pool_buffer *buffer) {\n\tif (buffer->buffer) {\n\t\twl_buffer_destroy(buffer->buffer);\n\t}\n\tif (buffer->cairo) {\n\t\tcairo_destroy(buffer->cairo);\n\t}\n\tif (buffer->surface) {\n\t\tcairo_surface_destroy(buffer->surface);\n\t}\n\tif (buffer->pango) {\n\t\tg_object_unref(buffer->pango);\n\t}\n\tif (buffer->data) {\n\t\tmunmap(buffer->data, buffer->size);\n\t}\n\tmemset(buffer, 0, sizeof(struct pool_buffer));\n}\n\nstruct pool_buffer *get_next_buffer(struct wl_shm *shm,\n\t\tstruct pool_buffer pool[static 2], uint32_t width, uint32_t height) {\n\tstruct pool_buffer *buffer = NULL;\n\tfor (size_t i = 0; i < 2; ++i) {\n\t\tif (pool[i].busy) {\n\t\t\tcontinue;\n\t\t}\n\t\tbuffer = &pool[i];\n\t}\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\n\tif (buffer->width != width || buffer->height != height) {\n\t\tfinish_buffer(buffer);\n\t}\n\n\tif (!buffer->buffer) {\n\t\tif (!create_buffer(shm, buffer, width, height)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn buffer;\n}\n"
        },
        {
          "name": "protocol",
          "type": "tree",
          "content": null
        },
        {
          "name": "render.c",
          "type": "blob",
          "size": 14.7509765625,
          "content": "#include <stdlib.h>\n#include <cairo/cairo.h>\n#include <pango/pangocairo.h>\n\n#include \"config.h\"\n#include \"criteria.h\"\n#include \"mako.h\"\n#include \"notification.h\"\n#include \"render.h\"\n#include \"wayland.h\"\n#include \"wlr-layer-shell-unstable-v1-client-protocol.h\"\n#include \"icon.h\"\n\n#define M_PI 3.14159265358979323846\n\n// HiDPI conventions: local variables are in surface-local coordinates, unless\n// they have a \"buffer_\" prefix, in which case they are in buffer-local\n// coordinates.\n\nstatic void set_source_u32(cairo_t *cairo, uint32_t color) {\n\tcairo_set_source_rgba(cairo,\n\t\t(color >> (3*8) & 0xFF) / 255.0,\n\t\t(color >> (2*8) & 0xFF) / 255.0,\n\t\t(color >> (1*8) & 0xFF) / 255.0,\n\t\t(color >> (0*8) & 0xFF) / 255.0);\n}\n\nstatic void set_layout_size(PangoLayout *layout, int width, int height,\n\t\tint scale) {\n\tpango_layout_set_width(layout, width * scale * PANGO_SCALE);\n\tpango_layout_set_height(layout, height * scale * PANGO_SCALE);\n}\n\nstatic void move_to(cairo_t *cairo, double x, double y, int scale) {\n\tcairo_move_to(cairo, x * scale, y * scale);\n}\n\nstatic void set_rounded_rectangle(cairo_t *cairo, double x, double y, double width, double height,\n\t\tint scale, int radius) {\n\tif (width == 0 || height == 0) {\n\t\treturn;\n\t}\n\tx *= scale;\n\ty *= scale;\n\twidth *= scale;\n\theight *= scale;\n\tradius *= scale;\n\tdouble degrees = M_PI / 180.0;\n\n\tcairo_new_sub_path(cairo);\n\tcairo_arc(cairo, x + width - radius, y + radius, radius, -90 * degrees, 0 * degrees);\n\tcairo_arc(cairo, x + width - radius, y + height - radius, radius, 0 * degrees, 90 * degrees);\n\tcairo_arc(cairo, x + radius, y + height - radius, radius, 90 * degrees, 180 * degrees);\n\tcairo_arc(cairo, x + radius, y + radius, radius, 180 * degrees, 270 * degrees);\n\tcairo_close_path(cairo);\n}\n\nstatic cairo_subpixel_order_t get_cairo_subpixel_order(\n\t\tenum wl_output_subpixel subpixel) {\n\tswitch (subpixel) {\n\tcase WL_OUTPUT_SUBPIXEL_UNKNOWN:\n\tcase WL_OUTPUT_SUBPIXEL_NONE:\n\t\treturn CAIRO_SUBPIXEL_ORDER_DEFAULT;\n\tcase WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB:\n\t\treturn CAIRO_SUBPIXEL_ORDER_RGB;\n\tcase WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR:\n\t\treturn CAIRO_SUBPIXEL_ORDER_BGR;\n\tcase WL_OUTPUT_SUBPIXEL_VERTICAL_RGB:\n\t\treturn CAIRO_SUBPIXEL_ORDER_VRGB;\n\tcase WL_OUTPUT_SUBPIXEL_VERTICAL_BGR:\n\t\treturn CAIRO_SUBPIXEL_ORDER_VBGR;\n\t}\n\tabort();\n}\n\nstatic void set_font_options(cairo_t *cairo, struct mako_surface *surface) {\n\tif (surface->surface_output == NULL) {\n\t\treturn;\n\t}\n\n\tcairo_font_options_t *fo = cairo_font_options_create();\n\tif (surface->surface_output->subpixel == WL_OUTPUT_SUBPIXEL_NONE) {\n\t\tcairo_font_options_set_antialias(fo, CAIRO_ANTIALIAS_GRAY);\n\t} else {\n\t\tcairo_font_options_set_antialias(fo, CAIRO_ANTIALIAS_SUBPIXEL);\n\t\tcairo_font_options_set_subpixel_order(fo,\n\t\t\tget_cairo_subpixel_order(surface->surface_output->subpixel));\n\t}\n\tcairo_set_font_options(cairo, fo);\n\tcairo_font_options_destroy(fo);\n}\n\nstatic int render_notification(cairo_t *cairo, struct mako_state *state, struct mako_surface *surface,\n\t\tstruct mako_style *style, const char *text, struct mako_icon *icon, int offset_y, int scale,\n\t\tstruct mako_hotspot *hotspot, int progress) {\n\tint border_size = 2 * style->border_size;\n\tint padding_height = style->padding.top + style->padding.bottom;\n\tint padding_width = style->padding.left + style->padding.right;\n\tint radius = style->border_radius;\n\tbool icon_vertical = style->icon_location == MAKO_ICON_LOCATION_TOP ||\n\t\tstyle->icon_location == MAKO_ICON_LOCATION_BOTTOM;\n\n\t// If the compositor has forced us to shrink down, do so.\n\tint notif_width =\n\t\t(style->width <= surface->width) ? style->width : surface->width;\n\n\t// offset_x is for the entire draw operation inside the surface\n\tint offset_x;\n\tif (surface->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT) {\n\t\toffset_x = surface->width - notif_width - style->margin.right;\n\t} else if (surface->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT) {\n\t\toffset_x = style->margin.left;\n\t} else { // CENTER has nothing to & with, so it's the else case\n\t\toffset_x = (surface->width - notif_width) / 2;\n\t}\n\n\t// text_x is the offset of the text inside our draw operation\n\tdouble text_x = style->padding.left;\n\tif (icon != NULL && style->icon_location == MAKO_ICON_LOCATION_LEFT) {\n\t\ttext_x = icon->width + 2*style->padding.left;\n\t}\n\n\t// text_y is the offset of the text inside our draw operation\n\tdouble text_y = style->padding.top;\n\tif (icon != NULL && style->icon_location == MAKO_ICON_LOCATION_TOP) {\n\t\ttext_y = icon->height + 2*style->padding.top;\n\t}\n\n\tdouble text_layout_width = notif_width - border_size - padding_width;\n\tif (icon && ! icon_vertical) {\n\t\ttext_layout_width -= icon->width;\n\t\ttext_layout_width -= style->icon_location == MAKO_ICON_LOCATION_LEFT ?\n\t\t\t(style->padding.left * 2) : (style->padding.right * 2);\n\t}\n\tdouble text_layout_height = style->height - border_size - padding_height;\n\tif (icon && icon_vertical) {\n\t\ttext_layout_height -= icon->height;\n\t\ttext_layout_height -= style->icon_location == MAKO_ICON_LOCATION_TOP ?\n\t\t\t(style->padding.top * 2) : (style->padding.bottom * 2);\n\t}\n\n\tset_font_options(cairo, surface);\n\n\tPangoLayout *layout = pango_cairo_create_layout(cairo);\n\tset_layout_size(layout, text_layout_width, text_layout_height, scale);\n\tpango_layout_set_alignment(layout, style->text_alignment);\n\tpango_layout_set_wrap(layout, PANGO_WRAP_WORD_CHAR);\n\tpango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_END);\n\tPangoFontDescription *desc =\n\t\tpango_font_description_from_string(style->font);\n\tpango_layout_set_font_description(layout, desc);\n\tpango_font_description_free(desc);\n\n\tPangoAttrList *attrs = NULL;\n\tGError *error = NULL;\n\tchar *buf = NULL;\n\tif (pango_parse_markup(text, -1, 0, &attrs, &buf, NULL, &error)) {\n\t\tpango_layout_set_text(layout, buf, -1);\n\t\tfree(buf);\n\t} else {\n\t\tfprintf(stderr, \"cannot parse pango markup: %s\\n\", error->message);\n\t\tg_error_free(error);\n\t\t// fallback to plain text\n\t\tpango_layout_set_text(layout, text, -1);\n\t}\n\n\tif (attrs == NULL) {\n\t\tattrs = pango_attr_list_new();\n\t}\n\tpango_attr_list_insert(attrs, pango_attr_scale_new(scale));\n\tpango_layout_set_attributes(layout, attrs);\n\tpango_attr_list_unref(attrs);\n\n\tint buffer_text_height = 0;\n\tint buffer_text_width = 0;\n\n\t// If there's no text to be rendered, the notification can shrink down\n\t// smaller than the line height.\n\tif (pango_layout_get_character_count(layout) > 0) {\n\t\tpango_layout_get_pixel_size(layout, &buffer_text_width, &buffer_text_height);\n\t}\n\tint text_height = buffer_text_height / scale;\n\tint text_width = buffer_text_width / scale;\n\n\tif (text_height > text_layout_height) {\n\t\ttext_height = text_layout_height;\n\t}\n\n\tint notif_height = text_height + border_size + padding_height;\n\tif (icon && icon_vertical) {\n\t\tnotif_height += icon->height;\n\t\tnotif_height += style->icon_location == MAKO_ICON_LOCATION_TOP ?\n\t\t\tstyle->padding.top : style->padding.bottom;\n\t}\n\tif (icon != NULL && ! icon_vertical && icon->height > text_height) {\n\t\tnotif_height = icon->height + border_size + padding_height;\n\t}\n\n\tif (notif_height < radius * 2) {\n\t\tnotif_height = radius * 2 + border_size;\n\t}\n\n\tint notif_background_width = notif_width - style->border_size;\n\n\t// Define the shape of the notification. The stroke is drawn centered on\n\t// the edge of the fill, so we need to inset the shape by half the\n\t// border_size.\n\tset_rounded_rectangle(cairo,\n\t\toffset_x + style->border_size / 2.0,\n\t\toffset_y + style->border_size / 2.0,\n\t\tnotif_background_width,\n\t\tnotif_height - style->border_size,\n\t\tscale, radius);\n\n\t// Render background, keeping the path.\n\tset_source_u32(cairo, style->colors.background);\n\tcairo_fill_preserve(cairo);\n\n\t// Keep a copy of the path. We need it later to draw the border on top, but\n\t// we have to create a new one for progress in the meantime.\n\tcairo_path_t *border_path = cairo_copy_path(cairo);\n\n\t// Render progress. We need to render this as a normal rectangle, but clip\n\t// it to the rounded rectangle we drew for the background. We also inset it\n\t// a bit further so that 0 and 100 percent are aligned to the inside edge\n\t// of the border and we can actually see the whole range.\n\tint progress_width =\n\t\t(notif_background_width - style->border_size) * progress / 100;\n\tif (progress_width < 0) {\n\t\tprogress_width = 0;\n\t} else if (progress_width > notif_background_width) {\n\t\tprogress_width = notif_background_width - style->border_size;\n\t}\n\n\tcairo_save(cairo);\n\tcairo_clip(cairo);\n\tcairo_set_operator(cairo, style->colors.progress.operator);\n\tset_source_u32(cairo, style->colors.progress.value);\n\tset_rounded_rectangle(cairo,\n\t\t\toffset_x + style->border_size,\n\t\t\toffset_y + style->border_size,\n\t\t\tprogress_width,\n\t\t\tnotif_height - style->border_size,\n\t\t\tscale, 0);\n\tcairo_fill(cairo);\n\tcairo_restore(cairo);\n\n\t// Render border, using the SOURCE operator to clip away the background\n\t// and progress beneath. This is the only way to make the background appear\n\t// to line up with the inside of a rounded border, while not revealing any\n\t// of the background when using a translucent border color.\n\tcairo_save(cairo);\n\tcairo_append_path(cairo, border_path);\n\tset_source_u32(cairo, style->colors.border);\n\tcairo_set_operator(cairo, CAIRO_OPERATOR_SOURCE);\n\tcairo_set_line_width(cairo, style->border_size * scale);\n\tcairo_stroke(cairo);\n\tcairo_restore(cairo);\n\n\tcairo_path_destroy(border_path);\n\n\tif (icon != NULL) {\n\t\t// Render icon\n\t\tdouble xpos = -1;\n\t\tdouble ypos = -1;\n\t\tdouble ypos_center = offset_y + style->border_size +\n\t\t\t(notif_height - icon->height - border_size) / 2;\n\t\tdouble xpos_center = offset_x + style->border_size +\n\t\t\t(notif_width - icon->width - border_size) / 2;\n\n\t\tswitch (style->icon_location) {\n\t\tcase MAKO_ICON_LOCATION_LEFT:\n\t\t\txpos = offset_x + style->border_size +\n\t\t\t\tstyle->padding.left;\n\t\t\typos = ypos_center;\n\t\t\tbreak;\n\t\tcase MAKO_ICON_LOCATION_RIGHT:\n\t\t\txpos = offset_x + notif_width - style->border_size -\n\t\t\t\tstyle->padding.right - icon->width;\n\t\t\typos = ypos_center;\n\t\t\tbreak;\n\t\tcase MAKO_ICON_LOCATION_TOP:\n\t\t\txpos = xpos_center;\n\t\t\typos = offset_y + style->border_size +\n\t\t\t\tstyle->padding.top;\n\t\t\tbreak;\n\t\tcase MAKO_ICON_LOCATION_BOTTOM:\n\t\t\txpos = xpos_center;\n\t\t\typos = offset_y + notif_height - style->border_size -\n\t\t\t\tstyle->padding.bottom - icon->height;\n\t\t\tbreak;\n\t\t}\n\t\tdraw_icon(cairo, icon, xpos, ypos, scale);\n\t}\n\n\tif (icon_vertical) {\n\t\ttext_x = (notif_width - text_width - border_size) / 2;\n\t} else {\n\t\ttext_y = (notif_height - text_height - border_size) / 2;\n\t}\n\n\t// Render text\n\tset_source_u32(cairo, style->colors.text);\n\tmove_to(cairo,\n\t\toffset_x + style->border_size + text_x,\n\t\toffset_y + style->border_size + text_y,\n\t\tscale);\n\tpango_cairo_update_layout(cairo, layout);\n\tpango_cairo_show_layout(cairo, layout);\n\n\t// Update hotspot with calculated location\n\tif (hotspot != NULL) {\n\t\thotspot->x = offset_x;\n\t\thotspot->y = offset_y;\n\t\thotspot->width = notif_width;\n\t\thotspot->height = notif_height;\n\t}\n\n\tg_object_unref(layout);\n\n\treturn notif_height;\n}\n\nvoid render(struct mako_surface *surface, struct pool_buffer *buffer, int scale,\n\t\tint *rendered_width, int *rendered_height) {\n\tstruct mako_state *state = surface->state;\n\tcairo_t *cairo = buffer->cairo;\n\n\t*rendered_width = *rendered_height = 0;\n\n\tif (wl_list_empty(&state->notifications)) {\n\t\treturn;\n\t}\n\n\t// Clear\n\tcairo_save(cairo);\n\tcairo_set_source_rgba(cairo, 0, 0, 0, 0);\n\tcairo_set_operator(cairo, CAIRO_OPERATOR_SOURCE);\n\tcairo_paint(cairo);\n\tcairo_restore(cairo);\n\n\tsize_t visible_count = 0;\n\tsize_t hidden_count = 0;\n\tint total_height = 0;\n\tint max_width = 0;\n\tint pending_bottom_margin = 0;\n\tstruct mako_notification *notif;\n\tsize_t total_notifications = 0;\n\twl_list_for_each(notif, &state->notifications, link) {\n\t\tif (notif->surface != surface) {\n\t\t\tcontinue;\n\t\t}\n\t\t++total_notifications;\n\n\t\t// Immediately before rendering we need to re-match all of the criteria\n\t\t// so that matches against the anchor and output work even if the\n\t\t// output was automatically assigned by the compositor.\n\t\tint rematch_count = apply_each_criteria(&state->config.criteria, notif);\n\t\tif (rematch_count == -1) {\n\t\t\t// We encountered an allocation failure or similar while applying\n\t\t\t// criteria. The notification may be partially matched, but the\n\t\t\t// worst case is that it has an empty style, so bail.\n\t\t\tfprintf(stderr, \"Failed to apply criteria\\n\");\n\t\t\tbreak;\n\t\t} else if (rematch_count == 0) {\n\t\t\t// This should be impossible, since the global criteria is always\n\t\t\t// present in a mako_config and matches everything.\n\t\t\tfprintf(stderr, \"Notification matched zero criteria?!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t// Note that by this point, everything in the style is guaranteed to\n\t\t// be specified, so we don't need to check.\n\t\tstruct mako_style *style = &notif->style;\n\n\t\tif (style->max_visible >= 0 &&\n\t\t\t\tvisible_count >= (size_t)style->max_visible) {\n\t\t\t++hidden_count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (style->invisible) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize_t text_len =\n\t\t\tformat_text(style->format, NULL, format_notif_text, notif);\n\n\t\tchar *text = malloc(text_len + 1);\n\t\tif (text == NULL) {\n\t\t\tfprintf(stderr, \"Unable to allocate memory to render notification\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tformat_text(style->format, text, format_notif_text, notif);\n\n\t\tif (style->margin.top > pending_bottom_margin) {\n\t\t\ttotal_height += style->margin.top;\n\t\t} else {\n\t\t\ttotal_height += pending_bottom_margin;\n\t\t}\n\n\t\tstruct mako_icon *icon = (style->icons) ? notif->icon : NULL;\n\t\tint notif_height = render_notification(\n\t\t\tcairo, state, surface, style, text, icon, total_height, scale,\n\t\t\t&notif->hotspot, notif->progress);\n\t\tfree(text);\n\n\t\tint notif_width =\n\t\t\tstyle->width + style->margin.left + style->margin.right;\n\n\t\ttotal_height += notif_height;\n\t\tif (max_width < notif_width) {\n\t\t\tmax_width = notif_width;\n\t\t}\n\t\tpending_bottom_margin = style->margin.bottom;\n\n\t\tif (notif->group_index < 1) {\n\t\t\t// If the notification is ungrouped, or is the first in a group, it\n\t\t\t// counts against max_visible. Even if other notifications in the\n\t\t\t// group are rendered based on criteria, a group is considered a\n\t\t\t// single entity for this purpose.\n\t\t\t++visible_count;\n\t\t}\n\t}\n\n\tif (hidden_count > 0) {\n\t\tstruct mako_notification *hidden_notif = create_notification(state);\n\t\thidden_notif->surface = surface;\n\t\thidden_notif->hidden = true;\n\t\tapply_each_criteria(&state->config.criteria, hidden_notif);\n\n\t\tstruct mako_style *style = &hidden_notif->style;\n\n\t\tif (style->margin.top > pending_bottom_margin) {\n\t\t\ttotal_height += style->margin.top;\n\t\t} else {\n\t\t\ttotal_height += pending_bottom_margin;\n\t\t}\n\n\t\tstruct mako_hidden_format_data data = {\n\t\t\t.hidden = hidden_count,\n\t\t\t.count = total_notifications,\n\t\t};\n\n\t\tsize_t text_ln =\n\t\t\tformat_text(style->format, NULL, format_hidden_text, &data);\n\t\tchar *text = malloc(text_ln + 1);\n\t\tif (text == NULL) {\n\t\t\tfprintf(stderr, \"allocation failed\");\n\t\t\treturn;\n\t\t}\n\n\t\tformat_text(style->format, text, format_hidden_text, &data);\n\n\t\tint hidden_height = render_notification(\n\t\t\tcairo, state, surface, style, text, NULL, total_height, scale, NULL, 0);\n\t\tfree(text);\n\n\t\ttotal_height += hidden_height;\n\t\tpending_bottom_margin = style->margin.bottom;\n\t\tdestroy_notification(hidden_notif);\n\t}\n\n\t*rendered_width = max_width;\n\t*rendered_height = total_height;\n}\n"
        },
        {
          "name": "string-util.c",
          "type": "blob",
          "size": 0.3994140625,
          "content": "#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *mako_asprintf(const char *fmt, ...) {\n\tchar *text;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tint size = vsnprintf(NULL, 0, fmt, args);\n\tva_end(args);\n\n\tif (size < 0) {\n\t\treturn NULL;\n\t}\n\n\ttext = malloc(size + 1);\n\tif (text == NULL) {\n\t\treturn NULL;\n\t}\n\n\tva_start(args, fmt);\n\tvsnprintf(text, size + 1, fmt, args);\n\tva_end(args);\n\n\treturn text;\n}\n"
        },
        {
          "name": "surface.c",
          "type": "blob",
          "size": 1.0048828125,
          "content": "#include <string.h>\n#include <stdlib.h>\n\n#include \"mako.h\"\n#include \"surface.h\"\n\nvoid destroy_surface(struct mako_surface *surface) {\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tif (surface->frame_callback != NULL) {\n\t\twl_callback_destroy(surface->frame_callback);\n\t}\n\tfinish_buffer(&surface->buffers[0]);\n\tfinish_buffer(&surface->buffers[1]);\n\n\t/* Clean up memory resources */\n\tfree(surface->configured_output);\n\twl_list_remove(&surface->link);\n\tfree(surface);\n}\n\nstruct mako_surface *create_surface(struct mako_state *state, const char *output,\n\t\tenum zwlr_layer_shell_v1_layer layer, uint32_t anchor) {\n\tstruct mako_surface *surface = calloc(1, sizeof(*surface));\n\tif (!surface) {\n\t\treturn NULL;\n\t}\n\n\tsurface->configured_output = strdup(output);\n\tsurface->layer = layer;\n\tsurface->anchor = anchor;\n\tsurface->state = state;\n\n\twl_list_insert(&state->surfaces, &surface->link);\n\treturn surface;\n}\n"
        },
        {
          "name": "types.c",
          "type": "blob",
          "size": 8.564453125,
          "content": "#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <wayland-client.h>\n#include <wordexp.h>\n#include <unistd.h>\n\n#include \"enum.h\"\n#include \"types.h\"\n\n\nconst char VALID_FORMAT_SPECIFIERS[] = \"%asbhtgi\";\n\n\nbool parse_boolean(const char *string, bool *out) {\n\tif (strcasecmp(string, \"true\") == 0 || strcmp(string, \"1\") == 0) {\n\t\t*out = true;\n\t\treturn true;\n\t} else if (strcasecmp(string, \"false\") == 0 || strcmp(string, \"0\") == 0) {\n\t\t*out = false;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool parse_int(const char *string, int *out) {\n\terrno = 0;\n\tchar *end;\n\tint parsed;\n\tparsed = (int)strtol(string, &end, 10);\n\tif (errno == 0 && end[0] == '\\0') {\n\t\t*out = parsed;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool parse_int_ge(const char *string, int *out, int min) {\n\tint parsed;\n\tif (parse_int(string, &parsed) && parsed >= min) {\n\t\t*out = parsed;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nbool parse_color(const char *string, uint32_t *out) {\n\tif (string[0] != '#') {\n\t\treturn false;\n\t}\n\tstring++;\n\n\tsize_t len = strlen(string);\n\tif (len != 6 && len != 8) {\n\t\treturn false;\n\t}\n\n\terrno = 0;\n\tchar *end;\n\t*out = (uint32_t)strtoul(string, &end, 16);\n\tif (errno != 0 || end[0] != '\\0') {\n\t\treturn false;\n\t}\n\n\tif (len == 6) {\n\t\t*out = (*out << 8) | 0xFF;\n\t}\n\treturn true;\n}\n\nbool parse_mako_color(const char *string, struct mako_color *out) {\n\tchar *components = strdup(string);\n\n\tchar *saveptr = NULL;\n\tchar *token = strtok_r(components, \" \\t\", &saveptr);\n\n\tif (token[0] == '#') {\n\t\tout->operator = CAIRO_OPERATOR_OVER;\n\t} else {\n\t\tif (strcasecmp(token, \"over\") == 0) {\n\t\t\tout->operator = CAIRO_OPERATOR_OVER;\n\t\t} else if (strcasecmp(token, \"source\") == 0) {\n\t\t\tout->operator = CAIRO_OPERATOR_SOURCE;\n\t\t} else {\n\t\t\tfree(components);\n\t\t\treturn false;\n\t\t}\n\n\t\ttoken = strtok_r(NULL, \" \\t\", &saveptr);\n\t\tif (token == NULL) {\n\t\t\tfree(components);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool ok = parse_color(token, &out->value);\n\n\tfree(components);\n\treturn ok;\n}\n\nbool parse_urgency(const char *string, enum mako_notification_urgency *out) {\n\tif (strcasecmp(string, \"low\") == 0) {\n\t\t*out = MAKO_NOTIFICATION_URGENCY_LOW;\n\t\treturn true;\n\t} else if (strcasecmp(string, \"normal\") == 0) {\n\t\t*out = MAKO_NOTIFICATION_URGENCY_NORMAL;\n\t\treturn true;\n\t} else if (strcasecmp(string, \"critical\") == 0) {\n\t\t*out = MAKO_NOTIFICATION_URGENCY_CRITICAL;\n\t\treturn true;\n\t} else if (strcasecmp(string, \"high\") == 0) {\n\t\t*out = MAKO_NOTIFICATION_URGENCY_CRITICAL;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/* Parse between 1 and 4 integers, comma separated, from the provided string.\n * Depending on the number of integers provided, the four fields of the `out`\n * struct will be initialized following the same rules as the CSS \"margin\"\n * property.\n */\nbool parse_directional(const char *string, struct mako_directional *out) {\n\tchar *components = strdup(string);\n\n\tint32_t values[] = {0, 0, 0, 0};\n\n\tchar *saveptr = NULL;\n\tchar *token = strtok_r(components, \",\", &saveptr);\n\tsize_t count;\n\tfor (count = 0; count < 4; count++) {\n\t\tif (token == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint32_t number;\n\t\tif (!parse_int(token, &number)) {\n\t\t\t// There were no digits, or something else went horribly wrong\n\t\t\tfree(components);\n\t\t\treturn false;\n\t\t}\n\n\t\tvalues[count] = number;\n\t\ttoken = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tswitch (count) {\n\tcase 1: // All values are the same\n\t\tout->top = out->right = out->bottom = out->left = values[0];\n\t\tbreak;\n\tcase 2: // Vertical, horizontal\n\t\tout->top = out->bottom = values[0];\n\t\tout->right = out->left = values[1];\n\t\tbreak;\n\tcase 3: // Top, horizontal, bottom\n\t\tout->top = values[0];\n\t\tout->right = out->left = values[1];\n\t\tout->bottom = values[2];\n\t\tbreak;\n\tcase 4: // Top, right, bottom, left\n\t\tout->top = values[0];\n\t\tout->right = values[1];\n\t\tout->bottom = values[2];\n\t\tout->left = values[3];\n\t\tbreak;\n\t}\n\n\tfree(components);\n\treturn true;\n}\n\nbool parse_criteria_spec(const char *string, struct mako_criteria_spec *out) {\n\t// Clear any existing specified fields in the output spec.\n\tmemset(out, 0, sizeof(struct mako_criteria_spec));\n\n\tchar *components = strdup(string);\n\tchar *saveptr = NULL;\n\tchar *token = strtok_r(components, \",\", &saveptr);\n\n\twhile (token) {\n\t\t// Can't just use &= because then we nave no way to report invalid\n\t\t// values. :(\n\t\tif (strcmp(token, \"app-name\") == 0) {\n\t\t\tout->app_name = true;\n\t\t} else if (strcmp(token, \"app-icon\") == 0) {\n\t\t\tout->app_icon = true;\n\t\t} else if (strcmp(token, \"actionable\") == 0) {\n\t\t\tout->actionable = true;\n\t\t} else if (strcmp(token, \"expiring\") == 0) {\n\t\t\tout->expiring = true;\n\t\t} else if (strcmp(token, \"urgency\") == 0) {\n\t\t\tout->urgency = true;\n\t\t} else if (strcmp(token, \"category\") == 0) {\n\t\t\tout->category = true;\n\t\t} else if (strcmp(token, \"desktop-entry\") == 0) {\n\t\t\tout->desktop_entry = true;\n\t\t} else if (strcmp(token, \"summary\") == 0) {\n\t\t\tout->summary = true;\n\t\t} else if (strcmp(token, \"body\") == 0) {\n\t\t\tout->body = true;\n\t\t} else if (strcmp(token, \"grouped\") == 0) {\n\t\t\tout->grouped = true;\n\t\t} else if (strcmp(token, \"group-index\") == 0) {\n\t\t\tout->group_index = true;\n\t\t} else if (strcmp(token, \"anchor\") == 0) {\n\t\t\tout->anchor = true;\n\t\t} else if (strcmp(token, \"output\") == 0) {\n\t\t\tout->output = true;\n\t\t} else if (strcmp(token, \"none\") == 0) {\n\t\t\tout->none = true;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown criteria field '%s'\\n\", token);\n\t\t\tfree(components);\n\t\t\treturn false;\n\t\t}\n\n\t\ttoken = strtok_r(NULL, \",\", &saveptr);\n\t}\n\n\tfree(components);\n\treturn true;\n}\n\n// Checks whether any of the fields of the given specification are set. Useful\n// for checking for some subset of fields without enumerating all known fields\n// yourself. Often you will want to copy a spec and clear fields you _don't_\n// care about to use this.\nbool mako_criteria_spec_any(const struct mako_criteria_spec *spec) {\n\treturn\n\t\tspec->app_name ||\n\t\tspec->app_icon ||\n\t\tspec->actionable ||\n\t\tspec->expiring ||\n\t\tspec->urgency ||\n\t\tspec->category ||\n\t\tspec->desktop_entry ||\n\t\tspec->summary ||\n\t\tspec->summary_pattern ||\n\t\tspec->body ||\n\t\tspec->body_pattern ||\n\t\tspec->none ||\n\t\tspec->group_index ||\n\t\tspec->grouped ||\n\t\tspec->hidden ||\n\t\tspec->output ||\n\t\tspec->anchor;\n}\n\nbool parse_format(const char *string, char **out) {\n\tsize_t token_max_length = strlen(string) + 1;\n\tchar token[token_max_length];\n\tmemset(token, 0, token_max_length);\n\tsize_t token_location = 0;\n\n\tenum mako_parse_state state = MAKO_PARSE_STATE_NORMAL;\n\tfor (size_t i = 0; i < token_max_length; ++i) {\n\t\tchar ch = string[i];\n\n\t\tswitch (state) {\n\t\tcase MAKO_PARSE_STATE_FORMAT:\n\t\t\tif (!strchr(VALID_FORMAT_SPECIFIERS, ch)) {\n\t\t\t\t// There's an invalid format specifier, bail.\n\t\t\t\t*out = NULL;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttoken[token_location] = ch;\n\t\t\t++token_location;\n\t\t\tstate = MAKO_PARSE_STATE_NORMAL;\n\t\t\tbreak;\n\n\t\tcase MAKO_PARSE_STATE_ESCAPE:\n\t\t\tswitch (ch) {\n\t\t\tcase 'n':\n\t\t\t\ttoken[token_location] = '\\n';\n\t\t\t\t++token_location;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\\\':\n\t\t\t\ttoken[token_location] = '\\\\';\n\t\t\t\t++token_location;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t++token_location;\n\t\t\t\ttoken[token_location] = ch;\n\t\t\t\t++token_location;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstate = MAKO_PARSE_STATE_NORMAL;\n\t\t\tbreak;\n\n\t\tcase MAKO_PARSE_STATE_NORMAL:\n\t\t\tswitch (ch) {\n\t\t\tcase '\\\\':\n\t\t\t\ttoken[token_location] = ch;\n\t\t\t\tstate = MAKO_PARSE_STATE_ESCAPE;\n\t\t\t\tbreak;\n\n\t\t\tcase '%':\n\t\t\t\ttoken[token_location] = ch;\n\t\t\t\t++token_location; // Leave the % intact.\n\t\t\t\tstate = MAKO_PARSE_STATE_FORMAT;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttoken[token_location] = ch;\n\t\t\t\t++token_location;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*out = NULL;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t*out = strdup(token);\n\treturn true;\n}\n\nbool parse_anchor(const char *string, uint32_t *out) {\n\tif (strcmp(string, \"top-right\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;\n\t} else if (strcmp(string, \"top-center\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP;\n\t} else if (strcmp(string, \"top-left\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT;\n\t} else if (strcmp(string, \"bottom-right\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;\n\t} else if (strcmp(string, \"bottom-center\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM;\n\t} else if (strcmp(string, \"bottom-left\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT;\n\t} else if (strcmp(string, \"center-right\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;\n\t} else if (strcmp(string, \"center-left\") == 0) {\n\t\t*out = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT;\n\t} else if (strcmp(string, \"center\") == 0) {\n\t\t*out = 0;\n\t} else {\n\t\tfprintf(stderr, \"Invalid anchor value '%s'\\n\", string);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"
        },
        {
          "name": "wayland.c",
          "type": "blob",
          "size": 23.560546875,
          "content": "#include <assert.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"criteria.h\"\n#include \"mako.h\"\n#include \"notification.h\"\n#include \"render.h\"\n#include \"surface.h\"\n#include \"wayland.h\"\n\nstatic void noop() {\n\t// This space intentionally left blank\n}\n\n\nstatic void output_handle_geometry(void *data, struct wl_output *wl_output,\n\t\tint32_t x, int32_t y, int32_t phy_width, int32_t phy_height,\n\t\tint32_t subpixel, const char *make, const char *model,\n\t\tint32_t transform) {\n\tstruct mako_output *output = data;\n\toutput->subpixel = subpixel;\n}\n\nstatic void output_handle_scale(void *data, struct wl_output *wl_output,\n\t\tint32_t factor) {\n\tstruct mako_output *output = data;\n\toutput->scale = factor;\n}\n\nstatic void output_handle_name(void *data, struct wl_output *wl_output,\n\t\tconst char *name) {\n\tstruct mako_output *output = data;\n\toutput->name = strdup(name);\n}\n\nstatic const struct wl_output_listener output_listener = {\n\t.geometry = output_handle_geometry,\n\t.mode = noop,\n\t.done = noop,\n\t.scale = output_handle_scale,\n\t.name = output_handle_name,\n\t.description = noop,\n};\n\nstatic void send_frame(struct mako_surface *surface);\n\nstatic void create_output(struct mako_state *state,\n\t\tstruct wl_output *wl_output, uint32_t global_name) {\n\tstruct mako_output *output = calloc(1, sizeof(struct mako_output));\n\tstruct mako_surface *surface;\n\tbool recreate_surface = false;\n\tif (output == NULL) {\n\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\treturn;\n\t}\n\toutput->state = state;\n\toutput->global_name = global_name;\n\toutput->wl_output = wl_output;\n\toutput->scale = 1;\n\n\trecreate_surface = wl_list_empty(&state->outputs);\n\n\twl_list_insert(&state->outputs, &output->link);\n\n\twl_output_set_user_data(wl_output, output);\n\twl_output_add_listener(wl_output, &output_listener, output);\n\tif (recreate_surface) {\n\t\t// We had no outputs, force our surfaces to redraw\n\t\twl_list_for_each(surface, &output->state->surfaces, link) {\n\t\t\tset_dirty(surface);\n\t\t}\n\t}\n}\n\nstatic void destroy_output(struct mako_output *output) {\n\tstruct mako_surface *surface;\n\twl_list_for_each(surface, &output->state->surfaces, link) {\n\t\tif (surface->surface_output == output) {\n\t\t\tsurface->surface_output = NULL;\n\t\t}\n\t\tif (surface->layer_surface_output == output) {\n\t\t\tsurface->layer_surface_output = NULL;\n\t\t}\n\t}\n\twl_list_remove(&output->link);\n\twl_output_destroy(output->wl_output);\n\tfree(output->name);\n\tfree(output);\n}\n\nstatic struct mako_surface *get_surface(struct mako_state *state,\n\t\tstruct wl_surface *wl_surface) {\n\tstruct mako_surface *surface;\n\twl_list_for_each(surface, &state->surfaces, link) {\n\t\tif (surface->surface == wl_surface) {\n\t\t\treturn surface;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void touch_handle_motion(void *data, struct wl_touch *wl_touch,\n\t\tuint32_t time, int32_t id,\n\t\twl_fixed_t surface_x, wl_fixed_t surface_y) {\n\tstruct mako_seat *seat = data;\n\tif (id >= MAX_TOUCHPOINTS) {\n\t\treturn;\n\t}\n\tseat->touch.pts[id].x = wl_fixed_to_int(surface_x);\n\tseat->touch.pts[id].y = wl_fixed_to_int(surface_y);\n}\n\nstatic void touch_handle_down(void *data, struct wl_touch *wl_touch,\n\t\tuint32_t serial, uint32_t time, struct wl_surface *wl_surface,\n\t\tint32_t id, wl_fixed_t surface_x, wl_fixed_t surface_y) {\n\tstruct mako_seat *seat = data;\n\tif (id >= MAX_TOUCHPOINTS) {\n\t\treturn;\n\t}\n\tseat->touch.pts[id].x = wl_fixed_to_int(surface_x);\n\tseat->touch.pts[id].y = wl_fixed_to_int(surface_y);\n\tseat->touch.pts[id].surface = get_surface(seat->state, wl_surface);\n}\n\nstatic void touch_handle_up(void *data, struct wl_touch *wl_touch,\n\t\tuint32_t serial, uint32_t time, int32_t id) {\n\tstruct mako_seat *seat = data;\n\tstruct mako_state *state = seat->state;\n\n\tif (id >= MAX_TOUCHPOINTS) {\n\t\treturn;\n\t}\n\n\tconst struct mako_binding_context ctx = {\n\t\t.surface = seat->touch.pts[id].surface,\n\t\t.seat = seat,\n\t\t.serial = serial,\n\t};\n\n\tstruct mako_notification *notif;\n\twl_list_for_each(notif, &state->notifications, link) {\n\t\tif (hotspot_at(&notif->hotspot, seat->touch.pts[id].x, seat->touch.pts[id].y)) {\n\t\t\tstruct mako_surface *surface = notif->surface;\n\t\t\tnotification_handle_touch(notif, &ctx);\n\t\t\tset_dirty(surface);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tseat->touch.pts[id].surface = NULL;\n}\n\nstatic void load_default_cursor(struct mako_state *state, uint32_t scale) {\n\tconst char *cursor_name = \"left_ptr\";\n\n\t//don't reload the cursor if what we have already can be used\n\tif (state->cursor.theme != NULL && state->cursor.scale == scale) {\n\t\treturn;\n\t}\n\n\tif (state->cursor.theme != NULL) {\n\t\twl_cursor_theme_destroy(state->cursor.theme);\n\t}\n\n\tif (state->cursor.surface == NULL) {\n\t\tstate->cursor.surface = wl_compositor_create_surface(state->compositor);\n\t}\n\n\tconst char *xcursor_theme = getenv(\"XCURSOR_THEME\");\n\tstate->cursor.theme = wl_cursor_theme_load(xcursor_theme, state->cursor.size * scale, state->shm);\n\tif (state->cursor.theme == NULL) {\n\t\tfprintf(stderr, \"couldn't find a cursor theme\\n\");\n\t\treturn;\n\t}\n\tstruct wl_cursor *cursor = wl_cursor_theme_get_cursor(state->cursor.theme, cursor_name);\n\tif (cursor == NULL) {\n\t\tfprintf(stderr, \"couldn't find cursor icon \\\"%s\\\"\\n\", cursor_name);\n\t\twl_cursor_theme_destroy(state->cursor.theme);\n\t\t// Set to NULL so it doesn't get free'd again\n\t\tstate->cursor.theme = NULL;\n\t\treturn;\n\t}\n\n\tstate->cursor.scale = scale;\n\tstate->cursor.image = cursor->images[0];\n\tstruct wl_buffer *cursor_buffer = wl_cursor_image_get_buffer(cursor->images[0]);\n\twl_surface_attach(state->cursor.surface, cursor_buffer, 0, 0);\n\twl_surface_set_buffer_scale(state->cursor.surface, scale);\n\twl_surface_commit(state->cursor.surface);\n}\n\nstatic void pointer_handle_enter(void *data, struct wl_pointer *wl_pointer,\n\t\tuint32_t serial, struct wl_surface *wl_surface,\n\t\twl_fixed_t surface_x, wl_fixed_t surface_y) {\n\tstruct mako_seat *seat = data;\n\tstruct mako_state *state = seat->state;\n\n\tseat->pointer.x = wl_fixed_to_int(surface_x);\n\tseat->pointer.y = wl_fixed_to_int(surface_y);\n\tseat->pointer.surface = get_surface(state, wl_surface);\n\n\tint scale = 1;\n\n\tstruct mako_surface *surface;\n\twl_list_for_each(surface, &state->surfaces, link) {\n\t\tif (!surface->surface_output) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (surface->surface_output->scale > scale) {\n\t\t\tscale = surface->surface_output->scale;\n\t\t}\n\t}\n\n\tif (state->cursor_shape_manager != NULL) {\n\t\tstruct wp_cursor_shape_device_v1 *device =\n\t\t\twp_cursor_shape_manager_v1_get_pointer(state->cursor_shape_manager, wl_pointer);\n\t\twp_cursor_shape_device_v1_set_shape(device, serial,\n\t\t\tWP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT);\n\t\twp_cursor_shape_device_v1_destroy(device);\n\t} else {\n\t\tload_default_cursor(state, scale);\n\n\t\tif (state->cursor.theme != NULL) {\n\t\t\twl_pointer_set_cursor(wl_pointer, serial, state->cursor.surface,\n\t\t\t\tstate->cursor.image->hotspot_x / state->cursor.scale,\n\t\t\t\tstate->cursor.image->hotspot_y / state->cursor.scale);\n\t\t}\n\t}\n}\n\nstatic void pointer_handle_leave(void *data, struct wl_pointer *wl_pointer,\n\t\tuint32_t serial, struct wl_surface *wl_surface) {\n\tstruct mako_seat *seat = data;\n\tseat->pointer.surface = NULL;\n}\n\nstatic void pointer_handle_motion(void *data, struct wl_pointer *wl_pointer,\n\t\tuint32_t time, wl_fixed_t surface_x, wl_fixed_t surface_y) {\n\tstruct mako_seat *seat = data;\n\tseat->pointer.x = wl_fixed_to_int(surface_x);\n\tseat->pointer.y = wl_fixed_to_int(surface_y);\n}\n\nstatic void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,\n\t\tuint32_t serial, uint32_t time, uint32_t button,\n\t\tuint32_t button_state) {\n\tstruct mako_seat *seat = data;\n\tstruct mako_state *state = seat->state;\n\n\tconst struct mako_binding_context ctx = {\n\t\t.surface = seat->pointer.surface,\n\t\t.seat = seat,\n\t\t.serial = serial,\n\t};\n\n\tstruct mako_notification *notif;\n\twl_list_for_each(notif, &state->notifications, link) {\n\t\tif (hotspot_at(&notif->hotspot, seat->pointer.x, seat->pointer.y)) {\n\t\t\tstruct mako_surface *surface = notif->surface;\n\t\t\tnotification_handle_button(notif, button, button_state, &ctx);\n\t\t\tset_dirty(surface);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct wl_pointer_listener pointer_listener = {\n\t.enter = pointer_handle_enter,\n\t.leave = pointer_handle_leave,\n\t.motion = pointer_handle_motion,\n\t.button = pointer_handle_button,\n\t.axis = noop,\n};\n\nstatic const struct wl_touch_listener touch_listener = {\n\t.down = touch_handle_down,\n\t.up = touch_handle_up,\n\t.motion = touch_handle_motion,\n\t.frame = noop,\n\t.cancel = noop,\n\t.shape = noop,\n\t.orientation = noop,\n};\n\nstatic void seat_handle_capabilities(void *data, struct wl_seat *wl_seat,\n\t\tuint32_t capabilities) {\n\tstruct mako_seat *seat = data;\n\n\tif (seat->pointer.wl_pointer != NULL) {\n\t\twl_pointer_release(seat->pointer.wl_pointer);\n\t\tseat->pointer.wl_pointer = NULL;\n\t}\n\tif (capabilities & WL_SEAT_CAPABILITY_POINTER) {\n\t\tseat->pointer.wl_pointer = wl_seat_get_pointer(wl_seat);\n\t\twl_pointer_add_listener(seat->pointer.wl_pointer,\n\t\t\t&pointer_listener, seat);\n\t}\n\tif (seat->touch.wl_touch != NULL) {\n\t\twl_touch_release(seat->touch.wl_touch);\n\t\tseat->touch.wl_touch = NULL;\n\t}\n\tif (capabilities & WL_SEAT_CAPABILITY_TOUCH) {\n\t\tseat->touch.wl_touch = wl_seat_get_touch(wl_seat);\n\t\twl_touch_add_listener(seat->touch.wl_touch,\n\t\t\t&touch_listener, seat);\n\t}\n}\n\nstatic const struct wl_seat_listener seat_listener = {\n\t.capabilities = seat_handle_capabilities,\n\t.name = noop,\n};\n\nstatic void create_seat(struct mako_state *state, struct wl_seat *wl_seat) {\n\tstruct mako_seat *seat = calloc(1, sizeof(struct mako_seat));\n\tif (seat == NULL) {\n\t\tfprintf(stderr, \"allocation failed\\n\");\n\t\treturn;\n\t}\n\tseat->state = state;\n\tseat->wl_seat = wl_seat;\n\twl_list_insert(&state->seats, &seat->link);\n\twl_seat_add_listener(wl_seat, &seat_listener, seat);\n}\n\nstatic void destroy_seat(struct mako_seat *seat) {\n\twl_list_remove(&seat->link);\n\twl_seat_release(seat->wl_seat);\n\tif (seat->pointer.wl_pointer) {\n\t\twl_pointer_release(seat->pointer.wl_pointer);\n\t}\n\tfree(seat);\n}\n\nstatic void surface_handle_enter(void *data, struct wl_surface *surface,\n\t\tstruct wl_output *wl_output) {\n\tstruct mako_surface *msurface = data;\n\t// Don't bother keeping a list of outputs, a layer surface can only be on\n\t// one output a a time\n\tmsurface->surface_output = wl_output_get_user_data(wl_output);\n\tset_dirty(msurface);\n}\n\nstatic void surface_handle_leave(void *data, struct wl_surface *surface,\n\t\tstruct wl_output *wl_output) {\n\tstruct mako_surface *msurface = data;\n\tmsurface->surface_output = NULL;\n}\n\nstatic const struct wl_surface_listener surface_listener = {\n\t.enter = surface_handle_enter,\n\t.leave = surface_handle_leave,\n};\n\n\nstatic void schedule_frame_and_commit(struct mako_surface *state);\n\nstatic void layer_surface_handle_configure(void *data,\n\t\tstruct zwlr_layer_surface_v1 *surface,\n\t\tuint32_t serial, uint32_t width, uint32_t height) {\n\tstruct mako_surface *msurface = data;\n\n\tzwlr_layer_surface_v1_ack_configure(surface, serial);\n\n\tif (msurface->configured &&\n\t\t\tmsurface->width == (int32_t) width &&\n\t\t\tmsurface->height == (int32_t) height) {\n\t\twl_surface_commit(msurface->surface);\n\t\treturn;\n\t}\n\n\tmsurface->configured = true;\n\tmsurface->width = width;\n\tmsurface->height = height;\n\n\tsend_frame(msurface);\n}\n\nstatic void layer_surface_handle_closed(void *data,\n\t\tstruct zwlr_layer_surface_v1 *surface) {\n\tstruct mako_surface *msurface = data;\n\n\tzwlr_layer_surface_v1_destroy(msurface->layer_surface);\n\tmsurface->layer_surface = NULL;\n\n\twl_surface_destroy(msurface->surface);\n\tmsurface->surface = NULL;\n\n\tif (msurface->frame_callback) {\n\t\twl_callback_destroy(msurface->frame_callback);\n\t\tmsurface->frame_callback = NULL;\n\t\tmsurface->dirty = true;\n\t}\n\n\tif (msurface->configured) {\n\t\tmsurface->configured = false;\n\t\tmsurface->width = msurface->height = 0;\n\t\tmsurface->dirty = true;\n\t}\n\n\tif (msurface->dirty) {\n\t\tschedule_frame_and_commit(msurface);\n\t}\n}\n\nstatic const struct zwlr_layer_surface_v1_listener layer_surface_listener = {\n\t.configure = layer_surface_handle_configure,\n\t.closed = layer_surface_handle_closed,\n};\n\n\nstatic void handle_global(void *data, struct wl_registry *registry,\n\t\tuint32_t name, const char *interface, uint32_t version) {\n\tstruct mako_state *state = data;\n\n\tif (strcmp(interface, wl_compositor_interface.name) == 0) {\n\t\tstate->compositor = wl_registry_bind(registry, name,\n\t\t\t&wl_compositor_interface, 4);\n\t} else if (strcmp(interface, wl_shm_interface.name) == 0) {\n\t\tstate->shm = wl_registry_bind(registry, name,\n\t\t\t&wl_shm_interface, 1);\n\t} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {\n\t\tstate->layer_shell = wl_registry_bind(registry, name,\n\t\t\t&zwlr_layer_shell_v1_interface, 1);\n\t} else if (strcmp(interface, wl_seat_interface.name) == 0) {\n\t\tstruct wl_seat *seat =\n\t\t\twl_registry_bind(registry, name, &wl_seat_interface, 3);\n\t\tcreate_seat(state, seat);\n\t} else if (strcmp(interface, wl_output_interface.name) == 0) {\n\t\tstruct wl_output *output =\n\t\t\twl_registry_bind(registry, name, &wl_output_interface, 4);\n\t\tcreate_output(state, output, name);\n\t} else if (strcmp(interface, xdg_activation_v1_interface.name) == 0) {\n\t\tstate->xdg_activation = wl_registry_bind(registry, name,\n\t\t\t&xdg_activation_v1_interface, 1);\n\t} else if (strcmp(interface, wp_cursor_shape_manager_v1_interface.name) == 0) {\n\t\tstate->cursor_shape_manager = wl_registry_bind(registry, name,\n\t\t\t&wp_cursor_shape_manager_v1_interface, 1);\n\t}\n}\n\nstatic void handle_global_remove(void *data, struct wl_registry *registry,\n\t\tuint32_t name) {\n\tstruct mako_state *state = data;\n\n\tstruct mako_output *output, *tmp;\n\twl_list_for_each_safe(output, tmp, &state->outputs, link) {\n\t\tif (output->global_name == name) {\n\t\t\tdestroy_output(output);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct wl_registry_listener registry_listener = {\n\t.global = handle_global,\n\t.global_remove = handle_global_remove,\n};\n\nbool init_wayland(struct mako_state *state) {\n\twl_list_init(&state->outputs);\n\twl_list_init(&state->seats);\n\n\tstate->display = wl_display_connect(NULL);\n\tif (state->display == NULL) {\n\t\tfprintf(stderr, \"failed to create display\\n\");\n\t\treturn false;\n\t}\n\n\tstate->registry = wl_display_get_registry(state->display);\n\twl_registry_add_listener(state->registry, &registry_listener, state);\n\n\tif (wl_display_roundtrip(state->display) < 0) {\n\t\tfprintf(stderr, \"wl_display_roundtrip() failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (state->compositor == NULL) {\n\t\tfprintf(stderr, \"compositor doesn't support wl_compositor\\n\");\n\t\treturn false;\n\t}\n\tif (state->shm == NULL) {\n\t\tfprintf(stderr, \"compositor doesn't support wl_shm\\n\");\n\t\treturn false;\n\t}\n\tif (state->layer_shell == NULL) {\n\t\tfprintf(stderr, \"compositor doesn't support zwlr_layer_shell_v1\\n\");\n\t\treturn false;\n\t}\n\n\t// Second roundtrip to get output metadata\n\tif (wl_display_roundtrip(state->display) < 0) {\n\t\tfprintf(stderr, \"wl_display_roundtrip() failed\\n\");\n\t\treturn false;\n\t}\n\n\t// Set up the cursor. It needs a wl_surface with the cursor loaded into it.\n\t// If one of these fail, mako will work fine without the cursor being able to change.\n\tconst char *cursor_size_env = getenv(\"XCURSOR_SIZE\");\n\tint cursor_size = 24;\n\tif (cursor_size_env != NULL) {\n\t\terrno = 0;\n\t\tchar *end;\n\t\tint temp_size = (int)strtol(cursor_size_env, &end, 10);\n\t\tif (errno == 0 && cursor_size_env[0] != 0 && end[0] == 0 && temp_size > 0) {\n\t\t\tcursor_size = temp_size;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Error: XCURSOR_SIZE is invalid\\n\");\n\t\t}\n\t}\n\n\tstate->cursor.size = cursor_size;\n\n\treturn true;\n}\n\nvoid finish_wayland(struct mako_state *state) {\n\tstruct mako_surface *surface, *stmp;\n\twl_list_for_each_safe(surface, stmp, &state->surfaces, link) {\n\t\tdestroy_surface(surface);\n\t}\n\n\tstruct mako_output *output, *output_tmp;\n\twl_list_for_each_safe(output, output_tmp, &state->outputs, link) {\n\t\tdestroy_output(output);\n\t}\n\n\tstruct mako_seat *seat, *seat_tmp;\n\twl_list_for_each_safe(seat, seat_tmp, &state->seats, link) {\n\t\tdestroy_seat(seat);\n\t}\n\n\tif (state->xdg_activation != NULL) {\n\t\txdg_activation_v1_destroy(state->xdg_activation);\n\t}\n\tif (state->cursor_shape_manager != NULL) {\n\t\twp_cursor_shape_manager_v1_destroy(state->cursor_shape_manager);\n\t}\n\n\tif (state->cursor.theme != NULL) {\n\t\twl_cursor_theme_destroy(state->cursor.theme);\n\t\twl_surface_destroy(state->cursor.surface);\n\t}\n\n\tzwlr_layer_shell_v1_destroy(state->layer_shell);\n\twl_compositor_destroy(state->compositor);\n\twl_shm_destroy(state->shm);\n\twl_registry_destroy(state->registry);\n\twl_display_disconnect(state->display);\n}\n\nstatic struct wl_region *get_input_region(struct mako_surface *surface) {\n\tstruct wl_region *region =\n\t\twl_compositor_create_region(surface->state->compositor);\n\n\tstruct mako_notification *notif;\n\twl_list_for_each(notif, &surface->state->notifications, link) {\n\t\tstruct mako_hotspot *hotspot = &notif->hotspot;\n\t\tif (notif->surface == surface) {\n\t\t\twl_region_add(region, hotspot->x, hotspot->y,\n\t\t\t\thotspot->width, hotspot->height);\n\t\t}\n\t}\n\n\treturn region;\n}\n\nstatic struct mako_output *get_configured_output(struct mako_surface *surface) {\n\tconst char *output_name = surface->configured_output;\n\tif (strcmp(output_name, \"\") == 0) {\n\t\treturn NULL;\n\t}\n\n\tstruct mako_output *output;\n\twl_list_for_each(output, &surface->state->outputs, link) {\n\t\tif (output->name != NULL && strcmp(output->name, output_name) == 0) {\n\t\t\treturn output;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void schedule_frame_and_commit(struct mako_surface *surface);\n\n// Draw and commit a new frame.\nstatic void send_frame(struct mako_surface *surface) {\n\tstruct mako_state *state = surface->state;\n\n\tif (wl_list_empty(&state->outputs)) {\n\t\tsurface->dirty = false;\n\t\treturn;\n\t}\n\n\tint scale = 1;\n\tif (surface->surface_output != NULL) {\n\t\tscale = surface->surface_output->scale;\n\t}\n\n\tsurface->current_buffer =\n\t\tget_next_buffer(state->shm, surface->buffers,\n\t\tsurface->width * scale, surface->height * scale);\n\tif (surface->current_buffer == NULL) {\n\t\tfprintf(stderr, \"no buffer available\\n\");\n\t\treturn;\n\t}\n\n\tstruct mako_output *output = get_configured_output(surface);\n\tint width = 0, height = 0;\n\trender(surface, surface->current_buffer, scale, &width, &height);\n\n\t// There are two cases where we want to tear down the surface: zero\n\t// notifications (height = 0) or moving between outputs.\n\tif (height == 0 || surface->layer_surface_output != output) {\n\t\tif (surface->layer_surface != NULL) {\n\t\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t\t\tsurface->layer_surface = NULL;\n\t\t}\n\t\tif (surface->surface != NULL) {\n\t\t\twl_surface_destroy(surface->surface);\n\t\t\tsurface->surface = NULL;\n\t\t}\n\t\tsurface->width = surface->height = 0;\n\t\tsurface->surface_output = NULL;\n\t\tsurface->configured = false;\n\t}\n\n\t// If there are no notifications, there's no point in recreating the\n\t// surface right now.\n\tif (height == 0) {\n\t\tsurface->dirty = false;\n\t\treturn;\n\t}\n\n\t// If we've made it here, there is something to draw. If the surface\n\t// doesn't exist (this is the first notification, or we moved to a\n\t// different output), we need to create it.\n\tif (surface->layer_surface == NULL) {\n\t\tstruct wl_output *wl_output = NULL;\n\t\tif (output != NULL) {\n\t\t\twl_output = output->wl_output;\n\t\t}\n\t\tsurface->layer_surface_output = output;\n\n\t\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\t\twl_surface_add_listener(surface->surface, &surface_listener, surface);\n\n\t\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\tstate->layer_shell, surface->surface, wl_output,\n\t\t\tsurface->layer, \"notifications\");\n\t\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t&layer_surface_listener, surface);\n\n\t\t// Because we're creating a new surface, we aren't going to draw\n\t\t// anything into it during this call. We don't know what size the\n\t\t// surface will be until we've asked the compositor for what we want\n\t\t// and it has responded with what it actually gave us. We also know\n\t\t// that the height we would _like_ to draw (greater than zero, or we\n\t\t// would have bailed already) is different from our state->height\n\t\t// (which has to be zero here), so we can fall through to the next\n\t\t// block to let it set the size for us.\n\t}\n\n\tassert(surface->layer_surface);\n\n\t// We now want to resize the surface if it isn't the right size. If the\n\t// surface is brand new, it doesn't even have a size yet. If it already\n\t// exists, we might need to resize if the list of notifications has changed\n\t// since the last time we drew.\n\tif (surface->height != height || surface->width != width) {\n\t\tstruct mako_style *style = &state->config.superstyle;\n\n\t\tzwlr_layer_surface_v1_set_size(surface->layer_surface, width, height);\n\t\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface, surface->anchor);\n\t\tzwlr_layer_surface_v1_set_margin(surface->layer_surface,\n\t\t\tstyle->outer_margin.top, style->outer_margin.right,\n\t\t\tstyle->outer_margin.bottom, style->outer_margin.left);\n\t\twl_surface_commit(surface->surface);\n\n\t\t// Now we're going to bail without drawing anything. This gives the\n\t\t// compositor a chance to create the surface and tell us what size we\n\t\t// were actually granted, which may be smaller than what we asked for\n\t\t// depending on the screen size and layout of other layer surfaces.\n\t\t// This information is provided in layer_surface_handle_configure,\n\t\t// which will then call send_frame again. When that call happens, the\n\t\t// layer surface will exist and the height will hopefully match what\n\t\t// we asked for. That means we won't return here, and will actually\n\t\t// draw into the surface down below.\n\t\t// TODO: If the compositor doesn't send a configure with the size we\n\t\t// requested, we'll enter an infinite loop. We need to keep track of\n\t\t// the fact that a request was sent separately from what height we are.\n\t\treturn;\n\t}\n\n\tassert(surface->configured);\n\n\t// Yay we can finally draw something!\n\tstruct wl_region *input_region = get_input_region(surface);\n\twl_surface_set_input_region(surface->surface, input_region);\n\twl_region_destroy(input_region);\n\n\twl_surface_set_buffer_scale(surface->surface, scale);\n\twl_surface_damage_buffer(surface->surface, 0, 0, INT32_MAX, INT32_MAX);\n\twl_surface_attach(surface->surface, surface->current_buffer->buffer, 0, 0);\n\tsurface->current_buffer->busy = true;\n\n\t// Schedule a frame in case the state becomes dirty again\n\tschedule_frame_and_commit(surface);\n\n\tsurface->dirty = false;\n}\n\nstatic void frame_handle_done(void *data, struct wl_callback *callback,\n\t\tuint32_t time) {\n\tstruct mako_surface *surface = data;\n\n\tif (surface->frame_callback) {\n\t\twl_callback_destroy(surface->frame_callback);\n\t\tsurface->frame_callback = NULL;\n\t}\n\n\t// Only draw again if we need to\n\tif (surface->dirty) {\n\t\tsend_frame(surface);\n\t}\n}\n\nstatic const struct wl_callback_listener frame_listener = {\n\t.done = frame_handle_done,\n};\n\nstatic void schedule_frame_and_commit(struct mako_surface *surface) {\n\tif (surface->frame_callback) {\n\t\treturn;\n\t}\n\tif (surface->surface == NULL) {\n\t\t// We don't yet have a surface, create it immediately\n\t\tsend_frame(surface);\n\t\treturn;\n\t}\n\tsurface->frame_callback = wl_surface_frame(surface->surface);\n\twl_callback_add_listener(surface->frame_callback, &frame_listener, surface);\n\twl_surface_commit(surface->surface);\n}\n\nvoid set_dirty(struct mako_surface *surface) {\n\tif (surface->dirty) {\n\t\treturn;\n\t}\n\tsurface->dirty = true;\n\tschedule_frame_and_commit(surface);\n}\n\nstatic void activation_token_handle_done(void *data,\n\t\tstruct xdg_activation_token_v1 *token, const char *token_str) {\n\tchar **out = data;\n\t*out = strdup(token_str);\n}\n\nstatic const struct xdg_activation_token_v1_listener activation_token_listener = {\n\t.done = activation_token_handle_done,\n};\n\nchar *create_xdg_activation_token(struct mako_surface *surface,\n\t\tstruct mako_seat *seat, uint32_t serial) {\n\tstruct mako_state *state = seat->state;\n\tif (state->xdg_activation == NULL) {\n\t\treturn NULL;\n\t}\n\n\tchar *token_str = NULL;\n\tstruct xdg_activation_token_v1 *token =\n\t\txdg_activation_v1_get_activation_token(state->xdg_activation);\n\txdg_activation_token_v1_add_listener(token, &activation_token_listener,\n\t\t&token_str);\n\txdg_activation_token_v1_set_serial(token, serial, seat->wl_seat);\n\txdg_activation_token_v1_set_surface(token, surface->surface);\n\txdg_activation_token_v1_commit(token);\n\n\twhile (wl_display_dispatch(state->display) >= 0 && token_str == NULL) {\n\t\t// This space is intentionally left blank\n\t}\n\n\txdg_activation_token_v1_destroy(token);\n\n\treturn token_str;\n}\n"
        }
      ]
    }
  ]
}