{
  "metadata": {
    "timestamp": 1736709667301,
    "page": 22,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "seL4/seL4",
      "stars": 4803,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cmake-format.yaml",
          "type": "blob",
          "size": 1.0361328125,
          "content": "#\n# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\nadditional_commands:\n  add_sources:\n    kwargs:\n      ASMFILES: '*'\n      CFILES: '*'\n      DEP: '*'\n      PREFIX: '*'\n  config_option:\n    kwargs:\n      DEFAULT: '*'\n      DEFAULT_DISABLED: '*'\n      DEPENDS: '*'\n  config_string:\n    flags:\n    - UNQUOTE\n    - UNDEF_DISABLED\n    kwargs:\n      DEFAULT: '*'\n      DEPENDS: '*'\n  cppfile:\n    kwargs:\n      EXACT_NAME: '*'\n      EXTRA_DEPS: '*'\n      EXTRA_FLAGS: '*'\n  gen_invocation_header:\n    flags:\n    - ARCH\n    - SEL4ARCH\n    - LIBSEL4\n    kwargs:\n      OUTPUT: '*'\n      XML: '*'\n  register_driver:\n    kwargs:\n      CFILES: '*'\n      PREFIX: '*'\n  declare_default_headers:\n    kwargs:\n        TIMER_FREQUENCY: '*'\n        MAX_IRQ: '*'\n        NUM_PPI: '*'\n        INTERRUPT_CONTROLLER: '*'\n        TIMER: '*'\n        KERNEL_WCET: '*'\n        CLK_MAGIC: '*'\n        CLK_SHIFT: '*'\n        TIMER_PRECISION: '*'\n        TIMER_OVERHEAD_TICKS: '*'\n        SMMU: '*'\n        MAX_SID: '*'\n        MAX_CB: '*'\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3515625,
          "content": "#\n# Copyright 2014, General Dynamics C4 Systems\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\n# generated python bytecode\n*.pyc\n\n# latex generated files\n*.aux\n*.log\n*.out\n*.lof\n*.lot\n*.bbl\n*.blg\n*.toc\n*.mpx\n*.acn\n*.glo\n*.gls\n*.ilg\n*.ist\n\ntools/parsetab.py\nmanual/env.tex\nmanual/manual.pdf\nmanual/stage\nmanual/doxygen-output\nmanual/generated\n\n# Emacs backups\n*~\n"
        },
        {
          "name": ".reuse",
          "type": "tree",
          "content": null
        },
        {
          "name": "CAVEATS.md",
          "type": "blob",
          "size": 10.3046875,
          "content": "<!--\n    Copyright 2014, General Dynamics C4 Systems\n\n    SPDX-License-Identifier: GPL-2.0-only\n-->\n\n# Known caveats in the seL4 API and implementation\n\n## Implementation Correctness\n\nThe following seL4 architectures have platforms with a C-level functional\ncorrectness proof. Proof support for further platforms within these\narchitectures is on the roadmap and expected in 2025.\n\n- AArch32: Armv7-a with and without hypervisor extensions, no SMMU, with\n  fast path\n  - Platforms (non-hyp): `sabre` (no FPU), `imx8mm-evk` (with FPU)\n  - Platforms (hyp, no FPU): `tk1`, `exynos5`\n- AArch64: Armv8-a with hypervisor extensions only, no SMMU, with fast path\n  - Platforms: `tx2`, `zynqmp`, `bcm2711` (rpi4)\n- RISC-V: 64-bit only, no fast path\n  - Platforms: `hifive`\n- x64: without VT-x and VT-d, no fast path\n  - Platforms: `pc99`\n\nThis proof covers the functional behaviour of the C code of the kernel. It does\nnot cover machine code, compiler, linker, boot code, cache or TLB management.\nThe compiler and linker can be removed from this list by additionally running the\nbinary verification tool chain for seL4 for AArch32 or RISC-V.\n\nOverall, the functional correctness proof shows that the seL4 C code implements\nthe formal [abstract API specification][ASpec] of seL4 and is free from standard\nC implementation defects such as buffer overruns or NULL pointer dereferences.\n\nFor AArch32 without hypervisor extensions and without FPU, and for RISC-V, there\nare additional proofs that this specification satisfies the following high-level\nsecurity properties:\n\n- integrity (no write without authority),\n- confidentiality (no read without authority), and\n- intransitive non-interference (isolation, modulo timing channels, between\n  adequately configured user-level components).\n\nThe security property proofs depend on additional assumptions on the correct\nconfiguration of the system. See the [l4v] repository on GitHub for more\ndetails.\n\nSimilar proofs for AArch64 with hypervisor extensions are in progress.\n\nFor AArch32, there additionally exist proofs for correct user-level system\ninitialisation. See the [l4v] repository for details.\n\nNote that seL4 currently performs lazy FPU and VCPU switching, which can\nintroduce information flow timing channels. An API-change proposal ([RFC]) to\nimprove this behaviour is currently in progress.\n\n## Verified Configurations\n\nFor the precise configuration of the verified platforms above, see the\ncorresponding files in the seL4 `configs/` directory.\n\nThe proofs are generally sensitive to changes in configuration parameters, and\nwill break if these are changed. For some parameters, the proofs are explicitly\nset up to be robust, such as the number of domains `NUM_DOMAINS`, and the domain\nschedule. More such parameters are on the roadmap to be added and documented\nhere.\n\nIf in doubt, edit the corresponding `_verified` config files and re-run the\nproofs as specified in the [l4v] repository.\n\n## Real Time\n\nThe default version of seL4 must be configured carefully for use in real-time\nrequirements. It has a small number of potentially long-running kernel\noperations that are not preemptible (e.g., endpoint deletion, certain\nscheduling states, frame and CNode initialisation). These can (and must) be\navoided by careful system configuration if low latency is required.\n\n## MCS\n\nThe MCS configuration of the kernel addresses many of these real-time problems\nand provides principled access control for execution time, but its formal\nverification is currently still in progress. For RISC-V, design-level proofs\nhave completed, and C-level proofs are in progress. Similar proofs for AArch64\nare planned.\n\nThe MCS configuration is supported by the seL4 foundation and should generally\nbe stable, with small API changes to be expected while verification is ongoing\nand the configuration is deployed in more systems. See open [requests for\ncomments][RFC] (RFCs) for MCS for what is currently being discussed.\n\nNote that the kernel worst-case execution time (WCET) configuration values in\nthe kernel platform definitions are defaults only and need to be determined\nbased on the specific use case -- for instance, static systems can be set up to\nhave low latency and WCET, whereas dynamic systems or systems where untrusted\ncode has authority to perform longer-running kernel operations may need higher\nvalues.\n\n## SMP\n\nA symmetric multi-processor (SMP) configuration for seL4 exists and is supported\nby the seL4 Foundation, but currently without formal verification. While\ngenerally stable, there are a small number of known open issues, in particular\nwhen the kernel is compiled with `clang`. We recommend `gcc` for working with\nSMP configurations of seL4.\n\nThe combination of SMP and hypervisor extensions is supported and should be\ngenerally stable, but like the plain SMP configuration it is not formally\nverified.\n\nThe combination of SMP and MCS is supported and is receiving active development,\nbut it is less explored and less tested. It should still be considered\nexperimental. There are no supported Armv7-a boards for SMP+MCS, only Armv8-a,\nRISC-V, and Intel. It is tested with `gcc` on `hifive`, `tqma8xqp1gb`,\n`odroidc4`, `zynqmp`, `tx1`, `tx2`, `pc99-32`, and `pc99-64`.\n\nThe combination of SMP, MCS, and hypervisor extensions is currently supported on\nAArch64 only. It is less tested with lower code coverage; currently with `gcc`\nonly, on `odroidc4`, `tx1`, and `tx2`.\n\nThe combination of SMP and domain scheduler is not supported. The SMP\nconfiguration is not expected to satisfy strong intransitive non-interference\nfor information flow.\n\nSee the [seL4 issue tracker][issues] and the [sel4test issue tracker][sel4test\nissues] for details using the labels `MCS` and `SMP` for finding issues on these\nconfigurations.\n\nAs these are unverified configurations, standard C implementation defects are\npossible and not excluded as in verified seL4 configurations.\n\nAn intermediate step towards higher assurance for seL4-based multicore systems\nis a static multi-kernel configuration of seL4. Formal verification for this\nconfiguration is on the roadmap for the AArch64 architecture, with initial work\nbegun. Even without verification complete, we expect multi-kernel configurations\nto be more robust, because they are simpler and closer to the current sequential\nseL4 proofs.\n\nIn a multi-kernel configuration, each CPU core runs a separate instance of seL4,\nwith each kernel instance getting access to disjoint subsets of memory of the\nmachine. User-level memory can be shared as device-untyped memory, which the\nkernel manages but does not access. These configurations can already be set up\nwithout kernel changes by providing suitable device tree overlays to each kernel\ninstance. Further work is planned to make such configurations easier to use and\nmore robust against unsafe use/configurations, e.g. by managing IRQ controller\naccess for each instance.\n\n## Re-using Address Spaces\n\nBefore a VSpace can be safely reused in a new security context, all frame caps\npreviously installed in it should be deleted. The kernel will not do this\nautomatically for the user.\n\nIf not deleted, old frame capabilities retain some authority in the new security\ncontext: the authority to perform cache maintenance operations and the unmap\noperation for mappings to the same frame at the same virtual address.\n\nCapabilities to mapped frames store the seL4 ASID and virtual address under\nwhich the frame is mapped to be able find the corresponding mapping slot. This\ninformation can become stale when, for instance, the page table object where the\nmapping resides is deleted, and a new page table object is created and used\nthere instead. The kernel guards against obvious mistakes such as attempting an\nunmap operation for a mapping slot that now points to another frame, but cannot\ndistinguish a cap with correct mapping information for the old VSpace from a cap\nwith correct mapping information for the new VSpace.\n\n## Intel VT-d (IOMMU)\n\n### Support\n\nIntel VT-d support in seL4 was tested for the following chipsets:\n\n- Intel Q35 Express\n- Intel 5500\n\nOn other chipsets with Intel VT-d support, seL4 might:\n\n- complain and disable IOMMU support\n- hang during bootstrapping\n- have some weird behaviour during runtime\n\nIn any of these cases, the workaround is to disable VT-d support, either:\n\n- in the BIOS, or\n- by including `disable_iommu` into the MultiBoot (e.g. GRUB) command line\n  as described in the seL4 documentation\n\n### MSI Remapping\n\nThis release does not yet provide support for IOMMU interrupt remapping, which\nmeans devices cannot be securely passed through to untrusted virtual machines,\nbecause they could then be used to trigger [arbitrary MSIs with arbitrary\npayload][MSI remap].\n\nWork on a MSI remapping feature is underway.\n\n## Information flow for x86\n\nWhile no configuration in this release of seL4 provides timing or other\nmicro-architectural channel guarantees, timing channel exploits on the x86\narchitecture are more widespread and relevant, especially for dynamic systems.\n\nThe kernel does provide configuration options for mitigating [Meltdown] and\n[Spectre]-style attacks, but there are no specific mitigations for more recent\nsuch attacks such as [Zenbleed] and [Inception].\n\nNote that the kernel does not depend on secrets, cryptographic or otherwise, so\nmost kernel targets for such attacks are not present, but timing channel\nexploits *can* enable one user-level thread to extract secrets from another.\n\nFor many constrained systems, e.g. static embedded systems with known code, the\nexisting mitigations may be sufficient. For more dynamic systems they are\nunlikely to be. Further mitigations could be added in the future with dedicated\nfunding.\n\n## Rowhammer\n\nseL4 does not offer specific protection against hardware-based memory attacks\nsuch as Rowhammer, but it does provide primitives for user-level systems to, for\ninstance, only map physical memory in such a way that Rowhammer is ineffective\nat crossing protection boundaries.\n\n[l4v]: https://github.com/seL4/l4v\n[RFC]: https://github.com/seL4/rfcs\n[issues]: https://github.com/seL4/seL4/issues/\n[sel4test issues]: https://github.com/seL4/sel4test/issues/\n[ASpec]: https://github.com/seL4/l4v/blob/master/spec/abstract\n\n[Meltdown]: https://meltdownattack.com\n[Spectre]: https://meltdownattack.com\n[Zenbleed]: https://lock.cmpxchg8b.com/zenbleed.html\n[Inception]: https://comsec.ethz.ch/research/microarch/inception/\n[MSI remap]: http://theinvisiblethings.blogspot.com/2011/05/following-white-rabbit-software-attacks.html\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 54.6708984375,
          "content": "<!-- SPDX-License-Identifier: CC-BY-SA-4.0 -->\n\n# Revision History for seL4\n\n<!--\n    Document maintainers: Wrap lines in this file at 120 characters.\n\n    Kernel engineers: When making changes to code (rather than documentation or comments) in the kernel repository,\n    include a change item entry here, at the end of the list for the upcoming release, describing the change, and\n    evaluate whether the compatibility breakage level must be promoted as a consequence.  As some rules of thumb:\n    * If the change affects only the sources of the kernel (`src/`, `/include`), it is a BINARY-COMPATIBLE change.\n    * If the change adds visible C preprocessor or language symbols in `libsel4/`, it is a BINARY-COMPATIBLE change.\n    * If the change alters existing symbol definitions, types, or implementations in `libsel4/`, it is a\n      SOURCE-COMPATIBLE change.\n    * Otherwise, it is BREAKING.\n-->\n\nThe following is a high-level description of changes to the seL4 kernel project, grouped by release.  It is aimed at\nengineers who desire a summary of changes in more coarse-grained form than the Git commit history.  Each release\ndescription indicates whether it is SOURCE-COMPATIBLE, BINARY-COMPATIBLE, or BREAKING relative to the previous release.\n\n---\n\n## Upcoming release: BREAKING\n\n### Changes\n\n* Added `zynqmp` and `rpi4` to the set of verified AArch64 configs.\n\n### Platforms\n\n* Removed the default settings `KernelArmVtimerUpdateVOffset` and `KernelArmDisableWFIWFETraps` from the platform\n  `tqma8xqp1gb`, since they are project specific settings, not platform settings. Add\n  `set(KernelArmVtimerUpdateVOffset OFF)` and\n  `set(KernelArmDisableWFIWFETraps ON)`\n  to your project settings to get the same configuration as before if you are using `tqma8xqp1gb`.\n\n### Upgrade Notes\n\n---\n\n## 13.0.0 2024-07-01: BREAKING\n\n### Security-relevant Changes\n\n* Fixed a kernel-crashing NULL pointer dereference when injecting an IRQ for a non-associated VCPU on SMP\n  configurations. This can be triggered from user-level by any thread that has access to or can create non-associated\n  VCPU objects. While HYP+SMP is not a verified configuration and is not thoroughly tested, it is generally assumed to\n  be working. If you are using this configuration, it is strongly recommended to upgrade.\n\n  * Affected configurations: only unverified HYP+SMP configurations on Arm platforms are affected.\n  * Affected versions: seL4 versions 12.0.0 and 12.1.0.\n  * Exploitability: Any thread that can create or that has access to an unassociated VCPU can cause the crash. In static\n    systems, only the system initialiser thread can create VCPUs and the standard capDL system initialiser will not\n    trigger the issue. VMMs could have the authority to dissociate an existing VCPU from a TCB if they have both\n    capabilities. That is, a malicious VMM could cause a crash, but generally VMMs are trusted, albeit not verified\n    code. Guest VMs generally do not have sufficient authority to exploit this vulnerability.\n  * Severity: Critical. This crashes the entire system.\n\n* Fixed a kernel-crashing cache maintenance operation on AArch64 (Armv8). On AArch64, when seL4 runs in EL1 the kernel\n  would fault with a data abort in `seL4_ARM_Page_Invalidate_Data` and `seL4_ARM_VSpace_Invalidate_Data` when the user\n  requested a `dc ivac` cache maintenance operation on a page that is not mapped writeable. If you are using seL4 in EL1\n  on AArch64, it is strongly recommended to upgrade.\n\n  * Affected configurations: unverified AArch64 configurations of seL4 with hypervisor extensions off (kernel runs in\n    EL1). AArch32 configurations and configurations where seL4 runs in EL2 are not affected.\n  * Affected versions: all previous versions since 5.0.0\n  * Exploitability: Any thread that has a VSpace capability or page capability to a page that is not mapped writable can\n    cause the data abort. Most Microkit and CAmkES systems do not give their component access to these capabilities, but any component with Untyped capabilities could create threads with enough capabilities to trigger the issue.\n  * Severity: Critical. This crashes the system.\n\n* Fixed a cache issue on Arm where cleared memory was not flushed to RAM, but only to the point of unification. This\n  means that uncached access was able to still see old memory content.\n\n  * Affected configurations: Arm platforms that distinguish flushing to PoU from flushing to RAM\n  * Affected versions: all previous versions since 4.0.0\n  * Exploitability: Low. The issue is trivially observable by mapping the same frame as cached and uncached.\n    However, it is unlikely to be exploitable in a real system, because re-using memory over security boundaries\n    is already excluded, so information leakage happens only within the same domain.\n  * Severity: Medium. It breaks functional correctness in the sense that a cleared frame may not yet be cleared when\n    viewed as uncached. It does not break any functional kernel behaviour.\n\n### Platforms\n\n* Added support for the ARM Cortex A55\n* Added support for the imx8mp-evk platform\n* Added support for additional RPI4 variants\n* Added support for the Odroid C4\n* Added support for the Avnet MaaXBoard\n* Added support for arm_hyp on qemu-arm-virt platfrom with cortex-a15 CPU\n* Added support for qemu-riscv-virt\n* Added support for the Pine64 Star64\n* Added support for the TQMa8XQP 1GiB module\n* Remove imx31/kzm platform support. This platform is being removed as it is sufficiently old and unused.\n* Remove ARM1136JF_S and ARMv6 support. This architecture version is being removed as it is sufficiently old and\n  unused. See [RFC-8](https://sel4.github.io/rfcs/implemented/0080-remove-armv6-support.html).\n* Remove ARMv6 specific configs: `KernelGlobalsFrame` and `KernelDangerousCodeInjectionOnUndefInstr`. This removes the\n  constant `seL4_GlobalsFrame` from libsel4 as well as the IPC buffer in GlobalsFrame caveat from CAVEATS.md\n* rpi3+rpi4: Mark first memory page as reserved\n\n#### Arm\n\n* Enabled access to `seL4_VCPUReg_VMPIDR` and `seL4_VCPUReg_VMPIDR_EL2` for all hypervisor configurations. Previously\n  this register was only accessible for SMP kernel configurations. Non-SMP configurations can still require access when\n  wanting to control the value of `MPIDR` that the guest reads. Note that the initial value for new seL4_ARM_VCPUs for\n  this register is 0 which isn't a legal value for `MPIDR_EL1` on AArch64. It may be necessary for the register to be\n  explicitly initialized by user level before launching a thread associated with the new seL4_ARM_VCPU.\n* Allow changing the VCPU of active thread: call `vcpu_switch` in `associateVCPUTCB`. This guarantees that the correct\n  VCPU will be activated when the kernel finishes execution. Previously, changing the VCPU of the current thread would\n  result in no VCPU being active.\n* benchmarking: use write-through kernel log buffer\n* arm_hyp: Access `SPSR` via non-banked instructions\n* `generic_timer`: force timer to de-assert IRQ.\n* No special handling for edge-triggered IRQs.\n  -  Clearing the pending state only has an effect if the IRQ state is active-and-pending, which happens for\n    edge-triggered interrupts if another edge happens on the IRQ line for the currently active interrupt. This window is\n    small enough to ignore, at worst user space will get another notification, which is harmless.\n\n    If unnecessary notifications are unwanted, the pending state should be cleared during `seL4_IRQHandler_Ack()`, as\n    that covers a much bigger window. However, edge-triggered interrupts are not expected to happen often. Making all\n    interrupt handling slightly faster and the code simpler is the better trade-off.\n* Make write-only mapping message consistent. There is a warning when creating a write-only mapping on AArch32/AArch64.\n  This message is now the same in all variants.\n\n##### AArch32\n\n* Implement `KernelArmExportPTMRUser` and `KernelArmExportVTMRUser` options for Arm generic timer use access on AArch32.\n* AArch32 VM fault messages now deliver original (untranslated) faulting IP in a hypervisor context, matching\n  AArch64 behaviour.\n* Fix single stepping on ARMv7\n* TLB: only perform TLB lockdown for Cortex A8.\n  - The code previously used the same instructions for Cortex A8 and A9, but the Cortex A8 instructions are undocumented\n    for A9, and A9 provides a slightly different TLB interface. As far as we can tell, the instructions were simply\n    ignored by the supported A8 platforms, so there was no current correctness issue. Since the instructions had no\n    effect, we removed A9 TLB lockdown support. This potential issue was discovered and reported by the UK's National\n    Cyber Security Centre (NCSC).\n* TLB: guard TLB lockdown count.\n  - `lockTLBEntry` uses the global `tlbLockCount` as input without checking bounds. This is fine, because the function\n    is called at most 2 times per core, but this is only apparent when checking the entire possible calling context.\n    Make this bound obvious locally by doing nothing if the function is called with values of `tlbLockCount` of 2 or\n    greater. This is safe, because TLB lockdown is a performance change only. Also add an assert for debug mode, because\n    we want to know if calling context ever changes. This potential issue was reported by The UK's National Cyber\n    Security Centre (NCSC).\n\n##### AArch64\n\n* Add `AARCH64_verified.cmake` config for functional correctness on AArch64\n* Rename libsel4 config option `AARCH64_VSPACE_S2_START_L1` to `CONFIG_AARCH64_VSPACE_S2_START_L1` to be namespace\n  compliant.\n* Added SMC Capability (`smc_cap`) and SMC forwarding for AArch64 platforms. See\n  [RFC-9](https://sel4.github.io/rfcs/implemented/0090-smc-cap.html).\n* Remove VSpace object types in AArch64: `seL4_ARM_PageDirectory` and `seL4_ARM_PageUpperDirectory`. See also the\n  corresponding [RFC](https://sel4.github.io/rfcs/implemented/0100-refactor-aarch64-vspace.html). The functionality\n  previously provided by these types will be provided by the existing `seL4_ARM_PageTable` object type. This allows for\n  a simpler API and enables a smaller kernel implementation that will be easier to verify. libsel4 provides a source\n  compatibility translation that maps the old libsel4 names and constants the new ones in\n  `<sel4/sel4_arch/deprecated.h>`. There are some exceptional cases where kernel behavior has changed:\n  - A Page directory and page table are now the same kind of object and can be mapped at any page table level.\n    If the lookup for the provided address stops at a slot that can map a page directory, it will map the object as a\n    page directory. If there already is a page directory mapped, the lookup will proceed to the next level and it will\n    map as a page table instead of returning an error.\n* Removed user address space reserved slots restriction on 40bit PA platforms when KernelArmHypervisorSupport is set.\n  This change is reflected in the definition of the seL4_UserTop constant that holds the largest user virtual address.\n* Added support for GICv3 virtualization, tested on iMX8QXP\n* Implemented a signal fastpath on AArch64. Must be enabled explicitly with the `KernelSignalFastpath` config option.\n* Implemented a virtual memory fault fastpath on AArch64. Must be enabled explicitly with the `KernelExceptionFastpath` config option.\n* Add option `KernelAArch64UserCacheEnable` for user cache maintenance.\n  - Enables user level access to `DC CVAU`, `DC CIVAC`, `DC CVAC`, and `IC IVAU` which are cache maintenance operations\n    for the data caches and instruction caches underlying Normal memory and also access to the read-only cache-type\n    register `CTR_EL0` that provides cache type information. The ArmV8-A architecture allows access from EL0 as fast\n    cache maintenance operations improves DMA performance in user-level device drivers.\n\n    These instructions are a subset of the available cache maintenance instructions as they can only address lines by\n    virtual address (VA). They also require that the VA provided refers to a valid mapping with at least read\n    permissions. This corresponds to lines that the EL0 could already affect via regular operation and so it's not\n    expected to break any cache-partitioning scheme.\n\n    The config option allows this policy to be selected for a particular kernel configuration, but it is default enabled\n    as this has been the existing behavior for current aarch64,hyp configurations and have not been explicitly disabled\n    in non-hyp configurations.\n* make error reporting consistent: Report the VSpace cap (1) as invalid, instead of the frame cap (0) in\n  `ARMFrameInvocation` to stay consistent with the other architectures.\n* vcpu: only trap WFx instructions from VCPUs. When `KernelArmDisableWFIWFETraps` is disabled (trapping of WFI/WFE is\n  enabled), the kernel traps WFx instructions from both native and vCPU threads. This change brings the code in line\n  with the config description.\n\n#### RISC-V\n\n* Remove the ability for user-space on RISC-V platforms to access the core-local interrupt controller (CLINT). The\n  CLINT contains memory-mapped registers that the kernel depends on for timer interrupts and hence should not be\n  accessible by user-space.\n* Add configuration option `KernelRiscvUseClintMtime` for faster access of hardware timestamp on RISC-V platforms.\n  The configuration option is not enabled by default as it requires access to the CLINT which depends on the platform\n  and whether the M-mode firmware allows S-mode to access the CLINT. For example, newer versions of OpenSBI (1.0 and above)\n  do not allow direct access of the CLINT.\n* Rename object interface files `include/interfaces/sel4.xml`, `arch_include/*/interfaces/sel4arch.xml`, and\n  `sel4_arch_include/*/interfaces/sel4arch.xml` to `include/interfaces/object-api.xml`,\n  `arch_include/*/interfaces/object-api-arch.xml`, and `sel4_arch_include/*/interfaces/object-api-sel4-arch.xml`,\n  respectively.\n* Improve PLIC driver API and documentation\n* Fix `getMaxUsToTicks` function tor return time instead of ticks.\n* Improve RISC-V PTE compliance: keep D, A, and U bits cleared.\n\n#### Intel\n\n* libsel4: add enum for EPT attributes.\n* VTX: fix EPT cache attribute setting. Previously the only effectively possible value was `EPTWriteBack`.\n* Add kernel support for 64-bit VMs\n* Provide `CONFIG_X86_64_VTX_64BIT_GUESTS` for 64-bit VM support\n* Only access real IOAPIC registers. IOAPICS can have varying numbers of lines attached. The actual number can be\n  accessed in the top 16 bits of the version register. Rather than assuming fixed 24 lines per IRQ, read the actual\n  number and use that.\n\n#### MCS\n\n* Rename `seL4_TimeoutMsg` to `seL4_Timeout_Msg` to make it consistent with the naming of other messages.\n* Correct the minimum size of a scheduling context. This changes the value of `seL4_MinSchedContextBits`.\n* Correct check for message length in `SchedControl_ConfigureFlags`\n* Allow lazy SchedContext rebind. Before, binding a scheduling context to a TCB was not allowed if the SC was bound to a\n  notification object. Also, binding an SC to a notification was not allowed if that scheduling context was already\n  bound to a TCB. Without these restriction it is much easier to move scheduling contexts around: In effect having a SC\n  bound on both the TCB and a notification acts as if the thread is running on a donated SC which will be returned when\n  the tasks calls `Recv`/`Wait`, which is done by `maybeReturnSchedContext()`.\n* Only charge budgets for non-idle thread SCs\n* ARM+MCS: Introduce `TIMER_OVERHEAD_TICKS`. For ARM currently `TIMER_PRECISION` exists, but that is in microseconds and\n  not fine-grained enough. `TIMER_OVERHEAD_TICKS` is needed to make periodic tasks synchronous with the system clock. If\n  this value is non-zero every period will be extended with the overhead of taking an interrupt and reading the system\n  clock. To avoid this drift, the configured value should be set to at least the average overhead.\n* SMP: Do not use cross-node `ksCurTime` assuming they are in sync (which they are not), instead use\n  `NODE_STATE(ksCurTime)`.\n* SMP: Add clock synchronisation test on boot\n* SMP: Fix scheduling context use-after-free\n\n#### Other Changes\n\n* boot: Introduce `seL4_BootInfoFrameSize` and `seL4_BootInfoFrameBits` for user land so there is no longer a need to\n  hard-code a 4 KiByte assumption. Remove `BI_FRAME_SIZE_BITS`.\n* Fix: Don't clobber msgInfo register in `PageGetAddress`, `ASIDControlInvocation`, `ARMCBInvocation`,\n  `A32PageDirectoryGetStatusBits`, `X86PortIn`, `WriteVMCS`, `ReadVMCS`, `ConfigureSingleStepping`, and `GetBreakpoint`.\n* `libsel4`: Make `bootinfo` consistent. Some slot positions in the rootnode would depend on configuration. However that\n  makes it difficult to add new root caps, especially if multiple caps only exist based on configuration. Make all caps\n  always there, but null if not configured.\n* `libsel4`: Eliminate unnamed enums\n* Improved consistency and completeness of user manual\n* Added manual for bitfield generator\n* `bitfield_gen`: allow non-contiguous tag fields. A tagged union can now optionally use multiple fields to indicate the\n  tag. These are called \"sliced\" tags in the code. The tag fields have to be at the same position and width in each\n  block of the tagged unions, and all tag fields have to be within the same word. See the manual for details.\n* Make `CONFIG_PRINTING` and `CONFIG_DEBUG_BUILD` usable independently from each other\n* Overall debug printing improvements\n* Fix invisible chars due to ANSI escape codes. On terminals with black background some debug output was invisible due\n  to black foreground colour. Use bold instead.\n* Rename libsel4 config option `ENABLE_SMP_SUPPORT` to `CONFIG_ENABLE_SMP_SUPPORT` to be namespace compliant.\n* Removed obsolete define `HAVE_AUTOCONF`\n* Remove userError from `seL4_ReplyRecv` path, because it too often incorrectly warns about legitimate operations\n* Update GDB macros\n* Add support for `cmake --install <dir>` for final build and config artefacts\n* `cmake`: support supplying custom device trees overrides\n* `cmake`: provide `gen_config.json` with kernel config settings\n* Provide `platform_gen.json` in addition to `platform_gen.yaml`\n* Allow build with GNU `binutils` >= 2.38\n* Allow compilation with clang 12\n* `cmake`: detect x86 cross-compiler for Arm host (e.g. on Apple M1)\n* Consistently use `/usr/bin/env` for bash/sh invocations\n* Require Python 3 consistently everywhere\n* Improved support for compiling on MacOS\n* General minor build system improvements and clean-up\n* Set up automated tests for CI and GitHub pull requests on seL4\n* Add vulnerability disclosure policy\n\n### Upgrade Notes\n\n* The change in `seL4_MinSchedContextBits` can lead to failure where code previously created\n  scheduling contexts with size `seL4_MinSchedContextBits` and expected more than the 2 minimum\n  refills to be available for that size. Either use a larger size (the previous value 8 of\n  `seL4_MinSchedContextBits`) in retyping, or request fewer refills.\n\n---\n\n## 12.1.0 2021-06-10: SOURCE COMPATIBLE\n\n### Changes\n\n* Moved kernel configuration header to libsel4.\n* Improved benchmarking:\n  - Made the kernel log buffer to be derived from cmake config.\n  - Added x86_64 kernel log buffer.\n  - Implemented RISC-V benchmark timestamping.\n  - Implemented benchmark log buffer for RISC-V.\n* Moved cap functions out of inline to make changing cap bitfields less noisy.\n* Removed weak definition of the __sel4_ipc_buffer variable which was causing large thread local storages to be\n  required.\n* Prepared the bitfield generator for Isabelle 2021.\n* Made a number of improvements to the CMake build scripts.\n* Added pre-processor 'include guards' for auto-generated files.\n* Added missing CONFIG_PLAT_IMX7 pre-processor '#define's.\n* Added `#pragma once` to the autoconf headers.\n* Removed `HAVE_AUTOCONF` guards in `sel4/config.h`.\n* Improved the manual:\n  - Corrected descriptions of CNode addressing.\n  - Documented initial thread's SMMU caps.\n* Improved libsel4:\n  - Removed redundant `HAVE_AUTOCONF` header guards in libsel4.\n  - Added missing `macros.h` #include in libsel4.\n  - Cleaned-up `macros.h` in libsel4.\n  - Added checks to use `_Static_assert()` in libsel4 if it is available.\n  - Unified definitions in `simple_types.h` in libsel4.\n  - Added `printf` format specifier `PRI_sel4_word` for printing word types.\n  - Unified seL4 type definitions.\n* Added specific `printf` formatting for seL4_Word.\n* Changed some variables to use `BOOT_BSS` instead of `BOOT_DATA` to save space in the ELF file.\n* Replaced the `capDL()` function with a generic `debug_capDL` function that is intended to be implemented by all\n  architectures.\n* Reduced `printf`s stack usage.\n* Fixed `ksnprintf()` corner case handling.\n* Fixed NULL `printf` output wrapper handling.\n* Cleaned up the printing API implementation.\n* Changed code to pass buffer to `printf` output channel.\n* Refactored the kernel console handling.\n* Added support for `PRIu64` and `SEL4_PRIu_word` in the kernel.\n* Changed various `printf` conversion specifiers to use `SEL4_PRIx_word` specifiers.\n\n#### MCS\n\n* Fixed a physical counter access issue on MCS on EL2.\n* Added MCS support for the ZynqMP.\n* Changed invokeSchedControl_Configure to always produce a scheduling context that is active and has configured\n  refills.\n* Prevented the binding of scheduling contexts to blocked TCBs.\n* Fixed conversions of ticks to microseconds on aarch64.\n* Added an additional sporadic flag to `seL4_SchedControl_Configure` which allows the option to create a sporadic\n  scheduling context.\n* Added explicit checks to not unblock the current scheduling context.\n* Fixed MCS and aarch64 VCPU interrupt interaction.\n* Renamed MCS kernel configuration option `KernelStaticMaxBudgetUs` to `KernelStaticMaxPeriodUs`.\n* Added check to make sure that the current thread will not yield to multiple threads.\n* Added check to account for an inactive scheduling context at preemption.\n* Deferred charging time budget in a preempted invocation.\n* Added code to update `ksDomainTime` in `updateTimestamp`.\n* Added call to `updateTimestamp` in a preemption point.\n* Added code to clear ksConsume when charging time to a revoked scheduling context.\n* Added code to cancel IPC when finalising reply caps.\n* Fixed a dereference of a scheduling context after it's removed from the associated TCB.\n* Added MCS to the preprocess check.\n\n#### x86\n\n* Removed a redundant de-reference for `seL4_X86DangerousRDMSR` in ia32.\n* Added a config option to set the frequency of the TSC.\n* Optimized the boot image size for x86_64.\n* Removed the PT_PHDR segment from the linker script to work around an issue in a variant of syslinux that treats a\n  PT_PHDR segment as distinct from a PT_LOAD segment.\n\n#### Arm\n\n* FPU ownership is now also given away on thread deletion instead of only on FPU exception.\n* Added basic build support for A35 core.\n* Fixed read/write of the VCPU CPACR register.\n* Fixed invalidation of the VIPI I-cache in hypervisor mode.\n* Removed duplicate interrupts for the zynqmp in its DTS.\n* Updated device definitions for the exynos5.\n* Added Raspberry Pi 4 support.\n* Updated Ethernet interrupts in the ZynqMP.\n* Added i.MX6 Nitrogen6_SoloX support.\n* Fixed CMake configurations for the ZynqMP and the Ultra96.\n* Fixed the platform `#define` for the i.MX6 Nitrogen6_SoloX.\n* Fixed I-cache invalidation on aarch64 SMP.\n* Fixed the usage of KernelPaddrUserTop on Arm platforms.\n* Added support for the i.MX low-power UART.\n* Added an option to ignore SErrors which is enabled on default for the TX2.\n\n#### RISC-V\n\n* Added PLIC driver and updated the DTS for the Ariane.\n* Merged the PLIC drivers for the Ariane and the Hifive.\n* Updated default timer frequency for the Ariane.\n* Map devices with large pages on 32 and 64-bit kernel.\n* Replaced mentions of BBL with OpenSBI.\n* Added definitions of the KernelOpenSBIPlatform variable for RISC-V platforms.\n* Removed instances of passing `extra_caps_t` by value for binary verification purposes.\n* Removed `slot_range_t` for binary verification purposes.\n* Removed `DONT_TRANSLATE` tag on 'read_sip' for binary verification purposes.\n* Added more efficient clz and ctz implementations to substitute the lack of machine instructions to count leading and\n  trailing zeroes.\n* Updated kernel bootstrap message to be the same as the one on Arm.\n* Added some fastpath improvements for RISC-V.\n* Added extra snippets of code to track kernel entries for RISC-V.\n* Added a configuration guard for fastpath on RISC-V.\n* Reorganised `traps.S` so that syscalls and fastpath checks were done after interrupts and exceptions checks to avoid\n  exceptions being interpreted as null-syscalls.\n* Added support for `riscv64-elf-` toolchain.\n* Fixed a register bug in the assembly entry point for SMP with regards to the elfloader passing HART and core IDs.\n\n### Upgrade Notes\n\n* Scheduling contexts can now be configured as constant-bandwidth or sporadic server.\n  - Constant bandwidth observes a continuous constant bandwidth of budget/period.\n  - Sporadic server behaves as described by Sprunt et. al.\n  - In an overcommitted system, sporadic preserves accumulated time.\n* There are new `PRIx` and `SEL4_PRIx` `printf` conversion specifiers that can now be used inside the kernel.\n* x86_64 kernel binaries are now smaller and may be structured differently compared to previous kernel binaries.\n* Kernel entry benchmarking can now be done on RISC-V.\n* AUTOCONF_INCLUDED is no longer defined. The seL4 build system has stopped\n  using autoconf a long time ago and this define has been kept for compatibility\n  since then. It is no longer used anywhere by now, so it can be removed.\n\n---\n\n## 12.0.0 2020-10-30: BREAKING\n\n### Changes\n\n\n* Update licensing to reflect project transfer to seL4 Foundation. SPDX tags are now used to identify the licenses for\n  each file in the project. Generally, kernel-level code is licensed under GPLv2 and user-level code under the 2-clause\n  BSD license.\n* Update contribution guidelines:\n  * the seL4 foundation requires DCO process instead of a CLA\n* Functional correctness verification for the RISC-V 64-bit HiFive Unleashed platform configuration\n  (RISCV64_verified.cmake with no fastpath or FPU enabled)\n* Update caveats file:\n  - The recycle operation has been removed\n  - More detail on what versions are verified\n  - Update comments on real time use of seL4\n* Improve seL4 manual.\n  - Fix aarch64 seL4_ARM_PageDirectory object API docs:\n    seL4_ARM_PageDirectory_Map is passed a vspace cap not an upper page directory cap.\n  - Increase documentation coverage for Arm object invocations\n  - Rework introduction of system calls in Kernel Services and Objects chapter.\n  - Improve discussion of Receive and Wait syscall behaviour between MCS and non-MCS systems.\n  - Explicitly mention grantreply rights in the exceptions section.\n  - Document schedcontext size_bits meaning.\n  - Remove metion of system criticality.\n  - Add SchedContext to object size discussion.\n  - Fix initial thread's CNode guard size.\n  - Update BootInfo struct table.\n  - Update padding field in UntypedDesc table\n* Update seL4_DebugSnapshot to provide a CapDL dump of the capability layout of\n  a running system for Arm, x86_64 and riscv32 configurations.\n* KernelBenchmarksTrackUtilisation:\n  - Add feature support for SMP configurations\n  - For each thread also track number of times scheduled, number of kernel entries and amount of cycles spent inside the\n    kernel and also add core-wide totals for each.\n* Add 2 new benchmark utilization syscalls\n  - seL4_BenchmarkDumpAllThreadsUtilisation: Prints a JSON formatted record of total and per-thread utilisation\n    statistics about the system. This currently includes a thread's total cycles scheduled, total number of times\n    scheduled, total cycles spent in the kernel and total number of times entering the kernel and then totals of each\n    for all threads on the current core.\n  - seL4_BenchmarkResetAllThreadsUtilisation: Resets the current counts of every user thread on the current core.\n* Added seL4_DebugPutString libsel4 function for printing a null-terminated string via calling seL4_DebugPutChar().\n* Introduced a new config flag, KernelInvocationReportErrorIPC, to enable userError format strings to be written to\n  the IPC buffer. Another config bool has been introduced to toggle printing the error out and this can also be set at\n  runtime. LibSel4PrintInvocationErrors is a libsel4 config used to print any kernel error messages reported in the IPC\n  buffer.\n* Repair barriers in clh_lock_acquire (SMP kernel lock). Strengthen the clh_lock_acquire to use release on the\n  atomic_exchange that makes the node public. Otherwise, (on ARM & RISCV) the store to the node value which sets its\n  state to CLHState_Pending can become visible some time after the node is visible. In that window of time, the next\n  thread which attempts to acquire the lock will still see the old state (CLHState_Granted) and enters the critical\n  section, leading to a mutual exclusion violation.\n* Replace all #ifdef header guards with #pragma once directives in libsel4 header files\n* gcc.cmake:\n  - Add option for coloured gcc output. Setting GCC_COLORS in the environment will result in -fdiagnostics-color=always\n    being provided to gcc. Ordinarily gcc would suppress coloured output when ninja redirects its stderr during normal\n    builds.\n  - Remember CROSS_COMPILER_PREFIX across CMake invocations. The variable would become unset in certain contexts.\n  - Add support for Arm cross-compilers on Red Hat distros.\n* Fastpath optimisation:\n  - Reorganise the code layout on Arm.\n  - bitfield_gen: explicit branch predictions.\n  - Optimize instruction cache access for fastpath.\n* Extend Clang support to all kernel configurations. Support targets LLVM versions between 9 and 11.\n* hardware_gen.py: Add elfloader output target for hardware_gen script. This generates header files describing the\n  platform's CPU configuration as well as device information such as compatibility strings and memory regions to the\n  elfloader that are consistent with the kernel's own definitions.\n* Fix bootinfo allocation bug when user image pushed against page directory boundary. The bootinfo is mapped in at the\n  end of the user image in the initial thread's vspace. The kernel initialisation code wasn't calculating the\n  bootinfo size correctly which could lead to a kernel fault when trying to map the bootinfo in when the parent page\n  table object hadn't been allocated.\n* Use autoconf definition for `RetypeMaxObjects` in <sel4/types.h>. This ensures that the definition stays consistent\n  with what the kernel is configured with.\n* Fix up timers and clock frequencies\n  - Remove beaglebone kernel timer prescaling. Previously the timer frequency was incorrectly set to to half (12MHz) its\n    configured frequency (24MHz).\n  - Set TX1 kernel timer frequency config to 12MHz and not 19.2MHz as this is the standard frequency of the input clock\n    source (m_clock).\n  - Set KZM kernel timer frequency config to 35MHz and not 18.6MHz based on sampling the timer frequency.\n  - imx31: add missing dts entry for the epit2 timer.\n  - Set non-mcs i.MX6 kernel timer frequency config to 498MHz and not 400MHz as this is based on the frequency of the\n    input clock source (PLL1)\n  - Zynq7000: Set kernel timer frequency to 320MHz.\n  - Qemu-arm-virt: Set kernel timer frequency to 6.25MHz.\n* Do not generate data symbols for enums in libsel4 as they end up as bss symbols and cause linker errors on newer\n  compiler versions.\n* Update padding field definition in seL4_UntypedDesc to make the struct word aligned. Previously, this struct wasn't\n  correctly word aligned on 64-bit platforms. This change removes the padding1 and padding2 fields and replaces them\n  with a padding field that is a variable number of bytes depending on the platform.\n* Add GitHub actions scripts. These scripts replicate internal CI checks directly on GitHub\n\n#### MCS\n\n* Stop scheduling contexts from being bound to tcb's that already have scheduling contexts.\n* Fix x86 `KERNEL_TIMER_IRQ` definition. Previously, MCS preemption point handling would check the wrong interrupt on\n  x86 platforms.\n* smp: tcb affinity modification bug. When changing the affinity of a thread on a remote core, the reschedule\n  operation wasn't being performed.\n* Allow `replyGrant` for fault handlers. The MCS kernel so far insisted on full grant rights for fault handler caps,\n  but replyGrant is sufficient and consistent with the default kernel config.\n* All scheduling contexts compare their time with time in assigned core instead of currently executing core.\n* Prevent recursion on timeout faults by suspending a passive server that receives a timeout fault.\n* Add KernelStaticMaxBudgetUs to bound the time the user provides to configure scheduling contexts to avoid malicious\n  or erroneous overflows of the scheduling math. Make the default max period/budget 1 hour.\n* rockpro64: enable mcs configurations\n\n#### Arm\n\n* arm: Add seL4_BenchmarkFlushL1Caches syscall to manually flush L1 caches in benchmark configurations.\n* New fault type when running in Arm hypervisor mode: seL4_Fault_VPPIEvent\n  - The kernel can keep track of IRQ state for each VCPU for a reduced set of PPI IRQs and deliver IRQ events as\n    VCPU faults for these interrupt numbers.\n  - Additionally a new VCPU invocation is introduced: seL4_ARM_VCPU_AckVPPI.\n    This is used to acknowledge a virtual PPI that was delivered as a fault.\n* Virtualise Arm Timer and VTimer interrupts to support sharing across VCPUs.\n  - A VCPU will now save and restore VTimer registers for the generic timer and also deliver a VTimer IRQ via a\n    seL4_Fault_VPPIEvent fault. This enables multiple VCPUs bound to the same physical core to share this device.\n* Build config option for whether WFE/WFI traps on VCPUs when running in Arm hypervisor mode\n* Arm: Add VMPIDR and VMPIDR_EL2 registers to VCPU objects for programming a VCPU's 'Virtualization Multiprocessor\n  ID Register' on aarch32 and aarch64.\n* Arm, vcpu, smp: Remote IPI call support for VIRQS. Injecting a VIRQ into a vcpu running on a different core will\n  IPI the remote core to perform the IRQ injection.\n* zynqmp: Disable hardware debug APIs as the platform doesn't support kernel hardware debug API.\n* zynqmp: Add support for aarch32 hyp\n* Gicv3: include cluster id when sending ipis.\n* qemu-arm-virt:\n  - Generate platform dtb based on KernelMaxNumNodes config value.\n  - Reserve the first 512MiB of Ram as device untyped for use in virtualization configurations.\n\n##### Aarch32\n\n* Moved TPIDRURO (PL0 Read-Only Thread ID register) to TCB register context from VCPU registers. This means\n  changes to this register from user level have to go via seL4_TCB_Write Registers instead of seL4_ARM_VCPU_WriteRegs.\n* aarch32: Restrict cache flush operation address range in hyp mode. It's required that cache flushing in hyp mode\n  is performed through the kernel window mapping as the kernel is unable to flush addresses outside of this mapping\n  without causing an access fault.\n* arm_hyp: Move PGD definitions out of libsel4 as they don't correspond to any public interfaces and are only used\n  internally by the kernel to manage its own address space.\n\n##### Aarch64\n\n* aarch64: Fix a bug where saving ELR_EL1 when managing a VCPU object was reading from ELR_EL1 instead of writing to it.\n* aarch64: Fix a bug where saving FAR_EL1 when managing a VCPU object was only writing to the low 32 bits of the 64-bit\n  FAR_EL1 register.\n* aarch64: Add missing faults to seL4_getArchFault. seL4_getArchFault is a libsel4 helper that constructs fault messages\n  out of the IPC buffer message registers but it wasn't aware of all possible fault types.\n* aarch64,vcpu: Add CNTKCTL_EL1 register to `vcpu_t`. This register tracks timer delegation to EL0 from EL1 and\n  needs to be switched for different VCPUs.\n* aarch64: Adds missing vcpu cases for some aarch64-specific functions on capabilities.\n* cortex-a53,hyp: Reduce seL4_UserTop when on a cortex-a53 platform and KernelArmHypervisorSupport is set.\n  - This is because the kernel uses the last slot in the top level VSpace object for storing the assigned VMID and so\n    any addresses that are addressed by the final slot are not accessible. This would apply to any CPU that have 40bit\n    stage 2 translation input address.\n* Arm SMMUv2 kernel API and TX2 smmuv2 driver. This supports using an SMMU to provide address translation and memory\n  protection for device memory access to platforms that implement a compatible Arm SMMUv2 System mmu. The kernel\n  implementation supports using an SMMU to restrict memory access of VM guest pass-through devices, or for isolating\n  devices and their drivers' memory accesses to the rest of a running system.\n\n#### x86\n\n* Fix printf typo in `apic_init`.\n* x86_64: Fix PCID feature constant to use the correct bit.\n* Fix interrupt flag reset upon nested interrupt resume, `c_nested_interrupt`. This fixes an issue where ia32 kernels\n  would crash if receiving a nested interrupt.\n\n#### RISC-V\n\n* Functional correctness of seL4/RISCV now formally verified at the C level.\n* Hifive: Enable seL4_IRQControl_GetTrigger object method. This method allocates an IRQ handler by ID and whether it is\n  level or edge triggered. Note: HiFive PLIC interrupts are all positive-level triggered.\n* Add search for additonal gcc riscv toolchains if the first one cannot be found.\n* Add support for rocketchip soc. Support Rocketchip SoC maps to Xilinx ZC706 board and ZCU102 board\n* Add support for polarfire soc.\n* Clear reservation state on slowpath exit as the RISC-V ISA manual requires supervisor code to execute a dummy sc\n  instruction to clear reservations \"during a preemptive context switch\".\n* Pass DTB through to userlevel in extra bootinfo fields similar to on Arm.\n* Use full width of scause to prevent large exception numbers to be misinterpreted as syscalls.\n* Fix page map bug.\n  - Previously, it was possible in decodeRISCVFrameInvocation for the rwx rights of the new PTE to become 000 after\n    masking with cap rights. This would turn the frame PTE into a page table PTE instead, and allow the user to create\n    almost arbitrary mappings, including to kernel data and code. The defect was discovered in the C verification of the\n    RISC-V port.\n* Remove seL4_UserException_FLAGS. This field was unused and was never set to anything by the kernel.\n* Add FPU config options for RISCV\n  - Two options, KernelRiscvExtD and KernelRiscvExtF, are added to represent the D and F floating-point extensions.\n    KernelHaveFPU is enabled when the floating-point extensions are enabled. The compiler ABI will also be changed to\n    lp64d for hardfloat builds.\n* Add RISCV64_MCS_verified.cmake config for in-progress MCS verification\n* riscv32: Remove incorrectly provided constants for 512MiB 'huge pages' which is not part of the specification.\n* riscv: Lower .boot alignment to 4KiB. This makes the final kernel image more compact.\n\n### Upgrade Notes\n\n* The project's licensing updates don't change the general licensing availability of the sources.\n  More information can be found: <https://github.com/seL4/seL4/blob/master/LICENSE.md>\n* Any references to the padding1 or padding2 fields in seL4_UntypedDesc require updating to\n  the new padding field. It is expected that these fields are unused.\n* Any platforms that have had changed kernel timer frequencies will see different scheduling\n  behavior as kernel timer ticks will occur at different times as kernel ticks are configured\n  in microseconds but then converted to timer ticks via the timer frequency. Any time-sensitive\n  programs may need to be re-calibrated.\n* Any riscv32 programs that were using the constants RISCVGigaPageBits or seL4_HugePageBits will\n  see a compilation error as the constants have been deleted as they aren't supported in the riscv32 spec.\n* Any riscv programs that refer to the seL4_UserException_FLAGS field will need to remove this reference. This field was\n  never initialised by the kernel previously and has now been removed.\n* Any riscv programs using the LR/SC atomics instructions will see reservations invalidated after kernel entries. It is\n  expected that this will not require any changes as reservations becoming invalid is normal behavior.\n* On cortex-a53 platforms when KernelArmHypervisorSupport is set have 1 less GiB of virtual memory addresses available\n  or 2GiB less on TX2 with the SMMU feature enabled. This is captured by the change in definition of the seL4_UserTop\n  constant that holds the larges virtual address accessible by user level.\n* On aarch32 the TPIDRURO register(PL0 Read-Only Thread ID register) has been removed from the VCPU object and added to\n  the TCB object. A VCPU is typically bound to a TCB so after updating the access, a thread with a VCPU attached will\n  still support having a TPIDRURO managed.\n* On Arm hypervisor configurations, PPI virtual timer interrupts are now delivered via seL4_Fault_VPPIEvent faults and\n  it is not possible to allocate an interrupt handler for these interrupts using the normal interrupt APIs. A VPPI\n  interrupt is received via receiving a fault message on a VCPU fault handler, and acknowledged by an invocation on\n  the VCPU object. VPPI interrupts that target a particular VCPU can only be generated while the VCPU thread is\n  executing.\n\n---\n\n## 11.0.0 2019-11-19: BREAKING\n\n### Changes\n\n* Add GrantReply access right for endpoint capabilities.\n  - seL4_Call is permitted on endpoints with either the Grant or the GrantReply access rights.\n  - Capabilities can only be transferred in a reply message if receiver's endpoint capability has the Grant right.\n* `seL4_CapRights_new` now takes 4 parameters\n* seL4_CapRightsBits added to libsel4. seL4_CapRightsBits is the number of bits to encode seL4_CapRights.\n* `seL4_UserTop` added\n  - a new constant in libsel4 that contains the first virtual address unavailable to\n    user level.\n* Add Kernel log buffer to aarch64\n* Support added for Aarch64 hypervisor mode (EL2) for Nvidia TX1 and TX2. This is not verified.\n* Support for generating ARM machine header files (memory regions and interrupts) based on a device tree.\n* Support added for ARM kernel serial driver to be linked in at build time based on the device tree compatibility string.\n* Support added for compiling verified configurations of the kernel with Clang 7.\n* RISC-V: handle all faults\n  - Pass all non-VM faults as user exceptions.\n* arm-hyp: pass ESR in handleUserLevelFault\n* aarch64: return ESR as part of user level fault\n* Created new seL4_nbASIDPoolsBits constant to keep track of max nb of ASID pools.\n* Support added for Hardkernel ODROID-C2.\n* Added extended bootinfo header for device tree (SEL4_BOOTINFO_HEADER_FDT).\n* Support added for passing a device tree from the bootloader to the root task on ARM.\n* Add seL4_VSpaceBits, the size of the top level page table.\n* The root cnode size is now a minimum of 4K.\n* Hifive board support and RISC-V external interrupt support via a PLIC driver.\n* Update seL4_FaultType size to 4bits.\n* Fix seL4_MappingFailedLookupLevel() for EPTs on x86.\n  - add SEL4_MAPING_LOOKUP_NO_[EPTPDPT, EPTPD, EPTPT] which now correspond to\n    the value returned by seL4_MappingFailedLookupLevel on X86 EPT mapping calls.\n* BeagleBone Black renamed from am335x to am335x-boneblack.\n* Supported added for BeagleBone Blue (am335x-boneblue).\n* Remove IPC Buffer register in user space on all platforms\n* Add managed TLS register for all platforms\n* Add configurable system call allowing userspace to set TLS register without capability on all platforms.\n* Non-hyp support added for Arm GICv3 interrupt controller.\n* Add initial support for i.MX8M boards.\n  - Support for i.MX8M Quad evk AArch64 EL2 and EL1, AArch32 smode only is accessible via the imx8mq-evk platform.\n  - Support for i.MX8M Mini evk AArch64 EL2 and EL1, AArch32 smode only is accessible via the imx8mm-evk platform.\n* Add FVP platform with fixed configuration. This currently assumes A57 configuration described in tools/dts/fvp.dts.\n* Arm SMP invocation IRQControl_GetTriggerCore added\n  - Used to route a specify which core an IRQ should be delivered on.\n* Kernel log buffer: Specify on which core an IRQ was delivered.\n* Add new seL4_DebugSendIPI syscall to send arbitrary SGIs on ARM when SMP and DEBUG_BUILD are activated.\n* Support for aarch64-hyp configurations with 40-bit physical addresses (PA) added.\n  - The aarch64 api now refers to VSpaces rather than PageGlobalDirectories,\n    as depending on the PA the top level translation structure can change.\n  - all `seL4_ARM_PageGlobalDirectory` invocations are now `seL4_ARM_VSpace` invocations.\n  - new constants 'seL4_ARM_VSpaceObject` and `seL4_VSpaceIndexBits`.\n* Merged MCS kernel feature.\n  - this is not verified and is under active verification.\n  - The goals of the MCS kernel is to provide strong temporal isolation and a basis for reasoning about time.\n* Moved aarch64 kernel window\n  - aarch64 kernel window is now placed at 0, meaning the kernel can access memory\n    below where the kernel image is mapped.\n* aarch64: Moved TPIDRRO_EL0 (EL0 Read-Only Thread ID register) to TCB register context from VCPU registers. This means\n  changes to this register from user level have to go via seL4_TCB_Write Registers instead of seL4_ARM_VCPU_WriteRegs.\n* Merge ARCH_Page_Remap functionality into ARCH_Page_Map. Remap was used for updating the mapping attributes of a page\n  without changing its virtual address. Now ARCH_Page_Map can be performed on an existing mapping to achieve the same\n  result. The ARCH_Page_Remap invocation has been removed from all configurations.\n* riscv64: Experimental SMP support for RISCV64 on HiFive.\n* Support added for QEMU ARM virt platform, with 3 CPUs: cortex-a15, cortex-a53 and cortex-a57\n  - PLATFORM=qemu-arm-virt\n  - ARM_CPU={cortex-a15, cortex-a53, cortex-a57}\n  - QEMU_MEMORY=1024 (default)\n* Support added for rockpro64.\n* RISCV: Add support for Ariane SoC\n* Unify device untyped initialisation across x86, Arm and RISC-V\n  - Access to the entire physical address range is made available via untypes.\n  - The kernel reserves regions that user level is not able to access and doesn't hand out untypeds for it.\n  - Ram memory is part of this reservation and is instead handed out as regular Untypeds.\n  - Memory reserved for use by the kernel or other reserved regions are not accessible via any untypeds.\n  - Devices used by the kernel are also not accessible via any untypeds.\n\n### Upgrade Notes\n\n* Usages of Endpoints can now use seL4_Call without providing Grant rights by downgrading the Grant to GrantReply\n* The kernel no longer reserves a register for holding the address of a thread's IPC buffer. It is now expected that the\n  location of the IPC buffer is stored in a __thread local variable and a thread register is used to refer to each\n  thread's thread local variables. The sel4runtime is an seL4 runtime that provides program entry points that setup\n  the IPC buffer address and serves as a reference for how the IPC buffer is expected to be accessed.\n* All `seL4_ARM_PageGlobalDirectory` invocations need to be replaced with `seL4_ARM_VSpace`.\n* Usages of ARCH_Page_Remap can be replaced with ARCH_Page_Map and require the original mapping address to be provided.\n* Device untypeds are provided to user level in different sizes which may require more initial processing to break them\n  down for each device they refer to.\n\n---\n\n## 10.1.1 2018-11-12: BINARY COMPATIBLE\n\n### Changes\n\n* Remove theoretical uninitialised variable use in infer_cpu_gic_id for binary translation validation\n\n### Upgrade Notes\n\n* 10.1.0 has a known broken test in the proofs. 10.1.1 fixes this test.\n\n---\n\n## 10.1.0 2018-11-07: SOURCE COMPATIBLE\n\n### Changes\n\n* structures in the boot info are not declared 'packed'\n  - these were previously packed (in the GCC attribute sense)\n  - some field lengths are tweaked to avoid padding\n  - this is a source-compatible change\n* ARM platforms can now set the trigger of an IRQ Handler capability\n  - seL4_IRQControl_GetTrigger allows users to obtain an IRQ Handler capability\n    and set the trigger (edge or level) in the interrupt controller.\n* Initial support for NVIDIA Jetson TX2 (ARMv8a, Cortex A57)\n* AARCH64 support added for raspberry pi 3 platform.\n* Code generation now use jinja2 instead of tempita.\n* AARCH32 HYP support added for running multiple ARM VMs\n* AARCH32 HYP VCPU registers updated.\n* A new invocation for setting TLSBase on all platforms.\n  - seL4_TCB_SetTLSBase\n* Kbuild/Kconfig/Makefile build system removed.\n\n---\n\n## 10.0.0 2018-05-28: BREAKING\n\n* Final version of the kernel  which supports integration with Kbuild based projects\n* Future versions, including this one, provide a CMake based build system\n\nFor more information see <https://docs.sel4.systems/Developing/Building>.\n\n### Changes\n\n* x86 IO ports now have an explicit IOPortControl capability to gate their creation. IOPort capabilities  may now only\n  be created through the IOPortControl capability that is passed to the rootserver. Additionally IOPort capabilities\n  may not be derived to have smaller ranges and the IOPortControl will not issue overlapping IOPorts\n* 32-bit support added for the initial prototype RISC-V architecture port\n\n### Upgrade Notes\n\n* A rootserver must now create IOPort capabilities from the provided IOPortControl capability. As IOPorts can not\n  have their ranges further restricted after creation it must create capabilities with the final desired granularity,\n  remembering that since ranges cannot overlap you cannot issue a larger and smaller range that have any IO ports\n  in common.\n\n---\n\n## 9.0.1 2018-04-18: BINARY COMPATIBLE\n\n### Changes\n\n* On 64-bit architectures, the `label` field of `seL4_MessageInfo` is now 52 bits wide. User-level programs\n  which use any of the following functions may break, if the program relies on these functions to mask the\n  `label` field to the previous width of 20 bits.\n  - `seL4_MessageInfo_new`\n  - `seL4_MessageInfo_get_label`\n  - `seL4_MessageInfo_set_label`\n* Initial prototype RISC-V architecture port. This port currently only supports running in 64-bit mode without FPU or\n  or multicore support on the Spike simulation platform. There is *no verification* for this platform.\n\n---\n\n## 9.0.0 2018-04-11: BREAKING\n\n### Changes\n\n* Debugging option on x86 for syscall interface to read/write MSRs (this is an, equally dangerous, alternative to\n  dangerous code injection)\n* Mitigation for Meltdown (<https://meltdownattack.com>) on x86-64 implemented. Mitigation is via a form of kernel\n  page table isolation through the use of a Static Kernel Image with Microstate (SKIM) window that is used for\n  trapping to and from the kernel address space. This can be enabled/disabled through the build configuration\n  depending on whether you are running on vulnerable hardware or not.\n* Mitigation for Spectre (<https://spectreattack.com>) on x86 against the kernel implemented. Default is software\n  mitigation and is the best performing so users need to do nothing. This does *not* prevent user processes from\n  exploiting each other.\n* x86 configuration option for performing branch prediction barrier on context switch to prevent Spectre style\n  attacks between user processes using the indirect branch predictor\n* x86 configuration option for flushing the RSB on context switch to prevent Spectre style attacks between user\n  processes using the RSB\n* Define extended bootinfo header for the x86 TSC frequency\n* x86 TSC frequency exported in extended bootinfo header\n* `archInfo` is no longer a member of the bootinfo struct. Its only use was for TSC frequency on x86, which\n  can now be retrieved through the extended bootinfo\n* Invocations to set thread priority and maximum control priority (MCP) have changed.\n  - For both invocations, users must now provide a TCB capability `auth`\n  - The requested MCP/priority is checked against the MCP of the `auth` capability.\n  - Previous behavior checked against the invoked TCB, which could be subject to the confused deputy\n   problem.\n* seL4_TCB_Configure no longer takes prio, mcp as an argument. Instead these fields must be set separately\n  with seL4_TCB_SetPriority and seL4_TCB_SetMCPriority.\n* seL4_TCB_SetPriority and seL4_TCB_SetMCPriority now take seL4_Word instead of seL4_Uint8.\n  - seL4_MaxPrio remains at 255.\n* seL4_TCB_SetSchedParams is a new method where MCP and priority can be set in the same sytsem call.\n* Size of the TCB object is increased for some build configurations\n\n### Upgrade notes\n\n* seL4_TCB_Configure calls that set priority should be changed to explicitly call seL4_TCB_SetSchedParams\n  or SetPriority\n* seL4_TCB_Configure calls that set MCP should be changed to explicitly call seL4_TCB_SetSchedParams\n  or seL4_TCB_SetMCPriority\n\n---\n\n## 8.0.0 2018-01-17\n\n### Changes\n\n* Support for additional zynq platform Zynq UltraScale+ MPSoC (Xilinx ZCU102, ARMv8a, Cortex A53)\n* Support for multiboot2 bootloaders on x86 (contributed change from Genode Labs)\n* Deprecate seL4_CapData_t type and functions related to it\n* A fastpath improvement means that when there are two runnable threads and the target thread is the highest priority in\n  the scheduler, the fastpath will be hit. Previously the fastpath would not be used on IPC from a high priority thread\n  to a low priority thread.\n* As a consequence of the above change, scheduling behaviour has changed in the case where a non-blocking IPC is sent\n  between two same priority threads: the sender will be scheduled, rather than the destination.\n* Benchmarking support for armv8/aarch64 is now available.\n* Additional x86 extra bootinfo type for retrieving frame buffer information from multiboot 2\n* Debugging option to export x86 Performance-Monitoring Counters to user level\n\n### Upgrade notes\n\n* seL4_CapData_t should be replaced with just seL4_Word. Construction of badges should just be `x` instead of\n  `seL4_CapData_Badge_new(x)` and guards should be `seL4_CNode_CapData_new(x, y)` instead of\n  `seL4_CapData_Guard_new(x, y)`\n* Code that relied on non-blocking IPC to switch between threads of the same priority may break.\n\n---\n\n## 7.0.0 2017-09-05\n\n### Changes\n\n* Support for building standalone ia32 kernel added\n* ia32: Set sensible defaults for FS and GS selectors\n* aarch64: Use tpidrro_el0 for IPC buffer instead of tpidr_el0\n* More seL4 manual documentation added for aarch64 object invocations\n* Default NUM_DOMAINS set to 16 for x86-64 standalone builds\n* libsel4: Return seL4_Error in invocation stubs in 8fb06eecff9 ''' This is a source code level breaking change '''\n* Add a CMake based build system\n* x86: Increase TCB size for debug builds\n* libsel4: x86: Remove nested struct declarations ''' This is a source code level breaking change '''\n* Bugfix: x86: Unmap pages when delete non final frame caps\n\n### Upgrade notes\n\n* This release is not source compatible with previous releases.\n* seL4 invocations that previously returned long now return seL4_Error which is an enum. Our libraries have already been\n  updated to reflect this change, but in other places where seL4 invocations are used directly, the return types will\n  need to be updated to reflect this change.\n* On x86 some structs in the Bootinfo have been rearranged. This only affects seL4_VBEModeInfoBlock_t which is used if\n  VESA BIOS Extensions (VBE) information is being used.\n\n### Known issues\n\n* One of our tests is non-deterministically becoming unresponsive on the SMP release build on the Sabre IMX.6 platform,\n  which is a non verified configuration of the kernel.  We are working on fixing this problem, and will likely do a\n  point release once it is fixed.\n\n---\nFor previous releases see <https://docs.sel4.systems/releases/sel4>\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 27.30859375,
          "content": "#\n# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\ncmake_minimum_required(VERSION 3.8.2)\ninclude(CheckCCompilerFlag)\n\ninclude(${CMAKE_CURRENT_LIST_DIR}/configs/seL4Config.cmake)\nproject(seL4 C ASM)\n\n# First find our helpers\nfind_file(KERNEL_HELPERS_PATH helpers.cmake PATHS tools CMAKE_FIND_ROOT_PATH_BOTH)\nmark_as_advanced(FORCE KERNEL_HELPERS_PATH)\ninclude(${KERNEL_HELPERS_PATH})\n\nfunction(RequireTool config file)\n    RequireFile(\"${config}\" \"${file}\" PATHS tools)\nendfunction(RequireTool)\n\nRequireTool(KERNEL_FLAGS_PATH flags.cmake)\n\nif(CCACHEFOUND)\n    set(ccache \"ccache\")\nendif()\n\ninclude(tools/internal.cmake)\n\n# Define tools used by the kernel\nset(PYTHON3 \"python3\" CACHE INTERNAL \"\")\nRequireTool(CPP_GEN_PATH cpp_gen.sh)\nRequireTool(CIRCULAR_INCLUDES circular_includes.py)\nRequireTool(CONFIG_GEN_PATH config_gen.py)\nRequireTool(BF_GEN_PATH bitfield_gen.py)\nRequireTool(HARDWARE_GEN_PATH hardware_gen.py)\nRequireTool(INVOCATION_ID_GEN_PATH invocation_header_gen.py)\nRequireTool(INVOCATION_JSON_GEN_PATH invocation_json_gen.py)\nRequireTool(SYSCALL_ID_GEN_PATH syscall_header_gen.py)\nRequireTool(XMLLINT_PATH xmllint.sh)\n\n# Process the configuration scripts\ninclude(config.cmake)\n\n# Define default global flag information so that users can compile with the same\n# basic architecture flags as the kernel\n\nstring(APPEND common_flags \" -D__KERNEL_${KernelWordSize}__\")\n\nif(KernelArchX86)\n    if(${KernelX86MicroArch} STREQUAL \"generic\")\n        string(APPEND common_flags \" -mtune=generic\")\n    else()\n        string(APPEND common_flags \" -march=${KernelX86MicroArch}\")\n    endif()\n\n    if(KernelSel4ArchX86_64)\n        string(APPEND common_exe_flags \" -Wl,-m,elf_x86_64\")\n    elseif(KernelSel4ArchIA32)\n        string(APPEND common_exe_flags \" -Wl,-m,elf_i386\")\n    else()\n        message(FATAL_ERROR \"unknown x86 KernelSel4Arch '${KernelSel4Arch}'\")\n    endif()\n\n    string(APPEND c_common_flags \" -m${KernelWordSize}\")\n\n    if(LLVM_TOOLCHAIN)\n        if(KernelSel4ArchIA32)\n            string(APPEND asm_common_flags \" -m32\")\n        endif()\n    else() # default is GCC toolchain\n        string(APPEND asm_common_flags \" -Wa,--${KernelWordSize}\")\n    endif()\n\nelseif(KernelArchARM)\n    set(arm_march \"${KernelArmArmV}${KernelArmMachFeatureModifiers}\")\n    string(APPEND c_common_flags \" -march=${arm_march}\")\n    string(APPEND asm_common_flags \" -march=${arm_march}\")\n\n    if(KernelSel4ArchAarch64)\n        # nothing special\n    elseif(KernelSel4ArchAarch32)\n        # Explicitly request ARM instead of THUMB for compilation.\n        string(APPEND c_common_flags \" -marm\")\n    else()\n        message(FATAL_ERROR \"unknown ARM KernelSel4Arch '${KernelSel4Arch}'\")\n    endif()\n\nelseif(KernelArchRiscV)\n    # The \"RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA\",\n    # chapter \"ISA Extension Naming Conventions\" describes the march string. Its\n    # form is roughly \"rv(32|64)((im?a?f?d?)|g)q?c?b?...\", where 'g' equals\n    # 'mafd_Zicsr_Zifencei'. Underscores are allowed as extension separator and\n    # even required between for all Z-extensions.\n\n    if(KernelSel4ArchRiscV32)\n        set(_riscv_march \"rv32i\") # Currently we don't support \"rv32e\"\n        set(_riscv_mabi \"ilp32\")\n    elseif(KernelSel4ArchRiscV64)\n        set(_riscv_march \"rv64i\")\n        set(_riscv_mabi \"lp64\")\n    else()\n        message(FATAL_ERROR \"unknown RISC-V KernelSel4Arch '${KernelSel4Arch}'\")\n    endif()\n\n    # Currently there are no KernelRiscvExtM or KernelRiscvExtA, thus the\n    # M-extension and A-extension are always enabled.\n    string(APPEND _riscv_march \"ma\")\n\n    # FPU support. The Q-extension implies the D-extension, which implies the\n    # F-extension, which implies the \"Zicsr\"-extension. Currently there is no\n    # KernelRiscvExtQ yet.\n    if(KernelRiscvExtD)\n        # Since the D-extension implies F-extension, specifying \"d\" would be\n        # sufficient. But it's common practice to say \"fd\"\n        string(APPEND _riscv_march \"fd\")\n        # Pass floating-point values up to 64 bits in F registers\n        string(APPEND _riscv_mabi \"d\")\n    elseif(KernelRiscvExtF)\n        string(APPEND _riscv_march \"f\")\n        # Pass floating-point values up to 32 bits in F registers\n        string(APPEND _riscv_mabi \"f\")\n    endif()\n\n    # Currently there is no KernelRiscvExtC and thus the C-extension is always\n    # enabled\n    string(APPEND _riscv_march \"c\")\n\n    # Determine if GNU toolchain is used and if yes, whether GCC version >= 11.3 (implies binutils version >= 2.38)\n    if(\n        CMAKE_ASM_COMPILER_ID STREQUAL \"GNU\"\n        AND CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL \"11.3\"\n    )\n        # Manually enable Zicsr and Zifencei extensions\n        # This became necessary due to a change in the default ISA version in GNU binutils 2.38 which is the\n        # default binutils version shipped with GCC 11.3\n        string(APPEND _riscv_march \"_zicsr_zifencei\")\n    endif()\n\n    string(APPEND common_flags \" -march=${_riscv_march} -mabi=${_riscv_mabi}\")\n\nelse()\n    message(FATAL_ERROR \"unknown KernelArch '${KernelArch}'\")\nendif()\n\nset(\n    BASE_ASM_FLAGS \"${asm_common_flags} ${common_flags}\"\n    CACHE INTERNAL \"Default ASM flags for compilation \\\n    (subset of flags used by the kernel build)\"\n)\n\nset(\n    BASE_C_FLAGS \"${c_common_flags} ${common_flags}\"\n    CACHE INTERNAL \"Default C flags for compilation \\\n    (subset of flags used by the kernel)\"\n)\n\nset(\n    BASE_CXX_FLAGS \"${cxx_common_flags} ${c_common_flags} ${common_flags}\"\n    CACHE INTERNAL \"Default CXX flags for compilation\"\n)\n\nset(\n    BASE_EXE_LINKER_FLAGS \"${common_flags} ${common_exe_flags} \"\n    CACHE INTERNAL \"Default flags for linker an elf binary application\"\n)\n\n# Setup kernel specific flags. Initialize all flags them from the same base\n# flags that the users will use. The kernel is a stand-alone application with a\n# custom implementation of the standard libraries.\ninclude(${KERNEL_FLAGS_PATH})\n\nadd_compile_options(\n    -std=c99\n    #-----------------------------------\n    # Configure warnings\n    #-----------------------------------\n    -Wall\n    -Werror\n    -Wstrict-prototypes\n    -Wmissing-prototypes\n    -Wnested-externs\n    -Wmissing-declarations\n    -Wundef\n    -Wpointer-arith\n    -Wno-nonnull\n    #-----------------------------------\n    # Configure compiler settings.\n    #-----------------------------------\n    -nostdinc # Do not use any system include paths, only use those given\n              # explicitly by the \"-I <path>\" parameters.\n    -ffreestanding # implies \"-fno-builtin\". Execution will not start at main().\n                   # No assumptions about the meaning of function names from the\n                   # standard library are made, except for memcpy(), memmove(),\n                   # memset() and memcmp(). __builtin_trap() will call abort().\n    -fno-stack-protector\n    -fno-asynchronous-unwind-tables\n    # GCC < 10 and clang < 11 put uninitialized global variables into a 'COMMON'\n    # section unless '-fno-common' is specified. The linker will put anything\n    # from 'COMMON' as the end of the '.bss' if nothing else is specified in the\n    # linker script. Besides making the variable placement look odd, this also\n    # tends to waste a page because we puts large aligned block at the end.\n    # Eventually, GCC 10 and clang 11 made '-fno-common' the default, see\n    # - https://gcc.gnu.org/gcc-10/changes.html\n    # - https://releases.llvm.org/11.0.0/tools/clang/docs/ReleaseNotes.html\n    -fno-common\n)\n\n# Linker parameters. There are two kinds actually:\n#   - flags processed by GCC when invoking it as linker wrapper\n#   - flags passed by GCC to the actual linker invocation (\"-Wl,<flag>\").\nstring(\n    APPEND CMAKE_EXE_LINKER_FLAGS\n    # KernelCommonFlags adds \"-nostdlib\", it's the GCC linker step counterpart\n    # for \"-ffreestanding\" and makes GCC not use the standard system startup\n    # files or libraries. This also excludes GCC's helper library libgcc. Any\n    # libraries that are to be linked must be specified explicitly. Tests have\n    # shown that this parameter doesn't prevent GCC from adding paths from a\n    # \"-L <path>\" argument to the linker invocation for the standard libs, and\n    # there seems no option that prevents this apart from providing an entirely\n    # different specs file via -specs=<file>. Note that \"-Wl,-nostdlib\" is not\n    # used here, because it is not needed. It makes the linker use library\n    # directories specified on the command line only and ignore any SEARCH_DIR\n    # set in a linker script. We provide our own linker scripts, and these\n    # don't set SEARCH_DIR.\n    \" -static\" # Implies \"-no-pie\" (and overrides \"-pie\"). The ld 2.37 docs say\n               # \"-no-pie\" is a linker option, but passing \"-Wl,-no-pie\" fails.\n    \" -Wl,--build-id=none\" # Ensure reproducible builds\n    \" -Wl,-n\" # Disable page alignment of sections\n)\n\n# Setup kernel specific flags used for both the compilation and linking step\nmacro(KernelCommonFlags)\n    foreach(common_flag IN ITEMS ${ARGV})\n        add_compile_options(${common_flag})\n        string(APPEND CMAKE_EXE_LINKER_FLAGS \" ${common_flag} \")\n    endforeach()\nendmacro(KernelCommonFlags)\n\nKernelCommonFlags(\n    ${KernelOptimisation}\n    # The following options are gcc options, it is unclear if ld options are\n    # generated automatically when gcc wraps the linking step and invokes ld.\n    -nostdlib -fno-pic -fno-pie\n)\n\n# Disable cloned functions. This is needed for binary verification at -O2.\nif(NOT KernelOptimisationCloneFunctions AND (CMAKE_C_COMPILER_ID STREQUAL \"GNU\"))\n    KernelCommonFlags(-fno-partial-inlining -fno-ipa-cp -fno-ipa-sra)\nendif()\n\nif(KernelFWholeProgram)\n    # KernelFWholeProgram is still an experimental feature and disabled by\n    # default. Clarify if the linker step via GCC actually cares about this\n    # parameter. There are also the options -flto and -fuse-linker-plugin that\n    # might be a more modern approach.\n    KernelCommonFlags(-fwhole-program)\nendif()\n\nif(KernelDebugBuild)\n    KernelCommonFlags(-DDEBUG -g -ggdb)\n    # Pretend to CMake that we're a release build with debug info. This is because\n    # we do actually allow CMake to do the final link step, so we'd like it not to\n    # strip our binary\n    set(CMAKE_BUILD_TYPE \"RelWithDebInfo\")\nelse()\n    set(CMAKE_BUILD_TYPE \"Release\")\nendif()\n\nif(KernelArchX86)\n    if(KernelSel4ArchX86_64)\n        KernelCommonFlags(-mcmodel=kernel)\n    elseif(KernelSel4ArchIA32)\n        # nothing special\n    else()\n        message(FATAL_ERROR \"unknown x86 KernelSel4Arch '${KernelSel4Arch}'\")\n    endif()\n    add_compile_options(-mno-mmx -mno-sse -mno-sse2 -mno-3dnow)\n\nelseif(KernelArchARM)\n    if(KernelSel4ArchAarch64)\n        KernelCommonFlags(-mgeneral-regs-only)\n        if(\n            ((CMAKE_C_COMPILER_ID STREQUAL \"GNU\")\n             AND (CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL \"10.0.0\")\n             )\n            OR\n                ((CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n                 AND (CMAKE_C_COMPILER_VERSION VERSION_GREATER_EQUAL \"12.0.0\")\n                 )\n        )\n            add_compile_options(-mno-outline-atomics)\n        endif()\n    elseif(KernelSel4ArchAarch32)\n        KernelCommonFlags(-mfloat-abi=soft)\n    else()\n        message(FATAL_ERROR \"unknown ARM KernelSel4Arch '${KernelSel4Arch}'\")\n    endif()\n\nelseif(KernelArchRiscV)\n    # Group \"small\" data objects together in a small-data section so they can\n    # be referenced using gp-relative addressing.  The exact value of\n    # small-data-limit is not crucial but it should be lowered if .small\n    # exceeds 4KiB.\n    #\n    KernelCommonFlags(-mcmodel=medany -msmall-data-limit=1024)\n\nelse()\n    message(FATAL_ERROR \"unknown KernelArch '${KernelArch}'\")\nendif()\n\n# Sort the C sources to ensure a stable layout of the final C file\nlist(SORT c_sources)\n# Add the domain schedule now that its sorted\nlist(APPEND c_sources \"${KernelDomainSchedule}\")\n\n# Add static header includes\ninclude_directories(\n    \"include\"\n    \"include/${KernelWordSize}\"\n    \"include/arch/${KernelArch}\"\n    \"include/arch/${KernelArch}/arch/${KernelWordSize}\"\n    \"include/plat/${KernelPlatform}\"\n    \"include/plat/${KernelPlatform}/plat/${KernelWordSize}\"\n)\n\nif(KernelArchARM)\n    include_directories(\n        \"include/arch/arm/armv/${KernelArmArmV}\"\n        \"include/arch/arm/armv/${KernelArmArmV}/${KernelWordSize}\"\n    )\nendif()\n\nif(KernelArmMach STREQUAL \"exynos\")\n    include_directories(\"include/plat/exynos_common/\")\nendif()\n\n# Add libsel4 include directories. These are explicitly added instead of calling\n# target_link_libraries(${target} sel4) because we don't want to inherit any\n# other build options from libsel4.\ninclude_directories(\n    \"libsel4/include\"\n    \"libsel4/arch_include/${KernelArch}\"\n    \"libsel4/sel4_arch_include/${KernelSel4Arch}\"\n    \"libsel4/sel4_plat_include/${KernelPlatform}\"\n    \"libsel4/mode_include/${KernelWordSize}\"\n)\n\n#\n# Config generation\n#\n\ninclude_directories($<TARGET_PROPERTY:kernel_Config,INTERFACE_INCLUDE_DIRECTORIES>)\n# The kernel expects to be able to include an 'autoconf.h' file at the moment.\n# So lets generate one for it to use\n# TODO: use the kernel_Config directly\ngenerate_autoconf(kernel_autoconf \"kernel\")\ninclude_directories($<TARGET_PROPERTY:kernel_autoconf,INTERFACE_INCLUDE_DIRECTORIES>)\n\n# Target for the config / autoconf headers. This is what all the other generated headers\n# can depend upon\nadd_custom_target(\n    kernel_config_headers\n    DEPENDS\n        kernel_autoconf_Gen\n        kernel_autoconf\n        kernel_Config\n        kernel_Gen\n)\n\n# Target for all generated headers. We start with just all the config / autoconf headers\nadd_custom_target(kernel_headers DEPENDS kernel_config_headers)\n\n# Build up a list of generated files. needed for dependencies in custom commands\nget_generated_files(gen_files_list kernel_autoconf_Gen)\nget_generated_files(gen_files2 kernel_Gen)\nlist(APPEND gen_files_list \"${gen_files2}\")\n\n#\n# C source generation\n#\n\n# Kernel compiles all C sources as a single C file, this provides\n# rules for doing the concatenation\n\nadd_custom_command(\n    OUTPUT kernel_all.c\n    COMMAND\n        \"${CPP_GEN_PATH}\" ${c_sources} > kernel_all.c\n    DEPENDS \"${CPP_GEN_PATH}\" ${c_sources}\n    COMMENT \"Concatenating C files\"\n    VERBATIM\n)\n\nadd_custom_target(kernel_all_c_wrapper DEPENDS kernel_all.c)\n\n#\n# Header Generation\n#\n\n# Rules for generating invocation and syscall headers\n# Aside from generating file rules for dependencies this section will also produce a target\n# that can be depended upon (along with the desired files themselves) to control parallelism\n\nset(xml_headers \"\")\nset(header_dest \"gen_headers/arch/api/invocation.h\")\ngen_invocation_header(\n    OUTPUT ${header_dest}\n    XML\n        ${CMAKE_CURRENT_SOURCE_DIR}/libsel4/arch_include/${KernelArch}/interfaces/object-api-arch.xml\n    ARCH\n)\nlist(APPEND xml_headers \"${header_dest}\")\nlist(APPEND gen_files_list \"${header_dest}\")\n\nset(header_dest \"gen_headers/arch/api/sel4_invocation.h\")\ngen_invocation_header(\n    OUTPUT \"${header_dest}\"\n    XML\n        \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/sel4_arch_include/${KernelSel4Arch}/interfaces/object-api-sel4-arch.xml\"\n    SEL4ARCH\n)\nlist(APPEND xml_headers \"${header_dest}\")\nlist(APPEND gen_files_list \"${header_dest}\")\n\nset(header_dest \"gen_headers/api/invocation.h\")\ngen_invocation_header(\n    OUTPUT \"${header_dest}\"\n    XML \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/include/interfaces/object-api.xml\"\n)\nlist(APPEND xml_headers \"${header_dest}\")\nlist(APPEND gen_files_list \"${header_dest}\")\n\nget_absolute_source_or_binary(\n    invocations_absolute \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/include/interfaces/object-api.xml\"\n)\nget_absolute_source_or_binary(\n    arch_invocations_absolute\n    \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/arch_include/${KernelArch}/interfaces/object-api-arch.xml\"\n)\nget_absolute_source_or_binary(\n    sel4_arch_invocations_absolute\n    \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/sel4_arch_include/${KernelSel4Arch}/interfaces/object-api-sel4-arch.xml\"\n)\n\nadd_custom_command(\n    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/generated/invocations_all.json\n    COMMAND rm -f ${CMAKE_CURRENT_BINARY_DIR}/generated/invocations_all.json\n    COMMAND\n        \"${PYTHON3}\" \"${INVOCATION_JSON_GEN_PATH}\"\n        --gen_config ${CMAKE_CURRENT_BINARY_DIR}/gen_config/kernel/gen_config.json\n        --invocations \"${invocations_absolute}\"\n        --arch_invocations \"${arch_invocations_absolute}\"\n        --sel4_arch_invocations \"${sel4_arch_invocations_absolute}\"\n        --dest ${CMAKE_CURRENT_BINARY_DIR}/generated/invocations_all.json\n    DEPENDS\n        \"${CMAKE_CURRENT_BINARY_DIR}/gen_config/kernel/gen_config.json\"\n        \"${INVOCATION_JSON_GEN_PATH}\"\n        \"${invocations_absolute}\"\n        \"${arch_invocations_absolute}\"\n        \"${sel4_arch_invocations_absolute}\"\n)\nlist(APPEND gen_files_list \"generated/invocations_all.json\")\n\nset(syscall_xml_base \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/include/api\")\nset(syscall_dest \"gen_headers/arch/api/syscall.h\")\nif(KernelIsMCS)\n    set(mcs --mcs)\nendif()\nadd_custom_command(\n    OUTPUT ${syscall_dest}\n    COMMAND\n        \"${XMLLINT_PATH}\"\n        --noout\n        --schema \"${syscall_xml_base}/syscall.xsd\" \"${syscall_xml_base}/syscall.xml\"\n    COMMAND\n        ${CMAKE_COMMAND} -E remove -f \"${syscall_dest}\"\n    COMMAND\n        ${PYTHON3} \"${SYSCALL_ID_GEN_PATH}\"\n        --xml \"${syscall_xml_base}/syscall.xml\"\n        --kernel_header \"${syscall_dest}\" ${mcs}\n    DEPENDS\n        \"${XMLLINT_PATH}\"\n        \"${SYSCALL_ID_GEN_PATH}\"\n        \"${syscall_xml_base}/syscall.xsd\"\n        \"${syscall_xml_base}/syscall.xml\"\n    COMMENT \"Generate syscall invocations\"\n    VERBATIM\n)\nlist(APPEND xml_headers \"${syscall_dest}\")\nlist(APPEND gen_files_list \"${syscall_dest}\")\n# Construct target for just the xml headers\nadd_custom_target(xml_headers_target DEPENDS ${xml_headers})\n# Add the xml headers to all the kernel headers\nadd_dependencies(kernel_headers xml_headers_target)\ninclude_directories(\"${CMAKE_CURRENT_BINARY_DIR}/gen_headers\")\n\n#\n# Prune list generation\n#\n\n# When generating bitfield files we can pass multiple '--prune' parameters that are source\n# files that get searched for determing which bitfield functions are used. This allows the\n# bitfield generator to only generate functions that are used. Whilst irrelevant for\n# normal compilation, not generating unused functions has significant time savings for the\n# automated verification tools\n\n# To generate a prune file we 'build' the kernel (similar to the kernel_all_pp.c rule\n# below) but strictly WITHOUT the generated header directory where the bitfield generated\n# headers are. This means our preprocessed file will contain all the code used by the\n# normal compilation, just without the bitfield headers (which we generate dummy versions of).\n# If we allowed the bitfield headers to be included then we would have a circular\n# dependency. As a result this rule comes *before* the Bitfield header generation section\n\nset(dummy_headers \"\")\nforeach(bf_dec ${bf_declarations})\n    string(\n        REPLACE\n            \":\"\n            \";\"\n            bf_dec\n            ${bf_dec}\n    )\n    list(GET bf_dec 0 bf_file)\n    list(GET bf_dec 1 bf_gen_dir)\n    get_filename_component(bf_name \"${bf_file}\" NAME)\n    string(\n        REPLACE\n            \".bf\"\n            \"_gen.h\"\n            bf_target\n            \"${bf_name}\"\n    )\n    list(\n        APPEND\n            dummy_headers \"${CMAKE_CURRENT_BINARY_DIR}/generated_prune/${bf_gen_dir}/${bf_target}\"\n    )\nendforeach()\n\nadd_custom_command(\n    OUTPUT ${dummy_headers}\n    COMMAND\n        ${CMAKE_COMMAND} -E touch ${dummy_headers}\n    COMMENT \"Generate dummy headers for prune compilation\"\n)\n\nadd_custom_target(dummy_header_wrapper DEPENDS ${dummy_headers})\n\ncppfile(\n    kernel_all_pp_prune.c kernel_all_pp_prune_wrapper kernel_all.c\n    EXTRA_FLAGS -CC \"-I${CMAKE_CURRENT_BINARY_DIR}/generated_prune\"\n    EXTRA_DEPS\n        kernel_all_c_wrapper\n        dummy_header_wrapper\n        xml_headers_target\n        kernel_config_headers\n        ${gen_files_list}\n)\n\n#\n# Bitfield header generation\n#\n\n# Need to generate a bunch of unique targets, we'll do this with piano numbers\nset(bf_gen_target \"kernel_bf_gen_target_1\")\n\nforeach(bf_dec ${bf_declarations})\n    string(\n        REPLACE\n            \":\"\n            \";\"\n            bf_dec\n            ${bf_dec}\n    )\n    list(GET bf_dec 0 bf_file)\n    list(GET bf_dec 1 bf_gen_dir)\n    get_filename_component(bf_name \"${bf_file}\" NAME)\n    string(\n        REPLACE\n            \".bf\"\n            \"_gen.h\"\n            bf_target\n            \"${bf_name}\"\n    )\n    string(\n        REPLACE\n            \".bf\"\n            \"_defs.thy\"\n            defs_target\n            \"${bf_name}\"\n    )\n    string(\n        REPLACE\n            \".bf\"\n            \"_proofs.thy\"\n            proofs_target\n            \"${bf_name}\"\n    )\n    set(pbf_name \"generated/${bf_gen_dir}/${bf_name}.pbf\")\n    set(pbf_target \"${bf_gen_target}_pbf\")\n    cppfile(\n        \"${pbf_name}\" \"${pbf_target}\" \"${bf_file}\"\n        EXTRA_FLAGS -P\n        EXTRA_DEPS kernel_config_headers ${gen_files_list}\n    )\n    GenHBFTarget(\n        \"\"\n        ${bf_gen_target}\n        \"generated/${bf_gen_dir}/${bf_target}\"\n        \"${pbf_name}\"\n        \"${pbf_target}\"\n        \"kernel_all_pp_prune.c\"\n        \"kernel_all_pp_prune_wrapper\"\n        \"${bf_file}\"\n    )\n    GenDefsBFTarget(\n        \"${bf_gen_target}_def\"\n        \"generated/${bf_gen_dir}/${defs_target}\"\n        \"${pbf_name}\"\n        \"${pbf_target}\"\n        \"kernel_all_pp_prune.c\"\n        \"kernel_all_pp_prune_wrapper\"\n    )\n    GenProofsBFTarget(\n        \"${bf_gen_target}_proof\"\n        \"generated/${bf_gen_dir}/${proofs_target}\"\n        \"${pbf_name}\"\n        \"${pbf_target}\"\n        \"kernel_all_pp_prune.c\"\n        \"kernel_all_pp_prune_wrapper\"\n    )\n    list(\n        APPEND\n            theories_deps\n            \"${bf_gen_target}_def\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/generated/${bf_gen_dir}/${defs_target}\"\n            \"${bf_gen_target}_proof\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/generated/${bf_gen_dir}/${proofs_target}\"\n    )\n    add_dependencies(kernel_headers \"${bf_gen_target}\")\n    list(APPEND gen_files_list \"${CMAKE_CURRENT_BINARY_DIR}/generated/${bf_gen_dir}/${bf_target}\")\n    set(bf_gen_target \"${bf_gen_target}1\")\nendforeach()\n# At this point we have generated a bunch of headers into ${CMAKE_CURRENT_BINARY_DIR}/generated\n# but we do not pass this to include_directories, as that will cause it to be an include directory\n# for *all* targets in this file (including ones we defined earlier) and the prune generation\n# *must not* see this files and generate dependencies on them as this will result in nonsense.\n# As such we must manually add this as an include directory to future targets\nset(CPPExtraFlags \"-I${CMAKE_CURRENT_BINARY_DIR}/generated\")\n\n#\n# Kernel compilation\n#\n\ncppfile(\n    kernel_all.i kernel_i_wrapper kernel_all.c\n    EXTRA_DEPS kernel_all_c_wrapper kernel_headers ${gen_files_list}\n    EXTRA_FLAGS\n        -CC \"${CPPExtraFlags}\"\n        # The circular_includes script relies upon parsing out exactly 'kernel_all_copy.c' as\n        # a special case so we must ask cppfile to use this input name\n    EXACT_NAME kernel_all_copy.c\n)\n\n# Explain to cmake that our object file is actually a C input file\nset_property(SOURCE kernel_all.i PROPERTY LANGUAGE C)\n\nif(KernelArchARM)\n    set(linker_source \"src/arch/arm/common_arm.lds\")\nelseif(KernelArchRiscV)\n    set(linker_source \"src/arch/riscv/common_riscv.lds\")\nelse()\n    set(linker_source \"src/plat/${KernelPlatform}/linker.lds\")\nendif()\nset(linker_lds_path \"${CMAKE_CURRENT_BINARY_DIR}/linker.lds_pp\")\n\n# Preprocess the linker script\ncppfile(\n    \"${linker_lds_path}\" linker_ld_wrapper \"${linker_source}\"\n    EXTRA_DEPS kernel_headers ${gen_files_list}\n    EXTRA_FLAGS -CC -P \"${CPPExtraFlags}\"\n)\n\nadd_custom_command(\n    OUTPUT circular_includes_valid\n    COMMAND ${PYTHON3} ${CIRCULAR_INCLUDES} --ignore kernel_all_copy.c < kernel_all.i\n    COMMAND touch circular_includes_valid\n    DEPENDS kernel_i_wrapper kernel_all.i\n)\n\nadd_custom_target(circular_includes DEPENDS circular_includes_valid)\n\nadd_custom_command(\n    OUTPUT kernel_all_pp.c\n    COMMAND\n        ${CMAKE_COMMAND} -E copy kernel_all.i kernel_all_pp.c\n    DEPENDS kernel_i_wrapper kernel_all.i\n)\nadd_custom_target(kernel_all_pp_wrapper DEPENDS kernel_all_pp.c)\n\nadd_custom_target(kernel_theories DEPENDS ${theories_deps})\n\n# Declare final kernel output\nadd_executable(kernel.elf EXCLUDE_FROM_ALL ${asm_sources} kernel_all.c)\ntarget_include_directories(kernel.elf PRIVATE ${config_dir})\ntarget_include_directories(kernel.elf PRIVATE include)\ntarget_include_directories(kernel.elf PRIVATE \"${CMAKE_CURRENT_BINARY_DIR}/generated\")\ntarget_link_libraries(kernel.elf PRIVATE kernel_Config kernel_autoconf)\nset_property(TARGET kernel.elf APPEND_STRING PROPERTY LINK_FLAGS \" -Wl,-T ${linker_lds_path} \")\nset_target_properties(kernel.elf PROPERTIES LINK_DEPENDS \"${linker_lds_path}\")\nadd_dependencies(kernel.elf circular_includes)\n\n# The following commands setup the install target for copying generated files and\n# compilation outputs to an install location: CMAKE_INSTALL_PREFIX.\n# CMAKE_INSTALL_PREFIX can be set on the cmake command line.\n#\n# The current installation outputs are:\n# - ${CMAKE_INSTALL_PREFIX}/bin/kernel.elf: Location of kernel.elf binary\n# - ${CMAKE_INSTALL_PREFIX}/libsel4/include: The include root for libsel4\n# - ${CMAKE_INSTALL_PREFIX}/libsel4/src: The c source files for the libsel4 library\n#\n# The install target is only created if this is the top level project.\n# We don't currently support creating install targets if the kernel is\n# imported in another project.\nif(\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\n    # Import libsel4 to get access to generation targets\n    add_subdirectory(libsel4)\n    # Add a default target that builds kernel.elf and generates all libsel4 headers\n    add_custom_target(single-project ALL DEPENDS sel4_generated kernel.elf)\n    # Disable the libsel4.a target as we don't intend to build the libsel4 sources\n    set_target_properties(sel4 PROPERTIES EXCLUDE_FROM_ALL ON)\n    # Install kernel.elf to bin/kernel.elf\n    install(TARGETS kernel.elf RUNTIME DESTINATION bin)\n    # Install all libsel4 headers to libsel4/include\n    install(\n        DIRECTORY\n            \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/include/\"\n            \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/arch_include/${KernelArch}/\"\n            \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/sel4_arch_include/${KernelSel4Arch}/\"\n            \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/sel4_plat_include/${KernelPlatform}/\"\n            \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/mode_include/${KernelWordSize}/\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/libsel4/include/\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/libsel4/arch_include/${KernelArch}/\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/libsel4/sel4_arch_include/${KernelSel4Arch}/\"\n            # The following directories install the autoconf headers\n            \"${CMAKE_CURRENT_BINARY_DIR}/gen_config/\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/libsel4/gen_config/\"\n            \"${CMAKE_CURRENT_BINARY_DIR}/libsel4/autoconf/\"\n        DESTINATION libsel4/include\n        FILES_MATCHING\n        PATTERN \"*.h\"\n        PATTERN \"*.pbf\"\n        PATTERN \"api/syscall.xml\"\n        PATTERN \"api/syscall.xsd\"\n        PATTERN \"object-api*.xml\"\n        PATTERN \"gen_config.json\"\n    )\n    # Install libsel4 sources to libsel4/src\n    install(DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}/libsel4/src/\" DESTINATION libsel4/src)\n    # Install additional support files\n    if(DEFINED KernelDTBPath)\n        install(FILES ${KernelDTBPath} DESTINATION support)\n    endif()\n    if(DEFINED platform_yaml)\n        install(FILES ${platform_yaml} DESTINATION support)\n    endif()\n    if(DEFINED platform_json)\n        install(FILES ${platform_json} DESTINATION support)\n    endif()\n\nendif()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.322265625,
          "content": "<!--\n     Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n\n     SPDX-License-Identifier: CC-BY-SA-4.0\n-->\n\n# Code of Conduct\n\nThis repository and interactions with it fall under the [seL4 Code of Conduct][1] available from the [seL4 website][2].\n\n[1]: https://docs.sel4.systems/processes/conduct.html\n[2]: https://sel4.systems\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.982421875,
          "content": "<!--\n     Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n\n     SPDX-License-Identifier: CC-BY-SA-4.0\n-->\n\n# Contributions Welcome!\n\nContributions to the seL4 kernel repository are welcome!\n\n## Kernel Development Process\n\nIn addition to our general [contribution guidelines][1], the kernel has additional git history requirements:\n\n* Please try to make sure every commit is in a working state to facilitate bisecting.\n    + unless there is a concrete reason, if so please state that reason in the commit message.\n* Try to keep commits small for ease of reviewing.\n\n[1]: https://docs.sel4.systems/Contributing\n\n## Build/Test\n\nGenerally, any contributions should pass the tests in the project\n<https://github.com/seL4/sel4test>. If new features or platforms are added,\nthey should add corresponding tests in `sel4test`.\n\nContributions to `master` should additionally either be invisible to the proof\nin <https://github.com/seL4/l4v>, such as comments, documentation, style,\nunverified platform, etc, or they should come with proof updates to `l4v`.\n\n## Contact\n\nIf you have larger changes or additions, it is a good idea to get in contact\nwith us as <devel@sel4.systems>, so we can help you get started.\n\nThe people responsible for the technical direction, procedures, and quality\ncontrol are the [Technical Steering Committee][2] (TSC) of the seL4\nfoundation. You can contact them either on the developer mailing list or on\ndirectly via email available from their profile pages.\n\n[2]: https://sel4.systems/Foundation/TSC\n\n## Developer Certificate of Origin (DCO)\n\nThis repository uses the same sign-off process as the Linux kernel. For every\ncommit, use\n\n    git commit -s\n\nto add a sign-off line to your commit message, which will come out as:\n\n    Signed-off-by: name <email>\n\nBy adding this line, you make the declaration that you have the right to make\nthis contribution under the open source license the files use that you changed\nor contributed.\n\nThe full text of the declaration is at <https://developercertificate.org>.\n"
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 3.8125,
          "content": "<!--\n     Copyright 2020 Data61, CSIRO (ABN 41 687 119 230)\n\n     SPDX-License-Identifier: CC-BY-SA-4.0\n-->\n\nContributors\n============\n\nPeople who contributed to the seL4 code, design, or documentation in this\nrepository (in alphabetical order).\n\n* Markku Ahvenjärvi, TII\n* Ali Akguel, NICTA\n* Hesham Almatary, Data61\n* June Andronick, Proofcraft, NICTA & UNSW\n* Ryan Barry, Proofcraft\n* Andy Bui, UNSW\n* Joel Beeren, NICTA\n* Bernard Blackham, NICTA & UNSW\n* Alexander Boettcher, Genode Labs\n* Timothy Bourke, NICTA\n* Andrew Boyton, NICTA & UNSW\n* G. Branden Robinson, Data61\n* Matthew Brassil, NICTA\n* Birgit Brecknell, seL4 Foundation, UNSW\n* Matthew Brecknell, Kry10, Data61\n* Jimmy Brush\n* Mitchell Buckley, Data61\n* Aleksander Budzynowski, NICTA & UNSW\n* Manuel Chakravarty, NICTA & UNSW\n* Xi Ma Chen, NICTA\n* Luca (Wei) Chen, Data61\n* Nahida Chowdhury, NICTA\n* Ahmed Charles\n* Peter Chubb, UNSW, NICTA, Data61\n* Jonas Claeson\n* David Cock, NICTA & UNSW\n* Adrian Danis, NICTA, Data61\n* Matthias Daum, NICTA & UNSW\n* Berkus Decker\n* Philip Derrin, NICTA\n* Kofi Doku Atuah, Data61\n* Dhammika Elkaduwe, NICTA & UNSW\n* Kevin Elphinstone, NICTA & UNSW\n* Alexander Fasching\n* Alison Felizzi, Data61\n* Matthew Fernandez, NICTA & UNSW, Data61\n* Peter Gammie, NICTA\n* Xin Gao, NICTA, Data61\n* Sylvain Gauthier, Data61\n* Alejandro Gomez-Londono, Data61\n* Lukas Graber, Hensoldt Cyber\n* David Greenaway, NICTA & UNSW\n* Matthew Grosvenor, NICTA\n* Karol Gugala, Antmicro\n* Chris Guikema, Dornerworks\n* Lukas Haenel, NICTA\n* Bao Haojun\n* Axel Heider, Codasip, Hensoldt Cyber\n* Gernot Heiser, NICTA & UNSW\n* Christian Helmuth, Genode Labs\n* Florian Hofhammer\n* Sebastian Holzapfel, Data61\n* Yu Hou\n* Peter S. Housel\n* Mark Jenkinson, Cap Gemini\n* Cao Jianlong\n* Alwin Joshy, UNSW\n* Robert Kaiser\n* Benjamin Kalman, NICTA\n* Felix Kam, NICTA\n* Justin King-Lacroix, NICTA\n* Gerwin Klein, Proofcraft, NICTA & UNSW, Data61\n* Rafal Kolanski, Proofcraft, NICTA & UNSW, Data61\n* Nataliya Korovkina\n* Alexander Kroh, NICTA\n* Ramana Kumar, Data61\n* Damon Lee, Kry10, Data61\n* Ben Leslie, Breakaway\n* Corey Lewis, Proofcraft, NICTA, Data61\n* Frank Li, Data61\n* Japheth Lim, NICTA, Data61\n* Chang Liu, Brown University\n* Cindy Liu\n* Jasper Lowell, Data61\n* Anna Lyons, NICTA & UNSW, Data61\n* Hannu Lyytinen, TII\n* Daniel Matichuk, NICTA & UNSW\n* Stephanie McArthur, NICTA\n* Craig McLaughlin, UNSW\n* Kent McLeod, Kry10, Data61\n* Michael McInerney, Proofcraft, UNSW\n* Sam McNally, NICTA\n* Bin Meng\n* Curtis Millar, Data61 & UNSW\n* Jesse Millwood, Dornerworks\n* Bruce Mitchener\n* Mathieu Mirmont\n* Luke Mondy, Data61\n* Toby Murray, NICTA & UNSW\n* Seiya Nuta\n* Tim Newsham\n* Joonas Onatsu, TII\n* Stefan O'Rear\n* Ameya Palande, NICTA\n* Max R.D. Parmer\n* Alex Pavey, Dornerworks\n* Thibaut Pérami, Data61\n* Jorge Pereira, TII\n* Sean Peters, NICTA\n* Victor Phan, Data61\n* Edward Pierzchalski, Data61\n* Matt Rice\n* Corey Richardson, Data61\n* Simon Rodgers, NICTA\n* Juan Pablo Ruiz, TII\n* Viktor Sannum\n* Wink Saville\n* Oliver Scott, Data61\n* Sean Seefried, NICTA\n* Thomas Sewell, NICTA & UNSW, Data61\n* Dan Shea\n* Yanyan Shen, NIO, Cog, Data61\n* Stephen Sherratt, NICTA, Data61\n* Simon Shields, Data61\n* Wojciech Sipak, Antmicro\n* Nick Spinale, Colias Group\n* Nathan Studer, Dornerworks\n* Jack Suann, Data61\n* Etienne Le Sueur, NICTA & UNSW\n* Partha Susarla, Data61\n* Miki Tanaka, Data61\n* Michael von Tessin, NICTA & UNSW\n* Klim Tsoutsman\n* Claudia Tu, UNSW\n* Ivan Velickovic, UNSW\n* Robbie Van Vossen, Dornerworks\n* Bertrand Virfollet\n* Adam Walker, NICTA\n* Jeff Waugh\n* Zhicheng Wei\n* James Wilmot, NICTA\n* Krishnan Winter, UNSW\n* Simon Winwood, NICTA\n* Marcin Witkowski, Antmicro\n* Addo Wondo, Data61\n* Jiawei Xie, NICTA\n* Donny Yang, Data61\n* Ilya Yanok\n* James Ye, Data61\n* Qiao Yongchang\n* Finn Zhang\n* Amirreza Zarrabi, Data61\n* Jingyao Zhou, UNSW, Data61\n* Siwei Zhuang, NICTA, Data61\n* Indan Zupancic, seL4 Foundation, MEP\n"
        },
        {
          "name": "FindseL4.cmake",
          "type": "blob",
          "size": 0.859375,
          "content": "#\n# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\nset(KERNEL_PATH \"${CMAKE_CURRENT_LIST_DIR}\" CACHE STRING \"\")\nset(KERNEL_HELPERS_PATH \"${CMAKE_CURRENT_LIST_DIR}/tools/helpers.cmake\" CACHE STRING \"\")\nset(KERNEL_CONFIG_PATH \"${CMAKE_CURRENT_LIST_DIR}/configs/seL4Config.cmake\" CACHE STRING \"\")\nmark_as_advanced(KERNEL_PATH KERNEL_HELPERS_PATH KERNEL_CONFIG_PATH)\n\nmacro(sel4_import_kernel)\n    add_subdirectory(${KERNEL_PATH} ${CMAKE_BINARY_DIR}/kernel)\nendmacro()\n\nmacro(sel4_import_libsel4)\n    add_subdirectory(\"${KERNEL_PATH}/libsel4\" ${CMAKE_BINARY_DIR}/libsel4)\nendmacro()\n\nmacro(sel4_configure_platform_settings)\n    include(${KERNEL_CONFIG_PATH})\nendmacro()\n\ninclude(FindPackageHandleStandardArgs)\nFIND_PACKAGE_HANDLE_STANDARD_ARGS(\n    seL4\n    DEFAULT_MSG\n    KERNEL_PATH\n    KERNEL_HELPERS_PATH\n    KERNEL_CONFIG_PATH\n)\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.171875,
          "content": "<!--\n     Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n\n     SPDX-License-Identifier: CC-BY-SA-4.0\n-->\n\n# License\n\nThe files in this repository are released under standard open source\nlicenses, identified by [SPDX license tags][1]. Generally, kernel-level\ncode is licensed under GPLv2 and user-level code under the 2-clause BSD\nlicense. See the individual file headers for details, or use one of the\npublicly available SPDX tools to generate a bill of materials. The\ndirectory `LICENSES` contains the text for all licenses that are\nmentioned by files in this repository.\n\n\n## GPL syscall note\n\nNote that, as in the [Linux syscall note for the GPL][2], the seL4\nkernel GPL license does *not* cover user-level code that uses kernel\nservices by normal system calls - this is merely considered normal use\nof the kernel, and does *not* fall under the heading of \"derived work\".\nSyscall headers are provided under BSD.\n\nFor a longer explanation of how the seL4 license does or does not affect\nyour own code see also [this blog post][3].\n\n[1]: https://spdx.org\n[2]: https://spdx.org/licenses/Linux-syscall-note.html\n[3]: https://microkerneldude.wordpress.com/2019/12/09/what-does-sel4s-license-imply/\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.7705078125,
          "content": "<!--\n     Copyright 2014, General Dynamics C4 Systems\n\n     SPDX-License-Identifier: GPL-2.0-only\n-->\n\nThe seL4 microkernel\n====================\n\n[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/5003/badge)](https://bestpractices.coreinfrastructure.org/projects/5003)\n[![CI](https://github.com/seL4/seL4/actions/workflows/push.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/push.yml)\n[![seL4Test](https://github.com/seL4/seL4/actions/workflows/sel4test-deploy.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/sel4test-deploy.yml)\n[![C Parser](https://github.com/seL4/seL4/actions/workflows/cparser.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/cparser.yml)\n[![Compile](https://github.com/seL4/seL4/actions/workflows/compilation-checks.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/compilation-checks.yml)\n[![Proof Sync](https://github.com/seL4/seL4/actions/workflows/preprocess-deploy.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/preprocess-deploy.yml)\n[![RefMan](https://github.com/seL4/seL4/actions/workflows/manual.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/manual.yml)\n[![XML](https://github.com/seL4/seL4/actions/workflows/xml_lint.yml/badge.svg)](https://github.com/seL4/seL4/actions/workflows/xml_lint.yml)\n\nThis project contains the source code of seL4 microkernel.\n\nFor details about the seL4 microkernel, including details about its formal\ncorrectness proof, please see the [`sel4.systems`][1] website and associated\n[FAQ][2].\n\nDOIs for citing recent releases of this repository:\n\n- [![DOI][4]](https://doi.org/10.5281/zenodo.591727)\n\nWe welcome contributions to seL4. Please see the website for information\non [how to contribute][3].\n\nThis repository is usually not used in isolation, but as part of the build\nsystem in a larger project.\n\n  [1]: http://sel4.systems/\n  [2]: https://docs.sel4.systems/projects/sel4/frequently-asked-questions\n  [3]: https://docs.sel4.systems/processes/contributing.html\n  [4]: https://zenodo.org/badge/DOI/10.5281/zenodo.591727.svg\n  [5]: https://sel4.systems/Info/Docs/seL4-manual-latest.pdf\n  [6]: https://docs.sel4.systems/GettingStarted\n  [7]: https://docs.sel4.systems/releases/sel4\n  [8]: https://docs.sel4.systems/projects/sel4/api-doc.html\n\nseL4 Basics\n---------------\n\n- [Tutorials](https://docs.sel4.systems/Tutorials)\n- [Documentation](https://docs.sel4.systems/projects/sel4/documentation)\n- [seL4 libraries](https://docs.sel4.systems/projects/user_libs)\n- [seL4Test](https://docs.sel4.systems/projects/sel4test/)\n- [Debugging guide](https://docs.sel4.systems/projects/sel4-tutorials/debugging-guide)\n- [Benchmarking guide](https://docs.sel4.systems/projects/sel4-tutorials/benchmarking-guide.html)\n- [Virtualization on seL4](https://docs.sel4.systems/projects/virtualization/)\n- [Host Build Dependencies](https://docs.sel4.systems/projects/buildsystem/host-dependencies.html)\n- [Porting seL4](https://docs.sel4.systems/projects/sel4/porting)\n\nCommunity\n---------\n\n- Forums:\n  - [Discourse](https://sel4.discourse.group/)\n  - [seL4 Announce](https://lists.sel4.systems/postorius/lists/announce.sel4.systems)\n  - [seL4 Devel](https://lists.sel4.systems/postorius/lists/devel.sel4.systems)\n- [Suggested projects](https://docs.sel4.systems/SuggestedProjects)\n- [Community projects](https://docs.sel4.systems/CommunityProjects)\n\nSee the [contact] links on the seL4 website for the full list.\n\n[contact]: https://sel4.systems/contact\n\nReporting security vulnerabilities\n----------------------------------\n\nIf you believe you have found a security vulnerability in seL4 or related\nsoftware, we ask you to follow our [vulnerability disclosure policy][VDP].\n\n[VDP]: https://github.com/seL4/seL4/blob/master/SECURITY.md\n\nManual\n------\n\nA hosted version of the [manual](manual/) for the most recent release can be found [here][5].\n\nA web version of the API can be found [here][8]\n\nRepository Overview\n-------------------\n\n- `include` and `src`: C and ASM source code of seL4\n- `tools`: build tools\n- `libsel4`: C bindings for the seL4 ABI\n- `manual`: LaTeX sources of the seL4 reference manual\n\nBuild Instructions\n------------------\n\nSee the seL4 website for [build instructions][6].\n\nStatus\n------\n\nA list of releases and current project status can be found under [seL4 releases][7].\n\n- [Roadmap](https://docs.sel4.systems/projects/roadmap): new features in development\n- [Hardware Support](https://docs.sel4.systems/Hardware): information about hardware platform ports\n- [Kernel Features](https://docs.sel4.systems/projects/sel4/status): information about available\n  kernel features\n- [Userland Components and\n      Drivers](https://docs.sel4.systems/projects/available-user-components.html): available device\n      drivers and userland components\n\nLicense\n-------\n\nSee the file [LICENSE.md](./LICENSE.md).\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 3.97265625,
          "content": "<!--\n     Copyright 2021, Data61, CSIRO (ABN 41 687 119 230)\n\n     SPDX-License-Identifier: CC-BY-SA-4.0\n-->\n\n# Vulnerability disclosure policy\n\nSecurity is a core value of the seL4 Foundation. If you believe you have\nfound a security vulnerability in seL4, we ask you to work with us to\nresolve it according to principles of responsible disclosure. This\npolicy outlines what we ask of you, and what you can expect of us.\n\n## Scope\n\nThis policy currently applies to the most recent released versions, and\nthe heads of the default branches of the software in the following seL4\nFoundation repositories:\n- https://github.com/seL4/seL4\n- https://github.com/seL4/capdl\n- https://github.com/seL4/camkes-tool\n\nNote that these repositories include various code generation tools, for\nexample the seL4 [bitfield generator], the [capDL-tool] and the\n[camkes-tool]. This policy applies to the code these tools ultimately\ngenerate, but not to the code generators themselves. In other words,\nit's the code that ends up running on seL4-based systems that we care\nabout.\n\n[bitfield generator]: https://github.com/seL4/seL4/blob/master/tools/bitfield_gen.py\n[capDL-tool]: https://github.com/seL4/capdl/tree/master/capDL-tool\n[camkes-tool]: https://github.com/seL4/camkes-tool\n\n## What we ask of you\n\n- Report any vulnerabilities you discover as soon as you can, using the\n  official channel below.\n- Provide enough detail to allow us to understand the vulnerability and\n  its impact.\n- Be patient with us if we have questions.\n- Allow us reasonable time to fix the vulnerability before you disclose\n  it publicly.\n- Be mindful that updating the proofs for a fix might take longer than\n  you imagine.\n- Avoid violating the privacy of others, disrupting the normal operation\n  of our systems, or destroying data.\n\n## What you can expect of us\n\n- We will respond to your report within 14 days, and usually sooner.\n- We will work with you to understand and reproduce the vulnerability\n  you are reporting.\n- We will try to reach agreement on an appropriate timeframe for fixing\n  the vulnerability. We will usually aim for 90 days, but sometimes we\n  will need significantly longer to complete difficult proofs.\n- We will work to fix the vulnerability in a timely manner, and will\n  keep you informed of our progress.\n- When we have developed a fix, we will publicly acknowledge the\n  vulnerability.\n- If you agree, we will publicly acknowledge your role in finding and\n  helping us fix the vulnerability.\n- We will protect your privacy, and will not disclose your personally\n  identifying information to third parties without your explicit\n  permission.\n\nUnfortunately, we are not currently able to offer bug bounties.\n\n## Official channel\n\nPlease send vulnerability reports by email to security@seL4.systems,\noptionally encrypted using our security officer's [OpenPGP key].\n\n[OpenPGP key]: https://seL4.systems/security.asc\n\n## FAQ\n\n### How can formally verified software contain security vulnerabilities?\n\nseL4 supports many configurations, and only some of these are verified.\nFor unverified configurations, we want to know about vulnerabilities, so\nwe can provide the level of support that you would expect from any\nwell-engineered software.\n\nEven verified configurations contain some code that is assumed to do the\nright thing, including boot code, assembly stubs, and cache management.\nIf that code does the wrong thing, there might be a security\nvulnerability in a verified configuration, and we want to know about\nthat.\n\nThe proofs also make a number of assumptions about the way hardware\nworks. If our assumptions are not valid for real hardware, there might\nbe a security vulnerability, and we want to know so we can try to fix\nour assumptions. Some assumptions might not be possible to fix. For\nexample, the assumption that memory is incorruptible may be violated by\nRowhammer, but it is quite fundamental to the proofs.\n\nFor more information about what the proofs mean, see the [seL4 FAQ].\n\n[seL4 FAQ]: https://docs.sel4.systems/projects/sel4/frequently-asked-questions.html\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.009765625,
          "content": "13.0.0-dev"
        },
        {
          "name": "config.cmake",
          "type": "blob",
          "size": 21.5849609375,
          "content": "#\n# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\ncmake_minimum_required(VERSION 3.7.2)\n\nconfig_option(\n    KernelIsMCS KERNEL_MCS \"Use the MCS kernel configuration, which is not verified.\"\n    DEFAULT OFF\n)\n\n# Error for unsupported MCS platforms\nif(KernelIsMCS AND (NOT KernelPlatformSupportsMCS))\n    message(\n        FATAL_ERROR \"KernelIsMCS selected, but platform: ${KernelPlatform} does not support it.\"\n    )\nendif()\n\n# Proof based configuration variables\nset(CSPEC_DIR \".\" CACHE PATH \"\")\nset(SKIP_MODIFIES ON CACHE BOOL \"\")\nset(SORRY_BITFIELD_PROOFS OFF CACHE BOOL \"\")\nfind_file(UMM_TYPES umm_types.txt CMAKE_FIND_ROOT_PATH_BOTH)\nset(force FORCE)\nif(KernelVerificationBuild)\n    set(force CLEAR)\nendif()\nmark_as_advanced(${force} CSPEC_DIR SKIP_MODIFIES SORRY_BITFIELD_PROOFS UMM_TYPES)\n# Use a custom target for collecting information during generation that we need during build\nadd_custom_target(kernel_config_target)\n# Put our common top level types in\nset_property(\n    TARGET kernel_config_target\n    APPEND\n    PROPERTY\n        TOPLEVELTYPES\n        cte_C\n        tcb_C\n        endpoint_C\n        notification_C\n        asid_pool_C\n        pte_C\n        user_data_C\n        user_data_device_C\n)\n\n# These options are now set in seL4Config.cmake\nif(DEFINED CALLED_declare_default_headers)\n    # calculate the irq cnode size based on MAX_NUM_IRQ\n    if(\"${KernelArch}\" STREQUAL \"riscv\")\n        math(EXPR MAX_NUM_IRQ \"${CONFIGURE_MAX_IRQ} + 2\")\n    else()\n        if(\n            DEFINED KernelMaxNumNodes\n            AND CONFIGURE_NUM_PPI GREATER \"0\"\n            AND \"${KernelArch}\" STREQUAL \"arm\"\n        )\n            math(\n                EXPR MAX_NUM_IRQ\n                \"(${KernelMaxNumNodes}-1)*${CONFIGURE_NUM_PPI} + ${CONFIGURE_MAX_IRQ}\"\n            )\n        else()\n            set(MAX_NUM_IRQ \"${CONFIGURE_MAX_IRQ}\")\n        endif()\n    endif()\n    set(BITS \"0\")\n    while(MAX_NUM_IRQ GREATER \"0\")\n        math(EXPR BITS \"${BITS} + 1\")\n        math(EXPR MAX_NUM_IRQ \"${MAX_NUM_IRQ} >> 1\")\n    endwhile()\n    set(CONFIGURE_IRQ_SLOT_BITS \"${BITS}\" CACHE INTERNAL \"\")\n    if(NOT DEFINED CONFIGURE_TIMER_PRECISION)\n        set(CONFIGURE_TIMER_PRECISION \"0\")\n    endif()\n    if(NOT DEFINED CONFIGURE_TIMER_OVERHEAD_TICKS)\n        set(CONFIGURE_TIMER_OVERHEAD_TICKS \"0\")\n    endif()\n    configure_file(\n        src/arch/${KernelArch}/platform_gen.h.in\n        ${CMAKE_CURRENT_BINARY_DIR}/gen_headers/plat/platform_gen.h @ONLY\n    )\n    include_directories(include/plat/default)\nendif()\n\n# Set defaults for common variables\nset(KernelHaveFPU OFF)\nset(KernelSetTLSBaseSelf OFF)\n\ninclude(src/arch/${KernelArch}/config.cmake)\ninclude(include/${KernelWordSize}/mode/config.cmake)\ninclude(src/config.cmake)\n\nset(KernelCustomDTS \"\" CACHE FILEPATH \"Provide a device tree file to use instead of the \\\nKernelPlatform's defaults\")\n\nif(NOT \"${KernelCustomDTS}\" STREQUAL \"\")\n    if(NOT EXISTS ${KernelCustomDTS})\n        message(FATAL_ERROR \"Can't open external dts file '${KernelCustomDTS}'!\")\n    endif()\n    # Override list to hold only custom dts\n    set(KernelDTSList \"${KernelCustomDTS}\")\n    message(STATUS \"Using custom ${KernelCustomDTS} device tree, ignoring default dts and overlays\")\nendif()\n\nif(DEFINED KernelDTSList AND (NOT \"${KernelDTSList}\" STREQUAL \"\"))\n    set(KernelDTSIntermediate \"${CMAKE_CURRENT_BINARY_DIR}/kernel.dts\")\n    set(\n        KernelDTBPath \"${CMAKE_CURRENT_BINARY_DIR}/kernel.dtb\"\n        CACHE INTERNAL \"Location of kernel DTB file\"\n    )\n    set(compatibility_outfile \"${CMAKE_CURRENT_BINARY_DIR}/kernel_compat.txt\")\n    set(device_dest \"${CMAKE_CURRENT_BINARY_DIR}/gen_headers/plat/machine/devices_gen.h\")\n    set(\n        platform_yaml \"${CMAKE_CURRENT_BINARY_DIR}/gen_headers/plat/machine/platform_gen.yaml\"\n        CACHE INTERNAL \"Location of platform YAML description\"\n    )\n    set(\n        platform_json \"${CMAKE_CURRENT_BINARY_DIR}/gen_headers/plat/machine/platform_gen.json\"\n        CACHE INTERNAL \"Location of platform JSON description\"\n    )\n    set(config_file \"${CMAKE_CURRENT_SOURCE_DIR}/tools/hardware.yml\")\n    set(config_schema \"${CMAKE_CURRENT_SOURCE_DIR}/tools/hardware_schema.yml\")\n    set(\n        KernelCustomDTSOverlay \"\"\n        CACHE\n            STRING\n            \"Provide an additional list of overlays to append to the selected KernelPlatform's \\\n        device tree during build time\"\n    )\n    if(NOT \"${KernelCustomDTSOverlay}\" STREQUAL \"\")\n        foreach(dts_entry IN ITEMS ${KernelCustomDTSOverlay})\n            if(NOT EXISTS ${dts_entry})\n                message(FATAL_ERROR \"Can't open external overlay file '${dts_entry}'!\")\n            endif()\n            list(APPEND KernelDTSList \"${dts_entry}\")\n            message(STATUS \"Appending ${dts_entry} overlay\")\n        endforeach()\n    endif()\n\n    find_program(DTC_TOOL dtc)\n    if(\"${DTC_TOOL}\" STREQUAL \"DTC_TOOL-NOTFOUND\")\n        message(FATAL_ERROR \"Cannot find 'dtc' program.\")\n    endif()\n    find_program(STAT_TOOL stat)\n    if(\"${STAT_TOOL}\" STREQUAL \"STAT_TOOL-NOTFOUND\")\n        message(FATAL_ERROR \"Cannot find 'stat' program.\")\n    endif()\n    mark_as_advanced(DTC_TOOL STAT_TOOL)\n    # Generate final DTS based on Linux DTS + seL4 overlay[s]\n    foreach(entry ${KernelDTSList})\n        get_absolute_source_or_binary(dts_tmp ${entry})\n        list(APPEND dts_list \"${dts_tmp}\")\n    endforeach()\n\n    check_outfile_stale(regen ${KernelDTBPath} dts_list ${CMAKE_CURRENT_BINARY_DIR}/dts.cmd)\n    if(regen)\n        file(REMOVE \"${KernelDTSIntermediate}\")\n        foreach(entry ${dts_list})\n            file(READ ${entry} CONTENTS)\n            file(APPEND \"${KernelDTSIntermediate}\" \"${CONTENTS}\")\n        endforeach()\n        # Compile DTS to DTB\n        execute_process(\n            COMMAND\n                ${DTC_TOOL} -q -I dts -O dtb -o ${KernelDTBPath} ${KernelDTSIntermediate}\n            RESULT_VARIABLE error\n        )\n        if(error)\n            message(FATAL_ERROR \"Failed to compile DTS to DTB: ${KernelDTSIntermediate}\")\n        endif()\n        # The macOS and GNU coreutils `stat` utilities have different interfaces.\n        # Check if we're using the macOS version, otherwise assume GNU coreutils.\n        # CMAKE_HOST_APPLE is a built-in CMake variable.\n        if(CMAKE_HOST_APPLE AND \"${STAT_TOOL}\" STREQUAL \"/usr/bin/stat\")\n            set(STAT_ARGS \"-f%z\")\n        else()\n            set(STAT_ARGS \"-c '%s'\")\n        endif()\n        # Track the size of the DTB for downstream tools\n        execute_process(\n            COMMAND ${STAT_TOOL} ${STAT_ARGS} ${KernelDTBPath}\n            OUTPUT_VARIABLE KernelDTBSize\n            OUTPUT_STRIP_TRAILING_WHITESPACE\n            RESULT_VARIABLE error\n        )\n        if(error)\n            message(FATAL_ERROR \"Failed to determine KernelDTBSize: ${KernelDTBPath}\")\n        endif()\n        string(\n            REPLACE\n                \"\\'\"\n                \"\"\n                KernelDTBSize\n                ${KernelDTBSize}\n        )\n        set(KernelDTBSize \"${KernelDTBSize}\" CACHE INTERNAL \"Size of DTB blob, in bytes\")\n    endif()\n\n    set(deps ${KernelDTBPath} ${config_file} ${config_schema} ${HARDWARE_GEN_PATH})\n    check_outfile_stale(regen ${device_dest} deps ${CMAKE_CURRENT_BINARY_DIR}/gen_header.cmd)\n    if(regen)\n        # Generate devices_gen header based on DTB\n        message(STATUS \"${device_dest} is out of date. Regenerating from DTB...\")\n        file(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/gen_headers/plat/machine/\")\n        execute_process(\n            COMMAND\n                ${PYTHON3} \"${HARDWARE_GEN_PATH}\" --dtb \"${KernelDTBPath}\" --compat-strings\n                --compat-strings-out \"${compatibility_outfile}\" --c-header --header-out\n                \"${device_dest}\" --hardware-config \"${config_file}\" --hardware-schema\n                \"${config_schema}\" --yaml --yaml-out \"${platform_yaml}\" --sel4arch\n                \"${KernelSel4Arch}\" --addrspace-max \"${KernelPaddrUserTop}\" --json --json-out\n                \"${platform_json}\"\n            RESULT_VARIABLE error\n        )\n        if(error)\n            message(FATAL_ERROR \"Failed to generate from DTB: ${device_dest}\")\n        endif()\n    endif()\n    file(READ \"${compatibility_outfile}\" compatibility_strings)\n\n    # Mark all file dependencies as CMake rerun dependencies.\n    set(cmake_deps ${deps} ${KernelDTSIntermediate} ${KernelDTSList} ${compatibility_outfile})\n    set_property(\n        DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\"\n        APPEND\n        PROPERTY CMAKE_CONFIGURE_DEPENDS ${cmake_deps}\n    )\n\n    include(src/drivers/config.cmake)\nendif()\n\n# Enshrine common variables in the config\nconfig_set(KernelHaveFPU HAVE_FPU \"${KernelHaveFPU}\")\nconfig_set(KernelPaddrUserTop PADDR_USER_DEVICE_TOP \"${KernelPaddrUserTop}\")\n\n# System parameters\nconfig_string(\n    KernelRootCNodeSizeBits ROOT_CNODE_SIZE_BITS \"Root CNode Size (2^n slots) \\\n    The acceptable range is 8-27 and 7-26, for 32-bit and 64-bit respectively. \\\n    The root CNode needs at least enough space to contain up to BI_CAP_DYN_START.\"\n    DEFAULT 12\n    UNQUOTE\n)\n\nconfig_string(\n    KernelTimerTickMS TIMER_TICK_MS \"Timer tick period in milliseconds\"\n    DEFAULT 2\n    UNQUOTE\n    DEPENDS \"NOT KernelIsMCS\"\n    UNDEF_DISABLED\n)\nconfig_string(\n    KernelTimeSlice TIME_SLICE \"Number of timer ticks until a thread is preempted.\"\n    DEFAULT 5\n    UNQUOTE\n    DEPENDS \"NOT KernelIsMCS\"\n    UNDEF_DISABLED\n)\nconfig_string(\n    KernelBootThreadTimeSlice BOOT_THREAD_TIME_SLICE\n    \"Number of milliseconds until the boot thread is preempted.\"\n    DEFAULT 5\n    UNQUOTE\n    DEPENDS \"KernelIsMCS\"\n    UNDEF_DISABLED\n)\nconfig_string(\n    KernelRetypeFanOutLimit RETYPE_FAN_OUT_LIMIT\n    \"Maximum number of objects that can be created in a single Retype() invocation.\"\n    DEFAULT 256\n    UNQUOTE\n)\nconfig_string(\n    KernelMaxNumWorkUnitsPerPreemption MAX_NUM_WORK_UNITS_PER_PREEMPTION\n    \"Maximum number of work units (delete/revoke iterations) until the kernel checks for\\\n    pending interrupts (and preempts the currently running syscall if interrupts are pending).\"\n    DEFAULT 100\n    UNQUOTE\n)\nconfig_string(\n    KernelResetChunkBits RESET_CHUNK_BITS\n    \"Maximum size in bits of chunks of memory to zero before checking a preemption point.\"\n    DEFAULT 8\n    UNQUOTE\n)\nconfig_string(\n    KernelMaxNumBootinfoUntypedCaps MAX_NUM_BOOTINFO_UNTYPED_CAPS\n    \"Max number of bootinfo untyped caps\"\n    DEFAULT 230\n    UNQUOTE\n)\nconfig_option(KernelFastpath FASTPATH \"Enable IPC fastpath\" DEFAULT ON)\n\nconfig_option(\n    KernelExceptionFastpath EXCEPTION_FASTPATH \"Enable exception fastpath\"\n    DEFAULT OFF\n    DEPENDS \"NOT KernelVerificationBuild; KernelSel4ArchAarch64\"\n)\n\nconfig_string(\n    KernelNumDomains NUM_DOMAINS \"The number of scheduler domains in the system\"\n    DEFAULT 1\n    UNQUOTE\n)\n\nconfig_option(\n    KernelSignalFastpath SIGNAL_FASTPATH \"Enable notification signal fastpath\"\n    DEFAULT OFF\n    DEPENDS \"KernelIsMCS; KernelFastpath; KernelSel4ArchAarch64; NOT KernelVerificationBuild\"\n    DEFAULT_DISABLED OFF\n)\n\nfind_file(\n    KernelDomainSchedule default_domain.c\n    PATHS src/config\n    CMAKE_FIND_ROOT_PATH_BOTH\n    DOC \"A C file providing the symbols ksDomSchedule and ksDomScheduleLength \\\n        to be linked with the kernel as a scheduling configuration.\"\n)\nif(SEL4_CONFIG_DEFAULT_ADVANCED)\n    mark_as_advanced(KernelDomainSchedule)\nendif()\n\nconfig_string(\n    KernelNumPriorities NUM_PRIORITIES \"The number of priority levels per domain. Valid range 1-256\"\n    DEFAULT 256\n    UNQUOTE\n)\n\nconfig_string(\n    KernelMaxNumNodes MAX_NUM_NODES \"Max number of CPU cores to boot\"\n    DEFAULT 1\n    DEPENDS \"${KernelNumDomains} EQUAL 1\"\n    UNQUOTE\n)\n\n# Set CONFIG_ENABLE_SMP_SUPPORT as an alias of CONFIG_MAX_NUM_NODES > 1\nif(KernelMaxNumNodes GREATER 1)\n    config_set(KernelEnableSMPSupport ENABLE_SMP_SUPPORT ON)\nelse()\n    config_set(KernelEnableSMPSupport ENABLE_SMP_SUPPORT OFF)\nendif()\n\nconfig_string(\n    KernelStackBits KERNEL_STACK_BITS\n    \"This describes the log2 size of the kernel stack. Great care should be taken as\\\n    there is no guard below the stack so setting this too small will cause random\\\n    memory corruption\"\n    DEFAULT 12\n    UNQUOTE\n)\n\nconfig_string(\n    KernelFPUMaxRestoresSinceSwitch FPU_MAX_RESTORES_SINCE_SWITCH\n    \"This option is a heuristic to attempt to detect when the FPU is no longer in use,\\\n    allowing the kernel to save the FPU state out so that the FPU does not have to be\\\n    enabled/disabled every thread switch. Every time we restore a thread and there is\\\n    active FPU state, we increment this setting and if it exceeds this threshold we\\\n    switch to the NULL state.\"\n    DEFAULT 64\n    DEPENDS \"KernelHaveFPU\"\n    UNDEF_DISABLED UNQUOTE\n)\n\nconfig_option(\n    KernelVerificationBuild VERIFICATION_BUILD\n    \"When enabled this configuration option prevents the usage of any other options that\\\n    would compromise the verification story of the kernel. Enabling this option does NOT\\\n    imply you are using a verified kernel.\"\n    DEFAULT ON\n)\n\nconfig_option(\n    KernelBinaryVerificationBuild BINARY_VERIFICATION_BUILD\n    \"When enabled, this configuration option restricts the use of other options that would \\\n     interfere with binary verification. For example, it will disable some inter-procedural \\\n     optimisations. Enabling this options does NOT imply that you are using a verified kernel.\"\n    DEFAULT OFF\n    DEPENDS \"KernelVerificationBuild\"\n)\n\nconfig_option(\n    KernelDebugBuild DEBUG_BUILD \"Enable debug facilities (symbols and assertions) in the kernel\"\n    DEFAULT ON\n    DEPENDS \"NOT KernelVerificationBuild\"\n    DEFAULT_DISABLED OFF\n)\n\nconfig_option(\n    HardwareDebugAPI HARDWARE_DEBUG_API\n    \"Builds the kernel with support for a userspace debug API, which can \\\n    allows userspace processes to set breakpoints, watchpoints and to \\\n    single-step through thread execution.\"\n    DEFAULT OFF\n    DEPENDS \"NOT KernelVerificationBuild;NOT KernelHardwareDebugAPIUnsupported\"\n)\nconfig_option(\n    KernelPrinting PRINTING\n    \"Allow the kernel to print out messages to the serial console during bootup and execution.\"\n    DEFAULT \"${KernelDebugBuild}\"\n    DEPENDS \"NOT KernelVerificationBuild\"\n    DEFAULT_DISABLED OFF\n)\n\nconfig_option(\n    KernelInvocationReportErrorIPC KERNEL_INVOCATION_REPORT_ERROR_IPC\n    \"Allows the kernel to write the userError to the IPC buffer\"\n    DEFAULT OFF\n    DEPENDS \"KernelPrinting\"\n    DEFAULT_DISABLED OFF\n)\n\nconfig_choice(\n    KernelBenchmarks\n    KERNEL_BENCHMARK\n    \"Enable benchmarks including logging and tracing info. \\\n    Setting this value > 1 enables a 1MB log buffer and functions for extracting data from it \\\n    at user level. NOTE this is only tested on the sabre and will not work on platforms with < 512mb memory. \\\n    This is not fully implemented for x86. \\\n    none -> No Benchmarking features enabled. \\\n    generic -> Enable global benchmarks config variable with no specific features. \\\n    track_kernel_entries -> Log kernel entries information including timing, number of invocations and arguments for \\\n    system calls, interrupts, user faults and VM faults. \\\n    tracepoints -> Enable manually inserted tracepoints that the kernel will track time consumed between. \\\n    track_utilisation -> Enable the kernel to track each thread's utilisation time.\"\n    \"none;KernelBenchmarksNone;NO_BENCHMARKS\"\n    \"generic;KernelBenchmarksGeneric;BENCHMARK_GENERIC;NOT KernelVerificationBuild\"\n    \"track_kernel_entries;KernelBenchmarksTrackKernelEntries;BENCHMARK_TRACK_KERNEL_ENTRIES;NOT KernelVerificationBuild\"\n    \"tracepoints;KernelBenchmarksTracepoints;BENCHMARK_TRACEPOINTS;NOT KernelVerificationBuild\"\n    \"track_utilisation;KernelBenchmarksTrackUtilisation;BENCHMARK_TRACK_UTILISATION;NOT KernelVerificationBuild\"\n)\nif(NOT (KernelBenchmarks STREQUAL \"none\"))\n    config_set(KernelEnableBenchmarks ENABLE_BENCHMARKS ON)\nelse()\n    config_set(KernelEnableBenchmarks ENABLE_BENCHMARKS OFF)\nendif()\n\n# Reflect the existence of kernel Log buffer\nif(KernelBenchmarksTrackKernelEntries OR KernelBenchmarksTracepoints)\n    config_set(KernelLogBuffer KERNEL_LOG_BUFFER ON)\nelse()\n    config_set(KernelLogBuffer KERNEL_LOG_BUFFER OFF)\nendif()\n\nconfig_string(\n    KernelMaxNumTracePoints MAX_NUM_TRACE_POINTS\n    \"Use TRACE_POINT_START(k) and TRACE_POINT_STOP(k) macros for recording data, \\\n    where k is an integer between 0 and this value - 1. The maximum number of \\\n    different trace point identifiers which can be used.\"\n    DEFAULT 1\n    DEPENDS \"NOT KernelVerificationBuild;KernelBenchmarksTracepoints\" DEFAULT_DISABLED 0\n    UNQUOTE\n)\n\nconfig_option(\n    KernelIRQReporting IRQ_REPORTING\n    \"seL4 does not properly check for and handle spurious interrupts. This can result \\\n    in unnecessary output from the kernel during debug builds. If you are CERTAIN these \\\n    messages are benign then use this config to turn them off.\"\n    DEFAULT ON\n    DEPENDS \"KernelPrinting\"\n    DEFAULT_DISABLED OFF\n)\nconfig_option(\n    KernelColourPrinting COLOUR_PRINTING\n    \"In debug mode, seL4 prints diagnostic messages to its serial output describing, \\\n    e.g., the cause of system call errors. This setting determines whether ANSI escape \\\n    codes are applied to colour code these error messages. You may wish to disable this \\\n    setting if your serial output is redirected to a file or pipe.\"\n    DEFAULT ON\n    DEPENDS \"KernelPrinting\"\n    DEFAULT_DISABLED OFF\n)\nconfig_string(\n    KernelUserStackTraceLength USER_STACK_TRACE_LENGTH\n    \"On a double fault the kernel can try and print out the users stack to aid \\\n    debugging. This option determines how many words of stack should be printed.\"\n    DEFAULT 16\n    DEPENDS \"KernelPrinting\" DEFAULT_DISABLED 0\n    UNQUOTE\n)\n\nconfig_choice(\n    KernelOptimisation\n    KERNEL_OPT_LEVEL\n    \"Select the kernel optimisation level\"\n    \"-O2;KernelOptimisationO2;KERNEL_OPT_LEVEL_O2\"\n    \"-Os;KernelOptimisationOS;KERNEL_OPT_LEVEL_OS\"\n    \"-O0;KernelOptimisationO0;KERNEL_OPT_LEVEL_O0\"\n    \"-O1;KernelOptimisationO1;KERNEL_OPT_LEVEL_O1\"\n    \"-O3;KernelOptimisationO3;KERNEL_OPT_LEVEL_O3\"\n)\n\nconfig_option(\n    KernelOptimisationCloneFunctions KERNEL_OPTIMISATION_CLONE_FUNCTIONS\n    \"If enabled, allow inter-procedural optimisations that can generate cloned or partial \\\n     functions, according to the coarse optimisation setting (KernelOptimisation). \\\n     By default, these optimisations are present at -O2 and higher. \\\n     If disabled, prevent those optimisations, regardless of the coarse optimisation setting. \\\n     The main use of this option is to disable cloned and partial functions when performing \\\n     binary verification at -O2. \\\n     This currently only affects GCC builds.\"\n    DEFAULT ON\n    DEPENDS \"NOT KernelBinaryVerificationBuild\"\n    DEFAULT_DISABLED OFF\n)\n\nconfig_option(\n    KernelFWholeProgram KERNEL_FWHOLE_PROGRAM\n    \"Enable -fwhole-program when linking kernel. This should work modulo gcc bugs, which \\\n    are not uncommon with -fwhole-program. Consider this feature experimental!\"\n    DEFAULT OFF\n    DEPENDS \"NOT KernelBinaryVerificationBuild\"\n)\n\nconfig_option(\n    KernelDangerousCodeInjection DANGEROUS_CODE_INJECTION\n    \"Adds a system call that allows users to specify code to be run in kernel mode. \\\n    Useful for profiling.\"\n    DEFAULT OFF\n    DEPENDS\n        \"NOT KernelARMHypervisorSupport;NOT KernelVerificationBuild;NOT KernelPlatformHikey;NOT KernelSkimWindow\"\n)\n\nconfig_option(\n    KernelDebugDisablePrefetchers DEBUG_DISABLE_PREFETCHERS\n    \"On ia32 platforms, this option disables the L2 hardware prefetcher, the L2 adjacent \\\n    cache line prefetcher, the DCU prefetcher and the DCU IP prefetcher. On the cortex \\\n    a53 this disables the L1 Data prefetcher.\"\n    DEFAULT OFF\n    DEPENDS \"KernelArchX86 OR KernelPlatformHikey\"\n)\n\n# Builds the kernel with support for an invocation to set the TLS_BASE\n# of the currently running thread without a capability.\nconfig_set(KernelSetTLSBaseSelf SET_TLS_BASE_SELF ${KernelSetTLSBaseSelf})\n\nconfig_string(\n    KernelWcetScale KERNEL_WCET_SCALE\n    \"Multiplier to scale kernel WCET estimate by: the kernel WCET estimate  \\\n     is used to ensure a thread has enough budget to get in and out of the  \\\n     kernel. When running in a simulator the WCET estimate, which is tuned  \\\n     for hardware, may not be sufficient. This option provides a hacky knob \\\n     that can be fiddled with when running inside a simulator.\"\n    DEFAULT 1\n    UNQUOTE\n    DEPENDS \"KernelIsMCS\"\n    UNDEF_DISABLED\n)\n\nconfig_string(\n    KernelStaticMaxPeriodUs KERNEL_STATIC_MAX_PERIOD_US\n    \"Specifies a static maximum to which scheduling context can have \\\n    either its period or budget configured.\"\n    DEFAULT 0\n    UNQUOTE\n    DEPENDS \"KernelIsMCS\"\n    UNDEF_DISABLED\n)\n\nconfig_option(\n    KernelClz32 CLZ_32 \"Define a __clzsi2 function to count leading zeros for uint32_t arguments. \\\n                        Only needed on platforms which lack a builtin instruction.\"\n    DEFAULT OFF\n)\n\nconfig_option(\n    KernelClz64 CLZ_64 \"Define a __clzdi2 function to count leading zeros for uint64_t arguments. \\\n                        Only needed on platforms which lack a builtin instruction.\"\n    DEFAULT OFF\n)\n\nconfig_option(\n    KernelCtz32 CTZ_32 \"Define a __ctzsi2 function to count trailing zeros for uint32_t arguments. \\\n                        Only needed on platforms which lack a builtin instruction.\"\n    DEFAULT OFF\n)\n\nconfig_option(\n    KernelCtz64 CTZ_64 \"Define a __ctzdi2 function to count trailing zeros for uint64_t arguments. \\\n                        Only needed on platforms which lack a builtin instruction.\"\n    DEFAULT OFF\n)\n\nconfig_option(\n    KernelClzNoBuiltin CLZ_NO_BUILTIN\n    \"Expose implementations of clzl and clzll to verification by avoiding the use \\\n     of __builtin_clzl and __builtin_clzll.\"\n    DEFAULT OFF\n)\n\nconfig_option(\n    KernelCtzNoBuiltin CTZ_NO_BUILTIN\n    \"Expose implementations of ctzl and ctzll to verification by avoiding the use \\\n     of __builtin_ctzl and __builtin_ctzll.\"\n    DEFAULT OFF\n)\n\nadd_config_library(kernel \"${configure_string}\")\n"
        },
        {
          "name": "configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "gcc.cmake",
          "type": "blob",
          "size": 6.54296875,
          "content": "#\n# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\ncmake_minimum_required(VERSION 3.7.2)\n\nset(CMAKE_SYSTEM_NAME Generic)\n# For a generic system this is unused, so define it to something that will be\n# obvious if someone accidentally uses it\nset(CMAKE_SYSTEM_PROCESSOR seL4CPU)\n\nset(CMAKE_SYSROOT \"${CMAKE_BINARY_DIR}\")\n\n# When this file is passed to configure_file in cmake, these variables get set to\n# the kernel platform configuration.\nset(sel4_arch @KernelSel4Arch@)\nset(arch @KernelArch@)\nset(mode @KernelWordSize@)\nset(cross_prefix @cross_prefix@)\n\n# If this file is used without templating, then cross_prefix will\n# have an invalid value and should only be assigned to CROSS_COMPILER_PREFIX\n# if it has been set to something different.\n# We need to build the test string dynamically otherwise the templating would\n# overwrite it.\nset(cross_prefix_test @cross_prefix)\nstring(APPEND cross_prefix_test @)\nif((NOT \"${cross_prefix}\" STREQUAL \"${cross_prefix_test}\") AND (NOT \"${cross_prefix}\" STREQUAL \"\"))\n    set(CROSS_COMPILER_PREFIX ${cross_prefix})\nendif()\n\n# This function hunts for an extant `gcc` with one of the candidate prefixes\n# specified in `ARGN`, allowing us to try different target triple prefixes for\n# cross-compilers built in various ways.\nfunction(FindPrefixedGCC out_var)\n    set(\"${out_var}\" \"PrefixedGCC-NOTFOUND\")\n    foreach(prefix ${ARGN})\n        set(\"test_var\" \"_GCC_${prefix}\")\n        find_program(\"${test_var}\" \"${prefix}gcc\")\n        if(${test_var})\n            message(STATUS \"Found GCC with prefix ${prefix}\")\n            set(\"${out_var}\" \"${prefix}\")\n            break()\n        endif()\n    endforeach()\n    if(${out_var})\n        set(\"${out_var}\" \"${${out_var}}\" PARENT_SCOPE)\n    else()\n        message(FATAL_ERROR \"Unable to find valid cross-compiling GCC\")\n    endif()\nendfunction(FindPrefixedGCC)\n\nif(\"${CROSS_COMPILER_PREFIX}\" STREQUAL \"\")\n    if((\"${arch}\" STREQUAL \"arm\") OR (\"${arch}\" STREQUAL \"x86\") OR (\"${arch}\" STREQUAL \"riscv\"))\n        if(${sel4_arch} STREQUAL \"aarch32\" OR ${sel4_arch} STREQUAL \"arm_hyp\")\n            FindPrefixedGCC(\n                CROSS_COMPILER_PREFIX\n                \"arm-linux-gnueabi-\"\n                \"arm-linux-gnu-\"\n                \"arm-none-eabi-\"\n            )\n        elseif(${sel4_arch} STREQUAL \"aarch64\")\n            FindPrefixedGCC(\n                CROSS_COMPILER_PREFIX\n                \"aarch64-linux-gnu-\"\n                \"aarch64-unknown-linux-gnu-\"\n                \"aarch64-none-linux-gnu-\"\n                \"aarch64-none-elf-\"\n            )\n        elseif(${arch} STREQUAL \"riscv\")\n            FindPrefixedGCC(\n                CROSS_COMPILER_PREFIX\n                \"riscv64-unknown-linux-gnu-\"\n                \"riscv64-unknown-elf-\"\n                \"riscv64-elf-\"\n            )\n        endif()\n    else()\n        # For backwards compatibility reasons we allow this file to work without templating.\n        # If initialised with -DCMAKE_TOOLCHAIN_FILE=\"$SCRIPT_PATH/gcc.cmake\" this script\n        # understood the following arguments: ARM, AARCH32, AARCH32HF, AARCH64, RISCV32, RISCV64, APPLE\n        if(AARCH32 OR ARM)\n            FindPrefixedGCC(\n                CROSS_COMPILER_PREFIX\n                \"arm-linux-gnueabi-\"\n                \"arm-linux-gnu-\"\n                \"arm-none-eabi-\"\n            )\n            if(ARM)\n                message(\"ARM flag is deprecated, please use AARCH32\")\n            endif()\n        elseif(AARCH64)\n            FindPrefixedGCC(\n                CROSS_COMPILER_PREFIX\n                \"aarch64-linux-gnu-\"\n                \"aarch64-unknown-linux-gnu-\"\n                \"aarch64-none-linux-gnu-\"\n                \"aarch64-none-elf-\"\n            )\n        elseif(RISCV32 OR RISCV64)\n            FindPrefixedGCC(\n                CROSS_COMPILER_PREFIX\n                \"riscv64-unknown-linux-gnu-\"\n                \"riscv64-unknown-elf-\"\n                \"riscv64-none-elf-\"\n                \"riscv64-elf-\"\n            )\n        endif()\n    endif()\n    if(AARCH32HF)\n        FindPrefixedGCC(\n            CROSS_COMPILER_PREFIX\n            \"arm-linux-gnueabihf-\"\n            \"arm-linux-gnu-\" # Later checks should confirm this has `hardfp`\n        )\n    endif()\n\n    if(\"${CROSS_COMPILER_PREFIX}\" STREQUAL \"\")\n        # If we haven't set a target above we assume x86_64/ia32 target, and hence have to\n        # find an appropriate x86 compatible toolchain. If we're on an AArch64 host, GCC will\n        # not support x86. If we're on macOS (detected via CMAKE_HOST_APPLE), we need to find\n        # the appropriate x86 compiler regardless of host architecture. This is as `gcc`\n        # usually actually uses clang on macOS, not GCC.\n        if(\"${CMAKE_HOST_SYSTEM_PROCESSOR}\" STREQUAL \"aarch64\" OR CMAKE_HOST_APPLE)\n            if(\"${sel4_arch}\" STREQUAL \"ia32\")\n                FindPrefixedGCC(CROSS_COMPILER_PREFIX \"i686-linux-gnu-\" \"i686-unknown-linux-gnu-\")\n            else()\n                FindPrefixedGCC(\n                    CROSS_COMPILER_PREFIX \"x86_64-linux-gnu-\" \"x86_64-unknown-linux-gnu-\"\n                )\n            endif()\n        endif()\n    endif()\nendif()\n\nset(CMAKE_C_COMPILER ${CROSS_COMPILER_PREFIX}gcc)\nset(CMAKE_ASM_COMPILER ${CROSS_COMPILER_PREFIX}gcc)\nset(CMAKE_CXX_COMPILER ${CROSS_COMPILER_PREFIX}g++)\n\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n\nset(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)\n\nset(CMAKE_TRY_COMPILE_PLATFORM_VARIABLES CROSS_COMPILER_PREFIX)\n\nmark_as_advanced(FORCE CMAKE_TOOLCHAIN_FILE)\n\n# Invoke compiler via ccache. This has no effect if ccache cannot be found.\n# Projects can override this effect by resetting the RULE_LAUNCH_COMPILE and\n# RULE_LAUNCH_LINK properties.\nfind_program(CCACHE ccache)\nif(NOT (\"${CCACHE}\" STREQUAL CCACHE-NOTFOUND))\n    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE})\n    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE})\nendif()\nmark_as_advanced(CCACHE)\n\n# GCC color options:\n# Ninja and ccache cause gcc to not emit colored output when -fdiagnostics-color=auto.\n# We upgrade this to -fdiagnostics-color=always if FORCE_COLORED_OUTPUT is set\n# We default FORCE_COLORED_OUTPUT=ON if GCC_COLORS is set in the environment\n# otherwise FORCE_COLORED_OUTPUT is left off.\nif($ENV{GCC_COLORS})\n    set(coloured_output ON)\nelse()\n    set(coloured_output OFF)\nendif()\noption(FORCE_COLORED_OUTPUT \"Always produce ANSI-colored output.\" ${coloured_output})\nmark_as_advanced(FORCE_COLORED_OUTPUT)\nif(${FORCE_COLORED_OUTPUT})\n    include_guard(GLOBAL)\n    add_compile_options(-fdiagnostics-color=always)\nendif()\n"
        },
        {
          "name": "gdb-macros",
          "type": "blob",
          "size": 21.8935546875,
          "content": "#\n# Copyright 2014, General Dynamics C4 Systems\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\n#GDB macros for displaying seL4 data structures. Currently a work in progress.\n#TODO: macros for examining an address space\n# Note: This assumes KERNEL_OFFSET is a symbol that has the same value\n# as PPTR_BASE_OFFSET\n\n\nset print pretty on\n\ndefine sel4\nend\n\ndocument sel4\n  This is a set of macros to interpret sel4 data structures. Available commands:\n\n  runqueues\n  currthread \n  sched_action\n  current_lookup_fault\n  current_fault\n  current_syscall_error\n  resolve_cap\n  resolve_cap_current\n  currthread_cnode\n  disp_cap\n  disp_ep\n  disp_ep_queue\n  dump_cnode\n  dump_currthread_cnode\n  get_thread_vspace\n  get_thread_cspace\n  get_thread_reply_slot\n  get_thread_most_recent_ipc_sender\n  get_thread_ipc_buffer\n  dump_thread_info\n\n  Type help <command> for more information on a specific command\nend\n\n# Discover type of target\n#\ndefine runqueues\n  set $found=0\n  while($found<255)\n    set $queue = ksReadyQueues[$found]\n    if($queue.head != 0x0)\n      set $current = $queue.head\n      while($current != $queue->end)\n        print *$current\n        set $current = $current->tcbSchedNext\n      end\n      print *$current\n    end\n    set $found++\n  end\nend\n\ndocument runqueues\n  Print TCBs of all runnable threads\nend\n\ndefine runqueues_c\n  set $found=0\n  while($found<255)\n    set $queue = ksReadyQueues[$found]\n    if($queue.head != 0x0)\n      set $current = $queue.head\n      while($current != $queue->end)\n        print_condensed_tcb $current\n        set $current = $current->tcbSchedNext\n      end\n      print_condensed_tcb $current\n    end\n    set $found++\n  end\nend\n\ndefine print_condensed_tcb\n  printf \"%d\\n\", $arg0->tcbPriority\nend\n\ndefine currthread\n  print *ksCurThread\nend\n\ndocument currthread\n  Print TCB of current thread\nend\n\ndefine sched_action\n  if(ksSchedulerAction == 0x0)\n    printf \"ResumeCurrentThread\\n\"\n  else \n    if (ksSchedulerAction == ~0x0)\n      printf \"ChooseNewThread\\n\"\n    else\n      printf \"SwitchToThread:\\n\"\n      print *ksSchedulerAction\n    end\n  end\nend\n\ndocument sched_action\n  Print the next scheduler action\nend\n\ndefine current_lookup_fault\n#print current_lookup_fault\n  if((current_lookup_fault.words[0] & 0x3)==lookup_fault_invalid_root)\n    printf \"invalid root\\n\"\n  else\n    if((current_lookup_fault.words[0] & 0x3)==lookup_fault_missing_capability)\n      printf \"missing capability\\n\"\n    else\n      if ((current_lookup_fault.words[0] & 0x3)==lookup_fault_depth_mismatch)\n        printf \"depth mismatch\\n\"\n      else \n        if((current_lookup_fault.words[0] & 0x3)==lookup_fault_guard_mismatch)\n          printf \"guard mismatch\\n\"\n        else\n          printf \"unknown lookup fault\\n\"\n        end\n      end\n    end\n  end\nend\n\ndocument current_lookup_fault\n  Decodes the current_lookup_fault variable to determine what went wrong with the last lookup\nend\n\ndefine current_fault\n  print current_fault\nend\n\ndocument current_fault\n  Prints the last fault\nend\n\ndefine current_syscall_error\n  print current_syscall_error\nend\n\ndocument current_syscall_error\n  Prints the last syscall error\nend\n\ndefine cap_type\n  return ($arg1.words[0]>>28) & 0xf\nend\n\ndefine mask\n  ((1<< $arg0)-1)\nend\n\ndefine currthread_cnode\n  set $cnode = ((cte_t *)((unsigned int)ksCurThread&~((1<<9)-1)))\n  print $cnode->cap\nend\n\ndocument currthread_cnode\n  Prints the root CNode of the current thread\nend\n\ndefine cnode_for_thread\n  set $cnode = ((cte_t *)((unsigned int)($arg0)&~((1<<9)-1)))\n  print $cnode->cap\nend\n\ndefine disp_ep\n  set $ep = *(endpoint_t *)$arg0\n  printf \"Queue head: %x\\n\", ($ep.words[1] & 0xfffffff0)\n  printf \"Queue tail: %x\\n\", ($ep.words[0] & 0xfffffff0)\n  print ((enum endpoint_state)($ep.words[0] & 0x3))\nend\n\ndocument disp_ep\n  Display basic information about an endpoint. arg0: pointer to an endpoint data structure in-kernel memory. This can be obtained from resolve_cap.\nend\n\ndefine disp_ep_queue\n  set $ep = *(endpoint_t *)$arg0\n  set $current = (tcb_t *)($ep.words[1] & 0xfffffff0)\n  set $tail = (tcb_t *)($ep.words[0] & 0xfffffff0)\n  if( $current == 0)\n    printf \"empty\\n\"\n  else\n    while( $current != $tail)\n      print *$current\n      set $current = $current->tcbEPNext\n    end\n    print *$current\n  end\nend\n\ndocument disp_ep_queue\n  Display all TCBs in an endpoint's queue. arg0: pointer to an endpoint data structure in kernel memory. This can be obtained from resolve_cap.\nend\n\ndefine disp_cap\n  set $cap = $arg0\n  set $type = (cap_tag_t)(($cap.words[0] >> 28) & 0xf)\n\n  if( $type == cap_null_cap )\n    printf \"Type: cap_null_cap\\n\"\n  end\n\n  if( $type == cap_untyped_cap )\n    printf \"Type: cap_untyped_cap\\n\"\n    printf \"blocksize: %x\\n\", $cap.words[1] & 0x1f\n    printf \"capPtr: %x\\n\", ($cap.words[0]>>28) & 0xf\n  end\n\n  if( $type == cap_endpoint_cap )\n    printf \"Type: cap_endpoint_cap\\n\"\n    printf \"badge: %x\\n\", ($cap.words[1] & 0xfffffff8) >> 3\n    printf \"EPPtr: %x\\n\", ($cap.words[0] & 0xfffffff) << 4\n  end\n\n  if( $type == cap_notification_cap )\n    printf \"Type: cap_notification_cap\\n\"\n    printf \"badge: %x\\n\", ($cap.words[1] & 0xfffffff8) >> 3\n    printf \"AEPPtr: %x\\n\", ($cap.words[0] & 0xfffffff) << 4\n  end\n\n  if( $type == cap_reply_cap )\n    printf \"Type: cap_reply_cap\\n\"\n  end\n\n  if( $type == cap_cnode_cap)\n    printf \"Type: cap_cnode_cap\\n\"\n    printf \"Radix: %x\\n\", ($cap.words[1] & 0xf800000) >> 23\n    printf \"Guard size: %x\\n\", ($cap.words[1] & 0x7c0000) >> 18\n    printf \"Guard: %x\\n\", ($cap.words[1] & 0x3ffff) >> 0\n    printf \"CNode ptr: %x\\n\", ($cap.words[0] & 0x7ffffff) << 5\n  end\n\n  if( $type == cap_thread_cap)\n    printf \"Type: cap_thread_cap\\n\"\n    printf \"TCBPtr: %x\\n\", ($cap.words[0] & 0xfffffff) << 4\n  end\n\n  if( $type == cap_irq_handler_cap )\n    printf \"Type: cap_irq_handler_cap\\n\"\n    printf \"capIRQ: %x\\n\", ($cap.words[1] & 0xff) >> 0\n  end\n\n  if( $type == cap_irq_control_cap )\n    printf \"Type: cap_irq_control_cap\\n\"\n    printf \"not implemented\\n\"\n  end\n\n  if( $type == cap_zombie_cap )\n    printf \"Type: cap_zombie_cap\\n\"\n  end\n\n  if( $type == cap_subtype_cap )\n    printf \"Type: cap_subtype_cap\\n\"\n\n    set $subtype = (subcap_tag_t)(($cap.words[0] & 0xf000000) >> 24)\n\n    if( $subtype == subcap_asid_control_cap )\n      printf \"Subtype: subcap_asid_control_cap\\n\"\n    end\n\n    if( $subtype == subcap_asid_pool_cap )\n      printf \"Subtype: subcap_asid_pool_cap\\n\"\n      printf \"capASIDBase: %x\\n\", $cap.words[1] & 0xffff\n      printf \"capType: %x\\n\", ($cap.words[0] >> 28) & 0xf\n      printf \"capASIDPool %x\\n\", ($cap.words[0] << 12)\n    end\n\n    if( $subtype == subcap_io_port_cap )\n      printf \"Subtype: subcap_io_port_cap\\n\"\n      printf \"capType: %x\\n\", ($cap.words[0] >> 28) & 0xf\n    end\n\n    if( $subtype == subcap_io_space_cap )\n      printf \"Subtype: subcap_io_space_cap\\n\"\n    end\n\n    if( $subtype == subcap_io_page_table_cap )\n      printf \"Subtype: subcap_io_page_table_cap\\n\"\n    end\n\n  end\n\n  if( $type == cap_frame_cap )\n    printf \"Type: cap_frame_cap\\n\"\n    printf \"FMappedAddress: %x\\n\", ($cap.words[1] & 0xfffff) << 12\n    printf \"FBasePtr: %x\\n\", ($cap.words[0] & 0xfffff) << 12\n    printf \"FMappedASIDLow: %x\\n\", ($cap.words[1] & 0x3ff00000) >> 20\n    printf \"FMappedASIDHigh: %x\\n\", ($cap.words[0] & 0xfc00000) >> 22\n    printf \"Frame size: %x\\n\", ($cap.words[1] & 0x80000000) >> 31\n  end\n\n  if( $type == cap_page_table_cap )\n    printf \"Type: cap_page_table_cap\\n\"\n    printf \"not implemented\\n\"\n  end\n\n  if( $type == cap_page_directory_cap )\n    printf \"Type: cap_page_directory_cap\\n\"\n    printf \"Is mapped: %x\\n\", ($cap.words[1] & 0x10000) >> 16\n    printf \"ASID: %x\\n\", ($cap->words[1] & 0xffff) >> 0\n    printf \"CapPDBasePTR: %x\\n\", $cap->words[1] << 12\n  end\n\n  print $cap\nend\n\ndocument disp_cap\n  Determines the type of a cap and prints relevant information. arg0: a kernel capability data structure (not a pointer). This can be obtained from resolve_cap.\nend\n\ndefine get_thread_cap\n  set $result = ((cte_t *)(((unsigned int) $arg0 )&~((1<<10)-1))) + $arg1\n  set $result = $result->cap\nend\n\ndocument get_thread_cap\n  Gets one of the caps associated with a TCB e.g. root CNode, VSpace, ipc_buffer. arg0: pointer to tcb struct, arg1: index of cap\nend\n\ndefine get_thread_cspace\n  get_thread_cap $arg0 0\nend\n\ndocument get_thread_cspace\n  Get the CTE for the root CNode of a thread. arg0: the in-kernel data structure representing the thread cap\nend\n\ndefine get_thread_vspace\n  get_thread_cap $arg0 1\nend\n\ndocument get_thread_vspace\n  Get the CTE for the vspace of a thread. arg0: the in-kernel data structure representing the thread cap\nend\n\ndefine get_thread_reply_slot\n  get_thread_cap $arg0 2\nend\n\ndocument get_thread_reply_slot\n  Get the CTE for the reply slot of a thread. arg0: the in-kernel data structure representing the thread cap\nend\n\ndefine get_thread_most_recent_ipc_sender\n  get_thread_cap $arg0 3\nend\n\ndocument get_thread_most_recent_ipc_sender\n  Get the CTE for the most recent IPC sender of a thread. arg0: the in-kernel data structure representing the thread cap\nend\n\ndefine get_thread_ipc_buffer\n  get_thread_cap $arg0 4\nend\n\ndocument get_thread_ipc_buffer\n  Get the CTE for the IPC buffer of a thread. arg0: the in-kernel data structure representing the thread cap\nend\n\ndefine dump_thread_info\n  set $tcbptr = $arg0\n  printf \"\\nCSpace:\\n\"\n  get_thread_cspace $tcbptr\n  disp_cap $result\n  printf \"\\nVSpace:\\n\"\n  get_thread_vspace $tcbptr\n  disp_cap $result\n  printf \"\\nReply slot:\\n\"\n  get_thread_reply_slot $tcbptr\n  disp_cap $result\n  printf \"\\nMost recent IPC sender:\\n\"\n  get_thread_most_recent_ipc_sender $tcbptr\n  disp_cap $result\n  printf \"\\nIPC buffer:\\n\"\n  get_thread_ipc_buffer $tcbptr\n  disp_cap $result\nend\n\ndocument dump_thread_info\n  Dump the extra caps associated with a thread (root CNode, VSpace etc). arg0: the in-kernel data structure representing the thread cap\nend\n\ndefine pd_for_asid\n  set $asid = $arg0\n  set $poolPtr = x86KSASIDTable[$asid >> asidLowBits];\n  set $pd = poolPtr->array[$asid & ((1<<asidLowBits)-1)];\n  if( !$asid || !$poolPtr )\n    printf \"Something went wrong\\n\"\n  else\n    print $pd\n  end\nend\n\ndefine resolve_cap\n  set $nodeCap = $arg0\n  set $capptr = (int)$arg1\n  set $n_bits = (int)$arg2\n\n  while(1) \n#printf \"loop: remaining: %d\\n\", $n_bits\n    #test cap type\n    if((( $nodeCap.words[0]>>28)&0xf) != cap_cnode_cap)\n      printf \"Error: not a CNode\\n\"\n      loop_break\n    end\n    set $radixBits = ($nodeCap.words[1] & 0xf800000) >> 23\n    set $guardBits = ($nodeCap.words[1] & 0x7c0000) >> 18\n    set $levelBits = $radixBits + $guardBits\n    set $capGuard = ($nodeCap.words[1] & 0x3ffff) >> 0\n\n    set $guard = ($capptr >> ($n_bits - $guardBits)) & ((1<<$guardBits)-1)\n    \n    if( ($guardBits > $n_bits) || ($guard != $capGuard))\n      printf \"levelbits: %d, radixbits: %d, guardbits: %d, n_bits: %d\\n\", $levelBits, $radixBits, $guardBits, $n_bits\n      printf \"guard: %x, capguard: %x\", $guard, $capGuard\n      printf \"lookup fault guard mismatch\\n\"\n      loop_break\n    end\n\n    if( $levelBits > $n_bits )\n      printf \"lookup fault depth mismatch\\n\"\n      loop_break\n    end\n\n    set $offset = ($capptr >> ($n_bits - $levelBits)) & ((1<<$radixBits)-1)\n    set $slot = ((cte_t *)(($nodeCap.words[0] & 0x7ffffff) << 5)) + $offset\n\n    if( $n_bits <= $levelBits)\n      disp_cap $slot->cap\n      loop_break\n    end\n\n    set $n_bits -= $levelBits\n    set $nodeCap = $slot->cap\n\n    #test cap type\n    if((( $nodeCap.words[0]>>28)&0xf) != cap_cnode_cap)\n      printf \"warning: terminating because node is not a CNode, not because all bits were resolved\\n\"\n      disp_cap $nodeCap\n      loop_break\n    end\n\n  end\n\nend\n\ndocument resolve_cap\n  Resolve a capPtr and print its contents using disp_cap. arg0: CNode to start resolving at, arg1: the cap to resolve (an integer), arg2: the depth to resolve to (an integer). The currthread_cnode macro may be useful to obtain the first argument.\nend\n\ndefine resolve_cap_current\n  currthread_cnode\n  resolve_cap $cnode->cap $arg0 $arg1\nend\n\ndocument resolve_cap_current\n  Resolve a capPtr and print its contents. Caps are resolved relative to root CNode of current thread. arg1: the cap to resolve, arg2: the depth.\nend\n\ndefine dump_cnode\n  set $nodeCap = $arg0\n\n  if((( $nodeCap.words[0]>>28)&0xf) != cap_cnode_cap)\n    printf \"Error: not a CNode\\n\"\n  end\n\n  set $radixBits = ($nodeCap.words[1] & 0xf800000) >> 23\n  set $guardBits = ($nodeCap.words[1] & 0x7c0000) >> 18\n  set $levelBits = $radixBits + $guardBits\n\n  set $count = 0\n\n  while( $count < (1<<$radixBits))\n    set $slot = ((cte_t *)(($nodeCap.words[0] & 0x7ffffff) << 5)) + $count\n    if((($slot->cap.words[0]>>28)&0xf) != cap_null_cap)\n      printf \"offset: %d\\n\", $count\n      disp_cap $slot->cap \n      printf \"\\n\"\n    end\n    set $count = $count+1\n  end\nend\n\ndocument dump_cnode\n  Dump the contents of a CNode. arg1: the CNode to dump\nend\n\ndefine dump_currthread_cnode\n  printf \"Top level CNode: \\n\"\n  currthread_cnode\n  printf \"\\n\\n\"\n  dump_cnode $cnode->cap\nend\n\ndocument dump_currthread_cnode\n  Dump the contents of the root CNode of the current thread. No arguments.\nend\n\ndefine irq_handler\n  set $slot = intStateIRQNode + $arg0\n  set $cap = $slot->cap\n  if((cap_tag_t)(($cap.words[0] >> 28) & 0xf) != cap_notification_cap)\n    printf \"no handler\\n\"\n  else\n    set $cap = (async_endpoint_t *)(($cap.words[0] & 0xfffffff) << 4)\n    disp_ep *$cap\n    disp_ep_queue *$cap\n  end\nend\n\ndocument irq_handler\n  Print the endpoints and handling threads for an IRQ. arg0: the IRQ number\nend\n\ndefine finish_irq\n  set $current_sel4_thread = ksCurThread\n#set $current = ((struct thread_info *)per_cpu___l4_current_tinfo)->task\n  tbreak *0xf012102a if (ksCurThread==$current_sel4_thread)  \n  continue\n  stepi\nend\n\ndocument finish_irq\n  Run until the end of the IRQ handler. This is useful if you are stepping through userland code and an interrupt occurs and control moves to the kernel. As far as I know there is no way to disable interrupts in qemu to avoid this.\nend\n\ndefine n2\n  next\n  if $eip>(unsigned long)&KERNEL_OFFSET\n    printf \"IRQ happened\\n\"\n    finish_irq\n  end\nend\n\ndocument n2\n  Like next but if it detects that an IRQ happens it executes that and returns.\nend\n\ndefine vtd_root\n  print x86KSvtdRootTable\nend\n\ndefine decode_vtd_root_entry\n  set $vtd_root_entry = (vtd_rte_t)$arg0\n  set $vtd_re_ctp = ($vtd_root_entry.words[0] & 0xfffff000)\n  set $vtd_re_present = ($vtd_root_entry.words[0] & 0x1)\nend\n\ndocument decode_vtd_root_entry\n  \"Decodes the vtd root entry into its component parts\"\nend\n\ndefine print_vtd_root_entry\n  printf \"ctp: %x\\n\", $vtd_re_ctp\n  printf \"present: %x\\n\", $vtd_re_present\nend\n\ndocument print_vtd_root_entry\n  \"Print the fields of an earlier decoded vtd root entry\"\nend\n\ndefine print_vtd_root_table \n  set $vtd_root_entry_ptr = x86KSvtdRootTable\n  set $count = 0\n  while($count < 256)\n    decode_vtd_root_entry $vtd_root_entry_ptr[$count] \n    if($vtd_re_present)\n      printf \"Index: %x\\n\", $count\n      print_vtd_root_entry \n    end\n    set $count++\n  end\nend\n\ndocument print_vtd_root_table\n  \"Prints all of the entries in the vtd root table. There is one entry for each PCI bus\"\nend\n\ndefine decode_vtd_context_entry\n  set $vtd_context_entry = (vtd_cte_t)$arg0\n  set $vtd_ce_did = ($vtd_context_entry.words[2] & 0xffff00) >> 8\n  set $vtd_ce_aw = ($vtd_context_entry.words[2] & 0x7)\n  set $vtd_ce_asr = ($vtd_context_entry.words[0] & 0xfffff000)\n  set $vtd_ce_present = ($vtd_context_entry.words[0] & 0x1)\nend\n\ndocument decode_vtd_context_entry\n  \"Decodes a vtd context entry into its component parts. arg0: pointer to the entry\"\nend\n\ndefine print_vtd_context_entry\n  printf \"did: %x\\n\", $vtd_ce_did\n  printf \"aw: %x\\n\", $vtd_ce_aw\n  printf \"asr: %x\\n\", $vtd_ce_asr\n  printf \"present: %x\\n\", $vtd_ce_present\nend\n\ndocument print_vtd_context_entry \n  \"Print the fields of an earlier decoded vtd context entry\"\nend\n\ndefine print_vtd_context_table\n  set $vtd_context_entry_ptr = (vtd_cte_t *)$arg0\n  set $count = 0\n  while($count < 256)\n    decode_vtd_context_entry $vtd_context_entry_ptr[$count]\n    if($vtd_ce_present)\n      printf \"index %x\\n\", $count\n      print_vtd_context_entry\n    end\n    set $count++\n  end\nend\n\ndocument print_vtd_context_table\n  \"Prints all of the fields in a vtd context table. There is one entry for each (dev, fn) in the bus. arg0: a pointer to the context table\"\nend\n\ndefine decode_vtd_page_table_entry\n  set $vtd_page_table_entry = (vtd_pte_t)$arg0\n  set $vtd_pte_addr =  ($vtd_page_table_entry.words[0] & 0xfffff000)\n  set $vtd_pte_write = ($vtd_page_table_entry.words[0] & 0x2) >> 1\n  set $vtd_pte_read = ($vtd_page_table_entry.words[0] & 0x1)\nend\n\ndocument decode_vtd_page_table_entry\n  \"Decodes a vtd PTE info its component parts. arg0: pointer to the entry\"\nend\n\ndefine print_vtd_page_table_entry\n  printf \"addr: %x\\n\", $vtd_pte_addr\n  printf \"write: %x\\n\", $vtd_pte_write\n  printf \"read: %x\\n\", $vtd_pte_read\nend\n\ndocument print_vtd_page_table_entry \n  \"Print the fields of an earlier decoded vtd page table entry\"\nend\n\ndefine print_vtd_page_table\n  set $vtd_pte_ptr = (vtd_pte_t *)$arg0\n  set $count = 0\n  while($count < 256)\n    decode_vtd_page_table_entry $vtd_pte_ptr[$count]\n    if($vtd_pte_read || $vtd_pte_write)\n      printf \"index: %x\\n\", $count\n      print_vtd_page_table_entry \n    end\n    set $count++\n  end\nend\n\ndocument print_vtd_page_table\n  \"Prints all of the fields in a vtd page table. arg0: a pointer to the page table\"\nend\n\n\ndefine paddr_to_vaddr\n  set $var = (unsigned long)$arg0\n  set $vaddr = ($var + (unsigned long)&KERNEL_OFFSET)\nend\n\ndocument paddr_to_vaddr\n  \"Convert a physical address to the locaction to which it is mapped in the kernel\"\nend\n\ndefine vaddr_to_paddr\n  set $paddr = ($arg0 - (unsigned long)&KERNEL_OFFSET)\nend\n\ndocument vaddr_to_paddr\n  \"Convert a virtual address in the kernel to a physical address\"\nend\n\ndefine lookup_vtd_address\n  set $bus = $arg0\n  set $devfn = $arg1\n  set $address = $arg2\n\n  set $vtd_root_entry_ptr = x86KSvtdRootTable\n  decode_vtd_root_entry $vtd_root_entry_ptr[$bus]\n  if($vtd_re_present)\n    printf \"Root entry: \\n\"\n    print_vtd_root_entry\n    paddr_to_vaddr $vtd_re_ctp\n    print/x $vaddr\n    set $vtd_context_entry_ptr = (vtd_cte_t *)$vaddr\n    paddr_to_vaddr $vtd_context_entry_ptr[$devfn]\n    decode_vtd_context_entry $vaddr\n    if($vtd_ce_present)\n      printf \"Context entry: \\n\"\n      print_vtd_context_entry\n      walk_vtd_pgtables $vtd_ce_asr $address\n    else\n      printf \"Error: context entry not present\\n\"\n    end\n  else\n    printf \"Error: root entry not present\\n\"\n  end\nend\n\ndocument lookup_vtd_address\n  \"Looks up an address in the address space of a given PCI device. arg0: PCI bus number, arg1: PCI devfn number, arg2: virtual address to look up\"\nend\n\ndefine walk_vtd_pgtables\n  set $pg_tab = (vtd_pte_t *)$arg0\n  set $address = (unsigned long long int)$arg1\n  set $count=0\n  if(($address & 0xffffff8000000000) == 0x0)\n    set $address = $address << 25\n    while(1)\n      set $index = ($address & 0xff80000000000000) >> (64-9)\n      printf \"index: %x\\n\", $index\n      set $address = ($address << 9)\n      paddr_to_vaddr $pg_tab\n      set $pg_tab = (vtd_pte_t *)$vaddr\n      decode_vtd_page_table_entry $pg_tab[$index]\n      if($vtd_pte_read || $vtd_pte_write)\n        printf \"Page table entry: \\n\"\n        print_vtd_page_table_entry\n#TODO check for superpages\n        set $count++\n        if($count==3)\n          printf \"Translation complete. Physical address: %llx\\n\", $vtd_pte_addr \n          loop_break\n        else\n          set $pg_tab = (vtd_pte_t *)$vtd_pte_addr\n        end\n      else \n        printf \"Error: Page table entry not present\\n\"\n        printf \"Page table: \"\n        print_vtd_page_table_entry \n        loop_break\n      end\n    end\n  else\n    printf \"Error: bits 63:39 must be 0\\n\"\n  end\nend\n\ndocument walk_vtd_pgtables\n  \"Walks the IOMMU page table to resolve a virtual address starting at the given page table. arg0: pointer to page table (in seL4 virtual memory), arg1: virtual address to resolve\"\nend\n\ndefine decode_pte\n  set $pte_addr = $arg0 & 0xfffff000\n  set $pte_present = $arg0 & 1\n  set $pte_rw = ($arg0 >> 1) & 1\n  set $pte_usr = ($arg0 >> 2) & 1\n  set $pte_pwt = ($arg0 >> 3) & 1\n  set $pte_pcd = ($arg0 >> 4) & 1\n  set $pte_accessed = ($arg0 >> 5) & 1\n  set $pte_dirty = ($arg0 >> 6) & 1\n  set $pte_pse = ($arg0 >> 7) & 1\n  set $pte_pat = ($arg0 >> 12) & 1\n  set $pte_avl = ($arg0 >> 9) & 7\n  set $pte_global = ($arg0 >> 8) & 1\nend\n\ndocument decode_pte\n Decode an X86 page table leaf entry into its component parts.\n If the PRESENT bit is 0 then the rest of the bits can be anything\n (OSs typically reuse them for swap housekeeping)\nend\n\ndefine maybe_print\n  if $arg0\n    printf $arg1\n  else\n    printf $arg2\n  end\nend\n\ndocument maybe_print\n If arg0 is non-zero print arg1 otherwise print arg2.\nend\n\n# Can't use the obvious printf formulation for this because gdb tries\n# to call malloc in the target --- which doesn't work in SeL4\ndefine print_pte\n  printf \"Address 0x%x \", $pte_addr\n  printf \"  attributes: \"\n  maybe_print $pte_present \"P\" \"-\"\n  maybe_print $pte_rw  \"w\"  \"r\"\n  maybe_print $pte_usr  \"U\"  \"S\"\n  maybe_print $pte_pwt \" WT \"  \" WB \"\n  maybe_print $pte_pcd \"NC \"  \"C \"\n  maybe_print $pte_accessed  \"A\"  \"-\"\n  maybe_print $pte_dirty  \"d\"  \"-\"\n  maybe_print $pte_pse  \"4M\"  \"4k\"\n  maybe_print $pte_pat \" PAT \" \"\"\n  maybe_print $pte_global \"g\" \"\"\n\n  printf \"AVL%x\\n\", $pte_avl\nend\n\ndocument print_pte\n  Print the PTE parts split out by decode_pte.\n  You must invoke decode_pte before invoking this function.\nend\n\ndefine pgd\n  set $idx = 0\n  set $pgdptr = $arg0\n  while ($idx < 1024)\n    set $pte = *(long *)$pgdptr\n#printf \"PGD@0x%x is 0x%x\\n\", $pgdptr, $pte\n    decode_pte $pte\n    set $mapped_addr =  $idx * (4 * 1024 * 1024)\n    set $idx = $idx + 1\n    set $pgdptr = $pgdptr + 4\n    if (! $pte_present)\n       loop_continue\n    end\n    if $pte_pse\n       printf \"HUGE (4G) V 0x%x \", $mapped_addr\n       print_pte\n    else\n      set $pteptr = (long)$pte_addr + 0xe0000000\n      set $n = 0\n      while ($n < 1024)\n        set $pte = *(long *)$pteptr\n        decode_pte $pte\n        if $pte_present\n          printf  \"V:%08x \", $mapped_addr\n          print_pte\n        end\n        set $pteptr = $pteptr + 4\n        set $mapped_addr = $mapped_addr + 4096\n        set $n = $n + 1\n      end\n    end\n  end\nend\n\ndocument pgd\n  Print a page table, starting at the page global directory.\n  Assumes 2-level (non-PAE) page tables,\nend\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "libsel4",
          "type": "tree",
          "content": null
        },
        {
          "name": "llvm.cmake",
          "type": "blob",
          "size": 1.1865234375,
          "content": "#\n# Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n#\n# SPDX-License-Identifier: GPL-2.0-only\n#\n\ncmake_minimum_required(VERSION 3.7.2)\n\nset(CMAKE_SYSTEM_NAME Generic)\n# For a generic system this is unused, so define it to something that will be\n# obvious if someone accidentally uses it\nset(CMAKE_SYSTEM_PROCESSOR seL4CPU)\n\nset(LLVM_TOOLCHAIN ON)\n\nset(CROSS_COMPILER_PREFIX ${TRIPLE}-)\n\nset(CMAKE_ASM_COMPILER \"clang\")\nset(CMAKE_ASM_COMPILER_ID Clang)\nset(CMAKE_ASM_COMPILER_TARGET ${TRIPLE})\n\nset(CMAKE_C_COMPILER \"clang\")\nset(CMAKE_C_COMPILER_ID Clang)\nset(CMAKE_C_COMPILER_TARGET ${TRIPLE})\n\nset(CMAKE_CXX_COMPILER \"clang++\")\nset(CMAKE_CXX_COMPILER_ID Clang)\nset(CMAKE_CXX_COMPILER_TARGET ${TRIPLE})\n\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n\nset(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)\n\nmark_as_advanced(FORCE CMAKE_TOOLCHAIN_FILE)\n\nfind_program(CCACHE ccache)\nif(NOT (\"${CCACHE}\" STREQUAL CCACHE-NOTFOUND))\n    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE})\n    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE})\nendif()\nmark_as_advanced(CCACHE)\n"
        },
        {
          "name": "manual",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}