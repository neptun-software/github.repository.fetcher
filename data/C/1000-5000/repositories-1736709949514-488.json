{
  "metadata": {
    "timestamp": 1736709949514,
    "page": 488,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "p-gen/smenu",
      "stars": 2379,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.4921875,
          "content": "AlignAfterOpenBracket: 'true'\nAlignConsecutiveAssignments: 'true'\nAlignConsecutiveDeclarations: 'true'\nAlignEscapedNewlinesLeft: 'true'\nAlignOperands: 'true'\nAlignTrailingComments: 'true'\nAllowAllArgumentsOnNextLine: 'false'\nAllowAllParametersOfDeclarationOnNextLine: 'false'\nAllowShortBlocksOnASingleLine: 'false'\nAllowShortCaseLabelsOnASingleLine: 'false'\nAllowShortFunctionsOnASingleLine: None\nAllowShortIfStatementsOnASingleLine: 'false'\nAllowShortLoopsOnASingleLine: 'false'\nAlwaysBreakBeforeMultilineStrings: 'false'\nBasedOnStyle: Mozilla\nBinPackArguments: 'false'\nBinPackParameters: 'false'\nBreakBeforeBinaryOperators: NonAssignment\nBreakBeforeBraces: Allman\nBreakBeforeTernaryOperators: 'true'\nBreakConstructorInitializersBeforeComma: 'false'\nColumnLimit: '80'\nContinuationIndentWidth: '2'\nDerivePointerAlignment: 'false'\nIndentCaseLabels: 'true'\nIndentWidth: '2'\nKeepEmptyLinesAtTheStartOfBlocks: 'true'\nLanguage: Cpp\nMaxEmptyLinesToKeep: '1'\nPenaltyBreakAssignment: '150'\nPenaltyBreakBeforeFirstCallParameter: '100'\nPointerAlignment: Right\nReflowComments: 'false'\nSeparateDefinitionBlocks: 'Always'\nSortIncludes: 'false'\nSpaceAfterCStyleCast: 'false'\nSpaceAroundPointerQualifiers: 'Before'\nSpaceBeforeAssignmentOperators: 'true'\nSpaceBeforeParens: ControlStatements\nSpaceBeforeCaseColon: 'false'\nSpaceInEmptyBlock: 'false'\nSpacesInSquareBrackets: 'false'\nSpaceInEmptyParentheses: 'false'\nSpacesBeforeTrailingComments: '1'\nSpacesInCStyleCastParentheses: 'false'\nSpacesInParentheses: 'false'\nTabWidth: '2'\nUseTab: Never\n"
        },
        {
          "name": "COPYRIGHT",
          "type": "blob",
          "size": 0.0654296875,
          "content": "(c) 2015, Pierre Gentile (p.gen.progs@gmail.com)\n\nLicense: MPL-2.0\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 16.8427734375,
          "content": "- Version 1.4.0\n* Fixes:\n  * Make sure certain variables are initialized before using them.\n  * Fixed cursor attribute on search failure.\n  * Some option names contain - instead of _.\n  * Correction of potential dereferencing of a NULL pointer.\n  * Correction of compiler warnings.\n\n* Improvements:\n  * Reworked code to go to start/end of line in col/line mode.\n  * Added a scrollbar below the window in col/line mode that displays\n    when necessary.\n  * UTF-8 space support for empty strings.\n  * Support for UTF-8 extended grapheme clusters if supported by the\n    terminal.\n\n* Miscellaneous:\n  * Changed the appearance of scrollbars to make them more discreet.\n  * Correction of typos in comments and in the manual.\n  * Code simplification and redesign.\n  * Reformatting the code to make it more readable.\n  * Made more NULL comparisons explicit.\n\n- Version 1.3.0\n* Fixes:\n  * Correction of an error in the calculation of the size of the longest word.\n  * Corrects the calculation of the space taken by the first direct access\n    numbers when it is explicitly specified.\n  * Increase the size of the buffer to store the scancode to prevent it\n    being truncated.\n  * Make decoding the column or row number more robust in command line analysis.\n  * Prevents the introduction of colours outside the range supported by\n    the terminal.\n* Improvements:\n  * Add the -sb|-sbw|-show_blank_words option to help display all words\n    composed entirely of spaces.\n  * Allow selection intervals to have no start or end number.\n  * In column mode, words can now be aligned left/right or centred.\n  * When numbering is active, unnumbered words are now always filled in with\n    blanks in col/line/tab mode.\n  * The -start_pattern option has been extended so that all words matching\n    the pattern can be searched directly using the Next/previous keys,\n    without having to enter search mode.\n  * The order in which -C/-R elements appear on the command line is now\n    taken into account.\n  * In column mode, columns and/or rows can have their own colour\n    and/or style.\n Miscellaneous:\n  * Corrections and improvements to the manual.\n  * Removal of dead code.\n  * Addition of an FAQ entry on alignments.\n  * The memory consumption has been reduced.\n\n\n- Version 1.2.0\n* Fixes:\n  * Correction of word selections with the mouse in long lines.\n  * Fixed support for the double-click mouse delay setting.\n  * Prevention of spurious commands being sent by the mouse paste function.\n  * Allowed compilation with old glibc versions.\n* Improvements:\n  * Redesign of the multiple selection mechanism with the possibility to undo.\n  * Improved initialization of mouse tracking modes.\n* Miscellaneous:\n  * Corrections and improvements to the manual.\n  * Removal of dead code.\n\n- Version 1.1.0\n* Fixes:\n  * Fix and improve the instant help (?) display.\n  * Fix and improve the substitution code.\n  * Fix and simplify the \"End\" key management code.\n* Improvements:\n  * Add mouse support.\n  * Allows to shift the window's content horizontally without moving the cursor.\n  * Small adjustments in UTF-8 symbols and comments.\n  * Improve the documentation.\n* Miscellaneous:\n  * Various code simplifications.\n- Version 1.0.0\n  * Fix and improve the content of the integrated help system.\n  * Allow multiple instances of the \"-limits\" option.\n- Version 1.0.0.RC2\n  * Improve memory management.\n  * Reduce the scope of some variables.\n  * Rework parts of the list code.\n  * Sync with github's ctxopt commit b943e6b.\n  * Switch to Mozilla Public License 2.0.\n  * Modify the URL to find the package maintainers.\n  * Fix a potential memory corruption.\n- Version 1.0.0.RC1\n* Fixes:\n  * Fix configure.ac for autoconf >= 2.70.\n  * Fixed a bug in the bash example in the README.\n  * Synchronization with the commit 9ddac73 of ctxopt on github.\n  * Use the right format to print size_t values (C99).\n  * Add a missing break.\n  * Fix a potential segfault when allocating .ini paths.\n  * Fixed color and attribute parsing.\n  * Fix some tests.\n* Improvements:\n  * Update to autoconf 2.71.\n  * Added \"invisible\" style attribute (n).\n  * Prevent smenu from running in the background.\n  * Catch and handle SIGPIPE signal.\n  * Improve the manual.\n* Miscellaneous:\n  * Various code simplifications.\n  * Removal of some unnecessary parameter.\n  * Removal of unnecessary code.\n  * Fixed typos in the README file.\n- Version 0.9.19\n* Fixes:\n  * Prevent an attempt to free memory that has already been freed.\n  * Prevent memory leaks when requesting help.\n  * Correctly handle the order of invocation of -i/-e options.\n  * Apply a PR from h1z1 with a small correction.\n  * Fix the UTF-8 byte sequence generation from a given UCS-4 codepoint.\n  * Many small fixes.\n* Improvements:\n  * Improve the documentation.\n  * Improve compatibility with some older compilers.\n  * Added the ability to set a global inactivity timeout.\n  * Improve the reliability of the code.\n* Miscellaneous:\n  * Removed the generation of the SUSE specific specfile.\n  * Many typos have been corrected.\n  * Various code simplifications.\n\n- Version 0.9.18\n* Fixes:\n  * A mismatch between signed and unsigned chars has been corrected.\n  * A fatal error in the direct access code has been corrected.\n  * A logic error that could cause a crash has been fixed.\n* Improvements:\n  * The user manual has been updated.\n  * An early substitution option -ES similar to -S has been added.\n  * Special levels are now considered when displaying searched words.\n  * An option to change the behaviour of the multi-selection mode has\n    been added.\n  * 4 more special levels (-6, -7, -8 and -9) are now available.\n  * The missing blink attribute has been added.\n  * The possibility to overload initial limits has been added.\n  * A new search session now starts from scratch by default.\n  * The integer checking function is now more reliable.\n  * A better code for validating UTF-8 byte sequences is now used.\n  * Tests have been added.\n* Misc:\n  * A missing licence reminder in the usage.c file has been added.\n  * An example in the README file has been added.\n  * Error messages are now more consistent.\n\n- Version 0.9.17\n* Fixes:\n  * The method to get the cursor location has been fixed and improved.\n  * A display problem when the title takes too many lines has been fixed.\n  * A failure when reopening /dev/tty is now fatal.\n  * Interesting signals are now trapped only when needed.\n  * The refresh mechanism when resizing the terminal has been fixed\n    and improved.\n  * \\U does not need too be escaped anymore.\n* Improvements:\n  * The -Q|-ignore_quotes option has been added to provide a way to\n    ignore quotes when splitting the input stream/file into words.\n  * The -!|-int|-int_string option has been added to define a string to\n    be displayed on stdout when ^C is entered during a smenu session.\n  * The usage text is now displayed in case of an error on the command\n    line.\n  * The code to create include/exclude RE patterns has been simplified.\n  * smenu now mimics the Unix shell signal processing.\n* Misc:\n  * The availability of str(n)dup is now checked at compile time.\n  * Tests for RE patterns/inv. character have bee added.\n  * The obsolete autogen.sh script has been removed.\n  * github's ctxopt commit f779fb8 is now used.\n  * The code is now a little more readable.\n\n- Version 0.9.16\n* Bug fixes:\n  * The SIGINT handling has been fixed.\n  * The lvm_menu example is fixed.\n  * Some memory allocation issues have been corrected.\n  * The last example in the man page now works correctly.\n  * The manual has been cleaned and corrected.\n  * Missing headers has been added.\n  * The List management code has been corrected and improved.\n  * Invalid UTF-8 sequences entered using \\u are now handled correctly.\n  * Unreachable code has been removed.\n  * As xwcscasecmp is missing in C99, a local version is now used.\n  * The search timeout now works correctly.\n* Improvements:\n  * Option management has been completely rewritten to use a new, more\n    flexible system called ctxopt (github.com/p-gen/ctxopt):\n    - Both short and long options can now be used.\n    - The validity of some option arguments can now be easily checked.\n    - A better and more precise help system can now be used.\n    - ...\n  * The horizontal and vertical scrolling symbols are now visually consistent.\n  * An updated version of autotools is now used.\n  * Wide mode is now allowed in column mode.\n  * Line delimiters can now be defined to break lines in tabulation mode.\n  * A set of UTF-8 characters can now be ignored as input.\n  * Substitution character for non-printable characters can now be changed.\n  * -N and -U options can now have multiple arguments.\n  * Fuzzy and substring searches now ignore leading and trailing blanks.\n  * Unicode codepoints can now be entered using the new \\U notation.\n  * smenu has been optimized to support networks with high latency.\n* Misc:\n  * A note in the README to thank the packagers has been added.\n  * The code has been adjusted to conform to C99.\n  * The code has been cleaned up in many places.\n\n- Version 0.9.15\n* Bug fixes:\n  * An ending pattern search was not correctly highlighted\n  * An highlighting issue when hitting the HOME key during a search\n    in numbered mode has been fixed\n  * The PgUp/PgDn moves have been fixed and improved in the presence of\n    excluded words\n  * The height of the windows when a message is present is now correctly\n    calculated\n  * The SIGINT signal handling is working properly now\n  * A vt100 terminal is assumed when the environment variable TERM\n    is unset\n* Improvements:\n  * The 'o' sub-option of the -D option has been enhanced\n  * The documentation has been improved and enhanced\n  * An example of a hierarchical menu interpreter has been added\n  * The message (title) appearance can now be changed with the -a option\n  * An empty line has been added after the message (title) for clarity\n  * The .spec file has been updated to support older SUSE/RH versions\n  * An issue opening /dev/tty is now clearly signaled\n  * The argument of the -n option is now optional and defaults to 0\n    (full height)\n  * It is now possible to directly move the cursor to the start/end of\n    the current line\n* Misc:\n  * The code has been split into several files\n  * The pull request #15 from sumbach/patch-1 has been merged\n  * The pull request #12 from jonnydubowsky/patch-1 has been merged\n  * More tests for the automatic regressions checking have been added\n  * UTF-8 string length processing has been optimized\n  * Help and usage messages are now printed on stdout\n  * A FAQ has been added\n  * Compiler warnings have been silenced\n\n- Version 0.9.14\n* Rework the search system (major change)\n  * Add a substring and a fuzzy (fzf inspired) search mode\n  * Enlighten the current search pattern in the matching words\n  * Remove the search mode timeout\n  * Introduce ENTER/ESC as a way to exit search mode\n  * Add the prefix/suffix affinity when searching\n  * Allow to tag/un-tag all the matching words\n  * add a -/ option to affect a search method to the / command\n  * Add 'T' and 'U' commands to tag/un-tag all the matching words\n* Improve the direct access mechanism\n  * [-D] Add a 's' (start) sub-option\n  * [-D] Add a 'h' (head) sub-option\n* Add a \"full window\" option value to -n\n* Improve the test system and add tests\n* Improve the documentation\n* Update the README.rst file and mention the wiki on GitHub\n* Fix an OpenBSD compatibility issue\n* Fix and improve the color mechanism\n* Fix the cursor display after an ESC hit\n* Fix the tag attribute display\n* Fix some compilation warnings\n* Fix a missing message when the terminal is too small\n* Fix a lot of other small and not-so-small bugs\n\n- Version 0.9.13\n* Add the first roll of an automated testing system\n* Fix a FreeBSD compatibility issue\n* Update the .spec file to create a '-test' RPM sub-package\n* [-a] Add a missing setting for cursor_on_tag (ct)\n* [-b] Fix a bug about non-printable characters\n* [-V] Output the version tag on standard output\n* [-D] Add a 'decorate' directive\n* [-D] Handle multiple instances of the same directive\n* Fix a logic error in the direct access code\n* Fix an horizontal scrolling issue when going to the last word\n* Clean up the allocated gutter array before leaving in case of error\n* Understand some more terminfo sequences\n* Fix the right margin and add a degraded method to display it\n* Improve the manual\n* Various other small bug fixes\n\nApr 08 18:32 UTC 2018 - p.gen.progs@gmail.com\n\n- Version 0.9.12\n* Fix the cursor restoration\n* Fix a Solaris incompatibility\n* Fix italic handling\n* Fix the replacement of sub-expressions (-S,-I,-E)\n* Fix a bug in the columns inclusion logic\n* Fix the impossibility to use the letter 't' in search mode\n* Fix possible display errors when the terminal is resized\n* Make sure that the timers does not alter the redrawing of the window\n* Add word numbering to allow direct access through their number (-N,-U,-F,-D)\n* Improve The manual\n* Allow the \\u notation for UTF-8 characters in more places\n* Improve the -T option and add the related -P option\n* Add the -p for use with the -P and -T options\n* The gutter option (-g) now accepts a parameter\n* Adopt the NO_COLOR standard (http://no-color.org)\n* Improve the navigation by understanding more keys and key combinations\n* Understand CTRL+L to redraws the window in case of corruption\n* Exit from search mode when a direction key is hit\n* Adjust some values of timers\n* Remove deprecated directives in -C and -L\n* Various other small fixes and improvements\n\nJan 26 12:35 UTC 2018 - p.gen.progs@gmail.com\n\n- Version 0.9.11\n* Introduce the new \\u notation for UTF-8 hex sequences\n* Non-printable characters with an escape form are expanded\n* Keep non selectable blank words to allow special effects\n* Fix the wide option when in column or tabulation mode\n* The last word is always the last of its line (-g)\n* Improve message (-m) placement in centered mode\n* Manage substitutions leading to empty strings\n* Hopefully fix the placement of the scroll bar in all cases\n* The gutter can now be displayed in column mode\n* Various other small fixes\n\nJul 29 16:30:00 UTC 2017 - p.gen.progs@gmail.com\n\n- Bump to version 0.9.10\n* The words acquisition is rewritten and split in multiple phases\n* Add the capacity to (de)select rows an columns containing regexes\n* -i, -e, -C and -R can be used more than once and have a cumulative effect\n* Bugfix: -s is able to jump to non selectable words\n* Bugfix: The attributes are not overloaded when reading configuration files\n* Bugfix: the right bar is too far right in some cases.\n* Bugfix: the right shift indicator is omitted in some cases\n* Add a -x|-X option to set a timeout in seconds\n* Add a -f option to select an alternative configuration file\n* Add a -a option to set the attributes of the displayed elements\n* Add more controls in the selection parser\n* smenu can now read words directly from a file given as parameter\n* Rewrite the replace function used by -S/-I/-E with a more sed-like one\n* Searches should always consider the visual aspect of words (-S/-I/-E)\n\nThu Dec 22 20:48:17 UTC 2016 - p.gen.progs@gmail.com\n\n- Version 0.9.9\n* New UTF8 validation routine\n* Man page cleanup\n* Code cleanup and improvement\n* Improved configuration process\n* Add code to detect the host system at compile time\n* Compilation is now possible on BSD system derivatives\n* Bug fix: ignore EOF when a scancode contains an escape sequence.\n* Fix the cursor appearance on tagged words\n\nSun Dec 11 20:00:20 UTC 2016 - p.gen.progs@gmail.com\n\n- Version 0.9.8\n* Change the cursor aspect when the selected word is tagged\n* Add a small animated gif demo\n* Fix a potential infinite loop\n* Use custom fgetc/ungetc to be able to safely push back more than one byte\n* Add libtinfo in the searched libraries an regenerate configure\n* Manage conflicts between -C, -R, -c, -l, and -t\n* Improve and fix the help line display\n* Add a -T option to enable a tagging (multi-selections) mode\n* Add the -? option to only display the synopsis\n* Adjust the code so that it can be compiled with an ANSI compiler\n* Put the searched line in the middle of the displayed window if possible\n* Add a -k option to prevent trimming spaces\n* Fix the -s option\n* When not in search mode, any key except '?' should quit the help mode\n* Add a new example: yesno\n* Fix an off-by-one error when using -c and -w together\n* And many other minor changes and fixes\n\n-------------------------------------------------------------------\nSun Mar 13 09:28:52 UTC 2016 - p.gen.progs@gmail.com\n\n- Version 0.9.1\n* Use the GNU autotools\n* Fix a lot of small and not so small bugs\n* Change the -s option semantic\n* Improve help and man page\n* Introduce some new options - see the man page for more\n* Also rework some options - see the man page for more\n* Add more configurable colors\n* Add the notion of non-selectable words\n* Add the notion of special words\n* Add a (de)selection by rows and/or columns\n* Interpret quotations in the input stream and ignore empty words\n* Add an option to center the output window\n* And many other minor changes\n\n-------------------------------------------------------------------\nSun Aug 9 23:00:59 UTC 2015 - p.gen.progs@gmail.com\n\n- Initial version - 0.9\n\n"
        },
        {
          "name": "FAQ",
          "type": "blob",
          "size": 2.8857421875,
          "content": "Q: What is smenu?\n\nA: smenu is a selection tool that acts as a filter that takes 'words'\n   from the standard input or a file and presents them on the screen in\n   various arrangements in a scrolling window.\n\n   A cursor that you can easily move allows you to select one or more\n   of them.\n\n   The selected 'words' are printed on the standard output.\n--------\nQ: Why smenu tells me: \"The length of a 'word' has reached the limit of\n   512 characters.\" but there is no such 'word' in my entry?\n\nA: It is likely that you have an unbalanced single or double quotation\n   mark somewhere. smenu uses quotation marks to be able to have spaces\n   in 'words', and quotation marks that are not used as delimiters must\n   be protected.\n\n   You can use something like: sed -e \"s/'/\\\\\\'/g\" -e 's/\"/\\\\\"/g' to\n   pre-process the input in such a case.\n\n   Another solution is to ask smenu to treat quotation marks as normal\n   characters by using the -Q|-ignore_quotes option.\n--------\nQ: Why does smenu -C... no longer work?\n\nA: smenu uses a new system of options based on the notion of contexts. The\n   -C parameter is only valid in the \"Columns\" context as indicated in the\n   error message.\n\n   The string '[-c|-col|-col_mode|-column>Columns]' that is printed\n   in the error message indicates that to switch to \"Columns\" mode\n   must use the -c parameter or its alternatives.\n\n   In this case the correct command line should contain something like:\n   smenu -c -C...\n--------\nQ: How to preserve the original alignment of the columns?\n\nA: smenu merges multiple occurrences of word delimiters (' ' in the\n   example below) and so the original alignment of columns is lost.\n   One way to limit this loss is to replace the delimiter with a character\n   that does not appear in the input and is not a delimiter, we will use\n   '!' in the example, and tell smenu to replace it with a space with the\n   -S option.\n\n   Example of a session using the free command:\n\n   $ free\n                  total        used        free      shared  buff/cache   available\n   Mem:            23Gi       4,3Gi       1,6Gi       118Mi        18Gi        19Gi\n   Swap:          2,0Gi       0,0Ki       2,0Gi\n\n   $ free -h | smenu -c\n   total used  free  shared buff/cache available\n   Mem:  23Gi  4,3Gi 1,6Gi  118Mi      18Gi      19Gi\n   Swap: 2,0Gi 0,0Ki 2,0Gi\n\n   $ free -h | sed -e 's/ /!/g' -e 's/!\\([^!]\\)/ \\1/g'\n   !!!!!!!!!!!!!! total!!!!!!! used!!!!!!! free!!!!! shared! buff/cache!! available\n   Mem:!!!!!!!!!!! 23Gi!!!!!! 4,3Gi!!!!!! 1,6Gi!!!!!! 120Mi!!!!!!! 18Gi!!!!!!! 19Gi\n   Swap:!!!!!!!!! 2,0Gi!!!!!! 0,0Ki!!!!!! 2,0Gi\n\n   $ free -h | sed -e 's/ /!/g' -e 's/!\\([^!]\\)/ \\1/g' | smenu -c -S'/!/ /g'\n   ############### total        used        free        shared       buff/cache   available\n   Mem:            23Gi         4,3Gi       1,6Gi       118Mi        18Gi         19Gi\n   Swap:           2,0Gi        0,0Ki       2,0Gi\n\n   Where ############### is the smenu cursor.\n"
        },
        {
          "name": "INTERNALS.rst",
          "type": "blob",
          "size": 7.56640625,
          "content": "Some internal notes.\n====================\nFiles.\n------\n\n:``smenu.c``, ``smenu.h``:\n  Main code.\n\n:``list.c``, ``list.h``:\n  Doubly linked list code.\n\n:``xmalloc.c``, ``xmalloc.h``:\n  Custom malloc, realloc,... code.\n\n:``index.c``, ``index.h``:\n  Code used to index words, the implementation uses a data structure called\n  the Ternary Search Tree (TST).\n\n:``utf8.c``, ``utf8.h``:\n  Code used to manage UTF-8 glyphs.\n\n:``fgetc.c``, ``fgetc.h``:\n  Custom ``fgetc`` code.\n\n:``utils.c``, ``utils.h``:\n  Various utility functions.\n\n:``usage.c``, ``usage.h``:\n  Code to display usage messages when necessary.\n\n:``ctxopt.h``, ``ctxopt.c``:\n  Code to manage command line options.\n\n:``safe.h``, ``safe.c``:\n  These files contain wrapper functions for some of the System APIs.\n\n:``tinybuf.h``:\n  Dynamic array code implemented as macros.\n\nWords.\n------\n  To illustrate how words are stored in memory, we will suppose the\n  following input text::\n\n    cute cup at\n      as   he\n    at us\n        i clue\n\n  The main data structures are:\n\n  - An array of words indexed by their order of appearance.\n\n    This is not purely a string array, words are structures which contain the\n    following information:\n\n    - the display string which can be shorter than the original string;\n    - the original string;\n    - various flags to facilitate search, display and accessibility;\n    - positional information: column start, column end end an number of\n      glyphs between the two.\n\n  The input text shown above will be put in the word array as::\n\n                                                     last=1\n                        last=1    last=1    last=1      |\n                           |         |         |        |\n            +------+-----+----+----+----+----+----+---+------+\n    input:  | cute | cup | at | as | he | at | us | i | clue |\n            +------+-----+----+----+----+----+----+---+------°\n    pos:      0      1     2    3    4    5    6    7   8\n\n  - A Ternary Search Tree (TST) which store all these positions in the\n    array more than once, if their appear multiple times.\n\n    Here is a simple representation of the TST containing these words::\n\n          +---- c\n         /      | \\\n        a   +-- u  h -+\n        |  /    |  |   \\\n        t l     t  e    u\n       /  |   / |     / |\n      s   u  p  e    i  s\n          |\n          e\n\n    In the TST tree, a list containing the position of words in the array\n    is attached to each terminal node of the words::\n\n           +---+              +---+\n     cute: | 0 |          he: | 4 |\n           +---+              +---+\n           +---+              +---+\n     cup:  | 1 |          us: | 6 |\n           +---+              +---+\n           +---+---+          +---+\n     at:   | 2 | 5 |      i:  | 7 |\n           +---+---+          +---+\n           +---+              +---+\n     as:   | 3 |        clue: | 8 |\n           +---+              +---+\n\n    This TST is used when searching a word using the ``/`` command or when using\n    the ``-s`` command line option.\n\n.. raw:: pdf\n\n   PageBreak\n\nWindow.\n-------\n  The following diagram illustrates various variables used in the code to\n  display the window::\n\n       first_word_in_line_a array\n                   |\n                   v\n                 +---+------stdin stream---------------+\n                 | 0 |                                 |\n                 |   |                                 |\n                 |   |                                 |\n                 |   |                                 |\n                 |   |                                 |\n                 |   |                                 |\n                 |   | win.first_column                |\n                 |   |    |                            |\n                 |   +----V-win---------+--------------+\n   win.start -------->............... ^ ...............| 1\n    win.offset   |   |............... | ...............| 2 <-- win.cur_line\n   <------------>|   |............... | win.max_lines .| 3\n                 |   |............... | ...............| .\n    current ------------> cursor .... | ...............| .\n                 |   |............... | ...............| .\n                 |   |............... v ...............<------ win.end\n                 |   +------------------+--------------+\n                 |   |                                 |\n                 |   |                                 |\n                 |   |                                 |\n                 |   |                          +------+\n    last_line ------->                          |\n                 +---+-------------------------^+\n                                               |\n                                               |\n                                            count-1\n\nSearching.\n----------\n\n  Input::\n\n    cute cup at\n      as   he\n    at us\n        i clues\n\nPrefix search.\n~~~~~~~~~~~~~~\n\n  This method uses the natural properties of TST for prefix searching to\n  find the position in the array of words.\n\n  Example with the prefix \"at\".\n\n  ::\n\n       +---- c\n      /      | \\\n     a   +-- u  h -+\n     |  /    |  |   \\\n     t l     t  e    u\n    /  |   / |     / |\n   s   u  p  e    i  s\n       |\n       e\n       |\n       s\n\n   cute cup at as he at us i clues\n            --       --\n\nFuzzy search.\n~~~~~~~~~~~~~\n\n  In a fuzzy search, case is irrelevant and the glyphs searched for do\n  not have to be consecutive, as in a substring search.\n\n  Each glyph entered adds a node in a search list.\n\n  The first glyph is searched from the root of the TST.\n\n  Each first child of this glyph's occurrences is added to an array in\n  the node.\n\n  The next glyph entered will be searched for in the sub-TST arrays present\n  in the previous node of the search list, and a new node will be added with\n  an array containing the first children of all its occurrences, if any.\n\n  Example when searching for \"ue\" in the TST ::\n\n       +---- c\n      /      | \\\n     a   +-- u  h -+\n     |  /    |  |   \\\n     t l     t  e    u\n    /  |   / |     / |\n   s   u  p  e    i  s\n       |\n       e\n       |\n       s\n\n  The content of the search_list after having fuzzy searched for \"ue\"::\n\n    u           -> e\n    -              -\n   [0] [1]  [2] : [1] [2]\n    s   e    t  :      s\n        |  / |  :\n        s p  e  :\n   cute cup at as he at us i clues\n    - -                        --\n\n  Another example, fuzzy searching for \"ct\".\n\n  Here is the content of the search_list::\n\n      c  -> t\n      -     -\n     [0] : [0]\n      u  :  e\n      |  :\n      t  :\n    / |  :\n   p  e  :\n\n   cute cup at as he at us i clues\n   - -\n\n  Another example, fuzzy searching for \"cu\".\n\n  Here is the content of the search_list::\n\n      c  -> u\n      -     -\n     [0] : [0] [1]\n      u  :  e   t\n      |  :  |  / |\n      t  :  s p  e\n    / |  :\n   p  e  :\n\n   cute cup at as he at us i clues\n   --   --                   - -\n\n  Another example, fuzzy searching for \"es\".\n\n  Here is the content of the search_list::\n\n    e          -> s\n    -             -\n   [0] [1] [2] : [0]\n    s          :\n\n   cute cup at as he at us i clues\n                                --\n\nSubstring search.\n~~~~~~~~~~~~~~~~~\n\n  This method also uses the search list described above, but only for the\n  first glyph. The aim is to store all sub-TSTs starting with the children\n  of all occurrences of the first glyph in the array in the node of the\n  search list.\n\n  A prefix search of the string without its first glyph is then performed\n  on each of these sub-TSTs.\n\n  Example with \"ue\"::\n\n    u           -> e\n    -              -\n   [0] [1]  [2] : [1]\n    s   e    t  :  e\n        |  / |  :  |\n        s p  e  :  s\n\n   cute cup at as he at us i clues\n                               --\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.333984375,
          "content": "Mozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\n    means each individual or legal entity that creates, contributes to\n    the creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n    means the combination of the Contributions of others (if any) used\n    by a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n    means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n    means Source Code Form to which the initial Contributor has attached\n    the notice in Exhibit A, the Executable Form of such Source Code\n    Form, and Modifications of such Source Code Form, in each case\n    including portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n    means\n\n    (a) that the initial Contributor has attached the notice described\n        in Exhibit B to the Covered Software; or\n\n    (b) that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the\n        terms of a Secondary License.\n\n1.6. \"Executable Form\"\n    means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n    means a work that combines Covered Software with other material, in \n    a separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n    means this document.\n\n1.9. \"Licensable\"\n    means having the right to grant, to the maximum extent possible,\n    whether at the time of the initial grant or subsequently, any and\n    all of the rights conveyed by this License.\n\n1.10. \"Modifications\"\n    means any of the following:\n\n    (a) any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered\n        Software; or\n\n    (b) any new file in Source Code Form that contains any Covered\n        Software.\n\n1.11. \"Patent Claims\" of a Contributor\n    means any patent claim(s), including without limitation, method,\n    process, and apparatus claims, in any patent Licensable by such\n    Contributor that would be infringed, but for the grant of the\n    License, by the making, using, selling, offering for sale, having\n    made, import, or transfer of either its Contributions or its\n    Contributor Version.\n\n1.12. \"Secondary License\"\n    means either the GNU General Public License, Version 2.0, the GNU\n    Lesser General Public License, Version 2.1, the GNU Affero General\n    Public License, Version 3.0, or any later versions of those\n    licenses.\n\n1.13. \"Source Code Form\"\n    means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n    means an individual or a legal entity exercising rights under this\n    License. For legal entities, \"You\" includes any entity that\n    controls, is controlled by, or is under common control with You. For\n    purposes of this definition, \"control\" means (a) the power, direct\n    or indirect, to cause the direction or management of such entity,\n    whether by contract or otherwise, or (b) ownership of more than\n    fifty percent (50%) of the outstanding shares or beneficial\n    ownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\n    Licensable by such Contributor to use, reproduce, make available,\n    modify, display, perform, distribute, and otherwise exploit its\n    Contributions, either on an unmodified basis, with Modifications, or\n    as part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\n    for sale, have made, import, and otherwise transfer either its\n    Contributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\n    or\n\n(b) for infringements caused by: (i) Your and any other third party's\n    modifications of Covered Software, or (ii) the combination of its\n    Contributions with other software (except as part of its Contributor\n    Version); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\n    its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\n    Form, as described in Section 3.1, and You must inform recipients of\n    the Executable Form how they can obtain a copy of such Source Code\n    Form by reasonable means in a timely manner, at a charge no more\n    than the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\n    License, or sublicense it under different terms, provided that the\n    license for the Executable Form does not attempt to limit or alter\n    the recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n*                                                                      *\n*  6. Disclaimer of Warranty                                           *\n*  -------------------------                                           *\n*                                                                      *\n*  Covered Software is provided under this License on an \"as is\"       *\n*  basis, without warranty of any kind, either expressed, implied, or  *\n*  statutory, including, without limitation, warranties that the       *\n*  Covered Software is free of defects, merchantable, fit for a        *\n*  particular purpose or non-infringing. The entire risk as to the     *\n*  quality and performance of the Covered Software is with You.        *\n*  Should any Covered Software prove defective in any respect, You     *\n*  (not any Contributor) assume the cost of any necessary servicing,   *\n*  repair, or correction. This disclaimer of warranty constitutes an   *\n*  essential part of this License. No use of any Covered Software is   *\n*  authorized under this License except under this disclaimer.         *\n*                                                                      *\n************************************************************************\n\n************************************************************************\n*                                                                      *\n*  7. Limitation of Liability                                          *\n*  --------------------------                                          *\n*                                                                      *\n*  Under no circumstances and under no legal theory, whether tort      *\n*  (including negligence), contract, or otherwise, shall any           *\n*  Contributor, or anyone who distributes Covered Software as          *\n*  permitted above, be liable to You for any direct, indirect,         *\n*  special, incidental, or consequential damages of any character      *\n*  including, without limitation, damages for lost profits, loss of    *\n*  goodwill, work stoppage, computer failure or malfunction, or any    *\n*  and all other commercial damages or losses, even if such party      *\n*  shall have been informed of the possibility of such damages. This   *\n*  limitation of liability shall not apply to liability for death or   *\n*  personal injury resulting from such party's negligence to the       *\n*  extent applicable law prohibits such limitation. Some               *\n*  jurisdictions do not allow the exclusion or limitation of           *\n*  incidental or consequential damages, so this exclusion and          *\n*  limitation may not apply to You.                                    *\n*                                                                      *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\n  This Source Code Form is \"Incompatible With Secondary Licenses\", as\n  defined by the Mozilla Public License, v. 2.0.\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 0.8076171875,
          "content": "bin_PROGRAMS = smenu\nsmenu_SOURCES = smenu.c smenu.h list.c list.h xmalloc.c xmalloc.h \\\n\t\tindex.c index.h utf8.c utf8.h fgetc.c fgetc.h     \\\n\t\tutils.c utils.h usage.c usage.h ctxopt.h ctxopt.c \\\n\t\tsafe.h safe.c tinybuf.h\ndist_man_MANS = smenu.1\nEXTRA_DIST =\tChangeLog build.sh version COPYRIGHT LICENSE README.rst \\\n\t\texamples build-aux tests FAQ\n\ndist-hook:\n\t@chmod u+rw $(distdir)/tests;              \\\n\tcd $(distdir)/tests ;                      \\\n\tfind * -name 'data*' -o                    \\\n\t       -name '*.in'  -o                    \\\n\t       -name '*.tst' -o                    \\\n\t       -name '*.bl'  -o                    \\\n\t       -name '*.good'                      \\\n\t| cpio -o > tests.cpio 2>/dev/null\n\t@gzip -f9 $(distdir)/tests/tests.cpio\n\t@find $(distdir)/tests/* -type d           \\\n\t\t\t\t -exec rm -rf {} +\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 30.2236328125,
          "content": "# Makefile.in generated by automake 1.17 from Makefile.am.\n# @configure_input@\n\n# Copyright (C) 1994-2024 Free Software Foundation, Inc.\n\n# This Makefile.in is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\n@SET_MAKE@\n\nVPATH = @srcdir@\nam__is_gnu_make = { \\\n  if test -z '$(MAKELEVEL)'; then \\\n    false; \\\n  elif test -n '$(MAKE_HOST)'; then \\\n    true; \\\n  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n    true; \\\n  else \\\n    false; \\\n  fi; \\\n}\nam__make_running_with_option = \\\n  case $${target_option-} in \\\n      ?) ;; \\\n      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n              \"target option '$${target_option-}' specified\" >&2; \\\n         exit 1;; \\\n  esac; \\\n  has_opt=no; \\\n  sane_makeflags=$$MAKEFLAGS; \\\n  if $(am__is_gnu_make); then \\\n    sane_makeflags=$$MFLAGS; \\\n  else \\\n    case $$MAKEFLAGS in \\\n      *\\\\[\\ \\\t]*) \\\n        bs=\\\\; \\\n        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n    esac; \\\n  fi; \\\n  skip_next=no; \\\n  strip_trailopt () \\\n  { \\\n    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n  }; \\\n  for flg in $$sane_makeflags; do \\\n    test $$skip_next = yes && { skip_next=no; continue; }; \\\n    case $$flg in \\\n      *=*|--*) continue;; \\\n        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n      -*I?*) strip_trailopt 'I';; \\\n        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n      -*O?*) strip_trailopt 'O';; \\\n        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n      -*l?*) strip_trailopt 'l';; \\\n      -[dEDm]) skip_next=yes;; \\\n      -[JT]) skip_next=yes;; \\\n    esac; \\\n    case $$flg in \\\n      *$$target_option*) has_opt=yes; break;; \\\n    esac; \\\n  done; \\\n  test $$has_opt = yes\nam__make_dryrun = (target_option=n; $(am__make_running_with_option))\nam__make_keepgoing = (target_option=k; $(am__make_running_with_option))\nam__rm_f = rm -f $(am__rm_f_notfound)\nam__rm_rf = rm -rf $(am__rm_f_notfound)\npkgdatadir = $(datadir)/@PACKAGE@\npkgincludedir = $(includedir)/@PACKAGE@\npkglibdir = $(libdir)/@PACKAGE@\npkglibexecdir = $(libexecdir)/@PACKAGE@\nam__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\ninstall_sh_DATA = $(install_sh) -c -m 644\ninstall_sh_PROGRAM = $(install_sh) -c\ninstall_sh_SCRIPT = $(install_sh) -c\nINSTALL_HEADER = $(INSTALL_DATA)\ntransform = $(program_transform_name)\nNORMAL_INSTALL = :\nPRE_INSTALL = :\nPOST_INSTALL = :\nNORMAL_UNINSTALL = :\nPRE_UNINSTALL = :\nPOST_UNINSTALL = :\nbuild_triplet = @build@\nhost_triplet = @host@\nbin_PROGRAMS = smenu$(EXEEXT)\nsubdir = .\nACLOCAL_M4 = $(top_srcdir)/aclocal.m4\nam__aclocal_m4_deps = $(top_srcdir)/configure.ac\nam__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n\t$(ACLOCAL_M4)\nDIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n\t$(am__configure_deps) $(am__DIST_COMMON)\nam__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n configure.lineno config.status.lineno\nmkinstalldirs = $(install_sh) -d\nCONFIG_HEADER = config.h\nCONFIG_CLEAN_FILES =\nCONFIG_CLEAN_VPATH_FILES =\nam__installdirs = \"$(DESTDIR)$(bindir)\" \"$(DESTDIR)$(man1dir)\"\nPROGRAMS = $(bin_PROGRAMS)\nam_smenu_OBJECTS = smenu.$(OBJEXT) list.$(OBJEXT) xmalloc.$(OBJEXT) \\\n\tindex.$(OBJEXT) utf8.$(OBJEXT) fgetc.$(OBJEXT) utils.$(OBJEXT) \\\n\tusage.$(OBJEXT) ctxopt.$(OBJEXT) safe.$(OBJEXT)\nsmenu_OBJECTS = $(am_smenu_OBJECTS)\nsmenu_LDADD = $(LDADD)\nAM_V_P = $(am__v_P_@AM_V@)\nam__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\nam__v_P_0 = false\nam__v_P_1 = :\nAM_V_GEN = $(am__v_GEN_@AM_V@)\nam__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\nam__v_GEN_0 = @echo \"  GEN     \" $@;\nam__v_GEN_1 = \nAM_V_at = $(am__v_at_@AM_V@)\nam__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\nam__v_at_0 = @\nam__v_at_1 = \nDEFAULT_INCLUDES = -I.@am__isrc@\ndepcomp = $(SHELL) $(top_srcdir)/build-aux/depcomp\nam__maybe_remake_depfiles = depfiles\nam__depfiles_remade = ./$(DEPDIR)/ctxopt.Po ./$(DEPDIR)/fgetc.Po \\\n\t./$(DEPDIR)/index.Po ./$(DEPDIR)/list.Po ./$(DEPDIR)/safe.Po \\\n\t./$(DEPDIR)/smenu.Po ./$(DEPDIR)/usage.Po ./$(DEPDIR)/utf8.Po \\\n\t./$(DEPDIR)/utils.Po ./$(DEPDIR)/xmalloc.Po\nam__mv = mv -f\nCOMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\nAM_V_CC = $(am__v_CC_@AM_V@)\nam__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\nam__v_CC_0 = @echo \"  CC      \" $@;\nam__v_CC_1 = \nCCLD = $(CC)\nLINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\nAM_V_CCLD = $(am__v_CCLD_@AM_V@)\nam__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\nam__v_CCLD_0 = @echo \"  CCLD    \" $@;\nam__v_CCLD_1 = \nSOURCES = $(smenu_SOURCES)\nDIST_SOURCES = $(smenu_SOURCES)\nam__can_run_installinfo = \\\n  case $$AM_UPDATE_INFO_DIR in \\\n    n|no|NO) false;; \\\n    *) (install-info --version) >/dev/null 2>&1;; \\\n  esac\nam__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\nam__vpath_adj = case $$p in \\\n    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n    *) f=$$p;; \\\n  esac;\nam__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\nam__install_max = 40\nam__nobase_strip_setup = \\\n  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\nam__nobase_strip = \\\n  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\nam__nobase_list = $(am__nobase_strip_setup); \\\n  for p in $$list; do echo \"$$p $$p\"; done | \\\n  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n    if (++n[$$2] == $(am__install_max)) \\\n      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n    END { for (dir in files) print dir, files[dir] }'\nam__base_list = \\\n  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\nam__uninstall_files_from_dir = { \\\n  { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n  || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n       $(am__cd) \"$$dir\" && echo $$files | $(am__xargs_n) 40 $(am__rm_f); }; \\\n  }\nman1dir = $(mandir)/man1\nNROFF = nroff\nMANS = $(dist_man_MANS)\nam__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP) \\\n\tconfig.h.in\n# Read a list of newline-separated strings from the standard input,\n# and print each of them once, without duplicates.  Input order is\n# *not* preserved.\nam__uniquify_input = $(AWK) '\\\n  BEGIN { nonempty = 0; } \\\n  { items[$$0] = 1; nonempty = 1; } \\\n  END { if (nonempty) { for (i in items) print i; }; } \\\n'\n# Make sure the list of sources is unique.  This is necessary because,\n# e.g., the same source file might be shared among _SOURCES variables\n# for different programs/libraries.\nam__define_uniq_tagged_files = \\\n  list='$(am__tagged_files)'; \\\n  unique=`for i in $$list; do \\\n    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n  done | $(am__uniquify_input)`\nAM_RECURSIVE_TARGETS = cscope\nam__DIST_COMMON = $(dist_man_MANS) $(srcdir)/Makefile.in \\\n\t$(srcdir)/config.h.in $(top_srcdir)/build-aux/compile \\\n\t$(top_srcdir)/build-aux/config.guess \\\n\t$(top_srcdir)/build-aux/config.sub \\\n\t$(top_srcdir)/build-aux/depcomp \\\n\t$(top_srcdir)/build-aux/install-sh \\\n\t$(top_srcdir)/build-aux/missing ChangeLog TODO \\\n\tbuild-aux/compile build-aux/config.guess build-aux/config.sub \\\n\tbuild-aux/depcomp build-aux/install-sh build-aux/missing\nDISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\ndistdir = $(PACKAGE)-$(VERSION)\ntop_distdir = $(distdir)\nam__remove_distdir = \\\n  if test -d \"$(distdir)\"; then \\\n    find \"$(distdir)\" -type d ! -perm -700 -exec chmod u+rwx {} ';' \\\n      ; rm -rf \"$(distdir)\" \\\n      || { sleep 5 && rm -rf \"$(distdir)\"; }; \\\n  else :; fi\nam__post_remove_distdir = $(am__remove_distdir)\nGZIP_ENV = -9\nDIST_ARCHIVES = $(distdir).tar.bz2\nDIST_TARGETS = dist-bzip2\n# Exists only to be overridden by the user if desired.\nAM_DISTCHECK_DVI_TARGET = dvi\ndistuninstallcheck_listfiles = find . -type f -print\nam__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \\\n  | sed 's|^\\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'\ndistcleancheck_listfiles = \\\n  find . \\( -type f -a \\! \\\n            \\( -name .nfs* -o -name .smb* -o -name .__afs* \\) \\) -print\nACLOCAL = @ACLOCAL@\nAMTAR = @AMTAR@\nAM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\nAUTOCONF = @AUTOCONF@\nAUTOHEADER = @AUTOHEADER@\nAUTOMAKE = @AUTOMAKE@\nAWK = @AWK@\nCC = @CC@\nCCDEPMODE = @CCDEPMODE@\nCFLAGS = @CFLAGS@\nCPPFLAGS = @CPPFLAGS@\nCSCOPE = @CSCOPE@\nCTAGS = @CTAGS@\nCYGPATH_W = @CYGPATH_W@\nDEFS = @DEFS@\nDEPDIR = @DEPDIR@\nECHO_C = @ECHO_C@\nECHO_N = @ECHO_N@\nECHO_T = @ECHO_T@\nEGREP = @EGREP@\nETAGS = @ETAGS@\nEXEEXT = @EXEEXT@\nGREP = @GREP@\nINSTALL = @INSTALL@\nINSTALL_DATA = @INSTALL_DATA@\nINSTALL_PROGRAM = @INSTALL_PROGRAM@\nINSTALL_SCRIPT = @INSTALL_SCRIPT@\nINSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\nLDFLAGS = @LDFLAGS@\nLIBOBJS = @LIBOBJS@\nLIBS = @LIBS@\nLN_S = @LN_S@\nLTLIBOBJS = @LTLIBOBJS@\nMAKEINFO = @MAKEINFO@\nMKDIR_P = @MKDIR_P@\nOBJEXT = @OBJEXT@\nPACKAGE = @PACKAGE@\nPACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\nPACKAGE_NAME = @PACKAGE_NAME@\nPACKAGE_STRING = @PACKAGE_STRING@\nPACKAGE_TARNAME = @PACKAGE_TARNAME@\nPACKAGE_URL = @PACKAGE_URL@\nPACKAGE_VERSION = @PACKAGE_VERSION@\nPATH_SEPARATOR = @PATH_SEPARATOR@\nSET_MAKE = @SET_MAKE@\nSHELL = @SHELL@\nSTRIP = @STRIP@\nVERSION = @VERSION@\nabs_builddir = @abs_builddir@\nabs_srcdir = @abs_srcdir@\nabs_top_builddir = @abs_top_builddir@\nabs_top_srcdir = @abs_top_srcdir@\nac_ct_CC = @ac_ct_CC@\nam__include = @am__include@\nam__leading_dot = @am__leading_dot@\nam__quote = @am__quote@\nam__rm_f_notfound = @am__rm_f_notfound@\nam__tar = @am__tar@\nam__untar = @am__untar@\nam__xargs_n = @am__xargs_n@\nbindir = @bindir@\nbuild = @build@\nbuild_alias = @build_alias@\nbuild_cpu = @build_cpu@\nbuild_os = @build_os@\nbuild_vendor = @build_vendor@\nbuilddir = @builddir@\ndatadir = @datadir@\ndatarootdir = @datarootdir@\ndocdir = @docdir@\ndvidir = @dvidir@\nexec_prefix = @exec_prefix@\nhost = @host@\nhost_alias = @host_alias@\nhost_cpu = @host_cpu@\nhost_os = @host_os@\nhost_vendor = @host_vendor@\nhtmldir = @htmldir@\nincludedir = @includedir@\ninfodir = @infodir@\ninstall_sh = @install_sh@\nlibdir = @libdir@\nlibexecdir = @libexecdir@\nlocaledir = @localedir@\nlocalstatedir = @localstatedir@\nmandir = @mandir@\nmkdir_p = @mkdir_p@\noldincludedir = @oldincludedir@\npdfdir = @pdfdir@\nprefix = @prefix@\nprogram_transform_name = @program_transform_name@\npsdir = @psdir@\nrunstatedir = @runstatedir@\nsbindir = @sbindir@\nsharedstatedir = @sharedstatedir@\nsrcdir = @srcdir@\nsysconfdir = @sysconfdir@\ntarget_alias = @target_alias@\ntop_build_prefix = @top_build_prefix@\ntop_builddir = @top_builddir@\ntop_srcdir = @top_srcdir@\nsmenu_SOURCES = smenu.c smenu.h list.c list.h xmalloc.c xmalloc.h \\\n\t\tindex.c index.h utf8.c utf8.h fgetc.c fgetc.h     \\\n\t\tutils.c utils.h usage.c usage.h ctxopt.h ctxopt.c \\\n\t\tsafe.h safe.c tinybuf.h\n\ndist_man_MANS = smenu.1\nEXTRA_DIST = ChangeLog build.sh version COPYRIGHT LICENSE README.rst \\\n\t\texamples build-aux tests FAQ\n\nall: config.h\n\t$(MAKE) $(AM_MAKEFLAGS) all-am\n\n.SUFFIXES:\n.SUFFIXES: .c .o .obj\nam--refresh: Makefile\n\t@:\n$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n\t@for dep in $?; do \\\n\t  case '$(am__configure_deps)' in \\\n\t    *$$dep*) \\\n\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n\t\t&& exit 0; \\\n\t      exit 1;; \\\n\t  esac; \\\n\tdone; \\\n\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n\t$(am__cd) $(top_srcdir) && \\\n\t  $(AUTOMAKE) --foreign Makefile\nMakefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n\t@case '$?' in \\\n\t  *config.status*) \\\n\t    echo ' $(SHELL) ./config.status'; \\\n\t    $(SHELL) ./config.status;; \\\n\t  *) \\\n\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles)'; \\\n\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles);; \\\n\tesac;\n\n$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n\t$(SHELL) ./config.status --recheck\n\n$(top_srcdir)/configure:  $(am__configure_deps)\n\t$(am__cd) $(srcdir) && $(AUTOCONF)\n$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n$(am__aclocal_m4_deps):\n\nconfig.h: stamp-h1\n\t@test -f $@ || rm -f stamp-h1\n\t@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1\n\nstamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n\t$(AM_V_at)rm -f stamp-h1\n\t$(AM_V_GEN)cd $(top_builddir) && $(SHELL) ./config.status config.h\n$(srcdir)/config.h.in:  $(am__configure_deps) \n\t$(AM_V_GEN)($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n\t$(AM_V_at)rm -f stamp-h1\n\t$(AM_V_at)touch $@\n\ndistclean-hdr:\n\t-rm -f config.h stamp-h1\ninstall-binPROGRAMS: $(bin_PROGRAMS)\n\t@$(NORMAL_INSTALL)\n\t@list='$(bin_PROGRAMS)'; test -n \"$(bindir)\" || list=; \\\n\tif test -n \"$$list\"; then \\\n\t  echo \" $(MKDIR_P) '$(DESTDIR)$(bindir)'\"; \\\n\t  $(MKDIR_P) \"$(DESTDIR)$(bindir)\" || exit 1; \\\n\tfi; \\\n\tfor p in $$list; do echo \"$$p $$p\"; done | \\\n\tsed 's/$(EXEEXT)$$//' | \\\n\twhile read p p1; do if test -f $$p \\\n\t  ; then echo \"$$p\"; echo \"$$p\"; else :; fi; \\\n\tdone | \\\n\tsed -e 'p;s,.*/,,;n;h' \\\n\t    -e 's|.*|.|' \\\n\t    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \\\n\tsed 'N;N;N;s,\\n, ,g' | \\\n\t$(AWK) 'BEGIN { files[\".\"] = \"\"; dirs[\".\"] = 1 } \\\n\t  { d=$$3; if (dirs[d] != 1) { print \"d\", d; dirs[d] = 1 } \\\n\t    if ($$2 == $$4) files[d] = files[d] \" \" $$1; \\\n\t    else { print \"f\", $$3 \"/\" $$4, $$1; } } \\\n\t  END { for (d in files) print \"f\", d, files[d] }' | \\\n\twhile read type dir files; do \\\n\t    if test \"$$dir\" = .; then dir=; else dir=/$$dir; fi; \\\n\t    test -z \"$$files\" || { \\\n\t      echo \" $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'\"; \\\n\t      $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files \"$(DESTDIR)$(bindir)$$dir\" || exit $$?; \\\n\t    } \\\n\t; done\n\nuninstall-binPROGRAMS:\n\t@$(NORMAL_UNINSTALL)\n\t@list='$(bin_PROGRAMS)'; test -n \"$(bindir)\" || list=; \\\n\tfiles=`for p in $$list; do echo \"$$p\"; done | \\\n\t  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \\\n\t      -e 's/$$/$(EXEEXT)/' \\\n\t`; \\\n\ttest -n \"$$list\" || exit 0; \\\n\techo \" ( cd '$(DESTDIR)$(bindir)' && rm -f\" $$files \")\"; \\\n\tcd \"$(DESTDIR)$(bindir)\" && $(am__rm_f) $$files\n\nclean-binPROGRAMS:\n\t-$(am__rm_f) $(bin_PROGRAMS)\n\nsmenu$(EXEEXT): $(smenu_OBJECTS) $(smenu_DEPENDENCIES) $(EXTRA_smenu_DEPENDENCIES) \n\t@rm -f smenu$(EXEEXT)\n\t$(AM_V_CCLD)$(LINK) $(smenu_OBJECTS) $(smenu_LDADD) $(LIBS)\n\nmostlyclean-compile:\n\t-rm -f *.$(OBJEXT)\n\ndistclean-compile:\n\t-rm -f *.tab.c\n\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctxopt.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fgetc.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/index.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/list.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/safe.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smenu.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/usage.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utf8.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils.Po@am__quote@ # am--include-marker\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xmalloc.Po@am__quote@ # am--include-marker\n\n$(am__depfiles_remade):\n\t@$(MKDIR_P) $(@D)\n\t@: >>$@\n\nam--depfiles: $(am__depfiles_remade)\n\n.c.o:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<\n\n.c.obj:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\ninstall-man1: $(dist_man_MANS)\n\t@$(NORMAL_INSTALL)\n\t@list1=''; \\\n\tlist2='$(dist_man_MANS)'; \\\n\ttest -n \"$(man1dir)\" \\\n\t  && test -n \"`echo $$list1$$list2`\" \\\n\t  || exit 0; \\\n\techo \" $(MKDIR_P) '$(DESTDIR)$(man1dir)'\"; \\\n\t$(MKDIR_P) \"$(DESTDIR)$(man1dir)\" || exit 1; \\\n\t{ for i in $$list1; do echo \"$$i\"; done;  \\\n\tif test -n \"$$list2\"; then \\\n\t  for i in $$list2; do echo \"$$i\"; done \\\n\t    | sed -n '/\\.1[a-z]*$$/p'; \\\n\tfi; \\\n\t} | while read p; do \\\n\t  if test -f $$p; then d=; else d=\"$(srcdir)/\"; fi; \\\n\t  echo \"$$d$$p\"; echo \"$$p\"; \\\n\tdone | \\\n\tsed -e 'n;s,.*/,,;p;h;s,.*\\.,,;s,^[^1][0-9a-z]*$$,1,;x' \\\n\t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,' | \\\n\tsed 'N;N;s,\\n, ,g' | { \\\n\tlist=; while read file base inst; do \\\n\t  if test \"$$base\" = \"$$inst\"; then list=\"$$list $$file\"; else \\\n\t    echo \" $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man1dir)/$$inst'\"; \\\n\t    $(INSTALL_DATA) \"$$file\" \"$(DESTDIR)$(man1dir)/$$inst\" || exit $$?; \\\n\t  fi; \\\n\tdone; \\\n\tfor i in $$list; do echo \"$$i\"; done | $(am__base_list) | \\\n\twhile read files; do \\\n\t  test -z \"$$files\" || { \\\n\t    echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(man1dir)'\"; \\\n\t    $(INSTALL_DATA) $$files \"$(DESTDIR)$(man1dir)\" || exit $$?; }; \\\n\tdone; }\n\nuninstall-man1:\n\t@$(NORMAL_UNINSTALL)\n\t@list=''; test -n \"$(man1dir)\" || exit 0; \\\n\tfiles=`{ for i in $$list; do echo \"$$i\"; done; \\\n\tl2='$(dist_man_MANS)'; for i in $$l2; do echo \"$$i\"; done | \\\n\t  sed -n '/\\.1[a-z]*$$/p'; \\\n\t} | sed -e 's,.*/,,;h;s,.*\\.,,;s,^[^1][0-9a-z]*$$,1,;x' \\\n\t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,'`; \\\n\tdir='$(DESTDIR)$(man1dir)'; $(am__uninstall_files_from_dir)\n\nID: $(am__tagged_files)\n\t$(am__define_uniq_tagged_files); mkid -fID $$unique\ntags: tags-am\nTAGS: tags\n\ntags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n\tset x; \\\n\there=`pwd`; \\\n\t$(am__define_uniq_tagged_files); \\\n\tshift; \\\n\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n\t  if test $$# -gt 0; then \\\n\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n\t      \"$$@\" $$unique; \\\n\t  else \\\n\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n\t      $$unique; \\\n\t  fi; \\\n\tfi\nctags: ctags-am\n\nCTAGS: ctags\nctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n\t$(am__define_uniq_tagged_files); \\\n\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n\t     $$unique\n\nGTAGS:\n\there=`$(am__cd) $(top_builddir) && pwd` \\\n\t  && $(am__cd) $(top_srcdir) \\\n\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\ncscope: cscope.files\n\ttest ! -s cscope.files \\\n\t  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)\nclean-cscope:\n\t-rm -f cscope.files\ncscope.files: clean-cscope cscopelist\ncscopelist: cscopelist-am\n\ncscopelist-am: $(am__tagged_files)\n\tlist='$(am__tagged_files)'; \\\n\tcase \"$(srcdir)\" in \\\n\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n\tesac; \\\n\tfor i in $$list; do \\\n\t  if test -f \"$$i\"; then \\\n\t    echo \"$(subdir)/$$i\"; \\\n\t  else \\\n\t    echo \"$$sdir/$$i\"; \\\n\t  fi; \\\n\tdone >> $(top_builddir)/cscope.files\n\ndistclean-tags:\n\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n\t-rm -f cscope.out cscope.in.out cscope.po.out cscope.files\ndistdir: $(BUILT_SOURCES)\n\t$(MAKE) $(AM_MAKEFLAGS) distdir-am\n\ndistdir-am: $(DISTFILES)\n\t$(am__remove_distdir)\n\t$(AM_V_at)$(MKDIR_P) \"$(distdir)\"\n\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n\tlist='$(DISTFILES)'; \\\n\t  dist_files=`for file in $$list; do echo $$file; done | \\\n\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n\tcase $$dist_files in \\\n\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n\t\t\t   sort -u` ;; \\\n\tesac; \\\n\tfor file in $$dist_files; do \\\n\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n\t  if test -d $$d/$$file; then \\\n\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n\t    if test -d \"$(distdir)/$$file\"; then \\\n\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n\t    fi; \\\n\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n\t    fi; \\\n\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n\t  else \\\n\t    test -f \"$(distdir)/$$file\" \\\n\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n\t    || exit 1; \\\n\t  fi; \\\n\tdone\n\t$(MAKE) $(AM_MAKEFLAGS) \\\n\t  top_distdir=\"$(top_distdir)\" distdir=\"$(distdir)\" \\\n\t  dist-hook\n\t-test -n \"$(am__skip_mode_fix)\" \\\n\t|| find \"$(distdir)\" -type d ! -perm -755 \\\n\t\t-exec chmod u+rwx,go+rx {} \\; -o \\\n\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n\t  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \\; \\\n\t|| chmod -R a+r \"$(distdir)\"\ndist-gzip: distdir\n\ttardir=$(distdir) && $(am__tar) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).tar.gz\n\t$(am__post_remove_distdir)\ndist-bzip2: distdir\n\ttardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2\n\t$(am__post_remove_distdir)\n\ndist-lzip: distdir\n\ttardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz\n\t$(am__post_remove_distdir)\n\ndist-xz: distdir\n\ttardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz\n\t$(am__post_remove_distdir)\n\ndist-zstd: distdir\n\ttardir=$(distdir) && $(am__tar) | zstd -c $${ZSTD_CLEVEL-$${ZSTD_OPT--19}} >$(distdir).tar.zst\n\t$(am__post_remove_distdir)\n\ndist-tarZ: distdir\n\t@echo WARNING: \"Support for distribution archives compressed with\" \\\n\t\t       \"legacy program 'compress' is deprecated.\" >&2\n\t@echo WARNING: \"It will be removed altogether in Automake 2.0\" >&2\n\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n\t$(am__post_remove_distdir)\n\ndist-shar: distdir\n\t@echo WARNING: \"Support for shar distribution archives is\" \\\n\t               \"deprecated.\" >&2\n\t@echo WARNING: \"It will be removed altogether in Automake 2.0\" >&2\n\tshar $(distdir) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).shar.gz\n\t$(am__post_remove_distdir)\n\ndist-zip: distdir\n\t-rm -f $(distdir).zip\n\tzip -rq $(distdir).zip $(distdir)\n\t$(am__post_remove_distdir)\n\ndist dist-all:\n\t$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'\n\t$(am__post_remove_distdir)\n\n# This target untars the dist file and tries a VPATH configuration.  Then\n# it guarantees that the distribution is self-contained by making another\n# tarfile.\ndistcheck: dist\n\tcase '$(DIST_ARCHIVES)' in \\\n\t*.tar.gz*) \\\n\t  eval GZIP= gzip -dc $(distdir).tar.gz | $(am__untar) ;;\\\n\t*.tar.bz2*) \\\n\t  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\\\n\t*.tar.lz*) \\\n\t  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\\\n\t*.tar.xz*) \\\n\t  xz -dc $(distdir).tar.xz | $(am__untar) ;;\\\n\t*.tar.Z*) \\\n\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n\t*.shar.gz*) \\\n\t  eval GZIP= gzip -dc $(distdir).shar.gz | unshar ;;\\\n\t*.zip*) \\\n\t  unzip $(distdir).zip ;;\\\n\t*.tar.zst*) \\\n\t  zstd -dc $(distdir).tar.zst | $(am__untar) ;;\\\n\tesac\n\tchmod -R a-w $(distdir)\n\tchmod u+w $(distdir)\n\tmkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst\n\tchmod a-w $(distdir)\n\ttest -d $(distdir)/_build || exit 0; \\\n\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n\t  && am__cwd=`pwd` \\\n\t  && $(am__cd) $(distdir)/_build/sub \\\n\t  && ../../configure \\\n\t    $(AM_DISTCHECK_CONFIGURE_FLAGS) \\\n\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n\t    --srcdir=../.. --prefix=\"$$dc_install_base\" \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) $(AM_DISTCHECK_DVI_TARGET) \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n\t        distuninstallcheck \\\n\t  && chmod -R a-w \"$$dc_install_base\" \\\n\t  && ({ \\\n\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n\t  && rm -rf \"$$dc_destdir\" \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n\t  && rm -rf $(DIST_ARCHIVES) \\\n\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \\\n\t  && cd \"$$am__cwd\" \\\n\t  || exit 1\n\t$(am__post_remove_distdir)\n\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n\t  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'\ndistuninstallcheck:\n\t@test -n '$(distuninstallcheck_dir)' || { \\\n\t  echo 'ERROR: trying to run $@ with an empty' \\\n\t       '$$(distuninstallcheck_dir)' >&2; \\\n\t  exit 1; \\\n\t}; \\\n\t$(am__cd) '$(distuninstallcheck_dir)' || { \\\n\t  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \\\n\t  exit 1; \\\n\t}; \\\n\ttest `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \\\n\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n\t        if test -n \"$(DESTDIR)\"; then \\\n\t          echo \"  (check DESTDIR support)\"; \\\n\t        fi ; \\\n\t        $(distuninstallcheck_listfiles) ; \\\n\t        exit 1; } >&2\ndistcleancheck: distclean\n\t@if test '$(srcdir)' = . ; then \\\n\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n\t  exit 1 ; \\\n\tfi\n\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n\t       $(distcleancheck_listfiles) ; \\\n\t       exit 1; } >&2\ncheck-am: all-am\ncheck: check-am\nall-am: Makefile $(PROGRAMS) $(MANS) config.h\ninstalldirs:\n\tfor dir in \"$(DESTDIR)$(bindir)\" \"$(DESTDIR)$(man1dir)\"; do \\\n\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n\tdone\ninstall: install-am\ninstall-exec: install-exec-am\ninstall-data: install-data-am\nuninstall: uninstall-am\n\ninstall-am: all-am\n\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n\ninstallcheck: installcheck-am\ninstall-strip:\n\tif test -z '$(STRIP)'; then \\\n\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n\t      install; \\\n\telse \\\n\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n\tfi\nmostlyclean-generic:\n\nclean-generic:\n\ndistclean-generic:\n\t-$(am__rm_f) $(CONFIG_CLEAN_FILES)\n\t-test . = \"$(srcdir)\" || $(am__rm_f) $(CONFIG_CLEAN_VPATH_FILES)\n\nmaintainer-clean-generic:\n\t@echo \"This command is intended for maintainers to use\"\n\t@echo \"it deletes files that may require special tools to rebuild.\"\nclean: clean-am\n\nclean-am: clean-binPROGRAMS clean-generic mostlyclean-am\n\ndistclean: distclean-am\n\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n\t-rm -f ./$(DEPDIR)/ctxopt.Po\n\t-rm -f ./$(DEPDIR)/fgetc.Po\n\t-rm -f ./$(DEPDIR)/index.Po\n\t-rm -f ./$(DEPDIR)/list.Po\n\t-rm -f ./$(DEPDIR)/safe.Po\n\t-rm -f ./$(DEPDIR)/smenu.Po\n\t-rm -f ./$(DEPDIR)/usage.Po\n\t-rm -f ./$(DEPDIR)/utf8.Po\n\t-rm -f ./$(DEPDIR)/utils.Po\n\t-rm -f ./$(DEPDIR)/xmalloc.Po\n\t-rm -f Makefile\ndistclean-am: clean-am distclean-compile distclean-generic \\\n\tdistclean-hdr distclean-tags\n\ndvi: dvi-am\n\ndvi-am:\n\nhtml: html-am\n\nhtml-am:\n\ninfo: info-am\n\ninfo-am:\n\ninstall-data-am: install-man\n\ninstall-dvi: install-dvi-am\n\ninstall-dvi-am:\n\ninstall-exec-am: install-binPROGRAMS\n\ninstall-html: install-html-am\n\ninstall-html-am:\n\ninstall-info: install-info-am\n\ninstall-info-am:\n\ninstall-man: install-man1\n\ninstall-pdf: install-pdf-am\n\ninstall-pdf-am:\n\ninstall-ps: install-ps-am\n\ninstall-ps-am:\n\ninstallcheck-am:\n\nmaintainer-clean: maintainer-clean-am\n\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n\t-rm -rf $(top_srcdir)/autom4te.cache\n\t-rm -f ./$(DEPDIR)/ctxopt.Po\n\t-rm -f ./$(DEPDIR)/fgetc.Po\n\t-rm -f ./$(DEPDIR)/index.Po\n\t-rm -f ./$(DEPDIR)/list.Po\n\t-rm -f ./$(DEPDIR)/safe.Po\n\t-rm -f ./$(DEPDIR)/smenu.Po\n\t-rm -f ./$(DEPDIR)/usage.Po\n\t-rm -f ./$(DEPDIR)/utf8.Po\n\t-rm -f ./$(DEPDIR)/utils.Po\n\t-rm -f ./$(DEPDIR)/xmalloc.Po\n\t-rm -f Makefile\nmaintainer-clean-am: distclean-am maintainer-clean-generic\n\nmostlyclean: mostlyclean-am\n\nmostlyclean-am: mostlyclean-compile mostlyclean-generic\n\npdf: pdf-am\n\npdf-am:\n\nps: ps-am\n\nps-am:\n\nuninstall-am: uninstall-binPROGRAMS uninstall-man\n\nuninstall-man: uninstall-man1\n\n.MAKE: all install-am install-strip\n\n.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles am--refresh check \\\n\tcheck-am clean clean-binPROGRAMS clean-cscope clean-generic \\\n\tcscope cscopelist-am ctags ctags-am dist dist-all dist-bzip2 \\\n\tdist-gzip dist-hook dist-lzip dist-shar dist-tarZ dist-xz \\\n\tdist-zip dist-zstd distcheck distclean distclean-compile \\\n\tdistclean-generic distclean-hdr distclean-tags distcleancheck \\\n\tdistdir distuninstallcheck dvi dvi-am html html-am info \\\n\tinfo-am install install-am install-binPROGRAMS install-data \\\n\tinstall-data-am install-dvi install-dvi-am install-exec \\\n\tinstall-exec-am install-html install-html-am install-info \\\n\tinstall-info-am install-man install-man1 install-pdf \\\n\tinstall-pdf-am install-ps install-ps-am install-strip \\\n\tinstallcheck installcheck-am installdirs maintainer-clean \\\n\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n\tmostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \\\n\tuninstall-am uninstall-binPROGRAMS uninstall-man \\\n\tuninstall-man1\n\n.PRECIOUS: Makefile\n\n\ndist-hook:\n\t@chmod u+rw $(distdir)/tests;              \\\n\tcd $(distdir)/tests ;                      \\\n\tfind * -name 'data*' -o                    \\\n\t       -name '*.in'  -o                    \\\n\t       -name '*.tst' -o                    \\\n\t       -name '*.bl'  -o                    \\\n\t       -name '*.good'                      \\\n\t| cpio -o > tests.cpio 2>/dev/null\n\t@gzip -f9 $(distdir)/tests/tests.cpio\n\t@find $(distdir)/tests/* -type d           \\\n\t\t\t\t -exec rm -rf {} +\n\n# Tell versions [3.59,3.63) of GNU make to not export all variables.\n# Otherwise a system limit (for SysV at least) may be exceeded.\n.NOEXPORT:\n\n# Tell GNU make to disable its built-in pattern rules.\n%:: %,v\n%:: RCS/%,v\n%:: RCS/%\n%:: s.%\n%:: SCCS/s.%\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 7.1123046875,
          "content": "..\n  ###################################################################\n  Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at https://mozilla.org/MPL/2.0/.\n  ###################################################################\n\n.. image:: smenu.gif\n\n|\n\n.. image:: simple_menu.gif\n\nWhat is it?\n===========\n**smenu** is a selection filter just like ``sed`` is an editing filter.\n\nThis tool reads words from standard input or from a file, and presents\nthem to the terminal screen in different layouts in a scrolling window.\nA cursor, easily moved using the **keyboard** and/or the **mouse**,\nmakes it possible to select one or more words.\n\nNote that the screen is not cleared at the start and end of **smenu**\nexecution.\nThe selection window is displayed at the cursor position, and the\nprevious contents of the terminal are neither modified nor lost.\n\nI've tried to make it as easy to use as possible.\nIt should work on all terminals managed in the ``terminfo`` database.\n\n``UTF-8`` encoding is supported.\nThis support includes double-width characters and extended grapheme\nclusters. The latter is still experimental, however, and works much\nbetter if appropriate terminals such as WezTerm or iTerm are used.\n\nThe encoding of ``UTF-8`` glyphs must also be in canonical form, as no\neffort will be made to put them in this form.\n\nPlease refer to the included man page to find out more about this little\nprogram.\n\nThe `wiki <https://github.com/p-gen/smenu/wiki>`_ contains screenshots and\nanimations that detail some concepts and features of **smenu**.\n\nHow to build it?\n================\nSome Linux distributions already provide **smenu** as a package,\nif not, **smenu** can be built on any system on which a functional\n``terminfo`` development platform is available.\nThis includes all Unix and Unix-like systems that I know of.\n\nPlease use the provided ``build.sh`` script to build the executable.\nThis script uses and accepts the same arguments as the GNU ``configure``\nscript, type ``build.sh --help`` to see them.\n\nHow to install it?\n==================\nOnce the build process is complete, a simple ``make install`` with the\nappropriate privileges will do it.\n\nIssue vs Discussion.\n====================\nI have enabled `discussions <https://github.com/p-gen/smenu/discussions>`_\non this repository.\n\nI am aware there may be some confusion when deciding where you should\ncommunicate when reporting issues, asking questions or raising feature\nrequests so this section aims to help us align on that.\n\nPlease `raise an issue <https://github.com/p-gen/smenu/issues>`_ if:\n\n- You have found a bug.\n- You have a feature request and can clearly describe your request.\n\nPlease `open a discussion <https://github.com/p-gen/smenu/discussions>`_ if:\n\n- You have a question.\n- You're not sure how to achieve something with smenu.\n- You have an idea but don't quite know how you would like it to work.\n- You have achieved something cool with smenu and want to show it off.\n- Anything else!\n\nSome examples.\n==============\n\nLinux example.\n--------------\nThis program should work on most Unix but if you are using Linux,\ntry to type the following line at a shell prompt (here: ``\"$ \"`` ):\n\n::\n\n  $ R=$(grep Vm /proc/$$/status \\\n        | smenu -n20 -W $':\\t\\n' -q -c -b -g -s /VmH)\n  $ echo $R\n\nSomething like this should now be displayed with the program waiting\nfor commands: (numbers are mine, yours will be different)\n\n::\n\n  VmPeak¦    23840 kB\n  VmSize¦    23836 kB\n  VmLck ¦        0 kB\n  VmHWM ¦     2936 kB\n  VmRSS ¦     2936 kB\n  VmData¦     1316 kB\n  VmStk ¦      136 kB\n  VmExe ¦       28 kB\n  VmLib ¦     3956 kB\n  VmPTE ¦       64 kB\n  VmSwap¦        0 kB\n\nA cursor should be under ``\"VmHWM \"``.\n\nAfter having moved the cursor to ``\"      136 kB\"`` and ended the program\nwith ``<Enter>``, the shell variable R should contain: ``\"      136 kB\"``.\n\nUnix example.\n-------------\nThe following command, which is Unix brand agnostic, should give you a\nscrolling window if you have more than 10 accounts on your Unix with a\nUID lower than 100:\n\n::\n\n  $ R=$(awk -F: '$3 < 100 {print $1,$3,$4,$NF}' /etc/passwd \\\n        | smenu -n10 -c)\n  $ echo $R\n\nOn mine (``LANG`` and ``LC_ALL`` set to ``POSIX``) it displays:\n\n::\n\n  at      25 25  /bin/bash      \\\n  sys     0  3   /usr/bin/ksh   +\n  bin     1  1   /bin/bash      |\n  daemon  2  2   /bin/bash      |\n  ftp     40 49  /bin/bash      |\n  games   12 100 /bin/bash      |\n  lp      4  7   /bin/bash      |\n  mail    8  12  /bin/false     |\n  named   44 44  /bin/false     |\n  ntp     74 108 /bin/false     v\n\nNote the presence of a scroll bar.\n\nBash example (CTRL-R replacement)\n---------------------------------\nJust add the following in your ``.bashrc``\n\n::\n\n  EOL=$'\\n'\n  bind -x '\"\\C-r\": READLINE_LINE=$(fc -lr 1                         \\\n                                   | sed \"s/[1-9][0-9]*..//\"        \\\n                                   | smenu -Q -l -a c:7/4,b -W\"$EOL\")\n                   READLINE_POINT=${#READLINE_LINE}'\n\nLaunch or relaunch **bash** and hit ``CTRL-R`` (``CTRL-C`` or ``q``\nto exit), enjoy!\n\nYou can also add the parameter **-d** to instruct **smenu** to clean\nthe selection window after selecting an entry.\n\nWarning for post v0.9.15 versions.\n----------------------------------\nThese versions use a new options system called **ctxopt** which\nmay contain bugs.\nPlease report them so they can be fixed in the next release of **smenu**\nor **ctxopt** (https://github.com/p-gen/ctxopt).\n\nCommand line arguments may also need to be rearranged in some cases\nbecause of this new option management system.\nSorry for the extra work this might entail.\n\nBugs.\n-----\n\nRight-alignment of lines written in right-to-left languages, such as Farsi\nor Hebrew, is not respected.\n\nTesting and reporting.\n----------------------\nThe included testing system is relatively young, please be indulgent.\n\n**IMPORTANT** the testing system has some dependencies, please read the\n``test/README.rst`` before going further.\n\n**NOTE** running all the tests by running ``./tests.sh`` in the\n``tests`` directory will take some time (around 21 min for now).\n\n**NOTE** on some systems like \\*BSD some tests may fail. This can be\nexplained by differences in posix/libc/... implementations.  This can\nnotably occur when some specific regular expressions or uncommon ``UTF-8``\nbyte sequences are used.\n\nIf a test fails for an unknown reason, please send me the name of its\ndirectory and the corresponding ``.bad`` file.\n\nIf you are hit by a bug that no test covers, then you can create a new\ntest in the ``tests`` directory in an existing or new directory: read the\n``tests/README.rst`` file, use an existing test as model, create an\n``.in`` file and a ``.tst`` file and send them to me as well as the\nproduced files.\n\nContributions.\n--------------\nContributions are welcome but discuss your proposal in an issue first,\nor with the maintainer.\n\nSpecial thanks.\n---------------\nI want to thank those who took the time to package **smenu** for their\npreferred operating system or distribution.\nYou will find their names here: https://repology.org/project/smenu/information\n"
        },
        {
          "name": "SUMMARY",
          "type": "blob",
          "size": 0.4228515625,
          "content": "Advanced terminal-based selection tool.\n\nThe items to be selected can come from a file or from the standard input.\nThe selected item is printed on the standard output.\n\nThe items are often ordinary words, but can be more complex.\n\nThe selection area can be browsed easily and even disappear once the\nselection is made.\n\nInitially designed to facilitate the creation of menus, smenu quickly\nbecame a much more general selection tool.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.0751953125,
          "content": "# To be done before the next version: \n[ ] Find and kill any remaining bugs.\n"
        },
        {
          "name": "aclocal.m4",
          "type": "blob",
          "size": 47.5048828125,
          "content": "# generated automatically by aclocal 1.17 -*- Autoconf -*-\n\n# Copyright (C) 1996-2024 Free Software Foundation, Inc.\n\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\nm4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\nm4_ifndef([AC_AUTOCONF_VERSION],\n  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\nm4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.72],,\n[m4_warning([this file was generated for autoconf 2.72.\nYou have another version of autoconf.  It may work, but is not guaranteed to.\nIf you have problems, you may need to regenerate the build system entirely.\nTo do so, use the procedure documented by the package, typically 'autoreconf'.])])\n\n# Copyright (C) 2002-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_AUTOMAKE_VERSION(VERSION)\n# ----------------------------\n# Automake X.Y traces this macro to ensure aclocal.m4 has been\n# generated from the m4 files accompanying Automake X.Y.\n# (This private macro should not be called outside this file.)\nAC_DEFUN([AM_AUTOMAKE_VERSION],\n[am__api_version='1.17'\ndnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\ndnl require some minimum version.  Point them to the right macro.\nm4_if([$1], [1.17], [],\n      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n])\n\n# _AM_AUTOCONF_VERSION(VERSION)\n# -----------------------------\n# aclocal traces this macro to find the Autoconf version.\n# This is a private macro too.  Using m4_define simplifies\n# the logic in aclocal, which can simply ignore this definition.\nm4_define([_AM_AUTOCONF_VERSION], [])\n\n# AM_SET_CURRENT_AUTOMAKE_VERSION\n# -------------------------------\n# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\nAC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n[AM_AUTOMAKE_VERSION([1.17])dnl\nm4_ifndef([AC_AUTOCONF_VERSION],\n  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n\n# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n\n# Copyright (C) 2001-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to\n# '$srcdir', '$srcdir/..', or '$srcdir/../..'.\n#\n# Of course, Automake must honor this variable whenever it calls a\n# tool from the auxiliary directory.  The problem is that $srcdir (and\n# therefore $ac_aux_dir as well) can be either absolute or relative,\n# depending on how configure is run.  This is pretty annoying, since\n# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n# source directory, any form will work fine, but in subdirectories a\n# relative path needs to be adjusted first.\n#\n# $ac_aux_dir/missing\n#    fails when called from a subdirectory if $ac_aux_dir is relative\n# $top_srcdir/$ac_aux_dir/missing\n#    fails if $ac_aux_dir is absolute,\n#    fails when called from a subdirectory in a VPATH build with\n#          a relative $ac_aux_dir\n#\n# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n# are both prefixed by $srcdir.  In an in-source build this is usually\n# harmless because $srcdir is '.', but things will broke when you\n# start a VPATH build or use an absolute $srcdir.\n#\n# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n# and then we would define $MISSING as\n#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n# This will work as long as MISSING is not called from configure, because\n# unfortunately $(top_srcdir) has no meaning in configure.\n# However there are other variables, like CC, which are often used in\n# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n#\n# Another solution, used here, is to always expand $ac_aux_dir to an\n# absolute PATH.  The drawback is that using absolute paths prevent a\n# configured tree to be moved without reconfiguration.\n\nAC_DEFUN([AM_AUX_DIR_EXPAND],\n[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\n# Expand $ac_aux_dir to an absolute path.\nam_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n])\n\n# AM_CONDITIONAL                                            -*- Autoconf -*-\n\n# Copyright (C) 1997-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n# -------------------------------------\n# Define a conditional.\nAC_DEFUN([AM_CONDITIONAL],\n[AC_PREREQ([2.52])dnl\n m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\nAC_SUBST([$1_TRUE])dnl\nAC_SUBST([$1_FALSE])dnl\n_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n_AM_SUBST_NOTMAKE([$1_FALSE])dnl\nm4_define([_AM_COND_VALUE_$1], [$2])dnl\nif $2; then\n  $1_TRUE=\n  $1_FALSE='#'\nelse\n  $1_TRUE='#'\n  $1_FALSE=\nfi\nAC_CONFIG_COMMANDS_PRE(\n[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n  AC_MSG_ERROR([[conditional \"$1\" was never defined.\nUsually this means the macro was only invoked conditionally.]])\nfi])])\n\n# Copyright (C) 1999-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n\n# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be\n# written in clear, in which case automake, when reading aclocal.m4,\n# will think it sees a *use*, and therefore will trigger all it's\n# C support machinery.  Also note that it means that autoscan, seeing\n# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n\n\n# _AM_DEPENDENCIES(NAME)\n# ----------------------\n# See how the compiler implements dependency checking.\n# NAME is \"CC\", \"CXX\", \"OBJC\", \"OBJCXX\", \"UPC\", or \"GJC\".\n# We try a few techniques and use that to set a single cache variable.\n#\n# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n# dependency, and given that the user is not expected to run this macro,\n# just rely on AC_PROG_CC.\nAC_DEFUN([_AM_DEPENDENCIES],\n[AC_REQUIRE([AM_SET_DEPDIR])dnl\nAC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\nAC_REQUIRE([AM_MAKE_INCLUDE])dnl\nAC_REQUIRE([AM_DEP_TRACK])dnl\n\nm4_if([$1], [CC],   [depcc=\"$CC\"   am_compiler_list=],\n      [$1], [CXX],  [depcc=\"$CXX\"  am_compiler_list=],\n      [$1], [OBJC], [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n      [$1], [OBJCXX], [depcc=\"$OBJCXX\" am_compiler_list='gcc3 gcc'],\n      [$1], [UPC],  [depcc=\"$UPC\"  am_compiler_list=],\n      [$1], [GCJ],  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n                    [depcc=\"$$1\"   am_compiler_list=])\n\nAC_CACHE_CHECK([dependency style of $depcc],\n               [am_cv_$1_dependencies_compiler_type],\n[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n  # We make a subdir and do the tests there.  Otherwise we can end up\n  # making bogus files that we don't know about and never remove.  For\n  # instance it was reported that on HP-UX the gcc test will end up\n  # making a dummy file named 'D' -- because '-MD' means \"put the output\n  # in D\".\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  # Copy depcomp to subdir because otherwise we won't find it if we're\n  # using a relative directory.\n  cp \"$am_depcomp\" conftest.dir\n  cd conftest.dir\n  # We will build objects and dependencies in a subdirectory because\n  # it helps to detect inapplicable dependency modes.  For instance\n  # both Tru64's cc and ICC support -MD to output dependencies as a\n  # side effect of compilation, but ICC will put the dependencies in\n  # the current directory while Tru64 will put them in the object\n  # directory.\n  mkdir sub\n\n  am_cv_$1_dependencies_compiler_type=none\n  if test \"$am_compiler_list\" = \"\"; then\n     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n  fi\n  am__universal=false\n  m4_case([$1], [CC],\n    [case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac],\n    [CXX],\n    [case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac])\n\n  for depmode in $am_compiler_list; do\n    # Setup a source with many dependencies, because some compilers\n    # like to wrap large dependency lists on column 80 (with \\), and\n    # we should not choose a depcomp mode which is confused by this.\n    #\n    # We need to recreate these files for each test, as the compiler may\n    # overwrite some of them when testing with obscure command lines.\n    # This happens at least with the AIX C compiler.\n    : > sub/conftest.c\n    for i in 1 2 3 4 5 6; do\n      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n      # Using \": > sub/conftst$i.h\" creates only sub/conftst1.h with\n      # Solaris 10 /bin/sh.\n      echo '/* dummy */' > sub/conftst$i.h\n    done\n    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n\n    # We check with '-c' and '-o' for the sake of the \"dashmstdout\"\n    # mode.  It turns out that the SunPro C++ compiler does not properly\n    # handle '-M -o', and we need to detect this.  Also, some Intel\n    # versions had trouble with output in subdirs.\n    am__obj=sub/conftest.${OBJEXT-o}\n    am__minus_obj=\"-o $am__obj\"\n    case $depmode in\n    gcc)\n      # This depmode causes a compiler race in universal mode.\n      test \"$am__universal\" = false || continue\n      ;;\n    nosideeffect)\n      # After this tag, mechanisms are not by side-effect, so they'll\n      # only be used when explicitly requested.\n      if test \"x$enable_dependency_tracking\" = xyes; then\n\tcontinue\n      else\n\tbreak\n      fi\n      ;;\n    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n      # This compiler won't grok '-c -o', but also, the minuso test has\n      # not run yet.  These depmodes are late enough in the game, and\n      # so weak that their functioning should not be impacted.\n      am__obj=conftest.${OBJEXT-o}\n      am__minus_obj=\n      ;;\n    none) break ;;\n    esac\n    if depmode=$depmode \\\n       source=sub/conftest.c object=$am__obj \\\n       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n         >/dev/null 2>conftest.err &&\n       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n      # icc doesn't choke on unknown options, it will just issue warnings\n      # or remarks (even with -Werror).  So we grep stderr for any message\n      # that says an option was ignored or not supported.\n      # When given -MP, icc 7.0 and 7.1 complain thus:\n      #   icc: Command line warning: ignoring option '-M'; no argument required\n      # The diagnosis changed in icc 8.0:\n      #   icc: Command line remark: option '-MP' not supported\n      if (grep 'ignoring option' conftest.err ||\n          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n        am_cv_$1_dependencies_compiler_type=$depmode\n        break\n      fi\n    fi\n  done\n\n  cd ..\n  rm -rf conftest.dir\nelse\n  am_cv_$1_dependencies_compiler_type=none\nfi\n])\nAC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\nAM_CONDITIONAL([am__fastdep$1], [\n  test \"x$enable_dependency_tracking\" != xno \\\n  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n])\n\n\n# AM_SET_DEPDIR\n# -------------\n# Choose a directory name for dependency files.\n# This macro is AC_REQUIREd in _AM_DEPENDENCIES.\nAC_DEFUN([AM_SET_DEPDIR],\n[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\nAC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n])\n\n\n# AM_DEP_TRACK\n# ------------\nAC_DEFUN([AM_DEP_TRACK],\n[AC_ARG_ENABLE([dependency-tracking], [dnl\nAS_HELP_STRING(\n  [--enable-dependency-tracking],\n  [do not reject slow dependency extractors])\nAS_HELP_STRING(\n  [--disable-dependency-tracking],\n  [speeds up one-time build])])\nif test \"x$enable_dependency_tracking\" != xno; then\n  am_depcomp=\"$ac_aux_dir/depcomp\"\n  AMDEPBACKSLASH='\\'\n  am__nodep='_no'\nfi\nAM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\nAC_SUBST([AMDEPBACKSLASH])dnl\n_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\nAC_SUBST([am__nodep])dnl\n_AM_SUBST_NOTMAKE([am__nodep])dnl\n])\n\n# Generate code to set up dependency tracking.              -*- Autoconf -*-\n\n# Copyright (C) 1999-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_OUTPUT_DEPENDENCY_COMMANDS\n# ------------------------------\nAC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n[{\n  # Older Autoconf quotes --file arguments for eval, but not when files\n  # are listed without --file.  Let's play safe and only enable the eval\n  # if we detect the quoting.\n  # TODO: see whether this extra hack can be removed once we start\n  # requiring Autoconf 2.70 or later.\n  AS_CASE([$CONFIG_FILES],\n          [*\\'*], [eval set x \"$CONFIG_FILES\"],\n          [*], [set x $CONFIG_FILES])\n  shift\n  # Used to flag and report bootstrapping failures.\n  am_rc=0\n  for am_mf\n  do\n    # Strip MF so we end up with the name of the file.\n    am_mf=`AS_ECHO([\"$am_mf\"]) | sed -e 's/:.*$//'`\n    # Check whether this is an Automake generated Makefile which includes\n    # dependency-tracking related rules and includes.\n    # Grep'ing the whole file directly is not great: AIX grep has a line\n    # limit of 2048, but all sed's we know have understand at least 4000.\n    sed -n 's,^am--depfiles:.*,X,p' \"$am_mf\" | grep X >/dev/null 2>&1 \\\n      || continue\n    am_dirpart=`AS_DIRNAME([\"$am_mf\"])`\n    am_filepart=`AS_BASENAME([\"$am_mf\"])`\n    AM_RUN_LOG([cd \"$am_dirpart\" \\\n      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n        | $MAKE -f - am--depfiles]) || am_rc=$?\n  done\n  if test $am_rc -ne 0; then\n    AC_MSG_FAILURE([Something went wrong bootstrapping makefile fragments\n    for automatic dependency tracking.  If GNU make was not used, consider\n    re-running the configure script with MAKE=\"gmake\" (or whatever is\n    necessary).  You can also try re-running configure with the\n    '--disable-dependency-tracking' option to at least be able to build\n    the package (albeit without support for automatic dependency tracking).])\n  fi\n  AS_UNSET([am_dirpart])\n  AS_UNSET([am_filepart])\n  AS_UNSET([am_mf])\n  AS_UNSET([am_rc])\n  rm -f conftest-deps.mk\n}\n])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n\n\n# AM_OUTPUT_DEPENDENCY_COMMANDS\n# -----------------------------\n# This macro should only be invoked once -- use via AC_REQUIRE.\n#\n# This code is only required when automatic dependency tracking is enabled.\n# This creates each '.Po' and '.Plo' makefile fragment that we'll need in\n# order to bootstrap the dependency handling code.\nAC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n[AC_CONFIG_COMMANDS([depfiles],\n     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n     [AMDEP_TRUE=\"$AMDEP_TRUE\" MAKE=\"${MAKE-make}\"])])\n\n# Do all the work for Automake.                             -*- Autoconf -*-\n\n# Copyright (C) 1996-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This macro actually does too much.  Some checks are only needed if\n# your package does certain things.  But this isn't really a big deal.\n\ndnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.\nm4_define([AC_PROG_CC],\nm4_defn([AC_PROG_CC])\n[_AM_PROG_CC_C_O\n])\n\n# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n# AM_INIT_AUTOMAKE([OPTIONS])\n# -----------------------------------------------\n# The call with PACKAGE and VERSION arguments is the old style\n# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n# and VERSION should now be passed to AC_INIT and removed from\n# the call to AM_INIT_AUTOMAKE.\n# We support both call styles for the transition.  After\n# the next Automake release, Autoconf can make the AC_INIT\n# arguments mandatory, and then we can depend on a new Autoconf\n# release and drop the old call support.\nAC_DEFUN([AM_INIT_AUTOMAKE],\n[AC_PREREQ([2.65])dnl\nm4_ifdef([_$0_ALREADY_INIT],\n  [m4_fatal([$0 expanded multiple times\n]m4_defn([_$0_ALREADY_INIT]))],\n  [m4_define([_$0_ALREADY_INIT], m4_expansion_stack)])dnl\ndnl Autoconf wants to disallow AM_ names.  We explicitly allow\ndnl the ones we care about.\nm4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\nAC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\nAC_REQUIRE([AC_PROG_INSTALL])dnl\nif test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n  # is not polluted with repeated \"-I.\"\n  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n  # test to see if srcdir already configured\n  if test -f $srcdir/config.status; then\n    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n  fi\nfi\n\n# test whether we have cygpath\nif test -z \"$CYGPATH_W\"; then\n  if (cygpath --version) >/dev/null 2>/dev/null; then\n    CYGPATH_W='cygpath -w'\n  else\n    CYGPATH_W=echo\n  fi\nfi\nAC_SUBST([CYGPATH_W])\n\n# Define the identity of the package.\ndnl Distinguish between old-style and new-style calls.\nm4_ifval([$2],\n[AC_DIAGNOSE([obsolete],\n             [$0: two- and three-arguments forms are deprecated.])\nm4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n AC_SUBST([PACKAGE], [$1])dnl\n AC_SUBST([VERSION], [$2])],\n[_AM_SET_OPTIONS([$1])dnl\ndnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\nm4_if(\n  m4_ifset([AC_PACKAGE_NAME], [ok]):m4_ifset([AC_PACKAGE_VERSION], [ok]),\n  [ok:ok],,\n  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n\n_AM_IF_OPTION([no-define],,\n[AC_DEFINE_UNQUOTED([PACKAGE], [\"$PACKAGE\"], [Name of package])\n AC_DEFINE_UNQUOTED([VERSION], [\"$VERSION\"], [Version number of package])])dnl\n\n# Some tools Automake needs.\nAC_REQUIRE([AM_SANITY_CHECK])dnl\nAC_REQUIRE([AC_ARG_PROGRAM])dnl\nAM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])\nAM_MISSING_PROG([AUTOCONF], [autoconf])\nAM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])\nAM_MISSING_PROG([AUTOHEADER], [autoheader])\nAM_MISSING_PROG([MAKEINFO], [makeinfo])\nAC_REQUIRE([AM_PROG_INSTALL_SH])dnl\nAC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\nAC_REQUIRE([AC_PROG_MKDIR_P])dnl\n# For better backward compatibility.  To be removed once Automake 1.9.x\n# dies out for good.  For more background, see:\n# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\nAC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n# We need awk for the \"check\" target (and possibly the TAP driver).  The\n# system \"awk\" is bad on some platforms.\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([AC_PROG_MAKE_SET])dnl\nAC_REQUIRE([AM_SET_LEADING_DOT])dnl\n_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n\t\t\t     [_AM_PROG_TAR([v7])])])\n_AM_IF_OPTION([no-dependencies],,\n[AC_PROVIDE_IFELSE([AC_PROG_CC],\n\t\t  [_AM_DEPENDENCIES([CC])],\n\t\t  [m4_define([AC_PROG_CC],\n\t\t\t     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_CXX],\n\t\t  [_AM_DEPENDENCIES([CXX])],\n\t\t  [m4_define([AC_PROG_CXX],\n\t\t\t     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_OBJC],\n\t\t  [_AM_DEPENDENCIES([OBJC])],\n\t\t  [m4_define([AC_PROG_OBJC],\n\t\t\t     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_OBJCXX],\n\t\t  [_AM_DEPENDENCIES([OBJCXX])],\n\t\t  [m4_define([AC_PROG_OBJCXX],\n\t\t\t     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl\n])\n# Variables for tags utilities; see am/tags.am\nif test -z \"$CTAGS\"; then\n  CTAGS=ctags\nfi\nAC_SUBST([CTAGS])\nif test -z \"$ETAGS\"; then\n  ETAGS=etags\nfi\nAC_SUBST([ETAGS])\nif test -z \"$CSCOPE\"; then\n  CSCOPE=cscope\nfi\nAC_SUBST([CSCOPE])\n\nAC_REQUIRE([_AM_SILENT_RULES])dnl\ndnl The testsuite driver may need to know about EXEEXT, so add the\ndnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This\ndnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.\nAC_CONFIG_COMMANDS_PRE(dnl\n[m4_provide_if([_AM_COMPILER_EXEEXT],\n  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n\nAC_REQUIRE([_AM_PROG_RM_F])\nAC_REQUIRE([_AM_PROG_XARGS_N])\n\ndnl The trailing newline in this macro's definition is deliberate, for\ndnl backward compatibility and to allow trailing 'dnl'-style comments\ndnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.\n])\n\ndnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\ndnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\ndnl mangled by Autoconf and run in a shell conditional statement.\nm4_define([_AC_COMPILER_EXEEXT],\nm4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n\n# When config.status generates a header, we must update the stamp-h file.\n# This file resides in the same directory as the config header\n# that is generated.  The stamp files are numbered to have different names.\n\n# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n# loop where config.status creates the headers, so we can generate\n# our stamp files there.\nAC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n[# Compute $1's index in $config_headers.\n_am_arg=$1\n_am_stamp_count=1\nfor _am_header in $config_headers :; do\n  case $_am_header in\n    $_am_arg | $_am_arg:* )\n      break ;;\n    * )\n      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n  esac\ndone\necho \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n\n# Copyright (C) 2001-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_PROG_INSTALL_SH\n# ------------------\n# Define $install_sh.\nAC_DEFUN([AM_PROG_INSTALL_SH],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nif test x\"${install_sh+set}\" != xset; then\n  case $am_aux_dir in\n  *\\ * | *\\\t*)\n    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n  *)\n    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n  esac\nfi\nAC_SUBST([install_sh])])\n\n# Copyright (C) 2003-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# Check whether the underlying file-system supports filenames\n# with a leading dot.  For instance MS-DOS doesn't.\nAC_DEFUN([AM_SET_LEADING_DOT],\n[rm -rf .tst 2>/dev/null\nmkdir .tst 2>/dev/null\nif test -d .tst; then\n  am__leading_dot=.\nelse\n  am__leading_dot=_\nfi\nrmdir .tst 2>/dev/null\nAC_SUBST([am__leading_dot])])\n\n# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n\n# Copyright (C) 2001-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_MAKE_INCLUDE()\n# -----------------\n# Check whether make has an 'include' directive that can support all\n# the idioms we need for our automatic dependency tracking code.\nAC_DEFUN([AM_MAKE_INCLUDE],\n[AC_MSG_CHECKING([whether ${MAKE-make} supports the include directive])\ncat > confinc.mk << 'END'\nam__doit:\n\t@echo this is the am__doit target >confinc.out\n.PHONY: am__doit\nEND\nam__include=\"#\"\nam__quote=\n# BSD make does it like this.\necho '.include \"confinc.mk\" # ignored' > confmf.BSD\n# Other make implementations (GNU, Solaris 10, AIX) do it like this.\necho 'include confinc.mk # ignored' > confmf.GNU\n_am_result=no\nfor s in GNU BSD; do\n  AM_RUN_LOG([${MAKE-make} -f confmf.$s && cat confinc.out])\n  AS_CASE([$?:`cat confinc.out 2>/dev/null`],\n      ['0:this is the am__doit target'],\n      [AS_CASE([$s],\n          [BSD], [am__include='.include' am__quote='\"'],\n          [am__include='include' am__quote=''])])\n  if test \"$am__include\" != \"#\"; then\n    _am_result=\"yes ($s style)\"\n    break\n  fi\ndone\nrm -f confinc.* confmf.*\nAC_MSG_RESULT([${_am_result}])\nAC_SUBST([am__include])])\nAC_SUBST([am__quote])])\n\n# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n\n# Copyright (C) 1997-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_MISSING_PROG(NAME, PROGRAM)\n# ------------------------------\nAC_DEFUN([AM_MISSING_PROG],\n[AC_REQUIRE([AM_MISSING_HAS_RUN])\n$1=${$1-\"${am_missing_run}$2\"}\nAC_SUBST($1)])\n\n# AM_MISSING_HAS_RUN\n# ------------------\n# Define MISSING if not defined so far and test if it is modern enough.\n# If it is, set am_missing_run to use it, otherwise, to nothing.\nAC_DEFUN([AM_MISSING_HAS_RUN],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nAC_REQUIRE_AUX_FILE([missing])dnl\nif test x\"${MISSING+set}\" != xset; then\n  MISSING=\"\\${SHELL} '$am_aux_dir/missing'\"\nfi\n# Use eval to expand $SHELL\nif eval \"$MISSING --is-lightweight\"; then\n  am_missing_run=\"$MISSING \"\nelse\n  am_missing_run=\n  AC_MSG_WARN(['missing' script is too old or missing])\nfi\n])\n\n# Helper functions for option handling.                     -*- Autoconf -*-\n\n# Copyright (C) 2001-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_MANGLE_OPTION(NAME)\n# -----------------------\nAC_DEFUN([_AM_MANGLE_OPTION],\n[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n\n# _AM_SET_OPTION(NAME)\n# --------------------\n# Set option NAME.  Presently that only means defining a flag for this option.\nAC_DEFUN([_AM_SET_OPTION],\n[m4_define(_AM_MANGLE_OPTION([$1]), [1])])\n\n# _AM_SET_OPTIONS(OPTIONS)\n# ------------------------\n# OPTIONS is a space-separated list of Automake options.\nAC_DEFUN([_AM_SET_OPTIONS],\n[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n\n# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n# -------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nAC_DEFUN([_AM_IF_OPTION],\n[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n\n# Copyright (C) 1999-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_PROG_CC_C_O\n# ---------------\n# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC\n# to automatically call this.\nAC_DEFUN([_AM_PROG_CC_C_O],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nAC_REQUIRE_AUX_FILE([compile])dnl\nAC_LANG_PUSH([C])dnl\nAC_CACHE_CHECK(\n  [whether $CC understands -c and -o together],\n  [am_cv_prog_cc_c_o],\n  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])\n  # Make sure it works both with $CC and with simple cc.\n  # Following AC_PROG_CC_C_O, we do the test twice because some\n  # compilers refuse to overwrite an existing .o file with -o,\n  # though they will create one.\n  am_cv_prog_cc_c_o=yes\n  for am_i in 1 2; do\n    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \\\n         && test -f conftest2.$ac_objext; then\n      : OK\n    else\n      am_cv_prog_cc_c_o=no\n      break\n    fi\n  done\n  rm -f core conftest*\n  unset am_i])\nif test \"$am_cv_prog_cc_c_o\" != yes; then\n   # Losing compiler, so override with the script.\n   # FIXME: It is wrong to rewrite CC.\n   # But if we don't then we get into trouble of one sort or another.\n   # A longer-term fix would be to have automake use am__CC in this case,\n   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n   CC=\"$am_aux_dir/compile $CC\"\nfi\nAC_LANG_POP([C])])\n\n# For backward compatibility.\nAC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n\n# Copyright (C) 2022-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_PROG_RM_F\n# ---------------\n# Check whether 'rm -f' without any arguments works.\n# https://bugs.gnu.org/10828\nAC_DEFUN([_AM_PROG_RM_F],\n[am__rm_f_notfound=\nAS_IF([(rm -f && rm -fr && rm -rf) 2>/dev/null], [], [am__rm_f_notfound='\"\"'])\nAC_SUBST(am__rm_f_notfound)\n])\n\n# Copyright (C) 2001-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_RUN_LOG(COMMAND)\n# -------------------\n# Run COMMAND, save the exit status in ac_status, and log it.\n# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)\nAC_DEFUN([AM_RUN_LOG],\n[{ echo \"$as_me:$LINENO: $1\" >&AS_MESSAGE_LOG_FD\n   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   (exit $ac_status); }])\n\n# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n\n# Copyright (C) 1996-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_SLEEP_FRACTIONAL_SECONDS\n# ----------------------------\nAC_DEFUN([_AM_SLEEP_FRACTIONAL_SECONDS], [dnl\nAC_CACHE_CHECK([whether sleep supports fractional seconds],\n               am_cv_sleep_fractional_seconds, [dnl\nAS_IF([sleep 0.001 2>/dev/null], [am_cv_sleep_fractional_seconds=yes],\n                                 [am_cv_sleep_fractional_seconds=no])\n])])\n\n# _AM_FILESYSTEM_TIMESTAMP_RESOLUTION\n# -----------------------------------\n# Determine the filesystem's resolution for file modification\n# timestamps.  The coarsest we know of is FAT, with a resolution\n# of only two seconds, even with the most recent \"exFAT\" extensions.\n# The finest (e.g. ext4 with large inodes, XFS, ZFS) is one\n# nanosecond, matching clock_gettime.  However, it is probably not\n# possible to delay execution of a shell script for less than one\n# millisecond, due to process creation overhead and scheduling\n# granularity, so we don't check for anything finer than that. (See below.)\nAC_DEFUN([_AM_FILESYSTEM_TIMESTAMP_RESOLUTION], [dnl\nAC_REQUIRE([_AM_SLEEP_FRACTIONAL_SECONDS])\nAC_CACHE_CHECK([filesystem timestamp resolution],\n               am_cv_filesystem_timestamp_resolution, [dnl\n# Default to the worst case.\nam_cv_filesystem_timestamp_resolution=2\n\n# Only try to go finer than 1 sec if sleep can do it.\n# Don't try 1 sec, because if 0.01 sec and 0.1 sec don't work,\n# - 1 sec is not much of a win compared to 2 sec, and\n# - it takes 2 seconds to perform the test whether 1 sec works.\n# \n# Instead, just use the default 2s on platforms that have 1s resolution,\n# accept the extra 1s delay when using $sleep in the Automake tests, in\n# exchange for not incurring the 2s delay for running the test for all\n# packages.\n#\nam_try_resolutions=\nif test \"$am_cv_sleep_fractional_seconds\" = yes; then\n  # Even a millisecond often causes a bunch of false positives,\n  # so just try a hundredth of a second. The time saved between .001 and\n  # .01 is not terribly consequential.\n  am_try_resolutions=\"0.01 0.1 $am_try_resolutions\"\nfi\n\n# In order to catch current-generation FAT out, we must *modify* files\n# that already exist; the *creation* timestamp is finer.  Use names\n# that make ls -t sort them differently when they have equal\n# timestamps than when they have distinct timestamps, keeping\n# in mind that ls -t prints the *newest* file first.\nrm -f conftest.ts?\n: > conftest.ts1\n: > conftest.ts2\n: > conftest.ts3\n\n# Make sure ls -t actually works.  Do 'set' in a subshell so we don't\n# clobber the current shell's arguments. (Outer-level square brackets\n# are removed by m4; they're present so that m4 does not expand\n# <dollar><star>; be careful, easy to get confused.)\nif (\n     set X `[ls -t conftest.ts[12]]` &&\n     {\n       test \"$[]*\" != \"X conftest.ts1 conftest.ts2\" ||\n       test \"$[]*\" != \"X conftest.ts2 conftest.ts1\";\n     }\n); then :; else\n  # If neither matched, then we have a broken ls.  This can happen\n  # if, for instance, CONFIG_SHELL is bash and it inherits a\n  # broken ls alias from the environment.  This has actually\n  # happened.  Such a system could not be considered \"sane\".\n  _AS_ECHO_UNQUOTED(\n    [\"Bad output from ls -t: \\\"`[ls -t conftest.ts[12]]`\\\"\"],\n    [AS_MESSAGE_LOG_FD])\n  AC_MSG_FAILURE([ls -t produces unexpected output.\nMake sure there is not a broken ls alias in your environment.])\nfi\n\nfor am_try_res in $am_try_resolutions; do\n  # Any one fine-grained sleep might happen to cross the boundary\n  # between two values of a coarser actual resolution, but if we do\n  # two fine-grained sleeps in a row, at least one of them will fall\n  # entirely within a coarse interval.\n  echo alpha > conftest.ts1\n  sleep $am_try_res\n  echo beta > conftest.ts2\n  sleep $am_try_res\n  echo gamma > conftest.ts3\n\n  # We assume that 'ls -t' will make use of high-resolution\n  # timestamps if the operating system supports them at all.\n  if (set X `ls -t conftest.ts?` &&\n      test \"$[]2\" = conftest.ts3 &&\n      test \"$[]3\" = conftest.ts2 &&\n      test \"$[]4\" = conftest.ts1); then\n    #\n    # Ok, ls -t worked. If we're at a resolution of 1 second, we're done,\n    # because we don't need to test make.\n    make_ok=true\n    if test $am_try_res != 1; then\n      # But if we've succeeded so far with a subsecond resolution, we\n      # have one more thing to check: make. It can happen that\n      # everything else supports the subsecond mtimes, but make doesn't;\n      # notably on macOS, which ships make 3.81 from 2006 (the last one\n      # released under GPLv2). https://bugs.gnu.org/68808\n      # \n      # We test $MAKE if it is defined in the environment, else \"make\".\n      # It might get overridden later, but our hope is that in practice\n      # it does not matter: it is the system \"make\" which is (by far)\n      # the most likely to be broken, whereas if the user overrides it,\n      # probably they did so with a better, or at least not worse, make.\n      # https://lists.gnu.org/archive/html/automake/2024-06/msg00051.html\n      #\n      # Create a Makefile (real tab character here):\n      rm -f conftest.mk\n      echo 'conftest.ts1: conftest.ts2' >conftest.mk\n      echo '\ttouch conftest.ts2' >>conftest.mk\n      #\n      # Now, running\n      #   touch conftest.ts1; touch conftest.ts2; make\n      # should touch ts1 because ts2 is newer. This could happen by luck,\n      # but most often, it will fail if make's support is insufficient. So\n      # test for several consecutive successes.\n      #\n      # (We reuse conftest.ts[12] because we still want to modify existing\n      # files, not create new ones, per above.)\n      n=0\n      make=${MAKE-make}\n      until test $n -eq 3; do\n        echo one > conftest.ts1\n        sleep $am_try_res\n        echo two > conftest.ts2 # ts2 should now be newer than ts1\n        if $make -f conftest.mk | grep 'up to date' >/dev/null; then\n          make_ok=false\n          break # out of $n loop\n        fi\n        n=`expr $n + 1`\n      done\n    fi\n    #\n    if $make_ok; then\n      # Everything we know to check worked out, so call this resolution good.\n      am_cv_filesystem_timestamp_resolution=$am_try_res\n      break # out of $am_try_res loop\n    fi\n    # Otherwise, we'll go on to check the next resolution.\n  fi\ndone\nrm -f conftest.ts?\n# (end _am_filesystem_timestamp_resolution)\n])])\n\n# AM_SANITY_CHECK\n# ---------------\nAC_DEFUN([AM_SANITY_CHECK],\n[AC_REQUIRE([_AM_FILESYSTEM_TIMESTAMP_RESOLUTION])\n# This check should not be cached, as it may vary across builds of\n# different projects.\nAC_MSG_CHECKING([whether build environment is sane])\n# Reject unsafe characters in $srcdir or the absolute working directory\n# name.  Accept space and tab only in the latter.\nam_lf='\n'\ncase `pwd` in\n  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n    AC_MSG_ERROR([unsafe absolute working directory name]);;\nesac\ncase $srcdir in\n  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;\nesac\n\n# Do 'set' in a subshell so we don't clobber the current shell's\n# arguments.  Must try -L first in case configure is actually a\n# symlink; some systems play weird games with the mod time of symlinks\n# (eg FreeBSD returns the mod time of the symlink's containing\n# directory).\nam_build_env_is_sane=no\nam_has_slept=no\nrm -f conftest.file\nfor am_try in 1 2; do\n  echo \"timestamp, slept: $am_has_slept\" > conftest.file\n  if (\n    set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n    if test \"$[]*\" = \"X\"; then\n      # -L didn't work.\n      set X `ls -t \"$srcdir/configure\" conftest.file`\n    fi\n    test \"$[]2\" = conftest.file\n  ); then\n    am_build_env_is_sane=yes\n    break\n  fi\n  # Just in case.\n  sleep \"$am_cv_filesystem_timestamp_resolution\"\n  am_has_slept=yes\ndone\n\nAC_MSG_RESULT([$am_build_env_is_sane])\nif test \"$am_build_env_is_sane\" = no; then\n  AC_MSG_ERROR([newly created file is older than distributed files!\nCheck your system clock])\nfi\n\n# If we didn't sleep, we still need to ensure time stamps of config.status and\n# generated files are strictly newer.\nam_sleep_pid=\nAS_IF([test -e conftest.file || grep 'slept: no' conftest.file >/dev/null 2>&1],, [dnl\n  ( sleep \"$am_cv_filesystem_timestamp_resolution\" ) &\n  am_sleep_pid=$!\n])\nAC_CONFIG_COMMANDS_PRE(\n  [AC_MSG_CHECKING([that generated files are newer than configure])\n   if test -n \"$am_sleep_pid\"; then\n     # Hide warnings about reused PIDs.\n     wait $am_sleep_pid 2>/dev/null\n   fi\n   AC_MSG_RESULT([done])])\nrm -f conftest.file\n])\n\n# Copyright (C) 2009-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_SILENT_RULES\n# ----------------\n# Enable less verbose build rules support.\nAC_DEFUN([_AM_SILENT_RULES],\n[AM_DEFAULT_VERBOSITY=1\nAC_ARG_ENABLE([silent-rules], [dnl\nAS_HELP_STRING(\n  [--enable-silent-rules],\n  [less verbose build output (undo: \"make V=1\")])\nAS_HELP_STRING(\n  [--disable-silent-rules],\n  [verbose build output (undo: \"make V=0\")])dnl\n])\ndnl\ndnl A few 'make' implementations (e.g., NonStop OS and NextStep)\ndnl do not support nested variable expansions.\ndnl See automake bug#9928 and bug#10237.\nam_make=${MAKE-make}\nAC_CACHE_CHECK([whether $am_make supports nested variables],\n   [am_cv_make_support_nested_variables],\n   [if AS_ECHO([['TRUE=$(BAR$(V))\nBAR0=false\nBAR1=true\nV=1\nam__doit:\n\t@$(TRUE)\n.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then\n  am_cv_make_support_nested_variables=yes\nelse\n  am_cv_make_support_nested_variables=no\nfi])\nAC_SUBST([AM_V])dnl\nAM_SUBST_NOTMAKE([AM_V])dnl\nAC_SUBST([AM_DEFAULT_V])dnl\nAM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl\nAC_SUBST([AM_DEFAULT_VERBOSITY])dnl\nAM_BACKSLASH='\\'\nAC_SUBST([AM_BACKSLASH])dnl\n_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\ndnl Delay evaluation of AM_DEFAULT_VERBOSITY to the end to allow multiple calls\ndnl to AM_SILENT_RULES to change the default value.\nAC_CONFIG_COMMANDS_PRE([dnl\ncase $enable_silent_rules in @%:@ (((\n  yes) AM_DEFAULT_VERBOSITY=0;;\n   no) AM_DEFAULT_VERBOSITY=1;;\nesac\nif test $am_cv_make_support_nested_variables = yes; then\n  dnl Using '$V' instead of '$(V)' breaks IRIX make.\n  AM_V='$(V)'\n  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'\nelse\n  AM_V=$AM_DEFAULT_VERBOSITY\n  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY\nfi\n])dnl\n])\n\n# AM_SILENT_RULES([DEFAULT])\n# --------------------------\n# Set the default verbosity level to DEFAULT (\"yes\" being less verbose, \"no\" or\n# empty being verbose).\nAC_DEFUN([AM_SILENT_RULES],\n[AC_REQUIRE([_AM_SILENT_RULES])\nAM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1])])\n\n# Copyright (C) 2001-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_PROG_INSTALL_STRIP\n# ---------------------\n# One issue with vendor 'install' (even GNU) is that you can't\n# specify the program used to strip binaries.  This is especially\n# annoying in cross-compiling environments, where the build's strip\n# is unlikely to handle the host's binaries.\n# Fortunately install-sh will honor a STRIPPROG variable, so we\n# always use install-sh in \"make install-strip\", and initialize\n# STRIPPROG with the value of the STRIP variable (set by the user).\nAC_DEFUN([AM_PROG_INSTALL_STRIP],\n[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n# Installed binaries are usually stripped using 'strip' when the user\n# run \"make install-strip\".  However 'strip' might not be the right\n# tool to use in cross-compilation environments, therefore Automake\n# will honor the 'STRIP' environment variable to overrule this program.\ndnl Don't test for $cross_compiling = yes, because it might be 'maybe'.\nif test \"$cross_compiling\" != no; then\n  AC_CHECK_TOOL([STRIP], [strip], :)\nfi\nINSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\nAC_SUBST([INSTALL_STRIP_PROGRAM])])\n\n# Copyright (C) 2006-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_SUBST_NOTMAKE(VARIABLE)\n# ---------------------------\n# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n# This macro is traced by Automake.\nAC_DEFUN([_AM_SUBST_NOTMAKE])\n\n# AM_SUBST_NOTMAKE(VARIABLE)\n# --------------------------\n# Public sister of _AM_SUBST_NOTMAKE.\nAC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n\n# Check how to create a tarball.                            -*- Autoconf -*-\n\n# Copyright (C) 2004-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_PROG_TAR(FORMAT)\n# --------------------\n# Check how to create a tarball in format FORMAT.\n# FORMAT should be one of 'v7', 'ustar', or 'pax'.\n#\n# Substitute a variable $(am__tar) that is a command\n# writing to stdout a FORMAT-tarball containing the directory\n# $tardir.\n#     tardir=directory && $(am__tar) > result.tar\n#\n# Substitute a variable $(am__untar) that extract such\n# a tarball read from stdin.\n#     $(am__untar) < result.tar\n#\nAC_DEFUN([_AM_PROG_TAR],\n[# Always define AMTAR for backward compatibility.  Yes, it's still used\n# in the wild :-(  We should find a proper way to deprecate it ...\nAC_SUBST([AMTAR], ['$${TAR-tar}'])\n\n# We'll loop over all known methods to create a tar archive until one works.\n_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n\nm4_if([$1], [v7],\n  [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n\n  [m4_case([$1],\n    [ustar],\n     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.\n      # There is notably a 21 bits limit for the UID and the GID.  In fact,\n      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343\n      # and bug#13588).\n      am_max_uid=2097151 # 2^21 - 1\n      am_max_gid=$am_max_uid\n      # The $UID and $GID variables are not portable, so we need to resort\n      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls\n      # below are definitely unexpected, so allow the users to see them\n      # (that is, avoid stderr redirection).\n      am_uid=`id -u || echo unknown`\n      am_gid=`id -g || echo unknown`\n      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])\n      if test x$am_uid = xunknown; then\n        AC_MSG_WARN([ancient id detected; assuming current UID is ok, but dist-ustar might not work])\n      elif test $am_uid -le $am_max_uid; then\n        AC_MSG_RESULT([yes])\n      else\n        AC_MSG_RESULT([no])\n        _am_tools=none\n      fi\n      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])\n      if test x$gm_gid = xunknown; then\n        AC_MSG_WARN([ancient id detected; assuming current GID is ok, but dist-ustar might not work])\n      elif test $am_gid -le $am_max_gid; then\n        AC_MSG_RESULT([yes])\n      else\n        AC_MSG_RESULT([no])\n        _am_tools=none\n      fi],\n\n  [pax],\n    [],\n\n  [m4_fatal([Unknown tar format])])\n\n  AC_MSG_CHECKING([how to create a $1 tar archive])\n\n  # Go ahead even if we have the value already cached.  We do so because we\n  # need to set the values for the 'am__tar' and 'am__untar' variables.\n  _am_tools=${am_cv_prog_tar_$1-$_am_tools}\n\n  for _am_tool in $_am_tools; do\n    case $_am_tool in\n    gnutar)\n      for _am_tar in tar gnutar gtar; do\n        AM_RUN_LOG([$_am_tar --version]) && break\n      done\n      am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n      am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n      am__untar=\"$_am_tar -xf -\"\n      ;;\n    plaintar)\n      # Must skip GNU tar: if it does not support --format= it doesn't create\n      # ustar tarball either.\n      (tar --version) >/dev/null 2>&1 && continue\n      am__tar='tar chf - \"$$tardir\"'\n      am__tar_='tar chf - \"$tardir\"'\n      am__untar='tar xf -'\n      ;;\n    pax)\n      am__tar='pax -L -x $1 -w \"$$tardir\"'\n      am__tar_='pax -L -x $1 -w \"$tardir\"'\n      am__untar='pax -r'\n      ;;\n    cpio)\n      am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n      am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n      am__untar='cpio -i -H $1 -d'\n      ;;\n    none)\n      am__tar=false\n      am__tar_=false\n      am__untar=false\n      ;;\n    esac\n\n    # If the value was cached, stop now.  We just wanted to have am__tar\n    # and am__untar set.\n    test -n \"${am_cv_prog_tar_$1}\" && break\n\n    # tar/untar a dummy directory, and stop if the command works.\n    rm -rf conftest.dir\n    mkdir conftest.dir\n    echo GrepMe > conftest.dir/file\n    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n    rm -rf conftest.dir\n    if test -s conftest.tar; then\n      AM_RUN_LOG([$am__untar <conftest.tar])\n      AM_RUN_LOG([cat conftest.dir/file])\n      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n    fi\n  done\n  rm -rf conftest.dir\n\n  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n  AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n\nAC_SUBST([am__tar])\nAC_SUBST([am__untar])\n]) # _AM_PROG_TAR\n\n# Copyright (C) 2022-2024 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_PROG_XARGS_N\n# ----------------\n# Check whether 'xargs -n' works.  It should work everywhere, so the fallback\n# is not optimized at all as we never expect to use it.\nAC_DEFUN([_AM_PROG_XARGS_N],\n[AC_CACHE_CHECK([xargs -n works], am_cv_xargs_n_works, [dnl\nAS_IF([test \"`echo 1 2 3 | xargs -n2 echo`\" = \"1 2\n3\"], [am_cv_xargs_n_works=yes], [am_cv_xargs_n_works=no])])\nAS_IF([test \"$am_cv_xargs_n_works\" = yes], [am__xargs_n='xargs -n'], [dnl\n  am__xargs_n='am__xargs_n () { shift; sed \"s/ /\\\\n/g\" | while read am__xargs_n_arg; do \"$@\" \"$am__xargs_n_arg\"; done; }'\n])dnl\nAC_SUBST(am__xargs_n)\n])\n\n"
        },
        {
          "name": "build-aux",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 1.0244140625,
          "content": "#!/bin/sh\n\n# ###################################################################\n# Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)\n#\n# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at https://mozilla.org/MPL/2.0/.\n# ###################################################################\n\n# Manage --help option\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nif echo \"$@\" | grep -- \"--help\"; then\n  ./configure --help | sed s/configure/build.sh/g\n  exit 1\nfi\n\n# Ensure that aclocal wont' be called\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\ntouch aclocal.m4\ntouch Makefile.in configure config.h.in\n\n# Create the Makefile\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n./configure \"$@\"\n\n# Add the git version if this is a git clone\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n[ -d .git ] && V=`git log -1 --pretty=format:-%h` || V=\"\"\n\nsed \"/VERSION/s/\\$/ \\\"$V\\\"/\" config.h > /tmp/config.h$$\nmv /tmp/config.h$$ config.h\n\n# Create the executable\n# \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nmake\n\nexit 0\n"
        },
        {
          "name": "config.h.in",
          "type": "blob",
          "size": 6.3935546875,
          "content": "/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* Define to 1 if you have the `clock_gettime' function */\n#undef HAVE_CLOCK_GETTIME\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#undef HAVE_FCNTL_H\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H\n\n/* Define to 1 if you have the <limits.h> header file. */\n#undef HAVE_LIMITS_H\n\n/* Define to 1 if you have the <locale.h> header file. */\n#undef HAVE_LOCALE_H\n\n/* Define to 1 if your system has a GNU libc compatible 'malloc' function, and\n   to 0 otherwise. */\n#undef HAVE_MALLOC\n\n/* Define to 1 if you have the 'mblen' function. */\n#undef HAVE_MBLEN\n\n/* Define to 1 if you have the 'memset' function. */\n#undef HAVE_MEMSET\n\n/* Define to 1 if you have the <minix/config.h> header file. */\n#undef HAVE_MINIX_CONFIG_H\n\n/* Define to 1 if you have the 'nl_langinfo' function. */\n#undef HAVE_NL_LANGINFO\n\n/* Define to 1 if you have the 'pathconf' function. */\n#undef HAVE_PATHCONF\n\n/* Define to 1 if your system has a GNU libc compatible 'realloc' function,\n   and to 0 otherwise. */\n#undef HAVE_REALLOC\n\n/* Define to 1 if you have the 'regcomp' function. */\n#undef HAVE_REGCOMP\n\n/* Define to 1 if you have the 'setlocale' function. */\n#undef HAVE_SETLOCALE\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdio.h> header file. */\n#undef HAVE_STDIO_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the 'strcasecmp' function. */\n#undef HAVE_STRCASECMP\n\n/* Define to 1 if you have the 'strchr' function. */\n#undef HAVE_STRCHR\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the 'strrchr' function. */\n#undef HAVE_STRRCHR\n\n/* Define to 1 if you have the 'strspn' function. */\n#undef HAVE_STRSPN\n\n/* Define to 1 if you have the <sys/ioctl.h> header file. */\n#undef HAVE_SYS_IOCTL_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#undef HAVE_WCHAR_H\n\n/* Name of package */\n#undef PACKAGE\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define to 1 if all of the C89 standard headers exist (not just the ones\n   required in a freestanding environment). This macro is provided for\n   backward compatibility; new code need not use it. */\n#undef STDC_HEADERS\n\n/* Enable extensions on AIX, Interix, z/OS.  */\n#ifndef _ALL_SOURCE\n# undef _ALL_SOURCE\n#endif\n/* Enable general extensions on macOS.  */\n#ifndef _DARWIN_C_SOURCE\n# undef _DARWIN_C_SOURCE\n#endif\n/* Enable general extensions on Solaris.  */\n#ifndef __EXTENSIONS__\n# undef __EXTENSIONS__\n#endif\n/* Enable GNU extensions on systems that have them.  */\n#ifndef _GNU_SOURCE\n# undef _GNU_SOURCE\n#endif\n/* Enable X/Open compliant socket functions that do not require linking\n   with -lxnet on HP-UX 11.11.  */\n#ifndef _HPUX_ALT_XOPEN_SOCKET_API\n# undef _HPUX_ALT_XOPEN_SOCKET_API\n#endif\n/* Identify the host operating system as Minix.\n   This macro does not affect the system headers' behavior.\n   A future release of Autoconf may stop defining this macro.  */\n#ifndef _MINIX\n# undef _MINIX\n#endif\n/* Enable general extensions on NetBSD.\n   Enable NetBSD compatibility extensions on Minix.  */\n#ifndef _NETBSD_SOURCE\n# undef _NETBSD_SOURCE\n#endif\n/* Enable OpenBSD compatibility extensions on NetBSD.\n   Oddly enough, this does nothing on OpenBSD.  */\n#ifndef _OPENBSD_SOURCE\n# undef _OPENBSD_SOURCE\n#endif\n/* Define to 1 if needed for POSIX-compatible behavior.  */\n#ifndef _POSIX_SOURCE\n# undef _POSIX_SOURCE\n#endif\n/* Define to 2 if needed for POSIX-compatible behavior.  */\n#ifndef _POSIX_1_SOURCE\n# undef _POSIX_1_SOURCE\n#endif\n/* Enable POSIX-compatible threading on Solaris.  */\n#ifndef _POSIX_PTHREAD_SEMANTICS\n# undef _POSIX_PTHREAD_SEMANTICS\n#endif\n/* Enable extensions specified by ISO/IEC TS 18661-5:2014.  */\n#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__\n# undef __STDC_WANT_IEC_60559_ATTRIBS_EXT__\n#endif\n/* Enable extensions specified by ISO/IEC TS 18661-1:2014.  */\n#ifndef __STDC_WANT_IEC_60559_BFP_EXT__\n# undef __STDC_WANT_IEC_60559_BFP_EXT__\n#endif\n/* Enable extensions specified by ISO/IEC TS 18661-2:2015.  */\n#ifndef __STDC_WANT_IEC_60559_DFP_EXT__\n# undef __STDC_WANT_IEC_60559_DFP_EXT__\n#endif\n/* Enable extensions specified by C23 Annex F.  */\n#ifndef __STDC_WANT_IEC_60559_EXT__\n# undef __STDC_WANT_IEC_60559_EXT__\n#endif\n/* Enable extensions specified by ISO/IEC TS 18661-4:2015.  */\n#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__\n# undef __STDC_WANT_IEC_60559_FUNCS_EXT__\n#endif\n/* Enable extensions specified by C23 Annex H and ISO/IEC TS 18661-3:2015.  */\n#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__\n# undef __STDC_WANT_IEC_60559_TYPES_EXT__\n#endif\n/* Enable extensions specified by ISO/IEC TR 24731-2:2010.  */\n#ifndef __STDC_WANT_LIB_EXT2__\n# undef __STDC_WANT_LIB_EXT2__\n#endif\n/* Enable extensions specified by ISO/IEC 24747:2009.  */\n#ifndef __STDC_WANT_MATH_SPEC_FUNCS__\n# undef __STDC_WANT_MATH_SPEC_FUNCS__\n#endif\n/* Enable extensions on HP NonStop.  */\n#ifndef _TANDEM_SOURCE\n# undef _TANDEM_SOURCE\n#endif\n/* Enable X/Open extensions.  Define to 500 only if necessary\n   to make mbstate_t available.  */\n#ifndef _XOPEN_SOURCE\n# undef _XOPEN_SOURCE\n#endif\n\n\n/* Version number of package */\n#undef VERSION\n\n/* Define to rpl_malloc if the replacement function should be used. */\n#undef malloc\n\n/* Define to rpl_realloc if the replacement function should be used. */\n#undef realloc\n\n/* Define as 'unsigned int' if <stddef.h> doesn't define. */\n#undef size_t\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 223.9609375,
          "content": "#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.72 for smenu 1.4.0.\n#\n# Report bugs to <p.gen.progs@gmail.com>.\n#\n#\n# Copyright (C) 1992-1996, 1998-2017, 2020-2023 Free Software Foundation,\n# Inc.\n#\n#\n# This configure script is free software; the Free Software Foundation\n# gives unlimited permission to copy, distribute and modify it.\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nif test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse case e in #(\n  e) case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac ;;\nesac\nfi\n\n\n\n# Reset variables that may have inherited troublesome values from\n# the environment.\n\n# IFS needs to be set, to space, tab, and newline, in precisely that order.\n# (If _AS_PATH_WALK were called with IFS unset, it would have the\n# side effect of setting IFS to empty, thus disabling word splitting.)\n# Quoting is to prevent editors from complaining about space-tab.\nas_nl='\n'\nexport as_nl\nIFS=\" \"\"\t$as_nl\"\n\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# Ensure predictable behavior from utilities with locale-dependent output.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# We cannot yet rely on \"unset\" to work, but we need these variables\n# to be unset--not just set to an empty or harmless value--now, to\n# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct\n# also avoids known problems related to \"unset\" and subshell syntax\n# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).\nfor as_var in BASH_ENV ENV MAIL MAILPATH CDPATH\ndo eval test \\${$as_var+y} \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\n\n# Ensure that fds 0, 1, and 2 are open.\nif (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi\nif (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi\nif (exec 3>&2)            ; then :; else exec 2>/dev/null; fi\n\n# The user is always right.\nif ${PATH_SEPARATOR+false} :; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    test -r \"$as_dir$0\" && as_myself=$as_dir$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as 'sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  printf \"%s\\n\" \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n\n# Use a proper internal environment variable to ensure we don't fall\n  # into an infinite loop, continuously re-executing ourselves.\n  if test x\"${_as_can_reexec}\" != xno && test \"x$CONFIG_SHELL\" != x; then\n    _as_can_reexec=no; export _as_can_reexec;\n    # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed 'exec'.\nprintf \"%s\\n\" \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\n  fi\n  # We don't want this to propagate to other subprocesses.\n          { _as_can_reexec=; unset _as_can_reexec;}\nif test \"x$CONFIG_SHELL\" = x; then\n  as_bourne_compatible=\"if test \\${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse case e in #(\n  e) case \\`(set -o) 2>/dev/null\\` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac ;;\nesac\nfi\n\"\n  as_required=\"as_fn_return () { (exit \\$1); }\nas_fn_success () { as_fn_return 0; }\nas_fn_failure () { as_fn_return 1; }\nas_fn_ret_success () { return 0; }\nas_fn_ret_failure () { return 1; }\n\nexitcode=0\nas_fn_success || { exitcode=1; echo as_fn_success failed.; }\nas_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }\nas_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }\nas_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }\nif ( set x; as_fn_ret_success y && test x = \\\"\\$1\\\" )\nthen :\n\nelse case e in #(\n  e) exitcode=1; echo positional parameters were not saved. ;;\nesac\nfi\ntest x\\$exitcode = x0 || exit 1\nblah=\\$(echo \\$(echo blah))\ntest x\\\"\\$blah\\\" = xblah || exit 1\ntest -x / || exit 1\"\n  as_suggested=\"  as_lineno_1=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_1a=\\$LINENO\n  as_lineno_2=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_2a=\\$LINENO\n  eval 'test \\\"x\\$as_lineno_1'\\$as_run'\\\" != \\\"x\\$as_lineno_2'\\$as_run'\\\" &&\n  test \\\"x\\`expr \\$as_lineno_1'\\$as_run' + 1\\`\\\" = \\\"x\\$as_lineno_2'\\$as_run'\\\"' || exit 1\ntest \\$(( 1 + 1 )) = 2 || exit 1\"\n  if (eval \"$as_required\") 2>/dev/null\nthen :\n  as_have_required=yes\nelse case e in #(\n  e) as_have_required=no ;;\nesac\nfi\n  if test x$as_have_required = xyes && (eval \"$as_suggested\") 2>/dev/null\nthen :\n\nelse case e in #(\n  e) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nas_found=false\nfor as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n  as_found=:\n  case $as_dir in #(\n\t /*)\n\t   for as_base in sh bash ksh sh5; do\n\t     # Try only shells that exist, to save several forks.\n\t     as_shell=$as_dir$as_base\n\t     if { test -f \"$as_shell\" || test -f \"$as_shell.exe\"; } &&\n\t\t    as_run=a \"$as_shell\" -c \"$as_bourne_compatible\"\"$as_required\" 2>/dev/null\nthen :\n  CONFIG_SHELL=$as_shell as_have_required=yes\n\t\t   if as_run=a \"$as_shell\" -c \"$as_bourne_compatible\"\"$as_suggested\" 2>/dev/null\nthen :\n  break 2\nfi\nfi\n\t   done;;\n       esac\n  as_found=false\ndone\nIFS=$as_save_IFS\nif $as_found\nthen :\n\nelse case e in #(\n  e) if { test -f \"$SHELL\" || test -f \"$SHELL.exe\"; } &&\n\t      as_run=a \"$SHELL\" -c \"$as_bourne_compatible\"\"$as_required\" 2>/dev/null\nthen :\n  CONFIG_SHELL=$SHELL as_have_required=yes\nfi ;;\nesac\nfi\n\n\n      if test \"x$CONFIG_SHELL\" != x\nthen :\n  export CONFIG_SHELL\n             # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed 'exec'.\nprintf \"%s\\n\" \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\nfi\n\n    if test x$as_have_required = xno\nthen :\n  printf \"%s\\n\" \"$0: This script requires a shell more modern than all\"\n  printf \"%s\\n\" \"$0: the shells that I found on your system.\"\n  if test ${ZSH_VERSION+y} ; then\n    printf \"%s\\n\" \"$0: In particular, zsh $ZSH_VERSION has bugs and should\"\n    printf \"%s\\n\" \"$0: be upgraded to zsh 4.3.4 or later.\"\n  else\n    printf \"%s\\n\" \"$0: Please tell bug-autoconf@gnu.org and\n$0: p.gen.progs@gmail.com about your system, including any\n$0: error possibly output before this message. Then install\n$0: a modern shell, or manually run the script under such a\n$0: shell if you do have one.\"\n  fi\n  exit 1\nfi ;;\nesac\nfi\nfi\nSHELL=${CONFIG_SHELL-/bin/sh}\nexport SHELL\n# Unset more variables known to interfere with behavior of common tools.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n## --------------------- ##\n## M4sh Shell Functions. ##\n## --------------------- ##\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`printf \"%s\\n\" \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null\nthen :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse case e in #(\n  e) as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  } ;;\nesac\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null\nthen :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse case e in #(\n  e) as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  } ;;\nesac\nfi # as_fn_arith\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  printf \"%s\\n\" \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n  as_lineno_1=$LINENO as_lineno_1a=$LINENO\n  as_lineno_2=$LINENO as_lineno_2a=$LINENO\n  eval 'test \"x$as_lineno_1'$as_run'\" != \"x$as_lineno_2'$as_run'\" &&\n  test \"x`expr $as_lineno_1'$as_run' + 1`\" = \"x$as_lineno_2'$as_run'\"' || {\n  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)\n  sed -n '\n    p\n    /[$]LINENO/=\n  ' <$as_myself |\n    sed '\n      t clear\n      :clear\n      s/[$]LINENO.*/&-/\n      t lineno\n      b\n      :lineno\n      N\n      :loop\n      s/[$]LINENO\\([^'$as_cr_alnum'_].*\\n\\)\\(.*\\)/\\2\\1\\2/\n      t loop\n      s/-\\n.*//\n    ' >$as_me.lineno &&\n  chmod +x \"$as_me.lineno\" ||\n    { printf \"%s\\n\" \"$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell\" >&2; as_fn_exit 1; }\n\n  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have\n  # already done that, so ensure we don't try to do so again and fall\n  # in an infinite loop.  This has already happened in practice.\n  _as_can_reexec=no; export _as_can_reexec\n  # Don't try to exec as it changes $[0], causing all sort of problems\n  # (the dirname of $[0] is not the place where we might find the\n  # original and so on.  Autoconf is especially sensitive to this).\n  . \"./$as_me.lineno\"\n  # Exit status is that of the last command.\n  exit\n}\n\n\n# Determine whether it's possible to make 'echo' print without a newline.\n# These variables are no longer used directly by Autoconf, but are AC_SUBSTed\n# for compatibility with existing Makefiles.\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\n# For backward compatibility with old third-party macros, we provide\n# the shell variables $as_echo and $as_echo_n.  New code should use\n# AS_ECHO([\"message\"]) and AS_ECHO_N([\"message\"]), respectively.\nas_echo='printf %s\\n'\nas_echo_n='printf %s'\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both 'ln -s file dir' and 'ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; 'ln -s' creates a wrapper executable.\n    # In both cases, we have to default to 'cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_sed_cpp=\"y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g\"\nas_tr_cpp=\"eval sed '$as_sed_cpp'\" # deprecated\n\n# Sed expression to map a string onto a valid variable name.\nas_sed_sh=\"y%*+%pp%;s%[^_$as_cr_alnum]%_%g\"\nas_tr_sh=\"eval sed '$as_sed_sh'\" # deprecated\n\n\ntest -n \"$DJDIR\" || exec 7<&0 </dev/null\nexec 6>&1\n\n# Name of the host.\n# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,\n# so uname gets run too.\nac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`\n\n#\n# Initializations.\n#\nac_default_prefix=/usr/local\nac_clean_files=\nac_config_libobj_dir=.\nLIBOBJS=\ncross_compiling=no\nsubdirs=\nMFLAGS=\nMAKEFLAGS=\n\n# Identity of this package.\nPACKAGE_NAME='smenu'\nPACKAGE_TARNAME='smenu'\nPACKAGE_VERSION='1.4.0'\nPACKAGE_STRING='smenu 1.4.0'\nPACKAGE_BUGREPORT='p.gen.progs@gmail.com'\nPACKAGE_URL=''\n\nac_unique_file=\"smenu.c\"\n# Factoring default headers for most tests.\nac_includes_default=\"\\\n#include <stddef.h>\n#ifdef HAVE_STDIO_H\n# include <stdio.h>\n#endif\n#ifdef HAVE_STDLIB_H\n# include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\"\n\nac_header_c_list=\nac_subst_vars='am__EXEEXT_FALSE\nam__EXEEXT_TRUE\nLTLIBOBJS\nLIBOBJS\nhost_os\nhost_vendor\nhost_cpu\nhost\nbuild_os\nbuild_vendor\nbuild_cpu\nbuild\nEGREP\nGREP\nLN_S\nam__fastdepCC_FALSE\nam__fastdepCC_TRUE\nCCDEPMODE\nam__nodep\nAMDEPBACKSLASH\nAMDEP_FALSE\nAMDEP_TRUE\nam__include\nDEPDIR\nOBJEXT\nEXEEXT\nac_ct_CC\nCPPFLAGS\nLDFLAGS\nCFLAGS\nCC\nam__xargs_n\nam__rm_f_notfound\nAM_BACKSLASH\nAM_DEFAULT_VERBOSITY\nAM_DEFAULT_V\nAM_V\nCSCOPE\nETAGS\nCTAGS\nam__untar\nam__tar\nAMTAR\nam__leading_dot\nSET_MAKE\nAWK\nmkdir_p\nMKDIR_P\nINSTALL_STRIP_PROGRAM\nSTRIP\ninstall_sh\nMAKEINFO\nAUTOHEADER\nAUTOMAKE\nAUTOCONF\nACLOCAL\nVERSION\nPACKAGE\nCYGPATH_W\nam__isrc\nINSTALL_DATA\nINSTALL_SCRIPT\nINSTALL_PROGRAM\ntarget_alias\nhost_alias\nbuild_alias\nLIBS\nECHO_T\nECHO_N\nECHO_C\nDEFS\nmandir\nlocaledir\nlibdir\npsdir\npdfdir\ndvidir\nhtmldir\ninfodir\ndocdir\noldincludedir\nincludedir\nrunstatedir\nlocalstatedir\nsharedstatedir\nsysconfdir\ndatadir\ndatarootdir\nlibexecdir\nsbindir\nbindir\nprogram_transform_name\nprefix\nexec_prefix\nPACKAGE_URL\nPACKAGE_BUGREPORT\nPACKAGE_STRING\nPACKAGE_VERSION\nPACKAGE_TARNAME\nPACKAGE_NAME\nPATH_SEPARATOR\nSHELL\nam__quote'\nac_subst_files=''\nac_user_opts='\nenable_option_checking\nenable_silent_rules\nenable_dependency_tracking\n'\n      ac_precious_vars='build_alias\nhost_alias\ntarget_alias\nCC\nCFLAGS\nLDFLAGS\nLIBS\nCPPFLAGS'\n\n\n# Initialize some variables set by options.\nac_init_help=\nac_init_version=false\nac_unrecognized_opts=\nac_unrecognized_sep=\n# The variables have the same names as the options, with\n# dashes changed to underlines.\ncache_file=/dev/null\nexec_prefix=NONE\nno_create=\nno_recursion=\nprefix=NONE\nprogram_prefix=NONE\nprogram_suffix=NONE\nprogram_transform_name=s,x,x,\nsilent=\nsite=\nsrcdir=\nverbose=\nx_includes=NONE\nx_libraries=NONE\n\n# Installation directory options.\n# These are left unexpanded so users can \"make install exec_prefix=/foo\"\n# and all the variables that are supposed to be based on exec_prefix\n# by default will actually change.\n# Use braces instead of parens because sh, perl, etc. also accept them.\n# (The list follows the same order as the GNU Coding Standards.)\nbindir='${exec_prefix}/bin'\nsbindir='${exec_prefix}/sbin'\nlibexecdir='${exec_prefix}/libexec'\ndatarootdir='${prefix}/share'\ndatadir='${datarootdir}'\nsysconfdir='${prefix}/etc'\nsharedstatedir='${prefix}/com'\nlocalstatedir='${prefix}/var'\nrunstatedir='${localstatedir}/run'\nincludedir='${prefix}/include'\noldincludedir='/usr/include'\ndocdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\ninfodir='${datarootdir}/info'\nhtmldir='${docdir}'\ndvidir='${docdir}'\npdfdir='${docdir}'\npsdir='${docdir}'\nlibdir='${exec_prefix}/lib'\nlocaledir='${datarootdir}/locale'\nmandir='${datarootdir}/man'\n\nac_prev=\nac_dashdash=\nfor ac_option\ndo\n  # If the previous option needs an argument, assign it.\n  if test -n \"$ac_prev\"; then\n    eval $ac_prev=\\$ac_option\n    ac_prev=\n    continue\n  fi\n\n  case $ac_option in\n  *=?*) ac_optarg=`expr \"X$ac_option\" : '[^=]*=\\(.*\\)'` ;;\n  *=)   ac_optarg= ;;\n  *)    ac_optarg=yes ;;\n  esac\n\n  case $ac_dashdash$ac_option in\n  --)\n    ac_dashdash=yes ;;\n\n  -bindir | --bindir | --bindi | --bind | --bin | --bi)\n    ac_prev=bindir ;;\n  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)\n    bindir=$ac_optarg ;;\n\n  -build | --build | --buil | --bui | --bu)\n    ac_prev=build_alias ;;\n  -build=* | --build=* | --buil=* | --bui=* | --bu=*)\n    build_alias=$ac_optarg ;;\n\n  -cache-file | --cache-file | --cache-fil | --cache-fi \\\n  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)\n    ac_prev=cache_file ;;\n  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \\\n  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)\n    cache_file=$ac_optarg ;;\n\n  --config-cache | -C)\n    cache_file=config.cache ;;\n\n  -datadir | --datadir | --datadi | --datad)\n    ac_prev=datadir ;;\n  -datadir=* | --datadir=* | --datadi=* | --datad=*)\n    datadir=$ac_optarg ;;\n\n  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \\\n  | --dataroo | --dataro | --datar)\n    ac_prev=datarootdir ;;\n  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \\\n  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)\n    datarootdir=$ac_optarg ;;\n\n  -disable-* | --disable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*disable-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: '$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=no ;;\n\n  -docdir | --docdir | --docdi | --doc | --do)\n    ac_prev=docdir ;;\n  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)\n    docdir=$ac_optarg ;;\n\n  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)\n    ac_prev=dvidir ;;\n  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)\n    dvidir=$ac_optarg ;;\n\n  -enable-* | --enable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*enable-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: '$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=\\$ac_optarg ;;\n\n  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \\\n  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \\\n  | --exec | --exe | --ex)\n    ac_prev=exec_prefix ;;\n  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \\\n  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \\\n  | --exec=* | --exe=* | --ex=*)\n    exec_prefix=$ac_optarg ;;\n\n  -gas | --gas | --ga | --g)\n    # Obsolete; use --with-gas.\n    with_gas=yes ;;\n\n  -help | --help | --hel | --he | -h)\n    ac_init_help=long ;;\n  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)\n    ac_init_help=recursive ;;\n  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)\n    ac_init_help=short ;;\n\n  -host | --host | --hos | --ho)\n    ac_prev=host_alias ;;\n  -host=* | --host=* | --hos=* | --ho=*)\n    host_alias=$ac_optarg ;;\n\n  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)\n    ac_prev=htmldir ;;\n  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \\\n  | --ht=*)\n    htmldir=$ac_optarg ;;\n\n  -includedir | --includedir | --includedi | --included | --include \\\n  | --includ | --inclu | --incl | --inc)\n    ac_prev=includedir ;;\n  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \\\n  | --includ=* | --inclu=* | --incl=* | --inc=*)\n    includedir=$ac_optarg ;;\n\n  -infodir | --infodir | --infodi | --infod | --info | --inf)\n    ac_prev=infodir ;;\n  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)\n    infodir=$ac_optarg ;;\n\n  -libdir | --libdir | --libdi | --libd)\n    ac_prev=libdir ;;\n  -libdir=* | --libdir=* | --libdi=* | --libd=*)\n    libdir=$ac_optarg ;;\n\n  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \\\n  | --libexe | --libex | --libe)\n    ac_prev=libexecdir ;;\n  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \\\n  | --libexe=* | --libex=* | --libe=*)\n    libexecdir=$ac_optarg ;;\n\n  -localedir | --localedir | --localedi | --localed | --locale)\n    ac_prev=localedir ;;\n  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)\n    localedir=$ac_optarg ;;\n\n  -localstatedir | --localstatedir | --localstatedi | --localstated \\\n  | --localstate | --localstat | --localsta | --localst | --locals)\n    ac_prev=localstatedir ;;\n  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \\\n  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)\n    localstatedir=$ac_optarg ;;\n\n  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)\n    ac_prev=mandir ;;\n  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)\n    mandir=$ac_optarg ;;\n\n  -nfp | --nfp | --nf)\n    # Obsolete; use --without-fp.\n    with_fp=no ;;\n\n  -no-create | --no-create | --no-creat | --no-crea | --no-cre \\\n  | --no-cr | --no-c | -n)\n    no_create=yes ;;\n\n  -no-recursion | --no-recursion | --no-recursio | --no-recursi \\\n  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)\n    no_recursion=yes ;;\n\n  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \\\n  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \\\n  | --oldin | --oldi | --old | --ol | --o)\n    ac_prev=oldincludedir ;;\n  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \\\n  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \\\n  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)\n    oldincludedir=$ac_optarg ;;\n\n  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)\n    ac_prev=prefix ;;\n  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)\n    prefix=$ac_optarg ;;\n\n  -program-prefix | --program-prefix | --program-prefi | --program-pref \\\n  | --program-pre | --program-pr | --program-p)\n    ac_prev=program_prefix ;;\n  -program-prefix=* | --program-prefix=* | --program-prefi=* \\\n  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)\n    program_prefix=$ac_optarg ;;\n\n  -program-suffix | --program-suffix | --program-suffi | --program-suff \\\n  | --program-suf | --program-su | --program-s)\n    ac_prev=program_suffix ;;\n  -program-suffix=* | --program-suffix=* | --program-suffi=* \\\n  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)\n    program_suffix=$ac_optarg ;;\n\n  -program-transform-name | --program-transform-name \\\n  | --program-transform-nam | --program-transform-na \\\n  | --program-transform-n | --program-transform- \\\n  | --program-transform | --program-transfor \\\n  | --program-transfo | --program-transf \\\n  | --program-trans | --program-tran \\\n  | --progr-tra | --program-tr | --program-t)\n    ac_prev=program_transform_name ;;\n  -program-transform-name=* | --program-transform-name=* \\\n  | --program-transform-nam=* | --program-transform-na=* \\\n  | --program-transform-n=* | --program-transform-=* \\\n  | --program-transform=* | --program-transfor=* \\\n  | --program-transfo=* | --program-transf=* \\\n  | --program-trans=* | --program-tran=* \\\n  | --progr-tra=* | --program-tr=* | --program-t=*)\n    program_transform_name=$ac_optarg ;;\n\n  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)\n    ac_prev=pdfdir ;;\n  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)\n    pdfdir=$ac_optarg ;;\n\n  -psdir | --psdir | --psdi | --psd | --ps)\n    ac_prev=psdir ;;\n  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)\n    psdir=$ac_optarg ;;\n\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil)\n    silent=yes ;;\n\n  -runstatedir | --runstatedir | --runstatedi | --runstated \\\n  | --runstate | --runstat | --runsta | --runst | --runs \\\n  | --run | --ru | --r)\n    ac_prev=runstatedir ;;\n  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \\\n  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \\\n  | --run=* | --ru=* | --r=*)\n    runstatedir=$ac_optarg ;;\n\n  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n    ac_prev=sbindir ;;\n  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n  | --sbi=* | --sb=*)\n    sbindir=$ac_optarg ;;\n\n  -sharedstatedir | --sharedstatedir | --sharedstatedi \\\n  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \\\n  | --sharedst | --shareds | --shared | --share | --shar \\\n  | --sha | --sh)\n    ac_prev=sharedstatedir ;;\n  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \\\n  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \\\n  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \\\n  | --sha=* | --sh=*)\n    sharedstatedir=$ac_optarg ;;\n\n  -site | --site | --sit)\n    ac_prev=site ;;\n  -site=* | --site=* | --sit=*)\n    site=$ac_optarg ;;\n\n  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n    ac_prev=srcdir ;;\n  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n    srcdir=$ac_optarg ;;\n\n  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \\\n  | --syscon | --sysco | --sysc | --sys | --sy)\n    ac_prev=sysconfdir ;;\n  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \\\n  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)\n    sysconfdir=$ac_optarg ;;\n\n  -target | --target | --targe | --targ | --tar | --ta | --t)\n    ac_prev=target_alias ;;\n  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)\n    target_alias=$ac_optarg ;;\n\n  -v | -verbose | --verbose | --verbos | --verbo | --verb)\n    verbose=yes ;;\n\n  -version | --version | --versio | --versi | --vers | -V)\n    ac_init_version=: ;;\n\n  -with-* | --with-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*with-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: '$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=\\$ac_optarg ;;\n\n  -without-* | --without-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*without-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: '$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=no ;;\n\n  --x)\n    # Obsolete; use --with-x.\n    with_x=yes ;;\n\n  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \\\n  | --x-incl | --x-inc | --x-in | --x-i)\n    ac_prev=x_includes ;;\n  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \\\n  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)\n    x_includes=$ac_optarg ;;\n\n  -x-libraries | --x-libraries | --x-librarie | --x-librari \\\n  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)\n    ac_prev=x_libraries ;;\n  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \\\n  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)\n    x_libraries=$ac_optarg ;;\n\n  -*) as_fn_error $? \"unrecognized option: '$ac_option'\nTry '$0 --help' for more information\"\n    ;;\n\n  *=*)\n    ac_envvar=`expr \"x$ac_option\" : 'x\\([^=]*\\)='`\n    # Reject names that are not valid shell variable names.\n    case $ac_envvar in #(\n      '' | [0-9]* | *[!_$as_cr_alnum]* )\n      as_fn_error $? \"invalid variable name: '$ac_envvar'\" ;;\n    esac\n    eval $ac_envvar=\\$ac_optarg\n    export $ac_envvar ;;\n\n  *)\n    # FIXME: should be removed in autoconf 3.0.\n    printf \"%s\\n\" \"$as_me: WARNING: you should use --build, --host, --target\" >&2\n    expr \"x$ac_option\" : \".*[^-._$as_cr_alnum]\" >/dev/null &&\n      printf \"%s\\n\" \"$as_me: WARNING: invalid host type: $ac_option\" >&2\n    : \"${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}\"\n    ;;\n\n  esac\ndone\n\nif test -n \"$ac_prev\"; then\n  ac_option=--`echo $ac_prev | sed 's/_/-/g'`\n  as_fn_error $? \"missing argument to $ac_option\"\nfi\n\nif test -n \"$ac_unrecognized_opts\"; then\n  case $enable_option_checking in\n    no) ;;\n    fatal) as_fn_error $? \"unrecognized options: $ac_unrecognized_opts\" ;;\n    *)     printf \"%s\\n\" \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2 ;;\n  esac\nfi\n\n# Check all directory arguments for consistency.\nfor ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n\t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n\t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n\t\tlibdir localedir mandir runstatedir\ndo\n  eval ac_val=\\$$ac_var\n  # Remove trailing slashes.\n  case $ac_val in\n    */ )\n      ac_val=`expr \"X$ac_val\" : 'X\\(.*[^/]\\)' \\| \"X$ac_val\" : 'X\\(.*\\)'`\n      eval $ac_var=\\$ac_val;;\n  esac\n  # Be sure to have absolute directory names.\n  case $ac_val in\n    [\\\\/$]* | ?:[\\\\/]* )  continue;;\n    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;\n  esac\n  as_fn_error $? \"expected an absolute directory name for --$ac_var: $ac_val\"\ndone\n\n# There might be people who depend on the old broken behavior: '$host'\n# used to hold the argument of --host etc.\n# FIXME: To remove some day.\nbuild=$build_alias\nhost=$host_alias\ntarget=$target_alias\n\n# FIXME: To remove some day.\nif test \"x$host_alias\" != x; then\n  if test \"x$build_alias\" = x; then\n    cross_compiling=maybe\n  elif test \"x$build_alias\" != \"x$host_alias\"; then\n    cross_compiling=yes\n  fi\nfi\n\nac_tool_prefix=\ntest -n \"$host_alias\" && ac_tool_prefix=$host_alias-\n\ntest \"$silent\" = yes && exec 6>/dev/null\n\n\nac_pwd=`pwd` && test -n \"$ac_pwd\" &&\nac_ls_di=`ls -di .` &&\nac_pwd_ls_di=`cd \"$ac_pwd\" && ls -di .` ||\n  as_fn_error $? \"working directory cannot be determined\"\ntest \"X$ac_ls_di\" = \"X$ac_pwd_ls_di\" ||\n  as_fn_error $? \"pwd does not report name of working directory\"\n\n\n# Find the source files, if location was not specified.\nif test -z \"$srcdir\"; then\n  ac_srcdir_defaulted=yes\n  # Try the directory containing this script, then the parent directory.\n  ac_confdir=`$as_dirname -- \"$as_myself\" ||\n$as_expr X\"$as_myself\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_myself\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_myself\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  srcdir=$ac_confdir\n  if test ! -r \"$srcdir/$ac_unique_file\"; then\n    srcdir=..\n  fi\nelse\n  ac_srcdir_defaulted=no\nfi\nif test ! -r \"$srcdir/$ac_unique_file\"; then\n  test \"$ac_srcdir_defaulted\" = yes && srcdir=\"$ac_confdir or ..\"\n  as_fn_error $? \"cannot find sources ($ac_unique_file) in $srcdir\"\nfi\nac_msg=\"sources are in $srcdir, but 'cd $srcdir' does not work\"\nac_abs_confdir=`(\n\tcd \"$srcdir\" && test -r \"./$ac_unique_file\" || as_fn_error $? \"$ac_msg\"\n\tpwd)`\n# When building in place, set srcdir=.\nif test \"$ac_abs_confdir\" = \"$ac_pwd\"; then\n  srcdir=.\nfi\n# Remove unnecessary trailing slashes from srcdir.\n# Double slashes in file names in object file debugging info\n# mess up M-x gdb in Emacs.\ncase $srcdir in\n*/) srcdir=`expr \"X$srcdir\" : 'X\\(.*[^/]\\)' \\| \"X$srcdir\" : 'X\\(.*\\)'`;;\nesac\nfor ac_var in $ac_precious_vars; do\n  eval ac_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_env_${ac_var}_value=\\$${ac_var}\n  eval ac_cv_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_cv_env_${ac_var}_value=\\$${ac_var}\ndone\n\n#\n# Report the --help message.\n#\nif test \"$ac_init_help\" = \"long\"; then\n  # Omit some internal or obsolete options to make the list less imposing.\n  # This message is too long to be a string in the A/UX 3.1 sh.\n  cat <<_ACEOF\n'configure' configures smenu 1.4.0 to adapt to many kinds of systems.\n\nUsage: $0 [OPTION]... [VAR=VALUE]...\n\nTo assign environment variables (e.g., CC, CFLAGS...), specify them as\nVAR=VALUE.  See below for descriptions of some of the useful variables.\n\nDefaults for the options are specified in brackets.\n\nConfiguration:\n  -h, --help              display this help and exit\n      --help=short        display options specific to this package\n      --help=recursive    display the short help of all the included packages\n  -V, --version           display version information and exit\n  -q, --quiet, --silent   do not print 'checking ...' messages\n      --cache-file=FILE   cache test results in FILE [disabled]\n  -C, --config-cache      alias for '--cache-file=config.cache'\n  -n, --no-create         do not create output files\n      --srcdir=DIR        find the sources in DIR [configure dir or '..']\n\nInstallation directories:\n  --prefix=PREFIX         install architecture-independent files in PREFIX\n                          [$ac_default_prefix]\n  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n                          [PREFIX]\n\nBy default, 'make install' will install all the files in\n'$ac_default_prefix/bin', '$ac_default_prefix/lib' etc.  You can specify\nan installation prefix other than '$ac_default_prefix' using '--prefix',\nfor instance '--prefix=\\$HOME'.\n\nFor better control, use the options below.\n\nFine tuning of the installation directories:\n  --bindir=DIR            user executables [EPREFIX/bin]\n  --sbindir=DIR           system admin executables [EPREFIX/sbin]\n  --libexecdir=DIR        program executables [EPREFIX/libexec]\n  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]\n  --libdir=DIR            object code libraries [EPREFIX/lib]\n  --includedir=DIR        C header files [PREFIX/include]\n  --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]\n  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]\n  --infodir=DIR           info documentation [DATAROOTDIR/info]\n  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]\n  --mandir=DIR            man documentation [DATAROOTDIR/man]\n  --docdir=DIR            documentation root [DATAROOTDIR/doc/smenu]\n  --htmldir=DIR           html documentation [DOCDIR]\n  --dvidir=DIR            dvi documentation [DOCDIR]\n  --pdfdir=DIR            pdf documentation [DOCDIR]\n  --psdir=DIR             ps documentation [DOCDIR]\n_ACEOF\n\n  cat <<\\_ACEOF\n\nProgram names:\n  --program-prefix=PREFIX            prepend PREFIX to installed program names\n  --program-suffix=SUFFIX            append SUFFIX to installed program names\n  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names\n\nSystem types:\n  --build=BUILD     configure for building on BUILD [guessed]\n  --host=HOST       cross-compile to build programs to run on HOST [BUILD]\n_ACEOF\nfi\n\nif test -n \"$ac_init_help\"; then\n  case $ac_init_help in\n     short | recursive ) echo \"Configuration of smenu 1.4.0:\";;\n   esac\n  cat <<\\_ACEOF\n\nOptional Features:\n  --disable-option-checking  ignore unrecognized --enable/--with options\n  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)\n  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]\n  --enable-silent-rules   less verbose build output (undo: \"make V=1\")\n  --disable-silent-rules  verbose build output (undo: \"make V=0\")\n  --enable-dependency-tracking\n                          do not reject slow dependency extractors\n  --disable-dependency-tracking\n                          speeds up one-time build\n\nSome influential environment variables:\n  CC          C compiler command\n  CFLAGS      C compiler flags\n  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a\n              nonstandard directory <lib dir>\n  LIBS        libraries to pass to the linker, e.g. -l<library>\n  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if\n              you have headers in a nonstandard directory <include dir>\n\nUse these variables to override the choices made by 'configure' or to help\nit to find libraries and programs with nonstandard names/locations.\n\nReport bugs to <p.gen.progs@gmail.com>.\n_ACEOF\nac_status=$?\nfi\n\nif test \"$ac_init_help\" = \"recursive\"; then\n  # If there are subdirs, report their specific --help.\n  for ac_dir in : $ac_subdirs_all; do test \"x$ac_dir\" = x: && continue\n    test -d \"$ac_dir\" ||\n      { cd \"$srcdir\" && ac_pwd=`pwd` && srcdir=. && test -d \"$ac_dir\"; } ||\n      continue\n    ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`printf \"%s\\n\" \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`printf \"%s\\n\" \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n    cd \"$ac_dir\" || { ac_status=$?; continue; }\n    # Check for configure.gnu first; this name is used for a wrapper for\n    # Metaconfig's \"Configure\" on case-insensitive file systems.\n    if test -f \"$ac_srcdir/configure.gnu\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure.gnu\" --help=recursive\n    elif test -f \"$ac_srcdir/configure\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure\" --help=recursive\n    else\n      printf \"%s\\n\" \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n    fi || ac_status=$?\n    cd \"$ac_pwd\" || { ac_status=$?; break; }\n  done\nfi\n\ntest -n \"$ac_init_help\" && exit $ac_status\nif $ac_init_version; then\n  cat <<\\_ACEOF\nsmenu configure 1.4.0\ngenerated by GNU Autoconf 2.72\n\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis configure script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\n_ACEOF\n  exit\nfi\n\n## ------------------------ ##\n## Autoconf initialization. ##\n## ------------------------ ##\n\n# ac_fn_c_try_compile LINENO\n# --------------------------\n# Try to compile conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext conftest.beam\n  if { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest.$ac_objext\nthen :\n  ac_retval=0\nelse case e in #(\n  e) printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1 ;;\nesac\nfi\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_compile\n\n# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES\n# -------------------------------------------------------\n# Tests whether HEADER exists and can be compiled using the include files in\n# INCLUDES, setting the cache variable VAR accordingly.\nac_fn_c_check_header_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\n#include <$2>\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  eval \"$3=yes\"\nelse case e in #(\n  e) eval \"$3=no\" ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_header_compile\n\n# ac_fn_c_try_link LINENO\n# -----------------------\n# Try to link conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_link ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext conftest.beam conftest$ac_exeext\n  if { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest$ac_exeext && {\n\t test \"$cross_compiling\" = yes ||\n\t test -x conftest$ac_exeext\n       }\nthen :\n  ac_retval=0\nelse case e in #(\n  e) printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1 ;;\nesac\nfi\n  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information\n  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would\n  # interfere with the next link command; also delete a directory that is\n  # left behind by Apple's compiler.  We do this before executing the actions.\n  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_link\n\n# ac_fn_c_check_type LINENO TYPE VAR INCLUDES\n# -------------------------------------------\n# Tests whether TYPE exists after having included INCLUDES, setting cache\n# variable VAR accordingly.\nac_fn_c_check_type ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) eval \"$3=no\"\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\nint\nmain (void)\n{\nif (sizeof ($2))\n\t return 0;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\nint\nmain (void)\n{\nif (sizeof (($2)))\n\t    return 0;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse case e in #(\n  e) eval \"$3=yes\" ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_type\n\n# ac_fn_c_try_run LINENO\n# ----------------------\n# Try to run conftest.$ac_ext, and return whether this succeeded. Assumes that\n# executables *can* be run.\nac_fn_c_try_run ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  if { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'\n  { { case \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_try\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; }\nthen :\n  ac_retval=0\nelse case e in #(\n  e) printf \"%s\\n\" \"$as_me: program exited with status $ac_status\" >&5\n       printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n       ac_retval=$ac_status ;;\nesac\nfi\n  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_run\n\n# ac_fn_c_check_func LINENO FUNC VAR\n# ----------------------------------\n# Tests whether FUNC exists, setting the cache variable VAR accordingly\nac_fn_c_check_func ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n/* Define $2 to an innocuous variant, in case <limits.h> declares $2.\n   For example, HP-UX 11i <limits.h> declares gettimeofday.  */\n#define $2 innocuous_$2\n\n/* System header to define __stub macros and hopefully few prototypes,\n   which can conflict with char $2 (void); below.  */\n\n#include <limits.h>\n#undef $2\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar $2 (void);\n/* The GNU C library defines this for functions which it implements\n    to always fail with ENOSYS.  Some functions are actually named\n    something starting with __ and the normal name is an alias.  */\n#if defined __stub_$2 || defined __stub___$2\nchoke me\n#endif\n\nint\nmain (void)\n{\nreturn $2 ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"\nthen :\n  eval \"$3=yes\"\nelse case e in #(\n  e) eval \"$3=no\" ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext conftest.$ac_ext ;;\nesac\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_func\nac_configure_args_raw=\nfor ac_arg\ndo\n  case $ac_arg in\n  *\\'*)\n    ac_arg=`printf \"%s\\n\" \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n  esac\n  as_fn_append ac_configure_args_raw \" '$ac_arg'\"\ndone\n\ncase $ac_configure_args_raw in\n  *$as_nl*)\n    ac_safe_unquote= ;;\n  *)\n    ac_unsafe_z='|&;<>()$`\\\\\"*?[ ''\t' # This string ends in space, tab.\n    ac_unsafe_a=\"$ac_unsafe_z#~\"\n    ac_safe_unquote=\"s/ '\\\\([^$ac_unsafe_a][^$ac_unsafe_z]*\\\\)'/ \\\\1/g\"\n    ac_configure_args_raw=`      printf \"%s\\n\" \"$ac_configure_args_raw\" | sed \"$ac_safe_unquote\"`;;\nesac\n\ncat >config.log <<_ACEOF\nThis file contains any messages produced by compilers while\nrunning configure, to aid debugging if configure makes a mistake.\n\nIt was created by smenu $as_me 1.4.0, which was\ngenerated by GNU Autoconf 2.72.  Invocation command line was\n\n  $ $0$ac_configure_args_raw\n\n_ACEOF\nexec 5>>config.log\n{\ncat <<_ASUNAME\n## --------- ##\n## Platform. ##\n## --------- ##\n\nhostname = `(hostname || uname -n) 2>/dev/null | sed 1q`\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`\n\n/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`\n/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`\n/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`\n/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`\n\n_ASUNAME\n\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    printf \"%s\\n\" \"PATH: $as_dir\"\n  done\nIFS=$as_save_IFS\n\n} >&5\n\ncat >&5 <<_ACEOF\n\n\n## ----------- ##\n## Core tests. ##\n## ----------- ##\n\n_ACEOF\n\n\n# Keep a trace of the command line.\n# Strip out --no-create and --no-recursion so they do not pile up.\n# Strip out --silent because we don't want to record it for future runs.\n# Also quote any args containing shell meta-characters.\n# Make two passes to allow for proper duplicate-argument suppression.\nac_configure_args=\nac_configure_args0=\nac_configure_args1=\nac_must_keep_next=false\nfor ac_pass in 1 2\ndo\n  for ac_arg\n  do\n    case $ac_arg in\n    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;\n    -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n    | -silent | --silent | --silen | --sile | --sil)\n      continue ;;\n    *\\'*)\n      ac_arg=`printf \"%s\\n\" \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    case $ac_pass in\n    1) as_fn_append ac_configure_args0 \" '$ac_arg'\" ;;\n    2)\n      as_fn_append ac_configure_args1 \" '$ac_arg'\"\n      if test $ac_must_keep_next = true; then\n\tac_must_keep_next=false # Got value, back to normal.\n      else\n\tcase $ac_arg in\n\t  *=* | --config-cache | -C | -disable-* | --disable-* \\\n\t  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \\\n\t  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \\\n\t  | -with-* | --with-* | -without-* | --without-* | --x)\n\t    case \"$ac_configure_args0 \" in\n\t      \"$ac_configure_args1\"*\" '$ac_arg' \"* ) continue ;;\n\t    esac\n\t    ;;\n\t  -* ) ac_must_keep_next=true ;;\n\tesac\n      fi\n      as_fn_append ac_configure_args \" '$ac_arg'\"\n      ;;\n    esac\n  done\ndone\n{ ac_configure_args0=; unset ac_configure_args0;}\n{ ac_configure_args1=; unset ac_configure_args1;}\n\n# When interrupted or exit'd, cleanup temporary files, and complete\n# config.log.  We remove comments because anyway the quotes in there\n# would cause problems or look ugly.\n# WARNING: Use '\\'' to represent an apostrophe within the trap.\n# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.\ntrap 'exit_status=$?\n  # Sanitize IFS.\n  IFS=\" \"\"\t$as_nl\"\n  # Save into config.log some information that might help in debugging.\n  {\n    echo\n\n    printf \"%s\\n\" \"## ---------------- ##\n## Cache variables. ##\n## ---------------- ##\"\n    echo\n    # The following way of writing the cache mishandles newlines in values,\n(\n  for ac_var in `(set) 2>&1 | sed -n '\\''s/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'\\''`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n  (set) 2>&1 |\n    case $as_nl`(ac_space='\\'' '\\''; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      sed -n \\\n\t\"s/'\\''/'\\''\\\\\\\\'\\'''\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\''\\\\2'\\''/p\"\n      ;; #(\n    *)\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n)\n    echo\n\n    printf \"%s\\n\" \"## ----------------- ##\n## Output variables. ##\n## ----------------- ##\"\n    echo\n    for ac_var in $ac_subst_vars\n    do\n      eval ac_val=\\$$ac_var\n      case $ac_val in\n      *\\'\\''*) ac_val=`printf \"%s\\n\" \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n      esac\n      printf \"%s\\n\" \"$ac_var='\\''$ac_val'\\''\"\n    done | sort\n    echo\n\n    if test -n \"$ac_subst_files\"; then\n      printf \"%s\\n\" \"## ------------------- ##\n## File substitutions. ##\n## ------------------- ##\"\n      echo\n      for ac_var in $ac_subst_files\n      do\n\teval ac_val=\\$$ac_var\n\tcase $ac_val in\n\t*\\'\\''*) ac_val=`printf \"%s\\n\" \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n\tesac\n\tprintf \"%s\\n\" \"$ac_var='\\''$ac_val'\\''\"\n      done | sort\n      echo\n    fi\n\n    if test -s confdefs.h; then\n      printf \"%s\\n\" \"## ----------- ##\n## confdefs.h. ##\n## ----------- ##\"\n      echo\n      cat confdefs.h\n      echo\n    fi\n    test \"$ac_signal\" != 0 &&\n      printf \"%s\\n\" \"$as_me: caught signal $ac_signal\"\n    printf \"%s\\n\" \"$as_me: exit $exit_status\"\n  } >&5\n  rm -f core *.core core.conftest.* &&\n    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&\n    exit $exit_status\n' 0\nfor ac_signal in 1 2 13 15; do\n  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal\ndone\nac_signal=0\n\n# confdefs.h avoids OS command line length limits that DEFS can exceed.\nrm -f -r conftest* confdefs.h\n\nprintf \"%s\\n\" \"/* confdefs.h */\" > confdefs.h\n\n# Predefined preprocessor variables.\n\nprintf \"%s\\n\" \"#define PACKAGE_NAME \\\"$PACKAGE_NAME\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_TARNAME \\\"$PACKAGE_TARNAME\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_VERSION \\\"$PACKAGE_VERSION\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_STRING \\\"$PACKAGE_STRING\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_BUGREPORT \\\"$PACKAGE_BUGREPORT\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_URL \\\"$PACKAGE_URL\\\"\" >>confdefs.h\n\n\n# Let the site file select an alternate cache file if it wants to.\n# Prefer an explicitly selected file to automatically selected ones.\nif test -n \"$CONFIG_SITE\"; then\n  ac_site_files=\"$CONFIG_SITE\"\nelif test \"x$prefix\" != xNONE; then\n  ac_site_files=\"$prefix/share/config.site $prefix/etc/config.site\"\nelse\n  ac_site_files=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\nfi\n\nfor ac_site_file in $ac_site_files\ndo\n  case $ac_site_file in #(\n  */*) :\n     ;; #(\n  *) :\n    ac_site_file=./$ac_site_file ;;\nesac\n  if test -f \"$ac_site_file\" && test -r \"$ac_site_file\"; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file\" >&5\nprintf \"%s\\n\" \"$as_me: loading site script $ac_site_file\" >&6;}\n    sed 's/^/| /' \"$ac_site_file\" >&5\n    . \"$ac_site_file\" \\\n      || { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"failed to load site script $ac_site_file\nSee 'config.log' for more details\" \"$LINENO\" 5; }\n  fi\ndone\n\nif test -r \"$cache_file\"; then\n  # Some versions of bash will fail to source /dev/null (special files\n  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.\n  if test /dev/null != \"$cache_file\" && test -f \"$cache_file\"; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: loading cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: loading cache $cache_file\" >&6;}\n    case $cache_file in\n      [\\\\/]* | ?:[\\\\/]* ) . \"$cache_file\";;\n      *)                      . \"./$cache_file\";;\n    esac\n  fi\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: creating cache $cache_file\" >&6;}\n  >$cache_file\nfi\n\nas_fn_append ac_header_c_list \" stdio.h stdio_h HAVE_STDIO_H\"\n# Test code for whether the C compiler supports C89 (global declarations)\nac_c_conftest_c89_globals='\n/* Does the compiler advertise C89 conformance?\n   Do not test the value of __STDC__, because some compilers set it to 0\n   while being otherwise adequately conformant. */\n#if !defined __STDC__\n# error \"Compiler does not advertise C89 conformance\"\n#endif\n\n#include <stddef.h>\n#include <stdarg.h>\nstruct stat;\n/* Most of the following tests are stolen from RCS 5.7 src/conf.sh.  */\nstruct buf { int x; };\nstruct buf * (*rcsopen) (struct buf *, struct stat *, int);\nstatic char *e (char **p, int i)\n{\n  return p[i];\n}\nstatic char *f (char * (*g) (char **, int), char **p, ...)\n{\n  char *s;\n  va_list v;\n  va_start (v,p);\n  s = g (p, va_arg (v,int));\n  va_end (v);\n  return s;\n}\n\n/* C89 style stringification. */\n#define noexpand_stringify(a) #a\nconst char *stringified = noexpand_stringify(arbitrary+token=sequence);\n\n/* C89 style token pasting.  Exercises some of the corner cases that\n   e.g. old MSVC gets wrong, but not very hard. */\n#define noexpand_concat(a,b) a##b\n#define expand_concat(a,b) noexpand_concat(a,b)\nextern int vA;\nextern int vbee;\n#define aye A\n#define bee B\nint *pvA = &expand_concat(v,aye);\nint *pvbee = &noexpand_concat(v,bee);\n\n/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has\n   function prototypes and stuff, but not \\xHH hex character constants.\n   These do not provoke an error unfortunately, instead are silently treated\n   as an \"x\".  The following induces an error, until -std is added to get\n   proper ANSI mode.  Curiously \\x00 != x always comes out true, for an\n   array size at least.  It is necessary to write \\x00 == 0 to get something\n   that is true only with -std.  */\nint osf4_cc_array ['\\''\\x00'\\'' == 0 ? 1 : -1];\n\n/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters\n   inside strings and character constants.  */\n#define FOO(x) '\\''x'\\''\nint xlc6_cc_array[FOO(a) == '\\''x'\\'' ? 1 : -1];\n\nint test (int i, double x);\nstruct s1 {int (*f) (int a);};\nstruct s2 {int (*f) (double a);};\nint pairnames (int, char **, int *(*)(struct buf *, struct stat *, int),\n               int, int);'\n\n# Test code for whether the C compiler supports C89 (body of main).\nac_c_conftest_c89_main='\nok |= (argc == 0 || f (e, argv, 0) != argv[0] || f (e, argv, 1) != argv[1]);\n'\n\n# Test code for whether the C compiler supports C99 (global declarations)\nac_c_conftest_c99_globals='\n/* Does the compiler advertise C99 conformance? */\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L\n# error \"Compiler does not advertise C99 conformance\"\n#endif\n\n// See if C++-style comments work.\n\n#include <stdbool.h>\nextern int puts (const char *);\nextern int printf (const char *, ...);\nextern int dprintf (int, const char *, ...);\nextern void *malloc (size_t);\nextern void free (void *);\n\n// Check varargs macros.  These examples are taken from C99 6.10.3.5.\n// dprintf is used instead of fprintf to avoid needing to declare\n// FILE and stderr.\n#define debug(...) dprintf (2, __VA_ARGS__)\n#define showlist(...) puts (#__VA_ARGS__)\n#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))\nstatic void\ntest_varargs_macros (void)\n{\n  int x = 1234;\n  int y = 5678;\n  debug (\"Flag\");\n  debug (\"X = %d\\n\", x);\n  showlist (The first, second, and third items.);\n  report (x>y, \"x is %d but y is %d\", x, y);\n}\n\n// Check long long types.\n#define BIG64 18446744073709551615ull\n#define BIG32 4294967295ul\n#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)\n#if !BIG_OK\n  #error \"your preprocessor is broken\"\n#endif\n#if BIG_OK\n#else\n  #error \"your preprocessor is broken\"\n#endif\nstatic long long int bignum = -9223372036854775807LL;\nstatic unsigned long long int ubignum = BIG64;\n\nstruct incomplete_array\n{\n  int datasize;\n  double data[];\n};\n\nstruct named_init {\n  int number;\n  const wchar_t *name;\n  double average;\n};\n\ntypedef const char *ccp;\n\nstatic inline int\ntest_restrict (ccp restrict text)\n{\n  // Iterate through items via the restricted pointer.\n  // Also check for declarations in for loops.\n  for (unsigned int i = 0; *(text+i) != '\\''\\0'\\''; ++i)\n    continue;\n  return 0;\n}\n\n// Check varargs and va_copy.\nstatic bool\ntest_varargs (const char *format, ...)\n{\n  va_list args;\n  va_start (args, format);\n  va_list args_copy;\n  va_copy (args_copy, args);\n\n  const char *str = \"\";\n  int number = 0;\n  float fnumber = 0;\n\n  while (*format)\n    {\n      switch (*format++)\n\t{\n\tcase '\\''s'\\'': // string\n\t  str = va_arg (args_copy, const char *);\n\t  break;\n\tcase '\\''d'\\'': // int\n\t  number = va_arg (args_copy, int);\n\t  break;\n\tcase '\\''f'\\'': // float\n\t  fnumber = va_arg (args_copy, double);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n  va_end (args_copy);\n  va_end (args);\n\n  return *str && number && fnumber;\n}\n'\n\n# Test code for whether the C compiler supports C99 (body of main).\nac_c_conftest_c99_main='\n  // Check bool.\n  _Bool success = false;\n  success |= (argc != 0);\n\n  // Check restrict.\n  if (test_restrict (\"String literal\") == 0)\n    success = true;\n  char *restrict newvar = \"Another string\";\n\n  // Check varargs.\n  success &= test_varargs (\"s, d'\\'' f .\", \"string\", 65, 34.234);\n  test_varargs_macros ();\n\n  // Check flexible array members.\n  struct incomplete_array *ia =\n    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));\n  ia->datasize = 10;\n  for (int i = 0; i < ia->datasize; ++i)\n    ia->data[i] = i * 1.234;\n  // Work around memory leak warnings.\n  free (ia);\n\n  // Check named initializers.\n  struct named_init ni = {\n    .number = 34,\n    .name = L\"Test wide string\",\n    .average = 543.34343,\n  };\n\n  ni.number = 58;\n\n  int dynamic_array[ni.number];\n  dynamic_array[0] = argv[0][0];\n  dynamic_array[ni.number - 1] = 543;\n\n  // work around unused variable warnings\n  ok |= (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == '\\''x'\\''\n\t || dynamic_array[ni.number - 1] != 543);\n'\n\n# Test code for whether the C compiler supports C11 (global declarations)\nac_c_conftest_c11_globals='\n/* Does the compiler advertise C11 conformance? */\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L\n# error \"Compiler does not advertise C11 conformance\"\n#endif\n\n// Check _Alignas.\nchar _Alignas (double) aligned_as_double;\nchar _Alignas (0) no_special_alignment;\nextern char aligned_as_int;\nchar _Alignas (0) _Alignas (int) aligned_as_int;\n\n// Check _Alignof.\nenum\n{\n  int_alignment = _Alignof (int),\n  int_array_alignment = _Alignof (int[100]),\n  char_alignment = _Alignof (char)\n};\n_Static_assert (0 < -_Alignof (int), \"_Alignof is signed\");\n\n// Check _Noreturn.\nint _Noreturn does_not_return (void) { for (;;) continue; }\n\n// Check _Static_assert.\nstruct test_static_assert\n{\n  int x;\n  _Static_assert (sizeof (int) <= sizeof (long int),\n                  \"_Static_assert does not work in struct\");\n  long int y;\n};\n\n// Check UTF-8 literals.\n#define u8 syntax error!\nchar const utf8_literal[] = u8\"happens to be ASCII\" \"another string\";\n\n// Check duplicate typedefs.\ntypedef long *long_ptr;\ntypedef long int *long_ptr;\ntypedef long_ptr long_ptr;\n\n// Anonymous structures and unions -- taken from C11 6.7.2.1 Example 1.\nstruct anonymous\n{\n  union {\n    struct { int i; int j; };\n    struct { int k; long int l; } w;\n  };\n  int m;\n} v1;\n'\n\n# Test code for whether the C compiler supports C11 (body of main).\nac_c_conftest_c11_main='\n  _Static_assert ((offsetof (struct anonymous, i)\n\t\t   == offsetof (struct anonymous, w.k)),\n\t\t  \"Anonymous union alignment botch\");\n  v1.i = 2;\n  v1.w.k = 5;\n  ok |= v1.i != 5;\n'\n\n# Test code for whether the C compiler supports C11 (complete).\nac_c_conftest_c11_program=\"${ac_c_conftest_c89_globals}\n${ac_c_conftest_c99_globals}\n${ac_c_conftest_c11_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  ${ac_c_conftest_c99_main}\n  ${ac_c_conftest_c11_main}\n  return ok;\n}\n\"\n\n# Test code for whether the C compiler supports C99 (complete).\nac_c_conftest_c99_program=\"${ac_c_conftest_c89_globals}\n${ac_c_conftest_c99_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  ${ac_c_conftest_c99_main}\n  return ok;\n}\n\"\n\n# Test code for whether the C compiler supports C89 (complete).\nac_c_conftest_c89_program=\"${ac_c_conftest_c89_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  return ok;\n}\n\"\n\nas_fn_append ac_header_c_list \" stdlib.h stdlib_h HAVE_STDLIB_H\"\nas_fn_append ac_header_c_list \" string.h string_h HAVE_STRING_H\"\nas_fn_append ac_header_c_list \" inttypes.h inttypes_h HAVE_INTTYPES_H\"\nas_fn_append ac_header_c_list \" stdint.h stdint_h HAVE_STDINT_H\"\nas_fn_append ac_header_c_list \" strings.h strings_h HAVE_STRINGS_H\"\nas_fn_append ac_header_c_list \" sys/stat.h sys_stat_h HAVE_SYS_STAT_H\"\nas_fn_append ac_header_c_list \" sys/types.h sys_types_h HAVE_SYS_TYPES_H\"\nas_fn_append ac_header_c_list \" unistd.h unistd_h HAVE_UNISTD_H\"\nas_fn_append ac_header_c_list \" wchar.h wchar_h HAVE_WCHAR_H\"\nas_fn_append ac_header_c_list \" minix/config.h minix_config_h HAVE_MINIX_CONFIG_H\"\n\n# Auxiliary files required by this configure script.\nac_aux_files=\"config.guess config.sub compile missing install-sh\"\n\n# Locations in which to look for auxiliary files.\nac_aux_dir_candidates=\"${srcdir}/build-aux\"\n\n# Search for a directory containing all of the required auxiliary files,\n# $ac_aux_files, from the $PATH-style list $ac_aux_dir_candidates.\n# If we don't find one directory that contains all the files we need,\n# we report the set of missing files from the *first* directory in\n# $ac_aux_dir_candidates and give up.\nac_missing_aux_files=\"\"\nac_first_candidate=:\nprintf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: looking for aux files: $ac_aux_files\" >&5\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nas_found=false\nfor as_dir in $ac_aux_dir_candidates\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n  as_found=:\n\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:  trying $as_dir\" >&5\n  ac_aux_dir_found=yes\n  ac_install_sh=\n  for ac_aux in $ac_aux_files\n  do\n    # As a special case, if \"install-sh\" is required, that requirement\n    # can be satisfied by any of \"install-sh\", \"install.sh\", or \"shtool\",\n    # and $ac_install_sh is set appropriately for whichever one is found.\n    if test x\"$ac_aux\" = x\"install-sh\"\n    then\n      if test -f \"${as_dir}install-sh\"; then\n        printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   ${as_dir}install-sh found\" >&5\n        ac_install_sh=\"${as_dir}install-sh -c\"\n      elif test -f \"${as_dir}install.sh\"; then\n        printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   ${as_dir}install.sh found\" >&5\n        ac_install_sh=\"${as_dir}install.sh -c\"\n      elif test -f \"${as_dir}shtool\"; then\n        printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   ${as_dir}shtool found\" >&5\n        ac_install_sh=\"${as_dir}shtool install -c\"\n      else\n        ac_aux_dir_found=no\n        if $ac_first_candidate; then\n          ac_missing_aux_files=\"${ac_missing_aux_files} install-sh\"\n        else\n          break\n        fi\n      fi\n    else\n      if test -f \"${as_dir}${ac_aux}\"; then\n        printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   ${as_dir}${ac_aux} found\" >&5\n      else\n        ac_aux_dir_found=no\n        if $ac_first_candidate; then\n          ac_missing_aux_files=\"${ac_missing_aux_files} ${ac_aux}\"\n        else\n          break\n        fi\n      fi\n    fi\n  done\n  if test \"$ac_aux_dir_found\" = yes; then\n    ac_aux_dir=\"$as_dir\"\n    break\n  fi\n  ac_first_candidate=false\n\n  as_found=false\ndone\nIFS=$as_save_IFS\nif $as_found\nthen :\n\nelse case e in #(\n  e) as_fn_error $? \"cannot find required auxiliary files:$ac_missing_aux_files\" \"$LINENO\" 5 ;;\nesac\nfi\n\n\n# These three variables are undocumented and unsupported,\n# and are intended to be withdrawn in a future Autoconf release.\n# They can cause serious problems if a builder's source tree is in a directory\n# whose full name contains unusual characters.\nif test -f \"${ac_aux_dir}config.guess\"; then\n  ac_config_guess=\"$SHELL ${ac_aux_dir}config.guess\"\nfi\nif test -f \"${ac_aux_dir}config.sub\"; then\n  ac_config_sub=\"$SHELL ${ac_aux_dir}config.sub\"\nfi\nif test -f \"$ac_aux_dir/configure\"; then\n  ac_configure=\"$SHELL ${ac_aux_dir}configure\"\nfi\n\n# Check that the precious variables saved in the cache have kept the same\n# value.\nac_cache_corrupted=false\nfor ac_var in $ac_precious_vars; do\n  eval ac_old_set=\\$ac_cv_env_${ac_var}_set\n  eval ac_new_set=\\$ac_env_${ac_var}_set\n  eval ac_old_val=\\$ac_cv_env_${ac_var}_value\n  eval ac_new_val=\\$ac_env_${ac_var}_value\n  case $ac_old_set,$ac_new_set in\n    set,)\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: '$ac_var' was set to '$ac_old_val' in the previous run\" >&5\nprintf \"%s\\n\" \"$as_me: error: '$ac_var' was set to '$ac_old_val' in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,set)\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: '$ac_var' was not set in the previous run\" >&5\nprintf \"%s\\n\" \"$as_me: error: '$ac_var' was not set in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,);;\n    *)\n      if test \"x$ac_old_val\" != \"x$ac_new_val\"; then\n\t# differences in whitespace do not lead to failure.\n\tac_old_val_w=`echo x $ac_old_val`\n\tac_new_val_w=`echo x $ac_new_val`\n\tif test \"$ac_old_val_w\" != \"$ac_new_val_w\"; then\n\t  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: '$ac_var' has changed since the previous run:\" >&5\nprintf \"%s\\n\" \"$as_me: error: '$ac_var' has changed since the previous run:\" >&2;}\n\t  ac_cache_corrupted=:\n\telse\n\t  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in '$ac_var' since the previous run:\" >&5\nprintf \"%s\\n\" \"$as_me: warning: ignoring whitespace changes in '$ac_var' since the previous run:\" >&2;}\n\t  eval $ac_var=\\$ac_old_val\n\tfi\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   former value:  '$ac_old_val'\" >&5\nprintf \"%s\\n\" \"$as_me:   former value:  '$ac_old_val'\" >&2;}\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   current value: '$ac_new_val'\" >&5\nprintf \"%s\\n\" \"$as_me:   current value: '$ac_new_val'\" >&2;}\n      fi;;\n  esac\n  # Pass precious variables to config.status.\n  if test \"$ac_new_set\" = set; then\n    case $ac_new_val in\n    *\\'*) ac_arg=$ac_var=`printf \"%s\\n\" \"$ac_new_val\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    *) ac_arg=$ac_var=$ac_new_val ;;\n    esac\n    case \" $ac_configure_args \" in\n      *\" '$ac_arg' \"*) ;; # Avoid dups.  Use of quotes ensures accuracy.\n      *) as_fn_append ac_configure_args \" '$ac_arg'\" ;;\n    esac\n  fi\ndone\nif $ac_cache_corrupted; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build\" >&5\nprintf \"%s\\n\" \"$as_me: error: changes in the environment can compromise the build\" >&2;}\n  as_fn_error $? \"run '${MAKE-make} distclean' and/or 'rm $cache_file'\n\t    and start over\" \"$LINENO\" 5\nfi\n## -------------------- ##\n## Main body of script. ##\n## -------------------- ##\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n\nac_config_headers=\"$ac_config_headers config.h\"\n\n\nam__api_version='1.17'\n\n\n\n  # Find a good install program.  We prefer a C program (faster),\n# so one script is as good as another.  But avoid the broken or\n# incompatible versions:\n# SysV /etc/install, /usr/sbin/install\n# SunOS /usr/etc/install\n# IRIX /sbin/install\n# AIX /bin/install\n# AmigaOS /C/install, which installs bootblocks on floppy discs\n# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag\n# AFS /usr/afsws/bin/install, which mishandles nonexistent args\n# SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n# OS/2's system install, which has a completely different semantic\n# ./install, which can be erroneously created by make from ./install.sh.\n# Reject install programs that cannot install multiple files.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install\" >&5\nprintf %s \"checking for a BSD-compatible install... \" >&6; }\nif test -z \"$INSTALL\"; then\nif test ${ac_cv_path_install+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    # Account for fact that we put trailing slashes in our PATH walk.\ncase $as_dir in #((\n  ./ | /[cC]/* | \\\n  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \\\n  ?:[\\\\/]os2[\\\\/]install[\\\\/]* | ?:[\\\\/]OS2[\\\\/]INSTALL[\\\\/]* | \\\n  /usr/ucb/* ) ;;\n  *)\n    # OSF1 and SCO ODT 3.0 have their own names for install.\n    # Don't use installbsd from OSF since it installs stuff as root\n    # by default.\n    for ac_prog in ginstall scoinst install; do\n      for ac_exec_ext in '' $ac_executable_extensions; do\n\tif as_fn_executable_p \"$as_dir$ac_prog$ac_exec_ext\"; then\n\t  if test $ac_prog = install &&\n\t    grep dspmsg \"$as_dir$ac_prog$ac_exec_ext\" >/dev/null 2>&1; then\n\t    # AIX install.  It has an incompatible calling convention.\n\t    :\n\t  elif test $ac_prog = install &&\n\t    grep pwplus \"$as_dir$ac_prog$ac_exec_ext\" >/dev/null 2>&1; then\n\t    # program-specific install script used by HP pwplus--don't use.\n\t    :\n\t  else\n\t    rm -rf conftest.one conftest.two conftest.dir\n\t    echo one > conftest.one\n\t    echo two > conftest.two\n\t    mkdir conftest.dir\n\t    if \"$as_dir$ac_prog$ac_exec_ext\" -c conftest.one conftest.two \"`pwd`/conftest.dir/\" &&\n\t      test -s conftest.one && test -s conftest.two &&\n\t      test -s conftest.dir/conftest.one &&\n\t      test -s conftest.dir/conftest.two\n\t    then\n\t      ac_cv_path_install=\"$as_dir$ac_prog$ac_exec_ext -c\"\n\t      break 3\n\t    fi\n\t  fi\n\tfi\n      done\n    done\n    ;;\nesac\n\n  done\nIFS=$as_save_IFS\n\nrm -rf conftest.one conftest.two conftest.dir\n ;;\nesac\nfi\n  if test ${ac_cv_path_install+y}; then\n    INSTALL=$ac_cv_path_install\n  else\n    # As a last resort, use the slow shell script.  Don't cache a\n    # value for INSTALL within a source directory, because that will\n    # break other packages using the cache if that directory is\n    # removed, or if the value is a relative name.\n    INSTALL=$ac_install_sh\n  fi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $INSTALL\" >&5\nprintf \"%s\\n\" \"$INSTALL\" >&6; }\n\n# Use test -z because SunOS4 sh mishandles braces in ${var-val}.\n# It thinks the first close brace ends the variable substitution.\ntest -z \"$INSTALL_PROGRAM\" && INSTALL_PROGRAM='${INSTALL}'\n\ntest -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL}'\n\ntest -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether sleep supports fractional seconds\" >&5\nprintf %s \"checking whether sleep supports fractional seconds... \" >&6; }\nif test ${am_cv_sleep_fractional_seconds+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if sleep 0.001 2>/dev/null\nthen :\n  am_cv_sleep_fractional_seconds=yes\nelse case e in #(\n  e) am_cv_sleep_fractional_seconds=no ;;\nesac\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_sleep_fractional_seconds\" >&5\nprintf \"%s\\n\" \"$am_cv_sleep_fractional_seconds\" >&6; }\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking filesystem timestamp resolution\" >&5\nprintf %s \"checking filesystem timestamp resolution... \" >&6; }\nif test ${am_cv_filesystem_timestamp_resolution+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) # Default to the worst case.\nam_cv_filesystem_timestamp_resolution=2\n\n# Only try to go finer than 1 sec if sleep can do it.\n# Don't try 1 sec, because if 0.01 sec and 0.1 sec don't work,\n# - 1 sec is not much of a win compared to 2 sec, and\n# - it takes 2 seconds to perform the test whether 1 sec works.\n#\n# Instead, just use the default 2s on platforms that have 1s resolution,\n# accept the extra 1s delay when using $sleep in the Automake tests, in\n# exchange for not incurring the 2s delay for running the test for all\n# packages.\n#\nam_try_resolutions=\nif test \"$am_cv_sleep_fractional_seconds\" = yes; then\n  # Even a millisecond often causes a bunch of false positives,\n  # so just try a hundredth of a second. The time saved between .001 and\n  # .01 is not terribly consequential.\n  am_try_resolutions=\"0.01 0.1 $am_try_resolutions\"\nfi\n\n# In order to catch current-generation FAT out, we must *modify* files\n# that already exist; the *creation* timestamp is finer.  Use names\n# that make ls -t sort them differently when they have equal\n# timestamps than when they have distinct timestamps, keeping\n# in mind that ls -t prints the *newest* file first.\nrm -f conftest.ts?\n: > conftest.ts1\n: > conftest.ts2\n: > conftest.ts3\n\n# Make sure ls -t actually works.  Do 'set' in a subshell so we don't\n# clobber the current shell's arguments. (Outer-level square brackets\n# are removed by m4; they're present so that m4 does not expand\n# <dollar><star>; be careful, easy to get confused.)\nif (\n     set X `ls -t conftest.ts[12]` &&\n     {\n       test \"$*\" != \"X conftest.ts1 conftest.ts2\" ||\n       test \"$*\" != \"X conftest.ts2 conftest.ts1\";\n     }\n); then :; else\n  # If neither matched, then we have a broken ls.  This can happen\n  # if, for instance, CONFIG_SHELL is bash and it inherits a\n  # broken ls alias from the environment.  This has actually\n  # happened.  Such a system could not be considered \"sane\".\n  printf \"%s\\n\" \"\"Bad output from ls -t: \\\"`ls -t conftest.ts[12]`\\\"\"\" >&5\n  { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"ls -t produces unexpected output.\nMake sure there is not a broken ls alias in your environment.\nSee 'config.log' for more details\" \"$LINENO\" 5; }\nfi\n\nfor am_try_res in $am_try_resolutions; do\n  # Any one fine-grained sleep might happen to cross the boundary\n  # between two values of a coarser actual resolution, but if we do\n  # two fine-grained sleeps in a row, at least one of them will fall\n  # entirely within a coarse interval.\n  echo alpha > conftest.ts1\n  sleep $am_try_res\n  echo beta > conftest.ts2\n  sleep $am_try_res\n  echo gamma > conftest.ts3\n\n  # We assume that 'ls -t' will make use of high-resolution\n  # timestamps if the operating system supports them at all.\n  if (set X `ls -t conftest.ts?` &&\n      test \"$2\" = conftest.ts3 &&\n      test \"$3\" = conftest.ts2 &&\n      test \"$4\" = conftest.ts1); then\n    #\n    # Ok, ls -t worked. If we're at a resolution of 1 second, we're done,\n    # because we don't need to test make.\n    make_ok=true\n    if test $am_try_res != 1; then\n      # But if we've succeeded so far with a subsecond resolution, we\n      # have one more thing to check: make. It can happen that\n      # everything else supports the subsecond mtimes, but make doesn't;\n      # notably on macOS, which ships make 3.81 from 2006 (the last one\n      # released under GPLv2). https://bugs.gnu.org/68808\n      #\n      # We test $MAKE if it is defined in the environment, else \"make\".\n      # It might get overridden later, but our hope is that in practice\n      # it does not matter: it is the system \"make\" which is (by far)\n      # the most likely to be broken, whereas if the user overrides it,\n      # probably they did so with a better, or at least not worse, make.\n      # https://lists.gnu.org/archive/html/automake/2024-06/msg00051.html\n      #\n      # Create a Makefile (real tab character here):\n      rm -f conftest.mk\n      echo 'conftest.ts1: conftest.ts2' >conftest.mk\n      echo '\ttouch conftest.ts2' >>conftest.mk\n      #\n      # Now, running\n      #   touch conftest.ts1; touch conftest.ts2; make\n      # should touch ts1 because ts2 is newer. This could happen by luck,\n      # but most often, it will fail if make's support is insufficient. So\n      # test for several consecutive successes.\n      #\n      # (We reuse conftest.ts[12] because we still want to modify existing\n      # files, not create new ones, per above.)\n      n=0\n      make=${MAKE-make}\n      until test $n -eq 3; do\n        echo one > conftest.ts1\n        sleep $am_try_res\n        echo two > conftest.ts2 # ts2 should now be newer than ts1\n        if $make -f conftest.mk | grep 'up to date' >/dev/null; then\n          make_ok=false\n          break # out of $n loop\n        fi\n        n=`expr $n + 1`\n      done\n    fi\n    #\n    if $make_ok; then\n      # Everything we know to check worked out, so call this resolution good.\n      am_cv_filesystem_timestamp_resolution=$am_try_res\n      break # out of $am_try_res loop\n    fi\n    # Otherwise, we'll go on to check the next resolution.\n  fi\ndone\nrm -f conftest.ts?\n# (end _am_filesystem_timestamp_resolution)\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_filesystem_timestamp_resolution\" >&5\nprintf \"%s\\n\" \"$am_cv_filesystem_timestamp_resolution\" >&6; }\n\n# This check should not be cached, as it may vary across builds of\n# different projects.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether build environment is sane\" >&5\nprintf %s \"checking whether build environment is sane... \" >&6; }\n# Reject unsafe characters in $srcdir or the absolute working directory\n# name.  Accept space and tab only in the latter.\nam_lf='\n'\ncase `pwd` in\n  *[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]*)\n    as_fn_error $? \"unsafe absolute working directory name\" \"$LINENO\" 5;;\nesac\ncase $srcdir in\n  *[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]*)\n    as_fn_error $? \"unsafe srcdir value: '$srcdir'\" \"$LINENO\" 5;;\nesac\n\n# Do 'set' in a subshell so we don't clobber the current shell's\n# arguments.  Must try -L first in case configure is actually a\n# symlink; some systems play weird games with the mod time of symlinks\n# (eg FreeBSD returns the mod time of the symlink's containing\n# directory).\nam_build_env_is_sane=no\nam_has_slept=no\nrm -f conftest.file\nfor am_try in 1 2; do\n  echo \"timestamp, slept: $am_has_slept\" > conftest.file\n  if (\n    set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n    if test \"$*\" = \"X\"; then\n      # -L didn't work.\n      set X `ls -t \"$srcdir/configure\" conftest.file`\n    fi\n    test \"$2\" = conftest.file\n  ); then\n    am_build_env_is_sane=yes\n    break\n  fi\n  # Just in case.\n  sleep \"$am_cv_filesystem_timestamp_resolution\"\n  am_has_slept=yes\ndone\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_build_env_is_sane\" >&5\nprintf \"%s\\n\" \"$am_build_env_is_sane\" >&6; }\nif test \"$am_build_env_is_sane\" = no; then\n  as_fn_error $? \"newly created file is older than distributed files!\nCheck your system clock\" \"$LINENO\" 5\nfi\n\n# If we didn't sleep, we still need to ensure time stamps of config.status and\n# generated files are strictly newer.\nam_sleep_pid=\nif test -e conftest.file || grep 'slept: no' conftest.file >/dev/null 2>&1\nthen :\n\nelse case e in #(\n  e)   ( sleep \"$am_cv_filesystem_timestamp_resolution\" ) &\n  am_sleep_pid=$!\n ;;\nesac\nfi\n\nrm -f conftest.file\n\ntest \"$program_prefix\" != NONE &&\n  program_transform_name=\"s&^&$program_prefix&;$program_transform_name\"\n# Use a double $ so make ignores it.\ntest \"$program_suffix\" != NONE &&\n  program_transform_name=\"s&\\$&$program_suffix&;$program_transform_name\"\n# Double any \\ or $.\n# By default was 's,x,x', remove it if useless.\nac_script='s/[\\\\$]/&&/g;s/;s,x,x,$//'\nprogram_transform_name=`printf \"%s\\n\" \"$program_transform_name\" | sed \"$ac_script\"`\n\n\n# Expand $ac_aux_dir to an absolute path.\nam_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n\n\n  if test x\"${MISSING+set}\" != xset; then\n  MISSING=\"\\${SHELL} '$am_aux_dir/missing'\"\nfi\n# Use eval to expand $SHELL\nif eval \"$MISSING --is-lightweight\"; then\n  am_missing_run=\"$MISSING \"\nelse\n  am_missing_run=\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: 'missing' script is too old or missing\" >&2;}\nfi\n\nif test x\"${install_sh+set}\" != xset; then\n  case $am_aux_dir in\n  *\\ * | *\\\t*)\n    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n  *)\n    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n  esac\nfi\n\n# Installed binaries are usually stripped using 'strip' when the user\n# run \"make install-strip\".  However 'strip' might not be the right\n# tool to use in cross-compilation environments, therefore Automake\n# will honor the 'STRIP' environment variable to overrule this program.\nif test \"$cross_compiling\" != no; then\n  if test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}strip; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_STRIP+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$STRIP\"; then\n  ac_cv_prog_STRIP=\"$STRIP\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_STRIP=\"${ac_tool_prefix}strip\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nSTRIP=$ac_cv_prog_STRIP\nif test -n \"$STRIP\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $STRIP\" >&5\nprintf \"%s\\n\" \"$STRIP\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_STRIP\"; then\n  ac_ct_STRIP=$STRIP\n  # Extract the first word of \"strip\", so it can be a program name with args.\nset dummy strip; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_STRIP+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_STRIP\"; then\n  ac_cv_prog_ac_ct_STRIP=\"$ac_ct_STRIP\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_STRIP=\"strip\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP\nif test -n \"$ac_ct_STRIP\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP\" >&5\nprintf \"%s\\n\" \"$ac_ct_STRIP\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_STRIP\" = x; then\n    STRIP=\":\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    STRIP=$ac_ct_STRIP\n  fi\nelse\n  STRIP=\"$ac_cv_prog_STRIP\"\nfi\n\nfi\nINSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for a race-free mkdir -p\" >&5\nprintf %s \"checking for a race-free mkdir -p... \" >&6; }\nif test -z \"$MKDIR_P\"; then\n  if test ${ac_cv_path_mkdir+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_prog in mkdir gmkdir; do\n\t for ac_exec_ext in '' $ac_executable_extensions; do\n\t   as_fn_executable_p \"$as_dir$ac_prog$ac_exec_ext\" || continue\n\t   case `\"$as_dir$ac_prog$ac_exec_ext\" --version 2>&1` in #(\n\t     'mkdir ('*'coreutils) '* | \\\n\t     *'BusyBox '* | \\\n\t     'mkdir (fileutils) '4.1*)\n\t       ac_cv_path_mkdir=$as_dir$ac_prog$ac_exec_ext\n\t       break 3;;\n\t   esac\n\t done\n       done\n  done\nIFS=$as_save_IFS\n ;;\nesac\nfi\n\n  test -d ./--version && rmdir ./--version\n  if test ${ac_cv_path_mkdir+y}; then\n    MKDIR_P=\"$ac_cv_path_mkdir -p\"\n  else\n    # As a last resort, use plain mkdir -p,\n    # in the hope it doesn't have the bugs of ancient mkdir.\n    MKDIR_P='mkdir -p'\n  fi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $MKDIR_P\" >&5\nprintf \"%s\\n\" \"$MKDIR_P\" >&6; }\n\nfor ac_prog in gawk mawk nawk awk\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_AWK+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$AWK\"; then\n  ac_cv_prog_AWK=\"$AWK\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_AWK=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nAWK=$ac_cv_prog_AWK\nif test -n \"$AWK\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AWK\" >&5\nprintf \"%s\\n\" \"$AWK\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$AWK\" && break\ndone\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \\$(MAKE)\" >&5\nprintf %s \"checking whether ${MAKE-make} sets \\$(MAKE)... \" >&6; }\nset x ${MAKE-make}\nac_make=`printf \"%s\\n\" \"$2\" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`\nif eval test \\${ac_cv_prog_make_${ac_make}_set+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat >conftest.make <<\\_ACEOF\nSHELL = /bin/sh\nall:\n\t@echo '@@@%%%=$(MAKE)=@@@%%%'\n_ACEOF\n# GNU make sometimes prints \"make[1]: Entering ...\", which would confuse us.\ncase `${MAKE-make} -f conftest.make 2>/dev/null` in\n  *@@@%%%=?*=@@@%%%*)\n    eval ac_cv_prog_make_${ac_make}_set=yes;;\n  *)\n    eval ac_cv_prog_make_${ac_make}_set=no;;\nesac\nrm -f conftest.make ;;\nesac\nfi\nif eval test \\$ac_cv_prog_make_${ac_make}_set = yes; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; }\n  SET_MAKE=\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\n  SET_MAKE=\"MAKE=${MAKE-make}\"\nfi\n\nrm -rf .tst 2>/dev/null\nmkdir .tst 2>/dev/null\nif test -d .tst; then\n  am__leading_dot=.\nelse\n  am__leading_dot=_\nfi\nrmdir .tst 2>/dev/null\n\nAM_DEFAULT_VERBOSITY=1\n# Check whether --enable-silent-rules was given.\nif test ${enable_silent_rules+y}\nthen :\n  enableval=$enable_silent_rules;\nfi\n\nam_make=${MAKE-make}\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $am_make supports nested variables\" >&5\nprintf %s \"checking whether $am_make supports nested variables... \" >&6; }\nif test ${am_cv_make_support_nested_variables+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if printf \"%s\\n\" 'TRUE=$(BAR$(V))\nBAR0=false\nBAR1=true\nV=1\nam__doit:\n\t@$(TRUE)\n.PHONY: am__doit' | $am_make -f - >/dev/null 2>&1; then\n  am_cv_make_support_nested_variables=yes\nelse\n  am_cv_make_support_nested_variables=no\nfi ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_make_support_nested_variables\" >&5\nprintf \"%s\\n\" \"$am_cv_make_support_nested_variables\" >&6; }\nAM_BACKSLASH='\\'\n\nam__rm_f_notfound=\nif (rm -f && rm -fr && rm -rf) 2>/dev/null\nthen :\n\nelse case e in #(\n  e) am__rm_f_notfound='\"\"' ;;\nesac\nfi\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking xargs -n works\" >&5\nprintf %s \"checking xargs -n works... \" >&6; }\nif test ${am_cv_xargs_n_works+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test \"`echo 1 2 3 | xargs -n2 echo`\" = \"1 2\n3\"\nthen :\n  am_cv_xargs_n_works=yes\nelse case e in #(\n  e) am_cv_xargs_n_works=no ;;\nesac\nfi ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_xargs_n_works\" >&5\nprintf \"%s\\n\" \"$am_cv_xargs_n_works\" >&6; }\nif test \"$am_cv_xargs_n_works\" = yes\nthen :\n  am__xargs_n='xargs -n'\nelse case e in #(\n  e)   am__xargs_n='am__xargs_n () { shift; sed \"s/ /\\\\n/g\" | while read am__xargs_n_arg; do \"\" \"$am__xargs_n_arg\"; done; }'\n ;;\nesac\nfi\n\nif test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n  # is not polluted with repeated \"-I.\"\n  am__isrc=' -I$(srcdir)'\n  # test to see if srcdir already configured\n  if test -f $srcdir/config.status; then\n    as_fn_error $? \"source directory already configured; run \\\"make distclean\\\" there first\" \"$LINENO\" 5\n  fi\nfi\n\n# test whether we have cygpath\nif test -z \"$CYGPATH_W\"; then\n  if (cygpath --version) >/dev/null 2>/dev/null; then\n    CYGPATH_W='cygpath -w'\n  else\n    CYGPATH_W=echo\n  fi\nfi\n\n\n# Define the identity of the package.\n PACKAGE='smenu'\n VERSION='1.4.0'\n\n\nprintf \"%s\\n\" \"#define PACKAGE \\\"$PACKAGE\\\"\" >>confdefs.h\n\n\nprintf \"%s\\n\" \"#define VERSION \\\"$VERSION\\\"\" >>confdefs.h\n\n# Some tools Automake needs.\n\nACLOCAL=${ACLOCAL-\"${am_missing_run}aclocal-${am__api_version}\"}\n\n\nAUTOCONF=${AUTOCONF-\"${am_missing_run}autoconf\"}\n\n\nAUTOMAKE=${AUTOMAKE-\"${am_missing_run}automake-${am__api_version}\"}\n\n\nAUTOHEADER=${AUTOHEADER-\"${am_missing_run}autoheader\"}\n\n\nMAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n\n# For better backward compatibility.  To be removed once Automake 1.9.x\n# dies out for good.  For more background, see:\n# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\nmkdir_p='$(MKDIR_P)'\n\n# We need awk for the \"check\" target (and possibly the TAP driver).  The\n# system \"awk\" is bad on some platforms.\n# Always define AMTAR for backward compatibility.  Yes, it's still used\n# in the wild :-(  We should find a proper way to deprecate it ...\nAMTAR='$${TAR-tar}'\n\n\n# We'll loop over all known methods to create a tar archive until one works.\n_am_tools='gnutar  pax cpio none'\n\nam__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'\n\n\n\n\n\n# Variables for tags utilities; see am/tags.am\nif test -z \"$CTAGS\"; then\n  CTAGS=ctags\nfi\n\nif test -z \"$ETAGS\"; then\n  ETAGS=etags\nfi\n\nif test -z \"$CSCOPE\"; then\n  CSCOPE=cscope\nfi\n\n\n\n\n\n\n\n\nAM_DEFAULT_VERBOSITY=0\n\n# Checks for programs.\n\n\n\n\n\n\n\n\n\nDEPDIR=\"${am__leading_dot}deps\"\n\nac_config_commands=\"$ac_config_commands depfiles\"\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} supports the include directive\" >&5\nprintf %s \"checking whether ${MAKE-make} supports the include directive... \" >&6; }\ncat > confinc.mk << 'END'\nam__doit:\n\t@echo this is the am__doit target >confinc.out\n.PHONY: am__doit\nEND\nam__include=\"#\"\nam__quote=\n# BSD make does it like this.\necho '.include \"confinc.mk\" # ignored' > confmf.BSD\n# Other make implementations (GNU, Solaris 10, AIX) do it like this.\necho 'include confinc.mk # ignored' > confmf.GNU\n_am_result=no\nfor s in GNU BSD; do\n  { echo \"$as_me:$LINENO: ${MAKE-make} -f confmf.$s && cat confinc.out\" >&5\n   (${MAKE-make} -f confmf.$s && cat confinc.out) >&5 2>&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }\n  case $?:`cat confinc.out 2>/dev/null` in #(\n  '0:this is the am__doit target') :\n    case $s in #(\n  BSD) :\n    am__include='.include' am__quote='\"' ;; #(\n  *) :\n    am__include='include' am__quote='' ;;\nesac ;; #(\n  *) :\n     ;;\nesac\n  if test \"$am__include\" != \"#\"; then\n    _am_result=\"yes ($s style)\"\n    break\n  fi\ndone\nrm -f confinc.* confmf.*\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: ${_am_result}\" >&5\nprintf \"%s\\n\" \"${_am_result}\" >&6; }\n\n# Check whether --enable-dependency-tracking was given.\nif test ${enable_dependency_tracking+y}\nthen :\n  enableval=$enable_dependency_tracking;\nfi\n\nif test \"x$enable_dependency_tracking\" != xno; then\n  am_depcomp=\"$ac_aux_dir/depcomp\"\n  AMDEPBACKSLASH='\\'\n  am__nodep='_no'\nfi\n if test \"x$enable_dependency_tracking\" != xno; then\n  AMDEP_TRUE=\n  AMDEP_FALSE='#'\nelse\n  AMDEP_TRUE='#'\n  AMDEP_FALSE=\nfi\n\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\nif test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}gcc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"gcc\", so it can be a program name with args.\nset dummy gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nif test -z \"$CC\"; then\n          if test -n \"$ac_tool_prefix\"; then\n    # Extract the first word of \"${ac_tool_prefix}cc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  fi\nfi\nif test -z \"$CC\"; then\n  # Extract the first word of \"cc\", so it can be a program name with args.\nset dummy cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\n  ac_prog_rejected=no\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    if test \"$as_dir$ac_word$ac_exec_ext\" = \"/usr/ucb/cc\"; then\n       ac_prog_rejected=yes\n       continue\n     fi\n    ac_cv_prog_CC=\"cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nif test $ac_prog_rejected = yes; then\n  # We found a bogon in the path, so make sure we never use it.\n  set dummy $ac_cv_prog_CC\n  shift\n  if test $# != 0; then\n    # We chose a different compiler from the bogus one.\n    # However, it has the same basename, so the bogon will be chosen\n    # first if we set CC to just the basename; use the full file name.\n    shift\n    ac_cv_prog_CC=\"$as_dir$ac_word${1+' '}$@\"\n  fi\nfi\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  for ac_prog in cl.exe\n  do\n    # Extract the first word of \"$ac_tool_prefix$ac_prog\", so it can be a program name with args.\nset dummy $ac_tool_prefix$ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"$ac_tool_prefix$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n    test -n \"$CC\" && break\n  done\nfi\nif test -z \"$CC\"; then\n  ac_ct_CC=$CC\n  for ac_prog in cl.exe\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$ac_ct_CC\" && break\ndone\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nfi\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}clang\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"clang\", so it can be a program name with args.\nset dummy clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nfi\n\n\ntest -z \"$CC\" && { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"no acceptable C compiler found in \\$PATH\nSee 'config.log' for more details\" \"$LINENO\" 5; }\n\n# Provide some information about the compiler.\nprintf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler version\" >&5\nset X $ac_compile\nac_compiler=$2\nfor ac_option in --version -v -V -qversion -version; do\n  { { ac_try=\"$ac_compiler $ac_option >&5\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compiler $ac_option >&5\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    sed '10a\\\n... rest of stderr output deleted ...\n         10q' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n  fi\n  rm -f conftest.er1 conftest.err\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\ndone\n\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files a.out a.out.dSYM a.exe b.out\"\n# Try to create an executable without -o first, disregard a.out.\n# It will help us diagnose broken compilers, and finding out an intuition\n# of exeext.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the C compiler works\" >&5\nprintf %s \"checking whether the C compiler works... \" >&6; }\nac_link_default=`printf \"%s\\n\" \"$ac_link\" | sed 's/ -o *conftest[^ ]*//'`\n\n# The possible output files:\nac_files=\"a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*\"\n\nac_rmfiles=\nfor ac_file in $ac_files\ndo\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    * ) ac_rmfiles=\"$ac_rmfiles $ac_file\";;\n  esac\ndone\nrm -f $ac_rmfiles\n\nif { { ac_try=\"$ac_link_default\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link_default\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  # Autoconf-2.13 could set the ac_cv_exeext variable to 'no'.\n# So ignore a value of 'no', otherwise this would lead to 'EXEEXT = no'\n# in a Makefile.  We should not override ac_cv_exeext if it was cached,\n# so that the user can short-circuit this test for compilers unknown to\n# Autoconf.\nfor ac_file in $ac_files ''\ndo\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )\n\t;;\n    [ab].out )\n\t# We found the default executable, but exeext='' is most\n\t# certainly right.\n\tbreak;;\n    *.* )\n\tif test ${ac_cv_exeext+y} && test \"$ac_cv_exeext\" != no;\n\tthen :; else\n\t   ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\tfi\n\t# We set ac_cv_exeext here because the later test for it is not\n\t# safe: cross compilers may not add the suffix if given an '-o'\n\t# argument, so we may need to know it at that point already.\n\t# Even if this section looks crufty: it has the advantage of\n\t# actually working.\n\tbreak;;\n    * )\n\tbreak;;\n  esac\ndone\ntest \"$ac_cv_exeext\" = no && ac_cv_exeext=\n\nelse case e in #(\n  e) ac_file='' ;;\nesac\nfi\nif test -z \"$ac_file\"\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nprintf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error 77 \"C compiler cannot create executables\nSee 'config.log' for more details\" \"$LINENO\" 5; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; } ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name\" >&5\nprintf %s \"checking for C compiler default output file name... \" >&6; }\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_file\" >&5\nprintf \"%s\\n\" \"$ac_file\" >&6; }\nac_exeext=$ac_cv_exeext\n\nrm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out\nac_clean_files=$ac_clean_files_save\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for suffix of executables\" >&5\nprintf %s \"checking for suffix of executables... \" >&6; }\nif { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  # If both 'conftest.exe' and 'conftest' are 'present' (well, observable)\n# catch 'conftest.exe'.  For instance with Cygwin, 'ls conftest' will\n# work properly (i.e., refer to 'conftest.exe'), while it won't with\n# 'rm'.\nfor ac_file in conftest.exe conftest conftest.*; do\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    *.* ) ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\t  break;;\n    * ) break;;\n  esac\ndone\nelse case e in #(\n  e) { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of executables: cannot compile and link\nSee 'config.log' for more details\" \"$LINENO\" 5; } ;;\nesac\nfi\nrm -f conftest conftest$ac_cv_exeext\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext\" >&5\nprintf \"%s\\n\" \"$ac_cv_exeext\" >&6; }\n\nrm -f conftest.$ac_ext\nEXEEXT=$ac_cv_exeext\nac_exeext=$EXEEXT\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdio.h>\nint\nmain (void)\n{\nFILE *f = fopen (\"conftest.out\", \"w\");\n if (!f)\n  return 1;\n return ferror (f) || fclose (f) != 0;\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files=\"$ac_clean_files conftest.out\"\n# Check that the compiler produces executables we can run.  If not, either\n# the compiler is broken, or we cross compile.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling\" >&5\nprintf %s \"checking whether we are cross compiling... \" >&6; }\nif test \"$cross_compiling\" != yes; then\n  { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\n  if { ac_try='./conftest$ac_cv_exeext'\n  { { case \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_try\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; }; then\n    cross_compiling=no\n  else\n    if test \"$cross_compiling\" = maybe; then\n\tcross_compiling=yes\n    else\n\t{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error 77 \"cannot run C compiled programs.\nIf you meant to cross compile, use '--host'.\nSee 'config.log' for more details\" \"$LINENO\" 5; }\n    fi\n  fi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $cross_compiling\" >&5\nprintf \"%s\\n\" \"$cross_compiling\" >&6; }\n\nrm -f conftest.$ac_ext conftest$ac_cv_exeext \\\n  conftest.o conftest.obj conftest.out\nac_clean_files=$ac_clean_files_save\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for suffix of object files\" >&5\nprintf %s \"checking for suffix of object files... \" >&6; }\nif test ${ac_cv_objext+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nrm -f conftest.o conftest.obj\nif { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  for ac_file in conftest.o conftest.obj conftest.*; do\n  test -f \"$ac_file\" || continue;\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;\n    *) ac_cv_objext=`expr \"$ac_file\" : '.*\\.\\(.*\\)'`\n       break;;\n  esac\ndone\nelse case e in #(\n  e) printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of object files: cannot compile\nSee 'config.log' for more details\" \"$LINENO\" 5; } ;;\nesac\nfi\nrm -f conftest.$ac_cv_objext conftest.$ac_ext ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext\" >&5\nprintf \"%s\\n\" \"$ac_cv_objext\" >&6; }\nOBJEXT=$ac_cv_objext\nac_objext=$OBJEXT\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C\" >&5\nprintf %s \"checking whether the compiler supports GNU C... \" >&6; }\nif test ${ac_cv_c_compiler_gnu+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n#ifndef __GNUC__\n       choke me\n#endif\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_compiler_gnu=yes\nelse case e in #(\n  e) ac_compiler_gnu=no ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nac_cv_c_compiler_gnu=$ac_compiler_gnu\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu\" >&5\nprintf \"%s\\n\" \"$ac_cv_c_compiler_gnu\" >&6; }\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\nif test $ac_compiler_gnu = yes; then\n  GCC=yes\nelse\n  GCC=\nfi\nac_test_CFLAGS=${CFLAGS+y}\nac_save_CFLAGS=$CFLAGS\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g\" >&5\nprintf %s \"checking whether $CC accepts -g... \" >&6; }\nif test ${ac_cv_prog_cc_g+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_save_c_werror_flag=$ac_c_werror_flag\n   ac_c_werror_flag=yes\n   ac_cv_prog_cc_g=no\n   CFLAGS=\"-g\"\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nelse case e in #(\n  e) CFLAGS=\"\"\n      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse case e in #(\n  e) ac_c_werror_flag=$ac_save_c_werror_flag\n\t CFLAGS=\"-g\"\n\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n   ac_c_werror_flag=$ac_save_c_werror_flag ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_g\" >&6; }\nif test $ac_test_CFLAGS; then\n  CFLAGS=$ac_save_CFLAGS\nelif test $ac_cv_prog_cc_g = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-g -O2\"\n  else\n    CFLAGS=\"-g\"\n  fi\nelse\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-O2\"\n  else\n    CFLAGS=\n  fi\nfi\nac_prog_cc_stdc=no\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features\" >&5\nprintf %s \"checking for $CC option to enable C11 features... \" >&6; }\nif test ${ac_cv_prog_cc_c11+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_prog_cc_c11=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c11_program\n_ACEOF\nfor ac_arg in '' -std=gnu11\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c11=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c11\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC ;;\nesac\nfi\n\nif test \"x$ac_cv_prog_cc_c11\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse case e in #(\n  e) if test \"x$ac_cv_prog_cc_c11\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c11\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c11\" ;;\nesac\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11\n  ac_prog_cc_stdc=c11 ;;\nesac\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features\" >&5\nprintf %s \"checking for $CC option to enable C99 features... \" >&6; }\nif test ${ac_cv_prog_cc_c99+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_prog_cc_c99=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c99_program\n_ACEOF\nfor ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c99=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c99\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC ;;\nesac\nfi\n\nif test \"x$ac_cv_prog_cc_c99\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse case e in #(\n  e) if test \"x$ac_cv_prog_cc_c99\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c99\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c99\" ;;\nesac\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99\n  ac_prog_cc_stdc=c99 ;;\nesac\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features\" >&5\nprintf %s \"checking for $CC option to enable C89 features... \" >&6; }\nif test ${ac_cv_prog_cc_c89+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_prog_cc_c89=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c89_program\n_ACEOF\nfor ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae \"-Aa -D_HPUX_SOURCE\" \"-Xc -D__EXTENSIONS__\"\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c89=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c89\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC ;;\nesac\nfi\n\nif test \"x$ac_cv_prog_cc_c89\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse case e in #(\n  e) if test \"x$ac_cv_prog_cc_c89\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c89\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c89\" ;;\nesac\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89\n  ac_prog_cc_stdc=c89 ;;\nesac\nfi\nfi\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n  ac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $CC understands -c and -o together\" >&5\nprintf %s \"checking whether $CC understands -c and -o together... \" >&6; }\nif test ${am_cv_prog_cc_c_o+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\n  # Make sure it works both with $CC and with simple cc.\n  # Following AC_PROG_CC_C_O, we do the test twice because some\n  # compilers refuse to overwrite an existing .o file with -o,\n  # though they will create one.\n  am_cv_prog_cc_c_o=yes\n  for am_i in 1 2; do\n    if { echo \"$as_me:$LINENO: $CC -c conftest.$ac_ext -o conftest2.$ac_objext\" >&5\n   ($CC -c conftest.$ac_ext -o conftest2.$ac_objext) >&5 2>&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } \\\n         && test -f conftest2.$ac_objext; then\n      : OK\n    else\n      am_cv_prog_cc_c_o=no\n      break\n    fi\n  done\n  rm -f core conftest*\n  unset am_i ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_prog_cc_c_o\" >&5\nprintf \"%s\\n\" \"$am_cv_prog_cc_c_o\" >&6; }\nif test \"$am_cv_prog_cc_c_o\" != yes; then\n   # Losing compiler, so override with the script.\n   # FIXME: It is wrong to rewrite CC.\n   # But if we don't then we get into trouble of one sort or another.\n   # A longer-term fix would be to have automake use am__CC in this case,\n   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n   CC=\"$am_aux_dir/compile $CC\"\nfi\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\ndepcc=\"$CC\"   am_compiler_list=\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc\" >&5\nprintf %s \"checking dependency style of $depcc... \" >&6; }\nif test ${am_cv_CC_dependencies_compiler_type+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n  # We make a subdir and do the tests there.  Otherwise we can end up\n  # making bogus files that we don't know about and never remove.  For\n  # instance it was reported that on HP-UX the gcc test will end up\n  # making a dummy file named 'D' -- because '-MD' means \"put the output\n  # in D\".\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  # Copy depcomp to subdir because otherwise we won't find it if we're\n  # using a relative directory.\n  cp \"$am_depcomp\" conftest.dir\n  cd conftest.dir\n  # We will build objects and dependencies in a subdirectory because\n  # it helps to detect inapplicable dependency modes.  For instance\n  # both Tru64's cc and ICC support -MD to output dependencies as a\n  # side effect of compilation, but ICC will put the dependencies in\n  # the current directory while Tru64 will put them in the object\n  # directory.\n  mkdir sub\n\n  am_cv_CC_dependencies_compiler_type=none\n  if test \"$am_compiler_list\" = \"\"; then\n     am_compiler_list=`sed -n 's/^#*\\([a-zA-Z0-9]*\\))$/\\1/p' < ./depcomp`\n  fi\n  am__universal=false\n  case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac\n\n  for depmode in $am_compiler_list; do\n    # Setup a source with many dependencies, because some compilers\n    # like to wrap large dependency lists on column 80 (with \\), and\n    # we should not choose a depcomp mode which is confused by this.\n    #\n    # We need to recreate these files for each test, as the compiler may\n    # overwrite some of them when testing with obscure command lines.\n    # This happens at least with the AIX C compiler.\n    : > sub/conftest.c\n    for i in 1 2 3 4 5 6; do\n      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n      # Using \": > sub/conftst$i.h\" creates only sub/conftst1.h with\n      # Solaris 10 /bin/sh.\n      echo '/* dummy */' > sub/conftst$i.h\n    done\n    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n\n    # We check with '-c' and '-o' for the sake of the \"dashmstdout\"\n    # mode.  It turns out that the SunPro C++ compiler does not properly\n    # handle '-M -o', and we need to detect this.  Also, some Intel\n    # versions had trouble with output in subdirs.\n    am__obj=sub/conftest.${OBJEXT-o}\n    am__minus_obj=\"-o $am__obj\"\n    case $depmode in\n    gcc)\n      # This depmode causes a compiler race in universal mode.\n      test \"$am__universal\" = false || continue\n      ;;\n    nosideeffect)\n      # After this tag, mechanisms are not by side-effect, so they'll\n      # only be used when explicitly requested.\n      if test \"x$enable_dependency_tracking\" = xyes; then\n\tcontinue\n      else\n\tbreak\n      fi\n      ;;\n    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n      # This compiler won't grok '-c -o', but also, the minuso test has\n      # not run yet.  These depmodes are late enough in the game, and\n      # so weak that their functioning should not be impacted.\n      am__obj=conftest.${OBJEXT-o}\n      am__minus_obj=\n      ;;\n    none) break ;;\n    esac\n    if depmode=$depmode \\\n       source=sub/conftest.c object=$am__obj \\\n       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n         >/dev/null 2>conftest.err &&\n       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n      # icc doesn't choke on unknown options, it will just issue warnings\n      # or remarks (even with -Werror).  So we grep stderr for any message\n      # that says an option was ignored or not supported.\n      # When given -MP, icc 7.0 and 7.1 complain thus:\n      #   icc: Command line warning: ignoring option '-M'; no argument required\n      # The diagnosis changed in icc 8.0:\n      #   icc: Command line remark: option '-MP' not supported\n      if (grep 'ignoring option' conftest.err ||\n          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n        am_cv_CC_dependencies_compiler_type=$depmode\n        break\n      fi\n    fi\n  done\n\n  cd ..\n  rm -rf conftest.dir\nelse\n  am_cv_CC_dependencies_compiler_type=none\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type\" >&5\nprintf \"%s\\n\" \"$am_cv_CC_dependencies_compiler_type\" >&6; }\nCCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type\n\n if\n  test \"x$enable_dependency_tracking\" != xno \\\n  && test \"$am_cv_CC_dependencies_compiler_type\" = gcc3; then\n  am__fastdepCC_TRUE=\n  am__fastdepCC_FALSE='#'\nelse\n  am__fastdepCC_TRUE='#'\n  am__fastdepCC_FALSE=\nfi\n\n\n\nac_header= ac_cache=\nfor ac_item in $ac_header_c_list\ndo\n  if test $ac_cache; then\n    ac_fn_c_check_header_compile \"$LINENO\" $ac_header ac_cv_header_$ac_cache \"$ac_includes_default\"\n    if eval test \\\"x\\$ac_cv_header_$ac_cache\\\" = xyes; then\n      printf \"%s\\n\" \"#define $ac_item 1\" >> confdefs.h\n    fi\n    ac_header= ac_cache=\n  elif test $ac_header; then\n    ac_cache=$ac_item\n  else\n    ac_header=$ac_item\n  fi\ndone\n\n\n\n\n\n\n\n\nif test $ac_cv_header_stdlib_h = yes && test $ac_cv_header_string_h = yes\nthen :\n\nprintf \"%s\\n\" \"#define STDC_HEADERS 1\" >>confdefs.h\n\nfi\n\n\n\n\n\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether it is safe to define __EXTENSIONS__\" >&5\nprintf %s \"checking whether it is safe to define __EXTENSIONS__... \" >&6; }\nif test ${ac_cv_safe_to_define___extensions__+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n#         define __EXTENSIONS__ 1\n          $ac_includes_default\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_safe_to_define___extensions__=yes\nelse case e in #(\n  e) ac_cv_safe_to_define___extensions__=no ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_safe_to_define___extensions__\" >&5\nprintf \"%s\\n\" \"$ac_cv_safe_to_define___extensions__\" >&6; }\n\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether _XOPEN_SOURCE should be defined\" >&5\nprintf %s \"checking whether _XOPEN_SOURCE should be defined... \" >&6; }\nif test ${ac_cv_should_define__xopen_source+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_should_define__xopen_source=no\n    if test $ac_cv_header_wchar_h = yes\nthen :\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n          #include <wchar.h>\n          mbstate_t x;\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n            #define _XOPEN_SOURCE 500\n            #include <wchar.h>\n            mbstate_t x;\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_should_define__xopen_source=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_should_define__xopen_source\" >&5\nprintf \"%s\\n\" \"$ac_cv_should_define__xopen_source\" >&6; }\n\n  printf \"%s\\n\" \"#define _ALL_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _DARWIN_C_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _GNU_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _HPUX_ALT_XOPEN_SOCKET_API 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _NETBSD_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _OPENBSD_SOURCE 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _POSIX_PTHREAD_SEMANTICS 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_BFP_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_DFP_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_IEC_60559_TYPES_EXT__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_LIB_EXT2__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define __STDC_WANT_MATH_SPEC_FUNCS__ 1\" >>confdefs.h\n\n  printf \"%s\\n\" \"#define _TANDEM_SOURCE 1\" >>confdefs.h\n\n  if test $ac_cv_header_minix_config_h = yes\nthen :\n  MINIX=yes\n    printf \"%s\\n\" \"#define _MINIX 1\" >>confdefs.h\n\n    printf \"%s\\n\" \"#define _POSIX_SOURCE 1\" >>confdefs.h\n\n    printf \"%s\\n\" \"#define _POSIX_1_SOURCE 2\" >>confdefs.h\n\nelse case e in #(\n  e) MINIX= ;;\nesac\nfi\n  if test $ac_cv_safe_to_define___extensions__ = yes\nthen :\n  printf \"%s\\n\" \"#define __EXTENSIONS__ 1\" >>confdefs.h\n\nfi\n  if test $ac_cv_should_define__xopen_source = yes\nthen :\n  printf \"%s\\n\" \"#define _XOPEN_SOURCE 500\" >>confdefs.h\n\nfi\n\nfor ac_prog in gawk mawk nawk awk\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_AWK+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$AWK\"; then\n  ac_cv_prog_AWK=\"$AWK\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_AWK=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nAWK=$ac_cv_prog_AWK\nif test -n \"$AWK\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $AWK\" >&5\nprintf \"%s\\n\" \"$AWK\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$AWK\" && break\ndone\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\nif test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}gcc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"gcc\", so it can be a program name with args.\nset dummy gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nif test -z \"$CC\"; then\n          if test -n \"$ac_tool_prefix\"; then\n    # Extract the first word of \"${ac_tool_prefix}cc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  fi\nfi\nif test -z \"$CC\"; then\n  # Extract the first word of \"cc\", so it can be a program name with args.\nset dummy cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\n  ac_prog_rejected=no\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    if test \"$as_dir$ac_word$ac_exec_ext\" = \"/usr/ucb/cc\"; then\n       ac_prog_rejected=yes\n       continue\n     fi\n    ac_cv_prog_CC=\"cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nif test $ac_prog_rejected = yes; then\n  # We found a bogon in the path, so make sure we never use it.\n  set dummy $ac_cv_prog_CC\n  shift\n  if test $# != 0; then\n    # We chose a different compiler from the bogus one.\n    # However, it has the same basename, so the bogon will be chosen\n    # first if we set CC to just the basename; use the full file name.\n    shift\n    ac_cv_prog_CC=\"$as_dir$ac_word${1+' '}$@\"\n  fi\nfi\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  for ac_prog in cl.exe\n  do\n    # Extract the first word of \"$ac_tool_prefix$ac_prog\", so it can be a program name with args.\nset dummy $ac_tool_prefix$ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"$ac_tool_prefix$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n    test -n \"$CC\" && break\n  done\nfi\nif test -z \"$CC\"; then\n  ac_ct_CC=$CC\n  for ac_prog in cl.exe\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$ac_ct_CC\" && break\ndone\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nfi\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}clang\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"clang\", so it can be a program name with args.\nset dummy clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi ;;\nesac\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nfi\n\n\ntest -z \"$CC\" && { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"no acceptable C compiler found in \\$PATH\nSee 'config.log' for more details\" \"$LINENO\" 5; }\n\n# Provide some information about the compiler.\nprintf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler version\" >&5\nset X $ac_compile\nac_compiler=$2\nfor ac_option in --version -v -V -qversion -version; do\n  { { ac_try=\"$ac_compiler $ac_option >&5\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compiler $ac_option >&5\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    sed '10a\\\n... rest of stderr output deleted ...\n         10q' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n  fi\n  rm -f conftest.er1 conftest.err\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\ndone\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C\" >&5\nprintf %s \"checking whether the compiler supports GNU C... \" >&6; }\nif test ${ac_cv_c_compiler_gnu+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n#ifndef __GNUC__\n       choke me\n#endif\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_compiler_gnu=yes\nelse case e in #(\n  e) ac_compiler_gnu=no ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nac_cv_c_compiler_gnu=$ac_compiler_gnu\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu\" >&5\nprintf \"%s\\n\" \"$ac_cv_c_compiler_gnu\" >&6; }\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\nif test $ac_compiler_gnu = yes; then\n  GCC=yes\nelse\n  GCC=\nfi\nac_test_CFLAGS=${CFLAGS+y}\nac_save_CFLAGS=$CFLAGS\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g\" >&5\nprintf %s \"checking whether $CC accepts -g... \" >&6; }\nif test ${ac_cv_prog_cc_g+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_save_c_werror_flag=$ac_c_werror_flag\n   ac_c_werror_flag=yes\n   ac_cv_prog_cc_g=no\n   CFLAGS=\"-g\"\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nelse case e in #(\n  e) CFLAGS=\"\"\n      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse case e in #(\n  e) ac_c_werror_flag=$ac_save_c_werror_flag\n\t CFLAGS=\"-g\"\n\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n   ac_c_werror_flag=$ac_save_c_werror_flag ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_g\" >&6; }\nif test $ac_test_CFLAGS; then\n  CFLAGS=$ac_save_CFLAGS\nelif test $ac_cv_prog_cc_g = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-g -O2\"\n  else\n    CFLAGS=\"-g\"\n  fi\nelse\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-O2\"\n  else\n    CFLAGS=\n  fi\nfi\nac_prog_cc_stdc=no\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features\" >&5\nprintf %s \"checking for $CC option to enable C11 features... \" >&6; }\nif test ${ac_cv_prog_cc_c11+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_prog_cc_c11=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c11_program\n_ACEOF\nfor ac_arg in '' -std=gnu11\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c11=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c11\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC ;;\nesac\nfi\n\nif test \"x$ac_cv_prog_cc_c11\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse case e in #(\n  e) if test \"x$ac_cv_prog_cc_c11\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c11\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c11\" ;;\nesac\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11\n  ac_prog_cc_stdc=c11 ;;\nesac\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features\" >&5\nprintf %s \"checking for $CC option to enable C99 features... \" >&6; }\nif test ${ac_cv_prog_cc_c99+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_prog_cc_c99=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c99_program\n_ACEOF\nfor ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c99=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c99\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC ;;\nesac\nfi\n\nif test \"x$ac_cv_prog_cc_c99\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse case e in #(\n  e) if test \"x$ac_cv_prog_cc_c99\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c99\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c99\" ;;\nesac\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99\n  ac_prog_cc_stdc=c99 ;;\nesac\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features\" >&5\nprintf %s \"checking for $CC option to enable C89 features... \" >&6; }\nif test ${ac_cv_prog_cc_c89+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_cv_prog_cc_c89=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c89_program\n_ACEOF\nfor ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae \"-Aa -D_HPUX_SOURCE\" \"-Xc -D__EXTENSIONS__\"\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c89=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c89\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC ;;\nesac\nfi\n\nif test \"x$ac_cv_prog_cc_c89\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse case e in #(\n  e) if test \"x$ac_cv_prog_cc_c89\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse case e in #(\n  e) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c89\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c89\" ;;\nesac\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89\n  ac_prog_cc_stdc=c89 ;;\nesac\nfi\nfi\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n  ac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $CC understands -c and -o together\" >&5\nprintf %s \"checking whether $CC understands -c and -o together... \" >&6; }\nif test ${am_cv_prog_cc_c_o+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\n  # Make sure it works both with $CC and with simple cc.\n  # Following AC_PROG_CC_C_O, we do the test twice because some\n  # compilers refuse to overwrite an existing .o file with -o,\n  # though they will create one.\n  am_cv_prog_cc_c_o=yes\n  for am_i in 1 2; do\n    if { echo \"$as_me:$LINENO: $CC -c conftest.$ac_ext -o conftest2.$ac_objext\" >&5\n   ($CC -c conftest.$ac_ext -o conftest2.$ac_objext) >&5 2>&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } \\\n         && test -f conftest2.$ac_objext; then\n      : OK\n    else\n      am_cv_prog_cc_c_o=no\n      break\n    fi\n  done\n  rm -f core conftest*\n  unset am_i ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_prog_cc_c_o\" >&5\nprintf \"%s\\n\" \"$am_cv_prog_cc_c_o\" >&6; }\nif test \"$am_cv_prog_cc_c_o\" != yes; then\n   # Losing compiler, so override with the script.\n   # FIXME: It is wrong to rewrite CC.\n   # But if we don't then we get into trouble of one sort or another.\n   # A longer-term fix would be to have automake use am__CC in this case,\n   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n   CC=\"$am_aux_dir/compile $CC\"\nfi\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\ndepcc=\"$CC\"   am_compiler_list=\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc\" >&5\nprintf %s \"checking dependency style of $depcc... \" >&6; }\nif test ${am_cv_CC_dependencies_compiler_type+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n  # We make a subdir and do the tests there.  Otherwise we can end up\n  # making bogus files that we don't know about and never remove.  For\n  # instance it was reported that on HP-UX the gcc test will end up\n  # making a dummy file named 'D' -- because '-MD' means \"put the output\n  # in D\".\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  # Copy depcomp to subdir because otherwise we won't find it if we're\n  # using a relative directory.\n  cp \"$am_depcomp\" conftest.dir\n  cd conftest.dir\n  # We will build objects and dependencies in a subdirectory because\n  # it helps to detect inapplicable dependency modes.  For instance\n  # both Tru64's cc and ICC support -MD to output dependencies as a\n  # side effect of compilation, but ICC will put the dependencies in\n  # the current directory while Tru64 will put them in the object\n  # directory.\n  mkdir sub\n\n  am_cv_CC_dependencies_compiler_type=none\n  if test \"$am_compiler_list\" = \"\"; then\n     am_compiler_list=`sed -n 's/^#*\\([a-zA-Z0-9]*\\))$/\\1/p' < ./depcomp`\n  fi\n  am__universal=false\n  case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac\n\n  for depmode in $am_compiler_list; do\n    # Setup a source with many dependencies, because some compilers\n    # like to wrap large dependency lists on column 80 (with \\), and\n    # we should not choose a depcomp mode which is confused by this.\n    #\n    # We need to recreate these files for each test, as the compiler may\n    # overwrite some of them when testing with obscure command lines.\n    # This happens at least with the AIX C compiler.\n    : > sub/conftest.c\n    for i in 1 2 3 4 5 6; do\n      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n      # Using \": > sub/conftst$i.h\" creates only sub/conftst1.h with\n      # Solaris 10 /bin/sh.\n      echo '/* dummy */' > sub/conftst$i.h\n    done\n    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n\n    # We check with '-c' and '-o' for the sake of the \"dashmstdout\"\n    # mode.  It turns out that the SunPro C++ compiler does not properly\n    # handle '-M -o', and we need to detect this.  Also, some Intel\n    # versions had trouble with output in subdirs.\n    am__obj=sub/conftest.${OBJEXT-o}\n    am__minus_obj=\"-o $am__obj\"\n    case $depmode in\n    gcc)\n      # This depmode causes a compiler race in universal mode.\n      test \"$am__universal\" = false || continue\n      ;;\n    nosideeffect)\n      # After this tag, mechanisms are not by side-effect, so they'll\n      # only be used when explicitly requested.\n      if test \"x$enable_dependency_tracking\" = xyes; then\n\tcontinue\n      else\n\tbreak\n      fi\n      ;;\n    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n      # This compiler won't grok '-c -o', but also, the minuso test has\n      # not run yet.  These depmodes are late enough in the game, and\n      # so weak that their functioning should not be impacted.\n      am__obj=conftest.${OBJEXT-o}\n      am__minus_obj=\n      ;;\n    none) break ;;\n    esac\n    if depmode=$depmode \\\n       source=sub/conftest.c object=$am__obj \\\n       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n         >/dev/null 2>conftest.err &&\n       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n      # icc doesn't choke on unknown options, it will just issue warnings\n      # or remarks (even with -Werror).  So we grep stderr for any message\n      # that says an option was ignored or not supported.\n      # When given -MP, icc 7.0 and 7.1 complain thus:\n      #   icc: Command line warning: ignoring option '-M'; no argument required\n      # The diagnosis changed in icc 8.0:\n      #   icc: Command line remark: option '-MP' not supported\n      if (grep 'ignoring option' conftest.err ||\n          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n        am_cv_CC_dependencies_compiler_type=$depmode\n        break\n      fi\n    fi\n  done\n\n  cd ..\n  rm -rf conftest.dir\nelse\n  am_cv_CC_dependencies_compiler_type=none\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type\" >&5\nprintf \"%s\\n\" \"$am_cv_CC_dependencies_compiler_type\" >&6; }\nCCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type\n\n if\n  test \"x$enable_dependency_tracking\" != xno \\\n  && test \"$am_cv_CC_dependencies_compiler_type\" = gcc3; then\n  am__fastdepCC_TRUE=\n  am__fastdepCC_FALSE='#'\nelse\n  am__fastdepCC_TRUE='#'\n  am__fastdepCC_FALSE=\nfi\n\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether ln -s works\" >&5\nprintf %s \"checking whether ln -s works... \" >&6; }\nLN_S=$as_ln_s\nif test \"$LN_S\" = \"ln -s\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no, using $LN_S\" >&5\nprintf \"%s\\n\" \"no, using $LN_S\" >&6; }\nfi\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \\$(MAKE)\" >&5\nprintf %s \"checking whether ${MAKE-make} sets \\$(MAKE)... \" >&6; }\nset x ${MAKE-make}\nac_make=`printf \"%s\\n\" \"$2\" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`\nif eval test \\${ac_cv_prog_make_${ac_make}_set+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) cat >conftest.make <<\\_ACEOF\nSHELL = /bin/sh\nall:\n\t@echo '@@@%%%=$(MAKE)=@@@%%%'\n_ACEOF\n# GNU make sometimes prints \"make[1]: Entering ...\", which would confuse us.\ncase `${MAKE-make} -f conftest.make 2>/dev/null` in\n  *@@@%%%=?*=@@@%%%*)\n    eval ac_cv_prog_make_${ac_make}_set=yes;;\n  *)\n    eval ac_cv_prog_make_${ac_make}_set=no;;\nesac\nrm -f conftest.make ;;\nesac\nfi\nif eval test \\$ac_cv_prog_make_${ac_make}_set = yes; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; }\n  SET_MAKE=\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\n  SET_MAKE=\"MAKE=${MAKE-make}\"\nfi\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for library containing tgetent\" >&5\nprintf %s \"checking for library containing tgetent... \" >&6; }\nif test ${ac_cv_search_tgetent+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.\n   The 'extern \"C\"' is for builds by C++ compilers;\n   although this is not generally supported in C code supporting it here\n   has little cost and some practical benefit (sr 110532).  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar tgetent (void);\nint\nmain (void)\n{\nreturn tgetent ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' tinfo curses ncursesw ncurses\ndo\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"\nthen :\n  ac_cv_search_tgetent=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext\n  if test ${ac_cv_search_tgetent+y}\nthen :\n  break\nfi\ndone\nif test ${ac_cv_search_tgetent+y}\nthen :\n\nelse case e in #(\n  e) ac_cv_search_tgetent=no ;;\nesac\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_tgetent\" >&5\nprintf \"%s\\n\" \"$ac_cv_search_tgetent\" >&6; }\nac_res=$ac_cv_search_tgetent\nif test \"$ac_res\" != no\nthen :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n  HAVE_CURSES=True\nfi\n\n\n# clock_gettime is in librt on *-*-osf5.1 and on glibc < 2.17, so add -lrt\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime\" >&5\nprintf %s \"checking for library containing clock_gettime... \" >&6; }\nif test ${ac_cv_search_clock_gettime+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.\n   The 'extern \"C\"' is for builds by C++ compilers;\n   although this is not generally supported in C code supporting it here\n   has little cost and some practical benefit (sr 110532).  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar clock_gettime (void);\nint\nmain (void)\n{\nreturn clock_gettime ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' rt\ndo\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"\nthen :\n  ac_cv_search_clock_gettime=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam \\\n    conftest$ac_exeext\n  if test ${ac_cv_search_clock_gettime+y}\nthen :\n  break\nfi\ndone\nif test ${ac_cv_search_clock_gettime+y}\nthen :\n\nelse case e in #(\n  e) ac_cv_search_clock_gettime=no ;;\nesac\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime\" >&5\nprintf \"%s\\n\" \"$ac_cv_search_clock_gettime\" >&6; }\nac_res=$ac_cv_search_clock_gettime\nif test \"$ac_res\" != no\nthen :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\n\nprintf \"%s\\n\" \"#define HAVE_CLOCK_GETTIME 1\" >>confdefs.h\n\nfi\n\n\n# Checks for libraries.\n\n# Checks for header files.\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e\" >&5\nprintf %s \"checking for grep that handles long lines and -e... \" >&6; }\nif test ${ac_cv_path_GREP+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test -z \"$GREP\"; then\n  ac_path_GREP_found=false\n  # Loop through the user's path and test for each of PROGNAME-LIST\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_prog in grep ggrep\n   do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      ac_path_GREP=\"$as_dir$ac_prog$ac_exec_ext\"\n      as_fn_executable_p \"$ac_path_GREP\" || continue\n# Check for GNU ac_path_GREP and select it if it is found.\n  # Check for GNU $ac_path_GREP\ncase `\"$ac_path_GREP\" --version 2>&1` in #(\n*GNU*)\n  ac_cv_path_GREP=\"$ac_path_GREP\" ac_path_GREP_found=:;;\n#(\n*)\n  ac_count=0\n  printf %s 0123456789 >\"conftest.in\"\n  while :\n  do\n    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n    mv \"conftest.tmp\" \"conftest.in\"\n    cp \"conftest.in\" \"conftest.nl\"\n    printf \"%s\\n\" 'GREP' >> \"conftest.nl\"\n    \"$ac_path_GREP\" -e 'GREP$' -e '-(cannot match)-' < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n    as_fn_arith $ac_count + 1 && ac_count=$as_val\n    if test $ac_count -gt ${ac_path_GREP_max-0}; then\n      # Best one so far, save it but keep looking for a better one\n      ac_cv_path_GREP=\"$ac_path_GREP\"\n      ac_path_GREP_max=$ac_count\n    fi\n    # 10*(2^10) chars as input seems more than enough\n    test $ac_count -gt 10 && break\n  done\n  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\nesac\n\n      $ac_path_GREP_found && break 3\n    done\n  done\n  done\nIFS=$as_save_IFS\n  if test -z \"$ac_cv_path_GREP\"; then\n    as_fn_error $? \"no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin\" \"$LINENO\" 5\n  fi\nelse\n  ac_cv_path_GREP=$GREP\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP\" >&5\nprintf \"%s\\n\" \"$ac_cv_path_GREP\" >&6; }\n GREP=\"$ac_cv_path_GREP\"\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for egrep\" >&5\nprintf %s \"checking for egrep... \" >&6; }\nif test ${ac_cv_path_EGREP+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if echo a | $GREP -E '(a|b)' >/dev/null 2>&1\n   then ac_cv_path_EGREP=\"$GREP -E\"\n   else\n     if test -z \"$EGREP\"; then\n  ac_path_EGREP_found=false\n  # Loop through the user's path and test for each of PROGNAME-LIST\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_prog in egrep\n   do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      ac_path_EGREP=\"$as_dir$ac_prog$ac_exec_ext\"\n      as_fn_executable_p \"$ac_path_EGREP\" || continue\n# Check for GNU ac_path_EGREP and select it if it is found.\n  # Check for GNU $ac_path_EGREP\ncase `\"$ac_path_EGREP\" --version 2>&1` in #(\n*GNU*)\n  ac_cv_path_EGREP=\"$ac_path_EGREP\" ac_path_EGREP_found=:;;\n#(\n*)\n  ac_count=0\n  printf %s 0123456789 >\"conftest.in\"\n  while :\n  do\n    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n    mv \"conftest.tmp\" \"conftest.in\"\n    cp \"conftest.in\" \"conftest.nl\"\n    printf \"%s\\n\" 'EGREP' >> \"conftest.nl\"\n    \"$ac_path_EGREP\" 'EGREP$' < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n    as_fn_arith $ac_count + 1 && ac_count=$as_val\n    if test $ac_count -gt ${ac_path_EGREP_max-0}; then\n      # Best one so far, save it but keep looking for a better one\n      ac_cv_path_EGREP=\"$ac_path_EGREP\"\n      ac_path_EGREP_max=$ac_count\n    fi\n    # 10*(2^10) chars as input seems more than enough\n    test $ac_count -gt 10 && break\n  done\n  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\nesac\n\n      $ac_path_EGREP_found && break 3\n    done\n  done\n  done\nIFS=$as_save_IFS\n  if test -z \"$ac_cv_path_EGREP\"; then\n    as_fn_error $? \"no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin\" \"$LINENO\" 5\n  fi\nelse\n  ac_cv_path_EGREP=$EGREP\nfi\n\n   fi ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP\" >&5\nprintf \"%s\\n\" \"$ac_cv_path_EGREP\" >&6; }\n EGREP=\"$ac_cv_path_EGREP\"\n\n         EGREP_TRADITIONAL=$EGREP\n ac_cv_path_EGREP_TRADITIONAL=$EGREP\n\n\nac_fn_c_check_header_compile \"$LINENO\" \"fcntl.h\" \"ac_cv_header_fcntl_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_fcntl_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_FCNTL_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"limits.h\" \"ac_cv_header_limits_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_limits_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LIMITS_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"langinfo.h\" \"ac_cv_header_langinfo_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_langinfo_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LANGINFO_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"locale.h\" \"ac_cv_header_locale_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_locale_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LOCALE_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"stdint.h\" \"ac_cv_header_stdint_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_stdint_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STDINT_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"stdlib.h\" \"ac_cv_header_stdlib_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_stdlib_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STDLIB_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"string.h\" \"ac_cv_header_string_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_string_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRING_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"sys/ioctl.h\" \"ac_cv_header_sys_ioctl_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_ioctl_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_IOCTL_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"sys/time.h\" \"ac_cv_header_sys_time_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_sys_time_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SYS_TIME_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"termios.h\" \"ac_cv_header_termios_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_termios_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_TERMIOS_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"unistd.h\" \"ac_cv_header_unistd_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_unistd_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_UNISTD_H 1\" >>confdefs.h\n\nfi\nac_fn_c_check_header_compile \"$LINENO\" \"wchar.h\" \"ac_cv_header_wchar_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_wchar_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_WCHAR_H 1\" >>confdefs.h\n\nfi\n\n\n# Checks for typedefs, structures, and compiler characteristics.\nac_fn_c_check_type \"$LINENO\" \"size_t\" \"ac_cv_type_size_t\" \"$ac_includes_default\"\nif test \"x$ac_cv_type_size_t\" = xyes\nthen :\n\nelse case e in #(\n  e)\nprintf \"%s\\n\" \"#define size_t unsigned int\" >>confdefs.h\n ;;\nesac\nfi\n\n\n# Checks for library functions.\n\n\n  # Make sure we can run config.sub.\n$SHELL \"${ac_aux_dir}config.sub\" sun4 >/dev/null 2>&1 ||\n  as_fn_error $? \"cannot run $SHELL ${ac_aux_dir}config.sub\" \"$LINENO\" 5\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking build system type\" >&5\nprintf %s \"checking build system type... \" >&6; }\nif test ${ac_cv_build+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) ac_build_alias=$build_alias\ntest \"x$ac_build_alias\" = x &&\n  ac_build_alias=`$SHELL \"${ac_aux_dir}config.guess\"`\ntest \"x$ac_build_alias\" = x &&\n  as_fn_error $? \"cannot guess build type; you must specify one\" \"$LINENO\" 5\nac_cv_build=`$SHELL \"${ac_aux_dir}config.sub\" $ac_build_alias` ||\n  as_fn_error $? \"$SHELL ${ac_aux_dir}config.sub $ac_build_alias failed\" \"$LINENO\" 5\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_build\" >&5\nprintf \"%s\\n\" \"$ac_cv_build\" >&6; }\ncase $ac_cv_build in\n*-*-*) ;;\n*) as_fn_error $? \"invalid value of canonical build\" \"$LINENO\" 5;;\nesac\nbuild=$ac_cv_build\nac_save_IFS=$IFS; IFS='-'\nset x $ac_cv_build\nshift\nbuild_cpu=$1\nbuild_vendor=$2\nshift; shift\n# Remember, the first character of IFS is used to create $*,\n# except with old shells:\nbuild_os=$*\nIFS=$ac_save_IFS\ncase $build_os in *\\ *) build_os=`echo \"$build_os\" | sed 's/ /-/g'`;; esac\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking host system type\" >&5\nprintf %s \"checking host system type... \" >&6; }\nif test ${ac_cv_host+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test \"x$host_alias\" = x; then\n  ac_cv_host=$ac_cv_build\nelse\n  ac_cv_host=`$SHELL \"${ac_aux_dir}config.sub\" $host_alias` ||\n    as_fn_error $? \"$SHELL ${ac_aux_dir}config.sub $host_alias failed\" \"$LINENO\" 5\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_host\" >&5\nprintf \"%s\\n\" \"$ac_cv_host\" >&6; }\ncase $ac_cv_host in\n*-*-*) ;;\n*) as_fn_error $? \"invalid value of canonical host\" \"$LINENO\" 5;;\nesac\nhost=$ac_cv_host\nac_save_IFS=$IFS; IFS='-'\nset x $ac_cv_host\nshift\nhost_cpu=$1\nhost_vendor=$2\nshift; shift\n# Remember, the first character of IFS is used to create $*,\n# except with old shells:\nhost_os=$*\nIFS=$ac_save_IFS\ncase $host_os in *\\ *) host_os=`echo \"$host_os\" | sed 's/ /-/g'`;; esac\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for GNU libc compatible malloc\" >&5\nprintf %s \"checking for GNU libc compatible malloc... \" >&6; }\nif test ${ac_cv_func_malloc_0_nonnull+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test \"$cross_compiling\" = yes\nthen :\n  case \"$host_os\" in # ((\n\t\t  # Guess yes on platforms where we know the result.\n\t\t  *-gnu* | freebsd* | netbsd* | openbsd* | bitrig* \\\n\t\t  | hpux* | solaris* | cygwin* | mingw* | windows* | msys* )\n\t\t    ac_cv_func_malloc_0_nonnull=yes ;;\n\t\t  # If we don't know, assume the worst.\n\t\t  *) ac_cv_func_malloc_0_nonnull=no ;;\n\t\tesac\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdlib.h>\n\nint\nmain (void)\n{\nvoid *p = malloc (0);\n\t\t   int result = !p;\n\t\t   free (p);\n\t\t   return result;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"\nthen :\n  ac_cv_func_malloc_0_nonnull=yes\nelse case e in #(\n  e) ac_cv_func_malloc_0_nonnull=no ;;\nesac\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_malloc_0_nonnull\" >&5\nprintf \"%s\\n\" \"$ac_cv_func_malloc_0_nonnull\" >&6; }\nif test $ac_cv_func_malloc_0_nonnull = yes\nthen :\n\nprintf \"%s\\n\" \"#define HAVE_MALLOC 1\" >>confdefs.h\n\nelse case e in #(\n  e) printf \"%s\\n\" \"#define HAVE_MALLOC 0\" >>confdefs.h\n\n   case \" $LIBOBJS \" in\n  *\" malloc.$ac_objext \"* ) ;;\n  *) LIBOBJS=\"$LIBOBJS malloc.$ac_objext\"\n ;;\nesac\n\n\nprintf \"%s\\n\" \"#define malloc rpl_malloc\" >>confdefs.h\n ;;\nesac\nfi\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for GNU libc compatible realloc\" >&5\nprintf %s \"checking for GNU libc compatible realloc... \" >&6; }\nif test ${ac_cv_func_realloc_0_nonnull+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse case e in #(\n  e) if test \"$cross_compiling\" = yes\nthen :\n  case \"$host_os\" in # ((\n\t\t  # Guess yes on platforms where we know the result.\n\t\t  *-gnu* | freebsd* | netbsd* | openbsd* | bitrig* \\\n\t\t  | hpux* | solaris* | cygwin* | mingw* | windows* | msys* )\n\t\t    ac_cv_func_realloc_0_nonnull=yes ;;\n\t\t  # If we don't know, assume the worst.\n\t\t  *) ac_cv_func_realloc_0_nonnull=no ;;\n\t\tesac\nelse case e in #(\n  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdlib.h>\n\nint\nmain (void)\n{\nvoid *p = realloc (0, 0);\n\t\t   int result = !p;\n\t\t   free (p);\n\t\t   return result;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"\nthen :\n  ac_cv_func_realloc_0_nonnull=yes\nelse case e in #(\n  e) ac_cv_func_realloc_0_nonnull=no ;;\nesac\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext ;;\nesac\nfi\n ;;\nesac\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_realloc_0_nonnull\" >&5\nprintf \"%s\\n\" \"$ac_cv_func_realloc_0_nonnull\" >&6; }\nif test $ac_cv_func_realloc_0_nonnull = yes\nthen :\n\nprintf \"%s\\n\" \"#define HAVE_REALLOC 1\" >>confdefs.h\n\nelse case e in #(\n  e) printf \"%s\\n\" \"#define HAVE_REALLOC 0\" >>confdefs.h\n\n   case \" $LIBOBJS \" in\n  *\" realloc.$ac_objext \"* ) ;;\n  *) LIBOBJS=\"$LIBOBJS realloc.$ac_objext\"\n ;;\nesac\n\n\nprintf \"%s\\n\" \"#define realloc rpl_realloc\" >>confdefs.h\n ;;\nesac\nfi\n\n\nac_fn_c_check_func \"$LINENO\" \"mblen\" \"ac_cv_func_mblen\"\nif test \"x$ac_cv_func_mblen\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_MBLEN 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"memset\" \"ac_cv_func_memset\"\nif test \"x$ac_cv_func_memset\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_MEMSET 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"nl_langinfo\" \"ac_cv_func_nl_langinfo\"\nif test \"x$ac_cv_func_nl_langinfo\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_NL_LANGINFO 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"pathconf\" \"ac_cv_func_pathconf\"\nif test \"x$ac_cv_func_pathconf\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_PATHCONF 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"regcomp\" \"ac_cv_func_regcomp\"\nif test \"x$ac_cv_func_regcomp\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_REGCOMP 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"setlocale\" \"ac_cv_func_setlocale\"\nif test \"x$ac_cv_func_setlocale\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_SETLOCALE 1\" >>confdefs.h\n\nfi\n\nac_fn_c_check_func \"$LINENO\" \"strchr\" \"ac_cv_func_strchr\"\nif test \"x$ac_cv_func_strchr\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRCHR 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"strrchr\" \"ac_cv_func_strrchr\"\nif test \"x$ac_cv_func_strrchr\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRRCHR 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"strspn\" \"ac_cv_func_strspn\"\nif test \"x$ac_cv_func_strspn\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRSPN 1\" >>confdefs.h\n\nfi\nac_fn_c_check_func \"$LINENO\" \"strcasecmp\" \"ac_cv_func_strcasecmp\"\nif test \"x$ac_cv_func_strcasecmp\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_STRCASECMP 1\" >>confdefs.h\n\nfi\n\n\n\n# OS-specific tests\ncase \"${host_os}\" in\n*freebsd*|*dragonfly*)\n  CPPFLAGS=\"-D__BSD_VISIBLE $CPPFLAGS\"\n  ;;\n\n*darwin*)\n  CPPFLAGS=\"-D_DARWIN_C_SOURCE $CPPFLAGS\"\n  ;;\n\n*netbsd*)\n  CPPFLAGS=\"-D_NETBSD_SOURCE $CPPFLAGS\"\n  ;;\n\n*openbsd*|*bitrig*)\n  CPPFLAGS=\"-D_BSD_SOURCE $CPPFLAGS\"\n  ;;\nesac\n\nac_config_files=\"$ac_config_files Makefile\"\n\ncat >confcache <<\\_ACEOF\n# This file is a shell script that caches the results of configure\n# tests run on this system so they can be shared between configure\n# scripts and configure runs, see configure's option --config-cache.\n# It is not useful on other systems.  If it contains results you don't\n# want to keep, you may remove or edit it.\n#\n# config.status only pays attention to the cache file if you give it\n# the --recheck option to rerun configure.\n#\n# 'ac_cv_env_foo' variables (set or unset) will be overridden when\n# loading this file, other *unset* 'ac_cv_foo' will be assigned the\n# following values.\n\n_ACEOF\n\n# The following way of writing the cache mishandles newlines in values,\n# but we know of no workaround that is simple, portable, and efficient.\n# So, we kill variables containing newlines.\n# Ultrix sh set writes to stderr and can't be redirected directly,\n# and sets the high bit in the cache file unless we assign to the vars.\n(\n  for ac_var in `(set) 2>&1 | sed -n 's/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n\n  (set) 2>&1 |\n    case $as_nl`(ac_space=' '; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      # 'set' does not quote correctly, so add quotes: double-quote\n      # substitution turns \\\\\\\\ into \\\\, and sed turns \\\\ into \\.\n      sed -n \\\n\t\"s/'/'\\\\\\\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\\\2'/p\"\n      ;; #(\n    *)\n      # 'set' quotes correctly as required by POSIX, so do not add quotes.\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n) |\n  sed '\n     /^ac_cv_env_/b end\n     t clear\n     :clear\n     s/^\\([^=]*\\)=\\(.*[{}].*\\)$/test ${\\1+y} || &/\n     t end\n     s/^\\([^=]*\\)=\\(.*\\)$/\\1=${\\1=\\2}/\n     :end' >>confcache\nif diff \"$cache_file\" confcache >/dev/null 2>&1; then :; else\n  if test -w \"$cache_file\"; then\n    if test \"x$cache_file\" != \"x/dev/null\"; then\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: updating cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: updating cache $cache_file\" >&6;}\n      if test ! -f \"$cache_file\" || test -h \"$cache_file\"; then\n\tcat confcache >\"$cache_file\"\n      else\n        case $cache_file in #(\n        */* | ?:*)\n\t  mv -f confcache \"$cache_file\"$$ &&\n\t  mv -f \"$cache_file\"$$ \"$cache_file\" ;; #(\n        *)\n\t  mv -f confcache \"$cache_file\" ;;\n\tesac\n      fi\n    fi\n  else\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: not updating unwritable cache $cache_file\" >&6;}\n  fi\nfi\nrm -f confcache\n\ntest \"x$prefix\" = xNONE && prefix=$ac_default_prefix\n# Let make expand exec_prefix.\ntest \"x$exec_prefix\" = xNONE && exec_prefix='${prefix}'\n\nDEFS=-DHAVE_CONFIG_H\n\nac_libobjs=\nac_ltlibobjs=\nU=\nfor ac_i in : $LIBOBJS; do test \"x$ac_i\" = x: && continue\n  # 1. Remove the extension, and $U if already installed.\n  ac_script='s/\\$U\\././;s/\\.o$//;s/\\.obj$//'\n  ac_i=`printf \"%s\\n\" \"$ac_i\" | sed \"$ac_script\"`\n  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR\n  #    will be set to the directory where LIBOBJS objects are built.\n  as_fn_append ac_libobjs \" \\${LIBOBJDIR}$ac_i\\$U.$ac_objext\"\n  as_fn_append ac_ltlibobjs \" \\${LIBOBJDIR}$ac_i\"'$U.lo'\ndone\nLIBOBJS=$ac_libobjs\n\nLTLIBOBJS=$ac_ltlibobjs\n\n\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure\" >&5\nprintf %s \"checking that generated files are newer than configure... \" >&6; }\n   if test -n \"$am_sleep_pid\"; then\n     # Hide warnings about reused PIDs.\n     wait $am_sleep_pid 2>/dev/null\n   fi\n   { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: done\" >&5\nprintf \"%s\\n\" \"done\" >&6; }\ncase $enable_silent_rules in # (((\n  yes) AM_DEFAULT_VERBOSITY=0;;\n   no) AM_DEFAULT_VERBOSITY=1;;\nesac\nif test $am_cv_make_support_nested_variables = yes; then\n    AM_V='$(V)'\n  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'\nelse\n  AM_V=$AM_DEFAULT_VERBOSITY\n  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY\nfi\n\n if test -n \"$EXEEXT\"; then\n  am__EXEEXT_TRUE=\n  am__EXEEXT_FALSE='#'\nelse\n  am__EXEEXT_TRUE='#'\n  am__EXEEXT_FALSE=\nfi\n\nif test -z \"${AMDEP_TRUE}\" && test -z \"${AMDEP_FALSE}\"; then\n  as_fn_error $? \"conditional \\\"AMDEP\\\" was never defined.\nUsually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\nfi\nif test -z \"${am__fastdepCC_TRUE}\" && test -z \"${am__fastdepCC_FALSE}\"; then\n  as_fn_error $? \"conditional \\\"am__fastdepCC\\\" was never defined.\nUsually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\nfi\nif test -z \"${am__fastdepCC_TRUE}\" && test -z \"${am__fastdepCC_FALSE}\"; then\n  as_fn_error $? \"conditional \\\"am__fastdepCC\\\" was never defined.\nUsually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\nfi\n\n: \"${CONFIG_STATUS=./config.status}\"\nac_write_fail=0\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files $CONFIG_STATUS\"\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS\" >&5\nprintf \"%s\\n\" \"$as_me: creating $CONFIG_STATUS\" >&6;}\nas_write_fail=0\ncat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\n\ndebug=false\nac_cs_recheck=false\nac_cs_silent=false\n\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$CONFIG_STATUS <<\\_ASEOF || as_write_fail=1\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nif test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse case e in #(\n  e) case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac ;;\nesac\nfi\n\n\n\n# Reset variables that may have inherited troublesome values from\n# the environment.\n\n# IFS needs to be set, to space, tab, and newline, in precisely that order.\n# (If _AS_PATH_WALK were called with IFS unset, it would have the\n# side effect of setting IFS to empty, thus disabling word splitting.)\n# Quoting is to prevent editors from complaining about space-tab.\nas_nl='\n'\nexport as_nl\nIFS=\" \"\"\t$as_nl\"\n\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# Ensure predictable behavior from utilities with locale-dependent output.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# We cannot yet rely on \"unset\" to work, but we need these variables\n# to be unset--not just set to an empty or harmless value--now, to\n# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct\n# also avoids known problems related to \"unset\" and subshell syntax\n# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).\nfor as_var in BASH_ENV ENV MAIL MAILPATH CDPATH\ndo eval test \\${$as_var+y} \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\n\n# Ensure that fds 0, 1, and 2 are open.\nif (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi\nif (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi\nif (exec 3>&2)            ; then :; else exec 2>/dev/null; fi\n\n# The user is always right.\nif ${PATH_SEPARATOR+false} :; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    test -r \"$as_dir$0\" && as_myself=$as_dir$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as 'sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  printf \"%s\\n\" \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  printf \"%s\\n\" \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null\nthen :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse case e in #(\n  e) as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  } ;;\nesac\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null\nthen :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse case e in #(\n  e) as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  } ;;\nesac\nfi # as_fn_arith\n\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n# Determine whether it's possible to make 'echo' print without a newline.\n# These variables are no longer used directly by Autoconf, but are AC_SUBSTed\n# for compatibility with existing Makefiles.\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\n# For backward compatibility with old third-party macros, we provide\n# the shell variables $as_echo and $as_echo_n.  New code should use\n# AS_ECHO([\"message\"]) and AS_ECHO_N([\"message\"]), respectively.\nas_echo='printf %s\\n'\nas_echo_n='printf %s'\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both 'ln -s file dir' and 'ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; 'ln -s' creates a wrapper executable.\n    # In both cases, we have to default to 'cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`printf \"%s\\n\" \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_sed_cpp=\"y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g\"\nas_tr_cpp=\"eval sed '$as_sed_cpp'\" # deprecated\n\n# Sed expression to map a string onto a valid variable name.\nas_sed_sh=\"y%*+%pp%;s%[^_$as_cr_alnum]%_%g\"\nas_tr_sh=\"eval sed '$as_sed_sh'\" # deprecated\n\n\nexec 6>&1\n## ----------------------------------- ##\n## Main body of $CONFIG_STATUS script. ##\n## ----------------------------------- ##\n_ASEOF\ntest $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# Save the log message, to keep $0 and so on meaningful, and to\n# report actual input values of CONFIG_FILES etc. instead of their\n# values after options handling.\nac_log=\"\nThis file was extended by smenu $as_me 1.4.0, which was\ngenerated by GNU Autoconf 2.72.  Invocation command line was\n\n  CONFIG_FILES    = $CONFIG_FILES\n  CONFIG_HEADERS  = $CONFIG_HEADERS\n  CONFIG_LINKS    = $CONFIG_LINKS\n  CONFIG_COMMANDS = $CONFIG_COMMANDS\n  $ $0 $@\n\non `(hostname || uname -n) 2>/dev/null | sed 1q`\n\"\n\n_ACEOF\n\ncase $ac_config_files in *\"\n\"*) set x $ac_config_files; shift; ac_config_files=$*;;\nesac\n\ncase $ac_config_headers in *\"\n\"*) set x $ac_config_headers; shift; ac_config_headers=$*;;\nesac\n\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n# Files that config.status was made for.\nconfig_files=\"$ac_config_files\"\nconfig_headers=\"$ac_config_headers\"\nconfig_commands=\"$ac_config_commands\"\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nac_cs_usage=\"\\\n'$as_me' instantiates files and other configuration actions\nfrom templates according to the current configuration.  Unless the files\nand actions are specified as TAGs, all are instantiated by default.\n\nUsage: $0 [OPTION]... [TAG]...\n\n  -h, --help       print this help, then exit\n  -V, --version    print version number and configuration settings, then exit\n      --config     print configuration, then exit\n  -q, --quiet, --silent\n                   do not print progress messages\n  -d, --debug      don't remove temporary files\n      --recheck    update $as_me by reconfiguring in the same conditions\n      --file=FILE[:TEMPLATE]\n                   instantiate the configuration file FILE\n      --header=FILE[:TEMPLATE]\n                   instantiate the configuration header FILE\n\nConfiguration files:\n$config_files\n\nConfiguration headers:\n$config_headers\n\nConfiguration commands:\n$config_commands\n\nReport bugs to <p.gen.progs@gmail.com>.\"\n\n_ACEOF\nac_cs_config=`printf \"%s\\n\" \"$ac_configure_args\" | sed \"$ac_safe_unquote\"`\nac_cs_config_escaped=`printf \"%s\\n\" \"$ac_cs_config\" | sed \"s/^ //; s/'/'\\\\\\\\\\\\\\\\''/g\"`\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_cs_config='$ac_cs_config_escaped'\nac_cs_version=\"\\\\\nsmenu config.status 1.4.0\nconfigured by $0, generated by GNU Autoconf 2.72,\n  with options \\\\\"\\$ac_cs_config\\\\\"\n\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis config.status script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\"\n\nac_pwd='$ac_pwd'\nsrcdir='$srcdir'\nINSTALL='$INSTALL'\nMKDIR_P='$MKDIR_P'\nAWK='$AWK'\ntest -n \"\\$AWK\" || AWK=awk\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# The default lists apply if the user does not specify any file.\nac_need_defaults=:\nwhile test $# != 0\ndo\n  case $1 in\n  --*=?*)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=`expr \"X$1\" : 'X[^=]*=\\(.*\\)'`\n    ac_shift=:\n    ;;\n  --*=)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=\n    ac_shift=:\n    ;;\n  *)\n    ac_option=$1\n    ac_optarg=$2\n    ac_shift=shift\n    ;;\n  esac\n\n  case $ac_option in\n  # Handling of the options.\n  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)\n    ac_cs_recheck=: ;;\n  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )\n    printf \"%s\\n\" \"$ac_cs_version\"; exit ;;\n  --config | --confi | --conf | --con | --co | --c )\n    printf \"%s\\n\" \"$ac_cs_config\"; exit ;;\n  --debug | --debu | --deb | --de | --d | -d )\n    debug=: ;;\n  --file | --fil | --fi | --f )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`printf \"%s\\n\" \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    '') as_fn_error $? \"missing file argument\" ;;\n    esac\n    as_fn_append CONFIG_FILES \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --header | --heade | --head | --hea )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`printf \"%s\\n\" \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    as_fn_append CONFIG_HEADERS \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --he | --h)\n    # Conflict between --help and --header\n    as_fn_error $? \"ambiguous option: '$1'\nTry '$0 --help' for more information.\";;\n  --help | --hel | -h )\n    printf \"%s\\n\" \"$ac_cs_usage\"; exit ;;\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil | --si | --s)\n    ac_cs_silent=: ;;\n\n  # This is an error.\n  -*) as_fn_error $? \"unrecognized option: '$1'\nTry '$0 --help' for more information.\" ;;\n\n  *) as_fn_append ac_config_targets \" $1\"\n     ac_need_defaults=false ;;\n\n  esac\n  shift\ndone\n\nac_configure_extra_args=\n\nif $ac_cs_silent; then\n  exec 6>/dev/null\n  ac_configure_extra_args=\"$ac_configure_extra_args --silent\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nif \\$ac_cs_recheck; then\n  set X $SHELL '$0' $ac_configure_args \\$ac_configure_extra_args --no-create --no-recursion\n  shift\n  \\printf \"%s\\n\" \"running CONFIG_SHELL=$SHELL \\$*\" >&6\n  CONFIG_SHELL='$SHELL'\n  export CONFIG_SHELL\n  exec \"\\$@\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nexec 5>>config.log\n{\n  echo\n  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX\n## Running $as_me. ##\n_ASBOX\n  printf \"%s\\n\" \"$ac_log\"\n} >&5\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n#\n# INIT-COMMANDS\n#\nAMDEP_TRUE=\"$AMDEP_TRUE\" MAKE=\"${MAKE-make}\"\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n\n# Handling of arguments.\nfor ac_config_target in $ac_config_targets\ndo\n  case $ac_config_target in\n    \"config.h\") CONFIG_HEADERS=\"$CONFIG_HEADERS config.h\" ;;\n    \"depfiles\") CONFIG_COMMANDS=\"$CONFIG_COMMANDS depfiles\" ;;\n    \"Makefile\") CONFIG_FILES=\"$CONFIG_FILES Makefile\" ;;\n\n  *) as_fn_error $? \"invalid argument: '$ac_config_target'\" \"$LINENO\" 5;;\n  esac\ndone\n\n\n# If the user did not use the arguments to specify the items to instantiate,\n# then the envvar interface is used.  Set only those that are not.\n# We use the long form for the default assignment because of an extremely\n# bizarre bug on SunOS 4.1.3.\nif $ac_need_defaults; then\n  test ${CONFIG_FILES+y} || CONFIG_FILES=$config_files\n  test ${CONFIG_HEADERS+y} || CONFIG_HEADERS=$config_headers\n  test ${CONFIG_COMMANDS+y} || CONFIG_COMMANDS=$config_commands\nfi\n\n# Have a temporary directory for convenience.  Make it in the build tree\n# simply because there is no reason against having it here, and in addition,\n# creating and moving files from /tmp can sometimes cause problems.\n# Hook for its removal unless debugging.\n# Note that there is a small window in which the directory will not be cleaned:\n# after its creation but before its name has been assigned to '$tmp'.\n$debug ||\n{\n  tmp= ac_tmp=\n  trap 'exit_status=$?\n  : \"${ac_tmp:=$tmp}\"\n  { test ! -d \"$ac_tmp\" || rm -fr \"$ac_tmp\"; } && exit $exit_status\n' 0\n  trap 'as_fn_exit 1' 1 2 13 15\n}\n# Create a (secure) tmp directory for tmp files.\n\n{\n  tmp=`(umask 077 && mktemp -d \"./confXXXXXX\") 2>/dev/null` &&\n  test -d \"$tmp\"\n}  ||\n{\n  tmp=./conf$$-$RANDOM\n  (umask 077 && mkdir \"$tmp\")\n} || as_fn_error $? \"cannot create a temporary directory in .\" \"$LINENO\" 5\nac_tmp=$tmp\n\n# Set up the scripts for CONFIG_FILES section.\n# No need to generate them if there are no CONFIG_FILES.\n# This happens for instance with './config.status config.h'.\nif test -n \"$CONFIG_FILES\"; then\n\n\nac_cr=`echo X | tr X '\\015'`\n# On cygwin, bash can eat \\r inside `` if the user requested igncr.\n# But we know of no other shell where ac_cr would be empty at this\n# point, so we can use a bashism as a fallback.\nif test \"x$ac_cr\" = x; then\n  eval ac_cr=\\$\\'\\\\r\\'\nfi\nac_cs_awk_cr=`$AWK 'BEGIN { print \"a\\rb\" }' </dev/null 2>/dev/null`\nif test \"$ac_cs_awk_cr\" = \"a${ac_cr}b\"; then\n  ac_cs_awk_cr='\\\\r'\nelse\n  ac_cs_awk_cr=$ac_cr\nfi\n\necho 'BEGIN {' >\"$ac_tmp/subs1.awk\" &&\n_ACEOF\n\n\n{\n  echo \"cat >conf$$subs.awk <<_ACEOF\" &&\n  echo \"$ac_subst_vars\" | sed 's/.*/&!$&$ac_delim/' &&\n  echo \"_ACEOF\"\n} >conf$$subs.sh ||\n  as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\nac_delim_num=`echo \"$ac_subst_vars\" | grep -c '^'`\nac_delim='%!_!# '\nfor ac_last_try in false false false false false :; do\n  . ./conf$$subs.sh ||\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n\n  ac_delim_n=`sed -n \"s/.*$ac_delim\\$/X/p\" conf$$subs.awk | grep -c X`\n  if test $ac_delim_n = $ac_delim_num; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\nrm -f conf$$subs.sh\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\ncat >>\"\\$ac_tmp/subs1.awk\" <<\\\\_ACAWK &&\n_ACEOF\nsed -n '\nh\ns/^/S[\"/; s/!.*/\"]=/\np\ng\ns/^[^!]*!//\n:repl\nt repl\ns/'\"$ac_delim\"'$//\nt delim\n:nl\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\n\"\\\\/\np\nn\nb repl\n:more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt nl\n:delim\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/\np\nb\n:more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt delim\n' <conf$$subs.awk | sed '\n/^[^\"\"]/{\n  N\n  s/\\n//\n}\n' >>$CONFIG_STATUS || ac_write_fail=1\nrm -f conf$$subs.awk\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACAWK\ncat >>\"\\$ac_tmp/subs1.awk\" <<_ACAWK &&\n  for (key in S) S_is_set[key] = 1\n  FS = \"\u0007\"\n\n}\n{\n  line = $ 0\n  nfields = split(line, field, \"@\")\n  substed = 0\n  len = length(field[1])\n  for (i = 2; i < nfields; i++) {\n    key = field[i]\n    keylen = length(key)\n    if (S_is_set[key]) {\n      value = S[key]\n      line = substr(line, 1, len) \"\" value \"\" substr(line, len + keylen + 3)\n      len += length(value) + length(field[++i])\n      substed = 1\n    } else\n      len += 1 + keylen\n  }\n\n  print line\n}\n\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nif sed \"s/$ac_cr//\" < /dev/null > /dev/null 2>&1; then\n  sed \"s/$ac_cr\\$//; s/$ac_cr/$ac_cs_awk_cr/g\"\nelse\n  cat\nfi < \"$ac_tmp/subs1.awk\" > \"$ac_tmp/subs.awk\" \\\n  || as_fn_error $? \"could not setup config files machinery\" \"$LINENO\" 5\n_ACEOF\n\n# VPATH may cause trouble with some makes, so we remove sole $(srcdir),\n# ${srcdir} and @srcdir@ entries from VPATH if srcdir is \".\", strip leading and\n# trailing colons and then remove the whole line if VPATH becomes empty\n# (actually we leave an empty line to preserve line numbers).\nif test \"x$srcdir\" = x.; then\n  ac_vpsub='/^[\t ]*VPATH[\t ]*=[\t ]*/{\nh\ns///\ns/^/:/\ns/[\t ]*$/:/\ns/:\\$(srcdir):/:/g\ns/:\\${srcdir}:/:/g\ns/:@srcdir@:/:/g\ns/^:*//\ns/:*$//\nx\ns/\\(=[\t ]*\\).*/\\1/\nG\ns/\\n//\ns/^[^=]*=[\t ]*$//\n}'\nfi\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nfi # test -n \"$CONFIG_FILES\"\n\n# Set up the scripts for CONFIG_HEADERS section.\n# No need to generate them if there are no CONFIG_HEADERS.\n# This happens for instance with './config.status Makefile'.\nif test -n \"$CONFIG_HEADERS\"; then\ncat >\"$ac_tmp/defines.awk\" <<\\_ACAWK ||\nBEGIN {\n_ACEOF\n\n# Transform confdefs.h into an awk script 'defines.awk', embedded as\n# here-document in config.status, that substitutes the proper values into\n# config.h.in to produce config.h.\n\n# Create a delimiter string that does not exist in confdefs.h, to ease\n# handling of long lines.\nac_delim='%!_!# '\nfor ac_last_try in false false :; do\n  ac_tt=`sed -n \"/$ac_delim/p\" confdefs.h`\n  if test -z \"$ac_tt\"; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_HEADERS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\n\n# For the awk script, D is an array of macro values keyed by name,\n# likewise P contains macro parameters if any.  Preserve backslash\n# newline sequences.\n\nac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*\nsed -n '\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt rset\n:rset\ns/^[\t ]*#[\t ]*define[\t ][\t ]*/ /\nt def\nd\n:def\ns/\\\\$//\nt bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\"/p\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\"/p\nd\n:bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\\\\\\\\\\\\n\"\\\\/p\nt cont\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\\\\\\\\\\\\n\"\\\\/p\nt cont\nd\n:cont\nn\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt clear\n:clear\ns/\\\\$//\nt bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/p\nd\n:bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\\\\\\\\\n\"\\\\/p\nb cont\n' <confdefs.h | sed '\ns/'\"$ac_delim\"'/\"\\\\\\\n\"/g' >>$CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  for (key in D) D_is_set[key] = 1\n  FS = \"\u0007\"\n}\n/^[\\t ]*#[\\t ]*(define|undef)[\\t ]+$ac_word_re([\\t (]|\\$)/ {\n  line = \\$ 0\n  split(line, arg, \" \")\n  if (arg[1] == \"#\") {\n    defundef = arg[2]\n    mac1 = arg[3]\n  } else {\n    defundef = substr(arg[1], 2)\n    mac1 = arg[2]\n  }\n  split(mac1, mac2, \"(\") #)\n  macro = mac2[1]\n  prefix = substr(line, 1, index(line, defundef) - 1)\n  if (D_is_set[macro]) {\n    # Preserve the white space surrounding the \"#\".\n    print prefix \"define\", macro P[macro] D[macro]\n    next\n  } else {\n    # Replace #undef with comments.  This is necessary, for example,\n    # in the case of _POSIX_SOURCE, which is predefined and required\n    # on some systems where configure will not decide to define it.\n    if (defundef == \"undef\") {\n      print \"/*\", prefix defundef, macro, \"*/\"\n      next\n    }\n  }\n}\n{ print }\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n  as_fn_error $? \"could not setup config headers machinery\" \"$LINENO\" 5\nfi # test -n \"$CONFIG_HEADERS\"\n\n\neval set X \"  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS\"\nshift\nfor ac_tag\ndo\n  case $ac_tag in\n  :[FHLC]) ac_mode=$ac_tag; continue;;\n  esac\n  case $ac_mode$ac_tag in\n  :[FHL]*:*);;\n  :L* | :C*:*) as_fn_error $? \"invalid tag '$ac_tag'\" \"$LINENO\" 5;;\n  :[FH]-) ac_tag=-:-;;\n  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;\n  esac\n  ac_save_IFS=$IFS\n  IFS=:\n  set x $ac_tag\n  IFS=$ac_save_IFS\n  shift\n  ac_file=$1\n  shift\n\n  case $ac_mode in\n  :L) ac_source=$1;;\n  :[FH])\n    ac_file_inputs=\n    for ac_f\n    do\n      case $ac_f in\n      -) ac_f=\"$ac_tmp/stdin\";;\n      *) # Look for the file first in the build tree, then in the source tree\n\t # (if the path is not absolute).  The absolute path cannot be DOS-style,\n\t # because $ac_f cannot contain ':'.\n\t test -f \"$ac_f\" ||\n\t   case $ac_f in\n\t   [\\\\/$]*) false;;\n\t   *) test -f \"$srcdir/$ac_f\" && ac_f=\"$srcdir/$ac_f\";;\n\t   esac ||\n\t   as_fn_error 1 \"cannot find input file: '$ac_f'\" \"$LINENO\" 5;;\n      esac\n      case $ac_f in *\\'*) ac_f=`printf \"%s\\n\" \"$ac_f\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; esac\n      as_fn_append ac_file_inputs \" '$ac_f'\"\n    done\n\n    # Let's still pretend it is 'configure' which instantiates (i.e., don't\n    # use $as_me), people would be surprised to read:\n    #    /* config.h.  Generated by config.status.  */\n    configure_input='Generated from '`\n\t  printf \"%s\\n\" \"$*\" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'\n\t`' by configure.'\n    if test x\"$ac_file\" != x-; then\n      configure_input=\"$ac_file.  $configure_input\"\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating $ac_file\" >&5\nprintf \"%s\\n\" \"$as_me: creating $ac_file\" >&6;}\n    fi\n    # Neutralize special characters interpreted by sed in replacement strings.\n    case $configure_input in #(\n    *\\&* | *\\|* | *\\\\* )\n       ac_sed_conf_input=`printf \"%s\\n\" \"$configure_input\" |\n       sed 's/[\\\\\\\\&|]/\\\\\\\\&/g'`;; #(\n    *) ac_sed_conf_input=$configure_input;;\n    esac\n\n    case $ac_tag in\n    *:-:* | *:-) cat >\"$ac_tmp/stdin\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5 ;;\n    esac\n    ;;\n  esac\n\n  ac_dir=`$as_dirname -- \"$ac_file\" ||\n$as_expr X\"$ac_file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)$' \\| \\\n\t X\"$ac_file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$ac_file\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  as_dir=\"$ac_dir\"; as_fn_mkdir_p\n  ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`printf \"%s\\n\" \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`printf \"%s\\n\" \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n\n  case $ac_mode in\n  :F)\n  #\n  # CONFIG_FILE\n  #\n\n  case $INSTALL in\n  [\\\\/$]* | ?:[\\\\/]* ) ac_INSTALL=$INSTALL ;;\n  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;\n  esac\n  ac_MKDIR_P=$MKDIR_P\n  case $MKDIR_P in\n  [\\\\/$]* | ?:[\\\\/]* ) ;;\n  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;\n  esac\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# If the template does not know about datarootdir, expand it.\n# FIXME: This hack should be removed a few years after 2.60.\nac_datarootdir_hack=; ac_datarootdir_seen=\nac_sed_dataroot='\n/datarootdir/ {\n  p\n  q\n}\n/@datadir@/p\n/@docdir@/p\n/@infodir@/p\n/@localedir@/p\n/@mandir@/p'\ncase `eval \"sed -n \\\"\\$ac_sed_dataroot\\\" $ac_file_inputs\"` in\n*datarootdir*) ac_datarootdir_seen=yes;;\n*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&2;}\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  ac_datarootdir_hack='\n  s&@datadir@&$datadir&g\n  s&@docdir@&$docdir&g\n  s&@infodir@&$infodir&g\n  s&@localedir@&$localedir&g\n  s&@mandir@&$mandir&g\n  s&\\\\\\${datarootdir}&$datarootdir&g' ;;\nesac\n_ACEOF\n\n# Neutralize VPATH when '$srcdir' = '.'.\n# Shell code in configure.ac might set extrasub.\n# FIXME: do we really want to maintain this feature?\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_sed_extra=\"$ac_vpsub\n$extrasub\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n:t\n/@[a-zA-Z_][a-zA-Z_0-9]*@/!b\ns|@configure_input@|$ac_sed_conf_input|;t t\ns&@top_builddir@&$ac_top_builddir_sub&;t t\ns&@top_build_prefix@&$ac_top_build_prefix&;t t\ns&@srcdir@&$ac_srcdir&;t t\ns&@abs_srcdir@&$ac_abs_srcdir&;t t\ns&@top_srcdir@&$ac_top_srcdir&;t t\ns&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t\ns&@builddir@&$ac_builddir&;t t\ns&@abs_builddir@&$ac_abs_builddir&;t t\ns&@abs_top_builddir@&$ac_abs_top_builddir&;t t\ns&@INSTALL@&$ac_INSTALL&;t t\ns&@MKDIR_P@&$ac_MKDIR_P&;t t\n$ac_datarootdir_hack\n\"\neval sed \\\"\\$ac_sed_extra\\\" \"$ac_file_inputs\" | $AWK -f \"$ac_tmp/subs.awk\" \\\n  >$ac_tmp/out || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n\ntest -z \"$ac_datarootdir_hack$ac_datarootdir_seen\" &&\n  { ac_out=`sed -n '/\\${datarootdir}/p' \"$ac_tmp/out\"`; test -n \"$ac_out\"; } &&\n  { ac_out=`sed -n '/^[\t ]*datarootdir[\t ]*:*=/p' \\\n      \"$ac_tmp/out\"`; test -z \"$ac_out\"; } &&\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable 'datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: $ac_file contains a reference to the variable 'datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&2;}\n\n  rm -f \"$ac_tmp/stdin\"\n  case $ac_file in\n  -) cat \"$ac_tmp/out\" && rm -f \"$ac_tmp/out\";;\n  *) rm -f \"$ac_file\" && mv \"$ac_tmp/out\" \"$ac_file\";;\n  esac \\\n  || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n ;;\n  :H)\n  #\n  # CONFIG_HEADER\n  #\n  if test x\"$ac_file\" != x-; then\n    {\n      printf \"%s\\n\" \"/* $configure_input  */\" >&1 \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\"\n    } >\"$ac_tmp/config.h\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    if diff \"$ac_file\" \"$ac_tmp/config.h\" >/dev/null 2>&1; then\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: $ac_file is unchanged\" >&5\nprintf \"%s\\n\" \"$as_me: $ac_file is unchanged\" >&6;}\n    else\n      rm -f \"$ac_file\"\n      mv \"$ac_tmp/config.h\" \"$ac_file\" \\\n\t|| as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    fi\n  else\n    printf \"%s\\n\" \"/* $configure_input  */\" >&1 \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\" \\\n      || as_fn_error $? \"could not create -\" \"$LINENO\" 5\n  fi\n# Compute \"$ac_file\"'s index in $config_headers.\n_am_arg=\"$ac_file\"\n_am_stamp_count=1\nfor _am_header in $config_headers :; do\n  case $_am_header in\n    $_am_arg | $_am_arg:* )\n      break ;;\n    * )\n      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n  esac\ndone\necho \"timestamp for $_am_arg\" >`$as_dirname -- \"$_am_arg\" ||\n$as_expr X\"$_am_arg\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$_am_arg\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$_am_arg\" : 'X\\(//\\)$' \\| \\\n\t X\"$_am_arg\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$_am_arg\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`/stamp-h$_am_stamp_count\n ;;\n\n  :C)  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: executing $ac_file commands\" >&5\nprintf \"%s\\n\" \"$as_me: executing $ac_file commands\" >&6;}\n ;;\n  esac\n\n\n  case $ac_file$ac_mode in\n    \"depfiles\":C) test x\"$AMDEP_TRUE\" != x\"\" || {\n  # Older Autoconf quotes --file arguments for eval, but not when files\n  # are listed without --file.  Let's play safe and only enable the eval\n  # if we detect the quoting.\n  # TODO: see whether this extra hack can be removed once we start\n  # requiring Autoconf 2.70 or later.\n  case $CONFIG_FILES in #(\n  *\\'*) :\n    eval set x \"$CONFIG_FILES\" ;; #(\n  *) :\n    set x $CONFIG_FILES ;; #(\n  *) :\n     ;;\nesac\n  shift\n  # Used to flag and report bootstrapping failures.\n  am_rc=0\n  for am_mf\n  do\n    # Strip MF so we end up with the name of the file.\n    am_mf=`printf \"%s\\n\" \"$am_mf\" | sed -e 's/:.*$//'`\n    # Check whether this is an Automake generated Makefile which includes\n    # dependency-tracking related rules and includes.\n    # Grep'ing the whole file directly is not great: AIX grep has a line\n    # limit of 2048, but all sed's we know have understand at least 4000.\n    sed -n 's,^am--depfiles:.*,X,p' \"$am_mf\" | grep X >/dev/null 2>&1 \\\n      || continue\n    am_dirpart=`$as_dirname -- \"$am_mf\" ||\n$as_expr X\"$am_mf\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$am_mf\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$am_mf\" : 'X\\(//\\)$' \\| \\\n\t X\"$am_mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$am_mf\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n    am_filepart=`$as_basename -- \"$am_mf\" ||\n$as_expr X/\"$am_mf\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$am_mf\" : 'X\\(//\\)$' \\| \\\n\t X\"$am_mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$am_mf\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n    { echo \"$as_me:$LINENO: cd \"$am_dirpart\" \\\n      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n        | $MAKE -f - am--depfiles\" >&5\n   (cd \"$am_dirpart\" \\\n      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n        | $MAKE -f - am--depfiles) >&5 2>&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } || am_rc=$?\n  done\n  if test $am_rc -ne 0; then\n    { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in '$ac_pwd':\" >&2;}\nas_fn_error $? \"Something went wrong bootstrapping makefile fragments\n    for automatic dependency tracking.  If GNU make was not used, consider\n    re-running the configure script with MAKE=\\\"gmake\\\" (or whatever is\n    necessary).  You can also try re-running configure with the\n    '--disable-dependency-tracking' option to at least be able to build\n    the package (albeit without support for automatic dependency tracking).\nSee 'config.log' for more details\" \"$LINENO\" 5; }\n  fi\n  { am_dirpart=; unset am_dirpart;}\n  { am_filepart=; unset am_filepart;}\n  { am_mf=; unset am_mf;}\n  { am_rc=; unset am_rc;}\n  rm -f conftest-deps.mk\n}\n ;;\n\n  esac\ndone # for ac_tag\n\n\nas_fn_exit 0\n_ACEOF\nac_clean_files=$ac_clean_files_save\n\ntest $ac_write_fail = 0 ||\n  as_fn_error $? \"write failure creating $CONFIG_STATUS\" \"$LINENO\" 5\n\n\n# configure is writing to config.log, and then calls config.status.\n# config.status does its own redirection, appending to config.log.\n# Unfortunately, on DOS this fails, as config.log is still kept open\n# by configure, so config.status won't be able to write to it; its\n# output is simply discarded.  So we exec the FD to /dev/null,\n# effectively closing config.log, so it can be properly (re)opened and\n# appended to by config.status.  When coming back to configure, we\n# need to make the FD available again.\nif test \"$no_create\" != yes; then\n  ac_cs_success=:\n  ac_config_status_args=\n  test \"$silent\" = yes &&\n    ac_config_status_args=\"$ac_config_status_args --quiet\"\n  exec 5>/dev/null\n  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false\n  exec 5>>config.log\n  # Use ||, not &&, to avoid exiting from the if with $? = 1, which\n  # would make configure fail if this is the last instruction.\n  $ac_cs_success || as_fn_exit 1\nfi\nif test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\nfi\n\n\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 1.666015625,
          "content": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nm4_define(my_version, [m4_esyscmd([tr -d '\\n' < version])])\n\nAC_PREREQ([2.71])\nAC_INIT([smenu],[my_version],[p.gen.progs@gmail.com])\nAC_CONFIG_SRCDIR([smenu.c])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_AUX_DIR([build-aux])\nAM_INIT_AUTOMAKE([no-dist-gzip dist-bzip2 foreign -Wall])\nAM_SILENT_RULES([yes])\n\n# Checks for programs.\nAC_USE_SYSTEM_EXTENSIONS\nAC_PROG_AWK\nAC_PROG_CC\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAC_PROG_MAKE_SET\n\nAC_SEARCH_LIBS([tgetent], [tinfo curses ncursesw ncurses], [HAVE_CURSES=True])\n\n# clock_gettime is in librt on *-*-osf5.1 and on glibc < 2.17, so add -lrt\nAC_SEARCH_LIBS([clock_gettime], [rt], [\n  AC_DEFINE([HAVE_CLOCK_GETTIME],1,\n  [Define to 1 if you have the `clock_gettime' function])])\n\n# Checks for libraries.\n\n# Checks for header files.\nAC_CHECK_INCLUDES_DEFAULT\nAC_PROG_EGREP\n\nAC_CHECK_HEADERS([fcntl.h limits.h langinfo.h locale.h stdint.h stdlib.h \\\n                  string.h sys/ioctl.h sys/time.h termios.h unistd.h wchar.h])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_TYPE_SIZE_T\n\n# Checks for library functions.\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\nAC_CHECK_FUNCS([mblen memset nl_langinfo pathconf regcomp setlocale])\nAC_CHECK_FUNCS([strchr strrchr strspn strcasecmp])\n\nAC_CANONICAL_HOST\n# OS-specific tests\ncase \"${host_os}\" in\n*freebsd*|*dragonfly*)\n  CPPFLAGS=\"-D__BSD_VISIBLE $CPPFLAGS\"\n  ;;\n\n*darwin*)\n  CPPFLAGS=\"-D_DARWIN_C_SOURCE $CPPFLAGS\"\n  ;;\n\n*netbsd*)\n  CPPFLAGS=\"-D_NETBSD_SOURCE $CPPFLAGS\"\n  ;;\n\n*openbsd*|*bitrig*)\n  CPPFLAGS=\"-D_BSD_SOURCE $CPPFLAGS\"\n  ;;\nesac\n\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n"
        },
        {
          "name": "ctxopt.c",
          "type": "blob",
          "size": 151.0087890625,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#include <errno.h>\n#include <stddef.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <stdarg.h>\n#include <string.h>\n#include \"ctxopt.h\"\n\n/* ************************ */\n/* Static global variables. */\n/* ************************ */\n\nstatic void *contexts_bst;\nstatic void *options_bst;\n\nstate_t *cur_state;\n\n/* Prototypes */\n\n/* ************************** */\n/* Fatal messages prototypes. */\n/* ************************** */\n\nstatic void (**err_functions)(errors e, state_t *state);\n\nstatic void\nfatal_internal(const char *format, ...);\n\nstatic void\nfatal(errors e, char *errmsg);\n\nstatic int   user_rc;      /* Used by various callback functions. */\nstatic int   user_value;   /* Used by various callback functions. */\nstatic char *user_string;  /* Used by various callback functions. */\nstatic char *user_string2; /* Used by various callback functions. */\nstatic void *user_object;  /* Used by various callback functions. */\n\n/* ************************************ */\n/* Memory management static prototypes. */\n/* ************************************ */\n\nstatic void *\nxmalloc(size_t size);\n\nstatic void *\nxcalloc(size_t num, size_t size);\n\nstatic void *\nxrealloc(void *ptr, size_t size);\n\nstatic char *\nxstrdup(const char *p);\n\nstatic char *\nxstrndup(const char *str, size_t len);\n\n/* ********************** */\n/* BST static prototypes. */\n/* ********************** */\n\ntypedef struct bst_s bst_t;\n\ntypedef enum\n{\n  preorder,\n  postorder,\n  endorder,\n  leaf\n} walk_order_e;\n\n#if 0 /* Unused yet. */\nstatic void *\nbst_delete(const void * vkey, void ** vrootp,\n           int (*compar)(const void *, const void *));\n#endif\n\nstatic void\nbst_destroy(void *vrootp, void (*clean)(void *));\n\nstatic void *\nbst_find(const void   *vkey,\n         void * const *vrootp,\n         int (*compar)(const void *, const void *));\n\nstatic void *\nbst_search(void  *vkey,\n           void **vrootp,\n           int (*compar)(const void *, const void *));\n\nstatic void\nbst_walk_recurse(const bst_t *root,\n                 void (*action)(const void *, walk_order_e, int),\n                 int level);\n\nstatic void\nbst_walk(const void *vroot, void (*action)(const void *, walk_order_e, int));\n\n/* ****************************** */\n/* Linked list static prototypes. */\n/* ****************************** */\n\ntypedef struct ll_node_s ll_node_t;\ntypedef struct ll_s      ll_t;\n\nstatic void\nll_append(ll_t * const list, void * const data);\n\nstatic void\nll_prepend(ll_t * const list, void * const data);\n\nstatic void\nll_insert_after(ll_t * const list, ll_node_t *node, void * const data);\n\nstatic void\nll_insert_before(ll_t * const list, ll_node_t *node, void * const data);\n\nstatic int\nll_delete(ll_t * const list, ll_node_t *node);\n\nstatic void\nll_init(ll_t *list);\n\nstatic ll_node_t *\nll_new_node(void);\n\nstatic ll_t *\nll_new(void);\n\nstatic void\nll_free(ll_t * const list, void (*)(void *));\n\nstatic void\nll_destroy(ll_t * const list, void (*)(void *));\n\nstatic int\nll_strarray(ll_t *list, ll_node_t *start_node, int *count, char ***array);\n\n/* ************************** */\n/* Various static prototypes. */\n/* ************************** */\n\nstatic void\nltrim(char *str, const char *trim_str);\n\nstatic void\nrtrim(char *str, const char *trim_str, size_t min);\n\nstatic int\nstrchrcount(char *str, char c);\n\nstatic int\nstrpref(char *s1, char *s2);\n\nstatic int\nstricmp(const char *s1, const char *s2);\n\nstatic char *\nxstrtok_r(char *str, const char *delim, char **end);\n\nstatic int\neval_yes(char *value, int *invalid);\n\nstatic char *\nget_word(char *str, char *buf, size_t len);\n\n/* ************************* */\n/* ctxopt static prototypes. */\n/* ************************* */\n\ntypedef struct flags_s      flags_t;\ntypedef struct opt_s        opt_t;\ntypedef struct par_s        par_t;\ntypedef struct ctx_s        ctx_t;\ntypedef struct constraint_s constraint_t;\ntypedef struct ctx_inst_s   ctx_inst_t;\ntypedef struct opt_inst_s   opt_inst_t;\ntypedef struct seen_opt_s   seen_opt_t;\ntypedef struct req_s        req_t;\n\nstatic char *\nstrtoken(char *s, char *token, size_t tok_len, char *pattern, int *pos);\n\nstatic int\nctx_compare(const void *c1, const void *c2);\n\nstatic void\nctx_free(void *o);\n\nstatic void\nctx_inst_free(void *ci);\n\nstatic void\nopt_inst_free(void *oi);\n\nstatic int\nseen_opt_compare(const void *so1, const void *so2);\n\nstatic void\nincomp_bst_free(void *b);\n\nstatic void\nreq_free(void *r);\n\nstatic void\nseen_opt_free(void *seen_opt);\n\nstatic int\nopt_compare(const void *o1, const void *o2);\n\nstatic void\nopt_free(void *o);\n\nstatic int\npar_compare(const void *a1, const void *a2);\n\nstatic void\npar_free(void *p);\n\nstatic void\nconstraint_free(void *cstr);\n\nstatic ctx_t *\nlocate_ctx(char *name);\n\nstatic opt_t *\nlocate_opt(char *name);\n\nstatic par_t *\nlocate_par(char *name, ctx_t *ctx);\n\nstatic void\nprint_before_constraints(ll_t *list);\n\nstatic void\nprint_options(ll_t *list,\n              int  *has_optional,\n              int  *has_ellipsis,\n              int  *has_rule,\n              int  *has_generic_arg,\n              int  *has_ctx_change,\n              int  *has_early_eval);\nstatic void\nprint_explanations(int has_early_eval,\n                   int has_ctx_change,\n                   int has_generic_arg,\n                   int has_optional,\n                   int has_ellipsis,\n                   int has_rule);\nstatic void\nbst_seen_opt_cb(const void *node, walk_order_e kind, int level);\n\nstatic void\nbst_seen_opt_seen_cb(const void *node, walk_order_e kind, int level);\n\nstatic void\nbst_print_ctx_cb(const void *node, walk_order_e kind, int level);\n\nstatic void\nbst_check_opt_cb(const void *node, walk_order_e kind, int level);\n\nstatic void\nbst_match_par_cb(const void *node, walk_order_e kind, int level);\n\nstatic void\nmatch_prefix_cb(const void *node, walk_order_e kind, int level);\n\nstatic int\nhas_unseen_mandatory_opt(ctx_inst_t *ctx_inst, char **missing);\n\nstatic int\nopt_parse(char *s, opt_t **opt);\n\nstatic int\ninit_opts(char *spec, ctx_t *ctx);\n\nstatic int\nctxopt_build_cmdline_list(int nb_words, char **words);\n\nstatic int\nopt_set_parms(char *opt_name, char *par_str);\n\nstatic ctx_inst_t *\nnew_ctx_inst(ctx_t *ctx, ctx_inst_t *prev_ctx_inst);\n\nstatic void\nevaluate_ctx_inst(ctx_inst_t *ctx_inst);\n\n/* ****************************** */\n/* Fatal messages implementation. */\n/* ****************************** */\n\n/* =================================================================== */\n/* Fatal error function used when a fatal condition is encountered.    */\n/* This function is reserved for the ctxopt internal usage.            */\n/*                                                                     */\n/* format : printf like format.                                        */\n/* ...    : remaining arguments interpreted using the format argument. */\n/* =================================================================== */\nstatic void\nfatal_internal(const char *format, ...)\n{\n  va_list args;\n\n  fprintf(stderr, \"CTXOPT: \");\n\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  fprintf(stderr, \"\\n\");\n  va_end(args);\n\n  exit(EXIT_FAILURE);\n}\n\n/* ====================================================================== */\n/* Generic fatal error function. This one uses the global status ctxopt   */\n/* stored in the cur_state structure and can call custom error functions. */\n/* registered by the users for a given error identifier if any.           */\n/*                                                                        */\n/* e      : Error identifier responsible of the fatal error.              */\n/* errmsg : User's provided string specific to the error e.               */\n/*          Note that errmsg is not used in all cases.                    */\n/*                                                                        */\n/*          CTXOPTMISPAR Missing parameter.                               */\n/*          CTXOPTREQPAR Option: all parameters in a required group are   */\n/*                               missing.                                 */\n/*          CTXOPTMISARG Missing argument.                                */\n/*          CTXOPTUXPARG Unexpected argument.                             */\n/*          CTXOPTDUPOPT Duplicated option.                               */\n/*          CTXOPTUNKPAR Unknown parameter.                               */\n/*          CTXOPTINCOPT Incompatible option.                             */\n/*          CTXOPTCTEOPT Option: bad number of occurrences.               */\n/*          CTXOPTCTLOPT Option: not enough occurrences.                  */\n/*          CTXOPTCTGOPT Option: too many occurrence of.                  */\n/*          CTXOPTCTEARG Arguments: bad number of occurrences.            */\n/*          CTXOPTCTLARG Arguments: not enough occurrences.               */\n/*          CTXOPTCTGARG Arguments: too many occurrences.                 */\n/* ====================================================================== */\nstatic void\nfatal(errors e, char *errmsg)\n{\n  if (err_functions[e] != NULL)\n    err_functions[e](e, cur_state);\n  else\n  {\n    switch (e)\n    {\n      case CTXOPTNOERR:\n        break;\n\n      case CTXOPTMISPAR:\n        if (cur_state->ctx_par_name != NULL)\n          fprintf(stderr,\n                  \"the mandatory parameter(s) %s are missing in the context \"\n                  \"introduced by %s.\\n\",\n                  errmsg,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The mandatory parameter(s) %s are missing \"\n                  \"in the main context.\\n\",\n                  errmsg);\n\n        free(errmsg);\n        break;\n\n      case CTXOPTREQPAR:\n        fprintf(stderr,\n                errmsg,\n                cur_state->req_opt_par_needed,\n                cur_state->req_opt_par);\n        break;\n\n      case CTXOPTUNXARG:\n        if (cur_state->cur_opt_par_name != NULL)\n          fprintf(stderr,\n                  \"The parameter %s takes no arguments \"\n                  \"or has too many arguments.\\n\",\n                  cur_state->cur_opt_par_name);\n        break;\n\n      case CTXOPTMISARG:\n        if (cur_state->pre_opt_par_name != NULL)\n          fprintf(stderr,\n                  \"%s requires argument(s).\\n\",\n                  cur_state->pre_opt_par_name);\n        else\n          fprintf(stderr,\n                  \"%s requires argument(s).\\n\",\n                  cur_state->cur_opt_par_name);\n        break;\n\n      case CTXOPTDUPOPT:\n        if (cur_state->pre_opt_par_name != NULL)\n          fprintf(stderr,\n                  \"The parameter %s can only appear once in the context \"\n                  \"introduced by %s.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s can only appear once \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params);\n        break;\n\n      case CTXOPTUNKPAR:\n        fprintf(stderr,\n                \"Unknown parameter %s.\\n%s\",\n                cur_state->cur_opt_par_name,\n                errmsg);\n        break;\n\n      case CTXOPTINCOPT:\n        fprintf(stderr,\n                \"The parameter %s is incompatible with %s.\\n\",\n                cur_state->cur_opt_par_name,\n                errmsg);\n        break;\n\n      case CTXOPTCTEOPT:\n        if (cur_state->ctx_par_name)\n          fprintf(stderr,\n                  \"The parameter %s must appear exactly %d times \"\n                  \"in the context introduced by %s.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->opts_count,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s must appear exactly %d times \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->opts_count);\n        break;\n\n      case CTXOPTCTLOPT:\n        if (cur_state->ctx_par_name)\n          fprintf(stderr,\n                  \"The parameter %s must appear less than %d times \"\n                  \"in the context introduced by %s.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->opts_count,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s must appear less than %d times \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->opts_count);\n        break;\n\n      case CTXOPTCTGOPT:\n        if (cur_state->ctx_par_name)\n          fprintf(stderr,\n                  \"The parameter %s must appear more than %d times \"\n                  \"in the context introduced by %s.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->opts_count,\n                  cur_state->ctx_par_name);\n        else\n          fprintf(stderr,\n                  \"The parameter %s must appear more than %d times \"\n                  \"in the main context.\\n\",\n                  cur_state->cur_opt_params,\n                  cur_state->opts_count);\n        break;\n\n      case CTXOPTCTEARG:\n        fprintf(stderr,\n                \"The parameter %s must have exactly %d arguments.\\n\",\n                cur_state->cur_opt_par_name,\n                cur_state->opt_args_count);\n        break;\n\n      case CTXOPTCTLARG:\n        fprintf(stderr,\n                \"The parameter %s must have less than %d arguments.\\n\",\n                cur_state->cur_opt_par_name,\n                cur_state->opt_args_count);\n        break;\n\n      case CTXOPTCTGARG:\n        fprintf(stderr,\n                \"The parameter %s must have more than %d arguments.\\n\",\n                cur_state->cur_opt_par_name,\n                cur_state->opt_args_count);\n        break;\n\n      case CTXOPTERRSIZ:\n        break;\n    }\n  }\n\n  /* CTXOPTUNKPAR should display the full usage to help the user follow   */\n  /* the chaining of contexts when several possible contexts have been    */\n  /* identified. Otherwise, errmsg is the empty string and the display of */\n  /* the current usage is enough.                                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (e == CTXOPTUNKPAR && *errmsg != '\\0')\n    ctxopt_disp_usage(continue_after);\n  else\n    ctxopt_ctx_disp_usage(NULL, continue_after);\n\n  exit(e); /* Exit with the error id e as return code. */\n}\n\n/* ********************************* */\n/* Memory management implementation. */\n/* ********************************* */\n\n/* ================== */\n/* Customized malloc. */\n/* ================== */\nstatic void *\nxmalloc(size_t size)\n{\n  void  *allocated;\n  size_t real_size;\n\n  real_size = (size > 0) ? size : 1;\n  allocated = malloc(real_size);\n  if (allocated == NULL)\n    fatal_internal(\"Insufficient memory (attempt to malloc %lu bytes).\\n\",\n                   (unsigned long int)size);\n\n  return allocated;\n}\n\n/* ================== */\n/* Customized calloc. */\n/* ================== */\nstatic void *\nxcalloc(size_t n, size_t size)\n{\n  void *allocated;\n\n  n         = (n > 0) ? n : 1;\n  size      = (size > 0) ? size : 1;\n  allocated = calloc(n, size);\n  if (allocated == NULL)\n    fatal_internal(\"Insufficient memory (attempt to calloc %lu bytes).\\n\",\n                   (unsigned long int)size);\n\n  return allocated;\n}\n\n/* =================== */\n/* Customized realloc. */\n/* =================== */\nstatic void *\nxrealloc(void *p, size_t size)\n{\n  void *allocated;\n\n  allocated = realloc(p, size);\n  if (allocated == NULL && size > 0)\n    fatal_internal(\"Insufficient memory (attempt to xrealloc %lu bytes).\\n\",\n                   (unsigned long int)size);\n\n  return allocated;\n}\n\n/* ==================================== */\n/* strdup implementation using xmalloc. */\n/* ==================================== */\nstatic char *\nxstrdup(const char *p)\n{\n  char *allocated;\n\n  allocated = xmalloc(strlen(p) + 1);\n  strcpy(allocated, p);\n\n  return allocated;\n}\n\n/* =================================================== */\n/* strndup implementation using xmalloc.               */\n/* This version guarantees that there is a final '\\0'. */\n/* =================================================== */\nstatic char *\nxstrndup(const char *str, size_t len)\n{\n  char *p;\n\n  p = memchr(str, '\\0', len);\n\n  if (p)\n    len = p - str;\n\n  p = xmalloc(len + 1);\n  memcpy(p, str, len);\n  p[len] = '\\0';\n\n  return p;\n}\n\n/* *************************** */\n/* Linked list implementation. */\n/* *************************** */\n\n/* Linked list node structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ll_node_s\n{\n  void             *data;\n  struct ll_node_s *next;\n  struct ll_node_s *prev;\n};\n\n/* Linked List structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ll_s\n{\n  ll_node_t *head;\n  ll_node_t *tail;\n  long       len;\n};\n\n/* ========================= */\n/* Create a new linked list. */\n/* ========================= */\nstatic ll_t *\nll_new(void)\n{\n  ll_t *ret = xmalloc(sizeof(ll_t));\n  ll_init(ret);\n\n  return ret;\n}\n\n/* =============================================== */\n/* Free all the elements of a list (make it empty) */\n/* NULL or a custom function may be used to free   */\n/* the sub components of the elements.             */\n/* =============================================== */\nstatic void\nll_free(ll_t * const list, void (*clean)(void *))\n{\n  ll_node_t *node;\n\n  if (list)\n  {\n    node = list->head;\n\n    while (node)\n    {\n      /* Apply a custom cleaner if not NULL. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (clean)\n        clean(node->data);\n\n      ll_delete(list, node);\n\n      node = list->head;\n    }\n  }\n}\n\n/* ==================================== */\n/* Destroy a list and all its elements. */\n/* ==================================== */\nstatic void\nll_destroy(ll_t *list, void (*clean)(void *))\n{\n  if (list)\n  {\n    ll_free(list, clean);\n    free(list);\n  }\n}\n\n/* ========================= */\n/* Initialize a linked list. */\n/* ========================= */\nstatic void\nll_init(ll_t *list)\n{\n  list->head = NULL;\n  list->tail = NULL;\n  list->len  = 0;\n}\n\n/* ===================================================== */\n/* Allocate the space for a new node in the linked list. */\n/* ===================================================== */\nstatic ll_node_t *\nll_new_node(void)\n{\n  ll_node_t *ret = xmalloc(sizeof(ll_node_t));\n\n  return ret;\n}\n\n/* ==================================================================== */\n/* Append a new node filled with its data at the end of the linked list */\n/* The user is responsible for the memory management of the data.       */\n/* ==================================================================== */\nstatic void\nll_append(ll_t * const list, void * const data)\n{\n  ll_node_t *node;\n\n  node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                         | uses xmalloc which does not return if there *\n                         | is an allocation error.                     */\n\n  node->data = data;\n  node->next = NULL;       /* This node will be the last. */\n  node->prev = list->tail; /* NULL if it is a new list.   */\n\n  if (list->tail)\n    list->tail->next = node;\n  else\n    list->head = node;\n\n  list->tail = node;\n\n  ++list->len; /* One more node in the list. */\n}\n\n/* ================================================================== */\n/* Put a new node filled with its data at the beginning of the linked */\n/* list.                                                              */\n/* The user is responsible for the memory management of the data.     */\n/* ================================================================== */\nstatic void\nll_prepend(ll_t * const list, void * const data)\n{\n  ll_node_t *node;\n\n  node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                         | uses xmalloc which does not return if there *\n                         | is an allocation error.                     */\n\n  node->data = data;\n  node->prev = NULL;       /* This node will be the first. */\n  node->next = list->head; /* NULL if it is a new list.    */\n\n  if (list->head)\n    list->head->prev = node;\n  else\n    list->tail = node;\n\n  list->head = node;\n\n  ++list->len; /* One more node in the list. */\n}\n\n/* ======================================================== */\n/* Insert a new node before the specified node in the list. */\n/* ======================================================== */\nstatic void\nll_insert_before(ll_t * const list, ll_node_t *node, void * const data)\n{\n  ll_node_t *new_node;\n\n  if (node->prev == NULL)\n    ll_prepend(list, data);\n  else\n  {\n    new_node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                               | uses xmalloc which does not return if there *\n                               | is an allocation error.                     */\n\n    new_node->data = data;\n    new_node->next = node;\n    new_node->prev = node->prev;\n\n    node->prev->next = new_node;\n    node->prev       = new_node;\n\n    ++list->len; /* One more node in the list. */\n  }\n}\n\n/* ======================================================= */\n/* Insert a new node after the specified node in the list. */\n/* ======================================================= */\nstatic void\nll_insert_after(ll_t * const list, ll_node_t *node, void * const data)\n{\n  ll_node_t *new_node;\n\n  if (node->next == NULL)\n    ll_append(list, data);\n  else\n  {\n    new_node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                               | uses xmalloc which does not return if there *\n                               | is an allocation error.                     */\n\n    new_node->data = data;\n    new_node->prev = node;\n    new_node->next = node->next;\n\n    node->next->prev = new_node;\n    node->next       = new_node;\n\n    ++list->len; /* One more node in the list. */\n  }\n}\n\n/* ================================================================= */\n/* Remove a node from a linked list.                                 */\n/* The memory taken by the deleted node must be freed by the caller. */\n/* ================================================================= */\nstatic int\nll_delete(ll_t * const list, ll_node_t *node)\n{\n  if (list->head == list->tail)\n  {\n    /* We delete the last remaining element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (list->head == NULL)\n      return 0;\n\n    list->head = list->tail = NULL;\n  }\n  else if (node->prev == NULL)\n  {\n    /* We delete the first element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    list->head       = node->next;\n    list->head->prev = NULL;\n  }\n  else if (node->next == NULL)\n  {\n    /* We delete the last element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    list->tail       = node->prev;\n    list->tail->next = NULL;\n  }\n  else\n  {\n    /* We delete an element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    node->next->prev = node->prev;\n    node->prev->next = node->next;\n  }\n\n  free(node);\n\n  --list->len; /* One less node in the list. */\n\n  return 1;\n}\n\n/* ==================================================================== */\n/* Allocate and fill an array of strings from a list.                   */\n/* WARNINGS:                                                            */\n/*   1) The list node must contain strings (char *).                    */\n/*   2) The strings in the resulting array MUST NOT be freed as the are */\n/*      NOT copied from the strings of the list.                        */\n/*                                                                      */\n/* IN list       : The list from which the array is generated.          */\n/* IN start_node : The node of the list which will be the first node to */\n/*                 consider to create the array.                        */\n/* OUT: count    : The number of elements of the resulting array.       */\n/* OUT: array    : The resulting array or NULL if the list is empty.    */\n/* RC :          : The number of elements of the resulting array.       */\n/* ==================================================================== */\nstatic int\nll_strarray(ll_t *list, ll_node_t *start_node, int *count, char ***array)\n{\n  int        n = 0;\n  ll_node_t *node;\n\n  *count = 0;\n\n  node = start_node;\n\n  if (list == NULL || node == NULL)\n  {\n    *array = NULL;\n\n    return 0;\n  }\n\n  *array = xmalloc((list->len + 1) * sizeof(char *));\n  while (node != NULL)\n  {\n    (*array)[n++] = (char *)(node->data);\n    (*count)++;\n\n    node = node->next;\n  }\n\n  (*array)[*count] = NULL;\n\n  return *count;\n}\n\n/* ******************************************************************* */\n/* BST (search.h compatible) implementation.                           */\n/*                                                                     */\n/* Tree search generalized from Knuth (6.2.2) Algorithm T just like    */\n/* the AT&T man page says.                                             */\n/*                                                                     */\n/* Written by reading the System V Interface Definition, not the code. */\n/*                                                                     */\n/* Totally public domain.                                              */\n/* ******************************************************************* */\n\nstruct bst_s\n{\n  void         *key;\n  struct bst_s *llink;\n  struct bst_s *rlink;\n};\n\n#if 0 /* Unused yet. */\n/* =========================== */\n/* Delete node with given key. */\n/* =========================== */\nstatic void *\nbst_delete(const void * vkey, void ** vrootp,\n           int (*compar)(const void *, const void *))\n{\n  bst_t ** rootp = (bst_t **)vrootp;\n  bst_t *  p, *q, *r;\n  int      cmp;\n\n  if (rootp == NULL || (p = *rootp) == NULL)\n    return NULL;\n\n  while ((cmp = (*compar)(vkey, (*rootp)->key)) != 0)\n  {\n    p     = *rootp;\n    rootp = (cmp < 0) ? &(*rootp)->llink  /* follow llink branch */\n                      : &(*rootp)->rlink; /* follow rlink branch */\n    if (*rootp == NULL)\n      return NULL; /* key not found */\n  }\n  r = (*rootp)->rlink;               /* D1: */\n  if ((q = (*rootp)->llink) == NULL) /* Left NULL? */\n    q = r;\n  else if (r != NULL)\n  { /* Right link is NULL? */\n    if (r->llink == NULL)\n    { /* D2: Find successor */\n      r->llink = q;\n      q        = r;\n    }\n    else\n    { /* D3: Find NULL link */\n      for (q = r->llink; q->llink != NULL; q = r->llink)\n        r = q;\n      r->llink = q->rlink;\n      q->llink = (*rootp)->llink;\n      q->rlink = (*rootp)->rlink;\n    }\n  }\n  if (p != *rootp)\n    free(*rootp); /* D4: Free node */\n  *rootp = q;     /* link parent to new node */\n  return p;\n}\n#endif\n\n/* ===================================================================== */\n/* Destroy a tree.                                                       */\n/* The clean function pointer can be NULL, in this case the node content */\n/* is not freed.                                                         */\n/* ===================================================================== */\nstatic void\nbst_destroy(void *vrootp, void (*clean)(void *))\n{\n  bst_t *root = (bst_t *)vrootp;\n\n  if (root == NULL)\n    return;\n\n  bst_destroy(root->llink, clean);\n  bst_destroy(root->rlink, clean);\n\n  if (clean)\n    clean((void *)root->key);\n\n  free(root);\n}\n\n/* ========================= */\n/* Find a node, or return 0. */\n/* ========================= */\nstatic void *\nbst_find(const void   *vkey,\n         void * const *vrootp,\n         int (*compar)(const void *, const void *))\n{\n  bst_t * const *rootp = (bst_t * const *)vrootp;\n\n  if (rootp == NULL)\n    return NULL;\n\n  while (*rootp != NULL)\n  { /* T1: */\n    int r;\n\n    if ((r = (*compar)(vkey, (*rootp)->key)) == 0) /* T2: */\n      return *rootp;                               /* key found */\n    rootp = (r < 0) ? &(*rootp)->llink             /* T3: follow left branch */\n                    : &(*rootp)->rlink;            /* T4: follow right branch */\n  }\n  return NULL;\n}\n\n/* ======================================= */\n/* Find or inserts datum into search tree. */\n/* ======================================= */\nstatic void *\nbst_search(void *vkey, void **vrootp, int (*compar)(const void *, const void *))\n{\n  bst_t  *q;\n  bst_t **rootp = (bst_t **)vrootp;\n\n  if (rootp == NULL)\n    return NULL;\n\n  while (*rootp != NULL)\n  { /* Knuth's T1: */\n    int r;\n\n    if ((r = (*compar)(vkey, (*rootp)->key)) == 0) /* T2: */\n      return *rootp;                               /* we found it! */\n\n    rootp = (r < 0) ? &(*rootp)->llink  /* T3: follow left branch */\n                    : &(*rootp)->rlink; /* T4: follow right branch */\n  }\n\n  q = xmalloc(sizeof(bst_t)); /* T5: key not found */\n  if (q != 0)\n  {                  /* make new node */\n    *rootp   = q;    /* link new node to old */\n    q->key   = vkey; /* initialize new node */\n    q->llink = q->rlink = NULL;\n  }\n  return q;\n}\n\n/* ========================= */\n/* Walk the nodes of a tree. */\n/* ========================= */\nstatic void\nbst_walk_recurse(const bst_t *root,\n                 void (*action)(const void *, walk_order_e, int),\n                 int level)\n{\n  if (root->llink == NULL && root->rlink == NULL)\n    (*action)(root, leaf, level);\n  else\n  {\n    (*action)(root, preorder, level);\n    if (root->llink != NULL)\n      bst_walk_recurse(root->llink, action, level + 1);\n    (*action)(root, postorder, level);\n    if (root->rlink != NULL)\n      bst_walk_recurse(root->rlink, action, level + 1);\n    (*action)(root, endorder, level);\n  }\n}\n\nstatic void\nbst_walk(const void *vroot, void (*action)(const void *, walk_order_e, int))\n{\n  if (vroot != NULL && action != NULL)\n    bst_walk_recurse(vroot, action, 0);\n}\n\n/* ************************ */\n/* Various implementations. */\n/* ************************ */\n\n/* ======================== */\n/* Trim leading characters. */\n/* ======================== */\nstatic void\nltrim(char *str, const char *trim_str)\n{\n  size_t len   = strlen(str);\n  size_t begin = strspn(str, trim_str);\n  size_t i;\n\n  if (begin > 0)\n    for (i = begin; i <= len; ++i)\n      str[i - begin] = str[i];\n}\n\n/* ================================================= */\n/* Trim trailing characters.                         */\n/* The resulting string will have at least min bytes */\n/* even if trailing spaces remain.                   */\n/* ================================================= */\nstatic void\nrtrim(char *str, const char *trim_str, size_t min)\n{\n  size_t len = strlen(str);\n  while (len > min && strchr(trim_str, str[len - 1]))\n    str[--len] = '\\0';\n}\n\n/* ================================================== */\n/* Count the number of occurrences of the character c */\n/* in the string str.                                 */\n/* The str pointer is assumed to be not NULL.         */\n/* ================================================== */\nstatic int\nstrchrcount(char *str, char c)\n{\n  int count = 0;\n\n  while (*str)\n    if (*str++ == c)\n      count++;\n\n  return count;\n}\n\n/* =============================================== */\n/* Is the string str2 a prefix of the string str1? */\n/* =============================================== */\nstatic int\nstrpref(char *str1, char *str2)\n{\n  while (*str1 != '\\0' && *str1 == *str2)\n  {\n    str1++;\n    str2++;\n  }\n\n  return *str2 == '\\0';\n}\n\n/* ========================== */\n/* Like strcmp ignoring case. */\n/* ========================== */\nstatic int\nstricmp(const char *s1, const char *s2)\n{\n  while (tolower((unsigned char)*s1) == tolower((unsigned char)*s2))\n  {\n    if (*s1 == '\\0')\n      return 0;\n\n    s1++;\n    s2++;\n  }\n\n  return (int)tolower((unsigned char)*s1) - (int)tolower((unsigned char)*s2);\n}\n\n/* ====================================================================== */\n/* Strings concatenation with dynamic memory allocation.                  */\n/* IN : a variable number of char * arguments with NULL terminating       */\n/*      the sequence.                                                     */\n/*      The first one must have been dynamically allocated and is         */\n/*      mandatory.                                                        */\n/*                                                                        */\n/* Returns a new allocated string containing the concatenation of all     */\n/* the arguments. It is the caller's responsibility to free the resulting */\n/* string.                                                                */\n/* ====================================================================== */\nstatic char *\nstrappend(char *str, ...)\n{\n  size_t  l;\n  va_list args;\n  char   *s;\n\n  l = 1 + strlen(str);\n  va_start(args, str);\n\n  s = va_arg(args, char *);\n\n  while (s)\n  {\n    l += strlen(s);\n    s = va_arg(args, char *);\n  }\n\n  va_end(args);\n\n  if (l > 0)\n    str = xrealloc(str, l);\n\n  va_start(args, str);\n  s = va_arg(args, char *);\n\n  while (s)\n  {\n    strcat(str, s);\n    s = va_arg(args, char *);\n  }\n  va_end(args);\n\n  return str;\n}\n\n/* ====================================================================== */\n/*  Public domain strtok_r() by Charlie Gordon.                           */\n/*   from comp.lang.c  9/14/2007                                          */\n/*      http://groups.google.com/group/comp.lang.c/msg/2ab1ecbb86646684   */\n/*                                                                        */\n/*     (Declaration that it's public domain):                             */\n/*      http://groups.google.com/group/comp.lang.c/msg/7c7b39328fefab9c   */\n/*                                                                        */\n/* Also, fixed by Fletcher T. Penney --- added the \"return NULL\" when     */\n/* *end == NULL.                                                          */\n/* ====================================================================== */\nstatic char *\nxstrtok_r(char *str, const char *delim, char **end)\n{\n  char *ret;\n\n  if (str == NULL)\n    str = *end;\n\n  if (str == NULL)\n    return NULL;\n\n  str += strspn(str, delim);\n\n  if (*str == '\\0')\n    return NULL;\n\n  ret = str;\n\n  str += strcspn(str, delim);\n\n  if (*str)\n    *str++ = '\\0';\n\n  *end = str;\n\n  return ret;\n}\n\n/* ===================================================================== */\n/* Put the first word of str, truncated to len characters, in buf.       */\n/* Return a pointer in str pointing just after the word.                 */\n/* buf must have been pre-allocated to accept at least len+1 characters. */\n/* Note that buf can contains a sting full of spaces is str was not      */\n/* trimmed before the call.                                              */\n/* ===================================================================== */\nchar *\nget_word(char *str, char *buf, size_t len)\n{\n  char *s = str;\n\n  /* Skip spaces. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*s && isspace(*s))\n    s++;\n\n  /* Set the new string start. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  str = s;\n\n  /* Get the word. */\n  /*\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*s && !isspace(*s) && s - str < (ptrdiff_t)len)\n    s++;\n\n  strncpy(buf, str, s - str);\n  buf[s - str] = 0;\n\n  return s;\n}\n\n/* ==================================================================== */\n/* Return 1 is value is \"1\" or \"yes\" (ignoring case).                   */\n/* Return 0 is value is \"0\" or \"no\" (ignoring case).                    */\n/* If value has another value, then set invalid to 1 and also return 0  */\n/* invalid is set to 0 in all the other cases.                          */\n/* ==================================================================== */\nstatic int\neval_yes(char *value, int *invalid)\n{\n  *invalid = 0;\n\n  if (strcmp(value, \"1\") == 0 || stricmp(value, \"yes\") == 0)\n    return 1;\n  else if (strcmp(value, \"0\") != 0 && stricmp(value, \"no\") != 0)\n    *invalid = 1;\n\n  return 0;\n}\n\n/* =========================================================== */\n/* Fill an array of strings from the words composing a string. */\n/*                                                             */\n/* str:    initial string which will be altered.               */\n/* args:   array of pointers to the start of the words in str. */\n/* max:    maximum number of words used before giving up.      */\n/* return: the number of words (<=max).                        */\n/* =========================================================== */\nstatic int\nstr2argv(char *str, char **args, int max)\n{\n  int nb_args = 0;\n\n  while (*str)\n  {\n    if (nb_args >= max)\n      return nb_args;\n\n    while (*str == ' ' || *str == '\\t')\n      *(str++) = '\\0';\n\n    if (!*str)\n      return nb_args;\n\n    args[nb_args] = str;\n    nb_args++;\n\n    while (*str && (*str != ' ') && (*str != '\\t'))\n      str++;\n  }\n\n  return nb_args;\n}\n\n/* ********************** */\n/* ctxopt implementation. */\n/* ********************** */\n\nstatic int ctxopt_initialized = 0; /* cap_init has not yet been called. */\n\n/* Flags structure initialized by ctxopt_init. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct flags_s\n{\n  int stop_if_non_option;\n  int allow_abbreviations;\n  int display_usage_on_error;\n};\n\nstatic flags_t flags = { 0, 1, 1 };\n\n/* Context structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ctx_s\n{\n  char *name;\n  ll_t *opt_list;    /* list of options allowed in this context.      */\n  ll_t *incomp_list; /* list of strings containing incompatible names *\n                      | of options separated by spaces or tabs.       */\n  ll_t *req_list;    /* list of strings containing an option name and *\n                      | all the option names where at least one of    *\n                      | them is required to be also present.          */\n\n  int (*action)(char  *name,\n                int    type,\n                char  *new_ctx,\n                int    ctx_nb_data,\n                void **ctx_data);\n  void  *par_bst;\n  int    nb_data;\n  void **data;\n};\n\n/* https://textik.com/#488ce3649b6c60f5                          */\n/*                                                               */\n/*       +--------------+                                        */\n/*       |first_ctx_inst|                                        */\n/*       +---+----------+                                        */\n/*           |                                                   */\n/*        +--v-----+      +--------+     +--------+      +-----+ */\n/* +---+-->ctx_inst+------>opt_inst+----->opt_inst+------> ... | */\n/* |   |  +-+------+      +----+---+     +----+---+      +-----+ */\n/* |   |    |                  |              |                  */\n/* |   |  +-v------+           |              |                  */\n/* |   +--+ctx_inst<-----------+              |                  */\n/* |      +-+------+                          |                  */\n/* |        |                                 |                  */\n/* |      +-v------+                          |                  */\n/* +------+ctx_inst<--------------------------+                  */\n/*        +-+------+                                             */\n/*          |                                                    */\n/*        +-v---+                                                */\n/*        | ... |                                                */\n/*        +-----+                                                */\n\n/* Option structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct opt_s\n{\n  char *name;     /* option name.                            */\n  char *next_ctx; /* new context this option may lead to     */\n  ll_t *ctx_list; /* list of contexts allowing this option.  */\n  char *params;   /* string containing all the parameters of *\n                   | the option.                             */\n\n  void (*action)(                    /* The option associated action.     */\n                 char  *ctx_name,    /* context name.                     */\n                 char  *opt_name,    /* option name.                      */\n                 char  *par,         /* option parameter.                 */\n                 int    nb_args,     /* number of arguments.              */\n                 char **args,        /* option arguments.                 */\n                 int    nb_opt_data, /* number of option data pointers.   */\n                 void **opt_data,    /* option data pointers.             */\n                 int    nb_ctx_data, /* nb of current  context data ptrs. */\n                 void **ctx_data     /* current context data pointers.    */\n  );\n\n  int visible_in_help; /* visibility in help.                                */\n  int nb_data; /* number of the data pointers passed as argument to action.  */\n  void **data; /* array of data pointers passed as argument to action.       */\n\n  int args;     /* 1 if this option takes arguments else 0.                  */\n  int optional; /* 1 if the option is optional, else 0.                      */\n  int multiple; /* 1 if the option can appear more than one time in a        *\n                 | context, else 0.                                          */\n\n  int  opt_count_matter; /* 1 if we must restrict the count, else 0.         */\n  int  occurrences;      /* Number of option occurrences in a context.       */\n  char opt_count_oper;   /* <, = or >                                        */\n  int  opt_count_mark;   /* Value to be compared to with opt_count_oper.     */\n\n  char *arg; /* symbolic text after # describing the option argument.        */\n\n  int optional_args; /* 1 of option is optional else 0.                      */\n  int multiple_args; /* 1 is option can appear more than once in a context   *\n                      | instance.                                            */\n\n  int  opt_args_count_matter; /* 1 if count is restricted, else 0.           */\n  char opt_args_count_oper;   /* <, = or >                                   */\n  int  opt_args_count_mark;   /* Value to be compared to with                *\n                               | opt_count_oper.                             */\n\n  int eval_first; /* 1 if this option must be evaluated before the options   *\n                   | without this mark.                                      */\n\n  ll_t *eval_before_list; /* List of pointers on options which must be       *\n                           | evaluated before this option.                   */\n\n  ll_t *constraints_list; /* List of constraint check functions pointers.    */\n};\n\n/* Context instance structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ctx_inst_s\n{\n  ctx_t      *ctx;             /* the context whose this is an instance of  */\n  ctx_inst_t *prev_ctx_inst;   /* ctx_inst of the opt_inst which led to the *\n                                | creation of this ctx_inst structure.      */\n  opt_inst_t *gen_opt_inst;    /* opt_inst which led to the creation of a   *\n                                | instance of this structure.               */\n  ll_t       *incomp_bst_list; /* list of seen_opt_t BST.                   */\n  void       *seen_opt_bst;    /* tree of seen_opt_t.                       */\n  ll_t       *opt_req_list;    /* list of req_t.                            */\n  ll_t       *opt_inst_list;   /* The list of option instances in this      *\n                                | context instance.                         */\n  char       *par_name;        /* parameter which created this instance.    */\n};\n\n/* Option instance structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct opt_inst_s\n{\n  opt_t      *opt;           /* The option this is an instance of.        */\n  char       *opt_name;      /* The option which led to this creation.    */\n  char       *par;           /* The parameter which led to this creation. */\n  ll_t       *values_list;   /* The list of arguments of this option.     */\n  ctx_inst_t *next_ctx_inst; /* The new context instance this option.     *\n                              | instance may create.                      */\n};\n\n/* Structure used to check if an option has bee seen or not */\n/* in a context instance.                                   */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct seen_opt_s\n{\n  opt_t *opt;  /* The concerned option.                                */\n  char  *par;  /* Parameter which led to the making of this structure. */\n  int    seen; /* 1 if seen in the context instances, else 0.          */\n};\n\n/* Structure used to check if at least one instance of the options whose */\n/* pointers are in or_opt_list has been seen in the ctx_inst where an    */\n/* instance or opt is also present.                                      */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct req_s\n{\n  opt_t *opt;         /* Option that asks for other options.    */\n  ll_t  *or_opt_list; /* Required options, at least one of them *\n                       |  must be present.                      */\n};\n\n/* Parameter structure which links a parameter to the option it belongs to. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct par_s\n{\n  char  *name; /* Parameter name (with the leading -). */\n  opt_t *opt;  /* Attached option.                     */\n};\n\n/* Constraint structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct constraint_s\n{\n  int (*constraint)(int nb_args, char **args, char *value, char *parameter);\n  int    nb_args;\n  char **args;\n  char  *to_free; /* pointer to the original string in which the array in *\n                   | args points to. This pointer is kept there to allow  *\n                   | it to be freed.                                      */\n};\n\nstate_t           *cur_state      = NULL; /* Current analysis state.        */\nstatic ll_t       *cmdline_list   = NULL; /* List of interpreted CLI words  *\n                                           | serves as the basis for the    *\n                                           | analysis of the parameters.    */\nstatic ctx_t      *main_ctx       = NULL; /* initial context.               */\nstatic ctx_inst_t *first_ctx_inst = NULL; /* Pointer to the fist context    *\n                                           | instance which holds the       *\n                                           | options instances.             */\nstatic ll_t       *ctx_inst_list  = NULL; /* List of the context instances. */\n\n/* ======================================================= */\n/* Parse a string for the next matching token.             */\n/*                                                         */\n/* s:       string to parse.                               */\n/* token:   pre_allocated array of max tok_len characters. */\n/* pattern: scanf type pattern token must match.           */\n/* pos:     number of characters successfully parsed in s. */\n/*                                                         */\n/* Returns: a pointer to the first unread character or     */\n/*          to he terminating \\0.                          */\n/* ======================================================= */\nstatic char *\nstrtoken(char *s, char *token, size_t tok_len, char *pattern, int *pos)\n{\n  char *full_pattern;\n  char  len[3];\n  int   n;\n\n  *pos = 0;\n\n  n = snprintf(len, 3, \"%zu\", tok_len);\n  if (n < 0)\n    return NULL;\n\n  full_pattern = xmalloc(strlen(pattern) + n + 4);\n\n  strcpy(full_pattern, \"%\");\n  strcat(full_pattern, len);\n  strcat(full_pattern, pattern);\n  strcat(full_pattern, \"%n\");\n\n  n = sscanf(s, full_pattern, token, pos);\n\n  free(full_pattern);\n\n  if (n != 1)\n    return NULL;\n\n  return s + *pos;\n}\n\n/* ****************************************** */\n/* Various comparison and deletion functions. */\n/* ****************************************** */\n\nstatic int\nctx_compare(const void *c1, const void *c2)\n{\n  return strcmp(((ctx_t *)c1)->name, ((ctx_t *)c2)->name);\n}\n\n/* =========================== */\n/* Free a context_bst element. */\n/* =========================== */\nstatic void\nctx_free(void *c)\n{\n  ctx_t *ctx = c;\n\n  free(ctx->name);\n  free(ctx->data);\n\n  ll_destroy(ctx->opt_list, NULL);\n  ll_destroy(ctx->incomp_list, free);\n  ll_destroy(ctx->req_list, free);\n  bst_destroy(ctx->par_bst, par_free);\n\n  free(c);\n}\n\n/* ============================= */\n/* Free a ctx_inst_list element. */\n/* ============================= */\nstatic void\nctx_inst_free(void *ci)\n{\n  ctx_inst_t *ctx_inst = ci;\n\n  free(ctx_inst->par_name);\n  ll_destroy(ctx_inst->incomp_bst_list, incomp_bst_free);\n  bst_destroy(ctx_inst->seen_opt_bst, seen_opt_free);\n  ll_destroy(ctx_inst->opt_inst_list, opt_inst_free);\n  ll_destroy(ctx_inst->opt_req_list, req_free);\n\n  free(ci);\n}\n\n/* ============================== */\n/* Free an opt_inst_list element. */\n/* ============================== */\nstatic void\nopt_inst_free(void *oi)\n{\n  opt_inst_t *opt_inst = oi;\n\n  ll_destroy(opt_inst->values_list, NULL);\n\n  free(oi);\n}\n\n/* ================================== */\n/* Compare two seen_opt_bst elements. */\n/* ================================== */\nstatic int\nseen_opt_compare(const void *so1, const void *so2)\n{\n  opt_t *o1, *o2;\n\n  o1 = ((seen_opt_t *)so1)->opt;\n  o2 = ((seen_opt_t *)so2)->opt;\n\n  return strcmp(o1->name, o2->name);\n}\n\n/* ============================ */\n/* Free a seen_opt_bst element. */\n/* ============================ */\nvoid\nseen_opt_free(void *so)\n{\n  seen_opt_t *seen_opt = so;\n\n  free(seen_opt->par);\n\n  free(so);\n}\n\n/* =========================== */\n/* Free an incomp_bst element. */\n/* =========================== */\nstatic void\nincomp_bst_free(void *b)\n{\n  bst_t *bst = b;\n\n  bst_destroy(bst, NULL);\n}\n\n/* ============================= */\n/* Free an opt_req_list element. */\n/* ============================= */\nstatic void\nreq_free(void *r)\n{\n  req_t *req = r;\n\n  ll_destroy(req->or_opt_list, NULL);\n  free(req);\n}\n\n/* ================================= */\n/* Compare two options_bst elements. */\n/* ================================= */\nstatic int\nopt_compare(const void *o1, const void *o2)\n{\n  return strcmp(((opt_t *)o1)->name, ((opt_t *)o2)->name);\n}\n\n/* ============================= */\n/* Free an options_bst elements. */\n/* ============================= */\nvoid\nopt_free(void *o)\n{\n  opt_t *opt = o;\n\n  free(opt->name);\n  free(opt->next_ctx);\n  free(opt->params);\n  free(opt->arg);\n  free(opt->data);\n\n  ll_destroy(opt->ctx_list, NULL);\n  ll_destroy(opt->constraints_list, constraint_free);\n  ll_destroy(opt->eval_before_list, NULL);\n\n  free(o);\n}\n\n/* ============================= */\n/* Compare two par_bst elements. */\n/* ============================= */\nstatic int\npar_compare(const void *a1, const void *a2)\n{\n  return strcmp(((par_t *)a1)->name, ((par_t *)a2)->name);\n}\n\n/* ======================= */\n/* Free a par_bst element. */\n/* ======================= */\nstatic void\npar_free(void *p)\n{\n  par_t *par = p;\n\n  free(par->name);\n\n  free(p);\n}\n\n/* ================================ */\n/* Free a constraints_list element. */\n/* ================================ */\nstatic void\nconstraint_free(void *c)\n{\n  constraint_t *cstr = c;\n\n  free(cstr->args);\n  free(cstr->to_free);\n\n  free(c);\n}\n\n/* ******************************************************************** */\n/* Helper functions to locate contexts, options and parameters in a BST */\n/* by their names.                                                      */\n/* ******************************************************************** */\n\nstatic ctx_t *\nlocate_ctx(char *name)\n{\n  bst_t *node;\n  ctx_t  ctx = { 0 };\n\n  ctx.name = name;\n\n  if ((node = bst_find(&ctx, &contexts_bst, ctx_compare)) == NULL)\n    return NULL;\n  else\n    return node->key;\n}\n\nstatic opt_t *\nlocate_opt(char *name)\n{\n  bst_t *node;\n  opt_t  opt = { 0 };\n\n  opt.name = name;\n\n  if ((node = bst_find(&opt, &options_bst, opt_compare)) == NULL)\n    return NULL;\n  else\n    return node->key;\n}\n\nstatic par_t *\nlocate_par(char *name, ctx_t *ctx)\n{\n  bst_t *node;\n  par_t  par = { 0 };\n  void  *bst = ctx->par_bst;\n\n  par.name = name;\n\n  if ((node = bst_find(&par, &bst, par_compare)) == NULL)\n    return NULL;\n  else\n    return node->key;\n}\n\n/* ====================================================================== */\n/* Helper function to display the dependency constraints between options. */\n/* These constraints are set with the ctxopt_add_opt_settings function    */\n/* using the 'before' and 'after' arguments.                              */\n/* IN  list  : a list of options.                                         */\n/* ====================================================================== */\nstatic void\nprint_before_constraints(ll_t *list)\n{\n  ll_node_t *node = list->head;\n  ll_node_t *before_node;\n  opt_t     *opt, *before_opt;\n  int        msg = 0;\n\n  while (node != NULL)\n  {\n    opt = node->data;\n\n    if (opt->eval_before_list->len > 0)\n    {\n      if (!msg)\n      {\n        printf(\"\\n  If present in the command line,\");\n        msg = 1; /* Display this message only once. */\n      }\n\n      before_node = opt->eval_before_list->head;\n\n      printf(\"\\n  \");\n      while (before_node != NULL)\n      {\n        before_opt = before_node->data;\n        printf(\"%s\", before_opt->params);\n\n        before_node = before_node->next;\n\n        if (before_node != NULL)\n          printf(\" and\\n  \");\n      }\n      printf(\" will be evaluated after %s\\n\", opt->params);\n    }\n    node = node->next;\n  }\n}\n\n/* =================================================================== */\n/* Utility function to format and print the options present in a list. */\n/*                                                                     */\n/* IN  list  : a list of options.                                      */\n/* OUT has_* : a set of flags which will determine the content of the  */\n/*             explanation given after the formatted printing of the   */\n/*             options.                                                */\n/* =================================================================== */\nstatic void\nprint_options(ll_t *list,\n              int  *has_optional,\n              int  *has_ellipsis,\n              int  *has_rule,\n              int  *has_generic_arg,\n              int  *has_ctx_change,\n              int  *has_early_eval)\n{\n  ll_node_t *node = list->head;\n  opt_t     *opt;\n  char      *line;\n  char      *option;\n\n  line = xstrdup(\"  \");\n\n  while (node != NULL)\n  {\n    option = xstrdup(\"\");\n    opt    = node->data;\n\n    /* Skip option set as not visible in help. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!opt->visible_in_help)\n    {\n      node = node->next;\n      continue;\n    }\n\n    if (opt->optional)\n    {\n      option        = strappend(option, \"[\", (char *)0);\n      *has_optional = 1;\n    }\n\n    if (opt->eval_first)\n    {\n      option          = strappend(option, \"*\", (char *)0);\n      *has_early_eval = 1;\n    }\n\n    option = strappend(option, opt->params, (char *)0);\n\n    if (opt->next_ctx != NULL)\n    {\n      option          = strappend(option, \">\", opt->next_ctx, (char *)0);\n      *has_ctx_change = 1;\n    }\n\n    if (opt->multiple)\n    {\n      if (opt->opt_count_oper != '\\0')\n      {\n        char m[4];\n        char o[2];\n        o[0] = opt->opt_count_oper;\n        o[1] = '\\0';\n        snprintf(m, 3, \"%u\", opt->opt_count_mark);\n        option    = strappend(option, \"...\", o, m, (char *)0);\n        *has_rule = 1;\n      }\n      else\n        option = strappend(option, \"...\", (char *)0);\n\n      *has_ellipsis = 1;\n    }\n\n    if (opt->args)\n    {\n      if (*(opt->arg) == '#')\n        *has_generic_arg = 1;\n\n      option = strappend(option, \" \", (char *)0);\n\n      if (opt->optional_args)\n      {\n        option        = strappend(option, \"[\", opt->arg, (char *)0);\n        *has_optional = 1;\n      }\n      else\n        option = strappend(option, opt->arg, (char *)0);\n\n      if (opt->multiple_args)\n      {\n        if (opt->opt_args_count_oper != '\\0')\n        {\n          char m[4];\n          char o[2];\n          o[0] = opt->opt_args_count_oper;\n          o[1] = '\\0';\n          snprintf(m, 3, \"%u\", opt->opt_args_count_mark);\n          option    = strappend(option, \"...\", o, m, (char *)0);\n          *has_rule = 1;\n        }\n        else\n          option = strappend(option, \"...\", (char *)0);\n\n        *has_ellipsis = 1;\n      }\n      if (opt->optional_args)\n        option = strappend(option, \"]\", (char *)0);\n    }\n    if (opt->optional)\n      option = strappend(option, \"]\", (char *)0);\n\n    if (strlen(line) + 1 + strlen(option) < 80)\n      line = strappend(line, option, \" \", (char *)0);\n    else\n    {\n      printf(\"%s\\n\", line);\n      line[2] = '\\0';\n      line    = strappend(line, option, \" \", (char *)0);\n    }\n\n    free(option);\n\n    node = node->next;\n  }\n\n  printf(\"%s\\n\", line);\n\n  free(line);\n}\n\n/* ==================================================== */\n/* Explain the special syntactic symbols present in the */\n/* generated usage messages.                            */\n/* ==================================================== */\nstatic void\nprint_explanations(int has_early_eval,\n                   int has_ctx_change,\n                   int has_generic_arg,\n                   int has_optional,\n                   int has_ellipsis,\n                   int has_rule)\n{\n  if (has_early_eval || has_ctx_change || has_generic_arg || has_optional\n      || has_ellipsis || has_rule)\n  {\n    printf(\"\\nExplanation of the syntax used above:\\n\");\n    printf(\"Only the parameters (prefixed by -) and the arguments, if any, \"\n           \"must be entered.\\n\");\n    printf(\"The following is just there to explain the other symbols \"\n           \"displayed.\\n\\n\");\n\n    if (has_early_eval)\n      printf(\"*            : the parameters defined for this option will \"\n             \"be evaluated first.\\n\");\n    if (has_ctx_change)\n      printf(\">            : the context after this symbol will be the new \"\n             \"default context.\\n\");\n    if (has_generic_arg)\n      printf(\"#tag         : argument with a hint about its meaning.\\n\");\n    if (has_optional)\n      printf(\"[...]        : the object between square brackets is \"\n             \"optional.\\n\");\n    if (has_ellipsis)\n      printf(\"...          : several occurrences of the previous object \"\n             \"are possible.\\n\");\n    if (has_rule)\n      printf(\"[<|=|>]number: rules constraining the number of \"\n             \"parameters/arguments.\\n\");\n  }\n}\n\n/* ************************************************************ */\n/* Various utilities and callback functions called when walking */\n/* through a BST.                                               */\n/* ************************************************************ */\n\nstatic void\nbst_seen_opt_cb(const void *node, walk_order_e kind, int level)\n{\n  seen_opt_t *seen_opt = ((bst_t *)node)->key;\n\n  if (kind == postorder || kind == leaf)\n  {\n    if ((!seen_opt->opt->optional) && seen_opt->seen == 0)\n    {\n      user_rc     = 1;\n      user_string = strappend(user_string,\n                              seen_opt->opt->params,\n                              \" \",\n                              (char *)0);\n    }\n  }\n}\n\nstatic void\nbst_seen_opt_seen_cb(const void *node, walk_order_e kind, int level)\n{\n  seen_opt_t *seen_opt = ((bst_t *)node)->key;\n\n  if (kind == postorder || kind == leaf)\n    if (seen_opt->seen == 1)\n    {\n      user_rc     = 1;\n      user_object = seen_opt->par;\n    }\n}\n\nstatic void\nbst_print_ctx_cb(const void *node, walk_order_e kind, int level)\n{\n  ctx_t *ctx     = main_ctx;\n  ctx_t *cur_ctx = ((bst_t *)node)->key;\n\n  ll_t *list;\n\n  int has_optional    = 0;\n  int has_ellipsis    = 0;\n  int has_rule        = 0;\n  int has_generic_arg = 0;\n  int has_ctx_change  = 0;\n  int has_early_eval  = 0;\n\n  if (kind == postorder || kind == leaf)\n    if (strcmp(ctx->name, cur_ctx->name) != 0)\n    {\n      list = cur_ctx->opt_list;\n\n      printf(\"\\nAllowed options in the context %s:\\n\", cur_ctx->name);\n      print_options(list,\n                    &has_optional,\n                    &has_ellipsis,\n                    &has_rule,\n                    &has_generic_arg,\n                    &has_ctx_change,\n                    &has_early_eval);\n      print_before_constraints(list);\n    }\n}\n\nstatic void\nbst_check_opt_cb(const void *node, walk_order_e kind, int level)\n{\n  opt_t *opt = ((bst_t *)node)->key;\n\n  if (kind == postorder || kind == leaf)\n  {\n    if (opt->params == NULL) /* opt must have associated parameters. */\n      fatal_internal(\"Option %s has no registered parameter.\\n\", opt->name);\n\n    if (opt->action == NULL) /* opt must have an action. */\n      fatal_internal(\"Option %s has no registered action.\\n\", opt->name);\n  }\n}\n\nstatic void\nbst_match_par_cb(const void *node, walk_order_e kind, int level)\n{\n  ctx_t *ctx = ((bst_t *)node)->key;\n\n  if (kind == postorder || kind == leaf)\n  {\n    char *str = xstrdup(user_string);\n\n    while (*str != '\\0')\n    {\n      if (locate_par(str, ctx) != NULL)\n      {\n        if (*user_string2 == '\\0')\n          user_string2 = strappend(user_string2, \"- \", ctx->name, (char *)0);\n        else\n          user_string2 = strappend(user_string2, \"\\n- \", ctx->name, (char *)0);\n        break;\n      }\n      str[strlen(str) - 1] = '\\0';\n    }\n    free(str);\n  }\n}\n\nstatic void\nmatch_prefix_cb(const void *node, walk_order_e kind, int level)\n{\n  par_t *par = ((bst_t *)node)->key;\n\n  if (kind == postorder || kind == leaf)\n    if (strpref(par->name, (char *)user_object))\n    {\n      user_rc++;\n      user_string = strappend(user_string, par->name, \" \", (char *)0);\n    }\n}\n\n/* ====================================================================== */\n/* A parameter may not be separated from its first option by spaces, in   */\n/* this case this function looks for a valid flag as a prefix and splits  */\n/* the command line queue (eg: \"-pa1\" -> \"-pa\" \"1\" if \"-pa\" is a valid    */\n/* option).                                                               */\n/*                                                                        */\n/* IN  word : the word to be checked.                                     */\n/* IN  ctx  : the context in which the flag indexed by the word is to be  */\n/*            checked.                                                    */\n/* OUT pos  : the offset in word pointing just after the matching prefix. */\n/* OUT opt  : a pointer to the option associated with the new parameter   */\n/*            or NULL if none is found.                                   */\n/*                                                                        */\n/* The returned pointer must be freed by the caller.                      */\n/* ====================================================================== */\nstatic char *\nlook_for_valid_prefix_in_word(char *word, ctx_t *ctx, int *pos, opt_t **opt)\n{\n  char *new = NULL;\n  int    len;\n  par_t *par;\n  par_t  tmp_par = { 0 };\n\n  len = strlen(word);\n\n  if (len > 2)\n  {\n    new = xstrdup(word);\n\n    do\n    {\n      new[--len]   = '\\0';\n      tmp_par.name = new;\n    } while ((par = locate_par(tmp_par.name, ctx)) == NULL && len > 2);\n\n    if (par != NULL)\n    {\n      *pos = len;\n      *opt = par->opt;\n    }\n    else\n    {\n      free(new);\n      new = NULL;\n    }\n  }\n  else\n    *pos = 0;\n\n  return new;\n}\n\n/* ============================================================= */\n/* If par_name is an unique abbreviation of an exiting parameter */\n/* in the context ctx, then return this parameter.               */\n/* ============================================================= */\nstatic char *\nabbrev_expand(char *par_name, ctx_t *ctx)\n{\n  user_object = par_name;\n  user_rc     = 0;\n\n  *user_string = '\\0';\n  bst_walk(ctx->par_bst, match_prefix_cb);\n  rtrim(user_string, \" \", 0);\n\n  /* The previous bst_walk has built a string of blank separated parameters */\n  /* all having par_name as prefix. This string is put in the user_string   */\n  /* exchange zone. The number of these words in put in user_rc.            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (user_rc == 1) /* The number of matching abbreviations. */\n    return xstrdup(user_string);\n  else /* There is at least two defined parameters starting with par_name. */\n  {\n    char  *s, *first_s;\n    par_t *par;\n    opt_t *opt;\n    int    opt_count   = 0;\n    void  *tmp_opt_bst = NULL;\n\n    /* Find all the options corresponding to these words and store them   */\n    /* without duplication in a temporary BST. Only their resulting count */\n    /* matters.                                                           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    s = first_s = strtok(user_string, \" \"); /* first_s holds a copy of *\n                                             | the first word.         */\n    while (s != NULL)\n    {\n      par = locate_par(s, ctx); /* par cannot be NULL here. */\n      opt = par->opt;\n\n      if (bst_find(opt, &tmp_opt_bst, opt_compare) == NULL)\n      {\n        /* This option as not already been seen    */\n        /* store it and increase the seen counter. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        bst_search(opt, &tmp_opt_bst, opt_compare);\n        opt_count++;\n      }\n      s = strtok(NULL, \" \");\n    }\n\n    /* Clean the temporary BST without removing the pointer */\n    /* to the real options.                                 */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (tmp_opt_bst != NULL)\n      bst_destroy(tmp_opt_bst, NULL);\n\n    if (opt_count == 1)\n      /* All the abbreviation are leading to only one option */\n      /* We can just continue as in the previous case.       */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      return xstrdup(first_s);\n    else\n      return NULL;\n  }\n}\n\n/* ================================================================ */\n/* Terminate the program if mandatory options required by a context */\n/* are not present.                                                 */\n/* ================================================================ */\nstatic void\ncheck_for_missing_mandatory_opt(ctx_inst_t *ctx_inst, char *opt_par)\n{\n  char *missing;\n\n  if (has_unseen_mandatory_opt(ctx_inst, &missing))\n    fatal(CTXOPTMISPAR, missing);\n}\n\n/* ====================================================== */\n/* Return 1 if at least one mandatory option was not seen */\n/* when quitting a context, else 0.                       */\n/* ====================================================== */\nstatic int\nhas_unseen_mandatory_opt(ctx_inst_t *ctx_inst, char **missing)\n{\n  user_rc      = 0;\n  *user_string = '\\0';\n\n  bst_walk(ctx_inst->seen_opt_bst, bst_seen_opt_cb);\n  rtrim(user_string, \" \", 0);\n\n  *missing = user_string;\n\n  return user_rc ? 1 : 0;\n}\n\n/* ========================================================================= */\n/* This function terminates the program if an option or its arguments do not */\n/* conform to its occurrences constraint.                                    */\n/* There constraints can appear by trailing >, < or = in their definition    */\n/* given in ctxopt_new_ctx.                                                  */\n/* ========================================================================= */\nstatic void\ncheck_for_occurrence_issues(ctx_inst_t *ctx_inst)\n{\n  ctx_t      *ctx = ctx_inst->ctx;\n  opt_t      *opt;\n  ll_node_t  *node;\n  opt_inst_t *opt_inst;\n  char       *cur_opt_params   = cur_state->cur_opt_params;\n  char       *cur_opt_par_name = cur_state->cur_opt_par_name;\n\n  /* Checks options. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->opt_list->head;\n\n  while (node != NULL)\n  {\n    opt = node->data;\n\n    /* Update current_state. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    cur_state->cur_opt_params = opt->params;\n    cur_state->opts_count     = opt->opt_count_mark;\n    cur_state->opt_args_count = opt->opt_args_count_mark;\n\n    if (opt->opt_count_matter)\n      switch (opt->opt_count_oper)\n      {\n        case '=':\n          if (opt->occurrences > 0 && opt->opt_count_mark != opt->occurrences)\n            fatal(CTXOPTCTEOPT, \"\");\n          break;\n\n        case '<':\n          if (opt->occurrences > 0 && opt->opt_count_mark <= opt->occurrences)\n            fatal(CTXOPTCTLOPT, \"\");\n          break;\n\n        case '>':\n          if (opt->occurrences > 0 && opt->opt_count_mark >= opt->occurrences)\n            fatal(CTXOPTCTGOPT, \"\");\n          break;\n      }\n\n    node = node->next;\n  }\n\n  /* Checks arguments. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx_inst->opt_inst_list->head;\n  while (node != NULL)\n  {\n    opt_inst = node->data;\n    opt      = opt_inst->opt;\n\n    /* Update current_state. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    cur_state->cur_opt_par_name = opt_inst->par;\n    cur_state->opts_count       = opt->opt_count_mark;\n    cur_state->opt_args_count   = opt->opt_args_count_mark;\n\n    int nb_values = opt_inst->values_list->len; /* Number of arguments of opt */\n\n    if (opt->opt_args_count_matter)\n      switch (opt->opt_args_count_oper)\n      {\n        case '=':\n          if (nb_values > 0 && opt->opt_args_count_mark != nb_values)\n            fatal(CTXOPTCTEARG, \"\");\n          break;\n\n        case '<':\n          if (nb_values > 0 && opt->opt_args_count_mark <= nb_values)\n            fatal(CTXOPTCTLARG, \"\");\n          break;\n\n        case '>':\n          if (nb_values > 0 && opt->opt_args_count_mark >= nb_values)\n            fatal(CTXOPTCTGARG, \"\");\n          break;\n      }\n\n    node = node->next;\n  }\n  cur_state->cur_opt_params   = cur_opt_params;\n  cur_state->cur_opt_par_name = cur_opt_par_name;\n}\n\n/* ====================================================================== */\n/* This function terminates the program if all the options which are part */\n/* of a group of required options by some other option are missing.       */\n/* ====================================================================== */\nstatic void\ncheck_for_requirement_issues(ctx_inst_t *ctx_inst)\n{\n  ll_node_t *node;\n  ll_node_t *req_node;\n  req_t     *req;\n  opt_t     *opt;\n  opt_t     *req_opt;\n  bst_t     *bst_node;\n  seen_opt_t tmp_seen_opt;\n  int        found;\n  char      *needed_params = NULL;\n\n  node = ctx_inst->opt_req_list->head;\n\n  while (node != NULL)\n  {\n    req = node->data;\n\n    opt              = req->opt;\n    tmp_seen_opt.opt = opt;\n\n    bst_node = bst_find(&tmp_seen_opt,\n                        &(ctx_inst->seen_opt_bst),\n                        seen_opt_compare);\n\n    /* TODO: make sure bst_node cannot be NULL here. */\n\n    if (bst_node && ((seen_opt_t *)(bst_node->key))->seen != 0)\n    {\n      found    = 0;\n      req_node = req->or_opt_list->head;\n\n      /* needed_params accumulates the params of the options in the group. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      free(needed_params); /* free can applied to the NULL pointer. */\n      needed_params = xstrdup(\"\");\n\n      /* Go through the list of the required group of options and */\n      /* succeed when one of them has been seen in the context.   */\n      /* otherwise a fatal error is triggered and the program is  */\n      /* terminated.                                              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while (req_node != NULL)\n      {\n        req_opt          = req_node->data;\n        tmp_seen_opt.opt = req_opt;\n        needed_params    = strappend(needed_params,\n                                  req_opt->params,\n                                  \"\\n  \",\n                                  (char *)0);\n\n        bst_node = bst_find(&tmp_seen_opt,\n                            &(ctx_inst->seen_opt_bst),\n                            seen_opt_compare);\n\n        if (((seen_opt_t *)(bst_node->key))->seen != 0)\n        {\n          found = 1; /* A required option has been seen, */\n          break;     /* accept the group.                */\n        }\n        req_node = req_node->next;\n      }\n\n      rtrim(needed_params, \"\\n \", 0);\n\n      /* This is a fatal error if none of the options in the required */\n      /* options group has been seen in the context.                  */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (!found)\n      {\n        char *errmsg;\n\n        if (req->or_opt_list->len > 1)\n          errmsg = xstrdup(\"At least one of the parameters among:\\n  %s\\n\"\n                           \"requested by %s must be present.\\n\");\n        else\n          errmsg = xstrdup(\"The parameter %s \"\n                           \"requested by %s must be present.\\n\");\n\n        cur_state->req_opt_par_needed = needed_params;\n        cur_state->req_opt_par        = opt->params;\n\n        fatal(CTXOPTREQPAR, errmsg);\n      }\n    }\n\n    node = node->next;\n  }\n}\n\n/* ======================================================================== */\n/* Parse a strings describing options and some of their characteristics     */\n/* The input string must have follow some rules like in the examples below: */\n/*                                                                          */\n/* \"opt_name1 opt_name2\"                                                    */\n/* \"[opt_name1] opt_name2\"                                                  */\n/* \"[opt_name1] opt_name2...\"                                               */\n/* \"[opt_name1 #...] opt_name2... [#]\"                                      */\n/* \"[opt_name1 [#...]] opt_name2... [#...]\"                                 */\n/*                                                                          */\n/* Where [ ] encloses an optional part, # means: has parameters and ...     */\n/* means that  there can be more than one occurrence of the previous thing. */\n/*                                                                          */\n/* opt_name can be followed by a 'new context' change prefixed with the     */\n/* symbol >, as in opt1>c2 by eg.                                           */\n/*                                                                          */\n/* This function returns as soon as one (or no) option has been parsed and  */\n/* return the offset to the next option to parse.                           */\n/*                                                                          */\n/* In case of successful parsing, an new option is allocated and its        */\n/* pointer returned.                                                        */\n/* ======================================================================== */\nstatic int\nopt_parse(char *s, opt_t **opt)\n{\n  int      opt_optional          = 0;\n  int      opt_multiple          = 0;\n  int      opt_count_matter      = 0;\n  char     opt_count_oper        = '\\0';\n  unsigned opt_count_mark        = 0;\n  int      opt_args              = 0;\n  char     opt_arg[33]           = { 0 };\n  int      opt_multiple_args     = 0;\n  int      opt_args_count_matter = 0;\n  char     opt_args_count_oper   = '\\0';\n  unsigned opt_args_count_mark   = 0;\n  int      opt_optional_args     = 0;\n  int      opt_eval_first        = 0;\n\n  int n;\n  int pos;\n  int count = 0;\n\n  char *s_orig = s;\n\n  char *p;\n  char *opt_name = NULL;\n  char *next_ctx;\n  char  token[65];\n\n  *opt = NULL;\n  memset(opt_arg, '\\0', 33);\n\n  /* Strip the leading blanks. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (isblank(*s))\n    s++;\n\n  if (*s == '[') /* Start of an optional option. */\n  {\n    opt_optional = 1;\n    s++;\n  }\n  s = strtoken(s, token, sizeof(token) - 1, \"[^] \\n\\t.]\", &pos);\n  if (s == NULL)\n    return -1; /* Empty string. */\n\n  /* Early EOS, only return success if the option is mandatory. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!*s)\n    if (opt_optional == 1)\n      return -(s - s_orig - 1);\n\n  /* Validate the option name */\n  /* ALPHA+(ALPHANUM|_)*      */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  p = token;\n  if (!isalpha(*p) && *p != '*')\n    return -(s - s_orig - 1); /* opt_name must start with a letter. */\n\n  if (*p == '*')\n    opt_eval_first = 1;\n\n  p++;\n  while (*p)\n  {\n    if (!isalnum(*p) && *p != '_' && *p != '>')\n      return -(s - s_orig - 1); /* opt_name must contain a letter, *\n                                 * a number or a _                 */\n    p++;\n  }\n\n  if (opt_eval_first)\n    opt_name = xstrdup(token + 1); /* Ignore the first '*' in token. */\n  else\n    opt_name = xstrdup(token);\n\n  if (*s == ']')\n  {\n    s++;\n    while (isblank(*s))\n      s++;\n\n    goto success;\n  }\n\n  /* Check if it can appear multiple times by looking for the dots. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  p = strtoken(s, token, 3, \"[.]\", &pos);\n  if (p)\n  {\n    if (strcmp(token, \"...\") == 0)\n    {\n      opt_multiple = 1;\n      s            = p;\n      if (*s == '<' || *s == '=' || *s == '>')\n      {\n        unsigned value;\n        int      offset;\n\n        n = sscanf(s + 1, \"%u%n\", &value, &offset);\n        if (n == 1)\n        {\n          opt_count_matter = 1;\n          opt_count_oper   = *s;\n          opt_count_mark   = value;\n        }\n        s += offset + 1;\n      }\n    }\n    else\n    {\n      free(opt_name);\n      return -(s - s_orig - 1);\n    }\n  }\n\n  if (*s == ']')\n  {\n    /* Abort on extraneous ] if the option is mandatory. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!opt_optional)\n    {\n      free(opt_name);\n      return -(s - s_orig - 1);\n    }\n\n    s++; /* skip the ] */\n\n    if (!*s || isblank(*s))\n      goto success;\n    else\n    {\n      free(opt_name);\n      return -(s - s_orig - 1);\n    }\n  }\n\n  /* A blank separates the option name and the argument tag. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (isblank(*s))\n  {\n    char dots[4];\n\n    while (isblank(*s))\n      s++;\n\n    if (!*s)\n      goto success;\n\n    pos = 0;\n    n   = sscanf(s, \"[%32[^] .\\t]%n%3[.]\", opt_arg, &pos, dots);\n    if (pos > 1 && *opt_arg == '#') /* [# has been read. */\n    {\n      opt_args          = 1;\n      opt_optional_args = 1;\n      if (n == 2)\n        opt_multiple_args = 1; /* There were dots. */\n\n      s += pos + !!(n == 2) * 3; /* Skips the dots. */\n\n      if (*s == '<' || *s == '=' || *s == '>')\n      {\n        unsigned value;\n        int      offset;\n\n        n = sscanf(s + 1, \"%u%n\", &value, &offset);\n        if (n == 1)\n        {\n          opt_args_count_matter = 1;\n          opt_args_count_oper   = *s;\n          opt_args_count_mark   = value;\n        }\n        s += offset + 1;\n      }\n\n      /* Optional arg tag must end with a ] */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (*s != ']')\n      {\n        free(opt_name);\n        return -(s - s_orig - 1);\n      }\n\n      s++; /* Skip the ] */\n    }\n    else\n    {\n      n = sscanf(s, \"%32[^] .\\t]%n%3[.]\", opt_arg, &pos, dots);\n      if (pos > 0 && *opt_arg == '#') /* # has been read. */\n      {\n        opt_args = 1;\n        if (n == 2) /* There were dots. */\n          opt_multiple_args = 1;\n\n        s += pos + !!(n == 2) * 3; /* Skip the dots. */\n\n        if (*s == '<' || *s == '=' || *s == '>')\n        {\n          unsigned value;\n          int      offset;\n\n          n = sscanf(s + 1, \"%u%n\", &value, &offset);\n          if (n == 1)\n          {\n            opt_args_count_matter = 1;\n            opt_args_count_oper   = *s;\n            opt_args_count_mark   = value;\n          }\n          s += offset + 1;\n        }\n      }\n    }\n    if (*s == ']')\n    {\n      /* Abort on extraneous ] if the option is mandatory. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (!opt_optional)\n      {\n        free(opt_name);\n        return -(s - s_orig - 1);\n      }\n\n      s++; /* skip the ] */\n\n      /* Strip the following blanks. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while (isblank(*s))\n        s++;\n\n      goto success;\n    }\n    else if (opt_optional == 0 && (!*s || isblank(*s)))\n    {\n      /* Strip the following blanks. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while (isblank(*s))\n        s++;\n\n      goto success;\n    }\n    else if (opt_args == 0) /* # was not read it is possibly the start *\n                             | of another option.                      */\n      goto success;\n    else\n    {\n      free(opt_name);\n      return -(s - s_orig - 1);\n    }\n  }\n\nsuccess:\n\n  /* Strip the following blanks. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (isblank(*s))\n    s++;\n\n  next_ctx = NULL;\n\n  if (*opt_name == '>')\n    fatal_internal(\"The option name is missing in %s.\", opt_name);\n\n  count = strchrcount(opt_name, '>');\n  if (count == 1)\n  {\n    char *tmp = strchr(opt_name, '>');\n    next_ctx  = xstrdup(tmp + 1);\n    *tmp      = '\\0';\n  }\n  else if (count > 1)\n    fatal_internal(\"Only one occurrence of '>' is allowed in %s.\", opt_name);\n\n  *opt = xmalloc(sizeof(opt_t));\n\n  (*opt)->name                  = opt_name;\n  (*opt)->optional              = opt_optional;\n  (*opt)->multiple              = opt_multiple;\n  (*opt)->opt_count_matter      = opt_count_matter;\n  (*opt)->opt_count_oper        = opt_count_oper;\n  (*opt)->opt_count_mark        = opt_count_mark;\n  (*opt)->args                  = opt_args;\n  (*opt)->arg                   = xstrdup(opt_arg);\n  (*opt)->optional_args         = opt_optional_args;\n  (*opt)->multiple_args         = opt_multiple_args;\n  (*opt)->opt_args_count_matter = opt_args_count_matter;\n  (*opt)->opt_args_count_oper   = opt_args_count_oper;\n  (*opt)->opt_args_count_mark   = opt_args_count_mark;\n  (*opt)->eval_first            = opt_eval_first;\n  (*opt)->next_ctx              = next_ctx;\n  (*opt)->ctx_list              = ll_new();\n  (*opt)->constraints_list      = ll_new();\n  (*opt)->eval_before_list      = ll_new();\n  (*opt)->action                = NULL;\n  (*opt)->params                = NULL;\n  (*opt)->data                  = NULL;\n  (*opt)->visible_in_help       = 1;\n\n  return s - s_orig;\n}\n\n/* ==================================================================== */\n/* Try to initialize all the option in a given string.                  */\n/* Each parsed option are put in a BST tree with its name as index.     */\n/*                                                                      */\n/* On collision, the arguments only the signature are required to be    */\n/* the same else this is considered as an error. Options can be used in */\n/* more than one context and can be optional in one and mandatory in    */\n/* another.                                                             */\n/* ==================================================================== */\nstatic int\ninit_opts(char *spec, ctx_t *ctx)\n{\n  opt_t *opt, *bst_opt;\n  bst_t *node;\n  int    offset;\n\n  while (*spec)\n  {\n    if ((offset = opt_parse(spec, &opt)) > 0)\n    {\n      spec += offset;\n\n      if ((node = bst_find(opt, &options_bst, opt_compare)) != NULL)\n      {\n        int same_next_ctx = 0;\n\n        bst_opt = node->key; /* Node extracted from the BST. */\n\n        if (bst_opt->next_ctx == NULL && opt->next_ctx == NULL)\n          same_next_ctx = 1;\n        else if (bst_opt->next_ctx == NULL && opt->next_ctx != NULL)\n          same_next_ctx = 0;\n        else if (bst_opt->next_ctx != NULL && opt->next_ctx == NULL)\n          same_next_ctx = 0;\n        else\n          same_next_ctx = strcmp(bst_opt->next_ctx, opt->next_ctx) == 0;\n\n        if (bst_opt->optional_args != opt->optional_args\n            || bst_opt->multiple_args != opt->multiple_args\n            || bst_opt->args != opt->args || !same_next_ctx)\n        {\n          fatal_internal(\"The option %s already exists with \"\n                         \"a different arguments signature.\\n\",\n                         opt->name);\n        }\n\n        /* The newly created opt is already present in options_bst. */\n        /* We can remove it.                                        */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        opt_free(opt);\n\n        /* The new occurrence of the option option is legal */\n        /* append the current context ptr in the list.      */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        ll_append(bst_opt->ctx_list, ctx);\n\n        /* Append the new option to the context's options list. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        ll_append(ctx->opt_list, bst_opt);\n      }\n      else\n      {\n        /* Initialize the option's context list with the current context. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        ll_append(opt->ctx_list, ctx);\n\n        /* Append the new option to the context's options list. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        ll_append(ctx->opt_list, opt);\n\n        /* Insert the new option in the BST. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        bst_search(opt, &options_bst, opt_compare);\n      }\n    }\n    else\n    {\n      char *s = xstrndup(spec, -offset);\n      printf(\"%s <---\\nSyntax error at or before offset %d\\n\", s, -offset);\n      free(s);\n\n      exit(EXIT_FAILURE);\n    }\n  }\n\n  return 1;\n}\n\n/* ===================================================== */\n/* ctxopt initialization function, must be called first. */\n/* ===================================================== */\nvoid\nctxopt_init(char *prog_name, char *init_flags)\n{\n  int n;\n\n  contexts_bst = NULL;\n  options_bst  = NULL;\n  char *ptr;\n\n  user_rc      = 0;\n  user_value   = 0;\n  user_string  = xmalloc(8);\n  user_string2 = xmalloc(8);\n  user_object  = NULL;\n  char flag[33], fname[31], vname[31];\n  int  invalid;\n\n  ctxopt_initialized = 1;\n\n  /* Initialize current_state.*/\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  cur_state = xcalloc(sizeof(state_t), 0);\n\n  /* Initialize custom error function pointers to NULL. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  err_functions = xmalloc(CTXOPTERRSIZ * sizeof(void *));\n  for (n = 0; n < CTXOPTERRSIZ; n++)\n    err_functions[n] = NULL;\n\n  /* Parse init_flags if any. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*init_flags && (init_flags = get_word(init_flags, flag, 32)))\n  {\n    if (*flag)\n    {\n      if (sscanf(flag, \"%30[^=]=%30[^=]\", fname, vname) != 2)\n        fatal_internal(\"Invalid flag assignment: %s.\", flag);\n\n      if (strcmp(fname, \"stop_if_non_option\") == 0)\n      {\n        if (eval_yes(vname, &invalid))\n          flags.stop_if_non_option = 1;\n        else if (!invalid)\n          flags.stop_if_non_option = 0;\n        else\n          fatal_internal(\"Invalid flag value for %s: %s.\", fname, vname);\n      }\n      else if (strcmp(fname, \"allow_abbreviations\") == 0)\n      {\n        if (eval_yes(vname, &invalid))\n          flags.allow_abbreviations = 1;\n        else if (!invalid)\n          flags.allow_abbreviations = 0;\n        else\n          fatal_internal(\"Invalid flag value for %s: %s.\", fname, vname);\n      }\n      else if (strcmp(fname, \"display_usage_on_error\") == 0)\n      {\n        if (eval_yes(vname, &invalid))\n          flags.display_usage_on_error = 1;\n        else if (!invalid)\n          flags.display_usage_on_error = 0;\n        else\n          fatal_internal(\"Invalid flag value for %s: %s.\", fname, vname);\n      }\n      else\n        fatal_internal(\"Invalid flag name: %s.\", fname);\n    }\n  }\n\n  /* Update current_state. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (prog_name)\n  {\n    if (*prog_name == '\\0')\n      cur_state->prog_name = xstrdup(\"program_name\");\n    else if ((ptr = strrchr(prog_name, '/')))\n      cur_state->prog_name = xstrdup(ptr + 1);\n    else\n      cur_state->prog_name = xstrdup(prog_name);\n  }\n  else\n    cur_state->prog_name = xstrdup(\"program_name\");\n}\n\n/* ========================================================================= */\n/* Utility function which create and register a par_t object in a BST        */\n/* embedded in a context.                                                    */\n/* This object will have a name and a pointer to the option it refers to.    */\n/* These object will be used to quickly find an option from a command        */\n/* line parameter during the analysis phase.                                 */\n/*                                                                           */\n/* IN      : an option name.                                                 */\n/* IN      : a string of command line parameters to associate to the option. */\n/* Returns : 1 is all was fine else 0.                                       */\n/* ========================================================================= */\nstatic int\nopt_set_parms(char *opt_name, char *par_str)\n{\n  char  *par_name, *ctx_name;\n  char  *tmp_par_str, *end_tmp_par_str;\n  ctx_t *ctx;\n  opt_t *opt;\n  bst_t *node;\n  par_t *par, tmp_par;\n  int    rc = 1; /* Return code. */\n\n  ll_t      *list;\n  ll_node_t *lnode;\n\n  /* Look if the given option is defined. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  opt = locate_opt(opt_name);\n  if (opt == NULL)\n    fatal_internal(\"Unknown option %s.\", opt_name);\n\n  /* For each context using this option. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  list = opt->ctx_list;\n\n  lnode = list->head;\n  while (lnode != NULL)\n  {\n    /* Locate the context in the contexts tree. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    ctx_name = ((ctx_t *)(lnode->data))->name;\n\n    ctx = locate_ctx(ctx_name);\n    if (ctx == NULL)\n      fatal_internal(\"Unknown context %s.\", ctx_name);\n    else\n    {\n      void *par_bst = ctx->par_bst;\n\n      tmp_par_str = xstrdup(par_str);\n      ltrim(tmp_par_str, \" \\t\");\n      rtrim(tmp_par_str, \" \\t\", 0);\n      par_name = xstrtok_r(tmp_par_str, \" \\t,\", &end_tmp_par_str);\n      if (par_name == NULL)\n        fatal_internal(\"Parameters are missing for option %s.\", opt_name);\n\n      /* For each parameter given in par_str, creates a par_t object and */\n      /* insert it the in the parameters BST of the context.             */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while (par_name != NULL)\n      {\n        tmp_par.name = par_name;\n\n        node = bst_find(&tmp_par, &par_bst, par_compare);\n        if (node != NULL)\n        {\n          fatal_internal(\"The parameter %s is already defined in context %s.\",\n                         par_name,\n                         ctx->name);\n          rc = 0;\n        }\n        else\n        {\n          par       = xmalloc(sizeof(par_t));\n          par->name = xstrdup(par_name);\n          par->opt  = opt; /* Link the option to this parameter. */\n\n          bst_search(par, &par_bst, par_compare);\n        }\n        par_name = xstrtok_r(NULL, \" \\t,\", &end_tmp_par_str);\n      }\n\n      /* Update the value of the root of ctx->par_bst as it may have */\n      /* been modified.                                              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ctx->par_bst = par_bst;\n\n      free(tmp_par_str);\n    }\n    lnode = lnode->next;\n  }\n\n  return rc;\n}\n\n/* ==================================================================== */\n/* Create a new context instance.                                       */\n/* IN ctx            : a context pointer to allow this instance to      */\n/*                     access the context fields                        */\n/* IN prev_ctx_inst  : the context instance whose option leading to the */\n/*                     creation of this new context instance is part of */\n/* Returns           : the new context.                                 */\n/* ==================================================================== */\nstatic ctx_inst_t *\nnew_ctx_inst(ctx_t *ctx, ctx_inst_t *prev_ctx_inst)\n{\n  opt_t      *opt;\n  opt_inst_t *gen_opt_inst;\n  ctx_inst_t *ctx_inst;\n  seen_opt_t *seen_opt;\n  char       *str, *opt_name;\n  void       *bst;\n  bst_t      *bst_node;\n\n  /* Keep a trace of the opt_inst which was at the origin of the creation */\n  /* of this context instance.                                            */\n  /* This will serve during the evaluation of the option callbacks.       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (prev_ctx_inst != NULL)\n  {\n    gen_opt_inst = (opt_inst_t *)(prev_ctx_inst->opt_inst_list->tail->data);\n\n    /* Update current_state. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    cur_state->opt_name = gen_opt_inst->opt->name;\n  }\n  else\n    gen_opt_inst = NULL;\n\n  /* Create and initialize the new context instance. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctx_inst                  = xmalloc(sizeof(ctx_inst_t));\n  ctx_inst->ctx             = ctx;\n  ctx_inst->prev_ctx_inst   = prev_ctx_inst;\n  ctx_inst->gen_opt_inst    = gen_opt_inst;\n  ctx_inst->incomp_bst_list = ll_new();\n  ctx_inst->opt_inst_list   = ll_new();\n  ctx_inst->opt_req_list    = ll_new();\n  ctx_inst->seen_opt_bst    = NULL;\n\n  ll_node_t *node;\n\n  if (prev_ctx_inst == NULL)\n    first_ctx_inst = ctx_inst;\n\n  /* Initialize the occurrence counters of each opt allowed in the context. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->opt_list->head;\n  while (node != NULL)\n  {\n    opt              = node->data;\n    opt->occurrences = 0;\n\n    node = node->next;\n  }\n\n  /* Initialize the BST containing the seen indicator for all the options */\n  /* allowed in this context instance.                                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->opt_list->head;\n  while (node != NULL)\n  {\n    opt            = node->data;\n    seen_opt       = xmalloc(sizeof(seen_opt_t));\n    seen_opt->opt  = opt;\n    seen_opt->par  = NULL;\n    seen_opt->seen = 0;\n\n    bst_search(seen_opt, &(ctx_inst->seen_opt_bst), seen_opt_compare);\n\n    node = node->next;\n  }\n\n  /* Initialize the BST containing the incompatibles options.              */\n  /* Incompatibles option names are read from strings found in the list    */\n  /* incomp_list present in each instance of ctx_t.                        */\n  /* These names are then used to search for the object of type seen_opt_t */\n  /* which is already present in the seen_opt_bst of the context instance. */\n  /* in the BST.                                                           */\n  /* Once found the seen_opt_t object in inserted in the new BST.          */\n  /* At the end the new BST in added to the list incomp_bst_list.          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->incomp_list->head;\n  while (node != NULL)\n  {\n    bst = NULL;\n    seen_opt_t tmp_seen_opt;\n\n    str = xstrdup(node->data);\n    ltrim(str, \" \\t\");\n    rtrim(str, \" \\t\", 0);\n    opt_name = strtok(str, \" \\t\"); /* Extract the first option name. */\n\n    while (opt_name != NULL) /* For each option name. */\n    {\n      if ((opt = locate_opt(opt_name)) != NULL)\n      {\n        /* The option found is searched in the tree of potential */\n        /* seen options.                                         */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        tmp_seen_opt.opt = opt;\n\n        bst_node = bst_find(&tmp_seen_opt,\n                            &(ctx_inst->seen_opt_bst),\n                            seen_opt_compare);\n\n        if (bst_node != NULL)\n        {\n          /* If found then it is added into the new BST tree. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          seen_opt = bst_node->key;\n          bst_search(seen_opt, &bst, seen_opt_compare);\n        }\n        else\n          /* Not found! That means that the option is unknown in this */\n          /* context as all options has have a seen_opt structure in  */\n          /* seen_opt_bst.                                            */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          fatal_internal(\"%s is not known in the context %s.\",\n                         opt->name,\n                         ctx->name);\n      }\n      else\n        fatal_internal(\"Unknown option %s.\", opt_name);\n\n      opt_name = strtok(NULL, \" \\t\");\n    }\n\n    free(str);\n    ll_append(ctx_inst->incomp_bst_list, bst);\n\n    node = node->next;\n  }\n\n  /* Initialize the list of res_t structures according to the     */\n  /* list set in the context by ctxopt_add_ctx_settings/required. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx->req_list->head;\n  while (node != NULL)\n  {\n    req_t *req = xmalloc(sizeof(req_t));\n\n    str = xstrdup(node->data);\n    ltrim(str, \" \\t\");\n    rtrim(str, \" \\t\", 0);\n    opt_name = strtok(str, \" \\t\"); /* Extract the first option name. */\n\n    if ((opt = locate_opt(opt_name)) != NULL)\n    {\n      req->opt         = opt;\n      req->or_opt_list = ll_new();\n      while ((opt_name = strtok(NULL, \" \\t\")) != NULL)\n      {\n        if ((opt = locate_opt(opt_name)) != NULL)\n          ll_append(req->or_opt_list, opt);\n        else\n          fatal_internal(\"Unknown option %s.\", opt_name);\n      }\n      ll_append(ctx_inst->opt_req_list, req);\n    }\n    else\n      fatal_internal(\"Unknown option %s.\", opt_name);\n\n    free(str);\n\n    node = node->next;\n  }\n  return ctx_inst;\n}\n\n/* ====================================================================== */\n/* Create a list formed by all the significant command line words         */\n/* Words beginning or ending with { or } are split. Each of these         */\n/* symbols will get their own place in the list.                          */\n/*                                                                        */\n/* the {...} part delimits a context, the { will not appear in the list   */\n/* and the } will be replaced by a | in the resulting list (cmdline_list) */\n/* to facilitate the parsing phase. | must not be used by the end user.   */\n/*                                                                        */\n/* IN nb_word : number of word to parse, this is typically argc-1 as the  */\n/*              program name is not considered.                           */\n/* IN words   : is the array of strings constituting the command line to  */\n/*              parse.                                                    */\n/* Returns    : 1 on success, 0 if a { or } is missing.                   */\n/* ====================================================================== */\nstatic int\nctxopt_build_cmdline_list(int nb_words, char **words)\n{\n  int        i;\n  char      *prev_word = NULL;\n  char      *word;\n  char      *ptr;\n  int        level = 0;\n  ll_node_t *node, *start_node;\n\n  /* The analysis is divided into three passes, this is not optimal but  */\n  /* must be done only one time. Doing that we privilege readability.    */\n  /*                                                                     */\n  /* In the following, SG is the ASCII character 1d (dec 29)             */\n  /*                                                                     */\n  /* The first pass creates the list, extract the leading an trailing    */\n  /*  SG '{' and '}' of each word and give them their own place in the   */\n  /* list                                                                */\n  /*                                                                     */\n  /* The second pass transform the '{...}' blocks by a trailing SG       */\n  /* ({...} -> ...|)                                                     */\n  /*                                                                     */\n  /* The last pass remove the duplicated SG, check for SG, '{' or '}' in */\n  /* the middle in the remaining list elements and recreate the pseudo   */\n  /* argument: {}                                                        */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  /* If the option list is not empty, clear it before going further. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (cmdline_list != NULL)\n    ll_destroy(cmdline_list, free);\n\n  cmdline_list = ll_new();\n\n  start_node = cmdline_list->head; /* In the following loop start_node will *\n                                    | contain a pointer to the current      *\n                                    | word stripped from its leading        *\n                                    | sequence of {, }.                     */\n  for (i = 0; i < nb_words; i++)\n  {\n    size_t len = strlen(words[i]);\n    size_t start, end;\n    char  *str;\n\n    str = words[i];\n\n    /* Replace each occurrence of the legal word {} by the characters */\n    /* 0x02 and 0x03 to hide them from the following process.         */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while ((ptr = strstr(str, \"{}\")) != NULL)\n    {\n      *ptr       = 0x02; /* Arbitrary values unlikely */\n      *(ptr + 1) = 0x03; /* present in a word.        */\n    }\n\n    if (len > 1) /* The word contains at least 2 characters. */\n    {\n      start = 0;\n\n      /* Interpret its beginning and look for the start of the real word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while (start <= len - 1 && (str[start] == '{' || str[start] == '}'))\n      {\n        ll_append(cmdline_list, xstrndup(str + start, 1));\n        start++;\n        start_node = cmdline_list->tail;\n      }\n\n      end = len - 1;\n      if (str[end] == '{' || str[end] == '}')\n      {\n        if (end > 0 && str[end - 1] != '\\\\')\n        {\n          ll_append(cmdline_list, xstrndup(str + end, 1));\n          end--;\n          node = cmdline_list->tail;\n\n          while (str[end] == '{' || str[end] == '}')\n          {\n            if (end > start && str[end - 1] == '\\\\')\n              break;\n\n            ll_insert_before(cmdline_list, node, xstrndup(str + end, 1));\n            end--;\n            node = node->prev;\n          }\n        }\n      }\n\n      if (start <= end)\n      {\n        if (start_node != NULL)\n          ll_insert_after(cmdline_list,\n                          start_node,\n                          xstrndup(str + start, end - start + 1));\n        else\n          ll_append(cmdline_list, xstrndup(str + start, end - start + 1));\n        start_node = cmdline_list->tail;\n      }\n    }\n    else if (len == 1)\n    {\n      ll_append(cmdline_list, xstrdup(str));\n      start_node = cmdline_list->tail;\n    }\n  }\n\n  /* 2nd pass. */\n  /* \"\"\"\"\"\"\"\"\" */\n  node = cmdline_list->head;\n\n  level = 0;\n  while (node != NULL)\n  {\n    word = node->data;\n\n    if (strcmp(word, \"{\") == 0)\n    {\n      ll_node_t *old_node = node;\n      level++;\n      node = node->next;\n      free(word);\n      ll_delete(cmdline_list, old_node);\n    }\n    else if (strcmp(word, \"}\") == 0)\n    {\n      level--;\n\n      if (level < 0)\n        return 0;\n      else\n        *word = 0x1d;\n    }\n    else\n      node = node->next;\n  }\n\n  if (level != 0)\n    return 0;\n\n  /* 3rd pass. */\n  /* \"\"\"\"\"\"\"\"\" */\n  node = cmdline_list->head;\n\n  while (node != NULL)\n  {\n    word = node->data;\n\n    /* Restore the original { and } characters forming the legal word {}. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while ((ptr = strchr(word, 0x02)) != NULL)\n      *ptr = '{';\n    while ((ptr = strchr(word, 0x03)) != NULL)\n      *ptr = '}';\n\n    /* Remove a SG if the previous element is SG. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strcmp(word, \"\\x1d\") == 0)\n    {\n      if (prev_word != NULL && (strcmp(prev_word, \"\\x1d\") == 0))\n      {\n        ll_node_t *old_node = node;\n        node                = node->prev;\n        free(old_node->data);\n        ll_delete(cmdline_list, old_node);\n      }\n    }\n    else if (strcmp(word, \"-\") == 0) /* A single - is a legal argument, not *\n                                      | a parameter. Protect it.            */\n    {\n      free(node->data);\n      node->data = xstrdup(\"\\\\-\");\n    }\n\n    prev_word = node->data;\n    node      = node->next;\n  }\n\n  /* Clean useless and SG at the beginning and end of list. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = cmdline_list->head;\n\n  if (node == NULL)\n    return 1;\n\n  word = node->data;\n\n  if (strcmp(word, \"\\x1d\") == 0)\n  {\n    free(word);\n    ll_delete(cmdline_list, node);\n  }\n\n  node = cmdline_list->tail;\n  if (node == NULL)\n    return 1;\n\n  word = node->data;\n\n  if (strcmp(word, \"\\x1d\") == 0)\n  {\n    free(word);\n    ll_delete(cmdline_list, node);\n  }\n\n  return 1;\n}\n\n/* ===================================================================== */\n/* Build and analyze the command line list and create the linked data    */\n/* structures whose data will be evaluated later by ctxopt_evaluate.     */\n/* This function identifies the following errors and creates an array of */\n/* The remaining not yet analyzed arguments.                             */\n/* - detect missing arguments                                            */\n/* - detect too many arguments                                           */\n/* - detect unknown parameters in a context                              */\n/* - detect too many occurrences of a parameters in a context            */\n/* - detect missing required arguments in a context                      */\n/*                                                                       */\n/* IN nb_word : number of word to parse, this is typically argc-1 as the */\n/*              program name is not considered                           */\n/* IN words   : is the array of strings constituting the command line to */\n/*              parse.                                                   */\n/* OUT nb_rem_args : nb of remaining command line arguments if a --      */\n/*                   is present in the list.                             */\n/* OUT rem_args    : array of remaining command line arguments if a --   */\n/*                   is present in the list. This array must be free by  */\n/*                   The caller as it is allocated here.                 */\n/* ===================================================================== */\nvoid\nctxopt_analyze(int nb_words, char **words, int *nb_rem_args, char ***rem_args)\n{\n  char *ctxopt_debug_env; /* Environment variable CTXOPT_DEBUG content.  */\n  int   ctxopt_debug;     /* 1 if ctxopt_debug_env is set and not empty. *\n                           | 0 if ctxopt_debug_env is unset or empty.    */\n\n  ctx_t      *ctx;\n  opt_t      *opt = NULL;\n  par_t      *par;\n  ctx_inst_t *ctx_inst;\n  opt_inst_t *opt_inst;\n  int         expect_par        = 0;\n  int         expect_arg        = 0;\n  int         expect_par_or_arg = 0;\n\n  ll_node_t  *cli_node;\n  bst_t      *bst_node;\n  seen_opt_t *bst_seen_opt;\n  char       *par_name;\n  void       *bst;\n\n  ll_node_t *node;\n\n  if (!ctxopt_build_cmdline_list(nb_words, words))\n    fatal_internal(\"The command line could not be parsed: \"\n                   \"missing '{' or '}' detected.\");\n\n  if (main_ctx == NULL)\n    fatal_internal(\"At least one context must have been created.\");\n\n  /* Check that all options has an action and at least one parameter. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  bst_walk(options_bst, bst_check_opt_cb);\n\n  /* CTXOPT debug setting. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctxopt_debug_env = getenv(\"CTXOPT_DEBUG\");\n  if (ctxopt_debug_env != NULL && *ctxopt_debug_env != '\\0')\n    ctxopt_debug = 1;\n  else\n    ctxopt_debug = 0;\n\n  /* Create the first ctx_inst record. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctx = main_ctx;\n\n  ctx_inst_list      = ll_new();\n  ctx_inst           = new_ctx_inst(ctx, NULL);\n  ctx_inst->par_name = NULL;\n\n  /* Update current_state. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  cur_state->ctx_name = ctx->name;\n\n  ll_append(ctx_inst_list, ctx_inst);\n\n  /* For each node in the command line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  cli_node   = cmdline_list->head;\n  expect_par = 1;\n  par_name   = NULL;\n\n  while (cli_node != NULL)\n  {\n    if (strcmp(cli_node->data, \"--\") == 0)\n      break; /* No new parameter will be analyzed after this point. */\n\n    par_name = cli_node->data;\n\n    /* Replace a leading -- by a single - */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strncmp(par_name, \"--\", 2) == 0)\n      par_name += 1; /* Ignore the first dash. */\n\n    if (strcmp(par_name, \"\\x1d\") == 0)\n    {\n      check_for_missing_mandatory_opt(ctx_inst, (char *)(cli_node->prev->data));\n      check_for_occurrence_issues(ctx_inst);\n      check_for_requirement_issues(ctx_inst);\n\n      /* Forced backtracking to the previous context instance. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (ctx_inst->prev_ctx_inst != NULL)\n      {\n        ctx_inst = ctx_inst->prev_ctx_inst;\n        ctx      = ctx_inst->ctx;\n\n        /* Update current_states. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"  */\n        cur_state->ctx_name     = ctx->name;\n        cur_state->ctx_par_name = ctx_inst->par_name;\n\n        if (ctxopt_debug)\n          fprintf(stderr,\n                  \"CTXOPT_DEBUG: Context forced backtrack, \"\n                  \"new current context: %s.\\n\",\n                  ctx->name);\n      }\n      else\n      {\n        /* Update current_state. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        cur_state->ctx_par_name = NULL;\n      }\n    }\n    else if (expect_par && *par_name == '-')\n    {\n      int   pos = 0;\n      char *prefix;\n\n      /* Update current_state. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      cur_state->cur_opt_par_name = par_name;\n      cur_state->ctx_name         = ctx->name;\n      cur_state->ctx_par_name     = ctx_inst->par_name;\n\n      if (ctxopt_debug)\n        fprintf(stderr,\n                \"CTXOPT_DEBUG: Parameter: %s. Current context: %s.\\n\",\n                par_name,\n                cur_state->ctx_name);\n\n      /* An expected parameter has been seen. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if ((par = locate_par(par_name, ctx)) == NULL)\n      {\n        opt_t *popt;\n        char  *word;\n\n        /* Look if this parameter is an unique abbreviation of a longer */\n        /* parameter. If this is the case then just replace it with its */\n        /* full length version and try again.                           */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (flags.allow_abbreviations)\n          if ((word = abbrev_expand(par_name, ctx)) != NULL)\n          {\n            cli_node->data = word;\n            continue;\n          }\n\n        /* Try to find a prefix which is a valid parameter in this context */\n        /* If found, split the cli_node in two to build a new parameter    */\n        /* node and followed by a node containing the remaining string     */\n        /* If the new parameter corresponds to an option not taking        */\n        /* argument then prefix the remaining string whit a dash as it may */\n        /* contain a new parameter.                                        */\n        /* The new parameter will be re-evaluated in the next iteration of */\n        /* the loop.                                                       */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"*/\n        prefix = look_for_valid_prefix_in_word(par_name, ctx, &pos, &popt);\n        if (prefix != NULL && pos != 0)\n        {\n          if (ctxopt_debug)\n            fprintf(stderr,\n                    \"CTXOPT_DEBUG: Found a valid parameter \"\n                    \"as a prefix of %s: %s.\\n\",\n                    par_name,\n                    prefix);\n\n          cli_node->data = prefix; /* prefix contains le name of a valid *\n                                    | parameter in this context.         */\n\n          if (popt->args)\n          {\n            /* The parameter may be followed by arguments. */\n            /* ''''''''''''''''''''''''''''''''''''''''''' */\n            if (*(par_name + pos) == '-')\n            {\n              word = xstrdup(\"\\\\\"); /* Protect the '-' */\n              word = strappend(word, par_name + pos, (char *)0);\n            }\n            else\n              word = xstrdup(par_name + pos);\n          }\n          else\n          {\n            /* The parameter does not take arguments, the    */\n            /* following word must be a parameter or nothing */\n            /* hence prefix it with a dash.                  */\n            /* ''''''''''''''''''''''''''''''''''''''''''''' */\n            word = xstrdup(\"-\");\n            word = strappend(word, par_name + pos, (char *)0);\n          }\n\n          /* Insert it after the current node in the list. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          ll_insert_after(cmdline_list, cli_node, word);\n\n          continue; /* loop. */\n        }\n        else\n        {\n          check_for_missing_mandatory_opt(ctx_inst, par_name);\n          check_for_occurrence_issues(ctx_inst);\n          check_for_requirement_issues(ctx_inst);\n\n          if (ctx_inst->prev_ctx_inst == NULL)\n          {\n            char *errmsg = xstrdup(\"\");\n\n            /* Update current_state. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            cur_state->ctx_par_name = NULL;\n\n            *user_string  = '\\0';\n            *user_string2 = '\\0';\n\n            user_string = strappend(user_string, par_name, (char *)0);\n\n            bst_walk(contexts_bst, bst_match_par_cb);\n\n            if (*user_string2 != '\\0')\n            {\n              char *help_msg;\n              int   count = 0;\n\n              count = strchrcount(user_string2, '\\n');\n\n              if (flags.display_usage_on_error)\n                help_msg = \", see below\";\n              else\n                help_msg = \"\";\n\n              if (count == 0) /* Only one context involved. */\n                errmsg = strappend(\n                  errmsg,\n                  \"\\nThis parameter is only valid in the following \"\n                  \"context:\\n\",\n                  user_string2,\n                  \"\\n\\nFirst switch to this context using the appropriate \"\n                  \"parameter\",\n                  help_msg,\n                  \".\\n\",\n                  (char *)0);\n              else\n                errmsg = strappend(\n                  errmsg,\n                  \"\\nThis parameter is only valid in one of the following \"\n                  \"contexts:\\n\",\n                  user_string2,\n                  \"\\n\\nFirst switch to one of them using the appropriate \"\n                  \"parameter\",\n                  help_msg,\n                  \".\\n\",\n                  (char *)0);\n            }\n\n            fatal(CTXOPTUNKPAR, errmsg);\n          }\n          else\n          {\n            /* Tries to backtrack and analyse the same parameter in the */\n            /* previous context.                                        */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            ctx_inst = ctx_inst->prev_ctx_inst;\n            ctx      = ctx_inst->ctx;\n\n            if (ctxopt_debug)\n              fprintf(stderr,\n                      \"CTXOPT_DEBUG: Context backtrack, \"\n                      \"new current context: %s.\\n\",\n                      ctx->name);\n\n            /* Update current_state. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            cur_state->ctx_name     = ctx->name;\n            cur_state->ctx_par_name = ctx_inst->par_name;\n\n            cli_node = cli_node->prev;\n          }\n        }\n      }\n      else\n      {\n        seen_opt_t seen_opt;\n\n        /* The parameter is valid in the context, create a opt_inst and */\n        /* append it to the ctx_inst list options list.                 */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        opt = par->opt;\n\n        opt->occurrences++;\n\n        opt_inst                = xmalloc(sizeof(opt_inst_t));\n        opt_inst->opt           = opt;\n        opt_inst->par           = par_name;\n        opt_inst->values_list   = ll_new();\n        opt_inst->next_ctx_inst = NULL;\n\n        /* Update current_state. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        cur_state->cur_opt_params = opt->params;\n\n        /* Priority option are inserted at the start of the opt_inst list */\n        /* but their order of appearance in the context definition must   */\n        /* be preserver so each new priority option will be placed after  */\n        /* the previous ones at the start of the opt_inst list.           */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (!opt->eval_first)\n        {\n          /* Look if we have a registered dependency in the order of the */\n          /* evaluation of two options.                                  */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (opt->eval_before_list->len > 0)\n          {\n            ll_t      *list = ctx_inst->opt_inst_list;\n            ll_node_t *opt_inst_node;\n\n            ll_t      *before_list = opt->eval_before_list;\n            ll_node_t *before_node = before_list->head;\n\n            ll_node_t *target_node = NULL; /* If not NULL, the new node    *\n                                            |  will be inserted before it. */\n\n            /* For each entry in eval_before_list, try to find if it       */\n            /* refers to an option already entered in the context. If this */\n            /* is the case, insert it just before it instead of putting it */\n            /* at the end.                                                 */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            while (before_node != NULL)\n            {\n              opt_inst_node = list->head;\n\n              while (opt_inst_node != target_node)\n              {\n                opt_t *tmp_opt = (((opt_inst_t *)opt_inst_node->data))->opt;\n\n                /* We have found an option mentioned if the before_list  */\n                /* of the option we want to add. We can stop searching.  */\n                /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                if (strcmp(tmp_opt->name, ((opt_t *)before_node->data)->name))\n                  opt_inst_node = opt_inst_node->next;\n                else\n                  target_node = opt_inst_node; /* Set the target node. */\n              }\n\n              before_node = before_node->next;\n            }\n\n            /* Insert or append ? */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (target_node != NULL)\n              ll_insert_before(ctx_inst->opt_inst_list, target_node, opt_inst);\n            else\n              ll_append(ctx_inst->opt_inst_list, opt_inst);\n          }\n          else\n            ll_append(ctx_inst->opt_inst_list, opt_inst);\n        }\n        else\n        {\n          ll_node_t  *opt_inst_node = ctx_inst->opt_inst_list->head;\n          opt_inst_t *tmp_opt_inst;\n\n          while (opt_inst_node != NULL)\n          {\n            tmp_opt_inst = opt_inst_node->data;\n            if (!tmp_opt_inst->opt->eval_first)\n            {\n              ll_insert_before(ctx_inst->opt_inst_list,\n                               opt_inst_node,\n                               opt_inst);\n              break;\n            }\n            else\n              opt_inst_node = opt_inst_node->next;\n          }\n          if (opt_inst_node == NULL)\n            ll_append(ctx_inst->opt_inst_list, opt_inst);\n        }\n\n        /* Check if an option was already seen in the */\n        /* current context instance.                  */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        seen_opt.opt = opt;\n\n        bst_node = bst_find(&seen_opt,\n                            &(ctx_inst->seen_opt_bst),\n                            seen_opt_compare);\n\n        /* bst_node cannot be NULL here. */\n\n        bst_seen_opt = (seen_opt_t *)(bst_node->key);\n\n        if (!opt->multiple && bst_seen_opt->seen == 1)\n          fatal(CTXOPTDUPOPT, \"\");\n\n        /* Check if this option is compatible with the options already */\n        /* seen in this context instance.                              */\n        /* Look if the option is present in one on the BST present in  */\n        /* the incomp_bst_list of the context instance.                */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        node = ctx_inst->incomp_bst_list->head;\n        while (node != NULL)\n        {\n          bst         = node->data;\n          user_object = NULL;\n\n          /* There can only have one seen_opt object in the BST tree was */\n          /* already seen, try to locate it, the result will be put in   */\n          /* user_object by the bst_seen_opt_seen_cb function.           */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          bst_walk(bst, bst_seen_opt_seen_cb);\n\n          /* If it is the case, look if the current option is also */\n          /* in this BST.                                          */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (user_object != NULL)\n          {\n            bst_node = bst_find(bst_seen_opt, &bst, seen_opt_compare);\n\n            if (bst_node != NULL)\n            {\n              bst_seen_opt = (seen_opt_t *)(bst_node->key);\n              if (bst_seen_opt->seen == 0)\n                fatal(CTXOPTINCOPT, (char *)user_object);\n            }\n          }\n\n          node = node->next;\n        }\n\n        /* Mark this option as seen in the current context instance. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        bst_seen_opt->seen = 1;\n        free(bst_seen_opt->par);\n        bst_seen_opt->par = xstrdup(par_name);\n\n        /* If this option leads to a next context, create a new ctx_inst */\n        /* and switch to it for the analyse of the future parameter.     */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (opt->next_ctx != NULL)\n        {\n          ctx = locate_ctx(opt->next_ctx);\n\n          if (ctx == NULL)\n            fatal_internal(\"Unknown context %s.\", opt->next_ctx);\n\n          opt_inst->next_ctx_inst = ctx_inst = new_ctx_inst(ctx, ctx_inst);\n          ctx_inst->par_name                 = xstrdup(par_name);\n\n          ll_append(ctx_inst_list, ctx_inst);\n\n          if (ctxopt_debug)\n            fprintf(stderr,\n                    \"CTXOPT_DEBUG: Context change, \"\n                    \"new current context: %s.\\n\",\n                    ctx->name);\n        }\n\n        /* Look is we must expect some arguments. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        expect_par_or_arg = 0;\n        expect_par        = 0;\n        expect_arg        = 0;\n\n        if (!opt->args)\n          expect_par = 1; /* Parameter doesn't accept any argument. */\n        else\n        {\n          if (!opt->optional_args)\n            expect_arg = 1; /* Parameter has mandatory arguments. */\n          else\n            expect_par_or_arg = 1; /* Parameter has optional arguments. */\n        }\n      }\n    }\n    else if (expect_par && *par_name != '-')\n    {\n      ll_node_t *n = cli_node->next;\n\n      if (!flags.stop_if_non_option)\n        /* Look if potential arguments must still be analyzed until the  */\n        /* end of the context/command line part to analyze/command line. */\n        /* If this is the case we have met an extra argument.            */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        while (n != NULL)\n        {\n          if (strcmp(n->data, \"--\") == 0 || strcmp(n->data, \"\\x1d\") == 0)\n            fatal(CTXOPTUNXARG, \"\");\n\n          if (*(char *)(n->data) == '-')\n            fatal(CTXOPTUNXARG, \"\");\n\n          n = n->next;\n        }\n\n      break; /* An unexpected non parameter was seen, if no Potential *\n              | arguments remain in the command line or               *\n              | flags.stop_if_non_option is set, assume that it is is *\n              | the first of the non arguments and stop the command   *\n              | line analysis.                                        */\n    }\n    else if (expect_arg && *par_name != '-')\n    {\n      ll_node_t    *cstr_node;\n      constraint_t *cstr;\n\n      if (ctxopt_debug)\n        fprintf(stderr, \"CTXOPT_DEBUG: Argument: %s.\\n\", par_name);\n\n      /* Check if the arguments of the option respects */\n      /* the attached constraints if any.              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      cstr_node = opt->constraints_list->head;\n      while (cstr_node != NULL)\n      {\n        cstr = cstr_node->data;\n        if (!cstr->constraint(cstr->nb_args,\n                              cstr->args,\n                              par_name,\n                              cur_state->cur_opt_par_name))\n        {\n          fputs(\"\\n\", stderr);\n          ctxopt_ctx_disp_usage(cur_state->ctx_name, exit_after);\n        }\n\n        cstr_node = cstr_node->next;\n      }\n\n      /* If the argument is valid, store it. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (*par_name == '\\\\' && *(par_name + 1) == '-')\n        ll_append(opt_inst->values_list, par_name + 1);\n      else\n        ll_append(opt_inst->values_list, par_name);\n\n      expect_arg        = 0;\n      expect_par        = 0;\n      expect_par_or_arg = 0;\n\n      if (opt->multiple_args)\n        expect_par_or_arg = 1;\n      else\n        expect_par = 1; /* Parameter takes only one argument. */\n    }\n    else if (expect_arg && *par_name == '-')\n      fatal(CTXOPTMISARG, \"\");\n    else if (expect_par_or_arg)\n    {\n      expect_arg        = 0;\n      expect_par        = 0;\n      expect_par_or_arg = 0;\n\n      if (*par_name != '-')\n        expect_arg = 1; /* Consider this word as an argument and retry. */\n      else\n        expect_par = 1; /* Consider this word as a parameter and retry. */\n\n      cli_node = cli_node->prev;\n    }\n\n    cli_node = cli_node->next;\n  }\n\n  if (cmdline_list->len > 0 && par_name && *par_name == '-')\n  {\n    if (expect_arg && opt && !opt->optional_args)\n      fatal(CTXOPTMISARG, \"\");\n  }\n\n  /* Look if a context_instance has unseen mandatory options. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node = ctx_inst_list->head;\n  while (node != NULL)\n  {\n    ctx_inst = node->data;\n\n    /* Update current_state. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    cur_state->ctx_name     = ctx_inst->ctx->name;\n    cur_state->ctx_par_name = ctx_inst->par_name;\n\n    check_for_missing_mandatory_opt(ctx_inst, par_name);\n    check_for_occurrence_issues(ctx_inst);\n    check_for_requirement_issues(ctx_inst);\n\n    node = node->next;\n  }\n\n  /* Allocate the array containing the remaining not analyzed */\n  /* command line arguments.                                  */\n  /* NOTE: The strings in the array are just pointer to the   */\n  /*       data of the generating list and must not be freed. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (cli_node != NULL)\n  {\n    if (strcmp((char *)cli_node->data, \"--\") == 0)\n      /* The special parameter -- was encountered, the -- argument is not */\n      /* put in the remaining arguments.                                  */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      ll_strarray(cmdline_list, cli_node->next, nb_rem_args, rem_args);\n    else\n      /* A non parameter was encountered when a parameter was expected. We  */\n      /* assume that the evaluation of the remaining command line  argument */\n      /* are not the responsibility of the users code.                      */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      ll_strarray(cmdline_list, cli_node, nb_rem_args, rem_args);\n  }\n  else\n  {\n    *nb_rem_args   = 0;\n    *rem_args      = xmalloc(sizeof(char *));\n    (*rem_args)[0] = NULL;\n  }\n}\n\n/* ==================================================== */\n/* Free ctxopt memory used for its internal structures. */\n/* ==================================================== */\nvoid\nctxopt_free_memory(void)\n{\n  ll_destroy(cmdline_list, free);\n  ll_destroy(ctx_inst_list, ctx_inst_free);\n  bst_destroy(options_bst, opt_free);\n  bst_destroy(contexts_bst, ctx_free);\n}\n\n/* ==================================================================== */\n/* Parse the options data structures and launches the callback function */\n/* attached to each options instances.                                  */\n/* This calls a recursive function which proceeds context per context.  */\n/* ==================================================================== */\nvoid\nctxopt_evaluate(void)\n{\n  evaluate_ctx_inst(first_ctx_inst);\n}\n\n/* =================================================================== */\n/* Recursive function called by ctxopt_evaluate to process the list of */\n/* the opt_inst present in a ctx_inst and attempt  to evaluate the     */\n/* action attached to the context and its option instances.            */\n/* =================================================================== */\nstatic void\nevaluate_ctx_inst(ctx_inst_t *ctx_inst)\n{\n  opt_inst_t *opt_inst;\n  ctx_t      *ctx;\n  opt_t      *opt;\n  ll_node_t  *opt_inst_node;\n  char      **args;\n  int         nb_args;\n\n  if (ctx_inst == NULL)\n    return;\n\n  ctx = ctx_inst->ctx;\n\n  /* Do not evaluate the action attached to this context is there is no */\n  /* option to evaluate.                                                */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  opt_inst_node = ctx_inst->opt_inst_list->head;\n  if (opt_inst_node == NULL)\n    return;\n\n  /* Call the entering action attached to this context if any. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (ctx->action != NULL)\n  {\n    if (ctx_inst->prev_ctx_inst != NULL)\n      ctx->action(ctx->name,\n                  entering,\n                  ctx_inst->prev_ctx_inst->ctx->name,\n                  ctx->nb_data,\n                  ctx->data);\n    else\n      ctx->action(ctx->name, entering, NULL, ctx->nb_data, ctx->data);\n  }\n\n  /* For each instance of options. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (opt_inst_node != NULL)\n  {\n    opt_inst = (opt_inst_t *)(opt_inst_node->data);\n    ll_strarray(opt_inst->values_list,\n                opt_inst->values_list->head,\n                &nb_args,\n                &args);\n    opt = opt_inst->opt;\n\n    /* Launch the attached action if any. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (opt->action != NULL)\n      opt->action(ctx->name,\n                  opt->name,\n                  opt_inst->par,\n                  nb_args,\n                  args,\n                  opt->nb_data,\n                  opt->data,\n                  ctx->nb_data,\n                  ctx->data);\n\n    if (opt_inst->next_ctx_inst != NULL)\n      evaluate_ctx_inst(opt_inst->next_ctx_inst);\n\n    if (args != NULL)\n      free(args);\n\n    opt_inst_node = opt_inst_node->next;\n  }\n\n  /* Call the exiting action attached to this context if any. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (ctx->action != NULL)\n  {\n    if (ctx_inst->prev_ctx_inst != NULL)\n      ctx->action(ctx->name,\n                  exiting,\n                  ctx_inst->prev_ctx_inst->ctx->name,\n                  ctx->nb_data,\n                  ctx->data);\n    else\n      ctx->action(ctx->name, exiting, NULL, ctx->nb_data, ctx->data);\n  }\n}\n\n/* ============================================================ */\n/* Create and initializes a new context.                        */\n/* - allocate space.                                            */\n/* - name it.                                                   */\n/* - initialize its option with a few of their characteristics. */\n/* ============================================================ */\nvoid\nctxopt_new_ctx(char *name, char *opts_specs)\n{\n  ctx_t *ctx;\n  char  *p;\n\n  if (!ctxopt_initialized)\n    fatal_internal(\"Please call ctxopt_init first.\");\n\n  ctx = xmalloc(sizeof(ctx_t));\n\n  /* Validates the context name: */\n  /* ALPHA+(ALPHANUM|_)*         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  p = name;\n  if (*p == '\\0' || !isalpha(*p))\n    fatal_internal(\"A context name must start with a letter: %s.\", name);\n\n  p++;\n  while (*p)\n  {\n    if (!isalnum(*p) && *p != '_')\n      fatal_internal(\"A context name must only contain letters, \"\n                     \"numbers or '_': %s.\",\n                     name);\n    p++;\n  }\n\n  ctx->name        = xstrdup(name);\n  ctx->opt_list    = ll_new(); /* List of options legit in this context.   */\n  ctx->incomp_list = ll_new(); /* List of incompatible options strings.    */\n  ctx->req_list    = ll_new(); /* List of opts/required opts tuples (str). */\n  ctx->par_bst     = NULL;\n  ctx->data        = NULL;\n  ctx->action      = NULL;\n\n  /* The first created context is the main one. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (contexts_bst == NULL)\n  {\n    main_ctx = ctx;\n\n    cur_state->ctx_name = ctx->name;\n  }\n\n  if (init_opts(opts_specs, ctx) == 0)\n    exit(EXIT_FAILURE);\n  if (bst_find(ctx, &contexts_bst, ctx_compare) != NULL)\n    fatal_internal(\"The context %s already exists.\", name);\n  else\n    bst_search(ctx, &contexts_bst, ctx_compare);\n}\n\n/* ==================================================== */\n/* Display a usage screen limited to a specific context */\n/* IN: the context name.                                */\n/* IN: what to do after (continue or exit the program)  */\n/*     possible values: continue_after, exit_after.     */\n/* ==================================================== */\nvoid\nctxopt_ctx_disp_usage(char *ctx_name, usage_behaviour action)\n{\n  ctx_t *ctx;\n  ll_t  *list;\n\n  int has_optional    = 0;\n  int has_ellipsis    = 0;\n  int has_rule        = 0;\n  int has_generic_arg = 0;\n  int has_ctx_change  = 0;\n  int has_early_eval  = 0;\n\n  if (!flags.display_usage_on_error)\n    return;\n\n  ctx = NULL;\n\n  if (ctx_name != NULL)\n    ctx = locate_ctx(ctx_name);\n  else\n    ctx = locate_ctx(cur_state->ctx_name);\n\n  if (ctx == NULL)\n    fatal_internal(\"Unknown context %s.\", ctx_name);\n\n  if (cur_state->ctx_par_name == NULL)\n    printf(\"\\nSynopsis:\\n%s \\\\\\n\", cur_state->prog_name);\n  else\n    printf(\"\\nSynopsis for the context introduced by %s:\\n\",\n           cur_state->ctx_par_name);\n\n  list = ctx->opt_list;\n  print_options(list,\n                &has_optional,\n                &has_ellipsis,\n                &has_rule,\n                &has_generic_arg,\n                &has_ctx_change,\n                &has_early_eval);\n\n  print_before_constraints(list);\n\n  print_explanations(has_early_eval,\n                     has_ctx_change,\n                     has_generic_arg,\n                     has_optional,\n                     has_ellipsis,\n                     has_rule);\n\n  if (action == exit_after)\n    exit(EXIT_FAILURE);\n}\n\n/* =================================================== */\n/* Display a full usage screen about all contexts.     */\n/* IN: what to do after (continue or exit the program) */\n/*     possible values: continue_after, exit_after.    */\n/* =================================================== */\nvoid\nctxopt_disp_usage(usage_behaviour action)\n{\n  ll_t *list;\n  int   has_optional    = 0;\n  int   has_ellipsis    = 0;\n  int   has_rule        = 0;\n  int   has_generic_arg = 0;\n  int   has_ctx_change  = 0;\n  int   has_early_eval  = 0;\n\n  if (!flags.display_usage_on_error)\n    return;\n\n  if (main_ctx == NULL)\n    fatal_internal(\"At least one context must have been created.\");\n\n  /* Usage for the first context. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  printf(\"\\nAllowed options in the base context:\\n\");\n  list = main_ctx->opt_list;\n  print_options(list,\n                &has_optional,\n                &has_ellipsis,\n                &has_rule,\n                &has_generic_arg,\n                &has_ctx_change,\n                &has_early_eval);\n\n  /* Dependency constraints between options. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  print_before_constraints(list);\n\n  /* Usage for the other contexts. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  bst_walk(contexts_bst, bst_print_ctx_cb);\n\n  /* Contextual syntactic explanations. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  print_explanations(has_early_eval,\n                     has_ctx_change,\n                     has_generic_arg,\n                     has_optional,\n                     has_ellipsis,\n                     has_rule);\n\n  if (action == exit_after)\n    exit(EXIT_FAILURE);\n}\n\n/* ************************************ */\n/* Built-in constraint check functions. */\n/* ************************************ */\n\n/* ============================================================= */\n/* This constraint checks if each arguments respects a format as */\n/* defined for the scanf function.                               */\n/* return 1 if yes and 0 if no.                                  */\n/* ============================================================= */\nint\nctxopt_format_constraint(int nb_args, char **args, char *value, char *par)\n{\n  int rc = 0;\n\n  char  x[256];\n  char  y;\n  char *format;\n\n  if (nb_args != 1)\n    fatal_internal(\"Format constraint, invalid number of parameters.\");\n\n  if (strlen(value) > 255)\n    value[255] = '\\0';\n\n  format = xstrdup(args[0]);\n  format = strappend(format, \"%c\", (char *)0);\n\n  rc = sscanf(value, format, x, &y);\n  if (rc != 1)\n    fprintf(stderr,\n            \"The argument %s of %s does not respect the imposed format %s.\",\n            value,\n            par,\n            args[0]);\n\n  free(format);\n\n  return rc == 1;\n}\n\n/* ================================================================== */\n/* This constraint checks if each arguments of the option instance is */\n/* between a minimum and a maximum (inclusive).                       */\n/* return 1 if yes and 0 if no.                                       */\n/* ================================================================== */\nint\nctxopt_re_constraint(int nb_args, char **args, char *value, char *par)\n{\n  regex_t re;\n\n  if (nb_args != 1)\n    fatal_internal(\n      \"Regular expression constraint, invalid number of parameters.\");\n\n  if (regcomp(&re, args[0], REG_EXTENDED) != 0)\n    fatal_internal(\"Invalid regular expression %s.\", args[0]);\n\n  if (regexec(&re, value, (size_t)0, NULL, 0) != 0)\n  {\n    fprintf(stderr,\n            \"The argument %s of %s doesn't match the constraining \"\n            \"regular expression %s.\",\n            value,\n            par,\n            args[0]);\n    return 0;\n  }\n\n  regfree(&re);\n\n  return 1;\n}\n\n/* ================================================================== */\n/* This constraint checks if each arguments of the option instance is */\n/* between a minimum and a maximum (inclusive).                       */\n/* return 1 if yes and 0 if no.                                       */\n/* ================================================================== */\nint\nctxopt_range_constraint(int nb_args, char **args, char *value, char *par)\n{\n  long  min = LONG_MIN, max = LONG_MAX;\n  char  c;\n  char *ptr;\n  int   n;\n  long  v;\n  int   min_only = 0;\n  int   max_only = 0;\n\n  if (nb_args != 2)\n    fatal_internal(\"Range constraint, invalid number of parameters.\");\n\n  n = 0;\n  if (strcmp(args[0], \".\") == 0)\n    max_only = 1;\n  else\n    n = sscanf(args[0], \"%ld%c\", &min, &c);\n\n  if (!max_only && n != 1)\n    fatal_internal(\"Range constraint, min: invalid parameters.\");\n\n  n = 0;\n  if (strcmp(args[1], \".\") == 0)\n    min_only = 1;\n  else\n    n = sscanf(args[1], \"%ld%c\", &max, &c);\n\n  if (!min_only && n != 1)\n    fatal_internal(\"Range constraint, max: invalid parameters.\");\n\n  if (min_only && max_only)\n    fatal_internal(\"Range constraint, invalid parameters.\");\n\n  errno = 0;\n  v     = strtol(value, &ptr, 10);\n  if (errno || ptr == value)\n    return 0;\n\n  if (min_only)\n  {\n    if (v < min)\n    {\n      fprintf(stderr,\n              \"The argument %ld of %s is not greater than or equal to %ld.\",\n              v,\n              par,\n              min);\n      return 0;\n    }\n    else\n      return 1;\n  }\n  else if (max_only)\n  {\n    if (v > max)\n    {\n      fprintf(stderr,\n              \"The argument %ld of %s is not less than or equal to %ld.\",\n              v,\n              par,\n              max);\n      return 0;\n    }\n    else\n      return 1;\n  }\n  else if (v < min || v > max)\n  {\n    fprintf(stderr,\n            \"The argument %ld of %s is not between %ld and %ld.\",\n            v,\n            par,\n            min,\n            max);\n    return 0;\n  }\n\n  return 1; /* Check passed. */\n}\n\n/* =============================================================== */\n/* This function provides a way to set the behaviour of a context. */\n/* =============================================================== */\nvoid\nctxopt_add_global_settings(settings s, ...)\n{\n  va_list(args);\n  va_start(args, s);\n\n  switch (s)\n  {\n    case error_functions:\n    {\n      typedef void fn(errors e, state_t * state);\n\n      void (*function)(errors e, state_t *state);\n\n      errors e;\n      e                = va_arg(args, errors);\n      function         = va_arg(args, fn *);\n      err_functions[e] = function;\n      break;\n    }\n\n    default:\n      break;\n  }\n  va_end(args);\n}\n\n/* ================================================================ */\n/* This function provides a way to set the behaviour of an option.  */\n/* It can take a variable number of arguments according to its      */\n/* first  argument:                                                 */\n/* - parameter:                                                     */\n/*   o a string containing an option name and all its possible      */\n/*     parameters separates by spaces, tabs or commas (char *)      */\n/*     (e.g: \"help -h -help\").                                      */\n/* - actions:                                                       */\n/*   o a string containing an option name.                          */\n/*   o a pointer to a function which will be called at evaluation   */\n/*     time.                                                        */\n/* - constraints:                                                   */\n/*   o a string containing an option name.                          */\n/*   o a pointer to a function to check if an argument is valid.    */\n/*   o a strings containing the arguments to this function.         */\n/* - visible_in_help:                                               */\n/*   o a string containing an option name.                          */\n/*   o the string \"yes\" or \"no\" (case insensitive) which will       */\n/*     determine if the option must be seen in help/usage.          */\n/* ================================================================ */\nvoid\nctxopt_add_opt_settings(settings s, ...)\n{\n  opt_t *opt;\n  void  *ptr = NULL;\n\n  va_list(args);\n  va_start(args, s);\n\n  switch (s)\n  {\n    /* This part associates some command line parameters to an option. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case parameters:\n    {\n      char *opt_name = NULL;\n      char *params;\n\n      /* The second argument must be a string containing: */\n      /* - The name of an existing option.                */\n      /* - a list of parameters with a leading dash (-).  */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr      = va_arg(args, char *);\n      opt_name = ptr;\n\n      if (opt_name != NULL)\n      {\n        if ((opt = locate_opt(opt_name)) != NULL)\n        {\n          ptr    = va_arg(args, char *);\n          params = ptr;\n\n          if (!opt_set_parms(opt_name, params))\n            fatal_internal(\n              \"Duplicated parameters or bad settings for the option %s.\",\n              params);\n        }\n        else\n          fatal_internal(\"Unknown option %s.\", opt_name);\n      }\n      else\n        fatal_internal(\n          \"ctxopt_opt_add_settings: parameters: not enough arguments.\");\n\n      /* Here opt is a known option. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (opt->params != NULL)\n        fatal_internal(\"Parameters are already set for %s.\", opt_name);\n      else\n      {\n        size_t n;\n        size_t l = strlen(params);\n\n        opt->params = xstrdup(params);\n        while ((n = strcspn(opt->params, \" \\t\")) < l)\n          opt->params[n] = '|';\n      }\n\n      break;\n    }\n\n    /* This part associates a callback function to an option.     */\n    /* This function will be called when an instance of an option */\n    /* is evaluated.                                              */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case actions:\n    {\n      void *data;\n      void (*function)();\n      int nb_data = 0;\n\n      /* The second argument must be the name of an existing option. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr = va_arg(args, char *);\n\n      if ((opt = locate_opt(ptr)) != NULL)\n      {\n        typedef void\n        fn(char *, char *, char *, int, char **, int, void *, int, void **);\n\n        /* The third argument must be the callback function. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        function    = va_arg(args, fn *);\n        opt->action = function;\n\n        /* The fourth argument must be a pointer to an user's defined   */\n        /* variable or structure that the previous function can manage. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        while ((data = va_arg(args, void *)) != NULL)\n        {\n          nb_data++;\n          opt->data = xrealloc(opt->data, nb_data * sizeof(void *));\n          opt->data[nb_data - 1] = data;\n        }\n        opt->nb_data = nb_data;\n      }\n      else\n        fatal_internal(\"Unknown option %s.\", ptr);\n      break;\n    }\n\n    /* This part associates a list of functions to control some */\n    /* characteristics of the arguments of an option.           */\n    /* Each function will be called in order and must return 1  */\n    /* to validate the arguments.                               */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case constraints:\n    {\n      char         *value;\n      constraint_t *cstr;\n      int (*function)();\n\n      /* The second argument must be a string. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr = va_arg(args, char *);\n\n      if ((opt = locate_opt(ptr)) != NULL)\n      {\n        typedef int fn(int, char **, char *);\n\n        /* The third argument must be a function. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        function = va_arg(args, fn *);\n\n        cstr             = xmalloc(sizeof(constraint_t));\n        cstr->constraint = function;\n\n        /* The fourth argument must be a string containing the argument of */\n        /* The previous function separated by spaces or tabs.              */\n        /* Theses arguments will be passed to the previous function        */\n        /* max: 32 argument!                                               */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        value = xstrdup(va_arg(args, char *));\n\n        cstr->to_free = value;\n        cstr->args    = xcalloc(sizeof(char *), 32);\n        cstr->nb_args = str2argv(value, cstr->args, 32);\n        ll_append(opt->constraints_list, cstr);\n      }\n      else\n        fatal_internal(\"Unknown option %s.\", ptr);\n      break;\n    }\n\n    /* This part allows to indicate that an option must be evaluated */\n    /* after a list of other options.                                */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case after:\n    {\n      char *str;\n\n      /* The second argument must be a string. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr = va_arg(args, char *);\n\n      if ((opt = locate_opt(ptr)) != NULL)\n      {\n        char  *end_str;\n        char  *opt_name;\n        opt_t *opt_before;\n\n        ptr = va_arg(args, char *);\n\n        str = xstrdup(ptr);\n        ltrim(str, \" \\t\");\n        rtrim(str, \" \\t\", 0);\n\n        /* Feed the list of options to be evaluated after the given option. */\n        /* This list will contain pointers to options.                      */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        opt_name = xstrtok_r(str, \" \\t,\", &end_str);\n        if (opt_name != NULL)\n        {\n          if ((opt_before = locate_opt(opt_name)) != NULL)\n          {\n            ll_append(opt->eval_before_list, opt_before);\n            while ((opt_name = xstrtok_r(NULL, \" \\t,\", &end_str)) != NULL)\n            {\n              if ((opt_before = locate_opt(opt_name)) != NULL)\n                ll_append(opt->eval_before_list, opt_before);\n              else\n                fatal_internal(\"Unknown option %s.\", opt_name);\n            }\n          }\n          else\n            fatal_internal(\"Unknown option %s.\", opt_name);\n        }\n        else\n          fatal_internal(\"Not enough options to be evaluated after %s.\",\n                         opt->name);\n\n        free(str);\n      }\n      else\n        fatal_internal(\"Unknown option %s.\", ptr);\n\n      break;\n    }\n\n    /* This part allows to indicate that an option must be evaluated */\n    /* before a list of other options.                               */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case before:\n    {\n      char *str;\n\n      /* The second argument must be a string. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr = va_arg(args, char *);\n\n      if ((opt = locate_opt(ptr)) != NULL)\n      {\n        char  *end_str;\n        char  *opt_name;\n        opt_t *opt_before;\n\n        ptr = va_arg(args, char *);\n\n        str = xstrdup(ptr);\n        ltrim(str, \" \\t\");\n        rtrim(str, \" \\t\", 0);\n\n        /* Feed the list of options to be evaluated before the given option. */\n        /* This list will contain pointers to options.                       */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        opt_name = xstrtok_r(str, \" \\t,\", &end_str);\n        if (opt_name != NULL)\n        {\n          if ((opt_before = locate_opt(opt_name)) != NULL)\n          {\n            ll_append(opt_before->eval_before_list, opt);\n            while ((opt_name = xstrtok_r(NULL, \" \\t,\", &end_str)) != NULL)\n            {\n              if ((opt_before = locate_opt(opt_name)) != NULL)\n                ll_append(opt_before->eval_before_list, opt);\n              else\n                fatal_internal(\"Unknown option %s.\", opt_name);\n            }\n          }\n          else\n            fatal_internal(\"Unknown option %s.\", opt_name);\n        }\n        else\n          fatal_internal(\"Not enough options to be evaluated before %s.\",\n                         opt->name);\n\n        free(str);\n      }\n      else\n        fatal_internal(\"Unknown option %s.\", ptr);\n\n      break;\n    }\n\n    case visible_in_help:\n    {\n      char *opt_name;\n      char *toggle;\n\n      /* The second argument must be a string containing */\n      /* The name of an existing option.                 */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr      = va_arg(args, char *);\n      opt_name = ptr;\n\n      if (opt_name != NULL)\n      {\n        if ((opt = locate_opt(opt_name)) != NULL)\n        {\n          ptr    = va_arg(args, char *);\n          toggle = ptr;\n\n          if (stricmp(toggle, \"yes\") == 0)\n            opt->visible_in_help = 1;\n          else if (stricmp(toggle, \"no\") == 0)\n            opt->visible_in_help = 0;\n          else\n            fatal_internal(\"The value for the visible_in_help setting must be \"\n                           \"\\\"yes\\\" or \\\"no\\\" (case insensitive).\",\n                           toggle);\n        }\n        else\n          fatal_internal(\"Unknown option %s.\", opt_name);\n      }\n      else\n        fatal_internal(\n          \"ctxopt_opt_add_settings: visible_in_help: not enough arguments.\");\n\n      break;\n    }\n\n    default:\n      break;\n  }\n  va_end(args);\n}\n\n/* =============================================================== */\n/* This function provides a way to set the behaviour of a context. */\n/* =============================================================== */\nvoid\nctxopt_add_ctx_settings(settings s, ...)\n{\n  ctx_t *ctx;\n\n  va_list(args);\n  va_start(args, s);\n\n  switch (s)\n  {\n    /* Add a set of mutually incompatible options in a context. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case incompatibilities:\n    {\n      void  *ptr;\n      ll_t  *list;\n      size_t n;\n      char  *str;\n\n      ptr = va_arg(args, char *);\n      if ((ctx = locate_ctx(ptr)) != NULL)\n      {\n        ptr  = va_arg(args, char *);\n        list = ctx->incomp_list;\n\n        str = xstrdup(ptr);\n        ltrim(str, \" \\t\");\n        rtrim(str, \" \\t\", 0);\n\n        n = strcspn(str, \" \\t\");\n        if (n > 0 && n < strlen(str))\n          ll_append(list, str);\n        else\n          fatal_internal(\n            \"Not enough incompatible options in the string: \\\"%s\\\".\",\n            str);\n      }\n      else\n        fatal_internal(\"Unknown context %s.\", ptr);\n      break;\n    }\n\n    case requirements:\n    {\n      void  *ptr;\n      ll_t  *list;\n      size_t n;\n      char  *str;\n\n      ptr = va_arg(args, char *);\n      if ((ctx = locate_ctx(ptr)) != NULL)\n      {\n        ptr  = va_arg(args, char *);\n        list = ctx->req_list;\n\n        str = xstrdup(ptr);\n        ltrim(str, \" \\t\");\n        rtrim(str, \" \\t\", 0);\n\n        n = strcspn(str, \" \\t\");\n        if (n > 0 && n < strlen(str))\n          ll_append(list, str);\n        else\n          fatal_internal(\"Not enough required options in the string: \\\"%s\\\".\",\n                         str);\n      }\n      else\n        fatal_internal(\"Unknown context %s.\", ptr);\n      break;\n    }\n\n    /* Add functions which will be called when */\n    /* entering and exiting a context.         */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case actions:\n    {\n      void *ptr;\n      void *data;\n      int (*function)();\n      int nb_data = 0;\n\n      ptr = va_arg(args, char *);\n      if ((ctx = locate_ctx(ptr)) != NULL)\n      {\n        typedef int fn(char *, direction, char *, int, void **);\n\n        function    = va_arg(args, fn *);\n        ctx->action = function;\n\n        while ((data = va_arg(args, void *)) != NULL)\n        {\n          nb_data++;\n          ctx->data = xrealloc(ctx->data, nb_data * sizeof(void *));\n          ctx->data[nb_data - 1] = data;\n        }\n        ctx->nb_data = nb_data;\n      }\n      else\n        fatal_internal(\"Unknown context %s.\", ptr);\n      break;\n    }\n\n    default:\n      break;\n  }\n  va_end(args);\n}\n"
        },
        {
          "name": "ctxopt.h",
          "type": "blob",
          "size": 3.0390625,
          "content": "/* ################################################################### */\n/* Copyright 2020, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef CTXOPT_H\n#define CTXOPT_H\n\ntypedef enum\n{\n  parameters,\n  constraints,\n  actions,\n  incompatibilities,\n  requirements,\n  error_functions,\n  before,\n  after,\n  visible_in_help,\n} settings;\n\ntypedef enum\n{\n  entering,\n  exiting\n} direction;\n\ntypedef enum\n{\n  CTXOPTNOERR = 0,\n  CTXOPTMISPAR,\n  CTXOPTREQPAR,\n  CTXOPTMISARG,\n  CTXOPTDUPOPT,\n  CTXOPTUNKPAR,\n  CTXOPTINCOPT,\n  CTXOPTCTEOPT,\n  CTXOPTCTLOPT,\n  CTXOPTCTGOPT,\n  CTXOPTCTEARG,\n  CTXOPTCTLARG,\n  CTXOPTCTGARG,\n  CTXOPTUNXARG,\n  CTXOPTERRSIZ\n} errors;\n\ntypedef enum\n{\n  continue_after,\n  exit_after\n} usage_behaviour;\n\ntypedef struct state_s\n{\n  char *prog_name;          /* base name of the program name.        */\n  char *ctx_name;           /* current context name.                 */\n  char *ctx_par_name;       /* parameter which led to this context.  */\n  char *opt_name;           /* current option name.                  */\n  int   opts_count;         /* limit of the number of occurrences of *\n                             |  the current option.                  */\n  int   opt_args_count;     /* limit of the number of parameters of  *\n                             |  the current option.                  */\n  char *pre_opt_par_name;   /* parameter before the current one.     */\n  char *cur_opt_par_name;   /* current parameter.                    */\n  char *cur_opt_params;     /* All the option's parameters.          */\n  char *req_opt_par_needed; /* Option's params in the missing        *\n                             | required group of optrions.           */\n  char *req_opt_par;        /* Option's params of the option which   *\n                             | required one of the parameter in      *\n                             | req_opt_par_needed to also be present *\n                             | in the current context.               */\n} state_t;\n\nvoid\nctxopt_init(char *prog_name, char *flags);\n\nvoid\nctxopt_analyze(int nb_words, char **words, int *rem_count, char ***rem_args);\n\nvoid\nctxopt_evaluate(void);\n\nvoid\nctxopt_new_ctx(char *name, char *opts_specs);\n\nvoid\nctxopt_ctx_disp_usage(char *ctx_name, usage_behaviour action);\n\nvoid\nctxopt_disp_usage(usage_behaviour action);\n\nvoid\nctxopt_add_global_settings(settings s, ...);\n\nvoid\nctxopt_add_ctx_settings(settings s, ...);\n\nvoid\nctxopt_add_opt_settings(settings s, ...);\n\nint\nctxopt_format_constraint(int nb_args, char **args, char *value, char *par);\n\nint\nctxopt_re_constraint(int nb_args, char **args, char *value, char *par);\n\nint\nctxopt_range_constraint(int nb_args, char **args, char *value, char *par);\n\nvoid\nctxopt_free_memory(void);\n\n#endif\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fgetc.c",
          "type": "blob",
          "size": 1.7255859375,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* ************************************************************************* */\n/* Custom fgetc/ungetc implementation able to unget more than one character. */\n/* ************************************************************************* */\n\n#include <stdio.h>\n#include \"fgetc.h\"\n\nenum\n{\n  GETC_BUFF_SIZE = 16\n};\n\nstatic unsigned char getc_buffer[GETC_BUFF_SIZE] = { '\\0' };\n\nstatic long next_buffer_pos = 0; /* Next free position in the getc buffer. */\n\n/* ======================================== */\n/* Gets a (possibly pushed-back) character. */\n/* ======================================== */\nint\nmy_fgetc(FILE *input)\n{\n  if (next_buffer_pos > 0)\n    return getc_buffer[--next_buffer_pos];\n  else\n  {\n    int c;\n\n    errno = 0;\n    c     = fgetc(input);\n\n    while (c == EOF && errno == EAGAIN)\n    {\n      errno = 0;\n      c     = fgetc(input);\n    }\n\n    return c;\n  }\n}\n\n/* =============================== */\n/* Pushes character back on input. */\n/* =============================== */\nint\nmy_ungetc(int c, FILE *input)\n{\n  int rc;\n\n  if (next_buffer_pos >= GETC_BUFF_SIZE)\n    rc = EOF;\n  else\n  {\n    rc = getc_buffer[next_buffer_pos++] = (unsigned char)c;\n\n    if (feof(input))\n      clearerr(input); /* No more EOF. */\n  }\n\n  return rc;\n}\n"
        },
        {
          "name": "fgetc.h",
          "type": "blob",
          "size": 0.6279296875,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef FGETC_H\n#define FGETC_H\n\n#include <errno.h>\n\nint\nmy_fgetc(FILE *input);\n\nint\nmy_ungetc(int c, FILE *input);\n\n#endif\n"
        },
        {
          "name": "index.c",
          "type": "blob",
          "size": 8.5185546875,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* ************************************************************************ */\n/* Ternary Search Tree and sorted array creation functions.                 */\n/* Inspired by a code described in \"Ternary Search Trees\" by Jon            */\n/* Bentley and Robert Sedgewick in the April, 1998, Dr. Dobb's Journal.     */\n/* Links:                                                                   */\n/*   https://www.drdobbs.com/database/ternary-search-trees/184410528?pgno=1 */\n/*   https://www.cs.princeton.edu/~rs/strings/tstdemo.c.                    */\n/* ************************************************************************ */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <wchar.h>\n#include <string.h>\n\n#include \"xmalloc.h\"\n#include \"list.h\"\n#include \"utils.h\"\n#include \"index.h\"\n\n/* List of words matching the current search. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nll_t *tst_search_list; /* Must be initialized by ll_new() before use. */\n\n/* ======================================= */\n/* Ternary search tree insertion function. */\n/* ======================================= */\ntst_node_t *\ntst_insert(tst_node_t *p, wchar_t *w, void *data)\n{\n  if (p == NULL)\n  {\n    p            = (tst_node_t *)xmalloc(sizeof(tst_node_t));\n    p->splitchar = *w;\n    p->lokid = p->eqkid = p->hikid = NULL;\n    p->data                        = NULL;\n  }\n\n  if (*w < p->splitchar)\n    p->lokid = tst_insert(p->lokid, w, data);\n  else if (*w == p->splitchar)\n  {\n    if (*w == L'\\0')\n    {\n      p->data  = data;\n      p->eqkid = NULL;\n    }\n    else\n      p->eqkid = tst_insert(p->eqkid, w + 1, data);\n  }\n  else\n    p->hikid = tst_insert(p->hikid, w, data);\n\n  return (p);\n}\n\n/* ====================================== */\n/* Ternary search tree deletion function. */\n/* User data area not cleaned.            */\n/* ====================================== */\nvoid\ntst_cleanup(tst_node_t *p)\n{\n  if (p != NULL)\n  {\n    tst_cleanup(p->lokid);\n    if (p->splitchar != L'\\0')\n      tst_cleanup(p->eqkid);\n    tst_cleanup(p->hikid);\n    free(p);\n  }\n}\n\n/* ========================================================== */\n/* Recursive traversal of a ternary tree. A callback function */\n/* is also called when a complete string is found.            */\n/* Returns 1 if the callback function succeed (returned 1) at */\n/* least once.                                                */\n/* The first_call argument is for initializing the static     */\n/* variable.                                                  */\n/* ========================================================== */\nint\ntst_traverse(tst_node_t *p, int (*callback)(void *), int first_call)\n{\n  static int rc;\n\n  if (first_call)\n    rc = 0;\n\n  if (p == NULL)\n    return 0;\n  tst_traverse(p->lokid, callback, 0);\n  if (p->splitchar != L'\\0')\n    tst_traverse(p->eqkid, callback, 0);\n  else\n    rc += (*callback)(p->data);\n  tst_traverse(p->hikid, callback, 0);\n\n  return !!rc;\n}\n\n/* ======================================================================= */\n/* Traverses the word tst looking for a wchar and build a list of pointers */\n/* containing all the sub-tst potentially leading to words containing the  */\n/* next wchar of the search string.                                        */\n/* ======================================================================= */\nint\ntst_substring_traverse(tst_node_t *p,\n                       int (*callback)(void *),\n                       int     first_call,\n                       wchar_t w)\n{\n  static int rc;\n\n  if (first_call)\n    rc = 0;\n\n  if (p == NULL)\n    return 0;\n\n  if (p->splitchar == w)\n  {\n    ll_node_t *node;\n    sub_tst_t *sub_tst_data;\n\n    node         = tst_search_list->tail;\n    sub_tst_data = (sub_tst_t *)(node->data);\n\n    if (p->eqkid != NULL)\n      insert_sorted_ptr(&(sub_tst_data->array),\n                        &(sub_tst_data->size),\n                        &(sub_tst_data->count),\n                        p->eqkid);\n\n    rc = 1;\n  }\n\n  tst_substring_traverse(p->lokid, callback, 0, w);\n  if (p->splitchar != L'\\0')\n    tst_substring_traverse(p->eqkid, callback, 0, w);\n  else if (callback != NULL)\n    rc += (*callback)(p->data);\n  tst_substring_traverse(p->hikid, callback, 0, w);\n\n  return !!rc;\n}\n\n/* ======================================================================== */\n/* Traverses the word tst looking for a wchar and build a list of pointers  */\n/* containing all the sub-tst nodes potentially leading to words containing */\n/* the next wchar os the search string.                                     */\n/* ======================================================================== */\nint\ntst_fuzzy_traverse(tst_node_t *p,\n                   int (*callback)(void *),\n                   int     first_call,\n                   wchar_t w)\n{\n  static int rc;\n  wchar_t    w1s[2];\n  wchar_t    w2s[2];\n\n  w1s[1] = w2s[1] = L'\\0';\n\n  if (first_call)\n    rc = 0;\n\n  if (p == NULL)\n    return 0;\n\n  w1s[0] = p->splitchar;\n  w2s[0] = w;\n\n  if (my_wcscasecmp(w1s, w2s) == 0)\n  {\n    ll_node_t *node;\n    sub_tst_t *sub_tst_data;\n\n    node         = tst_search_list->tail;\n    sub_tst_data = (sub_tst_t *)(node->data);\n\n    if (p->eqkid != NULL)\n      insert_sorted_ptr(&(sub_tst_data->array),\n                        &(sub_tst_data->size),\n                        &(sub_tst_data->count),\n                        p->eqkid);\n\n    rc += 1;\n  }\n\n  tst_fuzzy_traverse(p->lokid, callback, 0, w);\n  if (p->splitchar != L'\\0')\n    tst_fuzzy_traverse(p->eqkid, callback, 0, w);\n  else if (callback != NULL)\n    rc += (*callback)(p->data);\n  tst_fuzzy_traverse(p->hikid, callback, 0, w);\n\n  return !!rc;\n}\n\n/* ======================================================================= */\n/* Searches a complete string in a ternary tree starting from a root node. */\n/* ======================================================================= */\nvoid *\ntst_search(tst_node_t *root, wchar_t *w)\n{\n  tst_node_t *p;\n\n  p = root;\n\n  while (p)\n  {\n    if (*w < p->splitchar)\n      p = p->lokid;\n    else if (*w == p->splitchar)\n    {\n      if (*w++ == L'\\0')\n        return p->data;\n      p = p->eqkid;\n    }\n    else\n      p = p->hikid;\n  }\n\n  return NULL;\n}\n\n/* ============================================================== */\n/* Searches all strings beginning with the same prefix.           */\n/* the callback function will be applied to each of these strings */\n/* returns NULL if no string matched the prefix.                  */\n/* ============================================================== */\nvoid *\ntst_prefix_search(tst_node_t *root, wchar_t *w, int (*callback)(void *))\n{\n  tst_node_t *p   = root;\n  size_t      len = wcslen(w);\n  size_t      rc;\n\n  while (p)\n  {\n    if (*w < p->splitchar)\n      p = p->lokid;\n    else if (*w == p->splitchar)\n    {\n      len--;\n      if (*w++ == L'\\0')\n        return p->data;\n      if (len == 0)\n      {\n        rc = tst_traverse(p->eqkid, callback, 1);\n        return (void *)(long)rc;\n      }\n      p = p->eqkid;\n    }\n    else\n      p = p->hikid;\n  }\n\n  return NULL;\n}\n\n/* ========================================================= */\n/* Insertion of an pointer in a already sorted pointer array */\n/* without duplications.                                     */\n/* ========================================================= */\nvoid\ninsert_sorted_ptr(tst_node_t ***array_ptr,\n                  long         *size,\n                  long         *nb,\n                  tst_node_t   *ptr)\n{\n  long pos  = *nb;\n  long left = 0, right = *nb, middle;\n\n  if (*nb > 0)\n  {\n    /* Bisection search. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while (left < right)\n    {\n      middle = (left + right) / 2;\n      if ((intptr_t)((*array_ptr)[middle]) == (intptr_t)ptr)\n        return; /* Value already in array. */\n\n      if ((intptr_t)ptr < (intptr_t)((*array_ptr)[middle]))\n        right = middle;\n      else\n        left = middle + 1;\n    }\n    pos = left;\n  }\n\n  if (*nb == *size)\n  {\n    *size += 64;\n    *array_ptr = xrealloc(*array_ptr, *size * sizeof(long));\n  }\n\n  if (*nb > pos)\n    memmove((*array_ptr) + pos + 1,\n            (*array_ptr) + pos,\n            sizeof(ptr) * (*nb - pos));\n\n  (*nb)++;\n\n  (*array_ptr)[pos] = ptr;\n}\n"
        },
        {
          "name": "index.h",
          "type": "blob",
          "size": 2.0771484375,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef INDEX_H\n#define INDEX_H\n\n/* *************************************** */\n/* Ternary Search Tree specific structures */\n/* *************************************** */\n\ntypedef struct tst_node_s tst_node_t;\ntypedef struct sub_tst_s  sub_tst_t;\n\n#if 0 /* here for coherency but not used. */\nvoid tst_cleanup(tst_node_t * p);\n#endif\n\ntst_node_t *\ntst_insert(tst_node_t *p, wchar_t *w, void *data);\n\nvoid *\ntst_prefix_search(tst_node_t *root, wchar_t *w, int (*callback)(void *));\n\nvoid *\ntst_search(tst_node_t *root, wchar_t *w);\n\nint\ntst_traverse(tst_node_t *p, int (*callback)(void *), int first_call);\n\nint\ntst_substring_traverse(tst_node_t *p,\n                       int (*callback)(void *),\n                       int     first_call,\n                       wchar_t w);\nint\ntst_fuzzy_traverse(tst_node_t *p,\n                   int (*callback)(void *),\n                   int     first_call,\n                   wchar_t w);\n\nsub_tst_t *\nsub_tst_new(void);\n\nvoid\ninsert_sorted_ptr(tst_node_t ***array,\n                  long         *size,\n                  long         *filled,\n                  tst_node_t   *ptr);\n\n/* Ternary node structure */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct tst_node_s\n{\n  tst_node_t *lokid, *eqkid, *hikid;\n  void       *data;\n  wchar_t     splitchar;\n};\n\n/* Structure to contain data and metadata attached to a fuzzy/substring. */\n/* search step.                                                          */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct sub_tst_s\n{\n  tst_node_t **array;\n  long         size;\n  long         count;\n};\n\n#endif\n"
        },
        {
          "name": "list.c",
          "type": "blob",
          "size": 8.0859375,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* ********************************************************************* */\n/* Tiny linked list implementation.                                      */\n/*                                                                       */\n/* Each node contain a void pointer to some opaque data, these functions */\n/* will not try to allocate or free this data pointer.                   */\n/*                                                                       */\n/* Also accessors are not provided, the user has to directly manipulate  */\n/* the structure members (head, tail, len, data, prev, next).            */\n/* ********************************************************************* */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"xmalloc.h\"\n#include \"list.h\"\n\nstatic ll_node_t *\nll_partition(ll_node_t *l,\n             ll_node_t *h,\n             int (*comp)(void const *, void const *),\n             void (*swap)(void **, void **));\n\nstatic void\nll_quicksort(ll_node_t *l,\n             ll_node_t *h,\n             int (*comp)(void const *, void const *),\n             void (*swap)(void **, void **));\n\n/* ========================== */\n/* Creates a new linked list. */\n/* ========================== */\nll_t *\nll_new(void)\n{\n  ll_t *ret = xmalloc(sizeof(ll_t));\n  ll_init(ret);\n\n  return ret;\n}\n\n/* ========================== */\n/* Initializes a linked list. */\n/* ========================== */\nvoid\nll_init(ll_t *list)\n{\n  list->head = NULL;\n  list->tail = NULL;\n  list->len  = 0;\n}\n\n/* ====================================================== */\n/* Allocates the space for a new node in the linked list. */\n/* ====================================================== */\nll_node_t *\nll_new_node(void)\n{\n  return xmalloc(sizeof(ll_node_t));\n}\n\n/* ====================================================================== */\n/* Appends a new node filled with its data at the end of the linked list. */\n/* The user is responsible for the memory management of the data.         */\n/*                                                                        */\n/* Note: list is assumed to be initialized by ll_new().                   */\n/* ====================================================================== */\nvoid\nll_append(ll_t * const list, void * const data)\n{\n  ll_node_t *node;\n\n  node = ll_new_node(); /* ll_new_node cannot return NULL because it   *\n                         | uses xmalloc which does not return if there *\n                         | is an allocation error.                     */\n\n  node->data = data;\n  node->next = NULL;       /* This node will be the last. */\n  node->prev = list->tail; /* NULL if it is a new list.   */\n\n  if (list->tail != NULL)\n    list->tail->next = node;\n  else\n    list->head = node;\n\n  list->tail = node;\n\n  ++list->len; /* One more node in the list. */\n}\n\n/* ================================== */\n/* Removes a node from a linked list. */\n/* ================================== */\nint\nll_delete(ll_t * const list, ll_node_t *node)\n{\n  if (list->head == list->tail)\n  {\n    /* We delete the last remaining element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (list->head == NULL)\n      return 0;\n\n    list->head = list->tail = NULL;\n  }\n  else if (node->prev == NULL)\n  {\n    /* We delete the first element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    list->head       = node->next;\n    list->head->prev = NULL;\n  }\n  else if (node->next == NULL)\n  {\n    /* We delete the last element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    list->tail       = node->prev;\n    list->tail->next = NULL;\n  }\n  else\n  {\n    /* We delete an element from the list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    node->next->prev = node->prev;\n    node->prev->next = node->next;\n  }\n\n  free(node);\n\n  --list->len; /* One less node in the list. */\n\n  return 1;\n}\n\n/* ====================================================== */\n/* Partition code for the quicksort function.             */\n/* Based on code found here:                              */\n/* http://www.geeksforgeeks.org/quicksort-for-linked-list */\n/* ====================================================== */\nstatic ll_node_t *\nll_partition(ll_node_t *l,\n             ll_node_t *h,\n             int (*comp)(void const *, void const *),\n             void (*swap)(void **, void **))\n{\n  /* Considers last element as pivot, places the pivot element at its       */\n  /* correct position in sorted array, and places all smaller (smaller than */\n  /* pivot) to left of pivot and all greater elements to right of pivot.    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  /* Set pivot as h element. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  void *x = h->data;\n\n  ll_node_t *i = l->prev;\n  ll_node_t *j;\n\n  for (j = l; j != h; j = j->next)\n  {\n    if (comp(j->data, x) < 1)\n    {\n      i = (i == NULL) ? l : i->next;\n\n      swap(&(i->data), &(j->data));\n    }\n  }\n\n  i = (i == NULL) ? l : i->next;\n  swap(&(i->data), &(h->data));\n\n  return i;\n}\n\n/* ======================================================== */\n/* A recursive implementation of quicksort for linked list. */\n/* Based on code found here:                                */\n/* http://www.geeksforgeeks.org/quicksort-for-linked-list   */\n/* ======================================================== */\nstatic void\nll_quicksort(ll_node_t *l,\n             ll_node_t *h,\n             int (*comp)(void const *, void const *),\n             void (*swap)(void **, void **))\n{\n  if (h != NULL && l != h && l != h->next)\n  {\n    ll_node_t *p = ll_partition(l, h, comp, swap);\n    ll_quicksort(l, p->prev, comp, swap);\n    ll_quicksort(p->next, h, comp, swap);\n  }\n}\n\n/* ============================ */\n/* A linked list sort function. */\n/* ============================ */\nvoid\nll_sort(ll_t *list,\n        int (*comp)(void const *, void const *),\n        void (*swap)(void **, void **))\n{\n  /* Call the recursive ll_quicksort function. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ll_quicksort(list->head, list->tail, comp, swap);\n}\n\n/* ==========================================================================*/\n/* Finds a node in the list containing data. Return the node pointer or NULL */\n/* if not found.                                                             */\n/* A comparison function must be provided to compare a and b (strcmp like).  */\n/* ==========================================================================*/\nll_node_t *\nll_find(ll_t * const list,\n        void * const data,\n        int (*cmpfunc)(const void *, const void *))\n{\n  ll_node_t *node;\n\n  if (NULL == (node = list->head))\n    return NULL;\n\n  do\n  {\n    if (0 == cmpfunc(node->data, data))\n      return node;\n  } while (NULL != (node = node->next));\n\n  return NULL;\n}\n\n/* =============================================== */\n/* Free all the elements of a list (make it empty) */\n/* NULL or a custom function may be used to free   */\n/* the sub components of the elements.             */\n/* =============================================== */\nvoid\nll_free(ll_t * const list, void (*clean)(void *))\n{\n  if (list != NULL)\n  {\n    ll_node_t *node = list->head;\n\n    while (node)\n    {\n      /* Apply a custom cleaner if not NULL. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (clean)\n        clean(node->data);\n\n      ll_delete(list, node);\n\n      node = list->head;\n    }\n  }\n}\n\n/* ==================================== */\n/* Destroy a list and all its elements. */\n/* ==================================== */\nvoid\nll_destroy(ll_t *list, void (*clean)(void *))\n{\n  if (list != NULL)\n  {\n    ll_free(list, clean);\n    free(list);\n  }\n}\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 1.501953125,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef LIST_H\n#define LIST_H\n\ntypedef struct ll_node_s ll_node_t;\ntypedef struct ll_s      ll_t;\n\n/* ******************************* */\n/* Linked list specific structures */\n/* ******************************* */\n\n/* Linked list node structure */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ll_node_s\n{\n  void             *data;\n  struct ll_node_s *next;\n  struct ll_node_s *prev;\n};\n\n/* Linked List structure */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ll_s\n{\n  ll_node_t *head;\n  ll_node_t *tail;\n  long       len;\n};\n\nll_t *\nll_new(void);\n\nvoid\nll_init(ll_t *list);\n\nll_node_t *\nll_new_node(void);\n\nvoid\nll_append(ll_t * const list, void * const data);\n\nvoid\nll_sort(ll_t *list,\n        int (*comp)(void const *, void const *),\n        void (*swap)(void **, void **));\n\nint\nll_delete(ll_t * const list, ll_node_t *node);\n\nll_node_t *\nll_find(ll_t * const, void * const, int (*)(void const *, void const *));\n\nvoid\nll_free(ll_t * const list, void (*clean)(void *));\n\nvoid\nll_destroy(ll_t *list, void (*clean)(void *));\n\n#endif\n"
        },
        {
          "name": "safe.c",
          "type": "blob",
          "size": 1.5166015625,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* ************************************ */\n/* Some wrappers to manage EINTR errors */\n/* ************************************ */\n\n#include <stdio.h>\n#include <termios.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#include \"safe.h\"\n\nFILE *\nfopen_safe(const char * restrict stream, const char * restrict mode)\n{\n  FILE *file;\n\n  while ((file = fopen(stream, mode)) == NULL && errno == EINTR)\n    ;\n\n  return file;\n}\n\nint\ntcsetattr_safe(int                   fildes,\n               int                   optional_actions,\n               const struct termios *termios_p)\n{\n  int res;\n\n  while ((res = tcsetattr(fildes, optional_actions, termios_p)) == -1\n         && errno == EINTR)\n    ;\n\n  return res;\n}\n\nint\nfputc_safe(int c, FILE *stream)\n{\n  int res;\n\n  while ((res = fputc(c, stream)) == -1 && errno == EINTR)\n    ;\n\n  return res;\n}\n\nint\nfputs_safe(const char * restrict s, FILE * restrict stream)\n{\n  int res;\n\n  while ((res = fputs(s, stream)) == -1 && errno == EINTR)\n    ;\n\n  return res;\n}\n"
        },
        {
          "name": "safe.h",
          "type": "blob",
          "size": 0.8720703125,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef SAFE_H\n#define SAFE_H\n\nint\nfputs_safe(const char * restrict s, FILE * restrict stream);\n\nint\nfputc_safe(int c, FILE *stream);\n\nint\ntcsetattr_safe(int                   fildes,\n               int                   optional_actions,\n               const struct termios *termios_p);\n\nFILE *\nfopen_safe(const char * restrict stream, const char * restrict mode);\n\n#endif\n"
        },
        {
          "name": "simple_menu.gif",
          "type": "blob",
          "size": 128.6142578125,
          "content": null
        },
        {
          "name": "smenu.1",
          "type": "blob",
          "size": 85.5927734375,
          "content": ".\\\" ###################################################################\n.\\\" Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)\n.\\\"\n.\\\" This Source Code Form is subject to the terms of the Mozilla Public\n.\\\" License, v. 2.0. If a copy of the MPL was not distributed with this\n.\\\" file, You can obtain one at https://mozilla.org/MPL/2.0/.\n.\\\" ###################################################################\n.TH smenu 1\n.SH NAME\nsmenu - filter that allows one to interactively select a word from stdin\nand outputs the selection to stdout.\n.SH SYNOPSIS\n.nf\n  [\\fB*-h\\fP|\\fB-help\\fP]\n  [\\fB*-H\\fP|\\fB-long_help\\fP]\n  [\\fB*-?\\fP|\\fB-u\\fP|\\fB-usage\\fP]\n  [\\fB*-V\\fP|\\fB-version\\fP]\n  [\\fB-n\\fP|\\fB-lines\\fP|\\fB-height\\fP [\\fIheight\\fP]]\n  [\\fB-i\\fP|\\fB-in\\fP|\\fB-inc\\fP|\\fB-incl\\fP|\\fB-include\\fP... \\fIregex\\fP]\n  [\\fB-e\\fP|\\fB-ex\\fP|\\fB-exc\\fP|\\fB-excl\\fP|\\fB-exclude\\fP... \\fIregex\\fP]\n  [\\fB-m\\fP|\\fB-msg\\fP|\\fB-message\\fP|\\fB-title\\fP \\fImessage\\fP]\n  [\\fB-!\\fP|\\fB-int\\fP|\\fB-int_string\\fP [\\fIstring\\fP]]\n  [\\fB-a\\fP|\\fB-attr\\fP|\\fB-attributes\\fP \\fIprefix:attr\\fP...]\n  [\\fB-1\\fP|\\fB-l1\\fP|\\fB-level1\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-2\\fP|\\fB-l2\\fP|\\fB-level2\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-3\\fP|\\fB-l3\\fP|\\fB-level3\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-4\\fP|\\fB-l4\\fP|\\fB-level4\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-5\\fP|\\fB-l5\\fP|\\fB-level5\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-6\\fP|\\fB-l6\\fP|\\fB-level6\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-7\\fP|\\fB-l7\\fP|\\fB-level7\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-8\\fP|\\fB-l8\\fP|\\fB-level8\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-9\\fP|\\fB-l9\\fP|\\fB-level9\\fP \\fIregex\\fP [\\fIattr\\fP]]\n  [\\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP [\\fIdelim\\fP]]\n  [\\fB-z\\fP|\\fB-zap\\fP|\\fB-zap_glyphs\\fP \\fIbytes\\fP]\n  [\\fB-P\\fP|\\fB-pm\\fP|\\fB-pin\\fP|\\fB-pin_mode\\fP [\\fIdelim\\fP]]\n  [\\fB-0\\fP|\\fB-noat\\fP|\\fB-no_auto_tag\\fP]\n  [\\fB-p\\fP|\\fB-at\\fP|\\fB-auto_tag\\fP]\n  [\\fB-N\\fP|\\fB-number\\fP... [\\fIregex\\fP...]]\n  [\\fB-U\\fP|\\fB-unnumber\\fP... [\\fIregex\\fP...]]\n  [\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP]\n  [\\fB-D\\fP|\\fB-data\\fP|\\fB-options\\fP [\\fIparameter\\fP...]\n  [\\fB-b\\fP|\\fB-blank\\fP]\n  [\\fB-M\\fP|\\fB-middle\\fP|\\fB-center\\fP]\n  [\\fB-d\\fP|\\fB-restore\\fP|\\fB-delete\\fP|\\fB-clean\\fP|\\\n\\fB-delete_window\\fP|\\fB-clean_window\\fP]\n  [\\fB-c\\fP|\\fB-col\\fP|\\fB-col_mode\\fP|\\fB-column\\fP]\n  [\\fB-l\\fP|\\fB-line\\fP|\\fB-line_mode\\fP]\n  [\\fB-t\\fP|\\fB-tab\\fP|\\fB-tab_mode\\fP|\\fB-tabulate_mode\\fP [\\fIcols\\fP]]\n  [\\fB-w\\fP|\\fB-wide\\fP|\\fB-wide_mode\\fP]\n  [\\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP... \\\n[\\fIdirective\\fP][\\fIselector\\fP...]]\n  [\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP... \\\n[\\fIdirective\\fP][\\fIselector\\fP...]]\n  [\\fB-al\\fP|\\fB-align\\fP... [\\fIre_selectors\\fP...]]\n  [\\fB-A\\fP|\\fB-fc\\fP|\\fB-first_column\\fP \\fIregex\\fP]\n  [\\fB-Z\\fP|\\fB-lc\\fP|\\fB-last_column\\fP \\fIregex\\fP]\n  [\\fB-g\\fP|\\fB-gutter\\fP [\\fIstring\\fP]]\n  [\\fB-k\\fP|\\fB-ks\\fP|\\fB-keep_spaces\\fP]\n  [\\fB-W\\fP|\\fB-ws\\fP|\\fB-wd\\fP|\\fB-word_delimiters\\fP|\\\n\\fB-word_separators\\fP \\\n\\fIbytes\\fP]\n  [\\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\\n\\fB-line_separators\\fP \\\n\\fIbytes\\fP]\n  [\\fB-q\\fP|\\fB-no_bar\\fP|\\fB-no_scroll_bar\\fP]\n  [\\fB-no_hbar\\fP|\\fB-no_hor_scroll_bar\\fP]\n  [\\fB-hbar\\fP|\\fB-hor_scroll_bar\\fP]\n  [\\fB-S\\fP|\\fB-subst\\fP... \\fI/regex/repl/opts\\fP]\n  [\\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP... \\fI/regex/repl/opts\\fP]\n  [\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP... \\fI/regex/repl/opts\\fP]\n  [\\fB-ES\\fP|\\fB-early_subst\\fP... \\fI/regex/repl/opts\\fP]\n  [\\fB-/\\fP|\\fB-search_method\\fP \\fIprefix\\fP|\\fIsubstring\\fP|\\fIfuzzy\\fP]\n  [\\fB-s\\fP|\\fB-sp\\fP|\\fB-start\\fP|\\fB-start_pattern\\fP \\fIpattern\\fP]\n  [\\fB-x\\fP|\\fB-tmout\\fP|\\fB-timeout\\fP \\fItype\\fP [\\fIword\\fP] \\fIdelay\\fP]\n  [\\fB-X\\fP|\\fB-htmout\\fP|\\fB-hidden_timeout\\fP \\fItype\\fP [\\fIword\\fP] \\\n\\fIdelay\\fP]\n  [\\fB-r\\fP|\\fB-auto_validate\\fP]\n  [\\fB-is\\fP|\\fB-incremental_search\\fP]\n  [\\fB-v\\fP|\\fB-vb\\fP|\\fB-visual_bell\\fP]\n  [\\fB-Q\\fP|\\fB-ignore_quotes\\fP]\n  [\\fB-lim\\fP|\\fB-limits\\fP \\fIlimit:value\\fP...]\n  [\\fB-f\\fP|\\fB-forgotten_timeout\\fP|\\fB-global_timeout\\fP \\fItimeout\\fP]\n  [\\fB-nm\\fP|\\fB-no_mouse\\fP]\n  [\\fB-br\\fP|\\fB-buttons\\fP|\\fB-button_remapping\\fP \\fInew_button_1\\fP \\\n\\fInew_button_3\\fP]\n  [\\fB-dc\\fP|\\fB-dcd\\fP|\\fB-double_click\\fP|\\fB-double_click_delay\\fP \\\n\\fIdelay_in_ms\\fP]\n  [\\fB-sb\\fP|\\fB-sbw\\fP|\\fB-show_blank_words\\fP [\\fIblank_char\\fP]]\n\n\n  selectors    ::= See the \\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP description for \\\nmore details.\n  re_selectors ::= \\fIRE\\fP,...\n  directive    ::= \\fIi\\fP|\\fII\\fP|\\fIe\\fP|\\fIE\\fP|\\\n\\fIl\\fP|\\fIL\\fP|\\fIr\\fP|\\fIR\\fP|\\fIc\\fP|\\fIC\\fP\n  parameter    ::= [l|r:<char>]|[a:left|right]|[p:included|all|[w:<num>]|\n                [f:yes|no]|[o:<num>[+]]|[n:<num>]|[i:<num>]|[d:<char>]|\n                [s:<num>]|[h:trim|cut|keep]\n  attr         ::= [fg][/bg][,style]\n  RE           ::= \\fB<char>\\fIregex\\fB<char>\\fR\n\n  selectors and RE can be freely mixed.\n  style can only contain a maximum of 6 characters.\n  <char> in RE is any non-blank ASCII character except ','.\n.fi\n\nNote that some parameters require that others have been previously\nentered in the command line to be accepted.\n.SH DESCRIPTION\nThis small utility acts as a filter when no input file is given\n(reads from stdin and writes to stdout) or takes its inputs from that file.\n\nAll words read are presented in a scrolling window on the terminal \\fBat\nthe current cursor position\\fP, without clearing the screen first.\n.PP\nThe selection cursor is initially positioned on the first selectable word\nby default.\n.PP\nIn this window, words can be displayed next to each other, with a fixed\nsize, or in rows or columns respecting the line ends as input.\nIn column mode, words can also be centred, left aligned or right aligned.\nSee the options \\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP,\n\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP and\n\\fB-al\\fP|\\fB-align\\fP for more information.\n.PP\nThere are options to explicitly or implicitly include/exclude or align words\nusing extended regular expressions.\nNote that once certain words are explicitly excluded, they cannot be\nre-included later.\n.PP\nExcluded words are skipped when the selection cursor is moved and cannot\nbe searched for.\n.PP\nThe \\fB-W\\fP|\\fB-ws\\fP|\\fB-wd\\fP|\\fB-word_delimiters\\fP|\\fB-word_separators\\fP\noption can be used to set the characters (or multibyte\nsequences) which will be used to delimit the input words.\nThe default delimiters are: \\fISPACE\\fP, \\fI\\\\t\\fP and \\fI\\\\n\\fP.\n.PP\nThe\n\\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\fB-line_separators\\fP\nhas a similar meaning for lines.\n\nSpecial character sequences formed by a \\fI\\\\\\fP followed by one of the\ncharacters \\fIa\\fP \\fIb\\fP \\fIt\\fP \\fIn\\fP \\fIv\\fP \\fIf\\fP \\fIr\\fP and\n\\fI\\\\\\fP are understood and have their traditional meanings.\n\nsmenu strives to support UTF-8 encoding, both as input and output.\n\\fBUTF-8\\fP sequences introduced by \\fI\\\\u\\fP and \\fI\\\\U\\fP are also\nunderstood.\n\n\\fBWarning\\fP, when used together, it is important to know that all\nsequences beginning with \\fI\\\\U\\fP will be interpreted before the\nbeginning of the interpretation of sequences beginning with \\fI\\\\u\\fP.\n\n\\fI\\\\u\\fP can be followed by 2,4,6 or 8 hexadecimal characters composing\nan \\fBUTF-8\\fP bytestring.\nHere is an example of using \\fI\\\\u\\fP to compose a \\fBLatin Small Letter E\nwith Acute\\fP: \\fI\\\\uc3a9\\fP.\n\n\\fI\\\\U\\fP must be followed by exactly 6 hexadecimal digits, \\fBincluding\\fP\nleading zeros, that represent a Unicode codepoint according to ISO\n10646 UCS-4.\nThe \\fBLatin Small Letter E with Acute\\fP of the previous example\n(codepoint \\fBU+00E9\\fP) can then be represented as \\fI\\\\U0000e9\\fP.\n.PP\nNote that with most shells, the \\fI\\\\\\fP before \\fIu\\fP and \\fIU\\fP\nneed to be protected or escaped.\n.PP\nQuotations (single and double) in the input stream can be used to ignore\nthe word separators so that a group of words are taken as a single entity.\n.PP\nNon printable characters in words that are not delimiters are\nconverted to their traditional form (\\fI\\\\n\\fP for end-of-line,\n\\fI\\\\t\\fP for tabulation...) by default.\n.PP\nAn invalid \\fBUTF-8\\fP sequence or other non-printable character will be\nreplaced by a dot (\\fI.\\fP) by default.\n.PP\nThere is nevertheless a possibility to change this substitution character\nwith another \\fBASCII\\fP printable one with the help of the command line\noption \\fB-.\\fP|\\fB-dot\\fP|\\fB-invalid\\fP.\n.PP\n\\fBWarning\\fP, \\fBUTF-8\\fP encoded codepoints are quietly converted\ninto the substitution character when the user locale is not \\fBUTF-8\\fP\naware like \\fBPOSIX\\fP or \\fBC\\fP by example.\n.PP\nWords containing only spaces, entered directly or resulting from a\nsubstitution, are also rejected unless they are not selectable.\nThis allows special effects like creating blank lines for example.\nThese words are also kept in column mode, selectable or not.\n.PP\nsmenu has an option to define a set of characters or \\fBUTF-8\\fP sequences\nwhich should be ignored when reading words.\nThis can be very useful when dealing with inputs where the EOL sequence\nconsists in more than one character.\n.PP\nA typical example is DOS or Windows files with lines ending with\n\\fICRLF\\fP.\nIn such a case one might decide to ignore all \\fICR\\fP characters from\nthe input.\n.PP\n.SS \"Keyboard and mouse usage.\"\n\\fBkeyboard\\fP:\n.RS 2\nThe cursor can be moved in any direction using the arrow keys of the\nkeyboard: \\fB\\(<-\\fP, \\fB\\(da\\fP, \\fB\\(ua\\fP, \\fB\\(->\\fP\nor the \\fIvi\\fP direction keys: \\fBh\\fP, \\fBj\\fP, \\fBk\\fP and \\fBl\\fP.\nThe \\fBHOME\\fP, \\fBEND\\fP, \\fBPgDn\\fP and \\fBPgUp\\fP keys can also be\nused when available.\n\nThe meaning of the movement keys is as follows:\n.TS\ntab(@);\nl l.\n\\fB\\(<-\\fP, \\fBh\\fP@Previous word\n\\fBSHIFT\\ HOME\\fP, \\fBCTRL\\ \\(<-\\fP, \\fBH\\fP@Start of line in column or line mode\n\\fB\\(ua\\fP, \\fBk\\fP@Previous line\n\\fBPgUp\\fP, \\fBK\\fP@Previous page\n\\fBHOME\\fP@First word of the window\n\\fBCTRL\\ HOME\\fP, \\fBCTRL\\ K\\fP@First word\n\\fB<\\fP@The window's content is shifted to the\n@left while keeping the cursor visible\n\n\\fB\\(->\\fP, \\fBl\\fP@Next word\n\\fBSHIFT\\ END\\fP, \\fBCTRL\\ \\(->\\fP, \\fBL\\fP@End of line in column or line mode\n\\fB\\(da\\fP, \\fBj\\fP@Next line\n\\fBPgDn\\fP, \\fBJ\\fP@Next page\n\\fBEND\\fP@Last word of the window\n\\fBCTRL\\ END\\fP, \\fBCTRL\\ J\\fP@Last word\n\\fB>\\fP@The window's content is shifted to the\n@right while keeping the cursor visible\n.TE\n\n\\fBCTRL\\ \\(<-\\fP/\\fBH\\fP (resp. \\fBCTRL\\ \\(->\\fP/\\fBL\\fP) places the cursor\nso that a maximum number of words (selectable or not) are visible to\nthe left (reps. right) side of the window.\n\nWhen the content of the window is shifted to the left or right using\n\\fB<\\fP or \\fB>\\fP or the mouse, the cursor always highlights the same\nword and remains visible.\nThis can prevent any further shifting operations.\n.RE\n.PP\n\\fBMouse:\\fP\n.RS 2\nWith many terminal emulators, it is possible to use the mouse to interact\nwith the screen content.\n\n\\fBWarning\\fP, if groups of extended graphemes are present in the input,\nmouse-based selection is only accurate if the terminal correctly displays\nthese graphemes.\nAn example of a non-functional terminal is xterm, an example of a\nfunctional terminal is wezterm.\n\nWhen the mouse is supported, the cursor can turn into an arrow (but\nnot always) and the mouse can then be used as a point and click device\nas follows:\n\n\\fBFirst (usually left) mouse button (note that buttons can be remapped)\\fP:\n.RS 2\n.IP \\(bu 2\nA click on a word selects it if it is selectable.\n.IP \\(bu 2\nA click on a word while holding the CTRL key pressed when tagging/pinning\nis activated marks/unmarks this word.\n.IP \\(bu 2\nA Click at the ends of the vertical scroll bar (if present) is equivalent\nto pressing the keyboard's up or down arrow.\n\nA click anywhere else on the vertical scroll bar moves the cursor to\nanother word, depending on where you click.\n\nThe new current word will be positioned at the beginning of a line\nif possible.\n\nA click at the ends of the horizontal scroll bar (if present) is\nequivalent to pressing the keyboard's left or right arrow.\n\nA click anywhere else on the horizontal scroll bar moves the cursor left\nof right on the line containing the cursor, but does not move it further\nthan the first or last word on that line.\n.IP \\(bu 2\nA double-click on a word selects it, if selectable, and acts as if the\nEnter key had been pressed, the double-click delay being configurable.\n.IP \\(bu 2\nA click on the left or right horizontal arrow of each line (when visible)\nshifts the content of the window to the left or right, one word at a time.\n.br\nNothing happens if the cursor risks leaving the window.\n\nNote that clicking on a left-facing arrow in an empty line means that\nnot all the words in that line could be displayed because of previous\nshifts or moves.\nIn this case, smenu will try to display the last word of this line but\nit is not always possible as the cursor must remain visible.\n.br\nThe keyboard commands \\fB<\\fP and \\fB>\\fP can be used in such a case\nbecause the cursor is already on the current line.\n.RE\n.P\n\\fBThird (usually right) mouse button\\fP:\n.RS 2\n.IP \\(bu 2\nWhen tagging or pinning is enabled, a click on a word tags/untags it if\nit is selectable.\n.IP \\(bu 2\nWhen tagging or pinning is enabled, a click on a word while holding the\nCTRL key pressed has the following actions:\n.RS 2\n.IP - 2\nIf the word clicked is selectable and no word is already marked then\nmarks it.\n.IP - 2\nIf a word is marked and the clicked word is selectable and is not the\nmarked word, then:\n.RS 2\n.IP + 2\nIn column mode, if the marked word is in the same column/line as the\nclicked word, tags all words bounded by those words in that column/line\nas if \\fBZ\\fP the keyboard command were used.\n.IP + 2\nIn line or column mode, if the marked word is in the same line as the\nclicked word, tags all words bounded by those words in that line.\n.IP + 2\nOtherwise, tags all words bounded by the marked word and the\nclicked one.\n.IP + 2\nIn all cases, the mark is removed.\n.RE\n.RE\n.RE\n.P\n\\fBMouse wheel\\fP:\n.RS 2\n.IP \\(bu 2\nRotating the mouse wheel scrolls the contents of the window one line up\nor down.\n.IP \\(bu 2\nRotating the mouse wheel while holding down the \\fBCTRL\\fP key scrolls\nthe contents of the window one page up or down.\n.br\nThis feature may not work depending on the terminal and operating system.\n.PP\nBe sure to use the wheel when the mouse pointer is over the smenu\nwindow, as some terminal emulators may otherwise zoom the screen in\nand out instead.\n.RE\n.PP\nRemember that mouse support does not disable the keyboard, so use the\nkeys instead if the mouse is not working properly.\n.PP\nSome terminals may not report clicks after the 223rd line or column due\nto a limitation of the old X11 mouse tracking protocol, one example of\nsuch a terminal emulator is screen < 4.7.0.\ntmux as well as screen >= 4.7.0 are fine.\n\nKeyboard and mouse can be used at the same time.\n.TP 2\n\\fBRemark 1.\\fP\nSome X-Window terminal emulators may not support the\nenable/disable bracketed pastes escape sequence, in such a case if\nmay be necessary to explicitly clear the content of the paste buffer\nbefore running smenu so that the mouse buttons (especially for pasting)\ndo their job correctly.\n.br\nThis action can easily be performed using the command \\f(CRxsel -c\\fP\nfor example.\n.TP 2\n\\fBRemark 2.\\fP\nSome X-Windows terminal emulators intercept mouse input\nwhen some modifiers are used, a typical example is xterm which displays\npopup menus in these cases.\n.br\nFor xterm (Patch #361 - 2020/10/14 or later) a working workaround\nis to use the X resource \\f(CRXTerm*omitTranslation:popup-menu\\fP\neither by adding it in your \\f(CR.Xresources\\fP file and register\nit with \\f(CRxrdb\\fP or by launching xterm using the\n\\f(CR-xrm 'XTerm*omitTranslation:popup-menu'\\fP command line option.\n.TP 2\n\\fBRemark 3 for BSD systems.\\fP\nIn order for the mouse to work properly under (virtualised?) FreeBSD\nand perhaps other BSD variants, it may be necessary add the following\ntwo lines to the file \\fB~/.Xmodmap\\fP:\n\n.nf\n\\f(CR! Disable button 8 and 9.\npointer = 1 2 3 4 5 6 7 0 0 10 11 12\\fP\n.fi\n\nAnd run the command: \\f(CRxmodmap ~/.Xmodmap\\fP\n(ignore any warnings issued by this command).\n\nThis can also be done non-permanently by running the command:\n.nf\n\\f(CRxmodmap -e \"pointer = 1 2 3 4 5 6 7 0 0 10 11 12\"\\fP\n.fi\n\nIf this is not enough, try to disable buttons 8 to 12.\n\n.RE\n.P\n\\fBDirect access:\\fP\n.RS 2\nIf \\fB-N\\fP|\\fB-number\\fP, \\fB-U\\fP|\\fB-unnumber\\fP or\n\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP are used, then it becomes\npossible to directly access a word by entering its number.\nThe numbering created using these option is done \\fBbefore\\fP any words\nsubstitution done using \\fB-S\\fP|\\fB-subst\\fP \\fI/regex/repl/opts\\fP,\n\\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP or\n\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP.\n\nUsing a combination of these options, it is easy to control which words\nwill be numbered by adding a special symbol in it before using smenu and\nremoving it (substituted by nothing) afterward using\n\\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP by example.\n\n\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP gives another way to do that,\nsee below or more.\n.RE\n.SS \"Changing input words\"\nsmenu offers the possibility to modify the input words in a sed-like way.\nWords can be modified at two points: just after they have been read\nand after other operations have been applied, such as enabling,\ndisabling or coloring.\n\nThe related options are \\fB-ES\\fP|\\fB-subst\\fP,\n\\fB-S\\fP|\\fB-subst\\fP, \\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP and\n\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP their descriptions can be found\nin the \\fBOPTIONS\\fP section.\n.SS \"Searching for words\"\nA word can be searched using different algorithms: \\fIprefix\\fP,\n\\fIsubstring\\fP of \\fIfuzzy\\fP.\n.TP\n\\fIprefix\\fP (keys \\fB^\\fP or \\fB=\\fP):\nThe sequence of characters entered must match the beginning of a word.\n.TP\n\\fIsubstring\\fP (keys \\fB\"\\fP or \\fB'\\fP):\nThe sequence of characters entered must match a substring in a word.\n.TP\n\\fIfuzzy\\fP (keys \\fB~\\fP or \\fB*\\fP):\nAll the characters in the entered sequence must appear in the same order\nin a word, but need not be consecutive.\n\nThe case is also ignored.\n\nNote that spaces and tabs at the beginning and end of words are ignored\nwhen searching for substrings or fuzzy strings.\n\nThe cursor is placed, if possible, on the first matching word having the\nminimum number of gaps between the first and last matching character,\nsee the difference between the actions of the \\fBs\\fP/\\fBS\\fP and\n\\fBn\\fP/\\fBN\\fP keys below.\n\nThis method also tolerates intermediate symbols not appearing in the\nwords which will be ignored.\nIf this is the case, the attributes of the approximately matching\nwords are changed into an error versions of them to warn the user to\nthis situation.\n\nThe erroneous symbols will \\fInot\\fP be inserted in the search buffer.\n\nFor example: if the word \\fBabcdef\\fP is present in the standard input,\nthen entering \\f(CBabxcdye\\fP puts \\fBabcdef\\fP in the search buffer\nand the word is added to the list of matching words and displayed with\nan error attribute (in red by default).\n\nThis special state will persist until all the symbols following the first\nerroneous one are deleted (using backspace) or if \\fBESC\\fP is pressed\nto cancel the search session and clear the search buffer.\n.PP\nDuring a search session, the cursor changes and each character entered is\nadded in (or removed from) the search buffer.\nThe display is refreshed after each change in this buffer.\n.PP\nA 10 seconds timeout (by default) automatically ends the current\nsearch session as if the \\fBEnter\\fP key had been pressed.\nThis timeout is reset each time a new key is hit in search mode.\nThis delay can be configured using the \\fBsearch\\fP entry in the\n\\fBtimers\\fP section of the configuration file as shown in the example\nin the configuration subsection.\n.PP\nThe slash key (\\fB/\\fP) can also be used instead of any of these keys.\nBy default it is is programmed to do a \\fIfuzzy\\fP search but this can\nbe changed by using the command line option\n(\\fB-/\\fP|\\fB-search_method\\fP) or by tuning a configuration file,\nsee below.\n.PP\nAll the words matching the current search buffer are enhanced:\nThe characters present in the current search buffer are highlighted in\none way and the other characters in another way.\nBoth of these highlighting methods are configurable.\n.PP\nIf the user has entered the search sequence: \\fBo\\fP, \\fBs\\fP, then the\nmatching word \"words\" will be displayed as \\fBw\\fP\\fIo\\fP\\fBrd\\fP\\fIs\\fP\nwhen the \\fIfuzzy\\fP algorithm is in use depending of the display\nattributes configured.\n.PP\n\\fBENTER\\fP and all cursor moves terminate the search session but do\nnot clear the list of the matching words and the search buffer.\n.PP\nThe user can then use the \\fBn\\fP/\\fBs\\fP/\\fBSPACE\\fP keys (forward) and\nthe \\fBN\\fP/\\fBS\\fP keys (backward) to navigate in the list of matching\nwords,\n\nIn \\fIfuzzy\\fP search mode, the \\fBs\\fP/\\fBS\\fP keys attempt to move the\ncursor to the next/previous word whose matching part forms a substring\nof this word.\nIf no such matches exist, \\fBs\\fP/\\fBS\\fP and \\fBn\\fP/\\fBN\\fP do the\nsame things.\nTo move the cursor to the next/previous fuzzy match, use the\n\\fBn\\fP/\\fBN\\fP/\\fBSPACE\\fP keys.\n\\fBs\\fP means next \\fPs\\fPubstring match in this context while \\fBn\\fP\njust means \\fBn\\fPext match.\n.PP\nIf the user hits the \\fBHOME\\fP or \\fBEND\\fP key during a search session\nthen the list of matching words is reduced to the words starting\n(respectively) ending with the current search pattern and the window\nis refreshed.\nFor those who consider \\fBHOME\\fP and \\fBEND\\fP as non-intuitive,\nthe \\fBCTRL\\ A\\fP and \\fBCTRL\\ Z\\fP keys are also available in search mode\nas an alternative.\nThis behavior is persistent until the user hit the \\fBESC\\fP or\n\\fBENTER\\fP key.\n\nFor example, if the search pattern in substring mode is \\f(CBsh\\fP and\nthe user hits \\fBEND\\fP, then only the words \\fIending\\fP with \\f(CBsh\\fP\nwill be added in the searched word list and enhanced.\n\nNote that when a matching word is selected, its enhanced characters only\nshow one of the multiple matching possibilities.\n\nWhen not in a search session \\fBESC\\fP can be also used to clear the\nlist of matching words and to reset the search buffer.\n.PP\nNote that the search buffer is persistent as long as the same search\nalgorithm is used and \\fBESC\\fP has not been pressed.\n.SS \"Selection and Exit\"\nPressing \\fBq\\fP gives the possibility to exit without selecting anything.\n.PP\n\\fBCTRL\\ C\\fP (Abort) also exits the program immediately with a return\ncode equal to 128+SINGINT (by default) without selecting anything.\nSee the \\fB-!\\fP|\\fB-int\\fP|\\fB-int_string\\fP option for more information\nabout the customization of the \\fBCTRL\\ C\\fP behavior.\n.PP\nBy default, \\fBENTER\\fP or a double click with the first mouse button if\napplicable writes the selected word to stdout when not in\nsearch mode otherwise it exits from this mode and does nothing more.\nIf you want to be able to select a word \\fIeven\\fP when in search mode,\nuse the \\fB-r\\fP|\\fB-auto_validate\\fP option to change this behavior.\n.SS \"Tagging (multiple selections)\"\nWhen the tagging is activated by using the command line\n\\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP\nor \\fB-P\\fP|\\fB-pm\\fP|\\fB-pin\\fP|\\fB-pin_mode\\fP option, then the\nkeys \\fBt\\fP, \\fBu\\fP, \\fBINS\\fP, \\fBDEL\\fP \\fBc\\fP, \\fBr\\fP,\n\\fBm\\fP, \\fBM\\fP, \\fBT\\fP, \\fBC\\fP, \\fBR\\fP and \\fBU\\fP, can be\nused to tag/untag some words.\nThese tagged words will then be sent to the standard output when\n\\fBENTER\\fP is pressed.\n\nTheir meanings is as follows:\n.TP\n\\fBt\\fP\nTags/untags or Pin/unpin the word under the cursor (toggle).\n.TP\n\\fBu\\fP\nUntags or unpins the word under the cursor.\n.TP\n\\fBINS\\fP\nTags or pins the word under the cursor.\n.TP\n\\fBDEL\\fP\nUntags or unpins the word under the cursor.\n.TP\n\\fBc\\fP\nTags or pins all the selectable words in the current \\fBcolumn\\fP when\nno word is marked, otherwise acts like \\fBC\\fP.\n.TP\n\\fBr\\fP\nTags or pins all the selectable words in the current \\fBrow/line\\fP\nwhen no word is marked, otherwise acts like \\fBR\\fP.\n.TP\n\\fBm\\fP\nMarks the current word, the cursor aspect will change until the word\nis unmarked.\n.TP\n\\fBM\\fP or \\fBESC\\fP\nUnmarks the current word, other actions will also automatically unmark\nthe word, see below.\n.TP\n\\fBT\\fP\nIf no word are marked and the result of a search is still displayed then\ntags all words found in this search.\n\nIf no word has been searched and no word is marked, then the current\nword is marked, just as if \\fBm\\fP has been used instead.\nOtherwise all words between the marked word and the\ncurrent word are tagged.\n.br\nThe marked word will no longer be marked after tagging is complete.\n.TP\n\\fBZ\\fP\nLike \\fBT\\fP when not in search mode and when the marked words is not\non the same column or line as the cursor in column mode.\n.br\nWhen in column mode and if the marked word is in the same column or line\nas the cursor, tags only the words in the same column (respectively line)\nbounded by the marked word and the cursor.\n.TP\n\\fBC\\fP\nAs for \\fBT\\fP, \\fBC\\fP marks the current word if no word is currently\nmarked, just as if \\fBm\\fP had been used instead.\n.br\nIf a word is already marked, \\fBC\\fP tags/pins the words between the\ncurrent and the marked words if they are the \\fBsame column\\fP.\n.br\nThe marked word will no longer be marked after tagging is complete.\n.TP\n\\fBR\\fP\nAs for \\fBT\\fP, \\fBR\\fP marks the current word if no word is currently\nmarked, just as if \\fBm\\fP has been used instead.\n.br\nIf a word is already marked, \\fBR\\fP tags/pins the words between the\ncurrent and the marked words if they are the \\fBsame row/line\\fP.\n.br\nThe marked word will no longer be marked after tagging is complete.\n.PP\nNote that when you use \\fBT\\fP, \\fBC\\fP or \\fBR\\fP with pinning enabled,\nthe order of word selection depends on whether the marked word is before\nor after the current word.\n.br\nWhen a word is marked, the pinning order using \\fBc\\fP and \\fBr\\fP\nincreases from the marked word to the current word.\n.br\nWhen no words are marked, the pinning order when using \\fBc\\fP and \\fBr\\fP\nalways increases from top to bottom and from left to right respectively.\n.TP\n\\fBU\\fP\nUntags or unpins the last tagging action.\n.TP\n\\fBCTRL T\\fP\nUntags all the previously tagged/pinned words.\n.br\nThe marked word, if any, will no longer be marked after this action.\n.PP\nAlso note that using some of these keys may be more easily achieved by\nusing the third mouse button (usually the right one) when the mouse\nis available.\n.br\nSee how to use the right mouse buttons in the \"Keyboard and mouse\nusage.\" at the beginning of this manual.\n.SS Help\nA small help message can be displayed when hitting the \\fB?\\fP key.\nThis message will last for 30s or until another key or \\fBESC\\fP is\npressed.\n.br\nIf the help content is longer than the window, it can be scrolled up or\ndown using the vertical arrow keys or the vi direction keys (\\fBj\\fP\nand \\fBk\\fP).\n.SS \"Scroll bars\"\nThe vertical scroll bar is displayed at the right of the scrolling window.\nIts appearance is meant to be classical but it has some particularities:\n.IP \\(bu 2\nThe vertical scroll bar is not displayed if all the input words fit on\nonly one line.\n.IP \\(bu 2\nOtherwise, the vertical scroll bar is always displayed except when\nthe \\fB-q\\fP option is set.\nThis option completely disables the scroll display of all scroll bars.\n.IP \\(bu 2\nWhen the scrolling window has only one line, the vertical scroll bar\nhas only 3 states:\n.RS 2\n.IP - 2\n\\fBv\\fP when on all but the last line, indicating that you can go down\nto see more.\n.IP - 2\n\\fB^\\fP when on the last line.\n.IP - 2\n\\fB|\\fP otherwise.\n.RE\n.IP \\(bu 2\nWhen there is more than one line to display, \\fB/\\fP means that the window\ndisplays the first line, \\fB\\\\\\fP the last line.\n\\fB|\\fP is used to fill the gap, see below the different possible\nconfigurations.\n.TS\ntab(@);\nl l l l l\nl l l l l\nl l l l .\n\\\\@\\\\@^@^@\\\\ @Do not remove this trailing space!\n|@|@|@|@/\n/@v@/@v\n.TE\n.PP\nA \\fB+\\fP can also appear in the scroll bar in lieu of the vertical bar,\ngiving the relative position of the cursor line in the bunch of input\nwords.\n\nThe horizontal scroll bar is only displayed below the window when the\ncurrent line is truncated in line of column mode.\n\nIf its appearance scrolls up the windows in the screen, the new position\nof the window will unchanged even it this scroll bar is no more displayed\nas the line containing the cursor is no more truncated.\n.SS \"Terminal resizing (also see BUGS/LIMITATIONS)\"\nThe windows is redrawn if the terminal is resized.\nThe redrawing is actually done only 1s after the end of the resizing to\navoid artifacts on screen.\nThe cursor will remain on the current selected word but may be displayed\nat another place in the window.\n.SS \"Unicode support\"\nThis utility is Unicode aware and should be able to display correctly\nany Unicode character (even double-width ones) as long as the current\nencoding is \\fBUTF-8\\fP (\\fBUTF-8\\fP in the output of the \\fIlocale\\fP\ncommand).\n\nNote that smenu will not attempt to normalize words containing UTF-8 glyphs.\nThus \\fI\\\\u61\\\\ucc88\\fP (\\fIä\\fP) will not be considered equal to\n\\fI\\\\uc3a4\\fP (canonical normalization of  \\fIä\\fP).\nIt is nevertheless possible to use an external tool such as uconv from the\nICU project (https://icu.unicode.org) to do this work before using smenu.\n\nFor example: uconv can be used as a filter as in:\n\n\\f(CBcat ... | uconv -x any-nfc | smenu\\fP\n.SS \"Optional configuration file\"\nIf a file with adequate permissions and the same name as the executable\nbut prefixed with a dot is present in the current directory\nor in the user's home directory, then it will be parsed as a\n\\fI.ini\\fP file.\nThe values read from the file in the home directory will be overridden by\nthe ones read from the local directory (if it is present).\n\nMissing and bad keywords are silently skipped.\n\nThe values read, if valid, override the default hard-coded ones.\n\nIf a value is invalid an error message is shown and the program terminates.\n\nThe values of the timers must be given in units of \\fB1/10\\fP of a second.\n\nHere is an example giving the syntax and the names of the keywords\nallowed:\n.PP\n.nf\n\\f(CR--8<------------------------------------------------------------------\n[colors]\n  ; The terminal must have at least 8 colors and/or have attributes\n  : like bold and reverse for this to be useful\n  ; if not the following settings will be ignored.\n\n  method=ansi             ; classic | ansi (default)\n\n  cursor=0/2              ; cursor attributes\n  cursor_on_tag=0/2,u     ; cursor on tag attributes\n  shift=6,b               ; shift symbol attributes\n  message=0/3             ; message (title) attributes\n  bar = 7/4,b             ; scroll bars attributes\n  search_field = 0/6      ; search field attributes\n  search_text = 7,bu      ; search text attributes\n  match_field = 1,b       ; matching words field attributes\n  match_text = 7,bu       ; matching words text attributes\n  search_err_field = 1    ; approximate search field attributes\n  search_err_text = 1,r   ; approximate search text attributes\n  ; match_err_field = 3   ; approximate matching words field attributes\n  match_err_text = 1      ; approximate matching words text attributes\n  ; include = b           ; selectable color attributes\n  exclude = 4/0,u         ; non-selectable color attributes\n  tag = 0/5               ; tagged (selected) attributes\n  daccess = 3,b           ; direct access tag attributes\n\n  special1 = 7/4,b        ; attributes for the special level 1\n  special2 = bu           ; attributes for the special level 2\n  special3 = /3,b         ; attributes for the special level 3\n  special4 = 7/4          ; attributes for the special level 4\n  special5 = 7/2,b        ; attributes for the special level 5\n  special9 = 2,rb         ; attributes for the special level 9\n\n[window]\n  lines = 7               ; default number of lines of the window\n\n[limits]\n  word_length = 1024      ; arbitrary max length of input words (int)\n  words = 32767           ; arbitrary max number of allowed input\n                          ; words (int)\n  columns = 128           ; arbitrary max number of columns (int)\n\n[timers]\n  search = 100            ; search timeout in 1/10 s\n  help = 150              ; duration of the help message in 1/10 s\n  window = 7              ; delay before redrawing if the size of the\n                          ; terminal's window change in 1/10 s\n  direct_access = 6       ; duration allowed to add a new digit to\n                          ; the direct word access number in 1/10 s\n  forgotten = 9000        ; An explicit delay (in 1/10 s) before smenu\n                          ; is forced to stop as if \"q\" had been pressed.\n                          ; Useful when one forgot to make a selection.\n\n[misc]\n  default_search_method = substring\n\n[mouse]\n  double_click_delay= 200 ; delay in milliseconds\n--8<------------------------------------------------------------------\n\\fP\n.fi\n.IP \\(bu 2\nThe \\fBmethod\\fP keyword can take the two possible values displayed\nabove and determines if you want to use the native method (limited to 8\ncolors) of the \\fBansi\\fP method (ISO 8613-6) if your terminal supports\nmore than 8 colors.\n\nThe default value corresponds to \\fBansi\\fP.\n\nThe attributes syntax is [fg][/bg][[,.+]toggles] where \\fBfg\\fP and\n\\fBbg\\fP are numbers representing the foreground and background color\nand \\fBtoggles\\fP is a strings which can contain the characters \\fIb\\fP,\n\\fId\\fP, \\fIr\\fP, \\fIs\\fP, \\fIu\\fP, \\fIi\\fP, \\fIn\\fP and \\fIl\\fP\nrepresenting respectively \\fIb\\fPold, \\fId\\fPim, \\fIr\\fPeverse,\n\\fIs\\fPtandout, \\fIu\\fPnderline, \\fIi\\fPtalic, i\\fIn\\fPvisible\nand b\\fIl\\fPink.\n.IP \\(bu 2\nSpaces are allowed anywhere in the lines and between them, even around\nthe \\fB=\\fP.\n.IP \\(bu 2\nEverything following a \\fB;\\fP is ignored.\n.IP \\(bu 2\nWhen undefined, the default limits are:\n.TS\ntab(@);\nl l .\nwords@32767\nword_length@512\ncolumns@256\n.TE\n.SH OPTIONS\n\nNot all options may be available, depending on the current context.\n\nWhen smenu is called and before the first option is evaluated, it is in\nthe \\fBMain\\fP context.\nEach option can switch to another context in which only a subset of the\noptions is usable.\n\nFor each parameter described below, the contexts in which the associated\noption is defined as well as the context to which it leads, if any,\nare given.\n\nAn option not defined in a context will force the end of the current\ncontext and will be recursively evaluated in the previous contexts until\nfound (or not).\nIf not found, an error message is displayed and smenu is terminated.\n\nThe contexts defined in smenu are:\n.IP \\fBMain\\fP 2\nThe default context\n.IP \\fBColumns\\fP 2\nAfter the \\fB-c\\fP|\\fB-col\\fP|\\fB-col_mode\\fP|\\fB-column\\fP parameter.\n.IP \\fBLines\\fP 2\nAfter the \\fB-l\\fP|\\fB-line\\fP|\\fB-line_mode\\fP parameter.\n.IP \\fBTabulations 2\nAfter the \\fB-t\\fP|\\fB-tab\\fP|\\fB-tab_mode\\fP|\\fB-tabulate_mode\\fP parameter.\n.IP \\fBTagging\\fP 2\nAfter the \\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP or\n\\fB-P\\fP|\\fB-pm\\fP|\\fB-pin\\fP|\\fB-pin_mode\\fP parameter.\n.PP\n.IP \\fBWARNING\\fP 2\nHere is a situation that may seem confusing at first glance.\n\nImagine the only parameter command line parameter is \\fB-cols_select\\fP.\n\nSince this is a parameter of an option which is not valid when not in\nthe \\fBColumns\\fP context, it should have raised an error but it still\nseems to be accepted.\n\nThe trick is: when not in column mode \\fB-cols_select\\fP is indeed not\naccepted but its prefix (\\fB-col\\fP) is valid.\nThe options are thus understood as: \\fB-col\\fP \\fB-s_select\\fP.\nThe same mechanism occurs again as \\fB-s\\fP is also valid in column\nmode so the final understanding of the command line is: \\fB-col\\fP\n\\fB-s\\fP \\fB_select\\fP.\n\nAnother example that illustrates the fact that long parameters have\npriority over short parameter combinations: \\fB-is\\fP will not select\nonly words containing a \"\\fBs\\fP\", but will act in the same way as its\nalternative name (\\fB-incremental_search\\fP).\n\nIf you really want to select only words containing a \"\\fBs\\fP\", simply\nadd a space after the \\fBi\\fP as in \\fB-i s\\fP or use one of the other\n\\fB-i\\fP names such as \\fB-inc\\fP for example.\n\nIn such cases, the user may set the \\fBCTXOPT_DEBUG\\fP environment\nvariable which any non-empty content.\n\nIf we reconsider the \\fB-cols_select\\fP example with \\fBCTXOPT_DEBUG\\fP set\nthe output is now:\n\n.nf\nCTXOPT_DEBUG: Parameter: -cols_select. Evaluation context: Main.\nCTXOPT_DEBUG: Found a valid parameter as a prefix of -cols_select: -col.\nCTXOPT_DEBUG: Parameter: -col. Evaluation context: Main.\nCTXOPT_DEBUG: Switch to context Columns.\nCTXOPT_DEBUG: Parameter: -s_select. Evaluation context: Columns.\nCTXOPT_DEBUG: Found a valid parameter as a prefix of -s_select: -s.\nCTXOPT_DEBUG: Parameter: -s. Evaluation context: Columns.\nCTXOPT_DEBUG: Argument: _select.\n.fi\n\nIn this case, adding a space in the command line: \\fB-col\\fP\n\\fB-cols_select\\fP \\fB1\\fP also solves the issue and indicates that only\nthe first column should be selectable.\n\nNote, however, that at least one argument for \\fB-cols_select\\fP is\nnow required:\n\n.nf\nCTXOPT_DEBUG: Parameter: -col. Evaluation context: Main.\nCTXOPT_DEBUG: Switch to context Columns.\nCTXOPT_DEBUG: Parameter: -cols_select. Evaluation context: Columns.\nCTXOPT_DEBUG: Argument: 1.\n.fi\n.PP\nThe \\fB-h\\fP|\\fB-help\\fP and \\fB-?\\fP|\\fB-u\\fP|\\fB-usage\\fP options now\ndisplay the help and synopsis of the available options in the current\ncontext.\n.IP Example: 2\n\\f(CBsmenu -col -u\\fP will only show the usage in the \\fBColumns\\fP\ncontext\n.PP\nThe contexts contain all the non-context-changing options so, in practice,\nthe usage should be intuitive.\nYou may nevertheless have to adjust some scripts using the old smenu\nreleases as I did in the lvm_menu example.\n.PP\nSome of the advantages of this new system of options are:\n.IP \\(bu 2\nLong parameter names are allowed\nOne dash is enough, but two are also allowed for compatibility reasons.\n.IP \\(bu 2\nAn option can be referenced by any number of parameters with short or\nlong names.\n.IP \\(bu 2\nAuto checking of missing mandatory options, duplicated option,...\n.IP \\(bu 2\nOnly options usable in the current context are allowed.\n.PP\nThis option management system is explained in more detail at\nhttps://github.com/p-gen/ctxopt.\n.PP\nThe description of each command line parameter is as follows:\n.IP \"\\fB-h\\fP|\\fB-help\\fP\"\n(Allowed in all contexts.)\n\nDisplay a context specific help messages and exits.\n.IP \"\\fB-H\\fP|\\fB-long_help\\fP\"\n(Allowed in the \"Main\" context.)\n\nDisplay a long (non context specific) help messages and exits.\n.IP \"\\fB-?\\fP|\\fB-u\\fP|\\fB-usage\\fP\"\n(Allowed in all contexts.)\n\nDisplays a short help message and exits.\n.IP \"\\fB-V\\fP|\\fB-version\\fP\"\n(Allowed in the \"Main\" context.)\n\nThe \\fB.smenu\\fP files in the user's home directory and in the current\ndirectory, if present, will be ignored when this option is used.\n.IP \"\\fB-n\\fP|\\fB-lines\\fP|\\fB-height\\fP [\\fIheight\\fP]\"\n(Allowed in all contexts.)\n\nGives the maximum number of lines in the scrolling selection window.\n\nIf \\fB-n\\fP|\\fB-lines\\fP|\\fB-height\\fP is not present the number of\nlines will be set to \\fI5\\fP.\n\nIf \\fB-n\\fP|\\fB-lines\\fP|\\fB-height\\fP is present without argument, then\nthe height of the terminal will be used to determine the number of lines.\nThis remains true even if the terminal is resized.\n\nIf \\fB-n\\fP|\\fB-lines\\fP|\\fB-height\\fP is present with a numerical\nargument, this value will be used to determine the number of lines.\n.IP \"\\fB-i\\fP|\\fB-in\\fP|\\fB-inc\\fP|\\fB-incl\\fP|\\fB-include\\fP... \\fIregex\\fP\"\n(Allowed in all contexts.)\n\nSets the \\fBi\\fPnclude filter to match the selectable words.\nAll the other words will become implicitly non-selectable (excluded)\n\n\\fB-i\\fP|\\fB-in\\fP|\\fB-inc\\fP|\\fB-incl\\fP|\\fB-include\\fP can be used more\nthan once with cumulative effect.\n\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can also be used in the regexp.\n.IP \"\\fB-e\\fP|\\fB-ex\\fP|\\fB-exc\\fP|\\fB-excl\\fP|\\fB-exclude\\fP... \\fIregex\\fP\"\n(Allowed in all contexts.)\n\nSets the \\fBe\\fPxclude filter to match the non-selectable words.\nAll the other selectable words will become implicitly selectable (included)\n\n\\fB-e\\fP|\\fB-ex\\fP|\\fB-exc\\fP|\\fB-excl\\fP|\\fB-exclude\\fP can be used more\nthan once with cumulative effect.\nThis filter has a higher priority than the include filter.\n\nThe \\fIregex\\fP selections made using\n\\fB-i\\fP|\\fB-in\\fP|\\fB-inc\\fP|\\fB-incl\\fP|\\fB-include\\fP and/or\n\\fB-e\\fP|\\fB-ex\\fP|\\fB-exc\\fP|\\fB-excl\\fP|\\fB-exclude\\fP are done before\nthe possible words alterations made\nby \\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP or\n\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP (see below).\n\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can also be used in the regexp.\n.IP \"\\fB-m\\fP|\\fB-msg\\fP|\\fB-message\\fP|\\fB-title\\fP \\fImessage\\fP\"\n(Allowed in all contexts.)\n\nDisplays a message (title) above the window.\nIf the current locale is not \\fBUTF-8\\fP, then all \\fBUTF-8\\fP characters\nwill be replaced by the substitution character.\n\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can be used in the message.\n\nNote that the message will be truncated if it does not fit on a terminal\nline.\n.IP \"\\fB-!\\fP|\\fB-int\\fP|\\fB-int_string\\fP [\\fIstring\\fP]\"\n(Allowed in all contexts.)\n\nThe optional \\fIstring\\fP argument, when present,\ndefines the string to be used as the selection string when\nthe \\fBCTRL\\ C\\fP sequence is entered.\n\nIf \\fIstring\\fP is missing then nothing will be selected.\n\nIn all cases, when \\fB-!\\fP|\\fB-int\\fP|\\fB-int_string\\fP is present in\nthe command line, the return code of the program will be \\fB0\\fP.\n\nThis gives the user the choice to make the behavior of \\fBCTRL\\ C\\fP\nsimilar to that of \\fBq\\fP and \\fBQ\\fP or to that of the Unix shell\nleaving the shell with a return code greater than 128.\n.IP \"\\fB-a\\fP|\\fB-attr\\fP|\\fB-attributes\\fP \\fIprefix:attr\\fP...\"\n(Allowed in all contexts.)\n\nSets the display attributes of the elements displayed and the cursor.\n\nAt least one attribute prefixed attribute must be given.\n\n\\fIprefix\\fP can take the following values:\n.RS\n.PD 0\n.IP \\fIi\\fP\nincluded words.\n.IP \\fIe\\fP\nexcluded words.\n.IP \\fIc\\fP\ncursor.\n.IP \\fIb\\fP\nscroll bar.\n.IP \\fIs\\fP\nshift indicator.\n.IP \\fIm\\fP\nmessage (title).\n.IP \\fIt\\fP\ntagged words.\n.IP \\fIct\\fP\ncursor on tagged words.\n.IP \\fIsf\\fP\nsearch field.\n.IP \\fIst\\fP\nsearch text.\n.IP \\fIsfe\\fP\napproximate search field with error.\n.IP \\fIste\\fP\napproximate search text with error.\n.IP \\fImf\\fP\nmatching words field.\n.IP \\fImt\\fP\nmatching words text.\n.IP \\fImfe\\fP\nmatching words field with error.\n.IP \\fImte\\fP\nmatching words text with error.\n.IP \\fIda\\fP\ndirect access tag.\n.PD\n.RE\n.IP\nIf more than one attribute is given, they must be separated by spaces.\n\nExample: \\f(CB-attr i:/5 e:4,br b:7/3,rb c:7/2,b\\fP\n\nSee the the \\fB-1\\fP|\\fB-l1\\fP|\\fB-level1\\fP option below for the\ndescription of the attributes syntax after the colon and an example.\n.IP \"\\fB-1\\fP|\\fB-l1\\fP|\\fB-level1\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-2\\fP|\\fB-l2\\fP|\\fB-level2\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-3\\fP|\\fB-l3\\fP|\\fB-level3\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-4\\fP|\\fB-l4\\fP|\\fB-level4\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-5\\fP|\\fB-l5\\fP|\\fB-level5\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-6\\fP|\\fB-l6\\fP|\\fB-level6\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-7\\fP|\\fB-l7\\fP|\\fB-level7\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-8\\fP|\\fB-l8\\fP|\\fB-level8\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n.IP \"\\fB-9\\fP|\\fB-l9\\fP|\\fB-level9\\fP \\fIregex\\fP [\\fIattr\\fP]\"\n(Allowed in all contexts.)\n\nAllows one to give a special display color to up to 5 classes of words\nspecified by regular expressions.\nThey are called \\fBspecial levels\\fP.\nOnly selectable words will be considered.\n\nBy default, the first 5 special levels have their foreground color set\nto red, green, brown/yellow, purple and cyan and the remaining 4 levels\nare set to white.\nAll these colors also can be set or modified permanently in the\nconfiguration files.\nSee the example file above for an example.\n\nThe optional second argument (\\fIattr\\fP) can be used to override the\ndefault or configured attributes of each class.\nIts syntax is the same as the one used in the configuration file:\n.nf\n[\\fIfg\\fP][/\\fIbg\\fP]\\\n[,{\\fIb\\fP|\\fId\\fP|\\fIr\\fP|\\fIs\\fP|\\fIu\\fP|\\fIi\\fP|\\fIn\\fP|\\fIl\\fP}] \\\n| [{\\fIb\\fP|\\fId\\fP|\\fIr\\fP|\\fIs\\fP|\\fIu\\fP|\\fIi\\fP|\\fIn\\fP|\\fIl\\fP}]\n.fi\n\nExamples of possible attributes are:\n.nf\n  \\f(CB2/0,bu \\fPgreen on black bold underline\n  \\f(CB/2     \\fPgreen background\n  \\f(CB5      \\fPtext in purple\n  \\f(CBrb     \\fPreverse bold\n.fi\n\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can be used in the pattern.\n.IP \"\\fB-z\\fP|\\fB-zap\\fP|\\fB-zap_glyphs\\fP \\fIbytes\\fP\"\n(Allowed in all contexts.)\n\nInitializes a set of \\fBUTF-8\\fP characters to be ignored when reading\nwords from stdin or a file.\n\nExample: The argument \\f(CR'\\\\u0d\\\\ue282ac,'\\fP means: ignore all commas,\nEuro signs and carriage return characters when reading from stdin or\na file.\n\nAs shown above \\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can be used in the\nbytes set.\n.IP \"\\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP [\\fIdelim\\fP]\"\n(Allowed in the following contexts: \"Main\", \"Columns\", \"Lines\", and\n\"Tabulations\", switches to the \"Tagging\" context.)\n\nAllows multiple selections and switches to \\fBtag\\fP mode.\nIn this mode, several selectable words can be selected without leaving\nthe program.\n\nTagged words are highlighted (underlined by default).\n\nThe current word can be automatically tagged when the \\fBENTER\\fP key\nis pressed to complete the selection process if the\n\\fB-p\\fP|\\fB-at\\fP|\\fB-auto_tag\\fP option is\nalso set or if no word has been tagged.\n\nNote that nothing is selected when no word is tagged and when the\n\\fB-0\\fP|\\fB-noat\\fP|\\fB-no_auto_tag\\fP option is also set.\n\nAll tagged words (and possibly the world under the cursor) will be sent\nto the standard output separated by the optional argument given after\nthe option \\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP.\n\nNote that the \\fIdelim\\fP argument can contain more than one character,\ncan contain \\fBUTF-8\\fP characters (in native or \\fI\\\\u\\fP or \\fI\\\\U\\fP\nform) and can even contain control character as in \\f(CB$'\\\\n'\\fP.\n\nA single space character is used as the default separator if none\nis given.\n\n\\fBCaution\\fP: To get exactly the same behavior as in version 0.9.11\nand earlier, you must also use the \\fB-p\\fP|\\fB-at\\fP|\\fB-auto_tag\\fP\noption.\n.IP \"\\fB-P\\fP|\\fB-pm\\fP|\\fB-pin\\fP|\\fB-pin_mode\\fP [\\fIdelim\\fP]\"\n(Allowed in the following contexts: \"Main\", \"Columns\", \"Lines\", and\n\"Tabulations\", switches to the \"Tagging\" context.)\n\nWorks like \\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP but, unlike\n\\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP, the output depends on\nthe order in which the words were tagged.\nIn other words, the first tagged word comes first in the output, the\nsecond tagged word comes next, and so on.\n.IP \"\\fB-p\\fP|\\fB-at\\fP|\\fB-auto_tag\\fP\"\n(Allowed in the \"Tagging\" context.)\n\nThis option modifies the default behavior of the\n\\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP\nand \\fB-P\\fP|\\fB-pm\\fP|\\fB-pin\\fP|\\fB-pin_mode\\fP options.\n\nAn untagged word under the cursor will be automatically tagged when\n\\fBENTER\\fP is pressed.\n.IP \"\\fB-0\\fP|\\fB-noat\\fP|\\fB-no_auto_tag\\fP\"\n(Allowed in the \"Tagging\" context.)\n\nThis option modifies the default behavior of the\n\\fB-T\\fP|\\fB-tm\\fP|\\fB-tag\\fP|\\fB-tag_mode\\fP\nand \\fB-P\\fP|\\fB-pm\\fP|\\fB-pin\\fP|\\fB-pin_mode\\fP options.\n\nAn untagged word under the cursor will \\fBnot\\fP be automatically tagged\nwhen \\fBENTER\\fP is pressed \\fBand\\fP no other words are tagged.\nThis is true even when the option \\fB-p\\fP|\\fB-at\\fP|\\fB-auto_tag\\fP is\nalso set.\n\nIt is ignored if at least one other word is tagged at that time.\n.IP \"\\fB-N\\fP|\\fB-number\\fP>da_ctx... [\\fIregex\\fP]\"\n(Allowed in the following contexts: \"Main\", \"Columns\", \"Lines\" and\n\"Tabulation\".)\n\nThis option allows you to number selectable words that match a specific\nregular expression.\nThese numbers are numbered from 1 and allow direct access to the words.\n\nTo use this functionality, the user must enter the number which\ncorresponds to the desired entry digit per digit.\n\nEach new digit must be added in a time frame of 1/2 seconds (per default)\notherwise the number is considered complete and a newly entered digit\nwill start a new number.\nIf the number does not exists, then the cursor is restored to it's\ninitial position.\n\nThe sub-options of the \\fB-D\\fP|\\fB-data\\fP|\\fB-options\\fP option\ndescribed below can change the way \\fB-N\\fP|\\fB-number\\fP sets and\nformats the numbers.\n\nThis option accepts more than one argument and can be used multiple\ntimes with cumulative effects.\n\n\\fB-N\\fP|\\fB-number\\fP, \\fB-U\\fP|\\fB-unnumber\\fP and\n\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP can be mixed.\n.IP \"\\fB-U\\fP|\\fB-unnumber\\fP>da_ctx... [\\fIregex\\fP]\"\n(Allowed in the following contexts: \"Main\", \"Columns\", \"Lines\" and\n\"Tabulation\".)\n\nThis option allows one to unnumber words.\nIf placed after a previous \\fB-N\\fP|\\fB-number\\fP, it can be used to\nremove the numbering of selected words.\nIf placed before, the word which doesn't match its regular expression\nwill be numbered by default.\n\nThis mechanism is similar to to the inclusion/exclusion of words by\n\\fB-i\\fP|\\fB-in\\fP|\\fB-inc\\fP|\\fB-incl\\fP|\\fB-include\\fP and\n\\fB-e\\fP|\\fB-ex\\fP|\\fB-exc\\fP|\\fB-excl\\fP|\\fB-exclude\\fP.\n\nThis option accepts more than one argument and can be used multiple\ntimes with cumulative effects.\n\n\\fB-U\\fP|\\fB-unnumber\\fP, \\fB-N\\fP|\\fB-number\\fP and\n\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP can be mixed.\n.IP \"\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP\"\n(Allowed in the following contexts: \"Main\", \"Columns\", \"Lines\" and\n\"Tabulation\".)\n\nThis option is similar to \\fB-N\\fP|\\fB-number\\fP but does not generate\na continuous flow of numbers but extracts them from the word itself.\n\nWith this option you can take full control of the numbering of the\ndisplayed word.\nNote that the numbering does not need to be ordered.\n\nThe resulting word after the extraction of the number must be non empty.\n\nSome sub-option are required, see the \\fB-D\\fP|\\fB-data\\fP|\\fB-options\\fP\noption described below.\n\n\\fBNotice\\fP that for this option to work correctly, all the embedded\nnumbers must have the same number of digits.\nTo get that, a preprocessing may be necessary on the words before using\nthis program.\n\n\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\fB-N\\fP|\\fB-number\\fP and\n\\fB-U\\fP|\\fB-unnumber\\fP can be mixed.\n.IP \"\\fB-D\\fP|\\fB-data\\fP|\\fB-options\\fP [\\fIparameter\\fP...]\"\n(Allowed in the Following contexts: \"Main\", \"Columns\", \"Lines\" and\n\"Tabulations\".)\n\nThis option allows one to change the default behavior of\nthe \\fB-N\\fP|\\fB-number\\fP, \\fB-U\\fP|\\fB-unnumber\\fP and\n\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP options.\n\nIts optional parameters are called sub-options and must respect the\nformat \\fBx\\fP:\\fBy\\fP where \\fBx\\fP can be:\n.RS\n.TP\n\\f(CBl\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is the \\fBUTF-8\\fP character (in native or \\fI\\\\u\\fP or\n\\fI\\\\U\\fP form) to print before the number.\nThe default is a single space.\n\nExample:\n.br\n\\f(CRecho test | smenu -N -D l:\\\\(\\fP\n.br\nWill display: '\\f(CB(1)\\f(CR test\\fR'\n.\n.TP\n\\f(CBr\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is the \\fBUTF-8\\fP character (in native or \\fI\\\\u\\fP or\n\\fI\\\\U\\fP form) to print after the number.\nThe default is \\f(CB)\\fP.\n\nExample:\n.br\n\\f(CRecho test | smenu -N -D r:\\\\>\\fP\n.br\nWill display: ' \\f(CB1>\\f(CR test\\fR'\n.\n.TP\n\\f(CBa\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is '\\f(CBleft\\fP' (or one of its prefixes) if the number\nmust be \\fIleft\\fP aligned, or '\\f(CBright\\fP' (or one of its prefixes)\nif it must be \\fIright\\fP aligned.\nThe default is \\f(CBright\\fP.\n\nExample:\n.br\n\\f(CRecho test | smenu -N -D a:right w:3\\fP\n.br\nWill display: '   \\f(CB1)\\f(CR test\\fR'\n\n\\f(CRecho test | smenu -N -D a:left w:3\\fP\n.br\nWill display: ' \\f(CB1  )\\f(CR test\\fR'\n.\n.TP\n\\f(CBp\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is '\\f(CBincluded\\fP' or '\\f(CBall\\fP' for the initial\n\\fIp\\fPadding of the non numbered words.\nThe keyword '\\f(CBincluded\\fP' means that only \\fIincluded\\fP word will\nbe padded while '\\f(CBall\\fP' means pad \\fIall\\fP words.\n\nThis sub-option may improve compactness when there is a lot of\nnon-selectable words.\n\nThe default is \\f(CBall\\fP. These keywords can be abbreviated.\n\n\\fBWARNING\\fP: in column/line/tab mode this sub-option is ignored and\nnon numbered words are always padded.\n\nExample:\n.br\n\\f(CRecho a b c | smenu -eb -N -D l:\\\\( p:a\\fP\n.br\nWill display:\n\\f(CB(1)\\f(CR a     b \\f(CB(2) c\\fR\n\n.br\n\\f(CRecho a b c | smenu -eb -N -D l:\\\\( p:i\\fP\n.br\nWill display:\n\\f(CB(1)\\f(CR a b \\f(CB(2) c\\fR\n.\n.TP\n\\f(CBw\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is the \\fIw\\fPidth of the number between 1 and 5 included.\n\nFor an example, refer to the sub-option \\fBa\\fP above.\n.\n.TP\n\\f(CBf\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP controls if the numbering must \\fIf\\fPollow the last\nextracted number (defaults to \\f(CByes\\fP) or if it must remain\nindependent.\n\nThe possible values are \\f(CByes\\fP and \\f(CBno\\fP but can be abbreviated.\n\nExample:\n.br\n\\f(CRecho 2a b c | smenu -F -D l:\\\\( f:n n:1 -N\\fP\n.br\nWill display:\n\\f(CB(2)\\f(CR a \\f(CB(1)\\f(CR b \\f(CB(2)\\f(CR c\\fR\n\n.br\n\\f(CRecho 2a b c | smenu -F -D l:\\\\( f:y n:1 -N\\fP\n.br\nWill display:\n\\f(CB(2)\\f(CR a \\f(CB(3)\\f(CR b \\f(CB(4)\\f(CR c\\fR\n.\n.TP\n\\f(CBm\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP option)\nHere \\fBy\\fP controls if the numbering of word with missing embedded numbers\nmust be done or not (defaults to \\f(CByes\\fP).\n\nWhen this sub-option is set to \\f(CBno\\fP, the \\f(CBs\\fP and \\f(CBf\\fP\nsub-options are ignored.\n\nThe possible values are \\f(CByes\\fP and \\f(CBno\\fP but can be abbreviated.\n.\nExample:\n.br\n\\f(CRecho 2a b c | smenu -F -D l:\\\\( n:1 m:n -N\\fP\n.br\nWill display:\n\\f(CB(2)\\f(CR a     b     c\\fR\n\n\\f(CRecho 2a b c | smenu -F -D l:\\\\( n:1 m:y -N\\fP\n.br\nWill display:\n\\f(CB(2)\\f(CR a \\f(CB(3)\\f(CR b \\f(CB(4)\\f(CR c\\fR\n.TP\n\\f(CBh\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP option)\nTells what to do with the characters present before the embedded number if\nany.\n\nThe allowed directives are: '\\f(CBtrim\\fP' which discards them if they\nform an empty word (only made of spaces and tabulations), '\\f(CBcut\\fP'\nwhich unconditionally discards them and '\\f(CBkeep\\fP' which places them\nat the beginning of the resulting word.\n\nThe default value for this directive is '\\f(CBkeep\\fP', these keywords\ncan be abbreviated.\n\nExample:\n.br\n\\f(CBecho \\\\\" 2x\\\\\" | smenu -F -D l:\\\\( o:1 n:1\\fR\n.br\nWill display:\n.br\n\\f(CB(2)\\f(CR  x\\fR\n\\f(CR    ^^\\fR\n\\f(CB    \\fRSelection cursor\n\n\\f(CBecho \\\\\" 2x\\\\\" | smenu -F -D l:\\\\( o:1 n:1 h:t\\fR\n.br\nWill display:\n.br\n\\f(CB(2)\\f(CR x\\fR\n\\f(CR    ^\\fR\n\\f(CB    \\fRSelection cursor\n\n\\f(CBecho \\\\\"x2y\\\\\" | smenu -F -D l:\\\\( o:1 n:1 h:c\\fR\n.br\nWill display:\n.br\n\\f(CB(2)\\f(CR y\\fR\n.\n.TP\n\\f(CBo\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP option)\nHere \\fBy\\fP is the \\fIo\\fPffset of the first multibyte character of\nthe number to extract from the word (defaults to \\f(CB0\\fP).\n\nIf this offset if immediately followed by the character '\\f(CB+\\fP',\nthen the parser will look for the first number (if any) after the given\noffset instead of using its absolute value to extract the number.\n\nNote that when the '\\f(CB+\\fP' is used, it is necessary that the length\nof all the numbers to extract have the same size as the algorithm looks\nfor a digit to identify the beginning of the number to extract.\nHence, for example, \\fB1\\fP should appear as \\fB01\\fP in the input is\n\\f(CBn\\fP is set to \\f(CB2\\fP.\n\nExample:\n.br\n\\f(CBecho x2y xx3y | smenu -F -D l:\\\\( o:1+ n:1\\fR\n.br\nwill display:\n.br\n\\f(CB(2)\\f(CR xy \\f(CB(3)\\f(CR xxy\\fR\n\n\\f(CBecho x2y xx3y | smenu -F -D l:\\\\( o:1 n:1\\fR\n.br\nwill display (note the absence of the '\\f(CB+\\fP' character):\n.br\n\\f(CB(2)\\f(CR xy     xx3y\\fR\n.\n.TP\n\\f(CBn\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP option)\nHere \\fBy\\fP is the \\fIn\\fPumber of multibyte characters to extract\nfrom the word starting at the offset given by the \\f(CBo\\fP sub-option.\n\nExample: \\f(CRn:2\\fP will extract and use the first 2 digits of each\nwords from the input stream to number them.\n\n.TP\n\\f(CBi\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP option)\nHere \\fBy\\fP is number of multibyte characters to \\fIi\\fPgnore after\nthe extracted number\n.\n.TP\n\\f(CBd\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is a multibyte separator.\nWhen present, this directive instructs smenu to output the selected\nnumbered word(s) \\fIprefixed\\fP by its(their) direct access number(s)\nand the given separator.\n\nOnly the numbered word(s) will be prefixed.\n\n\\f(CBd\\fP stands for \\fBd\\fPecorate.\n\nThis directive can be useful when you want to post-process the output\naccording to its direct access number.\n\nExample:\n.br\n\\f(CBR=$(echo a b c | smenu -N -D d:-)\\fR\n.br\nwill display:\n.br\n\\f(CB1)\\f(CR a  \\f(CB2)\\f(CR b  \\f(CB3)\\f(CR c\\fR\n.br\nThe variable \\f(CBR\\fP will then contain the string \\f(CB2-b\\fP if\n\\f(CBb\\fP is selected.\n.\n.TP\n\\f(CBs\\fP (\\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP, \\\n\\fB-N\\fP|\\fB-number\\fP and \\fB-U\\fP|\\fB-unnumber\\fP options)\nHere \\fBy\\fP is the direct access number that will be set for the first\nnumbered word.\nIts value is \\fB1\\fP by default, a value of \\fB0\\fP is possible.\n\nExample:\n.br\n\\f(CBecho a b c | smenu -N -D s:1000\\fR\n.br\nwill display:\n.br\n\\f(CB1000)\\f(CR a  \\f(CB1001)\\f(CR b  \\f(CB1002) c\\fR\n.P\nTo number all words with the default parameters, use the\nsyntax: \"\\f(CR-N\\fP\" which is a shortcut for:\n\"\\f(CR-N -D l:' ' r:')' a:r p:a\\fP\"\n\nWhen the \\f(CBw\\fP sub-option is not given, the width of the numbers is\ndetermined automatically but if \\fB-F\\fP|\\fB-en\\fP|\\fB-embedded_number\\fP\nis set and the value of the \\f(CBn\\fP sub-option is given then this\nvalue is used.\n.RE\n.IP \"\\fB-b\\fP|\\fB-blank\\fP\"\n(Allowed in all contexts.)\n\nReplaces all non-printable characters by a blank.\nIf this results in a blank word, it will be potentially deleted.\n.IP \"\\fB-.\\fP|\\fB-dot\\fP|\\fB-invalid\\fP\"\n(Allowed in all contexts.)\n\nSets the substitution character for non-printable characters.\nWhen this parameter is not used, the default substitution character is\na single dot.\n.IP \"\\fB-M\\fP|\\fB-middle\\fP|\\fB-center\\fP\"\n(Allowed in all contexts.)\n\nCenters the display if possible.\n.IP \"\\fB-d\\fP|\\fB-restore\\fP|\\fB-delete\\fP|\\fB-clean\\fP|\\fB-delete_window\\fP|\\\n\\fB-clean_window\\fP\"\n(Allowed in all contexts.)\n\nTells the program to clean up the display before quitting by removing\nthe selection window after use as if it was never displayed.\n.IP \"\\fB-c\\fP|\\fB-col\\fP|\\fB-col_mode\\fP|\\fB-column\\fP\"\n(Allowed in the \"Main\" and \"Tagging\" contexts, switches to the \"Columns\"\ncontext.)\n\nSets the column mode.\nIn this mode the lines of words do not wrap when the right border of\nthe terminal is reached but only when a special character is read.\nSome words will not be displayed without an horizontal scrolling.\n\nIf such a scrolling is needed, some indications may appear on the left\nand right edge of the window to help the user to reach the unseen words.\n\nIn this mode, the width of each column is minimal to keep the maximum\ninformation visible on the terminal.\n.IP \"\\fB-l\\fP|\\fB-line\\fP|\\fB-line_mode\\fP\"\n(Allowed in the \"Main\" and \"Tagging\" contexts, switches to the \"Lines\"\ncontext.)\n\nSets the line mode.\nThis mode is the same as column mode but without any column alignment.\n.IP \"\\fB-t\\fP|\\fB-tab\\fP|\\fB-tab_mode\\fP|\\fB-tabulate_mode\\fP [\\fIcols\\fP]\"\n(Allowed in the \"Main\" and \"Tagging\" contexts, switches to the\n\"Tabulations\" context.)\n\nThis option sets the tabulation mode and, if a number is specified,\nattempts to set the number of displayed columns to that number.\n\nIn this mode, embedded line separators are ignored if not explicitly set\nwith \\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\fB-line_separators\\fP.\nThe options \\fB-A\\fP|\\fB-fc\\fP|\\fB-first_column\\fP and\n\\fB-Z\\fP|\\fB-lc\\fP|\\fB-last_column\\fP can nevertheless be used to\nforce words to appear in the first (respectively last) position of the\ndisplayed line.\n.PP\n.RS\nNote that the number of requested columns will be automatically reduced\nif a word does not fit in the calculated column size.\n.PP\nIn this mode each column has the same width.\n.RE\n.IP \"\\fB-w\\fP|\\fB-wide\\fP|\\fB-wide_mode\\fP\"\n(Allowed in the \"Columns\" and \"Tabulations\" contexts.)\n\nWhen \\fB-t\\fP|\\fB-tab\\fP|\\fB-tab_mode\\fP|\\fB-tabulate_mode\\fP is followed\nby a number of columns, the default is to compact the columns so that they\nuse the less terminal width as possible.\nThis option enlarges the columns in order to use the whole terminal width.\n\nWhen in column mode, \\fB-w\\fP|\\fB-wide\\fP|\\fB-wide_mode\\fP can be used\nto force all the columns to have the same size (the largest one).\nSee option \\fB-c\\fP|\\fB-col\\fP|\\fB-col_mode\\fP|\\fB-column\\fP below.\n.PP\n.RS\nNote that the column's size is only calculated once when the words are\ndisplayed for the first time.\nA terminal resize will not update this value.\nThis choice enables a faster display.\n.RE\n.PP\n.IP \"\\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP... \\\n[\\fIi\\fP|\\fII\\fP|\\fIe\\fP|\\fIE\\fP|\\\n\\fIl\\fP|\\fIL\\fP|\\fIr\\fP|\\fIR\\fP|\\fIc\\fP|\\fIC\\fP|\\\n\\fIa\\fP|\\fIA\\fP]\\\n[\\fIselectors\\fP]...\"\n(Allowed in the \"Columns\" context.)\n\nIn column mode, this option is useful for performing specific actions\non a set of columns.\n\nThese actions varies according to the directive given:\n.br\n- You can include (directive \\fIi\\fP or \\fII\\fP) or exclude (\\fIe\\fP or\n\\fIE\\fP) a set of selectable columns.\n.br\n- You can specified the kind of alignment (left, right or center) of the\nset of columns with the directives \\fIl\\fP, \\fIL\\fP, \\fIr\\fP, \\fIR\\fP,\n\\fIc\\fP or \\fIC\\fP.\n.br\n- You can also specified the attributes (colors...) of the set of columns\nwith the directives \\fIa\\fP or \\fIA\\fP.\n\nWhen the directive is missing, the \"include\" directive is assumed\n(\\fIi\\fP).\n\nNote that it is best to use the lower case version of these directives,\nas their upper case alternative may have other meanings in the future.\n\nIn selectors, columns can be designated by their number (starting with\n1) or by regular expressions surrounded by delimiters consisting of\nany printable ASCII character, except spaces and unprotected commas;\ncommas can be protected by backslashes ('\\fCD\\\\\\fP')).\n\nColumn ranges are defined  by separating their numbers with a dash. Open\ninterval to the left or right are allowed, so these interval descriptions\nmay be preceded or followed by a dash (e.g. \\f(CB5-7\\fP, \\f(CB-2\\fP\nor \\f(CB8-\\fP are allowed).\n\n\\fBWARNING\\fP: ranges of regular expressions are not yest supported.\n\nWhen using the \\fIa\\fP|\\fIA\\fP directive, an attribute \\fBmust\\fP be\nappended prefixed by a colon (':') as in \\f(CB-C a1-2:6+b\\fP per example.\nRefer to the attribute option (\\fB-a\\fP|\\fB-attr\\fP|\\fB-attributes\\fP)\nfor more details.\n\nMultiple selectors can be regrouped in one argument using commas to\nseparate them.\n\nThis option also accepts multiple arguments, each of them being a\nselector.\n\nA selection by regular expressions means that a column containing a word\nmatching any of these expressions will be included or excluded depending\non the letter given after the option or before the selector if there is\nmore than one argument.\n\nRegular expressions and column numbers can be freely mixed.\n\nThis option also sets the default alignment of column contents when no\narguments are provided.\nFor example: \\f(CB-Cr -Cl1\\fP sets the default alignment to the right\nand the alignment of the contents of column 1 to the left.\nAt the beginning, no default alignment of the column contents is set.\n\nRegular expression in \\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP and\n\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP can contain \\fBUTF-8\\fP\ncharacters either directly or by using the \\fI\\\\u\\fP or \\fI\\\\U\\fP notation.\n\nExample of columns selection: \\f(CB-Ci2,3,/X./,5-7\\fP forces the cursor\nto only navigate in columns \\fB2\\fP,\\fB3\\fP,\\fB5\\fP,\\fB6\\fP and \\fB7\\fP\nand those containing a two characters word starting with '\\fBX\\fP'.\nIf \\fIe\\fP was used in place of \\fIi\\fP, all the columns would have been\nselected \\fBexcept\\fP the columns \\fB2\\fP,\\fB3\\fP,\\fB5\\fP,\\fB6\\fP,\\fB7\\fP\nand those matching the extended regular expression '\\f(CBX.\\fP'.\n\nExample of defining the attributes of a column set:\n\\f(CB-C a2-6:7/4+b\\fP forces the columns from 2 to 6 to be bold and have\na foreground color equal to 7 and a background color equal to 4.\n\nExample of mixing alignment and inclusion/exclusion directives:\n\\f(CB-Ci1-5 -Ce/a+/ -Cr7,/b+/\\fP makes columns 1 to 5 selectable, makes\ncolumns whose content starts with \"a\" non selectable and aligns the\ncontent of the column 7 to the left.\n\nSpaces are allowed in the selection string if they are protected.\n\nWhen an alignment directive is used and without any column selection,\nthen the specified alignment becomes the default one, E.g: \\f(CB-Cr\\fP\nsets alignment the default one to the right.\n\nOther example where multiple selectors are used as multiple arguments:\n\\f(CBps | smenu -col -cols e/TTY/ e/CMD/ e3\\fP\n\n\\fBWarning\\fP, if this option appears on the command line before any\n\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP option, the specified\ncolumn alignments will be protected from any future row alignment\ndirectives.\nOtherwise row alignment directives will take precedence. For example:\n\n\\f(CBecho \"a b c\\\\\\\\naa bb cc\\\\\\\\naaaa bbbb cccc\"\n| smenu -c -g\\\\| -C c2 -R r2\\fP\n.br\n.nf\nGives:\n\\f(CRa   | b  |c\\fP\n\\f(CR  aa| bb |  cc <-- \\fPCol. 2 remains centered as \\f(CB-C\\fP was used first.\n\\f(CRaaaa|bbbb|cccc\\fP\n.fi\n\nBut\n\\f(CBecho \"a b c\\\\\\\\naa bb cc\\\\\\\\naaaa bbbb cccc\"\n| smenu -c -g\\\\| -R r2 -C c2\\fP\n.br\n.nf\nGives:\n\\f(CRa   | b  |c\\fP\n\\f(CR  aa|  bb|  cc <-- -R\\fP takes precedence as it was used first.\n\\f(CRaaaa|bbbb|cccc\\fP\n.fi\n.IP \"\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP... \\fIselectors\\fP...\"\n(Allowed in the \"Columns\" and \"Lines\" contexts.)\n\nSimilar to \\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP but for\nthe rows.\n\n\\fBWarning\\fP, the directives \\fIl\\fP, \\fIL\\fP, \\fIr\\fP, \\fIR\\fP, \\fIc\\fP\nand \\fIC\\fP are only allowed in column mode.\n\n\\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP and\n\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP can be used more than\nonce in a cumulative manner:\n\nThe selection mode (selection or de-selection) is given by the first\noccurrence of the options, the other occurrences will only update the\nselected or de-selected ranges.\n\nOnce a column or a row has been excluded, it cannot be re-included.\n.IP \"\\fB-al\\fP|\\fBalign\\fP... \\fIregex_selectors\\fP...\"\n(Allowed in the \"Columns\" context.)\n\nThis option is similar to\n\\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP and\n\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP but allows to\nalign all words matched by on of the regular expression defined in\n\\fIregex_selectors\\fP\n\nThis option only accepts a list of regular expressions.\n\nE.g.: \\f(CB-al c/a+/,/b+/\\fP\n\n\\fB-al\\fP|\\fBalign\\fP,\n\\fB-C\\fP|\\fB-cs\\fP|\\fB-cols\\fP|\\fB-cols_select\\fP and\n\\fB-R\\fP|\\fB-rs\\fP|\\fB-rows\\fP|\\fB-rows_select\\fP can be used more than\nonce in a cumulative manner.\n\nWord alignments with this option take precedence over row and column\nalignments.\n.IP \"\\fB-A\\fP|\\fB-fc\\fP|\\fB-first_column\\fP \\fIregex\\fP\"\n(Allowed in the following contexts: \"Columns\", \"Lines\" and \"Tabulations\".)\n\nIn column mode, forces all words matching the given regular expression\nto be the first one in the displayed line.\nIf you want to only rely on this method to build the lines, just specify\nan empty \\fBregex\\fP to set the end-of-line separator with\n\\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\fB-line_separators\\fP '')\n.PP\n.RS\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can also be used in the regexp after\n\\fB-A\\fP|\\fB-fc\\fP|\\fB-first_column\\fP.\n.RE\n.IP \"\\fB-Z\\fP|\\fB-lc\\fP|\\fB-last_column\\fP \\fIregex\\fP\"\n(Allowed in the following contexts: \"Columns\", \"Lines\" and \"Tabulations\".)\n\nSimilar to \\fB-A\\fP|\\fB-fc\\fP|\\fB-first_column\\fP but forces the word\nto be the latest of its line.\nThe same trick with\n\\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\fB-line_separators\\fP\ncan also be used.\n.PP\n.RS\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can also be used in the regexp after\n\\fB-Z\\fP|\\fB-lc\\fP|\\fB-last_column\\fP.\n.RE\n.IP \"\\fB-g\\fP|\\fB-gutter\\fP [\\fIstring\\fP]\"\n(Allowed in the \"Columns\" and \"Tabulations\" contexts.)\n\nReplaces the blank after each words in column or tabular mode by a column\nseparator.\n\nThis separator is extracted from the \\fIstring\\fP argument and each\nof its (multibyte) character is used one after the other to fill\nthe gutter.\n\nIf there are more columns that gutter characters then the last character\nis used for the remaining columns.\n\nWhen not given, the separator defaults to a vertical bar \\fI|\\fP (or a\nfull height vertical bar if the locale is set to \\fBUTF-8\\fP).\n\nEach character can be given in normal or \\fI\\\\u\\fP or \\fI\\\\U\\fP form in\nthe \\fIstring\\fP argument.\n\nExample: \"\\f(CB|- \\fP\" will allow one to separate the first two columns\nwith '\\f(CB|\\fP', then '\\f(CB-\\fP' will be used and '\\f(CB \\fP' will\nseparate the remaining columns if any.\n.IP \"\\fB-k\\fP|\\fB-ks\\fP|\\fB-keep_spaces\\fP\"\n(Allowed in all contexts.)\n\nBy default, the spaces surrounding the output string will be deleted.\nThis option forces them to be retained.\n.IP \"\\fB-W\\fP|\\fB-ws\\fP|\\fB-wd\\fP|\\fB-word_delimiters\\fP|\\\n\\fB-word_separators\\fP \\fIbytes\\fP\"\n(Allowed in all contexts.)\n\nThis option can be used to specify the characters (or multibyte\nsequences) which will be used to delimit the input words.\n\nEach character or multibyte sequence in the given argument will be\nunderstood as a word delimiter.\n\nMultibyte sequences (\\fBUTF-8\\fP) can be natives of using the same ASCII\nrepresentation used in words (a leading \\fI\\\\u\\fP or \\fI\\\\U\\fP following\nby up to 8 hexadecimal characters for the former and 6 hexadecimal\ncharacters for the latter).\n\nNon-printable characters in arguments should be given using the standard\n\\fI$''\\fP representation.\n\\fI$'\\\\t'\\fP stands for the tabulation character for example.\n\nThe default delimiters are: \\fISPACE\\fP, \\fI$'\\\\t'\\fP and \\fI$'\\\\n'\\fP.\n.IP \"\\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\\n\\fB-line_separators\\fP \\fIbytes\\fP\"\n(Allowed in all contexts.)\n\nThis option can be used to specify the characters (or multibyte\nsequences) which will be used to delimit the lines in the input stream.\n\nEach character or multibyte sequence in the given argument will be\nunderstood as a line delimiter.\n\nMultibyte sequences (\\fBUTF-8\\fP) can be natives of using the same ASCII\nrepresentation used in words (a leading \\fI\\\\u\\fP or \\fI\\\\U\\fP following\nby up to 8 hexadecimal characters for the former and 6 hexadecimal\ncharacters for the latter).\n\nNon-printable characters in arguments should be given using the standard\n$'' representation.\n$'\\\\n' stands for the newline character for example.\n\nThe default delimiter is: \\fI$'\\\\n'\\fP.\n\nThis option is only useful when the\n\\fB-c\\fP|\\fB-col\\fP|\\fB-col_mode\\fP|\\fB-column\\fP or \\fB-l\\fP option is\nalso set.\n\nThe characters (or multibyte sequences) passed to\n\\fB-L\\fP|\\fB-ls\\fP|\\fB-ld\\fP|\\fB-line-delimiters\\fP|\\fB-line_separators\\fP are\nautomatically added to the list of word delimiters as if\n\\fB-W\\fP|\\fB-ws\\fP|\\fB-wd\\fP|\\fB-word_delimiters\\fP|\\fB-word_separators\\fP was\nalso used.\n\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can also be used here.\n.TP\n.IP \"\\fB-q\\fP|\\fB-no_bar\\fP|\\fB-no_scroll_bar\\fP\"\n(Allowed in all contexts.)\n\nPrevents the display of the lateral scroll bar.\nThis also prevents the display of the horizontal scroll bar.\n.IP \"\\fB-no_hbar\\fP|\\fB-no_hor_scroll_bar\\fP\"\n(Allowed in the \"Columns\" and \"Lines\" contexts.)\n\nPrevents the display of the horizontal scroll bar.\n.IP \"\\fB-hbar\\fP|\\fB-hor_scroll_bar\\fP\"\n(Allowed in the \"Columns\" and \"Lines\" contexts.)\n\nForces the display of the horizontal scroll when at least one line will be\ntruncated.\nThis is the case even if the current line or lines being currently\ndisplayed are not truncated.\n\nWhen the \\fB-no_hbar\\fP|\\fB-no_hor_scroll_bar\\fP or\n\\fB-q\\fP|\\fB-no_bar\\fP|\\fB-no_scroll_bar\\fP are also present then this\noption is ignored.\n.IP \"\\fB-S\\fP|\\fB-subst\\fP... \\\n/\\fIregex\\fP/\\fIrepl\\fP/[\\fIg\\fP][\\fIv\\fP][\\fIs\\fP]\"\n(Allowed in all contexts.)\n\nPost-processes the words by applying a regular expression based\nsubstitution.\nThe argument must be formatted as in the \\fBsed\\fP editor.\n\nAs in \\fBsed\\fP, matching groups and references to these groups\n(from \\f(CB\\\\0\\fP to \\f(CB\\\\9\\fP in \\fIrepl\\fP) are supported.\nThese groups must be surrounded by \\f(CB(\\fP and \\f(CB)\\fP in \\fIregex\\fP.\n\\f(CB\\\\0\\fP and \\f(CB&\\fP are equivalent in \\fIrepl\\fP as in the GNU\nversion of \\fBsed\\fP.\n\nBack reference example:\n\n.nf\n\\f(CBR=$(echo \"[A] [B] [C]\" | ./smenu -S '/([^][]+)/:\\\\1:/')\\fP\nwill display \\f(CR\"[:A:] [:B:] [:C:]\"\\fP\n.fi\n\nThis option can be used more than once.\nEach substitution will be applied in sequence on each word.\nThis sequence can be stopped if a \\fBstop\\fP flag is encountered.\n\n.RS\n\\fBflags:\\fP\n.IP \\(bu 2\nThe optional trailing \\fBg\\fP (for \\fIg\\fPlobal) means that all matching\noccurrences shall be replaced and not only the first one.\n.IP \\(bu 2\nThe optional trailing \\fBv\\fP (for \\fIv\\fPisual) means that the altered\nwords will only be used for display and search.\nThe modifications will \\fInot\\fP be reflected in the returned word.\n.IP \\(bu 2\nThe optional trailing \\fBs\\fP (for \\fIs\\fPtop) means that no\nmore substitution will be allowed on this word even if another\n\\fB-S\\fP|\\fB-subst\\fP is used.\n.IP \\(bu 2\nThe optional trailing \\fBi\\fP (for \\fIi\\fPgnore case) means that the\nstring search operation should ignore the case for this pattern.\n\nSmall examples to explain the meaning of \\fIv\\fP:\n\n.nf\n\\f(CBR=$(echo a b c | smenu -S /b/B/)\\fP\n.fi\nwill display \\f(CR\"a B c\"\\fP and \\f(CBR\\fP will contain \\fIB\\fP\nwhen \\fIB\\fP is selected meanwhile\n\n.nf\n\\f(CBR=$(echo a b c | smenu -S /b/B/\\fBv\\fP)\\fR\n.fi\nwill display the same as above but \\f(CBR\\fP will contain the original\nword \\fIb\\fP when \\fIB\\fP is selected.\n\nIn both cases, only the word \\fIB\\fP will be searchable and not \\fIb\\fP.\n.RE\n.IP \"\\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP... \\\n/\\fIregex\\fP/\\fIrepl\\fP/[\\fIg\\fP][\\fIv\\fP][\\fIs\\fP]\"\n(Allowed in all contexts.)\n\nPost-processes the \\fBselectable\\fP words by applying a regular\nexpression based substitution (see \\fB-S\\fP|\\fB-subst\\fP for details).\n.IP \"\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP... \\\n/\\fIregex\\fP/\\fIrepl\\fP/[\\fIg\\fP][\\fIv\\fP][\\fIs\\fP]\"\n(Allowed in all contexts.)\n\nPost-processes the \\fBexcluded\\fP (or \\fBnon-selectable\\fP)\nwords by applying a regular expression based substitution (see\n\\fB-S\\fP|\\fB-subst\\fP for details).\n.PP\n.RS\nThe \\fB/\\fP separator that \\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP and\n\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP are using above can be\nsubstituted by any other character except \\fISPACE\\fP, \\fI\\\\t\\fP,\n\\fI\\\\f\\fP, \\fI\\\\n\\fP, \\fI\\\\r\\fP and \\fI\\\\v\\fP.\n.PP\nIn the three previous options, \\fIregex\\fP is a \\fBPOSIX\\fP\n\\fBE\\fPxtended \\fBR\\fPegular \\fBE\\fPxpression.\nFor details, please refer to the \\fBregex(7)\\fP manual page.\n.PP\nAdditionally \\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can also be used in\nthe regexp.\n.PP\n.RE\nIf a post-processing action\n(\\fB-S\\fP|\\fB-subst\\fP, \\fB-I\\fP|\\fB-si\\fP|\\fB-subst_included\\fP, \\\n\\fB-E\\fP|\\fB-se\\fP|\\fB-subst_excluded\\fP) results in an empty (length = 0)\nword, then we have two cases:\n.RS\n.IP \"in column mode:\"\nSubstitutions involving empty words can lead to misalignments, so it is\nnecessary to prohibit them and terminate the program.\nThese substitutions have to be made with other tools before using this\nutility.\n.IP \"otherwise:\"\nThe word is simply removed.\n.RE\n.IP \"\\fB-ES\\fP|\\fB-subst\\fP... \\\n/\\fIregex\\fP/\\fIrepl\\fP/[\\fIg\\fP][\\fIv\\fP][\\fIs\\fP]\"\n(Allowed in all contexts.)\n\nPre-processes words by applying a substitution based on a regular expression.\nThe argument must be formatted as in the \\fBsed\\fP editor.\n\nThe substitutions are made, as the name of the option indicates, before\nany other selection or coloring actions are made.\n\nThis option can be used more than once.\nEach substitution will be applied in sequence on each word.\nThis sequence can be stopped if a \\fBstop\\fP flag is encountered.\n\nIn summary, this option is similar to the \\fB-S\\fP|\\fB-subst\\fP option\npreviously described, except that the substitutions are made earlier and\ncertain flags like \\fBvisual\\fP are ignored.\n\nNote that this option can be used in conjunction with the other\nsubstitution options mentioned above.\n.IP \"\\fB-/\\fP|\\fB-search_method\\fP \\fIsearch_method\\fP\"\n(Allowed in all contexts.)\n\nAffects the '\\fB/\\fP' key to a search method.\nBy default '\\fB/\\fP' is affected to '\\fIfuzzy\\fP' but the argument can\nbe any prefix of '\\fIprefix\\fP', '\\fIsubstring\\fP' or '\\fIfuzzy\\fP'.\n.IP \"\\fB-s\\fP|\\fB-sp\\fP|\\fB-start\\fP|\\fB-start_pattern\\fP \\fIpattern\\fP\"\n(Allowed in all contexts.)\n\nPlace the cursor on the first word corresponding to the specified pattern.\n\nNote that although only the first matching word is highlighted,  all\nmatching words (if any) can be accessed using \\fBn\\fP/\\fBs\\fP/\\fBSPACE\\fP\nand \\fBN\\fP/\\fBS\\fP keys as if they were the result of one of the\nsearch actions.\n\nThese matching words can also be tagged at once if the tagging/pinning\nfunction is activated.  See the \"Tagging\" section for more information.\n\n\\fBESC\\fP can be used to disable navigation among matching words.\n\n\\fIpattern\\fP can be:\n.RS\n.IP \\(bu 2\nA \\fB#\\fP immediately followed by a \\fBnumber\\fP giving the initial\nposition of the cursor (counting from 0).\n\nIf the word at this position is excluded, then the first previous non\nexcluded word is selected if it exists, otherwise the first non excluded\nword is selected.\n\nIf this number if greater than the number of words, the cursor will be\nplaced on the latest selectable position.\n.IP \\(bu 2\nA single \\fB#\\fP or the string \\fB#last\\fP to set the initial\ncursor position on the latest selectable word position.\n.IP \\(bu 2\nA string starting with a \\fB/\\fP indicating that we want the cursor\nto be placed on the first word matching the given regular expression.\n.IP \\(bu 2\nA string starting with a \\fB=\\fP indicating than we want the cursor\nto be placed on that exact word.\n.IP \\(bu 2\nA normal string. In this case the cursor will be placed on the\nfirst word starting with that string (\\fBCa\\fP will match \\fBCancel\\fP\nby example).\n.PP\n\\fBWarning\\fP, when searching for a prefix or a regular expression, smenu\nonly looks for them after an eventual modification, so for example,\nthe command:\n\\f(CBsmenu -I/c/x/ -s/c <<< \"a b c d\"\\fP won't find c and put the cursor\non \\fBa\\fP but \\f(CBsmenu -I/c/x/v -s/c <<< \"a b c d\"\\fP will find it and\nput the cursor on the \\fBx\\fP substituting the \\fBc\\fP on screen only\n\n\\fI\\\\u\\fP and \\fI\\\\U\\fP sequences can be used in the pattern.\n.RE\n.IP \"\\fB-x\\fP|\\fB-tmout\\fP|\\fB-timeout\\fP \\fItype\\fP [\\fIword\\fP] \\fIdelay\\fP\"\n.IP \"\\fB-X\\fP|\\fB-htmout\\fP|\\fB-hidden_timeout\\fP \\fItype\\fP [\\fIword\\fP]\\\n \\fIdelay\\fP\"\n(Allowed in all contexts.)\n\nSets a timeout.\nThree types of timeout are possible:\n.RS\n.TP 10\ncurrent:\nAt the timeout, the word under the cursor and/or the tagged words are\nsent to the standard output if the \\fBENTER\\fP key has been pressed\n.TP 10\nquit:\nAt the timeout, nothing is selected as if the \\fBq\\fP key has been pressed\n.TP 10\nword:\nAt the timeout, the word given after the type is selected.\nNote that this word doesn't need to be part of the words coming from\nthe standard input.\n.PP\nEach type can be be shortened as a prefix of its full name (\"cur\" for\n\"current\" of \"q\" for \"quit\" per example).\n\nThe delay must be set in seconds and cannot be greater than 99999 seconds.\n\nThe remaining time (in seconds) is added at the end of the message\ndisplayed above the selection window and is updated in real time each\nsecond.\n\nAny key except \\fBENTER\\fP, \\fBq\\fP, \\fBQ\\fP and \\fBCTRL\\ C\\fP resets\nthe timer to its initial value.\n\nThe \\fB-X\\fP|\\fB-htmout\\fP|\\fB-hidden_timeout\\fP version works like\n\\fB-x\\fP|\\fB-tmout\\fP|\\fB-timeout\\fP but no periodic remaining messages\nis displayed above the selection window.\n.RE\n.IP \"\\fB-r\\fP|\\fB-auto_validate\\fP\"\n(Allowed in all contexts.)\n\nEnables \\fBENTER\\fP to validate the selection even in search mode.\n.IP \"\\fB-is\\fP|\\fB-incremental_search\\fP\"\n(Allowed in all contexts.)\n\nBy default, when a new search session is initiated, the current search\nbuffer is reset.\nWhen this parameter is set, the next search will start where the last\nsearch ended, except if \\fBESC\\fP was hit before.\n\nThis option instructs not to clean the previous search buffer each time\na new search session is started.\n.IP \"\\fB-v\\fP|\\fB-vb\\fP|\\fB-visual_bell\\fP\"\n(Allowed in all contexts.)\n\nBy default, when searching, an alarm is produced by the terminal when\nthe user enters a character or makes a move which lead to no result or\nto an error condition.\nThis argument make this beep visual by briefly showing the cursor.\n.IP \"\\fB-Q\\fP|\\fB-ignore_quotes\\fP\"\n(Allowed in all contexts.)\n\nUsing this option will remove the word grouping feature from single and\ndouble quotes which will be considered normal characters.\nFor example: \\f(CB\"a b\"\\fP will be considered by smenu as two words\n\\fB\"a\\fP and \\fBb\"\\fP and no more as a single word: \\fBa b\\fP.\n.IP \"\\fB-lim\\fP|\\fB-limits\\fP \\fIlimit:value\\fP...\"\n(Allowed in all contexts.)\n\nThis option gives the possibility to modify the default maximum number\nof words or columns and the maximum permitted word length.\n\nThe specified values overload the default settings and/or the settings\ngiven in the configuration files.\n\n.RS\nIn order to do that, three sub-options can be used:\n.IP \\fBl\\fP:value 2\nto set the maximum word length allowed.\n.IP \\fBw\\fP:value 2\nto set the maximum number of words allowed.\n.IP \\fBc\\fP:value 2\nto set the maximum number of columns allowed.\n.P\nSeveral sub-options, separated by spaces, can be given after this option.\n.RE\n\n.IP \"\\fB-f\\fP|\\fB-forgotten_timeout\\fP|\\fB-global_timeout\\fP \\fItimeout\\fP\"\n(Allowed in all contexts.)\n\nThis option defines a global timeout in seconds.\nThe program will end without error after this period of inactivity.\n\nThis timer is reset to its initial value each time a key is pressed.\n\nIts default value is \"unlimited\", but it can be changed by assigning a\nnumber (in tenths of seconds) to the \"forgotten\" entry in the [timers]\nsection of the optional configuration file.\nSee the example in the configuration sub-section.\n\nA \\fItimeout\\fP value equals to \\fB0\\fP explicitly disables this timer.\n.IP \"\\fB-nm\\fP|\\fB-no_mouse\\fP\"\n(Allowed in all contexts.)\n\nThis option allows you to disable the mouse even if smenu can use it.\n.IP \"\\fB-br\\fP|\\fB-buttons\\fP|\\fB-button_remapping\\fP \\fInew_button_1\\fP \\\n\\fInew_button_3\\fP\"\n(Allowed in all contexts.)\n\nThis option allows one to remap the mouse buttons.  The buttons are numbered\nfrom 1 to 3 but as smenu only uses buttons 1 and 3, only two arguments\nare required.\n\nBy example, the syntax \\f(CR-br 3 1\\fP will reverse the first (left)\nand third (right?) buttons.\n\nThe default mapping is \\f(CR1 3\\fP.\n.IP \"\\fB-dc\\fP|\\fB-dcd\\fP|\\fB-double_click\\fP|\\fB-double_click_delay\\fP \\\n\\fIdelay_in_ms\\fP\"\n(Allowed in all contexts.)\n\nThis option allows one to set the double-click delay in the range of 100 ms\n(1/10 second) to 500 ms (1/2 second).\nThe default delay of 150 ms (1/6.66 second) will be used if the given\nvalue is out of range or invalid.\n\nThe double-click capability can also be disabled by setting\n\\fIdelay_in_ms\\fP to \\fB0\\fP.\n\nThis setting is also configurable in a configuration file, see the\n[mouse] section in the example in the configuration sub-section.\n.IP \"\\fB-sb\\fP|\\fB-sbw\\fP|\\fB-show_blank_words\\fP [\\fIblank_char\\fP]\"\n(Allowed in all contexts.)\n\nNormally, blank words (words containing only space:.!fmt\ns) are only kept in column mode.\nWhen this option is present, these words are converted into a sequence\nof \\fIblank_char\\fP (or underscore if the optional parameter is absent)\nso that they are visible and not ignored when not in column mode.\n\n\\fIblank_char\\fP must be printable but not a space nor a multibyte\ncharacter.\n\nNote: These blank words remain blank even if they are now made\nvisible. They can still be excluded using \\f(CB-e '\\ '\\fP\nor \\f(CB-e '[ ]'\\fP per example.\n.SH NOTES\nIf tabulators (\\fI\\\\t\\fP) are embedded in the input, there is no way\nto replace them with the original number of spaces.\nIn this case use another filter (like \\fIexpand\\fR) to pre-process\nthe data.\n.SH EXAMPLES\n.SS 1\nSimple Yes/No/Cancel request with \"No\" as default choice:\n.PP\n.nf\n\\f(CRIn \\fBbash\\fP:\n  \\f(CBread R <<< $(echo \"Yes No Cancel\" \\\\\n               | smenu  -d -m \"Please choose:\" -s /N)\\fP\n\nor\n  \\f(CBR=$(echo \"Yes No Cancel\" \\\\\n      | smenu -d -m \"Please choose:\" -s /N)\\fP\n\nIn \\fBksh\\fP:\n  \\f(CBprint \"Yes No Cancel\"                \\\\\n  | smenu -d -m \"Please choose:\" -s /N \\\\\n  | read R\\fP\n\\fP\n.fi\n.SS 2\nGet a 3 columns report about VM statistics for the current process in\n\\fBbash\\fP/\\fBksh\\fP on Linux:\n.PP\n.nf\n\\f(CBR=$(grep Vm /proc/$$/status | expand | smenu -b -W$'\\\\n' -t3 -g -d)\\fB\n.PP\n\\fP\n.fi\n.SS 3\nCreate a one column selection window containing the list of the first\n20 LVM physical volumes.\nAt the end, the selection window will be erased.\nThis example is written in \\fBksh\\fP).\n.PP\n.nf\n\\f(CB\npvs -a -o pv_name --noheadings                 \\\\\n| smenu -m \"PV list\" -n20 -t1 -d -s //dev/root \\\\\n| read R\n\\fP\n.fi\n\nThe display will have a look similar to the following with the cursor\nset on the word \\fI/dev/root\\fP:\n\n.nf\n\\f(CRPV list\n/dev/md126           \\\\\n/dev/md127           |\n/dev/root            | <- cursor here.\n/dev/sda2            |\n/dev/sdb2            |\n/dev/sdc1            |\n/dev/sdc2            |\n/dev/system/homevol  /\n\\fP\n.fi\n.SS \"4 (advanced)\"\nImagine a file named \\fBsample.mnu\\fP with the following content:\n\n.nf\n\\f(CR--8<---------------------------------\n\"1 First Entry\" \"3 Third entry\"\n\"2 Second entry\" \"4 Fourth entry\"\n@@@ \"5 Fifth entry\"\n@@@\n\"0 Exit menu\"\n--8<---------------------------------\n\\fP\n.fi\n\nThen this quite esoteric command will render it (centered on the screen) as:\n\n.nf\n\\f(CR+----------------------------------+\n|            Test menu             |\n|                                  |\n| 1) First Entry   3) Third entry  |\n| 2) Second entry  4) Fourth entry |\n|                  5) Fifth entry  |\n|                                  |\n| 0) Exit menu                     |\n+----------------------------------+\n\\fP\n.fi\n\nwith the cursor on \\fIQuit\\fP and only the numbers and \"Quit\" selectable.\n\n\\f(CBR=$(smenu -q -d -s/Exit -M -n 30 -c        \\\\\n          -e \"@+\" -E '/@+/ /'              \\\\\n          -F -D n:1 i:1                    \\\\\n          -m \"Test menu\" < sample.mnu)\n\nThe selected entry will be available in \\f(CBR\\fP\n\nTry to understand it as an exercise.\n.SH ENVIRONMENT\n.TS\ntab(@);\nl l.\n\\fINO_COLOR\\fP@force a monochrome terminal when set.\n\\fICTXOPT_DEBUG\\fP@put the option parser in debug mode.\n.TE\n.SH BUGS/LIMITATIONS\nSome terminal emulators, those notably based on VTE version later than\n0.35 (see https://github.com/GNOME/vte/commit/01380d), have a new feature\nthat gives them the possibility to wrap/unwrap already displayed lines\nwhen resizing the window.\n\nAs far as I known, there is no terminfo entry to disable that.\n\nOn these types of terminals, the automatic re-display of the output of\nsmenu will be disturbed and some artifacts may appear on the screen if\nthe terminal window is resized.\n.SH AUTHORS\n\\(co 2015-present, Pierre Gentile (p.gen.progs@gmail.com)\n"
        },
        {
          "name": "smenu.c",
          "type": "blob",
          "size": 542.716796875,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <ctype.h>\n#include <time.h>\n#include <string.h>\n#include <unistd.h>\n#include <locale.h>\n#include <langinfo.h>\n#if (defined(__sun) && defined(__SVR4)) || defined(_AIX)\n#include <curses.h>\n#endif\n#include <term.h>\n#include <termios.h>\n#include <regex.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <wchar.h>\n\n#include \"xmalloc.h\"\n#include \"list.h\"\n#include \"index.h\"\n#include \"utf8.h\"\n#include \"fgetc.h\"\n#include \"utils.h\"\n#include \"ctxopt.h\"\n#include \"usage.h\"\n#include \"safe.h\"\n#define BUF_MALLOC xmalloc\n#define BUF_REALLOC xrealloc\n#include \"tinybuf.h\"\n#include \"smenu.h\"\n\n/* ***************** */\n/* Extern variables. */\n/* ***************** */\n\nextern ll_t *tst_search_list;\n\n/* ***************** */\n/* Global variables. */\n/* ***************** */\n\nword_t *word_a;       /* array containing words data (size: count).        */\nlong    count = 0;    /* number of words read from stdin.                  */\nlong    current;      /* index the current selection under the cursor).    */\nlong    new_current;  /* final cur. position, (used in search function).   */\nlong    prev_current; /* prev. position stored when using direct access.   */\n\nlong *line_nb_of_word_a;     /* array containing the line number (from 0)  *\n                              | of each word read.                         */\nlong *first_word_in_line_a;  /* array containing the index of the first    *\n                              | word of each lines.                        */\nlong *shift_right_sym_pos_a; /* screen column number of the right          *\n                              | scrolling symbol if any when in line or    *\n                              | column mode.                               */\n\nint forgotten_timer = -1;\nint help_timer      = -1;\nint winch_timer     = -1;\nint daccess_timer   = -1;\nint search_timer    = -1;\n\nsearch_mode_t search_mode     = NONE;\nsearch_mode_t old_search_mode = NONE;\n\nint help_mode = 0; /* 1 if help is displayed else 0. */\n\nint marked = -1; /* Index of the marked word or -1. */\n\nchar *word_buffer;\n\nint (*my_isprint)(int);\nint (*my_isempty)(const unsigned char *);\n\n/* UTF-8 useful symbols. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n/* clang-format off */\nchar * left_arrow      = \"\\xe2\\x86\\x90\"; /* ← leftwards arrow.               */\nchar * up_arrow        = \"\\xe2\\x86\\x91\"; /* ↑ upwards arrow.                 */\nchar * right_arrow     = \"\\xe2\\x86\\x92\"; /* → rightwards arrow.              */\nchar * down_arrow      = \"\\xe2\\x86\\x93\"; /* ↓ downwards arrow.               */\nchar * vertical_bar    = \"\\xe2\\x94\\x82\"; /* │ box drawings light vertical.   */\nchar * shift_left_sym  = \"\\xe2\\x97\\x80\"; /* ◀ black left-pointing triangle.  */\nchar * shift_right_sym = \"\\xe2\\x96\\xb6\"; /* ▶ black right-pointing triangle. */\nchar * sbar_line       = \"\\xe2\\x94\\x82\"; /* │ box drawings light vertical.   */\nchar * hbar_line       = \"\\xe2\\x94\\x80\"; /* ─ box drawings light horizontal. */\nchar * hbar_left       = \"\\xe2\\x97\\x80\"; /* ◀ black left-pointing triangle.  */\nchar * hbar_right      = \"\\xe2\\x96\\xb6\"; /* ▶ black right-pointing triangle. */\nchar * sbar_top        = \"\\xe2\\x94\\x90\"; /* ┐ box drawings light down and l. */\nchar * sbar_down       = \"\\xe2\\x94\\x98\"; /* ┘ box drawings light up and l.   */\nchar * hbar_begin      = \"\\xe2\\x94\\x94\"; /* └ box drawings light up and r.   */\nchar * hbar_end        = \"\\xe2\\x94\\x98\"; /* ┘ box drawings light up and l.   */\nchar * sbar_curs       = \"\\xe2\\x94\\x83\"; /* ┃ box drawings heavy vertical.   */\nchar * hbar_curs       = \"\\xe2\\x94\\x81\"; /* ━ box drawings heavy horizontal. */\nchar * sbar_arr_up     = \"\\xe2\\x96\\xb2\"; /* ▲ black up pointing triangle.    */\nchar * sbar_arr_down   = \"\\xe2\\x96\\xbc\"; /* ▼ black down pointing triangle.  */\nchar * msg_arr_down    = \"\\xe2\\x96\\xbc\"; /* ▼ black down pointing triangle.  */\n/* clang-format on */\n\n/* Mouse tracking. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nchar *mouse_trk_on;\nchar *mouse_trk_off;\n\n/* Variables used to manage the direct access entries. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ndaccess_t daccess;\nchar     *daccess_stack;\nint       daccess_stack_head;\n\n/* Variables used for fuzzy and substring searching. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nlong *matching_words_da = NULL; /* Array containing the index of all *\n                                 | matching words.                   */\n\nlong *best_matching_words_da = NULL; /* Array containing the index of *\n                                      | matching words containing a   *\n                                      | consecutive suite of matching *\n                                      | glyphs.                       */\n\nlong *alt_matching_words_da = NULL; /* Alternate array to contain only *\n                                     | the matching candidates having  *\n                                     | potentially a starting/ending   *\n                                     | pattern.                        */\n\n/* Variables used in signal handlers. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nvolatile sig_atomic_t got_winch          = 0;\nvolatile sig_atomic_t got_winch_alrm     = 0;\nvolatile sig_atomic_t got_forgotten_alrm = 0;\nvolatile sig_atomic_t got_help_alrm      = 0;\nvolatile sig_atomic_t got_daccess_alrm   = 0;\nvolatile sig_atomic_t got_search_alrm    = 0;\nvolatile sig_atomic_t got_timeout_tick   = 0;\nvolatile sig_atomic_t got_sigpipe        = 0;\nvolatile sig_atomic_t got_sigsegv        = 0;\nvolatile sig_atomic_t got_sigterm        = 0;\nvolatile sig_atomic_t got_sighup         = 0;\n\n/* Variables used when a timeout is set (option -x). */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntimeout_t timeout;\nchar     *timeout_word;      /* printed word when the timeout type is WORD. */\nchar     *timeout_seconds;   /* string containing the number of remaining   *\n                              | seconds.                                    */\nint       quiet_timeout = 0; /* 1 when we want no message to be displayed.  */\n\n/* *************** */\n/* Help functions. */\n/* *************** */\n\n/* ============================================================ */\n/* Parse, create and add an help entry.                         */\n/* - attributes are preprocessed for a future quicker display.  */\n/* - special entries t,m and c allow to ignore entries when not */\n/*   in tag mode, when the mouse is not usable or when not in   */\n/*   column mode.                                               */\n/*                                                              */\n/* entries       IN  array of help data.                        */\n/* help_items_da OUT dynamic array to be updated.               */\n/*                                                              */\n/* Return the number of help entries added in help_items_da.    */\n/* ============================================================ */\nint\nhelp_add_entries(win_t               *win,\n                 term_t              *term,\n                 toggle_t            *toggles,\n                 help_attr_entry_t ***help_items_da,\n                 help_entry_t        *entries,\n                 int                  entries_nb)\n{\n  int index;\n  int nb = 0;\n\n  help_attr_entry_t *attr_entry;\n\n  for (index = 0; index < entries_nb; index++)\n  {\n    /* Do not create a tag/pin related entry if tagging/pinning is not */\n    /* enabled.                                                        */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strchr(entries[index].flags, 't') && !toggles->taggable\n        && !toggles->pinable)\n      continue;\n\n    /* Do not create a mouse related entry if -no_mouse is activated. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strchr(entries[index].flags, 'm') && toggles->no_mouse)\n      continue;\n\n    /* Do not create a column/row related entry if the column or line_mode */\n    /* is not activated.                                                   */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strchr(entries[index].flags, 'c') && !win->line_mode && !win->col_mode)\n      continue;\n\n    /* Allocate and initialize a new attribute. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    attr_entry = xmalloc(sizeof(help_attr_entry_t));\n\n    attr_entry->str  = xstrdup(entries[index].str);\n    attr_entry->len  = entries[index].len;\n    attr_entry->attr = attr_new();\n\n    if (term->colors > 0)\n      parse_attr(entries[index].main_attr_str, attr_entry->attr, term->colors);\n    else\n      parse_attr(entries[index].alt_attr_str, attr_entry->attr, term->colors);\n\n    /* Add it into a dynamic array. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    BUF_PUSH(*help_items_da, attr_entry);\n\n    nb++;\n  }\n\n  return nb;\n}\n\n/* ======================================================== */\n/* Create an array of lines to be displayed by disp_help.   */\n/* Created lines will have a dynamic length with leading    */\n/* spaces removed.                                          */\n/*                                                          */\n/* last_line     IN  last logical line number (from 0).     */\n/* help_items_da OUT dynamic array to be updated.           */\n/*                                                          */\n/* Return the dynamic array containing help data with       */\n/*        attributes processed.                             */\n/* ======================================================== */\nhelp_attr_entry_t ***\ninit_help(win_t               *win,\n          term_t              *term,\n          toggle_t            *toggles,\n          long                 last_line,\n          help_attr_entry_t ***help_items_da)\n{\n  int index;            /* used to identify the objects long the help line. */\n  int entries_nb;       /* number of all potentially displayable help       *\n                         | entries.                                         */\n  int entries_total_nb; /* number of help entries to display.               */\n  int line = 0;         /* number of windows lines used by the help line.   */\n  int len  = 0;         /* length of the help line.                         */\n  int max_col;          /* when to split the help line.                     */\n  int forced_nl;\n  int first_in_line;\n\n  /* array of arrays containing help items.                        */\n  /* the content of this darray will be returned by this function. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  help_attr_entry_t ***help_lines_da = NULL;\n\n  /* array of help items, element of help_lines_da. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  help_attr_entry_t **items_da = NULL;\n\n  entries_nb = BUF_LEN(*help_items_da);\n\n  if (entries_nb == 0)\n  {\n    char *Cleft_arrow  = concat(\"^\", left_arrow, (char *)0);\n    char *Cright_arrow = concat(\"^\", right_arrow, (char *)0);\n    char *du_arrows    = concat(down_arrow, up_arrow, (char *)0);\n    char *arrows       = concat(left_arrow,\n                          down_arrow,\n                          up_arrow,\n                          right_arrow,\n                          (char *)0);\n\n    help_entry_t header_entries[] = {\n      { \"Start\", 5, \"u\", \"u\", \"\" },     { \" \", 1, \"u\", \"u\", \"\" },\n      { \"of\", 2, \"u\", \"u\", \"\" },        { \" \", 1, \"u\", \"u\", \"\" },\n      { \"quick\", 5, \"u\", \"u\", \"\" },     { \" \", 1, \"u\", \"u\", \"\" },\n      { \"help.\", 5, \"u\", \"u\", \"\" },     { \" \", 1, \"u\", \"u\", \"\" },\n      { \"jk\", 2, \"bu\", \"bu\", \"\" },      { \"/\", 1, \"u\", \"u\", \"\" },\n      { du_arrows, 2, \"bu\", \"bu\", \"\" }, { \" \", 1, \"u\", \"u\", \"\" },\n      { \"to\", 2, \"u\", \"u\", \"\" },        { \" \", 1, \"u\", \"u\", \"\" },\n      { \"scroll.\", 7, \"u\", \"u\", \"\" },   { \" \", 1, \"u\", \"u\", \"\" },\n      { \"\\\"\", 1, \"u\", \"u\", \"\" },        { \"man\", 3, \"bu\", \"bu\", \"\" },\n      { \" \", 1, \"u\", \"u\", \"\" },         { \"smenu\", 5, \"bu\", \"bu\", \"\" },\n      { \"\\\"\", 1, \"u\", \"u\", \"\" },        { \" \", 1, \"u\", \"u\", \"\" },\n      { \"for\", 3, \"u\", \"u\", \"\" },       { \" \", 1, \"u\", \"u\", \"\" },\n      { \"more\", 4, \"u\", \"u\", \"\" },      { \" \", 1, \"u\", \"u\", \"\" },\n      { \"help.\", 5, \"u\", \"u\", \"\" },\n    };\n\n    help_entry_t generic_entries[] = {\n      { \"\\n\", 0, \"\", \"\", \"\" },\n      { \"Move:\", 5, \"5+b\", \"r\", \"\" },\n      { \"Mouse:\", 6, \"2\", \"u\", \"m\" },\n      { \"B1\", 2, \"b\", \"b\", \"m\" },\n      { \",\", 1, \"\", \"\", \"m\" },\n      { \"B3\", 2, \"b\", \"b\", \"m\" },\n      { \",\", 1, \"\", \"\", \"m\" },\n      { \"Wheel\", 5, \"b\", \"b\", \"m\" },\n      { \" \", 1, \"\", \"\", \"m\" },\n      { \"Keyb:\", 5, \"2\", \"u\", \"m\" },\n      { \"hjkl\", 4, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { arrows, 4, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"PgUp\", 4, \"b\", \"b\", \"\" },\n      { \"/\", 1, \"\", \"\", \"\" },\n      { \"Dn\", 2, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"c\" },\n      { \"S-HOME\", 6, \"b\", \"b\", \"c\" },\n      { \"/\", 1, \"\", \"\", \"c\" },\n      { Cleft_arrow, 2, \"b\", \"b\", \"c\" },\n      { \"/\", 1, \"\", \"\", \"c\" },\n      { \"H\", 1, \"b\", \"b\", \"c\" },\n      { \",\", 1, \"\", \"\", \"c\" },\n      { \"S-END\", 5, \"b\", \"b\", \"c\" },\n      { \"/\", 1, \"\", \"\", \"c\" },\n      { Cright_arrow, 2, \"b\", \"b\", \"c\" },\n      { \"/\", 1, \"\", \"\", \"c\" },\n      { \"L\", 1, \"b\", \"b\", \"c\" },\n      { \"\\n\", 0, \"\", \"\", \"c\" },\n      { \"Shift:\", 6, \"5+b\", \"r\", \"c\" },\n      { \"<\", 1, \"b\", \"b\", \"c\" },\n      { \",\", 1, \"\", \"\", \"c\" },\n      { \">\", 1, \"b\", \"b\", \"c\" },\n      { \"\\n\", 0, \"\", \"\", \"\" },\n      { \"Abort:\", 6, \"5+b\", \"r\", \"\" },\n      { \"q\", 1, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"^C\", 2, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Cancel:\", 7, \"5+b\", \"r\", \"\" },\n      { \"ESC\", 3, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Select:\", 7, \"5+b\", \"r\", \"\" },\n      { \"Mouse:\", 6, \"2\", \"u\", \"m\" },\n      { \"Double-B1\", 9, \"b\", \"b\", \"m\" },\n      { \" \", 1, \"\", \"\", \"m\" },\n      { \"Keyb:\", 5, \"2\", \"u\", \"m\" },\n      { \"CR\", 2, \"b\", \"b\", \"\" },\n      { \"\\n\", 0, \"\", \"\", \"\" },\n      { \"Search:\", 7, \"5+b\", \"r\", \"\" },\n      { \"Def.\", 4, \"3\", \"i\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"(fuzzy):\", 8, \"3\", \"i\", \"\" },\n      { \"/\", 1, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Substr:\", 7, \"3\", \"i\", \"\" },\n      { \"\\\"\", 2, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"\\'\", 1, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Fuzzy:\", 6, \"3\", \"i\", \"\" },\n      { \"~\", 1, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"*\", 1, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"HOME\", 4, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"^A\", 2, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"END\", 3, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"^Z\", 2, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Prefix:\", 7, \"3\", \"i\", \"\" },\n      { \"=\", 1, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"^\", 1, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Validate:\", 9, \"3\", \"i\", \"\" },\n      { \"CR\", 2, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Next:\", 5, \"3\", \"i\", \"\" },\n      { \"SP\", 2, \"b\", \"b\", \"\" },\n      { \",\", 1, \"\", \"\", \"\" },\n      { \"n\", 1, \"b\", \"b\", \"\" },\n      { \" \", 1, \"\", \"\", \"\" },\n      { \"Prev:\", 5, \"3\", \"i\", \"\" },\n      { \"N\", 1, \"b\", \"b\", \"\" },\n      { \"\\n\", 0, \"\", \"\", \"t\" },\n      { \"Mark:\", 5, \"5+b\", \"r\", \"t\" },\n      { \"Mouse:\", 6, \"2\", \"u\", \"tm\" },\n      { \"^B1\", 3, \"b\", \"b\", \"tm\" },\n      { \"/\", 1, \"b\", \"b\", \"tm\" },\n      { \"B3\", 2, \"b\", \"b\", \"tm\" },\n      { \" \", 1, \"\", \"\", \"tm\" },\n      { \"Keyb:\", 5, \"2\", \"u\", \"tm\" },\n      { \"mM\", 2, \"b\", \"b\", \"t\" },\n      { \"\\n\", 0, \"\", \"\", \"t\" },\n      { \"Tag:\", 4, \"5+b\", \"r\", \"t\" },\n      { \"Mouse:\", 6, \"2\", \"u\", \"tm\" },\n      { \"B3\", 2, \"B\", \"B\", \"tm\" },\n      { \" \", 1, \"\", \"\", \"tm\" },\n      { \"Zone:\", 5, \"3\", \"i\", \"ctm\" },\n      { \"/\", 1, \"b\", \"b\", \"ctm\" },\n      { \"Row:\", 4, \"3\", \"i\", \"ctm\" },\n      { \"/\", 1, \"b\", \"b\", \"ctm\" },\n      { \"Col:\", 4, \"3\", \"i\", \"ctm\" },\n      { \"^B3\", 3, \"B\", \"B\", \"ctm\" },\n      { \" \", 1, \"b\", \"b\", \"ct\" },\n      { \"Keyb:\", 5, \"2\", \"u\", \"tm\" },\n      { \"t\", 1, \"b\", \"b\", \"t\" },\n      { \",\", 1, \"\", \"\", \"t\" },\n      { \"u\", 1, \"b\", \"b\", \"ct\" },\n      { \" \", 1, \"\", \"\", \"ct\" },\n      { \"r\", 1, \"b\", \"b\", \"ct\" },\n      { \",\", 1, \"\", \"\", \"ct\" },\n      { \"c\", 1, \"b\", \"b\", \"ct\" },\n      { \" \", 1, \"\", \"\", \"ct\" },\n      { \"Cont:\", 5, \"3\", \"i\", \"t\" },\n      { \"T\", 1, \"b\", \"b\", \"t\" },\n      { \"...\", 3, \"\", \"\", \"t\" },\n      { \"T\", 1, \"b\", \"b\", \"t\" },\n      { \",\", 1, \"\", \"\", \"t\" },\n      { \"Zone:\", 5, \"3\", \"i\", \"t\" },\n      { \"Z\", 1, \"b\", \"b\", \"t\" },\n      { \"...\", 3, \"\", \"\", \"t\" },\n      { \"Z\", 1, \"b\", \"b\", \"t\" },\n      { \",\", 1, \"\", \"\", \"ct\" },\n      { \"Row:\", 4, \"3\", \"i\", \"ct\" },\n      { \"R\", 1, \"b\", \"b\", \"ct\" },\n      { \"...\", 3, \"\", \"\", \"ct\" },\n      { \"R\", 1, \"b\", \"b\", \"ct\" },\n      { \",\", 1, \"\", \"\", \"ct\" },\n      { \"Col:\", 4, \"3\", \"i\", \"ct\" },\n      { \"C\", 1, \"b\", \"b\", \"ct\" },\n      { \"...\", 3, \"\", \"\", \"ct\" },\n      { \"C\", 1, \"b\", \"b\", \"ct\" },\n      { \" \", 1, \"\", \"\", \"t\" },\n      { \"Undo:\", 5, \"3\", \"i\", \"t\" },\n      { \"U\", 1, \"b\", \"b\", \"t\" },\n      { \",\", 1, \"\", \"\", \"t\" },\n      { \"^T\", 2, \"b\", \"b\", \"t\" },\n      { \" \", 1, \"\", \"\", \"t\" },\n    };\n\n    help_entry_t trailer_entries[] = {\n      { \"\\n\", 0, \"\", \"\", \"\" },  { \"End\", 3, \"u\", \"u\", \"\" },\n      { \" \", 1, \"u\", \"u\", \"\" }, { \"of\", 2, \"u\", \"u\", \"\" },\n      { \" \", 1, \"u\", \"u\", \"\" }, { \"quick\", 5, \"u\", \"u\", \"\" },\n      { \" \", 1, \"u\", \"u\", \"\" }, { \"help.\", 5, \"u\", \"u\", \"\" },\n    };\n\n    entries_total_nb = 0;\n\n    entries_nb = sizeof(header_entries) / sizeof(help_entry_t);\n    entries_total_nb += help_add_entries(win,\n                                         term,\n                                         toggles,\n                                         help_items_da,\n                                         header_entries,\n                                         entries_nb);\n\n    entries_nb = sizeof(generic_entries) / sizeof(help_entry_t);\n    entries_total_nb += help_add_entries(win,\n                                         term,\n                                         toggles,\n                                         help_items_da,\n                                         generic_entries,\n                                         entries_nb);\n\n    entries_nb = sizeof(trailer_entries) / sizeof(help_entry_t);\n    entries_total_nb += help_add_entries(win,\n                                         term,\n                                         toggles,\n                                         help_items_da,\n                                         trailer_entries,\n                                         entries_nb);\n  }\n  else\n    entries_total_nb = entries_nb;\n\n  /* Determine when to split the help line if necessary. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  max_col = term->ncolumns - 1;\n\n  help_lines_da = NULL;\n  items_da      = NULL;\n\n  first_in_line = 0;\n\n  /* Fill the darray of darrays, each line is a darray of help_attr_entry_t */\n  /* A new line is added each time the next entry does not fit in the       */\n  /* width of the window. This is done as long as there is space left in    */\n  /* the window.                                                            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (index = 0; index < entries_total_nb; index++)\n  {\n    /* Ignore item if its length cannot be fully displayed. */\n    /* '''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    if ((*help_items_da)[index]->len >= max_col)\n      continue;\n\n    /* increase the total length of displayed items in the line. */\n    /* ''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    len += (*help_items_da)[index]->len;\n\n    /* Set a flag if we need to start a new line. */\n    /* '''''''''''''''''''''''''''''''''''''''''' */\n    if (strcmp((*help_items_da)[index]->str, \"\\n\") == 0)\n      forced_nl = 1;\n    else\n      forced_nl = 0;\n\n    if (len >= max_col || forced_nl)\n    {\n      line++;\n      first_in_line = 1;\n\n      /* Exit early if we do not have enough space. */\n      /* '''''''''''''''''''''''''''''''''''''''''' */\n      if (line > last_line)\n        break;\n\n      len = 0;\n\n      /* Dynamically push the current items_da in help_lines_da */\n      /* And initialize a new items_da.                         */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      BUF_PUSH(help_lines_da, items_da);\n      items_da = NULL;\n\n      /* Do not put the '\\n' in the current items_da. */\n      /* '''''''''''''''''''''''''''''''''''''''''''' */\n      if (forced_nl)\n        continue;\n    }\n\n    /* Skip ' ' and ',' when they appear first in a line. */\n    /* '''''''''''''''''''''''''''''''''''''''''''''''''' */\n    if (first_in_line)\n      if (strcmp((*help_items_da)[index]->str, \" \") == 0\n          || strcmp((*help_items_da)[index]->str, \",\") == 0)\n        continue;\n\n    first_in_line = 0;\n    BUF_PUSH(items_da, (*help_items_da)[index]);\n  }\n\n  if (items_da != NULL)\n    BUF_PUSH(help_lines_da, items_da);\n\n  return help_lines_da;\n}\n\n/* ================================================= */\n/* Display the quick help content.                   */\n/*                                                   */\n/* help_lines_da      IN  array of help lines.       */\n/* fst_disp_help_line IN first help line to display. */\n/* ================================================= */\nvoid\ndisp_help(win_t               *win,\n          term_t              *term,\n          help_attr_entry_t ***help_lines_da,\n          int                  fst_disp_help_line)\n{\n  int index;   /* used to identify the objects long the help line. */\n  int max_col; /* when to split the help line.                     */\n  int displayed_lines;\n  int total_lines;\n\n  help_attr_entry_t **items_da;\n\n  /* Determine when to split the help line if necessary. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  max_col = term->ncolumns - 1;\n\n  /* Save the position of the terminal cursor so that it can be */\n  /* put back there after printing of the help line.            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  (void)tputs(TPARM1(save_cursor), 1, outch);\n\n  displayed_lines = 0;\n  total_lines     = BUF_LEN(help_lines_da);\n\n  /* Print the different objects forming the help lines.                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (index = fst_disp_help_line; index < total_lines; index++)\n  {\n    int i;\n    int item;\n    int nb_items;\n    int len;\n\n    if (displayed_lines == win->max_lines)\n      break;\n\n    displayed_lines++;\n\n    len = 0;\n\n    items_da = help_lines_da[index];\n    nb_items = BUF_LEN(items_da);\n\n    (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n    for (item = 0; item < nb_items; item++)\n    {\n      help_attr_entry_t *entry;\n\n      entry = items_da[item];\n      len += entry->len;\n\n      (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n      apply_attr(term, *(entry->attr));\n\n      fputs_safe(entry->str, stdout);\n      (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n    }\n\n    /* Fill the remaining space with spaces. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    for (i = len; i < max_col; i++)\n      fputc_safe(' ', stdout);\n    if (displayed_lines < win->max_lines)\n      fputc_safe('\\n', stdout);\n  }\n\n  /* Put back the cursor to its saved position. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  (void)tputs(TPARM1(restore_cursor), 1, outch);\n}\n\n/* *********************************** */\n/* Attributes string parsing function. */\n/* *********************************** */\n\n/* =========================================================== */\n/* Allocation and initialization of a new attribute structure. */\n/*                                                             */\n/* Return the newly created attribute.                         */\n/* =========================================================== */\nattrib_t *\nattr_new(void)\n{\n  attrib_t *attr;\n\n  attr = xmalloc(sizeof(attrib_t));\n\n  attr->is_set    = UNSET;\n  attr->fg        = -1;\n  attr->bg        = -1;\n  attr->bold      = (signed char)-1;\n  attr->dim       = (signed char)-1;\n  attr->reverse   = (signed char)-1;\n  attr->standout  = (signed char)-1;\n  attr->underline = (signed char)-1;\n  attr->italic    = (signed char)-1;\n  attr->invis     = (signed char)-1;\n  attr->blink     = (signed char)-1;\n\n  return attr;\n}\n\n/* ============================================ */\n/* Decode attributes toggles if any.            */\n/* b -> bold                                    */\n/* d -> dim                                     */\n/* r -> reverse                                 */\n/* s -> standout                                */\n/* u -> underline                               */\n/* i -> italic                                  */\n/* x -> invis                                   */\n/* l -> blink                                   */\n/*                                              */\n/* Return 0 if some unexpected toggle is found, */\n/*        1 otherwise.                          */\n/* ============================================ */\nint\ndecode_attr_toggles(char *s, attrib_t *attr)\n{\n  int rc = 1;\n\n  attr->bold      = (signed char)0;\n  attr->dim       = (signed char)0;\n  attr->reverse   = (signed char)0;\n  attr->standout  = (signed char)0;\n  attr->underline = (signed char)0;\n  attr->italic    = (signed char)0;\n  attr->invis     = (signed char)0;\n  attr->blink     = (signed char)0;\n\n  while (*s != '\\0')\n  {\n    switch (*s)\n    {\n      case 'b':\n        attr->bold   = (signed char)1;\n        attr->is_set = SET;\n        break;\n      case 'd':\n        attr->dim    = (signed char)1;\n        attr->is_set = SET;\n        break;\n      case 'r':\n        attr->reverse = (signed char)1;\n        attr->is_set  = SET;\n        break;\n      case 's':\n        attr->standout = (signed char)1;\n        attr->is_set   = SET;\n        break;\n      case 'u':\n        attr->underline = (signed char)1;\n        attr->is_set    = SET;\n        break;\n      case 'i':\n        attr->italic = (signed char)1;\n        attr->is_set = SET;\n        break;\n      case 'n':\n        attr->invis  = (signed char)1;\n        attr->is_set = SET;\n        break;\n      case 'l':\n        attr->blink  = (signed char)1;\n        attr->is_set = SET;\n        break;\n      default:\n        rc = 0;\n        break;\n    }\n    s++;\n  }\n  return rc;\n}\n\n/* =============================================================*/\n/* Parse attributes in str in the form [fg][/bg][[,.+]toggles]  */\n/* where:                                                       */\n/* fg and bg are short representing a color value               */\n/* toggles is an array of toggles (see decode_attr_toggles)     */\n/* Returns 1 on success else 0.                                 */\n/* attr will be filled by the function.                         */\n/* =============================================================*/\nint\nparse_attr(char *str, attrib_t *attr, short colors)\n{\n  int   n;\n  char *pos;\n  char  s1[12] = { (char)0 }; /* For the colors.     */\n  char  s2[9]  = { (char)0 }; /* For the attributes. */\n  short d1 = -1, d2 = -1;     /* colors. */\n  int   rc = 1;\n  char  c  = '\\0';\n\n  /* 11: 4 type+colon,2x3 for colors, 1 for slash.     */\n  /* 8 : max size for the concatenation of attributes. */\n  /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n  n = sscanf(str, \"%11[^,.+]%*[,.+]%8s%c\", s1, s2, &c);\n\n  if (n == 0 || c != '\\0')\n    goto error;\n\n  if ((pos = strchr(s1, '/')))\n  {\n    if (pos == s1) /* s1 starts with a / */\n    {\n      d1 = -1;\n      if (sscanf(s1 + 1, \"%hd\", &d2) == 0)\n      {\n        d2 = -1;\n        if (n == 1)\n          goto error;\n      }\n      else if (d2 < 0)\n        goto error;\n    }\n    else if (sscanf(s1, \"%hd/%hd\", &d1, &d2) < 2)\n    {\n      d1 = d2 = -1;\n      if (n == 1)\n        goto error;\n    }\n    else if (d1 < 0 || d2 < 0)\n      goto error;\n  }\n  else /* no / in the first string. */\n  {\n    d2 = -1;\n    if (sscanf(s1, \"%hd\", &d1) == 0)\n    {\n      d1 = -1;\n      if (n == 2 || decode_attr_toggles(s1, attr) == 0)\n        goto error;\n    }\n  }\n\n  if (colors == 0) /* Monochrome. */\n  {\n    attr->fg = -1;\n    attr->bg = -1;\n  }\n  else\n  {\n    attr->fg = d1 < colors ? d1 : -1;\n    attr->bg = d2 < colors ? d2 : -1;\n  }\n\n  if (n == 2)\n    rc = decode_attr_toggles(s2, attr);\n\n  return rc;\n\nerror:\n  return 0;\n}\n\n/* ============================================== */\n/* Set the terminal attributes according to attr. */\n/* ============================================== */\nvoid\napply_attr(term_t *term, attrib_t attr)\n{\n  if (attr.fg >= 0)\n    set_foreground_color(term, attr.fg);\n\n  if (attr.bg >= 0)\n    set_background_color(term, attr.bg);\n\n  if (attr.bold > (signed char)0)\n    (void)tputs(TPARM1(enter_bold_mode), 1, outch);\n\n  if (attr.dim > (signed char)0)\n    (void)tputs(TPARM1(enter_dim_mode), 1, outch);\n\n  if (attr.reverse > (signed char)0)\n    (void)tputs(TPARM1(enter_reverse_mode), 1, outch);\n\n  if (attr.standout > (signed char)0)\n    (void)tputs(TPARM1(enter_standout_mode), 1, outch);\n\n  if (attr.underline > (signed char)0)\n    (void)tputs(TPARM1(enter_underline_mode), 1, outch);\n\n  if (attr.italic > (signed char)0)\n    (void)tputs(TPARM1(enter_italics_mode), 1, outch);\n\n  if (attr.invis > (signed char)0)\n    (void)tputs(TPARM1(enter_secure_mode), 1, outch);\n\n  if (attr.blink > (signed char)0)\n    (void)tputs(TPARM1(enter_blink_mode), 1, outch);\n}\n\n/* ********************* */\n/* ini parsing function. */\n/* ********************* */\n\n/* ===================================================== */\n/* Callback function called when parsing each non-header */\n/* line of the ini file.                                 */\n/* Returns 0 if OK, 1 if not.                            */\n/* ===================================================== */\nint\nini_cb(win_t      *win,\n       term_t     *term,\n       limit_t    *limits,\n       ticker_t   *timers,\n       misc_t     *misc,\n       mouse_t    *mouse,\n       const char *section,\n       const char *name,\n       char       *value)\n{\n  int error      = 0;\n  int has_colors = term->colors > 7;\n\n  if (strcmp(section, \"colors\") == 0)\n  {\n    attrib_t v = { UNSET,\n                   /* fg        */ -1,\n                   /* bg        */ -1,\n                   /* bold      */ (signed char)-1,\n                   /* dim       */ (signed char)-1,\n                   /* reverse   */ (signed char)-1,\n                   /* standout  */ (signed char)-1,\n                   /* underline */ (signed char)-1,\n                   /* italic    */ (signed char)-1,\n                   /* invis     */ (signed char)-1,\n                   /* blink     */ (signed char)-1 };\n\n#define CHECK_ATTR(x)                             \\\n  else if (strcmp(name, #x) == 0)                 \\\n  {                                               \\\n    error = !parse_attr(value, &v, term->colors); \\\n    if (error)                                    \\\n      goto out;                                   \\\n    else                                          \\\n    {                                             \\\n      if (win->x##_attr.is_set != FORCED)         \\\n      {                                           \\\n        win->x##_attr.is_set = SET;               \\\n        if (v.fg >= 0)                            \\\n          win->x##_attr.fg = v.fg;                \\\n        if (v.bg >= 0)                            \\\n          win->x##_attr.bg = v.bg;                \\\n        if (v.bold >= (signed char)0)             \\\n          win->x##_attr.bold = v.bold;            \\\n        if (v.dim >= (signed char)0)              \\\n          win->x##_attr.dim = v.dim;              \\\n        if (v.reverse >= (signed char)0)          \\\n          win->x##_attr.reverse = v.reverse;      \\\n        if (v.standout >= (signed char)0)         \\\n          win->x##_attr.standout = v.standout;    \\\n        if (v.underline >= (signed char)0)        \\\n          win->x##_attr.underline = v.underline;  \\\n        if (v.italic >= (signed char)0)           \\\n          win->x##_attr.italic = v.italic;        \\\n        if (v.invis >= (signed char)0)            \\\n          win->x##_attr.invis = v.invis;          \\\n        if (v.blink >= (signed char)0)            \\\n          win->x##_attr.blink = v.blink;          \\\n      }                                           \\\n    }                                             \\\n  }\n\n#define CHECK_ATT_ATTR(x, y)                            \\\n  else if (strcmp(name, #x #y) == 0)                    \\\n  {                                                     \\\n    error = !parse_attr(value, &v, term->colors);       \\\n    if (error)                                          \\\n      goto out;                                         \\\n    else                                                \\\n    {                                                   \\\n      if (win->x##_attr[y - 1].is_set != FORCED)        \\\n      {                                                 \\\n        win->x##_attr[y - 1].is_set = SET;              \\\n        if (v.fg >= 0)                                  \\\n          win->x##_attr[y - 1].fg = v.fg;               \\\n        if (v.bg >= 0)                                  \\\n          win->x##_attr[y - 1].bg = v.bg;               \\\n        if (v.bold >= (signed char)0)                   \\\n          win->x##_attr[y - 1].bold = v.bold;           \\\n        if (v.dim >= (signed char)0)                    \\\n          win->x##_attr[y - 1].dim = v.dim;             \\\n        if (v.reverse >= (signed char)0)                \\\n          win->x##_attr[y - 1].reverse = v.reverse;     \\\n        if (v.standout >= (signed char)0)               \\\n          win->x##_attr[y - 1].standout = v.standout;   \\\n        if (v.underline >= (signed char)0)              \\\n          win->x##_attr[y - 1].underline = v.underline; \\\n        if (v.italic >= (signed char)0)                 \\\n          win->x##_attr[y - 1].italic = v.italic;       \\\n        if (v.invis >= (signed char)0)                  \\\n          win->x##_attr[y - 1].invis = v.invis;         \\\n        if (v.blink >= (signed char)0)                  \\\n          win->x##_attr[y - 1].blink = v.blink;         \\\n      }                                                 \\\n    }                                                   \\\n  }\n\n    /* [colors] section. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (has_colors)\n    {\n      if (strcmp(name, \"method\") == 0)\n      {\n        if (strcmp(value, \"classic\") == 0)\n          term->color_method = CLASSIC;\n        else if (strcmp(value, \"ansi\") == 0)\n          term->color_method = ANSI;\n        else\n        {\n          error = 1;\n          goto out;\n        }\n      }\n\n      /* clang-format off */\n      CHECK_ATTR(cursor)\n      CHECK_ATTR(bar)\n      CHECK_ATTR(shift)\n      CHECK_ATTR(message)\n      CHECK_ATTR(search_field)\n      CHECK_ATTR(search_text)\n      CHECK_ATTR(match_field)\n      CHECK_ATTR(match_text)\n      CHECK_ATTR(match_err_field)\n      CHECK_ATTR(match_err_text)\n      CHECK_ATTR(include)\n      CHECK_ATTR(exclude)\n      CHECK_ATTR(tag)\n      CHECK_ATTR(cursor_on_tag)\n      CHECK_ATTR(daccess)\n      CHECK_ATT_ATTR(special, 1)\n      CHECK_ATT_ATTR(special, 2)\n      CHECK_ATT_ATTR(special, 3)\n      CHECK_ATT_ATTR(special, 4)\n      CHECK_ATT_ATTR(special, 5)\n      CHECK_ATT_ATTR(special, 6)\n      CHECK_ATT_ATTR(special, 7)\n      CHECK_ATT_ATTR(special, 8)\n      CHECK_ATT_ATTR(special, 9)\n      /* clang-format on */\n    }\n  }\n  else if (strcmp(section, \"window\") == 0)\n  {\n    int v;\n\n    /* [window] section. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strcmp(name, \"lines\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v >= 0)))\n        goto out;\n      else\n        win->asked_max_lines = v;\n    }\n  }\n  else if (strcmp(section, \"limits\") == 0)\n  {\n    long v;\n\n    /* [limits] section. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strcmp(name, \"word_length\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%ld\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        limits->word_length = v;\n    }\n    else if (strcmp(name, \"words\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%ld\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        limits->words = v;\n    }\n    else if (strcmp(name, \"columns\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%ld\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        limits->cols = v;\n    }\n  }\n  else if (strcmp(section, \"timers\") == 0)\n  {\n    int v;\n\n    /* [timers] section. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strcmp(name, \"help\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        timers->help = v;\n    }\n    else if (strcmp(name, \"forgotten\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        timers->forgotten = v;\n    }\n    else if (strcmp(name, \"window\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        timers->winch = v;\n    }\n    else if (strcmp(name, \"direct_access\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        timers->direct_access = v;\n    }\n    else if (strcmp(name, \"search\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        timers->search = v;\n    }\n  }\n  else if (strcmp(section, \"mouse\") == 0)\n  {\n    int v;\n\n    /* [mouse] section. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strcmp(name, \"double_click_delay\") == 0)\n    {\n      if ((error = !(sscanf(value, \"%d\", &v) == 1 && v > 0)))\n        goto out;\n      else\n        mouse->double_click_delay = v;\n    }\n  }\n  else if (strcmp(section, \"misc\") == 0)\n  {\n    /* [misc] section. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (strcmp(name, \"default_search_method\") == 0)\n    {\n      if (misc->default_search_method == NONE)\n      {\n        if (strcmp(value, \"prefix\") == 0)\n          misc->default_search_method = PREFIX;\n        else if (strcmp(value, \"fuzzy\") == 0)\n          misc->default_search_method = FUZZY;\n        else if (strcmp(value, \"substring\") == 0)\n          misc->default_search_method = SUBSTRING;\n      }\n    }\n  }\n\nout:\n\n  return error;\n}\n\n/* ======================================================================== */\n/* Load an .ini format file.                                                */\n/* filename - path to a file.                                               */\n/* report   - callback can return non-zero to stop, the callback error code */\n/*            returned from this function.                                  */\n/* return   - return 0 on success.                                          */\n/*                                                                          */\n/* This function is public domain. No copyright is claimed.                 */\n/* Jon Mayo April 2011.                                                     */\n/* ======================================================================== */\nint\nini_load(const char *filename,\n         win_t      *win,\n         term_t     *term,\n         limit_t    *limits,\n         ticker_t   *timers,\n         misc_t     *misc,\n         mouse_t    *mouse,\n         int (*report)(win_t      *win,\n                       term_t     *term,\n                       limit_t    *limits,\n                       ticker_t   *timers,\n                       misc_t     *misc,\n                       mouse_t    *mouse,\n                       const char *section,\n                       const char *name,\n                       char       *value))\n{\n  char  name[64]     = \"\";\n  char  value[256]   = \"\";\n  char  section[128] = \"\";\n  char *s;\n  FILE *f;\n  int   cnt;\n  int   error;\n\n  /* If the filename is empty we skip this phase and use the */\n  /* default values.                                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (filename == NULL)\n    return 1;\n\n  /* We do that if the file is not readable as well. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  f = fopen_safe(filename, \"r\");\n  if (f == NULL)\n    return 0; /* Returns success as the presence of this file *\n               | is optional.                                 */\n\n  error = 0;\n\n  /* Skip blank lines. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (fscanf(f, \"%*[\\n]\") == 1)\n  {\n  }\n\n  while (!feof(f))\n  {\n    if (fscanf(f, \" [%127[^];\\n]]\", section) == 1)\n    {\n      /* Do nothing. */\n      /* \"\"\"\"\"\"\"\"\"\"\" */\n    }\n\n    if ((cnt = fscanf(f, \" %63[^=;\\n] = %255[^;\\n]\", name, value)))\n    {\n      if (cnt == 1)\n        *value = 0;\n\n      for (s = name + strlen(name) - 1; s > name && isspace(*s); s--)\n        *s = 0;\n\n      for (s = value + strlen(value) - 1; s > value && isspace(*s); s--)\n        *s = 0;\n\n      /* Callback function calling. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      error =\n        report(win, term, limits, timers, misc, mouse, section, name, value);\n\n      if (error)\n        goto out;\n    }\n\n    if (fscanf(f, \" ;%*[^\\n]\"))\n    {\n      /* To silence the compiler about unused results. */\n    }\n\n    /* Skip blank lines. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while (fscanf(f, \"%*[\\n]\") == 1)\n    {\n      /* Do nothing. */\n      /* \"\"\"\"\"\"\"\"\"\"\" */\n    }\n  }\n\nout:\n  fclose(f);\n\n  if (error)\n    fprintf(stderr,\n            \"Invalid entry found: %s=%s in %s.\\n\",\n            name,\n            value,\n            filename);\n\n  return error;\n}\n\n/* ====================================================================== */\n/* Returns the full path of the configuration file supposed to be in the  */\n/* user's home directory if base is NULL or in the content of the         */\n/* environment variable base.                                             */\n/*                                                                        */\n/* Returns NULL if the built path is too large or if base does not exist. */\n/* ====================================================================== */\nchar *\nmake_ini_path(char *name, char *base)\n{\n  char *path;\n  char *home;\n  long  path_max;\n  long  len;\n\n  /* Set the prefix of the path from the environment */\n  /* base can be \"HOME\" or \"PWD\".                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  home = getenv(base);\n\n  if (home == NULL)\n    home = \"\";\n\n  path_max = pathconf(\".\", _PC_PATH_MAX);\n  len      = strlen(home) + strlen(name) + 3;\n\n  if (path_max < 0)\n    path_max = 4096; /* POSIX minimal value. path_max >= 4096. */\n\n  if (len <= path_max)\n  {\n    char *conf;\n\n    path = xmalloc(len);\n    conf = strrchr(name, '/');\n\n    if (conf != NULL)\n      conf++;\n    else\n      conf = name;\n\n    snprintf(path, len, \"%s/.%s\", home, conf);\n  }\n  else\n    path = NULL;\n\n  return path;\n}\n\n/* ********************************* */\n/* Functions used when sorting tags. */\n/* ********************************* */\n\n/* =================================================================== */\n/* Compare the pin order of two pinned word in the output list.        */\n/* Returns -1 if the pinning value is less than the second, 0 if it is */\n/* equal to the second and 1 if it is greater than the second.         */\n/* =================================================================== */\nint\ntag_comp(void const *a, void const *b)\n{\n  output_t *oa = (output_t *)a;\n  output_t *ob = (output_t *)b;\n\n  if (oa->order == ob->order)\n    return 0;\n\n  return (oa->order < ob->order) ? -1 : 1;\n}\n\n/* ========================================================= */\n/* Swap the values of two selected words in the output list. */\n/* ========================================================= */\nvoid\ntag_swap(void **a, void **b)\n{\n  output_t *oa = (output_t *)*a;\n  output_t *ob = (output_t *)*b;\n\n  char *tmp_str;\n  long  tmp_order;\n\n  tmp_str        = oa->output_str;\n  oa->output_str = ob->output_str;\n  ob->output_str = tmp_str;\n\n  tmp_order = oa->order;\n  oa->order = ob->order;\n  ob->order = tmp_order;\n}\n\n/* ****************** */\n/* Utility functions. */\n/* ****************** */\n\n/* =================================================================== */\n/* Create a new element to be added to the tst_search_list used by the */\n/* search mechanism.                                                   */\n/* Return the newly created element.                                   */\n/* =================================================================== */\nsub_tst_t *\nsub_tst_new(void)\n{\n  sub_tst_t *elem = xmalloc(sizeof(sub_tst_t));\n\n  elem->size  = 64;\n  elem->count = 0;\n  elem->array = xmalloc(elem->size * sizeof(tst_node_t));\n\n  return elem;\n}\n\n/* ========================================= */\n/* Emit a small (visual) beep warn the user. */\n/* ========================================= */\nvoid\nmy_beep(toggle_t *toggles)\n{\n  struct timespec ts, rem;\n\n  if (!toggles->visual_bell)\n    fputc_safe('\\a', stdout);\n  else\n  {\n    int rc;\n\n    (void)tputs(TPARM1(cursor_visible), 1, outch);\n\n    ts.tv_sec  = 0;\n    ts.tv_nsec = 200000000; /* 0.2s */\n\n    errno = 0;\n    rc    = nanosleep(&ts, &rem);\n\n    while (rc < 0 && errno == EINTR)\n    {\n      errno = 0;\n      rc    = nanosleep(&rem, &rem);\n    }\n\n    (void)tputs(TPARM1(cursor_invisible), 1, outch);\n  }\n}\n\n/* ================================================================== */\n/* Integer verification constraint for ctxopt.                        */\n/* Return 1 if par is the representation of an integer else return 0. */\n/* ================================================================== */\nint\ncheck_integer_constraint(int nb_args, char **args, char *value, char *par)\n{\n  if (!is_integer(value))\n  {\n    fprintf(stderr, \"The argument of %s is not an integer: %s\", par, value);\n    return 0;\n  }\n  return 1;\n}\n\n/* ======================================================================= */\n/* Update the bitmap associated with a word. The bits set to 1 in this     */\n/* bitmap indicate the positions of the UFT-8 glyphs of the search buffer  */\n/* in the word.                                                            */\n/*                                                                         */\n/* The disp_word function will use it to display these special characters. */\n/*                                                                         */\n/* mode     is the search method.                                          */\n/* data     contains information about the search buffer.                  */\n/* affinity determines if we must only consider matches that occur at      */\n/*          the start, the end or if we just don't care.                   */\n/* ======================================================================= */\nvoid\nupdate_bitmaps(search_mode_t     mode,\n               search_data_t    *data,\n               bitmap_affinity_t affinity)\n{\n  long i, j, n; /* work variables.                                       */\n\n  long bm_len; /* number of chars taken by the bit mask.                 */\n\n  char *start; /* pointer on the position of the matching position       *\n                | of the last search buffer glyph in the word.           */\n\n  char *bm; /* the word's current bitmap.                                */\n\n  char *str;      /* copy of the current word put in lower case.         */\n  char *str_orig; /* original version of the word.                       */\n\n  char *sb_orig = data->buf; /* sb: search buffer.                       */\n\n  long *o    = data->utf8_off_a;   /* array of the offsets of the search *\n                                    | buffer glyphs.                     */\n  long *l    = data->utf8_len_a;   /* array of the lengths in bytes of   *\n                                    | the search buffer glyphs.          */\n  long  last = data->utf8_len - 1; /* offset of the last glyph in the    *\n                                    | search buffer.                     */\n\n  BUF_CLEAR(best_matching_words_da);\n\n  if (mode == FUZZY || mode == SUBSTRING)\n  {\n    char *sb;\n    char *first_glyph;\n    long  badness = 0; /* number of 0s between two 1s. */\n\n    first_glyph = xmalloc(5);\n\n    /* In fuzzy search mode, case is not taken into account */\n    /* during the search.                                   */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (mode == FUZZY)\n    {\n      sb = xstrdup(sb_orig); /* sb initially points to sb_orig. */\n      utf8_strtolower(sb, sb_orig);\n    }\n    else\n      sb = sb_orig;\n\n    for (i = 0; i < (long)BUF_LEN(matching_words_da); i++)\n    {\n      long lmg; /* Position of the last matching glyph of the search buffer *\n                 | in a word.                                               */\n\n      n = matching_words_da[i];\n\n      str_orig = xstrdup(word_a[n].str + daccess.flength);\n\n      /* We need to remove the trailing spaces to use the     */\n      /* following algorithm.                                 */\n      /* .len holds the original length in bytes of the word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      rtrim(str_orig, \" \\t\", 0);\n\n      bm_len = (word_a[n].mb - daccess.flength) / CHAR_BIT + 1;\n      bm     = word_a[n].bitmap;\n\n      /* In fuzzy search mode str are converted in lower case letters */\n      /* for comparison reason.                                       */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (mode == FUZZY)\n      {\n        str = xstrdup(str_orig);\n        utf8_strtolower(str, str_orig);\n      }\n      else\n        str = str_orig;\n\n      start = str;\n      lmg   = 0;\n\n      /* Start points to the first UTF-8 glyph of the word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      while ((size_t)(start - str) < word_a[n].len - daccess.flength)\n      {\n        /* Reset the bitmap. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        memset(bm, '\\0', bm_len);\n\n        /* Compare the glyph pointed to by start to the last glyph of */\n        /* the search buffer, the aim is to point to the first        */\n        /* occurrence of the last glyph of it.                        */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (memcmp(start, sb + o[last], l[last]) == 0)\n        {\n          char *p; /* Pointer to the beginning of an UTF-8 glyph in *\n                    | the potential lowercase version of the word.  */\n\n          long sg; /* Index going from lmg backward to 0 of the tested *\n                    | glyphs of the search buffer (searched glyph).    */\n\n          if (last == 0)\n          {\n            /* There is only one glyph in the search buffer, we can */\n            /* stop here.                                           */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            BIT_ON(bm, lmg);\n            if (affinity != END_AFFINITY)\n              break;\n          }\n\n          /* If the search buffer contains more than one glyph, we need  */\n          /* to search the first combination which match the buffer in   */\n          /* the word.                                                   */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          p = start;\n          j = last; /* j counts the number of glyphs in the search buffer *\n                     | not found in the word.                             */\n\n          /* Proceed backwards from the position of last glyph of the      */\n          /* search to check if all the previous glyphs can be fond before */\n          /* in the word. If not try to find the next position of this     */\n          /* last glyph in the word.                                       */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          sg = lmg;\n          while (j > 0 && (p = utf8_prev(str, p)) != NULL)\n          {\n            if (memcmp(p, sb + o[j - 1], l[j - 1]) == 0)\n            {\n              BIT_ON(bm, sg - 1);\n              j--;\n            }\n            else if (mode == SUBSTRING)\n              break;\n\n            sg--;\n          }\n\n          /* All the glyphs have been found. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (j == 0)\n          {\n            BIT_ON(bm, lmg);\n            if (affinity != END_AFFINITY)\n              break;\n          }\n        }\n\n        lmg++;\n        start = utf8_next(start);\n      }\n\n      if (mode == FUZZY)\n      {\n        size_t utf8_index;\n\n        free(str);\n\n        /* We know that the first non blank glyph is part of the pattern, */\n        /* so highlight it if it is not and suppresses the highlighting   */\n        /* of the next occurrence that must be here because this word has */\n        /* already been filtered by select_starting_pattern().            */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (affinity == START_AFFINITY)\n        {\n          size_t i;\n          long   utf8_len;\n\n          /* Skip leading spaces and tabs. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          for (i = 0; i < word_a[n].mb; i++)\n            if (!isblank(*(word_a[n].str + daccess.flength + i)))\n              break;\n\n          first_glyph = utf8_strprefix(first_glyph,\n                                       word_a[n].str + i,\n                                       1,\n                                       &utf8_len);\n\n          if (!BIT_ISSET(word_a[n].bitmap, i))\n          {\n            char *ptr1, *ptr2;\n\n            BIT_ON(word_a[n].bitmap, i);\n\n            ptr1 = word_a[n].str + i;\n            i++;\n            while ((ptr2 = utf8_next(ptr1)) != NULL)\n            {\n              if (memcmp(ptr2, first_glyph, utf8_len) == 0)\n              {\n                if (BIT_ISSET(word_a[n].bitmap, i))\n                {\n                  BIT_OFF(word_a[n].bitmap, i);\n                  break;\n                }\n                else\n                  ptr1 = ptr2;\n              }\n              else\n                ptr1 = ptr2;\n\n              i++;\n            }\n          }\n        }\n\n        /* Compute the number of 'holes' in the bitmap to determine the  */\n        /* badness of a match. The goal is to put the cursor on the word */\n        /* with the smallest badness.                                    */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        utf8_index = 0;\n        j          = 0;\n        badness    = 0;\n\n        while (utf8_index < word_a[n].mb\n               && !BIT_ISSET(word_a[n].bitmap, utf8_index))\n          utf8_index++;\n\n        while (utf8_index < word_a[n].mb)\n        {\n          if (!BIT_ISSET(word_a[n].bitmap, utf8_index))\n            badness++;\n          else\n            j++;\n\n          /* Stop here if all the possible bits has been checked as they  */\n          /* cannot be more numerous than the number of UTF-8 glyphs in   */\n          /* the search buffer.                                           */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (j == data->utf8_len)\n            break;\n\n          utf8_index++;\n        }\n      }\n      free(str_orig);\n\n      if (search_mode == FUZZY)\n      {\n        /* When the badness is zero (best match), add the word position. */\n        /* at the end of a special array which will be used to move the. */\n        /* cursor among this category of words.                          */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (badness == 0)\n          BUF_PUSH(best_matching_words_da, n);\n      }\n    }\n\n    if (mode == FUZZY)\n      free(sb);\n\n    free(first_glyph);\n  }\n  else if (mode == PREFIX)\n  {\n    for (i = 0; i < (long)BUF_LEN(matching_words_da); i++)\n    {\n      n      = matching_words_da[i];\n      bm     = word_a[n].bitmap;\n      bm_len = (word_a[n].mb - daccess.flength) / CHAR_BIT + 1;\n\n      memset(bm, '\\0', bm_len);\n\n      for (j = 0; j <= last; j++)\n        BIT_ON(bm, j);\n    }\n  }\n}\n\n/* ========================================================= */\n/* Find the next word index in the list of matching words    */\n/* using the bisection search algorithm.                     */\n/* Set the value of index to -1 and returns -1 if not found. */\n/* ========================================================= */\nlong\nfind_next_matching_word(long *array, long nb, long value, long *index)\n{\n  /* Use the cached value when possible. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*index >= 0 && *index < nb - 1 && array[*index] == value)\n    return (array[++(*index)]);\n\n  if (nb > 0)\n  {\n    long left = 0, right = nb;\n\n    /* Bisection search. */\n    /* ''''''''''''''''' */\n    while (left < right)\n    {\n      long middle = (left + right) / 2;\n\n      if (value < array[middle])\n        right = middle;\n      else\n        left = middle + 1;\n    }\n\n    if (left < nb - 1)\n    {\n      *index = left;\n      return array[*index];\n    }\n\n    if (value > array[nb - 1])\n    {\n      *index = -1;\n      return -1;\n    }\n\n    *index = nb - 1;\n    return array[*index];\n  }\n\n  *index = -1;\n  return -1;\n}\n\n/* ========================================================== */\n/* Find the previous word index in the list of matching words */\n/* using the bisection search algorithm.                      */\n/* set the value of index to -1 and returns -1 if not found.  */\n/* ========================================================== */\nlong\nfind_prev_matching_word(long *array, long nb, long value, long *index)\n{\n  /* Use the cached value when possible. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*index > 0 && array[*index] == value)\n    return (array[--(*index)]);\n\n  if (nb > 0)\n  {\n    /* Bisection search. */\n    /* ''''''''''''''''' */\n\n    long left = 0, right = nb;\n\n    while (left < right)\n    {\n      long middle = (left + right) / 2;\n\n      if (array[middle] == value)\n      {\n        if (middle > 0)\n        {\n          *index = middle - 1;\n          return array[*index];\n        }\n\n        *index = -1;\n        return -1;\n      }\n\n      if (value < array[middle])\n        right = middle;\n      else\n        left = middle + 1;\n    }\n\n    if (left > 0)\n    {\n      *index = left - 1;\n      return array[*index];\n    }\n\n    *index = -1;\n    return -1;\n  }\n\n  *index = -1;\n  return -1;\n}\n\n/* ============================================================= */\n/* Remove all traces of matched words and redisplay the windows. */\n/* ============================================================= */\nvoid\nclean_matches(search_data_t *search_data, long size)\n{\n  long i;\n\n  /* Clean the list of lists data-structure containing the search levels */\n  /* Note that the first element of the list is never deleted.           */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (tst_search_list != NULL)\n  {\n    ll_node_t *fuzzy_node;\n    sub_tst_t *sub_tst_data;\n\n    fuzzy_node = tst_search_list->tail;\n\n    while (tst_search_list->len > 1)\n    {\n      sub_tst_data = (sub_tst_t *)(fuzzy_node->data);\n\n      free(sub_tst_data->array);\n      free(sub_tst_data);\n\n      ll_delete(tst_search_list, tst_search_list->tail);\n      fuzzy_node = tst_search_list->tail;\n    }\n    sub_tst_data        = (sub_tst_t *)(fuzzy_node->data);\n    sub_tst_data->count = 0;\n  }\n\n  search_data->err = 0;\n\n  /* Clean the search buffer. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  memset(search_data->buf, '\\0', size - daccess.flength);\n\n  search_data->len           = 0;\n  search_data->utf8_len      = 0;\n  search_data->only_ending   = 0;\n  search_data->only_starting = 0;\n\n  /* Clean the match flags and bitmaps. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (i = 0; i < (long)BUF_LEN(matching_words_da); i++)\n  {\n    long n = matching_words_da[i];\n\n    word_a[n].is_matching = 0;\n\n    memset(word_a[n].bitmap,\n           '\\0',\n           (word_a[n].mb - daccess.flength) / CHAR_BIT + 1);\n  }\n\n  BUF_CLEAR(matching_words_da);\n}\n\n/* *************************** */\n/* Terminal utility functions. */\n/* *************************** */\n\n/* ===================================================================== */\n/* outch is a function version of putchar that can be passed to tputs as */\n/* a routine to call.                                                    */\n/* ===================================================================== */\nint\n#ifdef __sun\noutch(char c)\n#else\noutch(int c)\n#endif\n{\n  fputc_safe(c, stdout);\n  return 1;\n}\n\n/* =============================================== */\n/* Set the terminal in non echo/non canonical mode */\n/* wait for at least one byte, no timeout.         */\n/* =============================================== */\nvoid\nsetup_term(int const       fd,\n           struct termios *old_in_attrs,\n           struct termios *new_in_attrs)\n{\n  int error;\n\n  /* Save the terminal parameters and configure it in row mode. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  tcgetattr(fd, old_in_attrs);\n\n  new_in_attrs->c_iflag = 0;\n  new_in_attrs->c_oflag = old_in_attrs->c_oflag;\n  new_in_attrs->c_cflag = old_in_attrs->c_cflag;\n  new_in_attrs->c_lflag = old_in_attrs->c_lflag & ~(ICANON | ECHO | ISIG);\n\n  new_in_attrs->c_cc[VMIN]  = 1; /* wait for at least 1 byte. */\n  new_in_attrs->c_cc[VTIME] = 0; /* no timeout.               */\n\n  error = tcsetattr_safe(fd, TCSANOW, new_in_attrs);\n\n  if (error == -1)\n  {\n    perror(\"smenu\");\n    exit(EXIT_FAILURE);\n  }\n}\n\n/* ====================================== */\n/* Set the terminal in its previous mode. */\n/* ====================================== */\nvoid\nrestore_term(int const fd, struct termios *old_in_attrs)\n{\n  int error;\n\n  error = tcsetattr_safe(fd, TCSANOW, old_in_attrs);\n\n  if (error == -1)\n  {\n    perror(\"smenu\");\n    exit(EXIT_FAILURE);\n  }\n}\n\n/* ============================================== */\n/* Get the terminal numbers of lines and columns  */\n/* Assume that the TIOCGWINSZ, ioctl is available */\n/* Defaults to 80x24.                             */\n/* ============================================== */\nvoid\nget_terminal_size(int * const r, int * const c, term_t *term)\n{\n  struct winsize ws;\n\n  *r = *c = -1;\n\n  if (ioctl(0, TIOCGWINSZ, &ws) == 0)\n  {\n    *r = ws.ws_row;\n    *c = ws.ws_col;\n\n    if (*r > 0 && *c > 0)\n      return;\n  }\n\n  *r = tigetnum(\"lines\");\n  *c = tigetnum(\"cols\");\n\n  if (*r <= 0 || *c <= 0)\n  {\n    *r = 80;\n    *c = 24;\n  }\n}\n\n/* =========================================================== */\n/* Gets the cursor position in the terminal.                   */\n/* Assume that the Escape sequence ESC [ 6 n is available.     */\n/* Retries up to 64 times in case of system call interruption. */\n/* Returns 1 on success and 0 on error, in this case *r and *c */\n/* will contain 0.                                             */\n/* =========================================================== */\nint\nget_cursor_position(int * const r, int * const c)\n{\n  char  buf[32] = { 0 };\n  char *s;\n\n  int attempts = 64;\n  int v;\n  int rc = 1;\n\n  int ask; /* Number of asked characters.    */\n  int got; /* Number of characters obtained. */\n\n  int buf_size = sizeof(buf);\n\n  *r = *c = 0;\n\n  /* Report cursor location. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while ((v = write(STDOUT_FILENO, \"\\x1b[6n\", 4)) == -1 && attempts)\n  {\n    if (errno == EINTR)\n      attempts--;\n    else\n    {\n      rc = 0;\n      goto read;\n    }\n\n    errno = 0;\n  }\n\n  if (v != 4)\n    rc = 0;\n\nread:\n\n  /* Read the response: ESC [ rows ; cols R. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *(s = buf) = 0;\n\n  do\n  {\n    ask = buf_size - 1 - (s - buf);\n    got = read(STDIN_FILENO, s, ask);\n\n    if (got < 0 && errno == EINTR)\n      got = 0;\n    else if (got == 0)\n      break;\n\n    s += got;\n  } while (strchr(buf, 'R') == NULL);\n\n  /* Parse it. */\n  /* \"\"\"\"\"\"\"\"\" */\n  if (buf[0] != 0x1b || buf[1] != '[')\n    return 0;\n\n  if (sscanf(buf + 2, \"%d;%d\", r, c) != 2)\n    rc = 0;\n\n  return rc;\n}\n\n/* ======================================================================== */\n/* Parse a regular expression based selector.                               */\n/* The string to parse is bounded by a delimiter so we must parse something */\n/* like: <delim><regex string><delim> as in /a.*b/ by example.              */\n/*                                                                          */\n/* str            (in)  delimited string to parse                           */\n/* regex_list     (out) regex list to modify.                               */\n/* ======================================================================== */\nvoid\nparse_regex_selector_part(char *str, ll_t **regex_list)\n{\n  regex_t *regex;\n\n  /* Remove the last character of str (the delimiter).*/\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  str[strlen(str) - 1] = '\\0';\n\n  /* Ignore the first character of str (the delimiter).       */\n  /* compile it and add a compiled regex in a dedicated list. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  regex = xmalloc(sizeof(regex_t));\n  if (regcomp(regex, str + 1, REG_EXTENDED | REG_NOSUB) == 0)\n  {\n    if (*regex_list == NULL)\n      *regex_list = ll_new();\n\n    ll_append(*regex_list, regex);\n  }\n}\n\n/* ================================================================= */\n/* Compare two elements of type attr_elem_t.                         */\n/* The comparison key is the first member of the structure which is  */\n/* of type attrib_t.                                                 */\n/* Returns 0 is the two elements are equals otherwise returns 1.     */\n/* ================================================================= */\nint\nattr_elem_cmp(void const *a, void const *b)\n{\n  const attr_elem_t *ai = a;\n  const attr_elem_t *bi = b;\n\n  if (ai->attr->fg != bi->attr->fg)\n    return 1;\n  if (ai->attr->bg != bi->attr->bg)\n    return 1;\n  if (ai->attr->bold != bi->attr->bold)\n    return 1;\n  if (ai->attr->dim != bi->attr->dim)\n    return 1;\n  if (ai->attr->reverse != bi->attr->reverse)\n    return 1;\n  if (ai->attr->standout != bi->attr->standout)\n    return 1;\n  if (ai->attr->underline != bi->attr->underline)\n    return 1;\n  if (ai->attr->italic != bi->attr->italic)\n    return 1;\n  if (ai->attr->invis != bi->attr->invis)\n    return 1;\n  if (ai->attr->blink != bi->attr->blink)\n    return 1;\n\n  return 0;\n}\n\n/* ===================================================================== */\n/* Parse a column or row selector string whose syntax is defined as:     */\n/* [<letter>]<item1>|,<item>|,...                                        */\n/* <item> is <range>| <delimited regex>                                  */\n/* <item> is (<range>| <delimited regex>):<attribute> if letter is a|A.  */\n/* <range> is n1-n2 | n1 | -n2 | n1- where n1 starts with 1.             */\n/* <delimited regex> is <char><regex><char> (e.g. /<regex>/).            */\n/*                                                                       */\n/* <letter> is a|A|s|S|r|R|u|U where:                                    */\n/* i|I is for 'include'.                                                 */\n/* e|E is for 'exclude'.                                                 */\n/* l|L is for 'left' alignment.                                          */\n/* r|R is for 'right' alignment.                                         */\n/* c|C is for 'center' alignment.                                        */\n/* a|A for defining attributes for rows or columns.                      */\n/*                                                                       */\n/* str               (in)  string to parse.                              */\n/* filter            (out) is INCLUDE_FILTER or EXCLUDE_FILTER according */\n/*                         to <letter>.                                  */\n/* unparsed          (out) is empty on success and contains the unparsed */\n/*                         part on failure.                              */\n/* inc_interval_list (out) is a list of the interval of elements to      */\n/*                         be included.                                  */\n/* inc_regex_list    (out) is a list of extended regular expressions of  */\n/*                         elements to be included.                      */\n/* exc_interval_list (out) is a list of the interval of elements to be   */\n/*                         excluded.                                     */\n/* exc_regex_list    (out) is a list of regex matching elements to       */\n/*                         be excluded.                                  */\n/* aX_interval_list  (out) is a list of the interval of elements to be   */\n/*                         aligned to the left, right or centered.       */\n/* aX_regex_list     (out) is a list of regex matching elements to       */\n/*                         be aligned to the left, right or centered.    */\n/* at_interval_list  (out) is a list of the interval of elements with    */\n/*                         a given attribute.                            */\n/* at_regex_list     (out) is a list of regex matching elements with     */\n/*                         a given attribute.                            */\n/* ===================================================================== */\nvoid\nparse_selectors(char        *str,\n                filters_t   *filter,\n                char       **unparsed,\n                ll_t       **inc_interval_list,\n                ll_t       **inc_regex_list,\n                ll_t       **exc_interval_list,\n                ll_t       **exc_regex_list,\n                ll_t       **al_interval_list,\n                ll_t       **al_regex_list,\n                ll_t       **ar_interval_list,\n                ll_t       **ar_regex_list,\n                ll_t       **ac_interval_list,\n                ll_t       **ac_regex_list,\n                ll_t       **at_interval_list,\n                ll_t       **at_regex_list,\n                alignment_t *default_alignment,\n                win_t       *win,\n                misc_t      *misc,\n                term_t      *term)\n{\n  char         c;\n  long         start = 1;     /* column string offset in the parsed string. */\n  long         first, second; /* range starting and ending values.          */\n  char        *ptr;           /* pointer to the remaining string to parse.  */\n  interval_t  *interval;\n  selector_t   type;\n  char        *attr_str = NULL;\n  attrib_t    *attr;\n  attr_elem_t *attr_elem;\n\n  /* Replace the UTF-8 string representation in the selector by */\n  /* their binary values.                                       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  utf8_interpret(str, misc->invalid_char_substitute);\n\n  /* Get the first character to see if this is */\n  /* an additive or restrictive operation.     */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (sscanf(str, \"%c\", &c) == 0)\n    return;\n\n  switch (c)\n  {\n    case 'l':\n    case 'L':\n      if (!win->col_mode)\n      {\n        *unparsed = xstrdup(str);\n        return;\n      }\n      type = ALEFT;\n      break;\n\n    case 'r':\n    case 'R':\n      if (!win->col_mode)\n      {\n        *unparsed = xstrdup(str);\n        return;\n      }\n      type = ARIGHT;\n      break;\n\n    case 'c':\n    case 'C':\n      if (!win->col_mode)\n      {\n        *unparsed = xstrdup(str);\n        return;\n      }\n      type = ACENTER;\n      break;\n\n    case 'i':\n    case 'I':\n      type    = IN;\n      *filter = INCLUDE_FILTER;\n      break;\n\n    case 'e':\n    case 'E':\n      type    = EX;\n      *filter = EXCLUDE_FILTER;\n      break;\n\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      type    = IN;\n      *filter = INCLUDE_FILTER;\n      start   = 0;\n      break;\n\n    case 'a': /* Attribute. */\n      type = ATTR;\n      break;\n\n    default:\n      if (!isgraph(c))\n      {\n        *unparsed = strprint(str);\n        return;\n      }\n\n      type    = IN;\n      *filter = INCLUDE_FILTER;\n      start   = 0;\n      break;\n  }\n\n  /* Set ptr to the start of the interval list to parse. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ptr = str + start;\n\n  if (*ptr == '\\0' && *default_alignment == AL_NONE)\n    switch (type)\n    {\n      case ALEFT:\n        *default_alignment = AL_LEFT;\n        break;\n      case ARIGHT:\n        *default_alignment = AL_RIGHT;\n        break;\n      case ACENTER:\n        *default_alignment = AL_CENTERED;\n        break;\n      default:\n        *unparsed = xstrdup(str);\n        return;\n    }\n\n  /* Scan the comma separated ranges. */\n  /* '\\' can be used to escape a ','. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*ptr)\n  {\n    int   is_range = 0;\n    char  delim1, delim2 = '\\0';\n    char *oldptr;\n    char *colon = NULL;\n    int   l_open_range; /* 1 if the range is left-open.  */\n    int   r_open_range; /* 1 if the range is right-open. */\n\n    l_open_range = r_open_range = 0;\n    first = second = -1;\n    oldptr         = ptr;\n\n    while (*ptr && *ptr != ',')\n    {\n      if (*ptr == '-')\n      {\n        is_range = 1;\n        ptr++;\n      }\n      else if (*ptr == '\\\\' && *(ptr + 1) != '\\0' && *(ptr + 1) == ',')\n        ptr += 2;\n      else if (type == ATTR && *ptr == '\\\\' && *(ptr + 1) != '\\0'\n               && *(ptr + 1) == ':')\n        ptr += 2;\n      else if (type == ATTR && *ptr && *ptr == ':')\n      {\n        colon = ptr;\n        ptr++;\n      }\n      else\n        ptr++;\n    }\n\n    /* Forbid the trailing comma (ex: xxx,). */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (*ptr == ',' && *(ptr + 1) == '\\0')\n    {\n      *unparsed = strprint(ptr);\n      return;\n    }\n\n    /* Forbid the empty patterns (ex: xxx,,yyy). */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (oldptr == ptr)\n    {\n      *unparsed = strprint(ptr);\n      return;\n    }\n\n    /* Mark the end of the interval found. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (*ptr)\n      *ptr++ = '\\0';\n\n    delim1 = *(str + start);\n    if (delim1 == '-')\n      l_open_range = 1;\n\n    if (type != ATTR)\n    {\n      if (*ptr == '\\0')\n        delim2 = *(ptr - 1);\n      else if (ptr > str + start + 2)\n        delim2 = *(ptr - 2);\n    }\n    else\n    {\n      if (colon == NULL || colon == str + start)\n      {\n        *unparsed = strprint(str + start);\n        return;\n      }\n\n      delim2 = *(colon - 1);\n    }\n\n    /* Regex ranges are not yet supported in selectors. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!isdigit(delim1) && delim1 != '-' && is_range)\n    {\n      *unparsed = strprint(str + start);\n      return;\n    }\n\n    if (delim2 == '-')\n      r_open_range = 1;\n\n    /* Check is we have found a well described regular expression. */\n    /* If the segment to parse  contains at least three characters */\n    /* then delim1 and delim2 point to the first and last          */\n    /* delimiter of the regular expression.                        */\n    /* E.g. /abc/                                                  */\n    /*      ^   ^                                                  */\n    /*      |   |                                                  */\n    /* delim1   delim2                                             */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (ptr > str + start + 2 && delim1 == delim2 && isgraph(delim1)\n        && isgraph(delim2) && !isdigit(delim1) && !isdigit(delim2))\n    {\n      /* Process the regex. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      switch (type)\n      {\n        case IN:\n          parse_regex_selector_part(str + start, inc_regex_list);\n          break;\n        case EX:\n          parse_regex_selector_part(str + start, exc_regex_list);\n          break;\n        case ALEFT:\n          parse_regex_selector_part(str + start, al_regex_list);\n          break;\n        case ARIGHT:\n          parse_regex_selector_part(str + start, ar_regex_list);\n          break;\n        case ACENTER:\n          parse_regex_selector_part(str + start, ac_regex_list);\n          break;\n        case ATTR:\n          *colon = '\\0';\n          /* xxxxx\\0yyyy      */\n          /* |    | |         */\n          /* |    | attr part */\n          /* |    colon       */\n          /* str+start        */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n          attr = attr_new();\n\n          /* parse the attribute part (after the colon) */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (!parse_attr(colon + 1, attr, term->colors))\n          {\n            *unparsed = strprint(str + start);\n            free(attr);\n            return;\n          }\n\n          /* Parse the regex part (before the colon) and add it to the */\n          /* list of elements of type attr_elem_t.                     */\n          /* In each of these elements a list of regex for the same    */\n          /* attributes is updated.                                    */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (*at_regex_list == NULL) /* The list doesn't already exists. */\n          {\n            *at_regex_list    = ll_new();\n            attr_elem_t *elem = xmalloc(sizeof(attr_elem_t));\n            elem->attr        = attr;\n            elem->list        = NULL;\n            parse_regex_selector_part(str + start, &elem->list);\n            ll_append(*at_regex_list, elem);\n          }\n          else\n          {\n            attr_elem_t e;\n            ll_node_t  *node;\n            e.attr = attr;\n            /* Update the list of regex of the attribute attr. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if ((node = ll_find(*at_regex_list, &e, attr_elem_cmp)) != NULL)\n            {\n              ((attr_elem_t *)(node->data))->attr = attr;\n              parse_regex_selector_part(str + start,\n                                        &((attr_elem_t *)(node->data))->list);\n            }\n            else\n            {\n              attr_elem_t *elem = xmalloc(sizeof(attr_elem_t));\n              elem->attr        = attr;\n              elem->list        = NULL;\n              parse_regex_selector_part(str + start, &elem->list);\n              ll_append(*at_regex_list, elem);\n            }\n          }\n\n          break;\n      }\n\n      /* Adjust the start of the new interval to read in the */\n      /* initial string.                                     */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      start = ptr - str;\n\n      continue;\n    }\n\n    if (is_range)\n    {\n      /* We must parse 2 numbers separated by a dash. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n      int rc;\n      int pos;\n\n      if (l_open_range == 0 && r_open_range == 0)\n      {\n        rc = sscanf(str + start, \"%ld-%ld%n\", &first, &second, &pos);\n\n        if (type != ATTR)\n        {\n          if (rc != 2 || *(str + start + pos) != '\\0')\n          {\n            *unparsed = strprint(str + start);\n            return;\n          }\n        }\n        else\n        {\n          if (*(str + start + pos) != ':')\n          {\n            if (rc != 2 || *(str + start + pos) != '\\0')\n              *unparsed = strprint(str + start + pos);\n            else\n              *unparsed = strprint(str + start);\n            return;\n          }\n          else\n            attr_str = xstrdup(str + start + pos + 1);\n        }\n      }\n      else if (l_open_range == 1 && r_open_range == 0)\n      {\n        rc = sscanf(str + start, \"-%ld%n\", &second, &pos);\n\n        if (type != ATTR)\n        {\n          if (rc != 1 || *(str + start + pos) != '\\0')\n          {\n            *unparsed = strprint(str + start);\n            return;\n          }\n        }\n        else\n        {\n          if (*(str + start + pos) != ':')\n          {\n            if (rc != 1 || *(str + start + pos) != '\\0')\n              *unparsed = strprint(str + start + pos);\n            else\n              *unparsed = strprint(str + start);\n            return;\n          }\n          else\n            attr_str = xstrdup(str + start + pos + 1);\n        }\n\n        first = 1;\n      }\n      else if (l_open_range == 0 && r_open_range == 1)\n      {\n        rc = sscanf(str + start, \"%ld-%n\", &first, &pos);\n\n        if (type != ATTR)\n        {\n          if (rc != 1 || *(str + start + pos) != '\\0')\n          {\n            *unparsed = strprint(str + start);\n            return;\n          }\n        }\n        else\n        {\n          if (*(str + start + pos) != ':')\n          {\n            if (rc != 1 || *(str + start + pos) != '\\0')\n              *unparsed = strprint(str + start + pos);\n            else\n              *unparsed = strprint(str + start);\n            return;\n          }\n          else\n            attr_str = xstrdup(str + start + pos + 1);\n        }\n\n        second = LONG_MAX;\n      }\n\n      if (first < 1 || second < 1)\n      {\n        /* Both interval boundaries must be strictly positive. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        *unparsed = strprint(str + start);\n        return;\n      }\n\n      /* Ensure that the low bound of the interval is lower or equal */\n      /* to the high one. Swap them if needed.                       */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      interval = interval_new();\n\n      if (first > second)\n      {\n        size_t swap;\n\n        swap   = first;\n        first  = second;\n        second = swap;\n      }\n\n      interval->low  = first - 1;\n      interval->high = second - 1;\n    }\n    else\n    {\n      /* We must parse a single number. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n      int rc;\n      int pos;\n\n      rc = sscanf(str + start, \"%ld%n\", &first, &pos);\n\n      if (type != ATTR)\n      {\n        if (rc != 1 || *(str + start + pos) != '\\0')\n        {\n          *unparsed = strprint(str + start);\n          return;\n        }\n      }\n      else\n      {\n        if (*(str + start + pos) != ':')\n        {\n          if (rc != 1 || *(str + start + pos) != '\\0')\n            *unparsed = strprint(str + start + pos);\n          else\n            *unparsed = strprint(str + start);\n          return;\n        }\n        else\n          attr_str = xstrdup(str + start + pos + 1);\n      }\n\n      interval      = interval_new();\n      interval->low = interval->high = first - 1;\n    }\n\n    /* Adjust the start of the new interval to read in the */\n    /* initial string.                                     */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    start = ptr - str;\n\n    /* Add the new interval to the correct list. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    switch (type)\n    {\n      case IN:\n        if (*inc_interval_list == NULL)\n          *inc_interval_list = ll_new();\n\n        ll_append(*inc_interval_list, interval);\n        break;\n\n      case EX:\n        if (*exc_interval_list == NULL)\n          *exc_interval_list = ll_new();\n\n        ll_append(*exc_interval_list, interval);\n        break;\n\n      case ALEFT:\n        if (*al_interval_list == NULL)\n          *al_interval_list = ll_new();\n\n        ll_append(*al_interval_list, interval);\n        break;\n\n      case ARIGHT:\n        if (*ar_interval_list == NULL)\n          *ar_interval_list = ll_new();\n\n        ll_append(*ar_interval_list, interval);\n        break;\n\n      case ACENTER:\n        if (*ac_interval_list == NULL)\n          *ac_interval_list = ll_new();\n\n        ll_append(*ac_interval_list, interval);\n        break;\n\n      case ATTR:\n        attr = attr_new();\n        if (parse_attr(attr_str, attr, term->colors))\n        {\n          free(attr_str);\n          attr_elem       = xmalloc(sizeof(attr_elem_t));\n          attr_elem->attr = attr;\n\n          if (*at_interval_list == NULL)\n          {\n            *at_interval_list = ll_new();\n            attr_elem->list   = ll_new();\n            ll_append(attr_elem->list, interval);\n            ll_append(*at_interval_list, attr_elem);\n          }\n          else\n          {\n            ll_node_t *node;\n            if ((node = ll_find(*at_interval_list, attr_elem, attr_elem_cmp))\n                != NULL)\n            {\n              free(attr_elem);\n              attr_elem = (attr_elem_t *)node->data;\n\n              ll_append(attr_elem->list, interval);\n            }\n            else\n            {\n              attr_elem->list = ll_new();\n              ll_append(attr_elem->list, interval);\n              ll_append(*at_interval_list, attr_elem);\n            }\n          }\n        }\n        else\n        {\n          free(attr_str);\n          *unparsed = strprint(str + start);\n          free(attr);\n          return;\n        }\n        break;\n    }\n  }\n\n  /* If we are here, then all the intervals have be successfully parsed */\n  /* Ensure that the unparsed string is empty.                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *unparsed = xstrdup(\"\");\n}\n\n/* ===================================================================== */\n/* Parse a commas separated sequence of regular expression.              */\n/* Uses to align to the left, right or center some words base on regular */\n/* expressions.                                                          */\n/*                                                                       */\n/* str               (in)  sequence of regular expression.               */\n/* al_regex_list     (out) list of RE for left-aligned words.            */\n/* ar_regex_list     (out) list of RE for left-aligned words.            */\n/* ac_regex_list     (out) list of RE for centered words.                */\n/* default_alignment (out) new default alignment.                        */\n/* misc              (in)  used by utf8_interpret.                       */\n/* ===================================================================== */\nvoid\nparse_al_selectors(char        *str,\n                   char       **unparsed,\n                   ll_t       **al_regex_list,\n                   ll_t       **ar_regex_list,\n                   ll_t       **ac_regex_list,\n                   alignment_t *default_alignment,\n                   misc_t      *misc)\n{\n  char   c;\n  size_t start = 1; /* column string offset in the parsed string. */\n  char  *ptr;       /* pointer to the remaining string to parse.  */\n  int    type;\n\n  /* Replace the UTF-8 string representation in the selector by */\n  /* their binary values.                                       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  utf8_interpret(str, misc->invalid_char_substitute);\n\n  /* Get the first character to see if this is */\n  /* an additive or restrictive operation.     */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (sscanf(str, \"%c\", &c) == 0)\n    return;\n\n  type = *default_alignment;\n\n  switch (c)\n  {\n    case 'l':\n    case 'L':\n      type = ALEFT;\n      break;\n\n    case 'r':\n    case 'R':\n      type = ARIGHT;\n      break;\n\n    case 'c':\n    case 'C':\n      type = ACENTER;\n      break;\n\n    default:\n      if (!isgraph(c))\n        return;\n\n      start = 0;\n      break;\n  }\n\n  /* Set ptr to the start of the interval list to parse. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ptr = str + start;\n\n  if (*ptr == '\\0' && *default_alignment == AL_NONE)\n    switch (type)\n    {\n      case ALEFT:\n        *default_alignment = AL_LEFT;\n        break;\n      case ARIGHT:\n        *default_alignment = AL_RIGHT;\n        break;\n      case ACENTER:\n        *default_alignment = AL_CENTERED;\n        break;\n      default:\n        *unparsed = xstrdup(str);\n        return;\n    }\n\n  /* Scan the comma separated ranges. */\n  /* '\\' can be used to escape a ','. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*ptr)\n  {\n    char  delim1, delim2 = '\\0';\n    char *oldptr;\n\n    oldptr = ptr;\n    while (*ptr && *ptr != ',')\n    {\n      if (*ptr == '\\\\' && *(ptr + 1) != '\\0' && *(ptr + 1) == ',')\n        ptr += 2;\n      else\n        ptr++;\n    }\n\n    /* Forbid the trailing comma (ex: xxx,). */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (*ptr == ',' && (*(ptr + 1) == '\\0'))\n    {\n      *unparsed = xstrdup(ptr);\n      return;\n    }\n\n    /* Forbid the empty patterns (ex: xxx,,yyy). */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (oldptr == ptr)\n    {\n      *unparsed = xstrdup(ptr);\n      return;\n    }\n\n    /* Mark the end of the interval found. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (*ptr)\n      *ptr++ = '\\0';\n\n    /* If the regex contains at least three characters then delim1 */\n    /* and delim2 point to the first and last delimiter of the     */\n    /* regular expression. E.g. /abc/                              */\n    /*                          ^   ^                              */\n    /*                          |   |                              */\n    /*                     delim1   delim2                         */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    delim1 = *(str + start);\n    if (*ptr == '\\0')\n      delim2 = *(ptr - 1);\n    else if (ptr > str + start + 2)\n      delim2 = *(ptr - 2);\n\n    /* Forbid the empty patterns (ex: xxx,,yyy) and check is we have */\n    /* found a well described regular expression.                    */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (ptr > str + start + 2 && delim1 == delim2 && isgraph(delim1)\n        && isgraph(delim2) && !isdigit(delim1) && !isdigit(delim2))\n    {\n      /* Process the regex. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      switch (type)\n      {\n        case ALEFT:\n          parse_regex_selector_part(str + start, al_regex_list);\n          break;\n        case ARIGHT:\n          parse_regex_selector_part(str + start, ar_regex_list);\n          break;\n        case ACENTER:\n          parse_regex_selector_part(str + start, ac_regex_list);\n          break;\n      }\n\n      /* Adjust the start of the new interval to read in the */\n      /* initial string.                                     */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      start = ptr - str;\n\n      continue;\n    }\n    else\n    {\n      *unparsed = xstrdup(ptr - 1);\n      return;\n    }\n  }\n\n  /* If we are here, then all the intervals have be successfully parsed */\n  /* Ensure that the unparsed string is empty.                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *unparsed = xstrdup(\"\");\n}\n\n/* ========================================================= */\n/* Parse the sed like string passed as argument to -S/-I/-E. */\n/* This updates the sed parameter.                           */\n/* Return 1 on success and 0 on error.                       */\n/* ========================================================= */\nint\nparse_sed_like_string(sed_t *sed)\n{\n  char          sep;\n  char         *first_sep_pos;\n  char         *last_sep_pos;\n  char         *buf;\n  long          index;\n  unsigned char icase;\n  char          c;\n\n  if (strlen(sed->pattern) < 4)\n    return 0;\n\n  /* Get the separator (the 1st character). */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  buf = xstrdup(sed->pattern);\n  sep = buf[0];\n\n  /* Space like separators are not permitted. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (isspace(sep))\n    goto err;\n\n  /* Get the extended regular expression. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if ((first_sep_pos = strchr(buf + 1, sep)) == NULL)\n    goto err;\n\n  *first_sep_pos = '\\0';\n\n  /* Get the substitution string. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if ((last_sep_pos = strchr(first_sep_pos + 1, sep)) == NULL)\n    goto err;\n\n  *last_sep_pos = '\\0';\n\n  sed->substitution = xstrdup(first_sep_pos + 1);\n\n  /* Get the global indicator (trailing g)  */\n  /* and the visual indicator (trailing v)  */\n  /* and the stop indicator   (trailing s). */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sed->global = sed->visual = icase = (unsigned char)0;\n\n  index = 1;\n  while ((c = *(last_sep_pos + index)) != '\\0')\n  {\n    if (c == 'g')\n      sed->global = (unsigned char)1;\n    else if (c == 'v')\n      sed->visual = (unsigned char)1;\n    else if (c == 's')\n      sed->stop = (unsigned char)1;\n    else if (c == 'i')\n      icase = (unsigned char)1;\n    else\n      goto err;\n\n    index++;\n  }\n\n  /* Empty regular expression ? */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*(buf + 1) == '\\0')\n    goto err;\n\n  /* Compile the regular expression and abort on failure. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (regcomp(&(sed->re),\n              buf + 1,\n              !icase ? REG_EXTENDED : (REG_EXTENDED | REG_ICASE))\n      != 0)\n    goto err;\n\n  free(buf);\n\n  return 1;\n\nerr:\n  free(buf);\n\n  return 0;\n}\n\n/* ===================================================================== */\n/* Utility function used by replace to expand the replacement string.    */\n/* IN:                                                                   */\n/* orig:            matching part of the original string to be replaced. */\n/* repl:            string containing the replacement directives         */\n/* subs_a:          array of ranges containing the start and end offset  */\n/*                  of the remembered parts of the strings referenced    */\n/*                  by the sequence \\n where n is in [1,10].             */\n/* match_start/end: offset in orig for the current matched string        */\n/* subs_nb:         number of elements containing significant values in  */\n/*                  the array described above.                           */\n/* error:           set to 0 if no error in replacement string and to 1  */\n/*                  otherwise.                                           */\n/* match:           current match number in the original string.         */\n/*                                                                       */\n/* Return:                                                               */\n/* The modified string according to the content of repl.                 */\n/* ===================================================================== */\nchar *\nbuild_repl_string(char    *orig,\n                  char    *repl,\n                  long     match_start,\n                  long     match_end,\n                  range_t *subs_a,\n                  long     subs_nb,\n                  long     match,\n                  int     *error)\n{\n  char *str;     /*string to return */\n  int   special; /* 1 if the next character is protected. */\n  long  offset;  /* offset of the 1st sub corresponding to the match. */\n\n  str     = (char *)0;\n  special = 0;\n  *error  = 0;\n\n  offset = match * subs_nb;\n\n  if (*repl == '\\0')\n    BUF_FIT(str, 1);\n  else\n    while (!*error && *repl)\n    {\n      switch (*repl)\n      {\n        case '\\\\':\n          if (special)\n          {\n            BUF_PUSH(str, '\\\\');\n            special = 0;\n          }\n          else\n            special = 1;\n          break;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (special)\n          {\n            if ((*repl) - '0' <= subs_nb)\n            {\n              long index = (*repl) - '0' - 1 + offset;\n              long delta = subs_a[index].end - subs_a[index].start;\n\n              if (delta > 0)\n              {\n                char *ptr = BUF_ADD(str, delta);\n                memcpy(ptr, orig + subs_a[index].start, delta);\n              }\n            }\n            else\n            {\n              *error = 1;\n              break;\n            }\n            special = 0;\n          }\n          else\n          {\n            BUF_PUSH(str, *repl);\n          }\n          break;\n\n        case '0':\n          if (special)\n          {\n            long delta = match_end - match_start;\n\n            if (delta > 0)\n            {\n              char *ptr = BUF_ADD(str, delta);\n              memcpy(ptr, orig + match_start, delta);\n            }\n\n            special = 0;\n          }\n          else\n          {\n            BUF_PUSH(str, *repl);\n            special = 0;\n          }\n          break;\n\n        case '&':\n          if (!special)\n          {\n            long delta = match_end - match_start;\n\n            if (delta > 0)\n            {\n              char *ptr = BUF_ADD(str, delta);\n              memcpy(ptr, orig + match_start, delta);\n            }\n          }\n          else\n          {\n            BUF_PUSH(str, '&');\n            special = 0;\n          }\n          break;\n\n        default:\n          BUF_PUSH(str, *repl);\n          special = 0;\n      }\n      repl++;\n    }\n\n  BUF_PUSH(str, '\\0');\n\n  if (special > 0)\n    *error = 1;\n\n  return str;\n}\n\n/* ====================================================================== */\n/* Replace the part of a string matched by an extender regular expression */\n/* by the substitution string.                                            */\n/* The regex used must have been previously compiled.                     */\n/*                                                                        */\n/* orig: original string                                                  */\n/* sed:      composite variable containing the regular expression, a      */\n/*           substitution string and various other information.           */\n/* output:   destination buffer.                                          */\n/*                                                                        */\n/* return 1 if the replacement has been successful else 0.                */\n/*                                                                        */\n/* NOTE:                                                                  */\n/* uses the global variable word_buffer.                                  */\n/* ====================================================================== */\nint\nreplace(char *orig, sed_t *sed)\n{\n  size_t match_nb   = 0; /* number of matches in the original string. */\n  int    sub_nb     = 0; /* number of remembered matches in the       *\n                          | original string.                          */\n  size_t target_len = 0; /* length of the resulting string.           */\n  size_t subs_max   = 0;\n\n  if (*orig == '\\0')\n    return 1;\n\n  range_t *matches_a = xmalloc(strlen(orig) * sizeof(range_t));\n  range_t *subs_a    = xmalloc(10 * sizeof(range_t));\n\n  const char *p = orig; /* points to the end of the previous match. */\n  regmatch_t  m[10];    /* array containing the start/end offsets   *\n                         | of the matches found.                    */\n\n  while (1)\n  {\n    size_t i = 0;\n    size_t match;       /* current match index.                        */\n    size_t index   = 0; /* current char index in the original string.  */\n    int    nomatch = 0; /* equals to 1 when there is no more matching. */\n    char  *exp_repl;    /* expanded replacement string.                */\n\n    if (*p == '\\0')\n      nomatch = 1;\n    else\n      nomatch = regexec(&sed->re, p, 10, m, 0);\n\n    if (nomatch)\n    {\n      if (match_nb > 0)\n      {\n        for (index = 0; index < matches_a[0].start; index++)\n          word_buffer[target_len++] = orig[index];\n\n        for (match = 0; match < match_nb; match++)\n        {\n          size_t len;\n          size_t end;\n          int    error;\n\n          exp_repl = build_repl_string(orig,\n                                       sed->substitution,\n                                       matches_a[match].start,\n                                       matches_a[match].end,\n                                       subs_a,\n                                       subs_max,\n                                       match,\n                                       &error);\n\n          if (error)\n          {\n            fprintf(stderr,\n                    \"Invalid matching group reference \"\n                    \"in the replacement string \\\"%s\\\".\\n\",\n                    sed->substitution);\n            exit(EXIT_FAILURE);\n          }\n\n          len = strlen(exp_repl);\n\n          my_strcpy(word_buffer + target_len, exp_repl);\n          target_len += len;\n\n          BUF_FREE(exp_repl);\n\n          index += matches_a[match].end - matches_a[match].start;\n\n          if (match < match_nb - 1 && sed->global)\n            end = matches_a[match + 1].start;\n          else\n            end = strlen(orig);\n\n          while (index < end)\n            word_buffer[target_len++] = orig[index++];\n\n          word_buffer[target_len] = '\\0';\n\n          if (!sed->global)\n            break;\n        }\n      }\n      else\n      {\n        my_strcpy(word_buffer, orig);\n        free(matches_a);\n        free(subs_a);\n        return 0;\n      }\n\n      free(matches_a);\n      free(subs_a);\n      return nomatch;\n    }\n\n    subs_max = 0;\n    for (i = 0; i < 10; i++)\n    {\n      size_t start;\n      size_t finish;\n\n      if (m[i].rm_so == -1)\n        break;\n\n      start  = m[i].rm_so + (p - orig);\n      finish = m[i].rm_eo + (p - orig);\n\n      if (i == 0)\n      {\n        matches_a[match_nb].start = start;\n        matches_a[match_nb].end   = finish;\n        match_nb++;\n        if (match_nb > utf8_strlen(orig))\n          goto fail;\n      }\n      else\n      {\n        subs_a[sub_nb].start = start;\n        subs_a[sub_nb].end   = finish;\n        sub_nb++;\n        subs_max++;\n      }\n    }\n    if (m[0].rm_eo > 0)\n      p += m[0].rm_eo;\n    else\n      p++; /* Empty match. */\n  }\n\nfail:\n  free(matches_a);\n  free(subs_a);\n  return 0;\n}\n\n/* ============================================================ */\n/* Remove all ANSI color codes from s and puts the result in d. */\n/* Memory space for d must have been allocated before.          */\n/* ============================================================ */\nvoid\nstrip_ansi_color(char *s, toggle_t *toggles, misc_t *misc)\n{\n  char *p   = s;\n  long  len = strlen(s);\n\n  while (*s != '\\0')\n  {\n    /* Remove a sequence of \\x1b[...m from s. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((*s == 0x1b) && (*(s + 1) == '['))\n    {\n      while ((*s != '\\0') && (*s++ != 'm'))\n        ;\n    }\n    /* Convert a single \\x1b in the invalid substitute character. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    else if (*s == 0x1b)\n    {\n      if (toggles->blank_nonprintable && len > 1)\n        *s++ = ' '; /* Non printable character -> ' '. */\n      else\n        *s++ = misc->invalid_char_substitute;\n      p++;\n    }\n    /* No ESC char, we can move on. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    else\n      *p++ = *s++;\n  }\n\n  *p = '\\0';\n}\n\n/* ================================================================== */\n/* Callback function used by tst_traverse to insert the index         */\n/* of a matching word index in the sorted list of the already matched */\n/* words.                                                             */\n/* Always succeeds and returns 1.                                     */\n/* ================================================================== */\nint\nset_matching_flag(void *elem)\n{\n  ll_t *list = (ll_t *)elem;\n\n  ll_node_t *node = list->head;\n  long       target;\n\n  while (node)\n  {\n    size_t pos;\n\n    pos = *(size_t *)(node->data);\n    if (word_a[pos].is_selectable)\n      word_a[pos].is_matching = 1;\n\n    target = get_sorted_array_target_pos(matching_words_da,\n                                         BUF_LEN(matching_words_da),\n                                         pos);\n    if (target >= 0)\n      BUF_INSERT(matching_words_da, target, pos);\n\n    node = node->next;\n  }\n  return 1;\n}\n\n/* ======================================================================= */\n/* Callback function used by tst_traverse applied to tst_word so this      */\n/* function is applied on each node of this tst.                           */\n/*                                                                         */\n/* Each node of this tst contains a linked list storing the indexes of     */\n/* the words in the input flow.                                            */\n/* Each position in this list is used to:                                  */\n/* - mark the word at that position as matching,                           */\n/* - add this position in the sorted array matching_words_da.              */\n/* Always succeeds and returns 1.                                          */\n/* ======================================================================= */\nint\ntst_search_cb(void *elem)\n{\n  /* The data attached to the string in the tst is a linked list of   */\n  /* position of the string in the input flow, This list is naturally */\n  /* sorted.                                                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ll_t *list = (ll_t *)elem;\n\n  ll_node_t *node = list->head;\n  long       target;\n\n  while (node)\n  {\n    long pos;\n\n    pos = *(long *)(node->data);\n\n    word_a[pos].is_matching = 1;\n\n    target = get_sorted_array_target_pos(matching_words_da,\n                                         BUF_LEN(matching_words_da),\n                                         pos);\n    if (target >= 0)\n      BUF_INSERT(matching_words_da, target, pos);\n\n    node = node->next;\n  }\n  return 1; /* OK. */\n}\n\n/* **************** */\n/* Input functions. */\n/* **************** */\n\n/* ===================================================================== */\n/* Non delay reading of a scancode.                                      */\n/* Update a scancodes buffer and return its length  in bytes.            */\n/* The length of the scancode cannot reach max which must be lower of    */\n/* equal than 63 which is the size minus one of the buffer array defined */\n/* in main.                                                              */\n/* ===================================================================== */\nint\nget_scancode(unsigned char *s, size_t max)\n{\n  int            c;\n  size_t         i = 1;\n  struct termios original_ts, nowait_ts;\n\n  /* Wait until all data has been transmitted to stdin. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  tcdrain(0);\n\n  if ((c = my_fgetc(stdin)) == EOF)\n    return 0;\n\n  /* Initialize the string with the first byte. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  memset(s, '\\0', max);\n  s[0] = c;\n\n  /* 0x1b (ESC) has been found, proceed to check if additional codes */\n  /* are available.                                                  */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (c == 0x1b || c > 0x80)\n  {\n    /* Save the terminal parameters and configure getchar() */\n    /* to return immediately.                               */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    tcgetattr(0, &original_ts);\n    nowait_ts = original_ts;\n    nowait_ts.c_lflag &= ~ISIG;\n    nowait_ts.c_cc[VMIN]  = 0;\n    nowait_ts.c_cc[VTIME] = 0;\n\n    /* tcsetattr_safe cannot fail here. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    (void)tcsetattr_safe(0, TCSADRAIN, &nowait_ts);\n\n    /* Check if additional code is available after 0x1b. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((c = my_fgetc(stdin)) != EOF)\n    {\n      s[1] = c;\n\n      i = 2;\n      while (i < max && (c = my_fgetc(stdin)) != EOF)\n        s[i++] = c;\n    }\n    else\n    {\n      /* There isn't a new code, this mean 0x1b came from ESC key. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    }\n\n    /* Restore the save terminal parameters. */\n    /* tcsetattr_safe cannot fail here.      */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    (void)tcsetattr_safe(0, TCSADRAIN, &original_ts);\n\n    /* Ignore EOF when a scancode contains an escape sequence. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    clearerr(stdin);\n  }\n\n  return i;\n}\n\n/* ============================================================ */\n/* Helper function to compare to delimiters for use by ll_find. */\n/* ============================================================ */\nint\nbuffer_cmp(const void *a, const void *b)\n{\n  return strcmp((const char *)a, (const char *)b);\n}\n\n/* ===================================================================== */\n/* Get bytes from stdin. If the first byte is the leading character of a */\n/* UTF-8 glyph, the following ones are also read.                        */\n/* The utf8_get_length function is used to get the number of bytes of    */\n/* the character.                                                        */\n/* ===================================================================== */\nint\nread_bytes(FILE       *input,\n           char       *utf8_buffer,\n           ll_t       *zapped_glyphs_list,\n           langinfo_t *langinfo,\n           misc_t     *misc)\n{\n  int byte;\n  int last;\n  int n;\n\n  do\n  {\n    last = 0;\n\n    /* Read the first byte. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    byte = my_fgetc(input);\n\n    if (byte == EOF)\n      return EOF;\n\n    utf8_buffer[last++] = byte;\n\n    /* Check if we need to read more bytes to form a sequence */\n    /* and put the number of bytes of the sequence in last.   */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (langinfo->utf8 && ((n = utf8_get_length(byte)) > 1))\n    {\n      while (last < n && (byte = my_fgetc(input)) != EOF\n             && (byte & 0xc0) == 0x80)\n        utf8_buffer[last++] = byte;\n\n      if (byte == EOF)\n        return EOF;\n    }\n\n    utf8_buffer[last] = '\\0';\n\n    /* Replace an invalid UTF-8 byte sequence by a single dot.  */\n    /* In this case the original sequence is lost (unsupported  */\n    /* encoding).                                               */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (langinfo->utf8 && utf8_validate(utf8_buffer) != NULL)\n    {\n      byte = utf8_buffer[0] = misc->invalid_char_substitute;\n      utf8_buffer[1]        = '\\0';\n    }\n  } while (ll_find(zapped_glyphs_list, utf8_buffer, buffer_cmp) != NULL);\n\n  return byte;\n}\n\n/* =======================================================================*/\n/* Expand the string str by replacing all its embedded special characters */\n/* by their corresponding escape sequence.                                */\n/*                                                                        */\n/* dest must be long enough to contain the expanded string.               */\n/*                                                                        */\n/* Replace also UTF-8 glyphs by the substitution character if the         */\n/* current locale if not UTF-8.                                           */\n/*                                                                        */\n/* Return the number of resulting glyphs.                                 */\n/* ====================================================================== */\nsize_t\nexpand(char       *src,\n       char       *dest,\n       langinfo_t *langinfo,\n       toggle_t   *toggles,\n       misc_t     *misc)\n{\n  char   c;\n  int    n;\n  int    all_spaces = 1;\n  char  *ptr        = dest;\n  size_t len        = 0;\n\n  while ((c = *(src++)))\n  {\n    /* UTF-8 codepoints may take more than on character. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((n = utf8_get_length(c)) > 1)\n    {\n      all_spaces = 0;\n\n      if (langinfo->utf8)\n        /* If the locale is UTF-8 aware, copy src into ptr. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        do\n        {\n          *(ptr++) = c;\n          len++;\n        } while (--n && (c = *(src++)));\n      else\n      {\n        /* If not, ignore the bytes composing the UTF-8 glyph and replace */\n        /* them with the substitution character.                          */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        do\n        {\n          /* Skip this byte. */\n          /* ''''''''''''''' */\n        } while (--n && ('\\0' != *(src++)));\n\n        *(ptr++) = misc->invalid_char_substitute;\n        len++;\n      }\n    }\n    else\n      /* This is not a multibyte UTF-8 glyph. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      switch (c)\n      {\n        case '\\a':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 'a';\n          goto common_code;\n        case '\\b':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 'b';\n          goto common_code;\n        case '\\t':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 't';\n          goto common_code;\n        case '\\n':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 'n';\n          goto common_code;\n        case '\\v':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 'v';\n          goto common_code;\n        case '\\f':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 'f';\n          goto common_code;\n        case '\\r':\n          *(ptr++) = '\\\\';\n          *(ptr++) = 'r';\n          goto common_code;\n        case '\\\\':\n          *(ptr++) = '\\\\';\n          *(ptr++) = '\\\\';\n          goto common_code;\n\n        common_code:\n          len += 2;\n          all_spaces = 0;\n          break;\n\n        default:\n          if (my_isprint(c))\n          {\n            if (c != ' ')\n              all_spaces = 0;\n\n            *(ptr++) = c;\n          }\n          else\n          {\n            if (toggles->blank_nonprintable)\n              *(ptr++) = ' '; /* Non printable character -> ' '. */\n            else\n            {\n              *(ptr++)   = misc->invalid_char_substitute;\n              all_spaces = 0;\n            }\n          }\n          len++;\n      }\n  }\n\n  /* If the word contains only spaces, replace them */\n  /* by underscores so that it can be seen.         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (toggles->show_blank_words && all_spaces)\n    memset(dest, misc->blank_char_substitute, len);\n\n  *ptr = '\\0'; /* Ensure that dest has a nul terminator. */\n\n  return len;\n}\n\n/* ====================================================================== */\n/* read_word(input): return a char pointer to the next word (as a string) */\n/* Accept: a FILE * for the input stream.                                 */\n/* Return: a char *                                                       */\n/*    On Success: the return value will point to a nul-terminated         */\n/*                string.                                                 */\n/*    On Failure: the return value will be set to NULL.                   */\n/* ====================================================================== */\nchar *\nread_word(FILE          *input,\n          ll_t          *word_delims_list,\n          ll_t          *line_delims_list,\n          ll_t          *zapped_glyphs_list,\n          char          *utf8_buffer,\n          unsigned char *is_last,\n          toggle_t      *toggles,\n          langinfo_t    *langinfo,\n          win_t         *win,\n          limit_t       *limits,\n          misc_t        *misc)\n{\n  char         *temp = NULL;\n  int           byte;\n  long          utf8_count = 0; /* count chars used in current allocation. */\n  long          wordsize;       /* size of current allocation in chars.    */\n  unsigned char is_dquote;      /* double quote presence indicator.        */\n  unsigned char is_squote;      /* single quote presence indicator.        */\n  int           is_special;     /* a character is special after a \\        */\n\n  /* Skip leading delimiters. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  do\n    byte = read_bytes(input, utf8_buffer, zapped_glyphs_list, langinfo, misc);\n  while (byte != EOF\n         && ll_find(word_delims_list, utf8_buffer, buffer_cmp) != NULL);\n\n  if (byte == EOF)\n    return NULL;\n\n  /* Allocate initial word storage space. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  wordsize = CHARSCHUNK;\n  temp     = xmalloc(wordsize);\n\n  /* Start stashing bytes. Stop when we meet a non delimiter or EOF. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  utf8_count = 0;\n  is_dquote  = 0;\n  is_squote  = 0;\n  is_special = 0;\n\n  while (byte != EOF)\n  {\n    size_t i = 0;\n\n    if (utf8_count >= limits->word_length)\n    {\n      fprintf(stderr,\n              \"The length of a word has reached the limit of \"\n              \"%ld characters.\\n\",\n              limits->word_length);\n\n      exit(EXIT_FAILURE);\n    }\n\n    if (byte == '\\\\' && !is_special)\n    {\n      is_special = 1;\n      goto next;\n    }\n\n    /* Parse special characters. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (is_special)\n      switch (byte)\n      {\n        case 'a':\n          utf8_buffer[0] = byte = '\\a';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 'b':\n          utf8_buffer[0] = byte = '\\b';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 't':\n          utf8_buffer[0] = byte = '\\t';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 'n':\n          utf8_buffer[0] = byte = '\\n';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 'v':\n          utf8_buffer[0] = byte = '\\v';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 'f':\n          utf8_buffer[0] = byte = '\\f';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 'r':\n          utf8_buffer[0] = byte = '\\r';\n          utf8_buffer[1]        = '\\0';\n          break;\n\n        case 'u':\n          utf8_buffer[0] = '\\\\';\n          utf8_buffer[1] = 'u';\n          utf8_buffer[2] = '\\0';\n          break;\n\n        case 'U':\n          utf8_buffer[0] = '\\\\';\n          utf8_buffer[1] = 'U';\n          utf8_buffer[2] = '\\0';\n          break;\n\n        case '\\\\':\n          utf8_buffer[0] = byte = '\\\\';\n          utf8_buffer[1]        = '\\0';\n          break;\n      }\n    else\n    {\n      if (!misc->ignore_quotes)\n      {\n        /* Manage double quotes. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (byte == '\"' && !is_squote)\n          is_dquote ^= 1;\n\n        /* Manage single quotes. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (byte == '\\'' && !is_dquote)\n          is_squote ^= 1;\n      }\n    }\n\n    /* Only consider delimiters when outside quotations. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((!is_dquote && !is_squote)\n        && ll_find(word_delims_list, utf8_buffer, buffer_cmp) != NULL)\n      break;\n\n    /* We no dot count the significant quotes. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!misc->ignore_quotes && !is_special\n        && ((byte == '\"' && !is_squote) || (byte == '\\'' && !is_dquote)))\n    {\n      is_special = 0;\n      goto next;\n    }\n\n    /* Feed temp with the content of utf8_buffer. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while (utf8_buffer[i] != '\\0')\n    {\n      if (utf8_count >= wordsize - 1)\n        temp = xrealloc(temp,\n                        wordsize += (utf8_count / CHARSCHUNK + 1) * CHARSCHUNK);\n\n      *(temp + utf8_count++) = utf8_buffer[i];\n      i++;\n    }\n\n    is_special = 0;\n\n  next:\n    byte = read_bytes(input, utf8_buffer, zapped_glyphs_list, langinfo, misc);\n  }\n\n  /* Nul-terminate the word to make it a string. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *(temp + utf8_count) = '\\0';\n\n  /* Replace the UTF-8 ASCII representations in the word just */\n  /* read by their binary values.                             */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  utf8_interpret(temp, misc->invalid_char_substitute);\n\n  /* Skip all field delimiters before a record delimiter. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (ll_find(line_delims_list, utf8_buffer, buffer_cmp) == NULL)\n  {\n    byte = read_bytes(input, utf8_buffer, zapped_glyphs_list, langinfo, misc);\n\n    while (byte != EOF\n           && ll_find(word_delims_list, utf8_buffer, buffer_cmp) != NULL\n           && ll_find(line_delims_list, utf8_buffer, buffer_cmp) == NULL)\n      byte = read_bytes(input, utf8_buffer, zapped_glyphs_list, langinfo, misc);\n\n    if (byte != EOF)\n    {\n      if (langinfo->utf8 && utf8_get_length(utf8_buffer[0]) > 1)\n      {\n        size_t pos;\n\n        pos = strlen(utf8_buffer);\n        while (pos > 0)\n          my_ungetc(utf8_buffer[--pos], input);\n      }\n      else\n        my_ungetc(byte, input);\n    }\n  }\n\n  /* Mark it as the last word of a record if its sequence matches a */\n  /* record delimiter.                                              */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (byte == EOF\n      || ((win->col_mode || win->line_mode || win->tab_mode)\n          && ll_find(line_delims_list, utf8_buffer, buffer_cmp) != NULL))\n    *is_last = 1;\n  else\n    *is_last = 0;\n\n  /* Remove the ANSI color escape sequences from the word. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  strip_ansi_color(temp, toggles, misc);\n\n  return temp;\n}\n\n/* ================================================================ */\n/* Convert the 8 first colors from setf/setaf coding to setaf/setf. */\n/* ================================================================ */\nshort\ncolor_transcode(short color)\n{\n  switch (color)\n  {\n    case 1:\n      return 4;\n    case 3:\n      return 6;\n    case 4:\n      return 1;\n    case 6:\n      return 3;\n    default:\n      return color;\n  }\n}\n\n/* ========================================================== */\n/* Set a foreground color according to terminal capabilities. */\n/* ========================================================== */\nvoid\nset_foreground_color(term_t *term, short color)\n{\n  if (term->color_method == CLASSIC)\n  {\n    if (term->has_setf)\n      (void)tputs(TPARM2(set_foreground, color), 1, outch);\n    if (term->has_setaf)\n      (void)tputs(TPARM2(set_a_foreground, color_transcode(color)), 1, outch);\n  }\n\n  else if (term->color_method == ANSI)\n  {\n    if (term->has_setaf)\n      (void)tputs(TPARM2(set_a_foreground, color), 1, outch);\n    if (term->has_setf)\n      (void)tputs(TPARM2(set_foreground, color_transcode(color)), 1, outch);\n  }\n}\n\n/* ========================================================== */\n/* Set a background color according to terminal capabilities. */\n/* ========================================================== */\nvoid\nset_background_color(term_t *term, short color)\n{\n  if (term->color_method == CLASSIC)\n  {\n    if (term->has_setb)\n      (void)tputs(TPARM2(set_background, color), 1, outch);\n    if (term->has_setab)\n      (void)tputs(TPARM2(set_a_background, color_transcode(color)), 1, outch);\n  }\n\n  else if (term->color_method == ANSI)\n  {\n    if (term->has_setab)\n      (void)tputs(TPARM2(set_a_background, color), 1, outch);\n    if (term->has_setb)\n      (void)tputs(TPARM2(set_background, color_transcode(color)), 1, outch);\n  }\n}\n\n/* ======================================================= */\n/* Put a scrolling symbol at the first column of the line. */\n/* ======================================================= */\nvoid\nleft_margin_putp(char *s, term_t *term, win_t *win)\n{\n  apply_attr(term, win->shift_attr);\n\n  /* We won't print this symbol when not in column mode. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*s != '\\0')\n    fputs_safe(s, stdout);\n\n  (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n}\n\n/* ====================================================== */\n/* Put a scrolling symbol at the last column of the line. */\n/* ====================================================== */\nvoid\nright_margin_putp(char       *s1,\n                  char       *s2,\n                  langinfo_t *langinfo,\n                  term_t     *term,\n                  win_t      *win,\n                  long        line,\n                  long        offset)\n{\n  apply_attr(term, win->bar_attr);\n\n  if (term->has_hpa)\n    (void)tputs(TPARM2(column_address, offset + win->max_width + 1), 1, outch);\n  else if (term->has_cursor_address)\n    (void)tputs(TPARM3(cursor_address,\n                       term->curs_line + line - 2,\n                       offset + win->max_width + 1),\n                1,\n                outch);\n  else if (term->has_parm_right_cursor)\n  {\n    fputc_safe('\\r', stdout);\n    (void)tputs(TPARM2(parm_right_cursor, offset + win->max_width + 1),\n                1,\n                outch);\n  }\n  else\n  {\n    long i;\n\n    fputc_safe('\\r', stdout);\n    for (i = 0; i < offset + win->max_width + 1; i++)\n      (void)tputs(TPARM1(cursor_right), 1, outch);\n  }\n\n  if (langinfo->utf8)\n    fputs_safe(s1, stdout);\n  else\n    fputs_safe(s2, stdout);\n\n  (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n}\n\n/* ==========================================================*/\n/* Displays an horizontal scroll bar below the window.       */\n/* The bar if only displayed in line or column mode when the */\n/* line containing the cursor is truncated.                  */\n/*                                                           */\n/* mark is the offset of the cursor in the bar.              */\n/* ==========================================================*/\nvoid\ndisp_hbar(win_t *win, term_t *term, langinfo_t *langinfo, int pos1, int pos2)\n{\n  int i;\n\n  apply_attr(term, win->bar_attr);\n\n  (void)tputs(TPARM1(clr_eol), 1, outch);\n\n  /* Draw the left symbol arrow. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (langinfo->utf8)\n  {\n    if (pos1 == 0)\n      fputs_safe(hbar_begin, stdout);\n    else\n      fputs_safe(hbar_left, stdout);\n  }\n  else\n  {\n    if (pos1 == 0)\n      fputc_safe('<', stdout);\n    else\n      fputc_safe('\\\\', stdout);\n  }\n\n  /* Draw the line in the horizontal bar. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (term->has_rep && !langinfo->utf8)\n    (void)tputs(TPARM3(repeat_char, '-', term->ncolumns - 2), 1, outch);\n  else\n  {\n    char *s;\n\n    if (langinfo->utf8)\n      s = hbar_line;\n    else\n      s = \"-\";\n\n    for (i = 0; i < term->ncolumns - 3; i++)\n      fputs_safe(s, stdout);\n  }\n\n  /* Draw the cursor. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (term->has_hpa)\n  {\n    char *s;\n\n    if (langinfo->utf8)\n      s = hbar_curs;\n    else\n      s = \"#\";\n\n    (void)tputs(TPARM2(column_address, pos1 + 1), 1, outch);\n    for (i = pos1 + 1; i <= pos2 + 1; i++)\n      fputs_safe(s, stdout);\n\n    (void)tputs(TPARM2(column_address, term->ncolumns - 2), 1, outch);\n  }\n  else if (term->has_parm_right_cursor)\n  {\n    char *s;\n\n    if (langinfo->utf8)\n      s = hbar_curs;\n    else\n      s = \"#\";\n\n    fputs_safe(\"\\r\", stdout);\n    (void)tputs(TPARM2(parm_right_cursor, pos1 + 1), 1, outch);\n\n    for (i = pos1; i <= pos2; i++)\n      fputs_safe(s, stdout);\n\n    fputs_safe(\"\\r\", stdout);\n    (void)tputs(TPARM2(parm_right_cursor, term->ncolumns - 2), 1, outch);\n  }\n  else\n  {\n    char *s;\n\n    if (langinfo->utf8)\n      s = hbar_curs;\n    else\n      s = \"#\";\n\n    fputs_safe(\"\\r\", stdout);\n    (void)tputs(TPARM2(cursor_right, 1), 1, outch);\n    for (i = 0; i < pos1; i++)\n      (void)tputs(TPARM1(cursor_right), 1, outch);\n\n    for (i = pos1 + 2; i <= pos2 + 1; i++)\n      fputs_safe(s, stdout);\n\n    for (i = pos1; i < term->ncolumns - 3 - pos2 - 2; i++)\n      (void)tputs(TPARM1(cursor_right), 1, outch);\n  }\n\n  /* Draw the right symbol arrow. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (langinfo->utf8)\n  {\n    if (pos2 == term->ncolumns - 4)\n      fputs_safe(hbar_end, stdout);\n    else\n      fputs_safe(hbar_right, stdout);\n  }\n  else\n  {\n    if (pos2 == term->ncolumns - 4)\n      fputc_safe('>', stdout);\n    else\n      fputc_safe('/', stdout);\n  }\n\n  (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n}\n\n/* *************** */\n/* Core functions. */\n/* *************** */\n\n/* ============================================================== */\n/* Split the lines of the message given to -m to a linked list of */\n/* lines.                                                         */\n/* Also fill the maximum screen width and the maximum number      */\n/* of bytes of the longest line.                                  */\n/* ============================================================== */\nvoid\nget_message_lines(char *message,\n                  ll_t *message_lines_list,\n                  long *message_max_width,\n                  long *message_max_len)\n{\n  char    *str;\n  char    *ptr;\n  char    *cr_ptr;\n  long     n;\n  wchar_t *w = NULL;\n\n  *message_max_width = 0;\n  *message_max_len   = 0;\n  ptr                = message;\n\n  /* For each line terminated with a EOL character. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while (*ptr != '\\0' && (cr_ptr = strchr(ptr, '\\n')) != NULL)\n  {\n    if (cr_ptr > ptr)\n    {\n      str               = xmalloc(cr_ptr - ptr + 1);\n      str[cr_ptr - ptr] = '\\0';\n      memcpy(str, ptr, cr_ptr - ptr);\n    }\n    else\n      str = xstrdup(\"\");\n\n    ll_append(message_lines_list, str);\n\n    /* If needed, update the message maximum width. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    n = my_wcswidth((w = utf8_strtowcs(str)), utf8_strlen(str));\n    free(w);\n\n    if (n > *message_max_width)\n      *message_max_width = n;\n\n    /* If needed, update the message maximum number */\n    /* of bytes used by the longest line.           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((n = (long)strlen(str)) > *message_max_len)\n      *message_max_len = n;\n\n    ptr = cr_ptr + 1;\n  }\n\n  /* For the last line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*ptr != '\\0')\n  {\n    ll_append(message_lines_list, xstrdup(ptr));\n\n    n = my_wcswidth((w = utf8_strtowcs(ptr)), utf8_strlen(ptr));\n    free(w);\n\n    if (n > *message_max_width)\n      *message_max_width = n;\n\n    /* If needed, update the message maximum number */\n    /* of bytes used by the longest line.           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((n = (long)strlen(ptr)) > *message_max_len)\n      *message_max_len = n;\n  }\n  else\n    ll_append(message_lines_list, xstrdup(\"\"));\n}\n\n/* =================================================================== */\n/* Set the new start and the new end of the window structure according */\n/* to the current cursor position.                                     */\n/* =================================================================== */\nvoid\nset_win_start_end(win_t *win, long current, long last)\n{\n  long cur_line, end_line;\n\n  cur_line = line_nb_of_word_a[current];\n  if (cur_line == last)\n    win->end = count - 1;\n  else\n  {\n    /* In help mode we must not modify the windows start/end position as */\n    /* It must be redrawn exactly as it was before.                      */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!help_mode)\n    {\n      if (cur_line + win->max_lines / 2 + 1 <= last)\n        win->end = first_word_in_line_a[cur_line + win->max_lines / 2 + 1] - 1;\n      else\n        win->end = first_word_in_line_a[last];\n    }\n  }\n  end_line = line_nb_of_word_a[win->end];\n\n  if (end_line < win->max_lines)\n    win->start = 0;\n  else\n    win->start = first_word_in_line_a[end_line - win->max_lines + 1];\n}\n\n/* ======================================================================== */\n/* Set the metadata associated with a word, its starting and ending         */\n/* position, the line in which it is put and so on.                         */\n/* Set win.start win.end and the starting and ending position of each word. */\n/* This function is only called initially, when resizing the terminal and   */\n/* potentially when the search function is used.                            */\n/*                                                                          */\n/* Returns the number of the last line built.                               */\n/* ======================================================================== */\nlong\nbuild_metadata(term_t *term, long count, win_t *win)\n{\n  long     i = 0;\n  long     word_len;   /* Apparent length of the current word on the    *\n                        | terminal.                                     */\n  long     len  = 0;   /* Current line length.                          */\n  long     last = 0;   /* Number of the last line built.                */\n  long     word_width; /* Number of screen positions taken by the word. */\n  long     tab_count;  /* Current number of words in the line, used in  *\n                        | tab_mode.                                     */\n  wchar_t *w;\n\n  line_nb_of_word_a[0]    = 0;\n  first_word_in_line_a[0] = 0;\n\n  /* In column mode we need to calculate win->max_width, first initialize */\n  /* it to 0 and increment it later in the loop.                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!win->col_mode)\n  {\n    win->max_width      = 0;\n    win->real_max_width = 0;\n  }\n\n  tab_count = 0;\n  while (i < count)\n  {\n    /* Determine the number of screen positions taken by the word. */\n    /* Note: mbstowcs will always succeed here as word_a[i].str    */\n    /*       has already been utf8_validated/repaired.             */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    word_len   = mbstowcs(NULL, word_a[i].str, 0);\n    word_width = my_wcswidth((w = utf8_strtowcs(word_a[i].str)), word_len);\n\n    /* Manage the case where the word is larger than the terminal width. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (word_width >= term->ncolumns - 2)\n    {\n      /* Shorten the word until it fits. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      do\n      {\n        word_width = my_wcswidth(w, word_len--);\n      } while (word_len > 0 && word_width >= term->ncolumns - 2);\n    }\n    free(w);\n\n    /* Look if there is enough remaining place on the line when not in   */\n    /* column mode. Force a break if the 'is_last' flag is set in all    */\n    /* modes or if we hit the max number of allowed columns in tab mode. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((!win->col_mode && !win->line_mode\n         && (len + word_width + 1) >= term->ncolumns - 1)\n        || ((win->col_mode || win->line_mode || win->tab_mode) && i > 0\n            && word_a[i - 1].is_last)\n        || (win->tab_mode && win->max_cols > 0 && tab_count >= win->max_cols))\n    {\n\n      /* We must build another line. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      line_nb_of_word_a[i]       = ++last;\n      first_word_in_line_a[last] = i;\n\n      word_a[i].start = 0;\n\n      len           = word_width + 1; /* Resets the current line length.    */\n      tab_count     = 1;              /* Resets the current number of words *\n                                       | in the line.                       */\n      word_a[i].end = word_width - 1;\n      word_a[i].mb  = word_len;\n    }\n    else\n    {\n      word_a[i].start      = len;\n      word_a[i].end        = word_a[i].start + word_width - 1;\n      word_a[i].mb         = word_len;\n      line_nb_of_word_a[i] = last;\n\n      len += word_width + 1; /* Increase line length.                */\n      tab_count++;           /* We've seen another word in the line/ */\n    }\n\n    /* Update win->(real_)max_width if necessary. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (len > win->max_width)\n    {\n      /* Update the effective line width. */\n      /* '''''''''''''''''''''''''''''''' */\n      if (len > term->ncolumns)\n      {\n        win->max_width = term->ncolumns - 2;\n      }\n      else\n        win->max_width = len;\n    }\n\n    /* Update the real line width. */\n    /* ''''''''''''''''''''''''''' */\n    if (len > win->real_max_width)\n      win->real_max_width = len;\n\n    i++;\n  }\n\n  /* Set the left margin when in centered mode. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!win->center || win->max_width > term->ncolumns - 2)\n    win->offset = 0;\n  else\n    win->offset = (term->ncolumns - 2 - win->max_width) / 2;\n\n  /* We need to recalculate win->start and win->end here */\n  /* because of a possible terminal resizing.            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  set_win_start_end(win, current, last);\n\n  return last;\n}\n\n/* ======================================================================= */\n/* Helper function used by disp_word to print the cursor with the matching */\n/* characters of the word highlighted.                                     */\n/* ======================================================================= */\nvoid\ndisp_cursor_word(long pos, win_t *win, term_t *term, int err)\n{\n  size_t i;\n  int    att_set = 0;\n  char  *p       = word_a[pos].str + daccess.flength;\n  char  *np;\n\n  /* Set the cursor attribute. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n\n  (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n  if (word_a[pos].tag_id > 0)\n  {\n    if (marked == -1)\n      apply_attr(term, win->cursor_on_tag_attr);\n    else\n      apply_attr(term, win->cursor_on_tag_marked_attr);\n  }\n  else\n  {\n    if (marked == -1)\n      apply_attr(term, win->cursor_attr);\n    else\n      apply_attr(term, win->cursor_marked_attr);\n  }\n\n  for (i = 0; i < word_a[pos].mb - daccess.flength; i++)\n  {\n    if (BIT_ISSET(word_a[pos].bitmap, i))\n    {\n      if (!att_set)\n      {\n        att_set = 1;\n\n        /* Set the buffer display attribute. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n        if (err)\n          apply_attr(term, win->match_err_text_attr);\n        else\n          apply_attr(term, win->match_text_attr);\n\n        if (word_a[pos].tag_id > 0)\n        {\n          if (marked == -1)\n            apply_attr(term, win->cursor_on_tag_attr);\n          else\n            apply_attr(term, win->cursor_on_tag_marked_attr);\n        }\n        else\n        {\n          if (marked == -1)\n            apply_attr(term, win->cursor_attr);\n          else\n            apply_attr(term, win->cursor_marked_attr);\n        }\n      }\n    }\n    else\n    {\n      if (att_set)\n      {\n        att_set = 0;\n\n        /* Set the search cursor attribute. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n        if (word_a[pos].tag_id > 0)\n        {\n          if (marked == -1)\n            apply_attr(term, win->cursor_on_tag_attr);\n          else\n            apply_attr(term, win->cursor_on_tag_marked_attr);\n        }\n        else\n        {\n          if (marked == -1)\n            apply_attr(term, win->cursor_attr);\n          else\n            apply_attr(term, win->cursor_marked_attr);\n        }\n      }\n    }\n    np = utf8_next(p);\n    if (np == NULL)\n      fputs_safe(p, stdout);\n    else\n      printf(\"%.*s\", (int)(np - p), p);\n    p = np;\n  }\n}\n\n/* ========================================================== */\n/* Helper function used by disp_word to print a matching word */\n/* with the matching characters of the word highlighted.      */\n/* ========================================================== */\nvoid\ndisp_matching_word(long pos, win_t *win, term_t *term, int is_current, int err)\n{\n  size_t        i;\n  int           att_set = 0;\n  char         *p       = word_a[pos].str + daccess.flength;\n  char         *np;\n  unsigned char level = 0;\n\n  level = word_a[pos].special_level;\n\n  /* Set the search cursor attribute. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n\n  if (!is_current)\n  {\n    if (err)\n      apply_attr(term, win->match_err_field_attr);\n    else\n    {\n      if (level > 0)\n        apply_attr(term, win->special_attr[level - 1]);\n      else\n        apply_attr(term, win->match_field_attr);\n    }\n  }\n  else\n  {\n    if (err)\n      apply_attr(term, win->search_err_field_attr);\n    else\n      apply_attr(term, win->search_field_attr);\n  }\n\n  if (word_a[pos].tag_id > 0)\n    apply_attr(term, win->tag_attr);\n\n  for (i = 0; i < word_a[pos].mb - daccess.flength; i++)\n  {\n    if (BIT_ISSET(word_a[pos].bitmap, i))\n    {\n      if (!att_set)\n      {\n        att_set = 1;\n\n        /* Set the buffer display attribute. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n        if (!is_current)\n        {\n          if (err)\n            apply_attr(term, win->match_err_text_attr);\n          else\n            apply_attr(term, win->match_text_attr);\n        }\n        else\n          apply_attr(term, win->search_text_attr);\n\n        if (word_a[pos].tag_id > 0)\n          apply_attr(term, win->tag_attr);\n      }\n    }\n    else\n    {\n      if (att_set)\n      {\n        att_set = 0;\n\n        /* Set the search cursor attribute. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n        if (!is_current)\n        {\n          if (err)\n            apply_attr(term, win->match_err_field_attr);\n          else\n          {\n            if (level > 0)\n              apply_attr(term, win->special_attr[level - 1]);\n            else\n              apply_attr(term, win->match_field_attr);\n          }\n        }\n        else\n        {\n          if (err)\n            apply_attr(term, win->search_err_field_attr);\n          else\n            apply_attr(term, win->search_field_attr);\n        }\n\n        if (word_a[pos].tag_id > 0)\n          apply_attr(term, win->tag_attr);\n      }\n    }\n\n    np = utf8_next(p);\n    if (np == NULL)\n      fputs_safe(p, stdout);\n    else\n      printf(\"%.*s\", (int)(np - p), p);\n    p = np;\n  }\n}\n\n/* ====================================================================== */\n/* Display a word in, the windows. Manages the following different cases: */\n/* - Search mode display                                                  */\n/* - Cursor display                                                       */\n/* - Normal display                                                       */\n/* - Color or mono display                                                */\n/* ====================================================================== */\nvoid\ndisp_word(long           pos,\n          search_mode_t  search_mode,\n          search_data_t *search_data,\n          term_t        *term,\n          win_t         *win,\n          toggle_t      *toggles,\n          char          *tmp_word)\n{\n  long s = word_a[pos].start;\n  long e = word_a[pos].end;\n  long p;\n\n  char *buffer = search_data->buf;\n\n  if (pos == current)\n  {\n    if (search_mode != NONE)\n    {\n      utf8_strprefix(tmp_word, word_a[pos].str, (long)word_a[pos].mb, &p);\n      if (word_a[pos].is_numbered)\n      {\n        /* Set the direct access number attribute. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        apply_attr(term, win->daccess_attr);\n\n        /* And print it. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n        fputs_safe(daccess.left, stdout);\n        printf(\"%.*s\", daccess.length, tmp_word + 1);\n        fputs_safe(daccess.right, stdout);\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n        fputc_safe(' ', stdout);\n      }\n      else if (daccess.length > 0)\n      {\n        /* Prints the leading spaces. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n        printf(\"%.*s\", daccess.flength, tmp_word);\n      }\n\n      /* Set the search cursor attribute. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (search_data->err)\n        apply_attr(term, win->search_err_field_attr);\n      else\n        apply_attr(term, win->search_field_attr);\n\n      /* The tab attribute must complete the attributes already set. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (word_a[pos].tag_id > 0)\n        apply_attr(term, win->tag_attr);\n\n      /* Print the word part. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      fputs_safe(tmp_word + daccess.flength, stdout);\n\n      if (buffer[0] != '\\0')\n      {\n        long i = 0;\n\n        /* Put the cursor at the beginning of the word. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        for (i = 0; i < e - s + 1 - daccess.flength; i++)\n          (void)tputs(TPARM1(cursor_left), 1, outch);\n\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n\n        /* Set the search cursor attribute. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (search_data->err)\n          apply_attr(term, win->search_err_field_attr);\n        else\n          apply_attr(term, win->search_field_attr);\n\n        disp_matching_word(pos, win, term, 1, search_data->err);\n      }\n    }\n    else\n    {\n      if (daccess.length > 0)\n      {\n        /* If this word is not numbered, reset the display */\n        /* attributes before printing the leading spaces.  */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (!word_a[pos].is_numbered)\n        {\n          /* Print the non significant part of the word. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n          printf(\"%.*s\", daccess.flength - 1, word_a[pos].str);\n          (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n          fputc_safe(' ', stdout);\n        }\n        else\n        {\n          apply_attr(term, win->daccess_attr);\n\n          /* Print the non significant part of the word. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          fputs_safe(daccess.left, stdout);\n          printf(\"%.*s\", daccess.length, word_a[pos].str + 1);\n          fputs_safe(daccess.right, stdout);\n          (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n          fputc_safe(' ', stdout);\n        }\n      }\n\n      /* If we are not in search mode, display a normal cursor. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      utf8_strprefix(tmp_word, word_a[pos].str, (long)word_a[pos].mb, &p);\n      if (word_a[pos].is_matching)\n        disp_cursor_word(pos, win, term, search_data->err);\n      else\n      {\n        if (word_a[pos].tag_id > 0)\n        {\n          if (marked == -1)\n            apply_attr(term, win->cursor_on_tag_attr);\n          else\n          {\n            if (pos == marked)\n              apply_attr(term, win->cursor_on_marked_attr);\n\n            apply_attr(term, win->cursor_on_tag_marked_attr);\n          }\n        }\n        else\n        {\n          if (marked == -1)\n            apply_attr(term, win->cursor_attr);\n          else\n          {\n            if (pos == marked)\n              apply_attr(term, win->cursor_on_marked_attr);\n\n            apply_attr(term, win->cursor_marked_attr);\n          }\n        }\n\n        fputs_safe(tmp_word + daccess.flength, stdout);\n      }\n    }\n    (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n  }\n  else\n  {\n    /* Display a normal word without any attribute. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    utf8_strprefix(tmp_word, word_a[pos].str, (long)word_a[pos].mb, &p);\n\n    /* If words are numbered, emphasis their numbers. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (word_a[pos].is_numbered)\n    {\n      apply_attr(term, win->daccess_attr);\n\n      fputs_safe(daccess.left, stdout);\n      printf(\"%.*s\", daccess.length, tmp_word + 1);\n      fputs_safe(daccess.right, stdout);\n\n      (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n      fputc_safe(' ', stdout);\n    }\n    else if (daccess.length > 0)\n    {\n      long i;\n\n      /* Insert leading spaces if the word is non numbered and */\n      /* padding for all words is set.                         */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n      if (daccess.padding == 'a')\n        for (i = 0; i < daccess.flength; i++)\n          fputc_safe(' ', stdout);\n    }\n\n    if (!word_a[pos].is_selectable)\n      apply_attr(term, win->exclude_attr);\n    else if (word_a[pos].special_level > 0)\n    {\n      unsigned char level = word_a[pos].special_level - 1;\n\n      apply_attr(term, win->special_attr[level]);\n    }\n    else if (toggles->taggable && pos == marked)\n      apply_attr(term, win->marked_attr);\n    else\n    {\n      if (word_a[pos].iattr != NULL) /* is a specific attribute set? */\n        apply_attr(term, *(word_a[pos].iattr));\n      else\n        apply_attr(term, win->include_attr);\n    }\n\n    if (word_a[pos].is_matching)\n      disp_matching_word(pos, win, term, 0, search_data->err);\n    else\n    {\n      if (word_a[pos].tag_id > 0)\n        apply_attr(term, win->tag_attr);\n\n      if ((daccess.length > 0 && daccess.padding == 'a')\n          || word_a[pos].is_numbered)\n        fputs_safe(tmp_word + daccess.flength, stdout);\n      else\n        fputs_safe(tmp_word, stdout);\n    }\n\n    (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n  }\n}\n\n/* =================================== */\n/* Display a message above the window. */\n/* =================================== */\nvoid\ndisp_message(ll_t       *message_lines_list,\n             long        message_max_width,\n             long        message_max_len,\n             term_t     *term,\n             win_t      *win,\n             langinfo_t *langinfo)\n{\n  ll_node_t *node;\n  char      *line;\n  char      *buf;\n  size_t     len;\n  long       size;\n  long       offset;\n  wchar_t   *w;\n  int        n   = 0; /* Counter used to display message lines. */\n  int        cut = 0; /* Will be 1 if the message is shortened. */\n\n  sigset_t mask;\n\n  win->message_lines = 0;\n\n  /* Do nothing if there is no message to display. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (message_lines_list == NULL)\n    return;\n\n  /* Recalculate the number of to-be-displayed lines in the messages */\n  /* if space is missing.                                            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (term->nlines < 3)\n    return;\n\n  win->message_lines = message_lines_list->len;\n  if (win->message_lines > term->nlines - 2)\n  {\n    win->message_lines = term->nlines - 2;\n    win->max_lines     = term->nlines - win->message_lines - 1;\n    cut                = 1;\n  }\n  win->message_lines++;\n\n  /* Deactivate the periodic timer to prevent the interruptions to corrupt */\n  /* screen by altering the timing of the decoding of the terminfo         */\n  /* capabilities.                                                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sigemptyset(&mask);\n  sigaddset(&mask, SIGALRM);\n  sigprocmask(SIG_BLOCK, &mask, NULL);\n\n  node = message_lines_list->head;\n  buf  = xmalloc(message_max_len + 1);\n\n  /* Follow the list of message lines and display each line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (n = 1; n < win->message_lines; n++)\n  {\n    long i;\n\n    line = node->data;\n    len  = utf8_strlen(line);\n    w    = utf8_strtowcs(line);\n\n    /* Adjust size and len if the terminal is not large enough. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    size = my_wcswidth(w, len);\n    while (len > 0 && size > term->ncolumns)\n      size = my_wcswidth(w, --len);\n\n    free(w);\n\n    /* Compute the offset from the left screen border if -M option is set. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    offset = (term->ncolumns - message_max_width - 3) / 2;\n\n    if (win->center && offset > 0)\n      for (i = 0; i < offset; i++)\n        fputc_safe(' ', stdout);\n\n    apply_attr(term, win->message_attr);\n\n    /* Only print the start of a line if the screen width if too small. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    utf8_strprefix(buf, line, len, &size);\n\n    /* Print the line without the ending \\n. */\n    /* ''''''''''''''''''''''''''''''''''''' */\n    if (n > 1 && cut && n == win->message_lines - 1)\n    {\n      if (langinfo->utf8)\n        fputs_safe(msg_arr_down, stdout);\n      else\n        fputc_safe('v', stdout);\n    }\n    else\n      printf(\"%s\", buf);\n\n    /* Complete the short line with spaces until it reach the */\n    /* message max size.                                      */\n    /* '''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    for (i = size; i < message_max_width; i++)\n    {\n      if (i + (offset < 0 ? 0 : offset) >= term->ncolumns)\n        break;\n      fputc_safe(' ', stdout);\n    }\n\n    /* Drop the attributes and print a \\n. */\n    /* ''''''''''''''''''''''''''''''''''' */\n    if (term->nlines > 2)\n    {\n      (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n      puts(\"\");\n    }\n\n    node = node->next;\n  }\n\n  /* Add an empty line without attribute to separate the menu title */\n  /* and the menu content.                                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  puts(\"\");\n\n  free(buf);\n\n  /* Re-enable the periodic timer. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sigprocmask(SIG_UNBLOCK, &mask, NULL);\n}\n\n/* ============================= */\n/* Display the selection window. */\n/* ============================= */\nlong\ndisp_lines(win_t         *win,\n           toggle_t      *toggles,\n           long           current,\n           long           count,\n           search_mode_t  search_mode,\n           search_data_t *search_data,\n           term_t        *term,\n           long           last_line,\n           char          *tmp_word,\n           langinfo_t    *langinfo)\n{\n  long lines_disp;\n  long i;\n  char left_margin_symbol[5]; /* Placeholder for the arrow symbols. */\n  long len;\n  long has_vbar; /* Flag to signal the presence of the vertical bar. */\n  long first_start;\n  int  leftmost_start = 0; /* Starting position of the leftmost selectable *\n                            | word in the window lines.                    */\n  int  rightmost_end  = 0; /* Ending position of the rightmost selectable *\n                            | word in the window lines.                   */\n\n  long first_line; /* real line # on the first line of the window. */\n\n  int row1 = 0, row2 = 0, col = 0; /* Only the rows are used to detect a *\n                                    | bottom-of-page scrolling, col is   *\n                                    | necessary but not required here.   */\n\n  sigset_t mask;\n\n  /* Disable the periodic timer to prevent the interruptions to corrupt */\n  /* screen by altering the timing of the decoding of the terminfo      */\n  /* capabilities.                                                      */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sigemptyset(&mask);\n  sigaddset(&mask, SIGALRM);\n  sigprocmask(SIG_BLOCK, &mask, NULL);\n\n  left_margin_symbol[0] = ' ';\n  left_margin_symbol[1] = '\\0';\n\n  lines_disp     = 1;\n  first_start    = -1;\n  leftmost_start = 0;\n\n  /* Initialize the truncated lines flag. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  win->has_truncated_lines = 0;\n\n  /* Initialize the necessity of displaying the horizontal scroll bar or not. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  win->has_hbar = 0;\n\n  /* Initialize the selectable column guard to its maximum position. */\n  /* for the first window line.                                      */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  shift_right_sym_pos_a[line_nb_of_word_a[win->start] + lines_disp - 1] =\n    term->ncolumns;\n\n  (void)tputs(TPARM1(save_cursor), 1, outch);\n\n  i = win->start; /* Index of the first word in the window. */\n\n  /* Modify the max number of displayed lines if we do not have */\n  /* enough place.                                              */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win->max_lines > term->nlines - win->message_lines)\n    win->max_lines = term->nlines - win->message_lines;\n\n  if (last_line >= win->max_lines)\n    has_vbar = 1;\n  else\n    has_vbar = 0;\n\n  if (win->col_mode || win->line_mode)\n    len = term->ncolumns - 3;\n  else\n    len = term->ncolumns - 2;\n\n  /* If in column mode and the sum of the columns sizes + gutters is      */\n  /* greater than the terminal width,  then prepend a space to be able to */\n  /* display the left arrow indicating that the first displayed column    */\n  /* is not the first one.                                                */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (len > 1\n      && ((win->col_mode || win->line_mode)\n          && win->real_max_width > term->ncolumns - 2))\n  {\n    if (win->first_column > 0)\n    {\n      if (langinfo->utf8)\n        strcpy(left_margin_symbol, shift_left_sym);\n      else\n        strcpy(left_margin_symbol, \"<\");\n\n      if (!toggles->no_hor_scrollbar)\n        win->has_hbar = 1;\n    }\n    else if (toggles->hor_scrollbar)\n      win->has_hbar = 1;\n\n    if (!win->has_truncated_lines)\n      win->has_truncated_lines = 1;\n  }\n  else\n    left_margin_symbol[0] = '\\0';\n\n  /* Center the display ? */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win->offset > 0)\n  {\n    long i;\n    for (i = 0; i < win->offset; i++)\n      fputc_safe(' ', stdout);\n  }\n\n  left_margin_putp(left_margin_symbol, term, win);\n\n  first_line = line_nb_of_word_a[i];\n\n  while (len > 1 && i <= count - 1)\n  {\n    /* Display one word and the space or symbol following it. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (word_a[i].start >= win->first_column\n        && word_a[i].end < len + win->first_column)\n    {\n      if (first_start < 0)\n        first_start = word_a[i].start;\n\n      disp_word(i, search_mode, search_data, term, win, toggles, tmp_word);\n\n      /* Calculate the start offset of the last word of the line */\n      /* containing the cursor in column or line mode.           */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if ((win->col_mode || win->line_mode)\n          && line_nb_of_word_a[current] - first_line + 1 == lines_disp)\n      {\n        long wi;\n\n        wi = first_word_in_line_a[lines_disp + first_line - 1];\n        while (wi < current && !word_a[wi].is_selectable)\n          wi++;\n\n        leftmost_start = word_a[wi].start;\n\n        if (lines_disp + first_line > last_line)\n          wi = count - 1;\n        else\n          wi = first_word_in_line_a[lines_disp + first_line] - 1;\n\n        while (!word_a[wi].is_selectable)\n          wi--;\n\n        rightmost_end = word_a[wi].end;\n      }\n\n      /* If there are more element to be displayed after the right margin */\n      /* in column or line mode.                                          */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if ((win->col_mode || win->line_mode) && i < count - 1\n          && word_a[i + 1].end >= len + win->first_column)\n      {\n        if (!win->has_truncated_lines)\n          win->has_truncated_lines = 1;\n\n        /* Toggle the presence of the horizontal bar if allowed and */\n        /* if this line contains the cursor in column or line mode. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (!toggles->hor_scrollbar && !toggles->no_hor_scrollbar\n            && line_nb_of_word_a[current] - first_line + 1 == lines_disp)\n          win->has_hbar = 1; /* the line containing the cursor is *\n                              | truncated in the window.          */\n\n        apply_attr(term, win->shift_attr);\n\n        if (langinfo->utf8)\n          fputs_safe(shift_right_sym, stdout);\n        else\n          fputc_safe('>', stdout);\n\n        (void)tputs(TPARM1(exit_attribute_mode), 1, outch);\n\n        /* Adjust the selectable column guard to the column just after */\n        /* the last displayed word.                                    */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        shift_right_sym_pos_a[line_nb_of_word_a[i]] = word_a[i].end + 1\n                                                      - first_start + 2;\n      }\n      else\n        /* If we want to display the gutter. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (!word_a[i].is_last && win->col_sep\n            && (win->tab_mode || win->col_mode))\n        {\n          long pos;\n\n          /* Make sure that we are using the right gutter character even */\n          /* if the first displayed word is * not the first of its line. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          pos = i - first_word_in_line_a[line_nb_of_word_a[i]];\n\n          if (pos >= win->gutter_nb) /* Use the last gutter character. */\n            fputs_safe(win->gutter_a[win->gutter_nb - 1], stdout);\n          else\n            fputs_safe(win->gutter_a[pos], stdout);\n        }\n        else\n          /* Else just display a space. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          fputc_safe(' ', stdout);\n    }\n\n    /* Mark the line as the current line, the line containing the cursor. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (i == current)\n      win->cur_line = lines_disp;\n\n    /* Check if we must start a new line. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (i == count - 1 || word_a[i + 1].start == 0)\n    {\n      (void)tputs(TPARM1(clr_eol), 1, outch);\n      if (lines_disp < win->max_lines)\n      {\n        /* If we have more than one line to display. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (has_vbar && !toggles->no_scrollbar\n            && (lines_disp > 1 || i < count - 1))\n        {\n          /* Store the scroll bar column position. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          win->sb_column = win->offset + win->max_width + 1;\n\n          /* Display the next element of the scrollbar. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (line_nb_of_word_a[i] == 0)\n          {\n            if (win->max_lines > 1)\n              right_margin_putp(sbar_top,\n                                \"\\\\\",\n                                langinfo,\n                                term,\n                                win,\n                                lines_disp,\n                                win->offset);\n            else\n              right_margin_putp(sbar_arr_down,\n                                \"^\",\n                                langinfo,\n                                term,\n                                win,\n                                lines_disp,\n                                win->offset);\n          }\n          else if (lines_disp == 1)\n            right_margin_putp(sbar_arr_up,\n                              \"^\",\n                              langinfo,\n                              term,\n                              win,\n                              lines_disp,\n                              win->offset);\n          else if (line_nb_of_word_a[i] == last_line)\n          {\n            if (win->max_lines > 1)\n              right_margin_putp(sbar_down,\n                                \"/\",\n                                langinfo,\n                                term,\n                                win,\n                                lines_disp,\n                                win->offset);\n            else\n              right_margin_putp(sbar_arr_up,\n                                \"^\",\n                                langinfo,\n                                term,\n                                win,\n                                lines_disp,\n                                win->offset);\n          }\n          else if (last_line + 1 > win->max_lines\n                   && (long)((float)(line_nb_of_word_a[current])\n                               / (last_line + 1) * (win->max_lines - 2)\n                             + 2)\n                        == lines_disp)\n            right_margin_putp(sbar_curs,\n                              \"#\",\n                              langinfo,\n                              term,\n                              win,\n                              lines_disp,\n                              win->offset);\n          else\n            right_margin_putp(sbar_line,\n                              \"|\",\n                              langinfo,\n                              term,\n                              win,\n                              lines_disp,\n                              win->offset);\n        }\n\n        /* Print a newline character if we are not at the end of */\n        /* the input nor at the end of the window.               */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (i < count - 1 && lines_disp < win->max_lines)\n        {\n          fputc_safe('\\n', stdout);\n\n          if (win->offset > 0)\n          {\n            long i;\n            for (i = 0; i < win->offset; i++)\n              fputc_safe(' ', stdout);\n          }\n\n          left_margin_putp(left_margin_symbol, term, win);\n        }\n\n        /* We do not increment the number of lines seen after */\n        /* a premature end of input.                          */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (i < count - 1)\n        {\n          lines_disp++;\n          first_start = -1;\n\n          /* Initialize the selectable column guard to its maximum position. */\n          /* for the next window line.                                       */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          shift_right_sym_pos_a[line_nb_of_word_a[win->start] + lines_disp\n                                - 1] = term->ncolumns;\n        }\n\n        if (win->max_lines == 1)\n          break;\n      }\n      else if (lines_disp == win->max_lines)\n      {\n        /* The last line of the window has been displayed. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (has_vbar && line_nb_of_word_a[i] == last_line)\n        {\n          if (!toggles->no_scrollbar)\n          {\n            if (win->max_lines > 1)\n              right_margin_putp(sbar_down,\n                                \"/\",\n                                langinfo,\n                                term,\n                                win,\n                                lines_disp,\n                                win->offset);\n            else\n              right_margin_putp(sbar_arr_up,\n                                \"^\",\n                                langinfo,\n                                term,\n                                win,\n                                lines_disp,\n                                win->offset);\n          }\n        }\n        else\n        {\n          if (has_vbar && !toggles->no_scrollbar)\n            right_margin_putp(sbar_arr_down,\n                              \"v\",\n                              langinfo,\n                              term,\n                              win,\n                              lines_disp,\n                              win->offset);\n          break;\n        }\n      }\n      else\n        /* These lines were not in the widows and so we have nothing to do. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        break;\n    }\n\n    /* Next word. */\n    /* \"\"\"\"\"\"\"\"\"\" */\n    i++;\n  }\n\n  /* Display the horizontal bar when needed. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win->col_mode || win->line_mode)\n  {\n    /* Save again the cursor position before drawing the horizontal bar. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    get_cursor_position(&row1, &col); /* col is not needed here. */\n\n    if (win->has_hbar)\n    {\n      int pos1; /* Pos. of the cursor's start in the horizontal scroll bar. */\n      int pos2; /* Pos. of the cursor's end in the horizontal scroll bar.   */\n\n      /* Note: in the following expression, rightmost_start is always   */\n      /* greater then leftmost_start as a line containing a single word */\n      /* cannot be truncated and have an horizontal scroll bar hence    */\n      /* win->has_hbar = 0.                                             */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      pos1 = (int)(word_a[current].start - leftmost_start)\n             / (float)(rightmost_end - leftmost_start) * (term->ncolumns - 4);\n      pos2 = (int)(word_a[current].end - leftmost_start)\n             / (float)(rightmost_end - leftmost_start) * (term->ncolumns - 4);\n\n      if (pos2 > term->ncolumns - 4)\n        pos2 = term->ncolumns\n               - 4; /* just to make sure but should not happen. */\n\n      fputs_safe(\"\\n\", stdout);\n      disp_hbar(win, term, langinfo, pos1, pos2);\n\n      /* Mark the fact that an horizontal scroll bar has been displayed */\n      /* and its space allocated.                                       */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (win->hbar_displayed == 0)\n        win->hbar_displayed = 1;\n    }\n    else if (win->hbar_displayed) /* The horizontal scroll bar has already *\n                                   | been displayed, keep this space empty *\n                                   | to not disturb the display.           */\n    {\n      fputs_safe(\"\\n\", stdout);\n      (void)tputs(TPARM1(clr_eol), 1, outch);\n    }\n\n    /* Save again the cursor position again (especially the row) to detect   */\n    /* an automatic scroll up when the cursor is at the bottom of the window */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    get_cursor_position(&row2, &col);\n  }\n\n  /* Update win->end, this is necessary because we only   */\n  /* call build_metadata on start and on terminal resize. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (i == count)\n    win->end = i - 1;\n  else\n    win->end = i;\n\n  /* We restore the cursor position saved before the display of the window. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  (void)tputs(TPARM1(restore_cursor), 1, outch);\n\n  /* Make sure the cursor is correctly moved when the horizontal scroll */\n  /* bar is displayed and the window is at the bottom of the screen.    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win->col_mode || win->line_mode)\n  {\n    if (win->has_hbar && row1 == row2) /* Screen scrolled up. */\n    {\n      (void)tputs(TPARM1(cursor_up), 1, outch);\n      term->curs_line--;\n    }\n  }\n\n  /* Re-enable the periodic timer. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\n  return lines_disp + (win->hbar_displayed ? 1 : 0);\n}\n\n/* ======================================================= */\n/* Signal handler.                                         */\n/* Manages SIGSEGV, SIGTERM, SIGHUP, SIGWINCH and SIGALRM. */\n/* ======================================================= */\nvoid\nsig_handler(int s)\n{\n  switch (s)\n  {\n    /* Standard termination signals. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case SIGPIPE:\n      got_sigpipe = 1;\n      break;\n\n    case SIGSEGV:\n      got_sigsegv = 1;\n      break;\n\n    case SIGTERM:\n      got_sigterm = 1;\n      break;\n\n    case SIGHUP:\n      got_sighup = 1;\n      break;\n\n    /* Terminal resize. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case SIGWINCH:\n      got_winch = 1;\n      break;\n\n    /* Alarm triggered, This signal is used by the search mechanism to     */\n    /* forces a window refresh.                                            */\n    /* The help mechanism uses it to clear the message                     */\n    /* It is also used to redisplay the window after the end of a terminal */\n    /* resizing.                                                           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    case SIGALRM:\n      if (timeout.initial_value > 0)\n        got_timeout_tick = 1;\n\n      if (forgotten_timer > 0)\n        forgotten_timer--;\n\n      if (forgotten_timer == 0)\n        got_forgotten_alrm = 1;\n\n      if (help_timer > 0)\n        help_timer--;\n\n      if (help_timer == 0 && help_mode)\n        got_help_alrm = 1;\n\n      if (daccess_timer > 0)\n        daccess_timer--;\n\n      if (daccess_timer == 0)\n        got_daccess_alrm = 1;\n\n      if (winch_timer > 0)\n        winch_timer--;\n\n      if (winch_timer == 0)\n      {\n        got_winch      = 0;\n        got_help_alrm  = 0;\n        got_winch_alrm = 1;\n      }\n\n      if (search_timer > 0)\n        search_timer--;\n\n      if (search_timer == 0 && search_mode != NONE)\n        got_search_alrm = 1;\n\n      break;\n  }\n}\n\n/* ========================================================= */\n/* Set new first column to display when horizontal scrolling */\n/* Alter win->first_column.                                  */\n/* ========================================================= */\nvoid\nset_new_first_column(win_t *win, term_t *term)\n{\n  long pos;\n\n  if (word_a[current].start < win->first_column)\n  {\n    pos = current;\n\n    while (win->first_column > 0 && word_a[current].start < win->first_column)\n    {\n      win->first_column = word_a[pos].start;\n      pos--;\n    }\n  }\n  else if (word_a[current].end - win->first_column >= term->ncolumns - 3)\n  {\n    pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n    while (!word_a[pos].is_last\n           && word_a[current].end - win->first_column >= term->ncolumns - 3)\n    {\n      pos++;\n      win->first_column = word_a[pos].start;\n    }\n  }\n}\n\n/* ===================================================== */\n/* Restrict the matches to word ending with the pattern. */\n/* ===================================================== */\nvoid\nselect_ending_matches(win_t         *win,\n                      term_t        *term,\n                      search_data_t *search_data,\n                      long          *last_line)\n{\n  if (BUF_LEN(matching_words_da) > 0)\n  {\n    long  i;\n    long  index;\n    long  nb;\n    long *tmp;\n    char *ptr;\n    char *last_glyph;\n    long  utf8_len;\n\n    /* Creation of an alternate array which will      */\n    /* contain only the candidates having potentially */\n    /* an ending pattern, if this array becomes non   */\n    /* empty then it will replace the original array. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    BUF_FREE(alt_matching_words_da);\n    BUF_FIT(alt_matching_words_da, BUF_LEN(matching_words_da));\n\n    for (i = 0; i < (long)BUF_LEN(matching_words_da); i++)\n    {\n      index     = matching_words_da[i];\n      char *str = word_a[index].str;\n\n      /* count the trailing blanks non counted in the bitmap. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr = str + strlen(str);\n\n      nb = 0;\n      while ((ptr = utf8_prev(str, ptr)) != NULL && isblank(*ptr))\n        if (ptr - str > 0)\n          nb++;\n        else\n          break;\n\n      if (ptr == NULL) /* str is blank or contain an invalid uft8 sequence. */\n        ptr = str;\n\n      /* NOTE: utf8_prev cannot return NULL in the previous loop */\n      /* because str always contains at least one UTF-8 valid    */\n      /* sequence, so does ptr.                                  */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n      /* Check the bit corresponding to the last non blank glyph  */\n      /* If set we add the index to an alternate array, if not we */\n      /* clear the bitmap of the corresponding word.              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (BIT_ISSET(word_a[index].bitmap,\n                    word_a[index].mb - nb - daccess.flength - 1))\n        BUF_PUSH(alt_matching_words_da, index);\n      else\n      {\n        /* Look if the end of the word potentially contain an */\n        /* ending pattern.                                    */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (search_mode == FUZZY)\n        {\n          utf8_len   = mblen(ptr, 4);\n          last_glyph = search_data->buf + search_data->len - utf8_len;\n\n          /* in fuzzy search mode we only look the last glyph. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (memcmp(ptr, last_glyph, utf8_len) == 0)\n            BUF_PUSH(alt_matching_words_da, index);\n          else\n            memset(word_a[index].bitmap,\n                   '\\0',\n                   (word_a[index].mb - daccess.flength) / CHAR_BIT + 1);\n        }\n        else\n        {\n          /* in not fuzzy search mode use all the pattern. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          for (nb = 0; nb < search_data->utf8_len - 1; nb++)\n            ptr = utf8_prev(str, ptr);\n          if (memcmp(ptr, search_data->buf, search_data->len) == 0)\n            BUF_PUSH(alt_matching_words_da, index);\n          else\n            memset(word_a[index].bitmap,\n                   '\\0',\n                   (word_a[index].mb - daccess.flength) / CHAR_BIT + 1);\n        }\n      }\n    }\n\n    /* Swap the normal and alt array. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    tmp                   = matching_words_da;\n    matching_words_da     = alt_matching_words_da;\n    alt_matching_words_da = tmp;\n\n    if (BUF_LEN(matching_words_da) > 0)\n    {\n      /* Adjust the bitmap to the ending version. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      update_bitmaps(search_mode, search_data, END_AFFINITY);\n\n      current = matching_words_da[0];\n\n      if (current < win->start || current > win->end)\n        *last_line = build_metadata(term, count, win);\n\n      /* Set new first column to display. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      set_new_first_column(win, term);\n    }\n  }\n}\n\n/* ======================================================= */\n/* Restrict the matches to word starting with the pattern. */\n/* ======================================================= */\nvoid\nselect_starting_matches(win_t         *win,\n                        term_t        *term,\n                        search_data_t *search_data,\n                        long          *last_line)\n{\n  if (BUF_LEN(matching_words_da) > 0)\n  {\n    long   i;\n    long   index;\n    size_t nb;\n    long  *tmp;\n    long   pos;\n    char  *first_glyph;\n    int    utf8_len;\n\n    BUF_FREE(alt_matching_words_da);\n    BUF_FIT(alt_matching_words_da, BUF_LEN(matching_words_da));\n\n    first_glyph = xmalloc(5);\n\n    for (i = 0; i < (long)BUF_LEN(matching_words_da); i++)\n    {\n      index = matching_words_da[i];\n\n      for (nb = 0; nb < word_a[index].mb; nb++)\n        if (!isblank(*(word_a[index].str + daccess.flength + nb)))\n          break;\n\n      if (BIT_ISSET(word_a[index].bitmap, nb))\n        BUF_PUSH(alt_matching_words_da, index);\n      else\n      {\n\n        if (search_mode == FUZZY)\n        {\n          first_glyph = utf8_strprefix(first_glyph,\n                                       word_a[index].str + nb + daccess.flength,\n                                       1,\n                                       &pos);\n          utf8_len    = pos;\n\n          /* in fuzzy search mode we only look the first glyph. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (memcmp(search_data->buf, first_glyph, utf8_len) == 0)\n            BUF_PUSH(alt_matching_words_da, index);\n          else\n            memset(word_a[index].bitmap,\n                   '\\0',\n                   (word_a[index].mb + nb - daccess.flength) / CHAR_BIT + 1);\n        }\n        else\n        {\n          /* in not fuzzy search mode use all the pattern. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (memcmp(search_data->buf,\n                     word_a[index].str + nb,\n                     search_data->len - nb)\n              == 0)\n            BUF_PUSH(alt_matching_words_da, index);\n          else\n            memset(word_a[index].bitmap,\n                   '\\0',\n                   (word_a[index].mb + nb - daccess.flength) / CHAR_BIT + 1);\n        }\n      }\n    }\n\n    free(first_glyph);\n\n    /* Swap the normal and alt array. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    tmp                   = matching_words_da;\n    matching_words_da     = alt_matching_words_da;\n    alt_matching_words_da = tmp;\n\n    if (BUF_LEN(matching_words_da) > 0)\n    {\n      /* Adjust the bitmap to the starting version. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      update_bitmaps(search_mode, search_data, START_AFFINITY);\n\n      current = matching_words_da[0];\n\n      if (current < win->start || current > win->end)\n        *last_line = build_metadata(term, count, win);\n\n      /* Set new first column to display. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      set_new_first_column(win, term);\n    }\n  }\n}\n\n/* ============================= */\n/* Moves the cursor to the left. */\n/* ============================= */\nvoid\nmove_left(win_t         *win,\n          term_t        *term,\n          toggle_t      *toggles,\n          search_data_t *search_data,\n          langinfo_t    *langinfo,\n          long          *nl,\n          long           last_line,\n          char          *tmp_word)\n{\n  long old_current      = current;\n  long old_start        = win->start;\n  long old_first_column = win->first_column;\n  long wi; /* Word index. */\n\n  do\n  {\n    if (current > 0)\n    {\n      /* Sets the new win->start and win->end if the cursor */\n      /* is at the beginning of the windows.                */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (current == win->start && win->start > 0)\n      {\n        for (wi = win->start - 1; wi >= 0 && word_a[wi].start != 0; wi--)\n        {\n        }\n        win->start = wi;\n\n        if (word_a[wi].str != NULL)\n          win->start = wi;\n\n        if (win->end < count - 1)\n        {\n          for (wi = win->end + 2; wi < count - 1 && word_a[wi].start != 0; wi++)\n          {\n          }\n          if (word_a[wi].str != NULL)\n            win->end = wi;\n        }\n      }\n\n      /* In column mode we need to take care of the */\n      /* horizontal scrolling.                      */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (win->col_mode || win->line_mode)\n      {\n        long pos;\n\n        if (word_a[current].start == 0)\n        {\n          long len;\n\n          len = term->ncolumns - 3;\n          pos = first_word_in_line_a[line_nb_of_word_a[current - 1]];\n\n          while (word_a[current - 1].end - win->first_column >= len)\n          {\n            win->first_column += word_a[pos].end - word_a[pos].start + 2;\n\n            pos++;\n          }\n        }\n        else if (word_a[current - 1].start < win->first_column)\n          win->first_column = word_a[current - 1].start;\n      }\n      current--;\n    }\n    else\n      break;\n  } while (current != old_current && !word_a[current].is_selectable);\n\n  /* The old settings need to be restored if the */\n  /* new current word is not selectable.         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!word_a[current].is_selectable)\n  {\n    current    = old_current;\n    win->start = old_start;\n    if (win->col_mode || win->line_mode)\n      win->first_column = old_first_column;\n  }\n\n  if (current != old_current)\n    *nl = disp_lines(win,\n                     toggles,\n                     current,\n                     count,\n                     search_mode,\n                     search_data,\n                     term,\n                     last_line,\n                     tmp_word,\n                     langinfo);\n}\n\n/* ============================================ */\n/* Shift the content of the window to the left. */\n/* Stop if the cursor will stop to be visible.  */\n/* ============================================ */\nvoid\nshift_left(win_t         *win,\n           term_t        *term,\n           toggle_t      *toggles,\n           search_data_t *search_data,\n           langinfo_t    *langinfo,\n           long          *nl,\n           long           last_line,\n           char          *tmp_word,\n           long           line)\n{\n  long pos;\n  long len;\n\n  /* No lines to shift if not in lire or column mode. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!win->col_mode && !win->line_mode)\n    return;\n\n  /* Do  nothing if we already are on the left side of if the line */\n  /* is already fully displayed.                                   */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win->first_column == 0)\n    return;\n\n  /* Find the first word to be displayed in this line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  pos = first_word_in_line_a[line];\n\n  while (pos < count - 1 && word_a[pos].start < win->first_column\n         && word_a[pos + 1].start > 0)\n    pos++;\n\n  if (word_a[pos].start >= win->first_column)\n    pos--;\n\n  /* Make sure the word under the cursor remains visible. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  len = term->ncolumns - 3;\n  if (word_a[current].end >= len + word_a[pos].start)\n    return;\n\n  win->first_column = word_a[pos].start;\n\n  *nl = disp_lines(win,\n                   toggles,\n                   current,\n                   count,\n                   search_mode,\n                   search_data,\n                   term,\n                   last_line,\n                   tmp_word,\n                   langinfo);\n}\n\n/* ============================== */\n/* Moves the cursor to the right. */\n/* ============================== */\nvoid\nmove_right(win_t         *win,\n           term_t        *term,\n           toggle_t      *toggles,\n           search_data_t *search_data,\n           langinfo_t    *langinfo,\n           long          *nl,\n           long           last_line,\n           char          *tmp_word)\n{\n  long old_current      = current;\n  long old_start        = win->start;\n  long old_first_column = win->first_column;\n  long wi; /* word index */\n\n  do\n  {\n    if (current < count - 1)\n    {\n      /* Sets the new win->start and win->end if the cursor */\n      /* is at the end of the windows.                      */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (current == win->end && win->start < count - 1\n          && win->end != count - 1)\n      {\n        for (wi = win->start + 1; wi < count - 1 && word_a[wi].start != 0; wi++)\n        {\n        }\n\n        if (word_a[wi].str != NULL)\n          win->start = wi;\n\n        if (win->end < count - 1)\n        {\n          for (wi = win->end + 2; wi < count - 1 && word_a[wi].start != 0; wi++)\n          {\n          }\n          if (word_a[wi].str != NULL)\n            win->end = wi;\n        }\n      }\n\n      /* In column mode we need to take care of the */\n      /* horizontal scrolling.                      */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (win->col_mode || win->line_mode)\n      {\n        if (word_a[current].is_last)\n          win->first_column = 0;\n        else\n        {\n          long pos;\n          long len;\n\n          len = term->ncolumns - 3;\n\n          if (word_a[current + 1].end >= len + win->first_column)\n          {\n            /* Find the first word to be displayed in this line. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n            while (word_a[pos].start <= win->first_column)\n              pos++;\n\n            pos--;\n\n            /* If the new current word cannot be displayed, search */\n            /* the first word in the line that can be displayed by */\n            /* iterating on pos.                                   */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            while (word_a[current + 1].end - word_a[pos].start >= len)\n              pos++;\n\n            if (word_a[pos].start > 0)\n              win->first_column = word_a[pos].start;\n          }\n        }\n      }\n      current++;\n    }\n    else\n      break;\n  } while (current != old_current && !word_a[current].is_selectable);\n\n  /* The old settings need to be restored if the */\n  /* new current word is not selectable.         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!word_a[current].is_selectable)\n  {\n    current    = old_current;\n    win->start = old_start;\n    if (win->col_mode || win->line_mode)\n      win->first_column = old_first_column;\n  }\n\n  if (current != old_current)\n    *nl = disp_lines(win,\n                     toggles,\n                     current,\n                     count,\n                     search_mode,\n                     search_data,\n                     term,\n                     last_line,\n                     tmp_word,\n                     langinfo);\n}\n\n/* =========================================== */\n/* Shift content of the window to the right.   */\n/* Stop if the cursor will stop to be visible. */\n/* ============================================*/\nvoid\nshift_right(win_t         *win,\n            term_t        *term,\n            toggle_t      *toggles,\n            search_data_t *search_data,\n            langinfo_t    *langinfo,\n            long          *nl,\n            long           last_line,\n            char          *tmp_word,\n            long           line)\n{\n  long pos;\n\n  /* No lines to shift if not in lire or column mode. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!win->col_mode && !win->line_mode)\n    return;\n\n  /* Do nothing if we already are on the right side and all or lines */\n  /* are already fully displayed.                                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (shift_right_sym_pos_a[line] == term->ncolumns)\n  {\n    int found = 0;\n\n    /* Search for at least one line not fully displayed. */\n    /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n    for (long l = line_nb_of_word_a[win->start];\n         l < line_nb_of_word_a[win->start] + win->max_lines;\n         l++)\n    {\n      if (shift_right_sym_pos_a[l] == term->ncolumns) /* fully displayed. */\n        continue;\n\n      found = 1; /* Use this line instead of line to calculate the shifting. */\n\n      break;\n    }\n\n    /* Do nothing if all lines are fully displayed. */\n    /* '''''''''''''''''''''''''''''''''''''''''''' */\n    if (!found)\n      return;\n  }\n\n  /* Find the first word to be displayed in this line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  pos = first_word_in_line_a[line];\n\n  while (pos < count - 1 && word_a[pos].start < win->first_column\n         && word_a[pos + 1].start > 0)\n    pos++;\n\n  if (pos < count - 1 && word_a[pos + 1].start > 0)\n    pos++;\n\n  /* Make sure the word under the cursor remains visible. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (word_a[pos].start <= word_a[current].start)\n    win->first_column = word_a[pos].start;\n  else\n    return;\n\n  *nl = disp_lines(win,\n                   toggles,\n                   current,\n                   count,\n                   search_mode,\n                   search_data,\n                   term,\n                   last_line,\n                   tmp_word,\n                   langinfo);\n}\n\n/* ================================================================== */\n/* Get the last word of a line after it has been formed to fit in the */\n/* terminal.                                                          */\n/* ================================================================== */\nlong\nget_line_last_word(long line, long last_line)\n{\n  if (line == last_line)\n    return count - 1;\n\n  return first_word_in_line_a[line + 1] - 1;\n}\n\n/* ==================================================================== */\n/* Try to locate the best word in the target line when trying to move   */\n/* the cursor upwards.                                                  */\n/* returns 1 if a word has been found else 0.                           */\n/* This function has the side effect to potentially change the value of */\n/* the variable 'current' if an adequate word is found.                 */\n/* ==================================================================== */\nint\nfind_best_word_upwards(long last_word, long s, long e)\n{\n  int  found = 0;\n  long index;\n  long cursor;\n\n  /* Look for the first word whose start position in the line is */\n  /* less or equal to the source word starting position.         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  cursor = last_word;\n  while (word_a[cursor].start > s)\n    cursor--;\n\n  /* In case no word is eligible, keep the cursor on */\n  /* the last word.                                  */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (cursor == last_word && word_a[cursor].start > 0)\n    cursor--;\n\n  /* Try to guess the best choice if we have multiple choices. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (word_a[cursor].end >= s\n      && word_a[cursor].end - s >= e - word_a[cursor + 1].start)\n    current = cursor;\n  else\n  {\n    if (cursor < last_word)\n      current = cursor + 1;\n    else\n      current = cursor;\n  }\n\n  /* If the word is not selectable, try to find a selectable word */\n  /* in its line.                                                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!word_a[current].is_selectable)\n  {\n    index = 0;\n    while (word_a[current - index].start > 0\n           && !word_a[current - index].is_selectable)\n      index++;\n\n    if (word_a[current - index].is_selectable)\n    {\n      current -= index;\n      found = 1;\n    }\n    else\n    {\n      index = 0;\n      while (current + index < last_word\n             && !word_a[current + index].is_selectable)\n        index++;\n\n      if (word_a[current + index].is_selectable)\n      {\n        current += index;\n        found = 1;\n      }\n    }\n  }\n  else\n    found = 1;\n\n  return found;\n}\n\n/* ==================================================================== */\n/* Try to locate the best word in the target line when trying to move   */\n/* the cursor downwards.                                                */\n/* returns 1 if a word has been found else 0.                           */\n/* This function has the side effect to potentially change the value of */\n/* the variable 'current' if an adequate word is found.                 */\n/* ==================================================================== */\nint\nfind_best_word_downwards(long last_word, long s, long e)\n{\n  int  found = 0;\n  long index;\n  long cursor;\n\n  /* Look for the first word whose start position in the line is */\n  /* less or equal than the source word starting position.       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  cursor = last_word;\n  while (word_a[cursor].start > s)\n    cursor--;\n\n  /* In case no word is eligible, keep the cursor on */\n  /* the last word.                                  */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (cursor == last_word && word_a[cursor].start > 0)\n    cursor--;\n\n  /* Try to guess the best choice if we have multiple choices. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (cursor < count - 1\n      && word_a[cursor].end - s >= e - word_a[cursor + 1].start)\n    current = cursor;\n  else\n  {\n    if (cursor < count - 1)\n    {\n      if (cursor < last_word)\n        current = cursor + 1;\n      else\n        current = cursor;\n    }\n    else\n      current = count - 1;\n  }\n\n  /* If the word is not selectable, try to find a selectable word */\n  /* in its line.                                                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!word_a[current].is_selectable)\n  {\n    index = 0;\n    while (word_a[current - index].start > 0\n           && !word_a[current - index].is_selectable)\n      index++;\n\n    if (word_a[current - index].is_selectable)\n    {\n      current -= index;\n      found = 1;\n    }\n    else\n    {\n      index = 0;\n      while (current + index < last_word\n             && !word_a[current + index].is_selectable)\n        index++;\n\n      if (word_a[current + index].is_selectable)\n      {\n        current += index;\n        found = 1;\n      }\n    }\n  }\n  else\n    found = 1;\n\n  return found;\n}\n\n/* ========================= */\n/* Moves the cursor upwards. */\n/* ========================= */\nvoid\nmove_up(win_t         *win,\n        term_t        *term,\n        toggle_t      *toggles,\n        search_data_t *search_data,\n        langinfo_t    *langinfo,\n        long          *nl,\n        long           page,\n        long           first_selectable,\n        long           last_line,\n        char          *tmp_word)\n{\n  long line;                  /* The line being processed (target line).    */\n  long start_line;            /* The first line of the window.              */\n  long cur_line;              /* The line of the cursor.                    */\n  long nlines;                /* Number of line in the window.              */\n  long first_selectable_line; /* the line containing the first              *\n                               | selectable word.                           */\n  long lines_skipped; /* The number of line between the target line and the *\n                       | first line containing a selectable word in case of *\n                       | exclusions.                                        */\n  long last_word;     /* The last word on the target line.                  */\n  long s, e;          /* Starting and ending terminal position of a word.   */\n  int  found;         /* 1 if a line could be fond else 0.                  */\n\n  /* Store the initial starting and ending positions of */\n  /* the word under the cursor.                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  s = word_a[current].start;\n  e = word_a[current].end;\n\n  /* Identify the line number of the first window's line */\n  /* and the line number of the current line.            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  start_line            = line_nb_of_word_a[win->start];\n  cur_line              = line_nb_of_word_a[current];\n  first_selectable_line = line_nb_of_word_a[first_selectable];\n  lines_skipped         = 0;\n  found                 = 0;\n  nlines = win->max_lines < last_line + 1 ? win->max_lines : last_line + 1;\n\n  /* initialise the target line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  line = cur_line;\n\n  /* Special case if the cursor is already in the line containing the */\n  /* first selectable word.                                           */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (line == first_selectable_line)\n  {\n    /* we can't move the cursor up but we still can try to show the */\n    /* more non selectable words as we can.                         */\n    /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    if (line <= start_line + nlines - 1 - page)\n    {\n      /* We are scrolling one line at a time and the cursor is not in */\n      /* the last line of the window.                                 */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      if (start_line - page > 0)\n        /* There is enough remaining line to fill a window. */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''' */\n        start_line -= page;\n      else\n        /* We cannot scroll further. */\n        /* ''''''''''''''''''''''''' */\n        start_line = 0;\n    }\n    else\n    {\n      /* The cursor is already in the last line of the windows. */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      if (line >= nlines)\n        /* There is enough remaining line to fill a window. */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''' */\n        start_line = line - nlines + 1;\n      else\n        /* We cannot scroll further. */\n        /* ''''''''''''''''''''''''' */\n        start_line = 0;\n    }\n  }\n  else\n  {\n    if (line - page < 0)\n    {\n      /* Trivial case, we are already on the first page */\n      /* just jump to the first selectable line.        */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      line      = first_selectable_line;\n      last_word = get_line_last_word(line, last_line);\n      find_best_word_upwards(last_word, s, e);\n    }\n    else\n    {\n      /* Temporarily move up one page. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      line -= page;\n\n      /* The target line cannot be before the line containing the first */\n      /* selectable word.                                               */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (line < first_selectable_line)\n      {\n        line      = first_selectable_line;\n        last_word = get_line_last_word(line, last_line);\n        find_best_word_upwards(last_word, s, e);\n      }\n      else\n      {\n        /* If this is not the case, search upwards for the line with a */\n        /* selectable word. This line is guaranteed to exist.          */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        while (line >= first_selectable_line)\n        {\n          last_word = get_line_last_word(line, last_line);\n\n          if (find_best_word_upwards(last_word, s, e))\n          {\n            found = 1;\n            break;\n          }\n\n          line--;\n          lines_skipped++;\n        }\n      }\n    }\n  }\n\n  /* Look if we need to adjust the window to follow the cursor. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!found && start_line - page >= 0)\n  {\n    /* We are on the first line containing a selectable word and  */\n    /* There is enough place to scroll up a page but only scrolls */\n    /* up if the cursor remains in the window.                    */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (start_line + nlines - line > page)\n      start_line -= page;\n  }\n  else if (line < start_line)\n  {\n    /* The target line is above the windows. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (start_line - page - lines_skipped < 0)\n      /* There isn't enough remaining lines to scroll up */\n      /* a page size.                                    */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      start_line = 0;\n    else\n      start_line -= page + lines_skipped;\n  }\n\n  /* And set the new value of the starting word of the window. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  win->start = first_word_in_line_a[start_line];\n\n  /* Set the new first column to display */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  set_new_first_column(win, term);\n\n  /* Redisplay the window. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *nl = disp_lines(win,\n                   toggles,\n                   current,\n                   count,\n                   search_mode,\n                   search_data,\n                   term,\n                   last_line,\n                   tmp_word,\n                   langinfo);\n}\n\n/* =========================== */\n/* Moves the cursor downwards. */\n/* =========================== */\nvoid\nmove_down(win_t         *win,\n          term_t        *term,\n          toggle_t      *toggles,\n          search_data_t *search_data,\n          langinfo_t    *langinfo,\n          long          *nl,\n          long           page,\n          long           last_selectable,\n          long           last_line,\n          char          *tmp_word)\n{\n  long line;                 /* The line being processed (target line).     */\n  long start_line;           /* The first line of the window.               */\n  long cur_line;             /* The line of the cursor.                     */\n  long nlines;               /* Number of line in the window.               */\n  long last_selectable_line; /* the line containing the last                *\n                              | selectable word.                            */\n  long lines_skipped; /* The number of line between the target line and the *\n                       | first line containing a selectable word in case of *\n                       | exclusions.                                        */\n  long last_word;     /* The last word on the target line.                  */\n  long s, e;          /* Starting and ending terminal position of a word.   */\n  int  found;         /* 1 if a line could be fond in the next page else 0. */\n\n  /* Store the initial starting and ending positions of */\n  /* the word under the cursor.                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  s = word_a[current].start;\n  e = word_a[current].end;\n\n  /* Identify the line number of the first window's line */\n  /* and the line number of the current line.            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  start_line           = line_nb_of_word_a[win->start];\n  cur_line             = line_nb_of_word_a[current];\n  last_selectable_line = line_nb_of_word_a[last_selectable];\n  lines_skipped        = 0;\n  found                = 0;\n  nlines = win->max_lines < last_line + 1 ? win->max_lines : last_line + 1;\n\n  /* initialise the target line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  line = cur_line;\n\n  /* Special case if the cursor is already in the line containing the */\n  /* last selectable word.                                            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (line == last_selectable_line)\n  {\n    /* we can't move the cursor down but we still can try to show the */\n    /* more non selectable words as we can.                           */\n    /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    if (line >= start_line + page)\n    {\n      /* We are scrolling one line at a time and the cursor is not in */\n      /* the first line of the window.                                */\n      /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      if (start_line + page + nlines - 1 <= last_line)\n        /* There is enough remaining line to fill a window. */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''' */\n        start_line += page;\n      else\n        /* We cannot scroll further. */\n        /* ''''''''''''''''''''''''' */\n        start_line = last_line - nlines + 1;\n    }\n    else\n    {\n      /* The cursor is already in the first line of the windows. */\n      /* ''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n      if (last_line - line + 1 > nlines)\n        /* There is enough remaining line to fill a window. */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''' */\n        start_line = line;\n      else\n        /* We cannot scroll further. */\n        /* ''''''''''''''''''''''''' */\n        start_line = last_line - nlines + 1;\n    }\n  }\n  else\n  {\n    /* The cursor is above the line containing the last selectable word. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (last_line - line - page < 0)\n    {\n      /* Trivial case, we are already on the last page */\n      /* just jump to the last selectable line.        */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      line      = last_selectable_line;\n      last_word = get_line_last_word(line, last_line);\n      find_best_word_downwards(last_word, s, e);\n    }\n    else\n    {\n      /* Temporarily move down one page. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      line += page;\n\n      /* The target line cannot be after the line containing the last */\n      /* selectable word.                                             */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (line > last_selectable_line)\n      {\n        line      = last_selectable_line;\n        last_word = get_line_last_word(line, last_line);\n        find_best_word_downwards(last_word, s, e);\n      }\n      else\n      {\n        /* If this is not the case, search downwards for the line with a */\n        /* selectable word. This line is guaranteed to exist.            */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        while (line <= last_selectable_line)\n        {\n          last_word = get_line_last_word(line, last_line);\n\n          if (find_best_word_downwards(last_word, s, e))\n          {\n            found = 1;\n            break;\n          }\n\n          line++;\n          lines_skipped++;\n        }\n      }\n    }\n\n    /* Look if we need to adjust the window to follow the cursor. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!found && start_line + nlines - 1 + page <= last_line)\n    {\n      /* We are on the last line containing a selectable word and     */\n      /* There is enough place to scroll down a page but only scrolls */\n      /* down if the cursor remains in the window.                    */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (line - start_line >= page)\n        start_line += page;\n    }\n    else if (line > start_line + nlines - 1)\n    {\n      /* The target line is below the windows. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (start_line + nlines + page + lines_skipped - 1 > last_line)\n        /* There isn't enough remaining lines to scroll down */\n        /* a page size.                                      */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        start_line = last_line - nlines + 1;\n      else\n        start_line += page + lines_skipped;\n    }\n  }\n\n  /* And set the new value of the starting word of the window. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  win->start = first_word_in_line_a[start_line];\n\n  /* Set the new first column to display. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  set_new_first_column(win, term);\n\n  /* Redisplay the window. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *nl = disp_lines(win,\n                   toggles,\n                   current,\n                   count,\n                   search_mode,\n                   search_data,\n                   term,\n                   last_line,\n                   tmp_word,\n                   langinfo);\n}\n\n/* ========================================= */\n/* Initialize some internal data structures. */\n/* ========================================= */\nvoid\ninit_main_ds(attrib_t  *init_attr,\n             win_t     *win,\n             limit_t   *limits,\n             ticker_t  *timers,\n             toggle_t  *toggles,\n             misc_t    *misc,\n             mouse_t   *mouse,\n             timeout_t *timeout,\n             daccess_t *daccess)\n{\n  int i;\n\n  /* Initial attribute settings. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  init_attr->is_set    = UNSET;\n  init_attr->fg        = -1;\n  init_attr->bg        = -1;\n  init_attr->bold      = (signed char)-1;\n  init_attr->dim       = (signed char)-1;\n  init_attr->reverse   = (signed char)-1;\n  init_attr->standout  = (signed char)-1;\n  init_attr->underline = (signed char)-1;\n  init_attr->italic    = (signed char)-1;\n  init_attr->invis     = (signed char)-1;\n  init_attr->blink     = (signed char)-1;\n\n  /* Win fields initialization. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  win->max_lines       = 5;\n  win->message_lines   = 0;\n  win->asked_max_lines = -1;\n  win->center          = 0;\n  win->max_cols        = 0;\n  win->col_sep         = 0;\n  win->wide            = 0;\n  win->tab_mode        = 0;\n  win->col_mode        = 0;\n  win->line_mode       = 0;\n  win->first_column    = 0;\n  win->real_max_width  = 0;\n  win->sb_column       = -1;\n  win->hbar_displayed  = 0;\n\n  win->cursor_attr               = *init_attr;\n  win->cursor_marked_attr        = *init_attr;\n  win->cursor_on_marked_attr     = *init_attr;\n  win->cursor_on_tag_attr        = *init_attr;\n  win->cursor_on_tag_marked_attr = *init_attr;\n  win->marked_attr               = *init_attr;\n  win->bar_attr                  = *init_attr;\n  win->shift_attr                = *init_attr;\n  win->message_attr              = *init_attr;\n  win->search_field_attr         = *init_attr;\n  win->search_text_attr          = *init_attr;\n  win->search_err_field_attr     = *init_attr;\n  win->search_err_text_attr      = *init_attr;\n  win->match_field_attr          = *init_attr;\n  win->match_text_attr           = *init_attr;\n  win->match_err_field_attr      = *init_attr;\n  win->match_err_text_attr       = *init_attr;\n  win->include_attr              = *init_attr;\n  win->exclude_attr              = *init_attr;\n  win->tag_attr                  = *init_attr;\n  win->daccess_attr              = *init_attr;\n\n  win->next_tag_id = 1; /* No word is currently tagged. */\n  win->sel_sep     = NULL;\n\n  for (i = 0; i < 9; i++)\n    win->special_attr[i] = *init_attr;\n\n  /* Default limits initialization. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  limits->words       = 32767;\n  limits->cols        = 256;\n  limits->word_length = 512;\n\n  /* Default timers in 1/10 s. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  timers->search        = 100 * FREQ / 10;\n  timers->forgotten     = -1; /*  Disabled by default. */\n  timers->help          = 300 * FREQ / 10;\n  timers->winch         = 20 * FREQ / 10;\n  timers->direct_access = 6 * FREQ / 10;\n\n  /* Toggles initialization. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  toggles->del_line            = 0;\n  toggles->enter_val_in_search = 0;\n  toggles->no_scrollbar        = 0;\n  toggles->no_hor_scrollbar    = 0;\n  toggles->hor_scrollbar       = 0;\n  toggles->blank_nonprintable  = 0;\n  toggles->keep_spaces         = 0;\n  toggles->taggable            = 0;\n  toggles->autotag             = 0;\n  toggles->noautotag           = 0;\n  toggles->pinable             = 0;\n  toggles->visual_bell         = 0;\n  toggles->incremental_search  = 0;\n  toggles->no_mouse            = 0;\n  toggles->show_blank_words    = 0;\n  toggles->cols_first          = 0;\n  toggles->rows_first          = 0;\n\n  /* Misc default values. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  misc->default_search_method   = NONE;\n  misc->ignore_quotes           = 0;\n  misc->invalid_char_substitute = '.';\n  misc->blank_char_substitute   = '_';\n\n  /* Mouse values. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n  mouse->button[0] = 1;\n  mouse->button[1] = 2;\n  mouse->button[2] = 3;\n\n  mouse->double_click_delay = 150;\n\n  /* Set the default timeout to 0 (no expiration). */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  timeout->initial_value = 0;\n  timeout->remain        = 0;\n  timeout->reached       = 0;\n\n  /* Initialize Direct Access settings. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  daccess->mode       = DA_TYPE_NONE;\n  daccess->left       = xstrdup(\" \");\n  daccess->right      = xstrdup(\")\");\n  daccess->alignment  = 'r';\n  daccess->padding    = 'a';\n  daccess->head       = 'k'; /* Keep by default. */\n  daccess->length     = -2;\n  daccess->flength    = 0;\n  daccess->offset     = 0;\n  daccess->plus       = 0;\n  daccess->size       = 0;\n  daccess->ignore     = 0;\n  daccess->follow     = 'y';\n  daccess->missing    = 'y';\n  daccess->num_sep    = NULL;\n  daccess->def_number = -1;\n}\n\n/* *********************************** */\n/* ctxopt contexts callback functions. */\n/* *********************************** */\n\n/* ******************************** */\n/* ctxopt option callback function. */\n/* ******************************** */\n\nvoid\nhelp_action(char  *ctx_name,\n            char  *opt_name,\n            char  *param,\n            int    nb_values,\n            char **values,\n            int    nb_opt_data,\n            void **opt_data,\n            int    nb_ctx_data,\n            void **ctx_data)\n{\n  if (strcmp(ctx_name, \"Columns\") == 0)\n    columns_help();\n  else if (strcmp(ctx_name, \"Lines\") == 0)\n    lines_help();\n  else if (strcmp(ctx_name, \"Tabulations\") == 0)\n    tabulations_help();\n  else if (strcmp(ctx_name, \"Tagging\") == 0)\n    tagging_help();\n  else\n    main_help();\n\n  exit(EXIT_FAILURE);\n}\n\nvoid\nlong_help_action(char  *ctx_name,\n                 char  *opt_name,\n                 char  *param,\n                 int    nb_values,\n                 char **values,\n                 int    nb_opt_data,\n                 void **opt_data,\n                 int    nb_ctx_data,\n                 void **ctx_data)\n{\n  ctxopt_disp_usage(continue_after);\n\n  printf(\"\\nRead the manual for more information.\\n\");\n\n  exit(EXIT_FAILURE);\n}\n\nvoid\nusage_action(char  *ctx_name,\n             char  *opt_name,\n             char  *param,\n             int    nb_values,\n             char **values,\n             int    nb_opt_data,\n             void **opt_data,\n             int    nb_ctx_data,\n             void **ctx_data)\n{\n  ctxopt_ctx_disp_usage(ctx_name, exit_after);\n}\n\nvoid\nlines_action(char  *ctx_name,\n             char  *opt_name,\n             char  *param,\n             int    nb_values,\n             char **values,\n             int    nb_opt_data,\n             void **opt_data,\n             int    nb_ctx_data,\n             void **ctx_data)\n{\n  win_t *win = opt_data[0];\n\n  if (nb_values == 1)\n    /* No need to validate if values are numeric here, they have      */\n    /* already been validated by the check_integer_constraint filter. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    sscanf(values[0], \"%d\", &(win->asked_max_lines));\n  else\n    win->asked_max_lines = 0;\n}\n\nvoid\ntab_mode_action(char  *ctx_name,\n                char  *opt_name,\n                char  *param,\n                int    nb_values,\n                char **values,\n                int    nb_opt_data,\n                void **opt_data,\n                int    nb_ctx_data,\n                void **ctx_data)\n{\n  win_t *win = opt_data[0];\n\n  long max_cols;\n\n  if (nb_values == 1)\n  {\n    /* No need to validate if values are numeric or out of range here,  */\n    /* they have already been validated by the check_integer_constraint */\n    /* and ctxopt_range_constraint filters.                             */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    sscanf(values[0], \"%ld\", &max_cols);\n    win->max_cols = max_cols;\n  }\n\n  win->tab_mode  = 1;\n  win->col_mode  = 0;\n  win->line_mode = 0;\n}\n\nvoid\nset_pattern_action(char  *ctx_name,\n                   char  *opt_name,\n                   char  *param,\n                   int    nb_values,\n                   char **values,\n                   int    nb_opt_data,\n                   void **opt_data,\n                   int    nb_ctx_data,\n                   void **ctx_data)\n{\n  char  **pattern = opt_data[0];\n  misc_t *misc    = opt_data[1];\n\n  *pattern = xstrdup(values[0]);\n  utf8_interpret(*pattern, misc->invalid_char_substitute);\n}\n\nvoid\nint_action(char  *ctx_name,\n           char  *opt_name,\n           char  *param,\n           int    nb_values,\n           char **values,\n           int    nb_opt_data,\n           void **opt_data,\n           int    nb_ctx_data,\n           void **ctx_data)\n{\n  char      **string     = opt_data[0];\n  int        *shell_like = opt_data[1];\n  langinfo_t *langinfo   = opt_data[2];\n  misc_t     *misc       = opt_data[3];\n\n  if (nb_values == 1)\n  {\n    *string = xstrdup(values[0]);\n    if (!langinfo->utf8)\n      utf8_sanitize(*string, misc->invalid_char_substitute);\n    utf8_interpret(*string, misc->invalid_char_substitute);\n  }\n\n  *shell_like = 0;\n}\n\nvoid\nset_string_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  char      **string   = opt_data[0];\n  langinfo_t *langinfo = opt_data[1];\n  misc_t     *misc     = opt_data[2];\n\n  *string = xstrdup(values[0]);\n  if (!langinfo->utf8)\n    utf8_sanitize(*string, misc->invalid_char_substitute);\n  utf8_interpret(*string, misc->invalid_char_substitute);\n}\n\nvoid\nwide_mode_action(char  *ctx_name,\n                 char  *opt_name,\n                 char  *param,\n                 int    nb_values,\n                 char **values,\n                 int    nb_opt_data,\n                 void **opt_data,\n                 int    nb_ctx_data,\n                 void **ctx_data)\n{\n  win_t *win = opt_data[0];\n\n  win->wide = 1;\n}\n\nvoid\ncenter_mode_action(char  *ctx_name,\n                   char  *opt_name,\n                   char  *param,\n                   int    nb_values,\n                   char **values,\n                   int    nb_opt_data,\n                   void **opt_data,\n                   int    nb_ctx_data,\n                   void **ctx_data)\n{\n  win_t *win = opt_data[0];\n\n  win->center = 1;\n}\n\nvoid\ncolumns_select_action(char  *ctx_name,\n                      char  *opt_name,\n                      char  *param,\n                      int    nb_values,\n                      char **values,\n                      int    nb_opt_data,\n                      void **opt_data,\n                      int    nb_ctx_data,\n                      void **ctx_data)\n{\n  int       v;\n  ll_t    **cols_selector_list = opt_data[0];\n  toggle_t *toggles            = opt_data[1];\n\n  if (*cols_selector_list == NULL)\n    *cols_selector_list = ll_new();\n\n  if (toggles->cols_first == 0 && toggles->rows_first == 0)\n    toggles->cols_first = 1;\n\n  for (v = 0; v < nb_values; v++)\n    ll_append(*cols_selector_list, xstrdup(values[v]));\n}\n\nvoid\nrows_select_action(char  *ctx_name,\n                   char  *opt_name,\n                   char  *param,\n                   int    nb_values,\n                   char **values,\n                   int    nb_opt_data,\n                   void **opt_data,\n                   int    nb_ctx_data,\n                   void **ctx_data)\n{\n  int       v;\n  ll_t    **rows_selector_list = opt_data[0];\n  win_t    *win                = opt_data[1];\n  toggle_t *toggles            = opt_data[2];\n\n  if (*rows_selector_list == NULL)\n    *rows_selector_list = ll_new();\n\n  if (toggles->cols_first == 0 && toggles->rows_first == 0)\n    toggles->rows_first = 1;\n\n  for (v = 0; v < nb_values; v++)\n    ll_append(*rows_selector_list, xstrdup(values[v]));\n\n  win->max_cols = 0; /* Disable the window column restriction. */\n}\n\nvoid\naligns_select_action(char  *ctx_name,\n                     char  *opt_name,\n                     char  *param,\n                     int    nb_values,\n                     char **values,\n                     int    nb_opt_data,\n                     void **opt_data,\n                     int    nb_ctx_data,\n                     void **ctx_data)\n{\n  int    v;\n  ll_t **aligns_selector_list = opt_data[0];\n\n  if (*aligns_selector_list == NULL)\n    *aligns_selector_list = ll_new();\n\n  for (v = 0; v < nb_values; v++)\n    ll_append(*aligns_selector_list, xstrdup(values[v]));\n}\n\nvoid\ntoggle_action(char  *ctx_name,\n              char  *opt_name,\n              char  *param,\n              int    nb_values,\n              char **values,\n              int    nb_opt_data,\n              void **opt_data,\n              int    nb_ctx_data,\n              void **ctx_data)\n{\n  toggle_t *toggles = opt_data[0];\n\n  if (strcmp(opt_name, \"clean\") == 0)\n    toggles->del_line = 1;\n  else if (strcmp(opt_name, \"keep_spaces\") == 0)\n    toggles->keep_spaces = 1;\n  else if (strcmp(opt_name, \"visual_bell\") == 0)\n    toggles->visual_bell = 1;\n  else if (strcmp(opt_name, \"validate_in_search_mode\") == 0)\n    toggles->enter_val_in_search = 1;\n  else if (strcmp(opt_name, \"blank_nonprintable\") == 0)\n    toggles->blank_nonprintable = 1;\n  else if (strcmp(opt_name, \"no_scroll_bar\") == 0)\n  {\n    toggles->no_scrollbar     = 1;\n    toggles->no_hor_scrollbar = 1;\n    toggles->hor_scrollbar    = 0;\n  }\n  else if (strcmp(opt_name, \"no_hor_scroll_bar\") == 0)\n  {\n    if (!toggles->no_scrollbar)\n    {\n      toggles->no_hor_scrollbar = 1;\n      toggles->hor_scrollbar    = 0;\n    }\n  }\n  else if (strcmp(opt_name, \"hor_scroll_bar\") == 0)\n  {\n    if (!toggles->no_scrollbar && !toggles->no_hor_scrollbar)\n      toggles->hor_scrollbar = 1;\n  }\n  else if (strcmp(opt_name, \"auto_tag\") == 0)\n    toggles->autotag = 1;\n  else if (strcmp(opt_name, \"no_auto_tag\") == 0)\n    toggles->noautotag = 1;\n  else if (strcmp(opt_name, \"incremental_search\") == 0)\n    toggles->incremental_search = 1;\n  else if (strcmp(opt_name, \"no_mouse\") == 0)\n    toggles->no_mouse = 1;\n}\n\nvoid\ninvalid_char_action(char  *ctx_name,\n                    char  *opt_name,\n                    char  *param,\n                    int    nb_values,\n                    char **values,\n                    int    nb_opt_data,\n                    void **opt_data,\n                    int    nb_ctx_data,\n                    void **ctx_data)\n{\n  misc_t *misc = opt_data[0];\n\n  char ic = *values[0];\n\n  if (isprint(ic))\n    misc->invalid_char_substitute = ic;\n  else\n    misc->invalid_char_substitute = '.';\n}\n\nvoid\nshow_blank_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  toggle_t *toggles = opt_data[0];\n  misc_t   *misc    = opt_data[1];\n\n  unsigned char bc;\n\n  toggles->show_blank_words = 1;\n\n  if (nb_values == 1)\n  {\n    bc = (unsigned char)*values[0];\n\n    if (isprint(bc))\n      misc->blank_char_substitute = bc;\n    else\n      misc->blank_char_substitute = '_';\n  }\n}\n\nvoid\ngutter_action(char  *ctx_name,\n              char  *opt_name,\n              char  *param,\n              int    nb_values,\n              char **values,\n              int    nb_opt_data,\n              void **opt_data,\n              int    nb_ctx_data,\n              void **ctx_data)\n{\n  win_t      *win      = opt_data[0];\n  langinfo_t *langinfo = opt_data[1];\n  misc_t     *misc     = opt_data[2];\n\n  if (nb_values == 0)\n  {\n    /* As there is no argument, the gutter array will only contain */\n    /* a vertical bar.                                             */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    win->gutter_a = xmalloc(1 * sizeof(char *));\n\n    if (langinfo->utf8)\n      win->gutter_a[0] = xstrdup(vertical_bar);\n    else\n      win->gutter_a[0] = xstrdup(\"|\");\n\n    win->gutter_nb = 1;\n  }\n  else\n  {\n    /* The argument is used to feed the gutter array, each of its character */\n    /* Will serve as gutter in a round-robin way.                           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    long     n;\n    wchar_t *w;\n    long     i, offset;\n    char    *gutter;\n\n    gutter = xstrdup(values[0]);\n\n    utf8_interpret(gutter,\n                   misc->invalid_char_substitute); /* Guarantees a well    *\n                                                    | formed UTF-8 string. */\n\n    win->gutter_nb = utf8_strlen(gutter);\n    win->gutter_a  = xmalloc(win->gutter_nb * sizeof(char *));\n\n    offset = 0;\n\n    for (i = 0; i < win->gutter_nb; i++)\n    {\n      int mblength;\n\n      mblength         = utf8_get_length(*(gutter + offset));\n      win->gutter_a[i] = xcalloc(1, mblength + 1);\n      memcpy(win->gutter_a[i], gutter + offset, mblength);\n\n      n = my_wcswidth((w = utf8_strtowcs(win->gutter_a[i])), 1);\n      free(w);\n\n      if (n > 1)\n      {\n        fprintf(stderr, \"%s: A multi columns gutter is not allowed.\\n\", param);\n        ctxopt_ctx_disp_usage(ctx_name, exit_after);\n      }\n      offset += mblength;\n    }\n    free(gutter);\n  }\n  win->col_sep = 1; /* Activate the gutter. */\n}\n\nvoid\ncolumn_mode_action(char  *ctx_name,\n                   char  *opt_name,\n                   char  *param,\n                   int    nb_values,\n                   char **values,\n                   int    nb_opt_data,\n                   void **opt_data,\n                   int    nb_ctx_data,\n                   void **ctx_data)\n{\n  win_t *win = opt_data[0];\n\n  win->tab_mode  = 0;\n  win->col_mode  = 1;\n  win->line_mode = 0;\n  win->max_cols  = 0;\n}\n\nvoid\nline_mode_action(char  *ctx_name,\n                 char  *opt_name,\n                 char  *param,\n                 int    nb_values,\n                 char **values,\n                 int    nb_opt_data,\n                 void **opt_data,\n                 int    nb_ctx_data,\n                 void **ctx_data)\n{\n  win_t *win = opt_data[0];\n\n  win->line_mode = 1;\n  win->tab_mode  = 0;\n  win->col_mode  = 0;\n  win->max_cols  = 0;\n}\n\nvoid\ninclude_re_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  int    *pattern_def_include = opt_data[0];\n  char  **include_pattern     = opt_data[1];\n  misc_t *misc                = opt_data[2];\n\n  /* Set the default behaviour if not already set. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*pattern_def_include == -1)\n    *pattern_def_include = 0;\n\n  if (*include_pattern == NULL)\n    *include_pattern = concat(\"(\", values[0], \")\", (char *)0);\n  else\n    *include_pattern = concat(*include_pattern,\n                              \"|(\",\n                              values[0],\n                              \")\",\n                              (char *)0);\n\n  /* Replace the UTF-8 ASCII representations by their binary values in */\n  /* inclusion patterns.                                               */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  utf8_interpret(*include_pattern, misc->invalid_char_substitute);\n}\n\nvoid\nexclude_re_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  int    *pattern_def_include = opt_data[0];\n  char  **exclude_pattern     = opt_data[1];\n  misc_t *misc                = opt_data[2];\n\n  /* Set the default behaviour if not already set. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (*pattern_def_include == -1)\n    *pattern_def_include = 1;\n\n  if (*exclude_pattern == NULL)\n    *exclude_pattern = concat(\"(\", values[0], \")\", (char *)0);\n  else\n    *exclude_pattern = concat(*exclude_pattern,\n                              \"|(\",\n                              values[0],\n                              \")\",\n                              (char *)0);\n\n  /* Replace the UTF-8 ASCII representations by their binary values in */\n  /* exclusion patterns.                                               */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  utf8_interpret(*exclude_pattern, misc->invalid_char_substitute);\n}\n\nvoid\npost_subst_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  ll_t  **list = opt_data[0];\n  misc_t *misc = opt_data[1];\n\n  int i;\n\n  if (*list == NULL)\n    *list = ll_new();\n\n  for (i = 0; i < nb_values; i++)\n  {\n    sed_t *sed_node;\n\n    sed_node          = xmalloc(sizeof(sed_t));\n    sed_node->pattern = xstrdup(values[i]);\n    utf8_interpret(sed_node->pattern, misc->invalid_char_substitute);\n    sed_node->stop = 0;\n    ll_append(*list, sed_node);\n  }\n}\n\nvoid\nspecial_level_action(char  *ctx_name,\n                     char  *opt_name,\n                     char  *param,\n                     int    nb_values,\n                     char **values,\n                     int    nb_opt_data,\n                     void **opt_data,\n                     int    nb_ctx_data,\n                     void **ctx_data)\n{\n  char    **special_pattern = opt_data[0];\n  win_t    *win             = opt_data[1];\n  term_t   *term            = opt_data[2];\n  attrib_t *init_attr       = opt_data[3];\n  misc_t   *misc            = opt_data[4];\n\n  attrib_t attr = *init_attr;\n  char     opt  = param[strlen(param) - 1]; /* last character of param. */\n  int      i;\n\n  special_pattern[opt - '1'] = xstrdup(values[0]);\n  utf8_interpret(special_pattern[opt - '1'], misc->invalid_char_substitute);\n\n  /* Parse optional additional arguments. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (i = 1; i < nb_values; i++)\n  {\n    /* Colors must respect the format: <fg color>/<bg color>. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (parse_attr(values[i], &attr, term->colors))\n    {\n      win->special_attr[opt - '1'].is_set    = FORCED;\n      win->special_attr[opt - '1'].fg        = attr.fg;\n      win->special_attr[opt - '1'].bg        = attr.bg;\n      win->special_attr[opt - '1'].bold      = attr.bold;\n      win->special_attr[opt - '1'].dim       = attr.dim;\n      win->special_attr[opt - '1'].reverse   = attr.reverse;\n      win->special_attr[opt - '1'].standout  = attr.standout;\n      win->special_attr[opt - '1'].underline = attr.underline;\n      win->special_attr[opt - '1'].italic    = attr.italic;\n      win->special_attr[opt - '1'].invis     = attr.invis;\n      win->special_attr[opt - '1'].blink     = attr.blink;\n    }\n  }\n}\n\nvoid\nattributes_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  win_t    *win       = opt_data[0];\n  term_t   *term      = opt_data[1];\n  attrib_t *init_attr = opt_data[2];\n\n  long i, a;       /* loop index.                               */\n  long offset = 0; /* nb of chars to ship to find the attribute *\n                    | representation (prefix size).             */\n\n  attrib_t  attr;\n  attrib_t *attr_to_set = NULL;\n\n  /* Flags to check if an attribute is already set */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  int inc_attr_set           = 0; /* included words.                       */\n  int exc_attr_set           = 0; /* excluded words.                       */\n  int cur_attr_set           = 0; /* highlighted word (cursor).            */\n  int bar_attr_set           = 0; /* scroll bar.                           */\n  int shift_attr_set         = 0; /* horizontal scrolling arrows.          */\n  int message_attr_set       = 0; /* message (title).                      */\n  int tag_attr_set           = 0; /* selected (tagged) words.              */\n  int cursor_on_tag_attr_set = 0; /* selected words under the cursor.      */\n  int sf_attr_set            = 0; /* currently searched field color.       */\n  int st_attr_set            = 0; /* currently searched text color.        */\n  int mf_attr_set            = 0; /* matching word field color.            */\n  int mt_attr_set            = 0; /* matching word text color.             */\n  int mfe_attr_set           = 0; /* matching word with error field color. */\n  int mte_attr_set           = 0; /* matching word with error text color.  */\n  int daccess_attr_set       = 0; /* Direct access text color.             */\n\n  /* Information relatives to the attributes to be searched and set. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  struct\n  {\n    attrib_t *attr;\n    char     *msg;\n    int      *flag;\n    char     *prefix;\n    int       prefix_len;\n  } attr_infos[] = {\n    { &win->exclude_attr,\n      \"The exclude attribute is already set.\",\n      &exc_attr_set,\n      \"e:\",\n      2 },\n    { &win->include_attr,\n      \"The include attribute is already set.\",\n      &inc_attr_set,\n      \"i:\",\n      2 },\n    { &win->cursor_attr,\n      \"The cursor attribute is already set.\",\n      &cur_attr_set,\n      \"c:\",\n      2 },\n    { &win->bar_attr,\n      \"The scroll bar attribute is already set.\",\n      &bar_attr_set,\n      \"b:\",\n      2 },\n    { &win->shift_attr,\n      \"The shift attribute is already set.\",\n      &shift_attr_set,\n      \"s:\",\n      2 },\n    { &win->message_attr,\n      \"The message attribute is already set.\",\n      &message_attr_set,\n      \"m:\",\n      2 },\n    { &win->tag_attr,\n      \"The tag attribute is already set.\",\n      &tag_attr_set,\n      \"t:\",\n      2 },\n    { &win->cursor_on_tag_attr,\n      \"The cursor on tagged word attribute is already set.\",\n      &cursor_on_tag_attr_set,\n      \"ct:\",\n      3 },\n    { &win->search_field_attr,\n      \"The search field attribute is already set.\",\n      &sf_attr_set,\n      \"sf:\",\n      3 },\n    { &win->search_text_attr,\n      \"The search text attribute is already set.\",\n      &st_attr_set,\n      \"st:\",\n      3 },\n    { &win->search_err_field_attr,\n      \"The search with error field attribute is already set.\",\n      &sf_attr_set,\n      \"sfe:\",\n      4 },\n    { &win->search_err_text_attr,\n      \"The search text with error attribute is already set.\",\n      &st_attr_set,\n      \"ste:\",\n      4 },\n    { &win->match_field_attr,\n      \"The matching word field attribute is already set.\",\n      &mf_attr_set,\n      \"mf:\",\n      3 },\n    { &win->match_text_attr,\n      \"The matching word text attribute is already set.\",\n      &mt_attr_set,\n      \"mt:\",\n      3 },\n    { &win->match_err_field_attr,\n      \"The matching word with error field attribute is already set.\",\n      &mfe_attr_set,\n      \"mfe:\",\n      4 },\n    { &win->match_err_text_attr,\n      \"The matching word with error text attribute is already set.\",\n      &mte_attr_set,\n      \"mte:\",\n      4 },\n    { &win->daccess_attr,\n      \"The direct access tag attribute is already set.\",\n      &daccess_attr_set,\n      \"da:\",\n      3 },\n    { NULL, NULL, NULL, NULL, 0 }\n  };\n\n  /* Parse the arguments.                                               */\n  /* The syntax of the attributes has already been pre validated by the */\n  /* ctxopt_re_constraint filter.                                       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (a = 0; a < nb_values; a++)\n  {\n    attr = *init_attr;\n\n    i = 0;\n    while (attr_infos[i].flag != NULL)\n    {\n      if (strncmp(values[a], attr_infos[i].prefix, attr_infos[i].prefix_len)\n          == 0)\n      {\n        if (*attr_infos[i].flag)\n        {\n          fprintf(stderr, \"%s: \", param);\n          fputs_safe(attr_infos[i].msg, stderr);\n          fputs_safe(\"\\n\", stderr);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n\n        attr_to_set         = attr_infos[i].attr;\n        *attr_infos[i].flag = 1;\n        offset              = attr_infos[i].prefix_len;\n        break; /* We have found a matching prefix, *\n                | no need to continue.             */\n      }\n      i++;\n    }\n    if (attr_infos[i].flag == NULL)\n    {\n      fprintf(stderr, \"%s: Bad attribute prefix in %s\\n\", param, values[a]);\n      ctxopt_ctx_disp_usage(ctx_name, exit_after);\n    }\n\n    /* Attributes must respect the format: */\n    /* <fg color>/<bg color>,<styles>.     */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (parse_attr(values[a] + offset, &attr, term->colors))\n    {\n      attr_to_set->is_set    = FORCED;\n      attr_to_set->fg        = attr.fg;\n      attr_to_set->bg        = attr.bg;\n      attr_to_set->bold      = attr.bold;\n      attr_to_set->dim       = attr.dim;\n      attr_to_set->reverse   = attr.reverse;\n      attr_to_set->standout  = attr.standout;\n      attr_to_set->underline = attr.underline;\n      attr_to_set->italic    = attr.italic;\n      attr_to_set->invis     = attr.invis;\n      attr_to_set->blink     = attr.blink;\n    }\n    else\n    {\n      fprintf(stderr, \"%s: Bad attribute settings %s\\n\", param, values[a]);\n      ctxopt_ctx_disp_usage(ctx_name, exit_after);\n    }\n  }\n}\n\nvoid\nlimits_action(char  *ctx_name,\n              char  *opt_name,\n              char  *param,\n              int    nb_values,\n              char **values,\n              int    nb_opt_data,\n              void **opt_data,\n              int    nb_ctx_data,\n              void **ctx_data)\n{\n  limit_t *limits = opt_data[0];\n\n  long l;\n  long val;\n\n  char *lim;\n  char *endptr;\n  char *p;\n\n  /* Parse the arguments. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (l = 0; l < nb_values; l++)\n  {\n    errno = 0;\n    lim   = values[l];\n    p     = lim + 2;\n\n    switch (*lim)\n    {\n      case 'l': /* word length. */\n        val = strtol(p, &endptr, 0);\n        if (errno == ERANGE || (val == 0 && errno != 0) || endptr == p\n            || *endptr != '\\0')\n        {\n          fprintf(stderr, \"%s: Invalid word length limit. \", p);\n          fprintf(stderr,\n                  \"Using the default value: %ld\\n\",\n                  limits->word_length);\n        }\n        else\n          limits->word_length = val;\n        break;\n\n      case 'w': /* max number of words. */\n        val = strtol(p, &endptr, 0);\n        if (errno == ERANGE || (val == 0 && errno != 0) || endptr == p\n            || *endptr != '\\0')\n        {\n          fprintf(stderr, \"%s: Invalid words number limit. \", p);\n          fprintf(stderr, \"Using the default value: %ld\\n\", limits->words);\n        }\n        else\n          limits->words = val;\n        break;\n\n      case 'c': /* max number of words. */\n        val = strtol(p, &endptr, 0);\n        if (errno == ERANGE || (val == 0 && errno != 0) || endptr == p\n            || *endptr != '\\0')\n        {\n          fprintf(stderr, \"%s: Invalid columns number limit. \", p);\n          fprintf(stderr, \"Using the default value: %ld\\n\", limits->cols);\n        }\n        else\n          limits->cols = val;\n        break;\n\n      default:\n        fprintf(stderr, \"%s: Invalid limit keyword, should be l, w or c.\\n\", p);\n        break;\n    }\n  }\n}\n\nvoid\ncopyright_action(char  *ctx_name,\n                 char  *opt_name,\n                 char  *param,\n                 int    nb_values,\n                 char **values,\n                 int    nb_opt_data,\n                 void **opt_data,\n                 int    nb_ctx_data,\n                 void **ctx_data)\n{\n  fputs_safe(\"Copyright 2015 - Pierre Gentile <p.gen.progs@gmail.com> - \"\n             \"MPL-2.0\\n\",\n             stdout);\n\n  exit(EXIT_SUCCESS);\n}\n\nvoid\nversion_action(char  *ctx_name,\n               char  *opt_name,\n               char  *param,\n               int    nb_values,\n               char **values,\n               int    nb_opt_data,\n               void **opt_data,\n               int    nb_ctx_data,\n               void **ctx_data)\n{\n  fputs_safe(\"Version: \" VERSION \"\\n\", stdout);\n\n  exit(EXIT_SUCCESS);\n}\n\nvoid\ntimeout_action(char  *ctx_name,\n               char  *opt_name,\n               char  *param,\n               int    nb_values,\n               char **values,\n               int    nb_opt_data,\n               void **opt_data,\n               int    nb_ctx_data,\n               void **ctx_data)\n{\n  misc_t *misc = opt_data[0];\n\n  if (strcmp(opt_name, \"hidden_timeout\") == 0)\n    quiet_timeout = 1;\n\n  if (strprefix(\"current\", values[0]))\n    timeout.mode = CURRENT;\n  else if (strprefix(\"quit\", values[0]))\n    timeout.mode = QUIT;\n  else if (strprefix(\"word\", values[0]))\n  {\n    if (nb_values == 3)\n    {\n      timeout.mode = WORD;\n      timeout_word = xstrdup(values[1]);\n      utf8_interpret(timeout_word, misc->invalid_char_substitute);\n    }\n    else\n    {\n      fprintf(stderr, \"%s: Missing timeout selected word or delay.\\n\", param);\n      ctxopt_ctx_disp_usage(ctx_name, exit_after);\n    }\n  }\n\n  if (sscanf(values[nb_values - 1], \"%5u\", &timeout.initial_value) == 1)\n  {\n    timeout.initial_value *= FREQ;\n    timeout.remain = timeout.initial_value;\n  }\n  else\n  {\n    fprintf(stderr, \"%s: Invalid timeout delay.\\n\", param);\n    ctxopt_ctx_disp_usage(ctx_name, exit_after);\n  }\n}\n\nvoid\ntag_mode_action(char  *ctx_name,\n                char  *opt_name,\n                char  *param,\n                int    nb_values,\n                char **values,\n                int    nb_opt_data,\n                void **opt_data,\n                int    nb_ctx_data,\n                void **ctx_data)\n{\n  toggle_t *toggles = opt_data[0];\n  win_t    *win     = opt_data[1];\n  misc_t   *misc    = opt_data[2];\n\n  toggles->taggable = 1;\n\n  if (nb_values == 1)\n  {\n    win->sel_sep = xstrdup(values[0]);\n    utf8_interpret(win->sel_sep, misc->invalid_char_substitute);\n  }\n}\n\nvoid\npin_mode_action(char  *ctx_name,\n                char  *opt_name,\n                char  *param,\n                int    nb_values,\n                char **values,\n                int    nb_opt_data,\n                void **opt_data,\n                int    nb_ctx_data,\n                void **ctx_data)\n{\n  toggle_t *toggles = opt_data[0];\n  win_t    *win     = opt_data[1];\n  misc_t   *misc    = opt_data[2];\n\n  toggles->taggable = 1;\n  toggles->pinable  = 1;\n\n  if (nb_values == 1)\n  {\n    win->sel_sep = xstrdup(values[0]);\n    utf8_interpret(win->sel_sep, misc->invalid_char_substitute);\n  }\n}\n\nvoid\nsearch_method_action(char  *ctx_name,\n                     char  *opt_name,\n                     char  *param,\n                     int    nb_values,\n                     char **values,\n                     int    nb_opt_data,\n                     void **opt_data,\n                     int    nb_ctx_data,\n                     void **ctx_data)\n{\n  misc_t *misc = opt_data[0];\n\n  if (strprefix(\"prefix\", values[0]))\n    misc->default_search_method = PREFIX;\n  else if (strprefix(\"fuzzy\", values[0]))\n    misc->default_search_method = FUZZY;\n  else if (strprefix(\"substring\", values[0]))\n    misc->default_search_method = SUBSTRING;\n  else\n  {\n    fprintf(stderr, \"%s: Bad search method: %s\\n\", param, values[0]);\n    ctxopt_ctx_disp_usage(ctx_name, exit_after);\n  }\n}\n\nvoid\nauto_da_action(char  *ctx_name,\n               char  *opt_name,\n               char  *param,\n               int    nb_values,\n               char **values,\n               int    nb_opt_data,\n               void **opt_data,\n               int    nb_ctx_data,\n               void **ctx_data)\n{\n  char **daccess_pattern = opt_data[0];\n  int    i;\n\n  if (nb_values == 0)\n  {\n    if (daccess.missing == 'y' || ((daccess.mode & DA_TYPE_POS) == 0))\n    {\n      if (*daccess_pattern == NULL)\n      {\n        *daccess_pattern = xstrdup(\"(.)\");\n        daccess.mode |= DA_TYPE_AUTO; /* Auto. */\n      }\n      else\n        *daccess_pattern = concat(*daccess_pattern, \"|(.)\", (char *)0);\n    }\n  }\n  else\n    for (i = 0; i < nb_values; i++)\n    {\n      char *value;\n\n      if (*values[i] == '\\0'\n          && (daccess.missing == 'y' || ((daccess.mode & DA_TYPE_POS) == 0)))\n        value = \".\";\n      else\n        value = values[i];\n\n      if (*daccess_pattern == NULL)\n      {\n        *daccess_pattern = concat(\"(\", value, \")\", (char *)0);\n        daccess.mode |= DA_TYPE_AUTO; /* Auto. */\n      }\n      else\n        *daccess_pattern = concat(*daccess_pattern,\n                                  \"|(\",\n                                  value,\n                                  \")\",\n                                  (char *)0);\n    }\n\n  if (daccess.def_number < 0)\n  {\n    if (strcmp(param, \"-N\") == 0)\n      daccess.def_number = 0; /* Words are unnumbered by default. */\n    else\n      daccess.def_number = 1; /* Words are numbered by default.   */\n  }\n}\n\nvoid\nfield_da_number_action(char  *ctx_name,\n                       char  *opt_name,\n                       char  *param,\n                       int    nb_values,\n                       char **values,\n                       int    nb_opt_data,\n                       void **opt_data,\n                       int    nb_ctx_data,\n                       void **ctx_data)\n{\n  daccess.mode |= DA_TYPE_POS;\n}\n\nvoid\nda_options_action(char  *ctx_name,\n                  char  *opt_name,\n                  char  *param,\n                  int    nb_values,\n                  char **values,\n                  int    nb_opt_data,\n                  void **opt_data,\n                  int    nb_ctx_data,\n                  void **ctx_data)\n{\n  long   *daccess_index = opt_data[0];\n  misc_t *misc          = opt_data[1];\n\n  int      pos;\n  wchar_t *w;\n  int      n;\n  int      i;\n\n  /* Parse optional additional arguments.                              */\n  /* The syntax of the arguments has already been pre validated by the */\n  /* ctxopt_re_constraint filter.                                      */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (i = 0; i < nb_values; i++)\n  {\n    char *value = values[i];\n\n    switch (*value)\n    {\n      case 'l': /* Left char .*/\n        free(daccess.left);\n\n        daccess.left = xstrdup(value + 2);\n        utf8_interpret(daccess.left, misc->invalid_char_substitute);\n\n        if (utf8_strlen(daccess.left) != 1)\n        {\n          fprintf(stderr, \"%s: Too many characters after l:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n\n        n = my_wcswidth((w = utf8_strtowcs(daccess.left)), 1);\n        free(w);\n\n        if (n > 1)\n        {\n          fprintf(stderr,\n                  \"%s: A multi columns character is not allowed \"\n                  \"after l:\\n\",\n                  param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'r': /* Right char. */\n        free(daccess.right);\n\n        daccess.right = xstrdup(value + 2);\n        utf8_interpret(daccess.right, misc->invalid_char_substitute);\n\n        if (utf8_strlen(daccess.right) != 1)\n        {\n          fprintf(stderr, \"%s: Too many characters after r:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n\n        n = my_wcswidth((w = utf8_strtowcs(daccess.right)), 1);\n        free(w);\n\n        if (n > 1)\n        {\n          fprintf(stderr,\n                  \"%s: A multi columns character is not allowed \"\n                  \"after r:\\n\",\n                  param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'a': /* Alignment. */\n        if (strprefix(\"left\", value + 2))\n          daccess.alignment = 'l';\n        else if (strprefix(\"right\", value + 2))\n          daccess.alignment = 'r';\n        else\n        {\n          fprintf(stderr,\n                  \"%s: The value after a: must be \"\n                  \"l(eft) or r(ight)\\n\",\n                  param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'p': /* Padding. */\n        if (strprefix(\"all\", value + 2))\n          daccess.padding = 'a';\n        else if (strprefix(\"included\", value + 2))\n          daccess.padding = 'i';\n        else\n        {\n          fprintf(stderr, \"%s: Bad value after p:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'w': /* Width. */\n        if (sscanf(value + 2, \"%d%n\", &daccess.length, &pos) != 1)\n        {\n          fprintf(stderr, \"%s: Bad value after w:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        if (value[pos + 2] != '\\0')\n        {\n          fprintf(stderr, \"%s: Bad value after w:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        if (daccess.length <= 0 || daccess.length > 5)\n        {\n          fprintf(stderr, \"%s: w sub-option must be between 1 and 5\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'o': /* Start offset. */\n        if (sscanf(value + 2, \"%zu%n+\", &daccess.offset, &pos) == 1)\n        {\n          if (value[pos + 2] == '+')\n          {\n            daccess.plus = 1;\n\n            if (value[pos + 3] != '\\0')\n            {\n              fprintf(stderr, \"%s: Bad value after o:\\n\", param);\n              ctxopt_ctx_disp_usage(ctx_name, exit_after);\n            }\n          }\n          else if (value[pos + 2] != '\\0')\n          {\n            fprintf(stderr, \"%s: Bad value after o:\\n\", param);\n            ctxopt_ctx_disp_usage(ctx_name, exit_after);\n          }\n        }\n        else\n        {\n          fprintf(stderr, \"%s: Bad value after o:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n\n        break;\n\n      case 'n': /* Number of digits to extract. */\n        if (sscanf(value + 2, \"%d%n\", &daccess.size, &pos) != 1)\n        {\n          fprintf(stderr, \"%s: Bad value after n:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        if (value[pos + 2] != '\\0')\n        {\n          fprintf(stderr, \"%s: Bad value after n:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        if (daccess.size <= 0 || daccess.size > 5)\n        {\n          fprintf(stderr, \"n sub-option must have a value between 1 and 5.\\n\");\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'i': /* Number of UTF-8 glyphs to ignore after the *\n                 | selector to extract.                       */\n        if (sscanf(value + 2, \"%zu%n\", &daccess.ignore, &pos) != 1)\n        {\n          fprintf(stderr, \"%s: Bad value after i:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        if (value[pos + 2] != '\\0')\n        {\n          fprintf(stderr, \"%s: Bad value after i:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'f': /* Follow. */\n        if (strprefix(\"yes\", value + 2))\n          daccess.follow = 'y';\n        else if (strprefix(\"no\", value + 2))\n          daccess.follow = 'n';\n        else\n        {\n          fprintf(stderr, \"%s: Bad value after f:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'm': /* Possibly number missing embedded numbers. */\n        if (strprefix(\"yes\", value + 2))\n          daccess.missing = 'y';\n        else if (strprefix(\"no\", value + 2))\n          daccess.missing = 'n';\n        else\n        {\n          fprintf(stderr, \"%s: Bad value after m:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 'd': /* Decorate. */\n        free(daccess.num_sep);\n\n        daccess.num_sep = xstrdup(value + 2);\n        utf8_interpret(daccess.num_sep, misc->invalid_char_substitute);\n\n        if (utf8_strlen(daccess.num_sep) != 1)\n        {\n          fprintf(stderr, \"%s: Too many characters after d:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n\n        n = my_wcswidth((w = utf8_strtowcs(daccess.num_sep)), 1);\n        free(w);\n\n        if (n > 1)\n        {\n          fprintf(stderr,\n                  \"%s: A multi columns separator is not allowed \"\n                  \"after d:\\n\",\n                  param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      case 's': /* Start index. */\n      {\n        long index;\n\n        if (sscanf(value + 2, \"%ld%ln\", daccess_index, &index) == 1)\n        {\n          if (*daccess_index < 0 || *(value + 2 + index) != '\\0')\n            *daccess_index = 1;\n        }\n        else\n        {\n          fprintf(stderr, \"%s: Invalid first index after s:\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n      }\n      break;\n\n      case 'h': /* Head. */\n        if (strprefix(\"trim\", value + 2))\n          daccess.head = 't';\n        else if (strprefix(\"cut\", value + 2))\n          daccess.head = 'c';\n        else if (strprefix(\"keep\", value + 2))\n          daccess.head = 'k';\n        else\n        {\n          fprintf(stderr, \"%s: Bad value after :h\\n\", param);\n          ctxopt_ctx_disp_usage(ctx_name, exit_after);\n        }\n        break;\n\n      default:\n      {\n        fprintf(stderr, \"%s: Bad sub-command: %s\\n\", param, value);\n        ctxopt_ctx_disp_usage(ctx_name, exit_after);\n      }\n    }\n\n    if (daccess.length <= 0 || daccess.length > 5)\n      daccess.length = -2; /* special value -> auto. */\n  }\n}\n\nvoid\nignore_quotes_action(char  *ctx_name,\n                     char  *opt_name,\n                     char  *param,\n                     int    nb_values,\n                     char **values,\n                     int    nb_opt_data,\n                     void **opt_data,\n                     int    nb_ctx_data,\n                     void **ctx_data)\n{\n  misc_t *misc = opt_data[0];\n\n  misc->ignore_quotes = 1;\n}\n\nvoid\nforgotten_action(char  *ctx_name,\n                 char  *opt_name,\n                 char  *param,\n                 int    nb_values,\n                 char **values,\n                 int    nb_opt_data,\n                 void **opt_data,\n                 int    nb_ctx_data,\n                 void **ctx_data)\n{\n  ticker_t *timers = opt_data[0];\n\n  long   val;\n  char  *endptr;\n  char  *p;\n  size_t l = strlen(values[0]);\n\n  /* Add a 0 at the end of the parameter to multiply it by 10 */\n  /* as the timer values must be in tenths of seconds.        */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  p    = xmalloc(l + 2);\n  p    = strcpy(p, values[0]);\n  p[l] = '0';\n\n  errno = 0;\n  val   = strtol(p, &endptr, 0);\n  if (errno == ERANGE || (val == 0 && errno != 0) || endptr == p\n      || *endptr != '\\0')\n  {\n    fprintf(stderr, \"%s: Invalid timeout delay.\\n\", values[0]);\n    ctxopt_ctx_disp_usage(ctx_name, exit_after);\n  }\n  else if (val == 0)\n    timers->forgotten = -1; /* Explicitly disable the timers. */\n  else\n    timers->forgotten = (int)val;\n\n  free(p);\n}\n\nvoid\nbutton_action(char  *ctx_name,\n              char  *opt_name,\n              char  *param,\n              int    nb_values,\n              char **values,\n              int    nb_opt_data,\n              void **opt_data,\n              int    nb_ctx_data,\n              void **ctx_data)\n{\n  mouse_t *mouse = opt_data[0];\n\n  char *endptr;\n  char *p;\n  long  val;\n\n  if (nb_values != 2)\n  {\n    fprintf(stderr, \"Remapping of buttons 1 and 3 expected.\\n\");\n    ctxopt_ctx_disp_usage(ctx_name, exit_after);\n  }\n\n  int const index[2] = { 0, 2 };\n  int       ind;\n\n  mouse->button[0] = 0;\n  mouse->button[1] = 0;\n  mouse->button[2] = 0;\n\n  for (int i = 0; i < nb_values; i++)\n  {\n    ind   = index[i];\n    errno = 0;\n    p     = values[i];\n    val   = strtol(p, &endptr, 0);\n    if (errno == ERANGE || endptr == p || *endptr != '\\0' || val < 1 || val > 3)\n    {\n      fprintf(stderr, \"%s: Invalid button number.\\n\", values[0]);\n      ctxopt_ctx_disp_usage(ctx_name, exit_after);\n    }\n    mouse->button[(int)val - 1] = ind + 1;\n  }\n}\n\nvoid\ndouble_click_action(char  *ctx_name,\n                    char  *opt_name,\n                    char  *param,\n                    int    nb_values,\n                    char **values,\n                    int    nb_opt_data,\n                    void **opt_data,\n                    int    nb_ctx_data,\n                    void **ctx_data)\n{\n  mouse_t *mouse = opt_data[0];\n  int     *ddc   = opt_data[1];\n\n  char *endptr;\n  char *p = values[0];\n  long  val;\n\n  errno = 0;\n  val   = strtol(p, &endptr, 0);\n  if (errno == ERANGE || endptr == p || *endptr != '\\0')\n    return; /* default value (150 ~ 1/6.66th second) is set in main(). */\n  if (val == 0)\n    *ddc = 1; /* disable double_click; */\n  else if (val >= 100 && val <= 500)\n    mouse->double_click_delay = val;\n}\n\n/* =================================================================== */\n/* Cancels a search. Called when ESC is hit or a new search session is */\n/* initiated and the incremental_search option is not used.            */\n/* =================================================================== */\nvoid\nreset_search_buffer(win_t         *win,\n                    search_data_t *search_data,\n                    ticker_t      *timers,\n                    toggle_t      *toggles,\n                    term_t        *term,\n                    daccess_t     *daccess,\n                    langinfo_t    *langinfo,\n                    long           last_line,\n                    char          *tmp_word,\n                    long           word_real_max_size)\n{\n  /* ESC key has been pressed. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  search_mode_t saved_search_mode = search_mode;\n\n  /* Cancel the search timer. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  search_timer = 0;\n\n  search_data->err           = 0;\n  search_data->only_starting = 0;\n  search_data->only_ending   = 0;\n\n  if (help_mode)\n    disp_lines(win,\n               toggles,\n               current,\n               count,\n               search_mode,\n               search_data,\n               term,\n               last_line,\n               tmp_word,\n               langinfo);\n\n  /* Reset the direct access selector stack. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  memset(daccess_stack, '\\0', 6);\n  daccess_stack_head = 0;\n  daccess_timer      = timers->direct_access;\n\n  /* Clean the potential matching words non empty list. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  search_mode = NONE;\n\n  if (BUF_LEN(matching_words_da) > 0 || saved_search_mode != search_mode)\n  {\n    clean_matches(search_data, word_real_max_size);\n\n    disp_lines(win,\n               toggles,\n               current,\n               count,\n               search_mode,\n               search_data,\n               term,\n               last_line,\n               tmp_word,\n               langinfo);\n  }\n}\n\n/* ===================================================================== */\n/* Get the new index of a word based on the mouse click position.        */\n/* Returns a new index if a word could be selected or the original index */\n/* The error flag is set if the word was not selectable or if the user   */\n/* did not click on a word.                                              */\n/* ===================================================================== */\nlong\nget_clicked_index(win_t  *win,\n                  term_t *term,\n                  int     line_click,\n                  int     column_click,\n                  int    *error)\n{\n  long new_current;  /* Future new current word on success.              */\n  long clicked_line; /* Number of the clicked line in smenu internal     *\n                      | representation on the screen.                    */\n  int  delta;        /* Compensation due to the alignment of the first   *\n                      | visible word of the selected line in the window. */\n\n  /* Make sure the error indicator is initialized. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *error = 0;\n\n  /* Get the internal line number of the click. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  clicked_line = line_nb_of_word_a[win->start] + line_click - term->curs_line;\n\n  /* Ignore clicks after the last word on a line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (column_click >= shift_right_sym_pos_a[clicked_line])\n    return current;\n\n  new_current = first_word_in_line_a[clicked_line];\n\n  if (new_current == count - 1)\n    return new_current; /* The users clicked on the last word; */\n  else\n  {\n    int offset; /* in column or line mode lines can be larger than the *\n                 | terminal size, in this case a space is added at the *\n                 | start of the lines to possibly put the  shift arrow *\n                 | indicator, this space must be taken into account.   */\n    int found;  /* Flag to indicate if a word could have been clicked. */\n\n    /* Take into account the presence of shift arrows if any. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (win->has_truncated_lines)\n      offset = 1;\n    else\n      offset = 0;\n\n    /* Compensates for the offset of the window in the case of a centred */\n    /* window and the additional space added by the display of truncated */\n    /* lines.                                                            */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    column_click -= win->offset;\n\n    /* Forbid click on column 1 if the windows has truncated lines. */\n    /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    if (column_click == 1 && offset == 1)\n      return current;\n\n    /* Normalize column_click. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    column_click -= offset;\n\n    /* Determine the offset of the first character of the */\n    /* first visible word in the clicked line.            */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while (word_a[new_current].start < win->first_column)\n    {\n      new_current++;\n\n      if (new_current == count || word_a[new_current].start == 0)\n        return current;\n    }\n\n    delta = word_a[new_current].start - win->first_column;\n\n    /* Find the right clicked word if any. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    found = 0;\n\n    while (1)\n    {\n      if ((column_click - 1\n           >= word_a[new_current].start - win->first_column - delta)\n          && (column_click - 1\n              <= word_a[new_current].end - win->first_column - delta))\n      {\n        found = 1;\n        break;\n      }\n\n      new_current++;\n\n      if (new_current == count || word_a[new_current].start == 0)\n        break;\n    }\n\n    if (!found)\n    {\n      *error      = 1;\n      new_current = current;\n    }\n  }\n\n  if (!word_a[new_current].is_selectable)\n  {\n    *error = 1;\n    return current;\n  }\n\n  return new_current;\n}\n\n/* ==================================================================== */\n/* Get the number of the clicked shift arrow if any.                    */\n/* arrow will contain 0 if the left arrow as clicked and 1 if the right */\n/* arrow was clicked.                                                   */\n/* Returns 0 is no arrow was clicked else 1.                            */\n/* ==================================================================== */\nint\nshift_arrow_clicked(win_t  *win,\n                    term_t *term,\n                    int     line_click,\n                    int     column_click,\n                    long   *clicked_line,\n                    int    *arrow)\n{\n  *arrow = -1;\n\n  /* Get the internal line number of the click. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *clicked_line = line_nb_of_word_a[win->start] + line_click - term->curs_line;\n\n  if (column_click > shift_right_sym_pos_a[*clicked_line])\n    return 0;\n\n  /* Compensates for the offset of the window */\n  /* in the case of a centred window.         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (column_click == 1)\n    *arrow = 0; /* Left arrow. */\n  else if (shift_right_sym_pos_a[*clicked_line] < term->ncolumns\n           && column_click == shift_right_sym_pos_a[*clicked_line])\n    *arrow = 1; /* Right arrow. */\n  else\n    return 0;\n\n  return 1;\n}\n\n/* ============================================================== */\n/* Takes a string with leading and/or trailing spaces and try to  */\n/* left-align, right-align or center them by re-arranging blanks. */\n/* word      IN/OUT string to work with.                          */\n/* alignment IN     kind of alignments.                           */\n/* ============================================================== */\nvoid\nalign_word(word_t *word, alignment_t alignment, size_t prefix, char sp)\n{\n  switch (alignment)\n  {\n    char  *str;\n    size_t n;\n    size_t m;\n    size_t wl;\n    size_t l;\n\n    case AL_LEFT:\n      /* Left align the word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      str = xstrdup(word->str + prefix);\n      n   = 0;\n\n      while (str[n] == sp)\n        n++;\n\n      swap_string_parts(&str, n);\n\n      strcpy(word->str + prefix, str);\n      free(str);\n\n      break;\n\n    case AL_RIGHT:\n      /* Right align the word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      str = xstrdup(word->str + prefix);\n      n   = strlen(str) - 1;\n\n      while (n && str[n] == sp)\n        n--;\n\n      swap_string_parts(&str, n + 1);\n\n      strcpy(word->str + prefix, str);\n      free(str);\n\n      break;\n\n    case AL_CENTERED:\n      /* Center the word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      str = xstrdup(word->str + prefix);\n      n   = 0;\n      l   = strlen(str);\n      m   = l - 1;\n\n      while (str[n] == sp)\n        n++;\n\n      while (m && str[m] == sp)\n        m--;\n\n      if (n > m)\n      {\n        free(str);\n        break;\n      }\n\n      wl = m - n + 1;\n      memset(word->str + prefix, sp, l);\n\n      strncpy(word->str + prefix + (l - wl) / 2, str + n, wl);\n      free(str);\n\n      break;\n\n    default:\n      break;\n  }\n}\n\n/* ================= */\n/* Main entry point. */\n/* ================= */\nint\nmain(int argc, char *argv[])\n{\n  /* Mapping of supported charsets and the number of bits used in them. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  charsetinfo_t all_supported_charsets[] = {\n    { \"UTF-8\", 8 },\n\n    { \"ANSI_X3.4-1968\", 7 },\n    { \"ANSI_X3.4-1986\", 7 },\n    { \"646\", 7 },\n    { \"ASCII\", 7 },\n    { \"CP367\", 7 },\n    { \"IBM367\", 7 },\n    { \"ISO_646.BASIC\", 7 },\n    { \"ISO_646.IRV:1991\", 7 },\n    { \"ISO_646.IRV\", 7 },\n    { \"ISO646-US\", 7 },\n    { \"ISO-IR-6\", 7 },\n    { \"US\", 7 },\n    { \"US-ASCII\", 7 },\n\n    { \"hp-roman8\", 8 },\n    { \"roman8\", 8 },\n    { \"r8\", 8 },\n\n    { \"ISO8859-1\", 8 },\n    { \"ISO-8859-1\", 8 },\n    { \"ISO-IR-100\", 8 },\n    { \"ISO_8859-1:1987\", 8 },\n    { \"ISO_8859-1\", 8 },\n    { \"LATIN1\", 8 },\n    { \"L1\", 8 },\n    { \"IBM819\", 8 },\n    { \"CP819\", 8 },\n\n    { \"ISO8859-2\", 8 },\n    { \"ISO-8859-2\", 8 },\n    { \"ISO-IR-101\", 8 },\n    { \"ISO_8859-2:1987\", 8 },\n    { \"ISO_8859-2\", 8 },\n    { \"LATIN2\", 8 },\n    { \"L2\", 8 },\n    { \"CP28592\", 8 },\n\n    { \"ISO8859-3\", 8 },\n    { \"ISO-8859-3\", 8 },\n    { \"ISO-IR-109\", 8 },\n    { \"ISO_8859-3:1988\", 8 },\n    { \"ISO_8859-3\", 8 },\n    { \"LATIN3\", 8 },\n    { \"L3\", 8 },\n    { \"CP28593\", 8 },\n\n    { \"ISO8859-4\", 8 },\n    { \"ISO-8859-4\", 8 },\n    { \"ISO-IR-110\", 8 },\n    { \"ISO_8859-4:1988\", 8 },\n    { \"LATIN4\", 8 },\n    { \"L4\", 8 },\n    { \"CP28594\", 8 },\n\n    { \"ISO8859-5\", 8 },\n    { \"ISO-8859-5\", 8 },\n    { \"ISO-IR-144\", 8 },\n    { \"ISO_8859-5:1988\", 8 },\n    { \"CYRILLIC\", 8 },\n    { \"CP28595\", 8 },\n\n    { \"KOI8-R\", 8 },\n    { \"KOI8-RU\", 8 },\n    { \"KOI8-U\", 8 },\n\n    { \"ISO8859-6\", 8 },\n    { \"ISO-8859-6\", 8 },\n    { \"ISO-IR-127\", 8 },\n    { \"ISO_8859-6:1987\", 8 },\n    { \"ECMA-114\", 8 },\n    { \"ASMO-708\", 8 },\n    { \"ARABIC\", 8 },\n    { \"CP28596\", 8 },\n\n    { \"ISO8859-7\", 8 },\n    { \"ISO-8859-7\", 8 },\n    { \"ISO-IR-126\", 8 },\n    { \"ISO_8859-7:2003\", 8 },\n    { \"ISO_8859-7:1987\", 8 },\n    { \"ELOT_928\", 8 },\n    { \"ECMA-118\", 8 },\n    { \"GREEK\", 8 },\n    { \"GREEK8\", 8 },\n    { \"CP28597\", 8 },\n\n    { \"ISO8859-8\", 8 },\n    { \"ISO-8859-8\", 8 },\n    { \"ISO-IR-138\", 8 },\n    { \"ISO_8859-8:1988\", 8 },\n    { \"HEBREW\", 8 },\n    { \"CP28598\", 8 },\n\n    { \"ISO8859-9\", 8 },\n    { \"ISO-8859-9\", 8 },\n    { \"ISO-IR-148\", 8 },\n    { \"ISO_8859-9:1989\", 8 },\n    { \"LATIN5\", 8 },\n    { \"L5\", 8 },\n    { \"CP28599\", 8 },\n\n    { \"ISO8859-10\", 8 },\n    { \"ISO-8859-10\", 8 },\n    { \"ISO-IR-157\", 8 },\n    { \"ISO_8859-10:1992\", 8 },\n    { \"LATIN6\", 8 },\n    { \"L6\", 8 },\n    { \"CP28600\", 8 },\n\n    { \"ISO8859-11\", 8 },\n    { \"ISO-8859-11\", 8 },\n    { \"ISO-8859-11:2001\", 8 },\n    { \"ISO-IR-166\", 8 },\n    { \"CP474\", 8 },\n\n    { \"TIS-620\", 8 },\n    { \"TIS620\", 8 },\n    { \"TIS620-0\", 8 },\n    { \"TIS620.2529-1\", 8 },\n    { \"TIS620.2533-0\", 8 },\n\n    /* ISO-8859-12 was abandoned in 1997. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n    { \"ISO8859-13\", 8 },\n    { \"ISO-8859-13\", 8 },\n    { \"ISO-IR-179\", 8 },\n    { \"LATIN7\", 8 },\n    { \"L7\", 8 },\n    { \"CP28603\", 8 },\n\n    { \"ISO8859-14\", 8 },\n    { \"ISO-8859-14\", 8 },\n    { \"LATIN8\", 8 },\n    { \"L8\", 8 },\n\n    { \"ISO8859-15\", 8 },\n    { \"ISO-8859-15\", 8 },\n    { \"LATIN-9\", 8 },\n    { \"CP28605\", 8 },\n\n    { \"ISO8859-16\", 8 },\n    { \"ISO-8859-16\", 8 },\n    { \"ISO-IR-226\", 8 },\n    { \"ISO_8859-16:2001\", 8 },\n    { \"LATIN10\", 8 },\n    { \"L10\", 8 },\n\n    { \"CP1250\", 8 },\n    { \"CP1251\", 8 },\n\n    { \"CP1252\", 8 },\n    { \"MS-ANSI\", 8 },\n    { NULL, 0 }\n  };\n\n  /* Terminal setting variables. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  struct termios new_in_attrs;\n  struct termios old_in_attrs;\n\n  /* Interval timers used. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  struct itimerval periodic_itv; /* refresh rate for the timeout counter.    */\n\n  /* Used by the internal help system. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  help_attr_entry_t  **help_items_da = NULL;\n  help_attr_entry_t ***help_lines_da = NULL;\n\n  int fst_disp_help_line = 0;\n  int init_help_needed   = 1; /* 1 if help lines need to be reevaluated. */\n\n  /* Other variables. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  int    nb_rem_args = 0; /* Remaining non analyzed command line arguments.  */\n  char **rem_args    = NULL; /* Remaining non analyzed command line          *\n                              | arguments array.                             */\n\n  char *message = NULL; /* message to be displayed above the selection       *\n                         | window.                                           */\n  ll_t *message_lines_list = NULL; /* list of the lines in the message to    *\n                                    | be displayed.                          */\n  long  message_max_width  = 0; /* total width of the message                *\n                                 | (longest line).                           */\n  long  message_max_len    = 0; /* max number of bytes taken by a message     *\n                                 | line.                                     */\n\n  char *int_string      = NULL; /* String to be output when typing ^C.       */\n  int   int_as_in_shell = 1; /* CTRL-C mimics the shell behaviour.           */\n\n  FILE *input_file; /* The name of the file passed as argument if any.       */\n\n  long index; /* generic counter.                                            */\n\n  long daccess_index = 1; /* First index of the numbered words.              */\n\n  char   *daccess_np = NULL; /* direct access numbered pattern.              */\n  regex_t daccess_np_re; /* variable to store the compiled direct access     *\n                          | pattern (-N) RE.                                 */\n\n  char   *daccess_up = NULL; /* direct access not numbered pattern.          */\n  regex_t daccess_up_re; /* variable to store the compiled direct access     *\n                          | pattern (-U) RE.                                 */\n\n  char *include_pattern = NULL; /* ASCII version of the include RE           */\n  char *exclude_pattern = NULL; /* ASCII version of the exclude RE           */\n\n  int pattern_def_include = -1; /* Set to -1 until an -i or -e option is     *\n                                 | specified, This variable remembers  if    *\n                                 | the words not matched will be included    *\n                                 | (value 1) or excluded (value 0) by        *\n                                 | default.                                  */\n\n  regex_t include_re; /* variable to store the compiled include (-i) REs.    */\n  regex_t exclude_re; /* variable to store the compiled exclude (-e) REs.    */\n\n  ll_t *early_sed_list   = NULL; /* List of sed like string representation   *\n                                  | of regex given after (-ES).              */\n  ll_t *sed_list         = NULL; /* List of sed like string representation   *\n                                  | of regex given after (-S).               */\n  ll_t *include_sed_list = NULL; /* idem for -I.                             */\n  ll_t *exclude_sed_list = NULL; /* idem for -E.                             */\n\n  ll_t *inc_col_interval_list = NULL; /* Lists of included or                */\n  ll_t *exc_col_interval_list = NULL; /* excluded numerical intervals        */\n  ll_t *inc_row_interval_list = NULL; /* for lines and columns.              */\n  ll_t *exc_row_interval_list = NULL;\n\n  ll_t *inc_col_regex_list = NULL; /* Same for lines and columns specified.  */\n  ll_t *exc_col_regex_list = NULL; /* by regular expressions.                */\n  ll_t *inc_row_regex_list = NULL;\n  ll_t *exc_row_regex_list = NULL;\n\n  ll_t *al_col_interval_list = NULL; /* Lists of left aligned rows/columns,  */\n  ll_t *ar_col_interval_list = NULL; /* right aligned rows/columns,          */\n  ll_t *ac_col_interval_list = NULL; /* centered rows/columns                */\n  ll_t *al_row_interval_list = NULL;\n  ll_t *ar_row_interval_list = NULL;\n  ll_t *ac_row_interval_list = NULL;\n\n  ll_t *at_col_interval_list = NULL; /* list of attributes for rows and      */\n  ll_t *at_row_interval_list = NULL; /* columns.                             */\n\n  ll_t *al_col_regex_list = NULL; /* Same for regular expression based       */\n  ll_t *ar_col_regex_list = NULL; /* alignments.                             */\n  ll_t *ac_col_regex_list = NULL;\n  ll_t *al_row_regex_list = NULL;\n  ll_t *ar_row_regex_list = NULL;\n  ll_t *ac_row_regex_list = NULL;\n\n  ll_t *at_col_regex_list = NULL; /* list of attributes for rows and         */\n  ll_t *at_row_regex_list = NULL; /* columns.                                */\n\n  ll_t *al_word_regex_list = NULL;\n  ll_t *ar_word_regex_list = NULL;\n  ll_t *ac_word_regex_list = NULL;\n\n  unsigned char al_delim = 0x05; /* Alignment delimiter.                     */\n\n  alignment_t default_alignment = AL_NONE;\n\n  filters_t rows_filter_type = UNKNOWN_FILTER;\n\n  char   *first_word_pattern = NULL; /* used by -A/-Z.                       */\n  char   *last_word_pattern  = NULL;\n  regex_t first_word_re; /* to hold the compiled first words RE.             */\n  regex_t last_word_re;  /* to hold the compiled last words RE.              */\n\n  char   *special_pattern[9] = { NULL, NULL, NULL, NULL, NULL,\n                                 NULL, NULL, NULL, NULL }; /* -1 .. -9 */\n  regex_t special_re[9]; /* array to hold the compiled special patterns RE.  */\n\n  int include_visual_only = 0; /* If set to 1, the original word which is    *\n                                | read from stdin will be output even if its */\n  int exclude_visual_only = 0; /* visual representation was modified via     *\n                                | -S/-I/-E.                                  */\n\n  ll_t *cols_selector_list = NULL; /* to store ASCII representations of      */\n  char *cols_selector      = NULL; /* ranges add RE to select some columns   *\n                                    | with -C.                               */\n\n  ll_t *rows_selector_list = NULL; /* to store ASCII representations of      */\n  char *rows_selector      = NULL; /* ranges and RE to select some rows      *\n                                    | with -R.                               */\n\n  ll_t *aligns_selector_list = NULL; /* to store ASCII representations of    */\n  char *aligns_selector      = NULL; /* RE to select some rows with -al.     */\n\n  long wi; /* word index.                                                    */\n\n  term_t term; /* Terminal structure.                                        */\n\n  tst_node_t *tst_word    = NULL; /* TST used by the search function.        */\n  tst_node_t *tst_daccess = NULL; /* TST used by the direct access system.   */\n\n  long  page;     /* Step for the vertical cursor moves.                     */\n  char *word;     /* Temporary variable to work on words.                    */\n  char *tmp_word; /* Temporary variable able to contain  the beginning of    *\n                   | the word to be displayed.                               */\n\n  long     last_line = 0; /* last logical line number (from 0).              */\n  win_t    win;\n  limit_t  limits;  /* set of various limitations.                           */\n  ticker_t timers;  /* timers contents.                                      */\n  misc_t   misc;    /* misc contents.                                        */\n  mouse_t  mouse;   /* mouse default values.                                 */\n  toggle_t toggles; /* set of binary indicators.                             */\n\n  int   old_fd0; /* backups of the old stdin file descriptor.                */\n  int   old_fd1; /* backups of the old stdout file descriptor.               */\n  FILE *old_stdin;\n  FILE *old_stdout; /* The selected word will go there.                      */\n\n  long nl; /* Number of lines displayed in the window.                       */\n  long line_offset; /* Used to correctly put the cursor at the start of the  *\n                     | selection window, even after a terminal vertical      *\n                     | scroll.                                               */\n\n  long first_selectable; /* Index of the first selectable word in the input  *\n                          | stream.                                          */\n  long last_selectable;  /* Index of the last selectable word in the input   *\n                          | stream.                                          */\n\n  long min_size; /* Minimum screen width of a column in tabular mode.        */\n\n  long tab_max_size;      /* Maximum screen width of a column in tabular     *\n                           | mode.                                           */\n  long tab_real_max_size; /* Maximum size in bytes of a column in tabular    *\n                           | mode.                                           */\n\n  long *col_real_max_size = NULL; /* Array of maximum sizes (bytes) of each  */\n                                  /* column in column mode.                  */\n\n  long *col_max_size = NULL; /* Array of maximum sizes (in display cells)    *\n                              | of each column in column mode.               */\n\n  attrib_t **col_attrs = NULL; /* attributes for each column in column mode.  */\n\n  long word_real_max_size = 0; /* size of the longer word after expansion.   */\n  long cols_real_max_size = 0; /* Max real width of all columns used when    *\n                                | -w and -c are both set.                    */\n\n  long cols_max_size = 0; /* Same as above for the columns widths            */\n\n  long col_index = 0; /* Index of the current column when reading words,     *\n                       | used  in column mode.                               */\n\n  long cols_number = 0; /* Number of columns in column mode.                 */\n\n  char *pre_selection_index = NULL; /* pattern used to set the initial       *\n                                     | cursor position.                      */\n\n  unsigned char buffer[64]; /* Input buffer which will contain the scancode. */\n\n  search_data_t search_data;\n  search_data.buf = NULL;   /* Search buffer                                 */\n  search_data.len = 0;      /* Current position in the search buffer         */\n  search_data.utf8_len = 0; /* Current position in the search buffer in      *\n                             | UTF-8 units.                                  */\n  search_data.err      = 0; /* reset the error indicator.                    */\n  search_data.fuzzy_err_pos = -1; /* no last error position in search        *\n                                   | buffer.                                 */\n\n  long matching_word_cur_index = -1; /* cache for the next/previous moves    *\n                                      | in the matching words array.         */\n\n  struct sigaction sa; /* Signal structure.                                  */\n\n  char *iws = NULL, *ils = NULL, *zg = NULL; /* words/lines delimiters and   *\n                                              | zapped glyphs strings.       */\n\n  ll_t *word_delims_list   = NULL; /* and associated linked lists.           */\n  ll_t *line_delims_list   = NULL;\n  ll_t *zapped_glyphs_list = NULL;\n\n  char utf8_buffer[5]; /* buffer to store the bytes of a UTF-8 glyph         *\n                        | (4 chars max).                                     */\n  unsigned char is_last;\n  char         *charset;\n\n  char *home_ini_file;  /* init file full path.                              */\n  char *local_ini_file; /* init file full path.                              */\n\n  charsetinfo_t *charset_ptr;\n  langinfo_t     langinfo;\n  int            is_supported_charset;\n\n  long line_count = 0; /* Only used when -R is selected.                     */\n\n  attrib_t init_attr;\n\n  ll_node_t *inc_interval_node = NULL; /* one node of this list.             */\n  ll_node_t *exc_interval_node = NULL; /* one node of this list.             */\n\n  interval_t *inc_interval;       /* the data in each node.                  */\n  interval_t *exc_interval;       /* the data in each node.                  */\n  int         row_def_selectable; /* default selectable value.               */\n\n  int line_selected_by_regex = 0;\n  int line_excluded          = 0;\n\n  char *timeout_message;\n\n  char *common_options;\n  char *main_options, *main_spec_options;\n  char *col_options, *col_spec_options;\n  char *line_options, *line_spec_options;\n  char *tab_options, *tab_spec_options;\n  char *tag_options, *tag_spec_options;\n\n  /* Used to check if we can get the cursor position in the terminal. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  int row; /* absolute line position in terminal (1...)   */\n  int col; /* absolute column position in terminal (1...) */\n\n  int mouse_proto = -1;\n\n  /* Initialize some internal data structures. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  init_main_ds(&init_attr,\n               &win,\n               &limits,\n               &timers,\n               &toggles,\n               &misc,\n               &mouse,\n               &timeout,\n               &daccess);\n\n  /* direct access variable initialization.   */\n  /*   0   1   2   3   4   5                  */\n  /* +---+---+---+---+---+---+                */\n  /* |   |   |   |   |   |   | daccess_stack  */\n  /* +-^-+---+---+---+---+---+                */\n  /*   |                                      */\n  /*   daccess_stack_head                     */\n  /*                                          */\n  /* daccess_stack will be used as a string.  */\n  /* We must make sure its last byte is '\\0'. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  daccess_stack      = xcalloc(6, 1);\n  daccess_stack_head = 0;\n\n  /* fuzzy variables initialization. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  tst_search_list = ll_new();\n  ll_append(tst_search_list, sub_tst_new());\n\n  matching_words_da      = NULL;\n  best_matching_words_da = NULL;\n\n  /* Initialize the tag hit number which will permit to sort the */\n  /* pinned words when displayed.                                */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  long tag_nb = 0;\n\n  /* Columns selection variables. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  char *cols_filter = NULL;\n\n  /* Initialize the count of tagged words. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  long tagged_words = 0;\n\n  /* Double-click related variables. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  int             disable_double_click = 0;\n  int             click_nr             = 0;\n  struct timespec last_click_ts;\n\n  /* Get the current locale. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  setlocale(LC_ALL, \"\");\n  charset = nl_langinfo(CODESET);\n\n  /* Check if the local charset is supported. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  is_supported_charset = 0;\n  charset_ptr          = all_supported_charsets;\n\n  while (charset_ptr->name != NULL)\n  {\n    if (my_strcasecmp(charset, charset_ptr->name) == 0)\n    {\n      is_supported_charset = 1;\n      langinfo.bits        = charset_ptr->bits;\n      break;\n    }\n    charset_ptr++;\n  }\n\n  if (!is_supported_charset)\n  {\n    fprintf(stderr, \"%s is not a supported charset.\", charset);\n\n    exit(EXIT_FAILURE);\n  }\n\n  /* Remember the fact that the charset is UTF-8. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (strcmp(charset, \"UTF-8\") == 0)\n    langinfo.utf8 = 1;\n  else\n    langinfo.utf8 = 0;\n\n  /* my_isprint is a function pointers that points to   */\n  /* the 7 or 8-bit version of isprint according to the */\n  /* current locale.                                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (langinfo.utf8 || langinfo.bits == 8)\n    my_isprint = isprint8;\n  else\n    my_isprint = isprint7;\n\n  /* my_isempty is a function pointers that points to         */\n  /* the utf8 or non_utf8 version of isprint according to the */\n  /* current locale.                                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (langinfo.utf8)\n    my_isempty = isempty_utf8;\n  else\n    my_isempty = isempty_non_utf8;\n\n  /* Set terminal in noncanonical, noecho mode and  */\n  /* if TERM is unset or unknown, vt100 is assumed. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (getenv(\"TERM\") == NULL)\n    setupterm(\"vt100\", 1, (int *)0);\n  else\n    setupterm((char *)0, 1, (int *)0);\n\n  /* Get the number of colors if the use of colors is available */\n  /* and authorized.                                            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (getenv(\"NO_COLOR\") != NULL)\n    term.colors = 0;\n  else\n  {\n    term.colors = tigetnum(\"colors\");\n    if (term.colors < 0)\n      term.colors = 0;\n  }\n\n  /* Ignore SIGTTIN. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sigset_t sigs, oldsigs;\n\n  sigemptyset(&sigs);\n  sigaddset(&sigs, SIGTTIN);\n  sigprocmask(SIG_BLOCK, &sigs, &oldsigs);\n\n  /* Temporarily set /dev/tty as stdin/stdout to get its size */\n  /* even in a pipe.                                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  old_fd0 = dup(0);\n  if (old_fd0 == -1)\n  {\n    fprintf(stderr, \"Cannot save the standard input file descriptor.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  old_stdin = freopen(\"/dev/tty\", \"r\", stdin);\n\n  old_fd1 = dup(1);\n  if (old_fd1 == -1)\n  {\n    fprintf(stderr, \"Cannot save the standard output file descriptor.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  old_stdout = freopen(\"/dev/tty\", \"w\", stdout);\n\n  if (old_stdin == NULL || old_stdout == NULL)\n  {\n    fprintf(stderr, \"A terminal is required to use this program.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  /* Get the number of lines/columns of the terminal. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  get_terminal_size(&term.nlines, &term.ncolumns, &term);\n\n  /* Restore the old stdin and stdout. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (dup2(old_fd0, 0) == -1)\n  {\n    fprintf(stderr, \"Cannot restore the standard input file descriptor.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  if (dup2(old_fd1, 1) == -1)\n  {\n    fprintf(stderr, \"Cannot restore the standard output file descriptor.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  close(old_fd0);\n  close(old_fd1);\n\n  /* Build the full path of the .ini file. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  home_ini_file  = make_ini_path(argv[0], \"HOME\");\n  local_ini_file = make_ini_path(argv[0], \"PWD\");\n\n  /* Set the attributes from the configuration file if possible. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (ini_load(home_ini_file,\n               &win,\n               &term,\n               &limits,\n               &timers,\n               &misc,\n               &mouse,\n               ini_cb))\n    exit(EXIT_FAILURE);\n\n  if (ini_load(local_ini_file,\n               &win,\n               &term,\n               &limits,\n               &timers,\n               &misc,\n               &mouse,\n               ini_cb))\n    exit(EXIT_FAILURE);\n\n  free(home_ini_file);\n  free(local_ini_file);\n\n  /* Command line option settings using ctxopt. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctxopt_init(argv[0],\n              \"stop_if_non_option=No \"\n              \"allow_abbreviations=No \"\n              \"display_usage_on_error=Yes \");\n\n  common_options = \"[*help] \"\n                   \"[*usage] \"\n                   \"[include_re... #regex] \"\n                   \"[exclude_re... #regex] \"\n                   \"[title #message] \"\n                   \"[int [#string]] \"\n                   \"[attributes #prefix:attr...] \"\n                   \"[special_level_1 #...<3] \"\n                   \"[special_level_2 #...<3] \"\n                   \"[special_level_3 #...<3] \"\n                   \"[special_level_4 #...<3] \"\n                   \"[special_level_5 #...<3] \"\n                   \"[special_level_6 #...<3] \"\n                   \"[special_level_7 #...<3] \"\n                   \"[special_level_8 #...<3] \"\n                   \"[special_level_9 #...<3] \"\n                   \"[zapped_glyphs #bytes] \"\n                   \"[lines [#height]] \"\n                   \"[blank_nonprintable] \"\n                   \"[*invalid_character #invalid_char_subst] \"\n                   \"[center_mode] \"\n                   \"[clean] \"\n                   \"[keep_spaces] \"\n                   \"[word_separators #bytes] \"\n                   \"[no_scroll_bar] \"\n                   \"[early_subst_all... #/regex/repl/opts] \"\n                   \"[post_subst_all... #/regex/repl/opts] \"\n                   \"[post_subst_included... #/regex/repl/opts] \"\n                   \"[post_subst_excluded... #/regex/repl/opts] \"\n                   \"[search_method #prefix|substring|fuzzy] \"\n                   \"[start_pattern #pattern] \"\n                   \"[timeout #...] \"\n                   \"[hidden_timeout #...] \"\n                   \"[validate_in_search_mode] \"\n                   \"[visual_bell] \"\n                   \"[ignore_quotes] \"\n                   \"[incremental_search] \"\n                   \"[limits... #limit:value...] \"\n                   \"[forgotten_timeout #timeout] \"\n                   \"[double_click_delay #delay] \"\n                   \"[button_remapping #mapping...] \"\n                   \"[no_mouse] \"\n                   \"[show_blank_words [#blank_char]] \"; /* <- don't remove *\n                                                         | this space!     */\n\n  main_spec_options = \"[*copyright] \"\n                      \"[*version] \"\n                      \"[*long_help] \"\n                      \"[da_options #prefix:attr...] \"\n                      \"[auto_da_number... [#regex...]] \"\n                      \"[auto_da_unnumber... [#regex...]] \"\n                      \"[field_da_number] \"\n                      \"[column_mode>Columns] \"\n                      \"[line_mode>Lines] \"\n                      \"[tab_mode>Tabulations [#cols]] \"\n                      \"[tag_mode>Tagging [#delim]] \"\n                      \"[pin_mode>Tagging [#delim]]\";\n\n  col_spec_options = \"[wide_mode] \"\n                     \"[columns_select... #selector...] \"\n                     \"[rows_select... #selector...] \"\n                     \"[aligns_select... #re_selector...] \"\n                     \"[gutter [#string]] \"\n                     \"[line_separators #bytes] \"\n                     \"[da_options #prefix:attr...] \"\n                     \"[auto_da_number... [#regex...]] \"\n                     \"[auto_da_unnumber... [#regex...]] \"\n                     \"[field_da_number] \"\n                     \"[tag_mode>Tagging [#delim]] \"\n                     \"[pin_mode>Tagging [#delim]] \"\n                     \"[no_hor_scroll_bar] \"\n                     \"[hor_scroll_bar] \"\n                     \"[force_first_column #regex] \"\n                     \"[force_last_column #regex]\";\n\n  line_spec_options = \"[rows_select... #selector...] \"\n                      \"[line_separators #bytes] \"\n                      \"[da_options #prefix:attr...] \"\n                      \"[auto_da_number... [#regex...]] \"\n                      \"[auto_da_unnumber... [#regex...]] \"\n                      \"[field_da_number] \"\n                      \"[tag_mode>Tagging [#delim]] \"\n                      \"[pin_mode>Tagging [#delim]] \"\n                      \"[no_hor_scroll_bar] \"\n                      \"[hor_scroll_bar] \"\n                      \"[force_first_column #regex] \"\n                      \"[force_last_column #regex]\";\n\n  tab_spec_options = \"[wide_mode] \"\n                     \"[gutter [#string]] \"\n                     \"[line_separators #bytes] \"\n                     \"[da_options #prefix:attr...] \"\n                     \"[auto_da_number... [#regex...]] \"\n                     \"[auto_da_unnumber... [#regex...]] \"\n                     \"[field_da_number] \"\n                     \"[tag_mode>Tagging [#delim]] \"\n                     \"[pin_mode>Tagging [#delim]] \"\n                     \"[force_first_column #regex] \"\n                     \"[force_last_column #regex]\";\n\n  tag_spec_options = \"[auto_tag] \"\n                     \"[no_auto_tag] \"\n                     \"[column_mode>Columns] \"\n                     \"[line_mode>Lines] \"\n                     \"[tab_mode>Tabulations [#cols]]\";\n\n  main_options = concat(common_options, main_spec_options, (char *)0);\n  col_options  = concat(common_options, col_spec_options, (char *)0);\n  line_options = concat(common_options, line_spec_options, (char *)0);\n  tab_options  = concat(common_options, tab_spec_options, (char *)0);\n  tag_options  = concat(common_options, tag_spec_options, (char *)0);\n\n  ctxopt_new_ctx(\"Main\", main_options);\n  ctxopt_new_ctx(\"Columns\", col_options);\n  ctxopt_new_ctx(\"Lines\", line_options);\n  ctxopt_new_ctx(\"Tabulations\", tab_options);\n  ctxopt_new_ctx(\"Tagging\", tag_options);\n\n  free(main_options);\n  free(col_options);\n  free(line_options);\n  free(tab_options);\n  free(tag_options);\n\n  /* ctxopt parameters. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_opt_settings(parameters, \"help\", \"-h -help\");\n  ctxopt_add_opt_settings(parameters, \"long_help\", \"-H -long-help\");\n  ctxopt_add_opt_settings(parameters, \"usage\", \"-? -u -usage\");\n  ctxopt_add_opt_settings(parameters, \"copyright\", \"-copyright\");\n  ctxopt_add_opt_settings(parameters, \"version\", \"-V -version\");\n  ctxopt_add_opt_settings(parameters,\n                          \"include_re\",\n                          \"-i -in -inc -incl -include\");\n  ctxopt_add_opt_settings(parameters,\n                          \"exclude_re\",\n                          \"-e -ex -exc -excl -exclude\");\n  ctxopt_add_opt_settings(parameters, \"lines\", \"-n -lines -height\");\n  ctxopt_add_opt_settings(parameters, \"title\", \"-m -msg -message -title\");\n  ctxopt_add_opt_settings(parameters, \"int\", \"-! -int -int_string\");\n  ctxopt_add_opt_settings(parameters, \"attributes\", \"-a -attr -attributes\");\n  ctxopt_add_opt_settings(parameters, \"special_level_1\", \"-1 -l1 -level1\");\n  ctxopt_add_opt_settings(parameters, \"special_level_2\", \"-2 -l2 -level2\");\n  ctxopt_add_opt_settings(parameters, \"special_level_3\", \"-3 -l3 -level3\");\n  ctxopt_add_opt_settings(parameters, \"special_level_4\", \"-4 -l4 -level4\");\n  ctxopt_add_opt_settings(parameters, \"special_level_5\", \"-5 -l5 -level5\");\n  ctxopt_add_opt_settings(parameters, \"special_level_6\", \"-6 -l6 -level6\");\n  ctxopt_add_opt_settings(parameters, \"special_level_7\", \"-7 -l7 -level7\");\n  ctxopt_add_opt_settings(parameters, \"special_level_8\", \"-8 -l8 -level8\");\n  ctxopt_add_opt_settings(parameters, \"special_level_9\", \"-9 -l9 -level9\");\n  ctxopt_add_opt_settings(parameters, \"tag_mode\", \"-T -tm -tag -tag_mode\");\n  ctxopt_add_opt_settings(parameters, \"pin_mode\", \"-P -pm -pin -pin_mode\");\n  ctxopt_add_opt_settings(parameters, \"auto_tag\", \"-p -at -auto_tag\");\n  ctxopt_add_opt_settings(parameters, \"no_auto_tag\", \"-0 -noat -no_auto_tag\");\n  ctxopt_add_opt_settings(parameters, \"auto_da_number\", \"-N -number\");\n  ctxopt_add_opt_settings(parameters, \"auto_da_unnumber\", \"-U -unnumber\");\n  ctxopt_add_opt_settings(parameters,\n                          \"field_da_number\",\n                          \"-F -en -embedded_number\");\n  ctxopt_add_opt_settings(parameters, \"da_options\", \"-D -data -options\");\n  ctxopt_add_opt_settings(parameters, \"invalid_character\", \"-. -dot -invalid\");\n  ctxopt_add_opt_settings(parameters, \"blank_nonprintable\", \"-b -blank\");\n  ctxopt_add_opt_settings(parameters, \"center_mode\", \"-M -middle -center\");\n  ctxopt_add_opt_settings(parameters,\n                          \"clean\",\n                          \"-d -restore -delete -clean \"\n                          \"-delete_window -clean_window\");\n  ctxopt_add_opt_settings(parameters,\n                          \"column_mode\",\n                          \"-c -col -col_mode -column\");\n  ctxopt_add_opt_settings(parameters, \"line_mode\", \"-l -line -line_mode\");\n  ctxopt_add_opt_settings(parameters,\n                          \"tab_mode\",\n                          \"-t -tab -tab_mode -tabulate_mode\");\n  ctxopt_add_opt_settings(parameters, \"wide_mode\", \"-w -wide -wide_mode\");\n  ctxopt_add_opt_settings(parameters,\n                          \"columns_select\",\n                          \"-C -cs -cols -cols_select\");\n  ctxopt_add_opt_settings(parameters,\n                          \"rows_select\",\n                          \"-R -rs -rows -rows_select\");\n  ctxopt_add_opt_settings(parameters, \"aligns_select\", \"-al -align\");\n  ctxopt_add_opt_settings(parameters,\n                          \"force_first_column\",\n                          \"-A -fc -first_column\");\n  ctxopt_add_opt_settings(parameters,\n                          \"force_last_column\",\n                          \"-Z -lc -last_column\");\n  ctxopt_add_opt_settings(parameters, \"gutter\", \"-g -gutter\");\n  ctxopt_add_opt_settings(parameters, \"keep_spaces\", \"-k -ks -keep_spaces\");\n  ctxopt_add_opt_settings(parameters,\n                          \"word_separators\",\n                          \"-W -ws -wd -word_delimiters -word_separators\");\n  ctxopt_add_opt_settings(parameters,\n                          \"line_separators\",\n                          \"-L -ls -ld -line-delimiters -line_separators\");\n  ctxopt_add_opt_settings(parameters, \"zapped_glyphs\", \"-z -zap -zap-glyphs\");\n  ctxopt_add_opt_settings(parameters,\n                          \"no_scroll_bar\",\n                          \"-q -no_bar -no_scroll_bar\");\n  ctxopt_add_opt_settings(parameters,\n                          \"no_hor_scroll_bar\",\n                          \"-no_hbar -no_hor_scroll_bar\");\n  ctxopt_add_opt_settings(parameters,\n                          \"hor_scroll_bar\",\n                          \"-hbar -hor_scroll_bar\");\n  ctxopt_add_opt_settings(parameters, \"early_subst_all\", \"-ES -early_subst\");\n  ctxopt_add_opt_settings(parameters, \"post_subst_all\", \"-S -subst\");\n  ctxopt_add_opt_settings(parameters,\n                          \"post_subst_included\",\n                          \"-I -si -subst_included\");\n  ctxopt_add_opt_settings(parameters,\n                          \"post_subst_excluded\",\n                          \"-E -se -subst_excluded\");\n  ctxopt_add_opt_settings(parameters, \"search_method\", \"-/ -search_method\");\n  ctxopt_add_opt_settings(parameters,\n                          \"start_pattern\",\n                          \"-s -sp -start -start_pattern\");\n  ctxopt_add_opt_settings(parameters, \"timeout\", \"-x -tmout -timeout\");\n  ctxopt_add_opt_settings(parameters,\n                          \"hidden_timeout\",\n                          \"-X -htmout -hidden_timeout\");\n  ctxopt_add_opt_settings(parameters,\n                          \"validate_in_search_mode\",\n                          \"-r -auto_validate\");\n  ctxopt_add_opt_settings(parameters, \"visual_bell\", \"-v -vb -visual_bell\");\n  ctxopt_add_opt_settings(parameters, \"ignore_quotes\", \"-Q -ignore_quotes\");\n  ctxopt_add_opt_settings(parameters,\n                          \"incremental_search\",\n                          \"-is -incremental_search\");\n  ctxopt_add_opt_settings(parameters, \"limits\", \"-lim -limits\");\n  ctxopt_add_opt_settings(parameters,\n                          \"forgotten_timeout\",\n                          \"-f -forgotten_timeout -global_timeout\");\n  ctxopt_add_opt_settings(parameters, \"no_mouse\", \"-nm -no_mouse\");\n  ctxopt_add_opt_settings(parameters,\n                          \"button_remapping\",\n                          \"-br -buttons -button_remapping\");\n  ctxopt_add_opt_settings(parameters,\n                          \"double_click_delay\",\n                          \"-dc -dcd -double_click -double_click_delay\");\n  ctxopt_add_opt_settings(parameters,\n                          \"show_blank_words\",\n                          \"-sb -sbw -show_blank_words\");\n\n  /* ctxopt options incompatibilities. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_ctx_settings(incompatibilities,\n                          \"Main\",\n                          \"column_mode line_mode tab_mode\");\n  ctxopt_add_ctx_settings(incompatibilities, \"Main\", \"tag_mode pin_mode\");\n  ctxopt_add_ctx_settings(incompatibilities, \"Main\", \"help usage\");\n  ctxopt_add_ctx_settings(incompatibilities, \"Main\", \"timeout hidden_timeout\");\n  ctxopt_add_ctx_settings(incompatibilities,\n                          \"Main\",\n                          \"no_mouse button_remapping\");\n  ctxopt_add_ctx_settings(incompatibilities,\n                          \"Main\",\n                          \"no_mouse double_click_delay\");\n\n  /* ctxopt options requirements. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_ctx_settings(requirements,\n                          \"Main\",\n                          \"da_options \"\n                          \"field_da_number auto_da_number auto_da_unnumber\");\n  ctxopt_add_ctx_settings(requirements,\n                          \"Columns\",\n                          \"da_options \"\n                          \"field_da_number auto_da_number auto_da_unnumber\");\n  ctxopt_add_ctx_settings(requirements,\n                          \"Lines\",\n                          \"da_options \"\n                          \"field_da_number auto_da_number auto_da_unnumber\");\n  ctxopt_add_ctx_settings(requirements,\n                          \"Tabulations\",\n                          \"da_options \"\n                          \"field_da_number auto_da_number auto_da_unnumber\");\n\n  /* ctxopt actions. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_opt_settings(actions,\n                          \"auto_tag\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"no_auto_tag\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"invalid_character\",\n                          invalid_char_action,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"blank_nonprintable\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"center_mode\",\n                          center_mode_action,\n                          &win,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions, \"clean\", toggle_action, &toggles, (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"column_mode\",\n                          column_mode_action,\n                          &win,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"line_mode\",\n                          line_mode_action,\n                          &win,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"tab_mode\",\n                          tab_mode_action,\n                          &win,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"columns_select\",\n                          columns_select_action,\n                          &cols_selector_list,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"rows_select\",\n                          rows_select_action,\n                          &rows_selector_list,\n                          &win,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"aligns_select\",\n                          aligns_select_action,\n                          &aligns_selector_list,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"include_re\",\n                          include_re_action,\n                          &pattern_def_include,\n                          &include_pattern,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"exclude_re\",\n                          exclude_re_action,\n                          &pattern_def_include,\n                          &exclude_pattern,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"gutter\",\n                          gutter_action,\n                          &win,\n                          &langinfo,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions, \"help\", help_action, (char *)0);\n  ctxopt_add_opt_settings(actions, \"long_help\", long_help_action, (char *)0);\n  ctxopt_add_opt_settings(actions, \"usage\", usage_action, (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"keep_spaces\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions, \"lines\", lines_action, &win, (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"no_scroll_bar\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"no_hor_scroll_bar\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"hor_scroll_bar\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"start_pattern\",\n                          set_pattern_action,\n                          &pre_selection_index,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"title\",\n                          set_string_action,\n                          &message,\n                          &langinfo,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"int\",\n                          int_action,\n                          &int_string,\n                          &int_as_in_shell,\n                          &langinfo,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"validate_in_search_mode\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions, \"copyright\", copyright_action, (char *)0);\n  ctxopt_add_opt_settings(actions, \"version\", version_action, (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"visual_bell\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"incremental_search\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"wide_mode\",\n                          wide_mode_action,\n                          &win,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"early_subst_all\",\n                          post_subst_action,\n                          &early_sed_list,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"post_subst_all\",\n                          post_subst_action,\n                          &sed_list,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"post_subst_included\",\n                          post_subst_action,\n                          &include_sed_list,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"post_subst_excluded\",\n                          post_subst_action,\n                          &exclude_sed_list,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_1\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_2\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_3\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_4\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_5\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_6\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_7\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_8\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"special_level_9\",\n                          special_level_action,\n                          special_pattern,\n                          &win,\n                          &term,\n                          &init_attr,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"attributes\",\n                          attributes_action,\n                          &win,\n                          &term,\n                          &init_attr,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions, \"timeout\", timeout_action, &misc, (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"hidden_timeout\",\n                          timeout_action,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"force_first_column\",\n                          set_pattern_action,\n                          &first_word_pattern,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"force_last_column\",\n                          set_pattern_action,\n                          &last_word_pattern,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"word_separators\",\n                          set_pattern_action,\n                          &iws,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"line_separators\",\n                          set_pattern_action,\n                          &ils,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"zapped_glyphs\",\n                          set_pattern_action,\n                          &zg,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"tag_mode\",\n                          tag_mode_action,\n                          &toggles,\n                          &win,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"pin_mode\",\n                          pin_mode_action,\n                          &toggles,\n                          &win,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"search_method\",\n                          search_method_action,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"auto_da_number\",\n                          auto_da_action,\n                          &daccess_np,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"auto_da_unnumber\",\n                          auto_da_action,\n                          &daccess_up,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"field_da_number\",\n                          field_da_number_action,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"da_options\",\n                          da_options_action,\n                          &daccess_index,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"ignore_quotes\",\n                          ignore_quotes_action,\n                          &misc,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions, \"limits\", limits_action, &limits, (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"forgotten_timeout\",\n                          forgotten_action,\n                          &timers,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"button_remapping\",\n                          button_action,\n                          &mouse,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"double_click_delay\",\n                          double_click_action,\n                          &mouse,\n                          &disable_double_click,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"no_mouse\",\n                          toggle_action,\n                          &toggles,\n                          (char *)0);\n  ctxopt_add_opt_settings(actions,\n                          \"show_blank_words\",\n                          show_blank_action,\n                          &toggles,\n                          &misc,\n                          (char *)0);\n\n  /* ctxopt constraints. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_opt_settings(constraints,\n                          \"attributes\",\n                          ctxopt_re_constraint,\n                          \"[^:]+:.+\");\n  ctxopt_add_opt_settings(constraints,\n                          \"da_options\",\n                          ctxopt_re_constraint,\n                          \"[^:]+:.+\");\n  ctxopt_add_opt_settings(constraints, \"lines\", check_integer_constraint, \"\");\n\n  ctxopt_add_opt_settings(constraints,\n                          \"tab_mode\",\n                          check_integer_constraint,\n                          \"\");\n  ctxopt_add_opt_settings(constraints,\n                          \"tab_mode\",\n                          ctxopt_range_constraint,\n                          \"1 .\");\n  ctxopt_add_opt_settings(constraints,\n                          \"double_click_delay\",\n                          check_integer_constraint,\n                          \"\");\n\n  /* Evaluation order. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_opt_settings(after,\n                          \"field_da_number\",\n                          \"auto_da_number auto_da_unnumber\");\n\n  ctxopt_add_opt_settings(after,\n                          \"da_options\",\n                          \"field_da_number auto_da_number auto_da_unnumber\");\n\n  /* In help settings. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  ctxopt_add_opt_settings(visible_in_help, \"copyright\", \"no\");\n\n  /* Command line options analysis. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctxopt_analyze(argc - 1, argv + 1, &nb_rem_args, &rem_args);\n\n  /* Command line options evaluation. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctxopt_evaluate();\n\n  /* Check remaining non analyzed command line arguments. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (nb_rem_args == 1)\n  {\n    input_file = fopen_safe(rem_args[0], \"r\");\n    if (input_file == NULL)\n    {\n      fprintf(stderr,\n              \"The file \\\"%s\\\" does not exist or cannot be read.\\n\",\n              rem_args[0]);\n      ctxopt_ctx_disp_usage(NULL, exit_after);\n      exit(EXIT_FAILURE); /* Avoid a compiler warning. */\n    }\n  }\n  else if (nb_rem_args == 0)\n    input_file = stdin;\n  else\n  {\n    fprintf(stderr, \"Extra arguments detected:\\n\");\n\n    fprintf(stderr, \"%s\", rem_args[1]);\n    for (int i = 2; i < nb_rem_args; i++)\n      fprintf(stderr, \", %s\", rem_args[i]);\n    fprintf(stderr, \".\\n\");\n\n    ctxopt_ctx_disp_usage(NULL, exit_after);\n    exit(EXIT_FAILURE); /* Avoid a compiler warning. */\n  }\n\n  /* Free the memory used internally by ctxopt. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ctxopt_free_memory();\n\n  /* If we did not impose the number of columns, use the whole */\n  /* terminal width.                                           */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.tab_mode && !win.max_cols)\n    win.wide = 1;\n\n  /* Force the padding mode to all when words are numbered and not in */\n  /* col/line/tab_mode.                                               */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (daccess.padding != 'a' && (win.col_mode || win.line_mode || win.tab_mode))\n    daccess.padding = 'a';\n\n  win.start = 0;\n\n  term.color_method = ANSI; /* We default to setaf/setbf to set colors. */\n  term.curs_line = term.curs_column = 0;\n\n  {\n    char *str;\n\n    str                        = tigetstr(\"cuu1\");\n    term.has_cursor_up         = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"cud1\");\n    term.has_cursor_down       = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"cub1\");\n    term.has_cursor_left       = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"cuf1\");\n    term.has_cursor_right      = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"cup\");\n    term.has_cursor_address    = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"sc\");\n    term.has_save_cursor       = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"rc\");\n    term.has_restore_cursor    = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"setf\");\n    term.has_setf              = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"setb\");\n    term.has_setb              = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"setaf\");\n    term.has_setaf             = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"setab\");\n    term.has_setab             = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"hpa\");\n    term.has_hpa               = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"cuf\");\n    term.has_parm_right_cursor = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"bold\");\n    term.has_bold              = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"dim\");\n    term.has_dim               = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"rev\");\n    term.has_reverse           = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"smul\");\n    term.has_underline         = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"smso\");\n    term.has_standout          = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"sitm\");\n    term.has_italic            = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"invis\");\n    term.has_invis             = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"blink\");\n    term.has_blink             = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"kmous\");\n    term.has_kmous             = (str == (char *)-1 || str == NULL) ? 0 : 1;\n    str                        = tigetstr(\"rep\");\n    term.has_rep               = (str == (char *)-1 || str == NULL) ? 0 : 1;\n  }\n\n  if (!term.has_cursor_up || !term.has_cursor_down || !term.has_cursor_left\n      || !term.has_cursor_right || !term.has_save_cursor\n      || !term.has_restore_cursor)\n  {\n    fprintf(stderr,\n            \"The terminal does not have the required cursor \"\n            \"management capabilities.\\n\");\n\n    exit(EXIT_FAILURE);\n  }\n\n  word_buffer = xcalloc(1, daccess.flength + limits.word_length + 1);\n\n  /* default_search_method is not set in the command line nor in a config */\n  /* file, set it to fuzzy.                                               */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (misc.default_search_method == NONE)\n    misc.default_search_method = FUZZY;\n\n  /* If some attributes were not set, set their default values. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (term.colors > 7)\n  {\n    int const special_def_attr[9] = { 1, 2, 3, 5, 6, 7, 7, 7, 7 };\n\n    if (!win.cursor_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.cursor_attr.reverse = 1;\n      else if (term.has_standout)\n        win.cursor_attr.standout = 1;\n\n      win.cursor_attr.is_set = SET;\n    }\n\n    if (!win.cursor_marked_attr.is_set)\n    {\n      if (term.has_dim)\n        win.cursor_marked_attr.dim = 1;\n      else if (term.has_bold)\n        win.cursor_marked_attr.bold = 1;\n\n      if (term.has_reverse)\n        win.cursor_marked_attr.reverse = 1;\n      else if (term.has_standout)\n        win.cursor_marked_attr.standout = 1;\n\n      win.cursor_marked_attr.is_set = SET;\n    }\n\n    if (!win.cursor_on_marked_attr.is_set)\n    {\n      if (term.has_bold)\n        win.cursor_on_marked_attr.bold = 1;\n      if (term.has_italic)\n        win.cursor_on_marked_attr.italic = 1;\n\n      if (term.has_reverse)\n        win.cursor_on_marked_attr.reverse = 1;\n      else if (term.has_standout)\n        win.cursor_on_marked_attr.standout = 1;\n\n      win.cursor_on_marked_attr.is_set = SET;\n    }\n\n    if (!win.cursor_on_tag_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.cursor_on_tag_attr.reverse = 1;\n\n      if (term.has_underline)\n        win.cursor_on_tag_attr.underline = 1;\n      else\n        win.cursor_on_tag_attr.fg = 2;\n\n      win.cursor_on_tag_attr.is_set = SET;\n    }\n\n    if (!win.cursor_on_tag_marked_attr.is_set)\n    {\n      if (term.has_dim)\n        win.cursor_on_tag_marked_attr.dim = 1;\n\n      if (term.has_reverse)\n        win.cursor_on_tag_marked_attr.reverse = 1;\n\n      if (term.has_underline)\n        win.cursor_on_tag_marked_attr.underline = 1;\n\n      win.cursor_on_tag_marked_attr.is_set = SET;\n    }\n\n    if (!win.marked_attr.is_set)\n    {\n      if (term.has_standout)\n        win.marked_attr.standout = 1;\n\n      if (term.has_bold)\n        win.marked_attr.bold = 1;\n\n      win.marked_attr.fg = 2;\n      win.marked_attr.bg = 0;\n\n      win.marked_attr.is_set = SET;\n    }\n\n    if (!win.bar_attr.is_set)\n    {\n      win.bar_attr.fg     = 2;\n      win.bar_attr.is_set = SET;\n    }\n\n    if (!win.shift_attr.is_set)\n    {\n      win.shift_attr.fg     = 2;\n      win.shift_attr.is_set = SET;\n    }\n\n    if (!win.message_attr.is_set)\n    {\n      if (term.has_bold)\n        win.message_attr.bold = 1;\n      else if (term.has_reverse)\n        win.message_attr.reverse = 1;\n      else\n      {\n        win.message_attr.fg = 0;\n        win.message_attr.bg = 7;\n      }\n\n      win.message_attr.is_set = SET;\n    }\n\n    if (!win.search_field_attr.is_set)\n    {\n      win.search_field_attr.bg     = 5;\n      win.search_field_attr.is_set = SET;\n    }\n\n    if (!win.search_text_attr.is_set)\n    {\n      win.search_text_attr.fg = 0;\n      win.search_text_attr.bg = 6;\n\n      win.search_text_attr.is_set = SET;\n    }\n\n    if (!win.search_err_field_attr.is_set)\n    {\n      win.search_err_field_attr.bg     = 1;\n      win.search_err_field_attr.is_set = SET;\n    }\n\n    if (!win.search_err_text_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.search_err_text_attr.reverse = 1;\n\n      win.search_err_text_attr.fg     = 1;\n      win.search_err_text_attr.is_set = SET;\n    }\n\n    if (!win.match_field_attr.is_set)\n    {\n      win.match_field_attr.is_set = SET;\n    }\n\n    if (!win.match_text_attr.is_set)\n    {\n      win.match_text_attr.fg     = 5;\n      win.match_text_attr.is_set = SET;\n    }\n\n    if (!win.match_err_field_attr.is_set)\n    {\n      win.match_err_field_attr.is_set = SET;\n    }\n\n    if (!win.match_err_text_attr.is_set)\n    {\n      win.match_err_text_attr.fg     = 1;\n      win.match_err_text_attr.is_set = SET;\n    }\n\n    if (!win.exclude_attr.is_set)\n    {\n      win.exclude_attr.fg = 6;\n\n      win.exclude_attr.is_set = SET;\n    }\n\n    /* This attribute should complete the attributes already set. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (!win.tag_attr.is_set)\n    {\n      if (term.has_underline)\n        win.tag_attr.underline = 1;\n      else if (term.has_bold)\n        win.tag_attr.bold = 1;\n      else\n        win.tag_attr.fg = 2;\n\n      win.tag_attr.is_set = SET;\n    }\n\n    if (!win.daccess_attr.is_set)\n    {\n      if (term.has_bold)\n        win.daccess_attr.bold = 1;\n\n      win.daccess_attr.is_set = SET;\n    }\n\n    for (index = 0; index < 9; index++)\n    {\n      if (!win.special_attr[index].is_set)\n      {\n        win.special_attr[index].fg     = special_def_attr[index];\n        win.special_attr[index].is_set = SET;\n      }\n    }\n  }\n  else\n  {\n    if (!win.cursor_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.cursor_attr.reverse = 1;\n\n      win.cursor_attr.is_set = SET;\n    }\n\n    if (!win.cursor_on_tag_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.cursor_on_tag_attr.reverse = 1;\n\n      if (term.has_underline)\n        win.cursor_on_tag_attr.underline = 1;\n      else if (term.has_bold)\n        win.cursor_on_tag_attr.bold = 1;\n\n      win.cursor_on_tag_attr.is_set = SET;\n    }\n\n    if (!win.bar_attr.is_set)\n    {\n      if (term.has_bold)\n        win.bar_attr.bold = 1;\n\n      win.bar_attr.is_set = SET;\n    }\n\n    if (!win.shift_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.shift_attr.reverse = 1;\n\n      win.shift_attr.is_set = SET;\n    }\n\n    if (!win.message_attr.is_set)\n    {\n      if (term.has_bold)\n        win.message_attr.bold = 1;\n      else if (term.has_reverse)\n        win.message_attr.reverse = 1;\n\n      win.message_attr.is_set = SET;\n    }\n\n    if (!win.search_field_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.search_field_attr.reverse = 1;\n\n      win.search_field_attr.is_set = SET;\n    }\n\n    if (!win.search_text_attr.is_set)\n    {\n      if (term.has_bold)\n        win.search_text_attr.bold = 1;\n\n      win.search_text_attr.is_set = SET;\n    }\n\n    if (!win.search_err_field_attr.is_set)\n    {\n      if (term.has_bold)\n        win.search_err_field_attr.bold = 1;\n\n      win.search_err_field_attr.is_set = SET;\n    }\n\n    if (!win.search_err_text_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.search_err_text_attr.reverse = 1;\n\n      win.search_err_text_attr.is_set = SET;\n    }\n\n    if (!win.match_field_attr.is_set)\n    {\n      if (term.has_bold)\n        win.match_field_attr.bold = 1;\n      else if (term.has_reverse)\n        win.match_field_attr.reverse = 1;\n\n      win.match_field_attr.is_set = SET;\n    }\n\n    if (!win.match_text_attr.is_set)\n    {\n      if (term.has_reverse)\n        win.match_text_attr.reverse = 1;\n      else if (term.has_bold)\n        win.match_text_attr.bold = 1;\n\n      win.match_text_attr.is_set = SET;\n    }\n\n    if (!win.exclude_attr.is_set)\n    {\n      if (term.has_dim)\n        win.exclude_attr.dim = 1;\n      else if (term.has_italic)\n        win.exclude_attr.italic = 1;\n      else if (term.has_bold)\n        win.exclude_attr.bold = 1;\n\n      win.exclude_attr.is_set = SET;\n    }\n\n    if (!win.tag_attr.is_set)\n    {\n      if (term.has_underline)\n        win.tag_attr.underline = 1;\n      else if (term.has_standout)\n        win.tag_attr.standout = 1;\n      else if (term.has_reverse)\n        win.tag_attr.reverse = 1;\n\n      win.tag_attr.is_set = SET;\n    }\n\n    if (!win.daccess_attr.is_set)\n    {\n      if (term.has_bold)\n        win.daccess_attr.bold = 1;\n\n      win.daccess_attr.is_set = SET;\n    }\n\n    for (index = 0; index < 9; index++)\n    {\n      if (!win.special_attr[index].is_set)\n      {\n        if (term.has_bold)\n          win.special_attr[index].bold = 1;\n        else if (term.has_standout)\n          win.special_attr[index].standout = 1;\n\n        win.special_attr[index].is_set = SET;\n      }\n    }\n  }\n\n  /* Initialize and arm the global (forgotten) timer. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  forgotten_timer = timers.forgotten;\n\n  /* Initialize the timeout message when the x/X option is set. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!quiet_timeout && timeout.initial_value > 0)\n  {\n    switch (timeout.mode)\n    {\n      case QUIT:\n        timeout_message = xstrdup(\n          \"[     s before quitting without selecting anything]\");\n        break;\n\n      case CURRENT:\n        timeout_message = xstrdup(\n          \"[     s before selecting the current highlighted word]\");\n        break;\n\n      case WORD:\n      {\n        char *s = \"[     s before selecting the word \\\"\";\n\n        timeout_message = xcalloc(1, 4 + strlen(s) + strlen(timeout_word));\n\n        strcpy(timeout_message, s);\n        strcat(timeout_message, timeout_word);\n        strcat(timeout_message, \"\\\"]\");\n\n        break;\n      }\n\n      default:\n        /* The other cases are impossible due to options analysis. */\n        /* ''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        timeout_message = xstrdup(\"      \"); /* Just in case. */\n    }\n\n    timeout_seconds = xcalloc(1, 6);\n    snprintf(timeout_seconds, 6, \"%5u\", timeout.initial_value / FREQ);\n    memcpy(timeout_message + 1, timeout_seconds, 5);\n\n    message_lines_list = ll_new();\n\n    if (message)\n    {\n      long len;\n\n      get_message_lines(message,\n                        message_lines_list,\n                        &message_max_width,\n                        &message_max_len);\n      ll_append(message_lines_list, timeout_message);\n\n      if ((len = strlen(timeout_message)) > message_max_len)\n        message_max_len = message_max_width = len;\n    }\n    else\n    {\n      ll_append(message_lines_list, timeout_message);\n      message_max_len = message_max_width = strlen(timeout_message);\n    }\n  }\n  else if (message)\n  {\n    message_lines_list = ll_new();\n    get_message_lines(message,\n                      message_lines_list,\n                      &message_max_width,\n                      &message_max_len);\n  }\n\n  /* Force the maximum number of window's line if -n is used. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (term.nlines <= win.message_lines)\n  {\n    win.message_lines = term.nlines - 1;\n    win.max_lines     = 1;\n  }\n  else if (win.asked_max_lines >= 0)\n  {\n    if (win.asked_max_lines == 0)\n      win.max_lines = term.nlines - win.message_lines - 1;\n    else\n    {\n      if (win.asked_max_lines > term.nlines - win.message_lines)\n        win.max_lines = term.nlines - win.message_lines - 1;\n      else\n        win.max_lines = win.asked_max_lines;\n    }\n  }\n  else /* -n was not used. Set win.asked_max_lines to its default value. */\n    win.asked_max_lines = win.max_lines;\n\n  /* Allocate the memory for our words structures. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  word_a = xmalloc(WORDSCHUNK * sizeof(word_t));\n\n  /* Fill an array of word_t elements obtained from stdin. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  tab_real_max_size = 0;\n  tab_max_size      = 0;\n  min_size          = 0;\n\n  /* Parse the list of glyphs to be zapped (option -z). */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  zapped_glyphs_list = ll_new();\n  if (zg != NULL)\n  {\n    int   utf8_len;\n    char *zg_ptr = zg;\n    char *tmp;\n\n    utf8_len = mblen(zg_ptr, 4);\n\n    while (utf8_len != 0)\n    {\n      tmp = xmalloc(utf8_len + 1);\n      memcpy(tmp, zg_ptr, utf8_len);\n      tmp[utf8_len] = '\\0';\n      ll_append(zapped_glyphs_list, tmp);\n\n      zg_ptr += utf8_len;\n      utf8_len = mblen(zg_ptr, 4);\n    }\n  }\n\n  /* Parse the word separators string (option -W). If it is empty then  */\n  /* the standard delimiters (space, tab and EOL) are used. Each of its */\n  /* UTF-8 sequences are stored in a linked list.                       */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  word_delims_list = ll_new();\n\n  if (iws == NULL)\n  {\n    ll_append(word_delims_list, \" \");\n    ll_append(word_delims_list, \"\\t\");\n    ll_append(word_delims_list, \"\\n\");\n  }\n  else\n  {\n    int   utf8_len;\n    char *iws_ptr = iws;\n    char *tmp;\n\n    utf8_len = mblen(iws_ptr, 4);\n\n    while (utf8_len != 0)\n    {\n      tmp = xmalloc(utf8_len + 1);\n      memcpy(tmp, iws_ptr, utf8_len);\n      tmp[utf8_len] = '\\0';\n      ll_append(word_delims_list, tmp);\n\n      iws_ptr += utf8_len;\n      utf8_len = mblen(iws_ptr, 4);\n    }\n  }\n\n  /* Parse the line separators string (option -L). If it is empty then */\n  /* the standard delimiter (newline) is used. Each of its UTF-8       */\n  /* sequences are stored in a linked list.                            */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  line_delims_list = ll_new();\n\n  /* A default line separator is set to '\\n' except in tab_mode */\n  /* where it should be explicitly set.                         */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (ils == NULL && !win.tab_mode)\n    ll_append(line_delims_list, \"\\n\");\n  else\n  {\n    int   utf8_len;\n    char *ils_ptr = ils;\n    char *tmp;\n\n    utf8_len = mblen(ils_ptr, 4);\n\n    while (utf8_len != 0)\n    {\n      tmp = xmalloc(utf8_len + 1);\n      memcpy(tmp, ils_ptr, utf8_len);\n      tmp[utf8_len] = '\\0';\n      ll_append(line_delims_list, tmp);\n\n      /* Add this record delimiter as a word delimiter. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (ll_find(word_delims_list, tmp, buffer_cmp) == NULL)\n        ll_append(word_delims_list, tmp);\n\n      ils_ptr += utf8_len;\n      utf8_len = mblen(ils_ptr, 4);\n    }\n  }\n\n  /* Initialize the first chunks of the arrays which will contain the */\n  /* maximum length of each column in column mode.                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.col_mode)\n  {\n    long ci; /* Column index. */\n\n    col_real_max_size = xmalloc(COLSCHUNK * sizeof(long));\n    col_max_size      = xmalloc(COLSCHUNK * sizeof(long));\n\n    for (ci = 0; ci < COLSCHUNK; ci++)\n      col_real_max_size[ci] = col_max_size[ci] = 0;\n\n    col_index = cols_number = 0;\n  }\n\n  /* Compile the regular expression patterns. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (daccess_np\n      && regcomp(&daccess_np_re, daccess_np, REG_EXTENDED | REG_NOSUB) != 0)\n  {\n    fprintf(stderr, \"%s: Bad regular expression.\\n\", daccess_np);\n\n    exit(EXIT_FAILURE);\n  }\n\n  if (daccess_up\n      && regcomp(&daccess_up_re, daccess_up, REG_EXTENDED | REG_NOSUB) != 0)\n  {\n    fprintf(stderr, \"%s: Bad regular expression.\\n\", daccess_up);\n\n    exit(EXIT_FAILURE);\n  }\n\n  if (include_pattern != NULL\n      && regcomp(&include_re, include_pattern, REG_EXTENDED | REG_NOSUB) != 0)\n  {\n    fprintf(stderr, \"%s: Bad regular expression.\\n\", include_pattern);\n\n    exit(EXIT_FAILURE);\n  }\n\n  if (exclude_pattern != NULL\n      && regcomp(&exclude_re, exclude_pattern, REG_EXTENDED | REG_NOSUB) != 0)\n  {\n    fprintf(stderr, \"%s: Bad regular expression.\\n\", exclude_pattern);\n\n    exit(EXIT_FAILURE);\n  }\n\n  if (first_word_pattern != NULL\n      && regcomp(&first_word_re, first_word_pattern, REG_EXTENDED | REG_NOSUB)\n           != 0)\n  {\n    fprintf(stderr, \"%s: Bad regular expression.\\n\", first_word_pattern);\n\n    exit(EXIT_FAILURE);\n  }\n\n  if (last_word_pattern != NULL\n      && regcomp(&last_word_re, last_word_pattern, REG_EXTENDED | REG_NOSUB)\n           != 0)\n  {\n    fprintf(stderr, \"%s: Bad regular expression.\\n\", last_word_pattern);\n\n    exit(EXIT_FAILURE);\n  }\n\n  for (index = 0; index < 9; index++)\n  {\n    if (special_pattern[index] != NULL\n        && regcomp(&special_re[index],\n                   special_pattern[index],\n                   REG_EXTENDED | REG_NOSUB)\n             != 0)\n    {\n      fprintf(stderr, \"%s: Bad regular expression.\\n\", special_pattern[index]);\n\n      exit(EXIT_FAILURE);\n    }\n  }\n\n  /* Parse the post-processing patterns and extract its values. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (early_sed_list != NULL)\n  {\n    ll_node_t *node = early_sed_list->head;\n\n    while (node != NULL)\n    {\n      if (!parse_sed_like_string((sed_t *)(node->data)))\n      {\n        fprintf(stderr,\n                \"Bad -ES argument. Must be something like: \"\n                \"/regex/repl_string/[g][v][s][i].\\n\");\n\n        exit(EXIT_FAILURE);\n      }\n\n      node = node->next;\n    }\n  }\n\n  if (sed_list != NULL)\n  {\n    ll_node_t *node = sed_list->head;\n\n    while (node != NULL)\n    {\n      if (!parse_sed_like_string((sed_t *)(node->data)))\n      {\n        fprintf(stderr,\n                \"Bad -S argument. Must be something like: \"\n                \"/regex/repl_string/[g][v][s][i].\\n\");\n\n        exit(EXIT_FAILURE);\n      }\n      if ((!include_visual_only || !exclude_visual_only)\n          && ((sed_t *)(node->data))->visual)\n      {\n        include_visual_only = 1;\n        exclude_visual_only = 1;\n      }\n\n      node = node->next;\n    }\n  }\n\n  if (include_sed_list != NULL)\n  {\n    ll_node_t *node = include_sed_list->head;\n\n    while (node != NULL)\n    {\n      if (!parse_sed_like_string((sed_t *)(node->data)))\n      {\n        fprintf(stderr,\n                \"Bad -I argument. Must be something like: \"\n                \"/regex/repl_string/[g][v][s][i].\\n\");\n\n        exit(EXIT_FAILURE);\n      }\n      if (!include_visual_only && ((sed_t *)(node->data))->visual)\n        include_visual_only = 1;\n\n      node = node->next;\n    }\n  }\n\n  if (exclude_sed_list != NULL)\n  {\n    ll_node_t *node = exclude_sed_list->head;\n\n    while (node != NULL)\n    {\n      if (!parse_sed_like_string((sed_t *)(node->data)))\n      {\n        fprintf(stderr,\n                \"Bad -E argument. Must be something like: \"\n                \"/regex/repl_string/[g][v][s][i].\\n\");\n\n        exit(EXIT_FAILURE);\n      }\n      if (!exclude_visual_only && ((sed_t *)(node->data))->visual)\n        exclude_visual_only = 1;\n\n      node = node->next;\n    }\n  }\n\n  /* Parse the row selection string if any. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (rows_selector_list != NULL)\n  {\n    ll_node_t   *node_selector = rows_selector_list->head;\n    ll_node_t   *node;\n    filters_t    filter_type;\n    attr_elem_t *elem;\n\n    rows_filter_type = UNKNOWN_FILTER;\n    while (node_selector != NULL)\n    {\n      char *unparsed;\n\n      rows_selector = node_selector->data;\n\n      parse_selectors(rows_selector,\n                      &filter_type,\n                      &unparsed,\n                      &inc_row_interval_list,\n                      &inc_row_regex_list,\n                      &exc_row_interval_list,\n                      &exc_row_regex_list,\n                      &al_row_interval_list,\n                      &al_row_regex_list,\n                      &ar_row_interval_list,\n                      &ar_row_regex_list,\n                      &ac_row_interval_list,\n                      &ac_row_regex_list,\n                      &at_row_interval_list,\n                      &at_row_regex_list,\n                      &default_alignment,\n                      &win,\n                      &misc,\n                      &term);\n\n      if (*unparsed != '\\0')\n      {\n        fprintf(stderr,\n                \"Bad or not allowed row selection argument. \"\n                \"Unparsed part: %s\\n\",\n                unparsed);\n\n        exit(EXIT_FAILURE);\n      }\n\n      if (rows_filter_type == UNKNOWN_FILTER)\n        rows_filter_type = filter_type;\n\n      node_selector = node_selector->next;\n\n      free(unparsed);\n    }\n    optimize_an_interval_list(inc_row_interval_list);\n    optimize_an_interval_list(exc_row_interval_list);\n    optimize_an_interval_list(al_row_interval_list);\n    optimize_an_interval_list(ar_row_interval_list);\n    optimize_an_interval_list(ac_row_interval_list);\n\n    if (at_row_interval_list != NULL)\n    {\n      node = at_row_interval_list->head;\n      while (node)\n      {\n        elem = node->data;\n        optimize_an_interval_list(elem->list);\n        node = node->next;\n      }\n    }\n  }\n\n  /* Parse the column selection string if any. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (cols_selector_list != NULL)\n  {\n    filters_t    filter_type, cols_filter_type;\n    interval_t  *data;\n    ll_node_t   *node;\n    ll_node_t   *node_selector = cols_selector_list->head;\n    attr_elem_t *elem;\n\n    cols_filter = xmalloc(limits.cols);\n\n    cols_filter_type = UNKNOWN_FILTER;\n    while (node_selector != NULL)\n    {\n      char *unparsed;\n\n      cols_selector = node_selector->data;\n\n      parse_selectors(cols_selector,\n                      &filter_type,\n                      &unparsed,\n                      &inc_col_interval_list,\n                      &inc_col_regex_list,\n                      &exc_col_interval_list,\n                      &exc_col_regex_list,\n                      &al_col_interval_list,\n                      &al_col_regex_list,\n                      &ar_col_interval_list,\n                      &ar_col_regex_list,\n                      &ac_col_interval_list,\n                      &ac_col_regex_list,\n                      &at_col_interval_list,\n                      &at_col_regex_list,\n                      &default_alignment,\n                      &win,\n                      &misc,\n                      &term);\n\n      if (*unparsed != '\\0')\n      {\n        fprintf(stderr,\n                \"Bad or not allowed column selection argument. \"\n                \"Unparsed part: %s\\n\",\n                unparsed);\n\n        exit(EXIT_FAILURE);\n      }\n\n      optimize_an_interval_list(inc_col_interval_list);\n      optimize_an_interval_list(exc_col_interval_list);\n\n      if (cols_filter_type == UNKNOWN_FILTER)\n        cols_filter_type = filter_type;\n\n      /* Only initialize the whole set when -C is encountered for the */\n      /* first time.                                                  */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (cols_filter_type == INCLUDE_FILTER)\n        memset(cols_filter, SOFT_EXCLUDE_MARK, limits.cols);\n      else\n        memset(cols_filter, SOFT_INCLUDE_MARK, limits.cols);\n\n      /* Process the explicitly included columns intervals. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (inc_col_interval_list != NULL)\n        for (node = inc_col_interval_list->head; node; node = node->next)\n        {\n          data = node->data;\n\n          if (data->low >= limits.cols)\n            break;\n\n          if (data->high >= limits.cols)\n            data->high = limits.cols - 1;\n\n          memset(cols_filter + data->low,\n                 INCLUDE_MARK,\n                 data->high - data->low + 1);\n        }\n\n      /* Process the explicitly excluded column intervals. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (exc_col_interval_list != NULL)\n        for (node = exc_col_interval_list->head; node; node = node->next)\n        {\n          data = node->data;\n\n          if (data->low >= limits.cols)\n            break;\n\n          if (data->high >= limits.cols)\n            data->high = limits.cols - 1;\n\n          memset(cols_filter + data->low,\n                 EXCLUDE_MARK,\n                 data->high - data->low + 1);\n        }\n\n      node_selector = node_selector->next;\n\n      free(unparsed);\n    }\n\n    optimize_an_interval_list(al_col_interval_list);\n    optimize_an_interval_list(ar_col_interval_list);\n    optimize_an_interval_list(ac_col_interval_list);\n\n    if (at_col_interval_list != NULL)\n    {\n      node = at_col_interval_list->head;\n      while (node)\n      {\n        elem = node->data;\n        optimize_an_interval_list(elem->list);\n        node = node->next;\n      }\n    }\n  }\n\n  /* parse the alignment selector list if any. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (aligns_selector_list != NULL)\n  {\n    ll_node_t *node_selector = aligns_selector_list->head;\n\n    while (node_selector != NULL)\n    {\n      char *unparsed;\n\n      aligns_selector = node_selector->data;\n\n      parse_al_selectors(aligns_selector,\n                         &unparsed,\n                         &al_word_regex_list,\n                         &ar_word_regex_list,\n                         &ac_word_regex_list,\n                         &default_alignment,\n                         &misc);\n\n      if (*unparsed != '\\0')\n      {\n        fprintf(stderr,\n                \"Bad alignment selection argument. Unparsed part: %s\\n\",\n                unparsed);\n\n        exit(EXIT_FAILURE);\n      }\n\n      free(unparsed);\n\n      node_selector = node_selector->next;\n    }\n  }\n\n  /* Initialize the useful values needed to walk through */\n  /* the rows intervals.                                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (rows_filter_type == INCLUDE_FILTER)\n    row_def_selectable = SOFT_EXCLUDE_MARK;\n  else if (rows_filter_type == EXCLUDE_FILTER)\n    row_def_selectable = SOFT_INCLUDE_MARK;\n  else\n  {\n    if (pattern_def_include == 0)\n      row_def_selectable = SOFT_EXCLUDE_MARK;\n    else\n      row_def_selectable = SOFT_INCLUDE_MARK;\n  }\n\n  /* Set the head of the interval list. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (inc_row_interval_list)\n    inc_interval_node = inc_row_interval_list->head;\n  else\n    inc_interval_node = NULL;\n\n  if (exc_row_interval_list)\n    exc_interval_node = exc_row_interval_list->head;\n  else\n    exc_interval_node = NULL;\n\n  /* And get the first interval.*/\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (inc_interval_node)\n    inc_interval = (interval_t *)inc_interval_node->data;\n  else\n    inc_interval = NULL;\n\n  if (exc_interval_node)\n    exc_interval = (interval_t *)exc_interval_node->data;\n  else\n    exc_interval = NULL;\n\n  /* First pass:                                                  */\n  /* Get and process the input stream words.                      */\n  /* In this pass, the different actions will occur:              */\n  /* - A new word is read from stdin                              */\n  /* - A new SOL and or EOL is possibly set                       */\n  /* - A special level is possibly affected to the word just read */\n  /* - The -R is taken into account                               */\n  /* - The first part of the -C option is done                    */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while ((word = read_word(input_file,\n                           word_delims_list,\n                           line_delims_list,\n                           zapped_glyphs_list,\n                           utf8_buffer,\n                           &is_last,\n                           &toggles,\n                           &langinfo,\n                           &win,\n                           &limits,\n                           &misc))\n         != NULL)\n  {\n    int           selectable;\n    int           is_first = 0;\n    unsigned char special_level;\n    int           row_inc_matched = 0;\n    ll_node_t    *node;\n\n    if (*word == '\\0')\n      continue;\n\n    /* Early substitution. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (early_sed_list != NULL)\n    {\n      char *tmp;\n\n      node = early_sed_list->head;\n\n      while (node != NULL)\n      {\n        tmp = xstrdup(word);\n        if (replace(word, (sed_t *)(node->data)))\n        {\n\n          free(word);\n          word = xstrdup(word_buffer);\n\n          if (((sed_t *)(node->data))->stop)\n            break;\n        }\n\n        *word_buffer = '\\0';\n        node         = node->next;\n        free(tmp);\n      }\n    }\n\n    if (*word == '\\0')\n      continue;\n\n    /* Manipulates the is_last flag word indicator to make this word      */\n    /* the first or last one of the current line in column/line/tab mode. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (win.col_mode || win.line_mode || win.tab_mode)\n    {\n      if (first_word_pattern != NULL\n          && regexec(&first_word_re, word, (int)0, NULL, 0) == 0)\n        is_first = 1;\n\n      if (last_word_pattern != NULL && !is_last\n          && regexec(&last_word_re, word, (int)0, NULL, 0) == 0)\n        is_last = 1;\n    }\n\n    /* Check if the word is special. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    special_level = 0;\n    for (index = 0; index < 9; index++)\n    {\n      if (special_pattern[index] != NULL\n          && regexec(&special_re[index], word, (int)0, NULL, 0) == 0)\n      {\n        special_level = index + 1;\n        break;\n      }\n    }\n\n    /* Default selectable state. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    selectable = SOFT_INCLUDE_MARK;\n\n    /* For each new line check if the line is in the current   */\n    /* interval or if we need to get the next interval if any .*/\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (rows_selector)\n    {\n      if (count > 0 && word_a[count - 1].is_last)\n      {\n        /* We are in a new line, reset the flag indicating that we are on */\n        /* a line selected by a regular expression  and the flag saying   */\n        /* that the whole line has been excluded.                         */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        line_selected_by_regex = 0;\n        line_excluded          = 0;\n\n        /* And also reset the flag telling that the row has been explicitly */\n        /* removed from the selectable list of words.                       */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        row_inc_matched = 0;\n\n        /* Increment the line counter used to see if we are an include or */\n        /* exclude set of lines.                                          */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        line_count++;\n\n        /* Look if we need to use the next interval of the list. */\n        /* ''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        if (inc_interval_node && line_count > inc_interval->high)\n        {\n          inc_interval_node = inc_interval_node->next;\n          if (inc_interval_node)\n            inc_interval = (interval_t *)inc_interval_node->data;\n        }\n\n        if (exc_interval_node && line_count > exc_interval->high)\n        {\n          exc_interval_node = exc_interval_node->next;\n          if (exc_interval_node)\n            exc_interval = (interval_t *)exc_interval_node->data;\n        }\n      }\n\n      /* Look if the line is in an excluded or included line.             */\n      /* The included line intervals are only checked if the word didn't  */\n      /* belong to an excluded line interval before.                      */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (exc_interval && line_count >= exc_interval->low\n          && line_count <= exc_interval->high)\n        selectable = EXCLUDE_MARK;\n\n      if (selectable != EXCLUDE_MARK && inc_interval\n          && line_count >= inc_interval->low\n          && line_count <= inc_interval->high)\n      {\n        selectable = INCLUDE_MARK;\n\n        /* As the raw has been explicitly selected, record that so than */\n        /* we can distinguish that from the implicit selection.         */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        row_inc_matched = 1;\n      }\n    }\n\n    /* Check if the all the words in the current row must be included or */\n    /* excluded from the selectable set of words.                        */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (selectable != EXCLUDE_MARK)\n    {\n      /* Look in the excluded list of regular expressions. */\n      /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n      if (exc_row_regex_list != NULL)\n      {\n        regex_t *row_re;\n\n        ll_node_t *row_regex_node = exc_row_regex_list->head;\n\n        while (row_regex_node != NULL)\n        {\n          row_re = row_regex_node->data;\n          if (regexec(row_re, word, (int)0, NULL, 0) == 0)\n          {\n            long c = count - 1;\n\n            /* Mark all the next words of the line as excluded. */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''' */\n            line_selected_by_regex = 1;\n            line_excluded          = 1;\n\n            /* Mark all the previous words of the line as excluded. */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''''''' */\n            while (c >= 0 && !word_a[c].is_last)\n            {\n              word_a[c].is_selectable = EXCLUDE_MARK;\n              c--;\n            }\n\n            /* Mark the current word as not excluded. */\n            /* '''''''''''''''''''''''''''''''''''''' */\n            selectable = EXCLUDE_MARK;\n\n            /* No need to continue as the line is already marked as */\n            /* excluded.                                            */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''''''' */\n            break;\n          }\n\n          row_regex_node = row_regex_node->next;\n        }\n      }\n\n      /* If the line has not yet been excluded and the list of explicitly  */\n      /* include regular expressions is not empty then give them a chance. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (selectable != EXCLUDE_MARK && inc_row_regex_list != NULL)\n      {\n        regex_t *row_re;\n\n        ll_node_t *row_regex_node = inc_row_regex_list->head;\n\n        while (row_regex_node != NULL)\n        {\n          row_re = row_regex_node->data;\n          if (regexec(row_re, word, (int)0, NULL, 0) == 0)\n          {\n            long c = count - 1;\n\n            while (c >= 0 && !word_a[c].is_last)\n            {\n              /* Do not include an already excluded word. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (word_a[c].is_selectable)\n                word_a[c].is_selectable = INCLUDE_MARK;\n\n              c--;\n            }\n\n            /* Mark all the next words of the line as included. */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''' */\n            line_selected_by_regex = 1;\n\n            /* Mark all the previous words of the line as included. */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''''''' */\n            selectable = INCLUDE_MARK;\n          }\n\n          row_regex_node = row_regex_node->next;\n        }\n      }\n    }\n\n    /* If the line contains a word that matched a regex which determines */\n    /* the inclusion of exclusion of this line, then use the regex       */\n    /* selection flag to determine the inclusion/exclusion of the future */\n    /* words in the line.                                                */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (line_excluded)\n      selectable = EXCLUDE_MARK;\n    else\n    {\n      if (line_selected_by_regex)\n        selectable = (row_def_selectable == EXCLUDE_MARK) ? SOFT_EXCLUDE_MARK\n                                                          : INCLUDE_MARK;\n\n      /* Check if the current word is matching an include or exclude */\n      /* pattern                                                     */\n      /* Only do it if if hasn't be explicitly deselected before.    */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (selectable != EXCLUDE_MARK)\n      {\n        /* Check if the word will be excluded in the list of selectable */\n        /* words or not.                                                */\n        /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        if (exclude_pattern != NULL\n            && regexec(&exclude_re, word, (int)0, NULL, 0) == 0)\n          selectable = EXCLUDE_MARK;\n\n        if (selectable != 0 && !line_selected_by_regex)\n        {\n          /* Check if the word will be included in the list of selectable */\n          /* words or not.                                                */\n          /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n          if (include_pattern != NULL)\n          {\n            if (regexec(&include_re, word, (int)0, NULL, 0) == 0)\n              selectable = INCLUDE_MARK;\n            else if (!row_inc_matched)\n              selectable = row_def_selectable;\n          }\n          else if (rows_selector && !row_inc_matched)\n            selectable = row_def_selectable;\n        }\n      }\n    }\n\n    if (win.col_mode)\n    {\n      /* In column mode we must manage the allocation space for some       */\n      /* column's related data structures and check if some limits ave not */\n      /* been reached.                                                     */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n      if (is_first)\n        col_index = 1;\n      else\n      {\n        col_index++;\n\n        if (col_index > cols_number)\n        {\n          /* Check the limits. */\n          /* ''''''''''''''''' */\n          if (col_index == limits.cols)\n          {\n            fprintf(stderr,\n                    \"The number of columns has reached the limit of %ld.\\n\",\n                    limits.cols);\n\n            exit(EXIT_FAILURE);\n          }\n\n          cols_number++;\n\n          /* Look if we need to enlarge the arrays indexed by the */\n          /* number of columns.                                   */\n          /* '''''''''''''''''''''''''''''''''''''''''''''''''''' */\n          if (cols_number % COLSCHUNK == 0)\n          {\n            long ci; /* column index */\n\n            col_real_max_size = xrealloc(col_real_max_size,\n                                         (cols_number + COLSCHUNK)\n                                           * sizeof(long));\n\n            col_max_size = xrealloc(col_max_size,\n                                    (cols_number + COLSCHUNK) * sizeof(long));\n\n            /* Initialize the max size for the new columns. */\n            /* '''''''''''''''''''''''''''''''''''''''''''' */\n            for (ci = 0; ci < COLSCHUNK; ci++)\n            {\n              col_real_max_size[cols_number + ci] = 0;\n              col_max_size[cols_number + ci]      = 0;\n            }\n          }\n        }\n      }\n\n      /* We must now check if the word matches a RE that */\n      /* exclude the whole column.                       */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (cols_selector != NULL)\n      {\n        long ci; /* column index. */\n\n        regex_t *col_re;\n\n        if (cols_filter[col_index - 1] == EXCLUDE_MARK)\n          selectable = EXCLUDE_MARK;\n        else\n        {\n          if (exc_col_regex_list != NULL)\n          {\n            /* Some columns must be excluded by regex. */\n            /* ''''''''''''''''''''''''''''''''''''''' */\n            ll_node_t *col_regex_node = exc_col_regex_list->head;\n\n            while (col_regex_node != NULL)\n            {\n              col_re = col_regex_node->data;\n\n              if (regexec(col_re, word, (int)0, NULL, 0) == 0)\n              {\n                cols_filter[col_index - 1] = EXCLUDE_MARK;\n                selectable                 = EXCLUDE_MARK;\n\n                /* Mark non selectable the items above in the column. */\n                /* '''''''''''''''''''''''''''''''''''''''''''''''''' */\n                ci = 0;\n                for (wi = 0; wi < count; wi++)\n                {\n                  if (ci == col_index - 1)\n                    word_a[wi].is_selectable = EXCLUDE_MARK;\n\n                  if (word_a[wi].is_last)\n                    ci = 0;\n                  else\n                    ci++;\n                }\n                break;\n              }\n\n              col_regex_node = col_regex_node->next;\n            }\n          }\n\n          if (inc_col_regex_list != NULL)\n          {\n            /* Some columns must be included by regex. */\n            /* ''''''''''''''''''''''''''''''''''''''' */\n            ll_node_t *col_regex_node = inc_col_regex_list->head;\n\n            while (col_regex_node != NULL)\n            {\n              col_re = col_regex_node->data;\n\n              if (regexec(col_re, word, (int)0, NULL, 0) == 0)\n              {\n                cols_filter[col_index - 1] = INCLUDE_MARK;\n                break;\n              }\n\n              col_regex_node = col_regex_node->next;\n            }\n          }\n        }\n      }\n    }\n\n    /* Initialize the alignment information of each column to be 'left'. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    col_attrs = xmalloc(cols_number * sizeof(attrib_t *));\n    for (long ci = 0; ci < cols_number; ci++)\n      col_attrs[ci] = NULL;\n\n    /* Store some known values in the current word's structure. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    word_a[count].start = word_a[count].end = 0;\n\n    word_a[count].str           = word;\n    word_a[count].is_selectable = selectable;\n\n    word_a[count].special_level = special_level;\n    word_a[count].is_matching   = 0;\n    word_a[count].is_numbered   = 0;\n    word_a[count].tag_order     = 0;\n    word_a[count].tag_id        = 0;\n    word_a[count].iattr         = NULL;\n\n    if (win.col_mode || win.line_mode || win.tab_mode)\n    {\n      /* Set the last word in line indicator when in */\n      /* column/line/tab mode.                       */\n      /* ''''''''''''''''''''''''''''''''''''''''''' */\n      if (is_first && count > 0)\n        word_a[count - 1].is_last = 1;\n      word_a[count].is_last = is_last;\n      if (is_last)\n        col_index = 0;\n    }\n    else\n      word_a[count].is_last = 0;\n\n    /* One more word... */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (count + 1 >= limits.words)\n    {\n      fprintf(stderr,\n              \"The number of read words has reached the limit of %ld.\\n\",\n              limits.words);\n\n      exit(EXIT_FAILURE);\n    }\n\n    count++;\n\n    if (count % WORDSCHUNK == 0)\n      word_a = xrealloc(word_a, (count + WORDSCHUNK) * sizeof(word_t));\n  }\n\n  /* Early exit if there is no input or if no word is selected. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (count == 0)\n    exit(EXIT_FAILURE);\n\n  /* Ignore SIGINT */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n  sigaddset(&sigs, SIGINT);\n  sigprocmask(SIG_BLOCK, &sigs, &oldsigs);\n\n  /* The last word is always the last of its line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.col_mode || win.line_mode || win.tab_mode)\n    word_a[count - 1].is_last = 1;\n\n  /* Second pass to modify  the word according to all/include/exclude       */\n  /* regular expressions and the columns settings set in the previous pass. */\n  /* This must be done separately because in the first  pass, some word     */\n  /* could have been marked as excluded before the currently processed word */\n  /*  (second part of the -C option)                                        */\n  /* In this pass the following actions will also be done:                  */\n  /* - Finish the work on columns.                                          */\n  /* - Possibly modify the word according to -S/-I/-E arguments             */\n  /* - Replace unprintable characters in the word by mnemonics              */\n  /* - Remember the max size of the words/columns/tabs                      */\n  /* - Insert the word in a TST (Ternary Search Tree) index to facilitate   */\n  /*   word search (each node pf the TST will contain an UTF-8 glyph).      */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  col_index = 0;\n  for (wi = 0; wi < count; wi++)\n  {\n    char    *unaltered_word;\n    long     size;\n    long     word_len;\n    wchar_t *tmpw;\n    word_t  *word;\n    long     s;\n    long     len;\n    char    *expanded_word;\n    long     i;\n\n    /* If the column section argument is set, then adjust the final        */\n    /* selectable attribute  according to the already set words and column */\n    /* selectable flag contents.                                           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (cols_selector_list != NULL)\n    {\n      if (cols_filter[col_index] == EXCLUDE_MARK)\n        word_a[wi].is_selectable = EXCLUDE_MARK;\n      else if (word_a[wi].is_selectable != EXCLUDE_MARK)\n      {\n        switch (cols_filter[col_index])\n        {\n          case INCLUDE_MARK:\n            word_a[wi].is_selectable = INCLUDE_MARK;\n            break;\n\n          case SOFT_EXCLUDE_MARK:\n            if (word_a[wi].is_selectable == SOFT_EXCLUDE_MARK\n                || word_a[wi].is_selectable == SOFT_INCLUDE_MARK)\n              word_a[wi].is_selectable = EXCLUDE_MARK;\n            else\n              word_a[wi].is_selectable = INCLUDE_MARK;\n            break;\n\n          case SOFT_INCLUDE_MARK:\n            if (word_a[wi].is_selectable == SOFT_EXCLUDE_MARK)\n              word_a[wi].is_selectable = EXCLUDE_MARK;\n            else\n              word_a[wi].is_selectable = INCLUDE_MARK;\n            break;\n        }\n      }\n    }\n\n    word = &word_a[wi];\n\n    /* Make sure that daccess.length >= daccess.size */\n    /* with DA_TYPE_POS.                             */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (daccess.mode != DA_TYPE_NONE)\n    {\n      if ((daccess.mode & DA_TYPE_POS) && daccess.size > 0\n          && daccess.size > daccess.length)\n        daccess.length = daccess.size;\n\n      /* Auto determination of the length of the selector */\n      /* with DA_TYPE_AUTO.                               */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if ((daccess.mode & DA_TYPE_AUTO) && daccess.length == -2)\n      {\n        long n = count + daccess_index - 1;\n\n        daccess.length = 0;\n\n        while (n)\n        {\n          n /= 10;\n          daccess.length++;\n        }\n      }\n\n      /* Set the full length of the prefix in case of numbering. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (daccess.length > 0)\n        daccess.flength = 3 + daccess.length;\n\n      if (word->is_selectable != EXCLUDE_MARK\n          && word->is_selectable != SOFT_EXCLUDE_MARK)\n      {\n        char *selector;\n        char *tmp;\n        long *word_pos = xmalloc(sizeof(long));\n        int   may_number;\n        long  wlen;\n\n        wlen = strlen(word->str) + 4 + daccess.length;\n        tmp  = xmalloc(wlen);\n\n        if (!my_isempty((unsigned char *)word->str))\n        {\n          *word_pos = wi;\n\n          tmp[0] = ' ';\n\n          /* Check if the word is eligible to the numbering process. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (daccess_up == NULL && daccess_np == NULL)\n          {\n            if (daccess.mode & DA_TYPE_POS)\n              may_number = 1;\n            else\n              may_number = 0;\n          }\n          else\n          {\n            if (daccess_up != NULL\n                && !!regexec(&daccess_up_re, word->str, (int)0, NULL, 0) == 0)\n              may_number = 0;\n            else\n            {\n              if (daccess_np != NULL\n                  && !!regexec(&daccess_np_re, word->str, (int)0, NULL, 0) == 0)\n                may_number = 1;\n              else\n                may_number = daccess.def_number;\n            }\n          }\n\n          /* It is... */\n          /* \"\"\"\"\"\"\"\" */\n          if (may_number)\n          {\n            if ((daccess.mode & DA_TYPE_POS) && !word->is_numbered\n                && daccess.size > 0\n                && (daccess.offset + daccess.size + daccess.ignore)\n                     <= utf8_strlen(word->str))\n            {\n              long  selector_value;  /* numerical value of the         *\n                                         | extracted selector.            */\n              long  selector_offset; /* offset in byte to the selector *\n                                         | to extract.                    */\n              char *ptr;             /* points just after the selector *\n                                         | to extract.                    */\n              long  plus_offset;     /* points to the first occurrence *\n                                         | of a number in word->str after *\n                                         | the offset given.              */\n\n              selector_offset = utf8_offset(word->str, daccess.offset);\n\n              if (daccess.plus)\n              {\n                plus_offset = strcspn(word->str + selector_offset,\n                                      \"0123456789\");\n\n                if (plus_offset + daccess.size + daccess.ignore\n                    <= strlen(word->str))\n                  selector_offset += plus_offset;\n              }\n\n              ptr      = word->str + selector_offset;\n              selector = xstrndup(ptr, daccess.size);\n\n              /* read the embedded number and, if correct, format */\n              /* it according to daccess.alignment.               */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (sscanf(selector, \"%ld\", &selector_value) == 1)\n              {\n                snprintf(selector, daccess.size + 1, \"%ld\", selector_value);\n\n                snprintf(tmp + 1,\n                         wlen,\n                         \"%*ld\",\n                         daccess.alignment == 'l' ? -daccess.length\n                                                  : daccess.length,\n                         selector_value);\n\n                /* Overwrite the end of the word to erase */\n                /* the selector.                          */\n                /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                my_strcpy(ptr,\n                          ptr + daccess.size\n                            + utf8_offset(ptr + daccess.size, daccess.ignore));\n\n                /* Modify the word according to the 'h' directive */\n                /* of -D.                                         */\n                /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                if (daccess.head == 'c')\n                  /* h:c is present cut the leading characters */\n                  /* before the selector.                      */\n                  /* ''''''''''''''''''''''''''''''''''''''''' */\n                  memmove(word->str, ptr, strlen(ptr) + 1);\n                else if (daccess.head == 't')\n                {\n                  /* h:t is present trim the leading characters   */\n                  /* before the selector if they are ' ' or '\\t'. */\n                  /* '''''''''''''''''''''''''''''''''''''''''''' */\n                  char *p = word->str;\n\n                  while (p != ptr && (*p == ' ' || *p == '\\t'))\n                    p++;\n\n                  if (p == ptr)\n                    memmove(word->str, ptr, strlen(ptr) + 1);\n                }\n\n                ltrim(selector, \" \");\n                rtrim(selector, \" \", 0);\n\n                tst_daccess = tst_insert(tst_daccess,\n                                         utf8_strtowcs(selector),\n                                         word_pos);\n\n                if (daccess.follow == 'y')\n                  daccess_index = selector_value + 1;\n\n                word->is_numbered = 1;\n              }\n              free(selector);\n            }\n\n            /* Try to number this word if it is still non numbered and */\n            /* the -N/-U option is given.                              */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (!word->is_numbered && (daccess.mode & DA_TYPE_AUTO))\n            {\n              snprintf(tmp + 1,\n                       wlen,\n                       \"%*ld\",\n                       daccess.alignment == 'l' ? -daccess.length\n                                                : daccess.length,\n                       daccess_index);\n\n              selector = xstrdup(tmp + 1);\n              ltrim(selector, \" \");\n              rtrim(selector, \" \", 0);\n\n              /* Insert it in the tst tree containing the selector's */\n              /* digits.                                             */\n              /* ''''''''''''''''''''''''''''''''''''''''''''''''''' */\n              tst_daccess = tst_insert(tst_daccess,\n                                       utf8_strtowcs(selector),\n                                       word_pos);\n              daccess_index++;\n\n              free(selector);\n\n              word->is_numbered = 1;\n            }\n          }\n\n          /* Fill the space taken by the numbering by space if the word */\n          /* is not numbered.                                           */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (daccess.length > 0 && !word->is_numbered)\n          {\n            for (i = 0; i < daccess.flength; i++)\n              tmp[i] = ' ';\n          }\n\n          /* Make sure that the 2 character after this placeholder */\n          /* are initialized.                                      */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (daccess.length > 0)\n          {\n            tmp[1 + daccess.length] = ' ';\n            tmp[2 + daccess.length] = ' ';\n          }\n        }\n        else if (daccess.length > 0)\n        {\n          /* Make sure that the prefix of empty word is blank */\n          /* as they may be display in column mode.           */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          for (i = 0; i < daccess.flength; i++)\n            tmp[i] = ' ';\n        }\n\n        if (daccess.length > 0)\n        {\n          my_strcpy(tmp + daccess.flength, word->str);\n          free(word->str);\n          word->str = tmp;\n        }\n        else\n          free(tmp);\n      }\n      else\n      {\n        /* Should we also add space at the beginning of excluded words? */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (daccess.padding == 'a')\n        {\n          char *tmp = xmalloc(strlen(word->str) + 4 + daccess.length);\n          for (i = 0; i < daccess.flength; i++)\n            tmp[i] = ' ';\n          my_strcpy(tmp + daccess.flength, word->str);\n          free(word->str);\n          word->str = tmp;\n        }\n      }\n    }\n    else\n    {\n      daccess.size   = 0;\n      daccess.length = 0;\n    }\n\n    /* Save the original word. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    unaltered_word = xstrdup(word->str);\n\n    /* Possibly modify the word according to -S/-I/-E arguments. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    {\n      ll_node_t *node = NULL;\n      char      *tmp;\n\n      /* Manage the -S case. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (sed_list != NULL)\n      {\n        node = sed_list->head;\n\n        while (node != NULL)\n        {\n          tmp = xstrndup(word->str, daccess.flength);\n          if (replace(word->str + daccess.flength, (sed_t *)(node->data)))\n          {\n\n            free(word->str);\n            memmove(word_buffer + daccess.flength,\n                    word_buffer,\n                    strlen(word_buffer) + 1);\n            memmove(word_buffer, tmp, daccess.flength);\n\n            word->str = xstrdup(word_buffer);\n\n            if (((sed_t *)(node->data))->stop)\n              break;\n          }\n\n          *word_buffer = '\\0';\n          node         = node->next;\n          free(tmp);\n        }\n      }\n      else\n      {\n        /* Manage the -I/-E case. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if ((word->is_selectable == INCLUDE_MARK\n             || word->is_selectable == SOFT_INCLUDE_MARK)\n            && include_sed_list != NULL)\n          node = include_sed_list->head;\n        else if ((word->is_selectable == EXCLUDE_MARK\n                  || word->is_selectable == SOFT_EXCLUDE_MARK)\n                 && exclude_sed_list != NULL)\n          node = exclude_sed_list->head;\n        else\n          node = NULL;\n\n        *word_buffer = '\\0';\n\n        while (node != NULL)\n        {\n          tmp = xstrndup(word->str, daccess.flength);\n          if (replace(word->str + daccess.flength, (sed_t *)(node->data)))\n          {\n\n            free(word->str);\n            memmove(word_buffer + daccess.flength,\n                    word_buffer,\n                    strlen(word_buffer) + 1);\n            memmove(word_buffer, tmp, daccess.flength);\n\n            word->str = xstrdup(word_buffer);\n\n            if (((sed_t *)(node->data))->stop)\n              break;\n          }\n          *word_buffer = '\\0';\n          node         = node->next;\n          free(tmp);\n        }\n      }\n    }\n\n    /* A substitution leading to an empty word is invalid in column mode. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (win.col_mode)\n    {\n      long len;\n\n      if (daccess.padding == 'a')\n        len = daccess.flength;\n      else\n        len = 0;\n\n      if (*(word->str + len) == '\\0')\n        exit(EXIT_FAILURE);\n    }\n\n    /* Alter the word just read be replacing special chars  by their */\n    /* escaped equivalents.                                          */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    word_len = strlen(word->str);\n\n    expanded_word = xmalloc(5 * word_len + 1);\n    len = expand(word->str, expanded_word, &langinfo, &toggles, &misc);\n\n    /* Update it if needed. */\n    /* '''''''''''''''''''' */\n    if (strcmp(expanded_word, word->str) != 0)\n    {\n      word_len = len;\n      free(word->str);\n      word->str = xstrdup(expanded_word);\n    }\n\n    free(expanded_word);\n\n    if (win.col_mode)\n    {\n      /* Update the max values of col_real_max_size[col_index] */\n      /* and col_max_size[col_index].                          */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if ((s = (long)word_len) > col_real_max_size[col_index])\n      {\n        col_real_max_size[col_index] = s;\n\n        /* Also update the real max size of all columns seen. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (s > cols_real_max_size)\n          cols_real_max_size = s;\n      }\n\n      s = (long)mbstowcs(NULL, word->str, 0);\n      s = my_wcswidth((tmpw = utf8_strtowcs(word->str)), s);\n      free(tmpw);\n\n      if (s > col_max_size[col_index])\n      {\n        col_max_size[col_index] = s;\n\n        /* Also update the max size of all columns seen. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (s > cols_max_size)\n          cols_max_size = s;\n      }\n      /* Update the size of the longest expanded word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      word_real_max_size = cols_real_max_size + 1;\n    }\n    else if (win.tab_mode)\n    {\n      /* Store the new max number of bytes in a word       */\n      /* and update the size of the longest expanded word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if ((long)word_len > tab_real_max_size)\n        word_real_max_size = tab_real_max_size = (long)word_len;\n\n      /* Store the new max word width. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      size = (long)mbstowcs(NULL, word->str, 0);\n\n      if ((size = my_wcswidth((tmpw = utf8_strtowcs(word->str)), size))\n          > tab_max_size)\n        tab_max_size = size;\n\n      free(tmpw);\n    }\n    else if (word_real_max_size < word_len)\n      /* Update the size of the longest expanded word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      word_real_max_size = word_len;\n\n    /* When the visual only flag is set, we keep the unaltered word so */\n    /* that it can be restored even if its visual and searchable       */\n    /* representation may have been altered by the previous code.      */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n    /* Record the length of the word in bytes. This information will be */\n    /* used if the -k option (keep spaces ) is not set.                 */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    word->len = strlen(word->str);\n\n    /* Save the non modified word in .orig if it has been altered. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((strcmp(word->str, unaltered_word) != 0)\n        && ((word->is_selectable && include_visual_only)\n            || (!word->is_selectable && exclude_visual_only)))\n    {\n      word->orig = unaltered_word;\n    }\n    else\n    {\n      word->orig = NULL;\n      free(unaltered_word);\n    }\n\n    if (win.col_mode)\n    {\n      if (word_a[wi].is_last)\n        col_index = 0;\n      else\n        col_index++;\n    }\n  }\n\n  /* Set the minimum width of a column (-w and -t or -c option). */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.wide)\n  {\n    if (win.tab_mode)\n    {\n      if (win.max_cols > 0)\n        min_size = (term.ncolumns - 2) / win.max_cols - 1;\n\n      if (min_size < tab_max_size)\n        min_size = tab_max_size;\n\n      word_real_max_size = min_size + tab_real_max_size - tab_max_size;\n    }\n    else /* Column mode. */\n    {\n      min_size = (term.ncolumns - 2) / cols_number;\n      if (min_size < cols_max_size)\n        min_size = cols_max_size;\n\n      word_real_max_size = cols_real_max_size;\n    }\n  }\n\n  /* Third (compress) pass: remove all empty word and words containing */\n  /* only spaces when not in column mode.                              */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!win.col_mode)\n  {\n    long offset;\n\n    offset = 0;\n    for (wi = 0; wi < count - offset; wi++)\n    {\n      long len;\n\n      while (wi + offset < count)\n      {\n        if (daccess.padding == 'a' || word_a[wi + offset].is_numbered)\n          len = daccess.flength;\n        else\n          len = 0;\n\n        if (!my_isempty((unsigned char *)(word_a[wi + offset].str + len)))\n          break;\n\n        /* Keep non selectable empty words to allow special effects. */\n        /* ''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n        if (word_a[wi + offset].is_selectable == SOFT_EXCLUDE_MARK\n            || word_a[wi + offset].is_selectable == EXCLUDE_MARK)\n          break;\n\n        offset++;\n      }\n\n      if (offset > 0)\n        word_a[wi] = word_a[wi + offset];\n    }\n    count -= offset;\n  }\n\n  if (count == 0)\n    exit(EXIT_FAILURE);\n\n  /* Allocate the space for the satellites arrays. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  line_nb_of_word_a     = xmalloc(count * sizeof(long));\n  first_word_in_line_a  = xmalloc(count * sizeof(long));\n  shift_right_sym_pos_a = xmalloc(count * sizeof(long));\n\n  /* Fourth pass:                                                         */\n  /* When in column or tabulating mode, we need to adjust the length of   */\n  /* all the words by adding the right number of spaces so that they will */\n  /* be aligned correctly. In column mode the size of each column is      */\n  /* variable; in tabulate mode it is constant.                           */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.col_mode)\n  {\n    char *temp;\n\n    /* Sets all columns to the same size when -w and -c are both set. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (win.wide)\n      for (col_index = 0; col_index < cols_number; col_index++)\n      {\n        col_max_size[col_index]      = cols_max_size;\n        col_real_max_size[col_index] = cols_real_max_size;\n      }\n\n    /* Total space taken by all the columns plus the gutter. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    win.max_width      = 0;\n    win.real_max_width = 0;\n    for (col_index = 0; col_index < cols_number; col_index++)\n    {\n      if (win.max_width + col_max_size[col_index] + 1 <= term.ncolumns - 2)\n        win.max_width += col_max_size[col_index] + 1;\n\n      win.real_max_width += col_max_size[col_index] + 1;\n    }\n\n    col_index = 0;\n    for (wi = 0; wi < count; wi++)\n    {\n      long        s1, s2;\n      long        word_width;\n      wchar_t    *w;\n      regex_t     re;\n      ll_node_t  *node;\n      interval_t *interval;\n\n      /* Does this word matched by one of the alignment regex?         */\n      /* If yes, then add the current column number to the list of the */\n      /* corresponding column_alignment list                           */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ll_t  *regex_list_a[3]    = { al_col_regex_list,\n                                    ar_col_regex_list,\n                                    ac_col_regex_list };\n      ll_t **interval_list_a[3] = { &al_col_interval_list,\n                                    &ar_col_interval_list,\n                                    &ac_col_interval_list };\n\n      for (int i = 0; i < 3; i++) /* For each regex list. */\n      {\n        if (regex_list_a[i] == NULL)\n          continue;\n\n        node = regex_list_a[i]->head;\n        while (node) /* For each RE in the list. */\n        {\n          re = *(regex_t *)(node->data);\n          if (regexec(&re, word_a[wi].str + daccess.flength, (int)0, NULL, 0)\n              == 0)\n          {\n            int already_aligned = 0;\n\n            /* We have a match. */\n            /* '''''''''''''''' */\n            interval      = xmalloc(sizeof(interval_t));\n            interval->low = interval->high = col_index;\n\n            /* Look if the column has already been inserted in another */\n            /* interval list.                                          */\n            /* ''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n            for (int j = 0; j < 3; j++)\n            {\n              interval_t inter;\n              ll_node_t *n;\n\n              /* Quick continuation. */\n              /* ''''''''''''''''''' */\n              if (i == j || *interval_list_a[j] == NULL)\n                continue;\n\n              n = (*interval_list_a[j])->head;\n              while (n)\n              {\n                inter = *(interval_t *)(n->data);\n                if (col_index >= inter.low && col_index <= inter.high)\n                {\n                  already_aligned = 1; /* This column is already aligned. */\n                  break;\n                }\n                n = n->next;\n              }\n            }\n\n            if (!already_aligned)\n            {\n              /* Append a new interval containing the current column number */\n              /* in the interval list matching the regex list.              */\n              /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n              if (*interval_list_a[i] == NULL)\n                *interval_list_a[i] = ll_new();\n\n              ll_append(*interval_list_a[i], interval);\n            }\n          }\n          node = node->next;\n        }\n      }\n\n      /* Process regex based attributes and fill the attribute columns */\n      /* list accordingly.                                             */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (at_col_regex_list != NULL)\n      {\n        attrib_t    *attr;\n        attr_elem_t *elem;\n        ll_node_t   *regex_node;\n        ll_node_t   *interval_node;\n\n        node = at_col_regex_list->head;\n        while (node)\n        {\n          elem = node->data;\n          attr = elem->attr;\n\n          regex_node = elem->list->head;\n          while (regex_node)\n          {\n            re = *(regex_t *)(regex_node->data);\n            if (regexec(&re, word_a[wi].str + daccess.flength, (int)0, NULL, 0)\n                == 0)\n            {\n              /* We have a match. */\n              /* '''''''''''''''' */\n              attr_elem_t *new_elem;\n\n              if (col_attrs[col_index] != NULL)\n                break;\n\n              new_elem       = xmalloc(sizeof(attr_elem_t));\n              new_elem->attr = attr;\n\n              interval      = xmalloc(sizeof(interval_t));\n              interval->low = interval->high = col_index;\n\n              col_attrs[col_index] = attr;\n\n              if (at_col_interval_list == NULL)\n                at_col_interval_list = ll_new();\n\n              if ((interval_node = ll_find(at_col_interval_list,\n                                           elem,\n                                           attr_elem_cmp))\n                  != NULL)\n              {\n                ll_append(((attr_elem_t *)(interval_node->data))->list,\n                          interval);\n              }\n              else\n              {\n                new_elem->list = ll_new();\n                ll_append(new_elem->list, interval);\n                ll_append(at_col_interval_list, new_elem);\n              }\n            }\n            regex_node = regex_node->next;\n          }\n          node = node->next;\n        }\n      }\n\n      s1         = (long)strlen(word_a[wi].str);\n      word_width = mbstowcs(NULL, word_a[wi].str, 0);\n      s2         = my_wcswidth((w = utf8_strtowcs(word_a[wi].str)), word_width);\n      free(w);\n\n      /* Use the al_delim (0x05) character as a placeholder to preserve  */\n      /* the internal spaces of the word if there are any.               */\n      /* This value has been chosen because it cannot be part of a UTF-8 */\n      /* sequence and is very unlikely to be part of a normal word from  */\n      /* the input stream.                                               */\n      /* This placeholder will be removed during the alignment phase.    */\n      /*\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      temp = xcalloc(1, col_real_max_size[col_index] + s1 - s2 + 1);\n      memset(temp, al_delim, col_max_size[col_index] + s1 - s2);\n      memcpy(temp, word_a[wi].str, s1);\n      temp[col_real_max_size[col_index] + s1 - s2] = '\\0';\n      free(word_a[wi].str);\n      word_a[wi].str = temp;\n\n      if (word_a[wi].is_last)\n        col_index = 0;\n      else\n        col_index++;\n    }\n    optimize_an_interval_list(al_col_interval_list);\n    optimize_an_interval_list(ar_col_interval_list);\n    optimize_an_interval_list(ac_col_interval_list);\n  }\n  else if (win.tab_mode)\n  {\n    char *temp;\n\n    if (tab_max_size < min_size)\n    {\n      tab_max_size = min_size;\n      if (tab_max_size > tab_real_max_size)\n        tab_real_max_size = tab_max_size;\n    }\n\n    for (wi = 0; wi < count; wi++)\n    {\n      long     s1, s2;\n      long     word_width;\n      wchar_t *w;\n\n      s1         = (long)strlen(word_a[wi].str);\n      word_width = mbstowcs(NULL, word_a[wi].str, 0);\n      s2         = my_wcswidth((w = utf8_strtowcs(word_a[wi].str)), word_width);\n      free(w);\n      temp = xcalloc(1, tab_real_max_size + s1 - s2 + 1);\n      memset(temp, ' ', tab_max_size + s1 - s2);\n      memcpy(temp, word_a[wi].str, s1);\n      temp[tab_real_max_size + s1 - s2] = '\\0';\n      free(word_a[wi].str);\n      word_a[wi].str = temp;\n    }\n  }\n\n  /* Fifth pass: transforms the remaining SOFT_EXCLUDE_MARKs with */\n  /* EXCLUDE_MARKs.                                               */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  for (wi = 0; wi < count; wi++)\n  {\n    long    *data;\n    wchar_t *w;\n    ll_t    *list;\n\n    if (word_a[wi].is_selectable == SOFT_EXCLUDE_MARK)\n      word_a[wi].is_selectable = EXCLUDE_MARK;\n\n    /* If the word is selectable insert it in the TST tree */\n    /* with its associated index in the input stream.      */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (word_a[wi].is_selectable)\n    {\n      data  = xmalloc(sizeof(long));\n      *data = wi;\n\n      /* Create a wide characters string from the word screen */\n      /* representation to be able to store in in the TST.    */\n      /* Note that the direct access selector,if any, is not  */\n      /* stored.                                              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (word_a[wi].is_numbered)\n        w = utf8_strtowcs(word_a[wi].str + daccess.flength);\n      else\n        w = utf8_strtowcs(word_a[wi].str);\n\n      /* If we didn't already encounter this word, then create a new */\n      /* entry in the TST for it and store its index in its list.    */\n      /* Otherwise, add its index in its index list.                 */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (tst_word && (list = tst_search(tst_word, w)) != NULL)\n        ll_append(list, data);\n      else\n      {\n        list = ll_new();\n        ll_append(list, data);\n        tst_word = tst_insert(tst_word, w, list);\n      }\n      free(w);\n    }\n  }\n\n  /* Sixth pass: Apply alignment rules in column modes.                    */\n  /* The column alignments, based on regular expressions, have already     */\n  /* been processed in the fourth pass which converted this information    */\n  /* by adding new ranges to the three lists of column ranges.             */\n  /*                                                                       */\n  /* It remains to interpret these lists of column intervals and the lists */\n  /* of intervals and regular expressions for the rows.                    */\n  /*                                                                       */\n  /* To do this, a working table (aligned_a) is created and reset for      */\n  /* each row to store the statistics of alignments already processed,     */\n  /* taking into account the previous result and the order in which the    */\n  /* row and column alignment requests were made.                          */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.col_mode)\n  {\n    long       row_index = 0;\n    interval_t interval;\n\n    alignment_t alignment;      /* Future value of the word alignment. */\n    alignment_t word_alignment; /* Specific word alignment.            */\n    alignment_t row_alignment;  /* current row word alignments.        */\n\n    char *str, *tstr;\n\n    col_index = 0;\n\n    ll_node_t *cur_word_node_a[3];\n\n    ll_t *col_interval_list_a[3] = { al_col_interval_list,\n                                     ar_col_interval_list,\n                                     ac_col_interval_list };\n\n    ll_node_t *cur_col_node_a[3] = {\n      al_col_interval_list != NULL ? al_col_interval_list->head : NULL,\n      ar_col_interval_list != NULL ? ar_col_interval_list->head : NULL,\n      ac_col_interval_list != NULL ? ac_col_interval_list->head : NULL\n    };\n\n    ll_node_t *cur_row_interval_node_a[3] = {\n      al_row_interval_list != NULL ? al_row_interval_list->head : NULL,\n      ar_row_interval_list != NULL ? ar_row_interval_list->head : NULL,\n      ac_row_interval_list != NULL ? ac_row_interval_list->head : NULL\n    };\n\n    ll_node_t *cur_row_regex_node_a[3];\n\n    alignment_t const alignment_a[3] = { AL_LEFT, AL_RIGHT, AL_CENTERED };\n\n    char *aligned_a; /* Array of indicators used to remember that a word *\n                      | has been aligned with -al in a row.              */\n\n    /* Initialize each chars of aligned_a with No ('N'). */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    aligned_a = xmalloc(cols_number);\n\n    for (int i = 0; i < cols_number; i++)\n      aligned_a[i] = 'N';\n\n    row_alignment = AL_NONE;\n\n    for (wi = 0; wi < count; wi++)\n    {\n      word_alignment = AL_NONE;\n\n      if (row_alignment != AL_NONE)\n        alignment = row_alignment;\n      else\n        alignment = default_alignment;\n\n      str  = xstrdup(word_a[wi].str + daccess.flength);\n      tstr = xstrdup(str);\n\n      rtrim(tstr, \"\\x05\", 0);\n      ltrim(tstr, \"\\x05\");\n\n      /* First check if the current word is matched by a word specified */\n      /* regular expression set by the * alignment option.              */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n      cur_word_node_a[0] = al_word_regex_list != NULL ? al_word_regex_list->head\n                                                      : NULL;\n\n      cur_word_node_a[1] = ar_word_regex_list != NULL ? ar_word_regex_list->head\n                                                      : NULL;\n\n      cur_word_node_a[2] = ac_word_regex_list != NULL ? ac_word_regex_list->head\n                                                      : NULL;\n\n      cur_row_regex_node_a[0] = al_row_regex_list != NULL\n                                  ? al_row_regex_list->head\n                                  : NULL;\n\n      cur_row_regex_node_a[1] = ar_row_regex_list != NULL\n                                  ? ar_row_regex_list->head\n                                  : NULL;\n\n      cur_row_regex_node_a[2] = ac_row_regex_list != NULL\n                                  ? ac_row_regex_list->head\n                                  : NULL;\n\n      /* Process the word alignment regex lists. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      for (int i = 0; i < 3; i++)\n      {\n        while (word_alignment == AL_NONE && cur_word_node_a[i] != NULL)\n        {\n          regex_t *re;\n\n          re = (regex_t *)(cur_word_node_a[i]->data);\n\n          if (regexec(re, tstr, (int)0, NULL, 0) == 0)\n          {\n            word_alignment = alignment_a[i];\n\n            /* Mark this word as aligned in this row. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            aligned_a[col_index] = 'Y';\n\n            break; /* Early exit of the while loop. */\n          }\n\n          cur_word_node_a[i] = cur_word_node_a[i]->next;\n        }\n      }\n\n      /* Process the alignment lists for columns and increment     */\n      /* their current pointers when needed.                       */\n      /* The current interval pointer cur_col_node_a[i] is only    */\n      /* modified to point to the next one of the list is the      */\n      /* current column is greater than the  max column in the     */\n      /* pointed interval.                                         */\n      /* An already aligned column will not be realigned.          */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      for (int i = 0; i < 3; i++)\n      {\n        if (cur_col_node_a[i] != NULL)\n        {\n          interval = *(interval_t *)(cur_col_node_a[i]->data);\n          if (aligned_a[col_index] == 'N' && col_index >= interval.low\n              && col_index <= interval.high)\n          {\n            /* Tell that the word is already aligned when column */\n            /* alignments have precedence over row alignments.   */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (toggles.cols_first)\n              aligned_a[col_index] = 'Y';\n\n            alignment = alignment_a[i];\n          }\n          else if (col_index > interval.high)\n            cur_col_node_a[i] = cur_col_node_a[i]->next;\n        }\n        if (word_a[wi].is_last && col_interval_list_a[i] != NULL)\n          cur_col_node_a[i] = col_interval_list_a[i]->head;\n      }\n\n      /* Process row interval and regex alignment lists. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      for (int i = 0; i < 3; i++)\n      {\n        /* Lists of intervals. */\n        /* ''''''''''''''''''' */\n        if (cur_row_interval_node_a[i] != NULL)\n        {\n          interval = *(interval_t *)(cur_row_interval_node_a[i]->data);\n          if (row_alignment == AL_NONE && row_index >= interval.low\n              && row_index <= interval.high)\n          {\n            row_alignment = alignment_a[i];\n            if (aligned_a[col_index] == 'N')\n              alignment = alignment_a[i];\n          }\n          else if (row_index > interval.high)\n            cur_row_interval_node_a[i] = cur_row_interval_node_a[i]->next;\n        }\n\n        /* Lists of regular expression. */\n        /* '''''''''''''''''''''''''''' */\n        if (cur_row_regex_node_a[i] != NULL)\n        {\n          while (cur_row_regex_node_a[i] != NULL)\n          {\n            regex_t *re;\n\n            re = (regex_t *)(cur_row_regex_node_a[i]->data);\n\n            if (row_alignment == AL_NONE\n                && regexec(re, tstr, (int)0, NULL, 0) == 0)\n            {\n              row_alignment = alignment_a[i];\n              if (aligned_a[col_index] == 'N')\n                alignment = alignment_a[i];\n\n              /* Also aligns the previous words in the line to the */\n              /* right, left or centre.                            */\n              /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n              long j = wi;\n              while (j > 0 && !word_a[j - 1].is_last)\n              {\n                j--;\n\n                /* Do not realign words already aligned with -al */\n                /* of if already aligned using a column RE when  */\n                /* column alignments have precedence.            */\n                /* ''''''''''''''''''''''''''''''''''''''''''''' */\n                if (aligned_a[col_index - (wi - j)] == 'N')\n                  align_word(&word_a[j],\n                             alignment_a[i],\n                             daccess.flength,\n                             al_delim);\n              }\n\n              break; /* Early exit of the while loop. */\n            }\n            else if (toggles.rows_first && row_alignment != AL_NONE)\n              alignment = row_alignment;\n\n            cur_row_regex_node_a[i] = cur_row_regex_node_a[i]->next;\n          }\n        }\n      }\n\n      /* Force a word alignment if it is set for this word. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (word_alignment != AL_NONE)\n        alignment = word_alignment;\n\n      /* Do the alignment. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      align_word(&word_a[wi], alignment, daccess.flength, al_delim);\n\n      /* Adjusts things before a row change. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (word_a[wi].is_last || wi == count - 1) /* About to start a new row? */\n      {\n        row_index++;\n\n        /* Re-initialize the array with No ('N'). */\n        /* as this is a new row.                  */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        for (int i = 0; i < cols_number; i++)\n        {\n          aligned_a[i] = 'N';\n\n          /* We can restore the spaces which are not part of the word */\n          /* now that the row is fully processed.                     */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (wi - i >= 0)\n            strrep(word_a[wi - i].str + daccess.flength, al_delim, ' ');\n        }\n\n        col_index     = 0; /* Restart the columns counter. */\n        row_alignment = AL_NONE;\n      }\n      else\n        col_index++;\n\n      free(str);\n      free(tstr);\n    }\n  }\n\n  /* Seventh pass: sets default attributes. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.col_mode)\n  {\n    if (at_row_interval_list != NULL || at_col_interval_list != NULL\n        || at_row_regex_list != NULL || at_col_regex_list != NULL)\n    {\n      long         row_index = 0;\n      interval_t  *interval;\n      attrib_t    *attr;\n      ll_t        *list;\n      attr_elem_t *attr_elem;\n      ll_node_t   *attr_elem_node;\n      ll_node_t   *node;\n      regex_t      re;\n\n      col_index = 0;\n\n      for (wi = 0; wi < count; wi++)\n      {\n        if (word_a[wi].iattr != NULL)\n          continue;\n\n        if (at_row_interval_list != NULL)\n        {\n          attr_elem_node = at_row_interval_list->head;\n          while (attr_elem_node != NULL)\n          {\n            attr_elem = attr_elem_node->data;\n            attr      = attr_elem->attr;\n            list      = attr_elem->list; /* Cannot be null by construction. */\n            node      = list->head;\n\n            while (node)\n            {\n              interval = node->data;\n              if (row_index >= interval->low && row_index <= interval->high)\n              {\n                word_a[wi].iattr = attr;\n                goto early_row_exit;\n              }\n              node = node->next;\n            }\n            attr_elem_node = attr_elem_node->next;\n          }\n        }\n      early_row_exit:\n\n        if (at_col_interval_list != NULL)\n        {\n          attr_elem_node = at_col_interval_list->head;\n          while (attr_elem_node != NULL)\n          {\n            attr_elem = attr_elem_node->data;\n            attr      = attr_elem->attr;\n            list      = attr_elem->list; /* Cannot be null by construction. */\n            node      = list->head;\n            while (node)\n            {\n              interval = node->data;\n              if (col_index >= interval->low && col_index <= interval->high)\n              {\n                if (word_a[wi].iattr == NULL || toggles.cols_first)\n                {\n                  if (col_attrs[col_index] == NULL)\n                  {\n                    word_a[wi].iattr     = attr;\n                    col_attrs[col_index] = attr;\n                  }\n                  else\n                    word_a[wi].iattr = col_attrs[col_index];\n\n                  goto early_col_exit;\n                }\n              }\n              node = node->next;\n            }\n            attr_elem_node = attr_elem_node->next;\n          }\n        }\n      early_col_exit:\n\n        if (at_row_regex_list != NULL)\n        {\n          attr_elem_node = at_row_regex_list->head;\n          while (attr_elem_node != NULL)\n          {\n            attr_elem = attr_elem_node->data;\n            attr      = attr_elem->attr;\n            list      = attr_elem->list; /* Cannot be null by construction. */\n            node      = list->head;\n            while (node)\n            {\n              re = *(regex_t *)(node->data);\n              if (regexec(&re,\n                          word_a[wi].str + daccess.flength,\n                          (int)0,\n                          NULL,\n                          0)\n                  == 0)\n              {\n                col_index = 0;\n                while (wi > 0 && !word_a[wi - 1].is_last)\n                  wi--;\n\n                while (wi < count)\n                {\n                  if (toggles.cols_first && col_attrs[col_index] != NULL)\n                    word_a[wi].iattr = col_attrs[col_index];\n                  else\n                    word_a[wi].iattr = attr;\n\n                  col_index++;\n\n                  if (word_a[wi].is_last)\n                    break;\n                  wi++;\n                }\n              }\n              node = node->next;\n            }\n            attr_elem_node = attr_elem_node->next;\n          }\n        }\n\n        /* Adjusts things before a row change. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (word_a[wi].is_last\n            || wi == count - 1) /* About to start a new row? */\n        {\n          row_index++;\n\n          col_index = 0; /* Restart the columns counter. */\n        }\n        else\n          col_index++;\n      }\n    }\n  }\n\n  /* The word after the last one is set to NULL. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  word_a[count].str = NULL;\n\n  /* We can now allocate the space for our tmp_word work variable */\n  /* augmented by the number of tabulation columns. This is not   */\n  /* optimal but the loss is tiny and we have the guarantee that  */\n  /* enough place will be allocated.                              */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  tmp_word = xcalloc(1, word_real_max_size + tab_max_size + 1);\n\n  search_data.utf8_off_a = xmalloc(word_real_max_size * sizeof(long));\n  search_data.utf8_len_a = xmalloc(word_real_max_size * sizeof(long));\n\n  win.start = 0; /* index of the first element in the *\n                  | words array to be  displayed.     */\n\n  /* We can now build the first metadata. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  last_line = build_metadata(&term, count, &win);\n\n  /* Adjust the max number of lines in the windows */\n  /* if it has not be explicitly set.              */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (line_nb_of_word_a[count - 1] < win.max_lines)\n    win.max_lines = win.asked_max_lines = line_nb_of_word_a[count - 1] + 1;\n\n  /* Index of the selected element in the array words                */\n  /* The string can be:                                              */\n  /*   \"last\"    The string \"last\"   put the cursor on the last word */\n  /*   n         a number            put the cursor on the word n    */\n  /*   /pref     /+a regexp          put the cursor on the first     */\n  /*                                 word matching the prefix \"pref\" */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n  for (wi = 0; wi < count; wi++)\n  {\n    long len;\n\n    if (daccess.padding == 'a' || word_a[wi].is_numbered)\n      len = daccess.flength;\n    else\n      len = 0;\n\n    word_a[wi].bitmap = xcalloc(1, (word_a[wi].mb - len) / CHAR_BIT + 1);\n  }\n\n  /* Find the first selectable word (if any) in the input stream. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  first_selectable = 0;\n  while (first_selectable < count && !word_a[first_selectable].is_selectable)\n    first_selectable++;\n\n  /* If not found, abort. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (first_selectable == count)\n  {\n    fprintf(stderr, \"No selectable word found.\\n\");\n\n    exit(EXIT_FAILURE);\n  }\n\n  /* Else find the last selectable word in the input stream. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  last_selectable = count - 1;\n  while (last_selectable > 0 && !word_a[last_selectable].is_selectable)\n    last_selectable--;\n\n  if (pre_selection_index == NULL)\n    /* Option -s was not used. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    current = first_selectable;\n  else if (*pre_selection_index == '/')\n  {\n    /* A regular expression is expected. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    regex_t re;\n\n    if (regcomp(&re, pre_selection_index + 1, REG_EXTENDED | REG_NOSUB) != 0)\n    {\n      fprintf(stderr, \"%s: Invalid regular expression.\\n\", pre_selection_index);\n\n      exit(EXIT_FAILURE);\n    }\n    else\n    {\n      int   found = 0;\n      char *word;\n\n      for (index = first_selectable; index <= last_selectable; index++)\n      {\n        if (!word_a[index].is_selectable)\n          continue;\n\n        if (word_a[index].orig != NULL)\n          word = word_a[index].orig;\n        else\n          word = word_a[index].str;\n\n        if (regexec(&re, word, (int)0, NULL, 0) == 0)\n        {\n          long target;\n\n          if (!found)\n          {\n            found   = 1;\n            current = index;\n          }\n\n          /* Insert the index in the search array. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          target = get_sorted_array_target_pos(matching_words_da,\n                                               BUF_LEN(matching_words_da),\n                                               index);\n          if (target >= 0)\n            BUF_INSERT(matching_words_da, target, index);\n        }\n      }\n\n      if (!found)\n        current = first_selectable;\n    }\n  }\n  else if (*pre_selection_index == '=') /* exact search. */\n  {\n    /* An exact match is expected. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    wchar_t *w;\n\n    ll_t      *list;\n    ll_node_t *node;\n\n    list = tst_search(tst_word, w = utf8_strtowcs(pre_selection_index + 1));\n    if (list != NULL)\n    {\n      long target;\n\n      node    = list->head;\n      current = *(long *)(node->data);\n\n      while (node)\n      {\n        /* Insert the index in the search array. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        target = get_sorted_array_target_pos(matching_words_da,\n                                             BUF_LEN(matching_words_da),\n                                             *(long *)(node->data));\n        if (target >= 0)\n          BUF_INSERT(matching_words_da, target, *(long *)(node->data));\n\n        node = node->next;\n      }\n    }\n    else\n      current = first_selectable;\n\n    free(w);\n  }\n  else if (*pre_selection_index != '\\0')\n  {\n    /* A prefix string or an index is expected. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    int   len;\n    char *ptr = pre_selection_index;\n\n    if (*ptr == '#')\n    {\n      /* An index is expected. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      ptr++;\n\n      if (sscanf(ptr, \"%ld%n\", &current, &len) == 1 && len == (int)strlen(ptr))\n      {\n        /* We got an index (numeric value). */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        if (current < 0)\n          current = first_selectable;\n\n        if (current >= count)\n          current = count - 1;\n\n        if (!word_a[current].is_selectable)\n        {\n          if (current > last_selectable)\n            current = last_selectable;\n          else if (current < first_selectable)\n            current = first_selectable;\n          else\n            while (current > first_selectable && !word_a[current].is_selectable)\n              current--;\n        }\n      }\n      else if (*ptr == '\\0' || strcmp(ptr, \"last\") == 0)\n        /* We got a special index (empty or last). */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        current = last_selectable;\n      else\n      {\n        fprintf(stderr, \"%s: Invalid index.\\n\", ptr);\n\n        exit(EXIT_FAILURE);\n      }\n    }\n    else\n    {\n      int  found = 0;\n      long target;\n\n      /* A prefix is expected. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      for (new_current = first_selectable; new_current < count; new_current++)\n      {\n        if (strprefix(word_a[new_current].str, ptr)\n            && word_a[new_current].is_selectable)\n        {\n          if (!found)\n          {\n            current = new_current;\n            found   = 1;\n          }\n\n          /* Insert the index in the search array. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          target = get_sorted_array_target_pos(matching_words_da,\n                                               BUF_LEN(matching_words_da),\n                                               new_current);\n          if (target >= 0)\n            BUF_INSERT(matching_words_da, target, new_current);\n        }\n      }\n\n      if (!found)\n        current = first_selectable;\n    }\n  }\n  else\n    current = first_selectable;\n\n  /* We now need to adjust the 'start'/'end' fields of the */\n  /* structure 'win'.                                      */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  set_win_start_end(&win, current, last_line);\n\n  /* Re-associates /dev/tty with stdin and stdout. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (freopen(\"/dev/tty\", \"r\", stdin) == NULL)\n  {\n    fprintf(stderr, \"Unable to associate /dev/tty with stdin.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  old_fd1    = dup(1);\n  old_stdout = fdopen(old_fd1, \"w\");\n\n  setbuf(old_stdout, NULL);\n\n  if (freopen(\"/dev/tty\", \"w\", stdout) == NULL)\n  {\n    fprintf(stderr, \"Unable to associate /dev/tty with stdout.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  setvbuf(stdout, NULL, _IONBF, 0);\n\n  /* Make sure smenu runs in foreground. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!is_in_foreground_process_group())\n  {\n    fprintf(stderr, \"smenu cannot be launched in background.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  /* Set the characteristics of the terminal. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  setup_term(fileno(stdin), &old_in_attrs, &new_in_attrs);\n\n  if (!get_cursor_position(&row, &col))\n  {\n    fprintf(stderr,\n            \"The terminal does not have the capability to report \"\n            \"the cursor position.\\n\");\n    restore_term(fileno(stdin), &old_in_attrs);\n\n    exit(EXIT_FAILURE);\n  }\n\n  /* Initialize the search buffer with tab_real_max_size+1 NULs  */\n  /* It will never be reallocated, only cleared.                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  search_data.buf = xcalloc(1, word_real_max_size + 1 - daccess.flength);\n\n  /* Hide the cursor. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  (void)tputs(TPARM1(cursor_invisible), 1, outch);\n\n  /* Force the display to start at a beginning of line. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  get_cursor_position(&term.curs_line, &term.curs_column);\n  if (term.curs_column > 1)\n    puts(\"\");\n\n  /* Display the words window and its title for the first time. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  disp_message(message_lines_list,\n               message_max_width,\n               message_max_len,\n               &term,\n               &win,\n               &langinfo);\n\n  /* Before displaying the word windows for the first time when in    */\n  /* column or line mode, we need to ensure that the word under the   */\n  /* cursor will be visible by setting the number of the first column */\n  /* to be displayed.                                                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.col_mode || win.line_mode)\n  {\n    long pos;\n    long len;\n\n    len = term.ncolumns - 3;\n\n    /* Adjust win.first_column if the cursor is not visible. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n    while (word_a[current].end - word_a[pos].start >= len)\n      pos++;\n\n    win.first_column = word_a[pos].start;\n  }\n\n  /* Save the initial cursor line and column, here only the line is    */\n  /* interesting us. This will tell us if we are in need to compensate */\n  /* a terminal automatic scrolling.                                   */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  get_cursor_position(&term.curs_line, &term.curs_column);\n\n  nl = disp_lines(&win,\n                  &toggles,\n                  current,\n                  count,\n                  search_mode,\n                  &search_data,\n                  &term,\n                  last_line,\n                  tmp_word,\n                  &langinfo);\n\n  /* Assert the presence of an early display of the horizontal bar. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (win.has_hbar)\n    win.hbar_displayed = 1;\n\n  /* Determine the number of lines to move the cursor up if the window */\n  /* display needed a terminal scrolling.                              */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (nl + term.curs_line - 1 > term.nlines)\n    line_offset = term.curs_line + nl - term.nlines;\n  else\n    line_offset = 0;\n\n  /* Set the cursor to the first line of the window. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  {\n    long i; /* generic index in this block. */\n\n    for (i = 1; i < line_offset; i++)\n      (void)tputs(TPARM1(cursor_up), 1, outch);\n  }\n\n  /* Enable the reporting of the mouse events. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (!toggles.no_mouse)\n  {\n    if (term.has_kmous && strncmp(tigetstr(\"kmous\"), \"\\x1b[<\", 3) == 0)\n      mouse_trk_on = \"\\x1b[?1005l\\x1b[?1000;1006h\\x1b[?2004h\";\n    else\n      mouse_trk_on = \"\\x1b[?1005l\\x1b[?1000;1015;1006h\\x1b[?2004h\";\n\n    mouse_trk_off = \"\\x1b[?1000;1015;1006l\\x1b[?2004l\";\n\n    printf(\"%s\", mouse_trk_on);\n  }\n\n  /* Save again the cursor current line and column positions so that we */\n  /* will be able to put the terminal cursor back here.                 */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  get_cursor_position(&term.curs_line, &term.curs_column);\n\n  /* Arm the periodic timer. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  periodic_itv.it_value.tv_sec     = 0;\n  periodic_itv.it_value.tv_usec    = TCK;\n  periodic_itv.it_interval.tv_sec  = 0;\n  periodic_itv.it_interval.tv_usec = TCK;\n  setitimer(ITIMER_REAL, &periodic_itv, NULL);\n\n  /* Signal management. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  void sig_handler(int s);\n\n  sa.sa_handler = sig_handler;\n  sa.sa_flags   = 0;\n  sigemptyset(&sa.sa_mask);\n  sigaction(SIGWINCH, &sa, NULL);\n  sigaction(SIGALRM, &sa, NULL);\n  sigaction(SIGTERM, &sa, NULL);\n  sigaction(SIGHUP, &sa, NULL);\n  sigaction(SIGSEGV, &sa, NULL);\n  sigaction(SIGPIPE, &sa, NULL);\n\n  /* Main loop. */\n  /* \"\"\"\"\"\"\"\"\"\" */\n  while (1)\n  {\n    int sc = 0; /* scancode */\n\n    /* Manage the case of a broken pipe by exiting failure and restoring */\n    /* the terminal and the cursor.                                      */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_sigpipe)\n    {\n      (void)tputs(TPARM1(carriage_return), 1, outch);\n      (void)tputs(TPARM1(cursor_normal), 1, outch);\n      restore_term(fileno(stdin), &old_in_attrs);\n\n      exit(128 + SIGPIPE);\n    }\n\n    /* Manage a segmentation fault by exiting with failure and restoring */\n    /* the terminal and the cursor.                                      */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_sigsegv)\n    {\n      fputs_safe(\"SIGSEGV received!\\n\", stderr);\n      (void)tputs(TPARM1(carriage_return), 1, outch);\n      (void)tputs(TPARM1(cursor_normal), 1, outch);\n      restore_term(fileno(stdin), &old_in_attrs);\n\n      exit(128 + SIGSEGV);\n    }\n\n    /* Manage the hangup and termination signal by exiting with failure */\n    /* and restoring the terminal and the cursor.                       */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_sigterm || got_sighup)\n    {\n      fputs_safe(\"Interrupted!\\n\", stderr);\n      (void)tputs(TPARM1(carriage_return), 1, outch);\n      (void)tputs(TPARM1(cursor_normal), 1, outch);\n      restore_term(fileno(stdin), &old_in_attrs);\n\n      if (got_sigterm)\n        exit(128 + SIGTERM);\n      else\n        exit(128 + SIGHUP);\n    }\n\n    /* If this alarm is triggered, then gracefully exit. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_forgotten_alrm)\n    {\n      (void)tputs(TPARM1(carriage_return), 1, outch);\n      (void)tputs(TPARM1(cursor_normal), 1, outch);\n      restore_term(fileno(stdin), &old_in_attrs);\n\n      exit(EXIT_SUCCESS);\n    }\n\n    /* If this alarm is triggered, then redisplay the window */\n    /* to remove the help message and disable this timer.    */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_help_alrm)\n    {\n      got_help_alrm = 0;\n\n      /* Calculate the new metadata and draw the window again. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      last_line = build_metadata(&term, count, &win);\n\n      help_mode = 0;\n      nl        = disp_lines(&win,\n                      &toggles,\n                      current,\n                      count,\n                      search_mode,\n                      &search_data,\n                      &term,\n                      last_line,\n                      tmp_word,\n                      &langinfo);\n    }\n\n    /* Reset the direct access selector if the direct access alarm rang. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_daccess_alrm)\n    {\n      got_daccess_alrm = 0;\n      memset(daccess_stack, '\\0', 6);\n      daccess_stack_head = 0;\n\n      /* +---+---+---+---+---+---+               */\n      /* |   |   |   |   |   |   | daccess_stack */\n      /* +-^-+---+---+---+---+---+               */\n      /*   |                                     */\n      /*   daccess_stack_head                    */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n      daccess_timer = timers.direct_access;\n    }\n\n    if (got_search_alrm)\n    {\n      got_search_alrm = 0;\n\n      /* Calculate the new metadata and draw the window again. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      last_line = build_metadata(&term, count, &win);\n\n      search_mode = NONE;\n\n      nl = disp_lines(&win,\n                      &toggles,\n                      current,\n                      count,\n                      search_mode,\n                      &search_data,\n                      &term,\n                      last_line,\n                      tmp_word,\n                      &langinfo);\n    }\n\n    if (got_winch)\n    {\n      got_winch      = 0;\n      got_winch_alrm = 0;\n      winch_timer    = timers.winch; /* Rearm the refresh timer. */\n    }\n\n    /* If the timeout is set then decrement its remaining value   */\n    /* Upon expiration of this alarm, we trigger a content update */\n    /* of the window.                                             */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (got_winch_alrm)\n    {\n      long i; /* generic index in this block */\n      int  nlines, ncolumns;\n      int  line, column;\n      int  original_message_lines;\n\n      got_winch_alrm = 0;  /* Reset the flag signaling the need for a *\n                            | a refresh.                              */\n      winch_timer    = -1; /* Disarm the timer used for this refresh. */\n\n      if (message_lines_list != NULL && message_lines_list->len > 0)\n        original_message_lines = message_lines_list->len + 1;\n      else\n        original_message_lines = 0;\n\n      get_terminal_size(&nlines, &ncolumns, &term);\n\n      /* Update term with the new number of lines and columns */\n      /* of the real terminal.                                */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      term.nlines   = nlines;\n      term.ncolumns = ncolumns;\n\n      /* Reset the number of lines if the terminal has enough lines. */\n      /* message_lines_list->len+1 is used here instead of           */\n      /* win.message_lines because win.message_lines may have been   */\n      /* altered by a previous scrolling and not yet recalculated.   */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (term.nlines <= original_message_lines)\n      {\n        win.message_lines = term.nlines - 1;\n        win.max_lines     = 1;\n      }\n      else\n      {\n        win.message_lines = original_message_lines;\n\n        if (win.max_lines < term.nlines - win.message_lines)\n        {\n          if (win.asked_max_lines == 0)\n            win.max_lines = term.nlines - win.message_lines;\n          else\n          {\n            if (win.asked_max_lines > term.nlines - win.message_lines)\n              win.max_lines = term.nlines - win.message_lines;\n            else\n              win.max_lines = win.asked_max_lines;\n          }\n        }\n        else\n          win.max_lines = term.nlines - win.message_lines;\n      }\n\n      /* Erase the visible part of the displayed window. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      for (i = 0; i < win.message_lines; i++)\n      {\n        (void)tputs(TPARM1(clr_bol), 1, outch);\n        (void)tputs(TPARM1(clr_eol), 1, outch);\n        (void)tputs(TPARM1(cursor_up), 1, outch);\n      }\n\n      (void)tputs(TPARM1(clr_bol), 1, outch);\n      (void)tputs(TPARM1(clr_eol), 1, outch);\n      (void)tputs(TPARM1(save_cursor), 1, outch);\n\n      get_cursor_position(&line, &column);\n\n      for (i = 1; i < nl + win.message_lines; i++)\n      {\n        if (line + i >= nlines)\n          break; /* We have reached the last terminal line. */\n\n        (void)tputs(TPARM1(cursor_down), 1, outch);\n        (void)tputs(TPARM1(clr_bol), 1, outch);\n        (void)tputs(TPARM1(clr_eol), 1, outch);\n      }\n      (void)tputs(TPARM1(restore_cursor), 1, outch);\n\n      /* Get new cursor position. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      get_cursor_position(&term.curs_line, &term.curs_column);\n\n      /* Calculate the new metadata and draw the window again. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      last_line = build_metadata(&term, count, &win);\n\n      if (win.col_mode || win.line_mode)\n      {\n        long pos;\n        long len;\n\n        len = term.ncolumns - 3;\n\n        /* Adjust win.first_column if the cursor is no more visible. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n        while (word_a[current].end - word_a[pos].start >= len)\n          pos++;\n\n        win.first_column = word_a[pos].start;\n      }\n\n      /* Keep a line available for an eventual horizontal scroll bar. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (win.col_mode || win.line_mode)\n      {\n        if (win.asked_max_lines == 0\n            || win.max_lines > term.nlines - win.message_lines)\n        {\n          win.max_lines = term.nlines - win.message_lines - 1;\n          {\n            (void)tputs(TPARM3(cursor_address, win.max_lines, 0), 1, outch);\n            (void)tputs(TPARM1(clr_eol), 1, outch);\n            (void)tputs(TPARM3(cursor_address, 0, 0), 1, outch);\n          }\n        }\n        else if (win.asked_max_lines > term.nlines - win.message_lines)\n          win.max_lines = term.nlines - win.message_lines - 1;\n        else\n          win.max_lines = win.asked_max_lines;\n      }\n\n      disp_message(message_lines_list,\n                   message_max_width,\n                   message_max_len,\n                   &term,\n                   &win,\n                   &langinfo);\n\n      nl = disp_lines(&win,\n                      &toggles,\n                      current,\n                      count,\n                      search_mode,\n                      &search_data,\n                      &term,\n                      last_line,\n                      tmp_word,\n                      &langinfo);\n\n      /* Determine the number of lines to move the cursor up if the window  */\n      /* display needed a terminal scrolling.                               */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (nl + win.message_lines + term.curs_line > term.nlines)\n        line_offset = term.curs_line + nl + win.message_lines - term.nlines;\n      else\n        line_offset = 0;\n\n      /* Set the cursor to the first line of the window. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      for (i = 1; i < line_offset; i++)\n        (void)tputs(TPARM1(cursor_up), 1, outch);\n\n      /* Get new cursor position. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      get_cursor_position(&term.curs_line, &term.curs_column);\n\n      /* We need to trigger the rebuild of the help lines because of */\n      /* the geometry change.                                        */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      init_help_needed   = 1;\n      fst_disp_help_line = 0;\n\n      help_mode = 0;\n\n      /* Short-circuit the loop. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      continue;\n    }\n\n    /* and possibly set its reached value.                      */\n    /* The counter is frozen in search and help mode.           */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if (timeout.initial_value && search_mode == NONE && !help_mode\n        && got_timeout_tick)\n    {\n      long  i;\n      char *timeout_string;\n\n      got_timeout_tick = 0;\n\n      timeout.remain--;\n\n      if (!quiet_timeout && timeout.remain % FREQ == 0)\n      {\n        snprintf(timeout_seconds, 6, \"%5u\", timeout.remain / FREQ);\n        timeout_string =\n          (char *)(((ll_node_t *)(message_lines_list->tail))->data);\n        memcpy(timeout_string + 1, timeout_seconds, 5);\n\n        /* Erase the current window. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        for (i = 0; i < win.message_lines; i++)\n        {\n          (void)tputs(TPARM1(cursor_up), 1, outch);\n          (void)tputs(TPARM1(clr_bol), 1, outch);\n          (void)tputs(TPARM1(clr_eol), 1, outch);\n        }\n\n        (void)tputs(TPARM1(clr_bol), 1, outch);\n        (void)tputs(TPARM1(clr_eol), 1, outch);\n\n        /* Display the words window and its title for the first time. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        disp_message(message_lines_list,\n                     message_max_width,\n                     message_max_len,\n                     &term,\n                     &win,\n                     &langinfo);\n      }\n      /* The timeout has expired. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (timeout.remain == 0)\n        timeout.reached = 1;\n    }\n\n    if (timeout.reached)\n    {\n      if (timeout.mode == QUIT)\n        goto quit;\n      else if (timeout.mode == CURRENT || timeout.mode == WORD)\n        goto enter;\n    }\n\n    /* Pressed keys scancodes processing. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    page = 1; /* Default number of lines to do down/up *\n               | with PgDn/PgUp.                       */\n\n    sc = get_scancode(buffer, 63);\n\n    if (sc && winch_timer < 0) /* Do not allow input when a window *\n                                | refresh is scheduled.            */\n    {\n      /* Rearm the timer named \"forgotten\". */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      forgotten_timer = timers.forgotten;\n\n      if (timeout.initial_value && buffer[0] != 0x0d && buffer[0] != 'q'\n          && buffer[0] != 'Q' && buffer[0] != 3)\n      {\n        char *timeout_string;\n\n        /* Reset the timeout to its initial value. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        timeout.remain = timeout.initial_value;\n\n        if (!quiet_timeout)\n        {\n          snprintf(timeout_seconds, 6, \"%5u\", timeout.initial_value / FREQ);\n          timeout_string =\n            (char *)(((ll_node_t *)(message_lines_list->tail))->data);\n          memcpy(timeout_string + 1, timeout_seconds, 5);\n\n          /* Clear the message. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          for (long i = 0; i < win.message_lines; i++)\n          {\n            (void)tputs(TPARM1(cursor_up), 1, outch);\n            (void)tputs(TPARM1(clr_bol), 1, outch);\n            (void)tputs(TPARM1(clr_eol), 1, outch);\n          }\n\n          (void)tputs(TPARM1(clr_bol), 1, outch);\n          (void)tputs(TPARM1(clr_eol), 1, outch);\n\n          /* Display the words window and its title for the first time. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          disp_message(message_lines_list,\n                       message_max_width,\n                       message_max_len,\n                       &term,\n                       &win,\n                       &langinfo);\n        }\n\n        setitimer(ITIMER_REAL, &periodic_itv, NULL);\n      }\n\n      switch (buffer[0])\n      {\n        case 0x01: /* ^A */\n          if (!help_mode && search_mode != NONE)\n            goto khome;\n\n          break;\n\n        case 0x1a: /* ^Z */\n          if (!help_mode && search_mode != NONE)\n            goto kend;\n\n          break;\n\n        case 0x1b: /* ESC */\n\n          /* Ignore mouse pastes when bracketed pastes is enabled. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (memcmp(\"\\x1b[200~\", buffer, 6) == 0)\n          {\n            int  c;\n            char eb[6] = { 0 };\n\n            /* Consume stdin until a closing bracket is found. */\n            /* ''''''''''''''''''''''''''''''''''''''''''''''' */\n            while (1)\n            {\n              /* Fast reading until an ESC or the end of input is found. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              while ((c = my_fgetc(stdin)) != EOF && c != 0x1b)\n                ; /* Null action. */\n\n              /* Exits the loop early if the first ESC character starting */\n              /* the ending bracket has already be consumed while reading */\n              /* the content of buffer.                                   */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (c == EOF)\n                break;\n\n              /* Read the 5 next characters to look for the */\n              /* ending bracket \"[201~\".                    */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              scanf(\"%5c\", eb);\n              if (memcmp(\"[201~\", eb, 5) == 0)\n                break;\n            }\n          }\n\n          /* An escape sequence or a UTF-8 sequence has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (memcmp(\"\\x1bOH\", buffer, 3) == 0\n              || memcmp(\"\\x1bk\", buffer, 2) == 0\n              || memcmp(\"\\x1b[H\", buffer, 3) == 0\n              || memcmp(\"\\x1b[1~\", buffer, 4) == 0\n              || memcmp(\"\\x1b[7~\", buffer, 4) == 0)\n          {\n            /* HOME key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (help_mode)\n              break;\n\n            if (search_mode != NONE)\n            {\n            khome:\n              search_data.only_starting = 1;\n              search_data.only_ending   = 0;\n              select_starting_matches(&win, &term, &search_data, &last_line);\n            }\n            else\n            {\n              /* Find the first selectable word. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              current = win.start;\n\n              while (current < win.end && !word_a[current].is_selectable)\n                current++;\n\n              /* In column mode we need to take care of the */\n              /* horizontal scrolling.                      */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if ((win.col_mode || win.line_mode)\n                  && word_a[current].end < win.first_column)\n                win.first_column = word_a[current].start;\n            }\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n            break;\n          }\n\n          if (memcmp(\"\\x1b[1;5H\", buffer, 6) == 0\n              || memcmp(\"\\x1b[7^\", buffer, 4) == 0)\n            /* CTRL HOME key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kchome;\n\n          if (memcmp(\"\\x1bOF\", buffer, 3) == 0\n              || memcmp(\"\\x1bj\", buffer, 2) == 0\n              || memcmp(\"\\x1b[F\", buffer, 3) == 0\n              || memcmp(\"\\x1b[4~\", buffer, 4) == 0\n              || memcmp(\"\\x1b[8~\", buffer, 4) == 0)\n          {\n            /* END key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (help_mode)\n              break;\n\n            if (search_mode != NONE)\n            {\n            kend:\n\n              if (BUF_LEN(matching_words_da) > 0 && search_mode != PREFIX)\n              {\n                search_data.only_starting = 0;\n                search_data.only_ending   = 1;\n                select_ending_matches(&win, &term, &search_data, &last_line);\n              }\n            }\n            else\n            {\n              /* Find the last selectable word. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              current = win.end;\n\n              while (current > win.start && !word_a[current].is_selectable)\n                current--;\n\n              /* In column mode we need to take care of the */\n              /* horizontal scrolling.                      */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (win.col_mode || win.line_mode)\n                set_new_first_column(&win, &term);\n            }\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n            break;\n          }\n\n          if (memcmp(\"\\x1b[1;5F\", buffer, 6) == 0\n              || memcmp(\"\\x1b[8^\", buffer, 4) == 0)\n            /* CTRL END key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kcend;\n\n          if (memcmp(\"\\x1bOD\", buffer, 3) == 0\n              || memcmp(\"\\x1b[D\", buffer, 3) == 0)\n            /* Left arrow key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kl;\n\n          if (memcmp(\"\\x1bOC\", buffer, 3) == 0\n              || memcmp(\"\\x1b[C\", buffer, 3) == 0)\n            /* Right arrow key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kr;\n\n          if (memcmp(\"\\x1bOA\", buffer, 3) == 0\n              || memcmp(\"\\x1b[A\", buffer, 3) == 0)\n            /* Up arrow key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto ku;\n\n          if (memcmp(\"\\x1bOB\", buffer, 3) == 0\n              || memcmp(\"\\x1b[B\", buffer, 3) == 0)\n            /* Down arrow key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kd;\n\n          if (memcmp(\"\\x1b[I\", buffer, 3) == 0\n              || memcmp(\"\\x1b[5~\", buffer, 4) == 0)\n            /* PgUp key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kpp;\n\n          if (memcmp(\"\\x1b[G\", buffer, 3) == 0\n              || memcmp(\"\\x1b[6~\", buffer, 4) == 0)\n            /* PgDn key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto knp;\n\n          if (memcmp(\"\\x1b[L\", buffer, 3) == 0\n              || memcmp(\"\\x1b[2~\", buffer, 4) == 0)\n            /* Ins key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kins;\n\n          if (memcmp(\"\\x1b[3~\", buffer, 4) == 0)\n            /* Del key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto kdel;\n\n          if (memcmp(\"\\x1b[1;2F\", buffer, 6) == 0\n              || memcmp(\"\\x1b[1;5C\", buffer, 6) == 0\n              || memcmp(\"\\x1b[8$\", buffer, 4) == 0\n              || memcmp(\"\\x1bOc\", buffer, 3) == 0)\n            /* SHIFT END or CTRL -> has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto keol;\n\n          if (memcmp(\"\\x1b[1;2H\", buffer, 6) == 0\n              || memcmp(\"\\x1b[1;5D\", buffer, 6) == 0\n              || memcmp(\"\\x1b[7$\", buffer, 4) == 0\n              || memcmp(\"\\x1bOd\", buffer, 3) == 0)\n            /* SHIFT HOME or CTRL <- key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            goto ksol;\n\n          if (!toggles.no_mouse)\n          {\n            double          res = 5000; /* 5 s, arbitrary value. */\n            struct timespec res_ts;\n\n            /* The minimal resolution for double-click must be 1/10 s. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (clock_getres(CLOCK_MONOTONIC, &res_ts) == -1)\n              disable_double_click = 1;\n            else\n              res = 1000.0 * res_ts.tv_sec + 1e-6 * res_ts.tv_nsec;\n\n            if (res > 100)\n              disable_double_click = 1;\n\n            /* Detect the mouse protocol. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (memcmp(\"\\x1b[<\", buffer, 3) == 0)\n            {\n              mouse_proto = MOUSE1006;\n              goto kmouse;\n            }\n\n            if (memcmp(\"\\x1b[M\", buffer, 3) == 0)\n            {\n              mouse_proto = MOUSE1000;\n              goto kmouse;\n            }\n\n            if (memcmp(\"\\x1b[32;\", buffer, 5) == 0\n                || memcmp(\"\\x1b[33;\", buffer, 5) == 0\n                || memcmp(\"\\x1b[34;\", buffer, 5) == 0\n                || memcmp(\"\\x1b[96;\", buffer, 5) == 0\n                || memcmp(\"\\x1b[97;\", buffer, 5) == 0)\n            {\n              mouse_proto = MOUSE1015;\n              goto kmouse;\n            }\n          }\n\n          if (buffer[0] == 0x1b && buffer[1] == '\\0')\n          {\n            /* ESC key has been pressed. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n            /* Do not reset the search buffer when exiting the quick help */\n            /* using ESC.                                                 */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */\n            if (help_mode)\n              help_mode = 0;\n            else\n              reset_search_buffer(&win,\n                                  &search_data,\n                                  &timers,\n                                  &toggles,\n                                  &term,\n                                  &daccess,\n                                  &langinfo,\n                                  last_line,\n                                  tmp_word,\n                                  word_real_max_size);\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n\n            /* Unmark the marked word. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (toggles.taggable && marked >= 0)\n              goto unmark_word;\n\n            break;\n          }\n\n          /* Else ignore key. */\n          break;\n\n        quit:\n        case 'q':\n        case 'Q':\n        case 3: /* ^C */\n                /* q or Q of ^C has been pressed. */\n                /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n          if (!help_mode && search_mode != NONE && buffer[0] != 3)\n            goto special_cmds_when_searching;\n\n          {\n            long i; /* Generic index in this block. */\n\n            for (i = 0; i < win.message_lines; i++)\n              (void)tputs(TPARM1(cursor_up), 1, outch);\n\n            if (toggles.del_line)\n            {\n              (void)tputs(TPARM1(clr_eol), 1, outch);\n              (void)tputs(TPARM1(clr_bol), 1, outch);\n              (void)tputs(TPARM1(save_cursor), 1, outch);\n\n              for (i = 1; i < nl + win.message_lines; i++)\n              {\n                (void)tputs(TPARM1(cursor_down), 1, outch);\n                (void)tputs(TPARM1(clr_eol), 1, outch);\n                (void)tputs(TPARM1(clr_bol), 1, outch);\n              }\n              (void)tputs(TPARM1(restore_cursor), 1, outch);\n            }\n            else\n            {\n              for (i = 1; i < nl + win.message_lines; i++)\n                (void)tputs(TPARM1(cursor_down), 1, outch);\n              puts(\"\");\n            }\n          }\n\n          /* Disable the reporting of the mouse events. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (!toggles.no_mouse)\n            printf(\"%s\", mouse_trk_off);\n\n          /* Restore the visibility of the cursor. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          (void)tputs(TPARM1(cursor_normal), 1, outch);\n\n          if (buffer[0] == 3) /* ^C */\n          {\n            if (int_string != NULL)\n              fprintf(old_stdout, \"%s\", int_string);\n\n            /* Set the cursor at the start on the line an restore the */\n            /* original terminal state before exiting.                */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            (void)tputs(TPARM1(carriage_return), 1, outch);\n            restore_term(fileno(stdin), &old_in_attrs);\n\n            if (int_as_in_shell)\n              exit(128 + SIGINT);\n          }\n          else\n            restore_term(fileno(stdin), &old_in_attrs);\n\n          exit(EXIT_SUCCESS);\n\n        case 0x0c:\n          /* Form feed (^L) is a traditional method to redraw a screen. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (current < win.start || current > win.end)\n            last_line = build_metadata(&term, count, &win);\n\n          nl = disp_lines(&win,\n                          &toggles,\n                          current,\n                          count,\n                          search_mode,\n                          &search_data,\n                          &term,\n                          last_line,\n                          tmp_word,\n                          &langinfo);\n\n          if (help_mode)\n            disp_help(&win, &term, help_lines_da, fst_disp_help_line);\n          break;\n\n        case 'n':\n        case ' ':\n          /* n or the space bar has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode != NONE)\n            goto special_cmds_when_searching;\n\n          if (BUF_LEN(matching_words_da) > 0)\n          {\n            long pos = find_next_matching_word(matching_words_da,\n                                               BUF_LEN(matching_words_da),\n                                               current,\n                                               &matching_word_cur_index);\n            if (pos >= 0)\n              current = pos;\n\n            if (current < win.start || current > win.end)\n              last_line = build_metadata(&term, count, &win);\n\n            /* Set new first column to display. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            set_new_first_column(&win, &term);\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          break;\n\n        case 'N':\n          /* N has been pressed.*/\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode != NONE)\n            goto special_cmds_when_searching;\n\n          if (BUF_LEN(matching_words_da) > 0)\n          {\n            long pos = find_prev_matching_word(matching_words_da,\n                                               BUF_LEN(matching_words_da),\n                                               current,\n                                               &matching_word_cur_index);\n            if (pos >= 0)\n              current = pos;\n          }\n\n          if (current < win.start || current > win.end)\n            last_line = build_metadata(&term, count, &win);\n\n          /* Set new first column to display. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          set_new_first_column(&win, &term);\n\n          nl = disp_lines(&win,\n                          &toggles,\n                          current,\n                          count,\n                          search_mode,\n                          &search_data,\n                          &term,\n                          last_line,\n                          tmp_word,\n                          &langinfo);\n          break;\n\n        case 's':\n          /* s has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode != NONE)\n            goto special_cmds_when_searching;\n\n          if (BUF_LEN(matching_words_da) > 0)\n          {\n            long pos;\n\n            if (BUF_LEN(best_matching_words_da) > 0)\n              pos = find_next_matching_word(best_matching_words_da,\n                                            BUF_LEN(best_matching_words_da),\n                                            current,\n                                            &matching_word_cur_index);\n            else\n              pos = find_next_matching_word(matching_words_da,\n                                            BUF_LEN(matching_words_da),\n                                            current,\n                                            &matching_word_cur_index);\n\n            if (pos >= 0)\n              current = pos;\n\n            if (current < win.start || current > win.end)\n              last_line = build_metadata(&term, count, &win);\n\n            /* Set new first column to display. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            set_new_first_column(&win, &term);\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          break;\n\n        case 'S':\n          /* S has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode != NONE)\n            goto special_cmds_when_searching;\n\n          if (BUF_LEN(matching_words_da) > 0)\n          {\n            long pos;\n\n            if (BUF_LEN(best_matching_words_da) > 0)\n              pos = find_prev_matching_word(best_matching_words_da,\n                                            BUF_LEN(best_matching_words_da),\n                                            current,\n                                            &matching_word_cur_index);\n            else\n              pos = find_prev_matching_word(matching_words_da,\n                                            BUF_LEN(matching_words_da),\n                                            current,\n                                            &matching_word_cur_index);\n\n            if (pos >= 0)\n              current = pos;\n          }\n\n          if (current < win.start || current > win.end)\n            last_line = build_metadata(&term, count, &win);\n\n          /* Set new first column to display. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          set_new_first_column(&win, &term);\n\n          nl = disp_lines(&win,\n                          &toggles,\n                          current,\n                          count,\n                          search_mode,\n                          &search_data,\n                          &term,\n                          last_line,\n                          tmp_word,\n                          &langinfo);\n          break;\n\n        enter:\n        case 0x0d: /* CR */\n        {\n          /* <Enter> has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n          int       extra_lines;\n          char     *output_str;\n          output_t *output_node;\n\n          int width = 0;\n\n          wchar_t *w;\n          long     i; /* Generic index in this block. */\n\n          if (help_mode || marked >= 0)\n          {\n            marked = -1; /* Disable the marked mode unconditionally. */\n            nl     = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n\n          if (search_mode != NONE)\n          {\n            /* Cancel the search timer. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            search_timer = 0;\n\n            search_mode               = NONE;\n            search_data.only_starting = 0;\n            search_data.only_ending   = 0;\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n\n            if (!toggles.enter_val_in_search)\n              break;\n          }\n\n          if (toggles.del_line)\n          {\n            for (i = 0; i < win.message_lines; i++)\n              (void)tputs(TPARM1(cursor_up), 1, outch);\n\n            (void)tputs(TPARM1(clr_eol), 1, outch);\n            (void)tputs(TPARM1(clr_bol), 1, outch);\n            (void)tputs(TPARM1(save_cursor), 1, outch);\n\n            for (i = 1; i < nl + win.message_lines; i++)\n            {\n              (void)tputs(TPARM1(cursor_down), 1, outch);\n              (void)tputs(TPARM1(clr_eol), 1, outch);\n              (void)tputs(TPARM1(clr_bol), 1, outch);\n            }\n\n            (void)tputs(TPARM1(restore_cursor), 1, outch);\n          }\n          else\n          {\n            for (i = 1; i < nl; i++)\n              (void)tputs(TPARM1(cursor_down), 1, outch);\n            puts(\"\");\n          }\n\n          /* When a timeout of type WORD is set, prints the specified word */\n          /* else prints the current selected entries.                     */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (timeout.initial_value > 0 && timeout.remain == 0\n              && timeout.mode == WORD)\n            fprintf(old_stdout, \"%s\", timeout_word);\n          else\n          {\n            char *num_str;\n            char *str;\n\n            if (toggles.taggable)\n            {\n              ll_t      *output_list = ll_new();\n              ll_node_t *node;\n\n              /* When using -P, updates the tagging order of this word to */\n              /* make sure that the output will be correctly sorted.      */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (word_a[current].tag_id == 0 && toggles.pinable)\n                word_a[current].tag_order = tag_nb++;\n\n              for (wi = 0; wi < count; wi++)\n              {\n                if (word_a[wi].tag_id > 0 || wi == current)\n                {\n                  /* If the -p option is not used we do not take into      */\n                  /* account an untagged word under the cursor if at least */\n                  /* on word is tagged.                                    */\n                  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                  if (wi == current && tagged_words > 0 && !toggles.autotag\n                      && word_a[wi].tag_id == 0)\n                    continue;\n\n                  /* In tagged mode, do not automatically tag the word   */\n                  /* under the cursor if toggles.noautotag is set and no */\n                  /* word are tagged.                                    */\n                  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                  if (tagged_words == 0 && toggles.taggable\n                      && toggles.noautotag)\n                    continue;\n\n                  /* Chose the original string to print if the current one */\n                  /* has been altered by a possible expansion.             */\n                  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                  output_node = xmalloc(sizeof(output_t));\n\n                  if (word_a[wi].orig != NULL)\n                    str = word_a[wi].orig;\n                  else\n                    str = word_a[wi].str;\n\n                  if (word_a[wi].is_numbered && daccess.num_sep)\n                  {\n                    num_str = xstrndup(str + 1, daccess.length);\n\n                    ltrim(num_str, \" \");\n                    rtrim(num_str, \" \", 0);\n\n                    output_node->output_str = concat(num_str,\n                                                     daccess.num_sep,\n                                                     str + daccess.flength,\n                                                     (char *)0);\n\n                    free(num_str);\n                  }\n                  else\n                    output_node->output_str = xstrdup(str + daccess.flength);\n\n                  output_node->order = word_a[wi].tag_order;\n\n                  /* Trim the spaces if -k is not given. */\n                  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                  if (!toggles.keep_spaces)\n                  {\n                    ltrim(output_node->output_str, \" \\t\");\n                    rtrim(output_node->output_str, \" \\t\", 0);\n                  }\n\n                  ll_append(output_list, output_node);\n                }\n              }\n\n              /* If nothing is selected, exist without printing anything. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (output_list->head == NULL)\n                goto exit;\n\n              /* If -P is in use, then sort the output list. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (toggles.pinable)\n                ll_sort(output_list, tag_comp, tag_swap);\n\n              /* And print them. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              node = output_list->head;\n              while (node->next != NULL)\n              {\n                str = ((output_t *)(node->data))->output_str;\n\n                fprintf(old_stdout, \"%s\", str);\n                width += my_wcswidth((w = utf8_strtowcs(str)), 65535);\n                free(w);\n                free(str);\n                free(node->data);\n\n                if (win.sel_sep != NULL)\n                {\n                  fprintf(old_stdout, \"%s\", win.sel_sep);\n                  width += my_wcswidth((w = utf8_strtowcs(win.sel_sep)), 65535);\n                  free(w);\n                }\n                else\n                {\n                  fprintf(old_stdout, \" \");\n                  width++;\n                }\n\n                node = node->next;\n              }\n\n              str = ((output_t *)(node->data))->output_str;\n              fprintf(old_stdout, \"%s\", str);\n              width += my_wcswidth((w = utf8_strtowcs(str)), 65535);\n              free(w);\n              free(str);\n              free(node->data);\n            }\n            else\n            {\n              /* Chose the original string to print if the current one has */\n              /* been altered by a possible expansion.                     */\n              /* Once this made, print it.                                 */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (word_a[current].orig != NULL)\n                str = word_a[current].orig;\n              else\n                str = word_a[current].str;\n\n              if (word_a[current].is_numbered && daccess.num_sep)\n              {\n                num_str = xstrndup(str + 1, daccess.length);\n\n                ltrim(num_str, \" \");\n                rtrim(num_str, \" \", 0);\n\n                output_str = concat(num_str,\n                                    daccess.num_sep,\n                                    str + daccess.flength,\n                                    (char *)0);\n\n                free(num_str);\n              }\n              else\n                output_str = str + daccess.flength;\n\n              /* Trim the spaces if -k is not given. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (!toggles.keep_spaces)\n              {\n                ltrim(output_str, \" \\t\");\n                rtrim(output_str, \" \\t\", 0);\n              }\n\n              width = my_wcswidth((w = utf8_strtowcs(output_str)), 65535);\n              free(w);\n\n              /* And print it. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n              fprintf(old_stdout, \"%s\", output_str);\n            }\n\n            /* If the output stream is a terminal. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (isatty(old_fd1))\n            {\n              /* width is (in term of terminal columns) the size of the    */\n              /* string to be displayed.                                   */\n              /*                                                           */\n              /* With that information, count the number of terminal lines */\n              /* printed.                                                  */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              extra_lines = width / term.ncolumns;\n\n              /* Clean the printed line and all the extra lines used. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              (void)tputs(TPARM1(delete_line), 1, outch);\n\n              for (i = 0; i < extra_lines; i++)\n              {\n                (void)tputs(TPARM1(cursor_up), 1, outch);\n                (void)tputs(TPARM1(clr_eol), 1, outch);\n                (void)tputs(TPARM1(clr_bol), 1, outch);\n              }\n            }\n          }\n\n        exit:\n\n          /* Disable mouse reporting. */\n          /* '''''''''''''''''''''''' */\n          if (!toggles.no_mouse)\n            printf(\"%s\", mouse_trk_off);\n\n          /* Restore the visibility of the cursor. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          (void)tputs(TPARM1(cursor_normal), 1, outch);\n\n          /* Set the cursor at the start on the line an restore the */\n          /* original terminal state before exiting.                */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          (void)tputs(TPARM1(carriage_return), 1, outch);\n          restore_term(fileno(stdin), &old_in_attrs);\n\n          exit(EXIT_SUCCESS);\n        }\n\n        ksol:\n          /* Go to the start of the line. */\n          if (help_mode)\n            break;\n\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          search_mode = NONE;\n\n          /* Fall through. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        case 'H':\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (win.col_mode || win.line_mode)\n            {\n              long pos;\n\n              pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n              search_mode = NONE;\n\n              /* Find the first selectable word. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              while (!word_a[pos].is_last)\n              {\n                if (word_a[pos].is_selectable)\n                {\n                  current = pos;\n                  break;\n                }\n\n                pos++;\n\n                if (pos > current)\n                  break;\n              }\n\n              if (word_a[pos].is_last && word_a[pos].is_selectable)\n                current = pos;\n\n              set_new_first_column(&win, &term);\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        kl:\n          /* Cursor Left key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          search_mode = NONE;\n\n          /* Fall through. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        case 'h':\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n            move_left(&win,\n                      &term,\n                      &toggles,\n                      &search_data,\n                      &langinfo,\n                      &nl,\n                      last_line,\n                      tmp_word);\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        /* shift the window to the left if possible. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        case '<':\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n            shift_left(&win,\n                       &term,\n                       &toggles,\n                       &search_data,\n                       &langinfo,\n                       &nl,\n                       last_line,\n                       tmp_word,\n                       line_nb_of_word_a[current]);\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        keol:\n          /* Go to the end of the line. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          search_mode = NONE;\n\n          /* Fall through. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        case 'L':\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (win.col_mode || win.line_mode)\n            {\n              long pos;\n\n              pos = current;\n\n              search_mode = NONE;\n\n              /* Find the first selectable word. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              while (!word_a[pos].is_last)\n              {\n                if (word_a[pos].is_selectable)\n                  current = pos;\n\n                pos++;\n              }\n\n              if (word_a[pos].is_selectable)\n                current = pos;\n\n              set_new_first_column(&win, &term);\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        kr:\n          /* Right key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          search_mode = NONE;\n\n          /* Fall through. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        case 'l':\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n            move_right(&win,\n                       &term,\n                       &toggles,\n                       &search_data,\n                       &langinfo,\n                       &nl,\n                       last_line,\n                       tmp_word);\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        /* shift the window to the left if possible. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        case '>':\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n            shift_right(&win,\n                        &term,\n                        &toggles,\n                        &search_data,\n                        &langinfo,\n                        &nl,\n                        last_line,\n                        tmp_word,\n                        line_nb_of_word_a[current]);\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        case 0x0b:\n          /* ^K key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          goto kchome;\n\n        case 'K':\n          if (help_mode)\n            break;\n\n          if (search_mode != NONE)\n            goto special_cmds_when_searching;\n\n        kpp:\n          /* PgUp key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          page = win.max_lines;\n\n        ku:\n          /* Cursor Up key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          search_mode = NONE;\n\n          /* Fall through. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        case 'k':\n          if (search_mode == NONE)\n          {\n            if (help_mode)\n            {\n              int help_length = BUF_LEN(help_lines_da);\n\n              if (help_length > win.max_lines && fst_disp_help_line > 0)\n              {\n                fst_disp_help_line--;\n                nl = disp_lines(&win,\n                                &toggles,\n                                current,\n                                count,\n                                search_mode,\n                                &search_data,\n                                &term,\n                                last_line,\n                                tmp_word,\n                                &langinfo);\n                disp_help(&win, &term, help_lines_da, fst_disp_help_line);\n              }\n            }\n            else\n              move_up(&win,\n                      &term,\n                      &toggles,\n                      &search_data,\n                      &langinfo,\n                      &nl,\n                      page,\n                      first_selectable,\n                      last_line,\n                      tmp_word);\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        kchome:\n          /* Go to the first selectable word. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          current = 0;\n\n          search_mode = NONE;\n\n          /* Find the first selectable word. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          while (!word_a[current].is_selectable)\n            current++;\n\n          if (current < win.start || current > win.end)\n            last_line = build_metadata(&term, count, &win);\n\n          /* In column mode we need to take care of the */\n          /* horizontal scrolling.                      */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (win.col_mode || win.line_mode)\n          {\n            long pos;\n\n            /* Adjust win.first_column if the cursor is */\n            /* no more visible.                         */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n            while (word_a[current].end - word_a[pos].start >= term.ncolumns - 3)\n              pos++;\n\n            win.first_column = word_a[pos].start;\n          }\n\n          nl = disp_lines(&win,\n                          &toggles,\n                          current,\n                          count,\n                          search_mode,\n                          &search_data,\n                          &term,\n                          last_line,\n                          tmp_word,\n                          &langinfo);\n          break;\n\n        case 0x0a:\n          /* ^J key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          goto kcend;\n\n        case 'J':\n          if (help_mode)\n            break;\n\n          if (search_mode != NONE)\n            goto special_cmds_when_searching;\n\n        knp:\n          /* PgDn key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          page = win.max_lines;\n\n        kd:\n          /* Cursor Down key has been pressed. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          search_mode = NONE;\n\n          /* Fall through. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        case 'j':\n          if (search_mode == NONE)\n          {\n            if (help_mode)\n            {\n              int help_length = BUF_LEN(help_lines_da);\n\n              if (help_length > win.max_lines\n                  && fst_disp_help_line < help_length)\n              {\n                fst_disp_help_line++;\n                nl = disp_lines(&win,\n                                &toggles,\n                                current,\n                                count,\n                                search_mode,\n                                &search_data,\n                                &term,\n                                last_line,\n                                tmp_word,\n                                &langinfo);\n                disp_help(&win, &term, help_lines_da, fst_disp_help_line);\n              }\n            }\n            else\n              move_down(&win,\n                        &term,\n                        &toggles,\n                        &search_data,\n                        &langinfo,\n                        &nl,\n                        page,\n                        last_selectable,\n                        last_line,\n                        tmp_word);\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        kcend:\n          /* Go to the last selectable word. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          current = count - 1;\n\n          search_mode = NONE;\n\n          /* Find the first selectable word. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          while (!word_a[current].is_selectable)\n            current--;\n\n          if (current < win.start || current > win.end)\n            last_line = build_metadata(&term, count, &win);\n\n          /* In column mode we need to take care of the */\n          /* horizontal scrolling.                      */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (win.col_mode || win.line_mode)\n          {\n            long pos;\n\n            /* Adjust win.first_column if the cursor is no more visible. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            pos = first_word_in_line_a[line_nb_of_word_a[current]];\n\n            while (word_a[current].end - word_a[pos].start >= term.ncolumns - 3)\n              pos++;\n\n            win.first_column = word_a[pos].start;\n          }\n\n          nl = disp_lines(&win,\n                          &toggles,\n                          current,\n                          count,\n                          search_mode,\n                          &search_data,\n                          &term,\n                          last_line,\n                          tmp_word,\n                          &langinfo);\n          break;\n\n        case '/':\n          /* Generic search method according the misc settings. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (misc.default_search_method == PREFIX)\n            goto prefix_method;\n          else if (misc.default_search_method == SUBSTRING)\n            goto substring_method;\n          else if (misc.default_search_method == FUZZY)\n            goto fuzzy_method;\n\n          break;\n\n        case '~':\n        case '*':\n          /* ~ or * key has been pressed        */\n          /* (start of a fuzzy search session). */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n        fuzzy_method:\n\n          if (search_mode == NONE)\n          {\n            if (!toggles.incremental_search)\n              reset_search_buffer(&win,\n                                  &search_data,\n                                  &timers,\n                                  &toggles,\n                                  &term,\n                                  &daccess,\n                                  &langinfo,\n                                  last_line,\n                                  tmp_word,\n                                  word_real_max_size);\n\n            /* Set the search timer. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            search_timer = timers.search; /* default 10 s. */\n\n            search_mode = FUZZY;\n\n            if (old_search_mode != FUZZY)\n            {\n              old_search_mode = FUZZY;\n              clean_matches(&search_data, word_real_max_size);\n            }\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        case '\\'':\n        case '\\\"':\n          /* ' or \" key has been pressed            */\n          /* (start of a substring search session). */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n        substring_method:\n\n          if (search_mode == NONE)\n          {\n            if (!toggles.incremental_search)\n              reset_search_buffer(&win,\n                                  &search_data,\n                                  &timers,\n                                  &toggles,\n                                  &term,\n                                  &daccess,\n                                  &langinfo,\n                                  last_line,\n                                  tmp_word,\n                                  word_real_max_size);\n\n            /* Set the search timer. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            search_timer = timers.search; /* default 10 s. */\n\n            search_mode = SUBSTRING;\n\n            if (old_search_mode != SUBSTRING)\n            {\n              old_search_mode = SUBSTRING;\n              clean_matches(&search_data, word_real_max_size);\n            }\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        case '=':\n        case '^':\n          /* ^ or = key has been pressed         */\n          /* (start of a prefix search session). */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n        prefix_method:\n\n          if (search_mode == NONE)\n          {\n            if (!toggles.incremental_search)\n              reset_search_buffer(&win,\n                                  &search_data,\n                                  &timers,\n                                  &toggles,\n                                  &term,\n                                  &daccess,\n                                  &langinfo,\n                                  last_line,\n                                  tmp_word,\n                                  word_real_max_size);\n\n            /* Set the search timer. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            search_timer = timers.search; /* default 10 s. */\n\n            search_mode = PREFIX;\n\n            if (old_search_mode != PREFIX)\n            {\n              old_search_mode = PREFIX;\n              clean_matches(&search_data, word_real_max_size);\n            }\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n            break;\n          }\n          else\n            goto special_cmds_when_searching;\n\n          break;\n\n        kins:\n          if (help_mode)\n            break;\n\n          /* The INS key has been pressed to tag a word if */\n          /* tagging is enabled.                           */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (toggles.taggable && word_a[current].tag_id == 0)\n          {\n            word_a[current].tag_id = win.next_tag_id++;\n            tagged_words++;\n\n            if (toggles.pinable)\n              word_a[current].tag_order = tag_nb++;\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          break;\n\n        kdel:\n          if (help_mode)\n            break;\n\n          /* The DEL key has been pressed to untag a word if */\n          /* tagging is enabled.                             */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (toggles.taggable && word_a[current].tag_id > 0)\n          {\n            word_a[current].tag_id = 0;\n            tagged_words--;\n\n            /* We do not try to change tag_nb here to guaranty that */\n            /* tag_nb will be greater than all those already stored */\n            /* in all word_a[*].tag_order.                          */\n            /* '''''''''''''''''''''''''''''''''''''''''''''''''''' */\n\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          break;\n\n        case 't':\n          if (help_mode)\n            break;\n\n          /* t has been pressed to tag/untag a word if */\n          /* tagging is enabled.                       */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              if (word_a[current].tag_id > 0)\n              {\n                word_a[current].tag_id = 0;\n                tagged_words--;\n              }\n              else\n              {\n                word_a[current].tag_id = win.next_tag_id++;\n                tagged_words++;\n\n                if (toggles.pinable)\n                  word_a[current].tag_order = tag_nb++;\n              }\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        case 'u':\n          if (help_mode)\n            break;\n\n          /* u has been pressed to untag a word if */\n          /* tagging is enabled.                   */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              if (word_a[current].tag_id > 0)\n              {\n                word_a[current].tag_id = 0;\n                tagged_words--;\n\n                nl = disp_lines(&win,\n                                &toggles,\n                                current,\n                                count,\n                                search_mode,\n                                &search_data,\n                                &term,\n                                last_line,\n                                tmp_word,\n                                &langinfo);\n              }\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        case 20:\n          /* (CTRL-t) Remove all tags. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable && (win.next_tag_id > 1 || marked >= 0))\n            {\n              tagged_words    = 0;\n              win.next_tag_id = 1;\n              marked          = -1;\n\n              for (wi = 0; wi < count; wi++)\n              {\n                word_a[wi].tag_id    = 0;\n                word_a[wi].tag_order = 0;\n              }\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        tag_column:\n        case 'c':\n          if (help_mode)\n            break;\n\n          /* Tag all the words in the current column. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable || toggles.pinable)\n            {\n              long col, cur_col, marked_col;\n              long first, last;\n\n              int tagged;\n\n              if (!win.col_mode)\n                break;\n\n              /* Get the current column number. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              cur_col = current\n                        - first_word_in_line_a[line_nb_of_word_a[current]] + 1;\n\n              /* Determine the loop values according to the existence of */\n              /* a marked word and is value.                             */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (marked == -1)\n              {\n                first = 0;\n                last  = count - 1;\n              }\n              else\n              {\n                marked_col = marked\n                             - first_word_in_line_a[line_nb_of_word_a[marked]]\n                             + 1;\n\n                /* Ignore the marked word is its is not on the same column */\n                /* as the current word.                                    */\n                /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                if (cur_col == marked_col)\n                {\n                  if (marked <= current)\n                  {\n                    first = first_word_in_line_a[line_nb_of_word_a[marked]];\n                    last  = current;\n                  }\n                  else\n                  {\n                    first = first_word_in_line_a[line_nb_of_word_a[current]];\n                    last  = marked;\n\n                    /* Pre-increment tag_nb with is maximum mulue as     */\n                    /* it will be decremented in the following loop when */\n                    /* marked > current                                  */\n                    /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n                    tag_nb += marked - current + 1;\n                  }\n                }\n                else\n                  break;\n              }\n\n              /* Tag from first to last. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              col    = 0;\n              tagged = 0;\n\n              for (wi = first; wi <= last; wi++)\n              {\n                col++;\n                if (col == cur_col && word_a[wi].is_selectable\n                    && word_a[wi].tag_id == 0)\n                {\n                  word_a[wi].tag_id = win.next_tag_id;\n                  tagged_words++;\n\n                  if (toggles.pinable)\n                  {\n                    if (marked <= current)\n                      word_a[wi].tag_order = tag_nb++;\n                    else\n                      word_a[wi].tag_order = tag_nb--;\n                  }\n\n                  tagged = 1;\n                }\n\n                /* Time to go back to column 1? */\n                /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n                if (word_a[wi].is_last)\n                  col = 0;\n              }\n\n              if (tagged)\n                win.next_tag_id++;\n\n              if (marked > current)\n                tag_nb += marked - current + 1;\n\n              marked = -1;\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        case 'C':\n          /* Allow to tag part of a column, the first invocation marks    */\n          /* the starting word and the second marks the words in between. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            /* Mark the first word is not already marked. */\n            /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n            if (!win.col_mode)\n              break;\n\n            if (!toggles.taggable && !toggles.pinable)\n              break;\n\n            if (marked == -1)\n              goto mark_word;\n\n            goto tag_column;\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        tag_line:\n        case 'r':\n          /* Tag all the words in the current line. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable || toggles.pinable)\n            {\n              long first, last;\n              long marked_line;\n              int  tagged;\n\n              if (!win.col_mode && !win.line_mode)\n                break;\n\n              if (marked >= 0)\n              {\n                marked_line = line_nb_of_word_a[marked];\n                if (marked_line == line_nb_of_word_a[current])\n                {\n                  if (marked <= current)\n                  {\n                    first = marked;\n                    last  = current;\n                  }\n                  else\n                  {\n                    first = current;\n                    last  = marked;\n\n                    /* Pre-increment tag_nb with is maximum mulue as     */\n                    /* it will be decremented in the following loop when */\n                    /* marked > current                                  */\n                    /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n                    tag_nb += marked - current + 1;\n                  }\n                }\n                else\n                  break;\n              }\n              else\n              {\n                first = first_word_in_line_a[line_nb_of_word_a[current]];\n                if (line_nb_of_word_a[current] == line_nb_of_word_a[count - 1])\n                  last = count - 1;\n                else\n                  last = first_word_in_line_a[line_nb_of_word_a[current] + 1]\n                         - 1;\n              }\n\n              /* Tag from first to last. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              wi     = first;\n              tagged = 0;\n\n              do\n              {\n                if (word_a[wi].is_selectable)\n                {\n                  if (word_a[wi].tag_id == 0)\n                  {\n                    word_a[wi].tag_id = win.next_tag_id;\n                    tagged_words++;\n\n                    if (toggles.pinable)\n                    {\n                      if (marked <= current)\n                        word_a[wi].tag_order = tag_nb++;\n                      else\n                        word_a[wi].tag_order = tag_nb--;\n                    }\n\n                    tagged = 1;\n                  }\n                }\n                wi++;\n              } while (wi <= last);\n\n              if (tagged)\n                win.next_tag_id++;\n\n              if (marked > current)\n                tag_nb += marked - current + 1;\n\n              marked = -1;\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        case 'R':\n          /* Make sure that all the words in the current line */\n          /* are not tagged.                                  */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (!win.col_mode && !win.line_mode)\n              break;\n\n            if (!toggles.taggable && !toggles.pinable)\n              break;\n\n            if (marked == -1)\n              goto mark_word;\n\n            goto tag_line;\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        mark_word:\n        case 'm':\n          /* Mark the current word (ESC clears the mark). */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              marked = current;\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        unmark_word:\n        case 'M':\n          if (help_mode)\n            break;\n\n          /* unmark the current word (ESC clears the mark). */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              marked = -1;\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        tag_to_mark:\n        case 'T':\n          /* T has been pressed to tag all matching words resulting */\n          /* from a previous search if tagging is enabled.          */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              long i;\n\n              /* Is words have been matched by a recent search, tag them. */\n              /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n              if (BUF_LEN(matching_words_da) > 0 && marked == -1)\n              {\n                int tagged = 0;\n\n                for (i = 0; i < (long)BUF_LEN(matching_words_da); i++)\n                {\n                  wi = matching_words_da[i];\n\n                  if (word_a[wi].tag_id == 0)\n                  {\n                    word_a[wi].tag_id = win.next_tag_id;\n                    tagged_words++;\n\n                    if (toggles.pinable)\n                      word_a[wi].tag_order = tag_nb++;\n\n                    tagged = 1;\n                  }\n                }\n                if (tagged)\n                  win.next_tag_id++;\n              }\n              else /* Tag word between the marked and current words. */\n              {\n                if (marked == -1)\n                  goto mark_word;\n\n                {\n                  long first, last;\n                  int  tagged = 0;\n\n                  if (marked <= current)\n                  {\n                    first = marked;\n                    last  = current;\n                  }\n                  else\n                  {\n                    first = current;\n                    last  = marked;\n\n                    /* Pre-increment tag_nb with is maximum mulue as     */\n                    /* it will be decremented in the following loop when */\n                    /* marked > current                                  */\n                    /* ''''''''''''''''''''''''''''''''''''''''''''''''' */\n                    tag_nb += marked - current + 1;\n                  }\n\n                  tagged = 0;\n\n                  for (wi = first; wi <= last; wi++)\n                  {\n                    if (!word_a[wi].is_selectable)\n                      continue;\n\n                    if (word_a[wi].tag_id == 0)\n                    {\n                      word_a[wi].tag_id = win.next_tag_id;\n                      tagged_words++;\n\n                      if (toggles.pinable)\n                      {\n                        if (marked <= current)\n                          word_a[wi].tag_order = tag_nb++;\n                        else\n                          word_a[wi].tag_order = tag_nb--;\n                      }\n\n                      tagged = 1;\n                    }\n                  }\n\n                  if (tagged)\n                    win.next_tag_id++;\n\n                  if (marked > current)\n                    tag_nb += marked - current + 1;\n\n                  marked = -1;\n                }\n              }\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        adaptative_tag_to_mark:\n        case 'Z':\n          /* Z has been pressed to tag consecutive word in a given zone . */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              if (marked == -1)\n                marked = current;\n              else if (marked == current)\n                marked = -1;\n              else if (marked >= 0 && win.col_mode)\n              {\n                long cur_col =\n                  current - first_word_in_line_a[line_nb_of_word_a[current]]\n                  + 1;\n                long mark_col =\n                  marked - first_word_in_line_a[line_nb_of_word_a[marked]] + 1;\n                if (cur_col == mark_col)\n                  goto tag_column;\n                else if (line_nb_of_word_a[current]\n                         == line_nb_of_word_a[marked])\n                  goto tag_line;\n                else\n                  goto tag_to_mark;\n              }\n              else if (marked >= 0)\n              {\n                if (win.line_mode\n                    && line_nb_of_word_a[current] == line_nb_of_word_a[marked])\n                  goto tag_line;\n                else\n                  goto tag_to_mark;\n              }\n            }\n            nl = disp_lines(&win,\n                            &toggles,\n                            current,\n                            count,\n                            search_mode,\n                            &search_data,\n                            &term,\n                            last_line,\n                            tmp_word,\n                            &langinfo);\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        case 'U':\n          /* U has been pressed to undo the last tagging operation. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          if (help_mode)\n            break;\n\n          if (search_mode == NONE)\n          {\n            if (toggles.taggable)\n            {\n              for (wi = 0; wi < count; wi++)\n              {\n                if (!word_a[wi].is_selectable)\n                  continue;\n\n                if (word_a[wi].tag_id > 0)\n                {\n                  if (word_a[wi].tag_id == win.next_tag_id - 1)\n                  {\n                    word_a[wi].tag_id = 0;\n                    tagged_words--;\n                  }\n                }\n              }\n\n              if (win.next_tag_id > 1)\n                win.next_tag_id--;\n\n              nl = disp_lines(&win,\n                              &toggles,\n                              current,\n                              count,\n                              search_mode,\n                              &search_data,\n                              &term,\n                              last_line,\n                              tmp_word,\n                              &langinfo);\n            }\n          }\n          else\n            goto special_cmds_when_searching;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n "
        },
        {
          "name": "smenu.gif",
          "type": "blob",
          "size": 204.3388671875,
          "content": null
        },
        {
          "name": "smenu.h",
          "type": "blob",
          "size": 31.8203125,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef SMENU_H\n#define SMENU_H\n\n#define CHARSCHUNK 8\n#define WORDSCHUNK 8\n#define COLSCHUNK 16\n\n#define TPARM1(p) tparm(p, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n#define TPARM2(p, q) tparm(p, q, 0, 0, 0, 0, 0, 0, 0, 0)\n#define TPARM3(p, q, r) tparm(p, q, r, 0, 0, 0, 0, 0, 0, 0)\n\n#define _XOPEN_SOURCE 700\n\n/* Used for timers management. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n#define SECOND 1000000\n#define FREQ 10\n#define TCK (SECOND / FREQ)\n\n/* Large bit array management written by           */\n/* Scott Dudley, Auke Reitsma and Bob Stout.       */\n/* Assumes CHAR_BIT is one of either 8, 16, or 32. */\n/* Public domain.                                  */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n#define MASK (CHAR_BIT - 1)\n#define SHIFT ((CHAR_BIT == 8) ? 3 : (CHAR_BIT == 16) ? 4 : 8)\n\n#define BIT_OFF(a, x) ((void)((a)[(x) >> SHIFT] &= ~(1 << ((x) & MASK))))\n#define BIT_ON(a, x) ((void)((a)[(x) >> SHIFT] |= (1 << ((x) & MASK))))\n#define BIT_FLIP(a, x) ((void)((a)[(x) >> SHIFT] ^= (1 << ((x) & MASK))))\n#define BIT_ISSET(a, x) ((a)[(x) >> SHIFT] & (1 << ((x) & MASK)))\n\n/* ********* */\n/* Typedefs. */\n/* ********* */\n\ntypedef struct charsetinfo_s     charsetinfo_t;\ntypedef struct term_s            term_t;\ntypedef struct toggle_s          toggle_t;\ntypedef struct win_s             win_t;\ntypedef struct word_s            word_t;\ntypedef struct attrib_s          attrib_t;\ntypedef struct limit_s           limit_t;\ntypedef struct ticker_s          ticker_t;\ntypedef struct misc_s            misc_t;\ntypedef struct mouse_s           mouse_t;\ntypedef struct sed_s             sed_t;\ntypedef struct timeout_s         timeout_t;\ntypedef struct output_s          output_t;\ntypedef struct daccess_s         daccess_t;\ntypedef struct search_data_s     search_data_t;\ntypedef struct attr_elem_s       attr_elem_t;\ntypedef struct help_entry_s      help_entry_t;\ntypedef struct help_attr_entry_s help_attr_entry_t;\n\n/* ****** */\n/* Enums. */\n/* ****** */\n\n/* Various filter pseudo constants. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum filter_types\n{\n  UNKNOWN_FILTER,\n  INCLUDE_FILTER,\n  EXCLUDE_FILTER\n} filters_t;\n\n/* Types of selectors. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum selector_types\n{\n  IN,      /* Inclusion. */\n  EX,      /* Exclusion. */\n  ALEFT,   /* Alignment to the left. */\n  ARIGHT,  /* Alignment to the right. */\n  ACENTER, /* Alignment to the center. */\n  ATTR     /* Attribute. */\n} selector_t;\n\n/* Used by the -N -F and -D options. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum daccess_modes\n{\n  DA_TYPE_NONE = 0, /* must be 0 (boolean value). */\n  DA_TYPE_AUTO = 1,\n  DA_TYPE_POS  = 2\n} da_mode_t;\n\n/* Various timeout mode used by the -x/-X option. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum timeout_modes\n{\n  CURRENT, /* on timeout, outputs the selected word.       */\n  QUIT,    /* on timeout, quit without selecting anything. */\n  WORD     /* on timeout , outputs the specified word.     */\n} to_mode_t;\n\n/* Constants used to set the color attributes. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum attribute_settings\n{\n  UNSET = 0, /* must be 0 for future testings. */\n  SET,\n  FORCED /* an attribute setting has been given in the command line. */\n} attr_set_t;\n\n/* Method used to interpret the color numbers. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum color_method\n{\n  CLASSIC,\n  ANSI\n} color_method_t;\n\n/* Constant to distinguish between the various search modes. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum search_modes\n{\n  NONE,\n  PREFIX,\n  FUZZY,\n  SUBSTRING\n} search_mode_t;\n\n/* Constants used in search mode to orient the bit-mask building. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\ntypedef enum bitmap_affinities\n{\n  NO_AFFINITY,\n  END_AFFINITY,\n  START_AFFINITY\n} bitmap_affinity_t;\n\ntypedef enum alignment\n{\n  AL_NONE,\n  AL_LEFT,\n  AL_RIGHT,\n  AL_CENTERED\n} alignment_t;\n\n/* Used when managing the -C option. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nenum\n{\n  EXCLUDE_MARK      = 0, /* must be 0 because used in various tests      *\n                          | these words cannot be re-included.           */\n  INCLUDE_MARK      = 1, /* to forcibly include a word, these words can  *\n                          | be excluded later.                           */\n  SOFT_EXCLUDE_MARK = 2, /* word with this mark are excluded by default  *\n                          | but can be included later.                   */\n  SOFT_INCLUDE_MARK = 3  /* word with this mark are included by default  *\n                          | but can be excluded later.                   */\n};\n\n/* Mouse protocols. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nenum\n{\n  MOUSE1000, /* VT200          */\n  MOUSE1006, /* SGR_EXT_MODE   */\n  MOUSE1015  /* URXVT_EXT_MODE */\n};\n\n/* ******* */\n/* Structs */\n/* ******* */\n\n/* Used to store the different allowed charsets data. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct charsetinfo_s\n{\n  char *name; /* canonical name of the allowed charset. */\n  int   bits; /* number of bits in this charset.        */\n};\n\n/* Various toggles which can be set with command line options. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct toggle_s\n{\n  int del_line;            /* 1 if the clean option is set (-d) else 0.   */\n  int enter_val_in_search; /* 1 if ENTER validates in search mode else 0. */\n  int no_scrollbar;        /* 1 to disable the scrollbar display else 0.  */\n  int no_hor_scrollbar;    /* 1 to disable the horizontab scrollbar       *\n                            | display else 0.                             */\n  int hor_scrollbar;       /* 1 to always enable the scrollbar display    *\n                            * when lines are truncated in line/col mode   *\n                            * else 0.                                     */\n  int blank_nonprintable;  /* 1 to try to display non-blanks in           *\n                            | symbolic form else 0.                       */\n  int keep_spaces;         /* 1 to keep the trailing spaces in columns    *\n                            | and tabulate mode.                          */\n  int taggable;            /* 1 if tagging is enabled.                    */\n  int pinable;             /* 1 if pinning is selected.                   */\n  int autotag;             /* 1 if tagging is selected and pinning is     *\n                            | not and we do no want an automatic tagging  *\n                            | when the users presses <ENTER>.             */\n  int noautotag;           /* 1 if the word under the cursor must not be  *\n                            | autotagged when no other word are tagged.   */\n  int visual_bell;         /* 1 to flash the window, 0 to make a sound.   */\n  int incremental_search;  /* 1 makes the searching process incremental.  *\n                            | 0 keeps it forgetful.                       */\n  int no_mouse;            /* 1 to disable the possibly auto-detected     *\n                            | mouse, 0 to let smenu auto-detect it.       */\n  int show_blank_words;    /* 1 if blank words are allowed then they will *\n                            | be filled by an underscore, 0 to leave them *\n                            | blank.                                      */\n  int cols_first;          /* 1 if column alignment has priority over     *\n                            | row alignment else 0.                       */\n  int rows_first;          /* 1 if row alignment has priority over        *\n                            | column alignment else 0.                    */\n};\n\n/* Structure to store the default or imposed smenu limits. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct limit_s\n{\n  long word_length; /* maximum number of bytes in a word. */\n  long words;       /* maximum number of words.           */\n  long cols;        /* maximum number of columns.         */\n};\n\n/* Structure to store the default or imposed timers. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct ticker_s\n{\n  int search;\n  int forgotten;\n  int help;\n  int winch;\n  int direct_access;\n};\n\n/* Structure to store miscellaneous information. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct misc_s\n{\n  search_mode_t default_search_method;\n  char          invalid_char_substitute;\n  char          blank_char_substitute;\n  char          ignore_quotes;\n};\n\n/* Structure to store mouse information. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct mouse_s\n{\n  int double_click_delay;\n  int button[3];\n};\n\n/* Structure containing the attributes components. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct attrib_s\n{\n  attr_set_t  is_set;\n  short       fg;\n  short       bg;\n  signed char bold;\n  signed char dim;\n  signed char reverse;\n  signed char standout;\n  signed char underline;\n  signed char italic;\n  signed char invis;\n  signed char blink;\n};\n\n/* Structure containing some terminal characteristics. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct term_s\n{\n  int            ncolumns;     /* number of columns.                     */\n  int            nlines;       /* number of lines.                       */\n  int            curs_column;  /* current cursor column.                 */\n  int            curs_line;    /* current cursor line.                   */\n  short          colors;       /* number of available colors.            */\n  color_method_t color_method; /* color method (CLASSIC (0-7), ANSI).    */\n\n  char has_cursor_up;         /* has cuu1 terminfo capability.           */\n  char has_cursor_down;       /* has cud1 terminfo capability.           */\n  char has_cursor_left;       /* has cub1 terminfo capability.           */\n  char has_cursor_right;      /* has cuf1 terminfo capability.           */\n  char has_parm_right_cursor; /* has cuf terminfo capability.            */\n  char has_cursor_address;    /* has cup terminfo capability.            */\n  char has_save_cursor;       /* has sc terminfo capability.             */\n  char has_restore_cursor;    /* has rc terminfo capability.             */\n  char has_setf;              /* has set_foreground terminfo capability. */\n  char has_setb;              /* has set_background terminfo capability. */\n  char has_setaf;             /* idem for set_a_foreground (ANSI).       */\n  char has_setab;             /* idem for set_a_background (ANSI).       */\n  char has_hpa;               /* has column_address terminfo capability. */\n  char has_bold;              /* has bold mode.                          */\n  char has_dim;               /* has dim mode.                           */\n  char has_reverse;           /* has reverse mode.                       */\n  char has_underline;         /* has underline mode.                     */\n  char has_standout;          /* has standout mode.                      */\n  char has_italic;            /* has italic mode.                        */\n  char has_invis;             /* has invis mode.                         */\n  char has_blink;             /* has blink mode.                         */\n  char has_kmous;             /* has mouse reporting.                    */\n  char has_rep;               /* has repeact char.                       */\n};\n\n/* Structure describing a word. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct word_s\n{\n  long           start, end;    /* start/end absolute horiz. word positions *\n                                 | on the screen.                           */\n  size_t         mb;            /* number of UTF-8 glyphs to display.       */\n  long           tag_order;     /* each time a word is tagged, this value.  *\n                                 | is increased.                            */\n  unsigned short tag_id;        /* tag id. 0 means no tag.                  */\n  unsigned char  is_matching;   /* word is matching a search ERE.           */\n  unsigned char  is_last;       /* 1 if the word is the last of a line.     */\n  unsigned char  is_selectable; /* word is selectable.                      */\n  unsigned char  is_numbered;   /* word has a direct access index.          */\n  unsigned char  special_level; /* can vary from 0 to 9; 0 meaning normal.  */\n  char          *str;           /* display string associated with this word */\n  size_t         len;           /* number of bytes of str (for trimming).   */\n  char          *orig;          /* NULL or original string if is had been.  *\n                                 | shortened for being displayed or altered *\n                                 | by is expansion.                         */\n  char          *bitmap;        /* used to store the position of the.       *\n                                 | currently searched chars in a word. The  *\n                                 | objective is to speed their display.     */\n  attrib_t      *iattr;         /* Specific attribute set with the -Ra/-Ca  *\n                                 | options.                                 */\n};\n\n/* Structure describing the window in which the user  */\n/* will be able to select a word.                     */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct win_s\n{\n  long     start, end;      /* index of the first and last word.        */\n  int      first_column;    /* number of the first character displayed. */\n  int      cur_line;        /* relative number of the cursor line (1+). */\n  int      asked_max_lines; /* requested number of lines in the window. */\n  int      has_hbar;        /* 1 if an horizontal bar must be           *\n                             | displayed else 0.                        */\n  int      hbar_displayed;  /* 1 if an hozizontal bas has ever been     *\n                             | displayed else 0.                        */\n  int      max_lines;       /* effective number of lines in the window. */\n  int      max_cols;        /* max number of words in a single line.    */\n  int      real_max_width;  /* max line length. In column, tab or line  *\n                             | mode it can be greater than the          *\n                             | terminal width.                          */\n  int      message_lines;   /* number of lines taken by the messages    *\n                             | (updated by disp_message.                */\n  int      max_width;       /* max usable line width or the terminal.   */\n  int      offset;          /* Left margin, used in centered mode.      */\n  char    *sel_sep;         /* output separator when tags are enabled.  */\n  char   **gutter_a;        /* array of UTF-8 gutter glyphs.            */\n  int      gutter_nb;       /* number of UTF-8 gutter glyphs.           */\n  int      sb_column;       /* scroll bar column (-1) if no scroll bar. */\n  unsigned next_tag_id;     /* Next tag ID, increased on each tagging   *\n                             | operation.                               */\n\n  unsigned char tab_mode;  /* -t */\n  unsigned char col_mode;  /* -c */\n  unsigned char line_mode; /* -l */\n  unsigned char col_sep;   /* -g */\n  unsigned char wide;      /* -w */\n  unsigned char center;    /* -M */\n\n  unsigned char has_truncated_lines; /* 1 if win has tr. lines else 0. */\n\n  attrib_t cursor_attr;               /* current cursor attributes.          */\n  attrib_t cursor_marked_attr;        /* current cursor when a mark is set.  */\n  attrib_t cursor_on_marked_attr;     /* current cursor on marked word       *\n                                       | attributes.                         */\n  attrib_t cursor_on_tag_attr;        /* current cursor on tag attributes.   */\n  attrib_t cursor_on_tag_marked_attr; /* current cursor on tag attributes    *\n                                       | if current word is marked.          */\n  attrib_t marked_attr;               /* marked word.                        */\n  attrib_t bar_attr;                  /* scrollbar attributes.               */\n  attrib_t shift_attr;                /* shift indicator attributes.         */\n  attrib_t message_attr;              /* message (title) attributes.         */\n  attrib_t search_field_attr;         /* search mode field attributes.       */\n  attrib_t search_text_attr;          /* search mode text attributes.        */\n  attrib_t search_err_field_attr;     /* bad search mode field attributes.   */\n  attrib_t search_err_text_attr;      /* bad search mode text attributes.    */\n  attrib_t match_field_attr;          /* matching word field attributes.     */\n  attrib_t match_text_attr;           /* matching word text attributes.      */\n  attrib_t match_err_field_attr;      /* bad matching word field attributes. */\n  attrib_t match_err_text_attr;       /* bad matching word text attributes.  */\n  attrib_t include_attr;              /* selectable words attributes.        */\n  attrib_t exclude_attr;              /* non-selectable words attributes.    */\n  attrib_t tag_attr;                  /* non-selectable words attributes.    */\n  attrib_t daccess_attr;              /* direct access tag attributes.       */\n  attrib_t special_attr[9];           /* special (-1,...) words attributes.  */\n};\n\n/* Sed like node structure. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct sed_s\n{\n  char         *pattern;      /* pattern to be matched.                    */\n  char         *substitution; /* substitution string.                      */\n  unsigned char visual;       /* visual flag: alterations are only visual. */\n  unsigned char global;       /* global flag: alterations can occur more   *\n                               | than once.                                */\n  unsigned char stop;         /* stop flag:   only one alteration per word *\n                               | is allowed.                               */\n  regex_t       re;           /* compiled regular expression.              */\n};\n\n/* Structure used to keep track of the different timeout values. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct timeout_s\n{\n  to_mode_t mode;          /* timeout mode: current/quit/word. */\n  unsigned  initial_value; /* 0: no timeout else value in sec. */\n  unsigned  remain;        /* remaining seconds.               */\n  unsigned  reached;       /* 1: timeout has expired, else 0.  */\n};\n\n/* Structure used during the construction of the pinned words list. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct output_s\n{\n  long  order;      /* this field is incremented each time a word is *\n                     | pinned.                                       */\n  char *output_str; /* The pinned word itself.                       */\n};\n\n/* Structure describing the formatting of the automatic */\n/* direct access entries.                               */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct daccess_s\n{\n  da_mode_t mode;       /* DA_TYPE_NONE (0), DA_TYPE_AUTO, DA_TYPE_POS.    */\n  char     *left;       /* character to put before the direct access       *\n                         | selector.                                       */\n  char     *right;      /* character to put after the direct access        *\n                         | selector.                                       */\n  char      alignment;  /* l: left; r: right.                              */\n  char      padding;    /* a: all; i: only included words are padded.      */\n  char      head;       /* What to do with chars before the embedded       *\n                         | number.                                         */\n  int       length;     /* selector size (5 max).                          */\n  int       flength;    /* 0 or length + 3 (full prefix length.            */\n  size_t    offset;     /* offset to the start of the selector.            */\n  char      missing;    /* y: number missing embedded numbers.             */\n  int       plus;       /* 1 if we can look for the number to extract      *\n                         | after the offset, else 0. (a '+' follows the    *\n                         | offset).                                        */\n  int       size;       /* size in bytes of the selector to extract.       */\n  size_t    ignore;     /* number of UTF-8 glyphs to ignore after the      *\n                         | number.                                         */\n  char      follow;     /* y: the numbering follows the last number set.   */\n  char     *num_sep;    /* character to separate number and selection.     */\n  int       def_number; /* 1: the numbering is on by default 0: it is not. */\n};\n\n/* Structure used in search mod to store the current buffer and various   */\n/* related values.                                                        */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct search_data_s\n{\n  char *buf;        /* search buffer.                            */\n  long  len;        /* current position in the search buffer.    */\n  long  utf8_len;   /* current position in the search buffer in  *\n                     | UTF-8 units.                              */\n  long *utf8_off_a; /* array of mb offsets in buf.               */\n  long *utf8_len_a; /* array of mb lengths in buf.               */\n\n  int  err;           /* match error indicator.                  */\n  long fuzzy_err_pos; /* last good position in search buffer.    */\n\n  int only_ending;   /* only searches giving a result with the.  *\n                      | pattern at the end of the word will be   *\n                      | selected.                                */\n  int only_starting; /* same with the pattern at the beginning.  */\n};\n\n/* Structure used to store an attribute and the list of elements      */\n/* (columns, rows or RE) for which this attribute must be the default */\n/* one.                                                               */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct attr_elem_s\n{\n  attrib_t *attr; /* Attribute                           */\n  ll_t     *list; /* list of RE or intervals of columns. */\n};\n\nstruct help_entry_s\n{\n  char *str; /* string to be displayed for an object in the help line. */\n  int   len; /* screen space taken by of one of these objects.         */\n  char *main_attr_str; /* Style attribute when colors are available.   */\n  char *alt_attr_str;  /* Style attribute when colors are missing.     */\n  char *flags;         /* string which can only contain occurrences of *\n                        | c: only on column/line mode,                 *\n                        | t: only in tag mode,                         *\n                        | m: -no_mouse is set.                         */\n};\n\nstruct help_attr_entry_s\n{\n  char     *str;  /* string to be displayed for an object in the help line. */\n  int       len;  /* screen space taken by of one of these objects.         */\n  attrib_t *attr; /* attribute.                                             */\n};\n\n/* *********** */\n/* Prototypes. */\n/* *********** */\n\nattrib_t *\nattr_new(void);\n\nint\nhelp_add_entries(win_t               *win,\n                 term_t              *term,\n                 toggle_t            *toggles,\n                 help_attr_entry_t ***help_items_da,\n                 help_entry_t        *entries,\n                 int                  entries_nb);\n\nhelp_attr_entry_t ***\ninit_help(win_t               *win,\n          term_t              *term,\n          toggle_t            *toggles,\n          long                 last_line,\n          help_attr_entry_t ***help_items_da);\n\nvoid\ndisp_help(win_t               *win,\n          term_t              *term,\n          help_attr_entry_t ***help_da,\n          int                  first_help_line);\n\nint\ntag_comp(void const *a, void const *b);\n\nvoid\ntag_swap(void **a, void **b);\n\nint\nisempty(const char *s);\n\nvoid\nmy_beep(toggle_t *toggles);\n\nint\nget_cursor_position(int * const r, int * const c);\n\nvoid\nget_terminal_size(int * const r, int * const c, term_t *term);\n\nint\n#ifdef __sun\noutch(char c);\n#else\noutch(int c);\n#endif\n\nvoid\nrestore_term(int const fd, struct termios *old);\n\nvoid\nsetup_term(int const fd, struct termios *old, struct termios *new);\n\nvoid\nstrip_ansi_color(char *s, toggle_t *toggles, misc_t *misc);\n\nint\ntst_cb(void *elem);\n\nint\ntst_cb_cli(void *elem);\n\nint\nini_load(const char *filename,\n         win_t      *win,\n         term_t     *term,\n         limit_t    *limits,\n         ticker_t   *timers,\n         misc_t     *misc,\n         mouse_t    *mouse,\n         int (*report)(win_t      *win,\n                       term_t     *term,\n                       limit_t    *limits,\n                       ticker_t   *timers,\n                       misc_t     *misc,\n                       mouse_t    *mouse,\n                       const char *section,\n                       const char *name,\n                       char       *value));\n\nint\nini_cb(win_t      *win,\n       term_t     *term,\n       limit_t    *limits,\n       ticker_t   *timers,\n       misc_t     *misc,\n       mouse_t    *mouse,\n       const char *section,\n       const char *name,\n       char       *value);\n\nchar *\nmake_ini_path(char *name, char *base);\n\nshort\ncolor_transcode(short color);\n\nvoid\nset_foreground_color(term_t *term, short color);\n\nvoid\nset_background_color(term_t *term, short color);\n\nvoid\nset_win_start_end(win_t *win, long current, long last);\n\nlong\nbuild_metadata(term_t *term, long count, win_t *win);\n\nlong\ndisp_lines(win_t         *win,\n           toggle_t      *toggles,\n           long           current,\n           long           count,\n           search_mode_t  search_mode,\n           search_data_t *search_data,\n           term_t        *term,\n           long           last_line,\n           char          *tmp_word,\n           langinfo_t    *langinfo);\n\nvoid\nget_message_lines(char *message,\n                  ll_t *message_lines_list,\n                  long *message_max_width,\n                  long *message_max_len);\n\nvoid\ndisp_message(ll_t       *message_lines_list,\n             long        width,\n             long        max_len,\n             term_t     *term,\n             win_t      *win,\n             langinfo_t *langinfo);\n\nint\ncheck_integer_constraint(int nb_args, char **args, char *value, char *par);\n\nvoid\nupdate_bitmaps(search_mode_t     search_mode,\n               search_data_t    *search_data,\n               bitmap_affinity_t affinity);\n\nlong\nfind_next_matching_word(long *array, long nb, long value, long *index);\n\nlong\nfind_prev_matching_word(long *array, long nb, long value, long *index);\n\nvoid\nclean_matches(search_data_t *search_data, long size);\n\nvoid\ndisp_cursor_word(long pos, win_t *win, term_t *term, int err);\n\nvoid\ndisp_matching_word(long pos, win_t *win, term_t *term, int is_cursor, int err);\n\nvoid\ndisp_word(long           pos,\n          search_mode_t  search_mode,\n          search_data_t *search_data,\n          term_t        *term,\n          win_t         *win,\n          toggle_t      *toggles,\n          char          *tmp_word);\n\nsize_t\nexpand(char       *src,\n       char       *dest,\n       langinfo_t *langinfo,\n       toggle_t   *toggles,\n       misc_t     *misc);\n\nint\nread_bytes(FILE       *input,\n           char       *utf8_buffer,\n           ll_t       *ignored_glyphs_list,\n           langinfo_t *langinfo,\n           misc_t     *misc);\n\nint\nget_scancode(unsigned char *s, size_t max);\n\nchar *\nread_word(FILE          *input,\n          ll_t          *word_delims_list,\n          ll_t          *line_delims_list,\n          ll_t          *ignored_glyphs_list,\n          char          *utf8_buffer,\n          unsigned char *is_last,\n          toggle_t      *toggles,\n          langinfo_t    *langinfo,\n          win_t         *win,\n          limit_t       *limits,\n          misc_t        *misc);\n\nvoid\nleft_margin_putp(char *s, term_t *term, win_t *win);\n\nvoid\nright_margin_putp(char       *s1,\n                  char       *s2,\n                  langinfo_t *langinfo,\n                  term_t     *term,\n                  win_t      *win,\n                  long        line,\n                  long        offset);\n\nvoid\nsig_handler(int s);\n\nvoid\nset_new_first_column(win_t *win, term_t *term);\n\nint\nparse_sed_like_string(sed_t *sed);\n\nvoid\nparse_selectors(char        *str,\n                filters_t   *filter,\n                char       **unparsed,\n                ll_t       **inc_interval_list,\n                ll_t       **inc_regex_list,\n                ll_t       **exc_interval_list,\n                ll_t       **exc_regex_list,\n                ll_t       **al_interval_list,\n                ll_t       **al_regex_list,\n                ll_t       **ar_interval_list,\n                ll_t       **ar_regex_list,\n                ll_t       **ac_interval_list,\n                ll_t       **ac_regex_list,\n                ll_t       **at_interval_list,\n                ll_t       **at_regex_list,\n                alignment_t *al_default,\n                win_t       *win,\n                misc_t      *misc,\n                term_t      *term);\n\nvoid\nparse_al_selectors(char        *str,\n                   char       **unparsed,\n                   ll_t       **al_regex_list,\n                   ll_t       **ar_regex_list,\n                   ll_t       **ac_regex_list,\n                   alignment_t *default_alignment,\n                   misc_t      *misc);\nint\nreplace(char *orig, sed_t *sed);\n\nint\ndecode_attr_toggles(char *s, attrib_t *attr);\n\nint\nparse_attr(char *str, attrib_t *attr, short max_color);\n\nvoid\napply_attr(term_t *term, attrib_t attr);\n\nlong\nget_line_last_word(long line, long last_line);\n\nvoid\nmove_left(win_t         *win,\n          term_t        *term,\n          toggle_t      *toggles,\n          search_data_t *search_data,\n          langinfo_t    *langinfo,\n          long          *nl,\n          long           last_line,\n          char          *tmp_word);\n\nvoid\nmove_right(win_t         *win,\n           term_t        *term,\n           toggle_t      *toggles,\n           search_data_t *search_data,\n           langinfo_t    *langinfo,\n           long          *nl,\n           long           last_line,\n           char          *tmp_word);\n\nint\nfind_best_word_upwards(long last_word, long s, long e);\n\nint\nfind_best_word_downwards(long last_word, long s, long e);\n\nvoid\nmove_up(win_t         *win,\n        term_t        *term,\n        toggle_t      *toggles,\n        search_data_t *search_data,\n        langinfo_t    *langinfo,\n        long          *nl,\n        long           page,\n        long           first_selectable,\n        long           last_line,\n        char          *tmp_word);\n\nvoid\nmove_down(win_t         *win,\n          term_t        *term,\n          toggle_t      *toggles,\n          search_data_t *search_data,\n          langinfo_t    *langinfo,\n          long          *nl,\n          long           page,\n          long           last_selectable,\n          long           last_line,\n          char          *tmp_word);\n\nvoid\ninit_main_ds(attrib_t  *init_attr,\n             win_t     *win,\n             limit_t   *limits,\n             ticker_t  *timers,\n             toggle_t  *toggles,\n             misc_t    *misc,\n             mouse_t   *mouse,\n             timeout_t *timeout,\n             daccess_t *daccess);\n\nvoid\nreset_search_buffer(win_t         *win,\n                    search_data_t *search_data,\n                    ticker_t      *timers,\n                    toggle_t      *toggles,\n                    term_t        *term,\n                    daccess_t     *daccess,\n                    langinfo_t    *langinfo,\n                    long           last_line,\n                    char          *tmp_word,\n                    long           word_real_max_size);\nint\nis_in_foreground_process_group(void);\n#endif\n\nlong\nget_clicked_index(win_t  *win,\n                  term_t *term,\n                  int     line_click,\n                  int     column_click,\n                  int    *error);\n\nvoid\nalign_word(word_t *word, alignment_t alignment, size_t prerfix, char sp);\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tinybuf.h",
          "type": "blob",
          "size": 7.0673828125,
          "content": "/* TinyBuf - simple dynamic array - public domain - Bernhard Schelling 2020\n   https://github.com/schellingb/c-data-structures\n         no warranty implied; use at your own risk\n\n   This file implements stretchy buffers as invented (?) by Sean Barrett.\n   Based on the implementation from the public domain Bitwise project\n   by Per Vognsen - https://github.com/pervognsen/bitwise\n\n   It's a super simple type safe dynamic array for C with no need\n   to predeclare any type or anything.\n   The first time an element is added, memory for 16 elements are allocated.\n   Then every time length is about to exceed capacity, capacity is doubled.\n   Can be used in C++ with POD types (without any constructor/destructor).\n\n   Be careful not to supply modifying statements to the macro arguments.\n   Something like BUF_REMOVE(buf, i--); would have unintended results.\n\n   --- Added by Pierre Gentile - p.gen.progs@gmail.com - 2024 ---\n   BUF_MALLOC and BUF_REALLOC can be #defined to specify alternative memory\n   allocation and reallocation functions.\n   When not #defined, the standard malloc and realloc functions are used.\n   --- End ---\n\n   Sample usage:\n\n   mytype_t* buf = NULL;\n   BUF_PUSH(buf, some_element);\n   BUF_PUSH(buf, other_element);\n   -- now BUF_LEN(buf) == 2, buf[0] == some_element, buf[1] == other_element\n\n   -- Free allocated memory:\n   BUF_FREE(buf);\n   -- now buf == NULL, BUF_LEN(buf) == 0, BUF_CAP(buf) == 0\n\n   -- Explicitly increase allocated memory and set capacity:\n   BUF_FIT(buf, 100);\n   -- now BUF_LEN(buf) == 0, BUF_CAP(buf) == 100\n\n   -- Resize buffer (does not initialize or zero memory!):\n   BUF_RESIZE(buf, 200);\n   -- now BUF_LEN(buf) == 200, BUF_CAP(buf) == 200\n\n   -- Remove an element in the middle, keeping order:\n   BUF_REMOVE(buf, 30);\n   -- now BUF_LEN(buf) == 199, everything past 30 shifted 1 up\n\n   -- Remove an element in the middle, swapping the last element into it:\n   BUF_SWAPREMOVE(buf, 10);\n   -- now BUF_LEN(buf) == 198, element 198 was copied into 10\n\n   -- Insert an element into the middle of the array:\n   BUF_INSERT(buf, 100, some_element);\n   -- now BUF_LEN(buf) == 199, everything past 99 shifted 1 down\n\n   -- Make a gap of a given size in the middle of the array:\n   mytype_t* ptr_gap = BUF_MAKEGAP(buf, 20, 11);\n   -- now BUF_LEN(buf) == 210, everything past 19 shifted 11 down\n\n   -- Add multiple elements at the end (uninitialized):\n   mytype_t* ptr1 = BUF_ADD(buf, 10);\n   -- now BUF_LEN(buf) == 220, ptr1 points to buf[210]\n\n   -- Add multiple elements at the end (zeroing memory):\n   mytype_t* ptr2 = BUF_ADDZEROED(buf, 10);\n   -- now BUF_LEN(buf) == 230, ptr2 points to buf[220]\n\n   -- To handle running out of memory:\n   bool ran_out_of_memory = !BUF_TRYFIT(buf, 1000);\n   -- before RESIZE or PUSH. When out of memory, buf will stay unmodified.\n\n   PUBLIC DOMAIN (UNLICENSE)\n\n   This is free and unencumbered software released into the public domain.\n\n   Anyone is free to copy, modify, publish, use, compile, sell, or\n   distribute this software, either in source code form or as a compiled\n   binary, for any purpose, commercial or non-commercial, and by any\n   means.\n\n   In jurisdictions that recognize copyright laws, the author or authors\n   of this software dedicate any and all copyright interest in the\n   software to the public domain. We make this dedication for the benefit\n   of the public at large and to the detriment of our heirs and\n   successors. We intend this dedication to be an overt act of\n   relinquishment in perpetuity of all present and future rights to this\n   software under copyright law.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n   OTHER DEALINGS IN THE SOFTWARE.\n\n   For more information, please refer to <http://unlicense.org/>\n*/\n\n#ifndef TINYBUF_H\n#define TINYBUF_H\n\n#include <stdlib.h> /* for malloc, realloc */\n#include <string.h> /* for memmove, memset */\n#include <stddef.h> /* for size_t */\n\n/* Query functions. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n#define BUF_LEN(b) ((b) ? BUF__HDR(b)->len : 0)\n#define BUF_CAP(b) ((b) ? BUF__HDR(b)->cap : 0)\n#define BUF_END(b) ((b) + BUF_LEN(b))\n#define BUF_SIZEOF(b) ((b) ? BUF_LEN(b) * sizeof(*b) : 0)\n\n/* Modifying functions. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n#define BUF_FREE(b) \\\n  ((b) ? (free(BUF__HDR(b)), (*(void **)(&(b)) = (void *)0)) : 0)\n\n#define BUF_FIT(b, n)        \\\n  ((size_t)(n) <= BUF_CAP(b) \\\n     ? 0                     \\\n     : (*(void **)(&(b)) = buf__grow((b), (size_t)(n), sizeof(*(b)))))\n\n#define BUF_PUSH(b, val) \\\n  (BUF_FIT((b), BUF_LEN(b) + 1), (b)[BUF__HDR(b)->len++] = (val))\n\n#define BUF_POP(b) (b)[--BUF__HDR(b)->len]\n\n#define BUF_RESIZE(b, sz) \\\n  (BUF_FIT((b), (sz)), ((b) ? BUF__HDR(b)->len = (sz) : 0))\n\n#define BUF_CLEAR(b) ((b) ? BUF__HDR(b)->len = 0 : 0)\n\n#define BUF_TRYFIT(b, n) \\\n  (BUF_FIT((b), (n)), (((b) && BUF_CAP(b) >= (size_t)(n)) || !(n)))\n\n/* Utility functions. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n#define BUF_SHIFT(b, to, fr, n) \\\n  ((b) ? memmove((b) + (to), (b) + (fr), (n) * sizeof(*(b))) : 0)\n\n#define BUF_REMOVE(b, idx) \\\n  (BUF_SHIFT(b, idx, (idx) + 1, --BUF__HDR(b)->len - (idx)))\n\n#define BUF_SWAPREMOVE(b, idx) (BUF_SHIFT(b, idx, --BUF__HDR(b)->len, 1))\n\n#define BUF_MAKEGAP(b, idx, sz)                                \\\n  (BUF_RESIZE((b), BUF_LEN(b) + (sz)),                         \\\n   BUF_SHIFT(b, (idx) + (sz), idx, BUF_LEN(b) - (idx) - (sz)), \\\n   (b) + (idx))\n\n#define BUF_INSERT(b, idx, val) (*BUF_MAKEGAP(b, idx, 1) = (val))\n\n#define BUF_ZERO(b, idx, n) (memset((b) + (idx), 0, (n) * sizeof(*(b))))\n\n#define BUF_ADD(b, n) \\\n  (BUF_FIT(b, BUF_LEN(b) + (n)), (b) + (BUF__HDR(b)->len += (n)) - (n))\n\n#define BUF_ADDZEROED(b, n)      \\\n  (BUF_FIT(b, BUF_LEN(b) + (n)), \\\n   BUF_ZERO(b, BUF_LEN(b), n),   \\\n   (b) + (BUF__HDR(b)->len += (n)) - (n))\n\n#define BUF__HDR(b) (((struct buf__hdr *)(b)) - 1)\n\nstruct buf__hdr\n{\n  size_t len, cap;\n};\n\n#ifdef __GNUC__\n__attribute__((__unused__))\n#elif defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable:4505) /* Unref. local function has been removed. */\n#endif\n\n#ifndef BUF_MALLOC\n#define BUF_MALLOC malloc\n#endif\n\n#ifndef BUF_REALLOC\n#define BUF_REALLOC realloc\n#endif\n\nstatic void *\nbuf__grow(void *buf, size_t new_len, size_t elem_size)\n{\n  struct buf__hdr *new_hdr;\n  size_t           new_cap = 2 * BUF_CAP(buf), new_size;\n\n  if (new_cap < new_len)\n    new_cap = new_len;\n\n  if (new_cap < 16)\n    new_cap = 16;\n\n  new_size = sizeof(struct buf__hdr) + new_cap * elem_size;\n  if (buf)\n  {\n    new_hdr = (struct buf__hdr *)BUF_REALLOC(BUF__HDR(buf), new_size);\n    if (!new_hdr)\n      return buf; /* Out of memory, return unchanged. */\n  }\n  else\n  {\n    new_hdr = (struct buf__hdr *)BUF_MALLOC(new_size);\n    if (!new_hdr)\n      return (void *)0; /* Out of memory. */\n    new_hdr->len = 0;\n  }\n  new_hdr->cap = new_cap;\n  return new_hdr + 1;\n}\n\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n#endif\n"
        },
        {
          "name": "usage.c",
          "type": "blob",
          "size": 13.125,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* **************** */\n/* Usage functions. */\n/* **************** */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"usage.h\"\n#include \"ctxopt.h\"\n\nstatic void\ncommon_help(void);\n\n/* ======================= */\n/* Usage display and exit. */\n/* ======================= */\nstatic void\ncommon_help(void)\n{\n  printf(\"-h|-help\\n\");\n  printf(\"  displays this help.\\n\");\n  printf(\"-u|-usage\\n\");\n  printf(\"  displays the synopsis of the current context.\\n\");\n  printf(\"-i|-in|-inc|-incl|-include\\n\");\n  printf(\"  sets the regex input filter to match the selectable words.\\n\");\n  printf(\"-e|-ex|-exc|-excl|-exclude\\n\");\n  printf(\"  sets the regex input filter to match the non-selectable \"\n         \"words.\\n\");\n  printf(\"-m|-msg|-message|-title\\n\");\n  printf(\"  displays a one-line message/title above the window.\\n\");\n  printf(\"-!|-int|-int_string\\n\");\n  printf(\"  outputs an optional string when ^C is typed.\\n\");\n  printf(\"-a|-attr|-attributes\\n\");\n  printf(\"  sets the attributes for the various displayed elements.\\n\");\n  printf(\"-1|-l1|-level1,-2|-l2|-level2,...,-9|-l9|-level9\\n\");\n  printf(\"  gives specific colors to up to 9 classes of \"\n         \"selectable words.\\n\");\n  printf(\"-z|-zap|-zap_glyphs bytes\\n\");\n  printf(\"  defines a set of glyphs that should be ignored in the input \"\n         \"stream.\\n\");\n  printf(\"-n|-lines|-height\\n\");\n  printf(\"  sets the maximum number of lines in the selection window.\\n\");\n  printf(\"  This number is autodetected when no number is given.\\n\");\n  printf(\"-b|-blank\\n\");\n  printf(\"  displays non printable characters as space.\\n\");\n  printf(\"-.|-dot|-invalid\\n\");\n  printf(\"  defines the substitution character for a non-printable \"\n         \"character.\\n\");\n  printf(\"-M|-middle|-center\\n\");\n  printf(\"  centers the display if possible.\\n\");\n  printf(\"-d|-restore|-delete|-clean|-delete_window|-clean_window\\n\");\n  printf(\"  clears the lines used by the selection window on exit.\\n\");\n  printf(\"-k|-ks|-keep_spaces\\n\");\n  printf(\"  does not trim spaces surrounding the output string if any.\\n\");\n  printf(\"-W|-ws|-wd|-word_delimiters|-word_separators\\n\");\n  printf(\"  defines word separators in the input stream.\\n\");\n  printf(\"-L|-ls|-ld|-line-delimiters|-line_separators\\n\");\n  printf(\"  defines line separators in the input stream.\\n\");\n  printf(\"-q|-no_bar|-no_scroll_bar\\n\");\n  printf(\"  prevents the scroll bar from being displayed.\\n\");\n  printf(\"-no_hbar|-no_hor_scroll_bar\\n\");\n  printf(\"  prevents the horizontal scroll bar from being displayed.\\n\");\n  printf(\"-hbar|-hor_scroll_bar\\n\");\n  printf(\"  always displays the horizontal scroll bar when certain lines are \"\n         \"truncated.\\n\");\n  printf(\"-S|-subst\\n\");\n  printf(\"  defines the post-substitution action to apply to all words.\\n\");\n  printf(\"-I|-si|-subst_included\\n\");\n  printf(\"  defines the post-substitution action to apply to selectable \"\n         \"words only.\\n\");\n  printf(\"-E|-se|-subst_excluded\\n\");\n  printf(\"  defines the post-substitution action to apply to non-selectable \"\n         \"words only.\\n\");\n  printf(\"-ES|-early_subst\\n\");\n  printf(\"  defines the early substitution action to apply to all words.\\n\");\n  printf(\"-/|-search_method\\n\");\n  printf(\"  changes the affectation of the / key (default: fuzzy search).\\n\");\n  printf(\"-s|-sp|-start|-start_pattern\\n\");\n  printf(\"  sets the initial cursor position (refer to the manual for \"\n         \"more details).\\n\");\n  printf(\"-x|-tmout|-timeout/-X|-htmout|-hidden_timeout\\n\");\n  printf(\"  defines a timeout and specifies what to do when it expires.\\n\");\n  printf(\"-r|-auto_validate\\n\");\n  printf(\"  enables ENTER to validate the selection even in search mode.\\n\");\n  printf(\"-is|-incremental_search\\n\");\n  printf(\"  prevents the search buffer from being reset when starting a new \"\n         \"search\\n\");\n  printf(\"  session.\\n\");\n  printf(\"-v|-vb|-visual_bell\\n\");\n  printf(\"  makes the bell visual (fuzzy search with error).\\n\");\n  printf(\"-Q|-ignore_quotes\\n\");\n  printf(\"  treats single and double quotes as normal characters.\\n\");\n  printf(\"-lim|-limits\\n\");\n  printf(\"  overload the words number/max. word length/max columns limits.\\n\");\n  printf(\"-al|-align\\n\");\n  printf(\"  sets alignments for words selected by regular expressions.\\n\");\n  printf(\"-f|-forgotten_timeout|-global_timeout\\n\");\n  printf(\"  defines a global inactivity timeout, defaults to 15 min.\\n\");\n  printf(\"-nm|-no_mouse\\n\");\n  printf(\"  disable a possibly auto-detected mouse tracking support.\\n\");\n  printf(\"-br|-buttons|-button_remapping\\n\");\n  printf(\"  Remaps the left and right mouse buttons, default is 1 and 3.\\n\");\n  printf(\"-dc|-dcd|-double_click|-double_click_delay\\n\");\n  printf(\"  Change the mouse double-click delay which is 150 ms by default.\\n\");\n  printf(\"-sb|-sbw|-show_blank_words\\n\");\n  printf(\"  Make blank words visible and usable even in non column mode.\\n\");\n}\n\nvoid\nmain_help(void)\n{\n  ctxopt_ctx_disp_usage(\"Main\", continue_after);\n\n  printf(\"\\n----------------------------------------\");\n  printf(\"----------------------------------------\\n\");\n\n  printf(\"\\nThis is a filter that gets words from stdin or from a file and \");\n  printf(\"outputs\\n\");\n  printf(\"the selected words (or nothing) on stdout in a nice selection \");\n  printf(\"window\\n\\n\");\n  printf(\"The selection window appears on /dev/tty \");\n  printf(\"just below the current line\\n\");\n  printf(\"(no clear screen!).\\n\\n\");\n\n  printf(\"Short description of allowed parameters:\\n\\n\");\n  common_help();\n\n  printf(\"-V|-version\\n\");\n  printf(\"  displays the current version and quits.\\n\");\n  printf(\"-H|-long_help\\n\");\n  printf(\"  displays a full help and the options available in all \"\n         \"contexts.\\n\");\n  printf(\"-N|-number/-U|-unnumber\\n\");\n  printf(\"  creates or deletes direct access entries for words matching \"\n         \"(or not) a\\n\");\n  printf(\"  specific regex.\\n\");\n  printf(\"-F|-en|-embedded_number\\n\");\n  printf(\"  creates direct access entries by extracting the numbers from the \"\n         \"input words.\\n\");\n  printf(\"-c|-col|-col_mode|-column\\n\");\n  printf(\"  is like -tab without argument but respects end of lines.\\n\");\n  printf(\"-l|-line|-line_mode\\n\");\n  printf(\"  is like -col without column alignments.\\n\");\n  printf(\"-t|-tab|-tab_mode|-tabulate_mode\\n\");\n  printf(\"  tabulates the items. The number of columns can be limited \"\n         \"with\\n\");\n  printf(\"  an optional number.\\n\");\n  printf(\"-T|-tm|-tag|-tag_mode/-P|-pm|-pin|-pin_mode\\n\");\n  printf(\"  enables the tagging mode (multi-selections). \");\n  printf(\"An optional parameter\\n\");\n  printf(\"  defines the separator string between the selected words \");\n  printf(\"on the output.\\n\");\n  printf(\"  A single space is the default separator.\\n\");\n\n  printf(\"\\nNavigation keys are:\\n\");\n  printf(\"  - Left/Down/Up/Right arrows or h/j/k/l, H/J/K/L.\\n\");\n  printf(\"  - Home/End, SHIFT|CTRL+Home/End CTRK+J/CTRL+K.\\n\");\n  printf(\"  - Numbers if some words are numbered (-N/-U/-F).\\n\");\n  printf(\"  - SPACE to search for the next match of a previously\\n\");\n  printf(\"          entered search prefix if any, see below.\\n\\n\");\n  printf(\"Other useful keys are:\\n\");\n  printf(\"  - Help key (temporary display of a short help line): \"\n         \"?\\n\");\n  printf(\"  - Exit key without output (do nothing)             : \"\n         \"q\\n\");\n  printf(\"  - Tagging keys: Select/Deselect/Toggle             : \"\n         \"INS/DEL/t\\n\");\n  printf(\"  - Selection key                                    : \"\n         \"ENTER\\n\");\n  printf(\"  - Cancel key                                       : \"\n         \"ESC\\n\");\n  printf(\"  - Search key                                       : \"\n         \"/ or CTRL-F\\n\\n\");\n  printf(\"The search key activates a timed search mode in which\\n\");\n  printf(\"you can enter the first letters of the searched word.\\n\");\n  printf(\"When entering this mode you have 10s to start typing\\n\");\n  printf(\"and each entered letter restarts this timer.\\n\");\n  printf(\"After this time, the normal navigation mode is restored.\\n\\n\");\n  printf(\"Notes:\\n\");\n  printf(\"- the search timer can be cancelled by pressing ESC.\\n\");\n  printf(\"- a bad search letter can be removed with \");\n  printf(\"CTRL-H or Backspace.\\n\\n\");\n  printf(\"(C) Pierre Gentile.\\n\\n\");\n\n  exit(EXIT_FAILURE);\n}\n\nvoid\ncolumns_help(void)\n{\n  ctxopt_ctx_disp_usage(\"Columns\", continue_after);\n\n  printf(\"\\n----------------------------------------\");\n  printf(\"----------------------------------------\\n\");\n\n  printf(\"Short description of allowed parameters:\\n\\n\");\n  common_help();\n\n  printf(\"-C|-cs|-cols|-cols_select\\n\");\n  printf(\"  sets alignments and columns restrictions for selections.\\n\");\n  printf(\"-R|-rs|-rows|-rows_select\\n\");\n  printf(\"  sets rows restrictions for selections.\\n\");\n  printf(\"-w|-wide|-wide_mode\\n\");\n  printf(\"  uses all the terminal width for the columns if their numbers \"\n         \"is given.\\n\");\n  printf(\"-g|-gutter\\n\");\n  printf(\"  separates columns with a character in column or tabulate \"\n         \"mode.\\n\");\n  printf(\"-N|-number/-U|-unnumber\\n\");\n  printf(\"  numbers/un-numbers and provides a direct access to words \"\n         \"matching\\n\");\n  printf(\"  (or not) a specific regex.\\n\");\n  printf(\"-F|-en|-embedded_number\\n\");\n  printf(\"  numbers and provides a direct access to words by extracting the \"\n         \"number\\n\");\n  printf(\"-T|-tm|-tag|-tag_mode/-P|-pm|-pin|-pin_mode\\n\");\n  printf(\"  enables the tagging (multi-selections) mode. \");\n  printf(\"An optional parameter\\n\");\n  printf(\"  sets the separator string between the selected words \");\n  printf(\"on the output.\\n\");\n  printf(\"  A single space is the default separator.\\n\");\n  printf(\"-A|-fc|-first_column\\n\");\n  printf(\"  forces the specified word pattern to start a line.\\n\");\n  printf(\"-Z|-lc|-last_column\\n\");\n  printf(\"  forces the specified word pattern to end a line.\\n\");\n}\n\nvoid\nlines_help(void)\n{\n  ctxopt_ctx_disp_usage(\"Lines\", continue_after);\n\n  printf(\"\\n----------------------------------------\");\n  printf(\"----------------------------------------\\n\");\n\n  printf(\"Short description of allowed parameters:\\n\\n\");\n  common_help();\n\n  printf(\"-R|-rs|-rows|-row_select\\n\");\n  printf(\"  sets alignments and rows restrictions for selections.\\n\");\n  printf(\"-N|-number/-U|-unnumber\\n\");\n  printf(\"  numbers/un-numbers and provides a direct access to words \"\n         \"matching\\n\");\n  printf(\"  (or not) a specific regex.\\n\");\n  printf(\"-F|-en|-embedded_number\\n\");\n  printf(\"  numbers and provides a direct access to words by extracting the \"\n         \"number\\n\");\n  printf(\"-T|-tm|-tag|-tag_mode/-P|-pm|-pin|-pin_mode\\n\");\n  printf(\"  enables the tagging (multi-selections) mode. \");\n  printf(\"An optional parameter\\n\");\n  printf(\"  sets the separator string between the selected words \");\n  printf(\"on the output.\\n\");\n  printf(\"  A single space is the default separator.\\n\");\n  printf(\"-A|-fc|-first_column\\n\");\n  printf(\"  forces the specified word pattern to start a line.\\n\");\n  printf(\"-Z|-lc|-last_column\\n\");\n  printf(\"  forces the specified word pattern to end a line.\\n\");\n}\n\nvoid\ntabulations_help(void)\n{\n  ctxopt_ctx_disp_usage(\"Tabulations\", continue_after);\n\n  printf(\"\\n----------------------------------------\");\n  printf(\"----------------------------------------\\n\");\n\n  printf(\"Short description of allowed parameters:\\n\\n\");\n  common_help();\n\n  printf(\"-w|-wide|-wide_mode\\n\");\n  printf(\"  uses all the terminal width for the columns if their numbers \"\n         \"is given.\\n\");\n  printf(\"-g|-gutter\\n\");\n  printf(\"  separates columns with a character in column or tabulate \"\n         \"mode.\\n\");\n  printf(\"-N|-number/-U|-unnumber\\n\");\n  printf(\"  numbers/un-numbers and provides a direct access to words \"\n         \"matching\\n\");\n  printf(\"  (or not) a specific regex.\\n\");\n  printf(\"-F|-en|-embedded_number\\n\");\n  printf(\"  numbers and provides a direct access to words by extracting the \"\n         \"number\\n\");\n  printf(\"-T|-tm|-tag|-tag_mode/-P|-pm|-pin|-pin_mode\\n\");\n  printf(\"  enables the tagging (multi-selections) mode. \");\n  printf(\"An optional parameter\\n\");\n  printf(\"  sets the separator string between the selected words \");\n  printf(\"on the output.\\n\");\n  printf(\"  A single space is the default separator.\\n\");\n  printf(\"-A|-fc|-first_column\\n\");\n  printf(\"  forces the specified word pattern to start a line.\\n\");\n  printf(\"-Z|-lc|-last_column\\n\");\n  printf(\"  forces the specified word pattern to end a line.\\n\");\n}\n\nvoid\ntagging_help(void)\n{\n  ctxopt_ctx_disp_usage(\"Tagging\", continue_after);\n\n  printf(\"\\n----------------------------------------\");\n  printf(\"----------------------------------------\\n\");\n\n  printf(\"The following parameters are available in this context:\\n\\n\");\n  common_help();\n\n  printf(\"-p|-at|-auto_tag\\n\");\n  printf(\"  activates the auto-tagging.\\n\");\n  printf(\"-0|-noat|-no_auto_tag\\n\");\n  printf(\"  do not auto-tag the word under the cursor when in tagged mode\\n\");\n  printf(\"  and no other word is selected.\\n\");\n\n  exit(EXIT_FAILURE);\n}\n"
        },
        {
          "name": "usage.h",
          "type": "blob",
          "size": 0.671875,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef USAGE_H\n#define USAGE_H\n\nvoid\nmain_help(void);\n\nvoid\ncolumns_help(void);\n\nvoid\nlines_help(void);\n\nvoid\ntabulations_help(void);\n\nvoid\ntagging_help(void);\n\n#endif\n"
        },
        {
          "name": "utf8.c",
          "type": "blob",
          "size": 16.509765625,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* ************************************* */\n/* Various UTF-8 manipulation functions. */\n/* ************************************* */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n#include <langinfo.h>\n#include \"xmalloc.h\"\n#include \"utf8.h\"\n\n/* =========================================================== */\n/* UTF-8 byte sequence generation from a given UCS-4 codepoint */\n/* utf8_str must be preallocated with a size of at least 5     */\n/* bytes.                                                      */\n/* return the length of the generated sequence or 0 if c is    */\n/* not a valid codepoint.                                      */\n/* =========================================================== */\nint\ncptoutf8(char *utf8_str, uint32_t c)\n{\n  int len = 0;\n\n  if (c < 0x80)\n  {\n    utf8_str[0] = c;\n    len         = 1;\n  }\n  else if (c < 0x800)\n  {\n    utf8_str[0] = 0xC0 | ((c >> 6) & 0x1F);\n    utf8_str[1] = 0x80 | (c & 0x3F);\n    len         = 2;\n  }\n  else if (c < 0x10000)\n  {\n    utf8_str[0] = 0xE0 | ((c >> 12) & 0x0F);\n    utf8_str[1] = 0x80 | ((c >> 6) & 0x3F);\n    utf8_str[2] = 0x80 | (c & 0x3F);\n    len         = 3;\n  }\n  else if (c < 0x110000)\n  {\n    utf8_str[0] = 0xF0 | ((c >> 18) & 0x07);\n    utf8_str[1] = 0x80 | ((c >> 12) & 0x3F);\n    utf8_str[2] = 0x80 | ((c >> 6) & 0x3F);\n    utf8_str[3] = 0x80 | (c & 0x3F);\n    len         = 4;\n  }\n\n  return len;\n}\n\n/* ======================================================================= */\n/* Unicode (UTF-8) ASCII representation interpreter.                       */\n/* The string passed will be altered but its address will not change.      */\n/* All hexadecimal sequences of \\uxx, \\uxxxx, \\uxxxxxx and \\uxxxxxxxx will */\n/* be replaced by the corresponding UTF-8 character when possible.         */\n/* All hexadecimal sequences of \\Uxxxxxx will be replaced with the UTF-8   */\n/* sequence corresponding to the given UCS-4 codepoint.                    */\n/* When not possible the substitution character is substituted in place.   */\n/* Returns 0 if the conversion has failed else 1.                          */\n/* ======================================================================= */\nint\nutf8_interpret(char *s, char substitute)\n{\n  char  *utf8_str;          /* \\uxx...                                     */\n  size_t utf8_to_eos_len;   /* bytes in s starting from the first          *\n                             * occurrence of \\u.                           */\n  size_t init_len;          /* initial lengths of the string to interpret  */\n  size_t utf8_ascii_len;    /* 2,4,6 or 8 bytes.                           */\n  size_t len_to_remove = 0; /* number of bytes to remove after the         *\n                             | conversion.                                 */\n  char   tmp[9];            /* temporary string.                           */\n  int    rc = 1;            /* return code, 0: error, 1: fine.             */\n\n  /* Guard against the case where s is NULL. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  if (s == NULL)\n    return 0;\n\n  init_len = strlen(s);\n\n  /* Manage \\U codepoints. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while ((utf8_str = strstr(s,\n                            \"\\\\\"\n                            \"U\"))\n         != NULL)\n  {\n    int      utf8_str_len;\n    int      n;\n    uint32_t cp;\n    int      subst; /* 0, the \\U sequence is valid, else 1. */\n\n    utf8_to_eos_len = strlen(utf8_str);\n    utf8_str_len    = 0;\n\n    n = sscanf(utf8_str + 2,\n               \"%6[\"\n               \"0123456789\"\n               \"abcdef\"\n               \"ABCDEF\"\n               \"]%n\",\n               tmp,\n               &utf8_str_len);\n\n    subst = 0;\n\n    if (n == 1 && utf8_str_len == 6)\n    {\n      sscanf(tmp, \"%x\", &cp);\n      if (cp > 0x10FFFF)\n        subst = 1; /* Invalid range. */\n      else\n      {\n        char str[7];\n        int  len;\n\n        len             = cptoutf8(str, cp);\n        str[len]        = '\\0';\n        *(utf8_str + 1) = 'u';\n        memmove(utf8_str, str, len);\n        memmove(utf8_str + len, utf8_str + 8, utf8_to_eos_len - 8);\n        len_to_remove += 8 - len;\n      }\n    }\n    else\n      subst = 1; /* Invalid sequence. */\n\n    /* In case of invalid \\U sequence, replace it with the */\n    /* substitution character.                             */\n    /* ''''''''''''''''''''''''''''''''''''''''''''''''''' */\n    if (subst)\n    {\n      *utf8_str = substitute;\n      memmove(utf8_str + 1,\n              utf8_str + 2 + utf8_str_len,\n              utf8_to_eos_len - (utf8_str_len + 2 - 1));\n      len_to_remove += utf8_str_len + 2 - 1;\n    }\n  }\n\n  /* Make sure that the string is well terminated. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *(s + init_len - len_to_remove) = '\\0';\n\n  /* Manage \\u UTF-8 byte sequences. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  while ((utf8_str = strstr(s,\n                            \"\\\\\"\n                            \"u\"))\n         != NULL)\n  {\n    utf8_to_eos_len = strlen(utf8_str);\n    if (utf8_to_eos_len < 4) /* string too short to contain *\n                              | a valid UTF-8 char.         */\n    {\n      *utf8_str       = substitute;\n      *(utf8_str + 1) = '\\0';\n      rc              = 0;\n    }\n    else /* s is long enough. */\n    {\n      unsigned byte;\n      char    *utf8_seq_offset = utf8_str + 2;\n\n      /* Get the first 2 UTF-8 bytes. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      *tmp       = *utf8_seq_offset;\n      *(tmp + 1) = *(utf8_seq_offset + 1);\n      *(tmp + 2) = '\\0';\n\n      /* If they are invalid, replace the \\u sequence by the */\n      /* substitute character.                               */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (!isxdigit(tmp[0]) || !isxdigit(tmp[1]))\n      {\n        *utf8_str = substitute;\n        if (4 >= utf8_to_eos_len)\n          *(utf8_str + 1) = '\\0';\n        else\n        {\n          /* Do not forget the training \\0. */\n          /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n          memmove(utf8_str + 1, utf8_str + 4, utf8_to_eos_len - 4 + 1);\n        }\n        rc = 0;\n      }\n      else\n      {\n        char   end;\n        size_t i;\n        char   b[3] = { ' ', ' ', '\\0' };\n\n        /* They are valid, deduce from them the length of the sequence. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        sscanf(tmp, \"%2x\", &byte);\n\n        utf8_ascii_len = utf8_get_length(byte) * 2;\n\n        /* replace the \\u sequence by the bytes forming the UTF-8 char. */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n        /* Put the bytes in the tmp string. */\n        /* '''''''''''''''''''''''''''''''' */\n        *tmp = byte; /* Reuse the tmp array. */\n\n        for (i = 1; i < utf8_ascii_len / 2; i++)\n        {\n          int good = 1;\n          int n;\n\n          n = sscanf(utf8_seq_offset + 2 * i, \"%c%c\", &b[0], &b[1]);\n\n          if (n == 2)\n          {\n            byte = 0;\n            end  = '\\0';\n            sscanf(b, \"%x%c\", &byte, &end);\n\n            if (byte == 0 || end != '\\0' || (byte & 0xc0) != 0x80)\n              good = 0;\n          }\n          else\n            good = 0;\n\n          if (good)\n            *(tmp + i) = byte;\n          else\n            utf8_ascii_len = 2 * i; /* Force the new length according to the *\n                                     | number of valid UTF-8 bytes read.     */\n        }\n        tmp[utf8_ascii_len / 2] = '\\0';\n\n        /* Does they form a valid UTF-8 char? */\n        /* '''''''''''''''''''''''''''''''''' */\n        if (utf8_validate(tmp) == NULL)\n        {\n          /* Put them back in the original string and move */\n          /* the remaining bytes after them.               */\n          /* ''''''''''''''''''''''''''''''''''''''''''''' */\n          memmove(utf8_str, tmp, utf8_ascii_len / 2);\n\n          if (utf8_to_eos_len < utf8_ascii_len)\n            *(utf8_str + utf8_ascii_len / 2 + 1) = '\\0';\n          else\n            memmove(utf8_str + utf8_ascii_len / 2,\n                    utf8_seq_offset + utf8_ascii_len,\n                    utf8_to_eos_len - utf8_ascii_len - 2 + 1);\n        }\n        else\n        {\n          /* The invalid sequence is replaced by a */\n          /* substitution character.               */\n          /* ''''''''''''''''''''''''''''''''''''' */\n          *utf8_str = substitute;\n\n          if (utf8_to_eos_len < utf8_ascii_len)\n            *(utf8_str + 1) = '\\0';\n          else\n            memmove(utf8_str + 1,\n                    utf8_seq_offset + utf8_ascii_len,\n                    utf8_to_eos_len - utf8_ascii_len - 2 + 1);\n\n          utf8_ascii_len = 2;\n          rc             = 0;\n        }\n\n        /* Update the number of bytes to remove at the end */\n        /* of the initial string.                          */\n        /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n        len_to_remove += 2 + utf8_ascii_len / 2;\n      }\n    }\n  }\n\n  /* Make sure that the string is well terminated. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  *(s + init_len - len_to_remove) = '\\0';\n\n  return rc;\n}\n\n/* ========================================================= */\n/* Decodes the number of bytes taken by a UTF-8 glyph.       */\n/* It is the length of the leading sequence of bits set to 1 */\n/* in the first byte.                                        */\n/* ========================================================= */\nint\nutf8_get_length(unsigned char c)\n{\n  if (c < 0x80)\n    return 1;\n  else if (c < 0xe0)\n    return 2;\n  else if (c < 0xf0)\n    return 3;\n\n  return 4;\n}\n\n/* ==================================================== */\n/* Returns the byte offset of the nth UTF-8 glyph in s. */\n/* ==================================================== */\nsize_t\nutf8_offset(char const *s, size_t n)\n{\n  size_t i = 0;\n\n  while (n > 0)\n  {\n    if (s[i++] & 0x80)\n    {\n      (void)(((s[++i] & 0xc0) != 0x80) || ((s[++i] & 0xc0) != 0x80) || ++i);\n    }\n    n--;\n  }\n  return i;\n}\n\n/* ============================================== */\n/* Points to the previous UTF-8 glyph in a string */\n/* from the given position.                       */\n/* ============================================== */\nchar *\nutf8_prev(const char *str, const char *p)\n{\n  while ((*p & 0xc0) == 0x80)\n    p--;\n\n  for (--p; p >= str; --p)\n  {\n    if ((*p & 0xc0) != 0x80)\n      return (char *)p;\n  }\n  return NULL;\n}\n\n/* ========================================== */\n/* Points to the next UTF-8 glyph in a string */\n/* from the current position.                 */\n/* ========================================== */\nchar *\nutf8_next(char *p)\n{\n  if (*p)\n  {\n    for (++p; (*p & 0xc0) == 0x80; ++p)\n      ;\n  }\n\n  return *p == '\\0' ? NULL : p;\n}\n\n/* ============================================================= */\n/* Replaces any UTF-8 glyph present in s by a substitution       */\n/* character in-place.                                           */\n/* s will be modified but its address in memory will not change. */\n/* ============================================================= */\nvoid\nutf8_sanitize(char *s, char substitute)\n{\n  char  *p = s;\n  size_t len;\n\n  len = strlen(s);\n  while (*p)\n  {\n    int n;\n\n    n = utf8_get_length(*p);\n\n    if (n > 1)\n    {\n      *p = substitute;\n      memmove(p + 1, p + n, len - (p - s) - n + 1);\n      len -= (n - 1);\n    }\n\n    p++;\n  }\n}\n\n/* ======================================================================= */\n/* This function scans the '\\0'-terminated string starting at s.           */\n/* It returns a pointer to the first byte of the first malformed           */\n/* or overlong UTF-8 sequence found, or NULL if the string contains only   */\n/* correct UTF-8.                                                          */\n/* It also spots UTF-8 sequences that could cause trouble if converted to  */\n/* UTF-16, namely surrogate characters (U+D800..U+DFFF) and non-Unicode    */\n/* positions (U+FFFE..U+FFFF).                                             */\n/* This routine is very likely to find a malformed sequence if the input   */\n/* uses any other encoding than UTF-8.                                     */\n/* It therefore can be used as a very effective heuristic for              */\n/* distinguishing between UTF-8 and other encodings.                       */\n/*                                                                         */\n/* I wrote this code mainly as a specification of functionality; there     */\n/* are no doubt performance optimizations possible for certain CPUs.       */\n/*                                                                         */\n/* Markus Kuhn <http://www.cl.cam.ac.uk/~mgk25/> -- 2005-03-30             */\n/* License: http://www.cl.cam.ac.uk/~mgk25/short-license.html              */\n/* ======================================================================= */\nchar *\nutf8_validate(char *s)\n{\n  unsigned char *us = (unsigned char *)s;\n\n  /* clang-format off */\n  while (*us)\n  {\n    if (*us < 0x80)\n      /* 0xxxxxxx */\n      us++;\n    else if ((us[0] & 0xe0) == 0xc0)\n    {\n      /* 110XXXXx 10xxxxxx */\n      if ((us[1] & 0xc0) != 0x80 || (us[0] & 0xfe) == 0xc0) /* overlong? */\n        return (char *)us;\n\n      us += 2;\n    }\n    else if ((us[0] & 0xf0) == 0xe0)\n    {\n      /* 1110XXXX 10Xxxxxx 10xxxxxx */\n      if ((us[1] & 0xc0) != 0x80 ||\n          (us[2] & 0xc0) != 0x80 ||\n          (us[0] == 0xe0 && (us[1] & 0xe0) == 0x80) || /* overlong?         */\n          (us[0] == 0xed && (us[1] & 0xe0) == 0xa0) || /* surrogate?        */\n          (us[0] == 0xef && us[1] == 0xbf &&\n            (us[2] & 0xfe) == 0xbe))                   /* U+FFFE or U+FFFF? */\n        return (char *)us;\n\n      us += 3;\n    }\n    else if ((us[0] & 0xf8) == 0xf0)\n    {\n      /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */\n      if ((us[1] & 0xc0) != 0x80 ||\n          (us[2] & 0xc0) != 0x80 ||\n          (us[3] & 0xc0) != 0x80 ||\n          (us[0] == 0xf0 && (us[1] & 0xf0) == 0x80) ||     /* overlong?   */\n          (us[0] == 0xf4 && us[1] > 0x8f) || us[0] > 0xf4) /* > U+10FFFF? */\n        return (char *)us;\n\n      us += 4;\n    }\n    else\n      return (char *)us;\n  }\n  /* clang-format on */\n\n  return NULL;\n}\n\n/* ======================= */\n/* Multibyte UTF-8 strlen. */\n/* ======================= */\nsize_t\nutf8_strlen(char const *str)\n{\n  size_t i = 0, j = 0;\n\n  while (str[i])\n  {\n    if ((str[i] & 0xc0) != 0x80)\n      j++;\n    i++;\n  }\n  return j;\n}\n\n/* ==================================================================== */\n/* Multibytes extraction of the prefix of n UTF-8 glyphs from a string. */\n/* The destination string d must have been allocated before.            */\n/* pos is updated to reflect the position AFTER the prefix.             */\n/* ==================================================================== */\nchar *\nutf8_strprefix(char *d, char const *s, long n, long *pos)\n{\n  long i = 0;\n  long j = 0;\n\n  *pos = 0;\n\n  while (s[i] && j < n)\n  {\n    d[i] = s[i];\n    i++;\n    j++;\n    while (s[i] && (s[i] & 0xC0) == 0x80)\n    {\n      d[i] = s[i];\n      i++;\n    }\n  }\n\n  *pos = i;\n\n  d[i] = '\\0';\n\n  return d;\n}\n\n/* ================================================== */\n/* Converts a UTF-8 glyph string to a wchar_t string. */\n/* The returned string must be freed by the caller.   */\n/* ================================================== */\nwchar_t *\nutf8_strtowcs(char *s)\n{\n  int            converted = 0;\n  unsigned char *ch;\n  wchar_t       *wptr, *w;\n  size_t         size;\n\n  size = (long)strlen(s);\n  w    = xmalloc((size + 1) * sizeof(wchar_t));\n  w[0] = L'\\0';\n\n  wptr = w;\n  for (ch = (unsigned char *)s; *ch; ch += converted)\n  {\n    if ((converted = mbtowc(wptr, (char *)ch, 4)) > 0)\n      wptr++;\n    else\n    {\n      *wptr++   = (wchar_t)*ch;\n      converted = 1;\n    }\n  }\n\n  *wptr = L'\\0';\n\n  return w;\n}\n\n/* ============================================================== */\n/* Poor man UTF-8 aware strtolower version.                       */\n/* Replaces all ASCII characters in src by its lowercase version. */\n/* dst must be preallocated before the call.                      */\n/* ============================================================== */\nvoid\nutf8_strtolower(char *dst, char *src)\n{\n  unsigned char c;\n\n  while ((c = *src))\n  {\n    if (c >= 0x80)\n      *dst = c;\n    else\n      *dst = tolower(c);\n\n    src++;\n    dst++;\n  }\n\n  *dst = '\\0';\n}\n"
        },
        {
          "name": "utf8.h",
          "type": "blob",
          "size": 1.259765625,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef UTF8_H\n#define UTF8_H\n\n#include <stdint.h>\n\ntypedef struct langinfo_s langinfo_t;\n\n/* Locale information. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct langinfo_s\n{\n  int utf8; /* charset is UTF-8              */\n  int bits; /* number of bits in the charset */\n};\n\nint\nutf8_get_length(unsigned char c);\n\nsize_t\nutf8_offset(char const *, size_t);\n\nchar *\nutf8_strprefix(char *d, char const *s, long n, long *pos);\n\nsize_t\nutf8_strlen(char const *str);\n\nwchar_t *\nutf8_strtowcs(char *s);\n\nvoid\nutf8_sanitize(char *s, char sc);\n\nint\ncptoutf8(char *utf8_str, uint32_t c);\n\nint\nutf8_interpret(char *s, char sc);\n\nchar *\nutf8_validate(char *str);\n\nchar *\nutf8_prev(const char *str, const char *p);\n\nchar *\nutf8_next(char *p);\n\nvoid\nutf8_strtolower(char *dst, char *src);\n\n#endif\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 17.0634765625,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n/* ******************************** */\n/* Various small utility functions. */\n/* ******************************** */\n\n#include \"config.h\"\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <wctype.h>\n#include \"xmalloc.h\"\n#include \"wchar.h\"\n#include \"list.h\"\n#include \"utf8.h\"\n#include \"utils.h\"\n\n/* ******************* */\n/* Interval functions. */\n/* ******************* */\n\n/* ======================= */\n/* Creates a new interval. */\n/* ======================= */\ninterval_t *\ninterval_new(void)\n{\n  return xmalloc(sizeof(interval_t));\n}\n\n/* ======================================= */\n/* Compares 2 intervals as integer couples */\n/* same return values as for strcmp.       */\n/* ======================================= */\nint\ninterval_comp(void const *a, void const *b)\n{\n  interval_t const *ia = (interval_t *)a;\n  interval_t const *ib = (interval_t *)b;\n\n  if (ia->low < ib->low)\n    /* ia: [...      */\n    /* ib:      [... */\n    return -1;\n  if (ia->low > ib->low)\n    /* ia:      [... */\n    /* ib: [...      */\n    return 1;\n  if (ia->high < ib->high)\n    /* ia: ...]      */\n    /* ib:      ...] */\n    return -1;\n  if (ia->high > ib->high)\n    /* ia:      ...] */\n    /* ib: ...]      */\n    return 1;\n\n  return 0;\n}\n\n/* ================================== */\n/* Swaps the values of two intervals. */\n/* ================================== */\nvoid\ninterval_swap(void **a, void **b)\n{\n  interval_t *ia = (interval_t *)*a;\n  interval_t *ib = (interval_t *)*b;\n  long        tmp;\n\n  tmp     = ia->low;\n  ia->low = ib->low;\n  ib->low = tmp;\n\n  tmp      = ia->high;\n  ia->high = ib->high;\n  ib->high = tmp;\n}\n\n/* ====================================================================== */\n/* Merges the intervals from an interval list in order to get the minimum */\n/* number of intervals to consider.                                       */\n/* ====================================================================== */\nvoid\noptimize_an_interval_list(ll_t *list)\n{\n  ll_node_t  *node1, *node2;\n  interval_t *data1, *data2;\n\n  if (!list || list->len < 2)\n    return;\n\n  /* Step 1: sort the intervals list. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  ll_sort(list, interval_comp, interval_swap);\n\n  /* Step 2: merge the list by merging the consecutive intervals. */\n  /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n  node1 = list->head;\n  node2 = node1->next;\n\n  while (node2)\n  {\n    data1 = (interval_t *)(node1->data);\n    data2 = (interval_t *)(node2->data);\n\n    if (data1->high >= data2->low - 1)\n    {\n      /* Interval 1 overlaps interval 2. */\n      /* ''''''''''''''''''''''''''''''' */\n      if (data2->high >= data1->high)\n        data1->high = data2->high;\n      ll_delete(list, node2);\n      free(data2);\n      node2 = node1->next;\n    }\n    else\n    {\n      /* No overlap. */\n      /* ''''''''''' */\n      node1 = node2;\n      node2 = node2->next;\n    }\n  }\n}\n\n/* ***************** */\n/* String functions. */\n/* ***************** */\n\n/* ========================================================================= */\n/* Allocates memory and safely concatenate strings. Stolen from a public     */\n/* domain implementation which can be found here:                            */\n/* http://openwall.info/wiki/people/solar/software/public-domain-source-code */\n/* ========================================================================= */\nchar *\nconcat(const char *s1, ...)\n{\n  va_list     args;\n  const char *s;\n  char       *p, *result;\n  size_t      l, m, n;\n\n  m = n = strlen(s1);\n  va_start(args, s1);\n  while ((s = va_arg(args, char *)))\n  {\n    l = strlen(s);\n    if ((m += l) < l)\n      break;\n  }\n  va_end(args);\n  if (s || m >= INT_MAX)\n    return NULL;\n\n  result = (char *)xmalloc(m + 1);\n\n  memcpy(p = result, s1, n);\n  p += n;\n  va_start(args, s1);\n  while ((s = va_arg(args, char *)))\n  {\n    l = strlen(s);\n    if ((n += l) < l || n > m)\n      break;\n    memcpy(p, s, l);\n    p += l;\n  }\n  va_end(args);\n  if (s || m != n || p != result + n)\n  {\n    free(result);\n    return NULL;\n  }\n\n  *p = 0;\n  return result;\n}\n\n/* =============================================== */\n/* Is the string str2 a prefix of the string str1? */\n/* Returns 1 if true, else 0.                      */\n/* =============================================== */\nint\nstrprefix(char *str1, char *str2)\n{\n  while (*str1 != '\\0' && *str1 == *str2)\n  {\n    str1++;\n    str2++;\n  }\n\n  return *str2 == '\\0';\n}\n\n/* ========================= */\n/* Trims leading characters. */\n/* ========================= */\nvoid\nltrim(char *str, const char *trim_str)\n{\n  size_t len   = strlen(str);\n  size_t begin = strspn(str, trim_str);\n\n  if (begin > 0)\n    for (size_t i = begin; i <= len; ++i)\n      str[i - begin] = str[i];\n}\n\n/* ==================================================================== */\n/* Trims trailing characters.                                           */\n/* All (ASCII) characters in trim_str will be removed.                  */\n/* The min argument guarantees that the length of the resulting string  */\n/* will not be smaller than this size if it was larger before, 0 is the */\n/* usual value here.                                                    */\n/* Note that when min is greater than 0, tail characters intended to be */\n/* deleted may remain.                                                  */\n/* ==================================================================== */\nvoid\nrtrim(char *str, const char *trim_str, size_t min)\n{\n  size_t len = strlen(str);\n  while (len > min && strchr(trim_str, str[len - 1]))\n    str[--len] = '\\0';\n}\n\n/* ========================================= */\n/* Case insensitive strcmp.                  */\n/* from http://c.snippets.org/code/stricmp.c */\n/* ========================================= */\nint\nmy_strcasecmp(const char *str1, const char *str2)\n{\n#ifdef HAVE_STRCASECMP\n  return strcasecmp(str1, str2);\n#else\n  int retval = 0;\n\n  while (1)\n  {\n    retval = tolower(*str1++) - tolower(*str2++);\n\n    if (retval)\n      break;\n\n    if (*str1 && *str2)\n      continue;\n    else\n      break;\n  }\n  return retval;\n#endif\n}\n\n/* ============================================= */\n/* memmove based strcpy (tolerates overlapping). */\n/* ============================================= */\nchar *\nmy_strcpy(char *str1, char *str2)\n{\n  if (str1 == NULL || str2 == NULL)\n    return NULL;\n\n  memmove(str1, str2, strlen(str2) + 1);\n\n  return str1;\n}\n\n/* ================================ */\n/* 7 bits aware version of isprint. */\n/* ================================ */\nint\nisprint7(int i)\n{\n  return i >= 0x20 && i <= 0x7e;\n}\n\n/* ================================ */\n/* 8 bits aware version of isprint. */\n/* ================================ */\nint\nisprint8(int i)\n{\n  unsigned char c = i & (unsigned char)0xff;\n\n  return (c >= 0x20 && c < 0x7f) || (c >= (unsigned char)0xa0);\n}\n\n/* ==================================================== */\n/* Private implementation of wcscasecmp missing in c99. */\n/* ==================================================== */\nint\nmy_wcscasecmp(const wchar_t *s1, const wchar_t *s2)\n{\n  while (*s1)\n  {\n    wchar_t c1, c2;\n\n    c1 = towlower(*s1);\n    c2 = towlower(*s2);\n\n    if (c1 != c2)\n      return (int)(c1 - c2);\n\n    s1++;\n    s2++;\n  }\n  return -*s2;\n}\n\n/* ================================================================ */\n/* Returns 1 if s can be converted into an int otherwise returns 0. */\n/* ================================================================ */\nint\nis_integer(const char * const s)\n{\n  long int n;\n  char    *endptr;\n\n  n = strtol(s, &endptr, 10);\n\n  if (errno != ERANGE && n >= INT_MIN && n <= INT_MAX && *endptr == '\\0')\n    return 1;\n\n  return 0;\n}\n\n/* ===================================================== */\n/* Exchanges the start and end part of a string.         */\n/* The first part goes from char 0 to size-1.            */\n/* The second part goes from char size to the end of *s. */\n/* Returns 1 on success.                                 */\n/* ===================================================== */\nint\nswap_string_parts(char **s, size_t first)\n{\n  char  *tmp;\n  size_t size;\n\n  if (*s == NULL || **s == '\\0')\n    return 0;\n\n  tmp  = xmalloc(strlen(*s) * 2 + 1);\n  size = strlen(*s);\n\n  if (first > size)\n    return 0;\n\n  strcpy(tmp, *s);\n  strcat(tmp, *s);\n  strncpy(*s, tmp + first, size);\n\n  free(tmp);\n  return 1;\n}\n\n/* ================================================================ */\n/* Substitute all the characters c1 by c2 in the string s in place. */\n/* ================================================================ */\nvoid\nstrrep(char *s, const char c1, const char c2)\n{\n  if (s != NULL)\n    while (*s)\n    {\n      if (*s == c1)\n        *s = c2;\n      s++;\n    }\n}\n\n/* ================================================================== */\n/* Allocates and returns a string similar to s but with non printable */\n/* character changed by their ASCII hexadecimal notation.             */\n/* ================================================================== */\nchar *\nstrprint(char const *s)\n{\n  size_t l  = strlen(s);\n  char *new = xcalloc(1, 4 * l + 1);\n  char *p   = new;\n\n  while (*s)\n  {\n    if (isprint(*s))\n      *(p++) = *s++;\n    else\n    {\n      sprintf(p, \"\\\\x%02X\", (unsigned char)*s++);\n      p += 4;\n    }\n  }\n\n  if (p - new > (ptrdiff_t)l)\n    new = xrealloc(new, p - new + 1);\n\n  return new;\n}\n\n/* =============================================== */\n/* Hexadecimal dump of part of a buffer to a file. */\n/*                                                 */\n/* buf   : buffer to dump.                         */\n/* fp    : file to dump to.                        */\n/* prefix: string to be printed before each line.  */\n/* size  : length of the buffer to consider.       */\n/* =============================================== */\nvoid\nhexdump(const char *buf, FILE *fp, const char *prefix, size_t size)\n{\n  unsigned int  b;\n  unsigned char d[17];\n  unsigned int  o, mo;\n  size_t        l;\n\n  o = mo = 0;\n  l      = strlen(prefix);\n\n  memset(d, '\\0', 17);\n  for (b = 0; b < size; b++)\n  {\n\n    d[b % 16] = isprint(buf[b]) ? (unsigned char)buf[b] : '.';\n\n    if ((b % 16) == 0)\n    {\n      o = l + 7;\n      if (o > mo)\n        mo = o;\n      fprintf(fp, \"%s: %04x:\", prefix, b);\n    }\n\n    o += 3;\n    if (o > mo)\n      mo = o;\n    fprintf(fp, \" %02x\", (unsigned char)buf[b]);\n\n    if ((b % 16) == 15)\n    {\n      mo = o;\n      o  = 0;\n      fprintf(fp, \" |%s|\", d);\n      memset(d, '\\0', 17);\n      fprintf(fp, \"\\n\");\n    }\n  }\n  if ((b % 16) != 0)\n  {\n    for (unsigned int i = 0; i < mo - o; i++)\n      fprintf(fp, \"%c\", ' ');\n\n    fprintf(fp, \" |%s\", d);\n    if (mo > o)\n      for (unsigned int i = 0; i < 16 - strlen((char *)d); i++)\n        fprintf(fp, \"%c\", ' ');\n    fprintf(fp, \"%c\", '|');\n    memset(d, '\\0', 17);\n    fprintf(fp, \"\\n\");\n  }\n}\n\n/* ===================================================================== */\n/* Version of wcswidth which tries to support extended grapheme clusters */\n/* by taking into zero width characters.                                 */\n/* ===================================================================== */\nint\nmy_wcswidth(const wchar_t *s, size_t n)\n{\n  int len = 0;\n  int m   = 0;\n\n  if (s == NULL || *s == L'\\0')\n    return 0;\n\n  while (*s && m < n)\n  {\n    int l;\n\n    if ((l = wcwidth(*s)) >= 0)\n    {\n      /* Do not count zero-width-length glyphs. */\n      /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n      if (*s != L'\\x200d' && *(s + 1) != L'\\x200d' && *(s + 1) != L'\\xfe0f'\n          && *(s + 1) != L'\\x20e3')\n        len += l;\n    }\n    else\n      return -1; /* wcwidth returned -1. */\n\n    s++;\n    m++;\n  }\n\n  return len;\n}\n\n/* ==================================================================== */\n/* Get the target index of the number to be inserted in a sorted array. */\n/*                                                                      */\n/* IN array : an already empty or sorted array.                         */\n/* IN value : the value to be inserted in the array.                    */\n/* IN nb    : the number of existing elements in the array.             */\n/*                                                                      */\n/* RETURN   : -1 if the value is already in the array of the future     */\n/*            index of value in the array.                              */\n/* ==================================================================== */\nlong\nget_sorted_array_target_pos(long *array, long nb, long value)\n{\n  long pos  = nb;\n  long left = 0, right = nb, middle;\n\n  if (nb > 0)\n  {\n    /* Bisection search. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    while (left < right)\n    {\n      middle = (left + right) / 2;\n      if (array[middle] == value)\n        return -1; /* Value already in array. */\n\n      if (value < array[middle])\n        right = middle;\n      else\n        left = middle + 1;\n    }\n    pos = left;\n  }\n  return pos;\n}\n\n/* =============================================================== */\n/* Detect if the current terminal belongs to the foreground group. */\n/* returns 1 if yes else returns 0.                                */\n/* =============================================================== */\nint\nis_in_foreground_process_group(void)\n{\n  int fd, fg;\n\n  fd = open(\"/dev/tty\", O_RDONLY);\n  if (fd < 0)\n    return 0;\n\n  fg = (tcgetpgrp(fd) == getpgid(0));\n\n  close(fd);\n\n  return fg;\n}\n\n/* ====================================================== */\n/* Returns 1 if a string is empty or only made of spaces. */\n/* Non UTF-8 version.                                     */\n/* ====================================================== */\nint\nisempty_non_utf8(const unsigned char *s)\n{\n  while (*s != '\\0')\n  {\n    if (*s != ' ' && *s != '\\t')\n      return 0;\n    s++;\n  }\n  return 1;\n}\n\n/* ====================================================== */\n/* Returns 1 if a string is empty or only made of spaces. */\n/* UTF-8 version.                                         */\n/* ====================================================== */\nint\nisempty_utf8(const unsigned char *s)\n{\n  unsigned char c, d;\n\n  while (*s != '\\0')\n  {\n    if (*s == ' ' || *s == '\\t') /* Normal ASCII spaces. */\n      goto next;\n\n    if (*s < 0xc2) /* Not an UTF-8 space -> return FALSE. */\n      return 0;\n\n    /* Scanning for a potential non UTF-8 spaces scanning. */\n    /* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n    if ((c = *(s + 1)) != '\\0')\n    {\n      if (*s == 0xc2 && (c == 0x85 || c == 0xa0))\n      {\n        s++;\n        goto next; /* Unnamed control character or NO-BREAK SPACE. */\n      }\n\n      if ((d = *(s + 2)) == '\\0')\n        return 0;\n\n      if (*s == 0xe1 && c == 0x9a && d == 0x80)\n      {\n        s += 2;\n        goto next; /* OGHAM SPACE MARK. */\n      }\n\n      if (*s == 0xe1 && c == 0xa0 && d == 0x8e)\n      {\n        s += 2;\n        goto next; /* MONGOLIAN VOWEL SEPARATOR. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x80)\n      {\n        s += 2;\n        goto next; /* EN QUAD. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x81)\n      {\n        s += 2;\n        goto next; /* EM QUAD. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x82)\n      {\n        s += 2;\n        goto next; /* EN SPACE. */\n      }\n      if (*s == 0xe2 && c == 0x80 && d == 0x83)\n      {\n        s += 2;\n        goto next; /* EM SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x84)\n      {\n        s += 2;\n        goto next; /* THREE-PER-EM SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x85)\n      {\n        s += 2;\n        goto next; /* FOUR-PER-EM SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x86)\n      {\n        s += 2;\n        goto next; /* SIX-PER-EM SPACE. */\n      }\n      if (*s == 0xe2 && c == 0x80 && d == 0x87)\n      {\n        s += 2;\n        goto next; /* FIGURE SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x88)\n      {\n        s += 2;\n        goto next; /* PUNCTUATION SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x89)\n      {\n        s += 2;\n        goto next; /* THIN SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0x8a)\n      {\n        s += 2;\n        goto next; /* HAIR SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0xa8)\n      {\n        s += 2;\n        goto next; /* LINE SEPARATOR. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0xa9)\n      {\n        s += 2;\n        goto next; /* PARAGRAPH SEPARATOR. */\n      }\n\n      if (*s == 0xe2 && c == 0x80 && d == 0xaf)\n      {\n        s += 2;\n        goto next; /* NARROW NO-BREAK SPACE. */\n      }\n\n      if (*s == 0xe2 && c == 0x81 && d == 0x9f)\n      {\n        s += 2;\n        goto next; /* MEDIUM MATHEMATICAL SPACE. */\n      }\n\n      if (*s == 0xe3 && c == 0x80 && d == 0x80)\n      {\n        s += 2;\n        goto next; /* IDEOGRAPHIC SPACE. */\n      }\n\n      return 0;\n    }\n  next:\n    s++;\n  }\n  return 1;\n}\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 1.919921875,
          "content": "/* ################################################################### */\n/* Copyright 2015, Pierre Gentile (p.gen.progs@gmail.com)              */\n/*                                                                     */\n/* This Source Code Form is subject to the terms of the Mozilla Public */\n/* License, v. 2.0. If a copy of the MPL was not distributed with this */\n/* file, You can obtain one at https://mozilla.org/MPL/2.0/.           */\n/* ################################################################### */\n\n#ifndef UTILS_H\n#define UTILS_H\n\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n\ntypedef struct interval_s interval_t;\ntypedef struct range_s    range_t;\n\nstruct interval_s\n{\n  long low;\n  long high;\n};\n\n/* Structure used by the replace function to delimit matches */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\nstruct range_s\n{\n  size_t start;\n  size_t end;\n};\n\ninterval_t *\ninterval_new(void);\n\nint\ninterval_comp(void const *a, void const *b);\n\nvoid\ninterval_swap(void **a, void **b);\n\nvoid\noptimize_an_interval_list(ll_t *list);\n\nchar *\nconcat(const char *str1, ...);\n\nint\nstrprefix(char *str1, char *str2);\n\nvoid\nltrim(char *str, const char *trim);\n\nvoid\nrtrim(char *str, const char *trim, size_t min_len);\n\nint\nmy_strcasecmp(const char *str1, const char *str2);\n\nchar *\nmy_strcpy(char *dst, char *src);\n\nint\nisprint7(int i);\n\nint\nisprint8(int i);\n\nint\nmy_wcscasecmp(const wchar_t *w1s, const wchar_t *w2s);\n\nint\nis_integer(const char * const s);\n\nint\nswap_string_parts(char **s, size_t first);\n\nvoid\nstrrep(char *s, const char c1, const char c2);\n\nchar *\nstrprint(char const *s);\n\nvoid\nhexdump(const char *buf, FILE *fp, const char *prefix, size_t size);\n\nint\nmy_wcswidth(const wchar_t *s, size_t n);\n\nlong\nget_sorted_array_target_pos(long *array, long nb, long value);\n\nint\nis_in_foreground_process_group(void);\n\nint\nisempty_non_utf8(const unsigned char *s);\n\nint\nisempty_utf8(const unsigned char *s);\n\n#endif\n"
        },
        {
          "name": "version",
          "type": "blob",
          "size": 0.005859375,
          "content": "1.4.0\n"
        },
        {
          "name": "xmalloc.c",
          "type": "blob",
          "size": 4.5478515625,
          "content": "/* **************************** */\n/* Memory management functions. */\n/* **************************** */\n\n/* ***************************************************************** */\n/* Created by Kevin Locke (from numerous canonical examples).        */\n/*                                                                   */\n/* Adapted for use by smenu.                                         */\n/*                                                                   */\n/* I hereby place this file in the public domain.  It may be freely  */\n/* reproduced, distributed, used, modified, built upon, or otherwise */\n/* employed by anyone for any purpose without restriction.           */\n/* ***************************************************************** */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"config.h\"\n#include \"xmalloc.h\"\n\n/* The following rpl_* function are necessary for AIX which doesn't     */\n/* provide 'GNU compatible' allocation functions.                       */\n/* Every call to malloc()/realloc() is then replaced by a call to       */\n/* rpl_malloc()/rpl_realloc() as defined in the GNU generated config.h. */\n/* \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" */\n\n#ifdef malloc\n\n#undef malloc\nextern void *malloc(size_t);\n\nvoid *\nrpl_malloc(size_t size)\n{\n  if (!size)\n    size++;\n  return malloc(size);\n}\n\n#undef realloc\nextern void *\nrealloc(void *, size_t);\n\nvoid *\nrpl_realloc(void *ptr, size_t size)\n{\n  if (!size)\n    size++;\n  return (ptr ? realloc(ptr, size) : malloc(size));\n}\n\n#endif\n\n/* ================================================================== */\n/* Customized malloc.                                                 */\n/* Displays an error message and exits gracefully if an error occurs. */\n/* ================================================================== */\nvoid *\nxmalloc(size_t size)\n{\n  void  *allocated;\n  size_t real_size;\n\n  real_size = (size > 0) ? size : 1;\n  allocated = malloc(real_size);\n  if (allocated == NULL)\n  {\n    fprintf(stderr,\n            \"Error: Insufficient memory (attempt to malloc %zu bytes)\\n\",\n            size);\n\n    exit(EXIT_FAILURE);\n  }\n\n  return allocated;\n}\n\n/* ================================================================== */\n/* Customized calloc.                                                 */\n/* Displays an error message and exits gracefully if an error occurs. */\n/* ================================================================== */\nvoid *\nxcalloc(size_t n, size_t size)\n{\n  void *allocated;\n\n  n         = (n > 0) ? n : 1;\n  size      = (size > 0) ? size : 1;\n  allocated = calloc(n, size);\n  if (allocated == NULL)\n  {\n    fprintf(stderr,\n            \"Error: Insufficient memory (attempt to calloc %zu bytes)\\n\",\n            size);\n\n    exit(EXIT_FAILURE);\n  }\n\n  return allocated;\n}\n\n/* ================================================================== */\n/* Customized realloc.                                                */\n/* Displays an error message and exits gracefully if an error occurs. */\n/* ================================================================== */\nvoid *\nxrealloc(void *p, size_t size)\n{\n  void *allocated;\n\n  allocated = realloc(p, size);\n  if (allocated == NULL && size > 0)\n  {\n    fprintf(stderr,\n            \"Error: Insufficient memory (attempt to realloc %zu bytes)\\n\",\n            size);\n\n    exit(EXIT_FAILURE);\n  }\n\n  return allocated;\n}\n\n/* ================================================================== */\n/* strdup implementation using xmalloc.                               */\n/* Displays an error message and exits gracefully if an error occurs. */\n/* ================================================================== */\nchar *\nxstrdup(const char *str)\n{\n  char *p;\n\n  p = malloc(strlen(str) + 1);\n\n  if (p == NULL)\n  {\n    fprintf(stderr, \"Error: Insufficient memory for xstrdup.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  strcpy(p, str);\n\n  return p;\n}\n\n/* ================================================================== */\n/* strndup implementation using xmalloc.                              */\n/* This version guarantees that there is a final '\\0'.                */\n/* Displays an error message and exits gracefully if an error occurs. */\n/* ================================================================== */\nchar *\nxstrndup(const char *str, size_t len)\n{\n  char *p;\n\n  p = memchr(str, '\\0', len);\n\n  if (p != NULL)\n    len = p - str;\n\n  p = malloc(len + 1);\n\n  if (p == NULL)\n  {\n    fprintf(stderr, \"Error: Insufficient memory for xstrndup.\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  memcpy(p, str, len);\n  p[len] = '\\0';\n\n  return p;\n}\n"
        },
        {
          "name": "xmalloc.h",
          "type": "blob",
          "size": 0.3056640625,
          "content": "#ifndef XMALLOC_H\n#define XMALLOC_H\n\nvoid *\nrpl_malloc(size_t size);\n\nvoid *\nrpl_realloc(void *ptr, size_t size);\n\nvoid *\nxmalloc(size_t size);\n\nvoid *\nxcalloc(size_t n, size_t size);\n\nvoid *\nxrealloc(void *ptr, size_t size);\n\nchar *\nxstrdup(const char *p);\n\nchar *\nxstrndup(const char *str, size_t len);\n\n#endif\n"
        }
      ]
    }
  ]
}