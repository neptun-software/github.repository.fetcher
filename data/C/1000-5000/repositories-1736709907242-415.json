{
  "metadata": {
    "timestamp": 1736709907242,
    "page": 415,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AltraMayor/f3",
      "stars": 2607,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0390625,
          "content": "cscope.out\n\n*.swp\n*.d\n*.o\n*~\n\ndoc/_build"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.294921875,
          "content": "FROM ubuntu:22.04\n\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends \\\n        gcc \\\n        less \\\n        libparted-dev \\\n        libudev1 \\\n        libudev-dev \\\n        make \\\n        udev\n\nCOPY . /f3\n\nWORKDIR /f3\n\nRUN make install\n\nRUN make install-extra\n\nCMD less README.rst\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.3251953125,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.3828125,
          "content": "CC ?= gcc\nCFLAGS += -std=c99 -Wall -Wextra -pedantic -MMD -ggdb\n\nTARGETS = f3write f3read\nEXTRA_TARGETS = f3probe f3brew f3fix\n\nPREFIX = /usr/local\nINSTALL = install\nLN = ln\n\nifndef OS\n\tOS = $(shell uname -s)\nendif\nifneq ($(OS), Linux)\n\tARGP = /usr/local\n\tifeq ($(OS), Darwin)\n\t\tifneq ($(shell command -v brew),)\n\t\t\tARGP = $(shell brew --prefix)\n\t\tendif\n\tendif\n\tCFLAGS += -I$(ARGP)/include\n\tLDFLAGS += -L$(ARGP)/lib -largp\nendif\n\nall: $(TARGETS)\nextra: $(EXTRA_TARGETS)\n\ndocker:\n\tdocker build -f Dockerfile -t f3:latest .\n\ninstall: all\n\t$(INSTALL) -d $(DESTDIR)$(PREFIX)/bin\n\t$(INSTALL) -m755 $(TARGETS) $(DESTDIR)$(PREFIX)/bin\n\t$(INSTALL) -d $(DESTDIR)$(PREFIX)/share/man/man1\n\t$(INSTALL) -m644 f3read.1 $(DESTDIR)$(PREFIX)/share/man/man1\n\t$(LN) -sf f3read.1 $(DESTDIR)$(PREFIX)/share/man/man1/f3write.1\n\ninstall-extra: extra\n\t$(INSTALL) -d $(DESTDIR)$(PREFIX)/bin\n\t$(INSTALL) -m755 $(EXTRA_TARGETS) $(DESTDIR)$(PREFIX)/bin\n\nf3write: utils.o libflow.o f3write.o\n\t$(CC) -o $@ $^ $(LDFLAGS) -lm\n\nf3read: utils.o libflow.o f3read.o\n\t$(CC) -o $@ $^ $(LDFLAGS) -lm\n\nf3probe: libutils.o libdevs.o libprobe.o f3probe.o\n\t$(CC) -o $@ $^ $(LDFLAGS) -lm -ludev\n\nf3brew: libutils.o libdevs.o f3brew.o\n\t$(CC) -o $@ $^ $(LDFLAGS) -lm -ludev\n\nf3fix: libutils.o f3fix.o\n\t$(CC) -o $@ $^ $(LDFLAGS) -lparted\n\n-include *.d\n\nPHONY: cscope clean\n\ncscope:\n\tcscope -b *.c *.h\n\nclean:\n\trm -f *.o *.d cscope.out $(TARGETS) $(EXTRA_TARGETS)\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 12.21484375,
          "content": "f3 - Fight Flash Fraud\n======================\n\nf3 is a simple tool that tests flash cards capacity and performance to\nsee if they live up to claimed specifications. It fills the device with\npseudorandom data and then checks if it returns the same on reading.\n\nF3 stands for Fight Flash Fraud, or Fight Fake Flash.\n\n**Table of Contents**\n\n-  `Examples <#examples>`__\n-  `Installation <#installation>`__\n-  `Other resources <#other-resources>`__\n\n.. _examples:\n\nExamples\n========\n\nWe'll use :code:`/dev/sdX` as a placeholder here, you need to replace \n:code:`X` with a lowercase letter so that it matches the device you\nwant to use.\n:code:`lsblk` will show you an overview of your current devices.\n\nTesting performance with f3read/f3write\n---------------------------------------\n\nUse these two programs in this order. f3write will write large files to\nyour mounted disk and f3read will check if the flash disk contains\nexactly the written files::\n\n    $ ./f3write /media/michel/5EBD-5C80/\n    $ ./f3read /media/michel/5EBD-5C80/\n\nPlease replace \"/media/michel/5EBD-5C80/\" with the appropriate path. USB\ndevices are mounted in \"/Volumes\" on Macs.\n\nIf you have installed f3read and f3write, you can remove the \"./\" that\nis shown before their names.\n\nQuick capacity tests with f3probe\n---------------------------------\n\nf3probe is the fastest drive test and suitable for large disks because\nit only writes what's necessary to test the drive. It operates directly\non the (unmounted) block device and needs to be run as a privileged\nuser::\n\n    # ./f3probe --destructive --time-ops /dev/sdX\n\n.. warning:: This will destroy any previously stored data on your disk!\n\nCorrecting capacity to actual size with f3fix\n---------------------------------------------\n\nf3fix creates a partition that fits the actual size of the fake drive.\nUse f3probe's output to determine the parameters for f3fix::\n\n    # ./f3fix --last-sec=16477878 /dev/sdX\n\nInstallation\n============\n\nDownload and Compile\n--------------------\n\nThe files of the stable version of F3 are\n`here <https://github.com/AltraMayor/f3/tags>`__. The\nfollowing command uncompresses the files::\n\n    $ unzip f3-8.0.zip\n\n\nCompile stable software on Linux or FreeBSD\n-------------------------------------------\n\nTo build::\n\n    make\n\nIf you want to install f3write and f3read, run the following command::\n\n    make install\n\nCompile stable software on Windows/Cygwin\n-----------------------------------------\n\nf3write and f3read can be installed on Windows, but currently f3probe, f3fix,\nand f3brew `require Linux <#the-extra-applications-for-linux>`__.  To use them\non a Windows machine, use the `Docker Installation <#docker>`__.  For f3write\nand f3read, read on.\n\nIf you haven't already, install the following Cygwin packages and their dependencies:\n\n- `gcc-core`\n- `make`\n- `libargp-devel`\n\nTo build, you need special flags::\n\n    export LDFLAGS=\"$LDFLAGS -Wl,--stack,4000000 -largp\"\n    make\n\nIf you want to install f3write and f3read, run the following command::\n\n    make install\n\nCompile stable software on Apple Mac\n------------------------------------\n\nf3write and f3read can be installed on Mac, but currently f3probe, f3fix, and\nf3brew `require Linux <#the-extra-applications-for-linux>`__.  To use them on\nMac, use the `Docker Installation <#docker>`__.  For f3write and f3read, read\non.\n\nUsing HomeBrew\n~~~~~~~~~~~~~~\n\nIf you have Homebrew already installed in your computer, the command\nbelow will install F3::\n\n    brew install f3\n\nUsing MacPorts\n~~~~~~~~~~~~~~\n\nIf you use MacPorts instead, use the following command::\n\n    port install f3\n\nCompiling the latest development version from the source code\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nMost of the f3 source code builds fine using Xcode, the only dependency\nmissing is the GNU C library \"argp\". You can build argp from scratch, or\nuse the version provided by HomeBrew and MacPorts as \"argp-standalone\"\n\nThe following steps have been tested on OS X El Capitan 10.11.\n\n1) Install Apple command line tools::\n\n       xcode-select --install\n\nSee http://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/\nfor details.\n\n2) Install Homebrew or MacPorts\n\n   HomeBrew::\n\n     /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n\n   See https://brew.sh/ for details.\n\n   MacPorts: https://www.macports.org/install.php\n\n3) Install argp library::\n\n       brew install argp-standalone\n\n   See https://formulae.brew.sh/formula/argp-standalone and\n   https://www.freshports.org/devel/argp-standalone/ for more\n   information.\n\n   Or, for MacPorts::\n\n     port install argp-standalone\n\n   See https://trac.macports.org/browser/trunk/dports/sysutils/f3/Portfile\n   for more information.\n\n4) Build F3::\n\n   When using Homebrew, you can just run::\n\n       make\n\n   When using MacPorts, you will need to pass the location where MacPorts\n   installed argp-standalone::\n\n       make ARGP=/opt/local\n\nDocker\n------\n\nQuick Start\n~~~~~~~~~~~\n\nA pre-built `image <https://cloud.docker.com/repository/docker/peron/f3>`__\nis available over at Docker Hub, ready to be used.  With docker started, just\nrun::\n\n    docker run -it --rm --device <device> peron/f3 <f3-command> [<f3-options>] <device>\n\nFor example, to probe a drive mounted at /dev/sdX::\n\n    docker run -it --rm --device /dev/sdX peron/f3 f3probe --destructive --time-ops /dev/sdX\n\nOptionally, you can also build your own container *if* you don't want to use the\npre-built image.  From this directory, run::\n\n    make docker\n\nor::\n\n    docker build -t f3:latest .\n\n\nTo run f3 commands using your newly built Docker image::\n\n    docker run -it --rm --device <device> f3:latest <f3-command> [<f3-options>] <device>\n\n    docker run -it --rm --device /dev/sdX f3:latest f3probe --destructive --time-ops /dev/sdX\n    docker run -it --rm -v /path/to/mounted/device:/mnt/ f3:latest f3write /mnt/\n    docker run -it --rm -v /path/to/mounted/device:/mnt/ f3:latest f3read /mnt/\n\nDrive Permissions / Passthrough\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nGetting the drive device to map into the Docker container is tricky for Mac and\nWindows.  Passing through devices on Mac and Windows is a well-documented issue\n(`[github]\n<https://github.com/docker/for-mac/issues/3110#issuecomment-456853036>`__\n`[stackexchange]\n<https://devops.stackexchange.com/questions/4572/how-to-pass-a-dev-disk-device-on-macos-into-linux-docker/6076#6076>`__\n`[tty]\n<https://christopherjmcclellan.wordpress.com/2019/04/21/using-usb-with-docker-for-mac/#tldr>`__)\nOn Linux it should just work, but on Mac or Windows, Docker tends to map the\ndrive as a normal directory rather than a mounted drive and you will get an\nerror like :code:`f3probe: Can't open device '/opt/usb': Is a directory`, that\nis if you can map it at all.\n\nTo solve this, we can use docker-machine to create a VirtualBox VM\n(boot2docker), in which to run the Docker container.  Since VirtualBox *can*\nhandle device pass-through, we can pass the device through to the VirtualBox VM\nwhich can then pass the device through to the Docker container.  Milad Alizadeh\nwrote up some good instructions `here\n<https://mil.ad/blog/2018/access-usb-devices-in-container-in-mac.html>`__\nwhich are geared towards USB devices, but it shouldn't be too hard to adapt to\nother drive types.  Here's what I typed into my Mac terminal (probably\nsimilar for Windows, but untested)::\n\n    docker-machine create -d virtualbox default\n    docker-machine stop\n    vboxmanage modifyvm default --usb on\n    docker-machine start\n    vboxmanage usbfilter add 0 --target default --name flashdrive --vendorid 0x0123 --productid 0x4567\n    eval $(docker-machine env default)\n\n\nFor the usbfilter add command, note that the \"name\" argument is the new name\nyou're giving the filter so you can name it whatever you want.\n:code:`--vendorid` and :code:`--productid` can be found on Mac in \"System\nInformation\" under \"USB\". You can also try searching for the right device in\n:code:`vboxmanage list usbhost`.\n\nAlternatively, you may opt to add the device through the VirtualBox GUI\napplication instead::\n\n    docker-machine create -d virtualbox default\n    docker-machine stop\n    # open VirtualBox and manually add the drive device before proceeding to the next command\n    docker-machine start\n    eval $(docker-machine env default)\n\nOnce you've run the above commands, unplug and replug the flash drive and run::\n\n    docker-machine ssh default \"lsblk\"\n\nto list the devices. Search for the correct drive - the \"SIZE\" column may be\nhelpful in locating the device of interest. For example, :code:`sdb` is a common\nmount point for a USB drive.  Now you should be able to run the command from\nQuick Start::\n\n    docker run --rm -it --device /dev/sdX peron/f3 f3probe --destructive --time-ops /dev/sdX\n\nYou may find it useful to enter a bash prompt in the Docker container to poke\naround the filesystem::\n\n    docker run --rm -it --device /dev/sdX peron/f3 bash\n\nso that you can run commands like :code:`ls /dev/*`.\n\nThe extra applications for Linux\n--------------------------------\n\nInstall dependencies\n~~~~~~~~~~~~~~~~~~~~\n\nf3probe and f3brew require version 1 of the library libudev, and f3fix\nrequires version 0 of the library libparted to compile. On Ubuntu, you\ncan install these libraries with the following command::\n\n    sudo apt-get install libudev1 libudev-dev libparted-dev\n\nIf you are running a version of Ubuntu before 20.04.1, replace the package `libparted-dev`\non the command line above with `libparted0-dev`.\n\nOn Fedora, you can install these libraries with the following command::\n\n    sudo dnf install systemd-devel parted-devel\n\nCompile the extra applications\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    make extra\n\n.. note::\n   - The extra applications are only compiled and tested on Linux\n     platform.\n   - Please do not e-mail me saying that you want the extra\n     applications to run on your platform; I already know that.\n   - If you want the extra applications to run on your platform, help\n     to port them, or find someone that can port them for you. If you\n     do port any of them, please send me a patch to help others.\n   - The extra applications are f3probe, f3brew, and f3fix.\n\nIf you want to install the extra applications, run the following\ncommand::\n\n    make install-extra\n\nOther resources\n===============\n\nGraphical User Interfaces\n-------------------------\n\nThanks to our growing community of flash fraud fighters,\nwe have the following graphical user interfaces (GUI) available for F3:\n\n`F3 QT <https://github.com/zwpwjwtz/f3-qt>`__ is a Linux GUI that uses\nQT. F3 QT supports ``f3write``, ``f3read``, ``f3probe``, and ``f3fix``. Author:\nTianze.\n\n`F3XSwift <https://github.com/vrunkel/F3XSwift>`__ is a Mac GUI. F3XSwift supports ``f3write`` and ``f3read``. Author:\nVolker Runkel.\n\nPlease support the above projects by testing them and giving feedback to their\nauthors. This will improve their code as it has improved mine.\n\nFiles\n-----\n\n- ``changelog`` - Change log for package maintainers\n- ``f3read.1`` - Man page for f3read and f3write\n\n  In order to read this manual page, run ``man ./f3read.1``.\n  To install the page, run\n  ``install --owner=root --group=root --mode=644 f3read.1 /usr/share/man/man1``.\n\n- ``LICENSE`` - License (GPLv3)\n- ``Makefile`` - make(1) file\n- ``README`` - This file\n- ``*.h`` and ``*.c`` - C code of F3\n\nBash scripts\n------------\n\nAlthough the simple scripts listed in this section are ready for use,\nthey are really meant to help you to write your own scripts. So you can\npersonalize F3 to your specific needs:\n\n- ``f3write.h2w`` - Script to create files exactly like H2testw.\n\n  Use example: ``f3write.h2w /media/michel/5EBD-5C80/``.\n\n- ``log-f3wr`` - Script that runs f3write and f3read, and records\n  their output into a log file.\n\n  Use example: ``log-f3wr log-filename /media/michel/5EBD-5C80/``.\n\nPlease notice that all scripts and use examples above assume that\nf3write, f3read, and the scripts are in the same folder.\n\nFlakyflash\n----------\n\nIf your flash isn't fraudulent (or you've run f3fix to \"fix\" it) but\nyou're still seeing some sporadic data corruption, then you may have\n\"flaky flash.\" If your flash is formatted using the FAT file system,\nthen you can use `Flakyflash <https://github.com/whitslack/flakyflash>`__\nto find the flaky data clusters and mark them as bad in the FAT. This\nmay allow you to get a little more use out of your flash, but you\nshould still consider it as failing and replace it ASAP.\n"
        },
        {
          "name": "changelog",
          "type": "blob",
          "size": 2.8427734375,
          "content": "Version 8.0 - Oct 29, 2020\n\n    * f3read: add parameter --max-read-rate\n    * f3read: report speed, percentage, remaining time like f3write\n    * f3write: improve speed measurement (commit 791acdc32627...)\n    * f3probe: handle rare assertion failure (issue #82 ENODATA)\n\nVersion 7.2 - Jun 19, 2019\n\n    * f3write: keep up with extremely fast NVM drives (issue #117)\n    * f3write: improve measurement of write speed (issue #102)\n    * f3write: handle rare assertion failure (issue #111)\n    * f3probe: handle rare assertion failure (issue #82)\n\nVersion 7.1 - Jul 27, 2018\n\n    * fix compilation issues on non-Linux OSs\n    * f3write: make parameter --max-write-rate work precisely\n    * f3probe: change default reset type to RT_NONE\n\nVersion 7.0 - Dec 21, 2017\n\n    * stable version of f3probe, f3fix, and f3brew (Linux only)\n    * f3write: improved write speed and dealing with write failures\n\nVersion 6.0 - Dec 24, 2015\n\n    * f3probe: new algorithm.\n    * f3fix: deal with sectors whose sizes are not 512B.\n    * add f3brew (experimental).\n\nVersion 5.0 - Dec 24, 2014\n\n    * add f3probe (experimental).\n    * add f3fix   (experimental).\n    * fix building issue on Macs.\n\nVersion 4.0 - Sep 9, 2014\n\n    * add support for FreeBSD.\n    * add optional parameter --end-at=NUM to F3.\n    * add scripts f3write.h2w and log-f3wr.\n    * unify Makefile.\n\nVersion 3.0 - May 14, 2014\n\n    * fix bug first reported by John Lussmyer.\n    * add support for Windows/Cygwin.\n    * add a change log (this) and a man page.\n    * adopt h2testw's file format.\n\nVersion 2.2 - Feb 8, 2013\n\n    * add optional parameter --start-at=NUM to F3.\n    * remove arbitrary limit on filenames.\n    * fix bug first reported by Martin Theiss.\n    * minor code refinements.\n\nVersion 2.1 - Mar 7, 2012\n\n    * report version and copyright in help message.\n    * made f3write remove old F3 files in order.\n    * refined flow control algorithm of f3write.\n    * verify that \"all\" F3 files are present.\n    * added a rough approximation of posix_fadvise for Macs.\n\nVersion 2.0 - Dec 20, 2011\n\n    * added a very simple Makefile.\n    * reviewed code.\n    * added support for Macs.\n    * f3write now reports proper progress.\n    * added progress printout in f3read.\n    * improved precision of speed measurements.\n    * formatted code following Linux's coding style.\n\nVersion 1.1.3 - Sep 21, 2010\n\n    * fixes some warning issued by GCC when compiling f3read.c on 64bits\n      machines. Nicolai Abruzzese was the first one to report this issue.\n\nVersion 1.1.2 - Aug 31, 2010\n\n    * handles an I/O error reported by Misha Aizatulin.\n\nVersion 1.1.1 - Aug 16, 2010\n\n    * fixes some warnings issued by gcc when the parameter -Wall is used\n      to compile the source.\n\nVersion 1.1 - Aug 10, 2010\n\n    * adds a nice report at the end of the output of f3read.\n    * works fine with large memory cards.\n\nVersion 1.0 - Aug 02, 2010\n\n    * Initial release.\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "f3brew.c",
          "type": "blob",
          "size": 11.7626953125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n#include <string.h>\n#include <argp.h>\n#include <inttypes.h>\n#include <err.h>\n\n#include \"version.h\"\n#include \"libutils.h\"\n#include \"libdevs.h\"\n\n/* Argp's global variables. */\nconst char *argp_program_version = \"F3 BREW \" F3_STR_VERSION;\n\n/* Arguments. */\nstatic char adoc[] = \"<DISK_DEV>\";\n\n/* The capital \"E\" in \"REad\" in the string below is not a typo.\n * It shows from where the name B-RE-W comes.\n */\nstatic char doc[] = \"F3 Block REad and Write -- assess the media of \"\n\t\"a block device writing blocks, resetting the drive, and \"\n\t\"reading the blocks back\";\n\nstatic struct argp_option options[] = {\n\t{\"debug\",\t\t'd',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Enable debugging; only needed if none --debug-* option used\",\n\t\t1},\n\t{\"debug-real-size\",\t'r',\t\"SIZE_BYTE\",\tOPTION_HIDDEN,\n\t\t\"Real size of the emulated drive\",\t0},\n\t{\"debug-fake-size\",\t'f',\t\"SIZE_BYTE\",\tOPTION_HIDDEN,\n\t\t\"Fake size of the emulated drive\",\t0},\n\t{\"debug-wrap\",\t\t'w',\t\"N\",\t\tOPTION_HIDDEN,\n\t\t\"Wrap parameter of the emulated drive\",\t0},\n\t{\"debug-block-order\",\t'b',\t\"ORDER\",\tOPTION_HIDDEN,\n\t\t\"Block size of the emulated drive is 2^ORDER Bytes\",\t0},\n\t{\"debug-cache-order\",\t'c',\t\"ORDER\",\tOPTION_HIDDEN,\n\t\t\"Cache size of the emulated drive is 2^ORDER blocks\",\t0},\n\t{\"debug-strict-cache\",\t'o',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Force the cache to be strict\",\t\t\t\t0},\n\t{\"debug-keep-file\",\t'k',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Don't remove file used for emulating the drive\",\t0},\n\t{\"reset-type\",\t\t's',\t\"TYPE\",\t\t0,\n\t\t\"Reset method to use during the probe\",\t\t2},\n\t{\"start-at\",\t\t'h',\t\"BLOCK\",\t0,\n\t\t\"Where test begins; the default is block zero\",\t0},\n\t{\"end-at\",\t\t'e',\t\"BLOCK\",\t0,\n\t\t\"Where test ends; the default is the very last block\",\t0},\n\t{\"do-not-write\",\t'W',\tNULL,\t\t0,\n\t\t\"Do not write blocks\",\t\t\t\t0},\n\t{\"do-not-read\",\t\t'R',\tNULL,\t\t0,\n\t\t\"Do not read blocks\",\t\t\t\t0},\n\t{ 0 }\n};\n\nstruct args {\n\tchar\t\t*filename;\n\n\t/* Debugging options. */\n\tbool\t\tdebug;\n\tbool\t\tkeep_file;\n\n\t/* Behavior options. */\n\tenum reset_type\treset_type;\n\tbool test_write;\n\tbool test_read;\n\t/* 3 free bytes. */\n\n\t/* Geometry. */\n\tuint64_t\treal_size_byte;\n\tuint64_t\tfake_size_byte;\n\tint\t\twrap;\n\tint\t\tblock_order;\n\tint\t\tcache_order;\n\tint\t\tstrict_cache;\n\n\t/* What to do. */\n\tuint64_t\tfirst_block;\n\tuint64_t\tlast_block;\n};\n\nstatic error_t parse_opt(int key, char *arg, struct argp_state *state)\n{\n\tstruct args *args = state->input;\n\tlong long ll;\n\n\tswitch (key) {\n\tcase 'd':\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'r':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"Real size must be greater or equal to zero\");\n\t\targs->real_size_byte = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'f':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"Fake size must be greater or equal to zero\");\n\t\targs->fake_size_byte = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'w':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0 || ll >= 64)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrap must be in the interval [0, 63]\");\n\t\targs->wrap = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'b':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll != 0 && (ll < 9 || ll > 20))\n\t\t\targp_error(state,\n\t\t\t\t\"Block order must be in the interval [9, 20] or be zero\");\n\t\targs->block_order = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'c':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < -1 || ll > 64)\n\t\t\targp_error(state,\n\t\t\t\t\"Cache order must be in the interval [-1, 64]\");\n\t\targs->cache_order = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'o':\n\t\targs->strict_cache = true;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'k':\n\t\targs->keep_file = true;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 's':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0 || ll >= RT_MAX)\n\t\t\targp_error(state,\n\t\t\t\t\"Reset type must be in the interval [0, %i]\",\n\t\t\t\tRT_MAX - 1);\n\t\targs->reset_type = ll;\n\t\tbreak;\n\n\tcase 'h':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"The first block must be greater or equal to zero\");\n\t\targs->first_block = ll;\n\t\tbreak;\n\n\tcase 'e':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"The last block must be greater or equal to zero\");\n\t\targs->last_block = ll;\n\t\tbreak;\n\n\tcase 'W':\n\t\targs->test_write = false;\n\t\tbreak;\n\n\tcase 'R':\n\t\targs->test_read = false;\n\t\tbreak;\n\n\tcase ARGP_KEY_INIT:\n\t\targs->filename = NULL;\n\t\tbreak;\n\n\tcase ARGP_KEY_ARG:\n\t\tif (args->filename)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrong number of arguments; only one is allowed\");\n\t\targs->filename = arg;\n\t\tbreak;\n\n\tcase ARGP_KEY_END:\n\t\tif (!args->filename)\n\t\t\targp_error(state,\n\t\t\t\t\"The disk device was not specified\");\n\t\tif (args->debug &&\n\t\t\t!dev_param_valid(args->real_size_byte,\n\t\t\t\targs->fake_size_byte, args->wrap,\n\t\t\t\targs->block_order))\n\t\t\targp_error(state,\n\t\t\t\t\"The debugging parameters are not valid\");\n\n\t\tif (args->first_block > args->last_block)\n\t\t\targp_error(state,\n\t\t\t\t\"The first block parameter must be less or equal to the last block parameter. They are now: first_block=%\"\n\t\t\t\tPRIu64 \" > last_block=%\" PRIu64,\n\t\t\t\targs->first_block, args->last_block);\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic struct argp argp = {options, parse_opt, adoc, doc, NULL, NULL, NULL};\n\nstatic void write_blocks(struct device *dev,\n\tuint64_t first_block, uint64_t last_block)\n{\n\tconst int block_order = dev_get_block_order(dev);\n\tconst int block_size = dev_get_block_size(dev);\n\tchar stack[align_head(block_order) + BIG_BLOCK_SIZE_BYTE];\n\tchar *buffer = align_mem(stack, block_order);\n\tchar *stamp_blk = buffer;\n\tchar *flush_blk = buffer + BIG_BLOCK_SIZE_BYTE;\n\tuint64_t offset = first_block << block_order;\n\tuint64_t pos, first_pos = first_block;\n\n\tassert(BIG_BLOCK_SIZE_BYTE >= block_size);\n\n\tfor (pos = first_block; pos <= last_block; pos++) {\n\t\tfill_buffer_with_block(stamp_blk, block_order, offset, 0);\n\t\tstamp_blk += block_size;\n\t\toffset += block_size;\n\n\t\tif (stamp_blk == flush_blk || pos == last_block) {\n\t\t\tif (dev_write_blocks(dev, buffer, first_pos, pos))\n\t\t\t\twarn(\"Failed to write blocks from 0x%\" PRIx64\n\t\t\t\t\t\" to 0x%\" PRIx64, first_pos, pos);\n\t\t\tstamp_blk = buffer;\n\t\t\tfirst_pos = pos + 1;\n\t\t}\n\t}\n}\n\n/* XXX Properly handle return errors. */\nstatic void test_write_blocks(struct device *dev,\n\tuint64_t first_block, uint64_t last_block)\n{\n\tprintf(\"Writing blocks from 0x%\" PRIx64 \" to 0x%\" PRIx64 \"...\",\n\t\tfirst_block, last_block);\n\tfflush(stdout);\n\twrite_blocks(dev, first_block, last_block);\n\tprintf(\" Done\\n\\n\");\n}\n\nenum block_state {\n\tbs_unknown,\n\tbs_good,\n\tbs_bad,\n\tbs_overwritten,\n};\n\nstruct block_range {\n\tenum block_state\tstate;\n\tint\t\t\tblock_order;\n\tuint64_t\t\tstart_sector_offset;\n\tuint64_t\t\tend_sector_offset;\n\n\t/* Only used by state bs_overwritten. */\n\tuint64_t\t\tfound_sector_offset;\n};\n\nstatic const char *block_state_to_str(enum block_state state)\n{\n\tconst char *conv_array[] = {\n\t\t[bs_unknown] = \"Unknown\",\n\t\t[bs_good] = \"Good\",\n\t\t[bs_bad] = \"Bad\",\n\t\t[bs_overwritten] = \"Overwritten\",\n\t};\n\treturn conv_array[state];\n}\n\nstatic int is_block(uint64_t offset, int block_order)\n{\n\treturn !(((1ULL << block_order) - 1) & offset);\n}\n\nstatic void print_offset(uint64_t offset, int block_order)\n{\n\tassert(is_block(offset, block_order));\n\tprintf(\"block 0x%\" PRIx64, offset >> block_order);\n}\n\nstatic void print_block_range(const struct block_range *range)\n{\n\tprintf(\"[%s] from \", block_state_to_str(range->state));\n\tprint_offset(range->start_sector_offset, range->block_order);\n\tprintf(\" to \");\n\tprint_offset(range->end_sector_offset, range->block_order);\n\n\tswitch (range->state) {\n\tcase bs_good:\n\tcase bs_bad:\n\t\tbreak;\n\n\tcase bs_overwritten:\n\t\tprintf(\", found \");\n\t\tprint_offset(range->found_sector_offset, range->block_order);\n\t\tbreak;\n\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic void validate_block(uint64_t expected_sector_offset,\n\tconst char *probe_blk, int block_order, struct block_range *range)\n{\n\tuint64_t found_sector_offset;\n\tenum block_state state;\n\tbool push_range;\n\n\tif (validate_buffer_with_block(probe_blk, block_order,\n\t\t&found_sector_offset, 0))\n\t\tstate = bs_bad; /* Bad block. */\n\telse if (expected_sector_offset == found_sector_offset)\n\t\tstate = bs_good; /* Good block. */\n\telse\n\t\tstate = bs_overwritten; /* Overwritten block. */\n\n\tpush_range = (range->state != state) || (\n\t\t\tstate == bs_overwritten\n\t\t\t&& (\n\t\t\t\t(expected_sector_offset\n\t\t\t\t\t- range->start_sector_offset)\n\t\t\t\t!=\n\t\t\t\t(found_sector_offset\n\t\t\t\t\t- range->found_sector_offset)\n\t\t\t)\n\t\t);\n\n\tif (push_range) {\n\t\tif (range->state != bs_unknown)\n\t\t\tprint_block_range(range);\n\t\trange->state = state;\n\t\trange->start_sector_offset = expected_sector_offset;\n\t\trange->end_sector_offset = expected_sector_offset;\n\t\trange->found_sector_offset = found_sector_offset;\n\t} else {\n\t\trange->end_sector_offset = expected_sector_offset;\n\t}\n}\n\nstatic void read_blocks(struct device *dev,\n\tuint64_t first_block, uint64_t last_block)\n{\n\tconst int block_size = dev_get_block_size(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\tchar stack[align_head(block_order) + BIG_BLOCK_SIZE_BYTE];\n\tchar *buffer = align_mem(stack, block_order);\n\tuint64_t expected_sector_offset = first_block << block_order;\n\tuint64_t first_pos = first_block;\n\tuint64_t step = (BIG_BLOCK_SIZE_BYTE >> block_order) - 1;\n\tstruct block_range range = {\n\t\t.state = bs_unknown,\n\t\t.block_order = block_order,\n\t\t.start_sector_offset = 0,\n\t\t.end_sector_offset = 0,\n\t\t.found_sector_offset = 0,\n\t};\n\n\tassert(BIG_BLOCK_SIZE_BYTE >= block_size);\n\n\twhile (first_pos <= last_block) {\n\t\tchar *probe_blk = buffer;\n\t\tuint64_t pos, next_pos = first_pos + step;\n\n\t\tif (next_pos > last_block)\n\t\t\tnext_pos = last_block;\n\t\tif (dev_read_blocks(dev, buffer, first_pos, next_pos))\n\t\t\twarn(\"Failed to read blocks from 0x%\" PRIx64\n\t\t\t\t\" to 0x%\" PRIx64, first_pos, next_pos);\n\n\t\tfor (pos = first_pos; pos <= next_pos; pos++) {\n\t\t\tvalidate_block(expected_sector_offset, probe_blk,\n\t\t\t\tblock_order, &range);\n\t\t\texpected_sector_offset += block_size;\n\t\t\tprobe_blk += block_size;\n\t\t}\n\n\t\tfirst_pos = next_pos + 1;\n\t}\n\tif (range.state != bs_unknown)\n\t\tprint_block_range(&range);\n\telse\n\t\tassert(first_block > last_block);\n}\n\n/* XXX Properly handle return errors. */\nstatic void test_read_blocks(struct device *dev,\n\tuint64_t first_block, uint64_t last_block)\n{\n\tprintf(\"Reading blocks from 0x%\" PRIx64 \" to 0x%\" PRIx64 \":\\n\",\n\t\tfirst_block, last_block);\n\tread_blocks(dev, first_block, last_block);\n\tprintf(\"\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\tstruct args args = {\n\t\t/* Defaults. */\n\t\t.debug\t\t= false,\n\t\t.keep_file\t= false,\n\t\t.reset_type\t= RT_MANUAL_USB,\n\t\t.test_write\t= true,\n\t\t.test_read\t= true,\n\t\t.real_size_byte\t= 1ULL << 31,\n\t\t.fake_size_byte\t= 1ULL << 34,\n\t\t.wrap\t\t= 31,\n\t\t.block_order\t= 0,\n\t\t.cache_order\t= -1,\n\t\t.strict_cache\t= false,\n\t\t.first_block\t= 0,\n\t\t.last_block\t= -1ULL,\n\t};\n\tstruct device *dev;\n\tuint64_t very_last_block;\n\n\t/* Read parameters. */\n\targp_parse(&argp, argc, argv, 0, NULL, &args);\n\tprint_header(stdout, \"brew\");\n\n\tdev = args.debug\n\t\t? create_file_device(args.filename, args.real_size_byte,\n\t\t\targs.fake_size_byte, args.wrap, args.block_order,\n\t\t\targs.cache_order, args.strict_cache, args.keep_file)\n\t\t: create_block_device(args.filename, args.reset_type);\n\tif (!dev) {\n\t\tfprintf(stderr, \"\\nApplication cannot continue, finishing...\\n\");\n\t\texit(1);\n\t}\n\n\tprintf(\"Physical block size: 2^%i Bytes\\n\\n\", dev_get_block_order(dev));\n\n\tvery_last_block =\n\t\t(dev_get_size_byte(dev) >> dev_get_block_order(dev)) - 1;\n\tif (args.first_block > very_last_block)\n\t\targs.first_block = very_last_block;\n\tif (args.last_block > very_last_block)\n\t\targs.last_block = very_last_block;\n\n\tif (args.test_write)\n\t\ttest_write_blocks(dev, args.first_block, args.last_block);\n\n\tif (args.test_write && args.test_read) {\n\t\tconst char *final_dev_filename;\n\n\t\tassert(!dev_reset(dev));\n\t\tfinal_dev_filename = dev_get_filename(dev);\n\t\tif (strcmp(args.filename, final_dev_filename))\n\t\t\tprintf(\"\\nWARNING: device `%s' moved to `%s' due to the reset\\n\\n\",\n\t\t\t\targs.filename, final_dev_filename);\n\t}\n\n\tif (args.test_read)\n\t\ttest_read_blocks(dev, args.first_block, args.last_block);\n\n\tfree_device(dev);\n\treturn 0;\n}\n"
        },
        {
          "name": "f3fix.c",
          "type": "blob",
          "size": 6.361328125,
          "content": "#include <stdbool.h>\n#include <assert.h>\n#include <argp.h>\n#include <parted/parted.h>\n\n#include \"version.h\"\n#include \"libutils.h\"\n\n/* Argp's global variables. */\nconst char *argp_program_version = \"F3 Fix \" F3_STR_VERSION;\n\n/* Arguments. */\nstatic char adoc[] = \"<DISK_DEV>\";\n\nstatic char doc[] = \"F3 Fix -- edit the partition table of \"\n\t\"a fake flash drive to have a single partition that fully covers \"\n\t\"the real capacity of the drive\";\n\nstatic struct argp_option options[] = {\n\t{\"disk-type\",\t\t'd',\t\"TYPE\",\t\t0,\n\t\t\"Disk type of the partition table\",\t\t\t2},\n\t{\"fs-type\",\t\t'f',\t\"TYPE\",\t\t0,\n\t\t\"Type of the file system of the partition\",\t\t0},\n\t{\"boot\",\t\t\t'b',\tNULL,\t\t0,\n\t\t\"Mark the partition for boot\",\t\t\t\t0},\n\t{\"no-boot\",\t\t'n',\tNULL,\t\t0,\n\t\t\"Do not mark the partition for boot\",\t\t\t0},\n\t{\"first-sec\",\t\t'a',\t\"SEC-NUM\",\t0,\n\t\t\"Sector where the partition starts\",\t\t\t0},\n\t{\"last-sec\",\t\t'l',\t\"SEC-NUM\",\t0,\n\t\t\"Sector where the partition ends\",\t\t\t0},\n\t{\"list-disk-types\",\t'k',\tNULL,\t\t0,\n\t\t\"List all supported disk types\",\t\t\t3},\n\t{\"list-fs-types\",\t's',\tNULL,\t\t0,\n\t\t\"List all supported types of file systems\",\t\t0},\n\t{ 0 }\n};\n\nstruct args {\n\tbool\tlist_disk_types;\n\tbool\tlist_fs_types;\n\n\tbool\tboot;\n\n\t/* 29 free bytes. */\n\n\tconst char\t\t*dev_filename;\n\tPedDiskType\t\t*disk_type;\n\tPedFileSystemType\t*fs_type;\n\tPedSector\t\tfirst_sec;\n\tPedSector\t\tlast_sec;\n};\n\nstatic long long arg_to_long_long(const struct argp_state *state,\n\tconst char *arg)\n{\n\tchar *end;\n\tlong long ll = strtoll(arg, &end, 0);\n\tif (!arg)\n\t\targp_error(state, \"An integer must be provided\");\n\tif (!*arg || *end)\n\t\targp_error(state, \"`%s' is not an integer\", arg);\n\treturn ll;\n}\n\nstatic error_t parse_opt(int key, char *arg, struct argp_state *state)\n{\n\tstruct args *args = state->input;\n\tlong long ll;\n\n\tswitch (key) {\n\tcase 'd':\n\t\targs->disk_type = ped_disk_type_get(arg);\n\t\tif (!args->disk_type)\n\t\t\targp_error(state,\n\t\t\t\t\"Disk type `%s' is not supported; use --list-disk-types to see the supported types\",\n\t\t\t\targ);\n\t\tbreak;\n\n\tcase 'f':\n\t\targs->fs_type = ped_file_system_type_get(arg);\n\t\tif (!args->fs_type)\n\t\t\targp_error(state,\n\t\t\t\t\"File system type `%s' is not supported; use --list-fs-types to see the supported types\",\n\t\t\t\targ);\n\t\tbreak;\n\n\tcase 'b':\n\t\targs->boot = true;\n\t\tbreak;\n\n\tcase 'n':\n\t\targs->boot = false;\n\t\tbreak;\n\n\tcase 'a':\n\t\tll = arg_to_long_long(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"First sector must be greater or equal to 0\");\n\t\targs->first_sec = ll;\n\t\tbreak;\n\n\tcase 'l':\n\t\tll = arg_to_long_long(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"Last sector must be greater or equal to 0\");\n\t\targs->last_sec = ll;\n\t\tbreak;\n\n\tcase 'k':\n\t\targs->list_disk_types = true;\n\t\tbreak;\n\n\tcase 's':\n\t\targs->list_fs_types = true;\n\t\tbreak;\n\n\tcase ARGP_KEY_INIT:\n\t\targs->dev_filename = NULL;\n\t\targs->last_sec = -1;\n\t\tbreak;\n\n\tcase ARGP_KEY_ARG:\n\t\tif (args->dev_filename)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrong number of arguments; only one is allowed\");\n\t\targs->dev_filename = arg;\n\t\tbreak;\n\n\tcase ARGP_KEY_END:\n\t\tif (args->list_disk_types || args->list_fs_types)\n\t\t\tbreak;\n\n\t\tif (!args->dev_filename)\n\t\t\targp_error(state,\n\t\t\t\t\"The disk device was not specified\");\n\n\t\tif (args->last_sec < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"Option --last-sec is required\");\n\t\tif (args->first_sec > args->last_sec)\n\t\t\targp_error(state,\n\t\t\t\t\"Option --fist_sec must be less or equal to option --last_sec\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic struct argp argp = {options, parse_opt, adoc, doc, NULL, NULL, NULL};\n\nstatic void list_disk_types(void)\n{\n\tPedDiskType *type;\n\tint i = 0;\n\tprintf(\"Disk types:\\n\");\n\tfor (type = ped_disk_type_get_next(NULL); type;\n\t\ttype = ped_disk_type_get_next(type)) {\n\t\tprintf(\"%s\\t\", type->name);\n\t\ti++;\n\t\tif (i == 5) {\n\t\t\tprintf(\"\\n\");\n\t\t\ti = 0;\n\t\t}\n\t}\n\tif (i > 0)\n\t\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n}\n\nstatic void list_fs_types(void)\n{\n\tPedFileSystemType *fs_type;\n\tint i = 0;\n\tprintf(\"File system types:\\n\");\n\tfor (fs_type = ped_file_system_type_get_next(NULL); fs_type;\n\t\tfs_type = ped_file_system_type_get_next(fs_type)) {\n\t\tprintf(\"%s\\t\", fs_type->name);\n\t\ti++;\n\t\tif (i == 5) {\n\t\t\tprintf(\"\\n\");\n\t\t\ti = 0;\n\t\t}\n\t}\n\tif (i > 0)\n\t\tprintf(\"\\n\");\n\tprintf(\"\\n\");\n}\n\nstatic PedSector map_sector_to_logical_sector(PedSector sector,\n\tint logical_sector_size)\n{\n\tassert(logical_sector_size >= 512);\n\tassert(logical_sector_size % 512 == 0);\n\treturn sector / (logical_sector_size / 512);\n}\n\n/* 0 on failure, 1 otherwise. */\nstatic int fix_disk(PedDevice *dev, PedDiskType *type,\n\tPedFileSystemType *fs_type, int boot, PedSector start, PedSector end)\n{\n\tPedDisk *disk;\n\tPedPartition *part;\n\tPedGeometry *geom;\n\tPedConstraint *constraint;\n\tint ret = 0;\n\n\tdisk = ped_disk_new_fresh(dev, type);\n\tif (!disk)\n\t\tgoto out;\n\n\tstart = map_sector_to_logical_sector(start, dev->sector_size);\n\tend = map_sector_to_logical_sector(end, dev->sector_size);\n\tpart = ped_partition_new(disk, PED_PARTITION_NORMAL,\n\t\tfs_type, start, end);\n\tif (!part)\n\t\tgoto disk;\n\tif (boot && !ped_partition_set_flag(part, PED_PARTITION_BOOT, 1))\n\t\tgoto part;\n\n\tgeom = ped_geometry_new(dev, start, end - start + 1);\n\tif (!geom)\n\t\tgoto part;\n\tconstraint = ped_constraint_exact(geom);\n\tped_geometry_destroy(geom);\n\tif (!constraint)\n\t\tgoto part;\n\n\tret = ped_disk_add_partition(disk, part, constraint);\n\tped_constraint_destroy(constraint);\n\tif (!ret)\n\t\tgoto part;\n\t/* ped_disk_print(disk); */\n\n\tret = ped_disk_commit(disk);\n\tgoto disk;\n\npart:\n\tped_partition_destroy(part);\ndisk:\n\tped_disk_destroy(disk);\nout:\n\treturn ret;\n}\n\nint main (int argc, char *argv[])\n{\n\tstruct args args = {\n\t\t/* Defaults. */\n\t\t.list_disk_types\t= false,\n\t\t.list_fs_types\t\t= false,\n\n\t\t.boot\t\t\t= true,\n\n\t\t.disk_type\t\t= ped_disk_type_get(\"msdos\"),\n\t\t.fs_type\t\t= ped_file_system_type_get(\"fat32\"),\n\t\t.first_sec\t\t= 2048,\t/* Skip first 1MB. */\n\t};\n\n\tPedDevice *dev;\n\tint ret;\n\n\t/* Read parameters. */\n\targp_parse(&argp, argc, argv, 0, NULL, &args);\n\tprint_header(stdout, \"fix\");\n\n\tif (args.list_disk_types)\n\t\tlist_disk_types();\n\n\tif (args.list_fs_types)\n\t\tlist_fs_types();\n\n\tif (args.list_disk_types || args.list_fs_types) {\n\t\t/* If the user has asked for the types,\n\t\t * she doesn't want to fix the drive yet.\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* XXX If @dev is a partition, refer the user to\n\t * the disk of this partition.\n\t */\n\tdev = ped_device_get(args.dev_filename);\n\tif (!dev)\n\t\treturn 1;\n\n\tret = !fix_disk(dev, args.disk_type, args.fs_type, args.boot,\n\t\targs.first_sec, args.last_sec);\n\tprintf(\"Drive `%s' was successfully fixed\\n\", args.dev_filename);\n\tped_device_destroy(dev);\n\treturn ret;\n}\n"
        },
        {
          "name": "f3probe.c",
          "type": "blob",
          "size": 15.0185546875,
          "content": "#define _POSIX_C_SOURCE 200809L\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <argp.h>\n#include <stdbool.h>\n#include <assert.h>\n#include <inttypes.h>\n#include <sys/time.h>\n\n#include \"version.h\"\n#include \"libprobe.h\"\n#include \"libutils.h\"\n\n/* Argp's global variables. */\nconst char *argp_program_version = \"F3 Probe \" F3_STR_VERSION;\n\n/* Arguments. */\nstatic char adoc[] = \"<DISK_DEV>\";\n\nstatic char doc[] = \"F3 Probe -- probe a block device for \"\n\t\"counterfeit flash memory. If counterfeit, \"\n\t\"f3probe identifies the fake type and real memory size\";\n\nstatic struct argp_option options[] = {\n\t{\"debug\",\t\t'd',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Enable debugging; only needed if none --debug-* option used\",\n\t\t1},\n\t{\"debug-real-size\",\t'r',\t\"SIZE_BYTE\",\tOPTION_HIDDEN,\n\t\t\"Real size of the emulated drive\",\t0},\n\t{\"debug-fake-size\",\t'f',\t\"SIZE_BYTE\",\tOPTION_HIDDEN,\n\t\t\"Fake size of the emulated drive\",\t0},\n\t{\"debug-wrap\",\t\t'w',\t\"N\",\t\tOPTION_HIDDEN,\n\t\t\"Wrap parameter of the emulated drive\",\t0},\n\t{\"debug-block-order\",\t'b',\t\"ORDER\",\tOPTION_HIDDEN,\n\t\t\"Block size of the emulated drive is 2^ORDER Bytes\",\t0},\n\t{\"debug-cache-order\",\t'c',\t\"ORDER\",\tOPTION_HIDDEN,\n\t\t\"Cache size of the emulated drive is 2^ORDER blocks\",\t0},\n\t{\"debug-strict-cache\",\t'o',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Force the cache to be strict\",\t\t\t\t0},\n\t{\"debug-keep-file\",\t'k',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Don't remove file used for emulating the drive\",\t0},\n\t{\"debug-unit-test\",\t'u',\tNULL,\t\tOPTION_HIDDEN,\n\t\t\"Run a unit test; it ignores all other debug options\",\t0},\n\t{\"destructive\",\t\t'n',\tNULL,\t\t0,\n\t\t\"Do not restore blocks of the device after probing it\",\t2},\n\t{\"min-memory\",\t\t'l',\tNULL,\t\t0,\n\t\t\"Trade speed for less use of memory\",\t\t0},\n\t{\"reset-type\",\t\t's',\t\"TYPE\",\t\t0,\n\t\t\"Reset method to use during the probe\",\t\t0},\n\t{\"time-ops\",\t\t't',\tNULL,\t\t0,\n\t\t\"Time reads, writes, and resets\",\t\t0},\n\t{ 0 }\n};\n\nstruct args {\n\tchar\t\t*filename;\n\n\t/* Debugging options. */\n\tbool\t\tdebug;\n\tbool\t\tunit_test;\n\tbool\t\tkeep_file;\n\n\t/* Behavior options. */\n\tbool\t\tsave;\n\tbool\t\tmin_mem;\n\tenum reset_type\treset_type;\n\tbool\t\ttime_ops;\n\t/* 1 free bytes. */\n\n\t/* Geometry. */\n\tuint64_t\treal_size_byte;\n\tuint64_t\tfake_size_byte;\n\tint\t\twrap;\n\tint\t\tblock_order;\n\tint\t\tcache_order;\n\tint\t\tstrict_cache;\n};\n\nstatic error_t parse_opt(int key, char *arg, struct argp_state *state)\n{\n\tstruct args *args = state->input;\n\tlong long ll;\n\n\tswitch (key) {\n\tcase 'd':\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'r':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"Real size must be greater or equal to zero\");\n\t\targs->real_size_byte = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'f':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0)\n\t\t\targp_error(state,\n\t\t\t\t\"Fake size must be greater or equal to zero\");\n\t\targs->fake_size_byte = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'w':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0 || ll >= 64)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrap must be in the interval [0, 63]\");\n\t\targs->wrap = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'b':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll != 0 && (ll < 9 || ll > 20))\n\t\t\targp_error(state,\n\t\t\t\t\"Block order must be in the interval [9, 20] or be zero\");\n\t\targs->block_order = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'c':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < -1 || ll > 64)\n\t\t\targp_error(state,\n\t\t\t\t\"Cache order must be in the interval [-1, 64]\");\n\t\targs->cache_order = ll;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'o':\n\t\targs->strict_cache = true;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'k':\n\t\targs->keep_file = true;\n\t\targs->debug = true;\n\t\tbreak;\n\n\tcase 'u':\n\t\targs->unit_test = true;\n\t\tbreak;\n\n\tcase 'n':\n\t\targs->save = false;\n\t\tbreak;\n\n\tcase 'l':\n\t\targs->min_mem = true;\n\t\tbreak;\n\n\tcase 's':\n\t\tll = arg_to_ll_bytes(state, arg);\n\t\tif (ll < 0 || ll >= RT_MAX)\n\t\t\targp_error(state,\n\t\t\t\t\"Reset type must be in the interval [0, %i]\",\n\t\t\t\tRT_MAX - 1);\n\t\targs->reset_type = ll;\n\t\tbreak;\n\n\tcase 't':\n\t\targs->time_ops = true;\n\t\tbreak;\n\n\tcase ARGP_KEY_INIT:\n\t\targs->filename = NULL;\n\t\tbreak;\n\n\tcase ARGP_KEY_ARG:\n\t\tif (args->filename)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrong number of arguments; only one is allowed\");\n\t\targs->filename = arg;\n\t\tbreak;\n\n\tcase ARGP_KEY_END:\n\t\tif (!args->filename)\n\t\t\targp_error(state,\n\t\t\t\t\"The disk device was not specified\");\n\t\tif (args->debug &&\n\t\t\t!dev_param_valid(args->real_size_byte,\n\t\t\t\targs->fake_size_byte, args->wrap,\n\t\t\t\targs->block_order))\n\t\t\targp_error(state,\n\t\t\t\t\"The debugging parameters are not valid\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic struct argp argp = {options, parse_opt, adoc, doc, NULL, NULL, NULL};\n\nstruct unit_test_item {\n\tuint64_t\treal_size_byte;\n\tuint64_t\tfake_size_byte;\n\tint\t\twrap;\n\tint\t\tblock_order;\n\tint\t\tcache_order;\n\tint\t\tstrict_cache;\n};\n\nstatic const struct unit_test_item ftype_to_params[] = {\n\t/* Smallest good drive. */\n\t{1ULL << 21,\t1ULL << 21,\t21,\t9,\t-1,\tfalse},\n\n\t/* Good, 4KB-block, 1GB drive. */\n\t{1ULL << 30,\t1ULL << 30,\t30,\t12,\t-1,\tfalse},\n\n\t/* Bad drive. */\n\t{0,\t\t1ULL << 30,\t30,\t9,\t-1,\tfalse},\n\n\t/* Geometry of a real limbo drive. */\n\t{1777645568ULL,\t32505331712ULL,\t35,\t9,\t-1,\tfalse},\n\n\t/* Wraparound drive. */\n\t{1ULL << 31,\t1ULL << 34,\t31,\t9,\t-1,\tfalse},\n\n\t/* Chain drive. */\n\t{1ULL << 31,\t1ULL << 34,\t32,\t9,\t-1,\tfalse},\n\n\t/* Extreme case for memory usage (limbo drive). */\n\t{(1ULL<<20)+512,1ULL << 40,\t40,\t9,\t-1,\tfalse},\n\n\t/* Geometry of a real limbo drive with 256MB of strict cache. */\n\t{7600799744ULL,\t67108864000ULL,\t36,\t9,\t19,\ttrue},\n\n\t/* The drive before with a non-strict cache. */\n\t{7600799744ULL,\t67108864000ULL,\t36,\t9,\t19,\tfalse},\n\n\t/* The devil drive I. */\n\t{0,\t\t1ULL << 40,\t40,\t9,\t21,\ttrue},\n\n\t/* The devil drive II. */\n\t{0,\t\t1ULL << 40,\t40,\t9,\t21,\tfalse},\n};\n\n#define UNIT_TEST_N_CASES \\\n\t((int)(sizeof(ftype_to_params)/sizeof(struct unit_test_item)))\n\nstatic int unit_test(const char *filename)\n{\n\tint i, success = 0;\n\tfor (i = 0; i < UNIT_TEST_N_CASES; i++) {\n\t\tconst struct unit_test_item *item = &ftype_to_params[i];\n\t\tenum fake_type origin_type = dev_param_to_type(\n\t\t\titem->real_size_byte, item->fake_size_byte,\n\t\t\titem->wrap, item->block_order);\n\t\tuint64_t item_cache_byte = item->cache_order < 0 ? 0 :\n\t\t\t1ULL << (item->cache_order + item->block_order);\n\t\tdouble f_real = item->real_size_byte;\n\t\tdouble f_fake = item->fake_size_byte;\n\t\tdouble f_cache = item_cache_byte;\n\t\tconst char *unit_real = adjust_unit(&f_real);\n\t\tconst char *unit_fake = adjust_unit(&f_fake);\n\t\tconst char *unit_cache = adjust_unit(&f_cache);\n\n\t\tenum fake_type fake_type;\n\t\tuint64_t real_size_byte, announced_size_byte, cache_size_block;\n\t\tint wrap, need_reset, block_order, max_probe_blocks;\n\t\tstruct device *dev;\n\n\t\tdev = create_file_device(filename, item->real_size_byte,\n\t\t\titem->fake_size_byte, item->wrap, item->block_order,\n\t\t\titem->cache_order, item->strict_cache, false);\n\t\tassert(dev);\n\t\tmax_probe_blocks = probe_device_max_blocks(dev);\n\t\tassert(!probe_device(dev, &real_size_byte, &announced_size_byte,\n\t\t\t&wrap, &cache_size_block, &need_reset, &block_order));\n\t\tfree_device(dev);\n\t\tfake_type = dev_param_to_type(real_size_byte,\n\t\t\tannounced_size_byte, wrap, block_order);\n\n\t\t/* Report */\n\t\tprintf(\"Test %i\\t\\ttype/real size/fake size/module/cache size/reset/block size\\n\",\n\t\t\ti + 1);\n\t\tprintf(\"\\t\\t%s/%.2f %s/%.2f %s/2^%i Byte/%.2f %s/no/2^%i Byte\\n\",\n\t\t\tfake_type_to_name(origin_type),\n\t\t\tf_real, unit_real, f_fake, unit_fake, item->wrap,\n\t\t\tf_cache, unit_cache, item->block_order);\n\t\tif (real_size_byte == item->real_size_byte &&\n\t\t\tannounced_size_byte == item->fake_size_byte &&\n\t\t\twrap == item->wrap &&\n\t\t\t/* probe_device() returns an upper bound of\n\t\t\t * the cache size.\n\t\t\t */\n\t\t\titem_cache_byte <= (cache_size_block << block_order) &&\n\t\t\t!need_reset &&\n\t\t\tblock_order == item->block_order) {\n\t\t\tsuccess++;\n\t\t\tprintf(\"\\t\\tPerfect!\\tMax # of probed blocks: %i\\n\\n\",\n\t\t\t\tmax_probe_blocks);\n\t\t} else {\n\t\t\tdouble ret_f_real = real_size_byte;\n\t\t\tdouble ret_f_fake = announced_size_byte;\n\t\t\tdouble ret_f_cache = cache_size_block << block_order;\n\t\t\tconst char *ret_unit_real = adjust_unit(&ret_f_real);\n\t\t\tconst char *ret_unit_fake = adjust_unit(&ret_f_fake);\n\t\t\tconst char *ret_unit_cache = adjust_unit(&ret_f_cache);\n\t\t\tprintf(\"\\tError\\t%s/%.2f %s/%.2f %s/2^%i Byte/%.2f %s/%s/2^%i Byte\\n\\n\",\n\t\t\t\tfake_type_to_name(fake_type),\n\t\t\t\tret_f_real, ret_unit_real,\n\t\t\t\tret_f_fake, ret_unit_fake, wrap,\n\t\t\t\tret_f_cache, ret_unit_cache,\n\t\t\t\tneed_reset ? \"yes\" : \"no\", block_order);\n\t\t}\n\t}\n\n\tprintf(\"SUMMARY: \");\n\tif (success == UNIT_TEST_N_CASES)\n\t\tprintf(\"Perfect!\\n\");\n\telse\n\t\tprintf(\"Missed %i tests out of %i\\n\",\n\t\t\tUNIT_TEST_N_CASES - success, UNIT_TEST_N_CASES);\n\treturn 0;\n}\n\nstatic void report_size(const char *prefix, uint64_t bytes, int block_order)\n{\n\tdouble f = bytes;\n\tconst char *unit = adjust_unit(&f);\n\tprintf(\"%s %.2f %s (%\" PRIu64 \" blocks)\\n\", prefix, f, unit,\n\t\tbytes >> block_order);\n}\n\nstatic void report_order(const char *prefix, int order)\n{\n\tdouble f = (1ULL << order);\n\tconst char *unit = adjust_unit(&f);\n\tprintf(\"%s %.2f %s (2^%i Bytes)\\n\", prefix, f, unit, order);\n}\n\nstatic void report_cache(const char *prefix, uint64_t cache_size_block,\n\tint need_reset, int order)\n{\n\tdouble f = (cache_size_block << order);\n\tconst char *unit = adjust_unit(&f);\n\tprintf(\"%s %.2f %s (%\" PRIu64 \" blocks), need-reset=%s\\n\",\n\t\tprefix, f, unit, cache_size_block,\n\t\tneed_reset ? \"yes\" : \"no\");\n}\n\nstatic void report_probe_time(const char *prefix, uint64_t usec)\n{\n\tchar str[TIME_STR_SIZE];\n\tusec_to_str(usec, str);\n\tprintf(\"%s %s\\n\", prefix, str);\n}\n\nstatic void report_ops(const char *op, uint64_t count, uint64_t time_us)\n{\n\tchar str1[TIME_STR_SIZE], str2[TIME_STR_SIZE];\n\tusec_to_str(time_us, str1);\n\tusec_to_str(count > 0 ? time_us / count : 0, str2);\n\tprintf(\"%10s: %s / %\" PRIu64 \" = %s\\n\", op, str1, count, str2);\n}\n\nstatic int test_device(struct args *args)\n{\n\tstruct timeval t1, t2;\n\tstruct device *dev, *pdev, *sdev;\n\tenum fake_type fake_type;\n\tuint64_t real_size_byte, announced_size_byte, cache_size_block;\n\tint wrap, need_reset, block_order;\n\tuint64_t read_count, read_time_us;\n\tuint64_t write_count, write_time_us;\n\tuint64_t reset_count, reset_time_us;\n\tconst char *final_dev_filename;\n\n\tdev = args->debug\n\t\t? create_file_device(args->filename, args->real_size_byte,\n\t\t\targs->fake_size_byte, args->wrap, args->block_order,\n\t\t\targs->cache_order, args->strict_cache, args->keep_file)\n\t\t: create_block_device(args->filename, args->reset_type);\n\tif (!dev) {\n\t\tfprintf(stderr, \"\\nApplication cannot continue, finishing...\\n\");\n\t\texit(1);\n\t}\n\n\tif (args->time_ops) {\n\t\tpdev = create_perf_device(dev);\n\t\tassert(pdev);\n\t\tdev = pdev;\n\t} else {\n\t\tpdev = NULL;\n\t}\n\n\tsdev = NULL;\n\tif (args->save) {\n\t\tsdev = create_safe_device(dev,\n\t\t\tprobe_device_max_blocks(dev), args->min_mem);\n\t\tif (!sdev) {\n\t\t\tif (!args->min_mem)\n\t\t\t\tfprintf(stderr, \"Out of memory, try `f3probe --min-memory %s'\\n\",\n\t\t\t\t\tdev_get_filename(dev));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Out of memory, try `f3probe --destructive %s'\\nPlease back your data up before using option --destructive.\\nAlternatively, you could use a machine with more memory to run f3probe.\\n\",\n\t\t\t\t\tdev_get_filename(dev));\n\t\t\texit(1);\n\t\t}\n\t\tdev = sdev;\n\t}\n\n\tprintf(\"WARNING: Probing normally takes from a few seconds to 15 minutes, but\\n\");\n\tprintf(\"         it can take longer. Please be patient.\\n\\n\");\n\n\tassert(!gettimeofday(&t1, NULL));\n\t/* XXX Have a better error handling to recover\n\t * the state of the drive.\n\t */\n\tassert(!probe_device(dev, &real_size_byte, &announced_size_byte,\n\t\t&wrap, &cache_size_block, &need_reset, &block_order));\n\tassert(!gettimeofday(&t2, NULL));\n\n\tif (!args->debug && args->reset_type == RT_MANUAL_USB) {\n\t\tprintf(\"CAUTION\\t\\tCAUTION\\t\\tCAUTION\\n\");\n\t\tprintf(\"No more resets are needed, so do not unplug the drive\\n\");\n\t\tfflush(stdout);\n\t}\n\n\t/* Keep free_device() as close of probe_device() as possible to\n\t * make sure that the written blocks are recovered when\n\t * @args->save is true.\n\t */\n\tif (args->time_ops)\n\t\tperf_device_sample(pdev,\n\t\t\t&read_count, &read_time_us,\n\t\t\t&write_count, &write_time_us,\n\t\t\t&reset_count, &reset_time_us);\n\tif (sdev) {\n\t\tuint64_t very_last_pos = real_size_byte >> block_order;\n\t\tprintf(\"Probe finished, recovering blocks...\");\n\t\tfflush(stdout);\n\t\tif (very_last_pos > 0) {\n\t\t\tvery_last_pos--;\n\t\t\tsdev_recover(sdev, very_last_pos);\n\t\t}\n\t\tprintf(\" Done\\n\");\n\t\tsdev_flush(sdev);\n\t}\n\n\tfinal_dev_filename = strdup(dev_get_filename(dev));\n\tassert(final_dev_filename);\n\tfree_device(dev);\n\n\tif (args->save || (!args->debug && args->reset_type == RT_MANUAL_USB))\n\t\tprintf(\"\\n\");\n\n\tif (strcmp(args->filename, final_dev_filename))\n\t\tprintf(\"WARNING: device `%s' moved to `%s' due to the resets\\n\\n\",\n\t\t\targs->filename, final_dev_filename);\n\n\tfake_type = dev_param_to_type(real_size_byte, announced_size_byte,\n\t\twrap, block_order);\n\tswitch (fake_type) {\n\tcase FKTY_GOOD:\n\t\tprintf(\"Good news: The device `%s' is the real thing\\n\",\n\t\t\tfinal_dev_filename);\n\t\tbreak;\n\n\tcase FKTY_BAD:\n\t\tprintf(\"Bad news: The device `%s' is damaged\\n\",\n\t\t\tfinal_dev_filename);\n\t\tbreak;\n\n\tcase FKTY_LIMBO:\n\tcase FKTY_WRAPAROUND:\n\tcase FKTY_CHAIN: {\n\t\tuint64_t last_good_sector = (real_size_byte >> 9) - 1;\n\t\tassert(block_order >= 9);\n\t\tprintf(\"Bad news: The device `%s' is a counterfeit of type %s\\n\\n\"\n\t\t\t\"You can \\\"fix\\\" this device using the following command:\\n\"\n\t\t\t\"f3fix --last-sec=%\" PRIu64 \" %s\\n\",\n\t\t\tfinal_dev_filename, fake_type_to_name(fake_type),\n\t\t\tlast_good_sector, final_dev_filename);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tassert(0);\n\t\tbreak;\n\t}\n\n\tprintf(\"\\nDevice geometry:\\n\");\n\t  report_size(\"\\t         *Usable* size:\", real_size_byte,\n\t\tblock_order);\n\t  report_size(\"\\t        Announced size:\", announced_size_byte,\n\t\tblock_order);\n\t report_order(\"\\t                Module:\", wrap);\n\t report_cache(\"\\tApproximate cache size:\", cache_size_block,\n\t\tneed_reset, block_order);\n\t report_order(\"\\t   Physical block size:\", block_order);\n\treport_probe_time(\"\\nProbe time:\", diff_timeval_us(&t1, &t2));\n\n\tif (args->time_ops) {\n\t\tprintf(\" Operation: total time / count = avg time\\n\");\n\t\treport_ops(\"Read\", read_count, read_time_us);\n\t\treport_ops(\"Write\", write_count, write_time_us);\n\t\treport_ops(\"Reset\", reset_count, reset_time_us);\n\t}\n\n\tfree((void *)final_dev_filename);\n\treturn fake_type == FKTY_GOOD ? 0 : 100 + fake_type;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct args args = {\n\t\t/* Defaults. */\n\t\t.debug\t\t= false,\n\t\t.unit_test\t= false,\n\t\t.keep_file\t= false,\n\t\t.save\t\t= true,\n\t\t.min_mem\t= false,\n\n\t\t/* RT_NONE is the only reliable reset type against fake flash.\n\t\t * See issue #81 for details:\n\t\t * https://github.com/AltraMayor/f3/issues/81\n\t\t *\n\t\t * A side benefit of this reset type is that it works on\n\t\t * non-USB-backed drives, such as card readers that are\n\t\t * commonly built in laptops.\n\t\t * See issue #79 for details:\n\t\t * https://github.com/AltraMayor/f3/issues/79\n\t\t *\n\t\t * A negative side effect is that f3probe runs slower\n\t\t * for cases in which RT_USB would work. But users can\n\t\t * still request the reset type RT_USB by\n\t\t * passing --reset-type=1\n\t\t */\n\t\t.reset_type\t= RT_NONE,\n\n\t\t.time_ops\t= false,\n\t\t.real_size_byte\t= 1ULL << 31,\n\t\t.fake_size_byte\t= 1ULL << 34,\n\t\t.wrap\t\t= 31,\n\t\t.block_order\t= 0,\n\t\t.cache_order\t= -1,\n\t\t.strict_cache\t= false,\n\t};\n\n\t/* Read parameters. */\n\targp_parse(&argp, argc, argv, 0, NULL, &args);\n\tprint_header(stdout, \"probe\");\n\n\tif (args.unit_test)\n\t\treturn unit_test(args.filename);\n\treturn test_device(&args);\n}\n"
        },
        {
          "name": "f3read.1",
          "type": "blob",
          "size": 1.4248046875,
          "content": ".\\\"Text automatically generated by txt2man\n.TH F3 \"1\"  \"October 2020\" \"F3 8.0\" \"test real flash memory capacity\"\n.SH NAME\n\\fBf3write, f3read \\fP- test real flash memory capacity\n.SH SYNOPSIS\n.nf\n.fam C\n\\fBf3write\\fP [\\fB--start-at\\fP=NUM] [\\fB--end-at\\fP=NUM] <PATH>\n\\fBf3read\\fP  [\\fB--start-at\\fP=NUM] [\\fB--end-at\\fP=NUM] <PATH>\n.fam T\n.fi\n.fam T\n.fi\n.SH DESCRIPTION\nF3 (Fight Flash Fraud or Fight Fake Flash) tests the full capacity\nof a flash card (flash drive, flash disk, pendrive). It writes to the\ncard and then checks if can read it. It will assure you haven't been\nsold a card with a smaller capacity than stated.\n.PP\nWhen writing to flash drive, \\fBf3write\\fP fills the filesystem with 1GB\nfiles named N.h2w, where N is a number (i.e. /[0-9]+/).\n.PP\nWARNING: all data on the tested disk might be lost!\n.SH OPTIONS\n.TP\n\\fB--start-at\\fP=NUM\nInitial number of file names. Default value is 1.\n.TP\n\\fB--end-at\\fP=NUM\nFinal number of file names. Default value is \"infinity\".\n.SH EXAMPLE\nTo write over a flash drive mounted at /media/TEST:\n.PP\n.nf\n.fam C\n      $ f3write /media/TEST\n\n.fam T\n.fi\nTo read this flash drive:\n.PP\n.nf\n.fam C\n      $ f3read /media/TEST\n.fam T\n.fi\n.SH SEE ALSO\nFor detailed information about the F3 tools, see:\n.PP\nhttps://fight-flash-fraud.readthedocs.io/en/stable/\n.SH AUTHOR\nF3 was written by Michel Machado <michel@digirati.com.br>.\nThis manual page was first written by Joao Eriberto Mota Filho <eriberto@eriberto.pro.br>.\n"
        },
        {
          "name": "f3read.c",
          "type": "blob",
          "size": 10.8662109375,
          "content": "#define _POSIX_C_SOURCE 200112L\n#define _XOPEN_SOURCE 600\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <err.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <argp.h>\n\n#include \"utils.h\"\n#include \"libflow.h\"\n#include \"version.h\"\n\n/* Argp's global variables. */\nconst char *argp_program_version = \"F3 Read \" F3_STR_VERSION;\n\n/* Arguments. */\nstatic char adoc[] = \"<PATH>\";\n\nstatic char doc[] = \"F3 Read -- validate .h2w files to test \"\n\t\"the real capacity of the drive\";\n\nstatic struct argp_option options[] = {\n\t{\"start-at\",\t\t's',\t\"NUM\",\t\t0,\n\t\t\"First NUM.h2w file to be read\",\t\t\t1},\n\t{\"end-at\",\t\t'e',\t\"NUM\",\t\t0,\n\t\t\"Last NUM.h2w file to be read\",\t\t\t\t0},\n\t{\"max-read-rate\",\t'r',\t\"KB/s\",\t\t0,\n\t\t\"Maximum read rate\",\t\t\t\t\t0},\n\t{\"show-progress\",\t'p',\t\"NUM\",\t\t0,\n\t\t\"Show progress if NUM is not zero\",\t\t\t0},\n\t{ 0 }\n};\n\nstruct args {\n\tlong        start_at;\n\tlong        end_at;\n\tlong        max_read_rate;\n\tint\t    show_progress;\n\tconst char  *dev_path;\n};\n\nstatic error_t parse_opt(int key, char *arg, struct argp_state *state)\n{\n\tstruct args *args = state->input;\n\tlong l;\n\n\tswitch (key) {\n\tcase 's':\n\t\tl = arg_to_long(state, arg);\n\t\tif (l <= 0)\n\t\t\targp_error(state,\n\t\t\t\t\"NUM must be greater than zero\");\n\t\targs->start_at = l - 1;\n\t\tbreak;\n\n\tcase 'e':\n\t\tl = arg_to_long(state, arg);\n\t\tif (l <= 0)\n\t\t\targp_error(state,\n\t\t\t\t\"NUM must be greater than zero\");\n\t\targs->end_at = l - 1;\n\t\tbreak;\n\n\tcase 'r':\n\t\tl = arg_to_long(state, arg);\n\t\tif (l <= 0)\n\t\t\targp_error(state,\n\t\t\t\t\"KB/s must be greater than zero\");\n\t\targs->max_read_rate = l;\n\t\tbreak;\n\n\tcase 'p':\n\t\targs->show_progress = !!arg_to_long(state, arg);\n\t\tbreak;\n\n\tcase ARGP_KEY_INIT:\n\t\targs->dev_path = NULL;\n\t\tbreak;\n\n\tcase ARGP_KEY_ARG:\n\t\tif (args->dev_path)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrong number of arguments; only one is allowed\");\n\t\targs->dev_path = arg;\n\t\tbreak;\n\n\tcase ARGP_KEY_END:\n\t\tif (!args->dev_path)\n\t\t\targp_error(state,\n\t\t\t\t\"The disk path was not specified\");\n\t\tif (args->start_at > args->end_at)\n\t\t\targp_error(state,\n\t\t\t\t\"Option --start-at must be less or equal to option --end-at\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic struct argp argp = {options, parse_opt, adoc, doc, NULL, NULL, NULL};\n\nstruct file_stats {\n\tuint64_t secs_ok;\n\tuint64_t secs_corrupted;\n\tuint64_t secs_changed;\n\tuint64_t secs_overwritten;\n\n\tuint64_t bytes_read;\n\tint read_all;\n};\n\nstatic inline void zero_fstats(struct file_stats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n}\n\n#define TOLERANCE\t2\n\nstatic void check_sector(char *_sector, uint64_t expected_offset,\n\tstruct file_stats *stats)\n{\n\tuint64_t *sector = (uint64_t *)_sector;\n\tuint64_t rn;\n\tconst int num_int64 = SECTOR_SIZE >> 3;\n\tint error_count, i;\n\n\trn = sector[0];\n\terror_count = 0;\n\tfor (i = 1; error_count <= TOLERANCE && i < num_int64; i++) {\n\t\trn = random_number(rn);\n\t\tif (rn != sector[i])\n\t\t\terror_count++;\n\t}\n\n\tif (expected_offset == sector[0]) {\n\t\tif (error_count == 0)\n\t\t\tstats->secs_ok++;\n\t\telse if (error_count <= TOLERANCE)\n\t\t\tstats->secs_changed++;\n\t\telse\n\t\t\tstats->secs_corrupted++;\n\t} else if (error_count <= TOLERANCE)\n\t\tstats->secs_overwritten++;\n\telse\n\t\tstats->secs_corrupted++;\n}\n\nstatic uint64_t check_buffer(char *buf, size_t size, uint64_t expected_offset,\n\tstruct file_stats *stats)\n{\n\tchar *beyond_buf = buf + size;\n\n\tassert(size % SECTOR_SIZE == 0);\n\n\twhile (buf < beyond_buf) {\n\t\tcheck_sector(buf, expected_offset, stats);\n\t\tbuf += SECTOR_SIZE;\n\t\texpected_offset += SECTOR_SIZE;\n\t}\n\treturn expected_offset;\n}\n\nstatic ssize_t read_all(int fd, char *buf, size_t count)\n{\n\tsize_t done = 0;\n\tdo {\n\t\tssize_t rc = read(fd, buf + done, count - done);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn - errno;\n\t\t}\n\t\tif (rc == 0)\n\t\t\tbreak;\n\t\tdone += rc;\n\t} while (done < count);\n\treturn done;\n}\n\nstatic ssize_t check_chunk(struct dynamic_buffer *dbuf, int fd,\n\tuint64_t *p_expected_offset, uint64_t chunk_size,\n\tstruct file_stats *stats)\n{\n\tchar *buf = dbuf_get_buf(dbuf, chunk_size);\n\tsize_t len = dbuf_get_len(dbuf);\n\tssize_t tot_bytes_read = 0;\n\n\twhile (chunk_size > 0) {\n\t\tsize_t turn_size = chunk_size <= len ? chunk_size : len;\n\t\tssize_t bytes_read = read_all(fd, buf, turn_size);\n\n\t\tif (bytes_read < 0) {\n\t\t\tstats->bytes_read += tot_bytes_read;\n\t\t\treturn bytes_read;\n\t\t}\n\n\t\tif (bytes_read == 0)\n\t\t\tbreak;\n\n\t\ttot_bytes_read += bytes_read;\n\t\tchunk_size -= bytes_read;\n\t\t*p_expected_offset = check_buffer(buf, bytes_read,\n\t\t\t*p_expected_offset, stats);\n\t}\n\n\tstats->bytes_read += tot_bytes_read;\n\treturn tot_bytes_read;\n}\n\nstatic inline void print_status(const struct file_stats *stats)\n{\n\tprintf(\"%7\" PRIu64 \"/%9\" PRIu64 \"/%7\" PRIu64 \"/%7\" PRIu64,\n\t\tstats->secs_ok, stats->secs_corrupted, stats->secs_changed,\n\t\tstats->secs_overwritten);\n}\n\nstatic void validate_file(const char *path, int number, struct flow *fw,\n\tstruct file_stats *stats)\n{\n\tchar *full_fn;\n\tconst char *filename;\n\tint fd, saved_errno;\n\tssize_t bytes_read;\n\tuint64_t expected_offset;\n\tstruct dynamic_buffer dbuf;\n\n\tzero_fstats(stats);\n\n\tfull_fn = full_fn_from_number(&filename, path, number);\n\tassert(full_fn);\n\tprintf(\"Validating file %s ... \", filename);\n\tfflush(stdout);\n#ifdef __CYGWIN__\n\t/* We don't need write access, but some kernels require that\n\t * the file descriptor passed to fdatasync(2) to be writable.\n\t */\n\tfd = open(full_fn, O_RDWR);\n#else\n\tfd = open(full_fn, O_RDONLY);\n#endif\n\tif (fd < 0)\n\t\terr(errno, \"Can't open file %s\", full_fn);\n\n\t/* If the kernel follows our advice, f3read won't ever read from cache\n\t * even when testing small memory cards without a remount, and\n\t * we should have a better reading-speed measurement.\n\t */\n\tif (fdatasync(fd) < 0) {\n\t\tint saved_errno = errno;\n\t\t/* The issue https://github.com/AltraMayor/f3/issues/211\n\t\t * motivated the warning below.\n\t\t */\n\t\tprintf(\"\\nWARNING:\\nThe operating system returned errno=%i for fdatasync(): %s\\nThis error is unexpected and you may find more information on the log of the kernel (e.g. command dmesg(1) on Linux).\\n\\n\",\n\t\t\tsaved_errno, strerror(saved_errno));\n\t\texit(saved_errno);\n\t}\n\tassert(!posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED));\n\n\t/* Help the kernel to help us. */\n\tassert(!posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL));\n\n\tdbuf_init(&dbuf);\n\tsaved_errno = 0;\n\texpected_offset = (uint64_t)number * GIGABYTES;\n\tstart_measurement(fw);\n\twhile (true) {\n\t\tbytes_read = check_chunk(&dbuf, fd, &expected_offset,\n\t\t\tget_rem_chunk_size(fw), stats);\n\t\tif (bytes_read == 0)\n\t\t\tbreak;\n\t\tif (bytes_read < 0) {\n\t\t\tsaved_errno = - bytes_read;\n\t\t\tbreak;\n\t\t}\n\t\tif (measure(fd, fw, bytes_read) < 0) {\n\t\t\tsaved_errno = errno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (end_measurement(fd, fw) < 0) {\n\t\t/* If a write failure has happened before, preserve it. */\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t}\n\n\tprint_status(stats);\n\tstats->read_all = bytes_read == 0;\n\tif (!stats->read_all) {\n\t\tassert(saved_errno);\n\t\tprintf(\" - NOT fully read due to \\\"%s\\\"\",\n\t\t\tstrerror(saved_errno));\n\t} else if (saved_errno) {\n\t\tprintf(\" - %s\", strerror(saved_errno));\n\t}\n\tprintf(\"\\n\");\n\n\tdbuf_free(&dbuf);\n\tclose(fd);\n\tfree(full_fn);\n}\n\nstatic void report(const char *prefix, uint64_t i)\n{\n\tdouble f = (double) (i * SECTOR_SIZE);\n\tconst char *unit = adjust_unit(&f);\n\tprintf(\"%s %.2f %s (%\" PRIu64 \" sectors)\\n\", prefix, f, unit, i);\n}\n\nstatic uint64_t get_total_size(const char *path, const long *files)\n{\n\tuint64_t total_size = 0;\n\n\twhile (*files >= 0) {\n\t\tstruct stat st;\n\t\tint ret;\n\t\tconst char *filename;\n\t\tchar *full_fn = full_fn_from_number(&filename, path, *files);\n\t\tassert(full_fn);\n\n\t\tret = stat(full_fn, &st);\n\t\tif (ret < 0)\n\t\t\terr(errno, \"Can't stat file %s\", full_fn);\n\t\tif ((st.st_mode & S_IFMT) != S_IFREG)\n\t\t\terr(EINVAL, \"File %s is not a regular file\", full_fn);\n\t\tassert(st.st_size >= 0);\n\t\ttotal_size += st.st_size;\n\n\t\tfree(full_fn);\n\t\tfiles++;\n\t}\n\treturn total_size;\n}\n\nstatic inline void pr_avg_speed(double speed)\n{\n\tconst char *unit = adjust_unit(&speed);\n\tprintf(\"Average reading speed: %.2f %s/s\\n\", speed, unit);\n}\n\nstatic void iterate_files(const char *path, const long *files,\n\tlong start_at, long end_at, long max_read_rate, int progress)\n{\n\tuint64_t tot_ok, tot_corrupted, tot_changed, tot_overwritten, tot_size;\n\tint and_read_all = 1;\n\tint or_missing_file = 0;\n\tlong number = start_at;\n\tstruct flow fw;\n\tstruct timeval t1, t2;\n\n\tUNUSED(end_at);\n\n\tinit_flow(&fw, get_total_size(path, files), max_read_rate,\n\t\tprogress, NULL);\n\ttot_ok = tot_corrupted = tot_changed = tot_overwritten = tot_size = 0;\n\tprintf(\"                  SECTORS \"\n\t\t\"     ok/corrupted/changed/overwritten\\n\");\n\n\tassert(!gettimeofday(&t1, NULL));\n\twhile (*files >= 0) {\n\t\tstruct file_stats stats;\n\n\t\tor_missing_file = or_missing_file || (*files != number);\n\t\tfor (; number < *files; number++) {\n\t\t\tconst char *filename;\n\t\t\tchar *full_fn = full_fn_from_number(&filename, \"\",\n\t\t\t\tnumber);\n\t\t\tassert(full_fn);\n\t\t\tprintf(\"Missing file %s\\n\", filename);\n\t\t\tfree(full_fn);\n\t\t}\n\t\tnumber++;\n\n\t\tvalidate_file(path, *files, &fw, &stats);\n\t\ttot_ok += stats.secs_ok;\n\t\ttot_corrupted += stats.secs_corrupted;\n\t\ttot_changed += stats.secs_changed;\n\t\ttot_overwritten += stats.secs_overwritten;\n\t\ttot_size += stats.bytes_read;\n\t\tand_read_all = and_read_all && stats.read_all;\n\t\tfiles++;\n\t}\n\tassert(!gettimeofday(&t2, NULL));\n\tassert(tot_size == SECTOR_SIZE *\n\t\t(tot_ok + tot_corrupted + tot_changed + tot_overwritten));\n\n\t/* Notice that not reporting `missing' files after the last file\n\t * in @files is important since @end_at could be very large.\n\t */\n\n\treport(\"\\n  Data OK:\", tot_ok);\n\treport(\"Data LOST:\", tot_corrupted + tot_changed + tot_overwritten);\n\treport(\"\\t       Corrupted:\", tot_corrupted);\n\treport(\"\\tSlightly changed:\", tot_changed);\n\treport(\"\\t     Overwritten:\", tot_overwritten);\n\tif (or_missing_file)\n\t\tprintf(\"WARNING: Not all F3 files in the range %li to %li are available\\n\",\n\t\t\tstart_at + 1, number);\n\tif (!and_read_all)\n\t\tprintf(\"WARNING: Not all data was read due to I/O error(s)\\n\");\n\n\t/* Reading speed. */\n\tif (has_enough_measurements(&fw)) {\n\t\tpr_avg_speed(get_avg_speed(&fw));\n\t} else {\n\t\t/* If the drive is too fast for the measurements above,\n\t\t * try a coarse approximation of the reading speed.\n\t\t */\n\t\tint64_t total_time_ms = delay_ms(&t1, &t2);\n\t\tif (total_time_ms > 0) {\n\t\t\tpr_avg_speed(get_avg_speed_given_time(&fw,\n\t\t\t\ttotal_time_ms));\n\t\t} else {\n\t\t\tprintf(\"Reading speed not available\\n\");\n\t\t}\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tconst long *files;\n\n\tstruct args args = {\n\t\t/* Defaults. */\n\t\t.start_at\t= 0,\n\t\t.end_at\t\t= LONG_MAX - 1,\n\t\t.max_read_rate\t= 0,\n\t\t/* If stdout isn't a terminal, suppress progress. */\n\t\t.show_progress\t= isatty(STDOUT_FILENO),\n\t};\n\n\t/* Read parameters. */\n\targp_parse(&argp, argc, argv, 0, NULL, &args);\n\tprint_header(stdout, \"read\");\n\n\tadjust_dev_path(&args.dev_path);\n\n\tfiles = ls_my_files(args.dev_path, args.start_at, args.end_at);\n\n\titerate_files(args.dev_path, files, args.start_at, args.end_at,\n\t\targs.max_read_rate, args.show_progress);\n\tfree((void *)files);\n\treturn 0;\n}\n"
        },
        {
          "name": "f3write.c",
          "type": "blob",
          "size": 9.0771484375,
          "content": "#define _POSIX_C_SOURCE 200112L\n#define _XOPEN_SOURCE 600\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <err.h>\n#include <argp.h>\n\n#include \"utils.h\"\n#include \"libflow.h\"\n#include \"version.h\"\n\n/* Argp's global variables. */\nconst char *argp_program_version = \"F3 Write \" F3_STR_VERSION;\n\n/* Arguments. */\nstatic char adoc[] = \"<PATH>\";\n\nstatic char doc[] = \"F3 Write -- fill a drive out with .h2w files \"\n\t\"to test its real capacity\";\n\nstatic struct argp_option options[] = {\n\t{\"start-at\",\t\t's',\t\"NUM\",\t\t0,\n\t\t\"First NUM.h2w file to be written\",\t\t\t1},\n\t{\"end-at\",\t\t'e',\t\"NUM\",\t\t0,\n\t\t\"Last NUM.h2w file to be written\",\t\t\t0},\n\t{\"max-write-rate\",\t'w',\t\"KB/s\",\t\t0,\n\t\t\"Maximum write rate\",\t\t\t\t\t0},\n\t{\"show-progress\",\t'p',\t\"NUM\",\t\t0,\n\t\t\"Show progress if NUM is not zero\",\t\t\t0},\n\t{ 0 }\n};\n\nstruct args {\n\tlong\t\tstart_at;\n\tlong\t\tend_at;\n\tlong\t\tmax_write_rate;\n\tint\t\tshow_progress;\n\tconst char\t*dev_path;\n};\n\nstatic error_t parse_opt(int key, char *arg, struct argp_state *state)\n{\n\tstruct args *args = state->input;\n\tlong l;\n\n\tswitch (key) {\n\tcase 's':\n\t\tl = arg_to_long(state, arg);\n\t\tif (l <= 0)\n\t\t\targp_error(state,\n\t\t\t\t\"NUM must be greater than zero\");\n\t\targs->start_at = l - 1;\n\t\tbreak;\n\n\tcase 'e':\n\t\tl = arg_to_long(state, arg);\n\t\tif (l <= 0)\n\t\t\targp_error(state,\n\t\t\t\t\"NUM must be greater than zero\");\n\t\targs->end_at = l - 1;\n\t\tbreak;\n\n\tcase 'w':\n\t\tl = arg_to_long(state, arg);\n\t\tif (l <= 0)\n\t\t\targp_error(state,\n\t\t\t\t\"KB/s must be greater than zero\");\n\t\targs->max_write_rate = l;\n\t\tbreak;\n\n\tcase 'p':\n\t\targs->show_progress = !!arg_to_long(state, arg);\n\t\tbreak;\n\n\tcase ARGP_KEY_INIT:\n\t\targs->dev_path = NULL;\n\t\tbreak;\n\n\tcase ARGP_KEY_ARG:\n\t\tif (args->dev_path)\n\t\t\targp_error(state,\n\t\t\t\t\"Wrong number of arguments; only one is allowed\");\n\t\targs->dev_path = arg;\n\t\tbreak;\n\n\tcase ARGP_KEY_END:\n\t\tif (!args->dev_path)\n\t\t\targp_error(state,\n\t\t\t\t\"The disk path was not specified\");\n\t\tif (args->start_at > args->end_at)\n\t\t\targp_error(state,\n\t\t\t\t\"Option --start-at must be less or equal to option --end-at\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn ARGP_ERR_UNKNOWN;\n\t}\n\treturn 0;\n}\n\nstatic struct argp argp = {options, parse_opt, adoc, doc, NULL, NULL, NULL};\n\nstatic uint64_t fill_buffer(void *buf, size_t size, uint64_t offset)\n{\n\tconst int num_int64 = SECTOR_SIZE >> 3;\n\tuint8_t *p, *ptr_end;\n\n\tassert(size > 0);\n\tassert(size % SECTOR_SIZE == 0);\n\n\tp = buf;\n\tptr_end = p + size;\n\twhile (p < ptr_end) {\n\t\tuint64_t *sector = (uint64_t *)p;\n\t\tint i;\n\t\tsector[0] = offset;\n\t\tfor (i = 1; i < num_int64; i++)\n\t\t\tsector[i] = random_number(sector[i - 1]);\n\t\tp += SECTOR_SIZE;\n\t\toffset += SECTOR_SIZE;\n\t}\n\n\treturn offset;\n}\n\n/* XXX Avoid duplicate this function, which was copied from libdevs.c. */\nstatic int write_all(int fd, const char *buf, size_t count)\n{\n\tsize_t done = 0;\n\tdo {\n\t\tssize_t rc = write(fd, buf + done, count - done);\n\t\tif (rc < 0) {\n\t\t\t/* The write() failed. */\n\t\t\treturn errno;\n\t\t}\n\t\tdone += rc;\n\t} while (done < count);\n\treturn 0;\n}\n\nstatic int write_chunk(struct dynamic_buffer *dbuf, int fd, size_t chunk_size,\n\tuint64_t *poffset)\n{\n\tchar *buf = dbuf_get_buf(dbuf, chunk_size);\n\tsize_t len = dbuf_get_len(dbuf);\n\n\twhile (chunk_size > 0) {\n\t\tsize_t turn_size = chunk_size <= len ? chunk_size : len;\n\t\tint ret;\n\t\tchunk_size -= turn_size;\n\t\t*poffset = fill_buffer(buf, turn_size, *poffset);\n\t\tret = write_all(fd, buf, turn_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/* Return true when disk is full. */\nstatic int create_and_fill_file(const char *path, long number, size_t size,\n\tint *phas_suggested_max_write_rate, struct flow *fw)\n{\n\tchar *full_fn;\n\tconst char *filename;\n\tint fd, saved_errno;\n\tsize_t remaining;\n\tuint64_t offset;\n\tstruct dynamic_buffer dbuf;\n\n\tassert(size > 0);\n\tassert(size % fw->block_size == 0);\n\n\t/* Create the file. */\n\tfull_fn = full_fn_from_number(&filename, path, number);\n\tassert(full_fn);\n\tprintf(\"Creating file %s ... \", filename);\n\tfflush(stdout);\n\tfd = open(full_fn, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tif (errno == ENOSPC) {\n\t\t\tprintf(\"No space left.\\n\");\n\t\t\tfree(full_fn);\n\t\t\treturn true;\n\t\t}\n\t\terr(errno, \"Can't create file %s\", full_fn);\n\t}\n\tassert(fd >= 0);\n\n\t/* Write content. */\n\tdbuf_init(&dbuf);\n\tsaved_errno = 0;\n\toffset = (uint64_t)number * GIGABYTES;\n\tremaining = size;\n\tstart_measurement(fw);\n\twhile (remaining > 0) {\n\t\tuint64_t write_size = get_rem_chunk_size(fw);\n\t\tif (write_size > remaining)\n\t\t\twrite_size = remaining;\n\t\tsaved_errno = write_chunk(&dbuf, fd, write_size, &offset);\n\t\tif (saved_errno)\n\t\t\tbreak;\n\t\tremaining -= write_size;\n\t\tif (measure(fd, fw, write_size) < 0) {\n\t\t\tsaved_errno = errno;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (end_measurement(fd, fw) < 0) {\n\t\t/* If a write failure has happened before, preserve it. */\n\t\tif (!saved_errno)\n\t\t\tsaved_errno = errno;\n\t}\n\tdbuf_free(&dbuf);\n\tclose(fd);\n\tfree(full_fn);\n\n\tif (saved_errno == 0 || saved_errno == ENOSPC) {\n\t\tif (saved_errno == 0)\n\t\t\tassert(remaining == 0);\n\t\tprintf(\"OK!\\n\");\n\t\treturn saved_errno == ENOSPC;\n\t}\n\n\t/* Something went wrong. */\n\tassert(saved_errno);\n\tprintf(\"Write failure: %s\\n\", strerror(saved_errno));\n\tif (saved_errno == EIO && !*phas_suggested_max_write_rate) {\n\t\t*phas_suggested_max_write_rate = true;\n\t\tprintf(\"\\nWARNING:\\nThe write error above may be due to your memory card overheating\\nunder constant, maximum write rate. You can test this hypothesis\\ntouching your memory card. If it is hot, you can try f3write\\nagain, once your card has cooled down, using parameter --max-write-rate=2048\\nto limit the maximum write rate to 2MB/s, or another suitable rate.\\n\\n\");\n\t}\n\treturn false;\n}\n\nstatic inline uint64_t get_freespace(const char *path)\n{\n\tstruct statvfs fs;\n\tassert(!statvfs(path, &fs));\n\treturn (uint64_t)fs.f_frsize * (uint64_t)fs.f_bfree;\n}\n\nstatic inline void pr_freespace(uint64_t fs)\n{\n\tdouble f = (double)fs;\n\tconst char *unit = adjust_unit(&f);\n\tprintf(\"Free space: %.2f %s\\n\", f, unit);\n}\n\nstatic inline void pr_avg_speed(double speed)\n{\n\tconst char *unit = adjust_unit(&speed);\n\tprintf(\"Average writing speed: %.2f %s/s\\n\", speed, unit);\n}\n\nstatic int flush_chunk(const struct flow *fw, int fd)\n{\n\tUNUSED(fw);\n\n\tif (fdatasync(fd) < 0)\n\t\treturn -1; /* Caller can read errno(3). */\n\n\t/* Help the kernel to help us. */\n\tassert(!posix_fadvise(fd, 0, 0, POSIX_FADV_DONTNEED));\n\treturn 0;\n}\n\nstatic int fill_fs(const char *path, long start_at, long end_at,\n\tlong max_write_rate, int progress)\n{\n\tuint64_t free_space;\n\tstruct flow fw;\n\tlong i;\n\tint has_suggested_max_write_rate = max_write_rate > 0;\n\tstruct timeval t1, t2;\n\n\tfree_space = get_freespace(path);\n\tpr_freespace(free_space);\n\tif (free_space <= 0) {\n\t\tprintf(\"No space!\\n\");\n\t\treturn 1;\n\t}\n\n\ti = end_at - start_at + 1;\n\tif (i > 0 && (uint64_t)i <= (free_space >> 30)) {\n\t\t/* The amount of data to write is less than the space available,\n\t\t * update @free_space to improve estimate of time to finish.\n\t\t */\n\t\tfree_space = (uint64_t)i << 30;\n\t} else {\n\t\t/* There are more data to write than space available.\n\t\t * Reduce @end_at to reduce the number of error messages\n\t\t * when multiple write failures happens.\n\t\t *\n\t\t * One should not subtract the value below of one because\n\t\t * the expression (free_space >> 30) is an integer division,\n\t\t * that is, it ignores the remainder.\n\t\t */\n\t\tend_at = start_at + (free_space >> 30);\n\t}\n\n\tinit_flow(&fw, free_space, max_write_rate, progress, flush_chunk);\n\tassert(!gettimeofday(&t1, NULL));\n\tfor (i = start_at; i <= end_at; i++)\n\t\tif (create_and_fill_file(path, i, GIGABYTES,\n\t\t\t&has_suggested_max_write_rate, &fw))\n\t\t\tbreak;\n\tassert(!gettimeofday(&t2, NULL));\n\n\t/* Final report. */\n\tpr_freespace(get_freespace(path));\n\t/* Writing speed. */\n\tif (has_enough_measurements(&fw)) {\n\t\tpr_avg_speed(get_avg_speed(&fw));\n\t} else {\n\t\t/* If the drive is too fast for the measurements above,\n\t\t * try a coarse approximation of the writing speed.\n\t\t */\n\t\tint64_t total_time_ms = delay_ms(&t1, &t2);\n\t\tif (total_time_ms > 0) {\n\t\t\tpr_avg_speed(get_avg_speed_given_time(&fw,\n\t\t\t\ttotal_time_ms));\n\t\t} else {\n\t\t\tprintf(\"Writing speed not available\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void unlink_old_files(const char *path, long start_at, long end_at)\n{\n\tconst long *files = ls_my_files(path, start_at, end_at);\n\tconst long *number = files;\n\twhile (*number >= 0) {\n\t\tchar *full_fn;\n\t\tconst char *filename;\n\t\tfull_fn = full_fn_from_number(&filename, path, *number);\n\t\tassert(full_fn);\n\t\tprintf(\"Removing old file %s ...\\n\", filename);\n\t\tif (unlink(full_fn))\n\t\t\terr(errno, \"Can't remove file %s\", full_fn);\n\t\tnumber++;\n\t\tfree(full_fn);\n\t}\n\tfree((void *)files);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct args args = {\n\t\t/* Defaults. */\n\t\t.start_at\t= 0,\n\t\t.end_at\t\t= LONG_MAX - 1,\n\t\t.max_write_rate = 0,\n\t\t/* If stdout isn't a terminal, suppress progress. */\n\t\t.show_progress\t= isatty(STDOUT_FILENO),\n\t};\n\n\t/* Read parameters. */\n\targp_parse(&argp, argc, argv, 0, NULL, &args);\n\tprint_header(stdout, \"write\");\n\n\tadjust_dev_path(&args.dev_path);\n\n\tunlink_old_files(args.dev_path, args.start_at, args.end_at);\n\n\treturn fill_fs(args.dev_path, args.start_at, args.end_at,\n\t\targs.max_write_rate, args.show_progress);\n}\n"
        },
        {
          "name": "f3write.h2w",
          "type": "blob",
          "size": 0.1083984375,
          "content": "#!/usr/bin/env bash\n\n$(dirname $0)/f3write \"$@\" || exit 1\n\nFILES=(\"${@: -1}/*.h2w\")\ntruncate --size=/1M $FILES\n"
        },
        {
          "name": "libdevs.c",
          "type": "blob",
          "size": 32.22265625,
          "content": "#define _GNU_SOURCE\n#define _POSIX_C_SOURCE 200809L\n#define _FILE_OFFSET_BITS 64\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n#include <string.h>\n#include <inttypes.h>\n#include <errno.h>\n#include <err.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <linux/usbdevice_fs.h>\n#include <libudev.h>\n\n#include \"libutils.h\"\n#include \"libdevs.h\"\n\nstatic const char * const ftype_to_name[FKTY_MAX] = {\n\t[FKTY_GOOD]\t\t= \"good\",\n\t[FKTY_BAD]\t\t= \"bad\",\n\t[FKTY_LIMBO]\t\t= \"limbo\",\n\t[FKTY_WRAPAROUND]\t= \"wraparound\",\n\t[FKTY_CHAIN]\t\t= \"chain\",\n};\n\nconst char *fake_type_to_name(enum fake_type fake_type)\n{\n\tassert(fake_type < FKTY_MAX);\n\treturn ftype_to_name[fake_type];\n}\n\nint dev_param_valid(uint64_t real_size_byte,\n\tuint64_t announced_size_byte, int wrap, int block_order)\n{\n\tint block_size;\n\n\t/* Check general ranges. */\n\tif (real_size_byte > announced_size_byte || wrap < 0 || wrap >= 64 ||\n\t\tblock_order < 9 || block_order > 20)\n\t\treturn false;\n\n\t/* Check alignment of the sizes. */\n\tblock_size = 1 << block_order;\n\tif (real_size_byte % block_size || announced_size_byte % block_size)\n\t\treturn false;\n\n\t/* If good, @wrap must make sense. */\n\tif (real_size_byte == announced_size_byte) {\n\t\tuint64_t two_wrap = ((uint64_t)1) << wrap;\n\t\treturn announced_size_byte <= two_wrap;\n\t}\n\n\treturn true;\n}\n\nenum fake_type dev_param_to_type(uint64_t real_size_byte,\n\tuint64_t announced_size_byte, int wrap, int block_order)\n{\n\tuint64_t two_wrap;\n\n\tassert(dev_param_valid(real_size_byte, announced_size_byte,\n\t\twrap, block_order));\n\n\tif (real_size_byte == announced_size_byte)\n\t\treturn FKTY_GOOD;\n\n\tif (real_size_byte == 0)\n\t\treturn FKTY_BAD;\n\n\t/* real_size_byte < announced_size_byte */\n\n\ttwo_wrap = ((uint64_t)1) << wrap;\n\tif (two_wrap <= real_size_byte)\n\t\treturn FKTY_WRAPAROUND;\n\tif (two_wrap < announced_size_byte)\n\t\treturn FKTY_CHAIN;\n\treturn FKTY_LIMBO;\n}\n\nstruct device {\n\tuint64_t\tsize_byte;\n\tint\t\tblock_order;\n\n\tint (*read_blocks)(struct device *dev, char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos);\n\tint (*write_blocks)(struct device *dev, const char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos);\n\tint (*reset)(struct device *dev);\n\tvoid (*free)(struct device *dev);\n\tconst char *(*get_filename)(struct device *dev);\n};\n\nuint64_t dev_get_size_byte(struct device *dev)\n{\n\treturn dev->size_byte;\n}\n\nint dev_get_block_order(struct device *dev)\n{\n\treturn dev->block_order;\n}\n\nint dev_get_block_size(struct device *dev)\n{\n\treturn 1 << dev->block_order;\n}\n\nconst char *dev_get_filename(struct device *dev)\n{\n\treturn dev->get_filename(dev);\n}\n\nint dev_read_blocks(struct device *dev, char *buf,\n\tuint64_t first_pos, uint64_t last_pos)\n{\n\tif (first_pos > last_pos)\n\t\treturn false;\n\tassert(last_pos < (dev->size_byte >> dev->block_order));\n\treturn dev->read_blocks(dev, buf, first_pos, last_pos);\n}\n\nint dev_write_blocks(struct device *dev, const char *buf,\n\tuint64_t first_pos, uint64_t last_pos)\n{\n\tif (first_pos > last_pos)\n\t\treturn false;\n\tassert(last_pos < (dev->size_byte >> dev->block_order));\n\treturn dev->write_blocks(dev, buf, first_pos, last_pos);\n}\n\nint dev_reset(struct device *dev)\n{\n\treturn dev->reset ? dev->reset(dev) : 0;\n}\n\nvoid free_device(struct device *dev)\n{\n\tif (dev->free)\n\t\tdev->free(dev);\n\tfree(dev);\n}\n\nstruct file_device {\n\t/* This must be the first field. See dev_fdev() for details. */\n\tstruct device dev;\n\n\tconst char\t*filename;\n\tint\t\tfd;\n\tuint64_t\treal_size_byte;\n\tuint64_t\taddress_mask;\n\tuint64_t\tcache_mask;\n\tuint64_t\t*cache_entries;\n\tchar\t\t*cache_blocks;\n};\n\nstatic inline struct file_device *dev_fdev(struct device *dev)\n{\n\treturn (struct file_device *)dev;\n}\n\nstatic int fdev_read_block(struct device *dev, char *buf, uint64_t block_pos)\n{\n\tstruct file_device *fdev = dev_fdev(dev);\n\tconst int block_size = dev_get_block_size(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\toff_t off_ret, offset = block_pos << block_order;\n\tint done;\n\n\toffset &= fdev->address_mask;\n\tif ((uint64_t)offset >= fdev->real_size_byte) {\n\t\tuint64_t cache_pos;\n\n\t\tif (!fdev->cache_blocks)\n\t\t\tgoto no_block; /* No cache available. */\n\n\t\tcache_pos = block_pos & fdev->cache_mask;\n\n\t\tif (fdev->cache_entries &&\n\t\t\tfdev->cache_entries[cache_pos] != block_pos)\n\t\t\tgoto no_block;\n\n\t\tmemmove(buf, &fdev->cache_blocks[cache_pos << block_order],\n\t\t\tblock_size);\n\t\treturn 0;\n\t}\n\n\toff_ret = lseek(fdev->fd, offset, SEEK_SET);\n\tif (off_ret < 0)\n\t\treturn - errno;\n\tassert(off_ret == offset);\n\n\tdone = 0;\n\tdo {\n\t\tssize_t rc = read(fdev->fd, buf + done, block_size - done);\n\t\tassert(rc >= 0);\n\t\tif (!rc) {\n\t\t\t/* Tried to read beyond the end of the file. */\n\t\t\tassert(!done);\n\t\t\tmemset(buf, 0, block_size);\n\t\t\tdone += block_size;\n\t\t}\n\t\tdone += rc;\n\t} while (done < block_size);\n\n\treturn 0;\n\nno_block:\n\tmemset(buf, 0, block_size);\n\treturn 0;\n}\n\nstatic int fdev_read_blocks(struct device *dev, char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tconst int block_size = dev_get_block_size(dev);\n\tuint64_t pos;\n\n\tfor (pos = first_pos; pos <= last_pos; pos++) {\n\t\tint rc = fdev_read_block(dev, buf, pos);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tbuf += block_size;\n\t}\n\treturn 0;\n}\n\nstatic int write_all(int fd, const char *buf, size_t count)\n{\n\tsize_t done = 0;\n\tdo {\n\t\tssize_t rc = write(fd, buf + done, count - done);\n\t\tif (rc < 0) {\n\t\t\t/* The write() failed. */\n\t\t\treturn errno;\n\t\t}\n\t\tdone += rc;\n\t} while (done < count);\n\treturn 0;\n}\n\nstatic int fdev_write_block(struct device *dev, const char *buf,\n\tuint64_t block_pos)\n{\n\tstruct file_device *fdev = dev_fdev(dev);\n\tconst int block_size = dev_get_block_size(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\toff_t off_ret, offset = block_pos << block_order;\n\n\toffset &= fdev->address_mask;\n\tif ((uint64_t)offset >= fdev->real_size_byte) {\n\t\t/* Block beyond real memory. */\n\t\tuint64_t cache_pos;\n\n\t\tif (!fdev->cache_blocks)\n\t\t\treturn 0; /* No cache available. */\n\t\tcache_pos = block_pos & fdev->cache_mask;\n\t\tmemmove(&fdev->cache_blocks[cache_pos << block_order],\n\t\t\tbuf, block_size);\n\n\t\tif (fdev->cache_entries)\n\t\t\tfdev->cache_entries[cache_pos] = block_pos;\n\n\t\treturn 0;\n\t}\n\n\toff_ret = lseek(fdev->fd, offset, SEEK_SET);\n\tif (off_ret < 0)\n\t\treturn - errno;\n\tassert(off_ret == offset);\n\n\treturn write_all(fdev->fd, buf, block_size);\n}\n\nstatic int fdev_write_blocks(struct device *dev, const char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tconst int block_size = dev_get_block_size(dev);\n\tuint64_t pos;\n\n\tfor (pos = first_pos; pos <= last_pos; pos++) {\n\t\tint rc = fdev_write_block(dev, buf, pos);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tbuf += block_size;\n\t}\n\treturn 0;\n}\n\nstatic void fdev_free(struct device *dev)\n{\n\tstruct file_device *fdev = dev_fdev(dev);\n\tfree(fdev->cache_blocks);\n\tfree(fdev->cache_entries);\n\tfree((void *)fdev->filename);\n\tassert(!close(fdev->fd));\n}\n\nstatic const char *fdev_get_filename(struct device *dev)\n{\n\treturn dev_fdev(dev)->filename;\n}\n\nstruct device *create_file_device(const char *filename,\n\tuint64_t real_size_byte, uint64_t fake_size_byte, int wrap,\n\tint block_order, int cache_order, int strict_cache,\n\tint keep_file)\n{\n\tstruct file_device *fdev;\n\n\tfdev = malloc(sizeof(*fdev));\n\tif (!fdev)\n\t\tgoto error;\n\n\tfdev->filename = strdup(filename);\n\tif (!fdev->filename)\n\t\tgoto fdev;\n\n\tfdev->cache_mask = 0;\n\tfdev->cache_entries = NULL;\n\tfdev->cache_blocks = NULL;\n\tif (cache_order >= 0) {\n\t\tfdev->cache_mask = (((uint64_t)1) << cache_order) - 1;\n\t\tif (strict_cache) {\n\t\t\tsize_t size = sizeof(*fdev->cache_entries) <<\n\t\t\t\tcache_order;\n\t\t\tfdev->cache_entries = malloc(size);\n\t\t\tif (!fdev->cache_entries)\n\t\t\t\tgoto cache;\n\t\t\tmemset(fdev->cache_entries, 0, size);\n\t\t}\n\t\tfdev->cache_blocks = malloc(((uint64_t)1) <<\n\t\t\t(cache_order + block_order));\n\t\tif (!fdev->cache_blocks)\n\t\t\tgoto cache;\n\t}\n\n\tfdev->fd = open(filename, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n\tif (fdev->fd < 0) {\n\t\terr(errno, \"Can't create file `%s'\", filename);\n\t\tgoto cache;\n\t}\n\tif (!keep_file) {\n\t\t/* Unlinking the file now guarantees that it won't exist if\n\t\t * there is a crash.\n\t\t */\n\t\tassert(!unlink(filename));\n\t}\n\n\tif (!block_order) {\n\t\tstruct stat fd_stat;\n\t\tblksize_t block_size;\n\t\tassert(!fstat(fdev->fd, &fd_stat));\n\t\tblock_size = fd_stat.st_blksize;\n\t\tblock_order = ilog2(block_size);\n\t\tassert(block_size == (1 << block_order));\n\t}\n\n\tif (!dev_param_valid(real_size_byte, fake_size_byte, wrap, block_order))\n\t\tgoto keep_file;\n\n\tfdev->real_size_byte = real_size_byte;\n\tfdev->address_mask = (((uint64_t)1) << wrap) - 1;\n\n\tfdev->dev.size_byte = fake_size_byte;\n\tfdev->dev.block_order = block_order;\n\tfdev->dev.read_blocks = fdev_read_blocks;\n\tfdev->dev.write_blocks = fdev_write_blocks;\n\tfdev->dev.reset = NULL;\n\tfdev->dev.free = fdev_free;\n\tfdev->dev.get_filename = fdev_get_filename;\n\n\treturn &fdev->dev;\n\nkeep_file:\n\tif (keep_file)\n\t\tunlink(filename);\n\tassert(!close(fdev->fd));\ncache:\n\tfree(fdev->cache_blocks);\n\tfree(fdev->cache_entries);\n/* filename:\tthis label is not being used. */\n\tfree((void *)fdev->filename);\nfdev:\n\tfree(fdev);\nerror:\n\treturn NULL;\n}\n\nstruct block_device {\n\t/* This must be the first field. See dev_bdev() for details. */\n\tstruct device dev;\n\n\tconst char *filename;\n\tint fd;\n};\n\nstatic inline struct block_device *dev_bdev(struct device *dev)\n{\n\treturn (struct block_device *)dev;\n}\n\nstatic int read_all(int fd, char *buf, size_t count)\n{\n\tsize_t done = 0;\n\tdo {\n\t\tssize_t rc = read(fd, buf + done, count - done);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tif (errno == EIO || errno == ENODATA) {\n\t\t\t\t/* These errors are \"expected\",\n\t\t\t\t * so ignore them.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\t/* Execution should not come here. */\n\t\t\t\terr(errno,\n\t\t\t\t\t\"%s(): unexpected error code from read(2) = %i\",\n\t\t\t\t\t__func__, errno);\n\t\t\t}\n\t\t\treturn - errno;\n\t\t}\n\t\tassert(rc != 0); /* We should never hit the end of the file. */\n\t\tdone += rc;\n\t} while (done < count);\n\treturn 0;\n}\n\nstatic int bdev_read_blocks(struct device *dev, char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tstruct block_device *bdev = dev_bdev(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\tsize_t length = (last_pos - first_pos + 1) << block_order;\n\toff_t offset = first_pos << block_order;\n\toff_t off_ret = lseek(bdev->fd, offset, SEEK_SET);\n\tif (off_ret < 0)\n\t\treturn - errno;\n\tassert(off_ret == offset);\n\treturn read_all(bdev->fd, buf, length);\n}\n\nstatic int bdev_write_blocks(struct device *dev, const char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tstruct block_device *bdev = dev_bdev(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\tsize_t length = (last_pos - first_pos + 1) << block_order;\n\toff_t offset = first_pos << block_order;\n\toff_t off_ret = lseek(bdev->fd, offset, SEEK_SET);\n\tint rc;\n\tif (off_ret < 0)\n\t\treturn - errno;\n\tassert(off_ret == offset);\n\trc = write_all(bdev->fd, buf, length);\n\tif (rc)\n\t\treturn rc;\n\trc = fsync(bdev->fd);\n\tif (rc)\n\t\treturn rc;\n\treturn posix_fadvise(bdev->fd, 0, 0, POSIX_FADV_DONTNEED);\n}\n\nstatic inline int bdev_open(const char *filename)\n{\n\treturn open(filename, O_RDWR | O_DIRECT);\n}\n\nstatic struct udev_device *map_dev_to_usb_dev(struct udev_device *dev)\n{\n\tstruct udev_device *usb_dev;\n\n\t/* The device pointed to by dev contains information about\n\t * the USB device.\n\t * In order to get information about the USB device,\n\t * get the parent device with the subsystem/devtype pair of\n\t * \"usb\"/\"usb_device\".\n\t * This will be several levels up the tree,\n\t * but the function will find it.\n\t */\n\tusb_dev = udev_device_get_parent_with_subsystem_devtype(\n\t\tdev, \"usb\", \"usb_device\");\n\n\t/* @usb_dev is not referenced, and will be freed when\n\t * the child (i.e. @dev) is freed.\n\t * See udev_device_get_parent_with_subsystem_devtype() for\n\t * details.\n\t */\n\treturn udev_device_ref(usb_dev);\n}\n\nstatic struct udev_device *dev_from_block_fd(struct udev *udev, int block_fd)\n{\n\tstruct stat fd_stat;\n\n\tif (fstat(block_fd, &fd_stat)) {\n\t\twarn(\"Can't fstat() FD %i\", block_fd);\n\t\treturn NULL;\n\t}\n\n\tif (!S_ISBLK(fd_stat.st_mode)) {\n\t\twarnx(\"FD %i is not a block device\", block_fd);\n\t\treturn NULL;\n\t}\n\n\treturn udev_device_new_from_devnum(udev, 'b', fd_stat.st_rdev);\n}\n\nstatic struct udev_monitor *create_monitor(struct udev *udev,\n\tconst char *subsystem, const char *devtype)\n{\n\tstruct udev_monitor *mon;\n\tint mon_fd, flags;\n\n\tmon = udev_monitor_new_from_netlink(udev, \"udev\");\n\tassert(mon);\n\tassert(!udev_monitor_filter_add_match_subsystem_devtype(mon,\n\t\tsubsystem, devtype));\n\tassert(!udev_monitor_enable_receiving(mon));\n\tmon_fd = udev_monitor_get_fd(mon);\n\tassert(mon_fd >= 0);\n\tflags = fcntl(mon_fd, F_GETFL);\n\tassert(flags >= 0);\n\tassert(!fcntl(mon_fd, F_SETFL, flags & ~O_NONBLOCK));\n\n\treturn mon;\n}\n\nstatic uint64_t get_udev_dev_size_byte(struct udev_device *dev)\n{\n\tconst char *str_size_sector =\n\t\tudev_device_get_sysattr_value(dev, \"size\");\n\tchar *end;\n\tlong long size_sector;\n\tif (!str_size_sector)\n\t\treturn 0;\n\tsize_sector = strtoll(str_size_sector, &end, 10);\n\tassert(!*end);\n\treturn size_sector * 512LL;\n}\n\nstatic int wait_for_reset(struct udev *udev, const char *id_serial,\n\tuint64_t original_size_byte, const char **pfinal_dev_filename)\n{\n\tbool done = false, went_to_zero = false, already_changed_size = false;\n\tstruct udev_monitor *mon;\n\tint rc;\n\n\tmon = create_monitor(udev, \"block\", \"disk\");\n\tif (!mon) {\n\t\twarnx(\"%s(): Can't instantiate a monitor\", __func__);\n\t\trc = - ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct udev_device *dev;\n\t\tconst char *dev_id_serial, *action;\n\t\tuint64_t new_size_byte;\n\t\tconst char *devnode;\n\n\t\tdev = udev_monitor_receive_device(mon);\n\t\tif (!dev) {\n\t\t\twarnx(\"%s(): Can't monitor device\", __func__);\n\t\t\trc = - ENOMEM;\n\t\t\tgoto mon;\n\t\t}\n\t\tdev_id_serial = udev_device_get_property_value(dev,\n\t\t\t\"ID_SERIAL\");\n\t\tif (!dev_id_serial || strcmp(dev_id_serial, id_serial))\n\t\t\tgoto next;\n\n\t\taction = udev_device_get_action(dev);\n\t\tnew_size_byte = get_udev_dev_size_byte(dev);\n\t\tif (!strcmp(action, \"add\")) {\n\t\t\t/* Deal with the case in which the user pulls\n\t\t\t * the USB device.\n\t\t\t *\n\t\t\t * DO NOTHING.\n\t\t\t */\n\t\t} else if (!strcmp(action, \"change\")) {\n\t\t\t/* Deal with the case in which the user pulls\n\t\t\t * the memory card from the card reader.\n\t\t\t */\n\n\t\t\tif (!new_size_byte) {\n\t\t\t\t/* Memory card removed. */\n\t\t\t\twent_to_zero = true;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (!went_to_zero)\n\t\t\t\tgoto next;\n\t\t} else {\n\t\t\t/* Ignore all other actions. */\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (new_size_byte != original_size_byte) {\n\t\t\t/* This is an edge case. */\n\n\t\t\tif (!already_changed_size) {\n\t\t\t\talready_changed_size = true;\n\t\t\t\twent_to_zero = false;\n\t\t\t\tprintf(\"\\nThe drive changed its size of %\"\n\t\t\t\t\tPRIu64 \" Bytes to %\" PRIu64\n\t\t\t\t\t\" Bytes after the reset.\\nPlease try to unplug and plug it back again...\",\n\t\t\t\t\toriginal_size_byte, new_size_byte);\n\t\t\t\tfflush(stdout);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tprintf(\"\\nThe reset failed. The drive has not returned to its original size.\\n\\n\");\n\t\t\tfflush(stdout);\n\t\t\trc = - ENXIO;\n\t\t\tgoto mon;\n\t\t}\n\n\t\tdevnode = strdup(udev_device_get_devnode(dev));\n\t\tif (!devnode) {\n\t\t\twarnx(\"%s(): Out of memory\", __func__);\n\t\t\trc = - ENOMEM;\n\t\t\tgoto mon;\n\t\t}\n\t\tfree((void *)*pfinal_dev_filename);\n\t\t*pfinal_dev_filename = devnode;\n\t\tdone = true;\n\nnext:\n\t\tudev_device_unref(dev);\n\t} while (!done);\n\n\trc = 0;\n\nmon:\n\tassert(!udev_monitor_unref(mon));\nout:\n\treturn rc;\n}\n\nstatic int bdev_manual_usb_reset(struct device *dev)\n{\n\tstruct block_device *bdev = dev_bdev(dev);\n\tstruct udev *udev;\n\tstruct udev_device *udev_dev, *usb_dev;\n\tconst char *id_serial;\n\tint rc;\n\n\tif (bdev->fd < 0) {\n\t\t/* We don't have a device open.\n\t\t * This can happen when the previous reset failed, and\n\t\t * a reset is being called again.\n\t\t */\n\t\trc = - EBADF;\n\t\tgoto out;\n\t}\n\n\tudev = udev_new();\n\tif (!udev) {\n\t\twarnx(\"Can't load library udev\");\n\t\trc = - EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* Identify which drive we are going to reset. */\n\tudev_dev = dev_from_block_fd(udev, bdev->fd);\n\tif (!udev_dev) {\n\t\twarnx(\"Library udev can't find device `%s'\",\n\t\t\tdev_get_filename(dev));\n\t\trc = - EINVAL;\n\t\tgoto udev;\n\t}\n\tusb_dev = map_dev_to_usb_dev(udev_dev);\n\tif (!usb_dev) {\n\t\twarnx(\"Block device `%s' is not backed by a USB device\",\n\t\t\tdev_get_filename(dev));\n\t\trc = - EINVAL;\n\t\tgoto udev_dev;\n\t}\n\tid_serial = udev_device_get_property_value(udev_dev, \"ID_SERIAL\");\n\tif (!id_serial) {\n\t\twarnx(\"%s(): Out of memory\", __func__);\n\t\trc = - ENOMEM;\n\t\tgoto usb_dev;\n\t}\n\n\t/* Close @bdev->fd before the drive is removed to increase\n\t * the chance that the device will receive the same filename.\n\t * The code is robust enough to deal with the case the drive doesn't\n\t * receive the same file name, though.\n\t */\n\tassert(!close(bdev->fd));\n\tbdev->fd = -1;\n\n\tprintf(\"Please unplug and plug back the USB drive. Waiting...\");\n\tfflush(stdout);\n\trc = wait_for_reset(udev, id_serial, dev_get_size_byte(dev),\n\t\t&bdev->filename);\n\tif (rc) {\n\t\tassert(rc < 0);\n\t\tgoto usb_dev;\n\t}\n\tprintf(\" Thanks\\n\\n\");\n\n\tbdev->fd = bdev_open(bdev->filename);\n\tif (bdev->fd < 0) {\n\t\trc = - errno;\n\t\twarn(\"Can't reopen device `%s'\", bdev->filename);\n\t\tgoto usb_dev;\n\t}\n\n\trc = 0;\n\nusb_dev:\n\tudev_device_unref(usb_dev);\nudev_dev:\n\tudev_device_unref(udev_dev);\nudev:\n\tassert(!udev_unref(udev));\nout:\n\treturn rc;\n}\n\nstatic struct udev_device *map_block_to_usb_dev(struct udev *udev, int block_fd)\n{\n\tstruct udev_device *dev, *usb_dev;\n\n\tdev = dev_from_block_fd(udev, block_fd);\n\tif (!dev)\n\t\treturn NULL;\n\tusb_dev = map_dev_to_usb_dev(dev);\n\tudev_device_unref(dev);\n\treturn usb_dev;\n}\n\n/* Return an open fd to the underlying hardware of the block device. */\nstatic int usb_fd_from_block_dev(int block_fd, int open_flags)\n{\n\tstruct udev *udev;\n\tstruct udev_device *usb_dev;\n\tconst char *usb_filename;\n\tint usb_fd;\n\n\tudev = udev_new();\n\tif (!udev) {\n\t\twarnx(\"Can't load library udev\");\n\t\tusb_fd = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tusb_dev = map_block_to_usb_dev(udev, block_fd);\n\tif (!usb_dev) {\n\t\twarnx(\"Block device is not backed by a USB device\");\n\t\tusb_fd = -EINVAL;\n\t\tgoto udev;\n\t}\n\n\tusb_filename = udev_device_get_devnode(usb_dev);\n\tif (!usb_filename) {\n\t\twarnx(\"%s(): Out of memory\", __func__);\n\t\tusb_fd = -ENOMEM;\n\t\tgoto usb_dev;\n\t}\n\n\tusb_fd = open(usb_filename, open_flags | O_NONBLOCK);\n\tif (usb_fd < 0) {\n\t\tusb_fd = - errno;\n\t\twarn(\"Can't open device `%s'\", usb_filename);\n\t\tgoto usb_dev;\n\t}\n\nusb_dev:\n\tudev_device_unref(usb_dev);\nudev:\n\tassert(!udev_unref(udev));\nout:\n\treturn usb_fd;\n}\n\nstatic int bdev_usb_reset(struct device *dev)\n{\n\tstruct block_device *bdev = dev_bdev(dev);\n\tint usb_fd;\n\n\tif (bdev->fd < 0) {\n\t\t/* We don't have a device open.\n\t\t * This can happen when the previous reset failed, and\n\t\t * a reset is being called again.\n\t\t */\n\t\treturn - EBADF;\n\t}\n\n\tusb_fd = usb_fd_from_block_dev(bdev->fd, O_WRONLY);\n\tif (usb_fd < 0)\n\t\treturn usb_fd;\n\n\tassert(!close(bdev->fd));\n\tbdev->fd = -1;\n\tassert(!ioctl(usb_fd, USBDEVFS_RESET));\n\tassert(!close(usb_fd));\n\tbdev->fd = bdev_open(bdev->filename);\n\tif (bdev->fd < 0) {\n\t\tint rc = - errno;\n\t\twarn(\"Can't reopen device `%s'\", bdev->filename);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int bdev_none_reset(struct device *dev)\n{\n\tUNUSED(dev);\n\treturn 0;\n}\n\nstatic void bdev_free(struct device *dev)\n{\n\tstruct block_device *bdev = dev_bdev(dev);\n\tif (bdev->fd >= 0)\n\t\tassert(!close(bdev->fd));\n\tfree((void *)bdev->filename);\n}\n\nstatic const char *bdev_get_filename(struct device *dev)\n{\n\treturn dev_bdev(dev)->filename;\n}\n\nstatic struct udev_device *map_partition_to_disk(struct udev_device *dev)\n{\n\tstruct udev_device *disk_dev;\n\n\tdisk_dev = udev_device_get_parent_with_subsystem_devtype(\n\t\tdev, \"block\", \"disk\");\n\n\t/* @disk_dev is not referenced, and will be freed when\n\t * the child (i.e. @dev) is freed.\n\t * See udev_device_get_parent_with_subsystem_devtype() for\n\t * details.\n\t */\n\treturn udev_device_ref(disk_dev);\n}\n\n/* XXX This is borrowing from glibc.\n * A better solution would be to return proper errors,\n * so callers write their own messages.\n */\nextern const char *__progname;\n\nstruct device *create_block_device(const char *filename, enum reset_type rt)\n{\n\tstruct block_device *bdev;\n\tstruct udev *udev;\n\tstruct udev_device *fd_dev;\n\tconst char *s;\n\tint block_size, block_order;\n\n\tbdev = malloc(sizeof(*bdev));\n\tif (!bdev)\n\t\tgoto error;\n\n\tbdev->filename = strdup(filename);\n\tif (!bdev->filename)\n\t\tgoto bdev;\n\n\tbdev->fd = bdev_open(filename);\n\tif (bdev->fd < 0) {\n\t\tif (errno == EACCES && getuid()) {\n\t\t\tfprintf(stderr, \"Your user doesn't have access to device `%s'.\\n\"\n\t\t\t\t\"Try to run this program as root:\\n\"\n\t\t\t\t\"sudo %s %s\\n\"\n\t\t\t\t\"In case you don't have access to root, use f3write/f3read.\\n\",\n\t\t\t\tfilename, __progname, filename);\n\t\t} else {\n\t\t\terr(errno, \"Can't open device `%s'\", filename);\n\t\t}\n\t\tgoto filename;\n\t}\n\n\t/* Make sure that @bdev->fd is a disk, not a partition. */\n\tudev = udev_new();\n\tif (!udev) {\n\t\twarnx(\"Can't load library udev\");\n\t\tgoto fd;\n\t}\n\tfd_dev = dev_from_block_fd(udev, bdev->fd);\n\tif (!fd_dev) {\n\t\tfprintf(stderr, \"Can't create udev device from `%s'\\n\",\n\t\t\tfilename);\n\t\tgoto udev;\n\t}\n\tassert(!strcmp(udev_device_get_subsystem(fd_dev), \"block\"));\n\ts = udev_device_get_devtype(fd_dev);\n\tif (!strcmp(s, \"partition\")) {\n\t\tstruct udev_device *disk_dev = map_partition_to_disk(fd_dev);\n\t\tassert(disk_dev);\n\t\ts = udev_device_get_devnode(disk_dev);\n\t\tfprintf(stderr, \"Device `%s' is a partition of disk device `%s'.\\n\"\n\t\t\t\"You must run %s on the disk device as follows:\\n\"\n\t\t\t\"%s %s\\n\",\n\t\t\tfilename, s, __progname, __progname, s);\n\t\tudev_device_unref(disk_dev);\n\t\tgoto fd_dev;\n\t} else if (strcmp(s, \"disk\")) {\n\t\tfprintf(stderr, \"Device `%s' is not a disk, but `%s'\",\n\t\t\tfilename, s);\n\t\tgoto fd_dev;\n\t}\n\n\tif (rt != RT_NONE) {\n\t\t/* Make sure that @bdev->fd is backed by a USB device. */\n\t\tstruct udev_device *usb_dev = map_dev_to_usb_dev(fd_dev);\n\t\tif (!usb_dev) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Device `%s' is not backed by a USB device.\\n\"\n\t\t\t\t\"You must disable reset, run %s as follows:\\n\"\n\t\t\t\t\"%s --reset-type=%i %s\\n\",\n\t\t\t\tfilename, __progname, __progname, RT_NONE,\n\t\t\t\tfilename);\n\t\t\tgoto fd_dev;\n\t\t}\n\t\tudev_device_unref(usb_dev);\n\t}\n\tudev_device_unref(fd_dev);\n\tassert(!udev_unref(udev));\n\n\tswitch (rt) {\n\tcase RT_MANUAL_USB:\n\t\tbdev->dev.reset\t= bdev_manual_usb_reset;\n\t\tbreak;\n\tcase RT_USB:\n\t\tbdev->dev.reset = bdev_usb_reset;\n\t\tbreak;\n\tcase RT_NONE:\n\t\tbdev->dev.reset = bdev_none_reset;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tassert(!ioctl(bdev->fd, BLKGETSIZE64, &bdev->dev.size_byte));\n\n\tassert(!ioctl(bdev->fd, BLKSSZGET, &block_size));\n\tblock_order = ilog2(block_size);\n\tassert(block_size == (1 << block_order));\n\tbdev->dev.block_order = block_order;\n\n\tbdev->dev.read_blocks = bdev_read_blocks;\n\tbdev->dev.write_blocks = bdev_write_blocks;\n\tbdev->dev.free = bdev_free;\n\tbdev->dev.get_filename = bdev_get_filename;\n\n\treturn &bdev->dev;\n\nfd_dev:\n\tudev_device_unref(fd_dev);\nudev:\n\tassert(!udev_unref(udev));\nfd:\n\tassert(!close(bdev->fd));\nfilename:\n\tfree((void *)bdev->filename);\nbdev:\n\tfree(bdev);\nerror:\n\treturn NULL;\n}\n\nstruct perf_device {\n\t/* This must be the first field. See dev_pdev() for details. */\n\tstruct device\t\tdev;\n\n\tstruct device\t\t*shadow_dev;\n\n\tuint64_t\t\tread_count;\n\tuint64_t\t\tread_time_us;\n\tuint64_t\t\twrite_count;\n\tuint64_t\t\twrite_time_us;\n\tuint64_t\t\treset_count;\n\tuint64_t\t\treset_time_us;\n};\n\nstatic inline struct perf_device *dev_pdev(struct device *dev)\n{\n\treturn (struct perf_device *)dev;\n}\n\nstatic int pdev_read_blocks(struct device *dev, char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tstruct perf_device *pdev = dev_pdev(dev);\n\tstruct timeval t1, t2;\n\tint rc;\n\n\tassert(!gettimeofday(&t1, NULL));\n\trc = pdev->shadow_dev->read_blocks(pdev->shadow_dev, buf,\n\t\tfirst_pos, last_pos);\n\tassert(!gettimeofday(&t2, NULL));\n\tpdev->read_count += last_pos - first_pos + 1;\n\tpdev->read_time_us += diff_timeval_us(&t1, &t2);\n\treturn rc;\n}\n\nstatic int pdev_write_blocks(struct device *dev, const char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tstruct perf_device *pdev = dev_pdev(dev);\n\tstruct timeval t1, t2;\n\tint rc;\n\n\tassert(!gettimeofday(&t1, NULL));\n\trc = pdev->shadow_dev->write_blocks(pdev->shadow_dev, buf,\n\t\tfirst_pos, last_pos);\n\tassert(!gettimeofday(&t2, NULL));\n\tpdev->write_count += last_pos - first_pos + 1;\n\tpdev->write_time_us += diff_timeval_us(&t1, &t2);\n\treturn rc;\n}\n\nstatic int pdev_reset(struct device *dev)\n{\n\tstruct perf_device *pdev = dev_pdev(dev);\n\tstruct timeval t1, t2;\n\tint rc;\n\n\tassert(!gettimeofday(&t1, NULL));\n\trc = dev_reset(pdev->shadow_dev);\n\tassert(!gettimeofday(&t2, NULL));\n\tpdev->reset_count++;\n\tpdev->reset_time_us += diff_timeval_us(&t1, &t2);\n\treturn rc;\n}\n\nstatic void pdev_free(struct device *dev)\n{\n\tstruct perf_device *pdev = dev_pdev(dev);\n\tfree_device(pdev->shadow_dev);\n}\n\nstatic const char *pdev_get_filename(struct device *dev)\n{\n\treturn dev_get_filename(dev_pdev(dev)->shadow_dev);\n}\n\nstruct device *pdev_detach_and_free(struct device *dev)\n{\n\tstruct perf_device *pdev = dev_pdev(dev);\n\tstruct device *shadow_dev = pdev->shadow_dev;\n\tpdev->shadow_dev = NULL;\n\tpdev->dev.free = NULL;\n\tfree_device(&pdev->dev);\n\treturn shadow_dev;\n}\n\nstruct device *create_perf_device(struct device *dev)\n{\n\tstruct perf_device *pdev;\n\n\tpdev = malloc(sizeof(*pdev));\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpdev->shadow_dev = dev;\n\tpdev->read_count = 0;\n\tpdev->read_time_us = 0;\n\tpdev->write_count = 0;\n\tpdev->write_time_us = 0;\n\tpdev->reset_count = 0;\n\tpdev->reset_time_us = 0;\n\n\tpdev->dev.size_byte = dev->size_byte;\n\tpdev->dev.block_order = dev->block_order;\n\tpdev->dev.read_blocks = pdev_read_blocks;\n\tpdev->dev.write_blocks = pdev_write_blocks;\n\tpdev->dev.reset\t= pdev_reset;\n\tpdev->dev.free = pdev_free;\n\tpdev->dev.get_filename = pdev_get_filename;\n\n\treturn &pdev->dev;\n}\n\nvoid perf_device_sample(struct device *dev,\n\tuint64_t *pread_count, uint64_t *pread_time_us,\n\tuint64_t *pwrite_count, uint64_t *pwrite_time_us,\n\tuint64_t *preset_count, uint64_t *preset_time_us)\n{\n\tstruct perf_device *pdev = dev_pdev(dev);\n\n\tif (pread_count)\n\t\t*pread_count = pdev->read_count;\n\tif (pread_time_us)\n\t\t*pread_time_us = pdev->read_time_us;\n\n\tif (pwrite_count)\n\t\t*pwrite_count = pdev->write_count;\n\tif (pwrite_time_us)\n\t\t*pwrite_time_us = pdev->write_time_us;\n\n\tif (preset_count)\n\t\t*preset_count = pdev->reset_count;\n\tif (preset_time_us)\n\t\t*preset_time_us = pdev->reset_time_us;\n}\n\n#define SDEV_BITMAP_WORD\t\tlong\n#define SDEV_BITMAP_BITS_PER_WORD\t(8*sizeof(SDEV_BITMAP_WORD))\nstruct safe_device {\n\t/* This must be the first field. See dev_sdev() for details. */\n\tstruct device\t\tdev;\n\n\tstruct device\t\t*shadow_dev;\n\n\tchar\t\t\t*saved_blocks;\n\tuint64_t\t\t*sb_positions;\n\tSDEV_BITMAP_WORD\t*sb_bitmap;\n\tuint64_t\t\tsb_n;\n\tuint64_t\t\tsb_max;\n};\n\nstatic inline struct safe_device *dev_sdev(struct device *dev)\n{\n\treturn (struct safe_device *)dev;\n}\n\nstatic int sdev_read_blocks(struct device *dev, char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tstruct safe_device *sdev = dev_sdev(dev);\n\treturn sdev->shadow_dev->read_blocks(sdev->shadow_dev, buf,\n\t\tfirst_pos, last_pos);\n}\n\nstatic int sdev_is_block_saved(struct safe_device *sdev, uint64_t pos)\n{\n\tlldiv_t idx;\n\tSDEV_BITMAP_WORD set_bit;\n\n\tif (!sdev->sb_bitmap) {\n\t\tuint64_t i;\n\t\t/* Running without bitmap. */\n\t\tfor (i = 0; i < sdev->sb_n; i++)\n\t\t\tif (sdev->sb_positions[i] == pos) {\n\t\t\t\t/* The block is already saved. */\n\t\t\t\treturn true;\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tidx = lldiv(pos, SDEV_BITMAP_BITS_PER_WORD);\n\tset_bit = (SDEV_BITMAP_WORD)1 << idx.rem;\n\treturn !!(sdev->sb_bitmap[idx.quot] & set_bit);\n}\n\nstatic void sdev_mark_blocks(struct safe_device *sdev,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tuint64_t pos;\n\n\tfor (pos = first_pos; pos <= last_pos; pos++) {\n\t\tif (sdev->sb_bitmap) {\n\t\t\tlldiv_t idx = lldiv(pos, SDEV_BITMAP_BITS_PER_WORD);\n\t\t\tSDEV_BITMAP_WORD set_bit = (SDEV_BITMAP_WORD)1 <<\n\t\t\t\tidx.rem;\n\t\t\tsdev->sb_bitmap[idx.quot] |= set_bit;\n\t\t}\n\t\tsdev->sb_positions[sdev->sb_n] = pos;\n\t\tsdev->sb_n++;\n\t}\n}\n\n/* Load blocks into cache. */\nstatic int sdev_load_blocks(struct safe_device *sdev,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tconst int block_order = dev_get_block_order(sdev->shadow_dev);\n\tchar *block_buf = (char *)align_mem(sdev->saved_blocks, block_order) +\n\t\t(sdev->sb_n << block_order);\n\tint rc;\n\n\tassert(sdev->sb_n + (last_pos - first_pos + 1) < sdev->sb_max);\n\n\trc = sdev->shadow_dev->read_blocks(sdev->shadow_dev, block_buf,\n\t\tfirst_pos, last_pos);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Bookkeeping. */\n\tsdev_mark_blocks(sdev, first_pos, last_pos);\n\treturn 0;\n}\n\nstatic int sdev_save_block(struct safe_device *sdev,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tuint64_t pos, start_pos;\n\tint rc;\n\n\tstart_pos = first_pos;\n\tfor (pos = first_pos; pos <= last_pos; pos++) {\n\t\tif (sdev_is_block_saved(sdev, pos)) {\n\t\t\tif (start_pos < pos) {\n\t\t\t\t/* The blocks haven't been saved before.\n\t\t\t\t * Save them now.\n\t\t\t\t */\n\t\t\t\trc = sdev_load_blocks(sdev, start_pos, pos - 1);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} else if (start_pos == pos) {\n\t\t\t\t/* Do nothing. */\n\t\t\t} else {\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t\tstart_pos = pos + 1;\n\t\t}\n\t}\n\n\tif (start_pos <= last_pos) {\n\t\trc = sdev_load_blocks(sdev, start_pos, last_pos);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdev_write_blocks(struct device *dev, const char *buf,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tstruct safe_device *sdev = dev_sdev(dev);\n\tint rc = sdev_save_block(sdev, first_pos, last_pos);\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn sdev->shadow_dev->write_blocks(sdev->shadow_dev, buf,\n\t\tfirst_pos, last_pos);\n}\n\nstatic int sdev_reset(struct device *dev)\n{\n\treturn dev_reset(dev_sdev(dev)->shadow_dev);\n}\n\nstatic void sdev_carefully_recover(struct safe_device *sdev, char *buffer,\n\t\tuint64_t first_pos, uint64_t last_pos)\n{\n\tconst int block_size = dev_get_block_size(sdev->shadow_dev);\n\tuint64_t pos;\n\tint rc = sdev->shadow_dev->write_blocks(sdev->shadow_dev,\n\t\tbuffer, first_pos, last_pos);\n\tif (!rc)\n\t\treturn;\n\n\tfor (pos = first_pos; pos <= last_pos; pos++) {\n\t\tint rc = sdev->shadow_dev->write_blocks(sdev->shadow_dev,\n\t\t\tbuffer, pos, pos);\n\t\tif (rc) {\n\t\t\t/* Do not abort, try to recover all bocks. */\n\t\t\twarn(\"Failed to recover block 0x%\" PRIx64\n\t\t\t\t\" due to a write error\", pos);\n\t\t}\n\t\tbuffer += block_size;\n\t}\n}\n\nstatic uint64_t sdev_bitmap_length(struct device *dev)\n{\n\tconst int block_order = dev_get_block_order(dev);\n\tlldiv_t idx = lldiv(dev_get_size_byte(dev) >> block_order,\n\t\tSDEV_BITMAP_BITS_PER_WORD);\n\treturn (idx.quot + (idx.rem ? 1 : 0)) * sizeof(SDEV_BITMAP_WORD);\n}\n\nvoid sdev_recover(struct device *dev, uint64_t very_last_pos)\n{\n\tstruct safe_device *sdev = dev_sdev(dev);\n\tconst int block_order = dev_get_block_order(sdev->shadow_dev);\n\tchar *first_block = align_mem(sdev->saved_blocks, block_order);\n\tuint64_t i, first_pos, last_pos;\n\tchar *start_buf;\n\tint has_seq;\n\n\thas_seq = false;\n\tfor (i = 0; i < sdev->sb_n; i++) {\n\t\tuint64_t pos = sdev->sb_positions[i];\n\n\t\tif (!has_seq) {\n\t\t\tif (pos > very_last_pos)\n\t\t\t\tcontinue;\n\n\t\t\tlast_pos = first_pos = pos;\n\t\t\tstart_buf = first_block + (i << block_order);\n\t\t\thas_seq = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pos <= very_last_pos && pos == last_pos + 1) {\n\t\t\tlast_pos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdev_carefully_recover(sdev, start_buf, first_pos, last_pos);\n\n\t\thas_seq = pos <= very_last_pos;\n\t\tif (has_seq) {\n\t\t\tlast_pos = first_pos = pos;\n\t\t\tstart_buf = first_block + (i << block_order);\n\t\t}\n\t}\n\n\tif (has_seq) {\n\t\tsdev_carefully_recover(sdev, start_buf, first_pos, last_pos);\n\t\thas_seq = false;\n\t}\n}\n\nvoid sdev_flush(struct device *dev)\n{\n\tstruct safe_device *sdev = dev_sdev(dev);\n\n\tif (sdev->sb_n <= 0)\n\t\treturn;\n\n\tsdev->sb_n = 0;\n\n\tif (sdev->sb_bitmap)\n\t\tmemset(sdev->sb_bitmap, 0,\n\t\t\tsdev_bitmap_length(sdev->shadow_dev));\n}\n\nstatic void sdev_free(struct device *dev)\n{\n\tstruct safe_device *sdev = dev_sdev(dev);\n\n\tsdev_recover(dev, UINT_LEAST64_MAX);\n\tsdev_flush(dev);\n\n\tfree(sdev->sb_bitmap);\n\tfree(sdev->sb_positions);\n\tfree(sdev->saved_blocks);\n\tfree_device(sdev->shadow_dev);\n}\n\nstatic const char *sdev_get_filename(struct device *dev)\n{\n\treturn dev_get_filename(dev_sdev(dev)->shadow_dev);\n}\n\nstruct device *create_safe_device(struct device *dev, uint64_t max_blocks,\n\tint min_memory)\n{\n\tstruct safe_device *sdev;\n\tconst int block_order = dev_get_block_order(dev);\n\tuint64_t length;\n\n\tsdev = malloc(sizeof(*sdev));\n\tif (!sdev)\n\t\tgoto error;\n\n\tlength = align_head(block_order) + (max_blocks << block_order);\n\tsdev->saved_blocks = malloc(length);\n\tif (!sdev->saved_blocks)\n\t\tgoto sdev;\n\n\tsdev->sb_positions = malloc(max_blocks * sizeof(*sdev->sb_positions));\n\tif (!sdev->sb_positions)\n\t\tgoto saved_blocks;\n\n\tif (!min_memory) {\n\t\tlength = sdev_bitmap_length(dev);\n\t\tsdev->sb_bitmap = malloc(length);\n\t\tif (!sdev->sb_bitmap)\n\t\t\tgoto offsets;\n\t\tmemset(sdev->sb_bitmap, 0, length);\n\t} else {\n\t\tsdev->sb_bitmap = NULL;\n\t}\n\n\tsdev->shadow_dev = dev;\n\tsdev->sb_n = 0;\n\tsdev->sb_max = max_blocks;\n\n\tsdev->dev.size_byte = dev->size_byte;\n\tsdev->dev.block_order = block_order;\n\tsdev->dev.read_blocks = sdev_read_blocks;\n\tsdev->dev.write_blocks = sdev_write_blocks;\n\tsdev->dev.reset\t= sdev_reset;\n\tsdev->dev.free = sdev_free;\n\tsdev->dev.get_filename = sdev_get_filename;\n\n\treturn &sdev->dev;\n\noffsets:\n\tfree(sdev->sb_positions);\nsaved_blocks:\n\tfree(sdev->saved_blocks);\nsdev:\n\tfree(sdev);\nerror:\n\treturn NULL;\n}\n"
        },
        {
          "name": "libdevs.h",
          "type": "blob",
          "size": 2.5205078125,
          "content": "#ifndef HEADER_LIBDEVS_H\n#define HEADER_LIBDEVS_H\n\n#include <stdint.h>\n\n/*\n *\tDevice model\n */\n\nenum fake_type {\n\t/* Device is good. */\n\tFKTY_GOOD,\n\n\t/* Device is at least partially damaged. */\n\tFKTY_BAD,\n\n\t/* Device discards data after a given limit. */\n\tFKTY_LIMBO,\n\n\t/* Device overwrites data after a given limit. */\n\tFKTY_WRAPAROUND,\n\n\t/* Device is a sequence of wraparound and limbo regions. */\n\tFKTY_CHAIN,\n\n\tFKTY_MAX\n};\n\nconst char *fake_type_to_name(enum fake_type fake_type);\n\nint dev_param_valid(uint64_t real_size_byte,\n\tuint64_t announced_size_byte, int wrap, int block_order);\n\nenum fake_type dev_param_to_type(uint64_t real_size_byte,\n\tuint64_t announced_size_byte, int wrap, int block_order);\n\n/*\n *\tAbstract device\n */\n\nstruct device;\n\n/*\n *\tProperties\n */\n\nuint64_t dev_get_size_byte(struct device *dev);\nint dev_get_block_order(struct device *dev);\nint dev_get_block_size(struct device *dev);\n/* File name of the device.\n * This information is important because the filename may change due to resets.\n */\nconst char *dev_get_filename(struct device *dev);\n\n/*\n *\tMethods\n */\n\n/* One should use the following constant as the size of the buffer needed to\n * batch writes or reads.\n *\n * It must be a power of 2 greater than, or equal to 2^20.\n * The current value is 1MB.\n */\n#define BIG_BLOCK_SIZE_BYTE (1 << 20)\n\nint dev_read_blocks(struct device *dev, char *buf,\n\tuint64_t first_pos, uint64_t last_pos);\nint dev_write_blocks(struct device *dev, const char *buf,\n\tuint64_t first_pos, uint64_t last_pos);\n\nint dev_reset(struct device *dev);\nvoid free_device(struct device *dev);\n\n/*\n *\tConcrete devices\n */\n\nstruct device *create_file_device(const char *filename,\n\tuint64_t real_size_byte, uint64_t fake_size_byte, int wrap,\n\tint block_order, int cache_order, int strict_cache,\n\tint keep_file);\n\nenum reset_type {\n\tRT_MANUAL_USB = 0,\n\tRT_USB,\n\tRT_NONE,\n\tRT_MAX\n};\n\nstruct device *create_block_device(const char *filename, enum reset_type rt);\n\nstruct device *create_perf_device(struct device *dev);\nvoid perf_device_sample(struct device *dev,\n\tuint64_t *pread_count, uint64_t *pread_time_us,\n\tuint64_t *pwrite_count, uint64_t *pwrite_time_us,\n\tuint64_t *preset_count, uint64_t *preset_time_us);\n/* Detach the shadow device of @pdev, free @pdev, and return\n * the shadow device.\n */\nstruct device *pdev_detach_and_free(struct device *dev);\n\nstruct device *create_safe_device(struct device *dev, uint64_t max_blocks,\n\tint min_memory);\n\nvoid sdev_recover(struct device *dev, uint64_t very_last_pos);\nvoid sdev_flush(struct device *dev);\n\n#endif\t/* HEADER_LIBDEVS_H */\n"
        },
        {
          "name": "libflow.c",
          "type": "blob",
          "size": 8.8466796875,
          "content": "#define _POSIX_C_SOURCE 200112L\n#define _XOPEN_SOURCE 600\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <assert.h>\n#include <math.h>\n#include <sys/time.h>\n\n#include \"libflow.h\"\n#include \"utils.h\"\n\nstatic inline void move_to_inc_at_start(struct flow *fw)\n{\n\tfw->step = 1;\n\tfw->state = FW_INC;\n}\n\nvoid init_flow(struct flow *fw, uint64_t total_size,\n\tlong max_process_rate, int progress,\n\tflow_func_flush_chunk_t func_flush_chunk)\n{\n\tfw->total_size\t\t= total_size;\n\tfw->total_processed\t= 0;\n\tfw->progress\t\t= progress;\n\tfw->block_size\t\t= 512;\t/* Bytes\t*/\n\tfw->blocks_per_delay\t= 1;\t/* 512B/s\t*/\n\tfw->delay_ms\t\t= 1000;\t/* 1s\t\t*/\n\tfw->max_process_rate\t= max_process_rate <= 0\n\t\t? DBL_MAX : max_process_rate * 1024.;\n\tfw->measured_blocks\t= 0;\n\tfw->measured_time_ms\t= 0;\n\tfw->erase\t\t= 0;\n\tfw->func_flush_chunk\t= func_flush_chunk;\n\tfw->processed_blocks\t= 0;\n\tfw->acc_delay_us\t= 0;\n\tassert(fw->block_size > 0);\n\tassert(fw->block_size % SECTOR_SIZE == 0);\n\n\tmove_to_inc_at_start(fw);\n}\n\nstatic inline void repeat_ch(char ch, int count)\n{\n\twhile (count > 0) {\n\t\tprintf(\"%c\", ch);\n\t\tcount--;\n\t}\n}\n\nstatic void erase(int count)\n{\n\tif (count <= 0)\n\t\treturn;\n\trepeat_ch('\\b',\tcount);\n\trepeat_ch(' ',\tcount);\n\trepeat_ch('\\b',\tcount);\n}\n\nstatic int pr_time(double sec)\n{\n\tint has_h, has_m;\n\tint c, tot;\n\n\ttot = printf(\" -- \");\n\tassert(tot > 0);\n\n\thas_h = sec >= 3600;\n\tif (has_h) {\n\t\tdouble h = floor(sec / 3600);\n\t\tc = printf(\"%i:\", (int)h);\n\t\tassert(c > 0);\n\t\ttot += c;\n\t\tsec -= h * 3600;\n\t}\n\n\thas_m = has_h || sec >= 60;\n\tif (has_m) {\n\t\tdouble m = floor(sec / 60);\n\t\tif (has_h)\n\t\t\tc = printf(\"%02i:\", (int)m);\n\t\telse\n\t\t\tc = printf(\"%i:\", (int)m);\n\t\tassert(c > 0);\n\t\ttot += c;\n\t\tsec -= m * 60;\n\t}\n\n\tif (has_m)\n\t\tc = printf(\"%02i\", (int)round(sec));\n\telse\n\t\tc = printf(\"%is\", (int)round(sec));\n\tassert(c > 0);\n\treturn tot + c;\n}\n\nstatic void report_progress(struct flow *fw, double inst_speed)\n{\n\tconst char *unit = adjust_unit(&inst_speed);\n\tdouble percent;\n\t/* The following shouldn't be necessary, but sometimes\n\t * the initial free space isn't exactly reported\n\t * by the kernel; this issue has been seen on Macs.\n\t */\n\tif (fw->total_size < fw->total_processed)\n\t\tfw->total_size = fw->total_processed;\n\tpercent = (double)fw->total_processed * 100 / fw->total_size;\n\terase(fw->erase);\n\tfw->erase = printf(\"%.2f%% -- %.2f %s/s\",\n\t\tpercent, inst_speed, unit);\n\tassert(fw->erase > 0);\n\tif (has_enough_measurements(fw))\n\t\tfw->erase += pr_time(\n\t\t\t(fw->total_size - fw->total_processed) /\n\t\t\tget_avg_speed(fw));\n\tfflush(stdout);\n}\n\nstatic inline void __start_measurement(struct flow *fw)\n{\n\tassert(!gettimeofday(&fw->t1, NULL));\n}\n\nvoid start_measurement(struct flow *fw)\n{\n\t/*\n\t * The report below is especially useful when a single measurement spans\n\t * multiple files; this happens when a drive is faster than 1GB/s.\n\t */\n\tif (fw->progress)\n\t\treport_progress(fw, fw->blocks_per_delay * fw->block_size *\n\t\t\t1000.0 / fw->delay_ms);\n\t__start_measurement(fw);\n}\n\nstatic inline void move_to_steady(struct flow *fw)\n{\n\tfw->state = FW_STEADY;\n}\n\nstatic void move_to_search(struct flow *fw, int64_t bpd1, int64_t bpd2)\n{\n\tassert(bpd1 > 0);\n\tassert(bpd2 >= bpd1);\n\n\tfw->blocks_per_delay = (bpd1 + bpd2) / 2;\n\tif (bpd2 - bpd1 <= 3) {\n\t\tmove_to_steady(fw);\n\t\treturn;\n\t}\n\n\tfw->bpd1 = bpd1;\n\tfw->bpd2 = bpd2;\n\tfw->state = FW_SEARCH;\n}\n\nstatic inline void dec_step(struct flow *fw)\n{\n\tif (fw->blocks_per_delay - fw->step > 0) {\n\t\tfw->blocks_per_delay -= fw->step;\n\t\tfw->step *= 2;\n\t} else\n\t\tmove_to_search(fw, 1, fw->blocks_per_delay + fw->step / 2);\n}\n\nstatic inline void inc_step(struct flow *fw)\n{\n\tfw->blocks_per_delay += fw->step;\n\tfw->step *= 2;\n}\n\nstatic inline void move_to_inc(struct flow *fw)\n{\n\tmove_to_inc_at_start(fw);\n\tinc_step(fw);\n}\n\nstatic inline void move_to_dec(struct flow *fw)\n{\n\tfw->step = 1;\n\tfw->state = FW_DEC;\n\tdec_step(fw);\n}\n\nstatic inline int is_rate_above(const struct flow *fw,\n\tuint64_t delay, double inst_speed)\n{\n\t/* We use logical or here to enforce the lowest limit. */\n\treturn delay > fw->delay_ms || inst_speed > fw->max_process_rate;\n}\n\nstatic inline int is_rate_below(const struct flow *fw,\n\tuint64_t delay, double inst_speed)\n{\n\t/* We use logical and here to enforce both limits. */\n\treturn delay <= fw->delay_ms && inst_speed < fw->max_process_rate;\n}\n\nstatic inline int flush_chunk(const struct flow *fw, int fd)\n{\n\tif (fw->func_flush_chunk)\n\t\treturn fw->func_flush_chunk(fw, fd);\n\treturn 0;\n}\n\n/* XXX Avoid duplicate this function, which was copied from libutils.h. */\nstatic inline uint64_t diff_timeval_us(const struct timeval *t1,\n\tconst struct timeval *t2)\n{\n\treturn (t2->tv_sec - t1->tv_sec) * 1000000ULL +\n\t\tt2->tv_usec - t1->tv_usec;\n}\n\nint measure(int fd, struct flow *fw, long processed)\n{\n\tldiv_t result = ldiv(processed, fw->block_size);\n\tstruct timeval t2;\n\tuint64_t delay;\n\tdouble bytes_k, inst_speed;\n\n\tassert(result.rem == 0);\n\tfw->processed_blocks += result.quot;\n\tfw->total_processed += processed;\n\n\tif (fw->processed_blocks < fw->blocks_per_delay)\n\t\treturn 0;\n\tassert(fw->processed_blocks == fw->blocks_per_delay);\n\n\tif (flush_chunk(fw, fd) < 0)\n\t\treturn -1; /* Caller can read errno(3). */\n\n\tassert(!gettimeofday(&t2, NULL));\n\tdelay = (diff_timeval_us(&fw->t1, &t2) + fw->acc_delay_us) / 1000;\n\n\t/* Instantaneous speed in bytes per second. */\n\tbytes_k = fw->blocks_per_delay * fw->block_size * 1000.0;\n\tinst_speed = bytes_k / delay;\n\n\tif (delay < fw->delay_ms && inst_speed > fw->max_process_rate) {\n\t\t/* Wait until inst_speed == fw->max_process_rate\n\t\t * (if possible).\n\t\t */\n\t\tdouble wait_ms = round((bytes_k - delay * fw->max_process_rate)\n\t\t\t/ fw->max_process_rate);\n\n\t\t if (wait_ms < 0) {\n\t\t\t/* Wait what is possible. */\n\t\t\twait_ms = fw->delay_ms - delay;\n\t\t} else if (delay + wait_ms < fw->delay_ms) {\n\t\t\t/* wait_ms is not the largest possible value, so\n\t\t\t * force the flow algorithm to keep increasing it.\n\t\t\t * Otherwise, the delay to print progress may be\n\t\t\t * too small.\n\t\t\t */\n\t\t\twait_ms++;\n\t\t}\n\n\t\tif (wait_ms > 0) {\n\t\t\t/* Slow down. */\n\t\t\tmsleep(wait_ms);\n\n\t\t\t/* Adjust measurements. */\n\t\t\tdelay += wait_ms;\n\t\t\tinst_speed = bytes_k / delay;\n\t\t}\n\t}\n\n\t/* Update mean. */\n\tfw->measured_blocks += fw->processed_blocks;\n\tfw->measured_time_ms += delay;\n\n\tswitch (fw->state) {\n\tcase FW_INC:\n\t\tif (is_rate_above(fw, delay, inst_speed)) {\n\t\t\tmove_to_search(fw,\n\t\t\t\tfw->blocks_per_delay - fw->step / 2,\n\t\t\t\tfw->blocks_per_delay);\n\t\t} else if (is_rate_below(fw, delay, inst_speed)) {\n\t\t\tinc_step(fw);\n\t\t} else\n\t\t\tmove_to_steady(fw);\n\t\tbreak;\n\n\tcase FW_DEC:\n\t\tif (is_rate_above(fw, delay, inst_speed)) {\n\t\t\tdec_step(fw);\n\t\t} else if (is_rate_below(fw, delay, inst_speed)) {\n\t\t\tmove_to_search(fw, fw->blocks_per_delay,\n\t\t\t\tfw->blocks_per_delay + fw->step / 2);\n\t\t} else\n\t\t\tmove_to_steady(fw);\n\t\tbreak;\n\n\tcase FW_SEARCH:\n\t\tif (fw->bpd2 - fw->bpd1 <= 3) {\n\t\t\tmove_to_steady(fw);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_rate_above(fw, delay, inst_speed)) {\n\t\t\tfw->bpd2 = fw->blocks_per_delay;\n\t\t\tfw->blocks_per_delay = (fw->bpd1 + fw->bpd2) / 2;\n\t\t} else if (is_rate_below(fw, delay, inst_speed)) {\n\t\t\tfw->bpd1 = fw->blocks_per_delay;\n\t\t\tfw->blocks_per_delay = (fw->bpd1 + fw->bpd2) / 2;\n\t\t} else\n\t\t\tmove_to_steady(fw);\n\t\tbreak;\n\n\tcase FW_STEADY: {\n\t\tif (delay <= fw->delay_ms) {\n\t\t\tif (inst_speed < fw->max_process_rate) {\n\t\t\t\tmove_to_inc(fw);\n\t\t\t} else if (inst_speed > fw->max_process_rate) {\n\t\t\t\tmove_to_dec(fw);\n\t\t\t}\n\t\t} else if (fw->blocks_per_delay > 1) {\n\t\t\tmove_to_dec(fw);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tif (fw->progress)\n\t\treport_progress(fw, inst_speed);\n\n\t/* Reset accumulators. */\n\tfw->processed_blocks = 0;\n\tfw->acc_delay_us = 0;\n\t__start_measurement(fw);\n\treturn 0;\n}\n\nint end_measurement(int fd, struct flow *fw)\n{\n\tstruct timeval t2;\n\tint saved_errno;\n\tint ret = 0;\n\n\tif (fw->processed_blocks <= 0)\n\t\tgoto out;\n\n\tif (flush_chunk(fw, fd) < 0) {\n\t\tsaved_errno = errno;\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Save time in between closing ongoing file and creating a new file. */\n\tassert(!gettimeofday(&t2, NULL));\n\tfw->acc_delay_us += diff_timeval_us(&fw->t1, &t2);\n\nout:\n\t/* Erase progress information. */\n\terase(fw->erase);\n\tfw->erase = 0;\n\tfflush(stdout);\n\n\tif (ret < 0) {\n\t\t/* Propagate errno(3) to caller. */\n\t\terrno = saved_errno;\n\t}\n\treturn ret;\n}\n\nstatic inline void __dbuf_free(struct dynamic_buffer *dbuf)\n{\n\tif (dbuf->buf != dbuf->backup_buf)\n\t\tfree(dbuf->buf);\n}\n\nvoid dbuf_free(struct dynamic_buffer *dbuf)\n{\n\t__dbuf_free(dbuf);\n\tdbuf->buf = NULL;\n\tdbuf->len = 0;\n\tdbuf->max_buf = true;\n}\n\nchar *dbuf_get_buf(struct dynamic_buffer *dbuf, size_t size)\n{\n\t/* If enough buffer, or it's already the largest buffer, return it. */\n\tif (size <= dbuf->len || dbuf->max_buf)\n\t\treturn dbuf->buf;\n\n\t/*\n\t * Allocate a new buffer.\n\t */\n\n\t__dbuf_free(dbuf);\n\tdo {\n\t\tdbuf->buf = malloc(size);\n\t\tif (dbuf->buf != NULL) {\n\t\t\tdbuf->len = size;\n\t\t\treturn dbuf->buf;\n\t\t} else {\n\t\t\tdbuf->max_buf = true;\n\t\t}\n\t\tsize /= 2;\n\t} while (size > sizeof(dbuf->backup_buf));\n\n\t/* A larger buffer is not available; failsafe. */\n\tdbuf->buf = dbuf->backup_buf;\n\tdbuf->len = sizeof(dbuf->backup_buf);\n\treturn dbuf->buf;\n}\n"
        },
        {
          "name": "libflow.h",
          "type": "blob",
          "size": 3.0078125,
          "content": "#ifndef HEADER_LIBFLOW_H\n#define HEADER_LIBFLOW_H\n\n#include <stdint.h>\n#include <stdbool.h>\n\nstruct flow;\n\ntypedef int (*flow_func_flush_chunk_t)(const struct flow *fw, int fd);\n\nstruct flow {\n\t/* Total number of bytes to be processed. */\n\tuint64_t\ttotal_size;\n\t/* Total number of bytes already processed. */\n\tuint64_t\ttotal_processed;\n\t/* If true, show progress. */\n\tint\t\tprogress;\n\t/* Block size in bytes. */\n\tint\t\tblock_size;\n\t/* Delay intended between measurements in milliseconds. */\n\tunsigned int\tdelay_ms;\n\t/* Increment to apply to @blocks_per_delay. */\n\tint64_t\t\tstep;\n\t/* Blocks to process before measurement. */\n\tint64_t\t\tblocks_per_delay;\n\t/* Maximum processing rate in bytes per second. */\n\tdouble\t\tmax_process_rate;\n\t/* Number of measured blocks. */\n\tuint64_t\tmeasured_blocks;\n\t/* Measured time. */\n\tuint64_t\tmeasured_time_ms;\n\t/* State. */\n\tenum {FW_INC, FW_DEC, FW_SEARCH, FW_STEADY} state;\n\t/* Number of characters to erase before printing out progress. */\n\tint\t\terase;\n\n\t/*\n\t * Methods\n\t */\n\tflow_func_flush_chunk_t func_flush_chunk;\n\n\t/*\n\t * Initialized while measuring\n\t */\n\n\t/* Number of blocks processed since last measurement. */\n\tint64_t\t\tprocessed_blocks;\n\t/*\n\t * Accumulated delay before @processed_blocks reaches @blocks_per_delay\n\t * in microseconds.\n\t */\n\tuint64_t\tacc_delay_us;\n\t/* Range of blocks_per_delay while in FW_SEARCH state. */\n\tint64_t\t\tbpd1, bpd2;\n\t/* Time measurements. */\n\tstruct timeval\tt1;\n};\n\n/* If @max_process_rate <= 0, the maximum processing rate is infinity.\n * The unit of @max_process_rate is KB per second.\n */\nvoid init_flow(struct flow *fw, uint64_t total_size,\n\tlong max_process_rate, int progress,\n\tflow_func_flush_chunk_t func_flush_chunk);\n\nvoid start_measurement(struct flow *fw);\nint measure(int fd, struct flow *fw, long processed);\nint end_measurement(int fd, struct flow *fw);\n\nstatic inline int has_enough_measurements(const struct flow *fw)\n{\n\treturn fw->measured_time_ms > fw->delay_ms;\n}\n\nstatic inline double get_avg_speed_given_time(struct flow *fw,\n\tuint64_t total_time_ms)\n{\n\treturn (double)(fw->measured_blocks * fw->block_size * 1000) /\n\t\ttotal_time_ms;\n}\n\n/* Average writing speed in byte/s. */\nstatic inline double get_avg_speed(struct flow *fw)\n{\n\treturn get_avg_speed_given_time(fw, fw->measured_time_ms);\n}\n\nstatic inline uint64_t get_rem_chunk_size(struct flow *fw)\n{\n\tassert(fw->blocks_per_delay > fw->processed_blocks);\n\treturn (fw->blocks_per_delay - fw->processed_blocks) * fw->block_size;\n}\n\nstruct dynamic_buffer {\n\tchar   *buf;\n\tsize_t len;\n\tbool   max_buf;\n\tchar   backup_buf[1 << 21]; /* 2MB */\n};\n\nstatic inline void dbuf_init(struct dynamic_buffer *dbuf)\n{\n\tdbuf->buf = dbuf->backup_buf;\n\tdbuf->len = sizeof(dbuf->backup_buf);\n\tdbuf->max_buf = false;\n}\n\nvoid dbuf_free(struct dynamic_buffer *dbuf);\n\n/*\n * Although the returned buffer may be smaller than @size,\n * this function never returns NULL.\n */\nchar *dbuf_get_buf(struct dynamic_buffer *dbuf, size_t size);\n\nstatic inline size_t dbuf_get_len(const struct dynamic_buffer *dbuf)\n{\n\treturn dbuf->len;\n}\n\n#endif\t/* HEADER_LIBFLOW_H */\n"
        },
        {
          "name": "libprobe.c",
          "type": "blob",
          "size": 21.9736328125,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <assert.h>\n#include <math.h>\n#include <errno.h>\n#include <time.h>\t/* For time().\t\t*/\n#include <sys/time.h>\t/* For gettimeofday().\t*/\n\n#include \"libutils.h\"\n#include \"libprobe.h\"\n\nstatic int write_blocks(struct device *dev,\n\tuint64_t first_pos, uint64_t last_pos, uint64_t salt)\n{\n\tconst int block_order = dev_get_block_order(dev);\n\tconst int block_size = dev_get_block_size(dev);\n\t/* Aligning these pointers is necessary to directly read and write\n\t * the block device.\n\t * For the file device, this is superfluous.\n\t */\n\tchar stack[align_head(block_order) + BIG_BLOCK_SIZE_BYTE];\n\tchar *buffer = align_mem(stack, block_order);\n\tchar *stamp_blk = buffer;\n\tchar *flush_blk = buffer + BIG_BLOCK_SIZE_BYTE;\n\tuint64_t offset = first_pos << block_order;\n\tuint64_t pos, write_pos = first_pos;\n\n\tfor (pos = first_pos; pos <= last_pos; pos++) {\n\t\tfill_buffer_with_block(stamp_blk, block_order, offset, salt);\n\t\tstamp_blk += block_size;\n\t\toffset += block_size;\n\n\t\tif (stamp_blk == flush_blk || pos == last_pos) {\n\t\t\tif (dev_write_blocks(dev, buffer, write_pos, pos) &&\n\t\t\t\tdev_write_blocks(dev, buffer, write_pos, pos))\n\t\t\t\treturn true;\n\t\t\tstamp_blk = buffer;\n\t\t\twrite_pos = pos + 1;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int high_level_reset(struct device *dev, uint64_t start_pos,\n\tuint64_t cache_size_block, int need_reset, uint64_t salt)\n{\n\tif (write_blocks(dev,\n\t\tstart_pos, start_pos + cache_size_block - 1, salt))\n\t\treturn true;\n\n\t/* Reset. */\n\tif (need_reset && dev_reset(dev) && dev_reset(dev))\n\t\treturn true;\n\n\treturn false;\n}\n\n/* Statistics used by bisect() in order to optimize the proportion\n * between writes and resets.\n */\nstruct bisect_stats {\n\tint\t\twrite_count;\n\tint\t\treset_count;\n\tuint64_t\twrite_time_us;\n\tuint64_t\treset_time_us;\n};\n\nstatic void init_bisect_stats(struct bisect_stats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n}\n\n#define MAX_N_BLOCK_ORDER\t10\n\nstatic uint64_t estimate_n_bisect_blocks(struct bisect_stats *pstats)\n{\n\tdouble t_w_us, t_2w_us, t_r_us;\n\tuint64_t n_block_order;\n\n\tif (pstats->write_count < 10 || pstats->reset_count < 1) {\n\t\t/* There is not enough measurements. */\n\t\treturn (1 << 4) - 1;\n\t}\n\n\t/* Let 2^n be the total number of blocks on the drive.\n\t * Let p be the total number of passes.\n\t * Let w = (2^m - 1) be the number of blocks written on each pass,\n\t *   where m >= 1.\n\t *\n\t * A pass is an iteration of the loop in search_edge(), that is,\n\t * a call to write_test_blocks(), dev_reset(), and probe_test_blocks().\n\t *\n\t * The reason to have w = (2^m - 1) instead of w = 2^m is because\n\t * the former leads to a clean relationship between n, p, and m\n\t * when m is constant: 2^n / (w + 1)^p = 1 => p = n/m\n\t *\n\t * Let Tr be the time to reset the device.\n\t * Let Tw be the time to write a block to @dev.\n\t * Let Tw' be the time to write a block to the underlying device\n\t *   of @dev, that is, without overhead due to chaining multiple\n\t *   struct device. For example, when struct safe_device is used\n\t *   Tw > Tw'.\n\t * Let Trd be the time to read a block from @dev.\n\t *\n\t * Notice that each single-block pass reduces the search space in half,\n\t * and that to reduce the search space in half writing blocks,\n\t * one has to increase m of one.\n\t *\n\t * Thus, in order to be better writing more blocks than\n\t * going for another pass, the following relation must be true:\n\t *\n\t * Tr + Tw + Tw' >= (w - 1)(Tw + Tw')\n\t *\n\t * The relation above assumes Trd = 0.\n\t *\n\t * The left side of the relation above is the time to do _another_\n\t * pass writing a single block, whereas the right side is the time to\n\t * stay in the same pass and write (w - 1) more blocks.\n\t * In order words, if there is no advantage to write more blocks,\n\t * we stick to single-block passes.\n\t *\n\t * Tw' is there to account for any operation that writes\n\t * the blocks back (e.g. using struct safe_device), otherwise\n\t * processing operations related per written blocks that is not\n\t * being accounted for (e.g. reading the blocks back to test).\n\t *\n\t * Solving the relation for w: w <= Tr/(Tw + Tw') + 2\n\t *\n\t * However, we are not interested in any w, but only those of\n\t * of the form (2^m - 1) to make sure that we are not better off\n\t * calling another pass. Thus, solving the previous relation for m:\n\t *\n\t * m <= log_2(Tr/(Tw + Tw') + 3)\n\t *\n\t * We approximate Tw' making it equal to Tw.\n\t */\n\tt_w_us = (double)pstats->write_time_us / pstats->write_count;\n\tt_r_us = (double)pstats->reset_time_us / pstats->reset_count;\n\tt_2w_us = t_w_us > 0. ? 2. * t_w_us : 1.; /* Avoid zero division. */\n\tn_block_order = ilog2(round(t_r_us / t_2w_us + 3.));\n\n\t/* Bound the maximum number of blocks per pass to limit\n\t * the necessary amount of memory struct safe_device pre-allocates.\n\t */\n\tif (n_block_order > MAX_N_BLOCK_ORDER)\n\t\tn_block_order = MAX_N_BLOCK_ORDER;\n\n\treturn (1 << n_block_order) - 1;\n}\n\n/* Write blocks whose offsets are after @left_pos and before @right_pos. */\nstatic int write_bisect_blocks(struct device *dev,\n\tuint64_t left_pos, uint64_t right_pos, uint64_t n_blocks,\n\tuint64_t salt, uint64_t *pa, uint64_t *pb, uint64_t *pmax_idx)\n{\n\tuint64_t pos, last_pos;\n\n\tassert(n_blocks >= 1);\n\n\t/* Find coefficients of function a*idx + b where idx <= max_idx. */\n\tassert(left_pos < right_pos);\n\tassert(right_pos - left_pos >= 2);\n\t*pb = left_pos + 1;\n\t*pa = round((right_pos - *pb - 1.) / (n_blocks + 1.));\n\t*pa = !*pa ? 1ULL : *pa;\n\t*pmax_idx = (right_pos - *pb - 1) / *pa;\n\tif (*pmax_idx >= n_blocks) {\n\t\t/* Shift the zero of the function to the right.\n\t\t * This avoids picking the leftmost block when a more\n\t\t * informative block to the right is available.\n\t\t */\n\t\t*pb += *pa;\n\n\t\t*pmax_idx = n_blocks - 1;\n\t}\n\tlast_pos = *pa * *pmax_idx + *pb;\n\tassert(last_pos < right_pos);\n\n\t/* Write test blocks. */\n\tfor (pos = *pb; pos <= last_pos; pos += *pa)\n\t\tif (write_blocks(dev, pos, pos, salt))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int is_block_good(struct device *dev, uint64_t pos, int *pis_good,\n\tuint64_t salt)\n{\n\tconst int block_size = dev_get_block_size(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\tchar stack[align_head(block_order) + block_size];\n\tchar *probe_blk = align_mem(stack, block_order);\n\tuint64_t found_offset;\n\n\tif (dev_read_blocks(dev, probe_blk, pos, pos) &&\n\t\tdev_read_blocks(dev, probe_blk, pos, pos))\n\t\treturn true;\n\n\t*pis_good = !validate_buffer_with_block(probe_blk, block_order,\n\t\t\t&found_offset, salt) &&\n\t\tfound_offset == (pos << block_order);\n\treturn false;\n}\n\nstatic int probe_bisect_blocks(struct device *dev,\n\tuint64_t *pleft_pos, uint64_t *pright_pos, uint64_t salt,\n\tuint64_t a, uint64_t b, uint64_t max_idx)\n{\n\t/* Signed variables. */\n\tint64_t left_idx = 0;\n\tint64_t right_idx = max_idx;\n\twhile (left_idx <= right_idx) {\n\t\tint64_t idx = (left_idx + right_idx) / 2;\n\t\tuint64_t pos = a * idx + b;\n\t\tint is_good;\n\t\tif (is_block_good(dev, pos, &is_good, salt))\n\t\t\treturn true;\n\t\tif (is_good) {\n\t\t\tleft_idx = idx + 1;\n\t\t\t*pleft_pos = pos;\n\t\t} else {\n\t\t\tright_idx = idx - 1;\n\t\t\t*pright_pos = pos;\n\t\t}\n\t}\n\treturn false;\n}\n\n/* This function assumes that the block at @left_pos is good, and\n *\tthat the block at @*pright_pos is bad.\n */\nstatic int bisect(struct device *dev, struct bisect_stats *pstats,\n\tuint64_t left_pos, uint64_t *pright_pos, uint64_t reset_pos,\n\tuint64_t cache_size_block, int need_reset, uint64_t salt)\n{\n\tuint64_t gap = *pright_pos - left_pos;\n\tstruct timeval t1, t2;\n\n\tassert(*pright_pos > left_pos);\n\twhile (gap >= 2) {\n\t\tuint64_t a, b, max_idx;\n\t\tuint64_t n_blocks = estimate_n_bisect_blocks(pstats);\n\n\t\tassert(!gettimeofday(&t1, NULL));\n\t\tif (write_bisect_blocks(dev, left_pos, *pright_pos, n_blocks,\n\t\t\tsalt, &a, &b, &max_idx))\n\t\t\treturn true;\n\t\tassert(!gettimeofday(&t2, NULL));\n\t\tpstats->write_count += max_idx + 1;\n\t\tpstats->write_time_us += diff_timeval_us(&t1, &t2);\n\n\t\t/* Reset. */\n\t\tassert(!gettimeofday(&t1, NULL));\n\t\tif (high_level_reset(dev, reset_pos,\n\t\t\tcache_size_block, need_reset, salt))\n\t\t\treturn true;\n\t\tassert(!gettimeofday(&t2, NULL));\n\t\tpstats->reset_count++;\n\t\tpstats->reset_time_us += diff_timeval_us(&t1, &t2);\n\n\t\tif (probe_bisect_blocks(dev, &left_pos, pright_pos, salt,\n\t\t\t a, b, max_idx))\n\t\t\treturn true;\n\n\t\tgap = *pright_pos - left_pos;\n\t}\n\tassert(gap == 1);\n\treturn false;\n}\n\nstatic int count_good_blocks(struct device *dev, uint64_t *pcount,\n\tuint64_t first_pos, uint64_t last_pos, uint64_t salt)\n{\n\tconst int block_size = dev_get_block_size(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\tchar stack[align_head(block_order) + BIG_BLOCK_SIZE_BYTE];\n\tchar *buffer = align_mem(stack, block_order);\n\tuint64_t expected_sector_offset = first_pos << block_order;\n\tuint64_t start_pos = first_pos;\n\tuint64_t step = (BIG_BLOCK_SIZE_BYTE >> block_order) - 1;\n\tuint64_t count = 0;\n\n\tassert(BIG_BLOCK_SIZE_BYTE >= block_size);\n\n\twhile (start_pos <= last_pos) {\n\t\tchar *probe_blk = buffer;\n\t\tuint64_t pos, next_pos = start_pos + step;\n\n\t\tif (next_pos > last_pos)\n\t\t\tnext_pos = last_pos;\n\t\tif (dev_read_blocks(dev, buffer, start_pos, next_pos) &&\n\t\t\tdev_read_blocks(dev, buffer, start_pos, next_pos))\n\t\t\treturn true;\n\n\t\tfor (pos = start_pos; pos <= next_pos; pos++) {\n\t\t\tuint64_t found_sector_offset;\n\t\t\tif (!validate_buffer_with_block(probe_blk, block_order,\n\t\t\t\t\t&found_sector_offset, salt) &&\n\t\t\t\texpected_sector_offset == found_sector_offset)\n\t\t\t\tcount++;\n\t\t\texpected_sector_offset += block_size;\n\t\t\tprobe_blk += block_size;\n\t\t}\n\n\t\tstart_pos = next_pos + 1;\n\t}\n\n\t*pcount = count;\n\treturn false;\n}\n\nstatic int assess_reset_effect(struct device *dev,\n\tuint64_t *pcache_size_block, int *pneed_reset, int *pdone,\n\tuint64_t first_pos, uint64_t last_pos, uint64_t salt)\n{\n\tuint64_t write_target = (last_pos + 1) - first_pos;\n\tuint64_t b4_reset_count_block, after_reset_count_block;\n\n\tif (count_good_blocks(dev, &b4_reset_count_block,\n\t\tfirst_pos, last_pos, salt))\n\t\treturn true;\n\n\tif (!b4_reset_count_block) {\n\t\t/* The drive has no cache whatsoever. */\n\t\t*pcache_size_block = 0;\n\t\t*pneed_reset = false;\n\t\t*pdone = true;\n\t\treturn false;\n\t}\n\n\t/* Reset. */\n\tif (dev_reset(dev) && dev_reset(dev))\n\t\treturn true;\n\n\tif (count_good_blocks(dev, &after_reset_count_block,\n\t\tfirst_pos, last_pos, salt))\n\t\treturn true;\n\n\t/* Although unexpected, some fake cards do recover blocks after\n\t * a reset! This behavior is not consistent, though.\n\t * The first reported case is found here:\n\t * https://github.com/AltraMayor/f3/issues/50\n\t */\n\tif (b4_reset_count_block < write_target ||\n\t\tafter_reset_count_block < write_target) {\n\t\t*pneed_reset = after_reset_count_block < b4_reset_count_block;\n\t\t*pcache_size_block = *pneed_reset\n\t\t\t? after_reset_count_block\n\t\t\t: write_target;\n\t\t*pdone = true;\n\t\treturn false;\n\t}\n\n\t*pdone = false;\n\treturn false;\n}\n\nstatic inline uint64_t uint64_rand(void)\n{\n\treturn ((uint64_t)rand() << 32) | rand();\n}\n\nstatic uint64_t uint64_rand_range(uint64_t a, uint64_t b)\n{\n\tuint64_t r = uint64_rand();\n\tassert(a <= b);\n\treturn a + (r % (b - a + 1));\n}\n\n#define N_BLOCK_SAMPLES\t64\n\nstatic int probabilistic_test(struct device *dev,\n\tuint64_t first_pos, uint64_t last_pos, int *pfound_a_bad_block,\n\tuint64_t salt)\n{\n\tuint64_t gap;\n\tint i, n, is_linear;\n\n\tif (first_pos > last_pos)\n\t\tgoto not_found;\n\n\t/* Let g be the number of good blocks between\n\t *   @first_pos and @last_pos including them.\n\t * Let b be the number of bad and overwritten blocks between\n\t *   @first_pos and @last_pos including them.\n\t *\n\t * The probability Pr_g of sampling a good block at random between\n\t *\t@first_pos and @last_pos is Pr_g = g / (g + b), and\n\t *\tthe probability Pr_1b that among k block samples at least\n\t *\tone block is bad is Pr_1b = 1 - Pr_g^k.\n\t *\n\t * Assuming Pr_g <= 95% and k = 64, Pr_1b >= 96.2%.\n\t *\tThat is, with high probability (i.e. Pr_1b),\n\t *\tone can find at least a bad block with k samples\n\t *\twhen most blocks are good (Pr_g).\n\t */\n\n\t/* Test @samples. */\n\tgap = last_pos - first_pos + 1;\n\tis_linear = gap <= N_BLOCK_SAMPLES;\n\tn = is_linear ? gap : N_BLOCK_SAMPLES;\n\tfor (i = 0; i < n; i++) {\n\t\tuint64_t sample_pos = is_linear\n\t\t\t? first_pos + i\n\t\t\t: uint64_rand_range(first_pos, last_pos);\n\t\tint is_good;\n\n\t\tif (is_block_good(dev, sample_pos, &is_good, salt))\n\t\t\treturn true;\n\t\tif (!is_good) {\n\t\t\t/* Found a bad block. */\n\t\t\t*pfound_a_bad_block = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\nnot_found:\n\t*pfound_a_bad_block = false;\n\treturn false;\n}\n\nstatic int uint64_cmp(const void *pa, const void *pb)\n{\n\tconst uint64_t *pia = pa;\n\tconst uint64_t *pib = pb;\n\treturn *pia - *pib;\n}\n\nstatic int find_a_bad_block(struct device *dev,\n\tuint64_t left_pos, uint64_t *pright_pos, int *found_a_bad_block,\n\tuint64_t reset_pos, uint64_t cache_size_block, int need_reset,\n\tuint64_t salt)\n{\n\t/* We need to list all sampled blocks because\n\t * we need a sorted array; read the code to find the why.\n\t * If the sorted array were not needed, one could save the seed\n\t * of the random sequence and repeat the sequence to read the blocks\n\t * after writing them.\n\t */\n\tuint64_t samples[N_BLOCK_SAMPLES];\n\tuint64_t gap, prv_sample;\n\tint n, i;\n\n\tif (*pright_pos <= left_pos + 1)\n\t\tgoto not_found;\n\n\t/* The code below relies on the same analytical result derived\n\t * in probabilistic_test().\n\t */\n\n\t/* Fill up @samples. */\n\tgap = *pright_pos - left_pos - 1;\n\tif (gap <= N_BLOCK_SAMPLES) {\n\t\tn = gap;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tsamples[i] = left_pos + 1 + i;\n\n\t\t/* Write @samples. */\n\t\tif (write_blocks(dev, left_pos + 1, *pright_pos - 1, salt))\n\t\t\treturn true;\n\t} else {\n\t\tn = N_BLOCK_SAMPLES;\n\t\tfor (i = 0; i < n; i++)\n\t\t\tsamples[i] = uint64_rand_range(left_pos + 1,\n\t\t\t\t*pright_pos - 1);\n\n\t\t/* Sort entries of @samples to minimize reads.\n\t\t * As soon as one finds a bad block, one can stop and ignore\n\t\t * the remaining blocks because the found bad block is\n\t\t * the leftmost bad block.\n\t\t */\n\t\tqsort(samples, n, sizeof(uint64_t), uint64_cmp);\n\n\t\t/* Write @samples. */\n\t\tprv_sample = left_pos;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (samples[i] == prv_sample)\n\t\t\t\tcontinue;\n\t\t\tprv_sample = samples[i];\n\t\t\tif (write_blocks(dev, prv_sample, prv_sample, salt))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Reset. */\n\tif (high_level_reset(dev, reset_pos,\n\t\tcache_size_block, need_reset, salt))\n\t\treturn true;\n\n\t/* Test @samples. */\n\tprv_sample = left_pos;\n\tfor (i = 0; i < n; i++) {\n\t\tint is_good;\n\n\t\tif (samples[i] == prv_sample)\n\t\t\tcontinue;\n\n\t\tprv_sample = samples[i];\n\t\tif (is_block_good(dev, prv_sample, &is_good, salt))\n\t\t\treturn true;\n\t\tif (!is_good) {\n\t\t\t/* Found the leftmost bad block. */\n\t\t\t*pright_pos = prv_sample;\n\t\t\t*found_a_bad_block = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\nnot_found:\n\t*found_a_bad_block = false;\n\treturn false;\n}\n\n/* Both need to be a power of 2 and larger than, or equal to 2^block_order. */\n#define MIN_CACHE_SIZE_BYTE\t(1ULL << 20)\n#define MAX_CACHE_SIZE_BYTE\t(1ULL << 30)\n\nstatic int find_cache_size(struct device *dev,\n\tuint64_t left_pos, uint64_t *pright_pos, uint64_t *pcache_size_block,\n\tint *pneed_reset, int *pgood_drive, const uint64_t salt)\n{\n\tconst int block_order = dev_get_block_order(dev);\n\tuint64_t write_target = MIN_CACHE_SIZE_BYTE >> block_order;\n\tuint64_t final_write_target = MAX_CACHE_SIZE_BYTE >> block_order;\n\tuint64_t first_pos, last_pos, end_pos;\n\tint done;\n\n\t/*\n\t *\tBasis\n\t *\n\t * The key difference between the basis and the inductive step is\n\t * the fact that the basis always calls assess_reset_effect().\n\t * This difference is not for correctness, that is, one can remove it,\n\t * and fold the basis into the inductive step.\n\t * However, this difference is an important speedup because many\n\t * fake drives do not have permanent cache.\n\t */\n\n\tassert(write_target > 0);\n\tassert(write_target < final_write_target);\n\n\tlast_pos = end_pos = *pright_pos - 1;\n\t/* This convoluted test is needed because\n\t * the variables are unsigned.\n\t * In a simplified form, it tests the following:\n\t *\t*pright_pos - write_target > left_pos\n\t */\n\tif (*pright_pos > left_pos + write_target) {\n\t\tfirst_pos = *pright_pos - write_target;\n\t} else if (*pright_pos > left_pos + 1) {\n\t\t/* There's no room to write @write_target blocks,\n\t\t * so write what's possible.\n\t\t */\n\t\tfirst_pos = left_pos + 1;\n\t} else {\n\t\tgoto good;\n\t}\n\n\tif (write_blocks(dev, first_pos, last_pos, salt))\n\t\tgoto bad;\n\n\tif (assess_reset_effect(dev, pcache_size_block,\n\t\tpneed_reset, &done, first_pos, end_pos, salt))\n\t\tgoto bad;\n\tif (done) {\n\t\t*pright_pos = first_pos;\n\t\t*pgood_drive = false;\n\t\treturn false;\n\t}\n\n\t/*\n\t *\tInductive step\n\t */\n\n\twhile (write_target < final_write_target) {\n\t\tint found_a_bad_block;\n\n\t\twrite_target <<= 1;\n\t\tlast_pos = first_pos - 1;\n\t\tif (first_pos > left_pos + write_target)\n\t\t\tfirst_pos -= write_target;\n\t\telse if (first_pos > left_pos + 1)\n\t\t\tfirst_pos = left_pos + 1;\n\t\telse\n\t\t\tbreak; /* Cannot write any further. */\n\n\t\t/* Write @write_target blocks before\n\t\t * the previously written blocks.\n\t\t */\n\t\tif (write_blocks(dev, first_pos, last_pos, salt))\n\t\t\tgoto bad;\n\n\t\tif (probabilistic_test(dev, first_pos, end_pos,\n\t\t\t&found_a_bad_block, salt))\n\t\t\tgoto bad;\n\t\tif (found_a_bad_block) {\n\t\t\tif (assess_reset_effect(dev, pcache_size_block,\n\t\t\t\tpneed_reset, &done, first_pos, end_pos, salt))\n\t\t\t\tgoto bad;\n\t\t\tassert(done);\n\t\t\t*pright_pos = first_pos;\n\t\t\t*pgood_drive = false;\n\t\t\treturn false;\n\t\t}\n\t}\n\ngood:\n\t*pright_pos = end_pos + 1;\n\t*pcache_size_block = 0;\n\t*pneed_reset = false;\n\t*pgood_drive = true;\n\treturn false;\n\nbad:\n\t/* *pright_pos does not change. */\n\t*pcache_size_block = 0;\n\t*pneed_reset = false;\n\t*pgood_drive = false;\n\treturn true;\n}\n\nstatic int find_wrap(struct device *dev,\n\tuint64_t left_pos, uint64_t *pright_pos,\n\tuint64_t reset_pos, uint64_t cache_size_block, int need_reset,\n\tuint64_t salt)\n{\n\tuint64_t offset, high_bit, pos = left_pos + 1;\n\tint is_good, block_order;\n\n\t/*\n\t *\tBasis\n\t */\n\n\t/* Make sure that there is at least a good block at the beginning\n\t * of the drive.\n\t */\n\n\tif (pos >= *pright_pos)\n\t\treturn false;\n\n\tif (write_blocks(dev, pos, pos, salt) ||\n\t\thigh_level_reset(dev, reset_pos,\n\t\t\tcache_size_block, need_reset, salt) ||\n\t\tis_block_good(dev, pos, &is_good, salt) ||\n\t\t!is_good)\n\t\treturn true;\n\n\t/*\n\t *\tInductive step\n\t */\n\n\tblock_order = dev_get_block_order(dev);\n\toffset = pos << block_order;\n\thigh_bit = clp2(pos);\n\tif (high_bit <= pos)\n\t\thigh_bit <<= 1;\n\tpos += high_bit;\n\n\twhile (pos < *pright_pos) {\n\t\tchar stack[align_head(block_order) + (1 << block_order)];\n\t\tchar *probe_blk = align_mem(stack, block_order);\n\t\tuint64_t found_offset;\n\n\t\tif (dev_read_blocks(dev, probe_blk, pos, pos) &&\n\t\t\tdev_read_blocks(dev, probe_blk, pos, pos))\n\t\t\treturn true;\n\n\t\tif (!validate_buffer_with_block(probe_blk, block_order,\n\t\t\t&found_offset, salt) &&\n\t\t\tfound_offset == offset) {\n\t\t\t*pright_pos = high_bit;\n\t\t\treturn false;\n\t\t}\n\n\t\thigh_bit <<= 1;\n\t\tpos = high_bit + left_pos + 1;\n\t}\n\n\treturn false;\n}\n\nuint64_t probe_device_max_blocks(struct device *dev)\n{\n\tconst int block_order = dev_get_block_order(dev);\n\tuint64_t num_blocks = dev_get_size_byte(dev) >> block_order;\n\tint n = ceiling_log2(num_blocks);\n\n\t/* Make sure that there is no overflow in the formula below.\n\t * The number 10 is arbitrary here, that is, it's not tight.\n\t */\n\tassert(MAX_N_BLOCK_ORDER < 8*sizeof(int) - 10);\n\n\treturn\n\t\t/* find_cache_size() */\n\t\t(MAX_CACHE_SIZE_BYTE >> (block_order - 1)) +\n\t\t/* find_wrap() */\n\t\t1 +\n\t\t/* The number below is just an educated guess. */\n\t\t128 * (\n\t\t\t/* bisect()\n\t\t\t *\n\t\t\t * The number of used blocks is (p * w); see comments\n\t\t\t * in estimate_n_bisect_blocks() for the definition of\n\t\t\t * the variables.\n\t\t\t *\n\t\t\t * p * w = n/m * (2^m - 1) < n/m * 2^m = n * (2^m / m)\n\t\t\t *\n\t\t\t * Let f(m) be 2^m / m. One can prove that\n\t\t\t * f(m + 1) >= f(m) for all m >= 1.\n\t\t\t * Therefore, the following bound is true.\n\t\t\t *\n\t\t\t * p * w < n * f(max_m)\n\t\t\t */\n\t\t\t((n << MAX_N_BLOCK_ORDER) / MAX_N_BLOCK_ORDER) +\n\t\t\t/* find_a_bad_block() */\n\t\t\tN_BLOCK_SAMPLES\n\t\t);\n}\n\nint probe_device(struct device *dev, uint64_t *preal_size_byte,\n\tuint64_t *pannounced_size_byte, int *pwrap,\n\tuint64_t *pcache_size_block, int *pneed_reset, int *pblock_order)\n{\n\tconst uint64_t dev_size_byte = dev_get_size_byte(dev);\n\tconst int block_order = dev_get_block_order(dev);\n\tstruct bisect_stats stats;\n\tuint64_t salt, cache_size_block;\n\tuint64_t left_pos, right_pos, mid_drive_pos, reset_pos;\n\tint need_reset, good_drive, wrap, found_a_bad_block;\n\n\tassert(block_order <= 20);\n\n\t/* @left_pos must point to a good block.\n\t * We just point to the last block of the first 1MB of the card\n\t * because this region is reserved for partition tables.\n\t *\n\t * Given that all writing is confined to the interval\n\t * (@left_pos, @right_pos), we avoid losing the partition table.\n\t */\n\tleft_pos = (1ULL << (20 - block_order)) - 1;\n\n\t/* @right_pos must point to a bad block.\n\t * We just point to the block after the very last block.\n\t */\n\tright_pos = dev_size_byte >> block_order;\n\n\t/* @left_pos cannot be equal to @right_pos since\n\t * @left_pos points to a good block, and @right_pos to a bad block.\n\t */\n\tif (left_pos >= right_pos) {\n\t\tcache_size_block = 0;\n\t\tneed_reset = false;\n\t\tgoto bad;\n\t}\n\n\t/* I, Michel Machado, define that any drive with less than\n\t * this number of blocks is fake.\n\t */\n\tmid_drive_pos = clp2(right_pos / 2);\n\n\tassert(left_pos < mid_drive_pos);\n\tassert(mid_drive_pos < right_pos);\n\n\t/* This call is needed due to rand(). */\n\tsrand(time(NULL));\n\n\tsalt = uint64_rand();\n\n\tif (find_cache_size(dev, mid_drive_pos - 1, &right_pos,\n\t\t&cache_size_block, &need_reset, &good_drive, salt))\n\t\tgoto bad;\n\tassert(mid_drive_pos <= right_pos);\n\treset_pos = right_pos;\n\n\tif (find_wrap(dev, left_pos, &right_pos,\n\t\treset_pos, cache_size_block, need_reset, salt))\n\t\tgoto bad;\n\twrap = ceiling_log2(right_pos << block_order);\n\n\tinit_bisect_stats(&stats);\n\tif (!good_drive) {\n\t\tif (mid_drive_pos < right_pos)\n\t\t\tright_pos = mid_drive_pos;\n\t\tif (bisect(dev, &stats, left_pos, &right_pos,\n\t\t\treset_pos, cache_size_block, need_reset, salt))\n\t\t\tgoto bad;\n\t}\n\n\tdo {\n\t\tif (find_a_bad_block(dev, left_pos, &right_pos,\n\t\t\t&found_a_bad_block, reset_pos, cache_size_block,\n\t\t\tneed_reset, salt))\n\t\t\tgoto bad;\n\n\t\tif (found_a_bad_block &&\n\t\t\tbisect(dev, &stats, left_pos, &right_pos,\n\t\t\t\treset_pos, cache_size_block, need_reset, salt))\n\t\t\tgoto bad;\n\t} while (found_a_bad_block);\n\n\tif (right_pos == left_pos + 1) {\n\t\t/* Bad drive. */\n\t\tright_pos = 0;\n\t}\n\n\t*preal_size_byte = right_pos << block_order;\n\t*pwrap = wrap;\n\tgoto out;\n\nbad:\n\t*preal_size_byte = 0;\n\t*pwrap = ceiling_log2(dev_size_byte);\n\nout:\n\t*pannounced_size_byte = dev_size_byte;\n\t*pcache_size_block = cache_size_block;\n\t*pneed_reset = need_reset;\n\t*pblock_order = block_order;\n\treturn false;\n}\n"
        },
        {
          "name": "libprobe.h",
          "type": "blob",
          "size": 0.3515625,
          "content": "#ifndef HEADER_LIBPROBE_H\n#define HEADER_LIBPROBE_H\n\n#include <stdint.h>\n\n#include \"libdevs.h\"\n\nuint64_t probe_device_max_blocks(struct device *dev);\n\nint probe_device(struct device *dev, uint64_t *preal_size_byte,\n\tuint64_t *pannounced_size_byte, int *pwrap,\n\tuint64_t *pcache_size_block, int *pneed_reset, int *pblock_order);\n\n#endif\t/* HEADER_LIBPROBE_H */\n"
        },
        {
          "name": "libutils.c",
          "type": "blob",
          "size": 4.6767578125,
          "content": "#include <stdio.h>\t/* For fprintf().\t*/\n#include <stdlib.h>\t/* For strtoll().\t*/\n#include <stdbool.h>\n#include <assert.h>\n\n#include \"libutils.h\"\n#include \"version.h\"\n\n/* Count the number of 1 bits. */\nstatic int pop(uint64_t x)\n{\n\tint n = 0;\n\twhile (x) {\n\t\tn++;\n\t\tx = x & (x - 1);\n\t}\n\treturn n;\n}\n\nint ilog2(uint64_t x)\n{\n\tx = x | (x >>  1);\n\tx = x | (x >>  2);\n\tx = x | (x >>  4);\n\tx = x | (x >>  8);\n\tx = x | (x >> 16);\n\tx = x | (x >> 32);\n\treturn pop(x) - 1;\n}\n\nuint64_t clp2(uint64_t x)\n{\n\tx = x - 1;\n\tx = x | (x >>  1);\n\tx = x | (x >>  2);\n\tx = x | (x >>  4);\n\tx = x | (x >>  8);\n\tx = x | (x >> 16);\n\tx = x | (x >> 32);\n\treturn x + 1;\n}\n\nconst char *adjust_unit(double *ptr_bytes)\n{\n\tconst char *units[] = { \"Byte\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" };\n\tint i = 0;\n\tdouble final = *ptr_bytes;\n\n\twhile (i < 7 && final >= 1024) {\n\t\tfinal /= 1024;\n\t\ti++;\n\t}\n\t*ptr_bytes = final;\n\treturn units[i];\n}\n\n#define USEC_IN_A_MSEC\t1000ULL\n#define USEC_IN_A_SEC\t(1000*USEC_IN_A_MSEC)\n#define USEC_IN_A_MIN\t(60*USEC_IN_A_SEC)\n#define USEC_IN_AN_HOUR\t(60*USEC_IN_A_MIN)\n#define USEC_IN_A_DAY\t(24*USEC_IN_AN_HOUR)\n\nint usec_to_str(uint64_t usec, char *str)\n{\n\tint has_d, has_h, has_m, has_s;\n\tlldiv_t div;\n\tint c, tot = 0;\n\n\thas_d = usec >= USEC_IN_A_DAY;\n\tif (has_d) {\n\t\tdiv = lldiv(usec, USEC_IN_A_DAY);\n\t\tusec = div.rem;\n\t\tc = sprintf(str + tot, \"%i days\", (int)div.quot);\n\t\tassert(c > 0);\n\t\ttot += c;\n\t}\n\n\thas_h = usec >= USEC_IN_AN_HOUR;\n\tif (has_h) {\n\t\tdiv = lldiv(usec, USEC_IN_AN_HOUR);\n\t\tusec = div.rem;\n\t\tc = sprintf(str + tot, \"%s%i:\",\n\t\t\thas_d ? \" \" : \"\", (int)div.quot);\n\t\tassert(c > 0);\n\t\ttot += c;\n\t}\n\n\thas_m = has_h || usec >= USEC_IN_A_MIN;\n\tif (has_m) {\n\t\tdiv = lldiv(usec, USEC_IN_A_MIN);\n\t\tusec = div.rem;\n\t\tif (has_h)\n\t\t\tc = sprintf(str + tot, \"%02i\", (int)div.quot);\n\t\telse\n\t\t\tc = sprintf(str + tot, \"%i'\", (int)div.quot);\n\t\tassert(c > 0);\n\t\ttot += c;\n\t}\n\n\thas_s = usec >= USEC_IN_A_SEC;\n\tif (has_s) {\n\t\tdiv = lldiv(usec, USEC_IN_A_SEC);\n\t\tusec = div.rem;\n\t\tif (has_h)\n\t\t\tc = sprintf(str + tot, \":%02i\", (int)div.quot);\n\t\telse if (has_m)\n\t\t\tc = sprintf(str + tot, \"%02i\\\"\", (int)div.quot);\n\t\telse if (has_d)\n\t\t\tc = sprintf(str + tot, \"%is\", (int)div.quot);\n\t\telse\n\t\t\tc = sprintf(str + tot, \"%i.%02is\", (int)div.quot,\n\t\t\t\t(int)(usec / (10 * USEC_IN_A_MSEC)));\n\t\tassert(c > 0);\n\t\ttot += c;\n\t}\n\n\tif (has_d || has_h || has_m || has_s)\n\t\treturn tot;\n\n\tif (usec >= USEC_IN_A_MSEC) {\n\t\tdiv = lldiv(usec, USEC_IN_A_MSEC);\n\t\tusec = div.rem;\n\t\tc = sprintf(str + tot, \"%i.%ims\", (int)div.quot,\n\t\t\t(int)(usec / 100));\n\t} else {\n\t\tc = sprintf(str + tot, \"%ius\", (int)usec);\n\t}\n\tassert(c > 0);\n\ttot += c;\n\n\treturn tot;\n}\n\nvoid *align_mem(void *p, int order)\n{\n\tuintptr_t ip = (uintptr_t)p;\n\tuintptr_t head = align_head(order);\n\treturn (void *)(   (ip + head) & ~head   );\n}\n\nvoid print_header(FILE *f, const char *name)\n{\n\tfprintf(f,\n\t\"F3 %s \" F3_STR_VERSION \"\\n\"\n\t\"Copyright (C) 2010 Digirati Internet LTDA.\\n\"\n\t\"This is free software; see the source for copying conditions.\\n\"\n\t\"\\n\", name);\n}\n\nlong long arg_to_ll_bytes(const struct argp_state *state,\n\tconst char *arg)\n{\n\tchar *end;\n\tlong long ll = strtoll(arg, &end, 0);\n\tif (end == arg)\n\t\targp_error(state, \"An integer must be provided\");\n\n\t/* Deal with units. */\n\tswitch (*end) {\n\tcase 's':\n\tcase 'S': /* Sectors */\n\t\tll <<= 9;\n\t\tend++;\n\t\tbreak;\n\n\tcase 'k':\n\tcase 'K': /* KB */\n\t\tll <<= 10;\n\t\tend++;\n\t\tbreak;\n\n\tcase 'm':\n\tcase 'M': /* MB */\n\t\tll <<= 20;\n\t\tend++;\n\t\tbreak;\n\n\tcase 'g':\n\tcase 'G': /* GB */\n\t\tll <<= 30;\n\t\tend++;\n\t\tbreak;\n\n\tcase 't':\n\tcase 'T': /* TB */\n\t\tll <<= 40;\n\t\tend++;\n\t\tbreak;\n\t}\n\n\tif (*end)\n\t\targp_error(state, \"`%s' is not an integer\", arg);\n\treturn ll;\n}\n\nstatic inline uint64_t next_random_number(uint64_t random_number)\n{\n\treturn random_number * 4294967311ULL + 17;\n}\n\nvoid fill_buffer_with_block(void *buf, int block_order, uint64_t offset,\n\tuint64_t salt)\n{\n\tuint64_t *int64_array = buf;\n\tint i, num_int64 = 1 << (block_order - 3);\n\tuint64_t random_number = offset ^ salt;\n\n\tassert(block_order >= 9);\n\n\t/* The offset is known by drives,\n\t * so one doesn't have to encrypt it.\n\t * Please don't add @salt here!\n\t */\n\tint64_array[0] = offset;\n\n\t/* Thanks to @salt, a drive has to guess the seed. */\n\tfor (i = 1; i < num_int64; i++)\n\t\tint64_array[i] = random_number =\n\t\t\tnext_random_number(random_number);\n}\n\nint validate_buffer_with_block(const void *buf, int block_order,\n\tuint64_t *pfound_offset, uint64_t salt)\n{\n\tconst uint64_t *int64_array = buf;\n\tint i, num_int64 = 1 << (block_order - 3);\n\tuint64_t found_offset = int64_array[0];\n\tuint64_t random_number = found_offset ^ salt;\n\n\tassert(block_order >= 9);\n\n\tfor (i = 1; i < num_int64; i++) {\n\t\trandom_number = next_random_number(random_number);\n\t\tif (int64_array[i] != random_number)\n\t\t\treturn true;\n\t}\n\n\t*pfound_offset = found_offset;\n\treturn false;\n}\n"
        },
        {
          "name": "libutils.h",
          "type": "blob",
          "size": 1.658203125,
          "content": "#ifndef HEADER_LIBUTILS_H\n#define HEADER_LIBUTILS_H\n\n#include <stdint.h>\n#include <argp.h>\t/* For struct argp_state.\t*/\n#include <sys/time.h>\t/* For struct timeval.\t\t*/\n\n#define UNUSED(x)\t((void)x)\n\nint ilog2(uint64_t x);\n\n/* Least power of 2 greater than or equal to x. */\nuint64_t clp2(uint64_t x);\n\nstatic inline int ceiling_log2(uint64_t x)\n{\n\treturn ilog2(clp2(x));\n}\n\nconst char *adjust_unit(double *ptr_bytes);\n\n#define TIME_STR_SIZE\t128\n\nint usec_to_str(uint64_t usec, char *str);\n\n/*\n * The functions align_head() and align_mem() are used to align pointers.\n *\n * The following example allocates two block on stack and makes sure that\n * the blocks are aligned with the block size.\n *\n *\t// The number 2 below means two blocks.\n *\tchar stack[align_head(block_order) + (2 << block_order)];\n *\tchar *stamp_blk, *probe_blk;\n *\tstamp_blk = align_mem(stack, block_order);\n *\tprobe_blk = stamp_blk + block_size;\n */\n\nstatic inline int align_head(int order)\n{\n\treturn (1 << order) - 1;\n}\n\nvoid *align_mem(void *p, int order);\n\nvoid print_header(FILE *f, const char *name);\n\nlong long arg_to_ll_bytes(const struct argp_state *state, const char *arg);\n\n/* Dependent on the byte order of the processor (i.e. endianness). */\nvoid fill_buffer_with_block(void *buf, int block_order, uint64_t offset,\n\tuint64_t salt);\n\n/* Dependent on the byte order of the processor (i.e. endianness). */\nint validate_buffer_with_block(const void *buf, int block_order,\n\tuint64_t *pfound_offset, uint64_t salt);\n\nstatic inline uint64_t diff_timeval_us(const struct timeval *t1,\n\tconst struct timeval *t2)\n{\n\treturn (t2->tv_sec - t1->tv_sec) * 1000000ULL +\n\t\tt2->tv_usec - t1->tv_usec;\n}\n\n#endif\t/* HEADER_LIBUTILS_H */\n"
        },
        {
          "name": "log-f3wr",
          "type": "blob",
          "size": 0.16796875,
          "content": "#!/usr/bin/env bash\nLOG=$1\n$(dirname $0)/f3write \"${@:2}\" 2>&1 | tee -a \"${LOG}\" && \\\necho -e \"\\n\\n\" >> \"${LOG}\" && \\\n$(dirname $0)/f3read  \"${@:2}\" 2>&1 | tee -a \"${LOG}\"\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 5.3466796875,
          "content": "#define _GNU_SOURCE\n\n#if __APPLE__ && __MACH__\n\n#define _DARWIN_C_SOURCE\n\n#include <fcntl.h>\t/* For fcntl().\t*/\n\n#endif\t/* Apple Macintosh */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <errno.h>\n#include <err.h>\n#include <unistd.h>\n\n#include \"version.h\"\n#include \"utils.h\"\n\nvoid adjust_dev_path(const char **dev_path)\n{\n\tif (chdir(*dev_path)) {\n\t\terr(errno, \"Can't change working directory to %s at %s()\", *dev_path, __func__);\n\t}\n\t*dev_path = \".\";\n\n\tif (!chroot(*dev_path)) {\n\t\tassert(!chdir(\"/\"));\n\t} else if (errno != EPERM) {\n\t\terr(errno, \"Can't change root directory to %s at %s()\", *dev_path, __func__);\n\t}\n}\n\nconst char *adjust_unit(double *ptr_bytes)\n{\n\tconst char *units[] = { \"Byte\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" };\n\tint i = 0;\n\tdouble final = *ptr_bytes;\n\n\twhile (i < 7 && final >= 1024) {\n\t\tfinal /= 1024;\n\t\ti++;\n\t}\n\t*ptr_bytes = final;\n\treturn units[i];\n}\n\nint is_my_file(const char *filename)\n{\n\tconst char *p = filename;\n\n\tif (!p || !isdigit(*p))\n\t\treturn 0;\n\n\t/* Skip digits. */\n\tdo {\n\t\tp++;\n\t} while (isdigit(*p));\n\n\treturn\t(p[0] == '.') && (p[1] == 'h') && (p[2] == '2') &&\n\t\t(p[3] == 'w') && (p[4] == '\\0');\n}\n\nchar *full_fn_from_number(const char **filename, const char *path, long num)\n{\n\tchar *str;\n\tassert(asprintf(&str, \"%s/%li.h2w\", path, num + 1) > 0);\n\t*filename = str + strlen(path) + 1;\n\treturn str;\n}\n\nstatic long number_from_filename(const char *filename)\n{\n\tconst char *p;\n\tlong num;\n\n\tassert(is_my_file(filename));\n\n\tp = filename;\n\tnum = 0;\n\tdo {\n\t\tnum = num * 10 + (*p - '0');\n\t\tp++;\n\t} while (isdigit(*p));\n\n\treturn num - 1;\n}\n\nstatic inline bool include_this_file(const char *filename,\n\tlong start_at, long end_at, long *number)\n{\n\tif (!is_my_file(filename))\n\t\treturn false;\n\n\t*number = number_from_filename(filename);\n\n\treturn start_at <= *number && *number <= end_at;\n}\n\nstatic long count_files(const char *path, long start_at, long end_at)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *entry;\n\tlong dummy, total = 0;\n\n\tif (!dir)\n\t\terr(errno, \"Can't open path %s at %s()\", path, __func__);\n\n\tentry = readdir(dir);\n\twhile (entry) {\n\t\tif (include_this_file(entry->d_name, start_at, end_at, &dummy))\n\t\t\ttotal++;\n\t\tentry = readdir(dir);\n\t}\n\tclosedir(dir);\n\n\treturn total;\n}\n\n/* Don't call this function directly, use ls_my_files() instead. */\nstatic long *__ls_my_files(const char *path, long start_at, long end_at,\n\tlong *pcount)\n{\n\tlong total_files = count_files(path, start_at, end_at);\n\tDIR *dir;\n\tstruct dirent *entry;\n\tlong *ret, index;\n\n\tassert(total_files >= 0);\n\tret = malloc(sizeof(*ret) * (total_files + 1));\n\tassert(ret);\n\n\tdir = opendir(path);\n\tif (!dir)\n\t\terr(errno, \"Can't open path %s at %s()\", path, __func__);\n\n\tentry = readdir(dir);\n\tindex = 0;\n\twhile (entry) {\n\t\tlong number;\n\t\tif (include_this_file(entry->d_name, start_at, end_at,\n\t\t\t\t&number)) {\n\t\t\tif (index >= total_files) {\n\t\t\t\t/* The folder @path received more files\n\t\t\t\t * before we finished scanning it.\n\t\t\t\t */\n\t\t\t\tclosedir(dir);\n\t\t\t\tfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret[index++] = number;\n\t\t}\n\n\t\tentry = readdir(dir);\n\t}\n\tclosedir(dir);\n\n\tret[index] = -1;\n\t*pcount = index;\n\treturn ret;\n}\n\n/* To be used with qsort(3). */\nstatic int cmpintp(const void *p1, const void *p2)\n{\n\treturn *(const long *)p1 - *(const long *)p2;\n}\n\nconst long *ls_my_files(const char *path, long start_at, long end_at)\n{\n\tlong *ret, my_count;\n\n\tdo {\n\t\tret = __ls_my_files(path, start_at, end_at, &my_count);\n\t} while (!ret);\n\n\tqsort(ret, my_count, sizeof(*ret), cmpintp);\n\treturn ret;\n}\n\nlong arg_to_long(const struct argp_state *state, const char *arg)\n{\n\tchar *end;\n\tlong l = strtol(arg, &end, 0);\n\tif (!arg)\n\t\targp_error(state, \"An integer must be provided\");\n\tif (!*arg || *end)\n\t\targp_error(state, \"`%s' is not an integer\", arg);\n\treturn l;\n}\n\nvoid print_header(FILE *f, const char *name)\n{\n\tfprintf(f,\n\t\"F3 %s \" F3_STR_VERSION \"\\n\"\n\t\"Copyright (C) 2010 Digirati Internet LTDA.\\n\"\n\t\"This is free software; see the source for copying conditions.\\n\"\n\t\"\\n\", name);\n}\n\n#if __APPLE__ && __MACH__\n\n/* This function is a _rough_ approximation of fdatasync(2). */\nint fdatasync(int fd)\n{\n\treturn fcntl(fd, F_FULLFSYNC);\n}\n\n/* This function is a _rough_ approximation of posix_fadvise(2). */\nint posix_fadvise(int fd, off_t offset, off_t len, int advice)\n{\n\tUNUSED(offset);\n\tUNUSED(len);\n\tswitch (advice) {\n\tcase POSIX_FADV_SEQUENTIAL:\n\t\treturn fcntl(fd, F_RDAHEAD, 1);\n\tcase POSIX_FADV_DONTNEED:\n\t\treturn fcntl(fd, F_NOCACHE, 1);\n\tdefault:\n\t\tassert(0);\n\t}\n}\n\n#endif\t/* Apple Macintosh */\n\n#if (__APPLE__ && __MACH__) || defined(__OpenBSD__)\n\nvoid msleep(double wait_ms)\n{\n\tassert(!usleep(wait_ms * 1000));\n}\n\n#else\t/* Apple Macintosh / OpenBSD */\n\n#include <time.h> /* For clock_gettime() and clock_nanosleep(). */\n\nvoid msleep(double wait_ms)\n{\n\tstruct timespec req;\n\tint ret;\n\n\tassert(!clock_gettime(CLOCK_MONOTONIC, &req));\n\n\t/* Add @wait_ms to @req. */\n\tif (wait_ms > 1000) {\n\t\ttime_t sec = wait_ms / 1000;\n\t\twait_ms -= sec * 1000;\n\t\tassert(wait_ms > 0);\n\t\treq.tv_sec += sec;\n\t}\n\treq.tv_nsec += wait_ms * 1000000;\n\n\t/* Round @req up. */\n\tif (req.tv_nsec >= 1000000000) {\n\t\tldiv_t result = ldiv(req.tv_nsec, 1000000000);\n\t\treq.tv_sec += result.quot;\n\t\treq.tv_nsec = result.rem;\n\t}\n\n\tdo {\n\t\tret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME,\n\t\t\t&req, NULL);\n\t} while (ret == EINTR);\n\n\tassert(ret == 0);\n}\n\n#endif\t/* Apple Macintosh / OpenBSD */\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 1.9833984375,
          "content": "#ifndef HEADER_UTILS_H\n#define HEADER_UTILS_H\n\n#include <stdio.h>\t/* For type FILE.\t\t*/\n#include <sys/time.h>\t/* For struct timeval.\t\t*/\n#include <stdint.h>\t/* For type uint64_t.\t\t*/\n#include <argp.h>\t/* For struct argp_state.\t*/\n\n#define SECTOR_SIZE (512)\n#define GIGABYTES   (1024 * 1024 * 1024)\n\nvoid adjust_dev_path(const char **dev_path);\n\nconst char *adjust_unit(double *ptr_bytes);\n\n/* Return true if @filename matches the regex /^[0-9]+\\.h2w$/ */\nint is_my_file(const char *filename);\n\n/* Caller must free(3) the returned pointer. */\nchar *full_fn_from_number(const char **filename, const char *path, long num);\n\nstatic inline int64_t delay_ms(const struct timeval *t1,\n\tconst struct timeval *t2)\n{\n\treturn (int64_t)(t2->tv_sec  - t1->tv_sec)  * 1000 +\n\t\t\t(t2->tv_usec - t1->tv_usec) / 1000;\n}\n\nvoid msleep(double wait_ms);\n\nconst long *ls_my_files(const char *path, long start_at, long end_at);\n\nvoid print_header(FILE *f, const char *name);\n\nstatic inline uint64_t random_number(uint64_t prv_number)\n{\n\treturn prv_number * 4294967311ULL + 17;\n}\n\n#define UNUSED(x)\t((void)x)\n\nlong arg_to_long(const struct argp_state *state, const char *arg);\n\n#if __APPLE__ && __MACH__\n\n#include <unistd.h>\t/* For type off_t.\t*/\n\n#define POSIX_FADV_SEQUENTIAL\t2 /* Expect sequential page references.\t*/\n#define POSIX_FADV_DONTNEED\t4 /* Don't need these pages.\t\t*/\n\nint fdatasync(int fd);\nint posix_fadvise(int fd, off_t offset, off_t len, int advice);\n\n#endif\t/* Apple Macintosh */\n\n#ifdef __FreeBSD__\n#define fdatasync(fd) fsync(fd)\n#endif\n\n#ifdef __OpenBSD__\n\n#define POSIX_FADV_SEQUENTIAL\t2 /* Expect sequential page references.\t*/\n#define POSIX_FADV_DONTNEED\t4 /* Don't need these pages.\t\t*/\n\n/*\n * OpenBSD doesn't have posix_fadvise() (...).\n * There is some code [in F3] to emulate posix_fadvise for MacOS\n * but it uses various fcntl(2) commands that we don't have [in OpenBSD].\n *\n *  -- Stuart Henderson, OpenBSD developer\n */\n#define posix_fadvise(fd, offset, len, advice) (0)\n\n#endif\t/* OpenBSD */\n\n#endif\t/* HEADER_UTILS_H */\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 0.1083984375,
          "content": "#ifndef HEADER_VERSION_H\n#define HEADER_VERSION_H\n\n#define F3_STR_VERSION\t\"8.0\"\n\n#endif\t/* HEADER_VERSION_H */\n"
        }
      ]
    }
  ]
}