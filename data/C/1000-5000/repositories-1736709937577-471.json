{
  "metadata": {
    "timestamp": 1736709937577,
    "page": 471,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "brendan-rius/c-jwt-cracker",
      "stars": 2418,
      "defaultBranch": "master",
      "files": [
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.408203125,
          "content": "FROM n0madic/alpine-gcc:9.2.0\nRUN apk add --quiet --no-cache libressl-dev \nCOPY ./*.h /opt/src/\nCOPY ./*.c /opt/src/\nCOPY Makefile /opt/src/\nCOPY entrypoint.sh /\n#RUN apt-get install libssl-dev\nWORKDIR /opt/src\nRUN make\nRUN make OPENSSL=/usr/local/opt/openssl/include OPENSSL_LIB=-L/usr/local/opt/openssl/lib\nRUN [\"chmod\", \"+x\", \"/entrypoint.sh\"]\nRUN [\"chmod\", \"+x\", \"/opt/src/jwtcrack\"]\nENTRYPOINT [\"/entrypoint.sh\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2017 Brendan Rius\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.33984375,
          "content": "CC\t= gcc\n\nOPENSSL = /usr/include/openssl\nOPENSSL_LIB = -lssl\n\nCFLAGS\t+= -I $(OPENSSL) -g -std=gnu99 -O3\nLDFLAGS\t+= $(OPENSSL_LIB) -lcrypto -lpthread\n\nNAME\t= jwtcrack\nSRCS\t= main.c base64.c\nOBJS\t= $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) -o $(NAME) $(OBJS) $(LDFLAGS)\n\nclean:\n\trm -f $(OBJS)\n\nfclean: clean\n\trm -f $(NAME)\n\nre: fclean all\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6728515625,
          "content": "# JWT cracker\n\nA multi-threaded JWT brute-force cracker written in C. If you are very lucky or have a huge computing power, this program should find the secret key of a JWT token, allowing you to forge valid tokens. This is for testing purposes only, do not put yourself in trouble :)\n\nI used the [Apple Base64 implementation](https://opensource.apple.com/source/QuickTimeStreamingServer/QuickTimeStreamingServer-452/CommonUtilitiesLib/base64.c) that I modified slightly.\n\n## Build a Docker Image\n```\ndocker build . -t jwtcrack\n\n```\n\n\n## Run on Docker\n```\ndocker run -it --rm  jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE\n```\n\n## Manual Compilation\n\nMake sure you have openssl's headers installed.\nOn Ubuntu you can install them with `apt-get install libssl-dev`\n\n```\nmake\n```\n\nIf you use a Mac, you can install OpenSSL with `brew install openssl`, but the headers will be stored in a\ndifferent location:\n\n```\nmake OPENSSL=/usr/local/opt/openssl/include OPENSSL_LIB=-L/usr/local/opt/openssl/lib\n```\n\n## Run\n\n```\n$ > ./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE\n```                                                              \n\n## Run with different HMAC functions\n\nThe following hash functions are supported for HMAC, i.e. to generate keyed-hashed message authentication codes: \"sha256\" for JSON HS256 (HMAC using SHA-256), \"sha384\" for HS384 and \"sha512\" for HS512, respectively. You can specify the name of any other hash function exactly as it is named in the OpenSSL. If OpenSSL allows this hash function to be used for HMAC, then jwtcrack will try to decode the secret. However, since jwtcrack is only a decoder, there is no guarantee that this algorithm was actually used for encoding, let alone among the list of algorithms allowed for the \"JSON Web Algorithms\" RFC. See section 3.1. of the RFC 7518 for more details.\n\nIn the following example, we use a sha256 hash function that corresponds to JSON HS256 (HMAC-SHA256), see the \"sha256\" as a last command line parameter. Also, in this example we specify maximum secret length of 5 characters, and limit the alphabet to the following characters: ABCSNFabcsnf1234\n\n```\n$ > ./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE ABCSNFabcsnf1234 5 sha256\n```\nIn the above example, the key is `Sn1f`, and it takes less than a second on an average notebook manufactured around 2019 (e.g. with an Intel CPU based on Ice Lake microarchitecture). GCC version 9.3.0 with \"-O3\" was used to compile the jwtcrack program. It was linked with the OpenSSL library version 1.1.1f under Linux Ubuntu 20.04.1 LTS.\n\nHere, in the next example, we use \"sha512\" as a last command line parameter to specify HS512 (HMAC-SHA512), we also specify maximum secret length of 9 characters, and limit the alphabet to the following seven lowercase latin characters: \"adimnps\".\n\n```\n$ > ./jwtcrack eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiYWRtaW4ifQ.RnWtv7Rjggm8LdMU3yLnz4ejgGAkIxoZwsCMuJlHMwTh7CJODDZWR8sVuNvo2ws25cbH9HWcp2n5WxpIZ9_v0g adimnps 9 sha512\n```\n\nIn the above example, the key is `adminpass`, and it takes about 15 seconds on average to decode on a notebook with Intel Core i7 1065G7 CPU on Ice Lake microarchitecture (2019), base frequency 1.30 GHz, max turbo 3.90 GHz). The combined number of CPU seconds consumed from each of the cores in the user mode due to multithreading is about 100 on average to decode that secret.\n\n\nExample of using \"sha384\":\n\n```\n$ > ./jwtcrack eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzM4NCJ9.eyJyb2xlIjoiYWRtaW4ifQ.31xCH3k8VRqB8l5qBy7RyqI2htyCskBy_4cIWpk3o43UkIMW-IcjTUEL_NyFXUWJ 0123456789 6 sha384\n```\n\n## Measurement of time consumed by jwtcrack\n\n```\n/usr/bin/time -f \"Total number of CPU-seconds consumed directly from each of the CPU cores: %U\\nElapsed real wall clock time used by the process: %E\" ./jwtcrack eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiYWRtaW4ifQ.RnWtv7Rjggm8LdMU3yLnz4ejgGAkIxoZwsCMuJlHMwTh7CJODDZWR8sVuNvo2ws25cbH9HWcp2n5WxpIZ9_v0g adimnps 9 sha512\n```\n\n## Contribute\n\n * No progress status\n * If you stop the program, you cannot start back where you were\n \n## IMPORTANT: Known bugs\n\nThe base64 implementation I use (from Apple) is sometimes buggy because not every Base64 implementation is the same.\nSo sometimes, decrypting of your Base64 token will only work partially and thus you will be able to find a secret to your token that is not the correct one.\n\nIf someone is willing to implement a more robust Base64 implementation, that would be great :)\n"
        },
        {
          "name": "base64.c",
          "type": "blob",
          "size": 7.791015625,
          "content": "/*\n * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.\n *\n * @APPLE_LICENSE_HEADER_START@\n * \n * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.\n * \n * This file contains Original Code and/or Modifications of Original Code\n * as defined in and that are subject to the Apple Public Source License\n * Version 2.0 (the 'License'). You may not use this file except in\n * compliance with the License. Please obtain a copy of the License at\n * http://www.opensource.apple.com/apsl/ and read it before using this\n * file.\n * \n * The Original Code and all software distributed under the License are\n * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER\n * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,\n * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.\n * Please see the License for the specific language governing rights and\n * limitations under the License.\n * \n * @APPLE_LICENSE_HEADER_END@\n */\n/* ====================================================================\n * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the Apache Group\n *    for use in the Apache HTTP server project (http://www.apache.org/).\"\n *\n * 4. The names \"Apache Server\" and \"Apache Group\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the Apache Group\n *    for use in the Apache HTTP server project (http://www.apache.org/).\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Group and was originally based\n * on public domain software written at the National Center for\n * Supercomputing Applications, University of Illinois, Urbana-Champaign.\n * For more information on the Apache Group and the Apache HTTP server\n * project, please see <http://www.apache.org/>.\n *\n */\n\n/* Base64 encoder/decoder. Originally Apache file ap_base64.c\n */\n\n#include <string.h>\n\n#include \"base64.h\"\n\n/* aaaack but it's fast and const should make it shared text page. */\nstatic const unsigned char pr2six[256] =\n{\n    /* ASCII table */\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 63,\n    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,\n    64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 63,\n    64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64\n};\n\nint Base64decode_len(const char *bufcoded)\n{\n    int nbytesdecoded;\n    register const unsigned char *bufin;\n    register int nprbytes;\n\n    bufin = (const unsigned char *) bufcoded;\n    while (pr2six[*(bufin++)] <= 63);\n\n    nprbytes = (bufin - (const unsigned char *) bufcoded) - 1;\n    nbytesdecoded = ((nprbytes + 3) / 4) * 3;\n\n    return nbytesdecoded + 1;\n}\n\nint Base64decode(char *bufplain, const char *bufcoded)\n{\n    int nbytesdecoded;\n    register const unsigned char *bufin;\n    register unsigned char *bufout;\n    register int nprbytes;\n\n    bufin = (const unsigned char *) bufcoded;\n    while (pr2six[*(bufin++)] <= 63);\n    nprbytes = (bufin - (const unsigned char *) bufcoded) - 1;\n    nbytesdecoded = ((nprbytes + 3) / 4) * 3;\n\n    bufout = (unsigned char *) bufplain;\n    bufin = (const unsigned char *) bufcoded;\n\n    while (nprbytes > 4) {\n    *(bufout++) =\n        (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);\n    *(bufout++) =\n        (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);\n    *(bufout++) =\n        (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);\n    bufin += 4;\n    nprbytes -= 4;\n    }\n\n    /* Note: (nprbytes == 1) would be an error, so just ingore that case */\n    if (nprbytes > 1) {\n    *(bufout++) =\n        (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);\n    }\n    if (nprbytes > 2) {\n    *(bufout++) =\n        (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);\n    }\n    if (nprbytes > 3) {\n    *(bufout++) =\n        (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);\n    }\n\n    *(bufout++) = '\\0';\n    nbytesdecoded -= (4 - nprbytes) & 3;\n    return nbytesdecoded;\n}\n\nstatic const char basis_64[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nint Base64encode_len(int len)\n{\n    return ((len + 2) / 3 * 4) + 1;\n}\n\nint Base64encode(char *encoded, const char *string, int len)\n{\n    int i;\n    char *p;\n\n    p = encoded;\n    for (i = 0; i < len - 2; i += 3) {\n    *p++ = basis_64[(string[i] >> 2) & 0x3F];\n    *p++ = basis_64[((string[i] & 0x3) << 4) |\n                    ((int) (string[i + 1] & 0xF0) >> 4)];\n    *p++ = basis_64[((string[i + 1] & 0xF) << 2) |\n                    ((int) (string[i + 2] & 0xC0) >> 6)];\n    *p++ = basis_64[string[i + 2] & 0x3F];\n    }\n    if (i < len) {\n    *p++ = basis_64[(string[i] >> 2) & 0x3F];\n    if (i == (len - 1)) {\n        *p++ = basis_64[((string[i] & 0x3) << 4)];\n    //    *p++ = '=';\n    }\n    else {\n        *p++ = basis_64[((string[i] & 0x3) << 4) |\n                        ((int) (string[i + 1] & 0xF0) >> 4)];\n        *p++ = basis_64[((string[i + 1] & 0xF) << 2)];\n    }\n    //*p++ = '=';\n    }\n\n    *p++ = '\\0';\n    return p - encoded;\n}\n"
        },
        {
          "name": "base64.h",
          "type": "blob",
          "size": 4.1435546875,
          "content": "/*\n * Copyright (c) 2003 Apple Computer, Inc. All rights reserved.\n *\n * @APPLE_LICENSE_HEADER_START@\n * \n * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.\n * \n * This file contains Original Code and/or Modifications of Original Code\n * as defined in and that are subject to the Apple Public Source License\n * Version 2.0 (the 'License'). You may not use this file except in\n * compliance with the License. Please obtain a copy of the License at\n * http://www.opensource.apple.com/apsl/ and read it before using this\n * file.\n * \n * The Original Code and all software distributed under the License are\n * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER\n * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,\n * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.\n * Please see the License for the specific language governing rights and\n * limitations under the License.\n * \n * @APPLE_LICENSE_HEADER_END@\n */\n/* ====================================================================\n * Copyright (c) 1995-1999 The Apache Group.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the Apache Group\n *    for use in the Apache HTTP server project (http://www.apache.org/).\"\n *\n * 4. The names \"Apache Server\" and \"Apache Group\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    apache@apache.org.\n *\n * 5. Products derived from this software may not be called \"Apache\"\n *    nor may \"Apache\" appear in their names without prior written\n *    permission of the Apache Group.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the Apache Group\n *    for use in the Apache HTTP server project (http://www.apache.org/).\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Group and was originally based\n * on public domain software written at the National Center for\n * Supercomputing Applications, University of Illinois, Urbana-Champaign.\n * For more information on the Apache Group and the Apache HTTP server\n * project, please see <http://www.apache.org/>.\n *\n */\n\n\n\n#ifndef _BASE64_H_\n#define _BASE64_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint Base64encode_len(int len);\nint Base64encode(char * coded_dst, const char *plain_src,int len_plain_src);\n\nint Base64decode_len(const char * coded_src);\nint Base64decode(char * plain_dst, const char *coded_src);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //_BASE64_H_\n"
        },
        {
          "name": "entrypoint.sh",
          "type": "blob",
          "size": 0.0322265625,
          "content": "#!/bin/bash\n/opt/src/jwtcrack $@\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 8.5078125,
          "content": "/*\n\nCopyright (c) 2017 Brendan Rius. All rights reserved\n\nConfigurable HMAC hash functions implemented in 2021 by Maxim Masiutin,\nsee the \"README.md\" file for more details.\n\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <openssl/evp.h>\n#include <openssl/hmac.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include \"base64.h\"\n\nchar *g_header_b64 = NULL; // Holds the Base64 header of the original JWT\nchar *g_payload_b64 = NULL; // Holds the Base64 payload of the original JWT\nchar *g_signature_b64 = NULL; // Holds the Base64 signature of the original JWT\nunsigned char *g_to_encrypt = NULL; // Holds the part of the JWT that needs to be hashed\nunsigned char *g_signature = NULL; // Holds the Base64 *decoded* signature of the original JWT\n\n// Some lengths of buffers. Useful to avoid computing it multiple times.\n// Also, not all strings used finish with a '\\0' for optimization purposes.\n// In that case, we need to have the length\nsize_t g_header_b64_len = 0;\nsize_t g_payload_b64_len = 0;\nsize_t g_signature_b64_len = 0;\nsize_t g_signature_len = 0;\nsize_t g_to_encrypt_len = 0;\n\n// The alphabet to use when brute-forcing\nchar *g_alphabet = NULL;\nsize_t g_alphabet_len = 0;\n\nchar *g_found_secret = NULL;\n\nstruct s_thread_data {\n    const EVP_MD *g_evp_md; // The hash function to apply the HMAC to\n\n    // Holds the computed signature at each iteration to compare it with the original\n    // signature\n    unsigned char *g_result;\n    unsigned int g_result_len;\n\n    char *g_buffer; // Holds the secret being constructed\n\n    char starting_letter; // Each thread is assigned a first letter\n    size_t max_len; // And tries combinations up to a certain length\n};\n\nvoid init_thread_data(struct s_thread_data *data, char starting_letter, size_t max_len, const EVP_MD *evp_md) {\n    data->max_len = max_len;\n    data->starting_letter = starting_letter;\n// The chosen hash function for HMAC\n    data->g_evp_md = evp_md;\n    // Allocate the buffer used to hold the calculated signature\n    data->g_result = malloc(EVP_MAX_MD_SIZE);\n    // Allocate the buffer used to hold the generated key\n    data->g_buffer = malloc(max_len + 1);\n}\n\nvoid destroy_thread_data(struct s_thread_data *data) {\n    free(data->g_result);\n    free(data->g_buffer);\n}\n\n/**\n * Check if the signature produced with \"secret\n * of size \"secrent_len\" (without the '\\0') matches the original\n * signature.\n * Return true if it matches, false otherwise\n */\nbool check(struct s_thread_data *data, const char *secret, size_t secret_len) {\n    // If the secret was found by another thread, stop this thread\n    if (g_found_secret != NULL) {\n        destroy_thread_data(data);\n        pthread_exit(NULL);\n    }\n\n\t// Hash the \"to_encrypt\" buffer using HMAC into the \"result\" buffer\n\tHMAC(\n\t\tdata->g_evp_md,\n\t\t(const unsigned char *) secret, secret_len,\n\t\t(const unsigned char *) g_to_encrypt, g_to_encrypt_len,\n\t\tdata->g_result, &(data->g_result_len)\n\t);\n\n\t// Compare the computed hash to the given decoded base64 signature.\n\t// If there is a match, we just found the key.\n\treturn memcmp(data->g_result, g_signature, g_signature_len) == 0;\n}\n\nbool brute_impl(struct s_thread_data *data, char* str, int index, int max_depth)\n{\n    for (int i = 0; i < g_alphabet_len; ++i)\n    {\n        // The character at \"index\" in \"str\" successvely takes the value\n        // of each symbol in the alphabet\n        str[index] = g_alphabet[i];\n\n        // If just changed the last letter, that means we generated a\n        // permutation, so we check it\n        if (index == max_depth - 1) {\n            // If we found the key, we return, otherwise we continue.\n            // By continuing, the current letter (at index \"index\")\n            // will be changed to the next symbol in the alphabet\n            if (check(data, (const char *) str, max_depth)) return true;\n        }\n        // If the letter we just changed was not the last letter of\n        // the permutation we are generating, recurse to change the\n        // letter at the next index.\n        else {\n            // If this condition is met, that means we found the key.\n            // Otherwise the loop will continue and change the current\n            // character to the next letter in the alphabet.\n\t\t\tif (brute_impl(data, str, index + 1, max_depth)) return true;\n        }\n    }\n\n    // If we are here, we tried all the permutations without finding a match\n\treturn false;\n}\n\n/**\n * Try all the combinations of secret starting with letter \"starting_letter\"\n * and stopping at a maximum length of \"max_len\"\n * Returns the key when there is a match, otherwise returns NULL\n */\nchar *brute_sequential(struct s_thread_data *data)\n{\n    // We set the starting letter\n    data->g_buffer[0] = data->starting_letter;\n    // Special case for len = 1, we check in this function\n    if (check(data, data->g_buffer, 1)) {\n        // If this thread found the solution, set the shared global variable\n        // so other threads stop, and stop the current thread. Congrats little\n        // thread!\n        g_found_secret = strndup(data->g_buffer, 1);\n        return g_found_secret;\n    }\n\n    // We start from length 2 (we handled the special case of length 1\n    // above.\n    for (size_t i = 2; i <= data->max_len; ++i) {\n      \tif (brute_impl(data, data->g_buffer, 1, i)) {\n            // If this thread found the solution, set the shared global variable\n            // so other threads stop, and stop the current thread. Congrats little\n            // thread!\n            g_found_secret = strndup(data->g_buffer, i);\n            return g_found_secret;\n        }\n    }\n\n   success:\n    \n\treturn NULL;\n}\n\nvoid usage(const char *cmd, const char *alphabet, const size_t max_len, const char *hmac_alg) {\n\tprintf(\"%s <token> [alphabet] [max_len] [hmac_alg]\\n\"\n\t\t\t\t   \"Defaults: \"\n\t\t\t\t   \"alphabet=%s, \"\n\t\t\t\t   \"max_len=%zd, \"\n\t\t\t\t   \"hmac_alg=%s\\n\", cmd, alphabet, max_len, hmac_alg);\n}\n\nint main(int argc, char **argv) {\n\n\tconst EVP_MD *evp_md;\n\tsize_t max_len = 6;\n\t\n\t// by default, use OpenSSL EVP_sha256 which corresponds to JSON HS256 (HMAC-SHA256)\n\tconst char *default_hmac_alg = \"sha256\";\n\n\tg_alphabet = \"eariotnslcudpmhgbfywkvxzjqEARIOTNSLCUDPMHGBFYWKVXZJQ0123456789\";\n\n\tif (argc < 2) {\n\t\tusage(argv[0], g_alphabet, max_len, default_hmac_alg);\n\t\treturn 1;\n\t}\n\n\t// Get the token\n\tchar *jwt = argv[1];\n\n\tif (argc > 2)\n\t\tg_alphabet = argv[2];\n\n\tif (argc > 3)\n\t{\n\t\tint i3 = atoi(argv[3]);\n\t\tif (i3 > 0)\n\t\t{\n\t\t\tmax_len = i3;\n\t\t} else\n\t\t{\n\t\t\tprintf(\"Invalid max_len value %s (%d), defaults to %zd\\n\", argv[3], i3, max_len);\n\t\t}\n\t}\n\n\tif (argc > 4)\n\t{\n\t\tevp_md = EVP_get_digestbyname(argv[4]);\n\t\tif (evp_md == NULL) \n\t\t\tprintf(\"Unknown message digest %s, will use default %s\\n\", argv[4], default_hmac_alg);\n\t} else\n\t{\n\t   evp_md = NULL; \n\t}\n\n\tif (evp_md == NULL) \n\t{\n\t\tevp_md = EVP_get_digestbyname(default_hmac_alg);\n\t\tif (evp_md == NULL) \n\t\t{\n\t\t\tprintf(\"Cannot initialize the default message digest %s, aborting\\n\", default_hmac_alg);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tg_alphabet_len = strlen(g_alphabet);\n\n\t// Split the JWT into header, payload and signature\n\tg_header_b64 = strtok(jwt, \".\");\n\tg_payload_b64 = strtok(NULL, \".\");\n\tg_signature_b64 = strtok(NULL, \".\");\n\tg_header_b64_len = strlen(g_header_b64);\n\tg_payload_b64_len = strlen(g_payload_b64);\n\tg_signature_b64_len = strlen(g_signature_b64);\n\n\t// Recreate the part that is used to create the signature\n\t// Since it will always be the same\n\tg_to_encrypt_len = g_header_b64_len + 1 + g_payload_b64_len;\n\tg_to_encrypt = (unsigned char *) malloc(g_to_encrypt_len + 1);\n\tsprintf((char *) g_to_encrypt, \"%s.%s\", g_header_b64, g_payload_b64);\n\n\t// Decode the signature\n\tg_signature_len = Base64decode_len((const char *) g_signature_b64);\n\tg_signature = malloc(g_signature_len);\n\t// We re-assign the length, because Base64decode_len returned us an approximation\n\t// of the size so we could malloc safely. But we need the real decoded size, which\n\t// is returned by this function\n\tg_signature_len = Base64decode((char *) g_signature, (const char *) g_signature_b64);\n\n\n    struct s_thread_data *pointers_data[g_alphabet_len];\n    pthread_t *tid = malloc(g_alphabet_len * sizeof(pthread_t));\n\n    for (size_t i = 0; i < g_alphabet_len; i++) {\n        pointers_data[i] = malloc(sizeof(struct s_thread_data));\n        init_thread_data(pointers_data[i], g_alphabet[i], max_len, evp_md);\n        pthread_create(&tid[i], NULL, (void *(*)(void *)) brute_sequential, pointers_data[i]);\n    }\n\n    for (size_t i = 0; i < g_alphabet_len; i++)\n        pthread_join(tid[i], NULL);\n\n\tif (g_found_secret == NULL)\n\t\tprintf(\"No solution found :-(\\n\");\n\telse\n\t\tprintf(\"Secret is \\\"%s\\\"\\n\", g_found_secret);\n\n    free(g_found_secret);\n    free(tid);\n\n\treturn 0;\n}\n"
        }
      ]
    }
  ]
}