{
  "metadata": {
    "timestamp": 1736709762053,
    "page": 194,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ptitSeb/box86",
      "stars": 3432,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0966796875,
          "content": "build/\nbuild*/\n.vscode\n.gdb_history\nsrc/git_head.h\nbackup/\nbox86_update.sh\nrestore_backup.sh\n.cache"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.8095703125,
          "content": "language: c\r\narch:\r\n  - arm64-graviton2\r\n  - amd64\r\nos: linux\r\ndist: focal\r\n\r\naddons:\r\n  apt:\r\n    packages:\r\n      - python3\r\n\r\ncompiler:\r\n    - gcc\r\n\r\n      #Build steps\r\nbefore_script:\r\n    - if [ \"$TRAVIS_CPU_ARCH\" = \"arm64\" ]; then sudo dpkg --add-architecture armhf ; else sudo dpkg --add-architecture i386 ; fi\r\n    - if [ \"$TRAVIS_CPU_ARCH\" = \"arm64\" ]; then sudo apt-get -y install gcc-arm-linux-gnueabihf ; else sudo apt-get -y install gcc-multilib libc6-dev:i386 libgcc1:i386 ; fi\r\n    - mkdir build\r\n    - cd build\r\n    - if [ \"$TRAVIS_CPU_ARCH\" = \"arm64\" ]; then cmake .. -DRK3399=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ; else CFLAGS=\"-m32\" cmake .. -DLD80BITS=1 -DNOALIGN=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ; fi\r\n\r\nscript:\r\n    - make\r\n    - if [ \"$TRAVIS_CPU_ARCH\" != \"arm64\" ]; then ctest --output-on-failure ; fi\r\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 46.85546875,
          "content": "cmake_minimum_required(VERSION 3.10)\n\noption(PANDORA \"Set to ON if targeting an OpenPandora device\" ${PANDORA})\noption(PYRA \"Set to ON if targeting an OpenPandora device\" ${PYRA})\noption(RPI2 \"Set to ON if targeting an RaspberryPI2 device\" ${RPI2})\noption(RPI3 \"Set to ON if targeting an RaspberryPI3 device\" ${RPI3})\noption(RPI4 \"Set to ON if targeting an RaspberryPI4 device\" ${RPI4})\noption(RPI3ARM64 \"Set to ON if targeting an RaspberryPI3 device with multiarch arm64 and armhf\" ${RPI3ARM64})\noption(RPI4ARM64 \"Set to ON if targeting an RaspberryPI4 device with multiarch arm64 and armhf\" ${RPI4ARM64})\noption(GOA_CLONE \"Set to ON if targeting GO Advance clones, like RG351p/v, Gameforce Chi, RGB10...\" ${GOA_CLONE})\noption(RK3288 \"Set to ON if targeting an Rockchip RK3288 based device\" ${RK3288})\noption(RK3399 \"Set to ON if targeting an Rockchip RK3399 based device\" ${RK3399})\noption(RK3588 \"Set to ON if targeting an Rockchip RK3588 / RK3588S based device\" ${RK3588})\noption(ODROIDN2 \"Set to ON if targeting an ODROID-N2 device\" ${ODROIDN2})\noption(TEGRAX1 \"Set to ON if targeting an Tegra X1 (ARM64) based device\" ${TEGRAX1})\noption(TEGRAX1ARM32 \"Set to ON if targeting an Tegra X1 (ARM32) based device\" ${TEGRAX1ARM32})\noption(TEGRA_T194 \"Set to ON if targeting an Tegra Xavier based device\" ${TEGRA_T194})\noption(TEGRA_T234 \"Set to ON if targeting an Tegra Orin based device\" ${TEGRA_T234})\noption(PHYTIUM \"Set to ON if targeting an Phytium (D2000 or FT2000/4) based device\" ${PHYTIUM})\noption(GAMESHELL \"Set to ON if targeting a GameShell device\" ${GAMESHELL})\noption(ODROIDXU4 \"Set to ON if targeting an ODROID-XU4 device\" ${ODROIDXU4})\noption(POWER9 \"Set to ON if targeting a POWER9 processor\" ${POWER9})\noption(SD845 \"Set to ON if targeting a Snapragon 845 based device\" ${SD845})\noption(SD865 \"Set to ON if targeting a Snapragon 865 based device\" ${SD865})\noption(SD888 \"Set to ON if targeting a Snapragon 888 based device\" ${SD888})\noption(ADLINK \"Set to ON if targeting an ADLink AmpereAltra based device\" ${ADLINK})\noption(A64 \"Set to ON if targeting an Allwinner A64 based device\" ${A64})\noption(ARM64 \"Set to ON if targeting a generic ARM64 based device\" ${ARM64})\noption(BAD_SIGNAL \"Set to ON to activate the workaround for incoherent si_info on SIGSEGV\" ${BAD_SIGNAL})\noption(LX2160A \"Set to ON if targeting an LX2160A based device\" ${LX2160A})\noption(ANDROID \"Set to ON if targeting an Android device\" ${ANDROID})\noption(TERMUX \"Set to ON if targeting an Android device with Termux\" ${TERMUX})\noption(USE_CCACHE \"Set to ON to use ccache if present in the system\" ${USE_CCACHE})\noption(HAVE_TRACE \"Set to ON to have Trace ability (needs ZydisInfo library)\" ${HAVE_TRACE})\noption(NOLOADADDR \"Set to ON to avoid fixing the load address of Box86\" ${NO_LOADAADR})\noption(NOGETCLOCK \"Set to ON to avoid using clock_gettime with CLOCK_MONOTONIC_COARSE for RDTSC opcode (use gltimeofday instead)\" ${NOGETCLOCK})\noption(NOGIT \"Set to ON if not building from a git clone repo (like when building from a zip download from github)\" ${NOGIT})\noption(NO_LIB_INSTALL \"Set ON to not install a few x86 libs that are used by many program\" ${NO_LIB_INSTALL})\noption(NO_CONF_INSTALL \"Set ON to not install config files\" ${NO_CONF_INSTALL})\n\nif(PANDORA OR PYRA OR RPI2 OR RPI3 OR RPI4 OR GAMESHELL OR ODROIDXU4 OR GOA_CLONE OR RK3288 OR RK3399 OR ODROIDN2 OR TEGRAX1 OR TEGRAX1ARM32 OR TEGRA_T194 OR TEGRA_T234 OR RPI3ARM64 OR RPI4ARM64 OR PHYTIUM OR SD845 OR SD865 OR SD888 OR ADLINK OR A64 OR LX2160A OR ARM64 OR RK3588)\n    set(LD80BITS OFF CACHE BOOL \"\")\n    set(NOALIGN OFF CACHE BOOL \"\")\n    set(ARM_DYNAREC ON CACHE BOOL \"\")\n    if(RK3588)\n        set(BAD_SIGNAL ON CACHE BOOL \"\")\n    endif()\nendif()\nif(TERMUX)\n    set(ANDROID ON CACHE BOOL \"\")\n    set(TERMUX_PATH \"/data/data/com.termux/files\")\nendif()\nif(ANDROID)\n    set(NOLOADADDR ON CACHE BOOL \"\")\n    set(BAD_SIGNAL ON CACHE BOOL \"\")\nendif()\noption(LD80BITS \"Set to ON if host device have 80bits long double (i.e. i386)\" ${LD80BITS})\noption(NOALIGN \"Set to ON if host device doesn't need re-align (i.e. i386)\" ${NOALIGN})\noption(ARM_DYNAREC \"Set to ON to use ARM Dynamic Recompilation\" ${ARM_DYNAREC})\noption(POWERPCLE \"Set to ON if targeting a little-endian PowerPC device\" ${POWERPCLE})\noption(SYSV_VARARG \"Set to ON if host device uses SysVR4 vararg calling convention\" ${SYSV_VARARG})\n\nif(${CMAKE_VERSION} VERSION_LESS \"3.12.2\")\n    find_package(PythonInterp 3)\n    if(NOT PYTHONINTERP_FOUND)\n        message( FATAL_ERROR \"You need a Python interpretor, CMake will exit.\" )\n    endif()\n    if(${PYTHON_VERSION_MAJOR} LESS 3)\n        message( FATAL_ERROR \"You need a Python 3 interpretor, CMake will exit.\" )\n    endif()\nelse()\n    find_package(Python3)\n    if(NOT Python3_Interpreter_FOUND)\n        message( FATAL_ERROR \"You need a Python interpretor, CMake will exit.\" )\n    endif()\n    set(PYTHON_EXECUTABLE ${Python3_EXECUTABLE} CACHE INTERNAL \"The Python3 executable\" FORCE)\nendif()\n\ncmake_host_system_information(RESULT CMAKE_HOST_SYSTEM_PROCESSOR QUERY OS_PLATFORM)\n\nif(\"${CMAKE_HOST_SYSTEM_PROCESSOR}\" STREQUAL \"aarch64\" AND (RK3399 OR ODROIDN2 OR TEGRAX1 OR TEGRA_T194 OR TEGRA_T234 OR RPI3ARM64 OR RPI4ARM64 OR PHYTIUM OR SD845 OR SD888 OR ADLINK OR A64 OR LX2160A OR RK3588 OR ARM64))\n    set(COMPILER_TRIPLE arm-linux-gnueabihf-gcc)\n    find_program(COMPILER_FOUND ${COMPILER_TRIPLE})\n    \n    if(COMPILER_FOUND)\n        set(CMAKE_C_COMPILER ${COMPILER_FOUND})\n    else()\n        message(STATUS \"Cross compiler ${COMPILER_TRIPLE} not found, using CC or -DCMAKE_C_COMPILER\")\n    endif()\nendif()\n\nproject(box86 C ASM)\n\nenable_testing()\n\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"i686\"  _x86)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"x86_64\"  _x86_64)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"aarch64\"  _aarch64)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"armhf\"  _armhf)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"arm\"  _arm)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"armv8l\"  _armv8l)\n\nset(default_build_type \"RelwithDebInfo\")\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  message(STATUS \"Setting build type to '${default_build_type}' as none was specified.\")\n  set(CMAKE_BUILD_TYPE \"${default_build_type}\" CACHE STRING \"Choose the type of build.\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n\nif(PANDORA)\n    add_definitions(-DPANDORA)\n    #add_definitions(-mcpu=cortex-a8 -mfpu=neon -mfloat-abi=softfp -ftree-vectorize -fsingle-precision-constant -ffast-math)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a8 -mfpu=neon -mfloat-abi=softfp\")\nelseif(GAMESHELL)\n    add_definitions(-DGAMESHELL)\n    add_definitions(-marm -mcpu=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard\")\nelseif(PYRA)\n    add_definitions(-DPYRA)\n    add_definitions(-mcpu=cortex-a15 -mfpu=neon -mfloat-abi=hard -marm)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a15 -mfpu=neon -mfloat-abi=hard\")\nelseif(RPI2)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI2)\n    add_definitions(-marm -mcpu=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard\")\nelseif(RPI3)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI3)\n    add_definitions(-marm -march=armv8-a+crc -mtune=cortex-a53 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8-a+crc -mtune=cortex-a53 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(RPI4)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI4)\n    add_definitions(-marm -march=armv8-a+crc -mtune=cortex-a72 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8-a+crc -mtune=cortex-a72 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(RPI3ARM64)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI3ARM64)\n    add_definitions(-marm -march=armv8-a+crc -mtune=cortex-a53 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8-a+crc -mtune=cortex-a53 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(RPI4ARM64)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI4ARM64)\n    add_definitions(-marm -march=armv8-a+crc -mtune=cortex-a72 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8-a+crc -mtune=cortex-a72 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(ODROIDXU4)\n    add_definitions(-DODROIDXU4)\n    add_definitions(-marm -mcpu=cortex-a15.cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a15.cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard\")\nelseif(RK3288)\n    add_definitions(-DRK3288)\n    add_definitions(-mcpu=cortex-a17 -mfpu=neon -mfloat-abi=hard -marm)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a17 -mfpu=neon -mfloat-abi=hard\")\nelseif(SD845)\n    add_definitions(-DSD845)\n    add_definitions(-marm -march=armv8.2-a+simd+crypto -mtune=cortex-a75.cortex-a55 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8.2-a+simd+crypto -mtune=cortex-a75.cortex-a55 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(SD865)\n    add_definitions(-DSD865)\n    #note that cortex-a77.cortex-a55 is not supported, so fall back to a76 instead\n    add_definitions(-marm -march=armv8.2-a+simd+crypto -mtune=cortex-a76.cortex-a55 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8.2-a+simd+crypto -mtune=cortex-a76.cortex-a55 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(SD888)\n    add_definitions(-DSD888)\n    add_definitions(-marm -march=armv8.4-a+simd+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8.4-a+simd+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(ADLINK)\n    add_definitions(-DADLINK)\n    add_definitions(-marm -mcpu=neoverse-n1 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=neoverse-n1 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(A64)\n    add_definitions(-DA64)\n    add_definitions(-marm -march=armv8-a+crc+simd+crypto -mcpu=cortex-a53+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -march=armv8-a+crc+simd+crypto -mcpu=cortex-a53+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(GOA_CLONE)\n    add_definitions(-DGOA_CLONE)\n    add_definitions(-marm -mcpu=cortex-a35 -mfpu=neon-vfpv3 -march=armv8-a+crc+simd+crypto -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -mcpu=cortex-a35 -mfpu=neon-vfpv3 -march=armv8-a+crc+simd+crypto -mfloat-abi=hard\")\nelseif(RK3399)\n    add_definitions(-DRK3399)\n    add_definitions(-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a72+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a72+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(RK3588)\n    add_definitions(-DRK3588)\n    add_definitions(-pipe -mcpu=cortex-a76.cortex-a55+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    add_definitions(-DBAD_SIGNAL)\n    set(CMAKE_ASM_FLAGS  \"-pipe -mcpu=cortex-a76.cortex-a55+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(ARM64)\n    add_definitions(-DARM64)\n    add_definitions(-pipe -march=armv8-a+crc+simd+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(ODROIDN2)\n    add_definitions(-DODROIDN2)\n    add_definitions(-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a73.cortex-a53+crypto -mfpu=crypto-neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a73.cortex-a53+crypto -mfpu=crypto-neon-fp-armv8 -mfloat-abi=hard\")\nelseif(TEGRAX1)\n    add_definitions(-DTEGRAX1)\n    add_definitions(-marm -pipe -march=armv8-a+crc -mcpu=cortex-a57 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -pipe -march=armv8-a+crc -mcpu=cortex-a57 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(TEGRAX1ARM32)\n    add_definitions(-DTEGRAX1ARM32)\n    add_definitions(-marm -pipe -march=armv8-a+crc -mcpu=cortex-a57 -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -pipe -march=armv8-a+crc -mcpu=cortex-a57 -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(TEGRA_T194)\n    add_definitions(-DTEGRA_T194)\n    add_definitions(-marm -pipe -march=armv8.2-a+fp16+simd+crypto+predres -mfpu=crypto-neon-fp-armv8 -mcpu=cortex-a76+crypto -mtune=cortex-a76 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -pipe -march=armv8.2-a+fp16+simd+crypto+predres -mfpu=crypto-neon-fp-armv8 -mcpu=cortex-a76+crypto -mtune=cortex-a76 -mfloat-abi=hard\")\nelseif(TEGRA_T234)\n    add_definitions(-DTEGRA_T234)\n    add_definitions(-marm -pipe -march=armv8.2-a+fp16+simd+crypto+predres -mfpu=crypto-neon-fp-armv8 -mcpu=cortex-a78ae+crypto -mtune=cortex-a78ae -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-marm -pipe -march=armv8.2-a+fp16+simd+crypto+predres -mfpu=crypto-neon-fp-armv8 -mcpu=cortex-a78ae+crypto -mtune=cortex-a78ae -mfloat-abi=hard\")\nelseif(PHYTIUM)\n    add_definitions(-DPHYTIUM)\n    add_definitions(-pipe -march=armv8.1-a+simd+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.1-a+simd+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(LX2160A)\n    add_definitions(-DLX2160A)\n    add_definitions(-pipe -march=armv8-a+crypto+crc -mcpu=cortex-a72+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crypto+crc -mcpu=cortex-a72+crypto -mfpu=neon-fp-armv8 -mfloat-abi=hard\")\nelseif(ARM_DYNAREC)\n    #if DYNAREC is selected alone, without any arch\n    if(NOT ANDROID)\n        set(CMAKE_ASM_FLAGS  \"-pipe -march=armv7-a+simd -mfpu=neon\")\n    endif()\nendif()\nif(ANDROID)\n    add_definitions(-DANDROID)\nendif()\nif(TERMUX)\n    add_definitions(-DTERMUX)\nendif()\nif(BAD_SIGNAL)\n    add_definitions(-DBAD_SIGNAL)\nendif()\n\nif(POWER9)\n  add_definitions(-mcpu=power9 -mtune=power9)\nendif()\n\nif(NOGIT)\n    add_definitions(-DNOGIT)\nendif()\n\nif(BOX86LIB)\n    set(BOX86 box86)\nelseif(HAVE_TRACE)\n    set(BOX86 box86)\nelse()\n    set(BOX86 box86)\nendif()\n\ntry_compile(HAVE_ST_INO ${CMAKE_BINARY_DIR}/compile_tests ${CMAKE_SOURCE_DIR}/tests/test_st_ino.c)\n\nif(HAVE_ST_INO)\n  message(\"stat64 has __st_info field\")\n  add_definitions(-DHAVE_ST_INO)\nendif()\n\nset(BOX86_ELF_ADDRESS \"0x62800000\")\n\nif(LD80BITS)\n    add_definitions(-DHAVE_LD80BITS)\nendif()\n\nif(NOALIGN)\n    add_definitions(-DNOALIGN)\n    add_definitions(-pipe -march=core2 -msse2)\nendif()\n\nif(HAVE_TRACE)\n    add_definitions(-DHAVE_TRACE)\nendif()\n\nif(ARM_DYNAREC)\n    add_definitions(-DDYNAREC)\n    add_definitions(-DARM)\n    add_definitions(-marm)\n    enable_language(ASM)\nendif()\n\nif(POWERPCLE)\n  add_definitions(-DPOWERPCLE)\nendif()\n\nif(SYSV_VARARG)\n  add_definitions(-DSYSV_VARARG)\nendif()\n\nif(NOGETCLOCK)\n    add_definitions(-DNOGETCLOCK)\nendif()\n\nif(BOX86LIB)\n    add_definitions(-DBUILD_LIB)\n    if(BOX86DYNAMIC)\n        add_definitions(-DBUILD_DYNAMIC)\n    endif()\n    add_definitions(-fPIC)\n    if(NOT BOX86_ROOT)\n        message(FATAL_ERROR \"BOX86_ROOT not set when build as lib\")\n    endif()\nelse()\n    set(BOX86_ROOT ${CMAKE_SOURCE_DIR})\nendif()\n\n\nadd_definitions(-std=gnu11 -funwind-tables -fvisibility=hidden)\n\nif(USE_CCACHE)\n    find_program(CCACHE_FOUND ccache)\n    if(CCACHE_FOUND)\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)\n    endif()\nendif()\n\ninclude_directories(\n    \"${BOX86_ROOT}/src/include\"\n    \"${BOX86_ROOT}/src\"\n    \"${BOX86_ROOT}/src/wrapped/generated\"\n)\n\n# git_head.h is a generated file\nset_source_files_properties(\n    \"${BOX86_ROOT}/src/git_head.h\"\n    PROPERTIES GENERATED TRUE\n    HEADER_FILE_ONLY TRUE)\n\nset(ELFLOADER_SRC\n    \"${BOX86_ROOT}/src/main.c\"\n    \"${BOX86_ROOT}/src/box86context.c\"\n    \"${BOX86_ROOT}/src/build_info.c\"\n    \"${BOX86_ROOT}/src/custommem.c\"\n    \"${BOX86_ROOT}/src/mallochook.c\"\n    \"${BOX86_ROOT}/src/tools/bridge.c\"\n    \"${BOX86_ROOT}/src/tools/pathcoll.c\"\n    \"${BOX86_ROOT}/src/tools/fileutils.c\"\n    \"${BOX86_ROOT}/src/tools/callback.c\"\n    \"${BOX86_ROOT}/src/tools/box86stack.c\"\n    \"${BOX86_ROOT}/src/tools/my_cpuid.c\"\n    \"${BOX86_ROOT}/src/tools/gtkclass.c\"\n    \"${BOX86_ROOT}/src/tools/rcfile.c\"\n    \"${BOX86_ROOT}/src/tools/rbtree.c\"\n    \"${BOX86_ROOT}/src/tools/wine_tools.c\"\n    \"${BOX86_ROOT}/src/elfs/elfloader.c\"\n    \"${BOX86_ROOT}/src/elfs/elfparser.c\"\n    \"${BOX86_ROOT}/src/elfs/elfload_dump.c\"\n    \"${BOX86_ROOT}/src/librarian/library.c\"\n    \"${BOX86_ROOT}/src/librarian/librarian.c\"\n    \"${BOX86_ROOT}/src/librarian/dictionnary.c\"\n    \"${BOX86_ROOT}/src/librarian/symbols.c\"\n    \"${BOX86_ROOT}/src/librarian/globalsymbols.c\"\n    \"${BOX86_ROOT}/src/emu/x86compstrings.c\"\n    \"${BOX86_ROOT}/src/emu/x86emu.c\"\n    \"${BOX86_ROOT}/src/emu/x86run_private.c\"\n    \"${BOX86_ROOT}/src/emu/x86syscall.c\"\n    \"${BOX86_ROOT}/src/emu/x86primop.c\"\n    \"${BOX86_ROOT}/src/emu/x86trace.c\"\n    \"${BOX86_ROOT}/src/emu/x86int3.c\"\n    \"${BOX86_ROOT}/src/emu/x86tls.c\"\n    \"${BOX86_ROOT}/src/emu/x87emu_private.c\"\n    \"${BOX86_ROOT}/src/libtools/auxval.c\"\n    \"${BOX86_ROOT}/src/libtools/myalign.c\"\n    \"${BOX86_ROOT}/src/libtools/myalign64.c\"\n    \"${BOX86_ROOT}/src/libtools/myalignsys64.c\"\n    \"${BOX86_ROOT}/src/libtools/stat64_helper.c\"\n    \"${BOX86_ROOT}/src/libtools/myfts.c\"\n    \"${BOX86_ROOT}/src/libtools/sdl1rwops.c\"\n    \"${BOX86_ROOT}/src/libtools/sdl2rwops.c\"\n    \"${BOX86_ROOT}/src/libtools/signals.c\"\n    \"${BOX86_ROOT}/src/libtools/threads.c\"\n    \"${BOX86_ROOT}/src/libtools/vkalign.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec.c\"\n    \"${BOX86_ROOT}/src/wrapped/generated/wrapper.c\"\n)\nif(NOT ANDROID)\n    list(APPEND ELFLOADER_SRC \"${BOX86_ROOT}/src/libtools/obstack.c\")\nendif()\n\nset(INTERPRETER\n    \"${BOX86_ROOT}/src/emu/x86run.c\"\n    \"${BOX86_ROOT}/src/emu/x86run0f.c\"\n    \"${BOX86_ROOT}/src/emu/x86run64.c\"\n    \"${BOX86_ROOT}/src/emu/x86run640f.c\"\n    \"${BOX86_ROOT}/src/emu/x86run6466.c\"\n    \"${BOX86_ROOT}/src/emu/x86run6467.c\"\n    \"${BOX86_ROOT}/src/emu/x86run66.c\"\n    \"${BOX86_ROOT}/src/emu/x86run660f.c\"\n    \"${BOX86_ROOT}/src/emu/x86run66d9.c\"\n    \"${BOX86_ROOT}/src/emu/x86run66dd.c\"\n    \"${BOX86_ROOT}/src/emu/x86run66f20f.c\"\n    \"${BOX86_ROOT}/src/emu/x86run67.c\"\n    \"${BOX86_ROOT}/src/emu/x86run6766.c\"\n    \"${BOX86_ROOT}/src/emu/x86rund8.c\"\n    \"${BOX86_ROOT}/src/emu/x86rund9.c\"\n    \"${BOX86_ROOT}/src/emu/x86runda.c\"\n    \"${BOX86_ROOT}/src/emu/x86rundb.c\"\n    \"${BOX86_ROOT}/src/emu/x86rundc.c\"\n    \"${BOX86_ROOT}/src/emu/x86rundd.c\"\n    \"${BOX86_ROOT}/src/emu/x86runde.c\"\n    \"${BOX86_ROOT}/src/emu/x86rundf.c\"\n    \"${BOX86_ROOT}/src/emu/x86runf0.c\"\n    \"${BOX86_ROOT}/src/emu/x86runf066.c\"\n    \"${BOX86_ROOT}/src/emu/x86runf20f.c\"\n    \"${BOX86_ROOT}/src/emu/x86runf30f.c\"\n)\n\nset(WRAPPEDS\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibc.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibpthread.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibrt.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibbsd.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibgl.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibglu.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibx11.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibasound.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibdl.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl1.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl1mixer.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl1net.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl1image.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl1sound.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl1ttf.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl2mixer.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl2net.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl2image.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsdl2ttf.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsmpeg.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsmpeg2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedvorbisfile.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibvorbis.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibogg.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpng12.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpng16.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxxf86vm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxrandr.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxpresent.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxext.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedxinerama.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxfixes.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcursor.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxrender.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxft.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxi.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxss.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxpm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxau.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxdmcp.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibx11xcb.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcb.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbxfixes.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbshape.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbshm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbrandr.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbimage.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbkeysyms.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbxtest.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbdri2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbdri3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcbpresent.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxtst.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxt.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxcomposite.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxdamage.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibxmu.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibz.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedopenal.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedalure.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedalut.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedopencl.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedcurl.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedudev0.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedudev1.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappeddbus.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappediconv.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibdrm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedcrypto.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibssl.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibcrypt.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedutil.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibuuid.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibresolv.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpulsesimple.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpulse.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibsndfile.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedfontconfig.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedfreetype.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedbz2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedexpat.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibsm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibice.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibusb1.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibncursesw.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibformw.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibncurses.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibtinfo.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibpanel.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibncurses6.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibtinfo6.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgmp.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgcrypt.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgtkx112.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgdkx112.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgtk3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgdk3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgdkpixbuf2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgio2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgmodule2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgobject2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedglib2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgconf2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstreamer010.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstinterfaces010.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstreamer.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstaudio.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstvideo.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgsttag.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstbase.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgstapp.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibibus.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappeddbusmenugtk.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappeddbusmenuglib.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedappindicator.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedappindicator3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedayatanaappindicator3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedatk.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedatkbridge.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpangoft2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpangocairo.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgthread2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedcairo.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedcairogobject.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpango.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappeddbusglib1.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgudev1.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibnm.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedtcmallocminimal.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedmpg123.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgnutls.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibcups.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedd3dadapter9.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedvulkan.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedwaylandclient.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedxml2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedxslt.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedldapr.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlber.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappednsl.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlcms2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedkrb5.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgssapikrb5.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibtiff.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedldlinux.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedcrashhandler.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibv4l2.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappednspr4.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsmime3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappednssutil3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappednss3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedplds4.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedplc4.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedssl3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsoftokn3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedfreebl3.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedsecret1.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedtbbmalloc.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedmimalloc.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedselinux.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibharfbuzz.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibcairogobject.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibvkd3d.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedgomp.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedcap.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedpcap.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedfaudio.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedtbbmallocproxy.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibfuse.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedatomic.c\"\n    \"${BOX86_ROOT}/src/wrapped/wrappedlibpcre.c\"\n)\nif(ANDROID)\n    list(APPEND WRAPPEDS\n        \"${BOX86_ROOT}/src/wrapped/wrappedandroidshmem.c\"\n    )\nelse()\n    list(APPEND WRAPPEDS\n        \"${BOX86_ROOT}/src/wrapped/wrappedlibjpeg.c\"\n        \"${BOX86_ROOT}/src/wrapped/wrappedlibjpeg62.c\"\n        \"${BOX86_ROOT}/src/wrapped/wrappedturbojpeg.c\"\n    )\nendif()\n\n# If BOX86_ROOT contains a \".c\", the build breaks...\nstring(REPLACE \".c\" \"_private.h\" MODROOT ${BOX86_ROOT})\nset(WRAPPEDS_HEAD \"${BOX86_ROOT}/src/wrapped/wrappedd3dadapter9_genvate.h\")\nforeach(A ${WRAPPEDS})\n    string(REPLACE \".c\" \"_private.h\" C ${A})\n    string(REPLACE \"${MODROOT}\" \"${BOX86_ROOT}\" B ${C})\n    set(WRAPPEDS_HEAD ${WRAPPEDS_HEAD} ${B})\n    set_source_files_properties(${A} PROPERTIES OBJECT_DEPENDS ${B})\nendforeach()\n\nset(WRAPPER \"${BOX86_ROOT}/src/wrapped/generated/wrapper.c\" \"${BOX86_ROOT}/src/wrapped/generated/wrapper.h\")\n\nadd_custom_command(\n    OUTPUT \"${BOX86_ROOT}/src/wrapped/generated/functions_list.txt\"\n    COMMAND \"${PYTHON_EXECUTABLE}\" \"${BOX86_ROOT}/rebuild_wrappers.py\" \n    \"${BOX86_ROOT}\" \n    \"PANDORA\" \"HAVE_LD80BITS\" \"NOALIGN\" \"HAVE_TRACE\" \"POWERPCLE\" \"ANDROID\" \"TERMUX\" \"--\" \n    ${WRAPPEDS_HEAD}\n    MAIN_DEPENDENCY \"${BOX86_ROOT}/rebuild_wrappers.py\"\n    DEPENDS ${WRAPPEDS} ${WRAPPEDS_HEAD}\n    BYPRODUCTS ${WRAPPER}\n)\n\nadd_custom_command(\n    OUTPUT \"${BOX86_ROOT}/src/dynarec/last_run.txt\"\n    COMMAND \"${PYTHON_EXECUTABLE}\" \"${BOX86_ROOT}/rebuild_printer.py\" \"${BOX86_ROOT}\"\n    MAIN_DEPENDENCY \"${BOX86_ROOT}/rebuild_printer.py\"\n    DEPENDS \"${BOX86_ROOT}/src/dynarec/arm_instructions.txt\"\n    BYPRODUCTS \"${BOX86_ROOT}/src/dynarec/arm_printer.c\"\n)\n\nadd_custom_target(WRAPPERS DEPENDS \"${BOX86_ROOT}/src/wrapped/generated/functions_list.txt\")\nadd_custom_target(PRINTER DEPENDS \"${BOX86_ROOT}/src/dynarec/last_run.txt\")\n\nif(ARM_DYNAREC)\n    set(DYNAREC_SRC\n        \"${BOX86_ROOT}/src/dynarec/dynablock.c\"\n\n        \"${BOX86_ROOT}/src/dynarec/dynarec_arm.c\"\n        \"${BOX86_ROOT}/src/dynarec/dynarec_arm_functions.c\"\n        \"${BOX86_ROOT}/src/dynarec/dynarec_arm_jmpnext.c\"\n        \"${BOX86_ROOT}/src/dynarec/arm_printer.c\"\n        \"${BOX86_ROOT}/src/emu/x86test.c\"\n\n        \"${BOX86_ROOT}/src/dynarec/arm_prolog.S\"\n        \"${BOX86_ROOT}/src/dynarec/arm_epilog.S\"\n        \"${BOX86_ROOT}/src/dynarec/arm_next.S\"\n        \"${BOX86_ROOT}/src/dynarec/arm_lock_helper.S\"\n    )\n\n    set(DYNAREC_PASS\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_helper.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_emit_tests.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_emit_math.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_emit_logic.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_emit_shift.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_pass.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_00.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_0f.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_64.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_65.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_66.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_67.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_d8.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_d9.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_da.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_db.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_dc.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_dd.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_de.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_df.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_f0.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_660f.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_66f0.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_f20f.c\"\n    \"${BOX86_ROOT}/src/dynarec/dynarec_arm_f30f.c\"\n    )\n\n    set(DYNAREC_PASS \"${BOX86_ROOT}/src/wrapped/generated/wrapper.h\" ${DYNAREC_PASS})\n\n    add_library(dynarec_arm OBJECT ${DYNAREC_SRC})\n\n    add_library(arm_pass0 OBJECT ${DYNAREC_PASS})\n    set_target_properties(arm_pass0 PROPERTIES COMPILE_FLAGS \"-DSTEP=0\")\n    add_library(arm_pass1 OBJECT ${DYNAREC_PASS})\n    set_target_properties(arm_pass1 PROPERTIES COMPILE_FLAGS \"-DSTEP=1\")\n    add_library(arm_pass2 OBJECT ${DYNAREC_PASS})\n    set_target_properties(arm_pass2 PROPERTIES COMPILE_FLAGS \"-DSTEP=2\")\n    add_library(arm_pass3 OBJECT ${DYNAREC_PASS})\n    set_target_properties(arm_pass3 PROPERTIES COMPILE_FLAGS \"-DSTEP=3\")\n    add_library(test_interpreter OBJECT ${INTERPRETER})\n    set_target_properties(test_interpreter PROPERTIES COMPILE_FLAGS \"-DTEST_INTERPRETER\")\n    add_dependencies(arm_pass0 WRAPPERS)\n    add_dependencies(arm_pass1 WRAPPERS)\n    add_dependencies(arm_pass2 WRAPPERS)\n    add_dependencies(arm_pass3 WRAPPERS)\n\n    add_library(dynarec STATIC \n        $<TARGET_OBJECTS:dynarec_arm> \n        $<TARGET_OBJECTS:arm_pass0> \n        $<TARGET_OBJECTS:arm_pass1>\n        $<TARGET_OBJECTS:arm_pass2>\n        $<TARGET_OBJECTS:arm_pass3>\n        $<TARGET_OBJECTS:test_interpreter>\n    )\n\nendif()\n\n# creates git_head.h\nif(ARM_DYNAREC)\n    add_custom_command(\n        OUTPUT \"${BOX86_ROOT}/src/git_head.h\"\n        COMMAND bash -c \"echo \\\\\\#define GITREV \\\\\\\"$(git rev-parse --short HEAD)\\\\\\\">\\\"${BOX86_ROOT}/src/git_head.h\\\"\"\n        DEPENDS dynarec ${ELFLOADER_SRC} ${INTERPRETER} ${WRAPPEDS}\n        VERBATIM)\nelse()\n    add_custom_command(\n        OUTPUT \"${BOX86_ROOT}/src/git_head.h\"\n        COMMAND bash -c \"echo \\\\\\#define GITREV \\\\\\\"$(git rev-parse --short HEAD)\\\\\\\">\\\"${BOX86_ROOT}/src/git_head.h\\\"\"\n        DEPENDS ${ELFLOADER_SRC} ${INTERPRETER} ${WRAPPEDS}\n        VERBATIM)\nendif()\n\nadd_library(interpreter OBJECT ${INTERPRETER})\n\nif(BOX86LIB)\n#build a static or dynamic lib...\nif(BOX86DYNAMIC)\n    add_library(box86 SHARED ${ELFLOADER_SRC} ${WRAPPEDS} \"${BOX86_ROOT}/src/git_head.h\")\nelse()\n    add_library(${BOX86} OBJECT ${ELFLOADER_SRC} ${WRAPPEDS} \"${BOX86_ROOT}/src/git_head.h\")\nendif()\nif(ARM_DYNAREC)\n    if(ANDROID)\n        if(TERMUX)\n        target_link_libraries(${BOX86} dynarec interpreter m dl android-sysv-semaphore android-spawn)\n        else()\n        target_link_libraries(${BOX86} dynarec interpreter m dl)\n        endif()\n    else()\n        target_link_libraries(${BOX86} dynarec interpreter m dl rt pthread resolv)\n    endif()\nendif()\nif(${CMAKE_VERSION} VERSION_LESS \"3.13\")\n    set_target_properties(${BOX86} PROPERTIES LINK_FLAGS -rdynamic)\nelse()\n    target_link_options(${BOX86} PUBLIC -rdynamic)\nendif()\nadd_dependencies(${BOX86} WRAPPERS)\nadd_dependencies(${BOX86} PRINTER)\n\nadd_custom_target(buildinfo ${BOX86}\n    DEPENDS dynarec ${BOX86} )\n\nelse(BOX86LIB)\n\nadd_executable(${BOX86} ${ELFLOADER_SRC} ${WRAPPEDS} \"${BOX86_ROOT}/src/git_head.h\")\nadd_dependencies(${BOX86} WRAPPERS)\nadd_dependencies(${BOX86} PRINTER)\nif(ANDROID)\n    if(TERMUX)\n    target_link_libraries(${BOX86} dynarec interpreter m dl android-complex-math android-sysv-semaphore android-spawn )\n    else()\n    target_link_libraries(${BOX86} dynarec interpreter m dl)\n    endif()\n    target_link_libraries(${BOX86} c m dl)\nelse()\n    #target_link_libraries(${BOX86} c m dl rt pthread resolv)\n    set_target_properties(${BOX86} PROPERTIES LINK_FLAGS \"-Wl,--no-as-needed -lc -lm -ldl -lrt -lpthread -lresolv -Wl,--as-needed -pthread\")\nendif()\nif(ARM_DYNAREC)\n    target_link_libraries(${BOX86} dynarec interpreter)\nelse()\n    target_link_libraries(${BOX86} interpreter)\nendif()\n\nif(${CMAKE_VERSION} VERSION_LESS \"3.13\")\n    if(NOT NOLOADADDR)\n        if(CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n            set_target_properties(${BOX86} PROPERTIES LINK_FLAGS \"-rdynamic -Wl,--image-base,${BOX86_ELF_ADDRESS}\")\n        else()\n            set_target_properties(${BOX86} PROPERTIES LINK_FLAGS \"-rdynamic -Wl,-Ttext-segment,${BOX86_ELF_ADDRESS}\")\n        endif()\n    else()\n        set_target_properties(${BOX86} PROPERTIES LINK_FLAGS -rdynamic)\n    endif()\nelse()\n    target_link_options(${BOX86} PUBLIC -rdynamic)\n    if(NOT NOLOADADDR)\n        if(CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n            target_link_options(${BOX86} PUBLIC -Wl,--image-base,${BOX86_ELF_ADDRESS})\n        else()\n            target_link_options(${BOX86} PUBLIC -Wl,-Ttext-segment,${BOX86_ELF_ADDRESS})\n        endif()\n    endif()\nendif()\n\nif(NOT _x86 AND NOT _x86_64)\n  if(NOT TERMUX)\n   install(TARGETS ${BOX86}\n    RUNTIME DESTINATION bin)\n  else()\n   install(TARGETS ${BOX86}\n    RUNTIME DESTINATION ${TERMUX_PATH}/usr/bin)\n  endif()\n  if(NOT NO_CONF_INSTALL)\n    configure_file(system/box86.conf.cmake system/box86.conf)\n    \tif(NOT TERMUX)\n    \t\tinstall(FILES ${CMAKE_BINARY_DIR}/system/box86.conf DESTINATION /etc/binfmt.d/)\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/system/box86.box86rc DESTINATION /etc/)\n\telse()\n\t\t#install(FILES ${CMAKE_BINARY_DIR}/system/box86.conf DESTINATION ${TERMUX_PATH}/usr/etc/binfmt.d/)\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/system/box86.box86rc DESTINATION ${TERMUX_PATH}/usr/etc/)\n\tendif()\n  endif()\n  set(INSTALL_PATH \"/usr/lib/box86-i386-linux-gnu/\")\n  if(NOT NO_LIB_INSTALL)\n    if(NOT TERMUX)\n    \tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.6 DESTINATION ${INSTALL_PATH})\n    \tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.5 DESTINATION ${INSTALL_PATH})\n    \tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libgcc_s.so.1 DESTINATION ${INSTALL_PATH})\n    \tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libpng12.so.0 DESTINATION ${INSTALL_PATH})\n    \tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libunwind.so.8 DESTINATION ${INSTALL_PATH})\n    else()\n\n\t    install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.6 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t    install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.5 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t    install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libgcc_s.so.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t    install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libpng12.so.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t    install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libunwind.so.8 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n    endif()\n  endif()\nendif()\n\nif(NOT TARGET uninstall)\n    configure_file(\n        \"${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n        \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n        IMMEDIATE @ONLY)\n\n    add_custom_target(uninstall\n        COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\nendif()\n\nset(CPACK_GENERATOR \"DEB\")\nset(CPACK_DEBIAN_PACKAGE_MAINTAINER \"ptitSeb\")\nset(CPACK_PACKAGE_CONTACT \"ptitSeb@box86.org\")\nset(CPACK_PACKAGE_DESCRIPTION \"Box86 - Linux Userspace x86 Emulator with a twist\")\nif(TERMUX)\nset(CPACK_DEBIAN_PACKAGE_DEPENDS \"libandroid-sysv-semaphore, libandroid-spawn\")\nelse()\nset(CPACK_DEBIAN_PACKAGE_DEPENDS \"libc6\")\nendif()\nset(CPACK_PACKAGE_HOMEPAGE_URL, \"https://box86.org\")\nfile(STRINGS \"${BOX86_ROOT}/src/box86version.h\" TEMP_STRING REGEX \"BOX86_MAJOR\\\\s*\")\nstring(REGEX REPLACE \"BOX86_MAJOR\" \"\" TEMP_STRING ${TEMP_STRING})\nstring(REGEX MATCH \"[0-9]\" BOX86_MAJOR ${TEMP_STRING})\nfile(STRINGS \"${BOX86_ROOT}/src/box86version.h\" TEMP_STRING REGEX \"BOX86_MINOR\\\\s*\")\nstring(REGEX REPLACE \"BOX86_MINOR\" \"\" TEMP_STRING ${TEMP_STRING})\nstring(REGEX MATCH \"[0-9]\" BOX86_MINOR ${TEMP_STRING})\nfile(STRINGS \"${BOX86_ROOT}/src/box86version.h\" TEMP_STRING REGEX \"BOX86_REVISION\\\\s*\")\nstring(REGEX REPLACE \"BOX86_REVISION\" \"\" TEMP_STRING ${TEMP_STRING})\nstring(REGEX MATCH \"[0-9]\" BOX86_REVISION ${TEMP_STRING})\nset(CPACK_PACKAGE_VERSION_MAJOR ${BOX86_MAJOR})\nset(CPACK_PACKAGE_VERSION_MINOR ${BOX86_MINOR})\nset(CPACK_PACKAGE_VERSION_PATCH ${BOX86_REVISION})\nif(NOT TERMUX)\nset(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA \"${CMAKE_CURRENT_SOURCE_DIR}/postinst\")\nendif()\nif(_aarch64 OR _armhf OR _arm OR _armv8l)\n    if(TERMUX)\n    set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"arm\")\n    else()\n    set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"armhf\")\n    endif()\nelseif(_x86_64 OR _x86)\n    set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"i386\")\nelse()\n    #probably wrong...\n    execute_process(COMMAND \"dpkg --print-architecture\" OUTPUT_VARIABLE CPACK_DEBIAN_PACKAGE_ARCHITECTURE)\nendif()\nif(TERMUX)\nset(CPACK_PACKAGING_INSTALL_PREFIX \"${TERMUX_PATH}/usr\")\nendif()\nif(NOT TERMUX)\nset(CPACK_DEBIAN_FILE_NAME \"${BOX86}-${BOX86_MAJOR}.${BOX86_MINOR}.${BOX86_REVISION}_${CMAKE_SYSTEM_NAME}-${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}.deb\")\nelse()\nset(CPACK_DEBIAN_FILE_NAME \"${BOX86}-${BOX86_MAJOR}.${BOX86_MINOR}.${BOX86_REVISION}_Termux-${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}.deb\")\nendif()\nINCLUDE(CPack)\n\nadd_test(NAME bootSyscall COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test01 -D TEST_OUTPUT=tmpfile01.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref01.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME bootSyscallC COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test02 -D TEST_OUTPUT=tmpfile02.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref02.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME printf COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test03 -D TEST_OUTPUT=tmpfile03.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref03.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME args COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test04 -D TEST_ARGS2=yeah -D TEST_OUTPUT=tmpfile04.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref04.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME maths1 COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test05 -D TEST_ARGS2=7 -D TEST_OUTPUT=tmpfile05.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref05.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME threadsStart COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test06 -D TEST_OUTPUT=tmpfile06.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref06.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME trig COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test07 -D TEST_OUTPUT=tmpfile07.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref07.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME pi COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test08 -D TEST_OUTPUT=tmpfile08.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref08.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME fork COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test09 -D TEST_OUTPUT=tmpfile09.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref09.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME cppThreads COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test10 -D TEST_OUTPUT=tmpfile10.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref10.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME tlsData COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test11 -D TEST_OUTPUT=tmpfile11.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref11.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME fpu COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test12 -D TEST_OUTPUT=tmpfile12.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref12.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME contexts COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test13 -D TEST_OUTPUT=tmpfile13.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref13.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nif(NOT LD80BITS)\n    add_test(NAME conditionalThreads COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test14 -D TEST_OUTPUT=tmpfile14.txt \n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref14.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\nendif()\n\nadd_test(NAME linkingIndirectNoversion COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test15 -D TEST_OUTPUT=tmpfile15.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref15.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME linkingIndirectVersion COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test16 -D TEST_OUTPUT=tmpfile16.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref16.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME sse COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test17 -D TEST_OUTPUT=tmpfile17.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref17.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(sse PROPERTIES ENVIRONMENT \"BOX86_DYNAREC_FASTNAN=0;BOX86_DYNAREC_FASTROUND=0\")\n\nadd_test(NAME longjumpInSignals COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test18 -D TEST_OUTPUT=tmpfile18.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref18.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME x87 COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test19 -D TEST_OUTPUT=tmpfile19.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref19.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME idiv COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test20 -D TEST_OUTPUT=tmpfile20.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref20.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME multiple_dlopen COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test21 -D TEST_OUTPUT=tmpfile21.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref21.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(NAME aes COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test22 -D TEST_OUTPUT=tmpfile22.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref22.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nfile(GLOB extension_tests \"${CMAKE_SOURCE_DIR}/tests/extensions/*.c\")    \nforeach(file ${extension_tests})\n    get_filename_component(testname \"${file}\" NAME_WE)\n    add_test(NAME \"${testname}\" COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/extensions/${testname} -D TEST_OUTPUT=tmpfile-${testname}.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/extensions/${testname}.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake)\nendforeach()        \n\nadd_test(NAME sse_optimized COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86} \n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test17_o2 -D TEST_OUTPUT=tmpfile17_o2.txt \n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref17_o2.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(sse_optimized PROPERTIES ENVIRONMENT \"BOX86_DYNAREC_FASTNAN=0;BOX86_DYNAREC_FASTROUND=0\")    \n    \nadd_test(bswap ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test23 -D TEST_OUTPUT=tmpfile23.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref23.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n    \nadd_test(feround ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test24 -D TEST_OUTPUT=tmpfile24.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref24.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(sse4_2 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test25 -D TEST_OUTPUT=tmpfile25.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref25.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(fpu_rounding ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX86}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test26 -D TEST_OUTPUT=tmpfile26.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref26.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(fpu_rounding PROPERTIES ENVIRONMENT \"BOX86_DYNAREC_FASTROUND=0\")\n    \nendif(BOX86LIB)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "Copyright (c) 2018-2021 Sebastien Chevalier (\"ptitSeb\")\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.025390625,
          "content": "theme: jekyll-theme-hacker"
        },
        {
          "name": "cmake_uninstall.cmake.in",
          "type": "blob",
          "size": 0.9794921875,
          "content": "if(NOT EXISTS \"@CMAKE_BINARY_DIR@/install_manifest.txt\")\n  message(FATAL_ERROR \"Cannot find install manifest: @CMAKE_BINARY_DIR@/install_manifest.txt\")\nendif(NOT EXISTS \"@CMAKE_BINARY_DIR@/install_manifest.txt\")\n\nfile(READ \"@CMAKE_BINARY_DIR@/install_manifest.txt\" files)\nstring(REGEX REPLACE \"\\n\" \";\" files \"${files}\")\nforeach(file ${files})\n  message(STATUS \"Uninstalling $ENV{DESTDIR}${file}\")\n  if(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    exec_program(\n      \"@CMAKE_COMMAND@\" ARGS \"-E remove \\\"$ENV{DESTDIR}${file}\\\"\"\n      OUTPUT_VARIABLE rm_out\n      RETURN_VALUE rm_retval\n      )\n    if(NOT \"${rm_retval}\" STREQUAL 0)\n      message(FATAL_ERROR \"Problem when removing $ENV{DESTDIR}${file}\")\n    endif(NOT \"${rm_retval}\" STREQUAL 0)\n  else(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    message(STATUS \"File $ENV{DESTDIR}${file} does not exist.\")\n  endif(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\nendforeach(file)\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "install_steam.sh",
          "type": "blob",
          "size": 1.810546875,
          "content": "#!/bin/bash\n\n# create necessary directories\nmkdir -p ~/steam\nmkdir -p ~/steam/tmp\ncd ~/steam/tmp\n\n# download latest deb and unpack\nwget https://cdn.cloudflare.steamstatic.com/client/installer/steam.deb\nar x steam.deb\ntar xf data.tar.xz\n\n# remove deb archives, not needed anymore\nrm ./*.tar.xz ./steam.deb\n\n# move deb contents to steam folder\nmv ./usr/* ../\ncd ../ && rm -rf ./tmp/\n\n# create run script\necho '#!/bin/bash\nexport STEAMOS=1\nexport STEAM_RUNTIME=1\nexport DBUS_FATAL_WARNINGS=0\n~/steam/bin/steam $@' > steam\n\n# make script executable and move\nchmod +x steam\nsudo mv steam /usr/local/bin/\n\n# detect if we're running on 64 bit Debian (maybe this can be moved in another script then mentioned in documentation for the people that don't use steam but don't want a headache)\nMACHINE_TYPE=`uname -m`\nif [ ${MACHINE_TYPE} == 'aarch64' ] && [ -f '/etc/debian_version' ]; then\n echo \"Detected 64 bit ARM Debian. Installing 32 bit libraries\"\n sudo dpkg --add-architecture armhf # enable installation of armhf libraries\n sudo apt update # update package lists with the newly added arch\n # install the libraries that Steam requires\n sudo apt install libc6:armhf libsdl2-2.0-0:armhf libsdl2-image-2.0-0:armhf libsdl2-mixer-2.0-0:armhf libsdl2-ttf-2.0-0:armhf libopenal1:armhf libpng16-16:armhf libfontconfig1:armhf libxcomposite1:armhf libbz2-1.0:armhf libxtst6:armhf libsm6:armhf libice6:armhf libgl1:armhf libxinerama1:armhf libxdamage1:armhf libibus-1.0-5\n # this one is not there all the time, so just try it...\n sudo apt install libncurses5:armhf \n\n # install mesa for armhf if already installed\n if dpkg-query -W libgl1-mesa-dri 2>/dev/null; then\n  echo \"Detected mesa driver for 64 bit ARM. Installing complementary 32 bit one\"\n  sudo apt install libgl1-mesa-dri:armhf\n fi\n\n echo \"Don't forget to compile/install Box64!\"\nfi\n\necho \"Script complete.\"\n"
        },
        {
          "name": "pkgbuilds",
          "type": "tree",
          "content": null
        },
        {
          "name": "postinst",
          "type": "blob",
          "size": 0.0908203125,
          "content": "#!/bin/sh\nif [ -d '/run/systemd/system' ]; then\n    systemctl restart systemd-binfmt || :\nfi\n"
        },
        {
          "name": "rebuild_printer.py",
          "type": "blob",
          "size": 64.607421875,
          "content": "#!/usr/bin/env python3\n\nimport os\nimport re\nimport sys\nfrom math import ceil\n\n\"\"\"\nGenerates src/dynarec/arm_printer.c\n===\n\nSee src/dynarec/arm_instructions.txt (the input file) for the syntax documentation.\n\"\"\"\n\n# Helper class to avoid displaying '\\x1b[' on errors\nclass string(str):\n\tdef __repr__(self):\n\t\treturn str(self)\n\ndef nextAvailable(num):\n\treturn 8 if num <= 8 else (16 if num <= 16 else (32 if num <= 32 else 64))\n\ndef int2hex(i, finsz=-1):\n\tif (finsz == -1) and (i == 0): return \"0x0\"\n\telif i == 0: return \"0x\" + (\"0\" * finsz)\n\tret = \"\"\n\twhile i != 0:\n\t\tret += str(i % 16) if i % 16 < 10 else chr(ord('A') + (i % 16) - 10)\n\t\ti = i // 16\n\trl = len(ret)\n\tif rl < finsz:\n\t\tret = ret + (\"0\" * (finsz - rl))\n\treturn \"0x\" + ''.join(reversed(ret))\ndef arr2hex(a, forceBin=False):\n\tif forceBin:\n\t\treturn \"0b\" + ''.join(map(str, a))\n\telse:\n\t\tal = len(a)\n\t\treturn int2hex(sum(v * 2**(al - i - 1) for i, v in enumerate(a)), ceil(al / 4))\n\ndef sz2str(sz, forceBin=False):\n\treturn int2hex(2 ** sz - 1) if not forceBin else (\"0b\" + \"1\" * sz)\n\ndef main(root, ver, __debug_forceAllDebugging=False):\n\t# Initialize variables\n\toutput = \"\"\n\t\n\t# Debugging variable\n\tinvalidationCount = 0\n\t\n\ttabCount = 1\n\tdef append(strg):\n\t\tassert(\"\\t\" not in strg)\n\t\tnonlocal output, tabCount\n\t\tstrg = strg.split(\"\\n\")\n\t\tfor s in strg[:-1]:\n\t\t\tif s.endswith(\"{\"):\n\t\t\t\ttabCount = tabCount + 1\n\t\t\tif s.startswith(\"}\") and output.endswith(\"\\t\"):\n\t\t\t\ttabCount = tabCount - 1\n\t\t\t\toutput = output[:-1]\n\t\t\toutput = output + s + \"\\n\" + \"\\t\" * tabCount\n\t\tif strg[-1].startswith(\"}\") and output.endswith(\"\\t\"):\n\t\t\ttabCount = tabCount - 1\n\t\t\toutput = output[:-1]\n\t\toutput = output + strg[-1]\n\t\n\tinsts = None\n\t# Read the instruction and exit if nothing changed since last run\n\twith open(os.path.join(root, \"src\", \"dynarec\", \"arm_instructions.txt\"), 'r') as file:\n\t\tinsts = file.read()\n\t\t\n\t\t# Get all actual instructions\n\t\t# Ignore white lines and lines beginning with either !, ; or #\n\t\tinsts = list(filter(lambda l: not re.match(\"^\\\\s*$\", l) and not re.match(\"^([!;#])\", l), insts.split('\\n')))\n\t\t\n\t\ttry:\n\t\t\t# Do not open with `with` to be able to open it in writing mode\n\t\t\tlast = open(os.path.join(root, \"src\", \"dynarec\", \"last_run.txt\"), 'r')\n\t\t\tif '\\n'.join(insts) == last.read():\n\t\t\t\tlast.close()\n\t\t\t\twith open(os.path.join(root, \"src\", \"dynarec\", \"last_run.txt\"), 'w') as f:\n\t\t\t\t\tf.write('\\n'.join(insts))\n\t\t\t\treturn 0\n\t\t\tlast.close()\n\t\texcept OSError:\n\t\t\t# No last run file\n\t\t\tpass\n\t\n\tfor lnno, line in enumerate(insts):\n\t\tln = line.strip()\n\t\t\n\t\tdef fail(errType, reas, allow_use_curSplt=True):\n\t\t\t\"\"\"\n\t\t\tThrow an error of type `errType`, with `reas` as the reason.\n\t\t\tAppends the line number and the erroring line.\n\t\t\t\n\t\t\t`allow_use_curSplt` is a boolean, set to False if you want to ignore `curSplt` (no colored line)\n\t\t\t\"\"\"\n\t\t\ttry:\n\t\t\t\tnonlocal curSplt\n\t\t\t\tif allow_use_curSplt and (curSplt >= 0):\n\t\t\t\t\t# Get a colorized line\n\t\t\t\t\t# (Blah blah [CSI-color change][Here is the error][CSI-color change] blah)\n\t\t\t\t\tline = \"\"\n\t\t\t\t\talreadyChanged = 0\n\t\t\t\t\tcsp = 0\n\t\t\t\t\twhile csp < curSplt:\n\t\t\t\t\t\tif spltln[csp] == '\\x01':\n\t\t\t\t\t\t\talreadyChanged = 1\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif alreadyChanged == 0:\n\t\t\t\t\t\t\t\tline = line + spltln[csp] + \" \"\n\t\t\t\t\t\t\telif alreadyChanged == 1:\n\t\t\t\t\t\t\t\tline = line + spltln[csp] + \"<\"\n\t\t\t\t\t\t\t\talreadyChanged = 2\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tline = line + spltln[csp] + \">\"\n\t\t\t\t\t\t\t\talreadyChanged = 1\n\t\t\t\t\t\tcsp = csp + 1\n\t\t\t\t\tif spltln[csp] == '\\x01':\n\t\t\t\t\t\talreadyChanged = 1\n\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\tcsp = csp + 1\n\t\t\t\t\tline = line + \"\\033[31m[\\033[91m\" + spltln[csp] + \"\\033[31m]\\033[m\"\n\t\t\t\t\tif alreadyChanged == 0:\n\t\t\t\t\t\tline = line + \" \"\n\t\t\t\t\telif alreadyChanged == 1:\n\t\t\t\t\t\tline = line + \"<\"\n\t\t\t\t\t\talreadyChanged = 2\n\t\t\t\t\telse:\n\t\t\t\t\t\tline = line + \">\"\n\t\t\t\t\t\talreadyChanged = 1\n\t\t\t\t\tcsp = csp + 1\n\t\t\t\t\twhile csp < len(spltln):\n\t\t\t\t\t\tif spltln[csp] == '\\x01':\n\t\t\t\t\t\t\talreadyChanged = 1\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif alreadyChanged == 0:\n\t\t\t\t\t\t\t\tline = line + spltln[csp] + \" \"\n\t\t\t\t\t\t\telif alreadyChanged == 1:\n\t\t\t\t\t\t\t\tline = line + spltln[csp] + \"<\"\n\t\t\t\t\t\t\t\talreadyChanged = 2\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tline = line + spltln[csp] + \">\"\n\t\t\t\t\t\t\t\talreadyChanged = 1\n\t\t\t\t\t\tcsp = csp + 1\n\t\t\t\t\traise errType(string(str(reas) + \" (\" + str(lnno + 1) + \": \" + line[:-1] + \")\"))\n\t\t\t\telse:\n\t\t\t\t\t# No colored line\n\t\t\t\t\traise errType(str(reas) + \" (\" + str(lnno + 1) + \": \" + ln + \")\")\n\t\t\texcept errType as e:\n\t\t\t\t# Raise a BaseException as an error wrapper\n\t\t\t\t# (otherwise it will be caught and the line will be re-appended)\n\t\t\t\traise BaseException(\"[Error wrapper]\") from e\n\t\t\n\t\tspltln = ln.split(' ')\n\t\tcurSplt = -1\n\t\t\n\t\tmask = [0] * 32\n\t\tcorrectBits = [0] * 32\n\t\tcurBit = 32\n\t\tocurBit = -1\n\t\treq = ''\n\t\t\n\t\timms = [] # Immediates\n\t\tparm = [] # Custom variable length parameters\n\t\t\n\t\tvariables = {}\n\t\t\n\t\tdef generate_bin_test(positions=[], specifics=[]):\n\t\t\t\"\"\"\n\t\t\tGenerates the if statement at the beginning.\n\t\t\t\n\t\t\tYou may use positions and specifics to implement a \"multiple choice if\":\n\t\t\t- positions is an array that contains a bit position (MSB = 0)\n\t\t\t- specifics is an array of arrays the same length as positions that contains a tuple (mask, correctBit)\n\t\t\t  that is at position positions[current_pos]\n\t\t\t\"\"\"\n\t\t\t\n\t\t\tif specifics == []:\n\t\t\t\tappend(\"if ((opcode & \" + arr2hex(mask) + \") == \" + arr2hex(correctBits) + \") {\\n\")\n\t\t\telse:\n\t\t\t\tl = len(positions)\n\t\t\t\tif any(map(lambda v: (v < 0) or (v > 31), positions)):\n\t\t\t\t\tfail(\n\t\t\t\t\t\tAssertionError,\n\t\t\t\t\t\t\"generate_bin_tests requires a valid positions ({}) and specifics ({})!\".format(\n\t\t\t\t\t\t\tlen(positions), len(specifics)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\tif any(map(lambda s: len(s) != l, specifics)):\n\t\t\t\t\tfail(\n\t\t\t\t\t\tAssertionError,\n\t\t\t\t\t\t\"generate_bin_tests requires the same length for positions ({}) and each element \"\n\t\t\t\t\t\t\"of the specifics array ({})!\".format(\n\t\t\t\t\t\t\tlen(positions), [len(s) for s in specifics]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\n\t\t\t\tinner = []\n\t\t\t\tfor specific in specifics:\n\t\t\t\t\tfor i, (m, c) in zip(positions, specific):\n\t\t\t\t\t\tmask[i] = m\n\t\t\t\t\t\tcorrectBits[i] = c\n\t\t\t\t\tinner.append(\"((opcode & \" + arr2hex(mask) + \") == \" + arr2hex(correctBits) + \")\")\n\t\t\t\tappend(\"if (\" + \" || \".join(inner) + \") {\\n\")\n\t\t\n\t\tdef parse_var_requirements():\n\t\t\t\"\"\"\n\t\t\tParse the `/` restrictions on the bit fields\n\t\t\t\"\"\"\n\t\t\tnonlocal req\n\t\t\t\n\t\t\twhile req != '':\n\t\t\t\tkey = req[0]\n\t\t\t\treq = req[1:]\n\t\t\t\tif key == '=':\n\t\t\t\t\tif len(req) < ocurBit - curBit:\n\t\t\t\t\t\tfail(KeyError, \"Not enough data in constraint value (type '=' for val \" + val + \")\")\n\t\t\t\t\tfor i in range(ocurBit - curBit):\n\t\t\t\t\t\tif req[0] == 'x':\n\t\t\t\t\t\t\treq = req[1:]\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\telif (req[0] != '0') and (req[0] != '1'):\n\t\t\t\t\t\t\tfail(KeyError, \"Invalid constraint '\" + key + \"...\" + req[0] + \"'\")\n\t\t\t\t\t\tmask[32 - ocurBit + i] = 1\n\t\t\t\t\t\tcorrectBits[32 - ocurBit + i] = ord(req[0]) - ord('0')\n\t\t\t\t\t\treq = req[1:]\n\t\t\t\telif (ord(key) >= ord('0')) and (ord(key) <= ord('9')):\n\t\t\t\t\tif req == '':\n\t\t\t\t\t\tfail(KeyError, \"Not enough data in constraint value (type '\" + key + \"' for val \" + \\\n\t\t\t\t\t\t\tval + \")\")\n\t\t\t\t\telif (req[0] != '0') and (req[0] != '1'):\n\t\t\t\t\t\tfail(KeyError, \"Invalid constraint '\" + key + req[0] + \"'\")\n\t\t\t\t\tmask[31 - curBit + ord('0') - ord(key)] = 1\n\t\t\t\t\tcorrectBits[31 - curBit + ord('0') - ord(key)] = ord(req[0]) - ord('0')\n\t\t\t\t\treq = req[1:]\n\t\t\t\telif (ord(key) >= ord('A')) and (ord(key) <= ord('F')):\n\t\t\t\t\tif req == '':\n\t\t\t\t\t\tfail(KeyError, \"Not enough data in constraint value (type '\" + key + \"' for val \" + \\\n\t\t\t\t\t\t\tval + \")\")\n\t\t\t\t\telif (req[0] != '0') and (req[0] != '1'):\n\t\t\t\t\t\tfail(KeyError, \"Invalid constraint '\" + key + req[0] + \"'\")\n\t\t\t\t\tmask[31 - curBit + ord('A') + 10 - ord(key)] = 1\n\t\t\t\t\tcorrectBits[31 - curBit + ord('A') + 10 - ord(key)] = ord(req[0]) - ord('0')\n\t\t\t\t\treq = req[1:]\n\t\t\n\t\tdef add_custom_variables():\n\t\t\tnonlocal curSplt\n\t\t\t\n\t\t\t# Check for any custom variables\n\t\t\tif len(parm) == 1:\n\t\t\t\t# One parameter, name it param\n\t\t\t\tappend(\"int param = (opcode >> \" + str(parm[0][0]) + \") & \" + sz2str(parm[0][1]) + \";\\n\")\n\t\t\telse:\n\t\t\t\t# Multiple parameters, name them \"param\" paramNr \"_\" paramBitsSize\n\t\t\t\tfor i, p in enumerate(parm):\n\t\t\t\t\tappend(\n\t\t\t\t\t\t\"int param\" + str(i + 1) + \"_\" + str(p[1]) + \" = (opcode >> \" + \\\n\t\t\t\t\t\tstr(p[0]) + \") & \" + sz2str(p[1]) + \";\\n\"\n\t\t\t\t\t)\n\t\t\tif spltln[curSplt] == '@':\n\t\t\t\t# Additional custom modifications\n\t\t\t\tappend(\"\\n\")\n\t\t\t\t\n\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\twhile spltln[curSplt] != '@':\n\t\t\t\t\tif '=' in spltln[curSplt]:\n\t\t\t\t\t\t# Add an `if` statement\n\t\t\t\t\t\t\n\t\t\t\t\t\teq = spltln[curSplt]\n\t\t\t\t\t\t\n\t\t\t\t\t\t# Read initialization statement...\n\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\toldSplt = curSplt\n\t\t\t\t\t\twhile spltln[curSplt][-1] != '@':\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\tif len(spltln) == curSplt:\n\t\t\t\t\t\t\t\tfail(KeyError, \"End of '=' switch not found!\")\n\t\t\t\t\t\t\n\t\t\t\t\t\t# Always initialize if necessary\n\t\t\t\t\t\tif oldSplt != curSplt:\n\t\t\t\t\t\t\tappend(' '.join(spltln[oldSplt:curSplt]) + \";\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tifs = [\"\"]\n\t\t\t\t\t\t\n\t\t\t\t\t\tif spltln[curSplt] == '@@':\n\t\t\t\t\t\t\t# Custom ifs\n\t\t\t\t\t\t\t# Also, requires only a single '='\n\t\t\t\t\t\t\tif eq != \"=\":\n\t\t\t\t\t\t\t\tfail(ValueError, \"Too many '=' switches (@@ modifier)\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Extract the statements\n\t\t\t\t\t\t\tstatements = []\n\t\t\t\t\t\t\twhile spltln[curSplt] == '@@':\n\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tstatement = spltln[curSplt]\n\t\t\t\t\t\t\t\twhile spltln[curSplt][-1] != '@':\n\t\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\t\tstatement = statement + \" \" + spltln[curSplt]\n\t\t\t\t\t\t\t\t\tif len(spltln) == curSplt:\n\t\t\t\t\t\t\t\t\t\tfail(KeyError, \"End of '=' switch (@@ modifier) not found!\")\n\t\t\t\t\t\t\t\tstatements.append(statement[:-1])\n\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Unified eq length\n\t\t\t\t\t\t\teq = statements + [0]\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Make the ifs array\n\t\t\t\t\t\t\tfor stmt in statements:\n\t\t\t\t\t\t\t\tifs[-1] = ifs[-1] + \"if (\" + stmt + \") {\\n\"\n\t\t\t\t\t\t\t\tifs.append(\"} else \")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tifs[-1] = ifs[-1] + \"{\\n\"\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t# Standard if\n\t\t\t\t\t\t\teq = eq.split('=')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor e in eq[1:]:\n\t\t\t\t\t\t\t\tifs[-1] = ifs[-1] + \"if (\" + eq[0] + \" == \" + e + \") {\\n\"\n\t\t\t\t\t\t\t\tifs.append(\"} else \")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tifs[-1] = ifs[-1] + \"{\\n\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tif spltln[curSplt] == '!@':\n\t\t\t\t\t\t\t# Custom statements\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Extract the common value\n\t\t\t\t\t\t\tcommonPart = spltln[curSplt]\n\t\t\t\t\t\t\twhile spltln[curSplt][-1] != '@':\n\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\tcommonPart = commonPart + \" \" + spltln[curSplt]\n\t\t\t\t\t\t\t\tif len(spltln) == curSplt:\n\t\t\t\t\t\t\t\t\tfail(KeyError, \"End of '=' switch (!@ modifier) not found!\")\n\t\t\t\t\t\t\tcommonPart = commonPart[:-1].replace(\"\\\\n\", \"\\n\")\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Extract the parts\n\t\t\t\t\t\t\tcommonPart = commonPart.split('%')\n\t\t\t\t\t\t\tif len(commonPart) < 2:\n\t\t\t\t\t\t\t\tfail(ValueError, \"No replacement place!\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor if_ in ifs[:-1]:\n\t\t\t\t\t\t\t\tappend(if_)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t# For each '%', append the preceding part and the variable part\n\t\t\t\t\t\t\t\tfor common in commonPart[:-1]:\n\t\t\t\t\t\t\t\t\tinsert = spltln[curSplt]\n\t\t\t\t\t\t\t\t\twhile spltln[curSplt][-1] != '@':\n\t\t\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\t\t\tinsert = insert + \" \" + spltln[curSplt]\n\t\t\t\t\t\t\t\t\t\tif len(spltln) == curSplt:\n\t\t\t\t\t\t\t\t\t\t\tfail(\n\t\t\t\t\t\t\t\t\t\t\t\tKeyError,\n\t\t\t\t\t\t\t\t\t\t\t\t\"End of '=' switch (!@ modifier, repl1 i=\" + str(i) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\" part) not found!\"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tinsert = insert[:-1].replace(\"\\\\n\", \"\\n\")\n\t\t\t\t\t\t\t\t\tappend(common + insert)\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\tappend(commonPart[-1] + \";\\n\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Finish with the `else` part\n\t\t\t\t\t\t\tappend(ifs[-1])\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# For each '%', append the preceding part and the variable part\n\t\t\t\t\t\t\tfor common in commonPart[:-1]:\n\t\t\t\t\t\t\t\tinsert = spltln[curSplt]\n\t\t\t\t\t\t\t\twhile spltln[curSplt][-1] != '@':\n\t\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\t\tinsert = insert + \" \" + spltln[curSplt]\n\t\t\t\t\t\t\t\t\tif len(spltln) == curSplt:\n\t\t\t\t\t\t\t\t\t\tfail(KeyError, \"End of '=' switch (!@ modifier, repl2 part) not found!\")\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tinsert = insert[:-1].replace(\"\\\\n\", \"\\n\")\n\t\t\t\t\t\t\t\tappend(common + insert)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tappend(commonPart[-1] + \";\\n}\\n\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t# Standard statements\n\t\t\t\t\t\t\tdynvars = [dynvar.split(',') for dynvar in spltln[curSplt].split(';')]\n\t\t\t\t\t\t\tdynvars[-1][-1] = dynvars[-1][-1][:-1]\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\tif any(len(dynvar) != len(eq) + 1 for dynvar in dynvars):\n\t\t\t\t\t\t\t\tfail(ValueError, \"Not enough/too many possibilities in switch\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Reorganize dynvars so it matches [[variables], [set-if-A-true], ..., [set-else]]\n\t\t\t\t\t\t\tdynvars = list(map(lambda i: [dv[i] for dv in dynvars], range(len(dynvars[0]))))\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor if_, vals in zip(ifs[:-1], dynvars[1:]):\n\t\t\t\t\t\t\t\tappend(if_)\n\t\t\t\t\t\t\t\tfor var, val in zip(dynvars[0], vals):\n\t\t\t\t\t\t\t\t\tappend(var + \" = \" + val + \";\\n\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Else\n\t\t\t\t\t\t\tappend(ifs[-1])\n\t\t\t\t\t\t\tfor var, val in zip(dynvars[0], dynvars[-1]):\n\t\t\t\t\t\t\t\tappend(var + \" = \" + val + \";\\n\")\n\t\t\t\t\t\t\tappend(\"}\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\telif spltln[curSplt] == \"set\":\n\t\t\t\t\t\t# Set a (new?) variable\n\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\toldSplt = curSplt\n\t\t\t\t\t\twhile spltln[curSplt][-1] != '@':\n\t\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\t\t\tif len(spltln) == curSplt:\n\t\t\t\t\t\t\t\tfail(KeyError, \"End of '=' switch not found!\")\n\t\t\t\t\t\t\n\t\t\t\t\t\t# If the statement is empty just add a blank line\n\t\t\t\t\t\tif (oldSplt == curSplt) and (spltln[curSplt] == \"@\"):\n\t\t\t\t\t\t\tappend(\"\\n\")\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tappend(' '.join(spltln[oldSplt:curSplt + 1])[:-1] + \";\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tfail(KeyError, \"Unknown custom statement type '\" + spltln[curSplt] + \"'\")\n\t\t\t\tcurSplt = curSplt + 1\n\t\t\n\t\ttry:\n\t\t\tif spltln[0] == \"ARM_\":\n\t\t\t\t# ARM instruction\n\t\t\t\t\n\t\t\t\tvariables[\"cond\"] = -1\n\t\t\t\tvariables[\"registers\"] = {\n\t\t\t\t\t\"d\": [-1, -1, -1, -1, -1], # Register: #, ##, Rd, RdLo, RdHi\n\t\t\t\t\t\"t\": [-1, -1, -1], # Register: #, ##, Rt\n\t\t\t\t\t\"n\": [-1, -1, -1], # Register: #, ##, Rn\n\t\t\t\t\t\"m\": [-1, -1, -1], # Register: #, ##, Rm\n\t\t\t\t\t\"a\": [-1, -1, -1]  # Register: #, ##, Ra\n\t\t\t\t}\n\t\t\t\tvariables[\"reglist16\"] = -1 # Register list (16-bits)\n\t\t\t\t\n\t\t\t\tvariables[\"s\"] = -1 # Set flags\n\t\t\t\t\n\t\t\t\tvariables[\"u\"] = -1 # Unsigned\n\t\t\t\t\n\t\t\t\tvariables[\"r\"] = -1 # Rotate\n\t\t\t\t\n\t\t\t\tvariables[\"sb\"] = [-1, -1, -1] # lsb, msb\n\t\t\t\t\n\t\t\t\tvariables[\"w\"] = -1 # wback\n\t\t\t\t\n\t\t\t\tfor i, val in enumerate(spltln[1:]):\n\t\t\t\t\tif '/' in val:\n\t\t\t\t\t\tocurBit = curBit\n\t\t\t\t\t\treq = val.split('/')\n\t\t\t\t\t\tval, req = req[0], '/'.join(req[1:])\n\t\t\t\t\t\n\t\t\t\t\tif val == '0':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\telif val == '1':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\t\tcorrectBits[31 - curBit] = 1\n\t\t\t\t\telif (val == '(0)') or (val == '(1)'):\n\t\t\t\t\t\t# Ignore, even though the result should be undefined...\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\telif val == 'cond':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"cond\"] = curBit\n\t\t\t\t\telif val == 'Rd':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][2] = curBit\n\t\t\t\t\telif val == 'RdLo':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][3] = curBit\n\t\t\t\t\telif val == 'RdHi':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][4] = curBit\n\t\t\t\t\telif val == 'Rt':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"t\"][2] = curBit\n\t\t\t\t\telif val == 'Rn':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][2] = curBit\n\t\t\t\t\telif val == 'Rm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][2] = curBit\n\t\t\t\t\telif val == 'Ra':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"a\"][2] = curBit\n\t\t\t\t\telif val == 'S':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"s\"] = curBit\n\t\t\t\t\telif val == 'U':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"u\"] = curBit\n\t\t\t\t\telif val == 'W':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"w\"] = curBit\n\t\t\t\t\telif val == 'rotate':\n\t\t\t\t\t\tcurBit = curBit - 2\n\t\t\t\t\t\tvariables[\"r\"] = curBit\n\t\t\t\t\telif val == 'lsb':\n\t\t\t\t\t\tcurBit = curBit - 5\n\t\t\t\t\t\tvariables[\"sb\"][0] = curBit\n\t\t\t\t\telif val == 'msb':\n\t\t\t\t\t\tcurBit = curBit - 5\n\t\t\t\t\t\tvariables[\"sb\"][1] = curBit\n\t\t\t\t\telif val == 'widthm1':\n\t\t\t\t\t\tcurBit = curBit - 5\n\t\t\t\t\t\tvariables[\"sb\"][2] = curBit\n\t\t\t\t\telif val == 'register_list':\n\t\t\t\t\t\tcurBit = curBit - 16\n\t\t\t\t\t\tvariables[\"reglist16\"] = curBit\n\t\t\t\t\telif val == 'sat_imm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\timms.append([curBit, 4])\n\t\t\t\t\t\t\n\t\t\t\t\telif val.startswith('@<') and val.endswith('>'):\n\t\t\t\t\t\tparmlen = int(val[2:-1])\n\t\t\t\t\t\tcurBit = curBit - parmlen\n\t\t\t\t\t\tparm.append([curBit, parmlen])\n\t\t\t\t\telif val.startswith('imm'):\n\t\t\t\t\t\tif val.endswith('H') or val.endswith('L'): val = val[:-1]\n\t\t\t\t\t\timmsz = int(val[3:])\n\t\t\t\t\t\tcurBit = curBit - immsz\n\t\t\t\t\t\timms.append([curBit, immsz])\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tfail(KeyError, \"Unknown value '\" + val + \"'\")\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = i + 2\n\t\t\t\t\tparse_var_requirements()\n\t\t\t\t\t\n\t\t\t\t\tif curBit == 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telif curBit < 0:\n\t\t\t\t\t\tfail(KeyError, \"Current bit too low (\" + str(curBit) + \")\")\n\t\t\t\t\n\t\t\t\tif curSplt == -1:\n\t\t\t\t\tfail(KeyError, \"Not enough arguments\")\n\t\t\t\t\n\t\t\t\tgenerate_bin_test()\n\t\t\t\t\n\t\t\t\t# Add C variables\n\t\t\t\tif variables[\"s\"] != -1:\n\t\t\t\t\tappend(\"int s = (opcode >> \" + str(variables[\"s\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"cond\"] != -1:\n\t\t\t\t\tif mask[31 - variables[\"cond\"]] == 0:\n\t\t\t\t\t\tappend(\"const char* cond = conds[(opcode >> \" + str(variables[\"cond\"]) + \") & 0xF];\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"cond\"] = -2\n\t\t\t\tif variables[\"registers\"][\"d\"][2] != -1:\n\t\t\t\t\tappend(\"int rd = (opcode >> \" + str(variables[\"registers\"][\"d\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"d\"][3] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"d\"][4] != -1)\n\t\t\t\t\tappend(\"int rdlo = (opcode >> \" + str(variables[\"registers\"][\"d\"][3]) + \") & 0xF;\\n\")\n\t\t\t\t\tappend(\"int rdhi = (opcode >> \" + str(variables[\"registers\"][\"d\"][4]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"t\"][2] != -1:\n\t\t\t\t\tappend(\"int rt = (opcode >> \" + str(variables[\"registers\"][\"t\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"n\"][2] != -1:\n\t\t\t\t\tappend(\"int rn = (opcode >> \" + str(variables[\"registers\"][\"n\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"m\"][2] != -1:\n\t\t\t\t\tappend(\"int rm = (opcode >> \" + str(variables[\"registers\"][\"m\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"a\"][2] != -1:\n\t\t\t\t\tappend(\"int ra = (opcode >> \" + str(variables[\"registers\"][\"a\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"u\"] != -1:\n\t\t\t\t\tappend(\"int u = (opcode >> \" + str(variables[\"u\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"w\"] != -1:\n\t\t\t\t\tappend(\"int w = (opcode >> \" + str(variables[\"w\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"r\"] != -1:\n\t\t\t\t\tappend(\"int rot = (opcode >> \" + str(variables[\"r\"]) + \") & 3;\\nchar tmprot[8] = {0};\\n\")\n\t\t\t\t\tappend(\"if (rot) {\\nsprintf(tmprot, \\\" ror %d\\\", rot * 8);\\n}\\n\")\n\t\t\t\tif variables[\"sb\"][0] != -1:\n\t\t\t\t\tappend(\"int lsb = (opcode >> \" + str(variables[\"sb\"][0]) + \") & 0x1F;\\n\")\n\t\t\t\tif variables[\"sb\"][1] != -1:\n\t\t\t\t\tappend(\"int msb = (opcode >> \" + str(variables[\"sb\"][1]) + \") & 0x1F;\\n\")\n\t\t\t\tif variables[\"sb\"][2] != -1:\n\t\t\t\t\tappend(\"int widthm1 = (opcode >> \" + str(variables[\"sb\"][2]) + \") & 0x1F;\\n\")\n\t\t\t\tif variables[\"reglist16\"] != -1:\n\t\t\t\t\tappend(\"int reglist = (opcode >> \" + str(variables[\"reglist16\"]) + \") & 0xFFFF;\\n\")\n\t\t\t\tif imms != []:\n\t\t\t\t\timmssz = sum(map(lambda v: v[1], imms))\n\t\t\t\t\ttmp = \"(\" * len(imms)\n\t\t\t\t\tfor immpos, immsz in imms:\n\t\t\t\t\t\tif tmp[-1] != '(': tmp = tmp + \" << \" + str(immsz) + \") | \"\n\t\t\t\t\t\ttmp = tmp + \"((opcode >> \" + str(immpos) + \") & \" + sz2str(immsz) + \")\"\n\t\t\t\t\ttmp = tmp[1:]\n\t\t\t\t\tappend(\"uint\" + str(nextAvailable(immssz)) + \"_t imm\" + str(immssz) + \" = \" + tmp + \";\\n\")\n\t\t\t\t\t\n\t\t\t\t\t# Destroy imms since we don't need it anymore, but we do need immssz\n\t\t\t\t\timms = immssz\n\t\t\t\t\n\t\t\t\tadd_custom_variables()\n\t\t\t\t\n\t\t\t\tappend(\"\\nsprintf(ret, \\\"\")\n\t\t\t\t\n\t\t\t\t# Assemble the variables into the printf\n\t\t\t\tinstText = ' '.join(spltln[curSplt:]).split('<')\n\t\t\t\tinstText = [instTextPart.split('>') for instTextPart in instText]\n\t\t\t\tinstText = [itp for itp2 in instText for itp in itp2]\n\t\t\t\t\n\t\t\t\t# Make the failures nicer\n\t\t\t\tspltln = spltln[:curSplt] + [\"\\x01\"] + instText\n\t\t\t\t\n\t\t\t\tprintf_args = \"\"\n\t\t\t\tfor idx, text in enumerate(instText):\n\t\t\t\t\ttext = text.replace(\"&l\", \"<\").replace(\"&g\", \">\")\n\t\t\t\t\t\n\t\t\t\t\tif \"+/-\" in text:\n\t\t\t\t\t\ttext = text.replace(\"+/-\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (u ? \\\"\\\" : \\\"-\\\")\"\n\t\t\t\t\tif \"{!}\" in text:\n\t\t\t\t\t\ttext = text.replace(\"{!}\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (w ? \\\"!\\\" : \\\"\\\")\"\n\t\t\t\t\t\n\t\t\t\t\tskiprbr = False\n\t\t\t\t\tif idx % 2:\n\t\t\t\t\t\tif text == \"c\":\n\t\t\t\t\t\t\tif variables[\"cond\"] >= 0:\n\t\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", cond\"\n\t\t\t\t\t\telif text == \"Rd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rd]\"\n\t\t\t\t\t\telif text == \"RdLo\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rdlo]\"\n\t\t\t\t\t\telif text == \"RdHi\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rdhi]\"\n\t\t\t\t\t\telif text == \"Rt\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rt]\"\n\t\t\t\t\t\telif text == \"Rt2\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rt + 1]\"\n\t\t\t\t\t\telif text == \"Rn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rn]\"\n\t\t\t\t\t\telif text == \"Rm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rm]\"\n\t\t\t\t\t\telif text == \"Ra\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[ra]\"\n\t\t\t\t\t\telif text == \"const\":\n\t\t\t\t\t\t\tassert(imms == 12)\n\t\t\t\t\t\t\tappend(\"0x%x\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", print_modified_imm_ARM(imm12)\"\n\t\t\t\t\t\telif text == \"rotation\":\n\t\t\t\t\t\t\tif output.endswith(\"{, \"):\n\t\t\t\t\t\t\t\toutput = output[:-3]\n\t\t\t\t\t\t\t\tskiprbr = True\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", tmprot\"\n\t\t\t\t\t\telif text == \"label\":\n\t\t\t\t\t\t\tappend(\"%+d\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", (imm24 & 0x800000 ? imm24 | 0xFF000000 : imm24) + 2\"\n\t\t\t\t\t\telif text == \"lsb\":\n\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", lsb\"\n\t\t\t\t\t\telif text == \"width\":\n\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\tprintf_args = printf_args + (\", msb - lsb + 1\" if variables[\"sb\"][1] != -1 else \", widthm1 + 1\")\n\t\t\t\t\t\telif text == \"registers\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", print_register_list(reglist, 16)\"\n\t\t\t\t\t\telif text == \"imm\":\n\t\t\t\t\t\t\t#append(\"0x%0\" + str(ceil(imms / 4)) + \"x\")\n\t\t\t\t\t\t\tappend(\"0x%x\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", imm\" + str(imms)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\telif text.startswith(\"imm\"):\n\t\t\t\t\t\t\tif variables[\"u\"] != -1:\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t#append(\"0x%0\" + str(ceil(int(text[3:]) / 4)) + \"x\")\n\t\t\t\t\t\t\t\tappend(\"0x%x\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", \" + text\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfail(KeyError, \"Unknown variable \" + text)\n\t\t\t\t\telif text.endswith(\"{S}\"):\n\t\t\t\t\t\tappend(text[:-3] + \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (s ? \\\"S\\\" : \\\"\\\")\"\n\t\t\t\t\telse:\n\t\t\t\t\t\tif text == \"\":\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\ttext = text.split('\\\\')\n\t\t\t\t\t\twhile len(text) > 1:\n\t\t\t\t\t\t\tif text[1][0] == '%':\n\t\t\t\t\t\t\t\tmodifier, text[1] = '%', text[1][1:]\n\t\t\t\t\t\t\t\twhile (len(text[1]) > 1) \\\n\t\t\t\t\t\t\t\tand (text[1][0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']):\n\t\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tappend(text[0] + modifier)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tappend(text[0] + \"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", \" + text[1]\n\t\t\t\t\t\t\ttext = text[2:]\n\t\t\t\t\t\tif len(text) == 0:\n\t\t\t\t\t\t\tfail(AssertionError, \"Substitution not finished\")\n\t\t\t\t\t\tif skiprbr and (text[0][0] == \"}\"):\n\t\t\t\t\t\t\ttext[0] = text[0][1:]\n\t\t\t\t\t\tappend(text[0])\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\tappend(\"\\\"\" + printf_args + \");\\n} else \")\n\t\t\t\t\n\t\t\telif (spltln[0].upper() == \"ARMS\") or (spltln[0] == \"ARM$\"):\n\t\t\t\t# ARM Shift instruction\n\t\t\t\t# ARMs is only with immediate, ARM$ is only with register\n\t\t\t\t\n\t\t\t\tvariables[\"cond\"] = -1\n\t\t\t\tvariables[\"registers\"] = {\n\t\t\t\t\t\"d\": [-1, -1, -1], # Register: #, ##, Rd\n\t\t\t\t\t\"t\": [-1, -1, -1], # Register: #, ##, Rt\n\t\t\t\t\t\"n\": [-1, -1, -1], # Register: #, ##, Rn\n\t\t\t\t\t\"m\": [-1, -1, -1]  # Register: #, ##, Rm\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvariables[\"s\"] = -1 # Set flags\n\t\t\t\t\n\t\t\t\tvariables[\"u\"] = -1 # Unsigned shift\n\t\t\t\t\n\t\t\t\tvariables[\"w\"] = -1 # wback (used in adressing)\n\t\t\t\t\n\t\t\t\tvariables[\"shift\"] = False # Shift already detected?\n\t\t\t\t\n\t\t\t\tfor i, val in enumerate(spltln[1:]):\n\t\t\t\t\tif '/' in val:\n\t\t\t\t\t\tocurBit = curBit\n\t\t\t\t\t\treq = val.split('/')\n\t\t\t\t\t\tval, req = req[0], '/'.join(req[1:])\n\t\t\t\t\t\n\t\t\t\t\tif val == '0':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\telif val == '1':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\t\tcorrectBits[31 - curBit] = 1\n\t\t\t\t\telif (val == '(0)') or (val == '(1)'):\n\t\t\t\t\t\t# Ignore, even though the result should be undefined...\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\telif val == 'cond':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"cond\"] = curBit\n\t\t\t\t\telif val == 'Rd':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][2] = curBit\n\t\t\t\t\telif val == 'Rt':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"t\"][2] = curBit\n\t\t\t\t\telif val == 'Rn':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][2] = curBit\n\t\t\t\t\telif val == 'Rm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][2] = curBit\n\t\t\t\t\telif val == 'S':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"s\"] = curBit\n\t\t\t\t\telif val == 'U':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"u\"] = curBit\n\t\t\t\t\telif val == 'W':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"w\"] = curBit\n\t\t\t\t\telif val == 'type':\n\t\t\t\t\t\tcurBit = curBit - 2\n\t\t\t\t\t\timms.append([curBit, 2])\n\t\t\t\t\t\tvariables[\"shift\"] = True\n\t\t\t\t\telif val == 'sat_imm':\n\t\t\t\t\t\tcurBit = curBit - 5\n\t\t\t\t\t\timms.append([curBit, 5, True])\n\t\t\t\t\telif val == 'sh':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\t\n\t\t\t\t\telif val.startswith('@<') and val.endswith('>'):\n\t\t\t\t\t\tparmlen = int(val[2:-1])\n\t\t\t\t\t\tcurBit = curBit - parmlen\n\t\t\t\t\t\tparm.append([curBit, parmlen])\n\t\t\t\t\telif val.startswith('imm'):\n\t\t\t\t\t\tif variables[\"shift\"]: fail(ValueError, \"Immediate after a 'type' value detected\")\n\t\t\t\t\t\timmsz = int(val[3:])\n\t\t\t\t\t\tcurBit = curBit - immsz\n\t\t\t\t\t\timms.append([curBit, immsz])\n\t\t\t\t\t\tvariables[\"shift\"] = immsz == 12\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tfail(KeyError, \"Unknown value '\" + val + \"'\")\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = i + 2\n\t\t\t\t\tparse_var_requirements()\n\t\t\t\t\t\n\t\t\t\t\tif curBit == 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telif curBit < 0:\n\t\t\t\t\t\tfail(KeyError, \"Current bit too low (\" + str(curBit) + \")\")\n\t\t\t\t\n\t\t\t\tif curSplt == -1:\n\t\t\t\t\tfail(KeyError, \"Not enough arguments\")\n\t\t\t\t# There is not necessarily an explicit shift when using an ARMs\n\t\t\t\telif not variables[\"shift\"] and (spltln[0] == \"ARMS\"):\n\t\t\t\t\tfail(KeyError, \"No shift detected\")\n\t\t\t\t\n\t\t\t\t# Assumption:\n\t\t\t\t# bytes 11-4 are [imm5 type 0] (then auto-complete for [Rs 0 type 1 Rm])\n\t\t\t\tif (spltln[0] == \"ARMS\") and ((mask[20:24] + mask[25:28] != [0, 0, 0, 0, 0, 0, 1]) \\\n\t\t\t\t or ((correctBits[27] != 0) or (len(imms) != 2) or (imms[0] != [7, 5]))):\n\t\t\t\t\tfail(NotImplementedError, \"Unknown case with shift\")\n\t\t\t\t\n\t\t\t\tif (spltln[0] == \"ARMS\"):\n\t\t\t\t\tgenerate_bin_test([24, 27], [[(0, 0), (1, 0)], [(1, 0), (1, 1)]])\n\t\t\t\telse:\n\t\t\t\t\tgenerate_bin_test()\n\t\t\t\t\n\t\t\t\t# Add C variables\n\t\t\t\tif variables[\"s\"] != -1:\n\t\t\t\t\tappend(\"int s = (opcode >> \" + str(variables[\"s\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"cond\"] != -1:\n\t\t\t\t\tif mask[31 - variables[\"cond\"]] == 0:\n\t\t\t\t\t\tappend(\"const char* cond = conds[(opcode >> \" + str(variables[\"cond\"]) + \") & 0xF];\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"cond\"] = -2\n\t\t\t\tif variables[\"registers\"][\"d\"][2] != -1:\n\t\t\t\t\tappend(\"int rd = (opcode >> \" + str(variables[\"registers\"][\"d\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"t\"][2] != -1:\n\t\t\t\t\tappend(\"int rt = (opcode >> \" + str(variables[\"registers\"][\"t\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"n\"][2] != -1:\n\t\t\t\t\tappend(\"int rn = (opcode >> \" + str(variables[\"registers\"][\"n\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"m\"][2] != -1:\n\t\t\t\t\tappend(\"int rm = (opcode >> \" + str(variables[\"registers\"][\"m\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"u\"] != -1:\n\t\t\t\t\tappend(\"int u = (opcode >> \" + str(variables[\"u\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"w\"] != -1:\n\t\t\t\t\tappend(\"int w = (opcode >> \" + str(variables[\"w\"]) + \") & 1;\\n\")\n\t\t\t\tif (len(imms) == 2) and (len(imms[0]) == 3):\n\t\t\t\t\tappend(\"uint8_t imm = ((opcode >> \" + str(imms[0][0]) + \") & 0x1F) + 1;\\n\")\n\t\t\t\tappend(\"uint8_t shift = ((opcode >> 4) & \" + \\\n\t\t\t\t\t(\"0xFF)\" if (spltln[0] == \"ARMS\") else (\"0xFE)\" if (spltln[0] == \"ARMs\") else \"0xFF) | 0x01\")) + \\\n\t\t\t\t\t\";\\n\")\n\t\t\t\t\n\t\t\t\tadd_custom_variables()\n\t\t\t\t\n\t\t\t\tappend(\"\\nsprintf(ret, \\\"\")\n\t\t\t\t\n\t\t\t\t# Assemble the variables into the printf\n\t\t\t\tinstText = ' '.join(spltln[curSplt:]).split('<')\n\t\t\t\tinstText = [instTextPart.split('>') for instTextPart in instText]\n\t\t\t\tinstText = [itp for itp2 in instText for itp in itp2]\n\t\t\t\t\n\t\t\t\t# Make the failures nicer\n\t\t\t\tspltln = spltln[:curSplt] + [\"\\x01\"] + instText\n\t\t\t\t\n\t\t\t\tprintf_args = \"\"\n\t\t\t\tfor idx, text in enumerate(instText):\n\t\t\t\t\ttext = text.replace(\"&l\", \"<\").replace(\"&g\", \">\")\n\t\t\t\t\t\n\t\t\t\t\tif \"+/-\" in text:\n\t\t\t\t\t\ttext = text.replace(\"+/-\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (u ? \\\"\\\" : \\\"-\\\")\"\n\t\t\t\t\tif \"{!}\" in text:\n\t\t\t\t\t\ttext = text.replace(\"{!}\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (w ? \\\"!\\\" : \\\"\\\")\"\n\t\t\t\t\t\n\t\t\t\t\tif idx % 2:\n\t\t\t\t\t\tif text == \"c\":\n\t\t\t\t\t\t\tif variables[\"cond\"] != -1:\n\t\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", cond\"\n\t\t\t\t\t\telif text == \"Rd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rd]\"\n\t\t\t\t\t\telif text == \"Rt\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rt]\"\n\t\t\t\t\t\telif text == \"Rt2\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rt + 1]\"\n\t\t\t\t\t\telif text == \"Rn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rn]\"\n\t\t\t\t\t\telif text == \"Rm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rm]\"\n\t\t\t\t\t\telif text == \"imm\":\n\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", imm\"\n\t\t\t\t\t\telif text == \"shift\":\n\t\t\t\t\t\t\t# Tricky, since it is optional, but I want to have a pure copy-paste of the official doc\n\t\t\t\t\t\t\t# so we remove the end of the output if necessary\n\t\t\t\t\t\t\t# Otherwise it is as usual, however we use the print_shift method\n\t\t\t\t\t\t\tcomma = \"0\"\n\t\t\t\t\t\t\tif output.endswith(\"{, \"):\n\t\t\t\t\t\t\t\toutput = output[:-3]\n\t\t\t\t\t\t\t\tcomma = \"1\"\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", print_shift(shift, \" + comma + \")\"\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfail(KeyError, \"Unknown variable \" + text)\n\t\t\t\t\telif text.endswith(\"{S}\"):\n\t\t\t\t\t\tappend(text[:-3] + \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (s ? \\\"S\\\" : \\\"\\\")\"\n\t\t\t\t\telif text.startswith(\"}\"):\n\t\t\t\t\t\tappend(text[1:])\n\t\t\t\t\telse:\n\t\t\t\t\t\tif text == \"\":\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\ttext = text.split('\\\\')\n\t\t\t\t\t\twhile len(text) > 1:\n\t\t\t\t\t\t\tif text[1][0] == '%':\n\t\t\t\t\t\t\t\tmodifier, text[1] = '%', text[1][1:]\n\t\t\t\t\t\t\t\twhile (len(text[1]) > 1) \\\n\t\t\t\t\t\t\t\tand (text[1][0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']):\n\t\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tappend(text[0] + modifier)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tappend(text[0] + \"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", \" + text[1]\n\t\t\t\t\t\t\ttext = text[2:]\n\t\t\t\t\t\tif len(text) == 0:\n\t\t\t\t\t\t\tfail(AssertionError, \"Substitution not finished\")\n\t\t\t\t\t\tappend(text[0])\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\tappend(\"\\\"\" + printf_args + \");\\n} else \")\n\t\t\t\t\n\t\t\telif spltln[0] == \"NEON\":\n\t\t\t\t# NEON (advanced SIMD) instruction\n\t\t\t\t\n\t\t\t\tvariables[\"registers\"] = {\n\t\t\t\t\t\"d\": [-1, -1, -1], # Register: D, Vd, ##\n\t\t\t\t\t\"t\": [-1, -1, -1], # Register: #, ##, Rt\n\t\t\t\t\t\"n\": [-1, -1, -1], # Register: N, Vn, ##\n\t\t\t\t\t\"m\": [-1, -1, -1]  # Register: M, Vm, ##\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvariables[\"op\"] = -1 # Operation\n\t\t\t\tvariables[\"u\"] = -1 # Unsigned\n\t\t\t\tvariables[\"f\"] = -1 # Floating-point\n\t\t\t\tvariables[\"sz\"] = [-1, 0] # Operation size: pos, len\n\t\t\t\t\n\t\t\t\tvariables[\"cmode\"] = -1 # Used with immediates\n\t\t\t\t\n\t\t\t\tvariables[\"q\"] = -1 # Quadword\n\t\t\t\t\n\t\t\t\tfor i, val in enumerate(spltln[1:]):\n\t\t\t\t\tif '/' in val:\n\t\t\t\t\t\tocurBit = curBit\n\t\t\t\t\t\treq = val.split('/')\n\t\t\t\t\t\tval, req = req[0], '/'.join(req[1:])\n\t\t\t\t\t\n\t\t\t\t\tif val == '0':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\telif val == '1':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\t\tcorrectBits[31 - curBit] = 1\n\t\t\t\t\telif (val == '(0)') or (val == '(1)'):\n\t\t\t\t\t\t# Ignore, even though the result should be undefined...\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\telif val == 'D':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][0] = curBit\n\t\t\t\t\telif val == 'Vd':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][1] = curBit\n\t\t\t\t\telif val == 'Rt':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"t\"][2] = curBit\n\t\t\t\t\telif val == 'N':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][0] = curBit\n\t\t\t\t\telif val == 'Vn':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][1] = curBit\n\t\t\t\t\telif val == 'Rn':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][2] = curBit\n\t\t\t\t\telif val == 'M':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][0] = curBit\n\t\t\t\t\telif val == 'Vm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][1] = curBit\n\t\t\t\t\telif val == 'Rm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][2] = curBit\n\t\t\t\t\telif val == 'U':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"u\"] = curBit\n\t\t\t\t\telif val == 'F':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"f\"] = curBit\n\t\t\t\t\telif val == 'op':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"op\"] = curBit\n\t\t\t\t\telif val == 'cmode':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"cmode\"] = curBit\n\t\t\t\t\telif val == 'size':\n\t\t\t\t\t\tcurBit = curBit - 2\n\t\t\t\t\t\tvariables[\"sz\"] = [curBit, 2]\n\t\t\t\t\telif val == 'sz':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"sz\"] = [curBit, 1]\n\t\t\t\t\telif val == 'Q':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"q\"] = curBit\n\t\t\t\t\telif val == 'i':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\timms.append([curBit, 1, val])\n\t\t\t\t\telif val == 'L':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\timms.append([curBit, 1, val])\n\t\t\t\t\t\t\n\t\t\t\t\telif val.startswith('@<') and val.endswith('>'):\n\t\t\t\t\t\tparmlen = int(val[2:-1])\n\t\t\t\t\t\tcurBit = curBit - parmlen\n\t\t\t\t\t\tparm.append([curBit, parmlen])\n\t\t\t\t\telif val.lower().startswith('imm'):\n\t\t\t\t\t\timmsz = int(val[3:])\n\t\t\t\t\t\tcurBit = curBit - immsz\n\t\t\t\t\t\timms.append([curBit, immsz, val])\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tfail(KeyError, \"Unknown value '\" + val + \"'\")\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = i + 2\n\t\t\t\t\tparse_var_requirements()\n\t\t\t\t\t\n\t\t\t\t\tif curBit == 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telif curBit < 0:\n\t\t\t\t\t\tfail(KeyError, \"Current bit too low (\" + str(curBit) + \")\")\n\t\t\t\t\n\t\t\t\tif curSplt == -1:\n\t\t\t\t\tfail(KeyError, \"Not enough arguments\")\n\t\t\t\t\n\t\t\t\tgenerate_bin_test()\n\t\t\t\t\n\t\t\t\t# Add C variables\n\t\t\t\tif variables[\"op\"] != -1:\n\t\t\t\t\tappend(\"int op = (opcode >> \" + str(variables[\"op\"]) + \") & 1;\\n\")\n\t\t\t\tif (variables[\"u\"] != -1) and (variables[\"f\"] != -1):\n\t\t\t\t\tfail(ValueError, \"Cannot have both unsigned and floating-point\", False)\n\t\t\t\tif variables[\"u\"] != -1:\n\t\t\t\t\tappend(\"int u = (opcode >> \" + str(variables[\"u\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"f\"] != -1:\n\t\t\t\t\tappend(\"int f = (opcode >> \" + str(variables[\"f\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"sz\"][0] != -1:\n\t\t\t\t\tif (mask[31 - variables[\"sz\"][0]] == 0) and ((variables[\"sz\"][1] == 1) or (mask[30 - variables[\"sz\"][0]] == 0)):\n\t\t\t\t\t\tappend(\"int size = (opcode >> \" + str(variables[\"sz\"][0]) + \") & \" + sz2str(variables[\"sz\"][1]) + \";\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"sz\"][0] = -2\n\t\t\t\tif variables[\"q\"] != -1:\n\t\t\t\t\tif mask[31 - variables[\"q\"]] == 0:\n\t\t\t\t\t\tappend(\"int q = (opcode >> \" + str(variables[\"q\"]) + \") & 1;\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"q\"] = -2\n\t\t\t\tif variables[\"registers\"][\"d\"][0] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"d\"][1] != -1)\n\t\t\t\t\tappend(\"int d = ((opcode >> \" + str(variables[\"registers\"][\"d\"][0]) + \") & 1) << 4 \" + \\\n\t\t\t\t\t\t\"| ((opcode >> \" + str(variables[\"registers\"][\"d\"][1]) + \") & 0xF);\\n\")\n\t\t\t\tif variables[\"registers\"][\"t\"][2] != -1:\n\t\t\t\t\tappend(\"int rt = (opcode >> \" + str(variables[\"registers\"][\"t\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"n\"][0] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"n\"][1] != -1)\n\t\t\t\t\tappend(\"int n = ((opcode >> \" + str(variables[\"registers\"][\"n\"][0]) + \") & 1) << 4 \" + \\\n\t\t\t\t\t\t\"| ((opcode >> \" + str(variables[\"registers\"][\"n\"][1]) + \") & 0xF);\\n\")\n\t\t\t\tif variables[\"registers\"][\"n\"][2] != -1:\n\t\t\t\t\tappend(\"int rn = (opcode >> \" + str(variables[\"registers\"][\"n\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"m\"][0] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"m\"][1] != -1)\n\t\t\t\t\tappend(\"int m = ((opcode >> \" + str(variables[\"registers\"][\"m\"][0]) + \") & 1) << 4 \" + \\\n\t\t\t\t\t\t\"| ((opcode >> \" + str(variables[\"registers\"][\"m\"][1]) + \") & 0xF);\\n\")\n\t\t\t\tif variables[\"registers\"][\"m\"][2] != -1:\n\t\t\t\t\tappend(\"int rm = (opcode >> \" + str(variables[\"registers\"][\"m\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"cmode\"] != -1:\n\t\t\t\t\tappend(\"int cmode = (opcode >> \" + str(variables[\"cmode\"]) + \") & 0xF;\\n\")\n\t\t\t\tif imms != []:\n\t\t\t\t\tif (variables[\"cmode\"] != -1) and (variables[\"op\"] != -1):\n\t\t\t\t\t\t# Modified immediate value\n\t\t\t\t\t\t\n\t\t\t\t\t\t# Assert unique imms pattern since this is a NEON instruction, reduce the result's length\n\t\t\t\t\t\tassert(imms == [[24, 1, 'i'], [16, 3, 'imm3'], [0, 4, 'imm4']])\n\t\t\t\t\t\tappend(\"uint8_t imm8 = \" + \\\n\t\t\t\t\t\t\t\"(((opcode >> 24) & 0x1) << 7) | (((opcode >> 16) & 0x7) << 4) | (opcode & 0xF);\" + \\\n\t\t\t\t\t\t\t\"\\nconst char* decodedImm = print_modified_imm_NEON((op << 4) + cmode, imm8);\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\t\timms = [0, 8] + imms\n\t\t\t\t\telif imms[0][1] in [6]:\n\t\t\t\t\t\t# Shift value\n\t\t\t\t\t\tassert((len(imms) == 1) or ((len(imms) == 2) and (imms[1][2] == 'L')))\n\t\t\t\t\t\t\n\t\t\t\t\t\tl = len(imms) == 2\n\t\t\t\t\t\tif l:\n\t\t\t\t\t\t\tappend(\"uint8_t l = (opcode >> \" + str(imms[1][0]) + \") & 0x1;\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\t\timmssz = 6\n\t\t\t\t\t\tappend(\"uint8_t imm6 = (opcode >> \" + str(imms[0][0]) + \") & 0x3F;\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tif imms[0][2][:3] != \"IMM\":\n\t\t\t\t\t\t\tappend(\"uint8_t decodedImm = 0;\\nuint8_t size = 0;\\n\")\n\t\t\t\t\t\t\tif imms[0][2][:3] == \"imm\":\n\t\t\t\t\t\t\t\tappend(\n\t\t\t\t\t\t\t\t\t(\"if (l == 1) {\\ndecodedImm = 64 - imm6;\\nsize = 3;\\n} else \" if l else \"\") + \\\n\t\t\t\t\t\t\t\t\t\"if (imm6 & 0x20) {\\ndecodedImm = 64 - imm6;\\nsize = 2;\\n} else \" + \\\n\t\t\t\t\t\t\t\t\t\"if (imm6 & 0x10) {\\ndecodedImm = 32 - imm6;\\nsize = 1;\\n} else \" + \\\n\t\t\t\t\t\t\t\t\t\"{\\ndecodedImm = 16 - imm6;\\n}\\n\"\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tappend(\n\t\t\t\t\t\t\t\t\t(\"if (l == 1) {\\ndecodedImm = imm6;\\nsize = 3;\\n} else \" if l else \"\") + \\\n\t\t\t\t\t\t\t\t\t\"if (imm6 & 0x20) {\\ndecodedImm = imm6 - 32;\\nsize = 2;\\n\" + \\\n\t\t\t\t\t\t\t\t\t\"} else if (imm6 & 0x10) {\\ndecodedImm = imm6 - 16;\\nsize = 1;\\n\" + \\\n\t\t\t\t\t\t\t\t\t\"} else {\\ndecodedImm = imm6 - 8;\\n}\\n\"\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\n\t\t\t\t\t\timms = [1, immssz] + imms\n\t\t\t\t\telif imms[0][1] == 4:\n\t\t\t\t\t\t# Weird shift...\n\t\t\t\t\t\tassert(len(imms) == 1)\n\t\t\t\t\t\t\n\t\t\t\t\t\timmssz = 4\n\t\t\t\t\t\tappend(\"uint8_t imm4 = (opcode >> \" + str(imms[0][0]) + \") & 0xF;\\n\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tif imms[0][2][:3] != \"IMM\":\n\t\t\t\t\t\t\tappend(\n\t\t\t\t\t\t\t\t\"uint8_t decodedImm = 0;\\nuint8_t size = 0;\\n\" + \\\n\t\t\t\t\t\t\t\t\"if (imm4 & 0b0001) {\\ndecodedImm = imm4 >> 1;\\nsize = 8;\\n} else \" + \\\n\t\t\t\t\t\t\t\t\"if (imm4 & 0b0011) {\\ndecodedImm = imm4 >> 2;\\nsize = 16;\\n} else \" + \\\n\t\t\t\t\t\t\t\t\"if (imm4 & 0b0111) {\\ndecodedImm = imm4 >> 3;\\nsize = 32;\\n}\\n\"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\n\t\t\t\t\t\timms = [2, immssz] + imms\n\t\t\t\t\n\t\t\t\tadd_custom_variables()\n\t\t\t\t\n\t\t\t\tappend(\"\\nsprintf(ret, \\\"\")\n\t\t\t\t\n\t\t\t\t# Assemble the variables into the printf\n\t\t\t\tinstText = ' '.join(spltln[curSplt:]).split('<')\n\t\t\t\tinstText = [instTextPart.split('>') for instTextPart in instText]\n\t\t\t\tinstText = [itp for itp2 in instText for itp in itp2]\n\t\t\t\t\n\t\t\t\t# Make the failures nicer\n\t\t\t\tspltln = spltln[:curSplt] + [\"\\x01\"] + instText\n\t\t\t\t\n\t\t\t\tprintf_args = \"\"\n\t\t\t\tfor idx, text in enumerate(instText):\n\t\t\t\t\ttext = text.replace(\"&l\", \"<\").replace(\"&g\", \">\")\n\t\t\t\t\t\n\t\t\t\t\tif \"+/-\" in text:\n\t\t\t\t\t\ttext = text.replace(\"+/-\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (u ? \\\"\\\" : \\\"-\\\")\"\n\t\t\t\t\t\n\t\t\t\t\tif idx % 2:\n\t\t\t\t\t\tif text == \"c\":\n\t\t\t\t\t\t\tpass\n\t\t\t\t\t\telif text == \"dt\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tif imms == []:\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", dts[\" + (\"0x8 + (f << 2) + \" if variables[\"f\"] != -1 else \"\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + (\"(u << 2) + \" if variables[\"u\"] != -1 else \"\") + \"size]\"\n\t\t\t\t\t\t\telif imms[0] == 0:\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", decodedImm\"\n\t\t\t\t\t\t\telif imms[0] == 1:\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", dts[\" + (\"0x8 + (f << 2) + \" if variables[\"f\"] != -1 else \"\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + (\"(u << 2) + \" if variables[\"u\"] != -1 else \"\") + \"size]\"\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {} (on dt)\".format(imms[0]))\n\t\t\t\t\t\telif text == \"size\":\n\t\t\t\t\t\t\tif imms[0] == 1:\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", 8 << size\"\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {} (on size)\".format(imms[0]))\n\t\t\t\t\t\telif text == \"Qd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(q << 5) + 0x20\" if variables[\"q\"] != -1 else \"0x40\") + \" + d]\"\n\t\t\t\t\t\telif text == \"qd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[0x40 + d]\"\n\t\t\t\t\t\telif text == \"Dd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[0x20 + d]\"\n\t\t\t\t\t\telif text == \"Rt\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rt]\"\n\t\t\t\t\t\telif text == \"Qn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(q << 5) + 0x20\" if variables[\"q\"] != -1 else \"0x40\") + \" + n]\"\n\t\t\t\t\t\telif text == \"Dn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[0x20 + n]\"\n\t\t\t\t\t\telif text == \"Rn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rn]\"\n\t\t\t\t\t\telif text == \"Qm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(q << 5) + 0x20\" if variables[\"q\"] != -1 else \"0x40\") + \" + m]\"\n\t\t\t\t\t\telif text == \"Dm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[0x20 + m]\"\n\t\t\t\t\t\telif text == \"Dm[x]\":\n\t\t\t\t\t\t\tappend(\"%s[%d]\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[0x20 + m], decodedImm\"\n\t\t\t\t\t\telif text == \"Rm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rm]\"\n\t\t\t\t\t\telif text == \"imm\":\n\t\t\t\t\t\t\tif imms[0] == 0:\n\t\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", decodedImm + 4\"\n\t\t\t\t\t\t\telif imms[0] == 1:\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", decodedImm\"\n\t\t\t\t\t\t\telif imms[0] == 2:\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", imm4\"\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {}\".format(imms[0]))\n\t\t\t\t\t\telif text == \"fbits\":\n\t\t\t\t\t\t\tif (imms[0] == 1) and (imms[2][2][:3] == \"IMM\"):\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", 64 - imm6\"\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {} (first imm = {})\".format(imms[0], imms[2][2]))\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfail(KeyError, \"Unknown variable \" + text)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif text == \"\":\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\ttext = text.split('\\\\')\n\t\t\t\t\t\twhile len(text) > 1:\n\t\t\t\t\t\t\tif text[1][0] == '%':\n\t\t\t\t\t\t\t\tmodifier, text[1] = '%', text[1][1:]\n\t\t\t\t\t\t\t\twhile (len(text[1]) > 1) \\\n\t\t\t\t\t\t\t\tand (text[1][0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']):\n\t\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tappend(text[0] + modifier)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tappend(text[0] + \"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", \" + text[1]\n\t\t\t\t\t\t\ttext = text[2:]\n\t\t\t\t\t\tif len(text) == 0:\n\t\t\t\t\t\t\tfail(AssertionError, \"Substitution not finished\")\n\t\t\t\t\t\tappend(text[0])\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\tappend(\"\\\"\" + printf_args + \");\\n} else \")\n\t\t\t\t\n\t\t\telif spltln[0] == \"VFPU\":\n\t\t\t\t# vFPU instruction\n\t\t\t\t\n\t\t\t\tvariables[\"cond\"] = -1\n\t\t\t\tvariables[\"registers\"] = {\n\t\t\t\t\t\"d\": [-1, -1, -1], # Register: D, Vd, ##\n\t\t\t\t\t\"t\": [-1, -1, -1], # Register: #, ##, Rt\n\t\t\t\t\t\"n\": [-1, -1, -1], # Register: N, Vn, Rn\n\t\t\t\t\t\"m\": [-1, -1, -1]  # Register: M, Vm, ##\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvariables[\"op\"] = -1 # Operation\n\t\t\t\tvariables[\"u\"] = -1 # Unsigned\n\t\t\t\tvariables[\"f\"] = -1 # Floating-point\n\t\t\t\tvariables[\"sz\"] = [-1, 0] # Operation size: pos, len\n\t\t\t\t\n\t\t\t\tvariables[\"cmode\"] = -1 # Used with immediates\n\t\t\t\t\n\t\t\t\tvariables[\"q\"] = -1 # Quadword\n\t\t\t\t\n\t\t\t\tvariables[\"w\"] = -1 # wback\n\t\t\t\t\n\t\t\t\tfor i, val in enumerate(spltln[1:]):\n\t\t\t\t\tif '/' in val:\n\t\t\t\t\t\tocurBit = curBit\n\t\t\t\t\t\treq = val.split('/')\n\t\t\t\t\t\tval, req = req[0], '/'.join(req[1:])\n\t\t\t\t\t\n\t\t\t\t\tif val == '0':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\telif val == '1':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\t\tcorrectBits[31 - curBit] = 1\n\t\t\t\t\telif (val == '(0)') or (val == '(1)'):\n\t\t\t\t\t\t# Ignore, even though the result should be undefined...\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\telif val == 'cond':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"cond\"] = curBit\n\t\t\t\t\telif val == 'D':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][0] = curBit\n\t\t\t\t\telif val == 'Vd':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"d\"][1] = curBit\n\t\t\t\t\telif val == 'Rt':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"t\"][2] = curBit\n\t\t\t\t\telif val == 'N':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][0] = curBit\n\t\t\t\t\telif val == 'Vn':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][1] = curBit\n\t\t\t\t\telif val == 'Rn':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"n\"][2] = curBit\n\t\t\t\t\telif val == 'M':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][0] = curBit\n\t\t\t\t\telif val == 'Vm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][1] = curBit\n\t\t\t\t\telif val == 'Rm':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"registers\"][\"m\"][2] = curBit\n\t\t\t\t\telif val == 'U':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"u\"] = curBit\n\t\t\t\t\telif val == 'F':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"f\"] = curBit\n\t\t\t\t\telif val == 'W':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"w\"] = curBit\n\t\t\t\t\telif val == 'op':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"op\"] = curBit\n\t\t\t\t\telif val == 'cmode':\n\t\t\t\t\t\tcurBit = curBit - 4\n\t\t\t\t\t\tvariables[\"cmode\"] = curBit\n\t\t\t\t\telif val == 'size':\n\t\t\t\t\t\tcurBit = curBit - 2\n\t\t\t\t\t\tvariables[\"sz\"] = [curBit, 2]\n\t\t\t\t\telif val == 'sz':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"sz\"] = [curBit, 1]\n\t\t\t\t\telif val == 'Q':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tvariables[\"q\"] = curBit\n\t\t\t\t\telif val == 'i':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\timms.append([curBit, 1, val])\n\t\t\t\t\telif val == 'L':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\timms.append([curBit, 1, val])\n\t\t\t\t\t\t\n\t\t\t\t\telif val.startswith('@<') and val.endswith('>'):\n\t\t\t\t\t\tparmlen = int(val[2:-1])\n\t\t\t\t\t\tcurBit = curBit - parmlen\n\t\t\t\t\t\tparm.append([curBit, parmlen])\n\t\t\t\t\telif val.lower().startswith('imm'):\n\t\t\t\t\t\timmsz = int(val[3:])\n\t\t\t\t\t\tcurBit = curBit - immsz\n\t\t\t\t\t\timms.append([curBit, immsz, val])\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tfail(KeyError, \"Unknown value '\" + val + \"'\")\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = i + 2\n\t\t\t\t\tparse_var_requirements()\n\t\t\t\t\t\n\t\t\t\t\tif curBit == 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telif curBit < 0:\n\t\t\t\t\t\tfail(KeyError, \"Current bit too low (\" + str(curBit) + \")\")\n\t\t\t\t\n\t\t\t\tif curSplt == -1:\n\t\t\t\t\tfail(KeyError, \"Not enough arguments\")\n\t\t\t\t\n\t\t\t\tgenerate_bin_test()\n\t\t\t\t\n\t\t\t\t# Add C variables\n\t\t\t\tif variables[\"cond\"] != -1:\n\t\t\t\t\tif mask[31 - variables[\"cond\"]] == 0:\n\t\t\t\t\t\tappend(\"const char* cond = conds[(opcode >> \" + str(variables[\"cond\"]) + \") & 0xF];\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"cond\"] = -2\n\t\t\t\tif variables[\"op\"] != -1:\n\t\t\t\t\tappend(\"int op = (opcode >> \" + str(variables[\"op\"]) + \") & 1;\\n\")\n\t\t\t\tif (variables[\"u\"] != -1) and (variables[\"f\"] != -1):\n\t\t\t\t\tfail(ValueError, \"Cannot have both unsigned and floating-point\", False)\n\t\t\t\tif variables[\"u\"] != -1:\n\t\t\t\t\tappend(\"int u = (opcode >> \" + str(variables[\"u\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"f\"] != -1:\n\t\t\t\t\tappend(\"int f = (opcode >> \" + str(variables[\"f\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"sz\"][0] != -1:\n\t\t\t\t\tif (mask[31 - variables[\"sz\"][0]] == 0) and ((variables[\"sz\"][1] == 1) or (mask[30 - variables[\"sz\"][0]] == 0)):\n\t\t\t\t\t\tappend(\"int size = (opcode >> \" + str(variables[\"sz\"][0]) + \") & \" + sz2str(variables[\"sz\"][1]) + \";\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"sz\"][0] = -2\n\t\t\t\tif variables[\"q\"] != -1:\n\t\t\t\t\tif mask[31 - variables[\"q\"]] == 0:\n\t\t\t\t\t\tappend(\"int q = (opcode >> \" + str(variables[\"q\"]) + \") & 1;\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tvariables[\"q\"] = -2\n\t\t\t\tif variables[\"registers\"][\"d\"][0] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"d\"][1] != -1)\n\t\t\t\t\tappend(\"int d = ((opcode >> \" + str(variables[\"registers\"][\"d\"][0]) + \") & 1) << 4 \" + \\\n\t\t\t\t\t\t\"| ((opcode >> \" + str(variables[\"registers\"][\"d\"][1]) + \") & 0xF);\\n\")\n\t\t\t\tif variables[\"registers\"][\"t\"][2] != -1:\n\t\t\t\t\tappend(\"int rt = (opcode >> \" + str(variables[\"registers\"][\"t\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"n\"][0] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"n\"][1] != -1)\n\t\t\t\t\tappend(\"int n = ((opcode >> \" + str(variables[\"registers\"][\"n\"][0]) + \") & 1) << 4 \" + \\\n\t\t\t\t\t\t\"| ((opcode >> \" + str(variables[\"registers\"][\"n\"][1]) + \") & 0xF);\\n\")\n\t\t\t\tif variables[\"registers\"][\"n\"][2] != -1:\n\t\t\t\t\tappend(\"int rn = (opcode >> \" + str(variables[\"registers\"][\"n\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"registers\"][\"m\"][0] != -1:\n\t\t\t\t\tassert(variables[\"registers\"][\"m\"][1] != -1)\n\t\t\t\t\tappend(\"int m = ((opcode >> \" + str(variables[\"registers\"][\"m\"][0]) + \") & 1) << 4 \" + \\\n\t\t\t\t\t\t\"| ((opcode >> \" + str(variables[\"registers\"][\"m\"][1]) + \") & 0xF);\\n\")\n\t\t\t\tif variables[\"registers\"][\"m\"][2] != -1:\n\t\t\t\t\tappend(\"int rm = (opcode >> \" + str(variables[\"registers\"][\"m\"][2]) + \") & 0xF;\\n\")\n\t\t\t\tif variables[\"w\"] != -1:\n\t\t\t\t\tappend(\"int w = (opcode >> \" + str(variables[\"w\"]) + \") & 1;\\n\")\n\t\t\t\tif variables[\"cmode\"] != -1:\n\t\t\t\t\tappend(\"int cmode = (opcode >> \" + str(variables[\"cmode\"]) + \") & 0xF;\\n\")\n\t\t\t\tif imms != []:\n\t\t\t\t\timmssz = sum(map(lambda v: v[1], imms))\n\t\t\t\t\ttmp = \"(\" * len(imms)\n\t\t\t\t\tfor immpos, immsz, _ in imms:\n\t\t\t\t\t\tif tmp[-1] != '(': tmp = tmp + \" << \" + str(immsz) + \") | \"\n\t\t\t\t\t\ttmp = tmp + \"((opcode >> \" + str(immpos) + \") & \" + sz2str(immsz) + \")\"\n\t\t\t\t\ttmp = tmp[1:]\n\t\t\t\t\tappend(\"uint\" + str(nextAvailable(immssz)) + \"_t imm\" + str(immssz) + \" = \" + tmp + \";\\n\")\n\t\t\t\t\t\n\t\t\t\t\t# Destroy imms since we don't need it anymore, but we do need immssz\n\t\t\t\t\timms = [-1, immssz] + imms\n\t\t\t\t\n\t\t\t\tadd_custom_variables()\n\t\t\t\t\n\t\t\t\tappend(\"\\nsprintf(ret, \\\"\")\n\t\t\t\t\n\t\t\t\t# Assemble the variables into the printf\n\t\t\t\tinstText = ' '.join(spltln[curSplt:]).split('<')\n\t\t\t\tinstText = [instTextPart.split('>') for instTextPart in instText]\n\t\t\t\tinstText = [itp for itp2 in instText for itp in itp2]\n\t\t\t\t\n\t\t\t\t# Make the failures nicer\n\t\t\t\tspltln = spltln[:curSplt] + [\"\\x01\"] + instText\n\t\t\t\t\n\t\t\t\t# inside '{, '...'}'?\n\t\t\t\thasOpened = False\n\t\t\t\t\n\t\t\t\tprintf_args = \"\"\n\t\t\t\tfor idx, text in enumerate(instText):\n\t\t\t\t\ttext = text.replace(\"&l\", \"<\").replace(\"&g\", \">\")\n\t\t\t\t\t\n\t\t\t\t\tif \"+/-\" in text:\n\t\t\t\t\t\ttext = text.replace(\"+/-\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (u ? \\\"\\\" : \\\"-\\\")\"\n\t\t\t\t\tif \"{!}\" in text:\n\t\t\t\t\t\ttext = text.replace(\"{!}\", \"%s\")\n\t\t\t\t\t\tprintf_args = printf_args + \", (w ? \\\"!\\\" : \\\"\\\")\"\n\t\t\t\t\tif \"{, \" in text:\n\t\t\t\t\t\tif hasOpened:\n\t\t\t\t\t\t\tfail(AssertionError, \"Cannot have an inner curly brace\")\n\t\t\t\t\t\ttext = text.replace(\"{, \", \", \", 1)\n\t\t\t\t\t\thasOpened = True\n\t\t\t\t\tif \"}\" in text:\n\t\t\t\t\t\tif not hasOpened:\n\t\t\t\t\t\t\tfail(AssertionError, \"Cannot close an inexistant curly brace\")\n\t\t\t\t\t\ttext = text.replace(\"}\", \"\", 1)\n\t\t\t\t\t\thasOpened = False\n\t\t\t\t\t\n\t\t\t\t\tif idx % 2:\n\t\t\t\t\t\tif text == \"c\":\n\t\t\t\t\t\t\tif variables[\"cond\"] != -1:\n\t\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", cond\"\n\t\t\t\t\t\telif text == \"dt\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tif imms == []:\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", dts[\" + (\"0x8 + (f << 2) + \" if variables[\"f\"] != -1 else \"\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + (\"(u << 2) + \" if variables[\"u\"] != -1 else \"\") + \"size]\"\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {} (on dt)\".format(imms[0]))\n\t\t\t\t\t\telif text == \"size\":\n\t\t\t\t\t\t\tif imms[0] == 1:\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", 8 << size\"\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {} (on size)\".format(imms[0]))\n\t\t\t\t\t\telif text == \"Qd\":\n\t\t\t\t\t\t\t# VDUP (ARM core register) only\n\t\t\t\t\t\t\tassert(variables[\"q\"] != -1)\n\t\t\t\t\t\t\tassert((variables[\"registers\"][\"t\"][0:2] == [-1, -1]) and (variables[\"registers\"][\"t\"][2] != -1))\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[(q << 5) + 0x20 + d]\"\n\t\t\t\t\t\telif text == \"Dd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(size << 5)\" if variables[\"sz\"][0] != -1 else \"0x20\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \" + d]\"\n\t\t\t\t\t\telif text == \"Dd[x]\":\n\t\t\t\t\t\t\tappend(\"%s[%d]\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(size << 5)\" if variables[\"sz\"][0] != -1 else \"0x20\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \" + d], decodedImm\"\n\t\t\t\t\t\telif text == \"dd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[0x20 + d]\"\n\t\t\t\t\t\telif text == \"Sd\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[d]\"\n\t\t\t\t\t\telif text == \"Rt\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rt]\"\n\t\t\t\t\t\telif text == \"Dn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(size << 5)\" if variables[\"sz\"][0] != -1 else \"0x20\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \" + n]\"\n\t\t\t\t\t\telif text == \"Dn[x]\":\n\t\t\t\t\t\t\tappend(\"%s[%d]\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(size << 5)\" if variables[\"sz\"][0] != -1 else \"0x20\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \" + n], decodedImm\"\n\t\t\t\t\t\telif text == \"Sn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[n]\"\n\t\t\t\t\t\telif text == \"Rn\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rn]\"\n\t\t\t\t\t\telif text == \"Dm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[\" + (\"(size << 5)\" if variables[\"sz\"][0] != -1 else \"0x20\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \" + m]\"\n\t\t\t\t\t\telif text == \"Sm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[m]\"\n\t\t\t\t\t\telif text == \"Sm1\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", vecname[m + 1]\"\n\t\t\t\t\t\telif text == \"Rm\":\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", regname[rm]\"\n\t\t\t\t\t\telif text == \"imm\":\n\t\t\t\t\t\t\tif imms[0] == -1:\n\t\t\t\t\t\t\t\tappend(\"%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", imm\" + str(imms[1])\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tfail(ValueError, \"Unsupported immediate type {}\".format(imms[0]))\n\t\t\t\t\t\telif text == \"label\":\n\t\t\t\t\t\t\tif (imms[0] != -1) or ((imms[1] != 8) and (imms[1] != 24)):\n\t\t\t\t\t\t\t\tfail(AssertionError, \"Unsupported case (label A)\")\n\t\t\t\t\t\t\tif imms[1] == 8:\n\t\t\t\t\t\t\t\tif variables[\"u\"] == -1:\n\t\t\t\t\t\t\t\t\tfail(AssertionError, \"Unsupported case (label 1.B)\")\n\t\t\t\t\t\t\t\tappend(\"%s%d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", (u ? \\\"\\\" : \\\"-\\\"), imm8 + 2\"\n\t\t\t\t\t\t\telif imms[1] == 24:\n\t\t\t\t\t\t\t\tappend(\"%+d\")\n\t\t\t\t\t\t\t\tprintf_args = printf_args + \", (imm24 & 0x800000 ? imm24 | 0xFF000000 : imm24) + 2\"\n\t\t\t\t\t\telif text.lower() == \"list\":\n\t\t\t\t\t\t\tif (text == \"list\") and (variables[\"sz\"] == -1):\n\t\t\t\t\t\t\t\tfail(AssertionError, \"Unsupported case (list A)\")\n\t\t\t\t\t\t\tif (imms[0] != -1) or (imms[1] != 8):\n\t\t\t\t\t\t\t\tfail(AssertionError, \"Unsupported case (list B)\")\n\t\t\t\t\t\t\tif variables[\"registers\"][\"d\"][0] + variables[\"registers\"][\"d\"][1] == -2:\n\t\t\t\t\t\t\t\tfail(AssertionError, \"Unsupported case (list C)\")\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tappend(\"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", print_register_list_fpu(d, imm8, \"\n\t\t\t\t\t\t\tprintf_args = printf_args + (\"0\" if text == \"List\" else (\"1\" if text == \"LIst\" else \"size\"))\n\t\t\t\t\t\t\tprintf_args = printf_args + \")\"\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfail(KeyError, \"Unknown variable \" + text)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif text == \"\":\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\ttext = text.split('\\\\')\n\t\t\t\t\t\twhile len(text) > 1:\n\t\t\t\t\t\t\tif text[1][0] == '%':\n\t\t\t\t\t\t\t\tmodifier, text[1] = '%', text[1][1:]\n\t\t\t\t\t\t\t\twhile (len(text[1]) > 1) \\\n\t\t\t\t\t\t\t\tand (text[1][0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']):\n\t\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tmodifier, text[1] = modifier + text[1][0], text[1][1:]\n\t\t\t\t\t\t\t\tappend(text[0] + modifier)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tappend(text[0] + \"%s\")\n\t\t\t\t\t\t\tprintf_args = printf_args + \", \" + text[1]\n\t\t\t\t\t\t\ttext = text[2:]\n\t\t\t\t\t\tif len(text) == 0:\n\t\t\t\t\t\t\tfail(AssertionError, \"Substitution not finished\")\n\t\t\t\t\t\tappend(text[0])\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = curSplt + 1\n\t\t\t\tappend(\"\\\"\" + printf_args + \");\\n} else \")\n\t\t\t\t\n\t\t\telif spltln[0] == \"INVALIDATE\":\n\t\t\t\t# All instructions matching left are invalid\n\t\t\t\t\n\t\t\t\t# Constant -- set to True when debugging output\n\t\t\t\t# Appends a `#n` (with n being the number of INVALIDATEs before + 1) after `???`\n\t\t\t\tnumberInvalids = __debug_forceAllDebugging\n\t\t\t\t\n\t\t\t\tfor i, val in enumerate(spltln[1:]):\n\t\t\t\t\tif '/' in val:\n\t\t\t\t\t\tocurBit = curBit\n\t\t\t\t\t\treq = val.split('/')\n\t\t\t\t\t\tval, req = req[0], '/'.join(req[1:])\n\t\t\t\t\t\n\t\t\t\t\tif val == '0':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\telif val == '1':\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\tmask[31 - curBit] = 1\n\t\t\t\t\t\tcorrectBits[31 - curBit] = 1\n\t\t\t\t\telif (val == '(0)') or (val == '(1)'):\n\t\t\t\t\t\t# Ignore, even though the result should be undefined...\n\t\t\t\t\t\tcurBit = curBit - 1\n\t\t\t\t\t\t\n\t\t\t\t\telif val.startswith('<') and val.endswith('>'):\n\t\t\t\t\t\tblanklen = int(val[1:-1])\n\t\t\t\t\t\tcurBit = curBit - blanklen\n\t\t\t\t\t\t\n\t\t\t\t\telse:\n\t\t\t\t\t\tfail(KeyError, \"Unknown value '\" + val + \"'\")\n\t\t\t\t\t\n\t\t\t\t\tcurSplt = i + 2\n\t\t\t\t\tparse_var_requirements()\n\t\t\t\t\t\n\t\t\t\t\tif curBit == 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telif curBit < 0:\n\t\t\t\t\t\tfail(KeyError, \"Current bit too low (\" + str(curBit) + \")\")\n\t\t\t\t\n\t\t\t\tif curSplt == -1:\n\t\t\t\t\tfail(KeyError, \"Not enough arguments\")\n\t\t\t\telif len(spltln) != curSplt:\n\t\t\t\t\tfail(KeyError, \"Too many arguments\")\n\t\t\t\t\n\t\t\t\tif 1 in mask:\n\t\t\t\t\tgenerate_bin_test()\n\t\t\t\t\t\n\t\t\t\t\t# No C variable since we're invalidating!\n\t\t\t\t\t\n\t\t\t\t\t# Now print the invalidation, number if debugging\n\t\t\t\t\tif numberInvalids:\n\t\t\t\t\t\tappend(\"strcpy(ret, \\\"??? #\" + str(invalidationCount) + \"\\\");\\n} else \")\n\t\t\t\t\t\tinvalidationCount = invalidationCount + 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tappend(\"strcpy(ret, \\\"???\\\");\\n} else \")\n\t\t\t\telse:\n\t\t\t\t\t# No more input, we invalidated everything!\n\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\telif spltln[0] == \"TODO\":\n\t\t\t\tprint(\"\\033[96mNote:\\033[m todo '{}' (line {})\".format(' '.join(spltln[1:]), lnno))\n\t\t\t\t\n\t\t\telse:\n\t\t\t\tfail(NotImplementedError, spltln[0] + \" is not implemented\")\n\t\texcept Exception as e:\n\t\t\t# Add the failing line in case of error (BaseException is not caught!)\n\t\t\traise Exception(str(lnno + 1) + \": \" + ln) from e\n\t\n\t# Now the files rebuilding part\n\t# File header and guard\n\theader = \"\"\"\n\t#include <stdint.h>\n\t#include <stddef.h>\n\t#include <string.h>\n\t#include <stdio.h>\n\t\n\t#include \"arm_printer.h\"\n\t\n\t// conditions\n\t#define cEQ (0b0000<<28)\n\t#define cNE (0b0001<<28)\n\t#define cCS (0b0010<<28)\n\t#define cCC (0b0011<<28)\n\t#define cMI (0b0100<<28)\n\t#define cPL (0b0101<<28)\n\t#define cVS (0b0110<<28)\n\t#define cVC (0b0111<<28)\n\t#define cHI (0b1000<<28)\n\t#define cLS (0b1001<<28)\n\t#define cGE (0b1010<<28)\n\t#define cLT (0b1011<<28)\n\t#define cGT (0b1100<<28)\n\t#define cLE (0b1101<<28)\n\t#define c__ (0b1110<<28)\t// means all\n\t\n\tstatic const char* conds[16] = {\n\t\t\"EQ\", \"NE\", \"CS\", \"CC\",\n\t\t\"MI\", \"PL\", \"VS\", \"VC\",\n\t\t\"HI\", \"LS\", \"GE\", \"LT\",\n\t\t\"GT\", \"LE\",   \"\", \"##\"\n\t};\n\t\n\tstatic const char* regname[16] = {\n\t\t\"r0\", \"r1\", \"r2\", \"r3\", \"r4\",\n\t\t\"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\n\t\t\"r10\", \"r11\", \"r12\", \"SP\", \"LR\", \"PC\"\n\t};\n\t\n\t// Single precision are V_:_\n\t// Double and quad precision are _:V_\n\t// So we always use _:V_ and invert the corresponding single-precision (cleaner? code)\n\tstatic const char* vecname[96] = {\n\t\t\"S0\",  \"S2\",  \"S4\",  \"S6\",  \"S8\", \"S10\", \"S12\", \"S14\",\n\t\t\"S16\", \"S18\", \"S20\", \"S22\", \"S24\", \"S26\", \"S28\", \"S30\",\n\t\t\"S1\",  \"S3\",  \"S5\",  \"S7\",  \"S9\", \"S11\", \"S13\", \"S15\",\n\t\t\"S17\", \"S19\", \"S21\", \"S23\", \"S25\", \"S27\", \"S29\", \"S31\",\n\t\t\"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\",\n\t\t\"D8\", \"D9\", \"D10\", \"D11\", \"D12\", \"D13\", \"D14\", \"D15\",\n\t\t\"D16\", \"D17\", \"D18\", \"D19\", \"D20\", \"D21\", \"D22\", \"D23\",\n\t\t\"D24\", \"D25\", \"D26\", \"D27\", \"D28\", \"D29\", \"D30\", \"D31\",\n\t\t\"Q0\", \"!!!\", \"Q1\", \"!!!\", \"Q2\", \"!!!\", \"Q3\", \"!!!\",\n\t\t\"Q4\", \"!!!\", \"Q5\", \"!!!\", \"Q6\", \"!!!\", \"Q7\", \"!!!\",\n\t\t\"Q8\", \"!!!\", \"Q9\", \"!!!\", \"Q10\", \"!!!\", \"Q11\", \"!!!\",\n\t\t\"Q12\", \"!!!\", \"Q13\", \"!!!\", \"Q14\", \"!!!\", \"Q15\", \"!!!\"\n\t};\n\t\n\tstatic const char* dts[16] = {\n\t\t\"S8\", \"S16\", \"S32\", \"S64\",\n\t\t\"U8\", \"U16\", \"U32\", \"U64\",\n\t\t\"I8\", \"I16\", \"I32\", \"I64\",\n\t\t\"F8\", \"F16\", \"F32\", \"F64\"\n\t};\n\t\n\tstatic const char* shift_type[4] = {\n\t\t\"lsl \", \"lsr \", \"asr \", \"ror \"\n\t};\n\t\n\tconst char* print_shift(int shift, int comma) {\n\t\tstatic __thread char ret[20];\n\t\tret[0] = '\\\\0';\n\t\t\n\t\tint sh_op = (shift >> 1) & 3;\n\t\tif(shift & 1) {\n\t\t\tint rs = shift >> 4;\n\t\t\tsprintf(ret, \"%s%s%s\", (comma ? \", \" : \"\"), shift_type[sh_op], regname[rs]);\n\t\t} else {\n\t\t\tuint8_t amount = shift >> 3;\n\t\t\tif (!amount) {\n\t\t\t\tswitch (sh_op) {\n\t\t\t\tcase 0b00:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b01:\n\t\t\t\tcase 0b10:\n\t\t\t\t\tsprintf(ret, \"%s%s#32\", (comma ? \", \" : \"\"), shift_type[sh_op]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0b11:\n\t\t\t\t\tsprintf(ret, \"%srrx\", (comma ? \", \" : \"\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsprintf(ret, \"%s%s#%u\", (comma ? \", \" : \"\"), shift_type[sh_op], amount);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\t#define print_modified_imm_ARM(imm12) (((imm12 & 0xFF) >> (2*(imm12 >> 8))) | ((imm12 & 0xFF) << (32 - 2*(imm12 >> 8))))\n\t\n\tconst char* print_register_list(int list, int size) {\n\t\tint last = -2;\n\t\tint cnt = 0;\n\t\tstatic __thread char ret[68];\n\t\t\n\t\tret[0] = '{';\n\t\tret[1] = '\\\\0';\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tif (list & (1 << i)) {\n\t\t\t\tif (last >= 0) {\n\t\t\t\t\t++cnt;\n\t\t\t\t} else {\n\t\t\t\t\tif (last == -1)\n\t\t\t\t\t\tstrcat(ret, \", \");\n\t\t\t\t\tstrcat(ret, regname[i]);\n\t\t\t\t\tlast = i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cnt) {\n\t\t\t\t\tstrcat(ret, \"-\");\n\t\t\t\t\tstrcat(ret, regname[i - 1]);\n\t\t\t\t}\n\t\t\t\tif (last != -2) last = -1;\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t\tif (cnt) {\n\t\t\tstrcat(ret, \"-\");\n\t\t\tstrcat(ret, regname[size - 1]);\n\t\t}\n\t\tstrcat(ret, \"}\");\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tconst char* print_register_list_fpu(uint8_t start, uint8_t size, uint8_t double_prec) {\n\t\tstatic __thread char ret[68];\n\t\t\n\t\t// Assume VFPSmallRegisterBank(), so no D16 and no S32 (and above)\n\t\tif (start + (double_prec + 1) * size > 32) {\n\t\t\treturn \"!!!\";\n\t\t}\n\t\tif (size == 0) {\n\t\t\treturn \"!!!\";\n\t\t}\n\t\tif (double_prec && (size % 2 == 1)) {\n\t\t\tstrcpy(ret, \"!! {\");\n\t\t} else {\n\t\t\tret[0] = '{';\n\t\t\tret[1] = '\\\\0';\n\t\t}\n\t\t\n\t\tchar regChr;\n\t\tif (double_prec) {\n\t\t\tregChr = 'D';\n\t\t\tsize /= 2;\n\t\t} else {\n\t\t\tregChr = 'S';\n\t\t\tstart = (start >> 4) + ((start & 0xF) << 1);\n\t\t}\n\t\t\n\t\tchar tmp[7];\n\t\tfor (int cur = start; cur < start + size - 1; ++cur) {\n\t\t\tsprintf(tmp, \"%c%d, \", regChr, cur);\n\t\t\tstrcat(ret, tmp);\n\t\t}\n\t\tsprintf(tmp, \"%c%d}\", regChr, start + size - 1);\n\t\tstrcat(ret, tmp);\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tstatic const char* _print_modified_imm_I64_bytes[2] = {\"00\", \"FF\"};\n\t\n\tconst char* print_modified_imm_NEON(int op_cmode, int imm) {\n\t\tstatic __thread char ret[34] = \"???\\\\0-\"; // [dt: 4][imm: 30]\n\t\t\n\t\tstrcpy(&ret[4], \"UNPREDICTABLE\");\n\t\t\n\t\tswitch (op_cmode) {\n\t\tcase 0b00000: // VMOV.I32\n\t\tcase 0b00001: // VORR.I32\n\t\tcase 0b10000: // VMVN.I32\n\t\tcase 0b10001: // VBIC.I32\n\t\t\tstrcpy(ret, \"I32\");\n\t\t\tsprintf(&ret[4], \"0x%02X\", imm);\n\t\t\tbreak;\n\t\tcase 0b00010: // VMOV.I32\n\t\tcase 0b00011: // VORR.I32\n\t\tcase 0b10010: // VMVN.I32\n\t\tcase 0b10011: // VBIC.I32\n\t\t\tif (imm) {\n\t\t\t\tstrcpy(ret, \"I32\");\n\t\t\t\tsprintf(&ret[4], \"0x%02X00\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b00100: // VMOV.I32\n\t\tcase 0b00101: // VORR.I32\n\t\tcase 0b10100: // VMVN.I32\n\t\tcase 0b10101: // VBIC.I32\n\t\t\tif (imm) {\n\t\t\t\tstrcpy(ret, \"I32\");\n\t\t\t\tsprintf(&ret[4], \"0x%02X0000\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b00110: // VMOV.I32\n\t\tcase 0b00111: // VORR.I32\n\t\tcase 0b10110: // VMVN.I32\n\t\tcase 0b10111: // VBIC.I32\n\t\t\tif (imm) {\n\t\t\t\tstrcpy(ret, \"I32\");\n\t\t\t\tsprintf(&ret[4], \"0x%02X000000\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b01000: // VMOV.I16\n\t\tcase 0b01001: // VORR.I16\n\t\tcase 0b11000: // VMVN.I16\n\t\tcase 0b11001: // VBIC.I16\n\t\t\tstrcpy(ret, \"I16\");\n\t\t\tsprintf(&ret[4], \"0x%02X\", imm);\n\t\t\tbreak;\n\t\tcase 0b01010: // VMOV.I16\n\t\tcase 0b01011: // VORR.I16\n\t\tcase 0b11010: // VMVN.I16\n\t\tcase 0b11011: // VBIC.I16\n\t\t\tif (imm) {\n\t\t\t\tstrcpy(ret, \"I16\");\n\t\t\t\tsprintf(&ret[4], \"0x%02X00\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b01100: // VMOV.I32\n\t\tcase 0b11100: // VMVN.I32\n\t\t\tif (imm) {\n\t\t\t\tstrcpy(ret, \"I32\");\n\t\t\t\tsprintf(&ret[4], \"0x%02XFF\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b01101: // VMOV.I32\n\t\tcase 0b11101: // VMVN.I32\n\t\t\tif (imm) {\n\t\t\t\tstrcpy(ret, \"I32\");\n\t\t\t\tsprintf(&ret[4], \"0x%02XFFFF\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b01110: // VMOV.I8\n\t\t\tstrcpy(ret, \"I8\");\n\t\t\tsprintf(&ret[4], \"0x%02X\", imm);\n\t\t\tbreak;\n\t\tcase 0b01111: // VMOV.F32\n\t\t\tstrcpy(ret, \"F32\");\n\t\t\tsprintf(&ret[4], \"%e\", (imm & 0x80 ? -1 : 1) * (1 << (((imm >> 4) & 0x7) ^ 0b100)) * (float) (16 + (imm & 0xF)) / 128.);\n\t\t\tbreak;\n\t\tcase 0b11110: // VMOV.I64\n\t\t\t{\n\t\t\t\tstrcpy(ret, \"I64\");\n\t\t\t\tsprintf(&ret[4], \"#0x%s%s%s%s%s%s%s%s\",\n\t\t\t\t\t_print_modified_imm_I64_bytes[(imm >> 7) & 1], _print_modified_imm_I64_bytes[(imm >> 6) & 1],\n\t\t\t\t\t_print_modified_imm_I64_bytes[(imm >> 5) & 1], _print_modified_imm_I64_bytes[(imm >> 4) & 1],\n\t\t\t\t\t_print_modified_imm_I64_bytes[(imm >> 3) & 1], _print_modified_imm_I64_bytes[(imm >> 2) & 1],\n\t\t\t\t\t_print_modified_imm_I64_bytes[(imm >> 1) & 1], _print_modified_imm_I64_bytes[(imm >> 0) & 1]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0b11111: // V???.-\n\t\tdefault:\n\t\t\tstrcpy(ret, \"-\");\n\t\t\tstrcpy(&ret[4], \"UNDEFINED\");\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tconst char* arm_print(uint32_t opcode) {\n\t\tstatic __thread char ret[100];\n\t\tmemset(ret, 0, sizeof(ret));\n\t\t\n\t\t\"\"\"\n\tfooter = \"\"\"\n\t{\n\t\t\tstrcpy(ret, \"???\");\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\"\"\"\n\tbanner = \"/*******************************************************\" + ('*'*len(ver)) + \"***\\n\" \\\n\t         \" * File automatically generated by rebuild_printer.py (v\" + ver + \") *\\n\" \\\n\t         \" *******************************************************\" + ('*'*len(ver)) + \"***/\\n\"\n\ttrim = lambda string: '\\n'.join(line[1:] for line in string.splitlines())[1:]\n\theader = banner + trim(header)\n\tfooter = trim(footer)\n\t\n\twith open(os.path.join(root, \"src\", \"dynarec\", \"arm_printer.c\"), 'w') as file:\n\t\tfile.write(header)\n\t\tfile.write(output)\n\t\tfile.write(footer)\n\t# Save the string for the next iteration, writing was successful\n\twith open(os.path.join(root, \"src\", \"dynarec\", \"last_run.txt\"), 'w') as file:\n\t\tfile.write('\\n'.join(insts))\n\t\n\treturn 0\n\nif __name__ == '__main__':\n\tlimit = []\n\tfor i, v in enumerate(sys.argv):\n\t\tif v == \"--\":\n\t\t\tlimit.append(i)\n\tif main(sys.argv[1], \"1.2.0.06\") != 0:\n\t\texit(2)\n\texit(0)\n"
        },
        {
          "name": "rebuild_wrappers.py",
          "type": "blob",
          "size": 52.4140625,
          "content": "#!/usr/bin/env python3\n\nimport os\nimport sys\n\ntry:\n\tassert(sys.version_info.major == 3)\n\tif sys.version_info.minor >= 9:\n\t\t# Python 3.9+\n\t\tfrom typing import Any, Generic, NewType, Optional, TypeVar, Union, final\n\t\tfrom collections.abc import Callable, Iterable, Sequence\n\t\tDict = dict\n\t\tList = list\n\t\tType = type\n\t\tTuple = tuple\n\telif sys.version_info.minor >= 8:\n\t\t# Python [3.8, 3.9)\n\t\tfrom typing import Any, Callable, Dict, Generic, Iterable, List, NewType, Optional, Sequence, Tuple, Type, TypeVar, Union, final\n\telif (sys.version_info.minor >= 5) and (sys.version_info.micro >= 2):\n\t\t# Python [3.5.2, 3.8)\n\t\tfrom typing import Any, Callable, Dict, Generic, Iterable, List, NewType, Optional, Sequence, Tuple, Type, TypeVar, Union\n\t\tfinal = lambda fun: fun # type: ignore\n\telif sys.version_info.minor >= 5:\n\t\t# Python [3.5, 3.5.2)\n\t\tfrom typing import Any, Callable, Dict, Generic, Iterable, List, Optional, Sequence, Tuple, Type, TypeVar, Union\n\t\tdef NewType(_, b): return b # type: ignore\n\t\tfinal = lambda fun: fun # type: ignore\n\telse:\n\t\t# Python < 3.5\n\t\t#print(\"Your Python version does not have the typing module, fallback to empty 'types'\")\n\t\t# Dummies\n\t\tclass GTDummy:\n\t\t\tdef __getitem__(self, _):\n\t\t\t\treturn self\n\t\tAny = GTDummy() # type: ignore\n\t\tCallable = GTDummy() # type: ignore\n\t\tDict = GTDummy() # type: ignore\n\t\tGeneric = GTDummy() # type: ignore\n\t\tIterable = GTDummy() # type: ignore\n\t\tList = GTDummy() # type: ignore\n\t\tdef NewType(_, b): return b # type: ignore\n\t\tOptional = GTDummy() # type: ignore\n\t\tSequence = GTDummy() # type: ignore\n\t\tTuple = GTDummy() # type: ignore\n\t\tType = GTDummy() # type: ignore\n\t\tdef TypeVar(T): return object # type: ignore\n\t\tUnion = GTDummy() # type: ignore\n\t\tfinal = lambda fun: fun # type: ignore\nexcept ImportError:\n\tprint(\"It seems your Python version is quite broken...\")\n\tassert(False)\n\n\"\"\"\nGenerates all files in src/wrapped/generated\n===\n\nTL;DR: Automagically creates type definitions (/.F.+/ functions/typedefs...).\n       All '//%' in the headers are used by the script.\n\nReads each lines of each \"_private.h\" headers (plus wrappedd3dadapter9_genvate.h, derived from wrappedd3dadapter9_gen.h).\nFor each of them:\n- If if starts with a #ifdef, #else, #ifndef, #endif, it memorizes which definition is required\n- If it starts with a \"GO\", it will do multiple things:\n  - It memorizes the type used by the function (second macro argument)\n  - It memorizes the type it is mapped to, if needed (eg, iFvp is mapped to iFp: the first argument is dropped)\n  - It checks if the type given (both original and mapped to) are valid\n  - If the signature contains a 'E' but it is not a \"GOM\" command, it will throw an error (and vice-versa*)\n  - If the line also contains '//%', the script will parse what's attached to this comment start:\n    - If it is attached to a '%', the function will be skipped when generating the 'SUPER' macro in the *types.h\n\t- *If it is attached to a 'noE' or attached to something that ends with ',noE', it will ignore functions that\n\t  don't have the emulator as an argument but are still GOM functions\n- If the line starts with a '//%S', it will memorize a structure declaration.\n  The structure of it is: \"//%S <letter> <structure name> <signature equivalent>\"\n  NOTE: Those structure letters are \"fake types\" that are accepted in the macros.\n\n`gbl` contains the first list, `redirects` the second and\n `filespec` constains file specific informations (eg, structures, typedefs required...).\n\nAfter sorting the data, it generates:\n\nwrapper.c\n---------\n(Private) type definitions (/.F.+_t/)\nFunction definitions (/.F.+/ functions, that actually execute the function given as argument)\n\nwrapper.h\n---------\nGeneric \"wrapper_t\" type definition\nFunction declarations (/.F.+/ functions)\n\n*types.h\n--------\nLocal types definition, for the original signatures\nThe SUPER() macro definition, used to generate and initialize the `*_my_t` library structure\n(TODO: also automate this declaration/definition? It would require more metadata,\n and may break sometime in the future due to the system changing...)\n\n*defs.h\n-------\nLocal `#define`s, for signature mapping\n\n*undefs.h\n---------\nLocal `#undefine`s, for signature mapping\n\n\nExample:\n========\nIn wrappedtest_private.h:\n   ----------------------\n//%S X TestLibStructure ppu\n\nGO(superfunction, pFX)\nGOM(superFunction2, pFEpX)\nGOM(functionWithoutE, pFppu) //%noE\nGOM(functionWithoutEAndNotInTypes, pFpppu) //%%,noE\nGOM(functionNotInTypes, pFEpppu) //%%\n\n[No output]\nGenerated files:\nwrapper.c: [snippet]\n----------\ntypedef void *(*pFppu_t)(void*, void*, uint32_t);\ntypedef void *(*pFpppu_t)(void*, void*, void*, uint32_t);\ntypedef void *(*pFEpppu_t)(x86emu_t*, void*, void*, void*, uint32_t);\n\nvoid pFppu(x86emu_t *emu, uintptr_t fcn) { pFppu_t *fn = (pFppu_t)fn; R_RAX=...; }\nvoid pFpppu(x86emu_t *emu, uintptr_t fcn) { pFpppu_t *fn = (pFpppu_t)fn; R_RAX=...; }\nvoid pFEpppu(x86emu_t *emu, uintptr_t fcn) { pFpppu_t *fn = (pFpppu_t)fn; R_RAX=...; }\n\nwrapper.h: [snippet]\n----------\ntypedef void (*wrapper_t)(x86emu_t*, uintptr_t);\n\nvoid pFppu(x86emu_t *emu, uintptr_t fcn);\nvoid pFpppu(x86emu_t *emu, uintptr_t fcn);\nvoid pFEpppu(x86emu_t *emu, uintptr_t fcn);\n\nwrappedtesttypes.h:\n-------------------\ntypedef void *(*pFpX_t)(void*, TestLibStructure);\ntypedef void *(*pFppu_t)(void*, void*, uint32_t);\ntypedef void *(*pFpppu_t)(void*, void*, void*, uint32_t);\n\n#define SUPER() ADDED_FUNCTIONS() \\\\\n\tGO(superFunction2, pFpX) \\\\\n\tGO(functionWithoutE, pFppu)\n\nwrappedtestdefs.h:\n------------------\n#define pFX pFppu\n#define pFpX pFpppu\n\nwrappedtestundefs.h:\n--------------------\n#undef pFX\n#undef pFpX\n\"\"\"\n\n# Free letters:\n# AB   F H J      QR T   XYZab  e gh jk mno qrst   xyz\n\nT = TypeVar('T')\nU = TypeVar('U')\n\nFilename = str\n\nclass CustOrderedDict(Generic[T, U], Iterable[T]):\n\t__keys__: List[T] = []\n\t__actdict__: Dict[T, U] = {}\n\t\n\tdef __init__(self, src: Optional[Dict[T, U]] = None) -> None:\n\t\tif src is None:\n\t\t\tself.__keys__ = []\n\t\t\tself.__actdict__ = {}\n\t\telse:\n\t\t\tself.__keys__ = list(src.keys())\n\t\t\tself.__actdict__ = src\n\t\n\tdef sort(self, key: Callable[[T], Any] = lambda x: x) -> None:\n\t\tself.__keys__.sort(key=key)\n\t\n\tdef __iter__(self):\n\t\treturn iter(self.__keys__)\n\tdef __contains__(self, k: T) -> bool:\n\t\treturn k in self.__actdict__\n\tdef __getitem__(self, k: T) -> U:\n\t\treturn self.__actdict__[k]\n\tdef __setitem__(self, k: T, v: U) -> None:\n\t\tif k not in self.__keys__: self.__keys__.append(k)\n\t\tself.__actdict__[k] = v\nclass CustOrderedDictList(CustOrderedDict[T, List[U]]):\n\tdef __getitem__(self, k: T) -> List[U]:\n\t\tif k not in self: self[k] = []\n\t\treturn super().__getitem__(k)\n\nclass FirstArgumentSingletonMeta(Generic[T], type):\n\t_singletons: Dict[T, Type['FirstArgumentSingletonMeta']] = {}\n\t\n\t@classmethod\n\tdef __prepare__(metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any) -> Dict[str, Any]:\n\t\treturn { \"_singletons\": {} }\n\t\n\tdef __contains__(cls, k):\n\t\treturn k in cls._singletons\n\t\n\tdef getSingletons(cls):\n\t\treturn cls._singletons\n\tdef __getitem__(cls, k):\n\t\treturn cls._singletons[k]\n\t\n\tdef __call__(cls, fstarg, *largs, **kwargs):\n\t\tif fstarg not in cls._singletons:\n\t\t\tcls._singletons[fstarg] = super().__call__(fstarg, *largs, **kwargs)\n\t\treturn cls._singletons[fstarg]\n\nclass FileSpec:\n\tclass Struct:\n\t\tdef __init__(self, name: str, repl: str) -> None:\n\t\t\tself.name = name\n\t\t\tself.repl = repl\n\t\n\t# CONSTANT- values: original set\n\t# CONSTANT- rvalues: valid replacement values (outside of structures)\n\t# CONSTANT- validrepl: valid replacement values (for structures)\n\t#           structs: structure ids and additional data\n\tvalues:    Sequence[str] = ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'K', 'l', 'L', 'p', 'V', 'O', 'S', '2', 'P', 'G', 'N', 'M', 's']\n\trvalues:   Sequence[str] = ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'K', 'l', 'L', 'p', 'V', 'O', 'S', '2', 'P', 'G', 'N', 'M', 's']\n\tvalidrepl: Sequence[str] = ['c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'K', 'l', 'L', 'p', 'V', 'O', 'S', '2', 'P', 'G', 'N', 'M', 's']\n\t\n\tdef __init__(self) -> None:\n\t\tself.structs: CustOrderedDict[str, FileSpec.Struct] = CustOrderedDict()\n\t\t\n\t\tself.typedefs: CustOrderedDictList[_BareFunctionType, Function] = CustOrderedDictList()\n\t\tself.structsuses: List[FunctionType] = []\n\t\n\tdef registerStruct(self, id: str, name: str, repl: str):\n\t\tif len(id) != 1:\n\t\t\t# If you REALLY need it, consider opening a ticket\n\t\t\t# Before you do, consider that everything that is a valid in a C token is valid here too\n\t\t\traise ValueError(\"Type ID \\\"\" + id + \"\\\" is too long!\")\n\t\tif id in self.rvalues:\n\t\t\traise ValueError(\"Type \" + id + \" is already reserved!\")\n\t\tif id in self.structs:\n\t\t\traise ValueError(\"Type \" + id + \" is already used!\")\n\t\tif any(c not in self.validrepl for c in repl):\n\t\t\traise ValueError(\"Invalid structure replacement value \\\"\" + repl + \"\\\" (note: recursive replacements are not supported)\")\n\t\tif repl == \"\":\n\t\t\t# If you need this, please open an issue (also, this is never actually called, empty strings are removed at the calling site)\n\t\t\traise NotImplementedError(\"Invalid structure metadata supply (empty replacement)\")\n\t\t\n\t\tself.structs[id] = FileSpec.Struct(name, repl)\n\nclass FunctionType(metaclass=FirstArgumentSingletonMeta):\n\tdef __new__(cls, string: str, filespec: FileSpec) -> 'FunctionType':\n\t\tif ((string[0] not in FileSpec.values) or any(c not in FileSpec.values for c in string[2:])) \\\n\t\t and ((string[0] in FileSpec.values) or (string[0] in filespec.structs)) \\\n\t\t and all((c != 'v') and (c in FileSpec.values) or (c in filespec.structs) for c in string[2:]):\n\t\t\treturn super().__new__(StructFunctionType)\n\t\telse:\n\t\t\treturn super().__new__(cls)\n\t\n\tdef __init__(self, string: str, filespec: FileSpec) -> None:\n\t\t# Early fail\n\t\tif 'VV' in string:\n\t\t\traise ValueError(\"'V' can only be at the end of the type (use 's' instead)\")\n\t\t\n\t\tself.orig = string\n\t\t\n\t\tself.hasemu = 'E' in string\n\t\tif self.hasemu:\n\t\t\tif (\"E\" in string[:2]) or (\"E\" in string[3:]):\n\t\t\t\traise NotImplementedError(\"x86emu_t* not as the first parameter\")\n\t\t\tif len(string) < 4:\n\t\t\t\traise NotImplementedError(\"Type {0} too short\".format(string))\n\t\t\tchk_type = string[0] + string[3:]\n\t\telse:\n\t\t\tchk_type = string[0] + string[2:]\n\t\tself.withoutE = _BareFunctionType(string[0:2] + chk_type[1:], filespec, isinstance(self, StructFunctionType))\n\t\tself._bare = _BareFunctionType(self.orig, filespec, isinstance(self, StructFunctionType))\n\t\tif len(chk_type) < 2:\n\t\t\traise NotImplementedError(\"Type {0} too short\".format(string))\n\t\t\n\t\tif string[1] != \"F\":\n\t\t\traise NotImplementedError(\"Bad middle letter {0}\".format(string[1]))\n\t\t\n\t\tself.redirect = any(c not in FileSpec.values for c in chk_type) or (('v' in chk_type[1:]) and (len(chk_type) > 2))\n\t\tself.usestruct: bool = False\n\t\tself.redirected: Optional[FunctionType] = None\n\t\tif self.redirect:\n\t\t\tif all(((i == 0) or (c != 'v')) and (c in FileSpec.values) or (c in filespec.structs) for i, c in enumerate(chk_type)):\n\t\t\t\t# 'v' is never allowed here\n\t\t\t\tself.redirect = False\n\t\t\t\tself.usestruct = True\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tif any(c not in FileSpec.rvalues for c in chk_type):\n\t\t\t\t\traise NotImplementedError(\"Invalid type {0}\".format(string))\n\t\t\t\t\n\t\t\t\t# Ok, this is acceptable: there is 0, 1 and/or void\n\t\t\t\tstring = string[:2] + (string[2:]\n\t\t\t\t\t.replace(\"v\", \"\")) # void -> nothing\n\t\t\t\tassert(len(string) >= 3) # If this raises, don't use 'vFvvvvvv' as a signature...\n\t\t\t\tself.redirected = FunctionType(string, filespec)\n\t\t\t\tassert(not self.redirected.redirect and not self.redirected.usestruct)\n\t\n\tdef getchar(self, c: str) -> int:\n\t\treturn self._bare.getchar(c)\n\tdef getcharidx(self, i: int) -> int:\n\t\treturn self._bare.getcharidx(i)\n\tdef splitchar(self) -> List[int]:\n\t\treturn self._bare.splitchar()\n\t\n\tdef __hash__(self) -> int:\n\t\treturn str.__hash__(self.orig)\n\tdef __eq__(self, o: object):\n\t\treturn isinstance(o, FunctionType) and ((self.orig == o.orig) and (o is self or not isinstance(self, StructFunctionType)))\nclass StructFunctionType(FunctionType):\n\tdef __init__(self, string: str, filespec: FileSpec) -> None:\n\t\tsuper().__init__(string, filespec)\n\t\tassert(self.usestruct)\n\t\tself.filespec = filespec\n\t\tself.filespec.structsuses.append(self)\n\t\t\n\t\tself.returnsstruct = string[0] in self.filespec.structs\n\t\tif self.returnsstruct:\n\t\t\tif self.hasemu:\n\t\t\t\tstring = \"pFEp\" + string[3:]\n\t\t\telse:\n\t\t\t\tstring = \"pFp\" + string[2:]\n\t\t\n\t\tfor struct in self.filespec.structs:\n\t\t\tstring = string.replace(struct, self.filespec.structs[struct].repl)\n\t\tself.redirected = FunctionType(string, self.filespec)\n\nclass _BareFunctionType(FunctionType): # Fake derived\n\tdef __new__(cls, *largs, **kwargs):\n\t\treturn object.__new__(cls)\n\tdef __init__(self, string: str, filespec: FileSpec, isstruct: bool) -> None:\n\t\tself.orig = string\n\t\tself.filespec = filespec\n\t\tself.isstruct = isstruct\n\t\n\tdef getchar(self, c: str) -> int:\n\t\tif c in FileSpec.rvalues:\n\t\t\treturn FileSpec.rvalues.index(c)\n\t\telse:\n\t\t\tassert(self.isstruct)\n\t\t\treturn self.filespec.structs.__keys__.index(c) + len(FileSpec.rvalues)\n\tdef getcharidx(self, i: int) -> int:\n\t\treturn self.getchar(self.orig[i])\n\t\n\tdef splitchar(self) -> List[int]:\n\t\ttry:\n\t\t\tret = [\n\t\t\t\tlen(self.orig), self.getcharidx(0),\n\t\t\t\t*map(self.getcharidx, range(2, len(self.orig)))\n\t\t\t]\n\t\t\treturn ret\n\t\texcept ValueError as e:\n\t\t\traise ValueError(\"Value is \" + self.orig) from e\n\t\texcept AssertionError as e:\n\t\t\traise ValueError(\"Value is \" + self.orig) from e\n\n# Allowed GOs: GO,GOM,GO2,GOS,GOW,GOWM,GOW2,GO2S\nclass Function:\n\tdef __init__(self, name: str, funtype: FunctionType, gotype: str, filespec: FileSpec, filename: Filename, line: str) -> None:\n\t\tself._noE = False\n\t\t\n\t\tself.no_dlsym: bool = False\n\t\tif \"//%\" in line:\n\t\t\tadditional_meta = line.split(\"//%\")[1].split(\" \")[0].strip()\n\t\t\t\n\t\t\tif additional_meta.endswith(\",noE\"):\n\t\t\t\tself._noE = True\n\t\t\t\tadditional_meta = additional_meta[:-4]\n\t\t\t\n\t\t\tif additional_meta == 'noE':\n\t\t\t\tassert not self._noE, \"Duplicated 'noE'\"\n\t\t\t\tself._noE = True\n\t\t\telif additional_meta == '%':\n\t\t\t\tself.no_dlsym = True\n\t\t\telse:\n\t\t\t\traise NotImplementedError(\"Changing the function type 'on the fly' is not supported\")\n\t\t\n\t\tfuntypeerr = ValueError(\"Invalid function type \" + gotype)\n\t\tif not gotype.startswith(\"GO\"):\n\t\t\traise funtypeerr\n\t\tgotype = gotype[2:]\n\t\tself.isweak = (len(gotype) > 0) and (gotype[0] == \"W\")\n\t\tif self.isweak:\n\t\t\tgotype = gotype[1:]\n\t\tself.ismy = (len(gotype) > 0) and (gotype[0] == \"M\")\n\t\tself.is2 = (len(gotype) > 0) and (gotype[0] == \"2\")\n\t\tself.retS = (len(gotype) > 0) and (gotype[0] == \"S\")\n\t\tif self.ismy or self.is2 or self.retS:\n\t\t\tgotype = gotype[1:]\n\t\tif self.retS:\n\t\t\tself.ismy = True\n\t\t\tassert((self.no_dlsym and (funtype.orig.startswith(\"pFp\") or funtype.orig.startswith(\"pFEp\")))\n\t\t\t or (isinstance(funtype, StructFunctionType) and funtype.returnsstruct))\n\t\t\tself._noE = self._noE or self.no_dlsym\n\t\tif isinstance(funtype, StructFunctionType) and funtype.returnsstruct and not self.retS:\n\t\t\tgotype = \"GO\" + \\\n\t\t\t\t(\"W\" if self.isweak else \"\") + \\\n\t\t\t\t(\"M\" if self.ismy else \"\") + (\"2\" if self.is2 else \"\")\n\t\t\traise ValueError(\"Function type \" + funtype.orig + \" needs to return a structure, but doesn't (currently \" + gotype + \")\")\n\t\tif gotype != \"\":\n\t\t\traise funtypeerr\n\t\t\n\t\tself.name = name\n\t\tself.type = funtype\n\t\tself.filespec = filespec\n\t\tassert(not isinstance(funtype, StructFunctionType) or filespec is funtype.filespec) # No reason why not, so assert()\n\t\t\n\t\tif self.is2:\n\t\t\tself.fun2 = line.split(',')[2].split(')')[0].strip()\n\t\t\tif self.type.hasemu != self.fun2.startswith(\"my_\") and not self._noE:\n\t\t\t\t# If this raises because of a different prefix, open a pull request\n\t\t\t\tprint(\"\\033[91mThis is probably not what you meant!\\033[m ({0}:{1})\".format(filename, line[:-1]), file=sys.stderr)\n\t\t\t\tself.invalid = True\n\t\t\n\t\tif (self.ismy and not self.type.hasemu and not self.is2) and not self._noE:\n\t\t\t# Probably invalid on box86; if not so, remove/comment this whole 'if' (and also open an issue)\n\t\t\tprint(\"\\033[94mAre you sure of this?\\033[m ({0}:{1})\".format(filename, line[:-1]), file=sys.stderr)\n\t\t\tself.invalid = True\n\t\t\treturn\n\t\tif self.type.hasemu and not self.ismy and not self.is2:\n\t\t\t# Certified invalid\n\t\t\tprint(\"\\033[91mThis is probably not what you meant!\\033[m ({0}:{1})\".format(filename, line[:-1]), file=sys.stderr)\n\t\t\tself.invalid = True\n\t\t\treturn\n\t\tif self._noE and not self.ismy and not self.is2:\n\t\t\traise ValueError(\"Invalid meta: 'no E' provided but function is not a GOM\")\n\t\t\n\t\tif self.ismy or self.is2:\n\t\t\t# Add this to the typedefs\n\t\t\tself.filespec.typedefs[self.type.withoutE].append(self)\n\nDefineType = NewType('DefineType', str)\n@final\nclass Define:\n\tname: DefineType = DefineType(\"\")\n\tinverted_: bool = False\n\t\n\tdefines: List[DefineType] = []\n\t\n\tdef __init__(self, name: DefineType, inverted_: bool) -> None:\n\t\t# All values for \"name\" are in defines (throw otherwise)\n\t\tif name not in Define.defines:\n\t\t\traise KeyError(name)\n\t\t\n\t\tself.name = name\n\t\tself.inverted_ = inverted_\n\tdef copy(self) -> \"Define\":\n\t\treturn Define(self.name, self.inverted_)\n\t\n\tdef value(self) -> int:\n\t\treturn Define.defines.index(self.name)*2 + (1 if self.inverted_ else 0)\n\t\n\tdef invert(self) -> \"Define\":\n\t\t\"\"\"\n\t\tinvert -- Transform a `defined()` into a `!defined()` and vice-versa, in place.\n\t\t\"\"\"\n\t\tself.inverted_ = not self.inverted_\n\t\treturn self\n\tdef inverted(self) -> \"Define\":\n\t\t\"\"\"\n\t\tinverted -- Transform a `defined()` into a `!defined()` and vice-versa, out-of-place.\n\t\t\"\"\"\n\t\treturn Define(self.name, not self.inverted_)\n\t\n\tdef __str__(self) -> str:\n\t\tif self.inverted_:\n\t\t\treturn \"!defined(\" + self.name + \")\"\n\t\telse:\n\t\t\treturn \"defined(\" + self.name + \")\"\n\tdef __eq__(self, o) -> bool:\n\t\treturn isinstance(o, Define) and (self.name == o.name) and (self.inverted_ == o.inverted_)\n@final\nclass Clause:\n\tdefines: List[Define] = []\n\t\n\tdef __init__(self, defines: Union[List[Define], str] = []) -> None:\n\t\tif isinstance(defines, str):\n\t\t\tif defines == \"\":\n\t\t\t\tself.defines = []\n\t\t\telse:\n\t\t\t\tself.defines = list(\n\t\t\t\t\tmap(\n\t\t\t\t\t\tlambda x:\n\t\t\t\t\t\t\tDefine(DefineType(x[9:-1] if x[0] == '!' else x[8:-1]), x[0] == '!')\n\t\t\t\t\t\t, defines.split(\" && \")\n\t\t\t\t\t)\n\t\t\t\t)\n\t\telse:\n\t\t\tself.defines = [d.copy() for d in defines]\n\tdef copy(self) -> \"Clause\":\n\t\treturn Clause(self.defines)\n\t\n\tdef append(self, define: Define) -> \"Clause\":\n\t\tif any((define2.name == define.name) and (define2.inverted_ != define.inverted_) for define2 in self.defines):\n\t\t\traise ValueError(\"Tried to append an incompatible clause\")\n\t\t\n\t\tself.defines.append(define)\n\t\treturn self\n\tdef invert_last(self) -> \"Clause\":\n\t\tself.defines[-1].invert()\n\t\treturn self\n\tdef pop_last(self) -> \"Clause\":\n\t\tif len(self.defines) > 0: self.defines.pop()\n\t\treturn self\n\t\n\tdef empty(self) -> bool:\n\t\treturn self.defines == []\n\t\n\tdef __str__(self) -> str:\n\t\treturn \" && \".join(map(str, self.defines))\n\tdef __hash__(self):\n\t\treturn hash(str(self))\n\tdef __eq__(self, o) -> bool:\n\t\treturn isinstance(o, Clause) and (self.defines == o.defines)\nClausesStr = str\n@final\nclass Clauses:\n\t\"\"\"\n\tRepresent a list of clauses, aka a list of or-ed together and-ed \"defined()\"\n\tconditions\n\t\"\"\"\n\tclauses: List[Clause] = []\n\t\n\tdef __init__(self, clauses: Union[List[Clause], str] = []) -> None:\n\t\tif isinstance(clauses, str):\n\t\t\tif clauses == \"()\":\n\t\t\t\tself.clauses = []\n\t\t\telif \") || (\" in clauses:\n\t\t\t\tself.clauses = list(map(Clause, clauses[1:-1].split(\") || (\")))\n\t\t\telse:\n\t\t\t\tself.clauses = [Clause(clauses)]\n\t\telse:\n\t\t\tself.clauses = clauses[:]\n\tdef copy(self) -> \"Clauses\":\n\t\treturn Clauses(self.clauses[:])\n\t\n\tdef add(self, defines: Clause) -> \"Clauses\":\n\t\tself.clauses.append(defines)\n\t\treturn self\n\t\n\tdef empty(self) -> bool:\n\t\treturn self.clauses == []\n\t\n\tdef splitdef(self) -> Sequence[int]:\n\t\t\"\"\"\n\t\tsplitdef -- Sorting key function for #ifdefs\n\t\t\n\t\tAll #if defined(...) are sorted first by the length of its string\n\t\trepresentation, then by the number of clauses, then by the number of\n\t\t'&&' in each clause and then by the \"key\" of the tested names (left to\n\t\tright, inverted placed after non-inverted).\n\t\t\"\"\"\n\t\t\n\t\tret = [len(str(self)), len(self.clauses)] if len(self.clauses) > 0 else [-1]\n\t\tfor cunj in self.clauses:\n\t\t\tret.append(len(cunj.defines))\n\t\tfor cunj in self.clauses:\n\t\t\tfor d in cunj.defines:\n\t\t\t\tret.append(d.value())\n\t\treturn ret\n\t\n\tdef reduce(self) -> None:\n\t\t\"\"\"\n\t\treduce -- Reduces the number of clauses in-place\n\t\t\n\t\tRemoves the most possible number of conditions, both by removing\n\t\tconditions and by removing entire clauses.\n\t\t\n\t\tAs a side effect, sorts itself.\n\t\t\"\"\"\n\t\t# Early breaks\n\t\tif any(c.empty() for c in self.clauses):\n\t\t\tself.clauses = []\n\t\t\treturn\n\t\tif len(self.clauses) == 0:\n\t\t\treturn\n\t\telif len(self.clauses) == 1:\n\t\t\tclause = Clause()\n\t\t\tfor define in self.clauses[0].defines:\n\t\t\t\tif define in clause.defines:\n\t\t\t\t\tcontinue\n\t\t\t\telif define.inverted() in clause.defines:\n\t\t\t\t\tclause = Clause(',') # This should never happen (and never happens without breaking encapsulation)\n\t\t\t\telse:\n\t\t\t\t\tclause.append(define)\n\t\t\tclause.defines.sort(key=lambda d: Define.defines.index(d.name))\n\t\t\tself.clauses = [clause]\n\t\t\treturn\n\t\telif len(self.clauses) == 2:\n\t\t\tif len(self.clauses[0].defines) == len(self.clauses[1].defines) == 1:\n\t\t\t\tif self.clauses[0].defines[0].inverted() == self.clauses[1].defines[0]:\n\t\t\t\t\tself.clauses = []\n\t\t\t\t\treturn\n\t\t\n\t\t# Quine-McCluskey algorithm\n\t\t# matches: list of (matches, inverted_mask)\n\t\tneeded: List[Tuple[int, int]] = [\n\t\t\t(i, 0)\n\t\t\tfor i in range(1<<len(Define.defines))\n\t\t\tif any( # i matches any clause\n\t\t\t\tall( # i matches all conditions in the clause\n\t\t\t\t\t(i & (1<<Define.defines.index(define.name)) == 0) == define.inverted_\n\t\t\t\t\tfor define in clause.defines)\n\t\t\t\tfor clause in self.clauses)\n\t\t]\n\t\t\n\t\tlast_combined = needed[:]\n\t\tuncombinable: List[Tuple[int, int]] = []\n\t\twhile len(last_combined) > 0:\n\t\t\tcombined: List[Tuple[int, int]] = []\n\t\t\tcombinable: List[bool] = [False] * len(last_combined)\n\t\t\twhile len(last_combined) > 0:\n\t\t\t\tattempt = last_combined[-1]\n\t\t\t\tfor idx, (i, m) in enumerate(last_combined):\n\t\t\t\t\tif idx == len(last_combined) - 1:\n\t\t\t\t\t\tif not combinable[idx]:\n\t\t\t\t\t\t\tuncombinable.append(attempt)\n\t\t\t\t\telif m == attempt[1]:\n\t\t\t\t\t\tif (i ^ attempt[0]) & ((i ^ attempt[0]) - 1) != 0:\n\t\t\t\t\t\t\tcontinue # More than 1 bit of difference\n\t\t\t\t\t\t\n\t\t\t\t\t\tcombinable[idx] = True\n\t\t\t\t\t\tcombinable[len(last_combined) - 1] = True\n\t\t\t\t\t\tadd = (i | attempt[0], m | (i ^ attempt[0]))\n\t\t\t\t\t\tif add in combined:\n\t\t\t\t\t\t\tcontinue # Aleady added\n\t\t\t\t\t\tcombined.append(add)\n\t\t\t\tlast_combined.pop()\n\t\t\tlast_combined = combined\n\t\t\n\t\tmatches: Dict[int, List[Tuple[int, int]]] = {\n\t\t\ti: [combination for combination in uncombinable if (i | combination[1]) == combination[0]] for i, _ in needed\n\t\t}\n\t\tself.clauses = []\n\t\tmatches_size: int = 1\n\t\twhile len(matches) != 0:\n\t\t\tmatch_found = True\n\t\t\twhile match_found:\n\t\t\t\tmatch_found = False\n\t\t\t\tfor i in matches:\n\t\t\t\t\tif len(matches[i]) < matches_size:\n\t\t\t\t\t\traise NotImplementedError(\"There seems to be an error in the algorithm\")\n\t\t\t\t\telif len(matches[i]) == matches_size:\n\t\t\t\t\t\tmatch_found = True\n\t\t\t\t\t\tself.clauses.append(\n\t\t\t\t\t\t\tClause([\n\t\t\t\t\t\t\t\tDefine(\n\t\t\t\t\t\t\t\t\tn,\n\t\t\t\t\t\t\t\t\tmatches[i][0][0] & (1 << j) == 0\n\t\t\t\t\t\t\t\t) for j, n in enumerate(Define.defines) if matches[i][0][1] & (1 << j) == 0\n\t\t\t\t\t\t\t]))\n\t\t\t\t\t\tself.clauses[-1].defines.sort(key=lambda d: Define.defines.index(d.name))\n\t\t\t\t\t\tto_erase: List[int] = []\n\t\t\t\t\t\tfor j in matches:\n\t\t\t\t\t\t\tif matches[i][0] in matches[j]:\n\t\t\t\t\t\t\t\tto_erase.append(j)\n\t\t\t\t\t\tfor j in to_erase:\n\t\t\t\t\t\t\tdel matches[j]\n\t\t\t\t\t\tbreak\n\t\t\tmatches_size = matches_size + 1\n\t\tself.clauses.sort(key=lambda c: (len(c.defines), [Define.defines.index(d.name) for d in c.defines]))\n\t\n\tdef __str__(self) -> ClausesStr:\n\t\tif len(self.clauses) == 1:\n\t\t\treturn str(self.clauses[0])\n\t\telse:\n\t\t\treturn \"(\" + \") || (\".join(map(str, self.clauses)) + \")\"\n\tdef __hash__(self):\n\t\treturn hash(str(self))\n\tdef __eq__(self, o) -> bool:\n\t\treturn isinstance(o, Clauses) and (self.clauses == o.clauses)\n\nJumbledFunctions     = CustOrderedDictList[Clause, Function]\nFileSpecifics        = Dict[Filename, FileSpec]\n\nSortedGlobals        = CustOrderedDictList[Clauses, FunctionType]\nSortedRedirects      = CustOrderedDictList[Clauses, FunctionType]\n\ndef readFiles(files: Iterable[str]) -> Tuple[JumbledFunctions, JumbledFunctions, FileSpecifics]:\n\t\"\"\"\n\treadFiles\n\t\n\tThis function is the one that parses the files.\n\t\"\"\"\n\t\n\tgbls:      JumbledFunctions = CustOrderedDictList()\n\tredirects: JumbledFunctions = CustOrderedDictList()\n\tfilespecs: FileSpecifics    = {}\n\t\n\tsymbols: Dict[str, Filename] = {}\n\tneed_halt: bool = False\n\t\n\tfor filepath in files:\n\t\tfilename: Filename = filepath.split(\"/\")[-1]\n\t\tdependants: Clause = Clause()\n\t\t\n\t\tfilespec = FileSpec()\n\t\tfilespecs[filename[:-10]] = filespec\n\t\t\n\t\tdef add_symbol_name(symname: Optional[str], weak: bool = False, symsname: Dict[str, List[Tuple[str, bool]]] = {\"\": []}):\n\t\t\t# Optional arguments are evaluated only once!\n\t\t\tnonlocal need_halt\n\t\t\tif symname is None:\n\t\t\t\tfor c in symsname:\n\t\t\t\t\tif (c != \"\") and (len(symsname[c]) != 0):\n\t\t\t\t\t\t# Note: if this condition ever raises, check the wrapper pointed by it.\n\t\t\t\t\t\t# If you find no problem, comment the error below, add a \"pass\" below (so python is happy)\n\t\t\t\t\t\t# and open a ticket so I can fix this.\n\t\t\t\t\t\traise NotImplementedError(\"Some symbols are only implemented under one condition '{0}' (probably) ({1}/{2})\"\n\t\t\t\t\t\t\t\t.format(c, symsname[c][0][0], filename) + \" [extra note in the script]\")\n\t\t\t\t\tfor s, w in symsname[c]:\n\t\t\t\t\t\tif w: continue # Weak symbols never conflict with others in different libraries\n\t\t\t\t\t\t\n\t\t\t\t\t\tif s in (\n\t\t\t\t\t\t  '_init', '_fini',\n\t\t\t\t\t\t  '__bss_start', '__bss_start__', '__bss_end__', '_bss_end__',\n\t\t\t\t\t\t  '__data_start', '_edata',\n\t\t\t\t\t\t  '_end', '__end__'):\n\t\t\t\t\t\t\tcontinue # Always allow those symbols [TODO: check if OK]\n\t\t\t\t\t\tif s in symbols:\n\t\t\t\t\t\t\t# Check for resemblances between symbols[s] and filename\n\t\t\t\t\t\t\t# if filename.startswith(symbols[s][:-12]) or symbols[s].startswith(filename[:-12]):\n\t\t\t\t\t\t\t# \t# Probably OK\n\t\t\t\t\t\t\t# \tcontinue\n\t\t\t\t\t\t\t# Manual incompatible libs detection\n\t\t\t\t\t\t\tmatch = lambda l, r: (filename[7:-10], symbols[s][7:-10]) in [(l, r), (r, l)]\n\t\t\t\t\t\t\tif  match(\"gdkx112\",     \"gdk3\")        \\\n\t\t\t\t\t\t\t or match(\"gtkx112\",     \"gtk3\")        \\\n\t\t\t\t\t\t\t or match(\"libjpeg\",     \"libjpeg62\")   \\\n\t\t\t\t\t\t\t or match(\"libncurses\",  \"libncurses6\") \\\n\t\t\t\t\t\t\t or match(\"libncurses\",  \"libncursesw\") \\\n\t\t\t\t\t\t\t or match(\"libncurses6\", \"libncursesw\") \\\n\t\t\t\t\t\t\t or match(\"libtinfo6\",   \"libtinfo\")    \\\n\t\t\t\t\t\t\t or match(\"png12\",       \"png16\")       \\\n\t\t\t\t\t\t\t or match(\"sdl1\",        \"sdl2\")        \\\n\t\t\t\t\t\t\t or match(\"sdl1image\",   \"sdl2image\")   \\\n\t\t\t\t\t\t\t or match(\"sdl1mixer\",   \"sdl2mixer\")   \\\n\t\t\t\t\t\t\t or match(\"sdl1net\",     \"sdl2net\")     \\\n\t\t\t\t\t\t\t or match(\"sdl1ttf\",     \"sdl2ttf\")     \\\n\t\t\t\t\t\t\t or match(\"smpeg\",       \"smpeg2\")      \\\n\t\t\t\t\t\t\t or match(\"udev0\",       \"udev1\")       \\\n\t\t\t\t\t\t\t or match(\"gstinterfaces010\",\"gstvideo\")\\\n\t\t\t\t\t\t\t or match(\"gstinterfaces010\",\"gstaudio\")\\\n\t\t\t\t\t\t\t or match(\"gstreamer010\",\"gstreamer\")\t\\\n\t\t\t\t\t\t\t or match(\"appindicator\",\"appindicator3\")\\\n\t\t\t\t\t\t\t or match(\"appindicator\",\"ayatanaappindicator3\")\\\n\t\t\t\t\t\t\t or match(\"appindicator3\",\"ayatanaappindicator3\")\\\n\t\t\t\t\t\t\t \\\n\t\t\t\t\t\t\t or match(\"libc\",        \"tcmallocminimal\") \\\n\t\t\t\t\t\t\t or match(\"libc\",        \"ldlinux\") \t\\\n\t\t\t\t\t\t\t or match(\"libc\",        \"tbbmallocproxy\") \\\n\t\t\t\t\t\t\t or match(\"tcmallocminimal\",\"tbbmallocproxy\") \\\n\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t# libc and ldlinux have some \"__libc_\" data symbols in common... TODO check if ok\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Note: this test is very (too) simple. If it ever raises, comment\n\t\t\t\t\t\t\t# `need_halt = True` and open an issue.\n\t\t\t\t\t\t\tprint(\"The symbol {0} is declared in multiple files ({1}/{2})\"\n\t\t\t\t\t\t\t\t.format(s, symbols[s], filename) + \" [extra note in the script]\", file=sys.stderr)\n\t\t\t\t\t\t\tneed_halt = True\n\t\t\t\t\t\tsymbols[s] = filename\n\t\t\telse:\n\t\t\t\tsymname = symname.strip()\n\t\t\t\tif symname == \"\":\n\t\t\t\t\traise ValueError(\"This symbol name (\\\"\\\") is suspicious... ({0})\".format(filename))\n\t\t\t\t\n\t\t\t\tl = len(dependants.defines)\n\t\t\t\talready_pst = any(s == symname for s, _ in symsname[\"\"])\n\t\t\t\tif l == 1:\n\t\t\t\t\tsymsname.setdefault(str(dependants), [])\n\t\t\t\t\talready_pst = already_pst or any(s == symname for s, _ in symsname[str(dependants)])\n\t\t\t\tif already_pst:\n\t\t\t\t\tprint(\"The symbol {0} is duplicated! ({1})\".format(symname, filename), file=sys.stderr)\n\t\t\t\t\tneed_halt = True\n\t\t\t\t\treturn\n\t\t\t\tif l == 1:\n\t\t\t\t\ts = str(dependants.defines[0].inverted())\n\t\t\t\t\tif (s in symsname) and ((symname, weak) in symsname[s]):\n\t\t\t\t\t\tsymsname[s].remove((symname, weak))\n\t\t\t\t\t\tsymsname[\"\"].append((symname, weak))\n\t\t\t\t\telif (s in symsname) and ((symname, not weak) in symsname[s]):\n\t\t\t\t\t\tprint(\"The symbol {0} doesn't have the same 'weakness' in different conditions! ({1})\"\n\t\t\t\t\t\t\t.format(symname, filename), file=sys.stderr)\n\t\t\t\t\t\tneed_halt = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tsymsname[str(dependants)].append((symname, weak))\n\t\t\t\telif l == 0:\n\t\t\t\t\tsymsname[\"\"].append((symname, weak))\n\t\t\n\t\twith open(filepath, 'r') as file:\n\t\t\tfor line in file:\n\t\t\t\tln = line.strip()\n\t\t\t\t\n\t\t\t\ttry:\n\t\t\t\t\t# If the line is a `#' line (#ifdef LD80BITS/#ifndef LD80BITS/header)\n\t\t\t\t\tif ln.startswith(\"#\"):\n\t\t\t\t\t\tpreproc_cmd = ln[1:].strip()\n\t\t\t\t\t\tif preproc_cmd.startswith(\"if defined(GO)\"):\n\t\t\t\t\t\t\tcontinue #if defined(GO) && defined(GOM)...\n\t\t\t\t\t\telif preproc_cmd.startswith(\"if !(defined(GO)\"):\n\t\t\t\t\t\t\tcontinue #if !(defined(GO) && defined(GOM)...)\n\t\t\t\t\t\telif preproc_cmd.startswith(\"error\"):\n\t\t\t\t\t\t\tcontinue #error meh!\n\t\t\t\t\t\telif preproc_cmd.startswith(\"include\"):\n\t\t\t\t\t\t\tcontinue #inherit other library\n\t\t\t\t\t\telif preproc_cmd.startswith(\"endif\"):\n\t\t\t\t\t\t\tdependants.pop_last()\n\t\t\t\t\t\telif preproc_cmd.startswith(\"ifdef\"):\n\t\t\t\t\t\t\tdependants.append(Define(DefineType(preproc_cmd[5:].strip()), False))\n\t\t\t\t\t\telif preproc_cmd.startswith(\"ifndef\"):\n\t\t\t\t\t\t\tdependants.append(Define(DefineType(preproc_cmd[6:].strip()), True))\n\t\t\t\t\t\telif preproc_cmd.startswith(\"else\"):\n\t\t\t\t\t\t\tdependants.invert_last()\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\traise NotImplementedError(\"Unknown preprocessor directive: {0}\".format(preproc_cmd.split(\" \")[0]))\n\t\t\t\t\t\n\t\t\t\t\t# If the line is a `GO...' line (GO/GOM/GO2/...)...\n\t\t\t\t\telif ln.startswith(\"GO\"):\n\t\t\t\t\t\t# ... then look at the second parameter of the line\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tgotype = ln.split(\"(\")[0].strip()\n\t\t\t\t\t\t\tfunname = ln.split(\",\")[0].split(\"(\")[1].strip()\n\t\t\t\t\t\t\tln = ln.split(\",\")[1].split(\")\")[0].strip()\n\t\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t\traise NotImplementedError(\"Invalid GO command\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tfun = Function(funname, FunctionType(ln, filespec), gotype, filespec, filename, line)\n\t\t\t\t\t\tif not filename.endswith(\"_genvate.h\"):\n\t\t\t\t\t\t\tadd_symbol_name(fun.name, fun.isweak)\n\t\t\t\t\t\t\n\t\t\t\t\t\tif hasattr(fun, 'invalid'):\n\t\t\t\t\t\t\tneed_halt = True\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\tif fun.type.redirect or fun.type.usestruct:\n\t\t\t\t\t\t\tredirects[dependants.copy()].append(fun)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tgbls[dependants.copy()].append(fun)\n\t\t\t\t\t\n\t\t\t\t\t# If the line is a structure metadata information...\n\t\t\t\t\telif ln.startswith(\"//%S\"):\n\t\t\t\t\t\tmetadata = [e for e in ln.split() if e]\n\t\t\t\t\t\tif len(metadata) != 4:\n\t\t\t\t\t\t\t# If you need an empty replacement, please open a PR\n\t\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (too many/not enough fields)\")\n\t\t\t\t\t\tif metadata[0] != \"//%S\":\n\t\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (invalid signature)\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tfilespec.registerStruct(metadata[1], metadata[2], metadata[3])\n\t\t\t\t\t\n\t\t\t\t\t# If the line contains any symbol name...\n\t\t\t\t\telif (\"GO\" in ln) or (\"DATA\" in ln):\n\t\t\t\t\t\tif filename.endswith(\"_genvate.h\"):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# Probably \"//GO(..., \" or \"DATA(...,\" at least\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tsymname = ln.split('(')[1].split(',')[0].strip()\n\t\t\t\t\t\t\tadd_symbol_name(symname)\n\t\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t\t# Oops, it wasn't...\n\t\t\t\t\t\t\tpass\n\t\t\t\texcept Exception as e:\n\t\t\t\t\traise NotImplementedError(\"{0}:{1}\".format(filename, line[:-1])) from e\n\t\t\n\t\tif filename.endswith(\"_genvate.h\"):\n\t\t\tdel filespecs[filename[:-10]]\n\t\t\n\t\tadd_symbol_name(None)\n\t\tFunctionType.getSingletons().clear()\n\t\n\tif need_halt:\n\t\traise ValueError(\"Fix all previous errors before proceeding\")\n\t\n\treturn gbls, redirects, filespecs\n\ndef sortArrays(gbl_funcs: JumbledFunctions, red_funcs: JumbledFunctions, filespecs: FileSpecifics) \\\n -> Tuple[SortedGlobals, SortedRedirects]:\n\t# First sort file specific stuff\n\tfor fn in filespecs:\n\t\tfilespecs[fn].typedefs.sort(key=_BareFunctionType.splitchar)\n\t\tfor funtype in filespecs[fn].typedefs:\n\t\t\tfilespecs[fn].typedefs[funtype].sort(key=lambda f: f.name)\n\t\t\n\t\tfilespecs[fn].structs.sort()\n\t\tfilespecs[fn].structsuses.sort(key=FunctionType.splitchar)\n\t\n\t# Now, take all function types, and make a new table gbl_vals\n\t# This table contains all #if conditions for when a function type needs to\n\t# be generated.\n\tdef add_to_vals(vals: Dict[FunctionType, Clauses], t: FunctionType, clause: Clause) -> None:\n\t\tvals.setdefault(t, Clauses())\n\t\tif clause in vals[t].clauses: return\n\t\tvals[t].add(clause)\n\t\n\tgbl_vals: Dict[FunctionType, Clauses] = {}\n\tfor clause in gbl_funcs:\n\t\tfor f in gbl_funcs[clause]:\n\t\t\tadd_to_vals(gbl_vals, f.type, clause)\n\tfor clause in red_funcs:\n\t\tfor f in red_funcs[clause]:\n\t\t\tassert(f.type.redirected is not None)\n\t\t\tadd_to_vals(gbl_vals, f.type.redirected, clause)\n\t\n\t# Remove duplicate/useless conditions (and sort)\n\tfor t in gbl_vals:\n\t\tgbl_vals[t].reduce()\n\t\n\t# Now create a new gbls\n\t# gbls will contain the final version of gbls (without duplicates, based on\n\t# gbl_vals), meaning, a dict from clauses to function types to implement\n\tgbls: SortedGlobals = CustOrderedDictList()\n\tfor funtype in gbl_vals:\n\t\tgbls[gbl_vals[funtype]].append(funtype)\n\t# Sort the #if clauses as defined in `splitdef`\n\tgbls.sort(key=Clauses.splitdef)\n\t\n\t# Sort the function types as defined in `splitchar`\n\tfor clauses in gbls:\n\t\tgbls[clauses].sort(key=FunctionType.splitchar)\n\t\n\t# This map will contain all additional function types that are \"redirected\"\n\t# to an already defined type (with some remapping).\n\tred_vals: Dict[FunctionType, Clauses] = {}\n\tfor clause in red_funcs:\n\t\tfor f in red_funcs[clause]:\n\t\t\tif isinstance(f.type, StructFunctionType): continue\n\t\t\tassert(f.type.redirected is not None)\n\t\t\tadd_to_vals(red_vals, f.type, clause)\n\t\n\t# Also do the same sorting as before (it also helps keep the order\n\t# in the file deterministic)\n\tfor t in red_vals:\n\t\tred_vals[t].reduce()\n\t\n\tredirects: SortedRedirects = CustOrderedDictList()\n\tfor funtype in red_vals:\n\t\tredirects[red_vals[funtype]].append(funtype)\n\tredirects.sort(key=Clauses.splitdef)\n\t\n\tdef fail(): assert False\n\tfor clauses in redirects:\n\t\tredirects[clauses].sort(key=lambda v: fail() if v.redirected is None else v.splitchar() + v.redirected.splitchar())\n\t\n\treturn gbls, redirects\n\ndef checkRun(root: str, gbls: SortedGlobals, redirects: SortedRedirects, filespecs: FileSpecifics) -> Optional[str]:\n\t# Check if there was any new functions compared to last run\n\tfunctions_list: str = \"\"\n\tfor clauses in gbls:\n\t\tfor v in gbls[clauses]:\n\t\t\tfunctions_list = functions_list + \"#\" + str(clauses) + \" \" + v.orig + \"\\n\"\n\tfor clauses in redirects:\n\t\tfor v in redirects[clauses]:\n\t\t\tassert(v.redirected is not None)\n\t\t\tfunctions_list = functions_list + \"#\" + str(clauses) + \" \" + v.orig + \" -> \" + v.redirected.orig + \"\\n\"\n\tfor filename in sorted(filespecs.keys()):\n\t\tfunctions_list = functions_list + filename + \":\\n\"\n\t\tfor st in filespecs[filename].structs:\n\t\t\tstruct = filespecs[filename].structs[st]\n\t\t\tfunctions_list = functions_list + \\\n\t\t\t\t\"% \" + st + \" \" + struct.name + \" \" + struct.repl + \"\\n\"\n\t\tfor _bare in filespecs[filename].typedefs:\n\t\t\tfunctions_list = functions_list + \"- \" + _bare.orig + \":\\n\"\n\t\t\tfor fn in filespecs[filename].typedefs[_bare]:\n\t\t\t\tif fn.no_dlsym: continue\n\t\t\t\tfunctions_list = functions_list + \"  - \" + fn.name + \"\\n\"\n\t\tfor funtype in filespecs[filename].structsuses:\n\t\t\tassert(funtype.redirected is not None)\n\t\t\tfunctions_list = functions_list + \"% \" + funtype.orig + \" -> \" + funtype.redirected.orig + \"\\n\"\n\t\n\t# functions_list is a unique string, compare it with the last run\n\ttry:\n\t\tlast_run = \"\"\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"functions_list.txt\"), 'r') as file:\n\t\t\tlast_run = file.read()\n\t\tif last_run == functions_list:\n\t\t\t# Mark as OK for CMake\n\t\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"functions_list.txt\"), 'w') as file:\n\t\t\t\tfile.write(functions_list)\n\t\t\treturn None\n\texcept IOError:\n\t\t# The file does not exist yet, first run\n\t\tpass\n\t\n\treturn functions_list\n\ndef generate_files(root: str, files: Iterable[str], ver: str, gbls: SortedGlobals, redirects: SortedRedirects, \\\n filespecs: FileSpecifics) -> None:\n\t# Files header and guard\n\tfiles_header = {\n\t\t\"wrapper.c\": \"\"\"\n\t\t#include <stdio.h>\n\t\t#include <stdlib.h>\n\t\t#include <stdint.h>\n\t\t\n\t\t#include \"wrapper.h\"\n\t\t#include \"emu/x86emu_private.h\"\n\t\t#include \"emu/x87emu_private.h\"\n\t\t#include \"regs.h\"\n\t\t#include \"x86emu.h\"\n\t\t\n\t\ttypedef union ui64_s {lbr}\n\t\t    int64_t     i;\n\t\t    uint64_t    u;\n\t\t    uint32_t    d[2];\n\t\t{rbr} ui64_t;\n\t\t\n\t\ttypedef struct _2uint_struct_s {lbr}\n\t\t\tuint32_t\ta;\n\t\t\tuint32_t\tb;\n\t\t{rbr} _2uint_struct_t;\n\t\t\n\t\textern void* my__IO_2_1_stderr_;\n\t\textern void* my__IO_2_1_stdin_ ;\n\t\textern void* my__IO_2_1_stdout_;\n\t\t\n\t\tstatic void* io_convert(void* v)\n\t\t{lbr}\n\t\t\tif(!v)\n\t\t\t\treturn v;\n\t\t\tif(v==my__IO_2_1_stderr_)\n\t\t\t\treturn stderr;\n\t\t\tif(v==my__IO_2_1_stdin_)\n\t\t\t\treturn stdin;\n\t\t\tif(v==my__IO_2_1_stdout_)\n\t\t\t\treturn stdout;\n\t\t\treturn v;\n\t\t{rbr}\n\t\t\n\t\ttypedef struct my_GValue_s\n\t\t{lbr}\n\t\t  int         g_type;\n\t\t  union {lbr}\n\t\t    int        v_int;\n\t\t    int64_t    v_int64;\n\t\t    uint64_t   v_uint64;\n\t\t    float      v_float;\n\t\t    double     v_double;\n\t\t    void*      v_pointer;\n\t\t  {rbr} data[2];\n\t\t{rbr} my_GValue_t;\n\t\t\n\t\tstatic void alignGValue(my_GValue_t* v, void* value)\n\t\t{lbr}\n\t\t    v->g_type = *(int*)value;\n\t\t    memcpy(v->data, value+4, 2*sizeof(double));\n\t\t{rbr}\n\t\tstatic void unalignGValue(void* value, my_GValue_t* v)\n\t\t{lbr}\n\t\t    *(int*)value = v->g_type;\n\t\t    memcpy(value+4, v->data, 2*sizeof(double));\n\t\t{rbr}\n\t\t\n\t\tvoid* VulkanFromx86(void* src);\n\t\tvoid VulkanTox86(void* src);\n\t\t\n\t\t#define ST0val ST0.d\n\t\t\n\t\tint of_convert(int);\n\t\t\n\t\t\"\"\",\n\t\t\"wrapper.h\": \"\"\"\n\t\t#ifndef __WRAPPER_H_\n\t\t#define __WRAPPER_H_\n\t\t#include <stdint.h>\n\t\t#include <string.h>\n\t\t\n\t\ttypedef struct x86emu_s x86emu_t;\n\t\t\n\t\t// the generic wrapper pointer functions\n\t\ttypedef void (*wrapper_t)(x86emu_t* emu, uintptr_t fnc);\n\t\t\n\t\t// list of defined wrappers\n\t\t// E = current x86emu struct\n\t\t// v = void\n\t\t// C = unsigned byte c = char\n\t\t// W = unsigned short w = short\n\t\t// u = uint32, i = int32\n\t\t// U = uint64, I = int64\n\t\t// L = unsigned long, l = signed long (long is an int with the size of a pointer)\n\t\t// p = pointer\n\t\t// f = float, d = double, D = long double, K = fake long double\n\t\t// V = vaargs, s = address on the stack (doesn't move forward the pointer)\n\t\t// O = libc O_ flags bitfield\n\t\t// o = stdout\n\t\t// S = _IO_2_1_stdXXX_ pointer (or FILE*)\n\t\t// 2 = struct of 2 uint\n\t\t// N = ... automatically sending 1 arg\n\t\t// M = ... automatically sending 2 args\n\t\t// P = Vulkan struct pointer, G = a single GValue pointer\n\t\t\n\t\t\"\"\",\n\t\t\"fntypes.h\": \"\"\"\n\t\t#ifndef __{filename}TYPES_H_\n\t\t#define __{filename}TYPES_H_\n\t\t\n\t\t#ifndef LIBNAME\n\t\t#error You should only #include this file inside a wrapped*.c file\n\t\t#endif\n\t\t#ifndef ADDED_FUNCTIONS\n\t\t#define ADDED_FUNCTIONS() \n\t\t#endif\n\t\t\n\t\t\"\"\",\n\t\t\"fndefs.h\": \"\"\"\n\t\t#ifndef __{filename}DEFS_H_\n\t\t#define __{filename}DEFS_H_\n\t\t\n\t\t\"\"\",\n\t\t\"fnundefs.h\": \"\"\"\n\t\t#ifndef __{filename}UNDEFS_H_\n\t\t#define __{filename}UNDEFS_H_\n\t\t\n\t\t\"\"\"\n\t}\n\tfiles_guard = {\n\t\t\"wrapper.c\": \"\"\"\n\t\t\"\"\",\n\t\t\"wrapper.h\": \"\"\"\n\t\t#endif // __WRAPPER_H_\n\t\t\"\"\",\n\t\t\"fntypes.h\": \"\"\"\n\t\t#endif // __{filename}TYPES_H_\n\t\t\"\"\",\n\t\t\"fndefs.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}DEFS_H_\n\t\t\"\"\",\n\t\t\"fnundefs.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}UNDEFS_H_\n\t\t\"\"\"\n\t}\n\tbanner = \"/********************************************************\" + ('*'*len(ver)) + \"***\\n\" \\\n\t         \" * File automatically generated by rebuild_wrappers.py (v\" + ver + \") *\\n\" \\\n\t         \" ********************************************************\" + ('*'*len(ver)) + \"***/\\n\"\n\ttrim: Callable[[str], str] = lambda string: '\\n'.join(line[2:] for line in string.splitlines())[1:]\n\t# Yes, the for loops are inverted. This is because both dicts should have the same keys.\n\tfor fhdr in files_guard:\n\t\tfiles_header[fhdr] = banner + trim(files_header[fhdr])\n\tfor fhdr in files_header:\n\t\tfiles_guard[fhdr] = trim(files_guard[fhdr])\n\t\n\t# TODO: put the informations below in a structure (like in box64, where\n\t# typedefs & co. are stored in an ABI-specific structure)\n\t\n\treturn_x87: str = \"DKdf\"\n\tif any(c not in FileSpec.values for c in return_x87):\n\t\traise NotImplementedError(\"Invalid character\")\n\t\n\t# Typedefs\n\t#           E            v       c         w          i          I          C          W           u           U           f        d         D              K         l           L            p        V        O          S        2                  P        G        N      M      s\n\ttdtypes = [\"x86emu_t*\", \"void\", \"int8_t\", \"int16_t\", \"int32_t\", \"int64_t\", \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\", \"float\", \"double\", \"long double\", \"double\", \"intptr_t\", \"uintptr_t\", \"void*\", \"void*\", \"int32_t\", \"void*\", \"_2uint_struct_t\", \"void*\", \"void*\", \"...\", \"...\", \"void*\"]\n\tif len(FileSpec.values) != len(tdtypes):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(tdtypes) = {lentypes}\".format(lenval=len(FileSpec.values), lentypes=len(tdtypes)))\n\tdef generate_typedefs(funs: Iterable[FunctionType], file):\n\t\tfor funtype in funs:\n\t\t\tdef getstr(i: int) -> str:\n\t\t\t\tif i < len(tdtypes):\n\t\t\t\t\treturn tdtypes[i]\n\t\t\t\telse:\n\t\t\t\t\t# We are in a *types.h file\n\t\t\t\t\tassert(isinstance(funtype, _BareFunctionType) and funtype.isstruct)\n\t\t\t\t\treturn funtype.filespec.structs[funtype.filespec.structs.__keys__[i - len(tdtypes)]].name\n\t\t\tif funtype.orig.endswith(\"Ev\"):\n\t\t\t\tfile.write(\"typedef \" + getstr(funtype.getcharidx(0)) + \" (*\" + funtype.orig + \"_t)\"\n\t\t\t\t\t\t\t+ \"(\" + getstr(funtype.getchar('E')) + \");\\n\")\n\t\t\telse:\n\t\t\t\tfile.write(\"typedef \" + getstr(funtype.getcharidx(0)) + \" (*\" + funtype.orig + \"_t)\"\n\t\t\t\t\t\t\t+ \"(\" + ', '.join(getstr(funtype.getcharidx(i)) for i in range(2, len(funtype.orig))) + \");\\n\")\n\t\n\t# Wrappers\n\t#         E  v  c  w  i  I  C  W  u  U  f  d  D   K   l  L  p  V  O  S  2  P  G  N  M  s\n\tdeltas = [0, 4, 4, 4, 4, 8, 4, 4, 4, 8, 4, 8, 12, 12, 4, 4, 4, 1, 4, 4, 8, 4, 4, 0, 0, 0]\n\tvals = [\n\t\t\"\\n#error Invalid return type: emulator\\n\",                     # E\n\t\t\"fn({0});\",                                                     # v\n\t\t\"R_EAX=fn({0});\",                                               # c\n\t\t\"R_EAX=fn({0});\",                                               # w\n\t\t\"R_EAX=fn({0});\",                                               # i\n\t\t\"ui64_t r; r.i=fn({0}); R_EAX=r.d[0]; R_EDX=r.d[1];\",           # I\n\t\t\"R_EAX=(unsigned char)fn({0});\",                                # C\n\t\t\"R_EAX=(unsigned short)fn({0});\",                               # W\n\t\t\"R_EAX=(uint32_t)fn({0});\",                                     # u\n\t\t\"ui64_t r; r.u=(uint64_t)fn({0}); R_EAX=r.d[0]; R_EDX=r.d[1];\", # U\n\t\t\"float fl=fn({0}); fpu_do_push(emu); ST0val = fl;\",             # f\n\t\t\"double db=fn({0}); fpu_do_push(emu); ST0val = db;\",            # d\n\t\t\"long double ld=fn({0}); fpu_do_push(emu); ST0val = ld;\",       # D\n\t\t\"double db=fn({0}); fpu_do_push(emu); ST0val = db;\",            # K\n\t\t\"R_EAX=(intptr_t)fn({0});\",                                     # l\n\t\t\"R_EAX=(uintptr_t)fn({0});\",                                    # L\n\t\t\"R_EAX=(uintptr_t)fn({0});\",                                    # p\n\t\t\"\\n#error Invalid return type: va_list\\n\",                      # V\n\t\t\"\\n#error Invalid return type: at_flags\\n\",                     # O\n\t\t\"\\n#error Invalid return type: _io_file*\\n\",                    # S\n\t\t\"\\n#error Invalid return type: _2uint_struct\\n\",                # 2\n\t\t\"\\n#error Invalid return type: Vulkan Struct\\n\",                # P\n\t\t\"\\n#error Invalid return type: GValue Pointer\\n\",               # G\n\t\t\"\\n#error Invalid return type: ... with 1 arg\\n\",               # N\n\t\t\"\\n#error Invalid return type: ... with 2 args\\n\",              # M\n\t\t\"\\n#error Invalid return type: address on the stack\\n\",         # V\n\t]\n\targ = [\n\t\t\"emu, \",                                               # E\n\t\t\"\",                                                    # v\n\t\t\"*(int8_t*)(R_ESP + {p}), \",                           # c\n\t\t\"*(int16_t*)(R_ESP + {p}), \",                          # w\n\t\t\"*(int32_t*)(R_ESP + {p}), \",                          # i\n\t\t\"*(int64_t*)(R_ESP + {p}), \",                          # I\n\t\t\"*(uint8_t*)(R_ESP + {p}), \",                          # C\n\t\t\"*(uint16_t*)(R_ESP + {p}), \",                         # W\n\t\t\"*(uint32_t*)(R_ESP + {p}), \",                         # u\n\t\t\"*(uint64_t*)(R_ESP + {p}), \",                         # U\n\t\t\"*(float*)(R_ESP + {p}), \",                            # f\n\t\t\"*(double*)(R_ESP + {p}), \",                           # d\n\t\t\"LD2localLD((void*)(R_ESP + {p})), \",                  # D\n\t\t\"FromLD((void*)(R_ESP + {p})), \",                      # K\n\t\t\"*(intptr_t*)(R_ESP + {p}), \",                         # l\n\t\t\"*(uintptr_t*)(R_ESP + {p}), \",                        # L\n\t\t\"*(void**)(R_ESP + {p}), \",                            # p\n\t\t\"(void*)(R_ESP + {p}), \",                              # V\n\t\t\"of_convert(*(int32_t*)(R_ESP + {p})), \",              # O\n\t\t\"io_convert(*(void**)(R_ESP + {p})), \",                # S\n\t\t\"(_2uint_struct_t){{*(uintptr_t*)(R_ESP + {p}),*(uintptr_t*)(R_ESP + {p} + 4)}}, \", # 2\n\t\t\"arg{p}, \",                                            # P\n\t\t\"&arg{p}, \",                                           # G\n\t\t\"*(void**)(R_ESP + {p}), \",                            # N\n\t\t\"*(void**)(R_ESP + {p}),*(void**)(R_ESP + {p} + 4), \", # M\n\t\t\"(void*)(R_ESP + {p}), \",                              # V\n\t]\n\t# Asserts\n\tif len(FileSpec.values) != len(deltas):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(deltas) = {lendeltas}\".format(lenval=len(FileSpec.values), lendeltas=len(deltas)))\n\tif len(FileSpec.values) != len(vals):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(vals) = {lenvals}\".format(lenval=len(FileSpec.values), lenvals=len(vals)))\n\tif len(FileSpec.values) != len(arg):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(arg) = {lenarg}\".format(lenval=len(FileSpec.values), lenarg=len(arg)))\n\t\n\t# Helper functions to write the function definitions\n\tdef function_args(args: str, d: int = 4) -> str:\n\t\tif len(args) == 0:\n\t\t\treturn \"\"\n\t\tif d % 4 != 0:\n\t\t\traise ValueError(\"{d} is not a multiple of 4. Did you try passing a V then something else?\".format(d=d))\n\t\t\n\t\treturn arg[FileSpec.values.index(args[0])].format(p=d) + function_args(args[1:], d + deltas[FileSpec.values.index(args[0])])\n\t\n\tdef function_writer(f, N: FunctionType, W: str) -> None:\n\t\tf.write(\"void {0}(x86emu_t *emu, uintptr_t fcn) {2} {1} fn = ({1})fcn; \".format(N.orig, W, \"{\"))\n\t\t\n\t\tif N.orig == 'vFv':\n\t\t\tf.write(\"(void)emu; \")\n\t\t\n\t\targs = N.orig[2:]\n\t\tif args == 'Ev': args = 'E'\n\t\t\n\t\tif any(c in 'PG' for c in args):\n\t\t\t# Vulkan struct or GValue pointer, need to unwrap functions at the end\n\t\t\tdelta = 4\n\t\t\tfor c in args:\n\t\t\t\tif c == 'P':\n\t\t\t\t\tf.write(\"void *arg{d} = VulkanFromx86(*(void**)(R_ESP + {d})); \".format(d=delta))\n\t\t\t\tif c == 'G':\n\t\t\t\t\tf.write(\"my_GValue_t arg{d}; alignGValue(&arg{d}, *(void**)(R_ESP + {d})); \".format(d=delta))\n\t\t\t\tdelta = delta + deltas[FileSpec.values.index(c)]\n\t\t\tf.write(vals[FileSpec.values.index(N.orig[0])].format(function_args(args)[:-2]) + \" \")\n\t\t\tdelta = 4\n\t\t\tfor c in args:\n\t\t\t\tif c == 'P':\n\t\t\t\t\tf.write(\"VulkanTox86(arg{d}); \".format(d=delta))\n\t\t\t\tif c == 'G':\n\t\t\t\t\tf.write(\"unalignGValue(*(void**)(R_ESP + {d}), &arg{d}); \".format(d=delta))\n\t\t\t\tdelta = delta + deltas[FileSpec.values.index(c)]\n\t\t\tf.write(\"}\\n\")\n\t\telse:\n\t\t\t# Generic function\n\t\t\tf.write(vals[FileSpec.values.index(N.orig[0])].format(function_args(args)[:-2]) + \" }\\n\")\n\t\n\t# Rewrite the wrapper.c file:\n\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"wrapper.c\"), 'w') as file:\n\t\tfile.write(files_header[\"wrapper.c\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\t\n\t\t# First part: typedefs\n\t\tfor clauses in gbls:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tgenerate_typedefs(gbls[clauses], file)\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\n\t\tfile.write(\"\\n\")\n\t\t\n\t\t# Next part: function definitions\n\t\t\n\t\tfor clauses in gbls:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in gbls[clauses]:\n\t\t\t\tfunction_writer(file, funtype, funtype.orig + \"_t\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\n\")\n\t\tfor clauses in redirects:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in redirects[clauses]:\n\t\t\t\tassert(funtype.redirected is not None)\n\t\t\t\tfunction_writer(file, funtype, funtype.redirected.orig + \"_t\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\n\t\t# Finally, write predicate functions\n\t\t\n\t\t# isRetX87Wrapper\n\t\tfile.write(\"\\nint isRetX87Wrapper(wrapper_t fun) {\\n\")\n\t\tfor clauses in gbls:\n\t\t\tempty = True\n\t\t\tfor funtype in gbls[clauses]:\n\t\t\t\tif funtype.orig[0] in return_x87: # TODO: put this in a function (functions would request the ABI for more info)\n\t\t\t\t\tif empty and (not clauses.empty()):\n\t\t\t\t\t\tfile.write(\"#if \" + str(clauses) + \"\\n\")\n\t\t\t\t\t\tempty = False\n\t\t\t\t\tfile.write(\"\\tif (fun == &\" + funtype.orig + \") return 1;\\n\")\n\t\t\tif not empty:\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\treturn 0;\\n}\\n\")\n\t\t\n\t\tfile.write(files_guard[\"wrapper.c\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\n\t# Rewrite the wrapper.h file:\n\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"wrapper.h\"), 'w') as file:\n\t\tfile.write(files_header[\"wrapper.h\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\tfor clauses in gbls:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in gbls[clauses]:\n\t\t\t\tfile.write(\"void \" + funtype.orig + \"(x86emu_t *emu, uintptr_t fnc);\\n\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\n\")\n\t\tfor clauses in redirects:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in redirects[clauses]:\n\t\t\t\tfile.write(\"void \" + funtype.orig + \"(x86emu_t *emu, uintptr_t fnc);\\n\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(files_guard[\"wrapper.h\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\n\tfor fn in filespecs:\n\t\ttdtypes[FileSpec.values.index('V')] = \"...\"\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", fn + \"types.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fntypes.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tgenerate_typedefs(filespecs[fn].typedefs, file)\n\t\t\tfile.write(\"\\n#define SUPER() ADDED_FUNCTIONS()\")\n\t\t\tfor _bare in filespecs[fn].typedefs:\n\t\t\t\tfor fun in filespecs[fn].typedefs[_bare]:\n\t\t\t\t\tif fun.no_dlsym: continue\n\t\t\t\t\tfile.write(\" \\\\\\n\\tGO({0}, {1}_t)\".format(fun.name, _bare.orig))\n\t\t\tfile.write(\"\\n\\n\")\n\t\t\tfile.write(files_guard[\"fntypes.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", fn + \"defs.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fndefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tfor defined in filespecs[fn].structsuses:\n\t\t\t\tfile.write(\"#define {defined} {define}\\n\".format(defined=defined.orig, define=defined.redirected.orig))\n\t\t\tfile.write(files_guard[\"fndefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", fn + \"undefs.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fnundefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tfor defined in filespecs[fn].structsuses:\n\t\t\t\tfile.write(\"#undef {defined}\\n\".format(defined=defined.orig))\n\t\t\tfile.write(files_guard[\"fnundefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\ndef main(root: str, files: Iterable[str], ver: str):\n\t\"\"\"\n\tmain -- The main function\n\t\n\troot: the root path (where the CMakeLists.txt is located)\n\tfiles: a list of files to parse (wrapped*.h)\n\tver: version number\n\t\"\"\"\n\t\n\t# First read the files inside the headers\n\tgbl_funcs, red_funcs, filespecs = readFiles(files)\n\t\n\tif all(not c.empty() for c in gbl_funcs) or all(not c.empty() for c in red_funcs):\n\t\tprint(\"\\033[1;31mThere is suspiciously not many types...\\033[m\", file=sys.stderr)\n\t\tprint(\"Check the CMakeLists.txt file. If you are SURE there is nothing wrong\"\n\t\t\t  \" (as a random example, `set()` resets the variable...), then comment out the following return.\", file=sys.stderr)\n\t\tprint(\"(Also, the program WILL crash later if you proceed.)\", file=sys.stderr)\n\t\treturn 2 # Check what you did, not proceeding\n\t\n\tgbls, redirects = sortArrays(gbl_funcs, red_funcs, filespecs)\n\t\n\t# Check if there was any new functions\n\tfunctions_list = checkRun(root, gbls, redirects, filespecs)\n\tif functions_list is None:\n\t\tprint(\"Detected same build as last run, skipping\")\n\t\treturn 0\n\t\n\t# Now the files rebuilding part\n\tgenerate_files(root, files, ver, gbls, redirects, filespecs)\n\t\n\t# Save the string for the next iteration, writing was successful\n\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"functions_list.txt\"), 'w') as file:\n\t\tfile.write(functions_list)\n\t\n\treturn 0\n\nif __name__ == '__main__':\n\tlimit = []\n\tfor i, v in enumerate(sys.argv):\n\t\tif v == \"--\":\n\t\t\tlimit.append(i)\n\tDefine.defines = list(map(DefineType, sys.argv[2:limit[0]]))\n\tif main(sys.argv[1], sys.argv[limit[0]+1:], \"2.0.0.11\") != 0:\n\t\texit(2)\n\texit(0)\n"
        },
        {
          "name": "runTest.cmake",
          "type": "blob",
          "size": 2.0888671875,
          "content": "# arguments checking\nif( NOT TEST_PROGRAM )\n  message( FATAL_ERROR \"Require TEST_PROGRAM to be defined\" )\nendif( NOT TEST_PROGRAM )\nif( NOT TEST_ARGS )\n  message( FATAL_ERROR \"Require TEST_ARGS to be defined\" )\nendif( NOT TEST_ARGS )\nif( NOT TEST_OUTPUT )\n  message( FATAL_ERROR \"Require TEST_OUTPUT to be defined\" )\nendif( NOT TEST_OUTPUT )\nif( NOT TEST_REFERENCE )\n  message( FATAL_ERROR \"Require TEST_REFERENCE to be defined\" )\nendif( NOT TEST_REFERENCE )\n\nset(ENV{BOX86_LOG} 0)\nset(ENV{BOX86_NOBANNER} 1)\nif( EXISTS ${CMAKE_SOURCE_DIR}/x86lib )\n  # we are inside box86 folder\n  set(ENV{LD_LIBRARY_PATH} ${CMAKE_SOURCE_DIR}/x86lib)\nelse()\n  # we are inside build folder\n  set(ENV{LD_LIBRARY_PATH} ${CMAKE_SOURCE_DIR}/../x86lib)\nendif( EXISTS ${CMAKE_SOURCE_DIR}/x86lib )\n\n# run the test program, capture the stdout/stderr and the result var\nexecute_process(\n  COMMAND ${TEST_PROGRAM} ${TEST_ARGS} ${TEST_ARGS2}\n  OUTPUT_FILE ${TEST_OUTPUT}\n  ERROR_VARIABLE TEST_ERROR\n  RESULT_VARIABLE TEST_RESULT\n  )\n\n# if the return value is !=0 bail out\nif( TEST_RESULT )\n  get_filename_component(TESTNAME \"${TEST_ARGS}\" NAME)\n  file(RENAME \"${TEST_OUTPUT}\" \"${CMAKE_BINARY_DIR}/${TESTNAME}.out\")\n  file(WRITE  \"${CMAKE_BINARY_DIR}/${TESTNAME}.err\" ${TEST_ERROR})\n  message( FATAL_ERROR \"Failed: Test program ${TEST_PROGRAM} exited != 0.\\n${TEST_ERROR}\" )\nendif( TEST_RESULT )\n\n# now compare the output with the reference\nexecute_process(\n  COMMAND \"${CMAKE_COMMAND}\" -E compare_files \"${TEST_OUTPUT}\" \"${TEST_REFERENCE}\"\n  RESULT_VARIABLE TEST_RESULT\n  )\n\n# again, if return value is !=0 scream and shout\nif( TEST_RESULT )\n  get_filename_component(TESTNAME \"${TEST_ARGS}\" NAME)\n  file(RENAME \"${TEST_OUTPUT}\" \"${CMAKE_BINARY_DIR}/${TESTNAME}.out\")\n  file(WRITE  \"${CMAKE_BINARY_DIR}/${TESTNAME}.err\" ${TEST_ERROR})\n  message( FATAL_ERROR \"Failed: The output of ${TEST_PROGRAM} did not match ${TEST_REFERENCE}\")\nendif( TEST_RESULT )\n\n# remove the temporary files if they exist\nif( EXISTS ${TEST_OUTPUT} )\n  file(REMOVE \"${TEST_OUTPUT}\")\nendif()\n\n# everything went fine...\nmessage( \"Passed: The output of ${TEST_PROGRAM} matches ${TEST_REFERENCE}\" )\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "system",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "wrapperhelper",
          "type": "tree",
          "content": null
        },
        {
          "name": "x86lib",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}