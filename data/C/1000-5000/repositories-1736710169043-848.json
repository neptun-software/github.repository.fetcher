{
  "metadata": {
    "timestamp": 1736710169043,
    "page": 848,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mattiasgustavsson/libs",
      "stars": 1701,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8125,
          "content": "![build](https://github.com/mattiasgustavsson/libs/actions/workflows/main.yml/badge.svg)\n\n# libs\nSingle-file public domain libraries for C/C++ (dual licensed under MIT).\n\n* [app.h](docs/app.md) - Small cross-platform base framework for graphical apps, for C/C++.\n* [assetsys.h](docs/assetsys.md) - File system abstraction to read from zip-files, for C/C++.\n* [hashtable.h](docs/hashtable.md) - Cache efficient hash table implementation for C/C++.\n* [http.h](docs/http.md) - Basic HTTP protocol implementation over sockets (no https).\n* [ini.h](docs/ini.md) - Simple ini-file reader for C/C++.\n* [rnd.h](docs/rnd.md) - Pseudo-random number generators for C/C++.\n* [strpool.h](docs/strpool.md) - Highly efficient string pool for C/C++.\n* [thread.h](docs/thread.md) - Cross platform threading functions for C/C++.\n\n\n# wip libs\nMore libs, work-in-progress, some are unfinished, some are complete but lacking documentation.\n\n* array.h - Dynamic array library for C/C++.\n* audiosys.h - Sound mixer library for C/C++.\n* buffer.h - Memory buffer with read/write operations, for C/C++.\n* crtemu.h - Cathode ray tube emulation shader for C/C++.\n* cstr.h - String interning and manipulation library for C/C++.\n* dialog.h - Loading and management of dialogs for a custom game dialog system.\n* dir.h - Directory listing functions for C/C++.\n* frametimer.h - Framerate timer functionality, for C/C++.\n* id3tag.h - Read/write ID3 tags from/to mp3 files in C/C++.\n* img.h - Image processing functions for C/C++.\n* mus.h - Parsing library for MUS music files (as used in DOS games).\n* paldither.h - Convert true-color image to custom palette, with dither.\n* palettize.h - Median-cut palette generation and remapping for C/C++.\n* palrle.h - Run-length encoding of palettized bitmaps, for C/C++.\n* pixelfont.h - Custom pixel font format builder and renderer.\n* sysfont.h - Simple debug text renderer for C/C++.\n* testfw.h - Basic test framework for C/C++.\n\n\n# repackaged libs\nSingle-file header-only versions of libs written by other people, released under the same license as the original lib.\nI recommend using the latest version of these libs - I only repackage them like this to fit my single-file-libs centered\ndev paradigm, and if you don't absolutely need that, you are better off using the original multi-file versions.\n\n* ftplib.h - FTP client lib for C/C++. *By Thomas Pfau.*\n* hoedown.h - Markdown to HTML renderer for C/C++. *By Porte/Marti/Mendez/Torres.*\n* libxdiff.h - File Differential Library. *By Davide Libenzi.*\n* lzma.h - LZMA data compression/decompression library. *By Igor Pavlov.*\n* opl.h - OPL3/SB16 emulation with MIDI interface. *Based on code by Aaron Giles and Mateusz Viste* \n* samplerate.h - Sample-rate converter (libsamplerate) for C/C++. *By Erik de Castro Lopo*\n* speech.h - Basic text-to-speech synthesizer for C/C++. *By Jari Komppa / Nick Ing-Simmons (et al)*\n"
        },
        {
          "name": "app.h",
          "type": "blob",
          "size": 209.9755859375,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\napp.h - v0.5 - Small cross-platform base framework for graphical apps.\n\nDo this:\n    #define APP_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n\n#ifndef app_h\n#define app_h\n\n#ifndef APP_S16\n    #define APP_S16 short\n#endif\n#ifndef APP_U32\n    #define APP_U32 unsigned int\n#endif\n#ifndef APP_U64\n    #define APP_U64 unsigned long long\n#endif\n\n\ntypedef struct app_t app_t;\n\nint app_run( int (*app_proc)( app_t*, void* ), void* user_data, void* memctx, void* logctx, void* fatalctx );\n\ntypedef enum app_state_t { APP_STATE_EXIT_REQUESTED, APP_STATE_NORMAL, } app_state_t;\napp_state_t app_yield( app_t* app );\nvoid app_cancel_exit( app_t* app );\n\nvoid app_title( app_t* app, char const* title );\n\nchar const* app_cmdline( app_t* app );\nchar const* app_filename( app_t* app );\nchar const* app_userdata( app_t* app );\nchar const* app_appdata( app_t* app );\n\nAPP_U64 app_time_count( app_t* app );\nAPP_U64 app_time_freq( app_t* app );\n\ntypedef enum app_log_level_t { APP_LOG_LEVEL_INFO, APP_LOG_LEVEL_WARNING, APP_LOG_LEVEL_ERROR, } app_log_level_t;\nvoid app_log( app_t* app, app_log_level_t level, char const* message );\nvoid app_fatal_error( app_t* app, char const* message );\n\nvoid app_pointer( app_t* app, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y );\nvoid app_pointer_default( app_t* app, int* width, int* height, APP_U32* pixels_abgr, int* hotspot_x, int* hotspot_y );\n\nvoid app_pointer_pos( app_t* app, int x, int y );\nint app_pointer_x( app_t* app );\nint app_pointer_y( app_t* app );\n\nvoid app_pointer_limit( app_t* app, int x, int y, int width, int height );\nvoid app_pointer_limit_off( app_t* app );\n\ntypedef enum app_interpolation_t { APP_INTERPOLATION_NONE, APP_INTERPOLATION_LINEAR, } app_interpolation_t;\nvoid app_interpolation( app_t* app, app_interpolation_t interpolation );\n\ntypedef enum app_screenmode_t { APP_SCREENMODE_WINDOW, APP_SCREENMODE_FULLSCREEN, } app_screenmode_t;\nvoid app_screenmode( app_t* app, app_screenmode_t screenmode );\n\nvoid app_window_size( app_t* app, int width, int height );\nint app_window_width( app_t* app );\nint app_window_height( app_t* app );\n\nvoid app_window_pos( app_t* app, int x, int y );\nint app_window_x( app_t* app );\nint app_window_y( app_t* app );\n\ntypedef struct app_display_t\n    {\n    char id[ 64 ];\n    int x;\n    int y;\n    int width;\n    int height;\n    } app_display_t ;\n\ntypedef struct app_displays_t { app_display_t* displays; int count; } app_displays_t;\napp_displays_t app_displays( app_t* app );\n\nvoid app_present( app_t* app, APP_U32 const* pixels_xbgr, int width, int height, APP_U32 mod_xbgr, APP_U32 border_xbgr );\n\nvoid app_sound( app_t* app, int sample_pairs_count,\n    void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data ), void* user_data );\nvoid app_sound_volume( app_t* app, float volume );\n\ntypedef enum app_key_t { APP_KEY_INVALID, APP_KEY_LBUTTON, APP_KEY_RBUTTON, APP_KEY_CANCEL, APP_KEY_MBUTTON,\n    APP_KEY_XBUTTON1, APP_KEY_XBUTTON2, APP_KEY_BACK, APP_KEY_TAB, APP_KEY_CLEAR, APP_KEY_RETURN, APP_KEY_SHIFT,\n    APP_KEY_CONTROL, APP_KEY_MENU, APP_KEY_PAUSE, APP_KEY_CAPITAL, APP_KEY_KANA, APP_KEY_HANGUL = APP_KEY_KANA,\n    APP_KEY_JUNJA, APP_KEY_FINAL, APP_KEY_HANJA, APP_KEY_KANJI = APP_KEY_HANJA, APP_KEY_ESCAPE, APP_KEY_CONVERT,\n    APP_KEY_NONCONVERT, APP_KEY_ACCEPT, APP_KEY_MODECHANGE, APP_KEY_SPACE, APP_KEY_PRIOR, APP_KEY_NEXT, APP_KEY_END,\n    APP_KEY_HOME, APP_KEY_LEFT, APP_KEY_UP, APP_KEY_RIGHT, APP_KEY_DOWN, APP_KEY_SELECT, APP_KEY_PRINT, APP_KEY_EXEC,\n    APP_KEY_SNAPSHOT, APP_KEY_INSERT, APP_KEY_DELETE, APP_KEY_HELP, APP_KEY_0, APP_KEY_1, APP_KEY_2, APP_KEY_3,\n    APP_KEY_4, APP_KEY_5, APP_KEY_6, APP_KEY_7, APP_KEY_8, APP_KEY_9, APP_KEY_A, APP_KEY_B, APP_KEY_C, APP_KEY_D,\n    APP_KEY_E, APP_KEY_F, APP_KEY_G, APP_KEY_H, APP_KEY_I, APP_KEY_J, APP_KEY_K, APP_KEY_L, APP_KEY_M, APP_KEY_N,\n    APP_KEY_O, APP_KEY_P, APP_KEY_Q, APP_KEY_R, APP_KEY_S, APP_KEY_T, APP_KEY_U, APP_KEY_V, APP_KEY_W, APP_KEY_X,\n    APP_KEY_Y, APP_KEY_Z, APP_KEY_LWIN, APP_KEY_RWIN, APP_KEY_APPS, APP_KEY_SLEEP, APP_KEY_NUMPAD0, APP_KEY_NUMPAD1,\n    APP_KEY_NUMPAD2, APP_KEY_NUMPAD3, APP_KEY_NUMPAD4, APP_KEY_NUMPAD5, APP_KEY_NUMPAD6, APP_KEY_NUMPAD7,\n    APP_KEY_NUMPAD8, APP_KEY_NUMPAD9, APP_KEY_MULTIPLY, APP_KEY_ADD, APP_KEY_SEPARATOR, APP_KEY_SUBTRACT,\n    APP_KEY_DECIMAL, APP_KEY_DIVIDE, APP_KEY_F1, APP_KEY_F2, APP_KEY_F3, APP_KEY_F4, APP_KEY_F5, APP_KEY_F6, APP_KEY_F7,\n    APP_KEY_F8, APP_KEY_F9, APP_KEY_F10, APP_KEY_F11, APP_KEY_F12, APP_KEY_F13, APP_KEY_F14, APP_KEY_F15, APP_KEY_F16,\n    APP_KEY_F17, APP_KEY_F18, APP_KEY_F19, APP_KEY_F20, APP_KEY_F21, APP_KEY_F22, APP_KEY_F23, APP_KEY_F24,\n    APP_KEY_NUMLOCK, APP_KEY_SCROLL, APP_KEY_LSHIFT, APP_KEY_RSHIFT, APP_KEY_LCONTROL, APP_KEY_RCONTROL, APP_KEY_LMENU,\n    APP_KEY_RMENU, APP_KEY_BROWSER_BACK, APP_KEY_BROWSER_FORWARD, APP_KEY_BROWSER_REFRESH, APP_KEY_BROWSER_STOP,\n    APP_KEY_BROWSER_SEARCH, APP_KEY_BROWSER_FAVORITES, APP_KEY_BROWSER_HOME, APP_KEY_VOLUME_MUTE, APP_KEY_VOLUME_DOWN,\n    APP_KEY_VOLUME_UP, APP_KEY_MEDIA_NEXT_TRACK, APP_KEY_MEDIA_PREV_TRACK, APP_KEY_MEDIA_STOP, APP_KEY_MEDIA_PLAY_PAUSE,\n    APP_KEY_LAUNCH_MAIL, APP_KEY_LAUNCH_MEDIA_SELECT, APP_KEY_LAUNCH_APP1, APP_KEY_LAUNCH_APP2, APP_KEY_OEM_1,\n    APP_KEY_OEM_PLUS, APP_KEY_OEM_COMMA, APP_KEY_OEM_MINUS, APP_KEY_OEM_PERIOD, APP_KEY_OEM_2, APP_KEY_OEM_3,\n    APP_KEY_OEM_4, APP_KEY_OEM_5, APP_KEY_OEM_6, APP_KEY_OEM_7, APP_KEY_OEM_8, APP_KEY_OEM_102, APP_KEY_PROCESSKEY,\n    APP_KEY_ATTN, APP_KEY_CRSEL, APP_KEY_EXSEL, APP_KEY_EREOF, APP_KEY_PLAY, APP_KEY_ZOOM, APP_KEY_NONAME, APP_KEY_PA1,\n    APP_KEY_OEM_CLEAR, APP_KEYCOUNT } app_key_t;\n\ntypedef enum app_input_type_t { APP_INPUT_KEY_DOWN, APP_INPUT_KEY_UP, APP_INPUT_DOUBLE_CLICK, APP_INPUT_CHAR,\n    APP_INPUT_MOUSE_MOVE, APP_INPUT_MOUSE_DELTA, APP_INPUT_SCROLL_WHEEL, APP_INPUT_TABLET } app_input_type_t;\n\ntypedef enum app_pressed_t { APP_NOT_PRESSED, APP_PRESSED, } app_pressed_t;\n\ntypedef struct app_input_event_t\n    {\n    app_input_type_t type;\n    union data_t\n        {\n        app_key_t key;\n        char char_code;\n        struct { int x; int y; } mouse_pos;\n        struct { float x; float y; } mouse_delta;\n        float wheel_delta;\n        struct { int x; int y; float pressure; app_pressed_t tip; app_pressed_t lower; app_pressed_t upper; } tablet;\n        } data;\n    } app_input_event_t;\n\ntypedef struct app_input_t { app_input_event_t* events; int count; } app_input_t;\napp_input_t app_input( app_t* app );\n\nvoid app_coordinates_window_to_bitmap( app_t* app, int width, int height, int* x, int* y );\nvoid app_coordinates_bitmap_to_window( app_t* app, int width, int height, int* x, int* y );\n\n#endif /* app_h */\n\n\n/**\n\napp.h\n=====\n\nSmall cross-platform base framework for graphical apps.\n\n\nExample\n-------\n\nHere's a basic sample program which starts a windowed app and plots random pixels.\n\n    #define  APP_IMPLEMENTATION\n    #define  APP_WINDOWS\n    #include \"app.h\"\n\n    #include <stdlib.h> // for rand and __argc/__argv\n    #include <string.h> // for memset\n\n    int app_proc( app_t* app, void* user_data ) {\n        APP_U32 canvas[ 320 * 200 ]; // a place for us to draw stuff\n        memset( canvas, 0xC0, sizeof( canvas ) ); // clear to grey\n        app_screenmode( app, APP_SCREENMODE_WINDOW );\n\n        // keep running until the user close the window\n        while( app_yield( app ) != APP_STATE_EXIT_REQUESTED ) {\n            // plot a random pixel on the canvas\n            int x = rand() % 320;\n            int y = rand() % 200;\n            APP_U32 color = rand() | ( (APP_U32) rand() << 16 );\n            canvas[ x + y * 320 ] = color;\n\n            // display the canvas\n            app_present( app, canvas, 320, 200, 0xffffff, 0x000000 );\n        }\n        return 0;\n    }\n\n    int main( int argc, char** argv ) {\n        (void) argc, argv;\n        return app_run( app_proc, NULL, NULL, NULL, NULL );\n    }\n\n    // pass-through so the program will build with either /SUBSYSTEM:WINDOWS or /SUBSYSTEN:CONSOLE\n    extern \"C\" int __stdcall WinMain( struct HINSTANCE__*, struct HINSTANCE__*, char*, int ) { return main( __argc, __argv ); }\n\n\n\nAPI Documentation\n-----------------\n\napp.h is a single-header library, and does not need any .lib files or other binaries, or any build scripts. To use it,\nyou just include app.h to get the API declarations. To get the definitions, you must include app.h from *one* single\nC or C++ file, and #define the symbol `APP_IMPLEMENTATION` before you do.\n\nAs app.h is a cross platform library, you must also define which platform you are running on, like this for Windows:\n\n    #define APP_IMPLEMENTATION\n    #define APP_WINDOWS\n    #include \"app.h\"\n\nOr like this for other platforms:\n    #define APP_IMPLEMENTATION\n    #define APP_SDL\n    #include \"app.h\"\n\n### Customization\n\nThere are a few different things in app.h which are configurable by #defines. Most of the API use the `int` data type,\nfor integer values where the exact size is not important. However, for some functions, it specifically makes use of 16,\n32 and 64 bit data types. These default to using `short`, `unsigned int` and `unsigned long long` by default, but can be\nredefined by #defining APP_S16, APP_U32 and APP_U64 respectively, before including app.h. This is useful if you, for\nexample, use the types from `<stdint.h>` in the rest of your program, and you want app.h to use compatible types. In\nthis case, you would include app.h using the following code:\n\n    #define APP_S16 int16_t\n    #define APP_U32 uint32_t\n    #define APP_U64 uint64_t\n    #include \"app.h\"\n\nNote that when customizing the data types, you need to use the same definition in every place where you include app.h,\nas they affect the declarations as well as the definitions.\n\nThe rest of the customizations only affect the implementation, so will only need to be defined in the file where you\nhave the #define APP_IMPLEMENTATION.\n\n\n#### Custom memory allocators\n\nEven though app.h attempts to minimize the memory use and number of allocations, it still needs to make *some* use of\ndynamic allocation by calling `malloc`. Programs might want to keep track of allocations done, or use custom defined\npools to allocate memory from. app.h allows for specifying custom memory allocation functions for `malloc` and `free`.\nThis is done with the following code:\n\n    #define APP_IMPLEMENTATION\n    #define APP_MALLOC( ctx, size ) ( my_custom_malloc( ctx, size ) )\n    #define APP_FREE( ctx, ptr ) ( my_custom_free( ctx, ptr ) )\n    #include \"app.h\"\n\nwhere `my_custom_malloc` and `my_custom_free` are your own memory allocation/deallocation functions. The `ctx` parameter\nis an optional parameter of type `void*`. When `app_run` is called, you can pass in a `memctx` parameter, which can be a\npointer to anything you like, and which will be passed through as the `ctx` parameter to every APP_MALLOC/APP_FREE call.\nFor example, if you are doing memory tracking, you can pass a pointer to your tracking data as `memctx`, and in your\ncustom allocation/deallocation function, you can cast the `ctx` param back to the right type, and access the tracking\ndata.\n\nIf no custom allocator is defined, app.h will default to `malloc` and `free` from the C runtime library.\n\n\n#### Custom logging function\n\nThere's a bunch of things being logged when app.h runs. It will log an informational entry with the date and time for\nwhen the app is started and stopped, it will log warnings when non-essential initialization fails, and it will log\nerror messages when things go wrong. By default, logging is done by a simple printf to stdout. As some applications may\nneed a different behavior, such as writing out a log file, it is possible to override the default logging behavior\nthrough defines like this:\n\n    #define APP_IMPLEMENTATION\n    #define APP_LOG( ctx, level, message ) ( my_log_func( ctx, level, message ) )\n    #include \"app.h\"\n\nwhere `my_log_func` is your own logging function. Just like for the memory allocators, the `ctx` parameter is optional,\nand is just a `void*` value which is passed through. But in the case of logging, it will be passed through as the value\noff the `logctx` parameter passed into `app_run`. The `level` parameter specifies the severity level of the logging,\nand can be used to direct different types of messages to different logging systems, or filter out messages of certain\nseverity level, e.g. supressing informational messages.\n\n\n#### Custom fatal error function\n\nAs the app.h library works on the lowest level of your program, interfacing directly with the operating system, there\nmight occur errors which it can not recover from. In these cases, a *fatal error* will be reported. By default, when a\nfatal error happens, app.h will print a message to stdout, show a messagebox to the user, and force exit the program.\n\nIt is possible to change this behaviour using the following define:\n\n    #define APP_IMPLEMENTATION\n    #define APP_FATAL_ERROR( ctx, message ) ( my_custom_fatal_error_func( ctx, message ) )\n    #include \"app.h\"\n\nwhere `my_custom_fatal_error_func` is your own error reporting function. The `ctx` parameter fills the same purpose as\nfor the allocator and logging functions, but here it is the `fatalctx` parameter to `app_run` which is passed through.\n\n\napp_run\n-------\n\n    int app_run( int (*app_proc)( app_t*, void* ), void* user_data, void* memctx, void* logctx, void* fatalctx )\n\nCreates a new app instance, calls the given app_proc and waits for it to return. Then it destroys the app instance.\n\n* app_proc - function pointer to the user defined starting point of the app. The parameters to that function are:\n    app_t* a pointer to the app instance. This is an opaque type, and it is passed to all other functions in the API.\n    void* pointer to the user defined data that was passed as the `user_data` parameter to `app_run`.\n* user_data - pointer to user defined data which will be passed through to app_proc. May be NULL.\n* memctx - pointer to user defined data which will be passed through to custom APP_MALLOC/APP_FREE calls. May be NULL.\n* logctx - pointer to user defined data to be passed through to custom APP_LOG calls. May be NULL.\n* fatalctx - pointer to user defined data to be passed through to custom APP_FATAL_ERROR calls. May be NULL.\n\nWhen app_run is called, it will perform all the initialization needed by app.h, and create an `app_t*` instance. It will\nthen call the user-specified `app_proc`, and wait for it to return. The `app_t*` instance will be passed to `app_proc`,\nand can be used to call other functions in the API. When returning from `app_proc`, a return value is specified, and\n`app_run` will perform termination and cleanup, and destroy the `app_t*` instance, and then return the same value it got\nfrom the `app_proc`. After `app_run` returns, the `app_t*` value is no longer valid for use in any API calls.\n\n\napp_yield\n---------\n\n    app_state_t app_yield( app_t* app )\n\nAllows for app.h and the operating system to perform internal house keeping and updates. It should be called on each\niteration of your main loop.\n\nThe return value can be either `APP_STATE_NORMAL` or `APP_STATE_EXIT_REQUESTED`. `APP_STATE_EXIT_REQUESTED` means that\nthe user have requested the app to terminate, e.g. by pressing the *close* button on the window, and the user defined\n`app_proc` needs to handle this, by either returning (to signal that the app should terminate) or by calling\n`app_cancel_exit` to ignore the request. A typical pattern is to display a message to the user to confirm that the app\nshould exit. In the case of `APP_STATE_NORMAL`, there is no need to do anything.\n\n\napp_cancel_exit\n---------------\n\n    void app_cancel_exit( app_t* app )\n\nUsed to reset the `APP_STATE_EXIT_REQUESTED` state. See `app_yield` for details.\n\n\napp_title\n---------\n\n    void app_title( app_t* app, char const* title )\n\nSets the name of the application, which is displayed in the task switcher and in the title bar of the window.\n\n\napp_cmdline\n-----------\n\n    char const* app_cmdline( app_t* app )\n\nReturns the command line string used to launch the executable. This can be parsed to get command line arguments.\n\n\napp_filename\n------------\n\n    char const* app_filename( app_t* app )\n\nReturns the full filename and path of the executable. The first part of `app_cmdline` usually contains the name of the\nexecutable, but not necessarily the full path, depending on how it was launched. `app_filename`, however, always returns\nthe full path.\n\n\napp_userdata\n------------\n\n    char const* app_userdata( app_t* app )\n\nReturns the full path to a directory where a users personal files can be stored. Depending on the access rights of the\nuser, it may or may not be possible to write data to the same location as the executable, and instead it must be stored\nin a specific area designated by the operating system. `app_userdata` returns the path to the root if that directory.\nA typical use for this is to store the users savegame files, by creating a subfolder corresponding to your app, and save\nthe data there.\n\n\napp_appdata\n-----------\n\n    char const* app_appdata( app_t* app )\n\nReturns the full path to a directory where application specific files can be stored. Similar to the location returned by\n`app_userdata`, but suitable for application data shared between users. Typical use for this is to store the result of\ncached calculations or temporary files.\n\n\napp_time_count\n--------------\n\n    APP_U64 app_time_count( app_t* app )\n\nReturns the current value of the high precision clock. The epoch is undefined, and the resolution can vary between\nsystems. Use `app_time_freq` to convert to seconds. Typical use is to make two calls to `app_time_count` and calculate\nthe difference, to measure the time elapsed between the two calls.\n\n\napp_time_freq\n-------------\n\n    APP_U64 app_time_freq( app_t* app )\n\nReturns the number of clock ticks per second of the high precision clock. An example use case could be:\n\n    APP_U64 current_count = app_time_count( app );\n    APP_U64 delta_count = current_count - previous_count;\n    double delta_time = ( (double) delta_count ) / ( (double) app_time_freq( app ) );\n    previous_count = current_count;\n\nto measure the time between two iterations through your main loop.\n\n\napp_log\n-------\n\n    void app_log( app_t* app, app_log_level_t level, char const* message )\n\napp.h will do logging on certain events, e.q when the app starts and ends or when something goes wrong. As the logging\ncan be customized (see section on customization), it might be desirable for the program to do its own logging the same\nway as app.h does it. By calling `app_log`, logging will be done the same way as it is done inside app.h, whether custom\nlogging or default logging is being used.\n\n\napp_fatal_error\n---------------\n\n    void app_fatal_error( app_t* app, char const* message )\n\nSame as with app_log, but for reporting fatal errors, `app_fatal_error` will report an error the same way as is done\ninternally in app.h, whether custom or default fatal error reporting is being used.\n\n\napp_pointer\n-----------\n\n    void app_pointer( app_t* app, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y )\n\nSets the appearence current mouse pointer. `app_pointer` is called with the following parameters:\n\n* width, height - the horizontal and vertical dimensions of the mouse pointer bitmap.\n* pixels_abgr - width x height number of pixels making up the pointer bitmap, each pixel being a 32-bit unsigned integer\n    where the highest 8 bits are the alpha channel, and the following 8-bit groups are blue, green and red channels.\n* hotspot_x, hotspot_y - offset into the bitmap of the pointer origin, the center point it will be drawn at.\n\n\napp_pointer_default\n-------------------\n\n    void app_pointer_default( app_t* app, int* width, int* height, APP_U32* pixels_abgr, int* hotspot_x, int* hotspot_y )\n\nRetrieves the width, height, pixel data and hotspot for the default mouse pointer. Useful for restoring the default\npointer after using `app_pointer`, or for doing software rendered pointers. Called with the following parameters:\n\n* width, height - pointers to integer values that are to receive the width and height of the pointer. May be NULL.\n* pixels_abgr - width x height number of pixels to receive the pointer bitmap. May be NULL\n* hotspot_x, hotspot_y - pointers to integer values that are to receive the hotspot coordinates. May be NULL.\n\nA typical pattern for calling `app_pointer_default` is to first call it with `pixels_abgr` as NULL, to query the bitmaps\ndimensions, and then call it again after preparing a large enough memory area.\n\n\napp_pointer_pos\n---------------\n\n    void app_pointer_pos( app_t* app, int x, int y )\n\nSet the position of the mouse pointer, in window coordinates. The function `app_coordinates_bitmap_to_window` can be\nused to convert between the coordinate system of the currently displayed bitmap and that of the window.\n\n\napp_pointer_limit\n-----------------\n\n    void app_pointer_limit( app_t* app, int x, int y, int width, int height )\n\nLocks the mouse pointer movements to stay within the specified area, in window coordinates. The function\n`app_coordinates_bitmap_to_window` can be used to convert between the coordinate system of the currently displayed\nbitmap and that of the window.\n\n\napp_pointer_limit_off\n---------------------\n\n    void app_pointer_limit_off( app_t* app )\n\nTurns of the mouse pointer movement restriction, allowing the pointer to be moved freely again.\n\n\napp_interpolation\n-----------------\n\n    void app_interpolation( app_t* app, app_interpolation_t interpolation )\n\napp.h supports two different modes of displaying a bitmap. When using `APP_INTERPOLATION_LINEAR`, the bitmap will be\ndrawn with bilinear interpolations, stretching it to fill the window (maintaining aspect ratio), giving it a smooth, if\nsomwhat blurry, look. With `APP_INTERPOLATION_NONE`, scaling will only be done on whole pixel ratios, using no\ninterpolation, which is particularly suitable to maintain the clean, precise look of pixel art.\n`APP_INTERPOLATION_LINEAR` is the default setting.\n\n\napp_screenmode\n--------------\n\n    void app_screenmode( app_t* app, app_screenmode_t screenmode )\n\nSwitch between windowed mode and fullscreen mode. `APP_SCREENMODE_WINDOW` is used to select windowed mode, and\n`APP_SCREENMODE_FULLSCREEN` is used to switch to fullscreen mode. `APP_SCREENMODE_FULLSCREEN` is the default. Note that\nthe app.h fullscreenmode is of the \"borderless windowed\" type, meaning that fullscreen mode just means that the window\nis set to cover the entire screen, and its borders are hidden. It does not imply any exclusive locking of GPU resources.\nWhen switching from windowed to fullscreen mode on a multi-display system, the app will go fullscreen on the display\nthat the window is currently on.\n\n\napp_window_size\n---------------\n\n    void app_window_size( app_t* app, int width, int height )\n\nSets the size of the window. If currently in `APP_SCREENMODE_FULLSCREEN` screen mode, the setting will not take effect\nuntil switching to `APP_SCREENMODE_WINDOW`. `width` and `height` specifies the size of the windows client area, not\ncounting borders, title bar or decorations.\n\n\napp_window_width/app_window_height\n----------------------------------\n\n    int app_window_width( app_t* app )\n    int app_window_height( app_t* app )\n\nReturns the current dimensions of the window (which might have been resized by the user). Regardless of whether the app\nis currently in fullscreen or windowed mode, `app_window_width` and `app_window_height` returns the dimension the window\n*would* have in windowed mode. Width and height specifies the size of the windows client area, not counting borders,\ntitle bar or decorations.\n\n\napp_window_pos\n--------------\n\n    void app_window_pos( app_t* app, int x, int y )\n\nSets the position of the top left corner of the window. If currently in `APP_SCREENMODE_FULLSCREEN` screen mode, the\nsetting will not take effect until switching to `APP_SCREENMODE_WINDOW`.\n\n\napp_window_x/app_window_y\n-------------------------\n\n    int app_window_x( app_t* app )\n    int app_window_y( app_t* app )\n\nReturns the current position of the windows top left corner. Regardless of whether the app is currently in fullscreen or\nwindowed mode, `app_window_x` and `app_window_y` returns the position the window *would* have in windowed mode.\n\n\napp_displays\n------------\n\n    app_displays_t app_displays( app_t* app )\n\nReturns a list of all displays connected to the system. For each display, the following fields are reported:\n* id - a platform specific string used to identify the display. Useful for saving which display was in use.\n* x, y - position of the top left corner of the display, relative to the primary dispay which is always at 0,0.\n* width, height - size of the display, in pixels.\n\n\napp_present\n-----------\n\n    void app_present( app_t* app, APP_U32 const* pixels_xbgr, int width, int height, APP_U32 mod_xbgr, APP_U32 border_xbgr )\n\napp.h provides a very minimal API for drawing - the only thing you can really do, is provide it with a bitmap for it to\ndisplay on the screen. It is then up to the rest of your program to implement code for drawing shapes or sprites onto\nthat bitmap. When all your drawing is done, you call `app_present` passing it the bitmap, and it will be displayed on\nthe screen. `app_present` takes the following parameters:\n* pixels_xbgr - width x height number of pixels making up the bitmap to be presented, each pixel being a 32-bit unsigned\n    integer where the highest 8 bits are not used, and the following 8-bit groups are blue, green and red channels. This\n    parameter may be NULL, in which case no bitmap is drawn, to allow for custom rendering. See below for details.\n* width, height - the horizontal and vertical dimensions of the bitmap\n* mod_xbgr - an rgb color value which will be automatically multiplied with each pixel, component by component, before\n    it is displayed. Can be used to for example fade the bitmap to/from black. Set to 0xffffff for no effect.\n* border_xbgr - an rgb color value to be used as *border color*. The borders are the areas outside of the bitmap, which\n    are visible when the window aspect ratio does not match that of the bitmap, so you get bars above or below it.\n\nSince app.h uses opengl, you can also opt to not pass a bitmap to `app_present`, by passing NULL as the `pixels_xbgr`\nparameter (in which case the rest of the parameters are ignored). When doing this, it is up to your program to perform\ndrawing using opengl calls. In this case `app_present` will work as a call to SwapBuffers only. Note that glSetViewPort\nwill be automatically called whenever the window is resized.\n\n\napp_sound_buffer_size\n---------------------\n\n    void app_sound_buffer_size( app_t* app, int sample_pairs_count )\n\nThe api for playing sound samples is just as minimal as that for drawing. app.h provides a single, looping sound stream,\nand it is up to your program to handle sound formats, voices and mixing. By calling `app_sound_buffer_size`, a sound\nstream of the specified size is initialized, and playback is started. If a `sample_pairs_count` of 0 is given, sound\nplayback will be stopped.\n\nThe sound buffer is in 44100hz, signed 16-bit stereo format, and the `sample_pairs_count` specified how many left/right\npairs of 16-bit samples the buffer will contain. As an example, to specify a 1 second stream buffer, you would give the\nvalue 44100 for the `sample_pairs_count` parameter, which would internally create a sound buffer of 176,400 bytes, from\n44100 samples x 2 channels x 2 bytes per sample. However, since the bits per sample and number of channels are fixed,\nthe exact byte size of the sound buffer is not important in the app.h API.\n\n\napp_sound_position\n------------------\n\n    int app_sound_position( app_t* app )\n\nReturns the current playback position of the sound stream, given in the number of sample pairs from the start of the\nbuffer. Typical use of a streaming sound buffer is to fill the buffer with data, wait for the playback position to get\npassed the mid point of the buffer, and then write the next bit of data over the part that has already been played, and\nso on.\n\n\napp_sound_write\n---------------\n\n    void app_sound_write( app_t* app, int sample_pairs_offset, int sample_pairs_count, APP_S16 const* sample_pairs )\n\nWrites sample data to the sound buffer. It takes the following parameters:\n\n* sample_pairs_offset - the offset into the buffer of where to start writing, in number of sample pairs from the start.\n* sample_pairs_count - the number of sample pairs to write. Must be less than the buffer size.\n* sample_pairs - an array of sound samples, as signed 16-bit integers. Must be at least `sample_pairs_count` in length.\n\nThe `sample_pairs` parameter can be NULL, in which case the corresponding part of the buffer is cleared.\n\n\napp_sound_volume\n----------------\n\n    void app_sound_volume( app_t* app, float volume )\n\nSets the output volume level of the sound stream, as a normalized linear value in the range 0.0f to 1.0f, inclusive.\n\n\napp_input\n---------\n\n    app_input_t app_input( app_t* app )\n\nReturns a list of input events which occured since the last call to `app_input`. Each input event can be of one of a\nlist of types, and the `type` field of the `app_input_event_t` struct specifies which type the event is. The `data`\nstruct is a union of fields, where only one of them is valid, depending on the value of `type`:\n* APP_INPUT_KEY_DOWN, APP_INPUT_KEY_UP, APP_INPUT_DOUBLE_CLICK - use the `key` field of the `data` union, which contains\n    one of the keyboard key identifiers from the `app_key_t` enumeration. `APP_INPUT_KEY_DOWN` means a key was pressed,\n    or that it was held long enough for the key repeat to kick in. `APP_INPUT_KEY_UP` means a key was released, and is\n    not sent on key repeats. For both these events, a `key` may also mean a mouse button, as those are listed in the\n    `app_key_t` enum. `APP_INPUT_DOUBLE_CLICK` means a mouse button have been double clicked, and is not sent for\n    keyboard keys.\n* APP_INPUT_CHAR - use the `char_code` field of the `data` union, which contains the ASCII value of the key that was\n    pressed. This is used to read text input, and will handle things like upper/lower case, and characters which\n    requires multiple keys to be pressed in sequence to generate one input. This means that generally, when a key is\n    pressed, you will get both an `APP_INPUT_KEY_DOWN` event and an `APP_INPUT_CHAR` event - just use the one you are\n    interested in, and ignore the other.\n* APP_INPUT_MOUSE_MOVE - use the `mouse_pos` field of the `data` union, which contains the x and y position of the\n    mouse pointer, in window coordinates. The function `app_coordinates_window_to_bitmap` can be used to convert between\n    the coordinate system of the window and that of the currently displayed bitmap. The `APP_INPUT_MOUSE_MOVE` event is\n    sent whenever the user moves the mouse, as long as the window has focus and the pointer is inside its client area.\n* APP_INPUT_MOUSE_DELTA - use the `mouse_delta` field of the `data` union, which contains the horizontal and vertical\n    offset which the mouse has been moved by. Ideally, these values should be in normalized -1.0f to 1.0f range, but as\n    there is no standardisation on the hardware and os level for this, it is not possible to do, so instead the value\n    have been scaled to give roughly normalized -1.0f to 1.0f values on a typical setup. For serious use, sensitivity\n    settings and/or user calibration is recommended. The `APP_INPUT_MOUSE_DELTA` event is sent whenever the user moves\n    the mouse, regardless of whether the window has focus or whether the pointer is inside the window or not. The\n    `APP_INPUT_MOUSE_DELTA` event is a better option for reading relative mouse movements than using the\n    `APP_INPUT_MOUSE_MOVE` event together with `app_pointer_pos` to re-center the pointer on every update.\n* APP_INPUT_SCROLL_WHEEL - use the `wheel_delta` field of the `data` union, which contains the number of clicks by which\n    the scroll wheel on the mouse was turned, where positive values indicate that the wheel have been rotated away from\n    the user, and negative values means it has turned towards the user. The `APP_INPUT_SCROLL_WHEEL` is sent every time\n    the user turns the scroll wheel, as long as the window has focus.\n* APP_INPUT_TABLET - use the `tablet` field of the `data` union, which contains details about the pen used with a\n    graphical tablet, if connected and installed. The `x` and `y` fields are the horizontal and vertical positions of\n    the pen on the tablet, scaled to the coordinate system of the window. The function `app_coordinates_window_to_bitmap`\n    can be used to convert between the coordinate system of the window and that of the currently displayed bitmap. The\n    `pressure` field is the current pressure of the pen against the tablet, in normalized 0.0f to 1.0f range, inclusive,\n    where 0.0f means no pressure and 1.0f means full pressure. The `tip` field is set to `APP_PRESSED` if the tip of the\n    pen is touching the tablet at all, and to `APP_NOT_PRESSED` otherwise. The `upper` and `lower` fields indicate the\n    current state of the buttons on the side of the pen. The \"eraser\" part of the pen is not currently supported.\n\n\napp_coordinates_window_to_bitmap\n--------------------------------\n\n    void app_coordinates_window_to_bitmap( app_t* app, int width, int height, int* x, int* y )\n\nFunctions in the `app.h` API expects and returns coordinates in the windows coordinate system, where 0, 0 is the top\nleft corner of the windows client area (the area inside of the window borders, excluding title bar and decorations), and\nwidth, height is the dimension, in pixels, of the client area. It is often desirable to translate a position given in\nwindow coordinates into a position on the bitmap that is being displayed - taking into account whether the window is in\nfullscreen or windowed mode, and how the bitmap is stretched or padded depending on which interpolation mode is being\nused: `APP_INTERPOLATION_NONE` or `APP_INTERPOLATION_LINEAR`. `app_coordinates_window_to_bitmap` performs this\ntranslation, and is called with the following parameters:\n* width, height - dimensions of the bitmap being presented, the same as the ones passed to `app_present`.\n* x, y - pointers to integer values containing the coordinate, in the coordinate system of the window, to be translated.\n    When the function returns, their values will have been updated with the corresponding position in the coordinate\n    system of the bitmap.\n\n\napp_coordinates_bitmap_to_window\n--------------------------------\n\n    void app_coordinates_bitmap_to_window( app_t* app, int width, int height, int* x, int* y )\n\nThis performs the opposite translation to `app_coordinates_window_to_bitmap` - it converts a position given in the\ncoordinate system of the bitmap into the coordinate system of the window. See `app_coordinates_window_to_bitmap` for\ndetails.\n\n*/\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n#ifdef APP_IMPLEMENTATION\n#undef APP_IMPLEMENTATION\n\n#include <stdlib.h>\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    OPENGL CODE - Shared between platform implementations\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#ifndef APP_NULL\n\n#if defined( APP_WINDOWS )\n\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #ifndef _CRT_SECURE_NO_WARNINGS\n        #define _CRT_SECURE_NO_WARNINGS\n    #endif\n    #include <stddef.h>\n    #define APP_GLCALLTYPE __stdcall\n    typedef unsigned int APP_GLuint;\n    typedef int APP_GLsizei;\n    typedef unsigned int APP_GLenum;\n    typedef int APP_GLint;\n    typedef float APP_GLfloat;\n    typedef char APP_GLchar;\n    typedef unsigned char APP_GLboolean;\n    typedef size_t APP_GLsizeiptr;\n    typedef unsigned int APP_GLbitfield;\n\n    #define APP_GL_FLOAT 0x1406\n    #define APP_GL_FALSE 0\n    #define APP_GL_FRAGMENT_SHADER 0x8b30\n    #define APP_GL_VERTEX_SHADER 0x8b31\n    #define APP_GL_COMPILE_STATUS 0x8b81\n    #define APP_GL_LINK_STATUS 0x8b82\n    #define APP_GL_INFO_LOG_LENGTH 0x8b84\n    #define APP_GL_ARRAY_BUFFER 0x8892\n    #define APP_GL_TEXTURE_2D 0x0de1\n    #define APP_GL_TEXTURE0 0x84c0\n    #define APP_GL_CLAMP 0x2900\n    #define APP_GL_TEXTURE_WRAP_S 0x2802\n    #define APP_GL_TEXTURE_WRAP_T 0x2803\n    #define APP_GL_TEXTURE_MIN_FILTER 0x2801\n    #define APP_GL_TEXTURE_MAG_FILTER 0x2800\n    #define APP_GL_NEAREST 0x2600\n    #define APP_GL_LINEAR 0x2601\n    #define APP_GL_STATIC_DRAW 0x88e4\n    #define APP_GL_RGBA 0x1908\n    #define APP_GL_UNSIGNED_BYTE 0x1401\n    #define APP_GL_COLOR_BUFFER_BIT 0x00004000\n    #define APP_GL_TRIANGLE_FAN 0x0006\n\n#elif defined( APP_SDL ) || defined( APP_WASM )\n\n    #if defined( APP_WASM )\n        #include <wajic_gl.h>\n        #define WA_CORO_IMPLEMENT_NANOSLEEP\n        #include <wajic_coro.h>\n    #else\n        #include <GL/glew.h>\n        #include \"SDL_opengl.h\"\n    #endif\n    #define APP_GLCALLTYPE GLAPIENTRY\n    typedef GLuint APP_GLuint;\n    typedef GLsizei APP_GLsizei;\n    typedef GLenum APP_GLenum;\n    typedef GLint APP_GLint;\n    typedef GLfloat APP_GLfloat;\n    typedef GLchar APP_GLchar;\n    typedef GLboolean APP_GLboolean;\n    typedef GLsizeiptr APP_GLsizeiptr;\n    typedef GLbitfield APP_GLbitfield;\n\n    #define APP_GL_FLOAT GL_FLOAT\n    #define APP_GL_FALSE GL_FALSE\n    #define APP_GL_FRAGMENT_SHADER GL_FRAGMENT_SHADER\n    #define APP_GL_VERTEX_SHADER GL_VERTEX_SHADER\n    #define APP_GL_COMPILE_STATUS GL_COMPILE_STATUS\n    #define APP_GL_LINK_STATUS GL_LINK_STATUS\n    #define APP_GL_INFO_LOG_LENGTH GL_INFO_LOG_LENGTH\n    #define APP_GL_ARRAY_BUFFER GL_ARRAY_BUFFER\n    #define APP_GL_TEXTURE_2D GL_TEXTURE_2D\n    #define APP_GL_TEXTURE0 GL_TEXTURE0\n    #if defined( APP_WASM )\n        #define APP_GL_CLAMP GL_CLAMP_TO_EDGE\n    #else\n        #define APP_GL_CLAMP GL_CLAMP\n    #endif\n    #define APP_GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_S\n    #define APP_GL_TEXTURE_WRAP_T GL_TEXTURE_WRAP_T\n    #define APP_GL_TEXTURE_MIN_FILTER GL_TEXTURE_MIN_FILTER\n    #define APP_GL_TEXTURE_MAG_FILTER GL_TEXTURE_MAG_FILTER\n    #define APP_GL_NEAREST GL_NEAREST\n    #define APP_GL_LINEAR GL_LINEAR\n    #define APP_GL_STATIC_DRAW GL_STATIC_DRAW\n    #define APP_GL_RGBA GL_RGBA\n    #define APP_GL_UNSIGNED_BYTE GL_UNSIGNED_BYTE\n    #define APP_GL_COLOR_BUFFER_BIT GL_COLOR_BUFFER_BIT\n    #define APP_GL_TRIANGLE_FAN GL_TRIANGLE_FAN\n\n#else\n\n    #error Undefined platform. Define APP_WINDOWS, APP_SDL, APP_WASM or APP_NULL.\n    #define APP_GLCALLTYPE\n    typedef int APP_GLuint;\n    typedef int APP_GLsizei;\n    typedef int APP_GLenum;\n    typedef int APP_GLint;\n    typedef int APP_GLfloat;\n    typedef int APP_GLchar;\n    typedef int APP_GLboolean;\n    typedef int APP_GLsizeiptr;\n    typedef int APP_GLbitfield;\n\n#endif\n\n\n#ifdef APP_REPORT_SHADER_ERRORS\n    #include <string.h>\n#endif\n\nstruct app_internal_opengl_t\n    {\n\n    APP_GLuint (APP_GLCALLTYPE* CreateShader) (APP_GLenum type);\n    void (APP_GLCALLTYPE* ShaderSource) (APP_GLuint shader, APP_GLsizei count, APP_GLchar const* const* string, APP_GLint const* length);\n    void (APP_GLCALLTYPE* CompileShader) (APP_GLuint shader);\n    void (APP_GLCALLTYPE* GetShaderiv) (APP_GLuint shader, APP_GLenum pname, APP_GLint *params);\n    APP_GLuint (APP_GLCALLTYPE* CreateProgram) (void);\n    void (APP_GLCALLTYPE* AttachShader) (APP_GLuint program, APP_GLuint shader);\n    void (APP_GLCALLTYPE* BindAttribLocation) (APP_GLuint program, APP_GLuint index, APP_GLchar const* name);\n    void (APP_GLCALLTYPE* LinkProgram) (APP_GLuint program);\n    void (APP_GLCALLTYPE* GetProgramiv) (APP_GLuint program, APP_GLenum pname, APP_GLint *params);\n    void (APP_GLCALLTYPE* GenBuffers) (APP_GLsizei n, APP_GLuint *buffers);\n    void (APP_GLCALLTYPE* BindBuffer) (APP_GLenum target, APP_GLuint buffer);\n    void (APP_GLCALLTYPE* EnableVertexAttribArray) (APP_GLuint index);\n    void (APP_GLCALLTYPE* VertexAttribPointer) (APP_GLuint index, APP_GLint size, APP_GLenum type, APP_GLboolean normalized, APP_GLsizei stride, void const* pointer);\n    void (APP_GLCALLTYPE* GenTextures) (APP_GLsizei n, APP_GLuint* textures);\n    void (APP_GLCALLTYPE* Enable) (APP_GLenum cap);\n    void (APP_GLCALLTYPE* ActiveTexture) (APP_GLenum texture);\n    void (APP_GLCALLTYPE* BindTexture) (APP_GLenum target, APP_GLuint texture);\n    void (APP_GLCALLTYPE* TexParameteri) (APP_GLenum target, APP_GLenum pname, APP_GLint param);\n    void (APP_GLCALLTYPE* DeleteBuffers) (APP_GLsizei n, APP_GLuint const* buffers);\n    void (APP_GLCALLTYPE* DeleteTextures) (APP_GLsizei n, APP_GLuint const* textures);\n    void (APP_GLCALLTYPE* BufferData) (APP_GLenum target, APP_GLsizeiptr size, void const *data, APP_GLenum usage);\n    void (APP_GLCALLTYPE* UseProgram) (APP_GLuint program);\n    void (APP_GLCALLTYPE* Uniform1i) (APP_GLint location, APP_GLint v0);\n    void (APP_GLCALLTYPE* Uniform3f) (APP_GLint location, APP_GLfloat v0, APP_GLfloat v1, APP_GLfloat v2);\n    APP_GLint (APP_GLCALLTYPE* GetUniformLocation) (APP_GLuint program, APP_GLchar const* name);\n    void (APP_GLCALLTYPE* TexImage2D) (APP_GLenum target, APP_GLint level, APP_GLint internalformat, APP_GLsizei width, APP_GLsizei height, APP_GLint border, APP_GLenum format, APP_GLenum type, void const* pixels);\n    void (APP_GLCALLTYPE* ClearColor) (APP_GLfloat red, APP_GLfloat green, APP_GLfloat blue, APP_GLfloat alpha);\n    void (APP_GLCALLTYPE* Clear) (APP_GLbitfield mask);\n    void (APP_GLCALLTYPE* DrawArrays) (APP_GLenum mode, APP_GLint first, APP_GLsizei count);\n    void (APP_GLCALLTYPE* Viewport) (APP_GLint x, APP_GLint y, APP_GLsizei width, APP_GLsizei height);\n    void (APP_GLCALLTYPE* DeleteShader) (APP_GLuint shader);\n    void (APP_GLCALLTYPE* DeleteProgram) (APP_GLuint program);\n    #ifdef APP_REPORT_SHADER_ERRORS\n        void (APP_GLCALLTYPE* GetShaderInfoLog) (APP_GLuint shader, APP_GLsizei bufSize, APP_GLsizei *length, APP_GLchar *infoLog);\n    #endif\n\n    app_interpolation_t interpolation;\n    int window_width;\n    int window_height;\n\n    APP_GLuint vertexbuffer;\n    APP_GLuint texture;\n    APP_GLuint shader;\n    };\n\n\nstatic int app_internal_opengl_init( app_t* app, struct app_internal_opengl_t* gl, app_interpolation_t interpolation,\n    int window_width, int window_height )\n    {\n    (void) app;\n    gl->interpolation = interpolation;\n    gl->window_width = window_width;\n    gl->window_height = window_height;\n\n    char const* vs_source =\n    #ifdef APP_WASM\n        \"precision highp float;\\n\"\n    #else\n        \"#version 120\\n\"\n    #endif\n        \"attribute vec4 pos;\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_Position = vec4( pos.xy, 0.0, 1.0 );\"\n        \"    uv = pos.zw;\"\n        \"    }\"\n        ;\n\n    char const* fs_source =\n    #ifdef APP_WASM\n        \"precision highp float;\\n\"\n    #else\n        \"#version 120\\n\"\n    #endif\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D texture;\"\n        \"uniform vec3 modulate;\"\n        \"\"\n        \"void main(void)\"\n        \"    {\"\n        \"    gl_FragColor = texture2D( texture, uv ) * vec4( modulate, 1.0 );\"\n        \"    }\"\n        ;\n\n    #ifdef APP_REPORT_SHADER_ERRORS\n        char error_message[ 1024 ];\n    #endif\n\n    APP_GLuint vs = gl->CreateShader( APP_GL_VERTEX_SHADER );\n    gl->ShaderSource( vs, 1, (char const**) &vs_source, NULL );\n    gl->CompileShader( vs );\n    APP_GLint vs_compiled;\n    gl->GetShaderiv( vs, APP_GL_COMPILE_STATUS, &vs_compiled );\n    if( !vs_compiled )\n        {\n        #ifdef APP_REPORT_SHADER_ERRORS\n            char const* prefix = \"Vertex Shader Error: \";\n            memcpy( error_message, prefix, strlen( prefix ) + 1 );\n            int len = 0, written = 0;\n            gl->GetShaderiv( vs, APP_GL_INFO_LOG_LENGTH, &len );\n            gl->GetShaderInfoLog( vs, (APP_GLsizei)( sizeof( error_message ) - strlen( prefix ) ), &written,\n                error_message + strlen( prefix ) );\n            app_fatal_error( app, error_message );\n        #endif\n        return 0;\n        }\n\n    APP_GLuint fs = gl->CreateShader( APP_GL_FRAGMENT_SHADER );\n    gl->ShaderSource( fs, 1, (char const**) &fs_source, NULL );\n    gl->CompileShader( fs );\n    APP_GLint fs_compiled;\n    gl->GetShaderiv( fs, APP_GL_COMPILE_STATUS, &fs_compiled );\n    if( !fs_compiled )\n        {\n        #ifdef APP_REPORT_SHADER_ERRORS\n            char const* prefix = \"Fragment Shader Error: \";\n            memcpy( error_message, prefix, strlen( prefix ) + 1 );\n            int len = 0, written = 0;\n            gl->GetShaderiv( vs, APP_GL_INFO_LOG_LENGTH, &len );\n            gl->GetShaderInfoLog( fs, (APP_GLsizei)( sizeof( error_message ) - strlen( prefix ) ), &written,\n                error_message + strlen( prefix ) );\n            app_fatal_error( app, error_message );\n        #endif\n        return 0;\n        }\n\n\n    APP_GLuint prg = gl->CreateProgram();\n    gl->AttachShader( prg, fs );\n    gl->AttachShader( prg, vs );\n    gl->BindAttribLocation( prg, 0, \"pos\" );\n    gl->LinkProgram( prg );\n\n    APP_GLint linked;\n    gl->GetProgramiv( prg, APP_GL_LINK_STATUS, &linked );\n    if( !linked )\n        {\n        #ifdef APP_REPORT_SHADER_ERRORS\n            char const* prefix = \"Shader Link Error: \";\n            memcpy( error_message, prefix, strlen( prefix ) + 1 );\n            int len = 0, written = 0;\n            gl->GetShaderiv( vs, APP_GL_INFO_LOG_LENGTH, &len );\n            gl->GetShaderInfoLog( prg, (APP_GLsizei)( sizeof( error_message ) - strlen( prefix ) ), &written,\n                error_message + strlen( prefix ) );\n            app_fatal_error( app, error_message );\n        #endif\n        return 0;\n        }\n\n    gl->shader = prg;\n    gl->DeleteShader( fs );\n    gl->DeleteShader( vs );\n\n    gl->GenBuffers( 1, &gl->vertexbuffer );\n    gl->BindBuffer( APP_GL_ARRAY_BUFFER, gl->vertexbuffer );\n    gl->EnableVertexAttribArray( 0 );\n    gl->VertexAttribPointer( 0, 4, APP_GL_FLOAT, APP_GL_FALSE, 4 * sizeof( APP_GLfloat ), 0 );\n\n    gl->GenTextures( 1, &gl->texture );\n    #ifndef APP_WASM\n        // This enable call is not necessary when using fragment shaders, avoid logged warnings in WebGL\n        gl->Enable( APP_GL_TEXTURE_2D );\n    #endif\n    gl->ActiveTexture( APP_GL_TEXTURE0 );\n    gl->BindTexture( APP_GL_TEXTURE_2D, gl->texture );\n    gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_MIN_FILTER, APP_GL_NEAREST );\n    gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_MAG_FILTER, APP_GL_NEAREST );\n    gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_WRAP_S, APP_GL_CLAMP );\n    gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_WRAP_T, APP_GL_CLAMP );\n\n    return 1;\n    }\n\n\nstatic int app_internal_opengl_term( struct app_internal_opengl_t* gl )\n    {\n    gl->DeleteProgram( gl->shader );\n    gl->DeleteBuffers( 1, &gl->vertexbuffer);\n    gl->DeleteTextures( 1, &gl->texture );\n    return 1;\n    }\n\n\nstatic int app_internal_opengl_present( struct app_internal_opengl_t* gl, APP_U32 const* pixels_xbgr, int width,\n    int height, APP_U32 mod_xbgr, APP_U32 border_xbgr )\n    {\n    float x1 = 0.0f, y1 = 0.0f, x2 = (float) gl->window_width, y2 = (float) gl->window_height;\n\n    if( gl->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = gl->window_width / (float) width;\n        float vscale = gl->window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n\n        float hborder = ( gl->window_width - pixel_scale * width ) / 2.0f;\n        float vborder = ( gl->window_height - pixel_scale * height ) / 2.0f;\n        x1 = hborder;\n        y1 = vborder;\n        x2 = x1 + pixel_scale * width;\n        y2 = y1 + pixel_scale * height;\n        }\n    else\n        {\n        int hscale = gl->window_width / width;\n        int vscale = gl->window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n\n        int hborder = ( gl->window_width - pixel_scale * width ) / 2;\n        int vborder = ( gl->window_height - pixel_scale * height ) / 2;\n        x1 = (float) hborder;\n        y1 = (float) vborder;\n        x2 = x1 + (float) ( pixel_scale * width );\n        y2 = y1 + (float) ( pixel_scale * height );\n        }\n\n    x1 = ( x1 / gl->window_width ) * 2.0f - 1.0f;\n    x2 = ( x2 / gl->window_width ) * 2.0f - 1.0f;\n    y1 = ( y1 / gl->window_height ) * 2.0f - 1.0f;\n    y2 = ( y2 / gl->window_height ) * 2.0f - 1.0f;\n\n    APP_GLfloat vertices[ 16 ];\n    vertices[  0 ] = x1;\n    vertices[  1 ] = y1;\n    vertices[  2 ] = 0.0f;\n    vertices[  3 ] = 1.0f;\n\n    vertices[  4 ] = x2;\n    vertices[  5 ] = y1;\n    vertices[  6 ] = 1.0f;\n    vertices[  7 ] = 1.0f;\n\n    vertices[  8 ] = x2;\n    vertices[  9 ] = y2;\n    vertices[ 10 ] = 1.0f;\n    vertices[ 11 ] = 0.0f;\n\n    vertices[ 12 ] = x1;\n    vertices[ 13 ] = y2;\n    vertices[ 14 ] = 0.0f;\n    vertices[ 15 ] = 0.0f;\n\n    gl->BindBuffer( APP_GL_ARRAY_BUFFER, gl->vertexbuffer );\n    gl->BufferData( APP_GL_ARRAY_BUFFER, 4 * 4 * sizeof( APP_GLfloat ), vertices, APP_GL_STATIC_DRAW );\n    gl->VertexAttribPointer( 0, 4, APP_GL_FLOAT, APP_GL_FALSE, 4 * sizeof( APP_GLfloat ), 0 );\n\n    float mod_r = ( ( mod_xbgr >> 16 ) & 0xff ) / 255.0f;\n    float mod_g = ( ( mod_xbgr >> 8  ) & 0xff ) / 255.0f;\n    float mod_b = ( ( mod_xbgr       ) & 0xff ) / 255.0f;\n\n    gl->UseProgram( gl->shader );\n    gl->Uniform1i( gl->GetUniformLocation( gl->shader, \"texture\" ), 0 );\n    gl->Uniform3f( gl->GetUniformLocation( gl->shader, \"modulate\" ), mod_r, mod_g, mod_b );\n\n    gl->ActiveTexture( APP_GL_TEXTURE0 );\n    gl->BindTexture( APP_GL_TEXTURE_2D, gl->texture );\n    gl->TexImage2D( APP_GL_TEXTURE_2D, 0, APP_GL_RGBA, width, height, 0, APP_GL_RGBA, APP_GL_UNSIGNED_BYTE, pixels_xbgr );\n\n    if( gl->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_MIN_FILTER, APP_GL_LINEAR );\n        gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_MAG_FILTER, APP_GL_LINEAR );\n        }\n    else\n        {\n        gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_MIN_FILTER, APP_GL_NEAREST );\n        gl->TexParameteri( APP_GL_TEXTURE_2D, APP_GL_TEXTURE_MAG_FILTER, APP_GL_NEAREST );\n        }\n\n    float b = ( ( border_xbgr >> 16 ) & 0xff ) / 255.0f;\n    float g = ( ( border_xbgr >> 8  ) & 0xff ) / 255.0f;\n    float r = ( ( border_xbgr       ) & 0xff ) / 255.0f;\n    gl->ClearColor( r, g, b, 1.0f );\n    gl->Clear( APP_GL_COLOR_BUFFER_BIT );\n    gl->DrawArrays( APP_GL_TRIANGLE_FAN, 0, 4 );\n\n    return 1;\n    }\n\n\nstatic void app_internal_opengl_resize( struct app_internal_opengl_t* gl, int width, int height )\n    {\n    gl->Viewport( 0, 0, width, height );\n    gl->window_width = width;\n    gl->window_height = height;\n    }\n\n\nstatic void app_internal_opengl_interpolation( struct app_internal_opengl_t* gl, app_interpolation_t interpolation )\n    {\n    gl->interpolation = interpolation;\n    }\n\n\n#endif // #ifndef APP_NULL\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    NULL\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( APP_NULL )\n\n\nstruct app_t { void* dummy; };\nint app_run( int (*app_proc)( app_t*, void* ), void* user_data, void* memctx, void* logctx, void* fatalctx ) { app_t app; return app_proc( &app, user_data ); }\napp_state_t app_yield( app_t* app ) { return APP_STATE_NORMAL; }\nvoid app_cancel_exit( app_t* app ) { }\nvoid app_title( app_t* app, char const* title ) { }\nchar const* app_cmdline( app_t* app ) { return \"\"; }\nchar const* app_filename( app_t* app ) { return \"\"; }\nchar const* app_userdata( app_t* app ) { return \"\"; }\nchar const* app_appdata( app_t* app ) { return \"\"; }\nAPP_U64 app_time_count( app_t* app ) { return 0ULL; }\nAPP_U64 app_time_freq( app_t* app ) { return 0ULL; }\nvoid app_log( app_t* app, app_log_level_t level, char const* message ) { }\nvoid app_fatal_error( app_t* app, char const* message ) { }\nvoid app_pointer( app_t* app, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y ) { }\nvoid app_pointer_default( app_t* app, int* width, int* height, APP_U32* pixels_abgr, int* hotspot_x, int* hotspot_y ) { }\nvoid app_pointer_pos( app_t* app, int x, int y ) { }\nint app_pointer_x( app_t* app ) { return 0; }\nint app_pointer_y( app_t* app ) { return 0;}\nvoid app_pointer_limit( app_t* app, int x, int y, int width, int height ) { }\nvoid app_pointer_limit_off( app_t* app ) { }\nvoid app_interpolation( app_t* app, app_interpolation_t interpolation ) { }\nvoid app_screenmode( app_t* app, app_screenmode_t screenmode ) { }\nvoid app_window_size( app_t* app, int width, int height ) { }\nint app_window_width( app_t* app ) { return 0; }\nint app_window_height( app_t* app ) { return 0; }\nvoid app_window_pos( app_t* app, int x, int y ) { }\nint app_window_x( app_t* app ) { return 0; }\nint app_window_y( app_t* app ) { return 0; }\napp_displays_t app_displays( app_t* app ) { app_displays_t ret = { 0 }; return ret; }\nvoid app_present( app_t* app, APP_U32 const* pixels_xbgr, int width, int height, APP_U32 mod_xbgr, APP_U32 border_xbgr ) { }\nvoid app_sound( app_t* app, int sample_pairs_count, void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data ), void* user_data ) { }\nvoid app_sound_volume( app_t* app, float volume ) { }\napp_input_t app_input( app_t* app ) { app_input_t ret = { 0 }; return ret; }\nvoid app_coordinates_window_to_bitmap( app_t* app, int width, int height, int* x, int* y ) { }\nvoid app_coordinates_bitmap_to_window( app_t* app, int width, int height, int* x, int* y );\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    WINDOWS\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#elif defined( APP_WINDOWS )\n\n#define _CRT_NONSTDC_NO_DEPRECATE\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#if !defined( _WIN32_WINNT ) || _WIN32_WINNT < 0x0601\n#undef _WIN32_WINNT\n    #define _WIN32_WINNT 0x0601// requires Windows 7 minimum\n#endif\n// 0x0400=Windows NT 4.0, 0x0500=Windows 2000, 0x0501=Windows XP, 0x0502=Windows Server 2003, 0x0600=Windows Vista,\n// 0x0601=Windows 7, 0x0602=Windows 8, 0x0603=Windows 8.1, 0x0A00=Windows 10,\n#define _WINSOCKAPI_\n#pragma warning( push )\n#pragma warning( disable: 4619 ) // #pragma warning: there is no warning number 'nnnn'\n#pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n#pragma warning( disable: 4768 ) // __declspec attributes before linkage specification are ignored\n#pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n#pragma warning( disable: 4917 ) // 'declarator' : a GUID can only be associated with a class, interface or namespace\n#define _NTDDSCM_H_ /* Fixes the error of mismatched pragma warning push/pop in Windows SDK 10.0.17763.0 */\n#include <windows.h>\n//#include <shlobj.h>\n#pragma warning( pop )\n#ifndef __TINYC__\n#pragma comment( lib, \"user32.lib\" )\n#pragma comment( lib, \"gdi32.lib\" )\n#pragma comment( lib, \"winmm.lib\" )\n#pragma comment( lib, \"shell32.lib\" )\n#else\n#pragma comment( lib, \"user32\")\n#pragma comment( lib, \"gdi32\")\n#endif\n\n#include <time.h>\n#include <stdio.h>\n\n#pragma warning( push )\n#pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n#include <math.h>\n#pragma warning( pop )\n\n#ifndef APP_MALLOC\n    #include <stdlib.h>\n    #if defined(__cplusplus)\n        #define APP_MALLOC( ctx, size ) ( ::malloc( size ) )\n        #define APP_FREE( ctx, ptr ) ( ::free( ptr ) )\n    #else\n        #define APP_MALLOC( ctx, size ) ( malloc( size ) )\n        #define APP_FREE( ctx, ptr ) ( free( ptr ) )\n    #endif\n#endif\n\n#ifndef APP_LOG\n    #if defined(__cplusplus)\n        #define APP_LOG( ctx, level, message ) ::printf( \"%s\\n\", message )\n    #else\n        #define APP_LOG( ctx, level, message ) printf( \"%s\\n\", message )\n    #endif\n#endif\n\n#ifndef APP_FATAL_ERROR\n    #if defined(__cplusplus)\n        #define APP_FATAL_ERROR( ctx, message ) { ::printf( \"FATAL ERROR: %s\\n\", message ); \\\n            ::MessageBoxA( 0, message, \"Fatal Error!\", MB_OK | MB_ICONSTOP ); ::_flushall(); ::_exit( 0xff ); }\n    #else\n        #define APP_FATAL_ERROR( ctx, message ) { printf( \"FATAL ERROR: %s\\n\", message ); \\\n            MessageBoxA( 0, message, \"Fatal Error!\", MB_OK | MB_ICONSTOP ); _flushall(); _exit( 0xff ); }\n    #endif\n#endif\n\n\n#ifndef APP_WINDOWED_WS_STYLE\n    #define APP_WINDOWED_WS_STYLE WS_OVERLAPPEDWINDOW\n#endif\n\n#ifndef APP_WINDOWED_WS_EX_STYLE\n    #define APP_WINDOWED_WS_EX_STYLE 0\n#endif\n\n\ntypedef struct APP_LOGCONTEXTA\n    {\n    char lcName[ 40 ]; UINT lcOptions; UINT lcStatus; UINT lcLocks; UINT lcMsgBase; UINT lcDevice; UINT lcPktRate;\n    DWORD lcPktData; DWORD lcPktMode; DWORD lcMoveMask; DWORD lcBtnDnMask; DWORD lcBtnUpMask; LONG lcInOrgX;\n    LONG lcInOrgY; LONG lcInOrgZ; LONG lcInExtX; LONG lcInExtY; LONG lcInExtZ; LONG lcOutOrgX; LONG lcOutOrgY;\n    LONG lcOutOrgZ; LONG lcOutExtX; LONG lcOutExtY; LONG lcOutExtZ; DWORD lcSensX; DWORD lcSensY; DWORD lcSensZ;\n    BOOL lcSysMode; int lcSysOrgX; int lcSysOrgY; int lcSysExtX; int lcSysExtY; DWORD lcSysSensX; DWORD lcSysSensY;\n    } APP_LOGCONTEXTA;\ntypedef struct APP_AXIS { LONG axMin; LONG axMax; UINT axUnits; DWORD axResolution; } APP_AXIS;\ntypedef struct APP_PACKET { DWORD pkButtons; LONG pkX; LONG pkY; UINT pkNormalPressure; } APP_PACKET;\nDECLARE_HANDLE( APP_HMGR );\nDECLARE_HANDLE( APP_HCTX );\n#define APP_WTI_DEVICES 100\n#define APP_WTI_DDCTXS 400 /* 1.1 */\n#define APP_CXO_MESSAGES 0x0004\n#define APP_DVC_NPRESSURE 15\n#define APP_PK_BUTTONS 0x0040 // button information\n#define APP_PK_X 0x0080 // x axis\n#define APP_PK_Y 0x0100 // y axis\n#define APP_PK_NORMAL_PRESSURE 0x0400 // normal or tip pressure\n#define APP_PACKETDATA APP_PK_X | APP_PK_Y | APP_PK_BUTTONS | APP_PK_NORMAL_PRESSURE\n#define APP_PACKETMODE 0\n#define APP_WT_PACKET 0x7FF0\n\n\n\n////// DSOUND DEFINITIONS ////////\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n\ntypedef struct _DSOUND_WAVEFORMATEX\n    {\n    WORD        wFormatTag;\n    WORD        nChannels;\n    DWORD       nSamplesPerSec;\n    DWORD       nAvgBytesPerSec;\n    WORD        nBlockAlign;\n    WORD        wBitsPerSample;\n    WORD        cbSize;\n    } DSOUND_WAVEFORMATEX;\n\ntypedef struct _DSBUFFERDESC\n    {\n    DWORD           dwSize;\n    DWORD           dwFlags;\n    DWORD           dwBufferBytes;\n    DWORD           dwReserved;\n    DSOUND_WAVEFORMATEX*  lpwfxFormat;\n    } DSBUFFERDESC;\n\ntypedef struct _DSBPOSITIONNOTIFY\n    {\n    DWORD           dwOffset;\n    HANDLE          hEventNotify;\n    } DSBPOSITIONNOTIFY;\n\n\ntypedef struct _DSCAPS DSCAPS;\ntypedef struct _DSBCAPS DSBCAPS;\ntypedef struct _DSEFFECTDESC DSEFFECTDESC;\nstruct IDirectSound8;\n\ntypedef struct IDirectSoundBuffer8 { struct IDirectSoundBuffer8Vtbl* lpVtbl; } IDirectSoundBuffer8;\ntypedef struct IDirectSoundBuffer8Vtbl IDirectSoundBuffer8Vtbl;\n\nstruct IDirectSoundBuffer8Vtbl\n{\n    // IUnknown methods\n    HRESULT (STDMETHODCALLTYPE *QueryInterface)       (IDirectSoundBuffer8*, REFIID, LPVOID*);\n    ULONG (STDMETHODCALLTYPE *AddRef)        (IDirectSoundBuffer8*);\n    ULONG (STDMETHODCALLTYPE *Release)       (IDirectSoundBuffer8*);\n\n    // IDirectSoundBuffer methods\n    HRESULT (STDMETHODCALLTYPE *GetCaps)              (IDirectSoundBuffer8*, DSBCAPS* pDSBufferCaps);\n    HRESULT (STDMETHODCALLTYPE *GetCurrentPosition)   (IDirectSoundBuffer8*, LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor);\n    HRESULT (STDMETHODCALLTYPE *GetFormat)            (IDirectSoundBuffer8*, DSOUND_WAVEFORMATEX* pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);\n    HRESULT (STDMETHODCALLTYPE *GetVolume)            (IDirectSoundBuffer8*, LPLONG plVolume);\n    HRESULT (STDMETHODCALLTYPE *GetPan)               (IDirectSoundBuffer8*, LPLONG plPan);\n    HRESULT (STDMETHODCALLTYPE *GetFrequency)         (IDirectSoundBuffer8*, LPDWORD pdwFrequency);\n    HRESULT (STDMETHODCALLTYPE *GetStatus)            (IDirectSoundBuffer8*, LPDWORD pdwStatus);\n    HRESULT (STDMETHODCALLTYPE *Initialize)           (IDirectSoundBuffer8*, struct IDirectSound8* pDirectSound, DSBUFFERDESC* pcDSBufferDesc);\n    HRESULT (STDMETHODCALLTYPE *Lock)                 (IDirectSoundBuffer8*, DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags);\n    HRESULT (STDMETHODCALLTYPE *Play)                 (IDirectSoundBuffer8*, DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags);\n    HRESULT (STDMETHODCALLTYPE *SetCurrentPosition)   (IDirectSoundBuffer8*, DWORD dwNewPosition);\n    HRESULT (STDMETHODCALLTYPE *SetFormat)            (IDirectSoundBuffer8*, DSOUND_WAVEFORMATEX* pcfxFormat);\n    HRESULT (STDMETHODCALLTYPE *SetVolume)            (IDirectSoundBuffer8*, LONG lVolume);\n    HRESULT (STDMETHODCALLTYPE *SetPan)               (IDirectSoundBuffer8*, LONG lPan);\n    HRESULT (STDMETHODCALLTYPE *SetFrequency)         (IDirectSoundBuffer8*, DWORD dwFrequency);\n    HRESULT (STDMETHODCALLTYPE *Stop)                 (IDirectSoundBuffer8*);\n    HRESULT (STDMETHODCALLTYPE *Unlock)               (IDirectSoundBuffer8*, LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2);\n    HRESULT (STDMETHODCALLTYPE *Restore)              (IDirectSoundBuffer8*);\n\n    // IDirectSoundBuffer8 methods\n    HRESULT (STDMETHODCALLTYPE *SetFX)                (IDirectSoundBuffer8*, DWORD dwEffectsCount, DSEFFECTDESC* pDSFXDesc, LPDWORD pdwResultCodes);\n    HRESULT (STDMETHODCALLTYPE *AcquireResources)     (IDirectSoundBuffer8*, DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes);\n    HRESULT (STDMETHODCALLTYPE *GetObjectInPath)      (IDirectSoundBuffer8*, REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject);\n};\n\n#define IDirectSoundBuffer8_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)\n#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)\n#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)\n#define IDirectSoundBuffer8_Restore(p)                   (p)->lpVtbl->Restore(p)\n#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)\n#define IDirectSoundBuffer8_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)\n#define IDirectSoundBuffer8_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)\n#define IDirectSoundBuffer8_Release(p)                  (p)->lpVtbl->Release(p)\n\n\ntypedef struct IDirectSound8 { struct IDirectSound8Vtbl* lpVtbl; } IDirectSound8;\ntypedef struct IDirectSound8Vtbl IDirectSound8Vtbl;\n\nstruct IDirectSound8Vtbl\n{\n    // IUnknown methods\n    HRESULT (STDMETHODCALLTYPE *QueryInterface)(IDirectSound8*, REFIID, LPVOID*);\n    ULONG (STDMETHODCALLTYPE *AddRef)        (IDirectSound8*);\n    ULONG (STDMETHODCALLTYPE *Release)       (IDirectSound8*);\n\n    // IDirectSound methods\n    HRESULT (STDMETHODCALLTYPE *CreateSoundBuffer)    (IDirectSound8*, DSBUFFERDESC* pcDSBufferDesc, struct IDirectSoundBuffer8** ppDSBuffer, void* pUnkOuter);\n    HRESULT (STDMETHODCALLTYPE *GetCaps)              (IDirectSound8*, DSCAPS* pDSCaps);\n    HRESULT (STDMETHODCALLTYPE *DuplicateSoundBuffer) (IDirectSound8*, struct IDirectSoundBuffer8* pDSBufferOriginal, struct IDirectSoundBuffer8* *ppDSBufferDuplicate);\n    HRESULT (STDMETHODCALLTYPE *SetCooperativeLevel)  (IDirectSound8*, HWND hwnd, DWORD dwLevel);\n    HRESULT (STDMETHODCALLTYPE *Compact)              (IDirectSound8*);\n    HRESULT (STDMETHODCALLTYPE *GetSpeakerConfig)     (IDirectSound8*, LPDWORD pdwSpeakerConfig);\n    HRESULT (STDMETHODCALLTYPE *SetSpeakerConfig)     (IDirectSound8*, DWORD dwSpeakerConfig);\n    HRESULT (STDMETHODCALLTYPE *Initialize)           (IDirectSound8*, LPCGUID pcGuidDevice);\n\n    // IDirectSound8 methods\n    HRESULT (STDMETHODCALLTYPE *VerifyCertification)  (IDirectSound8*, LPDWORD pdwCertified);\n};\n\n#define IDirectSound8_Release(p)                  (p)->lpVtbl->Release(p)\n#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)\n#define IDirectSound8_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)\n\n\ntypedef struct IDirectSoundNotify { struct IDirectSoundNotifyVtbl* lpVtbl; } IDirectSoundNotify;\ntypedef struct IDirectSoundNotifyVtbl IDirectSoundNotifyVtbl;\n\nstruct IDirectSoundNotifyVtbl\n{\n    HRESULT (STDMETHODCALLTYPE *QueryInterface)(IDirectSoundNotify*, REFIID, LPVOID*);\n    ULONG (STDMETHODCALLTYPE *AddRef)        (IDirectSoundNotify*);\n    ULONG (STDMETHODCALLTYPE *Release)       (IDirectSoundNotify*);\n    HRESULT (STDMETHODCALLTYPE *SetNotificationPositions) (IDirectSoundNotify*, DWORD dwPositionNotifies, DSBPOSITIONNOTIFY* pcPositionNotifies);\n};\n\n#define IDirectSoundNotify_Release(p)                       (p)->lpVtbl->Release(p)\n#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)\n\n\n#define DS_OK                           S_OK\n#define DSERR_BUFFERLOST                MAKE_HRESULT(1, 0x878, 150)\n\n#define DSSCL_NORMAL                0x00000001\n#define DSBCAPS_CTRLVOLUME          0x00000080\n#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100\n#define DSBCAPS_GLOBALFOCUS         0x00008000\n#define DSBCAPS_GETCURRENTPOSITION2 0x00010000\n#define DSBPLAY_LOOPING             0x00000001\n#define DSBVOLUME_MIN               -10000\n\n\n#ifdef __cplusplus\n};\n#endif // __cplusplus\n\n\n///// END DSOUND DEFINITIONS //////\n\n\nstruct app_t\n    {\n    void* memctx;\n    void* logctx;\n    void* fatalctx;\n    app_interpolation_t interpolation;\n    app_screenmode_t screenmode;\n\n    BOOL initialized;\n    BOOL closed;\n\n    char exe_path[ 260 ];\n    char userdata_path[ 260 ];\n    char appdata_path[ 260 ];\n    char const* cmdline;\n\n    HINSTANCE hinstance;\n    HWND hwnd;\n    LRESULT (CALLBACK *user_wndproc)( app_t*, HWND, UINT, WPARAM, LPARAM );\n\n    HDC hdc;\n    HICON icon;\n    BOOL has_focus;\n    BOOL is_minimized;\n\n    struct app_internal_opengl_t gl;\n    HMODULE gl_dll;\n    HGLRC gl_context;\n    PROC (APP_GLCALLTYPE* wglGetProcAddress) (LPCSTR);\n    HGLRC (APP_GLCALLTYPE* wglCreateContext) (HDC);\n    BOOL (APP_GLCALLTYPE* wglDeleteContext) (HGLRC);\n    BOOL (APP_GLCALLTYPE* wglMakeCurrent) (HDC, HGLRC);\n    BOOL (APP_GLCALLTYPE* wglSwapIntervalEXT) (int);\n\n    UINT (WINAPI *GetRawInputDataPtr)( HRAWINPUT, UINT, LPVOID, PUINT, UINT );\n\n    HANDLE sound_notifications[ 2 ];\n    HMODULE dsound_dll;\n    struct IDirectSound8* dsound;\n    struct IDirectSoundBuffer8* dsoundbuf;\n    HANDLE sound_thread_handle;\n    volatile LONG exit_sound_thread;\n    int sample_pairs_count;\n    int sound_level;\n    void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data );\n    void* sound_user_data;\n\n    HCURSOR current_pointer;\n\n    BOOL clip_cursor;\n    RECT clip_rect;\n\n    app_input_event_t input_events[ 1024 ];\n    int input_count;\n\n    int windowed_x;\n    int windowed_y;\n    int windowed_h;\n    int windowed_w;\n    int fullscreen_width;\n    int fullscreen_height;\n\n    int display_count;\n    app_display_t displays[ 16 ];\n    HMONITOR displays_hmonitor[ 16 ];\n\n    struct\n        {\n        HMODULE wintab_dll;\n        APP_HCTX context;\n        int max_pressure;\n\n        UINT (WINAPI *WTInfo)( UINT, UINT, LPVOID );\n        APP_HCTX (WINAPI *WTOpen)( HWND, APP_LOGCONTEXTA*, BOOL );\n        BOOL (WINAPI *WTClose)( APP_HCTX );\n        BOOL (WINAPI *WTEnable)( APP_HCTX, BOOL );\n        BOOL (WINAPI *WTPacket)( APP_HCTX, UINT, LPVOID );\n        } tablet;\n    };\n\n\nstatic app_key_t app_internal_vkcode_to_appkey( app_t* app, int vkcode )\n    {\n    int map[ 256 * 2 ] = { APP_KEY_INVALID, 0x00, APP_KEY_LBUTTON, 0x01, APP_KEY_RBUTTON, 0x02, APP_KEY_CANCEL, 0x03, APP_KEY_MBUTTON, 0x04,\n        APP_KEY_XBUTTON1, 0x05, APP_KEY_XBUTTON2, 0x06, -1, 0x07, APP_KEY_BACK, 0x08, APP_KEY_TAB, 0x09, -1, 0x0A, -1, 0x0B, APP_KEY_CLEAR, 0x0C,\n        APP_KEY_RETURN, 0x0D, -1, 0x0E, -1, 0x0F, APP_KEY_SHIFT, 0x10, APP_KEY_CONTROL, 0x11, APP_KEY_MENU, 0x12, APP_KEY_PAUSE, 0x13,\n        APP_KEY_CAPITAL, 0x14, APP_KEY_KANA, 0x15, -1, 0x16, APP_KEY_JUNJA, 0x17, APP_KEY_FINAL, 0x18, APP_KEY_HANJA, 0x19, -1, 0x1A,\n        APP_KEY_ESCAPE, 0x1B, APP_KEY_CONVERT, 0x1C, APP_KEY_NONCONVERT, 0x1D, APP_KEY_ACCEPT, 0x1E, APP_KEY_MODECHANGE, 0x1F, APP_KEY_SPACE, 0x20,\n        APP_KEY_PRIOR, 0x21, APP_KEY_NEXT, 0x22, APP_KEY_END, 0x23, APP_KEY_HOME, 0x24, APP_KEY_LEFT, 0x25, APP_KEY_UP, 0x26, APP_KEY_RIGHT, 0x27,\n        APP_KEY_DOWN, 0x28, APP_KEY_SELECT, 0x29, APP_KEY_PRINT, 0x2A, APP_KEY_EXEC, 0x2B, APP_KEY_SNAPSHOT, 0x2C, APP_KEY_INSERT, 0x2D,\n        APP_KEY_DELETE, 0x2E, APP_KEY_HELP, 0x2F, APP_KEY_0, 0x30, APP_KEY_1, 0x31, APP_KEY_2, 0x32, APP_KEY_3, 0x33, APP_KEY_4, 0x34,\n        APP_KEY_5, 0x35, APP_KEY_6, 0x36, APP_KEY_7, 0x37, APP_KEY_8, 0x38, APP_KEY_9, 0x39, -1, 0x3A, -1, 0x3B, -1, 0x3C, -1, 0x3D, -1, 0x3E,\n        -1, 0x3F, -1, 0x40, APP_KEY_A, 0x41, APP_KEY_B, 0x42, APP_KEY_C, 0x43, APP_KEY_D, 0x44, APP_KEY_E, 0x45, APP_KEY_F, 0x46, APP_KEY_G, 0x47,\n        APP_KEY_H, 0x48, APP_KEY_I, 0x49, APP_KEY_J, 0x4A, APP_KEY_K, 0x4B, APP_KEY_L, 0x4C, APP_KEY_M, 0x4D, APP_KEY_N, 0x4E, APP_KEY_O, 0x4F,\n        APP_KEY_P, 0x50, APP_KEY_Q, 0x51, APP_KEY_R, 0x52, APP_KEY_S, 0x53, APP_KEY_T, 0x54, APP_KEY_U, 0x55, APP_KEY_V, 0x56, APP_KEY_W, 0x57,\n        APP_KEY_X, 0x58, APP_KEY_Y, 0x59, APP_KEY_Z, 0x5A, APP_KEY_LWIN, 0x5B, APP_KEY_RWIN, 0x5C, APP_KEY_APPS, 0x5D, -1, 0x5E, APP_KEY_SLEEP, 0x5F,\n        APP_KEY_NUMPAD0, 0x60, APP_KEY_NUMPAD1, 0x61, APP_KEY_NUMPAD2, 0x62, APP_KEY_NUMPAD3, 0x63, APP_KEY_NUMPAD4, 0x64, APP_KEY_NUMPAD5, 0x65,\n        APP_KEY_NUMPAD6, 0x66, APP_KEY_NUMPAD7, 0x67, APP_KEY_NUMPAD8, 0x68, APP_KEY_NUMPAD9, 0x69, APP_KEY_MULTIPLY, 0x6A, APP_KEY_ADD, 0x6B,\n        APP_KEY_SEPARATOR, 0x6C, APP_KEY_SUBTRACT, 0x6D, APP_KEY_DECIMAL, 0x6E, APP_KEY_DIVIDE, 0x6F, APP_KEY_F1, 0x70, APP_KEY_F2, 0x71,\n        APP_KEY_F3, 0x72, APP_KEY_F4, 0x73, APP_KEY_F5, 0x74, APP_KEY_F6, 0x75, APP_KEY_F7, 0x76, APP_KEY_F8, 0x77, APP_KEY_F9, 0x78,\n        APP_KEY_F10, 0x79, APP_KEY_F11, 0x7A, APP_KEY_F12, 0x7B, APP_KEY_F13, 0x7C, APP_KEY_F14, 0x7D, APP_KEY_F15, 0x7E, APP_KEY_F16, 0x7F,\n        APP_KEY_F17, 0x80, APP_KEY_F18, 0x81, APP_KEY_F19, 0x82, APP_KEY_F20, 0x83, APP_KEY_F21, 0x84, APP_KEY_F22, 0x85, APP_KEY_F23, 0x86,\n        APP_KEY_F24, 0x87, -1, 0x88, -1, 0x89, -1, 0x8A, -1, 0x8B, -1, 0x8C, -1, 0x8D, -1, 0x8E, -1, 0x8F, APP_KEY_NUMLOCK, 0x90,\n        APP_KEY_SCROLL, 0x91, -1, 0x92, -1, 0x93, -1, 0x94, -1, 0x95, -1, 0x96, -1, 0x97, -1, 0x98, -1, 0x99, -1, 0x9A, -1, 0x9B, -1, 0x9C, -1, 0x9D,\n        -1, 0x9E, -1, 0x9F, APP_KEY_LSHIFT, 0xA0, APP_KEY_RSHIFT, 0xA1, APP_KEY_LCONTROL, 0xA2, APP_KEY_RCONTROL, 0xA3, APP_KEY_LMENU, 0xA4,\n        APP_KEY_RMENU, 0xA5, APP_KEY_BROWSER_BACK, 0xA6, APP_KEY_BROWSER_FORWARD, 0xA7, APP_KEY_BROWSER_REFRESH, 0xA8, APP_KEY_BROWSER_STOP, 0xA9,\n        APP_KEY_BROWSER_SEARCH, 0xAA, APP_KEY_BROWSER_FAVORITES, 0xAB, APP_KEY_BROWSER_HOME, 0xAC, APP_KEY_VOLUME_MUTE, 0xAD,\n        APP_KEY_VOLUME_DOWN, 0xAE, APP_KEY_VOLUME_UP, 0xAF, APP_KEY_MEDIA_NEXT_TRACK, 0xB0, APP_KEY_MEDIA_PREV_TRACK, 0xB1, APP_KEY_MEDIA_STOP, 0xB2,\n        APP_KEY_MEDIA_PLAY_PAUSE, 0xB3, APP_KEY_LAUNCH_MAIL, 0xB4, APP_KEY_LAUNCH_MEDIA_SELECT, 0xB5, APP_KEY_LAUNCH_APP1, 0xB6,\n        APP_KEY_LAUNCH_APP2, 0xB7, -1, 0xB8, -1, 0xB9, APP_KEY_OEM_1, 0xBA, APP_KEY_OEM_PLUS, 0xBB, APP_KEY_OEM_COMMA, 0xBC, APP_KEY_OEM_MINUS, 0xBD,\n        APP_KEY_OEM_PERIOD, 0xBE, APP_KEY_OEM_2, 0xBF, APP_KEY_OEM_3, 0xC0, -1, 0xC1, -1, 0xC2, -1, 0xC3, -1, 0xC4, -1, 0xC5, -1, 0xC6, -1, 0xC7,\n        -1, 0xC8, -1, 0xC9, -1, 0xCA, -1, 0xCB, -1, 0xCC, -1, 0xCD, -1, 0xCE, -1, 0xCF, -1, 0xD0, -1, 0xD1, -1, 0xD2, -1, 0xD3, -1, 0xD4, -1, 0xD5,\n        -1, 0xD6, -1, 0xD7, -1, 0xD8, -1, 0xD9, -1, 0xDA, APP_KEY_OEM_4, 0xDB, APP_KEY_OEM_5, 0xDC, APP_KEY_OEM_6, 0xDD, APP_KEY_OEM_7, 0xDE,\n        APP_KEY_OEM_8, 0xDF, -1, 0xE0, -1, 0xE1, APP_KEY_OEM_102, 0xE2, -1, 0xE3, -1, 0xE4, APP_KEY_PROCESSKEY, 0xE5, -1, 0xE6, -1, 0xE7, -1, 0xE8,\n        -1, 0xE9, -1, 0xEA, -1, 0xEB, -1, 0xEC, -1, 0xED, -1, 0xEE, -1, 0xEF, -1, 0xF0, -1, 0xF1, -1, 0xF2, -1, 0xF3, -1, 0xF4, -1, 0xF5,\n        APP_KEY_ATTN, 0xF6, APP_KEY_CRSEL, 0xF7, APP_KEY_EXSEL, 0xF8, APP_KEY_EREOF, 0xF9, APP_KEY_PLAY, 0xFA, APP_KEY_ZOOM, 0xFB,\n        APP_KEY_NONAME, 0xFC, APP_KEY_PA1, 0xFD, APP_KEY_OEM_CLEAR, 0xFE, -1, 0xFF, };\n    if( vkcode < 0 || vkcode >= sizeof( map ) / ( 2 * sizeof( *map ) ) ) return APP_KEY_INVALID;\n    if( map[ vkcode * 2 + 1 ] != vkcode )\n        {\n        app_log( app, APP_LOG_LEVEL_ERROR, \"Keymap definition error\" );\n        return APP_KEY_INVALID;\n        }\n    return (app_key_t) map[ vkcode * 2 ];\n    }\n\n\nstatic void app_internal_add_input_event( app_t* app, app_input_event_t* event )\n    {\n    if( app->has_focus )\n        {\n        if( app->input_count < sizeof( app->input_events ) / sizeof( *app->input_events ) )\n            app->input_events[ app->input_count++ ] = *event;\n        }\n    }\n\n\nstatic RECT app_internal_rect( int left, int top, int right, int bottom )\n    {\n    RECT r; r.left = left; r.top = top; r.right = right; r.bottom = bottom; return r;\n    }\n\n\nstatic BOOL app_internal_tablet_init( app_t* app )\n    {\n    app->tablet.wintab_dll = LoadLibraryA( \"Wintab32.dll\" );\n    if( !app->tablet.wintab_dll ) return FALSE;\n\n    app->tablet.WTInfo = ( UINT (WINAPI*)( UINT, UINT, LPVOID ) )\n        (uintptr_t ) GetProcAddress( app->tablet.wintab_dll, \"WTInfoA\" );\n    app->tablet.WTOpen = ( APP_HCTX (WINAPI*)( HWND, APP_LOGCONTEXTA*, BOOL ) )\n        (uintptr_t ) GetProcAddress( app->tablet.wintab_dll, \"WTOpenA\" );\n    app->tablet.WTClose = ( BOOL (WINAPI*)( APP_HCTX ) )\n        (uintptr_t ) GetProcAddress( app->tablet.wintab_dll, \"WTClose\" );\n    app->tablet.WTEnable = ( BOOL (WINAPI*)( APP_HCTX, BOOL ) )\n        (uintptr_t ) GetProcAddress( app->tablet.wintab_dll, \"WTEnable\" );\n    app->tablet.WTPacket = ( BOOL (WINAPI*)( APP_HCTX, UINT, LPVOID ) )\n        (uintptr_t ) GetProcAddress( app->tablet.wintab_dll, \"WTPacket\" );\n\n    if( !app->tablet.WTInfo( 0 ,0, NULL ) ) return FALSE; // checks if tablet is present\n\n    APP_LOGCONTEXTA log_context;\n    memset( &log_context, 0, sizeof( log_context ) );\n    app->tablet.WTInfo( APP_WTI_DDCTXS, 0, &log_context );\n\n    APP_AXIS pressure;\n    memset( &pressure, 0, sizeof( pressure ) );\n    app->tablet.WTInfo( APP_WTI_DEVICES, APP_DVC_NPRESSURE, &pressure );\n    app->tablet.max_pressure = pressure.axMax;\n\n    log_context.lcPktData = APP_PACKETDATA;\n    log_context.lcOptions |= APP_CXO_MESSAGES;\n    log_context.lcPktMode = APP_PACKETMODE;\n    log_context.lcMoveMask = APP_PACKETDATA;\n    log_context.lcBtnUpMask = log_context.lcBtnDnMask;\n    log_context.lcOutOrgX = 0;\n    log_context.lcOutOrgY = 0;\n    log_context.lcOutExtX = GetSystemMetrics( SM_CXSCREEN) ;\n    log_context.lcOutExtY = -GetSystemMetrics( SM_CYSCREEN );\n\n    app->tablet.context = app->tablet.WTOpen( app->hwnd, &log_context, FALSE );\n    if( !app->tablet.context ) return FALSE;\n    return TRUE;\n}\n\n\nstatic BOOL app_internal_tablet_term( app_t* app )\n    {\n    if( app->tablet.context ) app->tablet.WTClose( app->tablet.context );\n    if( app->tablet.wintab_dll ) FreeLibrary( app->tablet.wintab_dll );\n    return TRUE;\n    }\n\n\n\nstatic LRESULT CALLBACK app_internal_wndproc( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)\n    {\n    app_t* app = (app_t*)(uintptr_t) GetWindowLongPtr( hwnd, GWLP_USERDATA );\n    if( !app ) return DefWindowProc( hwnd, message, wparam, lparam);\n\n    app_input_event_t input_event;\n\n    switch( message )\n        {\n        case WM_CHAR:\n            input_event.type = APP_INPUT_CHAR; input_event.data.char_code = (char) wparam;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_LBUTTONDOWN:\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = APP_KEY_LBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_LBUTTONUP:\n            input_event.type = APP_INPUT_KEY_UP; input_event.data.key = APP_KEY_LBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_LBUTTONDBLCLK:\n            input_event.type = APP_INPUT_DOUBLE_CLICK; input_event.data.key = APP_KEY_LBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = APP_KEY_LBUTTON;\n            app_internal_add_input_event(app, &input_event);\n            break;\n        case WM_RBUTTONDOWN:\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = APP_KEY_RBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_RBUTTONUP:\n            input_event.type = APP_INPUT_KEY_UP; input_event.data.key = APP_KEY_RBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_RBUTTONDBLCLK:\n            input_event.type = APP_INPUT_DOUBLE_CLICK; input_event.data.key = APP_KEY_RBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = APP_KEY_RBUTTON;\n            app_internal_add_input_event(app, &input_event);\n            break;\n        case WM_MBUTTONDOWN:\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = APP_KEY_MBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_MBUTTONUP:\n            input_event.type = APP_INPUT_KEY_UP; input_event.data.key = APP_KEY_MBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_MBUTTONDBLCLK:\n            input_event.type = APP_INPUT_DOUBLE_CLICK; input_event.data.key = APP_KEY_MBUTTON;\n            app_internal_add_input_event( app, &input_event );\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = APP_KEY_MBUTTON;\n            app_internal_add_input_event(app, &input_event);\n            break;\n        case WM_XBUTTONDOWN:\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = HIWORD( wparam ) == 1 ? APP_KEY_XBUTTON1 :APP_KEY_XBUTTON2;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_XBUTTONUP:\n            input_event.type = APP_INPUT_KEY_UP; input_event.data.key = HIWORD( wparam ) == 1 ? APP_KEY_XBUTTON1 :APP_KEY_XBUTTON2;\n            app_internal_add_input_event( app, &input_event );\n            break;\n        case WM_XBUTTONDBLCLK:\n            input_event.type = APP_INPUT_DOUBLE_CLICK; input_event.data.key = HIWORD( wparam ) == 1 ? APP_KEY_XBUTTON1 :APP_KEY_XBUTTON2;\n            app_internal_add_input_event( app, &input_event );\n            input_event.type = APP_INPUT_KEY_DOWN; input_event.data.key = HIWORD( wparam ) == 1 ? APP_KEY_XBUTTON1 :APP_KEY_XBUTTON2;\n            app_internal_add_input_event(app, &input_event);\n            break;\n        case WM_SYSKEYDOWN:\n        case WM_KEYDOWN:\n            {\n            input_event.type = APP_INPUT_KEY_DOWN;\n            WPARAM vkcode = wparam;\n            UINT scancode = (UINT)( ( lparam & 0x00ff0000 ) >> 16 );\n            int extended  = ( lparam & 0x01000000 ) != 0;\n            UINT const maptype = 3; //MAPVK_VSC_TO_VK_EX\n            switch( vkcode )\n                {\n                case VK_SHIFT:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n            app_internal_add_input_event( app, &input_event );\n\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) MapVirtualKey( scancode, maptype ) );\n                    app_internal_add_input_event( app, &input_event );\n            break;\n                case VK_CONTROL:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n            app_internal_add_input_event( app, &input_event );\n\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, extended ? VK_RCONTROL : VK_LCONTROL );\n                    app_internal_add_input_event( app, &input_event );\n            break;\n                case VK_MENU:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n                    app_internal_add_input_event( app, &input_event );\n\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, extended ? VK_RMENU : VK_LMENU );\n                    app_internal_add_input_event( app, &input_event );\n                    break;\n                default:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n                    app_internal_add_input_event( app, &input_event );\n                    break;\n                }\n            } break;\n\n        case WM_HOTKEY:\n            {\n            input_event.type = APP_INPUT_KEY_DOWN;\n            input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n            if( app->input_count < sizeof( app->input_events ) / sizeof( *app->input_events ) )\n                app->input_events[ app->input_count++ ] = input_event;\n            input_event.type = APP_INPUT_KEY_UP;\n            if( app->input_count < sizeof( app->input_events ) / sizeof( *app->input_events ) )\n                app->input_events[ app->input_count++ ] = input_event;\n            } break;\n\n        case WM_SYSKEYUP:\n        case WM_KEYUP:\n            {\n            input_event.type = APP_INPUT_KEY_UP;\n            WPARAM vkcode = wparam;\n            UINT scancode = (UINT)( ( lparam & 0x00ff0000 ) >> 16 );\n            int extended  = ( lparam & 0x01000000 ) != 0;\n            UINT const maptype = 3; //MAPVK_VSC_TO_VK_EX\n            switch( vkcode )\n                {\n                case VK_SHIFT:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n                    app_internal_add_input_event( app, &input_event );\n\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) MapVirtualKey( scancode, maptype ) );\n                    app_internal_add_input_event( app, &input_event );\n                    break;\n                case VK_CONTROL:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n                    app_internal_add_input_event( app, &input_event );\n\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, extended ? VK_RCONTROL : VK_LCONTROL );\n                    app_internal_add_input_event( app, &input_event );\n                    break;\n                case VK_MENU:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n                    app_internal_add_input_event( app, &input_event );\n\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, extended ? VK_RMENU : VK_LMENU );\n            app_internal_add_input_event( app, &input_event );\n            break;\n                default:\n                    input_event.data.key = app_internal_vkcode_to_appkey( app, (int) wparam );\n            app_internal_add_input_event( app, &input_event );\n            break;\n                }\n            } break;\n\n        /*\n        case WM_GESTURE:\n            printf( \"Gesture\\n\" );\n            if( app->has_focus )\n                {\n                GESTUREINFO gesture_info = { sizeof( gesture_info ) };\n                if( GetGestureInfo( (HGESTUREINFO) lparam, &gesture_info ) )\n                    {\n                    printf( \"Gesture Info\\n\" );\n                    static int prev = 0;\n                    if( gesture_info.dwID == GID_PAN )\n                        {\n                        if( gesture_info.dwFlags & GF_BEGIN )\n                            {\n                            prev = gesture_info.ptsLocation.y;\n                            }\n                        else\n                            {\n                            int dist = gesture_info.ptsLocation.y - prev;\n                            prev = gesture_info.ptsLocation.y;\n                            float wheel_delta = (float)( dist / 200.0f );\n                            printf( \"Pan/Inertia: %d\\n\", dist );\n                            if( app->input_count > 0 && app->input_events[ app->input_count - 1 ].type == APP_INPUT_SCROLL_WHEEL )\n                                {\n                                app_input_event_t* event = &app->input_events[ app->input_count - 1 ];\n                                event->data.wheel_delta += wheel_delta;\n                                }\n                            else\n                                {\n                                input_event.type = APP_INPUT_SCROLL_WHEEL;\n                                input_event.data.wheel_delta = wheel_delta;\n                                app_internal_add_input_event( app, &input_event );\n                                }\n                            }\n                        }\n                    }\n                }\n            break;\n        */\n        case WM_MOUSEWHEEL:\n            if( app->has_focus )\n                {\n                float const microsoft_mouse_wheel_constant = 120.0f;\n                float wheel_delta = ( (float) GET_WHEEL_DELTA_WPARAM( wparam ) ) / microsoft_mouse_wheel_constant;\n                if( app->input_count > 0 && app->input_events[ app->input_count - 1 ].type == APP_INPUT_SCROLL_WHEEL )\n                    {\n                    app_input_event_t* event = &app->input_events[ app->input_count - 1 ];\n                    event->data.wheel_delta += wheel_delta;\n                    }\n                else\n                    {\n                    input_event.type = APP_INPUT_SCROLL_WHEEL;\n                    input_event.data.wheel_delta = wheel_delta;\n                    app_internal_add_input_event( app, &input_event );\n                    }\n                }\n            break;\n\n        case WM_MOUSEMOVE:\n            if( app->has_focus )\n                {\n                POINT p;\n                GetCursorPos( &p );\n                ScreenToClient( app->hwnd, &p );\n                int mouse_x = p.x;\n                int mouse_y = p.y;\n\n                input_event.type = APP_INPUT_MOUSE_MOVE;\n                input_event.data.mouse_pos.x = mouse_x;\n                input_event.data.mouse_pos.y = mouse_y;\n                app_internal_add_input_event( app, &input_event );\n                }\n            break;\n\n        case WM_INPUT:\n            {\n            if( app->GetRawInputDataPtr )\n                {\n                RAWINPUT raw;\n                UINT size = sizeof( raw );\n                app->GetRawInputDataPtr( (HRAWINPUT) lparam, RID_INPUT, &raw, &size, sizeof( RAWINPUTHEADER ) );\n                if( raw.header.dwType == RIM_TYPEMOUSE )\n                    {\n                    if( ( raw.data.mouse.usFlags & 1 ) == MOUSE_MOVE_RELATIVE)\n                        {\n                        float dx = (float) raw.data.mouse.lLastX;\n                        float dy = (float) raw.data.mouse.lLastY;\n                        input_event.type = APP_INPUT_MOUSE_DELTA;\n                        input_event.data.mouse_delta.x = dx;\n                        input_event.data.mouse_delta.y = dy;\n                        app_internal_add_input_event( app, &input_event );\n                        }\n                    }\n                }\n            break;\n            }\n\n        case APP_WT_PACKET:\n            {\n            APP_PACKET packet;\n            memset( &packet, 0, sizeof( packet ) );\n            if( (APP_HCTX) lparam == app->tablet.context &&\n                app->tablet.WTPacket( app->tablet.context, (UINT) wparam, &packet ) )\n                {\n                POINT p;\n                p.x = packet.pkX;\n                p.y = packet.pkY;\n                ScreenToClient( app->hwnd, &p );\n                int pen_x = p.x;\n                int pen_y = p.y;\n\n                input_event.type = APP_INPUT_TABLET;\n                input_event.data.tablet.x = pen_x;\n                input_event.data.tablet.y = pen_y;\n                input_event.data.tablet.pressure = (float) packet.pkNormalPressure / (float) app->tablet.max_pressure;\n                input_event.data.tablet.tip = ( packet.pkButtons & 1 ) ? APP_PRESSED : APP_NOT_PRESSED;\n                input_event.data.tablet.lower = ( packet.pkButtons & 2 ) ? APP_PRESSED : APP_NOT_PRESSED;\n                input_event.data.tablet.upper = ( packet.pkButtons & 4 ) ? APP_PRESSED : APP_NOT_PRESSED;\n                app_internal_add_input_event( app, &input_event );\n                }\n            } break;\n\n        case WM_SETCURSOR:\n            if( LOWORD( lparam ) == HTCLIENT )\n                {\n                SetCursor( app->current_pointer );\n                return 0;\n                }\n            break;\n\n\n        case WM_WINDOWPOSCHANGED:\n            {\n            if( app->screenmode == APP_SCREENMODE_FULLSCREEN )\n                {\n                RECT wr, cr;\n                GetWindowRect( app->hwnd, &wr );\n                GetClientRect( app->hwnd, &cr );\n                if( wr.right - wr.left == cr.right - cr.left && wr.bottom - wr.top == cr.bottom - cr.top )\n                    {\n                    if( cr.right - cr.left != app->fullscreen_width || cr.bottom - cr.top != app->fullscreen_height )\n                        app_screenmode( app, APP_SCREENMODE_WINDOW );\n                    }\n                }\n\n            if( app->clip_cursor )\n                {\n                RECT r = app->clip_rect;\n                ClientToScreen( app->hwnd, (POINT*)&r );\n                ClientToScreen( app->hwnd, ( (POINT*)&r ) + 1 );\n                ClipCursor( &r );\n                }\n\n            } break;\n\n        case WM_SIZE:\n            {\n            if( wparam == SIZE_MAXIMIZED )\n                {\n                WINDOWPLACEMENT placement;\n                placement.length = sizeof( placement );\n                GetWindowPlacement( app->hwnd, &placement );\n                app->windowed_x = placement.rcNormalPosition.left;\n                app->windowed_y = placement.rcNormalPosition.top;\n                app->windowed_w = placement.rcNormalPosition.right - placement.rcNormalPosition.left;\n                app->windowed_h = placement.rcNormalPosition.bottom - placement.rcNormalPosition.top;\n                }\n\n            RECT r;\n            GetClientRect( app->hwnd, &r );\n            app_internal_opengl_resize( &app->gl, r.right - r.left, r.bottom - r.top );\n            } break;\n\n\n        case WM_ACTIVATEAPP:\n            app->has_focus = (BOOL) wparam;\n            if( app->has_focus )\n                {\n                app->is_minimized = FALSE;\n                if( app->clip_cursor )\n                    {\n                    RECT r = app->clip_rect;\n                    ClientToScreen( app->hwnd, (POINT*)&r );\n                    ClientToScreen( app->hwnd, ( (POINT*)&r ) + 1 );\n                    ClipCursor( &r );\n                    }\n                }\n            else\n                {\n                ClipCursor( NULL );\n                }\n\n            break;\n\n        case WM_SYSCOMMAND:\n            if( ( wparam & 0xFFF0 ) == SC_MINIMIZE ) app->is_minimized = TRUE;\n            break;\n\n        case WM_CLOSE:\n            app->closed = TRUE;\n            return 0;\n            break;\n\n        }\n\n    if( app->user_wndproc )\n        return app->user_wndproc( app, hwnd, message, wparam, lparam );\n\n    return DefWindowProc( hwnd, message, wparam, lparam);\n    }\n\n\nstatic BOOL CALLBACK app_internal_monitorenumproc( HMONITOR hmonitor, HDC dc, LPRECT rect, LPARAM data )\n    {\n    (void) dc;\n    app_t* app = (app_t*) data;\n\n    if( app->display_count >= sizeof( app->displays ) / sizeof( *app->displays ) ) return FALSE;\n    app->displays_hmonitor[ app->display_count ] = hmonitor;\n    app_display_t* display = &app->displays[ app->display_count++ ];\n\n    display->x = rect->left;\n    display->y = rect->top;\n    display->width = rect->right - rect->left;\n    display->height = rect->bottom - rect->top;\n\n    #ifdef __cplusplus\n        MONITORINFOEXA mi;\n        memset( &mi, 0, sizeof( MONITORINFOEXA ) );\n        mi.cbSize = sizeof( MONITORINFOEXA );\n        BOOL res = GetMonitorInfoA( hmonitor, &mi );\n        if( res && strlen( mi.szDevice ) >= sizeof( display->id ) ) res = FALSE;\n        strcpy( display->id, res ? mi.szDevice : \"\" ) ;\n    #else\n        MONITORINFOEXA mi;\n        memset( &mi, 0, sizeof( MONITORINFOEXA ) );\n        BOOL res = GetMonitorInfoA( hmonitor, (LPMONITORINFO)&mi );\n        if( res && strlen( mi.szDevice ) >= sizeof( display->id ) ) res = FALSE;\n        strcpy( display->id, res ? mi.szDevice : \"\" ) ;\n    #endif\n\n    return TRUE;\n    }\n\n\nstatic void app_internal_app_default_cursor( app_t* app )\n    {\n    APP_U32 pointer_pixels[ 256 * 256 ];\n    int pointer_width, pointer_height, pointer_hotspot_x, pointer_hotspot_y;\n    app_pointer_default( app, &pointer_width, &pointer_height, pointer_pixels, &pointer_hotspot_x, &pointer_hotspot_y );\n    app_pointer( app, pointer_width, pointer_height, pointer_pixels, pointer_hotspot_x, pointer_hotspot_y );\n    }\n\n\n#pragma warning( push )\n#pragma warning( disable: 4533 ) // initialization of 'wc' is skipped by 'goto init_failed'\n\nint app_run( int (*app_proc)( app_t*, void* ), void* user_data, void* memctx, void* logctx, void* fatalctx )\n    {\n    int result = 0xff;\n    //SetProcessDPIAware();\n\n    // Init app instance\n    app_t* app = (app_t*) APP_MALLOC( memctx, sizeof( app_t ) );\n    memset( app, 0, sizeof( *app ) );\n    app->memctx = memctx;\n    app->logctx = logctx;\n    app->fatalctx = fatalctx;\n    app->interpolation = APP_INTERPOLATION_LINEAR;\n    app->screenmode = APP_SCREENMODE_FULLSCREEN;\n\n    // Log start message\n    char msg[ 64 ];\n    time_t t = time( NULL );\n    struct tm* start = localtime( &t );\n    sprintf( msg, \"Application started %02d:%02d:%02d %04d-%02d-%02d.\",\n        start->tm_hour, start->tm_min, start->tm_sec, start->tm_year + 1900, start->tm_mon + 1, start->tm_mday );\n    app_log( app, APP_LOG_LEVEL_INFO, msg );\n\n    // Increase timing precision\n    #ifndef __TINYC__\n    TIMECAPS tc;\n    if( timeGetDevCaps( &tc, sizeof( TIMECAPS ) ) == TIMERR_NOERROR )\n        timeBeginPeriod( tc.wPeriodMin );\n    #endif\n\n    // Get instance handle\n    app->hinstance = GetModuleHandle( NULL );\n\n    // Retrieve the path of our executable\n    GetModuleFileNameA( 0, app->exe_path, sizeof( app->exe_path ) );\n\n    HMODULE shell32 = LoadLibraryA( \"shell32.dll\" );\n    if( shell32 )\n        {\n        HRESULT (__stdcall *SHGetFolderPathAPtr)(HWND, int, HANDLE, DWORD, LPSTR ) =\n            (HRESULT (__stdcall*)(HWND, int, HANDLE, DWORD, LPSTR ) ) (uintptr_t)\n                GetProcAddress( shell32, \"SHGetFolderPathA\" );\n\n        if( SHGetFolderPathAPtr )\n            {\n            #define APP_CSIDL_PERSONAL 0x0005 // My Documents\n            #define APP_CSIDL_COMMON_APPDATA 0x0023 // All Users\\Application Data\n            #define APP_CSIDL_FLAG_CREATE 0x8000\n\n            // Retrieve user data path\n            SHGetFolderPathAPtr( NULL, APP_CSIDL_PERSONAL | APP_CSIDL_FLAG_CREATE, NULL, 0, app->userdata_path );\n\n            // Retrieve app data path\n            SHGetFolderPathAPtr( NULL, APP_CSIDL_COMMON_APPDATA | APP_CSIDL_FLAG_CREATE, NULL, 0, app->appdata_path );\n\n            #undef APP_CSIDL_PERSONAL\n            #undef APP_CSIDL_COMMON_APPDATA\n            #undef APP_CSIDL_FLAG_CREATE\n        }\n\n        FreeLibrary( shell32 );\n        }\n\n    // Get command line string\n    app->cmdline = GetCommandLineA();\n\n    // Load a default Arrow cursor\n    app_internal_app_default_cursor( app );\n\n    // Load first icon in the exe and use as app icon\n    app->icon = LoadIconA( app->hinstance , MAKEINTRESOURCEA( 1 ) );\n\n    // List all displays\n    app->display_count = 0;\n    EnumDisplayMonitors( NULL, NULL, app_internal_monitorenumproc, (LPARAM) app );\n    if( app->display_count <= 0 ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to get display info\" ); goto init_failed;  }\n\n    // Setup the main application window\n    app->windowed_w = app->displays[ 0 ].width - app->displays[ 0 ].width / 6;\n    app->windowed_h = app->displays[ 0 ].height - app->displays[ 0 ].height / 6;\n    app->windowed_x = ( app->displays[ 0 ].width - app->windowed_w ) /  2;\n    app->windowed_y = ( app->displays[ 0 ].height - app->windowed_h ) / 2;\n\n    app->fullscreen_width = app->displays[ 0 ].width;\n    app->fullscreen_height = app->displays[ 0 ].height;\n\n    RECT winrect = app_internal_rect( app->windowed_x, app->windowed_y,\n        app->windowed_x + app->windowed_w, app->windowed_y + app->windowed_h );\n    AdjustWindowRect( &winrect, APP_WINDOWED_WS_STYLE | WS_VISIBLE, FALSE );\n\n    WNDCLASSEX wc = { sizeof( WNDCLASSEX ), CS_DBLCLKS | CS_OWNDC ,\n        (WNDPROC) app_internal_wndproc, 0, 0, 0, 0, 0, 0, 0, TEXT( \"app_wc\" ), 0 };\n    wc.hInstance = app->hinstance; wc.hIcon = app->icon; wc.hCursor = app->current_pointer;\n    wc.hbrBackground = (HBRUSH) GetStockObject( BLACK_BRUSH ); wc.hIconSm = app->icon;\n    RegisterClassEx( &wc );\n    app->hwnd = CreateWindowEx( APP_WINDOWED_WS_EX_STYLE, wc.lpszClassName, 0, APP_WINDOWED_WS_STYLE, app->windowed_x, app->windowed_y,\n        winrect.right - winrect.left, winrect.bottom - winrect.top, (HWND) 0, (HMENU) 0, app->hinstance, 0 );\n    if( !app->hwnd ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to create window.\" ); goto init_failed; }\n    app->hdc = GetDC( app->hwnd );\n    app->has_focus = TRUE;\n    app->is_minimized = FALSE;\n\n    // Store app pointer with window\n    #pragma warning( push )\n    #pragma warning( disable: 4244 ) // conversion from 'LONG_PTR' to 'LONG', possible loss of data\n    SetWindowLongPtr( app->hwnd, GWLP_USERDATA, (LONG_PTR) app );\n    #pragma warning( pop )\n\n\n    #ifdef APP_ENABLE_MEDIA_KEYS\n        int const APP_MOD_NOREPEAT = 0x4000;\n        RegisterHotKey( app->hwnd, VK_VOLUME_MUTE, APP_MOD_NOREPEAT, VK_VOLUME_MUTE );\n        RegisterHotKey( app->hwnd, VK_VOLUME_DOWN, APP_MOD_NOREPEAT, VK_VOLUME_DOWN );\n        RegisterHotKey( app->hwnd, VK_VOLUME_UP, APP_MOD_NOREPEAT, VK_VOLUME_UP );\n        RegisterHotKey( app->hwnd, VK_MEDIA_NEXT_TRACK, APP_MOD_NOREPEAT, VK_MEDIA_NEXT_TRACK );\n        RegisterHotKey( app->hwnd, VK_MEDIA_PREV_TRACK, APP_MOD_NOREPEAT, VK_MEDIA_PREV_TRACK );\n        RegisterHotKey( app->hwnd, VK_MEDIA_STOP, APP_MOD_NOREPEAT, VK_MEDIA_STOP );\n        RegisterHotKey( app->hwnd, VK_MEDIA_PLAY_PAUSE, APP_MOD_NOREPEAT, VK_MEDIA_PLAY_PAUSE );\n    #endif\n\n    ShowWindow( app->hwnd, SW_HIDE );\n    // Windows specific OpenGL initialization\n    app->gl_dll = LoadLibraryA( \"opengl32.dll\" );\n    if( !app->gl_dll ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to load opengl32.dll\" ); goto init_failed; }\n    app->wglGetProcAddress = (PROC(APP_GLCALLTYPE*)(LPCSTR)) (uintptr_t) GetProcAddress( app->gl_dll, \"wglGetProcAddress\" );\n    if( !app->wglGetProcAddress ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to find wglGetProcAddress\" ); goto init_failed; }\n    app->wglCreateContext = (HGLRC(APP_GLCALLTYPE*)(HDC)) (uintptr_t) GetProcAddress( app->gl_dll, \"wglCreateContext\" );\n    if( !app->wglCreateContext ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to find wglCreateContext\" ); goto init_failed; }\n    app->wglDeleteContext = (BOOL(APP_GLCALLTYPE*)(HGLRC)) (uintptr_t) GetProcAddress( app->gl_dll, \"wglDeleteContext\" );\n    if( !app->wglDeleteContext ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to find wglDeleteContext\" ); goto init_failed; }\n    app->wglMakeCurrent = (BOOL(APP_GLCALLTYPE*)(HDC, HGLRC)) (uintptr_t) GetProcAddress( app->gl_dll, \"wglMakeCurrent\" );\n    if( !app->wglMakeCurrent ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to find wglMakeCurrent\" ); goto init_failed; }\n\n    PIXELFORMATDESCRIPTOR pfd;\n    memset( &pfd, 0, sizeof( pfd ) );\n    pfd.nSize = sizeof( PIXELFORMATDESCRIPTOR );\n    pfd.nVersion = 1;\n    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;\n    pfd.iPixelType = PFD_TYPE_RGBA;\n    pfd.cColorBits = 32;\n    pfd.cDepthBits = 24;\n    pfd.cStencilBits = 8;\n    pfd.iLayerType = PFD_MAIN_PLANE;\n    BOOL res = SetPixelFormat( app->hdc, ChoosePixelFormat( app->hdc, &pfd ), &pfd );\n    if( !res ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to set pixel format\" ); goto init_failed; }\n\n    app->gl_context = app->wglCreateContext( app->hdc );\n    if( !app->gl_context ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to create OpenGL context\" ); goto init_failed; }\n    res = app->wglMakeCurrent( app->hdc, app->gl_context );\n    if( !res ) { app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to activate OpenGl Context\" ); goto init_failed; }\n\n    app->wglSwapIntervalEXT = (BOOL (APP_GLCALLTYPE*)(int)) (uintptr_t) app->wglGetProcAddress( \"wglSwapIntervalEXT\" );\n    if( app->wglSwapIntervalEXT ) app->wglSwapIntervalEXT( 1 );\n\n    // Attempt to bind opengl functions using GetProcAddress\n    app->gl.CreateShader = ( APP_GLuint (APP_GLCALLTYPE*) (APP_GLenum) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glCreateShader\" );\n    app->gl.ShaderSource = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLsizei, APP_GLchar const* const*, APP_GLint const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glShaderSource\" );\n    app->gl.CompileShader = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glCompileShader\" );\n    app->gl.GetShaderiv = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLenum, APP_GLint*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glGetShaderiv\" );\n    app->gl.CreateProgram = ( APP_GLuint (APP_GLCALLTYPE*) (void) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glCreateProgram\" );\n    app->gl.AttachShader = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glAttachShader\" );\n    app->gl.BindAttribLocation = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLuint, APP_GLchar const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glBindAttribLocation\" );\n    app->gl.LinkProgram = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glLinkProgram\" );\n    app->gl.GetProgramiv = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLenum, APP_GLint*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glGetProgramiv\" );\n    app->gl.GenBuffers = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glGenBuffers\" );\n    app->gl.BindBuffer = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glBindBuffer\" );\n    app->gl.EnableVertexAttribArray = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glEnableVertexAttribArray\" );\n    app->gl.VertexAttribPointer = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLint, APP_GLenum, APP_GLboolean, APP_GLsizei, void const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glVertexAttribPointer\" );\n    app->gl.GenTextures = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glGenTextures\" );\n    app->gl.Enable = ( void (APP_GLCALLTYPE*) (APP_GLenum) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glEnable\" );\n    app->gl.ActiveTexture = ( void (APP_GLCALLTYPE*) (APP_GLenum) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glActiveTexture\" );\n    app->gl.BindTexture = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glBindTexture\" );\n    app->gl.TexParameteri = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLenum, APP_GLint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glTexParameteri\" );\n    app->gl.DeleteBuffers = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glDeleteBuffers\" );\n    app->gl.DeleteTextures = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glDeleteTextures\" );\n    app->gl.BufferData = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLsizeiptr, void const *, APP_GLenum) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glBufferData\" );\n    app->gl.UseProgram = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glUseProgram\" );\n    app->gl.Uniform1i = ( void (APP_GLCALLTYPE*) (APP_GLint, APP_GLint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glUniform1i\" );\n    app->gl.Uniform3f = ( void (APP_GLCALLTYPE*) (APP_GLint, APP_GLfloat, APP_GLfloat, APP_GLfloat) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glUniform3f\" );\n    app->gl.GetUniformLocation = ( APP_GLint (APP_GLCALLTYPE*) (APP_GLuint, APP_GLchar const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glGetUniformLocation\" );\n    app->gl.TexImage2D = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLint, APP_GLint, APP_GLsizei, APP_GLsizei, APP_GLint, APP_GLenum, APP_GLenum, void const*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glTexImage2D\" );\n    app->gl.ClearColor = ( void (APP_GLCALLTYPE*) (APP_GLfloat, APP_GLfloat, APP_GLfloat, APP_GLfloat) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glClearColor\" );\n    app->gl.Clear = ( void (APP_GLCALLTYPE*) (APP_GLbitfield) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glClear\" );\n    app->gl.DrawArrays = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLint, APP_GLsizei) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glDrawArrays\" );\n    app->gl.Viewport = ( void (APP_GLCALLTYPE*) (APP_GLint, APP_GLint, APP_GLsizei, APP_GLsizei) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glViewport\" );\n    app->gl.DeleteShader = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glDeleteShader\" );\n    app->gl.DeleteProgram = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glDeleteProgram\" );\n    #ifdef APP_REPORT_SHADER_ERRORS\n        app->gl.GetShaderInfoLog = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLsizei, APP_GLsizei*, APP_GLchar*) ) (uintptr_t) GetProcAddress( app->gl_dll, \"glGetShaderInfoLog\" );\n    #endif\n\n    // Any opengl functions which didn't bind, try binding them using wglGetProcAddrss\n    if( !app->gl.CreateShader ) app->gl.CreateShader = ( APP_GLuint (APP_GLCALLTYPE*) (APP_GLenum) ) (uintptr_t) app->wglGetProcAddress( \"glCreateShader\" );\n    if( !app->gl.ShaderSource ) app->gl.ShaderSource = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLsizei, APP_GLchar const* const*, APP_GLint const*) ) (uintptr_t) app->wglGetProcAddress( \"glShaderSource\" );\n    if( !app->gl.CompileShader ) app->gl.CompileShader = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glCompileShader\" );\n    if( !app->gl.GetShaderiv ) app->gl.GetShaderiv = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLenum, APP_GLint*) ) (uintptr_t) app->wglGetProcAddress( \"glGetShaderiv\" );\n    if( !app->gl.CreateProgram ) app->gl.CreateProgram = ( APP_GLuint (APP_GLCALLTYPE*) (void) ) (uintptr_t) app->wglGetProcAddress( \"glCreateProgram\" );\n    if( !app->gl.AttachShader ) app->gl.AttachShader = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glAttachShader\" );\n    if( !app->gl.BindAttribLocation ) app->gl.BindAttribLocation = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLuint, APP_GLchar const*) ) (uintptr_t) app->wglGetProcAddress( \"glBindAttribLocation\" );\n    if( !app->gl.LinkProgram ) app->gl.LinkProgram = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glLinkProgram\" );\n    if( !app->gl.GetProgramiv ) app->gl.GetProgramiv = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLenum, APP_GLint*) ) (uintptr_t) app->wglGetProcAddress( \"glGetProgramiv\" );\n    if( !app->gl.GenBuffers ) app->gl.GenBuffers = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint*) ) (uintptr_t) app->wglGetProcAddress( \"glGenBuffers\" );\n    if( !app->gl.BindBuffer ) app->gl.BindBuffer = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glBindBuffer\" );\n    if( !app->gl.EnableVertexAttribArray ) app->gl.EnableVertexAttribArray = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glEnableVertexAttribArray\" );\n    if( !app->gl.VertexAttribPointer ) app->gl.VertexAttribPointer = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLint, APP_GLenum, APP_GLboolean, APP_GLsizei, void const*) ) (uintptr_t) app->wglGetProcAddress( \"glVertexAttribPointer\" );\n    if( !app->gl.GenTextures ) app->gl.GenTextures = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint*) ) (uintptr_t) app->wglGetProcAddress( \"glGenTextures\" );\n    if( !app->gl.Enable ) app->gl.Enable = ( void (APP_GLCALLTYPE*) (APP_GLenum) ) (uintptr_t) app->wglGetProcAddress( \"glEnable\" );\n    if( !app->gl.ActiveTexture ) app->gl.ActiveTexture = ( void (APP_GLCALLTYPE*) (APP_GLenum) ) (uintptr_t) app->wglGetProcAddress( \"glActiveTexture\" );\n    if( !app->gl.BindTexture ) app->gl.BindTexture = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glBindTexture\" );\n    if( !app->gl.TexParameteri ) app->gl.TexParameteri = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLenum, APP_GLint) ) (uintptr_t) app->wglGetProcAddress( \"glTexParameteri\" );\n    if( !app->gl.DeleteBuffers ) app->gl.DeleteBuffers = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint const*) ) (uintptr_t) app->wglGetProcAddress( \"glDeleteBuffers\" );\n    if( !app->gl.DeleteTextures ) app->gl.DeleteTextures = ( void (APP_GLCALLTYPE*) (APP_GLsizei, APP_GLuint const*) ) (uintptr_t) app->wglGetProcAddress( \"glDeleteTextures\" );\n    if( !app->gl.BufferData ) app->gl.BufferData = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLsizeiptr, void const *, APP_GLenum) ) (uintptr_t) app->wglGetProcAddress( \"glBufferData\" );\n    if( !app->gl.UseProgram ) app->gl.UseProgram = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glUseProgram\" );\n    if( !app->gl.Uniform1i ) app->gl.Uniform1i = ( void (APP_GLCALLTYPE*) (APP_GLint, APP_GLint) ) (uintptr_t) app->wglGetProcAddress( \"glUniform1i\" );\n    if( !app->gl.Uniform3f ) app->gl.Uniform3f = ( void (APP_GLCALLTYPE*) (APP_GLint, APP_GLfloat, APP_GLfloat, APP_GLfloat) ) (uintptr_t) app->wglGetProcAddress( \"glUniform3f\" );\n    if( !app->gl.GetUniformLocation ) app->gl.GetUniformLocation = ( APP_GLint (APP_GLCALLTYPE*) (APP_GLuint, APP_GLchar const*) ) (uintptr_t) app->wglGetProcAddress( \"glGetUniformLocation\" );\n    if( !app->gl.TexImage2D ) app->gl.TexImage2D = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLint, APP_GLint, APP_GLsizei, APP_GLsizei, APP_GLint, APP_GLenum, APP_GLenum, void const*) ) (uintptr_t) app->wglGetProcAddress( \"glTexImage2D\" );\n    if( !app->gl.ClearColor ) app->gl.ClearColor = ( void (APP_GLCALLTYPE*) (APP_GLfloat, APP_GLfloat, APP_GLfloat, APP_GLfloat) ) (uintptr_t) app->wglGetProcAddress( \"glClearColor\" );\n    if( !app->gl.Clear ) app->gl.Clear = ( void (APP_GLCALLTYPE*) (APP_GLbitfield) ) (uintptr_t) app->wglGetProcAddress( \"glClear\" );\n    if( !app->gl.DrawArrays ) app->gl.DrawArrays = ( void (APP_GLCALLTYPE*) (APP_GLenum, APP_GLint, APP_GLsizei) ) (uintptr_t) app->wglGetProcAddress( \"glDrawArrays\" );\n    if( !app->gl.Viewport ) app->gl.Viewport = ( void (APP_GLCALLTYPE*) (APP_GLint, APP_GLint, APP_GLsizei, APP_GLsizei) ) (uintptr_t) app->wglGetProcAddress( \"glViewport\" );\n    if( !app->gl.DeleteShader ) app->gl.DeleteShader = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glDeleteShader\" );\n    if( !app->gl.DeleteProgram ) app->gl.DeleteProgram = ( void (APP_GLCALLTYPE*) (APP_GLuint) ) (uintptr_t) app->wglGetProcAddress( \"glDeleteProgram\" );\n    #ifdef APP_REPORT_SHADER_ERRORS\n        if( !app->gl.GetShaderInfoLog ) app->gl.GetShaderInfoLog = ( void (APP_GLCALLTYPE*) (APP_GLuint, APP_GLsizei, APP_GLsizei*, APP_GLchar*) ) (uintptr_t) app->wglGetProcAddress( \"glGetShaderInfoLog\" );\n    #endif\n\n    // Report error if any gl function was not found.\n    if( !app->gl.CreateShader ) { app_fatal_error( app, \"Could not find function CreateShader.\" ); goto init_failed; }\n    if( !app->gl.ShaderSource ) { app_fatal_error( app, \"Could not find function ShaderSource.\" ); goto init_failed; }\n    if( !app->gl.CompileShader ) { app_fatal_error( app, \"Could not find function CompileShader.\" ); goto init_failed; }\n    if( !app->gl.GetShaderiv ) { app_fatal_error( app, \"Could not find function GetShaderiv.\" ); goto init_failed; }\n    if( !app->gl.CreateProgram ) { app_fatal_error( app, \"Could not find function CreateProgram.\" ); goto init_failed; }\n    if( !app->gl.AttachShader ) { app_fatal_error( app, \"Could not find function AttachShader.\" ); goto init_failed; }\n    if( !app->gl.BindAttribLocation ) { app_fatal_error( app, \"Could not find function BindAttribLocation.\" ); goto init_failed; }\n    if( !app->gl.LinkProgram ) { app_fatal_error( app, \"Could not find function LinkProgram.\" ); goto init_failed; }\n    if( !app->gl.GetProgramiv ) { app_fatal_error( app, \"Could not find function GetProgramiv.\" ); goto init_failed; }\n    if( !app->gl.GenBuffers ) { app_fatal_error( app, \"Could not find function GenBuffers.\" ); goto init_failed; }\n    if( !app->gl.BindBuffer ) { app_fatal_error( app, \"Could not find function BindBuffer.\" ); goto init_failed; }\n    if( !app->gl.EnableVertexAttribArray ) { app_fatal_error( app, \"Could not find function EnableVertexAttribArray.\" ); goto init_failed; }\n    if( !app->gl.VertexAttribPointer ) { app_fatal_error( app, \"Could not find function VertexAttribPointer.\" ); goto init_failed; }\n    if( !app->gl.GenTextures ) { app_fatal_error( app, \"Could not find function GenTextures.\" ); goto init_failed; }\n    if( !app->gl.Enable ) { app_fatal_error( app, \"Could not find function Enable.\" ); goto init_failed; }\n    if( !app->gl.ActiveTexture ) { app_fatal_error( app, \"Could not find function ActiveTexture.\" ); goto init_failed; }\n    if( !app->gl.BindTexture ) { app_fatal_error( app, \"Could not find function BindTexture.\" ); goto init_failed; }\n    if( !app->gl.TexParameteri ) { app_fatal_error( app, \"Could not find function TexParameteri.\" ); goto init_failed; }\n    if( !app->gl.DeleteBuffers ) { app_fatal_error( app, \"Could not find function DeleteBuffers.\" ); goto init_failed; }\n    if( !app->gl.DeleteTextures ) { app_fatal_error( app, \"Could not find function DeleteTextures.\" ); goto init_failed; }\n    if( !app->gl.BufferData ) { app_fatal_error( app, \"Could not find function BufferData.\" ); goto init_failed; }\n    if( !app->gl.UseProgram ) { app_fatal_error( app, \"Could not find function UseProgram.\" ); goto init_failed; }\n    if( !app->gl.Uniform1i ) { app_fatal_error( app, \"Could not find function Uniform1i.\" ); goto init_failed; }\n    if( !app->gl.Uniform3f ) { app_fatal_error( app, \"Could not find function Uniform3f.\" ); goto init_failed; }\n    if( !app->gl.GetUniformLocation ) { app_fatal_error( app, \"Could not find function GetUniformLocation.\" ); goto init_failed; }\n    if( !app->gl.TexImage2D ) { app_fatal_error( app, \"Could not find function TexImage2D.\" ); goto init_failed; }\n    if( !app->gl.ClearColor ) { app_fatal_error( app, \"Could not find function ClearColor.\" ); goto init_failed; }\n    if( !app->gl.Clear ) { app_fatal_error( app, \"Could not find function Clear.\" ); goto init_failed; }\n    if( !app->gl.DrawArrays ) { app_fatal_error( app, \"Could not find function DrawArrays.\" ); goto init_failed; }\n    if( !app->gl.Viewport ) { app_fatal_error( app, \"Could not find function Viewport.\" ); goto init_failed; }\n    if( !app->gl.DeleteShader ) { app_fatal_error( app, \"Could not find function DeleteShader.\" ); goto init_failed; }\n    if( !app->gl.DeleteProgram ) { app_fatal_error( app, \"Could not find function DeleteProgram.\" ); goto init_failed; }\n    #ifdef APP_REPORT_SHADER_ERRORS\n        if( !app->gl.GetShaderInfoLog ) { app_fatal_error( app, \"Could not find function GetShaderInfoLog.\" ); goto init_failed; }\n    #endif\n\n    // Platform independent OpenGL initialization\n    int width = app->screenmode == APP_SCREENMODE_FULLSCREEN ? app->fullscreen_width : app->windowed_w;\n    int height = app->screenmode == APP_SCREENMODE_FULLSCREEN ? app->fullscreen_height: app->windowed_h;\n    if( !app_internal_opengl_init( app, &app->gl, app->interpolation, width, height ) )\n        {\n        app_log( app, APP_LOG_LEVEL_ERROR, \"Failed to initialize OpenGL\" );\n        goto init_failed;\n        }\n\n    app->sound_notifications[ 0 ] = CreateEventA( NULL, FALSE, FALSE, NULL );\n    app->sound_notifications[ 1 ] = CreateEventA( NULL, FALSE, FALSE, NULL );\n\n\n    app->dsound_dll = LoadLibraryA( \"dsound.dll\" );\n    if( !app->dsound_dll ) app_log( app, APP_LOG_LEVEL_WARNING, \"Couldn't load dsound.dll. Sound disabled.\" );\n\n    if( app->dsound_dll )\n        {\n        HRESULT (WINAPI *DirectSoundCreate8Ptr)(LPCGUID,struct IDirectSound8**,void*) = ( HRESULT (WINAPI*)(LPCGUID,struct IDirectSound8**,void*) )\n            (uintptr_t) GetProcAddress( (HMODULE) app->dsound_dll, \"DirectSoundCreate8\" );\n        if( !DirectSoundCreate8Ptr )\n            {\n            app_log( app, APP_LOG_LEVEL_WARNING, \"Couldn't find DirectSoundCreate. Sound disabled.\" );\n            FreeLibrary( app->dsound_dll );\n            app->dsound_dll = 0;\n            }\n        if( DirectSoundCreate8Ptr )\n            {\n            HRESULT hr = DirectSoundCreate8Ptr( NULL, &app->dsound, NULL );\n            if( FAILED( hr ) || !app->dsound )\n                {\n                app_log( app, APP_LOG_LEVEL_WARNING, \"Couldn't create DirectSound object. Sound disabled.\" );\n                DirectSoundCreate8Ptr = 0;\n                FreeLibrary( app->dsound_dll );\n                app->dsound_dll = 0;\n                }\n            else\n                {\n                hr = IDirectSound8_SetCooperativeLevel( app->dsound, app->hwnd, DSSCL_NORMAL);\n                if( FAILED( hr ) )\n                    {\n                    app_log( app, APP_LOG_LEVEL_WARNING, \"Couldn't set cooperative level for DirectSound object. Sound disabled.\" );\n                    IDirectSound8_Release( app->dsound );\n                    app->dsound = 0;\n                    DirectSoundCreate8Ptr = 0;\n                    FreeLibrary( app->dsound_dll );\n                    app->dsound_dll = 0;\n                    }\n                }\n            }\n        }\n    app->sound_thread_handle = INVALID_HANDLE_VALUE;\n\n    HMODULE user32 = LoadLibraryA( \"user32.dll\" );\n    if( user32 )\n        {\n        BOOL (WINAPI *RegisterRawInputDevicesPtr)( PCRAWINPUTDEVICE, UINT, UINT ) =\n            (BOOL (WINAPI*)( PCRAWINPUTDEVICE, UINT, UINT ) )(uintptr_t) GetProcAddress( user32, \"RegisterRawInputDevices\" );\n\n        app->GetRawInputDataPtr = (UINT (WINAPI*)( HRAWINPUT, UINT, LPVOID, PUINT, UINT))\n            (uintptr_t) GetProcAddress( user32, \"GetRawInputData\" );\n\n        USHORT const USAGE_PAGE_GENERIC = ((USHORT) 0x01);\n        USHORT const USAGE_GENERIC_MOUSE = ((USHORT) 0x02);\n\n        RAWINPUTDEVICE rid[ 1 ];\n        rid[ 0 ].usUsagePage = USAGE_PAGE_GENERIC;\n        rid[ 0 ].usUsage = USAGE_GENERIC_MOUSE;\n        rid[ 0 ].dwFlags = RIDEV_INPUTSINK;\n        rid[ 0 ].hwndTarget = app->hwnd;\n        RegisterRawInputDevicesPtr( rid, 1, sizeof( *rid ) );\n\n        FreeLibrary( user32 );\n        }\n\n    if( !app_internal_tablet_init( app ) ) app_log( app, APP_LOG_LEVEL_WARNING, \"WinTab initialization failed - tablet not available\" );\n\n    result = app_proc( app, user_data );\n\ninit_failed:\n    if( !app_internal_tablet_term( app ) ) app_log( app, APP_LOG_LEVEL_WARNING, \"WinTab termination failed\" );\n    if( app->sound_thread_handle != INVALID_HANDLE_VALUE )\n        {\n        InterlockedExchange( &app->exit_sound_thread, 1 );\n        WaitForSingleObject( app->sound_thread_handle, INFINITE );\n        CloseHandle( app->sound_thread_handle );\n        }\n    if( app->dsoundbuf ) IDirectSoundBuffer8_Release( app->dsoundbuf );\n    if( app->dsound ) IDirectSound8_Release( app->dsound );\n    if( app->dsound_dll ) FreeLibrary( app->dsound_dll );\n    if( app->sound_notifications[ 0 ] ) CloseHandle( app->sound_notifications[ 0 ] );\n    if( app->sound_notifications[ 1 ] ) CloseHandle( app->sound_notifications[ 1 ] );\n    if( !app_internal_opengl_term( &app->gl ) ) app_log( app, APP_LOG_LEVEL_WARNING, \"Failed to terminate OpenGL\" );\n    if( app->gl_context ) app->wglMakeCurrent( 0, 0 );\n    if( app->gl_context ) app->wglDeleteContext( app->gl_context );\n    if( app->gl_dll ) FreeLibrary( app->gl_dll );\n    if( app->icon ) DestroyIcon( app->icon );\n    if( app->current_pointer ) DestroyIcon( app->current_pointer );\n    if( app->hdc ) ReleaseDC( app->hwnd, app->hdc );\n    if( app->hwnd ) DestroyWindow( app->hwnd );\n    UnregisterClass( TEXT( \"app_wc\" ), app->hinstance );\n\n    #ifndef __TINYC__\n    if( timeGetDevCaps( &tc, sizeof( TIMECAPS ) ) == TIMERR_NOERROR )\n        timeEndPeriod( tc.wPeriodMin );\n    #endif\n\n    t = time( NULL );\n    struct tm* end = localtime( &t );\n    sprintf( msg, \"Application terminated %02d:%02d:%02d %04d-%02d-%02d.\",\n        end->tm_hour, end->tm_min, end->tm_sec, end->tm_year + 1900, end->tm_mon + 1, end->tm_mday );\n    app_log( app, APP_LOG_LEVEL_INFO, msg );\n\n    APP_FREE( memctx, app );\n    return result;\n    }\n\n#pragma warning( pop )\n\n\napp_state_t app_yield( app_t* app )\n    {\n    if( !app->initialized )\n        {\n        if( app->screenmode == APP_SCREENMODE_WINDOW )\n        {\n            app->screenmode = APP_SCREENMODE_FULLSCREEN;\n            app_screenmode( app, APP_SCREENMODE_WINDOW );\n        }\n        else\n        {\n            app->screenmode = APP_SCREENMODE_WINDOW;\n            app_screenmode( app, APP_SCREENMODE_FULLSCREEN );\n        }\n        STARTUPINFOA startup_info = { sizeof( STARTUPINFOA ) };\n        GetStartupInfoA( &startup_info );\n        if( startup_info.dwFlags & STARTF_USESHOWWINDOW ) {\n            ShowWindow( app->hwnd, startup_info.wShowWindow );\n        } else {\n            ShowWindow( app->hwnd, SW_SHOWDEFAULT );\n        }\n        SetActiveWindow( app->hwnd );\n        BringWindowToTop( app->hwnd );\n        SwitchToThisWindow( app->hwnd, TRUE );\n        if( app->tablet.context ) app->tablet.WTEnable( app->tablet.context, TRUE );\n        app->initialized = TRUE;\n        }\n\n    MSG msg;\n    while( PeekMessage( &msg, app->hwnd, 0,0, PM_REMOVE ) )\n        {\n        TranslateMessage( &msg );\n        DispatchMessage( &msg );\n        }\n\n        SwitchToThread();   //  yield to any thread on same processor\n\n    return app->closed == TRUE ? APP_STATE_EXIT_REQUESTED : APP_STATE_NORMAL;\n    }\n\n\nvoid app_cancel_exit( app_t* app )\n    {\n    app->closed = FALSE;\n    }\n\n\nvoid app_title( app_t* app, char const* title )\n    {\n    #ifdef UNICODE\n        int len = (int) strlen (title );\n        if( len < 256 )\n            {\n            WCHAR unistring[ 256 ];\n            MultiByteToWideChar( CP_ACP, 0, title, -1, unistring, len + 1 );\n            SetWindowText( app->hwnd, unistring );\n            }\n    #else\n        SetWindowText( app->hwnd, title );\n    #endif\n    }\n\n\nchar const* app_cmdline( app_t* app )\n    {\n    return app->cmdline;\n    }\n\n\nchar const* app_filename( app_t* app )\n    {\n    return app->exe_path;\n    }\n\n\nchar const* app_userdata( app_t* app )\n    {\n    return app->userdata_path;\n    }\n\n\nchar const* app_appdata( app_t* app )\n    {\n    return app->appdata_path;\n    }\n\n\nAPP_U64 app_time_count( app_t* app )\n    {\n    (void) app;\n    LARGE_INTEGER c;\n    QueryPerformanceCounter( &c );\n    return (APP_U64) c.QuadPart;\n    }\n\n\nAPP_U64 app_time_freq( app_t* app )\n    {\n    (void) app;\n    LARGE_INTEGER f;\n    QueryPerformanceFrequency( &f );\n    return (APP_U64) f.QuadPart;\n    }\n\n\nvoid app_log( app_t* app, app_log_level_t level, char const* message )\n    {\n    (void) app, (void) level, (void) message;\n    APP_LOG( app->logctx, level, message );\n    }\n\n\nvoid app_fatal_error( app_t* app, char const* message )\n    {\n    (void) app, (void) message;\n    APP_FATAL_ERROR( app->fatalctx, message );\n    }\n\n\nstatic HCURSOR app_internal_create_cursor( HWND hwnd, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y )\n    {\n    int size = width > height ? width : height;\n    BITMAPV5HEADER header;\n    memset( &header, 0, sizeof( BITMAPV5HEADER ) );\n    header.bV5Size = sizeof( BITMAPV5HEADER );\n    header.bV5Width = (LONG) size;\n    header.bV5Height = -(LONG) size;\n    header.bV5Planes = 1;\n    header.bV5BitCount = 32;\n    header.bV5Compression = BI_BITFIELDS;\n    header.bV5RedMask   =  0x00FF0000;\n    header.bV5GreenMask =  0x0000FF00;\n    header.bV5BlueMask  =  0x000000FF;\n    header.bV5AlphaMask =  0xFF000000;\n\n    HDC hdc = GetDC( hwnd );\n    void* bits = NULL;\n    HBITMAP bitmap = CreateDIBSection( hdc, (BITMAPINFO*)&header, DIB_RGB_COLORS,  (void**) &bits, NULL, (DWORD) 0);\n    ReleaseDC( NULL, hdc );\n\n    APP_U32* ptr = (APP_U32*) bits;\n    for( int y = 0; y < height; ++y )\n        {\n        for( int x = 0; x < width; ++x )\n        {\n            APP_U32 c = pixels_abgr[ x + y * width ];\n            APP_U32 a = ( c & 0xff000000 ) >> 24;\n            APP_U32 b = ( c & 0x00ff0000 ) >> 16;\n            APP_U32 g = ( c & 0x0000ff00 ) >> 8;\n            APP_U32 r = ( c & 0x000000ff );\n            ptr[ x + y * size ] = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | b;\n            }\n        }\n\n    HBITMAP empty_mask = CreateBitmap( size, size, 1, 1, NULL );\n    ICONINFO icon_info;\n    icon_info.fIcon = FALSE;\n    icon_info.xHotspot = (DWORD) hotspot_x;\n    icon_info.yHotspot = (DWORD) hotspot_y;\n    icon_info.hbmMask = empty_mask;\n    icon_info.hbmColor = bitmap;\n\n    HCURSOR cursor = CreateIconIndirect( &icon_info );\n    DeleteObject( bitmap );\n    DeleteObject( empty_mask );\n\n    return cursor;\n    }\n\n\nvoid app_pointer( app_t* app, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y )\n    {\n    if( app->current_pointer ) DestroyIcon( app->current_pointer );\n    app->current_pointer = 0;\n\n    if( pixels_abgr )\n        app->current_pointer = app_internal_create_cursor( app->hwnd, width, height,\n            pixels_abgr, hotspot_x, hotspot_y );\n    ShowCursor( FALSE );\n    SetCursor( app->current_pointer );\n    ShowCursor( TRUE );\n    }\n\n\nstatic BOOL app_internal_extract_default_windows_cursor( int* width, int* height, APP_U32* pixels_abgr,\n    int* hotspot_x, int* hotspot_y )\n    {\n    HCURSOR cursor = LoadCursor( NULL, IDC_ARROW );\n    if( !cursor ) return FALSE;\n\n    ICONINFO info;\n    if( !GetIconInfo( cursor, &info ) ) { DestroyCursor( cursor ); return FALSE; }\n    BOOL bw_cursor = ( info.hbmColor == NULL );\n\n    BITMAP bmpinfo;\n    memset( &bmpinfo, 0, sizeof( bmpinfo ) );\n    if( bw_cursor && GetObject( info.hbmMask, sizeof( BITMAP ), &bmpinfo ) == 0 )\n        {\n        DestroyCursor( cursor );\n        DeleteObject( info.hbmColor );\n        DeleteObject( info.hbmMask );\n        return FALSE;\n        }\n    if( !bw_cursor && GetObject( info.hbmColor, sizeof( BITMAP ), &bmpinfo ) == 0 )\n        {\n        DestroyCursor( cursor );\n        DeleteObject( info.hbmColor );\n        DeleteObject( info.hbmMask );\n        return FALSE;\n        }\n\n    if( bmpinfo.bmWidth > 256 || bmpinfo.bmHeight > 256 )\n        {\n        DestroyCursor( cursor );\n        DeleteObject( info.hbmColor );\n        DeleteObject( info.hbmMask );\n        return FALSE;\n        }\n    int pointer_width = bmpinfo.bmWidth;\n    int pointer_height = ( bmpinfo.bmHeight >= 0 ? bmpinfo.bmHeight : -bmpinfo.bmHeight ) / ( bw_cursor ? 2 : 1 );\n\n    if( width ) *width = pointer_width;\n    if( height ) *height = pointer_height;\n    if( hotspot_x ) *hotspot_x = (int) info.xHotspot;\n    if( hotspot_y ) *hotspot_y = (int) info.yHotspot;\n    if( !pixels_abgr )\n        {\n        DestroyCursor( cursor );\n        DeleteObject( info.hbmColor );\n        DeleteObject( info.hbmMask );\n        return TRUE;\n        }\n\n    BITMAPINFOHEADER bmi;\n    bmi.biSize = sizeof( BITMAPINFOHEADER );\n    bmi.biPlanes = 1;\n    bmi.biBitCount = 32;\n    bmi.biWidth = bmpinfo.bmWidth;\n    bmi.biHeight = -bmpinfo.bmHeight;\n    bmi.biCompression = BI_RGB;\n    bmi.biSizeImage = 0;\n    HDC hdc = GetDC( NULL );\n    if( GetDIBits( hdc, bw_cursor ? info.hbmMask : info.hbmColor, 0, (UINT) bmpinfo.bmHeight, pixels_abgr,\n        (BITMAPINFO*) &bmi, DIB_RGB_COLORS ) != bmpinfo.bmHeight )\n        {\n        DestroyCursor( cursor );\n        DeleteObject( info.hbmColor );\n        DeleteObject( info.hbmMask );\n        ReleaseDC( NULL, hdc );\n        return FALSE;\n        }\n    ReleaseDC( NULL, hdc );\n\n    if( bw_cursor )\n        {\n        for( int y = 0; y < pointer_height; ++y )\n            {\n            for( int x = 0; x < pointer_width; ++x )\n                {\n                APP_U32 c = pixels_abgr[ x + pointer_width * y ];\n                APP_U32 m = pixels_abgr[ x + pointer_width * ( pointer_height + y ) ];\n                APP_U32 a = 255 - ( c & 0xff );\n                APP_U32 g = m & 0xff;\n                pixels_abgr[ x + pointer_width * y ] = ( a << 24 ) | ( g << 16 ) | ( g << 8 ) | g;\n                }\n            }\n        }\n    else\n        {\n        for( int y = 0; y < pointer_height; ++y )\n            {\n            for( int x = 0; x < pointer_width; ++x )\n                {\n                APP_U32 c = pixels_abgr[ x + pointer_width * y ];\n                APP_U32 a = ( c >> 24 ) & 0xff;\n                APP_U32 r = ( c >> 16 ) & 0xff;\n                APP_U32 g = ( c >>  8 ) & 0xff;\n                APP_U32 b = ( c       ) & 0xff;\n                pixels_abgr[ x + pointer_width * y ] = ( a << 24 ) | ( b << 16 ) | ( g << 8 ) | r;\n                }\n            }\n        }\n\n    DeleteObject( info.hbmColor );\n    DeleteObject( info.hbmMask );\n    DestroyCursor( cursor );\n    return TRUE;\n    }\n\n\nvoid app_pointer_default( app_t* app, int* width, int* height, APP_U32* pixels_abgr, int* hotspot_x, int* hotspot_y )\n    {\n    (void) app;\n\n    APP_U32 default_pointer_data[ 11 * 16 ] =\n        {\n        0xFF000000,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0xFF000000,0xFF000000,0xFF000000,0xFF000000,\n        0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFFFFFFFF,0xFF000000,0x00000000,0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0xFF000000,0x00000000,0x00000000,0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,0x00000000,\n        0xFF000000,0x00000000,0x00000000,0x00000000,0x00000000,0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,\n        0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xFF000000,0xFFFFFFFF,0xFFFFFFFF,0xFF000000,0x00000000,0x00000000,\n        0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xFF000000,0xFF000000,0xFF000000,0x00000000,0x00000000,\n        };\n\n    if( !app_internal_extract_default_windows_cursor( width, height, pixels_abgr, hotspot_x, hotspot_y ) )\n        {\n        if( width ) *width = 11;\n        if( height ) *height = 16;\n        if( hotspot_x ) *hotspot_x = 0;\n        if( hotspot_y ) *hotspot_y = 0;\n        if( pixels_abgr ) memcpy( pixels_abgr, default_pointer_data, sizeof( APP_U32 ) * 11 * 16 );\n        }\n    }\n\n\n\nvoid app_pointer_pos( app_t* app, int x, int y )\n    {\n    POINT p;\n    p.x = x;\n    p.y = y;\n    ClientToScreen( app->hwnd, &p );\n    SetCursorPos( p.x, p.y );\n    }\n\n\nint app_pointer_x( app_t* app )\n    {\n    POINT p;\n    GetCursorPos( &p );\n    ScreenToClient( app->hwnd, &p );\n    return (int) p.x;\n    }\n\n\nint app_pointer_y( app_t* app )\n    {\n    POINT p;\n    GetCursorPos( &p );\n    ScreenToClient( app->hwnd, &p );\n    return (int) p.y;\n    }\n\n\nvoid app_pointer_limit( app_t* app, int x, int y, int width, int height )\n    {\n    app->clip_cursor = TRUE;\n    app->clip_rect.left= x;\n    app->clip_rect.top = y;\n    app->clip_rect.right = x + width;\n    app->clip_rect.bottom = y + height;\n\n    RECT r = app->clip_rect;\n    ClientToScreen( app->hwnd, (POINT*)&r );\n    ClientToScreen( app->hwnd, ( (POINT*)&r ) + 1 );\n    ClipCursor( &r );\n    }\n\n\nvoid app_pointer_limit_off( app_t* app )\n    {\n    app->clip_cursor = FALSE;\n    ClipCursor( 0 );\n    }\n\n\nvoid app_interpolation( app_t* app, app_interpolation_t interpolation )\n    {\n    if( interpolation == app->interpolation ) return;\n    app->interpolation = interpolation;\n\n    POINT p;\n    GetCursorPos( &p );\n    ScreenToClient( app->hwnd, &p );\n    int mouse_x = p.x;\n    int mouse_y = p.y;\n\n    app_input_event_t input_event;\n    input_event.type = APP_INPUT_MOUSE_MOVE;\n    input_event.data.mouse_pos.x = mouse_x;\n    input_event.data.mouse_pos.y = mouse_y;\n    app_internal_add_input_event( app, &input_event );\n\n    app_internal_opengl_interpolation( &app->gl, interpolation );\n    }\n\n\nvoid app_screenmode( app_t* app, app_screenmode_t screenmode )\n    {\n    if( screenmode == app->screenmode ) return;\n    app->screenmode = screenmode;\n    BOOL visible = IsWindowVisible( app->hwnd );\n    if( screenmode == APP_SCREENMODE_WINDOW )\n        {\n        SetWindowLong( app->hwnd, GWL_STYLE, APP_WINDOWED_WS_STYLE | ( visible ? WS_VISIBLE : 0 ) );\n\n        WINDOWPLACEMENT placement;\n        placement.length = sizeof( placement );\n        GetWindowPlacement( app->hwnd, &placement );\n        placement.showCmd = (UINT)( visible ? SW_SHOW : SW_HIDE );\n\n        placement.rcNormalPosition.left = app->windowed_x;\n        placement.rcNormalPosition.top = app->windowed_y;\n        placement.rcNormalPosition.right = app->windowed_x + app->windowed_w;\n        placement.rcNormalPosition.bottom = app->windowed_y + app->windowed_h;\n        SetWindowPlacement( app->hwnd, &placement );\n        }\n    else\n        {\n        WINDOWPLACEMENT placement;\n        placement.length = sizeof( placement );\n        GetWindowPlacement( app->hwnd, &placement );\n\n        if( visible )\n            {\n        if( placement.showCmd != SW_SHOWMAXIMIZED )\n            {\n            app->windowed_x = placement.rcNormalPosition.left;\n            app->windowed_y = placement.rcNormalPosition.top;\n            app->windowed_w = placement.rcNormalPosition.right - placement.rcNormalPosition.left;\n            app->windowed_h = placement.rcNormalPosition.bottom - placement.rcNormalPosition.top;\n            }\n        else\n            {\n            ShowWindow( app->hwnd, SW_RESTORE );\n            }\n            }\n\n        HMONITOR hmonitor = MonitorFromWindow( app->hwnd, MONITOR_DEFAULTTOPRIMARY );\n        int display_index = 0;\n        for( int i = 0; i < app->display_count; ++i )\n            {\n            if( app->displays_hmonitor[ i ] == hmonitor )\n                {\n                display_index = i;\n                break;\n                }\n            }\n\n\n        RECT r = app_internal_rect( app->displays[ display_index ].x, app->displays[ display_index ].y,\n            app->displays[ display_index ].x + app->displays[ display_index ].width,\n            app->displays[ display_index ].y + app->displays[ display_index ].height );\n        app->fullscreen_width = r.right - r.left;\n        app->fullscreen_height = r.bottom - r.top;\n        SetWindowPos( app->hwnd, 0, r.left, r.top, app->fullscreen_width, app->fullscreen_height,\n            SWP_NOOWNERZORDER | SWP_FRAMECHANGED );\n\n        SetWindowLong( app->hwnd, GWL_STYLE, ( visible ? WS_VISIBLE : 0 ) );\n        SetWindowPos( app->hwnd, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_FRAMECHANGED );\n        }\n    }\n\n\nvoid app_window_size( app_t* app, int width, int height )\n    {\n    RECT r;\n    r = app_internal_rect( 0, 0, width, height );\n    AdjustWindowRect( &r, APP_WINDOWED_WS_STYLE | WS_VISIBLE, FALSE );\n\n    width = r.right - r.left;\n    height = r.bottom - r.top;\n    app->windowed_w = width;\n    app->windowed_h = height;\n\n    if( app->screenmode == APP_SCREENMODE_WINDOW )\n        SetWindowPos( app->hwnd, 0, 0, 0, width, height, SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_FRAMECHANGED );\n    }\n\n\nint app_window_width( app_t* app )\n    {\n    RECT r;\n    GetClientRect( app->hwnd, &r );\n    return r.right - r.left;\n    }\n\n\nint app_window_height( app_t* app )\n    {\n    RECT r;\n    GetClientRect( app->hwnd, &r );\n    return r.bottom - r.top;\n    }\n\n\nvoid app_window_pos( app_t* app, int x, int y )\n    {\n    if( app->screenmode == APP_SCREENMODE_WINDOW )\n        {\n        WINDOWPLACEMENT placement;\n        placement.length = sizeof( placement );\n        GetWindowPlacement( app->hwnd, &placement );\n        placement.rcNormalPosition.right = x + ( placement.rcNormalPosition.right - placement.rcNormalPosition.left );\n        placement.rcNormalPosition.bottom = y + ( placement.rcNormalPosition.bottom - placement.rcNormalPosition.top );\n        placement.rcNormalPosition.left = x;\n        placement.rcNormalPosition.top = y;\n        SetWindowPlacement( app->hwnd, &placement );\n        }\n\n        app->windowed_x = x;\n        app->windowed_y = y;\n        }\n\n\nint app_window_x( app_t* app )\n    {\n    if( app->screenmode == APP_SCREENMODE_WINDOW )\n        {\n        WINDOWPLACEMENT placement;\n        placement.length = sizeof( placement );\n        GetWindowPlacement( app->hwnd, &placement );\n        return placement.rcNormalPosition.left;\n        }\n    else\n        {\n        return app->windowed_x;\n        }\n    }\n\n\nint app_window_y( app_t* app )\n    {\n    if( app->screenmode == APP_SCREENMODE_WINDOW )\n        {\n        WINDOWPLACEMENT placement;\n        placement.length = sizeof( placement );\n        GetWindowPlacement( app->hwnd, &placement );\n        return placement.rcNormalPosition.top;\n        }\n    else\n        {\n        return app->windowed_y;\n        }\n    }\n\n\napp_displays_t app_displays( app_t* app )\n    {\n    app_displays_t displays;\n    displays.count = app->display_count;\n    displays.displays = app->displays;\n    return displays;\n    }\n\n\nvoid app_present( app_t* app, APP_U32 const* pixels_xbgr, int width, int height, APP_U32 mod_xbgr, APP_U32 border_xbgr )\n    {\n    if( app->is_minimized ) return;\n    if( pixels_xbgr ) app_internal_opengl_present( &app->gl, pixels_xbgr, width, height, mod_xbgr, border_xbgr );\n    SwapBuffers( app->hdc );\n    }\n\n\nstatic void app_sound_write( app_t* app, int sample_pairs_offset, int sample_pairs_count )\n    {\n    int offset = sample_pairs_offset * 2 * ( 16 / 8 );\n    int length = sample_pairs_count * 2 * ( 16 / 8 );\n\n    // Obtain memory address of write block. This will be in two parts if the block wraps around.\n    LPVOID lpvPtr1;\n    DWORD dwBytes1;\n    LPVOID lpvPtr2;\n    DWORD dwBytes2;\n    HRESULT hr = IDirectSoundBuffer8_Lock( app->dsoundbuf, (DWORD) offset, (DWORD) length, &lpvPtr1, &dwBytes1,\n        &lpvPtr2, &dwBytes2, 0 );\n\n    // If DSERR_BUFFERLOST is returned, restore and retry lock.\n    if( hr == DSERR_BUFFERLOST )\n        {\n        IDirectSoundBuffer8_Restore( app->dsoundbuf );\n        hr = IDirectSoundBuffer8_Lock( app->dsoundbuf, (DWORD) offset, (DWORD) length, &lpvPtr1, &dwBytes1,\n            &lpvPtr2, &dwBytes2, 0 );\n        }\n    if( FAILED( hr) )\n        {\n        app_log( app, APP_LOG_LEVEL_WARNING, \"Couldn't lock sound buffer\" );\n        IDirectSound8_Release( app->dsound );\n        app->dsound = 0;\n        return;\n        }\n\n    // Write to pointers.\n    app->sound_callback( (APP_S16*) lpvPtr1, (int) dwBytes1 / ( 2 * ( 16 / 8 ) ), app->sound_user_data );\n    if( lpvPtr2 ) app->sound_callback( (APP_S16*) lpvPtr2, (int) dwBytes2 / ( 2 * ( 16 / 8 ) ), app->sound_user_data );\n\n    // Release the data back to DirectSound.\n    hr = IDirectSoundBuffer8_Unlock( app->dsoundbuf, lpvPtr1, dwBytes1, lpvPtr2, dwBytes2 );\n    if( FAILED( hr) )\n        {\n        app_log( app, APP_LOG_LEVEL_WARNING, \"Couldn't unlock sound buffer\" );\n        IDirectSound8_Release( app->dsound );\n        app->dsound = 0;\n        return;\n        }\n    }\n\n\nstatic DWORD WINAPI app_sound_thread_proc( LPVOID lpThreadParameter )\n    {\n    app_t* app = (app_t*) lpThreadParameter;\n    int mid_point = app->sample_pairs_count / 2;\n    int half_size = mid_point;\n    int prev_pos = 0;\n    while( InterlockedCompareExchange( &app->exit_sound_thread, 0, 0 ) == 0 )\n    {\n        WaitForMultipleObjectsEx( 2, app->sound_notifications, FALSE, 100, FALSE );\n        DWORD position = 0;\n        IDirectSoundBuffer8_GetCurrentPosition( app->dsoundbuf, &position, 0 );\n        int pos = ( (int) position )/( 2 * ( 16 / 8 ) );\n\n        if( prev_pos >= mid_point && pos < mid_point )\n            app_sound_write( app, mid_point, half_size );\n        else if( prev_pos < mid_point && pos >= mid_point )\n            app_sound_write( app, 0, half_size );\n\n        prev_pos = pos;\n        }\n\n    return 0;\n    }\n\n\nvoid app_sound( app_t* app, int sample_pairs_count, void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data ), void* user_data )\n    {\n    if( !app->dsound ) return;\n\n    if( !sound_callback || !sample_pairs_count )\n        {\n        if( app->sound_thread_handle != INVALID_HANDLE_VALUE )\n            {\n            InterlockedExchange( &app->exit_sound_thread, 1 );\n            WaitForSingleObject( app->sound_thread_handle, INFINITE );\n            CloseHandle( app->sound_thread_handle );\n            app->sound_thread_handle = INVALID_HANDLE_VALUE;\n            }\n        if( app->dsoundbuf )\n            {\n            IDirectSoundBuffer8_Release( app->dsoundbuf );\n            app->dsoundbuf = NULL;\n            }\n        app->sample_pairs_count = 0;\n        app->sound_callback = NULL;\n        app->sound_user_data = NULL;\n        return;\n        }\n\n    if( app->sample_pairs_count != sample_pairs_count )\n        {\n    app->sample_pairs_count = sample_pairs_count;\n\n    if( app->dsoundbuf )\n        {\n            IDirectSoundBuffer8_Release( app->dsoundbuf );\n        app->dsoundbuf = 0;\n        }\n\n    if( sample_pairs_count > 0 )\n        {\n        int const channels = 2;\n        int const frequency = 44100;\n        int const bits_per_sample = 16;\n\n        WORD const DSOUND_WAVE_FORMAT_PCM = 1;\n        DSOUND_WAVEFORMATEX format;\n        memset( &format, 0, sizeof( DSOUND_WAVEFORMATEX ) );\n        format.wFormatTag = DSOUND_WAVE_FORMAT_PCM;\n        format.nChannels = (WORD) channels;\n        format.nSamplesPerSec = (DWORD) frequency;\n        format.nBlockAlign = (WORD) ( ( channels * bits_per_sample ) / 8 );\n        format.nAvgBytesPerSec = (DWORD) ( frequency * format.nBlockAlign );\n        format.wBitsPerSample = (WORD) bits_per_sample;\n        format.cbSize = 0;\n\n        DSBUFFERDESC dsbdesc;\n        memset( &dsbdesc, 0, sizeof( DSBUFFERDESC ) );\n        dsbdesc.dwSize = sizeof( DSBUFFERDESC );\n\n            dsbdesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPOSITIONNOTIFY ;\n\n        int size = channels * ( bits_per_sample / 8 ) * sample_pairs_count;\n        dsbdesc.dwBufferBytes = (DWORD) size;\n        dsbdesc.lpwfxFormat = &format;\n\n            struct IDirectSoundBuffer8* soundbuf = NULL;\n            HRESULT hr = IDirectSound8_CreateSoundBuffer( app->dsound, &dsbdesc, &soundbuf, NULL );\n            if( FAILED( hr ) || !soundbuf )\n            {\n            app_log( app, APP_LOG_LEVEL_WARNING, \"Failed to create sound buffer\" );\n                IDirectSound8_Release( app->dsound );\n            app->dsound = 0;\n                app->sample_pairs_count = 0;\n                app->sound_callback = NULL;\n                app->sound_user_data = NULL;\n            return;\n            }\n\n            GUID const GUID_IDirectSoundBuffer8 = { 0x6825a449, 0x7524, 0x4d82, { 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e } };\n            #ifdef __cplusplus\n                GUID const& ref_GUID_IDirectSoundBuffer8 = GUID_IDirectSoundBuffer8;\n            #else\n                GUID const* ref_GUID_IDirectSoundBuffer8 = &GUID_IDirectSoundBuffer8;\n            #endif\n            hr = IDirectSoundBuffer8_QueryInterface( soundbuf, ref_GUID_IDirectSoundBuffer8, (void**) &app->dsoundbuf );\n            IDirectSoundBuffer8_Release( soundbuf );\n\n            if( FAILED( hr ) || !app->dsoundbuf )\n    {\n                app_log( app, APP_LOG_LEVEL_WARNING, \"Failed to create sound buffer\" );\n                IDirectSound8_Release( app->dsound );\n                app->dsound = 0;\n                app->sample_pairs_count = 0;\n                app->sound_callback = NULL;\n                app->sound_user_data = NULL;\n                return;\n    }\n\n            struct IDirectSoundNotify* notify = NULL;\n            GUID const GUID_IDirectSoundNotify8 = { 0xb0210783, 0x89cd, 0x11d0, { 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16 } };\n            #ifdef __cplusplus\n                GUID const& ref_GUID_IDirectSoundNotify8 = GUID_IDirectSoundNotify8;\n            #else\n                GUID const* ref_GUID_IDirectSoundNotify8 = &GUID_IDirectSoundNotify8;\n            #endif\n            hr = IDirectSoundBuffer8_QueryInterface( app->dsoundbuf, ref_GUID_IDirectSoundNotify8, (void**) &notify );\n            if( FAILED( hr ) || !notify )\n            {\n                app_log( app, APP_LOG_LEVEL_WARNING, \"Failed to create sound buffer\" );\n                IDirectSoundBuffer8_Release( app->dsoundbuf );\n                IDirectSound8_Release( app->dsound );\n                app->dsound = 0;\n                app->dsoundbuf = 0;\n                app->sample_pairs_count = 0;\n                app->sound_callback = NULL;\n                app->sound_user_data = NULL;\n                return;\n                }\n\n            DSBPOSITIONNOTIFY notify_positions[ 2 ];\n            notify_positions[ 0 ].dwOffset = 0;\n            notify_positions[ 0 ].hEventNotify = app->sound_notifications[ 0 ];\n            notify_positions[ 1 ].dwOffset = (DWORD)( size / 2 );\n            notify_positions[ 1 ].hEventNotify = app->sound_notifications[ 1 ];\n\n            IDirectSoundNotify_SetNotificationPositions( notify, 2, notify_positions );\n            IDirectSoundNotify_Release( notify );\n\n            InterlockedExchange( &app->exit_sound_thread, 0 );\n            app->sound_thread_handle = CreateThread( NULL, 0U, app_sound_thread_proc, app, 0, NULL );\n            SetThreadPriority( app->sound_thread_handle, THREAD_PRIORITY_HIGHEST );\n\n            IDirectSoundBuffer8_Play( app->dsoundbuf, 0, 0, DSBPLAY_LOOPING );\n        }\n        }\n\n    app->sound_callback = sound_callback;\n    app->sound_user_data = user_data;\n        }\n\n\nvoid app_sound_volume( app_t* app, float volume )\n    {\n    if( !app->dsound ) return;\n    if( !app->dsoundbuf ) return;\n\n    int level = volume < 0.000015f ? DSBVOLUME_MIN : (int) ( 2000.0f * (float) log10( (double ) volume ) );\n    if( app->sound_level == level ) return;\n    app->sound_level = level;\n\n    IDirectSoundBuffer8_SetVolume( app->dsoundbuf, level );\n    }\n\n\napp_input_t app_input( app_t* app )\n    {\n    app_input_t input;\n    input.events = app->input_events;\n    input.count = app->input_count;\n    app->input_count = 0;\n    return input;\n    }\n\n\nvoid app_coordinates_window_to_bitmap( app_t* app, int width, int height, int* x, int* y )\n    {\n    if( width == 0 || height == 0 ) return;\n    RECT r;\n    GetClientRect( app->hwnd, &r );\n    int window_width = ( app->screenmode == APP_SCREENMODE_FULLSCREEN ) ? app->fullscreen_width : r.right - r.left;\n    int window_height = ( app->screenmode == APP_SCREENMODE_FULLSCREEN ) ? app->fullscreen_height : r.bottom - r.top;\n\n\n    if( app->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = window_width / (float) width;\n        float vscale = window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n        if( pixel_scale > 0.0f )\n            {\n            float hborder = ( window_width - pixel_scale * width ) / 2.0f;\n            float vborder = ( window_height - pixel_scale * height ) / 2.0f;\n            *x -= (int)( hborder );\n            *y -= (int)( vborder );\n            *x = (int)( *x / pixel_scale );\n            *y = (int)( *y / pixel_scale );\n            }\n        else\n            {\n            *x = 0;\n            *y = 0;\n            }\n        }\n    else\n        {\n        int hscale = window_width / width;\n        int vscale = window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n        int hborder = ( window_width - pixel_scale * width ) / 2;\n        int vborder = ( window_height - pixel_scale * height ) / 2;\n        *x -= (int)( hborder );\n        *y -= (int)( vborder );\n        *x = (int)( *x / pixel_scale );\n        *y = (int)( *y / pixel_scale );\n        }\n    }\n\n\nvoid app_coordinates_bitmap_to_window( app_t* app, int width, int height, int* x, int* y )\n    {\n    RECT r;\n    GetClientRect( app->hwnd, &r );\n    int window_width = ( app->screenmode == APP_SCREENMODE_FULLSCREEN ) ? app->fullscreen_width : r.right - r.left;\n    int window_height = ( app->screenmode == APP_SCREENMODE_FULLSCREEN ) ? app->fullscreen_height : r.bottom - r.top;\n\n\n    if( app->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = window_width / (float) width;\n        float vscale = window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n        if( pixel_scale > 0.0f )\n            {\n            float hborder = ( window_width - pixel_scale * width ) / 2.0f;\n            float vborder = ( window_height - pixel_scale * height ) / 2.0f;\n            *x = (int)( *x * pixel_scale );\n            *y = (int)( *y * pixel_scale );\n            *x += (int)( hborder );\n            *y += (int)( vborder );\n            }\n        else\n            {\n            *x = 0;\n            *y = 0;\n            }\n        }\n    else\n        {\n        int hscale = window_width / width;\n        int vscale = window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n        int hborder = ( window_width - pixel_scale * width ) / 2;\n        int vborder = ( window_height - pixel_scale * height ) / 2;\n        *x = (int)( *x * pixel_scale );\n        *y = (int)( *y * pixel_scale );\n        *x += (int)( hborder );\n        *y += (int)( vborder );\n        }\n    }\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    SDL\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#elif defined( APP_SDL )\n\n#ifndef APP_MALLOC\n    #include <stdlib.h>\n    #if defined(__cplusplus)\n        #define APP_MALLOC( ctx, size ) ( ::malloc( size ) )\n        #define APP_FREE( ctx, ptr ) ( ::free( ptr ) )\n    #else\n        #define APP_MALLOC( ctx, size ) ( malloc( size ) )\n        #define APP_FREE( ctx, ptr ) ( free( ptr ) )\n    #endif\n#endif\n\n#include <string.h>\n#include <stdio.h>\n\n#include \"SDL.h\"\n\n#ifndef APP_FATAL_ERROR\n    #define APP_FATAL_ERROR( ctx, message ) { \\\n            SDL_ShowSimpleMessageBox( SDL_MESSAGEBOX_ERROR, \"Fatal Error!\", message, NULL ); exit( 0xff ); }\n#endif\n\nstruct app_t\n    {\n    void* memctx;\n    void* logctx;\n    void* fatalctx;\n    struct app_internal_opengl_t gl;\n    int initialized;\n    int exit_requested;\n    int has_focus;\n    app_interpolation_t interpolation;\n    app_screenmode_t screenmode;\n\n    SDL_Window* window;\n    SDL_Cursor* cursor;\n\n    SDL_AudioDeviceID sound_device;\n    void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data );\n    void* sound_user_data;\n    int volume;\n\n    app_input_event_t input_events[ 1024 ];\n    int input_count;\n\n    int display_count;\n    app_display_t displays[ 16 ];\n\n    };\n\n\nint app_run( int (*app_proc)( app_t*, void* ), void* user_data, void* memctx, void* logctx, void* fatalctx )\n    {\n    app_t* app = (app_t*) APP_MALLOC( memctx, sizeof( app_t ) );\n    memset( app, 0, (int)sizeof( app_t ) );\n    app->memctx = memctx;\n    app->logctx = logctx;\n    app->fatalctx = fatalctx;\n    app->interpolation = APP_INTERPOLATION_LINEAR;\n    app->screenmode = APP_SCREENMODE_FULLSCREEN;\n\n    int result = 0xff;\n    int display_count;\n    int glres;\n\n    if( SDL_Init( SDL_INIT_EVERYTHING ) < 0 )\n        {\n//        printf( \"SDL could not initialize! SDL_Error: %s\\n\", SDL_GetError() );\n        goto init_failed;\n        }\n\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);\n\n    app->window = SDL_CreateWindow( \"\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 400, SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_HIDDEN);\n    if( !app->window )\n    {\n//        printf( \"Window could not be created! SDL_Error: %s\\n\", SDL_GetError() );\n        goto init_failed;\n    }\n\n    app->has_focus = 1;\n    app->volume = 256;\n\n    display_count = SDL_GetNumVideoDisplays();\n    for( int i = 0; i < display_count; ++i )\n        {\n        SDL_Rect r;\n        SDL_GetDisplayBounds( i, &r );\n        app_display_t d;\n        sprintf( d.id, \"DISPLAY%d\", i );\n        d.x = r.x;\n        d.y = r.y;\n        d.width = r.w;\n        d.height = r.h;\n        app->displays[ i ] = d;\n        }\n    app->display_count = display_count;\n\n    SDL_GL_CreateContext( app->window );\n    glewInit();\n\n    SDL_GL_SetSwapInterval( 1 );\n\n    app->gl.CreateShader = glCreateShader;\n    app->gl.ShaderSource = glShaderSource;\n    app->gl.CompileShader = glCompileShader;\n    app->gl.GetShaderiv = glGetShaderiv;\n    app->gl.CreateProgram = glCreateProgram;\n    app->gl.AttachShader = glAttachShader;\n    app->gl.BindAttribLocation = glBindAttribLocation;\n    app->gl.LinkProgram = glLinkProgram;\n    app->gl.GetProgramiv = glGetProgramiv;\n    app->gl.GenBuffers = glGenBuffers;\n    app->gl.BindBuffer = glBindBuffer;\n    app->gl.EnableVertexAttribArray = glEnableVertexAttribArray;\n    app->gl.VertexAttribPointer = glVertexAttribPointer;\n    app->gl.GenTextures = glGenTextures;\n    app->gl.Enable = glEnable;\n    app->gl.ActiveTexture = glActiveTexture;\n    app->gl.BindTexture = glBindTexture;\n    app->gl.TexParameteri = glTexParameteri;\n    app->gl.DeleteBuffers = glDeleteBuffers;\n    app->gl.DeleteTextures = glDeleteTextures;\n    app->gl.BufferData = glBufferData;\n    app->gl.UseProgram = glUseProgram;\n    app->gl.Uniform1i = glUniform1i;\n    app->gl.Uniform3f = glUniform3f;\n    app->gl.GetUniformLocation = glGetUniformLocation;\n    app->gl.TexImage2D = glTexImage2D;\n    app->gl.ClearColor = glClearColor;\n    app->gl.Clear = glClear;\n    app->gl.DrawArrays = glDrawArrays;\n    app->gl.Viewport = glViewport;\n    app->gl.DeleteShader = glDeleteShader;\n    app->gl.DeleteProgram = glDeleteProgram;\n    #ifdef APP_REPORT_SHADER_ERRORS\n        app->gl.GetShaderInfoLog = glGetShaderInfoLog;\n    #endif\n\n    glres = app_internal_opengl_init( app, &app->gl, app->interpolation, 640, 400 );\n    if( !glres )\n        {\n        app_fatal_error( app, \"OpenGL init fail\" );\n        goto init_failed;\n        }\n\n    result = app_proc( app, user_data );\n\ninit_failed:\n    if( app->sound_device )\n        {\n        SDL_PauseAudioDevice( app->sound_device, 1 );\n        SDL_CloseAudioDevice( app->sound_device );\n        app->sound_device = 0;\n        app->sound_callback = NULL;\n        app->sound_user_data = NULL;\n        }\n\n    if( app->cursor ) SDL_FreeCursor( app->cursor );\n\n    //Destroy window\n    SDL_DestroyWindow( app->window );\n\n\n    //Quit SDL subsystems\n    SDL_Quit();\n\n    APP_FREE( memctx, app );\n    return result;\n    }\n\n\nstatic app_key_t app_internal_scancode_to_appkey( app_t* app, SDL_Scancode scancode )\n\n    {\n    int map[ 287 * 2 ] = { APP_KEY_INVALID, SDL_SCANCODE_UNKNOWN, APP_KEY_INVALID, 1, APP_KEY_INVALID, 2, APP_KEY_INVALID, 3, APP_KEY_A, SDL_SCANCODE_A,\n        APP_KEY_B, SDL_SCANCODE_B, APP_KEY_C, SDL_SCANCODE_C, APP_KEY_D, SDL_SCANCODE_D, APP_KEY_E, SDL_SCANCODE_E, APP_KEY_F, SDL_SCANCODE_F, APP_KEY_G,\n        SDL_SCANCODE_G, APP_KEY_H, SDL_SCANCODE_H, APP_KEY_I, SDL_SCANCODE_I, APP_KEY_J, SDL_SCANCODE_J, APP_KEY_K, SDL_SCANCODE_K, APP_KEY_L,\n        SDL_SCANCODE_L, APP_KEY_M, SDL_SCANCODE_M, APP_KEY_N, SDL_SCANCODE_N, APP_KEY_O, SDL_SCANCODE_O, APP_KEY_P, SDL_SCANCODE_P, APP_KEY_Q,\n        SDL_SCANCODE_Q, APP_KEY_R, SDL_SCANCODE_R, APP_KEY_S, SDL_SCANCODE_S, APP_KEY_T, SDL_SCANCODE_T, APP_KEY_U, SDL_SCANCODE_U, APP_KEY_V,\n        SDL_SCANCODE_V, APP_KEY_W, SDL_SCANCODE_W, APP_KEY_X, SDL_SCANCODE_X, APP_KEY_Y, SDL_SCANCODE_Y, APP_KEY_Z, SDL_SCANCODE_Z, APP_KEY_1,\n        SDL_SCANCODE_1, APP_KEY_2, SDL_SCANCODE_2, APP_KEY_3, SDL_SCANCODE_3, APP_KEY_4, SDL_SCANCODE_4, APP_KEY_5, SDL_SCANCODE_5, APP_KEY_6,\n        SDL_SCANCODE_6, APP_KEY_7, SDL_SCANCODE_7, APP_KEY_8, SDL_SCANCODE_8, APP_KEY_9, SDL_SCANCODE_9, APP_KEY_0, SDL_SCANCODE_0, APP_KEY_RETURN,\n        SDL_SCANCODE_RETURN, APP_KEY_ESCAPE, SDL_SCANCODE_ESCAPE, APP_KEY_BACK, SDL_SCANCODE_BACKSPACE, APP_KEY_TAB, SDL_SCANCODE_TAB, APP_KEY_SPACE,\n        SDL_SCANCODE_SPACE, APP_KEY_OEM_MINUS, SDL_SCANCODE_MINUS, APP_KEY_INVALID, SDL_SCANCODE_EQUALS, APP_KEY_OEM_4, SDL_SCANCODE_LEFTBRACKET,\n        APP_KEY_OEM_6, SDL_SCANCODE_RIGHTBRACKET, APP_KEY_OEM_5, SDL_SCANCODE_BACKSLASH, APP_KEY_INVALID, SDL_SCANCODE_NONUSHASH, APP_KEY_OEM_1,\n        SDL_SCANCODE_SEMICOLON, APP_KEY_OEM_7, SDL_SCANCODE_APOSTROPHE, APP_KEY_INVALID, SDL_SCANCODE_GRAVE, APP_KEY_OEM_COMMA, SDL_SCANCODE_COMMA,\n        APP_KEY_OEM_PERIOD, SDL_SCANCODE_PERIOD, APP_KEY_OEM_2, SDL_SCANCODE_SLASH, APP_KEY_CAPITAL, SDL_SCANCODE_CAPSLOCK, APP_KEY_F1, SDL_SCANCODE_F1,\n        APP_KEY_F2, SDL_SCANCODE_F2, APP_KEY_F3, SDL_SCANCODE_F3, APP_KEY_F4, SDL_SCANCODE_F4, APP_KEY_F5, SDL_SCANCODE_F5, APP_KEY_F6, SDL_SCANCODE_F6,\n        APP_KEY_F7, SDL_SCANCODE_F7, APP_KEY_F8, SDL_SCANCODE_F8, APP_KEY_F9, SDL_SCANCODE_F9, APP_KEY_F10, SDL_SCANCODE_F10, APP_KEY_F11,\n        SDL_SCANCODE_F11, APP_KEY_F12, SDL_SCANCODE_F12, APP_KEY_SNAPSHOT, SDL_SCANCODE_PRINTSCREEN, APP_KEY_SCROLL, SDL_SCANCODE_SCROLLLOCK,\n        APP_KEY_PAUSE, SDL_SCANCODE_PAUSE, APP_KEY_INSERT, SDL_SCANCODE_INSERT, APP_KEY_HOME, SDL_SCANCODE_HOME, APP_KEY_PRIOR, SDL_SCANCODE_PAGEUP,\n        APP_KEY_DELETE, SDL_SCANCODE_DELETE, APP_KEY_END, SDL_SCANCODE_END, APP_KEY_NEXT, SDL_SCANCODE_PAGEDOWN, APP_KEY_RIGHT, SDL_SCANCODE_RIGHT,\n        APP_KEY_LEFT, SDL_SCANCODE_LEFT, APP_KEY_DOWN, SDL_SCANCODE_DOWN, APP_KEY_UP, SDL_SCANCODE_UP, APP_KEY_NUMLOCK, SDL_SCANCODE_NUMLOCKCLEAR,\n        APP_KEY_DIVIDE, SDL_SCANCODE_KP_DIVIDE, APP_KEY_MULTIPLY, SDL_SCANCODE_KP_MULTIPLY, APP_KEY_SUBTRACT, SDL_SCANCODE_KP_MINUS, APP_KEY_ADD,\n        SDL_SCANCODE_KP_PLUS, APP_KEY_RETURN, SDL_SCANCODE_KP_ENTER, APP_KEY_NUMPAD1,SDL_SCANCODE_KP_1, APP_KEY_NUMPAD2,SDL_SCANCODE_KP_2, APP_KEY_NUMPAD3,\n        SDL_SCANCODE_KP_3, APP_KEY_NUMPAD4,SDL_SCANCODE_KP_4, APP_KEY_NUMPAD5,SDL_SCANCODE_KP_5, APP_KEY_NUMPAD6,SDL_SCANCODE_KP_6, APP_KEY_NUMPAD7,\n        SDL_SCANCODE_KP_7, APP_KEY_NUMPAD8,SDL_SCANCODE_KP_8, APP_KEY_NUMPAD9,SDL_SCANCODE_KP_9, APP_KEY_NUMPAD0,SDL_SCANCODE_KP_0, APP_KEY_DECIMAL,\n        SDL_SCANCODE_KP_PERIOD, APP_KEY_INVALID, SDL_SCANCODE_NONUSBACKSLASH, APP_KEY_APPS, SDL_SCANCODE_APPLICATION, APP_KEY_INVALID, SDL_SCANCODE_POWER,\n        APP_KEY_RETURN, SDL_SCANCODE_KP_EQUALS, APP_KEY_F13, SDL_SCANCODE_F13, APP_KEY_F14, SDL_SCANCODE_F14, APP_KEY_F15, SDL_SCANCODE_F15, APP_KEY_F16,\n        SDL_SCANCODE_F16, APP_KEY_F17, SDL_SCANCODE_F17, APP_KEY_F18, SDL_SCANCODE_F18, APP_KEY_F19, SDL_SCANCODE_F19, APP_KEY_F20, SDL_SCANCODE_F20,\n        APP_KEY_F21, SDL_SCANCODE_F21, APP_KEY_F22, SDL_SCANCODE_F22, APP_KEY_F23, SDL_SCANCODE_F23, APP_KEY_F24, SDL_SCANCODE_F24, APP_KEY_EXEC,\n        SDL_SCANCODE_EXECUTE, APP_KEY_HELP, SDL_SCANCODE_HELP, APP_KEY_MENU, SDL_SCANCODE_MENU, APP_KEY_SELECT, SDL_SCANCODE_SELECT, APP_KEY_MEDIA_STOP,\n        SDL_SCANCODE_STOP, APP_KEY_INVALID, SDL_SCANCODE_AGAIN, APP_KEY_INVALID, SDL_SCANCODE_UNDO, APP_KEY_INVALID, SDL_SCANCODE_CUT, APP_KEY_INVALID,\n        SDL_SCANCODE_COPY, APP_KEY_INVALID, SDL_SCANCODE_PASTE, APP_KEY_INVALID, SDL_SCANCODE_FIND, APP_KEY_VOLUME_MUTE, SDL_SCANCODE_MUTE,\n        APP_KEY_VOLUME_UP, SDL_SCANCODE_VOLUMEUP, APP_KEY_VOLUME_DOWN, SDL_SCANCODE_VOLUMEDOWN, APP_KEY_INVALID, 130, APP_KEY_INVALID, 131,\n        APP_KEY_INVALID, 132, APP_KEY_SEPARATOR, SDL_SCANCODE_KP_COMMA, APP_KEY_INVALID, SDL_SCANCODE_KP_EQUALSAS400, APP_KEY_INVALID,\n        SDL_SCANCODE_INTERNATIONAL1, APP_KEY_INVALID, SDL_SCANCODE_INTERNATIONAL2, APP_KEY_INVALID, SDL_SCANCODE_INTERNATIONAL3, APP_KEY_INVALID,\n        SDL_SCANCODE_INTERNATIONAL4, APP_KEY_INVALID, SDL_SCANCODE_INTERNATIONAL5, APP_KEY_INVALID, SDL_SCANCODE_INTERNATIONAL6, APP_KEY_INVALID,\n        SDL_SCANCODE_INTERNATIONAL7, APP_KEY_INVALID, SDL_SCANCODE_INTERNATIONAL8, APP_KEY_INVALID, SDL_SCANCODE_INTERNATIONAL9, APP_KEY_HANGUL,\n        SDL_SCANCODE_LANG1, APP_KEY_HANJA, SDL_SCANCODE_LANG2,  APP_KEY_INVALID, SDL_SCANCODE_LANG3, APP_KEY_INVALID, SDL_SCANCODE_LANG4, APP_KEY_INVALID,\n        SDL_SCANCODE_LANG5, APP_KEY_INVALID, SDL_SCANCODE_LANG6, APP_KEY_INVALID, SDL_SCANCODE_LANG7, APP_KEY_INVALID, SDL_SCANCODE_LANG8, APP_KEY_INVALID,\n        SDL_SCANCODE_LANG9, APP_KEY_INVALID, SDL_SCANCODE_ALTERASE, APP_KEY_INVALID, SDL_SCANCODE_SYSREQ, APP_KEY_CANCEL, SDL_SCANCODE_CANCEL, APP_KEY_CLEAR,\n        SDL_SCANCODE_CLEAR, APP_KEY_PRIOR, SDL_SCANCODE_PRIOR, APP_KEY_RETURN, SDL_SCANCODE_RETURN2, APP_KEY_OEM_COMMA, SDL_SCANCODE_SEPARATOR,\n        APP_KEY_INVALID, SDL_SCANCODE_OUT, APP_KEY_INVALID, SDL_SCANCODE_OPER, APP_KEY_INVALID, SDL_SCANCODE_CLEARAGAIN, APP_KEY_CRSEL, SDL_SCANCODE_CRSEL,\n        APP_KEY_EXSEL, SDL_SCANCODE_EXSEL, APP_KEY_INVALID, 165, APP_KEY_INVALID, 166, APP_KEY_INVALID, 167, APP_KEY_INVALID, 168, APP_KEY_INVALID, 169,\n        APP_KEY_INVALID, 170, APP_KEY_INVALID, 171, APP_KEY_INVALID, 172, APP_KEY_INVALID, 173, APP_KEY_INVALID, 174, APP_KEY_INVALID, 175, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_00, APP_KEY_INVALID, SDL_SCANCODE_KP_000, APP_KEY_INVALID, SDL_SCANCODE_THOUSANDSSEPARATOR, APP_KEY_INVALID,\n        SDL_SCANCODE_DECIMALSEPARATOR, APP_KEY_INVALID, SDL_SCANCODE_CURRENCYUNIT, APP_KEY_INVALID, SDL_SCANCODE_CURRENCYSUBUNIT, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_LEFTPAREN, APP_KEY_INVALID, SDL_SCANCODE_KP_RIGHTPAREN, APP_KEY_INVALID, SDL_SCANCODE_KP_LEFTBRACE, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_RIGHTBRACE, APP_KEY_INVALID, SDL_SCANCODE_KP_TAB, APP_KEY_INVALID, SDL_SCANCODE_KP_BACKSPACE, APP_KEY_INVALID, SDL_SCANCODE_KP_A,\n        APP_KEY_INVALID, SDL_SCANCODE_KP_B, APP_KEY_INVALID, SDL_SCANCODE_KP_C, APP_KEY_INVALID, SDL_SCANCODE_KP_D, APP_KEY_INVALID, SDL_SCANCODE_KP_E,\n        APP_KEY_INVALID, SDL_SCANCODE_KP_F, APP_KEY_INVALID, SDL_SCANCODE_KP_XOR, APP_KEY_INVALID, SDL_SCANCODE_KP_POWER, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_PERCENT, APP_KEY_INVALID, SDL_SCANCODE_KP_LESS, APP_KEY_INVALID, SDL_SCANCODE_KP_GREATER, APP_KEY_INVALID, SDL_SCANCODE_KP_AMPERSAND,\n        APP_KEY_INVALID, SDL_SCANCODE_KP_DBLAMPERSAND, APP_KEY_INVALID, SDL_SCANCODE_KP_VERTICALBAR, APP_KEY_INVALID, SDL_SCANCODE_KP_DBLVERTICALBAR,\n        APP_KEY_INVALID, SDL_SCANCODE_KP_COLON, APP_KEY_INVALID, SDL_SCANCODE_KP_HASH, APP_KEY_INVALID, SDL_SCANCODE_KP_SPACE, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_AT, APP_KEY_INVALID, SDL_SCANCODE_KP_EXCLAM, APP_KEY_INVALID, SDL_SCANCODE_KP_MEMSTORE, APP_KEY_INVALID, SDL_SCANCODE_KP_MEMRECALL,\n        APP_KEY_INVALID, SDL_SCANCODE_KP_MEMCLEAR, APP_KEY_INVALID, SDL_SCANCODE_KP_MEMADD, APP_KEY_INVALID, SDL_SCANCODE_KP_MEMSUBTRACT, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_MEMMULTIPLY, APP_KEY_INVALID, SDL_SCANCODE_KP_MEMDIVIDE, APP_KEY_INVALID, SDL_SCANCODE_KP_PLUSMINUS, APP_KEY_INVALID,\n        SDL_SCANCODE_KP_CLEAR, APP_KEY_INVALID, SDL_SCANCODE_KP_CLEARENTRY, APP_KEY_INVALID, SDL_SCANCODE_KP_BINARY, APP_KEY_INVALID, SDL_SCANCODE_KP_OCTAL,\n        APP_KEY_INVALID, SDL_SCANCODE_KP_DECIMAL, APP_KEY_INVALID, SDL_SCANCODE_KP_HEXADECIMAL, APP_KEY_INVALID, 222, APP_KEY_INVALID, 223, APP_KEY_LCONTROL,\n        SDL_SCANCODE_LCTRL, APP_KEY_LSHIFT, SDL_SCANCODE_LSHIFT, APP_KEY_LMENU, SDL_SCANCODE_LALT, APP_KEY_LWIN, SDL_SCANCODE_LGUI, APP_KEY_RCONTROL,\n        SDL_SCANCODE_RCTRL, APP_KEY_RSHIFT, SDL_SCANCODE_RSHIFT, APP_KEY_RMENU, SDL_SCANCODE_RALT, APP_KEY_RWIN, SDL_SCANCODE_RGUI, APP_KEY_INVALID, 232,\n        APP_KEY_INVALID, 233, APP_KEY_INVALID, 234, APP_KEY_INVALID, 235, APP_KEY_INVALID, 236, APP_KEY_INVALID, 237, APP_KEY_INVALID, 238, APP_KEY_INVALID,\n        239, APP_KEY_INVALID, 240, APP_KEY_INVALID, 241, APP_KEY_INVALID, 242, APP_KEY_INVALID, 243, APP_KEY_INVALID, 244, APP_KEY_INVALID, 245,\n        APP_KEY_INVALID, 246, APP_KEY_INVALID, 247, APP_KEY_INVALID, 248, APP_KEY_INVALID, 249, APP_KEY_INVALID, 250, APP_KEY_INVALID, 251, APP_KEY_INVALID,\n        252, APP_KEY_INVALID, 253, APP_KEY_INVALID, 254, APP_KEY_INVALID, 255, APP_KEY_INVALID, 256, APP_KEY_MODECHANGE, SDL_SCANCODE_MODE,\n        APP_KEY_MEDIA_NEXT_TRACK, SDL_SCANCODE_AUDIONEXT, APP_KEY_MEDIA_PREV_TRACK, SDL_SCANCODE_AUDIOPREV, APP_KEY_MEDIA_PLAY_PAUSE, SDL_SCANCODE_AUDIOSTOP,\n        APP_KEY_PLAY, SDL_SCANCODE_AUDIOPLAY, APP_KEY_VOLUME_MUTE, SDL_SCANCODE_AUDIOMUTE, APP_KEY_LAUNCH_MEDIA_SELECT, SDL_SCANCODE_MEDIASELECT,\n        APP_KEY_INVALID, SDL_SCANCODE_WWW, APP_KEY_LAUNCH_MAIL, SDL_SCANCODE_MAIL, APP_KEY_INVALID, SDL_SCANCODE_CALCULATOR, APP_KEY_INVALID,\n        SDL_SCANCODE_COMPUTER, APP_KEY_BROWSER_SEARCH, SDL_SCANCODE_AC_SEARCH, APP_KEY_BROWSER_HOME, SDL_SCANCODE_AC_HOME, APP_KEY_BROWSER_BACK,\n        SDL_SCANCODE_AC_BACK, APP_KEY_BROWSER_FORWARD, SDL_SCANCODE_AC_FORWARD, APP_KEY_BROWSER_STOP, SDL_SCANCODE_AC_STOP, APP_KEY_BROWSER_REFRESH,\n        SDL_SCANCODE_AC_REFRESH, APP_KEY_BROWSER_FAVORITES, SDL_SCANCODE_AC_BOOKMARKS, APP_KEY_INVALID, SDL_SCANCODE_BRIGHTNESSDOWN, APP_KEY_INVALID,\n        SDL_SCANCODE_BRIGHTNESSUP, APP_KEY_INVALID, SDL_SCANCODE_DISPLAYSWITCH, APP_KEY_INVALID, SDL_SCANCODE_KBDILLUMTOGGLE, APP_KEY_INVALID,\n        SDL_SCANCODE_KBDILLUMDOWN, APP_KEY_INVALID, SDL_SCANCODE_KBDILLUMUP, APP_KEY_INVALID, SDL_SCANCODE_EJECT, APP_KEY_SLEEP, SDL_SCANCODE_SLEEP,\n        APP_KEY_LAUNCH_APP1, SDL_SCANCODE_APP1, APP_KEY_LAUNCH_APP2, SDL_SCANCODE_APP2, APP_KEY_INVALID, SDL_SCANCODE_AUDIOREWIND, APP_KEY_INVALID,\n        SDL_SCANCODE_AUDIOFASTFORWARD, };\n\n    if( scancode < 0 || scancode >= sizeof( map ) / ( 2 * sizeof( *map ) ) ) return APP_KEY_INVALID;\n    if( map[ scancode * 2 + 1 ] != scancode )\n        {\n        app_log( app, APP_LOG_LEVEL_ERROR, \"Keymap definition error\" );\n        return APP_KEY_INVALID;\n        }\n    return (app_key_t) map[ scancode * 2 ];\n    }\n\n\nstatic void app_internal_add_input_event( app_t* app, app_input_event_t* event )\n    {\n    if( app->has_focus )\n        {\n        if( app->input_count < sizeof( app->input_events ) / sizeof( *app->input_events ) )\n            app->input_events[ app->input_count++ ] = *event;\n        }\n    }\n\n\napp_state_t app_yield( app_t* app )\n    {\n    if( !app->initialized )\n        {\n        app->initialized = 1;\n        if( app->screenmode == APP_SCREENMODE_FULLSCREEN ) SDL_SetWindowFullscreen( app->window, SDL_WINDOW_FULLSCREEN_DESKTOP );\n        SDL_ShowWindow( app->window );\n        int w = app->gl.window_width;\n        int h = app->gl.window_height;\n        SDL_GL_GetDrawableSize( app->window, &w, &h );\n        app_internal_opengl_resize( &app->gl, w, h );\n        }\n\n    SDL_Event e;\n    while( SDL_PollEvent( &e ) )\n        {\n        if( e.type == SDL_WINDOWEVENT )\n            {\n            if( e.window.event == SDL_WINDOWEVENT_SIZE_CHANGED )\n                {\n                int w = app->gl.window_width;\n                int h = app->gl.window_height;\n                SDL_GL_GetDrawableSize( app->window, &w, &h );\n                if( w != app->gl.window_width || h != app->gl.window_height )\n                    {\n                    app_internal_opengl_resize( &app->gl, w, h );\n                    }\n                }\n            else if( e.window.event == SDL_WINDOWEVENT_CLOSE )\n                {\n                app->exit_requested = 1;\n                }\n            else if( e.window.event == SDL_WINDOWEVENT_FOCUS_GAINED )\n                {\n                app->has_focus = 1;\n                }\n            else if( e.window.event == SDL_WINDOWEVENT_FOCUS_LOST )\n                {\n                app->has_focus = 0;\n                }\n            }\n        else if( e.type == SDL_KEYDOWN )\n            {\n            app_input_event_t input_event;\n            input_event.type = APP_INPUT_KEY_DOWN;\n            input_event.data.key = app_internal_scancode_to_appkey( app, e.key.keysym.scancode );\n            app_internal_add_input_event( app, &input_event );\n            }\n        else if( e.type == SDL_KEYUP )\n            {\n            app_input_event_t input_event;\n            input_event.type = APP_INPUT_KEY_UP;\n            input_event.data.key = app_internal_scancode_to_appkey( app, e.key.keysym.scancode );\n            app_internal_add_input_event( app, &input_event );\n            }\n        else if( e.type == SDL_TEXTINPUT )\n            {\n            app_input_event_t input_event;\n            char *c;\n            input_event.type = APP_INPUT_CHAR;\n            for ( c = e.text.text; *c; c++ )\n                {\n                input_event.data.char_code = *c;\n                app_internal_add_input_event( app, &input_event );\n                }\n            }\n        else if( e.type == SDL_MOUSEMOTION )\n            {\n            app_input_event_t input_event;\n            input_event.type = APP_INPUT_MOUSE_MOVE;\n            input_event.data.mouse_pos.x = e.motion.x;\n            input_event.data.mouse_pos.y = e.motion.y;\n            app_internal_add_input_event( app, &input_event );\n\n            input_event.type = APP_INPUT_MOUSE_DELTA;\n            input_event.data.mouse_pos.x = e.motion.xrel;\n            input_event.data.mouse_pos.y = e.motion.yrel;\n            app_internal_add_input_event( app, &input_event );\n            }\n        else if( e.type == SDL_MOUSEBUTTONDOWN )\n            {\n            app_input_event_t input_event;\n            input_event.type = APP_INPUT_KEY_DOWN;\n            if( e.button.button == SDL_BUTTON_LEFT )\n                input_event.data.key = APP_KEY_LBUTTON;\n            else if( e.button.button == SDL_BUTTON_RIGHT )\n                input_event.data.key = APP_KEY_RBUTTON;\n            else if( e.button.button == SDL_BUTTON_MIDDLE )\n                input_event.data.key = APP_KEY_MBUTTON;\n            else if( e.button.button == SDL_BUTTON_X1 )\n                input_event.data.key = APP_KEY_XBUTTON1;\n            else if( e.button.button == SDL_BUTTON_X2 )\n                input_event.data.key = APP_KEY_XBUTTON2;\n            app_internal_add_input_event( app, &input_event );\n            }\n        else if( e.type == SDL_MOUSEBUTTONUP )\n            {\n            app_input_event_t input_event;\n            input_event.type = APP_INPUT_KEY_UP;\n            if( e.button.button == SDL_BUTTON_LEFT )\n                input_event.data.key = APP_KEY_LBUTTON;\n            else if( e.button.button == SDL_BUTTON_RIGHT )\n                input_event.data.key = APP_KEY_RBUTTON;\n            else if( e.button.button == SDL_BUTTON_MIDDLE )\n                input_event.data.key = APP_KEY_MBUTTON;\n            else if( e.button.button == SDL_BUTTON_X1 )\n                input_event.data.key = APP_KEY_XBUTTON1;\n            else if( e.button.button == SDL_BUTTON_X2 )\n                input_event.data.key = APP_KEY_XBUTTON2;\n            app_internal_add_input_event( app, &input_event );\n            }\n        else if( e.type == SDL_MOUSEWHEEL )\n            {\n            float const microsoft_mouse_wheel_constant = 120.0f;\n            float wheel_delta = ( (float) e.wheel.y ) / microsoft_mouse_wheel_constant;\n            if( app->input_count > 0 && app->input_events[ app->input_count - 1 ].type == APP_INPUT_SCROLL_WHEEL )\n                {\n                app_input_event_t* event = &app->input_events[ app->input_count - 1 ];\n                event->data.wheel_delta += wheel_delta;\n                }\n            else\n                {\n                app_input_event_t input_event;\n                input_event.type = APP_INPUT_SCROLL_WHEEL;\n                input_event.data.wheel_delta = wheel_delta;\n                app_internal_add_input_event( app, &input_event );\n                }\n            }\n\n        }\n\n    return app->exit_requested ? APP_STATE_EXIT_REQUESTED : APP_STATE_NORMAL;\n    }\n\n\nvoid app_cancel_exit( app_t* app )\n    {\n    app->exit_requested = 0;\n    }\n\n\nvoid app_title( app_t* app, char const* title )\n    {\n    SDL_SetWindowTitle( app->window, title );\n    }\n\n\nchar const* app_cmdline( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\nchar const* app_filename( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\nchar const* app_userdata( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\nchar const* app_appdata( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\n\n\nAPP_U64 app_time_count( app_t* app )\n    {\n    return SDL_GetPerformanceCounter();\n    }\n\n\nAPP_U64 app_time_freq( app_t* app )\n    {\n    return SDL_GetPerformanceFrequency();\n    }\n\n\nvoid app_log( app_t* app, app_log_level_t level, char const* message ) { /* NOT IMPLEMENTED */ }\n\n\nvoid app_fatal_error( app_t* app, char const* message )\n    {\n    APP_FATAL_ERROR( app->fatalctx, message );\n    }\n\n\nvoid app_pointer( app_t* app, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y )\n    {\n    SDL_Surface* surf = SDL_CreateRGBSurfaceFrom( (void*)pixels_abgr, width, height, 32, 4 * width, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000 );\n    if( app->cursor ) SDL_FreeCursor( app->cursor );\n    app->cursor = SDL_CreateColorCursor( surf, hotspot_x, hotspot_y );\n    SDL_SetCursor( app->cursor );\n    SDL_FreeSurface( surf );\n    }\n\n\nvoid app_pointer_default( app_t* app, int* width, int* height, APP_U32* pixels_abgr, int* hotspot_x, int* hotspot_y ) { /* NOT IMPLEMENTED */ }\n\n\nvoid app_pointer_pos( app_t* app, int x, int y )\n    {\n    SDL_WarpMouseInWindow( app->window, x, y );\n    }\n\n\nint app_pointer_x( app_t* app )\n    {\n    int x = 0;\n    SDL_GetMouseState( &x, NULL );\n    return x;\n    }\n\n\nint app_pointer_y( app_t* app )\n    {\n    int y = 0;\n    SDL_GetMouseState( NULL, &y );\n    return y;\n    }\n\n\nvoid app_pointer_limit( app_t* app, int x, int y, int width, int height ) { /* NOT IMPLEMENTED */ }\nvoid app_pointer_limit_off( app_t* app ) { /* NOT IMPLEMENTED */ }\n\nvoid app_interpolation( app_t* app, app_interpolation_t interpolation )\n    {\n    if( interpolation == app->interpolation ) return;\n    app->interpolation = interpolation;\n\n    int mouse_x;\n    int mouse_y;\n    SDL_GetMouseState( &mouse_x, &mouse_y );\n\n    app_input_event_t input_event;\n    input_event.type = APP_INPUT_MOUSE_MOVE;\n    input_event.data.mouse_pos.x = mouse_x;\n    input_event.data.mouse_pos.y = mouse_y;\n    app_internal_add_input_event( app, &input_event );\n\n    app_internal_opengl_interpolation( &app->gl, interpolation );\n    }\n\n\nvoid app_screenmode( app_t* app, app_screenmode_t screenmode )\n    {\n    if( screenmode != app->screenmode )\n        {\n        app->screenmode = screenmode;\n        SDL_SetWindowFullscreen( app->window,\n            screenmode == APP_SCREENMODE_FULLSCREEN ? SDL_WINDOW_FULLSCREEN_DESKTOP  : 0 );\n        }\n    }\n\n\nvoid app_window_size( app_t* app, int width, int height )\n    {\n    SDL_SetWindowSize( app->window, width, height );\n    }\n\n\nint app_window_width( app_t* app )\n    {\n    int width = 0;\n    SDL_GetWindowSize( app->window, &width, NULL );\n    return width;\n    }\n\n\nint app_window_height( app_t* app )\n    {\n    int height = 0;\n    SDL_GetWindowSize( app->window, NULL, &height );\n    return height;\n    }\n\n\nvoid app_window_pos( app_t* app, int x, int y )\n    {\n    SDL_SetWindowPosition( app->window, x, y );\n    }\n\n\nint app_window_x( app_t* app )\n    {\n    int x = 0;\n    SDL_GetWindowPosition( app->window, &x, NULL );\n    return x;\n    }\n\n\nint app_window_y( app_t* app )\n    {\n    int y = 0;\n    SDL_GetWindowPosition( app->window, NULL, &y );\n    return y;\n    }\n\n\napp_displays_t app_displays( app_t* app )\n    {\n    app_displays_t displays;\n    displays.count = app->display_count;\n    displays.displays = app->displays;\n    return displays;\n    }\n\n\nvoid app_present( app_t* app, APP_U32 const* pixels_xbgr, int width, int height, APP_U32 mod_xbgr, APP_U32 border_xbgr )\n    {\n    if( pixels_xbgr ) app_internal_opengl_present( &app->gl, pixels_xbgr, width, height, mod_xbgr, border_xbgr );\n    SDL_GL_SwapWindow( app->window );\n    }\n\n\nstatic void app_internal_sdl_sound_callback( void* userdata, Uint8* stream, int len )\n    {\n    app_t* app = (app_t*) userdata;\n    if( app->sound_callback )\n        {\n        app->sound_callback( (APP_S16*) stream, len / ( 2 * sizeof( APP_S16 ) ), app->sound_user_data );\n        if( app->volume < 256 )\n            {\n            APP_S16* samples = (APP_S16*) stream;\n            for( int i = 0; i < len / sizeof( APP_S16 ); ++i )\n                {\n                int s = (int)(*samples);\n                s = ( s * app->volume ) >> 8;\n                *samples++ = (APP_S16) s;\n                }\n            }\n        }\n    }\n\n\nvoid app_sound( app_t* app, int sample_pairs_count, void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data ), void* user_data )\n    {\n    if( app->sound_device )\n        {\n        SDL_PauseAudioDevice( app->sound_device, 1 );\n        SDL_CloseAudioDevice( app->sound_device );\n        app->sound_callback = NULL;\n        app->sound_user_data = NULL;\n        app->sound_device = 0;\n        }\n    if( sample_pairs_count > 0 && sound_callback )\n        {\n        SDL_AudioSpec spec;\n        spec.freq = 44100;\n        spec.format = AUDIO_S16;\n        spec.channels = 2;\n        spec.silence = 0;\n        spec.samples = sample_pairs_count * 2;\n        spec.padding = 0;\n        spec.size = 0;\n        spec.callback = app_internal_sdl_sound_callback;\n        spec.userdata = app;\n\n        app->sound_device = SDL_OpenAudioDevice( NULL, 0, &spec, NULL, 0 );\n        if( !app->sound_device ) return;\n\n        app->sound_callback = sound_callback;\n        app->sound_user_data = user_data;\n        SDL_PauseAudioDevice( app->sound_device, 0 );\n        }\n    }\n\n\nvoid app_sound_volume( app_t* app, float volume )\n    {\n    int v = (int) ( volume * 256.0f );\n    app->volume = v < 0 ? 0 : v > 256 ? 256 : v;\n    }\n\n\napp_input_t app_input( app_t* app )\n    {\n    app_input_t input;\n    input.events = app->input_events;\n    input.count = app->input_count;\n    app->input_count = 0;\n    return input;\n    }\n\n\nvoid app_coordinates_window_to_bitmap( app_t* app, int width, int height, int* x, int* y )\n    {\n    if( width == 0 || height == 0 ) return;\n    int window_width;\n    int window_height;\n    SDL_GL_GetDrawableSize( app->window, &window_width, &window_height );\n\n\n    if( app->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = window_width / (float) width;\n        float vscale = window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n        if( pixel_scale > 0.0f )\n            {\n            float hborder = ( window_width - pixel_scale * width ) / 2.0f;\n            float vborder = ( window_height - pixel_scale * height ) / 2.0f;\n            *x -= (int)( hborder );\n            *y -= (int)( vborder );\n            *x = (int)( *x / pixel_scale );\n            *y = (int)( *y / pixel_scale );\n            }\n        else\n            {\n            *x = 0;\n            *y = 0;\n            }\n        }\n    else\n        {\n        int hscale = window_width / width;\n        int vscale = window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n        int hborder = ( window_width - pixel_scale * width ) / 2;\n        int vborder = ( window_height - pixel_scale * height ) / 2;\n        *x -= (int)( hborder );\n        *y -= (int)( vborder );\n        *x = (int)( *x / pixel_scale );\n        *y = (int)( *y / pixel_scale );\n        }\n    }\n\n\nvoid app_coordinates_bitmap_to_window( app_t* app, int width, int height, int* x, int* y )\n    {\n    int window_width;\n    int window_height;\n    SDL_GL_GetDrawableSize( app->window, &window_width, &window_height );\n\n    if( app->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = window_width / (float) width;\n        float vscale = window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n        if( pixel_scale > 0.0f )\n            {\n            float hborder = ( window_width - pixel_scale * width ) / 2.0f;\n            float vborder = ( window_height - pixel_scale * height ) / 2.0f;\n            *x = (int)( *x * pixel_scale );\n            *y = (int)( *y * pixel_scale );\n            *x += (int)( hborder );\n            *y += (int)( vborder );\n            }\n        else\n            {\n            *x = 0;\n            *y = 0;\n            }\n        }\n    else\n        {\n        int hscale = window_width / width;\n        int vscale = window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n        int hborder = ( window_width - pixel_scale * width ) / 2;\n        int vborder = ( window_height - pixel_scale * height ) / 2;\n        *x = (int)( *x * pixel_scale );\n        *y = (int)( *y * pixel_scale );\n        *x += (int)( hborder );\n        *y += (int)( vborder );\n        }\n    }\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    WEBASSEMBLY\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#elif defined( APP_WASM )\n\n#ifndef APP_MALLOC\n    #include <stdlib.h>\n    #if defined(__cplusplus)\n        #define APP_MALLOC( ctx, size ) ( ::malloc( size ) )\n        #define APP_FREE( ctx, ptr ) ( ::free( ptr ) )\n    #else\n        #define APP_MALLOC( ctx, size ) ( malloc( size ) )\n        #define APP_FREE( ctx, ptr ) ( free( ptr ) )\n    #endif\n#endif\n\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n\nWAJIC(void, app_js_print, (const char* msg),\n    {\n    WA.print(MStrGet(msg) + \"\\n\");\n    })\n\n#ifndef APP_FATAL_ERROR\n    #define APP_FATAL_ERROR( ctx, message ) { app_js_print(message); abort(); }\n#endif\n\nstruct app_t\n    {\n    void* memctx;\n    void* logctx;\n    void* fatalctx;\n    struct app_internal_opengl_t gl;\n    int has_focus;\n    app_interpolation_t interpolation;\n\n    void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data );\n    void* sound_user_data;\n    int sound_buffer_size;\n    APP_S16* sound_buffer;\n    int volume;\n\n    app_input_event_t input_events[ 1024 ];\n    int input_count;\n    int pointer_x;\n    int pointer_y;\n    };\n\n\n// The javascript event handling keeps a simple buffer of events with 3 ints per event\n// The first int is the event id, followed by two arguments (not all events use both arguments)\n//   EVENT ID                  ARG 1           ARG 2\n//   1 WINDOW_SIZE_CHANGED     w               h\n//   2 WINDOW_FOCUS            gained/lost\n//   3 KEY                     down/up         scancode\n//   4 CHAR                    charcode\n//   5 MOUSE_MOTION            x               y\n//   6 MOUSE_BUTTON            down/up         buttonnum\n//   7 MOUSE_WHEEL             wheel\n\nWAJIC_WITH_INIT(\n(\n    var evts = [], evtcursor = 0, dpr = window.devicePixelRatio||1, canvas, aspect_ratio, fullscreen;\n    var update_canvas_size = (w)=>\n    {\n        var h = (w *= dpr)/aspect_ratio|0;\n        if (w<32 || h<32 || (w == canvas.width && h == canvas.height) || fullscreen) return;\n        canvas.width = w;\n        canvas.height = h;\n        evts.push(1, canvas.width, canvas.height);\n    };\n    var alias = (el, a, b, c)=>\n    {\n        return el[a+c] || el['moz'+b+c] || el['webkit'+b+c] || el['ms'+b+c];\n    };\n),\nvoid, app_js_setup_canvas, (int* out_width, int* out_height),\n{\n    canvas = WA.canvas;\n    if (!canvas.height) { canvas.width = 1024; canvas.height = 576; }\n    MU32[out_width>>2] = canvas.clientWidth;\n    MU32[out_height>>2] = canvas.clientHeight;\n    aspect_ratio = canvas.width/canvas.height;\n\n    var cancelEvent = (e)=>{ if (e.preventDefault) e.preventDefault(true); else if (e.stopPropagation) e.stopPropagation(true); else e.stopped = true; };\n    var documtEvent = (t, f, a)=>{ document.addEventListener(t, f); if (!a) { documtEvent('moz'+t, f, 1); documtEvent('webkit'+t, f, 1); documtEvent('ms'+t, f, 1); } };\n    var windowEvent = (t, f)=>{ window.addEventListener(t, f, true); };\n    var canvasEvent = (t, f)=>{ canvas.addEventListener(t, f, {capture:true,passive:false}); };\n    windowEvent('resize', ()=>{ update_canvas_size(canvas.clientWidth); });\n    windowEvent('focus', ()=>{ evts.push(2, 1, 0); });\n    windowEvent('blur',  ()=>{ evts.push(2, (fullscreen?1:0), 0); });\n    windowEvent('keydown', (e)=>\n    {\n        evts.push(3, 1, e.keyCode);\n        if (e.key.length == 1 && e.key.charCodeAt() < 128 && !e.ctrlKey) evts.push(4, e.key.charCodeAt(), 0);\n        cancelEvent(e);\n    });\n    windowEvent('keyup',   (e)=>\n    {\n        evts.push(3, 0, e.keyCode);\n        cancelEvent(e);\n    });\n    canvasEvent('mousemove', (e)=>\n    {\n        evts.push(5,\n            (e.offsetX * canvas.width /  canvas.clientWidth )|0,\n            (e.offsetY * canvas.height / canvas.clientHeight)|0);\n        cancelEvent(e);\n    });\n    var buttons = 0;\n    canvasEvent('mousedown', (e)=>\n    {\n        var btn = (1<<e.button);\n        if (buttons & btn) return;\n        buttons |= btn;\n        evts.push(6, 1, e.button);\n        cancelEvent(e);\n    });\n    windowEvent('mouseup', (e)=>\n    {\n        var btn = (1<<e.button);\n        if (!(buttons & btn)) return;\n        buttons &= ~btn;\n        evts.push(6, 0, e.button);\n        cancelEvent(e);\n    });\n    canvasEvent('wheel', (e)=>{ evts.push(7, e.deltaY); cancelEvent(e); });\n    documtEvent('fullscreenchange', ()=>\n    {\n        fullscreen = alias(document,'f','F','ullscreenElement') || alias(document,'f','F','ullScreenElement');\n        if (fullscreen)\n        {\n            canvas.orgS = canvas.style.cssText;\n            canvas.orgW = canvas.clientWidth;\n            canvas.style.cssText = 'background:black';\n            canvas.height = screen.height * dpr;\n            canvas.width = screen.width * dpr;\n            evts.push(1, canvas.width, canvas.height);\n        }\n        else if (canvas.orgS)\n        {\n            canvas.style.cssText = canvas.orgS;\n            update_canvas_size(canvas.orgW);\n        }\n    });\n    WA.SetFullscreen = (f)=>\n    {\n        if (!f == !fullscreen) return;\n        var el = (f ? WA.canvas : document);\n        var fn = (f ? (alias(el,'r','R','equestFullscreen') || alias(el,'r','R','equestFullScreen')) : (alias(el,'e','E','xitFullscreen') || alias(el,'c','C','ancelFullScreen')));\n        if (fn) fn.apply(el, []);\n    };\n})\n\nWAJIC(void, app_js_screenmode, (int fullscreen),\n{\n    WA.SetFullscreen(fullscreen);\n})\n\nWAJIC(void, app_js_set_aspect_ratio, (int* width, int* height),\n{\n    var new_aspect_ratio = MU32[width>>2]/MU32[height>>2];\n    if (Math.abs(new_aspect_ratio - aspect_ratio) > 0.01)\n    {\n        aspect_ratio = new_aspect_ratio;\n        update_canvas_size(canvas.clientWidth);\n    }\n    MU32[width>>2] = canvas.width;\n    MU32[height>>2] = canvas.height;\n})\n\nWAJIC(int, app_js_get_event, (int evt[3]),\n{\n    if (evtcursor >= evts.length)\n    {\n        evts.length = evtcursor = 0;\n        return 0;\n    }\n    MU32[(evt>>2)+0] = evts[evtcursor++];\n    MU32[(evt>>2)+1] = evts[evtcursor++];\n    MU32[(evt>>2)+2] = evts[evtcursor++];\n    return 1;\n})\n\n\nint app_run( int (*app_proc)( app_t*, void* ), void* user_data, void* memctx, void* logctx, void* fatalctx )\n    {\n    app_t* app = (app_t*) APP_MALLOC( memctx, sizeof( app_t ) );\n    memset( app, 0, (int)sizeof( app_t ) );\n    app->memctx = memctx;\n    app->logctx = logctx;\n    app->fatalctx = fatalctx;\n    app->interpolation = APP_INTERPOLATION_LINEAR;\n\n    app->gl.CreateShader = glCreateShader;\n    app->gl.ShaderSource = glShaderSource;\n    app->gl.CompileShader = glCompileShader;\n    app->gl.GetShaderiv = glGetShaderiv;\n    app->gl.CreateProgram = glCreateProgram;\n    app->gl.AttachShader = glAttachShader;\n    app->gl.BindAttribLocation = glBindAttribLocation;\n    app->gl.LinkProgram = glLinkProgram;\n    app->gl.GetProgramiv = glGetProgramiv;\n    app->gl.GenBuffers = glGenBuffers;\n    app->gl.BindBuffer = glBindBuffer;\n    app->gl.EnableVertexAttribArray = glEnableVertexAttribArray;\n    app->gl.VertexAttribPointer = glVertexAttribPointer;\n    app->gl.GenTextures = glGenTextures;\n    app->gl.Enable = glEnable;\n    app->gl.ActiveTexture = glActiveTexture;\n    app->gl.BindTexture = glBindTexture;\n    app->gl.TexParameteri = glTexParameteri;\n    app->gl.DeleteBuffers = glDeleteBuffers;\n    app->gl.DeleteTextures = glDeleteTextures;\n    app->gl.BufferData = glBufferData;\n    app->gl.UseProgram = glUseProgram;\n    app->gl.Uniform1i = glUniform1i;\n    app->gl.Uniform3f = glUniform3f;\n    app->gl.GetUniformLocation = glGetUniformLocation;\n    app->gl.TexImage2D = glTexImage2D;\n    app->gl.ClearColor = glClearColor;\n    app->gl.Clear = glClear;\n    app->gl.DrawArrays = glDrawArrays;\n    app->gl.Viewport = glViewport;\n    app->gl.DeleteShader = glDeleteShader;\n    app->gl.DeleteProgram = glDeleteProgram;\n    #ifdef APP_REPORT_SHADER_ERRORS\n        app->gl.GetShaderInfoLog = glGetShaderInfoLog;\n    #endif\n\n    int result = 0xff;\n\n    app_js_setup_canvas( &app->gl.window_width, &app->gl.window_height );\n    glSetupCanvasContext( 1, 0, 0, 0 );\n    glViewport( 0, 0, app->gl.window_width, app->gl.window_height );\n\n    app->has_focus = 1;\n    app->volume = 256;\n\n    int glres = app_internal_opengl_init( app, &app->gl, app->interpolation, app->gl.window_width, app->gl.window_height );\n    if( !glres )\n        {\n        app_fatal_error( app, \"OpenGL init fail\" );\n        goto init_failed;\n        }\n    WaCoroInitNew( NULL, NULL, NULL, 0 );\n    result = app_proc( app, user_data );\n\ninit_failed:\n\n    APP_FREE( memctx, app );\n    return result;\n    }\n\n\nstatic void app_internal_add_input_event( app_t* app, app_input_event_t* event )\n    {\n    if( app->has_focus )\n        {\n        if( app->input_count < sizeof( app->input_events ) / sizeof( *app->input_events ) )\n            app->input_events[ app->input_count++ ] = *event;\n        }\n    }\n\n\nstatic app_key_t app_internal_scancode_to_appkey( app_t* app, int scancode )\n    {\n    static const app_key_t map[] = {\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_CANCEL,      APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_HELP,         APP_KEY_INVALID,         APP_KEY_BACK,            APP_KEY_TAB,\n        APP_KEY_RETURN,         APP_KEY_INVALID,             APP_KEY_CLEAR,        APP_KEY_RETURN,      APP_KEY_RETURN,      APP_KEY_INVALID,   APP_KEY_LSHIFT,       APP_KEY_LCONTROL,        APP_KEY_LMENU,           APP_KEY_PAUSE,\n        APP_KEY_CAPITAL,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_HANJA,     APP_KEY_INVALID,      APP_KEY_ESCAPE,          APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_MODECHANGE,          APP_KEY_SPACE,        APP_KEY_PRIOR,       APP_KEY_NEXT,        APP_KEY_END,       APP_KEY_HOME,         APP_KEY_LEFT,            APP_KEY_UP,              APP_KEY_RIGHT,\n        APP_KEY_DOWN,           APP_KEY_SELECT,              APP_KEY_SNAPSHOT,     APP_KEY_EXEC,        APP_KEY_SNAPSHOT,    APP_KEY_INSERT,    APP_KEY_DELETE,       APP_KEY_HELP,            APP_KEY_0,               APP_KEY_1,\n        APP_KEY_2,              APP_KEY_3,                   APP_KEY_4,            APP_KEY_5,           APP_KEY_6,           APP_KEY_7,         APP_KEY_8,            APP_KEY_9,               APP_KEY_INVALID,         APP_KEY_OEM_1,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_A,         APP_KEY_B,            APP_KEY_C,               APP_KEY_D,               APP_KEY_E,\n        APP_KEY_F,              APP_KEY_G,                   APP_KEY_H,            APP_KEY_I,           APP_KEY_J,           APP_KEY_K,         APP_KEY_L,            APP_KEY_M,               APP_KEY_N,               APP_KEY_O,\n        APP_KEY_P,              APP_KEY_Q,                   APP_KEY_R,            APP_KEY_S,           APP_KEY_T,           APP_KEY_U,         APP_KEY_V,            APP_KEY_W,               APP_KEY_X,               APP_KEY_Y,\n        APP_KEY_Z,              APP_KEY_LWIN,                APP_KEY_RWIN,         APP_KEY_APPS,        APP_KEY_INVALID,     APP_KEY_SLEEP,     APP_KEY_NUMPAD0,      APP_KEY_NUMPAD1,         APP_KEY_NUMPAD2,         APP_KEY_NUMPAD3,\n        APP_KEY_NUMPAD4,        APP_KEY_NUMPAD5,             APP_KEY_NUMPAD6,      APP_KEY_NUMPAD7,     APP_KEY_NUMPAD8,     APP_KEY_NUMPAD9,   APP_KEY_MULTIPLY,     APP_KEY_ADD,             APP_KEY_OEM_COMMA,       APP_KEY_SUBTRACT,\n        APP_KEY_INVALID,        APP_KEY_DIVIDE,              APP_KEY_F1,           APP_KEY_F2,          APP_KEY_F3,          APP_KEY_F4,        APP_KEY_F5,           APP_KEY_F6,              APP_KEY_F7,              APP_KEY_F8,\n        APP_KEY_F9,             APP_KEY_F10,                 APP_KEY_F11,          APP_KEY_F12,         APP_KEY_F13,         APP_KEY_F14,       APP_KEY_F15,          APP_KEY_F16,             APP_KEY_F17,             APP_KEY_F18,\n        APP_KEY_F19,            APP_KEY_F20,                 APP_KEY_F21,          APP_KEY_F22,         APP_KEY_F23,         APP_KEY_F24,       APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_NUMLOCK,     APP_KEY_SCROLL,    APP_KEY_RETURN,       APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_LSHIFT,         APP_KEY_RSHIFT,              APP_KEY_LCONTROL,     APP_KEY_RCONTROL,    APP_KEY_LMENU,       APP_KEY_RMENU,     APP_KEY_BROWSER_BACK, APP_KEY_BROWSER_FORWARD, APP_KEY_BROWSER_REFRESH, APP_KEY_BROWSER_STOP,\n        APP_KEY_BROWSER_SEARCH, APP_KEY_BROWSER_FAVORITES,   APP_KEY_BROWSER_HOME, APP_KEY_VOLUME_MUTE, APP_KEY_VOLUME_DOWN, APP_KEY_VOLUME_UP, APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_RETURN,          APP_KEY_INVALID,\n        APP_KEY_LAUNCH_MAIL,    APP_KEY_LAUNCH_MEDIA_SELECT, APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_OEM_1,        APP_KEY_INVALID,         APP_KEY_OEM_COMMA,       APP_KEY_OEM_MINUS,\n        APP_KEY_OEM_PERIOD,     APP_KEY_OEM_2,               APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_OEM_4,\n        APP_KEY_OEM_5,          APP_KEY_OEM_6,               APP_KEY_OEM_7,        APP_KEY_INVALID,     APP_KEY_LWIN,        APP_KEY_RMENU,     APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_INVALID,     APP_KEY_INVALID,   APP_KEY_INVALID,      APP_KEY_INVALID,         APP_KEY_INVALID,         APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_HANGUL,      APP_KEY_INVALID,   APP_KEY_INVALID,      APP_KEY_CRSEL,           APP_KEY_EXSEL,           APP_KEY_INVALID,\n        APP_KEY_INVALID,        APP_KEY_INVALID,             APP_KEY_INVALID,      APP_KEY_INVALID,     APP_KEY_CLEAR,       APP_KEY_INVALID, };\n\n    if( scancode < 0 || scancode >= sizeof( map ) / sizeof( *map ) ) return APP_KEY_INVALID;\n    return (app_key_t) map[ scancode ];\n    }\n\n\napp_state_t app_yield( app_t* app )\n    {\n    int evt[3];\n    app_input_event_t input_event;\n    app_key_t key;\n    while (app_js_get_event( evt ))\n    {\n        switch (evt[0])\n            {\n            //         EVENT ID                ARG 1           ARG 2\n            case 1: // WINDOW_SIZE_CHANGED     w               h\n                if( evt[1] != app->gl.window_width || evt[2] != app->gl.window_height )\n                    {\n                    app_internal_opengl_resize( &app->gl, evt[1], evt[2] );\n                    }\n                break;\n            case 2: // WINDOW_FOCUS            gained/lost\n                app->has_focus = evt[1];\n                break;\n            case 3: // KEY                     down/up         scancode\n                input_event.type = (evt[1] ? APP_INPUT_KEY_DOWN : APP_INPUT_KEY_UP);\n                key = app_internal_scancode_to_appkey( app, evt[2] );\n                if( key == APP_KEY_LCONTROL || key == APP_KEY_RCONTROL )\n                    {\n                    input_event.data.key = APP_KEY_CONTROL;\n                    app_internal_add_input_event( app, &input_event );\n                    }\n                else if( key == APP_KEY_LSHIFT || key == APP_KEY_RSHIFT )\n                    {\n                    input_event.data.key = APP_KEY_SHIFT;\n                    app_internal_add_input_event( app, &input_event );\n                    }\n                else if( key == APP_KEY_LMENU || key == APP_KEY_RMENU )\n                    {\n                    input_event.data.key = APP_KEY_MENU;\n                    app_internal_add_input_event( app, &input_event );\n                    }\n                input_event.data.key = key;\n                app_internal_add_input_event( app, &input_event );\n                break;\n            case 4: // CHAR                    charcode\n                input_event.type = APP_INPUT_CHAR;\n                input_event.data.char_code = (char) evt[1];\n                app_internal_add_input_event( app, &input_event );\n                break;\n            case 5: // MOUSE_MOTION            x               y\n                input_event.type = APP_INPUT_MOUSE_MOVE;\n                app->pointer_x = input_event.data.mouse_pos.x = evt[1];\n                app->pointer_y = input_event.data.mouse_pos.y = evt[2];\n                app_internal_add_input_event( app, &input_event );\n                break;\n            case 6: // MOUSE_BUTTON            down/up         buttonnum\n                input_event.type = (evt[1] ? APP_INPUT_KEY_DOWN : APP_INPUT_KEY_UP);\n                if( evt[2] == 0 )\n                    input_event.data.key = APP_KEY_LBUTTON;\n                else if( evt[2] == 1 )\n                    input_event.data.key = APP_KEY_RBUTTON;\n                else if( evt[2] == 2 )\n                    input_event.data.key = APP_KEY_MBUTTON;\n                else if( evt[2] == 3 )\n                    input_event.data.key = APP_KEY_XBUTTON1;\n                else if( evt[2] == 4 )\n                    input_event.data.key = APP_KEY_XBUTTON2;\n                else\n                    break;\n                app_internal_add_input_event( app, &input_event );\n                break;\n            case 7: // MOUSE_WHEEL             wheel\n                {\n                float const microsoft_mouse_wheel_constant = 120.0f;\n                float wheel_delta = ( (float) evt[1] ) / microsoft_mouse_wheel_constant;\n                if( app->input_count > 0 && app->input_events[ app->input_count - 1 ].type == APP_INPUT_SCROLL_WHEEL )\n                    {\n                    app_input_event_t* event = &app->input_events[ app->input_count - 1 ];\n                    event->data.wheel_delta += wheel_delta;\n                    }\n                else\n                    {\n                    input_event.type = APP_INPUT_SCROLL_WHEEL;\n                    input_event.data.wheel_delta = wheel_delta;\n                    app_internal_add_input_event( app, &input_event );\n                    }\n                } break;\n        }\n    }\n    return APP_STATE_NORMAL;\n    }\n\n\nvoid app_cancel_exit( app_t* app ) { /* NOT IMPLEMENTED */ }\nvoid app_title( app_t* app, char const* title ) { /* NOT IMPLEMENTED */ }\nchar const* app_cmdline( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\nchar const* app_filename( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\nchar const* app_userdata( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\nchar const* app_appdata( app_t* app ) { /* NOT IMPLEMENTED */ return NULL; }\n\n\nWAJIC_WITH_INIT(\n(\n    var start_time = Date.now();\n),\nAPP_U32, app_js_get_ticks, (),\n{\n    return Date.now() - start_time;\n})\n\nAPP_U64 app_time_count( app_t* app )\n    {\n    return (APP_U64)app_js_get_ticks()*1000;\n    }\n\n\nAPP_U64 app_time_freq( app_t* app )\n    {\n    return (APP_U64)1000*1000;\n    }\n\n\nvoid app_log( app_t* app, app_log_level_t level, char const* message )\n    {\n    printf(\"[APP] [%d] %s\\n\", (int)level, message);\n    }\n\n\nvoid app_fatal_error( app_t* app, char const* message )\n    {\n    APP_FATAL_ERROR( app->fatalctx, message );\n    }\n\n\nvoid app_pointer( app_t* app, int width, int height, APP_U32* pixels_abgr, int hotspot_x, int hotspot_y ) { /* NOT IMPLEMENTED */ }\nvoid app_pointer_default( app_t* app, int* width, int* height, APP_U32* pixels_abgr, int* hotspot_x, int* hotspot_y ) { /* NOT IMPLEMENTED */ }\nvoid app_pointer_pos( app_t* app, int x, int y ) { /* NOT IMPLEMENTED */ }\n\n\nint app_pointer_x( app_t* app )\n    {\n    return app->pointer_x;\n    }\n\n\nint app_pointer_y( app_t* app )\n    {\n    return app->pointer_y;\n    }\n\n\nvoid app_pointer_limit( app_t* app, int x, int y, int width, int height ) { /* NOT IMPLEMENTED */ }\nvoid app_pointer_limit_off( app_t* app ) { /* NOT IMPLEMENTED */ }\n\nvoid app_interpolation( app_t* app, app_interpolation_t interpolation )\n    {\n    if( interpolation == app->interpolation ) return;\n    app->interpolation = interpolation;\n\n    app_internal_opengl_interpolation( &app->gl, interpolation );\n    }\n\n\nvoid app_screenmode( app_t* app, app_screenmode_t screenmode )\n    {\n    app_js_screenmode( (int) ( screenmode == APP_SCREENMODE_FULLSCREEN ) );\n    }\n\n\nvoid app_window_size( app_t* app, int width, int height )\n    {\n    // view size is controlled by the browser, we only control the display aspect ratio\n    app_js_set_aspect_ratio( &width, &height );\n    if( width != app->gl.window_width || height != app->gl.window_height )\n        {\n        app_internal_opengl_resize( &app->gl, width, height );\n        }\n    }\n\n\nint app_window_width( app_t* app )\n    {\n    return app->gl.window_width;\n    }\n\n\nint app_window_height( app_t* app )\n    {\n    return app->gl.window_height;\n    }\n\n\nvoid app_window_pos( app_t* app, int x, int y ) { /* NOT IMPLEMENTED */ }\n\n\nint app_window_x( app_t* app )\n    {\n    return 0;\n    }\n\n\nint app_window_y( app_t* app )\n    {\n    return 0;\n    }\n\n\napp_displays_t app_displays( app_t* app )\n    {\n    // Fixed display for web\n    static app_display_t display;\n    display.id[0] = '\\0';\n    display.x = 0;\n    display.y = 0;\n    display.width = 1920;\n    display.height = 1080;\n    app_displays_t displays;\n    displays.count = 1;\n    displays.displays = &display;\n    return displays;\n    }\n\n\nWAJIC_WITH_INIT(\n(\n    var audio_ctx, audio_done = 0, audio_latency = 2048, audio_bufs = [], audio_bufidx = 0, audio_miss = 0;\n    var start_audio = ()=>\n    {\n        if (audio_ctx.state == 'running') return 1;\n        audio_done = audio_ctx.currentTime;\n        audio_ctx.resume();\n    };\n    var set_start_audio_event = (name)=>document.addEventListener(name, start_audio, {once:true});\n),\nint, app_js_audio_needed, (bool has_focus),\n{\n    if (!audio_ctx)\n    {\n        if (audio_ctx === false) return 0;\n        try { (audio_ctx = new (alias(window,\"\",\"\",'AudioContext'))()).createBuffer(1,1,44100).getChannelData(0); } catch (e) { }\n        if (!audio_ctx) { audio_ctx = false; WA.print('Warning: WebAudio not supported\\n'); return 0; }\n        for (var i = 0; i != 10; i++) audio_bufs[i] = audio_ctx.createBuffer(2, 2048, 44100);\n        if (!start_audio()) { set_start_audio_event('click'); set_start_audio_event('touchstart'); set_start_audio_event('keydown'); }\n    }\n    if (!start_audio() && !start_audio()) return 0;\n    var ct = audio_ctx.currentTime;\n    if (audio_done < ct)\n    {\n        if (has_focus && (audio_miss += 2) > 7)\n        {\n            audio_latency += 2048;\n            audio_miss = 0;\n        }\n        audio_done = ct;\n    }\n    else if (audio_miss > 1) audio_miss--;\n    return ((ct - audio_done) * 44100 + .5 + audio_latency * (has_focus ? 1 : 2) + 2047)>>11;\n})\n\nWAJIC(int, app_js_audio_push, (APP_S16* sample_pairs, int volume),\n{\n    sample_pairs = new Int16Array(MU8.buffer).subarray(sample_pairs>>1);\n    var buf = audio_bufs[audio_bufidx = ((audio_bufidx + 1) % 10)];\n    var left = buf.getChannelData(0), right = buf.getChannelData(1);\n    var f = (1 / 32768) * (volume / 255);\n    for (var i = 0; i != 2048; i++)\n    {\n        left[i] = sample_pairs[i*2] * f;\n        right[i] = sample_pairs[i*2+1] * f;\n    }\n    var source = audio_ctx.createBufferSource();\n    source.connect(audio_ctx.destination);\n    source.buffer = buf;\n    source[source.start ? 'start' : 'noteOn'](0.005+audio_done);\n    audio_done += 2048/44100;\n})\n\n\nvoid app_present( app_t* app, APP_U32 const* pixels_xbgr, int width, int height, APP_U32 mod_xbgr, APP_U32 border_xbgr )\n    {\n    if( pixels_xbgr ) app_internal_opengl_present( &app->gl, pixels_xbgr, width, height, mod_xbgr, border_xbgr );\n    for( int needed = app_js_audio_needed(app->has_focus); app->sound_callback && needed--;)\n        {\n        app->sound_callback(app->sound_buffer, 2048, app->sound_user_data);\n        app_js_audio_push(app->sound_buffer, app->volume);\n        }\n    if( app->has_focus )\n        WaCoroWaitAnimFrame();\n    else\n        WaCoroSleep(50);\n    }\n\n\nvoid app_sound( app_t* app, int sample_pairs_count, void (*sound_callback)( APP_S16* sample_pairs, int sample_pairs_count, void* user_data ), void* user_data )\n    {\n    app->sound_callback = sound_callback;\n    app->sound_user_data = user_data;\n    if( sound_callback && !app->sound_buffer )\n        app->sound_buffer = (APP_S16*) APP_MALLOC( app->memctx, sizeof(APP_S16) * 2048 * 2 );\n    else if( !sound_callback && app->sound_buffer )\n        APP_FREE( app->memctx, app->sound_buffer );\n    }\n\n\nvoid app_sound_volume( app_t* app, float volume )\n    {\n    int v = (int) ( volume * 256.0f );\n    app->volume = v < 0 ? 0 : v > 256 ? 256 : v;\n    }\n\n\napp_input_t app_input( app_t* app )\n    {\n    app_input_t input;\n    input.events = app->input_events;\n    input.count = app->input_count;\n    app->input_count = 0;\n    return input;\n    }\n\n\nvoid app_coordinates_window_to_bitmap( app_t* app, int width, int height, int* x, int* y )\n    {\n    if( width == 0 || height == 0 ) return;\n    if( app->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = app->gl.window_width / (float) width;\n        float vscale = app->gl.window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n        if( pixel_scale > 0.0f )\n            {\n            float hborder = ( app->gl.window_width - pixel_scale * width ) / 2.0f;\n            float vborder = ( app->gl.window_height - pixel_scale * height ) / 2.0f;\n            *x -= (int)( hborder );\n            *y -= (int)( vborder );\n            *x = (int)( *x / pixel_scale );\n            *y = (int)( *y / pixel_scale );\n            }\n        else\n            {\n            *x = 0;\n            *y = 0;\n            }\n        }\n    else\n        {\n        int hscale = app->gl.window_width / width;\n        int vscale = app->gl.window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n        int hborder = ( app->gl.window_width - pixel_scale * width ) / 2;\n        int vborder = ( app->gl.window_height - pixel_scale * height ) / 2;\n        *x -= (int)( hborder );\n        *y -= (int)( vborder );\n        *x = (int)( *x / pixel_scale );\n        *y = (int)( *y / pixel_scale );\n        }\n    }\n\n\nvoid app_coordinates_bitmap_to_window( app_t* app, int width, int height, int* x, int* y )\n    {\n    if( app->interpolation == APP_INTERPOLATION_LINEAR )\n        {\n        float hscale = app->gl.window_width / (float) width;\n        float vscale = app->gl.window_height / (float) height;\n        float pixel_scale = hscale < vscale ? hscale : vscale;\n        if( pixel_scale > 0.0f )\n            {\n            float hborder = ( app->gl.window_width - pixel_scale * width ) / 2.0f;\n            float vborder = ( app->gl.window_height - pixel_scale * height ) / 2.0f;\n            *x = (int)( *x * pixel_scale );\n            *y = (int)( *y * pixel_scale );\n            *x += (int)( hborder );\n            *y += (int)( vborder );\n            }\n        else\n            {\n            *x = 0;\n            *y = 0;\n            }\n        }\n    else\n        {\n        int hscale = app->gl.window_width / width;\n        int vscale = app->gl.window_height / height;\n        int pixel_scale = pixel_scale = hscale < vscale ? hscale : vscale;\n        pixel_scale = pixel_scale < 1 ? 1 : pixel_scale;\n        int hborder = ( app->gl.window_width - pixel_scale * width ) / 2;\n        int vborder = ( app->gl.window_height - pixel_scale * height ) / 2;\n        *x = (int)( *x * pixel_scale );\n        *y = (int)( *y * pixel_scale );\n        *x += (int)( hborder );\n        *y += (int)( vborder );\n        }\n    }\n\n\n#else\n    #error Undefined platform. Define APP_WINDOWS, APP_SDL, APP_WASM or APP_NULL.\n#endif\n\n\n#endif /* APP_IMPLEMENTATION */\n\n/*\nrevision history:\n    0.4     pointer x/y, callback for sound, modifier keys fix, gl binding fix, cursor fix\n    0.3     added API documentation\n    0.2     first publicly released version\n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2016 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "array.h",
          "type": "blob",
          "size": 12.8154296875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\narray.h - v0.1 - Dynamic array library for C/C++.\n\nDo this:\n    #define ARRAY_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef array_h\n#define array_h\n\n#ifndef ARRAY_BOOL_T\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdbool.h>\n    #define ARRAY_BOOL_T bool\n#endif\n\n#define array_t( type ) struct { int count; type* items; }\n#define array_param_t( type ) void\n#define array_create( type ) ARRAY_CAST( (void*)internal_array_create( sizeof( type ), NULL ) )\n#define array_create_memctx( type, memctx ) ARRAY_CAST( (void*)internal_array_create( sizeof( type ), (memctx) ) )\n#define array_destroy( array ) internal_array_destroy( (struct internal_array_t*) (array) )\n#define array_add( array, item ) ARRAY_CAST( internal_array_add( (struct internal_array_t*) (array), (void*) (item), (int)sizeof( *item ) ) )\n#define array_remove( array, index ) internal_array_remove( (struct internal_array_t*) (array), (index) )\n#define array_remove_ordered( array, index ) internal_array_remove_ordered( (struct internal_array_t*) (array), (index) )\n#define array_get( array, index, item ) internal_array_get( (struct internal_array_t*) (array), (index), (void*) (item) )\n#define array_set( array, index, item ) internal_array_set( (struct internal_array_t*) (array), (index), (void*) (item) )\n#define array_count( array ) internal_array_count( (struct internal_array_t*) (array) )\n#define array_sort( array, compare ) internal_array_sort( (struct internal_array_t*) (array), (compare) )\n#define array_bsearch( array, key, compare ) internal_array_bsearch( (struct internal_array_t*) (array), (void*) (key), (compare) )\n#define array_find( array, item ) internal_array_find( (struct internal_array_t*) (array), (void*) (item) )\n#define array_item( array, index ) ARRAY_CAST( internal_array_item( (struct internal_array_t*) (array), (index) ) )\n\n\n// In C, a void* can be implicitly cast to any other kind of pointer, while in C++ you need an explicit cast. In most\n// cases, the explicit cast works for both C and C++, but if we consider the case where we have nested structs, then\n// the way you refer to them differs between C and C++ (in C++, `parent_type::nested_type`, in C just `nested_type`).\n// In addition, with the automatic cast in C, it is possible to use unnamed nested structs and still dynamically\n// allocate arrays of that type - this would be desirable when the code is compiled from C++ as well.\n// This VOID_CAST macro allows for automatic cast from void* in C++. In C, it does nothing, but for C++ it uses a\n// simple template function to define a cast-to-anything operator.\n// Use like this:\n//      struct {\n//          struct {\n//              int x;\n//          } *nested;\n//      } parent;\n//      parent.nested = VOID_CAST( malloc( sizeof( *parent.nested ) * count ) );\n//\n#ifndef ARRAY_CAST\n    #ifdef __cplusplus\n        struct array_cast {\n            inline array_cast( void* x_ ) : x( x_ ) { }\n            inline array_cast( void const* x_ ) : x( (void*) x_ ) { }\n            template< typename T > inline operator T() { return (T)x; } // cast to whatever requested\n            void* x;\n        };\n        #define ARRAY_CAST( x ) array_cast( x )\n    #else\n        #define ARRAY_CAST( x ) x\n    #endif\n#endif\n\n\nstruct internal_array_t;\n\nstruct internal_array_t* internal_array_create( int item_size, void* memctx );\nvoid internal_array_destroy( struct internal_array_t* array );\nvoid* internal_array_add( struct internal_array_t* array, void* item, int item_size );\nvoid internal_array_remove( struct internal_array_t* array, int index );\nvoid internal_array_remove_ordered( struct internal_array_t* array, int index );\nARRAY_BOOL_T internal_array_get( struct internal_array_t* array, int index, void* item );\nARRAY_BOOL_T internal_array_set( struct internal_array_t* array, int index, void const* item );\nint internal_array_count( struct internal_array_t* array );\nvoid internal_array_sort( struct internal_array_t* array, int (*compare)( void const*, void const* ) );\nint internal_array_bsearch( struct internal_array_t* array, void* key, int (*compare)( void const*, void const* ) );\nint internal_array_find( struct internal_array_t* array, void* item );\nvoid* internal_array_item( struct internal_array_t* array, int index );\n\n#endif /* array_h */\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef ARRAY_IMPLEMENTATION\n#undef ARRAY_IMPLEMENTATION\n\n#ifndef ARRAY_ASSERT\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <assert.h>\n    #define ARRAY_ASSERT( condition, message ) assert( condition && message );\n#endif\n\n#ifndef ARRAY_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define ARRAY_MALLOC( ctx, size ) ( malloc( size ) )\n    #define ARRAY_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n#ifndef ARRAY_MEMCPY\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define ARRAY_MEMCPY( dst, src, cnt ) ( memcpy( (dst), (src), (cnt) ) )\n#endif\n\n#ifndef ARRAY_MEMMOVE\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define ARRAY_MEMMOVE( dst, src, cnt ) ( memcpy( (dst), (src), (cnt) ) )\n#endif\n\n#ifndef ARRAY_MEMCMP\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define ARRAY_MEMCMP( a, b, cnt ) ( memcmp( (a), (b), (cnt) ) )\n#endif\n\n#ifndef ARRAY_QSORT\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define ARRAY_QSORT( base, num, size, cmp ) ( qsort( (base), (num), (size), (cmp) ) )\n#endif\n\n#ifndef ARRAY_BSEARCH\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define ARRAY_BSEARCH( key, base, num, size, cmp ) ( bsearch( (key), (base), (num), (size), (cmp) ) )\n#endif\n\n\nstruct internal_array_t {\n    int count;\n    void* items;\n    void* memctx;\n    int item_size;\n    int capacity;\n};\n\n\nstruct internal_array_t* internal_array_create( int item_size, void* memctx ) {\n    struct internal_array_t* array = (struct internal_array_t*) ARRAY_MALLOC( memctx, sizeof( struct internal_array_t ) );\n    array->memctx = memctx;\n    array->item_size = item_size;\n    array->capacity = 256;\n    array->count = 0;\n    array->items = ARRAY_MALLOC( memctx, (size_t) array->capacity * item_size );\n    return array;\n}\n\n\nvoid internal_array_destroy( struct internal_array_t* array ) {\n    ARRAY_FREE( array->memctx, array->items );\n    ARRAY_FREE( array->memctx, array );\n}\n\n\nvoid* internal_array_add( struct internal_array_t* array, void* item, int item_size  ) {\n    ARRAY_ASSERT( item_size == array->item_size, \"Invalid item\" );\n    if( array->count >= array->capacity ) {\n        array->capacity *= 2;\n        void* items = array->items;\n        array->items = ARRAY_MALLOC( array->memctx, (size_t) array->capacity * array->item_size );\n        ARRAY_MEMCPY( array->items, items, (size_t)array->count * array->item_size );\n        ARRAY_FREE( array->memctx, items );\n    }\n    ARRAY_MEMCPY( (void*)( ( (uintptr_t) array->items ) + array->count * array->item_size ), item,\n        (size_t)array->item_size );\n    ++array->count;\n    return (void*)( ( (uintptr_t) array->items ) + ( array->count - 1 ) * array->item_size );\n}\n\n\nvoid internal_array_remove( struct internal_array_t* array, int index ) {\n    if( index >= 0 && index < array->count ) {\n        --array->count;\n        ARRAY_MEMMOVE( (void*)( ( (uintptr_t) array->items ) + index * array->item_size ),\n            (void*)( ( (uintptr_t) array->items ) + array->count  * array->item_size ), (size_t) array->item_size );\n    }\n}\n\nvoid internal_array_remove_ordered( struct internal_array_t* array, int index ) {\n    if( index >= 0 && index < array->count ) {\n        --array->count;\n        ARRAY_MEMMOVE( (void*)( ( (uintptr_t) array->items ) + index * array->item_size ),\n            (void*)( ( (uintptr_t) array->items ) + ( index + 1 ) * array->item_size ),\n            (size_t)array->item_size * ( array->count - index ) );\n    }\n}\n\nARRAY_BOOL_T internal_array_get( struct internal_array_t* array, int index, void* item ) {\n    ARRAY_BOOL_T result = index >= 0 && index < array->count;\n    if( result ) {\n        ARRAY_MEMCPY( item, (void*)( ( (uintptr_t) array->items ) + index * array->item_size ),\n            (size_t) array->item_size );\n    }\n    return result;\n}\n\nARRAY_BOOL_T internal_array_set( struct internal_array_t* array, int index, void const* item ) {\n    ARRAY_BOOL_T result = index >= 0 && index < array->count;\n    if( result ) {\n        ARRAY_MEMCPY( (void*)( ( (uintptr_t) array->items ) + index * array->item_size ), item,\n            (size_t) array->item_size );\n    }\n    return result;\n}\n\nint internal_array_count( struct internal_array_t* array ) {\n    int count = array->count;\n    return count;\n}\n\n\nvoid internal_array_sort( struct internal_array_t* array, int (*compare)( void const*, void const* ) ) {\n    ARRAY_QSORT( array->items, (size_t) array->count, (size_t) array->item_size, compare );\n}\n\n\nint internal_array_bsearch( struct internal_array_t* array, void* key, int (*compare)( void const*, void const* ) ) {\n    void* item = ARRAY_BSEARCH( key, array->items, (size_t) array->count, (size_t) array->item_size, compare );\n    int result = -1;\n    if( item ) {\n        result = (int)( ( ((uintptr_t)item) - ((uintptr_t)array->items) ) / array->item_size );\n    }\n    return result;\n}\n\n\nint internal_array_find( struct internal_array_t* array, void* item ) {\n    for( int i = 0; i < array->count; ++i ) {\n        if( ARRAY_MEMCMP( (void*)( ( (uintptr_t) array->items ) + i * array->item_size ), item,\n            (size_t) array->item_size) == 0 ) {\n\n            return i;\n        }\n    }\n    return -1;\n}\n\n\nvoid* internal_array_item( struct internal_array_t* array, int index ) {\n    if(  index >= 0 && index < array->count ) {\n        return (void*)( ( (uintptr_t) array->items ) + index * array->item_size );\n    } else {\n        return NULL;\n    }\n}\n\n#endif /* ARRAY_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2022 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "assetsys.h",
          "type": "blob",
          "size": 284.83984375,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nassetsys.h - v1.5 - File system abstraction to read from zip-files, for C/C++.\n\nDo this:\n    #define ASSETSYS_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n\nIf you are using miniz.c for other things, and have included it in your \nproject, you need to define ASSETSYS_NO_MINIZ as well, to avoid duplicate \ndefinitions. \n\nDependencies: \n    strpool.h\n*/\n\n#ifndef assetsys_h\n#define assetsys_h\n\n#ifndef ASSETSYS_U64\n    #define ASSETSYS_U64 unsigned long long\n#endif\n\ntypedef enum assetsys_error_t\n    {\n    ASSETSYS_SUCCESS = 0,\n    ASSETSYS_ERROR_INVALID_PATH = -1,\n    ASSETSYS_ERROR_INVALID_MOUNT = -2, \n    ASSETSYS_ERROR_FAILED_TO_READ_ZIP = -3,\n    ASSETSYS_ERROR_FAILED_TO_CLOSE_ZIP = -4,\n    ASSETSYS_ERROR_FAILED_TO_READ_FILE = -5,\n    ASSETSYS_ERROR_FILE_NOT_FOUND = -6,\n    ASSETSYS_ERROR_DIR_NOT_FOUND = -7, \n    ASSETSYS_ERROR_INVALID_PARAMETER = -8,\n    ASSETSYS_ERROR_BUFFER_TOO_SMALL = -9,\n    } assetsys_error_t;\n\ntypedef struct assetsys_t assetsys_t;\n\nassetsys_t* assetsys_create( void* memctx );\nvoid assetsys_destroy( assetsys_t* sys );\n\nassetsys_error_t assetsys_mount( assetsys_t* sys, char const* path, char const* mount_as );\nassetsys_error_t assetsys_mount_from_memory( assetsys_t* sys, void const* data, int size, char const* mount_as);\nassetsys_error_t assetsys_dismount( assetsys_t* sys, char const* path, char const* mounted_as );\n\ntypedef struct assetsys_file_t { ASSETSYS_U64 mount; ASSETSYS_U64 path; int index; } assetsys_file_t;\n\nassetsys_error_t assetsys_file( assetsys_t* sys, char const* path, assetsys_file_t* file );\nassetsys_error_t assetsys_file_load( assetsys_t* sys, assetsys_file_t file, int* size, void* buffer, int capacity );\nint assetsys_file_size( assetsys_t* sys, assetsys_file_t file );\n\nint assetsys_file_count( assetsys_t* sys, char const* path );\nchar const* assetsys_file_name( assetsys_t* sys, char const* path, int index );\nchar const* assetsys_file_path( assetsys_t* sys, char const* path, int index );\n\nint assetsys_subdir_count( assetsys_t* sys, char const* path );\nchar const* assetsys_subdir_name( assetsys_t* sys, char const* path, int index );\nchar const* assetsys_subdir_path( assetsys_t* sys, char const* path, int index );\n\n#endif /* assetsys_h */\n\n/**\n\nassetsys.h\n==========\n\nFile system abstraction to read from zip-files, for C/C++.\n\n\nExample\n-------\n\n    #define ASSETSYS_IMPLEMENTATION\n    #include \"assetsys.h\"\n\n    #define STRPOOL_IMPLEMENTATION\n    #include \"strpool.h\"\n\n    #include <stdio.h> // for printf\n\n    void list_assets( assetsys_t* assetsys, char const* path, int indent ) {\n        // Print folder names and recursively list assets\n        for( int i = 0; i < assetsys_subdir_count( assetsys, path ); ++i ) {\n            char const* subdir_name = assetsys_subdir_name( assetsys, path, i );\n            for( int j = 0; j < indent; ++j ) printf( \"  \" );\n            printf( \"%s/\\n\", subdir_name );\n\n            char const* subdir_path = assetsys_subdir_path( assetsys, path, i );\n            list_assets( assetsys, subdir_path, indent + 1 );\n        }\n\n        // Print file names\n        for( int i = 0; i < assetsys_file_count( assetsys, path ); ++i ) {\n            char const* file_name = assetsys_file_name( assetsys, path, i );\n            for( int j = 0; j < indent; ++j ) printf( \"  \" );\n            printf( \"%s\\n\", file_name );\n        }\n    }\n\n    int main( void ) {\n        assetsys_t* assetsys = assetsys_create( 0 );\n    \n        // Mount current working folder as a virtual \"/data\" path\n        assetsys_mount( assetsys, \".\", \"/data\" );\n\n        // Print all files and subfolders\n        list_assets( assetsys, \"/\", 0 ); // Start at root \n\n        // Load a file\n        assetsys_file_t file;\n        assetsys_file( assetsys, \"/data/readme.txt\", &file );\n        int size = assetsys_file_size( assetsys, file );\n        char* content = (char*) malloc( size + 1 ); // extra space for '\\0'\n        int loaded_size = 0;\n        assetsys_file_load( assetsys, file, &loaded_size, content, size );\n        content[ size ] = '\\0'; // zero terminate the text file\n        printf( \"%s\\n\", content );\n        free( content );\n\n        assetsys_destroy( assetsys );\n    }\n    \n\nAPI Documentation\n-----------------\n\nassetsys.h is a system for loading binary assets into your game. It allows you to mount directories and archive files \n(bundles of files; assetsys.h supports using standard zip files for this) assign them a virtual path. You then load \nassets through assetsys using the virtual path (which can stay the same even if the mounts change). assetsys.h is \ncase-insensitive regardless of platform, and only accepts forward slash \"/\" as path separator, to ensure consistent \nbehavior. It allows you to mount several paths or archive files to the same virtual path, even if they contain files of \nthe same name, and a later mount will take precedence over a previous one. This allows you to, for example, have a \n`data` archive file and an `update` archive file, where `update` contains new versions of only some of the files.\n\nassetsys.h is a single-header library, and does not need any .lib files or other binaries, or any build scripts. To use \nit, you just include assetsys.h to get the API declarations. To get the definitions, you must include assetsys.h from \n*one* single C or C++ file, and #define the symbol `ASSETSYS_IMPLEMENTATION` before you do. \n\nassetsys.h has a dependency om another single-header library, strpool.h, which is used for efficient storage and \ncomparison of the filename and path strings. assetsys.h automatically includes strpool.h, so it must reside in the same\npath. It does not specify the STRPOOL_IMPLEMENTATION define, on the assumption that you might be including strpool.h in\nsome other part of your program. If you are not, you can make assetsys.h include the strpool implemention by doing:\n\n    #define ASSETSYS_IMPLEMENTATION\n    #define STRPOOL_IMPLEMENTATION\n    #include \"assetsys.h\"\n\n\n### Customization\n\nThere are a few different things in assetsys.h which are configurable by #defines. Most of the API use the `int` data \ntype, for integer values where the exact size is not important. However, for some functions, it specifically makes use \nof an unsigned 64 bit data types. It default to using `unsigned long long`, but can be redefined by #defining \nASSETSYS_U64, before including assetsys.h. This is useful if you, for example, use the types from `<stdint.h>` in the \nrest of your program, and you want assetsys.h to use compatible types. In this case, you would include assetsys.h using \nthe following code:\n\n    #define ASSETSYS_U64 uint64_t\n    #include \"assetsys.h\"\n\nNote that when customizing the data type, you need to use the same definition in every place where you include \nassetsys.h, as they affect the declarations as well as the definitions.\n\nThe rest of the customizations only affect the implementation, so will only need to be defined in the file where you\nhave the #define ASSETSYS_IMPLEMENTATION.\n\n\n#### Custom memory allocators\n\nTo store the internal data structures, ini.h needs to do dynamic allocation by calling `malloc`. Programs might want to \nkeep track of allocations done, or use custom defined pools to allocate memory from. assetsys.h allows for specifying \ncustom memory allocation functions for `malloc` and `free`. This is done with the following code:\n\n    #define ASSETSYS_IMPLEMENTATION\n    #define ASSETSYS_MALLOC( ctx, size ) ( my_custom_malloc( ctx, size ) )\n    #define ASSETSYS_FREE( ctx, ptr ) ( my_custom_free( ctx, ptr ) )\n    #include \"assetsys.h\"\n\nwhere `my_custom_malloc` and `my_custom_free` are your own memory allocation/deallocation functions. The `ctx` parameter\nis an optional parameter of type `void*`. When `assetsys_init` is called, you can set the `memctx` field of the `config`\nparameter, to a pointer to anything you like, and which will be passed through as the `ctx` parameter to every \n`ASSETSYS_MALLOC`/`ASSETSYS_FREE` call. For example, if you are doing memory tracking, you can pass a pointer to your \ntracking data as `memctx`, and in your custom allocation/deallocation function, you can cast the `ctx` param back to the \nright type, and access the tracking data.\n\nIf no custom allocator is defined, assetsys.h will default to `malloc` and `free` from the C runtime library.\n\n\n#### Custom assert\n\nassetsys.h makes use of asserts to report usage errors and code errors. By default, it makes use of the C runtime \nlibrary `assert` macro, which only executes in debug builds. However, it allows for substituting with your own assert \nfunction or macro using the following code:\n\n    #define ASSETSYS_IMPLEMENTATION\n    #define ASSETSYS_ASSERT( condition ) ( my_custom_assert( condition ) )\n    #include \"assetsys.h\"\n\nNote that if you only want the asserts to trigger in debug builds, you must add a check for this in your custom assert.\n\n\n#### miniz implementation\n\nassetsys.h makes use of the miniz library for parsing and decompressing zip files. It includes the entire miniz source\ncode inside assetsys.h, so normally you don't have to worry about it. However, in the case where you might already be\nusing miniz in some other part of the program, you can tell assetsys.h to not include the implementation for miniz. It \nwill still include the miniz definitions, and if you don't include the miniz implementation elsewhere, you will get a \nlinker error. To exclude the miniz implementation, simply define `ASSETSYS_NO_MINIZ` before including assetsys.h, like \nthis:\n\n    #define ASSETSYS_IMPLEMENTATION\n    #define ASSETSYS_NO_MINIZ\n    #include \"assetsys.h\"\n\n    \nassetsys_create\n---------------\n\n    assetsys_t* assetsys_create( void* memctx )\n\nCreates a new assetsys instance. assetsys.h does not use any global variables, all data it needs is accessed through\nthe instance created by calling assetsys_create. Different instances can be used safely from different threads, but if\nusing the same instance from multiple threads, it is up to the user to make sure functions are not called concurrently,\nfor example by adding a mutex lock around each call.\n\n\nassetsys_destroy\n----------------\n\n    void assetsys_destroy( assetsys_t* sys )\n\nDestroys an assetsys instance, releasing all the resources used by it. \n\n\nassetsys_mount\n--------------\n\n    assetsys_error_t assetsys_mount( assetsys_t* sys, char const* path, char const* mount_as )\n\nMounts the data source `path`, making all its files accessible through this assetsys instance. The data source can be\neither a folder or an archive file (a standard .zip file, with or without compression). `path` must use forward slash \n`/` as path separator, never backslash, regardless of platform. It must not end with a path separator. The string\n`mount_as` will be prepended to all mounted files, and can be passed as \"/\" to mount as root.  `mount_as` may \nnot contain the characters backslash `\\` or colon `:`. It must not end with a path separator (unless consisting of \na single path separator only, \"/\"). `assetsys_mount` will  return `ASSETSYS_ERROR_INVALID_PARAMETER` if either `path` \nor `mount_as` is NULL. It will return `ASSETSYS_ERROR_INVALID_PATH` if the conditions detailed above are not met, or \nif the file or folder specified by `path` could not be found. If `path` indicates a file, and it is not a valid archive\nfile, `assetsys_mount` returns `ASSETSYS_ERROR_FAILED_TO_READ_ZIP`.\n\nIf multiple mounts contains the same file and it is accessible through the same full path (whether because of the \n`mount_as` prefix or not), the last mounted data source will be used when loading that file.\n\n\nassetsys_mount_from_memory\n--------------------------\n\n    assetsys_error_t assetsys_mount_from_memory( assetsys_t* sys, void const* data, int size, char const* mount_as )\n\nSame as `assetsys_mount()`, but takes a data buffer of an archived *.zip* file, along with the size of the file.\n\n\nassetsys_dismount\n-----------------\n\n    assetsys_error_t assetsys_dismount( assetsys_t* sys, char const* path, char const* mounted_as )\n\nRemoves a data source which was mounted by calling `assetsys_mount`. `path` and `mounted_as` must be the same as was\nused when mounting. If `path` is NULL, `assetsys_dismount` returns `ASSETSYS_ERROR_INVALID_PARAMETER`. If `mounted_as`\nis NULL, or no matching mount could be found, it returns `ASSETSYS_ERROR_INVALID_MOUNT`. \n\n\nassetsys_file\n-------------\n\n    assetsys_error_t assetsys_file( assetsys_t* sys, char const* path, assetsys_file_t* file )\n\nRetrieves a handle for the file specified by `path`. `path` needs to be an absolute path, including the `mount_as` \nprefix specified when the data source was mounted, and matching is case insensitive. The mounts are searched in reverse\norder they were added, and if a file with the specified path could not be found, `assetsys_file` returns\n`ASSETSYS_ERROR_FILE_NOT_FOUND`. The handle is written to `file`, which must be a pointer to a `assetsys_file_t`\nvariable declared by the caller. The handle is used in calls to `assetsys_file_load` and `assetsys_file_size`. The \nhandle is only valid until any mounts are modified by calling `assetsys_mount` or `assetsys_dismount`.\n\n\nassetsys_file_load\n------------------\n\n    assetsys_error_t assetsys_file_load( assetsys_t* sys, assetsys_file_t file, int* size, void* buffer, int capacity )\n\nLoad the data from the file specified by the handle `file` (initialized by calling `assetsys_file`) and writes it into\nthe memory indicated by `buffer`. This memory buffer must be large enough to fit the entire file, and the `capacity`\nparameter must indicate its size. To find out how large the buffer needs to be, call `assetsys_file_size`. The size of\nthe file will also be reported in the `size` parameter, unless it is passed in as NULL. Note that the two sizes can be\nreported with different values if the file was updated on disk between the call to `assetsys_file_size` and the call to\n`assetsys_file_load`. \nIf the file could not be loaded, `assetsys_file_load` returns `ASSETSYS_ERROR_FAILED_TO_READ_FILE`. If the `capacity`\nparameter is too small to hold the file data, `assetsys_file_load` returns `ASSETSYS_ERROR_BUFFER_TOO_SMALL`.\n\n\nassetsys_file_size\n------------------\n\n    int assetsys_file_size( assetsys_t* sys, assetsys_file_t file )\n\nReturns the size, in bytes, of the file specified by the handle `file` (initialized by calling `assetsys_file`). If the\nfile handle is not valid, `assetsys_file_size` returns 0. If the file is found in a directory mount, the size will be\nre-queried on each call to `assetsys_file_size` (to support the case where a file have been re-saved to disk since the\nlast call). In the case where the file resides in an archive mount, `assetsys_file_size` will return its initial value.\n\n\nassetsys_file_count\n-------------------\n\n    int assetsys_file_count( assetsys_t* sys, char const* path )\n\nReturns the number of files in the directory with the specified path, or 0 if the path is invalid. `path` needs to be an \nabsolute path, including the `mount_as` prefix specified when the data source was mounted, and matching is case \ninsensitive. `assetsys_file_count` returns the total number of files from all mounts, which fall under the path.\n\n\nassetsys_file_name\n------------------\n    \n    char const* assetsys_file_name( assetsys_t* sys, char const* path, int index )\n\nReturns the filename and extension (but not the full path) of one of the files in the specified path. `path` needs to be \nan absolute path, including the `mount_as` prefix specified when the data source was mounted, and matching is case \ninsensitive. `index` needs to be between 0 and one less than the count returned by calling `assetsys_file_count` with\nthe same path. If the path is invalid or index is out of range, `assetsys_file_name` returns NULL.\n\n\nassetsys_file_path\n------------------\n\n    char const* assetsys_file_path( assetsys_t* sys, char const* path, int index )\n\nReturns the full path, including filename and extension, of one of the files in the specified path. `path` needs to be \nan absolute path, including the `mount_as` prefix specified when the data source was mounted, and matching is case \ninsensitive. `index` needs to be between 0 and one less than the count returned by calling `assetsys_file_count` with\nthe same path. If the path is invalid or index is out of range, `assetsys_file_path` returns NULL.\n\n\nassetsys_subdir_count\n---------------------\n\n    int assetsys_subdir_count( assetsys_t* sys, char const* path )\n\nReturns the number of subdirectories in the directory with the specified path, or 0 if the path is invalid. `path` needs \nto be an absolute path, including the `mount_as` prefix specified when the data source was mounted, and matching is case \ninsensitive. `assetsys_subdir_count` returns the total number of directories from all mounts, which fall under the path.\n\n\nassetsys_subdir_name\n--------------------\n\n    char const* assetsys_subdir_name( assetsys_t* sys, char const* path, int index )\n\nReturns the name (but not the full path) of one of the subdirectories in the specified path. `path` needs to be an \nabsolute path, including the `mount_as` prefix specified when the data source was mounted, and matching is case \ninsensitive. `index` needs to be between 0 and one less than the count returned by calling `assetsys_subdir_count` with\nthe same path. If the path is invalid or index is out of range, `assetsys_subdir_name` returns NULL.\n\n\nassetsys_subdir_path\n--------------------\n\n    char const* assetsys_subdir_path( assetsys_t* sys, char const* path, int index )\n\nReturns the name, including the full path, of one of the files in the specified path. `path` needs to be an absolute \npath, including the `mount_as` prefix specified when the data source was mounted, and matching is case insensitive. \n`index` needs to be between 0 and one less than the count returned by calling `assetsys_subdir_count` with the same \npath. If the path is invalid or index is out of range, `assetsys_subdir_path` returns NULL.\n\n\n*/\n\n\n// If we are running tests on windows\n#if defined( ASSETSYS_RUN_TESTS ) && defined( _WIN32 ) && !defined( __TINYC__ )\n    // To get file names/line numbers with meory leak detection, we need to include crtdbg.h before all other files\n    #define _CRTDBG_MAP_ALLOC\n    #include <crtdbg.h>\n#endif\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef ASSETSYS_IMPLEMENTATION\n#undef ASSETSYS_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n\n#ifndef ASSETSYS_FILE\n  #include <stdio.h>\n  #define ASSETSYS_FILE FILE\n#endif\n\n#ifndef ASSETSYS_FOPEN\n  #include <stdio.h> // fopen\n  #define ASSETSYS_FOPEN( f, m ) fopen( f, m )\n#endif\n\n#ifndef ASSETSYS_FCLOSE\n  #include <stdio.h> // fclose\n  #define ASSETSYS_FCLOSE( f ) fclose( f )\n#endif\n\n#ifndef ASSETSYS_FREAD\n  #include <stdio.h> // fread\n  #define ASSETSYS_FREAD( b, i, c, s ) fread( b, (i), (c), s )\n#endif\n\n#ifndef ASSETSYS_FWRITE\n  #include <stdio.h> // fwrite\n  #define ASSETSYS_FWRITE( b, i, c, s ) fwrite( b, (i), (c), s )\n#endif\n\n#ifndef ASSETSYS_FTELL\n  #include <stdio.h> // ftell\n  #define ASSETSYS_FTELL( f ) ftell( f )\n#endif\n\n#ifndef ASSETSYS_FSEEK\n  #include <stdio.h> // fseek\n  #define ASSETSYS_FSEEK( s, o, w ) fseek( s, (o), (w) )\n#endif\n\n#ifndef ASSETSYS_FILE_STAT\n  #if defined( _MSC_VER ) && _MSC_VER >= 1400\n    #include <sys/stat.h> // _stat\n    #define ASSETSYS_FILE_STAT __stat64\n  #else\n    #include <sys/stat.h> // stat\n    #define ASSETSYS_FILE_STAT stat\n  #endif\n#endif\n\n#ifndef ASSETSYS_FILE_STAT_STRUCT\n  #if defined( _MSC_VER ) && _MSC_VER >= 1400\n    #include <sys/stat.h> // _stat64\n    #define ASSETSYS_FILE_STAT_STRUCT _stat64\n  #else\n    #include <sys/stat.h> // stat\n    #define ASSETSYS_FILE_STAT_STRUCT stat\n  #endif\n#endif\n\n#ifndef ASSETSYS_SEEK_END\n  #include <stdio.h> // SEEK_END\n  #define ASSETSYS_SEEK_END SEEK_END\n#endif\n\n#ifndef ASSETSYS_SEEK_SET\n  #include <stdio.h> // SEEK_SET\n  #define ASSETSYS_SEEK_SET SEEK_SET\n#endif\n\n#ifndef ASSETSYS_FFLUSH\n  #include <stdio.h> // fflush\n  #define ASSETSYS_FFLUSH( f ) fflush( f )\n#endif\n\n#ifndef ASSETSYS_FREOPEN\n  #include <stdio.h> // freopen\n  #define ASSETSYS_FREOPEN( f, m, s ) freopen( f, m, s )\n#endif\n\n#ifndef ASSETSYS_DELETE_FILE\n  #include <stdio.h> // remove\n  #define ASSETSYS_DELETE_FILE( f ) remove( f )\n#endif\n\n#ifdef ASSETSYS_NO_MINIZ\n  #define MINIZ_HEADER_FILE_ONLY\n#else\n  #define MINIZ_NO_TIME\n  #define MINIZ_NO_MALLOC\n  #ifndef MZ_FILE\n    #define MZ_FILE ASSETSYS_FILE\n  #endif\n  #ifndef MZ_FOPEN\n    #define MZ_FOPEN(f, m) ASSETSYS_FOPEN(f, m)\n  #endif\n  #ifndef MZ_FCLOSE\n    #define MZ_FCLOSE ASSETSYS_FCLOSE\n  #endif\n  #ifndef MZ_FREAD\n    #define MZ_FREAD ASSETSYS_FREAD\n  #endif\n  #ifndef MZ_FWRITE\n    #define MZ_FWRITE ASSETSYS_FWRITE\n  #endif\n  #ifndef MZ_FTELL64\n    #define MZ_FTELL64 ASSETSYS_FTELL\n  #endif\n  #ifndef MZ_FSEEK64\n    #define MZ_FSEEK64 ASSETSYS_FSEEK\n  #endif\n  #ifndef MZ_FILE_STAT_STRUCT\n    #define MZ_FILE_STAT_STRUCT ASSETSYS_FILE_STAT_STRUCT\n  #endif\n  #ifndef MZ_FILE_STAT\n    #define MZ_FILE_STAT ASSETSYS_FILE_STAT\n  #endif\n  #ifndef MZ_FFLUSH\n    #define MZ_FFLUSH(val) ASSETSYS_FFLUSH(val)\n  #endif\n  #ifndef MZ_FREOPEN\n    #define MZ_FREOPEN(f, m, s) ASSETSYS_FREOPEN(f, m, s)\n  #endif\n  #ifndef MZ_DELETE_FILE\n    #define MZ_DELETE_FILE ASSETSYS_DELETE_FILE\n  #endif\n#endif /* ASSETSYS_NO_MINIZ */\n\n#ifdef ASSETSYS_ASSERT\n    #define MZ_ASSERT( x ) ASSETSYS_ASSERT( x, \"Miniz assert\" )\n#endif /* ASSETSYS_ASSERT */\n\n#pragma warning( push )\n#pragma warning( disable: 4619 ) // pragma warning : there is no warning number 'number'\n#pragma warning( disable: 4244 ) // 'conversion' conversion from 'type1' to 'type2', possible loss of data\n#pragma warning( disable: 4365 ) // 'action' conversion from 'type_1' to 'type_2', signed/unsigned mismatch\n#pragma warning( disable: 4548 ) // expression before comma has no effect; expected expression with side-effect\n#pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n\n/*\n------------------------------------------------------------------------------\n    BEGIN miniz.c\n------------------------------------------------------------------------------\n*/\n\n/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing\n   See \"unlicense\" statement at the end of this file.\n   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013\n   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt\n\n   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define\n   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).\n\n   * Change History\n     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major release with Zip64 support (almost there!):\n       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug (thanks kahmyong.moon@hp.com) which could cause locate files to not find files. This bug\n        would only have occured in earlier versions if you explicitly used this flag, OR if you used mz_zip_extract_archive_file_to_heap() or mz_zip_add_mem_to_archive_file_in_place()\n        (which used this flag). If you can't switch to v1.15 but want to fix this bug, just remove the uses of this flag from both helper funcs (and of course don't use the flag).\n       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when pUser_read_buf is not NULL and compressed size is > uncompressed size\n       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract compressed data from directory entries, to account for weird zipfiles which contain zero-size compressed data on dir entries.\n         Hopefully this fix won't cause any issues on weird zip archives, because it assumes the low 16-bits of zip external attributes are DOS attributes (which I believe they always are in practice).\n       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the internal attributes, just the filename and external attributes\n       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed\n       - Added cmake support for Linux builds which builds all the examples, tested with clang v3.3 and gcc v4.6.\n       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti\n       - Merged MZ_FORCEINLINE fix from hdeanclark\n       - Fix <time.h> include before config #ifdef, thanks emil.brink\n       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping (super useful for OpenGL apps), and explicit control over the compression level (so you can\n        set it to 1 for real-time compression).\n       - Merged in some compiler fixes from paulharris's github repro.\n       - Retested this build under Windows (VS 2010, including static analysis), tcc  0.9.26, gcc v4.6 and clang v3.3.\n       - Added example6.c, which dumps an image of the mandelbrot set to a PNG file.\n       - Modified example2 to help test the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.\n       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix possible src file fclose() leak if alignment bytes+local header file write faiiled\n         - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader(): Was pushing the wrong central dir header offset, appears harmless in this release, but it became a problem in the zip64 branch\n     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).\n     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.\n       - Temporarily/locally slammed in \"typedef unsigned long mz_ulong\" and re-ran a randomized regression test on ~500k files.\n       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.\n       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly\n        \"Use of the comma-operator in a tested expression..\" analysis warning, which I purposely use to work around a MSVC compiler warning).\n       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.\n       - Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.\n       - Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.\n       - Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)\n       - Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).\n     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.\n      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.\n     5/28/11 v1.11 - Added statement from unlicense.org\n     5/27/11 v1.10 - Substantial compressor optimizations:\n      - Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a\n      - Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).\n      - Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.\n      - Refactored the compression code for better readability and maintainability.\n      - Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large\n       drop in throughput on some files).\n     5/15/11 v1.09 - Initial stable release.\n\n   * Low-level Deflate/Inflate implementation notes:\n\n     Compression: Use the \"tdefl\" API's. The compressor supports raw, static, and dynamic blocks, lazy or\n     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses\n     approximately as well as zlib.\n\n     Decompression: Use the \"tinfl\" API's. The entire decompressor is implemented as a single function\n     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory\n     block large enough to hold the entire file.\n\n     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.\n\n   * zlib-style API notes:\n\n     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in\n     zlib replacement in many apps:\n        The z_stream struct, optional memory allocation callbacks\n        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound\n        inflateInit/inflateInit2/inflate/inflateEnd\n        compress, compress2, compressBound, uncompress\n        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.\n        Supports raw deflate streams or standard zlib streams with adler-32 checking.\n\n     Limitations:\n      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.\n      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but\n      there are no guarantees that miniz.c pulls this off perfectly.\n\n   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by\n     Alex Evans. Supports 1-4 bytes/pixel images.\n\n   * ZIP archive API notes:\n\n     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to\n     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from\n     existing archives, create new archives, append new files to existing archives, or clone archive data from\n     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),\n     or you can specify custom file read/write callbacks.\n\n     - Archive reading: Just call this function to read a single file from a disk archive:\n\n      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,\n        size_t *pSize, mz_uint zip_flags);\n\n     For more complex cases, use the \"mz_zip_reader\" functions. Upon opening an archive, the entire central\n     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.\n\n     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:\n\n     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);\n\n     The locate operation can optionally check file comments too, which (as one example) can be used to identify\n     multiple versions of the same file in an archive. This function uses a simple linear search through the central\n     directory, so it's not very fast.\n\n     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and\n     retrieve detailed info on each file by calling mz_zip_reader_file_stat().\n\n     - Archive creation: Use the \"mz_zip_writer\" functions. The ZIP writer immediately writes compressed file data\n     to disk and builds an exact image of the central directory in memory. The central directory image is written\n     all at once at the end of the archive file when the archive is finalized.\n\n     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,\n     which can be useful when the archive will be read from optical media. Also, the writer supports placing\n     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still\n     readable by any ZIP tool.\n\n     - Archive appending: The simple way to add a single file to an archive is to call this function:\n\n      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,\n        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);\n\n     The archive will be created if it doesn't already exist, otherwise it'll be appended to.\n     Note the appending is done in-place and is not an atomic operation, so if something goes wrong\n     during the operation it's possible the archive could be left without a central directory (although the local\n     file headers and file data will be fine, so the archive will be recoverable).\n\n     For more complex archive modification scenarios:\n     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to\n     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the\n     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and\n     you're done. This is safe but requires a bunch of temporary disk space or heap memory.\n\n     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),\n     append new files as needed, then finalize the archive which will write an updated central directory to the\n     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a\n     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.\n\n     - ZIP archive support limitations:\n     No zip64 or spanning support. Extraction functions can only handle unencrypted, stored or deflated files.\n     Requires streams capable of seeking.\n\n   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the\n     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.\n\n   * Important: For best perf. be sure to customize the below macros for your target platform:\n     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n     #define MINIZ_LITTLE_ENDIAN 1\n     #define MINIZ_HAS_64BIT_REGISTERS 1\n\n   * On platforms using glibc, Be sure to \"#define _LARGEFILE64_SOURCE 1\" before including miniz.c to ensure miniz\n     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files\n     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).\n*/\n\n#ifndef MINIZ_HEADER_INCLUDED\n#define MINIZ_HEADER_INCLUDED\n\n#include <stdlib.h>\n\n// Defines to completely disable specific portions of miniz.c:\n// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.\n\n// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O.\n//#define MINIZ_NO_STDIO\n\n// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or\n// get/set file times, and the C run-time funcs that get/set times won't be called.\n// The current downside is the times written to your archives will be from 1979.\n//#define MINIZ_NO_TIME\n\n// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.\n//#define MINIZ_NO_ARCHIVE_APIS\n\n// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive API's.\n//#define MINIZ_NO_ARCHIVE_WRITING_APIS\n\n// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's.\n//#define MINIZ_NO_ZLIB_APIS\n\n// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib.\n#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n\n// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.\n// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc\n// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user\n// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.\n//#define MINIZ_NO_MALLOC\n\n#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))\n  // TODO: Work around \"error: include file 'sys\\utime.h' when compiling with tcc on Linux\n  #define MINIZ_NO_TIME\n#endif\n\n#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)\n  #include <time.h>\n#endif\n\n#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)\n// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.\n#define MINIZ_X86_OR_X64_CPU 1\n#endif\n\n#if (__BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.\n#define MINIZ_LITTLE_ENDIAN 1\n#endif\n\n#if MINIZ_X86_OR_X64_CPU\n// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.\n#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n#endif\n\n#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)\n// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).\n#define MINIZ_HAS_64BIT_REGISTERS 1\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// ------------------- zlib-style API Definitions.\n\n// For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!\ntypedef unsigned long mz_ulong;\n\n// mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.\nvoid mz_free(void *p);\n\n#define MZ_ADLER32_INIT (1)\n// mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.\nmz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);\n\n#define MZ_CRC32_INIT (0)\n// mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.\nmz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);\n\n// Compression strategies.\nenum { MZ_DEFAULT_STRATEGY = 0, MZ_FILTERED = 1, MZ_HUFFMAN_ONLY = 2, MZ_RLE = 3, MZ_FIXED = 4 };\n\n// Method\n#define MZ_DEFLATED 8\n\n#ifndef MINIZ_NO_ZLIB_APIS\n\n// Heap allocation callbacks.\n// Note that mz_alloc_func parameter types purpsosely differ from zlib's: items/size is size_t, not unsigned long.\ntypedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);\ntypedef void (*mz_free_func)(void *opaque, void *address);\ntypedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items, size_t size);\n\n#define MZ_VERSION          \"9.1.15\"\n#define MZ_VERNUM           0x91F0\n#define MZ_VER_MAJOR        9\n#define MZ_VER_MINOR        1\n#define MZ_VER_REVISION     15\n#define MZ_VER_SUBREVISION  0\n\n// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs).\nenum { MZ_NO_FLUSH = 0, MZ_PARTIAL_FLUSH = 1, MZ_SYNC_FLUSH = 2, MZ_FULL_FLUSH = 3, MZ_FINISH = 4, MZ_BLOCK = 5 };\n\n// Return status codes. MZ_PARAM_ERROR is non-standard.\nenum { MZ_OK = 0, MZ_STREAM_END = 1, MZ_NEED_DICT = 2, MZ_ERRNO = -1, MZ_STREAM_ERROR = -2, MZ_DATA_ERROR = -3, MZ_MEM_ERROR = -4, MZ_BUF_ERROR = -5, MZ_VERSION_ERROR = -6, MZ_PARAM_ERROR = -10000 };\n\n// Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.\nenum { MZ_NO_COMPRESSION = 0, MZ_BEST_SPEED = 1, MZ_BEST_COMPRESSION = 9, MZ_UBER_COMPRESSION = 10, MZ_DEFAULT_LEVEL = 6, MZ_DEFAULT_COMPRESSION = -1 };\n\n// Window bits\n#define MZ_DEFAULT_WINDOW_BITS 15\n\nstruct mz_internal_state;\n\n// Compression/decompression stream struct.\ntypedef struct mz_stream_s\n{\n  const unsigned char *next_in;     // pointer to next byte to read\n  unsigned int avail_in;            // number of bytes available at next_in\n  mz_ulong total_in;                // total number of bytes consumed so far\n\n  unsigned char *next_out;          // pointer to next byte to write\n  unsigned int avail_out;           // number of bytes that can be written to next_out\n  mz_ulong total_out;               // total number of bytes produced so far\n\n  char *msg;                        // error msg (unused)\n  struct mz_internal_state *state;  // internal state, allocated by zalloc/zfree\n\n  mz_alloc_func zalloc;             // optional heap allocation function (defaults to malloc)\n  mz_free_func zfree;               // optional heap free function (defaults to free)\n  void *opaque;                     // heap alloc function user pointer\n\n  int data_type;                    // data_type (unused)\n  mz_ulong adler;                   // adler32 of the source or uncompressed data\n  mz_ulong reserved;                // not used\n} mz_stream;\n\ntypedef mz_stream *mz_streamp;\n\n// Returns the version string of miniz.c.\nconst char *mz_version(void);\n\n// mz_deflateInit() initializes a compressor with default options:\n// Parameters:\n//  pStream must point to an initialized mz_stream struct.\n//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].\n//  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio.\n//  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)\n// Return values:\n//  MZ_OK on success.\n//  MZ_STREAM_ERROR if the stream is bogus.\n//  MZ_PARAM_ERROR if the input parameters are bogus.\n//  MZ_MEM_ERROR on out of memory.\nint mz_deflateInit(mz_streamp pStream, int level);\n\n// mz_deflateInit2() is like mz_deflate(), except with more control:\n// Additional parameters:\n//   method must be MZ_DEFLATED\n//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer)\n//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)\nint mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);\n\n// Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().\nint mz_deflateReset(mz_streamp pStream);\n\n// mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible.\n// Parameters:\n//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.\n//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH.\n// Return values:\n//   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full).\n//   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore.\n//   MZ_STREAM_ERROR if the stream is bogus.\n//   MZ_PARAM_ERROR if one of the parameters is invalid.\n//   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.)\nint mz_deflate(mz_streamp pStream, int flush);\n\n// mz_deflateEnd() deinitializes a compressor:\n// Return values:\n//  MZ_OK on success.\n//  MZ_STREAM_ERROR if the stream is bogus.\nint mz_deflateEnd(mz_streamp pStream);\n\n// mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH.\nmz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);\n\n// Single-call compression functions mz_compress() and mz_compress2():\n// Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure.\nint mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);\nint mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);\n\n// mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress().\nmz_ulong mz_compressBound(mz_ulong source_len);\n\n// Initializes a decompressor.\nint mz_inflateInit(mz_streamp pStream);\n\n// mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer:\n// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate).\nint mz_inflateInit2(mz_streamp pStream, int window_bits);\n\n// Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible.\n// Parameters:\n//   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members.\n//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.\n//   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster).\n//   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data.\n// Return values:\n//   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full.\n//   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified.\n//   MZ_STREAM_ERROR if the stream is bogus.\n//   MZ_DATA_ERROR if the deflate stream is invalid.\n//   MZ_PARAM_ERROR if one of the parameters is invalid.\n//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again\n//   with more input data, or with more room in the output buffer (except when using single call decompression, described above).\nint mz_inflate(mz_streamp pStream, int flush);\n\n// Deinitializes a decompressor.\nint mz_inflateEnd(mz_streamp pStream);\n\n// Single-call decompression.\n// Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure.\nint mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);\n\n// Returns a string description of the specified error code, or NULL if the error code is invalid.\nconst char *mz_error(int err);\n\n// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports.\n// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project.\n#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n  typedef unsigned char Byte;\n  typedef unsigned int uInt;\n  typedef mz_ulong uLong;\n  typedef Byte Bytef;\n  typedef uInt uIntf;\n  typedef char charf;\n  typedef int intf;\n  typedef void *voidpf;\n  typedef uLong uLongf;\n  typedef void *voidp;\n  typedef void *const voidpc;\n  #define Z_NULL                0\n  #define Z_NO_FLUSH            MZ_NO_FLUSH\n  #define Z_PARTIAL_FLUSH       MZ_PARTIAL_FLUSH\n  #define Z_SYNC_FLUSH          MZ_SYNC_FLUSH\n  #define Z_FULL_FLUSH          MZ_FULL_FLUSH\n  #define Z_FINISH              MZ_FINISH\n  #define Z_BLOCK               MZ_BLOCK\n  #define Z_OK                  MZ_OK\n  #define Z_STREAM_END          MZ_STREAM_END\n  #define Z_NEED_DICT           MZ_NEED_DICT\n  #define Z_ERRNO               MZ_ERRNO\n  #define Z_STREAM_ERROR        MZ_STREAM_ERROR\n  #define Z_DATA_ERROR          MZ_DATA_ERROR\n  #define Z_MEM_ERROR           MZ_MEM_ERROR\n  #define Z_BUF_ERROR           MZ_BUF_ERROR\n  #define Z_VERSION_ERROR       MZ_VERSION_ERROR\n  #define Z_PARAM_ERROR         MZ_PARAM_ERROR\n  #define Z_NO_COMPRESSION      MZ_NO_COMPRESSION\n  #define Z_BEST_SPEED          MZ_BEST_SPEED\n  #define Z_BEST_COMPRESSION    MZ_BEST_COMPRESSION\n  #define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION\n  #define Z_DEFAULT_STRATEGY    MZ_DEFAULT_STRATEGY\n  #define Z_FILTERED            MZ_FILTERED\n  #define Z_HUFFMAN_ONLY        MZ_HUFFMAN_ONLY\n  #define Z_RLE                 MZ_RLE\n  #define Z_FIXED               MZ_FIXED\n  #define Z_DEFLATED            MZ_DEFLATED\n  #define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS\n  #define alloc_func            mz_alloc_func\n  #define free_func             mz_free_func\n  #define internal_state        mz_internal_state\n  #define z_stream              mz_stream\n  #define deflateInit           mz_deflateInit\n  #define deflateInit2          mz_deflateInit2\n  #define deflateReset          mz_deflateReset\n  #define deflate               mz_deflate\n  #define deflateEnd            mz_deflateEnd\n  #define deflateBound          mz_deflateBound\n  #define compress              mz_compress\n  #define compress2             mz_compress2\n  #define compressBound         mz_compressBound\n  #define inflateInit           mz_inflateInit\n  #define inflateInit2          mz_inflateInit2\n  #define inflate               mz_inflate\n  #define inflateEnd            mz_inflateEnd\n  #define uncompress            mz_uncompress\n  #define crc32                 mz_crc32\n  #define adler32               mz_adler32\n  #define MAX_WBITS             15\n  #define MAX_MEM_LEVEL         9\n  #define zError                mz_error\n  #define ZLIB_VERSION          MZ_VERSION\n  #define ZLIB_VERNUM           MZ_VERNUM\n  #define ZLIB_VER_MAJOR        MZ_VER_MAJOR\n  #define ZLIB_VER_MINOR        MZ_VER_MINOR\n  #define ZLIB_VER_REVISION     MZ_VER_REVISION\n  #define ZLIB_VER_SUBREVISION  MZ_VER_SUBREVISION\n  #define zlibVersion           mz_version\n  #define zlib_version          mz_version()\n#endif // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES\n\n#endif // MINIZ_NO_ZLIB_APIS\n\n// ------------------- Types and macros\n\ntypedef unsigned char mz_uint8;\ntypedef signed short mz_int16;\ntypedef unsigned short mz_uint16;\ntypedef unsigned int mz_uint32;\ntypedef unsigned int mz_uint;\ntypedef long long mz_int64;\ntypedef unsigned long long mz_uint64;\ntypedef int mz_bool;\n\n#define MZ_FALSE (0)\n#define MZ_TRUE (1)\n\n// An attempt to work around MSVC's spammy \"warning C4127: conditional expression is constant\" message.\n#ifdef _MSC_VER\n   #define MZ_MACRO_END while (0, 0)\n#else\n   #define MZ_MACRO_END while (0)\n#endif\n\n// ------------------- ZIP archive reading/writing\n\n#ifndef MINIZ_NO_ARCHIVE_APIS\n\nenum\n{\n  MZ_ZIP_MAX_IO_BUF_SIZE = 64*1024,\n  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,\n  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256\n};\n\ntypedef struct\n{\n  mz_uint32 m_file_index;\n  mz_uint32 m_central_dir_ofs;\n  mz_uint16 m_version_made_by;\n  mz_uint16 m_version_needed;\n  mz_uint16 m_bit_flag;\n  mz_uint16 m_method;\n#ifndef MINIZ_NO_TIME\n  time_t m_time;\n#endif\n  mz_uint32 m_crc32;\n  mz_uint64 m_comp_size;\n  mz_uint64 m_uncomp_size;\n  mz_uint16 m_internal_attr;\n  mz_uint32 m_external_attr;\n  mz_uint64 m_local_header_ofs;\n  mz_uint32 m_comment_size;\n  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];\n  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];\n} mz_zip_archive_file_stat;\n\ntypedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);\ntypedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);\n\nstruct mz_zip_internal_state_tag;\ntypedef struct mz_zip_internal_state_tag mz_zip_internal_state;\n\ntypedef enum\n{\n  MZ_ZIP_MODE_INVALID = 0,\n  MZ_ZIP_MODE_READING = 1,\n  MZ_ZIP_MODE_WRITING = 2,\n  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3\n} mz_zip_mode;\n\ntypedef struct mz_zip_archive_tag\n{\n  mz_uint64 m_archive_size;\n  mz_uint64 m_central_directory_file_ofs;\n  mz_uint m_total_files;\n  mz_zip_mode m_zip_mode;\n\n  mz_uint m_file_offset_alignment;\n\n  mz_alloc_func m_pAlloc;\n  mz_free_func m_pFree;\n  mz_realloc_func m_pRealloc;\n  void *m_pAlloc_opaque;\n\n  mz_file_read_func m_pRead;\n  mz_file_write_func m_pWrite;\n  void *m_pIO_opaque;\n\n  mz_zip_internal_state *m_pState;\n\n} mz_zip_archive;\n\ntypedef enum\n{\n  MZ_ZIP_FLAG_CASE_SENSITIVE                = 0x0100,\n  MZ_ZIP_FLAG_IGNORE_PATH                   = 0x0200,\n  MZ_ZIP_FLAG_COMPRESSED_DATA               = 0x0400,\n  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800\n} mz_zip_flags;\n\n// ZIP archive reading\n\n// Inits a ZIP archive reader.\n// These functions read and validate the archive's central directory.\nmz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags);\nmz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags);\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);\n#endif\n\n// Returns the total number of files in the archive.\nmz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);\n\n// Returns detailed information about an archive file entry.\nmz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);\n\n// Determines if an archive file entry is a directory entry.\nmz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);\nmz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);\n\n// Retrieves the filename of an archive file entry.\n// Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename.\nmz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);\n\n// Attempts to locates a file in the archive's central directory.\n// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH\n// Returns -1 if the file cannot be found.\nint mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);\n\n// Extracts a archive file to a memory buffer using no memory allocation.\nmz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);\nmz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);\n\n// Extracts a archive file to a memory buffer.\nmz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);\n\n// Extracts a archive file to a dynamically allocated heap buffer.\nvoid *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);\nvoid *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);\n\n// Extracts a archive file using a callback function to output the file's data.\nmz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);\n\n#ifndef MINIZ_NO_STDIO\n// Extracts a archive file to a disk file and sets its last accessed and modified times.\n// This function only extracts files, not archive directory records.\nmz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);\nmz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);\n#endif\n\n// Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used.\nmz_bool mz_zip_reader_end(mz_zip_archive *pZip);\n\n// ZIP archive writing\n\n#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n// Inits a ZIP archive writer.\nmz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);\nmz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);\n#endif\n\n// Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive.\n// For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called.\n// For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it).\n// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL.\n// Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before\n// the archive is finalized the file's central directory will be hosed.\nmz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);\n\n// Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive.\n// To add a directory entry, call this method with an archive name ending in a forwardslash with empty buffer.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);\nmz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);\n\n#ifndef MINIZ_NO_STDIO\n// Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);\n#endif\n\n// Adds a file to an archive by fully cloning the data from another archive.\n// This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data, and comment fields.\nmz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index);\n\n// Finalizes the archive by writing the central directory records followed by the end of central directory record.\n// After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end().\n// An archive must be manually finalized by calling this function for it to be valid.\nmz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);\nmz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize);\n\n// Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used.\n// Note for the archive to be valid, it must have been finalized before ending.\nmz_bool mz_zip_writer_end(mz_zip_archive *pZip);\n\n// Misc. high-level helper functions:\n\n// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive.\n// level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION.\nmz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);\n\n// Reads a single file from an archive into a heap block.\n// Returns NULL on failure.\nvoid *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint zip_flags);\n\n#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n#endif // #ifndef MINIZ_NO_ARCHIVE_APIS\n\n// ------------------- Low-level Decompression API Definitions\n\n// Decompression flags used by tinfl_decompress().\n// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.\n// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.\n// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).\n// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.\nenum\n{\n  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,\n  TINFL_FLAG_HAS_MORE_INPUT = 2,\n  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,\n  TINFL_FLAG_COMPUTE_ADLER32 = 8\n};\n\n// High level decompression functions:\n// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().\n// On entry:\n//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.\n// On return:\n//  Function returns a pointer to the decompressed data, or NULL on failure.\n//  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.\n//  The caller must call mz_free() on the returned block when it's no longer needed.\nvoid *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);\n\n// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.\n// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.\n#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))\nsize_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);\n\n// tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.\n// Returns 1 on success or 0 on failure.\ntypedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);\nint tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);\n\nstruct tinfl_decompressor_tag; typedef struct tinfl_decompressor_tag tinfl_decompressor;\n\n// Max size of LZ dictionary.\n#define TINFL_LZ_DICT_SIZE 32768\n\n// Return status.\ntypedef enum\n{\n  TINFL_STATUS_BAD_PARAM = -3,\n  TINFL_STATUS_ADLER32_MISMATCH = -2,\n  TINFL_STATUS_FAILED = -1,\n  TINFL_STATUS_DONE = 0,\n  TINFL_STATUS_NEEDS_MORE_INPUT = 1,\n  TINFL_STATUS_HAS_MORE_OUTPUT = 2\n} tinfl_status;\n\n// Initializes the decompressor to its initial state.\n#define tinfl_init(r) do { (r)->m_state = 0; } MZ_MACRO_END\n#define tinfl_get_adler32(r) (r)->m_check_adler32\n\n// Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.\n// This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.\ntinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);\n\n// Internal/private bits follow.\nenum\n{\n  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,\n  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS\n};\n\ntypedef struct\n{\n  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];\n  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];\n} tinfl_huff_table;\n\n#if MINIZ_HAS_64BIT_REGISTERS\n  #define TINFL_USE_64BIT_BITBUF 1\n#endif\n\n#if TINFL_USE_64BIT_BITBUF\n  typedef mz_uint64 tinfl_bit_buf_t;\n  #define TINFL_BITBUF_SIZE (64)\n#else\n  typedef mz_uint32 tinfl_bit_buf_t;\n  #define TINFL_BITBUF_SIZE (32)\n#endif\n\nstruct tinfl_decompressor_tag\n{\n  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];\n  tinfl_bit_buf_t m_bit_buf;\n  size_t m_dist_from_out_buf_start;\n  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];\n  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];\n};\n\n// ------------------- Low-level Compression API Definitions\n\n// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).\n#define TDEFL_LESS_MEMORY 0\n\n// tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):\n// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).\nenum\n{\n  TDEFL_HUFFMAN_ONLY = 0, TDEFL_DEFAULT_MAX_PROBES = 128, TDEFL_MAX_PROBES_MASK = 0xFFF\n};\n\n// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.\n// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).\n// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.\n// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).\n// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)\n// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.\n// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.\n// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.\n// The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK).\nenum\n{\n  TDEFL_WRITE_ZLIB_HEADER             = 0x01000,\n  TDEFL_COMPUTE_ADLER32               = 0x02000,\n  TDEFL_GREEDY_PARSING_FLAG           = 0x04000,\n  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,\n  TDEFL_RLE_MATCHES                   = 0x10000,\n  TDEFL_FILTER_MATCHES                = 0x20000,\n  TDEFL_FORCE_ALL_STATIC_BLOCKS       = 0x40000,\n  TDEFL_FORCE_ALL_RAW_BLOCKS          = 0x80000\n};\n\n// High level compression functions:\n// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().\n// On entry:\n//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.\n//  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.\n// On return:\n//  Function returns a pointer to the compressed data, or NULL on failure.\n//  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.\n//  The caller must free() the returned block when it's no longer needed.\nvoid *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);\n\n// tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.\n// Returns 0 on failure.\nsize_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);\n\n// Compresses an image to a compressed PNG file in memory.\n// On entry:\n//  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. \n//  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.\n//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL\n//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps).\n// On return:\n//  Function returns a pointer to the compressed data, or NULL on failure.\n//  *pLen_out will be set to the size of the PNG image file.\n//  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed.\nvoid *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);\nvoid *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);\n\n// Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.\ntypedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);\n\n// tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.\nmz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);\n\nenum { TDEFL_MAX_HUFF_TABLES = 3, TDEFL_MAX_HUFF_SYMBOLS_0 = 288, TDEFL_MAX_HUFF_SYMBOLS_1 = 32, TDEFL_MAX_HUFF_SYMBOLS_2 = 19, TDEFL_LZ_DICT_SIZE = 32768, TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1, TDEFL_MIN_MATCH_LEN = 3, TDEFL_MAX_MATCH_LEN = 258 };\n\n// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).\n#if TDEFL_LESS_MEMORY\nenum { TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 12, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };\n#else\nenum { TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };\n#endif\n\n// The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.\ntypedef enum\n{\n  TDEFL_STATUS_BAD_PARAM = -2,\n  TDEFL_STATUS_PUT_BUF_FAILED = -1,\n  TDEFL_STATUS_OKAY = 0,\n  TDEFL_STATUS_DONE = 1,\n} tdefl_status;\n\n// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums\ntypedef enum\n{\n  TDEFL_NO_FLUSH = 0,\n  TDEFL_SYNC_FLUSH = 2,\n  TDEFL_FULL_FLUSH = 3,\n  TDEFL_FINISH = 4\n} tdefl_flush;\n\n// tdefl's compression state structure.\ntypedef struct\n{\n  tdefl_put_buf_func_ptr m_pPut_buf_func;\n  void *m_pPut_buf_user;\n  mz_uint m_flags, m_max_probes[2];\n  int m_greedy_parsing;\n  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;\n  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;\n  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;\n  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;\n  tdefl_status m_prev_return_status;\n  const void *m_pIn_buf;\n  void *m_pOut_buf;\n  size_t *m_pIn_buf_size, *m_pOut_buf_size;\n  tdefl_flush m_flush;\n  const mz_uint8 *m_pSrc;\n  size_t m_src_buf_left, m_out_buf_ofs;\n  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];\n  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];\n  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];\n  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];\n  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];\n} tdefl_compressor;\n\n// Initializes the compressor.\n// There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.\n// pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.\n// If pBut_buf_func is NULL the user should always call the tdefl_compress() API.\n// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)\ntdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);\n\n// Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.\ntdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);\n\n// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.\n// tdefl_compress_buffer() always consumes the entire input buffer.\ntdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);\n\ntdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);\nmz_uint32 tdefl_get_adler32(tdefl_compressor *d);\n\n// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't defined, because it uses some of its macros.\n#ifndef MINIZ_NO_ZLIB_APIS\n// Create tdefl_compress() flags given zlib-style compression parameters.\n// level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files)\n// window_bits may be -15 (raw deflate) or 15 (zlib)\n// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED\nmz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);\n#endif // #ifndef MINIZ_NO_ZLIB_APIS\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // MINIZ_HEADER_INCLUDED\n\n// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)\n\n#ifndef MINIZ_HEADER_FILE_ONLY\n\ntypedef unsigned char mz_validate_uint16[sizeof(mz_uint16)==2 ? 1 : -1];\ntypedef unsigned char mz_validate_uint32[sizeof(mz_uint32)==4 ? 1 : -1];\ntypedef unsigned char mz_validate_uint64[sizeof(mz_uint64)==8 ? 1 : -1];\n\n#include <string.h>\n\n#ifndef MZ_ASSERT\n    #include <assert.h>\n    #define MZ_ASSERT(x) assert(x)\n#endif\n\n#ifdef MINIZ_NO_MALLOC\n  #define MZ_MALLOC(x) NULL\n  #define MZ_FREE(x) (void)x, ((void)0)\n  #define MZ_REALLOC(p, x) NULL\n#else\n  #define MZ_MALLOC(x) malloc(x)\n  #define MZ_FREE(x) free(x)\n  #define MZ_REALLOC(p, x) realloc(p, x)\n#endif\n\n#define MZ_MAX(a,b) (((a)>(b))?(a):(b))\n#define MZ_MIN(a,b) (((a)<(b))?(a):(b))\n#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  #define MZ_READ_LE16(p) *((const mz_uint16 *)(p))\n  #define MZ_READ_LE32(p) *((const mz_uint32 *)(p))\n#else\n  #define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))\n  #define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))\n#endif\n\n#ifdef _MSC_VER\n  #define MZ_FORCEINLINE __forceinline\n#elif defined(__GNUC__)\n  #define MZ_FORCEINLINE inline __attribute__((__always_inline__))\n#else\n  #define MZ_FORCEINLINE inline\n#endif\n\n#ifdef __cplusplus\n  extern \"C\" {\n#endif\n\n// ------------------- zlib-style API's\n\nmz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)\n{\n  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16); size_t block_len = buf_len % 5552;\n  if (!ptr) return MZ_ADLER32_INIT;\n  while (buf_len) {\n    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {\n      s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;\n      s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;\n    }\n    for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n    s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;\n  }\n  return (s2 << 16) + s1;\n}\n\n// Karl Malbrain's compact CRC-32. See \"A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed\": http://www.geocities.com/malbrain/\nmz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)\n{\n  static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };\n  mz_uint32 crcu32 = (mz_uint32)crc;\n  if (!ptr) return MZ_CRC32_INIT;\n  crcu32 = ~crcu32; while (buf_len--) { mz_uint8 b = *ptr++; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)]; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)]; }\n  return ~crcu32;\n}\n\nvoid mz_free(void *p)\n{\n  MZ_FREE(p);\n}\n\n#ifndef MINIZ_NO_ZLIB_APIS\n\nstatic void *def_alloc_func(void *opaque, size_t items, size_t size) { (void)opaque, (void)items, (void)size; return MZ_MALLOC(items * size); }\nstatic void def_free_func(void *opaque, void *address) { (void)opaque, (void)address; MZ_FREE(address); }\nstatic void *def_realloc_func(void *opaque, void *address, size_t items, size_t size) { (void)opaque, (void)address, (void)items, (void)size; return MZ_REALLOC(address, items * size); }\n\nconst char *mz_version(void)\n{\n  return MZ_VERSION;\n}\n\nint mz_deflateInit(mz_streamp pStream, int level)\n{\n  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);\n}\n\nint mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)\n{\n  tdefl_compressor *pComp;\n  mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);\n\n  if (!pStream) return MZ_STREAM_ERROR;\n  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))) return MZ_PARAM_ERROR;\n\n  pStream->data_type = 0;\n  pStream->adler = MZ_ADLER32_INIT;\n  pStream->msg = NULL;\n  pStream->reserved = 0;\n  pStream->total_in = 0;\n  pStream->total_out = 0;\n  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;\n  if (!pStream->zfree) pStream->zfree = def_free_func;\n\n  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));\n  if (!pComp)\n    return MZ_MEM_ERROR;\n\n  pStream->state = (struct mz_internal_state *)pComp;\n\n  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)\n  {\n    mz_deflateEnd(pStream);\n    return MZ_PARAM_ERROR;\n  }\n\n  return MZ_OK;\n}\n\nint mz_deflateReset(mz_streamp pStream)\n{\n  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree)) return MZ_STREAM_ERROR;\n  pStream->total_in = pStream->total_out = 0;\n  tdefl_init((tdefl_compressor*)pStream->state, NULL, NULL, ((tdefl_compressor*)pStream->state)->m_flags);\n  return MZ_OK;\n}\n\nint mz_deflate(mz_streamp pStream, int flush)\n{\n  size_t in_bytes, out_bytes;\n  mz_ulong orig_total_in, orig_total_out;\n  int mz_status = MZ_OK;\n\n  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out)) return MZ_STREAM_ERROR;\n  if (!pStream->avail_out) return MZ_BUF_ERROR;\n\n  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;\n\n  if (((tdefl_compressor*)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)\n    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;\n\n  orig_total_in = pStream->total_in; orig_total_out = pStream->total_out;\n  for ( ; ; )\n  {\n    tdefl_status defl_status;\n    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;\n\n    defl_status = tdefl_compress((tdefl_compressor*)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);\n    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tdefl_get_adler32((tdefl_compressor*)pStream->state);\n\n    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes;\n    pStream->total_out += (mz_uint)out_bytes;\n\n    if (defl_status < 0)\n    {\n      mz_status = MZ_STREAM_ERROR;\n      break;\n    }\n    else if (defl_status == TDEFL_STATUS_DONE)\n    {\n      mz_status = MZ_STREAM_END;\n      break;\n    }\n    else if (!pStream->avail_out)\n      break;\n    else if ((!pStream->avail_in) && (flush != MZ_FINISH))\n    {\n      if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))\n        break;\n      return MZ_BUF_ERROR; // Can't make forward progress without some input.\n    }\n  }\n  return mz_status;\n}\n\nint mz_deflateEnd(mz_streamp pStream)\n{\n  if (!pStream) return MZ_STREAM_ERROR;\n  if (pStream->state)\n  {\n    pStream->zfree(pStream->opaque, pStream->state);\n    pStream->state = NULL;\n  }\n  return MZ_OK;\n}\n\nmz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)\n{\n  (void)pStream;\n  // This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.)\n  return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);\n}\n\nint mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)\n{\n  int status;\n  mz_stream stream;\n  memset(&stream, 0, sizeof(stream));\n\n  // In case mz_ulong is 64-bits (argh I hate longs).\n  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;\n\n  stream.next_in = pSource;\n  stream.avail_in = (mz_uint32)source_len;\n  stream.next_out = pDest;\n  stream.avail_out = (mz_uint32)*pDest_len;\n\n  status = mz_deflateInit(&stream, level);\n  if (status != MZ_OK) return status;\n\n  status = mz_deflate(&stream, MZ_FINISH);\n  if (status != MZ_STREAM_END)\n  {\n    mz_deflateEnd(&stream);\n    return (status == MZ_OK) ? MZ_BUF_ERROR : status;\n  }\n\n  *pDest_len = stream.total_out;\n  return mz_deflateEnd(&stream);\n}\n\nint mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)\n{\n  return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);\n}\n\nmz_ulong mz_compressBound(mz_ulong source_len)\n{\n  return mz_deflateBound(NULL, source_len);\n}\n\ntypedef struct\n{\n  tinfl_decompressor m_decomp;\n  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed; int m_window_bits;\n  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];\n  tinfl_status m_last_status;\n} inflate_state;\n\nint mz_inflateInit2(mz_streamp pStream, int window_bits)\n{\n  inflate_state *pDecomp;\n  if (!pStream) return MZ_STREAM_ERROR;\n  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)) return MZ_PARAM_ERROR;\n\n  pStream->data_type = 0;\n  pStream->adler = 0;\n  pStream->msg = NULL;\n  pStream->total_in = 0;\n  pStream->total_out = 0;\n  pStream->reserved = 0;\n  if (!pStream->zalloc) pStream->zalloc = def_alloc_func;\n  if (!pStream->zfree) pStream->zfree = def_free_func;\n\n  pDecomp = (inflate_state*)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));\n  if (!pDecomp) return MZ_MEM_ERROR;\n\n  pStream->state = (struct mz_internal_state *)pDecomp;\n\n  tinfl_init(&pDecomp->m_decomp);\n  pDecomp->m_dict_ofs = 0;\n  pDecomp->m_dict_avail = 0;\n  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;\n  pDecomp->m_first_call = 1;\n  pDecomp->m_has_flushed = 0;\n  pDecomp->m_window_bits = window_bits;\n\n  return MZ_OK;\n}\n\nint mz_inflateInit(mz_streamp pStream)\n{\n   return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);\n}\n\nint mz_inflate(mz_streamp pStream, int flush)\n{\n  inflate_state* pState;\n  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;\n  size_t in_bytes, out_bytes, orig_avail_in;\n  tinfl_status status;\n\n  if ((!pStream) || (!pStream->state)) return MZ_STREAM_ERROR;\n  if (flush == MZ_PARTIAL_FLUSH) flush = MZ_SYNC_FLUSH;\n  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;\n\n  pState = (inflate_state*)pStream->state;\n  if (pState->m_window_bits > 0) decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;\n  orig_avail_in = pStream->avail_in;\n\n  first_call = pState->m_first_call; pState->m_first_call = 0;\n  if (pState->m_last_status < 0) return MZ_DATA_ERROR;\n\n  if (pState->m_has_flushed && (flush != MZ_FINISH)) return MZ_STREAM_ERROR;\n  pState->m_has_flushed |= (flush == MZ_FINISH);\n\n  if ((flush == MZ_FINISH) && (first_call))\n  {\n    // MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file.\n    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;\n    in_bytes = pStream->avail_in; out_bytes = pStream->avail_out;\n    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);\n    pState->m_last_status = status;\n    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes; pStream->total_in += (mz_uint)in_bytes;\n    pStream->adler = tinfl_get_adler32(&pState->m_decomp);\n    pStream->next_out += (mz_uint)out_bytes; pStream->avail_out -= (mz_uint)out_bytes; pStream->total_out += (mz_uint)out_bytes;\n\n    if (status < 0)\n      return MZ_DATA_ERROR;\n    else if (status != TINFL_STATUS_DONE)\n    {\n      pState->m_last_status = TINFL_STATUS_FAILED;\n      return MZ_BUF_ERROR;\n    }\n    return MZ_STREAM_END;\n  }\n  // flush != MZ_FINISH then we must assume there's more input.\n  if (flush != MZ_FINISH) decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;\n\n  if (pState->m_dict_avail)\n  {\n    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);\n    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);\n    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;\n    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);\n    return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;\n  }\n\n  for ( ; ; )\n  {\n    in_bytes = pStream->avail_in;\n    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;\n\n    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);\n    pState->m_last_status = status;\n\n    pStream->next_in += (mz_uint)in_bytes; pStream->avail_in -= (mz_uint)in_bytes;\n    pStream->total_in += (mz_uint)in_bytes; pStream->adler = tinfl_get_adler32(&pState->m_decomp);\n\n    pState->m_dict_avail = (mz_uint)out_bytes;\n\n    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);\n    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);\n    pStream->next_out += n; pStream->avail_out -= n; pStream->total_out += n;\n    pState->m_dict_avail -= n; pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);\n\n    if (status < 0)\n       return MZ_DATA_ERROR; // Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well).\n    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))\n      return MZ_BUF_ERROR; // Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH.\n    else if (flush == MZ_FINISH)\n    {\n       // The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH.\n       if (status == TINFL_STATUS_DONE)\n          return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;\n       // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong.\n       else if (!pStream->avail_out)\n          return MZ_BUF_ERROR;\n    }\n    else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))\n      break;\n  }\n\n  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;\n}\n\nint mz_inflateEnd(mz_streamp pStream)\n{\n  if (!pStream)\n    return MZ_STREAM_ERROR;\n  if (pStream->state)\n  {\n    pStream->zfree(pStream->opaque, pStream->state);\n    pStream->state = NULL;\n  }\n  return MZ_OK;\n}\n\nint mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)\n{\n  mz_stream stream;\n  int status;\n  memset(&stream, 0, sizeof(stream));\n\n  // In case mz_ulong is 64-bits (argh I hate longs).\n  if ((source_len | *pDest_len) > 0xFFFFFFFFU) return MZ_PARAM_ERROR;\n\n  stream.next_in = pSource;\n  stream.avail_in = (mz_uint32)source_len;\n  stream.next_out = pDest;\n  stream.avail_out = (mz_uint32)*pDest_len;\n\n  status = mz_inflateInit(&stream);\n  if (status != MZ_OK)\n    return status;\n\n  status = mz_inflate(&stream, MZ_FINISH);\n  if (status != MZ_STREAM_END)\n  {\n    mz_inflateEnd(&stream);\n    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;\n  }\n  *pDest_len = stream.total_out;\n\n  return mz_inflateEnd(&stream);\n}\n\nconst char *mz_error(int err)\n{\n  static struct { int m_err; const char *m_pDesc; } s_error_descs[] =\n  {\n    { MZ_OK, \"\" }, { MZ_STREAM_END, \"stream end\" }, { MZ_NEED_DICT, \"need dictionary\" }, { MZ_ERRNO, \"file error\" }, { MZ_STREAM_ERROR, \"stream error\" },\n    { MZ_DATA_ERROR, \"data error\" }, { MZ_MEM_ERROR, \"out of memory\" }, { MZ_BUF_ERROR, \"buf error\" }, { MZ_VERSION_ERROR, \"version error\" }, { MZ_PARAM_ERROR, \"parameter error\" }\n  };\n  mz_uint i; for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i) if (s_error_descs[i].m_err == err) return s_error_descs[i].m_pDesc;\n  return NULL;\n}\n\n#endif //MINIZ_NO_ZLIB_APIS\n\n// ------------------- Low-level Decompression (completely independent from all compression API's)\n\n#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)\n#define TINFL_MEMSET(p, c, l) memset(p, c, l)\n\n#define TINFL_CR_BEGIN switch(r->m_state) { case 0:\n#define TINFL_CR_RETURN(state_index, result) do { status = result; r->m_state = state_index; goto common_exit; case state_index:; } MZ_MACRO_END\n#define TINFL_CR_RETURN_FOREVER(state_index, result) do { for ( ; ; ) { TINFL_CR_RETURN(state_index, result); } } MZ_MACRO_END\n#define TINFL_CR_FINISH }\n\n// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never\n// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.\n#define TINFL_GET_BYTE(state_index, c) do { \\\n  if (pIn_buf_cur >= pIn_buf_end) { \\\n    for ( ; ; ) { \\\n      if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) { \\\n        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \\\n        if (pIn_buf_cur < pIn_buf_end) { \\\n          c = *pIn_buf_cur++; \\\n          break; \\\n        } \\\n      } else { \\\n        c = 0; \\\n        break; \\\n      } \\\n    } \\\n  } else c = *pIn_buf_cur++; } MZ_MACRO_END\n\n#define TINFL_NEED_BITS(state_index, n) do { mz_uint c; TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; } while (num_bits < (mz_uint)(n))\n#define TINFL_SKIP_BITS(state_index, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END\n#define TINFL_GET_BITS(state_index, b, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } b = bit_buf & ((1 << (n)) - 1); bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END\n\n// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.\n// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a\n// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the\n// bit buffer contains >=15 bits (deflate's max. Huffman code size).\n#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff) \\\n  do { \\\n    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \\\n    if (temp >= 0) { \\\n      code_len = temp >> 9; \\\n      if ((code_len) && (num_bits >= code_len)) \\\n      break; \\\n    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) { \\\n       code_len = TINFL_FAST_LOOKUP_BITS; \\\n       do { \\\n          temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \\\n       } while ((temp < 0) && (num_bits >= (code_len + 1))); if (temp >= 0) break; \\\n    } TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; \\\n  } while (num_bits < 15);\n\n// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read\n// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully\n// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.\n// The slow path is only executed at the very end of the input buffer.\n#define TINFL_HUFF_DECODE(state_index, sym, pHuff) do { \\\n  int temp; mz_uint code_len, c; \\\n  if (num_bits < 15) { \\\n    if ((pIn_buf_end - pIn_buf_cur) < 2) { \\\n       TINFL_HUFF_BITBUF_FILL(state_index, pHuff); \\\n    } else { \\\n       bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); pIn_buf_cur += 2; num_bits += 16; \\\n    } \\\n  } \\\n  if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0) \\\n    code_len = temp >> 9, temp &= 511; \\\n  else { \\\n    code_len = TINFL_FAST_LOOKUP_BITS; do { temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; } while (temp < 0); \\\n  } sym = temp; bit_buf >>= code_len; num_bits -= code_len; } MZ_MACRO_END\n\ntinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)\n{\n  static const int s_length_base[31] = { 3,4,5,6,7,8,9,10,11,13, 15,17,19,23,27,31,35,43,51,59, 67,83,99,115,131,163,195,227,258,0,0 };\n  static const int s_length_extra[31]= { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\n  static const int s_dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193, 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\n  static const int s_dist_extra[32] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n  static const mz_uint8 s_length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\n  static const int s_min_table_sizes[3] = { 257, 1, 4 };\n\n  tinfl_status status = TINFL_STATUS_FAILED; mz_uint32 num_bits, dist, counter, num_extra; tinfl_bit_buf_t bit_buf;\n  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;\n  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;\n  size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;\n\n  // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).\n  if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) { *pIn_buf_size = *pOut_buf_size = 0; return TINFL_STATUS_BAD_PARAM; }\n\n  num_bits = r->m_num_bits; bit_buf = r->m_bit_buf; dist = r->m_dist; counter = r->m_counter; num_extra = r->m_num_extra; dist_from_out_buf_start = r->m_dist_from_out_buf_start;\n  TINFL_CR_BEGIN\n\n  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0; r->m_z_adler32 = r->m_check_adler32 = 1;\n  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)\n  {\n    TINFL_GET_BYTE(1, r->m_zhdr0); TINFL_GET_BYTE(2, r->m_zhdr1);\n    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));\n    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) counter |= (((1ULL << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1ULL << (8U + (r->m_zhdr0 >> 4)))));\n    if (counter) { TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED); }\n  }\n\n  do\n  {\n    TINFL_GET_BITS(3, r->m_final, 3); r->m_type = r->m_final >> 1;\n    if (r->m_type == 0)\n    {\n      TINFL_SKIP_BITS(5, num_bits & 7);\n      for (counter = 0; counter < 4; ++counter) { if (num_bits) TINFL_GET_BITS(6, r->m_raw_header[counter], 8); else TINFL_GET_BYTE(7, r->m_raw_header[counter]); }\n      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) { TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED); }\n      while ((counter) && (num_bits))\n      {\n        TINFL_GET_BITS(51, dist, 8);\n        while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT); }\n        *pOut_buf_cur++ = (mz_uint8)dist;\n        counter--;\n      }\n      while (counter)\n      {\n        size_t n; while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT); }\n        while (pIn_buf_cur >= pIn_buf_end)\n        {\n          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT)\n          {\n            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);\n          }\n          else\n          {\n            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);\n          }\n        }\n        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);\n        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n); pIn_buf_cur += n; pOut_buf_cur += n; counter -= (mz_uint)n;\n      }\n    }\n    else if (r->m_type == 3)\n    {\n      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);\n    }\n    else\n    {\n      if (r->m_type == 1)\n      {\n        mz_uint8 *p = r->m_tables[0].m_code_size; mz_uint i;\n        r->m_table_sizes[0] = 288; r->m_table_sizes[1] = 32; TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);\n        for ( i = 0; i <= 143; ++i) *p++ = 8; for ( ; i <= 255; ++i) *p++ = 9; for ( ; i <= 279; ++i) *p++ = 7; for ( ; i <= 287; ++i) *p++ = 8;\n      }\n      else\n      {\n        for (counter = 0; counter < 3; counter++) { TINFL_GET_BITS(11, r->m_table_sizes[counter], \"\\05\\05\\04\"[counter]); r->m_table_sizes[counter] += s_min_table_sizes[counter]; }\n        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size); for (counter = 0; counter < r->m_table_sizes[2]; counter++) { mz_uint s; TINFL_GET_BITS(14, s, 3); r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s; }\n        r->m_table_sizes[2] = 19;\n      }\n      for ( ; (int)r->m_type >= 0; r->m_type--)\n      {\n        int tree_next, tree_cur; tinfl_huff_table *pTable;\n        mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16]; pTable = &r->m_tables[r->m_type]; MZ_CLEAR_OBJ(total_syms); MZ_CLEAR_OBJ(pTable->m_look_up); MZ_CLEAR_OBJ(pTable->m_tree);\n        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i) total_syms[pTable->m_code_size[i]]++;\n        used_syms = 0, total = 0; next_code[0] = next_code[1] = 0;\n        for (i = 1; i <= 15; ++i) { used_syms += total_syms[i]; next_code[i + 1] = (total = ((total + total_syms[i]) << 1)); }\n        if ((65536 != total) && (used_syms > 1))\n        {\n          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);\n        }\n        for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)\n        {\n          mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index]; if (!code_size) continue;\n          cur_code = next_code[code_size]++; for (l = code_size; l > 0; l--, cur_code >>= 1) rev_code = (rev_code << 1) | (cur_code & 1);\n          if (code_size <= TINFL_FAST_LOOKUP_BITS) { mz_int16 k = (mz_int16)((code_size << 9) | sym_index); while (rev_code < TINFL_FAST_LOOKUP_SIZE) { pTable->m_look_up[rev_code] = k; rev_code += (1 << code_size); } continue; }\n          if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) { pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; }\n          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);\n          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)\n          {\n            tree_cur -= ((rev_code >>= 1) & 1);\n            if (!pTable->m_tree[-tree_cur - 1]) { pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; } else tree_cur = pTable->m_tree[-tree_cur - 1];\n          }\n          tree_cur -= ((rev_code >>= 1) & 1); pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;\n        }\n        if (r->m_type == 2)\n        {\n          for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]); )\n          {\n            mz_uint s; TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]); if (dist < 16) { r->m_len_codes[counter++] = (mz_uint8)dist; continue; }\n            if ((dist == 16) && (!counter))\n            {\n              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);\n            }\n            num_extra = \"\\02\\03\\07\"[dist - 16]; TINFL_GET_BITS(18, s, num_extra); s += \"\\03\\03\\013\"[dist - 16];\n            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s); counter += s;\n          }\n          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)\n          {\n            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);\n          }\n          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]); TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);\n        }\n      }\n      for ( ; ; )\n      {\n        mz_uint8 *pSrc;\n        for ( ; ; )\n        {\n          if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))\n          {\n            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);\n            if (counter >= 256)\n              break;\n            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT); }\n            *pOut_buf_cur++ = (mz_uint8)counter;\n          }\n          else\n          {\n            int sym2; mz_uint code_len;\n#if TINFL_USE_64BIT_BITBUF\n            if (num_bits < 30) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits); pIn_buf_cur += 4; num_bits += 32; }\n#else\n            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }\n#endif\n            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)\n              code_len = sym2 >> 9;\n            else\n            {\n              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);\n            }\n            counter = sym2; bit_buf >>= code_len; num_bits -= code_len;\n            if (counter & 256)\n              break;\n\n#if !TINFL_USE_64BIT_BITBUF\n            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }\n#endif\n            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)\n              code_len = sym2 >> 9;\n            else\n            {\n              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);\n            }\n            bit_buf >>= code_len; num_bits -= code_len;\n\n            pOut_buf_cur[0] = (mz_uint8)counter;\n            if (sym2 & 256)\n            {\n              pOut_buf_cur++;\n              counter = sym2;\n              break;\n            }\n            pOut_buf_cur[1] = (mz_uint8)sym2;\n            pOut_buf_cur += 2;\n          }\n        }\n        if ((counter &= 511) == 256) break;\n\n        num_extra = s_length_extra[counter - 257]; counter = s_length_base[counter - 257];\n        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(25, extra_bits, num_extra); counter += extra_bits; }\n\n        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);\n        num_extra = s_dist_extra[dist]; dist = s_dist_base[dist];\n        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(27, extra_bits, num_extra); dist += extra_bits; }\n\n        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;\n        if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))\n        {\n          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);\n        }\n\n        pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);\n\n        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)\n        {\n          while (counter--)\n          {\n            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT); }\n            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];\n          }\n          continue;\n        }\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n        else if ((counter >= 9) && (counter <= dist))\n        {\n          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);\n          do\n          {\n            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];\n            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];\n            pOut_buf_cur += 8;\n          } while ((pSrc += 8) < pSrc_end);\n          if ((counter &= 7) < 3)\n          {\n            if (counter)\n            {\n              pOut_buf_cur[0] = pSrc[0];\n              if (counter > 1)\n                pOut_buf_cur[1] = pSrc[1];\n              pOut_buf_cur += counter;\n            }\n            continue;\n          }\n        }\n#endif\n        do\n        {\n          pOut_buf_cur[0] = pSrc[0];\n          pOut_buf_cur[1] = pSrc[1];\n          pOut_buf_cur[2] = pSrc[2];\n          pOut_buf_cur += 3; pSrc += 3;\n        } while ((int)(counter -= 3) > 2);\n        if ((int)counter > 0)\n        {\n          pOut_buf_cur[0] = pSrc[0];\n          if ((int)counter > 1)\n            pOut_buf_cur[1] = pSrc[1];\n          pOut_buf_cur += counter;\n        }\n      }\n    }\n  } while (!(r->m_final & 1));\n  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)\n  {\n    TINFL_SKIP_BITS(32, num_bits & 7); for (counter = 0; counter < 4; ++counter) { mz_uint s; if (num_bits) TINFL_GET_BITS(41, s, 8); else TINFL_GET_BYTE(42, s); r->m_z_adler32 = (r->m_z_adler32 << 8) | s; }\n  }\n  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);\n  TINFL_CR_FINISH\n\ncommon_exit:\n  r->m_num_bits = num_bits; r->m_bit_buf = bit_buf; r->m_dist = dist; r->m_counter = counter; r->m_num_extra = num_extra; r->m_dist_from_out_buf_start = dist_from_out_buf_start;\n  *pIn_buf_size = pIn_buf_cur - pIn_buf_next; *pOut_buf_size = pOut_buf_cur - pOut_buf_next;\n  if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))\n  {\n    const mz_uint8 *ptr = pOut_buf_next; size_t buf_len = *pOut_buf_size;\n    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16; size_t block_len = buf_len % 5552;\n    while (buf_len)\n    {\n      for (i = 0; i + 7 < block_len; i += 8, ptr += 8)\n      {\n        s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;\n        s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;\n      }\n      for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n      s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;\n    }\n    r->m_check_adler32 = (s2 << 16) + s1; if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32)) status = TINFL_STATUS_ADLER32_MISMATCH;\n  }\n  return status;\n}\n\n// Higher level helper functions.\nvoid *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)\n{\n  tinfl_decompressor decomp; void *pBuf = NULL, *pNew_buf; size_t src_buf_ofs = 0, out_buf_capacity = 0;\n  *pOut_len = 0;\n  tinfl_init(&decomp);\n  for ( ; ; )\n  {\n    size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;\n    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf, pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,\n      (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))\n    {\n      MZ_FREE(pBuf); *pOut_len = 0; return NULL;\n    }\n    src_buf_ofs += src_buf_size;\n    *pOut_len += dst_buf_size;\n    if (status == TINFL_STATUS_DONE) break;\n    new_out_buf_capacity = out_buf_capacity * 2; if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;\n    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);\n    if (!pNew_buf)\n    {\n      MZ_FREE(pBuf); *pOut_len = 0; return NULL;\n    }\n    pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity;\n  }\n  return pBuf;\n}\n\nsize_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)\n{\n  tinfl_decompressor decomp; tinfl_status status; tinfl_init(&decomp);\n  status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;\n}\n\nint tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)\n{\n  int result = 0;\n  tinfl_decompressor decomp;\n  mz_uint8 *pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE); size_t in_buf_ofs = 0, dict_ofs = 0;\n  if (!pDict)\n    return TINFL_STATUS_FAILED;\n  tinfl_init(&decomp);\n  for ( ; ; )\n  {\n    size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;\n    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,\n      (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));\n    in_buf_ofs += in_buf_size;\n    if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))\n      break;\n    if (status != TINFL_STATUS_HAS_MORE_OUTPUT)\n    {\n      result = (status == TINFL_STATUS_DONE);\n      break;\n    }\n    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);\n  }\n  MZ_FREE(pDict);\n  *pIn_buf_size = in_buf_ofs;\n  return result;\n}\n\n// ------------------- Low-level Compression (independent from all decompression API's)\n\n// Purposely making these tables static for faster init and thread safety.\nstatic const mz_uint16 s_tdefl_len_sym[256] = {\n  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,\n  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,\n  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,\n  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,\n  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,\n  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,\n  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,\n  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };\n\nstatic const mz_uint8 s_tdefl_len_extra[256] = {\n  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };\n\nstatic const mz_uint8 s_tdefl_small_dist_sym[512] = {\n  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,\n  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,\n  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,\n  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,\n  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,\n  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };\n\nstatic const mz_uint8 s_tdefl_small_dist_extra[512] = {\n  0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7 };\n\nstatic const mz_uint8 s_tdefl_large_dist_sym[128] = {\n  0,0,18,19,20,20,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,\n  26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,\n  28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29 };\n\nstatic const mz_uint8 s_tdefl_large_dist_extra[128] = {\n  0,0,8,8,9,9,9,9,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,\n  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,\n  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13 };\n\n// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.\ntypedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;\nstatic tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1)\n{\n  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2]; tdefl_sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1; MZ_CLEAR_OBJ(hist);\n  for (i = 0; i < num_syms; i++) { mz_uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; }\n  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;\n  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)\n  {\n    const mz_uint32* pHist = &hist[pass << 8];\n    mz_uint offsets[256], cur_ofs = 0;\n    for (i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }\n    for (i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];\n    { tdefl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }\n  }\n  return pCur_syms;\n}\n\n// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.\nstatic void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)\n{\n  int root, leaf, next, avbl, used, dpth;\n  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }\n  A[0].m_key += A[1].m_key; root = 0; leaf = 2;\n  for (next=1; next < n-1; next++)\n  {\n    if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = (mz_uint16)next; } else A[next].m_key = A[leaf++].m_key;\n    if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key); A[root++].m_key = (mz_uint16)next; } else A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);\n  }\n  A[n-2].m_key = 0; for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;\n  avbl = 1; used = dpth = 0; root = n-2; next = n-1;\n  while (avbl>0)\n  {\n    while (root>=0 && (int)A[root].m_key==dpth) { used++; root--; }\n    while (avbl>used) { A[next--].m_key = (mz_uint16)(dpth); avbl--; }\n    avbl = 2*used; dpth++; used = 0;\n  }\n}\n\n// Limits canonical Huffman code table's max code size.\nenum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };\nstatic void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)\n{\n  int i; mz_uint32 total = 0; if (code_list_len <= 1) return;\n  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];\n  for (i = max_code_size; i > 0; i--) total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));\n  while (total != (1UL << max_code_size))\n  {\n    pNum_codes[max_code_size]--;\n    for (i = max_code_size - 1; i > 0; i--) if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }\n    total--;\n  }\n}\n\nstatic void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)\n{\n  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE]; mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; MZ_CLEAR_OBJ(num_codes);\n  if (static_table)\n  {\n    for (i = 0; i < table_len; i++) num_codes[d->m_huff_code_sizes[table_num][i]]++;\n  }\n  else\n  {\n    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;\n    int num_used_syms = 0;\n    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];\n    for (i = 0; i < table_len; i++) if (pSym_count[i]) { syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (mz_uint16)i; }\n\n    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1); tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);\n\n    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;\n\n    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);\n\n    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]); MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);\n    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)\n      for (l = num_codes[i]; l > 0; l--) d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);\n  }\n\n  next_code[1] = 0; for (j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1);\n\n  for (i = 0; i < table_len; i++)\n  {\n    mz_uint rev_code = 0, code, code_size; if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;\n    code = next_code[code_size]++; for (l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1);\n    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;\n  }\n}\n\n#define TDEFL_PUT_BITS(b, l) do { \\\n  mz_uint bits = b; mz_uint len = l; MZ_ASSERT(bits <= ((1U << len) - 1U)); \\\n  d->m_bit_buffer |= (bits << d->m_bits_in); d->m_bits_in += len; \\\n  while (d->m_bits_in >= 8) { \\\n    if (d->m_pOutput_buf < d->m_pOutput_buf_end) \\\n      *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \\\n      d->m_bit_buffer >>= 8; \\\n      d->m_bits_in -= 8; \\\n  } \\\n} MZ_MACRO_END\n\n#define TDEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \\\n  if (rle_repeat_count < 3) { \\\n    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \\\n    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \\\n  } else { \\\n    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3); \\\n} rle_repeat_count = 0; } }\n\n#define TDEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \\\n  if (rle_z_count < 3) { \\\n    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \\\n  } else if (rle_z_count <= 10) { \\\n    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3); \\\n  } else { \\\n    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \\\n} rle_z_count = 0; } }\n\nstatic mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };\n\nstatic void tdefl_start_dynamic_block(tdefl_compressor *d)\n{\n  int num_lit_codes, num_dist_codes, num_bit_lengths; mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;\n  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;\n\n  d->m_huff_count[0][256] = 1;\n\n  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);\n  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);\n\n  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--) if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;\n  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--) if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;\n\n  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);\n  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);\n  total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;\n\n  memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);\n  for (i = 0; i < total_code_sizes_to_pack; i++)\n  {\n    mz_uint8 code_size = code_sizes_to_pack[i];\n    if (!code_size)\n    {\n      TDEFL_RLE_PREV_CODE_SIZE();\n      if (++rle_z_count == 138) { TDEFL_RLE_ZERO_CODE_SIZE(); }\n    }\n    else\n    {\n      TDEFL_RLE_ZERO_CODE_SIZE();\n      if (code_size != prev_code_size)\n      {\n        TDEFL_RLE_PREV_CODE_SIZE();\n        d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;\n      }\n      else if (++rle_repeat_count == 6)\n      {\n        TDEFL_RLE_PREV_CODE_SIZE();\n      }\n    }\n    prev_code_size = code_size;\n  }\n  if (rle_repeat_count) { TDEFL_RLE_PREV_CODE_SIZE(); } else { TDEFL_RLE_ZERO_CODE_SIZE(); }\n\n  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);\n\n  TDEFL_PUT_BITS(2, 2);\n\n  TDEFL_PUT_BITS(num_lit_codes - 257, 5);\n  TDEFL_PUT_BITS(num_dist_codes - 1, 5);\n\n  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--) if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;\n  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1)); TDEFL_PUT_BITS(num_bit_lengths - 4, 4);\n  for (i = 0; (int)i < num_bit_lengths; i++) TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);\n\n  for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes; )\n  {\n    mz_uint code = packed_code_sizes[packed_code_sizes_index++]; MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);\n    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);\n    if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], \"\\02\\03\\07\"[code - 16]);\n  }\n}\n\nstatic void tdefl_start_static_block(tdefl_compressor *d)\n{\n  mz_uint i;\n  mz_uint8 *p = &d->m_huff_code_sizes[0][0];\n\n  for (i = 0; i <= 143; ++i) *p++ = 8;\n  for ( ; i <= 255; ++i) *p++ = 9;\n  for ( ; i <= 279; ++i) *p++ = 7;\n  for ( ; i <= 287; ++i) *p++ = 8;\n\n  memset(d->m_huff_code_sizes[1], 5, 32);\n\n  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);\n  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);\n\n  TDEFL_PUT_BITS(1, 2);\n}\n\nstatic const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS\nstatic mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)\n{\n  mz_uint flags;\n  mz_uint8 *pLZ_codes;\n  mz_uint8 *pOutput_buf = d->m_pOutput_buf;\n  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;\n  mz_uint64 bit_buffer = d->m_bit_buffer;\n  mz_uint bits_in = d->m_bits_in;\n\n#define TDEFL_PUT_BITS_FAST(b, l) { bit_buffer |= (((mz_uint64)(b)) << bits_in); bits_in += (l); }\n\n  flags = 1;\n  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)\n  {\n    if (flags == 1)\n      flags = *pLZ_codes++ | 0x100;\n\n    if (flags & 1)\n    {\n      mz_uint s0, s1, n0, n1, sym, num_extra_bits;\n      mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16 *)(pLZ_codes + 1); pLZ_codes += 3;\n\n      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);\n\n      // This sequence coaxes MSVC into using cmov's vs. jmp's.\n      s0 = s_tdefl_small_dist_sym[match_dist & 511];\n      n0 = s_tdefl_small_dist_extra[match_dist & 511];\n      s1 = s_tdefl_large_dist_sym[match_dist >> 8];\n      n1 = s_tdefl_large_dist_extra[match_dist >> 8];\n      sym = (match_dist < 512) ? s0 : s1;\n      num_extra_bits = (match_dist < 512) ? n0 : n1;\n\n      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);\n    }\n    else\n    {\n      mz_uint lit = *pLZ_codes++;\n      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n\n      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))\n      {\n        flags >>= 1;\n        lit = *pLZ_codes++;\n        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n\n        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))\n        {\n          flags >>= 1;\n          lit = *pLZ_codes++;\n          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n        }\n      }\n    }\n\n    if (pOutput_buf >= d->m_pOutput_buf_end)\n      return MZ_FALSE;\n\n    *(mz_uint64*)pOutput_buf = bit_buffer;\n    pOutput_buf += (bits_in >> 3);\n    bit_buffer >>= (bits_in & ~7);\n    bits_in &= 7;\n  }\n\n#undef TDEFL_PUT_BITS_FAST\n\n  d->m_pOutput_buf = pOutput_buf;\n  d->m_bits_in = 0;\n  d->m_bit_buffer = 0;\n\n  while (bits_in)\n  {\n    mz_uint32 n = MZ_MIN(bits_in, 16);\n    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);\n    bit_buffer >>= n;\n    bits_in -= n;\n  }\n\n  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n\n  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n}\n#else\nstatic mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)\n{\n  mz_uint flags;\n  mz_uint8 *pLZ_codes;\n\n  flags = 1;\n  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)\n  {\n    if (flags == 1)\n      flags = *pLZ_codes++ | 0x100;\n    if (flags & 1)\n    {\n      mz_uint sym, num_extra_bits;\n      mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8)); pLZ_codes += 3;\n\n      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);\n\n      if (match_dist < 512)\n      {\n        sym = s_tdefl_small_dist_sym[match_dist]; num_extra_bits = s_tdefl_small_dist_extra[match_dist];\n      }\n      else\n      {\n        sym = s_tdefl_large_dist_sym[match_dist >> 8]; num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];\n      }\n      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);\n      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);\n    }\n    else\n    {\n      mz_uint lit = *pLZ_codes++;\n      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n    }\n  }\n\n  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n\n  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n}\n#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS\n\nstatic mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)\n{\n  if (static_block)\n    tdefl_start_static_block(d);\n  else\n    tdefl_start_dynamic_block(d);\n  return tdefl_compress_lz_codes(d);\n}\n\nstatic int tdefl_flush_block(tdefl_compressor *d, int flush)\n{\n  mz_uint saved_bit_buf, saved_bits_in;\n  mz_uint8 *pSaved_output_buf;\n  mz_bool comp_block_succeeded = MZ_FALSE;\n  int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;\n  mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;\n\n  d->m_pOutput_buf = pOutput_buf_start;\n  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;\n\n  MZ_ASSERT(!d->m_output_flush_remaining);\n  d->m_output_flush_ofs = 0;\n  d->m_output_flush_remaining = 0;\n\n  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);\n  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);\n\n  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))\n  {\n    TDEFL_PUT_BITS(0x78, 8); TDEFL_PUT_BITS(0x01, 8);\n  }\n\n  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);\n\n  pSaved_output_buf = d->m_pOutput_buf; saved_bit_buf = d->m_bit_buffer; saved_bits_in = d->m_bits_in;\n\n  if (!use_raw_block)\n    comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));\n\n  // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.\n  if ( ((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&\n       ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size) )\n  {\n    mz_uint i; d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n    TDEFL_PUT_BITS(0, 2);\n    if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }\n    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)\n    {\n      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);\n    }\n    for (i = 0; i < d->m_total_lz_bytes; ++i)\n    {\n      TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);\n    }\n  }\n  // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.\n  else if (!comp_block_succeeded)\n  {\n    d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n    tdefl_compress_block(d, MZ_TRUE);\n  }\n\n  if (flush)\n  {\n    if (flush == TDEFL_FINISH)\n    {\n      if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }\n      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) { mz_uint i, a = d->m_adler32; for (i = 0; i < 4; i++) { TDEFL_PUT_BITS((a >> 24) & 0xFF, 8); a <<= 8; } }\n    }\n    else\n    {\n      mz_uint i, z = 0; TDEFL_PUT_BITS(0, 3); if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); } for (i = 2; i; --i, z ^= 0xFFFF) { TDEFL_PUT_BITS(z & 0xFFFF, 16); }\n    }\n  }\n\n  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);\n\n  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n\n  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8; d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes; d->m_total_lz_bytes = 0; d->m_block_index++;\n\n  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)\n  {\n    if (d->m_pPut_buf_func)\n    {\n      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))\n        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);\n    }\n    else if (pOutput_buf_start == d->m_output_buf)\n    {\n      int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));\n      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);\n      d->m_out_buf_ofs += bytes_to_copy;\n      if ((n -= bytes_to_copy) != 0)\n      {\n        d->m_output_flush_ofs = bytes_to_copy;\n        d->m_output_flush_remaining = n;\n      }\n    }\n    else\n    {\n      d->m_out_buf_ofs += n;\n    }\n  }\n\n  return d->m_output_flush_remaining;\n}\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)\nstatic MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)\n{\n  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;\n  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n  const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;\n  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);\n  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;\n  for ( ; ; )\n  {\n    for ( ; ; )\n    {\n      if (--num_probes_left == 0) return;\n      #define TDEFL_PROBE \\\n        next_probe_pos = d->m_next[probe_pos]; \\\n        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \\\n        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \\\n        if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;\n      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;\n    }\n    if (!dist) break; q = (const mz_uint16*)(d->m_dict + probe_pos); if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue; p = s; probe_len = 32;\n    do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n                   (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );\n    if (!probe_len)\n    {\n      *pMatch_dist = dist; *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN); break;\n    }\n    else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len)\n    {\n      *pMatch_dist = dist; if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;\n      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);\n    }\n  }\n}\n#else\nstatic MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)\n{\n  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;\n  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n  const mz_uint8 *s = d->m_dict + pos, *p, *q;\n  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];\n  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;\n  for ( ; ; )\n  {\n    for ( ; ; )\n    {\n      if (--num_probes_left == 0) return;\n      #define TDEFL_PROBE \\\n        next_probe_pos = d->m_next[probe_pos]; \\\n        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \\\n        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \\\n        if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;\n      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;\n    }\n    if (!dist) break; p = s; q = d->m_dict + probe_pos; for (probe_len = 0; probe_len < max_match_len; probe_len++) if (*p++ != *q++) break;\n    if (probe_len > match_len)\n    {\n      *pMatch_dist = dist; if ((*pMatch_len = match_len = probe_len) == max_match_len) return;\n      c0 = d->m_dict[pos + match_len]; c1 = d->m_dict[pos + match_len - 1];\n    }\n  }\n}\n#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\nstatic mz_bool tdefl_compress_fast(tdefl_compressor *d)\n{\n  // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.\n  mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;\n  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;\n  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n\n  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))\n  {\n    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;\n    mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;\n    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);\n    d->m_src_buf_left -= num_bytes_to_process;\n    lookahead_size += num_bytes_to_process;\n\n    while (num_bytes_to_process)\n    {\n      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);\n      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);\n      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));\n      d->m_pSrc += n;\n      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;\n      num_bytes_to_process -= n;\n    }\n\n    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);\n    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;\n\n    while (lookahead_size >= 4)\n    {\n      mz_uint cur_match_dist, cur_match_len = 1;\n      mz_uint8 *pCur_dict = d->m_dict + cur_pos;\n      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;\n      mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;\n      mz_uint probe_pos = d->m_hash[hash];\n      d->m_hash[hash] = (mz_uint16)lookahead_pos;\n\n      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))\n      {\n        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;\n        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);\n        mz_uint32 probe_len = 32;\n        do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n          (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );\n        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);\n        if (!probe_len)\n          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;\n\n        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)))\n        {\n          cur_match_len = 1;\n          *pLZ_code_buf++ = (mz_uint8)first_trigram;\n          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n          d->m_huff_count[0][(mz_uint8)first_trigram]++;\n        }\n        else\n        {\n          mz_uint32 s0, s1;\n          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);\n\n          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));\n\n          cur_match_dist--;\n\n          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);\n          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;\n          pLZ_code_buf += 3;\n          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);\n\n          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];\n          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];\n          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;\n\n          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;\n        }\n      }\n      else\n      {\n        *pLZ_code_buf++ = (mz_uint8)first_trigram;\n        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n        d->m_huff_count[0][(mz_uint8)first_trigram]++;\n      }\n\n      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }\n\n      total_lz_bytes += cur_match_len;\n      lookahead_pos += cur_match_len;\n      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);\n      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;\n      MZ_ASSERT(lookahead_size >= cur_match_len);\n      lookahead_size -= cur_match_len;\n\n      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])\n      {\n        int n;\n        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;\n        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;\n        if ((n = tdefl_flush_block(d, 0)) != 0)\n          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;\n      }\n    }\n\n    while (lookahead_size)\n    {\n      mz_uint8 lit = d->m_dict[cur_pos];\n\n      total_lz_bytes++;\n      *pLZ_code_buf++ = lit;\n      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }\n\n      d->m_huff_count[0][lit]++;\n\n      lookahead_pos++;\n      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);\n      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;\n      lookahead_size--;\n\n      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])\n      {\n        int n;\n        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;\n        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;\n        if ((n = tdefl_flush_block(d, 0)) != 0)\n          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;\n      }\n    }\n  }\n\n  d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;\n  d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;\n  return MZ_TRUE;\n}\n#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n\nstatic MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)\n{\n  d->m_total_lz_bytes++;\n  *d->m_pLZ_code_buf++ = lit;\n  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }\n  d->m_huff_count[0][lit]++;\n}\n\nstatic MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)\n{\n  mz_uint32 s0, s1;\n\n  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));\n\n  d->m_total_lz_bytes += match_len;\n\n  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);\n\n  match_dist -= 1;\n  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);\n  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8); d->m_pLZ_code_buf += 3;\n\n  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }\n\n  s0 = s_tdefl_small_dist_sym[match_dist & 511]; s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];\n  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;\n\n  if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;\n}\n\nstatic mz_bool tdefl_compress_normal(tdefl_compressor *d)\n{\n  const mz_uint8 *pSrc = d->m_pSrc; size_t src_buf_left = d->m_src_buf_left;\n  tdefl_flush flush = d->m_flush;\n\n  while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))\n  {\n    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;\n    // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.\n    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))\n    {\n      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;\n      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];\n      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);\n      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;\n      src_buf_left -= num_bytes_to_process;\n      d->m_lookahead_size += num_bytes_to_process;\n      while (pSrc != pSrc_end)\n      {\n        mz_uint8 c = *pSrc++; d->m_dict[dst_pos] = c; if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);\n        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);\n        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK; ins_pos++;\n      }\n    }\n    else\n    {\n      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))\n      {\n        mz_uint8 c = *pSrc++;\n        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;\n        src_buf_left--;\n        d->m_dict[dst_pos] = c;\n        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)\n        {\n          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;\n          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);\n          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);\n        }\n      }\n    }\n    d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);\n    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))\n      break;\n\n    // Simple lazy/greedy parsing state machine.\n    len_to_move = 1; cur_match_dist = 0; cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1); cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))\n    {\n      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))\n      {\n        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];\n        cur_match_len = 0; while (cur_match_len < d->m_lookahead_size) { if (d->m_dict[cur_pos + cur_match_len] != c) break; cur_match_len++; }\n        if (cur_match_len < TDEFL_MIN_MATCH_LEN) cur_match_len = 0; else cur_match_dist = 1;\n      }\n    }\n    else\n    {\n      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);\n    }\n    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))\n    {\n      cur_match_dist = cur_match_len = 0;\n    }\n    if (d->m_saved_match_len)\n    {\n      if (cur_match_len > d->m_saved_match_len)\n      {\n        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);\n        if (cur_match_len >= 128)\n        {\n          tdefl_record_match(d, cur_match_len, cur_match_dist);\n          d->m_saved_match_len = 0; len_to_move = cur_match_len;\n        }\n        else\n        {\n          d->m_saved_lit = d->m_dict[cur_pos]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;\n        }\n      }\n      else\n      {\n        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);\n        len_to_move = d->m_saved_match_len - 1; d->m_saved_match_len = 0;\n      }\n    }\n    else if (!cur_match_dist)\n      tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);\n    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))\n    {\n      tdefl_record_match(d, cur_match_len, cur_match_dist);\n      len_to_move = cur_match_len;\n    }\n    else\n    {\n      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;\n    }\n    // Move the lookahead forward by len_to_move bytes.\n    d->m_lookahead_pos += len_to_move;\n    MZ_ASSERT(d->m_lookahead_size >= len_to_move);\n    d->m_lookahead_size -= len_to_move;\n    d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);\n    // Check if it's time to flush the current LZ codes to the internal output buffer.\n    if ( (d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||\n         ( (d->m_total_lz_bytes > 31*1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) )\n    {\n      int n;\n      d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;\n      if ((n = tdefl_flush_block(d, 0)) != 0)\n        return (n < 0) ? MZ_FALSE : MZ_TRUE;\n    }\n  }\n\n  d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;\n  return MZ_TRUE;\n}\n\nstatic tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)\n{\n  if (d->m_pIn_buf_size)\n  {\n    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n  }\n\n  if (d->m_pOut_buf_size)\n  {\n    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);\n    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);\n    d->m_output_flush_ofs += (mz_uint)n;\n    d->m_output_flush_remaining -= (mz_uint)n;\n    d->m_out_buf_ofs += n;\n\n    *d->m_pOut_buf_size = d->m_out_buf_ofs;\n  }\n\n  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;\n}\n\ntdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)\n{\n  if (!d)\n  {\n    if (pIn_buf_size) *pIn_buf_size = 0;\n    if (pOut_buf_size) *pOut_buf_size = 0;\n    return TDEFL_STATUS_BAD_PARAM;\n  }\n\n  d->m_pIn_buf = pIn_buf; d->m_pIn_buf_size = pIn_buf_size;\n  d->m_pOut_buf = pOut_buf; d->m_pOut_buf_size = pOut_buf_size;\n  d->m_pSrc = (const mz_uint8 *)(pIn_buf); d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;\n  d->m_out_buf_ofs = 0;\n  d->m_flush = flush;\n\n  if ( ((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||\n        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf) )\n  {\n    if (pIn_buf_size) *pIn_buf_size = 0;\n    if (pOut_buf_size) *pOut_buf_size = 0;\n    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);\n  }\n  d->m_wants_to_finish |= (flush == TDEFL_FINISH);\n\n  if ((d->m_output_flush_remaining) || (d->m_finished))\n    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n\n#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&\n      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&\n      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))\n  {\n    if (!tdefl_compress_fast(d))\n      return d->m_prev_return_status;\n  }\n  else\n#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n  {\n    if (!tdefl_compress_normal(d))\n      return d->m_prev_return_status;\n  }\n\n  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))\n    d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);\n\n  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))\n  {\n    if (tdefl_flush_block(d, flush) < 0)\n      return d->m_prev_return_status;\n    d->m_finished = (flush == TDEFL_FINISH);\n    if (flush == TDEFL_FULL_FLUSH) { MZ_CLEAR_OBJ(d->m_hash); MZ_CLEAR_OBJ(d->m_next); d->m_dict_size = 0; }\n  }\n\n  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n}\n\ntdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)\n{\n  MZ_ASSERT(d->m_pPut_buf_func); return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);\n}\n\ntdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)\n{\n  d->m_pPut_buf_func = pPut_buf_func; d->m_pPut_buf_user = pPut_buf_user;\n  d->m_flags = (mz_uint)(flags); d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3; d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;\n  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;\n  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);\n  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;\n  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;\n  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8;\n  d->m_pOutput_buf = d->m_output_buf; d->m_pOutput_buf_end = d->m_output_buf; d->m_prev_return_status = TDEFL_STATUS_OKAY;\n  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0; d->m_adler32 = 1;\n  d->m_pIn_buf = NULL; d->m_pOut_buf = NULL;\n  d->m_pIn_buf_size = NULL; d->m_pOut_buf_size = NULL;\n  d->m_flush = TDEFL_NO_FLUSH; d->m_pSrc = NULL; d->m_src_buf_left = 0; d->m_out_buf_ofs = 0;\n  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n  return TDEFL_STATUS_OKAY;\n}\n\ntdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)\n{\n  return d->m_prev_return_status;\n}\n\nmz_uint32 tdefl_get_adler32(tdefl_compressor *d)\n{\n  return d->m_adler32;\n}\n\nmz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)\n{\n  tdefl_compressor *pComp; mz_bool succeeded; if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;\n  pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor)); if (!pComp) return MZ_FALSE;\n  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);\n  succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);\n  MZ_FREE(pComp); return succeeded;\n}\n\ntypedef struct\n{\n  size_t m_size, m_capacity;\n  mz_uint8 *m_pBuf;\n  mz_bool m_expandable;\n} tdefl_output_buffer;\n\nstatic mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)\n{\n  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;\n  size_t new_size = p->m_size + len;\n  if (new_size > p->m_capacity)\n  {\n    size_t new_capacity = p->m_capacity; mz_uint8 *pNew_buf; if (!p->m_expandable) return MZ_FALSE;\n    do { new_capacity = MZ_MAX(128U, new_capacity << 1U); } while (new_size > new_capacity);\n    pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity); if (!pNew_buf) return MZ_FALSE;\n    p->m_pBuf = pNew_buf; p->m_capacity = new_capacity;\n  }\n  memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len); p->m_size = new_size;\n  return MZ_TRUE;\n}\n\nvoid *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)\n{\n  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);\n  if (!pOut_len) return MZ_FALSE; else *pOut_len = 0;\n  out_buf.m_expandable = MZ_TRUE;\n  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;\n  *pOut_len = out_buf.m_size; return out_buf.m_pBuf;\n}\n\nsize_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)\n{\n  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);\n  if (!pOut_buf) return 0;\n  out_buf.m_pBuf = (mz_uint8*)pOut_buf; out_buf.m_capacity = out_buf_len;\n  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;\n  return out_buf.m_size;\n}\n\n#ifndef MINIZ_NO_ZLIB_APIS\nstatic const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };\n\n// level may actually range from [0,10] (10 is a \"hidden\" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files).\nmz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)\n{\n  mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);\n  if (window_bits > 0) comp_flags |= TDEFL_WRITE_ZLIB_HEADER;\n\n  if (!level) comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;\n  else if (strategy == MZ_FILTERED) comp_flags |= TDEFL_FILTER_MATCHES;\n  else if (strategy == MZ_HUFFMAN_ONLY) comp_flags &= ~TDEFL_MAX_PROBES_MASK;\n  else if (strategy == MZ_FIXED) comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;\n  else if (strategy == MZ_RLE) comp_flags |= TDEFL_RLE_MATCHES;\n\n  return comp_flags;\n}\n#endif //MINIZ_NO_ZLIB_APIS\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable:4204) // nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal)\n#endif\n\n// Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at\n// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.\n// This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck.\nvoid *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)\n{\n  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined.\n  static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32,  16, 32, 128, 256,  512, 768, 1500 };\n  tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor)); tdefl_output_buffer out_buf; int i, bpl = w * num_chans, y, z; mz_uint32 c; *pLen_out = 0;\n  if (!pComp) return NULL;\n  MZ_CLEAR_OBJ(out_buf); out_buf.m_expandable = MZ_TRUE; out_buf.m_capacity = 57+MZ_MAX(64, (1+bpl)*h); if (NULL == (out_buf.m_pBuf = (mz_uint8*)MZ_MALLOC(out_buf.m_capacity))) { MZ_FREE(pComp); return NULL; }\n  // write dummy header\n  for (z = 41; z; --z) tdefl_output_buffer_putter(&z, 1, &out_buf);\n  // compress image data\n  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);\n  for (y = 0; y < h; ++y) { tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH); tdefl_compress_buffer(pComp, (mz_uint8*)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH); }\n  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE) { MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }\n  // write real header\n  *pLen_out = out_buf.m_size-41;\n  {\n    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};\n    mz_uint8 pnghdr[41]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,\n      0,0,(mz_uint8)(w>>8),(mz_uint8)w,0,0,(mz_uint8)(h>>8),(mz_uint8)h,8,chans[num_chans],0,0,0,0,0,0,0,\n      (mz_uint8)(*pLen_out>>24),(mz_uint8)(*pLen_out>>16),(mz_uint8)(*pLen_out>>8),(mz_uint8)*pLen_out,0x49,0x44,0x41,0x54};\n    c=(mz_uint32)mz_crc32(MZ_CRC32_INIT,pnghdr+12,17); for (i=0; i<4; ++i, c<<=8) ((mz_uint8*)(pnghdr+29))[i]=(mz_uint8)(c>>24);\n    memcpy(out_buf.m_pBuf, pnghdr, 41);\n  }\n  // write footer (IDAT CRC-32, followed by IEND chunk)\n  if (!tdefl_output_buffer_putter(\"\\0\\0\\0\\0\\0\\0\\0\\0\\x49\\x45\\x4e\\x44\\xae\\x42\\x60\\x82\", 16, &out_buf)) { *pLen_out = 0; MZ_FREE(pComp); MZ_FREE(out_buf.m_pBuf); return NULL; }\n  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT,out_buf.m_pBuf+41-4, *pLen_out+4); for (i=0; i<4; ++i, c<<=8) (out_buf.m_pBuf+out_buf.m_size-16)[i] = (mz_uint8)(c >> 24);\n  // compute final size of file, grab compressed data buffer and return\n  *pLen_out += 57; MZ_FREE(pComp); return out_buf.m_pBuf;\n}\nvoid *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)\n{\n  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out)\n  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);\n}\n\n#ifdef _MSC_VER\n#pragma warning (pop)\n#endif\n\n// ------------------- .ZIP archive reading\n\n#ifndef MINIZ_NO_ARCHIVE_APIS\n\n#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))\n\n// Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff.\nenum\n{\n  // ZIP archive identifiers and record sizes\n  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50, MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50, MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,\n  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,\n  // Central directory header record offsets\n  MZ_ZIP_CDH_SIG_OFS = 0, MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4, MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6, MZ_ZIP_CDH_BIT_FLAG_OFS = 8,\n  MZ_ZIP_CDH_METHOD_OFS = 10, MZ_ZIP_CDH_FILE_TIME_OFS = 12, MZ_ZIP_CDH_FILE_DATE_OFS = 14, MZ_ZIP_CDH_CRC32_OFS = 16,\n  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20, MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24, MZ_ZIP_CDH_FILENAME_LEN_OFS = 28, MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,\n  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32, MZ_ZIP_CDH_DISK_START_OFS = 34, MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36, MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38, MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,\n  // Local directory header offsets\n  MZ_ZIP_LDH_SIG_OFS = 0, MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4, MZ_ZIP_LDH_BIT_FLAG_OFS = 6, MZ_ZIP_LDH_METHOD_OFS = 8, MZ_ZIP_LDH_FILE_TIME_OFS = 10,\n  MZ_ZIP_LDH_FILE_DATE_OFS = 12, MZ_ZIP_LDH_CRC32_OFS = 14, MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18, MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,\n  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26, MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,\n  // End of central directory offsets\n  MZ_ZIP_ECDH_SIG_OFS = 0, MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4, MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6, MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,\n  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10, MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12, MZ_ZIP_ECDH_CDIR_OFS_OFS = 16, MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,\n};\n\ntypedef struct\n{\n  void *m_p;\n  size_t m_size, m_capacity;\n  mz_uint m_element_size;\n} mz_zip_array;\n\nstruct mz_zip_internal_state_tag\n{\n  mz_zip_array m_central_dir;\n  mz_zip_array m_central_dir_offsets;\n  mz_zip_array m_sorted_central_dir_offsets;\n  MZ_FILE *m_pFile;\n  void *m_pMem;\n  size_t m_mem_size;\n  size_t m_mem_capacity;\n};\n\n#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size\n#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]\n\nstatic MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)\n{\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);\n  memset(pArray, 0, sizeof(mz_zip_array));\n}\n\nstatic mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)\n{\n  void *pNew_p; size_t new_capacity = min_new_capacity; MZ_ASSERT(pArray->m_element_size); if (pArray->m_capacity >= min_new_capacity) return MZ_TRUE;\n  if (growing) { new_capacity = MZ_MAX(1, pArray->m_capacity); while (new_capacity < min_new_capacity) new_capacity *= 2; }\n  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, new_capacity))) return MZ_FALSE;\n  pArray->m_p = pNew_p; pArray->m_capacity = new_capacity;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)\n{\n  if (new_capacity > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing)) return MZ_FALSE; }\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)\n{\n  if (new_size > pArray->m_capacity) { if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing)) return MZ_FALSE; }\n  pArray->m_size = new_size;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)\n{\n  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)\n{\n  size_t orig_size = pArray->m_size; if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE)) return MZ_FALSE;\n  memcpy((mz_uint8*)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_TIME\nstatic time_t mz_zip_dos_to_time_t(int dos_time, int dos_date)\n{\n  struct tm tm;\n  memset(&tm, 0, sizeof(tm)); tm.tm_isdst = -1;\n  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900; tm.tm_mon = ((dos_date >> 5) & 15) - 1; tm.tm_mday = dos_date & 31;\n  tm.tm_hour = (dos_time >> 11) & 31; tm.tm_min = (dos_time >> 5) & 63; tm.tm_sec = (dos_time << 1) & 62;\n  return mktime(&tm);\n}\n\nstatic void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1400 \n  struct tm tm_struct;\n  struct tm *tm = &tm_struct;\n  errno_t err = localtime_s(tm, &time);\n  if (err)\n  {\n    *pDOS_date = 0; *pDOS_time = 0;\n    return;\n  }\n#else\n  struct tm *tm = localtime(&time);\n#endif\n  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));\n  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);\n}\n#endif\n\n#ifndef MINIZ_NO_STDIO\nstatic mz_bool mz_zip_get_file_modified_time(const char *pFilename, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)\n{\n#ifdef MINIZ_NO_TIME\n  (void)pFilename; *pDOS_date = *pDOS_time = 0;\n#else\n  struct MZ_FILE_STAT_STRUCT file_stat;\n  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.\n  if (MZ_FILE_STAT(pFilename, &file_stat) != 0)\n    return MZ_FALSE;\n  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);\n#endif // #ifdef MINIZ_NO_TIME\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_TIME\nstatic mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time, time_t modified_time)\n{\n  struct utimbuf t; t.actime = access_time; t.modtime = modified_time;\n  return !utime(pFilename, &t);\n}\n#endif // #ifndef MINIZ_NO_TIME\n#endif // #ifndef MINIZ_NO_STDIO\n\nstatic mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint32 flags)\n{\n  (void)flags;\n  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))\n    return MZ_FALSE;\n\n  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;\n  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;\n  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_READING;\n  pZip->m_archive_size = 0;\n  pZip->m_central_directory_file_ofs = 0;\n  pZip->m_total_files = 0;\n\n  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))\n    return MZ_FALSE;\n  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)\n{\n  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;\n  const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));\n  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  mz_uint8 l = 0, r = 0;\n  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE; pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pE = pL + MZ_MIN(l_len, r_len);\n  while (pL < pE)\n  {\n    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))\n      break;\n    pL++; pR++;\n  }\n  return (pL == pE) ? (l_len < r_len) : (l < r);\n}\n\n#define MZ_SWAP_UINT32(a, b) do { mz_uint32 t = a; a = b; b = t; } MZ_MACRO_END\n\n// Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.)\nstatic void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)\n{\n  mz_zip_internal_state *pState = pZip->m_pState;\n  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;\n  const mz_zip_array *pCentral_dir = &pState->m_central_dir;\n  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);\n  const int size = pZip->m_total_files;\n  int start = (size - 2) >> 1, end;\n  while (start >= 0)\n  {\n    int child, root = start;\n    for ( ; ; )\n    {\n      if ((child = (root << 1) + 1) >= size)\n        break;\n      child += (((child + 1) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1])));\n      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))\n        break;\n      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;\n    }\n    start--;\n  }\n\n  end = size - 1;\n  while (end > 0)\n  {\n    int child, root = 0;\n    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);\n    for ( ; ; )\n    {\n      if ((child = (root << 1) + 1) >= end)\n        break;\n      child += (((child + 1) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1]));\n      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))\n        break;\n      MZ_SWAP_UINT32(pIndices[root], pIndices[child]); root = child;\n    }\n    end--;\n  }\n}\n\nstatic mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint32 flags)\n{\n  mz_uint cdir_size, num_this_disk, cdir_disk_index;\n  mz_uint64 cdir_ofs;\n  mz_int64 cur_file_ofs;\n  const mz_uint8 *p;\n  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)]; mz_uint8 *pBuf = (mz_uint8 *)buf_u32;\n  mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);\n  // Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there.\n  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  // Find the end of central directory record by scanning the file from the end towards the beginning.\n  cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);\n  for ( ; ; )\n  {\n    int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)\n      return MZ_FALSE;\n    for (i = n - 4; i >= 0; --i)\n      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)\n        break;\n    if (i >= 0)\n    {\n      cur_file_ofs += i;\n      break;\n    }\n    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))\n      return MZ_FALSE;\n    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);\n  }\n  // Read and verify the end of central directory record.\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||\n      ((pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) != MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))\n    return MZ_FALSE;\n\n  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);\n  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);\n  if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))\n    return MZ_FALSE;\n\n  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) < pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n\n  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);\n  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  pZip->m_central_directory_file_ofs = cdir_ofs;\n\n  if (pZip->m_total_files)\n  {\n     mz_uint i, n;\n\n    // Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and another to hold the sorted indices.\n    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||\n        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))\n      return MZ_FALSE;\n\n    if (sort_central_dir)\n    {\n      if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))\n        return MZ_FALSE;\n    }\n\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)\n      return MZ_FALSE;\n\n    // Now create an index into the central directory file records, do some basic sanity checking on each record, and check for zip64 entries (which are not yet supported).\n    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;\n    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)\n    {\n      mz_uint total_header_size, comp_size, decomp_size, disk_index;\n      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))\n        return MZ_FALSE;\n      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);\n      if (sort_central_dir)\n        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;\n      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) || (comp_size == 0xFFFFFFFF))\n        return MZ_FALSE;\n      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);\n      if ((disk_index != num_this_disk) && (disk_index != 1))\n        return MZ_FALSE;\n      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)\n        return MZ_FALSE;\n      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)\n        return MZ_FALSE;\n      n -= total_header_size; p += total_header_size;\n    }\n  }\n\n  if (sort_central_dir)\n    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint32 flags)\n{\n  if ((!pZip) || (!pZip->m_pRead))\n    return MZ_FALSE;\n  if (!mz_zip_reader_init_internal(pZip, flags))\n    return MZ_FALSE;\n  pZip->m_archive_size = size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags))\n  {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\nstatic size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)\n{\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);\n  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);\n  return s;\n}\n\nmz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint32 flags)\n{\n  if (!mz_zip_reader_init_internal(pZip, flags))\n    return MZ_FALSE;\n  pZip->m_archive_size = size;\n  pZip->m_pRead = mz_zip_mem_read_func;\n  pZip->m_pIO_opaque = pZip;\n#ifdef __cplusplus\n  pZip->m_pState->m_pMem = const_cast<void *>(pMem);\n#else\n  pZip->m_pState->m_pMem = (void *)pMem;\n#endif\n  pZip->m_pState->m_mem_size = size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags))\n  {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)\n{\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);\n  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))\n    return 0;\n  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);\n}\n\nmz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)\n{\n  mz_uint64 file_size;\n  MZ_FILE *pFile = MZ_FOPEN(pFilename, \"rb\");\n  if (!pFile)\n    return MZ_FALSE;\n  if (MZ_FSEEK64(pFile, 0, SEEK_END))\n  {\n    MZ_FCLOSE(pFile);\n    return MZ_FALSE;\n  }\n  file_size = MZ_FTELL64(pFile);\n  if (!mz_zip_reader_init_internal(pZip, flags))\n  {\n    MZ_FCLOSE(pFile);\n    return MZ_FALSE;\n  }\n  pZip->m_pRead = mz_zip_file_read_func;\n  pZip->m_pIO_opaque = pZip;\n  pZip->m_pState->m_pFile = pFile;\n  pZip->m_archive_size = file_size;\n  if (!mz_zip_reader_read_central_dir(pZip, flags))\n  {\n    mz_zip_reader_end(pZip);\n    return MZ_FALSE;\n  }\n  return MZ_TRUE;\n}\n#endif // #ifndef MINIZ_NO_STDIO\n\nmz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)\n{\n  return pZip ? pZip->m_total_files : 0;\n}\n\nstatic MZ_FORCEINLINE const mz_uint8 *mz_zip_reader_get_cdh(mz_zip_archive *pZip, mz_uint file_index)\n{\n  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return NULL;\n  return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));\n}\n\nmz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)\n{\n  mz_uint m_bit_flag;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p)\n    return MZ_FALSE;\n  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);\n  return (m_bit_flag & 1);\n}\n\nmz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)\n{\n  mz_uint filename_len, external_attr;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p)\n    return MZ_FALSE;\n\n  // First see if the filename ends with a '/' character.\n  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  if (filename_len)\n  {\n    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')\n      return MZ_TRUE;\n  }\n\n  // Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct.\n  // Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field.\n  // FIXME: Remove this check? Is it necessary - we already check the filename.\n  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);\n  if ((external_attr & 0x10) != 0)\n    return MZ_TRUE;\n\n  return MZ_FALSE;\n}\n\nmz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)\n{\n  mz_uint n;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if ((!p) || (!pStat))\n    return MZ_FALSE;\n\n  // Unpack the central directory record.\n  pStat->m_file_index = file_index;\n  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);\n  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);\n  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);\n  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);\n  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);\n#ifndef MINIZ_NO_TIME\n  pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));\n#endif\n  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);\n  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);\n  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);\n  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);\n\n  // Copy as much of the filename and comment as possible.\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);\n  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n); pStat->m_filename[n] = '\\0';\n\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS); n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);\n  pStat->m_comment_size = n;\n  memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n); pStat->m_comment[n] = '\\0';\n\n  return MZ_TRUE;\n}\n\nmz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)\n{\n  mz_uint n;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  if (!p) { if (filename_buf_size) pFilename[0] = '\\0'; return 0; }\n  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  if (filename_buf_size)\n  {\n    n = MZ_MIN(n, filename_buf_size - 1);\n    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);\n    pFilename[n] = '\\0';\n  }\n  return n + 1;\n}\n\nstatic MZ_FORCEINLINE mz_bool mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)\n{\n  mz_uint i;\n  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)\n    return 0 == memcmp(pA, pB, len);\n  for (i = 0; i < len; ++i)\n    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))\n      return MZ_FALSE;\n  return MZ_TRUE;\n}\n\nstatic MZ_FORCEINLINE int mz_zip_reader_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)\n{\n  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;\n  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n  mz_uint8 l = 0, r = 0;\n  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n  pE = pL + MZ_MIN(l_len, r_len);\n  while (pL < pE)\n  {\n    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))\n      break;\n    pL++; pR++;\n  }\n  return (pL == pE) ? (int)(l_len - r_len) : (l - r);\n}\n\nstatic int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename)\n{\n  mz_zip_internal_state *pState = pZip->m_pState;\n  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;\n  const mz_zip_array *pCentral_dir = &pState->m_central_dir;\n  mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);\n  const int size = pZip->m_total_files;\n  const mz_uint filename_len = (mz_uint)strlen(pFilename);\n  int l = 0, h = size - 1;\n  while (l <= h)\n  {\n    int m = (l + h) >> 1, file_index = pIndices[m], comp = mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);\n    if (!comp)\n      return file_index;\n    else if (comp < 0)\n      l = m + 1;\n    else\n      h = m - 1;\n  }\n  return -1;\n}\n\nint mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)\n{\n  mz_uint file_index; size_t name_len, comment_len;\n  if ((!pZip) || (!pZip->m_pState) || (!pName) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return -1;\n  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))\n    return mz_zip_reader_locate_file_binary_search(pZip, pName);\n  name_len = strlen(pName); if (name_len > 0xFFFF) return -1;\n  comment_len = pComment ? strlen(pComment) : 0; if (comment_len > 0xFFFF) return -1;\n  for (file_index = 0; file_index < pZip->m_total_files; file_index++)\n  {\n    const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));\n    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);\n    const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;\n    if (filename_len < name_len)\n      continue;\n    if (comment_len)\n    {\n      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n      const char *pFile_comment = pFilename + filename_len + file_extra_len;\n      if ((file_comment_len != comment_len) || (!mz_zip_reader_string_equal(pComment, pFile_comment, file_comment_len, flags)))\n        continue;\n    }\n    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))\n    {\n      int ofs = filename_len - 1;\n      do\n      {\n        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\\\') || (pFilename[ofs] == ':'))\n          break;\n      } while (--ofs >= 0);\n      ofs++;\n      pFilename += ofs; filename_len -= ofs;\n    }\n    if ((filename_len == name_len) && (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))\n      return file_index;\n  }\n  return -1;\n}\n\nmz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)\n{\n  int status = TINFL_STATUS_DONE;\n  mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;\n  mz_zip_archive_file_stat file_stat;\n  void *pRead_buf;\n  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n  tinfl_decompressor inflator;\n\n  if ((buf_size) && (!pBuf))\n    return MZ_FALSE;\n\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))\n    return MZ_FALSE;\n\n  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)\n  if (!file_stat.m_comp_size)\n    return MZ_TRUE;\n\n  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).\n  // I'm torn how to handle this case - should it fail instead?\n  if (mz_zip_reader_is_file_a_directory(pZip, file_index))\n    return MZ_TRUE;\n\n  // Encryption and patch files are not supported.\n  if (file_stat.m_bit_flag & (1 | 32))\n    return MZ_FALSE;\n\n  // This function only supports stored and deflate.\n  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))\n    return MZ_FALSE;\n\n  // Ensure supplied output buffer is large enough.\n  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;\n  if (buf_size < needed_size)\n    return MZ_FALSE;\n\n  // Read and parse the local directory entry.\n  cur_file_ofs = file_stat.m_local_header_ofs;\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n\n  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))\n  {\n    // The file is stored or the caller has requested the compressed data.\n    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)\n      return MZ_FALSE;\n    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);\n  }\n\n  // Decompress the file either directly from memory or from a file input buffer.\n  tinfl_init(&inflator);\n\n  if (pZip->m_pState->m_pMem)\n  {\n    // Read directly from the archive in memory.\n    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;\n    read_buf_size = read_buf_avail = file_stat.m_comp_size;\n    comp_remaining = 0;\n  }\n  else if (pUser_read_buf)\n  {\n    // Use a user provided read buffer.\n    if (!user_read_buf_size)\n      return MZ_FALSE;\n    pRead_buf = (mz_uint8 *)pUser_read_buf;\n    read_buf_size = user_read_buf_size;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n  else\n  {\n    // Temporarily allocate a read buffer.\n    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);\n#ifdef _MSC_VER\n    if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))\n#else\n    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))\n#endif\n      return MZ_FALSE;\n    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))\n      return MZ_FALSE;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n\n  do\n  {\n    size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);\n    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))\n    {\n      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)\n      {\n        status = TINFL_STATUS_FAILED;\n        break;\n      }\n      cur_file_ofs += read_buf_avail;\n      comp_remaining -= read_buf_avail;\n      read_buf_ofs = 0;\n    }\n    in_buf_size = (size_t)read_buf_avail;\n    status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));\n    read_buf_avail -= in_buf_size;\n    read_buf_ofs += in_buf_size;\n    out_buf_ofs += out_buf_size;\n  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);\n\n  if (status == TINFL_STATUS_DONE)\n  {\n    // Make sure the entire file was decompressed, and check its CRC.\n    if ((out_buf_ofs != file_stat.m_uncomp_size) || (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))\n      status = TINFL_STATUS_FAILED;\n  }\n\n  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n\n  return status == TINFL_STATUS_DONE;\n}\n\nmz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)\n{\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0)\n    return MZ_FALSE;\n  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size);\n}\n\nmz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)\n{\n  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size, flags, NULL, 0);\n}\n\nmz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)\n{\n  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);\n}\n\nvoid *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)\n{\n  mz_uint64 comp_size, uncomp_size, alloc_size;\n  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);\n  void *pBuf;\n\n  if (pSize)\n    *pSize = 0;\n  if (!p)\n    return NULL;\n\n  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);\n\n  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;\n#ifdef _MSC_VER\n  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))\n#else\n  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))\n#endif\n    return NULL;\n  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))\n    return NULL;\n\n  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size, flags))\n  {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n    return NULL;\n  }\n\n  if (pSize) *pSize = (size_t)alloc_size;\n  return pBuf;\n}\n\nvoid *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)\n{\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0)\n  {\n    if (pSize) *pSize = 0;\n    return MZ_FALSE;\n  }\n  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);\n}\n\nmz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)\n{\n  int status = TINFL_STATUS_DONE; mz_uint file_crc32 = MZ_CRC32_INIT;\n  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;\n  mz_zip_archive_file_stat file_stat;\n  void *pRead_buf = NULL; void *pWrite_buf = NULL;\n  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))\n    return MZ_FALSE;\n\n  // Empty file, or a directory (but not always a directory - I've seen odd zips with directories that have compressed data which inflates to 0 bytes)\n  if (!file_stat.m_comp_size)\n    return MZ_TRUE;\n\n  // Entry is a subdirectory (I've seen old zips with dir entries which have compressed deflate data which inflates to 0 bytes, but these entries claim to uncompress to 512 bytes in the headers).\n  // I'm torn how to handle this case - should it fail instead?\n  if (mz_zip_reader_is_file_a_directory(pZip, file_index))\n    return MZ_TRUE;\n\n  // Encryption and patch files are not supported.\n  if (file_stat.m_bit_flag & (1 | 32))\n    return MZ_FALSE;\n\n  // This function only supports stored and deflate.\n  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))\n    return MZ_FALSE;\n\n  // Read and parse the local directory entry.\n  cur_file_ofs = file_stat.m_local_header_ofs;\n  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n\n  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)\n    return MZ_FALSE;\n\n  // Decompress the file either directly from memory or from a file input buffer.\n  if (pZip->m_pState->m_pMem)\n  {\n    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;\n    read_buf_size = read_buf_avail = file_stat.m_comp_size;\n    comp_remaining = 0;\n  }\n  else\n  {\n    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);\n    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))\n      return MZ_FALSE;\n    read_buf_avail = 0;\n    comp_remaining = file_stat.m_comp_size;\n  }\n\n  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))\n  {\n    // The file is stored or the caller has requested the compressed data.\n    if (pZip->m_pState->m_pMem)\n    {\n#ifdef _MSC_VER\n      if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))\n#else\n      if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > 0xFFFFFFFF))\n#endif\n        return MZ_FALSE;\n      if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)\n        status = TINFL_STATUS_FAILED;\n      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n        file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);\n      cur_file_ofs += file_stat.m_comp_size;\n      out_buf_ofs += file_stat.m_comp_size;\n      comp_remaining = 0;\n    }\n    else\n    {\n      while (comp_remaining)\n      {\n        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)\n        {\n          status = TINFL_STATUS_FAILED;\n          break;\n        }\n\n        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n          file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);\n\n        if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)\n        {\n          status = TINFL_STATUS_FAILED;\n          break;\n        }\n        cur_file_ofs += read_buf_avail;\n        out_buf_ofs += read_buf_avail;\n        comp_remaining -= read_buf_avail;\n      }\n    }\n  }\n  else\n  {\n    tinfl_decompressor inflator;\n    tinfl_init(&inflator);\n\n    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))\n      status = TINFL_STATUS_FAILED;\n    else\n    {\n      do\n      {\n        mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));\n        size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));\n        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))\n        {\n          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);\n          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)\n          {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n          cur_file_ofs += read_buf_avail;\n          comp_remaining -= read_buf_avail;\n          read_buf_ofs = 0;\n        }\n\n        in_buf_size = (size_t)read_buf_avail;\n        status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);\n        read_buf_avail -= in_buf_size;\n        read_buf_ofs += in_buf_size;\n\n        if (out_buf_size)\n        {\n          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)\n          {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n          file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);\n          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)\n          {\n            status = TINFL_STATUS_FAILED;\n            break;\n          }\n        }\n      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));\n    }\n  }\n\n  if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))\n  {\n    // Make sure the entire file was decompressed, and check its CRC.\n    if ((out_buf_ofs != file_stat.m_uncomp_size) || (file_crc32 != file_stat.m_crc32))\n      status = TINFL_STATUS_FAILED;\n  }\n\n  if (!pZip->m_pState->m_pMem)\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n  if (pWrite_buf)\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);\n\n  return status == TINFL_STATUS_DONE;\n}\n\nmz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)\n{\n  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);\n  if (file_index < 0)\n    return MZ_FALSE;\n  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)\n{\n  (void)ofs; return MZ_FWRITE(pBuf, 1, n, (MZ_FILE*)pOpaque);\n}\n\nmz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)\n{\n  mz_bool status;\n  mz_zip_archive_file_stat file_stat;\n  MZ_FILE *pFile;\n  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))\n    return MZ_FALSE;\n  pFile = MZ_FOPEN(pDst_filename, \"wb\");\n  if (!pFile)\n    return MZ_FALSE;\n  status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);\n  if (MZ_FCLOSE(pFile) == EOF)\n    return MZ_FALSE;\n#ifndef MINIZ_NO_TIME\n  if (status)\n    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);\n#endif\n  return status;\n}\n#endif // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_reader_end(mz_zip_archive *pZip)\n{\n  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return MZ_FALSE;\n\n  if (pZip->m_pState)\n  {\n    mz_zip_internal_state *pState = pZip->m_pState; pZip->m_pState = NULL;\n    mz_zip_array_clear(pZip, &pState->m_central_dir);\n    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);\n    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);\n\n#ifndef MINIZ_NO_STDIO\n    if (pState->m_pFile)\n    {\n      MZ_FCLOSE(pState->m_pFile);\n      pState->m_pFile = NULL;\n    }\n#endif // #ifndef MINIZ_NO_STDIO\n\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);\n  }\n  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;\n\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)\n{\n  int file_index = mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);\n  if (file_index < 0)\n    return MZ_FALSE;\n  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);\n}\n#endif\n\n// ------------------- .ZIP archive writing\n\n#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\nstatic void mz_write_le16(mz_uint8 *p, mz_uint16 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); }\nstatic void mz_write_le32(mz_uint8 *p, mz_uint32 v) { p[0] = (mz_uint8)v; p[1] = (mz_uint8)(v >> 8); p[2] = (mz_uint8)(v >> 16); p[3] = (mz_uint8)(v >> 24); }\n#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))\n#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))\n\nmz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)\n{\n  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))\n    return MZ_FALSE;\n\n  if (pZip->m_file_offset_alignment)\n  {\n    // Ensure user specified file offset alignment is a power of 2.\n    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))\n      return MZ_FALSE;\n  }\n\n  if (!pZip->m_pAlloc) pZip->m_pAlloc = def_alloc_func;\n  if (!pZip->m_pFree) pZip->m_pFree = def_free_func;\n  if (!pZip->m_pRealloc) pZip->m_pRealloc = def_realloc_func;\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n  pZip->m_archive_size = existing_size;\n  pZip->m_central_directory_file_ofs = 0;\n  pZip->m_total_files = 0;\n\n  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))\n    return MZ_FALSE;\n  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));\n  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));\n  return MZ_TRUE;\n}\n\nstatic size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)\n{\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_zip_internal_state *pState = pZip->m_pState;\n  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);\n#ifdef _MSC_VER\n  if ((!n) || ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))\n#else\n  if ((!n) || ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))\n#endif\n    return 0;\n  if (new_size > pState->m_mem_capacity)\n  {\n    void *pNew_block;\n    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity); while (new_capacity < new_size) new_capacity *= 2;\n    if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))\n      return 0;\n    pState->m_pMem = pNew_block; pState->m_mem_capacity = new_capacity;\n  }\n  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);\n  pState->m_mem_size = (size_t)new_size;\n  return n;\n}\n\nmz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)\n{\n  pZip->m_pWrite = mz_zip_heap_write_func;\n  pZip->m_pIO_opaque = pZip;\n  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))\n    return MZ_FALSE;\n  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))\n  {\n    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))\n    {\n      mz_zip_writer_end(pZip);\n      return MZ_FALSE;\n    }\n    pZip->m_pState->m_mem_capacity = initial_allocation_size;\n  }\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nstatic size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)\n{\n  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;\n  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);\n  if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))\n    return 0;\n  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);\n}\n\nmz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)\n{\n  MZ_FILE *pFile;\n  pZip->m_pWrite = mz_zip_file_write_func;\n  pZip->m_pIO_opaque = pZip;\n  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))\n    return MZ_FALSE;\n  if (NULL == (pFile = MZ_FOPEN(pFilename, \"wb\")))\n  {\n    mz_zip_writer_end(pZip);\n    return MZ_FALSE;\n  }\n  pZip->m_pState->m_pFile = pFile;\n  if (size_to_reserve_at_beginning)\n  {\n    mz_uint64 cur_ofs = 0; char buf[4096]; MZ_CLEAR_OBJ(buf);\n    do\n    {\n      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);\n      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)\n      {\n        mz_zip_writer_end(pZip);\n        return MZ_FALSE;\n      }\n      cur_ofs += n; size_to_reserve_at_beginning -= n;\n    } while (size_to_reserve_at_beginning);\n  }\n  return MZ_TRUE;\n}\n#endif // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)\n{\n  mz_zip_internal_state *pState;\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))\n    return MZ_FALSE;\n  // No sense in trying to write to an archive that's already at the support max size\n  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  if (pState->m_pFile)\n  {\n#ifdef MINIZ_NO_STDIO\n    pFilename; return MZ_FALSE;\n#else\n    // Archive is being read from stdio - try to reopen as writable.\n    if (pZip->m_pIO_opaque != pZip)\n      return MZ_FALSE;\n    if (!pFilename)\n      return MZ_FALSE;\n    pZip->m_pWrite = mz_zip_file_write_func;\n    if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, \"r+b\", pState->m_pFile)))\n    {\n      // The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it.\n      mz_zip_reader_end(pZip);\n      return MZ_FALSE;\n    }\n#endif // #ifdef MINIZ_NO_STDIO\n  }\n  else if (pState->m_pMem)\n  {\n    // Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback.\n    if (pZip->m_pIO_opaque != pZip)\n      return MZ_FALSE;\n    pState->m_mem_capacity = pState->m_mem_size;\n    pZip->m_pWrite = mz_zip_heap_write_func;\n  }\n  // Archive is being read via a user provided read function - make sure the user has specified a write function too.\n  else if (!pZip->m_pWrite)\n    return MZ_FALSE;\n\n  // Start writing new files at the archive's current central directory location.\n  pZip->m_archive_size = pZip->m_central_directory_file_ofs;\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;\n  pZip->m_central_directory_file_ofs = 0;\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)\n{\n  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);\n}\n\ntypedef struct\n{\n  mz_zip_archive *m_pZip;\n  mz_uint64 m_cur_archive_file_ofs;\n  mz_uint64 m_comp_size;\n} mz_zip_writer_add_state;\n\nstatic mz_bool mz_zip_writer_add_put_buf_callback(const void* pBuf, int len, void *pUser)\n{\n  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;\n  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)\n    return MZ_FALSE;\n  pState->m_cur_archive_file_ofs += len;\n  pState->m_comp_size += len;\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)\n{\n  (void)pZip;\n  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)\n{\n  (void)pZip;\n  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);\n  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);\n  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size, const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs, mz_uint32 ext_attributes)\n{\n  mz_zip_internal_state *pState = pZip->m_pState;\n  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;\n  size_t orig_central_dir_size = pState->m_central_dir.m_size;\n  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n\n  // No zip64 support yet\n  if ((local_header_ofs > 0xFFFFFFFF) || (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + comment_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, extra_size, comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||\n      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))\n  {\n    // Try to push the central directory array back into its original state.\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  return MZ_TRUE;\n}\n\nstatic mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)\n{\n  // Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes.\n  if (*pArchive_name == '/')\n    return MZ_FALSE;\n  while (*pArchive_name)\n  {\n    if ((*pArchive_name == '\\\\') || (*pArchive_name == ':'))\n      return MZ_FALSE;\n    pArchive_name++;\n  }\n  return MZ_TRUE;\n}\n\nstatic mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)\n{\n  mz_uint32 n;\n  if (!pZip->m_file_offset_alignment)\n    return 0;\n  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));\n  return (pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1);\n}\n\nstatic mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)\n{\n  char buf[4096];\n  memset(buf, 0, MZ_MIN(sizeof(buf), n));\n  while (n)\n  {\n    mz_uint32 s = MZ_MIN(sizeof(buf), n);\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)\n      return MZ_FALSE;\n    cur_file_ofs += s; n -= s;\n  }\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)\n{\n  mz_uint16 method = 0, dos_time = 0, dos_date = 0;\n  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;\n  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;\n  size_t archive_name_size;\n  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];\n  tdefl_compressor *pComp = NULL;\n  mz_bool store_data_uncompressed;\n  mz_zip_internal_state *pState;\n\n  if ((int)level_and_flags < 0)\n    level_and_flags = MZ_DEFAULT_LEVEL;\n  level = level_and_flags & 0xF;\n  store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))\n    return MZ_FALSE;\n  // No zip64 support yet\n  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))\n    return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name))\n    return MZ_FALSE;\n\n#ifndef MINIZ_NO_TIME\n  {\n    time_t cur_time; time(&cur_time);\n    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);\n  }\n#endif // #ifndef MINIZ_NO_TIME\n\n  archive_name_size = strlen(pArchive_name);\n  if (archive_name_size > 0xFFFF)\n    return MZ_FALSE;\n\n  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))\n  {\n    // Set DOS Subdirectory attribute bit.\n    ext_attributes |= 0x10;\n    // Subdirectories cannot contain data.\n    if ((buf_size) || (uncomp_size))\n      return MZ_FALSE;\n  }\n\n  // Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.)\n  if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size)) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))\n    return MZ_FALSE;\n\n  if ((!store_data_uncompressed) && (buf_size))\n  {\n    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))\n      return MZ_FALSE;\n  }\n\n  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))\n  {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n    return MZ_FALSE;\n  }\n  local_dir_header_ofs += num_alignment_padding_bytes;\n  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }\n  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);\n\n  MZ_CLEAR_OBJ(local_dir_header);\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)\n  {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n    return MZ_FALSE;\n  }\n  cur_archive_file_ofs += archive_name_size;\n\n  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))\n  {\n    uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8*)pBuf, buf_size);\n    uncomp_size = buf_size;\n    if (uncomp_size <= 3)\n    {\n      level = 0;\n      store_data_uncompressed = MZ_TRUE;\n    }\n  }\n\n  if (store_data_uncompressed)\n  {\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)\n    {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n      return MZ_FALSE;\n    }\n\n    cur_archive_file_ofs += buf_size;\n    comp_size = buf_size;\n\n    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)\n      method = MZ_DEFLATED;\n  }\n  else if (buf_size)\n  {\n    mz_zip_writer_add_state state;\n\n    state.m_pZip = pZip;\n    state.m_cur_archive_file_ofs = cur_archive_file_ofs;\n    state.m_comp_size = 0;\n\n    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||\n        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))\n    {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n      return MZ_FALSE;\n    }\n\n    comp_size = state.m_comp_size;\n    cur_archive_file_ofs = state.m_cur_archive_file_ofs;\n\n    method = MZ_DEFLATED;\n  }\n\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n  pComp = NULL;\n\n  // no zip64 support yet\n  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))\n    return MZ_FALSE;\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_archive_file_ofs;\n\n  return MZ_TRUE;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)\n{\n  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;\n  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;\n  mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;\n  size_t archive_name_size;\n  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];\n  MZ_FILE *pSrc_file = NULL;\n\n  if ((int)level_and_flags < 0)\n    level_and_flags = MZ_DEFAULT_LEVEL;\n  level = level_and_flags & 0xF;\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)\n    return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name))\n    return MZ_FALSE;\n\n  archive_name_size = strlen(pArchive_name);\n  if (archive_name_size > 0xFFFF)\n    return MZ_FALSE;\n\n  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + comment_size + archive_name_size) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))\n    return MZ_FALSE;\n    \n  pSrc_file = MZ_FOPEN(pSrc_filename, \"rb\");\n  if (!pSrc_file)\n    return MZ_FALSE;\n  MZ_FSEEK64(pSrc_file, 0, SEEK_END);\n  uncomp_size = MZ_FTELL64(pSrc_file);\n  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);\n\n  if (uncomp_size > 0xFFFFFFFF)\n  {\n    // No zip64 support yet\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  if (uncomp_size <= 3)\n    level = 0;\n\n  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes + sizeof(local_dir_header)))\n  {\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  local_dir_header_ofs += num_alignment_padding_bytes;\n  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }\n  cur_archive_file_ofs += num_alignment_padding_bytes + sizeof(local_dir_header);\n\n  MZ_CLEAR_OBJ(local_dir_header);\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)\n  {\n    MZ_FCLOSE(pSrc_file);\n    return MZ_FALSE;\n  }\n  cur_archive_file_ofs += archive_name_size;\n\n  if (uncomp_size)\n  {\n    mz_uint64 uncomp_remaining = uncomp_size;\n    void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);\n    if (!pRead_buf)\n    {\n      MZ_FCLOSE(pSrc_file);\n      return MZ_FALSE;\n    }\n\n    if (!level)\n    {\n      while (uncomp_remaining)\n      {\n        mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);\n        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) || (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n))\n        {\n          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n          MZ_FCLOSE(pSrc_file);\n          return MZ_FALSE;\n        }\n        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);\n        uncomp_remaining -= n;\n        cur_archive_file_ofs += n;\n      }\n      comp_size = uncomp_size;\n    }\n    else\n    {\n      mz_bool result = MZ_FALSE;\n      mz_zip_writer_add_state state;\n      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));\n      if (!pComp)\n      {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      state.m_pZip = pZip;\n      state.m_cur_archive_file_ofs = cur_archive_file_ofs;\n      state.m_comp_size = 0;\n\n      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)\n      {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      for ( ; ; )\n      {\n        size_t in_buf_size = (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);\n        tdefl_status status;\n\n        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)\n          break;\n\n        uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);\n        uncomp_remaining -= in_buf_size;\n\n        status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size, uncomp_remaining ? TDEFL_NO_FLUSH : TDEFL_FINISH);\n        if (status == TDEFL_STATUS_DONE)\n        {\n          result = MZ_TRUE;\n          break;\n        }\n        else if (status != TDEFL_STATUS_OKAY)\n          break;\n      }\n\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);\n\n      if (!result)\n      {\n        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n        MZ_FCLOSE(pSrc_file);\n        return MZ_FALSE;\n      }\n\n      comp_size = state.m_comp_size;\n      cur_archive_file_ofs = state.m_cur_archive_file_ofs;\n\n      method = MZ_DEFLATED;\n    }\n\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);\n  }\n\n  MZ_FCLOSE(pSrc_file); pSrc_file = NULL;\n\n  // no zip64 support yet\n  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date))\n    return MZ_FALSE;\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))\n    return MZ_FALSE;\n\n  if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment, comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0, dos_time, dos_date, local_dir_header_ofs, ext_attributes))\n    return MZ_FALSE;\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_archive_file_ofs;\n\n  return MZ_TRUE;\n}\n#endif // #ifndef MINIZ_NO_STDIO\n\nmz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint file_index)\n{\n  mz_uint n, bit_flags, num_alignment_padding_bytes;\n  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;\n  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;\n  mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)]; mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;\n  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];\n  size_t orig_central_dir_size;\n  mz_zip_internal_state *pState;\n  void *pBuf; const mz_uint8 *pSrc_central_header;\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))\n    return MZ_FALSE;\n  if (NULL == (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))\n    return MZ_FALSE;\n  pState = pZip->m_pState;\n\n  num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);\n\n  // no zip64 support yet\n  if ((pZip->m_total_files == 0xFFFF) || ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  cur_src_file_ofs = MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);\n  cur_dst_file_ofs = pZip->m_archive_size;\n\n  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)\n    return MZ_FALSE;\n  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))\n    return MZ_FALSE;\n  cur_dst_file_ofs += num_alignment_padding_bytes;\n  local_dir_header_ofs = cur_dst_file_ofs;\n  if (pZip->m_file_offset_alignment) { MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0); }\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)\n    return MZ_FALSE;\n  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;\n\n  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);\n  comp_bytes_remaining = n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);\n\n  if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(sizeof(mz_uint32) * 4, MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining)))))\n    return MZ_FALSE;\n\n  while (comp_bytes_remaining)\n  {\n    n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)\n    {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n    cur_src_file_ofs += n;\n\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)\n    {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n    cur_dst_file_ofs += n;\n\n    comp_bytes_remaining -= n;\n  }\n\n  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);\n  if (bit_flags & 8)\n  {\n    // Copy data descriptor\n    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)\n    {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n\n    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)\n    {\n      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n      return MZ_FALSE;\n    }\n\n    cur_src_file_ofs += n;\n    cur_dst_file_ofs += n;\n  }\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);\n\n  // no zip64 support yet\n  if (cur_dst_file_ofs > 0xFFFFFFFF)\n    return MZ_FALSE;\n\n  orig_central_dir_size = pState->m_central_dir.m_size;\n\n  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);\n  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))\n    return MZ_FALSE;\n\n  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n))\n  {\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  if (pState->m_central_dir.m_size > 0xFFFFFFFF)\n    return MZ_FALSE;\n  n = (mz_uint32)orig_central_dir_size;\n  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))\n  {\n    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);\n    return MZ_FALSE;\n  }\n\n  pZip->m_total_files++;\n  pZip->m_archive_size = cur_dst_file_ofs;\n\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)\n{\n  mz_zip_internal_state *pState;\n  mz_uint64 central_dir_ofs, central_dir_size;\n  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];\n\n  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n\n  // no zip64 support yet\n  if ((pZip->m_total_files > 0xFFFF) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))\n    return MZ_FALSE;\n\n  central_dir_ofs = 0;\n  central_dir_size = 0;\n  if (pZip->m_total_files)\n  {\n    // Write central directory\n    central_dir_ofs = pZip->m_archive_size;\n    central_dir_size = pState->m_central_dir.m_size;\n    pZip->m_central_directory_file_ofs = central_dir_ofs;\n    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)\n      return MZ_FALSE;\n    pZip->m_archive_size += central_dir_size;\n  }\n\n  // Write end of central directory record\n  MZ_CLEAR_OBJ(hdr);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);\n  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);\n  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);\n  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);\n\n  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, sizeof(hdr)) != sizeof(hdr))\n    return MZ_FALSE;\n#ifndef MINIZ_NO_STDIO\n  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))\n    return MZ_FALSE;\n#endif // #ifndef MINIZ_NO_STDIO\n\n  pZip->m_archive_size += sizeof(hdr);\n\n  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf, size_t *pSize)\n{\n  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize))\n    return MZ_FALSE;\n  if (pZip->m_pWrite != mz_zip_heap_write_func)\n    return MZ_FALSE;\n  if (!mz_zip_writer_finalize_archive(pZip))\n    return MZ_FALSE;\n\n  *pBuf = pZip->m_pState->m_pMem;\n  *pSize = pZip->m_pState->m_mem_size;\n  pZip->m_pState->m_pMem = NULL;\n  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;\n  return MZ_TRUE;\n}\n\nmz_bool mz_zip_writer_end(mz_zip_archive *pZip)\n{\n  mz_zip_internal_state *pState;\n  mz_bool status = MZ_TRUE;\n  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))\n    return MZ_FALSE;\n\n  pState = pZip->m_pState;\n  pZip->m_pState = NULL;\n  mz_zip_array_clear(pZip, &pState->m_central_dir);\n  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);\n  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);\n\n#ifndef MINIZ_NO_STDIO\n  if (pState->m_pFile)\n  {\n    MZ_FCLOSE(pState->m_pFile);\n    pState->m_pFile = NULL;\n  }\n#endif // #ifndef MINIZ_NO_STDIO\n\n  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))\n  {\n    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);\n    pState->m_pMem = NULL;\n  }\n\n  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);\n  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;\n  return status;\n}\n\n#ifndef MINIZ_NO_STDIO\nmz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)\n{\n  mz_bool status, created_new_archive = MZ_FALSE;\n  mz_zip_archive zip_archive;\n  struct MZ_FILE_STAT_STRUCT file_stat;\n  MZ_CLEAR_OBJ(zip_archive);\n  if ((int)level_and_flags < 0)\n     level_and_flags = MZ_DEFAULT_LEVEL;\n  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))\n    return MZ_FALSE;\n  if (!mz_zip_writer_validate_archive_name(pArchive_name))\n    return MZ_FALSE;\n  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)\n  {\n    // Create a new archive.\n    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))\n      return MZ_FALSE;\n    created_new_archive = MZ_TRUE;\n  }\n  else\n  {\n    // Append to an existing archive.\n    if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))\n      return MZ_FALSE;\n    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename))\n    {\n      mz_zip_reader_end(&zip_archive);\n      return MZ_FALSE;\n    }\n  }\n  status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);\n  // Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.)\n  if (!mz_zip_writer_finalize_archive(&zip_archive))\n    status = MZ_FALSE;\n  if (!mz_zip_writer_end(&zip_archive))\n    status = MZ_FALSE;\n  if ((!status) && (created_new_archive))\n  {\n    // It's a new archive and something went wrong, so just delete it.\n    int ignoredStatus = MZ_DELETE_FILE(pZip_filename);\n    (void)ignoredStatus;\n  }\n  return status;\n}\n\nvoid *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)\n{\n  int file_index;\n  mz_zip_archive zip_archive;\n  void *p = NULL;\n\n  if (pSize)\n    *pSize = 0;\n\n  if ((!pZip_filename) || (!pArchive_name))\n    return NULL;\n\n  MZ_CLEAR_OBJ(zip_archive);\n  if (!mz_zip_reader_init_file(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))\n    return NULL;\n\n  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL, flags)) >= 0)\n    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);\n\n  mz_zip_reader_end(&zip_archive);\n  return p;\n}\n\n#endif // #ifndef MINIZ_NO_STDIO\n\n#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS\n\n#endif // #ifndef MINIZ_NO_ARCHIVE_APIS\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // MINIZ_HEADER_FILE_ONLY\n\n/*\n  This is free and unencumbered software released into the public domain.\n\n  Anyone is free to copy, modify, publish, use, compile, sell, or\n  distribute this software, either in source code form or as a compiled\n  binary, for any purpose, commercial or non-commercial, and by any\n  means.\n\n  In jurisdictions that recognize copyright laws, the author or authors\n  of this software dedicate any and all copyright interest in the\n  software to the public domain. We make this dedication for the benefit\n  of the public at large and to the detriment of our heirs and\n  successors. We intend this dedication to be an overt act of\n  relinquishment in perpetuity of all present and future rights to this\n  software under copyright law.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n  OTHER DEALINGS IN THE SOFTWARE.\n\n  For more information, please refer to <http://unlicense.org/>\n*/\n\n/*\n------------------------------------------------------------------------------\n    END miniz.c\n------------------------------------------------------------------------------\n*/\n\n#pragma warning( pop )\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n\n#include \"strpool.h\"\n\n#ifndef ASSETSYS_ASSERT\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <assert.h>\n    #define ASSETSYS_ASSERT( expression, message ) assert( ( expression ) && ( message ) )\n#endif\n\n#ifndef ASSETSYS_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define ASSETSYS_MALLOC( ctx, size ) ( malloc( size ) )\n    #define ASSETSYS_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\n#if defined( _WIN32 )\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n\t#if !defined( _WIN32_WINNT ) || _WIN32_WINNT < 0x0501 \n    #undef _WIN32_WINNT\n    #define _WIN32_WINNT 0x0501 // requires Windows XP minimum\n    // 0x0400=Windows NT 4.0, 0x0500=Windows 2000, 0x0501=Windows XP, 0x0502=Windows Server 2003, 0x0600=Windows Vista, \n    // 0x0601=Windows 7, 0x0602=Windows 8, 0x0603=Windows 8.1, 0x0A00=Windows 10\n#endif\n    #define _WINSOCKAPI_\n    #pragma warning( push )\n    #pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n    #pragma warning( disable: 4768 ) // __declspec attributes before linkage specification are ignored\t\n    #pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n    #include <windows.h>\n    #pragma warning( pop )\n\n    struct assetsys_internal_dir_entry_t \n        {\n        char name[ MAX_PATH ];\n        BOOL is_folder;\n        };\n\n\n    struct assetsys_internal_dir_t\n        {\n        HANDLE handle;\n        WIN32_FIND_DATAA data;\n        struct assetsys_internal_dir_entry_t entry;\n        };\n\n\n    static void assetsys_internal_dir_open( struct assetsys_internal_dir_t* dir, char const* path )\n        {\n        size_t path_len = strlen( path );\n        BOOL trailing_path_separator = path[ path_len - 1 ] == '\\\\' || path[ path_len - 1 ] == '/';\n        const char* string_to_append = \"*.*\";\n        if( path_len + strlen( string_to_append ) + ( trailing_path_separator ? 0 : 1 ) >= MAX_PATH ) return;\n        char search_pattern[ MAX_PATH ];\n        strcpy( search_pattern, path );\n        if( !trailing_path_separator ) strcat( search_pattern, \"\\\\\" );\n        strcat( search_pattern, string_to_append );\n\n        WIN32_FIND_DATAA data;\n        HANDLE handle = FindFirstFileA( search_pattern, &data );\n        if( handle == INVALID_HANDLE_VALUE ) return;\n\n        dir->handle = handle;\n        dir->data = data;\n        }\n\n\n    static void assetsys_internal_dir_close( struct assetsys_internal_dir_t* dir )\n        {\n        if( dir->handle != INVALID_HANDLE_VALUE ) FindClose( dir->handle );\n        }\n\n\n    static struct assetsys_internal_dir_entry_t* assetsys_internal_dir_read( struct assetsys_internal_dir_t* dir )\n        {\n        if( dir->handle == INVALID_HANDLE_VALUE ) return NULL;\n\n        strcpy( dir->entry.name, dir->data.cFileName );\n        dir->entry.is_folder = ( dir->data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0;\n\n        BOOL result = FindNextFileA( dir->handle, &dir->data );\n        if( !result )\n            {\n            FindClose( dir->handle );\n            dir->handle = INVALID_HANDLE_VALUE;      \n            }\n\n        return &dir->entry;    \n        }\n\n\n    static char const* assetsys_internal_dir_name( struct assetsys_internal_dir_entry_t* entry )\n        {\n        return entry->name;\n        }\n\n\n    static int assetsys_internal_dir_is_file( struct assetsys_internal_dir_entry_t* entry )\n        {\n        return entry->is_folder == FALSE;\n        }\n\n\n    static int assetsys_internal_dir_is_folder( struct assetsys_internal_dir_entry_t* entry )\n        {\n        return entry->is_folder == TRUE;\n        }\n\n\n#else\n\n    #include <dirent.h>\n\n    struct assetsys_internal_dir_t\n        {\n        DIR* dir;\n        };\n\n\n    typedef struct assetsys_internal_dir_entry_t assetsys_internal_dir_entry_t;\n\n\n    static void assetsys_internal_dir_open( struct assetsys_internal_dir_t* dir, char const* path )\n        {\n        dir->dir = opendir( path );\n        }\n\n\n    static void assetsys_internal_dir_close( struct assetsys_internal_dir_t* dir )\n        {\n        closedir( dir->dir );\n        }\n\n\n    static assetsys_internal_dir_entry_t* assetsys_internal_dir_read( struct assetsys_internal_dir_t* dir )\n        {\n        return (assetsys_internal_dir_entry_t*)readdir( dir->dir );\n        }\n\n\n    static char const* assetsys_internal_dir_name( assetsys_internal_dir_entry_t* entry )\n        {\n        return ( (struct dirent*)entry )->d_name;\n        }\n\n\n    static int assetsys_internal_dir_is_file( assetsys_internal_dir_entry_t* entry )\n        {\n        return ( (struct dirent*)entry )->d_type == DT_REG;\n        }\n\n\n    static int assetsys_internal_dir_is_folder( assetsys_internal_dir_entry_t* entry )\n        {\n        return ( (struct dirent*)entry )->d_type == DT_DIR;\n        }\n\n#endif \n\n\nstatic void* assetsys_internal_mz_alloc( void* memctx, size_t items, size_t size ) \n    { \n    (void) memctx; (void) items; (void) size; \n    ASSETSYS_U64* p = (ASSETSYS_U64*) ASSETSYS_MALLOC( memctx, ( items * size ) + sizeof( ASSETSYS_U64 ) );\n    *p = ( items * size );\n    return p + 1; \n    }\n\n\nstatic void assetsys_internal_mz_free( void* memctx, void* ptr ) \n    { \n    (void) memctx; (void) ptr; \n    if( !ptr ) return;\n    ASSETSYS_U64* p = ( (ASSETSYS_U64*) ptr ) - 1;\n    ASSETSYS_FREE( memctx, p ); \n    }\n\n\nstatic void* assetsys_internal_mz_realloc( void* memctx, void* ptr, size_t items, size_t size ) \n    { \n    (void) memctx; (void) ptr; (void) items; (void) size; \n    if( !ptr ) return assetsys_internal_mz_alloc( memctx, items, size );\n   \n    ASSETSYS_U64* p = ( (ASSETSYS_U64*) ptr ) - 1;\n    ASSETSYS_U64 prev_size = *p;\n    if( prev_size >= ( items * size ) ) return ptr;\n    \n    ASSETSYS_U64* new_ptr = (ASSETSYS_U64*) ASSETSYS_MALLOC( memctx, ( items * size ) + sizeof( ASSETSYS_U64 ) ); \n    *new_ptr = ( items * size );\n    ++new_ptr;\n    memcpy( new_ptr, ptr, (size_t) prev_size );\n    ASSETSYS_FREE( memctx, p );\n    return new_ptr;\n    }\n\n\nstatic char* assetsys_internal_dirname( char const* path );\n\nstruct assetsys_internal_file_t\n    {\n    int size;\n    int zip_index;\n    int collated_index;\n    };\n\nstruct assetsys_internal_folder_t\n    {\n    int collated_index;\n    };\n\nenum assetsys_internal_mount_type_t\n    {\n    ASSETSYS_INTERNAL_MOUNT_TYPE_DIR,\n    ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP,\n    };\n\nstruct assetsys_internal_mount_t\n    {\n    ASSETSYS_U64 path;\n    ASSETSYS_U64 mounted_as;\n    int mount_len;\n    enum assetsys_internal_mount_type_t type;\n    mz_zip_archive zip;\n\n    struct assetsys_internal_file_t* files;\n    int files_count;\n    int files_capacity;\n\n    struct assetsys_internal_folder_t* dirs;\n    int dirs_count;\n    int dirs_capacity;\n    };\n\nstruct assetsys_internal_collated_t\n    {\n    ASSETSYS_U64 path;\n    int parent;\n    int ref_count;\n    int is_file;\n    };\n\n\nstruct assetsys_t\n    {\n    void* memctx;\n    strpool_t strpool;\n\n    struct assetsys_internal_mount_t* mounts;\n    int mounts_count;\n    int mounts_capacity;\n\n    struct assetsys_internal_collated_t* collated;\n    int collated_count;\n    int collated_capacity;\n\n    char temp[ 260 ];\n    };\n\n\nstatic ASSETSYS_U64 assetsys_internal_add_string( assetsys_t* sys, char const* const str )\n    {\n    ASSETSYS_U64 h = strpool_inject( &sys->strpool, str, (int) strlen( str ) );\n    strpool_incref( &sys->strpool, h );\n    return h;\n    }\n\n\nstatic char const* assetsys_internal_get_string( assetsys_t* sys, ASSETSYS_U64 const handle )\n    {\n    return strpool_cstr( &sys->strpool, handle );\n    }\n\n\nassetsys_t* assetsys_create( void* memctx )\n    {\n    assetsys_t* sys = (assetsys_t*) ASSETSYS_MALLOC( memctx, sizeof( assetsys_t ) );\n    sys->memctx = memctx;\n\n    strpool_config_t config = strpool_default_config;\n    config.memctx = memctx;\n    strpool_init( &sys->strpool, &config );\n\n    sys->mounts_count = 0;\n    sys->mounts_capacity = 16;\n    sys->mounts = (struct assetsys_internal_mount_t*) ASSETSYS_MALLOC( memctx, \n        sizeof( *sys->mounts ) * sys->mounts_capacity );\n\n    sys->collated_count = 0;\n    sys->collated_capacity = 16384;\n    sys->collated = (struct assetsys_internal_collated_t*) ASSETSYS_MALLOC( memctx, \n        sizeof( *sys->collated ) * sys->collated_capacity );\n    return sys;\n    }\n\n\nvoid assetsys_destroy( assetsys_t* sys )\n    {\n    while( sys->mounts_count > 0 )\n        {\n        assetsys_dismount( sys, assetsys_internal_get_string( sys, sys->mounts[ 0 ].path ), \n            assetsys_internal_get_string( sys, sys->mounts[ 0 ].mounted_as ) );\n        }\n    ASSETSYS_FREE( sys->memctx, sys->collated );\n    ASSETSYS_FREE( sys->memctx, sys->mounts );\n    strpool_term( &sys->strpool );\n    ASSETSYS_FREE( sys->memctx, sys );\n    }\n\n\nstatic int assetsys_internal_register_collated( assetsys_t* sys, char const* path, int const is_file )\n    {\n    if( path[ 0 ] == '/' && path[ 1 ] == '/' ) ++path;\n\n    ASSETSYS_U64 handle = strpool_inject( &sys->strpool, path, (int) strlen( path ) );\n\n    int first_free = -1;\n    for( int i = 0; i < sys->collated_count; ++i )\n        {\n        if( sys->collated[ i ].ref_count > 0 && sys->collated[ i ].path == handle )\n            {\n            ASSETSYS_ASSERT( is_file == sys->collated[ i ].is_file, \"Entry type mismatch\" );\n            ++sys->collated[ i ].ref_count;\n            strpool_discard( &sys->strpool, handle );\n            return i;\n            }\n        if( sys->collated[ i ].ref_count == 0 ) first_free = i;\n        }\n\n    if( first_free < 0)\n        {\n        if( sys->collated_count >= sys->collated_capacity ) \n            {\n            sys->collated_capacity *= 2;\n            struct assetsys_internal_collated_t* new_collated = (struct assetsys_internal_collated_t*) ASSETSYS_MALLOC( \n                sys->memctx, sizeof( *sys->collated ) * sys->collated_capacity );\n            memcpy( new_collated, sys->collated, sizeof( *sys->collated ) * sys->collated_count );\n            ASSETSYS_FREE( sys->memctx, sys->collated );\n            sys->collated = new_collated;\n            }\n        first_free = sys->collated_count++;\n        }\n\n\n    struct assetsys_internal_collated_t* dir = &sys->collated[ first_free ];\n    dir->path = handle;\n    strpool_incref( &sys->strpool, handle );\n    dir->parent = -1;\n    dir->ref_count = 1;\n    dir->is_file = is_file;\n    return first_free;\n    }\n\n\nstatic void assetsys_internal_collate_directories( assetsys_t* sys, struct assetsys_internal_mount_t* const mount )\n    {\n    for( int i = 0; i < mount->dirs_count; ++i )\n        {\n        struct assetsys_internal_collated_t* subdir = &sys->collated[ mount->dirs[ i ].collated_index ];\n        if( subdir->parent < 0 )\n            {\n            char const* a = assetsys_internal_get_string( sys, subdir->path ); (void) a;\n            char* sub_path = assetsys_internal_dirname( assetsys_internal_get_string( sys, subdir->path ) ) ;\n            ASSETSYS_U64 handle = strpool_inject( &sys->strpool, sub_path, (int) strlen( sub_path ) - 1 );\n            for( int j = 0; j < sys->collated_count; ++j )\n                {\n                struct assetsys_internal_collated_t* dir = &sys->collated[ j ];\n                char const* b = assetsys_internal_get_string( sys, dir->path ); (void) b;\n                if( dir->path == handle )\n                    {\n                    subdir->parent = j;\n                    break;\n                    }\n                }\n            if( subdir->parent < 0 ) strpool_discard( &sys->strpool, handle );\n            }\n        }\n\n    for( int i = 0; i < mount->files_count; ++i )\n        {\n        struct assetsys_internal_collated_t* file = &sys->collated[ mount->files[ i ].collated_index ];\n        if( file->parent < 0 )\n            {\n            char* file_path = assetsys_internal_dirname( assetsys_internal_get_string( sys, file->path ) ) ;\n            ASSETSYS_U64 handle = strpool_inject( &sys->strpool, file_path, file_path[0] == '/' && file_path[1] == '\\0' ? 1 : (int) strlen( file_path ) - 1 );\n            for( int j = 0; j < sys->collated_count; ++j )\n                {\n                struct assetsys_internal_collated_t* dir = &sys->collated[ j ];\n                if( dir->path == handle )\n                    {\n                    file->parent = j;\n                    break;\n                    }\n                }\n            if( file->parent < 0 ) strpool_discard( &sys->strpool, handle );\n            }\n        }\n    }\n\n\nstatic void assetsys_internal_recurse_directories( assetsys_t* sys, int const collated_index, \n    struct assetsys_internal_mount_t* const mount )\n    {\n    char const* path = assetsys_internal_get_string( sys, sys->collated[ collated_index ].path );\n    path += mount->mount_len;\n    if( *path == '/' ) ++path;\n\n    strcpy( sys->temp, assetsys_internal_get_string( sys, mount->path ) );\n    strcat( sys->temp, ( *path == '\\0' || *sys->temp == '\\0' ) ? \"\" : \"/\" );\n    strcat( sys->temp, path );\n\n    struct assetsys_internal_dir_t dir;\n    assetsys_internal_dir_open( &dir, *sys->temp == '\\0' ? \".\" : sys->temp );\n        \n    struct assetsys_internal_dir_entry_t* dirent;\n    for( dirent = assetsys_internal_dir_read( &dir ); dirent != NULL; dirent = assetsys_internal_dir_read( &dir ) )\n        {\n        char const* name = assetsys_internal_dir_name( dirent );\n        if( !name || *name == '\\0' || strcmp( name, \".\" ) == 0 || strcmp( name, \"..\" ) == 0 ) continue;\n        int is_file = assetsys_internal_dir_is_file( dirent );\n        int is_folder = assetsys_internal_dir_is_folder( dirent );\n        if( is_file )\n            {\n            char const* file_path = assetsys_internal_get_string( sys, sys->collated[ collated_index ].path );\n            file_path += mount->mount_len;\n            if( *file_path == '/' ) ++file_path;\n\n            strcpy( sys->temp, assetsys_internal_get_string( sys, mount->path ) );\n            strcat( sys->temp, ( *file_path == '\\0' || *sys->temp == '\\0' ) ? \"\" : \"/\" );\n            strcat( sys->temp, file_path );\n            strcat( sys->temp, *sys->temp == '\\0' ? \"\" : \"/\" );\n            strcat( sys->temp, name );\n\n            struct stat s;\n            if( stat( sys->temp, &s ) == 0 )\n                {\n                strcpy( sys->temp, assetsys_internal_get_string( sys, mount->mounted_as ) );\n                if( *sys->temp && sys->temp[ strlen( sys->temp ) - 1 ] != '/' ) strcat( sys->temp, \"/\" );\n                strcat( sys->temp, file_path );\n                strcat( sys->temp, *file_path == '\\0' ? \"\" : \"/\" );\n                strcat( sys->temp, name );\n\n                if( mount->files_count >= mount->files_capacity )\n                    {\n                    mount->files_capacity *= 2;\n                    struct assetsys_internal_file_t* new_files = (struct assetsys_internal_file_t*) ASSETSYS_MALLOC( \n                        sys->memctx, sizeof( *(mount->files) ) * mount->files_capacity );\n                    memcpy( new_files, mount->files, sizeof( *(mount->files) ) * mount->files_count );\n                    ASSETSYS_FREE( sys->memctx, mount->files );\n                    mount->files = new_files;\n                    }\n\n                struct assetsys_internal_file_t* file = &mount->files[ mount->files_count++ ];\n                file->size = (int) s.st_size;\n                file->zip_index = -1;\n                file->collated_index = assetsys_internal_register_collated( sys, sys->temp, 1 );\n                }\n            }\n        else if( is_folder )\n            {\n            char const* folder_path = assetsys_internal_get_string( sys, sys->collated[ collated_index ].path );\n            folder_path += mount->mount_len;\n            if( *folder_path == '/' ) ++folder_path;\n\n            strcpy( sys->temp, assetsys_internal_get_string( sys, mount->path ) );\n            strcat( sys->temp, ( *folder_path == '\\0' || *sys->temp == '\\0' ) ? \"\" : \"/\" );\n            strcat( sys->temp, folder_path );\n            strcat( sys->temp, *sys->temp == '\\0' ? \"\" : \"/\" );\n            strcat( sys->temp, name );\n\n            struct stat s;\n            if( stat( sys->temp, &s ) == 0 )\n                {\n                strcpy( sys->temp, assetsys_internal_get_string( sys, mount->mounted_as ) );\n                if( *sys->temp && sys->temp[ strlen( sys->temp ) - 1 ] != '/' ) strcat( sys->temp, \"/\" );\n                strcat( sys->temp, folder_path );\n                strcat( sys->temp, *folder_path == '\\0' ? \"\" : \"/\" );\n                strcat( sys->temp, name );\n\n                if( mount->dirs_count >= mount->dirs_capacity )\n                    {\n                    mount->dirs_capacity *= 2;\n                    struct assetsys_internal_folder_t* new_dirs = (struct assetsys_internal_folder_t*) ASSETSYS_MALLOC( \n                        sys->memctx, sizeof( *(mount->dirs) ) * mount->dirs_capacity );\n                    memcpy( new_dirs, mount->dirs, sizeof( *(mount->dirs) ) * mount->dirs_count );\n                    ASSETSYS_FREE( sys->memctx, mount->dirs );\n                    mount->dirs = new_dirs;\n                    }\n                struct assetsys_internal_folder_t* as_dir = &mount->dirs[ mount->dirs_count++ ];\n                as_dir->collated_index = assetsys_internal_register_collated( sys, sys->temp, 0 );\n                assetsys_internal_recurse_directories( sys, as_dir->collated_index, mount );\n                }\n            }        \n        }\n    assetsys_internal_dir_close( &dir );\n    }\n\n/**\n * Mount the given internal mount data into the assetsys instance.\n * \n * @internal\n */\nassetsys_error_t assetsys_internal_mount_files( assetsys_t* sys, struct assetsys_internal_mount_t* mount )\n    {\n    int count = (int) mz_zip_reader_get_num_files( &mount->zip );\n\n    for( int i = 0; i < count; ++i )\n        {\n        if( mz_zip_reader_is_file_a_directory( &mount->zip, (mz_uint) i ) )\n            {\n            if( mount->dirs_count >= mount->dirs_capacity )\n                {\n                mount->dirs_capacity *= 2;\n                struct assetsys_internal_folder_t* new_dirs = (struct assetsys_internal_folder_t*) ASSETSYS_MALLOC( \n                    sys->memctx, sizeof( *(mount->dirs) ) * mount->dirs_capacity );\n                memcpy( new_dirs, mount->dirs, sizeof( *(mount->dirs) ) * mount->dirs_count );\n                ASSETSYS_FREE( sys->memctx, mount->dirs );\n                mount->dirs = new_dirs;\n                }\n\n            char filename[ 1024 ];                \n            mz_zip_reader_get_filename( &mount->zip, (mz_uint) i, filename, sizeof( filename ) );\n\n            struct assetsys_internal_folder_t* as_dir = &mount->dirs[ mount->dirs_count++ ];\n            strcpy( sys->temp, assetsys_internal_get_string( sys, mount->mounted_as ) );\n            strcat( sys->temp, \"/\" );\n            strcat( sys->temp, filename );\n            sys->temp[ strlen( sys->temp )  - 1 ] = '\\0';\n            as_dir->collated_index = assetsys_internal_register_collated( sys, sys->temp, 0 );\n            }\n        }\n\n    for( int i = 0; i < count; ++i )\n        {\n        if( !mz_zip_reader_is_file_a_directory( &mount->zip, (mz_uint) i ) )\n            {\n            if( mount->files_count >= mount->files_capacity )\n                {\n                mount->files_capacity *= 2;\n                struct assetsys_internal_file_t* new_files = (struct assetsys_internal_file_t*) ASSETSYS_MALLOC( \n                    sys->memctx, sizeof( *(mount->files) ) * mount->files_capacity );\n                memcpy( new_files, mount->files, sizeof( *(mount->files) ) * mount->files_count );\n                ASSETSYS_FREE( sys->memctx, mount->files );\n                mount->files = new_files;\n                }\n\n            mz_zip_archive_file_stat stat;\n            mz_bool result = mz_zip_reader_file_stat( &mount->zip, (mz_uint) i, &stat);\n            if( !result )\n                {\n                mz_zip_reader_end( &mount->zip );\n                ASSETSYS_FREE( sys->memctx, mount->dirs );\n                ASSETSYS_FREE( sys->memctx, mount->files );\n                return ASSETSYS_ERROR_FAILED_TO_READ_ZIP;\n                }\n\n            struct assetsys_internal_file_t* file = &mount->files[ mount->files_count++ ];\n            strcpy( sys->temp, assetsys_internal_get_string( sys, mount->mounted_as ) );\n            strcat( sys->temp, \"/\" );\n            strcat( sys->temp, stat.m_filename );\n            file->collated_index = assetsys_internal_register_collated( sys, sys->temp, 1 );\n            file->size = (int) stat.m_uncomp_size;\n            file->zip_index = i;\n\n            char* dir_path = assetsys_internal_dirname( sys->temp );\n            ASSETSYS_U64 handle = strpool_inject( &sys->strpool, dir_path, (int) strlen( dir_path ) - 1 );               \n            int found = 0;\n            for( int j = 0; j < mount->dirs_count; ++j )\n                {\n                if( handle == sys->collated[ mount->dirs[ j ].collated_index ].path )\n                    found = 1;\n                }\n            if( !found ) \n                {\n                struct assetsys_internal_folder_t* as_dir = &mount->dirs[ mount->dirs_count++ ];\n                as_dir->collated_index = assetsys_internal_register_collated( sys, \n                    assetsys_internal_get_string( sys, handle ), 0 );\n                }\n            }\n        }\n\n        return ASSETSYS_SUCCESS;\n    }\n\n/**\n * Creates an internal mount object for use by assetsys.\n * \n * @internal\n */\nstruct assetsys_internal_mount_t* assetsys_internal_create_mount( assetsys_t* sys, enum assetsys_internal_mount_type_t type, char const* path, char const* mount_as )\n    {\n    if( sys->mounts_count >= sys->mounts_capacity )\n        {\n        sys->mounts_capacity *= 2;\n        struct assetsys_internal_mount_t* new_mounts = (struct assetsys_internal_mount_t*) ASSETSYS_MALLOC( sys->memctx, \n            sizeof( *sys->mounts ) * sys->mounts_capacity );\n        memcpy( new_mounts, sys->mounts, sizeof( *sys->mounts ) * sys->mounts_count );\n        ASSETSYS_FREE( sys->memctx, sys->mounts );\n        sys->mounts = new_mounts;\n        }\n\n    struct assetsys_internal_mount_t* mount = &sys->mounts[ sys->mounts_count ];\n\n    mount->mounted_as = assetsys_internal_add_string( sys, mount_as ? mount_as : \"\" );\n    mount->mount_len = mount_as ? (int) strlen( mount_as ) : 0;\n    mount->path = assetsys_internal_add_string( sys, path );\n    mount->type = type;\n        \n    mount->files_count = 0;\n    mount->files_capacity = 4096;\n    mount->files = (struct assetsys_internal_file_t*) ASSETSYS_MALLOC( sys->memctx, \n        sizeof( *(mount->files) ) * mount->files_capacity );\n\n    mount->dirs_count = 0;\n    mount->dirs_capacity = 1024;\n    mount->dirs = (struct assetsys_internal_folder_t*) ASSETSYS_MALLOC( sys->memctx, \n        sizeof( *(mount->dirs) ) * mount->dirs_capacity );\n\n    if( type == ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP )\n        {\n        memset( &mount->zip, 0, sizeof( mount->zip ) );\n        mount->zip.m_pAlloc = assetsys_internal_mz_alloc;\n        mount->zip.m_pRealloc = assetsys_internal_mz_realloc;\n        mount->zip.m_pFree = assetsys_internal_mz_free;\n        mount->zip.m_pAlloc_opaque = sys->memctx;\n        }\n    \n    return mount;\n    }\n\nassetsys_error_t assetsys_mount_from_memory( assetsys_t* sys, void const* data, int size, char const* mount_as)\n    {\n    if (!data) return ASSETSYS_ERROR_INVALID_PARAMETER;\n    if( !mount_as ) return ASSETSYS_ERROR_INVALID_PARAMETER;\n    if( strchr( mount_as, '\\\\' ) ) return ASSETSYS_ERROR_INVALID_PATH;\n    int mount_len = (int) strlen( mount_as );\n    if( mount_len == 0 || mount_as[ 0 ] != '/' || ( mount_len > 1 && mount_as[ mount_len - 1 ] == '/' ) ) \n        return ASSETSYS_ERROR_INVALID_PATH;\n\n    struct assetsys_internal_mount_t* mount = assetsys_internal_create_mount(sys, ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP, \"data\", mount_as);\n\n    mz_bool status = mz_zip_reader_init_mem( &mount->zip, data, size, 0 );\n    if( !status )\n        {\n        ASSETSYS_FREE( sys->memctx, mount->dirs );\n        ASSETSYS_FREE( sys->memctx, mount->files );\n        return ASSETSYS_ERROR_FAILED_TO_READ_ZIP;\n        }\n\n    assetsys_error_t result = assetsys_internal_mount_files( sys, mount );\n    if( result != ASSETSYS_SUCCESS )\n        return result;\n\n    assetsys_internal_collate_directories( sys, mount );\n\n    ++sys->mounts_count;\n    return ASSETSYS_SUCCESS;\n    }\n\nassetsys_error_t assetsys_mount( assetsys_t* sys, char const* path, char const* mount_as )\n    {\n    if( !path ) return ASSETSYS_ERROR_INVALID_PARAMETER;\n    if( !mount_as ) return ASSETSYS_ERROR_INVALID_PARAMETER;\n    if( strchr( path, '\\\\' ) ) return ASSETSYS_ERROR_INVALID_PATH;\n    if( strchr( mount_as, '\\\\' ) ) return ASSETSYS_ERROR_INVALID_PATH;\n    int len = (int) strlen( path );\n    if( len > 1 && path[ len - 1 ] == '/' ) return ASSETSYS_ERROR_INVALID_PATH;     \n    int mount_len = (int) strlen( mount_as );\n    if( mount_len == 0 || mount_as[ 0 ] != '/' || ( mount_len > 1 && mount_as[ mount_len - 1 ] == '/' ) ) \n        return ASSETSYS_ERROR_INVALID_PATH;     \n    \n    enum assetsys_internal_mount_type_t type;\n\n    #if defined( _MSC_VER ) && _MSC_VER >= 1400\n        struct _stat64 s;\n        int res = __stat64( *path == '\\0' ? \".\" : path, &s );\n    #else\n        struct stat s;\n        int res = stat( *path == '\\0' ? \".\" : path, &s );\n    #endif\n    if( res == 0 )\n        {\n        if( s.st_mode & S_IFDIR ) type = ASSETSYS_INTERNAL_MOUNT_TYPE_DIR;\n        else if( s.st_mode & S_IFREG ) type = ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP;\n        else return ASSETSYS_ERROR_INVALID_PATH;\n        }\n    else\n        {\n        return ASSETSYS_ERROR_INVALID_PATH;\n        }\n\n    struct assetsys_internal_mount_t* mount = assetsys_internal_create_mount(sys, type, path, mount_as);\n\n    if( type == ASSETSYS_INTERNAL_MOUNT_TYPE_DIR )\n        {\n        struct assetsys_internal_folder_t* dir = &mount->dirs[ mount->dirs_count++ ];\n        dir->collated_index = assetsys_internal_register_collated( sys, mount_as, 0 );\n        assetsys_internal_recurse_directories( sys, dir->collated_index, mount );\n        }\n    else if( type == ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP )\n        {\n#ifdef MINIZ_NO_STDIO\n        // If we explicitly disable stdio.\n        return ASSETSYS_ERROR_FAILED_TO_READ_ZIP;\n#else\n        mz_bool status = mz_zip_reader_init_file( &mount->zip, path, 0 );\n        if( !status )\n            {\n            ASSETSYS_FREE( sys->memctx, mount->dirs );\n            ASSETSYS_FREE( sys->memctx, mount->files );\n            return ASSETSYS_ERROR_FAILED_TO_READ_ZIP;\n            }\n\n        assetsys_error_t result = assetsys_internal_mount_files( sys, mount );\n        if( result != ASSETSYS_SUCCESS )\n            return result;\n#endif\n        }\n\n    assetsys_internal_collate_directories( sys, mount );\n\n    ++sys->mounts_count;\n    return ASSETSYS_SUCCESS;\n    }\n\n\nstatic void assetsys_internal_remove_collated( assetsys_t* sys, int const index )\n    {\n    struct assetsys_internal_collated_t* coll = &sys->collated[ index ];\n    ASSETSYS_ASSERT( coll->ref_count > 0, \"Invalid ref count\" );\n    --coll->ref_count;\n    if( coll->ref_count == 0 )\n        {\n        strpool_decref( &sys->strpool, coll->path );\n        strpool_discard( &sys->strpool, coll->path );\n        }\n    }\n\n\nassetsys_error_t assetsys_dismount( assetsys_t* sys, char const* path, char const* mounted_as )\n    {\n    if( !path ) return ASSETSYS_ERROR_INVALID_PARAMETER;\n    if( !mounted_as ) return ASSETSYS_ERROR_INVALID_MOUNT;\n\n    ASSETSYS_U64 path_handle = strpool_inject( &sys->strpool, path, (int) strlen( path ) );\n    ASSETSYS_U64 mount_handle = strpool_inject( &sys->strpool, mounted_as, (int) strlen( mounted_as ) );\n\n    for( int i = 0; i < sys->mounts_count; ++i )\n        {\n        struct assetsys_internal_mount_t* mount = &sys->mounts[ i ];\n        if( mount->mounted_as == mount_handle && mount->path == path_handle )\n            {\n            mz_bool result = 1;\n            if( mount->type == ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP ) result = mz_zip_reader_end( &mount->zip );\n\n            strpool_decref( &sys->strpool, mount->mounted_as );\n            strpool_decref( &sys->strpool, mount->path );\n            strpool_discard( &sys->strpool, mount_handle );\n            strpool_discard( &sys->strpool, path_handle );\n            \n            for( int j = 0; j < mount->dirs_count; ++j )\n                assetsys_internal_remove_collated( sys, mount->dirs[ j ].collated_index );\n\n            for( int j = 0; j < mount->files_count; ++j )\n                assetsys_internal_remove_collated( sys, mount->files[ j ].collated_index );\n\n            ASSETSYS_FREE( sys->memctx, mount->dirs );\n            ASSETSYS_FREE( sys->memctx, mount->files );\n\n            int count = sys->mounts_count - i;\n            if( count > 0 ) memcpy( &sys->mounts[ i ], &sys->mounts[ i + 1 ], sizeof( *sys->mounts ) * count );\n            --sys->mounts_count;\n\n            return !result ? ASSETSYS_ERROR_FAILED_TO_CLOSE_ZIP : ASSETSYS_SUCCESS;\n            }\n        }\n\n    strpool_discard( &sys->strpool, mount_handle );\n    strpool_discard( &sys->strpool, path_handle );\n    return ASSETSYS_ERROR_INVALID_MOUNT;\n    }\n\n\nassetsys_error_t assetsys_file( assetsys_t* sys, char const* path, assetsys_file_t* file )\n    {\n    if( !file || !path ) return ASSETSYS_ERROR_INVALID_PARAMETER;\n\n    ASSETSYS_U64 handle = strpool_inject( &sys->strpool, path, (int) strlen( path ) );\n\n    int m = sys->mounts_count;\n    while( m > 0)\n        {\n        --m;\n        struct assetsys_internal_mount_t* mount = &sys->mounts[ m ];\n        for( int i = 0; i < mount->files_count; ++i )\n            {\n            ASSETSYS_U64 h = sys->collated[ mount->files[ i ].collated_index ].path;\n            if( handle == h )\n                {\n                file->mount = mount->mounted_as;\n                file->path = mount->path;\n                file->index = i;\n                return ASSETSYS_SUCCESS;\n                }\n            }\n        }\n\n    strpool_discard( &sys->strpool, handle );\n    return ASSETSYS_ERROR_FILE_NOT_FOUND;\n    }\n\n\nstatic int assetsys_internal_find_mount_index( assetsys_t* sys, ASSETSYS_U64 const mount, ASSETSYS_U64 const path )\n    {\n    for( int i = 0; i < sys->mounts_count; ++i )\n        {\n        if( sys->mounts[ i ].mounted_as == mount && sys->mounts[ i ].path == path )\n            return i;\n        }\n    return -1;\n    }\n\n\nassetsys_error_t assetsys_file_load( assetsys_t* sys, assetsys_file_t f, int* size, void* buffer, int capacity )\n    {\n    int mount_index = assetsys_internal_find_mount_index( sys, f.mount, f.path );\n    if( mount_index < 0 ) return ASSETSYS_ERROR_INVALID_MOUNT;\n\n    struct assetsys_internal_mount_t* mount = &sys->mounts[ mount_index ];\n    struct assetsys_internal_file_t* file = &mount->files[ f.index ];\n    if( mount->type == ASSETSYS_INTERNAL_MOUNT_TYPE_ZIP )\n        {\n        if( size ) *size = (int) file->size;\n        if( file->size > capacity ) return ASSETSYS_ERROR_BUFFER_TOO_SMALL;\n\n        mz_bool result = mz_zip_reader_extract_to_mem_no_alloc( &mount->zip, (mz_uint) file->zip_index, buffer, \n            (size_t) file->size, 0, 0, 0 ); \n        return result ? ASSETSYS_SUCCESS : ASSETSYS_ERROR_FAILED_TO_READ_FILE;\n        }\n    else\n        {\n        strcpy( sys->temp, assetsys_internal_get_string( sys, mount->path ) );\n        strcat( sys->temp, *sys->temp == '\\0' ? \"\" : \"/\" );\n        strcat( sys->temp, assetsys_internal_get_string( sys, \n            sys->collated[ file->collated_index ].path ) + \n            ( strcmp( assetsys_internal_get_string( sys, mount->mounted_as ), \"/\" ) == 0 ? 0 : mount->mount_len + 1 ) );\n        ASSETSYS_FILE* fp = ASSETSYS_FOPEN( sys->temp, \"rb\" );\n        if( !fp ) return ASSETSYS_ERROR_FAILED_TO_READ_FILE;\n        \n        ASSETSYS_FSEEK( fp, 0, ASSETSYS_SEEK_END );\n        int file_size = (int) ASSETSYS_FTELL( fp );\n        ASSETSYS_FSEEK( fp, 0, ASSETSYS_SEEK_SET );\n        if( size ) *size = file_size;\n\n        if( file_size > capacity ) { ASSETSYS_FCLOSE( fp ); return ASSETSYS_ERROR_BUFFER_TOO_SMALL; }\n\n        int size_read = (int) ASSETSYS_FREAD( buffer, 1, (size_t) file_size, fp );\n        ASSETSYS_FCLOSE( fp );\n        if( size_read != file_size ) return ASSETSYS_ERROR_FAILED_TO_READ_FILE;\n\n        return ASSETSYS_SUCCESS;\n        }\n    }\n\n\nint assetsys_file_size( assetsys_t* sys, assetsys_file_t file )\n    {\n    int mount_index = assetsys_internal_find_mount_index( sys, file.mount, file.path );\n    if( mount_index < 0 ) return 0;\n\n    struct assetsys_internal_mount_t* mount = &sys->mounts[ mount_index ];\n    if( mount->type == ASSETSYS_INTERNAL_MOUNT_TYPE_DIR )\n        {\n        strcpy( sys->temp, assetsys_internal_get_string( sys, mount->path ) );\n        strcat( sys->temp, *sys->temp == '\\0' ? \"\" : \"/\" );\n        strcat( sys->temp, assetsys_internal_get_string( sys, \n            sys->collated[ mount->files[ file.index ].collated_index ].path ) + mount->mount_len + 1 );\n        struct stat s;\n        if( stat( sys->temp, &s ) == 0 )\n            mount->files[ file.index ].size = (int) s.st_size;\n        }\n        \n    return mount->files[ file.index ].size;\n    }\n\n\nstatic int assetsys_internal_find_collated( assetsys_t* sys, char const* const path )\n    {\n    ASSETSYS_U64 handle = strpool_inject( &sys->strpool, path, (int) strlen( path ) );\n\n    for( int i = 0; i < sys->collated_count; ++i )\n        {\n        if( sys->collated[ i ].path == handle )\n            {\n            return i;\n            }\n        }\n\n    strpool_discard( &sys->strpool, handle );\n    return -1;\n    }\n\n\nint assetsys_file_count( assetsys_t* sys, char const* path )\n    {\n    if( !path ) return 0;\n    int dir = assetsys_internal_find_collated( sys, path );\n    int count = 0;\n    for( int i = 0; i < sys->collated_count; ++i )\n        {\n        if( sys->collated[ i ].is_file && sys->collated[ i ].parent == dir )\n            {\n            ++count;\n            }\n        }\n    return count;\n    }\n\n\nchar const* assetsys_file_name( assetsys_t* sys, char const* path, int index )\n    {\n    char const* file_path = assetsys_file_path( sys, path, index );\n    if( file_path ) \n        {\n        char const* name = strrchr( file_path, '/' );\n        if( !name ) return file_path;\n        return name + 1;\n        }\n\n    return NULL;\n    }\n\n\nchar const* assetsys_file_path( assetsys_t* sys, char const* path, int index )\n    {\n    if( !path ) return 0;\n    int dir = assetsys_internal_find_collated( sys, path );\n    int count = 0;\n    for( int i = 0; i < sys->collated_count; ++i )\n        {\n        if( sys->collated[ i ].is_file &&  sys->collated[ i ].parent == dir )\n            {\n            if( count == index ) return assetsys_internal_get_string( sys, sys->collated[ i ].path );\n            ++count;\n            }\n        }\n    return NULL;\n    }\n\n\nint assetsys_subdir_count( assetsys_t* sys, char const* path )\n    {\n    if( !path ) return 0;\n    int dir = assetsys_internal_find_collated( sys, path );\n    int count = 0;\n    for( int i = 0; i < sys->collated_count; ++i )\n        {\n        if( !sys->collated[ i ].is_file && sys->collated[ i ].parent == dir )\n            {\n            ++count;\n            }\n        }\n    return count;\n    }\n\n\nchar const* assetsys_subdir_name( assetsys_t* sys, char const* path, int index )\n    {\n    char const* subdir_path = assetsys_subdir_path( sys, path, index );\n    if( subdir_path ) \n        {\n        char const* name = strrchr( subdir_path, '/' );\n        if( !name ) return subdir_path;\n        return name + 1;\n        }\n\n    return NULL;\n    }\n\n\nchar const* assetsys_subdir_path( assetsys_t* sys, char const* path, int index )\n    {\n    if( !path ) return 0;\n    int dir = assetsys_internal_find_collated( sys, path );\n    int count = 0;\n    for( int i = 0; i < sys->collated_count; ++i )\n        {\n        if( !sys->collated[ i ].is_file &&  sys->collated[ i ].parent == dir )\n            {\n            if( count == index ) return assetsys_internal_get_string( sys, sys->collated[ i ].path );\n            ++count;\n            }\n        }\n    return NULL;\n    }\n\n\nstatic char* assetsys_internal_dirname( char const* path )\n    {\n    static char result[ 260 ];\n    strncpy( result, path, sizeof( result ) );\n      \n    char* lastForwardSlash = strrchr( result, '/' );\n\n    if( lastForwardSlash ) *(lastForwardSlash + 1 ) = '\\0';\n    else *result = '\\0';\n\n    return result;\n    }\n\n\n#endif /* ASSETSYS_IMPLEMENTATION */\n\n\n/*\n----------------------\n    TESTS\n----------------------\n*/\n\n\n#ifdef ASSETSYS_RUN_TESTS\n\n#include \"testfw.h\"\n\nvoid test_assetsys( void ) {\n    // Zip file with a test.txt file containing \"Hello, World!\"\n    const unsigned char test_assetsys_data[]  = {\n        0x50, 0x4b, 0x03, 0x04, 0x0a, 0x03, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x9e, 0x23, 0x57, 0x84, 0x9e, \n        0xe8, 0xb4, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x74, 0x65, \n        0x73, 0x74, 0x2e, 0x74, 0x78, 0x74, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x6f, 0x72, \n        0x6c, 0x64, 0x21, 0x0a, 0x50, 0x4b, 0x01, 0x02, 0x3f, 0x03, 0x0a, 0x03, 0x00, 0x00, 0x00, 0x00, \n        0xfc, 0x9e, 0x23, 0x57, 0x84, 0x9e, 0xe8, 0xb4, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, \n        0x08, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0xb4, 0x81, 0x00, 0x00, \n        0x00, 0x00, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x74, 0x78, 0x74, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00, \n        0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x0e, 0xf2, 0x2d, 0xc2, 0xde, 0xd9, 0x01, 0x00, 0x0e, \n        0xf2, 0x2d, 0xc2, 0xde, 0xd9, 0x01, 0x00, 0x0e, 0xf2, 0x2d, 0xc2, 0xde, 0xd9, 0x01, 0x50, 0x4b, \n        0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x34, 0x00, \n        0x00, 0x00, 0x00, 0x00\n    };\n    const int test_assetsys_data_size = 164;\n\n    TESTFW_TEST_BEGIN( \"Test mounting path and loading file\" );\n        {\n        // Create the asset system\n        assetsys_t* assetsys = assetsys_create( 0 );\n        TESTFW_EXPECTED( assetsys != NULL );\n\n        // Mount current working folder as a virtual \"/data\" path\n        TESTFW_EXPECTED( assetsys_mount( assetsys, \".\", \"/data\" ) == ASSETSYS_SUCCESS );\n\n        // Load a file\n        assetsys_file_t file;\n        TESTFW_EXPECTED( assetsys_file( assetsys, \"/data/README.md\", &file ) == ASSETSYS_SUCCESS );\n\n        // Find the size of the file\n        int size = assetsys_file_size( assetsys, file );\n        TESTFW_EXPECTED( size > 30 );\n\n        // Load the file\n        char* content = (char*) malloc( size + 1 ); // extra space for '\\0'\n        int loaded_size = 0;\n        TESTFW_EXPECTED( assetsys_file_load( assetsys, file, &loaded_size, content, size ) == ASSETSYS_SUCCESS );\n        content[ size ] = '\\0'; // zero terminate the text file\n\n        // Clean up\n        free( content );\n        assetsys_destroy( assetsys );\n        }\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Test mounting data and loading file\" );\n        {\n        // Create the asset system\n        assetsys_t* assetsys = assetsys_create( 0 );\n        TESTFW_EXPECTED( assetsys != NULL );\n\n        // Mount current working folder as a virtual \"/data\" path\n        TESTFW_EXPECTED( assetsys_mount_from_memory( assetsys, test_assetsys_data, test_assetsys_data_size, \"/data\" ) == ASSETSYS_SUCCESS );\n\n        // Load a file\n        assetsys_file_t file;\n        TESTFW_EXPECTED( assetsys_file( assetsys, \"/data/test.txt\", &file ) == ASSETSYS_SUCCESS );\n\n        // Find the size of the file\n        int size = assetsys_file_size( assetsys, file );\n        TESTFW_EXPECTED( size > 10 );\n\n        // Load the file\n        char* content = (char*) malloc( size + 1 ); // extra space for '\\0'\n        int loaded_size = 0;\n        TESTFW_EXPECTED( assetsys_file_load( assetsys, file, &loaded_size, content, size ) == ASSETSYS_SUCCESS );\n        content[ size ] = '\\0'; // zero terminate the text file\n\n        TESTFW_EXPECTED( content[0] == 'H' );\n        TESTFW_EXPECTED( content[1] == 'e' );\n        TESTFW_EXPECTED( content[2] == 'l' );\n        TESTFW_EXPECTED( content[3] == 'l' );\n        TESTFW_EXPECTED( content[4] == 'o' );\n\n        // Clean up\n        free( content );\n        assetsys_destroy( assetsys );\n        }\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Test mounting zip file directly\" );\n        {\n        // Save the test.zip file to the file system.\n        ASSETSYS_FILE* fp = ASSETSYS_FOPEN( \"test.zip\", \"wb\" );\n        TESTFW_EXPECTED(fp != NULL);\n        ASSETSYS_FWRITE(test_assetsys_data, 1, test_assetsys_data_size, fp);\n        ASSETSYS_FCLOSE(fp);\n\n        // Create the asset system\n        assetsys_t* assetsys = assetsys_create( 0 );\n        TESTFW_EXPECTED( assetsys != NULL );\n\n        // Mount the test.zip file as a virtual \"/datafile\" path\n        TESTFW_EXPECTED( assetsys_mount( assetsys, \"test.zip\", \"/datafile\" ) == ASSETSYS_SUCCESS );\n\n        // Load a file\n        assetsys_file_t file;\n        TESTFW_EXPECTED( assetsys_file( assetsys, \"/datafile/test.txt\", &file ) == ASSETSYS_SUCCESS );\n\n        // Find the size of the file\n        int size = assetsys_file_size( assetsys, file);\n        TESTFW_EXPECTED( size > 5 );\n\n        // Load the file\n        char* content = (char*) malloc( size + 1 ); // extra space for '\\0'\n        int loaded_size = 0;\n        TESTFW_EXPECTED( assetsys_file_load( assetsys, file, &loaded_size, content, size ) == ASSETSYS_SUCCESS );\n        TESTFW_EXPECTED( content[0] == 'H' );\n        TESTFW_EXPECTED( content[1] == 'e' );\n        TESTFW_EXPECTED( content[2] == 'l' );\n        TESTFW_EXPECTED( content[3] == 'l' );\n        TESTFW_EXPECTED( content[4] == 'o' );\n\n        // Clean up\n        free( content );\n        assetsys_destroy( assetsys );\n        }\n    TESTFW_TEST_END();\n}\n\n\nint main( int argc, char** argv ) {\n    (void) argc, argv;\n\n    TESTFW_INIT();\n    \n    test_assetsys();\n\n    return TESTFW_SUMMARY();\n}\n\n\n// pass-through so the program will build with either /SUBSYSTEM:WINDOWS or /SUBSYSTEM:CONSOLE\n#if defined( _WIN32 ) && !defined( __TINYC__ )\n    #include <stdlib.h>\n    #ifdef __cplusplus \n        extern \"C\" int __stdcall WinMain( struct HINSTANCE__*, struct HINSTANCE__*, char*, int ) { \n            return main( __argc, __argv ); \n        }\n    #else\n        struct HINSTANCE__;\n        int __stdcall WinMain( struct HINSTANCE__* a, struct HINSTANCE__* b, char* c, int d ) { \n            (void) a, b, c, d; return main( __argc, __argv ); \n        }\n    #endif\n#endif\n\n#define TESTFW_IMPLEMENTATION\n#include \"testfw.h\"\n\n#endif /* ASSETSYS_RUN_TESTS */\n\n\n/*\n\ncontributors:\n    Randy Gaul (hotloading support)\n    Rob Loach (assetsys_mount_from_memory)\n\nrevision history:\n    1.5     fix issue where mount as root \"/\" didn't work when mounting folder\n    1.4     allow mounting from memory\n    1.3     allow absolute paths when mounting, update docs for mount as root\n    1.2     asserts with message, eliminated a frequent small allocation\n    1.1     changes to support loading assets being re-saved during execution\n    1.0     first released version  \n\n*/\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\nUses public domain code for \"miniz\" zip file support - original license can be \nfound in the miniz section of this file.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n    \n"
        },
        {
          "name": "audiosys.h",
          "type": "blob",
          "size": 42.9248046875,
          "content": "/*\n------------------------------------------------------------------------------\n\t\t  Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\naudiosys.h - v0.1 - Sound and music playback (mixing only) for C/C++.\n\nDo this:\n\t#define AUDIOSYS_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef audiosys_h\n#define audiosys_h\n\n#ifndef AUDIOSYS_S16\n\t#define AUDIOSYS_S16 signed short\n#endif\n\n#ifndef AUDIOSYS_U64\n\t#define AUDIOSYS_U64 unsigned long long\n#endif\n\n#define AUDIOSYS_DEFAULT_VOICE_COUNT 16\n\ntypedef struct audiosys_audio_source_t {\n\tvoid* instance;\n\tvoid (*release)( void* instance );\n\tint (*read_samples)( void* instance, float* sample_pairs, int sample_pairs_count );\n\tvoid (*restart)( void* instance );\n\tvoid (*set_position)( void* instance, int position_in_sample_pairs );\n\tint (*get_position)( void* instance );\n} audiosys_audio_source_t;\n\n\ntypedef struct audiosys_t audiosys_t;\n\naudiosys_t* audiosys_create( int active_voice_count, void* memctx );\nvoid audiosys_destroy( audiosys_t* audiosys );\n\nvoid audiosys_render( audiosys_t* audiosys, AUDIOSYS_S16* output_sample_pairs, int sample_pairs_count );\n\nvoid audiosys_master_volume_set( audiosys_t* audiosys, float volume );\nfloat audiosys_master_volume( audiosys_t* audiosys );\n\nvoid audiosys_gain_set( audiosys_t* audiosys, float gain );\nfloat audiosys_gain( audiosys_t* audiosys );\n\nvoid audiosys_pause( audiosys_t* audiosys );\nvoid audiosys_resume( audiosys_t* audiosys );\n\nvoid audiosys_stop_all( audiosys_t* audiosys );\n\ntypedef enum audiosys_paused_t {\n\tAUDIOSYS_NOT_PAUSED,\n\tAUDIOSYS_PAUSED,\n} audiosys_paused_t;\n\naudiosys_paused_t audiosys_paused( audiosys_t* audiosys );\n\n\ntypedef enum audiosys_loop_t {\n\tAUDIOSYS_LOOP_OFF,\n\tAUDIOSYS_LOOP_ON,\n} audiosys_loop_t;\n\nvoid audiosys_music_play( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_in_time );\nvoid audiosys_music_stop( audiosys_t* audiosys, float fade_out_time );\nvoid audiosys_music_pause( audiosys_t* audiosys );\nvoid audiosys_music_resume( audiosys_t* audiosys );\nvoid audiosys_music_switch( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_out_time, float fade_in_time );\nvoid audiosys_music_cross_fade( audiosys_t* audiosys, audiosys_audio_source_t source, float cross_fade_time );\nvoid audiosys_music_position_set( audiosys_t* audiosys, float position );\nfloat audiosys_music_position( audiosys_t* audiosys );\naudiosys_audio_source_t audiosys_music_source( audiosys_t* audiosys );\nvoid audiosys_music_loop_set( audiosys_t* audiosys, audiosys_loop_t loop );\naudiosys_loop_t audiosys_music_loop( audiosys_t* audiosys );\nvoid audiosys_music_volume_set( audiosys_t* audiosys, float volume );\nfloat audiosys_music_volume( audiosys_t* audiosys );\nvoid audiosys_music_pan_set( audiosys_t* audiosys, float pan );\nfloat audiosys_music_pan( audiosys_t* audiosys );\n\nvoid audiosys_ambience_play( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_in_time );\nvoid audiosys_ambience_stop( audiosys_t* audiosys, float fade_out_time );\nvoid audiosys_ambience_pause( audiosys_t* audiosys );\nvoid audiosys_ambience_resume( audiosys_t* audiosys );\nvoid audiosys_ambience_switch( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_out_time, float fade_in_time );\nvoid audiosys_ambience_cross_fade( audiosys_t* audiosys, audiosys_audio_source_t source, float cross_fade_time );\nvoid audiosys_ambience_position_set( audiosys_t* audiosys, float position );\nfloat audiosys_ambience_position( audiosys_t* audiosys );\naudiosys_audio_source_t audiosys_ambience_source( audiosys_t* audiosys );\nvoid audiosys_ambience_loop_set( audiosys_t* audiosys, audiosys_loop_t loop );\naudiosys_loop_t audiosys_ambience_loop( audiosys_t* audiosys );\nvoid audiosys_ambience_volume_set( audiosys_t* audiosys, float volume );\nfloat audiosys_ambience_volume( audiosys_t* audiosys );\nvoid audiosys_ambience_pan_set( audiosys_t* audiosys, float pan );\nfloat audiosys_ambience_pan( audiosys_t* audiosys );\n\nAUDIOSYS_U64 audiosys_sound_play( audiosys_t* audiosys, audiosys_audio_source_t source, float priority, float fade_in_time );\nvoid audiosys_sound_stop( audiosys_t* audiosys, AUDIOSYS_U64 handle, float fade_out_time );\nvoid audiosys_sound_pause( audiosys_t* audiosys, AUDIOSYS_U64 handle );\nvoid audiosys_sound_resume( audiosys_t* audiosys, AUDIOSYS_U64 handle );\nvoid audiosys_sound_position_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, float position );\nfloat audiosys_sound_position( audiosys_t* audiosys, AUDIOSYS_U64 handle );\naudiosys_audio_source_t audiosys_sound_source( audiosys_t* audiosys, AUDIOSYS_U64 handle );\nvoid audiosys_sound_loop_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, audiosys_loop_t loop );\naudiosys_loop_t audiosys_sound_loop( audiosys_t* audiosys, AUDIOSYS_U64 handle );\nvoid audiosys_sound_volume_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, float volume );\nfloat audiosys_sound_volume( audiosys_t* audiosys, AUDIOSYS_U64 handle );\nvoid audiosys_sound_pan_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, float pan );\nfloat audiosys_sound_pan( audiosys_t* audiosys, AUDIOSYS_U64 handle );\n\n\ntypedef enum audiosys_sound_valid_t {\n\tAUDIOSYS_SOUND_INVALID,\n\tAUDIOSYS_SOUND_VALID,\n} audiosys_sound_valid_t;\n\naudiosys_sound_valid_t audiosys_sound_valid(audiosys_t* audiosys, AUDIOSYS_U64 handle );\n\n#endif /* audiosys_h */\n\n/*\n----------------------\n\tIMPLEMENTATION\n----------------------\n*/\n\n#ifdef AUDIOSYS_IMPLEMENTATION\n#undef AUDIOSYS_IMPLEMENTATION\n\n#ifndef AUDIOSYS_MALLOC\n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <stdlib.h>\n\t#define AUDIOSYS_MALLOC( ctx, size ) ( malloc( size ) )\n\t#define AUDIOSYS_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n#ifndef AUDIOSYS_ASSERT\n\t#undef _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#undef _CRT_SECURE_NO_WARNINGS\n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <assert.h>\n\t#define AUDIOSYS_ASSERT( expression, message ) assert( ( expression ) && ( message ) )\n#endif\n\n#ifndef AUDIOSYS_MEMCPY\n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <string.h>\n\t#define AUDIOSYS_MEMCPY( dst, src, cnt ) ( memcpy( (dst), (src), (cnt) ) )\n#endif \n\n#ifndef AUDIOSYS_MEMSET\n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <string.h>\n\t#define AUDIOSYS_MEMSET( dst, val, cnt ) ( memset( (dst), (val), (cnt) ) )\n#endif \n\n#ifndef AUDIOSYS_MEMMOVE\n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <string.h>\n\t#define AUDIOSYS_MEMMOVE( dst, src, cnt ) ( memmove((dst), (src), (cnt) ) )\n#endif \n\n\ntypedef struct audiosys_internal_handles_data_t {\n\tint index;\n\tint counter;\n} audiosys_internal_handles_data_t;\n\n\ntypedef struct audiosys_internal_handles_t {\n\tvoid* memctx;\n\tstruct audiosys_internal_handles_data_t* data;\n\tint capacity;\n\tint count;\n\tint freelist_head;\n\tint freelist_tail;\n} audiosys_internal_handles_t;\n\n\nstatic void audiosys_internal_handles_init( audiosys_internal_handles_t* handles, int initial_capacity, void* memctx ) {\n\thandles->memctx = memctx;\n\thandles->count = 0;\n\thandles->capacity = initial_capacity <= 0 ? 1 : initial_capacity;\n\thandles->freelist_head = -1;\n\thandles->freelist_tail = -1;\n\thandles->data = (struct audiosys_internal_handles_data_t*) AUDIOSYS_MALLOC( memctx, handles->capacity * sizeof( *handles->data ) );\n\tAUDIOSYS_ASSERT( handles->data, \"Allocation failed\" );\n}\n\n\nstatic void audiosys_internal_handles_term( audiosys_internal_handles_t* handles ) {\n\t//AUDIOSYS_FREE( handles->memctx, handles->data );\n}\n\n\nstatic int audiosys_internal_handles_alloc( audiosys_internal_handles_t* handles, int index ) {\n\tint handle;\n\n\tif( handles->count < handles->capacity ) {\n\t\thandle = handles->count;\n\t\thandles->data[ handles->count ].counter = 0;\n\t\t++handles->count;           \n\t} else if( handles->freelist_head >= 0 ) {\n\t\thandle = handles->freelist_head;\n\t\tif( handles->freelist_tail == handles->freelist_head ) handles->freelist_tail = handles->data[ handles->freelist_head ].index;\n\t\thandles->freelist_head = handles->data[ handles->freelist_head ].index;                     \n\t} else {\n\t\thandles->capacity *= 2;\n\t\tstruct audiosys_internal_handles_data_t* new_data = (struct audiosys_internal_handles_data_t*) AUDIOSYS_MALLOC( handles->memctx, handles->capacity * sizeof( *handles->data ) );\n\t\tAUDIOSYS_ASSERT( new_data, \"Allocation failed\" );\n\t\tAUDIOSYS_MEMCPY( new_data, handles->data, handles->count * sizeof( *handles->data ) );\n\t\tAUDIOSYS_FREE( handles->memctx, handles->data );\n\t\thandles->data = new_data;\n\t\thandle = handles->count;\n\t\thandles->data[ handles->count ].counter = 0;\n\t\t++handles->count;           \n\t}\n\n\thandles->data[ handle ].index = index;\n\treturn handle;\n}\n\n\nstatic void audiosys_internal_handles_release( audiosys_internal_handles_t* handles, int handle ) {\n\tif( handles->freelist_tail < 0 ) {\n\t\tAUDIOSYS_ASSERT( handles->freelist_head < 0, \"Freelist invalid\" );\n\t\thandles->freelist_head = handle;\n\t\thandles->freelist_tail = handle;\n\t} else {\n\t\thandles->data[ handles->freelist_tail ].index = handle;\n\t\thandles->freelist_tail = handle;\n\t}\n\t++handles->data[ handle ].counter; // invalidate handle via counter\n\thandles->data[ handle ].index = -1;\n}\n\n\nstatic int audiosys_internal_handles_index( audiosys_internal_handles_t* handles, int handle ) {\n\tif( handle >= 0 && handle < handles->count ) {\n\t\treturn handles->data[ handle ].index;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n\nstatic void audiosys_internal_handles_update( audiosys_internal_handles_t* handles, int handle, int index ) {\n\thandles->data[ handle ].index = index;\n}\n\n\nstatic uint64_t audiosys_internal_to_u64( int handle, int counter ) {\n\tuint64_t i = (uint64_t) ( handle + 1 );\n\tuint64_t c = (uint64_t) counter;\n\treturn ( c << 32ull ) | ( i );\n}\n\n\nstatic int audiosys_internal_u64_to_counter( uint64_t u ) {\n\treturn (int) ( u >> 32ull ) ;\n}\n\t\n\nstatic int audiosys_internal_u64_to_handle( uint64_t u ) {\n\treturn ( (int) ( u & 0xffffffffull ) ) - 1;\n}\n\n\nstatic uint64_t audiosys_internal_handles_to_u64( audiosys_internal_handles_t* handles, int handle ) {\n\treturn audiosys_internal_to_u64( handle, handles->data[ handle ].counter );\n}\n\n\nstatic int audiosys_internal_handles_from_u64( audiosys_internal_handles_t* handles, uint64_t u ) {\n\tint handle = audiosys_internal_u64_to_handle( u );\n\tif( handle >= 0 && handle < handles->count && handles->data[ handle ].counter == audiosys_internal_u64_to_counter( u ) ) {\n\t\treturn handle;\n\t} else {\n\t\treturn -1;\n\t}\n}\n\n\ntypedef enum audiosys_internal_voice_state_t {\n\tAUDIOSYS_INTERNAL_VOICE_STATE_STOPPED,\n\tAUDIOSYS_INTERNAL_VOICE_STATE_PLAYING,\n\tAUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN,\n\tAUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT,\n\tAUDIOSYS_INTERNAL_VOICE_STATE_CROSSFADING,\n\tAUDIOSYS_INTERNAL_VOICE_STATE_QUEUED,\n} audiosys_internal_voice_state_t;\n\n\ntypedef struct audiosys_internal_voice_t {\n\tAUDIOSYS_U64 handle;\n\taudiosys_internal_voice_state_t state;\n\taudiosys_audio_source_t source;\n\tint initialized;\n\tint paused;\n\tint loop;\n\tfloat priority;\n\tfloat volume;\n\tfloat pan;\n\tfloat fade_in_time;\n\tfloat fade_out_time;\n\tfloat fade_progress;\n\n\tfloat current_fade_volume;\n\tfloat current_fade_delta;\n} audiosys_internal_voice_t;\n\n\nstruct audiosys_t {\n\tvoid* memctx;\n\n\tint use_soft_clip;\n\tint active_voice_count;\n\tfloat master_volume;\n\tfloat gain;\n\tint paused;\n\t\n\taudiosys_internal_voice_t music;\n\taudiosys_internal_voice_t music_crossfade;\n\tfloat music_crossfade_time;\n\t\n\taudiosys_internal_voice_t ambience;\n\taudiosys_internal_voice_t ambience_crossfade;\n\tfloat ambience_crossfade_time;\n\t\n\tint sounds_capacity;\n\tint sounds_count;\n\tAUDIOSYS_U64* sounds_by_priority;\n\taudiosys_internal_voice_t* sounds;\n\taudiosys_internal_handles_t sounds_handles;\n\t\n\tint mixing_buffer_size;\n\tfloat* mixing_buffer;\n\tfloat* sample_buffer;\n};\n\n\nstatic void audiosys_internal_release_source( audiosys_audio_source_t* source ) {\n\tif( source->release ) {\n\t\tsource->release( source->instance );\n\t}\n\tsource->instance = NULL;\n\tsource->release = NULL;\n\tsource->read_samples = NULL;\n\tsource->restart = NULL;\n\tsource->set_position = NULL;\n\tsource->get_position = NULL;\n}\n\n\naudiosys_t* audiosys_create( int active_voice_count, void* memctx ) {\n\taudiosys_t* audiosys = (audiosys_t*) AUDIOSYS_MALLOC( memctx, sizeof( audiosys_t ) );\n\tAUDIOSYS_MEMSET( audiosys, 0, sizeof( audiosys_t ) );\n\n\taudiosys->memctx = memctx;\n\n\taudiosys->use_soft_clip = true;\n\taudiosys->active_voice_count= active_voice_count;\n\taudiosys->master_volume = 1.0f;\n\taudiosys->gain = 1.0f;\n\taudiosys->paused = 0;\n\n\taudiosys->music.volume = 1.0f;\n\taudiosys->music.loop = true;\n\taudiosys->music_crossfade.volume = 1.0f;\n\taudiosys->music_crossfade.loop = true;\n\n\taudiosys->ambience.volume = 1.0f;\n\taudiosys->ambience.loop = true;\n\taudiosys->ambience_crossfade.volume = 1.0f;\n\taudiosys->ambience_crossfade.loop = true;\n\n\taudiosys->sounds_capacity = 64;\n\taudiosys->sounds_count = 0;\n\taudiosys->sounds_by_priority = (AUDIOSYS_U64*) AUDIOSYS_MALLOC( memctx, sizeof( AUDIOSYS_U64 ) * audiosys->sounds_capacity );\n\tAUDIOSYS_MEMSET( audiosys->sounds_by_priority, 0, sizeof( AUDIOSYS_U64 ) * audiosys->sounds_capacity );\n\taudiosys->sounds = (audiosys_internal_voice_t*) AUDIOSYS_MALLOC( memctx, sizeof( audiosys_internal_voice_t ) * audiosys->sounds_capacity );\n\taudiosys_internal_handles_init( &audiosys->sounds_handles, audiosys->sounds_capacity, memctx );   \n\n\treturn audiosys;\n}\n\n\nvoid audiosys_destroy( audiosys_t* audiosys ) {\n\taudiosys_internal_release_source( &audiosys->music.source );\n\taudiosys_internal_release_source( &audiosys->music_crossfade.source );\n\taudiosys_internal_release_source( &audiosys->ambience.source );\n\taudiosys_internal_release_source( &audiosys->ambience_crossfade.source );\n\tfor( int i = 0; i < audiosys->sounds_count; ++i ) {\n\t\taudiosys_internal_release_source( &audiosys->sounds[ i ].source );\n\t}\n\n\taudiosys_internal_handles_term( &audiosys->sounds_handles );\n\tAUDIOSYS_FREE( audiosys->memctx, audiosys->sounds_by_priority );\n\tAUDIOSYS_FREE( audiosys->memctx, audiosys->sounds );\n\n\tif( audiosys->mixing_buffer ) {\n\t\tAUDIOSYS_FREE( audiosys->memctx, audiosys->mixing_buffer );\n\t}\n\n\tif( audiosys->sample_buffer ) {\n\t\tAUDIOSYS_FREE( audiosys->memctx, audiosys->sample_buffer );\n\t}\n\n\tAUDIOSYS_FREE( audiosys->memctx, audiosys );\n}\n\n\nstatic audiosys_internal_voice_t* audiosys_internal_get_sound( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\tint index = audiosys_internal_handles_index( &audiosys->sounds_handles, audiosys_internal_handles_from_u64( &audiosys->sounds_handles, handle ) );\n\tif( index < 0 ) { \n\t\treturn 0;\n\t}\n\treturn &audiosys->sounds[ index ];\n}\n\n\nstatic AUDIOSYS_U64 audiosys_internal_add_sound( audiosys_t* audiosys, audiosys_internal_voice_t** sound, float priority ) {\n\tif( audiosys->sounds_count >= audiosys->sounds_capacity ) {\n\t\tint new_capacity = audiosys->sounds_capacity * 2;\n\t\tAUDIOSYS_U64* new_sounds_by_priority = (AUDIOSYS_U64*) AUDIOSYS_MALLOC( memctx, sizeof( AUDIOSYS_U64 ) * new_capacity );\n\t\taudiosys_internal_voice_t* new_sounds = (audiosys_internal_voice_t*) AUDIOSYS_MALLOC( memctx, sizeof( audiosys_internal_voice_t ) * new_capacity );\n\t\tAUDIOSYS_MEMCPY( new_sounds_by_priority, audiosys->sounds_by_priority, sizeof( AUDIOSYS_U64 ) * audiosys->sounds_count );\n\t\tAUDIOSYS_MEMCPY( new_sounds, audiosys->sounds, sizeof( audiosys_internal_voice_t ) * audiosys->sounds_count );\n\t\tAUDIOSYS_FREE( audiosys->memctx, audiosys->sounds_by_priority );\n\t\tAUDIOSYS_FREE( audiosys->memctx, audiosys->sounds );\n\t\taudiosys->sounds_capacity = new_capacity;\n\t\taudiosys->sounds_by_priority = new_sounds_by_priority;\n\t\taudiosys->sounds = new_sounds;\n\t}\n\n\tint index = audiosys->sounds_count;\n\tif( audiosys->sounds_count > 0 ) {\n\t\tint min_index = 0; \n\t\tint max_index = audiosys->sounds_count - 1;\n\t\twhile( min_index <= max_index ) {\n\t\t\tint center = ( max_index - min_index ) / 2 + min_index;\n\t\t\taudiosys_internal_voice_t* snd = audiosys_internal_get_sound( audiosys, audiosys->sounds_by_priority[ center ] );\n\t\t\tfloat center_prio = snd->priority;\n\t\t\tif( center_prio <= priority ) {\n\t\t\t\tmax_index = center - 1;\n\t\t\t} else {\n\t\t\t\tmin_index = center + 1;\n\t\t\t}\n\t\t}\n\t\tindex = min_index;\n\t}\n\t\n\t++audiosys->sounds_count;\n\t*sound = &audiosys->sounds[ audiosys->sounds_count - 1 ];\n\tAUDIOSYS_U64 handle = audiosys_internal_handles_to_u64( &audiosys->sounds_handles, audiosys_internal_handles_alloc( &audiosys->sounds_handles, audiosys->sounds_count - 1 ) );\n\n\tfor( int i = audiosys->sounds_count - 1; i > index ; --i ) {\n\t\taudiosys->sounds_by_priority[ i ] = audiosys->sounds_by_priority[ i - 1 ];\n\t}\n\n\taudiosys->sounds_by_priority[ index ] = handle;\n\treturn handle;\n}\n\n\t\nstatic void audiosys_internal_remove_sound( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\tint index = audiosys_internal_handles_index( &audiosys->sounds_handles, audiosys_internal_handles_from_u64( &audiosys->sounds_handles, handle ) );\n\tif( index < 0 ) {\n\t\treturn;\n\t}\n\n\taudiosys_internal_handles_release( &audiosys->sounds_handles, audiosys_internal_handles_from_u64( &audiosys->sounds_handles, handle ) );\n\taudiosys_internal_voice_t* sound_to_remove = &audiosys->sounds[ index ];\n\taudiosys_internal_release_source( &sound_to_remove->source );\n\n\tfor( int j = 0; j < audiosys->sounds_count; ++j ) {\n\t\tif( audiosys->sounds_by_priority[ j ] == handle ) {\n\t\t\tfor( int i = j; i < audiosys->sounds_count - 1; ++i ) {\n\t\t\t\taudiosys->sounds_by_priority[ i ] = audiosys->sounds_by_priority[ i + 1 ];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\taudiosys_internal_voice_t* last_sound = &audiosys->sounds[ audiosys->sounds_count - 1 ];\n\taudiosys_internal_handles_update( &audiosys->sounds_handles, audiosys_internal_handles_from_u64( &audiosys->sounds_handles, last_sound->handle ), index );\n\t--audiosys->sounds_count;\n\n\t*sound_to_remove = *last_sound;\n}\n\t\n\nvoid audiosys_internal_update_fading( audiosys_internal_voice_t* voice, float delta_time ) {\n\tif( !voice ) {\n\t\treturn;\n\t}\n\n\tfloat fade_volume = 1.0f;\n\tfloat fade_delta = 0.0f;\n\tif( voice->state == AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT && voice->fade_out_time > 0.0f ) {\n\t\tvoice->fade_progress -= delta_time / voice->fade_out_time;\n\t\tif( voice->fade_progress <= 0.0f ) {\n\t\t\tvoice->fade_progress = 0.0f;\n\t\t\tvoice->state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t\t\tfade_volume = 0.0f;\n\t\t\taudiosys_internal_release_source( &voice->source );\n\t\t} else {\n\t\t\tfloat volume_dec_per_second = 1.0f / voice->fade_out_time;\n\t\t\tfloat volume_dec_per_sample = volume_dec_per_second / 44100.0f;\n\t\t\tfade_volume = voice->fade_progress;\n\t\t\tfade_volume = fade_volume < 0.0f ? 0.0f : fade_volume > 1.0f ? 1.0f : fade_volume;\t\t\t\n\t\t\tfade_delta = -volume_dec_per_sample;\n\t\t}\n\t} else if( voice->state == AUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN && voice->fade_in_time > 0.0f ) {\n\t\tvoice->fade_progress += delta_time / voice->fade_in_time;\n\t\tif( voice->fade_progress >= 1.0f ) {\t\t\t\t\n\t\t\tvoice->fade_progress = 1.0f;\n\t\t\tvoice->state = AUDIOSYS_INTERNAL_VOICE_STATE_PLAYING;\n\t\t\tfade_volume = 1.0f;\n\t\t\t} else {\n\t\t\tfloat volume_inc_per_second = 1.0f / voice->fade_in_time;\n\t\t\tfloat volume_inc_per_sample = volume_inc_per_second / 44100.0f;\n\t\t\tfade_volume = voice->fade_progress;\n\t\t\tfade_volume = fade_volume < 0.0f ? 0.0f : fade_volume > 1.0f ? 1.0f : fade_volume;\t\t\t\n\t\t\tfade_delta = volume_inc_per_sample;\n\t\t}\n\t}\n\n\tvoice->current_fade_volume = fade_volume;\n\tvoice->current_fade_delta = fade_delta;\n}\n\n\nvoid audiosys_internal_update_from_source( audiosys_t* audiosys, audiosys_internal_voice_t* voice, float* output_sample_pairs, int sample_pairs_count ) {\n\tint samples_to_write = sample_pairs_count;\n\tif( !voice->initialized ) {\n\t\taudiosys_internal_update_fading( voice, 0.0f );\n\t\tvoice->initialized = 1;\n\t} else {        \n\t\taudiosys_internal_update_fading( voice, sample_pairs_count / 44100.0f );\n\t}\n\n\tif( !voice->source.read_samples || voice->state == AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED ) {\n\t\tAUDIOSYS_MEMSET( output_sample_pairs, 0, sample_pairs_count * sizeof( float ) * 2 );\n\t\treturn;\n\t}\n\n\tfloat* out = output_sample_pairs;\n\tint count_written = voice->source.read_samples( voice->source.instance, out, samples_to_write );\n\tout += count_written * 2;\n\twhile( count_written < samples_to_write ) {\n\t\tif( voice->loop && voice->source.restart ) {\n\t\t\tvoice->source.restart( voice->source.instance );\n\t\t\tint written = voice->source.read_samples( voice->source.instance, out, samples_to_write - count_written );\n\t\t\tout += written * 2;\n\t\t\tcount_written += written;\n\t\t} else {\n\t\t\taudiosys_internal_release_source( &voice->source );\n\t\t\tfor( int i = 0; i < ( samples_to_write - count_written ) * 2; ++i ) {\n\t\t\t\tout[ i ] = 0.0f;\t\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n   \nvoid audiosys_internal_mix_voice( audiosys_t* audiosys, audiosys_internal_voice_t* voice, float* sample_pairs, int sample_pairs_count ) {\n\tif( !voice ) {\n\t\treturn;\n\t}\n\n\taudiosys_internal_update_from_source( audiosys, voice, sample_pairs, sample_pairs_count );\n\n\tfloat fade_volume = voice->current_fade_volume;\n\tfloat fade_delta = voice->current_fade_delta;\n\n\tif( voice->pan < 0.0f && fade_delta != 0.0f ) {\n\t\tfloat a = -voice->pan; \n\t\tfloat ia = 1.0f - a;\n\t\tfor( int i = 0; i < sample_pairs_count; ++i ) {\n\t\t    float l = sample_pairs[ i * 2 + 0 ];\n\t\t    float r = sample_pairs[ i * 2 + 1 ];\n\t\t\tfloat left = l + a * r;\n\t\t\tfloat right = r * ia;\n\t\t    left *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    right *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    audiosys->mixing_buffer[ i * 2 + 0 ] += left;\n\t\t    audiosys->mixing_buffer[ i * 2 + 1 ] += right;\n\t\t\tfade_volume += fade_delta;\n\t\t\tfade_volume = fade_volume < 0.0f ? 0.0f : fade_volume > 1.0f ? 1.0f : fade_volume;\t\t\t\n\t\t}\n\t} else if( voice->pan > 0.0f && fade_delta != 0.0f ) {\n\t\tfloat a = voice->pan;\n\t\tfloat ia = 1.0f - a;\n\t\tfor( int i = 0; i < sample_pairs_count; ++i ) {\n\t\t    float l = sample_pairs[ i * 2 + 0 ];\n\t\t    float r = sample_pairs[ i * 2 + 1 ];\n\t\t\tfloat right = l * a + r;\n\t\t\tfloat left = l * ia;\n\t\t    left *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    right *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    audiosys->mixing_buffer[ i * 2 + 0 ] += left;\n\t\t    audiosys->mixing_buffer[ i * 2 + 1 ] += right;\n\t\t\tfade_volume += fade_delta;\n\t\t\tfade_volume = fade_volume < 0.0f ? 0.0f : fade_volume > 1.0f ? 1.0f : fade_volume;\t\t\t\n\t\t}\n\t} else if( voice->pan < 0.0f && fade_delta == 0.0f ) {\n\t\tfloat a = -voice->pan; \n\t\tfloat ia = 1.0f - a;\n\t\tfor( int i = 0; i < sample_pairs_count; ++i ) {\n\t\t    float l = sample_pairs[ i * 2 + 0 ];\n\t\t    float r = sample_pairs[ i * 2 + 1 ];\n\t\t\tfloat left = l + a * r;\n\t\t\tfloat right = r * ia;\n\t\t    left *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    right *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    audiosys->mixing_buffer[ i * 2 + 0 ] += left;\n\t\t    audiosys->mixing_buffer[ i * 2 + 1 ] += right;\n\t\t}\n\t} else if( voice->pan > 0.0f && fade_delta == 0.0f ) {\n\t\tfloat a = voice->pan;\n\t\tfloat ia = 1.0f - a;\n\t\tfor( int i = 0; i < sample_pairs_count; ++i ) {\n\t\t    float l = sample_pairs[ i * 2 + 0 ];\n\t\t    float r = sample_pairs[ i * 2 + 1 ];\n\t\t\tfloat right = l * a + r;\n\t\t\tfloat left = l * ia;\n\t\t    left *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    right *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    audiosys->mixing_buffer[ i * 2 + 0 ] += left;\n\t\t    audiosys->mixing_buffer[ i * 2 + 1 ] += right;\n\t\t}\n\t} else if( voice->pan == 0.0f && fade_delta != 0.0f ) {\n\t\tfor( int i = 0; i < sample_pairs_count; ++i ) {\n\t\t    float left = sample_pairs[ i * 2 + 0 ];\n\t\t    float right = sample_pairs[ i * 2 + 1 ];\n\t\t    left *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    right *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    audiosys->mixing_buffer[ i * 2 + 0 ] += left;\n\t\t    audiosys->mixing_buffer[ i * 2 + 1 ] += right;\n\t\t\tfade_volume += fade_delta;\n\t\t\tfade_volume = fade_volume < 0.0f ? 0.0f : fade_volume > 1.0f ? 1.0f : fade_volume;\t\t\t\n\t\t}\n\t} else if( voice->pan == 0.0f && fade_delta == 0.0f ) {\n\t\tfor( int i = 0; i < sample_pairs_count; ++i ) {\n\t\t    float left = sample_pairs[ i * 2 + 0 ];\n\t\t    float right = sample_pairs[ i * 2 + 1 ];\n\t\t    left *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    right *= voice->volume * fade_volume * audiosys->master_volume;\n\t\t    audiosys->mixing_buffer[ i * 2 + 0 ] += left;\n\t\t    audiosys->mixing_buffer[ i * 2 + 1 ] += right;\n\t\t}\n\t} else {\n\t\tAUDIOSYS_ASSERT( false, \"Invalid mix parameters\" );\n\t}\n}\n\n\nvoid audiosys_render( audiosys_t* audiosys, AUDIOSYS_S16* output_sample_pairs, int sample_pairs_count ) {\n\tif( audiosys->paused ) {\n\t\tAUDIOSYS_MEMSET( output_sample_pairs, 0, sample_pairs_count * sizeof( AUDIOSYS_S16 ) * 2 );\n\t\treturn;\n\t}\n\n\tif( audiosys->mixing_buffer_size < sample_pairs_count ) {\n\t\tif( audiosys->mixing_buffer ) {\n\t\t\tAUDIOSYS_FREE( audiosys->memctx, audiosys->mixing_buffer );\n\t\t}\n\t\tif( audiosys->sample_buffer ) {\n\t\t\tAUDIOSYS_FREE( audiosys->memctx, audiosys->sample_buffer );\n\t\t}\n\t\taudiosys->mixing_buffer_size = sample_pairs_count;\n\t\taudiosys->mixing_buffer = (float*) AUDIOSYS_MALLOC( audiosys->memctx, sample_pairs_count * sizeof( float ) * 2 );\n\t\taudiosys->sample_buffer = (float*) AUDIOSYS_MALLOC( audiosys->memctx, sample_pairs_count * sizeof( float ) * 2 );\n\t}\n\n\t// remove sounds which have finished playing\n\tfor( int i = audiosys->sounds_count - 1; i >= 0; --i ) {\n\t\taudiosys_internal_voice_t* voice = &audiosys->sounds[ i ];\n\t\tif( voice->source.read_samples == NULL ) audiosys_internal_remove_sound( audiosys, voice->handle );\n\t}\n\n\t// clear buffer for mixing\n\tfor( int i = 0; i < sample_pairs_count * 2; ++i ) {\n\t\taudiosys->mixing_buffer[ i ] = 0.0f;\n\t}\n\t\n\t// mix all active voices\n\taudiosys_internal_mix_voice( audiosys, &audiosys->music, audiosys->sample_buffer, sample_pairs_count );\n\taudiosys_internal_mix_voice( audiosys, &audiosys->music_crossfade, audiosys->sample_buffer, sample_pairs_count );\n\taudiosys_internal_mix_voice( audiosys, &audiosys->ambience, audiosys->sample_buffer, sample_pairs_count );\n\taudiosys_internal_mix_voice( audiosys, &audiosys->ambience_crossfade, audiosys->sample_buffer, sample_pairs_count );\n\n\tint sounds_count = audiosys->active_voice_count;\n\tfor( int i = 0; i < sounds_count; ++i ) {\n\t   audiosys_internal_mix_voice( audiosys, audiosys_internal_get_sound( audiosys, audiosys->sounds_by_priority[ i ] ), audiosys->sample_buffer, sample_pairs_count );\n\t}\n\n\tif( audiosys->use_soft_clip ) {\n\t\tfor( int i = 0; i < sample_pairs_count * 2; ++i ) {\n\t\t\tfloat s = audiosys->mixing_buffer[ i ];\n\t\t\ts *= audiosys->gain * 0.5f;\n\t\t\ts = s < -1.0f ? -2.0f / 3.0f : s > 1.0f ? 2.0f / 3.0f : s - ( s * s * s ) / 3; // soft clip \n\t\t\ts *= 32000.0f;\n\t\t\toutput_sample_pairs[ i ] = (AUDIOSYS_S16)( s );\n\t\t}\n\t} else {\n\t\tfor( int i = 0; i < sample_pairs_count * 2; ++i ) {\n\t\t\tfloat s = audiosys->mixing_buffer[ i ];\n\t\t\ts *= audiosys->gain * 0.5f;\n\t\t\ts = s < -1.0f ? -1.0f : s > 1.0f ? 1.0f : s;\n\t\t\ts *= 32000.0f;\n\t\t\toutput_sample_pairs[ i ] = (AUDIOSYS_S16)( s );\n\t\t}\n\t}\n}\n\n\nvoid audiosys_master_volume_set( audiosys_t* audiosys, float volume ) {\n\taudiosys->master_volume = volume < 0.0f ? 0.0f : volume > 1.0f ? 1.0f : volume;\n}\n\n\nfloat audiosys_master_volume( audiosys_t* audiosys ) {\n\treturn audiosys->master_volume;\n}\n\n\nvoid audiosys_gain_set( audiosys_t* audiosys, float gain ) {\n\taudiosys->gain = gain;\n}\n\n\nfloat audiosys_gain( audiosys_t* audiosys ) {\n\treturn audiosys->gain;\n}\n\n\nvoid audiosys_pause( audiosys_t* audiosys ) {\n\taudiosys->paused = 1;\n}\n\n\nvoid audiosys_resume( audiosys_t* audiosys ) {\n\taudiosys->paused = 0;\n}\n\n\nvoid audiosys_stop_all( audiosys_t* audiosys ) {\n\taudiosys_music_stop( audiosys, 0.0f );\n\taudiosys_ambience_stop( audiosys, 0.0f );\n\n\tfor( int i = 0; i < audiosys->sounds_count; ++i ) {\n\t\taudiosys_internal_voice_t* sound = &audiosys->sounds[ i ];\n\t\tsound->state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t\taudiosys_internal_remove_sound( audiosys, sound->handle );\n\t\taudiosys_internal_release_source( &sound->source );\n\t}\n}\n\n\naudiosys_paused_t audiosys_paused( audiosys_t* audiosys ) {\n\treturn audiosys->paused ? AUDIOSYS_PAUSED : AUDIOSYS_NOT_PAUSED;\n}\n\n\nstatic void audiosys_internal_init_voice( audiosys_internal_voice_t* voice, audiosys_audio_source_t source, int is_sound ) {\n\tvoice->handle = 0;\n\tvoice->initialized = 0;\n\tvoice->paused = 0;\n\tvoice->state = AUDIOSYS_INTERNAL_VOICE_STATE_PLAYING;\n\tvoice->source = source;\n\tif( is_sound ) {\n\t    voice->loop = 0;\n\t    voice->volume = 1.0f;\n\t    voice->pan = 0.0f;\n\t}\n\tvoice->fade_in_time = 0.0f;\n\tvoice->fade_out_time = 0.0f;\n\tvoice->priority = 0.0f;\n\tvoice->fade_progress = 1.0f;\n\tvoice->current_fade_volume = 1.0f;\n\tvoice->current_fade_delta = 0.0f;\n}\n\n\nvoid audiosys_music_play( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_in_time ) {\n\taudiosys_internal_release_source( &audiosys->music.source );\n\taudiosys_internal_init_voice( &audiosys->music, source, 0 );\n\taudiosys->music.fade_in_time = fade_in_time;\n\tif( fade_in_time > 0.0f ) {\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN;\n\t\taudiosys->music.fade_progress = 0.0f;\n\t}\n}\n\n\nvoid audiosys_music_stop( audiosys_t* audiosys, float fade_out_time ) {\n\tif( fade_out_time > 0.0f ) {\n\t\taudiosys->music.fade_out_time = fade_out_time;\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t\taudiosys->music.fade_progress = 1.0f;\n\t} else {\n\t\taudiosys_internal_release_source( &audiosys->music.source );\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t}\n}\n\n\nvoid audiosys_music_pause( audiosys_t* audiosys ) {\n\tif( audiosys->music.paused == 1 ) {\n\t\treturn;\n\t}\n\taudiosys->music.paused = 1;\n}\n\n\nvoid audiosys_music_resume( audiosys_t* audiosys ) {\n\tif( audiosys->music.paused == 0 ) { \n\t\treturn;\n\t}\n\taudiosys->music.paused = 0;\n}\n\n\nvoid audiosys_music_switch( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_out_time, float fade_in_time ) {\n\tif( fade_out_time > 0.0f ) {\n\t\taudiosys->music.fade_out_time = fade_out_time;\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t\taudiosys->music.fade_progress = 1.0f;\n\t} else {\n\t\taudiosys_internal_release_source( &audiosys->music.source );\n\t\taudiosys_music_play( audiosys, source, fade_in_time );\n\t\treturn;\n\t}\n\taudiosys_internal_voice_t temp = audiosys->music;\n\taudiosys->music = audiosys->music_crossfade;\n\taudiosys->music_crossfade = temp;\n\n\taudiosys_internal_init_voice( &audiosys->music, source, 0 );\n\taudiosys->music.fade_in_time = fade_in_time;\n\tif( fade_in_time > 0.0f ) {\n\t\taudiosys->music.fade_progress = 0.0f;\n\t}\n\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_QUEUED;\n}\n\n\nvoid audiosys_music_cross_fade( audiosys_t* audiosys, audiosys_audio_source_t source, float cross_fade_time ) {\n\tif( cross_fade_time > 0.0f ) {\n\t\taudiosys->music.fade_out_time = cross_fade_time;\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t\taudiosys->music.fade_progress = 1.0f;\n\t} else {\n\t\taudiosys_internal_release_source( &audiosys->music.source );\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t}\n\taudiosys_internal_voice_t temp = audiosys->music;\n\taudiosys->music = audiosys->music_crossfade;\n\taudiosys->music_crossfade = temp;\n\n\taudiosys_internal_init_voice( &audiosys->music, source, 0 );\n\taudiosys->music.fade_in_time = cross_fade_time;\n\tif( cross_fade_time > 0.0f ) {\n\t\taudiosys->music.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN;\n\t\taudiosys->music.fade_progress = 0.0f;\n\t}\n}\n\n\nvoid audiosys_music_position_set( audiosys_t* audiosys, float position ) {\n\tif( !audiosys->music.source.set_position ) {\n\t\treturn;\n\t}\n\n\taudiosys->music.source.set_position( audiosys->music.source.instance, (int)( position * 44100.0f ) );\n}\n\n\nfloat audiosys_music_position( audiosys_t* audiosys ) {\n\tif( !audiosys->music.source.get_position ) {\n\t\treturn 0.0f;\n\t}\n\n\treturn audiosys->music.source.get_position( audiosys->music.source.instance ) / 44100.0f;\n}\n\n\naudiosys_audio_source_t audiosys_music_source( audiosys_t* audiosys ) {\n\treturn audiosys->music.source;\n}\n\n\nvoid audiosys_music_loop_set( audiosys_t* audiosys, audiosys_loop_t loop ) {\n\taudiosys->music.loop = loop == AUDIOSYS_LOOP_ON ? 1 : 0;\t\n}\n\n\naudiosys_loop_t audiosys_music_loop( audiosys_t* audiosys ) {\n\treturn audiosys->music.loop ? AUDIOSYS_LOOP_ON : AUDIOSYS_LOOP_OFF;\n}\n\n\nvoid audiosys_music_volume_set( audiosys_t* audiosys, float volume ) {\n\taudiosys->music.volume = volume;\n}\n\n\nfloat audiosys_music_volume( audiosys_t* audiosys ) {\n\treturn audiosys->music.volume;\n}\n\n\nvoid audiosys_music_pan_set( audiosys_t* audiosys, float pan ) {\n\taudiosys->music.pan = pan < -1.0f ? -1.0f : pan > 1.0f ? 1.0f : pan;\n}\n\n\nfloat audiosys_music_pan( audiosys_t* audiosys ) {\n\treturn audiosys->music.pan;\n}\n\n\nvoid audiosys_ambience_play( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_in_time ) {\n\taudiosys_internal_release_source( &audiosys->ambience.source );\n\taudiosys_internal_init_voice( &audiosys->ambience, source, 0 );\n\taudiosys->ambience.fade_in_time = fade_in_time;\n\tif( fade_in_time > 0.0f ) {\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN;\n\t\taudiosys->ambience.fade_progress = 0.0f;\n\t}\n}\n\n\nvoid audiosys_ambience_stop( audiosys_t* audiosys, float fade_out_time ) {\n\tif( fade_out_time > 0.0f ) {\n\t\taudiosys->ambience.fade_out_time = fade_out_time;\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t\taudiosys->ambience.fade_progress = 1.0f;\n\t} else {\n\t\taudiosys_internal_release_source( &audiosys->ambience.source );\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t}\n}\n\n\nvoid audiosys_ambience_pause( audiosys_t* audiosys ) {\n\tif( audiosys->ambience.paused == 1 ) {\n\t\treturn;\n\t}\n\taudiosys->ambience.paused = 1;\n}\n\n\nvoid audiosys_ambience_resume( audiosys_t* audiosys ) {\n\tif( audiosys->ambience.paused == 0 ) {\n\t\treturn;\n\t}\n\taudiosys->ambience.paused = 0;\n}\n\n\nvoid audiosys_ambience_switch( audiosys_t* audiosys, audiosys_audio_source_t source, float fade_out_time, float fade_in_time ) {\n\tif( fade_out_time > 0.0f ) {\n\t\taudiosys->ambience.fade_out_time = fade_out_time;\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t} else {\n\t\taudiosys_internal_release_source( &audiosys->ambience.source );\n\t\taudiosys_ambience_play( audiosys, source, fade_in_time );\n\t\treturn;\n\t}\n\taudiosys_internal_voice_t temp = audiosys->ambience;\n\taudiosys->ambience = audiosys->ambience_crossfade;\n\taudiosys->ambience_crossfade = temp;\n\n\taudiosys_internal_init_voice( &audiosys->ambience, source, 0 );\n\taudiosys->ambience.fade_in_time = fade_in_time;\n\tif( fade_in_time > 0.0f ) {\n\t\taudiosys->ambience.fade_progress = 0.0f;\n\t}\n\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_QUEUED;\n}\n\n\nvoid audiosys_ambience_cross_fade( audiosys_t* audiosys, audiosys_audio_source_t source, float cross_fade_time ) {\n\tif( cross_fade_time > 0.0f ) {\n\t\taudiosys->ambience.fade_out_time = cross_fade_time;\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t\taudiosys->ambience.fade_progress = 1.0f;\n\t} else {\n\t\taudiosys_internal_release_source( &audiosys->ambience.source );\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t}\n\taudiosys_internal_voice_t temp = audiosys->ambience;\n\taudiosys->ambience = audiosys->ambience_crossfade;\n\taudiosys->ambience_crossfade = temp;\n\n\taudiosys_internal_init_voice( &audiosys->ambience, source, 0 );\n\taudiosys->ambience.fade_in_time = cross_fade_time;\n\tif( cross_fade_time > 0.0f ) {\n\t\taudiosys->ambience.state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN;\n\t\taudiosys->ambience.fade_progress = 0.0f;\n\t}\n}\n\n\nvoid audiosys_ambience_position_set( audiosys_t* audiosys, float position ) {\n\tif( !audiosys->ambience.source.set_position ) {\n\t\treturn;\n\t}\n\n\taudiosys->ambience.source.set_position( audiosys->ambience.source.instance, (int)( position * 44100.0f ) );\n}\n\n\nfloat audiosys_ambience_position( audiosys_t* audiosys ) {\n\tif( !audiosys->ambience.source.get_position ) {\n\t\treturn 0.0f;\n\t}\n\n\treturn audiosys->ambience.source.get_position( audiosys->ambience.source.instance ) / 44100.0f;\n}\n\naudiosys_audio_source_t audiosys_ambience_source( audiosys_t* audiosys ) {\n\treturn audiosys->ambience.source;\n}\n\n\nvoid audiosys_ambience_loop_set( audiosys_t* audiosys, audiosys_loop_t loop ) {\n\taudiosys->ambience.loop = loop == AUDIOSYS_LOOP_ON ? 1 : 0;\t\n}\n\n\naudiosys_loop_t audiosys_ambience_loop( audiosys_t* audiosys ) {\n\treturn audiosys->ambience.loop ? AUDIOSYS_LOOP_ON : AUDIOSYS_LOOP_OFF;\n}\n\n\nvoid audiosys_ambience_volume_set( audiosys_t* audiosys, float volume ) {\n\taudiosys->ambience.volume = volume;\n}\n\n\nfloat audiosys_ambience_volume( audiosys_t* audiosys ) {\n\treturn audiosys->ambience.volume;\n}\n\n\nvoid audiosys_ambience_pan_set( audiosys_t* audiosys, float pan ) {\n\taudiosys->ambience.pan = pan < -1.0f ? -1.0f : pan > 1.0f ? 1.0f : pan;\n}\n\n\nfloat audiosys_ambience_pan( audiosys_t* audiosys )\n\t{\n\treturn audiosys->ambience.pan;\n\t}\n\n\nAUDIOSYS_U64 audiosys_sound_play( audiosys_t* audiosys, audiosys_audio_source_t source, float priority, float fade_in_time ) {\n\taudiosys_internal_voice_t* sound;\n\tAUDIOSYS_U64 handle = audiosys_internal_add_sound( audiosys, &sound, priority );\n\taudiosys_internal_init_voice( sound, source, 1 );\n\tsound->handle = handle;\n\tsound->priority = priority;\n\tsound->fade_in_time = fade_in_time;\n\tif( fade_in_time > 0.0f )  {\n\t\tsound->state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_IN;\n\t\tsound->fade_progress = 0.0f;\n\t}\n\treturn handle;\n}\n\n\nvoid audiosys_sound_stop( audiosys_t* audiosys, AUDIOSYS_U64 handle, float fade_out_time ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\n\tif( fade_out_time > 0.0f ) {\n\t\tsound->fade_out_time = fade_out_time;\n\t\tsound->state = AUDIOSYS_INTERNAL_VOICE_STATE_FADING_OUT;\n\t\tsound->fade_progress = 1.0f;\n\t} else {\n\t\tsound->state = AUDIOSYS_INTERNAL_VOICE_STATE_STOPPED;\n\t\taudiosys_internal_remove_sound( audiosys, handle );\n\t\taudiosys_internal_release_source( &sound->source );\n\t}\n}\n\n\nvoid audiosys_sound_pause( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\tif( sound->paused == 1 ) {\n\t\treturn;\n\t}\n\tsound->paused = 1;\n}\n\n\nvoid audiosys_sound_resume( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\tif( sound->paused == 0 ) {\n\t\treturn;\n\t}\n\tsound->paused = 0;\n}\n\n\nvoid audiosys_sound_position_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, float position ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\tif( !sound->source.set_position ) {\n\t\treturn;\n\t}\n\n\tsound->source.set_position( sound->source.instance, (int)( position * 44100.0f ) );\n}\n\n\nfloat audiosys_sound_position( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn 0.0f;\n\t}\n\tif( !sound->source.get_position ) {\n\t\treturn 0.0f;\n\t}\n\n\treturn sound->source.get_position( sound->source.instance ) / 44100.0f;\n}\n\n\naudiosys_audio_source_t audiosys_sound_source( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\taudiosys_audio_source_t null_source;\n\t\tAUDIOSYS_MEMSET( &null_source, 0, sizeof( null_source ) );\n\t\treturn null_source;\n\t}\n\treturn sound->source;\n}\n\n\nvoid audiosys_sound_loop_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, audiosys_loop_t loop ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\tsound->loop = loop == AUDIOSYS_LOOP_ON ? 1 : 0;\t\n}\n\n\naudiosys_loop_t audiosys_sound_loop( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn AUDIOSYS_LOOP_OFF;\n\t}\n\treturn sound->loop ? AUDIOSYS_LOOP_ON : AUDIOSYS_LOOP_OFF;\n}\n\n\nvoid audiosys_sound_volume_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, float volume ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\tsound->volume = volume;\n}\n\n\nfloat audiosys_sound_volume( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn 0.0f;\n\t}\n\treturn sound->volume;\n}\n\n\nvoid audiosys_sound_pan_set( audiosys_t* audiosys, AUDIOSYS_U64 handle, float pan ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn;\n\t}\n\tsound->pan = pan < -1.0f ? -1.0f : pan > 1.0f ? 1.0f : pan;\n}\n\n\nfloat audiosys_sound_pan( audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn 0.0f;\n\t}\n\treturn sound->pan;\n}\n\n\naudiosys_sound_valid_t audiosys_sound_valid(audiosys_t* audiosys, AUDIOSYS_U64 handle ) {\n\taudiosys_internal_voice_t* sound = audiosys_internal_get_sound( audiosys, handle );\n\tif( !sound ) {\n\t\treturn AUDIOSYS_SOUND_INVALID;\n\t}\n\treturn AUDIOSYS_SOUND_VALID;\n}\n\n#endif /* AUDIOSYS_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2017 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "buffer.h",
          "type": "blob",
          "size": 16.4736328125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nbuffer.h - v0.1 - Memory buffer with read/write operations, for C/C++.\n\nDo this:\n    #define BUFFER_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef buffer_h\n#define buffer_h\n\n// If you want buffer to swap endianness on read/write, do this before include: #define BUFFER_BIG_ENDIAN\n\n#ifndef BUFFER_I8_T\n    #define BUFFER_I8_T char\n#endif\n\n#ifndef BUFFER_I16_T\n    #define BUFFER_I16_T short\n#endif\n\n#ifndef BUFFER_I32_T\n    #define BUFFER_I32_T int\n#endif\n\n#ifndef BUFFER_I64_T\n    #define BUFFER_I64_T long long\n#endif\n\n#ifndef BUFFER_U8_T\n    #define BUFFER_U8_T unsigned char\n#endif\n\n#ifndef BUFFER_U16_T\n    #define BUFFER_U16_T unsigned short\n#endif\n\n#ifndef BUFFER_U32_T\n    #define BUFFER_U32_T unsigned int\n#endif\n\n#ifndef BUFFER_U64_T\n    #define BUFFER_U64_T unsigned long long\n#endif\n\n\ntypedef struct buffer_t buffer_t;\n\nbuffer_t* buffer_create( void );\nbuffer_t* buffer_load( const char* filename );\nbuffer_t* buffer_map( void* data, size_t size );\nvoid buffer_destroy( buffer_t* buffer );\nbool buffer_save( buffer_t* buffer, char const* filename );\nvoid buffer_resize( buffer_t* buffer, size_t size );\nsize_t buffer_position( buffer_t* buffer );\nsize_t buffer_position_set( buffer_t* buffer, size_t position );\nsize_t buffer_size( buffer_t* buffer );\nvoid* buffer_data( buffer_t* buffer );\n\nint buffer_read_char( buffer_t* buffer, char* value, int count );\nint buffer_read_i8( buffer_t* buffer, BUFFER_I8_T* value, int count );\nint buffer_read_i16( buffer_t* buffer, BUFFER_I16_T* value, int count );\nint buffer_read_i32( buffer_t* buffer, BUFFER_I32_T* value, int count );\nint buffer_read_i64( buffer_t* buffer, BUFFER_I64_T* value, int count );\nint buffer_read_u8( buffer_t* buffer, BUFFER_U8_T* value, int count );\nint buffer_read_u16( buffer_t* buffer, BUFFER_U16_T* value, int count );\nint buffer_read_u32( buffer_t* buffer, BUFFER_U32_T* value, int count );\nint buffer_read_u64( buffer_t* buffer, BUFFER_U64_T* value, int count );\nint buffer_read_float( buffer_t* buffer, float* value, int count );\nint buffer_read_double( buffer_t* buffer, double* value, int count );\nint buffer_read_bool( buffer_t* buffer, bool* value, int count );\n\nint buffer_write_char( buffer_t* buffer, char const* value, int count );\nint buffer_write_i8( buffer_t* buffer, BUFFER_I8_T const* value, int count );\nint buffer_write_i16( buffer_t* buffer, BUFFER_I16_T const* value, int count );\nint buffer_write_i32( buffer_t* buffer, BUFFER_I32_T const* value, int count );\nint buffer_write_i64( buffer_t* buffer, BUFFER_I64_T const* value, int count );\nint buffer_write_u8( buffer_t* buffer, BUFFER_U8_T const* value, int count );\nint buffer_write_u16( buffer_t* buffer, BUFFER_U16_T const* value, int count );\nint buffer_write_u32( buffer_t* buffer, BUFFER_U32_T const* value, int count );\nint buffer_write_u64( buffer_t* buffer, BUFFER_U64_T const* value, int count );\nint buffer_write_float( buffer_t* buffer, float const* value, int count );\nint buffer_write_double( buffer_t* buffer, double const* value, int count );\nint buffer_write_bool( buffer_t* buffer, bool const* value, int count );\n\n#endif /* buffer_h */\n\n\n#ifdef BUFFER_IMPLEMENTATION\n#undef BUFFER_IMPLEMENTATION\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstatic BUFFER_U32_T buffer_pow2ceil( BUFFER_U32_T v ) {\n    --v;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    ++v;\n    v += ( v == 0 );\n    return v;\n}\n\n\nstruct buffer_t {\n    size_t capacity;\n    size_t size;\n    size_t position;\n    void* data;\n    int is_mapped;\n};\n\n\nbuffer_t* buffer_create( void ) {\n    buffer_t* buffer = (buffer_t*) malloc( sizeof( buffer_t) );\n    buffer->capacity = 4096;\n    buffer->size = 0;\n    buffer->position = 0;\n    buffer->data = malloc( buffer->capacity );\n    buffer->is_mapped = 0;\n    return buffer;\n}\n\n\nbuffer_t* buffer_load( const char* filename ) {\n    FILE* fp = fopen( filename, \"rb\" );\n    if( !fp ) {\n        return NULL;\n    }\n    fseek( fp, 0, SEEK_END );\n    int size = (int) ftell( fp );\n    fseek( fp, 0, SEEK_SET );\n    if( size == 0 ) {\n        fclose( fp );\n        return NULL;\n    }\n\n    int pow2size = (int)buffer_pow2ceil( (BUFFER_U32_T) size );\n    void* data = malloc( pow2size );\n    int read = (int) fread( data, 1, size, fp );\n    fclose( fp );\n    if( read != size ) {\n        free( data );\n        return NULL;\n    }\n\n    buffer_t* buffer = (buffer_t*) malloc( sizeof( buffer_t) );\n    buffer->capacity = pow2size;\n    buffer->size = size;\n    buffer->position = 0;\n    buffer->data = data;\n    buffer->is_mapped = 0;\n    return buffer;\n}\n\n\nbuffer_t* buffer_map( void* data, size_t size ) {\n    if( !data ) {\n        return NULL;\n    }\n    buffer_t* buffer = (buffer_t*) malloc( sizeof( buffer_t) );\n    buffer->capacity = size;\n    buffer->size = size;\n    buffer->position = 0;\n    buffer->data = data;\n    buffer->is_mapped = 1;\n    return buffer;\n}\n\n\nvoid buffer_destroy( buffer_t* buffer ) {\n    if( !buffer->is_mapped ) {\n        free( buffer->data );\n    }\n    free( buffer );\n}\n\n\nbool buffer_save( buffer_t* buffer, char const* filename ) {\n    FILE* fp = fopen( filename, \"wb\" );\n    if( !fp ) {\n        return false;\n    }\n    size_t written = fwrite( buffer->data, 1, buffer->size, fp );\n    fclose( fp );\n    return written == buffer->size;\n}\n\n\nvoid buffer_resize( buffer_t* buffer, size_t size ) {\n    if( buffer->is_mapped ) {\n        return;\n    }\n    if( size > buffer->capacity ) {\n        while( size > buffer->capacity ) {\n            buffer->capacity *= 2;\n        }\n        buffer->data = realloc( buffer->data, buffer->capacity );\n    }\n    buffer->size = size;\n    if( buffer->position > size ) {\n        buffer->position = size;\n    }\n}\n\n\nsize_t buffer_position( buffer_t* buffer ) {\n    size_t result = buffer->position;\n    return result;\n}\n\n\nsize_t buffer_position_set( buffer_t* buffer, size_t position ) {\n    buffer->position = position > buffer->size ? buffer->size : position;\n    size_t result = buffer->position;\n    return result;\n}\n\n\nsize_t buffer_size( buffer_t* buffer ) {\n    size_t result = buffer->size;\n    return result;\n}\n\n\nvoid* buffer_data( buffer_t* buffer ) {\n    return buffer->data;\n}\n\n#ifndef BUFFER_BIG_ENDIAN\n    #define BUFFER_READ_IMPL \\\n        { \\\n            int result = 0; \\\n            for( int i = 0; i < count; ++i ) { \\\n                if( buffer->position + sizeof( *value ) > buffer->size ) { \\\n                    return result; \\\n                } \\\n                memcpy( &value[ i ], (void*)( ( (uintptr_t) buffer->data ) + buffer->position ), sizeof( *value ) ); \\\n                buffer->position += sizeof( *value ); \\\n                ++result; \\\n            } \\\n            return result; \\\n        }\n#else\n    #define BUFFER_READ_IMPL \\\n        { \\\n            int result = 0; \\\n            for( int i = 0; i < count; ++i ) { \\\n                if( buffer->position + sizeof( *value ) > buffer->size ) { \\\n                    return result; \\\n                } \\\n                void* x = &value[ i ]; \\\n                memcpy( x, (void*)( ( (uintptr_t) buffer->data ) + buffer->position ), sizeof( *value ) ); \\\n                if( sizeof(*value) == 2 ) \\\n                    *(BUFFER_U16_T*)(x) = \\\n                    ((((*(BUFFER_U16_T*)(x)) & 0xFF00) >> 8) | \\\n                     (((*(BUFFER_U16_T*)(x)) & 0x00FF) << 8)); \\\n                else if( sizeof(*value) == 4 ) \\\n                    *(BUFFER_U32_T*)(x) = \\\n                    ((((*(BUFFER_U32_T*)(x)) & 0xFF000000) >> 24) | \\\n                     (((*(BUFFER_U32_T*)(x)) & 0x00FF0000) >> 8) | \\\n                     (((*(BUFFER_U32_T*)(x)) & 0x0000FF00) << 8) | \\\n                     (((*(BUFFER_U32_T*)(x)) & 0x000000FF) << 24) ); \\\n                else if( sizeof(*value) == 8 ) \\\n                    *(BUFFER_U64_T*)(x) = \\\n                    ((((*(BUFFER_U64_T*)(x)) & 0xFF00000000000000) >> 56 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x00FF000000000000) >> 40 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x0000FF0000000000) >> 24 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x000000FF00000000) >> 8 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x00000000FF000000) << 8) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x0000000000FF0000) << 24) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x000000000000FF00) << 40) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x00000000000000FF) << 56)); \\\n                buffer->position += sizeof( *value ); \\\n                ++result; \\\n            } \\\n            return result; \\\n        }\n#endif\n\nint buffer_read_char( buffer_t* buffer, char* value, int count ) BUFFER_READ_IMPL\nint buffer_read_i8( buffer_t* buffer, BUFFER_I8_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_i16( buffer_t* buffer, BUFFER_I16_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_i32( buffer_t* buffer, BUFFER_I32_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_i64( buffer_t* buffer, BUFFER_I64_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_u8( buffer_t* buffer, BUFFER_U8_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_u16( buffer_t* buffer, BUFFER_U16_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_u32( buffer_t* buffer, BUFFER_U32_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_u64( buffer_t* buffer, BUFFER_U64_T* value, int count ) BUFFER_READ_IMPL\nint buffer_read_float( buffer_t* buffer, float* value, int count ) BUFFER_READ_IMPL\nint buffer_read_double( buffer_t* buffer, double* value, int count ) BUFFER_READ_IMPL\nint buffer_read_bool( buffer_t* buffer, bool* value, int count ) BUFFER_READ_IMPL\n\n#undef BUFFER_READ_IMPL\n\n\n#ifndef BUFFER_BIG_ENDIAN\n    #define BUFFER_WRITE_IMPL \\\n        { \\\n            int result = 0; \\\n            for( int i = 0; i < count; ++i ) { \\\n                if( buffer->position + sizeof( *value ) > buffer->size ) { \\\n                    if( buffer->is_mapped ) break; \\\n                    buffer->size = buffer->position + sizeof( *value ); \\\n                    while( buffer->size > buffer->capacity ) { \\\n                        buffer->capacity *= 2; \\\n                    } \\\n                    buffer->data = realloc( buffer->data, buffer->capacity ); \\\n                } \\\n                memcpy( (void*)( ( (uintptr_t) buffer->data ) + buffer->position ), &value[ i ], sizeof( *value ) ); \\\n                buffer->position += sizeof( *value ); \\\n                ++result; \\\n            } \\\n            return result; \\\n        }\n#else\n    #define BUFFER_WRITE_IMPL \\\n        { \\\n            int result = 0; \\\n            for( int i = 0; i < count; ++i ) { \\\n                if( buffer->position + sizeof( *value ) > buffer->size ) { \\\n                    if( buffer->is_mapped ) break; \\\n                    buffer->size = buffer->position + sizeof( *value ); \\\n                    while( buffer->size > buffer->capacity ) { \\\n                        buffer->capacity *= 2; \\\n                    } \\\n                    buffer->data = realloc( buffer->data, buffer->capacity ); \\\n                } \\\n                void* x = (void*)( ( (uintptr_t) buffer->data ) + buffer->position ); \\\n                memcpy( x, &value[ i ], sizeof( *value ) ); \\\n                if( sizeof(*value) == 2 ) \\\n                    *(BUFFER_U16_T*)(x) = \\\n                    ((((*(BUFFER_U16_T*)(x)) & 0xFF00) >> 8) | \\\n                     (((*(BUFFER_U16_T*)(x)) & 0x00FF) << 8)); \\\n                else if( sizeof(*value) == 4 ) \\\n                    *(BUFFER_U32_T*)(x) = \\\n                    ((((*(BUFFER_U32_T*)(x)) & 0xFF000000) >> 24) | \\\n                     (((*(BUFFER_U32_T*)(x)) & 0x00FF0000) >> 8) | \\\n                     (((*(BUFFER_U32_T*)(x)) & 0x0000FF00) << 8) | \\\n                     (((*(BUFFER_U32_T*)(x)) & 0x000000FF) << 24) ); \\\n                else if( sizeof(*value) == 8 ) \\\n                    *(BUFFER_U64_T*)(x) = \\\n                    ((((*(BUFFER_U64_T*)(x)) & 0xFF00000000000000) >> 56 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x00FF000000000000) >> 40 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x0000FF0000000000) >> 24 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x000000FF00000000) >> 8 ) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x00000000FF000000) << 8) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x0000000000FF0000) << 24) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x000000000000FF00) << 40) | \\\n                     (((*(BUFFER_U64_T*)(x)) & 0x00000000000000FF) << 56)); \\\n                buffer->position += sizeof( *value ); \\\n                ++result; \\\n            } \\\n            return result; \\\n        }\n#endif\n\nint buffer_write_char( buffer_t* buffer, char const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_i8( buffer_t* buffer, BUFFER_I8_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_i16( buffer_t* buffer, BUFFER_I16_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_i32( buffer_t* buffer, BUFFER_I32_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_i64( buffer_t* buffer, BUFFER_I64_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_u8( buffer_t* buffer, BUFFER_U8_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_u16( buffer_t* buffer, BUFFER_U16_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_u32( buffer_t* buffer, BUFFER_U32_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_u64( buffer_t* buffer, BUFFER_U64_T const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_float( buffer_t* buffer, float const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_double( buffer_t* buffer, double const* value, int count ) BUFFER_WRITE_IMPL\nint buffer_write_bool( buffer_t* buffer, bool const* value, int count ) BUFFER_WRITE_IMPL\n\n#undef BUFFER_WRITE_IMPL\n\n#endif /* BUFFER_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2022 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "crtemu.h",
          "type": "blob",
          "size": 92.7216796875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\ncrtemu.h - v0.1 - Cathode ray tube emulation shader for C/C++.\n\nDo this:\n    #define CRTEMU_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n\n#ifndef crtemu_h\n#define crtemu_h\n\n#ifndef CRTEMU_U32\n    #define CRTEMU_U32 unsigned int\n#endif\n#ifndef CRTEMU_U64\n    #define CRTEMU_U64 unsigned long long\n#endif\n\ntypedef enum crtemu_type_t {\n    CRTEMU_TYPE_TV,\n    CRTEMU_TYPE_PC,\n    CRTEMU_TYPE_LITE,\n} crtemu_type_t;\n\ntypedef struct crtemu_t crtemu_t;\n\ncrtemu_t* crtemu_create( crtemu_type_t type, void* memctx );\n\nvoid crtemu_destroy( crtemu_t* crtemu );\n\nvoid crtemu_frame( crtemu_t* crtemu, CRTEMU_U32* frame_abgr, int frame_width, int frame_height );\n\nvoid crtemu_present( crtemu_t* crtemu, CRTEMU_U64 time_us, CRTEMU_U32 const* pixels_xbgr, int width, int height,\n    CRTEMU_U32 mod_xbgr, CRTEMU_U32 border_xbgr );\n\nvoid crtemu_coordinates_window_to_bitmap( crtemu_t* crtemu, int width, int height, int* x, int* y );\n\n#endif /* crtemu_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n#ifdef CRTEMU_IMPLEMENTATION\n#undef CRTEMU_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE\n#define _CRT_SECURE_NO_WARNINGS\n#include <stddef.h>\n#include <string.h>\n\n#ifndef CRTEMU_MALLOC\n    #include <stdlib.h>\n    #if defined(__cplusplus)\n        #define CRTEMU_MALLOC( ctx, size ) ( ::malloc( size ) )\n        #define CRTEMU_FREE( ctx, ptr ) ( ::free( ptr ) )\n    #else\n        #define CRTEMU_MALLOC( ctx, size ) ( malloc( size ) )\n        #define CRTEMU_FREE( ctx, ptr ) ( free( ptr ) )\n    #endif\n#endif\n\n#ifdef CRTEMU_REPORT_SHADER_ERRORS\n    #ifndef CRTEMU_REPORT_ERROR\n        #define _CRT_NONSTDC_NO_DEPRECATE\n        #define _CRT_SECURE_NO_WARNINGS\n        #include <stdio.h>\n        #define CRTEMU_REPORT_ERROR( str ) printf( \"%s\", str )\n    #endif\n#endif\n\n#ifndef _WIN32\n    #define CRTEMU_SDL\n#endif\n\n#ifdef __wasm__\n    #define CRTEMU_WEBGL\n#endif\n\n#ifndef CRTEMU_SDL\n\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n\n        __declspec(dllimport) struct HINSTANCE__* __stdcall LoadLibraryA( char const* lpLibFileName );\n        __declspec(dllimport) int __stdcall FreeLibrary( struct HINSTANCE__* hModule );\n        #if defined(_WIN64)\n            typedef __int64 (__stdcall* CRTEMU_PROC)( void );\n            __declspec(dllimport) CRTEMU_PROC __stdcall GetProcAddress( struct HINSTANCE__* hModule, char const* lpLibFileName );\n        #else\n            typedef __int32 (__stdcall* CRTEMU_PROC)( void );\n            __declspec(dllimport) CRTEMU_PROC __stdcall GetProcAddress( struct HINSTANCE__* hModule, char const* lpLibFileName );\n        #endif\n\n    #ifdef __cplusplus\n        }\n    #endif\n\n    #define CRTEMU_GLCALLTYPE __stdcall\n    typedef unsigned int CRTEMU_GLuint;\n    typedef int CRTEMU_GLsizei;\n    typedef unsigned int CRTEMU_GLenum;\n    typedef int CRTEMU_GLint;\n    typedef float CRTEMU_GLfloat;\n    typedef char CRTEMU_GLchar;\n    typedef unsigned char CRTEMU_GLboolean;\n    typedef size_t CRTEMU_GLsizeiptr;\n    typedef unsigned int CRTEMU_GLbitfield;\n\n    #define CRTEMU_GL_FLOAT 0x1406\n    #define CRTEMU_GL_FALSE 0\n    #define CRTEMU_GL_FRAGMENT_SHADER 0x8b30\n    #define CRTEMU_GL_VERTEX_SHADER 0x8b31\n    #define CRTEMU_GL_COMPILE_STATUS 0x8b81\n    #define CRTEMU_GL_LINK_STATUS 0x8b82\n    #define CRTEMU_GL_INFO_LOG_LENGTH 0x8b84\n    #define CRTEMU_GL_ARRAY_BUFFER 0x8892\n    #define CRTEMU_GL_TEXTURE_2D 0x0de1\n    #define CRTEMU_GL_TEXTURE0 0x84c0\n    #define CRTEMU_GL_TEXTURE1 0x84c1\n    #define CRTEMU_GL_TEXTURE2 0x84c2\n    #define CRTEMU_GL_TEXTURE3 0x84c3\n    #define CRTEMU_GL_TEXTURE_MIN_FILTER 0x2801\n    #define CRTEMU_GL_TEXTURE_MAG_FILTER 0x2800\n    #define CRTEMU_GL_NEAREST 0x2600\n    #define CRTEMU_GL_LINEAR 0x2601\n    #define CRTEMU_GL_STATIC_DRAW 0x88e4\n    #define CRTEMU_GL_RGBA 0x1908\n    #define CRTEMU_GL_UNSIGNED_BYTE 0x1401\n    #define CRTEMU_GL_COLOR_BUFFER_BIT 0x00004000\n    #define CRTEMU_GL_TRIANGLE_FAN 0x0006\n    #define CRTEMU_GL_FRAMEBUFFER 0x8d40\n    #define CRTEMU_GL_VIEWPORT 0x0ba2\n    #define CRTEMU_GL_RGB 0x1907\n    #define CRTEMU_GL_COLOR_ATTACHMENT0 0x8ce0\n    #define CRTEMU_GL_TEXTURE_WRAP_S 0x2802\n    #define CRTEMU_GL_TEXTURE_WRAP_T 0x2803\n    #define CRTEMU_GL_CLAMP_TO_BORDER 0x812D\n    #define CRTEMU_GL_TEXTURE_BORDER_COLOR 0x1004\n\n#else\n\n    #ifndef CRTEMU_WEBGL\n        #include <GL/glew.h>\n        #include \"SDL_opengl.h\"\n    #else\n        #include <wajic_gl.h>\n    #endif\n    #define CRTEMU_GLCALLTYPE GLAPIENTRY\n\n    typedef GLuint CRTEMU_GLuint;\n    typedef GLsizei CRTEMU_GLsizei;\n    typedef GLenum CRTEMU_GLenum;\n    typedef GLint CRTEMU_GLint;\n    typedef GLfloat CRTEMU_GLfloat;\n    typedef GLchar CRTEMU_GLchar;\n    typedef GLboolean CRTEMU_GLboolean;\n    typedef GLsizeiptr CRTEMU_GLsizeiptr;\n    typedef GLbitfield CRTEMU_GLbitfield;\n\n     #define CRTEMU_GL_FLOAT GL_FLOAT\n     #define CRTEMU_GL_FALSE GL_FALSE\n     #define CRTEMU_GL_FRAGMENT_SHADER GL_FRAGMENT_SHADER\n     #define CRTEMU_GL_VERTEX_SHADER GL_VERTEX_SHADER\n     #define CRTEMU_GL_COMPILE_STATUS GL_COMPILE_STATUS\n     #define CRTEMU_GL_LINK_STATUS GL_LINK_STATUS\n     #define CRTEMU_GL_INFO_LOG_LENGTH GL_INFO_LOG_LENGTH\n     #define CRTEMU_GL_ARRAY_BUFFER GL_ARRAY_BUFFER\n     #define CRTEMU_GL_TEXTURE_2D GL_TEXTURE_2D\n     #define CRTEMU_GL_TEXTURE0 GL_TEXTURE0\n     #define CRTEMU_GL_TEXTURE1 GL_TEXTURE1\n     #define CRTEMU_GL_TEXTURE2 GL_TEXTURE2\n     #define CRTEMU_GL_TEXTURE3 GL_TEXTURE3\n     #define CRTEMU_GL_TEXTURE_MIN_FILTER GL_TEXTURE_MIN_FILTER\n     #define CRTEMU_GL_TEXTURE_MAG_FILTER GL_TEXTURE_MAG_FILTER\n     #define CRTEMU_GL_NEAREST GL_NEAREST\n     #define CRTEMU_GL_LINEAR GL_LINEAR\n     #define CRTEMU_GL_STATIC_DRAW GL_STATIC_DRAW\n     #define CRTEMU_GL_RGBA GL_RGBA\n     #define CRTEMU_GL_UNSIGNED_BYTE GL_UNSIGNED_BYTE\n     #define CRTEMU_GL_COLOR_BUFFER_BIT GL_COLOR_BUFFER_BIT\n     #define CRTEMU_GL_TRIANGLE_FAN GL_TRIANGLE_FAN\n     #define CRTEMU_GL_FRAMEBUFFER GL_FRAMEBUFFER\n     #define CRTEMU_GL_VIEWPORT GL_VIEWPORT\n     #define CRTEMU_GL_RGB GL_RGB\n     #define CRTEMU_GL_COLOR_ATTACHMENT0 GL_COLOR_ATTACHMENT0\n     #define CRTEMU_GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_S\n     #define CRTEMU_GL_TEXTURE_WRAP_T GL_TEXTURE_WRAP_T\n     #ifndef CRTEMU_WEBGL\n         #define CRTEMU_GL_CLAMP_TO_BORDER GL_CLAMP_TO_BORDER\n         #define CRTEMU_GL_TEXTURE_BORDER_COLOR GL_TEXTURE_BORDER_COLOR\n     #else\n         // WebGL does not support GL_CLAMP_TO_BORDER, we have to emulate\n         // this behavior with code in the fragment shader\n         #define CRTEMU_GL_CLAMP_TO_BORDER GL_CLAMP_TO_EDGE\n     #endif\n#endif\n\n\nstruct crtemu_t {\n    crtemu_type_t type;\n    void* memctx;\n\n    CRTEMU_GLuint vertexbuffer;\n    CRTEMU_GLuint backbuffer;\n    CRTEMU_GLuint fbo_backbuffer;\n\n    CRTEMU_GLuint accumulatetexture_a;\n    CRTEMU_GLuint accumulatetexture_b;\n    CRTEMU_GLuint accumulatebuffer_a;\n    CRTEMU_GLuint accumulatebuffer_b;\n\n    CRTEMU_GLuint blurtexture_a;\n    CRTEMU_GLuint blurtexture_b;\n    CRTEMU_GLuint blurbuffer_a;\n    CRTEMU_GLuint blurbuffer_b;\n\n    CRTEMU_GLuint frametexture;\n    float use_frame;\n\n    CRTEMU_GLuint crt_shader;\n    CRTEMU_GLuint blur_shader;\n    CRTEMU_GLuint accumulate_shader;\n    CRTEMU_GLuint blend_shader;\n    CRTEMU_GLuint copy_shader;\n\n    int last_present_width;\n    int last_present_height;\n\n\n    #ifndef CRTEMU_SDL\n        struct HINSTANCE__* gl_dll;\n        CRTEMU_PROC (CRTEMU_GLCALLTYPE *wglGetProcAddress) (char const* );\n    #endif\n\n    void (CRTEMU_GLCALLTYPE* TexParameterfv) (CRTEMU_GLenum target, CRTEMU_GLenum pname, CRTEMU_GLfloat const* params);\n    void (CRTEMU_GLCALLTYPE* DeleteFramebuffers) (CRTEMU_GLsizei n, CRTEMU_GLuint const* framebuffers);\n    void (CRTEMU_GLCALLTYPE* GetIntegerv) (CRTEMU_GLenum pname, CRTEMU_GLint *data);\n    void (CRTEMU_GLCALLTYPE* GenFramebuffers) (CRTEMU_GLsizei n, CRTEMU_GLuint *framebuffers);\n    void (CRTEMU_GLCALLTYPE* BindFramebuffer) (CRTEMU_GLenum target, CRTEMU_GLuint framebuffer);\n    void (CRTEMU_GLCALLTYPE* Uniform1f) (CRTEMU_GLint location, CRTEMU_GLfloat v0);\n    void (CRTEMU_GLCALLTYPE* Uniform2f) (CRTEMU_GLint location, CRTEMU_GLfloat v0, CRTEMU_GLfloat v1);\n    void (CRTEMU_GLCALLTYPE* FramebufferTexture2D) (CRTEMU_GLenum target, CRTEMU_GLenum attachment, CRTEMU_GLenum textarget, CRTEMU_GLuint texture, CRTEMU_GLint level);\n    CRTEMU_GLuint (CRTEMU_GLCALLTYPE* CreateShader) (CRTEMU_GLenum type);\n    void (CRTEMU_GLCALLTYPE* ShaderSource) (CRTEMU_GLuint shader, CRTEMU_GLsizei count, CRTEMU_GLchar const* const* string, CRTEMU_GLint const* length);\n    void (CRTEMU_GLCALLTYPE* CompileShader) (CRTEMU_GLuint shader);\n    void (CRTEMU_GLCALLTYPE* GetShaderiv) (CRTEMU_GLuint shader, CRTEMU_GLenum pname, CRTEMU_GLint *params);\n    CRTEMU_GLuint (CRTEMU_GLCALLTYPE* CreateProgram) (void);\n    void (CRTEMU_GLCALLTYPE* AttachShader) (CRTEMU_GLuint program, CRTEMU_GLuint shader);\n    void (CRTEMU_GLCALLTYPE* BindAttribLocation) (CRTEMU_GLuint program, CRTEMU_GLuint index, CRTEMU_GLchar const* name);\n    void (CRTEMU_GLCALLTYPE* LinkProgram) (CRTEMU_GLuint program);\n    void (CRTEMU_GLCALLTYPE* GetProgramiv) (CRTEMU_GLuint program, CRTEMU_GLenum pname, CRTEMU_GLint *params);\n    void (CRTEMU_GLCALLTYPE* GenBuffers) (CRTEMU_GLsizei n, CRTEMU_GLuint *buffers);\n    void (CRTEMU_GLCALLTYPE* BindBuffer) (CRTEMU_GLenum target, CRTEMU_GLuint buffer);\n    void (CRTEMU_GLCALLTYPE* EnableVertexAttribArray) (CRTEMU_GLuint index);\n    void (CRTEMU_GLCALLTYPE* VertexAttribPointer) (CRTEMU_GLuint index, CRTEMU_GLint size, CRTEMU_GLenum type, CRTEMU_GLboolean normalized, CRTEMU_GLsizei stride, void const* pointer);\n    void (CRTEMU_GLCALLTYPE* GenTextures) (CRTEMU_GLsizei n, CRTEMU_GLuint* textures);\n    void (CRTEMU_GLCALLTYPE* Enable) (CRTEMU_GLenum cap);\n    void (CRTEMU_GLCALLTYPE* ActiveTexture) (CRTEMU_GLenum texture);\n    void (CRTEMU_GLCALLTYPE* BindTexture) (CRTEMU_GLenum target, CRTEMU_GLuint texture);\n    void (CRTEMU_GLCALLTYPE* TexParameteri) (CRTEMU_GLenum target, CRTEMU_GLenum pname, CRTEMU_GLint param);\n    void (CRTEMU_GLCALLTYPE* DeleteBuffers) (CRTEMU_GLsizei n, CRTEMU_GLuint const* buffers);\n    void (CRTEMU_GLCALLTYPE* DeleteTextures) (CRTEMU_GLsizei n, CRTEMU_GLuint const* textures);\n    void (CRTEMU_GLCALLTYPE* BufferData) (CRTEMU_GLenum target, CRTEMU_GLsizeiptr size, void const *data, CRTEMU_GLenum usage);\n    void (CRTEMU_GLCALLTYPE* UseProgram) (CRTEMU_GLuint program);\n    void (CRTEMU_GLCALLTYPE* Uniform1i) (CRTEMU_GLint location, CRTEMU_GLint v0);\n    void (CRTEMU_GLCALLTYPE* Uniform3f) (CRTEMU_GLint location, CRTEMU_GLfloat v0, CRTEMU_GLfloat v1, CRTEMU_GLfloat v2);\n    CRTEMU_GLint (CRTEMU_GLCALLTYPE* GetUniformLocation) (CRTEMU_GLuint program, CRTEMU_GLchar const* name);\n    void (CRTEMU_GLCALLTYPE* TexImage2D) (CRTEMU_GLenum target, CRTEMU_GLint level, CRTEMU_GLint internalformat, CRTEMU_GLsizei width, CRTEMU_GLsizei height, CRTEMU_GLint border, CRTEMU_GLenum format, CRTEMU_GLenum type, void const* pixels);\n    void (CRTEMU_GLCALLTYPE* ClearColor) (CRTEMU_GLfloat red, CRTEMU_GLfloat green, CRTEMU_GLfloat blue, CRTEMU_GLfloat alpha);\n    void (CRTEMU_GLCALLTYPE* Clear) (CRTEMU_GLbitfield mask);\n    void (CRTEMU_GLCALLTYPE* DrawArrays) (CRTEMU_GLenum mode, CRTEMU_GLint first, CRTEMU_GLsizei count);\n    void (CRTEMU_GLCALLTYPE* Viewport) (CRTEMU_GLint x, CRTEMU_GLint y, CRTEMU_GLsizei width, CRTEMU_GLsizei height);\n    void (CRTEMU_GLCALLTYPE* DeleteShader) (CRTEMU_GLuint shader);\n    void (CRTEMU_GLCALLTYPE* DeleteProgram) (CRTEMU_GLuint program);\n    #ifdef CRTEMU_REPORT_SHADER_ERRORS\n        void (CRTEMU_GLCALLTYPE* GetShaderInfoLog) (CRTEMU_GLuint shader, CRTEMU_GLsizei bufSize, CRTEMU_GLsizei *length, CRTEMU_GLchar *infoLog);\n    #endif\n};\n\n\nstatic CRTEMU_GLuint crtemu_internal_build_shader( crtemu_t* crtemu, char const* vs_source, char const* fs_source ) {\n    #ifdef CRTEMU_REPORT_SHADER_ERRORS\n        char error_message[ 1024 ];\n    #endif\n\n    CRTEMU_GLuint vs = crtemu->CreateShader( CRTEMU_GL_VERTEX_SHADER );\n    crtemu->ShaderSource( vs, 1, (char const**) &vs_source, NULL );\n    crtemu->CompileShader( vs );\n    CRTEMU_GLint vs_compiled;\n    crtemu->GetShaderiv( vs, CRTEMU_GL_COMPILE_STATUS, &vs_compiled );\n    if( !vs_compiled ) {\n        #ifdef CRTEMU_REPORT_SHADER_ERRORS\n            char const* prefix = \"Vertex Shader Error: \";\n            strcpy( error_message, prefix );\n            int len = 0, written = 0;\n            crtemu->GetShaderiv( vs, CRTEMU_GL_INFO_LOG_LENGTH, &len );\n            crtemu->GetShaderInfoLog( vs, (CRTEMU_GLsizei)( sizeof( error_message ) - strlen( prefix ) ), &written,\n                error_message + strlen( prefix ) );\n            CRTEMU_REPORT_ERROR( error_message );\n        #endif\n        return 0;\n    }\n\n    CRTEMU_GLuint fs = crtemu->CreateShader( CRTEMU_GL_FRAGMENT_SHADER );\n    crtemu->ShaderSource( fs, 1, (char const**) &fs_source, NULL );\n    crtemu->CompileShader( fs );\n    CRTEMU_GLint fs_compiled;\n    crtemu->GetShaderiv( fs, CRTEMU_GL_COMPILE_STATUS, &fs_compiled );\n    if( !fs_compiled ) {\n        #ifdef CRTEMU_REPORT_SHADER_ERRORS\n            char const* prefix = \"Fragment Shader Error: \";\n            strcpy( error_message, prefix );\n            int len = 0, written = 0;\n            crtemu->GetShaderiv( vs, CRTEMU_GL_INFO_LOG_LENGTH, &len );\n            crtemu->GetShaderInfoLog( fs, (CRTEMU_GLsizei)( sizeof( error_message ) - strlen( prefix ) ), &written,\n                error_message + strlen( prefix ) );\n            CRTEMU_REPORT_ERROR( error_message );\n        #endif\n        return 0;\n    }\n\n\n    CRTEMU_GLuint prg = crtemu->CreateProgram();\n    crtemu->AttachShader( prg, fs );\n    crtemu->AttachShader( prg, vs );\n    crtemu->BindAttribLocation( prg, 0, \"pos\" );\n    crtemu->LinkProgram( prg );\n\n    CRTEMU_GLint linked;\n    crtemu->GetProgramiv( prg, CRTEMU_GL_LINK_STATUS, &linked );\n    if( !linked ) {\n        #ifdef CRTEMU_REPORT_SHADER_ERRORS\n            char const* prefix = \"Shader Link Error: \";\n            strcpy( error_message, prefix );\n            int len = 0, written = 0;\n            crtemu->GetShaderiv( vs, CRTEMU_GL_INFO_LOG_LENGTH, &len );\n            crtemu->GetShaderInfoLog( prg, (CRTEMU_GLsizei)( sizeof( error_message ) - strlen( prefix ) ), &written,\n                error_message + strlen( prefix ) );\n            CRTEMU_REPORT_ERROR( error_message );\n        #endif\n        return 0;\n    }\n\n    return prg;\n}\n\n\nbool crtemu_shaders_tv( crtemu_t* crtemu ) {\n    char const* vs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"attribute vec4 pos;\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_Position = vec4( pos.xy, 0.0, 1.0 );\"\n        \"    uv = pos.zw;\"\n        \"    }\";\n\n    char const* crt_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\\n\"\n        \"varying vec2 uv;\\n\"\n        \"\\n\"\n        \"uniform vec3 modulate;\\n\"\n        \"uniform vec2 resolution;\\n\"\n        \"uniform vec2 size;\\n\"\n        \"uniform float time;\\n\"\n        \"uniform sampler2D backbuffer;\\n\"\n        \"uniform sampler2D blurbuffer;\\n\"\n        \"uniform sampler2D frametexture;\\n\"\n        \"uniform float use_frame;\\n\"\n        \"\\n\"\n        #ifdef CRTEMU_WEBGL\n            // WebGL does not support GL_CLAMP_TO_BORDER so we overwrite texture2D\n            // with this function which emulates the clamp-to-border behavior\n            \"vec4 texture2Dborder(sampler2D samp, vec2 tc)\\n\"\n            \"    {\\n\"\n            \"    float borderdist = .502-max(abs(.5-tc.x), abs(.5-tc.y));\\n\"\n            \"    float borderfade = clamp(borderdist * 400.0, 0.0, 1.0);\\n\"\n            \"    return texture2D( samp, tc ) * borderfade;\\n\"\n            \"    }\\n\"\n            \"#define texture2D texture2Dborder\\n\"\n        #endif\n        \"vec3 tsample( sampler2D samp, vec2 tc, float offs, vec2 resolution )\\n\"\n        \"    {\\n\"\n        \"    tc = tc * vec2(1.025, 0.92) + vec2(-0.0125, 0.04);\\n\"\n        \"    vec3 s = pow( abs( texture2D( samp, vec2( tc.x, 1.0-tc.y ) ).rgb), vec3( 2.2 ) );\\n\"\n        \"    return s*vec3(1.25);\\n\"\n        \"    }\"\n        \"\\n\"\n        \"vec3 filmic( vec3 LinearColor )\\n\"\n        \"    {\\n\"\n        \"    vec3 x = max( vec3(0.0), LinearColor-vec3(0.004));\\n\"\n        \"    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"vec2 curve( vec2 uv )\\n\"\n        \"    {\\n\"\n        \"    uv = (uv - 0.5) * 2.0;\\n\"\n        \"    uv *= 1.1;  \\n\"\n        \"    uv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\\n\"\n        \"    uv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\\n\"\n        \"    uv  = (uv / 2.0) + 0.5;\\n\"\n        \"    uv =  uv *0.92 + 0.04;\\n\"\n        \"    return uv;\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"float rand(vec2 co)\\n\"\n        \"    {\\n\"\n        \"    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n\"\n        \"    }\\n\"\n        \"    \\n\"\n        \"void main(void)\\n\"\n        \"    {\\n\"\n        \"    /* Curve */\\n\"\n        \"    vec2 curved_uv = mix( curve( uv ), uv, 0.4 );\\n\"\n        \"    float scale = 0.04;\\n\"\n        \"    vec2 scuv = curved_uv*(1.0-scale)+scale/2.0+vec2(0.003, -0.001);\\n\"\n        \"\\n\"\n        \"    /* Main color, Bleed */\\n\"\n        \"    vec3 col;\\n\"\n        \"    float x =  sin(0.1*time+curved_uv.y*13.0)*sin(0.23*time+curved_uv.y*19.0)*sin(0.3+0.11*time+curved_uv.y*23.0)*0.0012;\\n\"\n        \"    float o =sin(gl_FragCoord.y*1.5)/resolution.x;\\n\"\n        \"    x=x*0.25+o*0.25;\\n\"\n        \"    col.r = tsample(backbuffer,vec2(x+scuv.x+0.0009,scuv.y+0.0009),resolution.y/800.0, resolution ).x+0.02;\\n\"\n        \"    col.g = tsample(backbuffer,vec2(x+scuv.x+0.0000,scuv.y-0.0011),resolution.y/800.0, resolution ).y+0.02;\\n\"\n        \"    col.b = tsample(backbuffer,vec2(x+scuv.x-0.0015,scuv.y+0.0000),resolution.y/800.0, resolution ).z+0.02;\\n\"\n        \"    float i = clamp(col.r*0.299 + col.g*0.587 + col.b*0.114, 0.0, 1.0 );        \\n\"\n        \"    i = pow( 1.0 - pow(i,2.0), 1.0 );\\n\"\n        \"    i = (1.0-i) * 0.85 + 0.15;  \\n\"\n        \"\\n\"\n        \"    /* Ghosting */\\n\"\n        \"    float ghs = 0.15;\\n\"\n        \"    vec3 r = tsample(blurbuffer, vec2(x-0.014*1.0, -0.027)*0.85+0.007*vec2( 0.35*sin(1.0/7.0 + 15.0*curved_uv.y + 0.9*time), \\n\"\n        \"        0.35*sin( 2.0/7.0 + 10.0*curved_uv.y + 1.37*time) )+vec2(scuv.x+0.001,scuv.y+0.001),\\n\"\n        \"        5.5+1.3*sin( 3.0/9.0 + 31.0*curved_uv.x + 1.70*time),resolution).xyz*vec3(0.5,0.25,0.25);\\n\"\n        \"    vec3 g = tsample(blurbuffer, vec2(x-0.019*1.0, -0.020)*0.85+0.007*vec2( 0.35*cos(1.0/9.0 + 15.0*curved_uv.y + 0.5*time), \\n\"\n        \"        0.35*sin( 2.0/9.0 + 10.0*curved_uv.y + 1.50*time) )+vec2(scuv.x+0.000,scuv.y-0.002),\\n\"\n        \"        5.4+1.3*sin( 3.0/3.0 + 71.0*curved_uv.x + 1.90*time),resolution).xyz*vec3(0.25,0.5,0.25);\\n\"\n        \"    vec3 b = tsample(blurbuffer, vec2(x-0.017*1.0, -0.003)*0.85+0.007*vec2( 0.35*sin(2.0/3.0 + 15.0*curved_uv.y + 0.7*time), \\n\"\n        \"        0.35*cos( 2.0/3.0 + 10.0*curved_uv.y + 1.63*time) )+vec2(scuv.x-0.002,scuv.y+0.000),\\n\"\n        \"        5.3+1.3*sin( 3.0/7.0 + 91.0*curved_uv.x + 1.65*time),resolution).xyz*vec3(0.25,0.25,0.5);\\n\"\n        \"\\n\"\n        \"    col += vec3(ghs*(1.0-0.299))*pow(clamp(vec3(3.0)*r,vec3(0.0),vec3(1.0)),vec3(2.0))*vec3(i);\\n\"\n        \"    col += vec3(ghs*(1.0-0.587))*pow(clamp(vec3(3.0)*g,vec3(0.0),vec3(1.0)),vec3(2.0))*vec3(i);\\n\"\n        \"    col += vec3(ghs*(1.0-0.114))*pow(clamp(vec3(3.0)*b,vec3(0.0),vec3(1.0)),vec3(2.0))*vec3(i);\\n\"\n        \"\\n\"\n        \"    /* Level adjustment (curves) */\\n\"\n        \"    col *= vec3(0.95,1.05,0.95);\\n\"\n        \"    col = clamp(col*1.3 + 0.75*col*col + 1.25*col*col*col*col*col,vec3(0.0),vec3(10.0));\\n\"\n        \"\\n\"\n        \"    /* Vignette */\\n\"\n        \"    float vig = (0.1 + 1.0*16.0*curved_uv.x*curved_uv.y*(1.0-curved_uv.x)*(1.0-curved_uv.y));\\n\"\n        \"    vig = 1.3*pow(vig,0.5);\\n\"\n        \"    col *= vig;\\n\"\n        \"\\n\"\n        \"    /* Scanlines */\\n\"\n        \"    float scans = clamp( 0.35+0.18*sin(4.0*time+curved_uv.y*size.y*1.5), 0.0, 1.0);\\n\"\n        \"    float s = pow(scans,0.9);\\n\"\n        \"    col = col * vec3(s);\\n\"\n        \"\\n\"\n        \"    /* Vertical lines (shadow mask) */\\n\"\n        \"    col*=1.0-0.23*(clamp((mod(gl_FragCoord.xy.x, 3.0))/2.0,0.0,1.0));\\n\"\n        \"\\n\"\n        \"    /* Tone map */\\n\"\n        \"    col = filmic( col );\\n\"\n        \"\\n\"\n        \"    /* Noise */\\n\"\n        \"    /*vec2 seed = floor(curved_uv*resolution.xy*vec2(0.5))/resolution.xy;*/\\n\"\n        \"    vec2 seed = curved_uv*resolution.xy;;\\n\"\n        \"    /* seed = curved_uv; */\\n\"\n        \"    col -= 0.015*pow(vec3(rand( seed +time ), rand( seed +time*2.0 ), rand( seed +time * 3.0 ) ), vec3(1.5) );\\n\"\n        \"\\n\"\n        \"    /* Flicker */\\n\"\n        \"    col *= (1.0-0.004*(sin(50.0*time+curved_uv.y*2.0)*0.5+0.5));\\n\"\n        \"\\n\"\n        \"    /* Clamp */\\n\"\n        \"    if (curved_uv.x < 0.0 || curved_uv.x > 1.0)\\n\"\n        \"        col *= 0.0;\\n\"\n        \"    if (curved_uv.y < 0.0 || curved_uv.y > 1.0)\\n\"\n        \"        col *= 0.0;\\n\"\n        \"    col *= modulate;\\n\"\n        \"    /* Frame */\\n\"\n        \"    vec2 fuv=vec2( uv.x, 1.0 - uv.y);\\n\"\n        \"    vec4 f=texture2D(frametexture,fuv);\\n\"\n        \"    vec3 fr = mix( max( col, 0.0), f.xyz, f.w);\\n\"\n        \"    col = mix( col, fr, vec3( use_frame ) );\\n\"\n        \"    \\n\"\n        \"    gl_FragColor = vec4( col, 1.0 );\\n\"\n        \"    }\\n\"\n        \"\\n\";\n\n    char const* blur_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform vec2 blur;\"\n        \"uniform sampler2D texture;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 sum = texture2D( texture, uv ) * 0.2270270270;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 4.0 * blur.x, uv.y - 4.0 * blur.y ) ) * 0.0162162162;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 3.0 * blur.x, uv.y - 3.0 * blur.y ) ) * 0.0540540541;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 2.0 * blur.x, uv.y - 2.0 * blur.y ) ) * 0.1216216216;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 1.0 * blur.x, uv.y - 1.0 * blur.y ) ) * 0.1945945946;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 1.0 * blur.x, uv.y + 1.0 * blur.y ) ) * 0.1945945946;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 2.0 * blur.x, uv.y + 2.0 * blur.y ) ) * 0.1216216216;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 3.0 * blur.x, uv.y + 3.0 * blur.y ) ) * 0.0540540541;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 4.0 * blur.x, uv.y + 4.0 * blur.y ) ) * 0.0162162162;\"\n        \"    gl_FragColor = sum;\"\n        \"    }   \"\n        \"\";\n\n\n    char const* accumulate_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"uniform sampler2D tex1;\"\n        \"uniform float modulate;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 a = texture2D( tex0, uv ) * vec4( modulate );\"\n        \"    vec4 b = texture2D( tex1, uv );\"\n        \"\"\n        \"    gl_FragColor = max( a, b * 0.96 );\"\n        \"    }   \"\n        \"\";\n\n    char const* blend_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"uniform sampler2D tex1;\"\n        \"uniform float modulate;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 a = texture2D( tex0, uv ) * vec4( modulate );\"\n        \"    vec4 b = texture2D( tex1, uv );\"\n        \"\"\n        \"    gl_FragColor = max( a, b * 0.32 );\"\n        \"    }   \"\n        \"\";\n\n    char const* copy_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_FragColor = texture2D( tex0, uv );\"\n        \"    }   \"\n        \"\";\n\n    crtemu->crt_shader = crtemu_internal_build_shader( crtemu, vs_source, crt_fs_source );\n    if( crtemu->crt_shader == 0 ) return false;\n\n    crtemu->blur_shader = crtemu_internal_build_shader( crtemu, vs_source, blur_fs_source );\n    if( crtemu->blur_shader == 0 ) return false;\n\n    crtemu->accumulate_shader = crtemu_internal_build_shader( crtemu, vs_source, accumulate_fs_source );\n    if( crtemu->accumulate_shader == 0 ) return false;\n\n    crtemu->blend_shader = crtemu_internal_build_shader( crtemu, vs_source, blend_fs_source );\n    if( crtemu->blend_shader == 0 ) return false;\n\n    crtemu->copy_shader = crtemu_internal_build_shader( crtemu, vs_source, copy_fs_source );\n    if( crtemu->copy_shader == 0 ) return false;\n\n    return true;\n}\n\n\nbool crtemu_shaders_pc( crtemu_t* crtemu ) {\n    char const* vs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"attribute vec4 pos;\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_Position = vec4( pos.xy, 0.0, 1.0 );\"\n        \"    uv = pos.zw;\"\n        \"    }\";\n\n    char const* crt_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\\n\"\n        \"varying vec2 uv;\\n\"\n        \"\\n\"\n        \"uniform vec3 modulate;\\n\"\n        \"uniform vec2 resolution;\\n\"\n        \"uniform vec2 size;\\n\"\n        \"uniform float time;\\n\"\n        \"uniform sampler2D backbuffer;\\n\"\n        \"uniform sampler2D blurbuffer;\\n\"\n        \"uniform sampler2D frametexture;\\n\"\n        \"uniform float use_frame;\\n\"\n        \"\\n\"\n        #ifdef CRTEMU_WEBGL\n            // WebGL does not support GL_CLAMP_TO_BORDER so we overwrite texture2D\n            // with this function which emulates the clamp-to-border behavior\n            \"vec4 texture2Dborder(sampler2D samp, vec2 tc)\\n\"\n            \"    {\\n\"\n            \"    float borderdist = .502-max(abs(.5-tc.x), abs(.5-tc.y));\\n\"\n            \"    float borderfade = clamp(borderdist * 400.0, 0.0, 1.0);\\n\"\n            \"    return texture2D( samp, tc ) * borderfade;\\n\"\n            \"    }\\n\"\n            \"#define texture2D texture2Dborder\\n\"\n        #endif\n        \"vec3 tsample( sampler2D samp, vec2 tc, float offs, vec2 resolution )\\n\"\n        \"    {\\n\"\n        \"    tc = tc * vec2(1.156, 1.156) - vec2( 0.078 + 0.003, 0.078 );\\n\"\n        \"    vec3 s = pow( abs( texture2D( samp, vec2( tc.x, 1.0-tc.y ) ).rgb), vec3( 2.2 ) );\\n\"\n        \"    return s*vec3(1.25);\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"vec3 filmic( vec3 LinearColor )\\n\"\n        \"    {\\n\"\n        \"    vec3 x = max( vec3(0.0), LinearColor-vec3(0.004));\\n\"\n        \"    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"vec2 curve( vec2 uv )\\n\"\n        \"    {\\n\"\n        \"    uv = (uv - 0.5) * 2.0;\\n\"\n        \"    uv *= 1.1; \\n\"\n        \"    uv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\\n\"\n        \"    uv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\\n\"\n        \"    uv  = (uv / 2.0) + 0.5;\\n\"\n        \"    uv =  uv *0.92 + 0.04;\\n\"\n        \"    return uv;\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"float rand(vec2 co)\\n\"\n        \"    {\\n\"\n        \"    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n\"\n        \"    }\\n\"\n        \"    \\n\"\n        \"void main(void)\\n\"\n        \"   {\\n\"\n        \"    /* Curve */\\n\"\n        \"    vec2 curved_uv = mix( curve( uv ), uv, 0.8 );\\n\"\n        \"    float scale = 0.04;\\n\"\n        \"    vec2 scuv = curved_uv*(1.0-scale)+scale/2.0+vec2(0.003, -0.001);\\n\"\n        \"\\n\"\n        \"    /* Main color, Bleed */\\n\"\n        \"    vec3 col;\\n\"\n        \"    float x =  sin(0.1*time+curved_uv.y*13.0)*sin(0.23*time+curved_uv.y*19.0)*sin(0.3+0.11*time+curved_uv.y*23.0)*0.0012;\\n\"\n        \"    float o =sin(gl_FragCoord.y*1.5)/resolution.x;\\n\"\n        \"    x+=o*0.25;\\n\"\n        \"   x *= 0.2;\\n\"\n        \"    col.r = tsample(backbuffer,vec2(x+scuv.x+0.0009*0.25,scuv.y+0.0009*0.25),resolution.y/800.0, resolution ).x+0.02;\\n\"\n        \"    col.g = tsample(backbuffer,vec2(x+scuv.x+0.0000*0.25,scuv.y-0.0011*0.25),resolution.y/800.0, resolution ).y+0.02;\\n\"\n        \"    col.b = tsample(backbuffer,vec2(x+scuv.x-0.0015*0.25,scuv.y+0.0000*0.25),resolution.y/800.0, resolution ).z+0.02;\\n\"\n        \"    float i = clamp(col.r*0.299 + col.g*0.587 + col.b*0.114, 0.0, 1.0 );       \\n\"\n        \"    i = pow( 1.0 - pow(i,2.0), 1.0 );\\n\"\n        \"    i = (1.0-i) * 0.85 + 0.15; \\n\"\n        \"\\n\"\n        \"    /* Ghosting */\\n\"\n        \"    float ghs = 0.05;\\n\"\n        \"    vec3 r = tsample(blurbuffer, vec2(x-0.014*1.0, -0.027)*0.45+0.007*vec2( 0.35*sin(1.0/7.0 + 15.0*curved_uv.y + 0.9*time), \\n\"\n        \"        0.35*sin( 2.0/7.0 + 10.0*curved_uv.y + 1.37*time) )+vec2(scuv.x+0.001,scuv.y+0.001),\\n\"\n        \"        5.5+1.3*sin( 3.0/9.0 + 31.0*curved_uv.x + 1.70*time),resolution).xyz*vec3(0.5,0.25,0.25);\\n\"\n        \"    vec3 g = tsample(blurbuffer, vec2(x-0.019*1.0, -0.020)*0.45+0.007*vec2( 0.35*cos(1.0/9.0 + 15.0*curved_uv.y + 0.5*time), \\n\"\n        \"        0.35*sin( 2.0/9.0 + 10.0*curved_uv.y + 1.50*time) )+vec2(scuv.x+0.000,scuv.y-0.002),\\n\"\n        \"        5.4+1.3*sin( 3.0/3.0 + 71.0*curved_uv.x + 1.90*time),resolution).xyz*vec3(0.25,0.5,0.25);\\n\"\n        \"    vec3 b = tsample(blurbuffer, vec2(x-0.017*1.0, -0.003)*0.35+0.007*vec2( 0.35*sin(2.0/3.0 + 15.0*curved_uv.y + 0.7*time), \\n\"\n        \"        0.35*cos( 2.0/3.0 + 10.0*curved_uv.y + 1.63*time) )+vec2(scuv.x-0.002,scuv.y+0.000),\\n\"\n        \"        5.3+1.3*sin( 3.0/7.0 + 91.0*curved_uv.x + 1.65*time),resolution).xyz*vec3(0.25,0.25,0.5);\\n\"\n        \"\\n\"\n        \"    col += vec3(ghs*(1.0-0.299))*pow(clamp(vec3(3.0)*r,vec3(0.0),vec3(1.0)),vec3(2.0))*vec3(i);\\n\"\n        \"    col += vec3(ghs*(1.0-0.587))*pow(clamp(vec3(3.0)*g,vec3(0.0),vec3(1.0)),vec3(2.0))*vec3(i);\\n\"\n        \"    col += vec3(ghs*(1.0-0.114))*pow(clamp(vec3(3.0)*b,vec3(0.0),vec3(1.0)),vec3(2.0))*vec3(i);\\n\"\n        \"\\n\"\n        \"    /* Level adjustment (curves) */\\n\"\n        \"    col *= vec3(0.95,0.95,0.95);\\n\"\n        \"    col = clamp(col*1.3 + 0.75*col*col + 1.25*col*col*col*col*col,vec3(0.0),vec3(10.0));\\n\"\n        \"\\n\"\n        \"    /* Vignette */\\n\"\n        \"    float vig = (0.1 + 1.0*16.0*curved_uv.x*curved_uv.y*(1.0-curved_uv.x)*(1.0-curved_uv.y));\\n\"\n        \"    vig = 1.3*pow(vig,0.5);\\n\"\n        \"    col *= vig;\\n\"\n        \"\\n\"\n        \"    /* Scanlines */\\n\"\n        \"    float scans = clamp( 0.5+0.2*sin(cos(20.0*time)*0.32+curved_uv.y*size.y*1.75), 0.0, 1.0);\\n\"\n        \"    float s = pow(scans,0.9);\\n\"\n        \"    col = col * vec3(s);\\n\"\n        \"\\n\"\n        \"    /* Vertical lines (shadow mask) */\\n\"\n        \"    col*=1.0-0.23*(clamp((mod(gl_FragCoord.xy.x, 3.0))/2.0,0.0,1.0));\\n\"\n        \"\\n\"\n        \"    /* Tone map */\\n\"\n        \"    col = filmic( col );\\n\"\n        \"\\n\"\n        \"    /* Noise */\\n\"\n        \"    //vec2 seed = floor(curved_uv*resolution.xy*vec2(0.5))/resolution.xy;\\n\"\n        \"    vec2 seed = curved_uv*resolution.xy;;\\n\"\n        \"    /* seed = curved_uv; */\\n\"\n        \"    col -= 0.015*pow(vec3(rand( seed +time ), rand( seed +time*2.0 ), rand( seed +time * 3.0 ) ), vec3(1.5) );\\n\"\n        \"\\n\"\n        \"    /* Flicker */\\n\"\n        \"    col *= (1.0-0.004*(sin(50.0*time+curved_uv.y*2.0)*0.5+0.5));\\n\"\n        \"\\n\"\n        \"    /* Clamp */\\n\"\n        \"    if (curved_uv.x < 0.0 || curved_uv.x > 1.0)\\n\"\n        \"        col *= 0.0;\\n\"\n        \"    if (curved_uv.y < 0.0 || curved_uv.y > 1.0)\\n\"\n        \"        col *= 0.0;\\n\"\n        \"    col*=modulate; \\n\"\n        \"    /* Frame */\\n\"\n        \"   vec2 fuv=vec2( uv.x, 1.0 - uv.y);\\n\"\n        \"    vec4 f=texture2D(frametexture, fuv);\\n\"\n        \"    col = mix( col, mix( max( col, 0.0), f.xyz, f.w), vec3( use_frame) );\\n\"\n        \"    \\n\"\n        \"   gl_FragColor = vec4( col, 1.0 );\\n\"\n        \"   }\\n\"\n        \"   \\n\"\n        \"\";\n\n    char const* blur_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform vec2 blur;\"\n        \"uniform sampler2D texture;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 sum = texture2D( texture, uv ) * 0.2270270270;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 4.0 * blur.x, uv.y - 4.0 * blur.y ) ) * 0.0162162162;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 3.0 * blur.x, uv.y - 3.0 * blur.y ) ) * 0.0540540541;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 2.0 * blur.x, uv.y - 2.0 * blur.y ) ) * 0.1216216216;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 1.0 * blur.x, uv.y - 1.0 * blur.y ) ) * 0.1945945946;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 1.0 * blur.x, uv.y + 1.0 * blur.y ) ) * 0.1945945946;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 2.0 * blur.x, uv.y + 2.0 * blur.y ) ) * 0.1216216216;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 3.0 * blur.x, uv.y + 3.0 * blur.y ) ) * 0.0540540541;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 4.0 * blur.x, uv.y + 4.0 * blur.y ) ) * 0.0162162162;\"\n        \"    gl_FragColor = sum;\"\n        \"    }   \"\n        \"\";\n\n\n    char const* accumulate_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"uniform sampler2D tex1;\"\n        \"uniform float modulate;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 a = texture2D( tex0, uv ) * vec4( modulate );\"\n        \"    vec4 b = texture2D( tex1, uv );\"\n        \"\"\n        \"    gl_FragColor = max( a, b * 0.96 );\"\n        \"    }   \"\n        \"\";\n\n    char const* blend_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"uniform sampler2D tex1;\"\n        \"uniform float modulate;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 a = texture2D( tex0, uv ) * vec4( modulate );\"\n        \"    vec4 b = texture2D( tex1, uv );\"\n        \"\"\n        \"    gl_FragColor = max( a, b * 0.24 );\"\n        \"    }   \"\n        \"\";\n\n    char const* copy_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_FragColor = texture2D( tex0, uv );\"\n        \"    }   \"\n        \"\";\n\n    crtemu->crt_shader = crtemu_internal_build_shader( crtemu, vs_source, crt_fs_source );\n    if( crtemu->crt_shader == 0 ) return false;\n\n    crtemu->blur_shader = crtemu_internal_build_shader( crtemu, vs_source, blur_fs_source );\n    if( crtemu->blur_shader == 0 ) return false;\n\n    crtemu->accumulate_shader = crtemu_internal_build_shader( crtemu, vs_source, accumulate_fs_source );\n    if( crtemu->accumulate_shader == 0 ) return false;\n\n    crtemu->blend_shader = crtemu_internal_build_shader( crtemu, vs_source, blend_fs_source );\n    if( crtemu->blend_shader == 0 ) return false;\n\n    crtemu->copy_shader = crtemu_internal_build_shader( crtemu, vs_source, copy_fs_source );\n    if( crtemu->copy_shader == 0 ) return false;\n\n    return true;\n}\n\n\nbool crtemu_shaders_lite( crtemu_t* crtemu ) {\n    char const* vs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"attribute vec4 pos;\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_Position = vec4( pos.xy, 0.0, 1.0 );\"\n        \"    uv = pos.zw;\"\n        \"    }\";\n\n    char const* crt_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\\n\"\n        \"varying vec2 uv;\\n\"\n        \"\\n\"\n        \"uniform vec3 modulate;\\n\"\n        \"uniform vec2 resolution;\\n\"\n        \"uniform vec2 size;\\n\"\n        \"uniform float time;\\n\"\n        \"uniform sampler2D backbuffer;\\n\"\n        \"uniform sampler2D blurbuffer;\\n\"\n        \"uniform sampler2D frametexture;\\n\"\n        \"uniform float use_frame;\\n\"\n        \"\\n\"\n       /* #ifdef CRTEMU_WEBGL\n            // WebGL does not support GL_CLAMP_TO_BORDER so we overwrite texture2D\n            // with this function which emulates the clamp-to-border behavior\n            \"vec4 texture2Dborder(sampler2D samp, vec2 tc)\\n\"\n            \"    {\\n\"\n            \"    float borderdist = .502-max(abs(.5-tc.x), abs(.5-tc.y));\\n\"\n            \"    float borderfade = clamp(borderdist * 400.0, 0.0, 1.0);\\n\"\n            \"    return texture2D( samp, tc ) * borderfade;\\n\"\n            \"    }\\n\"\n            \"#define texture2D texture2Dborder\\n\"\n        #endif*/\n        \"vec3 tsample( sampler2D samp, vec2 tc )\\n\"\n        \"    {\\n\"\n        \"    vec3 s = pow( abs( texture2D( samp, vec2( tc.x, 1.0-tc.y ) ).rgb), vec3( 2.2 ) );\\n\"\n        \"    return s;\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"vec3 filmic( vec3 LinearColor )\\n\"\n        \"    {\\n\"\n        \"    vec3 x = max( vec3(0.0), LinearColor-vec3(0.004));\\n\"\n        \"    return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);\\n\"\n        \"    }\\n\"\n        \"\\n\"\n        \"void main(void)\\n\"\n        \"   {\\n\"\n        \"    // Main color\\n\"\n        \"    vec3 col;\\n\"\n        \"    col = mix( tsample(backbuffer,uv ), tsample(frametexture,uv ), 0.45 );\\n\"\n        \"    col = 3.0*col + pow( col, vec3( 3.0 ) );\\n\"\n        \"    col += tsample(blurbuffer,uv )*0.3;\\n\"\n        \"\\n\"\n        \"    // Scanlines\\n\"\n        \"    float scans = clamp( 0.5-0.5*cos( uv.y * 6.28319 * (size.y ) ), 0.0, 1.0);\\n\"\n        \"    float s = pow(scans,1.3);\\n\"\n        \"    col = mix( col, col * vec3(s), 0.7 );\\n\"\n        \"\\n\"\n        \"    // Vertical lines (shadow mask)\\n\"\n        \"    col*=1.0-0.23*(clamp((mod(gl_FragCoord.xy.x, 3.0))/2.0,0.0,1.0));\\n\"\n        \"\\n\"\n        \"    // Vignette\\n\"\n        \"    float vig = (0.1 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\\n\"\n        \"    vig = 1.3*pow(vig,0.5);\\n\"\n        \"    col = mix( col, col*vig, 0.2 );\\n\"\n        \"\\n\"\n        \"    // Tone map\\n\"\n        \"    col = mix( pow( col, vec3(1.0 / 2.2) ), filmic( col ), 0.5 );\\n\"\n        \"\\n\"\n        \"    col*=modulate; \\n\"\n        \"    gl_FragColor = vec4( col, 1.0 );\\n\"\n        \"   }\\n\"\n        \"   \\n\"\n        \"\";\n\n    char const* blur_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform vec2 blur;\"\n        \"uniform sampler2D texture;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 sum = texture2D( texture, uv ) * 0.2270270270;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 4.0 * blur.x, uv.y - 4.0 * blur.y ) ) * 0.0162162162;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 3.0 * blur.x, uv.y - 3.0 * blur.y ) ) * 0.0540540541;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 2.0 * blur.x, uv.y - 2.0 * blur.y ) ) * 0.1216216216;\"\n        \"    sum += texture2D(texture, vec2( uv.x - 1.0 * blur.x, uv.y - 1.0 * blur.y ) ) * 0.1945945946;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 1.0 * blur.x, uv.y + 1.0 * blur.y ) ) * 0.1945945946;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 2.0 * blur.x, uv.y + 2.0 * blur.y ) ) * 0.1216216216;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 3.0 * blur.x, uv.y + 3.0 * blur.y ) ) * 0.0540540541;\"\n        \"    sum += texture2D(texture, vec2( uv.x + 4.0 * blur.x, uv.y + 4.0 * blur.y ) ) * 0.0162162162;\"\n        \"    gl_FragColor = sum;\"\n        \"    }   \"\n        \"\";\n\n\n    char const* accumulate_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"uniform sampler2D tex1;\"\n        \"uniform float modulate;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 a = texture2D( tex0, uv ) * vec4( modulate );\"\n        \"    vec4 b = texture2D( tex1, uv );\"\n        \"\"\n        \"    gl_FragColor = max( a, b * 0.96 );\"\n        \"    }   \"\n        \"\";\n\n    char const* blend_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"uniform sampler2D tex1;\"\n        \"uniform float modulate;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    vec4 a = texture2D( tex0, uv ) * vec4( modulate );\"\n        \"    vec4 b = texture2D( tex1, uv );\"\n        \"\"\n        \"    gl_FragColor = max( a, b * 0.2 );\"\n        \"    }   \"\n        \"\";\n\n    char const* copy_fs_source =\n        #ifdef CRTEMU_WEBGL\n            \"precision highp float;\\n\\n\"\n        #else\n            \"#version 120\\n\\n\"\n        #endif\n        \"\"\n        \"varying vec2 uv;\"\n        \"\"\n        \"uniform sampler2D tex0;\"\n        \"\"\n        \"void main( void )\"\n        \"    {\"\n        \"    gl_FragColor = texture2D( tex0, uv );\"\n        \"    }   \"\n        \"\";\n\n    crtemu->crt_shader = crtemu_internal_build_shader( crtemu, vs_source, crt_fs_source );\n    if( crtemu->crt_shader == 0 ) return false;\n\n    crtemu->blur_shader = crtemu_internal_build_shader( crtemu, vs_source, blur_fs_source );\n    if( crtemu->blur_shader == 0 ) return false;\n\n    crtemu->accumulate_shader = crtemu_internal_build_shader( crtemu, vs_source, accumulate_fs_source );\n    if( crtemu->accumulate_shader == 0 ) return false;\n\n    crtemu->blend_shader = crtemu_internal_build_shader( crtemu, vs_source, blend_fs_source );\n    if( crtemu->blend_shader == 0 ) return false;\n\n    crtemu->copy_shader = crtemu_internal_build_shader( crtemu, vs_source, copy_fs_source );\n    if( crtemu->copy_shader == 0 ) return false;\n\n    return true;\n\n}\n\n\ncrtemu_t* crtemu_create( crtemu_type_t type, void* memctx ) {\n    crtemu_t* crtemu = (crtemu_t*) CRTEMU_MALLOC( memctx, sizeof( crtemu_t ) );\n    memset( crtemu, 0, sizeof( crtemu_t ) );\n    crtemu->type = type;\n    crtemu->memctx = memctx;\n        \n    crtemu->use_frame = 0.0f;\n\n    crtemu->last_present_width = 0;\n    crtemu->last_present_height = 0;\n\n    #ifndef CRTEMU_SDL\n\n        crtemu->gl_dll = LoadLibraryA( \"opengl32.dll\" );\n        if( !crtemu->gl_dll ) goto failed;\n\n        crtemu->wglGetProcAddress = (CRTEMU_PROC (CRTEMU_GLCALLTYPE*)(char const*)) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"wglGetProcAddress\" );\n        if( !crtemu->gl_dll ) goto failed;\n\n        // Attempt to bind opengl functions using GetProcAddress\n        crtemu->TexParameterfv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLfloat const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glTexParameterfv\" );\n        crtemu->DeleteFramebuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glDeleteFramebuffers\" );\n        crtemu->GetIntegerv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLint *) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGetIntegerv\" );\n        crtemu->GenFramebuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint *) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGenFramebuffers\" );\n        crtemu->BindFramebuffer = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glBindFramebuffer\" );\n        crtemu->Uniform1f = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLfloat) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glUniform1f\" );\n        crtemu->Uniform2f = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLfloat, CRTEMU_GLfloat) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glUniform2f\" );\n        crtemu->FramebufferTexture2D = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLuint, CRTEMU_GLint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glFramebufferTexture2D\" );\n        crtemu->CreateShader = ( CRTEMU_GLuint (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glCreateShader\" );\n        crtemu->ShaderSource = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLsizei, CRTEMU_GLchar const* const*, CRTEMU_GLint const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glShaderSource\" );\n        crtemu->CompileShader = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glCompileShader\" );\n        crtemu->GetShaderiv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLenum, CRTEMU_GLint*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGetShaderiv\" );\n        crtemu->CreateProgram = ( CRTEMU_GLuint (CRTEMU_GLCALLTYPE*) (void) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glCreateProgram\" );\n        crtemu->AttachShader = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glAttachShader\" );\n        crtemu->BindAttribLocation = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLuint, CRTEMU_GLchar const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glBindAttribLocation\" );\n        crtemu->LinkProgram = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glLinkProgram\" );\n        crtemu->GetProgramiv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLenum, CRTEMU_GLint*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGetProgramiv\" );\n        crtemu->GenBuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGenBuffers\" );\n        crtemu->BindBuffer = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glBindBuffer\" );\n        crtemu->EnableVertexAttribArray = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glEnableVertexAttribArray\" );\n        crtemu->VertexAttribPointer = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLint, CRTEMU_GLenum, CRTEMU_GLboolean, CRTEMU_GLsizei, void const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glVertexAttribPointer\" );\n        crtemu->GenTextures = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGenTextures\" );\n        crtemu->Enable = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glEnable\" );\n        crtemu->ActiveTexture = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glActiveTexture\" );\n        crtemu->BindTexture = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glBindTexture\" );\n        crtemu->TexParameteri = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glTexParameteri\" );\n        crtemu->DeleteBuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glDeleteBuffers\" );\n        crtemu->DeleteTextures = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glDeleteTextures\" );\n        crtemu->BufferData = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLsizeiptr, void const *, CRTEMU_GLenum) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glBufferData\" );\n        crtemu->UseProgram = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glUseProgram\" );\n        crtemu->Uniform1i = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glUniform1i\" );\n        crtemu->Uniform3f = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLfloat, CRTEMU_GLfloat, CRTEMU_GLfloat) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glUniform3f\" );\n        crtemu->GetUniformLocation = ( CRTEMU_GLint (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLchar const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGetUniformLocation\" );\n        crtemu->TexImage2D = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLint, CRTEMU_GLint, CRTEMU_GLsizei, CRTEMU_GLsizei, CRTEMU_GLint, CRTEMU_GLenum, CRTEMU_GLenum, void const*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glTexImage2D\" );\n        crtemu->ClearColor = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLfloat, CRTEMU_GLfloat, CRTEMU_GLfloat, CRTEMU_GLfloat) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glClearColor\" );\n        crtemu->Clear = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLbitfield) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glClear\" );\n        crtemu->DrawArrays = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLint, CRTEMU_GLsizei) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glDrawArrays\" );\n        crtemu->Viewport = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLint, CRTEMU_GLsizei, CRTEMU_GLsizei) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glViewport\" );\n        crtemu->DeleteShader = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glDeleteShader\" );\n        crtemu->DeleteProgram = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glDeleteProgram\" );\n        #ifdef CRTEMU_REPORT_SHADER_ERRORS\n            crtemu->GetShaderInfoLog = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLsizei, CRTEMU_GLsizei*, CRTEMU_GLchar*) ) (uintptr_t) GetProcAddress( crtemu->gl_dll, \"glGetShaderInfoLog\" );\n        #endif\n\n        // Any opengl functions which didn't bind, try binding them using wglGetProcAddrss\n        if( !crtemu->TexParameterfv ) crtemu->TexParameterfv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLfloat const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glTexParameterfv\" );\n        if( !crtemu->DeleteFramebuffers ) crtemu->DeleteFramebuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glDeleteFramebuffers\" );\n        if( !crtemu->GetIntegerv ) crtemu->GetIntegerv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLint *) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGetIntegerv\" );\n        if( !crtemu->GenFramebuffers ) crtemu->GenFramebuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint *) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGenFramebuffers\" );\n        if( !crtemu->BindFramebuffer ) crtemu->BindFramebuffer = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glBindFramebuffer\" );\n        if( !crtemu->Uniform1f ) crtemu->Uniform1f = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLfloat) ) (uintptr_t) crtemu->wglGetProcAddress( \"glUniform1f\" );\n        if( !crtemu->Uniform2f ) crtemu->Uniform2f = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLfloat, CRTEMU_GLfloat) ) (uintptr_t) crtemu->wglGetProcAddress( \"glUniform2f\" );\n        if( !crtemu->FramebufferTexture2D ) crtemu->FramebufferTexture2D = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLuint, CRTEMU_GLint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glFramebufferTexture2D\" );\n        if( !crtemu->CreateShader ) crtemu->CreateShader = ( CRTEMU_GLuint (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum) ) (uintptr_t) crtemu->wglGetProcAddress( \"glCreateShader\" );\n        if( !crtemu->ShaderSource ) crtemu->ShaderSource = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLsizei, CRTEMU_GLchar const* const*, CRTEMU_GLint const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glShaderSource\" );\n        if( !crtemu->CompileShader ) crtemu->CompileShader = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glCompileShader\" );\n        if( !crtemu->GetShaderiv ) crtemu->GetShaderiv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLenum, CRTEMU_GLint*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGetShaderiv\" );\n        if( !crtemu->CreateProgram ) crtemu->CreateProgram = ( CRTEMU_GLuint (CRTEMU_GLCALLTYPE*) (void) ) (uintptr_t) crtemu->wglGetProcAddress( \"glCreateProgram\" );\n        if( !crtemu->AttachShader ) crtemu->AttachShader = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glAttachShader\" );\n        if( !crtemu->BindAttribLocation ) crtemu->BindAttribLocation = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLuint, CRTEMU_GLchar const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glBindAttribLocation\" );\n        if( !crtemu->LinkProgram ) crtemu->LinkProgram = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glLinkProgram\" );\n        if( !crtemu->GetProgramiv ) crtemu->GetProgramiv = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLenum, CRTEMU_GLint*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGetProgramiv\" );\n        if( !crtemu->GenBuffers ) crtemu->GenBuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGenBuffers\" );\n        if( !crtemu->BindBuffer ) crtemu->BindBuffer = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glBindBuffer\" );\n        if( !crtemu->EnableVertexAttribArray ) crtemu->EnableVertexAttribArray = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glEnableVertexAttribArray\" );\n        if( !crtemu->VertexAttribPointer ) crtemu->VertexAttribPointer = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLint, CRTEMU_GLenum, CRTEMU_GLboolean, CRTEMU_GLsizei, void const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glVertexAttribPointer\" );\n        if( !crtemu->GenTextures ) crtemu->GenTextures = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGenTextures\" );\n        if( !crtemu->Enable ) crtemu->Enable = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum) ) (uintptr_t) crtemu->wglGetProcAddress( \"glEnable\" );\n        if( !crtemu->ActiveTexture ) crtemu->ActiveTexture = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum) ) (uintptr_t) crtemu->wglGetProcAddress( \"glActiveTexture\" );\n        if( !crtemu->BindTexture ) crtemu->BindTexture = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glBindTexture\" );\n        if( !crtemu->TexParameteri ) crtemu->TexParameteri = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLenum, CRTEMU_GLint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glTexParameteri\" );\n        if( !crtemu->DeleteBuffers ) crtemu->DeleteBuffers = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glDeleteBuffers\" );\n        if( !crtemu->DeleteTextures ) crtemu->DeleteTextures = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLsizei, CRTEMU_GLuint const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glDeleteTextures\" );\n        if( !crtemu->BufferData ) crtemu->BufferData = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLsizeiptr, void const *, CRTEMU_GLenum) ) (uintptr_t) crtemu->wglGetProcAddress( \"glBufferData\" );\n        if( !crtemu->UseProgram ) crtemu->UseProgram = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glUseProgram\" );\n        if( !crtemu->Uniform1i ) crtemu->Uniform1i = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glUniform1i\" );\n        if( !crtemu->Uniform3f ) crtemu->Uniform3f = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLfloat, CRTEMU_GLfloat, CRTEMU_GLfloat) ) (uintptr_t) crtemu->wglGetProcAddress( \"glUniform3f\" );\n        if( !crtemu->GetUniformLocation ) crtemu->GetUniformLocation = ( CRTEMU_GLint (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLchar const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGetUniformLocation\" );\n        if( !crtemu->TexImage2D ) crtemu->TexImage2D = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLint, CRTEMU_GLint, CRTEMU_GLsizei, CRTEMU_GLsizei, CRTEMU_GLint, CRTEMU_GLenum, CRTEMU_GLenum, void const*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glTexImage2D\" );\n        if( !crtemu->ClearColor ) crtemu->ClearColor = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLfloat, CRTEMU_GLfloat, CRTEMU_GLfloat, CRTEMU_GLfloat) ) (uintptr_t) crtemu->wglGetProcAddress( \"glClearColor\" );\n        if( !crtemu->Clear ) crtemu->Clear = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLbitfield) ) (uintptr_t) crtemu->wglGetProcAddress( \"glClear\" );\n        if( !crtemu->DrawArrays ) crtemu->DrawArrays = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLenum, CRTEMU_GLint, CRTEMU_GLsizei) ) (uintptr_t) crtemu->wglGetProcAddress( \"glDrawArrays\" );\n        if( !crtemu->Viewport ) crtemu->Viewport = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLint, CRTEMU_GLint, CRTEMU_GLsizei, CRTEMU_GLsizei) ) (uintptr_t) crtemu->wglGetProcAddress( \"glViewport\" );\n        if( !crtemu->DeleteShader ) crtemu->DeleteShader = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glDeleteShader\" );\n        if( !crtemu->DeleteProgram ) crtemu->DeleteProgram = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint) ) (uintptr_t) crtemu->wglGetProcAddress( \"glDeleteProgram\" );\n        #ifdef CRTEMU_REPORT_SHADER_ERRORS\n            if( !crtemu->GetShaderInfoLog ) crtemu->GetShaderInfoLog = ( void (CRTEMU_GLCALLTYPE*) (CRTEMU_GLuint, CRTEMU_GLsizei, CRTEMU_GLsizei*, CRTEMU_GLchar*) ) (uintptr_t) crtemu->wglGetProcAddress( \"glGetShaderInfoLog\" );\n        #endif\n\n    #else\n\n         crtemu->TexParameterfv = glTexParameterfv;\n         crtemu->DeleteFramebuffers = glDeleteFramebuffers;\n         crtemu->GetIntegerv = glGetIntegerv;\n         crtemu->GenFramebuffers = glGenFramebuffers;\n         crtemu->BindFramebuffer = glBindFramebuffer;\n         crtemu->Uniform1f = glUniform1f;\n         crtemu->Uniform2f = glUniform2f;\n         crtemu->FramebufferTexture2D = glFramebufferTexture2D;\n         crtemu->CreateShader = glCreateShader;\n         crtemu->ShaderSource = glShaderSource;\n         crtemu->CompileShader = glCompileShader;\n         crtemu->GetShaderiv = glGetShaderiv;\n         crtemu->CreateProgram = glCreateProgram;\n         crtemu->AttachShader = glAttachShader;\n         crtemu->BindAttribLocation = glBindAttribLocation;\n         crtemu->LinkProgram = glLinkProgram;\n         crtemu->GetProgramiv = glGetProgramiv;\n         crtemu->GenBuffers = glGenBuffers;\n         crtemu->BindBuffer = glBindBuffer;\n         crtemu->EnableVertexAttribArray = glEnableVertexAttribArray;\n         crtemu->VertexAttribPointer = glVertexAttribPointer;\n         crtemu->GenTextures = glGenTextures;\n         crtemu->Enable = glEnable;\n         crtemu->ActiveTexture = glActiveTexture;\n         crtemu->BindTexture = glBindTexture;\n         crtemu->TexParameteri = glTexParameteri;\n         crtemu->DeleteBuffers = glDeleteBuffers;\n         crtemu->DeleteTextures = glDeleteTextures;\n         crtemu->BufferData = glBufferData;\n         crtemu->UseProgram = glUseProgram;\n         crtemu->Uniform1i = glUniform1i;\n         crtemu->Uniform3f = glUniform3f;\n         crtemu->GetUniformLocation = glGetUniformLocation;\n         crtemu->TexImage2D = glTexImage2D;\n         crtemu->ClearColor = glClearColor;\n         crtemu->Clear = glClear;\n         crtemu->DrawArrays = glDrawArrays;\n         crtemu->Viewport = glViewport;\n         crtemu->DeleteShader = glDeleteShader;\n         crtemu->DeleteProgram = glDeleteProgram;\n         #ifdef CRTEMU_REPORT_SHADER_ERRORS\n            crtemu->GetShaderInfoLog = glGetShaderInfoLog;\n         #endif\n\n    #endif\n\n    // Report error if any gl function was not found.\n    if( !crtemu->TexParameterfv ) goto failed;\n    if( !crtemu->DeleteFramebuffers ) goto failed;\n    if( !crtemu->GetIntegerv ) goto failed;\n    if( !crtemu->GenFramebuffers ) goto failed;\n    if( !crtemu->BindFramebuffer ) goto failed;\n    if( !crtemu->Uniform1f ) goto failed;\n    if( !crtemu->Uniform2f ) goto failed;\n    if( !crtemu->FramebufferTexture2D ) goto failed;\n    if( !crtemu->CreateShader ) goto failed;\n    if( !crtemu->ShaderSource ) goto failed;\n    if( !crtemu->CompileShader ) goto failed;\n    if( !crtemu->GetShaderiv ) goto failed;\n    if( !crtemu->CreateProgram ) goto failed;\n    if( !crtemu->AttachShader ) goto failed;\n    if( !crtemu->BindAttribLocation ) goto failed;\n    if( !crtemu->LinkProgram ) goto failed;\n    if( !crtemu->GetProgramiv ) goto failed;\n    if( !crtemu->GenBuffers ) goto failed;\n    if( !crtemu->BindBuffer ) goto failed;\n    if( !crtemu->EnableVertexAttribArray ) goto failed;\n    if( !crtemu->VertexAttribPointer ) goto failed;\n    if( !crtemu->GenTextures ) goto failed;\n    if( !crtemu->Enable ) goto failed;\n    if( !crtemu->ActiveTexture ) goto failed;\n    if( !crtemu->BindTexture ) goto failed;\n    if( !crtemu->TexParameteri ) goto failed;\n    if( !crtemu->DeleteBuffers ) goto failed;\n    if( !crtemu->DeleteTextures ) goto failed;\n    if( !crtemu->BufferData ) goto failed;\n    if( !crtemu->UseProgram ) goto failed;\n    if( !crtemu->Uniform1i ) goto failed;\n    if( !crtemu->Uniform3f ) goto failed;\n    if( !crtemu->GetUniformLocation ) goto failed;\n    if( !crtemu->TexImage2D ) goto failed;\n    if( !crtemu->ClearColor ) goto failed;\n    if( !crtemu->Clear ) goto failed;\n    if( !crtemu->DrawArrays ) goto failed;\n    if( !crtemu->Viewport ) goto failed;\n    if( !crtemu->DeleteShader ) goto failed;\n    if( !crtemu->DeleteProgram ) goto failed;\n    #ifdef CRTEMU_REPORT_SHADER_ERRORS\n        if( !crtemu->GetShaderInfoLog ) goto failed;\n    #endif\n\n    switch( type ) {\n        case CRTEMU_TYPE_TV: {\n            if( !crtemu_shaders_tv( crtemu ) ) goto failed;               \n        } break;\n        case CRTEMU_TYPE_PC: {\n            if( !crtemu_shaders_pc( crtemu ) ) goto failed;\n        } break;\n        case CRTEMU_TYPE_LITE: {\n            if( !crtemu_shaders_lite( crtemu ) ) goto failed;\n        } break;\n    }\n\n    crtemu->GenTextures( 1, &crtemu->accumulatetexture_a );\n    crtemu->GenFramebuffers( 1, &crtemu->accumulatebuffer_a );\n\n    crtemu->GenTextures( 1, &crtemu->accumulatetexture_b );\n    crtemu->GenFramebuffers( 1, &crtemu->accumulatebuffer_b );\n\n    crtemu->GenTextures( 1, &crtemu->blurtexture_a );\n    crtemu->GenFramebuffers( 1, &crtemu->blurbuffer_a );\n\n    crtemu->GenTextures( 1, &crtemu->blurtexture_b );\n    crtemu->GenFramebuffers( 1, &crtemu->blurbuffer_b );\n\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n    crtemu->GenTextures( 1, &crtemu->frametexture );\n    #ifndef CRTEMU_WEBGL\n        // This enable call is not necessary when using fragment shaders, avoid logged warnings in WebGL\n        crtemu->Enable( CRTEMU_GL_TEXTURE_2D );\n    #endif\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE2 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->frametexture );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n\n    crtemu->GenTextures( 1, &crtemu->backbuffer );\n    crtemu->GenFramebuffers( 1, &crtemu->fbo_backbuffer );\n    #ifndef CRTEMU_WEBGL\n        // This enable call is not necessary when using fragment shaders, avoid logged warnings in WebGL\n        crtemu->Enable( CRTEMU_GL_TEXTURE_2D );\n    #endif\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_NEAREST );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_NEAREST );\n\n    crtemu->GenBuffers( 1, &crtemu->vertexbuffer );\n    crtemu->BindBuffer( CRTEMU_GL_ARRAY_BUFFER, crtemu->vertexbuffer );\n    crtemu->EnableVertexAttribArray( 0 );\n    crtemu->VertexAttribPointer( 0, 4, CRTEMU_GL_FLOAT, CRTEMU_GL_FALSE, 4 * sizeof( CRTEMU_GLfloat ), 0 );\n\n    #ifdef CRTEMU_WEBGL\n        // Avoid WebGL error \"TEXTURE_2D at unit 0 is incomplete: Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE.\"\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_a );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_b );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_a );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_b );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->frametexture );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );\n    #endif\n\n    return crtemu;\n\nfailed:\n    if( crtemu->accumulatetexture_a ) crtemu->DeleteTextures( 1, &crtemu->accumulatetexture_a );\n    if( crtemu->accumulatebuffer_a ) crtemu->DeleteFramebuffers( 1, &crtemu->accumulatebuffer_a );\n    if( crtemu->accumulatetexture_b ) crtemu->DeleteTextures( 1, &crtemu->accumulatetexture_b );\n    if( crtemu->accumulatebuffer_b ) crtemu->DeleteFramebuffers( 1, &crtemu->accumulatebuffer_b );\n    if( crtemu->blurtexture_a ) crtemu->DeleteTextures( 1, &crtemu->blurtexture_a );\n    if( crtemu->blurbuffer_a ) crtemu->DeleteFramebuffers( 1, &crtemu->blurbuffer_a );\n    if( crtemu->blurtexture_b ) crtemu->DeleteTextures( 1, &crtemu->blurtexture_b );\n    if( crtemu->blurbuffer_b ) crtemu->DeleteFramebuffers( 1, &crtemu->blurbuffer_b );\n    if( crtemu->frametexture ) crtemu->DeleteTextures( 1, &crtemu->frametexture );\n    if( crtemu->backbuffer ) crtemu->DeleteTextures( 1, &crtemu->backbuffer );\n    if( crtemu->vertexbuffer ) crtemu->DeleteBuffers( 1, &crtemu->vertexbuffer );\n\n    #ifndef CRTEMU_SDL\n        if( crtemu->gl_dll ) FreeLibrary( crtemu->gl_dll );\n    #endif\n    CRTEMU_FREE( crtemu->memctx, crtemu );\n    return 0;\n}\n\n\nvoid crtemu_destroy( crtemu_t* crtemu ) {\n    crtemu->DeleteTextures( 1, &crtemu->accumulatetexture_a );\n    crtemu->DeleteFramebuffers( 1, &crtemu->accumulatebuffer_a );\n    crtemu->DeleteTextures( 1, &crtemu->accumulatetexture_b );\n    crtemu->DeleteFramebuffers( 1, &crtemu->accumulatebuffer_b );\n    crtemu->DeleteTextures( 1, &crtemu->blurtexture_a );\n    crtemu->DeleteFramebuffers( 1, &crtemu->blurbuffer_a );\n    crtemu->DeleteTextures( 1, &crtemu->blurtexture_b );\n    crtemu->DeleteFramebuffers( 1, &crtemu->blurbuffer_b );\n    crtemu->DeleteTextures( 1, &crtemu->frametexture );\n    crtemu->DeleteTextures( 1, &crtemu->backbuffer );\n    crtemu->DeleteBuffers( 1, &crtemu->vertexbuffer );\n    #ifndef CRTEMU_SDL\n        FreeLibrary( crtemu->gl_dll );\n    #endif\n    CRTEMU_FREE( crtemu->memctx, crtemu );\n}\n\n\nvoid crtemu_frame( crtemu_t* crtemu, CRTEMU_U32* frame_abgr, int frame_width, int frame_height ) {\n    if( crtemu->type != CRTEMU_TYPE_LITE ) {\n        crtemu->ActiveTexture( CRTEMU_GL_TEXTURE3 );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->frametexture );\n        crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGBA, frame_width, frame_height, 0, CRTEMU_GL_RGBA, CRTEMU_GL_UNSIGNED_BYTE, frame_abgr );\n        if( frame_abgr ) {\n            crtemu->use_frame = 1.0f;\n        } else {\n            crtemu->use_frame = 0.0f;\n        }\n    }\n}\n\n\nstatic void crtemu_internal_blur( crtemu_t* crtemu, CRTEMU_GLuint source, CRTEMU_GLuint blurbuffer_a, CRTEMU_GLuint blurbuffer_b,\n    CRTEMU_GLuint blurtexture_b, float r, int width, int height ) {\n\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, blurbuffer_b );\n    crtemu->UseProgram( crtemu->blur_shader );\n    crtemu->Uniform2f( crtemu->GetUniformLocation( crtemu->blur_shader, \"blur\" ), r / (float) width, 0 );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->blur_shader, \"texture\" ), 0 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, source );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, blurbuffer_a );\n    crtemu->UseProgram( crtemu->blur_shader );\n    crtemu->Uniform2f( crtemu->GetUniformLocation( crtemu->blur_shader, \"blur\" ), 0, r / (float) height );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->blur_shader, \"texture\" ), 0 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, blurtexture_b );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n}\n\n\nvoid crtemu_present( crtemu_t* crtemu, CRTEMU_U64 time_us, CRTEMU_U32 const* pixels_xbgr, int width, int height,\n    CRTEMU_U32 mod_xbgr, CRTEMU_U32 border_xbgr ) {\n\n    int viewport[ 4 ];\n    crtemu->GetIntegerv( CRTEMU_GL_VIEWPORT, viewport );\n    \n    // Copy to backbuffer\n    if( pixels_xbgr ) {\n        crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n        crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGBA, width, height, 0, CRTEMU_GL_RGBA, CRTEMU_GL_UNSIGNED_BYTE, pixels_xbgr );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    } else {\n        if( width != crtemu->last_present_width || height != crtemu->last_present_height ) {\n            crtemu->ActiveTexture( CRTEMU_GL_TEXTURE1 );\n            crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n            crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGB, width, height, 0, CRTEMU_GL_RGB, CRTEMU_GL_UNSIGNED_BYTE, 0 );\n            crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );           \n            crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->fbo_backbuffer );\n            crtemu->FramebufferTexture2D( CRTEMU_GL_FRAMEBUFFER, CRTEMU_GL_COLOR_ATTACHMENT0, CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer, 0 );\n        }\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->fbo_backbuffer );\n        crtemu->Viewport( 0, 0, width, height );\n        crtemu->UseProgram( crtemu->copy_shader );\n        crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->copy_shader, \"tex0\" ), 0 );\n        CRTEMU_GLfloat vertices[] = {\n            -1.0f, -1.0f, 0.0f, 0.0f,\n             1.0f, -1.0f, 1.0f, 0.0f,\n             1.0f,  1.0f, 1.0f, 1.0f,\n            -1.0f,  1.0f, 0.0f, 1.0f,\n        };\n        crtemu->BufferData( CRTEMU_GL_ARRAY_BUFFER, 4 * 4 * sizeof( CRTEMU_GLfloat ), vertices, CRTEMU_GL_STATIC_DRAW );\n        crtemu->BindBuffer( CRTEMU_GL_ARRAY_BUFFER, crtemu->vertexbuffer );\n        crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n        crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n        crtemu->Viewport( viewport[ 0 ], viewport[ 1 ], viewport[ 2 ], viewport[ 3 ] );\n    }\n\n    if( width != crtemu->last_present_width || height != crtemu->last_present_height ) {\n        crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_a );\n        crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGB, width, height, 0, CRTEMU_GL_RGB, CRTEMU_GL_UNSIGNED_BYTE, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->accumulatebuffer_a );\n        crtemu->FramebufferTexture2D( CRTEMU_GL_FRAMEBUFFER, CRTEMU_GL_COLOR_ATTACHMENT0, CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_a, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_b );\n        crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGB, width, height, 0, CRTEMU_GL_RGB, CRTEMU_GL_UNSIGNED_BYTE, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->accumulatebuffer_b );\n        crtemu->FramebufferTexture2D( CRTEMU_GL_FRAMEBUFFER, CRTEMU_GL_COLOR_ATTACHMENT0, CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_b, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_a );\n        crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGB, width, height, 0, CRTEMU_GL_RGB, CRTEMU_GL_UNSIGNED_BYTE, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->blurbuffer_a );\n        crtemu->FramebufferTexture2D( CRTEMU_GL_FRAMEBUFFER, CRTEMU_GL_COLOR_ATTACHMENT0, CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_a, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_b );\n        crtemu->TexImage2D( CRTEMU_GL_TEXTURE_2D, 0, CRTEMU_GL_RGB, width, height, 0, CRTEMU_GL_RGB, CRTEMU_GL_UNSIGNED_BYTE, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->blurbuffer_b );\n        crtemu->FramebufferTexture2D( CRTEMU_GL_FRAMEBUFFER, CRTEMU_GL_COLOR_ATTACHMENT0, CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_b, 0 );\n        crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n    }\n\n\n    crtemu->last_present_width = width;\n    crtemu->last_present_height = height;\n\n    CRTEMU_GLfloat vertices[] = {\n        -1.0f, -1.0f, 0.0f, 0.0f,\n         1.0f, -1.0f, 1.0f, 0.0f,\n         1.0f,  1.0f, 1.0f, 1.0f,\n        -1.0f,  1.0f, 0.0f, 1.0f,\n    };\n    crtemu->BufferData( CRTEMU_GL_ARRAY_BUFFER, 4 * 4 * sizeof( CRTEMU_GLfloat ), vertices, CRTEMU_GL_STATIC_DRAW );\n    crtemu->BindBuffer( CRTEMU_GL_ARRAY_BUFFER, crtemu->vertexbuffer );\n\n    crtemu->Viewport( 0, 0, width, height );\n\n    // Blur the previous accumulation buffer\n    crtemu_internal_blur( crtemu, crtemu->accumulatetexture_b, crtemu->blurbuffer_a, crtemu->blurbuffer_b, crtemu->blurtexture_b, 1.0f, width, height );\n\n    // Update accumulation buffer\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->accumulatebuffer_a );\n    crtemu->UseProgram( crtemu->accumulate_shader );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->accumulate_shader, \"tex0\" ), 0 );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->accumulate_shader, \"tex1\" ), 1 );\n    crtemu->Uniform1f( crtemu->GetUniformLocation( crtemu->accumulate_shader, \"modulate\" ), 1.0f );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE1 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_a );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE1 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n\n    // Store a copy of the accumulation buffer\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->accumulatebuffer_b );\n    crtemu->UseProgram( crtemu->copy_shader );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->copy_shader, \"tex0\" ), 0 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_a );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n    // Blend accumulation and backbuffer\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, crtemu->accumulatebuffer_a );\n    crtemu->UseProgram( crtemu->blend_shader );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->blend_shader, \"tex0\" ), 0 );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->blend_shader, \"tex1\" ), 1 );\n    crtemu->Uniform1f( crtemu->GetUniformLocation( crtemu->blend_shader, \"modulate\" ), 1.0f );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE1 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_b );\n    crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE1 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n\n    // Add slight blur to backbuffer\n    float backbuffer_blur = crtemu->type == CRTEMU_TYPE_TV ? 0.17f : 0.0f;\n    crtemu_internal_blur( crtemu, crtemu->accumulatetexture_a, crtemu->accumulatebuffer_a, crtemu->blurbuffer_b, crtemu->blurtexture_b, backbuffer_blur, width, height );\n\n    // Create fully blurred version of backbuffer\n    crtemu_internal_blur( crtemu, crtemu->accumulatetexture_a, crtemu->blurbuffer_a, crtemu->blurbuffer_b, crtemu->blurtexture_b, 1.0f, width, height );\n\n\n    // Present to screen with CRT shader\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n\n    crtemu->Viewport( viewport[ 0 ], viewport[ 1 ], viewport[ 2 ], viewport[ 3 ] );\n\n    int window_width = viewport[ 2 ] - viewport[ 0 ];\n    int window_height = viewport[ 3 ] - viewport[ 1 ];\n\n    int aspect_width = (int)( ( window_height * 4 ) / 3 );\n    int aspect_height= (int)( ( window_width * 3 ) / 4 );\n    int target_width, target_height;\n    if( aspect_height <= window_height ) {\n        target_width = window_width;\n        target_height = aspect_height;\n    } else {\n        target_width = aspect_width;\n        target_height = window_height;\n    }\n\n    float hscale = target_width / (float) width;\n    float vscale = target_height / (float) height;\n\n    float hborder = ( window_width - hscale * width ) / 2.0f;\n    float vborder = ( window_height - vscale * height ) / 2.0f;\n    float x1 = hborder;\n    float y1 = vborder;\n    float x2 = x1 + hscale * width;\n    float y2 = y1 + vscale * height;\n\n    x1 = ( x1 / window_width ) * 2.0f - 1.0f;\n    x2 = ( x2 / window_width ) * 2.0f - 1.0f;\n    y1 = ( y1 / window_height ) * 2.0f - 1.0f;\n    y2 = ( y2 / window_height ) * 2.0f - 1.0f;\n\n    CRTEMU_GLfloat screen_vertices[] = {\n        0.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, 0.0f, 1.0f, 0.0f,\n        0.0f, 0.0f, 1.0f, 1.0f,\n        0.0f, 0.0f, 0.0f, 1.0f,\n    };\n    screen_vertices[  0 ] = x1;\n    screen_vertices[  1 ] = y1;\n    screen_vertices[  4 ] = x2;\n    screen_vertices[  5 ] = y1;\n    screen_vertices[  8 ] = x2;\n    screen_vertices[  9 ] = y2;\n    screen_vertices[ 12 ] = x1;\n    screen_vertices[ 13 ] = y2;\n\n    crtemu->BindBuffer( CRTEMU_GL_ARRAY_BUFFER, crtemu->vertexbuffer );\n    crtemu->EnableVertexAttribArray( 0 );\n    crtemu->VertexAttribPointer( 0, 4, CRTEMU_GL_FLOAT, CRTEMU_GL_FALSE, 4 * sizeof( CRTEMU_GLfloat ), 0 );\n    crtemu->BufferData( CRTEMU_GL_ARRAY_BUFFER, 4 * 4 * sizeof( CRTEMU_GLfloat ), screen_vertices, CRTEMU_GL_STATIC_DRAW );\n\n    float b = ( ( border_xbgr >> 16 ) & 0xff ) / 255.0f;\n    float g = ( ( border_xbgr >> 8  ) & 0xff ) / 255.0f;\n    float r = ( ( border_xbgr       ) & 0xff ) / 255.0f;\n    crtemu->ClearColor( r, g, b, 1.0f );\n    crtemu->Clear( CRTEMU_GL_COLOR_BUFFER_BIT );\n\n    crtemu->UseProgram( crtemu->crt_shader );\n\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->crt_shader, \"backbuffer\" ), 0 );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->crt_shader, \"blurbuffer\" ), 1 );\n    crtemu->Uniform1i( crtemu->GetUniformLocation( crtemu->crt_shader, \"frametexture\" ), 2 );\n    crtemu->Uniform1f( crtemu->GetUniformLocation( crtemu->crt_shader, \"use_frame\" ), crtemu->use_frame );\n    crtemu->Uniform1f( crtemu->GetUniformLocation( crtemu->crt_shader, \"time\" ), 1.5f * (CRTEMU_GLfloat)( ( (double) time_us ) / 1000000.0 ) );\n    crtemu->Uniform2f( crtemu->GetUniformLocation( crtemu->crt_shader, \"resolution\" ), (float) window_width, (float) window_height );\n    if( crtemu->type == CRTEMU_TYPE_LITE ) {\n        crtemu->Uniform2f( crtemu->GetUniformLocation( crtemu->crt_shader, \"size\" ), (float)( target_width / 2 >= width ? width : target_width / 2 ), (float) ( target_height / 2 >= height ? height : target_height / 2 ) );\n    } else {\n        crtemu->Uniform2f( crtemu->GetUniformLocation( crtemu->crt_shader, \"size\" ), (float) target_width, (float) target_height );\n    }\n\n    float mod_r = ( ( mod_xbgr >> 16 ) & 0xff ) / 255.0f;\n    float mod_g = ( ( mod_xbgr >> 8  ) & 0xff ) / 255.0f;\n    float mod_b = ( ( mod_xbgr       ) & 0xff ) / 255.0f;\n    crtemu->Uniform3f( crtemu->GetUniformLocation( crtemu->crt_shader, \"modulate\" ), mod_r, mod_g, mod_b );\n\n    float color[] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->accumulatetexture_a );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, CRTEMU_GL_CLAMP_TO_BORDER );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, CRTEMU_GL_CLAMP_TO_BORDER );\n    #ifndef CRTEMU_WEBGL\n        crtemu->TexParameterfv( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_BORDER_COLOR, color );\n    #endif\n\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE1 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->blurtexture_a );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, CRTEMU_GL_CLAMP_TO_BORDER );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, CRTEMU_GL_CLAMP_TO_BORDER );\n    #ifndef CRTEMU_WEBGL\n        crtemu->TexParameterfv( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_BORDER_COLOR, color );\n    #endif\n\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE3 );\n    if( crtemu->type == CRTEMU_TYPE_LITE ) {\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->backbuffer );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_NEAREST );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_NEAREST );\n    } else {\n        crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, crtemu->frametexture );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MIN_FILTER, CRTEMU_GL_LINEAR );\n        crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_MAG_FILTER, CRTEMU_GL_LINEAR );\n    }\n\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_S, CRTEMU_GL_CLAMP_TO_BORDER );\n    crtemu->TexParameteri( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_WRAP_T, CRTEMU_GL_CLAMP_TO_BORDER );\n    #ifndef CRTEMU_WEBGL\n        crtemu->TexParameterfv( CRTEMU_GL_TEXTURE_2D, CRTEMU_GL_TEXTURE_BORDER_COLOR, color );\n    #endif\n\n    crtemu->DrawArrays( CRTEMU_GL_TRIANGLE_FAN, 0, 4 );\n\n    crtemu->ActiveTexture( CRTEMU_GL_TEXTURE0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 0 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 1 );\n    crtemu->BindTexture( CRTEMU_GL_TEXTURE_2D, 2 );\n    crtemu->BindFramebuffer( CRTEMU_GL_FRAMEBUFFER, 0 );\n}\n\n\nvoid crtemu_coordinates_window_to_bitmap( crtemu_t* crtemu, int width, int height, int* x, int* y ) {\n    switch( crtemu->type ) {\n        case CRTEMU_TYPE_TV: {\n            CRTEMU_GLint viewport[ 4 ];\n            crtemu->GetIntegerv( CRTEMU_GL_VIEWPORT, viewport );\n\n            int window_width = viewport[ 2 ] - viewport[ 0 ];\n            int window_height = viewport[ 3 ] - viewport[ 1 ];\n\n            int aspect_width = (int)( ( window_height * 4 ) / 3 );\n            int aspect_height= (int)( ( window_width * 3 ) / 4 );\n            int target_width, target_height;\n            if( aspect_height <= window_height ) {\n                target_width = window_width;\n                target_height = aspect_height;\n            } else {\n                target_width = aspect_width;\n                target_height = window_height;\n            }\n\n            float hscale = target_width / (float) width;\n            float vscale = target_height / (float) height;\n\n            float hborder = ( window_width - hscale * width ) / 2.0f;\n            float vborder = ( window_height - vscale * height ) / 2.0f;\n\n            float xp = ( ( *x - hborder ) / hscale ) / (float) width;\n            float yp = ( ( *y - vborder ) / vscale ) / (float) height;\n\n            /* TODO: Common params for shader and this */\n            float xc = ( xp - 0.5f ) * 2.0f;\n            float yc = ( yp - 0.5f ) * 2.0f;\n            xc *= 1.1f;\n            yc *= 1.1f;\n            //xc *= 1.0f + powf( ( fabsf( yc ) / 5.0f ), 2.0f);\n            //yc *= 1.0f + powf( ( fabsf( xc ) / 4.0f ), 2.0f);\n            float yt = ( yc >= 0.0f ? yc : -yc ) / 5.0f;\n            float xt = ( xc >= 0.0f ? xc : -xc ) / 4.0f;\n            xc *= 1.0f + ( yt * yt );\n            yc *= 1.0f + ( xt * xt );\n            xc = ( xc / 2.0f ) + 0.5f;\n            yc = ( yc / 2.0f ) + 0.5f;\n            xc = xc * 0.92f + 0.04f;\n            yc = yc * 0.92f + 0.04f;\n            xp = xc * 0.6f + xp * 0.4f;\n            yp = yc * 0.6f + yp * 0.4f;\n\n            xp = xp * ( 1.0f - 0.04f ) + 0.04f / 2.0f + 0.003f;\n            yp = yp * ( 1.0f - 0.04f ) + 0.04f / 2.0f - 0.001f;\n\n            xp = xp * 1.025f - 0.0125f;\n            yp = yp * 0.92f + 0.04f;\n\n            xp *= width;\n            yp *= height;\n\n            *x = (int) ( xp );\n            *y = (int) ( yp );\n        } break;\n        case CRTEMU_TYPE_PC: {\n            CRTEMU_GLint viewport[ 4 ];\n            crtemu->GetIntegerv( CRTEMU_GL_VIEWPORT, viewport );\n\n            int window_width = viewport[ 2 ] - viewport[ 0 ];\n            int window_height = viewport[ 3 ] - viewport[ 1 ];\n\n            int aspect_width = (int)( ( window_height * 4 ) / 3 );\n            int aspect_height= (int)( ( window_width * 3 ) / 4 );\n            int target_width, target_height;\n            if( aspect_height <= window_height ) {\n                target_width = window_width;\n                target_height = aspect_height;\n            } else {\n                target_width = aspect_width;\n                target_height = window_height;\n            }\n\n            float hscale = target_width / (float) width;\n            float vscale = target_height / (float) height;\n\n            float hborder = ( window_width - hscale * width ) / 2.0f;\n            float vborder = ( window_height - vscale * height ) / 2.0f;\n\n            float xp = ( ( *x - hborder ) / hscale ) / (float) width;\n            float yp = ( ( *y - vborder ) / vscale ) / (float) height;\n\n            /* TODO: Common params for shader and this */\n            float xc = ( xp - 0.5f ) * 2.0f;\n            float yc = ( yp - 0.5f ) * 2.0f;\n            xc *= 1.1f;\n            yc *= 1.1f;\n            //xc *= 1.0f + powf( ( fabsf( yc ) / 5.0f ), 2.0f);\n            //yc *= 1.0f + powf( ( fabsf( xc ) / 4.0f ), 2.0f);\n            float yt = ( yc >= 0.0f ? yc : -yc ) / 5.0f;\n            float xt = ( xc >= 0.0f ? xc : -xc ) / 4.0f;\n            xc *= 1.0f + ( yt * yt );\n            yc *= 1.0f + ( xt * xt );\n            xc = ( xc / 2.0f ) + 0.5f;\n            yc = ( yc / 2.0f ) + 0.5f;\n            xc = xc * 0.92f + 0.04f;\n            yc = yc * 0.92f + 0.04f;\n            xp = xc * 0.2f + xp * 0.8f;\n            yp = yc * 0.2f + yp * 0.8f;\n\n            xp = xp * ( 1.0f - 0.04f ) + 0.04f / 2.0f + 0.003f;\n            yp = yp * ( 1.0f - 0.04f ) + 0.04f / 2.0f - 0.001f;\n\n            xp = xp * 1.156f - ( 0.078f + 0.003f );\n            yp = yp * 1.156f - 0.078f;\n\n            xp *= width;\n            yp *= height;\n\n            *x = (int) ( xp );\n            *y = (int) ( yp );\n        } break;\n        case CRTEMU_TYPE_LITE: {\n            CRTEMU_GLint viewport[ 4 ];\n            crtemu->GetIntegerv( CRTEMU_GL_VIEWPORT, viewport );\n\n            int window_width = viewport[ 2 ] - viewport[ 0 ];\n            int window_height = viewport[ 3 ] - viewport[ 1 ];\n\n            int aspect_width = (int)( ( window_height * 4 ) / 3 );\n            int aspect_height= (int)( ( window_width * 3 ) / 4 );\n            int target_width, target_height;\n            if( aspect_height <= window_height ) {\n                target_width = window_width;\n                target_height = aspect_height;\n            } else {\n                target_width = aspect_width;\n                target_height = window_height;\n            }\n\n            float hscale = target_width / (float) width;\n            float vscale = target_height / (float) height;\n\n            float hborder = ( window_width - hscale * width ) / 2.0f;\n            float vborder = ( window_height - vscale * height ) / 2.0f;\n\n            float xp = ( ( *x - hborder ) / hscale ) / (float) width;\n            float yp = ( ( *y - vborder ) / vscale ) / (float) height;\n\n            xp *= width;\n            yp *= height;\n\n            *x = (int) ( xp );\n            *y = (int) ( yp );\n        } break;\n    }\n}\n\n\n\n#endif /* CRTEMU_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2016 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "cstr.h",
          "type": "blob",
          "size": 83.5556640625,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\ncstr.h - v1.0 - String interning and manipulation library for C/C++.\n\nDo this:\n    #define CSTR_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef cstr_h\n#define cstr_h\n\n#ifndef CSTR_U32\n    #define CSTR_U32 unsigned int\n#endif\n\n#ifndef CSTR_SIZE_T\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stddef.h>\n    #define CSTR_SIZE_T size_t\n#endif\n\n#ifndef CSTR_BOOL_T\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdbool.h>\n    #define CSTR_BOOL_T bool\n#endif\n\n\n#ifndef CSTR_VA_LIST_T\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdarg.h>\n    #define CSTR_VA_LIST_T va_list\n#endif\n\n\n#ifndef CSTR_NO_GLOBAL_API\n\nvoid cstr_reset( void );\n\nstruct cstr_restore_point_t;\nstruct cstr_restore_point_t* cstr_restore_point( void );\nvoid cstr_rollback( struct cstr_restore_point_t* restore_point );\n\nchar const* cstr( char const* str );\nchar const* cstr_n( char const* str, CSTR_SIZE_T n );\n\nCSTR_BOOL_T cstr_is_interned( char const* str );\n\nCSTR_SIZE_T cstr_len( char const* str );\n\nchar const* cstr_cat( char const* a, char const* b );\n\nchar const* cstr_vformat( char const* format, CSTR_VA_LIST_T args );\nchar const* cstr_format( char const* format, ... );\n\nchar const* cstr_trim( char const* str );\nchar const* cstr_ltrim( char const* str );\nchar const* cstr_rtrim( char const* str );\n\nchar const* cstr_left( char const* str, size_t n );\nchar const* cstr_right( char const* str, size_t n );\nchar const* cstr_mid( char const* str, size_t start, size_t n );\n\nchar const* cstr_upper( char const* str );\nchar const* cstr_lower( char const* str );\n\nchar const* cstr_lpad( char const* str, char padding, CSTR_SIZE_T total_max_length );\nchar const* cstr_rpad( char const* str, char padding, CSTR_SIZE_T total_max_length );\n\nchar const* cstr_join( char const* a, char const* b, char const* separator );\n\nchar const* cstr_replace( char const* str, char const* find, char const* replacement );\n\nchar const* cstr_insert( char const* str, int position, char const* insertion );\nchar const* cstr_remove( char const* str, int start, int length );\n\nchar const* cstr_int( int i );\nchar const* cstr_float( float f );\n\nCSTR_BOOL_T cstr_starts( char const* str, char const* start );\nCSTR_BOOL_T cstr_ends( char const* str, char const* end );\n\nCSTR_BOOL_T cstr_is_equal( char const* a, char const* b );\nint cstr_compare( char const* a, char const* b );\nint cstr_compare_nocase( char const* a, char const* b );\n\nint cstr_find( char const* str, char const* find, int start );\nint cstr_rfind( char const* str, char const* find, int start );\n\nCSTR_U32 cstr_hash( char const* str );\n\nstruct cstr_tokenizer_t { void* internal; };\nstruct cstr_tokenizer_t cstr_tokenizer( char const* str );\nchar const* cstr_tokenize( struct cstr_tokenizer_t* tokenizer, char const* separators );\n\nchar* cstr_temp_buffer( size_t capacity );\n\n#endif /* CSTR_NO_GLOBAL_API */\n\n\n#ifdef CSTR_INSTANCE_API\n\nstruct cstri_t;\nstruct cstri_t* cstri_create( void* memctx );\nvoid cstri_destroy( struct cstri_t* cstri );\n\nvoid cstri_reset( struct cstri_t* cstri );\n\nstruct cstr_restore_point_t* cstri_restore_point( struct cstri_t* cstri );\nvoid cstri_rollback( struct cstri_t* cstri, struct cstr_restore_point_t* restore_point );\n\nchar const* cstri( struct cstri_t* cstri, char const* str );\nchar const* cstri_n( struct cstri_t* cstri, char const* str, CSTR_SIZE_T n );\n\nCSTR_BOOL_T cstri_is_interned( struct cstri_t* cstri, char const* str );\n\nCSTR_SIZE_T cstri_len( struct cstri_t* cstri, char const* str );\n\nchar const* cstri_cat( struct cstri_t* cstri, char const* a, char const* b );\n\nchar const* cstri_vformat( struct cstri_t* cstri, char const* format, CSTR_VA_LIST_T args );\nchar const* cstri_format( struct cstri_t* cstri, char const* format, ... );\n\nchar const* cstri_trim( struct cstri_t* cstri, char const* str );\nchar const* cstri_ltrim( struct cstri_t* cstri, char const* str );\nchar const* cstri_rtrim( struct cstri_t* cstri, char const* str );\n\nchar const* cstri_left( struct cstri_t* cstri, char const* str, size_t n );\nchar const* cstri_right( struct cstri_t* cstri, char const* str, size_t n );\nchar const* cstri_mid( struct cstri_t* cstri, char const* str, size_t start, size_t n );\n\nchar const* cstri_upper( struct cstri_t* cstri, char const* str );\nchar const* cstri_lower( struct cstri_t* cstri, char const* str );\n\nchar const* cstri_lpad( struct cstri_t* cstri, char const* str, char padding, CSTR_SIZE_T total_max_length );\nchar const* cstri_rpad( struct cstri_t* cstri, char const* str, char padding, CSTR_SIZE_T total_max_length );\n\nchar const* cstri_join( struct cstri_t* cstri, char const* a, char const* b, char const* separator );\n\nchar const* cstri_replace( struct cstri_t* cstri, char const* str, char const* find, char const* replacement );\n\nchar const* cstri_insert( struct cstri_t* cstri, char const* str, int position, char const* insertion );\nchar const* cstri_remove( struct cstri_t* cstri, char const* str, int start, int length );\n\nchar const* cstri_int( struct cstri_t* cstri, int i );\nchar const* cstri_float( struct cstri_t* cstri, float f );\n\nCSTR_BOOL_T cstri_starts( struct cstri_t* cstri, char const* str, char const* start );\nCSTR_BOOL_T cstri_ends( struct cstri_t* cstri, char const* str, char const* end );\n\nCSTR_BOOL_T cstri_is_equal( struct cstri_t* cstri, char const* a, char const* b );\nint cstri_compare( struct cstri_t* cstri, char const* a, char const* b );\nint cstri_compare_nocase( struct cstri_t* cstri, char const* a, char const* b );\n\nint cstri_find( struct cstri_t* cstri, char const* str, char const* find, int start );\nint cstri_rfind( struct cstri_t* cstri, char const* str, char const* find, int start );\n\nCSTR_U32 cstri_hash( struct cstri_t* cstri, char const* str );\n\nstruct cstr_tokenizer_t cstri_tokenizer( struct cstri_t* cstri, char const* str );\nchar const* cstri_tokenize( struct cstri_t* cstri, struct cstr_tokenizer_t* tokenizer, char const* separators );\n\nchar* cstri_temp_buffer( struct cstri_t* cstri, size_t capacity );\n\n#endif /* CSTR_INSTANCE_API */\n\n\n\n\n#endif /* cstr_h */\n\n\n/**\n\ncstr.h\n======\n\n*/\n\n\n// If we are running tests on windows\n#if defined( CSTR_RUN_TESTS ) && defined( _WIN32 ) && !defined( __TINYC__ )\n    // To get file names/line numbers with meory leak detection, we need to include crtdbg.h before all other files\n    #define _CRTDBG_MAP_ALLOC\n    #include <crtdbg.h>\n#endif\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef CSTR_IMPLEMENTATION\n#undef CSTR_IMPLEMENTATION\n\n#ifndef CSTR_DEFAULT_BLOCK_SIZE \n    #define CSTR_DEFAULT_BLOCK_SIZE 0x400000 /* 4 MB */\n#endif\n\n#ifndef CSTR_MUTEX_LOCK\n    #define CSTR_MUTEX_LOCK() \n    #define CSTR_MUTEX_UNLOCK() \n#endif\n\n#ifndef CSTR_VA_START\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdarg.h>\n    #define CSTR_VA_START va_start\n    #define CSTR_VA_END va_end\n#endif\n\n#ifndef CSTR_ASSERT\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <assert.h>\n    #define CSTR_ASSERT( expression, message ) assert( ( expression ) && ( message ) )\n#endif\n\n#ifndef CSTR_ISSPACE\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <ctype.h>\n    #define CSTR_ISSPACE( c ) ( isspace( c ) )\n#endif \n\n#ifndef CSTR_TOUPPER\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <ctype.h>\n    #define CSTR_TOUPPER( c ) ( toupper( c ) )\n#endif \n\n#ifndef CSTR_TOLOWER\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <ctype.h>\n    #define CSTR_TOLOWER( c ) ( tolower( c ) )\n#endif \n\n#ifndef CSTR_MEMCPY\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define CSTR_MEMCPY( dst, src, cnt ) ( memcpy( (dst), (src), (cnt) ) )\n#endif \n\n#ifndef CSTR_MEMCMP\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define CSTR_MEMCMP( a, b, cnt ) ( memcmp( (a), (b), (cnt) ) )\n#endif \n\n#ifndef CSTR_MEMSET\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define CSTR_MEMSET( ptr, val, cnt ) ( memset( (ptr), (val), (cnt) ) )\n#endif \n\n#ifndef CSTR_STRLEN\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define CSTR_STRLEN( s ) ( strlen( s ) )        \n#endif \n\n#ifndef CSTR_STRSTR\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #define CSTR_STRSTR( s1, s2 ) ( strstr( (s1), (s2) ) )        \n#endif \n\n#ifndef CSTR_STRNICMP\n    #ifdef _WIN32\n        #define _CRT_NONSTDC_NO_DEPRECATE \n        #define _CRT_SECURE_NO_WARNINGS\n        #include <string.h>\n        #define CSTR_STRNICMP( s1, s2, len ) ( strnicmp( (s1), (s2), (len) ) )\n    #else\n        #include <strings.h>\n        #define CSTR_STRNICMP( s1, s2, len ) ( strncasecmp( (s1), (s2), (len) ) )        \n    #endif\n#endif \n\n#ifndef CSTR_VSNPRINTF\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n    #define CSTR_VSNPRINTF( s, n, fmt, args ) ( vsnprintf( (s), (n), (fmt), (args) ) )\n#endif\n\n#ifndef CSTR_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define CSTR_MALLOC( ctx, size ) ( malloc( size ) )\n    #define CSTR_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <stdarg.h>\n\n\n//// instance api\n\nstruct cstr_block_t {\n    char* head;\n    char* tail;\n    char* end;\n};\n\n\nstruct cstr_slot_t {\n    CSTR_U32 hash;\n    CSTR_SIZE_T length;\n    char const* string;\n};\n\n\nstruct cstri_t {\n    void* memctx;\n    CSTR_SIZE_T blocks_count;\n    CSTR_SIZE_T blocks_capacity;\n    struct cstr_block_t* blocks;\n    CSTR_SIZE_T hash_table_count;\n    CSTR_SIZE_T hash_table_capacity;\n    struct cstr_slot_t* hash_table;\n    CSTR_SIZE_T temp_capacity;\n    char* temp_buffer;\n};\n\n\nstatic CSTR_U32 internal_cstr_hash( char const* str, CSTR_SIZE_T length ) {\n\tCSTR_U32 m = 0x5bd1e995u;\n\tCSTR_U32 h = 0x31313137u;\n\twhile( length >= 4 ) {\n\t\tCSTR_U32 k = *(CSTR_U32 *)str;\n\t\tk *= m;\n\t\tk ^= k >> 24;\n\t\tk *= m;\n\t\th *= m;\n\t\th ^= k;\n\t\tstr += 4;\n\t\tlength -= 4;\n\t}\n    switch( length ) {\n        case 3: h ^= str[ 2 ] << 16;\n        case 2: h ^= str[ 1 ] << 8;\n        case 1: h ^= str[ 0 ];\n                h *= m;\n\t}\n\th ^= h >> 13;\n\th *= m;\n\th ^= h >> 15;\n\treturn h;\n}\n\n\nstatic struct cstr_slot_t* internal_cstr_interned( struct cstri_t* cstri, char const* str ) {\n    if( str ) {\n        for( CSTR_SIZE_T i = 0; i < cstri->blocks_count; ++i ) {\n            if( str >= cstri->blocks[ i ].head + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 ) && str < cstri->blocks[ i ].end ) {\n                str -= sizeof( CSTR_U32 );\n                CSTR_U32 hash = *(CSTR_U32*) str;\n                str -= sizeof( CSTR_SIZE_T );\n        \t    size_t slot = ( hash & ( cstri->hash_table_capacity - 1 ) );\n\t            while( cstri->hash_table[ slot ].string ) {\n                    if( cstri->hash_table[ slot ].string == str ) {\n                        return &cstri->hash_table[ slot ];\n                    }\n\t\t            slot = ( slot + 1 ) & ( cstri->hash_table_capacity - 1 );\n\t            }   \n                return NULL;\n            }\n        }\n    }\n    return NULL;\n}\n\n\nstatic struct cstr_slot_t* internal_cstr_find_slot( struct cstri_t* cstri, CSTR_U32 hash, char const* str, CSTR_SIZE_T len ) {\n\tsize_t slot = ( hash & ( cstri->hash_table_capacity - 1 ) );\n\twhile( cstri->hash_table[ slot ].string ) {\n\t\tif( cstri->hash_table[ slot ].hash == hash && cstri->hash_table[ slot ].length == len ) {\n            char const* slot_string = cstri->hash_table[ slot ].string + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 );\n\t\t\tif( CSTR_MEMCMP( slot_string, str, len ) == 0 ) {\n                break;\n\t\t\t}\n\t\t}\n\t\tslot = ( slot + 1 ) & ( cstri->hash_table_capacity - 1 );\n\t}   \n    return &cstri->hash_table[ slot ];\n}\n\n\nstatic char const* internal_cstr_insert( struct cstri_t* cstri, char const* str, CSTR_SIZE_T n ) {\n    struct cstr_slot_t* interned = internal_cstr_interned( cstri, str );\n    if( interned && interned->length == n ) {\n        return interned->string + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 );\n    }\n\n    if( !str ) {\n        str = \"\";\n        n = 0;\n    }\n    CSTR_U32 hash = internal_cstr_hash( str, n );\n    struct cstr_slot_t* slot = internal_cstr_find_slot( cstri, hash, str, n );\n    if( slot->string ) {\n        return slot->string + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 );\n    }\n\n    if( cstri->hash_table_count >= cstri->hash_table_capacity / 3 ) {\n        size_t old_capacity = cstri->hash_table_capacity;\n        struct cstr_slot_t* old_table = cstri->hash_table;\n\n        cstri->hash_table_capacity *= 2;\n\n        cstri->hash_table = (struct cstr_slot_t*) CSTR_MALLOC( cstri->memctx,  \n            cstri->hash_table_capacity * sizeof( *cstri->hash_table ) );\n        CSTR_MEMSET( cstri->hash_table, 0, cstri->hash_table_capacity * sizeof( *cstri->hash_table ) );\n\n        for( size_t i = 0; i < old_capacity; ++i ) {\n            if( old_table[ i ].string ) {\n                CSTR_U32 entry_hash = old_table[ i ].hash;\n                size_t new_slot = ( entry_hash & cstri->hash_table_capacity - 1 );\n                while( cstri->hash_table[ new_slot ].string ) {\n                    new_slot = ( new_slot + 1 ) & ( cstri->hash_table_capacity - 1 );\n                }\n                cstri->hash_table[ new_slot ] = old_table[ i ];\n            }               \n        }\n\n        CSTR_FREE( cstri->memctx, old_table );\n        slot = internal_cstr_find_slot( cstri, hash, str, n );\n    }\n\n    CSTR_SIZE_T alloc_len = ( n + 1 + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 ) + 0xf ) & ~(CSTR_SIZE_T)0xf;\n\n    struct cstr_block_t* block = NULL;\n    if( cstri->blocks_count > 0 ) {\n        struct cstr_block_t* b = &cstri->blocks[ cstri->blocks_count - 1 ];\n        if( (CSTR_SIZE_T)( b->end - b->tail ) >= alloc_len ) {\n            block = b;\n        }\n    }\n    if( !block ) {\n        if( cstri->blocks_count >= cstri->blocks_capacity ) {\n            cstri->blocks_capacity *= 2;\n            void* new_blocks = CSTR_MALLOC( cstri->memctx, cstri->blocks_capacity * sizeof( struct cstr_block_t ) );\n            CSTR_MEMCPY( new_blocks, cstri->blocks, cstri->blocks_count * sizeof( struct cstr_block_t ) );\n            CSTR_FREE( cstri->memctx, cstri->blocks );\n            cstri->blocks = (struct cstr_block_t*) new_blocks;\n        }\n        block = &cstri->blocks[ cstri->blocks_count++ ];\n        CSTR_SIZE_T size = alloc_len <= CSTR_DEFAULT_BLOCK_SIZE ? CSTR_DEFAULT_BLOCK_SIZE : alloc_len;\n        block->head = (char*) CSTR_MALLOC( cstri->memctx, size );\n        block->tail = block->head;\n        block->end = block->head + size;\n    }\n\n    char* item = block->tail;\n    block->tail += alloc_len;\n\n    slot->hash = hash;\n    slot->length = n;\n    slot->string = item;\n    ++cstri->hash_table_count;\n\n    *(CSTR_SIZE_T*)item = n;\n    item += sizeof( CSTR_SIZE_T );\n    *(CSTR_U32*)item = hash;\n    item += sizeof( CSTR_U32 );\n    CSTR_MEMCPY( item, str, n );\n    item[ n ] = '\\0';\n    return item;\n}\n\n\nstatic char* internal_cstr_temp_buffer( struct cstri_t* cstri, size_t capacity ) {\n    if( cstri->temp_capacity <= capacity ) {\n        CSTR_FREE( cstri->memctx, cstri->temp_buffer );\n        while( cstri->temp_capacity <= capacity ) {\n            cstri->temp_capacity *= 2;\n        }\n        cstri->temp_buffer = (char*) CSTR_MALLOC( cstri->memctx, cstri->temp_capacity );\n    }\n    return cstri->temp_buffer;\n}\n\n\nstruct cstri_t* cstri_create( void* memctx ) {\n    struct cstri_t* cstri = (struct cstri_t*) CSTR_MALLOC( memctx, sizeof( struct cstri_t ) );\n    cstri->memctx = memctx;\n    cstri->blocks_count = 0;\n    cstri->blocks_capacity = 16;\n    cstri->blocks = (struct cstr_block_t*) CSTR_MALLOC( memctx, cstri->blocks_capacity * sizeof( *cstri->blocks ) );\n    cstri->hash_table_count = 1024;\n    cstri->hash_table_capacity = 1024;\n    cstri->hash_table = (struct cstr_slot_t*) CSTR_MALLOC( memctx, cstri->hash_table_capacity * sizeof( *cstri->hash_table ) );\n    CSTR_MEMSET( cstri->hash_table, 0, cstri->hash_table_capacity * sizeof( *cstri->hash_table ) );\n    cstri->temp_capacity = 1024;\n    cstri->temp_buffer = (char*) CSTR_MALLOC( memctx, cstri->temp_capacity );\n    return cstri;\n}\n\n\nvoid cstri_destroy( struct cstri_t* cstri ) {\n    CSTR_FREE( cstri->memctx, cstri->temp_buffer );\n    CSTR_FREE( cstri->memctx, cstri->hash_table );\n    for( CSTR_SIZE_T i = 0; i < cstri->blocks_count; ++i ) {\n        CSTR_FREE( cstri->memctx, cstri->blocks[ i ].head );\n    }\n    CSTR_FREE( cstri->memctx, cstri->blocks );\n    CSTR_FREE( cstri->memctx, cstri );\n}\n\n\nvoid cstri_reset( struct cstri_t* cstri ) {\n    for( CSTR_SIZE_T i = 0; i < cstri->blocks_count; ++i ) {\n        CSTR_FREE( cstri->memctx, cstri->blocks[ i ].head );\n    }\n    cstri->blocks_count = 0;\n    CSTR_MEMSET( cstri->hash_table, 0, cstri->hash_table_capacity * sizeof( *cstri->hash_table ) );\n}\n\n\nstruct cstr_restore_point_t* cstri_restore_point( struct cstri_t* cstri ) {\n    return (struct cstr_restore_point_t*)( cstri->blocks_count > 0 ? cstri->blocks[ cstri->blocks_count - 1 ].tail : NULL );\n}\n\n\nvoid cstri_rollback( struct cstri_t* cstri, struct cstr_restore_point_t* restore_point ) {\n    // find the block containing the restore point    \n    CSTR_SIZE_T index = cstri->blocks_count;\n    for( CSTR_SIZE_T i = 0; i < cstri->blocks_count; ++i ) {\n        if( restore_point >= (struct cstr_restore_point_t*)cstri->blocks[ i ].head \n          && restore_point <= (struct cstr_restore_point_t*)cstri->blocks[ i ].tail ) {\n            index = i;\n            break;\n        }\n    }\n\n    // ignore invalid restore points\n    if( index >= cstri->blocks_count ) {\n        return;\n    }\n\n    // remove blocks allocated after restore point\n    cstri->blocks[ index ].tail = (char*)restore_point;\n    for( CSTR_SIZE_T i = index + 1; i < cstri->blocks_count; ++i ) {\n        CSTR_FREE( cstri->memctx, cstri->blocks[ i ].head );\n    }\n    cstri->blocks_count = index + 1;\n\n    // recreate hash table\n    CSTR_MEMSET( cstri->hash_table, 0, cstri->hash_table_capacity * sizeof( *cstri->hash_table ) );\n    for( CSTR_SIZE_T i = 0; i < cstri->blocks_count; ++i ) {\n        struct cstr_block_t* block = &cstri->blocks[ i ];\n        char const* ptr = block->head;\n        while( ptr + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 ) < block->tail ) {\n            CSTR_SIZE_T len = *(CSTR_SIZE_T*)ptr;\n            CSTR_U32 hash = *(CSTR_U32*)( ptr + sizeof( CSTR_SIZE_T ) );\n\n            size_t slot = ( hash & ( cstri->hash_table_capacity - 1 ) );\n\t        while( cstri->hash_table[ slot ].string ) {\n\t\t        slot = ( slot + 1 ) & ( cstri->hash_table_capacity - 1 );\n\t        }   \n            cstri->hash_table[ slot ].hash = hash;\n            cstri->hash_table[ slot ].length = len;\n            cstri->hash_table[ slot ].string = ptr;\n            ptr += ( len + 1 + sizeof( CSTR_SIZE_T ) + sizeof( CSTR_U32 ) + 0xf ) & ~(CSTR_SIZE_T)0xf;\n        }\n    }\n\n}\n\n\nchar const* cstri( struct cstri_t* cstri, char const* str ) {\n    return internal_cstr_insert( cstri, str, str ? CSTR_STRLEN( str ) : 0 );\n}\n\n\nchar const* cstri_n( struct cstri_t* cstri, char const* str, CSTR_SIZE_T n ) {\n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    CSTR_SIZE_T len = 0;\n    while( str[ len ] && len < n ) {\n        ++len;\n    }\n    return internal_cstr_insert( cstri, str, len );\n}\n\n\nCSTR_BOOL_T cstri_is_interned( struct cstri_t* cstri, char const* str ) {\n    if( !str ) return 0;\n    struct cstr_slot_t* slot = internal_cstr_interned( cstri, str );\n    return slot != NULL;\n}\n\n\nCSTR_SIZE_T cstri_len( struct cstri_t* cstri, char const* str ) {\n    if( !str ) return 0;\n    struct cstr_slot_t* slot = internal_cstr_interned( cstri, str );\n    if( slot ) {\n        return slot->length;\n    } else {\n        return CSTR_STRLEN( str );\n    }\n}\n\n\nchar const* cstri_cat( struct cstri_t* cstri, char const* a, char const* b ) {\n    CSTR_SIZE_T len_a = cstri_len( cstri, a );\n    CSTR_SIZE_T len_b = cstri_len( cstri, b );\n    CSTR_SIZE_T len = len_a + len_b;\n    char* temp = internal_cstr_temp_buffer( cstri, len );\n    CSTR_MEMCPY( temp, a, len_a );\n    CSTR_MEMCPY( temp + len_a, b, len_b );\n    return internal_cstr_insert( cstri, temp, len );\n}\n\n\nchar const* cstri_vformat( struct cstri_t* cstri, char const* format, CSTR_VA_LIST_T args ) {\n    if( !format ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n\tint size = CSTR_VSNPRINTF( cstri->temp_buffer, cstri->temp_capacity, format, args );\n    if( size < 0 ) {\n        return NULL;\n    }\n    if( (CSTR_SIZE_T) size >= cstri->temp_capacity ) {\n        internal_cstr_temp_buffer( cstri, size + 1u );\n    \tCSTR_VSNPRINTF( cstri->temp_buffer, cstri->temp_capacity, format, args );\n    }\n    return internal_cstr_insert( cstri, cstri->temp_buffer, (CSTR_SIZE_T)size );\n}\n\n\nchar const* cstri_format( struct cstri_t* cstri, char const* format, ... ) {\n    if( !format ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n\tCSTR_VA_LIST_T args;\n    CSTR_VA_START( args, format );\n    char const* ret = cstri_vformat( cstri, format, args );\n    CSTR_VA_END( args );\n    return ret;\n}\n\n\nchar const* cstri_trim( struct cstri_t* cstri, char const* str ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    char const* start = str;\n    char const* end = str + cstri_len( cstri, str );\n    while( start < end && CSTR_ISSPACE( *start ) ) {\n        ++start;\n    }\n    while( end > start && CSTR_ISSPACE( *( end - 1 ) ) ) {\n        --end;\n    }\n    return internal_cstr_insert( cstri, start, (CSTR_SIZE_T)( end - start ) ); \n}\n\n\nchar const* cstri_ltrim( struct cstri_t* cstri, char const* str ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    char const* start = str;\n    char const* end = str + cstri_len( cstri, str );\n    while( start < end && CSTR_ISSPACE( *start ) ) {\n        ++start;\n    }\n    return internal_cstr_insert( cstri, start, (CSTR_SIZE_T)( end - start ) ); \n}\n\n\nchar const* cstri_rtrim( struct cstri_t* cstri, char const* str ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    char const* start = str;\n    char const* end = str + cstri_len( cstri, str );\n    while( end > start && CSTR_ISSPACE( *( end - 1 ) ) ) {\n        --end;\n    }\n    return internal_cstr_insert( cstri, start, (CSTR_SIZE_T)( end - start ) ); \n}\n\n\nchar const* cstri_left( struct cstri_t* cstri, char const* str, size_t n ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    CSTR_SIZE_T len = cstri_len( cstri, str );\n    if( len <= n ) {\n        return internal_cstr_insert( cstri, str, len );\n    }\n    return internal_cstr_insert( cstri, str, n ); \n}\n\n\nchar const* cstri_right( struct cstri_t* cstri, char const* str, size_t n ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    CSTR_SIZE_T len = cstri_len( cstri, str );\n    if( len <= n ) {\n        return internal_cstr_insert( cstri, str, len );\n    }\n    return internal_cstr_insert( cstri, str + len - n, n ); \n}\n\n\nchar const* cstri_mid( struct cstri_t* cstri, char const* str, size_t start, size_t n ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    CSTR_SIZE_T len = cstri_len( cstri, str );\n    if( len <= start ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    if( len - start <= n || n <= 0 ) {\n        return internal_cstr_insert( cstri, str + start, len - start );\n    }\n    return internal_cstr_insert( cstri, str + start, n ); \n}\n\n\nchar const* cstri_upper( struct cstri_t* cstri, char const* str ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    CSTR_SIZE_T len = cstri_len( cstri, str );\n    char* temp = internal_cstr_temp_buffer( cstri, len );\n    for( CSTR_SIZE_T i = 0; i < len; ++i ) {\n        temp[ i ] = (char) CSTR_TOUPPER( str[ i ] );\n    }\n    return internal_cstr_insert( cstri, temp, len ); \n}\n\n\nchar const* cstri_lower( struct cstri_t* cstri, char const* str ) { \n    if( !str ) {\n        return internal_cstr_insert( cstri, \"\", 0 );\n    }\n    CSTR_SIZE_T len = cstri_len( cstri, str );\n    char* temp = internal_cstr_temp_buffer( cstri, len );\n    for( CSTR_SIZE_T i = 0; i < len; ++i ) {\n        temp[ i ] = (char) CSTR_TOLOWER( str[ i ] );\n    }\n    return internal_cstr_insert( cstri, temp, len ); \n}\n\n#pragma warning( push )\n#pragma warning( disable: 4100 )\n\nchar const* cstri_lpad( struct cstri_t* cstri, char const* str, char padding, CSTR_SIZE_T total_max_length ) {\n    return NULL; // todo \n}\n\n\nchar const* cstri_rpad( struct cstri_t* cstri, char const* str, char padding, CSTR_SIZE_T total_max_length ) {\n    return NULL; // todo \n}\n\n\nchar const* cstri_join( struct cstri_t* cstri, char const* a, char const* b, char const* separator ) {\n    return NULL; // todo \n}\n\n\nchar const* cstri_replace( struct cstri_t* cstri, char const* str, char const* find, char const* replacement ) {\n    return NULL; // todo \n}\n\n\nchar const* cstri_insert( struct cstri_t* cstri, char const* str, int position, char const* insertion ) {\n    return NULL; // todo \n}\n\n\nchar const* cstri_remove( struct cstri_t* cstri, char const* str, int start, int length ) {\n    return NULL; // todo \n}\n\n#pragma warning( pop )\n\nchar const* cstri_int( struct cstri_t* cstri, int i ) { \n    return cstri_format( cstri, \"%d\", i ); \n}\n\n\nchar const* cstri_float( struct cstri_t* cstri, float f ) { \n    return cstri_format( cstri, \"%f\", f ); \n}\n\n\nCSTR_BOOL_T cstri_starts( struct cstri_t* cstri, char const* str, char const* start ) { \n    CSTR_SIZE_T str_len = cstri_len( cstri, str );\n    CSTR_SIZE_T start_len = cstri_len( cstri, start );\n    return str_len >= start_len && CSTR_MEMCMP( str, start, start_len ) == 0;\n}\n\n\nCSTR_BOOL_T cstri_ends( struct cstri_t* cstri, char const* str, char const* end ) { \n    CSTR_SIZE_T str_len = cstri_len( cstri, str );\n    CSTR_SIZE_T end_len = cstri_len( cstri, end );\n    return str_len >= end_len && CSTR_MEMCMP( str + str_len - end_len, end, end_len ) == 0;\n}\n\n\nCSTR_BOOL_T cstri_is_equal( struct cstri_t* cstri, char const* a, char const* b ) {\n    if( a == b ) {\n        return 1;\n    }\n    CSTR_SIZE_T len_a = cstri_len( cstri, a );\n    CSTR_SIZE_T len_b = cstri_len( cstri, b );\n    if( len_a != len_b ) {\n        return 0;\n    }\n    return CSTR_MEMCMP( a, b, len_a ) == 0;\n}\n\n\nint cstri_compare( struct cstri_t* cstri, char const* a, char const* b ) {\n    if( a == b ) {\n        return 0;\n    }\n    CSTR_SIZE_T len_a = cstri_len( cstri, a );\n    CSTR_SIZE_T len_b = cstri_len( cstri, b );\n    CSTR_SIZE_T min_len = len_a < len_b ? len_a : len_b;\n    return CSTR_MEMCMP( a ? a : \"\", b ? b : \"\", min_len + 1 );\n}\n\nint cstri_compare_nocase( struct cstri_t* cstri, char const* a, char const* b ) {\n    if( a == b ) {\n        return 0;\n    }\n    CSTR_SIZE_T len_a = cstri_len( cstri, a );\n    CSTR_SIZE_T len_b = cstri_len( cstri, b );\n    CSTR_SIZE_T min_len = len_a < len_b ? len_a : len_b;\n    return CSTR_STRNICMP( a ? a : \"\", b ? b : \"\", min_len + 1 );\n}\n\n\nint cstri_find( struct cstri_t* cstri, char const* str, char const* find, int start ) { \n    if( !str || !find || start < 0) {\n        return -1;\n    }\n    CSTR_SIZE_T len = cstri_len( cstri, str );\n    if( (CSTR_SIZE_T)start >= len ) {\n        return -1;\n    }\n    char const* res = CSTR_STRSTR( str + start, find );\n    if( !res ) {\n        return -1;\n    }\n    return (int)( res - str );\n}\n\n\nint cstri_rfind( struct cstri_t* cstri, char const* str, char const* find, int start ) { \n    (void) cstri, (void)str, (void)find, (void)start;\n    // todo\n    return -1;\n}\n\n\nCSTR_U32 cstri_hash( struct cstri_t* cstri, char const* str ) {\n    struct cstr_slot_t* slot = internal_cstr_interned( cstri, str );\n    if( slot ) {\n        return slot->hash;\n    } else {\n        return internal_cstr_hash( str ? str : \"\", str ? CSTR_STRLEN( str ) : 0 );\n    }\n}\n\n\nstruct cstr_tokenizer_t cstri_tokenizer( struct cstri_t* cstri, char const* str ) {\n    struct cstr_tokenizer_t tokenizer;\n    tokenizer.internal = (void*)internal_cstr_insert( cstri, str, str ? CSTR_STRLEN( str ) : 0 );\n    return tokenizer;\n}\n\n\nchar const* cstri_tokenize( struct cstri_t* cstri, struct cstr_tokenizer_t* tokenizer, char const* separators ) {\n    CSTR_SIZE_T sep_len = cstr_len( separators );\n    char const* pos = (char const*) tokenizer->internal;\n\n    // strip leading separators\n    while( *pos ) {\n        char ch = *pos;\n        CSTR_BOOL_T is_sep = 0;\n        for( CSTR_SIZE_T i = 0; i < sep_len; ++i ) {\n            if( ch == separators[ i ] ) {\n                is_sep = 1;\n                break;\n            }\n        }\n        if( !is_sep ) break;\n        ++pos;\n    }\n\n    // find next separator\n    char const* token = pos;\n    while( *pos ) {\n        char ch = *pos;\n        CSTR_BOOL_T is_sep = 0;\n        for( CSTR_SIZE_T i = 0; i < sep_len; ++i ) {\n            if( ch == separators[ i ] ) {\n                is_sep = 1;\n                break;\n            }\n        }\n        if( is_sep ) break;\n        ++pos;\n    }\n\n    tokenizer->internal = (void*) pos;\n    \n    // no more tokens?\n    if( *token == '\\0' ) {\n        return NULL;\n    }\n\n    // return the token\n    return internal_cstr_insert( cstri, token, (CSTR_SIZE_T)( pos - token ) );\n}\n\n\nchar* cstri_temp_buffer( struct cstri_t* cstri, size_t capacity ) {\n    return internal_cstr_temp_buffer( cstri, capacity );\n}\n\n\n//// global api\n\n#ifndef CSTR_NO_GLOBAL_API\n\n\nstatic struct cstri_t* g_internal_cstr = NULL;\n\n\nvoid internal_cstr_cleanup( void ) {\n    if( g_internal_cstr ) {\n        cstri_destroy( g_internal_cstr );\n        g_internal_cstr = NULL;\n    }\n}\n\n\nstatic void internal_cstr_instance( void ) {\n    if( !g_internal_cstr ) {\n        g_internal_cstr = cstri_create( NULL );\n        static int atexit_set = 0;\n        if( !atexit_set ) {\n            #ifndef __wasm__\n            atexit( internal_cstr_cleanup );\n            #endif\n            atexit_set = 1;\n        }\n    }\n}\n\n\nvoid cstr_reset( void ) { \n    CSTR_MUTEX_LOCK();\n    internal_cstr_cleanup();\n    CSTR_MUTEX_UNLOCK();\n}\n\n\nstruct cstr_restore_point_t* cstr_restore_point( void ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    struct cstr_restore_point_t* ret = cstri_restore_point( g_internal_cstr );\n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nvoid cstr_rollback( struct cstr_restore_point_t* restore_point ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    cstri_rollback( g_internal_cstr, restore_point );\n    CSTR_MUTEX_UNLOCK();\n}\n\n\nchar const* cstr( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_n( char const* str, CSTR_SIZE_T n ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_n( g_internal_cstr, str, n ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nCSTR_BOOL_T cstr_is_interned( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    CSTR_BOOL_T ret = cstri_is_interned( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nCSTR_SIZE_T cstr_len( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    CSTR_SIZE_T ret = cstri_len( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_cat( char const* a, char const* b ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_cat( g_internal_cstr, a, b ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_vformat( char const* format, CSTR_VA_LIST_T args ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_vformat( g_internal_cstr, format, args ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_format( char const* format, ... ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n\tCSTR_VA_LIST_T args;\n    CSTR_VA_START( args, format );\n    char const* ret = cstri_vformat( g_internal_cstr, format, args ); \n    CSTR_VA_END( args );\n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_trim( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_trim( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_ltrim( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_ltrim( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_rtrim( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_rtrim( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_left( char const* str, size_t n ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_left( g_internal_cstr, str, n ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_right( char const* str, size_t n ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_right( g_internal_cstr, str, n ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_mid( char const* str, size_t start, size_t n ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_mid( g_internal_cstr, str, start, n ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_upper( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_upper( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_lower( char const* str ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_lower( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_lpad( char const* str, char padding, CSTR_SIZE_T total_max_length ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_lpad( g_internal_cstr, str, padding, total_max_length ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_rpad( char const* str, char padding, CSTR_SIZE_T total_max_length ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_rpad( g_internal_cstr, str, padding, total_max_length ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_join( char const* a, char const* b, char const* separator ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_join( g_internal_cstr, a, b, separator ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_replace( char const* str, char const* find, char const* replacement ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_replace( g_internal_cstr, str, find, replacement ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_insert( char const* str, int position, char const* insertion ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_insert( g_internal_cstr, str, position,insertion ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_remove( char const* str, int start, int length ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_remove( g_internal_cstr, str, start, length ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_int( int i ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_int( g_internal_cstr, i ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_float( float f ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_float( g_internal_cstr, f ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nCSTR_BOOL_T cstr_starts( char const* str, char const* start ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    CSTR_BOOL_T ret = cstri_starts( g_internal_cstr, str, start ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nCSTR_BOOL_T cstr_ends( char const* str, char const* end ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    CSTR_BOOL_T ret = cstri_ends( g_internal_cstr, str, end ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nCSTR_BOOL_T cstr_is_equal( char const* a, char const* b ) {\n    if( a == b ) {\n        return 1;\n    }\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    int ret = cstri_is_equal( g_internal_cstr, a, b ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nint cstr_compare( char const* a, char const* b ) {\n    if( a == b ) {\n        return 0;\n    }\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    int ret = cstri_compare( g_internal_cstr, a, b ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nint cstr_compare_nocase( char const* a, char const* b ) {\n    if( a == b ) {\n        return 0;\n    }\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    int ret = cstri_compare_nocase( g_internal_cstr, a, b ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nint cstr_find( char const* str, char const* find, int start ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    int ret = cstri_find( g_internal_cstr, str, find, start ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nint cstr_rfind( char const* str, char const* find, int start ) { \n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    int ret = cstri_rfind( g_internal_cstr, str, find, start ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nCSTR_U32 cstr_hash( char const* str ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    CSTR_U32  ret = cstri_hash( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nstruct cstr_tokenizer_t cstr_tokenizer( char const* str ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    struct cstr_tokenizer_t ret = cstri_tokenizer( g_internal_cstr, str ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar const* cstr_tokenize( struct cstr_tokenizer_t* tokenizer, char const* separators ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char const* ret = cstri_tokenize( g_internal_cstr, tokenizer, separators ); \n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\nchar* cstr_temp_buffer( size_t capacity ) {\n    CSTR_MUTEX_LOCK();\n    if( !g_internal_cstr ) internal_cstr_instance();\n    char* ret = cstri_temp_buffer( g_internal_cstr, capacity );\n    CSTR_MUTEX_UNLOCK();\n    return ret;\n}\n\n\n#endif /* CSTR_NO_GLOBAL_API */\n\n\n#endif /* CSTR_IMPLEMENTATION */\n\n\n/*\n----------------------\n    TESTS\n----------------------\n*/\n\n\n#ifdef CSTR_RUN_TESTS\n\n#include \"testfw.h\"\n\nvoid stress_tests( void ) {\n\n    TESTFW_TEST_BEGIN( \"Create very large (16MB) cstr\" );\n    char* src = (char*) malloc( 16 * 1024 * 1024 + 1);\n    TESTFW_EXPECTED( src != NULL );\n    memset( src, 'A', 16 * 1024 * 1024 );\n    src[ 16 * 1024 * 1024 ] = '\\0';\n    TESTFW_EXPECTED( strlen( src ) == 16 * 1024 * 1024 );\n    char const* str = cstr( src );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != src );\n    TESTFW_EXPECTED( strcmp( str, src ) == 0 );\n    free( src );\n    TESTFW_EXPECTED( strlen( str ) == 16 * 1024 * 1024 );\n    TESTFW_TEST_END();\n\n\n    TESTFW_TEST_BEGIN( \"Create many strings (4M), and use restore points to roll back\" );\n\n    char const** strings = (char const**) malloc( sizeof( char* ) * 4 * 1000 * 1000 );\n    struct cstr_restore_point_t* restore_point_a = NULL;\n    struct cstr_restore_point_t* restore_point_b = NULL;\n    struct cstr_restore_point_t* restore_point_c = NULL;\n    for( CSTR_SIZE_T i = 0; i < 4 * 1000 * 1000; ++i ) {\n        if( i == 1 * 1000 * 1000 ) {\n            restore_point_a = cstr_restore_point();\n        }\n        if( i == 2 * 1000 * 1000 ) {\n            restore_point_b = cstr_restore_point();\n        }\n        if( i == 3 * 1000 * 1000 ) {\n            restore_point_c = cstr_restore_point();\n        }\n        char src[ 64 ];\n        sprintf( src, \"STRING: %x\", (int) i );\n        char const* str = cstr( src );\n        strings[ i ] = str;\n        TESTFW_EXPECTED( str != NULL );\n        TESTFW_EXPECTED( str != src );\n        TESTFW_EXPECTED( strlen( str ) != 0 );\n        TESTFW_EXPECTED( strcmp( str, src ) == 0 );\n    }\n\n    TESTFW_EXPECTED( restore_point_a != NULL );\n    TESTFW_EXPECTED( restore_point_b != NULL );\n    TESTFW_EXPECTED( restore_point_c != NULL );\n\n    for( CSTR_SIZE_T i = 0; i < 4 * 1000 * 1000; ++i ) {\n        TESTFW_EXPECTED( cstr_is_interned( strings[ i ] ) );\n    }\n\n    cstr_rollback( restore_point_c );\n    for( CSTR_SIZE_T i = 0; i < 3 * 1000 * 1000; ++i ) {\n        TESTFW_EXPECTED( cstr_is_interned( strings[ i ] ) );\n    }\n    for( CSTR_SIZE_T i = 3 * 1000 * 1000; i < 4 * 1000 * 1000; ++i ) {\n        TESTFW_EXPECTED( !cstr_is_interned( strings[ i ] ) );\n    }\n\n    // intentionally not rolling back to restore_point_b to test skipping over restore points\n\n    cstr_rollback( restore_point_a );\n    for( CSTR_SIZE_T i = 0; i < 1 * 1000 * 1000; ++i ) {\n        TESTFW_EXPECTED( cstr_is_interned( strings[ i ] ) );\n    }\n    for( CSTR_SIZE_T i = 1 * 1000 * 1000; i < 4 * 1000 * 1000; ++i ) {\n        TESTFW_EXPECTED( !cstr_is_interned( strings[ i ] ) );\n    }\n    free( (char*)strings );\n\n    TESTFW_TEST_END();\n\n\n    cstr_reset();\n}\n\n\nvoid test_cstr( void ) {\n    TESTFW_TEST_BEGIN( \"Create cstr from NULL pointer\" );\n    char const* str = cstr( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from static string\" );\n    char const* str = cstr( \"Static test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != (char*)\"Static test string\" );\n    TESTFW_EXPECTED( strcmp( str, \"Static test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from char array\" );\n    char arr[] = \"Char array string\";\n    char const* str = cstr( arr );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != arr );\n    TESTFW_EXPECTED( strcmp( str, \"Char array string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from cstr\" );\n    char const* src = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( src ) );\n    TESTFW_EXPECTED( src != NULL );\n    TESTFW_EXPECTED( strcmp( src, \"Test string\" ) == 0 );\n    char const* str = cstr( src );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str == src );\n    TESTFW_EXPECTED( strcmp( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_n( void ) {\n    TESTFW_TEST_BEGIN( \"Create cstr from NULL pointer and explicit length\" );\n    char const* str = cstr_n( NULL, 0 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from static string and explicit length\" );\n    char const* str = cstr_n( \"Static test string\", 18 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != (char*)\"Static test string\" );\n    TESTFW_EXPECTED( strcmp( str, \"Static test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from char array and explicit length\" );\n    char arr[] = \"Char array string\";\n    char const* str = cstr_n( arr, 17 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != arr );\n    TESTFW_EXPECTED( strcmp( str, \"Char array string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from cstr and explicit length\" );\n    char const* src = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( src ) );\n    TESTFW_EXPECTED( src != NULL );\n    TESTFW_EXPECTED( strcmp( src, \"Test string\" ) == 0 );\n    char const* str = cstr_n( src, 11 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str == src );\n    TESTFW_EXPECTED( strcmp( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n\n    TESTFW_TEST_BEGIN( \"Create cstr from NULL pointer and too long explicit length\" );\n    char const* str = cstr_n( NULL, 20 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from static string and too long explicit length\" );\n    char const* str = cstr_n( \"Static test string\", 30 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != (char*)\"Static test string\" );\n    TESTFW_EXPECTED( strcmp( str, \"Static test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from char array and too long explicit length\" );\n    char arr[] = \"Char array string\";\n    char const* str = cstr_n( arr, 30 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != arr );\n    TESTFW_EXPECTED( strcmp( str, \"Char array string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from cstr and too long explicit length\" );\n    char const* src = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( src ) );\n    TESTFW_EXPECTED( src != NULL );\n    TESTFW_EXPECTED( strcmp( src, \"Test string\" ) == 0 );\n    char const* str = cstr_n( src, 30 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str == src );\n    TESTFW_EXPECTED( strcmp( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n\n    TESTFW_TEST_BEGIN( \"Create cstr from static string and explicit length shorter than string\" );\n    char const* str = cstr_n( \"Static test string\", 6 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != (char*)\"Static\" );\n    TESTFW_EXPECTED( strcmp( str, \"Static\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from char array and explicit length shorter than string\" );\n    char arr[] = \"Char array string\";\n    char const* str = cstr_n( arr, 4 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != arr );\n    TESTFW_EXPECTED( strcmp( str, \"Char\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Create cstr from cstr and explicit length shorter than string\" );\n    char const* src = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( src ) );\n    TESTFW_EXPECTED( src != NULL );\n    TESTFW_EXPECTED( strcmp( src, \"Test string\" ) == 0 );\n    char const* str = cstr_n( src, 4 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( str != src );\n    TESTFW_EXPECTED( strcmp( str, \"Test\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_len( void ) {\n    TESTFW_TEST_BEGIN( \"Get length of a cstr string\" );\n    char const* str = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( cstr_len( str ) == 11 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Get length of a cstr string containing zero terminator\" );\n    char const* str = cstr_n( \"Test string\\0part2\", 18 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( cstr_len( str ) == 11 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Get length of a string literal\" );\n    TESTFW_EXPECTED( cstr_len( \"Test string\" ) == 11 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Get length of a char array\" );\n    char str[ 18 ] = \"Test string\\0part2\";\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( cstr_len( str ) == 11 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Get length of a cstr created from char array\" );\n    char arr[ 18 ] = \"Test string\\0part2\";\n    char const* str = cstr_n( arr, 18 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( cstr_len( str ) == 11 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Get length of a NULL string\" );\n    TESTFW_EXPECTED( cstr_len( NULL ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_cat( void ) {\n    TESTFW_TEST_BEGIN( \"Concatenate two strings\" );\n    char const* str = cstr_cat( \"Test\", \"String\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"TestString\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Concatenate a string with a NULL string\" );\n    char const* str = cstr_cat( \"Test\", NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"Test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Concatenate a NULL string with a string\" );\n    char const* str = cstr_cat( NULL, \"String\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"String\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Concatenate two NULL strings\" );\n    char const* str = cstr_cat( NULL, NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_format( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_format with a NULL format string\" );\n    char const* str = cstr_format( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_format to format a string\" );\n    char const* str = cstr_format( \"Test format, int: %d, float: %f, str: %s\", 7, 1.0f, \"Test String\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"Test format, int: 7, float: 1.000000, str: Test String\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_trim( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with leading spaces\" );\n    char const* str = cstr_trim( \"   test\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with trailing spaces\" );\n    char const* str = cstr_trim( \"test   \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with leading and trailing spaces\" );\n    char const* str = cstr_trim( \"   test   \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with various whitespace chars\" );\n    char const* str = cstr_trim( \"\\t\\r\\ntest\\t\\r\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with single leading and trailing space\" );\n    char const* str = cstr_trim( \" test \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with no leading or trailing spaces\" );\n    char const* str = cstr_trim( \"test\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with single non-space char\" );\n    char const* str = cstr_trim( \"t\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with single non-space char and single leading space\" );\n    char const* str = cstr_trim( \" t\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with single non-space char and single trailing space\" );\n    char const* str = cstr_trim( \"t \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with single non-space char and single leading and trailing spaces\" );\n    char const* str = cstr_trim( \" t \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with spaces in the middle of the string\" );\n    char const* str = cstr_trim( \"  test test  \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with a string of all spaces\" );\n    char const* str = cstr_trim( \"     \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_trim with a NULL string\" );\n    char const* str = cstr_trim( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_ltrim( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with leading spaces\" );\n    char const* str = cstr_ltrim( \"   test\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with trailing spaces\" );\n    char const* str = cstr_ltrim( \"test   \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test   \" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with leading and trailing spaces\" );\n    char const* str = cstr_ltrim( \"   test   \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test   \" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with various whitespace chars\" );\n    char const* str = cstr_ltrim( \"\\t\\r\\ntest\\t\\r\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\\t\\r\\n\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with single leading and trailing space\" );\n    char const* str = cstr_ltrim( \" test \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test \" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with no leading or trailing spaces\" );\n    char const* str = cstr_ltrim( \"test\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with single non-space char\" );\n    char const* str = cstr_ltrim( \"t\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with single non-space char and single leading space\" );\n    char const* str = cstr_ltrim( \" t\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with single non-space char and single trailing space\" );\n    char const* str = cstr_ltrim( \"t \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t \" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with single non-space char and single leading and trailing spaces\" );\n    char const* str = cstr_ltrim( \" t \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t \" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with spaces in the middle of the string\" );\n    char const* str = cstr_ltrim( \"  test test  \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test test  \" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with a string of all spaces\" );\n    char const* str = cstr_ltrim( \"     \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ltrim with a NULL string\" );\n    char const* str = cstr_ltrim( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_rtrim( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with leading spaces\" );\n    char const* str = cstr_rtrim( \"   test\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"   test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with trailing spaces\" );\n    char const* str = cstr_rtrim( \"test   \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with leading and trailing spaces\" );\n    char const* str = cstr_rtrim( \"   test   \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"   test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with various whitespace chars\" );\n    char const* str = cstr_rtrim( \"\\t\\r\\ntest\\t\\r\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\\t\\r\\ntest\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with single leading and trailing space\" );\n    char const* str = cstr_rtrim( \" test \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \" test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with no leading or trailing spaces\" );\n    char const* str = cstr_rtrim( \"test\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with single non-space char\" );\n    char const* str = cstr_rtrim( \"t\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with single non-space char and single leading space\" );\n    char const* str = cstr_rtrim( \" t\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \" t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with single non-space char and single trailing space\" );\n    char const* str = cstr_rtrim( \"t \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with single non-space char and single leading and trailing spaces\" );\n    char const* str = cstr_rtrim( \" t \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \" t\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with spaces in the middle of the string\" );\n    char const* str = cstr_rtrim( \"  test test  \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"  test test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with a string of all spaces\" );\n    char const* str = cstr_rtrim( \"     \" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_rtrim with a NULL string\" );\n    char const* str = cstr_rtrim( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_left( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_left to get beginning of string\" );\n    char const* str = cstr_left( \"Test string\", 4 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"Test\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_left with length beyond end of string\" );\n    char const* str = cstr_left( \"Test string\", 20 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_left with NULL string\" );\n    char const* str = cstr_left( NULL, 4 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_right( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_right to get end of string\" );\n    char const* str = cstr_right( \"Test string\", 6 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_right with length beyond start of string\" );\n    char const* str = cstr_right( \"Test string\", 20 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_right with NULL string\" );\n    char const* str = cstr_right( NULL, 6 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_mid( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_mid to get middle of string\" );\n    char const* str = cstr_mid( \"Test string\", 2, 5 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"st st\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_mid with length beyond end of string\" );\n    char const* str = cstr_mid( \"Test string\", 2, 20 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"st string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_mid with start beyond end of string\" );\n    char const* str = cstr_mid( \"Test string\", 20, 5 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_mid on NULL string\" );\n    char const* str = cstr_mid( NULL, 2, 5 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_upper( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_upper with mixed case string\" );\n    char const* str = cstr_upper( \"Test String\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"TEST STRING\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_upper with uppercase string\" );\n    char const* str = cstr_upper( \"TEST STRING\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"TEST STRING\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_upper with lowercase string\" );\n    char const* str = cstr_upper( \"test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"TEST STRING\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_upper with NULL string\" );\n    char const* str = cstr_upper( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_lower( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_lower with mixed case string\" );\n    char const* str = cstr_lower( \"Test String\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_lower with uppercase string\" );\n    char const* str = cstr_lower( \"TEST STRING\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_lower with lowercase string\" );\n    char const* str = cstr_lower( \"test string\" );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_lower with NULL string\" );\n    char const* str = cstr_lower( NULL );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_int( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_int with a positive number\" );\n    char const* str = cstr_int( 42 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"42\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_int with a negative number\" );\n    char const* str = cstr_int( -100 );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"-100\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_int with a large number\" );\n    char const* str = cstr_int( 2147483647  );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"2147483647\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n    \nvoid test_cstr_float( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_float\" );\n    char const* str = cstr_float( 42.0f );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"42.000000\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_int with a small number\" );\n    char const* str = cstr_float( 42.43e-6f );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"0.000042\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_int with a really small number\" );\n    char const* str = cstr_float( 42.43e-25f );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"0.000000\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_int with a really large number\" );\n    char const* str = cstr_float( 42e15f );\n    TESTFW_EXPECTED( cstr_is_interned( str ) );\n    TESTFW_EXPECTED( str != NULL );\n    TESTFW_EXPECTED( strcmp( str, \"41999999856279552.000000\" ) == 0 );\n    TESTFW_TEST_END();\n}\n\n    \nvoid test_cstr_starts( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with matching substring\" );\n    TESTFW_EXPECTED( cstr_starts( \"TestString\", \"Test\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with non-matching substring\" );\n    TESTFW_EXPECTED( cstr_starts( \"Test\", \"TestString\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with identical strings\" );\n    TESTFW_EXPECTED( cstr_starts( \"Test\", \"Test\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with first string empty\" );\n    TESTFW_EXPECTED( cstr_starts( \"\", \"Test\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with second string empty\" );\n    TESTFW_EXPECTED( cstr_starts( \"Test\", \"\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with two empty strings\" );\n    TESTFW_EXPECTED( cstr_starts( \"\", \"\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with single char second string\" );\n    TESTFW_EXPECTED( cstr_starts( \"TestString\", \"T\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with second string NULL\" );\n    TESTFW_EXPECTED( cstr_starts( \"TestString\", NULL ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with first string NULL\" );\n    TESTFW_EXPECTED( cstr_starts( NULL, \"TestString\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_starts with both strings NULL\" );\n    TESTFW_EXPECTED( cstr_starts( NULL, NULL ) == true );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_ends( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with matching substring\" );\n    TESTFW_EXPECTED( cstr_ends( \"TestString\", \"String\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with non-matching substring\" );\n    TESTFW_EXPECTED( cstr_ends( \"String\", \"TestString\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with identical strings\" );\n    TESTFW_EXPECTED( cstr_ends( \"Test\", \"Test\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with first string empty\" );\n    TESTFW_EXPECTED( cstr_ends( \"\", \"String\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with second string empty\" );\n    TESTFW_EXPECTED( cstr_ends( \"String\", \"\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with two empty strings\" );\n    TESTFW_EXPECTED( cstr_ends( \"\", \"\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with single char second string\" );\n    TESTFW_EXPECTED( cstr_ends( \"TestString\", \"g\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with second string NULL\" );\n    TESTFW_EXPECTED( cstr_ends( \"TestString\", NULL ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with first string NULL\" );\n    TESTFW_EXPECTED( cstr_ends( NULL, \"TestString\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_ends with both strings NULL\" );\n    TESTFW_EXPECTED( cstr_ends( NULL, NULL ) == true );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_is_equal( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with two NULL strings\" );\n    TESTFW_EXPECTED( cstr_is_equal( NULL, NULL ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with a NULL string and an empty string\" );\n    TESTFW_EXPECTED( cstr_is_equal( NULL, \"\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with two string literals\" );\n    TESTFW_EXPECTED( cstr_is_equal( \"Test string\", \"Test string\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with two cstr strings\" );\n    char const* a = cstr( \"Test string\" );\n    char const* b = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_equal( a, b ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with a string literal and a cstr string\" );\n    char const* str = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_is_equal( str, \"Test string\" ) == true );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with two different string literals\" );\n    TESTFW_EXPECTED( cstr_is_equal( \"Test string A\", \"Test string B\" ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with two different cstr strings\" );\n    char const* a = cstr( \"Test string A\" );\n    char const* b = cstr( \"Test string B\" );\n    TESTFW_EXPECTED( cstr_is_equal( a, b ) == false );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_is_equal with a string literal and a different cstr string\" );\n    char const* str = cstr( \"Test string A\" );\n    TESTFW_EXPECTED( cstr_is_equal( str, \"Test string B\" ) == false );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_compare( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with two NULL strings\" );\n    TESTFW_EXPECTED( cstr_compare( NULL, NULL ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with a NULL string and an empty string\" );\n    TESTFW_EXPECTED( cstr_compare( NULL, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with two string literals\" );\n    TESTFW_EXPECTED( cstr_compare( \"Test string\", \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with two cstr strings\" );\n    char const* a = cstr( \"Test string\" );\n    char const* b = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_compare( a, b ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with a string literal and a cstr string\" );\n    char const* str = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_compare( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with two different string literals\" );\n    TESTFW_EXPECTED( cstr_compare( \"Test string A\", \"Test string B\" ) < 0 );\n    TESTFW_EXPECTED( cstr_compare( \"Test string B\", \"Test string A\" ) > 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare with two different cstr strings\" );\n    char const* a = cstr( \"Test string A\" );\n    char const* b = cstr( \"Test string B\" );\n    TESTFW_EXPECTED( cstr_compare( a, b ) < 0 );\n    TESTFW_EXPECTED( cstr_compare( b, a ) > 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_compare_nocase( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two NULL strings\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( NULL, NULL ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with a NULL string and an empty string\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( NULL, \"\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two string literals\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( \"Test string\", \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two cstr strings\" );\n    char const* a = cstr( \"Test string\" );\n    char const* b = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( a, b ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with a string literal and a cstr string\" );\n    char const* str = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( str, \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two different string literals\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( \"Test string A\", \"Test string B\" ) < 0 );\n    TESTFW_EXPECTED( cstr_compare_nocase( \"Test string B\", \"Test string A\" ) > 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two different cstr strings\" );\n    char const* a = cstr( \"Test string A\" );\n    char const* b = cstr( \"Test string B\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( a, b ) < 0 );\n    TESTFW_EXPECTED( cstr_compare_nocase( b, a ) > 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two string literals differing only by case\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( \"TEST STRING\", \"Test string\" ) == 0 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_compare_nocase with two cstr strings differing only by case\" );\n    char const* a = cstr( \"TEST STRING\" );\n    char const* b = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_compare_nocase( a, b ) == 0 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_find( void ) {\n\n}\n\n\nvoid test_cstr_hash( void ) {\n    TESTFW_TEST_BEGIN( \"Use cstr_hash with NULL string\" );\n    TESTFW_EXPECTED( cstr_hash( NULL ) == 0x569ed9aa );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_hash with empty string\" );\n    TESTFW_EXPECTED( cstr_hash( NULL ) == 0x569ed9aa );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_hash with string literal\" );\n    TESTFW_EXPECTED( cstr_hash( \"Test string\" ) == 0x5b8cc1a9 );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Use cstr_hash with cstr string\" );\n    char const* str = cstr( \"Test string\" );\n    TESTFW_EXPECTED( cstr_hash( str ) == 0x5b8cc1a9 );\n    TESTFW_TEST_END();\n}\n\n\nvoid test_cstr_tokenize( void ) {\n    TESTFW_TEST_BEGIN( \"Can tokenize sample string\" );\n    \n    struct cstr_tokenizer_t tokenizer = cstr_tokenizer( \"A string\\tof ,,tokens\\nand some  more tokens    \" );\n    TESTFW_EXPECTED( tokenizer.internal != NULL );\n    \n    char const* token1 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token1 ) );\n    TESTFW_EXPECTED( token1 != NULL );\n    TESTFW_EXPECTED( strcmp( token1, \"A\" ) == 0 );\n    \n    char const* token2 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token2 ) );\n    TESTFW_EXPECTED( token2 != NULL );\n    TESTFW_EXPECTED( strcmp( token2, \"string\" ) == 0 );\n    \n    char const* token3 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token3 ) );\n    TESTFW_EXPECTED( token3 != NULL );\n    TESTFW_EXPECTED( strcmp( token3, \"of\" ) == 0 );\n    \n    char const* token4 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token4 ) );\n    TESTFW_EXPECTED( token4 != NULL );\n    TESTFW_EXPECTED( strcmp( token4, \"tokens\" ) == 0 );\n    \n    char const* token5 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token5 ) );\n    TESTFW_EXPECTED( token5 != NULL );\n    TESTFW_EXPECTED( strcmp( token5, \"and\" ) == 0 );\n    \n    char const* token6 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token6 ) );\n    TESTFW_EXPECTED( token6 != NULL );\n    TESTFW_EXPECTED( strcmp( token6, \"some\" ) == 0 );\n    \n    char const* token7 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token7 ) );\n    TESTFW_EXPECTED( token7 != NULL );\n    TESTFW_EXPECTED( strcmp( token7, \"more\" ) == 0 );\n    \n    char const* token8 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( cstr_is_interned( token8 ) );\n    TESTFW_EXPECTED( token8 != NULL );\n    TESTFW_EXPECTED( strcmp( token8, \"tokens\" ) == 0 );\n    \n    char const* token9 = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( token9 == NULL );\n\n    TESTFW_TEST_END();\n\n\n    TESTFW_TEST_BEGIN( \"Can tokenize string containing only separators\" );  \n    struct cstr_tokenizer_t tokenizer = cstr_tokenizer( \" \\t ,,\\n   \" );\n    TESTFW_EXPECTED( tokenizer.internal != NULL );    \n    char const* token = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( token == NULL );\n    TESTFW_TEST_END();\n\n    TESTFW_TEST_BEGIN( \"Can tokenize NULL string\" );  \n    struct cstr_tokenizer_t tokenizer = cstr_tokenizer( NULL );\n    TESTFW_EXPECTED( tokenizer.internal != NULL );    \n    char const* token = cstr_tokenize( &tokenizer, \" ,\\t\\n\" );\n    TESTFW_EXPECTED( token == NULL );\n    TESTFW_TEST_END();\n}\n\n\nint main( int argc, char** argv ) {\n    (void) argc, argv;\n\n    TESTFW_INIT();\n    \n    test_cstr();\n    test_cstr_n();\n    test_cstr_len();\n    test_cstr_cat();\n    test_cstr_format();\n    test_cstr_trim();\n    test_cstr_ltrim();\n    test_cstr_rtrim();\n    test_cstr_left();\n    test_cstr_right();\n    test_cstr_mid();\n    test_cstr_upper();\n    test_cstr_lower();\n    test_cstr_int();\n    test_cstr_float();\n    test_cstr_starts();\n    test_cstr_ends();\n    test_cstr_is_equal();\n    test_cstr_compare();\n    test_cstr_compare_nocase();\n    test_cstr_find();\n    test_cstr_hash();\n    test_cstr_tokenize();\n    stress_tests();\n\n    cstr_reset();\n    return TESTFW_SUMMARY();\n}\n\n\n// pass-through so the program will build with either /SUBSYSTEM:WINDOWS or /SUBSYSTEM:CONSOLE\n#if defined( _WIN32 ) && !defined( __TINYC__ )\n    #ifdef __cplusplus \n        extern \"C\" int __stdcall WinMain( struct HINSTANCE__*, struct HINSTANCE__*, char*, int ) { \n            return main( __argc, __argv ); \n        }\n    #else\n        struct HINSTANCE__;\n        int __stdcall WinMain( struct HINSTANCE__* a, struct HINSTANCE__* b, char* c, int d ) { \n            (void) a, b, c, d; return main( __argc, __argv ); \n        }\n    #endif\n#endif\n\n#define TESTFW_IMPLEMENTATION\n#include \"testfw.h\"\n\n#endif /* CSTR_RUN_TESTS */\n\n\n/*\nrevision history:\n    1.0     first released version  \n*/\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2022 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "dialog.h",
          "type": "blob",
          "size": 40.0693359375,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\ndialog.h - v0.1 - Loading and management of dialog definitions.\n\nThis library provides functionality to load and manage dialogs written in a \ncustom markup language designed for simplicity and readability.\n\nThe dialog definition files contain any number of \"conversations\". Each\nconversation is made up of any number of entries. An entry can be any of the\nfollowing: a line of speech, an option, a redirect command, or an event \ncommand.\n\nA conversation is defined by giving it an ID within square brackets ( [, ] ).\nTwo conversation IDs should be considered reserved: EXIT and RETURN. The \nfirst of these means that the dialog is over for now and should be stopped,\nand the second means to return to the conversation from which we came (if \nthere is no conversation to return to, the dialog should be stopped).\n\nA line of speech consists of an actor name within angled brackets ( <, > ) \nfollowed by the actual ine.\n\nAn option (as may be selected by a player) starts with the character ^. If it\nstarts with two of that character, ^^, it means that the option is persistent\nand thus shall not be removed (the normal behaviour is that options are \nremoved from the list after being chosen once). After the ^ or ^^ is the line\nwhich will be spoken if the option is chosen. Last, the line has the \ncharacter @ followed by the ID of the conversation to jump to should that \noption be chosen.\n\nA redirect command is simply the @ character followed by the ID of the \nconversation to jump to when execution reaches this command.\n\nFinally, an event command is any string surrounded by # characters. This can\nbe used to send a custom message to the game engine, to signal that something\nshould happen.\n\nHere follows an example dialog file from \"The Strangler\":\n\n\t[TalkToBambi]\n\t^ Sorry to *bother* you, ma'am. I need to ask you some *questions*. @YouAcop\n\t^ Well well well... ain't you a *classy* one. @Classy\n\t^ Excuse me, do you know a woman by the name of Amber? @Amber\n\t^^ I don't have any more questions right now. @EXIT\n\n\t[YouAcop]\n\t<Bambi> You a *cop* or something? Fuck off.\n\t<O'Reilly> *Believe* me, I hate those *bastards* just as much as you do.\n\t@RETURN\n\n\t[Classy]\n\t<Bambi> Errr.. No *offense*, pal, but you're not exactly one to *talk*.\n\t@RETURN\n\n\t[Amber]\n\t<Bambi> I knew Amber. But Amber is *dead*. \n\t@RETURN\n\n\t[ShowPicture]\n\t<O'Reilly> Have you seen this man around?\n\t<Bambi> Yeah, I've seen him with some of the *girls*.\n\t<O'Reilly> Did you see him with Amber last night?\n\t<Bambi> I *did*, now that you *mention* it...\n\t<O'Reilly> Any idea where he might have taken her?\n\t<Bambi> Probably to this *motel*... that's where he'd usually go....\t\n\t#UnlockMotel#\n\n*/\n\n#ifndef dialog_h\n#define dialog_h\n\ntypedef struct dialog_t dialog_t;\n\ndialog_t* dialog_create( char const* input, int input_size );\nvoid dialog_destroy( dialog_t* dialog );\n\nint dialog_save( dialog_t const* dialog, void* data, int capacity );\ndialog_t* dialog_load( void const* data, int size );\nvoid dialog_unload( dialog_t* dialog );\n\ntypedef struct dialog_conversation_t { int handle; } dialog_conversation_t;\ntypedef struct dialog_entry_t { int handle; } dialog_entry_t;\ntypedef struct dialog_line_t { int handle; } dialog_line_t;\ntypedef struct dialog_option_t { int handle; } dialog_option_t;\ntypedef struct dialog_redirect_t { int handle; } dialog_redirect_t;\ntypedef struct dialog_event_t { int handle; } dialog_event_t;\n\ntypedef enum dialog_entry_type_t { \n    DIALOG_ENTRY_TYPE_INVALID = -1,\n    DIALOG_ENTRY_TYPE_LINE, \n    DIALOG_ENTRY_TYPE_OPTION, \n    DIALOG_ENTRY_TYPE_REDIRECT, \n    DIALOG_ENTRY_TYPE_EVENT,\n} dialog_entry_type_t;\n\nint dialog_find_conversation( dialog_t const* dialog, char const* id );\n\nint dialog_conversation_count( dialog_t const* dialog );\ndialog_conversation_t dialog_conversation( dialog_t const* dialog, int index );\n\nchar const* dialog_conversation_id( dialog_t const* dialog, dialog_conversation_t conversation );\nint dialog_conversation_entry_count( dialog_t const* dialog, dialog_conversation_t conversation );\ndialog_entry_t dialog_conversation_entry( dialog_t const* dialog, dialog_conversation_t conversation, int index );\n\nchar const* dialog_entry_id( dialog_t const* dialog, dialog_entry_t entry );\ndialog_entry_type_t dialog_entry_type( dialog_t const* dialog, dialog_entry_t entry );\ndialog_line_t dialog_entry_line( dialog_t const* dialog, dialog_entry_t entry );\ndialog_option_t dialog_entry_option( dialog_t const* dialog, dialog_entry_t entry );\ndialog_redirect_t dialog_entry_redirect( dialog_t const* dialog, dialog_entry_t entry );\ndialog_event_t dialog_entry_event( dialog_t const* dialog, dialog_entry_t entry );\n\nchar const* dialog_line_actor( dialog_t const* dialog, dialog_line_t line );\nchar const* dialog_line_text( dialog_t const* dialog, dialog_line_t line );\n\nchar const* dialog_option_text( dialog_t const* dialog, dialog_option_t option );\nchar const* dialog_option_target( dialog_t const* dialog, dialog_option_t option );\nint dialog_option_is_persistent( dialog_t const* dialog, dialog_option_t option );\n\nchar const* dialog_redirect_target( dialog_t const* dialog, dialog_redirect_t redirect );\n\nchar const* dialog_event_event( dialog_t const* dialog, dialog_event_t event );\n\n\n#endif /* dialog_h */\n\n\n/*\nvoid test_dialog( dialog_t* dialog ) {\n    for( int i = 0; i < dialog_conversation_count( dialog ); ++i ) {\n        dialog_conversation_t conversation = dialog_conversation( dialog, i );\n        printf( \"\\n[%s]\\n\", dialog_conversation_id( dialog, conversation ) );      \n        for( int j = 0; j < dialog_conversation_entry_count( dialog, conversation ); ++j ) {\n            dialog_entry_t entry = dialog_conversation_entry( dialog, conversation, j );\n            dialog_entry_type_t type = dialog_entry_type( dialog, entry );\n            char const* id = dialog_entry_id( dialog, entry );\n            if( id ) {\n                printf( \"{%s}\", id );\n            }\n\n            if( type == DIALOG_ENTRY_TYPE_LINE ) {\n                dialog_line_t line = dialog_entry_line( dialog, entry );\n                printf(\"<%s>%s\", dialog_line_actor( dialog, line ), dialog_line_text( dialog, line ) );\n            } else if( type == DIALOG_ENTRY_TYPE_OPTION ) {\n                dialog_option_t option = dialog_entry_option( dialog, entry );\n                if( dialog_option_is_persistent( dialog, option ) ) {\n                    printf( \"^\" );\n                }\n                printf(\"^%s@%s\", dialog_option_text( dialog, option ), dialog_option_target( dialog, option ) );\n            } else if( type == DIALOG_ENTRY_TYPE_REDIRECT ) {\n                dialog_redirect_t redirect = dialog_entry_redirect( dialog, entry );\n                printf(\"@%s\", dialog_redirect_target( dialog, redirect ) );\n            } else if( type == DIALOG_ENTRY_TYPE_EVENT ) {\n                dialog_event_t event = dialog_entry_event( dialog, entry );\n                printf(\"#%s#\", dialog_event_event( dialog, event ) );\n            }\n            printf( \"|\\n\" );\n        }\n    }\n}\n*/\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n\n#ifdef DIALOG_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#define wait PIXIE_STD_WAIT /* osx defines a conflicting \"wait\" */\n#include <stdlib.h>\n#undef wait\n#include <string.h>\n\n\ntypedef struct dialog_parse_line_t {\n\tchar* actor;\n    char* text;\n} dialog_parse_line_t;\n\n\ntypedef struct dialog_parse_option_t {\n\tchar* text;\n    char* target;\n    int is_persistant;\n} dialog_parse_option_t;\n\n\ntypedef struct dialog_parse_redirect_t {\n\tchar* target;\n} dialog_parse_redirect_t;\n\n\ntypedef struct dialog_parse_event_t {\n\tchar* event;\n} dialog_parse_event_t;\n\n\ntypedef struct dialog_parse_entry_t {\n\tchar* id; // TODO: change this to \"condition\",  which should work similar to events - the player will be in a \"waiting for condition\" state, and once it gets the result, either do the line or not\n    dialog_entry_type_t type;\n    union {\n\t    struct dialog_parse_line_t line; \n\t    struct dialog_parse_option_t option;\n\t    struct dialog_parse_redirect_t redirect;\n\t    struct dialog_parse_event_t event;\n    } data;\n} dialog_parse_entry_t;\n\n\ntypedef struct dialog_parse_convo_t {\n    char* id;\n    int entries_count;\n    int entries_capacity;\n    dialog_parse_entry_t* entries;\n} dialog_parse_convo_t;\n\n\ntypedef struct dialog_parse_t {\n    int conversations_count;\n    int conversations_capacity;\n    dialog_parse_convo_t* conversations;\n} dialog_parse_t;\n\n\nint dialog_parse_line( dialog_parse_line_t* parse, char const* start, char const* end ) {\n\t// A Line is defined like this:\n\t//     <ActorName>LineText\n\n\t// If the row doesn't start with '<', it's not a valid line\n\tif( *start != '<' ) return 0;\n\t++start; // Skip leading bracket\n\t\t    \n\t// Find end bracket\n\tchar const* actor_end = start;\n\twhile( *actor_end != '>' && actor_end < end ) ++actor_end;\n\n\t// If there's no ending '>', it's not a valid line\n\tif( (*actor_end) != '>' ) return 0;\n\n    // Store actor name\n\tparse->actor = (char*) malloc( (size_t)( actor_end - start + 1 ) );\n    strncpy( parse->actor, start, (size_t)( actor_end - start ) );\n    parse->actor[ actor_end - start ] = '\\0';\n\t\t    \n\t// Parse line text\n\tstart = actor_end + 1; // Skip past the ending bracket of the actor name    \n\twhile( start < end && *start <= ' ' ) ++start; // Skip leading whitespace\n\n    // Store line text\n\tparse->text = (char*) malloc( (size_t)( end - start + 1 ) );\n    strncpy( parse->text, start, (size_t)( end - start ) );\n    parse->text[ end - start ] = '\\0';\n\n    // Respect escape codes for line breaks\n\tchar* str = parse->text;\n    char* out = parse->text;\n\twhile( *str ) {\n\t\tif( *str == '\\\\' && *( str + 1 ) == 'n' ) {\n\t\t\t*out++ = '\\n';\n\t\t\tstr += 2;\n\t\t} else {\n            *out++ = *str++;\n        }\n\t}\n\t\t    \n\t// If we don't have both a valid actor and a valid line, this row is invalid\n\tif( !parse->actor || *parse->actor == '\\0' || !parse->text || *parse->text == '\\0' ) {\n        if( parse->actor ) free( parse->actor );\n        if( parse->text ) free( parse->text );\n        parse->actor = NULL;\n        parse->text = NULL;\n        return 0;\n    }\n\n\t// This is a valid row\n\treturn 1;\n}\n\n\nint dialog_parse_option( dialog_parse_option_t* parse, char const* start, char const* end ) {\n\t// An Option is defined like this:\n\t//     ^OptionText@TargetId\n\t//\n\t// Or, for a persistent option:\n\t//     ^^OptionText@TargetId\n\n\t// If the row doesn't start with '^', it's not a valid option\n\tif( *start != '^' ) return 0;\n\t++start; // Skip leading '^'\n\n\t// If the second character is also '^', this is a persistent option\n\tif( *start == '^' ) { \n        parse->is_persistant = 1; \n        ++start; // Skip second '^'\n    } \n\telse {\n        parse->is_persistant = 0; // This is not a persistent option\n    }\n\n\t// Skip leading whitespace\n\twhile( start < end && *start <= ' ' ) ++start;\n\t\t\t\n\t// If the rest of the row is empty, it is not a valid option\n\tif( start == end ) return 0;\n\n\t// Find the '@' character\n\tchar const* target = start;\n\twhile( *target != '@' && target < end ) ++target;\n\n\t// If there isn't an '@' character, this is not a valid option\n\tif( *target != '@' ) return 0;\n\t\t    \n\t// Trim trailing whitespace\n\tchar const* trim = target - 1;\n\twhile( trim > start && *trim <= ' ' ) --trim;\n\n    // Store option text\n\tparse->text = (char*) malloc( (size_t)( trim - start + 1 ) );\n    strncpy( parse->text, start, (size_t)( trim - start ) );\n    parse->text[ trim - start ] = '\\0';\n\t\t    \n\t// Parse target id\n\t++target; // Skip the '@' character\n\t\t\t\n\t// Skip leading whitespace\n\twhile( target < end && *target <= ' ' ) ++target;\n\t\t    \n\t// Store target id\n\tparse->target = (char*) malloc( (size_t)( end - target + 1 ) );\n    strncpy( parse->target, target, (size_t)( end - target ) );\n    parse->target[ end - target ] = '\\0';\n\t\t    \n\t// If option text or target id are empty, this is not a valid option\n\t// If we don't have both a valid actor and a valid line, this row is invalid\n\tif( !parse->text || *parse->text == '\\0' || !parse->target || *parse->target == '\\0' ) {\n        if( parse->text ) free( parse->text );\n        if( parse->target ) free( parse->target );\n        parse->text = NULL;\n        parse->target = NULL;\n        return 0;\n    }\n\n\treturn 1;\n}\n\n\nint dialog_parse_redirect( dialog_parse_redirect_t* parse, char const* start, char const* end ) {\n\t// A Redirect is defined like this:\n\t//     @TargetId\n\n\t// If row doesn't start with '@', it is not a valid redirect\n\tif( *start != '@' ) return 0;\n\t++start; // Skip the '@' character\n\n\t// Skip leading whitespace\n\twhile( start < end && *start <= ' ' ) ++start;\n\n\t// Store target id\n\tparse->target = (char*) malloc( (size_t)( end - start + 1 ) );\n    strncpy( parse->target, start, (size_t)( end - start ) );\n    parse->target[ end - start ] = '\\0';\n\n\t// If we don't have a valid target id, this is not a valid redirect\n\tif( !parse->target || *parse->target == '\\0' ) {\n        if( parse->target ) free( parse->target );\n        parse->target = NULL;\n        return 0;\n    }\n\n\treturn 1;\n}\n\n\nint dialog_parse_event( dialog_parse_event_t* parse, char const* start, char const* end ) {\n\t// An Event is defined like this:\n\t//     #eventName#\n\n\t// If the row doesn't start with '#', it's not a valid event\n\tif( *start != '#' ) return 0;\n\t++start; // Skip leading '#'\n\n\t// If there's no trailing '#', this is not a valid event\n\tif( *--end != '#' ) return 0;\n\n    // Store event string\n\tparse->event = (char*) malloc( (size_t)( end - start + 1 ) );\n    strncpy( parse->event, start, (size_t)( end - start ) );\n    parse->event[ end - start ] = '\\0';\n\n\t// If we don't have a valid event name, it's not a valid event\n\tif( !parse->event || *parse->event == '\\0' ) {\n        if( parse->event ) free( parse->event );\n        parse->event = NULL;\n        return 0;\n    }\n\n\t// Indicate that this is a valid event\n\treturn 1;\t\t\t\n}\n\n\nint dialog_parse_entry( dialog_parse_entry_t* parse, char const* start, char const* end ) {\n    char const* row = start;\n\n\t// Strip id (text defined {like_this} is an id) from the start of the row\n\tif( *row == '{' && strchr( row, '}' ) != 0 )\n\t\t{\n\t\tconst char* id = ++row;\n\t\twhile( row < end && *row != '}' ) ++row;\n\t\tparse->id = (char*) malloc( (size_t)( row - id + 1 ) );\n        strncpy( parse->id, id, (size_t)( row - id ) );\n        parse->id[ row - id ] = '\\0';\n\t\t++row;\n\t\twhile( row < end && *row <= ' ' ) ++row;\n\t\t}\n \t\n \tif( *row == '<' ) { // Check if this is a line\n \t\tparse->type = DIALOG_ENTRY_TYPE_LINE;\n \t\treturn dialog_parse_line( &parse->data.line, row, end );\n    } else if( *row == '^' ) { // Check if this is an option\n \t\tparse->type = DIALOG_ENTRY_TYPE_OPTION;\n \t\treturn dialog_parse_option( &parse->data.option, row, end );\n \t} else if( *row == '@' ) { // Check if this is a redirect\n \t\tparse->type = DIALOG_ENTRY_TYPE_REDIRECT;\n \t\treturn dialog_parse_redirect( &parse->data.redirect, row, end );\n \t} else if( *row == '#' && *( end - 1 ) == '#' && ( end - row ) > 2 ) { // Check if this is an event\n \t\tparse->type = DIALOG_ENTRY_TYPE_EVENT;\n \t\treturn dialog_parse_event( &parse->data.event, row, end );\n \t} else { // Not a valid row\n \t\treturn 0;\n \t}\n}\n\n\nstatic int dialog_parse_row( dialog_parse_convo_t* parse, char const* start, char const* end ) {\n    // Block definition?\n\tsize_t length = (size_t)( end - start );\n\tif( *start == '[' && start[ length - 1 ] == ']' )\n\t\t{        \n\t\tif( !parse->id ) // We only deal with the id if this is a new block\n\t\t\t{\n            parse->id = (char*) malloc( (size_t)( length - 1 ) );\n            strncpy( parse->id, start + 1, length - 2 );\n            parse->id[ length - 2 ] = '\\0';\n\t\t\treturn 1; // Indicate that row was parsed ok\n\t\t\t}\n\n\t\t// We have reached the end of the conversation \n\t\treturn 0; // Indicate that row has not been parsed (new conversation)\n\t\t}\n\n\t// Entry\n\tdialog_parse_entry_t entry;\n    memset( &entry, 0, sizeof( entry ) );\n\tif( dialog_parse_entry( &entry, start, end ) ) { // Parse the row as an entry\n        if( parse->entries_count >= parse->entries_capacity ) {\n            parse->entries_capacity *= 2;\n            parse->entries = (dialog_parse_entry_t*) realloc( parse->entries, \n                sizeof( dialog_parse_entry_t ) * parse->entries_capacity );\n        }\n        parse->entries[ parse->entries_count++ ] = entry;\n    } else {\n        // TODO: Warn about failed parse\n        if( entry.id ) free( entry.id );\n    }\n\n\treturn 1; // Indicate that row was parsed ok\n}\n\n\nstatic void dialog_parse( dialog_parse_t* parse, char const* buffer, int size ) {\n    dialog_parse_convo_t current = { 0 };\n    current.entries_count = 0;\n    current.entries_capacity = 256;\n    current.entries = (dialog_parse_entry_t*) malloc( sizeof( dialog_parse_entry_t ) * current.entries_capacity );\n\n\t// extract rows\n\tfor( char const* ptr = buffer; ptr - buffer < size; ++ptr ) {\n\t\tchar const* row_start = ptr;\n\t\t\t\t\n\t\t// skip forward until next line break\n\t\twhile( *ptr != '\\n' && ptr - buffer < size ) ++ptr;\n\n\t\t// only bother with non-zero length rows\n\t\tif( ptr - row_start > 1 ) {\n\t\t\tchar const* row = row_start;\n\t\t\tchar const* row_end = ptr; \n\n\t\t\t// skip leading whitespace\n\t\t\tchar const* start = row;\n\t\t\twhile ( start < row_end && *start <= ' ' )  ++start;\t\t\t\t\t\n\t\t\trow = start;\n\n\t\t\t// skip trailing whitespace\n\t\t\tstart = row;\n\t\t\tchar const* end = row_end;\n\t\t\twhile( *end <= ' ' && end > start ) --end; \n\t\t\t++end;\n\t\t\t\t\t\n\t\t\t// only bother with non-zero length rows\n\t\t\tif( end - start > 0 ) {\n\t\t\t\t// parse row\n\t\t\t\tint parse_result = dialog_parse_row( &current, start, end );\n\t\t\t\tif( !parse_result ) { // if we're on a new conversation\n\t\t\t\t\t// new conversation, so insert the current one into the list if it is valid\n\t                if( current.id ) {\n                        if( parse->conversations_count >= parse->conversations_capacity ) {\n                            parse->conversations_capacity *= 2;\n                            parse->conversations = (dialog_parse_convo_t*) realloc( parse->conversations, \n                                sizeof( dialog_parse_convo_t ) * parse->conversations_capacity );\n                        }\n                        parse->conversations[ parse->conversations_count++ ] = current;\n                    } else {\n                        free( current.entries );\n                    }\n\n\t\t\t\t\t// and then start a new conversation\n\t\t\t\t\tcurrent.id = 0;\n                    current.entries_count = 0;\n                    current.entries_capacity = 256;\n                    current.entries = (dialog_parse_entry_t*) malloc( sizeof( dialog_parse_entry_t ) * current.entries_capacity );\n\t\t\t\t\tdialog_parse_row( &current, start, end );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\t// if the current conversation is valid, add it to the list\n\tif( current.id ) {\n        if( parse->conversations_count >= parse->conversations_capacity ) {\n            parse->conversations_capacity *= 2;\n            parse->conversations = (dialog_parse_convo_t*) realloc( parse->conversations, \n                sizeof( dialog_parse_convo_t ) * parse->conversations_capacity );\n        }\n        parse->conversations[ parse->conversations_count++ ] = current;\n    } else {\n        free( current.entries );\n    }\n}\n\n\ntypedef struct dialog_data_t {\n    int type;\n    union {\n        struct {\n\t        int actor_offset;\n            int text_offset;\n        } line;\n\n        struct {\n\t        int text_offset;\n            int target_offset;\n            int is_persistant;\n        } option;\n\n        struct {\n\t        int target_offset;\n        } redirect;\n\n        struct {\n\t        int event_offset;\n        } event;\n\n        struct {\n            int id_offset;\n            int entries_count;\n            int entry_list_start_index;\n        } conversation;\n        \n        struct {\n            int id_offset;\n            int entry_index;\n            int entry_list_next_index;\n        } entry_list;\n\n    } data;\n} dialog_data_t;\n\n\nstruct dialog_t {\n    int size_in_bytes;\n    int conversation_count;\n    int data_count;\n    dialog_data_t data[ 1 ];\n};\n\n\n#define DIALOG_ENTRY_TYPE_CONVERSATION 4 \n#define DIALOG_ENTRY_TYPE_ENTRY_LIST 5\n\n\ndialog_t* dialog_create( char const* input, int input_size ) {\n    dialog_parse_t parse;\n    parse.conversations_count = 0;\n    parse.conversations_capacity = 256;\n    parse.conversations = (dialog_parse_convo_t*) malloc( sizeof( dialog_parse_convo_t ) * parse.conversations_capacity );\n    dialog_parse( &parse, input, input_size );\n    int total_size = sizeof( dialog_t ) - sizeof( dialog_data_t );\n    total_size += parse.conversations_count * sizeof( dialog_data_t );\n    int entry_list_count = 0;\n    int entries_count = 0;\n    for( int i = 0; i < parse.conversations_count; ++i ) {\n        total_size += (int)strlen( parse.conversations[ i ].id ) + 1;\n        total_size += parse.conversations[ i ].entries_count * sizeof( dialog_data_t );\n        entry_list_count += parse.conversations[ i ].entries_count;\n        for( int j = 0; j < parse.conversations[ i ].entries_count; ++j ) {\n            ++entries_count;\n            total_size += sizeof( dialog_data_t );\n            if( parse.conversations[ i ].entries[ j ].id ) {\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].id ) + 1;\n            }\n            if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_LINE ) {\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].data.line.actor ) + 1;\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].data.line.text ) + 1;\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_OPTION ) {\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].data.option.text ) + 1;\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].data.option.target ) + 1;\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_REDIRECT ) {\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].data.redirect.target ) + 1;\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_EVENT ) {\n                total_size += (int)strlen( parse.conversations[ i ].entries[ j ].data.event.event ) + 1;\n            }\n        }\n    }\n\n    dialog_t* dialog = (dialog_t*) malloc( (size_t) total_size );\n    dialog->size_in_bytes = total_size;\n    dialog->conversation_count = parse.conversations_count;\n    int next_index = parse.conversations_count;\n    char* text_data = (char*)( dialog->data + parse.conversations_count + entry_list_count + entries_count );\n    int text_offset = (int)( text_data - (char*)dialog );\n    for( int i = 0; i < parse.conversations_count; ++i ) {\n        dialog_data_t* conversation = &dialog->data[ i ];\n        conversation->type = DIALOG_ENTRY_TYPE_CONVERSATION;\n        conversation->data.conversation.id_offset = text_offset;\n        conversation->data.conversation.entries_count = parse.conversations[ i ].entries_count;\n        conversation->data.conversation.entry_list_start_index = next_index++;\n        \n        strcpy( text_data, parse.conversations[ i ].id );\n        text_data += strlen( parse.conversations[ i ].id ) + 1;\n        text_offset += (int)strlen( parse.conversations[ i ].id ) + 1;\n\n        int index = conversation->data.conversation.entry_list_start_index;\n        for( int j = 0; j < parse.conversations[ i ].entries_count; ++j ) {\n            dialog_data_t* entry_list = &dialog->data[ index ];\n            entry_list->type = DIALOG_ENTRY_TYPE_ENTRY_LIST;\n            entry_list->data.entry_list.entry_index = next_index++;\n            index = j >= parse.conversations[ i ].entries_count - 1 ? 0 : next_index++;\n            entry_list->data.entry_list.entry_list_next_index = index;\n            if( parse.conversations[ i ].entries[ j ].id ) {\n                entry_list->data.entry_list.id_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].id );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].id ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].id ) + 1;\n            } else {\n                entry_list->data.entry_list.id_offset = 0;\n            }\n\n            dialog_data_t* entry = &dialog->data[ entry_list->data.entry_list.entry_index ];\n            if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_LINE ) {\n                entry->type = DIALOG_ENTRY_TYPE_LINE;\n\n                entry->data.line.actor_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].data.line.actor );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].data.line.actor ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].data.line.actor ) + 1;\n\n                entry->data.line.text_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].data.line.text );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].data.line.text ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].data.line.text ) + 1;\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_OPTION ) {\n                entry->type = DIALOG_ENTRY_TYPE_OPTION;\n                entry->data.option.text_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].data.option.text );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].data.option.text ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].data.option.text ) + 1;\n\n                entry->data.option.target_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].data.option.target );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].data.option.target ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].data.option.target ) + 1;\n\n                entry->data.option.is_persistant = parse.conversations[ i ].entries[ j ].data.option.is_persistant;\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_REDIRECT ) {\n                entry->type = DIALOG_ENTRY_TYPE_REDIRECT;\n                entry->data.redirect.target_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].data.redirect.target );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].data.redirect.target ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].data.redirect.target ) + 1;\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_EVENT ) {\n                entry->type = DIALOG_ENTRY_TYPE_EVENT;\n                entry->data.event.event_offset = text_offset;\n                strcpy( text_data, parse.conversations[ i ].entries[ j ].data.event.event );\n                text_data += strlen( parse.conversations[ i ].entries[ j ].data.event.event ) + 1;\n                text_offset += (int)strlen( parse.conversations[ i ].entries[ j ].data.event.event ) + 1;\n            }\n        }\n    }\n    dialog->data_count = next_index;\n\n    for( int i = 0; i < parse.conversations_count; ++i ) {\n        free( parse.conversations[ i ].id );\n        for( int j = 0; j < parse.conversations[ i ].entries_count; ++j ) {\n            if( parse.conversations[ i ].entries[ j ].id ) {\n                free( parse.conversations[ i ].entries[ j ].id );\n            }\n            if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_LINE ) {\n                free( parse.conversations[ i ].entries[ j ].data.line.actor );\n                free( parse.conversations[ i ].entries[ j ].data.line.text );\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_OPTION ) {\n                free( parse.conversations[ i ].entries[ j ].data.option.text );\n                free( parse.conversations[ i ].entries[ j ].data.option.target );\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_REDIRECT ) {\n                free( parse.conversations[ i ].entries[ j ].data.redirect.target );\n            } else if( parse.conversations[ i ].entries[ j ].type == DIALOG_ENTRY_TYPE_EVENT ) {\n                free( parse.conversations[ i ].entries[ j ].data.event.event );\n            }\n        }\n        free( parse.conversations[ i ].entries );\n    }\n    free( parse.conversations );\n\n    return dialog;\n}\n\n\nvoid dialog_destroy( dialog_t* dialog ) {\n    free( dialog );\n}\n\n\nint dialog_save( dialog_t const* dialog, void* data, int capacity ) {\n    if( data && capacity >= dialog->size_in_bytes ) {\n        memcpy( data, dialog, (size_t)( dialog->size_in_bytes ) );\n    }\n    return dialog->size_in_bytes;\n}\n\n\ndialog_t* dialog_load( void const* data, int size ) {\n    dialog_t* dialog = (dialog_t*) malloc( (size_t) size );\n    memcpy( dialog, data, (size_t) size );\n    return dialog;\n}\n\n\nvoid dialog_unload( dialog_t* dialog ) {\n    free( dialog );\n}\n\n\nint dialog_find_conversation( dialog_t const* dialog, char const* id ) {\n    for( int i = 0; i < dialog->conversation_count; ++i ) {\n        char const* conv_id = ( (char const*) dialog ) + dialog->data[ i ].data.conversation.id_offset;\n\t\t#ifdef _WIN32\n\t\tif( stricmp( id, conv_id ) == 0 ) {\n\t\t#else\n\t\tif( strcasecmp( id, conv_id ) == 0 ) {\n\t\t#endif\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n\nint dialog_conversation_count( dialog_t const* dialog ) {\n    return dialog->conversation_count;\n}\n\n\ndialog_conversation_t dialog_conversation( dialog_t const* dialog, int index ) {\n    dialog_conversation_t conversation;\n    conversation.handle = index >= 0 && index < dialog->conversation_count ? index : -1;\n    return conversation;\n}\n\n\nchar const* dialog_conversation_id( dialog_t const* dialog, dialog_conversation_t conversation ) {\n    if( conversation.handle >= 0 && conversation.handle < dialog->conversation_count ) {\n        return ( (char*) dialog ) + dialog->data[ conversation.handle ].data.conversation.id_offset;\n    } else {\n        return NULL;\n    }\n}\n\n\nint dialog_conversation_entry_count( dialog_t const* dialog, dialog_conversation_t conversation ) {\n    if( conversation.handle >= 0 && conversation.handle < dialog->conversation_count ) {\n        return dialog->data[ conversation.handle ].data.conversation.entries_count;\n    } else {\n        return 0;\n    }\n}\n\n\ndialog_entry_t dialog_conversation_entry( dialog_t const* dialog, dialog_conversation_t conversation, int index ) {\n    dialog_entry_t entry;\n    entry.handle = -1;\n    if( conversation.handle >= 0 && conversation.handle < dialog->conversation_count ) {\n        if( index < 0 || index >= dialog->data[ conversation.handle ].data.conversation.entries_count ) {\n            return entry;\n        }\n        int entry_index = dialog->data[ conversation.handle ].data.conversation.entry_list_start_index;\n        for( int i = 0; i < index; ++i ) {\n            entry_index = dialog->data[ entry_index ].data.entry_list.entry_list_next_index;\n        }\n        if( !entry_index ) {\n            return entry;\n        }\n        entry.handle = entry_index;\n        return entry;\n    } else {\n        return entry;\n    }\n}\n\n\nchar const* dialog_entry_id( dialog_t const* dialog, dialog_entry_t entry ) {\n    if( entry.handle < 0 || entry.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ entry.handle ].type != DIALOG_ENTRY_TYPE_ENTRY_LIST ) {\n        return NULL;\n    }\n    if( dialog->data[ entry.handle ].data.entry_list.id_offset ) {\n        return ( (char*) dialog ) + dialog->data[ entry.handle ].data.entry_list.id_offset;        \n    } else {\n        return NULL;\n    }    \n}\n\n\ndialog_entry_type_t dialog_entry_type( dialog_t const* dialog, dialog_entry_t entry ) {\n    if( entry.handle < 0 || entry.handle >= dialog->data_count ) {\n        return DIALOG_ENTRY_TYPE_INVALID;\n    }\n    if( dialog->data[ entry.handle ].type != DIALOG_ENTRY_TYPE_ENTRY_LIST ) {\n        return DIALOG_ENTRY_TYPE_INVALID;\n    }\n    int entry_index = dialog->data[ entry.handle ].data.entry_list.entry_index;\n    if( entry_index < 0 || entry_index >= dialog->data_count ) {\n        return DIALOG_ENTRY_TYPE_INVALID;\n    }\n    dialog_entry_type_t type = (dialog_entry_type_t) dialog->data[ entry_index ].type;\n    if( type == DIALOG_ENTRY_TYPE_LINE || type == DIALOG_ENTRY_TYPE_OPTION || type == DIALOG_ENTRY_TYPE_REDIRECT || \n        type == DIALOG_ENTRY_TYPE_EVENT ) {\n            return type;\n    }\n    return DIALOG_ENTRY_TYPE_INVALID;\n}\n\n\ndialog_line_t dialog_entry_line( dialog_t const* dialog, dialog_entry_t entry ) {\n    dialog_line_t line;\n    line.handle = -1;\n    if( entry.handle < 0 || entry.handle >= dialog->data_count ) {\n        return line;\n    }\n    if( dialog->data[ entry.handle ].type != DIALOG_ENTRY_TYPE_ENTRY_LIST ) {\n        return line;\n    }\n    int entry_index = dialog->data[ entry.handle ].data.entry_list.entry_index;\n    if( entry_index < 0 || entry_index >= dialog->data_count ) {\n        return line;\n    }\n    if( dialog->data[ entry_index ].type != DIALOG_ENTRY_TYPE_LINE ) {\n        return line;\n    }\n    line.handle = entry_index;\n    return line;\n}\n\n\ndialog_option_t dialog_entry_option( dialog_t const* dialog, dialog_entry_t entry ) {\n    dialog_option_t option;\n    option.handle = -1;\n    if( entry.handle < 0 || entry.handle >= dialog->data_count ) {\n        return option;\n    }\n    if( dialog->data[ entry.handle ].type != DIALOG_ENTRY_TYPE_ENTRY_LIST ) {\n        return option;\n    }\n    int entry_index = dialog->data[ entry.handle ].data.entry_list.entry_index;\n    if( entry_index < 0 || entry_index >= dialog->data_count ) {\n        return option;\n    }\n    if( dialog->data[ entry_index ].type != DIALOG_ENTRY_TYPE_OPTION ) {\n        return option;\n    }\n    option.handle = entry_index;\n    return option;\n}\n\n\ndialog_redirect_t dialog_entry_redirect( dialog_t const* dialog, dialog_entry_t entry ) {\n    dialog_redirect_t redirect;\n    redirect.handle = -1;\n    if( entry.handle < 0 || entry.handle >= dialog->data_count ) {\n        return redirect;\n    }\n    if( dialog->data[ entry.handle ].type != DIALOG_ENTRY_TYPE_ENTRY_LIST ) {\n        return redirect;\n    }\n    int entry_index = dialog->data[ entry.handle ].data.entry_list.entry_index;\n    if( entry_index < 0 || entry_index >= dialog->data_count ) {\n        return redirect;\n    }\n    if( dialog->data[ entry_index ].type != DIALOG_ENTRY_TYPE_REDIRECT ) {\n        return redirect;\n    }\n    redirect.handle = entry_index;\n    return redirect;\n}\n\n\ndialog_event_t dialog_entry_event( dialog_t const* dialog, dialog_entry_t entry ) {\n    dialog_event_t event;\n    event.handle = -1;\n    if( entry.handle < 0 || entry.handle >= dialog->data_count ) {\n        return event;\n    }\n    if( dialog->data[ entry.handle ].type != DIALOG_ENTRY_TYPE_ENTRY_LIST ) {\n        return event;\n    }\n    int entry_index = dialog->data[ entry.handle ].data.entry_list.entry_index;\n    if( entry_index < 0 || entry_index >= dialog->data_count ) {\n        return event;\n    }\n    if( dialog->data[ entry_index ].type != DIALOG_ENTRY_TYPE_EVENT ) {\n        return event;\n    }\n    event.handle = entry_index;\n    return event;\n}\n\n\nchar const* dialog_line_actor( dialog_t const* dialog, dialog_line_t line ) {\n    if( line.handle < 0 || line.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ line.handle ].type != DIALOG_ENTRY_TYPE_LINE ) {\n        return NULL;\n    }\n    \n    return ( (char*) dialog ) + dialog->data[ line.handle ].data.line.actor_offset;        \n}\n\n\nchar const* dialog_line_text( dialog_t const* dialog, dialog_line_t line ) {\n    if( line.handle < 0 || line.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ line.handle ].type != DIALOG_ENTRY_TYPE_LINE ) {\n        return NULL;\n    }\n    \n    return ( (char*) dialog ) + dialog->data[ line.handle ].data.line.text_offset;        \n}\n\n\nchar const* dialog_option_text( dialog_t const* dialog, dialog_option_t option ) {\n    if( option.handle < 0 || option.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ option.handle ].type != DIALOG_ENTRY_TYPE_OPTION ) {\n        return NULL;\n    }\n    \n    return ( (char*) dialog ) + dialog->data[ option.handle ].data.option.text_offset;        \n}\n\n\nchar const* dialog_option_target( dialog_t const* dialog, dialog_option_t option ) {\n    if( option.handle < 0 || option.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ option.handle ].type != DIALOG_ENTRY_TYPE_OPTION ) {\n        return NULL;\n    }\n    \n    return ( (char*) dialog ) + dialog->data[ option.handle ].data.option.target_offset;        \n}\n\n\nint dialog_option_is_persistent( dialog_t const* dialog, dialog_option_t option ) {\n    if( option.handle < 0 || option.handle >= dialog->data_count ) {\n        return 0;\n    }\n    if( dialog->data[ option.handle ].type != DIALOG_ENTRY_TYPE_OPTION ) {\n        return 0;\n    }\n    \n    return dialog->data[ option.handle ].data.option.is_persistant;        \n}\n\n\nchar const* dialog_redirect_target( dialog_t const* dialog, dialog_redirect_t redirect ) {\n    if( redirect.handle < 0 || redirect.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ redirect.handle ].type != DIALOG_ENTRY_TYPE_REDIRECT ) {\n        return NULL;\n    }\n    \n    return ( (char*) dialog ) + dialog->data[ redirect.handle ].data.redirect.target_offset;        \n}\n\n\nchar const* dialog_event_event( dialog_t const* dialog, dialog_event_t event ) {\n    if( event.handle < 0 || event.handle >= dialog->data_count ) {\n        return NULL;\n    }\n    if( dialog->data[ event.handle ].type != DIALOG_ENTRY_TYPE_EVENT ) {\n        return NULL;\n    }\n    \n    return ( (char*) dialog ) + dialog->data[ event.handle ].data.event.event_offset;        \n}\n\n\n#endif /* DIALOG_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2019 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "dir.h",
          "type": "blob",
          "size": 8.2626953125,
          "content": "\n/*\n------------------------------------------------------------------------------\n\t\t  Licensing information can be found at the end of the dir.\n------------------------------------------------------------------------------\n\ndir.h - v0.1 - Directory listing functions for C/C++\n\nDo this:\n\t#define DIR_IMPLEMENTATION\nbefore you include this file in *one* C/C++ dir to create the implementation.\n*/\n\n#ifndef dir_h\n#define dir_h\n\ntypedef struct dir_t dir_t;\ntypedef struct dir_entry_t dir_entry_t;\n\ndir_t* dir_open( char const* path );\nvoid dir_close( dir_t* dir );\nchar const* dir_path( dir_t* dir );\ndir_entry_t* dir_read( dir_t* dir );\n\nchar const* dir_name( dir_entry_t* entry );\nint dir_is_file( dir_entry_t* entry );\nint dir_is_folder( dir_entry_t* entry );\n\n#endif /* dir_h */\n\n/*\n----------------------\n\tIMPLEMENTATION\n----------------------\n*/\n\n#ifdef DIR_IMPLEMENTATION\n#undef DIR_IMPLEMENTATION\n\n#ifndef DIR_MALLOC\n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <stdlib.h>\n\t#if defined(__cplusplus)\n\t\t#define DIR_MALLOC( size ) ( ::malloc( size ) )\n\t\t#define DIR_FREE( ptr ) ( ::free( ptr ) )\n\t#else\n\t\t#define DIR_MALLOC( size ) ( malloc( size ) )\n\t\t#define DIR_FREE( ptr ) ( free( ptr ) )\n\t#endif\n#endif\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    WINDOWS\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#if defined( DIR_WINDOWS )\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#if !defined( _WIN32_WINNT ) || _WIN32_WINNT < 0x0501 \n\t#undef _WIN32_WINNT\n\t#define _WIN32_WINNT 0x0501 // requires Windows XP minimum\n#endif\n// 0x0400=Windows NT 4.0, 0x0500=Windows 2000, 0x0501=Windows XP, 0x0502=Windows Server 2003, 0x0600=Windows Vista, \n// 0x0601=Windows 7, 0x0602=Windows 8, 0x0603=Windows 8.1, 0x0A00=Windows 10, \n#define _WINSOCKAPI_\n#pragma warning( push )\n#pragma warning( disable: 4365 )\n#pragma warning( disable: 4619 )\n#pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n#pragma warning( disable: 4768 ) // __declspec attributes before linkage specification are ignored\t\n#pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n#define _NTDDSCM_H_\n#include <windows.h>\n#pragma warning( pop )\n\nstruct dir_entry_t \n\t{\n\tchar name[ MAX_PATH ];\n\tBOOL is_folder;\n\t};\n\n\nstruct dir_t\n\t{\n    char path[ MAX_PATH ];\n\tHANDLE handle;\n\tWIN32_FIND_DATAA data;\n\tdir_entry_t entry;\n\t};\n\n\ndir_t* dir_open( char const* path )\n\t{\n\tif( !path ) return 0;\n\n\tsize_t path_len = strlen( path );\n\tBOOL trailing_path_separator = path[ path_len - 1 ] == '\\\\' || path[ path_len - 1 ] == '/';\n\tconst char* string_to_append = \"*.*\";\n\tif( path_len + strlen( string_to_append ) + ( trailing_path_separator ? 0 : 1 ) >= MAX_PATH ) return NULL;\n\tchar search_pattern[ MAX_PATH ];\n\tstrcpy( search_pattern, path );\n\tif( !trailing_path_separator ) strcat( search_pattern, \"\\\\\" );\n\tstrcat( search_pattern, string_to_append );\n\n\tWIN32_FIND_DATAA data;\n\tHANDLE handle = FindFirstFileA( search_pattern, &data );\n\tif( handle == INVALID_HANDLE_VALUE ) return NULL;\n\n\tdir_t* dir = (dir_t*) DIR_MALLOC( sizeof( dir_t ) );\n    strcpy( dir->path, path );\n\tdir->handle = handle;\n\tdir->data = data;\n\n\treturn dir;\n\t}\n\n\nvoid dir_close( dir_t* dir )\n\t{\n\tif( !dir ) return;\n\n\tif( dir->handle != INVALID_HANDLE_VALUE ) FindClose( dir->handle );\n\tDIR_FREE( dir );\n\t}\n\n\nchar const* dir_path( dir_t* dir )\n\t{\n\tif( !dir ) return NULL;\n\treturn dir->path;\n\t}\n\n\ndir_entry_t* dir_read( dir_t* dir )\n\t{\n\tif( !dir ) return NULL;\n\tif( dir->handle == INVALID_HANDLE_VALUE ) return NULL;\n\n\tstrcpy( dir->entry.name, dir->data.cFileName );\n\tdir->entry.is_folder = ( dir->data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0;\n\n\tBOOL result = FindNextFileA( dir->handle, &dir->data );\n\tif( !result )\n\t\t{\n\t\tFindClose( dir->handle );\n\t\tdir->handle = INVALID_HANDLE_VALUE;      \n\t\t}\n\n\treturn &dir->entry;    \n\t}\n\n\nchar const* dir_name( dir_entry_t* entry )\n\t{\n\tif( !entry ) return NULL;\n\treturn entry->name;\n\t}\n\n\nint dir_is_file( dir_entry_t* entry )\n\t{\n\tif( !entry ) return 0;\n\treturn entry->is_folder == FALSE;\n\t}\n\n\nint dir_is_folder( dir_entry_t* entry )\n\t{\n\tif( !entry ) return 0;\n\treturn entry->is_folder == TRUE;\n\t}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    POSIX\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#elif defined( DIR_POSIX )\n\n#include <dirent.h>\n\n\ndir_t* dir_open( char const* path )\n\t{\n\tDIR* dir = opendir( path );\n\treturn (dir_t*) dir;\n\t}\n\n\nvoid dir_close( dir_t* dir )\n\t{\n\tif( !dir ) return;\n\tclosedir( (DIR*) dir );\n\t}\n\n\ndir_entry_t* dir_read( dir_t* dir )\n\t{\n\tif( !dir ) return NULL;\n\treturn (dir_entry_t*)readdir( (DIR*) dir );\n\t}\n\n\nchar const* dir_name( dir_entry_t* entry )\n\t{\n\tif( !entry ) return NULL;\n\treturn ( (struct dirent*)entry )->d_name;\n\t}\n\n\nint dir_is_file( dir_entry_t* entry )\n\t{\n\tif( !entry ) return 0;\n\treturn ( (struct dirent*)entry )->d_type == DT_REG;\n\t}\n\n\nint dir_is_folder( dir_entry_t* entry )\n\t{\n\tif( !entry ) return 0;\n\treturn ( (struct dirent*)entry )->d_type == DT_DIR;\n\t}\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//    PLATFORM ERROR\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#else\n\n\t#error Undefined platform. Define DIR_WINDOWS or DIR_POSIX.\n\n#endif \n\n\n#endif /* DIR_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2017 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "frametimer.h",
          "type": "blob",
          "size": 10.92578125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nframetimer.h - v0.1 - Framerate timer functionality.\n\nDo this:\n    #define FRAMETIMER_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef frametimer_h\n#define frametimer_h\n\ntypedef struct frametimer_t frametimer_t;\n\nframetimer_t* frametimer_create( void* memxtx );\n\nvoid frametimer_destroy( frametimer_t* frametimer );\n\nvoid frametimer_lock_rate( frametimer_t* frametimer, int fps );\n\nfloat frametimer_update( frametimer_t* frametimer );\n\nfloat frametimer_delta_time( frametimer_t* frametimer );\n\nint frametimer_frame_counter( frametimer_t* frametimer );\n\n#endif /* frametimer_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef FRAMETIMER_IMPLEMENTATION\n#undef FRAMETIMER_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE\n#ifndef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n#endif\n#ifdef _WIN32\n    #if !defined( _WIN32_WINNT ) || _WIN32_WINNT < 0x0501\n        #undef _WIN32_WINNT\n        #define _WIN32_WINNT 0x0501 // requires Windows XP minimum\n    #endif\n    // 0x0400=Windows NT 4.0, 0x0500=Windows 2000, 0x0501=Windows XP, 0x0502=Windows Server 2003, 0x0600=Windows Vista,\n    // 0x0601=Windows 7, 0x0602=Windows 8, 0x0603=Windows 8.1, 0x0A00=Windows 10,\n    #define _WINSOCKAPI_\n    #pragma warning( push )\n    #pragma warning( disable: 4619 )\n    #pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n    #pragma warning( disable: 4768 ) // __declspec attributes before linkage specification are ignored\n    #pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n    #include <windows.h>\n    #pragma warning( pop )\n    #ifndef __TINYC__\n        #pragma comment(lib, \"winmm.lib\")\n    #else\n        typedef struct timecaps_tag { UINT wPeriodMin; UINT wPeriodMax; } TIMECAPS, *PTIMECAPS, NEAR *NPTIMECAPS, FAR *LPTIMECAPS;\n        typedef UINT MMRESULT;\n        #define TIMERR_NOERROR (0)\n        static MMRESULT (*timeGetDevCaps)( LPTIMECAPS ptc, UINT cbtc );\n        static MMRESULT (*timeBeginPeriod)( UINT uPeriod );\n        static MMRESULT (*timeEndPeriod)( UINT uPeriod );\n    #endif\n#elif defined( __APPLE__ )\n    #include <mach/mach_time.h>\n#elif defined( __wasm__ )\n    #define WA_CORO_IMPLEMENT_NANOSLEEP\n    #include <wajic_coro.h>\n#else\n    #include <time.h>\n#endif\n\n#ifndef FRAMETIMER_MALLOC\n    #include <stdlib.h>\n    #if defined(__cplusplus)\n        #define FRAMETIMER_MALLOC( ctx, size ) ( ::malloc( size ) )\n        #define FRAMETIMER_FREE( ctx, ptr ) ( ::free( ptr ) )\n    #else\n        #define FRAMETIMER_MALLOC( ctx, size ) ( malloc( size ) )\n        #define FRAMETIMER_FREE( ctx, ptr ) ( free( ptr ) )\n    #endif\n#endif\n\n#ifndef FRAMETIMER_U64\n    #define FRAMETIMER_U64 unsigned long long\n#endif\n\nstruct frametimer_t\n    {\n    FRAMETIMER_U64 clock_freq;\n    FRAMETIMER_U64 prev_clock;\n    void* memctx;\n    float delta_time;\n    int initialized;\n    int frame_counter;\n    int frame_rate_lock;\n    #ifdef _WIN32\n        HANDLE waitable_timer;\n    #endif\n    };\n\n\nframetimer_t* frametimer_create( void* memctx )\n    {\n    frametimer_t* frametimer = (frametimer_t*) FRAMETIMER_MALLOC( memctx, sizeof( frametimer_t ) );\n    #ifdef _WIN32\n        #ifdef __TINYC__\n            HMODULE winmm = LoadLibrary( \"winmm\" );\n            timeGetDevCaps = GetProcAddress( winmm, \"timeGetDevCaps\");\n            timeBeginPeriod = GetProcAddress( winmm, \"timeBeginPeriod\");\n            timeEndPeriod = GetProcAddress( winmm, \"timeEndPeriod\");\n        #endif\n        TIMECAPS tc;\n        if( timeGetDevCaps( &tc, sizeof( TIMECAPS ) ) == TIMERR_NOERROR )\n            timeBeginPeriod( tc.wPeriodMin );\n        frametimer->waitable_timer = CreateWaitableTimer(NULL, TRUE, NULL);\n    #endif\n\n    frametimer->memctx = memctx;\n    frametimer->initialized = 0;\n\n    #ifdef _WIN32\n        LARGE_INTEGER f;\n        QueryPerformanceFrequency( &f );\n        frametimer->clock_freq = (FRAMETIMER_U64) f.QuadPart;\n    #else\n        frametimer->clock_freq = 1000000000ull;\n    #endif\n\n    frametimer->prev_clock = 0;\n    frametimer->delta_time = 0.0f;\n    frametimer->frame_counter = 0;\n    frametimer->frame_rate_lock = 0;\n    return frametimer;\n    }\n\n\nvoid frametimer_destroy( frametimer_t* frametimer )\n    {\n    #ifdef _WIN32\n        CloseHandle( frametimer->waitable_timer );\n        TIMECAPS tc;\n        if( timeGetDevCaps( &tc, sizeof( TIMECAPS ) ) == TIMERR_NOERROR )\n            timeEndPeriod( tc.wPeriodMin );\n    #endif\n    FRAMETIMER_FREE( frametimer->memctx, frametimer );\n    }\n\n\nvoid frametimer_lock_rate( frametimer_t* frametimer, int fps )\n    {\n    frametimer->frame_rate_lock = ( fps > 0 && fps < 5 ) ? 5 : fps < 0 ? 0 : fps;\n    }\n\n\nfloat frametimer_update( frametimer_t* frametimer )\n    {\n    if( !frametimer->initialized )\n        {\n        #ifdef _WIN32\n            LARGE_INTEGER c;\n            QueryPerformanceCounter( &c );\n            frametimer->prev_clock = (FRAMETIMER_U64) c.QuadPart;\n        #elif defined( __APPLE__ )\n            frametimer->prev_clock = clock_gettime_nsec_np( CLOCK_UPTIME_RAW );\n        #else\n            struct timespec t;\n            clock_gettime( CLOCK_MONOTONIC_RAW, &t );\n            frametimer->prev_clock = (FRAMETIMER_U64)t.tv_sec;\n            frametimer->prev_clock *= 1000000000ull;\n            frametimer->prev_clock += (FRAMETIMER_U64)t.tv_nsec;\n        #endif\n        frametimer->initialized = 1;\n        }\n\n    ++frametimer->frame_counter;\n\n\n    FRAMETIMER_U64 curr_clock = 0ULL;\n    #ifdef _WIN32\n        LARGE_INTEGER c;\n        QueryPerformanceCounter( &c );\n        curr_clock = (FRAMETIMER_U64) c.QuadPart;\n    #elif defined( __APPLE__ )\n        curr_clock = (FRAMETIMER_U64) clock_gettime_nsec_np( CLOCK_UPTIME_RAW );\n    #else\n        struct timespec t;\n        clock_gettime( CLOCK_MONOTONIC_RAW, &t );\n        curr_clock = (FRAMETIMER_U64)t.tv_sec;\n        curr_clock *= 1000000000ull;\n        curr_clock += (FRAMETIMER_U64)t.tv_nsec;\n    #endif\n\n    if( frametimer->frame_rate_lock > 0 )\n        {\n        FRAMETIMER_U64 delta = 0ULL;\n        if( curr_clock > frametimer->prev_clock )\n            delta = curr_clock - frametimer->prev_clock - 1ULL;\n        if( delta < frametimer->clock_freq / frametimer->frame_rate_lock )\n            {\n            FRAMETIMER_U64 wait = ( frametimer->clock_freq / frametimer->frame_rate_lock ) - delta;\n            #ifdef _WIN32\n                if( wait > 0 )\n                    {\n                    LARGE_INTEGER due_time;\n                    due_time.QuadPart = - (LONGLONG) ( ( 10000000ULL * wait ) / frametimer->clock_freq ) ;\n\n                    SetWaitableTimer( frametimer->waitable_timer, &due_time, 0, 0, 0, FALSE );\n                    WaitForSingleObject( frametimer->waitable_timer, 200 ); // wait long enough for timer to trigger ( 200ms == 5fps )\n                    CancelWaitableTimer( frametimer->waitable_timer ); // in case we timed out\n                    }\n            #else\n                struct timespec t = { 0, 0 };\n                t.tv_nsec = wait;\n                while( t.tv_nsec > 0 )\n                    {\n                    struct timespec r = { 0, 0 };\n                    if( nanosleep( &t, &r ) >= 0 ) break;\n                    t = r;\n                    }\n            #endif\n            curr_clock += wait;\n            }\n        }\n\n    FRAMETIMER_U64 delta_clock = 0ULL;\n    if( curr_clock > frametimer->prev_clock ) delta_clock = curr_clock - frametimer->prev_clock;\n\n    // Cap delta time if it is too high (running at less than 5 fps ) or things will jump\n    // like crazy on occasional long stalls.\n    if( delta_clock > frametimer->clock_freq / 5ULL ) delta_clock = frametimer->clock_freq / 5ULL; // Cap to 5 fps\n\n    float delta_time = (float) ( ( (double) delta_clock ) / ( (double) frametimer->clock_freq ) );\n\n    frametimer->delta_time = delta_time;\n    frametimer->prev_clock = curr_clock;\n\n    return delta_time;\n    }\n\n\nfloat frametimer_delta_time( frametimer_t* frametimer )\n    {\n    return frametimer->delta_time;\n    }\n\n\nint frametimer_frame_counter( frametimer_t* frametimer )\n    {\n    return frametimer->frame_counter;\n    }\n\n\n#endif /* FRAMETIMER_IMPLEMENTATION */\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "ftplib.h",
          "type": "blob",
          "size": 36.4541015625,
          "content": "/*\nftplib.h - FTP client lib for C/C++.\n\nDo this:\n\t#define FTPLIB_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n\n------------------------------------------------------------------------------\n\nThis is simply a merged single-header version of the original ftplib lib.\n\nThe original license text can be found below, and I place my changes under the \nsame license.\n\n                        / Mattias Gustavsson ( mattias@mattiasgustavsson.com )\n*/\n\n/***************************************************************************/\n/*\t\t\t\t\t\t\t\t\t                                       */\n/* ftplib.h - header file for callable ftp access routines                 */\n/* Copyright (C) 1996-2001, 2013, 2016 Thomas Pfau, tfpfau@gmail.com\t   */\n/*\t1407 Thomas Ave, North Brunswick, NJ, 08902\t\t\t                   */\n/*\t\t\t\t\t\t\t\t\t                                       */\n/* This library is free software.  You can redistribute it and/or\t       */\n/* modify it under the terms of the Artistic License 2.0.\t\t           */\n/* \t\t\t\t\t\t\t\t\t                                       */\n/* This library is distributed in the hope that it will be useful,\t       */\n/* but WITHOUT ANY WARRANTY; without even the implied warranty of\t       */\n/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\t       */\n/* Artistic License 2.0 for more details.\t\t\t\t                   */\n/* \t\t\t\t\t\t\t\t\t                                       */\n/* See the file LICENSE or \t\t\t\t\t\t                           */\n/* http://www.perlfoundation.org/artistic_license_2_0\t\t\t           */\n/*\t\t\t\t\t\t\t\t\t                                       */\n/***************************************************************************/\n\n#if !defined(__FTPLIB_H)\n#define __FTPLIB_H\n\n// MG: removed as it is no longer built as a library\n/*\n#if defined(__unix__) || defined(VMS)\n#define GLOBALDEF\n#define GLOBALREF extern\n#elif defined(_WIN32)\n#if defined BUILDING_LIBRARY\n#define GLOBALDEF __declspec(dllexport)\n#define GLOBALREF __declspec(dllexport)\n#else\n#define GLOBALREF __declspec(dllimport)\n#endif\n#endif\n*/\n#define GLOBALDEF\n#define GLOBALREF\n\n#pragma warning( push )\n#pragma warning( disable: 4668 )\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <limits.h>\n#include <inttypes.h>\n#pragma warning( pop )\n\n/* FtpAccess() type codes */\n#define FTPLIB_DIR 1\n#define FTPLIB_DIR_VERBOSE 2\n#define FTPLIB_FILE_READ 3\n#define FTPLIB_FILE_WRITE 4\n\n/* FtpAccess() mode codes */\n#define FTPLIB_ASCII 'A'\n#define FTPLIB_IMAGE 'I'\n#define FTPLIB_TEXT FTPLIB_ASCII\n#define FTPLIB_BINARY FTPLIB_IMAGE\n\n/* connection modes */\n#define FTPLIB_PASSIVE 1\n#define FTPLIB_PORT 2\n\n/* connection option names */\n#define FTPLIB_CONNMODE 1\n#define FTPLIB_CALLBACK 2\n#define FTPLIB_IDLETIME 3\n#define FTPLIB_CALLBACKARG 4\n#define FTPLIB_CALLBACKBYTES 5\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(__UINT64_MAX)\ntypedef uint64_t fsz_t;\n#else\ntypedef uint32_t fsz_t;\n#endif\n\ntypedef struct NetBuf netbuf;\ntypedef int (*FtpCallback)(netbuf *nControl, fsz_t xfered, void *arg);\n\ntypedef struct FtpCallbackOptions {\n    FtpCallback cbFunc;\t\t/* function to call */\n    void *cbArg;\t\t/* argument to pass to function */\n    unsigned int bytesXferred;\t/* callback if this number of bytes transferred */\n    unsigned int idleTime;\t/* callback if this many milliseconds have elapsed */\n} FtpCallbackOptions;\n\n//GLOBALREF int ftplib_debug;\nGLOBALREF void FtpInit(void);\nGLOBALREF char *FtpLastResponse(netbuf *nControl);\nGLOBALREF int FtpConnect(const char *host, netbuf **nControl);\nGLOBALREF int FtpOptions(int opt, long val, netbuf *nControl);\nGLOBALREF int FtpSetCallback(const FtpCallbackOptions *opt, netbuf *nControl);\nGLOBALREF int FtpClearCallback(netbuf *nControl);\nGLOBALREF int FtpLogin(const char *user, const char *pass, netbuf *nControl);\nGLOBALREF int FtpAccess(const char *path, int typ, int mode, netbuf *nControl,\n    netbuf **nData);\nGLOBALREF int FtpRead(void *buf, int max, netbuf *nData);\nGLOBALREF int FtpWrite(const void *buf, int len, netbuf *nData);\nGLOBALREF int FtpClose(netbuf *nData);\nGLOBALREF int FtpSite(const char *cmd, netbuf *nControl);\nGLOBALREF int FtpSysType(char *buf, int max, netbuf *nControl);\nGLOBALREF int FtpMkdir(const char *path, netbuf *nControl);\nGLOBALREF int FtpChdir(const char *path, netbuf *nControl);\nGLOBALREF int FtpCDUp(netbuf *nControl);\nGLOBALREF int FtpRmdir(const char *path, netbuf *nControl);\nGLOBALREF int FtpPwd(char *path, int max, netbuf *nControl);\nGLOBALREF int FtpNlst(const char *output, const char *path, netbuf *nControl);\nGLOBALREF int FtpDir(const char *output, const char *path, netbuf *nControl);\nGLOBALREF int FtpSize(const char *path, unsigned int *size, char mode, netbuf *nControl);\n#if defined(__UINT64_MAX)\nGLOBALREF int FtpSizeLong(const char *path, fsz_t *size, char mode, netbuf *nControl);\n#endif\nGLOBALREF int FtpModDate(const char *path, char *dt, int max, netbuf *nControl);\nGLOBALREF int FtpGet(const char *output, const char *path, char mode,\n\tnetbuf *nControl);\nGLOBALREF int FtpPut(const char *input, const char *path, char mode,\n\tnetbuf *nControl);\nGLOBALREF int FtpRename(const char *src, const char *dst, netbuf *nControl);\nGLOBALREF int FtpDelete(const char *fnm, netbuf *nControl);\nGLOBALREF void FtpQuit(netbuf *nControl);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /* __FTPLIB_H */\n\n#ifdef FTPLIB_IMPLEMENTATION\n#undef FTPLIB_IMPLEMENTATION\n\n// MG: FIXUP TO GET THINGS TO COMPILE\n\t#pragma comment (lib, \"Ws2_32.lib\") \n\t#pragma warning( push )\n    #pragma warning( disable: 4242 )\n    #pragma warning( disable: 4244 )\n    #pragma warning( disable: 4267 )\n    #pragma warning( disable: 4312 )\n    #pragma warning( disable: 4365 )\n    #pragma warning( disable: 4388 )\n    #pragma warning( disable: 4548 )\n    #pragma warning( disable: 4668 )\n\t#pragma warning( disable: 4701 )\n\t#pragma warning( disable: 4706 )\n    #pragma warning( disable: 4996 )\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n\n    #include <stdlib.h>\t\n\tconst char* hstrerror(int err) { static char str[ 16 ]; itoa( err, str, 10 );  return str; }\n\n/***************************************************************************/\n/*\t\t\t\t\t\t\t\t\t   */\n/* ftplib.c - callable ftp access routines\t\t\t\t   */\n/* Copyright (C) 1996-2001, 2013, 2016 Thomas Pfau, tfpfau@gmail.com\t   */\n/*\t1407 Thomas Ave, North Brunswick, NJ, 08902\t\t\t   */\n/*\t\t\t\t\t\t\t\t\t   */\n/* This library is free software.  You can redistribute it and/or\t   */\n/* modify it under the terms of the Artistic License 2.0.\t\t   */\n/* \t\t\t\t\t\t\t\t\t   */\n/* This library is distributed in the hope that it will be useful,\t   */\n/* but WITHOUT ANY WARRANTY; without even the implied warranty of\t   */\n/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\t   */\n/* Artistic License 2.0 for more details.\t\t\t\t   */\n/* \t\t\t\t\t\t\t\t\t   */\n/* See the file LICENSE or \t\t\t\t\t\t   */\n/* http://www.perlfoundation.org/artistic_license_2_0\t\t\t   */\n/* \t\t\t\t\t\t\t\t\t   */\n/***************************************************************************/\n\n#if defined(__unix__) || defined(__VMS)\n#include <unistd.h>\n#endif\n#if defined(_WIN32)\n#define _WINSOCKAPI_\n#pragma warning( push )\n#pragma warning( disable: 4255 )\n#include <windows.h>\n#include <winsock.h>\n#pragma warning( pop )\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <ctype.h>\n#if defined(__unix__)\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#elif defined(VMS)\n#include <types.h>\n#include <socket.h>\n#include <in.h>\n#include <netdb.h>\n#include <inet.h>\n#elif defined(_WIN32)\n#include <winsock2.h>\n#endif\n#if defined(__APPLE__)\n#undef _REENTRANT\n#endif\n\n\n#define BUILDING_LIBRARY\n// #include \"ftplib.h\" /* MG: merge to single header lib */\n\n#if defined(__UINT64_MAX) && !defined(PRIu64)\n#if ULONG_MAX == __UINT32_MAX\n#define PRIu64 \"llu\"\n#else\n#define PRIu64 \"lu\"\n#endif\n#endif\n\n#if defined(_WIN32)\n#define SETSOCKOPT_OPTVAL_TYPE (const char *)\n#else\n#define SETSOCKOPT_OPTVAL_TYPE (void *)\n#endif\n\n#define FTPLIB_BUFSIZ 8192\n#define RESPONSE_BUFSIZ 1024\n#define TMP_BUFSIZ 1024\n#define ACCEPT_TIMEOUT 30\n\n#define FTPLIB_CONTROL 0\n#define FTPLIB_READ 1\n#define FTPLIB_WRITE 2\n\n#if !defined FTPLIB_DEFMODE\n#define FTPLIB_DEFMODE FTPLIB_PASSIVE\n#endif\n\nstruct NetBuf {\n    char *cput,*cget;\n    int handle;\n    int cavail,cleft;\n    char *buf;\n    int dir;\n    netbuf *ctrl;\n    netbuf *data;    \n    int cmode;\n    struct timeval idletime;\n    FtpCallback idlecb;\n    void *idlearg;\n    unsigned long int xfered;\n    unsigned long int cbbytes;\n    unsigned long int xfered1;\n    char response[RESPONSE_BUFSIZ];\n};\n\nstatic char *version =\n    \"ftplib Release 4.0 07-Jun-2013, copyright 1996-2003, 2013 Thomas Pfau\";\n\nGLOBALDEF int ftplib_debug = 0;\n\n#if defined(__unix__) || defined(VMS)\nint net_read(int fd, char *buf, size_t len)\n{\n    while ( 1 )\n    {\n\tint c = read(fd, buf, len);\n\tif ( c == -1 )\n\t{\n\t    if ( errno != EINTR && errno != EAGAIN )\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    return c;\n\t}\n    }\n}\n\nint net_write(int fd, const char *buf, size_t len)\n{\n    int done = 0;\n    while ( len > 0 )\n    {\n\tint c = write( fd, buf, len );\n\tif ( c == -1 )\n\t{\n\t    if ( errno != EINTR && errno != EAGAIN )\n\t\treturn -1;\n\t}\n\telse if ( c == 0 )\n\t{\n\t    return done;\n\t}\n\telse\n\t{\n\t    buf += c;\n\t    done += c;\n\t    len -= c;\n\t}\n    }\n    return done;\n}\n#define net_close close\n#elif defined(_WIN32)\n#define net_read(x,y,z) recv(x,y,z,0)\n#define net_write(x,y,z) send(x,y,z,0)\n#define net_close closesocket\n#endif\n\n#if defined(NEED_MEMCCPY)\n/*\n * VAX C does not supply a memccpy routine so I provide my own\n */\nvoid *memccpy(void *dest, const void *src, int c, size_t n)\n{\n    int i=0;\n    const unsigned char *ip=src;\n    unsigned char *op=dest;\n\n    while (i < n)\n    {\n\tif ((*op++ = *ip++) == c)\n\t    break;\n\ti++;\n    }\n    if (i == n)\n\treturn NULL;\n    return op;\n}\n#endif\n#if defined(NEED_STRDUP)\n/*\n * strdup - return a malloc'ed copy of a string\n */\nchar *strdup(const char *src)\n{\n    int l = strlen(src) + 1;\n    char *dst = malloc(l);\n    if (dst)\n        strcpy(dst,src);\n    return dst;\n}\n#endif\n\n/*\n * socket_wait - wait for socket to receive or flush data\n *\n * return 1 if no user callback, otherwise, return value returned by\n * user callback\n */\nstatic int socket_wait(netbuf *ctl)\n{\n    fd_set fd,*rfd = NULL,*wfd = NULL;\n    struct timeval tv;\n    int rv = 0;\n    if ((ctl->dir == FTPLIB_CONTROL) || (ctl->idlecb == NULL))\n\treturn 1;\n    if (ctl->dir == FTPLIB_WRITE)\n\twfd = &fd;\n    else\n\trfd = &fd;\n    FD_ZERO(&fd);\n    do\n    {\n\tFD_SET((unsigned int)ctl->handle,&fd);\n\ttv = ctl->idletime;\n\trv = select(ctl->handle+1, rfd, wfd, NULL, &tv);\n\tif (rv == -1)\n\t{\n\t    rv = 0;\n\t    strncpy(ctl->ctrl->response, strerror(errno),\n                    sizeof(ctl->ctrl->response));\n\t    break;\n\t}\n\telse if (rv > 0)\n\t{\n\t    rv = 1;\n\t    break;\n\t}\n    }\n    while ((rv = ctl->idlecb(ctl, ctl->xfered, ctl->idlearg)));\n    return rv;\n}\n\n/*\n * read a line of text\n *\n * return -1 on error or bytecount\n */\nstatic int readline(char *buf,int max,netbuf *ctl)\n{\n    int x,retval = 0;\n    char *end,*bp=buf;\n    int eof = 0;\n\n    if ((ctl->dir != FTPLIB_CONTROL) && (ctl->dir != FTPLIB_READ))\n\treturn -1;\n    if (max == 0)\n\treturn 0;\n    do\n    {\n    \tif (ctl->cavail > 0)\n    \t{\n\t    x = (max >= ctl->cavail) ? ctl->cavail : max-1;\n\t    end = (char*) memccpy(bp,ctl->cget,'\\n',x);\n\t    if (end != NULL)\n\t\tx = end - bp;\n\t    retval += x;\n\t    bp += x;\n\t    *bp = '\\0';\n\t    max -= x;\n\t    ctl->cget += x;\n\t    ctl->cavail -= x;\n\t    if (end != NULL)\n\t    {\n\t\tbp -= 2;\n\t\tif (strcmp(bp,\"\\r\\n\") == 0)\n\t\t{\n\t\t    *bp++ = '\\n';\n\t\t    *bp++ = '\\0';\n\t\t    --retval;\n\t\t}\n\t    \tbreak;\n\t    }\n    \t}\n    \tif (max == 1)\n    \t{\n\t    *buf = '\\0';\n\t    break;\n    \t}\n    \tif (ctl->cput == ctl->cget)\n    \t{\n\t    ctl->cput = ctl->cget = ctl->buf;\n\t    ctl->cavail = 0;\n\t    ctl->cleft = FTPLIB_BUFSIZ;\n    \t}\n\tif (eof)\n\t{\n\t    if (retval == 0)\n\t\tretval = -1;\n\t    break;\n\t}\n\tif (!socket_wait(ctl))\n\t    return retval;\n    \tif ((x = net_read(ctl->handle,ctl->cput,ctl->cleft)) == -1)\n    \t{\n\t    if (ftplib_debug)\n\t\tperror(\"read\");\n\t    retval = -1;\n\t    break;\n    \t}\n\tif (x == 0)\n\t    eof = 1;\n    \tctl->cleft -= x;\n    \tctl->cavail += x;\n    \tctl->cput += x;\n    }\n    while (1);\n    return retval;\n}\n\n/*\n * write lines of text\n *\n * return -1 on error or bytecount\n */\nstatic int writeline(const char *buf, int len, netbuf *nData)\n{\n    int x, nb=0, w;\n    const char *ubp = buf;\n    char *nbp;\n    char lc=0;\n\n    if (nData->dir != FTPLIB_WRITE)\n\treturn -1;\n    nbp = nData->buf;\n    for (x=0; x < len; x++)\n    {\n\tif ((*ubp == '\\n') && (lc != '\\r'))\n\t{\n\t    if (nb == FTPLIB_BUFSIZ)\n\t    {\n\t\tif (!socket_wait(nData))\n\t\t    return x;\n\t\tw = net_write(nData->handle, nbp, FTPLIB_BUFSIZ);\n\t\tif (w != FTPLIB_BUFSIZ)\n\t\t{\n\t\t    if (ftplib_debug)\n\t\t\tprintf(\"net_write(1) returned %d, errno = %d\\n\", w, errno);\n\t\t    return(-1);\n\t\t}\n\t\tnb = 0;\n\t    }\n\t    nbp[nb++] = '\\r';\n\t}\n\tif (nb == FTPLIB_BUFSIZ)\n\t{\n\t    if (!socket_wait(nData))\n\t\treturn x;\n\t    w = net_write(nData->handle, nbp, FTPLIB_BUFSIZ);\n\t    if (w != FTPLIB_BUFSIZ)\n\t    {\n\t\tif (ftplib_debug)\n\t\t    printf(\"net_write(2) returned %d, errno = %d\\n\", w, errno);\n\t\treturn(-1);\n\t    }\n\t    nb = 0;\n\t}\n\tnbp[nb++] = lc = *ubp++;\n    }\n    if (nb)\n    {\n\tif (!socket_wait(nData))\n\t    return x;\n\tw = net_write(nData->handle, nbp, nb);\n\tif (w != nb)\n\t{\n\t    if (ftplib_debug)\n\t\tprintf(\"net_write(3) returned %d, errno = %d\\n\", w, errno);\n\t    return(-1);\n\t}\n    }\n    return len;\n}\n\n/*\n * read a response from the server\n *\n * return 0 if first char doesn't match\n * return 1 if first char matches\n */\nstatic int readresp(char c, netbuf *nControl)\n{\n    char match[5];\n    if (readline(nControl->response,RESPONSE_BUFSIZ,nControl) == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"Control socket read failed\");\n\treturn 0;\n    }\n    if (ftplib_debug > 1)\n\tfprintf(stderr,\"%s\",nControl->response);\n    if (nControl->response[3] == '-')\n    {\n\tstrncpy(match,nControl->response,3);\n\tmatch[3] = ' ';\n\tmatch[4] = '\\0';\n\tdo\n\t{\n\t    if (readline(nControl->response,RESPONSE_BUFSIZ,nControl) == -1)\n\t    {\n\t\tif (ftplib_debug)\n\t\t    perror(\"Control socket read failed\");\n\t\treturn 0;\n\t    }\n\t    if (ftplib_debug > 1)\n\t\tfprintf(stderr,\"%s\",nControl->response);\n\t}\n\twhile (strncmp(nControl->response,match,4));\n    }\n    if (nControl->response[0] == c)\n\treturn 1;\n    return 0;\n}\n\n/*\n * FtpInit for stupid operating systems that require it (Windows NT)\n */\nGLOBALDEF void FtpInit(void)\n{\n#if defined(_WIN32)\n    WORD wVersionRequested;\n    WSADATA wsadata;\n    int err;\n    wVersionRequested = MAKEWORD(1,1);\n    if ((err = WSAStartup(wVersionRequested,&wsadata)) != 0)\n\tfprintf(stderr,\"Network failed to start: %d\\n\",err);\n#endif\n}\n\n/*\n * FtpLastResponse - return a pointer to the last response received\n */\nGLOBALDEF char *FtpLastResponse(netbuf *nControl)\n{\n    if ((nControl) && (nControl->dir == FTPLIB_CONTROL))\n    \treturn nControl->response;\n    return NULL;\n}\n\n/*\n * FtpConnect - connect to remote server\n *\n * return 1 if connected, 0 if not\n */\nGLOBALDEF int FtpConnect(const char *host, netbuf **nControl)\n{\n    int sControl;\n    struct sockaddr_in sin;\n    int on=1;\n    netbuf *ctrl;\n    char *lhost;\n    char *pnum;\n\n    memset(&sin,0,sizeof(sin));\n    sin.sin_family = AF_INET;\n    lhost = strdup(host);\n    pnum = strchr(lhost,':');\n    if (pnum == NULL)\n\tpnum = \"ftp\";\n    else\n\t*pnum++ = '\\0';\n    if (isdigit(*pnum))\n\tsin.sin_port = htons(atoi(pnum));\n    else\n    {\n\tstruct servent *pse;\n#if _REENTRANT\n\tstruct servent se;\n\tchar tmpbuf[TMP_BUFSIZ];\n\tint i;\n\tif ( ( i = getservbyname_r(pnum,\"tcp\",&se,tmpbuf,TMP_BUFSIZ,&pse) ) != 0 )\n\t{\n\t    errno = i;\n\t    if ( ftplib_debug )\n\t\tperror(\"getservbyname_r\");\n\t    free(lhost);\n\t    return 0;\n\t}\n#else\n\tif ((pse = getservbyname(pnum,\"tcp\") ) == NULL )\n\t{\n\t    if ( ftplib_debug )\n\t\tperror(\"getservbyname\");\n\t    free(lhost);\n\t    return 0;\n\t}\n#endif\n\tsin.sin_port = pse->s_port;\n    }\n    if ((sin.sin_addr.s_addr = inet_addr(lhost)) == INADDR_NONE)\n    {\n\tstruct hostent *phe;\n#ifdef _REENTRANT\n\tstruct hostent he;\n\tchar tmpbuf[TMP_BUFSIZ];\n\tint i, herr;\n\tif ( ( ( i = gethostbyname_r( lhost, &he, tmpbuf, TMP_BUFSIZ, &phe, &herr ) ) != 0 ) ||\n\t     ( phe == NULL ) )\n\t{\n\t    if ( ftplib_debug )\n\t\tfprintf(stderr, \"gethostbyname: %s\\n\", hstrerror(herr));\n\t    free(lhost);\n\t    return 0;\n\t}\n#else\n    \tif ((phe = gethostbyname(lhost)) == NULL)\n    \t{\n\t    if (ftplib_debug)\n\t\tfprintf(stderr, \"gethostbyname: %s\\n\", hstrerror(h_errno));\n\t    free(lhost);\n\t    return 0;\n    \t}\n#endif\n    \tmemcpy((char *)&sin.sin_addr, phe->h_addr, phe->h_length);\n    }\n    free(lhost);\n    sControl = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sControl == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"socket\");\n\treturn 0;\n    }\n    if (setsockopt(sControl,SOL_SOCKET,SO_REUSEADDR,\n\t\t   SETSOCKOPT_OPTVAL_TYPE &on, sizeof(on)) == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"setsockopt\");\n\tnet_close(sControl);\n\treturn 0;\n    }\n    if (connect(sControl, (struct sockaddr *)&sin, sizeof(sin)) == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"connect\");\n\tnet_close(sControl);\n\treturn 0;\n    }\n    ctrl = (netbuf*) calloc(1,sizeof(netbuf));\n    if (ctrl == NULL)\n    {\n\tif (ftplib_debug)\n\t    perror(\"calloc\");\n\tnet_close(sControl);\n\treturn 0;\n    }\n    ctrl->buf = (char*)malloc(FTPLIB_BUFSIZ);\n    if (ctrl->buf == NULL)\n    {\n\tif (ftplib_debug)\n\t    perror(\"calloc\");\n\tnet_close(sControl);\n\tfree(ctrl);\n\treturn 0;\n    }\n    ctrl->handle = sControl;\n    ctrl->dir = FTPLIB_CONTROL;\n    ctrl->ctrl = NULL;\n    ctrl->data = NULL;\n    ctrl->cmode = FTPLIB_DEFMODE;\n    ctrl->idlecb = NULL;\n    ctrl->idletime.tv_sec = ctrl->idletime.tv_usec = 0;\n    ctrl->idlearg = NULL;\n    ctrl->xfered = 0;\n    ctrl->xfered1 = 0;\n    ctrl->cbbytes = 0;\n    if (readresp('2', ctrl) == 0)\n    {\n\tnet_close(sControl);\n\tfree(ctrl->buf);\n\tfree(ctrl);\n\treturn 0;\n    }\n    *nControl = ctrl;\n    return 1;\n}\n\nGLOBALDEF int FtpSetCallback(const FtpCallbackOptions *opt, netbuf *nControl)\n{\n    nControl->idlecb = opt->cbFunc;\n    nControl->idlearg = opt->cbArg;\n    nControl->idletime.tv_sec = opt->idleTime / 1000;\n    nControl->idletime.tv_usec = (opt->idleTime % 1000) * 1000;\n    nControl->cbbytes = opt->bytesXferred;\n    return 1;\n}\nGLOBALDEF int FtpClearCallback(netbuf *nControl)\n{\n    nControl->idlecb = NULL;\n    nControl->idlearg = NULL;\n    nControl->idletime.tv_sec = 0;\n    nControl->idletime.tv_usec = 0;\n    nControl->cbbytes = 0;\n    return 1;\n}\n/*\n * FtpOptions - change connection options\n *\n * returns 1 if successful, 0 on error\n */\nGLOBALDEF int FtpOptions(int opt, long val, netbuf *nControl)\n{\n    int v,rv=0;\n    switch (opt)\n    {\n      case FTPLIB_CONNMODE:\n\tv = (int) val;\n\tif ((v == FTPLIB_PASSIVE) || (v == FTPLIB_PORT))\n\t{\n\t    nControl->cmode = v;\n\t    rv = 1;\n\t}\n\tbreak;\n      case FTPLIB_CALLBACK:\n\tnControl->idlecb = (FtpCallback) val;\n\trv = 1;\n\tbreak;\n      case FTPLIB_IDLETIME:\n\tv = (int) val;\n\trv = 1;\n\tnControl->idletime.tv_sec = v / 1000;\n\tnControl->idletime.tv_usec = (v % 1000) * 1000;\n\tbreak;\n      case FTPLIB_CALLBACKARG:\n\trv = 1;\n\tnControl->idlearg = (void *) val;\n\tbreak;\n      case FTPLIB_CALLBACKBYTES:\n        rv = 1;\n        nControl->cbbytes = (int) val;\n        break;\n    }\n    return rv;\n}\n\n/*\n * FtpSendCmd - send a command and wait for expected response\n *\n * return 1 if proper response received, 0 otherwise\n */\nstatic int FtpSendCmd(const char *cmd, char expresp, netbuf *nControl)\n{\n    char buf[TMP_BUFSIZ];\n    if (nControl->dir != FTPLIB_CONTROL)\n\treturn 0;\n    if (ftplib_debug > 2)\n\tfprintf(stderr,\"%s\\n\",cmd);\n    if ((strlen(cmd) + 3) > sizeof(buf))\n        return 0;\n    sprintf(buf,\"%s\\r\\n\",cmd);\n    if (net_write(nControl->handle,buf,strlen(buf)) <= 0)\n    {\n\tif (ftplib_debug)\n\t    perror(\"write\");\n\treturn 0;\n    }\n    return readresp(expresp, nControl);\n}\n\n/*\n * FtpLogin - log in to remote server\n *\n * return 1 if logged in, 0 otherwise\n */\nGLOBALDEF int FtpLogin(const char *user, const char *pass, netbuf *nControl)\n{\n    char tempbuf[64];\n\n    if (((strlen(user) + 7) > sizeof(tempbuf)) ||\n        ((strlen(pass) + 7) > sizeof(tempbuf)))\n        return 0;\n    sprintf(tempbuf,\"USER %s\",user);\n    if (!FtpSendCmd(tempbuf,'3',nControl))\n    {\n\tif (nControl->response[0] == '2')\n\t    return 1;\n\treturn 0;\n    }\n    sprintf(tempbuf,\"PASS %s\",pass);\n    return FtpSendCmd(tempbuf,'2',nControl);\n}\n\n/*\n * FtpOpenPort - set up data connection\n *\n * return 1 if successful, 0 otherwise\n */\nstatic int FtpOpenPort(netbuf *nControl, netbuf **nData, int mode, int dir)\n{\n    int sData;\n    union {\n\tstruct sockaddr sa;\n\tstruct sockaddr_in in;\n    } sin;\n    struct linger lng = { 0, 0 };\n    unsigned int l;\n    int on=1;\n    netbuf *ctrl;\n    char *cp;\n    unsigned int v[6];\n    char buf[TMP_BUFSIZ];\n\n    if (nControl->dir != FTPLIB_CONTROL)\n\treturn -1;\n    if ((dir != FTPLIB_READ) && (dir != FTPLIB_WRITE))\n    {\n\tsprintf(nControl->response, \"Invalid direction %d\\n\", dir);\n\treturn -1;\n    }\n    if ((mode != FTPLIB_ASCII) && (mode != FTPLIB_IMAGE))\n    {\n\tsprintf(nControl->response, \"Invalid mode %c\\n\", mode);\n\treturn -1;\n    }\n    l = sizeof(sin);\n    if (nControl->cmode == FTPLIB_PASSIVE)\n    {\n\tmemset(&sin, 0, l);\n\tsin.in.sin_family = AF_INET;\n\tif (!FtpSendCmd(\"PASV\",'2',nControl))\n\t    return -1;\n\tcp = strchr(nControl->response,'(');\n\tif (cp == NULL)\n\t    return -1;\n\tcp++;\n\tsscanf(cp,\"%u,%u,%u,%u,%u,%u\",&v[2],&v[3],&v[4],&v[5],&v[0],&v[1]);\n\tsin.sa.sa_data[2] = v[2];\n\tsin.sa.sa_data[3] = v[3];\n\tsin.sa.sa_data[4] = v[4];\n\tsin.sa.sa_data[5] = v[5];\n\tsin.sa.sa_data[0] = v[0];\n\tsin.sa.sa_data[1] = v[1];\n    }\n    else\n    {\n\tif (getsockname(nControl->handle, &sin.sa, (int*)&l) < 0)\n\t{\n\t    if (ftplib_debug)\n\t\tperror(\"getsockname\");\n\t    return -1;\n\t}\n    }\n    sData = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);\n    if (sData == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"socket\");\n\treturn -1;\n    }\n    if (setsockopt(sData,SOL_SOCKET,SO_REUSEADDR,\n\t\t   SETSOCKOPT_OPTVAL_TYPE &on,sizeof(on)) == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"setsockopt\");\n\tnet_close(sData);\n\treturn -1;\n    }\n    if (setsockopt(sData,SOL_SOCKET,SO_LINGER,\n\t\t   SETSOCKOPT_OPTVAL_TYPE &lng,sizeof(lng)) == -1)\n    {\n\tif (ftplib_debug)\n\t    perror(\"setsockopt\");\n\tnet_close(sData);\n\treturn -1;\n    }\n    if (nControl->cmode == FTPLIB_PASSIVE)\n    {\n\tif (connect(sData, &sin.sa, sizeof(sin.sa)) == -1)\n\t{\n\t    if (ftplib_debug)\n\t\tperror(\"connect\");\n\t    net_close(sData);\n\t    return -1;\n\t}\n    }\n    else\n    {\n\tsin.in.sin_port = 0;\n\tif (bind(sData, &sin.sa, sizeof(sin)) == -1)\n\t{\n\t    if (ftplib_debug)\n\t\tperror(\"bind\");\n\t    net_close(sData);\n\t    return -1;\n\t}\n\tif (listen(sData, 1) < 0)\n\t{\n\t    if (ftplib_debug)\n\t\tperror(\"listen\");\n\t    net_close(sData);\n\t    return -1;\n\t}\n\tif (getsockname(sData, &sin.sa, (int*)&l) < 0)\n\t    return -1;\n\tsprintf(buf, \"PORT %d,%d,%d,%d,%d,%d\",\n\t\t(unsigned char) sin.sa.sa_data[2],\n\t\t(unsigned char) sin.sa.sa_data[3],\n\t\t(unsigned char) sin.sa.sa_data[4],\n\t\t(unsigned char) sin.sa.sa_data[5],\n\t\t(unsigned char) sin.sa.sa_data[0],\n\t\t(unsigned char) sin.sa.sa_data[1]);\n\tif (!FtpSendCmd(buf,'2',nControl))\n\t{\n\t    net_close(sData);\n\t    return -1;\n\t}\n    }\n    ctrl = (netbuf*)calloc(1,sizeof(netbuf));\n    if (ctrl == NULL)\n    {\n\tif (ftplib_debug)\n\t    perror(\"calloc\");\n\tnet_close(sData);\n\treturn -1;\n    }\n    if ((mode == 'A') && ((ctrl->buf = (char*)malloc(FTPLIB_BUFSIZ)) == NULL))\n    {\n\tif (ftplib_debug)\n\t    perror(\"calloc\");\n\tnet_close(sData);\n\tfree(ctrl);\n\treturn -1;\n    }\n    ctrl->handle = sData;\n    ctrl->dir = dir;\n    ctrl->idletime = nControl->idletime;\n    ctrl->idlearg = nControl->idlearg;\n    ctrl->xfered = 0;\n    ctrl->xfered1 = 0;\n    ctrl->cbbytes = nControl->cbbytes;\n    ctrl->ctrl = nControl;\n    if (ctrl->idletime.tv_sec || ctrl->idletime.tv_usec || ctrl->cbbytes)\n\tctrl->idlecb = nControl->idlecb;\n    else\n\tctrl->idlecb = NULL;\n    nControl->data = ctrl;\n    *nData = ctrl;\n    return 1;\n}\n\n/*\n * FtpAcceptConnection - accept connection from server\n *\n * return 1 if successful, 0 otherwise\n */\nstatic int FtpAcceptConnection(netbuf *nData, netbuf *nControl)\n{\n    int sData;\n    struct sockaddr addr;\n    unsigned int l;\n    int i;\n    struct timeval tv;\n    fd_set mask;\n    int rv;\n\n    FD_ZERO(&mask);\n    FD_SET((unsigned int)nControl->handle, &mask);\n    FD_SET((unsigned int)nData->handle, &mask);\n    tv.tv_usec = 0;\n    tv.tv_sec = ACCEPT_TIMEOUT;\n    i = nControl->handle;\n    if (i < nData->handle)\n\ti = nData->handle;\n    i = select(i+1, &mask, NULL, NULL, &tv);\n    if (i == -1)\n    {\n        strncpy(nControl->response, strerror(errno),\n                sizeof(nControl->response));\n        net_close(nData->handle);\n        nData->handle = 0;\n        rv = 0;\n    }\n    else if (i == 0)\n    {\n\tstrcpy(nControl->response, \"timed out waiting for connection\");\n\tnet_close(nData->handle);\n\tnData->handle = 0;\n\trv = 0;\n    }\n    else\n    {\n\tif (FD_ISSET(nData->handle, &mask))\n\t{\n\t    l = sizeof(addr);\n\t    sData = accept(nData->handle, &addr, (int*)&l);\n\t    i = errno;\n\t    net_close(nData->handle);\n\t    if (sData > 0)\n\t    {\n\t\trv = 1;\n\t\tnData->handle = sData;\n\t    }\n\t    else\n\t    {\n\t\tstrncpy(nControl->response, strerror(i),\n                        sizeof(nControl->response));\n\t\tnData->handle = 0;\n\t\trv = 0;\n\t    }\n\t}\n\telse if (FD_ISSET(nControl->handle, &mask))\n\t{\n\t    net_close(nData->handle);\n\t    nData->handle = 0;\n\t    readresp('2', nControl);\n\t    rv = 0;\n\t}\n    }\n    return rv;\t\n}\n\n/*\n * FtpAccess - return a handle for a data stream\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpAccess(const char *path, int typ, int mode, netbuf *nControl,\n    netbuf **nData)\n{\n    char buf[TMP_BUFSIZ];\n    int dir;\n    if ((path == NULL) &&\n        ((typ == FTPLIB_FILE_WRITE) || (typ == FTPLIB_FILE_READ)))\n    {\n\tsprintf(nControl->response,\n                \"Missing path argument for file transfer\\n\");\n\treturn 0;\n    }\n    sprintf(buf, \"TYPE %c\", mode);\n    if (!FtpSendCmd(buf, '2', nControl))\n\treturn 0;\n    switch (typ)\n    {\n      case FTPLIB_DIR:\n\tstrcpy(buf,\"NLST\");\n\tdir = FTPLIB_READ;\n\tbreak;\n      case FTPLIB_DIR_VERBOSE:\n\tstrcpy(buf,\"LIST\");\n\tdir = FTPLIB_READ;\n\tbreak;\n      case FTPLIB_FILE_READ:\n\tstrcpy(buf,\"RETR\");\n\tdir = FTPLIB_READ;\n\tbreak;\n      case FTPLIB_FILE_WRITE:\n\tstrcpy(buf,\"STOR\");\n\tdir = FTPLIB_WRITE;\n\tbreak;\n      default:\n\tsprintf(nControl->response, \"Invalid open type %d\\n\", typ);\n\treturn 0;\n    }\n    if (path != NULL)\n    {\n        int i = strlen(buf);\n        buf[i++] = ' ';\n        if ((strlen(path) + i + 1) >= sizeof(buf))\n            return 0;\n        strcpy(&buf[i],path);\n    }\n    if (FtpOpenPort(nControl, nData, mode, dir) == -1)\n\treturn 0;\n    if (!FtpSendCmd(buf, '1', nControl))\n    {\n\tFtpClose(*nData);\n\t*nData = NULL;\n\treturn 0;\n    }\n    if (nControl->cmode == FTPLIB_PORT)\n    {\n\tif (!FtpAcceptConnection(*nData,nControl))\n\t{\n\t    FtpClose(*nData);\n\t    *nData = NULL;\n\t    nControl->data = NULL;\n\t    return 0;\n\t}\n    }\n    return 1;\n}\n\n/*\n * FtpRead - read from a data connection\n */\nGLOBALDEF int FtpRead(void *buf, int max, netbuf *nData)\n{\n    int i;\n    if (nData->dir != FTPLIB_READ)\n\treturn 0;\n    if (nData->buf)\n        i = readline((char*)buf, max, nData);\n    else\n    {\n        i = socket_wait(nData);\n\tif (i != 1)\n\t    return 0;\n        i = net_read(nData->handle, (char*)buf, max);\n    }\n    if (i == -1)\n\treturn 0;\n    nData->xfered += i;\n    if (nData->idlecb && nData->cbbytes)\n    {\n        nData->xfered1 += i;\n        if (nData->xfered1 > nData->cbbytes)\n        {\n\t    if (nData->idlecb(nData, nData->xfered, nData->idlearg) == 0)\n\t\treturn 0;\n            nData->xfered1 = 0;\n        }\n    }\n    return i;\n}\n\n/*\n * FtpWrite - write to a data connection\n */\nGLOBALDEF int FtpWrite(const void *buf, int len, netbuf *nData)\n{\n    int i;\n    if (nData->dir != FTPLIB_WRITE)\n\treturn 0;\n    if (nData->buf)\n    \ti = writeline((char*)buf, len, nData);\n    else\n    {\n        socket_wait(nData);\n        i = net_write(nData->handle, (char*)buf, len);\n    }\n    if (i == -1)\n\treturn 0;\n    nData->xfered += i;\n    if (nData->idlecb && nData->cbbytes)\n    {\n        nData->xfered1 += i;\n        if (nData->xfered1 > nData->cbbytes)\n        {\n            nData->idlecb(nData, nData->xfered, nData->idlearg);\n            nData->xfered1 = 0;\n        }\n    }\n    return i;\n}\n\n/*\n * FtpClose - close a data connection\n */\nGLOBALDEF int FtpClose(netbuf *nData)\n{\n    netbuf *ctrl;\n    switch (nData->dir)\n    {\n      case FTPLIB_WRITE:\n\t/* potential problem - if buffer flush fails, how to notify user? */\n\tif (nData->buf != NULL)\n\t    writeline(NULL, 0, nData);\n      case FTPLIB_READ:\n\tif (nData->buf)\n\t    free(nData->buf);\n\tshutdown(nData->handle,2);\n\tnet_close(nData->handle);\n\tctrl = nData->ctrl;\n\tfree(nData);\n\tctrl->data = NULL;\n\tif (ctrl && ctrl->response[0] != '4' && ctrl->response[0] != '5')\n\t{\n\t    return(readresp('2', ctrl));\n\t}\n\treturn 1;\n      case FTPLIB_CONTROL:\n\tif (nData->data)\n\t{\n\t    nData->ctrl = NULL;\n\t    FtpClose(nData->data);\n\t}\n\tnet_close(nData->handle);\n\tfree(nData);\n\treturn 0;\n    }\n    return 1;\n}\n\n/*\n * FtpSite - send a SITE command\n *\n * return 1 if command successful, 0 otherwise\n */\nGLOBALDEF int FtpSite(const char *cmd, netbuf *nControl)\n{\n    char buf[TMP_BUFSIZ];\n    \n    if ((strlen(cmd) + 7) > sizeof(buf))\n        return 0;\n    sprintf(buf,\"SITE %s\",cmd);\n    if (!FtpSendCmd(buf,'2',nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpSysType - send a SYST command\n *\n * Fills in the user buffer with the remote system type.  If more\n * information from the response is required, the user can parse\n * it out of the response buffer returned by FtpLastResponse().\n *\n * return 1 if command successful, 0 otherwise\n */\nGLOBALDEF int FtpSysType(char *buf, int max, netbuf *nControl)\n{\n    int l = max;\n    char *b = buf;\n    char *s;\n    if (!FtpSendCmd(\"SYST\",'2',nControl))\n\treturn 0;\n    s = &nControl->response[4];\n    while ((--l) && (*s != ' '))\n\t*b++ = *s++;\n    *b++ = '\\0';\n    return 1;\n}\n\n/*\n * FtpMkdir - create a directory at server\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpMkdir(const char *path, netbuf *nControl)\n{\n    char buf[TMP_BUFSIZ];\n\n    if ((strlen(path) + 6) > sizeof(buf))\n        return 0;\n    sprintf(buf,\"MKD %s\",path);\n    if (!FtpSendCmd(buf,'2', nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpChdir - change path at remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpChdir(const char *path, netbuf *nControl)\n{\n    char buf[TMP_BUFSIZ];\n\n    if ((strlen(path) + 6) > sizeof(buf))\n        return 0;\n    sprintf(buf,\"CWD %s\",path);\n    if (!FtpSendCmd(buf,'2',nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpCDUp - move to parent directory at remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpCDUp(netbuf *nControl)\n{\n    if (!FtpSendCmd(\"CDUP\",'2',nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpRmdir - remove directory at remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpRmdir(const char *path, netbuf *nControl)\n{\n    char buf[TMP_BUFSIZ];\n\n    if ((strlen(path) + 6) > sizeof(buf))\n        return 0;\n    sprintf(buf,\"RMD %s\",path);\n    if (!FtpSendCmd(buf,'2',nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpPwd - get working directory at remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpPwd(char *path, int max, netbuf *nControl)\n{\n    int l = max;\n    char *b = path;\n    char *s;\n    if (!FtpSendCmd(\"PWD\",'2',nControl))\n\treturn 0;\n    s = strchr(nControl->response, '\"');\n    if (s == NULL)\n\treturn 0;\n    s++;\n    while ((--l) && (*s) && (*s != '\"'))\n\t*b++ = *s++;\n    *b++ = '\\0';\n    return 1;\n}\n\n/*\n * FtpXfer - issue a command and transfer data\n *\n * return 1 if successful, 0 otherwise\n */\nstatic int FtpXfer(const char *localfile, const char *path,\n\tnetbuf *nControl, int typ, int mode)\n{\n    int l,c;\n    char *dbuf;\n    FILE *local = NULL;\n    netbuf *nData;\n    int rv=1;\n\n    if (localfile != NULL)\n    {\n\tchar ac[4];\n\tmemset( ac, 0, sizeof(ac) );\n\tif (typ == FTPLIB_FILE_WRITE)\n\t    ac[0] = 'r';\n\telse\n\t    ac[0] = 'w';\n\tif (mode == FTPLIB_IMAGE)\n\t    ac[1] = 'b';\n\tlocal = fopen(localfile, ac);\n\tif (local == NULL)\n\t{\n\t    strncpy(nControl->response, strerror(errno),\n                    sizeof(nControl->response));\n\t    return 0;\n\t}\n    }\n    if (local == NULL)\n\tlocal = (typ == FTPLIB_FILE_WRITE) ? stdin : stdout;\n    if (!FtpAccess(path, typ, mode, nControl, &nData))\n    {\n\tif (localfile)\n\t{\n\t    fclose(local);\n\t    if ( typ == FTPLIB_FILE_READ )\n\t\tunlink(localfile);\n\t}\n\treturn 0;\n    }\n    dbuf = (char*)malloc(FTPLIB_BUFSIZ);\n    if (typ == FTPLIB_FILE_WRITE)\n    {\n\twhile ((l = fread(dbuf, 1, FTPLIB_BUFSIZ, local)) > 0)\n\t{\n\t    if ((c = FtpWrite(dbuf, l, nData)) < l)\n\t    {\n\t\tprintf(\"short write: passed %d, wrote %d\\n\", l, c);\n\t\trv = 0;\n\t\tbreak;\n\t    }\n\t}\n    }\n    else\n    {\n    \twhile ((l = FtpRead(dbuf, FTPLIB_BUFSIZ, nData)) > 0)\n\t{\n\t    if (fwrite(dbuf, 1, l, local) == 0)\n\t    {\n\t\tif (ftplib_debug)\n\t\t    perror(\"localfile write\");\n\t\trv = 0;\n\t\tbreak;\n\t    }\n\t}\n    }\n    free(dbuf);\n    fflush(local);\n    if (localfile != NULL)\n\tfclose(local);\n    FtpClose(nData);\n    return rv;\n}\n\n/*\n * FtpNlst - issue an NLST command and write response to output\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpNlst(const char *outputfile, const char *path,\n\tnetbuf *nControl)\n{\n    return FtpXfer(outputfile, path, nControl, FTPLIB_DIR, FTPLIB_ASCII);\n}\n\n/*\n * FtpDir - issue a LIST command and write response to output\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpDir(const char *outputfile, const char *path, netbuf *nControl)\n{\n    return FtpXfer(outputfile, path, nControl, FTPLIB_DIR_VERBOSE, FTPLIB_ASCII);\n}\n\n/*\n * FtpSize - determine the size of a remote file\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpSize(const char *path, unsigned int *size, char mode, netbuf *nControl)\n{\n    char cmd[TMP_BUFSIZ];\n    int resp,rv=1;\n    unsigned int sz;\n\n    if ((strlen(path) + 7) > sizeof(cmd))\n        return 0;\n    sprintf(cmd, \"TYPE %c\", mode);\n    if (!FtpSendCmd(cmd, '2', nControl))\n\treturn 0;\n    sprintf(cmd,\"SIZE %s\",path);\n    if (!FtpSendCmd(cmd,'2',nControl))\n\trv = 0;\n    else\n    {\n\tif (sscanf(nControl->response, \"%d %u\", &resp, &sz) == 2)\n\t    *size = sz;\n\telse\n\t    rv = 0;\n    }   \n    return rv;\n}\n\n#if defined(__UINT64_MAX)\n/*\n * FtpSizeLong - determine the size of a remote file\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpSizeLong(const char *path, fsz_t *size, char mode, netbuf *nControl)\n{\n    char cmd[TMP_BUFSIZ];\n    int resp,rv=1;\n    fsz_t sz;\n\n    if ((strlen(path) + 7) > sizeof(cmd))\n        return 0;\n    sprintf(cmd, \"TYPE %c\", mode);\n    if (!FtpSendCmd(cmd, '2', nControl))\n\treturn 0;\n    sprintf(cmd,\"SIZE %s\",path);\n    if (!FtpSendCmd(cmd,'2',nControl))\n\trv = 0;\n    else\n    {\n\tif (sscanf(nControl->response, \"%d %\" PRIu64 \"\", &resp, &sz) == 2)\n\t    *size = sz;\n\telse\n\t    rv = 0;\n    }   \n    return rv;\n}\n#endif\n\n/*\n * FtpModDate - determine the modification date of a remote file\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpModDate(const char *path, char *dt, int max, netbuf *nControl)\n{\n    char buf[TMP_BUFSIZ];\n    int rv = 1;\n\n    if ((strlen(path) + 7) > sizeof(buf))\n        return 0;\n    sprintf(buf,\"MDTM %s\",path);\n    if (!FtpSendCmd(buf,'2',nControl))\n\trv = 0;\n    else\n\tstrncpy(dt, &nControl->response[4], max);\n    return rv;\n}\n\n/*\n * FtpGet - issue a GET command and write received data to output\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpGet(const char *outputfile, const char *path,\n\tchar mode, netbuf *nControl)\n{\n    return FtpXfer(outputfile, path, nControl, FTPLIB_FILE_READ, mode);\n}\n\n/*\n * FtpPut - issue a PUT command and send data from input\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpPut(const char *inputfile, const char *path, char mode,\n\tnetbuf *nControl)\n{\n    return FtpXfer(inputfile, path, nControl, FTPLIB_FILE_WRITE, mode);\n}\n\n/*\n * FtpRename - rename a file at remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpRename(const char *src, const char *dst, netbuf *nControl)\n{\n    char cmd[TMP_BUFSIZ];\n\n    if (((strlen(src) + 7) > sizeof(cmd)) ||\n        ((strlen(dst) + 7) > sizeof(cmd)))\n        return 0;\n    sprintf(cmd,\"RNFR %s\",src);\n    if (!FtpSendCmd(cmd,'3',nControl))\n\treturn 0;\n    sprintf(cmd,\"RNTO %s\",dst);\n    if (!FtpSendCmd(cmd,'2',nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpDelete - delete a file at remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF int FtpDelete(const char *fnm, netbuf *nControl)\n{\n    char cmd[TMP_BUFSIZ];\n\n    if ((strlen(fnm) + 7) > sizeof(cmd))\n        return 0;\n    sprintf(cmd,\"DELE %s\",fnm);\n    if (!FtpSendCmd(cmd,'2', nControl))\n\treturn 0;\n    return 1;\n}\n\n/*\n * FtpQuit - disconnect from remote\n *\n * return 1 if successful, 0 otherwise\n */\nGLOBALDEF void FtpQuit(netbuf *nControl)\n{\n    if (nControl->dir != FTPLIB_CONTROL)\n\treturn;\n    FtpSendCmd(\"QUIT\",'2',nControl);\n    net_close(nControl->handle);\n    free(nControl->buf);\n    free(nControl);\n}\n\n// MG: FIXUP TO GET THINGS TO COMPILE\n\t#pragma warning( pop )\n\n#endif /* FTPLIB_IMPLEMENTATION */\n"
        },
        {
          "name": "hashtable.h",
          "type": "blob",
          "size": 30.7529296875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nhashtable.h - v2.0 - Cache efficient hash table implementation for C/C++.\n\nDo this:\n    #define HASHTABLE_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef hashtable_h\n#define hashtable_h\n\n#ifndef HASHTABLE_U32\n    #define HASHTABLE_U32 unsigned int\n#endif\n\ntypedef struct hashtable_t hashtable_t;\n\nvoid hashtable_init( hashtable_t* table, int key_size, int item_size, int initial_capacity, void* memctx );\nvoid hashtable_term( hashtable_t* table );\n\nvoid hashtable_insert( hashtable_t* table, HASHTABLE_U32 hash, void const* key, void const* item );\nvoid hashtable_remove( hashtable_t* table, HASHTABLE_U32 hash, void const* key );\nvoid hashtable_clear( hashtable_t* table );\n\nvoid* hashtable_find( hashtable_t const* table, HASHTABLE_U32 hash, void const* key );\n\nint hashtable_count( hashtable_t const* table );\nvoid* hashtable_items( hashtable_t const* table );\nvoid const* hashtable_keys( hashtable_t const* table );\n\nvoid hashtable_swap( hashtable_t* table, int index_a, int index_b );\n\n\n#endif /* hashtable_h */\n\n/*\n\nuint32_t hash_u32( uint32_t key ) {\n    key = ~key + ( key << 15 );\n    key = key ^ ( key >> 12 );\n    key = key + ( key << 2 );\n    key = key ^ ( key >> 4 );\n    key = (key + ( key << 3 ) ) + ( key << 11 );\n    key = key ^ ( key >> 16);\n    return key;\n}\n\n\nuint32_t hash_u64( uint64_t key ) {\n    key = ( ~key ) + ( key << 18 );\n    key = key ^ ( key >> 31 );\n    key = ( key + ( key << 2 ) ) + ( key << 4 );\n    key = key ^ ( key >> 11 );\n    key = key + ( key << 6 );\n    key = key ^ ( key >> 22 );  \n    return (uint32_t) key;\n}\n\n\nuint32_t hash_str( char const* key ) {\n    uint32_t hash = 5381u; \n    for( char const* s = key; *s != \\0; ++s ) {\n        hash = ( ( hash << 5u ) + hash ) ^ (*s);\n    }\n    return hash;\n}\n\n\nuint32_t murmur_hash( const void * key, int len, uint32_t seed ) {\n\tuint32_t const m = 0x5bd1e995;\n\tint const r = 24;\n\tuint32_t h = seed ^ len;\n\t\n    uint8_t const* data = (uint8_t const*) key;\n\twhile( len >= 4 ) {\n\t\t#ifdef PLATFORM_BIG_ENDIAN\n\t\t\tuint32_t k = ( data[0] ) + ( data[1] << 8 ) + ( data[2] << 16 ) + ( data[3] << 24 );\n\t\t#else\n\t\t\tuint32_t k = *(uint32_t *)data;\n\t\t#endif\n\n\t\tk *= m;\n\t\tk ^= k >> r;\n\t\tk *= m;\n\n\t\th *= m;\n\t\th ^= k;\n\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\n    switch(len) {\n        case 3: h ^= data[2] << 16;\n        case 2: h ^= data[1] << 8;\n        case 1: h ^= data[0];\n                h *= m;\n\t};\n\n\th ^= h >> 13;\n\th *= m;\n\th ^= h >> 15;\n\n\treturn h;\n}\n\n*/\n\n/**\n\nhashtable.h\n===========\n\nCache efficient hash table implementation for C/C++.\n\n\nExample\n-------\n\n    #define HASHTABLE_IMPLEMENTATION\n    #include \"hashtable.h\"\n\n    #include <stdio.h> // for printf\n\n    int main( int argc, char** argv ) {\n        // define some example key and value types\n        typedef struct key_t { int a, b, c; } key_t;\n        typedef struct value_t { \n            char id[ 64 ]; \n            float x, y, z; \n            int n[ 250 ]; \n            } value_t;\n\n        // create a couple of sample keys \n        // (don't bother to fill in the fields for this sample)\n        key_t* key_a = (key_t*)malloc( sizeof( key_t ) );\n        key_t* key_b = (key_t*)malloc( sizeof( key_t ) );\n\n        hashtable_t table;\n        hashtable_init( &table, sizeof( value_t ), 256, 0 );\n\n        {\n        // values are copied into the table, not stored by pointer\n        // (don't bother to fill in all the fields for this sample)\n        value_t value_a = { \"Item A\" };\n        value_t value_b = { \"Item B\" };\n        hashtable_insert( &table, (HASHTABLE_U64)(uintptr_t)key_a, &value_a );\n        hashtable_insert( &table, (HASHTABLE_U64)(uintptr_t)key_b, &value_b );\n        }\n\n        // find the values by key\n        value_t* value_a = (value_t*)hashtable_find( &table, (HASHTABLE_U64)(uintptr_t)key_a );\n        printf( \"First item: %s\\n\", value_a->id );   \n        value_t* value_b = (value_t*)hashtable_find( &table, (HASHTABLE_U64)(uintptr_t)key_b );\n        printf( \"Second item: %s\\n\", value_b->id );\n\n        // remove one of the items\n        hashtable_remove( &table, (HASHTABLE_U64)(uintptr_t)key_a );\n\n        // it is possible to enumerate keys and values\n        int count = hashtable_count( &table );\n        HASHTABLE_U64 const* keys = hashtable_keys( &table );\n        value_t* items = (value_t*)hashtable_items( &table );\n        printf( \"\\nEnumeration:\\n\" );\n        for( int i = 0; i < count; ++i ) {\n            printf( \"  0x%X : %s\\n\", (int) keys[ i ], items[ i ].id );\n        }\n\n        // cleanup\n        hashtable_term( &table );\n        free( key_b );\n        free( key_a );\n        return 0;\n        }\n\n\nAPI Documentation\n-----------------\n\nhashtable.h is a small library for storing values in a table and access them efficiently by a 64-bit key. It is a \nsingle-header library, and does not need any .lib files or other binaries, or any build scripts. To use it, you just \ninclude hashtable.h to get the API declarations. To  get the definitions, you must include hashtable.h from *one* single \nC or C++ file, and #define the symbol `HASHTABLE_IMPLEMENTATION` before you do. \n\nThe key value must be unique per entry, and is hashed for efficient lookup using an internal hashing algorithm. This\nlibrary does not support custom key types, so typically pointers or handles are used as key values.\n\nThe library is written with efficiency in mind. Data and keys are stored in separate structures, for better cache \ncoherency, and hash collisions are resolved with open addressing/linear probing using the next available slot, which is\nalso good for the cache. \n\n\n### Customization\n\nThere are a few different things in hashtable.h which are configurable by #defines. Most of the API use the `int` data \ntype, for integer values where the exact size is not important. However, for some functions, it specifically makes use \nof 32 and 64 bit data types. These default to using `unsigned int` and `unsigned long long` by default, but can be\nredefined by #defining HASHTABLE_U32 and HASHTABLE_U64 respectively, before including hashtable.h. This is useful if \nyou, for  example, use the types from `<stdint.h>` in the rest of your program, and you want hashtable.h to use \ncompatible types. In this case, you would include hashtable.h using the following code:\n\n    #define HASHTABLE_U32 uint32_t\n    #define HASHTABLE_U64 uint64_t\n    #include \"hashtable.h\"\n\nNote that when customizing the data types, you need to use the same definition in every place where you include \nhashtable.h, as they affect the declarations as well as the definitions.\n\nThe rest of the customizations only affect the implementation, so will only need to be defined in the file where you\nhave the #define HASHTABLE_IMPLEMENTATION.\n\nNote that if all customizations are utilized, hashtable.h will include no external files whatsoever, which might be \nuseful if you need full control over what code is being built.\n\n\n#### size_t\n\nInternally, the hashtable.h implementation makes use of the standard `size_t` data type. This requires including the\nc runtime library header `<stddef.h>`. To allow full configurability, and avoid hashtable.h including stddef.h, you can \nspecify which type hashtable.h should use for its size_t, by #defining HASHTABLE_SIZE_T, like this:\n\n    #define HASHTABLE_IMPLEMENTATION\n    #define HASHTABLE_SIZE_T uint64_t\n    #include \"hashtable.h\"\n\nIf not specified, hashtable.h will by default include stddef.h and use the standard `size_t` type.\n\n\n#### Custom memory allocators\n\nTo store the internal data structures, hashtable.h needs to do dynamic allocation by calling `malloc`. Programs might \nwant to keep track of allocations done, or use custom defined pools to allocate memory from. hashtable.h allows for \nspecifying custom memory allocation functions for `malloc` and `free`. This is done with the following code:\n\n    #define HASHTABLE_IMPLEMENTATION\n    #define HASHTABLE_MALLOC( ctx, size ) ( my_custom_malloc( ctx, size ) )\n    #define HASHTABLE_FREE( ctx, ptr ) ( my_custom_free( ctx, ptr ) )\n    #include \"hashtable.h\"\n\nwhere `my_custom_malloc` and `my_custom_free` are your own memory allocation/deallocation functions. The `ctx` parameter\nis an optional parameter of type `void*`. When `hashtable_init` is called, you can pass in a `memctx` parameter, which \ncan be a pointer to anything you like, and which will be passed through as the `ctx` parameter to every  \n`HASHTABLE_MALLOC`/`HASHTABLE_FREE` call. For example, if you are doing memory tracking, you can pass a pointer to your \ntracking data as `memctx`, and in your custom allocation/deallocation function, you can cast the `ctx` param back to the \nright type, and access the tracking data.\n\nIf no custom allocator is defined, hashtable.h will default to `malloc` and `free` from the C runtime library.\n\n\n#### Custom assert\n\nhashtable.h makes use of asserts to report usage errors and failed allocation errors. By default, it makes use of the C \nruntime library `assert` macro, which only executes in debug builds. However, it allows for substituting with your own\nassert function or macro using the following code:\n\n    #define HASHTABLE_IMPLEMENTATION\n    #define HASHTABLE_ASSERT( condition ) ( my_custom_assert( condition ) )\n    #include \"hashtable.h\"\n\nNote that if you only want the asserts to trigger in debug builds, you must add a check for this in your custom assert.\n\n\n#### Custom C runtime functions\n\nThe library makes use of two additional functions from the C runtime library, and for full flexibility, it allows you \nto substitute them for your own. Here's an example:\n\n    #define HASHTABLE_IMPLEMENTATION\n    #define HASHTABLE_MEMCPY( dst, src, cnt ) ( my_memcpy_func( dst, src, cnt ) )\n    #define HASHTABLE_MEMSET( ptr, val, cnt ) ( my_memset_func( ptr, val, cnt ) )\n    #include \"hashtable.h\"\n\nIf no custom function is defined, hashtable.h will default to the C runtime library equivalent.\n\n\nhashtable_init\n--------------\n\n    void hashtable_init( hashtable_t* table, int item_size, int initial_capacity, void* memctx )\n\nInitialize a hashtable instance. `item_size` specifies the size, in bytes, of the data type holding a single item stored\nin the table. `initial_capacity` is the number of items to allocate storage for initially - capacity will automatically\ngrow as needed, by reallocating memory.\n\n\nhashtable_term\n--------------\n    \n    void hashtable_term( hashtable_t* table )\n\nTerminates a hashtable instance, releasing all memory used by it. No further calls to the hashtable API are valid until\nthe instance is reinitialized by another call to `hashtable_init`.\n\n\nhashtable_insert\n----------------\n\n    void hashtable_insert( hashtable_t* table, HASHTABLE_U64 key, void const* item )\n\nInserts a data item into the hashtable, associating it with the specified key. The item is copied into the hashtable, \nrather than just storing the `item` pointer, so the `item` pointer can be safely released after the call to \n`hashtable_insert`. The value of `key` must be unique - it is not valid to store two items with the same key value. An\nassert is triggered if trying to add a key which already exists, which means that if the default assert is used, it will\nonly be checked in debug builds - in release builds, it is up to the calling code to ensure this doesn't happen, or the\nhashtable will be left in an undefined state.\n\n\nhashtable_remove\n----------------\n\n    void hashtable_remove( hashtable_t* table, HASHTABLE_U64 key )\n\nRemoves the item associated with the specified key, and the instance of the key itself, from the hashtable. If the \nspecified key could not be found, an assert is triggered.\n\n\nhashtable_clear\n---------------\n\n    void hashtable_clear( hashtable_t* table )\n\nRemoves all the items stored in the hashtable, without deallocating any of the memory it has allocated.\n\n\nhashtable_find\n--------------\n\n    void* hashtable_find( hashtable_t const* table, HASHTABLE_U64 key )\n\nReturns a pointer to the item associated with the specified key, or NULL it the key was not found. The lookup is \ndesigned for efficiency, and for minimizing cache missed.\n\n\nhashtable_count\n---------------\n\n    int hashtable_count( hashtable_t const* table )\n\nReturns the number of items currently held in the table.\n\n\nhashtable_items\n---------------\n\n    void* hashtable_items( hashtable_t const* table )\n\nReturns a pointer to the items currently held in the table. All items are stored in a contiguous memory block, and you\ncan get to the next item be moving the pointer `item_size` bytes forward, where `item_size` is the same value as passed\nto hash_table_init. The easiest way to acces items is to cast the return value to the correct type and just index it as\na normal array. It contains as many items as returned by `hashtable_count`.\n\n\nhashtable_keys\n--------------\n\n    HASHTABLE_U64 const* hashtable_keys( hashtable_t const* table )\n\nReturns a pointer to the keys currently held in the table, in the same order as the items returned from \n`hashtable_items`. Can be indexed as an array with as many elements as returned by `hashtable_count`.\n\n\nhashtable_swap\n--------------\n\n    void hashtable_swap( hashtable_t* table, int index_a, int index_b )\n\nSwaps the specified item/key pairs, and updates the hash lookup for both. Can be used to re-order the contents, as\nretrieved by calling `hashtable_items` and `hashtable_keys`, while keeping the hashing intact.\n\n*/\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifndef hashtable_t_h\n#define hashtable_t_h\n\nstruct hashtable_internal_slot_t\n    {\n    HASHTABLE_U32 key_hash;\n    int item_index;\n    int base_count;\n    };\n\nstruct hashtable_t\n    {\n    void* memctx;\n    int count;\n    int key_size;\n    int item_size;\n\n    struct hashtable_internal_slot_t* slots;\n    int slot_capacity;\n    int prime_index;\n\n    void* items_key;\n    int* items_slot;\n    void* items_data;\n    int item_capacity;\n\n    void* swap_temp;\n    };\n\n#endif /* hashtable_t_h */\n\n\n#ifdef HASHTABLE_IMPLEMENTATION\n#undef HASHTABLE_IMPLEMENTATION\n\n#ifndef HASHTABLE_SIZE_T\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stddef.h>\n    #define HASHTABLE_SIZE_T size_t\n#endif\n\n#ifndef HASHTABLE_ASSERT\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <assert.h>\n    #define HASHTABLE_ASSERT( x ) assert( x )\n#endif\n\n#ifndef HASHTABLE_MEMCPY\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define HASHTABLE_MEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef HASHTABLE_KEYCOPY\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define HASHTABLE_KEYCOPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef HASHTABLE_ITEMCOPY\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define HASHTABLE_ITEMCOPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef HASHTABLE_KEYCMP\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define HASHTABLE_KEYCMP( a, b, len ) ( memcmp( a, b, len ) == 0 )\n#endif \n\n#ifndef HASHTABLE_MALLOC\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define HASHTABLE_MALLOC( ctx, size ) ( malloc( size ) )\n    #define HASHTABLE_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\nstatic HASHTABLE_U32 hashtable_internal_pow2ceil( HASHTABLE_U32 v )\n    {\n    --v;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    ++v;\n    v += ( v == 0 );\n    return v;\n    }\n\n\nstatic int hashtable_internal_primes[] = { 31, 67, 127, 257, 509, 1021, 2053, 4099, 8191, 16381, 32771, 65537, 131071, \n    262147, 524287, 1048573, 2097143, 4194301, 8388617, 16777213, 33554467, 67108859, 134217757, 268435459, 536870909, \n    1073741827, 2147483647 };\n\n\nvoid hashtable_init( hashtable_t* table, int key_size, int item_size, int initial_capacity, void* memctx )\n    {\n    initial_capacity = (int)hashtable_internal_pow2ceil( initial_capacity >=0 ? (HASHTABLE_U32) initial_capacity : 32U );\n    int prime_index = 0;\n    while( hashtable_internal_primes[ prime_index ] < initial_capacity + initial_capacity / 2 ) ++prime_index;\n    \n    table->memctx = memctx;\n    table->count = 0;\n    table->key_size = key_size;\n    table->item_size = item_size;\n    table->slot_capacity = hashtable_internal_primes[ prime_index ];\n    table->prime_index = prime_index;\n\n    if( key_size > 0 )\n        {\n        int slots_size = (int)( table->slot_capacity * sizeof( *table->slots ) );\n        table->slots = (struct hashtable_internal_slot_t*) HASHTABLE_MALLOC( table->memctx, (HASHTABLE_SIZE_T) slots_size );\n        HASHTABLE_ASSERT( table->slots );\n\n        for( int i = 0; i < table->slot_capacity; ++i  )\n            {\n            table->slots[ i ].base_count = 0;\n            table->slots[ i ].item_index = -1;\n            }\n        }\n    else\n        {\n        table->slots = 0;\n        }\n\n    table->item_capacity = initial_capacity;\n    table->items_key = HASHTABLE_MALLOC( table->memctx, \n        table->item_capacity * ( table->key_size + sizeof( *table->items_slot ) + table->item_size ) + \n        ( table->key_size > table->item_size ? table->key_size : table->item_size ) );\n    HASHTABLE_ASSERT( table->items_key );\n    table->items_slot = (int*)( ( (uintptr_t) table->items_key ) + table->key_size * table->item_capacity );\n    table->items_data = (void*)( table->items_slot + table->item_capacity );\n    table->swap_temp = (void*)( ( (uintptr_t) table->items_data ) + table->item_size * table->item_capacity ); \n    }\n\n\nvoid hashtable_term( hashtable_t* table )\n    {\n    HASHTABLE_FREE( table->memctx, table->items_key );\n    HASHTABLE_FREE( table->memctx, table->slots );\n    }\n\n\n\nstatic int hashtable_internal_find_slot( hashtable_t const* table, HASHTABLE_U32 hash, void const* key )\n    {\n    HASHTABLE_U32 slot_capacity = (HASHTABLE_U32) table->slot_capacity;\n    int const base_slot = (int)( hash % slot_capacity );\n\n    int base_count = table->slots[ base_slot ].base_count;\n    int slot = base_slot;\n    while( base_count > 0 )\n        {\n        if( table->slots[ slot ].item_index >= 0 )\n            {\n            HASHTABLE_U32 slot_hash = table->slots[ slot ].key_hash;\n            int slot_base = (int)( slot_hash % slot_capacity );\n            if( slot_base == base_slot ) \n                {\n                HASHTABLE_ASSERT( base_count > 0 );\n                if( slot_hash == hash )\n                    {\n                    void const* slot_key = (void const*)( ( (uintptr_t) table->items_key ) + table->key_size * table->slots[ slot ].item_index );\n                    if( HASHTABLE_KEYCMP( slot_key, key, table->key_size ) )\n                        return slot;\n                    }\n                --base_count;\n                }\n            }\n        slot = (int)( ( slot + 1 ) % slot_capacity );\n        }   \n\n    return -1;\n    }\n\n\nstatic void hashtable_internal_expand_slots( hashtable_t* table )\n    {\n    if( !table->slots ) return;\n\n    int const old_capacity = table->slot_capacity;\n    struct hashtable_internal_slot_t* old_slots = table->slots;\n\n    table->slot_capacity = hashtable_internal_primes[ ++table->prime_index ];\n    HASHTABLE_U32 slot_capacity = (HASHTABLE_U32) table->slot_capacity;\n\n    int const size = (int)( table->slot_capacity * sizeof( *table->slots ) );\n    table->slots = (struct hashtable_internal_slot_t*) HASHTABLE_MALLOC( table->memctx, (HASHTABLE_SIZE_T) size );\n    HASHTABLE_ASSERT( table->slots );\n    for( int i = 0; i < table->slot_capacity; ++i  )\n        {\n        table->slots[ i ].base_count = 0;\n        table->slots[ i ].item_index = -1;\n        }\n\n    for( int i = 0; i < old_capacity; ++i )\n        {\n        if( old_slots[ i ].item_index >= 0 )\n            {\n            HASHTABLE_U32 const hash = old_slots[ i ].key_hash;\n            int const base_slot = (int)( hash % slot_capacity );\n            int slot = base_slot;\n            while( table->slots[ slot ].item_index >= 0 )\n                slot = (int)( ( slot + 1 ) % slot_capacity );\n            table->slots[ slot ].key_hash = hash;\n            int item_index = old_slots[ i ].item_index;\n            table->slots[ slot ].item_index = item_index;\n            table->items_slot[ item_index ] = slot; \n            ++table->slots[ base_slot ].base_count;\n            }               \n        }\n\n    HASHTABLE_FREE( table->memctx, old_slots );\n    }\n\n\nstatic void hashtable_internal_expand_items( hashtable_t* table )\n    {\n    table->item_capacity *= 2;\n    \n    void* const new_items_key = HASHTABLE_MALLOC( table->memctx, \n        table->item_capacity * ( table->key_size + sizeof( *table->items_slot ) + table->item_size ) + \n        ( table->key_size > table->item_size ? table->key_size : table->item_size ) );\n    HASHTABLE_ASSERT( new_items_key );\n\n    int* const new_items_slot = (int*)( ( (uintptr_t) new_items_key ) + table->key_size * table->item_capacity );\n    void* const new_items_data = (void*)( new_items_slot + table->item_capacity );\n    void* const new_swap_temp = (void*)( ( (uintptr_t) new_items_data ) + table->item_size * table->item_capacity ); \n\n    HASHTABLE_MEMCPY( new_items_key, table->items_key, table->count * table->key_size );\n    HASHTABLE_MEMCPY( new_items_slot, table->items_slot, table->count * sizeof( *table->items_slot ) );\n    HASHTABLE_MEMCPY( new_items_data, table->items_data, (HASHTABLE_SIZE_T) table->count * table->item_size );\n    \n    HASHTABLE_FREE( table->memctx, table->items_key );\n\n    table->items_key = new_items_key;\n    table->items_slot = new_items_slot;\n    table->items_data = new_items_data;\n    table->swap_temp = new_swap_temp;\n    }\n\n\nvoid hashtable_insert( hashtable_t* table, HASHTABLE_U32 hash, void const* key, void const* item )\n    {\n    if( !table->slots ) \n        {\n        if( table->count >= table->item_capacity )\n            hashtable_internal_expand_items( table );\n\n        void* dest_item = (void*)( ( (uintptr_t) table->items_data ) + table->count * table->item_size );\n        HASHTABLE_ITEMCOPY( dest_item, item, (HASHTABLE_SIZE_T) table->item_size );\n        ++table->count;\n        return;\n        }\n\n    HASHTABLE_ASSERT( hashtable_internal_find_slot( table, hash, key ) < 0 );\n\n    if( table->count >= ( table->slot_capacity - table->slot_capacity / 3 ) )\n        hashtable_internal_expand_slots( table );\n        \n    HASHTABLE_U32 slot_capacity = (HASHTABLE_U32) table->slot_capacity;\n    int const base_slot = (int)( hash % slot_capacity );\n    int base_count = table->slots[ base_slot ].base_count;\n    int slot = base_slot;\n    int first_free = slot;\n    while( base_count )\n        {\n        if( table->slots[ slot ].item_index < 0 && table->slots[ first_free ].item_index >= 0 ) first_free = slot;\n        HASHTABLE_U32 const slot_hash = table->slots[ slot ].key_hash;\n        int slot_base = (int)( slot_hash % slot_capacity );\n        if( slot_base == base_slot ) \n            --base_count;\n        slot = (int)( ( slot + 1 ) % slot_capacity );\n        }       \n\n    slot = first_free;\n    while( table->slots[ slot ].item_index >= 0  )\n        slot = (int)( ( slot + 1 ) % slot_capacity );\n\n    if( table->count >= table->item_capacity )\n        hashtable_internal_expand_items( table );\n\n    HASHTABLE_ASSERT( table->slots[ slot ].item_index < 0 && (int)( hash % slot_capacity ) == (HASHTABLE_U32) base_slot );\n    table->slots[ slot ].key_hash = hash;\n    table->slots[ slot ].item_index = table->count;\n    ++table->slots[ base_slot ].base_count;\n\n        \n    void* dest_item = (void*)( ( (uintptr_t) table->items_data ) + table->count * table->item_size );\n    HASHTABLE_ITEMCOPY( dest_item, item, (HASHTABLE_SIZE_T) table->item_size );\n    void* dest_key = (void*)( ( (uintptr_t) table->items_key ) + table->count * table->key_size );\n    HASHTABLE_KEYCOPY( dest_key, key, (HASHTABLE_SIZE_T) table->key_size );\n    table->items_slot[ table->count ] = slot;\n    ++table->count;\n    } \n\n\nvoid hashtable_remove( hashtable_t* table, HASHTABLE_U32 hash, void const* key )\n    {\n    if( table->slots )\n        {\n        int const slot = hashtable_internal_find_slot( table, hash, key );\n        HASHTABLE_ASSERT( slot >= 0 );\n\n        HASHTABLE_U32 slot_capacity = (HASHTABLE_U32) table->slot_capacity;\n        int const base_slot = (int)( hash % slot_capacity );\n        int index = table->slots[ slot ].item_index;\n        int last_index = table->count - 1;\n        --table->slots[ base_slot ].base_count;\n        table->slots[ slot ].item_index = -1;\n\n        if( index != last_index )\n            {\n            void* dst_key = (void*)( ( (uintptr_t) table->items_key ) + index * table->key_size );\n            void* src_key = (void*)( ( (uintptr_t) table->items_key ) + last_index * table->key_size );\n            HASHTABLE_KEYCOPY( dst_key, src_key, (HASHTABLE_SIZE_T) table->key_size );\n            table->items_slot[ index ] = table->items_slot[ last_index ];\n            void* dst_item = (void*)( ( (uintptr_t) table->items_data ) + index * table->item_size );\n            void* src_item = (void*)( ( (uintptr_t) table->items_data ) + last_index * table->item_size );\n            HASHTABLE_ITEMCOPY( dst_item, src_item, (HASHTABLE_SIZE_T) table->item_size );\n            table->slots[ table->items_slot[ last_index ] ].item_index = index;\n            }\n        }\n    --table->count;\n    } \n\n\nvoid hashtable_clear( hashtable_t* table )\n    {\n    table->count = 0;\n    if( table->slots )\n        {\n        for( int i = 0; i < table->slot_capacity; ++i  )\n            {\n            table->slots[ i ].base_count = 0;\n            table->slots[ i ].item_index = -1;\n            }  \n        }\n    }\n\n\nvoid* hashtable_find( hashtable_t const* table, HASHTABLE_U32 hash, void const* key )\n    {\n    int const slot = table->slots ? hashtable_internal_find_slot( table, hash, key ) : -1;\n    if( slot < 0 ) return 0;\n\n    int const index = table->slots[ slot ].item_index;\n    void* const item = (void*)( ( (uintptr_t) table->items_data ) + index * table->item_size );\n    return item;\n    }\n\n\nint hashtable_count( hashtable_t const* table )\n    {\n    return table->count;\n    }\n\n\nvoid* hashtable_items( hashtable_t const* table )\n    {\n    return table->items_data;\n    }\n\n\nvoid const* hashtable_keys( hashtable_t const* table )\n    {\n    return table->items_key;\n    }\n\n\nvoid hashtable_swap( hashtable_t* table, int index_a, int index_b )\n    {\n    if( index_a < 0 || index_a >= table->count || index_b < 0 || index_b >= table->count ) return;\n\n    int slot_a = table->items_slot[ index_a ];\n    int slot_b = table->items_slot[ index_b ];\n\n    table->items_slot[ index_a ] = slot_b;\n    table->items_slot[ index_b ] = slot_a;\n\n    void* key_a = (void*)( ( (uintptr_t) table->items_key ) + index_a * table->key_size );\n    void* key_b = (void*)( ( (uintptr_t) table->items_key ) + index_b * table->key_size );\n    HASHTABLE_KEYCOPY( table->swap_temp, key_a, table->key_size );\n    HASHTABLE_KEYCOPY( key_a, key_b, table->key_size );\n    HASHTABLE_KEYCOPY( key_b, table->swap_temp, table->key_size );\n\n    void* item_a = (void*)( ( (uintptr_t) table->items_data ) + index_a * table->item_size );\n    void* item_b = (void*)( ( (uintptr_t) table->items_data ) + index_b * table->item_size );\n    HASHTABLE_ITEMCOPY( table->swap_temp, item_a, table->item_size );\n    HASHTABLE_ITEMCOPY( item_a, item_b, table->item_size );\n    HASHTABLE_ITEMCOPY( item_b, table->swap_temp, table->item_size );\n\n    if( table->slots )\n        {\n        table->slots[ slot_a ].item_index = index_b;\n        table->slots[ slot_b ].item_index = index_a;\n        }\n    }\n\n\n#endif /* HASHTABLE_IMPLEMENTATION */\n\n/*\n\ncontributors:\n    Randy Gaul (hashtable_clear, hashtable_swap )\n\nrevision history:\n    2.0     variable key size, custom hashing\n    1.1     added hashtable_clear, hashtable_swap\n    1.0     first released version  \n\n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "hoedown.h",
          "type": "blob",
          "size": 150.5908203125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nhoedown.h - v1.0 - Markdown to HTML renderer for C/C++.\n\nDo this:\n\t#define HOEDOWN_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n\n------------------------------------------------------------------------------\n\nThis is simply a merged single-header version of the original hoedown lib. I\nalso fixed some minor issues which prevented compilation in C++ (casts).\n\nThe original license text can be found at the end of this file, and I place my\nchanges under the same license.\n\n                        / Mattias Gustavsson ( mattias@mattiasgustavsson.com )\n*/\n\n#ifndef hoedown_h\n#define hoedown_h\n\n/*\n------------------------------------------------------------------------------\n\tSTART buffer.h\n------------------------------------------------------------------------------\n*/\n/* buffer.h - simple, fast buffers */\n\n#ifndef HOEDOWN_BUFFER_H\n#define HOEDOWN_BUFFER_H\n\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#if defined(_MSC_VER)\n#define __attribute__(x)\n#define inline __inline\n#define __builtin_expect(x,n) x\n#endif\n\n\n/*********\n * TYPES *\n *********/\n\ntypedef void *(*hoedown_realloc_callback)(void *, size_t);\ntypedef void (*hoedown_free_callback)(void *);\n\nstruct hoedown_buffer {\n\tuint8_t *data;\t/* actual character data */\n\tsize_t size;\t/* size of the string */\n\tsize_t asize;\t/* allocated size (0 = volatile buffer) */\n\tsize_t unit;\t/* reallocation unit size (0 = read-only buffer) */\n\n\thoedown_realloc_callback data_realloc;\n\thoedown_free_callback data_free;\n\thoedown_free_callback buffer_free;\n};\n\ntypedef struct hoedown_buffer hoedown_buffer;\n\n\n/*************\n * FUNCTIONS *\n *************/\n\n/* allocation wrappers */\nvoid *hoedown_malloc(size_t size) __attribute__ ((malloc));\nvoid *hoedown_calloc(size_t nmemb, size_t size) __attribute__ ((malloc));\nvoid *hoedown_realloc(void *ptr, size_t size) __attribute__ ((malloc));\n\n/* hoedown_buffer_init: initialize a buffer with custom allocators */\nvoid hoedown_buffer_init(\n\thoedown_buffer *buffer,\n\tsize_t unit,\n\thoedown_realloc_callback data_realloc,\n\thoedown_free_callback data_free,\n\thoedown_free_callback buffer_free\n);\n\n/* hoedown_buffer_uninit: uninitialize an existing buffer */\nvoid hoedown_buffer_uninit(hoedown_buffer *buf);\n\n/* hoedown_buffer_new: allocate a new buffer */\nhoedown_buffer *hoedown_buffer_new(size_t unit) __attribute__ ((malloc));\n\n/* hoedown_buffer_reset: free internal data of the buffer */\nvoid hoedown_buffer_reset(hoedown_buffer *buf);\n\n/* hoedown_buffer_grow: increase the allocated size to the given value */\nvoid hoedown_buffer_grow(hoedown_buffer *buf, size_t neosz);\n\n/* hoedown_buffer_put: append raw data to a buffer */\nvoid hoedown_buffer_put(hoedown_buffer *buf, const uint8_t *data, size_t size);\n\n/* hoedown_buffer_puts: append a NUL-terminated string to a buffer */\nvoid hoedown_buffer_puts(hoedown_buffer *buf, const char *str);\n\n/* hoedown_buffer_putc: append a single char to a buffer */\nvoid hoedown_buffer_putc(hoedown_buffer *buf, uint8_t c);\n\n/* hoedown_buffer_putf: read from a file and append to a buffer, until EOF or error */\nint hoedown_buffer_putf(hoedown_buffer *buf, FILE* file);\n\n/* hoedown_buffer_set: replace the buffer's contents with raw data */\nvoid hoedown_buffer_set(hoedown_buffer *buf, const uint8_t *data, size_t size);\n\n/* hoedown_buffer_sets: replace the buffer's contents with a NUL-terminated string */\nvoid hoedown_buffer_sets(hoedown_buffer *buf, const char *str);\n\n/* hoedown_buffer_eq: compare a buffer's data with other data for equality */\nint hoedown_buffer_eq(const hoedown_buffer *buf, const uint8_t *data, size_t size);\n\n/* hoedown_buffer_eq: compare a buffer's data with NUL-terminated string for equality */\nint hoedown_buffer_eqs(const hoedown_buffer *buf, const char *str);\n\n/* hoedown_buffer_prefix: compare the beginning of a buffer with a string */\nint hoedown_buffer_prefix(const hoedown_buffer *buf, const char *prefix);\n\n/* hoedown_buffer_slurp: remove a given number of bytes from the head of the buffer */\nvoid hoedown_buffer_slurp(hoedown_buffer *buf, size_t size);\n\n/* hoedown_buffer_cstr: NUL-termination of the string array (making a C-string) */\nconst char *hoedown_buffer_cstr(hoedown_buffer *buf);\n\n/* hoedown_buffer_printf: formatted printing to a buffer */\nvoid hoedown_buffer_printf(hoedown_buffer *buf, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));\n\n/* hoedown_buffer_put_utf8: put a Unicode character encoded as UTF-8 */\nvoid hoedown_buffer_put_utf8(hoedown_buffer *buf, unsigned int codepoint);\n\n/* hoedown_buffer_free: free the buffer */\nvoid hoedown_buffer_free(hoedown_buffer *buf);\n\n\n/* HOEDOWN_BUFPUTSL: optimized hoedown_buffer_puts of a string literal */\n#define HOEDOWN_BUFPUTSL(output, literal) \\\n\thoedown_buffer_put(output, (const uint8_t *)literal, sizeof(literal) - 1)\n\n/* HOEDOWN_BUFSETSL: optimized hoedown_buffer_sets of a string literal */\n#define HOEDOWN_BUFSETSL(output, literal) \\\n\thoedown_buffer_set(output, (const uint8_t *)literal, sizeof(literal) - 1)\n\n/* HOEDOWN_BUFEQSL: optimized hoedown_buffer_eqs of a string literal */\n#define HOEDOWN_BUFEQSL(output, literal) \\\n\thoedown_buffer_eq(output, (const uint8_t *)literal, sizeof(literal) - 1)\n\n\n#endif /** HOEDOWN_BUFFER_H **/\n/*\n------------------------------------------------------------------------------\n\tEND buffer.h\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART autolink.h\n------------------------------------------------------------------------------\n*/\n/* autolink.h - versatile autolinker */\n\n#ifndef HOEDOWN_AUTOLINK_H\n#define HOEDOWN_AUTOLINK_H\n\n//#include \"buffer.h\"\n\n\n/*************\n * CONSTANTS *\n *************/\n\ntypedef enum hoedown_autolink_flags {\n\tHOEDOWN_AUTOLINK_SHORT_DOMAINS = (1 << 0)\n} hoedown_autolink_flags;\n\n\n/*************\n * FUNCTIONS *\n *************/\n\n/* hoedown_autolink_is_safe: verify that a URL has a safe protocol */\nint hoedown_autolink_is_safe(const uint8_t *data, size_t size);\n\n/* hoedown_autolink__www: search for the next www link in data */\nsize_t hoedown_autolink__www(size_t *rewind_p, hoedown_buffer *link,\n\tuint8_t *data, size_t offset, size_t size, hoedown_autolink_flags flags);\n\n/* hoedown_autolink__email: search for the next email in data */\nsize_t hoedown_autolink__email(size_t *rewind_p, hoedown_buffer *link,\n\tuint8_t *data, size_t offset, size_t size, hoedown_autolink_flags flags);\n\n/* hoedown_autolink__url: search for the next URL in data */\nsize_t hoedown_autolink__url(size_t *rewind_p, hoedown_buffer *link,\n\tuint8_t *data, size_t offset, size_t size, hoedown_autolink_flags flags);\n\n\n#endif /** HOEDOWN_AUTOLINK_H **/\n/*\n------------------------------------------------------------------------------\n\tEND autolink.h\n------------------------------------------------------------------------------\n*/\n/*\n------------------------------------------------------------------------------\n\tSTART document.h\n------------------------------------------------------------------------------\n*/\n/* document.h - generic markdown parser */\n\n#ifndef HOEDOWN_DOCUMENT_H\n#define HOEDOWN_DOCUMENT_H\n\n//#include \"buffer.h\"\n//#include \"autolink.h\"\n\n\n/*************\n * CONSTANTS *\n *************/\n\ntypedef enum hoedown_extensions {\n\t/* block-level extensions */\n\tHOEDOWN_EXT_TABLES = (1 << 0),\n\tHOEDOWN_EXT_FENCED_CODE = (1 << 1),\n\tHOEDOWN_EXT_FOOTNOTES = (1 << 2),\n\n\t/* span-level extensions */\n\tHOEDOWN_EXT_AUTOLINK = (1 << 3),\n\tHOEDOWN_EXT_STRIKETHROUGH = (1 << 4),\n\tHOEDOWN_EXT_UNDERLINE = (1 << 5),\n\tHOEDOWN_EXT_HIGHLIGHT = (1 << 6),\n\tHOEDOWN_EXT_QUOTE = (1 << 7),\n\tHOEDOWN_EXT_SUPERSCRIPT = (1 << 8),\n\tHOEDOWN_EXT_MATH = (1 << 9),\n\n\t/* other flags */\n\tHOEDOWN_EXT_NO_INTRA_EMPHASIS = (1 << 11),\n\tHOEDOWN_EXT_SPACE_HEADERS = (1 << 12),\n\tHOEDOWN_EXT_MATH_EXPLICIT = (1 << 13),\n\n\t/* negative flags */\n\tHOEDOWN_EXT_DISABLE_INDENTED_CODE = (1 << 14)\n} hoedown_extensions;\n\n#define HOEDOWN_EXT_BLOCK (\\\n\tHOEDOWN_EXT_TABLES |\\\n\tHOEDOWN_EXT_FENCED_CODE |\\\n\tHOEDOWN_EXT_FOOTNOTES )\n\n#define HOEDOWN_EXT_SPAN (\\\n\tHOEDOWN_EXT_AUTOLINK |\\\n\tHOEDOWN_EXT_STRIKETHROUGH |\\\n\tHOEDOWN_EXT_UNDERLINE |\\\n\tHOEDOWN_EXT_HIGHLIGHT |\\\n\tHOEDOWN_EXT_QUOTE |\\\n\tHOEDOWN_EXT_SUPERSCRIPT |\\\n\tHOEDOWN_EXT_MATH )\n\n#define HOEDOWN_EXT_FLAGS (\\\n\tHOEDOWN_EXT_NO_INTRA_EMPHASIS |\\\n\tHOEDOWN_EXT_SPACE_HEADERS |\\\n\tHOEDOWN_EXT_MATH_EXPLICIT )\n\n#define HOEDOWN_EXT_NEGATIVE (\\\n\tHOEDOWN_EXT_DISABLE_INDENTED_CODE )\n\ntypedef enum hoedown_list_flags {\n\tHOEDOWN_LIST_ORDERED = (1 << 0),\n\tHOEDOWN_LI_BLOCK = (1 << 1)\t/* <li> containing block data */\n} hoedown_list_flags;\n\ntypedef enum hoedown_table_flags {\n\tHOEDOWN_TABLE_ALIGN_LEFT = 1,\n\tHOEDOWN_TABLE_ALIGN_RIGHT = 2,\n\tHOEDOWN_TABLE_ALIGN_CENTER = 3,\n\tHOEDOWN_TABLE_ALIGNMASK = 3,\n\tHOEDOWN_TABLE_HEADER = 4\n} hoedown_table_flags;\n\ntypedef enum hoedown_autolink_type {\n\tHOEDOWN_AUTOLINK_NONE,\t\t/* used internally when it is not an autolink*/\n\tHOEDOWN_AUTOLINK_NORMAL,\t/* normal http/http/ftp/mailto/etc link */\n\tHOEDOWN_AUTOLINK_EMAIL\t\t/* e-mail link without explit mailto: */\n} hoedown_autolink_type;\n\n\n/*********\n * TYPES *\n *********/\n\nstruct hoedown_document;\ntypedef struct hoedown_document hoedown_document;\n\nstruct hoedown_renderer_data {\n    void* user_data; /* MG: addition to be able to pass extra data to my overloaded render handlers */\n\tvoid *opaque;\n};\ntypedef struct hoedown_renderer_data hoedown_renderer_data;\n\n// MG: addition for custom data pointer\nvoid hoedown_document_user_data( hoedown_document *doc, void* user_data );\n\n/* hoedown_renderer - functions for rendering parsed data */\nstruct hoedown_renderer {\n\t/* state object */\n\tvoid *opaque;\n\n\t/* block level callbacks - NULL skips the block */\n\tvoid (*blockcode)(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data);\n\tvoid (*blockquote)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*header)(hoedown_buffer *ob, const hoedown_buffer *content, int level, const hoedown_renderer_data *data);\n\tvoid (*hrule)(hoedown_buffer *ob, const hoedown_renderer_data *data);\n\tvoid (*list)(hoedown_buffer *ob, const hoedown_buffer *content, hoedown_list_flags flags, const hoedown_renderer_data *data);\n\tvoid (*listitem)(hoedown_buffer *ob, const hoedown_buffer *content, hoedown_list_flags flags, const hoedown_renderer_data *data);\n\tvoid (*paragraph)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*table)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*table_header)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*table_body)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*table_row)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*table_cell)(hoedown_buffer *ob, const hoedown_buffer *content, hoedown_table_flags flags, const hoedown_renderer_data *data);\n\tvoid (*footnotes)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tvoid (*footnote_def)(hoedown_buffer *ob, const hoedown_buffer *content, unsigned int num, const hoedown_renderer_data *data);\n\tvoid (*blockhtml)(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data);\n\n\t/* span level callbacks - NULL or return 0 prints the span verbatim */\n\tint (*autolink)(hoedown_buffer *ob, const hoedown_buffer *link, hoedown_autolink_type type, const hoedown_renderer_data *data);\n\tint (*codespan)(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data);\n\tint (*double_emphasis)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*emphasis)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*underline)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*highlight)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*quote)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*image)(hoedown_buffer *ob, const hoedown_buffer *link, const hoedown_buffer *title, const hoedown_buffer *alt, const hoedown_renderer_data *data);\n\tint (*linebreak)(hoedown_buffer *ob, const hoedown_renderer_data *data);\n\tint (*link)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_buffer *link, const hoedown_buffer *title, const hoedown_renderer_data *data);\n\tint (*triple_emphasis)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*strikethrough)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*superscript)(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data);\n\tint (*footnote_ref)(hoedown_buffer *ob, unsigned int num, const hoedown_renderer_data *data);\n\tint (*math)(hoedown_buffer *ob, const hoedown_buffer *text, int displaymode, const hoedown_renderer_data *data);\n\tint (*raw_html)(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data);\n\n\t/* low level callbacks - NULL copies input directly into the output */\n\tvoid (*entity)(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data);\n\tvoid (*normal_text)(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data);\n\n\t/* miscellaneous callbacks */\n\tvoid (*doc_header)(hoedown_buffer *ob, int inline_render, const hoedown_renderer_data *data);\n\tvoid (*doc_footer)(hoedown_buffer *ob, int inline_render, const hoedown_renderer_data *data);\n};\ntypedef struct hoedown_renderer hoedown_renderer;\n\n\n/*************\n * FUNCTIONS *\n *************/\n\n/* hoedown_document_new: allocate a new document processor instance */\nhoedown_document *hoedown_document_new(\n\tconst hoedown_renderer *renderer,\n\thoedown_extensions extensions,\n\tsize_t max_nesting\n) __attribute__ ((malloc));\n\n/* hoedown_document_render: render regular Markdown using the document processor */\nvoid hoedown_document_render(hoedown_document *doc, hoedown_buffer *ob, const uint8_t *data, size_t size);\n\n/* hoedown_document_render_inline: render inline Markdown using the document processor */\nvoid hoedown_document_render_inline(hoedown_document *doc, hoedown_buffer *ob, const uint8_t *data, size_t size);\n\n/* hoedown_document_free: deallocate a document processor instance */\nvoid hoedown_document_free(hoedown_document *doc);\n\n\n#endif /** HOEDOWN_DOCUMENT_H **/\n/*\n------------------------------------------------------------------------------\n\tEND document.h\n------------------------------------------------------------------------------\n*/\n/*\n------------------------------------------------------------------------------\n\tSTART html.h\n------------------------------------------------------------------------------\n*/\n/* html.h - HTML renderer and utilities */\n\n#ifndef HOEDOWN_HTML_H\n#define HOEDOWN_HTML_H\n\n//#include \"document.h\"\n//#include \"buffer.h\"\n\n\n/*************\n * CONSTANTS *\n *************/\n\ntypedef enum hoedown_html_flags {\n\tHOEDOWN_HTML_SKIP_HTML = (1 << 0),\n\tHOEDOWN_HTML_ESCAPE = (1 << 1),\n\tHOEDOWN_HTML_HARD_WRAP = (1 << 2),\n\tHOEDOWN_HTML_USE_XHTML = (1 << 3)\n} hoedown_html_flags;\n\ntypedef enum hoedown_html_tag {\n\tHOEDOWN_HTML_TAG_NONE = 0,\n\tHOEDOWN_HTML_TAG_OPEN,\n\tHOEDOWN_HTML_TAG_CLOSE\n} hoedown_html_tag;\n\n\n/*********\n * TYPES *\n *********/\n\nstruct hoedown_html_renderer_state {\n\tvoid *opaque;\n\n\tstruct {\n\t\tint header_count;\n\t\tint current_level;\n\t\tint level_offset;\n\t\tint nesting_level;\n\t} toc_data;\n\n\thoedown_html_flags flags;\n\n\t/* extra callbacks */\n\tvoid (*link_attributes)(hoedown_buffer *ob, const hoedown_buffer *url, const hoedown_renderer_data *data);\n};\ntypedef struct hoedown_html_renderer_state hoedown_html_renderer_state;\n\n\n/*************\n * FUNCTIONS *\n *************/\n\n/* hoedown_html_smartypants: process an HTML snippet using SmartyPants for smart punctuation */\nvoid hoedown_html_smartypants(hoedown_buffer *ob, const uint8_t *data, size_t size);\n\n/* hoedown_html_is_tag: checks if data starts with a specific tag, returns the tag type or NONE */\nhoedown_html_tag hoedown_html_is_tag(const uint8_t *data, size_t size, const char *tagname);\n\n\n/* hoedown_html_renderer_new: allocates a regular HTML renderer */\nhoedown_renderer *hoedown_html_renderer_new(\n\thoedown_html_flags render_flags,\n\tint nesting_level\n) __attribute__ ((malloc));\n\n/* hoedown_html_toc_renderer_new: like hoedown_html_renderer_new, but the returned renderer produces the Table of Contents */\nhoedown_renderer *hoedown_html_toc_renderer_new(\n\tint nesting_level\n) __attribute__ ((malloc));\n\n/* hoedown_html_renderer_free: deallocate an HTML renderer */\nvoid hoedown_html_renderer_free(hoedown_renderer *renderer);\n\n/* hoedown_escape_href: escape (part of) a URL inside HTML */\nvoid hoedown_escape_href(hoedown_buffer *ob, const uint8_t *data, size_t size);\n\n/* hoedown_escape_html: escape HTML */\nvoid hoedown_escape_html(hoedown_buffer *ob, const uint8_t *data, size_t size, int secure);\n\n\n\n#endif /** HOEDOWN_HTML_H **/\n/*\n------------------------------------------------------------------------------\n\tEND html.h\n------------------------------------------------------------------------------\n*/\n\n#endif /* file_h */\n\n\n/*\n------------------------------------------------------------------------------\n\tIMPLEMENTATION\n------------------------------------------------------------------------------\n*/\n\n#ifdef HOEDOWN_IMPLEMENTATION\n#undef HOEDOWN_IMPLEMENTATION\n\n#pragma warning( push )\n#pragma warning( disable: 4100 )\n#pragma warning( disable: 4242 )\n#pragma warning( disable: 4244 )\n#pragma warning( disable: 4365 )\n#pragma warning( disable: 4456 )\n#pragma warning( disable: 4996 )\n\n/*\n------------------------------------------------------------------------------\n\tSTART autolink.c\n------------------------------------------------------------------------------\n*/\n//#include \"autolink.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#ifndef _MSC_VER\n#include <strings.h>\n#else\n#define strncasecmp\t_strnicmp\n#endif\n\nint\nhoedown_autolink_is_safe(const uint8_t *data, size_t size)\n{\n\tstatic const size_t valid_uris_count = 6;\n\tstatic const char *valid_uris[] = {\n\t\t\"http://\", \"https://\", \"/\", \"#\", \"ftp://\", \"mailto:\"\n\t};\n\tstatic const size_t valid_uris_size[] = { 7, 8, 1, 1, 6, 7 };\n\tsize_t i;\n\n\tfor (i = 0; i < valid_uris_count; ++i) {\n\t\tsize_t len = valid_uris_size[i];\n\n\t\tif (size > len &&\n\t\t\tstrncasecmp((char *)data, valid_uris[i], len) == 0 &&\n\t\t\tisalnum(data[len]))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic size_t\nautolink_delim(uint8_t *data, size_t link_end, size_t max_rewind, size_t size)\n{\n\tuint8_t cclose, copen = 0;\n\tsize_t i;\n\n\tfor (i = 0; i < link_end; ++i)\n\t\tif (data[i] == '<') {\n\t\t\tlink_end = i;\n\t\t\tbreak;\n\t\t}\n\n\twhile (link_end > 0) {\n\t\tif (strchr(\"?!.,:\", data[link_end - 1]) != NULL)\n\t\t\tlink_end--;\n\n\t\telse if (data[link_end - 1] == ';') {\n\t\t\tsize_t new_end = link_end - 2;\n\n\t\t\twhile (new_end > 0 && isalpha(data[new_end]))\n\t\t\t\tnew_end--;\n\n\t\t\tif (new_end < link_end - 2 && data[new_end] == '&')\n\t\t\t\tlink_end = new_end;\n\t\t\telse\n\t\t\t\tlink_end--;\n\t\t}\n\t\telse break;\n\t}\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\tcclose = data[link_end - 1];\n\n\tswitch (cclose) {\n\tcase '\"':\tcopen = '\"'; break;\n\tcase '\\'':\tcopen = '\\''; break;\n\tcase ')':\tcopen = '('; break;\n\tcase ']':\tcopen = '['; break;\n\tcase '}':\tcopen = '{'; break;\n\t}\n\n\tif (copen != 0) {\n\t\tsize_t closing = 0;\n\t\tsize_t opening = 0;\n\t\tsize_t i = 0;\n\n\t\t/* Try to close the final punctuation sign in this same line;\n\t\t * if we managed to close it outside of the URL, that means that it's\n\t\t * not part of the URL. If it closes inside the URL, that means it\n\t\t * is part of the URL.\n\t\t *\n\t\t * Examples:\n\t\t *\n\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *\tfoo (http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric))\n\t\t *\n\t\t *\t(foo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *\t\t=> foo http://www.pokemon.com/Pikachu_(Electric)\n\t\t */\n\n\t\twhile (i < link_end) {\n\t\t\tif (data[i] == copen)\n\t\t\t\topening++;\n\t\t\telse if (data[i] == cclose)\n\t\t\t\tclosing++;\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (closing != opening)\n\t\t\tlink_end--;\n\t}\n\n\treturn link_end;\n}\n\nstatic size_t\ncheck_domain(uint8_t *data, size_t size, int allow_short)\n{\n\tsize_t i, np = 0;\n\n\tif (!isalnum(data[0]))\n\t\treturn 0;\n\n\tfor (i = 1; i < size - 1; ++i) {\n\t\tif (strchr(\".:\", data[i]) != NULL) np++;\n\t\telse if (!isalnum(data[i]) && data[i] != '-') break;\n\t}\n\n\tif (allow_short) {\n\t\t/* We don't need a valid domain in the strict sense (with\n\t\t * least one dot; so just make sure it's composed of valid\n\t\t * domain characters and return the length of the the valid\n\t\t * sequence. */\n\t\treturn i;\n\t} else {\n\t\t/* a valid domain needs to have at least a dot.\n\t\t * that's as far as we get */\n\t\treturn np ? i : 0;\n\t}\n}\n\nsize_t\nhoedown_autolink__www(\n\tsize_t *rewind_p,\n\thoedown_buffer *link,\n\tuint8_t *data,\n\tsize_t max_rewind,\n\tsize_t size,\n\thoedown_autolink_flags flags)\n{\n\tsize_t link_end;\n\n\tif (max_rewind > 0 && !ispunct(data[-1]) && !isspace(data[-1]))\n\t\treturn 0;\n\n\tif (size < 4 || memcmp(data, \"www.\", strlen(\"www.\")) != 0)\n\t\treturn 0;\n\n\tlink_end = check_domain(data, size, 0);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\twhile (link_end < size && !isspace(data[link_end]))\n\t\tlink_end++;\n\n\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\thoedown_buffer_put(link, data, link_end);\n\t*rewind_p = 0;\n\n\treturn (int)link_end;\n}\n\nsize_t\nhoedown_autolink__email(\n\tsize_t *rewind_p,\n\thoedown_buffer *link,\n\tuint8_t *data,\n\tsize_t max_rewind,\n\tsize_t size,\n\tunsigned int flags)\n{\n\tsize_t link_end, rewind;\n\tint nb = 0, np = 0;\n\n\tfor (rewind = 0; rewind < max_rewind; ++rewind) {\n\t\tuint8_t c = data[-1 - rewind];\n\n\t\tif (isalnum(c))\n\t\t\tcontinue;\n\n\t\tif (strchr(\".+-_\", c) != NULL)\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\tif (rewind == 0)\n\t\treturn 0;\n\n\tfor (link_end = 0; link_end < size; ++link_end) {\n\t\tuint8_t c = data[link_end];\n\n\t\tif (isalnum(c))\n\t\t\tcontinue;\n\n\t\tif (c == '@')\n\t\t\tnb++;\n\t\telse if (c == '.' && link_end < size - 1)\n\t\t\tnp++;\n\t\telse if (c != '-' && c != '_')\n\t\t\tbreak;\n\t}\n\n\tif (link_end < 2 || nb != 1 || np == 0 ||\n\t\t!isalpha(data[link_end - 1]))\n\t\treturn 0;\n\n\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\thoedown_buffer_put(link, data - rewind, link_end + rewind);\n\t*rewind_p = rewind;\n\n\treturn link_end;\n}\n\nsize_t\nhoedown_autolink__url(\n\tsize_t *rewind_p,\n\thoedown_buffer *link,\n\tuint8_t *data,\n\tsize_t max_rewind,\n\tsize_t size,\n\tunsigned int flags)\n{\n\tsize_t link_end, rewind = 0, domain_len;\n\n\tif (size < 4 || data[1] != '/' || data[2] != '/')\n\t\treturn 0;\n\n\twhile (rewind < max_rewind && isalpha(data[-1 - rewind]))\n\t\trewind++;\n\n\tif (!hoedown_autolink_is_safe(data - rewind, size + rewind))\n\t\treturn 0;\n\n\tlink_end = strlen(\"://\");\n\n\tdomain_len = check_domain(\n\t\tdata + link_end,\n\t\tsize - link_end,\n\t\tflags & HOEDOWN_AUTOLINK_SHORT_DOMAINS);\n\n\tif (domain_len == 0)\n\t\treturn 0;\n\n\tlink_end += domain_len;\n\twhile (link_end < size && !isspace(data[link_end]))\n\t\tlink_end++;\n\n\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n\n\tif (link_end == 0)\n\t\treturn 0;\n\n\thoedown_buffer_put(link, data - rewind, link_end + rewind);\n\t*rewind_p = rewind;\n\n\treturn link_end;\n}\n/*\n------------------------------------------------------------------------------\n\tEND autolink.c\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART buffer.c\n------------------------------------------------------------------------------\n*/\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"buffer.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#ifdef _WIN32\n\t#define vsnprintf _vsnprintf\n#endif\n\nvoid *\nhoedown_malloc(size_t size)\n{\n\tvoid *ret = malloc(size);\n\n\tif (!ret) {\n\t\tfprintf(stderr, \"Allocation failed.\\n\");\n\t\tabort();\n\t}\n\n\treturn ret;\n}\n\nvoid *\nhoedown_calloc(size_t nmemb, size_t size)\n{\n\tvoid *ret = calloc(nmemb, size);\n\n\tif (!ret) {\n\t\tfprintf(stderr, \"Allocation failed.\\n\");\n\t\tabort();\n\t}\n\n\treturn ret;\n}\n\nvoid *\nhoedown_realloc(void *ptr, size_t size)\n{\n\tvoid *ret = realloc(ptr, size);\n\n\tif (!ret) {\n\t\tfprintf(stderr, \"Allocation failed.\\n\");\n\t\tabort();\n\t}\n\n\treturn ret;\n}\n\nvoid\nhoedown_buffer_init(\n\thoedown_buffer *buf,\n\tsize_t unit,\n\thoedown_realloc_callback data_realloc,\n\thoedown_free_callback data_free,\n\thoedown_free_callback buffer_free)\n{\n\tassert(buf);\n\n\tbuf->data = NULL;\n\tbuf->size = buf->asize = 0;\n\tbuf->unit = unit;\n\tbuf->data_realloc = data_realloc;\n\tbuf->data_free = data_free;\n\tbuf->buffer_free = buffer_free;\n}\n\nvoid\nhoedown_buffer_uninit(hoedown_buffer *buf)\n{\n\tassert(buf && buf->unit);\n\tbuf->data_free(buf->data);\n}\n\nhoedown_buffer *\nhoedown_buffer_new(size_t unit)\n{\n\thoedown_buffer *ret = (hoedown_buffer *)hoedown_malloc(sizeof (hoedown_buffer));\n\thoedown_buffer_init(ret, unit, hoedown_realloc, free, free);\n\treturn ret;\n}\n\nvoid\nhoedown_buffer_free(hoedown_buffer *buf)\n{\n\tif (!buf) return;\n\tassert(buf && buf->unit);\n\n\tbuf->data_free(buf->data);\n\n\tif (buf->buffer_free)\n\t\tbuf->buffer_free(buf);\n}\n\nvoid\nhoedown_buffer_reset(hoedown_buffer *buf)\n{\n\tassert(buf && buf->unit);\n\n\tbuf->data_free(buf->data);\n\tbuf->data = NULL;\n\tbuf->size = buf->asize = 0;\n}\n\nvoid\nhoedown_buffer_grow(hoedown_buffer *buf, size_t neosz)\n{\n\tsize_t neoasz;\n\tassert(buf && buf->unit);\n\n\tif (buf->asize >= neosz)\n\t\treturn;\n\n\tneoasz = buf->asize + buf->unit;\n\twhile (neoasz < neosz)\n\t\tneoasz += buf->unit;\n\n\tbuf->data = (uint8_t*)buf->data_realloc(buf->data, neoasz);\n\tbuf->asize = neoasz;\n}\n\nvoid\nhoedown_buffer_put(hoedown_buffer *buf, const uint8_t *data, size_t size)\n{\n\tassert(buf && buf->unit);\n\n\tif (buf->size + size > buf->asize)\n\t\thoedown_buffer_grow(buf, buf->size + size);\n\n\tmemcpy(buf->data + buf->size, data, size);\n\tbuf->size += size;\n}\n\nvoid\nhoedown_buffer_puts(hoedown_buffer *buf, const char *str)\n{\n\thoedown_buffer_put(buf, (const uint8_t *)str, strlen(str));\n}\n\nvoid\nhoedown_buffer_putc(hoedown_buffer *buf, uint8_t c)\n{\n\tassert(buf && buf->unit);\n\n\tif (buf->size >= buf->asize)\n\t\thoedown_buffer_grow(buf, buf->size + 1);\n\n\tbuf->data[buf->size] = c;\n\tbuf->size += 1;\n}\n\nint\nhoedown_buffer_putf(hoedown_buffer *buf, FILE *file)\n{\n\tassert(buf && buf->unit);\n\n\twhile (!(feof(file) || ferror(file))) {\n\t\thoedown_buffer_grow(buf, buf->size + buf->unit);\n\t\tbuf->size += fread(buf->data + buf->size, 1, buf->unit, file);\n\t}\n\n\treturn ferror(file);\n}\n\nvoid\nhoedown_buffer_set(hoedown_buffer *buf, const uint8_t *data, size_t size)\n{\n\tassert(buf && buf->unit);\n\n\tif (size > buf->asize)\n\t\thoedown_buffer_grow(buf, size);\n\n\tmemcpy(buf->data, data, size);\n\tbuf->size = size;\n}\n\nvoid\nhoedown_buffer_sets(hoedown_buffer *buf, const char *str)\n{\n\thoedown_buffer_set(buf, (const uint8_t *)str, strlen(str));\n}\n\nint\nhoedown_buffer_eq(const hoedown_buffer *buf, const uint8_t *data, size_t size)\n{\n\tif (buf->size != size) return 0;\n\treturn memcmp(buf->data, data, size) == 0;\n}\n\nint\nhoedown_buffer_eqs(const hoedown_buffer *buf, const char *str)\n{\n\treturn hoedown_buffer_eq(buf, (const uint8_t *)str, strlen(str));\n}\n\nint\nhoedown_buffer_prefix(const hoedown_buffer *buf, const char *prefix)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < buf->size; ++i) {\n\t\tif (prefix[i] == 0)\n\t\t\treturn 0;\n\n\t\tif (buf->data[i] != prefix[i])\n\t\t\treturn buf->data[i] - prefix[i];\n\t}\n\n\treturn 0;\n}\n\nvoid\nhoedown_buffer_slurp(hoedown_buffer *buf, size_t size)\n{\n\tassert(buf && buf->unit);\n\n\tif (size >= buf->size) {\n\t\tbuf->size = 0;\n\t\treturn;\n\t}\n\n\tbuf->size -= size;\n\tmemmove(buf->data, buf->data + size, buf->size);\n}\n\nconst char *\nhoedown_buffer_cstr(hoedown_buffer *buf)\n{\n\tassert(buf && buf->unit);\n\n\tif (buf->size < buf->asize && buf->data[buf->size] == 0)\n\t\treturn (char *)buf->data;\n\n\thoedown_buffer_grow(buf, buf->size + 1);\n\tbuf->data[buf->size] = 0;\n\n\treturn (char *)buf->data;\n}\n\nvoid\nhoedown_buffer_printf(hoedown_buffer *buf, const char *fmt, ...)\n{\n\tva_list ap;\n\tint n;\n\n\tassert(buf && buf->unit);\n\n\tif (buf->size >= buf->asize)\n\t\thoedown_buffer_grow(buf, buf->size + 1);\n\n\tva_start(ap, fmt);\n\tn = vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n\tva_end(ap);\n\n\tif (n < 0) {\n#ifndef _MSC_VER\n\t\treturn;\n#else\n\t\tva_start(ap, fmt);\n\t\tn = _vscprintf(fmt, ap);\n\t\tva_end(ap);\n#endif\n\t}\n\n\tif ((size_t)n >= buf->asize - buf->size) {\n\t\thoedown_buffer_grow(buf, buf->size + n + 1);\n\n\t\tva_start(ap, fmt);\n\t\tn = vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n\t\tva_end(ap);\n\t}\n\n\tif (n < 0)\n\t\treturn;\n\n\tbuf->size += n;\n}\n\nvoid hoedown_buffer_put_utf8(hoedown_buffer *buf, unsigned int c) {\n\tunsigned char unichar[4];\n\n\tassert(buf && buf->unit);\n\n\tif (c < 0x80) {\n\t\thoedown_buffer_putc(buf, c);\n\t}\n\telse if (c < 0x800) {\n\t\tunichar[0] = 192 + (c / 64);\n\t\tunichar[1] = 128 + (c % 64);\n\t\thoedown_buffer_put(buf, unichar, 2);\n\t}\n\telse if (c - 0xd800u < 0x800) {\n\t\tHOEDOWN_BUFPUTSL(buf, \"\\xef\\xbf\\xbd\");\n\t}\n\telse if (c < 0x10000) {\n\t\tunichar[0] = 224 + (c / 4096);\n\t\tunichar[1] = 128 + (c / 64) % 64;\n\t\tunichar[2] = 128 + (c % 64);\n\t\thoedown_buffer_put(buf, unichar, 3);\n\t}\n\telse if (c < 0x110000) {\n\t\tunichar[0] = 240 + (c / 262144);\n\t\tunichar[1] = 128 + (c / 4096) % 64;\n\t\tunichar[2] = 128 + (c / 64) % 64;\n\t\tunichar[3] = 128 + (c % 64);\n\t\thoedown_buffer_put(buf, unichar, 4);\n\t}\n\telse {\n\t\tHOEDOWN_BUFPUTSL(buf, \"\\xef\\xbf\\xbd\");\n\t}\n}\n/*\n------------------------------------------------------------------------------\n\tEND buffer.c\n------------------------------------------------------------------------------\n*/\n/*\n------------------------------------------------------------------------------\n\tSTART stack.h\n------------------------------------------------------------------------------\n*/\n/* stack.h - simple stacking */\n\n#ifndef HOEDOWN_STACK_H\n#define HOEDOWN_STACK_H\n\n#include <stddef.h>\n\n\n/*********\n * TYPES *\n *********/\n\nstruct hoedown_stack {\n\tvoid **item;\n\tsize_t size;\n\tsize_t asize;\n};\ntypedef struct hoedown_stack hoedown_stack;\n\n\n/*************\n * FUNCTIONS *\n *************/\n\n/* hoedown_stack_init: initialize a stack */\nvoid hoedown_stack_init(hoedown_stack *st, size_t initial_size);\n\n/* hoedown_stack_uninit: free internal data of the stack */\nvoid hoedown_stack_uninit(hoedown_stack *st);\n\n/* hoedown_stack_grow: increase the allocated size to the given value */\nvoid hoedown_stack_grow(hoedown_stack *st, size_t neosz);\n\n/* hoedown_stack_push: push an item to the top of the stack */\nvoid hoedown_stack_push(hoedown_stack *st, void *item);\n\n/* hoedown_stack_pop: retrieve and remove the item at the top of the stack */\nvoid *hoedown_stack_pop(hoedown_stack *st);\n\n/* hoedown_stack_top: retrieve the item at the top of the stack */\nvoid *hoedown_stack_top(const hoedown_stack *st);\n\n\n#endif /** HOEDOWN_STACK_H **/\n/*\n------------------------------------------------------------------------------\n\tEND stack.h\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART document.c\n------------------------------------------------------------------------------\n*/\n//#include \"document.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n\n//#include \"stack.h\"\n\n#ifndef _MSC_VER\n#include <strings.h>\n#else\n#define strncasecmp\t_strnicmp\n#endif\n\n#define REF_TABLE_SIZE 8\n\n#define BUFFER_BLOCK 0\n#define BUFFER_SPAN 1\n\n#define HOEDOWN_LI_END 8\t/* internal list flag */\n\nconst char *hoedown_find_block_tag(const char *str, unsigned int len);\n\n/***************\n * LOCAL TYPES *\n ***************/\n\n/* link_ref: reference to a link */\nstruct link_ref {\n\tunsigned int id;\n\n\thoedown_buffer *link;\n\thoedown_buffer *title;\n\n\tstruct link_ref *next;\n};\n\n/* footnote_ref: reference to a footnote */\nstruct footnote_ref {\n\tunsigned int id;\n\n\tint is_used;\n\tunsigned int num;\n\n\thoedown_buffer *contents;\n};\n\n/* footnote_item: an item in a footnote_list */\nstruct footnote_item {\n\tstruct footnote_ref *ref;\n\tstruct footnote_item *next;\n};\n\n/* footnote_list: linked list of footnote_item */\nstruct footnote_list {\n\tunsigned int count;\n\tstruct footnote_item *head;\n\tstruct footnote_item *tail;\n};\n\n/* char_trigger: function pointer to render active chars */\n/*   returns the number of chars taken care of */\n/*   data is the pointer of the beginning of the span */\n/*   offset is the number of valid chars before data */\ntypedef size_t\n(*char_trigger)(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\n\nstatic size_t char_emphasis(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_quote(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_linebreak(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_codespan(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_escape(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_entity(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_langle_tag(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_autolink_url(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_autolink_email(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_autolink_www(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_link(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_superscript(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\nstatic size_t char_math(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size);\n\nenum markdown_char_t {\n\tMD_CHAR_NONE = 0,\n\tMD_CHAR_EMPHASIS,\n\tMD_CHAR_CODESPAN,\n\tMD_CHAR_LINEBREAK,\n\tMD_CHAR_LINK,\n\tMD_CHAR_LANGLE,\n\tMD_CHAR_ESCAPE,\n\tMD_CHAR_ENTITY,\n\tMD_CHAR_AUTOLINK_URL,\n\tMD_CHAR_AUTOLINK_EMAIL,\n\tMD_CHAR_AUTOLINK_WWW,\n\tMD_CHAR_SUPERSCRIPT,\n\tMD_CHAR_QUOTE,\n\tMD_CHAR_MATH\n};\n\nstatic char_trigger markdown_char_ptrs[] = {\n\tNULL,\n\t&char_emphasis,\n\t&char_codespan,\n\t&char_linebreak,\n\t&char_link,\n\t&char_langle_tag,\n\t&char_escape,\n\t&char_entity,\n\t&char_autolink_url,\n\t&char_autolink_email,\n\t&char_autolink_www,\n\t&char_superscript,\n\t&char_quote,\n\t&char_math\n};\n\nstruct hoedown_document {\n\thoedown_renderer md;\n\thoedown_renderer_data data;\n\n\tstruct link_ref *refs[REF_TABLE_SIZE];\n\tstruct footnote_list footnotes_found;\n\tstruct footnote_list footnotes_used;\n\tuint8_t active_char[256];\n\thoedown_stack work_bufs[2];\n\thoedown_extensions ext_flags;\n\tsize_t max_nesting;\n\tint in_link_body;\n};\n\n// MG: addition for custom data pointer\nvoid hoedown_document_user_data( hoedown_document *doc, void* user_data )\n{\n    doc->data.user_data = user_data; \n}\n\n/***************************\n * HELPER FUNCTIONS *\n ***************************/\n\nstatic hoedown_buffer *\nnewbuf(hoedown_document *doc, int type)\n{\n\tstatic const size_t buf_size[2] = {256, 64};\n\thoedown_buffer *work = NULL;\n\thoedown_stack *pool = &doc->work_bufs[type];\n\n\tif (pool->size < pool->asize &&\n\t\tpool->item[pool->size] != NULL) {\n\t\twork = (hoedown_buffer*)pool->item[pool->size++];\n\t\twork->size = 0;\n\t} else {\n\t\twork = hoedown_buffer_new(buf_size[type]);\n\t\thoedown_stack_push(pool, work);\n\t}\n\n\treturn work;\n}\n\nstatic void\npopbuf(hoedown_document *doc, int type)\n{\n\tdoc->work_bufs[type].size--;\n}\n\nstatic void\nunscape_text(hoedown_buffer *ob, hoedown_buffer *src)\n{\n\tsize_t i = 0, org;\n\twhile (i < src->size) {\n\t\torg = i;\n\t\twhile (i < src->size && src->data[i] != '\\\\')\n\t\t\ti++;\n\n\t\tif (i > org)\n\t\t\thoedown_buffer_put(ob, src->data + org, i - org);\n\n\t\tif (i + 1 >= src->size)\n\t\t\tbreak;\n\n\t\thoedown_buffer_putc(ob, src->data[i + 1]);\n\t\ti += 2;\n\t}\n}\n\nstatic unsigned int\nhash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\n\treturn hash;\n}\n\nstatic struct link_ref *\nadd_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = (struct link_ref *)hoedown_calloc(1, sizeof(struct link_ref));\n\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}\n\nstatic struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nfree_link_refs(struct link_ref **references)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n\t\tstruct link_ref *r = references[i];\n\t\tstruct link_ref *next;\n\n\t\twhile (r) {\n\t\t\tnext = r->next;\n\t\t\thoedown_buffer_free(r->link);\n\t\t\thoedown_buffer_free(r->title);\n\t\t\tfree(r);\n\t\t\tr = next;\n\t\t}\n\t}\n}\n\nstatic struct footnote_ref *\ncreate_footnote_ref(struct footnote_list *list, const uint8_t *name, size_t name_size)\n{\n\tstruct footnote_ref *ref = (struct footnote_ref *)hoedown_calloc(1, sizeof(struct footnote_ref));\n\n\tref->id = hash_link_ref(name, name_size);\n\n\treturn ref;\n}\n\nstatic int\nadd_footnote_ref(struct footnote_list *list, struct footnote_ref *ref)\n{\n\tstruct footnote_item *item = (struct footnote_item *)hoedown_calloc(1, sizeof(struct footnote_item));\n\tif (!item)\n\t\treturn 0;\n\titem->ref = ref;\n\n\tif (list->head == NULL) {\n\t\tlist->head = list->tail = item;\n\t} else {\n\t\tlist->tail->next = item;\n\t\tlist->tail = item;\n\t}\n\tlist->count++;\n\n\treturn 1;\n}\n\nstatic struct footnote_ref *\nfind_footnote_ref(struct footnote_list *list, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct footnote_item *item = NULL;\n\n\titem = list->head;\n\n\twhile (item != NULL) {\n\t\tif (item->ref->id == hash)\n\t\t\treturn item->ref;\n\t\titem = item->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nfree_footnote_ref(struct footnote_ref *ref)\n{\n\thoedown_buffer_free(ref->contents);\n\tfree(ref);\n}\n\nstatic void\nfree_footnote_list(struct footnote_list *list, int free_refs)\n{\n\tstruct footnote_item *item = list->head;\n\tstruct footnote_item *next;\n\n\twhile (item) {\n\t\tnext = item->next;\n\t\tif (free_refs)\n\t\t\tfree_footnote_ref(item->ref);\n\t\tfree(item);\n\t\titem = next;\n\t}\n}\n\n\n/*\n * Check whether a char is a Markdown spacing char.\n\n * Right now we only consider spaces the actual\n * space and a newline: tabs and carriage returns\n * are filtered out during the preprocessing phase.\n *\n * If we wanted to actually be UTF-8 compliant, we\n * should instead extract an Unicode codepoint from\n * this character and check for space properties.\n */\nstatic int\n_isspace(int c)\n{\n\treturn c == ' ' || c == '\\n';\n}\n\n/* is_empty_all: verify that all the data is spacing */\nstatic int\nis_empty_all(const uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\twhile (i < size && _isspace(data[i])) i++;\n\treturn i == size;\n}\n\n/*\n * Replace all spacing characters in data with spaces. As a special\n * case, this collapses a newline with the previous space, if possible.\n */\nstatic void\nreplace_spacing(hoedown_buffer *ob, const uint8_t *data, size_t size)\n{\n\tsize_t i = 0, mark;\n\thoedown_buffer_grow(ob, size);\n\twhile (1) {\n\t\tmark = i;\n\t\twhile (i < size && data[i] != '\\n') i++;\n\t\thoedown_buffer_put(ob, data + mark, i - mark);\n\n\t\tif (i >= size) break;\n\n\t\tif (!(i > 0 && data[i-1] == ' '))\n\t\t\thoedown_buffer_putc(ob, ' ');\n\t\ti++;\n\t}\n}\n\n/****************************\n * INLINE PARSING FUNCTIONS *\n ****************************/\n\n/* is_mail_autolink  looks for the address part of a mail autolink and '>' */\n/* this is less strict than the original markdown e-mail address matching */\nstatic size_t\nis_mail_autolink(uint8_t *data, size_t size)\n{\n\tsize_t i = 0, nb = 0;\n\n\t/* address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@' */\n\tfor (i = 0; i < size; ++i) {\n\t\tif (isalnum(data[i]))\n\t\t\tcontinue;\n\n\t\tswitch (data[i]) {\n\t\t\tcase '@':\n\t\t\t\tnb++;\n\n\t\t\tcase '-':\n\t\t\tcase '.':\n\t\t\tcase '_':\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn (nb == 1) ? i + 1 : 0;\n\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* tag_length  returns the length of the given tag, or 0 is it's not valid */\nstatic size_t\ntag_length(uint8_t *data, size_t size, hoedown_autolink_type *autolink)\n{\n\tsize_t i, j;\n\n\t/* a valid tag can't be shorter than 3 chars */\n\tif (size < 3) return 0;\n\n\t/* begins with a '<' optionally followed by '/', followed by letter or number */\n\tif (data[0] != '<') return 0;\n\ti = (data[1] == '/') ? 2 : 1;\n\n\tif (!isalnum(data[i]))\n\t\treturn 0;\n\n\t/* scheme test */\n\t*autolink = HOEDOWN_AUTOLINK_NONE;\n\n\t/* try to find the beginning of an URI */\n\twhile (i < size && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-'))\n\t\ti++;\n\n\tif (i > 1 && data[i] == '@') {\n\t\tif ((j = is_mail_autolink(data + i, size - i)) != 0) {\n\t\t\t*autolink = HOEDOWN_AUTOLINK_EMAIL;\n\t\t\treturn i + j;\n\t\t}\n\t}\n\n\tif (i > 2 && data[i] == ':') {\n\t\t*autolink = HOEDOWN_AUTOLINK_NORMAL;\n\t\ti++;\n\t}\n\n\t/* completing autolink test: no spacing or ' or \" */\n\tif (i >= size)\n\t\t*autolink = HOEDOWN_AUTOLINK_NONE;\n\n\telse if (*autolink) {\n\t\tj = i;\n\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == '>' || data[i] == '\\'' ||\n\t\t\t\t\tdata[i] == '\"' || data[i] == ' ' || data[i] == '\\n')\n\t\t\t\t\tbreak;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) return 0;\n\t\tif (i > j && data[i] == '>') return i + 1;\n\t\t/* one of the forbidden chars has been found */\n\t\t*autolink = HOEDOWN_AUTOLINK_NONE;\n\t}\n\n\t/* looking for something looking like a tag end */\n\twhile (i < size && data[i] != '>') i++;\n\tif (i >= size) return 0;\n\treturn i + 1;\n}\n\n/* parse_inline  parses inline markdown elements */\nstatic void\nparse_inline(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\tsize_t i = 0, end = 0, consumed = 0;\n\thoedown_buffer work = { 0, 0, 0, 0, NULL, NULL, NULL };\n\tuint8_t *active_char = doc->active_char;\n\n\tif (doc->work_bufs[BUFFER_SPAN].size +\n\t\tdoc->work_bufs[BUFFER_BLOCK].size > doc->max_nesting)\n\t\treturn;\n\n\twhile (i < size) {\n\t\t/* copying inactive chars into the output */\n\t\twhile (end < size && active_char[data[end]] == 0)\n\t\t\tend++;\n\n\t\tif (doc->md.normal_text) {\n\t\t\twork.data = data + i;\n\t\t\twork.size = end - i;\n\t\t\tdoc->md.normal_text(ob, &work, &doc->data);\n\t\t}\n\t\telse\n\t\t\thoedown_buffer_put(ob, data + i, end - i);\n\n\t\tif (end >= size) break;\n\t\ti = end;\n\n\t\tend = markdown_char_ptrs[ (int)active_char[data[end]] ](ob, doc, data + i, i - consumed, size - i);\n\t\tif (!end) /* no action from the callback */\n\t\t\tend = i + 1;\n\t\telse {\n\t\t\ti += end;\n\t\t\tend = i;\n\t\t\tconsumed = i;\n\t\t}\n\t}\n}\n\n/* is_escaped  returns whether special char at data[loc] is escaped by '\\\\' */\nstatic int\nis_escaped(uint8_t *data, size_t loc)\n{\n\tsize_t i = loc;\n\twhile (i >= 1 && data[i - 1] == '\\\\')\n\t\ti--;\n\n\t/* odd numbers of backslashes escapes data[loc] */\n\treturn (int)( (loc - i) % 2 );\n}\n\n/* find_emph_char  looks for the next emph uint8_t, skipping other constructs */\nstatic size_t\nfind_emph_char(uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0;\n\n\twhile (i < size) {\n\t\twhile (i < size && data[i] != c && data[i] != '[' && data[i] != '`')\n\t\t\ti++;\n\n\t\tif (i == size)\n\t\t\treturn 0;\n\n\t\t/* not counting escaped chars */\n\t\tif (is_escaped(data, i)) {\n\t\t\ti++; continue;\n\t\t}\n\n\t\tif (data[i] == c)\n\t\t\treturn i;\n\n\t\t/* skipping a codespan */\n\t\tif (data[i] == '`') {\n\t\t\tsize_t span_nb = 0, bt;\n\t\t\tsize_t tmp_i = 0;\n\n\t\t\t/* counting the number of opening backticks */\n\t\t\twhile (i < size && data[i] == '`') {\n\t\t\t\ti++; span_nb++;\n\t\t\t}\n\n\t\t\tif (i >= size) return 0;\n\n\t\t\t/* finding the matching closing sequence */\n\t\t\tbt = 0;\n\t\t\twhile (i < size && bt < span_nb) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\tif (data[i] == '`') bt++;\n\t\t\t\telse bt = 0;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* not a well-formed codespan; use found matching emph char */\n\t\t\tif (bt < span_nb && i >= size) return tmp_i;\n\t\t}\n\t\t/* skipping a link */\n\t\telse if (data[i] == '[') {\n\t\t\tsize_t tmp_i = 0;\n\t\t\tuint8_t cc;\n\n\t\t\ti++;\n\t\t\twhile (i < size && data[i] != ']') {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\twhile (i < size && _isspace(data[i]))\n\t\t\t\ti++;\n\n\t\t\tif (i >= size)\n\t\t\t\treturn tmp_i;\n\n\t\t\tswitch (data[i]) {\n\t\t\tcase '[':\n\t\t\t\tcc = ']'; break;\n\n\t\t\tcase '(':\n\t\t\t\tcc = ')'; break;\n\n\t\t\tdefault:\n\t\t\t\tif (tmp_i)\n\t\t\t\t\treturn tmp_i;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\twhile (i < size && data[i] != cc) {\n\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i >= size)\n\t\t\t\treturn tmp_i;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* parse_emph1  parsing single emphase */\n/* closed by a symbol not preceded by spacing and not followed by symbol */\nstatic size_t\nparse_emph1(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\thoedown_buffer *work = 0;\n\tint r;\n\n\t/* skipping one symbol if coming from emph3 */\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\n\t\t\tif (doc->ext_flags & HOEDOWN_EXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + 1 < size && isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twork = newbuf(doc, BUFFER_SPAN);\n\t\t\tparse_inline(work, doc, data, i);\n\n\t\t\tif (doc->ext_flags & HOEDOWN_EXT_UNDERLINE && c == '_')\n\t\t\t\tr = doc->md.underline(ob, work, &doc->data);\n\t\t\telse\n\t\t\t\tr = doc->md.emphasis(ob, work, &doc->data);\n\n\t\t\tpopbuf(doc, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* parse_emph2  parsing single emphase */\nstatic size_t\nparse_emph2(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\thoedown_buffer *work = 0;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\tif (i + 1 < size && data[i] == c && data[i + 1] == c && i && !_isspace(data[i - 1])) {\n\t\t\twork = newbuf(doc, BUFFER_SPAN);\n\t\t\tparse_inline(work, doc, data, i);\n\n\t\t\tif (c == '~')\n\t\t\t\tr = doc->md.strikethrough(ob, work, &doc->data);\n\t\t\telse if (c == '=')\n\t\t\t\tr = doc->md.highlight(ob, work, &doc->data);\n\t\t\telse\n\t\t\t\tr = doc->md.double_emphasis(ob, work, &doc->data);\n\n\t\t\tpopbuf(doc, BUFFER_SPAN);\n\t\t\treturn r ? i + 2 : 0;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n}\n\n/* parse_emph3  parsing single emphase */\n/* finds the first closing tag, and delegates to the other emph */\nstatic size_t\nparse_emph3(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tint r;\n\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\n\t\t/* skip spacing preceded symbols */\n\t\tif (data[i] != c || _isspace(data[i - 1]))\n\t\t\tcontinue;\n\n\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && doc->md.triple_emphasis) {\n\t\t\t/* triple symbol found */\n\t\t\thoedown_buffer *work = newbuf(doc, BUFFER_SPAN);\n\n\t\t\tparse_inline(work, doc, data, i);\n\t\t\tr = doc->md.triple_emphasis(ob, work, &doc->data);\n\t\t\tpopbuf(doc, BUFFER_SPAN);\n\t\t\treturn r ? i + 3 : 0;\n\n\t\t} else if (i + 1 < size && data[i + 1] == c) {\n\t\t\t/* double symbol found, handing over to emph1 */\n\t\t\tlen = parse_emph1(ob, doc, data - 2, size + 2, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 2;\n\n\t\t} else {\n\t\t\t/* single symbol found, handing over to emph2 */\n\t\t\tlen = parse_emph2(ob, doc, data - 1, size + 1, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* parse_math  parses a math span until the given ending delimiter */\nstatic size_t\nparse_math(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size, const char *end, size_t delimsz, int displaymode)\n{\n\thoedown_buffer text = { NULL, 0, 0, 0, NULL, NULL, NULL };\n\tsize_t i = delimsz;\n\n\tif (!doc->md.math)\n\t\treturn 0;\n\n\t/* find ending delimiter */\n\twhile (1) {\n\t\twhile (i < size && data[i] != (uint8_t)end[0])\n\t\t\ti++;\n\n\t\tif (i >= size)\n\t\t\treturn 0;\n\n\t\tif (!is_escaped(data, i) && !(i + delimsz > size)\n\t\t\t&& memcmp(data + i, end, delimsz) == 0)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\t/* prepare buffers */\n\ttext.data = data + delimsz;\n\ttext.size = i - delimsz;\n\n\t/* if this is a $$ and MATH_EXPLICIT is not active,\n\t * guess whether displaymode should be enabled from the context */\n\ti += delimsz;\n\tif (delimsz == 2 && !(doc->ext_flags & HOEDOWN_EXT_MATH_EXPLICIT))\n\t\tdisplaymode = is_empty_all(data - offset, offset) && is_empty_all(data + i, size - i);\n\n\t/* call callback */\n\tif (doc->md.math(ob, &text, displaymode, &doc->data))\n\t\treturn i;\n\n\treturn 0;\n}\n\n/* char_emphasis  single and double emphasis parsing */\nstatic size_t\nchar_emphasis(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tuint8_t c = data[0];\n\tsize_t ret;\n\n\tif (doc->ext_flags & HOEDOWN_EXT_NO_INTRA_EMPHASIS) {\n\t\tif (offset > 0 && !_isspace(data[-1]) && data[-1] != '>' && data[-1] != '(')\n\t\t\treturn 0;\n\t}\n\n\tif (size > 2 && data[1] != c) {\n\t\t/* spacing cannot follow an opening emphasis;\n\t\t * strikethrough and highlight only takes two characters '~~' */\n\t\tif (c == '~' || c == '=' || _isspace(data[1]) || (ret = parse_emph1(ob, doc, data + 1, size - 1, c)) == 0)\n\t\t\treturn 0;\n\n\t\treturn ret + 1;\n\t}\n\n\tif (size > 3 && data[1] == c && data[2] != c) {\n\t\tif (_isspace(data[2]) || (ret = parse_emph2(ob, doc, data + 2, size - 2, c)) == 0)\n\t\t\treturn 0;\n\n\t\treturn ret + 2;\n\t}\n\n\tif (size > 4 && data[1] == c && data[2] == c && data[3] != c) {\n\t\tif (c == '~' || c == '=' || _isspace(data[3]) || (ret = parse_emph3(ob, doc, data + 3, size - 3, c)) == 0)\n\t\t\treturn 0;\n\n\t\treturn ret + 3;\n\t}\n\n\treturn 0;\n}\n\n\n/* char_linebreak  '\\n' preceded by two spaces (assuming linebreak != 0) */\nstatic size_t\nchar_linebreak(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tif (offset < 2 || data[-1] != ' ' || data[-2] != ' ')\n\t\treturn 0;\n\n\t/* removing the last space from ob and rendering */\n\twhile (ob->size && ob->data[ob->size - 1] == ' ')\n\t\tob->size--;\n\n\treturn doc->md.linebreak(ob, &doc->data) ? 1 : 0;\n}\n\n\n/* char_codespan  '`' parsing a code span (assuming codespan != 0) */\nstatic size_t\nchar_codespan(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\thoedown_buffer work = { NULL, 0, 0, 0, NULL, NULL, NULL };\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\n\t/* counting the number of backticks in the delimiter */\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\n\t/* finding the next delimiter */\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\n\tif (i < nb && end >= size)\n\t\treturn 0; /* no matching delimiter */\n\n\t/* trimming outside spaces */\n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\n\t/* real code span */\n\tif (f_begin < f_end) {\n\t\twork.data = data + f_begin;\n\t\twork.size = f_end - f_begin;\n\n\t\tif (!doc->md.codespan(ob, &work, &doc->data))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!doc->md.codespan(ob, 0, &doc->data))\n\t\t\tend = 0;\n\t}\n\n\treturn end;\n}\n\n/* char_quote  '\"' parsing a quote */\nstatic size_t\nchar_quote(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nq = 0, i, f_begin, f_end;\n\n\t/* counting the number of quotes in the delimiter */\n\twhile (nq < size && data[nq] == '\"')\n\t\tnq++;\n\n\t/* finding the next delimiter */\n\tend = nq;\n\twhile (1) {\n\t\ti = end;\n\t\tend += find_emph_char(data + end, size - end, '\"');\n\t\tif (end == i) return 0;\t\t/* no matching delimiter */\n\t\ti = end;\n\t\twhile (end < size && data[end] == '\"' && end - i < nq) end++;\n\t\tif (end - i >= nq) break;\n\t}\n\n\t/* trimming outside spaces */\n\tf_begin = nq;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\n\tf_end = end - nq;\n\twhile (f_end > nq && data[f_end-1] == ' ')\n\t\tf_end--;\n\n\t/* real quote */\n\tif (f_begin < f_end) {\n\t\thoedown_buffer *work = newbuf(doc, BUFFER_SPAN);\n\t\tparse_inline(work, doc, data + f_begin, f_end - f_begin);\n\n\t\tif (!doc->md.quote(ob, work, &doc->data))\n\t\t\tend = 0;\n\t\tpopbuf(doc, BUFFER_SPAN);\n\t} else {\n\t\tif (!doc->md.quote(ob, 0, &doc->data))\n\t\t\tend = 0;\n\t}\n\n\treturn end;\n}\n\n\n/* char_escape  '\\\\' backslash escape */\nstatic size_t\nchar_escape(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tstatic const char *escape_chars = \"\\\\`*_{}[]()#+-.!:|&<>^~=\\\"$\";\n\thoedown_buffer work = { 0, 0, 0, 0, NULL, NULL, NULL };\n\tsize_t w;\n\n\tif (size > 1) {\n\t\tif (data[1] == '\\\\' && (doc->ext_flags & HOEDOWN_EXT_MATH) &&\n\t\t\tsize > 2 && (data[2] == '(' || data[2] == '[')) {\n\t\t\tconst char *end = (data[2] == '[') ? \"\\\\\\\\]\" : \"\\\\\\\\)\";\n\t\t\tw = parse_math(ob, doc, data, offset, size, end, 3, data[2] == '[');\n\t\t\tif (w) return w;\n\t\t}\n\n\t\tif (strchr(escape_chars, data[1]) == NULL)\n\t\t\treturn 0;\n\n\t\tif (doc->md.normal_text) {\n\t\t\twork.data = data + 1;\n\t\t\twork.size = 1;\n\t\t\tdoc->md.normal_text(ob, &work, &doc->data);\n\t\t}\n\t\telse hoedown_buffer_putc(ob, data[1]);\n\t} else if (size == 1) {\n\t\thoedown_buffer_putc(ob, data[0]);\n\t}\n\n\treturn 2;\n}\n\n/* char_entity  '&' escaped when it doesn't belong to an entity */\n/* valid entities are assumed to be anything matching &#?[A-Za-z0-9]+; */\nstatic size_t\nchar_entity(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end = 1;\n\thoedown_buffer work = { 0, 0, 0, 0, NULL, NULL, NULL };\n\n\tif (end < size && data[end] == '#')\n\t\tend++;\n\n\twhile (end < size && isalnum(data[end]))\n\t\tend++;\n\n\tif (end < size && data[end] == ';')\n\t\tend++; /* real entity */\n\telse\n\t\treturn 0; /* lone '&' */\n\n\tif (doc->md.entity) {\n\t\twork.data = data;\n\t\twork.size = end;\n\t\tdoc->md.entity(ob, &work, &doc->data);\n\t}\n\telse hoedown_buffer_put(ob, data, end);\n\n\treturn end;\n}\n\n/* char_langle_tag  '<' when tags or autolinks are allowed */\nstatic size_t\nchar_langle_tag(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\thoedown_buffer work = { NULL, 0, 0, 0, NULL, NULL, NULL };\n\thoedown_autolink_type altype = HOEDOWN_AUTOLINK_NONE;\n\tsize_t end = tag_length(data, size, &altype);\n\tint ret = 0;\n\n\twork.data = data;\n\twork.size = end;\n\n\tif (end > 2) {\n\t\tif (doc->md.autolink && altype != HOEDOWN_AUTOLINK_NONE) {\n\t\t\thoedown_buffer *u_link = newbuf(doc, BUFFER_SPAN);\n\t\t\twork.data = data + 1;\n\t\t\twork.size = end - 2;\n\t\t\tunscape_text(u_link, &work);\n\t\t\tret = doc->md.autolink(ob, u_link, altype, &doc->data);\n\t\t\tpopbuf(doc, BUFFER_SPAN);\n\t\t}\n\t\telse if (doc->md.raw_html)\n\t\t\tret = doc->md.raw_html(ob, &work, &doc->data);\n\t}\n\n\tif (!ret) return 0;\n\telse return end;\n}\n\nstatic size_t\nchar_autolink_www(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\thoedown_buffer *link, *link_url, *link_text;\n\tsize_t link_len, rewind;\n\n\tif (!doc->md.link || doc->in_link_body)\n\t\treturn 0;\n\n\tlink = newbuf(doc, BUFFER_SPAN);\n\n\tif ((link_len = hoedown_autolink__www(&rewind, link, data, offset, size, HOEDOWN_AUTOLINK_SHORT_DOMAINS)) > 0) {\n\t\tlink_url = newbuf(doc, BUFFER_SPAN);\n\t\tHOEDOWN_BUFPUTSL(link_url, \"http://\");\n\t\thoedown_buffer_put(link_url, link->data, link->size);\n\n\t\tif (ob->size > rewind)\n\t\t\tob->size -= rewind;\n\t\telse\n\t\t\tob->size = 0;\n\n\t\tif (doc->md.normal_text) {\n\t\t\tlink_text = newbuf(doc, BUFFER_SPAN);\n\t\t\tdoc->md.normal_text(link_text, link, &doc->data);\n\t\t\tdoc->md.link(ob, link_text, link_url, NULL, &doc->data);\n\t\t\tpopbuf(doc, BUFFER_SPAN);\n\t\t} else {\n\t\t\tdoc->md.link(ob, link, link_url, NULL, &doc->data);\n\t\t}\n\t\tpopbuf(doc, BUFFER_SPAN);\n\t}\n\n\tpopbuf(doc, BUFFER_SPAN);\n\treturn link_len;\n}\n\nstatic size_t\nchar_autolink_email(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\thoedown_buffer *link;\n\tsize_t link_len, rewind;\n\n\tif (!doc->md.autolink || doc->in_link_body)\n\t\treturn 0;\n\n\tlink = newbuf(doc, BUFFER_SPAN);\n\n\tif ((link_len = hoedown_autolink__email(&rewind, link, data, offset, size, 0)) > 0) {\n\t\tif (ob->size > rewind)\n\t\t\tob->size -= rewind;\n\t\telse\n\t\t\tob->size = 0;\n\n\t\tdoc->md.autolink(ob, link, HOEDOWN_AUTOLINK_EMAIL, &doc->data);\n\t}\n\n\tpopbuf(doc, BUFFER_SPAN);\n\treturn link_len;\n}\n\nstatic size_t\nchar_autolink_url(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\thoedown_buffer *link;\n\tsize_t link_len, rewind;\n\n\tif (!doc->md.autolink || doc->in_link_body)\n\t\treturn 0;\n\n\tlink = newbuf(doc, BUFFER_SPAN);\n\n\tif ((link_len = hoedown_autolink__url(&rewind, link, data, offset, size, 0)) > 0) {\n\t\tif (ob->size > rewind)\n\t\t\tob->size -= rewind;\n\t\telse\n\t\t\tob->size = 0;\n\n\t\tdoc->md.autolink(ob, link, HOEDOWN_AUTOLINK_NORMAL, &doc->data);\n\t}\n\n\tpopbuf(doc, BUFFER_SPAN);\n\treturn link_len;\n}\n\n/* char_link  '[': parsing a link, a footnote or an image */\nstatic size_t\nchar_link(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tint is_img = (offset && data[-1] == '!' && !is_escaped(data - offset, offset - 1));\n\tint is_footnote = (doc->ext_flags & HOEDOWN_EXT_FOOTNOTES && data[1] == '^');\n\tsize_t i = 1, txt_e, link_b = 0, link_e = 0, title_b = 0, title_e = 0;\n\thoedown_buffer *content = NULL;\n\thoedown_buffer *link = NULL;\n\thoedown_buffer *title = NULL;\n\thoedown_buffer *u_link = NULL;\n\tsize_t org_work_size = doc->work_bufs[BUFFER_SPAN].size;\n\tint ret = 0, in_title = 0, qtype = 0;\n\n\t/* checking whether the correct renderer exists */\n\tif ((is_footnote && !doc->md.footnote_ref) || (is_img && !doc->md.image)\n\t\t|| (!is_img && !is_footnote && !doc->md.link))\n\t\tgoto cleanup;\n\n\t/* looking for the matching closing bracket */\n\ti += find_emph_char(data + i, size - i, ']');\n\ttxt_e = i;\n\n\tif (i < size && data[i] == ']') i++;\n\telse goto cleanup;\n\n\t/* footnote link */\n\tif (is_footnote) {\n\t\thoedown_buffer id = { NULL, 0, 0, 0, NULL, NULL, NULL };\n\t\tstruct footnote_ref *fr;\n\n\t\tif (txt_e < 3)\n\t\t\tgoto cleanup;\n\n\t\tid.data = data + 2;\n\t\tid.size = txt_e - 2;\n\n\t\tfr = find_footnote_ref(&doc->footnotes_found, id.data, id.size);\n\n\t\t/* mark footnote used */\n\t\tif (fr && !fr->is_used) {\n\t\t\tif(!add_footnote_ref(&doc->footnotes_used, fr))\n\t\t\t\tgoto cleanup;\n\t\t\tfr->is_used = 1;\n\t\t\tfr->num = doc->footnotes_used.count;\n\n\t\t\t/* render */\n\t\t\tif (doc->md.footnote_ref)\n\t\t\t\tret = doc->md.footnote_ref(ob, fr->num, &doc->data);\n\t\t}\n\n\t\tgoto cleanup;\n\t}\n\n\t/* skip any amount of spacing */\n\t/* (this is much more laxist than original markdown syntax) */\n\twhile (i < size && _isspace(data[i]))\n\t\ti++;\n\n\t/* inline style link */\n\tif (i < size && data[i] == '(') {\n\t\tsize_t nb_p;\n\n\t\t/* skipping initial spacing */\n\t\ti++;\n\n\t\twhile (i < size && _isspace(data[i]))\n\t\t\ti++;\n\n\t\tlink_b = i;\n\n\t\t/* looking for link end: ' \" ) */\n\t\t/* Count the number of open parenthesis */\n\t\tnb_p = 0;\n\n\t\twhile (i < size) {\n\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\telse if (data[i] == '(' && i != 0) {\n\t\t\t\tnb_p++; i++;\n\t\t\t}\n\t\t\telse if (data[i] == ')') {\n\t\t\t\tif (nb_p == 0) break;\n\t\t\t\telse nb_p--; i++;\n\t\t\t} else if (i >= 1 && _isspace(data[i-1]) && (data[i] == '\\'' || data[i] == '\"')) break;\n\t\t\telse i++;\n\t\t}\n\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* looking for title end if present */\n\t\tif (data[i] == '\\'' || data[i] == '\"') {\n\t\t\tqtype = data[i];\n\t\t\tin_title = 1;\n\t\t\ti++;\n\t\t\ttitle_b = i;\n\n\t\t\twhile (i < size) {\n\t\t\t\tif (data[i] == '\\\\') i += 2;\n\t\t\t\telse if (data[i] == qtype) {in_title = 0; i++;}\n\t\t\t\telse if ((data[i] == ')') && !in_title) break;\n\t\t\t\telse i++;\n\t\t\t}\n\n\t\t\tif (i >= size) goto cleanup;\n\n\t\t\t/* skipping spacing after title */\n\t\t\ttitle_e = i - 1;\n\t\t\twhile (title_e > title_b && _isspace(data[title_e]))\n\t\t\t\ttitle_e--;\n\n\t\t\t/* checking for closing quote presence */\n\t\t\tif (data[title_e] != '\\'' &&  data[title_e] != '\"') {\n\t\t\t\ttitle_b = title_e = 0;\n\t\t\t\tlink_e = i;\n\t\t\t}\n\t\t}\n\n\t\t/* remove spacing at the end of the link */\n\t\twhile (link_e > link_b && _isspace(data[link_e - 1]))\n\t\t\tlink_e--;\n\n\t\t/* remove optional angle brackets around the link */\n\t\tif (data[link_b] == '<' && data[link_e - 1] == '>') {\n\t\t\tlink_b++;\n\t\t\tlink_e--;\n\t\t}\n\n\t\t/* building escaped link and title */\n\t\tif (link_e > link_b) {\n\t\t\tlink = newbuf(doc, BUFFER_SPAN);\n\t\t\thoedown_buffer_put(link, data + link_b, link_e - link_b);\n\t\t}\n\n\t\tif (title_e > title_b) {\n\t\t\ttitle = newbuf(doc, BUFFER_SPAN);\n\t\t\thoedown_buffer_put(title, data + title_b, title_e - title_b);\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/* reference style link */\n\telse if (i < size && data[i] == '[') {\n\t\thoedown_buffer *id = newbuf(doc, BUFFER_SPAN);\n\t\tstruct link_ref *lr;\n\n\t\t/* looking for the id */\n\t\ti++;\n\t\tlink_b = i;\n\t\twhile (i < size && data[i] != ']') i++;\n\t\tif (i >= size) goto cleanup;\n\t\tlink_e = i;\n\n\t\t/* finding the link_ref */\n\t\tif (link_b == link_e)\n\t\t\treplace_spacing(id, data + 1, txt_e - 1);\n\t\telse\n\t\t\thoedown_buffer_put(id, data + link_b, link_e - link_b);\n\n\t\tlr = find_link_ref(doc->refs, id->data, id->size);\n\t\tif (!lr)\n\t\t\tgoto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\t\ti++;\n\t}\n\n\t/* shortcut reference style link */\n\telse {\n\t\thoedown_buffer *id = newbuf(doc, BUFFER_SPAN);\n\t\tstruct link_ref *lr;\n\n\t\t/* crafting the id */\n\t\treplace_spacing(id, data + 1, txt_e - 1);\n\n\t\t/* finding the link_ref */\n\t\tlr = find_link_ref(doc->refs, id->data, id->size);\n\t\tif (!lr)\n\t\t\tgoto cleanup;\n\n\t\t/* keeping link and title from link_ref */\n\t\tlink = lr->link;\n\t\ttitle = lr->title;\n\n\t\t/* rewinding the spacing */\n\t\ti = txt_e + 1;\n\t}\n\n\t/* building content: img alt is kept, only link content is parsed */\n\tif (txt_e > 1) {\n\t\tcontent = newbuf(doc, BUFFER_SPAN);\n\t\tif (is_img) {\n\t\t\thoedown_buffer_put(content, data + 1, txt_e - 1);\n\t\t} else {\n\t\t\t/* disable autolinking when parsing inline the\n\t\t\t * content of a link */\n\t\t\tdoc->in_link_body = 1;\n\t\t\tparse_inline(content, doc, data + 1, txt_e - 1);\n\t\t\tdoc->in_link_body = 0;\n\t\t}\n\t}\n\n\tif (link) {\n\t\tu_link = newbuf(doc, BUFFER_SPAN);\n\t\tunscape_text(u_link, link);\n\t}\n\n\t/* calling the relevant rendering function */\n\tif (is_img) {\n\t\tif (ob->size && ob->data[ob->size - 1] == '!')\n\t\t\tob->size -= 1;\n\n\t\tret = doc->md.image(ob, u_link, title, content, &doc->data);\n\t} else {\n\t\tret = doc->md.link(ob, content, u_link, title, &doc->data);\n\t}\n\n\t/* cleanup */\ncleanup:\n\tdoc->work_bufs[BUFFER_SPAN].size = (int)org_work_size;\n\treturn ret ? i : 0;\n}\n\nstatic size_t\nchar_superscript(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t sup_start, sup_len;\n\thoedown_buffer *sup;\n\n\tif (!doc->md.superscript)\n\t\treturn 0;\n\n\tif (size < 2)\n\t\treturn 0;\n\n\tif (data[1] == '(') {\n\t\tsup_start = 2;\n\t\tsup_len = find_emph_char(data + 2, size - 2, ')') + 2;\n\n\t\tif (sup_len == size)\n\t\t\treturn 0;\n\t} else {\n\t\tsup_start = sup_len = 1;\n\n\t\twhile (sup_len < size && !_isspace(data[sup_len]))\n\t\t\tsup_len++;\n\t}\n\n\tif (sup_len - sup_start == 0)\n\t\treturn (sup_start == 2) ? 3 : 0;\n\n\tsup = newbuf(doc, BUFFER_SPAN);\n\tparse_inline(sup, doc, data + sup_start, sup_len - sup_start);\n\tdoc->md.superscript(ob, sup, &doc->data);\n\tpopbuf(doc, BUFFER_SPAN);\n\n\treturn (sup_start == 2) ? sup_len + 1 : sup_len;\n}\n\nstatic size_t\nchar_math(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t offset, size_t size)\n{\n\t/* double dollar */\n\tif (size > 1 && data[1] == '$')\n\t\treturn parse_math(ob, doc, data, offset, size, \"$$\", 2, 1);\n\n\t/* single dollar allowed only with MATH_EXPLICIT flag */\n\tif (doc->ext_flags & HOEDOWN_EXT_MATH_EXPLICIT)\n\t\treturn parse_math(ob, doc, data, offset, size, \"$\", 1, 0);\n\n\treturn 0;\n}\n\n/*********************************\n * BLOCK-LEVEL PARSING FUNCTIONS *\n *********************************/\n\n/* is_empty  returns the line length when it is empty, 0 otherwise */\nstatic size_t\nis_empty(const uint8_t *data, size_t size)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\n\treturn i + 1;\n}\n\n/* is_hrule  returns whether a line is a horizontal rule */\nstatic int\nis_hrule(uint8_t *data, size_t size)\n{\n\tsize_t i = 0, n = 0;\n\tuint8_t c;\n\n\t/* skipping initial spaces */\n\tif (size < 3) return 0;\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\t/* looking at the hrule uint8_t */\n\tif (i + 2 >= size\n\t|| (data[i] != '*' && data[i] != '-' && data[i] != '_'))\n\t\treturn 0;\n\tc = data[i];\n\n\t/* the whole line must be the char or space */\n\twhile (i < size && data[i] != '\\n') {\n\t\tif (data[i] == c) n++;\n\t\telse if (data[i] != ' ')\n\t\t\treturn 0;\n\n\t\ti++;\n\t}\n\n\treturn n >= 3;\n}\n\n/* check if a line is a code fence; return the\n * end of the code fence. if passed, width of\n * the fence rule and character will be returned */\nstatic size_t\nis_codefence(uint8_t *data, size_t size, size_t *width, uint8_t *chr)\n{\n\tsize_t i = 0, n = 1;\n\tuint8_t c;\n\n\t/* skipping initial spaces */\n\tif (size < 3)\n\t\treturn 0;\n\n\tif (data[0] == ' ') { i++;\n\tif (data[1] == ' ') { i++;\n\tif (data[2] == ' ') { i++; } } }\n\n\t/* looking at the hrule uint8_t */\n\tc = data[i];\n\tif (i + 2 >= size || !(c=='~' || c=='`'))\n\t\treturn 0;\n\n\t/* the fence must be that same character */\n\twhile (++i < size && data[i] == c)\n\t\t++n;\n\n\tif (n < 3)\n\t\treturn 0;\n\n\tif (width) *width = n;\n\tif (chr) *chr = c;\n\treturn i;\n}\n\n/* expects single line, checks if it's a codefence and extracts language */\nstatic size_t\nparse_codefence(uint8_t *data, size_t size, hoedown_buffer *lang, size_t *width, uint8_t *chr)\n{\n\tsize_t i, w, lang_start;\n\n\ti = w = is_codefence(data, size, width, chr);\n\tif (i == 0)\n\t\treturn 0;\n\n\twhile (i < size && _isspace(data[i]))\n\t\ti++;\n\n\tlang_start = i;\n\n\twhile (i < size && !_isspace(data[i]))\n\t\ti++;\n\n\tlang->data = data + lang_start;\n\tlang->size = i - lang_start;\n\n\t/* Avoid parsing a codespan as a fence */\n\ti = lang_start + 2;\n\twhile (i < size && !(data[i] == *chr && data[i-1] == *chr && data[i-2] == *chr)) i++;\n\tif (i < size) return 0;\n\n\treturn w;\n}\n\n/* is_atxheader  returns whether the line is a hash-prefixed header */\nstatic int\nis_atxheader(hoedown_document *doc, uint8_t *data, size_t size)\n{\n\tif (data[0] != '#')\n\t\treturn 0;\n\n\tif (doc->ext_flags & HOEDOWN_EXT_SPACE_HEADERS) {\n\t\tsize_t level = 0;\n\n\t\twhile (level < size && level < 6 && data[level] == '#')\n\t\t\tlevel++;\n\n\t\tif (level < size && data[level] != ' ')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* is_headerline  returns whether the line is a setext-style hdr underline */\nstatic int\nis_headerline(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\t/* test of level 1 header */\n\tif (data[i] == '=') {\n\t\tfor (i = 1; i < size && data[i] == '='; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 1 : 0; }\n\n\t/* test of level 2 header */\n\tif (data[i] == '-') {\n\t\tfor (i = 1; i < size && data[i] == '-'; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 2 : 0; }\n\n\t/* test of level 3 header */\n\tif (data[i] == '~') {\n\t\tfor (i = 1; i < size && data[i] == '~'; i++);\n\t\twhile (i < size && data[i] == ' ') i++;\n\t\treturn (i >= size || data[i] == '\\n') ? 3 : 0; }\n\treturn 0;\n}\n\nstatic int\nis_next_headerline(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\twhile (i < size && data[i] != '\\n')\n\t\ti++;\n\n\tif (++i >= size)\n\t\treturn 0;\n\n\treturn is_headerline(data + i, size - i);\n}\n\n/* prefix_quote  returns blockquote prefix length */\nstatic size_t\nprefix_quote(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i < size && data[i] == '>') {\n\t\tif (i + 1 < size && data[i + 1] == ' ')\n\t\t\treturn i + 2;\n\n\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\n/* prefix_code  returns prefix length for block code*/\nstatic size_t\nprefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\n\treturn 0;\n}\n\n/* prefix_oli  returns ordered list item prefix */\nstatic size_t\nprefix_oli(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i >= size || data[i] < '0' || data[i] > '9')\n\t\treturn 0;\n\n\twhile (i < size && data[i] >= '0' && data[i] <= '9')\n\t\ti++;\n\n\tif (i + 1 >= size || data[i] != '.' || data[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}\n\n/* prefix_uli  returns ordered list item prefix */\nstatic size_t\nprefix_uli(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i + 1 >= size ||\n\t\t(data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n\t\tdata[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}\n\n\n/* parse_block  parsing of one block, returning next uint8_t to parse */\nstatic void parse_block(hoedown_buffer *ob, hoedown_document *doc,\n\t\t\tuint8_t *data, size_t size);\n\n\n/* parse_blockquote  handles parsing of a blockquote fragment */\nstatic size_t\nparse_blockquote(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\tsize_t beg, end = 0, pre, work_size = 0;\n\tuint8_t *work_data = 0;\n\thoedown_buffer *out = 0;\n\n\tout = newbuf(doc, BUFFER_BLOCK);\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n\n\t\tpre = prefix_quote(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\n\t\t/* empty line followed by non-quote line */\n\t\telse if (is_empty(data + beg, end - beg) &&\n\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n\t\t\t\t!is_empty(data + end, size - end))))\n\t\t\tbreak;\n\n\t\tif (beg < end) { /* copy into the in-place working buffer */\n\t\t\t/* hoedown_buffer_put(work, data + beg, end - beg); */\n\t\t\tif (!work_data)\n\t\t\t\twork_data = data + beg;\n\t\t\telse if (data + beg != work_data + work_size)\n\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n\t\t\twork_size += end - beg;\n\t\t}\n\t\tbeg = end;\n\t}\n\n\tparse_block(out, doc, work_data, work_size);\n\tif (doc->md.blockquote)\n\t\tdoc->md.blockquote(ob, out, &doc->data);\n\tpopbuf(doc, BUFFER_BLOCK);\n\treturn end;\n}\n\nstatic size_t\nparse_htmlblock(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, int do_render);\n\n/* parse_blockquote  handles parsing of a regular paragraph */\nstatic size_t\nparse_paragraph(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\thoedown_buffer work = { NULL, 0, 0, 0, NULL, NULL, NULL };\n\tsize_t i = 0, end = 0;\n\tint level = 0;\n\n\twork.data = data;\n\n\twhile (i < size) {\n\t\tfor (end = i + 1; end < size && data[end - 1] != '\\n'; end++) /* empty */;\n\n\t\tif (is_empty(data + i, size - i))\n\t\t\tbreak;\n\n\t\tif ((level = is_headerline(data + i, size - i)) != 0)\n\t\t\tbreak;\n\n\t\tif (is_atxheader(doc, data + i, size - i) ||\n\t\t\tis_hrule(data + i, size - i) ||\n\t\t\tprefix_quote(data + i, size - i)) {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\n\t\ti = end;\n\t}\n\n\twork.size = i;\n\twhile (work.size && data[work.size - 1] == '\\n')\n\t\twork.size--;\n\n\tif (!level) {\n\t\thoedown_buffer *tmp = newbuf(doc, BUFFER_BLOCK);\n\t\tparse_inline(tmp, doc, work.data, work.size);\n\t\tif (doc->md.paragraph)\n\t\t\tdoc->md.paragraph(ob, tmp, &doc->data);\n\t\tpopbuf(doc, BUFFER_BLOCK);\n\t} else {\n\t\thoedown_buffer *header_work;\n\n\t\tif (work.size) {\n\t\t\tsize_t beg;\n\t\t\ti = work.size;\n\t\t\twork.size -= 1;\n\n\t\t\twhile (work.size && data[work.size] != '\\n')\n\t\t\t\twork.size -= 1;\n\n\t\t\tbeg = work.size + 1;\n\t\t\twhile (work.size && data[work.size - 1] == '\\n')\n\t\t\t\twork.size -= 1;\n\n\t\t\tif (work.size > 0) {\n\t\t\t\thoedown_buffer *tmp = newbuf(doc, BUFFER_BLOCK);\n\t\t\t\tparse_inline(tmp, doc, work.data, work.size);\n\n\t\t\t\tif (doc->md.paragraph)\n\t\t\t\t\tdoc->md.paragraph(ob, tmp, &doc->data);\n\n\t\t\t\tpopbuf(doc, BUFFER_BLOCK);\n\t\t\t\twork.data += beg;\n\t\t\t\twork.size = i - beg;\n\t\t\t}\n\t\t\telse work.size = i;\n\t\t}\n\n\t\theader_work = newbuf(doc, BUFFER_SPAN);\n\t\tparse_inline(header_work, doc, work.data, work.size);\n\n\t\tif (doc->md.header)\n\t\t\tdoc->md.header(ob, header_work, (int)level, &doc->data);\n\n\t\tpopbuf(doc, BUFFER_SPAN);\n\t}\n\n\treturn end;\n}\n\n/* parse_fencedcode  handles parsing of a block-level code fragment */\nstatic size_t\nparse_fencedcode(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\thoedown_buffer text = { 0, 0, 0, 0, NULL, NULL, NULL };\n\thoedown_buffer lang = { 0, 0, 0, 0, NULL, NULL, NULL };\n\tsize_t i = 0, text_start, line_start;\n\tsize_t w, w2;\n\tsize_t width, width2;\n\tuint8_t chr, chr2;\n\n\t/* parse codefence line */\n\twhile (i < size && data[i] != '\\n')\n\t\ti++;\n\n\tw = parse_codefence(data, i, &lang, &width, &chr);\n\tif (!w)\n\t\treturn 0;\n\n\t/* search for end */\n\ti++;\n\ttext_start = i;\n\twhile ((line_start = i) < size) {\n\t\twhile (i < size && data[i] != '\\n')\n\t\t\ti++;\n\n\t\tw2 = is_codefence(data + line_start, i - line_start, &width2, &chr2);\n\t\tif (w == w2 && width == width2 && chr == chr2 &&\n\t\t    is_empty(data + (line_start+w), i - (line_start+w)))\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\ttext.data = data + text_start;\n\ttext.size = line_start - text_start;\n\n\tif (doc->md.blockcode)\n\t\tdoc->md.blockcode(ob, text.size ? &text : NULL, lang.size ? &lang : NULL, &doc->data);\n\n\treturn i;\n}\n\nstatic size_t\nparse_blockcode(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\tsize_t beg, end, pre;\n\thoedown_buffer *work = 0;\n\n\twork = newbuf(doc, BUFFER_BLOCK);\n\n\tbeg = 0;\n\twhile (beg < size) {\n\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++) {};\n\t\tpre = prefix_code(data + beg, end - beg);\n\n\t\tif (pre)\n\t\t\tbeg += pre; /* skipping prefix */\n\t\telse if (!is_empty(data + beg, end - beg))\n\t\t\t/* non-empty non-prefixed line breaks the pre */\n\t\t\tbreak;\n\n\t\tif (beg < end) {\n\t\t\t/* verbatim copy to the working buffer,\n\t\t\t\tescaping entities */\n\t\t\tif (is_empty(data + beg, end - beg))\n\t\t\t\thoedown_buffer_putc(work, '\\n');\n\t\t\telse hoedown_buffer_put(work, data + beg, end - beg);\n\t\t}\n\t\tbeg = end;\n\t}\n\n\twhile (work->size && work->data[work->size - 1] == '\\n')\n\t\twork->size -= 1;\n\n\thoedown_buffer_putc(work, '\\n');\n\n\tif (doc->md.blockcode)\n\t\tdoc->md.blockcode(ob, work, NULL, &doc->data);\n\n\tpopbuf(doc, BUFFER_BLOCK);\n\treturn beg;\n}\n\n/* parse_listitem  parsing of a single list item */\n/*\tassuming initial prefix is already removed */\nstatic size_t\nparse_listitem(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, hoedown_list_flags *flags)\n{\n\thoedown_buffer *work = 0, *inter = 0;\n\tsize_t beg = 0, end, pre, sublist = 0, orgpre = 0, i;\n\tint in_empty = 0, has_inside_empty = 0, in_fence = 0;\n\n\t/* keeping track of the first indentation prefix */\n\twhile (orgpre < 3 && orgpre < size && data[orgpre] == ' ')\n\t\torgpre++;\n\n\tbeg = prefix_uli(data, size);\n\tif (!beg)\n\t\tbeg = prefix_oli(data, size);\n\n\tif (!beg)\n\t\treturn 0;\n\n\t/* skipping to the beginning of the following line */\n\tend = beg;\n\twhile (end < size && data[end - 1] != '\\n')\n\t\tend++;\n\n\t/* getting working buffers */\n\twork = newbuf(doc, BUFFER_SPAN);\n\tinter = newbuf(doc, BUFFER_SPAN);\n\n\t/* putting the first line into the working buffer */\n\thoedown_buffer_put(work, data + beg, end - beg);\n\tbeg = end;\n\n\t/* process the following lines */\n\twhile (beg < size) {\n\t\tsize_t has_next_uli = 0, has_next_oli = 0;\n\n\t\tend++;\n\n\t\twhile (end < size && data[end - 1] != '\\n')\n\t\t\tend++;\n\n\t\t/* process an empty line */\n\t\tif (is_empty(data + beg, end - beg)) {\n\t\t\tin_empty = 1;\n\t\t\tbeg = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* calculating the indentation */\n\t\ti = 0;\n\t\twhile (i < 4 && beg + i < end && data[beg + i] == ' ')\n\t\t\ti++;\n\n\t\tpre = i;\n\n\t\tif (doc->ext_flags & HOEDOWN_EXT_FENCED_CODE) {\n\t\t\tif (is_codefence(data + beg + i, end - beg - i, NULL, NULL))\n\t\t\t\tin_fence = !in_fence;\n\t\t}\n\n\t\t/* Only check for new list items if we are **not** inside\n\t\t * a fenced code block */\n\t\tif (!in_fence) {\n\t\t\thas_next_uli = prefix_uli(data + beg + i, end - beg - i);\n\t\t\thas_next_oli = prefix_oli(data + beg + i, end - beg - i);\n\t\t}\n\n\t\t/* checking for a new item */\n\t\tif ((has_next_uli && !is_hrule(data + beg + i, end - beg - i)) || has_next_oli) {\n\t\t\tif (in_empty)\n\t\t\t\thas_inside_empty = 1;\n\n\t\t\t/* the following item must have the same (or less) indentation */\n\t\t\tif (pre <= orgpre) {\n\t\t\t\t/* if the following item has different list type, we end this list */\n\t\t\t\tif (in_empty && (\n\t\t\t\t\t((*flags & HOEDOWN_LIST_ORDERED) && has_next_uli) ||\n\t\t\t\t\t(!(*flags & HOEDOWN_LIST_ORDERED) && has_next_oli)))\n\t\t\t\t\t*flags = (hoedown_list_flags)( *flags | HOEDOWN_LI_END );\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!sublist)\n\t\t\t\tsublist = work->size;\n\t\t}\n\t\t/* joining only indented stuff after empty lines;\n\t\t * note that now we only require 1 space of indentation\n\t\t * to continue a list */\n\t\telse if (in_empty && pre == 0) {\n\t\t\t*flags = (hoedown_list_flags)( *flags | HOEDOWN_LI_END );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (in_empty) {\n\t\t\thoedown_buffer_putc(work, '\\n');\n\t\t\thas_inside_empty = 1;\n\t\t\tin_empty = 0;\n\t\t}\n\n\t\t/* adding the line without prefix into the working buffer */\n\t\thoedown_buffer_put(work, data + beg + i, end - beg - i);\n\t\tbeg = end;\n\t}\n\n\t/* render of li contents */\n\tif (has_inside_empty)\n\t\t*flags = (hoedown_list_flags)( *flags | HOEDOWN_LI_BLOCK );\n\n\tif (*flags & HOEDOWN_LI_BLOCK) {\n\t\t/* intermediate render of block li */\n\t\tif (sublist && sublist < work->size) {\n\t\t\tparse_block(inter, doc, work->data, sublist);\n\t\t\tparse_block(inter, doc, work->data + sublist, work->size - sublist);\n\t\t}\n\t\telse\n\t\t\tparse_block(inter, doc, work->data, work->size);\n\t} else {\n\t\t/* intermediate render of inline li */\n\t\tif (sublist && sublist < work->size) {\n\t\t\tparse_inline(inter, doc, work->data, sublist);\n\t\t\tparse_block(inter, doc, work->data + sublist, work->size - sublist);\n\t\t}\n\t\telse\n\t\t\tparse_inline(inter, doc, work->data, work->size);\n\t}\n\n\t/* render of li itself */\n\tif (doc->md.listitem)\n\t\tdoc->md.listitem(ob, inter, *flags, &doc->data);\n\n\tpopbuf(doc, BUFFER_SPAN);\n\tpopbuf(doc, BUFFER_SPAN);\n\treturn beg;\n}\n\n\n/* parse_list  parsing ordered or unordered list block */\nstatic size_t\nparse_list(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, hoedown_list_flags flags)\n{\n\thoedown_buffer *work = 0;\n\tsize_t i = 0, j;\n\n\twork = newbuf(doc, BUFFER_BLOCK);\n\n\twhile (i < size) {\n\t\tj = parse_listitem(work, doc, data + i, size - i, &flags);\n\t\ti += j;\n\n\t\tif (!j || (flags & HOEDOWN_LI_END))\n\t\t\tbreak;\n\t}\n\n\tif (doc->md.list)\n\t\tdoc->md.list(ob, work, flags, &doc->data);\n\tpopbuf(doc, BUFFER_BLOCK);\n\treturn i;\n}\n\n/* parse_atxheader  parsing of atx-style headers */\nstatic size_t\nparse_atxheader(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\n\tif (end > i) {\n\t\thoedown_buffer *work = newbuf(doc, BUFFER_SPAN);\n\n\t\tparse_inline(work, doc, data + i, end - i);\n\n\t\tif (doc->md.header)\n\t\t\tdoc->md.header(ob, work, (int)level, &doc->data);\n\n\t\tpopbuf(doc, BUFFER_SPAN);\n\t}\n\n\treturn skip;\n}\n\n/* parse_footnote_def  parse a single footnote definition */\nstatic void\nparse_footnote_def(hoedown_buffer *ob, hoedown_document *doc, unsigned int num, uint8_t *data, size_t size)\n{\n\thoedown_buffer *work = 0;\n\twork = newbuf(doc, BUFFER_SPAN);\n\n\tparse_block(work, doc, data, size);\n\n\tif (doc->md.footnote_def)\n\tdoc->md.footnote_def(ob, work, num, &doc->data);\n\tpopbuf(doc, BUFFER_SPAN);\n}\n\n/* parse_footnote_list  render the contents of the footnotes */\nstatic void\nparse_footnote_list(hoedown_buffer *ob, hoedown_document *doc, struct footnote_list *footnotes)\n{\n\thoedown_buffer *work = 0;\n\tstruct footnote_item *item;\n\tstruct footnote_ref *ref;\n\n\tif (footnotes->count == 0)\n\t\treturn;\n\n\twork = newbuf(doc, BUFFER_BLOCK);\n\n\titem = footnotes->head;\n\twhile (item) {\n\t\tref = item->ref;\n\t\tparse_footnote_def(work, doc, ref->num, ref->contents->data, ref->contents->size);\n\t\titem = item->next;\n\t}\n\n\tif (doc->md.footnotes)\n\t\tdoc->md.footnotes(ob, work, &doc->data);\n\tpopbuf(doc, BUFFER_BLOCK);\n}\n\n/* htmlblock_is_end  check for end of HTML block : </tag>( *)\\n */\n/*\treturns tag length on match, 0 otherwise */\n/*\tassumes data starts with \"<\" */\nstatic size_t\nhtmlblock_is_end(\n\tconst char *tag,\n\tsize_t tag_len,\n\thoedown_document *doc,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i = tag_len + 3, w;\n\n\t/* try to match the end tag */\n\t/* note: we're not considering tags like \"</tag >\" which are still valid */\n\tif (i > size ||\n\t\tdata[1] != '/' ||\n\t\tstrncasecmp((char *)data + 2, tag, tag_len) != 0 ||\n\t\tdata[tag_len + 2] != '>')\n\t\treturn 0;\n\n\t/* rest of the line must be empty */\n\tif ((w = is_empty(data + i, size - i)) == 0 && i < size)\n\t\treturn 0;\n\n\treturn i + w;\n}\n\n/* htmlblock_find_end  try to find HTML block ending tag */\n/*\treturns the length on match, 0 otherwise */\nstatic size_t\nhtmlblock_find_end(\n\tconst char *tag,\n\tsize_t tag_len,\n\thoedown_document *doc,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i = 0, w;\n\n\twhile (1) {\n\t\twhile (i < size && data[i] != '<') i++;\n\t\tif (i >= size) return 0;\n\n\t\tw = htmlblock_is_end(tag, tag_len, doc, data + i, size - i);\n\t\tif (w) return i + w;\n\t\ti++;\n\t}\n}\n\n/* htmlblock_find_end_strict  try to find end of HTML block in strict mode */\n/*\t(it must be an unindented line, and have a blank line afterwads) */\n/*\treturns the length on match, 0 otherwise */\nstatic size_t\nhtmlblock_find_end_strict(\n\tconst char *tag,\n\tsize_t tag_len,\n\thoedown_document *doc,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i = 0, mark;\n\n\twhile (1) {\n\t\tmark = i;\n\t\twhile (i < size && data[i] != '\\n') i++;\n\t\tif (i < size) i++;\n\t\tif (i == mark) return 0;\n\n\t\tif (data[mark] == ' ' && mark > 0) continue;\n\t\tmark += htmlblock_find_end(tag, tag_len, doc, data + mark, i - mark);\n\t\tif (mark == i && (is_empty(data + i, size - i) || i >= size)) break;\n\t}\n\n\treturn i;\n}\n\n/* parse_htmlblock  parsing of inline HTML block */\nstatic size_t\nparse_htmlblock(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size, int do_render)\n{\n\thoedown_buffer work = { NULL, 0, 0, 0, NULL, NULL, NULL };\n\tsize_t i, j = 0, tag_len, tag_end;\n\tconst char *curtag = NULL;\n\n\twork.data = data;\n\n\t/* identification of the opening tag */\n\tif (size < 2 || data[0] != '<')\n\t\treturn 0;\n\n\ti = 1;\n\twhile (i < size && data[i] != '>' && data[i] != ' ')\n\t\ti++;\n\n\tif (i < size)\n\t\tcurtag = hoedown_find_block_tag((char *)data + 1, (int)i - 1);\n\n\t/* handling of special cases */\n\tif (!curtag) {\n\n\t\t/* HTML comment, laxist form */\n\t\tif (size > 5 && data[1] == '!' && data[2] == '-' && data[3] == '-') {\n\t\t\ti = 5;\n\n\t\t\twhile (i < size && !(data[i - 2] == '-' && data[i - 1] == '-' && data[i] == '>'))\n\t\t\t\ti++;\n\n\t\t\ti++;\n\n\t\t\tif (i < size)\n\t\t\t\tj = is_empty(data + i, size - i);\n\n\t\t\tif (j) {\n\t\t\t\twork.size = i + j;\n\t\t\t\tif (do_render && doc->md.blockhtml)\n\t\t\t\t\tdoc->md.blockhtml(ob, &work, &doc->data);\n\t\t\t\treturn work.size;\n\t\t\t}\n\t\t}\n\n\t\t/* HR, which is the only self-closing block tag considered */\n\t\tif (size > 4 && (data[1] == 'h' || data[1] == 'H') && (data[2] == 'r' || data[2] == 'R')) {\n\t\t\ti = 3;\n\t\t\twhile (i < size && data[i] != '>')\n\t\t\t\ti++;\n\n\t\t\tif (i + 1 < size) {\n\t\t\t\ti++;\n\t\t\t\tj = is_empty(data + i, size - i);\n\t\t\t\tif (j) {\n\t\t\t\t\twork.size = i + j;\n\t\t\t\t\tif (do_render && doc->md.blockhtml)\n\t\t\t\t\t\tdoc->md.blockhtml(ob, &work, &doc->data);\n\t\t\t\t\treturn work.size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* no special case recognised */\n\t\treturn 0;\n\t}\n\n\t/* looking for a matching closing tag in strict mode */\n\ttag_len = strlen(curtag);\n\ttag_end = htmlblock_find_end_strict(curtag, tag_len, doc, data, size);\n\n\t/* if not found, trying a second pass looking for indented match */\n\t/* but not if tag is \"ins\" or \"del\" (following original Markdown.pl) */\n\tif (!tag_end && strcmp(curtag, \"ins\") != 0 && strcmp(curtag, \"del\") != 0)\n\t\ttag_end = htmlblock_find_end(curtag, tag_len, doc, data, size);\n\n\tif (!tag_end)\n\t\treturn 0;\n\n\t/* the end of the block has been found */\n\twork.size = tag_end;\n\tif (do_render && doc->md.blockhtml)\n\t\tdoc->md.blockhtml(ob, &work, &doc->data);\n\n\treturn tag_end;\n}\n\nstatic void\nparse_table_row(\n\thoedown_buffer *ob,\n\thoedown_document *doc,\n\tuint8_t *data,\n\tsize_t size,\n\tsize_t columns,\n\thoedown_table_flags *col_data,\n\thoedown_table_flags header_flag)\n{\n\tsize_t i = 0, col, len;\n\thoedown_buffer *row_work = 0;\n\n\tif (!doc->md.table_cell || !doc->md.table_row)\n\t\treturn;\n\n\trow_work = newbuf(doc, BUFFER_SPAN);\n\n\tif (i < size && data[i] == '|')\n\t\ti++;\n\n\tfor (col = 0; col < columns && i < size; ++col) {\n\t\tsize_t cell_start, cell_end;\n\t\thoedown_buffer *cell_work;\n\n\t\tcell_work = newbuf(doc, BUFFER_SPAN);\n\n\t\twhile (i < size && _isspace(data[i]))\n\t\t\ti++;\n\n\t\tcell_start = i;\n\n\t\tlen = find_emph_char(data + i, size - i, '|');\n\n\t\t/* Two possibilities for len == 0:\n\t\t   1) No more pipe char found in the current line.\n\t\t   2) The next pipe is right after the current one, i.e. empty cell.\n\t\t   For case 1, we skip to the end of line; for case 2 we just continue.\n\t\t*/\n\t\tif (len == 0 && i < size && data[i] != '|')\n\t\t\tlen = size - i;\n\t\ti += len;\n\n\t\tcell_end = i - 1;\n\n\t\twhile (cell_end > cell_start && _isspace(data[cell_end]))\n\t\t\tcell_end--;\n\n\t\tparse_inline(cell_work, doc, data + cell_start, 1 + cell_end - cell_start);\n\t\tdoc->md.table_cell(row_work, cell_work, (hoedown_table_flags)( col_data[col] | header_flag ), &doc->data);\n\n\t\tpopbuf(doc, BUFFER_SPAN);\n\t\ti++;\n\t}\n\n\tfor (; col < columns; ++col) {\n\t\thoedown_buffer empty_cell = { 0, 0, 0, 0, NULL, NULL, NULL };\n\t\tdoc->md.table_cell(row_work, &empty_cell, (hoedown_table_flags)( col_data[col] | header_flag ), &doc->data);\n\t}\n\n\tdoc->md.table_row(ob, row_work, &doc->data);\n\n\tpopbuf(doc, BUFFER_SPAN);\n}\n\nstatic size_t\nparse_table_header(\n\thoedown_buffer *ob,\n\thoedown_document *doc,\n\tuint8_t *data,\n\tsize_t size,\n\tsize_t *columns,\n\thoedown_table_flags **column_data)\n{\n\tint pipes;\n\tsize_t i = 0, col, header_end, under_end;\n\n\tpipes = 0;\n\twhile (i < size && data[i] != '\\n')\n\t\tif (data[i++] == '|')\n\t\t\tpipes++;\n\n\tif (i == size || pipes == 0)\n\t\treturn 0;\n\n\theader_end = i;\n\n\twhile (header_end > 0 && _isspace(data[header_end - 1]))\n\t\theader_end--;\n\n\tif (data[0] == '|')\n\t\tpipes--;\n\n\tif (header_end && data[header_end - 1] == '|')\n\t\tpipes--;\n\n\tif (pipes < 0)\n\t\treturn 0;\n\n\t*columns = pipes + 1;\n\t*column_data = (hoedown_table_flags*) hoedown_calloc(*columns, sizeof(hoedown_table_flags));\n\n\t/* Parse the header underline */\n\ti++;\n\tif (i < size && data[i] == '|')\n\t\ti++;\n\n\tunder_end = i;\n\twhile (under_end < size && data[under_end] != '\\n')\n\t\tunder_end++;\n\n\tfor (col = 0; col < *columns && i < under_end; ++col) {\n\t\tsize_t dashes = 0;\n\n\t\twhile (i < under_end && data[i] == ' ')\n\t\t\ti++;\n\n\t\tif (data[i] == ':') {\n\t\t\ti++; (*column_data)[col] = (hoedown_table_flags)( (*column_data)[col] | HOEDOWN_TABLE_ALIGN_LEFT );\n\t\t\tdashes++;\n\t\t}\n\n\t\twhile (i < under_end && data[i] == '-') {\n\t\t\ti++; dashes++;\n\t\t}\n\n\t\tif (i < under_end && data[i] == ':') {\n\t\t\ti++; (*column_data)[col] = (hoedown_table_flags)( (*column_data)[col] | HOEDOWN_TABLE_ALIGN_RIGHT );\n\t\t\tdashes++;\n\t\t}\n\n\t\twhile (i < under_end && data[i] == ' ')\n\t\t\ti++;\n\n\t\tif (i < under_end && data[i] != '|' && data[i] != '+')\n\t\t\tbreak;\n\n\t\tif (dashes < 3)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tif (col < *columns)\n\t\treturn 0;\n\n\tparse_table_row(\n\t\tob, doc, data,\n\t\theader_end,\n\t\t*columns,\n\t\t*column_data,\n\t\tHOEDOWN_TABLE_HEADER\n\t);\n\n\treturn under_end + 1;\n}\n\nstatic size_t\nparse_table(\n\thoedown_buffer *ob,\n\thoedown_document *doc,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i;\n\n\thoedown_buffer *work = 0;\n\thoedown_buffer *header_work = 0;\n\thoedown_buffer *body_work = 0;\n\n\tsize_t columns;\n\thoedown_table_flags *col_data = NULL;\n\n\twork = newbuf(doc, BUFFER_BLOCK);\n\theader_work = newbuf(doc, BUFFER_SPAN);\n\tbody_work = newbuf(doc, BUFFER_BLOCK);\n\n\ti = parse_table_header(header_work, doc, data, size, &columns, &col_data);\n\tif (i > 0) {\n\n\t\twhile (i < size) {\n\t\t\tsize_t row_start;\n\t\t\tint pipes = 0;\n\n\t\t\trow_start = i;\n\n\t\t\twhile (i < size && data[i] != '\\n')\n\t\t\t\tif (data[i++] == '|')\n\t\t\t\t\tpipes++;\n\n\t\t\tif (pipes == 0 || i == size) {\n\t\t\t\ti = row_start;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparse_table_row(\n\t\t\t\tbody_work,\n\t\t\t\tdoc,\n\t\t\t\tdata + row_start,\n\t\t\t\ti - row_start,\n\t\t\t\tcolumns,\n\t\t\t\tcol_data, (hoedown_table_flags) 0\n\t\t\t);\n\n\t\t\ti++;\n\t\t}\n\n        if (doc->md.table_header)\n            doc->md.table_header(work, header_work, &doc->data);\n\n        if (doc->md.table_body)\n            doc->md.table_body(work, body_work, &doc->data);\n\n\t\tif (doc->md.table)\n\t\t\tdoc->md.table(ob, work, &doc->data);\n\t}\n\n\tfree(col_data);\n\tpopbuf(doc, BUFFER_SPAN);\n\tpopbuf(doc, BUFFER_BLOCK);\n\tpopbuf(doc, BUFFER_BLOCK);\n\treturn i;\n}\n\n/* parse_block  parsing of one block, returning next uint8_t to parse */\nstatic void\nparse_block(hoedown_buffer *ob, hoedown_document *doc, uint8_t *data, size_t size)\n{\n\tsize_t beg, end, i;\n\tuint8_t *txt_data;\n\tbeg = 0;\n\n\tif (doc->work_bufs[BUFFER_SPAN].size +\n\t\tdoc->work_bufs[BUFFER_BLOCK].size > doc->max_nesting)\n\t\treturn;\n\n\twhile (beg < size) {\n\t\ttxt_data = data + beg;\n\t\tend = size - beg;\n\n\t\tif (is_atxheader(doc, txt_data, end))\n\t\t\tbeg += parse_atxheader(ob, doc, txt_data, end);\n\n\t\telse if (data[beg] == '<' && doc->md.blockhtml &&\n\t\t\t\t(i = parse_htmlblock(ob, doc, txt_data, end, 1)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if ((i = is_empty(txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if (is_hrule(txt_data, end)) {\n\t\t\tif (doc->md.hrule)\n\t\t\t\tdoc->md.hrule(ob, &doc->data);\n\n\t\t\twhile (beg < size && data[beg] != '\\n')\n\t\t\t\tbeg++;\n\n\t\t\tbeg++;\n\t\t}\n\n\t\telse if ((doc->ext_flags & HOEDOWN_EXT_FENCED_CODE) != 0 &&\n\t\t\t(i = parse_fencedcode(ob, doc, txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if ((doc->ext_flags & HOEDOWN_EXT_TABLES) != 0 &&\n\t\t\t(i = parse_table(ob, doc, txt_data, end)) != 0)\n\t\t\tbeg += i;\n\n\t\telse if (prefix_quote(txt_data, end))\n\t\t\tbeg += parse_blockquote(ob, doc, txt_data, end);\n\n\t\telse if (!(doc->ext_flags & HOEDOWN_EXT_DISABLE_INDENTED_CODE) && prefix_code(txt_data, end))\n\t\t\tbeg += parse_blockcode(ob, doc, txt_data, end);\n\n\t\telse if (prefix_uli(txt_data, end))\n\t\t\tbeg += parse_list(ob, doc, txt_data, end, (hoedown_list_flags) 0);\n\n\t\telse if (prefix_oli(txt_data, end))\n\t\t\tbeg += parse_list(ob, doc, txt_data, end, HOEDOWN_LIST_ORDERED);\n\n\t\telse\n\t\t\tbeg += parse_paragraph(ob, doc, txt_data, end);\n\t}\n}\n\n\n\n/*********************\n * REFERENCE PARSING *\n *********************/\n\n/* is_footnote  returns whether a line is a footnote definition or not */\nstatic int\nis_footnote(const uint8_t *data, size_t beg, size_t end, size_t *last, struct footnote_list *list)\n{\n\tsize_t i = 0;\n\thoedown_buffer *contents = 0;\n\tsize_t ind = 0;\n\tint in_empty = 0;\n\tsize_t start = 0;\n\n\tsize_t id_offset, id_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: caret followed by anything between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tif (i >= end || data[i] != '^') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\n\t/* getting content buffer */\n\tcontents = hoedown_buffer_new(64);\n\n\tstart = i;\n\n\t/* process lines similar to a list item */\n\twhile (i < end) {\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\n\t\t/* process an empty line */\n\t\tif (is_empty(data + start, i - start)) {\n\t\t\tin_empty = 1;\n\t\t\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\t\t\ti++;\n\t\t\t\tif (i < end && data[i] == '\\n' && data[i - 1] == '\\r') i++;\n\t\t\t}\n\t\t\tstart = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* calculating the indentation */\n\t\tind = 0;\n\t\twhile (ind < 4 && start + ind < end && data[start + ind] == ' ')\n\t\t\tind++;\n\n\t\t/* joining only indented stuff after empty lines;\n\t\t * note that now we only require 1 space of indentation\n\t\t * to continue, just like lists */\n\t\tif (ind == 0) {\n\t\t\tif (start == id_end + 2 && data[start] == '\\t') {}\n\t\t\telse break;\n\t\t}\n\t\telse if (in_empty) {\n\t\t\thoedown_buffer_putc(contents, '\\n');\n\t\t}\n\n\t\tin_empty = 0;\n\n\t\t/* adding the line into the content buffer */\n\t\thoedown_buffer_put(contents, data + start + ind, i - start - ind);\n\t\t/* add carriage return */\n\t\tif (i < end) {\n\t\t\thoedown_buffer_putc(contents, '\\n');\n\t\t\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\t\t\ti++;\n\t\t\t\tif (i < end && data[i] == '\\n' && data[i - 1] == '\\r') i++;\n\t\t\t}\n\t\t}\n\t\tstart = i;\n\t}\n\n\tif (last)\n\t\t*last = start;\n\n\tif (list) {\n\t\tstruct footnote_ref *ref;\n\t\tref = create_footnote_ref(list, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\t\tif (!add_footnote_ref(list, ref)) {\n\t\t\tfree_footnote_ref(ref);\n\t\t\treturn 0;\n\t\t}\n\t\tref->contents = contents;\n\t}\n\n\treturn 1;\n}\n\n/* is_ref  returns whether a line is a reference or not */\nstatic int\nis_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n{\n/*\tint n; */\n\tsize_t i = 0;\n\tsize_t id_offset, id_end;\n\tsize_t link_offset, link_end;\n\tsize_t title_offset, title_end;\n\tsize_t line_end;\n\n\t/* up to 3 optional leading spaces */\n\tif (beg + 3 >= end) return 0;\n\tif (data[beg] == ' ') { i = 1;\n\tif (data[beg + 1] == ' ') { i = 2;\n\tif (data[beg + 2] == ' ') { i = 3;\n\tif (data[beg + 3] == ' ') return 0; } } }\n\ti += beg;\n\n\t/* id part: anything but a newline between brackets */\n\tif (data[i] != '[') return 0;\n\ti++;\n\tid_offset = i;\n\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n\t\ti++;\n\tif (i >= end || data[i] != ']') return 0;\n\tid_end = i;\n\n\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n\ti++;\n\tif (i >= end || data[i] != ':') return 0;\n\ti++;\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\ti++;\n\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i >= end) return 0;\n\n\t/* link: spacing-free sequence, optionally between angle brackets */\n\tif (data[i] == '<')\n\t\ti++;\n\n\tlink_offset = i;\n\n\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n\t\ti++;\n\n\tif (data[i - 1] == '>') link_end = i - 1;\n\telse link_end = i;\n\n\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n\twhile (i < end && data[i] == ' ') i++;\n\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n\t\treturn 0;\n\tline_end = 0;\n\t/* computing end-of-line */\n\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\tline_end = i + 1;\n\n\t/* optional (space|tab)* spacer after a newline */\n\tif (line_end) {\n\t\ti = line_end + 1;\n\t\twhile (i < end && data[i] == ' ') i++; }\n\n\t/* optional title: any non-newline sequence enclosed in '\"()\n\t\t\t\t\talone on its line */\n\ttitle_offset = title_end = 0;\n\tif (i + 1 < end\n\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n\t\ti++;\n\t\ttitle_offset = i;\n\t\t/* looking for EOL */\n\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n\t\t\ttitle_end = i + 1;\n\t\telse\ttitle_end = i;\n\t\t/* stepping back */\n\t\ti -= 1;\n\t\twhile (i > title_offset && data[i] == ' ')\n\t\t\ti -= 1;\n\t\tif (i > title_offset\n\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n\t\t\tline_end = title_end;\n\t\t\ttitle_end = i; } }\n\n\tif (!line_end || link_end == link_offset)\n\t\treturn 0; /* garbage after the link empty link */\n\n\t/* a valid ref has been found, filling-in return structures */\n\tif (last)\n\t\t*last = line_end;\n\n\tif (refs) {\n\t\tstruct link_ref *ref;\n\n\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n\t\tif (!ref)\n\t\t\treturn 0;\n\n\t\tref->link = hoedown_buffer_new(link_end - link_offset);\n\t\thoedown_buffer_put(ref->link, data + link_offset, link_end - link_offset);\n\n\t\tif (title_end > title_offset) {\n\t\t\tref->title = hoedown_buffer_new(title_end - title_offset);\n\t\t\thoedown_buffer_put(ref->title, data + title_offset, title_end - title_offset);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void expand_tabs(hoedown_buffer *ob, const uint8_t *line, size_t size)\n{\n\t/* This code makes two assumptions:\n\t * - Input is valid UTF-8.  (Any byte with top two bits 10 is skipped,\n\t *   whether or not it is a valid UTF-8 continuation byte.)\n\t * - Input contains no combining characters.  (Combining characters\n\t *   should be skipped but are not.)\n\t */\n\tsize_t  i = 0, tab = 0;\n\n\twhile (i < size) {\n\t\tsize_t org = i;\n\n\t\twhile (i < size && line[i] != '\\t') {\n\t\t\t/* ignore UTF-8 continuation bytes */\n\t\t\tif ((line[i] & 0xc0) != 0x80)\n\t\t\t\ttab++;\n\t\t\ti++;\n\t\t}\n\n\t\tif (i > org)\n\t\t\thoedown_buffer_put(ob, line + org, i - org);\n\n\t\tif (i >= size)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\thoedown_buffer_putc(ob, ' '); tab++;\n\t\t} while (tab % 4);\n\n\t\ti++;\n\t}\n}\n\n/**********************\n * EXPORTED FUNCTIONS *\n **********************/\n\nhoedown_document *\nhoedown_document_new(\n\tconst hoedown_renderer *renderer,\n\thoedown_extensions extensions,\n\tsize_t max_nesting)\n{\n\thoedown_document *doc = NULL;\n\n\tassert(max_nesting > 0 && renderer);\n\n\tdoc = (hoedown_document*) hoedown_malloc(sizeof(hoedown_document));\n\tmemcpy(&doc->md, renderer, sizeof(hoedown_renderer));\n\n\tdoc->data.opaque = renderer->opaque;\n\n\thoedown_stack_init(&doc->work_bufs[BUFFER_BLOCK], 4);\n\thoedown_stack_init(&doc->work_bufs[BUFFER_SPAN], 8);\n\n\tmemset(doc->active_char, 0x0, 256);\n\n\tif (extensions & HOEDOWN_EXT_UNDERLINE && doc->md.underline) {\n\t\tdoc->active_char['_'] = MD_CHAR_EMPHASIS;\n\t}\n\n\tif (doc->md.emphasis || doc->md.double_emphasis || doc->md.triple_emphasis) {\n\t\tdoc->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tdoc->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & HOEDOWN_EXT_STRIKETHROUGH)\n\t\t\tdoc->active_char['~'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & HOEDOWN_EXT_HIGHLIGHT)\n\t\t\tdoc->active_char['='] = MD_CHAR_EMPHASIS;\n\t}\n\n\tif (doc->md.codespan)\n\t\tdoc->active_char['`'] = MD_CHAR_CODESPAN;\n\n\tif (doc->md.linebreak)\n\t\tdoc->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\n\tif (doc->md.image || doc->md.link || doc->md.footnotes || doc->md.footnote_ref)\n\t\tdoc->active_char['['] = MD_CHAR_LINK;\n\n\tdoc->active_char['<'] = MD_CHAR_LANGLE;\n\tdoc->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tdoc->active_char['&'] = MD_CHAR_ENTITY;\n\n\tif (extensions & HOEDOWN_EXT_AUTOLINK) {\n\t\tdoc->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tdoc->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tdoc->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t}\n\n\tif (extensions & HOEDOWN_EXT_SUPERSCRIPT)\n\t\tdoc->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\n\tif (extensions & HOEDOWN_EXT_QUOTE)\n\t\tdoc->active_char['\"'] = MD_CHAR_QUOTE;\n\n\tif (extensions & HOEDOWN_EXT_MATH)\n\t\tdoc->active_char['$'] = MD_CHAR_MATH;\n\n\t/* Extension data */\n\tdoc->ext_flags = extensions;\n\tdoc->max_nesting = max_nesting;\n\tdoc->in_link_body = 0;\n\n\treturn doc;\n}\n\nvoid\nhoedown_document_render(hoedown_document *doc, hoedown_buffer *ob, const uint8_t *data, size_t size)\n{\n\tstatic const uint8_t UTF8_BOM[] = {0xEF, 0xBB, 0xBF};\n\n\thoedown_buffer *text;\n\tsize_t beg, end;\n\n\tint footnotes_enabled;\n\n\ttext = hoedown_buffer_new(64);\n\n\t/* Preallocate enough space for our buffer to avoid expanding while copying */\n\thoedown_buffer_grow(text, size);\n\n\t/* reset the references table */\n\tmemset(&doc->refs, 0x0, REF_TABLE_SIZE * sizeof(void *));\n\n\tfootnotes_enabled = doc->ext_flags & HOEDOWN_EXT_FOOTNOTES;\n\n\t/* reset the footnotes lists */\n\tif (footnotes_enabled) {\n\t\tmemset(&doc->footnotes_found, 0x0, sizeof(doc->footnotes_found));\n\t\tmemset(&doc->footnotes_used, 0x0, sizeof(doc->footnotes_used));\n\t}\n\n\t/* first pass: looking for references, copying everything else */\n\tbeg = 0;\n\n\t/* Skip a possible UTF-8 BOM, even though the Unicode standard\n\t * discourages having these in UTF-8 documents */\n\tif (size >= 3 && memcmp(data, UTF8_BOM, 3) == 0)\n\t\tbeg += 3;\n\n\twhile (beg < size) /* iterating over lines */\n\t\tif (footnotes_enabled && is_footnote(data, beg, size, &end, &doc->footnotes_found))\n\t\t\tbeg = end;\n\t\telse if (is_ref(data, beg, size, &end, doc->refs))\n\t\t\tbeg = end;\n\t\telse { /* skipping to the next line */\n\t\t\tend = beg;\n\t\t\twhile (end < size && data[end] != '\\n' && data[end] != '\\r')\n\t\t\t\tend++;\n\n\t\t\t/* adding the line body if present */\n\t\t\tif (end > beg)\n\t\t\t\texpand_tabs(text, data + beg, end - beg);\n\n\t\t\twhile (end < size && (data[end] == '\\n' || data[end] == '\\r')) {\n\t\t\t\t/* add one \\n per newline */\n\t\t\t\tif (data[end] == '\\n' || (end + 1 < size && data[end + 1] != '\\n'))\n\t\t\t\t\thoedown_buffer_putc(text, '\\n');\n\t\t\t\tend++;\n\t\t\t}\n\n\t\t\tbeg = end;\n\t\t}\n\n\t/* pre-grow the output buffer to minimize allocations */\n\thoedown_buffer_grow(ob, text->size + (text->size >> 1));\n\n\t/* second pass: actual rendering */\n\tif (doc->md.doc_header)\n\t\tdoc->md.doc_header(ob, 0, &doc->data);\n\n\tif (text->size) {\n\t\t/* adding a final newline if not already present */\n\t\tif (text->data[text->size - 1] != '\\n' &&  text->data[text->size - 1] != '\\r')\n\t\t\thoedown_buffer_putc(text, '\\n');\n\n\t\tparse_block(ob, doc, text->data, text->size);\n\t}\n\n\t/* footnotes */\n\tif (footnotes_enabled)\n\t\tparse_footnote_list(ob, doc, &doc->footnotes_used);\n\n\tif (doc->md.doc_footer)\n\t\tdoc->md.doc_footer(ob, 0, &doc->data);\n\n\t/* clean-up */\n\thoedown_buffer_free(text);\n\tfree_link_refs(doc->refs);\n\tif (footnotes_enabled) {\n\t\tfree_footnote_list(&doc->footnotes_found, 1);\n\t\tfree_footnote_list(&doc->footnotes_used, 0);\n\t}\n\n\tassert(doc->work_bufs[BUFFER_SPAN].size == 0);\n\tassert(doc->work_bufs[BUFFER_BLOCK].size == 0);\n}\n\nvoid\nhoedown_document_render_inline(hoedown_document *doc, hoedown_buffer *ob, const uint8_t *data, size_t size)\n{\n\tsize_t i = 0, mark;\n\thoedown_buffer *text = hoedown_buffer_new(64);\n\n\t/* reset the references table */\n\tmemset(&doc->refs, 0x0, REF_TABLE_SIZE * sizeof(void *));\n\n\t/* first pass: expand tabs and process newlines */\n\thoedown_buffer_grow(text, size);\n\twhile (1) {\n\t\tmark = i;\n\t\twhile (i < size && data[i] != '\\n' && data[i] != '\\r')\n\t\t\ti++;\n\n\t\texpand_tabs(text, data + mark, i - mark);\n\n\t\tif (i >= size)\n\t\t\tbreak;\n\n\t\twhile (i < size && (data[i] == '\\n' || data[i] == '\\r')) {\n\t\t\t/* add one \\n per newline */\n\t\t\tif (data[i] == '\\n' || (i + 1 < size && data[i + 1] != '\\n'))\n\t\t\t\thoedown_buffer_putc(text, '\\n');\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* second pass: actual rendering */\n\thoedown_buffer_grow(ob, text->size + (text->size >> 1));\n\n\tif (doc->md.doc_header)\n\t\tdoc->md.doc_header(ob, 1, &doc->data);\n\n\tparse_inline(ob, doc, text->data, text->size);\n\n\tif (doc->md.doc_footer)\n\t\tdoc->md.doc_footer(ob, 1, &doc->data);\n\n\t/* clean-up */\n\thoedown_buffer_free(text);\n\n\tassert(doc->work_bufs[BUFFER_SPAN].size == 0);\n\tassert(doc->work_bufs[BUFFER_BLOCK].size == 0);\n}\n\nvoid\nhoedown_document_free(hoedown_document *doc)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < (size_t)doc->work_bufs[BUFFER_SPAN].asize; ++i)\n\t\thoedown_buffer_free((hoedown_buffer*)doc->work_bufs[BUFFER_SPAN].item[i]);\n\n\tfor (i = 0; i < (size_t)doc->work_bufs[BUFFER_BLOCK].asize; ++i)\n\t\thoedown_buffer_free((hoedown_buffer*)doc->work_bufs[BUFFER_BLOCK].item[i]);\n\n\thoedown_stack_uninit(&doc->work_bufs[BUFFER_SPAN]);\n\thoedown_stack_uninit(&doc->work_bufs[BUFFER_BLOCK]);\n\n\tfree(doc);\n}\n/*\n------------------------------------------------------------------------------\n\tEND document.c\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART escape.h\n------------------------------------------------------------------------------\n*/\n/* escape.h - escape utilities */\n\n#ifndef HOEDOWN_ESCAPE_H\n#define HOEDOWN_ESCAPE_H\n\n//#include \"buffer.h\"\n\n\n/*************\n * FUNCTIONS *\n *************/\n\n/* hoedown_escape_href: escape (part of) a URL inside HTML */\nvoid hoedown_escape_href(hoedown_buffer *ob, const uint8_t *data, size_t size);\n\n/* hoedown_escape_html: escape HTML */\nvoid hoedown_escape_html(hoedown_buffer *ob, const uint8_t *data, size_t size, int secure);\n\n\n#endif /** HOEDOWN_ESCAPE_H **/\n/*\n------------------------------------------------------------------------------\n\tEND escape.h\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART html.c\n------------------------------------------------------------------------------\n*/\n//#include \"html.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n//#include \"escape.h\"\n\n#define USE_XHTML(opt) (opt->flags & HOEDOWN_HTML_USE_XHTML)\n\nhoedown_html_tag\nhoedown_html_is_tag(const uint8_t *data, size_t size, const char *tagname)\n{\n\tsize_t i;\n\tint closed = 0;\n\n\tif (size < 3 || data[0] != '<')\n\t\treturn HOEDOWN_HTML_TAG_NONE;\n\n\ti = 1;\n\n\tif (data[i] == '/') {\n\t\tclosed = 1;\n\t\ti++;\n\t}\n\n\tfor (; i < size; ++i, ++tagname) {\n\t\tif (*tagname == 0)\n\t\t\tbreak;\n\n\t\tif (data[i] != *tagname)\n\t\t\treturn HOEDOWN_HTML_TAG_NONE;\n\t}\n\n\tif (i == size)\n\t\treturn HOEDOWN_HTML_TAG_NONE;\n\n\tif (isspace(data[i]) || data[i] == '>')\n\t\treturn closed ? HOEDOWN_HTML_TAG_CLOSE : HOEDOWN_HTML_TAG_OPEN;\n\n\treturn HOEDOWN_HTML_TAG_NONE;\n}\n\nstatic void escape_html(hoedown_buffer *ob, const uint8_t *source, size_t length)\n{\n\thoedown_escape_html(ob, source, length, 0);\n}\n\nstatic void escape_href(hoedown_buffer *ob, const uint8_t *source, size_t length)\n{\n\thoedown_escape_href(ob, source, length);\n}\n\n/********************\n * GENERIC RENDERER *\n ********************/\nstatic int\nrndr_autolink(hoedown_buffer *ob, const hoedown_buffer *link, hoedown_autolink_type type, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\n\tif (!link || !link->size)\n\t\treturn 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<a href=\\\"\");\n\tif (type == HOEDOWN_AUTOLINK_EMAIL)\n\t\tHOEDOWN_BUFPUTSL(ob, \"mailto:\");\n\tescape_href(ob, link->data, link->size);\n\n\tif (state->link_attributes) {\n\t\thoedown_buffer_putc(ob, '\\\"');\n\t\tstate->link_attributes(ob, link, data);\n\t\thoedown_buffer_putc(ob, '>');\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t}\n\n\t/*\n\t * Pretty printing: if we get an email address as\n\t * an actual URI, e.g. `mailto:foo@bar.com`, we don't\n\t * want to print the `mailto:` prefix\n\t */\n\tif (hoedown_buffer_prefix(link, \"mailto:\") == 0) {\n\t\tescape_html(ob, link->data + 7, link->size - 7);\n\t} else {\n\t\tescape_html(ob, link->data, link->size);\n\t}\n\n\tHOEDOWN_BUFPUTSL(ob, \"</a>\");\n\n\treturn 1;\n}\n\nstatic void\nrndr_blockcode(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_buffer *lang, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\n\tif (lang) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code class=\\\"language-\");\n\t\tescape_html(ob, lang->data, lang->size);\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<pre><code>\");\n\t}\n\n\tif (text)\n\t\tescape_html(ob, text->data, text->size);\n\n\tHOEDOWN_BUFPUTSL(ob, \"</code></pre>\\n\");\n}\n\nstatic void\nrndr_blockquote(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\tHOEDOWN_BUFPUTSL(ob, \"<blockquote>\\n\");\n\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</blockquote>\\n\");\n}\n\nstatic int\nrndr_codespan(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data)\n{\n\tHOEDOWN_BUFPUTSL(ob, \"<code>\");\n\tif (text) escape_html(ob, text->data, text->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</code>\");\n\treturn 1;\n}\n\nstatic int\nrndr_strikethrough(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size)\n\t\treturn 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<del>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</del>\");\n\treturn 1;\n}\n\nstatic int\nrndr_double_emphasis(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size)\n\t\treturn 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<strong>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</strong>\");\n\n\treturn 1;\n}\n\nstatic int\nrndr_emphasis(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size) return 0;\n\tHOEDOWN_BUFPUTSL(ob, \"<em>\");\n\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</em>\");\n\treturn 1;\n}\n\nstatic int\nrndr_underline(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size)\n\t\treturn 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<u>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</u>\");\n\n\treturn 1;\n}\n\nstatic int\nrndr_highlight(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size)\n\t\treturn 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<mark>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</mark>\");\n\n\treturn 1;\n}\n\nstatic int\nrndr_quote(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size)\n\t\treturn 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<q>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}\n\nstatic int\nrndr_linebreak(hoedown_buffer *ob, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\thoedown_buffer_puts(ob, USE_XHTML(state) ? \"<br/>\\n\" : \"<br>\\n\");\n\treturn 1;\n}\n\nstatic void\nrndr_header(hoedown_buffer *ob, const hoedown_buffer *content, int level, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\n\tif (ob->size)\n\t\thoedown_buffer_putc(ob, '\\n');\n\n\tif (level <= state->toc_data.nesting_level)\n\t\thoedown_buffer_printf(ob, \"<h%d id=\\\"toc_%d\\\">\", level, state->toc_data.header_count++);\n\telse\n\t\thoedown_buffer_printf(ob, \"<h%d>\", level);\n\n\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\thoedown_buffer_printf(ob, \"</h%d>\\n\", level);\n}\n\nstatic int\nrndr_link(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_buffer *link, const hoedown_buffer *title, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<a href=\\\"\");\n\n\tif (link && link->size)\n\t\tescape_href(ob, link->data, link->size);\n\n\tif (title && title->size) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\" title=\\\"\");\n\t\tescape_html(ob, title->data, title->size);\n\t}\n\n\tif (state->link_attributes) {\n\t\thoedown_buffer_putc(ob, '\\\"');\n\t\tstate->link_attributes(ob, link, data);\n\t\thoedown_buffer_putc(ob, '>');\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\">\");\n\t}\n\n\tif (content && content->size) hoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</a>\");\n\treturn 1;\n}\n\nstatic void\nrndr_list(hoedown_buffer *ob, const hoedown_buffer *content, hoedown_list_flags flags, const hoedown_renderer_data *data)\n{\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\thoedown_buffer_put(ob, (const uint8_t *)(flags & HOEDOWN_LIST_ORDERED ? \"<ol>\\n\" : \"<ul>\\n\"), 5);\n\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\thoedown_buffer_put(ob, (const uint8_t *)(flags & HOEDOWN_LIST_ORDERED ? \"</ol>\\n\" : \"</ul>\\n\"), 6);\n}\n\nstatic void\nrndr_listitem(hoedown_buffer *ob, const hoedown_buffer *content, hoedown_list_flags flags, const hoedown_renderer_data *data)\n{\n\tHOEDOWN_BUFPUTSL(ob, \"<li>\");\n\tif (content) {\n\t\tsize_t size = content->size;\n\t\twhile (size && content->data[size - 1] == '\\n')\n\t\t\tsize--;\n\n\t\thoedown_buffer_put(ob, content->data, size);\n\t}\n\tHOEDOWN_BUFPUTSL(ob, \"</li>\\n\");\n}\n\nstatic void\nrndr_paragraph(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\tsize_t i = 0;\n\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\n\tif (!content || !content->size)\n\t\treturn;\n\n\twhile (i < content->size && isspace(content->data[i])) i++;\n\n\tif (i == content->size)\n\t\treturn;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<p>\");\n\tif (state->flags & HOEDOWN_HTML_HARD_WRAP) {\n\t\tsize_t org;\n\t\twhile (i < content->size) {\n\t\t\torg = i;\n\t\t\twhile (i < content->size && content->data[i] != '\\n')\n\t\t\t\ti++;\n\n\t\t\tif (i > org)\n\t\t\t\thoedown_buffer_put(ob, content->data + org, i - org);\n\n\t\t\t/*\n\t\t\t * do not insert a line break if this newline\n\t\t\t * is the last character on the paragraph\n\t\t\t */\n\t\t\tif (i >= content->size - 1)\n\t\t\t\tbreak;\n\n\t\t\trndr_linebreak(ob, data);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\thoedown_buffer_put(ob, content->data + i, content->size - i);\n\t}\n\tHOEDOWN_BUFPUTSL(ob, \"</p>\\n\");\n}\n\nstatic void\nrndr_raw_block(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data)\n{\n\tsize_t org, sz;\n\n\tif (!text)\n\t\treturn;\n\n\t/* FIXME: Do we *really* need to trim the HTML? How does that make a difference? */\n\tsz = text->size;\n\twhile (sz > 0 && text->data[sz - 1] == '\\n')\n\t\tsz--;\n\n\torg = 0;\n\twhile (org < sz && text->data[org] == '\\n')\n\t\torg++;\n\n\tif (org >= sz)\n\t\treturn;\n\n\tif (ob->size)\n\t\thoedown_buffer_putc(ob, '\\n');\n\n\thoedown_buffer_put(ob, text->data + org, sz - org);\n\thoedown_buffer_putc(ob, '\\n');\n}\n\nstatic int\nrndr_triple_emphasis(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size) return 0;\n\tHOEDOWN_BUFPUTSL(ob, \"<strong><em>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</em></strong>\");\n\treturn 1;\n}\n\nstatic void\nrndr_hrule(hoedown_buffer *ob, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\thoedown_buffer_puts(ob, USE_XHTML(state) ? \"<hr/>\\n\" : \"<hr>\\n\");\n}\n\nstatic int\nrndr_image(hoedown_buffer *ob, const hoedown_buffer *link, const hoedown_buffer *title, const hoedown_buffer *alt, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\tif (!link || !link->size) return 0;\n\n\tHOEDOWN_BUFPUTSL(ob, \"<img src=\\\"\");\n\tescape_href(ob, link->data, link->size);\n\tHOEDOWN_BUFPUTSL(ob, \"\\\" alt=\\\"\");\n\n\tif (alt && alt->size)\n\t\tescape_html(ob, alt->data, alt->size);\n\n\tif (title && title->size) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"\\\" title=\\\"\");\n\t\tescape_html(ob, title->data, title->size); }\n\n\thoedown_buffer_puts(ob, USE_XHTML(state) ? \"\\\"/>\" : \"\\\">\");\n\treturn 1;\n}\n\nstatic int\nrndr_raw_html(hoedown_buffer *ob, const hoedown_buffer *text, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\n\t/* ESCAPE overrides SKIP_HTML. It doesn't look to see if\n\t * there are any valid tags, just escapes all of them. */\n\tif((state->flags & HOEDOWN_HTML_ESCAPE) != 0) {\n\t\tescape_html(ob, text->data, text->size);\n\t\treturn 1;\n\t}\n\n\tif ((state->flags & HOEDOWN_HTML_SKIP_HTML) != 0)\n\t\treturn 1;\n\n\thoedown_buffer_put(ob, text->data, text->size);\n\treturn 1;\n}\n\nstatic void\nrndr_table(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n    if (ob->size) hoedown_buffer_putc(ob, '\\n');\n    HOEDOWN_BUFPUTSL(ob, \"<table>\\n\");\n    hoedown_buffer_put(ob, content->data, content->size);\n    HOEDOWN_BUFPUTSL(ob, \"</table>\\n\");\n}\n\nstatic void\nrndr_table_header(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n    if (ob->size) hoedown_buffer_putc(ob, '\\n');\n    HOEDOWN_BUFPUTSL(ob, \"<thead>\\n\");\n    hoedown_buffer_put(ob, content->data, content->size);\n    HOEDOWN_BUFPUTSL(ob, \"</thead>\\n\");\n}\n\nstatic void\nrndr_table_body(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n    if (ob->size) hoedown_buffer_putc(ob, '\\n');\n    HOEDOWN_BUFPUTSL(ob, \"<tbody>\\n\");\n    hoedown_buffer_put(ob, content->data, content->size);\n    HOEDOWN_BUFPUTSL(ob, \"</tbody>\\n\");\n}\n\nstatic void\nrndr_tablerow(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tHOEDOWN_BUFPUTSL(ob, \"<tr>\\n\");\n\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</tr>\\n\");\n}\n\nstatic void\nrndr_tablecell(hoedown_buffer *ob, const hoedown_buffer *content, hoedown_table_flags flags, const hoedown_renderer_data *data)\n{\n\tif (flags & HOEDOWN_TABLE_HEADER) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<th\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"<td\");\n\t}\n\n\tswitch (flags & HOEDOWN_TABLE_ALIGNMASK) {\n\tcase HOEDOWN_TABLE_ALIGN_CENTER:\n\t\tHOEDOWN_BUFPUTSL(ob, \" style=\\\"text-align: center\\\">\");\n\t\tbreak;\n\n\tcase HOEDOWN_TABLE_ALIGN_LEFT:\n\t\tHOEDOWN_BUFPUTSL(ob, \" style=\\\"text-align: left\\\">\");\n\t\tbreak;\n\n\tcase HOEDOWN_TABLE_ALIGN_RIGHT:\n\t\tHOEDOWN_BUFPUTSL(ob, \" style=\\\"text-align: right\\\">\");\n\t\tbreak;\n\n\tdefault:\n\t\tHOEDOWN_BUFPUTSL(ob, \">\");\n\t}\n\n\tif (content)\n\t\thoedown_buffer_put(ob, content->data, content->size);\n\n\tif (flags & HOEDOWN_TABLE_HEADER) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"</th>\\n\");\n\t} else {\n\t\tHOEDOWN_BUFPUTSL(ob, \"</td>\\n\");\n\t}\n}\n\nstatic int\nrndr_superscript(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (!content || !content->size) return 0;\n\tHOEDOWN_BUFPUTSL(ob, \"<sup>\");\n\thoedown_buffer_put(ob, content->data, content->size);\n\tHOEDOWN_BUFPUTSL(ob, \"</sup>\");\n\treturn 1;\n}\n\nstatic void\nrndr_normal_text(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\tif (content)\n\t\tescape_html(ob, content->data, content->size);\n}\n\nstatic void\nrndr_footnotes(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\n\tif (ob->size) hoedown_buffer_putc(ob, '\\n');\n\tHOEDOWN_BUFPUTSL(ob, \"<div class=\\\"footnotes\\\">\\n\");\n\thoedown_buffer_puts(ob, USE_XHTML(state) ? \"<hr/>\\n\" : \"<hr>\\n\");\n\tHOEDOWN_BUFPUTSL(ob, \"<ol>\\n\");\n\n\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\n\tHOEDOWN_BUFPUTSL(ob, \"\\n</ol>\\n</div>\\n\");\n}\n\nstatic void\nrndr_footnote_def(hoedown_buffer *ob, const hoedown_buffer *content, unsigned int num, const hoedown_renderer_data *data)\n{\n\tsize_t i = 0;\n\tint pfound = 0;\n\n\t/* insert anchor at the end of first paragraph block */\n\tif (content) {\n\t\twhile ((i+3) < content->size) {\n\t\t\tif (content->data[i++] != '<') continue;\n\t\t\tif (content->data[i++] != '/') continue;\n\t\t\tif (content->data[i++] != 'p' && content->data[i] != 'P') continue;\n\t\t\tif (content->data[i] != '>') continue;\n\t\t\ti -= 3;\n\t\t\tpfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thoedown_buffer_printf(ob, \"\\n<li id=\\\"fn%d\\\">\\n\", num);\n\tif (pfound) {\n\t\thoedown_buffer_put(ob, content->data, i);\n\t\thoedown_buffer_printf(ob, \"&nbsp;<a href=\\\"#fnref%d\\\" rev=\\\"footnote\\\">&#8617;</a>\", num);\n\t\thoedown_buffer_put(ob, content->data + i, content->size - i);\n\t} else if (content) {\n\t\thoedown_buffer_put(ob, content->data, content->size);\n\t}\n\tHOEDOWN_BUFPUTSL(ob, \"</li>\\n\");\n}\n\nstatic int\nrndr_footnote_ref(hoedown_buffer *ob, unsigned int num, const hoedown_renderer_data *data)\n{\n\thoedown_buffer_printf(ob, \"<sup id=\\\"fnref%d\\\"><a href=\\\"#fn%d\\\" rel=\\\"footnote\\\">%d</a></sup>\", num, num, num);\n\treturn 1;\n}\n\nstatic int\nrndr_math(hoedown_buffer *ob, const hoedown_buffer *text, int displaymode, const hoedown_renderer_data *data)\n{\n\thoedown_buffer_put(ob, (const uint8_t *)(displaymode ? \"\\\\[\" : \"\\\\(\"), 2);\n\tescape_html(ob, text->data, text->size);\n\thoedown_buffer_put(ob, (const uint8_t *)(displaymode ? \"\\\\]\" : \"\\\\)\"), 2);\n\treturn 1;\n}\n\nstatic void\ntoc_header(hoedown_buffer *ob, const hoedown_buffer *content, int level, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state = (hoedown_html_renderer_state *)data->opaque;\n\n\tif (level <= state->toc_data.nesting_level) {\n\t\t/* set the level offset if this is the first header\n\t\t * we're parsing for the document */\n\t\tif (state->toc_data.current_level == 0)\n\t\t\tstate->toc_data.level_offset = level - 1;\n\n\t\tlevel -= state->toc_data.level_offset;\n\n\t\tif (level > state->toc_data.current_level) {\n\t\t\twhile (level > state->toc_data.current_level) {\n\t\t\t\tHOEDOWN_BUFPUTSL(ob, \"<ul>\\n<li>\\n\");\n\t\t\t\tstate->toc_data.current_level++;\n\t\t\t}\n\t\t} else if (level < state->toc_data.current_level) {\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"</li>\\n\");\n\t\t\twhile (level < state->toc_data.current_level) {\n\t\t\t\tHOEDOWN_BUFPUTSL(ob, \"</ul>\\n</li>\\n\");\n\t\t\t\tstate->toc_data.current_level--;\n\t\t\t}\n\t\t\tHOEDOWN_BUFPUTSL(ob,\"<li>\\n\");\n\t\t} else {\n\t\t\tHOEDOWN_BUFPUTSL(ob,\"</li>\\n<li>\\n\");\n\t\t}\n\n\t\thoedown_buffer_printf(ob, \"<a href=\\\"#toc_%d\\\">\", state->toc_data.header_count++);\n\t\tif (content) hoedown_buffer_put(ob, content->data, content->size);\n\t\tHOEDOWN_BUFPUTSL(ob, \"</a>\\n\");\n\t}\n}\n\nstatic int\ntoc_link(hoedown_buffer *ob, const hoedown_buffer *content, const hoedown_buffer *link, const hoedown_buffer *title, const hoedown_renderer_data *data)\n{\n\tif (content && content->size) hoedown_buffer_put(ob, content->data, content->size);\n\treturn 1;\n}\n\nstatic void\ntoc_finalize(hoedown_buffer *ob, int inline_render, const hoedown_renderer_data *data)\n{\n\thoedown_html_renderer_state *state;\n\n\tif (inline_render)\n\t\treturn;\n\n\tstate = (hoedown_html_renderer_state *)data->opaque;\n\n\twhile (state->toc_data.current_level > 0) {\n\t\tHOEDOWN_BUFPUTSL(ob, \"</li>\\n</ul>\\n\");\n\t\tstate->toc_data.current_level--;\n\t}\n\n\tstate->toc_data.header_count = 0;\n}\n\nhoedown_renderer *\nhoedown_html_toc_renderer_new(int nesting_level)\n{\n\tstatic const hoedown_renderer cb_default = {\n\t\tNULL,\n\n\t\tNULL,\n\t\tNULL,\n\t\ttoc_header,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\n\t\tNULL,\n\t\trndr_codespan,\n\t\trndr_double_emphasis,\n\t\trndr_emphasis,\n\t\trndr_underline,\n\t\trndr_highlight,\n\t\trndr_quote,\n\t\tNULL,\n\t\tNULL,\n\t\ttoc_link,\n\t\trndr_triple_emphasis,\n\t\trndr_strikethrough,\n\t\trndr_superscript,\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\n\t\tNULL,\n\t\trndr_normal_text,\n\n\t\tNULL,\n\t\ttoc_finalize\n\t};\n\n\thoedown_html_renderer_state *state;\n\thoedown_renderer *renderer;\n\n\t/* Prepare the state pointer */\n\tstate = (hoedown_html_renderer_state *)hoedown_malloc(sizeof(hoedown_html_renderer_state));\n\tmemset(state, 0x0, sizeof(hoedown_html_renderer_state));\n\n\tstate->toc_data.nesting_level = nesting_level;\n\n\t/* Prepare the renderer */\n\trenderer = (hoedown_renderer *)hoedown_malloc(sizeof(hoedown_renderer));\n\tmemcpy(renderer, &cb_default, sizeof(hoedown_renderer));\n\n\trenderer->opaque = state;\n\treturn renderer;\n}\n\nhoedown_renderer *\nhoedown_html_renderer_new(hoedown_html_flags render_flags, int nesting_level)\n{\n\tstatic const hoedown_renderer cb_default = {\n\t\tNULL,\n\n\t\trndr_blockcode,\n\t\trndr_blockquote,\n\t\trndr_header,\n\t\trndr_hrule,\n\t\trndr_list,\n\t\trndr_listitem,\n\t\trndr_paragraph,\n\t\trndr_table,\n\t\trndr_table_header,\n\t\trndr_table_body,\n\t\trndr_tablerow,\n\t\trndr_tablecell,\n\t\trndr_footnotes,\n\t\trndr_footnote_def,\n\t\trndr_raw_block,\n\n\t\trndr_autolink,\n\t\trndr_codespan,\n\t\trndr_double_emphasis,\n\t\trndr_emphasis,\n\t\trndr_underline,\n\t\trndr_highlight,\n\t\trndr_quote,\n\t\trndr_image,\n\t\trndr_linebreak,\n\t\trndr_link,\n\t\trndr_triple_emphasis,\n\t\trndr_strikethrough,\n\t\trndr_superscript,\n\t\trndr_footnote_ref,\n\t\trndr_math,\n\t\trndr_raw_html,\n\n\t\tNULL,\n\t\trndr_normal_text,\n\n\t\tNULL,\n\t\tNULL\n\t};\n\n\thoedown_html_renderer_state *state;\n\thoedown_renderer *renderer;\n\n\t/* Prepare the state pointer */\n\tstate = (hoedown_html_renderer_state *)hoedown_malloc(sizeof(hoedown_html_renderer_state));\n\tmemset(state, 0x0, sizeof(hoedown_html_renderer_state));\n\n\tstate->flags = render_flags;\n\tstate->toc_data.nesting_level = nesting_level;\n\n\t/* Prepare the renderer */\n\trenderer = (hoedown_renderer *)hoedown_malloc(sizeof(hoedown_renderer));\n\tmemcpy(renderer, &cb_default, sizeof(hoedown_renderer));\n\n\tif (render_flags & HOEDOWN_HTML_SKIP_HTML || render_flags & HOEDOWN_HTML_ESCAPE)\n\t\trenderer->blockhtml = NULL;\n\n\trenderer->opaque = state;\n\treturn renderer;\n}\n\nvoid\nhoedown_html_renderer_free(hoedown_renderer *renderer)\n{\n\tfree(renderer->opaque);\n\tfree(renderer);\n}\n/*\n------------------------------------------------------------------------------\n\tEND html.c\n------------------------------------------------------------------------------\n*/\n/*\n------------------------------------------------------------------------------\n\tSTART escape.c\n------------------------------------------------------------------------------\n*/\n//#include \"escape.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n\n\n#define likely(x)       __builtin_expect((x),1)\n#define unlikely(x)     __builtin_expect((x),0)\n\n\n/*\n * The following characters will not be escaped:\n *\n *\t\t-_.+!*'(),%#@?=;:/,+&$ alphanum\n *\n * Note that this character set is the addition of:\n *\n *\t- The characters which are safe to be in an URL\n *\t- The characters which are *not* safe to be in\n *\tan URL because they are RESERVED characters.\n *\n * We assume (lazily) that any RESERVED char that\n * appears inside an URL is actually meant to\n * have its native function (i.e. as an URL\n * component/separator) and hence needs no escaping.\n *\n * There are two exceptions: the chacters & (amp)\n * and ' (single quote) do not appear in the table.\n * They are meant to appear in the URL as components,\n * yet they require special HTML-entity escaping\n * to generate valid HTML markup.\n *\n * All other characters will be escaped to %XX.\n *\n */\nstatic const uint8_t HREF_SAFE[UINT8_MAX+1] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,\n\t0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nvoid\nhoedown_escape_href(hoedown_buffer *ob, const uint8_t *data, size_t size)\n{\n\tstatic const char hex_chars[] = \"0123456789ABCDEF\";\n\tsize_t  i = 0, mark;\n\tchar hex_str[3];\n\n\thex_str[0] = '%';\n\n\twhile (i < size) {\n\t\tmark = i;\n\t\twhile (i < size && HREF_SAFE[data[i]]) i++;\n\n\t\t/* Optimization for cases where there's nothing to escape */\n\t\tif (mark == 0 && i >= size) {\n\t\t\thoedown_buffer_put(ob, data, size);\n\t\t\treturn;\n\t\t}\n\n\t\tif (likely(i > mark)) {\n\t\t\thoedown_buffer_put(ob, data + mark, i - mark);\n\t\t}\n\n\t\t/* escaping */\n\t\tif (i >= size)\n\t\t\tbreak;\n\n\t\tswitch (data[i]) {\n\t\t/* amp appears all the time in URLs, but needs\n\t\t * HTML-entity escaping to be inside an href */\n\t\tcase '&':\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"&amp;\");\n\t\t\tbreak;\n\n\t\t/* the single quote is a valid URL character\n\t\t * according to the standard; it needs HTML\n\t\t * entity escaping too */\n\t\tcase '\\'':\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"&#x27;\");\n\t\t\tbreak;\n\n\t\t/* the space can be escaped to %20 or a plus\n\t\t * sign. we're going with the generic escape\n\t\t * for now. the plus thing is more commonly seen\n\t\t * when building GET strings */\n#if 0\n\t\tcase ' ':\n\t\t\thoedown_buffer_putc(ob, '+');\n\t\t\tbreak;\n#endif\n\n\t\t/* every other character goes with a %XX escaping */\n\t\tdefault:\n\t\t\thex_str[1] = hex_chars[(data[i] >> 4) & 0xF];\n\t\t\thex_str[2] = hex_chars[data[i] & 0xF];\n\t\t\thoedown_buffer_put(ob, (uint8_t *)hex_str, 3);\n\t\t}\n\n\t\ti++;\n\t}\n}\n\n\n/**\n * According to the OWASP rules:\n *\n * & --> &amp;\n * < --> &lt;\n * > --> &gt;\n * \" --> &quot;\n * ' --> &#x27;     &apos; is not recommended\n * / --> &#x2F;     forward slash is included as it helps end an HTML entity\n *\n */\nstatic const uint8_t HTML_ESCAPE_TABLE[UINT8_MAX+1] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 1, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 4,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic const char *HTML_ESCAPES[] = {\n        \"\",\n        \"&quot;\",\n        \"&amp;\",\n        \"&#39;\",\n        \"&#47;\",\n        \"&lt;\",\n        \"&gt;\"\n};\n\nvoid\nhoedown_escape_html(hoedown_buffer *ob, const uint8_t *data, size_t size, int secure)\n{\n\tsize_t i = 0, mark;\n\n\twhile (1) {\n\t\tmark = i;\n\t\twhile (i < size && HTML_ESCAPE_TABLE[data[i]] == 0) i++;\n\n\t\t/* Optimization for cases where there's nothing to escape */\n\t\tif (mark == 0 && i >= size) {\n\t\t\thoedown_buffer_put(ob, data, size);\n\t\t\treturn;\n\t\t}\n\n\t\tif (likely(i > mark))\n\t\t\thoedown_buffer_put(ob, data + mark, i - mark);\n\n\t\tif (i >= size) break;\n\n\t\t/* The forward slash is only escaped in secure mode */\n\t\tif (!secure && data[i] == '/') {\n\t\t\thoedown_buffer_putc(ob, '/');\n\t\t} else {\n\t\t\thoedown_buffer_puts(ob, HTML_ESCAPES[HTML_ESCAPE_TABLE[data[i]]]);\n\t\t}\n\n\t\ti++;\n\t}\n}\n/*\n------------------------------------------------------------------------------\n\tEND escape.c\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART stack.c\n------------------------------------------------------------------------------\n*/\n//#include \"stack.h\"\n\n//#include \"buffer.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nvoid\nhoedown_stack_init(hoedown_stack *st, size_t initial_size)\n{\n\tassert(st);\n\n\tst->item = NULL;\n\tst->size = st->asize = 0;\n\n\tif (!initial_size)\n\t\tinitial_size = 8;\n\n\thoedown_stack_grow(st, initial_size);\n}\n\nvoid\nhoedown_stack_uninit(hoedown_stack *st)\n{\n\tassert(st);\n\n\tfree(st->item);\n}\n\nvoid\nhoedown_stack_grow(hoedown_stack *st, size_t neosz)\n{\n\tassert(st);\n\n\tif (st->asize >= neosz)\n\t\treturn;\n\n\tst->item = (void**)hoedown_realloc(st->item, neosz * sizeof(void *));\n\tmemset(st->item + st->asize, 0x0, (neosz - st->asize) * sizeof(void *));\n\n\tst->asize = neosz;\n\n\tif (st->size > neosz)\n\t\tst->size = neosz;\n}\n\nvoid\nhoedown_stack_push(hoedown_stack *st, void *item)\n{\n\tassert(st);\n\n\tif (st->size >= st->asize)\n\t\thoedown_stack_grow(st, st->size * 2);\n\n\tst->item[st->size++] = item;\n}\n\nvoid *\nhoedown_stack_pop(hoedown_stack *st)\n{\n\tassert(st);\n\n\tif (!st->size)\n\t\treturn NULL;\n\n\treturn st->item[--st->size];\n}\n\nvoid *\nhoedown_stack_top(const hoedown_stack *st)\n{\n\tassert(st);\n\n\tif (!st->size)\n\t\treturn NULL;\n\n\treturn st->item[st->size - 1];\n}\n/*\n------------------------------------------------------------------------------\n\tEND stack.c\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART html_blocks.c\n------------------------------------------------------------------------------\n*/\n/* ANSI-C code produced by gperf version 3.0.3 */\n/* Command-line: gperf -L ANSI-C -N hoedown_find_block_tag -c -C -E -S 1 --ignore-case -m100 html_block_names.gperf  */\n/* Computed positions: -k'1-2' */\n\n#if !((' ' == 32) && ('!' == 33) && ('\"' == 34) && ('#' == 35) \\\n      && ('%' == 37) && ('&' == 38) && ('\\'' == 39) && ('(' == 40) \\\n      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \\\n      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \\\n      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \\\n      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \\\n      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \\\n      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \\\n      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \\\n      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \\\n      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \\\n      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \\\n      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \\\n      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \\\n      && ('Z' == 90) && ('[' == 91) && ('\\\\' == 92) && (']' == 93) \\\n      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \\\n      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \\\n      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \\\n      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \\\n      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \\\n      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \\\n      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \\\n      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))\n/* The character set is not based on ISO-646.  */\n#error \"gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>.\"\n#endif\n\n/* maximum key range = 24, duplicates = 0 */\n\n#ifndef GPERF_DOWNCASE\n#define GPERF_DOWNCASE 1\nstatic unsigned char gperf_downcase[256] =\n  {\n      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,\n     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,\n     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,\n     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,\n     60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,\n    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,\n    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,\n    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\n    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,\n    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\n    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,\n    255\n  };\n#endif\n\n#ifndef GPERF_CASE_STRNCMP\n#define GPERF_CASE_STRNCMP 1\nstatic int\ngperf_case_strncmp (register const char *s1, register const char *s2, register unsigned int n)\n{\n  for (; n > 0;)\n    {\n      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n      if (c1 != 0 && c1 == c2)\n        {\n          n--;\n          continue;\n        }\n      return (int)c1 - (int)c2;\n    }\n  return 0;\n}\n#endif\n\n#ifdef __GNUC__\n__inline\n#else\n#ifdef __cplusplus\ninline\n#endif\n#endif\nstatic unsigned int\nhash (register const char *str, register unsigned int len)\n{\n  static const unsigned char asso_values[] =\n    {\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      22, 21, 19, 18, 16,  0, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25,  1, 25,  0, 25,\n       1,  0,  0, 13,  0, 25, 25, 11,  2,  1,\n       0, 25, 25,  5,  0,  2, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25,  1, 25,\n       0, 25,  1,  0,  0, 13,  0, 25, 25, 11,\n       2,  1,  0, 25, 25,  5,  0,  2, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n      25, 25, 25, 25, 25, 25, 25\n    };\n  register int hval = (int)len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[1]+1];\n      /*FALLTHROUGH*/\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval;\n}\n\n#ifdef __GNUC__\n__inline\n#ifdef __GNUC_STDC_INLINE__\n__attribute__ ((__gnu_inline__))\n#endif\n#endif\nconst char *\nhoedown_find_block_tag (register const char *str, register unsigned int len)\n{\n  enum\n    {\n      TOTAL_KEYWORDS = 24,\n      MIN_WORD_LENGTH = 1,\n      MAX_WORD_LENGTH = 10,\n      MIN_HASH_VALUE = 1,\n      MAX_HASH_VALUE = 24\n    };\n\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n        {\n          register const char *resword;\n\n          switch (key - 1)\n            {\n              case 0:\n                resword = \"p\";\n                goto compare;\n              case 1:\n                resword = \"h6\";\n                goto compare;\n              case 2:\n                resword = \"div\";\n                goto compare;\n              case 3:\n                resword = \"del\";\n                goto compare;\n              case 4:\n                resword = \"form\";\n                goto compare;\n              case 5:\n                resword = \"table\";\n                goto compare;\n              case 6:\n                resword = \"figure\";\n                goto compare;\n              case 7:\n                resword = \"pre\";\n                goto compare;\n              case 8:\n                resword = \"fieldset\";\n                goto compare;\n              case 9:\n                resword = \"noscript\";\n                goto compare;\n              case 10:\n                resword = \"script\";\n                goto compare;\n              case 11:\n                resword = \"style\";\n                goto compare;\n              case 12:\n                resword = \"dl\";\n                goto compare;\n              case 13:\n                resword = \"ol\";\n                goto compare;\n              case 14:\n                resword = \"ul\";\n                goto compare;\n              case 15:\n                resword = \"math\";\n                goto compare;\n              case 16:\n                resword = \"ins\";\n                goto compare;\n              case 17:\n                resword = \"h5\";\n                goto compare;\n              case 18:\n                resword = \"iframe\";\n                goto compare;\n              case 19:\n                resword = \"h4\";\n                goto compare;\n              case 20:\n                resword = \"h3\";\n                goto compare;\n              case 21:\n                resword = \"blockquote\";\n                goto compare;\n              case 22:\n                resword = \"h2\";\n                goto compare;\n              case 23:\n                resword = \"h1\";\n                goto compare;\n            }\n          return 0;\n        compare:\n          if ((((unsigned char)*str ^ (unsigned char)*resword) & ~32) == 0 && !gperf_case_strncmp (str, resword, len) && resword[len] == '\\0')\n            return resword;\n        }\n    }\n  return 0;\n}\n/*\n------------------------------------------------------------------------------\n\tEND html_blocks.c\n------------------------------------------------------------------------------\n*/\n\n/*\n------------------------------------------------------------------------------\n\tSTART html_smartypants.c\n------------------------------------------------------------------------------\n*/\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"html.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#ifdef _MSC_VER\n#define snprintf _snprintf\n#endif\n\nstruct smartypants_data {\n\tint in_squote;\n\tint in_dquote;\n};\n\nstatic size_t smartypants_cb__ltag(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__dquote(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__amp(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__period(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__number(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__dash(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__parens(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__squote(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__backtick(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\nstatic size_t smartypants_cb__escape(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n\nstatic size_t (*smartypants_cb_ptrs[])\n\t(hoedown_buffer *, struct smartypants_data *, uint8_t, const uint8_t *, size_t) =\n{\n\tNULL,\t\t\t\t\t/* 0 */\n\tsmartypants_cb__dash,\t/* 1 */\n\tsmartypants_cb__parens,\t/* 2 */\n\tsmartypants_cb__squote, /* 3 */\n\tsmartypants_cb__dquote, /* 4 */\n\tsmartypants_cb__amp,\t/* 5 */\n\tsmartypants_cb__period,\t/* 6 */\n\tsmartypants_cb__number,\t/* 7 */\n\tsmartypants_cb__ltag,\t/* 8 */\n\tsmartypants_cb__backtick, /* 9 */\n\tsmartypants_cb__escape, /* 10 */\n};\n\nstatic const uint8_t smartypants_cb_chars[UINT8_MAX+1] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 4, 0, 0, 0, 5, 3, 2, 0, 0, 0, 0, 1, 6, 0,\n\t0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,\n\t9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic int\nword_boundary(uint8_t c)\n{\n\treturn c == 0 || isspace(c) || ispunct(c);\n}\n\n/*\n\tIf 'text' begins with any kind of single quote (e.g. \"'\" or \"&apos;\" etc.),\n\treturns the length of the sequence of characters that makes up the single-\n\tquote.  Otherwise, returns zero.\n*/\nstatic size_t\nsquote_len(const uint8_t *text, size_t size)\n{\n\tstatic char* single_quote_list[] = { \"'\", \"&#39;\", \"&#x27;\", \"&apos;\", NULL };\n\tchar** p;\n\n\tfor (p = single_quote_list; *p; ++p) {\n\t\tsize_t len = strlen(*p);\n\t\tif (size >= len && memcmp(text, *p, len) == 0) {\n\t\t\treturn len;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Converts \" or ' at very beginning or end of a word to left or right quote */\nstatic int\nsmartypants_quotes(hoedown_buffer *ob, uint8_t previous_char, uint8_t next_char, uint8_t quote, int *is_open)\n{\n\tchar ent[8];\n\n\tif (*is_open && !word_boundary(next_char))\n\t\treturn 0;\n\n\tif (!(*is_open) && !word_boundary(previous_char))\n\t\treturn 0;\n\n\tsnprintf(ent, sizeof(ent), \"&%c%cquo;\", (*is_open) ? 'r' : 'l', quote);\n\t*is_open = !(*is_open);\n\thoedown_buffer_puts(ob, ent);\n\treturn 1;\n}\n\n/*\n\tConverts ' to left or right single quote; but the initial ' might be in\n\tdifferent forms, e.g. &apos; or &#39; or &#x27;.\n\t'squote_text' points to the original single quote, and 'squote_size' is its length.\n\t'text' points at the last character of the single-quote, e.g. ' or ;\n*/\nstatic size_t\nsmartypants_squote(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size,\n\t\t\t\t   const uint8_t *squote_text, size_t squote_size)\n{\n\tif (size >= 2) {\n\t\tuint8_t t1 = tolower(text[1]);\n\t\tsize_t next_squote_len = squote_len(text+1, size-1);\n\n\t\t/* convert '' to &ldquo; or &rdquo; */\n\t\tif (next_squote_len > 0) {\n\t\t\tuint8_t next_char = (size > 1+next_squote_len) ? text[1+next_squote_len] : 0;\n\t\t\tif (smartypants_quotes(ob, previous_char, next_char, 'd', &smrt->in_dquote))\n\t\t\t\treturn next_squote_len;\n\t\t}\n\n\t\t/* Tom's, isn't, I'm, I'd */\n\t\tif ((t1 == 's' || t1 == 't' || t1 == 'm' || t1 == 'd') &&\n\t\t\t(size == 3 || word_boundary(text[2]))) {\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"&rsquo;\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* you're, you'll, you've */\n\t\tif (size >= 3) {\n\t\t\tuint8_t t2 = tolower(text[2]);\n\n\t\t\tif (((t1 == 'r' && t2 == 'e') ||\n\t\t\t\t(t1 == 'l' && t2 == 'l') ||\n\t\t\t\t(t1 == 'v' && t2 == 'e')) &&\n\t\t\t\t(size == 4 || word_boundary(text[3]))) {\n\t\t\t\tHOEDOWN_BUFPUTSL(ob, \"&rsquo;\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 's', &smrt->in_squote))\n\t\treturn 0;\n\n\thoedown_buffer_put(ob, squote_text, squote_size);\n\treturn 0;\n}\n\n/* Converts ' to left or right single quote. */\nstatic size_t\nsmartypants_cb__squote(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\treturn smartypants_squote(ob, smrt, previous_char, text, size, text, 1);\n}\n\n/* Converts (c), (r), (tm) */\nstatic size_t\nsmartypants_cb__parens(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 3) {\n\t\tuint8_t t1 = tolower(text[1]);\n\t\tuint8_t t2 = tolower(text[2]);\n\n\t\tif (t1 == 'c' && t2 == ')') {\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"&copy;\");\n\t\t\treturn 2;\n\t\t}\n\n\t\tif (t1 == 'r' && t2 == ')') {\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"&reg;\");\n\t\t\treturn 2;\n\t\t}\n\n\t\tif (size >= 4 && t1 == 't' && t2 == 'm' && text[3] == ')') {\n\t\t\tHOEDOWN_BUFPUTSL(ob, \"&trade;\");\n\t\t\treturn 3;\n\t\t}\n\t}\n\n\thoedown_buffer_putc(ob, text[0]);\n\treturn 0;\n}\n\n/* Converts \"--\" to em-dash, etc. */\nstatic size_t\nsmartypants_cb__dash(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 3 && text[1] == '-' && text[2] == '-') {\n\t\tHOEDOWN_BUFPUTSL(ob, \"&mdash;\");\n\t\treturn 2;\n\t}\n\n\tif (size >= 2 && text[1] == '-') {\n\t\tHOEDOWN_BUFPUTSL(ob, \"&ndash;\");\n\t\treturn 1;\n\t}\n\n\thoedown_buffer_putc(ob, text[0]);\n\treturn 0;\n}\n\n/* Converts &quot; etc. */\nstatic size_t\nsmartypants_cb__amp(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tsize_t len;\n\tif (size >= 6 && memcmp(text, \"&quot;\", 6) == 0) {\n\t\tif (smartypants_quotes(ob, previous_char, size >= 7 ? text[6] : 0, 'd', &smrt->in_dquote))\n\t\t\treturn 5;\n\t}\n\n\tlen = squote_len(text, size);\n\tif (len > 0) {\n\t\treturn (len-1) + smartypants_squote(ob, smrt, previous_char, text+(len-1), size-(len-1), text, len);\n\t}\n\n\tif (size >= 4 && memcmp(text, \"&#0;\", 4) == 0)\n\t\treturn 3;\n\n\thoedown_buffer_putc(ob, '&');\n\treturn 0;\n}\n\n/* Converts \"...\" to ellipsis */\nstatic size_t\nsmartypants_cb__period(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 3 && text[1] == '.' && text[2] == '.') {\n\t\tHOEDOWN_BUFPUTSL(ob, \"&hellip;\");\n\t\treturn 2;\n\t}\n\n\tif (size >= 5 && text[1] == ' ' && text[2] == '.' && text[3] == ' ' && text[4] == '.') {\n\t\tHOEDOWN_BUFPUTSL(ob, \"&hellip;\");\n\t\treturn 4;\n\t}\n\n\thoedown_buffer_putc(ob, text[0]);\n\treturn 0;\n}\n\n/* Converts `` to opening double quote */\nstatic size_t\nsmartypants_cb__backtick(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size >= 2 && text[1] == '`') {\n\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n\t\t\treturn 1;\n\t}\n\n\thoedown_buffer_putc(ob, text[0]);\n\treturn 0;\n}\n\n/* Converts 1/2, 1/4, 3/4 */\nstatic size_t\nsmartypants_cb__number(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (word_boundary(previous_char) && size >= 3) {\n\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '2') {\n\t\t\tif (size == 3 || word_boundary(text[3])) {\n\t\t\t\tHOEDOWN_BUFPUTSL(ob, \"&frac12;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '4') {\n\t\t\tif (size == 3 || word_boundary(text[3]) ||\n\t\t\t\t(size >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h')) {\n\t\t\t\tHOEDOWN_BUFPUTSL(ob, \"&frac14;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\n\t\tif (text[0] == '3' && text[1] == '/' && text[2] == '4') {\n\t\t\tif (size == 3 || word_boundary(text[3]) ||\n\t\t\t\t(size >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's')) {\n\t\t\t\tHOEDOWN_BUFPUTSL(ob, \"&frac34;\");\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t}\n\n\thoedown_buffer_putc(ob, text[0]);\n\treturn 0;\n}\n\n/* Converts \" to left or right double quote */\nstatic size_t\nsmartypants_cb__dquote(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (!smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 'd', &smrt->in_dquote))\n\t\tHOEDOWN_BUFPUTSL(ob, \"&quot;\");\n\n\treturn 0;\n}\n\nstatic size_t\nsmartypants_cb__ltag(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tstatic const char *skip_tags[] = {\n\t  \"pre\", \"code\", \"var\", \"samp\", \"kbd\", \"math\", \"script\", \"style\"\n\t};\n\tstatic const size_t skip_tags_count = 8;\n\n\tsize_t tag, i = 0;\n\n\t/* This is a comment. Copy everything verbatim until --> or EOF is seen. */\n\tif (i + 4 < size && memcmp(text, \"<!--\", 4) == 0) {\n\t\ti += 4;\n\t\twhile (i + 3 < size && memcmp(text + i, \"-->\",  3) != 0)\n\t\t\ti++;\n\t\ti += 3;\n\t\thoedown_buffer_put(ob, text, i + 1);\n\t\treturn i;\n\t}\n\n\twhile (i < size && text[i] != '>')\n\t\ti++;\n\n\tfor (tag = 0; tag < skip_tags_count; ++tag) {\n\t\tif (hoedown_html_is_tag(text, size, skip_tags[tag]) == HOEDOWN_HTML_TAG_OPEN)\n\t\t\tbreak;\n\t}\n\n\tif (tag < skip_tags_count) {\n\t\tfor (;;) {\n\t\t\twhile (i < size && text[i] != '<')\n\t\t\t\ti++;\n\n\t\t\tif (i == size)\n\t\t\t\tbreak;\n\n\t\t\tif (hoedown_html_is_tag(text + i, size - i, skip_tags[tag]) == HOEDOWN_HTML_TAG_CLOSE)\n\t\t\t\tbreak;\n\n\t\t\ti++;\n\t\t}\n\n\t\twhile (i < size && text[i] != '>')\n\t\t\ti++;\n\t}\n\n\thoedown_buffer_put(ob, text, i + 1);\n\treturn i;\n}\n\nstatic size_t\nsmartypants_cb__escape(hoedown_buffer *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n{\n\tif (size < 2)\n\t\treturn 0;\n\n\tswitch (text[1]) {\n\tcase '\\\\':\n\tcase '\"':\n\tcase '\\'':\n\tcase '.':\n\tcase '-':\n\tcase '`':\n\t\thoedown_buffer_putc(ob, text[1]);\n\t\treturn 1;\n\n\tdefault:\n\t\thoedown_buffer_putc(ob, '\\\\');\n\t\treturn 0;\n\t}\n}\n\n#if 0\nstatic struct {\n    uint8_t c0;\n    const uint8_t *pattern;\n    const uint8_t *entity;\n    int skip;\n} smartypants_subs[] = {\n    { '\\'', \"'s>\",      \"&rsquo;\",  0 },\n    { '\\'', \"'t>\",      \"&rsquo;\",  0 },\n    { '\\'', \"'re>\",     \"&rsquo;\",  0 },\n    { '\\'', \"'ll>\",     \"&rsquo;\",  0 },\n    { '\\'', \"'ve>\",     \"&rsquo;\",  0 },\n    { '\\'', \"'m>\",      \"&rsquo;\",  0 },\n    { '\\'', \"'d>\",      \"&rsquo;\",  0 },\n    { '-',  \"--\",       \"&mdash;\",  1 },\n    { '-',  \"<->\",      \"&ndash;\",  0 },\n    { '.',  \"...\",      \"&hellip;\", 2 },\n    { '.',  \". . .\",    \"&hellip;\", 4 },\n    { '(',  \"(c)\",      \"&copy;\",   2 },\n    { '(',  \"(r)\",      \"&reg;\",    2 },\n    { '(',  \"(tm)\",     \"&trade;\",  3 },\n    { '3',  \"<3/4>\",    \"&frac34;\", 2 },\n    { '3',  \"<3/4ths>\", \"&frac34;\", 2 },\n    { '1',  \"<1/2>\",    \"&frac12;\", 2 },\n    { '1',  \"<1/4>\",    \"&frac14;\", 2 },\n    { '1',  \"<1/4th>\",  \"&frac14;\", 2 },\n    { '&',  \"&#0;\",      0,       3 },\n};\n#endif\n\nvoid\nhoedown_html_smartypants(hoedown_buffer *ob, const uint8_t *text, size_t size)\n{\n\tsize_t i;\n\tstruct smartypants_data smrt = {0, 0};\n\n\tif (!text)\n\t\treturn;\n\n\thoedown_buffer_grow(ob, size);\n\n\tfor (i = 0; i < size; ++i) {\n\t\tsize_t org;\n\t\tuint8_t action = 0;\n\n\t\torg = i;\n\t\twhile (i < size && (action = smartypants_cb_chars[text[i]]) == 0)\n\t\t\ti++;\n\n\t\tif (i > org)\n\t\t\thoedown_buffer_put(ob, text + org, i - org);\n\n\t\tif (i < size) {\n\t\t\ti += smartypants_cb_ptrs[(int)action]\n\t\t\t\t(ob, &smrt, i ? text[i - 1] : 0, text + i, size - i);\n\t\t}\n\t}\n}\n/*\n------------------------------------------------------------------------------\n\tEND html_smartypants.c\n------------------------------------------------------------------------------\n*/\n\n#pragma warning( pop )\n\n#endif /* HOEDOWN_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n    LICENSE\n------------------------------------------------------------------------------\n\nCopyright (c) 2008, Natacha Porte\nCopyright (c) 2011, Vicent Marti\nCopyright (c) 2014, Xavier Mendez, Devin Torres and the Hoedown authors\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "http.h",
          "type": "blob",
          "size": 26.685546875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nhttp.hpp - v1.0 - Basic HTTP protocol implementation over sockets (no https).\n\nDo this:\n    #define HTTP_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef http_hpp\n#define http_hpp\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <stddef.h> // for size_t\n#include <stdint.h> // for uintptr_t\n\ntypedef enum http_status_t\n    {\n    HTTP_STATUS_PENDING,\n    HTTP_STATUS_COMPLETED,\n    HTTP_STATUS_FAILED,\n    } http_status_t;\n\ntypedef struct http_t\n    {\n    http_status_t status;\n    int status_code;\n    char const* reason_phrase;\n    char const* content_type;\n    size_t response_size;\n    void* response_data;\n    } http_t;\n\nhttp_t* http_get( char const* url, void* memctx );\nhttp_t* http_post( char const* url, void const* data, size_t size, void* memctx );\n\nhttp_status_t http_process( http_t* http );\n\nvoid http_release( http_t* http );\n\n#endif /* http_hpp */\n\n/** \n\nhttp.hpp\n========\n\nBasic HTTP protocol implementation over sockets (no https).\n\n\nExample\n-------\n\n    #define HTTP_IMPLEMENTATION\n    #include \"http.h\"\n\n    int main( int argc, char** argv ) {\n        http_t* request = http_get( \"http://www.mattiasgustavsson.com/http_test.txt\", NULL );\n        if( !request ) {\n            printf( \"Invalid request.\\n\" );\n            return 1;\n        }\n\n        http_status_t status = HTTP_STATUS_PENDING;\n        int prev_size = -1;\n        while( status == HTTP_STATUS_PENDING ) {\n            status = http_process( request );\n            if( prev_size != (int) request->response_size ) {\n                printf( \"%d byte(s) received.\\n\", (int) request->response_size );\n                prev_size = (int) request->response_size;\n            }\n        }\n\n        if( status == HTTP_STATUS_FAILED ) {\n            printf( \"HTTP request failed (%d): %s.\\n\", request->status_code, request->reason_phrase );\n            http_release( request );\n            return 1;\n        }\n    \n        printf( \"\\nContent type: %s\\n\\n%s\\n\", request->content_type, (char const*)request->response_data );\n        http_release( request );\n        return 0;\n    }\n\n\nAPI Documentation\n-----------------\n\nhttp.h is a small library for making http requests from a web server. It only supports GET and POST http commands, and\nis designed for when you just need a very basic way of communicating over http. http.h does not support https \nconnections, just plain http.\n\nhttp.h is a single-header library, and does not need any .lib files or other binaries, or any build scripts. To use \nit, you just include http.h to get the API declarations. To get the definitions, you must include http.h from \n*one* single C or C++ file, and #define the symbol `HTTP_IMPLEMENTATION` before you do. \n\n\n#### Custom memory allocators\n\nFor working memory and to store the retrieved data, http.h needs to do dynamic allocation by calling `malloc`. Programs \nmight want to keep track of allocations done, or use custom defined pools to allocate memory from. http.h allows \nfor specifying custom memory allocation functions for `malloc` and `free`. This is done with the following code:\n\n    #define HTTP_IMPLEMENTATION\n    #define HTTP_MALLOC( ctx, size ) ( my_custom_malloc( ctx, size ) )\n    #define HTTP_FREE( ctx, ptr ) ( my_custom_free( ctx, ptr ) )\n    #include \"http.h\"\n\nwhere `my_custom_malloc` and `my_custom_free` are your own memory allocation/deallocation functions. The `ctx` parameter\nis an optional parameter of type `void*`. When `http_get` or `http_post` is called, , you can pass in a `memctx` \nparameter, which can be a pointer to anything you like, and which will be passed through as the `ctx` parameter to every \n`HTTP_MALLOC`/`HTTP_FREE` call. For example, if you are doing memory tracking, you can pass a pointer to your \ntracking data as `memctx`, and in your custom allocation/deallocation function, you can cast the `ctx` param back to the \nright type, and access the tracking data.\n\nIf no custom allocator is defined, http.h will default to `malloc` and `free` from the C runtime library.\n\n\nhttp_get\n--------\n\n    http_t* http_get( char const* url, void* memctx )\n\nInitiates a http GET request with the specified url. `url` is a zero terminated string containing the request location,\njust like you would type it in a browser, for example `http://www.mattiasgustavsson.com:80/http_test.txt`. `memctx` is a \npointer to user defined data which will be passed through to the custom HTTP_MALLOC/HTTP_FREE calls. It can be NULL if \nno user defined data is needed. Returns a `http_t` instance, which needs to be passed to `http_process` to process the\nrequest. When the request is finished (or have failed), the returned `http_t` instance needs to be released by calling\n`http_release`. If the request was invalid, `http_get` returns NULL.\n\n\nhttp_post\n---------\n\n    http_t* http_post( char const* url, void const* data, size_t size, void* memctx )\n\nInitiates a http POST request with the specified url. `url` is a zero terminated string containing the request location,\njust like you would type it in a browser, for example `http://www.mattiasgustavsson.com:80/http_test.txt`. `data` is a\npointer to the data to be sent along as part of the request, and `size` is the number of bytes to send. `memctx` is a \npointer to user defined data which will be passed through to the custom HTTP_MALLOC/HTTP_FREE calls. It can be NULL if \nno user defined data is needed. Returns a `http_t` instance, which needs to be passed to `http_process` to process the\nrequest. When the request is finished (or have failed), the returned `http_t` instance needs to be released by calling\n`http_release`. If the request was invalid, `http_post` returns NULL.\n\n\nhttp_process\n------------\n\n    http_status_t http_process( http_t* http )\n\nhttp.h uses non-blocking sockets, so after a request have been made by calling either `http_get` or `http_post`, you \nhave to keep calling `http_process` for as long as it returns `HTTP_STATUS_PENDING`. You can call it from a loop which \ndoes other work too, for example from inside a game loop or from a loop which calls `http_process` on multiple requests.\nIf the request fails, `http_process` returns `HTTP_STATUS_FAILED`, and the fields `status_code` and `reason_phrase` may\ncontain more details (for example, status code can be 404 if the requested resource was not found on the server). If the \nrequest completes successfully, it returns `HTTP_STATUS_COMPLETED`. In this case, the `http_t` instance will contain \ndetails about the result. `status_code` and `reason_phrase` contains the details about the result, as specified in the\nHTTP protocol. `content_type` contains the MIME type for the returns resource, for example `text/html` for a normal web\npage. `response_data` is the pointer to the received data, and `resonse_size` is the number of bytes it contains. In the\ncase when the response data is in text format, http.h ensures there is a zero terminator placed immediately after the\nresponse data block, so it is safe to interpret the resonse data as a `char*`. Note that the data size in this case will \nbe the length of the data without the additional zero terminator.\n\n\nhttp_release\n------------\n\n    void http_release( http_t* http )\n\nReleases the resources acquired by `http_get` or `http_post`. Should be call when you are finished with the request.\n\n*/\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef HTTP_IMPLEMENTATION\n\n#ifdef _WIN32\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #pragma warning( push )\n    #pragma warning( disable: 4127 ) // conditional expression is constant\n    #pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n    #pragma warning( disable: 4365 ) // 'action' : conversion from 'type_1' to 'type_2', signed/unsigned mismatch\n    #pragma warning( disable: 4574 ) // 'Identifier' is defined to be '0': did you mean to use '#if identifier'?\n    #pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directive'\n    #pragma warning( disable: 4706 ) // assignment within conditional expression\n    #include <winsock2.h>\n    #include <ws2tcpip.h>\n    #pragma warning( pop )\n    #pragma comment (lib, \"Ws2_32.lib\") \n    #include <string.h>\n    #include <stdio.h>\n    #define HTTP_SOCKET SOCKET\n    #define HTTP_INVALID_SOCKET INVALID_SOCKET\n#else\n    #include <stdlib.h>\n    #include <stdio.h>\n    #include <string.h>\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <unistd.h>\n    #include <errno.h>\n    #include <fcntl.h>\n    #include <netdb.h>\n    #define HTTP_SOCKET int\n    #define HTTP_INVALID_SOCKET -1\n#endif\n\n#ifndef HTTP_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define HTTP_MALLOC( ctx, size ) ( malloc( size ) )\n    #define HTTP_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\ntypedef struct http_internal_t \n    {\n    /* keep this at the top!*/ \n    http_t http;\n    /* because http_internal_t* can be cast to http_t*. */\n    \n    void* memctx;\n    HTTP_SOCKET socket;\n    int connect_pending;\n    int request_sent;\n    char address[ 256 ];\n    char request_header[ 256 ];\n    char* request_header_large;\n    void* request_data;\n    size_t request_data_size;\n    char reason_phrase[ 1024 ];\n    char content_type[ 256 ];\n    size_t data_size;\n    size_t data_capacity;\n    void* data;\n    } http_internal_t;\n\n\nstatic int http_internal_parse_url( char const* url, char* address, size_t address_capacity, char* port, \n    size_t port_capacity, char const** resource )\n    {\n    // make sure url starts with http://\n    if( strncmp( url, \"http://\", 7 ) != 0 ) return 0;\n    url += 7; // skip http:// part of url\n    \n    size_t url_len = strlen( url );\n\n    // find end of address part of url\n    char const* address_end = strchr( url, ':' );\n    if( !address_end ) address_end = strchr( url, '/' );\n    if( !address_end ) address_end = url + url_len;\n\n    // extract address\n    size_t address_len = (size_t)( address_end - url );\n    if( address_len >= address_capacity ) return 0;\n    memcpy( address, url, address_len );\n    address[ address_len ] = 0;\n\n    // check if there's a port defined\n    char const* port_end = address_end;\n    if( *address_end == ':' )\n        {\n        ++address_end;\n        port_end = strchr( address_end, '/' );\n        if( !port_end ) port_end = address_end + strlen( address_end );\n        size_t port_len = (size_t)( port_end - address_end );\n        if( port_len >= port_capacity ) return 0;\n        memcpy( port, address_end, port_len );\n        port[ port_len ] = 0;\n        }\n    else\n        {\n        // use default port number 80\n        if( port_capacity <= 2 ) return 0;\n        strcpy( port, \"80\" );\n        }\n\n\n    *resource = port_end;\n\n    return 1;\n    }\n\n\nHTTP_SOCKET http_internal_connect( char const* address, char const* port )\n    {   \n    // set up hints for getaddrinfo\n    struct addrinfo hints;\n    memset( &hints, 0, sizeof( hints ) );\n    hints.ai_family = AF_UNSPEC; // the Internet Protocol version 4 (IPv4) address family.\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;    // Use Transmission Control Protocol (TCP).\n\n    // resolve the server address and port\n    struct addrinfo* addri = 0;\n    int error = getaddrinfo( address, port, &hints, &addri) ;\n    if( error != 0 ) return HTTP_INVALID_SOCKET;\n\n    // create the socket\n    HTTP_SOCKET sock = socket( addri->ai_family, addri->ai_socktype, addri->ai_protocol );\n    if( sock == -1) \n        {\n        freeaddrinfo( addri );\n        return HTTP_INVALID_SOCKET;\n        }\n\n    // set socket to nonblocking mode\n    u_long nonblocking = 1;\n    #ifdef _WIN32\n        int res = ioctlsocket( sock, FIONBIO, &nonblocking );\n    #else\n        int flags = fcntl( sock, F_GETFL, 0 );\n        int res = fcntl( sock, F_SETFL, flags | O_NONBLOCK ); \n    #endif\n    if( res == -1 )\n        {\n        freeaddrinfo( addri );\n        #ifdef _WIN32\n            closesocket( sock );\n        #else\n            close( sock );\n        #endif\n        return HTTP_INVALID_SOCKET;\n        }\n\n    // connect to server\n    if( connect( sock, addri->ai_addr, (int)addri->ai_addrlen ) == -1 )\n        {\n        #ifdef _WIN32\n            if( WSAGetLastError() != WSAEWOULDBLOCK && WSAGetLastError() != WSAEINPROGRESS )\n                {\n                freeaddrinfo( addri );\n                closesocket( sock );\n                return HTTP_INVALID_SOCKET;\n                }\n        #else\n            if( errno != EWOULDBLOCK && errno != EINPROGRESS && errno != EAGAIN )\n                {\n                freeaddrinfo( addri );\n                close( sock );\n                return HTTP_INVALID_SOCKET;\n                }\n        #endif\n        }\n\n    freeaddrinfo( addri );\n    return sock;\n    }\n\n    \nstatic http_internal_t* http_internal_create( size_t request_data_size, void* memctx )\n    {\n    http_internal_t* internal = (http_internal_t*) HTTP_MALLOC( memctx, sizeof( http_internal_t ) + request_data_size );\n\n    internal->http.status = HTTP_STATUS_PENDING;\n    internal->http.status_code = 0;\n    internal->http.response_size = 0;\n    internal->http.response_data = NULL;\n\n    internal->memctx = memctx;\n    internal->connect_pending = 1;\n    internal->request_sent = 0;\n    \n    strcpy( internal->reason_phrase, \"\" );\n    internal->http.reason_phrase = internal->reason_phrase;\n\n    strcpy( internal->content_type, \"\" );\n    internal->http.content_type = internal->content_type;\n\n    internal->data_size = 0;\n    internal->data_capacity = 64 * 1024;\n    internal->data = HTTP_MALLOC( memctx, internal->data_capacity );\n    \n    internal->request_data = NULL;\n    internal->request_data_size = 0;\n    \n    return internal;\n    }\n\n\nhttp_t* http_get( char const* url, void* memctx )\n    {       \n    #ifdef _WIN32\n        WSADATA wsa_data;\n        if( WSAStartup( MAKEWORD( 1, 0 ), &wsa_data ) != 0 ) return NULL;\n    #endif\n    \n    char address[ 256 ];\n    char port[ 16 ];\n    char const* resource;\n    \n    if( http_internal_parse_url( url, address, sizeof( address ), port, sizeof( port ), &resource ) == 0 )\n        return NULL; \n\n    HTTP_SOCKET socket = http_internal_connect( address, port );\n    if( socket == HTTP_INVALID_SOCKET ) return NULL;\n    \n    http_internal_t* internal = http_internal_create( 0, memctx );\n    internal->socket = socket;\n\n    char* request_header;   \n    size_t request_header_len = 64 + strlen( resource ) + strlen( address ) + strlen( port );\n    if( request_header_len < sizeof( internal->request_header ) )\n        {\n        internal->request_header_large = NULL;\n        request_header = internal->request_header;\n        }\n    else\n        {\n        internal->request_header_large = (char*) HTTP_MALLOC( memctx, request_header_len + 1 );\n        request_header = internal->request_header_large;\n        }       \n    int default_http_port = (strcmp(port, \"80\") == 0);\n    sprintf( request_header, \"GET %s HTTP/1.0\\r\\nHost: %s%s%s\\r\\n\\r\\n\", resource, address, default_http_port ? \"\" : \":\", default_http_port ? \"\" : port );\n    \n    return &internal->http;\n    }\n\n\nhttp_t* http_post( char const* url, void const* data, size_t size, void* memctx )\n    {\n    #ifdef _WIN32\n        WSADATA wsa_data;\n        if( WSAStartup( MAKEWORD( 1, 0 ), &wsa_data ) != 0 ) return 0;\n    #endif\n    \n    char address[ 256 ];\n    char port[ 16 ];\n    char const* resource;\n    \n    if( http_internal_parse_url( url, address, sizeof( address ), port, sizeof( port ), &resource ) == 0 )\n        return NULL; \n\n    HTTP_SOCKET socket = http_internal_connect( address, port );\n    if( socket == HTTP_INVALID_SOCKET ) return NULL;\n    \n    http_internal_t* internal = http_internal_create( size, memctx );\n    internal->socket = socket;\n\n    char* request_header;   \n    size_t request_header_len = 64 + strlen( resource ) + strlen( address ) + strlen( port );\n    if( request_header_len < sizeof( internal->request_header ) )\n        {\n        internal->request_header_large = NULL;\n        request_header = internal->request_header;\n        }\n    else\n        {\n        internal->request_header_large = (char*) HTTP_MALLOC( memctx, request_header_len + 1 );\n        request_header = internal->request_header_large;\n        }       \n    int default_http_port = (strcmp(port, \"80\") == 0);\n    sprintf( request_header, \"POST %s HTTP/1.0\\r\\nHost: %s%s%s\\r\\nContent-Length: %d\\r\\n\\r\\n\", resource, address, default_http_port ? \"\" : \":\", default_http_port ? \"\" : port, \n        (int) size );\n    \n    internal->request_data_size = size;\n    internal->request_data = ( internal + 1 );\n    memcpy( internal->request_data, data, size );\n    \n    return &internal->http;\n    }\n\n\nhttp_status_t http_process( http_t* http )\n    {\n    http_internal_t* internal = (http_internal_t*) http;    \n    \n    if( http->status == HTTP_STATUS_FAILED ) return http->status;\n    \n    if( internal->connect_pending )\n        {   \n        fd_set sockets_to_check; \n        FD_ZERO( &sockets_to_check );\n        #pragma warning( push )\n        #pragma warning( disable: 4548 ) // expression before comma has no effect; expected expression with side-effect\n        FD_SET( internal->socket, &sockets_to_check );\n        #pragma warning( pop )\n        struct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = 0;\n        // check if socket is ready for send\n        if( select( (int)( internal->socket + 1 ), NULL, &sockets_to_check, NULL, &timeout ) == 1 ) \n            {\n            int opt = -1;\n            socklen_t len = sizeof( opt ); \n            if( getsockopt( internal->socket, SOL_SOCKET, SO_ERROR, (char*)( &opt ), &len) >= 0 && opt == 0 ) \n                internal->connect_pending = 0; // if it is, we're connected\n            }\n        }\n\n    if( internal->connect_pending ) return http->status;\n\n    if( !internal->request_sent )\n        {\n        char const* request_header = internal->request_header_large ? \n            internal->request_header_large : internal->request_header;\n        if( send( internal->socket, request_header, (int) strlen( request_header ), 0 ) == -1 )\n            {\n            http->status = HTTP_STATUS_FAILED;\n            return http->status;\n            }\n        if( internal->request_data_size )\n            {\n            int res = send( internal->socket, (char const*)internal->request_data, (int) internal->request_data_size, 0 );\n            if( res == -1 )\n                {\n                http->status = HTTP_STATUS_FAILED;\n                return http->status;\n                }\n            }\n        internal->request_sent = 1;\n        return http->status;\n        }\n\n    // check if socket is ready for recv\n    fd_set sockets_to_check; \n    FD_ZERO( &sockets_to_check );\n    #pragma warning( push )\n    #pragma warning( disable: 4548 ) // expression before comma has no effect; expected expression with side-effect\n    FD_SET( internal->socket, &sockets_to_check );\n    #pragma warning( pop )\n    struct timeval timeout; timeout.tv_sec = 0; timeout.tv_usec = 0;\n    while( select( (int)( internal->socket + 1 ), &sockets_to_check, NULL, NULL, &timeout ) == 1 )\n        {\n        char buffer[ 4096 ];\n        int size = recv( internal->socket, buffer, sizeof( buffer ), 0 );\n        if( size == -1 )\n            {\n            http->status = HTTP_STATUS_FAILED;\n            return http->status;\n            }\n        else if( size > 0 )\n            {\n            size_t min_size = internal->data_size + size + 1;\n            if( internal->data_capacity < min_size )\n                {\n                internal->data_capacity *= 2; \n                if( internal->data_capacity < min_size ) internal->data_capacity = min_size;\n                void* new_data = HTTP_MALLOC( memctx, internal->data_capacity );\n                memcpy( new_data, internal->data, internal->data_size );\n                HTTP_FREE( memctx, internal->data );\n                internal->data = new_data;\n                }\n            memcpy( (void*)( ( (uintptr_t) internal->data ) + internal->data_size ), buffer, (size_t) size );\n            internal->data_size += size;\n            }\n        else if( size == 0 )\n            {\n            char const* status_line = (char const*) internal->data;\n\n            int header_size = 0;\n            char const* header_end = strstr( status_line, \"\\r\\n\\r\\n\" );\n            if( header_end )\n                {\n                header_end += 4;\n                header_size = (int)( header_end - status_line );\n                }\n            else\n                {\n                http->status = HTTP_STATUS_FAILED;\n                return http->status;\n                }\n\n            // skip http version\n            status_line = strchr( status_line, ' ' );\n            if( !status_line )\n                {\n                http->status = HTTP_STATUS_FAILED;\n                return http->status;\n                }\n            ++status_line;\n            \n            // extract status code\n            char status_code[ 16 ];\n            char const* status_code_end = strchr( status_line, ' ' );\n            if( !status_code_end )\n                {\n                http->status = HTTP_STATUS_FAILED;\n                return http->status;\n                }\n            memcpy( status_code, status_line, (size_t)( status_code_end - status_line ) );\n            status_code[ status_code_end - status_line ] = 0;\n            status_line = status_code_end + 1;\n            http->status_code = atoi( status_code );\n            \n            // extract reason phrase\n            char const* reason_phrase_end = strstr( status_line, \"\\r\\n\" );\n            if( !reason_phrase_end )\n                {\n                http->status = HTTP_STATUS_FAILED;\n                return http->status;\n                }\n            size_t reason_phrase_len = (size_t)( reason_phrase_end - status_line );\n            if( reason_phrase_len >= sizeof( internal->reason_phrase ) ) \n                reason_phrase_len = sizeof( internal->reason_phrase ) - 1;\n            memcpy( internal->reason_phrase, status_line, reason_phrase_len );\n            internal->reason_phrase[ reason_phrase_len ] = 0;\n            status_line = reason_phrase_end + 1;\n            \n            // extract content type\n            char const* content_type_start = strstr( status_line, \"Content-Type: \" );\n            if( content_type_start )\n                {\n                content_type_start += strlen( \"Content-Type: \" );\n                char const* content_type_end = strstr( content_type_start, \"\\r\\n\" );\n                if( content_type_end )\n                    {\n                    size_t content_type_len = (size_t)( content_type_end - content_type_start );\n                    if( content_type_len >= sizeof( internal->content_type ) ) \n                        content_type_len = sizeof( internal->content_type ) - 1;\n                    memcpy( internal->content_type, content_type_start, content_type_len );\n                    internal->content_type[ content_type_len ] = 0;\n                    }\n                }\n\n            http->status =  http->status_code < 300 ? HTTP_STATUS_COMPLETED : HTTP_STATUS_FAILED;\n            http->response_data = (void*)( ( (uintptr_t) internal->data ) + header_size );\n            http->response_size = internal->data_size - header_size;\n\n            // add an extra zero after the received data, but don't modify the size, so ascii results can be used as\n            // a zero terminated string. the size returned will be the string without this extra zero terminator.\n            ( (char*)http->response_data )[ http->response_size ] = 0;\n            return http->status;\n            }\n        }\n    \n    return http->status;\n    }\n\n\nvoid http_release( http_t* http )\n    {\n    http_internal_t* internal = (http_internal_t*) http;\n    #ifdef _WIN32\n        closesocket( internal->socket );\n    #else\n        close( internal->socket );\n    #endif\n\n    if( internal->request_header_large) HTTP_FREE( memctx, internal->request_header_large );\n    HTTP_FREE( memctx, internal->data );\n    HTTP_FREE( memctx, internal );\n    #ifdef _WIN32\n        WSACleanup();\n    #endif\n    }\n\n\n#endif /* HTTP_IMPLEMENTATION */\n\n/*\nrevision history:\n    1.0     first released version  \n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2016 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "id3tag.h",
          "type": "blob",
          "size": 30.53125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nid3tag.h - v0.1 - Read/write ID3 tags from/to mp3 files in C/C++.\n\nDo this:\n    #define ID3TAG_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef id3tag_h\n#define id3tag_h\n\n#ifndef ID3TAG_U32\n    #define ID3TAG_U32 unsigned int\n#endif\n   \n#define ID3TAG_PIC_TYPE_COVER_FRONT 3\n#define ID3TAG_PIC_TYPE_COVER_BACK 4\n#define ID3TAG_PIC_TYPE_LEAFLET_PAGE 5\n#define ID3TAG_PIC_TYPE_MEDIA 6\n#define ID3TAG_PIC_TYPE_ARTIST 8\n#define ID3TAG_PIC_TYPE_ARTIST_LOGO 13\n\n\ntypedef struct id3tag_pic_t\n    {\n    int pic_type;\n    char const* description;\n    char const* mime_type;\n    void const* data;\n    size_t size;\n    } id3tag_pic_t;\n\n\ntypedef struct id3tag_t\n    {\n    char const* title;\n    char const* artist;\n    char const* album_artist;\n    char const* album;\n    char const* sort_title;\n    char const* sort_artist;\n    char const* sort_album_artist;\n    char const* sort_album;\n    char const* genre;\n    char const* year;\n    char const* track;\n    char const* tracks;\n    char const* disc;\n    char const* discs;\n    char const* compilation;\n    int track_length;\n\n    int play_counter;\n\n    int pics_count;\n    id3tag_pic_t const* pics;\n    } id3tag_t;\n\n#define ID3TAG_ALL_FIELDS ( 0xFFFFFFFF )\n#define ID3TAG_FIELD_TITLE ( 1U )\n#define ID3TAG_FIELD_ARTIST ( 1U << 1U )\n#define ID3TAG_FIELD_ALBUM_ARTIST ( 1U << 2U )\n#define ID3TAG_FIELD_ALBUM ( 1U << 3U )\n#define ID3TAG_FIELD_SORT_TITLE ( 1U << 4U )\n#define ID3TAG_FIELD_SORT_ARTIST ( 1U << 5U )\n#define ID3TAG_FIELD_SORT_ALBUM_ARTIST ( 1U << 6U )\n#define ID3TAG_FIELD_SORT_ALBUM ( 1U << 7U )\n#define ID3TAG_FIELD_GENRE ( 1U << 8U )\n#define ID3TAG_FIELD_YEAR ( 1U << 9U )\n#define ID3TAG_FIELD_TRACK ( 1U << 10U )\n#define ID3TAG_FIELD_TRACKS ( 1U << 11U )\n#define ID3TAG_FIELD_DISC ( 1U << 12U )\n#define ID3TAG_FIELD_DISCS ( 1U << 13U )\n#define ID3TAG_FIELD_COMPILATION ( 1U << 14U )\n#define ID3TAG_FIELD_PLAY_COUNTER ( 1U << 15U )\n#define ID3TAG_FIELD_PICS ( 1U << 16U )\n#define ID3TAG_FIELD_TRACK_LENGTH ( 1U << 17U )\n\nsize_t id3tag_size( void const* first_ten_bytes );\n\nid3tag_t* id3tag_load( void const* data, size_t size, ID3TAG_U32 fields, void* memctx );\nid3tag_t* id3tag_load_id3v1( void const* data, size_t size, void* memctx );\nvoid id3tag_free( id3tag_t* id3tag );\n\nsize_t id3tag_save( id3tag_t const* id3tag, ID3TAG_U32 fields, void const* data, size_t capacity );\n\n\n#endif /* id3tag_h */\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef ID3TAG_IMPLEMENTATION\n#undef ID3TAG_IMPLEMENTATION\n\n#ifndef ID3TAG_U8\n    #define ID3TAG_U8 unsigned char\n#endif\n\n#ifndef ID3TAG_U16\n    #define ID3TAG_U16 unsigned short\n#endif\n\n\n#ifndef ID3TAG_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define ID3TAG_MALLOC( ctx, size ) ( malloc( size ) )\n    #define ID3TAG_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\ntypedef struct id3tag_internal_t\n{\n    id3tag_t tag;\n    void* memctx;\n    int pics_capacity;\n} id3tag_internal_t;\n\n\nint id3tag_internal_utf16_to_utf8( ID3TAG_U16* str, int len, char* out, int capacity, int endian_swap )\n    {       \n    ID3TAG_U16* in_ptr = str;\n    char* out_ptr = out;\n    char* out_end = out + capacity;\n\n    for( int i = 0; i < len; ++i )\n        {\n        ID3TAG_U32 cp = (ID3TAG_U32) *in_ptr++;\n        if( endian_swap ) cp = ( ( cp & 0xff00 ) >> 8 ) | ( ( cp & 0x00ff ) << 8 );\n\n        if( cp == 0x0000 ) break;\n\n        if( cp >= 0xd800u && cp <= 0xdbffu )\n            cp = ( cp << 10 ) + (*in_ptr++) + ( 0x10000u - ( 0xd800u << 10 ) - 0xdc00u );\n\n        if( cp < 0x80 )\n            {\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) cp ); else ++out_ptr;\n            }\n        else if( cp < 0x800 ) \n            {\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( cp >> 6) | 0xc0 ) ); else ++out_ptr;\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( cp & 0x3f ) | 0x80 ) ); else ++out_ptr;\n            }\n        else if (cp < 0x10000) \n            {\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( cp >> 12 ) | 0xe0 ) ); else ++out_ptr;\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( ( cp >> 6 ) & 0x3f ) | 0x80 ) ); else ++out_ptr;\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( cp & 0x3f ) | 0x80 ) ); else ++out_ptr;\n            }\n        else \n            {\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( cp >> 18 ) | 0xf0 ) ); else ++out_ptr;\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( ( cp >> 12 ) & 0x3f ) | 0x80 ) ); else ++out_ptr;\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( ( cp >> 6 ) & 0x3f ) | 0x80 ) ); else ++out_ptr;\n            if( out && out_ptr < out_end ) *out_ptr++ = (char)( (ID3TAG_U8) ( ( cp & 0x3f ) | 0x80 ) ); else ++out_ptr;\n            }\n        }\n    if( out && out_ptr < out_end ) *out_ptr++ = '\\0'; else ++out_ptr;\n\n    int out_len = out ? (int)( out_ptr - out ) : (int)(uintptr_t)( out_ptr );\n    return out_len;\n    }\n\n\n// TODO: Proper unicode support with a font that can handle it, instead of doing this\nchar* utf8_to_latin1( char* s )\n    {\n    for( int readIndex = 0, writeIndex = 0 ; ; writeIndex++ )\n    {\n        if( s[ readIndex ] == 0 ) { s[ writeIndex ] = 0; break; }\n\n        int len; \n        if ( (ID3TAG_U8) s[ readIndex ] < 0x80 ) len = 1;\n        else if ( ( (ID3TAG_U8) s[ readIndex ] & 0x20 ) == 0 ) len = 2;\n        else if ( ( (ID3TAG_U8) s[ readIndex ] & 0x10 ) == 0 ) len = 3;\n        else if ( ( (ID3TAG_U8) s[ readIndex ] & 0x08 ) == 0 ) len = 4;\n        else if ( ( (ID3TAG_U8) s[ readIndex ] & 0x04 ) == 0 ) len = 5;\n        else len = 6;\n        \n        char c = '\\0';\n        if( len == 1 ) \n            {\n            s[ writeIndex ] = s[ readIndex++ ];\n            }\n        else\n            {\n            int v = ( s[ readIndex++ ] & ( 0xff >> ( len + 1 ) ) ) << ( ( len - 1 ) * 6 );\n            for( len-- ; len > 0 ; len-- ) v |= ( (ID3TAG_U8)( s[ readIndex++ ] ) - 0x80 ) << ( ( len - 1 ) * 6 );\n            if( v == 8216 ) v = '\\'';\n            if( v == 8217 ) v = '\\'';\n            if( v == 9733 ) v = '*';\n            if( v == 8208 ) v = '-';\n            if( v == 8211 ) v = '-';\n            if( v == 8220 ) v = '\"';\n            if( v == 8221 ) v = 'r';\n            if( v == 8482 ) \n                v = ' '; // TM\n            if( v == 263 ) v = 'c';\n            if( v == 65533 ) v = '?';\n            if( v == 8230 ) { // '...'\n                s[ writeIndex++ ] = '.';\n                s[ writeIndex++ ] = '.';\n                v = '.';\n            }\n            if( v == 339 ) { \n                s[ writeIndex++ ] = 'o';\n                v = 'e';\n            }\n            if( v > 0xff ) {\n                v = ' ';\n            }\n            c = (char) v;\n            s[ writeIndex ] = c;\n            }\n        }\n\n    return s;\n    }\n\n\nsize_t id3tag_size( void const* first_ten_bytes )\n    {\n    ID3TAG_U8* ptr = (ID3TAG_U8*) first_ten_bytes;\n\n    // verify the header to see if this is a valid ID3 tag\n    if( *ptr++ != 0x49 || *ptr++ != 0x44 || *ptr++ != 0x33 || *ptr++ >= 0xff || *ptr++ >= 0xff ) return 0;\n\n    ++ptr; // skip flags field\n\n    ID3TAG_U32 size = 0;\n    for( int i = 0; i < 4; ++i )\n        {\n        ID3TAG_U8 b = *ptr++;\n        if( b >= 0x80 ) return 0; // Not a valid ID3\n        size |= ( (ID3TAG_U32) b ) << ( 7 * ( 3 - i ) );    \n        }\n\n    return (size_t) size + 10;\n    }\n\n\nchar* id3tag_internal_get_string( int encoding, ID3TAG_U8* ptr, int size, void* memctx, int* bytes_consumed )\n    {\n    (void) memctx;\n    if( encoding == 0) // Latin1\n        {\n        char* str = (char*)ID3TAG_MALLOC( memctx, (size_t)( size + 1 ) );\n        memcpy( str, ptr, (size_t) size );\n        str[ size ] = '\\0';\n        if( bytes_consumed ) *bytes_consumed = (int) strlen( str ) + 1;\n        return str;\n        }\n    else if( encoding == 1 ) // UTF16 with BOM\n        {\n        ID3TAG_U16 bom = *( (ID3TAG_U16*) ptr );\n        if( bom == 0xfffe || bom == 0xfeff ) { ptr += 2; size -= 2; }\n        int endian_swap = ( bom == 0xfffe );                \n\n        int len = id3tag_internal_utf16_to_utf8( (ID3TAG_U16*) ptr, size / 2, 0, 0, endian_swap );\n        char* str = (char*)ID3TAG_MALLOC( memctx, (size_t) len );\n        id3tag_internal_utf16_to_utf8( (ID3TAG_U16*) ptr, size / 2, str, len, endian_swap );\n\n        if( bytes_consumed ) \n            {\n            *bytes_consumed = ( ( bom == 0xfffe || bom == 0xfeff ) ? 2 : 0 );\n            ID3TAG_U16* s = (ID3TAG_U16*) ptr;\n            while( *s++ ) *bytes_consumed = ( *bytes_consumed ) + 2;\n            *bytes_consumed = ( *bytes_consumed ) + 2;\n            }\n\n        utf8_to_latin1( str );\n        return str;\n        }\n    else if( encoding == 2 ) // UTF16BE without BOM\n        {\n        int endian_swap = 1;                \n\n        int len = id3tag_internal_utf16_to_utf8( (ID3TAG_U16*) ptr, size / 2, 0, 0, endian_swap );\n        char* str = (char*)ID3TAG_MALLOC( memctx, (size_t) len );\n        id3tag_internal_utf16_to_utf8( (ID3TAG_U16*) ptr, size / 2, str, len, endian_swap );\n\n        if( bytes_consumed ) \n            {\n            *bytes_consumed = 0;\n            ID3TAG_U16* s = (ID3TAG_U16*) ptr;\n            while( *s++ ) *bytes_consumed = ( *bytes_consumed ) + 2;\n            *bytes_consumed = ( *bytes_consumed ) + 2;\n        }\n\n        utf8_to_latin1( str );\n        return str;\n        }\n    else if( encoding == 3 ) // UTF8\n        {\n        char* str = (char*)ID3TAG_MALLOC( memctx, (size_t) size + 1 );\n        memcpy( str, ptr, (size_t) size );\n        str[ size ] = '\\0';\n        if( bytes_consumed ) *bytes_consumed = (int) strlen( str ) + 1;\n\n        utf8_to_latin1( str );\n        return str;\n        }\n    else\n        {\n        return 0;\n        }\n    }\n\n\nid3tag_t* id3tag_load_id3v1( void const* data, size_t size, void* memctx )\n    {\n    if( size != 128 ) return NULL;\n    char const* ptr = (char const*) data;\n    if( strncmp( ptr, \"TAG\", 3 ) != 0 ) return NULL;\n    ptr += 3;\n\n    id3tag_internal_t* tag = (id3tag_internal_t*) ID3TAG_MALLOC( memctx, sizeof( id3tag_internal_t ) + size );\n    memset( tag, 0, sizeof( id3tag_internal_t ) );\n    memcpy( tag + 1, data, size );\n    tag->memctx = memctx;\n\n    tag->tag.title = (char*) ID3TAG_MALLOC( memctx, 31 );\n    strncpy( (char*) tag->tag.title, ptr, 30 );\n    ( (char*) tag->tag.title )[ 30 ] = '\\0';\n    ptr += 30;\n\n    tag->tag.artist = (char*) ID3TAG_MALLOC( memctx, 31 );\n    strncpy( (char*) tag->tag.artist, ptr, 30 );\n    ( (char*) tag->tag.artist )[ 30 ] = '\\0';\n    ptr += 30;\n\n    tag->tag.album = (char*) ID3TAG_MALLOC( memctx, 31 );\n    strncpy( (char*) tag->tag.album, ptr, 30 );\n    ( (char*) tag->tag.album )[ 30 ] = '\\0';\n    ptr += 30;\n\n    tag->tag.year = (char*) ID3TAG_MALLOC( memctx, 5 );    \n    strncpy( (char*) tag->tag.year, ptr, 4 );\n    ( (char*) tag->tag.year)[ 4 ] = '\\0';\n    ptr += 4;\n\n    char const* comment = ptr;\n    if( comment[ 28 ] == 0 && (int)(ID3TAG_U8)( ptr[ 29 ] ) > 0 )\n        {\n        tag->tag.track = (char*) ID3TAG_MALLOC( memctx, 30 );    \n        sprintf( (char*) tag->tag.track, \"%d\", (int)(ID3TAG_U8)( ptr[ 29 ] ) );\n        }\n    ptr += 30;\n\n    int genre = (int)(ID3TAG_U8)( *ptr );\n    if( genre != 255 )\n        {\n        tag->tag.genre = (char*) ID3TAG_MALLOC( memctx, 30 );    \n        sprintf( (char*) tag->tag.genre, \"(%d)\", genre );\n        }\n\n    return (id3tag_t*) tag;\n    }\n\n\nid3tag_t* id3tag_load( void const* data, size_t size, ID3TAG_U32 fields, void* memctx )\n    {\n    enum fields_t\n        {\n        FIELD_TITLE,\n        FIELD_ARTIST,\n        FIELD_ALBUM_ARTIST,\n        FIELD_ALBUM,\n        FIELD_SORT_TITLE,\n        FIELD_SORT_ARTIST,\n        FIELD_SORT_ALBUM_ARTIST,\n        FIELD_SORT_ALBUM,\n        FIELD_GENRE,\n        FIELD_YEAR,\n        FIELD_TRACK,\n        FIELD_TRACKS,\n        FIELD_DISC,\n        FIELD_DISCS,\n        FIELD_COMPILATION,\n        FIELD_PLAY_COUNTER,\n        FIELD_TRACK_LENGTH,\n\n        FIELDCOUNT,\n        };\n    bool fields_found[ FIELDCOUNT ] = { false };\n\n    int fields_requested = 0;\n    if( fields & ID3TAG_FIELD_TITLE ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_ARTIST ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_ALBUM_ARTIST ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_ALBUM ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_SORT_TITLE ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_SORT_ARTIST ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_SORT_ALBUM_ARTIST ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_SORT_ALBUM ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_GENRE ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_YEAR ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_TRACK ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_TRACKS ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_DISC ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_DISCS ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_COMPILATION ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_PLAY_COUNTER ) ++fields_requested;\n    if( fields & ID3TAG_FIELD_TRACK_LENGTH ) ++fields_requested;\n\n    ID3TAG_U8* ptr = (ID3TAG_U8*) data;\n\n    // validate data\n    if( size < 10 ) return NULL; // Not a valid ID3\n    size_t tag_size = id3tag_size( data );\n    if( tag_size == 0 ) return NULL; // Not a valid ID3\n    if( size < tag_size ) return NULL; // Not enough data\n\n    id3tag_internal_t* tag = (id3tag_internal_t*) ID3TAG_MALLOC( memctx, sizeof( id3tag_internal_t ) + size );\n    memset( tag, 0, sizeof( id3tag_internal_t ) );\n    memcpy( tag + 1, data, size );\n    tag->memctx = memctx;\n\n    ptr += 3; // skip past \"ID3\" marker\n    \n    // read version and flags\n    int version = *ptr++;\n    int revision = *ptr++; (void) revision;\n    ID3TAG_U8 header_flags = *ptr++;\n    (void) header_flags; // TODO: inspect flags\n\n    ptr += 4; // skip past size field\n\n    ID3TAG_U8* end = ( (ID3TAG_U8*) data ) + tag_size;\n    \n    while( ptr <= ( end - 10 ) )\n        {        \n        if( ( fields & ID3TAG_FIELD_PICS ) == 0 )\n            {\n            int fields_found_count = 0;\n            for( int i = 0; i < FIELDCOUNT; ++i ) if( fields_found[ i ] ) ++fields_found_count;\n            if( fields_found_count == fields_requested ) break;\n            }\n\n        if( version >= 3 && ptr[ 0 ] == 0 && ptr[ 1 ] == 0 && ptr[ 2 ] == 0 && ptr[ 3 ] == 0 ) break; // end of frames (in padding)\n        if( version < 3 && ptr[ 0 ] == 0 && ptr[ 1 ] == 0 && ptr[ 2 ] == 0 ) break; // end of frames (in padding)\n\n        char frame_id[ 5 ]= { (char) *ptr++, (char) *ptr++, (char) *ptr++, '\\0', '\\0' };\n        if( version >= 3 ) frame_id[ 3 ] = (char) *ptr++;\n        int frame_size = 0;\n        if( version >= 4 )\n            for( int i = 3; i >= 0 ; --i ) frame_size |= ( (ID3TAG_U32) ( ( *ptr++ )  ) ) << ( 7 *  i );    \n        else if( version >= 3 )\n            for( int i = 3; i >= 0 ; --i ) frame_size |= ( (ID3TAG_U32) ( ( *ptr++ )  ) ) << ( 8 *  i );    \n        else\n            for( int i = 2; i >= 0 ; --i ) frame_size |= ( (ID3TAG_U32) ( ( *ptr++ )  ) ) << ( 8 *  i );    \n        if( frame_size <= 0 ) break; // end of frames\n        if( frame_size >= ( end - ptr )  ) break; // invalid frame\n        ID3TAG_U16 flags = 0;\n        if( version >= 3 ) flags = (ID3TAG_U16)( ( ( (ID3TAG_U16)( *ptr++ ) ) << 8 ) | ( *ptr++ ) );\n       \n\n        if( ( fields & ID3TAG_FIELD_TITLE ) && ( strcmp( frame_id , \"TIT2\" ) == 0 || strcmp( frame_id , \"TT2\" ) == 0 ) )\n            {\n            if( !tag->tag.title ) tag->tag.title = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_TITLE ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_ARTIST ) && ( strcmp( frame_id , \"TPE1\" ) == 0 || strcmp( frame_id , \"TP1\" ) == 0 ) )\n            {\n            if( !tag->tag.artist ) tag->tag.artist = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_ARTIST ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_ALBUM_ARTIST) && ( strcmp( frame_id , \"TPE2\" ) == 0 || strcmp( frame_id , \"TP2\" ) == 0 ) )\n            {\n            if( !tag->tag.album_artist ) tag->tag.album_artist = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_ALBUM_ARTIST ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_ALBUM ) && ( strcmp( frame_id , \"TALB\" ) == 0 || strcmp( frame_id , \"TAL\" ) == 0 ) )\n            {\n            if( !tag->tag.album ) tag->tag.album = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_ALBUM ] = true;\n            }\n       \n        if( ( fields & ID3TAG_FIELD_GENRE ) && ( strcmp( frame_id , \"TCON\" ) == 0 || strcmp( frame_id , \"TCO\" ) == 0 ) )\n            {\n            if( !tag->tag.genre ) tag->tag.genre = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_GENRE ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_YEAR ) && ( strcmp( frame_id , \"TYER\" ) == 0 || strcmp( frame_id , \"TYE\" ) == 0 ) )\n            {\n            if( !tag->tag.year ) tag->tag.year = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_YEAR ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_COMPILATION ) && ( strcmp( frame_id , \"TCMP\" ) == 0 || strcmp( frame_id , \"TCP\" ) == 0 ) )\n            {\n            if( !tag->tag.compilation ) tag->tag.compilation = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_COMPILATION ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_SORT_TITLE ) && ( strcmp( frame_id , \"TSOT\" ) == 0 || strcmp( frame_id , \"TST\" ) == 0 ) )\n            {\n            if( !tag->tag.sort_title ) tag->tag.sort_title = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_SORT_TITLE ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_SORT_ARTIST ) && ( strcmp( frame_id , \"TSOP\" ) == 0 || strcmp( frame_id , \"TSP\" ) == 0 ) )\n            {\n            if( !tag->tag.sort_artist ) tag->tag.sort_artist = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_SORT_ARTIST ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_SORT_ALBUM ) && ( strcmp( frame_id , \"TSOA\" ) == 0 || strcmp( frame_id , \"TSA\" ) == 0 ) )\n            {\n            if( !tag->tag.sort_album ) tag->tag.sort_album = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_SORT_ALBUM ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_SORT_ALBUM_ARTIST ) && ( strcmp( frame_id , \"TSO2\" ) == 0 || strcmp( frame_id , \"TS2\" ) == 0 ) )\n            {\n            if( !tag->tag.sort_album_artist ) tag->tag.sort_album_artist = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            fields_found[ FIELD_SORT_ALBUM_ARTIST ] = true;\n            }\n\n        if( ( fields & ID3TAG_FIELD_TRACK_LENGTH ) && ( strcmp( frame_id , \"TLEN\" ) == 0 || strcmp( frame_id , \"TLE\" ) == 0 ) )\n            {\n            char* str = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            if( tag->tag.track_length == 0 ) tag->tag.track_length = atoi( str );\n            ID3TAG_FREE( memctx, str );\n            if( tag->tag.track_length > 0 ) fields_found[ FIELD_TRACK_LENGTH ] = true;\n            }\n\n        if( ( ( fields & ID3TAG_FIELD_TRACK ) || ( fields & ID3TAG_FIELD_TRACKS ) ) && \n             ( strcmp( frame_id , \"TRCK\" ) == 0 || strcmp( frame_id , \"TRK\" ) == 0 ) )\n            {\n            char* first_str = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            char* separator = strchr( first_str, '/' );\n            if( separator ) *separator = '\\0';\n            char* second_str = separator ? ( separator + 1 ) : NULL;\n            \n            int first = atoi( first_str );\n            int second = second_str ? atoi( second_str ) : 0;\n            ID3TAG_FREE( memctx, first_str );\n\n            char buf[ 64 ];\n\n            if( first > 0 )\n                {\n                sprintf( buf, \"%d\", first );\n                if( strlen( buf ) > 0 && !tag->tag.track )\n                    {\n                    tag->tag.track = (char*) ID3TAG_MALLOC( memctx, strlen( buf ) + 1 );\n                    strcpy( (char*) tag->tag.track, buf );\n                    fields_found[ FIELD_TRACK ] = true;\n                    }\n                }\n\n            if( second > 0 )\n                {\n                sprintf( buf, \"%d\", second );\n                if( strlen( buf ) > 0 && !tag->tag.tracks )\n                    {\n                    tag->tag.tracks = (char*) ID3TAG_MALLOC( memctx, strlen( buf ) + 1 );\n                    strcpy( (char*) tag->tag.tracks, buf );\n                    fields_found[ FIELD_TRACKS ] = true;\n                    }\n                }            \n            }\n\n        if( ( ( fields & ID3TAG_FIELD_DISC ) || ( fields & ID3TAG_FIELD_DISCS ) ) && \n             ( strcmp( frame_id , \"TPOS\" ) == 0 || strcmp( frame_id , \"TPA\" ) == 0 ) )\n            {\n            char* first_str = id3tag_internal_get_string( *ptr, ptr + 1, frame_size - 1, memctx, NULL );\n            char* separator = strchr( first_str, '/' );\n            if( separator ) *separator = '\\0';\n            char* second_str = separator ? ( separator + 1 ) : NULL;\n            \n            int first = atoi( first_str );\n            int second = second_str ? atoi( second_str ) : 0;\n            ID3TAG_FREE( memctx, first_str );\n\n            char buf[ 64 ];\n\n            if( first > 0 )\n                {\n                sprintf( buf, \"%d\", first );\n                if( strlen( buf ) > 0 && !tag->tag.disc )\n                    {\n                    tag->tag.disc = (char*) ID3TAG_MALLOC( memctx, strlen( buf ) + 1 );\n                    strcpy( (char*) tag->tag.disc, buf );\n                    fields_found[ FIELD_DISC ] = true;\n                    }\n                }\n\n            if( second > 0 )\n                {\n                sprintf( buf, \"%d\", second );\n                if( strlen( buf ) > 0 && !tag->tag.discs )\n                    {\n                    tag->tag.discs = (char*) ID3TAG_MALLOC( memctx, strlen( buf ) + 1 );\n                    strcpy( (char*) tag->tag.discs, buf );\n                    fields_found[ FIELD_DISCS ] = true;\n                    }\n                }            \n            }\n\n\n        if( ( fields & ID3TAG_FIELD_PICS ) && ( strcmp( frame_id , \"APIC\" ) == 0 || strcmp( frame_id , \"PIC\" ) == 0 ) )\n            {\n            if( !tag->tag.pics )\n                {\n                tag->pics_capacity = 16;\n                tag->tag.pics = (id3tag_pic_t*) ID3TAG_MALLOC( memctx, sizeof( id3tag_pic_t ) * tag->pics_capacity );\n                tag->tag.pics_count = 0;\n                }\n            if( tag->tag.pics_count >= tag->pics_capacity )\n                {\n                tag->pics_capacity *= 2;\n                id3tag_pic_t* new_pics = (id3tag_pic_t*) ID3TAG_MALLOC( memctx, sizeof( id3tag_pic_t ) * tag->pics_capacity );\n                memcpy( new_pics, tag->tag.pics, sizeof( id3tag_pic_t ) * tag->tag.pics_count );\n                ID3TAG_FREE( memctx, (id3tag_pic_t*)tag->tag.pics );\n                tag->tag.pics = new_pics;\n                }\n\n            int encoding = *ptr++;\n            --frame_size;\n\n            id3tag_pic_t* pic = (id3tag_pic_t*) &tag->tag.pics[ tag->tag.pics_count++ ];\n            memset( pic, 0, sizeof( *pic ) );\n\n            if( version < 3 )\n                {\n                char str[ 4 ] = { (char) *ptr++, (char) *ptr++, (char) *ptr++, '\\0' };\n                frame_size -= 3;\n\n                pic->mime_type = (char*) ID3TAG_MALLOC( memctx, 32 );\n                if( strcmp( str, \"JPG\" ) == 0 ) \n                    strcpy( (char*) pic->mime_type, \"image/jpeg\" );\n                else if( strcmp( str, \"PNG\" ) == 0 ) \n                    strcpy( (char*) pic->mime_type, \"image/png\" );\n                else if( strcmp( str, \"GIF\" ) == 0 ) \n                    strcpy( (char*) pic->mime_type, \"image/gif\" );\n                else if( strcmp( str, \"BMP\" ) == 0 ) \n                    strcpy( (char*) pic->mime_type, \"image/bmp\" );\n                else\n                    strcpy( (char*) pic->mime_type, str );                \n                }\n            else\n                {\n                int bytes = 0;\n                pic->mime_type = id3tag_internal_get_string( encoding, ptr, frame_size, memctx, &bytes );\n                ptr += bytes;\n                frame_size -= bytes;\n                }\n\n            pic->pic_type = *ptr++;\n            --frame_size;\n\n            if( pic->pic_type != 0 )\n                ptr = ptr;\n\n            int bytes = 0;\n            pic->description = id3tag_internal_get_string( encoding, ptr, frame_size, memctx, &bytes );\n            ptr += bytes;\n            frame_size -= bytes;\n\n            if( frame_size )\n                {\n                pic->data = ID3TAG_MALLOC( memctx, (size_t) frame_size );\n                memcpy( (void*) pic->data, ptr, (size_t) frame_size );\n                pic->size = (size_t) frame_size;\n                }\n            else\n                {\n                if( pic->mime_type ) ID3TAG_FREE( memctx, (char*) pic->mime_type );\n                if( pic->description ) ID3TAG_FREE( memctx, (char*) pic->description );\n                --tag->tag.pics_count;\n                }\n            }\n\n        ptr += frame_size;\n        }\n\n    return (id3tag_t*) tag;\n    }\n\n\nvoid id3tag_free( id3tag_t* id3tag )\n    {\n    id3tag_internal_t* internal = (id3tag_internal_t*) id3tag;\n\n    if( internal->tag.title) ID3TAG_FREE( internal->memctx, (char*) internal->tag.title );\n    if( internal->tag.artist ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.artist );\n    if( internal->tag.album_artist ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.album_artist );\n    if( internal->tag.album ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.album );\n    if( internal->tag.sort_title) ID3TAG_FREE( internal->memctx, (char*) internal->tag.sort_title );\n    if( internal->tag.sort_artist ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.sort_artist );\n    if( internal->tag.sort_album_artist ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.sort_album_artist );\n    if( internal->tag.sort_album ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.sort_album );\n    if( internal->tag.genre ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.genre );\n    if( internal->tag.year ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.year );\n    if( internal->tag.track ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.track );\n    if( internal->tag.tracks ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.tracks );\n    if( internal->tag.disc ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.disc );\n    if( internal->tag.discs ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.discs );\n    if( internal->tag.compilation ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.compilation );\n\n    if( internal->tag.pics )\n        {\n        for( int i = 0; i < internal->tag.pics_count; ++i )\n            {\n            if( internal->tag.pics[ i ].description ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.pics[ i ].description );\n            if( internal->tag.pics[ i ].mime_type ) ID3TAG_FREE( internal->memctx, (char*) internal->tag.pics[ i ].mime_type );\n            if( internal->tag.pics[ i ].data ) ID3TAG_FREE( internal->memctx, (void*) internal->tag.pics[ i ].data );\n            }\n\n        if( internal->tag.pics ) ID3TAG_FREE( internal->memctx, (id3tag_pic_t*) internal->tag.pics );\n        }\n\n    ID3TAG_FREE( internal->memctx, id3tag );\n    }\n\n\nsize_t id3tag_save( id3tag_t const* id3tag, ID3TAG_U32 fields, void const* data, size_t capacity )\n    {\n    (void) id3tag, fields, data, capacity;\n    return 0;\n    }\n\n\n#endif /* ID3TAG_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2018 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/"
        },
        {
          "name": "img.h",
          "type": "blob",
          "size": 12.5966796875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nimg.h - v0.1 - Image processing functions for C/C++.\n\nDo this:\n    #define IMG_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef img_h\n#define img_h\n\n#ifndef IMG_U32\n    #define IMG_U32  unsigned int\n#endif\n\n\ntypedef struct img_rgba_t {\n    float r;\n    float g;\n    float b;\n    float a;\n} img_rgba_t;\n\ntypedef struct img_t {\n    int width;\n    int height;\n    img_rgba_t* pixels;\n} img_t;\n\ntypedef struct img_hsva_t {\n    float h;\n    float s;\n    float v;\n    float a;\n} img_hsva_t;\n\nimg_t img_create( int width, int height );\nimg_t img_from_abgr32( IMG_U32* abgr, int width, int height );\nvoid img_free( img_t* img );\n\nvoid img_to_argb32( img_t* img, IMG_U32* abgr );\nimg_rgba_t img_sample_clamp( img_t* img, float u, float v );\n\nimg_rgba_t img_rgba_lerp( img_rgba_t a, img_rgba_t b, float s );\nimg_hsva_t img_rgba_to_hsva( img_rgba_t rgb );\nimg_rgba_t img_hsva_to_rgba( img_hsva_t hsv );\n\nvoid img_adjust_brightness( img_t* img, float value );\nvoid img_adjust_contrast( img_t* img, float value );\nvoid img_adjust_saturation( img_t* img, float value );\nvoid img_sharpen( img_t* img, float radius, float blend );\n\n\n#endif /* img_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef IMG_IMPLEMENTATION\n#undef IMG_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdlib.h>\n\n\n#if !defined( IMG_POW ) || !defined( IMG_FLOOR )\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #pragma warning( push )\n    #pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n    #include <math.h>\n    #pragma warning( pop )\n#endif\n\n\n#ifndef IMG_POW\n    #ifdef __TINYC__\n        #define IMG_POW( x, y ) ( (float) pow( (double) x, (double) y ) )\n    #else\n        #define IMG_POW( x, y ) powf( x, y )\n    #endif\n#endif\n\n#ifndef IMG_FLOOR\n    #ifdef __TINYC__\n        #define IMG_FLOOR( x ) ( (float) floor( (double) x ) )\n    #else\n        #define IMG_FLOOR( x ) floorf( x )\n    #endif\n#endif\n\n\nimg_t img_create( int width, int height ) {\n    img_t img;\n    img.width = width;\n    img.height = height;\n    img.pixels = (img_rgba_t*) malloc( sizeof( img_rgba_t ) * width * height );\n    memset( img.pixels, 0, sizeof( img_rgba_t ) * width * height );\n    return img;\n}\n\n\nimg_t img_from_abgr32( IMG_U32* abgr, int width, int height ) {\n    img_t img;\n    img.width = width;\n    img.height = height;\n    img.pixels = (img_rgba_t*) malloc( sizeof( img_rgba_t ) * width * height );\n    for( int i = 0; i < width * height; ++i ) {\n        IMG_U32 p = abgr[ i ];\n        IMG_U32 b = ( p       ) & 0xff;\n        IMG_U32 g = ( p >>  8 ) & 0xff;\n        IMG_U32 r = ( p >> 16 ) & 0xff;\n        IMG_U32 a = ( p >> 24 ) & 0xff;\n        img_rgba_t* f = &img.pixels[ i ];\n        f->r = ( (float) r ) / 255.0f;\n        f->g = ( (float) g ) / 255.0f;\n        f->b = ( (float) b ) / 255.0f;\n        f->a = ( (float) a ) / 255.0f;\n    }\n    return img;\n}\n\n\nvoid img_free( img_t* img ) {\n    free( img->pixels );\n    img->pixels = NULL;\n}\n\n\nfloat img_clamp( float x, float low, float high ) {\n    return x < low ? low : x > high ? high : x;\n}\n\n\nvoid img_to_argb32( img_t* img, IMG_U32* abgr ) {\n    for( int i = 0; i < img->width * img->height; ++i ) {\n        img_rgba_t p = img->pixels[ i ];\n        p.r = img_clamp( p.r, 0.0f, 1.0f );\n        p.g = img_clamp( p.g, 0.0f, 1.0f );\n        p.b = img_clamp( p.b, 0.0f, 1.0f );\n        p.a = img_clamp( p.a, 0.0f, 1.0f );\n        IMG_U32 r = (IMG_U32)( p.r * 256.0f );\n        IMG_U32 g = (IMG_U32)( p.g * 256.0f );\n        IMG_U32 b = (IMG_U32)( p.b * 256.0f );\n        IMG_U32 a = (IMG_U32)( p.a * 256.0f );\n        r = r > 255 ? 255 : r;\n        g = g > 255 ? 255 : g;\n        b = b > 255 ? 255 : b;\n        a = a > 255 ? 255 : a;\n        abgr[ i ] = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );\n    }\n}\n\n\n\nimg_rgba_t img_rgba_lerp( img_rgba_t a, img_rgba_t b, float s ) {\n    img_rgba_t c;\n    c.r = a.r + ( b.r - a.r ) * s;\n    c.g = a.g + ( b.g - a.g ) * s;\n    c.b = a.b + ( b.b - a.b ) * s;\n    c.a = a.a + ( b.a - a.a ) * s;\n    return c;\n}\n\n\nimg_rgba_t img_sample_clamp( img_t* img, float u, float v ) {\n    int maxw = ( img->width - 1 );\n    int maxh = ( img->height - 1 );\n\n    float fu = IMG_FLOOR( u );\n    float du = u - fu;\n    float fv = IMG_FLOOR( v );\n    float dv = v - fv;\n\n    int x1 = (int) ( fu );\n    int y1 = (int) ( fv );\n    int x2 = (int) ( fu + 1.0f );\n    int y2 = (int) ( fv + 1.0f );\n\n    x1 = x1 < 0 ? 0 : x1 > maxw ? maxw : x1;\n    x2 = x2 < 0 ? 0 : x2 > maxw ? maxw : x2;\n    y1 = y1 < 0 ? 0 : y1 > maxh ? maxh : y1;\n    y2 = y2 < 0 ? 0 : y2 > maxh ? maxh : y2;\n\n    img_rgba_t c1 = img->pixels[ x1 + y1 * img->width ];\n    img_rgba_t c2 = img->pixels[ x2 + y1 * img->width ];\n    img_rgba_t c3 = img->pixels[ x1 + y2 * img->width ];\n    img_rgba_t c4 = img->pixels[ x2 + y2 * img->width ];\n\n    return img_rgba_lerp( img_rgba_lerp( c1, c2, du ), img_rgba_lerp( c3, c4, du ), dv );\n}\n\n\nvoid img_adjust_brightness( img_t* img, float value ) {\n    if( value == 0.0f ) return;\n    for( int i = 0; i < img->width * img->height; ++i ) {\n        img_rgba_t* p = &img->pixels[ i ];\n        p->r = p->r + value;\n        p->g = p->g + value;\n        p->b = p->b + value;\n    }\n}\n\nvoid img_adjust_contrast( img_t* img, float value ) {\n    if( value == 0.0f ) return;\n    for( int i = 0; i < img->width * img->height; ++i ) {\n        img_rgba_t* p = &img->pixels[ i ];\n        p->r = ( p->r - 0.5f ) * value + 0.5f;\n        p->g = ( p->g - 0.5f ) * value + 0.5f;\n        p->b = ( p->b - 0.5f ) * value + 0.5f;\n    }\n}\n\n#define img_min( x, y ) ( (x) < (y) ? (x) : (y) )\n#define img_max( x, y ) ( (x) > (y) ? (x) : (y) )\n\nimg_hsva_t img_rgba_to_hsva( img_rgba_t rgb ) {\n    img_hsva_t hsv;\n    hsv.a = rgb.a;\n\n    float cmin = img_min( rgb.r, img_min( rgb.g, rgb.b ) ); //Min. value of RGB\n    float cmax = img_max( rgb.r, img_max( rgb.g, rgb.b ) ); //Max. value of RGB\n    float cdel = cmax - cmin;   //Delta RGB value\n\n    hsv.v = cmax;\n\n    if( cdel == 0 ) { //This is a gray, no chroma...\n        hsv.h = 0;  //HSV results from 0 to 1\n        hsv.s = 0;\n    } else { //Chromatic data...\n        hsv.s = cdel / cmax;\n\n        float rdel = ( ( ( cmax - rgb.r ) / 6.0f ) + ( cdel / 2.0f ) ) / cdel;\n        float gdel = ( ( ( cmax - rgb.g ) / 6.0f ) + ( cdel / 2.0f ) ) / cdel;\n        float bdel = ( ( ( cmax - rgb.b ) / 6.0f ) + ( cdel / 2.0f ) ) / cdel;\n\n        if( rgb.r == cmax ) {\n            hsv.h = bdel - gdel;\n        } else if( rgb.g == cmax ) {\n            hsv.h = ( 1.0f / 3.0f ) + rdel - bdel;\n        } else {\n            hsv.h = ( 2.0f / 3.0f ) + gdel - rdel;\n        }\n\n        if ( hsv.h < 0.0f ) {\n            hsv.h += 1.0f;\n        }\n        if ( hsv.h > 1.0f ) {\n            hsv.h -= 1.0f;\n        }\n    }\n\n    hsv.h = hsv.h;\n    hsv.s = hsv.s;\n    hsv.v = hsv.v;\n    return hsv;\n}\n\n\nimg_rgba_t img_hsva_to_rgba( img_hsva_t hsv ) {\n    img_rgba_t rgb;\n    rgb.a = hsv.a;\n\n    if( hsv.s == 0.0f ) { // HSV from 0 to 1\n        rgb.r = hsv.v;\n        rgb.g = hsv.v;\n        rgb.b = hsv.v;\n    } else {\n        float h = hsv.h * 6.0f;\n        if( h == 6.0f ) {\n            h = 0.0f;   //H must be < 1\n        }\n        float i = IMG_FLOOR( h );\n        float v1 = hsv.v * ( 1.0f - hsv.s );\n        float v2 = hsv.v * ( 1.0f - hsv.s * ( h - i ) );\n        float v3 = hsv.v * ( 1.0f - hsv.s * ( 1.0f - ( h - i ) ) );\n\n        switch( (int) i ) {\n            case 0: { rgb.r = hsv.v; rgb.g = v3   ; rgb.b = v1   ; } break;\n            case 1: { rgb.r = v2   ; rgb.g = hsv.v; rgb.b = v1   ; } break;\n            case 2: { rgb.r = v1   ; rgb.g = hsv.v; rgb.b = v3   ; } break;\n            case 3: { rgb.r = v1   ; rgb.g = v2   ; rgb.b = hsv.v; } break;\n            case 4: { rgb.r = v3   ; rgb.g = v1   ; rgb.b = hsv.v; } break;\n            default:{ rgb.r = hsv.v; rgb.g = v1   ; rgb.b = v2   ; } break;\n        }\n    }\n\n    rgb.r = rgb.r;\n    rgb.g = rgb.g;\n    rgb.b = rgb.b;\n    return rgb;\n}\n\n\nvoid img_adjust_saturation( img_t* img, float value ) {\n    if( value == 0.0f ) return;\n    for( int i = 0; i < img->width * img->height; ++i ) {\n        img_rgba_t* p = &img->pixels[ i ];\n        img_hsva_t hsv = img_rgba_to_hsva( *p );\n        hsv.s = img_clamp( hsv.s + value, 0.0f, 1.0f );\n        *p = img_hsva_to_rgba( hsv );\n    }\n}\n\n\nvoid img_sharpen( img_t* img, float radius, float blend ) {\n    float filter[ 9 ] = {\n        -1.0f, -1.0f, -1.0f,\n        -1.0f,  9.0f, -1.0f,\n        -1.0f, -1.0f, -1.0f,\n    };\n\n    img_rgba_t* result = (img_rgba_t*) malloc( img->width * img->height * sizeof( img_rgba_t ) );\n\n    img_rgba_t* src = img->pixels;\n    img_rgba_t* dst = result;\n    for( int y = 0; y < img->height; ++y ) {\n        for( int x = 0; x < img->width; ++x ) {\n            if( src->a > 0.0f ) {\n                img_rgba_t acc = { 0.0f, 0.0f, 0.0f, 0.0f };\n                for( int fx = -1; fx <= 1; ++fx ) {\n                    for( int fy = -1; fy <= 1; ++fy ) {\n                        float u = ( (float) x ) + ( (float) fx ) * radius;\n                        float v = ( (float) y ) + ( (float) fy ) * radius;\n                        img_rgba_t s = img_sample_clamp( img, u, v );\n                        if( s.a < 0.0001f ) {\n                            s = *src;\n                        }\n                        acc.r += s.r * ( filter[ ( 1 + fx ) + ( 1 + fy ) * 3 ] );\n                        acc.g += s.g * ( filter[ ( 1 + fx ) + ( 1 + fy ) * 3 ] );\n                        acc.b += s.b * ( filter[ ( 1 + fx ) + ( 1 + fy ) * 3 ] );\n                    }\n                }\n                *dst = img_rgba_lerp( *src, acc, blend );\n                dst->a = src->a;\n            } else {\n                *dst = *src;\n            }\n            ++src;\n            ++dst;\n        }\n    }\n\n    free( img->pixels );\n    img->pixels = result;\n}\n\n#endif /* IMG_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2019 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "ini.h",
          "type": "blob",
          "size": 38.3798828125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nini.h - v1.2 - Simple ini-file reader for C/C++.\n\nDo this:\n    #define INI_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef ini_h\n#define ini_h\n\n#define INI_GLOBAL_SECTION ( 0 )\n#define INI_NOT_FOUND ( -1 )\n\ntypedef struct ini_t ini_t;\n\nini_t* ini_create( void* memctx );\nini_t* ini_load( char const* data, void* memctx );\n\nint ini_save( ini_t const* ini, char* data, int size );\nvoid ini_destroy( ini_t* ini );\n\nint ini_section_count( ini_t const* ini );\nchar const* ini_section_name( ini_t const* ini, int section );\n\nint ini_property_count( ini_t const* ini, int section );\nchar const* ini_property_name( ini_t const* ini, int section, int property );\nchar const* ini_property_value( ini_t const* ini, int section, int property );\n\nint ini_find_section( ini_t const* ini, char const* name, int name_length );\nint ini_find_property( ini_t const* ini, int section, char const* name, int name_length );\n\nint ini_section_add( ini_t* ini, char const* name, int length );\nvoid ini_property_add( ini_t* ini, int section, char const* name, int name_length, char const* value, int value_length );\nvoid ini_section_remove( ini_t* ini, int section );\nvoid ini_property_remove( ini_t* ini, int section, int property );\n\nvoid ini_section_name_set( ini_t* ini, int section, char const* name, int length );\nvoid ini_property_name_set( ini_t* ini, int section, int property, char const* name, int length );\nvoid ini_property_value_set( ini_t* ini, int section, int property, char const* value, int length  );\n\n#endif /* ini_h */\n\n\n/**\n\nini.h \n=====\n\nSimple ini-file reader for C/C++.\n\n\nExamples\n--------\n\n#### Loading an ini file and retrieving values\n\n    #define INI_IMPLEMENTATION\n    #include \"ini.h\"\n\n    #include <stdio.h>\n    #include <stdlib.h>\n\n    int main()\n        {\n        FILE* fp = fopen( \"test.ini\", \"r\" );\n        fseek( fp, 0, SEEK_END );\n        int size = ftell( fp );\n        fseek( fp, 0, SEEK_SET );\n        char* data = (char*) malloc( size + 1 );\n        fread( data, 1, size, fp );\n        data[ size ] = '\\0';\n        fclose( fp );\n\n        ini_t* ini = ini_load( data, NULL );\n        free( data );\n        int second_index = ini_find_property( ini, INI_GLOBAL_SECTION, \"SecondSetting\", 0 );\n        char const* second = ini_property_value( ini, INI_GLOBAL_SECTION, second_index );\n        printf( \"%s=%s\\n\", \"SecondSetting\", second );\n        int section = ini_find_section( ini, \"MySection\", 0 );\n        int third_index = ini_find_property( ini, section, \"ThirdSetting\", 0 );\n        char const* third = ini_property_value( ini, section, third_index );\n        printf( \"%s=%s\\n\", \"ThirdSetting\", third );\n        ini_destroy( ini );\n\n        return 0;\n        }\n\n-----------------------------------------------------------------------------------------------\n\n#### Creating a new ini file\n\n    #define INI_IMPLEMENTATION\n    #include \"ini.h\"\n\n    #include <stdio.h>\n    #include <stdlib.h>\n\n    int main()\n        {       \n        ini_t* ini = ini_create( NULL );\n        ini_property_add( ini, INI_GLOBAL_SECTION, \"FirstSetting\", 0, \"Test\", 0 );\n        ini_property_add( ini, INI_GLOBAL_SECTION, \"SecondSetting\", 0, \"2\", 0 );\n        int section = ini_section_add( ini, \"MySection\", 0 );\n        ini_property_add( ini, section, \"ThirdSetting\", 0, \"Three\", 0 );\n\n        int size = ini_save( ini, NULL, 0 ); // Find the size needed\n        char* data = (char*) malloc( size );\n        size = ini_save( ini, data, size ); // Actually save the file\n        ini_destroy( ini );\n\n        FILE* fp = fopen( \"test.ini\", \"w\" );\n        fwrite( data, 1, size - 1, fp );\n        fclose( fp );\n        free( data );\n\n        return 0;\n        }\n\n\n\nAPI Documentation\n-----------------\n\nini.h is a small library for reading classic .ini files. It is a single-header library, and does not need any .lib files \nor other binaries, or any build scripts. To use it, you just include ini.h to get the API declarations. To get the \ndefinitions, you must include ini.h from *one* single C or C++ file, and #define the symbol `INI_IMPLEMENTATION` before \nyou do. \n\n\n### Customization\n\nThere are a few different things in ini.h which are configurable by #defines. The customizations only affect the \nimplementation, so will only need to be defined in the file where you have the #define INI_IMPLEMENTATION.\n\nNote that if all customizations are utilized, ini.h will include no external files whatsoever, which might be useful\nif you need full control over what code is being built.\n\n\n#### Custom memory allocators\n\nTo store the internal data structures, ini.h needs to do dynamic allocation by calling `malloc`. Programs might want to \nkeep track of allocations done, or use custom defined pools to allocate memory from. ini.h allows for specifying custom \nmemory allocation functions for `malloc` and `free`.\nThis is done with the following code:\n\n    #define INI_IMPLEMENTATION\n    #define INI_MALLOC( ctx, size ) ( my_custom_malloc( ctx, size ) )\n    #define INI_FREE( ctx, ptr ) ( my_custom_free( ctx, ptr ) )\n    #include \"ini.h\"\n\nwhere `my_custom_malloc` and `my_custom_free` are your own memory allocation/deallocation functions. The `ctx` parameter\nis an optional parameter of type `void*`. When `ini_create` or `ini_load` is called, you can pass in a `memctx` \nparameter, which can be a pointer to anything you like, and which will be passed through as the `ctx` parameter to every \n`INI_MALLOC`/`INI_FREE` call. For example, if you are doing memory tracking, you can pass a pointer to your tracking \ndata as `memctx`, and in your custom allocation/deallocation function, you can cast the `ctx` param back to the \nright type, and access the tracking data.\n\nIf no custom allocator is defined, ini.h will default to `malloc` and `free` from the C runtime library.\n\n\n#### Custom C runtime function\n\nThe library makes use of three additional functions from the C runtime library, and for full flexibility, it allows you \nto substitute them for your own. Here's an example:\n\n    #define INI_IMPLEMENTATION\n    #define INI_MEMCPY( dst, src, cnt ) ( my_memcpy_func( dst, src, cnt ) )\n    #define INI_STRLEN( s ) ( my_strlen_func( s ) )\n    #define INI_STRNICMP( s1, s2, cnt ) ( my_strnicmp_func( s1, s2, cnt ) )\n    #include \"ini.h\"\n\nIf no custom function is defined, ini.h will default to the C runtime library equivalent.\n\n\nini_create\n----------\n    \n    ini_t* ini_create( void* memctx )\n\nInstantiates a new, empty ini structure, which can be manipulated with other API calls, to fill it with data. To save it\nout to an ini-file string, use `ini_save`. When no longer needed, it can be destroyed by calling `ini_destroy`.\n`memctx` is a pointer to user defined data which will be passed through to the custom INI_MALLOC/INI_FREE calls. It can \nbe NULL if no user defined data is needed.\n\n\nini_load\n--------\n\n    ini_t* ini_load( char const* data, void* memctx )\n\nParse the zero-terminated string `data` containing an ini-file, and create a new ini_t instance containing the data. \nThe instance can be manipulated with other API calls to enumerate sections/properties and retrieve values. When no \nlonger needed, it can be destroyed by calling `ini_destroy`. `memctx` is a pointer to user defined data which will be \npassed through to the custom INI_MALLOC/INI_FREE calls. It can be NULL if no user defined data is needed.\n\n\nini_save\n--------\n    \n    int ini_save( ini_t const* ini, char* data, int size )\n\nSaves an ini structure as a zero-terminated ini-file string, into the specified buffer. Returns the number of bytes \nwritten, including the zero terminator. If `data` is NULL, nothing is written, but `ini_save` still returns the number\nof bytes it would have written. If the size of `data`, as specified in the `size` parameter, is smaller than that \nrequired, only part of the ini-file string will be written. `ini_save` still returns the number of bytes it would have\nwritten had the buffer been large enough.\n\n\nini_destroy\n-----------\n\n    void ini_destroy( ini_t* ini )\n\nDestroy an `ini_t` instance created by calling `ini_load` or `ini_create`, releasing the memory allocated by it. No\nfurther API calls are valid on an `ini_t` instance after calling `ini_destroy` on it.\n\n\nini_section_count\n-----------------\n\n    int ini_section_count( ini_t const* ini )\n\nReturns the number of sections in an ini file. There's at least one section in an ini file (the global section), but \nthere can be many more, each specified in the file by the section name wrapped in square brackets [ ].\n\n\nini_section_name\n----------------\n\n    char const* ini_section_name( ini_t const* ini, int section )\n\nReturns the name of the section with the specified index. `section` must be non-negative and less than the value \nreturned by `ini_section_count`, or `ini_section_name` will return NULL. The defined constant `INI_GLOBAL_SECTION` can\nbe used to indicate the global section.\n\n\nini_property_count\n------------------\n\n    int ini_property_count( ini_t const* ini, int section )\n\nReturns the number of properties belonging to the section with the specified index. `section` must be non-negative and \nless than the value returned by `ini_section_count`, or `ini_section_name` will return 0. The defined constant \n`INI_GLOBAL_SECTION` can be used to indicate the global section. Properties are declared in the ini-file on he format\n`name=value`.\n\n\nini_property_name\n-----------------\n\n    char const* ini_property_name( ini_t const* ini, int section, int property )\n\nReturns the name of the property with the specified index `property` in the section with the specified index `section`.\n`section` must be non-negative and less than the value returned by `ini_section_count`, and `property` must be \nnon-negative and less than the value returned by `ini_property_count`, or `ini_property_name` will return NULL. The \ndefined constant `INI_GLOBAL_SECTION` can be used to indicate the global section.\n\n\nini_property_value\n------------------\n\n    char const* ini_property_value( ini_t const* ini, int section, int property )\n\nReturns the value of the property with the specified index `property` in the section with the specified index `section`.\n`section` must be non-negative and less than the value returned by `ini_section_count`, and `property` must be \nnon-negative and less than the value returned by `ini_property_count`, or `ini_property_value` will return NULL. The \ndefined constant `INI_GLOBAL_SECTION` can be used to indicate the global section.\n\n\nini_find_section\n----------------\n\n    int ini_find_section( ini_t const* ini, char const* name, int name_length )\n\nFinds the section with the specified name, and returns its index. `name_length` specifies the number of characters in\n`name`, which does not have to be zero-terminated. If `name_length` is zero, the length is determined automatically, but\nin this case `name` has to be zero-terminated. If no section with the specified name could be found, the value\n`INI_NOT_FOUND` is returned.\n\n\nini_find_property\n-----------------\n\n    int ini_find_property( ini_t const* ini, int section, char const* name, int name_length )\n\nFinds the property with the specified name, within the section with the specified index, and returns the index of the \nproperty. `name_length` specifies the number of characters in `name`, which does not have to be zero-terminated. If \n`name_length` is zero, the length is determined automatically, but in this case `name` has to be zero-terminated. If no \nproperty with the specified name could be found within the specified section, the value `INI_NOT_FOUND` is  returned.\n`section` must be non-negative and less than the value returned by `ini_section_count`, or `ini_find_property` will \nreturn `INI_NOT_FOUND`. The defined constant `INI_GLOBAL_SECTION` can be used to indicate the global section.\n\n\nini_section_add\n---------------\n\n    int ini_section_add( ini_t* ini, char const* name, int length )\n\nAdds a section with the specified name, and returns the index it was added at. There is no check done to see if a \nsection with the specified name already exists - multiple sections of the same name are allowed. `length` specifies the \nnumber of characters in `name`, which does not have to be zero-terminated. If `length` is zero, the length is determined \nautomatically, but in this case `name` has to be zero-terminated.\n\n\nini_property_add\n----------------\n    \n    void ini_property_add( ini_t* ini, int section, char const* name, int name_length, char const* value, int value_length )\n\nAdds a property with the specified name and value to the specified section, and returns the index it was added at. There \nis no check done to see if a property with the specified name already exists - multiple properties of the same name are \nallowed. `name_length` and `value_length` specifies the number of characters in `name` and `value`, which does not have \nto be zero-terminated. If `name_length` or `value_length` is zero, the length is determined automatically, but in this \ncase `name`/`value` has to be zero-terminated. `section` must be non-negative and less than the value returned by\n`ini_section_count`, or the property will not be added. The defined constant `INI_GLOBAL_SECTION` can be used to \nindicate the global section.\n\n\nini_section_remove\n------------------\n\n    void ini_section_remove( ini_t* ini, int section )\n\nRemoves the section with the specified index, and all properties within it. `section` must be non-negative and less than \nthe value returned by `ini_section_count`. The defined constant `INI_GLOBAL_SECTION` can be used to indicate the global \nsection. Note that removing a section will shuffle section indices, so that section indices you may have stored will no \nlonger indicate the same section as it did before the remove. Use the find functions to update your indices.\n\n\nini_property_remove\n-------------------\n\n    void ini_property_remove( ini_t* ini, int section, int property )\n\nRemoves the property with the specified index from the specified section. `section` must be non-negative and less than \nthe value returned by `ini_section_count`, and `property` must be non-negative and less than the value returned by \n`ini_property_count`. The defined constant `INI_GLOBAL_SECTION` can be used to indicate the global section. Note that \nremoving a property will shuffle property indices within the specified section, so that property indices you may have \nstored will no longer indicate the same property as it did before the remove. Use the find functions to update your \nindices.\n\n\nini_section_name_set\n--------------------\n\n    void ini_section_name_set( ini_t* ini, int section, char const* name, int length )\n\nChange the name of the section with the specified index. `section` must be non-negative and less than the value returned \nby `ini_section_count`. The defined constant `INI_GLOBAL_SECTION` can be used to indicate the global section. `length` \nspecifies the number of characters in `name`, which does not have to be zero-terminated. If `length` is zero, the length \nis determined automatically, but in this case `name` has to be zero-terminated.\n\n\nini_property_name_set\n---------------------\n\n    void ini_property_name_set( ini_t* ini, int section, int property, char const* name, int length )\n\nChange the name of the property with the specified index in the specified section. `section` must be non-negative and \nless than the value returned by `ini_section_count`, and `property` must be non-negative and less than the value \nreturned by `ini_property_count`. The defined constant `INI_GLOBAL_SECTION` can be used to indicate the global section.\n`length` specifies the number of characters in `name`, which does not have to be zero-terminated. If `length` is zero, \nthe length is determined automatically, but in this case `name` has to be zero-terminated.\n\n\nini_property_value_set\n----------------------\n\n    void ini_property_value_set( ini_t* ini, int section, int property, char const* value, int length  )\n\nChange the value of the property with the specified index in the specified section. `section` must be non-negative and \nless than the value returned by `ini_section_count`, and `property` must be non-negative and less than the value \nreturned by `ini_property_count`. The defined constant `INI_GLOBAL_SECTION` can be used to indicate the global section.\n`length` specifies the number of characters in `value`, which does not have to be zero-terminated. If `length` is zero, \nthe length is determined automatically, but in this case `value` has to be zero-terminated.\n\n*/\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef INI_IMPLEMENTATION\n#undef INI_IMPLEMENTATION\n\n#define INITIAL_CAPACITY ( 256 )\n\n#undef _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_NONSTDC_NO_DEPRECATE \n#undef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#include <stddef.h>\n\n#ifndef INI_MALLOC\n    #include <stdlib.h>\n    #define INI_MALLOC( ctx, size ) ( malloc( size ) )\n    #define INI_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n#ifndef INI_MEMCPY\n    #include <string.h>\n    #define INI_MEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef INI_STRLEN\n    #include <string.h>\n    #define INI_STRLEN( s ) ( strlen( s ) )\n#endif \n\n#ifndef INI_STRNICMP\n    #ifdef _WIN32\n        #include <string.h>\n        #define INI_STRNICMP( s1, s2, cnt ) ( strnicmp( s1, s2, cnt ) )\n    #else                           \n        #include <string.h>         \n        #define INI_STRNICMP( s1, s2, cnt ) ( strncasecmp( s1, s2, cnt ) )        \n    #endif\n#endif \n\n\nstruct ini_internal_section_t\n    {\n    char name[ 32 ];\n    char* name_large;\n    };\n\n\nstruct ini_internal_property_t\n    {\n    int section;\n    char name[ 32 ];\n    char* name_large;\n    char value[ 64 ];\n    char* value_large;\n    };\n\n\nstruct ini_t\n    {\n    struct ini_internal_section_t* sections;\n    int section_capacity;\n    int section_count;\n\n    struct ini_internal_property_t* properties;\n    int property_capacity;\n    int property_count;\n\n    void* memctx;\n    };\n\n\nstatic int ini_internal_property_index( ini_t const* ini, int section, int property )\n    {\n    int i;\n    int p;\n\n    if( ini && section >= 0 && section < ini->section_count )\n        {\n        p = 0;\n        for( i = 0; i < ini->property_count; ++i )\n            {\n            if( ini->properties[ i ].section == section )\n                {\n                if( p == property ) return i;\n                ++p;\n                }\n            }\n        }\n\n    return INI_NOT_FOUND;\n    }\n\n\nini_t* ini_create( void* memctx )\n    {\n    ini_t* ini;\n\n    ini = (ini_t*) INI_MALLOC( memctx, sizeof( ini_t ) );\n    ini->memctx = memctx;\n    ini->sections = (struct ini_internal_section_t*) INI_MALLOC( ini->memctx, INITIAL_CAPACITY * sizeof( ini->sections[ 0 ] ) );\n    ini->section_capacity = INITIAL_CAPACITY;\n    ini->section_count = 1; /* global section */\n    ini->sections[ 0 ].name[ 0 ] = '\\0'; \n    ini->sections[ 0 ].name_large = 0;\n    ini->properties = (struct ini_internal_property_t*) INI_MALLOC( ini->memctx, INITIAL_CAPACITY * sizeof( ini->properties[ 0 ] ) );\n    ini->property_capacity = INITIAL_CAPACITY;\n    ini->property_count = 0;\n    return ini;\n    }\n\n\nini_t* ini_load( char const* data, void* memctx )\n    {\n    ini_t* ini;\n    char const* ptr;\n    int s;\n    char const* start;\n    char const* start2;\n    int l;\n\n    ini = ini_create( memctx );\n\n    ptr = data;\n    if( ptr )\n        {\n        s = 0;\n        while( *ptr )\n            {\n            /* trim leading whitespace */\n            while( *ptr && *ptr <=' ' )\n                ++ptr;\n            \n            /* done? */\n            if( !*ptr ) break;\n\n            /* comment */\n            else if( *ptr == ';' )\n                {\n                while( *ptr && *ptr !='\\n' )\n                    ++ptr;\n                }\n            /* section */\n            else if( *ptr == '[' )\n                {\n                ++ptr;\n                start = ptr;\n                while( *ptr && *ptr !=']' && *ptr != '\\n' )\n                    ++ptr;\n\n                if( *ptr == ']' )\n                    {\n                    s = ini_section_add( ini, start, (int)( ptr - start) );\n                    ++ptr;\n                    }\n                }\n            /* property */\n            else\n                {\n                start = ptr;\n                while( *ptr && *ptr !='=' && *ptr != '\\n' )\n                    ++ptr;\n\n                if( *ptr == '=' )\n                    {\n                    l = (int)( ptr - start);\n                    ++ptr;\n                    while( *ptr && *ptr <= ' ' && *ptr != '\\n' ) \n                        ptr++;\n                    start2 = ptr;\n                    while( *ptr && *ptr != '\\n' )\n                        ++ptr;\n                    while( ptr >= start2 && *(--ptr) <= ' ' ) \n                        (void)ptr;\n                    ptr++;\n                    if( ptr == start2 )\n                        ini_property_add( ini, s, start, l, \"\", 1 );\n                    else\n                        ini_property_add( ini, s, start, l, start2, (int)( ptr - start2 ) );\n                    }\n                }\n            }\n        }   \n\n    return ini;\n    }\n\n\nint ini_save( ini_t const* ini, char* data, int size )\n    {\n    int s;\n    int p;\n    int i;\n    int l;\n    char* n;\n    int pos;\n\n    if( ini )\n        {\n        pos = 0;\n        for( s = 0; s < ini->section_count; ++s )\n            {\n            n = ini->sections[ s ].name_large ? ini->sections[ s ].name_large : ini->sections[ s ].name;\n            l = (int) INI_STRLEN( n );\n            if( l > 0 )\n                {\n                if( data && pos < size ) data[ pos ] = '[';\n                ++pos;\n                for( i = 0; i < l; ++i )\n                    {\n                    if( data && pos < size ) data[ pos ] = n[ i ];\n                    ++pos;\n                    }\n                if( data && pos < size ) data[ pos ] = ']';\n                ++pos;\n                if( data && pos < size ) data[ pos ] = '\\n';\n                ++pos;\n                }\n\n            for( p = 0; p < ini->property_count; ++p )\n                {\n                if( ini->properties[ p ].section == s )\n                    {\n                    n = ini->properties[ p ].name_large ? ini->properties[ p ].name_large : ini->properties[ p ].name;\n                    l = (int) INI_STRLEN( n );\n                    for( i = 0; i < l; ++i )\n                        {\n                        if( data && pos < size ) data[ pos ] = n[ i ];\n                        ++pos;\n                        }\n                    if( data && pos < size ) data[ pos ] = '=';\n                    ++pos;\n                    n = ini->properties[ p ].value_large ? ini->properties[ p ].value_large : ini->properties[ p ].value;\n                    l = (int) INI_STRLEN( n );\n                    for( i = 0; i < l; ++i )\n                        {\n                        if( data && pos < size ) data[ pos ] = n[ i ];\n                        ++pos;\n                        }\n                    if( data && pos < size ) data[ pos ] = '\\n';\n                    ++pos;\n                    }\n                }\n\n            if( pos > 0 )\n                {\n                if( data && pos < size ) data[ pos ] = '\\n';\n                ++pos;\n                }\n            }\n\n        if( data && pos < size ) data[ pos ] = '\\0';\n        ++pos;\n\n        return pos;\n        }\n\n    return 0;\n    }\n\n\nvoid ini_destroy( ini_t* ini )\n    {\n    int i;\n\n    if( ini )\n        {\n        for( i = 0; i < ini->property_count; ++i )\n            {\n            if( ini->properties[ i ].value_large ) INI_FREE( ini->memctx, ini->properties[ i ].value_large );\n            if( ini->properties[ i ].name_large ) INI_FREE( ini->memctx, ini->properties[ i ].name_large );\n            }\n        for( i = 0; i < ini->section_count; ++i )\n            if( ini->sections[ i ].name_large ) INI_FREE( ini->memctx, ini->sections[ i ].name_large );\n        INI_FREE( ini->memctx, ini->properties );\n        INI_FREE( ini->memctx, ini->sections );\n        INI_FREE( ini->memctx, ini );\n        }\n    }\n\n\nint ini_section_count( ini_t const* ini )\n    {\n    if( ini ) return ini->section_count;\n    return 0;\n    }\n\n\nchar const* ini_section_name( ini_t const* ini, int section )\n    {\n    if( ini && section >= 0 && section < ini->section_count )\n        return ini->sections[ section ].name_large ? ini->sections[ section ].name_large : ini->sections[ section ].name;\n\n    return NULL;\n    }\n\n\nint ini_property_count( ini_t const* ini, int section )\n    {\n    int i;\n    int count;\n\n    if( ini )\n        {\n        count = 0;\n        for( i = 0; i < ini->property_count; ++i )\n            {\n            if( ini->properties[ i ].section == section ) ++count;\n            }\n        return count;\n        }\n\n    return 0;\n    }\n\n\nchar const* ini_property_name( ini_t const* ini, int section, int property )\n    {\n    int p;\n\n    if( ini && section >= 0 && section < ini->section_count )\n        {\n        p = ini_internal_property_index( ini, section, property );\n        if( p != INI_NOT_FOUND )\n            return ini->properties[ p ].name_large ? ini->properties[ p ].name_large : ini->properties[ p ].name;\n        }\n\n    return NULL;\n    }\n\n\nchar const* ini_property_value( ini_t const* ini, int section, int property )\n    {\n    int p;\n\n    if( ini && section >= 0 && section < ini->section_count )\n        {\n        p = ini_internal_property_index( ini, section, property );\n        if( p != INI_NOT_FOUND )\n            return ini->properties[ p ].value_large ? ini->properties[ p ].value_large : ini->properties[ p ].value;\n        }\n\n    return NULL;\n    }\n\n\nint ini_find_section( ini_t const* ini, char const* name, int name_length )\n    {\n    int i;\n\n    if( ini && name )\n        {\n        if( name_length <= 0 ) name_length = (int) INI_STRLEN( name );\n        for( i = 0; i < ini->section_count; ++i )\n            {\n            char const* const other = \n                ini->sections[ i ].name_large ? ini->sections[ i ].name_large : ini->sections[ i ].name;\n            if( strlen( other ) == name_length && INI_STRNICMP( name, other, (size_t)name_length ) == 0 )\n                return i;\n            }\n        }\n\n    return INI_NOT_FOUND;\n    }\n\n\nint ini_find_property( ini_t const* ini, int section, char const* name, int name_length )\n    {\n    int i;\n    int c;\n\n    if( ini && name && section >= 0 && section < ini->section_count)\n        {\n        if( name_length <= 0 ) name_length = (int) INI_STRLEN( name );\n        c = 0;\n        for( i = 0; i < ini->property_count; ++i )\n            {\n            if( ini->properties[ i ].section == section )\n                {\n                char const* const other = \n                    ini->properties[ i ].name_large ? ini->properties[ i ].name_large : ini->properties[ i ].name;\n                if( strlen( other ) == name_length && INI_STRNICMP( name, other, (size_t) name_length ) == 0 )\n                    return c;\n                ++c;\n                }\n            }\n        }\n\n    return INI_NOT_FOUND;\n    }\n\n\nint ini_section_add( ini_t* ini, char const* name, int length )\n    {\n    struct ini_internal_section_t* new_sections;\n    \n    if( ini && name )\n        {\n        if( length <= 0 ) length = (int) INI_STRLEN( name );\n        if( ini->section_count >= ini->section_capacity )\n            {\n            ini->section_capacity *= 2;\n            new_sections = (struct ini_internal_section_t*) INI_MALLOC( ini->memctx, \n                ini->section_capacity * sizeof( ini->sections[ 0 ] ) );\n            INI_MEMCPY( new_sections, ini->sections, ini->section_count * sizeof( ini->sections[ 0 ] ) );\n            INI_FREE( ini->memctx, ini->sections );\n            ini->sections = new_sections;\n            }\n\n        ini->sections[ ini->section_count ].name_large = 0;\n        if( (size_t) length + 1 >= sizeof( ini->sections[ 0 ].name ) )\n            {\n            ini->sections[ ini->section_count ].name_large = (char*) INI_MALLOC( ini->memctx, (size_t) length + 1 );\n            INI_MEMCPY( ini->sections[ ini->section_count ].name_large, name, (size_t) length );\n            ini->sections[ ini->section_count ].name_large[ length ] = '\\0';\n            }\n        else\n            {\n            INI_MEMCPY( ini->sections[ ini->section_count ].name, name, (size_t) length );\n            ini->sections[ ini->section_count ].name[ length ] = '\\0';\n            }\n\n        return ini->section_count++;\n        }\n    return INI_NOT_FOUND;\n    }\n\n\nvoid ini_property_add( ini_t* ini, int section, char const* name, int name_length, char const* value, int value_length )\n    {\n    struct ini_internal_property_t* new_properties;\n\n    if( ini && name && section >= 0 && section < ini->section_count )\n        {\n        if( name_length <= 0 ) name_length = (int) INI_STRLEN( name );\n        if( value_length <= 0 ) value_length = (int) INI_STRLEN( value );\n\n        if( ini->property_count >= ini->property_capacity )\n            {\n\n            ini->property_capacity *= 2;\n            new_properties = (struct ini_internal_property_t*) INI_MALLOC( ini->memctx, \n                ini->property_capacity * sizeof( ini->properties[ 0 ] ) );\n            INI_MEMCPY( new_properties, ini->properties, ini->property_count * sizeof( ini->properties[ 0 ] ) );\n            INI_FREE( ini->memctx, ini->properties );\n            ini->properties = new_properties;\n            }\n        \n        ini->properties[ ini->property_count ].section = section;\n        ini->properties[ ini->property_count ].name_large = 0;\n        ini->properties[ ini->property_count ].value_large = 0;\n\n        if( (size_t) name_length + 1 >= sizeof( ini->properties[ 0 ].name ) )\n            {\n            ini->properties[ ini->property_count ].name_large = (char*) INI_MALLOC( ini->memctx, (size_t) name_length + 1 );\n            INI_MEMCPY( ini->properties[ ini->property_count ].name_large, name, (size_t) name_length );\n            ini->properties[ ini->property_count ].name_large[ name_length ] = '\\0';\n            }\n        else\n            {\n            INI_MEMCPY( ini->properties[ ini->property_count ].name, name, (size_t) name_length );\n            ini->properties[ ini->property_count ].name[ name_length ] = '\\0';\n            }\n\n        if( (size_t) value_length + 1 >= sizeof( ini->properties[ 0 ].value ) )\n            {\n            ini->properties[ ini->property_count ].value_large = (char*) INI_MALLOC( ini->memctx, (size_t) value_length + 1 );\n            INI_MEMCPY( ini->properties[ ini->property_count ].value_large, value, (size_t) value_length );\n            ini->properties[ ini->property_count ].value_large[ value_length ] = '\\0';\n            }\n        else\n            {\n            INI_MEMCPY( ini->properties[ ini->property_count ].value, value, (size_t) value_length );\n            ini->properties[ ini->property_count ].value[ value_length ] = '\\0';\n            }\n\n        ++ini->property_count;\n        }\n    }\n\n\nvoid ini_section_remove( ini_t* ini, int section )\n    {\n    int p;\n\n    if( ini && section >= 0 && section < ini->section_count )\n        {\n        if( ini->sections[ section ].name_large ) INI_FREE( ini->memctx, ini->sections[ section ].name_large );\n        for( p = ini->property_count - 1; p >= 0; --p ) \n            {\n            if( ini->properties[ p ].section == section )\n                {\n                if( ini->properties[ p ].value_large ) INI_FREE( ini->memctx, ini->properties[ p ].value_large );\n                if( ini->properties[ p ].name_large ) INI_FREE( ini->memctx, ini->properties[ p ].name_large );\n                ini->properties[ p ] = ini->properties[ --ini->property_count ];\n                }\n            }\n\n        ini->sections[ section ] = ini->sections[ --ini->section_count  ];\n        \n        for( p = 0; p < ini->property_count; ++p ) \n            {\n            if( ini->properties[ p ].section == ini->section_count )\n                ini->properties[ p ].section = section;\n            }\n        }\n    }\n\n\nvoid ini_property_remove( ini_t* ini, int section, int property )\n    {\n    int p;\n\n    if( ini && section >= 0 && section < ini->section_count )\n        {\n        p = ini_internal_property_index( ini, section, property );\n        if( p != INI_NOT_FOUND )\n            {\n            if( ini->properties[ p ].value_large ) INI_FREE( ini->memctx, ini->properties[ p ].value_large );\n            if( ini->properties[ p ].name_large ) INI_FREE( ini->memctx, ini->properties[ p ].name_large );\n            ini->properties[ p ] = ini->properties[ --ini->property_count  ];\n            return;\n            }\n        }\n    }\n\n\nvoid ini_section_name_set( ini_t* ini, int section, char const* name, int length )\n    {\n    if( ini && name && section >= 0 && section < ini->section_count )\n        {\n        if( length <= 0 ) length = (int) INI_STRLEN( name );\n        if( ini->sections[ section ].name_large ) INI_FREE( ini->memctx, ini->sections[ section ].name_large );\n        ini->sections[ section ].name_large = 0;\n        \n        if( (size_t) length + 1 >= sizeof( ini->sections[ 0 ].name ) )\n            {\n            ini->sections[ section ].name_large = (char*) INI_MALLOC( ini->memctx, (size_t) length + 1 );\n            INI_MEMCPY( ini->sections[ section ].name_large, name, (size_t) length );\n            ini->sections[ section ].name_large[ length ] = '\\0';\n            }\n        else\n            {\n            INI_MEMCPY( ini->sections[ section ].name, name, (size_t) length );\n            ini->sections[ section ].name[ length ] = '\\0';\n            }\n        }\n    }\n\n\nvoid ini_property_name_set( ini_t* ini, int section, int property, char const* name, int length )\n    {\n    int p;\n\n    if( ini && name && section >= 0 && section < ini->section_count )\n        {\n        if( length <= 0 ) length = (int) INI_STRLEN( name );\n        p = ini_internal_property_index( ini, section, property );\n        if( p != INI_NOT_FOUND )\n            {\n            if( ini->properties[ p ].name_large ) INI_FREE( ini->memctx, ini->properties[ p ].name_large );\n            ini->properties[ ini->property_count ].name_large = 0;\n\n            if( (size_t) length + 1 >= sizeof( ini->properties[ 0 ].name ) )\n                {\n                ini->properties[ p ].name_large = (char*) INI_MALLOC( ini->memctx, (size_t) length + 1 );\n                INI_MEMCPY( ini->properties[ p ].name_large, name, (size_t) length );\n                ini->properties[ p ].name_large[ length ] = '\\0';\n                }\n            else\n                {\n                INI_MEMCPY( ini->properties[ p ].name, name, (size_t) length );\n                ini->properties[ p ].name[ length ] = '\\0';\n                }\n            }\n        }\n    }\n\n\nvoid ini_property_value_set( ini_t* ini, int section, int property, char const* value, int length )\n    {\n    int p;\n\n    if( ini && value && section >= 0 && section < ini->section_count )\n        {\n        if( length <= 0 ) length = (int) INI_STRLEN( value );\n        p = ini_internal_property_index( ini, section, property );\n        if( p != INI_NOT_FOUND )\n            {\n            if( ini->properties[ p ].value_large ) INI_FREE( ini->memctx, ini->properties[ p ].value_large );\n            ini->properties[ ini->property_count ].value_large = 0;\n\n            if( (size_t) length + 1 >= sizeof( ini->properties[ 0 ].value ) )\n                {\n                ini->properties[ p ].value_large = (char*) INI_MALLOC( ini->memctx, (size_t) length + 1 );\n                INI_MEMCPY( ini->properties[ p ].value_large, value, (size_t) length );\n                ini->properties[ p ].value_large[ length ] = '\\0';\n                }\n            else\n                {\n                INI_MEMCPY( ini->properties[ p ].value, value, (size_t) length );\n                ini->properties[ p ].value[ length ] = '\\0';\n                }\n            }\n        }\n    }\n\n\n#endif /* INI_IMPLEMENTATION */\n\n/*\n\ncontributors:\n    Randy Gaul (copy-paste bug in ini_property_value_set)\n    Branimir Karadzic (INI_STRNICMP bugfix)\n\nrevision history:\n    1.2     using strnicmp for correct length compares, fixed copy-paste bug in ini_property_value_set\n    1.1     customization, added documentation, cleanup\n    1.0     first publicly released version\n\n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "libxdiff.h",
          "type": "blob",
          "size": 107.716796875,
          "content": "/*\n * This is a modified version of the original LibXDiff. Basically, I merged\n * it into a single-file header-only library, and added some casts to make\n * the code compile in both C and C++. I place my changes under the same\n * license as the original code.\n *                                                  /Mattias Gustavsson\n * Do this:\n *\t\t#define LIBXDIFF_IMPLEMENTATION\n * before including this file in *one* C/C++ file to get the implementation\n *\n ****************************************************************************\n *\n *  LibXDiff by Davide Libenzi ( File Differential Library )\n *  Copyright (C) 2003  Davide Libenzi\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n */\n\n\n/* BEGIN xdiff.h */\n\n#if !defined(XDIFF_H)\n#define XDIFF_H\n\n//#ifdef __cplusplus\n//extern \"C\" {\n//#endif /* #ifdef __cplusplus */\n//\n\n#define XDF_NEED_MINIMAL (1 << 1)\n\n#define XDL_PATCH_NORMAL '-'\n#define XDL_PATCH_REVERSE '+'\n#define XDL_PATCH_MODEMASK ((1 << 8) - 1)\n#define XDL_PATCH_IGNOREBSPACE (1 << 8)\n\t\n#define XDL_MMB_READONLY (1 << 0)\n\n#define XDL_MMF_ATOMIC (1 << 0)\n\n#define XDL_BDOP_INS 1\n#define XDL_BDOP_CPY 2\n#define XDL_BDOP_INSB 3\n\n\n\ntypedef struct s_memallocator {\n\tvoid *priv;\n\tvoid *(*malloc)(void *, unsigned int);\n\tvoid (*free)(void *, void *);\n\tvoid *(*realloc)(void *, void *, unsigned int);\n} memallocator_t;\n\ntypedef struct s_mmblock {\n\tstruct s_mmblock *next;\n\tunsigned long flags;\n\tlong size, bsize;\n\tchar *ptr;\n} mmblock_t;\n\ntypedef struct s_mmfile {\n\tunsigned long flags;\n\tmmblock_t *head, *tail;\n\tlong bsize, fsize, rpos;\n\tmmblock_t *rcur, *wcur;\n} mmfile_t;\n\ntypedef struct s_mmbuffer {\n\tchar *ptr;\n\tlong size;\n} mmbuffer_t;\n\ntypedef struct s_xpparam {\n\tunsigned long flags;\n} xpparam_t;\n\ntypedef struct s_xdemitcb {\n\tvoid *priv;\n\tint (*outf)(void *, mmbuffer_t *, int);\n} xdemitcb_t;\n\ntypedef struct s_xdemitconf {\n\tlong ctxlen;\n} xdemitconf_t;\n\ntypedef struct s_bdiffparam {\n\tlong bsize;\n} bdiffparam_t;\n\n\nint xdl_set_allocator(memallocator_t const *malt);\nvoid *xdl_malloc(unsigned int size);\nvoid xdl_free(void *ptr);\nvoid *xdl_realloc(void *ptr, unsigned int size);\n\nint xdl_init_mmfile(mmfile_t *mmf, long bsize, unsigned long flags);\nvoid xdl_free_mmfile(mmfile_t *mmf);\nint xdl_mmfile_iscompact(mmfile_t *mmf);\nint xdl_seek_mmfile(mmfile_t *mmf, long off);\nlong xdl_read_mmfile(mmfile_t *mmf, void *data, long size);\nlong xdl_write_mmfile(mmfile_t *mmf, void const *data, long size);\nlong xdl_writem_mmfile(mmfile_t *mmf, mmbuffer_t *mb, int nbuf);\nvoid *xdl_mmfile_writeallocate(mmfile_t *mmf, long size);\nlong xdl_mmfile_ptradd(mmfile_t *mmf, char *ptr, long size, unsigned long flags);\nlong xdl_copy_mmfile(mmfile_t *mmf, long size, xdemitcb_t *ecb);\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size);\nvoid *xdl_mmfile_next(mmfile_t *mmf, long *size);\nlong xdl_mmfile_size(mmfile_t *mmf);\nint xdl_mmfile_cmp(mmfile_t *mmf1, mmfile_t *mmf2);\nint xdl_mmfile_compact(mmfile_t *mmfo, mmfile_t *mmfc, long bsize, unsigned long flags);\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb);\nint xdl_patch(mmfile_t *mf, mmfile_t *mfp, int mode, xdemitcb_t *ecb,\n\t      xdemitcb_t *rjecb);\n\nint xdl_merge3(mmfile_t *mmfo, mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb,\n\t       xdemitcb_t *rjecb);\n\nint xdl_bdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, bdiffparam_t const *bdp, xdemitcb_t *ecb);\nint xdl_bdiff(mmfile_t *mmf1, mmfile_t *mmf2, bdiffparam_t const *bdp, xdemitcb_t *ecb);\nint xdl_rabdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, xdemitcb_t *ecb);\nint xdl_rabdiff(mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb);\nlong xdl_bdiff_tgsize(mmfile_t *mmfp);\nint xdl_bpatch(mmfile_t *mmf, mmfile_t *mmfp, xdemitcb_t *ecb);\nint xdl_bpatch_multi(mmbuffer_t *base, mmbuffer_t *mbpch, int n, xdemitcb_t *ecb);\n\n\n//#ifdef __cplusplus\n//}\n//#endif /* #ifdef __cplusplus */\n\n#endif /* #if !defined(XDIFF_H) */\n\n/* END xdiff.h */\n\n\n\n#ifdef LIBXDIFF_IMPLEMENTATION\n#undef LIBXDIFF_IMPLEMENTATION\n\n\n/* BEGIN xinclude.h */\n\n#if !defined(XINCLUDE_H)\n#define XINCLUDE_H\n\n#if defined(HAVE_WINCONFIG_H)\n#include \"winconfig.h\"\n#endif /* #if defined(HAVE_CONFIG_H) */\n\n#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif /* #if defined(HAVE_CONFIG_H) */\n\n#if defined(HAVE_STDIO_H)\n#include <stdio.h>\n#endif /* #if defined(HAVE_STDIO_H) */\n\n#if defined(HAVE_STDLIB_H)\n#include <stdlib.h>\n#endif /* #if defined(HAVE_STDLIB_H) */\n\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif /* #if defined(HAVE_UNISTD_H) */\n\n#if defined(HAVE_STRING_H)\n#include <string.h>\n#endif /* #if defined(HAVE_STRING_H) */\n\n#if defined(HAVE_LIMITS_H)\n#include <limits.h>\n#endif /* #if defined(HAVE_LIMITS_H) */\n\n\n/*\n#include \"xmacros.h\"\n#include \"xmissing.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xutils.h\"\n#include \"xadler32.h\"\n#include \"xprepare.h\"\n#include \"xdiffi.h\"\n#include \"xemit.h\"\n#include \"xbdiff.h\"\n*/\n\n\n#endif /* #if !defined(XINCLUDE_H) */\n\n/* END xinclude.h */\n\n\n/* BEGIN xmacros.h */\n\n#if !defined(XMACROS_H)\n#define XMACROS_H\n\n\n#define XDL_MIN(a, b) ((a) < (b) ? (a): (b))\n#define XDL_MAX(a, b) ((a) > (b) ? (a): (b))\n#define XDL_ABS(v) ((v) >= 0 ? (v): -(v))\n#define XDL_ISDIGIT(c) ((c) >= '0' && (c) <= '9')\n#define XDL_ADDBITS(v, b) ((v) + ((v) >> (b)))\n#define XDL_MASKBITS(b) ((1UL << (b)) - 1)\n#define XDL_HASHLONG(v, b) (XDL_ADDBITS((unsigned long) (v), b) & XDL_MASKBITS(b))\n#define XDL_PTRFREE(p) do { if (p) { xdl_free(p); (p) = NULL; } } while (0)\n#define XDL_RECMATCH(r1, r2) ((r1)->size == (r2)->size && memcmp((r1)->ptr, (r2)->ptr, (r1)->size) == 0)\n#define XDL_LE32_PUT(p, v) do { \\\n\tunsigned char *__p = (unsigned char *) (p); \\\n\t*__p++ = (unsigned char) (v); \\\n\t*__p++ = (unsigned char) ((v) >> 8); \\\n\t*__p++ = (unsigned char) ((v) >> 16); \\\n\t*__p = (unsigned char) ((v) >> 24); \\\n} while (0)\n#define XDL_LE32_GET(p, v) do { \\\n\tunsigned char const *__p = (unsigned char const *) (p); \\\n\t(v) = (unsigned long) __p[0] | ((unsigned long) __p[1]) << 8 | \\\n\t\t((unsigned long) __p[2]) << 16 | ((unsigned long) __p[3]) << 24; \\\n} while (0)\n\n\n#endif /* #if !defined(XMACROS_H) */\n\n/* END macros.h */\n\n\n/* BEGIN xmissing.h */\n\n#if !defined(XMISSING_H)\n#define XMISSING_H\n\n\n#if !defined(CHAR_BIT)\n#define CHAR_BIT 8\n#endif /* #if !defined(CHAR_BIT) */\n\n\n\n#if !defined(HAVE_MEMCHR)\nvoid *memchr(void const *p, int c, long n);\n#endif /* #if !defined(HAVE_MEMCHR) */\n\n#if !defined(HAVE_MEMCMP)\nint memcmp(void const *p1, void const *p2, long n);\n#endif /* #if !defined(HAVE_MEMCMP) */\n\n#if !defined(HAVE_MEMCPY)\nvoid *memcpy(void *d, void const *s, long n);\n#endif /* #if !defined(HAVE_MEMCPY) */\n\n#if !defined(HAVE_MEMSET)\nvoid *memset(void *d, int c, long n);\n#endif /* #if !defined(HAVE_MEMSET) */\n\n#if !defined(HAVE_STRLEN)\nlong strlen(char const *s);\n#endif /* #if !defined(HAVE_STRLEN) */\n\n\n\n#endif /* #if !defined(XMISSING_H) */\n\n/* END xmissing.h */\n\n\n/* BEGIN xtypes.h */\n\n#if !defined(XTYPES_H)\n#define XTYPES_H\n\n\n\ntypedef struct s_chanode {\n\tstruct s_chanode *next;\n\tlong icurr;\n} chanode_t;\n\ntypedef struct s_chastore {\n\tchanode_t *head, *tail;\n\tlong isize, nsize;\n\tchanode_t *ancur;\n\tchanode_t *sncur;\n\tlong scurr;\n} chastore_t;\n\ntypedef struct s_xrecord {\n\tstruct s_xrecord *next;\n\tchar const *ptr;\n\tlong size;\n\tunsigned long ha;\n} xrecord_t;\n\ntypedef struct s_xdfile {\n\tchastore_t rcha;\n\tlong nrec;\n\tunsigned int hbits;\n\txrecord_t **rhash;\n\tlong dstart, dend;\n\txrecord_t **recs;\n\tchar *rchg;\n\tlong *rindex;\n\tlong nreff;\n\tunsigned long *ha;\n} xdfile_t;\n\ntypedef struct s_xdfenv {\n\txdfile_t xdf1, xdf2;\n} xdfenv_t;\n\n\n\n#endif /* #if !defined(XTYPES_H) */\n\n/* END xtypes.h */\n\n\n/* BEGIN xutils.h */\n\n#if !defined(XUTILS_H)\n#define XUTILS_H\n\n\n\nlong xdl_bogosqrt(long n);\nint xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb);\nint xdl_mmfile_outf(void *priv, mmbuffer_t *mb, int nbuf);\nint xdl_cha_init(chastore_t *cha, long isize, long icount);\nvoid xdl_cha_free(chastore_t *cha);\nvoid *xdl_cha_alloc(chastore_t *cha);\nvoid *xdl_cha_first(chastore_t *cha);\nvoid *xdl_cha_next(chastore_t *cha);\nlong xdl_guess_lines(mmfile_t *mf);\nunsigned long xdl_hash_record(char const **data, char const *top);\nunsigned int xdl_hashbits(unsigned int size);\nint xdl_num_out(char *out, long val);\nlong xdl_atol(char const *str, char const **next);\nint xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2, xdemitcb_t *ecb);\n\n\n\n#endif /* #if !defined(XUTILS_H) */\n\n/* END xutils.h */\n\n\n/* BEGIN xadler32.h */\n\n#if !defined(XADLER32_H)\n#define XADLER32_H\n\n\n\nunsigned long xdl_adler32(unsigned long adler, unsigned char const *buf,\n\t\t\t  unsigned int len);\n\n\n\n#endif /* #if !defined(XADLER32_H) */\n\n/* END xadler32.h */\n\n\n/* BEGIN xprepare.h */\n\n#if !defined(XPREPARE_H)\n#define XPREPARE_H\n\n\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe);\nvoid xdl_free_env(xdfenv_t *xe);\n\n\n\n#endif /* #if !defined(XPREPARE_H) */\n\n/* END xprepare.h */\n\n\n/* BEGIN xdiffi.h */\n\n#if !defined(XDIFFI_H)\n#define XDIFFI_H\n\n\ntypedef struct s_diffdata {\n\tlong nrec;\n\tunsigned long const *ha;\n\tlong *rindex;\n\tchar *rchg;\n} diffdata_t;\n\ntypedef struct s_xdalgoenv {\n\tlong mxcost;\n\tlong snake_cnt;\n\tlong heur_min;\n} xdalgoenv_t;\n\ntypedef struct s_xdchange {\n\tstruct s_xdchange *next;\n\tlong i1, i2;\n\tlong chg1, chg2;\n} xdchange_t;\n\n\n\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv);\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe);\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr);\nvoid xdl_free_script(xdchange_t *xscr);\nint xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t  xdemitconf_t const *xecfg);\n\n\n#endif /* #if !defined(XDIFFI_H) */\n\n/* END xdiffi.h */\n\n\n/* BEGIN xemit.h */\n\n#if !defined(XEMIT_H)\n#define XEMIT_H\n\n\n\nint xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t  xdemitconf_t const *xecfg);\n\n\n\n#endif /* #if !defined(XEMIT_H) */\n\n/* END xemit.h */\n\n\n/* BEGIN xbdiff.h */\n\n#if !defined(XBDIFF_H)\n#define XBDIFF_H\n\n\n#define XDL_BPATCH_HDR_SIZE (4 + 4)\n#define XDL_MIN_BLKSIZE 16\n#define XDL_INSBOP_SIZE (1 + 4)\n#define XDL_COPYOP_SIZE (1 + 4 + 4)\n\n\n\nunsigned long xdl_mmb_adler32(mmbuffer_t *mmb);\nunsigned long xdl_mmf_adler32(mmfile_t *mmf);\n\n\n\n#endif /* #if !defined(XBDIFF_H) */\n\n/* END xbdiff.h */\n\n\n\n\n\n/* BEGIN xadler32.c */\n\n/* largest prime smaller than 65536 */\n#define BASE 65521L\n\n/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n#define NMAX 5552\n\n\n#define DO1(buf, i)  { s1 += buf[i]; s2 += s1; }\n#define DO2(buf, i)  DO1(buf, i); DO1(buf, i + 1);\n#define DO4(buf, i)  DO2(buf, i); DO2(buf, i + 2);\n#define DO8(buf, i)  DO4(buf, i); DO4(buf, i + 4);\n#define DO16(buf)    DO8(buf, 0); DO8(buf, 8);\n\n\n\nunsigned long xdl_adler32(unsigned long adler, unsigned char const *buf,\n\t\t\t  unsigned int len) {\n\tint k;\n\tunsigned long s1 = adler & 0xffff;\n\tunsigned long s2 = (adler >> 16) & 0xffff;\n\n\tif (!buf)\n\t\treturn 1;\n\n\twhile (len > 0) {\n\t\tk = len < NMAX ? len :NMAX;\n\t\tlen -= k;\n\t\twhile (k >= 16) {\n\t\t\tDO16(buf);\n\t\t\tbuf += 16;\n\t\t\tk -= 16;\n\t\t}\n\t\tif (k != 0)\n\t\t\tdo {\n\t\t\t\ts1 += *buf++;\n\t\t\t\ts2 += s1;\n\t\t\t} while (--k);\n\t\ts1 %= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\treturn (s2 << 16) | s1;\n}\n\n/* END xadler32.c */\n\n\n/* BEGIN xalloc.c */\n\nstatic void *wrap_malloc(void *priv, unsigned int size) {\n\n\treturn malloc(size);\n}\n\n\nstatic void wrap_free(void *priv, void *ptr) {\n\n\tfree(ptr);\n}\n\n\nstatic void *wrap_realloc(void *priv, void *ptr, unsigned int size) {\n\n\treturn realloc(ptr, size);\n}\n\n\nstatic memallocator_t xmalt = { NULL, wrap_malloc, wrap_free, wrap_realloc };\n\n\n\nint xdl_set_allocator(memallocator_t const *malt) {\n\txmalt = *malt;\n\treturn 0;\n}\n\n\nvoid *xdl_malloc(unsigned int size) {\n\treturn xmalt.malloc ? xmalt.malloc(xmalt.priv, size): NULL;\n}\n\n\nvoid xdl_free(void *ptr) {\n\tif (xmalt.free)\n\t\txmalt.free(xmalt.priv, ptr);\n}\n\n\nvoid *xdl_realloc(void *ptr, unsigned int size) {\n\treturn xmalt.realloc ? xmalt.realloc(xmalt.priv, ptr, size): NULL;\n}\n\n/* END xalloc.x */\n\n\n/* BEGIN xbdiff. c */\n\ntypedef struct s_bdrecord {\n\tstruct s_bdrecord *next;\n\tunsigned long fp;\n\tchar const *ptr;\n} bdrecord_t;\n\ntypedef struct s_bdfile {\n\tchar const *data, *top;\n\tchastore_t cha;\n\tunsigned int fphbits;\n\tbdrecord_t **fphash;\n} bdfile_t;\n\n\n\nstatic int xdl_prepare_bdfile(mmbuffer_t *mmb, long fpbsize, bdfile_t *bdf) {\n\tunsigned int fphbits;\n\tlong i, size, hsize;\n\tchar const *base, *data, *top;\n\tbdrecord_t *brec;\n\tbdrecord_t **fphash;\n\n\tfphbits = xdl_hashbits((unsigned int) (mmb->size / fpbsize) + 1);\n\thsize = 1 << fphbits;\n\tif (!(fphash = (bdrecord_t **) xdl_malloc(hsize * sizeof(bdrecord_t *)))) {\n\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < hsize; i++)\n\t\tfphash[i] = NULL;\n\n\tif (xdl_cha_init(&bdf->cha, sizeof(bdrecord_t), hsize / 4 + 1) < 0) {\n\n\t\txdl_free(fphash);\n\t\treturn -1;\n\t}\n\n\tif (!(size = mmb->size)) {\n\t\tbdf->data = bdf->top = NULL;\n\t} else {\n\t\tbdf->data = data = base = mmb->ptr;\n\t\tbdf->top = top = mmb->ptr + mmb->size;\n\n\t\tif ((data += (size / fpbsize) * fpbsize) == top)\n\t\t\tdata -= fpbsize;\n\n\t\tfor (; data >= base; data -= fpbsize) {\n\t\t\tif (!(brec = (bdrecord_t *) xdl_cha_alloc(&bdf->cha))) {\n\n\t\t\t\txdl_cha_free(&bdf->cha);\n\t\t\t\txdl_free(fphash);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tbrec->fp = xdl_adler32(0, (unsigned char const *) data,\n\t\t\t\t\t       XDL_MIN(fpbsize, (long) (top - data)));\n\t\t\tbrec->ptr = data;\n\n\t\t\ti = (long) XDL_HASHLONG(brec->fp, fphbits);\n\t\t\tbrec->next = fphash[i];\n\t\t\tfphash[i] = brec;\n\t\t}\n\t}\n\n\tbdf->fphbits = fphbits;\n\tbdf->fphash = fphash;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_bdfile(bdfile_t *bdf) {\n\n\txdl_free(bdf->fphash);\n\txdl_cha_free(&bdf->cha);\n}\n\n\nunsigned long xdl_mmb_adler32(mmbuffer_t *mmb) {\n\n\treturn mmb->size ? xdl_adler32(0, (unsigned char const *) mmb->ptr, mmb->size): 0;\n}\n\n\nunsigned long xdl_mmf_adler32(mmfile_t *mmf) {\n\tunsigned long fp = 0;\n\tlong size;\n\tchar const *blk;\n\n\tif ((blk = (char const *) xdl_mmfile_first(mmf, &size)) != NULL) {\n\t\tdo {\n\t\t\tfp = xdl_adler32(fp, (unsigned char const *) blk, size);\n\t\t} while ((blk = (char const *) xdl_mmfile_next(mmf, &size)) != NULL);\n\t}\n\treturn fp;\n}\n\n\nint xdl_bdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, bdiffparam_t const *bdp, xdemitcb_t *ecb) {\n\tlong i, rsize, size, bsize, csize, msize, moff;\n\tunsigned long fp;\n\tchar const *blk, *base, *data, *top, *ptr1, *ptr2;\n\tbdrecord_t *brec;\n\tbdfile_t bdf;\n\tmmbuffer_t mb[2];\n\tunsigned char cpybuf[32];\n\n\tif ((bsize = bdp->bsize) < XDL_MIN_BLKSIZE)\n\t\tbsize = XDL_MIN_BLKSIZE;\n\tif (xdl_prepare_bdfile(mmb1, bsize, &bdf) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Prepare and emit the binary patch file header. It will be used\n\t * to verify that that file being patched matches in size and fingerprint\n\t * the one that generated the patch.\n\t */\n\tfp = xdl_mmb_adler32(mmb1);\n\tsize = mmb1->size;\n\tXDL_LE32_PUT(cpybuf, fp);\n\tXDL_LE32_PUT(cpybuf + 4, size);\n\n\tmb[0].ptr = (char *) cpybuf;\n\tmb[0].size = 4 + 4;\n\n\tif (ecb->outf(ecb->priv, mb, 1) < 0) {\n\n\t\txdl_free_bdfile(&bdf);\n\t\treturn -1;\n\t}\n\n\tif ((blk = (char const *) mmb2->ptr) != NULL) {\n\t\tsize = mmb2->size;\n\t\tfor (base = data = blk, top = data + size; data < top;) {\n\t\t\trsize = XDL_MIN(bsize, (long) (top - data));\n\t\t\tfp = xdl_adler32(0, (unsigned char const *) data, rsize);\n\n\t\t\ti = (long) XDL_HASHLONG(fp, bdf.fphbits);\n\t\t\tfor (msize = 0, brec = bdf.fphash[i]; brec; brec = brec->next)\n\t\t\t\tif (brec->fp == fp) {\n\t\t\t\t\tcsize = XDL_MIN((long) (top - data), (long) (bdf.top - brec->ptr));\n\t\t\t\t\tfor (ptr1 = brec->ptr, ptr2 = data; csize && *ptr1 == *ptr2;\n\t\t\t\t\t     csize--, ptr1++, ptr2++);\n\n\t\t\t\t\tif ((csize = (long) (ptr1 - brec->ptr)) > msize) {\n\t\t\t\t\t\tmoff = (long) (brec->ptr - bdf.data);\n\t\t\t\t\t\tmsize = csize;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (msize < XDL_COPYOP_SIZE) {\n\t\t\t\tdata++;\n\t\t\t} else {\n\t\t\t\tif (data > base) {\n\t\t\t\t\ti = (long) (data - base);\n\t\t\t\t\tif (i > 255) {\n\t\t\t\t\t\tcpybuf[0] = XDL_BDOP_INSB;\n\t\t\t\t\t\tXDL_LE32_PUT(cpybuf + 1, i);\n\n\t\t\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\t\t\tmb[0].size = XDL_INSBOP_SIZE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcpybuf[0] = XDL_BDOP_INS;\n\t\t\t\t\t\tcpybuf[1] = (unsigned char) i;\n\n\t\t\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\t\t\tmb[0].size = 2;\n\t\t\t\t\t}\n\t\t\t\t\tmb[1].ptr = (char *) base;\n\t\t\t\t\tmb[1].size = i;\n\n\t\t\t\t\tif (ecb->outf(ecb->priv, mb, 2) < 0) {\n\n\t\t\t\t\t\txdl_free_bdfile(&bdf);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata += msize;\n\n\t\t\t\tcpybuf[0] = XDL_BDOP_CPY;\n\t\t\t\tXDL_LE32_PUT(cpybuf + 1, moff);\n\t\t\t\tXDL_LE32_PUT(cpybuf + 5, msize);\n\n\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\tmb[0].size = XDL_COPYOP_SIZE;\n\n\t\t\t\tif (ecb->outf(ecb->priv, mb, 1) < 0) {\n\n\t\t\t\t\txdl_free_bdfile(&bdf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbase = data;\n\t\t\t}\n\t\t}\n\t\tif (data > base) {\n\t\t\ti = (long) (data - base);\n\t\t\tif (i > 255) {\n\t\t\t\tcpybuf[0] = XDL_BDOP_INSB;\n\t\t\t\tXDL_LE32_PUT(cpybuf + 1, i);\n\n\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\tmb[0].size = XDL_INSBOP_SIZE;\n\t\t\t} else {\n\t\t\t\tcpybuf[0] = XDL_BDOP_INS;\n\t\t\t\tcpybuf[1] = (unsigned char) i;\n\n\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\tmb[0].size = 2;\n\t\t\t}\n\t\t\tmb[1].ptr = (char *) base;\n\t\t\tmb[1].size = i;\n\n\t\t\tif (ecb->outf(ecb->priv, mb, 2) < 0) {\n\n\t\t\t\txdl_free_bdfile(&bdf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\txdl_free_bdfile(&bdf);\n\n\treturn 0;\n}\n\n\nint xdl_bdiff(mmfile_t *mmf1, mmfile_t *mmf2, bdiffparam_t const *bdp, xdemitcb_t *ecb) {\n\tmmbuffer_t mmb1, mmb2;\n\n\tif (!xdl_mmfile_iscompact(mmf1) || !xdl_mmfile_iscompact(mmf2)) {\n\n\t\treturn -1;\n\t}\n\n\tif ((mmb1.ptr = (char *) xdl_mmfile_first(mmf1, &mmb1.size)) == NULL)\n\t\tmmb1.size = 0;\n\tif ((mmb2.ptr = (char *) xdl_mmfile_first(mmf2, &mmb2.size)) == NULL)\n\t\tmmb2.size = 0;\n\n\treturn xdl_bdiff_mb(&mmb1, &mmb2, bdp, ecb);\n}\n\n\nlong xdl_bdiff_tgsize(mmfile_t *mmfp) {\n\tlong tgsize = 0, size, off, csize;\n\tchar const *blk;\n\tunsigned char const *data, *top;\n\n\tif ((blk = (char const *) xdl_mmfile_first(mmfp, &size)) == NULL ||\n\t    size < XDL_BPATCH_HDR_SIZE) {\n\n\t\treturn -1;\n\t}\n\tblk += XDL_BPATCH_HDR_SIZE;\n\tsize -= XDL_BPATCH_HDR_SIZE;\n\n\tdo {\n\t\tfor (data = (unsigned char const *) blk, top = data + size;\n\t\t     data < top;) {\n\t\t\tif (*data == XDL_BDOP_INS) {\n\t\t\t\tdata++;\n\t\t\t\tcsize = (long) *data++;\n\t\t\t\ttgsize += csize;\n\t\t\t\tdata += csize;\n\t\t\t} else if (*data == XDL_BDOP_INSB) {\n\t\t\t\tdata++;\n\t\t\t\tXDL_LE32_GET(data, csize);\n\t\t\t\tdata += 4;\n\t\t\t\ttgsize += csize;\n\t\t\t\tdata += csize;\n\t\t\t} else if (*data == XDL_BDOP_CPY) {\n\t\t\t\tdata++;\n\t\t\t\tXDL_LE32_GET(data, off);\n\t\t\t\tdata += 4;\n\t\t\t\tXDL_LE32_GET(data, csize);\n\t\t\t\tdata += 4;\n\t\t\t\ttgsize += csize;\n\t\t\t} else {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} while ((blk = (char const *) xdl_mmfile_next(mmfp, &size)) != NULL);\n\n\treturn tgsize;\n}\n\n\n/* END xbdiff.c */\n\n\n/* BEGIN xpatchi.c */\n\n#define XDL_MOBF_MINALLOC 128\n\n\ntypedef struct s_mmoffbuffer {\n\tlong off, size;\n\tchar *ptr;\n} mmoffbuffer_t;\n\n\n\nstatic int xdl_copy_range(mmfile_t *mmf, long off, long size, xdemitcb_t *ecb) {\n\tif (xdl_seek_mmfile(mmf, off) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_copy_mmfile(mmf, size, ecb) != size) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_bpatch(mmfile_t *mmf, mmfile_t *mmfp, xdemitcb_t *ecb) {\n\tlong size, off, csize, osize;\n\tunsigned long fp, ofp;\n\tchar const *blk;\n\tunsigned char const *data, *top;\n\tmmbuffer_t mb;\n\n\tif ((blk = (char const *) xdl_mmfile_first(mmfp, &size)) == NULL ||\n\t    size < XDL_BPATCH_HDR_SIZE) {\n\n\t\treturn -1;\n\t}\n\tofp = xdl_mmf_adler32(mmf);\n\tosize = xdl_mmfile_size(mmf);\n\tXDL_LE32_GET(blk, fp);\n\tXDL_LE32_GET(blk + 4, csize);\n\tif (fp != ofp || csize != osize) {\n\n\t\treturn -1;\n\t}\n\n\tblk += XDL_BPATCH_HDR_SIZE;\n\tsize -= XDL_BPATCH_HDR_SIZE;\n\n\tdo {\n\t\tfor (data = (unsigned char const *) blk, top = data + size;\n\t\t     data < top;) {\n\t\t\tif (*data == XDL_BDOP_INS) {\n\t\t\t\tdata++;\n\n\t\t\t\tmb.size = (long) *data++;\n\t\t\t\tmb.ptr = (char *) data;\n\t\t\t\tdata += mb.size;\n\n\t\t\t\tif (ecb->outf(ecb->priv, &mb, 1) < 0) {\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else if (*data == XDL_BDOP_INSB) {\n\t\t\t\tdata++;\n\t\t\t\tXDL_LE32_GET(data, csize);\n\t\t\t\tdata += 4;\n\n\t\t\t\tmb.size = csize;\n\t\t\t\tmb.ptr = (char *) data;\n\t\t\t\tdata += mb.size;\n\n\t\t\t\tif (ecb->outf(ecb->priv, &mb, 1) < 0) {\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else if (*data == XDL_BDOP_CPY) {\n\t\t\t\tdata++;\n\t\t\t\tXDL_LE32_GET(data, off);\n\t\t\t\tdata += 4;\n\t\t\t\tXDL_LE32_GET(data, csize);\n\t\t\t\tdata += 4;\n\n\t\t\t\tif (xdl_copy_range(mmf, off, csize, ecb) < 0) {\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} while ((blk = (char const *) xdl_mmfile_next(mmfp, &size)) != NULL);\n\n\treturn 0;\n}\n\n\nstatic unsigned long xdl_mmob_adler32(mmoffbuffer_t *obf, int n) {\n\tunsigned long ha;\n\n\tfor (ha = 0; n > 0; n--, obf++)\n\t\tha = xdl_adler32(ha, (unsigned char const *) obf->ptr, obf->size);\n\n\treturn ha;\n}\n\n\nstatic long xdl_mmob_size(mmoffbuffer_t *obf, int n) {\n\n\treturn n > 0 ? obf[n - 1].off + obf[n - 1].size: 0;\n}\n\n\nstatic mmoffbuffer_t *xdl_mmob_new(mmoffbuffer_t **probf, int *pnobf, int *paobf) {\n\tint aobf;\n\tmmoffbuffer_t *cobf, *rrobf;\n\n\tif (*pnobf >= *paobf) {\n\t\taobf = 2 * (*paobf) + 1;\n\t\tif ((rrobf = (mmoffbuffer_t *)\n\t\t     xdl_realloc(*probf, aobf * sizeof(mmoffbuffer_t))) == NULL) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\t*probf = rrobf;\n\t\t*paobf = aobf;\n\t}\n\tcobf = (*probf) + (*pnobf);\n\t(*pnobf)++;\n\n\treturn cobf;\n}\n\n\nstatic int xdl_mmob_find_cntr(mmoffbuffer_t *obf, int n, long off) {\n\tint i, lo, hi;\n\n\tfor (lo = -1, hi = n; hi - lo > 1;) {\n\t\ti = (hi + lo) / 2;\n\t\tif (off < obf[i].off)\n\t\t\thi = i;\n\t\telse\n\t\t\tlo = i;\n\t}\n\n\treturn (lo >= 0 && off >= obf[lo].off && off < obf[lo].off + obf[lo].size) ? lo: -1;\n}\n\n\nstatic int xdl_bmerge(mmoffbuffer_t *obf, int n, mmbuffer_t *mbfp, mmoffbuffer_t **probf,\n\t\t      int *pnobf) {\n\tint i, aobf, nobf;\n\tlong ooff, off, csize;\n\tunsigned long fp, ofp;\n\tunsigned char const *data, *top;\n\tmmoffbuffer_t *robf, *cobf;\n\n\tif (mbfp->size < XDL_BPATCH_HDR_SIZE) {\n\n\t\treturn -1;\n\t}\n\tdata = (unsigned char const *) mbfp->ptr;\n\ttop = data + mbfp->size;\n\n\tofp = xdl_mmob_adler32(obf, n);\n\tXDL_LE32_GET(data, fp);\n\tdata += 4;\n\tXDL_LE32_GET(data, csize);\n\tdata += 4;\n\tif (fp != ofp || csize != xdl_mmob_size(obf, n)) {\n\n\t\treturn -1;\n\t}\n\taobf = XDL_MOBF_MINALLOC;\n\tnobf = 0;\n\tif ((robf = (mmoffbuffer_t *) xdl_malloc(aobf * sizeof(mmoffbuffer_t))) == NULL) {\n\n\t\treturn -1;\n\t}\n\n\tfor (ooff = 0; data < top;) {\n\t\tif (*data == XDL_BDOP_INS) {\n\t\t\tdata++;\n\n\t\t\tif ((cobf = xdl_mmob_new(&robf, &nobf, &aobf)) == NULL) {\n\n\t\t\t\txdl_free(robf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcobf->off = ooff;\n\t\t\tcobf->size = (long) *data++;\n\t\t\tcobf->ptr = (char *) data;\n\n\t\t\tdata += cobf->size;\n\t\t\tooff += cobf->size;\n\t\t} else if (*data == XDL_BDOP_INSB) {\n\t\t\tdata++;\n\t\t\tXDL_LE32_GET(data, csize);\n\t\t\tdata += 4;\n\n\t\t\tif ((cobf = xdl_mmob_new(&robf, &nobf, &aobf)) == NULL) {\n\n\t\t\t\txdl_free(robf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcobf->off = ooff;\n\t\t\tcobf->size = csize;\n\t\t\tcobf->ptr = (char *) data;\n\n\t\t\tdata += cobf->size;\n\t\t\tooff += cobf->size;\n\t\t} else if (*data == XDL_BDOP_CPY) {\n\t\t\tdata++;\n\t\t\tXDL_LE32_GET(data, off);\n\t\t\tdata += 4;\n\t\t\tXDL_LE32_GET(data, csize);\n\t\t\tdata += 4;\n\n\t\t\tif ((i = xdl_mmob_find_cntr(obf, n, off)) < 0) {\n\n\t\t\t\txdl_free(robf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\toff -= obf[i].off;\n\t\t\tfor (; i < n && csize > 0; i++, off = 0) {\n\t\t\t\tif ((cobf = xdl_mmob_new(&robf, &nobf, &aobf)) == NULL) {\n\n\t\t\t\t\txdl_free(robf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcobf->off = ooff;\n\t\t\t\tcobf->size = XDL_MIN(csize, obf[i].size - off);\n\t\t\t\tcobf->ptr = obf[i].ptr + off;\n\n\t\t\t\tooff += cobf->size;\n\t\t\t\tcsize -= cobf->size;\n\t\t\t}\n\t\t\tif (csize > 0) {\n\n\t\t\t\txdl_free(robf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\n\t\t\txdl_free(robf);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t*probf = robf;\n\t*pnobf = nobf;\n\n\treturn 0;\n}\n\n\nstatic int xdl_bmerge_synt(mmoffbuffer_t *obf, int n, xdemitcb_t *ecb) {\n\tint i;\n\tmmbuffer_t *mb;\n\n\tif ((mb = (mmbuffer_t *) xdl_malloc(n * sizeof(mmbuffer_t))) == NULL) {\n\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tmb[i].ptr = obf[i].ptr;\n\t\tmb[i].size = obf[i].size;\n\t}\n\tif (ecb->outf(ecb->priv, mb, n) < 0) {\n\n\t\txdl_free(mb);\n\t\treturn -1;\n\t}\n\txdl_free(mb);\n\n\treturn 0;\n}\n\n\nint xdl_bpatch_multi(mmbuffer_t *base, mmbuffer_t *mbpch, int n, xdemitcb_t *ecb) {\n\tint i, nobf, fnobf;\n\tmmoffbuffer_t *obf, *fobf;\n\n\tnobf = 1;\n\tif ((obf = (mmoffbuffer_t *) xdl_malloc(nobf * sizeof(mmoffbuffer_t))) == NULL) {\n\n\t\treturn -1;\n\t}\n\tobf->off = 0;\n\tobf->ptr = base->ptr;\n\tobf->size = base->size;\n\tfor (i = 0; i < n; i++) {\n\t\tif (xdl_bmerge(obf, nobf, &mbpch[i], &fobf, &fnobf) < 0) {\n\n\t\t\txdl_free(obf);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free(obf);\n\n\t\tobf = fobf;\n\t\tnobf = fnobf;\n\t}\n\tif (xdl_bmerge_synt(obf, nobf, ecb) < 0) {\n\n\t\txdl_free(obf);\n\t\treturn -1;\n\t}\n\txdl_free(obf);\n\n\treturn 0;\n}\n\n/* END xpatchi.c */\n\n\n/* BEGIN xdiffi.c */\n\n#define XDL_MAX_COST_MIN 256\n#define XDL_HEUR_MIN_COST 256\n#define XDL_LINE_MAX (long)((1UL << (8 * sizeof(long) - 1)) - 1)\n#define XDL_SNAKE_CNT 20\n#define XDL_K_HEUR 4\n\n\n\ntypedef struct s_xdpsplit {\n\tlong i1, i2;\n\tint min_lo, min_hi;\n} xdpsplit_t;\n\n\n\n/*\n * See \"An O(ND) Difference Algorithm and its Variations\", by Eugene Myers.\n * Basically considers a \"box\" (off1, off2, lim1, lim2) and scan from both\n * the forward diagonal starting from (off1, off2) and the backward diagonal\n * starting from (lim1, lim2). If the K values on the same diagonal crosses\n * returns the furthest point of reach. We might end up having to expensive\n * cases using this algorithm is full, so a little bit of heuristic is needed\n * to cut the search and to return a suboptimal point.\n */\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv) {\n\tlong dmin = off1 - lim2, dmax = lim1 - off2;\n\tlong fmid = off1 - off2, bmid = lim1 - lim2;\n\tlong odd = (fmid - bmid) & 1;\n\tlong fmin = fmid, fmax = fmid;\n\tlong bmin = bmid, bmax = bmid;\n\tlong ec, d, i1, i2, prev1, best, dd, v, k;\n\n\t/*\n\t * Set initial diagonal values for both forward and backward path.\n\t */\n\tkvdf[fmid] = off1;\n\tkvdb[bmid] = lim1;\n\n\tfor (ec = 1;; ec++) {\n\t\tint got_snake = 0;\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the extenal K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (fmin > dmin)\n\t\t\tkvdf[--fmin - 1] = -1;\n\t\telse\n\t\t\t++fmin;\n\t\tif (fmax < dmax)\n\t\t\tkvdf[++fmax + 1] = -1;\n\t\telse\n\t\t\t--fmax;\n\n\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\tif (kvdf[d - 1] >= kvdf[d + 1])\n\t\t\t\ti1 = kvdf[d - 1] + 1;\n\t\t\telse\n\t\t\t\ti1 = kvdf[d + 1];\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 < lim1 && i2 < lim2 && ha1[i1] == ha2[i2]; i1++, i2++);\n\t\t\tif (i1 - prev1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdf[d] = i1;\n\t\t\tif (odd && bmin <= d && d <= bmax && kvdb[d] <= i1) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We need to extent the diagonal \"domain\" by one. If the next\n\t\t * values exits the box boundaries we need to change it in the\n\t\t * opposite direction because (max - min) must be a power of two.\n\t\t * Also we initialize the extenal K value to -1 so that we can\n\t\t * avoid extra conditions check inside the core loop.\n\t\t */\n\t\tif (bmin > dmin)\n\t\t\tkvdb[--bmin - 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t++bmin;\n\t\tif (bmax < dmax)\n\t\t\tkvdb[++bmax + 1] = XDL_LINE_MAX;\n\t\telse\n\t\t\t--bmax;\n\n\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\tif (kvdb[d - 1] < kvdb[d + 1])\n\t\t\t\ti1 = kvdb[d - 1];\n\t\t\telse\n\t\t\t\ti1 = kvdb[d + 1] - 1;\n\t\t\tprev1 = i1;\n\t\t\ti2 = i1 - d;\n\t\t\tfor (; i1 > off1 && i2 > off2 && ha1[i1 - 1] == ha2[i2 - 1]; i1--, i2--);\n\t\t\tif (prev1 - i1 > xenv->snake_cnt)\n\t\t\t\tgot_snake = 1;\n\t\t\tkvdb[d] = i1;\n\t\t\tif (!odd && fmin <= d && d <= fmax && i1 <= kvdf[d]) {\n\t\t\t\tspl->i1 = i1;\n\t\t\t\tspl->i2 = i2;\n\t\t\t\tspl->min_lo = spl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\tif (need_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the edit cost is above the heuristic trigger and if\n\t\t * we got a good snake, we sample current diagonals to see\n\t\t * if some of the, have reached an \"interesting\" path. Our\n\t\t * measure is a function of the distance from the diagonal\n\t\t * corner (i1 + i2) penalized with the distance from the\n\t\t * mid diagonal itself. If this value is above the current\n\t\t * edit cost times a magic factor (XDL_K_HEUR) we consider\n\t\t * it interesting.\n\t\t */\n\t\tif (got_snake && ec > xenv->heur_min) {\n\t\t\tfor (best = 0, d = fmax; d >= fmin; d -= 2) {\n\t\t\t\tdd = d > fmid ? d - fmid: fmid - d;\n\t\t\t\ti1 = kvdf[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (i1 - off1) + (i2 - off2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 + xenv->snake_cnt <= i1 && i1 < lim1 &&\n\t\t\t\t    off2 + xenv->snake_cnt <= i2 && i2 < lim2) {\n\t\t\t\t\tfor (k = 1; ha1[i1 - k] == ha2[i2 - k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t\treturn ec;\n\t\t\t}\n\n\t\t\tfor (best = 0, d = bmax; d >= bmin; d -= 2) {\n\t\t\t\tdd = d > bmid ? d - bmid: bmid - d;\n\t\t\t\ti1 = kvdb[d];\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tv = (lim1 - i1) + (lim2 - i2) - dd;\n\n\t\t\t\tif (v > XDL_K_HEUR * ec && v > best &&\n\t\t\t\t    off1 < i1 && i1 <= lim1 - xenv->snake_cnt &&\n\t\t\t\t    off2 < i2 && i2 <= lim2 - xenv->snake_cnt) {\n\t\t\t\t\tfor (k = 0; ha1[i1 + k] == ha2[i2 + k]; k++)\n\t\t\t\t\t\tif (k == xenv->snake_cnt - 1) {\n\t\t\t\t\t\t\tbest = v;\n\t\t\t\t\t\t\tspl->i1 = i1;\n\t\t\t\t\t\t\tspl->i2 = i2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best > 0) {\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t\treturn ec;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Enough is enough. We spent too much time here and now we collect\n\t\t * the furthest reaching path using the (i1 + i2) measure.\n\t\t */\n\t\tif (ec >= xenv->mxcost) {\n\t\t\tlong fbest, fbest1, bbest, bbest1;\n\n\t\t\tfbest = -1;\n\t\t\tfor (d = fmax; d >= fmin; d -= 2) {\n\t\t\t\ti1 = XDL_MIN(kvdf[d], lim1);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (lim2 < i2)\n\t\t\t\t\ti1 = lim2 + d, i2 = lim2;\n\t\t\t\tif (fbest < i1 + i2) {\n\t\t\t\t\tfbest = i1 + i2;\n\t\t\t\t\tfbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbbest = XDL_LINE_MAX;\n\t\t\tfor (d = bmax; d >= bmin; d -= 2) {\n\t\t\t\ti1 = XDL_MAX(off1, kvdb[d]);\n\t\t\t\ti2 = i1 - d;\n\t\t\t\tif (i2 < off2)\n\t\t\t\t\ti1 = off2 + d, i2 = off2;\n\t\t\t\tif (i1 + i2 < bbest) {\n\t\t\t\t\tbbest = i1 + i2;\n\t\t\t\t\tbbest1 = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lim1 + lim2) - bbest < fbest - (off1 + off2)) {\n\t\t\t\tspl->i1 = fbest1;\n\t\t\t\tspl->i2 = fbest - fbest1;\n\t\t\t\tspl->min_lo = 1;\n\t\t\t\tspl->min_hi = 0;\n\t\t\t} else {\n\t\t\t\tspl->i1 = bbest1;\n\t\t\t\tspl->i2 = bbest - bbest1;\n\t\t\t\tspl->min_lo = 0;\n\t\t\t\tspl->min_hi = 1;\n\t\t\t}\n\t\t\treturn ec;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n\n/*\n * Rule: \"Divide et Impera\". Recursively split the box in sub-boxes by calling\n * the box splitting function. Note that the real job (marking changed lines)\n * is done in the two boundary reaching checks.\n */\nint xdl_recs_cmp(diffdata_t *dd1, long off1, long lim1,\n\t\t diffdata_t *dd2, long off2, long lim2,\n\t\t long *kvdf, long *kvdb, int need_min, xdalgoenv_t *xenv) {\n\tunsigned long const *ha1 = dd1->ha, *ha2 = dd2->ha;\n\n\t/*\n\t * Shrink the box by walking through each diagonal snake (SW and NE).\n\t */\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[off1] == ha2[off2]; off1++, off2++);\n\tfor (; off1 < lim1 && off2 < lim2 && ha1[lim1 - 1] == ha2[lim2 - 1]; lim1--, lim2--);\n\n\t/*\n\t * If one dimension is empty, then all records on the other one must\n\t * be obviously changed.\n\t */\n\tif (off1 == lim1) {\n\t\tchar *rchg2 = dd2->rchg;\n\t\tlong *rindex2 = dd2->rindex;\n\n\t\tfor (; off2 < lim2; off2++)\n\t\t\trchg2[rindex2[off2]] = 1;\n\t} else if (off2 == lim2) {\n\t\tchar *rchg1 = dd1->rchg;\n\t\tlong *rindex1 = dd1->rindex;\n\n\t\tfor (; off1 < lim1; off1++)\n\t\t\trchg1[rindex1[off1]] = 1;\n\t} else {\n\t\tlong ec;\n\t\txdpsplit_t spl;\n\n\t\t/*\n\t\t * Divide ...\n\t\t */\n\t\tif ((ec = xdl_split(ha1, off1, lim1, ha2, off2, lim2, kvdf, kvdb,\n\t\t\t\t    need_min, &spl, xenv)) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * ... et Impera.\n\t\t */\n\t\tif (xdl_recs_cmp(dd1, off1, spl.i1, dd2, off2, spl.i2,\n\t\t\t\t kvdf, kvdb, spl.min_lo, xenv) < 0 ||\n\t\t    xdl_recs_cmp(dd1, spl.i1, lim1, dd2, spl.i2, lim2,\n\t\t\t\t kvdf, kvdb, spl.min_hi, xenv) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tlong ndiags;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tndiags = xe->xdf1.nreff + xe->xdf2.nreff + 3;\n\tif (!(kvd = (long *) xdl_malloc((2 * ndiags + 2) * sizeof(long)))) {\n\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}\n\n\nstatic xdchange_t *xdl_add_change(xdchange_t *xscr, long i1, long i2, long chg1, long chg2) {\n\txdchange_t *xch;\n\n\tif (!(xch = (xdchange_t *) xdl_malloc(sizeof(xdchange_t))))\n\t\treturn NULL;\n\n\txch->next = xscr;\n\txch->i1 = i1;\n\txch->i2 = i2;\n\txch->chg1 = chg1;\n\txch->chg2 = chg2;\n\n\treturn xch;\n}\n\n\nstatic int xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joineable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       XDL_RECMATCH(recs[ixs - 1], recs[ix - 1])) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the enf-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       XDL_RECMATCH(recs[ixs], recs[ix])) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded postion in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}\n\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}\n\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xdl_emit_diff(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}\n\n/* END xdiffi.c */\n\n\n/* BEGIN xemit.c */\nstatic long xdl_get_rec(xdfile_t *xdf, long ri, char const **rec) {\n\n\t*rec = xdf->recs[ri]->ptr;\n\n\treturn xdf->recs[ri]->size;\n}\n\n\nstatic int xdl_emit_record(xdfile_t *xdf, long ri, char const *pre, xdemitcb_t *ecb) {\n\tlong size, psize = strlen(pre);\n\tchar const *rec;\n\n\tsize = xdl_get_rec(xdf, ri, &rec);\n\tif (xdl_emit_diffrec(rec, size, pre, psize, ecb) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n/*\n * Starting at the passed change atom, find the latest change atom to be included\n * inside the differential hunk according to the specified configuration.\n */\nstatic xdchange_t *xdl_get_hunk(xdchange_t *xscr, xdemitconf_t const *xecfg) {\n\txdchange_t *xch, *xchp;\n\n\tfor (xchp = xscr, xch = xscr->next; xch; xchp = xch, xch = xch->next)\n\t\tif (xch->i1 - (xchp->i1 + xchp->chg1) > 2 * xecfg->ctxlen)\n\t\t\tbreak;\n\n\treturn xchp;\n}\n\n\nint xdl_emit_diff(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,\n\t\t  xdemitconf_t const *xecfg) {\n\tlong s1, s2, e1, e2, lctx;\n\txdchange_t *xch, *xche;\n\n\tfor (xch = xche = xscr; xch; xch = xche->next) {\n\t\txche = xdl_get_hunk(xch, xecfg);\n\n\t\ts1 = XDL_MAX(xch->i1 - xecfg->ctxlen, 0);\n\t\ts2 = XDL_MAX(xch->i2 - xecfg->ctxlen, 0);\n\n\t\tlctx = xecfg->ctxlen;\n\t\tlctx = XDL_MIN(lctx, xe->xdf1.nrec - (xche->i1 + xche->chg1));\n\t\tlctx = XDL_MIN(lctx, xe->xdf2.nrec - (xche->i2 + xche->chg2));\n\n\t\te1 = xche->i1 + xche->chg1 + lctx;\n\t\te2 = xche->i2 + xche->chg2 + lctx;\n\n\t\t/*\n\t\t * Emit current hunk header.\n\t\t */\n\t\tif (xdl_emit_hunk_hdr(s1 + 1, e1 - s1, s2 + 1, e2 - s2, ecb) < 0)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Emit pre-context.\n\t\t */\n\t\tfor (; s1 < xch->i1; s1++)\n\t\t\tif (xdl_emit_record(&xe->xdf1, s1, \" \", ecb) < 0)\n\t\t\t\treturn -1;\n\n\t\tfor (s1 = xch->i1, s2 = xch->i2;; xch = xch->next) {\n\t\t\t/*\n\t\t\t * Merge previous with current change atom.\n\t\t\t */\n\t\t\tfor (; s1 < xch->i1 && s2 < xch->i2; s1++, s2++)\n\t\t\t\tif (xdl_emit_record(&xe->xdf1, s1, \" \", ecb) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t/*\n\t\t\t * Removes lines from the first file.\n\t\t\t */\n\t\t\tfor (s1 = xch->i1; s1 < xch->i1 + xch->chg1; s1++)\n\t\t\t\tif (xdl_emit_record(&xe->xdf1, s1, \"-\", ecb) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\t/*\n\t\t\t * Adds lines from the second file.\n\t\t\t */\n\t\t\tfor (s2 = xch->i2; s2 < xch->i2 + xch->chg2; s2++)\n\t\t\t\tif (xdl_emit_record(&xe->xdf2, s2, \"+\", ecb) < 0)\n\t\t\t\t\treturn -1;\n\n\t\t\tif (xch == xche)\n\t\t\t\tbreak;\n\t\t\ts1 = xch->i1 + xch->chg1;\n\t\t\ts2 = xch->i2 + xch->chg2;\n\t\t}\n\n\t\t/*\n\t\t * Emit post-context.\n\t\t */\n\t\tfor (s1 = xche->i1 + xche->chg1; s1 < e1; s1++)\n\t\t\tif (xdl_emit_record(&xe->xdf1, s1, \" \", ecb) < 0)\n\t\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* END xemit.c */\n\n\n/* BEGIN xmerge3.c */\n\n#define XDL_MERGE3_BLKSIZE (1024 * 8)\n#define XDL_MERGE3_CTXLEN 3\n\n\n\nint xdl_merge3(mmfile_t *mmfo, mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb,\n\t       xdemitcb_t *rjecb) {\n\txpparam_t xpp;\n\txdemitconf_t xecfg;\n\txdemitcb_t xecb;\n\tmmfile_t mmfp;\n\n\tif (xdl_init_mmfile(&mmfp, XDL_MERGE3_BLKSIZE, XDL_MMF_ATOMIC) < 0) {\n\n\t\treturn -1;\n\t}\n\n\txpp.flags = 0;\n\n\txecfg.ctxlen = XDL_MERGE3_CTXLEN;\n\n\txecb.priv = &mmfp;\n\txecb.outf = xdl_mmfile_outf;\n\n\tif (xdl_diff(mmfo, mmf2, &xpp, &xecfg, &xecb) < 0) {\n\n\t\txdl_free_mmfile(&mmfp);\n\t\treturn -1;\n\t}\n\n\tif (xdl_patch(mmf1, &mmfp, XDL_PATCH_NORMAL, ecb, rjecb) < 0) {\n\n\t\txdl_free_mmfile(&mmfp);\n\t\treturn -1;\n\t}\n\n\txdl_free_mmfile(&mmfp);\n\n\treturn 0;\n}\n\n/* END xmerge3.c */\n\n\n/* BEGIN missing.c */\n\n#if !defined(HAVE_MEMCHR)\n\nvoid *memchr(void const *p, int c, long n) {\n\tchar const *pc = p;\n\n\tfor (; n; n--, pc++)\n\t\tif (*pc == (char) c)\n\t\t\treturn (void*)pc;\n\treturn NULL;\n}\n\n#endif /* #if !defined(HAVE_MEMCHR) */\n\n\n#if !defined(HAVE_MEMCMP)\n\nint memcmp(void const *p1, void const *p2, long n) {\n\tchar const *pc1 = p1, *pc2 = p2;\n\n\tfor (; n; n--, pc1++, pc2++)\n\t\tif (*pc1 != *pc2)\n\t\t\treturn *pc1 - *pc2;\n\treturn 0;\n}\n\n#endif /* #if !defined(HAVE_MEMCMP) */\n\n\n#if !defined(HAVE_MEMCPY)\n\nvoid *memcpy(void *d, void const *s, long n) {\n\tchar *dc = d;\n\tchar const *sc = s;\n\n\tfor (; n; n--, dc++, sc++)\n\t\t*dc = *sc;\n\treturn d;\n}\n\n#endif /* #if !defined(HAVE_MEMCPY) */\n\n\n#if !defined(HAVE_MEMSET)\n\nvoid *memset(void *d, int c, long n) {\n\tchar *dc = d;\n\n\tfor (; n; n--, dc++)\n\t\t*dc = (char) c;\n\treturn d;\n}\n\n#endif /* #if !defined(HAVE_MEMSET) */\n\n\n#if !defined(HAVE_STRLEN)\n\nlong strlen(char const *s) {\n\tchar const *tmp;\n\n\tfor (tmp = s; *s; s++);\n\treturn (long) (s - tmp);\n}\n\n#endif /* #if !defined(HAVE_STRLEN) */\n\n/* END xmissing.c */\n\n\n/* BEGIN xpatchi.c */\n\n#define XDL_MAX_FUZZ 3\n#define XDL_MIN_SYNCLINES 4\n\n\n\ntypedef struct s_recinfo {\n\tchar const *ptr;\n\tlong size;\n} recinfo_t;\n\ntypedef struct s_recfile {\n\tmmfile_t *mf;\n\tlong nrec;\n\trecinfo_t *recs;\n} recfile_t;\n\ntypedef struct s_hunkinfo {\n\tlong s1, s2;\n\tlong c1, c2;\n\tlong cmn, radd, rdel, pctx, sctx;\n} hunkinfo_t;\n\ntypedef struct s_patchstats {\n\tlong adds, dels;\n} patchstats_t;\n\ntypedef struct s_patch {\n\trecfile_t rf;\n\thunkinfo_t hi;\n\tlong hkrec;\n\tlong hklen;\n\tlong flags;\n\tpatchstats_t ps;\n\tint fuzzies;\n} patch_t;\n\n\n\n\nstatic int xdl_load_hunk_info(char const *line, long size, hunkinfo_t *hki);\nstatic int xdl_init_recfile(mmfile_t *mf, int ispatch, recfile_t *rf);\nstatic void xdl_free_recfile(recfile_t *rf);\nstatic char const *xdl_recfile_get(recfile_t *rf, long irec, long *size);\nstatic int xdl_init_patch(mmfile_t *mf, long flags, patch_t *pch);\nstatic void xdl_free_patch(patch_t *pch);\nstatic int xdl_load_hunk(patch_t *pch, long hkrec);\nstatic int xdl_first_hunk(patch_t *pch);\nstatic int xdl_next_hunk(patch_t *pch);\nstatic int xdl_line_match(patch_t *pch, const char *s, long ns, char const *m, long nm);\nstatic int xdl_hunk_match(recfile_t *rf, long irec, patch_t *pch, int mode, int fuzz);\nstatic int xdl_find_hunk(recfile_t *rf, long ibase, patch_t *pch, int mode,\n\t\t\t int fuzz, long *hkpos, int *exact);\nstatic int xdl_emit_rfile_line(recfile_t *rf, long line, xdemitcb_t *ecb);\nstatic int xdl_flush_section(recfile_t *rf, long start, long top, xdemitcb_t *ecb);\nstatic int xdl_apply_hunk(recfile_t *rf, long hkpos, patch_t *pch, int mode,\n\t\t\t  long *ibase, xdemitcb_t *ecb);\nstatic int xdl_reject_hunk(recfile_t *rf, patch_t *pch, int mode,\n\t\t\t   xdemitcb_t *rjecb);\nstatic int xdl_process_hunk(recfile_t *rff, patch_t *pch, long *ibase, int mode,\n\t\t\t    xdemitcb_t *ecb, xdemitcb_t *rjecb);\n\n\n\n\nstatic int xdl_load_hunk_info(char const *line, long size, hunkinfo_t *hki) {\n\tchar const *next;\n\n\t/*\n\t * The diff header format should be:\n\t *\n\t *   @@ -OP,OC +NP,NC @@\n\t *\n\t * Unfortunately some software avoid to emit OP or/and NP in case\n\t * of not existing old or new file (it should be mitted as zero).\n\t * We need to handle both syntaxes.\n\t */\n\tif (memcmp(line, \"@@ -\", 4))\n\t\treturn -1;\n\tline += 4;\n\tsize -= 4;\n\n\tif (!size || !XDL_ISDIGIT(*line))\n\t\treturn -1;\n\thki->s1 = xdl_atol(line, &next);\n\tsize -= next - line;\n\tline = next;\n\tif (!size)\n\t\treturn -1;\n\tif (*line == ',') {\n\t\tsize--, line++;\n\t\tif (!size || !XDL_ISDIGIT(*line))\n\t\t\treturn -1;\n\t\thki->c1 = xdl_atol(line, &next);\n\t\tsize -= next - line;\n\t\tline = next;\n\t\tif (!size || *line != ' ')\n\t\t\treturn -1;\n\t\tsize--, line++;\n\t} else if (*line == ' ') {\n\t\tsize--, line++;\n\t\thki->c1 = hki->s1;\n\t\thki->s1 = 0;\n\t} else\n\t\treturn -1;\n\n\tif (!size || *line != '+')\n\t\treturn -1;\n\tsize--, line++;\n\tif (!size || !XDL_ISDIGIT(*line))\n\t\treturn -1;\n\thki->s2 = xdl_atol(line, &next);\n\tsize -= next - line;\n\tline = next;\n\tif (!size)\n\t\treturn -1;\n\tif (*line == ',') {\n\t\tsize--, line++;\n\t\tif (!size || !XDL_ISDIGIT(*line))\n\t\t\treturn -1;\n\t\thki->c2 = xdl_atol(line, &next);\n\t\tsize -= next - line;\n\t\tline = next;\n\t\tif (!size || *line != ' ')\n\t\t\treturn -1;\n\t\tsize--, line++;\n\t} else if (*line == ' ') {\n\t\tsize--, line++;\n\t\thki->c2 = hki->s2;\n\t\thki->s2 = 0;\n\t} else\n\t\treturn -1;\n\tif (size < 2 || memcmp(line, \"@@\", 2) != 0)\n\t\treturn -1;\n\n\t/*\n\t * We start from zero, so decrement by one unless it's the special position\n\t * '0' inside the unified diff (new or deleted file).\n\t */\n\tif (hki->s1 > 0 && hki->c1 > 0)\n\t\thki->s1--;\n\tif (hki->s2 > 0 && hki->c2 > 0)\n\t\thki->s2--;\n\n\treturn 0;\n}\n\n\nstatic int xdl_init_recfile(mmfile_t *mf, int ispatch, recfile_t *rf) {\n\tlong narec, nrec, bsize;\n\trecinfo_t *recs, *rrecs;\n\tchar const *blk, *cur, *top, *eol;\n\n\tnarec = xdl_guess_lines(mf);\n\tif (!(recs = (recinfo_t *) xdl_malloc(narec * sizeof(recinfo_t)))) {\n\n\t\treturn -1;\n\t}\n\tnrec = 0;\n\tif ((cur = blk = (char const*) xdl_mmfile_first(mf, &bsize)) != NULL) {\n\t\tfor (top = blk + bsize;;) {\n\t\t\tif (cur >= top) {\n\t\t\t\tif (!(cur = blk = (char const*) xdl_mmfile_next(mf, &bsize)))\n\t\t\t\t\tbreak;\n\t\t\t\ttop = blk + bsize;\n\t\t\t}\n\t\t\tif (nrec >= narec) {\n\t\t\t\tnarec *= 2;\n\t\t\t\tif (!(rrecs = (recinfo_t *)\n\t\t\t\t      xdl_realloc(recs, narec * sizeof(recinfo_t)))) {\n\n\t\t\t\t\txdl_free(recs);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\trecs = rrecs;\n\t\t\t}\n\t\t\trecs[nrec].ptr = cur;\n\t\t\tif (!(eol = (char const*) memchr(cur, '\\n', top - cur)))\n\t\t\t\teol = top - 1;\n\t\t\trecs[nrec].size = (long) (eol - cur) + 1;\n\t\t\tif (ispatch && *cur == '\\\\' && nrec > 0 && recs[nrec - 1].size > 0 &&\n\t\t\t    recs[nrec - 1].ptr[recs[nrec - 1].size - 1] == '\\n')\n\t\t\t\trecs[nrec - 1].size--;\n\t\t\telse\n\t\t\t\tnrec++;\n\t\t\tcur = eol + 1;\n\t\t}\n\t}\n\trf->mf = mf;\n\trf->nrec = nrec;\n\trf->recs = recs;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_recfile(recfile_t *rf) {\n\n\txdl_free(rf->recs);\n}\n\n\nstatic char const *xdl_recfile_get(recfile_t *rf, long irec, long *size) {\n\n\tif (irec < 0 || irec >= rf->nrec)\n\t\treturn NULL;\n\t*size = rf->recs[irec].size;\n\n\treturn rf->recs[irec].ptr;\n}\n\n\nstatic int xdl_init_patch(mmfile_t *mf, long flags, patch_t *pch) {\n\n\tif (xdl_init_recfile(mf, 1, &pch->rf) < 0) {\n\n\t\treturn -1;\n\t}\n\tpch->hkrec = 0;\n\tpch->hklen = 0;\n\tpch->flags = flags;\n\tpch->ps.adds = pch->ps.dels = 0;\n\tpch->fuzzies = 0;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_patch(patch_t *pch) {\n\n\txdl_free_recfile(&pch->rf);\n}\n\n\nstatic int xdl_load_hunk(patch_t *pch, long hkrec) {\n\tlong size, i, nb;\n\tchar const *line;\n\n\tfor (;; hkrec++) {\n\t\tpch->hkrec = hkrec;\n\t\tif (!(line = xdl_recfile_get(&pch->rf, pch->hkrec, &size)))\n\t\t\treturn 0;\n\t\tif (*line == '@')\n\t\t\tbreak;\n\t}\n\tif (xdl_load_hunk_info(line, size, &pch->hi) < 0) {\n\n\t\treturn -1;\n\t}\n\tpch->hi.cmn = pch->hi.radd = pch->hi.rdel = pch->hi.pctx = pch->hi.sctx = 0;\n\tfor (i = pch->hkrec + 1, nb = 0;\n\t     (line = xdl_recfile_get(&pch->rf, i, &size)) != NULL; i++) {\n\t\tif (*line == '@' || *line == '\\n')\n\t\t\tbreak;\n\t\tif (*line == ' ') {\n\t\t\tnb++;\n\t\t\tpch->hi.cmn++;\n\t\t} else if (*line == '+') {\n\t\t\tif (pch->hi.radd + pch->hi.rdel == 0)\n\t\t\t\tpch->hi.pctx = nb;\n\t\t\tnb = 0;\n\t\t\tpch->hi.radd++;\n\t\t} else if (*line == '-') {\n\t\t\tif (pch->hi.radd + pch->hi.rdel == 0)\n\t\t\t\tpch->hi.pctx = nb;\n\t\t\tnb = 0;\n\t\t\tpch->hi.rdel++;\n\t\t} else {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\tpch->hi.sctx = nb;\n\tif (pch->hi.cmn + pch->hi.radd != pch->hi.c2 ||\n\t    pch->hi.cmn + pch->hi.rdel != pch->hi.c1) {\n\n\t\treturn -1;\n\t}\n\tpch->hklen = i - pch->hkrec - 1;\n\n\treturn 1;\n}\n\n\nstatic int xdl_first_hunk(patch_t *pch) {\n\n\treturn xdl_load_hunk(pch, 0);\n}\n\n\nstatic int xdl_next_hunk(patch_t *pch) {\n\n\treturn xdl_load_hunk(pch, pch->hkrec + pch->hklen + 1);\n}\n\n\nstatic int xdl_line_match(patch_t *pch, const char *s, long ns, char const *m, long nm) {\n\n\tfor (; ns > 0 && (s[ns - 1] == '\\r' || s[ns - 1] == '\\n'); ns--);\n\tfor (; nm > 0 && (m[nm - 1] == '\\r' || m[nm - 1] == '\\n'); nm--);\n\tif (pch->flags & XDL_PATCH_IGNOREBSPACE) {\n\t\tfor (; ns > 0 && (*s == ' ' || *s == '\\t'); ns--, s++);\n\t\tfor (; ns > 0 && (s[ns - 1] == ' ' || s[ns - 1] == '\\t'); ns--);\n\t\tfor (; nm > 0 && (*m == ' ' || *m == '\\t'); nm--, m++);\n\t\tfor (; nm > 0 && (m[nm - 1] == ' ' || m[nm - 1] == '\\t'); nm--);\n\t}\n\n\treturn ns == nm && memcmp(s, m, ns) == 0;\n}\n\n\nstatic int xdl_hunk_match(recfile_t *rf, long irec, patch_t *pch, int mode, int fuzz) {\n\tlong i, j, z, fsize, psize, ptop, pfuzz, sfuzz, misses;\n\tchar const *fline, *pline;\n\n\t/*\n\t * Limit fuzz to not be greater than the prefix and suffix context.\n\t */\n\tpfuzz = fuzz < pch->hi.pctx ? fuzz: pch->hi.pctx;\n\tsfuzz = fuzz < pch->hi.sctx ? fuzz: pch->hi.sctx;\n\n\t/*\n\t * First loop through the prefix fuzz area. In this loop we simply\n\t * note mismatching lines. We allow missing lines here, that is,\n\t * some prefix context lines are missing.\n\t */\n\tfor (z = pfuzz, misses = 0, i = irec, j = pch->hkrec + 1,\n\t     ptop = pch->hkrec + 1 + pch->hklen - sfuzz;\n\t     z > 0 && i < rf->nrec && j < ptop; i++, j++, z--) {\n\t\tif (!(pline = xdl_recfile_get(&pch->rf, j, &psize)))\n\t\t\treturn 0;\n\t\tif (!(fline = xdl_recfile_get(rf, i, &fsize)) ||\n\t\t    !xdl_line_match(pch, fline, fsize, pline + 1, psize - 1))\n\t\t\tmisses++;\n\t}\n\tif (misses > fuzz)\n\t\treturn 0;\n\n\t/*\n\t * Strict match loop.\n\t */\n\tfor (; i < rf->nrec && j < ptop; i++, j++) {\n\t\tfor (; j < ptop; j++) {\n\t\t\tif (!(pline = xdl_recfile_get(&pch->rf, j, &psize)))\n\t\t\t\treturn 0;\n\t\t\tif (*pline == ' ' || *pline == mode)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == ptop)\n\t\t\tbreak;\n\t\tif (!(fline = xdl_recfile_get(rf, i, &fsize)) ||\n\t\t    !xdl_line_match(pch, fline, fsize, pline + 1, psize - 1))\n\t\t\treturn 0;\n\t}\n\tfor (; j < ptop; j++)\n\t\tif (!(pline = xdl_recfile_get(&pch->rf, j, &psize)) ||\n\t\t    *pline == ' ' || *pline == mode)\n\t\t\treturn 0;\n\n\t/*\n\t * Finally loop through the suffix fuzz area. In this loop we simply\n\t * note mismatching lines. We allow missing lines here, that is,\n\t * some suffix context lines are missing.\n\t */\n\tfor (z = sfuzz; z > 0 && i < rf->nrec; i++, j++, z--) {\n\t\tif (!(pline = xdl_recfile_get(&pch->rf, j, &psize)))\n\t\t\treturn 0;\n\t\tif (!(fline = xdl_recfile_get(rf, i, &fsize)) ||\n\t\t    !xdl_line_match(pch, fline, fsize, pline + 1, psize - 1))\n\t\t\tmisses++;\n\t}\n\n\treturn misses <= fuzz;\n}\n\n\nstatic int xdl_find_hunk(recfile_t *rf, long ibase, patch_t *pch, int mode,\n\t\t\t int fuzz, long *hkpos, int *exact) {\n\tlong hpos, hlen, i, j;\n\tlong pos[2];\n\n\thpos = mode == '-' ? pch->hi.s1: pch->hi.s2;\n\thlen = mode == '-' ? pch->hi.cmn + pch->hi.rdel: pch->hi.cmn + pch->hi.radd;\n\tif (xdl_hunk_match(rf, hpos, pch, mode, fuzz)) {\n\t\t*hkpos = hpos;\n\t\t*exact = 1;\n\t\treturn 1;\n\t}\n\tfor (i = 1;; i++) {\n\t\t/*\n\t\t * We allow a negative starting hunk position, up to the\n\t\t * number of prefix context lines.\n\t\t */\n\t\tj = 0;\n\t\tif (hpos - i >= ibase - pch->hi.pctx)\n\t\t\tpos[j++] = hpos - i;\n\t\tif (hpos + i + hlen <= rf->nrec)\n\t\t\tpos[j++] = hpos + i;\n\t\tif (!j)\n\t\t\tbreak;\n\t\tfor (j--; j >= 0; j--)\n\t\t\tif (xdl_hunk_match(rf, pos[j], pch, mode, fuzz)) {\n\t\t\t\t*hkpos = pos[j];\n\t\t\t\t*exact = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int xdl_emit_rfile_line(recfile_t *rf, long line, xdemitcb_t *ecb) {\n\tmmbuffer_t mb;\n\n\tif (!(mb.ptr = (char *) xdl_recfile_get(rf, line, &mb.size)) ||\n\t    ecb->outf(ecb->priv, &mb, 1) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int xdl_flush_section(recfile_t *rf, long start, long top, xdemitcb_t *ecb) {\n\tlong i;\n\n\tfor (i = start; i <= top; i++) {\n\t\tif (xdl_emit_rfile_line(rf, i, ecb) < 0) {\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int xdl_apply_hunk(recfile_t *rf, long hkpos, patch_t *pch, int mode,\n\t\t\t  long *ibase, xdemitcb_t *ecb) {\n\tlong j, psize, ptop;\n\tchar const *pline;\n\tmmbuffer_t mb;\n\n\t/*\n\t * The hunk starting position (hkpos) can be negative, up to the number\n\t * of prefix context lines. Since this function only emit the core of\n\t * the hunk (the remaining lines are flushed by xdl_flush_section() calls)\n\t * we need to normalize it by adding the number of prefix context lines.\n\t * The normalized value of the starting position is then greater/equal\n\t * to zero.\n\t */\n\thkpos += pch->hi.pctx;\n\tif (xdl_flush_section(rf, *ibase, hkpos - 1, ecb) < 0) {\n\n\t\treturn -1;\n\t}\n\t*ibase = hkpos;\n\tfor (j = pch->hkrec + 1 + pch->hi.pctx,\n\t     ptop = pch->hkrec + 1 + pch->hklen - pch->hi.sctx; j < ptop; j++) {\n\t\tif (!(pline = xdl_recfile_get(&pch->rf, j, &psize))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\tif (*pline == ' ') {\n\t\t\tif (xdl_emit_rfile_line(rf, *ibase, ecb) < 0) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t(*ibase)++;\n\t\t} else if (*pline != mode) {\n\t\t\tmb.ptr = (char *) pline + 1;\n\t\t\tmb.size = psize - 1;\n\t\t\tif (ecb->outf(ecb->priv, &mb, 1) < 0) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpch->ps.adds++;\n\t\t} else {\n\t\t\t(*ibase)++;\n\t\t\tpch->ps.dels++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int xdl_reject_hunk(recfile_t *rf, patch_t *pch, int mode,\n\t\t\t   xdemitcb_t *rjecb) {\n\tlong i, size, s1, s2, c1, c2;\n\tchar const *line, *pre;\n\tmmbuffer_t mb;\n\n\tif (mode == '-') {\n\t\ts1 = pch->hi.s1;\n\t\ts2 = pch->hi.s2;\n\t\tc1 = pch->hi.c1;\n\t\tc2 = pch->hi.c2;\n\t} else {\n\t\ts1 = pch->hi.s2;\n\t\ts2 = pch->hi.s1;\n\t\tc1 = pch->hi.c2;\n\t\tc2 = pch->hi.c1;\n\t}\n\ts1 += pch->ps.adds - pch->ps.dels;\n\tif (xdl_emit_hunk_hdr(s1 + 1, c1, s2 + 1, c2, rjecb) < 0) {\n\n\t\treturn -1;\n\t}\n\tfor (i = pch->hkrec + 1;\n\t     (line = xdl_recfile_get(&pch->rf, i, &size)) != NULL; i++) {\n\t\tif (*line == '@' || *line == '\\n')\n\t\t\tbreak;\n\t\tif (mode == '-' || *line == ' ') {\n\t\t\tmb.ptr = (char *) line;\n\t\t\tmb.size = size;\n\t\t\tif (rjecb->outf(rjecb->priv, &mb, 1) < 0) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tpre = *line == '+' ? \"-\": \"+\";\n\t\t\tif (xdl_emit_diffrec(line + 1, size - 1, pre, strlen(pre),\n\t\t\t\t\t     rjecb) < 0) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int xdl_process_hunk(recfile_t *rff, patch_t *pch, long *ibase, int mode,\n\t\t\t    xdemitcb_t *ecb, xdemitcb_t *rjecb) {\n\tint fuzz, exact, hlen, maxfuzz;\n\tlong hkpos;\n\n\thlen = mode == '-' ? pch->hi.cmn + pch->hi.rdel: pch->hi.cmn + pch->hi.radd;\n\tmaxfuzz = XDL_MAX_FUZZ;\n\tif (hlen - maxfuzz < XDL_MIN_SYNCLINES)\n\t\tmaxfuzz = hlen - XDL_MIN_SYNCLINES;\n\tif (maxfuzz < 0)\n\t\tmaxfuzz = 0;\n\tfor (fuzz = 0; fuzz <= maxfuzz; fuzz++) {\n\t\tif (xdl_find_hunk(rff, *ibase, pch, mode, fuzz,\n\t\t\t\t  &hkpos, &exact)) {\n\t\t\tif (xdl_apply_hunk(rff, hkpos, pch, mode,\n\t\t\t\t\t   ibase, ecb) < 0) {\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!exact || fuzz)\n\t\t\t\tpch->fuzzies++;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (xdl_reject_hunk(rff, pch, mode, rjecb) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_patch(mmfile_t *mf, mmfile_t *mfp, int mode, xdemitcb_t *ecb,\n\t      xdemitcb_t *rjecb) {\n\tint hkres, exact;\n\tlong hkpos, ibase;\n\trecfile_t rff;\n\tpatch_t pch;\n\n\tif (xdl_init_recfile(mf, 0, &rff) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_init_patch(mfp, mode & ~XDL_PATCH_MODEMASK, &pch) < 0) {\n\n\t\txdl_free_recfile(&rff);\n\t\treturn -1;\n\t}\n\tmode &= XDL_PATCH_MODEMASK;\n\tibase = 0;\n\tif ((hkres = xdl_first_hunk(&pch)) > 0) {\n\t\tdo {\n\t\t\tif (xdl_process_hunk(&rff, &pch, &ibase, mode,\n\t\t\t\t\t     ecb, rjecb) < 0) {\n\t\t\t\txdl_free_patch(&pch);\n\t\t\t\txdl_free_recfile(&rff);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} while ((hkres = xdl_next_hunk(&pch)) > 0);\n\t}\n\tif (hkres < 0) {\n\n\t\txdl_free_patch(&pch);\n\t\txdl_free_recfile(&rff);\n\t\treturn -1;\n\t}\n\tif (xdl_flush_section(&rff, ibase, rff.nrec - 1, ecb) < 0) {\n\n\t\txdl_free_patch(&pch);\n\t\txdl_free_recfile(&rff);\n\t\treturn -1;\n\t}\n\txdl_free_patch(&pch);\n\txdl_free_recfile(&rff);\n\n\treturn pch.fuzzies;\n}\n\n/* END xpatchi.c */\n\n\n/* BEGIN xprepare.c */\n\n#define XDL_KPDIS_RUN 4\n#define XDL_MAX_EQLIMIT 1024\n#define XDL_SIMSCAN_WINDOWN 100\n\n\ntypedef struct s_xdlclass {\n\tstruct s_xdlclass *next;\n\tunsigned long ha;\n\tchar const *line;\n\tlong size;\n\tlong idx;\n} xdlclass_t;\n\ntypedef struct s_xdlclassifier {\n\tunsigned int hbits;\n\tlong hsize;\n\txdlclass_t **rchash;\n\tchastore_t ncha;\n\tlong count;\n} xdlclassifier_t;\n\n\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size) {\n\tlong i;\n\n\tcf->hbits = xdl_hashbits((unsigned int) size);\n\tcf->hsize = 1 << cf->hbits;\n\n\tif (xdl_cha_init(&cf->ncha, sizeof(xdlclass_t), size / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(cf->rchash = (xdlclass_t **) xdl_malloc(cf->hsize * sizeof(xdlclass_t *)))) {\n\n\t\txdl_cha_free(&cf->ncha);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cf->hsize; i++)\n\t\tcf->rchash[i] = NULL;\n\n\tcf->count = 0;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_classifier(xdlclassifier_t *cf) {\n\txdl_free(cf->rchash);\n\txdl_cha_free(&cf->ncha);\n}\n\n\nstatic int xdl_classify_record(xdlclassifier_t *cf, xrecord_t **rhash, unsigned int hbits,\n\t\t\t       xrecord_t *rec) {\n\tlong hi;\n\tchar const *line;\n\txdlclass_t *rcrec;\n\n\tline = rec->ptr;\n\thi = (long) XDL_HASHLONG(rec->ha, cf->hbits);\n\tfor (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)\n\t\tif (rcrec->ha == rec->ha && rcrec->size == rec->size &&\n\t\t    !memcmp(line, rcrec->line, rec->size))\n\t\t\tbreak;\n\n\tif (!rcrec) {\n\t\tif (!(rcrec = (xdlclass_t*) xdl_cha_alloc(&cf->ncha))) {\n\n\t\t\treturn -1;\n\t\t}\n\t\trcrec->idx = cf->count++;\n\t\trcrec->line = line;\n\t\trcrec->size = rec->size;\n\t\trcrec->ha = rec->ha;\n\t\trcrec->next = cf->rchash[hi];\n\t\tcf->rchash[hi] = rcrec;\n\t}\n\n\trec->ha = (unsigned long) rcrec->idx;\n\n\thi = (long) XDL_HASHLONG(rec->ha, hbits);\n\trec->next = rhash[hi];\n\trhash[hi] = rec;\n\n\treturn 0;\n}\n\n\nstatic int xdl_prepare_ctx(mmfile_t *mf, long narec, xpparam_t const *xpp,\n\t\t\t   xdlclassifier_t *cf, xdfile_t *xdf) {\n\tunsigned int hbits;\n\tlong i, nrec, hsize, bsize;\n\tunsigned long hav;\n\tchar const *blk, *cur, *top, *prev;\n\txrecord_t *crec;\n\txrecord_t **recs, **rrecs;\n\txrecord_t **rhash;\n\tunsigned long *ha;\n\tchar *rchg;\n\tlong *rindex;\n\n\tif (xdl_cha_init(&xdf->rcha, sizeof(xrecord_t), narec / 4 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(recs = (xrecord_t **) xdl_malloc(narec * sizeof(xrecord_t *)))) {\n\n\t\txdl_cha_free(&xdf->rcha);\n\t\treturn -1;\n\t}\n\n\thbits = xdl_hashbits((unsigned int) narec);\n\thsize = 1 << hbits;\n\tif (!(rhash = (xrecord_t **) xdl_malloc(hsize * sizeof(xrecord_t *)))) {\n\n\t\txdl_free(recs);\n\t\txdl_cha_free(&xdf->rcha);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < hsize; i++)\n\t\trhash[i] = NULL;\n\n\tnrec = 0;\n\tif ((cur = blk = (char const*) xdl_mmfile_first(mf, &bsize)) != NULL) {\n\t\tfor (top = blk + bsize;;) {\n\t\t\tif (cur >= top) {\n\t\t\t\tif (!(cur = blk = (char const*) xdl_mmfile_next(mf, &bsize)))\n\t\t\t\t\tbreak;\n\t\t\t\ttop = blk + bsize;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\thav = xdl_hash_record(&cur, top);\n\t\t\tif (nrec >= narec) {\n\t\t\t\tnarec *= 2;\n\t\t\t\tif (!(rrecs = (xrecord_t **) xdl_realloc(recs, narec * sizeof(xrecord_t *)))) {\n\n\t\t\t\t\txdl_free(rhash);\n\t\t\t\t\txdl_free(recs);\n\t\t\t\t\txdl_cha_free(&xdf->rcha);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\trecs = rrecs;\n\t\t\t}\n\t\t\tif (!(crec = (xrecord_t*) xdl_cha_alloc(&xdf->rcha))) {\n\n\t\t\t\txdl_free(rhash);\n\t\t\t\txdl_free(recs);\n\t\t\t\txdl_cha_free(&xdf->rcha);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcrec->ptr = prev;\n\t\t\tcrec->size = (long) (cur - prev);\n\t\t\tcrec->ha = hav;\n\t\t\trecs[nrec++] = crec;\n\n\t\t\tif (xdl_classify_record(cf, rhash, hbits, crec) < 0) {\n\n\t\t\t\txdl_free(rhash);\n\t\t\t\txdl_free(recs);\n\t\t\t\txdl_cha_free(&xdf->rcha);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(rchg = (char *) xdl_malloc(nrec + 2))) {\n\n\t\txdl_free(rhash);\n\t\txdl_free(recs);\n\t\txdl_cha_free(&xdf->rcha);\n\t\treturn -1;\n\t}\n\tmemset(rchg, 0, nrec + 2);\n\n\tif (!(rindex = (long *) xdl_malloc((nrec + 1) * sizeof(long)))) {\n\n\t\txdl_free(rchg);\n\t\txdl_free(rhash);\n\t\txdl_free(recs);\n\t\txdl_cha_free(&xdf->rcha);\n\t\treturn -1;\n\t}\n\tif (!(ha = (unsigned long *) xdl_malloc((nrec + 1) * sizeof(unsigned long)))) {\n\n\t\txdl_free(rindex);\n\t\txdl_free(rchg);\n\t\txdl_free(rhash);\n\t\txdl_free(recs);\n\t\txdl_cha_free(&xdf->rcha);\n\t\treturn -1;\n\t}\n\n\txdf->nrec = nrec;\n\txdf->recs = recs;\n\txdf->hbits = hbits;\n\txdf->rhash = rhash;\n\txdf->rchg = rchg + 1;\n\txdf->rindex = rindex;\n\txdf->nreff = 0;\n\txdf->ha = ha;\n\txdf->dstart = 0;\n\txdf->dend = nrec - 1;\n\n\treturn 0;\n}\n\n\nstatic void xdl_free_ctx(xdfile_t *xdf) {\n\txdl_free(xdf->rhash);\n\txdl_free(xdf->rindex);\n\txdl_free(xdf->rchg - 1);\n\txdl_free(xdf->ha);\n\txdl_free(xdf->recs);\n\txdl_cha_free(&xdf->rcha);\n}\n\n\nstatic int xdl_clean_mmatch(char const *dis, long i, long s, long e) {\n\tlong r, rdis0, rpdis0, rdis1, rpdis1;\n\n\t/*\n\t * Limits the window the is examined during the similar-lines\n\t * scan. The loops below stops when dis[i - r] == 1 (line that\n\t * has no match), but there are corner cases where the loop\n\t * proceed all the way to the extremities by causing huge\n\t * performance penalties in case of big files.\n\t */\n\tif (i - s > XDL_SIMSCAN_WINDOWN)\n\t\ts = i - XDL_SIMSCAN_WINDOWN;\n\tif (e - i > XDL_SIMSCAN_WINDOWN)\n\t\te = i + XDL_SIMSCAN_WINDOWN;\n\n\t/*\n\t * Scans the lines before 'i' to find a run of lines that either\n\t * have no match (dis[j] == 0) or have multiple matches (dis[j] > 1).\n\t * Note that we always call this function with dis[i] > 1, so the\n\t * current line (i) is already a multimatch line.\n\t */\n\tfor (r = 1, rdis0 = 0, rpdis0 = 1; (i - r) >= s; r++) {\n\t\tif (!dis[i - r])\n\t\t\trdis0++;\n\t\telse if (dis[i - r] == 2)\n\t\t\trpdis0++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run before the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t * We want to discard multimatch lines only when they appear in the\n\t * middle of runs with nomatch lines (dis[j] == 0).\n\t */\n\tif (rdis0 == 0)\n\t\treturn 0;\n\tfor (r = 1, rdis1 = 0, rpdis1 = 1; (i + r) <= e; r++) {\n\t\tif (!dis[i + r])\n\t\t\trdis1++;\n\t\telse if (dis[i + r] == 2)\n\t\t\trpdis1++;\n\t\telse\n\t\t\tbreak;\n\t}\n\t/*\n\t * If the run after the line 'i' found only multimatch lines, we\n\t * return 0 and hence we don't make the current line (i) discarded.\n\t */\n\tif (rdis1 == 0)\n\t\treturn 0;\n\trdis1 += rdis0;\n\trpdis1 += rpdis0;\n\n\treturn rpdis1 * XDL_KPDIS_RUN < (rpdis1 + rdis1);\n}\n\n\n/*\n * Try to reduce the problem complexity, discard records that have no\n * matches on the other file. Also, lines that have multiple matches\n * might be potentially discarded if they happear in a run of discardable.\n */\nstatic int xdl_cleanup_records(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, nm, rhi, nreff, mlim;\n\tunsigned long hav;\n\txrecord_t **recs;\n\txrecord_t *rec;\n\tchar *dis, *dis1, *dis2;\n\n\tif (!(dis = (char *) xdl_malloc(xdf1->nrec + xdf2->nrec + 2))) {\n\n\t\treturn -1;\n\t}\n\tmemset(dis, 0, xdf1->nrec + xdf2->nrec + 2);\n\tdis1 = dis;\n\tdis2 = dis1 + xdf1->nrec + 1;\n\n\tif ((mlim = xdl_bogosqrt(xdf1->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart]; i <= xdf1->dend; i++, recs++) {\n\t\thav = (*recs)->ha;\n\t\trhi = (long) XDL_HASHLONG(hav, xdf2->hbits);\n\t\tfor (nm = 0, rec = xdf2->rhash[rhi]; rec; rec = rec->next)\n\t\t\tif (rec->ha == hav && ++nm == mlim)\n\t\t\t\tbreak;\n\t\tdis1[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tif ((mlim = xdl_bogosqrt(xdf2->nrec)) > XDL_MAX_EQLIMIT)\n\t\tmlim = XDL_MAX_EQLIMIT;\n\tfor (i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart]; i <= xdf2->dend; i++, recs++) {\n\t\thav = (*recs)->ha;\n\t\trhi = (long) XDL_HASHLONG(hav, xdf1->hbits);\n\t\tfor (nm = 0, rec = xdf1->rhash[rhi]; rec; rec = rec->next)\n\t\t\tif (rec->ha == hav && ++nm == mlim)\n\t\t\t\tbreak;\n\t\tdis2[i] = (nm == 0) ? 0: (nm >= mlim) ? 2: 1;\n\t}\n\n\tfor (nreff = 0, i = xdf1->dstart, recs = &xdf1->recs[xdf1->dstart];\n\t     i <= xdf1->dend; i++, recs++) {\n\t\tif (dis1[i] == 1 ||\n\t\t    (dis1[i] == 2 && !xdl_clean_mmatch(dis1, i, xdf1->dstart, xdf1->dend))) {\n\t\t\txdf1->rindex[nreff] = i;\n\t\t\txdf1->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf1->rchg[i] = 1;\n\t}\n\txdf1->nreff = nreff;\n\n\tfor (nreff = 0, i = xdf2->dstart, recs = &xdf2->recs[xdf2->dstart];\n\t     i <= xdf2->dend; i++, recs++) {\n\t\tif (dis2[i] == 1 ||\n\t\t    (dis2[i] == 2 && !xdl_clean_mmatch(dis2, i, xdf2->dstart, xdf2->dend))) {\n\t\t\txdf2->rindex[nreff] = i;\n\t\t\txdf2->ha[nreff] = (*recs)->ha;\n\t\t\tnreff++;\n\t\t} else\n\t\t\txdf2->rchg[i] = 1;\n\t}\n\txdf2->nreff = nreff;\n\n\txdl_free(dis);\n\n\treturn 0;\n}\n\n\n/*\n * Early trim initial and terminal matching records.\n */\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tlong i, lim;\n\txrecord_t **recs1, **recs2;\n\n\trecs1 = xdf1->recs;\n\trecs2 = xdf2->recs;\n\tfor (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;\n\t     i++, recs1++, recs2++)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dstart = xdf2->dstart = i;\n\n\trecs1 = xdf1->recs + xdf1->nrec - 1;\n\trecs2 = xdf2->recs + xdf2->nrec - 1;\n\tfor (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)\n\t\tif ((*recs1)->ha != (*recs2)->ha)\n\t\t\tbreak;\n\n\txdf1->dend = xdf1->nrec - i - 1;\n\txdf2->dend = xdf2->nrec - i - 1;\n\n\treturn 0;\n}\n\n\nstatic int xdl_optimize_ctxs(xdfile_t *xdf1, xdfile_t *xdf2) {\n\tif (xdl_trim_ends(xdf1, xdf2) < 0 ||\n\t    xdl_cleanup_records(xdf1, xdf2) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2;\n\txdlclassifier_t cf;\n\n\tenl1 = xdl_guess_lines(mf1) + 1;\n\tenl2 = xdl_guess_lines(mf2) + 1;\n\n\tif (xdl_init_classifier(&cf, enl1 + enl2 + 1) < 0) {\n\n\t\treturn -1;\n\t}\n\n\tif (xdl_prepare_ctx(mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\txdl_free_classifier(&cf);\n\n\tif (xdl_optimize_ctxs(&xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}\n\n/* END xprepare.c */\n\n\n\n/* BEGIN xrabdiff.c */\n\n/*\n *  xrabdiff by Davide Libenzi (Rabin's polynomial fingerprint based delta generator)\n *  Copyright (C) 2006  Davide Libenzi\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  Davide Libenzi <davidel@xmailserver.org>\n *\n *\n *  Hints, ideas and code for the implementation came from:\n *\n *  Rabin's original paper: http://www.xmailserver.org/rabin.pdf\n *  Chan & Lu's paper:      http://www.xmailserver.org/rabin_impl.pdf\n *  Broder's paper:         http://www.xmailserver.org/rabin_apps.pdf\n *  LBFS source code:       http://www.fs.net/sfswww/lbfs/\n *  Geert Bosch's post:     http://marc.theaimsgroup.com/?l=git&m=114565424620771&w=2\n *\n */\n\n/* #include \"xinclude.h\" */\n\n\n#if !defined(XRABPLY_TYPE32) && !defined(XRABPLY_TYPE64)\n#define XRABPLY_TYPE64 long long\n#define XV64(v) ((xply_word) v ## ULL)\n#endif\n\n//#include \"xrabply.c\"\n/* BEGIN xrabply.c */\n\n#if defined(XRABPLY_TYPE64)\n\n#if !defined(XV64)\n#define XV64(v) ((xply_word) v ## ULL)\n#endif\n\n#define XRAB_ROOTPOLY XV64(0x36f7381af4d70d33)\n\n#define XRAB_SHIFT 53\n#define XRAB_WNDSIZE 20\n\ntypedef unsigned XRABPLY_TYPE64 xply_word;\n\nstatic const xply_word T[256] = {\n\tXV64(0x0), XV64(0x36f7381af4d70d33), XV64(0x5b19482f1d791755), XV64(0x6dee7035e9ae1a66),\n\tXV64(0x80c5a844ce252399), XV64(0xb632905e3af22eaa), XV64(0xdbdce06bd35c34cc), XV64(0xed2bd871278b39ff),\n\tXV64(0x18b50899c4a4732), XV64(0x377c6893689d4a01), XV64(0x5a9218a681335067), XV64(0x6c6520bc75e45d54),\n\tXV64(0x814ef8cd526f64ab), XV64(0xb7b9c0d7a6b86998), XV64(0xda57b0e24f1673fe), XV64(0xeca088f8bbc17ecd),\n\tXV64(0x316a11338948e64), XV64(0x35e19909cc438357), XV64(0x580fe93c25ed9931), XV64(0x6ef8d126d13a9402),\n\tXV64(0x83d30957f6b1adfd), XV64(0xb524314d0266a0ce), XV64(0xd8ca4178ebc8baa8), XV64(0xee3d79621f1fb79b),\n\tXV64(0x29df19aa4dec956), XV64(0x346ac9805009c465), XV64(0x5984b9b5b9a7de03), XV64(0x6f7381af4d70d330),\n\tXV64(0x825859de6afbeacf), XV64(0xb4af61c49e2ce7fc), XV64(0xd94111f17782fd9a), XV64(0xefb629eb8355f0a9),\n\tXV64(0x62d422671291cc8), XV64(0x30da7a3c85fe11fb), XV64(0x5d340a096c500b9d), XV64(0x6bc33213988706ae),\n\tXV64(0x86e8ea62bf0c3f51), XV64(0xb01fd2784bdb3262), XV64(0xddf1a24da2752804), XV64(0xeb069a5756a22537),\n\tXV64(0x7a612afed635bfa), XV64(0x31512ab519b456c9), XV64(0x5cbf5a80f01a4caf), XV64(0x6a48629a04cd419c),\n\tXV64(0x8763baeb23467863), XV64(0xb19482f1d7917550), XV64(0xdc7af2c43e3f6f36), XV64(0xea8dcadecae86205),\n\tXV64(0x53be33549bd92ac), XV64(0x33ccdb2fbd6a9f9f), XV64(0x5e22ab1a54c485f9), XV64(0x68d59300a01388ca),\n\tXV64(0x85fe4b718798b135), XV64(0xb309736b734fbc06), XV64(0xdee7035e9ae1a660), XV64(0xe8103b446e36ab53),\n\tXV64(0x4b0b3bcd5f7d59e), XV64(0x32478ba62120d8ad), XV64(0x5fa9fb93c88ec2cb), XV64(0x695ec3893c59cff8),\n\tXV64(0x84751bf81bd2f607), XV64(0xb28223e2ef05fb34), XV64(0xdf6c53d706abe152), XV64(0xe99b6bcdf27cec61),\n\tXV64(0xc5a844ce2523990), XV64(0x3aadbc56168534a3), XV64(0x5743cc63ff2b2ec5), XV64(0x61b4f4790bfc23f6),\n\tXV64(0x8c9f2c082c771a09), XV64(0xba681412d8a0173a), XV64(0xd7866427310e0d5c), XV64(0xe1715c3dc5d9006f),\n\tXV64(0xdd1d4c57e187ea2), XV64(0x3b26ecdf8acf7391), XV64(0x56c89cea636169f7), XV64(0x603fa4f097b664c4),\n\tXV64(0x8d147c81b03d5d3b), XV64(0xbbe3449b44ea5008), XV64(0xd60d34aead444a6e), XV64(0xe0fa0cb45993475d),\n\tXV64(0xf4c255fdac6b7f4), XV64(0x39bb1d452e11bac7), XV64(0x54556d70c7bfa0a1), XV64(0x62a2556a3368ad92),\n\tXV64(0x8f898d1b14e3946d), XV64(0xb97eb501e034995e), XV64(0xd490c534099a8338), XV64(0xe267fd2efd4d8e0b),\n\tXV64(0xec775d6468cf0c6), XV64(0x38304dccb25bfdf5), XV64(0x55de3df95bf5e793), XV64(0x632905e3af22eaa0),\n\tXV64(0x8e02dd9288a9d35f), XV64(0xb8f5e5887c7ede6c), XV64(0xd51b95bd95d0c40a), XV64(0xe3ecada76107c939),\n\tXV64(0xa77c66a937b2558), XV64(0x3c80fe7067ac286b), XV64(0x516e8e458e02320d), XV64(0x6799b65f7ad53f3e),\n\tXV64(0x8ab26e2e5d5e06c1), XV64(0xbc455634a9890bf2), XV64(0xd1ab260140271194), XV64(0xe75c1e1bb4f01ca7),\n\tXV64(0xbfc96e30f31626a), XV64(0x3d0baef9fbe66f59), XV64(0x50e5decc1248753f), XV64(0x6612e6d6e69f780c),\n\tXV64(0x8b393ea7c11441f3), XV64(0xbdce06bd35c34cc0), XV64(0xd0207688dc6d56a6), XV64(0xe6d74e9228ba5b95),\n\tXV64(0x9616779abefab3c), XV64(0x3f965f635f38a60f), XV64(0x52782f56b696bc69), XV64(0x648f174c4241b15a),\n\tXV64(0x89a4cf3d65ca88a5), XV64(0xbf53f727911d8596), XV64(0xd2bd871278b39ff0), XV64(0xe44abf088c6492c3),\n\tXV64(0x8ea37f037a5ec0e), XV64(0x3e1d0feac372e13d), XV64(0x53f37fdf2adcfb5b), XV64(0x650447c5de0bf668),\n\tXV64(0x882f9fb4f980cf97), XV64(0xbed8a7ae0d57c2a4), XV64(0xd336d79be4f9d8c2), XV64(0xe5c1ef81102ed5f1),\n\tXV64(0x18b50899c4a47320), XV64(0x2e42308330737e13), XV64(0x43ac40b6d9dd6475), XV64(0x755b78ac2d0a6946),\n\tXV64(0x9870a0dd0a8150b9), XV64(0xae8798c7fe565d8a), XV64(0xc369e8f217f847ec), XV64(0xf59ed0e8e32f4adf),\n\tXV64(0x193e581058ee3412), XV64(0x2fc9600aac393921), XV64(0x4227103f45972347), XV64(0x74d02825b1402e74),\n\tXV64(0x99fbf05496cb178b), XV64(0xaf0cc84e621c1ab8), XV64(0xc2e2b87b8bb200de), XV64(0xf41580617f650ded),\n\tXV64(0x1ba3a98afc30fd44), XV64(0x2d54919008e7f077), XV64(0x40bae1a5e149ea11), XV64(0x764dd9bf159ee722),\n\tXV64(0x9b6601ce3215dedd), XV64(0xad9139d4c6c2d3ee), XV64(0xc07f49e12f6cc988), XV64(0xf68871fbdbbbc4bb),\n\tXV64(0x1a28f903607aba76), XV64(0x2cdfc11994adb745), XV64(0x4131b12c7d03ad23), XV64(0x77c6893689d4a010),\n\tXV64(0x9aed5147ae5f99ef), XV64(0xac1a695d5a8894dc), XV64(0xc1f41968b3268eba), XV64(0xf703217247f18389),\n\tXV64(0x1e984abfb58d6fe8), XV64(0x286f72a5415a62db), XV64(0x45810290a8f478bd), XV64(0x73763a8a5c23758e),\n\tXV64(0x9e5de2fb7ba84c71), XV64(0xa8aadae18f7f4142), XV64(0xc544aad466d15b24), XV64(0xf3b392ce92065617),\n\tXV64(0x1f131a3629c728da), XV64(0x29e4222cdd1025e9), XV64(0x440a521934be3f8f), XV64(0x72fd6a03c06932bc),\n\tXV64(0x9fd6b272e7e20b43), XV64(0xa9218a6813350670), XV64(0xc4cffa5dfa9b1c16), XV64(0xf238c2470e4c1125),\n\tXV64(0x1d8eebac8d19e18c), XV64(0x2b79d3b679ceecbf), XV64(0x4697a3839060f6d9), XV64(0x70609b9964b7fbea),\n\tXV64(0x9d4b43e8433cc215), XV64(0xabbc7bf2b7ebcf26), XV64(0xc6520bc75e45d540), XV64(0xf0a533ddaa92d873),\n\tXV64(0x1c05bb251153a6be), XV64(0x2af2833fe584ab8d), XV64(0x471cf30a0c2ab1eb), XV64(0x71ebcb10f8fdbcd8),\n\tXV64(0x9cc01361df768527), XV64(0xaa372b7b2ba18814), XV64(0xc7d95b4ec20f9272), XV64(0xf12e635436d89f41),\n\tXV64(0x14ef8cd526f64ab0), XV64(0x2218b4cfd2214783), XV64(0x4ff6c4fa3b8f5de5), XV64(0x7901fce0cf5850d6),\n\tXV64(0x942a2491e8d36929), XV64(0xa2dd1c8b1c04641a), XV64(0xcf336cbef5aa7e7c), XV64(0xf9c454a4017d734f),\n\tXV64(0x1564dc5cbabc0d82), XV64(0x2393e4464e6b00b1), XV64(0x4e7d9473a7c51ad7), XV64(0x788aac69531217e4),\n\tXV64(0x95a1741874992e1b), XV64(0xa3564c02804e2328), XV64(0xceb83c3769e0394e), XV64(0xf84f042d9d37347d),\n\tXV64(0x17f92dc61e62c4d4), XV64(0x210e15dceab5c9e7), XV64(0x4ce065e9031bd381), XV64(0x7a175df3f7ccdeb2),\n\tXV64(0x973c8582d047e74d), XV64(0xa1cbbd982490ea7e), XV64(0xcc25cdadcd3ef018), XV64(0xfad2f5b739e9fd2b),\n\tXV64(0x16727d4f822883e6), XV64(0x2085455576ff8ed5), XV64(0x4d6b35609f5194b3), XV64(0x7b9c0d7a6b869980),\n\tXV64(0x96b7d50b4c0da07f), XV64(0xa040ed11b8daad4c), XV64(0xcdae9d245174b72a), XV64(0xfb59a53ea5a3ba19),\n\tXV64(0x12c2cef357df5678), XV64(0x2435f6e9a3085b4b), XV64(0x49db86dc4aa6412d), XV64(0x7f2cbec6be714c1e),\n\tXV64(0x920766b799fa75e1), XV64(0xa4f05ead6d2d78d2), XV64(0xc91e2e98848362b4), XV64(0xffe9168270546f87),\n\tXV64(0x13499e7acb95114a), XV64(0x25bea6603f421c79), XV64(0x4850d655d6ec061f), XV64(0x7ea7ee4f223b0b2c),\n\tXV64(0x938c363e05b032d3), XV64(0xa57b0e24f1673fe0), XV64(0xc8957e1118c92586), XV64(0xfe62460bec1e28b5),\n\tXV64(0x11d46fe06f4bd81c), XV64(0x272357fa9b9cd52f), XV64(0x4acd27cf7232cf49), XV64(0x7c3a1fd586e5c27a),\n\tXV64(0x9111c7a4a16efb85), XV64(0xa7e6ffbe55b9f6b6), XV64(0xca088f8bbc17ecd0), XV64(0xfcffb79148c0e1e3),\n\tXV64(0x105f3f69f3019f2e), XV64(0x26a8077307d6921d), XV64(0x4b467746ee78887b), XV64(0x7db14f5c1aaf8548),\n\tXV64(0x909a972d3d24bcb7), XV64(0xa66daf37c9f3b184), XV64(0xcb83df02205dabe2), XV64(0xfd74e718d48aa6d1)\n};\n\nstatic const xply_word U[256] = {\n\tXV64(0x0), XV64(0x1c3eb44b122426b2), XV64(0xe8a508cd09f4057), XV64(0x12b4e4c7c2bb66e5),\n\tXV64(0x1d14a119a13e80ae), XV64(0x12a1552b31aa61c), XV64(0x139ef19571a1c0f9), XV64(0xfa045de6385e64b),\n\tXV64(0xcde7a29b6aa0c6f), XV64(0x10e0ce62a48e2add), XV64(0x2542aa566354c38), XV64(0x1e6a9eee74116a8a),\n\tXV64(0x11cadb3017948cc1), XV64(0xdf46f7b05b0aa73), XV64(0x1f408bbcc70bcc96), XV64(0x37e3ff7d52fea24),\n\tXV64(0x19bcf4536d5418de), XV64(0x58240187f703e6c), XV64(0x1736a4dfbdcb5889), XV64(0xb081094afef7e3b),\n\tXV64(0x4a8554acc6a9870), XV64(0x1896e101de4ebec2), XV64(0xa2205c61cf5d827), XV64(0x161cb18d0ed1fe95),\n\tXV64(0x15628e7adbfe14b1), XV64(0x95c3a31c9da3203), XV64(0x1be8def60b6154e6), XV64(0x7d66abd19457254),\n\tXV64(0x8762f637ac0941f), XV64(0x14489b2868e4b2ad), XV64(0x6fc7fefaa5fd448), XV64(0x1ac2cba4b87bf2fa),\n\tXV64(0x58ed0bc2e7f3c8f), XV64(0x19b064f73c5b1a3d), XV64(0xb048030fee07cd8), XV64(0x173a347becc45a6a),\n\tXV64(0x189a71a58f41bc21), XV64(0x4a4c5ee9d659a93), XV64(0x161021295fdefc76), XV64(0xa2e95624dfadac4),\n\tXV64(0x950aa9598d530e0), XV64(0x156e1ede8af11652), XV64(0x7dafa19484a70b7), XV64(0x1be44e525a6e5605),\n\tXV64(0x14440b8c39ebb04e), XV64(0x87abfc72bcf96fc), XV64(0x1ace5b00e974f019), XV64(0x6f0ef4bfb50d6ab),\n\tXV64(0x1c3224ef432b2451), XV64(0xc90a4510f02e3), XV64(0x12b8746393b46406), XV64(0xe86c028819042b4),\n\tXV64(0x12685f6e215a4ff), XV64(0x1d1831bdf031824d), XV64(0xfacd57a328ae4a8), XV64(0x1392613120aec21a),\n\tXV64(0x10ec5ec6f581283e), XV64(0xcd2ea8de7a50e8c), XV64(0x1e660e4a251e6869), XV64(0x258ba01373a4edb),\n\tXV64(0xdf8ffdf54bfa890), XV64(0x11c64b94469b8e22), XV64(0x372af538420e8c7), XV64(0x1f4c1b189604ce75),\n\tXV64(0xb1da1785cfe791e), XV64(0x172315334eda5fac), XV64(0x597f1f48c613949), XV64(0x19a945bf9e451ffb),\n\tXV64(0x16090061fdc0f9b0), XV64(0xa37b42aefe4df02), XV64(0x188350ed2d5fb9e7), XV64(0x4bde4a63f7b9f55),\n\tXV64(0x7c3db51ea547571), XV64(0x1bfd6f1af87053c3), XV64(0x9498bdd3acb3526), XV64(0x15773f9628ef1394),\n\tXV64(0x1ad77a484b6af5df), XV64(0x6e9ce03594ed36d), XV64(0x145d2ac49bf5b588), XV64(0x8639e8f89d1933a),\n\tXV64(0x12a1552b31aa61c0), XV64(0xe9fe160238e4772), XV64(0x1c2b05a7e1352197), XV64(0x15b1ecf3110725),\n\tXV64(0xfb5f4329094e16e), XV64(0x138b407982b0c7dc), XV64(0x13fa4be400ba139), XV64(0x1d0110f5522f878b),\n\tXV64(0x1e7f2f0287006daf), XV64(0x2419b4995244b1d), XV64(0x10f57f8e579f2df8), XV64(0xccbcbc545bb0b4a),\n\tXV64(0x36b8e1b263eed01), XV64(0x1f553a50341acbb3), XV64(0xde1de97f6a1ad56), XV64(0x11df6adce4858be4),\n\tXV64(0xe9371c472814591), XV64(0x12adc58f60a56323), XV64(0x192148a21e05c6), XV64(0x1c279503b03a2374),\n\tXV64(0x1387d0ddd3bfc53f), XV64(0xfb96496c19be38d), XV64(0x1d0d805103208568), XV64(0x133341a1104a3da),\n\tXV64(0x24d0bedc42b49fe), XV64(0x1e73bfa6d60f6f4c), XV64(0xcc75b6114b409a9), XV64(0x10f9ef2a06902f1b),\n\tXV64(0x1f59aaf46515c950), XV64(0x3671ebf7731efe2), XV64(0x11d3fa78b58a8907), XV64(0xded4e33a7aeafb5),\n\tXV64(0x172f85971fd55d4f), XV64(0xb1131dc0df17bfd), XV64(0x19a5d51bcf4a1d18), XV64(0x59b6150dd6e3baa),\n\tXV64(0xa3b248ebeebdde1), XV64(0x160590c5accffb53), XV64(0x4b174026e749db6), XV64(0x188fc0497c50bb04),\n\tXV64(0x1bf1ffbea97f5120), XV64(0x7cf4bf5bb5b7792), XV64(0x157baf3279e01177), XV64(0x9451b796bc437c5),\n\tXV64(0x6e55ea70841d18e), XV64(0x1adbeaec1a65f73c), XV64(0x86f0e2bd8de91d9), XV64(0x1451ba60cafab76b),\n\tXV64(0x163b42f0b9fcf23c), XV64(0xa05f6bbabd8d48e), XV64(0x18b1127c6963b26b), XV64(0x48fa6377b4794d9),\n\tXV64(0xb2fe3e918c27292), XV64(0x171157a20ae65420), XV64(0x5a5b365c85d32c5), XV64(0x199b072eda791477),\n\tXV64(0x1ae538d90f56fe53), XV64(0x6db8c921d72d8e1), XV64(0x146f6855dfc9be04), XV64(0x851dc1ecded98b6),\n\tXV64(0x7f199c0ae687efd), XV64(0x1bcf2d8bbc4c584f), XV64(0x97bc94c7ef73eaa), XV64(0x15457d076cd31818),\n\tXV64(0xf87b6a3d4a8eae2), XV64(0x13b902e8c68ccc50), XV64(0x10de62f0437aab5), XV64(0x1d33526416138c07),\n\tXV64(0x129317ba75966a4c), XV64(0xeada3f167b24cfe), XV64(0x1c194736a5092a1b), XV64(0x27f37db72d0ca9),\n\tXV64(0x359cc8a6202e68d), XV64(0x1f6778c17026c03f), XV64(0xdd39c06b29da6da), XV64(0x11ed284da0b98068),\n\tXV64(0x1e4d6d93c33c6623), XV64(0x273d9d8d1184091), XV64(0x10c73d1f13a32674), XV64(0xcf98954018700c6),\n\tXV64(0x13b5924c9783ceb3), XV64(0xf8b260785a7e801), XV64(0x1d3fc2c0471c8ee4), XV64(0x101768b5538a856),\n\tXV64(0xea1335536bd4e1d), XV64(0x129f871e249968af), XV64(0x2b63d9e6220e4a), XV64(0x1c15d792f40628f8),\n\tXV64(0x1f6be8652129c2dc), XV64(0x3555c2e330de46e), XV64(0x11e1b8e9f1b6828b), XV64(0xddf0ca2e392a439),\n\tXV64(0x27f497c80174272), XV64(0x1e41fd37923364c0), XV64(0xcf519f050880225), XV64(0x10cbadbb42ac2497),\n\tXV64(0xa09661ffad7d66d), XV64(0x1637d254e8f3f0df), XV64(0x48336932a48963a), XV64(0x18bd82d8386cb088),\n\tXV64(0x171dc7065be956c3), XV64(0xb23734d49cd7071), XV64(0x1997978a8b761694), XV64(0x5a923c199523026),\n\tXV64(0x6d71c364c7dda02), XV64(0x1ae9a87d5e59fcb0), XV64(0x85d4cba9ce29a55), XV64(0x1463f8f18ec6bce7),\n\tXV64(0x1bc3bd2fed435aac), XV64(0x7fd0964ff677c1e), XV64(0x1549eda33ddc1afb), XV64(0x97759e82ff83c49),\n\tXV64(0x1d26e388e5028b22), XV64(0x11857c3f726ad90), XV64(0x13acb304359dcb75), XV64(0xf92074f27b9edc7),\n\tXV64(0x324291443c0b8c), XV64(0x1c0cf6da56182d3e), XV64(0xeb8121d94a34bdb), XV64(0x1286a65686876d69),\n\tXV64(0x11f899a153a8874d), XV64(0xdc62dea418ca1ff), XV64(0x1f72c92d8337c71a), XV64(0x34c7d669113e1a8),\n\tXV64(0xcec38b8f29607e3), XV64(0x10d28cf3e0b22151), XV64(0x2666834220947b4), XV64(0x1e58dc7f302d6106),\n\tXV64(0x49a17db885693fc), XV64(0x18a4a3909a72b54e), XV64(0xa10475758c9d3ab), XV64(0x162ef31c4aedf519),\n\tXV64(0x198eb6c229681352), XV64(0x5b002893b4c35e0), XV64(0x1704e64ef9f75305), XV64(0xb3a5205ebd375b7),\n\tXV64(0x8446df23efc9f93), XV64(0x147ad9b92cd8b921), XV64(0x6ce3d7eee63dfc4), XV64(0x1af08935fc47f976),\n\tXV64(0x1550cceb9fc21f3d), XV64(0x96e78a08de6398f), XV64(0x1bda9c674f5d5f6a), XV64(0x7e4282c5d7979d8),\n\tXV64(0x18a83334cb7db7ad), XV64(0x496877fd959911f), XV64(0x162263b81be2f7fa), XV64(0xa1cd7f309c6d148),\n\tXV64(0x5bc922d6a433703), XV64(0x19822666786711b1), XV64(0xb36c2a1badc7754), XV64(0x170876eaa8f851e6),\n\tXV64(0x1476491d7dd7bbc2), XV64(0x848fd566ff39d70), XV64(0x1afc1991ad48fb95), XV64(0x6c2addabf6cdd27),\n\tXV64(0x962e804dce93b6c), XV64(0x155c5c4fcecd1dde), XV64(0x7e8b8880c767b3b), XV64(0x1bd60cc31e525d89),\n\tXV64(0x114c767a629af73), XV64(0x1d2a732cb40d89c1), XV64(0xf9e97eb76b6ef24), XV64(0x13a023a06492c996),\n\tXV64(0x1c00667e07172fdd), XV64(0x3ed2351533096f), XV64(0x128a36f2d7886f8a), XV64(0xeb482b9c5ac4938),\n\tXV64(0xdcabd4e1083a31c), XV64(0x11f4090502a785ae), XV64(0x340edc2c01ce34b), XV64(0x1f7e5989d238c5f9),\n\tXV64(0x10de1c57b1bd23b2), XV64(0xce0a81ca3990500), XV64(0x1e544cdb612263e5), XV64(0x26af89073064557)\n};\n\n#endif /* if defined(XRABPLY_TYPE64) */\n\n#if defined(XRABPLY_TYPE32)\n\n#if !defined(XV32)\n#define XV32(v) ((xply_word) v ## ULL)\n#endif\n\n#define XRAB_ROOTPOLY XV32(0xabd1f37b)\n\n#define XRAB_SHIFT 23\n#define XRAB_WNDSIZE 20\n\ntypedef unsigned XRABPLY_TYPE32 xply_word;\n\nstatic const xply_word T[256] = {\n\tXV32(0x0), XV32(0xabd1f37b), XV32(0x57a3e6f6), XV32(0xfc72158d),\n\tXV32(0x4963e97), XV32(0xaf47cdec), XV32(0x5335d861), XV32(0xf8e42b1a),\n\tXV32(0x92c7d2e), XV32(0xa2fd8e55), XV32(0x5e8f9bd8), XV32(0xf55e68a3),\n\tXV32(0xdba43b9), XV32(0xa66bb0c2), XV32(0x5a19a54f), XV32(0xf1c85634),\n\tXV32(0x1258fa5c), XV32(0xb9890927), XV32(0x45fb1caa), XV32(0xee2aefd1),\n\tXV32(0x16cec4cb), XV32(0xbd1f37b0), XV32(0x416d223d), XV32(0xeabcd146),\n\tXV32(0x1b748772), XV32(0xb0a57409), XV32(0x4cd76184), XV32(0xe70692ff),\n\tXV32(0x1fe2b9e5), XV32(0xb4334a9e), XV32(0x48415f13), XV32(0xe390ac68),\n\tXV32(0x24b1f4b8), XV32(0x8f6007c3), XV32(0x7312124e), XV32(0xd8c3e135),\n\tXV32(0x2027ca2f), XV32(0x8bf63954), XV32(0x77842cd9), XV32(0xdc55dfa2),\n\tXV32(0x2d9d8996), XV32(0x864c7aed), XV32(0x7a3e6f60), XV32(0xd1ef9c1b),\n\tXV32(0x290bb701), XV32(0x82da447a), XV32(0x7ea851f7), XV32(0xd579a28c),\n\tXV32(0x36e90ee4), XV32(0x9d38fd9f), XV32(0x614ae812), XV32(0xca9b1b69),\n\tXV32(0x327f3073), XV32(0x99aec308), XV32(0x65dcd685), XV32(0xce0d25fe),\n\tXV32(0x3fc573ca), XV32(0x941480b1), XV32(0x6866953c), XV32(0xc3b76647),\n\tXV32(0x3b534d5d), XV32(0x9082be26), XV32(0x6cf0abab), XV32(0xc72158d0),\n\tXV32(0x4963e970), XV32(0xe2b21a0b), XV32(0x1ec00f86), XV32(0xb511fcfd),\n\tXV32(0x4df5d7e7), XV32(0xe624249c), XV32(0x1a563111), XV32(0xb187c26a),\n\tXV32(0x404f945e), XV32(0xeb9e6725), XV32(0x17ec72a8), XV32(0xbc3d81d3),\n\tXV32(0x44d9aac9), XV32(0xef0859b2), XV32(0x137a4c3f), XV32(0xb8abbf44),\n\tXV32(0x5b3b132c), XV32(0xf0eae057), XV32(0xc98f5da), XV32(0xa74906a1),\n\tXV32(0x5fad2dbb), XV32(0xf47cdec0), XV32(0x80ecb4d), XV32(0xa3df3836),\n\tXV32(0x52176e02), XV32(0xf9c69d79), XV32(0x5b488f4), XV32(0xae657b8f),\n\tXV32(0x56815095), XV32(0xfd50a3ee), XV32(0x122b663), XV32(0xaaf34518),\n\tXV32(0x6dd21dc8), XV32(0xc603eeb3), XV32(0x3a71fb3e), XV32(0x91a00845),\n\tXV32(0x6944235f), XV32(0xc295d024), XV32(0x3ee7c5a9), XV32(0x953636d2),\n\tXV32(0x64fe60e6), XV32(0xcf2f939d), XV32(0x335d8610), XV32(0x988c756b),\n\tXV32(0x60685e71), XV32(0xcbb9ad0a), XV32(0x37cbb887), XV32(0x9c1a4bfc),\n\tXV32(0x7f8ae794), XV32(0xd45b14ef), XV32(0x28290162), XV32(0x83f8f219),\n\tXV32(0x7b1cd903), XV32(0xd0cd2a78), XV32(0x2cbf3ff5), XV32(0x876ecc8e),\n\tXV32(0x76a69aba), XV32(0xdd7769c1), XV32(0x21057c4c), XV32(0x8ad48f37),\n\tXV32(0x7230a42d), XV32(0xd9e15756), XV32(0x259342db), XV32(0x8e42b1a0),\n\tXV32(0x3916219b), XV32(0x92c7d2e0), XV32(0x6eb5c76d), XV32(0xc5643416),\n\tXV32(0x3d801f0c), XV32(0x9651ec77), XV32(0x6a23f9fa), XV32(0xc1f20a81),\n\tXV32(0x303a5cb5), XV32(0x9bebafce), XV32(0x6799ba43), XV32(0xcc484938),\n\tXV32(0x34ac6222), XV32(0x9f7d9159), XV32(0x630f84d4), XV32(0xc8de77af),\n\tXV32(0x2b4edbc7), XV32(0x809f28bc), XV32(0x7ced3d31), XV32(0xd73cce4a),\n\tXV32(0x2fd8e550), XV32(0x8409162b), XV32(0x787b03a6), XV32(0xd3aaf0dd),\n\tXV32(0x2262a6e9), XV32(0x89b35592), XV32(0x75c1401f), XV32(0xde10b364),\n\tXV32(0x26f4987e), XV32(0x8d256b05), XV32(0x71577e88), XV32(0xda868df3),\n\tXV32(0x1da7d523), XV32(0xb6762658), XV32(0x4a0433d5), XV32(0xe1d5c0ae),\n\tXV32(0x1931ebb4), XV32(0xb2e018cf), XV32(0x4e920d42), XV32(0xe543fe39),\n\tXV32(0x148ba80d), XV32(0xbf5a5b76), XV32(0x43284efb), XV32(0xe8f9bd80),\n\tXV32(0x101d969a), XV32(0xbbcc65e1), XV32(0x47be706c), XV32(0xec6f8317),\n\tXV32(0xfff2f7f), XV32(0xa42edc04), XV32(0x585cc989), XV32(0xf38d3af2),\n\tXV32(0xb6911e8), XV32(0xa0b8e293), XV32(0x5ccaf71e), XV32(0xf71b0465),\n\tXV32(0x6d35251), XV32(0xad02a12a), XV32(0x5170b4a7), XV32(0xfaa147dc),\n\tXV32(0x2456cc6), XV32(0xa9949fbd), XV32(0x55e68a30), XV32(0xfe37794b),\n\tXV32(0x7075c8eb), XV32(0xdba43b90), XV32(0x27d62e1d), XV32(0x8c07dd66),\n\tXV32(0x74e3f67c), XV32(0xdf320507), XV32(0x2340108a), XV32(0x8891e3f1),\n\tXV32(0x7959b5c5), XV32(0xd28846be), XV32(0x2efa5333), XV32(0x852ba048),\n\tXV32(0x7dcf8b52), XV32(0xd61e7829), XV32(0x2a6c6da4), XV32(0x81bd9edf),\n\tXV32(0x622d32b7), XV32(0xc9fcc1cc), XV32(0x358ed441), XV32(0x9e5f273a),\n\tXV32(0x66bb0c20), XV32(0xcd6aff5b), XV32(0x3118ead6), XV32(0x9ac919ad),\n\tXV32(0x6b014f99), XV32(0xc0d0bce2), XV32(0x3ca2a96f), XV32(0x97735a14),\n\tXV32(0x6f97710e), XV32(0xc4468275), XV32(0x383497f8), XV32(0x93e56483),\n\tXV32(0x54c43c53), XV32(0xff15cf28), XV32(0x367daa5), XV32(0xa8b629de),\n\tXV32(0x505202c4), XV32(0xfb83f1bf), XV32(0x7f1e432), XV32(0xac201749),\n\tXV32(0x5de8417d), XV32(0xf639b206), XV32(0xa4ba78b), XV32(0xa19a54f0),\n\tXV32(0x597e7fea), XV32(0xf2af8c91), XV32(0xedd991c), XV32(0xa50c6a67),\n\tXV32(0x469cc60f), XV32(0xed4d3574), XV32(0x113f20f9), XV32(0xbaeed382),\n\tXV32(0x420af898), XV32(0xe9db0be3), XV32(0x15a91e6e), XV32(0xbe78ed15),\n\tXV32(0x4fb0bb21), XV32(0xe461485a), XV32(0x18135dd7), XV32(0xb3c2aeac),\n\tXV32(0x4b2685b6), XV32(0xe0f776cd), XV32(0x1c856340), XV32(0xb754903b)\n};\n\nstatic const xply_word U[256] = {\n\tXV32(0x0), XV32(0x5ce33923), XV32(0x1217813d), XV32(0x4ef4b81e),\n\tXV32(0x242f027a), XV32(0x78cc3b59), XV32(0x36388347), XV32(0x6adbba64),\n\tXV32(0x485e04f4), XV32(0x14bd3dd7), XV32(0x5a4985c9), XV32(0x6aabcea),\n\tXV32(0x6c71068e), XV32(0x30923fad), XV32(0x7e6687b3), XV32(0x2285be90),\n\tXV32(0x3b6dfa93), XV32(0x678ec3b0), XV32(0x297a7bae), XV32(0x7599428d),\n\tXV32(0x1f42f8e9), XV32(0x43a1c1ca), XV32(0xd5579d4), XV32(0x51b640f7),\n\tXV32(0x7333fe67), XV32(0x2fd0c744), XV32(0x61247f5a), XV32(0x3dc74679),\n\tXV32(0x571cfc1d), XV32(0xbffc53e), XV32(0x450b7d20), XV32(0x19e84403),\n\tXV32(0x76dbf526), XV32(0x2a38cc05), XV32(0x64cc741b), XV32(0x382f4d38),\n\tXV32(0x52f4f75c), XV32(0xe17ce7f), XV32(0x40e37661), XV32(0x1c004f42),\n\tXV32(0x3e85f1d2), XV32(0x6266c8f1), XV32(0x2c9270ef), XV32(0x707149cc),\n\tXV32(0x1aaaf3a8), XV32(0x4649ca8b), XV32(0x8bd7295), XV32(0x545e4bb6),\n\tXV32(0x4db60fb5), XV32(0x11553696), XV32(0x5fa18e88), XV32(0x342b7ab),\n\tXV32(0x69990dcf), XV32(0x357a34ec), XV32(0x7b8e8cf2), XV32(0x276db5d1),\n\tXV32(0x5e80b41), XV32(0x590b3262), XV32(0x17ff8a7c), XV32(0x4b1cb35f),\n\tXV32(0x21c7093b), XV32(0x7d243018), XV32(0x33d08806), XV32(0x6f33b125),\n\tXV32(0x46661937), XV32(0x1a852014), XV32(0x5471980a), XV32(0x892a129),\n\tXV32(0x62491b4d), XV32(0x3eaa226e), XV32(0x705e9a70), XV32(0x2cbda353),\n\tXV32(0xe381dc3), XV32(0x52db24e0), XV32(0x1c2f9cfe), XV32(0x40cca5dd),\n\tXV32(0x2a171fb9), XV32(0x76f4269a), XV32(0x38009e84), XV32(0x64e3a7a7),\n\tXV32(0x7d0be3a4), XV32(0x21e8da87), XV32(0x6f1c6299), XV32(0x33ff5bba),\n\tXV32(0x5924e1de), XV32(0x5c7d8fd), XV32(0x4b3360e3), XV32(0x17d059c0),\n\tXV32(0x3555e750), XV32(0x69b6de73), XV32(0x2742666d), XV32(0x7ba15f4e),\n\tXV32(0x117ae52a), XV32(0x4d99dc09), XV32(0x36d6417), XV32(0x5f8e5d34),\n\tXV32(0x30bdec11), XV32(0x6c5ed532), XV32(0x22aa6d2c), XV32(0x7e49540f),\n\tXV32(0x1492ee6b), XV32(0x4871d748), XV32(0x6856f56), XV32(0x5a665675),\n\tXV32(0x78e3e8e5), XV32(0x2400d1c6), XV32(0x6af469d8), XV32(0x361750fb),\n\tXV32(0x5cccea9f), XV32(0x2fd3bc), XV32(0x4edb6ba2), XV32(0x12385281),\n\tXV32(0xbd01682), XV32(0x57332fa1), XV32(0x19c797bf), XV32(0x4524ae9c),\n\tXV32(0x2fff14f8), XV32(0x731c2ddb), XV32(0x3de895c5), XV32(0x610bace6),\n\tXV32(0x438e1276), XV32(0x1f6d2b55), XV32(0x5199934b), XV32(0xd7aaa68),\n\tXV32(0x67a1100c), XV32(0x3b42292f), XV32(0x75b69131), XV32(0x2955a812),\n\tXV32(0x271dc115), XV32(0x7bfef836), XV32(0x350a4028), XV32(0x69e9790b),\n\tXV32(0x332c36f), XV32(0x5fd1fa4c), XV32(0x11254252), XV32(0x4dc67b71),\n\tXV32(0x6f43c5e1), XV32(0x33a0fcc2), XV32(0x7d5444dc), XV32(0x21b77dff),\n\tXV32(0x4b6cc79b), XV32(0x178ffeb8), XV32(0x597b46a6), XV32(0x5987f85),\n\tXV32(0x1c703b86), XV32(0x409302a5), XV32(0xe67babb), XV32(0x52848398),\n\tXV32(0x385f39fc), XV32(0x64bc00df), XV32(0x2a48b8c1), XV32(0x76ab81e2),\n\tXV32(0x542e3f72), XV32(0x8cd0651), XV32(0x4639be4f), XV32(0x1ada876c),\n\tXV32(0x70013d08), XV32(0x2ce2042b), XV32(0x6216bc35), XV32(0x3ef58516),\n\tXV32(0x51c63433), XV32(0xd250d10), XV32(0x43d1b50e), XV32(0x1f328c2d),\n\tXV32(0x75e93649), XV32(0x290a0f6a), XV32(0x67feb774), XV32(0x3b1d8e57),\n\tXV32(0x199830c7), XV32(0x457b09e4), XV32(0xb8fb1fa), XV32(0x576c88d9),\n\tXV32(0x3db732bd), XV32(0x61540b9e), XV32(0x2fa0b380), XV32(0x73438aa3),\n\tXV32(0x6aabcea0), XV32(0x3648f783), XV32(0x78bc4f9d), XV32(0x245f76be),\n\tXV32(0x4e84ccda), XV32(0x1267f5f9), XV32(0x5c934de7), XV32(0x7074c4),\n\tXV32(0x22f5ca54), XV32(0x7e16f377), XV32(0x30e24b69), XV32(0x6c01724a),\n\tXV32(0x6dac82e), XV32(0x5a39f10d), XV32(0x14cd4913), XV32(0x482e7030),\n\tXV32(0x617bd822), XV32(0x3d98e101), XV32(0x736c591f), XV32(0x2f8f603c),\n\tXV32(0x4554da58), XV32(0x19b7e37b), XV32(0x57435b65), XV32(0xba06246),\n\tXV32(0x2925dcd6), XV32(0x75c6e5f5), XV32(0x3b325deb), XV32(0x67d164c8),\n\tXV32(0xd0adeac), XV32(0x51e9e78f), XV32(0x1f1d5f91), XV32(0x43fe66b2),\n\tXV32(0x5a1622b1), XV32(0x6f51b92), XV32(0x4801a38c), XV32(0x14e29aaf),\n\tXV32(0x7e3920cb), XV32(0x22da19e8), XV32(0x6c2ea1f6), XV32(0x30cd98d5),\n\tXV32(0x12482645), XV32(0x4eab1f66), XV32(0x5fa778), XV32(0x5cbc9e5b),\n\tXV32(0x3667243f), XV32(0x6a841d1c), XV32(0x2470a502), XV32(0x78939c21),\n\tXV32(0x17a02d04), XV32(0x4b431427), XV32(0x5b7ac39), XV32(0x5954951a),\n\tXV32(0x338f2f7e), XV32(0x6f6c165d), XV32(0x2198ae43), XV32(0x7d7b9760),\n\tXV32(0x5ffe29f0), XV32(0x31d10d3), XV32(0x4de9a8cd), XV32(0x110a91ee),\n\tXV32(0x7bd12b8a), XV32(0x273212a9), XV32(0x69c6aab7), XV32(0x35259394),\n\tXV32(0x2ccdd797), XV32(0x702eeeb4), XV32(0x3eda56aa), XV32(0x62396f89),\n\tXV32(0x8e2d5ed), XV32(0x5401ecce), XV32(0x1af554d0), XV32(0x46166df3),\n\tXV32(0x6493d363), XV32(0x3870ea40), XV32(0x7684525e), XV32(0x2a676b7d),\n\tXV32(0x40bcd119), XV32(0x1c5fe83a), XV32(0x52ab5024), XV32(0xe486907)\n};\n\n#endif /* if defined(XRABPLY_TYPE32) */\n\n/* END xrabply.c */\n\n\n\n\n\n#define XRAB_SLIDE(v, c) do {\t\t\t\t\t\\\n\t\tif (++wpos == XRAB_WNDSIZE) wpos = 0;\t\t\\\n\t\tv ^= U[wbuf[wpos]];\t\t\t\t\\\n\t\twbuf[wpos] = (c);\t\t\t\t\\\n\t\tv = ((v << 8) | (c)) ^ T[v >> XRAB_SHIFT];\t\\\n\t} while (0)\n\n\n#define XRAB_MINCPYSIZE 12\n#define XRAB_WBITS (sizeof(xply_word) * 8)\n\n\n\ntypedef struct s_xrabctx {\n\tlong idxsize;\n\tlong *idx;\n\tunsigned char const *data;\n\tlong size;\n} xrabctx_t;\n\ntypedef struct s_xrabcpyi {\n\tlong src;\n\tlong tgt;\n\tlong len;\n} xrabcpyi_t;\n\ntypedef struct s_xrabcpyi_arena {\n\tlong cnt, size;\n\txrabcpyi_t *acpy;\n} xrabcpyi_arena_t;\n\n\n\nstatic void xrab_init_cpyarena(xrabcpyi_arena_t *aca) {\n\taca->cnt = aca->size = 0;\n\taca->acpy = NULL;\n}\n\n\nstatic void xrab_free_cpyarena(xrabcpyi_arena_t *aca) {\n\txdl_free(aca->acpy);\n}\n\n\nstatic int xrab_add_cpy(xrabcpyi_arena_t *aca, xrabcpyi_t const *rcpy) {\n\tlong size;\n\txrabcpyi_t *acpy;\n\n\tif (aca->cnt >= aca->size) {\n\t\tsize = 2 * aca->size + 1024;\n\t\tif ((acpy = (xrabcpyi_t *)\n\t\t     xdl_realloc(aca->acpy, size * sizeof(xrabcpyi_t))) == NULL)\n\t\t\treturn -1;\n\t\taca->acpy = acpy;\n\t\taca->size = size;\n\t}\n\taca->acpy[aca->cnt++] = *rcpy;\n\n\treturn 0;\n}\n\n\nstatic long xrab_cmnseq(unsigned char const *data, long start, long size) {\n\tunsigned char ch = data[start];\n\tunsigned char const *ptr, *top;\n\n\tfor (ptr = data + start + 1, top = data + size; ptr < top && ch == *ptr; ptr++);\n\n\treturn (long) (ptr - (data + start + 1));\n}\n\n\nstatic int xrab_build_ctx(unsigned char const *data, long size, xrabctx_t *ctx) {\n\tlong i, isize, idxsize, seq, wpos = 0;\n\txply_word fp = 0, mask;\n\tunsigned char ch;\n\tunsigned char const *ptr, *eot;\n\tlong *idx;\n\tunsigned char wbuf[XRAB_WNDSIZE];\n\tlong maxoffs[256];\n\tlong maxseq[256];\n\txply_word maxfp[256];\n\n\tmemset(wbuf, 0, sizeof(wbuf));\n\tmemset(maxseq, 0, sizeof(maxseq));\n\tisize = 2 * (size / XRAB_WNDSIZE);\n\tfor (idxsize = 1; idxsize < isize; idxsize <<= 1);\n\tmask = (xply_word) (idxsize - 1);\n\tif ((idx = (long *) xdl_malloc(idxsize * sizeof(long))) == NULL)\n\t\treturn -1;\n\tmemset(idx, 0, idxsize * sizeof(long));\n\tfor (i = 0; i + XRAB_WNDSIZE < size; i += XRAB_WNDSIZE) {\n\t\t/*\n\t\t * Generate a brand new hash for the current window. Here we could\n\t\t * try to perform pseudo-loop unroll by 4 blocks if necessary, and\n\t\t * if we force XRAB_WNDSIZE to be a multiple of 4, we could reduce\n\t\t * the branch occurence inside XRAB_SLIDE by a factor of 4.\n\t\t */\n\t\tfor (ptr = data + i, eot = ptr + XRAB_WNDSIZE; ptr < eot; ptr++)\n\t\t\tXRAB_SLIDE(fp, *ptr);\n\n\t\t/*\n\t\t * Try to scan for single value scans, and store them in the\n\t\t * array according to the longest one. Before we do a fast check\n\t\t * to avoid calling xrab_cmnseq() when not necessary.\n\t\t */\n\t\tif ((ch = data[i]) == data[i + XRAB_WNDSIZE - 1] &&\n\t\t    (seq = xrab_cmnseq(data, i, size)) > XRAB_WNDSIZE &&\n\t\t    seq > maxseq[ch]) {\n\t\t\tmaxseq[ch] = seq;\n\t\t\tmaxfp[ch] = fp;\n\t\t\tmaxoffs[ch] = i + XRAB_WNDSIZE;\n\t\t\tseq = (seq / XRAB_WNDSIZE) * XRAB_WNDSIZE;\n\t\t\ti += seq - XRAB_WNDSIZE;\n\t\t} else\n\t\t\tidx[fp & mask] = i + XRAB_WNDSIZE;\n\t}\n\n\t/*\n\t * Restore back the logest sequences by overwriting target hash buckets.\n\t */\n\tfor (i = 0; i < 256; i++)\n\t\tif (maxseq[i])\n\t\t\tidx[maxfp[i] & mask] = maxoffs[i];\n\tctx->idxsize = idxsize;\n\tctx->idx = idx;\n\tctx->data = data;\n\tctx->size = size;\n\n\treturn 0;\n}\n\n\nstatic void xrab_free_ctx(xrabctx_t *ctx) {\n\n\txdl_free(ctx->idx);\n}\n\n\nstatic int xrab_diff(unsigned char const *data, long size, xrabctx_t *ctx,\n\t\t     xrabcpyi_arena_t *aca) {\n\tlong i, offs, ssize, src, tgt, esrc, etgt, wpos = 0;\n\txply_word fp = 0, mask;\n\tlong const *idx;\n\tunsigned char const *sdata;\n\txrabcpyi_t rcpy;\n\tunsigned char wbuf[XRAB_WNDSIZE];\n\n\txrab_init_cpyarena(aca);\n\tmemset(wbuf, 0, sizeof(wbuf));\n\tfor (i = 0; i < XRAB_WNDSIZE - 1 && i < size; i++)\n\t\tXRAB_SLIDE(fp, data[i]);\n\tidx = ctx->idx;\n\tsdata = ctx->data;\n\tssize = ctx->size;\n\tmask = (xply_word) (ctx->idxsize - 1);\n\twhile (i < size) {\n\t\tunsigned char ch = data[i++];\n\n\t\tXRAB_SLIDE(fp, ch);\n\t\toffs = idx[fp & mask];\n\n\t\t/*\n\t\t * Fast check here to probabilistically reduce false positives\n\t\t * that would trigger the slow path below.\n\t\t */\n\t\tif (offs == 0 || ch != sdata[offs - 1])\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Stretch the match both sides as far as possible.\n\t\t */\n\t\tsrc = offs - 1;\n\t\ttgt = i - 1;\n\t\tfor (; tgt > 0 && src > 0 && data[tgt - 1] == sdata[src - 1];\n\t\t     tgt--, src--);\n\t\tesrc = offs;\n\t\tetgt = i;\n\t\tfor (; etgt < size && esrc < ssize && data[etgt] == sdata[esrc];\n\t\t     etgt++, esrc++);\n\n\t\t/*\n\t\t * Avoid considering copies smaller than the XRAB_MINCPYSIZE\n\t\t * threshold.\n\t\t */\n\t\tif (etgt - tgt >= XRAB_MINCPYSIZE) {\n\t\t\trcpy.src = src;\n\t\t\trcpy.tgt = tgt;\n\t\t\trcpy.len = etgt - tgt;\n\t\t\tif (xrab_add_cpy(aca, &rcpy) < 0) {\n\t\t\t\txrab_free_cpyarena(aca);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Fill up the new window and exit with 'i' properly set on exit.\n\t\t\t */\n\t\t\tfor (i = etgt - XRAB_WNDSIZE; i < etgt; i++)\n\t\t\t\tXRAB_SLIDE(fp, data[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic int xrab_tune_cpyarena(unsigned char const *data, long size, xrabctx_t *ctx,\n\t\t\t      xrabcpyi_arena_t *aca) {\n\tlong i, cpos;\n\txrabcpyi_t *rcpy;\n\n\tfor (cpos = size, i = aca->cnt - 1; i >= 0; i--) {\n\t\trcpy = aca->acpy + i;\n\t\tif (rcpy->tgt >= cpos)\n\t\t\trcpy->len = 0;\n\t\telse if (rcpy->tgt + rcpy->len > cpos) {\n\t\t\tif ((rcpy->len = cpos - rcpy->tgt) >= XRAB_MINCPYSIZE)\n\t\t\t\tcpos = rcpy->tgt;\n\t\t\telse\n\t\t\t\trcpy->len = 0;\n\t\t} else\n\t\t\tcpos = rcpy->tgt;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_rabdiff_mb(mmbuffer_t *mmb1, mmbuffer_t *mmb2, xdemitcb_t *ecb) {\n\tlong i, cpos, size;\n\tunsigned long fp;\n\txrabcpyi_t *rcpy;\n\txrabctx_t ctx;\n\txrabcpyi_arena_t aca;\n\tmmbuffer_t mb[2];\n\tunsigned char cpybuf[32];\n\n\tfp = xdl_mmb_adler32(mmb1);\n\tif (xrab_build_ctx((unsigned char const *) mmb1->ptr, mmb1->size,\n\t\t\t   &ctx) < 0)\n\t\treturn -1;\n\tif (xrab_diff((unsigned char const *) mmb2->ptr, mmb2->size, &ctx,\n\t\t      &aca) < 0) {\n\t\txrab_free_ctx(&ctx);\n\t\treturn -1;\n\t}\n\txrab_tune_cpyarena((unsigned char const *) mmb2->ptr, mmb2->size, &ctx,\n\t\t\t   &aca);\n\txrab_free_ctx(&ctx);\n\n\t/*\n\t * Prepare and emit the binary patch file header. It will be used\n\t * to verify that that file being patched matches in size and fingerprint\n\t * the one that generated the patch.\n\t */\n\tsize = mmb1->size;\n\tXDL_LE32_PUT(cpybuf, fp);\n\tXDL_LE32_PUT(cpybuf + 4, size);\n\n\tmb[0].ptr = (char *) cpybuf;\n\tmb[0].size = 4 + 4;\n\tif (ecb->outf(ecb->priv, mb, 1) < 0) {\n\t\txrab_free_cpyarena(&aca);\n\t\treturn -1;\n\t}\n\tfor (cpos = 0, i = 0; i < aca.cnt; i++) {\n\t\trcpy = aca.acpy + i;\n\t\tif (rcpy->len == 0)\n\t\t\tcontinue;\n\t\tif (cpos < rcpy->tgt) {\n\t\t\tsize = rcpy->tgt - cpos;\n\t\t\tif (size > 255) {\n\t\t\t\tcpybuf[0] = XDL_BDOP_INSB;\n\t\t\t\tXDL_LE32_PUT(cpybuf + 1, size);\n\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\tmb[0].size = XDL_INSBOP_SIZE;\n\t\t\t} else {\n\t\t\t\tcpybuf[0] = XDL_BDOP_INS;\n\t\t\t\tcpybuf[1] = (unsigned char) size;\n\t\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\t\tmb[0].size = 2;\n\t\t\t}\n\t\t\tmb[1].ptr = mmb2->ptr + cpos;\n\t\t\tmb[1].size = size;\n\t\t\tif (ecb->outf(ecb->priv, mb, 2) < 0) {\n\t\t\t\txrab_free_cpyarena(&aca);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcpos = rcpy->tgt;\n\t\t}\n\t\tcpybuf[0] = XDL_BDOP_CPY;\n\t\tXDL_LE32_PUT(cpybuf + 1, rcpy->src);\n\t\tXDL_LE32_PUT(cpybuf + 5, rcpy->len);\n\t\tmb[0].ptr = (char *) cpybuf;\n\t\tmb[0].size = XDL_COPYOP_SIZE;\n\t\tif (ecb->outf(ecb->priv, mb, 1) < 0) {\n\t\t\txrab_free_cpyarena(&aca);\n\t\t\treturn -1;\n\t\t}\n\t\tcpos += rcpy->len;\n\t}\n\txrab_free_cpyarena(&aca);\n\tif (cpos < mmb2->size) {\n\t\tsize = mmb2->size - cpos;\n\t\tif (size > 255) {\n\t\t\tcpybuf[0] = XDL_BDOP_INSB;\n\t\t\tXDL_LE32_PUT(cpybuf + 1, size);\n\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\tmb[0].size = XDL_INSBOP_SIZE;\n\t\t} else {\n\t\t\tcpybuf[0] = XDL_BDOP_INS;\n\t\t\tcpybuf[1] = (unsigned char) size;\n\t\t\tmb[0].ptr = (char *) cpybuf;\n\t\t\tmb[0].size = 2;\n\t\t}\n\t\tmb[1].ptr = mmb2->ptr + cpos;\n\t\tmb[1].size = size;\n\t\tif (ecb->outf(ecb->priv, mb, 2) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_rabdiff(mmfile_t *mmf1, mmfile_t *mmf2, xdemitcb_t *ecb) {\n\tmmbuffer_t mmb1, mmb2;\n\n\tif (!xdl_mmfile_iscompact(mmf1) || !xdl_mmfile_iscompact(mmf2))\n\t\treturn -1;\n\tif ((mmb1.ptr = (char *) xdl_mmfile_first(mmf1, &mmb1.size)) == NULL)\n\t\tmmb1.size = 0;\n\tif ((mmb2.ptr = (char *) xdl_mmfile_first(mmf2, &mmb2.size)) == NULL)\n\t\tmmb2.size = 0;\n\n\treturn xdl_rabdiff_mb(&mmb1, &mmb2, ecb);\n}\n\n/* END xrabdiff.c */\n\n\n/* BEGIN xutils.c */\n\n#define XDL_GUESS_NLINES 256\n\n\n\n\nlong xdl_bogosqrt(long n) {\n\tlong i;\n\n\t/*\n\t * Classical integer square root approximation using shifts.\n\t */\n\tfor (i = 1; n > 0; n >>= 2)\n\t\ti <<= 1;\n\n\treturn i;\n}\n\n\nint xdl_emit_diffrec(char const *rec, long size, char const *pre, long psize,\n\t\t     xdemitcb_t *ecb) {\n\tint i = 2;\n\tmmbuffer_t mb[3];\n\n\tmb[0].ptr = (char *) pre;\n\tmb[0].size = psize;\n\tmb[1].ptr = (char *) rec;\n\tmb[1].size = size;\n\tif (size > 0 && rec[size - 1] != '\\n') {\n\t\tmb[2].ptr = (char *) \"\\n\\\\ No newline at end of file\\n\";\n\t\tmb[2].size = strlen(mb[2].ptr);\n\t\ti++;\n\t}\n\tif (ecb->outf(ecb->priv, mb, i) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_init_mmfile(mmfile_t *mmf, long bsize, unsigned long flags) {\n\n\tmmf->flags = flags;\n\tmmf->head = mmf->tail = NULL;\n\tmmf->bsize = bsize;\n\tmmf->fsize = 0;\n\tmmf->rcur = mmf->wcur = NULL;\n\tmmf->rpos = 0;\n\n\treturn 0;\n}\n\n\nvoid xdl_free_mmfile(mmfile_t *mmf) {\n\tmmblock_t *cur, *tmp;\n\n\tfor (cur = mmf->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}\n\n\nint xdl_mmfile_iscompact(mmfile_t *mmf) {\n\n\treturn mmf->head == mmf->tail;\n}\n\n\nint xdl_seek_mmfile(mmfile_t *mmf, long off) {\n\tlong bsize;\n\n\tif (xdl_mmfile_first(mmf, &bsize)) {\n\t\tdo {\n\t\t\tif (off < bsize) {\n\t\t\t\tmmf->rpos = off;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\toff -= bsize;\n\t\t} while (xdl_mmfile_next(mmf, &bsize));\n\t}\n\n\treturn -1;\n}\n\n\nlong xdl_read_mmfile(mmfile_t *mmf, void *data, long size) {\n\tlong rsize, csize;\n\tchar *ptr = (char*) data;\n\tmmblock_t *rcur;\n\n\tfor (rsize = 0, rcur = mmf->rcur; rcur && rsize < size;) {\n\t\tif (mmf->rpos >= rcur->size) {\n\t\t\tif (!(mmf->rcur = rcur = rcur->next))\n\t\t\t\tbreak;\n\t\t\tmmf->rpos = 0;\n\t\t}\n\t\tcsize = XDL_MIN(size - rsize, rcur->size - mmf->rpos);\n\t\tmemcpy(ptr, rcur->ptr + mmf->rpos, csize);\n\t\trsize += csize;\n\t\tptr += csize;\n\t\tmmf->rpos += csize;\n\t}\n\n\treturn rsize;\n}\n\n\nlong xdl_write_mmfile(mmfile_t *mmf, void const *data, long size) {\n\tlong wsize, bsize, csize;\n\tmmblock_t *wcur;\n\n\tfor (wsize = 0; wsize < size;) {\n\t\twcur = mmf->wcur;\n\t\tif (wcur && (wcur->flags & XDL_MMB_READONLY))\n\t\t\treturn wsize;\n\t\tif (!wcur || wcur->size == wcur->bsize ||\n\t\t    (mmf->flags & XDL_MMF_ATOMIC && wcur->size + size > wcur->bsize)) {\n\t\t\tbsize = XDL_MAX(mmf->bsize, size);\n\t\t\tif (!(wcur = (mmblock_t *) xdl_malloc(sizeof(mmblock_t) + bsize))) {\n\n\t\t\t\treturn wsize;\n\t\t\t}\n\t\t\twcur->flags = 0;\n\t\t\twcur->ptr = (char *) wcur + sizeof(mmblock_t);\n\t\t\twcur->size = 0;\n\t\t\twcur->bsize = bsize;\n\t\t\twcur->next = NULL;\n\t\t\tif (!mmf->head)\n\t\t\t\tmmf->head = wcur;\n\t\t\tif (mmf->tail)\n\t\t\t\tmmf->tail->next = wcur;\n\t\t\tmmf->tail = wcur;\n\t\t\tmmf->wcur = wcur;\n\t\t}\n\t\tcsize = XDL_MIN(size - wsize, wcur->bsize - wcur->size);\n\t\tmemcpy(wcur->ptr + wcur->size, (char const *) data + wsize, csize);\n\t\twsize += csize;\n\t\twcur->size += csize;\n\t\tmmf->fsize += csize;\n\t}\n\n\treturn size;\n}\n\n\nlong xdl_writem_mmfile(mmfile_t *mmf, mmbuffer_t *mb, int nbuf) {\n\tint i;\n\tlong size;\n\tchar *data;\n\n\tfor (i = 0, size = 0; i < nbuf; i++)\n\t\tsize += mb[i].size;\n\tif (!(data = (char *) xdl_mmfile_writeallocate(mmf, size)))\n\t\treturn -1;\n\tfor (i = 0; i < nbuf; i++) {\n\t\tmemcpy(data, mb[i].ptr, mb[i].size);\n\t\tdata += mb[i].size;\n\t}\n\n\treturn size;\n}\n\n\nvoid *xdl_mmfile_writeallocate(mmfile_t *mmf, long size) {\n\tlong bsize;\n\tmmblock_t *wcur;\n\tchar *blk;\n\n\tif (!(wcur = mmf->wcur) || wcur->size + size > wcur->bsize) {\n\t\tbsize = XDL_MAX(mmf->bsize, size);\n\t\tif (!(wcur = (mmblock_t *) xdl_malloc(sizeof(mmblock_t) + bsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\twcur->flags = 0;\n\t\twcur->ptr = (char *) wcur + sizeof(mmblock_t);\n\t\twcur->size = 0;\n\t\twcur->bsize = bsize;\n\t\twcur->next = NULL;\n\t\tif (!mmf->head)\n\t\t\tmmf->head = wcur;\n\t\tif (mmf->tail)\n\t\t\tmmf->tail->next = wcur;\n\t\tmmf->tail = wcur;\n\t\tmmf->wcur = wcur;\n\t}\n\n\tblk = wcur->ptr + wcur->size;\n\twcur->size += size;\n\tmmf->fsize += size;\n\n\treturn blk;\n}\n\n\nlong xdl_mmfile_ptradd(mmfile_t *mmf, char *ptr, long size, unsigned long flags) {\n\tmmblock_t *wcur;\n\n\tif (!(wcur = (mmblock_t *) xdl_malloc(sizeof(mmblock_t)))) {\n\n\t\treturn -1;\n\t}\n\twcur->flags = flags;\n\twcur->ptr = ptr;\n\twcur->size = wcur->bsize = size;\n\twcur->next = NULL;\n\tif (!mmf->head)\n\t\tmmf->head = wcur;\n\tif (mmf->tail)\n\t\tmmf->tail->next = wcur;\n\tmmf->tail = wcur;\n\tmmf->wcur = wcur;\n\n\tmmf->fsize += size;\n\n\treturn size;\n}\n\n\nlong xdl_copy_mmfile(mmfile_t *mmf, long size, xdemitcb_t *ecb) {\n\tlong rsize, csize;\n\tmmblock_t *rcur;\n\tmmbuffer_t mb;\n\n\tfor (rsize = 0, rcur = mmf->rcur; rcur && rsize < size;) {\n\t\tif (mmf->rpos >= rcur->size) {\n\t\t\tif (!(mmf->rcur = rcur = rcur->next))\n\t\t\t\tbreak;\n\t\t\tmmf->rpos = 0;\n\t\t}\n\t\tcsize = XDL_MIN(size - rsize, rcur->size - mmf->rpos);\n\t\tmb.ptr = rcur->ptr + mmf->rpos;\n\t\tmb.size = csize;\n\t\tif (ecb->outf(ecb->priv, &mb, 1) < 0) {\n\n\t\t\treturn rsize;\n\t\t}\n\t\trsize += csize;\n\t\tmmf->rpos += csize;\n\t}\n\n\treturn rsize;\n}\n\n\nvoid *xdl_mmfile_first(mmfile_t *mmf, long *size) {\n\n\tif (!(mmf->rcur = mmf->head))\n\t\treturn NULL;\n\n\t*size = mmf->rcur->size;\n\n\treturn mmf->rcur->ptr;\n}\n\n\nvoid *xdl_mmfile_next(mmfile_t *mmf, long *size) {\n\n\tif (!mmf->rcur || !(mmf->rcur = mmf->rcur->next))\n\t\treturn NULL;\n\n\t*size = mmf->rcur->size;\n\n\treturn mmf->rcur->ptr;\n}\n\n\nlong xdl_mmfile_size(mmfile_t *mmf) {\n\n\treturn mmf->fsize;\n}\n\n\nint xdl_mmfile_cmp(mmfile_t *mmf1, mmfile_t *mmf2) {\n\tint cres;\n\tlong size, bsize1, bsize2, size1, size2;\n\tchar const *blk1, *cur1, *top1;\n\tchar const *blk2, *cur2, *top2;\n\n\tif ((cur1 = blk1 = (char const*) xdl_mmfile_first(mmf1, &bsize1)) != NULL)\n\t\ttop1 = blk1 + bsize1;\n\tif ((cur2 = blk2 = (char const*) xdl_mmfile_first(mmf2, &bsize2)) != NULL)\n\t\ttop2 = blk2 + bsize2;\n\tif (!cur1) {\n\t\tif (!cur2 || xdl_mmfile_size(mmf2) == 0)\n\t\t\treturn 0;\n\t\treturn -*cur2;\n\t} else if (!cur2)\n\t\treturn xdl_mmfile_size(mmf1) ? *cur1: 0;\n\tfor (;;) {\n\t\tif (cur1 >= top1) {\n\t\t\tif ((cur1 = blk1 = (char const*) xdl_mmfile_next(mmf1, &bsize1)) != NULL)\n\t\t\t\ttop1 = blk1 + bsize1;\n\t\t}\n\t\tif (cur2 >= top2) {\n\t\t\tif ((cur2 = blk2 = (char const*) xdl_mmfile_next(mmf2, &bsize2)) != NULL)\n\t\t\t\ttop2 = blk2 + bsize2;\n\t\t}\n\t\tif (!cur1) {\n\t\t\tif (!cur2)\n\t\t\t\tbreak;\n\t\t\treturn -*cur2;\n\t\t} else if (!cur2)\n\t\t\treturn *cur1;\n\t\tsize1 = top1 - cur1;\n\t\tsize2 = top2 - cur2;\n\t\tsize = XDL_MIN(size1, size2);\n\t\tif ((cres = memcmp(cur1, cur2, size)) != 0)\n\t\t\treturn cres;\n\t\tcur1 += size;\n\t\tcur2 += size;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_mmfile_compact(mmfile_t *mmfo, mmfile_t *mmfc, long bsize, unsigned long flags) {\n\tlong fsize = xdl_mmfile_size(mmfo), size;\n\tchar *data;\n\tchar const *blk;\n\n\tif (xdl_init_mmfile(mmfc, bsize, flags) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (!(data = (char *) xdl_mmfile_writeallocate(mmfc, fsize))) {\n\n\t\txdl_free_mmfile(mmfc);\n\t\treturn -1;\n\t}\n\tif ((blk = (char const *) xdl_mmfile_first(mmfo, &size)) != NULL) {\n\t\tdo {\n\t\t\tmemcpy(data, blk, size);\n\t\t\tdata += size;\n\t\t} while ((blk = (char const *) xdl_mmfile_next(mmfo, &size)) != NULL);\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_mmfile_outf(void *priv, mmbuffer_t *mb, int nbuf) {\n\tmmfile_t *mmf = (mmfile_t*) priv;\n\n\tif (xdl_writem_mmfile(mmf, mb, nbuf) < 0) {\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\nint xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}\n\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}\n\n\nvoid *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}\n\n\nvoid *xdl_cha_first(chastore_t *cha) {\n\tchanode_t *sncur;\n\n\tif (!(cha->sncur = sncur = cha->head))\n\t\treturn NULL;\n\n\tcha->scurr = 0;\n\n\treturn (char *) sncur + sizeof(chanode_t) + cha->scurr;\n}\n\n\nvoid *xdl_cha_next(chastore_t *cha) {\n\tchanode_t *sncur;\n\n\tif (!(sncur = cha->sncur))\n\t\treturn NULL;\n\tcha->scurr += cha->isize;\n\tif (cha->scurr == sncur->icurr) {\n\t\tif (!(sncur = cha->sncur = sncur->next))\n\t\t\treturn NULL;\n\t\tcha->scurr = 0;\n\t}\n\n\treturn (char *) sncur + sizeof(chanode_t) + cha->scurr;\n}\n\n\nlong xdl_guess_lines(mmfile_t *mf) {\n\tlong nl = 0, size, tsize = 0;\n\tchar const *data, *cur, *top;\n\n\tif ((cur = data = (char const*) xdl_mmfile_first(mf, &size)) != NULL) {\n\t\tfor (top = data + size; nl < XDL_GUESS_NLINES;) {\n\t\t\tif (cur >= top) {\n\t\t\t\ttsize += (long) (cur - data);\n\t\t\t\tif (!(cur = data = (char const*) xdl_mmfile_next(mf, &size)))\n\t\t\t\t\tbreak;\n\t\t\t\ttop = data + size;\n\t\t\t}\n\t\t\tnl++;\n\t\t\tif (!(cur = (char const*) memchr(cur, '\\n', top - cur)))\n\t\t\t\tcur = top;\n\t\t\telse\n\t\t\t\tcur++;\n\t\t}\n\t\ttsize += (long) (cur - data);\n\t}\n\n\tif (nl && tsize)\n\t\tnl = xdl_mmfile_size(mf) / (tsize / nl);\n\n\treturn nl + 1;\n}\n\n\nunsigned long xdl_hash_record(char const **data, char const *top) {\n\tunsigned long ha = 5381;\n\tchar const *ptr = *data;\n\n\tfor (; ptr < top && *ptr != '\\n'; ptr++) {\n\t\tha += (ha << 5);\n\t\tha ^= (unsigned long) *ptr;\n\t}\n\t*data = ptr < top ? ptr + 1: ptr;\n\n\treturn ha;\n}\n\n\nunsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}\n\n\nint xdl_num_out(char *out, long val) {\n\tchar *ptr, *str = out;\n\tchar buf[32];\n\n\tptr = buf + sizeof(buf) - 1;\n\t*ptr = '\\0';\n\tif (val < 0) {\n\t\t*--ptr = '-';\n\t\tval = -val;\n\t}\n\tfor (; val && ptr > buf; val /= 10)\n\t\t*--ptr = \"0123456789\"[val % 10];\n\tif (*ptr)\n\t\tfor (; *ptr; ptr++, str++)\n\t\t\t*str = *ptr;\n\telse\n\t\t*str++ = '0';\n\t*str = '\\0';\n\n\treturn str - out;\n}\n\n\nlong xdl_atol(char const *str, char const **next) {\n\tlong val, base;\n\tchar const *top;\n\n\tfor (top = str; XDL_ISDIGIT(*top); top++);\n\tif (next)\n\t\t*next = top;\n\tfor (val = 0, base = 1, top--; top >= str; top--, base *= 10)\n\t\tval += base * (long)(*top - '0');\n\treturn val;\n}\n\n\nint xdl_emit_hunk_hdr(long s1, long c1, long s2, long c2, xdemitcb_t *ecb) {\n\tint nb = 0;\n\tmmbuffer_t mb;\n\tchar buf[128];\n\n\tmemcpy(buf, \"@@ -\", 4);\n\tnb += 4;\n\n\tnb += xdl_num_out(buf + nb, c1 ? s1: s1 - 1);\n\n\tmemcpy(buf + nb, \",\", 1);\n\tnb += 1;\n\n\tnb += xdl_num_out(buf + nb, c1);\n\n\tmemcpy(buf + nb, \" +\", 2);\n\tnb += 2;\n\n\tnb += xdl_num_out(buf + nb, c2 ? s2: s2 - 1);\n\n\tmemcpy(buf + nb, \",\", 1);\n\tnb += 1;\n\n\tnb += xdl_num_out(buf + nb, c2);\n\n\tmemcpy(buf + nb, \" @@\\n\", 4);\n\tnb += 4;\n\n\tmb.ptr = buf;\n\tmb.size = nb;\n\tif (ecb->outf(ecb->priv, &mb, 1) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* END xutils.c */\n\n\n\n#endif /* LIBXDIFF_IMPLEMENTATION */\n"
        },
        {
          "name": "lzma.h",
          "type": "blob",
          "size": 164.509765625,
          "content": "/*\n * This is a modified version of of Igor Pavlov's LzmaLib. Basically, I \n * merged it into a single-file header-only library, made a few changes\n * to make the code compile in both C and C++. The original code is \n * public domain, and I place my version into the public domain as well.\n *\n *                                                  /Mattias Gustavsson\n * Do this:\n *\t\t#define LZMA_IMPLEMENTATION\n * before including this file in *one* C/C++ file to get the implementation\n *\n */\n \n#ifndef LZMA_H\n#define LZMA_H\n\n#include <stddef.h>\n\n/* LzmaLib.h -- LZMA library interface\n2013-01-18 : Igor Pavlov : Public domain */\n\n\n#define LZMA_PROPS_SIZE 5\n\n\n#define SZ_OK 0\n\n#define SZ_ERROR_DATA 1\n#define SZ_ERROR_MEM 2\n#define SZ_ERROR_CRC 3\n#define SZ_ERROR_UNSUPPORTED 4\n#define SZ_ERROR_PARAM 5\n#define SZ_ERROR_INPUT_EOF 6\n#define SZ_ERROR_OUTPUT_EOF 7\n#define SZ_ERROR_READ 8\n#define SZ_ERROR_WRITE 9\n#define SZ_ERROR_PROGRESS 10\n#define SZ_ERROR_FAIL 11\n\n#define SZ_ERROR_ARCHIVE 16\n#define SZ_ERROR_NO_ARCHIVE 17\n\n\n/*\nRAM requirements for LZMA:\n  for compression:   (dictSize * 11.5 + 6 MB) + state_size\n  for decompression: dictSize + state_size\n    state_size = (4 + (1.5 << (lc + lp))) KB\n    by default (lc=3, lp=0), state_size = 16 KB.\n\nLZMA properties (5 bytes) format\n    Offset Size  Description\n      0     1    lc, lp and pb in encoded form.\n      1     4    dictSize (little endian).\n*/\n\n/*\nLzmaCompress\n------------\n\noutPropsSize -\n     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.\n     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.\n\n  LZMA Encoder will use defult values for any parameter, if it is\n  -1  for any from: level, loc, lp, pb, fb\n   0  for dictSize\n\nlevel - compression level: 0 <= level <= 9;\n\n  level dictSize algo  fb\n    0:    16 KB   0    32\n    1:    64 KB   0    32\n    2:   256 KB   0    32\n    3:     1 MB   0    32\n    4:     4 MB   0    32\n    5:    16 MB   1    32\n    6:    32 MB   1    32\n    7+:   64 MB   1    64\n\n  The default value for \"level\" is 5.\n\n  algo = 0 means fast method\n  algo = 1 means normal method\n\ndictSize - The dictionary size in bytes. The maximum value is\n        128 MB = (1 << 27) bytes for 32-bit version\n          1 GB = (1 << 30) bytes for 64-bit version\n     The default value is 16 MB = (1 << 24) bytes.\n     It's recommended to use the dictionary that is larger than 4 KB and\n     that can be calculated as (1 << N) or (3 << N) sizes.\n\nlc - The number of literal context bits (high bits of previous literal).\n     It can be in the range from 0 to 8. The default value is 3.\n     Sometimes lc=4 gives the gain for big files.\n\nlp - The number of literal pos bits (low bits of current position for literals).\n     It can be in the range from 0 to 4. The default value is 0.\n     The lp switch is intended for periodical data when the period is equal to 2^lp.\n     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's\n     better to set lc=0, if you change lp switch.\n\npb - The number of pos bits (low bits of current position).\n     It can be in the range from 0 to 4. The default value is 2.\n     The pb switch is intended for periodical data when the period is equal 2^pb.\n\nfb - Word size (the number of fast bytes).\n     It can be in the range from 5 to 273. The default value is 32.\n     Usually, a big number gives a little bit better compression ratio and\n     slower compression process.\n\n\nOut:\n  destLen  - processed output size\nReturns:\n  SZ_OK               - OK\n  SZ_ERROR_MEM        - Memory allocation error\n  SZ_ERROR_PARAM      - Incorrect paramater\n  SZ_ERROR_OUTPUT_EOF - output buffer overflow\n*/\n\nint LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,\n  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */\n  int level,      /* 0 <= level <= 9, default = 5 */\n  unsigned dictSize,  /* default = (1 << 24) */\n  int lc,        /* 0 <= lc <= 8, default = 3  */\n  int lp,        /* 0 <= lp <= 4, default = 0  */\n  int pb,        /* 0 <= pb <= 4, default = 2  */\n  int fb,        /* 5 <= fb <= 273, default = 32 */\n  int (*progress)( size_t inSize, size_t outSize, void* userData ),\n  void* userData\n);\n\n/*\nLzmaUncompress\n--------------\nIn:\n  dest     - output data\n  destLen  - output data size\n  src      - input data\n  srcLen   - input data size\nOut:\n  destLen  - processed output size\n  srcLen   - processed input size\nReturns:\n  SZ_OK                - OK\n  SZ_ERROR_DATA        - Data error\n  SZ_ERROR_MEM         - Memory allocation arror\n  SZ_ERROR_UNSUPPORTED - Unsupported properties\n  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)\n*/\n\nint LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t *srcLen,\n  const unsigned char *props, size_t propsSize);\n\n\n#endif /* LZMA_H */\n\n\n\n\n\n#ifdef LZMA_IMPLEMENTATION\n\n#define Int32 signed int\n#define Int64 signed long long\n#define Byte unsigned char\n#define UInt16 unsigned short\n#define UInt32 unsigned int\n#define UInt64 unsigned long long\n\n#define UNUSED_VAR(x) (void)x;\n\n\n\n\n\n/* 7zTypes.h -- Basic types\n2018-08-04 : Igor Pavlov : Public domain */\n\n\ntypedef int SRes;\n\n\n#ifndef RINOK\n#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }\n#endif\n\ntypedef int BoolInt;\n/* typedef BoolInt Bool; */\n#define True 1\n#define False 0\n\n\ntypedef struct ISeqInStream ISeqInStream;\nstruct ISeqInStream\n{\n  SRes (*Read)(const ISeqInStream *p, void *buf, size_t *size);\n    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.\n       (output(*size) < input(*size)) is allowed */\n};\n#define ISeqInStream_Read(p, buf, size) (p)->Read(p, buf, size)\n\n/* it can return SZ_ERROR_INPUT_EOF */\nSRes SeqInStream_Read(const ISeqInStream *stream, void *buf, size_t size);\nSRes SeqInStream_Read2(const ISeqInStream *stream, void *buf, size_t size, SRes errorType);\nSRes SeqInStream_ReadByte(const ISeqInStream *stream, Byte *buf);\n\n\ntypedef struct ISeqOutStream ISeqOutStream;\nstruct ISeqOutStream\n{\n  size_t (*Write)(const ISeqOutStream *p, const void *buf, size_t size);\n    /* Returns: result - the number of actually written bytes.\n       (result < size) means error */\n};\n#define ISeqOutStream_Write(p, buf, size) (p)->Write(p, buf, size)\n\n\ntypedef struct ICompressProgress ICompressProgress;\n\nstruct ICompressProgress\n{\n  SRes (*Progress)(const ICompressProgress *p, UInt64 inSize, UInt64 outSize);\n    /* Returns: result. (result != SZ_OK) means break.\n       Value (UInt64)(Int64)-1 for size means unknown value. */\n};\n#define ICompressProgress_Progress(p, inSize, outSize) (p)->Progress(p, inSize, outSize)\n\n\ntypedef struct ISzAlloc ISzAlloc;\ntypedef const ISzAlloc * ISzAllocPtr;\n\nstruct ISzAlloc\n{\n  void *(*Alloc)(ISzAllocPtr p, size_t size);\n  void (*Free)(ISzAllocPtr p, void *address); /* address can be 0 */\n};\n\n#define ISzAlloc_Alloc(p, size) (p)->Alloc(p, size)\n#define ISzAlloc_Free(p, a) (p)->Free(p, a)\n\n/* deprecated */\n#define IAlloc_Alloc(p, size) ISzAlloc_Alloc(p, size)\n#define IAlloc_Free(p, a) ISzAlloc_Free(p, a)\n\n\n#ifndef MY_offsetof\n  #ifdef offsetof\n    #define MY_offsetof(type, m) offsetof(type, m)\n    /*\n    #define MY_offsetof(type, m) FIELD_OFFSET(type, m)\n    */\n  #else\n    #define MY_offsetof(type, m) ((size_t)&(((type *)0)->m))\n  #endif\n#endif\n\n\n\n#ifndef MY_container_of\n\n/*\n#define MY_container_of(ptr, type, m) container_of(ptr, type, m)\n#define MY_container_of(ptr, type, m) CONTAINING_RECORD(ptr, type, m)\n#define MY_container_of(ptr, type, m) ((type *)((char *)(ptr) - offsetof(type, m)))\n#define MY_container_of(ptr, type, m) (&((type *)0)->m == (ptr), ((type *)(((char *)(ptr)) - MY_offsetof(type, m))))\n*/\n\n/*\n  GCC shows warning: \"perhaps the 'offsetof' macro was used incorrectly\"\n    GCC 3.4.4 : classes with constructor\n    GCC 4.8.1 : classes with non-public variable members\"\n*/\n\n#define MY_container_of(ptr, type, m) ((type *)((char *)(1 ? (ptr) : &((type *)0)->m) - MY_offsetof(type, m)))\n\n\n#endif\n\n#define CONTAINER_FROM_VTBL_SIMPLE(ptr, type, m) ((type *)(ptr))\n\n/*\n#define CONTAINER_FROM_VTBL(ptr, type, m) CONTAINER_FROM_VTBL_SIMPLE(ptr, type, m)\n*/\n#define CONTAINER_FROM_VTBL(ptr, type, m) MY_container_of(ptr, type, m)\n\n#define CONTAINER_FROM_VTBL_CLS(ptr, type, m) CONTAINER_FROM_VTBL_SIMPLE(ptr, type, m)\n/*\n#define CONTAINER_FROM_VTBL_CLS(ptr, type, m) CONTAINER_FROM_VTBL(ptr, type, m)\n*/\n\n\n\n#ifdef _MSC_VER\n\n#if _MSC_VER >= 1300\n#define MY_NO_INLINE __declspec(noinline)\n#else\n#define MY_NO_INLINE\n#endif\n\n#define MY_FORCE_INLINE __forceinline\n\n#define MY_CDECL __cdecl\n#define MY_FAST_CALL __fastcall\n\n#else\n\n#define MY_NO_INLINE\n#define MY_FORCE_INLINE\n#define MY_CDECL\n#define MY_FAST_CALL\n\n/* inline keyword : for C++ / C99 */\n\n/* GCC, clang: */\n/*\n#if defined (__GNUC__) && (__GNUC__ >= 4)\n#define MY_FORCE_INLINE __attribute__((always_inline))\n#define MY_NO_INLINE __attribute__((noinline))\n#endif\n*/\n\n#endif\n\n\n\n\n\n/* Alloc.h -- Memory allocation functions\n2018-02-19 : Igor Pavlov : Public domain */\n\nvoid *MyAlloc(size_t size);\nvoid MyFree(void *address);\n\n#ifdef _WIN32\n\nvoid SetLargePageSize( void );\n\nvoid *MidAlloc(size_t size);\nvoid MidFree(void *address);\nvoid *BigAlloc(size_t size);\nvoid BigFree(void *address);\n\n#else\n\n#define MidAlloc(size) MyAlloc(size)\n#define MidFree(address) MyFree(address)\n#define BigAlloc(size) MyAlloc(size)\n#define BigFree(address) MyFree(address)\n\n#endif\n\nextern const ISzAlloc g_Alloc;\nextern const ISzAlloc g_BigAlloc;\nextern const ISzAlloc g_MidAlloc;\nextern const ISzAlloc g_AlignedAlloc;\n\n\ntypedef struct\n{\n  ISzAlloc vt;\n  ISzAllocPtr baseAlloc;\n  unsigned numAlignBits; /* ((1 << numAlignBits) >= sizeof(void *)) */\n  size_t offset;         /* (offset == (k * sizeof(void *)) && offset < (1 << numAlignBits) */\n} CAlignOffsetAlloc;\n\nvoid AlignOffsetAlloc_CreateVTable(CAlignOffsetAlloc *p);\n\n\n\n\n\n/*  LzmaEnc.h -- LZMA Encoder\n2017-07-27 : Igor Pavlov : Public domain */\n\ntypedef struct _CLzmaEncProps\n{\n  int level;       /* 0 <= level <= 9 */\n  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version\n                      (1 << 12) <= dictSize <= (3 << 29) for 64-bit version\n                      default = (1 << 24) */\n  int lc;          /* 0 <= lc <= 8, default = 3 */\n  int lp;          /* 0 <= lp <= 4, default = 0 */\n  int pb;          /* 0 <= pb <= 4, default = 2 */\n  int algo;        /* 0 - fast, 1 - normal, default = 1 */\n  int fb;          /* 5 <= fb <= 273, default = 32 */\n  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */\n  int numHashBytes; /* 2, 3 or 4, default = 4 */\n  UInt32 mc;       /* 1 <= mc <= (1 << 30), default = 32 */\n  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */\n\n  UInt64 reduceSize; /* estimated size of data that will be compressed. default = (UInt64)(Int64)-1.\n                        Encoder uses this value to reduce dictionary size */\n} CLzmaEncProps;\n\nvoid LzmaEncProps_Init(CLzmaEncProps *p);\nvoid LzmaEncProps_Normalize(CLzmaEncProps *p);\nUInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);\n\n\n/* ---------- CLzmaEncHandle Interface ---------- */\n\n/* LzmaEnc* functions can return the following exit codes:\nSRes:\n  SZ_OK           - OK\n  SZ_ERROR_MEM    - Memory allocation error\n  SZ_ERROR_PARAM  - Incorrect paramater in props\n  SZ_ERROR_WRITE  - ISeqOutStream write callback error\n  SZ_ERROR_OUTPUT_EOF - output buffer overflow - version with (Byte *) output\n  SZ_ERROR_PROGRESS - some break from progress callback\n*/\n\ntypedef void * CLzmaEncHandle;\n\nCLzmaEncHandle LzmaEnc_Create(ISzAllocPtr alloc);\nvoid LzmaEnc_Destroy(CLzmaEncHandle p, ISzAllocPtr alloc, ISzAllocPtr allocBig);\n\nSRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);\nvoid LzmaEnc_SetDataSize(CLzmaEncHandle p, UInt64 expectedDataSiize);\nSRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, size_t *size);\nunsigned LzmaEnc_IsWriteEndMark(CLzmaEncHandle p);\n\nSRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,\n    ICompressProgress *progress, ISzAllocPtr alloc, ISzAllocPtr allocBig);\nSRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,\n    int writeEndMark, ICompressProgress *progress, ISzAllocPtr alloc, ISzAllocPtr allocBig);\n\n\n/* ---------- One Call Interface ---------- */\n\nSRes LzmaEncode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,\n    const CLzmaEncProps *props, Byte *propsEncoded, size_t *propsSize, int writeEndMark,\n    ICompressProgress *progress, ISzAllocPtr alloc, ISzAllocPtr allocBig);\n\n\n\n\n\n/* LzmaDec.h -- LZMA Decoder\n2018-04-21 : Igor Pavlov : Public domain */\n\n/* #define _LZMA_PROB32 */\n/* _LZMA_PROB32 can increase the speed on some CPUs,\n   but memory usage for CLzmaDec::probs will be doubled in that case */\n\ntypedef\n#ifdef _LZMA_PROB32\n  UInt32\n#else\n  UInt16\n#endif\n  CLzmaProb;\n\n\n/* ---------- LZMA Properties ---------- */\n\n#define LZMA_PROPS_SIZE 5\n\ntypedef struct _CLzmaProps\n{\n  Byte lc;\n  Byte lp;\n  Byte pb;\n  Byte _pad_;\n  UInt32 dicSize;\n} CLzmaProps;\n\n/* LzmaProps_Decode - decodes properties\nReturns:\n  SZ_OK\n  SZ_ERROR_UNSUPPORTED - Unsupported properties\n*/\n\nSRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);\n\n\n/* ---------- LZMA Decoder state ---------- */\n\n/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.\n   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */\n\n#define LZMA_REQUIRED_INPUT_MAX 20\n\ntypedef struct\n{\n  /* Don't change this structure. ASM code can use it. */\n  CLzmaProps prop;\n  CLzmaProb *probs;\n  CLzmaProb *probs_1664;\n  Byte *dic;\n  size_t dicBufSize;\n  size_t dicPos;\n  const Byte *buf;\n  UInt32 range;\n  UInt32 code;\n  UInt32 processedPos;\n  UInt32 checkDicSize;\n  UInt32 reps[4];\n  UInt32 state;\n  UInt32 remainLen;\n\n  UInt32 numProbs;\n  unsigned tempBufSize;\n  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];\n} CLzmaDec;\n\n#define LzmaDec_Construct(p) { (p)->dic = NULL; (p)->probs = NULL; }\n\nvoid LzmaDec_Init(CLzmaDec *p);\n\n/* There are two types of LZMA streams:\n     - Stream with end mark. That end mark adds about 6 bytes to compressed size.\n     - Stream without end mark. You must know exact uncompressed size to decompress such stream. */\n\ntypedef enum\n{\n  LZMA_FINISH_ANY,   /* finish at any point */\n  LZMA_FINISH_END    /* block must be finished at the end */\n} ELzmaFinishMode;\n\n/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!\n\n   You must use LZMA_FINISH_END, when you know that current output buffer\n   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.\n\n   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,\n   and output value of destLen will be less than output buffer size limit.\n   You can check status result also.\n\n   You can use multiple checks to test data integrity after full decompression:\n     1) Check Result and \"status\" variable.\n     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.\n     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.\n        You must use correct finish mode in that case. */\n\ntypedef enum\n{\n  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */\n  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */\n  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */\n  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */\n  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */\n} ELzmaStatus;\n\n/* ELzmaStatus is used only as output value for function call */\n\n\n/* ---------- Interfaces ---------- */\n\n/* There are 3 levels of interfaces:\n     1) Dictionary Interface\n     2) Buffer Interface\n     3) One Call Interface\n   You can select any of these interfaces, but don't mix functions from different\n   groups for same object. */\n\n\n/* There are two variants to allocate state for Dictionary Interface:\n     1) LzmaDec_Allocate / LzmaDec_Free\n     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs\n   You can use variant 2, if you set dictionary buffer manually.\n   For Buffer Interface you must always use variant 1.\n\nLzmaDec_Allocate* can return:\n  SZ_OK\n  SZ_ERROR_MEM         - Memory allocation error\n  SZ_ERROR_UNSUPPORTED - Unsupported properties\n*/\n\nSRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAllocPtr alloc);\nvoid LzmaDec_FreeProbs(CLzmaDec *p, ISzAllocPtr alloc);\n\nSRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAllocPtr alloc);\nvoid LzmaDec_Free(CLzmaDec *p, ISzAllocPtr alloc);\n\n/* ---------- Dictionary Interface ---------- */\n\n/* You can use it, if you want to eliminate the overhead for data copying from\n   dictionary to some other external buffer.\n   You must work with CLzmaDec variables directly in this interface.\n\n   STEPS:\n     LzmaDec_Construct()\n     LzmaDec_Allocate()\n     for (each new stream)\n     {\n       LzmaDec_Init()\n       while (it needs more decompression)\n       {\n         LzmaDec_DecodeToDic()\n         use data from CLzmaDec::dic and update CLzmaDec::dicPos\n       }\n     }\n     LzmaDec_Free()\n*/\n\n/* LzmaDec_DecodeToDic\n\n   The decoding to internal dictionary buffer (CLzmaDec::dic).\n   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!\n\nfinishMode:\n  It has meaning only if the decoding reaches output limit (dicLimit).\n  LZMA_FINISH_ANY - Decode just dicLimit bytes.\n  LZMA_FINISH_END - Stream must be finished after dicLimit.\n\nReturns:\n  SZ_OK\n    status:\n      LZMA_STATUS_FINISHED_WITH_MARK\n      LZMA_STATUS_NOT_FINISHED\n      LZMA_STATUS_NEEDS_MORE_INPUT\n      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK\n  SZ_ERROR_DATA - Data error\n*/\n\nSRes LzmaDec_DecodeToDic(CLzmaDec *p, size_t dicLimit,\n    const Byte *src, size_t *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);\n\n\n/* ---------- Buffer Interface ---------- */\n\n/* It's zlib-like interface.\n   See LzmaDec_DecodeToDic description for information about STEPS and return results,\n   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need\n   to work with CLzmaDec variables manually.\n\nfinishMode:\n  It has meaning only if the decoding reaches output limit (*destLen).\n  LZMA_FINISH_ANY - Decode just destLen bytes.\n  LZMA_FINISH_END - Stream must be finished after (*destLen).\n*/\n\nSRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, size_t *destLen,\n    const Byte *src, size_t *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);\n\n\n/* ---------- One Call Interface ---------- */\n\n/* LzmaDecode\n\nfinishMode:\n  It has meaning only if the decoding reaches output limit (*destLen).\n  LZMA_FINISH_ANY - Decode just destLen bytes.\n  LZMA_FINISH_END - Stream must be finished after (*destLen).\n\nReturns:\n  SZ_OK\n    status:\n      LZMA_STATUS_FINISHED_WITH_MARK\n      LZMA_STATUS_NOT_FINISHED\n      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK\n  SZ_ERROR_DATA - Data error\n  SZ_ERROR_MEM  - Memory allocation error\n  SZ_ERROR_UNSUPPORTED - Unsupported properties\n  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).\n*/\n\nSRes LzmaDecode(Byte *dest, size_t *destLen, const Byte *src, size_t *srcLen,\n    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,\n    ELzmaStatus *status, ISzAllocPtr alloc);\n\n\n\n\n\n/* LzmaLib.c -- LZMA library wrapper\n2015-06-13 : Igor Pavlov : Public domain */\n\n//#include \"Alloc.h\"\n//#include \"LzmaDec.h\"\n//#include \"LzmaEnc.h\"\n//#include \"LzmaLib.h\"\n\nstruct WrappedProgress\n{\n ICompressProgress intProgress;\n int (*extProgress)( size_t inSize, size_t outSize, void* userData );\n void* userData;\n};\n\n\nSRes compressProgress(const ICompressProgress *p, UInt64 inSize, UInt64 outSize)\n{\n    struct WrappedProgress* progress = (struct WrappedProgress*) p;\n    if( progress->extProgress( (size_t) inSize, (size_t) outSize, progress->userData ) == 0 )\n        return SZ_OK;\n    else\n        return SZ_ERROR_FAIL;\n}\n\n\nint LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,\n  unsigned char *outProps, size_t *outPropsSize,\n  int level, /* 0 <= level <= 9, default = 5 */\n  unsigned dictSize, /* use (1 << N) or (3 << N). 4 KB < dictSize <= 128 MB */\n  int lc, /* 0 <= lc <= 8, default = 3  */\n  int lp, /* 0 <= lp <= 4, default = 0  */\n  int pb, /* 0 <= pb <= 4, default = 2  */\n  int fb,  /* 5 <= fb <= 273, default = 32 */\n  int (*progress)( size_t inSize, size_t outSize, void* userData ),\n  void* userData\n)\n{\n  CLzmaEncProps props;\n  LzmaEncProps_Init(&props);\n  props.level = level;\n  props.dictSize = dictSize;\n  props.lc = lc;\n  props.lp = lp;\n  props.pb = pb;\n  props.fb = fb;\n\n  struct WrappedProgress wrappedProgress;\n  wrappedProgress.intProgress.Progress = compressProgress;\n  wrappedProgress.extProgress = progress;\n  wrappedProgress.userData = userData;\n  return LzmaEncode(dest, destLen, src, srcLen, &props, outProps, outPropsSize, 0, progress ? &wrappedProgress.intProgress : NULL, &g_Alloc, &g_Alloc);\n}\n\n\nint LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t *srcLen,\n  const unsigned char *props, size_t propsSize)\n{\n  ELzmaStatus status;\n  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &status, &g_Alloc);\n}\n\n\n\n\n\n/* Alloc.c -- Memory allocation functions\n2018-04-27 : Igor Pavlov : Public domain */\n\n\n#include <stdio.h>\n/*\n#pragma warning( push )\n#pragma warning( disable: 4365 )\n#pragma warning( disable: 4619 )\n#pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n#pragma warning( disable: 4768 ) // __declspec attributes before linkage specification are ignored\n#pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n#define _NTDDSCM_H_\n#include <windows.h>\n#pragma warning( pop )\n*/\n#include <stdlib.h>\n\n//#include \"Alloc.h\"\n\n/* #define _SZ_ALLOC_DEBUG */\n\n/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */\n#ifdef _SZ_ALLOC_DEBUG\n\n#include <stdio.h>\nint g_allocCount = 0;\nint g_allocCountMid = 0;\nint g_allocCountBig = 0;\n\n\n#define CONVERT_INT_TO_STR(charType, tempSize) \\\n  unsigned char temp[tempSize]; unsigned i = 0; \\\n  while (val >= 10) { temp[i++] = (unsigned char)('0' + (unsigned)(val % 10)); val /= 10; } \\\n  *s++ = (charType)('0' + (unsigned)val); \\\n  while (i != 0) { i--; *s++ = temp[i]; } \\\n  *s = 0;\n\nstatic void ConvertUInt64ToString(UInt64 val, char *s)\n{\n  CONVERT_INT_TO_STR(char, 24);\n}\n\n#define GET_HEX_CHAR(t) ((char)(((t < 10) ? ('0' + t) : ('A' + (t - 10)))))\n\nstatic void ConvertUInt64ToHex(UInt64 val, char *s)\n{\n  UInt64 v = val;\n  unsigned i;\n  for (i = 1;; i++)\n  {\n    v >>= 4;\n    if (v == 0)\n      break;\n  }\n  s[i] = 0;\n  do\n  {\n    unsigned t = (unsigned)(val & 0xF);\n    val >>= 4;\n    s[--i] = GET_HEX_CHAR(t);\n  }\n  while (i);\n}\n\n#define DEBUG_OUT_STREAM stderr\n\nstatic void Print(const char *s)\n{\n  fputs(s, DEBUG_OUT_STREAM);\n}\n\nstatic void PrintAligned(const char *s, size_t align)\n{\n  size_t len = strlen(s);\n  for(;;)\n  {\n    fputc(' ', DEBUG_OUT_STREAM);\n    if (len >= align)\n      break;\n    ++len;\n  }\n  Print(s);\n}\n\nstatic void PrintLn()\n{\n  Print(\"\\n\");\n}\n\nstatic void PrintHex(UInt64 v, size_t align)\n{\n  char s[32];\n  ConvertUInt64ToHex(v, s);\n  PrintAligned(s, align);\n}\n\nstatic void PrintDec(UInt64 v, size_t align)\n{\n  char s[32];\n  ConvertUInt64ToString(v, s);\n  PrintAligned(s, align);\n}\n\nstatic void PrintAddr(void *p)\n{\n  PrintHex((UInt64)(size_t)(ptrdiff_t)p, 12);\n}\n\n\n#define PRINT_ALLOC(name, cnt, size, ptr) \\\n    Print(name \" \"); \\\n    PrintDec(cnt++, 10); \\\n    PrintHex(size, 10); \\\n    PrintAddr(ptr); \\\n    PrintLn();\n\n#define PRINT_FREE(name, cnt, ptr) if (ptr) { \\\n    Print(name \" \"); \\\n    PrintDec(--cnt, 10); \\\n    PrintAddr(ptr); \\\n    PrintLn(); }\n\n#else\n\n#define PRINT_ALLOC(name, cnt, size, ptr)\n#define PRINT_FREE(name, cnt, ptr)\n#define Print(s)\n#define PrintLn()\n#define PrintHex(v, align)\n#define PrintDec(v, align)\n#define PrintAddr(p)\n\n#endif\n\n\n\nvoid *MyAlloc(size_t size)\n{\n  if (size == 0)\n    return NULL;\n  #ifdef _SZ_ALLOC_DEBUG\n  {\n    void *p = malloc(size);\n    PRINT_ALLOC(\"Alloc    \", g_allocCount, size, p);\n    return p;\n  }\n  #else\n  return malloc(size);\n  #endif\n}\n\nvoid MyFree(void *address)\n{\n  PRINT_FREE(\"Free    \", g_allocCount, address);\n\n  free(address);\n}\n\n#ifdef _WIN32\n\nvoid *MidAlloc(size_t size)\n{\n  if (size == 0)\n    return NULL;\n\n  PRINT_ALLOC(\"Alloc-Mid\", g_allocCountMid, size, NULL);\n\n  return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n}\n\nvoid MidFree(void *address)\n{\n  PRINT_FREE(\"Free-Mid\", g_allocCountMid, address);\n\n  if (!address)\n    return;\n  VirtualFree(address, 0, MEM_RELEASE);\n}\n\n#ifndef MEM_LARGE_PAGES\n#undef _7ZIP_LARGE_PAGES\n#endif\n\n#ifdef _7ZIP_LARGE_PAGES\nSIZE_T g_LargePageSize = 0;\ntypedef SIZE_T (WINAPI *GetLargePageMinimumP)();\n#endif\n\nvoid SetLargePageSize( void )\n{\n  #ifdef _7ZIP_LARGE_PAGES\n  SIZE_T size;\n  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)\n        GetProcAddress(GetModuleHandle(TEXT(\"kernel32.dll\")), \"GetLargePageMinimum\");\n  if (!largePageMinimum)\n    return;\n  size = largePageMinimum();\n  if (size == 0 || (size & (size - 1)) != 0)\n    return;\n  g_LargePageSize = size;\n  #endif\n}\n\n\nvoid *BigAlloc(size_t size)\n{\n  if (size == 0)\n    return NULL;\n\n  PRINT_ALLOC(\"Alloc-Big\", g_allocCountBig, size, NULL);\n\n  #ifdef _7ZIP_LARGE_PAGES\n  {\n    SIZE_T ps = g_LargePageSize;\n    if (ps != 0 && ps <= (1 << 30) && size > (ps / 2))\n    {\n      size_t size2;\n      ps--;\n      size2 = (size + ps) & ~ps;\n      if (size2 >= size)\n      {\n        void *res = VirtualAlloc(NULL, size2, MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);\n        if (res)\n          return res;\n      }\n    }\n  }\n  #endif\n\n  return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n}\n\nvoid BigFree(void *address)\n{\n  PRINT_FREE(\"Free-Big\", g_allocCountBig, address);\n\n  if (!address)\n    return;\n  VirtualFree(address, 0, MEM_RELEASE);\n}\n\n#endif\n\n\nstatic void *SzAlloc(ISzAllocPtr p, size_t size) { UNUSED_VAR(p); return MyAlloc(size); }\nstatic void SzFree(ISzAllocPtr p, void *address) { UNUSED_VAR(p); MyFree(address); }\nconst ISzAlloc g_Alloc = { SzAlloc, SzFree };\n\nstatic void *SzMidAlloc(ISzAllocPtr p, size_t size) { UNUSED_VAR(p); return MidAlloc(size); }\nstatic void SzMidFree(ISzAllocPtr p, void *address) { UNUSED_VAR(p); MidFree(address); }\nconst ISzAlloc g_MidAlloc = { SzMidAlloc, SzMidFree };\n\nstatic void *SzBigAlloc(ISzAllocPtr p, size_t size) { UNUSED_VAR(p); return BigAlloc(size); }\nstatic void SzBigFree(ISzAllocPtr p, void *address) { UNUSED_VAR(p); BigFree(address); }\nconst ISzAlloc g_BigAlloc = { SzBigAlloc, SzBigFree };\n\n\n/*\n  uintptr_t : <stdint.h> C99 (optional)\n            : unsupported in VS6\n*/\n\n#ifdef _WIN32\n  typedef UINT_PTR UIntPtr;\n#else\n  /*\n  typedef uintptr_t UIntPtr;\n  */\n  typedef ptrdiff_t UIntPtr;\n#endif\n\n\n#define ADJUST_ALLOC_SIZE 0\n/*\n#define ADJUST_ALLOC_SIZE (sizeof(void *) - 1)\n*/\n/*\n  Use (ADJUST_ALLOC_SIZE = (sizeof(void *) - 1)), if\n     MyAlloc() can return address that is NOT multiple of sizeof(void *).\n*/\n\n\n/*\n#define MY_ALIGN_PTR_DOWN(p, align) ((void *)((char *)(p) - ((size_t)(UIntPtr)(p) & ((align) - 1))))\n*/\n#define MY_ALIGN_PTR_DOWN(p, align) ((void *)((((UIntPtr)(p)) & ~((UIntPtr)(align) - 1))))\n\n#define MY_ALIGN_PTR_UP_PLUS(p, align) MY_ALIGN_PTR_DOWN(((char *)(p) + (align) + ADJUST_ALLOC_SIZE), align)\n\n\n#if ( defined( _POSIX_C_SOURCE ) && _POSIX_C_SOURCE >= 200112L) && !defined(_WIN32)\n  #define USE_posix_memalign\n#endif\n\n/*\n  This posix_memalign() is for test purposes only.\n  We also need special Free() function instead of free(),\n  if this posix_memalign() is used.\n*/\n\n/*\nstatic int posix_memalign(void **ptr, size_t align, size_t size)\n{\n  size_t newSize = size + align;\n  void *p;\n  void *pAligned;\n  *ptr = NULL;\n  if (newSize < size)\n    return 12; // ENOMEM\n  p = MyAlloc(newSize);\n  if (!p)\n    return 12; // ENOMEM\n  pAligned = MY_ALIGN_PTR_UP_PLUS(p, align);\n  ((void **)pAligned)[-1] = p;\n  *ptr = pAligned;\n  return 0;\n}\n*/\n\n/*\n  ALLOC_ALIGN_SIZE >= sizeof(void *)\n  ALLOC_ALIGN_SIZE >= cache_line_size\n*/\n\n#define ALLOC_ALIGN_SIZE ((size_t)1 << 7)\n\nstatic void *SzAlignedAlloc(ISzAllocPtr pp, size_t size)\n{\n  #ifndef USE_posix_memalign\n\n  void *p;\n  void *pAligned;\n  size_t newSize;\n  UNUSED_VAR(pp);\n\n  /* also we can allocate additional dummy ALLOC_ALIGN_SIZE bytes after aligned\n     block to prevent cache line sharing with another allocated blocks */\n\n  newSize = size + ALLOC_ALIGN_SIZE * 1 + ADJUST_ALLOC_SIZE;\n  if (newSize < size)\n    return NULL;\n\n  p = MyAlloc(newSize);\n\n  if (!p)\n    return NULL;\n  pAligned = MY_ALIGN_PTR_UP_PLUS(p, ALLOC_ALIGN_SIZE);\n\n  Print(\" size=\"); PrintHex(size, 8);\n  Print(\" a_size=\"); PrintHex(newSize, 8);\n  Print(\" ptr=\"); PrintAddr(p);\n  Print(\" a_ptr=\"); PrintAddr(pAligned);\n  PrintLn();\n\n  ((void **)pAligned)[-1] = p;\n\n  return pAligned;\n\n  #else\n\n  void *p;\n  UNUSED_VAR(pp);\n  if (posix_memalign(&p, ALLOC_ALIGN_SIZE, size))\n    return NULL;\n\n  Print(\" posix_memalign=\"); PrintAddr(p);\n  PrintLn();\n\n  return p;\n\n  #endif\n}\n\n\nstatic void SzAlignedFree(ISzAllocPtr pp, void *address)\n{\n  UNUSED_VAR(pp);\n  #ifndef USE_posix_memalign\n  if (address)\n    MyFree(((void **)address)[-1]);\n  #else\n  free(address);\n  #endif\n}\n\n\nconst ISzAlloc g_AlignedAlloc = { SzAlignedAlloc, SzAlignedFree };\n\n\n\n#define MY_ALIGN_PTR_DOWN_1(p) MY_ALIGN_PTR_DOWN(p, sizeof(void *))\n\n/* we align ptr to support cases where CAlignOffsetAlloc::offset is not multiply of sizeof(void *) */\n#define REAL_BLOCK_PTR_VAR(p) ((void **)MY_ALIGN_PTR_DOWN_1(p))[-1]\n/*\n#define REAL_BLOCK_PTR_VAR(p) ((void **)(p))[-1]\n*/\n\nstatic void *AlignOffsetAlloc_Alloc(ISzAllocPtr pp, size_t size)\n{\n  CAlignOffsetAlloc *p = CONTAINER_FROM_VTBL(pp, CAlignOffsetAlloc, vt);\n  void *adr;\n  void *pAligned;\n  size_t newSize;\n  size_t extra;\n  size_t alignSize = (size_t)1 << p->numAlignBits;\n\n  if (alignSize < sizeof(void *))\n    alignSize = sizeof(void *);\n\n  if (p->offset >= alignSize)\n    return NULL;\n\n  /* also we can allocate additional dummy ALLOC_ALIGN_SIZE bytes after aligned\n     block to prevent cache line sharing with another allocated blocks */\n  extra = p->offset & (sizeof(void *) - 1);\n  newSize = size + alignSize + extra + ADJUST_ALLOC_SIZE;\n  if (newSize < size)\n    return NULL;\n\n  adr = ISzAlloc_Alloc(p->baseAlloc, newSize);\n\n  if (!adr)\n    return NULL;\n\n  pAligned = (char *)MY_ALIGN_PTR_DOWN((char *)adr +\n      alignSize - p->offset + extra + ADJUST_ALLOC_SIZE, alignSize) + p->offset;\n\n  PrintLn();\n  Print(\"- Aligned: \");\n  Print(\" size=\"); PrintHex(size, 8);\n  Print(\" a_size=\"); PrintHex(newSize, 8);\n  Print(\" ptr=\"); PrintAddr(adr);\n  Print(\" a_ptr=\"); PrintAddr(pAligned);\n  PrintLn();\n\n  REAL_BLOCK_PTR_VAR(pAligned) = adr;\n\n  return pAligned;\n}\n\n\nstatic void AlignOffsetAlloc_Free(ISzAllocPtr pp, void *address)\n{\n  if (address)\n  {\n    CAlignOffsetAlloc *p = CONTAINER_FROM_VTBL(pp, CAlignOffsetAlloc, vt);\n    PrintLn();\n    Print(\"- Aligned Free: \");\n    PrintLn();\n    ISzAlloc_Free(p->baseAlloc, REAL_BLOCK_PTR_VAR(address));\n  }\n}\n\n\nvoid AlignOffsetAlloc_CreateVTable(CAlignOffsetAlloc *p)\n{\n  p->vt.Alloc = AlignOffsetAlloc_Alloc;\n  p->vt.Free = AlignOffsetAlloc_Free;\n}\n\n\n\n\n\n/* LzFind.h -- Match finder for LZ algorithms\n2017-06-10 : Igor Pavlov : Public domain */\n\ntypedef UInt32 CLzRef;\n\ntypedef struct _CMatchFinder\n{\n  Byte *buffer;\n  UInt32 pos;\n  UInt32 posLimit;\n  UInt32 streamPos;\n  UInt32 lenLimit;\n\n  UInt32 cyclicBufferPos;\n  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */\n\n  Byte streamEndWasReached;\n  Byte btMode;\n  Byte bigHash;\n  Byte directInput;\n\n  UInt32 matchMaxLen;\n  CLzRef *hash;\n  CLzRef *son;\n  UInt32 hashMask;\n  UInt32 cutValue;\n\n  Byte *bufferBase;\n  ISeqInStream *stream;\n\n  UInt32 blockSize;\n  UInt32 keepSizeBefore;\n  UInt32 keepSizeAfter;\n\n  UInt32 numHashBytes;\n  size_t directInputRem;\n  UInt32 historySize;\n  UInt32 fixedHashSize;\n  UInt32 hashSizeSum;\n  SRes result;\n  UInt32 crc[256];\n  size_t numRefs;\n\n  UInt64 expectedDataSize;\n} CMatchFinder;\n\n#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)\n\n#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)\n\n#define Inline_MatchFinder_IsFinishedOK(p) \\\n    ((p)->streamEndWasReached \\\n        && (p)->streamPos == (p)->pos \\\n        && (!(p)->directInput || (p)->directInputRem == 0))\n\nint MatchFinder_NeedMove(CMatchFinder *p);\nByte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);\nvoid MatchFinder_MoveBlock(CMatchFinder *p);\nvoid MatchFinder_ReadIfRequired(CMatchFinder *p);\n\nvoid MatchFinder_Construct(CMatchFinder *p);\n\n/* Conditions:\n     historySize <= 3 GB\n     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB\n*/\nint MatchFinder_Create(CMatchFinder *p, UInt32 historySize,\n    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,\n    ISzAllocPtr alloc);\nvoid MatchFinder_Free(CMatchFinder *p, ISzAllocPtr alloc);\nvoid MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, size_t numItems);\nvoid MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);\n\nUInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,\n    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,\n    UInt32 *distances, UInt32 maxLen);\n\n/*\nConditions:\n  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.\n  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function\n*/\n\ntypedef void (*Mf_Init_Func)(void *object);\ntypedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);\ntypedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);\ntypedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);\ntypedef void (*Mf_Skip_Func)(void *object, UInt32);\n\ntypedef struct _IMatchFinder\n{\n  Mf_Init_Func Init;\n  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;\n  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;\n  Mf_GetMatches_Func GetMatches;\n  Mf_Skip_Func Skip;\n} IMatchFinder;\n\nvoid MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);\n\nvoid MatchFinder_Init_LowHash(CMatchFinder *p);\nvoid MatchFinder_Init_HighHash(CMatchFinder *p);\nvoid MatchFinder_Init_3(CMatchFinder *p, int readData);\nvoid MatchFinder_Init(CMatchFinder *p);\n\nUInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);\nUInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);\n\nvoid Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);\nvoid Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);\n\n\n\n\n\n/* LzmaEnc.c -- LZMA Encoder\n2019-01-10: Igor Pavlov : Public domain */\n\n#include <string.h>\n\n/* #define SHOW_STAT */\n/* #define SHOW_STAT2 */\n\n#if defined(SHOW_STAT) || defined(SHOW_STAT2)\n#include <stdio.h>\n#endif\n\n\n#ifdef SHOW_STAT\nstatic unsigned g_STAT_OFFSET = 0;\n#endif\n\n#define kLzmaMaxHistorySize ((UInt32)3 << 29)\n/* #define kLzmaMaxHistorySize ((UInt32)7 << 29) */\n\n#define kNumTopBits 24\n#define kTopValue ((UInt32)1 << kNumTopBits)\n\n#define kNumBitModelTotalBits 11\n#define kBitModelTotal (1 << kNumBitModelTotalBits)\n#define kNumMoveBits 5\n#define kProbInitValue (kBitModelTotal >> 1)\n\n#define kNumMoveReducingBits 4\n#define kNumBitPriceShiftBits 4\n#define kBitPrice (1 << kNumBitPriceShiftBits)\n\n#define REP_LEN_COUNT 64\n\nvoid LzmaEncProps_Init(CLzmaEncProps *p)\n{\n  p->level = 5;\n  p->dictSize = p->mc = 0;\n  p->reduceSize = (UInt64)(Int64)-1;\n  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = -1;\n  p->writeEndMark = 0;\n}\n\nvoid LzmaEncProps_Normalize(CLzmaEncProps *p)\n{\n  int level = p->level;\n  if (level < 0) level = 5;\n  p->level = level;\n\n  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level <= 7 ? (1 << 25) : (1 << 26)));\n  if (p->dictSize > p->reduceSize)\n  {\n    unsigned i;\n    UInt32 reduceSize = (UInt32)p->reduceSize;\n    for (i = 11; i <= 30; i++)\n    {\n      if (reduceSize <= ((UInt32)2 << i)) { p->dictSize = ((UInt32)2 << i); break; }\n      if (reduceSize <= ((UInt32)3 << i)) { p->dictSize = ((UInt32)3 << i); break; }\n    }\n  }\n\n  if (p->lc < 0) p->lc = 3;\n  if (p->lp < 0) p->lp = 0;\n  if (p->pb < 0) p->pb = 2;\n\n  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);\n  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);\n  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);\n  if (p->numHashBytes < 0) p->numHashBytes = 4;\n  if (p->mc == 0) p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);\n}\n\nUInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)\n{\n  CLzmaEncProps props = *props2;\n  LzmaEncProps_Normalize(&props);\n  return props.dictSize;\n}\n\n#if (_MSC_VER >= 1400)\n/* BSR code is fast for some new CPUs */\n/* #define LZMA_LOG_BSR */\n#endif\n\n#ifdef LZMA_LOG_BSR\n\n#define kDicLogSizeMaxCompress 32\n\n#define BSR2_RET(pos, res) { unsigned long zz; _BitScanReverse(&zz, (pos)); res = (zz + zz) + ((pos >> (zz - 1)) & 1); }\n\nstatic unsigned GetPosSlot1(UInt32 pos)\n{\n  unsigned res;\n  BSR2_RET(pos, res);\n  return res;\n}\n#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }\n#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }\n\n#else\n\n#define kNumLogBits (9 + sizeof(size_t) / 2)\n/* #define kNumLogBits (11 + sizeof(size_t) / 8 * 3) */\n\n#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)\n\nstatic void LzmaEnc_FastPosInit(Byte *g_FastPos)\n{\n  unsigned slot;\n  g_FastPos[0] = 0;\n  g_FastPos[1] = 1;\n  g_FastPos += 2;\n\n  for (slot = 2; slot < kNumLogBits * 2; slot++)\n  {\n    size_t k = ((size_t)1 << ((slot >> 1) - 1));\n    size_t j;\n    for (j = 0; j < k; j++)\n      g_FastPos[j] = (Byte)slot;\n    g_FastPos += k;\n  }\n}\n\n/* we can use ((limit - pos) >> 31) only if (pos < ((UInt32)1 << 31)) */\n/*\n#define BSR2_RET(pos, res) { unsigned zz = 6 + ((kNumLogBits - 1) & \\\n  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \\\n  res = p->g_FastPos[pos >> zz] + (zz * 2); }\n*/\n\n/*\n#define BSR2_RET(pos, res) { unsigned zz = 6 + ((kNumLogBits - 1) & \\\n  (0 - (((((UInt32)1 << (kNumLogBits)) - 1) - (pos >> 6)) >> 31))); \\\n  res = p->g_FastPos[pos >> zz] + (zz * 2); }\n*/\n\n#define BSR2_RET(pos, res) { unsigned zz = (pos < (1 << (kNumLogBits + 6))) ? 6 : 6 + kNumLogBits - 1; \\\n  res = p->g_FastPos[pos >> zz] + (zz * 2); }\n\n/*\n#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \\\n  p->g_FastPos[pos >> 6] + 12 : \\\n  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }\n*/\n\n#define GetPosSlot1(pos) p->g_FastPos[pos]\n#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }\n#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos & (kNumFullDistances - 1)]; else BSR2_RET(pos, res); }\n\n#endif\n\n\n#define LZMA_NUM_REPS 4\n\ntypedef UInt16 CState;\ntypedef UInt16 CExtra;\n\ntypedef struct\n{\n  UInt32 price;\n  CState state;\n  CExtra extra;\n      // 0   : normal\n      // 1   : LIT : MATCH\n      // > 1 : MATCH (extra-1) : LIT : REP0 (len)\n  UInt32 len;\n  UInt32 dist;\n  UInt32 reps[LZMA_NUM_REPS];\n} COptimal;\n\n\n// 18.06\n#define kNumOpts (1 << 11)\n#define kPackReserve (kNumOpts * 8)\n// #define kNumOpts (1 << 12)\n// #define kPackReserve (1 + kNumOpts * 2)\n\n#define kNumLenToPosStates 4\n#define kNumPosSlotBits 6\n#define kDicLogSizeMin 0\n#define kDicLogSizeMax 32\n#define kDistTableSizeMax (kDicLogSizeMax * 2)\n\n#define kNumAlignBits 4\n#define kAlignTableSize (1 << kNumAlignBits)\n#define kAlignMask (kAlignTableSize - 1)\n\n#define kStartPosModelIndex 4\n#define kEndPosModelIndex 14\n#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))\n\n/*\ntypedef\n#ifdef _LZMA_PROB32\n  UInt32\n#else\n  UInt16\n#endif\n  CLzmaProb;\n*/\n\n#define LZMA_PB_MAX 4\n#define LZMA_LC_MAX 8\n#define LZMA_LP_MAX 4\n\n#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)\n\n#define kLenNumLowBits 3\n#define kLenNumLowSymbols (1 << kLenNumLowBits)\n#define kLenNumHighBits 8\n#define kLenNumHighSymbols (1 << kLenNumHighBits)\n#define kLenNumSymbolsTotal (kLenNumLowSymbols * 2 + kLenNumHighSymbols)\n\n#define LZMA_MATCH_LEN_MIN 2\n#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)\n\n#define kNumStates 12\n\n\ntypedef struct\n{\n  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << (kLenNumLowBits + 1)];\n  CLzmaProb high[kLenNumHighSymbols];\n} CLenEnc;\n\n\ntypedef struct\n{\n  unsigned tableSize;\n  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];\n  // UInt32 prices1[LZMA_NUM_PB_STATES_MAX][kLenNumLowSymbols * 2];\n  // UInt32 prices2[kLenNumSymbolsTotal];\n} CLenPriceEnc;\n\n#define GET_PRICE_LEN(p, posState, len) \\\n    ((p)->prices[posState][(size_t)(len) - LZMA_MATCH_LEN_MIN])\n\n/*\n#define GET_PRICE_LEN(p, posState, len) \\\n    ((p)->prices2[(size_t)(len) - 2] + ((p)->prices1[posState][((len) - 2) & (kLenNumLowSymbols * 2 - 1)] & (((len) - 2 - kLenNumLowSymbols * 2) >> 9)))\n*/\n\ntypedef struct\n{\n  UInt32 range;\n  unsigned cache;\n  UInt64 low;\n  UInt64 cacheSize;\n  Byte *buf;\n  Byte *bufLim;\n  Byte *bufBase;\n  ISeqOutStream *outStream;\n  UInt64 processed;\n  SRes res;\n} CRangeEnc;\n\n\ntypedef struct\n{\n  CLzmaProb *litProbs;\n\n  unsigned state;\n  UInt32 reps[LZMA_NUM_REPS];\n\n  CLzmaProb posAlignEncoder[1 << kNumAlignBits];\n  CLzmaProb isRep[kNumStates];\n  CLzmaProb isRepG0[kNumStates];\n  CLzmaProb isRepG1[kNumStates];\n  CLzmaProb isRepG2[kNumStates];\n  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];\n  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];\n\n  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];\n  CLzmaProb posEncoders[kNumFullDistances];\n\n  CLenEnc lenProbs;\n  CLenEnc repLenProbs;\n\n} CSaveState;\n\n\ntypedef UInt32 CProbPrice;\n\n\ntypedef struct\n{\n  void *matchFinderObj;\n  IMatchFinder matchFinder;\n\n  unsigned optCur;\n  unsigned optEnd;\n\n  unsigned longestMatchLen;\n  unsigned numPairs;\n  UInt32 numAvail;\n\n  unsigned state;\n  unsigned numFastBytes;\n  unsigned additionalOffset;\n  UInt32 reps[LZMA_NUM_REPS];\n  unsigned lpMask, pbMask;\n  CLzmaProb *litProbs;\n  CRangeEnc rc;\n\n  UInt32 backRes;\n\n  unsigned lc, lp, pb;\n  unsigned lclp;\n\n  BoolInt fastMode;\n  BoolInt writeEndMark;\n  BoolInt finished;\n  BoolInt needInit;\n  // BoolInt _maxMode;\n\n  UInt64 nowPos64;\n\n  unsigned matchPriceCount;\n  // unsigned alignPriceCount;\n  int repLenEncCounter;\n\n  unsigned distTableSize;\n\n  UInt32 dictSize;\n  SRes result;\n\n  CMatchFinder matchFinderBase;\n\n  CProbPrice ProbPrices[kBitModelTotal >> kNumMoveReducingBits];\n\n  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];\n\n  UInt32 alignPrices[kAlignTableSize];\n  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];\n  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];\n\n  CLzmaProb posAlignEncoder[1 << kNumAlignBits];\n  CLzmaProb isRep[kNumStates];\n  CLzmaProb isRepG0[kNumStates];\n  CLzmaProb isRepG1[kNumStates];\n  CLzmaProb isRepG2[kNumStates];\n  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];\n  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];\n  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];\n  CLzmaProb posEncoders[kNumFullDistances];\n\n  CLenEnc lenProbs;\n  CLenEnc repLenProbs;\n\n  #ifndef LZMA_LOG_BSR\n  Byte g_FastPos[1 << kNumLogBits];\n  #endif\n\n  CLenPriceEnc lenEnc;\n  CLenPriceEnc repLenEnc;\n\n  COptimal opt[kNumOpts];\n\n  CSaveState saveState;\n\n} CLzmaEnc;\n\n\n\n#define COPY_ARR(dest, src, arr) memcpy(dest->arr, src->arr, sizeof(src->arr));\n\nvoid LzmaEnc_SaveState(CLzmaEncHandle pp)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  CSaveState *dest = &p->saveState;\n\n  dest->state = p->state;\n\n  dest->lenProbs = p->lenProbs;\n  dest->repLenProbs = p->repLenProbs;\n\n  COPY_ARR(dest, p, reps);\n\n  COPY_ARR(dest, p, posAlignEncoder);\n  COPY_ARR(dest, p, isRep);\n  COPY_ARR(dest, p, isRepG0);\n  COPY_ARR(dest, p, isRepG1);\n  COPY_ARR(dest, p, isRepG2);\n  COPY_ARR(dest, p, isMatch);\n  COPY_ARR(dest, p, isRep0Long);\n  COPY_ARR(dest, p, posSlotEncoder);\n  COPY_ARR(dest, p, posEncoders);\n\n  memcpy(dest->litProbs, p->litProbs, ((UInt32)0x300 << p->lclp) * sizeof(CLzmaProb));\n}\n\n\nvoid LzmaEnc_RestoreState(CLzmaEncHandle pp)\n{\n  CLzmaEnc *dest = (CLzmaEnc *)pp;\n  const CSaveState *p = &dest->saveState;\n\n  dest->state = p->state;\n\n  dest->lenProbs = p->lenProbs;\n  dest->repLenProbs = p->repLenProbs;\n\n  COPY_ARR(dest, p, reps);\n\n  COPY_ARR(dest, p, posAlignEncoder);\n  COPY_ARR(dest, p, isRep);\n  COPY_ARR(dest, p, isRepG0);\n  COPY_ARR(dest, p, isRepG1);\n  COPY_ARR(dest, p, isRepG2);\n  COPY_ARR(dest, p, isMatch);\n  COPY_ARR(dest, p, isRep0Long);\n  COPY_ARR(dest, p, posSlotEncoder);\n  COPY_ARR(dest, p, posEncoders);\n\n  memcpy(dest->litProbs, p->litProbs, ((UInt32)0x300 << dest->lclp) * sizeof(CLzmaProb));\n}\n\n\n\nSRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  CLzmaEncProps props = *props2;\n  LzmaEncProps_Normalize(&props);\n\n  if (props.lc > LZMA_LC_MAX\n      || props.lp > LZMA_LP_MAX\n      || props.pb > LZMA_PB_MAX\n      || props.dictSize > ((UInt64)1 << kDicLogSizeMaxCompress)\n      || props.dictSize > kLzmaMaxHistorySize)\n    return SZ_ERROR_PARAM;\n\n  p->dictSize = props.dictSize;\n  {\n    unsigned fb = props.fb;\n    if (fb < 5)\n      fb = 5;\n    if (fb > LZMA_MATCH_LEN_MAX)\n      fb = LZMA_MATCH_LEN_MAX;\n    p->numFastBytes = fb;\n  }\n  p->lc = props.lc;\n  p->lp = props.lp;\n  p->pb = props.pb;\n  p->fastMode = (props.algo == 0);\n  // p->_maxMode = True;\n  p->matchFinderBase.btMode = (Byte)(props.btMode ? 1 : 0);\n  {\n    unsigned numHashBytes = 4;\n    if (props.btMode)\n    {\n      if (props.numHashBytes < 2)\n        numHashBytes = 2;\n      else if (props.numHashBytes < 4)\n        numHashBytes = props.numHashBytes;\n    }\n    p->matchFinderBase.numHashBytes = numHashBytes;\n  }\n\n  p->matchFinderBase.cutValue = props.mc;\n\n  p->writeEndMark = props.writeEndMark;\n\n  return SZ_OK;\n}\n\n\nvoid LzmaEnc_SetDataSize(CLzmaEncHandle pp, UInt64 expectedDataSiize)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  p->matchFinderBase.expectedDataSize = expectedDataSiize;\n}\n\n\n#define kState_Start 0\n#define kState_LitAfterMatch 4\n#define kState_LitAfterRep   5\n#define kState_MatchAfterLit 7\n#define kState_RepAfterLit   8\n\nstatic const Byte kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};\nstatic const Byte kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};\nstatic const Byte kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};\nstatic const Byte kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};\n\n#define IsLitState(s) ((s) < 7)\n#define GetLenToPosState2(len) (((len) < kNumLenToPosStates - 1) ? (len) : kNumLenToPosStates - 1)\n#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)\n\n#define kInfinityPrice (1 << 30)\n\nstatic void RangeEnc_Construct(CRangeEnc *p)\n{\n  p->outStream = NULL;\n  p->bufBase = NULL;\n}\n\n#define RangeEnc_GetProcessed(p)       ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)\n#define RangeEnc_GetProcessed_size_t(p) ((size_t)(p)->processed + ((p)->buf - (p)->bufBase) + (size_t)(p)->cacheSize)\n\n#define RC_BUF_SIZE (1 << 16)\n\nstatic int RangeEnc_Alloc(CRangeEnc *p, ISzAllocPtr alloc)\n{\n  if (!p->bufBase)\n  {\n    p->bufBase = (Byte *)ISzAlloc_Alloc(alloc, RC_BUF_SIZE);\n    if (!p->bufBase)\n      return 0;\n    p->bufLim = p->bufBase + RC_BUF_SIZE;\n  }\n  return 1;\n}\n\nstatic void RangeEnc_Free(CRangeEnc *p, ISzAllocPtr alloc)\n{\n  ISzAlloc_Free(alloc, p->bufBase);\n  p->bufBase = 0;\n}\n\nstatic void RangeEnc_Init(CRangeEnc *p)\n{\n  /* Stream.Init(); */\n  p->range = 0xFFFFFFFF;\n  p->cache = 0;\n  p->low = 0;\n  p->cacheSize = 0;\n\n  p->buf = p->bufBase;\n\n  p->processed = 0;\n  p->res = SZ_OK;\n}\n\nMY_NO_INLINE static void RangeEnc_FlushStream(CRangeEnc *p)\n{\n  size_t num;\n  if (p->res != SZ_OK)\n    return;\n  num = p->buf - p->bufBase;\n  if (num != ISeqOutStream_Write(p->outStream, p->bufBase, num))\n    p->res = SZ_ERROR_WRITE;\n  p->processed += num;\n  p->buf = p->bufBase;\n}\n\nMY_NO_INLINE static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)\n{\n  UInt32 low = (UInt32)p->low;\n  unsigned high = (unsigned)(p->low >> 32);\n  p->low = (UInt32)(low << 8);\n  if (low < (UInt32)0xFF000000 || high != 0)\n  {\n    {\n      Byte *buf = p->buf;\n      *buf++ = (Byte)(p->cache + high);\n      p->cache = (unsigned)(low >> 24);\n      p->buf = buf;\n      if (buf == p->bufLim)\n        RangeEnc_FlushStream(p);\n      if (p->cacheSize == 0)\n        return;\n    }\n    high += 0xFF;\n    for (;;)\n    {\n      Byte *buf = p->buf;\n      *buf++ = (Byte)(high);\n      p->buf = buf;\n      if (buf == p->bufLim)\n        RangeEnc_FlushStream(p);\n      if (--p->cacheSize == 0)\n        return;\n    }\n  }\n  p->cacheSize++;\n}\n\nstatic void RangeEnc_FlushData(CRangeEnc *p)\n{\n  int i;\n  for (i = 0; i < 5; i++)\n    RangeEnc_ShiftLow(p);\n}\n\n#define RC_NORM(p) if (range < kTopValue) { range <<= 8; RangeEnc_ShiftLow(p); }\n\n#define RC_BIT_PRE(p, prob) \\\n  ttt = *(prob); \\\n  newBound = (range >> kNumBitModelTotalBits) * ttt;\n\n// #define _LZMA_ENC_USE_BRANCH\n\n#ifdef _LZMA_ENC_USE_BRANCH\n\n#define RC_BIT(p, prob, bit) { \\\n  RC_BIT_PRE(p, prob) \\\n  if (bit == 0) { range = newBound; ttt += (kBitModelTotal - ttt) >> kNumMoveBits; } \\\n  else { (p)->low += newBound; range -= newBound; ttt -= ttt >> kNumMoveBits; } \\\n  *(prob) = (CLzmaProb)ttt; \\\n  RC_NORM(p) \\\n  }\n\n#else\n\n#define RC_BIT(p, prob, bit) { \\\n  UInt32 mask; \\\n  RC_BIT_PRE(p, prob) \\\n  mask = 0 - (UInt32)bit; \\\n  range &= mask; \\\n  mask &= newBound; \\\n  range -= mask; \\\n  (p)->low += mask; \\\n  mask = (UInt32)bit - 1; \\\n  range += newBound & mask; \\\n  mask &= (kBitModelTotal - ((1 << kNumMoveBits) - 1)); \\\n  mask += ((1 << kNumMoveBits) - 1); \\\n  ttt += (Int32)(mask - ttt) >> kNumMoveBits; \\\n  *(prob) = (CLzmaProb)ttt; \\\n  RC_NORM(p) \\\n  }\n\n#endif\n\n\n\n\n#define RC_BIT_0_BASE(p, prob) \\\n  range = newBound; *(prob) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));\n\n#define RC_BIT_1_BASE(p, prob) \\\n  range -= newBound; (p)->low += newBound; *(prob) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits)); \\\n\n#define RC_BIT_0(p, prob) \\\n  RC_BIT_0_BASE(p, prob) \\\n  RC_NORM(p)\n\n#define RC_BIT_1(p, prob) \\\n  RC_BIT_1_BASE(p, prob) \\\n  RC_NORM(p)\n\nstatic void RangeEnc_EncodeBit_0(CRangeEnc *p, CLzmaProb *prob)\n{\n  UInt32 range, ttt, newBound;\n  range = p->range;\n  RC_BIT_PRE(p, prob)\n  RC_BIT_0(p, prob)\n  p->range = range;\n}\n\nstatic void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 sym)\n{\n  UInt32 range = p->range;\n  sym |= 0x100;\n  do\n  {\n    UInt32 ttt, newBound;\n    // RangeEnc_EncodeBit(p, probs + (sym >> 8), (sym >> 7) & 1);\n    CLzmaProb *prob = probs + (sym >> 8);\n    UInt32 bit = (sym >> 7) & 1;\n    sym <<= 1;\n    RC_BIT(p, prob, bit);\n  }\n  while (sym < 0x10000);\n  p->range = range;\n}\n\nstatic void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 sym, UInt32 matchByte)\n{\n  UInt32 range = p->range;\n  UInt32 offs = 0x100;\n  sym |= 0x100;\n  do\n  {\n    UInt32 ttt, newBound;\n    CLzmaProb *prob;\n    UInt32 bit;\n    matchByte <<= 1;\n    // RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (sym >> 8)), (sym >> 7) & 1);\n    prob = probs + (offs + (matchByte & offs) + (sym >> 8));\n    bit = (sym >> 7) & 1;\n    sym <<= 1;\n    offs &= ~(matchByte ^ sym);\n    RC_BIT(p, prob, bit);\n  }\n  while (sym < 0x10000);\n  p->range = range;\n}\n\n\n\nstatic void LzmaEnc_InitPriceTables(CProbPrice *ProbPrices)\n{\n  UInt32 i;\n  for (i = 0; i < (kBitModelTotal >> kNumMoveReducingBits); i++)\n  {\n    const unsigned kCyclesBits = kNumBitPriceShiftBits;\n    UInt32 w = (i << kNumMoveReducingBits) + (1 << (kNumMoveReducingBits - 1));\n    unsigned bitCount = 0;\n    unsigned j;\n    for (j = 0; j < kCyclesBits; j++)\n    {\n      w = w * w;\n      bitCount <<= 1;\n      while (w >= ((UInt32)1 << 16))\n      {\n        w >>= 1;\n        bitCount++;\n      }\n    }\n    ProbPrices[i] = (CProbPrice)((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);\n    // printf(\"\\n%3d: %5d\", i, ProbPrices[i]);\n  }\n}\n\n\n#define GET_PRICE(prob, bit) \\\n  p->ProbPrices[((prob) ^ (unsigned)(((-(int)(bit))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];\n\n#define GET_PRICEa(prob, bit) \\\n     ProbPrices[((prob) ^ (unsigned)((-((int)(bit))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];\n\n#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]\n#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]\n\n#define GET_PRICEa_0(prob) ProbPrices[(prob) >> kNumMoveReducingBits]\n#define GET_PRICEa_1(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]\n\n\nstatic UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 sym, const CProbPrice *ProbPrices)\n{\n  UInt32 price = 0;\n  sym |= 0x100;\n  do\n  {\n    unsigned bit = sym & 1;\n    sym >>= 1;\n    price += GET_PRICEa(probs[sym], bit);\n  }\n  while (sym >= 2);\n  return price;\n}\n\n\nstatic UInt32 LitEnc_Matched_GetPrice(const CLzmaProb *probs, UInt32 sym, UInt32 matchByte, const CProbPrice *ProbPrices)\n{\n  UInt32 price = 0;\n  UInt32 offs = 0x100;\n  sym |= 0x100;\n  do\n  {\n    matchByte <<= 1;\n    price += GET_PRICEa(probs[offs + (matchByte & offs) + (sym >> 8)], (sym >> 7) & 1);\n    sym <<= 1;\n    offs &= ~(matchByte ^ sym);\n  }\n  while (sym < 0x10000);\n  return price;\n}\n\n\nstatic void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, unsigned numBits, unsigned sym)\n{\n  UInt32 range = rc->range;\n  unsigned m = 1;\n  do\n  {\n    UInt32 ttt, newBound;\n    unsigned bit = sym & 1;\n    // RangeEnc_EncodeBit(rc, probs + m, bit);\n    sym >>= 1;\n    RC_BIT(rc, probs + m, bit);\n    m = (m << 1) | bit;\n  }\n  while (--numBits);\n  rc->range = range;\n}\n\n\n\nstatic void LenEnc_Init(CLenEnc *p)\n{\n  unsigned i;\n  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << (kLenNumLowBits + 1)); i++)\n    p->low[i] = kProbInitValue;\n  for (i = 0; i < kLenNumHighSymbols; i++)\n    p->high[i] = kProbInitValue;\n}\n\nstatic void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, unsigned sym, unsigned posState)\n{\n  UInt32 range, ttt, newBound;\n  CLzmaProb *probs = p->low;\n  range = rc->range;\n  RC_BIT_PRE(rc, probs);\n  if (sym >= kLenNumLowSymbols)\n  {\n    RC_BIT_1(rc, probs);\n    probs += kLenNumLowSymbols;\n    RC_BIT_PRE(rc, probs);\n    if (sym >= kLenNumLowSymbols * 2)\n    {\n      RC_BIT_1(rc, probs);\n      rc->range = range;\n      // RcTree_Encode(rc, p->high, kLenNumHighBits, sym - kLenNumLowSymbols * 2);\n      LitEnc_Encode(rc, p->high, sym - kLenNumLowSymbols * 2);\n      return;\n    }\n    sym -= kLenNumLowSymbols;\n  }\n\n  // RcTree_Encode(rc, probs + (posState << kLenNumLowBits), kLenNumLowBits, sym);\n  {\n    unsigned m;\n    unsigned bit;\n    RC_BIT_0(rc, probs);\n    probs += (posState << (1 + kLenNumLowBits));\n    bit = (sym >> 2)    ; RC_BIT(rc, probs + 1, bit); m = (1 << 1) + bit;\n    bit = (sym >> 1) & 1; RC_BIT(rc, probs + m, bit); m = (m << 1) + bit;\n    bit =  sym       & 1; RC_BIT(rc, probs + m, bit);\n    rc->range = range;\n  }\n}\n\nstatic void SetPrices_3(const CLzmaProb *probs, UInt32 startPrice, UInt32 *prices, const CProbPrice *ProbPrices)\n{\n  unsigned i;\n  for (i = 0; i < 8; i += 2)\n  {\n    UInt32 price = startPrice;\n    UInt32 prob;\n    price += GET_PRICEa(probs[1           ], (i >> 2));\n    price += GET_PRICEa(probs[2 + (i >> 2)], (i >> 1) & 1);\n    prob = probs[4 + (i >> 1)];\n    prices[i    ] = price + GET_PRICEa_0(prob);\n    prices[i + 1] = price + GET_PRICEa_1(prob);\n  }\n}\n\n\nMY_NO_INLINE static void MY_FAST_CALL LenPriceEnc_UpdateTables(\n    CLenPriceEnc *p,\n    unsigned numPosStates,\n    const CLenEnc *enc,\n    const CProbPrice *ProbPrices)\n{\n  UInt32 b;\n\n  {\n    unsigned prob = enc->low[0];\n    UInt32 a, c;\n    unsigned posState;\n    b = GET_PRICEa_1(prob);\n    a = GET_PRICEa_0(prob);\n    c = b + GET_PRICEa_0(enc->low[kLenNumLowSymbols]);\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n      UInt32 *prices = p->prices[posState];\n      const CLzmaProb *probs = enc->low + (posState << (1 + kLenNumLowBits));\n      SetPrices_3(probs, a, prices, ProbPrices);\n      SetPrices_3(probs + kLenNumLowSymbols, c, prices + kLenNumLowSymbols, ProbPrices);\n    }\n  }\n\n  /*\n  {\n    unsigned i;\n    UInt32 b;\n    a = GET_PRICEa_0(enc->low[0]);\n    for (i = 0; i < kLenNumLowSymbols; i++)\n      p->prices2[i] = a;\n    a = GET_PRICEa_1(enc->low[0]);\n    b = a + GET_PRICEa_0(enc->low[kLenNumLowSymbols]);\n    for (i = kLenNumLowSymbols; i < kLenNumLowSymbols * 2; i++)\n      p->prices2[i] = b;\n    a += GET_PRICEa_1(enc->low[kLenNumLowSymbols]);\n  }\n  */\n\n  // p->counter = numSymbols;\n  // p->counter = 64;\n\n  {\n    unsigned i = p->tableSize;\n\n    if (i > kLenNumLowSymbols * 2)\n    {\n      const CLzmaProb *probs = enc->high;\n      UInt32 *prices = p->prices[0] + kLenNumLowSymbols * 2;\n      i -= kLenNumLowSymbols * 2 - 1;\n      i >>= 1;\n      b += GET_PRICEa_1(enc->low[kLenNumLowSymbols]);\n      do\n      {\n        /*\n        p->prices2[i] = a +\n        // RcTree_GetPrice(enc->high, kLenNumHighBits, i - kLenNumLowSymbols * 2, ProbPrices);\n        LitEnc_GetPrice(probs, i - kLenNumLowSymbols * 2, ProbPrices);\n        */\n        // UInt32 price = a + RcTree_GetPrice(probs, kLenNumHighBits - 1, sym, ProbPrices);\n        unsigned sym = --i + (1 << (kLenNumHighBits - 1));\n        UInt32 price = b;\n        do\n        {\n          unsigned bit = sym & 1;\n          sym >>= 1;\n          price += GET_PRICEa(probs[sym], bit);\n        }\n        while (sym >= 2);\n\n        {\n          unsigned prob = probs[(size_t)i + (1 << (kLenNumHighBits - 1))];\n          prices[(size_t)i * 2    ] = price + GET_PRICEa_0(prob);\n          prices[(size_t)i * 2 + 1] = price + GET_PRICEa_1(prob);\n        }\n      }\n      while (i);\n\n      {\n        unsigned posState;\n        size_t num = (p->tableSize - kLenNumLowSymbols * 2) * sizeof(p->prices[0][0]);\n        for (posState = 1; posState < numPosStates; posState++)\n          memcpy(p->prices[posState] + kLenNumLowSymbols * 2, p->prices[0] + kLenNumLowSymbols * 2, num);\n      }\n    }\n  }\n}\n\n/*\n  #ifdef SHOW_STAT\n  g_STAT_OFFSET += num;\n  printf(\"\\n MovePos %u\", num);\n  #endif\n*/\n\n#define MOVE_POS(p, num) { \\\n    p->additionalOffset += (num); \\\n    p->matchFinder.Skip(p->matchFinderObj, (UInt32)(num)); }\n\n\nstatic unsigned ReadMatchDistances(CLzmaEnc *p, unsigned *numPairsRes)\n{\n  unsigned numPairs;\n\n  p->additionalOffset++;\n  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);\n  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);\n  *numPairsRes = numPairs;\n\n  #ifdef SHOW_STAT\n  printf(\"\\n i = %u numPairs = %u    \", g_STAT_OFFSET, numPairs / 2);\n  g_STAT_OFFSET++;\n  {\n    unsigned i;\n    for (i = 0; i < numPairs; i += 2)\n      printf(\"%2u %6u   | \", p->matches[i], p->matches[i + 1]);\n  }\n  #endif\n\n  if (numPairs == 0)\n    return 0;\n  {\n    unsigned len = p->matches[(size_t)numPairs - 2];\n    if (len != p->numFastBytes)\n      return len;\n    {\n      UInt32 numAvail = p->numAvail;\n      if (numAvail > LZMA_MATCH_LEN_MAX)\n        numAvail = LZMA_MATCH_LEN_MAX;\n      {\n        const Byte *p1 = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;\n        const Byte *p2 = p1 + len;\n        ptrdiff_t dif = (ptrdiff_t)-1 - p->matches[(size_t)numPairs - 1];\n        const Byte *lim = p1 + numAvail;\n        for (; p2 != lim && *p2 == p2[dif]; p2++)\n        {}\n        return (unsigned)(p2 - p1);\n      }\n    }\n  }\n}\n\n#define MARK_LIT ((UInt32)(Int32)-1)\n\n#define MakeAs_Lit(p)       { (p)->dist = MARK_LIT; (p)->extra = 0; }\n#define MakeAs_ShortRep(p)  { (p)->dist = 0; (p)->extra = 0; }\n#define IsShortRep(p)       ((p)->dist == 0)\n\n\n#define GetPrice_ShortRep(p, state, posState) \\\n  ( GET_PRICE_0(p->isRepG0[state]) + GET_PRICE_0(p->isRep0Long[state][posState]))\n\n#define GetPrice_Rep_0(p, state, posState) ( \\\n    GET_PRICE_1(p->isMatch[state][posState]) \\\n  + GET_PRICE_1(p->isRep0Long[state][posState])) \\\n  + GET_PRICE_1(p->isRep[state]) \\\n  + GET_PRICE_0(p->isRepG0[state])\n\nMY_FORCE_INLINE\nstatic UInt32 GetPrice_PureRep(const CLzmaEnc *p, unsigned repIndex, size_t state, size_t posState)\n{\n  UInt32 price;\n  UInt32 prob = p->isRepG0[state];\n  if (repIndex == 0)\n  {\n    price = GET_PRICE_0(prob);\n    price += GET_PRICE_1(p->isRep0Long[state][posState]);\n  }\n  else\n  {\n    price = GET_PRICE_1(prob);\n    prob = p->isRepG1[state];\n    if (repIndex == 1)\n      price += GET_PRICE_0(prob);\n    else\n    {\n      price += GET_PRICE_1(prob);\n      price += GET_PRICE(p->isRepG2[state], repIndex - 2);\n    }\n  }\n  return price;\n}\n\n\nstatic unsigned Backward(CLzmaEnc *p, unsigned cur)\n{\n  unsigned wr = cur + 1;\n  p->optEnd = wr;\n\n  for (;;)\n  {\n    UInt32 dist = p->opt[cur].dist;\n    unsigned len = (unsigned)p->opt[cur].len;\n    unsigned extra = (unsigned)p->opt[cur].extra;\n    cur -= len;\n\n    if (extra)\n    {\n      wr--;\n      p->opt[wr].len = (UInt32)len;\n      cur -= extra;\n      len = extra;\n      if (extra == 1)\n      {\n        p->opt[wr].dist = dist;\n        dist = MARK_LIT;\n      }\n      else\n      {\n        p->opt[wr].dist = 0;\n        len--;\n        wr--;\n        p->opt[wr].dist = MARK_LIT;\n        p->opt[wr].len = 1;\n      }\n    }\n\n    if (cur == 0)\n    {\n      p->backRes = dist;\n      p->optCur = wr;\n      return len;\n    }\n\n    wr--;\n    p->opt[wr].dist = dist;\n    p->opt[wr].len = (UInt32)len;\n  }\n}\n\n\n\n#define LIT_PROBS(pos, prevByte) \\\n  (p->litProbs + (UInt32)3 * (((((pos) << 8) + (prevByte)) & p->lpMask) << p->lc))\n\n\nstatic unsigned GetOptimum(CLzmaEnc *p, UInt32 position)\n{\n  unsigned last, cur;\n  UInt32 reps[LZMA_NUM_REPS];\n  unsigned repLens[LZMA_NUM_REPS];\n  UInt32 *matches;\n\n  {\n    UInt32 numAvail;\n    unsigned numPairs, mainLen, repMaxIndex, i, posState;\n    UInt32 matchPrice, repMatchPrice;\n    const Byte *data;\n    Byte curByte, matchByte;\n\n    p->optCur = p->optEnd = 0;\n\n    if (p->additionalOffset == 0)\n      mainLen = ReadMatchDistances(p, &numPairs);\n    else\n    {\n      mainLen = p->longestMatchLen;\n      numPairs = p->numPairs;\n    }\n\n    numAvail = p->numAvail;\n    if (numAvail < 2)\n    {\n      p->backRes = MARK_LIT;\n      return 1;\n    }\n    if (numAvail > LZMA_MATCH_LEN_MAX)\n      numAvail = LZMA_MATCH_LEN_MAX;\n\n    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;\n    repMaxIndex = 0;\n\n    for (i = 0; i < LZMA_NUM_REPS; i++)\n    {\n      unsigned len;\n      const Byte *data2;\n      reps[i] = p->reps[i];\n      data2 = data - reps[i];\n      if (data[0] != data2[0] || data[1] != data2[1])\n      {\n        repLens[i] = 0;\n        continue;\n      }\n      for (len = 2; len < numAvail && data[len] == data2[len]; len++)\n      {}\n      repLens[i] = len;\n      if (len > repLens[repMaxIndex])\n        repMaxIndex = i;\n    }\n\n    if (repLens[repMaxIndex] >= p->numFastBytes)\n    {\n      unsigned len;\n      p->backRes = (UInt32)repMaxIndex;\n      len = repLens[repMaxIndex];\n      MOVE_POS(p, len - 1)\n      return len;\n    }\n\n    matches = p->matches;\n\n    if (mainLen >= p->numFastBytes)\n    {\n      p->backRes = matches[(size_t)numPairs - 1] + LZMA_NUM_REPS;\n      MOVE_POS(p, mainLen - 1)\n      return mainLen;\n    }\n\n    curByte = *data;\n    matchByte = *(data - reps[0]);\n\n    last = repLens[repMaxIndex];\n    if (last <= mainLen)\n      last = mainLen;\n\n    if (last < 2 && curByte != matchByte)\n    {\n      p->backRes = MARK_LIT;\n      return 1;\n    }\n\n    p->opt[0].state = (CState)p->state;\n\n    posState = (position & p->pbMask);\n\n    {\n      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));\n      p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +\n        (!IsLitState(p->state) ?\n          LitEnc_Matched_GetPrice(probs, curByte, matchByte, p->ProbPrices) :\n          LitEnc_GetPrice(probs, curByte, p->ProbPrices));\n    }\n\n    MakeAs_Lit(&p->opt[1]);\n\n    matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);\n    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);\n\n    // 18.06\n    if (matchByte == curByte && repLens[0] == 0)\n    {\n      UInt32 shortRepPrice = repMatchPrice + GetPrice_ShortRep(p, p->state, posState);\n      if (shortRepPrice < p->opt[1].price)\n      {\n        p->opt[1].price = shortRepPrice;\n        MakeAs_ShortRep(&p->opt[1]);\n      }\n      if (last < 2)\n      {\n        p->backRes = p->opt[1].dist;\n        return 1;\n      }\n    }\n\n    p->opt[1].len = 1;\n\n    p->opt[0].reps[0] = reps[0];\n    p->opt[0].reps[1] = reps[1];\n    p->opt[0].reps[2] = reps[2];\n    p->opt[0].reps[3] = reps[3];\n\n    // ---------- REP ----------\n\n    for (i = 0; i < LZMA_NUM_REPS; i++)\n    {\n      unsigned repLen = repLens[i];\n      UInt32 price;\n      if (repLen < 2)\n        continue;\n      price = repMatchPrice + GetPrice_PureRep(p, i, p->state, posState);\n      do\n      {\n        UInt32 price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState, repLen);\n        COptimal *opt = &p->opt[repLen];\n        if (price2 < opt->price)\n        {\n          opt->price = price2;\n          opt->len = (UInt32)repLen;\n          opt->dist = (UInt32)i;\n          opt->extra = 0;\n        }\n      }\n      while (--repLen >= 2);\n    }\n\n\n    // ---------- MATCH ----------\n    {\n      unsigned len = repLens[0] + 1;\n      if (len <= mainLen)\n      {\n        unsigned offs = 0;\n        UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);\n\n        if (len < 2)\n          len = 2;\n        else\n          while (len > matches[offs])\n            offs += 2;\n\n        for (; ; len++)\n        {\n          COptimal *opt;\n          UInt32 dist = matches[(size_t)offs + 1];\n          UInt32 price = normalMatchPrice + GET_PRICE_LEN(&p->lenEnc, posState, len);\n          unsigned lenToPosState = GetLenToPosState(len);\n\n          if (dist < kNumFullDistances)\n            price += p->distancesPrices[lenToPosState][dist & (kNumFullDistances - 1)];\n          else\n          {\n            unsigned slot;\n            GetPosSlot2(dist, slot);\n            price += p->alignPrices[dist & kAlignMask];\n            price += p->posSlotPrices[lenToPosState][slot];\n          }\n\n          opt = &p->opt[len];\n\n          if (price < opt->price)\n          {\n            opt->price = price;\n            opt->len = (UInt32)len;\n            opt->dist = dist + LZMA_NUM_REPS;\n            opt->extra = 0;\n          }\n\n          if (len == matches[offs])\n          {\n            offs += 2;\n            if (offs == numPairs)\n              break;\n          }\n        }\n      }\n    }\n\n\n    cur = 0;\n\n    #ifdef SHOW_STAT2\n    /* if (position >= 0) */\n    {\n      unsigned i;\n      printf(\"\\n pos = %4X\", position);\n      for (i = cur; i <= last; i++)\n      printf(\"\\nprice[%4X] = %u\", position - cur + i, p->opt[i].price);\n    }\n    #endif\n  }\n\n\n\n  // ---------- Optimal Parsing ----------\n\n  for (;;)\n  {\n    unsigned numAvail;\n    UInt32 numAvailFull;\n    unsigned newLen, numPairs, prev, state, posState, startLen;\n    UInt32 litPrice, matchPrice, repMatchPrice;\n    BoolInt nextIsLit;\n    Byte curByte, matchByte;\n    const Byte *data;\n    COptimal *curOpt, *nextOpt;\n\n    if (++cur == last)\n      break;\n\n    // 18.06\n    if (cur >= kNumOpts - 64)\n    {\n      unsigned j, best;\n      UInt32 price = p->opt[cur].price;\n      best = cur;\n      for (j = cur + 1; j <= last; j++)\n      {\n        UInt32 price2 = p->opt[j].price;\n        if (price >= price2)\n        {\n          price = price2;\n          best = j;\n        }\n      }\n      {\n        unsigned delta = best - cur;\n        if (delta != 0)\n        {\n          MOVE_POS(p, delta);\n        }\n      }\n      cur = best;\n      break;\n    }\n\n    newLen = ReadMatchDistances(p, &numPairs);\n\n    if (newLen >= p->numFastBytes)\n    {\n      p->numPairs = numPairs;\n      p->longestMatchLen = newLen;\n      break;\n    }\n\n    curOpt = &p->opt[cur];\n\n    position++;\n\n    // we need that check here, if skip_items in p->opt are possible\n    /*\n    if (curOpt->price >= kInfinityPrice)\n      continue;\n    */\n\n    prev = cur - curOpt->len;\n\n    if (curOpt->len == 1)\n    {\n      state = (unsigned)p->opt[prev].state;\n      if (IsShortRep(curOpt))\n        state = kShortRepNextStates[state];\n      else\n        state = kLiteralNextStates[state];\n    }\n    else\n    {\n      const COptimal *prevOpt;\n      UInt32 b0;\n      UInt32 dist = curOpt->dist;\n\n      if (curOpt->extra)\n      {\n        prev -= (unsigned)curOpt->extra;\n        state = kState_RepAfterLit;\n        if (curOpt->extra == 1)\n          state = (dist < LZMA_NUM_REPS ? kState_RepAfterLit : kState_MatchAfterLit);\n      }\n      else\n      {\n        state = (unsigned)p->opt[prev].state;\n        if (dist < LZMA_NUM_REPS)\n          state = kRepNextStates[state];\n        else\n          state = kMatchNextStates[state];\n      }\n\n      prevOpt = &p->opt[prev];\n      b0 = prevOpt->reps[0];\n\n      if (dist < LZMA_NUM_REPS)\n      {\n        if (dist == 0)\n        {\n          reps[0] = b0;\n          reps[1] = prevOpt->reps[1];\n          reps[2] = prevOpt->reps[2];\n          reps[3] = prevOpt->reps[3];\n        }\n        else\n        {\n          reps[1] = b0;\n          b0 = prevOpt->reps[1];\n          if (dist == 1)\n          {\n            reps[0] = b0;\n            reps[2] = prevOpt->reps[2];\n            reps[3] = prevOpt->reps[3];\n          }\n          else\n          {\n            reps[2] = b0;\n            reps[0] = prevOpt->reps[dist];\n            reps[3] = prevOpt->reps[dist ^ 1];\n          }\n        }\n      }\n      else\n      {\n        reps[0] = (dist - LZMA_NUM_REPS + 1);\n        reps[1] = b0;\n        reps[2] = prevOpt->reps[1];\n        reps[3] = prevOpt->reps[2];\n      }\n    }\n\n    curOpt->state = (CState)state;\n    curOpt->reps[0] = reps[0];\n    curOpt->reps[1] = reps[1];\n    curOpt->reps[2] = reps[2];\n    curOpt->reps[3] = reps[3];\n\n    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;\n    curByte = *data;\n    matchByte = *(data - reps[0]);\n\n    posState = (position & p->pbMask);\n\n    /*\n    The order of Price checks:\n       <  LIT\n       <= SHORT_REP\n       <  LIT : REP_0\n       <  REP    [ : LIT : REP_0 ]\n       <  MATCH  [ : LIT : REP_0 ]\n    */\n\n    {\n      UInt32 curPrice = curOpt->price;\n      unsigned prob = p->isMatch[state][posState];\n      matchPrice = curPrice + GET_PRICE_1(prob);\n      litPrice = curPrice + GET_PRICE_0(prob);\n    }\n\n    nextOpt = &p->opt[(size_t)cur + 1];\n    nextIsLit = False;\n\n    // here we can allow skip_items in p->opt, if we don't check (nextOpt->price < kInfinityPrice)\n    // 18.new.06\n    if ((nextOpt->price < kInfinityPrice\n        // && !IsLitState(state)\n        && matchByte == curByte)\n        || litPrice > nextOpt->price\n        )\n      litPrice = 0;\n    else\n    {\n      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));\n      litPrice += (!IsLitState(state) ?\n          LitEnc_Matched_GetPrice(probs, curByte, matchByte, p->ProbPrices) :\n          LitEnc_GetPrice(probs, curByte, p->ProbPrices));\n\n      if (litPrice < nextOpt->price)\n      {\n        nextOpt->price = litPrice;\n        nextOpt->len = 1;\n        MakeAs_Lit(nextOpt);\n        nextIsLit = True;\n      }\n    }\n\n    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);\n\n    numAvailFull = p->numAvail;\n    {\n      unsigned temp = kNumOpts - 1 - cur;\n      if (numAvailFull > temp)\n        numAvailFull = (UInt32)temp;\n    }\n\n    // 18.06\n    // ---------- SHORT_REP ----------\n    if (IsLitState(state)) // 18.new\n    if (matchByte == curByte)\n    if (repMatchPrice < nextOpt->price) // 18.new\n    // if (numAvailFull < 2 || data[1] != *(data - reps[0] + 1))\n    if (\n        // nextOpt->price >= kInfinityPrice ||\n        nextOpt->len < 2   // we can check nextOpt->len, if skip items are not allowed in p->opt\n        || (nextOpt->dist != 0\n            // && nextOpt->extra <= 1 // 17.old\n            )\n        )\n    {\n      UInt32 shortRepPrice = repMatchPrice + GetPrice_ShortRep(p, state, posState);\n      // if (shortRepPrice <= nextOpt->price) // 17.old\n      if (shortRepPrice < nextOpt->price)  // 18.new\n      {\n        nextOpt->price = shortRepPrice;\n        nextOpt->len = 1;\n        MakeAs_ShortRep(nextOpt);\n        nextIsLit = False;\n      }\n    }\n\n    if (numAvailFull < 2)\n      continue;\n    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);\n\n    // numAvail <= p->numFastBytes\n\n    // ---------- LIT : REP_0 ----------\n\n    if (!nextIsLit\n        && litPrice != 0 // 18.new\n        && matchByte != curByte\n        && numAvailFull > 2)\n    {\n      const Byte *data2 = data - reps[0];\n      if (data[1] == data2[1] && data[2] == data2[2])\n      {\n        unsigned len;\n        unsigned limit = p->numFastBytes + 1;\n        if (limit > numAvailFull)\n          limit = numAvailFull;\n        for (len = 3; len < limit && data[len] == data2[len]; len++)\n        {}\n\n        {\n          unsigned state2 = kLiteralNextStates[state];\n          unsigned posState2 = (position + 1) & p->pbMask;\n          UInt32 price = litPrice + GetPrice_Rep_0(p, state2, posState2);\n          {\n            unsigned offset = cur + len;\n\n            if (last < offset)\n              last = offset;\n\n            // do\n            {\n              UInt32 price2;\n              COptimal *opt;\n              len--;\n              // price2 = price + GetPrice_Len_Rep_0(p, len, state2, posState2);\n              price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState2, len);\n\n              opt = &p->opt[offset];\n              // offset--;\n              if (price2 < opt->price)\n              {\n                opt->price = price2;\n                opt->len = (UInt32)len;\n                opt->dist = 0;\n                opt->extra = 1;\n              }\n            }\n            // while (len >= 3);\n          }\n        }\n      }\n    }\n\n    startLen = 2; /* speed optimization */\n\n    {\n      // ---------- REP ----------\n      unsigned repIndex = 0; // 17.old\n      // unsigned repIndex = IsLitState(state) ? 0 : 1; // 18.notused\n      for (; repIndex < LZMA_NUM_REPS; repIndex++)\n      {\n        unsigned len;\n        UInt32 price;\n        const Byte *data2 = data - reps[repIndex];\n        if (data[0] != data2[0] || data[1] != data2[1])\n          continue;\n\n        for (len = 2; len < numAvail && data[len] == data2[len]; len++)\n        {}\n\n        // if (len < startLen) continue; // 18.new: speed optimization\n\n        {\n          unsigned offset = cur + len;\n          if (last < offset)\n            last = offset;\n        }\n        {\n          unsigned len2 = len;\n          price = repMatchPrice + GetPrice_PureRep(p, repIndex, state, posState);\n          do\n          {\n            UInt32 price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState, len2);\n            COptimal *opt = &p->opt[cur + len2];\n            if (price2 < opt->price)\n            {\n              opt->price = price2;\n              opt->len = (UInt32)len2;\n              opt->dist = (UInt32)repIndex;\n              opt->extra = 0;\n            }\n          }\n          while (--len2 >= 2);\n        }\n\n        if (repIndex == 0) startLen = len + 1;  // 17.old\n        // startLen = len + 1; // 18.new\n\n        /* if (_maxMode) */\n        {\n          // ---------- REP : LIT : REP_0 ----------\n          // numFastBytes + 1 + numFastBytes\n\n          unsigned len2 = len + 1;\n          unsigned limit = len2 + p->numFastBytes;\n          if (limit > numAvailFull)\n            limit = numAvailFull;\n\n          len2 += 2;\n          if (len2 <= limit)\n          if (data[len2 - 2] == data2[len2 - 2])\n          if (data[len2 - 1] == data2[len2 - 1])\n          {\n            unsigned state2 = kRepNextStates[state];\n            unsigned posState2 = (position + len) & p->pbMask;\n            price += GET_PRICE_LEN(&p->repLenEnc, posState, len)\n                + GET_PRICE_0(p->isMatch[state2][posState2])\n                + LitEnc_Matched_GetPrice(LIT_PROBS(position + len, data[(size_t)len - 1]),\n                    data[len], data2[len], p->ProbPrices);\n\n            // state2 = kLiteralNextStates[state2];\n            state2 = kState_LitAfterRep;\n            posState2 = (posState2 + 1) & p->pbMask;\n\n\n            price += GetPrice_Rep_0(p, state2, posState2);\n\n          for (; len2 < limit && data[len2] == data2[len2]; len2++)\n          {}\n\n          len2 -= len;\n          // if (len2 >= 3)\n          {\n            {\n              unsigned offset = cur + len + len2;\n\n              if (last < offset)\n                last = offset;\n              // do\n              {\n                UInt32 price2;\n                COptimal *opt;\n                len2--;\n                // price2 = price + GetPrice_Len_Rep_0(p, len2, state2, posState2);\n                price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState2, len2);\n\n                opt = &p->opt[offset];\n                // offset--;\n                if (price2 < opt->price)\n                {\n                  opt->price = price2;\n                  opt->len = (UInt32)len2;\n                  opt->extra = (CExtra)(len + 1);\n                  opt->dist = (UInt32)repIndex;\n                }\n              }\n              // while (len2 >= 3);\n            }\n          }\n          }\n        }\n      }\n    }\n\n\n    // ---------- MATCH ----------\n    /* for (unsigned len = 2; len <= newLen; len++) */\n    if (newLen > numAvail)\n    {\n      newLen = numAvail;\n      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);\n      matches[numPairs] = (UInt32)newLen;\n      numPairs += 2;\n    }\n\n    // startLen = 2; /* speed optimization */\n\n    if (newLen >= startLen)\n    {\n      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);\n      UInt32 dist;\n      unsigned offs, posSlot, len;\n\n      {\n        unsigned offset = cur + newLen;\n        if (last < offset)\n          last = offset;\n      }\n\n      offs = 0;\n      while (startLen > matches[offs])\n        offs += 2;\n      dist = matches[(size_t)offs + 1];\n\n      // if (dist >= kNumFullDistances)\n      GetPosSlot2(dist, posSlot);\n\n      for (len = /*2*/ startLen; ; len++)\n      {\n        UInt32 price = normalMatchPrice + GET_PRICE_LEN(&p->lenEnc, posState, len);\n        {\n          COptimal *opt;\n          unsigned lenNorm = len - 2;\n          lenNorm = GetLenToPosState2(lenNorm);\n          if (dist < kNumFullDistances)\n            price += p->distancesPrices[lenNorm][dist & (kNumFullDistances - 1)];\n          else\n            price += p->posSlotPrices[lenNorm][posSlot] + p->alignPrices[dist & kAlignMask];\n\n          opt = &p->opt[cur + len];\n          if (price < opt->price)\n          {\n            opt->price = price;\n            opt->len = (UInt32)len;\n            opt->dist = dist + LZMA_NUM_REPS;\n            opt->extra = 0;\n          }\n        }\n\n        if (len == matches[offs])\n        {\n          // if (p->_maxMode) {\n          // MATCH : LIT : REP_0\n\n          const Byte *data2 = data - dist - 1;\n          unsigned len2 = len + 1;\n          unsigned limit = len2 + p->numFastBytes;\n          if (limit > numAvailFull)\n            limit = numAvailFull;\n\n          len2 += 2;\n          if (len2 <= limit)\n          if (data[len2 - 2] == data2[len2 - 2])\n          if (data[len2 - 1] == data2[len2 - 1])\n          {\n          for (; len2 < limit && data[len2] == data2[len2]; len2++)\n          {}\n\n          len2 -= len;\n\n          // if (len2 >= 3)\n          {\n            unsigned state2 = kMatchNextStates[state];\n            unsigned posState2 = (position + len) & p->pbMask;\n            unsigned offset;\n            price += GET_PRICE_0(p->isMatch[state2][posState2]);\n            price += LitEnc_Matched_GetPrice(LIT_PROBS(position + len, data[(size_t)len - 1]),\n                    data[len], data2[len], p->ProbPrices);\n\n            // state2 = kLiteralNextStates[state2];\n            state2 = kState_LitAfterMatch;\n\n            posState2 = (posState2 + 1) & p->pbMask;\n            price += GetPrice_Rep_0(p, state2, posState2);\n\n            offset = cur + len + len2;\n\n            if (last < offset)\n              last = offset;\n            // do\n            {\n              UInt32 price2;\n              COptimal *opt;\n              len2--;\n              // price2 = price + GetPrice_Len_Rep_0(p, len2, state2, posState2);\n              price2 = price + GET_PRICE_LEN(&p->repLenEnc, posState2, len2);\n              opt = &p->opt[offset];\n              // offset--;\n              if (price2 < opt->price)\n              {\n                opt->price = price2;\n                opt->len = (UInt32)len2;\n                opt->extra = (CExtra)(len + 1);\n                opt->dist = dist + LZMA_NUM_REPS;\n              }\n            }\n            // while (len2 >= 3);\n          }\n\n          }\n\n          offs += 2;\n          if (offs == numPairs)\n            break;\n          dist = matches[(size_t)offs + 1];\n          // if (dist >= kNumFullDistances)\n            GetPosSlot2(dist, posSlot);\n        }\n      }\n    }\n  }\n\n  do\n    p->opt[last].price = kInfinityPrice;\n  while (--last);\n\n  return Backward(p, cur);\n}\n\n\n\n#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))\n\n\n\nstatic unsigned GetOptimumFast(CLzmaEnc *p)\n{\n  UInt32 numAvail, mainDist;\n  unsigned mainLen, numPairs, repIndex, repLen, i;\n  const Byte *data;\n\n  if (p->additionalOffset == 0)\n    mainLen = ReadMatchDistances(p, &numPairs);\n  else\n  {\n    mainLen = p->longestMatchLen;\n    numPairs = p->numPairs;\n  }\n\n  numAvail = p->numAvail;\n  p->backRes = MARK_LIT;\n  if (numAvail < 2)\n    return 1;\n  // if (mainLen < 2 && p->state == 0) return 1; // 18.06.notused\n  if (numAvail > LZMA_MATCH_LEN_MAX)\n    numAvail = LZMA_MATCH_LEN_MAX;\n  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;\n  repLen = repIndex = 0;\n\n  for (i = 0; i < LZMA_NUM_REPS; i++)\n  {\n    unsigned len;\n    const Byte *data2 = data - p->reps[i];\n    if (data[0] != data2[0] || data[1] != data2[1])\n      continue;\n    for (len = 2; len < numAvail && data[len] == data2[len]; len++)\n    {}\n    if (len >= p->numFastBytes)\n    {\n      p->backRes = (UInt32)i;\n      MOVE_POS(p, len - 1)\n      return len;\n    }\n    if (len > repLen)\n    {\n      repIndex = i;\n      repLen = len;\n    }\n  }\n\n  if (mainLen >= p->numFastBytes)\n  {\n    p->backRes = p->matches[(size_t)numPairs - 1] + LZMA_NUM_REPS;\n    MOVE_POS(p, mainLen - 1)\n    return mainLen;\n  }\n\n  mainDist = 0; /* for GCC */\n\n  if (mainLen >= 2)\n  {\n    mainDist = p->matches[(size_t)numPairs - 1];\n    while (numPairs > 2)\n    {\n      UInt32 dist2;\n      if (mainLen != p->matches[(size_t)numPairs - 4] + 1)\n        break;\n      dist2 = p->matches[(size_t)numPairs - 3];\n      if (!ChangePair(dist2, mainDist))\n        break;\n      numPairs -= 2;\n      mainLen--;\n      mainDist = dist2;\n    }\n    if (mainLen == 2 && mainDist >= 0x80)\n      mainLen = 1;\n  }\n\n  if (repLen >= 2)\n    if (    repLen + 1 >= mainLen\n        || (repLen + 2 >= mainLen && mainDist >= (1 << 9))\n        || (repLen + 3 >= mainLen && mainDist >= (1 << 15)))\n  {\n    p->backRes = (UInt32)repIndex;\n    MOVE_POS(p, repLen - 1)\n    return repLen;\n  }\n\n  if (mainLen < 2 || numAvail <= 2)\n    return 1;\n\n  {\n    unsigned len1 = ReadMatchDistances(p, &p->numPairs);\n    p->longestMatchLen = len1;\n\n    if (len1 >= 2)\n    {\n      UInt32 newDist = p->matches[(size_t)p->numPairs - 1];\n      if (   (len1 >= mainLen && newDist < mainDist)\n          || (len1 == mainLen + 1 && !ChangePair(mainDist, newDist))\n          || (len1 >  mainLen + 1)\n          || (len1 + 1 >= mainLen && mainLen >= 3 && ChangePair(newDist, mainDist)))\n        return 1;\n    }\n  }\n\n  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;\n\n  for (i = 0; i < LZMA_NUM_REPS; i++)\n  {\n    unsigned len, limit;\n    const Byte *data2 = data - p->reps[i];\n    if (data[0] != data2[0] || data[1] != data2[1])\n      continue;\n    limit = mainLen - 1;\n    for (len = 2;; len++)\n    {\n      if (len >= limit)\n        return 1;\n      if (data[len] != data2[len])\n        break;\n    }\n  }\n\n  p->backRes = mainDist + LZMA_NUM_REPS;\n  if (mainLen != 2)\n  {\n    MOVE_POS(p, mainLen - 2)\n  }\n  return mainLen;\n}\n\n\n\n\nstatic void WriteEndMarker(CLzmaEnc *p, unsigned posState)\n{\n  UInt32 range;\n  range = p->rc.range;\n  {\n    UInt32 ttt, newBound;\n    CLzmaProb *prob = &p->isMatch[p->state][posState];\n    RC_BIT_PRE(&p->rc, prob)\n    RC_BIT_1(&p->rc, prob)\n    prob = &p->isRep[p->state];\n    RC_BIT_PRE(&p->rc, prob)\n    RC_BIT_0(&p->rc, prob)\n  }\n  p->state = kMatchNextStates[p->state];\n\n  p->rc.range = range;\n  LenEnc_Encode(&p->lenProbs, &p->rc, 0, posState);\n  range = p->rc.range;\n\n  {\n    // RcTree_Encode_PosSlot(&p->rc, p->posSlotEncoder[0], (1 << kNumPosSlotBits) - 1);\n    CLzmaProb *probs = p->posSlotEncoder[0];\n    unsigned m = 1;\n    do\n    {\n      UInt32 ttt, newBound;\n      RC_BIT_PRE(p, probs + m)\n      RC_BIT_1(&p->rc, probs + m);\n      m = (m << 1) + 1;\n    }\n    while (m < (1 << kNumPosSlotBits));\n  }\n  {\n    // RangeEnc_EncodeDirectBits(&p->rc, ((UInt32)1 << (30 - kNumAlignBits)) - 1, 30 - kNumAlignBits);    UInt32 range = p->range;\n    unsigned numBits = 30 - kNumAlignBits;\n    do\n    {\n      range >>= 1;\n      p->rc.low += range;\n      RC_NORM(&p->rc)\n    }\n    while (--numBits);\n  }\n\n  {\n    // RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);\n    CLzmaProb *probs = p->posAlignEncoder;\n    unsigned m = 1;\n    do\n    {\n      UInt32 ttt, newBound;\n      RC_BIT_PRE(p, probs + m)\n      RC_BIT_1(&p->rc, probs + m);\n      m = (m << 1) + 1;\n    }\n    while (m < kAlignTableSize);\n  }\n  p->rc.range = range;\n}\n\n\nstatic SRes CheckErrors(CLzmaEnc *p)\n{\n  if (p->result != SZ_OK)\n    return p->result;\n  if (p->rc.res != SZ_OK)\n    p->result = SZ_ERROR_WRITE;\n  if (p->matchFinderBase.result != SZ_OK)\n    p->result = SZ_ERROR_READ;\n  if (p->result != SZ_OK)\n    p->finished = True;\n  return p->result;\n}\n\n\nMY_NO_INLINE static SRes Flush(CLzmaEnc *p, UInt32 nowPos)\n{\n  /* ReleaseMFStream(); */\n  p->finished = True;\n  if (p->writeEndMark)\n    WriteEndMarker(p, nowPos & p->pbMask);\n  RangeEnc_FlushData(&p->rc);\n  RangeEnc_FlushStream(&p->rc);\n  return CheckErrors(p);\n}\n\n\nMY_NO_INLINE static void FillAlignPrices(CLzmaEnc *p)\n{\n  unsigned i;\n  const CProbPrice *ProbPrices = p->ProbPrices;\n  const CLzmaProb *probs = p->posAlignEncoder;\n  // p->alignPriceCount = 0;\n  for (i = 0; i < kAlignTableSize / 2; i++)\n  {\n    UInt32 price = 0;\n    unsigned sym = i;\n    unsigned m = 1;\n    unsigned bit;\n    UInt32 prob;\n    bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[m], bit); m = (m << 1) + bit;\n    bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[m], bit); m = (m << 1) + bit;\n    bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[m], bit); m = (m << 1) + bit;\n    prob = probs[m];\n    p->alignPrices[i    ] = price + GET_PRICEa_0(prob);\n    p->alignPrices[i + 8] = price + GET_PRICEa_1(prob);\n    // p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);\n  }\n}\n\n\nMY_NO_INLINE static void FillDistancesPrices(CLzmaEnc *p)\n{\n  // int y; for (y = 0; y < 100; y++) {\n\n  UInt32 tempPrices[kNumFullDistances];\n  unsigned i, lps;\n\n  const CProbPrice *ProbPrices = p->ProbPrices;\n  p->matchPriceCount = 0;\n\n  for (i = kStartPosModelIndex / 2; i < kNumFullDistances / 2; i++)\n  {\n    unsigned posSlot = GetPosSlot1(i);\n    unsigned footerBits = (posSlot >> 1) - 1;\n    unsigned base = ((2 | (posSlot & 1)) << footerBits);\n    const CLzmaProb *probs = p->posEncoders + (size_t)base * 2;\n    // tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base, footerBits, i - base, p->ProbPrices);\n    UInt32 price = 0;\n    unsigned m = 1;\n    unsigned sym = i;\n    unsigned offset = (unsigned)1 << footerBits;\n    base += i;\n\n    if (footerBits)\n    do\n    {\n      unsigned bit = sym & 1;\n      sym >>= 1;\n      price += GET_PRICEa(probs[m], bit);\n      m = (m << 1) + bit;\n    }\n    while (--footerBits);\n\n    {\n      unsigned prob = probs[m];\n      tempPrices[base         ] = price + GET_PRICEa_0(prob);\n      tempPrices[base + offset] = price + GET_PRICEa_1(prob);\n    }\n  }\n\n  for (lps = 0; lps < kNumLenToPosStates; lps++)\n  {\n    unsigned slot;\n    unsigned distTableSize2 = (p->distTableSize + 1) >> 1;\n    UInt32 *posSlotPrices = p->posSlotPrices[lps];\n    const CLzmaProb *probs = p->posSlotEncoder[lps];\n\n    for (slot = 0; slot < distTableSize2; slot++)\n    {\n      // posSlotPrices[slot] = RcTree_GetPrice(encoder, kNumPosSlotBits, slot, p->ProbPrices);\n      UInt32 price;\n      unsigned bit;\n      unsigned sym = slot + (1 << (kNumPosSlotBits - 1));\n      unsigned prob;\n      bit = sym & 1; sym >>= 1; price  = GET_PRICEa(probs[sym], bit);\n      bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[sym], bit);\n      bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[sym], bit);\n      bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[sym], bit);\n      bit = sym & 1; sym >>= 1; price += GET_PRICEa(probs[sym], bit);\n      prob = probs[(size_t)slot + (1 << (kNumPosSlotBits - 1))];\n      posSlotPrices[(size_t)slot * 2    ] = price + GET_PRICEa_0(prob);\n      posSlotPrices[(size_t)slot * 2 + 1] = price + GET_PRICEa_1(prob);\n    }\n\n    {\n      UInt32 delta = ((UInt32)((kEndPosModelIndex / 2 - 1) - kNumAlignBits) << kNumBitPriceShiftBits);\n      for (slot = kEndPosModelIndex / 2; slot < distTableSize2; slot++)\n      {\n        posSlotPrices[(size_t)slot * 2    ] += delta;\n        posSlotPrices[(size_t)slot * 2 + 1] += delta;\n        delta += ((UInt32)1 << kNumBitPriceShiftBits);\n      }\n    }\n\n    {\n      UInt32 *dp = p->distancesPrices[lps];\n\n      dp[0] = posSlotPrices[0];\n      dp[1] = posSlotPrices[1];\n      dp[2] = posSlotPrices[2];\n      dp[3] = posSlotPrices[3];\n\n      for (i = 4; i < kNumFullDistances; i += 2)\n      {\n        UInt32 slotPrice = posSlotPrices[GetPosSlot1(i)];\n        dp[i    ] = slotPrice + tempPrices[i];\n        dp[i + 1] = slotPrice + tempPrices[i + 1];\n      }\n    }\n  }\n  // }\n}\n\n\n\nvoid LzmaEnc_Construct(CLzmaEnc *p)\n{\n  RangeEnc_Construct(&p->rc);\n  MatchFinder_Construct(&p->matchFinderBase);\n\n  {\n    CLzmaEncProps props;\n    LzmaEncProps_Init(&props);\n    LzmaEnc_SetProps(p, &props);\n  }\n\n  #ifndef LZMA_LOG_BSR\n  LzmaEnc_FastPosInit(p->g_FastPos);\n  #endif\n\n  LzmaEnc_InitPriceTables(p->ProbPrices);\n  p->litProbs = NULL;\n  p->saveState.litProbs = NULL;\n\n}\n\nCLzmaEncHandle LzmaEnc_Create(ISzAllocPtr alloc)\n{\n  void *p;\n  p = ISzAlloc_Alloc(alloc, sizeof(CLzmaEnc));\n  if (p)\n    LzmaEnc_Construct((CLzmaEnc *)p);\n  return p;\n}\n\nvoid LzmaEnc_FreeLits(CLzmaEnc *p, ISzAllocPtr alloc)\n{\n  ISzAlloc_Free(alloc, p->litProbs);\n  ISzAlloc_Free(alloc, p->saveState.litProbs);\n  p->litProbs = NULL;\n  p->saveState.litProbs = NULL;\n}\n\nvoid LzmaEnc_Destruct(CLzmaEnc *p, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  MatchFinder_Free(&p->matchFinderBase, allocBig);\n  LzmaEnc_FreeLits(p, alloc);\n  RangeEnc_Free(&p->rc, alloc);\n}\n\nvoid LzmaEnc_Destroy(CLzmaEncHandle p, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);\n  ISzAlloc_Free(alloc, p);\n}\n\n\nstatic SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, UInt32 maxPackSize, UInt32 maxUnpackSize)\n{\n  UInt32 nowPos32, startPos32;\n  if (p->needInit)\n  {\n    p->matchFinder.Init(p->matchFinderObj);\n    p->needInit = 0;\n  }\n\n  if (p->finished)\n    return p->result;\n  RINOK(CheckErrors(p));\n\n  nowPos32 = (UInt32)p->nowPos64;\n  startPos32 = nowPos32;\n\n  if (p->nowPos64 == 0)\n  {\n    unsigned numPairs;\n    Byte curByte;\n    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)\n      return Flush(p, nowPos32);\n    ReadMatchDistances(p, &numPairs);\n    RangeEnc_EncodeBit_0(&p->rc, &p->isMatch[kState_Start][0]);\n    // p->state = kLiteralNextStates[p->state];\n    curByte = *(p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset);\n    LitEnc_Encode(&p->rc, p->litProbs, curByte);\n    p->additionalOffset--;\n    nowPos32++;\n  }\n\n  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)\n\n  for (;;)\n  {\n    UInt32 dist;\n    unsigned len, posState;\n    UInt32 range, ttt, newBound;\n    CLzmaProb *probs;\n\n    if (p->fastMode)\n      len = GetOptimumFast(p);\n    else\n    {\n      unsigned oci = p->optCur;\n      if (p->optEnd == oci)\n        len = GetOptimum(p, nowPos32);\n      else\n      {\n        const COptimal *opt = &p->opt[oci];\n        len = opt->len;\n        p->backRes = opt->dist;\n        p->optCur = oci + 1;\n      }\n    }\n\n    posState = (unsigned)nowPos32 & p->pbMask;\n    range = p->rc.range;\n    probs = &p->isMatch[p->state][posState];\n\n    RC_BIT_PRE(&p->rc, probs)\n\n    dist = p->backRes;\n\n    #ifdef SHOW_STAT2\n    printf(\"\\n pos = %6X, len = %3u  pos = %6u\", nowPos32, len, dist);\n    #endif\n\n    if (dist == MARK_LIT)\n    {\n      Byte curByte;\n      const Byte *data;\n      unsigned state;\n\n      RC_BIT_0(&p->rc, probs);\n      p->rc.range = range;\n      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;\n      probs = LIT_PROBS(nowPos32, *(data - 1));\n      curByte = *data;\n      state = p->state;\n      p->state = kLiteralNextStates[state];\n      if (IsLitState(state))\n        LitEnc_Encode(&p->rc, probs, curByte);\n      else\n        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0]));\n    }\n    else\n    {\n      RC_BIT_1(&p->rc, probs);\n      probs = &p->isRep[p->state];\n      RC_BIT_PRE(&p->rc, probs)\n\n      if (dist < LZMA_NUM_REPS)\n      {\n        RC_BIT_1(&p->rc, probs);\n        probs = &p->isRepG0[p->state];\n        RC_BIT_PRE(&p->rc, probs)\n        if (dist == 0)\n        {\n          RC_BIT_0(&p->rc, probs);\n          probs = &p->isRep0Long[p->state][posState];\n          RC_BIT_PRE(&p->rc, probs)\n          if (len != 1)\n          {\n            RC_BIT_1_BASE(&p->rc, probs);\n          }\n          else\n          {\n            RC_BIT_0_BASE(&p->rc, probs);\n            p->state = kShortRepNextStates[p->state];\n          }\n        }\n        else\n        {\n          RC_BIT_1(&p->rc, probs);\n          probs = &p->isRepG1[p->state];\n          RC_BIT_PRE(&p->rc, probs)\n          if (dist == 1)\n          {\n            RC_BIT_0_BASE(&p->rc, probs);\n            dist = p->reps[1];\n          }\n          else\n          {\n            RC_BIT_1(&p->rc, probs);\n            probs = &p->isRepG2[p->state];\n            RC_BIT_PRE(&p->rc, probs)\n            if (dist == 2)\n            {\n              RC_BIT_0_BASE(&p->rc, probs);\n              dist = p->reps[2];\n            }\n            else\n            {\n              RC_BIT_1_BASE(&p->rc, probs);\n              dist = p->reps[3];\n              p->reps[3] = p->reps[2];\n            }\n            p->reps[2] = p->reps[1];\n          }\n          p->reps[1] = p->reps[0];\n          p->reps[0] = dist;\n        }\n\n        RC_NORM(&p->rc)\n\n        p->rc.range = range;\n\n        if (len != 1)\n        {\n          LenEnc_Encode(&p->repLenProbs, &p->rc, len - LZMA_MATCH_LEN_MIN, posState);\n          --p->repLenEncCounter;\n          p->state = kRepNextStates[p->state];\n        }\n      }\n      else\n      {\n        unsigned posSlot;\n        RC_BIT_0(&p->rc, probs);\n        p->rc.range = range;\n        p->state = kMatchNextStates[p->state];\n\n        LenEnc_Encode(&p->lenProbs, &p->rc, len - LZMA_MATCH_LEN_MIN, posState);\n        // --p->lenEnc.counter;\n\n        dist -= LZMA_NUM_REPS;\n        p->reps[3] = p->reps[2];\n        p->reps[2] = p->reps[1];\n        p->reps[1] = p->reps[0];\n        p->reps[0] = dist + 1;\n\n        p->matchPriceCount++;\n        GetPosSlot(dist, posSlot);\n        // RcTree_Encode_PosSlot(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], posSlot);\n        {\n          UInt32 sym = (UInt32)posSlot + (1 << kNumPosSlotBits);\n          range = p->rc.range;\n          probs = p->posSlotEncoder[GetLenToPosState(len)];\n          do\n          {\n            CLzmaProb *prob = probs + (sym >> kNumPosSlotBits);\n            UInt32 bit = (sym >> (kNumPosSlotBits - 1)) & 1;\n            sym <<= 1;\n            RC_BIT(&p->rc, prob, bit);\n          }\n          while (sym < (1 << kNumPosSlotBits * 2));\n          p->rc.range = range;\n        }\n\n        if (dist >= kStartPosModelIndex)\n        {\n          unsigned footerBits = ((posSlot >> 1) - 1);\n\n          if (dist < kNumFullDistances)\n          {\n            unsigned base = ((2 | (posSlot & 1)) << footerBits);\n            RcTree_ReverseEncode(&p->rc, p->posEncoders + base, footerBits, (unsigned)(dist /* - base */));\n          }\n          else\n          {\n            UInt32 pos2 = (dist | 0xF) << (32 - footerBits);\n            range = p->rc.range;\n            // RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);\n            /*\n            do\n            {\n              range >>= 1;\n              p->rc.low += range & (0 - ((dist >> --footerBits) & 1));\n              RC_NORM(&p->rc)\n            }\n            while (footerBits > kNumAlignBits);\n            */\n            do\n            {\n              range >>= 1;\n              p->rc.low += range & (0 - (pos2 >> 31));\n              pos2 += pos2;\n              RC_NORM(&p->rc)\n            }\n            while (pos2 != 0xF0000000);\n\n\n            // RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);\n\n            {\n              unsigned m = 1;\n              unsigned bit;\n              bit = dist & 1; dist >>= 1; RC_BIT(&p->rc, p->posAlignEncoder + m, bit); m = (m << 1) + bit;\n              bit = dist & 1; dist >>= 1; RC_BIT(&p->rc, p->posAlignEncoder + m, bit); m = (m << 1) + bit;\n              bit = dist & 1; dist >>= 1; RC_BIT(&p->rc, p->posAlignEncoder + m, bit); m = (m << 1) + bit;\n              bit = dist & 1;             RC_BIT(&p->rc, p->posAlignEncoder + m, bit);\n              p->rc.range = range;\n              // p->alignPriceCount++;\n            }\n          }\n        }\n      }\n    }\n\n    nowPos32 += (UInt32)len;\n    p->additionalOffset -= len;\n\n    if (p->additionalOffset == 0)\n    {\n      UInt32 processed;\n\n      if (!p->fastMode)\n      {\n        /*\n        if (p->alignPriceCount >= 16) // kAlignTableSize\n          FillAlignPrices(p);\n        if (p->matchPriceCount >= 128)\n          FillDistancesPrices(p);\n        if (p->lenEnc.counter <= 0)\n          LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, &p->lenProbs, p->ProbPrices);\n        */\n        if (p->matchPriceCount >= 64)\n        {\n          FillAlignPrices(p);\n          // { int y; for (y = 0; y < 100; y++) {\n          FillDistancesPrices(p);\n          // }}\n          LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, &p->lenProbs, p->ProbPrices);\n        }\n        if (p->repLenEncCounter <= 0)\n        {\n          p->repLenEncCounter = REP_LEN_COUNT;\n          LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, &p->repLenProbs, p->ProbPrices);\n        }\n      }\n\n      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)\n        break;\n      processed = nowPos32 - startPos32;\n\n      if (maxPackSize)\n      {\n        if (processed + kNumOpts + 300 >= maxUnpackSize\n            || RangeEnc_GetProcessed_size_t(&p->rc) + kPackReserve >= maxPackSize)\n          break;\n      }\n      else if (processed >= (1 << 17))\n      {\n        p->nowPos64 += nowPos32 - startPos32;\n        return CheckErrors(p);\n      }\n    }\n  }\n\n  p->nowPos64 += nowPos32 - startPos32;\n  return Flush(p, nowPos32);\n}\n\n\n\n#define kBigHashDicLimit ((UInt32)1 << 24)\n\nstatic SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  UInt32 beforeSize = kNumOpts;\n  if (!RangeEnc_Alloc(&p->rc, alloc))\n    return SZ_ERROR_MEM;\n\n  {\n    unsigned lclp = p->lc + p->lp;\n    if (!p->litProbs || !p->saveState.litProbs || p->lclp != lclp)\n    {\n      LzmaEnc_FreeLits(p, alloc);\n      p->litProbs = (CLzmaProb *)ISzAlloc_Alloc(alloc, ((UInt32)0x300 << lclp) * sizeof(CLzmaProb));\n      p->saveState.litProbs = (CLzmaProb *)ISzAlloc_Alloc(alloc, ((UInt32)0x300 << lclp) * sizeof(CLzmaProb));\n      if (!p->litProbs || !p->saveState.litProbs)\n      {\n        LzmaEnc_FreeLits(p, alloc);\n        return SZ_ERROR_MEM;\n      }\n      p->lclp = lclp;\n    }\n  }\n\n  p->matchFinderBase.bigHash = (Byte)(p->dictSize > kBigHashDicLimit ? 1 : 0);\n\n  if (beforeSize + p->dictSize < keepWindowSize)\n    beforeSize = keepWindowSize - p->dictSize;\n\n  if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))\n    return SZ_ERROR_MEM;\n  p->matchFinderObj = &p->matchFinderBase;\n  MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);\n\n  return SZ_OK;\n}\n\nvoid LzmaEnc_Init(CLzmaEnc *p)\n{\n  unsigned i;\n  p->state = 0;\n  p->reps[0] =\n  p->reps[1] =\n  p->reps[2] =\n  p->reps[3] = 1;\n\n  RangeEnc_Init(&p->rc);\n\n  for (i = 0; i < (1 << kNumAlignBits); i++)\n    p->posAlignEncoder[i] = kProbInitValue;\n\n  for (i = 0; i < kNumStates; i++)\n  {\n    unsigned j;\n    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)\n    {\n      p->isMatch[i][j] = kProbInitValue;\n      p->isRep0Long[i][j] = kProbInitValue;\n    }\n    p->isRep[i] = kProbInitValue;\n    p->isRepG0[i] = kProbInitValue;\n    p->isRepG1[i] = kProbInitValue;\n    p->isRepG2[i] = kProbInitValue;\n  }\n\n  {\n    for (i = 0; i < kNumLenToPosStates; i++)\n    {\n      CLzmaProb *probs = p->posSlotEncoder[i];\n      unsigned j;\n      for (j = 0; j < (1 << kNumPosSlotBits); j++)\n        probs[j] = kProbInitValue;\n    }\n  }\n  {\n    for (i = 0; i < kNumFullDistances; i++)\n      p->posEncoders[i] = kProbInitValue;\n  }\n\n  {\n    UInt32 num = (UInt32)0x300 << (p->lp + p->lc);\n    UInt32 k;\n    CLzmaProb *probs = p->litProbs;\n    for (k = 0; k < num; k++)\n      probs[k] = kProbInitValue;\n  }\n\n\n  LenEnc_Init(&p->lenProbs);\n  LenEnc_Init(&p->repLenProbs);\n\n  p->optEnd = 0;\n  p->optCur = 0;\n\n  {\n    for (i = 0; i < kNumOpts; i++)\n      p->opt[i].price = kInfinityPrice;\n  }\n\n  p->additionalOffset = 0;\n\n  p->pbMask = (1 << p->pb) - 1;\n  p->lpMask = ((UInt32)0x100 << p->lp) - ((unsigned)0x100 >> p->lc);\n}\n\n\nvoid LzmaEnc_InitPrices(CLzmaEnc *p)\n{\n  if (!p->fastMode)\n  {\n    FillDistancesPrices(p);\n    FillAlignPrices(p);\n  }\n\n  p->lenEnc.tableSize =\n  p->repLenEnc.tableSize =\n      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;\n\n  p->repLenEncCounter = REP_LEN_COUNT;\n\n  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, &p->lenProbs, p->ProbPrices);\n  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, &p->repLenProbs, p->ProbPrices);\n}\n\nstatic SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  unsigned i;\n  for (i = kEndPosModelIndex / 2; i < kDicLogSizeMax; i++)\n    if (p->dictSize <= ((UInt32)1 << i))\n      break;\n  p->distTableSize = i * 2;\n\n  p->finished = False;\n  p->result = SZ_OK;\n  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));\n  LzmaEnc_Init(p);\n  LzmaEnc_InitPrices(p);\n  p->nowPos64 = 0;\n  return SZ_OK;\n}\n\nstatic SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,\n    ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  p->matchFinderBase.stream = inStream;\n  p->needInit = 1;\n  p->rc.outStream = outStream;\n  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);\n}\n\nSRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,\n    ISeqInStream *inStream, UInt32 keepWindowSize,\n    ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  p->matchFinderBase.stream = inStream;\n  p->needInit = 1;\n  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);\n}\n\nstatic void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, size_t srcLen)\n{\n  p->matchFinderBase.directInput = 1;\n  p->matchFinderBase.bufferBase = (Byte *)src;\n  p->matchFinderBase.directInputRem = srcLen;\n}\n\nSRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, size_t srcLen,\n    UInt32 keepWindowSize, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  LzmaEnc_SetInputBuf(p, src, srcLen);\n  p->needInit = 1;\n\n  LzmaEnc_SetDataSize(pp, srcLen);\n  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);\n}\n\nvoid LzmaEnc_Finish(CLzmaEncHandle pp)\n{\n  UNUSED_VAR(pp);\n}\n\n\ntypedef struct\n{\n  ISeqOutStream vt;\n  Byte *data;\n  size_t rem;\n  BoolInt overflow;\n} CLzmaEnc_SeqOutStreamBuf;\n\nstatic size_t SeqOutStreamBuf_Write(const ISeqOutStream *pp, const void *data, size_t size)\n{\n  CLzmaEnc_SeqOutStreamBuf *p = CONTAINER_FROM_VTBL(pp, CLzmaEnc_SeqOutStreamBuf, vt);\n  if (p->rem < size)\n  {\n    size = p->rem;\n    p->overflow = True;\n  }\n  memcpy(p->data, data, size);\n  p->rem -= size;\n  p->data += size;\n  return size;\n}\n\n\nUInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)\n{\n  const CLzmaEnc *p = (CLzmaEnc *)pp;\n  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);\n}\n\n\nconst Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)\n{\n  const CLzmaEnc *p = (CLzmaEnc *)pp;\n  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;\n}\n\n\nSRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, BoolInt reInit,\n    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  UInt64 nowPos64;\n  SRes res;\n  CLzmaEnc_SeqOutStreamBuf outStream;\n\n  outStream.vt.Write = SeqOutStreamBuf_Write;\n  outStream.data = dest;\n  outStream.rem = *destLen;\n  outStream.overflow = False;\n\n  p->writeEndMark = False;\n  p->finished = False;\n  p->result = SZ_OK;\n\n  if (reInit)\n    LzmaEnc_Init(p);\n  LzmaEnc_InitPrices(p);\n\n  nowPos64 = p->nowPos64;\n  RangeEnc_Init(&p->rc);\n  p->rc.outStream = &outStream.vt;\n\n  if (desiredPackSize == 0)\n    return SZ_ERROR_OUTPUT_EOF;\n\n  res = LzmaEnc_CodeOneBlock(p, desiredPackSize, *unpackSize);\n\n  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);\n  *destLen -= outStream.rem;\n  if (outStream.overflow)\n    return SZ_ERROR_OUTPUT_EOF;\n\n  return res;\n}\n\n\nstatic SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)\n{\n  SRes res = SZ_OK;\n\n  for (;;)\n  {\n    res = LzmaEnc_CodeOneBlock(p, 0, 0);\n    if (res != SZ_OK || p->finished)\n      break;\n    if (progress)\n    {\n      res = ICompressProgress_Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));\n      if (res != SZ_OK)\n      {\n        res = SZ_ERROR_PROGRESS;\n        break;\n      }\n    }\n  }\n\n  LzmaEnc_Finish(p);\n\n  /*\n  if (res == SZ_OK && !Inline_MatchFinder_IsFinishedOK(&p->matchFinderBase))\n    res = SZ_ERROR_FAIL;\n  }\n  */\n\n  return res;\n}\n\n\nSRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,\n    ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));\n  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);\n}\n\n\nSRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, size_t *size)\n{\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n  unsigned i;\n  UInt32 dictSize = p->dictSize;\n  if (*size < LZMA_PROPS_SIZE)\n    return SZ_ERROR_PARAM;\n  *size = LZMA_PROPS_SIZE;\n  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);\n\n  if (dictSize >= ((UInt32)1 << 22))\n  {\n    UInt32 kDictMask = ((UInt32)1 << 20) - 1;\n    if (dictSize < (UInt32)0xFFFFFFFF - kDictMask)\n      dictSize = (dictSize + kDictMask) & ~kDictMask;\n  }\n  else for (i = 11; i <= 30; i++)\n  {\n    if (dictSize <= ((UInt32)2 << i)) { dictSize = (2 << i); break; }\n    if (dictSize <= ((UInt32)3 << i)) { dictSize = (3 << i); break; }\n  }\n\n  for (i = 0; i < 4; i++)\n    props[1 + i] = (Byte)(dictSize >> (8 * i));\n  return SZ_OK;\n}\n\n\nunsigned LzmaEnc_IsWriteEndMark(CLzmaEncHandle pp)\n{\n  return ((CLzmaEnc *)pp)->writeEndMark;\n}\n\n\nSRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,\n    int writeEndMark, ICompressProgress *progress, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  SRes res;\n  CLzmaEnc *p = (CLzmaEnc *)pp;\n\n  CLzmaEnc_SeqOutStreamBuf outStream;\n\n  outStream.vt.Write = SeqOutStreamBuf_Write;\n  outStream.data = dest;\n  outStream.rem = *destLen;\n  outStream.overflow = False;\n\n  p->writeEndMark = writeEndMark;\n  p->rc.outStream = &outStream.vt;\n\n  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);\n\n  if (res == SZ_OK)\n  {\n    res = LzmaEnc_Encode2(p, progress);\n    if (res == SZ_OK && p->nowPos64 != srcLen)\n      res = SZ_ERROR_FAIL;\n  }\n\n  *destLen -= outStream.rem;\n  if (outStream.overflow)\n    return SZ_ERROR_OUTPUT_EOF;\n  return res;\n}\n\n\nSRes LzmaEncode(Byte *dest, size_t *destLen, const Byte *src, size_t srcLen,\n    const CLzmaEncProps *props, Byte *propsEncoded, size_t *propsSize, int writeEndMark,\n    ICompressProgress *progress, ISzAllocPtr alloc, ISzAllocPtr allocBig)\n{\n  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);\n  SRes res;\n  if (!p)\n    return SZ_ERROR_MEM;\n\n  res = LzmaEnc_SetProps(p, props);\n  if (res == SZ_OK)\n  {\n    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);\n    if (res == SZ_OK)\n      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,\n          writeEndMark, progress, alloc, allocBig);\n  }\n\n  LzmaEnc_Destroy(p, alloc, allocBig);\n  return res;\n}\n\n\n\n\n\n/* LzmaDec.c -- LZMA Decoder\n2018-07-04 : Igor Pavlov : Public domain */\n\n#include <string.h>\n\n/* #include \"CpuArch.h\" */\n//#include \"LzmaDec.h\"\n\n#define kNumTopBits 24\n#define kTopValue ((UInt32)1 << kNumTopBits)\n\n#define kNumBitModelTotalBits 11\n#define kBitModelTotal (1 << kNumBitModelTotalBits)\n#define kNumMoveBits 5\n\n#define RC_INIT_SIZE 5\n\n#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }\n\n#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * (UInt32)ttt; if (code < bound)\n#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));\n#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));\n#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \\\n  { UPDATE_0(p); i = (i + i); A0; } else \\\n  { UPDATE_1(p); i = (i + i) + 1; A1; }\n\n#define TREE_GET_BIT(probs, i) { GET_BIT2(probs + i, i, ;, ;); }\n\n#define REV_BIT(p, i, A0, A1) IF_BIT_0(p + i) \\\n  { UPDATE_0(p + i); A0; } else \\\n  { UPDATE_1(p + i); A1; }\n#define REV_BIT_VAR(  p, i, m) REV_BIT(p, i, i += m; m += m, m += m; i += m; )\n#define REV_BIT_CONST(p, i, m) REV_BIT(p, i, i += m;       , i += m * 2; )\n#define REV_BIT_LAST( p, i, m) REV_BIT(p, i, i -= m        , ; )\n\n#define TREE_DECODE(probs, limit, i) \\\n  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }\n\n/* #define _LZMA_SIZE_OPT */\n\n#ifdef _LZMA_SIZE_OPT\n#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)\n#else\n#define TREE_6_DECODE(probs, i) \\\n  { i = 1; \\\n  TREE_GET_BIT(probs, i); \\\n  TREE_GET_BIT(probs, i); \\\n  TREE_GET_BIT(probs, i); \\\n  TREE_GET_BIT(probs, i); \\\n  TREE_GET_BIT(probs, i); \\\n  TREE_GET_BIT(probs, i); \\\n  i -= 0x40; }\n#endif\n\n#define NORMAL_LITER_DEC TREE_GET_BIT(prob, symbol)\n#define MATCHED_LITER_DEC \\\n  matchByte += matchByte; \\\n  bit = offs; \\\n  offs &= matchByte; \\\n  probLit = prob + (offs + bit + symbol); \\\n  GET_BIT2(probLit, symbol, offs ^= bit; , ;)\n\n\n\n#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }\n\n#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * (UInt32)ttt; if (code < bound)\n#define UPDATE_0_CHECK range = bound;\n#define UPDATE_1_CHECK range -= bound; code -= bound;\n#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \\\n  { UPDATE_0_CHECK; i = (i + i); A0; } else \\\n  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }\n#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)\n#define TREE_DECODE_CHECK(probs, limit, i) \\\n  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }\n\n\n#define REV_BIT_CHECK(p, i, m) IF_BIT_0_CHECK(p + i) \\\n  { UPDATE_0_CHECK; i += m; m += m; } else \\\n  { UPDATE_1_CHECK; m += m; i += m; }\n\n\n#define kNumPosBitsMax 4\n#define kNumPosStatesMax (1 << kNumPosBitsMax)\n\n#define kLenNumLowBits 3\n#define kLenNumLowSymbols (1 << kLenNumLowBits)\n#define kLenNumHighBits 8\n#define kLenNumHighSymbols (1 << kLenNumHighBits)\n\n#define LenLow 0\n#define LenHigh (LenLow + 2 * (kNumPosStatesMax << kLenNumLowBits))\n#define kNumLenProbs (LenHigh + kLenNumHighSymbols)\n\n#define LenChoice LenLow\n#define LenChoice2 (LenLow + (1 << kLenNumLowBits))\n\n#define kNumStates 12\n#define kNumStates2 16\n#define kNumLitStates 7\n\n#define kStartPosModelIndex 4\n#define kEndPosModelIndex 14\n#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))\n\n#define kNumPosSlotBits 6\n#define kNumLenToPosStates 4\n\n#define kNumAlignBits 4\n#define kAlignTableSize (1 << kNumAlignBits)\n\n#define kMatchMinLen 2\n#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols * 2 + kLenNumHighSymbols)\n\n/* External ASM code needs same CLzmaProb array layout. So don't change it. */\n\n/* (probs_1664) is faster and better for code size at some platforms */\n/*\n#ifdef MY_CPU_X86_OR_AMD64\n*/\n#define kStartOffset 1664\n#define GET_PROBS p->probs_1664\n/*\n#define GET_PROBS p->probs + kStartOffset\n#else\n#define kStartOffset 0\n#define GET_PROBS p->probs\n#endif\n*/\n\n#define SpecPos (-kStartOffset)\n#define IsRep0Long (SpecPos + kNumFullDistances)\n#define RepLenCoder (IsRep0Long + (kNumStates2 << kNumPosBitsMax))\n#define LenCoder (RepLenCoder + kNumLenProbs)\n#define IsMatch (LenCoder + kNumLenProbs)\n#define Align (IsMatch + (kNumStates2 << kNumPosBitsMax))\n#define IsRep (Align + kAlignTableSize)\n#define IsRepG0 (IsRep + kNumStates)\n#define IsRepG1 (IsRepG0 + kNumStates)\n#define IsRepG2 (IsRepG1 + kNumStates)\n#define PosSlot (IsRepG2 + kNumStates)\n#define Literal (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))\n#define NUM_BASE_PROBS (Literal + kStartOffset)\n\n#if Align != 0 && kStartOffset != 0\n  #error Stop_Compiling_Bad_LZMA_kAlign\n#endif\n\n#if NUM_BASE_PROBS != 1984\n  #error Stop_Compiling_Bad_LZMA_PROBS\n#endif\n\n\n#define LZMA_LIT_SIZE 0x300\n\n#define LzmaProps_GetNumProbs(p) (NUM_BASE_PROBS + ((UInt32)LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))\n\n\n#define CALC_POS_STATE(processedPos, pbMask) (((processedPos) & (pbMask)) << 4)\n#define COMBINED_PS_STATE (posState + state)\n#define GET_LEN_STATE (posState)\n\n#define LZMA_DIC_MIN (1 << 12)\n\n/*\np->remainLen : shows status of LZMA decoder:\n    < kMatchSpecLenStart : normal remain\n    = kMatchSpecLenStart : finished\n    = kMatchSpecLenStart + 1 : need init range coder\n    = kMatchSpecLenStart + 2 : need init range coder and state\n*/\n\n/* ---------- LZMA_DECODE_REAL ---------- */\n/*\nLzmaDec_DecodeReal_3() can be implemented in external ASM file.\n3 - is the code compatibility version of that function for check at link time.\n*/\n\n#define LZMA_DECODE_REAL LzmaDec_DecodeReal_3\n\n/*\nLZMA_DECODE_REAL()\nIn:\n  RangeCoder is normalized\n  if (p->dicPos == limit)\n  {\n    LzmaDec_TryDummy() was called before to exclude LITERAL and MATCH-REP cases.\n    So first symbol can be only MATCH-NON-REP. And if that MATCH-NON-REP symbol\n    is not END_OF_PAYALOAD_MARKER, then function returns error code.\n  }\n\nProcessing:\n  first LZMA symbol will be decoded in any case\n  All checks for limits are at the end of main loop,\n  It will decode new LZMA-symbols while (p->buf < bufLimit && dicPos < limit),\n  RangeCoder is still without last normalization when (p->buf < bufLimit) is being checked.\n\nOut:\n  RangeCoder is normalized\n  Result:\n    SZ_OK - OK\n    SZ_ERROR_DATA - Error\n  p->remainLen:\n    < kMatchSpecLenStart : normal remain\n    = kMatchSpecLenStart : finished\n*/\n\n\n#ifdef _LZMA_DEC_OPT\n\nint MY_FAST_CALL LZMA_DECODE_REAL(CLzmaDec *p, size_t limit, const Byte *bufLimit);\n\n#else\n\nstatic\nint MY_FAST_CALL LZMA_DECODE_REAL(CLzmaDec *p, size_t limit, const Byte *bufLimit)\n{\n  CLzmaProb *probs = GET_PROBS;\n  unsigned state = (unsigned)p->state;\n  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];\n  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;\n  unsigned lc = p->prop.lc;\n  unsigned lpMask = ((unsigned)0x100 << p->prop.lp) - ((unsigned)0x100 >> lc);\n\n  Byte *dic = p->dic;\n  size_t dicBufSize = p->dicBufSize;\n  size_t dicPos = p->dicPos;\n\n  UInt32 processedPos = p->processedPos;\n  UInt32 checkDicSize = p->checkDicSize;\n  unsigned len = 0;\n\n  const Byte *buf = p->buf;\n  UInt32 range = p->range;\n  UInt32 code = p->code;\n\n  do\n  {\n    CLzmaProb *prob;\n    UInt32 bound;\n    unsigned ttt;\n    unsigned posState = CALC_POS_STATE(processedPos, pbMask);\n\n    prob = probs + IsMatch + COMBINED_PS_STATE;\n    IF_BIT_0(prob)\n    {\n      unsigned symbol;\n      UPDATE_0(prob);\n      prob = probs + Literal;\n      if (processedPos != 0 || checkDicSize != 0)\n        prob += (UInt32)3 * ((((processedPos << 8) + dic[(dicPos == 0 ? dicBufSize : dicPos) - 1]) & lpMask) << lc);\n      processedPos++;\n\n      if (state < kNumLitStates)\n      {\n        state -= (state < 4) ? state : 3;\n        symbol = 1;\n        #ifdef _LZMA_SIZE_OPT\n        do { NORMAL_LITER_DEC } while (symbol < 0x100);\n        #else\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        NORMAL_LITER_DEC\n        #endif\n      }\n      else\n      {\n        unsigned matchByte = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];\n        unsigned offs = 0x100;\n        state -= (state < 10) ? 3 : 6;\n        symbol = 1;\n        #ifdef _LZMA_SIZE_OPT\n        do\n        {\n          unsigned bit;\n          CLzmaProb *probLit;\n          MATCHED_LITER_DEC\n        }\n        while (symbol < 0x100);\n        #else\n        {\n          unsigned bit;\n          CLzmaProb *probLit;\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n          MATCHED_LITER_DEC\n        }\n        #endif\n      }\n\n      dic[dicPos++] = (Byte)symbol;\n      continue;\n    }\n\n    {\n      UPDATE_1(prob);\n      prob = probs + IsRep + state;\n      IF_BIT_0(prob)\n      {\n        UPDATE_0(prob);\n        state += kNumStates;\n        prob = probs + LenCoder;\n      }\n      else\n      {\n        UPDATE_1(prob);\n        /*\n        // that case was checked before with kBadRepCode\n        if (checkDicSize == 0 && processedPos == 0)\n          return SZ_ERROR_DATA;\n        */\n        prob = probs + IsRepG0 + state;\n        IF_BIT_0(prob)\n        {\n          UPDATE_0(prob);\n          prob = probs + IsRep0Long + COMBINED_PS_STATE;\n          IF_BIT_0(prob)\n          {\n            UPDATE_0(prob);\n            dic[dicPos] = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];\n            dicPos++;\n            processedPos++;\n            state = state < kNumLitStates ? 9 : 11;\n            continue;\n          }\n          UPDATE_1(prob);\n        }\n        else\n        {\n          UInt32 distance;\n          UPDATE_1(prob);\n          prob = probs + IsRepG1 + state;\n          IF_BIT_0(prob)\n          {\n            UPDATE_0(prob);\n            distance = rep1;\n          }\n          else\n          {\n            UPDATE_1(prob);\n            prob = probs + IsRepG2 + state;\n            IF_BIT_0(prob)\n            {\n              UPDATE_0(prob);\n              distance = rep2;\n            }\n            else\n            {\n              UPDATE_1(prob);\n              distance = rep3;\n              rep3 = rep2;\n            }\n            rep2 = rep1;\n          }\n          rep1 = rep0;\n          rep0 = distance;\n        }\n        state = state < kNumLitStates ? 8 : 11;\n        prob = probs + RepLenCoder;\n      }\n\n      #ifdef _LZMA_SIZE_OPT\n      {\n        unsigned lim, offset;\n        CLzmaProb *probLen = prob + LenChoice;\n        IF_BIT_0(probLen)\n        {\n          UPDATE_0(probLen);\n          probLen = prob + LenLow + GET_LEN_STATE;\n          offset = 0;\n          lim = (1 << kLenNumLowBits);\n        }\n        else\n        {\n          UPDATE_1(probLen);\n          probLen = prob + LenChoice2;\n          IF_BIT_0(probLen)\n          {\n            UPDATE_0(probLen);\n            probLen = prob + LenLow + GET_LEN_STATE + (1 << kLenNumLowBits);\n            offset = kLenNumLowSymbols;\n            lim = (1 << kLenNumLowBits);\n          }\n          else\n          {\n            UPDATE_1(probLen);\n            probLen = prob + LenHigh;\n            offset = kLenNumLowSymbols * 2;\n            lim = (1 << kLenNumHighBits);\n          }\n        }\n        TREE_DECODE(probLen, lim, len);\n        len += offset;\n      }\n      #else\n      {\n        CLzmaProb *probLen = prob + LenChoice;\n        IF_BIT_0(probLen)\n        {\n          UPDATE_0(probLen);\n          probLen = prob + LenLow + GET_LEN_STATE;\n          len = 1;\n          TREE_GET_BIT(probLen, len);\n          TREE_GET_BIT(probLen, len);\n          TREE_GET_BIT(probLen, len);\n          len -= 8;\n        }\n        else\n        {\n          UPDATE_1(probLen);\n          probLen = prob + LenChoice2;\n          IF_BIT_0(probLen)\n          {\n            UPDATE_0(probLen);\n            probLen = prob + LenLow + GET_LEN_STATE + (1 << kLenNumLowBits);\n            len = 1;\n            TREE_GET_BIT(probLen, len);\n            TREE_GET_BIT(probLen, len);\n            TREE_GET_BIT(probLen, len);\n          }\n          else\n          {\n            UPDATE_1(probLen);\n            probLen = prob + LenHigh;\n            TREE_DECODE(probLen, (1 << kLenNumHighBits), len);\n            len += kLenNumLowSymbols * 2;\n          }\n        }\n      }\n      #endif\n\n      if (state >= kNumStates)\n      {\n        UInt32 distance;\n        prob = probs + PosSlot +\n            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);\n        TREE_6_DECODE(prob, distance);\n        if (distance >= kStartPosModelIndex)\n        {\n          unsigned posSlot = (unsigned)distance;\n          unsigned numDirectBits = (unsigned)(((distance >> 1) - 1));\n          distance = (2 | (distance & 1));\n          if (posSlot < kEndPosModelIndex)\n          {\n            distance <<= numDirectBits;\n            prob = probs + SpecPos;\n            {\n              UInt32 m = 1;\n              distance++;\n              do\n              {\n                REV_BIT_VAR(prob, distance, m);\n              }\n              while (--numDirectBits);\n              distance -= m;\n            }\n          }\n          else\n          {\n            numDirectBits -= kNumAlignBits;\n            do\n            {\n              NORMALIZE\n              range >>= 1;\n\n              {\n                UInt32 t;\n                code -= range;\n                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */\n                distance = (distance << 1) + (t + 1);\n                code += range & t;\n              }\n              /*\n              distance <<= 1;\n              if (code >= range)\n              {\n                code -= range;\n                distance |= 1;\n              }\n              */\n            }\n            while (--numDirectBits);\n            prob = probs + Align;\n            distance <<= kNumAlignBits;\n            {\n              unsigned i = 1;\n              REV_BIT_CONST(prob, i, 1);\n              REV_BIT_CONST(prob, i, 2);\n              REV_BIT_CONST(prob, i, 4);\n              REV_BIT_LAST (prob, i, 8);\n              distance |= i;\n            }\n            if (distance == (UInt32)0xFFFFFFFF)\n            {\n              len = kMatchSpecLenStart;\n              state -= kNumStates;\n              break;\n            }\n          }\n        }\n\n        rep3 = rep2;\n        rep2 = rep1;\n        rep1 = rep0;\n        rep0 = distance + 1;\n        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;\n        if (distance >= (checkDicSize == 0 ? processedPos: checkDicSize))\n        {\n          p->dicPos = dicPos;\n          return SZ_ERROR_DATA;\n        }\n      }\n\n      len += kMatchMinLen;\n\n      {\n        size_t rem;\n        unsigned curLen;\n        size_t pos;\n\n        if ((rem = limit - dicPos) == 0)\n        {\n          p->dicPos = dicPos;\n          return SZ_ERROR_DATA;\n        }\n\n        curLen = ((rem < len) ? (unsigned)rem : len);\n        pos = dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0);\n\n        processedPos += (UInt32)curLen;\n\n        len -= curLen;\n        if (curLen <= dicBufSize - pos)\n        {\n          Byte *dest = dic + dicPos;\n          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;\n          const Byte *lim = dest + curLen;\n          dicPos += (size_t)curLen;\n          do\n            *(dest) = (Byte)*(dest + src);\n          while (++dest != lim);\n        }\n        else\n        {\n          do\n          {\n            dic[dicPos++] = dic[pos];\n            if (++pos == dicBufSize)\n              pos = 0;\n          }\n          while (--curLen != 0);\n        }\n      }\n    }\n  }\n  while (dicPos < limit && buf < bufLimit);\n\n  NORMALIZE;\n\n  p->buf = buf;\n  p->range = range;\n  p->code = code;\n  p->remainLen = (UInt32)len;\n  p->dicPos = dicPos;\n  p->processedPos = processedPos;\n  p->reps[0] = rep0;\n  p->reps[1] = rep1;\n  p->reps[2] = rep2;\n  p->reps[3] = rep3;\n  p->state = (UInt32)state;\n\n  return SZ_OK;\n}\n#endif\n\nstatic void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, size_t limit)\n{\n  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)\n  {\n    Byte *dic = p->dic;\n    size_t dicPos = p->dicPos;\n    size_t dicBufSize = p->dicBufSize;\n    unsigned len = (unsigned)p->remainLen;\n    size_t rep0 = p->reps[0]; /* we use size_t to avoid the BUG of VC14 for AMD64 */\n    size_t rem = limit - dicPos;\n    if (rem < len)\n      len = (unsigned)(rem);\n\n    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)\n      p->checkDicSize = p->prop.dicSize;\n\n    p->processedPos += (UInt32)len;\n    p->remainLen -= (UInt32)len;\n    while (len != 0)\n    {\n      len--;\n      dic[dicPos] = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];\n      dicPos++;\n    }\n    p->dicPos = dicPos;\n  }\n}\n\n\n#define kRange0 0xFFFFFFFF\n#define kBound0 ((kRange0 >> kNumBitModelTotalBits) << (kNumBitModelTotalBits - 1))\n#define kBadRepCode (kBound0 + (((kRange0 - kBound0) >> kNumBitModelTotalBits) << (kNumBitModelTotalBits - 1)))\n#if kBadRepCode != (0xC0000000 - 0x400)\n  #error Stop_Compiling_Bad_LZMA_Check\n#endif\n\nstatic int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, size_t limit, const Byte *bufLimit)\n{\n  do\n  {\n    size_t limit2 = limit;\n    if (p->checkDicSize == 0)\n    {\n      UInt32 rem = p->prop.dicSize - p->processedPos;\n      if (limit - p->dicPos > rem)\n        limit2 = p->dicPos + rem;\n\n      if (p->processedPos == 0)\n        if (p->code >= kBadRepCode)\n          return SZ_ERROR_DATA;\n    }\n\n    RINOK(LZMA_DECODE_REAL(p, limit2, bufLimit));\n\n    if (p->checkDicSize == 0 && p->processedPos >= p->prop.dicSize)\n      p->checkDicSize = p->prop.dicSize;\n\n    LzmaDec_WriteRem(p, limit);\n  }\n  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);\n\n  return 0;\n}\n\ntypedef enum\n{\n  DUMMY_ERROR, /* unexpected end of input stream */\n  DUMMY_LIT,\n  DUMMY_MATCH,\n  DUMMY_REP\n} ELzmaDummy;\n\nstatic ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, size_t inSize)\n{\n  UInt32 range = p->range;\n  UInt32 code = p->code;\n  const Byte *bufLimit = buf + inSize;\n  const CLzmaProb *probs = GET_PROBS;\n  unsigned state = (unsigned)p->state;\n  ELzmaDummy res;\n\n  {\n    const CLzmaProb *prob;\n    UInt32 bound;\n    unsigned ttt;\n    unsigned posState = CALC_POS_STATE(p->processedPos, (1 << p->prop.pb) - 1);\n\n    prob = probs + IsMatch + COMBINED_PS_STATE;\n    IF_BIT_0_CHECK(prob)\n    {\n      UPDATE_0_CHECK\n\n      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */\n\n      prob = probs + Literal;\n      if (p->checkDicSize != 0 || p->processedPos != 0)\n        prob += ((UInt32)LZMA_LIT_SIZE *\n            ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +\n            (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));\n\n      if (state < kNumLitStates)\n      {\n        unsigned symbol = 1;\n        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);\n      }\n      else\n      {\n        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +\n            (p->dicPos < p->reps[0] ? p->dicBufSize : 0)];\n        unsigned offs = 0x100;\n        unsigned symbol = 1;\n        do\n        {\n          unsigned bit;\n          const CLzmaProb *probLit;\n          matchByte += matchByte;\n          bit = offs;\n          offs &= matchByte;\n          probLit = prob + (offs + bit + symbol);\n          GET_BIT2_CHECK(probLit, symbol, offs ^= bit; , ; )\n        }\n        while (symbol < 0x100);\n      }\n      res = DUMMY_LIT;\n    }\n    else\n    {\n      unsigned len;\n      UPDATE_1_CHECK;\n\n      prob = probs + IsRep + state;\n      IF_BIT_0_CHECK(prob)\n      {\n        UPDATE_0_CHECK;\n        state = 0;\n        prob = probs + LenCoder;\n        res = DUMMY_MATCH;\n      }\n      else\n      {\n        UPDATE_1_CHECK;\n        res = DUMMY_REP;\n        prob = probs + IsRepG0 + state;\n        IF_BIT_0_CHECK(prob)\n        {\n          UPDATE_0_CHECK;\n          prob = probs + IsRep0Long + COMBINED_PS_STATE;\n          IF_BIT_0_CHECK(prob)\n          {\n            UPDATE_0_CHECK;\n            NORMALIZE_CHECK;\n            return DUMMY_REP;\n          }\n          else\n          {\n            UPDATE_1_CHECK;\n          }\n        }\n        else\n        {\n          UPDATE_1_CHECK;\n          prob = probs + IsRepG1 + state;\n          IF_BIT_0_CHECK(prob)\n          {\n            UPDATE_0_CHECK;\n          }\n          else\n          {\n            UPDATE_1_CHECK;\n            prob = probs + IsRepG2 + state;\n            IF_BIT_0_CHECK(prob)\n            {\n              UPDATE_0_CHECK;\n            }\n            else\n            {\n              UPDATE_1_CHECK;\n            }\n          }\n        }\n        state = kNumStates;\n        prob = probs + RepLenCoder;\n      }\n      {\n        unsigned limit, offset;\n        const CLzmaProb *probLen = prob + LenChoice;\n        IF_BIT_0_CHECK(probLen)\n        {\n          UPDATE_0_CHECK;\n          probLen = prob + LenLow + GET_LEN_STATE;\n          offset = 0;\n          limit = 1 << kLenNumLowBits;\n        }\n        else\n        {\n          UPDATE_1_CHECK;\n          probLen = prob + LenChoice2;\n          IF_BIT_0_CHECK(probLen)\n          {\n            UPDATE_0_CHECK;\n            probLen = prob + LenLow + GET_LEN_STATE + (1 << kLenNumLowBits);\n            offset = kLenNumLowSymbols;\n            limit = 1 << kLenNumLowBits;\n          }\n          else\n          {\n            UPDATE_1_CHECK;\n            probLen = prob + LenHigh;\n            offset = kLenNumLowSymbols * 2;\n            limit = 1 << kLenNumHighBits;\n          }\n        }\n        TREE_DECODE_CHECK(probLen, limit, len);\n        len += offset;\n      }\n\n      if (state < 4)\n      {\n        unsigned posSlot;\n        prob = probs + PosSlot +\n            ((len < kNumLenToPosStates - 1 ? len : kNumLenToPosStates - 1) <<\n            kNumPosSlotBits);\n        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);\n        if (posSlot >= kStartPosModelIndex)\n        {\n          unsigned numDirectBits = ((posSlot >> 1) - 1);\n\n          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */\n\n          if (posSlot < kEndPosModelIndex)\n          {\n            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits);\n          }\n          else\n          {\n            numDirectBits -= kNumAlignBits;\n            do\n            {\n              NORMALIZE_CHECK\n              range >>= 1;\n              code -= range & (((code - range) >> 31) - 1);\n              /* if (code >= range) code -= range; */\n            }\n            while (--numDirectBits);\n            prob = probs + Align;\n            numDirectBits = kNumAlignBits;\n          }\n          {\n            unsigned i = 1;\n            unsigned m = 1;\n            do\n            {\n              REV_BIT_CHECK(prob, i, m);\n            }\n            while (--numDirectBits);\n          }\n        }\n      }\n    }\n  }\n  NORMALIZE_CHECK;\n  return res;\n}\n\n\nvoid LzmaDec_InitDicAndState(CLzmaDec *p, BoolInt initDic, BoolInt initState)\n{\n  p->remainLen = kMatchSpecLenStart + 1;\n  p->tempBufSize = 0;\n\n  if (initDic)\n  {\n    p->processedPos = 0;\n    p->checkDicSize = 0;\n    p->remainLen = kMatchSpecLenStart + 2;\n  }\n  if (initState)\n    p->remainLen = kMatchSpecLenStart + 2;\n}\n\nvoid LzmaDec_Init(CLzmaDec *p)\n{\n  p->dicPos = 0;\n  LzmaDec_InitDicAndState(p, True, True);\n}\n\n\nSRes LzmaDec_DecodeToDic(CLzmaDec *p, size_t dicLimit, const Byte *src, size_t *srcLen,\n    ELzmaFinishMode finishMode, ELzmaStatus *status)\n{\n  size_t inSize = *srcLen;\n  (*srcLen) = 0;\n\n  *status = LZMA_STATUS_NOT_SPECIFIED;\n\n  if (p->remainLen > kMatchSpecLenStart)\n  {\n    for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)\n      p->tempBuf[p->tempBufSize++] = *src++;\n    if (p->tempBufSize != 0 && p->tempBuf[0] != 0)\n      return SZ_ERROR_DATA;\n    if (p->tempBufSize < RC_INIT_SIZE)\n    {\n      *status = LZMA_STATUS_NEEDS_MORE_INPUT;\n      return SZ_OK;\n    }\n    p->code =\n        ((UInt32)p->tempBuf[1] << 24)\n      | ((UInt32)p->tempBuf[2] << 16)\n      | ((UInt32)p->tempBuf[3] << 8)\n      | ((UInt32)p->tempBuf[4]);\n    p->range = 0xFFFFFFFF;\n    p->tempBufSize = 0;\n\n    if (p->remainLen > kMatchSpecLenStart + 1)\n    {\n      size_t numProbs = LzmaProps_GetNumProbs(&p->prop);\n      size_t i;\n      CLzmaProb *probs = p->probs;\n      for (i = 0; i < numProbs; i++)\n        probs[i] = kBitModelTotal >> 1;\n      p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;\n      p->state = 0;\n    }\n\n    p->remainLen = 0;\n  }\n\n  LzmaDec_WriteRem(p, dicLimit);\n\n  while (p->remainLen != kMatchSpecLenStart)\n  {\n      int checkEndMarkNow = 0;\n\n      if (p->dicPos >= dicLimit)\n      {\n        if (p->remainLen == 0 && p->code == 0)\n        {\n          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n          return SZ_OK;\n        }\n        if (finishMode == LZMA_FINISH_ANY)\n        {\n          *status = LZMA_STATUS_NOT_FINISHED;\n          return SZ_OK;\n        }\n        if (p->remainLen != 0)\n        {\n          *status = LZMA_STATUS_NOT_FINISHED;\n          return SZ_ERROR_DATA;\n        }\n        checkEndMarkNow = 1;\n      }\n\n      if (p->tempBufSize == 0)\n      {\n        size_t processed;\n        const Byte *bufLimit;\n        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)\n        {\n          int dummyRes = LzmaDec_TryDummy(p, src, inSize);\n          if (dummyRes == DUMMY_ERROR)\n          {\n            memcpy(p->tempBuf, src, inSize);\n            p->tempBufSize = (unsigned)inSize;\n            (*srcLen) += inSize;\n            *status = LZMA_STATUS_NEEDS_MORE_INPUT;\n            return SZ_OK;\n          }\n          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)\n          {\n            *status = LZMA_STATUS_NOT_FINISHED;\n            return SZ_ERROR_DATA;\n          }\n          bufLimit = src;\n        }\n        else\n          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;\n        p->buf = src;\n        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)\n          return SZ_ERROR_DATA;\n        processed = (size_t)(p->buf - src);\n        (*srcLen) += processed;\n        src += processed;\n        inSize -= processed;\n      }\n      else\n      {\n        unsigned rem = p->tempBufSize, lookAhead = 0;\n        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)\n          p->tempBuf[rem++] = src[lookAhead++];\n        p->tempBufSize = rem;\n        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)\n        {\n          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, (size_t)rem);\n          if (dummyRes == DUMMY_ERROR)\n          {\n            (*srcLen) += (size_t)lookAhead;\n            *status = LZMA_STATUS_NEEDS_MORE_INPUT;\n            return SZ_OK;\n          }\n          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)\n          {\n            *status = LZMA_STATUS_NOT_FINISHED;\n            return SZ_ERROR_DATA;\n          }\n        }\n        p->buf = p->tempBuf;\n        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)\n          return SZ_ERROR_DATA;\n\n        {\n          unsigned kkk = (unsigned)(p->buf - p->tempBuf);\n          if (rem < kkk)\n            return SZ_ERROR_FAIL; /* some internal error */\n          rem -= kkk;\n          if (lookAhead < rem)\n            return SZ_ERROR_FAIL; /* some internal error */\n          lookAhead -= rem;\n        }\n        (*srcLen) += (size_t)lookAhead;\n        src += lookAhead;\n        inSize -= (size_t)lookAhead;\n        p->tempBufSize = 0;\n      }\n  }\n\n  if (p->code != 0)\n    return SZ_ERROR_DATA;\n  *status = LZMA_STATUS_FINISHED_WITH_MARK;\n  return SZ_OK;\n}\n\n\nSRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, size_t *destLen, const Byte *src, size_t *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)\n{\n  size_t outSize = *destLen;\n  size_t inSize = *srcLen;\n  *srcLen = *destLen = 0;\n  for (;;)\n  {\n    size_t inSizeCur = inSize, outSizeCur, dicPos;\n    ELzmaFinishMode curFinishMode;\n    SRes res;\n    if (p->dicPos == p->dicBufSize)\n      p->dicPos = 0;\n    dicPos = p->dicPos;\n    if (outSize > p->dicBufSize - dicPos)\n    {\n      outSizeCur = p->dicBufSize;\n      curFinishMode = LZMA_FINISH_ANY;\n    }\n    else\n    {\n      outSizeCur = dicPos + outSize;\n      curFinishMode = finishMode;\n    }\n\n    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);\n    src += inSizeCur;\n    inSize -= inSizeCur;\n    *srcLen += inSizeCur;\n    outSizeCur = p->dicPos - dicPos;\n    memcpy(dest, p->dic + dicPos, outSizeCur);\n    dest += outSizeCur;\n    outSize -= outSizeCur;\n    *destLen += outSizeCur;\n    if (res != 0)\n      return res;\n    if (outSizeCur == 0 || outSize == 0)\n      return SZ_OK;\n  }\n}\n\nvoid LzmaDec_FreeProbs(CLzmaDec *p, ISzAllocPtr alloc)\n{\n  ISzAlloc_Free(alloc, p->probs);\n  p->probs = NULL;\n}\n\nstatic void LzmaDec_FreeDict(CLzmaDec *p, ISzAllocPtr alloc)\n{\n  ISzAlloc_Free(alloc, p->dic);\n  p->dic = NULL;\n}\n\nvoid LzmaDec_Free(CLzmaDec *p, ISzAllocPtr alloc)\n{\n  LzmaDec_FreeProbs(p, alloc);\n  LzmaDec_FreeDict(p, alloc);\n}\n\nSRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)\n{\n  UInt32 dicSize;\n  Byte d;\n\n  if (size < LZMA_PROPS_SIZE)\n    return SZ_ERROR_UNSUPPORTED;\n  else\n    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);\n\n  if (dicSize < LZMA_DIC_MIN)\n    dicSize = LZMA_DIC_MIN;\n  p->dicSize = dicSize;\n\n  d = data[0];\n  if (d >= (9 * 5 * 5))\n    return SZ_ERROR_UNSUPPORTED;\n\n  p->lc = (Byte)(d % 9);\n  d /= 9;\n  p->pb = (Byte)(d / 5);\n  p->lp = (Byte)(d % 5);\n\n  return SZ_OK;\n}\n\nstatic SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAllocPtr alloc)\n{\n  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);\n  if (!p->probs || numProbs != p->numProbs)\n  {\n    LzmaDec_FreeProbs(p, alloc);\n    p->probs = (CLzmaProb *)ISzAlloc_Alloc(alloc, numProbs * sizeof(CLzmaProb));\n    if (!p->probs)\n      return SZ_ERROR_MEM;\n    p->probs_1664 = p->probs + 1664;\n    p->numProbs = numProbs;\n  }\n  return SZ_OK;\n}\n\nSRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAllocPtr alloc)\n{\n  CLzmaProps propNew;\n  RINOK(LzmaProps_Decode(&propNew, props, propsSize));\n  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));\n  p->prop = propNew;\n  return SZ_OK;\n}\n\nSRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAllocPtr alloc)\n{\n  CLzmaProps propNew;\n  size_t dicBufSize;\n  RINOK(LzmaProps_Decode(&propNew, props, propsSize));\n  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));\n\n  {\n    UInt32 dictSize = propNew.dicSize;\n    size_t mask = ((UInt32)1 << 12) - 1;\n         if (dictSize >= ((UInt32)1 << 30)) mask = ((UInt32)1 << 22) - 1;\n    else if (dictSize >= ((UInt32)1 << 22)) mask = ((UInt32)1 << 20) - 1;;\n    dicBufSize = ((size_t)dictSize + mask) & ~mask;\n    if (dicBufSize < dictSize)\n      dicBufSize = dictSize;\n  }\n\n  if (!p->dic || dicBufSize != p->dicBufSize)\n  {\n    LzmaDec_FreeDict(p, alloc);\n    p->dic = (Byte *)ISzAlloc_Alloc(alloc, dicBufSize);\n    if (!p->dic)\n    {\n      LzmaDec_FreeProbs(p, alloc);\n      return SZ_ERROR_MEM;\n    }\n  }\n  p->dicBufSize = dicBufSize;\n  p->prop = propNew;\n  return SZ_OK;\n}\n\nSRes LzmaDecode(Byte *dest, size_t *destLen, const Byte *src, size_t *srcLen,\n    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,\n    ELzmaStatus *status, ISzAllocPtr alloc)\n{\n  CLzmaDec p;\n  SRes res;\n  size_t outSize = *destLen, inSize = *srcLen;\n  *destLen = *srcLen = 0;\n  *status = LZMA_STATUS_NOT_SPECIFIED;\n  if (inSize < RC_INIT_SIZE)\n    return SZ_ERROR_INPUT_EOF;\n  LzmaDec_Construct(&p);\n  RINOK(LzmaDec_AllocateProbs(&p, propData, propSize, alloc));\n  p.dic = dest;\n  p.dicBufSize = outSize;\n  LzmaDec_Init(&p);\n  *srcLen = inSize;\n  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);\n  *destLen = p.dicPos;\n  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)\n    res = SZ_ERROR_INPUT_EOF;\n  LzmaDec_FreeProbs(&p, alloc);\n  return res;\n}\n\n\n\n\n\n/* LzHash.h -- HASH functions for LZ algorithms\n2015-04-12 : Igor Pavlov : Public domain */\n\n#define kHash2Size (1 << 10)\n#define kHash3Size (1 << 16)\n#define kHash4Size (1 << 20)\n\n#define kFix3HashSize (kHash2Size)\n#define kFix4HashSize (kHash2Size + kHash3Size)\n#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)\n\n#define HASH2_CALC hv = cur[0] | ((UInt32)cur[1] << 8);\n\n#define HASH3_CALC { \\\n  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \\\n  h2 = temp & (kHash2Size - 1); \\\n  hv = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }\n\n#define HASH4_CALC { \\\n  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \\\n  h2 = temp & (kHash2Size - 1); \\\n  temp ^= ((UInt32)cur[2] << 8); \\\n  h3 = temp & (kHash3Size - 1); \\\n  hv = (temp ^ (p->crc[cur[3]] << 5)) & p->hashMask; }\n\n#define HASH5_CALC { \\\n  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \\\n  h2 = temp & (kHash2Size - 1); \\\n  temp ^= ((UInt32)cur[2] << 8); \\\n  h3 = temp & (kHash3Size - 1); \\\n  temp ^= (p->crc[cur[3]] << 5); \\\n  h4 = temp & (kHash4Size - 1); \\\n  hv = (temp ^ (p->crc[cur[4]] << 3)) & p->hashMask; }\n\n/* #define HASH_ZIP_CALC hv = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */\n#define HASH_ZIP_CALC hv = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;\n\n\n#define MT_HASH2_CALC \\\n  h2 = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);\n\n#define MT_HASH3_CALC { \\\n  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \\\n  h2 = temp & (kHash2Size - 1); \\\n  h3 = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }\n\n#define MT_HASH4_CALC { \\\n  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \\\n  h2 = temp & (kHash2Size - 1); \\\n  temp ^= ((UInt32)cur[2] << 8); \\\n  h3 = temp & (kHash3Size - 1); \\\n  h4 = (temp ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }\n\n\n\n\n\n/* LzFind.c -- Match finder for LZ algorithms\n2018-07-08 : Igor Pavlov : Public domain */\n\n#include <string.h>\n\n//#include \"LzFind.h\"\n//#include \"LzHash.h\"\n\n#define kEmptyHashValue 0\n#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)\n#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */\n#define kNormalizeMask (~(UInt32)(kNormalizeStepMin - 1))\n#define kMaxHistorySize ((UInt32)7 << 29)\n\n#define kStartMaxLen 3\n\nstatic void LzInWindow_Free(CMatchFinder *p, ISzAllocPtr alloc)\n{\n  if (!p->directInput)\n  {\n    ISzAlloc_Free(alloc, p->bufferBase);\n    p->bufferBase = NULL;\n  }\n}\n\n/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */\n\nstatic int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAllocPtr alloc)\n{\n  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;\n  if (p->directInput)\n  {\n    p->blockSize = blockSize;\n    return 1;\n  }\n  if (!p->bufferBase || p->blockSize != blockSize)\n  {\n    LzInWindow_Free(p, alloc);\n    p->blockSize = blockSize;\n    p->bufferBase = (Byte *)ISzAlloc_Alloc(alloc, (size_t)blockSize);\n  }\n  return (p->bufferBase != NULL);\n}\n\nByte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }\n\nUInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }\n\nvoid MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)\n{\n  p->posLimit -= subValue;\n  p->pos -= subValue;\n  p->streamPos -= subValue;\n}\n\nstatic void MatchFinder_ReadBlock(CMatchFinder *p)\n{\n  if (p->streamEndWasReached || p->result != SZ_OK)\n    return;\n\n  /* We use (p->streamPos - p->pos) value. (p->streamPos < p->pos) is allowed. */\n\n  if (p->directInput)\n  {\n    UInt32 curSize = 0xFFFFFFFF - (p->streamPos - p->pos);\n    if (curSize > p->directInputRem)\n      curSize = (UInt32)p->directInputRem;\n    p->directInputRem -= curSize;\n    p->streamPos += curSize;\n    if (p->directInputRem == 0)\n      p->streamEndWasReached = 1;\n    return;\n  }\n\n  for (;;)\n  {\n    Byte *dest = p->buffer + (p->streamPos - p->pos);\n    size_t size = (p->bufferBase + p->blockSize - dest);\n    if (size == 0)\n      return;\n\n    p->result = ISeqInStream_Read(p->stream, dest, &size);\n    if (p->result != SZ_OK)\n      return;\n    if (size == 0)\n    {\n      p->streamEndWasReached = 1;\n      return;\n    }\n    p->streamPos += (UInt32)size;\n    if (p->streamPos - p->pos > p->keepSizeAfter)\n      return;\n  }\n}\n\nvoid MatchFinder_MoveBlock(CMatchFinder *p)\n{\n  memmove(p->bufferBase,\n      p->buffer - p->keepSizeBefore,\n      (size_t)(p->streamPos - p->pos) + p->keepSizeBefore);\n  p->buffer = p->bufferBase + p->keepSizeBefore;\n}\n\nint MatchFinder_NeedMove(CMatchFinder *p)\n{\n  if (p->directInput)\n    return 0;\n  /* if (p->streamEndWasReached) return 0; */\n  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);\n}\n\nvoid MatchFinder_ReadIfRequired(CMatchFinder *p)\n{\n  if (p->streamEndWasReached)\n    return;\n  if (p->keepSizeAfter >= p->streamPos - p->pos)\n    MatchFinder_ReadBlock(p);\n}\n\nstatic void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)\n{\n  if (MatchFinder_NeedMove(p))\n    MatchFinder_MoveBlock(p);\n  MatchFinder_ReadBlock(p);\n}\n\nstatic void MatchFinder_SetDefaultSettings(CMatchFinder *p)\n{\n  p->cutValue = 32;\n  p->btMode = 1;\n  p->numHashBytes = 4;\n  p->bigHash = 0;\n}\n\n#define kCrcPoly 0xEDB88320\n\nvoid MatchFinder_Construct(CMatchFinder *p)\n{\n  unsigned i;\n  p->bufferBase = NULL;\n  p->directInput = 0;\n  p->hash = NULL;\n  p->expectedDataSize = (UInt64)(Int64)-1;\n  MatchFinder_SetDefaultSettings(p);\n\n  for (i = 0; i < 256; i++)\n  {\n    UInt32 r = (UInt32)i;\n    unsigned j;\n    for (j = 0; j < 8; j++)\n      r = (r >> 1) ^ (kCrcPoly & ((UInt32)0 - (r & 1)));\n    p->crc[i] = r;\n  }\n}\n\nstatic void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAllocPtr alloc)\n{\n  ISzAlloc_Free(alloc, p->hash);\n  p->hash = NULL;\n}\n\nvoid MatchFinder_Free(CMatchFinder *p, ISzAllocPtr alloc)\n{\n  MatchFinder_FreeThisClassMemory(p, alloc);\n  LzInWindow_Free(p, alloc);\n}\n\nstatic CLzRef* AllocRefs(size_t num, ISzAllocPtr alloc)\n{\n  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);\n  if (sizeInBytes / sizeof(CLzRef) != num)\n    return NULL;\n  return (CLzRef *)ISzAlloc_Alloc(alloc, sizeInBytes);\n}\n\nint MatchFinder_Create(CMatchFinder *p, UInt32 historySize,\n    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,\n    ISzAllocPtr alloc)\n{\n  UInt32 sizeReserv;\n\n  if (historySize > kMaxHistorySize)\n  {\n    MatchFinder_Free(p, alloc);\n    return 0;\n  }\n\n  sizeReserv = historySize >> 1;\n       if (historySize >= ((UInt32)3 << 30)) sizeReserv = historySize >> 3;\n  else if (historySize >= ((UInt32)2 << 30)) sizeReserv = historySize >> 2;\n\n  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);\n\n  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;\n  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;\n\n  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */\n\n  if (LzInWindow_Create(p, sizeReserv, alloc))\n  {\n    UInt32 newCyclicBufferSize = historySize + 1;\n    UInt32 hs;\n    p->matchMaxLen = matchMaxLen;\n    {\n      p->fixedHashSize = 0;\n      if (p->numHashBytes == 2)\n        hs = (1 << 16) - 1;\n      else\n      {\n        hs = historySize;\n        if (hs > p->expectedDataSize)\n          hs = (UInt32)p->expectedDataSize;\n        if (hs != 0)\n          hs--;\n        hs |= (hs >> 1);\n        hs |= (hs >> 2);\n        hs |= (hs >> 4);\n        hs |= (hs >> 8);\n        hs >>= 1;\n        hs |= 0xFFFF; /* don't change it! It's required for Deflate */\n        if (hs > (1 << 24))\n        {\n          if (p->numHashBytes == 3)\n            hs = (1 << 24) - 1;\n          else\n            hs >>= 1;\n          /* if (bigHash) mode, GetHeads4b() in LzFindMt.c needs (hs >= ((1 << 24) - 1))) */\n        }\n      }\n      p->hashMask = hs;\n      hs++;\n      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;\n      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;\n      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;\n      hs += p->fixedHashSize;\n    }\n\n    {\n      size_t newSize;\n      size_t numSons;\n      p->historySize = historySize;\n      p->hashSizeSum = hs;\n      p->cyclicBufferSize = newCyclicBufferSize;\n\n      numSons = newCyclicBufferSize;\n      if (p->btMode)\n        numSons <<= 1;\n      newSize = hs + numSons;\n\n      if (p->hash && p->numRefs == newSize)\n        return 1;\n\n      MatchFinder_FreeThisClassMemory(p, alloc);\n      p->numRefs = newSize;\n      p->hash = AllocRefs(newSize, alloc);\n\n      if (p->hash)\n      {\n        p->son = p->hash + p->hashSizeSum;\n        return 1;\n      }\n    }\n  }\n\n  MatchFinder_Free(p, alloc);\n  return 0;\n}\n\nstatic void MatchFinder_SetLimits(CMatchFinder *p)\n{\n  UInt32 limit = kMaxValForNormalize - p->pos;\n  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;\n\n  if (limit2 < limit)\n    limit = limit2;\n  limit2 = p->streamPos - p->pos;\n\n  if (limit2 <= p->keepSizeAfter)\n  {\n    if (limit2 > 0)\n      limit2 = 1;\n  }\n  else\n    limit2 -= p->keepSizeAfter;\n\n  if (limit2 < limit)\n    limit = limit2;\n\n  {\n    UInt32 lenLimit = p->streamPos - p->pos;\n    if (lenLimit > p->matchMaxLen)\n      lenLimit = p->matchMaxLen;\n    p->lenLimit = lenLimit;\n  }\n  p->posLimit = p->pos + limit;\n}\n\n\nvoid MatchFinder_Init_LowHash(CMatchFinder *p)\n{\n  size_t i;\n  CLzRef *items = p->hash;\n  size_t numItems = p->fixedHashSize;\n  for (i = 0; i < numItems; i++)\n    items[i] = kEmptyHashValue;\n}\n\n\nvoid MatchFinder_Init_HighHash(CMatchFinder *p)\n{\n  size_t i;\n  CLzRef *items = p->hash + p->fixedHashSize;\n  size_t numItems = (size_t)p->hashMask + 1;\n  for (i = 0; i < numItems; i++)\n    items[i] = kEmptyHashValue;\n}\n\n\nvoid MatchFinder_Init_3(CMatchFinder *p, int readData)\n{\n  p->cyclicBufferPos = 0;\n  p->buffer = p->bufferBase;\n  p->pos =\n  p->streamPos = p->cyclicBufferSize;\n  p->result = SZ_OK;\n  p->streamEndWasReached = 0;\n\n  if (readData)\n    MatchFinder_ReadBlock(p);\n\n  MatchFinder_SetLimits(p);\n}\n\n\nvoid MatchFinder_Init(CMatchFinder *p)\n{\n  MatchFinder_Init_HighHash(p);\n  MatchFinder_Init_LowHash(p);\n  MatchFinder_Init_3(p, True);\n}\n\n\nstatic UInt32 MatchFinder_GetSubValue(CMatchFinder *p)\n{\n  return (p->pos - p->historySize - 1) & kNormalizeMask;\n}\n\nvoid MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, size_t numItems)\n{\n  size_t i;\n  for (i = 0; i < numItems; i++)\n  {\n    UInt32 value = items[i];\n    if (value <= subValue)\n      value = kEmptyHashValue;\n    else\n      value -= subValue;\n    items[i] = value;\n  }\n}\n\nstatic void MatchFinder_Normalize(CMatchFinder *p)\n{\n  UInt32 subValue = MatchFinder_GetSubValue(p);\n  MatchFinder_Normalize3(subValue, p->hash, p->numRefs);\n  MatchFinder_ReduceOffsets(p, subValue);\n}\n\n\nMY_NO_INLINE\nstatic void MatchFinder_CheckLimits(CMatchFinder *p)\n{\n  if (p->pos == kMaxValForNormalize)\n    MatchFinder_Normalize(p);\n  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)\n    MatchFinder_CheckAndMoveAndRead(p);\n  if (p->cyclicBufferPos == p->cyclicBufferSize)\n    p->cyclicBufferPos = 0;\n  MatchFinder_SetLimits(p);\n}\n\n\n/*\n  (lenLimit > maxLen)\n*/\nMY_FORCE_INLINE\nstatic UInt32 * Hc_GetMatchesSpec(unsigned lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,\n    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,\n    UInt32 *distances, unsigned maxLen)\n{\n  /*\n  son[_cyclicBufferPos] = curMatch;\n  for (;;)\n  {\n    UInt32 delta = pos - curMatch;\n    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n      return distances;\n    {\n      const Byte *pb = cur - delta;\n      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];\n      if (pb[maxLen] == cur[maxLen] && *pb == *cur)\n      {\n        UInt32 len = 0;\n        while (++len != lenLimit)\n          if (pb[len] != cur[len])\n            break;\n        if (maxLen < len)\n        {\n          maxLen = len;\n          *distances++ = len;\n          *distances++ = delta - 1;\n          if (len == lenLimit)\n            return distances;\n        }\n      }\n    }\n  }\n  */\n\n  const Byte *lim = cur + lenLimit;\n  son[_cyclicBufferPos] = curMatch;\n  do\n  {\n    UInt32 delta = pos - curMatch;\n    if (delta >= _cyclicBufferSize)\n      break;\n    {\n      ptrdiff_t diff;\n      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];\n      diff = (ptrdiff_t)0 - delta;\n      if (cur[maxLen] == cur[maxLen + diff])\n      {\n        const Byte *c = cur;\n        while (*c == c[diff])\n        {\n          if (++c == lim)\n          {\n            distances[0] = (UInt32)(lim - cur);\n            distances[1] = delta - 1;\n            return distances + 2;\n          }\n        }\n        {\n          unsigned len = (unsigned)(c - cur);\n          if (maxLen < len)\n          {\n            maxLen = len;\n            distances[0] = (UInt32)len;\n            distances[1] = delta - 1;\n            distances += 2;\n          }\n        }\n      }\n    }\n  }\n  while (--cutValue);\n\n  return distances;\n}\n\n\nMY_FORCE_INLINE\nUInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,\n    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,\n    UInt32 *distances, UInt32 maxLen)\n{\n  CLzRef *ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;\n  CLzRef *ptr1 = son + ((size_t)_cyclicBufferPos << 1);\n  unsigned len0 = 0, len1 = 0;\n  for (;;)\n  {\n    UInt32 delta = pos - curMatch;\n    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n    {\n      *ptr0 = *ptr1 = kEmptyHashValue;\n      return distances;\n    }\n    {\n      CLzRef *pair = son + ((size_t)(_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n      const Byte *pb = cur - delta;\n      unsigned len = (len0 < len1 ? len0 : len1);\n      UInt32 pair0 = pair[0];\n      if (pb[len] == cur[len])\n      {\n        if (++len != lenLimit && pb[len] == cur[len])\n          while (++len != lenLimit)\n            if (pb[len] != cur[len])\n              break;\n        if (maxLen < len)\n        {\n          maxLen = (UInt32)len;\n          *distances++ = (UInt32)len;\n          *distances++ = delta - 1;\n          if (len == lenLimit)\n          {\n            *ptr1 = pair0;\n            *ptr0 = pair[1];\n            return distances;\n          }\n        }\n      }\n      if (pb[len] < cur[len])\n      {\n        *ptr1 = curMatch;\n        ptr1 = pair + 1;\n        curMatch = *ptr1;\n        len1 = len;\n      }\n      else\n      {\n        *ptr0 = curMatch;\n        ptr0 = pair;\n        curMatch = *ptr0;\n        len0 = len;\n      }\n    }\n  }\n}\n\nstatic void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,\n    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)\n{\n  CLzRef *ptr0 = son + ((size_t)_cyclicBufferPos << 1) + 1;\n  CLzRef *ptr1 = son + ((size_t)_cyclicBufferPos << 1);\n  unsigned len0 = 0, len1 = 0;\n  for (;;)\n  {\n    UInt32 delta = pos - curMatch;\n    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n    {\n      *ptr0 = *ptr1 = kEmptyHashValue;\n      return;\n    }\n    {\n      CLzRef *pair = son + ((size_t)(_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n      const Byte *pb = cur - delta;\n      unsigned len = (len0 < len1 ? len0 : len1);\n      if (pb[len] == cur[len])\n      {\n        while (++len != lenLimit)\n          if (pb[len] != cur[len])\n            break;\n        {\n          if (len == lenLimit)\n          {\n            *ptr1 = pair[0];\n            *ptr0 = pair[1];\n            return;\n          }\n        }\n      }\n      if (pb[len] < cur[len])\n      {\n        *ptr1 = curMatch;\n        ptr1 = pair + 1;\n        curMatch = *ptr1;\n        len1 = len;\n      }\n      else\n      {\n        *ptr0 = curMatch;\n        ptr0 = pair;\n        curMatch = *ptr0;\n        len0 = len;\n      }\n    }\n  }\n}\n\n#ifdef MOVE_POS\n#undef MOVE_POS\n#endif\n\n#define MOVE_POS \\\n  ++p->cyclicBufferPos; \\\n  p->buffer++; \\\n  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);\n\n#define MOVE_POS_RET MOVE_POS return (UInt32)offset;\n\nstatic void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }\n\n#define GET_MATCHES_HEADER2(minLen, ret_op) \\\n  unsigned lenLimit; UInt32 hv; const Byte *cur; UInt32 curMatch; \\\n  lenLimit = (unsigned)p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \\\n  cur = p->buffer;\n\n#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)\n#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)\n\n#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue\n\n#define GET_MATCHES_FOOTER(offset, maxLen) \\\n  offset = (unsigned)(GetMatchesSpec1((UInt32)lenLimit, curMatch, MF_PARAMS(p), \\\n  distances + offset, (UInt32)maxLen) - distances); MOVE_POS_RET;\n\n#define SKIP_FOOTER \\\n  SkipMatchesSpec((UInt32)lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;\n\n#define UPDATE_maxLen { \\\n    ptrdiff_t diff = (ptrdiff_t)0 - d2; \\\n    const Byte *c = cur + maxLen; \\\n    const Byte *lim = cur + lenLimit; \\\n    for (; c != lim; c++) if (*(c + diff) != *c) break; \\\n    maxLen = (unsigned)(c - cur); }\n\nstatic UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  unsigned offset;\n  GET_MATCHES_HEADER(2)\n  HASH2_CALC;\n  curMatch = p->hash[hv];\n  p->hash[hv] = p->pos;\n  offset = 0;\n  GET_MATCHES_FOOTER(offset, 1)\n}\n\nUInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  unsigned offset;\n  GET_MATCHES_HEADER(3)\n  HASH_ZIP_CALC;\n  curMatch = p->hash[hv];\n  p->hash[hv] = p->pos;\n  offset = 0;\n  GET_MATCHES_FOOTER(offset, 2)\n}\n\nstatic UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  UInt32 h2, d2, pos;\n  unsigned maxLen, offset;\n  UInt32 *hash;\n  GET_MATCHES_HEADER(3)\n\n  HASH3_CALC;\n\n  hash = p->hash;\n  pos = p->pos;\n\n  d2 = pos - hash[h2];\n\n  curMatch = (hash + kFix3HashSize)[hv];\n\n  hash[h2] = pos;\n  (hash + kFix3HashSize)[hv] = pos;\n\n  maxLen = 2;\n  offset = 0;\n\n  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)\n  {\n    UPDATE_maxLen\n    distances[0] = (UInt32)maxLen;\n    distances[1] = d2 - 1;\n    offset = 2;\n    if (maxLen == lenLimit)\n    {\n      SkipMatchesSpec((UInt32)lenLimit, curMatch, MF_PARAMS(p));\n      MOVE_POS_RET;\n    }\n  }\n\n  GET_MATCHES_FOOTER(offset, maxLen)\n}\n\nstatic UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  UInt32 h2, h3, d2, d3, pos;\n  unsigned maxLen, offset;\n  UInt32 *hash;\n  GET_MATCHES_HEADER(4)\n\n  HASH4_CALC;\n\n  hash = p->hash;\n  pos = p->pos;\n\n  d2 = pos - hash                  [h2];\n  d3 = pos - (hash + kFix3HashSize)[h3];\n\n  curMatch = (hash + kFix4HashSize)[hv];\n\n  hash                  [h2] = pos;\n  (hash + kFix3HashSize)[h3] = pos;\n  (hash + kFix4HashSize)[hv] = pos;\n\n  maxLen = 0;\n  offset = 0;\n\n  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)\n  {\n    maxLen = 2;\n    distances[0] = 2;\n    distances[1] = d2 - 1;\n    offset = 2;\n  }\n\n  if (d2 != d3 && d3 < p->cyclicBufferSize && *(cur - d3) == *cur)\n  {\n    maxLen = 3;\n    distances[(size_t)offset + 1] = d3 - 1;\n    offset += 2;\n    d2 = d3;\n  }\n\n  if (offset != 0)\n  {\n    UPDATE_maxLen\n    distances[(size_t)offset - 2] = (UInt32)maxLen;\n    if (maxLen == lenLimit)\n    {\n      SkipMatchesSpec((UInt32)lenLimit, curMatch, MF_PARAMS(p));\n      MOVE_POS_RET;\n    }\n  }\n\n  if (maxLen < 3)\n    maxLen = 3;\n\n  GET_MATCHES_FOOTER(offset, maxLen)\n}\n\n/*\nstatic UInt32 Bt5_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  UInt32 h2, h3, h4, d2, d3, d4, maxLen, offset, pos;\n  UInt32 *hash;\n  GET_MATCHES_HEADER(5)\n\n  HASH5_CALC;\n\n  hash = p->hash;\n  pos = p->pos;\n\n  d2 = pos - hash                  [h2];\n  d3 = pos - (hash + kFix3HashSize)[h3];\n  d4 = pos - (hash + kFix4HashSize)[h4];\n\n  curMatch = (hash + kFix5HashSize)[hv];\n\n  hash                  [h2] = pos;\n  (hash + kFix3HashSize)[h3] = pos;\n  (hash + kFix4HashSize)[h4] = pos;\n  (hash + kFix5HashSize)[hv] = pos;\n\n  maxLen = 0;\n  offset = 0;\n\n  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)\n  {\n    distances[0] = maxLen = 2;\n    distances[1] = d2 - 1;\n    offset = 2;\n    if (*(cur - d2 + 2) == cur[2])\n      distances[0] = maxLen = 3;\n    else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)\n    {\n      distances[2] = maxLen = 3;\n      distances[3] = d3 - 1;\n      offset = 4;\n      d2 = d3;\n    }\n  }\n  else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)\n  {\n    distances[0] = maxLen = 3;\n    distances[1] = d3 - 1;\n    offset = 2;\n    d2 = d3;\n  }\n\n  if (d2 != d4 && d4 < p->cyclicBufferSize\n      && *(cur - d4) == *cur\n      && *(cur - d4 + 3) == *(cur + 3))\n  {\n    maxLen = 4;\n    distances[(size_t)offset + 1] = d4 - 1;\n    offset += 2;\n    d2 = d4;\n  }\n\n  if (offset != 0)\n  {\n    UPDATE_maxLen\n    distances[(size_t)offset - 2] = maxLen;\n    if (maxLen == lenLimit)\n    {\n      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));\n      MOVE_POS_RET;\n    }\n  }\n\n  if (maxLen < 4)\n    maxLen = 4;\n\n  GET_MATCHES_FOOTER(offset, maxLen)\n}\n*/\n\nstatic UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  UInt32 h2, h3, d2, d3, pos;\n  unsigned maxLen, offset;\n  UInt32 *hash;\n  GET_MATCHES_HEADER(4)\n\n  HASH4_CALC;\n\n  hash = p->hash;\n  pos = p->pos;\n\n  d2 = pos - hash                  [h2];\n  d3 = pos - (hash + kFix3HashSize)[h3];\n  curMatch = (hash + kFix4HashSize)[hv];\n\n  hash                  [h2] = pos;\n  (hash + kFix3HashSize)[h3] = pos;\n  (hash + kFix4HashSize)[hv] = pos;\n\n  maxLen = 0;\n  offset = 0;\n\n  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)\n  {\n    maxLen = 2;\n    distances[0] = 2;\n    distances[1] = d2 - 1;\n    offset = 2;\n  }\n\n  if (d2 != d3 && d3 < p->cyclicBufferSize && *(cur - d3) == *cur)\n  {\n    maxLen = 3;\n    distances[(size_t)offset + 1] = d3 - 1;\n    offset += 2;\n    d2 = d3;\n  }\n\n  if (offset != 0)\n  {\n    UPDATE_maxLen\n    distances[(size_t)offset - 2] = (UInt32)maxLen;\n    if (maxLen == lenLimit)\n    {\n      p->son[p->cyclicBufferPos] = curMatch;\n      MOVE_POS_RET;\n    }\n  }\n\n  if (maxLen < 3)\n    maxLen = 3;\n\n  offset = (unsigned)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),\n      distances + offset, maxLen) - (distances));\n  MOVE_POS_RET\n}\n\n/*\nstatic UInt32 Hc5_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  UInt32 h2, h3, h4, d2, d3, d4, maxLen, offset, pos\n  UInt32 *hash;\n  GET_MATCHES_HEADER(5)\n\n  HASH5_CALC;\n\n  hash = p->hash;\n  pos = p->pos;\n\n  d2 = pos - hash                  [h2];\n  d3 = pos - (hash + kFix3HashSize)[h3];\n  d4 = pos - (hash + kFix4HashSize)[h4];\n\n  curMatch = (hash + kFix5HashSize)[hv];\n\n  hash                  [h2] = pos;\n  (hash + kFix3HashSize)[h3] = pos;\n  (hash + kFix4HashSize)[h4] = pos;\n  (hash + kFix5HashSize)[hv] = pos;\n\n  maxLen = 0;\n  offset = 0;\n\n  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)\n  {\n    distances[0] = maxLen = 2;\n    distances[1] = d2 - 1;\n    offset = 2;\n    if (*(cur - d2 + 2) == cur[2])\n      distances[0] = maxLen = 3;\n    else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)\n    {\n      distances[2] = maxLen = 3;\n      distances[3] = d3 - 1;\n      offset = 4;\n      d2 = d3;\n    }\n  }\n  else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)\n  {\n    distances[0] = maxLen = 3;\n    distances[1] = d3 - 1;\n    offset = 2;\n    d2 = d3;\n  }\n\n  if (d2 != d4 && d4 < p->cyclicBufferSize\n      && *(cur - d4) == *cur\n      && *(cur - d4 + 3) == *(cur + 3))\n  {\n    maxLen = 4;\n    distances[(size_t)offset + 1] = d4 - 1;\n    offset += 2;\n    d2 = d4;\n  }\n\n  if (offset != 0)\n  {\n    UPDATE_maxLen\n    distances[(size_t)offset - 2] = maxLen;\n    if (maxLen == lenLimit)\n    {\n      p->son[p->cyclicBufferPos] = curMatch;\n      MOVE_POS_RET;\n    }\n  }\n\n  if (maxLen < 4)\n    maxLen = 4;\n\n  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),\n      distances + offset, maxLen) - (distances));\n  MOVE_POS_RET\n}\n*/\n\nUInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)\n{\n  unsigned offset;\n  GET_MATCHES_HEADER(3)\n  HASH_ZIP_CALC;\n  curMatch = p->hash[hv];\n  p->hash[hv] = p->pos;\n  offset = (unsigned)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),\n      distances, 2) - (distances));\n  MOVE_POS_RET\n}\n\nstatic void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    SKIP_HEADER(2)\n    HASH2_CALC;\n    curMatch = p->hash[hv];\n    p->hash[hv] = p->pos;\n    SKIP_FOOTER\n  }\n  while (--num != 0);\n}\n\nvoid Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    SKIP_HEADER(3)\n    HASH_ZIP_CALC;\n    curMatch = p->hash[hv];\n    p->hash[hv] = p->pos;\n    SKIP_FOOTER\n  }\n  while (--num != 0);\n}\n\nstatic void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    UInt32 h2;\n    UInt32 *hash;\n    SKIP_HEADER(3)\n    HASH3_CALC;\n    hash = p->hash;\n    curMatch = (hash + kFix3HashSize)[hv];\n    hash[h2] =\n    (hash + kFix3HashSize)[hv] = p->pos;\n    SKIP_FOOTER\n  }\n  while (--num != 0);\n}\n\nstatic void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    UInt32 h2, h3;\n    UInt32 *hash;\n    SKIP_HEADER(4)\n    HASH4_CALC;\n    hash = p->hash;\n    curMatch = (hash + kFix4HashSize)[hv];\n    hash                  [h2] =\n    (hash + kFix3HashSize)[h3] =\n    (hash + kFix4HashSize)[hv] = p->pos;\n    SKIP_FOOTER\n  }\n  while (--num != 0);\n}\n\n/*\nstatic void Bt5_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    UInt32 h2, h3, h4;\n    UInt32 *hash;\n    SKIP_HEADER(5)\n    HASH5_CALC;\n    hash = p->hash;\n    curMatch = (hash + kFix5HashSize)[hv];\n    hash                  [h2] =\n    (hash + kFix3HashSize)[h3] =\n    (hash + kFix4HashSize)[h4] =\n    (hash + kFix5HashSize)[hv] = p->pos;\n    SKIP_FOOTER\n  }\n  while (--num != 0);\n}\n*/\n\nstatic void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    UInt32 h2, h3;\n    UInt32 *hash;\n    SKIP_HEADER(4)\n    HASH4_CALC;\n    hash = p->hash;\n    curMatch = (hash + kFix4HashSize)[hv];\n    hash                  [h2] =\n    (hash + kFix3HashSize)[h3] =\n    (hash + kFix4HashSize)[hv] = p->pos;\n    p->son[p->cyclicBufferPos] = curMatch;\n    MOVE_POS\n  }\n  while (--num != 0);\n}\n\n/*\nstatic void Hc5_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    UInt32 h2, h3, h4;\n    UInt32 *hash;\n    SKIP_HEADER(5)\n    HASH5_CALC;\n    hash = p->hash;\n    curMatch = hash + kFix5HashSize)[hv];\n    hash                  [h2] =\n    (hash + kFix3HashSize)[h3] =\n    (hash + kFix4HashSize)[h4] =\n    (hash + kFix5HashSize)[hv] = p->pos;\n    p->son[p->cyclicBufferPos] = curMatch;\n    MOVE_POS\n  }\n  while (--num != 0);\n}\n*/\n\nvoid Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)\n{\n  do\n  {\n    SKIP_HEADER(3)\n    HASH_ZIP_CALC;\n    curMatch = p->hash[hv];\n    p->hash[hv] = p->pos;\n    p->son[p->cyclicBufferPos] = curMatch;\n    MOVE_POS\n  }\n  while (--num != 0);\n}\n\nvoid MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)\n{\n  vTable->Init = (Mf_Init_Func)MatchFinder_Init;\n  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;\n  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;\n  if (!p->btMode)\n  {\n    /* if (p->numHashBytes <= 4) */\n    {\n      vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;\n      vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;\n    }\n    /*\n    else\n    {\n      vTable->GetMatches = (Mf_GetMatches_Func)Hc5_MatchFinder_GetMatches;\n      vTable->Skip = (Mf_Skip_Func)Hc5_MatchFinder_Skip;\n    }\n    */\n  }\n  else if (p->numHashBytes == 2)\n  {\n    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;\n    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;\n  }\n  else if (p->numHashBytes == 3)\n  {\n    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;\n    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;\n  }\n  else /* if (p->numHashBytes == 4) */\n  {\n    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;\n    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;\n  }\n  /*\n  else\n  {\n    vTable->GetMatches = (Mf_GetMatches_Func)Bt5_MatchFinder_GetMatches;\n    vTable->Skip = (Mf_Skip_Func)Bt5_MatchFinder_Skip;\n  }\n  */\n}\n\n\n\n#undef Align\n\n#endif /* LZMA_IMPLEMENTATION */"
        },
        {
          "name": "mus.h",
          "type": "blob",
          "size": 10.25,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nmus.h - v0.1 - Parsing library for MUS music files (as used in DOS games).\n\nDo this:\n    #define MUS_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef mus_h\n#define mus_h\n\n#include <stddef.h>\n\ntypedef struct mus_t mus_t;\n    \nmus_t* mus_create( void const* data, size_t size, void* memctx );\nvoid mus_destroy( mus_t* mus ); \n\ntypedef enum mus_cmd_t {\n    MUS_CMD_RELEASE_NOTE,\n    MUS_CMD_PLAY_NOTE,\n    MUS_CMD_PITCH_BEND,\n    MUS_CMD_SYSTEM_EVENT,\n    MUS_CMD_CONTROLLER,\n    MUS_CMD_END_OF_MEASURE,\n    MUS_CMD_FINISH,\n    MUS_CMD_RENDER_SAMPLES,\n} mus_cmd_t;\n\nstruct mus_cmd_release_note_t {\n    int note;\n};\n\nstruct mus_cmd_play_note_t {\n    int note;\n    int volume;\n};\n\nstruct mus_cmd_pitch_bend_t {\n    int bend_amount;\n};\n\nenum mus_system_event_t {\n    MUS_SYSTEM_EVENT_ALL_SOUNDS_OFF,\n    MUS_SYSTEM_EVENT_ALL_NOTES_OFF,\n    MUS_SYSTEM_EVENT_MONO,\n    MUS_SYSTEM_EVENT_POLY,\n    MUS_SYSTEM_EVENT_RESET_ALL_CONTROLLERS,\n};\n\nstruct mus_cmd_system_event_t {\n    enum mus_system_event_t event;\n};\n\nenum mus_controller_t {\n    MUS_CONTROLLER_CHANGE_INSTRUMENT,\n    MUS_CONTROLLER_BANK_SELECT,\n    MUS_CONTROLLER_MODULATION,\n    MUS_CONTROLLER_VOLUME,\n    MUS_CONTROLLER_PAN,\n    MUS_CONTROLLER_EXPRESSION,\n    MUS_CONTROLLER_REVERB_DEPTH,\n    MUS_CONTROLLER_CHORUS_DEPTH,\n    MUS_CONTROLLER_SUSTAIN_PEDAL,\n    MUS_CONTROLLER_SOFT_PEDAL,\n};\n\nstruct mus_cmd_controller_t {\n    enum mus_controller_t controller;\n    int value;\n};\n\nstruct mus_cmd_render_samples_t {\n    int samples_count;\n};\n\nunion mus_cmd_data_t {\n    struct mus_cmd_release_note_t release_note;\n    struct mus_cmd_play_note_t play_note;\n    struct mus_cmd_pitch_bend_t pitch_bend;\n    struct mus_cmd_system_event_t system_event;\n    struct mus_cmd_controller_t controller;\n    struct mus_cmd_render_samples_t render_samples;\n};\n\ntypedef struct mus_event_t {\n    int channel;\n    enum mus_cmd_t cmd;\n    union mus_cmd_data_t data;\n} mus_event_t;\n\n\nvoid mus_next_event( mus_t* mus, mus_event_t* event );\n\nvoid mus_restart( mus_t* mus );\n\n#endif /* mus_h */\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef MUS_IMPLEMENTATION\n#undef MUS_IMPLEMENTATION\n\n#if !defined( MUS_MALLOC ) || !defined( MUS_FREE )\n    #include <stdlib.h>\n    #define MUS_MALLOC  malloc\n    #define MUS_FREE    free\n#endif\n\nstruct mus_t {\n    int note_volume[ 16 ];\n    int accumulated_delay;\n    int pos;\n    int length;\n    uint8_t data[ 1 ]; // \"open\" array\n};\n\nmus_t* mus_create( void const* data, size_t size, void* memctx ) {\n    (void) memctx, (void) size;\n    uintptr_t ptr = (uintptr_t) data;\n    uint32_t sig = *(uint32_t*) ptr;\n    ptr += 4;\n    if( sig != 0x1a53554d ) { // Identifier \"MUS\" followed by 0x1A\n        return NULL;\n    }\n    int length = *(uint16_t*) ptr;\n    ptr += 2;\n\n    int offset = *(uint16_t*) ptr;\n    ptr += 2;\n\n    if( (size_t)( length + offset ) > size ) {\n        return NULL;\n    }\n\n    mus_t* mus = (mus_t*) MUS_MALLOC( sizeof( mus_t ) + length - 1 );\n    mus->length = length;\n    memcpy( mus->data, (void*)( ((uintptr_t)data) + offset ), length );\n    mus_restart( mus );\n    return mus;\n}\n\n\nvoid mus_destroy( mus_t* mus ) {\n    MUS_FREE( mus );\n}\n\n\nvoid mus_next_event( mus_t* mus, mus_event_t* event ) {\n    if( mus->accumulated_delay ) {\n        int samples_count = ( mus->accumulated_delay * 44100 ) / 140;\n        event->channel = 0;\n        event->cmd = MUS_CMD_RENDER_SAMPLES;\n        event->data.render_samples.samples_count = samples_count;\n        mus->accumulated_delay = 0;\n        return;\n    }\n    while( mus->pos < mus->length ) {\n        uint8_t data = mus->data[ mus->pos++ ];\n        int channel = data & 15;\n        int type = ( data >> 4 ) & 7;\n        int last = ( data >> 7 ) & 1;\n        int event_valid = 0;\n        switch( type ) {\n            case 0: { // Release Note\n                data = mus->data[ mus->pos++ ];\n                int note = data & 127;\n                event->channel = channel;\n                event->cmd = MUS_CMD_RELEASE_NOTE;\n                event->data.release_note.note = note;\n                event_valid = 1;\n            } break;\n\n            case 1: { // Play Note\n                data = mus->data[ mus->pos++ ];\n                int note = data & 127;\n                int has_vol = ( data >> 7 );\n                if( has_vol ) {\n                    data = mus->data[ mus->pos++ ];\n                    mus->note_volume[ channel ] = data;\n                }\n                event->channel = channel;\n                event->cmd = MUS_CMD_PLAY_NOTE;\n                event->data.play_note.note = note;\n                event->data.play_note.volume = mus->note_volume[ channel ];\n                event_valid = 1;\n            } break;\n\n            case 2: { // Pitch Bend\n                data = mus->data[ mus->pos++ ];\n                int bend_amount = data;\n                event->channel = channel;\n                event->cmd = MUS_CMD_PITCH_BEND;\n                event->data.pitch_bend.bend_amount = bend_amount;\n                event_valid = 1;\n            } break;\n\n            case 3: { // System Event\n                data = mus->data[ mus->pos++ ];\n                int sysevent = data & 127;\n                event->channel = channel;\n                event->cmd = MUS_CMD_SYSTEM_EVENT;\n                event->data.system_event.event = (enum mus_system_event_t)sysevent;\n                event_valid = 1;\n            } break;\n\n            case 4: { // Controller\n                data = mus->data[ mus->pos++ ];\n                int controller = data & 127;\n                data = mus->data[ mus->pos++ ];\n                int value = data & 127;\n                event->channel = channel;\n                event->cmd = MUS_CMD_CONTROLLER;\n                event->data.controller.controller = (enum mus_controller_t)controller;\n                event->data.controller.value = value;\n                event_valid = 1;\n            } break;\n\n            case 5: { // End of Measure\n                event->channel = channel;\n                event->cmd = MUS_CMD_END_OF_MEASURE;\n                event_valid = 1;\n            } break;\n\n            case 6: { // Finish\n                event->channel = channel;\n                event->cmd = MUS_CMD_END_OF_MEASURE;\n                event_valid = 1;\n            } break;\n\n            case 7: { // Unused\n                data = mus->data[ mus->pos++ ];\n            } break;\n        }\n\n        if( last ) {\n            int delay = 0;\n            for( ; ; ) {\n                data = mus->data[ mus->pos++ ];\n                delay = delay * 128 + ( data & 127 );\n                if( ( data >> 7 ) == 0 ) {\n                    if( event_valid ) {\n                        mus->accumulated_delay = delay;\n                    } else {\n                        int samples_count = ( delay * 44100 ) / 140;\n                        event->channel = 0;\n                        event->cmd = MUS_CMD_RENDER_SAMPLES;\n                        event->data.render_samples.samples_count = samples_count;\n                        event_valid = 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if( event_valid ) {\n            return;\n        }\n    }\n\n    event->channel = 0;\n    event->cmd = MUS_CMD_FINISH;\n}\n\n\nvoid mus_restart( mus_t* mus ) {\n    mus->accumulated_delay = 0;\n    for( int i = 0; i < sizeof( mus->note_volume ) / sizeof( *mus->note_volume ); ++i ){\n        mus->note_volume[ i ] = 127;\n    }\n    mus->pos = 0;\n}\n\n\n#endif /* MUS_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2021 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "opl.h",
          "type": "blob",
          "size": 119.5283203125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nopl.h - v0.1 - OPL3 (SoundBlaster16) emulation with MIDI compatible interface\n\nDo this:\n    #define OP_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n\n------------------------------------------------------------------------------\n\nThis file contains heavily modified code from two different open source \nprojects: ymfm https://github.com/aaronsgiles/ymfm (a collection of Yamaha FM \nsound cores) and DOSMid http://dosmid.sourceforge.net (a MIDI and MUS player \nfor DOS).\n\nIn the case of the ymfm code, I reduced it down to just the OPL3 parts, and\nrefactored the remaining code from OOP C++ to plain C, and prefixed everything\nwith OPL_EMU_ or opl_emu_.\n\nFor the DOSMidi code, I pretty much used the files OPL.H and OPL.C with only\nminor changes, but put it together with the ymfm code to form a single file\nlibrary.\n\nIt is possible (even likely) that I have messed things up in this process, and\nI recommend that you use the original source code versions linked above if you\nwant to use this for anything serious.\n\n                        / Mattias Gustavsson ( mattias@mattiasgustavsson.com )\n*/\n\n#ifndef opl_h\n#define opl_h\n\ntypedef struct opl_timbre_t {\n  unsigned long modulator_E862, carrier_E862;\n  unsigned char modulator_40, carrier_40;\n  unsigned char feedconn;\n  signed char finetune;\n  unsigned char notenum;\n  signed short noteoffset;\n} opl_timbre_t;\n\ntypedef struct opl_t opl_t;\n\n/* Initialize hardware upon startup - positive on success, negative otherwise\n * Returns 0 for OPL2 initialization, or 1 if OPL3 has been detected */\nopl_t* opl_create( void );\n\n/* close OPL device */\nvoid opl_destroy( opl_t* opl );\n\n/* turns off all notes */\nvoid opl_clear( opl_t* opl );\n\n/* turn note 'on', on emulated MIDI channel */\nvoid opl_midi_noteon( opl_t* opl, int channel, int note, int velocity );\n\n/* turn note 'off', on emulated MIDI channel */\nvoid opl_midi_noteoff( opl_t* opl, int channel, int note );\n\n/* adjust the pitch wheel on emulated MIDI channel */\nvoid opl_midi_pitchwheel( opl_t* opl, int channel, int wheelvalue );\n\n/* emulate MIDI 'controller' messages on the OPL */\nvoid opl_midi_controller( opl_t* opl, int channel, int id, int value );\n\n/* assign a new instrument to emulated MIDI channel */\nvoid opl_midi_changeprog( opl_t* opl, int channel, int program );\n\nvoid opl_loadinstrument(opl_t* opl, int voice, opl_timbre_t* timbre );\n\n/* loads an IBK bank from file into an array of 128 opl_timbre_t structures.\n * returns 0 on success, non-zero otherwise */\nint opl_loadbank_ibk( opl_t* opl, char const* file );\n\nint opl_loadbank_op2(opl_t* opl, void const* data, int size );\n\nvoid opl_render( opl_t* opl, short* sample_pairs, int sample_pairs_count, float volume );\n\nvoid opl_write( opl_t* opl, int count, unsigned short* regs, unsigned char* data );\n\n#endif /* opl_h */\n\n\n\n#ifdef OPL_IMPLEMENTATION\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h> /* calloc() */\n#include <string.h> /* strdup() */\n\n\n//-------------------------------------------------\n//  bitfield - extract a bitfield from the given\n//  value, starting at bit 'start' for a length of\n//  'length' bits\n//-------------------------------------------------\n\nuint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n{\n\treturn (value >> start) & ((1 << length) - 1);\n}\n\n\n//-------------------------------------------------\n//  clamp - clamp between the minimum and maximum\n//  values provided\n//-------------------------------------------------\n\nint32_t opl_emu_clamp(int32_t value, int32_t minval, int32_t maxval)\n{\n\tif (value < minval)\n\t\treturn minval;\n\tif (value > maxval)\n\t\treturn maxval;\n\treturn value;\n}\n\n#define opl_min(a,b) (((a)<(b))?(a):(b))\n#define opl_max(a,b) (((a)>(b))?(a):(b))\n\n\n// various envelope states\nenum opl_emu_envelope_state\n{\n\tOPL_EMU_EG_ATTACK = 1,\n\tOPL_EMU_EG_DECAY = 2,\n\tOPL_EMU_EG_SUSTAIN = 3,\n\tOPL_EMU_EG_RELEASE = 4,\n\tOPL_EMU_EG_STATES = 6\n};\n\n\n\n// three different keyon sources; actual keyon is an OR over all of these\nenum opl_emu_keyon_type\n{\n\tOPL_EMU_KEYON_NORMAL = 0,\n\tOPL_EMU_KEYON_RHYTHM = 1,\n\tOPL_EMU_KEYON_CSM = 2\n};\n\n\n// ======================> opl_emu_opdata_cache\n\n#define OPL_EMU_PHASE_STEP_DYNAMIC 1\n\n// this class holds data that is computed once at the start of clocking\n// and remains static during subsequent sound generation\nstruct opl_emu_opdata_cache\n{\n\t// set phase_step to this value to recalculate it each sample; needed\n\t// in the case of PM LFO changes\n\n\tuint16_t const *waveform;         // base of sine table\n\tuint32_t phase_step;              // phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active\n\tuint32_t total_level;             // total level * 8 + KSL\n\tuint32_t block_freq;              // raw block frequency value (used to compute phase_step)\n\tint32_t detune;                   // detuning value (used to compute phase_step)\n\tuint32_t multiple;                // multiple value (x.1, used to compute phase_step)\n\tuint32_t eg_sustain;              // sustain level, shifted up to envelope values\n\tuint8_t eg_rate[OPL_EMU_EG_STATES];       // envelope rate, including KSR\n\tuint8_t eg_shift;                 // envelope shift amount\n};\n\n\n// ======================> opl_emu_registers\n\n//\n// OPL/OPL2/OPL3/OPL4 register map:\n//\n//      System-wide registers:\n//           01 xxxxxxxx Test register\n//              --x----- Enable OPL compatibility mode [OPL2 only] (1 = enable)\n//           02 xxxxxxxx Timer A value (4 * OPN)\n//           03 xxxxxxxx Timer B value\n//           04 x------- RST\n//              -x------ Mask timer A\n//              --x----- Mask timer B\n//              ------x- Load timer B\n//              -------x Load timer A\n//           08 x------- CSM mode [OPL/OPL2 only]\n//              -x------ Note select\n//           BD x------- AM depth\n//              -x------ PM depth\n//              --x----- Rhythm enable\n//              ---x---- Bass drum key on\n//              ----x--- Snare drum key on\n//              -----x-- Tom key on\n//              ------x- Top cymbal key on\n//              -------x High hat key on\n//          101 --xxxxxx Test register 2 [OPL3 only]\n//          104 --x----- Channel 6 4-operator mode [OPL3 only]\n//              ---x---- Channel 5 4-operator mode [OPL3 only]\n//              ----x--- Channel 4 4-operator mode [OPL3 only]\n//              -----x-- Channel 3 4-operator mode [OPL3 only]\n//              ------x- Channel 2 4-operator mode [OPL3 only]\n//              -------x Channel 1 4-operator mode [OPL3 only]\n//          105 -------x New [OPL3 only]\n//              ------x- New2 [OPL4 only]\n//\n//     Per-channel registers (channel in address bits 0-3)\n//     Note that all these apply to address+100 as well on OPL3+\n//        A0-A8 xxxxxxxx F-number (low 8 bits)\n//        B0-B8 --x----- Key on\n//              ---xxx-- Block (octvate, 0-7)\n//              ------xx F-number (high two bits)\n//        C0-C8 x------- CHD output (to DO0 pin) [OPL3+ only]\n//              -x------ CHC output (to DO0 pin) [OPL3+ only]\n//              --x----- CHB output (mixed right, to DO2 pin) [OPL3+ only]\n//              ---x---- CHA output (mixed left, to DO2 pin) [OPL3+ only]\n//              ----xxx- Feedback level for operator 1 (0-7)\n//              -------x Operator connection algorithm\n//\n//     Per-operator registers (operator in bits 0-5)\n//     Note that all these apply to address+100 as well on OPL3+\n//        20-35 x------- AM enable\n//              -x------ PM enable (VIB)\n//              --x----- EG type\n//              ---x---- Key scale rate\n//              ----xxxx Multiple value (0-15)\n//        40-55 xx------ Key scale level (0-3)\n//              --xxxxxx Total level (0-63)\n//        60-75 xxxx---- Attack rate (0-15)\n//              ----xxxx Decay rate (0-15)\n//        80-95 xxxx---- Sustain level (0-15)\n//              ----xxxx Release rate (0-15)\n//        E0-F5 ------xx Wave select (0-3) [OPL2 only]\n//              -----xxx Wave select (0-7) [OPL3+ only]\n//\n\n// constants\n#define OPL_EMU_REGISTERS_OUTPUTS 2\n#define OPL_EMU_REGISTERS_CHANNELS 18\n#define OPL_EMU_REGISTERS_ALL_CHANNELS ( (1 << OPL_EMU_REGISTERS_CHANNELS) - 1 )\n#define OPL_EMU_REGISTERS_OPERATORS ( OPL_EMU_REGISTERS_CHANNELS * 2 )\n#define OPL_EMU_REGISTERS_WAVEFORMS 8\n#define OPL_EMU_REGISTERS_REGISTERS 0x200\n#define OPL_EMU_REGISTERS_REG_MODE 0x04\n#define OPL_EMU_REGISTERS_DEFAULT_PRESCALE 8\n#define OPL_EMU_REGISTERS_STATUS_BUSY 0\n\n// this value is returned from the write() function for rhythm channels\n#define OPL_EMU_REGISTERS_RHYTHM_CHANNEL 0xff\n\n// this is the size of a full sin waveform\n#define OPL_EMU_REGISTERS_WAVEFORM_LENGTH 0x400\n\nstruct opl_emu_registers\n{\n\t// internal state\n\tuint16_t m_lfo_am_counter;            // LFO AM counter\n\tuint16_t m_lfo_pm_counter;            // LFO PM counter\n\tuint32_t m_noise_lfsr;                // noise LFSR state\n\tuint8_t m_lfo_am;                     // current LFO AM value\n\tuint8_t m_regdata[OPL_EMU_REGISTERS_REGISTERS];         // register data\n\tuint16_t m_waveform[OPL_EMU_REGISTERS_WAVEFORMS][OPL_EMU_REGISTERS_WAVEFORM_LENGTH]; // waveforms\n};\n\n\n// helper to encode four operator numbers into a 32-bit value in the\n// operator maps for each register class\nuint32_t opl_emu_registers_operator_list(uint8_t o1, uint8_t o2, uint8_t o3, uint8_t o4)\n{\n\treturn o1 | (o2 << 8) | (o3 << 16) | (o4 << 24);\n}\n\n// helper to apply KSR to the raw ADSR rate, ignoring ksr if the\n// raw value is 0, and clamping to 63\nuint32_t opl_emu_registers_effective_rate(uint32_t rawrate, uint32_t ksr)\n{\n\treturn (rawrate == 0) ? 0 : opl_min(rawrate + ksr, 63);\n}\n\n\n// constructor\nvoid opl_emu_registers_init( struct opl_emu_registers* regs );\n\n// reset to initial state\nvoid opl_emu_registers_reset(struct opl_emu_registers* regs);\n\n// map channel number to register offset\nuint32_t opl_emu_registers_channel_offset(uint32_t chnum)\n{\n    return (chnum % 9) + 0x100 * (chnum / 9);\n}\n\n// map operator number to register offset\nuint32_t opl_emu_registers_operator_offset(uint32_t opnum)\n{\n    return (opnum % 18) + 2 * ((opnum % 18) / 6) + 0x100 * (opnum / 18);\n}\n\n// return an array of operator indices for each channel\nstruct opl_emu_registers_operator_mapping { uint32_t chan[OPL_EMU_REGISTERS_CHANNELS]; };\nvoid opl_emu_registers_operator_map(struct opl_emu_registers* regs,struct opl_emu_registers_operator_mapping* dest) ;\n\n// handle writes to the register array\nint opl_emu_registers_write(struct opl_emu_registers* regs,uint16_t index, uint8_t data, uint32_t* chan, uint32_t* opmask);\n\n// clock the noise and LFO, if present, returning LFO PM value\nint32_t opl_emu_registers_clock_noise_and_lfo(struct opl_emu_registers* regs);\n\n// reset the LFO\nvoid opl_emu_registers_reset_lfo(struct opl_emu_registers* regs) { regs->m_lfo_am_counter = regs->m_lfo_pm_counter = 0; }\n\n// return the AM offset from LFO for the given channel\n// on OPL this is just a fixed value\nuint32_t opl_emu_registers_lfo_am_offset(struct opl_emu_registers* regs,uint32_t choffs)  { return regs->m_lfo_am; }\n\n// return LFO/noise states\nuint32_t opl_emu_registers_noise_state(struct opl_emu_registers* regs)  { return regs->m_noise_lfsr >> 23; }\n\n// caching helpers\nvoid opl_emu_registers_cache_operator_data(struct opl_emu_registers* regs,uint32_t choffs, uint32_t opoffs, struct opl_emu_opdata_cache *cache);\n\n// compute the phase step, given a PM value\nuint32_t opl_emu_registers_compute_phase_step(struct opl_emu_registers* regs,uint32_t choffs, uint32_t opoffs, struct opl_emu_opdata_cache const *cache, int32_t lfo_raw_pm);\n\n// return a bitfield extracted from a byte\nuint32_t opl_emu_registers_byte(struct opl_emu_registers* regs,uint32_t offset, uint32_t start, uint32_t count, uint32_t extra_offset/* = 0*/) \n{\n\treturn opl_emu_bitfield(regs->m_regdata[offset + extra_offset], start, count);\n}\n\n// return a bitfield extracted from a pair of bytes, MSBs listed first\nuint32_t opl_emu_registers_word(struct opl_emu_registers* regs,uint32_t offset1, uint32_t start1, uint32_t count1, uint32_t offset2, uint32_t start2, uint32_t count2, uint32_t extra_offset/* = 0*/) \n{\n\treturn (opl_emu_registers_byte(regs,offset1, start1, count1, extra_offset) << count2) | opl_emu_registers_byte(regs,offset2, start2, count2, extra_offset);\n}\n\n\n\n// system-wide registers\nuint32_t opl_emu_registers_timer_a_value(struct opl_emu_registers* regs)                    { return opl_emu_registers_byte(regs,0x02, 0, 8, 0) * 4; } // 8->10 bits\nuint32_t opl_emu_registers_timer_b_value(struct opl_emu_registers* regs)                    { return opl_emu_registers_byte(regs,0x03, 0, 8, 0); }\nuint32_t opl_emu_registers_status_mask(struct opl_emu_registers* regs)                      { return opl_emu_registers_byte(regs,0x04, 0, 8, 0) & 0x78; }\nuint32_t opl_emu_registers_note_select(struct opl_emu_registers* regs)                      { return opl_emu_registers_byte(regs,0x08, 6, 1, 0); }\nuint32_t opl_emu_registers_lfo_am_depth(struct opl_emu_registers* regs)                     { return opl_emu_registers_byte(regs,0xbd, 7, 1, 0); }\nuint32_t opl_emu_registers_lfo_pm_depth(struct opl_emu_registers* regs)                     { return opl_emu_registers_byte(regs,0xbd, 6, 1, 0); }\nuint32_t opl_emu_registers_rhythm_enable(struct opl_emu_registers* regs)                    { return opl_emu_registers_byte(regs,0xbd, 5, 1, 0); }\nuint32_t opl_emu_registers_newflag(struct opl_emu_registers* regs)                          { return opl_emu_registers_byte(regs,0x105, 0, 1, 0); }\nuint32_t opl_emu_registers_fourop_enable(struct opl_emu_registers* regs)                    { return opl_emu_registers_byte(regs,0x104, 0, 6, 0); }\n\n// per-channel registers\nuint32_t opl_emu_registers_ch_block_freq(struct opl_emu_registers* regs,uint32_t choffs)     { return opl_emu_registers_word(regs,0xb0, 0, 5, 0xa0, 0, 8, choffs); }\nuint32_t opl_emu_registers_ch_feedback(struct opl_emu_registers* regs,uint32_t choffs)       { return opl_emu_registers_byte(regs,0xc0, 1, 3, choffs); }\nuint32_t opl_emu_registers_ch_algorithm(struct opl_emu_registers* regs,uint32_t choffs)      { return opl_emu_registers_byte(regs,0xc0, 0, 1, choffs) | ((8 | (opl_emu_registers_byte(regs,0xc3, 0, 1, choffs) << 1))); }\nuint32_t opl_emu_registers_ch_output_any(struct opl_emu_registers* regs,uint32_t choffs)     { return opl_emu_registers_newflag(regs) ? opl_emu_registers_byte(regs,0xc0 + choffs, 4, 4, 0) : 1; }\nuint32_t opl_emu_registers_ch_output_0(struct opl_emu_registers* regs,uint32_t choffs)       { return opl_emu_registers_newflag(regs) ? opl_emu_registers_byte(regs,0xc0 + choffs, 4, 1, 0) : 1; }\nuint32_t opl_emu_registers_ch_output_1(struct opl_emu_registers* regs,uint32_t choffs)       { return opl_emu_registers_newflag(regs) ? opl_emu_registers_byte(regs,0xc0 + choffs, 5, 1, 0) : 1; }\nuint32_t opl_emu_registers_ch_output_2(struct opl_emu_registers* regs,uint32_t choffs)       { return opl_emu_registers_newflag(regs) ? opl_emu_registers_byte(regs,0xc0 + choffs, 6, 1, 0) : 0; }\nuint32_t opl_emu_registers_ch_output_3(struct opl_emu_registers* regs,uint32_t choffs)       { return opl_emu_registers_newflag(regs) ? opl_emu_registers_byte(regs,0xc0 + choffs, 7, 1, 0) : 0; }\n\n// per-operator registers\nuint32_t opl_emu_registers_op_lfo_am_enable(struct opl_emu_registers* regs,uint32_t opoffs)  { return opl_emu_registers_byte(regs,0x20, 7, 1, opoffs); }\nuint32_t opl_emu_registers_op_lfo_pm_enable(struct opl_emu_registers* regs,uint32_t opoffs)  { return opl_emu_registers_byte(regs,0x20, 6, 1, opoffs); }\nuint32_t opl_emu_registers_op_eg_sustain(struct opl_emu_registers* regs,uint32_t opoffs)     { return opl_emu_registers_byte(regs,0x20, 5, 1, opoffs); }\nuint32_t opl_emu_registers_op_ksr(struct opl_emu_registers* regs,uint32_t opoffs)            { return opl_emu_registers_byte(regs,0x20, 4, 1, opoffs); }\nuint32_t opl_emu_registers_op_multiple(struct opl_emu_registers* regs,uint32_t opoffs)       { return opl_emu_registers_byte(regs,0x20, 0, 4, opoffs); }\nuint32_t opl_emu_registers_op_ksl(struct opl_emu_registers* regs,uint32_t opoffs)            { uint32_t temp = opl_emu_registers_byte(regs,0x40, 6, 2, opoffs); return opl_emu_bitfield(temp, 1,1) | (opl_emu_bitfield(temp, 0,1) << 1); }\nuint32_t opl_emu_registers_op_total_level(struct opl_emu_registers* regs,uint32_t opoffs)    { return opl_emu_registers_byte(regs,0x40, 0, 6, opoffs); }\nuint32_t opl_emu_registers_op_attack_rate(struct opl_emu_registers* regs,uint32_t opoffs)    { return opl_emu_registers_byte(regs,0x60, 4, 4, opoffs); }\nuint32_t opl_emu_registers_op_decay_rate(struct opl_emu_registers* regs,uint32_t opoffs)     { return opl_emu_registers_byte(regs,0x60, 0, 4, opoffs); }\nuint32_t opl_emu_registers_op_sustain_level(struct opl_emu_registers* regs,uint32_t opoffs)  { return opl_emu_registers_byte(regs,0x80, 4, 4, opoffs); }\nuint32_t opl_emu_registers_op_release_rate(struct opl_emu_registers* regs,uint32_t opoffs)   { return opl_emu_registers_byte(regs,0x80, 0, 4, opoffs); }\nuint32_t opl_emu_registers_op_waveform(struct opl_emu_registers* regs,uint32_t opoffs)       { return opl_emu_registers_byte(regs,0xe0, 0, opl_emu_registers_newflag(regs) ? 3 : 2, opoffs); }\n\n\n// helper to determine if the this channel is an active rhythm channel\nint opl_emu_registers_is_rhythm(struct opl_emu_registers* regs,uint32_t choffs) \n{\n\treturn opl_emu_registers_rhythm_enable(regs) && (choffs >= 6 && choffs <= 8);\n}\n\n// ======================> opl_emu_fm_operator\n\n// \"quiet\" value, used to optimize when we can skip doing working\n#define OPL_EMU_FM_OPERATOR_EG_QUIET 0x200\n\n// opl_emu_fm_operator represents an FM operator (or \"slot\" in FM parlance), which\n// produces an output sine wave modulated by an envelope\nstruct opl_emu_fm_operator\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tuint32_t m_opoffs;                     // operator offset in registers\n\tuint32_t m_phase;                      // current phase value (10.10 format)\n\tuint16_t m_env_attenuation;            // computed envelope attenuation (4.6 format)\n\tenum opl_emu_envelope_state m_env_state;            // current envelope state\n\tuint8_t m_key_state;                   // current key state: on or off (bit 0)\n\tuint8_t m_keyon_live;                  // live key on state (bit 0 = direct, bit 1 = rhythm, bit 2 = CSM)\n\tstruct opl_emu_opdata_cache m_cache;                  // cached values for performance\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};\n\nvoid opl_emu_fm_operator_init(struct opl_emu_fm_operator* fmop, struct opl_emu_registers* regs, uint32_t opoffs);\n\n// reset the operator state\nvoid opl_emu_fm_operator_reset(struct opl_emu_fm_operator* fmop);\n\n// return the operator/channel offset\nuint32_t opl_emu_fm_operator_opoffs(struct opl_emu_fm_operator* fmop)  { return fmop->m_opoffs; }\nuint32_t opl_emu_fm_operator_choffs(struct opl_emu_fm_operator* fmop)  { return fmop->m_choffs; }\n\n// set the current channel\nvoid opl_emu_fm_operator_set_choffs(struct opl_emu_fm_operator* fmop,uint32_t choffs) { fmop->m_choffs = choffs; }\n\n// prepare prior to clocking\nint opl_emu_fm_operator_prepare(struct opl_emu_fm_operator* fmop);\n\n// master clocking function\nvoid opl_emu_fm_operator_clock(struct opl_emu_fm_operator* fmop,uint32_t env_counter, int32_t lfo_raw_pm);\n\n// return the current phase value\nuint32_t opl_emu_fm_operator_phase(struct opl_emu_fm_operator* fmop)  { return fmop->m_phase >> 10; }\n\n// compute operator volume\nint32_t opl_emu_fm_operator_compute_volume(struct opl_emu_fm_operator* fmop,uint32_t phase, uint32_t am_offset) ;\n\n// key state control\nvoid opl_emu_fm_operator_keyonoff(struct opl_emu_fm_operator* fmop,uint32_t on, enum opl_emu_keyon_type type);\n\n// start the attack phase\nvoid opl_emu_fm_operator_start_attack(struct opl_emu_fm_operator* fmop);\n\n// start the release phase\nvoid opl_emu_fm_operator_start_release(struct opl_emu_fm_operator* fmop);\n\n// clock phases\nvoid opl_emu_fm_operator_clock_keystate(struct opl_emu_fm_operator* fmop,uint32_t keystate);\nvoid opl_emu_fm_operator_clock_envelope(struct opl_emu_fm_operator* fmop,uint32_t env_counter);\nvoid opl_emu_fm_operator_clock_phase(struct opl_emu_fm_operator* fmop,int32_t lfo_raw_pm);\n\n// return effective attenuation of the envelope\nuint32_t opl_emu_fm_operator_envelope_attenuation(struct opl_emu_fm_operator* fmop,uint32_t am_offset) ;\n\n\n\n// ======================> opl_emu_fm_channel\n\n// opl_emu_fm_channel represents an FM channel which combines the output of 2 or 4\n// operators into a final result\nstruct opl_emu_fm_channel\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tint16_t m_feedback[2];                 // feedback memory for operator 1\n\tint16_t m_feedback_in;         // next input value for op 1 feedback (set in output)\n\tstruct opl_emu_fm_operator *m_op[4];    // up to 4 operators\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};\n\n\nvoid opl_emu_fm_channel_init(struct opl_emu_fm_channel* fmch,struct opl_emu_registers* regs, uint32_t choffs);\n\n// reset the channel state\nvoid opl_emu_fm_channel_reset(struct opl_emu_fm_channel* fmch);\n\n// return the channel offset\nuint32_t opl_emu_fm_channel_choffs(struct opl_emu_fm_channel* fmch) { return fmch->m_choffs; }\n\n// assign operators\nvoid opl_emu_fm_channel_assign(struct opl_emu_fm_channel* fmch,uint32_t index, struct opl_emu_fm_operator *op)\n{\n\tfmch->m_op[index] = op;\n\tif (op != NULL)\n\t\topl_emu_fm_operator_set_choffs(op, fmch->m_choffs);\n}\n\n// signal key on/off to our operators\nvoid opl_emu_fm_channel_keyonoff(struct opl_emu_fm_channel* fmch,uint32_t states, enum opl_emu_keyon_type type, uint32_t chnum);\n\n// prepare prior to clocking\nint opl_emu_fm_channel_prepare(struct opl_emu_fm_channel* fmch);\n\n// master clocking function\nvoid opl_emu_fm_channel_clock(struct opl_emu_fm_channel* fmch,uint32_t env_counter, int32_t lfo_raw_pm);\n\n// specific 2-operator and 4-operator output handlers\nvoid opl_emu_fm_channel_output_2op(struct opl_emu_fm_channel* fmch,short *output, uint32_t rshift, int32_t clipmax);\nvoid opl_emu_fm_channel_output_4op(struct opl_emu_fm_channel* fmch,short *output, uint32_t rshift, int32_t clipmax);\n\n// compute the special OPL rhythm channel outputs\nvoid opl_emu_fm_channel_output_rhythm_ch6(struct opl_emu_fm_channel* fmch,short *output, uint32_t rshift, int32_t clipmax);\nvoid opl_emu_fm_channel_output_rhythm_ch7(struct opl_emu_fm_channel* fmch,uint32_t phase_select,short *output, uint32_t rshift, int32_t clipmax);\nvoid opl_emu_fm_channel_output_rhythm_ch8(struct opl_emu_fm_channel* fmch,uint32_t phase_select,short *output, uint32_t rshift, int32_t clipmax);\n\n// are we a 4-operator channel or a 2-operator one?\nint opl_emu_fm_channel_is4op( struct opl_emu_fm_channel* fmch )\n{\n    return (fmch->m_op[2] != NULL);\n}\n\n// helper to add values to the outputs based on channel enables\nvoid opl_emu_fm_channel_add_to_output(struct opl_emu_fm_channel* fmch,uint32_t choffs,short* output, int32_t value)\n{\n\t// create these constants to appease overzealous compilers checking array\n\t// bounds in unreachable code (looking at you, clang)\n\tint out0_index = 0;\n\tint out1_index = 1 % OPL_EMU_REGISTERS_OUTPUTS;\n\tint out2_index = 2 % OPL_EMU_REGISTERS_OUTPUTS;\n\tint out3_index = 3 % OPL_EMU_REGISTERS_OUTPUTS;\n\n\tif (OPL_EMU_REGISTERS_OUTPUTS == 1 || opl_emu_registers_ch_output_0(fmch->m_regs, choffs)) {\n        int s = output[out0_index] + value;\n\t\toutput[out0_index] = s < -32767 ? -32767 : s > 32767 ? 32767 : s;\n    }\n\tif (OPL_EMU_REGISTERS_OUTPUTS >= 2 && opl_emu_registers_ch_output_1(fmch->m_regs, choffs)) {\n        int s = output[out1_index] + value;\n\t\toutput[out1_index] = s < -32767 ? -32767 : s > 32767 ? 32767 : s;\n    }\n\t//if (OPL_EMU_REGISTERS_OUTPUTS >= 3 && opl_emu_registers_ch_output_2(fmch->m_regs, choffs))\n\t//\toutput->data[out2_index] += value;\n\t//if (OPL_EMU_REGISTERS_OUTPUTS >= 4 && opl_emu_registers_ch_output_3(fmch->m_regs, choffs))\n\t//\toutput->data[out3_index] += value;\n}\n\n\n\n\n// ======================> ymf262\n\n// ymf262 represents a set of operators and channels which together\n// form a Yamaha FM core; chips that implement other engines (ADPCM, wavetable,\n// etc) take this output and combine it with the others externally\nstruct opl_emu_t\n{\n\tuint32_t m_env_counter;          // envelope counter; low 2 bits are sub-counter\n\tuint8_t m_status;                // current status register\n\tuint8_t m_timer_running[2];      // current timer running state\n\tuint32_t m_active_channels;      // mask of active channels (computed by prepare)\n\tuint32_t m_modified_channels;    // mask of channels that have been modified\n\tuint32_t m_prepare_count;        // counter to do periodic prepare sweeps\n\tstruct opl_emu_registers m_regs;             // register accessor\n\tstruct opl_emu_fm_channel m_channel[OPL_EMU_REGISTERS_CHANNELS]; // channel pointers\n\tstruct opl_emu_fm_operator m_operator[OPL_EMU_REGISTERS_OPERATORS]; // operator pointers\n};\n\n\n\n\n//*********************************************************\n//  YMF262\n//*********************************************************\n\n// set/reset bits in the status register, updating the IRQ status\nuint8_t opl_emu_set_reset_status(struct opl_emu_t* emu, uint8_t set, uint8_t reset)\n{\n\temu->m_status = (emu->m_status | set) & ~(reset | OPL_EMU_REGISTERS_STATUS_BUSY);\n\t//m_intf.opl_emu_sync_check_interrupts();\n\treturn emu->m_status & ~opl_emu_registers_status_mask(&emu->m_regs);\n}\n\nvoid opl_emu_assign_operators( struct opl_emu_t* emu );\nvoid opl_emu_write( struct opl_emu_t* emu, uint16_t regnum, uint8_t data);\n\n//-------------------------------------------------\n//  ymf262 - constructor\n//-------------------------------------------------\n\nvoid opl_emu_init( struct opl_emu_t* emu ) \n{\n\temu->m_env_counter = 0;\n\temu->m_status = 0;\n\temu->m_timer_running[ 0 ] = 0;\n\temu->m_timer_running[ 1 ] = 0;\n\temu->m_active_channels = OPL_EMU_REGISTERS_ALL_CHANNELS;\n\temu->m_modified_channels = OPL_EMU_REGISTERS_ALL_CHANNELS;\n\temu->m_prepare_count = 0;\n\n\topl_emu_registers_init( &emu->m_regs );\n\n\t// create the channels\n\tfor (uint32_t chnum = 0; chnum < OPL_EMU_REGISTERS_CHANNELS; chnum++)\n\t\topl_emu_fm_channel_init(&emu->m_channel[chnum], &emu->m_regs, opl_emu_registers_channel_offset(chnum));\n\n\t// create the operators\n\tfor (uint32_t opnum = 0; opnum < OPL_EMU_REGISTERS_OPERATORS; opnum++)\n\t\topl_emu_fm_operator_init(&emu->m_operator[opnum],&emu->m_regs, opl_emu_registers_operator_offset(opnum));\n\n\t// do the initial operator assignment\n\topl_emu_assign_operators( emu );\n}\n\n\n//-------------------------------------------------\n//  reset - reset the overall state\n//-------------------------------------------------\n\nvoid opl_emu_reset( struct opl_emu_t* emu)\n{\n\t// reset all status bits\n\topl_emu_set_reset_status(emu, 0, 0xff);\n\n\t// register type-specific initialization\n\topl_emu_registers_reset( &emu->m_regs );\n\n\t// explicitly write to the mode register since it has side-effects\n\topl_emu_write(emu, OPL_EMU_REGISTERS_REG_MODE, 0);\n\n\t// reset the channels\n\tfor (int i = 0; i < sizeof( emu->m_channel ) / sizeof( *emu->m_channel ); ++i )\n\t\topl_emu_fm_channel_reset(&emu->m_channel[ i ]);\n\n\t// reset the operators\n\tfor (int i = 0; i < sizeof( emu->m_operator ) / sizeof( *emu->m_operator ); ++i )\n\t\topl_emu_fm_operator_reset(&emu->m_operator[ i ]);\n}\n\n\n//-------------------------------------------------\n//  clock - iterate over all channels, clocking\n//  them forward one step\n//-------------------------------------------------\n\nuint32_t opl_emu_clock( struct opl_emu_t* emu,uint32_t chanmask)\n{\n\t// if something was modified, prepare\n\t// also prepare every 4k samples to catch ending notes\n\tif (emu->m_modified_channels != 0 || emu->m_prepare_count++ >= 4096)\n\t{\n\t\t// reassign operators to channels if dynamic\n        opl_emu_assign_operators(emu);\n\n\t\t// call each channel to prepare\n\t\temu->m_active_channels = 0;\n\t\tfor (uint32_t chnum = 0; chnum < OPL_EMU_REGISTERS_CHANNELS; chnum++)\n\t\t\tif (opl_emu_bitfield(chanmask, chnum,1))\n\t\t\t\tif (opl_emu_fm_channel_prepare(&emu->m_channel[chnum]))\n\t\t\t\t\temu->m_active_channels |= 1 << chnum;\n\n\t\t// reset the modified channels and prepare count\n\t\temu->m_modified_channels = emu->m_prepare_count = 0;\n\t}\n\n\t// if the envelope clock divider is 1, just increment by 4;\n    emu->m_env_counter += 4;\n\n\t// clock the noise generator\n\tint32_t lfo_raw_pm = opl_emu_registers_clock_noise_and_lfo(&emu->m_regs);\n\n\t// now update the state of all the channels and operators\n\tfor (uint32_t chnum = 0; chnum < OPL_EMU_REGISTERS_CHANNELS; chnum++)\n\t\tif (opl_emu_bitfield(chanmask, chnum, 1))\n\t\t\topl_emu_fm_channel_clock(&emu->m_channel[chnum], emu->m_env_counter, lfo_raw_pm);\n\n\n\t// return the envelope counter as it is used to clock ADPCM-A\n\treturn emu->m_env_counter;\n}\n\n\n//-------------------------------------------------\n//  output - compute a sum over the relevant\n//  channels\n//-------------------------------------------------\n\nvoid opl_emu_out( struct opl_emu_t* emu, short* output, uint32_t rshift, int32_t clipmax, uint32_t chanmask)\n{\n\t// mask out inactive channels\n\tchanmask &= emu->m_active_channels;\n\n\t// handle the rhythm case, where some of the operators are dedicated\n\t// to percussion (this is an OPL-specific feature)\n\tif (opl_emu_registers_rhythm_enable(&emu->m_regs))\n\t{\n\t\t// precompute the operator 13+17 phase selection value\n\t\tuint32_t op13phase = opl_emu_fm_operator_phase(&emu->m_operator[13]);\n\t\tuint32_t op17phase = opl_emu_fm_operator_phase(&emu->m_operator[17]);\n\t\tuint32_t phase_select = (opl_emu_bitfield(op13phase, 2, 1) ^ opl_emu_bitfield(op13phase, 7, 1)) | opl_emu_bitfield(op13phase, 3,1) | (opl_emu_bitfield(op17phase, 5,1) ^ opl_emu_bitfield(op17phase, 3,1));\n\n\t\t// sum over all the desired channels\n\t\tfor (uint32_t chnum = 0; chnum < OPL_EMU_REGISTERS_CHANNELS; chnum++)\n\t\t\tif (opl_emu_bitfield(chanmask, chnum,1))\n\t\t\t{\n\t\t\t\tif (chnum == 6)\n\t\t\t\t\topl_emu_fm_channel_output_rhythm_ch6(&emu->m_channel[chnum],output, rshift, clipmax);\n\t\t\t\telse if (chnum == 7)\n\t\t\t\t\topl_emu_fm_channel_output_rhythm_ch7(&emu->m_channel[chnum],phase_select, output, rshift, clipmax);\n\t\t\t\telse if (chnum == 8)\n\t\t\t\t\topl_emu_fm_channel_output_rhythm_ch8(&emu->m_channel[chnum],phase_select, output, rshift, clipmax);\n\t\t\t\telse if (opl_emu_fm_channel_is4op(&emu->m_channel[chnum]))\n\t\t\t\t\topl_emu_fm_channel_output_4op(&emu->m_channel[chnum],output, rshift, clipmax);\n\t\t\t\telse\n\t\t\t\t\topl_emu_fm_channel_output_2op(&emu->m_channel[chnum],output, rshift, clipmax);\n\t\t\t}\n\t}\n\telse\n\t{\n\t\t// sum over all the desired channels\n\t\tfor (uint32_t chnum = 0; chnum < OPL_EMU_REGISTERS_CHANNELS; chnum++)\n\t\t\tif (opl_emu_bitfield(chanmask, chnum,1))\n\t\t\t{\n\t\t\t\tif (opl_emu_fm_channel_is4op(&emu->m_channel[chnum]))\n\t\t\t\t\topl_emu_fm_channel_output_4op(&emu->m_channel[chnum],output, rshift, clipmax);\n\t\t\t\telse\n\t\t\t\t\topl_emu_fm_channel_output_2op(&emu->m_channel[chnum],output, rshift, clipmax);\n\t\t\t}\n\t}\n}\n\n\n//-------------------------------------------------\n//  write - handle writes to the OPN registers\n//-------------------------------------------------\n\nvoid opl_emu_write( struct opl_emu_t* emu, uint16_t regnum, uint8_t data)\n{\n\t// special case: writes to the mode register can impact IRQs;\n\t// schedule these writes to ensure ordering with timers\n\tif (regnum == OPL_EMU_REGISTERS_REG_MODE)\n\t{\n//\t\temu->m_intf.opl_emu_sync_mode_write(data);\n\t\treturn;\n\t}\n\n\t// for now just mark all channels as modified\n\temu->m_modified_channels = OPL_EMU_REGISTERS_ALL_CHANNELS;\n\n\t// most writes are passive, consumed only when needed\n\tuint32_t keyon_channel;\n\tuint32_t keyon_opmask;\n\tif (opl_emu_registers_write(&emu->m_regs,regnum, data, &keyon_channel, &keyon_opmask))\n\t{\n\t\t// handle writes to the keyon register(s)\n\t\tif (keyon_channel < OPL_EMU_REGISTERS_CHANNELS)\n\t\t{\n\t\t\t// normal channel on/off\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[keyon_channel],keyon_opmask, OPL_EMU_KEYON_NORMAL, keyon_channel);\n\t\t}\n\t\telse if (OPL_EMU_REGISTERS_CHANNELS >= 9 && keyon_channel == OPL_EMU_REGISTERS_RHYTHM_CHANNEL)\n\t\t{\n\t\t\t// special case for the OPL rhythm channels\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[6],opl_emu_bitfield(keyon_opmask, 4,1) ? 3 : 0, OPL_EMU_KEYON_RHYTHM, 6);\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[7],opl_emu_bitfield(keyon_opmask, 0,1) | (opl_emu_bitfield(keyon_opmask, 3,1) << 1), OPL_EMU_KEYON_RHYTHM, 7);\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[8],opl_emu_bitfield(keyon_opmask, 2,1) | (opl_emu_bitfield(keyon_opmask, 1,1) << 1), OPL_EMU_KEYON_RHYTHM, 8);\n\t\t}\n\t}\n}\n\n\n//-------------------------------------------------\n//  assign_operators - get the current mapping of\n//  operators to channels and assign them all\n//-------------------------------------------------\n\nvoid opl_emu_assign_operators( struct opl_emu_t* emu)\n{\n\tstruct opl_emu_registers_operator_mapping map;\n\topl_emu_registers_operator_map(&emu->m_regs, &map);\n\n\tfor (uint32_t chnum = 0; chnum < OPL_EMU_REGISTERS_CHANNELS; chnum++)\n\t\tfor (uint32_t index = 0; index < 4; index++)\n\t\t{\n\t\t\tuint32_t opnum = opl_emu_bitfield(map.chan[chnum], 8 * index, 8);\n\t\t\topl_emu_fm_channel_assign(&emu->m_channel[chnum],index, (opnum == 0xff) ? NULL : &emu->m_operator[opnum]);\n\t\t}\n}\n\n\n//-------------------------------------------------\n//  update_timer - update the state of the given\n//  timer\n//-------------------------------------------------\n\nvoid opl_emu_update_timer( struct opl_emu_t* emu, uint32_t tnum, uint32_t enable)\n{\n\t// if the timer is live, but not currently enabled, set the timer\n\tif (enable && !emu->m_timer_running[tnum])\n\t{\n\t\t// period comes from the registers, and is different for each\n\t\tuint32_t period = (tnum == 0) ? (1024 - opl_emu_registers_timer_a_value(&emu->m_regs)) : 16 * (256 - opl_emu_registers_timer_b_value(&emu->m_regs));\n\n\t\t// reset it\n\t\t//emu->m_intf.opl_emu_set_timer(tnum, period * OPERATORS * emu->m_clock_prescale);\n\t\temu->m_timer_running[tnum] = 1;\n\t}\n\n\t// if the timer is not live, ensure it is not enabled\n\telse if (!enable)\n\t{\n\t\t//emu->m_intf.opl_emu_set_timer(tnum, -1);\n\t\temu->m_timer_running[tnum] = 0;\n\t}\n}\n\n\n//-------------------------------------------------\n//  generate - generate samples of sound\n//-------------------------------------------------\n\nvoid opl_emu_generate( struct opl_emu_t* emu,short *output, uint32_t numsamples, float volume )\n{\n\tvolume = volume > 1.0f ? 1.0f : volume < 0.0f ? 0.0f : volume;\n\tfor (uint32_t samp = 0; samp < numsamples; samp++, output+=2)\n\t{\n\t\t// clock the system\n\t\topl_emu_clock(emu, OPL_EMU_REGISTERS_ALL_CHANNELS);\n\n\t\t// update the FM content; mixing details for YMF262 need verification\n\t\topl_emu_out(emu, output, 0, 32767, OPL_EMU_REGISTERS_ALL_CHANNELS);\n        \n        *output = (short)((*output) * volume);\n        *(output + 1) = (short)((*(output + 1)) * volume);\n\t}\n}\n\n\n\n//-------------------------------------------------\n//  opl_emu_opl_key_scale_atten - converts an\n//  OPL concatenated block (3 bits) and fnum\n//  (10 bits) into an attenuation offset; values\n//  here are for 6dB/octave, in 0.75dB units\n//  (matching total level LSB)\n//-------------------------------------------------\n\nuint32_t opl_emu_opl_key_scale_atten(uint32_t block, uint32_t fnum_4msb)\n{\n\t// this table uses the top 4 bits of FNUM and are the maximal values\n\t// (for when block == 7). Values for other blocks can be computed by\n\t// subtracting 8 for each block below 7.\n\tstatic uint8_t const fnum_to_atten[16] = { 0,24,32,37,40,43,45,47,48,50,51,52,53,54,55,56 };\n\tint32_t result = fnum_to_atten[fnum_4msb] - 8 * (block ^ 7);\n\treturn opl_max(0, result);\n}\n\n\n\n//*********************************************************\n//  GLOBAL TABLE LOOKUPS\n//*********************************************************\n\n//-------------------------------------------------\n//  opl_emu_abs_sin_attenuation - given a sin (phase) input\n//  where the range 0-2*PI is mapped onto 10 bits,\n//  return the absolute value of sin(input),\n//  logarithmically-adjusted and treated as an\n//  attenuation value, in 4.8 fixed point format\n//-------------------------------------------------\n\nuint32_t opl_emu_abs_sin_attenuation(uint32_t input)\n{\n\t// the values here are stored as 4.8 logarithmic values for 1/4 phase\n\t// this matches the internal format of the OPN chip, extracted from the die\n\tstatic uint16_t const s_sin_table[256] =\n\t{\n\t\t0x859,0x6c3,0x607,0x58b,0x52e,0x4e4,0x4a6,0x471,0x443,0x41a,0x3f5,0x3d3,0x3b5,0x398,0x37e,0x365,\n\t\t0x34e,0x339,0x324,0x311,0x2ff,0x2ed,0x2dc,0x2cd,0x2bd,0x2af,0x2a0,0x293,0x286,0x279,0x26d,0x261,\n\t\t0x256,0x24b,0x240,0x236,0x22c,0x222,0x218,0x20f,0x206,0x1fd,0x1f5,0x1ec,0x1e4,0x1dc,0x1d4,0x1cd,\n\t\t0x1c5,0x1be,0x1b7,0x1b0,0x1a9,0x1a2,0x19b,0x195,0x18f,0x188,0x182,0x17c,0x177,0x171,0x16b,0x166,\n\t\t0x160,0x15b,0x155,0x150,0x14b,0x146,0x141,0x13c,0x137,0x133,0x12e,0x129,0x125,0x121,0x11c,0x118,\n\t\t0x114,0x10f,0x10b,0x107,0x103,0x0ff,0x0fb,0x0f8,0x0f4,0x0f0,0x0ec,0x0e9,0x0e5,0x0e2,0x0de,0x0db,\n\t\t0x0d7,0x0d4,0x0d1,0x0cd,0x0ca,0x0c7,0x0c4,0x0c1,0x0be,0x0bb,0x0b8,0x0b5,0x0b2,0x0af,0x0ac,0x0a9,\n\t\t0x0a7,0x0a4,0x0a1,0x09f,0x09c,0x099,0x097,0x094,0x092,0x08f,0x08d,0x08a,0x088,0x086,0x083,0x081,\n\t\t0x07f,0x07d,0x07a,0x078,0x076,0x074,0x072,0x070,0x06e,0x06c,0x06a,0x068,0x066,0x064,0x062,0x060,\n\t\t0x05e,0x05c,0x05b,0x059,0x057,0x055,0x053,0x052,0x050,0x04e,0x04d,0x04b,0x04a,0x048,0x046,0x045,\n\t\t0x043,0x042,0x040,0x03f,0x03e,0x03c,0x03b,0x039,0x038,0x037,0x035,0x034,0x033,0x031,0x030,0x02f,\n\t\t0x02e,0x02d,0x02b,0x02a,0x029,0x028,0x027,0x026,0x025,0x024,0x023,0x022,0x021,0x020,0x01f,0x01e,\n\t\t0x01d,0x01c,0x01b,0x01a,0x019,0x018,0x017,0x017,0x016,0x015,0x014,0x014,0x013,0x012,0x011,0x011,\n\t\t0x010,0x00f,0x00f,0x00e,0x00d,0x00d,0x00c,0x00c,0x00b,0x00a,0x00a,0x009,0x009,0x008,0x008,0x007,\n\t\t0x007,0x007,0x006,0x006,0x005,0x005,0x005,0x004,0x004,0x004,0x003,0x003,0x003,0x002,0x002,0x002,\n\t\t0x002,0x001,0x001,0x001,0x001,0x001,0x001,0x001,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000\n\t};\n\n\t// if the top bit is set, we're in the second half of the curve\n\t// which is a mirror image, so invert the index\n\tif (opl_emu_bitfield(input, 8,1))\n\t\tinput = ~input;\n\n\t// return the value from the table\n\treturn s_sin_table[input & 0xff];\n}\n\n\n//-------------------------------------------------\n//  opl_emu_attenuation_to_volume - given a 5.8 fixed point\n//  logarithmic attenuation value, return a 13-bit\n//  linear volume\n//-------------------------------------------------\n\nuint32_t opl_emu_attenuation_to_volume(uint32_t input)\n{\n\t// the values here are 10-bit mantissas with an implied leading bit\n\t// this matches the internal format of the OPN chip, extracted from the die\n\n\t// as a nod to performance, the implicit 0x400 bit is pre-incorporated, and\n\t// the values are left-shifted by 2 so that a simple right shift is all that\n\t// is needed; also the order is reversed to save a NOT on the input\n#define X(a) (((a) | 0x400) << 2)\n\tstatic uint16_t const s_power_table[256] =\n\t{\n\t\tX(0x3fa),X(0x3f5),X(0x3ef),X(0x3ea),X(0x3e4),X(0x3df),X(0x3da),X(0x3d4),\n\t\tX(0x3cf),X(0x3c9),X(0x3c4),X(0x3bf),X(0x3b9),X(0x3b4),X(0x3ae),X(0x3a9),\n\t\tX(0x3a4),X(0x39f),X(0x399),X(0x394),X(0x38f),X(0x38a),X(0x384),X(0x37f),\n\t\tX(0x37a),X(0x375),X(0x370),X(0x36a),X(0x365),X(0x360),X(0x35b),X(0x356),\n\t\tX(0x351),X(0x34c),X(0x347),X(0x342),X(0x33d),X(0x338),X(0x333),X(0x32e),\n\t\tX(0x329),X(0x324),X(0x31f),X(0x31a),X(0x315),X(0x310),X(0x30b),X(0x306),\n\t\tX(0x302),X(0x2fd),X(0x2f8),X(0x2f3),X(0x2ee),X(0x2e9),X(0x2e5),X(0x2e0),\n\t\tX(0x2db),X(0x2d6),X(0x2d2),X(0x2cd),X(0x2c8),X(0x2c4),X(0x2bf),X(0x2ba),\n\t\tX(0x2b5),X(0x2b1),X(0x2ac),X(0x2a8),X(0x2a3),X(0x29e),X(0x29a),X(0x295),\n\t\tX(0x291),X(0x28c),X(0x288),X(0x283),X(0x27f),X(0x27a),X(0x276),X(0x271),\n\t\tX(0x26d),X(0x268),X(0x264),X(0x25f),X(0x25b),X(0x257),X(0x252),X(0x24e),\n\t\tX(0x249),X(0x245),X(0x241),X(0x23c),X(0x238),X(0x234),X(0x230),X(0x22b),\n\t\tX(0x227),X(0x223),X(0x21e),X(0x21a),X(0x216),X(0x212),X(0x20e),X(0x209),\n\t\tX(0x205),X(0x201),X(0x1fd),X(0x1f9),X(0x1f5),X(0x1f0),X(0x1ec),X(0x1e8),\n\t\tX(0x1e4),X(0x1e0),X(0x1dc),X(0x1d8),X(0x1d4),X(0x1d0),X(0x1cc),X(0x1c8),\n\t\tX(0x1c4),X(0x1c0),X(0x1bc),X(0x1b8),X(0x1b4),X(0x1b0),X(0x1ac),X(0x1a8),\n\t\tX(0x1a4),X(0x1a0),X(0x19c),X(0x199),X(0x195),X(0x191),X(0x18d),X(0x189),\n\t\tX(0x185),X(0x181),X(0x17e),X(0x17a),X(0x176),X(0x172),X(0x16f),X(0x16b),\n\t\tX(0x167),X(0x163),X(0x160),X(0x15c),X(0x158),X(0x154),X(0x151),X(0x14d),\n\t\tX(0x149),X(0x146),X(0x142),X(0x13e),X(0x13b),X(0x137),X(0x134),X(0x130),\n\t\tX(0x12c),X(0x129),X(0x125),X(0x122),X(0x11e),X(0x11b),X(0x117),X(0x114),\n\t\tX(0x110),X(0x10c),X(0x109),X(0x106),X(0x102),X(0x0ff),X(0x0fb),X(0x0f8),\n\t\tX(0x0f4),X(0x0f1),X(0x0ed),X(0x0ea),X(0x0e7),X(0x0e3),X(0x0e0),X(0x0dc),\n\t\tX(0x0d9),X(0x0d6),X(0x0d2),X(0x0cf),X(0x0cc),X(0x0c8),X(0x0c5),X(0x0c2),\n\t\tX(0x0be),X(0x0bb),X(0x0b8),X(0x0b5),X(0x0b1),X(0x0ae),X(0x0ab),X(0x0a8),\n\t\tX(0x0a4),X(0x0a1),X(0x09e),X(0x09b),X(0x098),X(0x094),X(0x091),X(0x08e),\n\t\tX(0x08b),X(0x088),X(0x085),X(0x082),X(0x07e),X(0x07b),X(0x078),X(0x075),\n\t\tX(0x072),X(0x06f),X(0x06c),X(0x069),X(0x066),X(0x063),X(0x060),X(0x05d),\n\t\tX(0x05a),X(0x057),X(0x054),X(0x051),X(0x04e),X(0x04b),X(0x048),X(0x045),\n\t\tX(0x042),X(0x03f),X(0x03c),X(0x039),X(0x036),X(0x033),X(0x030),X(0x02d),\n\t\tX(0x02a),X(0x028),X(0x025),X(0x022),X(0x01f),X(0x01c),X(0x019),X(0x016),\n\t\tX(0x014),X(0x011),X(0x00e),X(0x00b),X(0x008),X(0x006),X(0x003),X(0x000)\n\t};\n#undef X\n\n\t// look up the fractional part, then shift by the whole\n\treturn s_power_table[input & 0xff] >> (input >> 8);\n}\n\n\n\n//-------------------------------------------------\n//  opl_emu_attenuation_increment - given a 6-bit ADSR\n//  rate value and a 3-bit stepping index,\n//  return a 4-bit increment to the attenutaion\n//  for this step (or for the attack case, the\n//  fractional scale factor to decrease by)\n//-------------------------------------------------\n\nuint32_t opl_emu_attenuation_increment(uint32_t rate, uint32_t index)\n{\n\tstatic uint32_t const s_increment_table[64] =\n\t{\n\t\t0x00000000, 0x00000000, 0x10101010, 0x10101010,  // 0-3    (0x00-0x03)\n\t\t0x10101010, 0x10101010, 0x11101110, 0x11101110,  // 4-7    (0x04-0x07)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 8-11   (0x08-0x0B)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 12-15  (0x0C-0x0F)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 16-19  (0x10-0x13)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 20-23  (0x14-0x17)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 24-27  (0x18-0x1B)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 28-31  (0x1C-0x1F)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 32-35  (0x20-0x23)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 36-39  (0x24-0x27)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 40-43  (0x28-0x2B)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 44-47  (0x2C-0x2F)\n\t\t0x11111111, 0x21112111, 0x21212121, 0x22212221,  // 48-51  (0x30-0x33)\n\t\t0x22222222, 0x42224222, 0x42424242, 0x44424442,  // 52-55  (0x34-0x37)\n\t\t0x44444444, 0x84448444, 0x84848484, 0x88848884,  // 56-59  (0x38-0x3B)\n\t\t0x88888888, 0x88888888, 0x88888888, 0x88888888   // 60-63  (0x3C-0x3F)\n\t};\n\treturn opl_emu_bitfield(s_increment_table[rate], 4*index, 4);\n}\n\n\n//*********************************************************\n//  OPL REGISTERS\n//*********************************************************\n\n//-------------------------------------------------\n//  opl_emu_registers - constructor\n//-------------------------------------------------\n\nvoid opl_emu_registers_init(struct opl_emu_registers* regs) \n{\n\tregs->m_lfo_am_counter = 0;\n\tregs->m_lfo_pm_counter = 0;\n\tregs->m_noise_lfsr = 1;\n\tregs->m_lfo_am = 0;\n\n\t// create these pointers to appease overzealous compilers checking array\n\t// bounds in unreachable code (looking at you, clang)\n\tuint16_t *wf0 = &regs->m_waveform[0][0];\n\tuint16_t *wf1 = &regs->m_waveform[1 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\tuint16_t *wf2 = &regs->m_waveform[2 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\tuint16_t *wf3 = &regs->m_waveform[3 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\tuint16_t *wf4 = &regs->m_waveform[4 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\tuint16_t *wf5 = &regs->m_waveform[5 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\tuint16_t *wf6 = &regs->m_waveform[6 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\tuint16_t *wf7 = &regs->m_waveform[7 % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\n\t// create the waveforms\n\tfor (uint32_t index = 0; index < OPL_EMU_REGISTERS_WAVEFORM_LENGTH; index++)\n\t\twf0[index] = opl_emu_abs_sin_attenuation(index) | (opl_emu_bitfield(index, 9,1) << 15);\n\n\tif (OPL_EMU_REGISTERS_WAVEFORMS >= 4)\n\t{\n\t\tuint16_t zeroval = wf0[0];\n\t\tfor (uint32_t index = 0; index < OPL_EMU_REGISTERS_WAVEFORM_LENGTH; index++)\n\t\t{\n\t\t\twf1[index] = opl_emu_bitfield(index, 9,1) ? zeroval : wf0[index];\n\t\t\twf2[index] = wf0[index] & 0x7fff;\n\t\t\twf3[index] = opl_emu_bitfield(index, 8,1) ? zeroval : (wf0[index] & 0x7fff);\n\t\t\tif (OPL_EMU_REGISTERS_WAVEFORMS >= 8)\n\t\t\t{\n\t\t\t\twf4[index] = opl_emu_bitfield(index, 9,1) ? zeroval : wf0[index * 2];\n\t\t\t\twf5[index] = opl_emu_bitfield(index, 9,1) ? zeroval : wf0[(index * 2) & 0x1ff];\n\t\t\t\twf6[index] = opl_emu_bitfield(index, 9,1) << 15;\n\t\t\t\twf7[index] = (opl_emu_bitfield(index, 9,1) ? (index ^ 0x13ff) : index) << 3;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//-------------------------------------------------\n//  reset - reset to initial state\n//-------------------------------------------------\n\nvoid opl_emu_registers_reset(struct opl_emu_registers* regs)\n{\n    for( int i = 0; i < OPL_EMU_REGISTERS_REGISTERS; ++i )\n        regs->m_regdata[ i ] = 0;\n}\n\n\n//-------------------------------------------------\n//  opl_emu_registers_operator_map - return an array of operator\n//  indices for each channel; for OPL this is fixed\n//-------------------------------------------------\n\nvoid opl_emu_registers_operator_map(struct opl_emu_registers* regs, struct opl_emu_registers_operator_mapping* dest)\n{\n    // OPL3/OPL4 can be configured for 2 or 4 operators\n    uint32_t fourop = opl_emu_registers_fourop_enable(regs);\n\n    dest->chan[ 0] = opl_emu_bitfield(fourop, 0,1) ? opl_emu_registers_operator_list(  0,  3,  6,  9 ) : opl_emu_registers_operator_list(  0,  3, 0xff, 0xff );\n    dest->chan[ 1] = opl_emu_bitfield(fourop, 1,1) ? opl_emu_registers_operator_list(  1,  4,  7, 10 ) : opl_emu_registers_operator_list(  1,  4, 0xff, 0xff );\n    dest->chan[ 2] = opl_emu_bitfield(fourop, 2,1) ? opl_emu_registers_operator_list(  2,  5,  8, 11 ) : opl_emu_registers_operator_list(  2,  5, 0xff, 0xff );\n    dest->chan[ 3] = opl_emu_bitfield(fourop, 0,1) ? opl_emu_registers_operator_list( 0xff, 0xff, 0xff, 0xff) : opl_emu_registers_operator_list(  6,  9, 0xff, 0xff );\n    dest->chan[ 4] = opl_emu_bitfield(fourop, 1,1) ? opl_emu_registers_operator_list( 0xff, 0xff, 0xff, 0xff) : opl_emu_registers_operator_list(  7, 10, 0xff, 0xff );\n    dest->chan[ 5] = opl_emu_bitfield(fourop, 2,1) ? opl_emu_registers_operator_list( 0xff, 0xff, 0xff, 0xff) : opl_emu_registers_operator_list(  8, 11, 0xff, 0xff );\n    dest->chan[ 6] = opl_emu_registers_operator_list( 12, 15, 0xff, 0xff );\n    dest->chan[ 7] = opl_emu_registers_operator_list( 13, 16, 0xff, 0xff );\n    dest->chan[ 8] = opl_emu_registers_operator_list( 14, 17, 0xff, 0xff );\n\n    dest->chan[ 9] = opl_emu_bitfield(fourop, 3,1) ? opl_emu_registers_operator_list( 18, 21, 24, 27 ) : opl_emu_registers_operator_list( 18, 21, 0xff, 0xff );\n    dest->chan[10] = opl_emu_bitfield(fourop, 4,1) ? opl_emu_registers_operator_list( 19, 22, 25, 28 ) : opl_emu_registers_operator_list( 19, 22, 0xff, 0xff );\n    dest->chan[11] = opl_emu_bitfield(fourop, 5,1) ? opl_emu_registers_operator_list( 20, 23, 26, 29 ) : opl_emu_registers_operator_list( 20, 23, 0xff, 0xff );\n    dest->chan[12] = opl_emu_bitfield(fourop, 3,1) ? opl_emu_registers_operator_list(0xff, 0xff, 0xff, 0xff) : opl_emu_registers_operator_list( 24, 27, 0xff, 0xff );\n    dest->chan[13] = opl_emu_bitfield(fourop, 4,1) ? opl_emu_registers_operator_list(0xff, 0xff, 0xff, 0xff) : opl_emu_registers_operator_list( 25, 28, 0xff, 0xff );\n    dest->chan[14] = opl_emu_bitfield(fourop, 5,1) ? opl_emu_registers_operator_list(0xff, 0xff, 0xff, 0xff) : opl_emu_registers_operator_list( 26, 29, 0xff, 0xff );\n    dest->chan[15] = opl_emu_registers_operator_list( 30, 33, 0xff, 0xff );\n    dest->chan[16] = opl_emu_registers_operator_list( 31, 34, 0xff, 0xff );\n    dest->chan[17] = opl_emu_registers_operator_list( 32, 35, 0xff, 0xff );\n}\n\n\n//-------------------------------------------------\n//  write - handle writes to the register array\n//-------------------------------------------------\n\nint opl_emu_registers_write(struct opl_emu_registers* regs,uint16_t index, uint8_t data, uint32_t *channel, uint32_t *opmask)\n{\n\t// writes to the mode register with high bit set ignore the low bits\n\tif (index == OPL_EMU_REGISTERS_REG_MODE && opl_emu_bitfield(data, 7,1) != 0)\n\t\tregs->m_regdata[index] |= 0x80;\n\telse\n\t\tregs->m_regdata[index] = data;\n\n\t// handle writes to the rhythm keyons\n\tif (index == 0xbd)\n\t{\n\t\t*channel = OPL_EMU_REGISTERS_RHYTHM_CHANNEL;\n\t\t*opmask = opl_emu_bitfield(data, 5,1) ? opl_emu_bitfield(data, 0, 5) : 0;\n\t\treturn 1;\n\t}\n\n\t// handle writes to the channel keyons\n\tif ((index & 0xf0) == 0xb0)\n\t{\n\t\t*channel = index & 0x0f;\n\t\tif (*channel < 9)\n\t\t{\n            *channel += 9 * opl_emu_bitfield(index, 8,1);\n\t\t\t*opmask = opl_emu_bitfield(data, 5,1) ? 15 : 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n//-------------------------------------------------\n//  clock_noise_and_lfo - clock the noise and LFO,\n//  handling clock division, depth, and waveform\n//  computations\n//-------------------------------------------------\n\nstatic int32_t opl_emu_opl_clock_noise_and_lfo(uint32_t *noise_lfsr, uint16_t *lfo_am_counter, uint16_t *lfo_pm_counter, uint8_t *lfo_am, uint32_t am_depth, uint32_t pm_depth)\n{\n\t// OPL has a 23-bit noise generator for the rhythm section, running at\n\t// a constant rate, used only for percussion input\n\t*noise_lfsr <<= 1;\n\t*noise_lfsr |= opl_emu_bitfield(*noise_lfsr, 23,1) ^ opl_emu_bitfield(*noise_lfsr, 9,1) ^ opl_emu_bitfield(*noise_lfsr, 8,1) ^ opl_emu_bitfield(*noise_lfsr, 1,1);\n\n\t// OPL has two fixed-frequency LFOs, one for AM, one for PM\n\n\t// the AM LFO has 210*64 steps; at a nominal 50kHz output,\n\t// this equates to a period of 50000/(210*64) = 3.72Hz\n\tuint32_t am_counter = *lfo_am_counter++;\n\tif (am_counter >= 210*64 - 1)\n\t\t*lfo_am_counter = 0;\n\n\t// low 8 bits are fractional; depth 0 is divided by 2, while depth 1 is times 2\n\tint shift = 9 - 2 * am_depth;\n\n\t// AM value is the upper bits of the value, inverted across the midpoint\n\t// to produce a triangle\n\t*lfo_am = ((am_counter < 105*64) ? am_counter : (210*64+63 - am_counter)) >> shift;\n\n\t// the PM LFO has 8192 steps, or a nominal period of 6.1Hz\n\tuint32_t pm_counter = *lfo_pm_counter++;\n\n\t// PM LFO is broken into 8 chunks, each lasting 1024 steps; the PM value\n\t// depends on the upper bits of FNUM, so this value is a fraction and\n\t// sign to apply to that value, as a 1.3 value\n\tstatic int8_t pm_scale[8] = { 8, 4, 0, -4, -8, -4, 0, 4 };\n\treturn pm_scale[opl_emu_bitfield(pm_counter, 10, 3)] >> (pm_depth ^ 1);\n}\n\nint32_t opl_emu_registers_clock_noise_and_lfo(struct opl_emu_registers* regs)\n{\n\treturn opl_emu_opl_clock_noise_and_lfo(&regs->m_noise_lfsr, &regs->m_lfo_am_counter, &regs->m_lfo_pm_counter, &regs->m_lfo_am, opl_emu_registers_lfo_am_depth(regs), opl_emu_registers_lfo_pm_depth(regs));\n}\n\n\n//-------------------------------------------------\n//  cache_operator_data - fill the operator cache\n//  with prefetched data; note that this code is\n//  also used by ymopna_registers, so it must\n//  handle upper channels cleanly\n//-------------------------------------------------\n\nvoid opl_emu_registers_cache_operator_data(struct opl_emu_registers* regs,uint32_t choffs, uint32_t opoffs, struct opl_emu_opdata_cache *cache)\n{\n\t// set up the easy stuff\n\tcache->waveform = &regs->m_waveform[opl_emu_registers_op_waveform(regs, opoffs) % OPL_EMU_REGISTERS_WAVEFORMS][0];\n\n\t// get frequency from the channel\n\tuint32_t block_freq = cache->block_freq = opl_emu_registers_ch_block_freq(regs,choffs);\n\n\t// compute the keycode: block_freq is:\n\t//\n\t//     111  |\n\t//     21098|76543210\n\t//     BBBFF|FFFFFFFF\n\t//     ^^^??\n\t//\n\t// the 4-bit keycode uses the top 3 bits plus one of the next two bits\n\tuint32_t keycode = opl_emu_bitfield(block_freq, 10, 3) << 1;\n\n\t// lowest bit is determined by note_select(); note that it is\n\t// actually reversed from what the manual says, however\n\tkeycode |= opl_emu_bitfield(block_freq, 9 - opl_emu_registers_note_select(regs), 1);\n\n\t// no detune adjustment on OPL\n\tcache->detune = 0;\n\n\t// multiple value, as an x.1 value (0 means 0.5)\n\t// replace the low bit with a table lookup to give 0,1,2,3,4,5,6,7,8,9,10,10,12,12,15,15\n\tuint32_t multiple = opl_emu_registers_op_multiple(regs,opoffs);\n\tcache->multiple = ((multiple & 0xe) | opl_emu_bitfield(0xc2aa, multiple,1)) * 2;\n\tif (cache->multiple == 0)\n\t\tcache->multiple = 1;\n\n\t// phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active; this depends on block_freq, detune,\n\t// and multiple, so compute it after we've done those\n\tif (opl_emu_registers_op_lfo_pm_enable(regs,opoffs) == 0)\n\t\tcache->phase_step = opl_emu_registers_compute_phase_step(regs,choffs, opoffs, cache, 0);\n\telse\n\t\tcache->phase_step = OPL_EMU_PHASE_STEP_DYNAMIC;\n\n\t// total level, scaled by 8\n\tcache->total_level = opl_emu_registers_op_total_level(regs,opoffs) << 3;\n\n\t// pre-add key scale level\n\tuint32_t ksl = opl_emu_registers_op_ksl(regs,opoffs);\n\tif (ksl != 0)\n\t\tcache->total_level += opl_emu_opl_key_scale_atten(opl_emu_bitfield(block_freq, 10, 3), opl_emu_bitfield(block_freq, 6, 4)) << ksl;\n\n\t// 4-bit sustain level, but 15 means 31 so effectively 5 bits\n\tcache->eg_sustain = opl_emu_registers_op_sustain_level(regs,opoffs);\n\tcache->eg_sustain |= (cache->eg_sustain + 1) & 0x10;\n\tcache->eg_sustain <<= 5;\n\n\t// determine KSR adjustment for enevlope rates\n\tuint32_t ksrval = keycode >> (2 * (opl_emu_registers_op_ksr(regs,opoffs) ^ 1));\n\tcache->eg_rate[OPL_EMU_EG_ATTACK] = opl_emu_registers_effective_rate(opl_emu_registers_op_attack_rate(regs,opoffs) * 4, ksrval);\n\tcache->eg_rate[OPL_EMU_EG_DECAY] = opl_emu_registers_effective_rate(opl_emu_registers_op_decay_rate(regs,opoffs) * 4, ksrval);\n\tcache->eg_rate[OPL_EMU_EG_SUSTAIN] = opl_emu_registers_op_eg_sustain(regs,opoffs) ? 0 : opl_emu_registers_effective_rate(opl_emu_registers_op_release_rate(regs,opoffs) * 4, ksrval);\n\tcache->eg_rate[OPL_EMU_EG_RELEASE] = opl_emu_registers_effective_rate(opl_emu_registers_op_release_rate(regs,opoffs) * 4, ksrval);\n}\n\n\n//-------------------------------------------------\n//  compute_phase_step - compute the phase step\n//-------------------------------------------------\n\nstatic uint32_t opl_emu_opl_compute_phase_step(uint32_t block_freq, uint32_t multiple, int32_t lfo_raw_pm)\n{\n\t// OPL phase calculation has no detuning, but uses FNUMs like\n\t// the OPN version, and computes PM a bit differently\n\n\t// extract frequency number as a 12-bit fraction\n\tuint32_t fnum = opl_emu_bitfield(block_freq, 0, 10) << 2;\n\n\t// apply the phase adjustment based on the upper 3 bits\n\t// of FNUM and the PM depth parameters\n\tfnum += (lfo_raw_pm * opl_emu_bitfield(block_freq, 7, 3)) >> 1;\n\n\t// keep fnum to 12 bits\n\tfnum &= 0xfff;\n\n\t// apply block shift to compute phase step\n\tuint32_t block = opl_emu_bitfield(block_freq, 10, 3);\n\tuint32_t phase_step = (fnum << block) >> 2;\n\n\t// apply frequency multiplier (which is cached as an x.1 value)\n\treturn (phase_step * multiple) >> 1;\n}\n\nuint32_t opl_emu_registers_compute_phase_step(struct opl_emu_registers* regs,uint32_t choffs, uint32_t opoffs, struct opl_emu_opdata_cache const *cache, int32_t lfo_raw_pm)\n{\n\treturn opl_emu_opl_compute_phase_step(cache->block_freq, cache->multiple, opl_emu_registers_op_lfo_pm_enable(regs,opoffs) ? lfo_raw_pm : 0);\n}\n\n\n\n//*********************************************************\n//  FM OPERATOR\n//*********************************************************\n\n//-------------------------------------------------\n//  opl_emu_fm_operator - constructor\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_init(struct opl_emu_fm_operator* fmop, struct opl_emu_registers* regs, uint32_t opoffs) {\n\tfmop->m_choffs = 0;\n\tfmop->m_opoffs = opoffs;\n\tfmop->m_phase = 0;\n\tfmop->m_env_attenuation = 0x3ff;\n\tfmop->m_env_state = OPL_EMU_EG_RELEASE;\n\tfmop->m_key_state = 0;\n\tfmop->m_keyon_live = 0;\n\tfmop->m_regs = regs;\n\tfmop->m_cache.eg_shift = 0;\n}\n\n\n//-------------------------------------------------\n//  reset - reset the channel state\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_reset(struct opl_emu_fm_operator* fmop)\n{\n\t// reset our data\n\tfmop->m_phase = 0;\n\tfmop->m_env_attenuation = 0x3ff;\n\tfmop->m_env_state = OPL_EMU_EG_RELEASE;\n\tfmop->m_key_state = 0;\n\tfmop->m_keyon_live = 0;\n}\n\n//-------------------------------------------------\n//  prepare - prepare for clocking\n//-------------------------------------------------\n\nint opl_emu_fm_operator_prepare(struct opl_emu_fm_operator* fmop)\n{\n\t// cache the data\n\topl_emu_registers_cache_operator_data(fmop->m_regs,fmop->m_choffs, fmop->m_opoffs, &fmop->m_cache);\n\n\t// clock the key state\n\topl_emu_fm_operator_clock_keystate(fmop,(uint32_t)(fmop->m_keyon_live != 0));\n\tfmop->m_keyon_live &= ~(1 << OPL_EMU_KEYON_CSM);\n\n\t// we're active until we're quiet after the release\n\treturn (fmop->m_env_state != OPL_EMU_EG_RELEASE || fmop->m_env_attenuation < OPL_EMU_FM_OPERATOR_EG_QUIET);\n}\n\n\n//-------------------------------------------------\n//  clock - master clocking function\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_clock(struct opl_emu_fm_operator* fmop, uint32_t env_counter, int32_t lfo_raw_pm)\n{\n\t// clock the envelope if on an envelope cycle; env_counter is a x.2 value\n\tif (opl_emu_bitfield(env_counter, 0, 2) == 0)\n\t\topl_emu_fm_operator_clock_envelope(fmop,env_counter >> 2);\n\n\t// clock the phase\n\topl_emu_fm_operator_clock_phase(fmop,lfo_raw_pm);\n}\n\n\n//-------------------------------------------------\n//  compute_volume - compute the 14-bit signed\n//  volume of this operator, given a phase\n//  modulation and an AM LFO offset\n//-------------------------------------------------\n\nint32_t opl_emu_fm_operator_compute_volume(struct opl_emu_fm_operator* fmop, uint32_t phase, uint32_t am_offset)\n{\n\t// the low 10 bits of phase represents a full 2*PI period over\n\t// the full sin wave\n\n\t// early out if the envelope is effectively off\n\tif (fmop->m_env_attenuation > OPL_EMU_FM_OPERATOR_EG_QUIET)\n\t\treturn 0;\n\n\t// get the absolute value of the sin, as attenuation, as a 4.8 fixed point value\n\tuint32_t sin_attenuation = fmop->m_cache.waveform[phase & (OPL_EMU_REGISTERS_WAVEFORM_LENGTH - 1)];\n\n\t// get the attenuation from the evelope generator as a 4.6 value, shifted up to 4.8\n\tuint32_t env_attenuation = opl_emu_fm_operator_envelope_attenuation(fmop, am_offset) << 2;\n\n\t// combine into a 5.8 value, then convert from attenuation to 13-bit linear volume\n\tint32_t result = opl_emu_attenuation_to_volume((sin_attenuation & 0x7fff) + env_attenuation);\n\n\t// negate if in the negative part of the sin wave (sign bit gives 14 bits)\n\treturn opl_emu_bitfield(sin_attenuation, 15,1) ? -result : result;\n}\n\n\n//-------------------------------------------------\n//  keyonoff - signal a key on/off event\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_keyonoff(struct opl_emu_fm_operator* fmop, uint32_t on, enum opl_emu_keyon_type type)\n{\n\tfmop->m_keyon_live = (fmop->m_keyon_live & ~(1 << (int)(type))) | (opl_emu_bitfield(on, 0,1) << (int)(type));\n}\n\n\n//-------------------------------------------------\n//  start_attack - start the attack phase; called\n//  when a keyon happens \n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_start_attack(struct opl_emu_fm_operator* fmop)\n{\n\t// don't change anything if already in attack state\n\tif (fmop->m_env_state == OPL_EMU_EG_ATTACK)\n\t\treturn;\n\tfmop->m_env_state = OPL_EMU_EG_ATTACK;\n\n\t// reset the phase when we start an attack due to a key on\n    fmop->m_phase = 0;\n\n\t// if the attack rate >= 62 then immediately go to max attenuation\n\tif (fmop->m_cache.eg_rate[OPL_EMU_EG_ATTACK] >= 62)\n\t\tfmop->m_env_attenuation = 0;\n}\n\n\n//-------------------------------------------------\n//  start_release - start the release phase;\n//  called when a keyoff happens\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_start_release(struct opl_emu_fm_operator* fmop)\n{\n\t// don't change anything if already in release state\n\tif (fmop->m_env_state >= OPL_EMU_EG_RELEASE)\n\t\treturn;\n\tfmop->m_env_state = OPL_EMU_EG_RELEASE;\n}\n\n\n//-------------------------------------------------\n//  clock_keystate - clock the keystate to match\n//  the incoming keystate\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_clock_keystate(struct opl_emu_fm_operator* fmop, uint32_t keystate)\n{\n\t// has the key changed?\n\tif ((keystate ^ fmop->m_key_state) != 0)\n\t{\n\t\tfmop->m_key_state = keystate;\n\n\t\t// if the key has turned on, start the attack\n\t\tif (keystate != 0)\n\t\t{\n            opl_emu_fm_operator_start_attack(fmop);\n\t\t}\n\n\t\t// otherwise, start the release\n\t\telse\n\t\t\topl_emu_fm_operator_start_release(fmop);\n\t}\n}\n\n\n//-------------------------------------------------\n//  clock_envelope - clock the envelope state\n//  according to the given count\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_clock_envelope(struct opl_emu_fm_operator* fmop, uint32_t env_counter)\n{\n\t// handle attack->decay transitions\n\tif (fmop->m_env_state == OPL_EMU_EG_ATTACK && fmop->m_env_attenuation == 0)\n\t\tfmop->m_env_state = OPL_EMU_EG_DECAY;\n\n\t// handle decay->sustain transitions; it is important to do this immediately\n\t// after the attack->decay transition above in the event that the sustain level\n\t// is set to 0 (in which case we will skip right to sustain without doing any\n\t// decay); as an example where this can be heard, check the cymbals sound\n\t// in channel 0 of shinobi's test mode sound #5\n\tif (fmop->m_env_state == OPL_EMU_EG_DECAY && fmop->m_env_attenuation >= fmop->m_cache.eg_sustain)\n\t\tfmop->m_env_state = OPL_EMU_EG_SUSTAIN;\n\n\t// fetch the appropriate 6-bit rate value from the cache\n\tuint32_t rate = fmop->m_cache.eg_rate[fmop->m_env_state];\n\n\t// compute the rate shift value; this is the shift needed to\n\t// apply to the env_counter such that it becomes a 5.11 fixed\n\t// point number\n\tuint32_t rate_shift = rate >> 2;\n\tenv_counter <<= rate_shift;\n\n\t// see if the fractional part is 0; if not, it's not time to clock\n\tif (opl_emu_bitfield(env_counter, 0, 11) != 0)\n\t\treturn;\n\n\t// determine the increment based on the non-fractional part of env_counter\n\tuint32_t relevant_bits = opl_emu_bitfield(env_counter, (rate_shift <= 11) ? 11 : rate_shift, 3);\n\tuint32_t increment = opl_emu_attenuation_increment(rate, relevant_bits);\n\n\t// attack is the only one that increases\n\tif (fmop->m_env_state == OPL_EMU_EG_ATTACK)\n\t{\n\t\t// glitch means that attack rates of 62/63 don't increment if\n\t\t// changed after the initial key on (where they are handled\n\t\t// specially); nukeykt confirms this happens on OPM, OPN, OPL/OPLL\n\t\t// at least so assuming it is true for everyone\n\t\tif (rate < 62)\n\t\t\tfmop->m_env_attenuation += (~fmop->m_env_attenuation * increment) >> 4;\n\t}\n\n\t// all other cases are similar\n\telse\n\t{\n\t\t// non-SSG-EG cases just apply the increment\n        fmop->m_env_attenuation += increment;\n\n\t\t// clamp the final attenuation\n\t\tif (fmop->m_env_attenuation >= 0x400)\n\t\t\tfmop->m_env_attenuation = 0x3ff;\n\t}\n}\n\n\n//-------------------------------------------------\n//  clock_phase - clock the 10.10 phase value; the\n//  OPN version of the logic has been verified\n//  against the Nuked phase generator\n//-------------------------------------------------\n\nvoid opl_emu_fm_operator_clock_phase(struct opl_emu_fm_operator* fmop, int32_t lfo_raw_pm)\n{\n\t// read from the cache, or recalculate if PM active\n\tuint32_t phase_step = fmop->m_cache.phase_step;\n\tif (phase_step == OPL_EMU_PHASE_STEP_DYNAMIC)\n\t\tphase_step = opl_emu_registers_compute_phase_step(fmop->m_regs,fmop->m_choffs, fmop->m_opoffs, &fmop->m_cache, lfo_raw_pm);\n\n\t// finally apply the step to the current phase value\n\tfmop->m_phase += phase_step;\n}\n\n\n//-------------------------------------------------\n//  envelope_attenuation - return the effective\n//  attenuation of the envelope\n//-------------------------------------------------\n\nuint32_t opl_emu_fm_operator_envelope_attenuation(struct opl_emu_fm_operator* fmop, uint32_t am_offset)\n{\n\tuint32_t result = fmop->m_env_attenuation >> fmop->m_cache.eg_shift;\n\n\t// add in LFO AM modulation\n\tif (opl_emu_registers_op_lfo_am_enable(fmop->m_regs,fmop->m_opoffs))\n\t\tresult += am_offset;\n\n\t// add in total level and KSL from the cache\n\tresult += fmop->m_cache.total_level;\n\n\t// clamp to max, apply shift, and return\n\treturn opl_min(result, 0x3ff);\n}\n\n\n\n//*********************************************************\n//  FM CHANNEL\n//*********************************************************\n\n//-------------------------------------------------\n//  opl_emu_fm_channel - constructor\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_init(struct opl_emu_fm_channel* fmch,struct opl_emu_registers* regs, uint32_t choffs) {\n\tfmch->m_choffs = choffs;\n\tfmch->m_feedback[ 0 ] = 0;\n    fmch->m_feedback[ 1 ] = 0;\n\tfmch->m_feedback_in = 0;\n\tfmch->m_op[ 0 ] = NULL;\n\tfmch->m_op[ 1 ] = NULL;\n\tfmch->m_op[ 2 ] = NULL;\n\tfmch->m_op[ 3 ] = NULL;\n\tfmch->m_regs = regs;\n}\n\n\n//-------------------------------------------------\n//  reset - reset the channel state\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_reset(struct opl_emu_fm_channel* fmch)\n{\n\t// reset our data\n\tfmch->m_feedback[0] = fmch->m_feedback[1] = 0;\n\tfmch->m_feedback_in = 0;\n}\n\n//-------------------------------------------------\n//  keyonoff - signal key on/off to our operators\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_keyonoff(struct opl_emu_fm_channel* fmch,uint32_t states, enum opl_emu_keyon_type type, uint32_t chnum)\n{\n\tfor (uint32_t opnum = 0; opnum < sizeof( fmch->m_op ) / sizeof( *fmch->m_op ); opnum++)\n\t\tif (fmch->m_op[opnum] != NULL)\n\t\t\topl_emu_fm_operator_keyonoff(fmch->m_op[opnum],opl_emu_bitfield(states, opnum,1), type);\n}\n\n\n//-------------------------------------------------\n//  prepare - prepare for clocking\n//-------------------------------------------------\n\nint opl_emu_fm_channel_prepare(struct opl_emu_fm_channel* fmch)\n{\n\tuint32_t active_mask = 0;\n\n\t// prepare all operators and determine if they are active\n\tfor (uint32_t opnum = 0; opnum < sizeof( fmch->m_op ) / sizeof( *fmch->m_op ); opnum++)\n\t\tif (fmch->m_op[opnum] != NULL)\n\t\t\tif (opl_emu_fm_operator_prepare(fmch->m_op[opnum]))\n\t\t\t\tactive_mask |= 1 << opnum;\n\n\treturn (active_mask != 0);\n}\n\n\n//-------------------------------------------------\n//  clock - master clock of all operators\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_clock(struct opl_emu_fm_channel* fmch,uint32_t env_counter, int32_t lfo_raw_pm)\n{\n\t// clock the feedback through\n\tfmch->m_feedback[0] = fmch->m_feedback[1];\n\tfmch->m_feedback[1] = fmch->m_feedback_in;\n\n\tfor (uint32_t opnum = 0; opnum < sizeof( fmch->m_op ) / sizeof( *fmch->m_op ); opnum++)\n\t\tif (fmch->m_op[opnum] != NULL)\n\t\t\topl_emu_fm_operator_clock(fmch->m_op[opnum],env_counter, lfo_raw_pm);\n}\n\n\n//-------------------------------------------------\n//  output_2op - combine 4 operators according to\n//  the specified algorithm, returning a sum\n//  according to the rshift and clipmax parameters,\n//  which vary between different implementations\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_output_2op(struct opl_emu_fm_channel* fmch,short *output, uint32_t rshift, int32_t clipmax)\n{\n\t// The first 2 operators should be populated\n\t// AM amount is the same across all operators; compute it once\n\tuint32_t am_offset = opl_emu_registers_lfo_am_offset(fmch->m_regs,fmch->m_choffs);\n\n\t// operator 1 has optional self-feedback\n\tint32_t opmod = 0;\n\tuint32_t feedback = opl_emu_registers_ch_feedback(fmch->m_regs,fmch->m_choffs);\n\tif (feedback != 0)\n\t\topmod = (fmch->m_feedback[0] + fmch->m_feedback[1]) >> (10 - feedback);\n\n\t// compute the 14-bit volume/value of operator 1 and update the feedback\n\tint32_t op1value = fmch->m_feedback_in = opl_emu_fm_operator_compute_volume(fmch->m_op[0], opl_emu_fm_operator_phase(fmch->m_op[0]) + opmod, am_offset);\n\n\t// now that the feedback has been computed, skip the rest if all volumes\n\t// are clear; no need to do all this work for nothing\n\tif (opl_emu_registers_ch_output_any(fmch->m_regs,fmch->m_choffs) == 0)\n\t\treturn;\n\n\t// Algorithms for two-operator case:\n\t//    0: O1 -> O2 -> out\n\t//    1: (O1 + O2) -> out\n\tint32_t result;\n\tif (opl_emu_bitfield(opl_emu_registers_ch_algorithm(fmch->m_regs,fmch->m_choffs), 0,1) == 0)\n\t{\n\t\t// some OPL chips use the previous sample for modulation instead of\n\t\t// the current sample\n\t\topmod = op1value >> 1;\n\t\tresult = opl_emu_fm_operator_compute_volume(fmch->m_op[1], opl_emu_fm_operator_phase(fmch->m_op[1]) + opmod, am_offset) >> rshift;\n\t}\n\telse\n\t{\n\t\tresult = op1value + (opl_emu_fm_operator_compute_volume(fmch->m_op[1], opl_emu_fm_operator_phase(fmch->m_op[1]), am_offset) >> rshift);\n\t\tint32_t clipmin = -clipmax - 1;\n\t\tresult = opl_emu_clamp(result, clipmin, clipmax);\n\t}\n\n\t// add to the output\n\topl_emu_fm_channel_add_to_output(fmch,fmch->m_choffs, output, result);\n}\n\n\n//-------------------------------------------------\n//  output_4op - combine 4 operators according to\n//  the specified algorithm, returning a sum\n//  according to the rshift and clipmax parameters,\n//  which vary between different implementations\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_output_4op(struct opl_emu_fm_channel* fmch,short *output, uint32_t rshift, int32_t clipmax)\n{\n\t// AM amount is the same across all operators; compute it once\n\tuint32_t am_offset = opl_emu_registers_lfo_am_offset(fmch->m_regs,fmch->m_choffs);\n\n\t// operator 1 has optional self-feedback\n\tint32_t opmod = 0;\n\tuint32_t feedback = opl_emu_registers_ch_feedback(fmch->m_regs,fmch->m_choffs);\n\tif (feedback != 0)\n\t\topmod = (fmch->m_feedback[0] + fmch->m_feedback[1]) >> (10 - feedback);\n\n\t// compute the 14-bit volume/value of operator 1 and update the feedback\n\tint32_t op1value = fmch->m_feedback_in = opl_emu_fm_operator_compute_volume(fmch->m_op[0], opl_emu_fm_operator_phase(fmch->m_op[0]) + opmod, am_offset);\n\n\t// now that the feedback has been computed, skip the rest if all volumes\n\t// are clear; no need to do all this work for nothing\n\tif (opl_emu_registers_ch_output_any(fmch->m_regs,fmch->m_choffs) == 0)\n\t\treturn;\n\n\t// OPM/OPN offer 8 different connection algorithms for 4 operators,\n\t// and OPL3 offers 4 more, which we designate here as 8-11.\n\t//\n\t// The operators are computed in order, with the inputs pulled from\n\t// an array of values (opout) that is populated as we go:\n\t//    0 = 0\n\t//    1 = O1\n\t//    2 = O2\n\t//    3 = O3\n\t//    4 = (O4)\n\t//    5 = O1+O2\n\t//    6 = O1+O3\n\t//    7 = O2+O3\n\t//\n\t// The s_algorithm_ops table describes the inputs and outputs of each\n\t// algorithm as follows:\n\t//\n\t//      ---------x use opout[x] as operator 2 input\n\t//      ------xxx- use opout[x] as operator 3 input\n\t//      ---xxx---- use opout[x] as operator 4 input\n\t//      --x------- include opout[1] in final sum\n\t//      -x-------- include opout[2] in final sum\n\t//      x--------- include opout[3] in final sum\n\t#define ALGORITHM(op2in, op3in, op4in, op1out, op2out, op3out) \\\n\t\t((op2in) | ((op3in) << 1) | ((op4in) << 4) | ((op1out) << 7) | ((op2out) << 8) | ((op3out) << 9))\n\tstatic uint16_t const s_algorithm_ops[8+4] =\n\t{\n\t\tALGORITHM(1,2,3, 0,0,0),    //  0: O1 -> O2 -> O3 -> O4 -> out (O4)\n\t\tALGORITHM(0,5,3, 0,0,0),    //  1: (O1 + O2) -> O3 -> O4 -> out (O4)\n\t\tALGORITHM(0,2,6, 0,0,0),    //  2: (O1 + (O2 -> O3)) -> O4 -> out (O4)\n\t\tALGORITHM(1,0,7, 0,0,0),    //  3: ((O1 -> O2) + O3) -> O4 -> out (O4)\n\t\tALGORITHM(1,0,3, 0,1,0),    //  4: ((O1 -> O2) + (O3 -> O4)) -> out (O2+O4)\n\t\tALGORITHM(1,1,1, 0,1,1),    //  5: ((O1 -> O2) + (O1 -> O3) + (O1 -> O4)) -> out (O2+O3+O4)\n\t\tALGORITHM(1,0,0, 0,1,1),    //  6: ((O1 -> O2) + O3 + O4) -> out (O2+O3+O4)\n\t\tALGORITHM(0,0,0, 1,1,1),    //  7: (O1 + O2 + O3 + O4) -> out (O1+O2+O3+O4)\n\t\tALGORITHM(1,2,3, 0,0,0),    //  8: O1 -> O2 -> O3 -> O4 -> out (O4)         [same as 0]\n\t\tALGORITHM(0,2,3, 1,0,0),    //  9: (O1 + (O2 -> O3 -> O4)) -> out (O1+O4)   [unique]\n\t\tALGORITHM(1,0,3, 0,1,0),    // 10: ((O1 -> O2) + (O3 -> O4)) -> out (O2+O4) [same as 4]\n\t\tALGORITHM(0,2,0, 1,0,1)     // 11: (O1 + (O2 -> O3) + O4) -> out (O1+O3+O4) [unique]\n\t};\n\tuint32_t algorithm_ops = s_algorithm_ops[opl_emu_registers_ch_algorithm(fmch->m_regs,fmch->m_choffs)];\n\n\t// populate the opout table\n\tint16_t opout[8];\n\topout[0] = 0;\n\topout[1] = op1value;\n\n\t// compute the 14-bit volume/value of operator 2\n\topmod = opout[opl_emu_bitfield(algorithm_ops, 0, 1)] >> 1;\n\topout[2] = opl_emu_fm_operator_compute_volume(fmch->m_op[1], opl_emu_fm_operator_phase(fmch->m_op[1]) + opmod, am_offset);\n\topout[5] = opout[1] + opout[2];\n\n\t// compute the 14-bit volume/value of operator 3\n\topmod = opout[opl_emu_bitfield(algorithm_ops, 1, 3)] >> 1;\n\topout[3] = opl_emu_fm_operator_compute_volume(fmch->m_op[2], opl_emu_fm_operator_phase(fmch->m_op[2]) + opmod, am_offset);\n\topout[6] = opout[1] + opout[3];\n\topout[7] = opout[2] + opout[3];\n\n\t// compute the 14-bit volume/value of operator 4; this could be a noise\n\t// value on the OPM; all algorithms consume OP4 output at a minimum\n    opmod = opout[opl_emu_bitfield(algorithm_ops, 4, 3)] >> 1;\n    int32_t result = opl_emu_fm_operator_compute_volume(fmch->m_op[3], opl_emu_fm_operator_phase(fmch->m_op[3]) + opmod, am_offset);\n\t\n\tresult >>= rshift;\n\n\t// optionally add OP1, OP2, OP3\n\tint32_t clipmin = -clipmax - 1;\n\tif (opl_emu_bitfield(algorithm_ops, 7,1) != 0)\n\t\tresult = opl_emu_clamp(result + (opout[1] >> rshift), clipmin, clipmax);\n\tif (opl_emu_bitfield(algorithm_ops, 8,1) != 0)\n\t\tresult = opl_emu_clamp(result + (opout[2] >> rshift), clipmin, clipmax);\n\tif (opl_emu_bitfield(algorithm_ops, 9,1) != 0)\n\t\tresult = opl_emu_clamp(result + (opout[3] >> rshift), clipmin, clipmax);\n\n\t// add to the output\n\topl_emu_fm_channel_add_to_output(fmch,fmch->m_choffs, output, result);\n}\n\n\n//-------------------------------------------------\n//  output_rhythm_ch6 - special case output\n//  computation for OPL channel 6 in rhythm mode,\n//  which outputs a Bass Drum instrument\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_output_rhythm_ch6(struct opl_emu_fm_channel* fmch,short *output, uint32_t rshift, int32_t clipmax)\n{\n\t// AM amount is the same across all operators; compute it once\n\tuint32_t am_offset = opl_emu_registers_lfo_am_offset(fmch->m_regs,fmch->m_choffs);\n\n\t// Bass Drum: this uses operators 12 and 15 (i.e., channel 6)\n\t// in an almost-normal way, except that if the algorithm is 1,\n\t// the first operator is ignored instead of added in\n\n\t// operator 1 has optional self-feedback\n\tint32_t opmod = 0;\n\tuint32_t feedback = opl_emu_registers_ch_feedback(fmch->m_regs,fmch->m_choffs);\n\tif (feedback != 0)\n\t\topmod = (fmch->m_feedback[0] + fmch->m_feedback[1]) >> (10 - feedback);\n\n\t// compute the 14-bit volume/value of operator 1 and update the feedback\n\tint32_t opout1 = fmch->m_feedback_in = opl_emu_fm_operator_compute_volume(fmch->m_op[0], opl_emu_fm_operator_phase(fmch->m_op[0]) + opmod, am_offset);\n\n\t// compute the 14-bit volume/value of operator 2, which is the result\n\topmod = opl_emu_bitfield(opl_emu_registers_ch_algorithm(fmch->m_regs,fmch->m_choffs), 0,1) ? 0 : (opout1 >> 1);\n\tint32_t result = opl_emu_fm_operator_compute_volume(fmch->m_op[1], opl_emu_fm_operator_phase(fmch->m_op[1]) + opmod, am_offset) >> rshift;\n\n\t// add to the output\n\topl_emu_fm_channel_add_to_output(fmch, fmch->m_choffs, output, result * 2);\n}\n\n\n//-------------------------------------------------\n//  output_rhythm_ch7 - special case output\n//  computation for OPL channel 7 in rhythm mode,\n//  which outputs High Hat and Snare Drum\n//  instruments\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_output_rhythm_ch7(struct opl_emu_fm_channel* fmch,uint32_t phase_select,short *output, uint32_t rshift, int32_t clipmax)\n{\n\t// AM amount is the same across all operators; compute it once\n\tuint32_t am_offset = opl_emu_registers_lfo_am_offset(fmch->m_regs,fmch->m_choffs);\n\tuint32_t noise_state = opl_emu_bitfield(opl_emu_registers_noise_state(fmch->m_regs), 0,1);\n\n\t// High Hat: this uses the envelope from operator 13 (channel 7),\n\t// and a combination of noise and the operator 13/17 phase select\n\t// to compute the phase\n\tuint32_t phase = (phase_select << 9) | (0xd0 >> (2 * (noise_state ^ phase_select)));\n\tint32_t result = opl_emu_fm_operator_compute_volume(fmch->m_op[0], phase, am_offset) >> rshift;\n\n\t// Snare Drum: this uses the envelope from operator 16 (channel 7),\n\t// and a combination of noise and operator 13 phase to pick a phase\n\tuint32_t op13phase = opl_emu_fm_operator_phase(fmch->m_op[0]);\n\tphase = (0x100 << opl_emu_bitfield(op13phase, 8,1)) ^ (noise_state << 8);\n\tresult += opl_emu_fm_operator_compute_volume(fmch->m_op[1],phase, am_offset) >> rshift;\n\tresult = opl_emu_clamp(result, -clipmax - 1, clipmax);\n\n\t// add to the output\n\topl_emu_fm_channel_add_to_output(fmch, fmch->m_choffs, output, result * 2);\n}\n\n\n//-------------------------------------------------\n//  output_rhythm_ch8 - special case output\n//  computation for OPL channel 8 in rhythm mode,\n//  which outputs Tom Tom and Top Cymbal instruments\n//-------------------------------------------------\n\nvoid opl_emu_fm_channel_output_rhythm_ch8(struct opl_emu_fm_channel* fmch,uint32_t phase_select,short *output, uint32_t rshift, int32_t clipmax)\n{\n\t// AM amount is the same across all operators; compute it once\n\tuint32_t am_offset = opl_emu_registers_lfo_am_offset(fmch->m_regs,fmch->m_choffs);\n\n\t// Tom Tom: this is just a single operator processed normally\n\tint32_t result = opl_emu_fm_operator_compute_volume(fmch->m_op[0], opl_emu_fm_operator_phase(fmch->m_op[0]), am_offset) >> rshift;\n\n\t// Top Cymbal: this uses the envelope from operator 17 (channel 8),\n\t// and the operator 13/17 phase select to compute the phase\n\tuint32_t phase = 0x100 | (phase_select << 9);\n\tresult += opl_emu_fm_operator_compute_volume(fmch->m_op[1], phase, am_offset) >> rshift;\n\tresult = opl_emu_clamp(result, -clipmax - 1, clipmax);\n\n\t// add to the output\n\topl_emu_fm_channel_add_to_output(fmch, fmch->m_choffs, output, result * 2);\n}\n\n\n// This is the number subtracted from the 2nd voice for an instrument for OP2 soundbanks\n// which causes those second voices to be replaced before their (more important) first voices\n// when the OPL voice channels are all used up\n#define OP2_2NDVOICE_PRIORITY_PENALTY 0xFF\n\nstruct voicealloc_t {\n  unsigned short priority;\n  signed short timbreid;\n  signed char channel;\n  signed char note;\n  unsigned char voiceindex; /* 1 if 2nd voice for OP2 soundbank instrument, 0 otherwise */\n};\n\nenum op2_flags_t {\n  OP2_FIXEDPITCH = 1,\n  OP2_UNUSED = 2, /* technically delayed vibrato https://moddingwiki.shikadi.net/wiki/OP2_Bank_Format */\n  OP2_DOUBLEVOICE = 4,\n};\n\nstruct opl_t {\n  signed char notes2voices[16][128][2]; /* keeps the map of channel:notes -> voice allocations */\n  unsigned short channelpitch[16];      /* per-channel pitch level */\n  unsigned short channelvol[16];        /* per-channel pitch level */\n  struct voicealloc_t voices2notes[18]; /* keeps the map of what voice is playing what note/channel currently */\n  unsigned char channelprog[16];        /* programs (patches) assigned to channels */\n  int opl3; /* flag indicating whether or not the sound module is OPL3-compatible or only OPL2 */\n  struct opl_emu_t opl_emu;\n  struct opl_timbre_t opl_gmtimbres[ 256 ];\n  struct opl_timbre_t opl_gmtimbres_voice2[ 256 ]; /* second voice included in OP2 format */\n  int is_op2; /* true if OP2 soundbank */\n  enum op2_flags_t op2_flags[ 256 ]; /* OP2 format flags */\n};\n\n\nvoid oplregwr( opl_t* opl, uint16_t reg, uint8_t data ) {\n    opl_emu_write( &opl->opl_emu, reg, data );\n}\n\n\nvoid opl_render( opl_t* opl, short* sample_pairs, int sample_pairs_count, float volume ) {\n    memset( sample_pairs, 0, sample_pairs_count * 2 * sizeof( short ) );\n    opl_emu_generate( &opl->opl_emu, sample_pairs, sample_pairs_count, volume );\n}\n\n\nvoid opl_write( opl_t* opl, int count, unsigned short* regs, unsigned char* data ) {\n    struct opl_emu_t* emu = &opl->opl_emu;\n    for( int i = 0; i < count; ++i ) {\n        uint16_t regnum = regs[ i ];\n        uint8_t value = data[ i ];\n\t    // special case: writes to the mode register can impact IRQs;\n\t    // schedule these writes to ensure ordering with timers\n\t    if (regnum == OPL_EMU_REGISTERS_REG_MODE)\n\t    {\n    //\t\temu->m_intf.opl_emu_sync_mode_write(data);\n\t\t    continue;;\n\t    }\n\n\t    // for now just mark all channels as modified\n\t    emu->m_modified_channels = OPL_EMU_REGISTERS_ALL_CHANNELS;\n\n\t    // most writes are passive, consumed only when needed\n\t    uint32_t keyon_channel;\n\t    uint32_t keyon_opmask;\n\t    if (opl_emu_registers_write(&emu->m_regs,regnum, value, &keyon_channel, &keyon_opmask))\n\t    {\n\t\t    // handle writes to the keyon register(s)\n\t\t    if (keyon_channel < OPL_EMU_REGISTERS_CHANNELS)\n\t\t    {\n\t\t\t    // normal channel on/off\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[keyon_channel],keyon_opmask, OPL_EMU_KEYON_NORMAL, keyon_channel);\n\t\t    }\n\t\t    else if (OPL_EMU_REGISTERS_CHANNELS >= 9 && keyon_channel == OPL_EMU_REGISTERS_RHYTHM_CHANNEL)\n\t\t    {\n\t\t\t    // special case for the OPL rhythm channels\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[6],opl_emu_bitfield(keyon_opmask, 4,1) ? 3 : 0, OPL_EMU_KEYON_RHYTHM, 6);\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[7],opl_emu_bitfield(keyon_opmask, 0,1) | (opl_emu_bitfield(keyon_opmask, 3,1) << 1), OPL_EMU_KEYON_RHYTHM, 7);\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[8],opl_emu_bitfield(keyon_opmask, 2,1) | (opl_emu_bitfield(keyon_opmask, 1,1) << 1), OPL_EMU_KEYON_RHYTHM, 8);\n\t\t    }\n\t    }\n    }\n}\n\n\nconst unsigned short freqtable[128] = {                          /* note # */\n        345, 365, 387, 410, 435, 460, 488, 517, 547, 580, 615, 651,  /*  0 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 12 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 24 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 36 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 48 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 60 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 72 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 84 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 96 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651, /* 108 */\n        690, 731, 774, 820, 869, 921, 975, 517};                    /* 120 */\n\nconst unsigned char octavetable[128] = {                         /* note # */\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                          /*  0 */\n        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,                          /* 12 */\n        1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,                          /* 24 */\n        2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,                          /* 36 */\n        3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,                          /* 48 */\n        4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,                          /* 60 */\n        5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,                          /* 72 */\n        6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7,                          /* 84 */\n        7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,                          /* 96 */\n        8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,                         /* 108 */\n        9, 9, 9, 9, 9, 9, 9,10};                                    /* 120 */\n\nconst unsigned short pitchtable[256] = {                    /* pitch wheel */\n         29193U,29219U,29246U,29272U,29299U,29325U,29351U,29378U,  /* -128 */\n         29405U,29431U,29458U,29484U,29511U,29538U,29564U,29591U,  /* -120 */\n         29618U,29644U,29671U,29698U,29725U,29752U,29778U,29805U,  /* -112 */\n         29832U,29859U,29886U,29913U,29940U,29967U,29994U,30021U,  /* -104 */\n         30048U,30076U,30103U,30130U,30157U,30184U,30212U,30239U,  /*  -96 */\n         30266U,30293U,30321U,30348U,30376U,30403U,30430U,30458U,  /*  -88 */\n         30485U,30513U,30541U,30568U,30596U,30623U,30651U,30679U,  /*  -80 */\n         30706U,30734U,30762U,30790U,30817U,30845U,30873U,30901U,  /*  -72 */\n         30929U,30957U,30985U,31013U,31041U,31069U,31097U,31125U,  /*  -64 */\n         31153U,31181U,31209U,31237U,31266U,31294U,31322U,31350U,  /*  -56 */\n         31379U,31407U,31435U,31464U,31492U,31521U,31549U,31578U,  /*  -48 */\n         31606U,31635U,31663U,31692U,31720U,31749U,31778U,31806U,  /*  -40 */\n         31835U,31864U,31893U,31921U,31950U,31979U,32008U,32037U,  /*  -32 */\n         32066U,32095U,32124U,32153U,32182U,32211U,32240U,32269U,  /*  -24 */\n         32298U,32327U,32357U,32386U,32415U,32444U,32474U,32503U,  /*  -16 */\n         32532U,32562U,32591U,32620U,32650U,32679U,32709U,32738U,  /*   -8 */\n         32768U,32798U,32827U,32857U,32887U,32916U,32946U,32976U,  /*    0 */\n         33005U,33035U,33065U,33095U,33125U,33155U,33185U,33215U,  /*    8 */\n         33245U,33275U,33305U,33335U,33365U,33395U,33425U,33455U,  /*   16 */\n         33486U,33516U,33546U,33576U,33607U,33637U,33667U,33698U,  /*   24 */\n         33728U,33759U,33789U,33820U,33850U,33881U,33911U,33942U,  /*   32 */\n         33973U,34003U,34034U,34065U,34095U,34126U,34157U,34188U,  /*   40 */\n         34219U,34250U,34281U,34312U,34343U,34374U,34405U,34436U,  /*   48 */\n         34467U,34498U,34529U,34560U,34591U,34623U,34654U,34685U,  /*   56 */\n         34716U,34748U,34779U,34811U,34842U,34874U,34905U,34937U,  /*   64 */\n         34968U,35000U,35031U,35063U,35095U,35126U,35158U,35190U,  /*   72 */\n         35221U,35253U,35285U,35317U,35349U,35381U,35413U,35445U,  /*   80 */\n         35477U,35509U,35541U,35573U,35605U,35637U,35669U,35702U,  /*   88 */\n         35734U,35766U,35798U,35831U,35863U,35895U,35928U,35960U,  /*   96 */\n         35993U,36025U,36058U,36090U,36123U,36155U,36188U,36221U,  /*  104 */\n         36254U,36286U,36319U,36352U,36385U,36417U,36450U,36483U,  /*  112 */\n         36516U,36549U,36582U,36615U,36648U,36681U,36715U,36748U}; /*  120 */\n\n\n/*\n * This file contains OPL fonts for all the General Midi level 1 instruments:\n *  - 128 instruments\n *  - 128 percussions\n */\nstatic struct opl_timbre_t opl_gmtimbres_default[ 256 ] = {\n/* ,---------+-------- Wave select settings                        *\n * | ,--------+------ Sustain/release rates                       *\n * | | ,-------+---- Attack/decay rates                          *\n * | | | ,------+-- AM/VIB/EG/KSR/Multiple bits                 *\n * | | | |   | | | |                                               *\n * | | | |   | | | |    ,----+-- KSL/attenuation settings          *\n * | | | |   | | | |    |    |    ,----- Feedback/connection bits  *\n * | | | |   | | | |    |    |    |   ,---- Percussion note number */\n{0x223E133,0x4F4F131,0xA5,0x09,0x0E,0,0},\n{0x433F133,0x0F4F131,0xA3,0x09,0x0C,0,0},\n{0x4B3E131,0x0F4F130,0x1A,0x86,0x08,0,0},\n{0x073FA32,0x4F4D111,0x80,0x08,0x0C,0,0},\n{0x0E7F21C,0x0B8F201,0x6F,0x80,0x0C,0,0},\n{0x0C7F437,0x0D7F230,0x5D,0x0A,0x08,0,0},\n{0x303F232,0x1F6D131,0x44,0x00,0x08,0,0},\n{0x559F101,0x0F7F111,0x44,0x08,0x06,0,0},\n{0x087F607,0x0E4F231,0x54,0x08,0x09,0,0},\n{0x0A5F33F,0x0F2C312,0xA1,0x06,0x0C,0,0},\n{0x004561A,0x004F601,0x9E,0x08,0x08,0,0},\n{0x0F6F2B2,0x0F6F281,0xE5,0x00,0x0F,0,0},\n{0x0F6F618,0x0F7E500,0x63,0x80,0x06,0,0},\n{0x096F616,0x0F5F111,0x1F,0x03,0x04,0,0},\n{0x082F307,0x0E3F302,0x97,0x8A,0x06,0,0},\n{0x4109130,0x3B5F321,0x52,0x88,0x08,0,0},\n{0x116B1A2,0x117D160,0x88,0x80,0x07,0,0},\n{0x0F8F032,0x0F8F001,0x65,0x00,0x0E,0,0},\n{0x018AA70,0x0088AB1,0x44,0x0A,0x04,0,0},\n{0x1043030,0x1145431,0x92,0x80,0x0D,0,0},\n{0x0178000,0x1176081,0x54,0x8B,0x04,0,0},\n{0x025A721,0x1264132,0x4D,0x08,0x06,0,0},\n{0x4FAF022,0x01A6221,0x96,0x08,0x0C,0,0},\n{0x107F020,0x2055231,0x92,0x07,0x08,0,0},\n{0x274A613,0x4B8F401,0xDD,0x05,0x06,0,0},\n{0x5E5F133,0x1E4F211,0x99,0x07,0x06,0,0},\n{0x21FF021,0x088F211,0xA5,0x48,0x0A,0,0},\n{0x132ED10,0x3E7D210,0x87,0x0A,0x06,0,0},\n{0x0F4E430,0x0F5F330,0x92,0x80,0x08,0,0},\n{0x0F78111,0x3F7F054,0x40,0x45,0x08,0,0},\n{0x0F78111,0x2F7F054,0x40,0x45,0x0A,0,0},\n{0x6F78AE4,0x649B1F2,0x03,0x0A,0x0A,0,0},\n{0x0209220,0x0E6C130,0x97,0x05,0x00,0,0},\n{0x0FFF030,0x0F8F131,0x9D,0x00,0x0A,0,0},\n{0x026AA20,0x0D7F131,0xCF,0x80,0x0A,0,0},\n{0x0007511,0x0B69212,0x1A,0x40,0x08,0,0},\n{0x2E69419,0x5B6B311,0x5E,0x08,0x00,0,0},\n{0x2E69515,0x1B6B211,0x17,0x08,0x00,0,0},\n{0x0F5F430,0x0F6F330,0x0E,0x00,0x0A,0,0},\n{0x1468330,0x017D231,0x15,0x00,0x0A,0,0},\n{0x2257020,0x4266161,0x95,0x05,0x0A,0,0},\n{0x2446070,0x2154130,0x4E,0x00,0x0A,0,0},\n{0x214D070,0x1175222,0x0F,0x88,0x02,0,0},\n{0x521F570,0x4166021,0x90,0x09,0x06,0,0},\n{0x201C3B0,0x0058321,0x8D,0x08,0x08,0,0},\n{0x0848521,0x074C411,0x69,0x07,0x0A,0,0},\n{0x022E133,0x0F2F131,0xA2,0x09,0x0E,0,0},\n{0x4C3C413,0x0B4D215,0x9B,0x09,0x0A,0,0},\n{0x223F832,0x4055421,0x99,0x8A,0x0C,0,0},\n{0x5059022,0x1055521,0x5B,0x85,0x00,0,0},\n{0x1254732,0x40256B1,0xA4,0x0A,0x08,0,0},\n{0x0031121,0x1046120,0x58,0x84,0x00,0,0},\n{0x0055020,0x0F55021,0x1C,0x0F,0x07,0,0},\n{0x239B420,0x0076121,0x50,0x05,0x06,0,0},\n{0x05470F0,0x07460B0,0x5A,0x80,0x00,0,0},\n{0x2436110,0x114D211,0x90,0x00,0x0C,0,0},\n{0x017B561,0x0097F21,0x92,0x04,0x0C,0,0},\n{0x0235270,0x0198160,0x1E,0x08,0x0E,0,0},\n{0x0157621,0x0378261,0x94,0x00,0x0C,0,0},\n{0x118537A,0x5177432,0x21,0x00,0x04,0,0},\n{0x0364120,0x02B7220,0x21,0x08,0x0C,0,0},\n{0x0577320,0x117C020,0x19,0x03,0x0C,0,0},\n{0x036F120,0x337F120,0x92,0x08,0x0E,0,0},\n{0x0A66120,0x0976120,0x9B,0x08,0x0E,0,0},\n{0x0F37010,0x1F65051,0x51,0x04,0x0A,0,0},\n{0x1067021,0x1165231,0x8A,0x00,0x06,0,0},\n{0x00B9820,0x10B5330,0x8E,0x00,0x0A,0,0},\n{0x10B8020,0x11B6330,0x87,0x00,0x08,0,0},\n{0x0235030,0x0076C62,0x58,0x08,0x0A,0,0},\n{0x2077820,0x2074331,0x97,0x00,0x06,0,0},\n{0x0199030,0x01B6132,0x95,0x80,0x0A,0,0},\n{0x0177531,0x0174530,0x93,0x03,0x0C,0,0},\n{0x08D6EF1,0x02A3571,0xC0,0x00,0x0E,0,0},\n{0x08860A1,0x02A6561,0xA6,0x00,0x08,0,0},\n{0x2176522,0x0277421,0x5A,0x00,0x06,0,0},\n{0x1273471,0x01745B0,0x8D,0x05,0x04,0,0},\n{0x00457E1,0x0375760,0xA8,0x00,0x0E,0,0},\n{0x6543739,0x25D67A1,0x28,0x00,0x0E,0,0},\n{0x00F31D0,0x0053270,0xC7,0x00,0x0B,0,0},\n{0x00581A1,0x0295230,0x37,0x00,0x06,0,0},\n{0x20FFF22,0x60FFF21,0x7F,0x12,0x05,0,0},\n{0x39BC120,0x368C030,0xBF,0x06,0x00,0,0},\n{0x33357F0,0x00767E0,0x28,0x00,0x0E,0,0},\n{0x40457E1,0x03D67E0,0x23,0x00,0x0E,0,0},\n{0x32B7320,0x12BF131,0x40,0x00,0x08,0,0},\n{0x5029071,0x0069060,0x96,0x09,0x08,0,0},\n{0x195C120,0x1637030,0x43,0x80,0x0A,0,0},\n{0x132ED10,0x3E7D210,0x87,0x08,0x06,0,0},\n{0x2946374,0x005A0A1,0xA5,0x05,0x02,0,0},\n{0x00521A1,0x0053360,0xC0,0x00,0x09,0,0},\n{0x2A5A120,0x196A120,0x95,0x05,0x0C,0,0},\n{0x005F0E0,0x0548160,0x44,0x00,0x0B,0,0},\n{0x0336183,0x05452E0,0xA7,0x00,0x06,0,0},\n{0x2529082,0x1534340,0x9D,0x80,0x0C,0,0},\n{0x2345231,0x2135120,0x98,0x00,0x06,0,0},\n{0x1521161,0x1632060,0x90,0x80,0x08,0,0},\n{0x157B260,0x019F803,0x04,0x40,0x07,0,0},\n{0x2322122,0x0133221,0x8C,0x92,0x06,0,0},\n{0x074F624,0x0249303,0xC0,0x0D,0x00,0,0},\n{0x3D2C091,0x1D2D130,0x8E,0x03,0x00,0,0},\n{0x5F29052,0x0F2C240,0x96,0x06,0x08,0,0},\n{0x05213E1,0x2131371,0x1A,0x88,0x07,0,0},\n{0x0B67060,0x0928031,0x9C,0x11,0x0A,0,0},\n{0x0025511,0x1748201,0x94,0x06,0x0E,0,0},\n{0x0B37120,0x5F48220,0x1B,0x08,0x02,0,0},\n{0x0127530,0x6F4F310,0x0D,0x0A,0x06,0,0},\n{0x033F900,0x273F400,0x80,0x80,0x00,0,0},\n{0x332F320,0x6E49423,0x0E,0x08,0x08,0,0},\n{0x0328413,0x073B410,0xA1,0x00,0x0F,0,0},\n{0x1397931,0x2099B22,0x80,0x00,0x06,0,0},\n{0x302A130,0x0266221,0x1E,0x00,0x0E,0,0},\n{0x0136030,0x1169130,0x12,0x80,0x08,0,0},\n{0x032A115,0x172B212,0x00,0x80,0x01,0,0},\n{0x001E795,0x0679616,0x81,0x00,0x04,0,0},\n{0x4046303,0x005A901,0xCA,0x08,0x06,0,0},\n{0x6D1F817,0x098F611,0xA7,0x00,0x06,0,0},\n{0x008F312,0x004F600,0x08,0xC8,0x04,0,46},\n{0x0C8A820,0x0B7E601,0x0B,0x00,0x00,0,0},\n{0x00437D2,0x0343471,0xA1,0x07,0x0C,0,0},\n{0x2114109,0x51D2101,0x05,0x80,0x0A,0,0},\n{0x4543310,0x3574515,0x19,0x03,0x0E,0,0},\n{0x00437D2,0x0343471,0xA1,0x07,0x0C,0,0},\n{0x200C327,0x6021300,0x80,0x08,0x0E,0,65},\n{0x003EBD7,0x06845D8,0xD4,0x00,0x07,0,0},\n{0x62FDA20,0x614B009,0x42,0x48,0x04,0,0},\n{0x101FE30,0x6142120,0x00,0x00,0x0C,0,17},\n{0x200832F,0x6044020,0x80,0x00,0x0E,0,65},\n{0x230732F,0x6E6F400,0x00,0x00,0x0E,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0E,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x06,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x06,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x06,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0A,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0A,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0E,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x06,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0A,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0C,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0A,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x02,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0E,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0C,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0E,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0E,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x08,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x0F,0,0},\n{0x057FB00,0x046F800,0x00,0x00,0x0E,0,25},\n{0x277F810,0x006FC11,0x86,0x00,0x0A,0,34},\n{0x287F702,0x678F802,0x80,0x88,0x0A,0,61},\n{0x6EF8801,0x608B502,0x0D,0x00,0x0C,0,38},\n{0x05476C1,0x30892C5,0x80,0x08,0x06,0,37},\n{0x6EF8800,0x608F502,0x13,0x00,0x08,0,38},\n{0x508F601,0x104F600,0x08,0x00,0x06,0,32},\n{0x254F307,0x307F905,0x04,0x0B,0x06,0,48},\n{0x508F601,0x104F600,0x08,0x00,0x0A,0,34},\n{0x254D307,0x3288905,0x04,0x08,0x0A,0,48},\n{0x508F601,0x104F600,0x0C,0x00,0x08,0,37},\n{0x2F2E327,0x3F5C525,0x04,0x08,0x08,0,48},\n{0x508F601,0x104F600,0x0C,0x00,0x00,0,40},\n{0x508F601,0x104F600,0x0C,0x00,0x00,0,43},\n{0x292F108,0x354F201,0x00,0x08,0x00,0,61},\n{0x508F601,0x104F600,0x0C,0x00,0x00,0,46},\n{0x210F509,0x305FE03,0x8A,0x88,0x00,0,60},\n{0x283E108,0x334D700,0x00,0x08,0x00,0,79},\n{0x2E1F119,0x3F3F11B,0x04,0x08,0x00,0,62},\n{0x2777603,0x3679601,0x87,0x08,0x00,0,80},\n{0x251F206,0x263C504,0x04,0x09,0x00,0,67},\n{0x366F905,0x099F701,0x00,0x00,0x00,0,58},\n{0x292F108,0x354F201,0x00,0x03,0x00,0,62},\n{0x422F120,0x056B40E,0x81,0x00,0x00,0,24},\n{0x212FD04,0x305FD03,0x01,0x00,0x00,0,61},\n{0x2A8F9E3,0x0779643,0x1E,0x08,0x00,0,41},\n{0x2A8F9E3,0x0779643,0x1E,0x00,0x00,0,35},\n{0x0A8F7E9,0x5D8990A,0x08,0x00,0x00,0,29},\n{0x2A8F9E2,0x0779642,0x1E,0x00,0x00,0,41},\n{0x2A8F9E2,0x0779642,0x1E,0x00,0x00,0,37},\n{0x456FB02,0x017F700,0x81,0x00,0x00,0,55},\n{0x456FB02,0x017F700,0x81,0x00,0x00,0,48},\n{0x367FD01,0x098F601,0x00,0x08,0x00,0,78},\n{0x367FD01,0x098F601,0x00,0x08,0x00,0,73},\n{0x25E780C,0x32B8A0A,0x00,0x80,0x00,0,88},\n{0x098600F,0x3FC8590,0x08,0xC0,0x00,0,40},\n{0x009F020,0x37DA588,0x07,0x00,0x00,0,45},\n{0x00FC020,0x32DA5A8,0x07,0x00,0x00,0,42},\n{0x106F680,0x016F610,0x00,0x00,0x00,0,48},\n{0x106F680,0x016F610,0x00,0x00,0x00,0,48},\n{0x0D1F815,0x078F512,0x44,0x00,0x00,0,73},\n{0x1D1F813,0x078F512,0x44,0x00,0x00,0,68},\n{0x1D1F813,0x078F512,0x44,0x00,0x00,0,61},\n{0x1DC5D01,0x06FF79F,0x0B,0x00,0x00,0,16},\n{0x1C7C900,0x05FF49F,0x07,0x00,0x00,0,16},\n{0x160F2C6,0x07AF4D4,0x4F,0x80,0x00,0,90},\n{0x160F286,0x0B7F294,0x4F,0x80,0x00,0,90},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0},\n{0x0000000,0x0000000,0x00,0x00,0x00,0,0}\n};\n\n/* tables below provide register offsets for each voice. note, that these are\n * NOT the registers IDs, but their direct offsets instead - this for simpler\n * and faster computations. */\nconst unsigned short op1offsets[18] = {0x00,0x01,0x02,0x08,0x09,0x0a,0x10,0x11,0x12,0x100,0x101,0x102,0x108,0x109,0x10a,0x110,0x111,0x112};\nconst unsigned short op2offsets[18] = {0x03,0x04,0x05,0x0b,0x0c,0x0d,0x13,0x14,0x15,0x103,0x104,0x105,0x10b,0x10c,0x10d,0x113,0x114,0x115};\n\n/* number of melodic voices: 9 by default (OPL2), can go up to 18 (OPL3) */\nstatic int voicescount = 9;\n\n\n/* 'volume' is in range 0..127 - take care to change only the 'attenuation'\n * part of the register, and never touch the KSL bits */\nstatic void calc_vol(unsigned char *regbyte, int volume) {\n  int level;\n  /* invert bits and strip out the KSL header */\n  level = ~(*regbyte);\n  level &= 0x3f;\n\n  /* adjust volume */\n  level = (level * volume) / 127;\n\n  /* boundaries check */\n  if (level > 0x3f) level = 0x3f;\n  if (level < 0) level = 0;\n\n  /* invert the bits, as expected by the OPL registers */\n  level = ~level;\n  level &= 0x3f;\n\n  /* final result computation */\n  *regbyte &= 0xC0;  /* zero out all attentuation bits */\n  *regbyte |= level; /* fill in the new attentuation value */\n}\n\n\n/* Initialize hardware upon startup - positive on success, negative otherwise\n * Returns 0 for OPL2 initialization, or 1 if OPL3 has been detected */\nopl_t* opl_create(void) {\n  /* init memory */\n  struct opl_t* opl = (struct opl_t*)calloc(1, sizeof(struct opl_t));\n  if (opl == NULL) return NULL;\n  memcpy( opl->opl_gmtimbres, opl_gmtimbres_default, sizeof( opl_gmtimbres_default ) );\n  opl_emu_init( &opl->opl_emu );\n\n  opl->is_op2 = 0;\n  \n  /* detect the hardware and return error if not found */\n  oplregwr(opl, 0x04, 0x60); /* reset both timers by writing 60h to register 4 */\n  oplregwr(opl, 0x04, 0x80); /* enable interrupts by writing 80h to register 4 (must be a separate write from the 1st one) */\n  //x = inp(port) & 0xE0; /* read the status register (port 388h) and store the result */\n  oplregwr(opl, 0x02, 0xff); /* write FFh to register 2 (Timer 1) */\n  oplregwr(opl, 0x04, 0x21); /* start timer 1 by writing 21h to register 4 */\n  /*udelay(500);*/ /* Creative Labs recommends a delay of at least 80 microseconds\n                  I delay for 500us just to be sure. DO NOT perform inp()\n                  calls for delay here, some cards do not initialize well then\n                  (reported for CT2760) */\n  //y = inp(port) & 0xE0;  /* read the upper bits of the status register */\n  oplregwr(opl, 0x04, 0x60); /* reset both timers and interrupts (see steps 1 and 2) */\n  oplregwr(opl, 0x04, 0x80); /* reset both timers and interrupts (see steps 1 and 2) */\n  /* test the stored results of steps 3 and 7 by ANDing them with E0h. The result of step 3 should be */\n\n//  if (x != 0) return(-1);    /* 00h, and the result of step 7 should be C0h. If both are     */\n//  if (y != 0xC0) return(-2); /* ok, an AdLib-compatible board is installed in the computer   */\n\n\n  /* is it an OPL3 or just an OPL2? */\n  /*if ((inp(port) & 0x06) == 0) */opl->opl3 = 1;\n\n  /* init the hardware */\n  voicescount = 9; /* OPL2 provides 9 melodic voices */\n\n  /* enable OPL3 (if detected) and put it into 36 operators mode */\n  if (opl->opl3 != 0) {\n    oplregwr(opl, 0x105, 1);  /* enable OPL3 mode (36 operators) */\n    oplregwr(opl, 0x104, 0);  /* disable four-operator voices */\n    voicescount = 18;          /* OPL3 provides 18 melodic channels */\n\n    /* Init the secondary OPL chip\n     * NOTE: this I don't do anymore, it turns my Aztech Waverider mute! */\n    /* oplregwr(0x101, 0x20); */ /* enable Waveform Select */\n    /* oplregwr(0x108, 0x40); */ /* turn off CSW mode and activate FM synth mode */\n    /* oplregwr(0x1BD, 0x00); */ /* set vibrato/tremolo depth to low, set melodic mode */\n  }\n\n  oplregwr(opl, 0x01, 0x20);  /* enable Waveform Select */\n  oplregwr(opl, 0x04, 0x00);  /* turn off timers IRQs */\n  oplregwr(opl, 0x08, 0x40);  /* turn off CSW mode and activate FM synth mode */\n  oplregwr(opl, 0xBD, 0x00);  /* set vibrato/tremolo depth to low, set melodic mode */\n\n  for (int x = 0; x < voicescount; x++) {\n    oplregwr(opl, 0x20 + op1offsets[x], 0x1);     /* set the modulator's multiple to 1 */\n    oplregwr(opl, 0x20 + op2offsets[x], 0x1);     /* set the modulator's multiple to 1 */\n    oplregwr(opl, 0x40 + op1offsets[x], 0x10);    /* set volume of all channels to about 40 dB */\n    oplregwr(opl, 0x40 + op2offsets[x], 0x10);    /* set volume of all channels to about 40 dB */\n  }\n\n  opl_clear(opl);\n  /* all done */\n  return(opl);\n}\n\n\n/* close OPL device */\nvoid opl_destroy(opl_t* opl) {\n  int x;\n\n  /* turns all notes 'off' */\n  opl_clear(opl);\n\n  /* set volume to lowest level on all voices */\n  for (x = 0; x < voicescount; x++) {\n    oplregwr(opl, 0x40 + op1offsets[x], 0x1f);\n    oplregwr(opl, 0x40 + op2offsets[x], 0x1f);\n  }\n\n  /* if OPL3, switch the chip back into its default OPL2 mode */\n  if (opl->opl3 != 0) oplregwr(opl, 0x105, 0);\n\n  /* free state memory */\n  free(opl);\n  opl = NULL;\n}\n\nvoid opl_noteoff(opl_t* opl, unsigned short voice) {\n  /* if voice is one of the OPL3 set, adjust it and route over secondary OPL port */\n  if (voice >= 9) {\n    oplregwr(opl, 0x1B0 + voice - 9, 0);\n  } else {\n    oplregwr(opl, 0xB0 + voice, 0);\n  }\n}\n\n\nvoid opl_noteon(opl_t* opl, unsigned short voice, unsigned int note, int pitch) {\n  unsigned int freq = freqtable[note];\n  unsigned int octave = octavetable[note];\n\n  if (pitch != 0) {\n    if (pitch > 127) {\n      pitch = 127;\n    } else if (pitch < -128) {\n      pitch = -128;\n    }\n    freq = ((unsigned long)freq * pitchtable[pitch + 128]) >> 15;\n    if (freq >= 1024) {\n      freq >>= 1;\n      octave++;\n    }\n  }\n  if (octave > 7) octave = 7;\n\n  /* if voice is one of the OPL3 set, adjust it and route over secondary OPL port */\n  if (voice >= 9) {\n    voice -= 9;\n    voice |= 0x100;\n  }\n\n  oplregwr(opl, 0xA0 + voice, freq & 0xff); /* set lowfreq */\n  oplregwr(opl, 0xB0 + voice, (freq >> 8) | (octave << 2) | 32); /* KEY ON + hifreq + octave */\n}\n\n\n/* turns off all notes */\nvoid opl_clear(opl_t* opl) {\n  int x, y;\n  for (x = 0; x < voicescount; x++) opl_noteoff(opl, x);\n\n  /* reset the percussion bits at the 0xBD register */\n  oplregwr(opl, 0xBD, 0);\n\n  /* mark all voices as unused */\n  for (x = 0; x < voicescount; x++) {\n    opl->voices2notes[x].channel = -1;\n    opl->voices2notes[x].note = -1;\n    opl->voices2notes[x].timbreid = -1;\n    opl->voices2notes[x].voiceindex = 0xFF;\n  }\n\n  /* mark all notes as unallocated */\n  for (x = 0; x < 16; x++) {\n    for (y = 0; y < 128; y++) {\n      opl->notes2voices[x][y][0] = -1;\n      opl->notes2voices[x][y][1] = -1;\n    }\n  }\n\n  /* pre-set emulated channel patches to default GM ids and reset all\n   * per-channel volumes */\n  for (x = 0; x < 16; x++) {\n    opl_midi_changeprog(opl,x, x);\n    opl->channelvol[x] = 127;\n  }\n}\n\n\n\nvoid opl_midi_pitchwheel(opl_t* opl, int channel, int pitchwheel) {\n  int x;\n  /* update the new pitch value for channel (used by newly played notes) */\n//  opl->channelpitch[channel] = pitchwheel;\n  /* check all active voices to see who is playing on given channel now, and\n   * recompute all playing notes for this channel with the new pitch TODO */\n  for (x = 0; x < voicescount; x++) {\n    if (opl->voices2notes[x].channel != channel) continue;\n    \n    opl_timbre_t* timbre = opl->voices2notes[x].voiceindex == 0\n      ? &(opl->opl_gmtimbres[opl->voices2notes[x].timbreid])\n      : &(opl->opl_gmtimbres_voice2[opl->voices2notes[x].timbreid])\n      ;\n    opl_noteon(opl, x, opl->voices2notes[x].note + timbre->noteoffset, pitchwheel + timbre->finetune);\n  }\n}\n\n\nvoid opl_midi_controller(opl_t* opl, int channel, int id, int value) {\n  int x;\n  switch (id) {\n    case 11: /* \"Expression\" (meaning \"channel volume\") */\n      opl->channelvol[channel] = value;\n      break;\n    case 123: /* 'all notes off' */\n    case 120: /* 'all sound off' - I map it to 'all notes off' for now, not perfect but better than not handling it at all */\n      for (x = 0; x < voicescount; x++) {\n        if (opl->voices2notes[x].channel != channel) continue;\n        opl_midi_noteoff(opl, channel, opl->voices2notes[x].note);\n      }\n      break;\n  }\n}\n\n\n/* assign a new instrument to emulated MIDI channel */\nvoid opl_midi_changeprog(opl_t* opl,int channel, int program) {\n  if (channel == 9) return; /* do not allow to change channel 9, it is for percussions only */\n  opl->channelprog[channel] = program;\n}\n\n\nvoid opl_loadinstrument(opl_t* opl, int voice, opl_timbre_t *timbre) {\n  /* KSL (key level scaling) / attenuation */\n  oplregwr(opl, 0x40 + op1offsets[voice], timbre->modulator_40);\n  oplregwr(opl, 0x40 + op2offsets[voice], timbre->carrier_40 | 0x3f); /* force volume to 0, it will be reajusted during 'note on' */\n\n  /* select waveform on both operators */\n  oplregwr(opl, 0xE0 + op1offsets[voice], timbre->modulator_E862 >> 24);\n  oplregwr(opl, 0xE0 + op2offsets[voice], timbre->carrier_E862 >> 24);\n\n  /* sustain / release */\n  oplregwr(opl, 0x80 + op1offsets[voice], (timbre->modulator_E862 >> 16) & 0xff);\n  oplregwr(opl, 0x80 + op2offsets[voice], (timbre->carrier_E862 >> 16) & 0xff);\n\n  /* attack rate / decay */\n  oplregwr(opl, 0x60 + op1offsets[voice], (timbre->modulator_E862 >> 8) & 0xff);\n  oplregwr(opl, 0x60 + op2offsets[voice], (timbre->carrier_E862 >> 8) & 0xff);\n\n  /* AM / vibrato / envelope */\n  oplregwr(opl, 0x20 + op1offsets[voice], timbre->modulator_E862 & 0xff);\n  oplregwr(opl, 0x20 + op2offsets[voice], timbre->carrier_E862 & 0xff);\n\n  /* feedback / connection */\n  if (voice >= 9) {\n    voice -= 9;\n    voice |= 0x100;\n  }\n  if (opl->opl3 != 0) { /* on OPL3 make sure to enable LEFT/RIGHT unmute bits */\n    oplregwr(opl, 0xC0 + voice, timbre->feedconn | 0x30);\n  } else {\n    oplregwr(opl, 0xC0 + voice, timbre->feedconn);\n  }\n\n}\n\n\n/* adjust the volume of the voice (in the usual MIDI range of 0..127) */\nstatic void voicevolume(opl_t* opl, unsigned short voice, const opl_timbre_t* timbre, int volume) {\n  unsigned char carrierval = timbre->carrier_40;\n  if (volume == 0) {\n    carrierval |= 0x3f;\n  } else {\n    calc_vol(&carrierval, volume);\n  }\n  oplregwr(opl, 0x40 + op2offsets[voice], carrierval);\n}\n\n\n/* get the id of the instrument that relates to channel/note pair */\nstatic int getinstrument(opl_t* opl, int channel, int note) {\n  if ((note < 0) || (note > 127) || (channel > 15)) return(-1);\n  if (channel == 9) { /* the percussion channel requires special handling */\n    if (opl->is_op2)\n      return 128 + note - 35;\n    else\n      return(128 | note);\n  }\n  return(opl->channelprog[channel]);\n}\n\nvoid opl_midi_noteoff_op2(opl_t* opl, int channel, int note, int vindex);\n\nvoid opl_midi_noteon_op2(opl_t* opl, int channel, int note, int velocity, int vindex) {\n  if( velocity == 0 ) {\n      opl_midi_noteoff_op2( opl, channel, note, vindex );\n      return;\n  }\n  int x, voice = -1;\n  int lowestpriority = 0xFFFF;\n  int highestvoiceindex = -1;\n  int lowestpriorityvoice = -1;\n  int instrument;\n\n  /* get the instrument to play */\n  instrument = getinstrument(opl, channel, note);\n  if (instrument < 0) return;\n  \n  /* only play OP2 second voice when appropriate */\n  if (vindex > 0 && (opl->op2_flags[instrument] & OP2_DOUBLEVOICE) == 0) return;\n  \n  opl_timbre_t* timbre = vindex == 0 ? &(opl->opl_gmtimbres[instrument]) : &(opl->opl_gmtimbres_voice2[instrument]);\n\n  /* if note already playing, then reuse its voice to avoid leaving a stuck voice */\n  if (opl->notes2voices[channel][note][vindex] >= 0) {\n    voice = opl->notes2voices[channel][note][vindex];\n  } else {\n    /* else find a free voice, possibly with the right timbre, or at least locate the oldest note */\n    for (x = 0; x < voicescount; x++) {\n      if (opl->voices2notes[x].channel < 0) {\n        voice = x; /* preselect this voice, but continue looking */\n        /* if the instrument is right, do not look further */\n        if (opl->voices2notes[x].timbreid == instrument && opl->voices2notes[x].voiceindex == vindex) {\n          break;\n        }\n      }\n      if (opl->voices2notes[x].priority < lowestpriority) {\n        /* 2nd instrumental voice should not overwrite 1st instrumental voice */\n        /* also prefer 2nd instrumental voices when possible */\n        if (opl->voices2notes[x].voiceindex >= vindex && opl->voices2notes[x].voiceindex >= highestvoiceindex) {\n          lowestpriorityvoice = x;\n          lowestpriority = opl->voices2notes[x].priority;\n          highestvoiceindex = opl->voices2notes[x].voiceindex;\n        }\n      }\n    }\n    /* if no free voice available, then abort the oldest one */\n    if (voice < 0) {\n      if (lowestpriorityvoice < 0) {\n        /* no suitable voice found to abort */\n        return;\n      }\n      voice = lowestpriorityvoice;\n      opl_midi_noteoff_op2(opl, opl->voices2notes[voice].channel, opl->voices2notes[voice].note, opl->voices2notes[voice].voiceindex);\n    }\n  }\n\n  /* load the proper instrument, if not already good */\n  if (opl->voices2notes[voice].timbreid != instrument) {\n    opl->voices2notes[voice].timbreid = instrument;\n    opl_loadinstrument(opl, voice, timbre);\n  }\n\n  /* update states */\n  opl->voices2notes[voice].channel = channel;\n  opl->voices2notes[voice].note = note;\n  opl->voices2notes[voice].priority = ((16 - channel) << 8) | 0xff; /* lower channels must have priority */\n  opl->voices2notes[voice].voiceindex = vindex;\n  opl->notes2voices[channel][note][vindex] = voice;\n  \n  /* second OP2 voice has lower priority */\n  if (vindex != 0) {\n    int reducedprio = (int)opl->voices2notes[voice].priority - OP2_2NDVOICE_PRIORITY_PENALTY;\n    if (reducedprio < 0) reducedprio = 0;\n    opl->voices2notes[voice].priority = (unsigned short)reducedprio;\n  }\n\n  /* set the requested velocity on the voice */\n  voicevolume(opl, voice, timbre, velocity * opl->channelvol[channel] / 127);\n\n  /* trigger NOTE_ON on the OPL, take care to apply the 'finetune' pitch correction, too */\n  if (channel == 9) { /* percussion channel doesn't provide a real note, so I */\n                      /* use a static one (MUSPLAYER uses C-5 (60), why not.  */\n    opl_noteon(opl, voice, timbre->notenum + timbre->noteoffset, opl->channelpitch[channel] + timbre->finetune);\n  } else {\n    opl_noteon(opl, voice, note + timbre->noteoffset, opl->channelpitch[channel] + timbre->finetune);\n  }\n\n  /* reajust all priorities */\n  for (x = 0; x < voicescount; x++) {\n    if (opl->voices2notes[x].priority > 0) opl->voices2notes[x].priority -= 1;\n  }\n}\n\nvoid opl_midi_noteon(opl_t* opl, int channel, int note, int velocity) {\n  /* play 2nd instrumental voice first just in case */\n  opl_midi_noteon_op2(opl, channel, note, velocity, 1);\n  opl_midi_noteon_op2(opl, channel, note, velocity, 0);\n}\n\nvoid opl_midi_noteoff_op2(opl_t* opl, int channel, int note, int vindex) {\n  int voice = opl->notes2voices[channel][note][vindex];\n\n  if (voice >= 0) {\n    opl_noteoff(opl, voice);\n    opl->voices2notes[voice].channel = -1;\n    opl->voices2notes[voice].note = -1;\n    opl->voices2notes[voice].priority = -1;\n    opl->voices2notes[voice].voiceindex = 0xFF;\n    opl->notes2voices[channel][note][vindex] = -1;\n  }\n}\n\nvoid opl_midi_noteoff(opl_t* opl, int channel, int note) {\n    opl_midi_noteoff_op2(opl, channel, note, 0);\n    opl_midi_noteoff_op2(opl, channel, note, 1);\n}\n\n\nstatic int opl_loadbank_internal(opl_t* opl, char const* file, int offset) {\n  opl->is_op2 = 0;\n  unsigned char buff[16];\n  int i;\n  /* open the IBK file */\n  FILE* f = fopen( file, \"rb\" );\n  if( !f ) return -1;\n  /* file must be exactly 3204 bytes long */\n  fseek( f, 0, SEEK_END );\n  if (ftell(f) != 3204) {\n    fclose(f);\n    return(-2);\n  }\n  fseek( f, 0, SEEK_SET);\n  /* file must start with an IBK header */\n  if ((fread(buff, 1, 4,f) != 4) || (buff[0] != 'I') || (buff[1] != 'B') || (buff[2] != 'K') || (buff[3] != 0x1A)) {\n    fclose(f);\n    return(-3);\n  }\n  /* load 128 instruments from the IBK file */\n  for (i = offset; i < 128 + offset; i++) {\n    /* load instruments */\n    if (fread(buff, 1, 16, f) != 16) {\n      fclose(f);\n      return(-4);\n    }\n    /* load modulator */\n    opl->opl_gmtimbres[i].modulator_E862 = buff[8]; /* wave select */\n    opl->opl_gmtimbres[i].modulator_E862 <<= 8;\n    opl->opl_gmtimbres[i].modulator_E862 |= buff[6]; /* sust/release */\n    opl->opl_gmtimbres[i].modulator_E862 <<= 8;\n    opl->opl_gmtimbres[i].modulator_E862 |= buff[4]; /* attack/decay */\n    opl->opl_gmtimbres[i].modulator_E862 <<= 8;\n    opl->opl_gmtimbres[i].modulator_E862 |= buff[0]; /* AM/VIB... flags */\n    /* load carrier */\n    opl->opl_gmtimbres[i].carrier_E862 = buff[9]; /* wave select */\n    opl->opl_gmtimbres[i].carrier_E862 <<= 8;\n    opl->opl_gmtimbres[i].carrier_E862 |= buff[7]; /* sust/release */\n    opl->opl_gmtimbres[i].carrier_E862 <<= 8;\n    opl->opl_gmtimbres[i].carrier_E862 |= buff[5]; /* attack/decay */\n    opl->opl_gmtimbres[i].carrier_E862 <<= 8;\n    opl->opl_gmtimbres[i].carrier_E862 |= buff[1]; /* AM/VIB... flags */\n    /* load KSL */\n    opl->opl_gmtimbres[i].modulator_40 = buff[2];\n    opl->opl_gmtimbres[i].carrier_40 = buff[3];\n    /* feedconn & finetune */\n    opl->opl_gmtimbres[i].feedconn = buff[10];\n    opl->opl_gmtimbres[i].finetune = buff[12]; /* used only in some IBK files */\n    opl->opl_gmtimbres[i].notenum = 60;\n    opl->opl_gmtimbres[i].noteoffset = 0;\n  }\n  /* close file and return success */\n  fclose(f);\n  return(0);\n}\n\n/*\nstatic void dump2file(void) {\n  FILE *fd;\n  int i;\n  fd = fopen(\"dump.txt\", \"wb\");\n  if (fd == NULL) return;\n  for (i = 0; i < 256; i++) {\n    char *comma = \"\";\n    if (i < 255) comma = \",\";\n    fprintf(fd, \"{0x%07lX,0x%07lX,0x%02X,0x%02X,0x%02X,%d,%d}%s\\r\\n\", opl->opl_gmtimbres[i].modulator_E862, opl->opl_gmtimbres[i].carrier_E862, opl->opl_gmtimbres[i].modulator_40, opl->opl_gmtimbres[i].carrier_40, opl->opl_gmtimbres[i].feedconn, opl->opl_gmtimbres[i].finetune, opl->opl_gmtimbres[i].notenum, comma);\n  }\n  fclose(fd);\n}\n*/\nint opl_loadbank_ibk(opl_t* opl, char const* file) {\n  char *instruments = NULL, *percussion = NULL;\n  int i, res;\n  instruments = strdup(file); /* duplicate the string so we can modify it */\n  if (instruments == NULL) return(-64); /* out of mem */\n  /* if a second file is provided, it's for percussion */\n  for (i = 0; instruments[i] != 0; i++) {\n    if (instruments[i] == ',') {\n      instruments[i] = 0;\n      percussion = instruments + i + 1;\n      break;\n    }\n  }\n  /* load the file(s) */\n  res = opl_loadbank_internal(opl, instruments, 0);\n  if ((res == 0) && (percussion != NULL)) {\n    res = opl_loadbank_internal(opl, percussion, 128);\n  }\n  free(instruments);\n  /*dump2file();*/ /* dump instruments to a 'dump.txt' file */\n  return(res);\n}\n\nstatic void opl_load_op2_voice(opl_timbre_t* timbre, uint8_t const* buff) {\n  /* load modulator */\n  timbre->modulator_E862 = buff[3]; /* wave select */\n  timbre->modulator_E862 <<= 8;\n  timbre->modulator_E862 |= buff[2]; /* sust/release */\n  timbre->modulator_E862 <<= 8;\n  timbre->modulator_E862 |= buff[1]; /* attack/decay */\n  timbre->modulator_E862 <<= 8;\n  timbre->modulator_E862 |= buff[0]; /* AM/VIB... flags */\n  /* load carrier */\n  timbre->carrier_E862 = buff[10]; /* wave select */\n  timbre->carrier_E862 <<= 8;\n  timbre->carrier_E862 |= buff[9]; /* sust/release */\n  timbre->carrier_E862 <<= 8;\n  timbre->carrier_E862 |= buff[8]; /* attack/decay */\n  timbre->carrier_E862 <<= 8;\n  timbre->carrier_E862 |= buff[7]; /* AM/VIB... flags */\n  /* load KSL */\n  timbre->modulator_40 = ( buff[5] & 0x3f ) | ( buff[4] & 0xc0 );\n  timbre->carrier_40 = ( buff[12] & 0x3f ) | ( buff[11] & 0xc0 );\n  /* feedconn & finetune */\n  timbre->feedconn = buff[6];\n  timbre->finetune = 0;\n  timbre->noteoffset = (int16_t)(buff[14] | ((uint16_t)buff[15] << 8));\n}\n\nint opl_loadbank_op2(opl_t* opl, void const* data, int size ) {\n  if( size < 8 + 36 * 175 ) {\n      return -3;\n  }\n  uint8_t const* buff = (uint8_t const*) data;\n  int i;\n  /* file must start with an #OPL_II# header */\n  if ((buff[0] != '#') || (buff[1] != 'O') || (buff[2] != 'P') || (buff[3] != 'L') || (buff[4] != '_') || (buff[5] != 'I') || (buff[6] != 'I') || (buff[7] != '#')) {\n    return(-3);\n  }\n  buff += 8;\n  \n  opl->is_op2 = 1;\n\n  /* load 128 instruments from the IBK file */\n  for (i = 0; i < 175; i++) {\n    /* load instruments */\n    \n    /* OP2 instrument header */\n    opl->op2_flags[i] = (enum op2_flags_t)( buff[0] | ((uint16_t)buff[1] << 8) );\n    int finetune = buff[2];\n    uint8_t fixednote = buff[3];\n    buff += 4;\n    \n    /* first voice */\n    opl_load_op2_voice(&opl->opl_gmtimbres[i], buff);\n    opl->opl_gmtimbres[i].notenum = fixednote;\n    buff += 16;\n\n    /* second voice */\n    opl_load_op2_voice(&opl->opl_gmtimbres_voice2[i], buff);\n    opl->opl_gmtimbres_voice2[i].notenum = fixednote;\n    opl->opl_gmtimbres_voice2[i].finetune += finetune - 128;\n    buff += 16;\n  }\n  /* close file and return success */\n  return(0);\n}\n\n\n\n#endif /* OPL_IMPLEMENTATION */\n\n/*\nOPL_EMU parts are from https://github.com/aaronsgiles/ymfm\nLicense:\n\nBSD 3-Clause License\n\nCopyright (c) 2021, Aaron Giles\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n/*\nOther parts are from http://dosmid.sourceforge.net\nLicense:\n\nLibrary to access OPL2/OPL3 hardware (YM3812 / YMF262)\n\nCopyright (C) 2015-2016 Mateusz Viste\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n*/\n\n"
        },
        {
          "name": "paldither.h",
          "type": "blob",
          "size": 19.4072265625,
          "content": "/*\n------------------------------------------------------------------------------\n\t\t  Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\npaldither.h - v0.1 - Convert true-color image to custom palette, with dither.\n\nDo this:\n\t#define PALDITHER_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef paldither_h\n#define paldither_h\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <stddef.h>\n\n#ifndef PALDITHER_U32\n\t#define PALDITHER_U32 unsigned int\n#endif\n\n#ifndef PALDITHER_U8\n\t#define PALDITHER_U8 unsigned char\n#endif\n\n\ntypedef enum paldither_type_t\n\t{\n\tPALDITHER_TYPE_DEFAULT,\n\tPALDITHER_TYPE_BAYER,\n\tPALDITHER_TYPE_NONE,\n\t} paldither_type_t;\n\n\ntypedef struct paldither_palette_t\n\t{\n\tvoid* memctx;\n\tint color_count;\n\tPALDITHER_U32 colortable[ 256 ];\n\t} paldither_palette_t;\n\npaldither_palette_t* paldither_palette_create( PALDITHER_U32 const* xbgr, int count, size_t* palette_size, void* memctx );\npaldither_palette_t* paldither_palette_create_from_data( void const* data, size_t size, void* memctx );\n\nvoid paldither_palette_destroy( paldither_palette_t* palette );\n\nvoid paldither_palettize( PALDITHER_U32* abgr, int width, int height, paldither_palette_t const* palette, \n\tpaldither_type_t dither_type, PALDITHER_U8* output );\n\n#endif /* paldither_h */\n\n\n/*\n----------------------\n\tIMPLEMENTATION\n----------------------\n*/\n\n#ifdef PALDITHER_IMPLEMENTATION\n#undef PALDITHER_IMPLEMENTATION\n\n#ifndef PALDITHER_MALLOC\n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <stdlib.h>\n\t#if defined(__cplusplus)\n\t\t#define PALDITHER_MALLOC( ctx, size ) ( ::malloc( size ) )\n\t\t#define PALDITHER_FREE( ctx, ptr ) ( ::free( ptr ) )\n\t#else\n\t\t#define PALDITHER_MALLOC( ctx, size ) ( malloc( size ) )\n\t\t#define PALDITHER_FREE( ctx, ptr ) ( free( ptr ) )\n\t#endif\n#endif\n\n#ifndef PALDITHER_ASSERT\n\t#undef _CRT_NONSTDC_NO_DEPRECATE \n\t#define _CRT_NONSTDC_NO_DEPRECATE \n\t#undef _CRT_SECURE_NO_WARNINGS\n\t#define _CRT_SECURE_NO_WARNINGS\n\t#include <assert.h>\n\t#define PALDITHER_ASSERT( expression, message ) assert( ( expression ) && ( message ) )\n#endif\n\n#include <stdlib.h>\n\n\ntypedef struct paldither_mix_t\n\t{\n\tint first;\n\tint second;\n\tint d;\n\tunsigned char ratio;\n\tunsigned char r;\n\tunsigned char g;\n\tunsigned char b;\n\tunsigned char l;\n\t} paldither_mix_t;\n\n\nstatic void paldither_internal_mix( void* memctx, PALDITHER_U32 const* xbgr, int count, int mix_levels,\n\tpaldither_mix_t** out_mix, int* out_mix_count )\n\t{\n\t(void) memctx;\n\n\tint mix_count = ( ( count / 2 ) * ( count + 1 ) ) * mix_levels;\n\tpaldither_mix_t* mix = (paldither_mix_t*) PALDITHER_MALLOC( memctx, mix_count * sizeof( paldither_mix_t ) );\n\n\tint c = 0;\n\tfor( int i = 0; i < count; ++i )\n\t\t{\n\t\tPALDITHER_U32 fcolor = xbgr[ i ] & 0x00ffffff;\n\t\tint fr = (int)( ( fcolor & 0x000000ff ) );\n\t\tint fg = (int)( ( fcolor & 0x0000ff00 ) >> 8 );\n\t\tint fb = (int)( ( fcolor & 0x00ff0000 ) >> 16 );                \n\t\tint fl = (int)( ( 54 * fr + 183 * fg + 19 * fb + 127 ) >> 8 );\n\t\tPALDITHER_ASSERT( fl <= 0xff && fl >= 0, \"Value out of range\" );          \n\n\t\tfor( int j = i + 1; j < count; ++j )\t\n\t\t\t{\n\t\t\tPALDITHER_U32 scolor = xbgr[ j ] & 0x00ffffff;\n\t\t\tint sr = (int)( ( scolor & 0x000000ff ) );\n\t\t\tint sg = (int)( ( scolor & 0x0000ff00 ) >> 8 );\n\t\t\tint sb = (int)( ( scolor & 0x00ff0000 ) >> 16 );                \n\t\t\tint sl = (int)( ( 54 * sr + 183 * sg + 19 * sb + 127 ) >> 8 );\n\t\t\tPALDITHER_ASSERT( sl <= 0xff && sl >= 0, \"Value out of range\" );                   \n\n\t\t\tint dr = fr - sr;\n\t\t\tint dg = fg - sg;\n\t\t\tint db = fb - sb;\n\t\t\tint dl = fl - sl;\n\t\t\tint d = ( ( ( ( dr*dr + dg*dg + db*db ) >> 1 ) + dl*dl ) + 127 ) >> 8;\n\t   \n\t\t\tfor( int k = 0; k < mix_levels; ++k )\t\n\t\t\t\t{\n\t\t\t\tint r = fr;\n\t\t\t\tint g = fg;\n\t\t\t\tint b = fb;\n\t\t\t\tint l = fl;\n\t\t\t\tif( mix_levels > 1 )\n\t\t\t\t\t{\n\t\t\t\t\tint s = mix_levels - 1;\n\t\t\t\t\tint ik = s - k;                    \n\t\t\t\t\tr = ( r * ik + sr * k + ( mix_levels / 2 ) ) / s;\n\t\t\t\t\tg = ( g * ik + sg * k + ( mix_levels / 2 ) ) / s;\n\t\t\t\t\tb = ( b * ik + sb * k + ( mix_levels / 2 ) ) / s;\n\t\t\t\t\tl = ( 54 * r + 183 * g + 19 * b  + 127 ) >> 8;\n\t\t\t\t\tPALDITHER_ASSERT( r <= 0xff && g <= 0xff && b <= 0xff && r >= 0 && g >= 0 && b >= 0 && l <= 0xff && l >= 0, \"Value out of range\" );                   \n\t\t\t\t\t}\n\n\t\t\t\tmix[ c ].first = i;\n\t\t\t\tmix[ c ].second = j;\n\t\t\t\tmix[ c ].ratio = (unsigned char) k;\n\t\t\t\tmix[ c ].r = (unsigned char) r;\n\t\t\t\tmix[ c ].g = (unsigned char) g;\n\t\t\t\tmix[ c ].b = (unsigned char) b;\n\t\t\t\tmix[ c ].l = (unsigned char) l;\n\t\t\t\tmix[ c ].d = d;\n\t\t\t\t++c;\n\t\t\t\tPALDITHER_ASSERT( mix_count >= c, \"Out of range\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t*out_mix = mix;\n\t*out_mix_count = c;\n\t}\n\n\nstatic void paldither_internal_list( void* memctx, paldither_mix_t* mix, int mix_count,\n\tint out_map[ 16 * 16 * 16 ], int** out_list, int* out_list_count )\n\t{\n\t(void) memctx;\n\tint cube[ 17 * 17 * 17 ];\t\n\tfor( int r = 0; r < 17; ++r )\n\t\t{\n\t\tfor( int g = 0; g < 17; ++g )\n\t\t\t{\n\t\t\tfor( int b = 0; b < 17; ++b )\n\t\t\t\t{\n\t\t\t\tint best_diff = 0x7FFFFFFF;\n\t\t\t\tint best_mix = 0;\n\t\t\t\tpaldither_mix_t const* m = mix;\n\t\t\t\tint l = ( 54 * (r * 16) + 183 * (g * 16) + 19 * (b * 16) + 127 ) >> 8;\n\t\t\t\tfor( int i = 0; i < mix_count; ++i, ++m )\n\t\t\t\t\t{\n\t\t\t\t\tint dr = r * 16 - m->r;\n\t\t\t\t\tint dg = g * 16 - m->g;\n\t\t\t\t\tint db = b * 16 - m->b;\n\t\t\t\t\tint dl = l - m->l;\n\t\t\t\t\tint d = ( ( ( dr*dr + dg*dg + db*db ) >> 1 ) + dl*dl) + ( m->d * 3 );\n\t\t\t\t\tif( i == 0 || d < best_diff ) { best_diff = d; best_mix = i; }\n\t\t\t\t\t}\n\t\t\t\tcube[ r * 17 * 17 + g * 17 + b ] = best_mix;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tint map[ 16 * 16 * 16 ];\n\tint list_capacity = mix_count * 256;\n\tint* list = (int*) PALDITHER_MALLOC( memctx, list_capacity * sizeof( int ) );\n\tint list_count = 0;\n\t\n\tint* mapptr = map;\n\tfor( int r = 0; r < 16; ++r )\n\t\t{\n\t\tfor( int g = 0; g < 16; ++g )\n\t\t\t{\n\t\t\tfor( int b = 0; b < 16; ++b )\n\t\t\t\t{\n\t\t\t\tpaldither_mix_t const* m = mix;\n\t\t\t\t*mapptr++ = list_count;\n\t\t\t\tif( list_count == list_capacity ) \n\t\t\t\t\t{ \n\t\t\t\t\tlist_capacity *= 2; \n\t\t\t\t\tint* new_list = (int*) PALDITHER_MALLOC( memctx, list_capacity * sizeof( int ) ); \n\t\t\t\t\tmemcpy( new_list, list, list_count * sizeof( int ) );\n\t\t\t\t\tPALDITHER_FREE( memctx, list );\n\t\t\t\t\tlist = new_list; \n\t\t\t\t\t}\n\t\t\t\tint count_index = list_count++;\n\t\t\t\tlist[ count_index ] = 0;\n\t\t\t\tfor( int i = 0; i < mix_count; ++i, ++m )\n\t\t\t\t\t{\n\t\t\t\t\tpaldither_mix_t const* best_mix = &mix[ cube[ ( r ) * 17 * 17 + ( g ) * 17 + ( b ) ] ];\n\t\t\t\t\tpaldither_mix_t const* best_mix2 = &mix[ cube[ ( r + 1 ) * 17 * 17 + ( g + 1 ) * 17 + ( b + 1 ) ] ];\n\t\t\t\t\tint pass = \t\t\t\t\n\t\t\t\t\t    ( m->r >= best_mix->r && m->r <= best_mix2->r )\n\t\t\t\t\t && ( m->g >= best_mix->g && m->g <= best_mix2->g )\n\t\t\t\t\t && ( m->b >= best_mix->b && m->b <= best_mix2->b );\n\t\t\t\t\tif( pass ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tlist[ count_index ]++;\n\t\t\t\t\t\tif( list_count == list_capacity ) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tlist_capacity *= 2; \n\t\t\t\t\t\t\tint* new_list = (int*) PALDITHER_MALLOC( memctx, list_capacity * sizeof( int ) ); \n\t\t\t\t\t\t\tmemcpy( new_list, list, list_count * sizeof( int ) );\n\t\t\t\t\t\t\tPALDITHER_FREE( memctx, list );\n\t\t\t\t\t\t\tlist = new_list; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tlist[ list_count++ ] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tmemcpy( out_map, map, sizeof( map ) );\n\t*out_list = list;\n\t*out_list_count = list_count;\n\t}\n\n\npaldither_palette_t* paldither_palette_create( PALDITHER_U32 const* xbgr, int count, size_t* palette_size, void* memctx )\n\t{\t\n\t(void) memctx;\n\n\tint default_mix_count;\n\tpaldither_mix_t* default_mix;\n\tpaldither_internal_mix( memctx, xbgr, count, 11, &default_mix, &default_mix_count );\n\n\tint default_map[ 16 * 16 * 16 ];\n\tint* default_list;\n\tint default_list_count = 0;\n\tpaldither_internal_list( memctx, default_mix, default_mix_count, default_map, &default_list, &default_list_count );\n\t\n\tint bayer_mix_count;\n\tpaldither_mix_t* bayer_mix;\n\tpaldither_internal_mix( memctx, xbgr, count, 17, &bayer_mix, &bayer_mix_count );\n\n\tint bayer_map[ 16 * 16 * 16 ];\n\tint* bayer_list;\n\tint bayer_list_count = 0;\n\tpaldither_internal_list( memctx, bayer_mix, bayer_mix_count, bayer_map, &bayer_list, &bayer_list_count );\n\n\tint nodither_mix_count;\n\tpaldither_mix_t* nodither_mix;\n\tpaldither_internal_mix( memctx, xbgr, count, 1, &nodither_mix, &nodither_mix_count );\n\n\tint nodither_map[ 16 * 16 * 16 ];\n\tint* nodither_list;\n\tint nodither_list_count = 0;\n\tpaldither_internal_list( memctx, nodither_mix, nodither_mix_count, nodither_map, &nodither_list, &nodither_list_count );\n\n\tsize_t size = sizeof( paldither_palette_t ) + \n\t\tsizeof( int ) + default_list_count * sizeof( int ) + \n\t\tsizeof( int ) + default_mix_count * sizeof( paldither_mix_t ) + \n\t\tsizeof( default_map ) +\n\t\tsizeof( int ) + bayer_list_count * sizeof( int ) + \n\t\tsizeof( int ) + bayer_mix_count * sizeof( paldither_mix_t ) + \n\t\tsizeof( bayer_map ) +\n\t\tsizeof( int ) + nodither_list_count * sizeof( int ) + \n\t\tsizeof( int ) + nodither_mix_count * sizeof( paldither_mix_t ) + \n\t\tsizeof( nodither_map );\t\n\tpaldither_palette_t* palette = (paldither_palette_t*) PALDITHER_MALLOC( memctx, size );\n\tpalette->memctx = memctx;\n\t\n\tpalette->color_count = count;\n\tmemcpy( palette->colortable, xbgr, sizeof( *xbgr ) * count );\n\t\n\tuintptr_t dest = (uintptr_t)( palette + 1) ;\n\n\t*(int*) dest = default_mix_count; dest += sizeof( int );\n\tmemcpy( (void*)dest, default_mix, default_mix_count * sizeof( paldither_mix_t ) );\n\tdest += default_mix_count * sizeof( paldither_mix_t );\n\n\tmemcpy( (void*)dest, default_map, sizeof( default_map ) );\n\tdest += sizeof( default_map );\n\n\t*(int*) dest = default_list_count; dest += sizeof( int );\n\tmemcpy( (void*)dest, default_list, default_list_count * sizeof( int ) );\n\tdest += default_list_count * sizeof( int );\n\n\tPALDITHER_FREE( memctx, default_list );\n\tPALDITHER_FREE( memctx, default_mix );\n\t\n\t*(int*) dest = bayer_mix_count; dest += sizeof( int );\n\tmemcpy( (void*)dest, bayer_mix, bayer_mix_count * sizeof( paldither_mix_t ) );\n\tdest += bayer_mix_count * sizeof( paldither_mix_t );\n\n\tmemcpy( (void*)dest, bayer_map, sizeof( bayer_map ) );\n\tdest += sizeof( bayer_map );\n\n\t*(int*) dest = bayer_list_count; dest += sizeof( int );\n\tmemcpy( (void*)dest, bayer_list, bayer_list_count * sizeof( int ) );\n\tdest += bayer_list_count * sizeof( int );\n\n\tPALDITHER_FREE( memctx, bayer_list );\n\tPALDITHER_FREE( memctx, bayer_mix );\n\n\t*(int*) dest = nodither_mix_count; dest += sizeof( int );\n\tmemcpy( (void*)dest, nodither_mix, nodither_mix_count * sizeof( paldither_mix_t ) );\n\tdest += nodither_mix_count * sizeof( paldither_mix_t );\n\n\tmemcpy( (void*)dest, nodither_map, sizeof( nodither_map ) );\n\tdest += sizeof( nodither_map );\n\n\t*(int*) dest = nodither_list_count; dest += sizeof( int );\n\tmemcpy( (void*)dest, nodither_list, nodither_list_count * sizeof( int ) );\n\tdest += nodither_list_count * sizeof( int );\n\n\tPALDITHER_FREE( memctx, nodither_list );\n\tPALDITHER_FREE( memctx, nodither_mix );\n\t\n\tif( palette_size ) *palette_size = size;\n\treturn palette;\n\t}\n\n\t\npaldither_palette_t* paldither_palette_create_from_data( void const* data, size_t size, void* memctx )\n\t{\n\tpaldither_palette_t* palette = (paldither_palette_t*)PALDITHER_MALLOC( memctx, size );\n\tpalette->memctx = memctx;\n\tmemcpy( &palette->color_count, data, size );\n\treturn palette;\n\t}\n\n\nvoid paldither_palette_destroy( paldither_palette_t* palette )\n\t{\n\tPALDITHER_FREE( palette->memctx, palette );\n\t}\n\n\t\nvoid paldither_palettize( PALDITHER_U32* abgr, int width, int height, paldither_palette_t const* palette, \n\tpaldither_type_t dither_type, PALDITHER_U8* output )\n\t{\n\tunsigned char default_dither_pattern[ 4 * 4 * 11 ] = \n\t    {\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,0,\n\t    0,0,0,1,\n\n\t    1,0,1,0,\n\t    0,1,0,0,\n\t    1,0,1,0,\n\t    0,0,0,1,\n\n\t    1,0,1,0,\n\t    0,1,0,1,\n\t    1,0,1,0,\n\t    0,1,0,1,\n\n\t    1,0,1,0,\n\t    1,1,0,1,\n\t    1,0,1,0,\n\t    0,1,1,1,\n\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\t    1,1,1,1,\n\n\t   };\n\n\tunsigned char bayer_dither_pattern[ 4 * 4 * 17 ] = \n\t    {\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\n\t\t1, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\n\t\t1, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 0,\n\n\t\t1, 0, 1, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 0,\n\n\t\t1, 0, 1, 0,\n\t\t0, 0, 0, 0,\n\t\t1, 0, 1, 0,\n\t\t0, 0, 0, 0,\n\n\t\t1, 0, 1, 0,\n\t\t0, 1, 0, 0,\n\t\t1, 0, 1, 0,\n\t\t0, 0, 0, 0,\n\n\t\t1, 0, 1, 0,\n\t\t0, 1, 0, 0,\n\t\t1, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\n\t\t1, 0, 1, 0,\n\t\t0, 1, 0, 1,\n\t\t1, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\n\t\t1, 0, 1, 0,\n\t\t0, 1, 0, 1,\n\t\t1, 0, 1, 0,\n\t\t0, 1, 0, 1,\n\n\t\t1, 1, 1, 0,\n\t\t0, 1, 0, 1,\n\t\t1, 0, 1, 0,\n\t\t0, 1, 0, 1,\n\n\t\t1, 1, 1, 0,\n\t\t0, 1, 0, 1,\n\t\t1, 0, 1, 1,\n\t\t0, 1, 0, 1,\n\n\t\t1, 1, 1, 1,\n\t\t0, 1, 0, 1,\n\t\t1, 0, 1, 1,\n\t\t0, 1, 0, 1,\n\n\t\t1, 1, 1, 1,\n\t\t0, 1, 0, 1,\n\t\t1, 1, 1, 1,\n\t\t0, 1, 0, 1,\n\n\t\t1, 1, 1, 1,\n\t\t1, 1, 0, 1,\n\t\t1, 1, 1, 1,\n\t\t0, 1, 0, 1,\n\n\t\t1, 1, 1, 1,\n\t\t1, 1, 0, 1,\n\t\t1, 1, 1, 1,\n\t\t0, 1, 1, 1,\n\n\t\t1, 1, 1, 1,\n\t\t1, 1, 1, 1,\n\t\t1, 1, 1, 1,\n\t\t0, 1, 1, 1,\n\n\t\t1, 1, 1, 1,\n\t\t1, 1, 1, 1,\n\t\t1, 1, 1, 1,\n\t\t1, 1, 1, 1,\n\t\t};\n\n\tunsigned char none_dither_pattern[ 4 * 4 * 2 ] = \n\t    {\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t0, 0, 0, 0,\n\t\t};\n\n\n\tuintptr_t ptr = (uintptr_t)( palette + 1 );\n\n\tint default_pal_mix_count = *(int*)ptr; ptr += sizeof( int );\n\tpaldither_mix_t const* default_pal_mix = (paldither_mix_t*) ptr; ptr += default_pal_mix_count * sizeof( paldither_mix_t );\n\tint const* default_pal_map = (int*) ptr; ptr += 16 * 16 * 16 * sizeof( int );\n\tint default_pal_list_count = *(int*)ptr; ptr += sizeof( int );\n\tint const* default_pal_list = (int*) ptr; ptr += default_pal_list_count * sizeof( int );   \n\t\n\tint bayer_pal_mix_count = *(int*)ptr; ptr += sizeof( int );\n\tpaldither_mix_t const* bayer_pal_mix = (paldither_mix_t*) ptr; ptr += bayer_pal_mix_count * sizeof( paldither_mix_t );\n\tint const* bayer_pal_map = (int*) ptr; ptr += 16 * 16 * 16 * sizeof( int );\n\tint bayer_pal_list_count = *(int*)ptr; ptr += sizeof( int );\n\tint const* bayer_pal_list = (int*) ptr; ptr += bayer_pal_list_count * sizeof( int );\n\n\tint nodither_pal_mix_count = *(int*)ptr; ptr += sizeof( int );\n\tpaldither_mix_t const* nodither_pal_mix = (paldither_mix_t*) ptr; ptr += nodither_pal_mix_count * sizeof( paldither_mix_t );\n\tint const* nodither_pal_map = (int*) ptr; ptr += 16 * 16 * 16 * sizeof( int );\n\tint nodither_pal_list_count = *(int*)ptr; ptr += sizeof( int );\n\tint const* nodither_pal_list = (int*) ptr; ptr += nodither_pal_list_count * sizeof( int );\n\t\n\tunsigned char* dither_pattern = default_dither_pattern;\n\tint pal_mix_count = default_pal_mix_count;\n\tpaldither_mix_t const* pal_mix = default_pal_mix;\n\tint const* pal_map = default_pal_map;\n\tint const* pal_list = default_pal_list;   \n\n\tif( dither_type == PALDITHER_TYPE_BAYER )\n\t\t{\n\t\tdither_pattern = bayer_dither_pattern;\n\t\tpal_mix_count = bayer_pal_mix_count;\n\t    pal_mix = bayer_pal_mix;\n\t    pal_map = bayer_pal_map;\n\t    pal_list = bayer_pal_list;   \n\t\t}\n\telse if( dither_type == PALDITHER_TYPE_NONE )\n\t\t{\n\t\tdither_pattern = none_dither_pattern;\n\t\tpal_mix_count = nodither_pal_mix_count;\n\t    pal_mix = nodither_pal_mix;\n\t    pal_map = nodither_pal_map;\n\t    pal_list = nodither_pal_list;   \n\t\t}\n\n\tfor( int y = 0; y < height; ++y )\n\t\t{\n\t\tfor( int x = 0; x < width; ++x )\t\n\t\t\t{\n\t\t\tPALDITHER_U32 color = abgr[ x + y * width ];\n\t\t\tint r = (int)( ( color & 0x000000ff ) );\n\t\t\tint g = (int)( ( color & 0x0000ff00 ) >> 8 );\n\t\t\tint b = (int)( ( color & 0x00ff0000 ) >> 16 );                \n\t\t\tint l = (int)( ( 54 * r + 183 * g + 19 * b + 127 ) >> 8 );\n\t\t\tPALDITHER_ASSERT( l <= 0xff && l >= 0, \"Value out of range\" );           \n\n\t\t\tpaldither_mix_t const* best_mix = 0;\n\t\t\tint pal_index = pal_map[ ( r >> 4 ) * 16 * 16 + ( g >> 4 ) * 16 + ( b >> 4 ) ];\n\t\t\tint count = pal_list[ pal_index++ ];\n\t\t\tif( count != 0 )\n\t\t\t\t{\n\t\t\t\tint best_diff = 0x7FFFFFFF;\n\t\t\t\tint const* index = &pal_list[ pal_index ];\n\t\t\t\tfor( int i = 0; i < count; ++i, ++index )\n\t\t\t\t\t{\n\t\t\t\t\tpaldither_mix_t const* m = &pal_mix[ *index ];\n\t\t\t\t\tint dr = r - m->r;\n\t\t\t\t\tint dg = g - m->g;\n\t\t\t\t\tint db = b - m->b;\n\t\t\t\t\tint dl = l - m->l;\n\t\t\t\t\tint d = ( ( ( dr*dr + dg*dg + db*db ) >> 1 ) + dl*dl) + ( m->d * 3 );\n\t\t\t\t\tif( i == 0 || d < best_diff ) { best_diff = d; best_mix = m; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint best_diff = 0x7FFFFFFF;\n\t\t\t\tpaldither_mix_t const* m = pal_mix;\n\t\t\t\tfor( int i = 0; i < pal_mix_count; ++i, ++m )\n\t\t\t\t\t{\n\t\t\t\t\tint dr = r - m->r;\n\t\t\t\t\tint dg = g - m->g;\n\t\t\t\t\tint db = b - m->b;\n\t\t\t\t\tint dl = l - m->l;\n\t\t\t\t\tint d = ( ( ( dr*dr + dg*dg + db*db ) >> 1 ) + dl*dl) + ( m->d * 3 );\n\t\t\t\t\tif( i == 0 || d < best_diff ) { best_diff = d; best_mix = m; }\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tint index = dither_pattern[ best_mix->ratio * 4 * 4 + ( x & 3 ) + ( y & 3 ) * 4 ] ? \n\t\t\t\tbest_mix->second : best_mix->first;\n\t\t\t\t\n\t\t\tif( output) output[ x + y * width ] = (PALDITHER_U8) index;\n\t\t\tabgr[ x + y * width ] = ( abgr[ x + y * width ] & 0xff000000 ) | ( palette->colortable[ index ] & 0x00ffffff );\n\t\t\t}\n\t\t}\n\t}\n\n\n#endif /* PALDITHER_IMPLEMENTATION */\n\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "palettize.h",
          "type": "blob",
          "size": 25.5224609375,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\npalettize.h - v0.1 - Median-cut palette generation and remapping for C/C++.\n\nDo this:\n\t#define PALETTIZE_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef palettize_h\n#define palettize_h\n\n\n#ifndef PALETTIZE_U32\n\t#define PALETTIZE_U32 unsigned int\n#endif\n\n#ifndef PALETTIZE_U16\n\t#define PALETTIZE_U16 unsigned short\n#endif\n\n#ifndef PALETTIZE_U8\n\t#define PALETTIZE_U8 unsigned char\n#endif\n\n\nint palettize_generate_palette_xbgr32( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U32* palette, int palette_size, void* memctx );\n\nvoid palettize_remap_xbgr32( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U32 const* palette, int palette_size, PALETTIZE_U8* output );\n\n\nint palettize_generate_palette_rgb16( PALETTIZE_U16 const* rgb, int width, int height, \n    PALETTIZE_U16* palette, int palette_size, void* memctx );\n\nvoid palettize_remap_rgb16( PALETTIZE_U16 const* rgb, int width, int height, \n    PALETTIZE_U16 const* palette, int palette_size, PALETTIZE_U8* output );\n\n\nint palettize_generate_rgb16_palette_xbgr32( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U16* palette, int palette_size, void* memctx );\n\nvoid palettize_remap_xbgr32_pal16( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U16 const* palette, int palette_size, PALETTIZE_U8* output );\n\n\n#endif /* palettize_h */\n\n/**\n\nExample\n=======\n\nAn example which loads a bitmap, generate a palette from it, and remap the image to that palette:\n\n    #define PALETTIZE_IMPLEMENTATION\n    #include \"palettize.h\n\n    #define STB_IMAGE_IMPLEMENTATION\n    #include \"stb_image.h\"\n\n    #define STB_IMAGE_WRITE_IMPLEMENTATION\n    #include \"stb_image_write.h\"\n\n\tint main( int argc, char** argv )\n\t\t{\n\t\t(void) argc, argv;\n    \n        int w, h, c;\n        PALETTIZE_U32* img = (PALETTIZE_U32*) stbi_load( \"test.png\", &w, &h, &c, 4 );\n    \n        PALETTIZE_U32 pal[ 256 ];\n        int pal_count = palettize_generate_palette_xbgr32( img, w, h, pal, 256, 0 );\n    \n        PALETTIZE_U8* palimg = (PALETTIZE_U8*) malloc( w * h );\n        palettize_remap_xbgr32( img, w, h, pal, pal_count, palimg );\n    \n        for( int i = 0; i < w * h; ++i ) img[ i ] = pal[ palimg[ i ] ];\n        stbi_write_png( \"palettized.png\", w, h, 4, img, w * 4 );\n        free( palimg );\n        stbi_image_free( img );\n\t\t}\n\n\t// pass-through so the program will build with either /SUBSYSTEM:WINDOWS or /SUBSYSTEN:CONSOLE\n\textern \"C\" int __stdcall WinMain( struct HINSTANCE__*, struct HINSTANCE__*, char*, int ) { return main( __argc, __argv ); }\n\n**/\n\n\n\n/*\n----------------------\n\tIMPLEMENTATION\n----------------------\n*/\n\n#ifdef PALETTIZE_IMPLEMENTATION\n#undef PALETTIZE_IMPLEMENTATION\n\n\n#ifndef PALETTIZE_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n\t#include <stdlib.h>\n\t#if defined(__cplusplus)\n\t\t#define PALETTIZE_MALLOC( ctx, size ) ( ::malloc( size ) )\n\t\t#define PALETTIZE_FREE( ctx, ptr ) ( ::free( ptr ) )\n\t#else\n\t\t#define PALETTIZE_MALLOC( ctx, size ) ( malloc( size ) )\n\t\t#define PALETTIZE_FREE( ctx, ptr ) ( free( ptr ) )\n\t#endif\n#endif\n\n\ntypedef struct palettize_internal_rgb_t { PALETTIZE_U8 rgb[ 3 ]; } palettize_internal_rgb_t;\n\n\ntypedef struct palettize_internal_bucket_t\n    {\n    palettize_internal_rgb_t* points;\n    int points_count;\n    palettize_internal_rgb_t min_val;\n    palettize_internal_rgb_t max_val;\n    } palettize_internal_bucket_t;\n\n\nstatic void palettize_internal_bucket_init( palettize_internal_bucket_t* bucket, palettize_internal_rgb_t* points, \n    int points_count )\n    {\n    bucket->points = points;\n    bucket->points_count = points_count;\n\n    for( int j = 0; j < 3; ++j ) bucket->min_val.rgb[ j ] = bucket->max_val.rgb[ j ] = bucket->points[ 0 ].rgb[ j ];\n\n    for( int i = 1; i < bucket->points_count; ++i )\n        {\n        for( int j = 0; j < 3; ++j )\n            {\n            bucket->min_val.rgb[ j ] = bucket->min_val.rgb[ j ] < bucket->points[ i ].rgb[ j ] ? \n                bucket->min_val.rgb[ j ] : bucket->points[ i ].rgb[ j ];\n            bucket->max_val.rgb[ j ] = bucket->max_val.rgb[ j ] > bucket->points[ i ].rgb[ j ] ? \n                bucket->max_val.rgb[ j ] : bucket->points[ i ].rgb[ j ];\n            }\n        }\n    }\n\n\nstatic int palettize_internal_bucket_largest_range( palettize_internal_bucket_t const* bucket )\n    {\n    int m = bucket->max_val.rgb[ 0 ] - bucket->min_val.rgb[ 0 ];\n    int max_index = 0;\n    for( int i = 1; i < 3; ++i )\n        {\n        int diff = bucket->max_val.rgb[ i ] - bucket->min_val.rgb[ i ];\n        if( diff > m ) { m = diff; max_index = i; }\n        }\n    return max_index;\n    }\n\n\nstatic int palettize_internal_bucket_compare( palettize_internal_bucket_t const* a, \n    palettize_internal_bucket_t const* b ) \n    {\n    int i = palettize_internal_bucket_largest_range( a );\n    int j = palettize_internal_bucket_largest_range( b );\n    int ra = a->max_val.rgb[ i ] - a->min_val.rgb[ i ];\n    int rb = b->max_val.rgb[ j ] - b->min_val.rgb[ j ];\n    return ra < rb ? -1 : ra > rb ? 1 : 0; \n    }\n\n\ntypedef struct palettize_internal_priority_queue_t\n    {\n    palettize_internal_bucket_t* elements;\n    int capacity;\n    int count;\n    } palettize_internal_priority_queue_t;\n\n\nstatic void priority_queue_push( palettize_internal_priority_queue_t* queue, palettize_internal_bucket_t const* value )\n    {\n    PALDITHER_ASSERT( queue->count < queue->capacity, \"Priority queue overflow\" );\n    if( queue->count >= queue->capacity ) return;\n    queue->elements[ queue->count++ ] = *value;\n\tint index = queue->count;\n\twhile( index > 1 && \n        palettize_internal_bucket_compare( &queue->elements[ index - 1 ], &queue->elements[ index / 2 - 1 ] ) > 0 )\n\t\t{\n\t\tpalettize_internal_bucket_t temp = queue->elements[ index / 2 - 1 ];\n\t\tqueue->elements[ index / 2 - 1 ] = queue->elements[ index - 1 ];\n\t\tqueue->elements[ index - 1 ] = temp;\n\t\tindex /=2;\n\t\t}\n    }\n\n\nstatic void priority_queue_pop( palettize_internal_priority_queue_t* queue )\n    {\n\tif( queue->count == 0 ) return;\n    queue->elements[ 0 ] = queue->elements[ --queue->count ];\n\tint v = 1;\n\tint u = 0;\n\twhile( u != v)\n\t\t{\n\t\tu = v;\t\t\n\t\tif( 2 * u + 1 <= queue->count ) \n\t\t\t{\n\t\t\tif( palettize_internal_bucket_compare( &queue->elements[ u - 1 ], &queue->elements[ 2 * u - 1 ] ) <= 0 ) \n                v = 2 * u;\n\t\t\tif( palettize_internal_bucket_compare( &queue->elements[ v - 1 ], &queue->elements[ 2 * u + 1 - 1 ] ) <= 0 ) \n                v = 2 * u + 1;\n\t\t\t}\n\t\telse if ( 2 * u <= queue->count )\n\t\t\t{\t\t\t\n\t\t\tif( palettize_internal_bucket_compare( &queue->elements[ u - 1 ], &queue->elements[ 2 * u - 1 ] ) <= 0 ) \n                v = 2 * u;\n\t\t\t}\n\n\t\tif( u != v )\n\t\t\t{\n\t\t\tpalettize_internal_bucket_t temp = queue->elements[ u - 1 ];\n\t\t\tqueue->elements[ u - 1 ] = queue->elements[ v - 1 ];\n\t\t\tqueue->elements[ v - 1 ] = temp;\n\t\t\t}\n\t\t}\n\t}\n\n\t\nstatic void palettize_internal_nth_element(palettize_internal_rgb_t* first, palettize_internal_rgb_t* nth, \n    palettize_internal_rgb_t* last, int index) \n    {\n    while( last - first > 3 ) \n        {\n        palettize_internal_rgb_t const* a = first; \n        palettize_internal_rgb_t const* b = first + ( last - first ) / 2;\n        palettize_internal_rgb_t const* c = last - 1;\n        palettize_internal_rgb_t const* pivot;\n        if( a->rgb[ index ] < b->rgb[ index ] )\n            pivot = b->rgb[ index ] < c->rgb[ index ] ? b : a->rgb[ index ] < c->rgb[ index ] ? c : a;\n        else \n            pivot = a->rgb[ index ] < c->rgb[ index ]  ? a : b->rgb[ index ] < c->rgb[ index ] ? c : b;\n   \n        palettize_internal_rgb_t* part_first = first;\n        palettize_internal_rgb_t* part_last = last;\n        palettize_internal_rgb_t* cut;\n        for( ; ; ) \n            {\n            while( part_first->rgb[ index ] < pivot->rgb[ index ] ) ++part_first;\n            --part_last;\n            while( pivot->rgb[ index ] < part_last->rgb[ index ] ) --part_last;\n            if( part_first >= part_last ) { cut = part_first; break; }  \n            palettize_internal_rgb_t tmp = *part_first; *part_first = *part_last; *part_last = tmp;\n            ++part_first;\n            }  \n        if( cut <= nth ) first = cut; else  last = cut;\n        }\n\n    if( first == last ) return;\n    for( palettize_internal_rgb_t* i = first + 1; i != last; ++i ) \n        {\n        if( i->rgb[ index ] < first->rgb[ index ] ) \n            {\n            palettize_internal_rgb_t* copy_last = i;\n            palettize_internal_rgb_t* copy_result = i + 1;\n            while( first != copy_last ) *( --copy_result ) = *( --copy_last );\n            *first = *i;\n            }\n        else \n            {\n            palettize_internal_rgb_t* ins_last = i;\n            palettize_internal_rgb_t* next = ins_last;\n            --next;  \n            while( i->rgb[ index ] < next->rgb[ index ] ) { *ins_last = *next; ins_last = next; --next; }\n            *ins_last = *i;\n            }\n        }\n    }\n\n\nstatic int palettize_internal_median_cut(palettize_internal_rgb_t* image, int points_count, \n    palettize_internal_bucket_t* work_mem, int desired_size,  palettize_internal_rgb_t* output )\n    {\n    palettize_internal_priority_queue_t bucket_queue;\n    bucket_queue.count = 0;\n    bucket_queue.capacity = desired_size;\n    bucket_queue.elements = work_mem;\n\n    palettize_internal_bucket_t initial_bucket;\n    palettize_internal_bucket_init( &initial_bucket, image, points_count );\n\n    priority_queue_push( &bucket_queue, &initial_bucket );\n    while( bucket_queue.count > 0 && bucket_queue.elements[ 0 ].points_count > 1 )\n        {\n        if( bucket_queue.count >= desired_size ) break;\n        palettize_internal_bucket_t largest_range_bucket = bucket_queue.elements[ 0 ];\n\n        priority_queue_pop( &bucket_queue );\n        palettize_internal_rgb_t * begin = largest_range_bucket.points;\n\t    palettize_internal_rgb_t * median = largest_range_bucket.points + ( largest_range_bucket.points_count + 1 ) / 2;\n\t    palettize_internal_rgb_t * end = largest_range_bucket.points + largest_range_bucket.points_count;\n\n\t    switch( palettize_internal_bucket_largest_range( &largest_range_bucket ) )\n\t        {\n\t        case 0: palettize_internal_nth_element( begin, median, end, 0 ); break;\n\t        case 1: palettize_internal_nth_element( begin, median, end, 1 ); break;\n\t        case 2: palettize_internal_nth_element( begin, median, end, 2 ); break;\n\t        }\n\n\t    palettize_internal_bucket_t bucket1;\n        palettize_internal_bucket_init( &bucket1, begin, (int)( median-begin ) );\n        priority_queue_push( &bucket_queue, &bucket1);\n\n        palettize_internal_bucket_t bucket2;\n        palettize_internal_bucket_init( &bucket2, median, (int)( end-median ) );\n        priority_queue_push( &bucket_queue, &bucket2);\n        }\n\n    int result = 0;\n    while( bucket_queue.count > 0 )\n        {\n        palettize_internal_bucket_t bucket = bucket_queue.elements[ 0 ];\n        priority_queue_pop( &bucket_queue );\n\n        int sum[ 3 ] = { 0, 0, 0 };\n        for( int i = 0; i < bucket.points_count; ++i )\n            for( int j = 0; j < 3; ++j )\n                sum[ j ] += bucket.points[ i ].rgb[ j ];\n\n        if( bucket.points_count )\n            {\n        palettize_internal_rgb_t average;\n        for( int j = 0; j < 3; ++j ) average.rgb[ j ] = (PALETTIZE_U8) ( sum[ j ] / bucket.points_count );\n\n        output[ result++ ] = average;\n        }\n        }\n\n    return result;\n    }\n\n\nint palettize_generate_palette_xbgr32( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U32* palette, int palette_size, void* memctx )\n\t{\n    (void) memctx;\n\tint pixel_count = width * height;\n\n    int count = 0;\n    for( int i = 0; i < pixel_count; ++i ) \n        {\n        if( ( xbgr[ i ] >> 24 ) == 0 ) continue;\n        int found = 0;\n        for( int j = 0; j < count; ++j )\n            {\n            if( ( palette[ j ] & 0x00ffffff ) == ( xbgr[ i ] & 0x00ffffff ) )\n                {\n                found = 1;\n                break;\n                }\n            }\n        if( !found ) \n            {\n            if( count >= palette_size ) goto skip;\n            palette[ count++ ] = xbgr[ i ];\n            }\n        }\n\n    return count;\n\nskip: ;\n    size_t malloc_size =  sizeof( palettize_internal_rgb_t ) * ( pixel_count + palette_size );\n    malloc_size += sizeof( palettize_internal_bucket_t ) * palette_size;\n\tpalettize_internal_rgb_t* data = (palettize_internal_rgb_t*) PALETTIZE_MALLOC( memctx, malloc_size );\n\n    int data_size = 0;\n\tfor( int p = 0; p < pixel_count; ++p )\n\t\t{\n\t\tPALETTIZE_U32 color = *xbgr++;\n\t\tPALETTIZE_U8 a = (PALETTIZE_U8 ) ( ( color & 0xff000000 ) >> 24 );\n\t\tif( a > 0 )\n\t\t\t{\n\t\t\tPALETTIZE_U8 b = (PALETTIZE_U8) ( ( color & 0x00ff0000 ) >> 16 );\n\t\t\tPALETTIZE_U8 g = (PALETTIZE_U8) ( ( color & 0x0000ff00 ) >> 8  );\n\t\t\tPALETTIZE_U8 r = (PALETTIZE_U8) ( ( color & 0x000000ff )       );\n\t\t\tdata[ data_size ].rgb[ 0 ] = r;\n\t\t\tdata[ data_size ].rgb[ 1 ] = g;\n\t\t\tdata[ data_size ].rgb[ 2 ] = b;\n\t\t\t++data_size;\n\t\t\t}\n\t\t}\n\tpalettize_internal_rgb_t* result = data + pixel_count;\n    palettize_internal_bucket_t* work_mem = (palettize_internal_bucket_t*) ( data + pixel_count + palette_size );\n\tint result_count = palettize_internal_median_cut( data, data_size, work_mem, palette_size, result );\n\t\n    count = 0;\n\tfor( int i = 0; i < result_count; ++i )\n\t\t{\n\t\tpalettize_internal_rgb_t p = result[ i ];\n\t\tPALETTIZE_U32 c = 0xff000000 | ( p.rgb[ 2 ] << 16 ) | ( p.rgb[ 1 ] << 8 ) | p.rgb[ 0 ];\n\t\tint found = 0;\n\t\tfor( int j = 0; j < count; ++j ) if( palette[ j ] == c ) { found = 1; break; }\n\t\tif( !found ) palette[ count++ ] = c; \n        if( count >= palette_size ) break;\n\t\t}\n\n\tPALETTIZE_FREE( memctx, data );\n\treturn count;\n\t}\n\n\nvoid palettize_remap_xbgr32( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U32 const* palette, int palette_size, PALETTIZE_U8* output )\n\t{\n    for( int y = 0; y < height;  ++y )\n        {\n\t\tfor( int x = 0; x < width; ++x )\n            {\n            PALETTIZE_U32 color = *xbgr++;\n            int best_index = 0;\n            int mindist_sq = 255 * 255 + 255 * 255 + 255 * 255 + 1;\n            for( int i = 0; i < palette_size; ++i ) \n\t\t        {\n\t\t        PALETTIZE_U8 cr = ( (PALETTIZE_U8) ( ( color & 0x00ff0000 ) >> 16 ) );\n\t\t        PALETTIZE_U8 cg = ( (PALETTIZE_U8) ( ( color & 0x0000ff00 ) >> 8  ) );\n\t\t        PALETTIZE_U8 cb = ( (PALETTIZE_U8) ( ( color & 0x000000ff )       )  );\n\t\t        PALETTIZE_U8 pr = ( (PALETTIZE_U8) ( ( palette[ i ] & 0x00ff0000 ) >> 16 ) );\n\t\t        PALETTIZE_U8 pg = ( (PALETTIZE_U8) ( ( palette[ i ] & 0x0000ff00 ) >> 8  ) );\n\t\t        PALETTIZE_U8 pb = ( (PALETTIZE_U8) ( ( palette[ i ] & 0x000000ff )       ) );\n                int dr = ( (int) cr ) - ( (int) pr );\n                int dg = ( (int) cg ) - ( (int) pg );\n                int db = ( (int) cb ) - ( (int) pb );\n                int dist_sq = dr * dr + dg * dg + db * db;\n                if( dist_sq < mindist_sq ) { mindist_sq = dist_sq; best_index = i; }\n\t\t        }\n\t\t\t*output++ = (PALETTIZE_U8) best_index;\n            }\n        }\n    }\n\n\nstatic PALETTIZE_U16 palettize_internal_rgb32_to_rgb16( PALETTIZE_U32 color )\n\t{\n\treturn ((PALETTIZE_U16) ( ((color & 0x00f80000)>>8) | ((color & 0x0000fc00)>>5) | ((color & 0x000000f8)>>3) ));\n\t}\n\n\nstatic PALETTIZE_U32 palettize_internal_rgb16_to_rgb32( PALETTIZE_U16 color )\n\t{\n\treturn (((PALETTIZE_U32)color & 0xf800)<<8) | (((PALETTIZE_U32)color & 0x07e0)<<5) | \n        (((PALETTIZE_U32)color & 0x001f)<<3) | (0xff000000);\n\t}\n\n\nint palettize_generate_palette_rgb16( PALETTIZE_U16 const* rgb, int width, int height, \n    PALETTIZE_U16* palette, int palette_size, void* memctx )\n\t{\n    (void) memctx;\n\tint pixel_count = width * height;\n\n    int count = 0;\n    for( int i = 0; i < pixel_count; ++i ) \n        {\n        int found = 0;\n        for( int j = 0; j < count; ++j )\n            {\n            if( ( palette[ j ] ) == ( rgb[ i ] & 0x00ffffff ) )\n                {\n                found = 1;\n                break;\n                }\n            }\n        if( !found ) \n            {\n            if( count >= palette_size ) goto skip;\n            palette[ count++ ] = rgb[ i ];\n            }\n        }\n\n    return count;\n\nskip: ;\n    size_t malloc_size =  sizeof( palettize_internal_rgb_t ) * ( pixel_count + palette_size );\n    malloc_size += sizeof( palettize_internal_bucket_t ) * palette_size;\n\tpalettize_internal_rgb_t* data = (palettize_internal_rgb_t*) PALETTIZE_MALLOC( memctx, malloc_size );\n\n    int data_size = 0;\n\tfor( int p = 0; p < pixel_count; ++p )\n\t\t{\n\t\tPALETTIZE_U32 color = palettize_internal_rgb16_to_rgb32( *rgb++ );\n\t\tPALETTIZE_U8 a = (PALETTIZE_U8) ( ( color & 0xff000000 ) >> 24 );\n\t\tif( a > 0 )\n\t\t\t{\n\t\t\tPALETTIZE_U8 b = (PALETTIZE_U8) ( ( color & 0x00ff0000 ) >> 16 );\n\t\t\tPALETTIZE_U8 g = (PALETTIZE_U8) ( ( color & 0x0000ff00 ) >> 8  );\n\t\t\tPALETTIZE_U8 r = (PALETTIZE_U8) ( ( color & 0x000000ff )       );\n\t\t\tdata[ data_size ].rgb[ 0 ] = r;\n\t\t\tdata[ data_size ].rgb[ 1 ] = g;\n\t\t\tdata[ data_size ].rgb[ 2 ] = b;\n\t\t\t++data_size;\n\t\t\t}\n\t\t}\n\n\tpalettize_internal_rgb_t* result = data + pixel_count;\n    palettize_internal_bucket_t* work_mem = (palettize_internal_bucket_t*) ( data + pixel_count + palette_size );\n\tint result_count = palettize_internal_median_cut( data, data_size, work_mem, palette_size, result );\n\n    count = 0;\n\tfor( int i = 0; i < result_count; ++i )\n\t\t{\n\t\tpalettize_internal_rgb_t p = result[ i ];\n\t\tPALETTIZE_U16 c = palettize_internal_rgb32_to_rgb16( \n\t\t\t(PALETTIZE_U32)( ( p.rgb[ 2 ] << 16 ) | ( p.rgb[ 1 ] << 8 ) | p.rgb[ 0 ] ) );\n\t\tint found = 0;\n\t\tfor( int j = 0; j < count; ++j ) if( palette[ j ] == c ) { found = 1; break; }\n\t\tif( !found ) palette[ count++ ] = c;\n        if( count >= palette_size ) break;\n\t\t}\n\n\tPALETTIZE_FREE( memctx, data );\n\treturn count;\n\t}\n\n\nvoid palettize_remap_rgb16( PALETTIZE_U16 const* rgb, int width, int height, \n    PALETTIZE_U16 const* palette, int palette_size, PALETTIZE_U8* output )\n\t{\n    for( int y = 0; y < height;  ++y )\n        {\n\t\tfor( int x = 0; x < width; ++x )\n            {\n            PALETTIZE_U32 color = palettize_internal_rgb16_to_rgb32( *rgb++ );\n\t        int best_index = 0;\n            int mindist_sq = 255 * 255 + 255 * 255 + 255 * 255 + 1;\n            for( int i = 0; i < palette_size; ++i ) \n\t\t        {\n\t\t        PALETTIZE_U8 cr = ( (PALETTIZE_U8) ( ( color & 0x00ff0000 ) >> 16 ) );\n\t\t        PALETTIZE_U8 cg = ( (PALETTIZE_U8) ( ( color & 0x0000ff00 ) >> 8  ) );\n\t\t        PALETTIZE_U8 cb = ( (PALETTIZE_U8) ( ( color & 0x000000ff )       ) );\n                PALETTIZE_U32 pal = palettize_internal_rgb16_to_rgb32( palette[ i ] );\n\t\t        PALETTIZE_U8 pr = ( (PALETTIZE_U8) ( ( pal & 0x00ff0000 ) >> 16 ) );\n\t\t        PALETTIZE_U8 pg = ( (PALETTIZE_U8) ( ( pal & 0x0000ff00 ) >> 8  ) );\n\t\t        PALETTIZE_U8 pb = ( (PALETTIZE_U8) ( ( pal & 0x000000ff )       ) );\n                int dr = ( (int) cr) - ( (int) pr );\n                int dg = ( (int) cg) - ( (int) pg );\n                int db = ( (int) cb) - ( (int) pb );\n                int dist_sq = dr * dr + dg * dg + db * db;\n                if( dist_sq < mindist_sq )  { mindist_sq = dist_sq; best_index = i; }\n\t\t        }\n\t\t\t*output++ = (PALETTIZE_U8) best_index;            \n            }\n        }\n\t}\n\n\nint palettize_generate_rgb16_palette_xbgr32( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U16* palette, int palette_size, void* memctx )\n    {\n    (void) memctx;\n\tint pixel_count = width * height;\n\n    int count = 0;\n    for( int i = 0; i < pixel_count; ++i ) \n        {\n        if( ( xbgr[ i ] >> 24 ) == 0 ) continue;\n\t\tPALETTIZE_U16 c = palettize_internal_rgb32_to_rgb16( xbgr[ i ] );\n        int found = 0;\n        for( int j = 0; j < count; ++j )\n            {\n            if( palette[ j ] == c )\n                {\n                found = 1;\n                break;\n                }\n            }\n        if( !found ) \n            {\n            if( count >= palette_size ) goto skip;\n            palette[ count++ ] = c;\n            }\n        }\n\n    return count;\n\nskip: ;\n    size_t malloc_size =  sizeof( palettize_internal_rgb_t ) * ( pixel_count + palette_size );\n    malloc_size += sizeof( palettize_internal_bucket_t ) * palette_size;\n\tpalettize_internal_rgb_t* data = (palettize_internal_rgb_t*) PALETTIZE_MALLOC( memctx,  malloc_size );\n\n    int data_size = 0;\n\tfor( int p = 0; p < pixel_count; ++p )\n\t\t{\n\t\tPALETTIZE_U32 color = *xbgr++;\n\t\tPALETTIZE_U8 a = (PALETTIZE_U8) ( ( color & 0xff000000 ) >>24 );\n\t\tif( a > 0 )\n\t\t\t{\n\t\t\tcolor = palettize_internal_rgb16_to_rgb32( palettize_internal_rgb32_to_rgb16( color ) );\n\t\t\tPALETTIZE_U8 b = (PALETTIZE_U8) ( ( color & 0x00ff0000 ) >> 16 );\n\t\t\tPALETTIZE_U8 g = (PALETTIZE_U8) ( ( color & 0x0000ff00 ) >> 8  );\n\t\t\tPALETTIZE_U8 r = (PALETTIZE_U8) ( ( color & 0x000000ff )       );\n\t\t\tdata[ data_size ].rgb[ 0 ] = r;\n\t\t\tdata[ data_size ].rgb[ 1 ] = g;\n\t\t\tdata[ data_size ].rgb[ 2 ] = b;\n\t\t\t++data_size;\n\t\t\t}\n\t\t}\n\tpalettize_internal_rgb_t* result = data + pixel_count;\n    palettize_internal_bucket_t* work_mem = (palettize_internal_bucket_t*) ( data + pixel_count + palette_size );\n\tint result_count = palettize_internal_median_cut( data, data_size, work_mem, palette_size, result );\n\t\n    count = 0;\n\tfor( int i = 0; i < result_count; ++i )\n\t\t{\n\t\tpalettize_internal_rgb_t p = result[ i ];\n\t\tPALETTIZE_U16 c = palettize_internal_rgb32_to_rgb16( \n\t\t\t(PALETTIZE_U32)( ( p.rgb[ 2 ] << 16 ) | ( p.rgb[ 1 ] << 8 ) | p.rgb[ 0 ] ) );\n\t\tint found = 0;\n\t\tfor( int j= 0; j < count; ++j ) if( palette[ j ] == c ) { found = 1; break; }\n\t\tif( !found ) palette[ count++ ] = c;\n        if( count >= palette_size ) break;\n\t\t}\n\n\tPALETTIZE_FREE( memctx, data );\n\treturn count;\n    }\n\n\nvoid palettize_remap_xbgr32_pal16( PALETTIZE_U32 const* xbgr, int width, int height, \n    PALETTIZE_U16 const* palette, int palette_size, PALETTIZE_U8* output )\n    {\n    for( int y = 0; y < height;  ++y )\n        {\n\t\tfor( int x = 0; x < width; ++x )\n            {\n            PALETTIZE_U32 color = *xbgr++;\n            int best_index = 0;\n            int mindist_sq = 255 * 255 + 255 * 255 + 255 * 255 + 1;\n            for( int i = 0; i < palette_size; ++i ) \n\t\t        {\n\t\t        PALETTIZE_U8 cr = ( (PALETTIZE_U8) ( ( color & 0x00ff0000 ) >> 16 ) );\n\t\t        PALETTIZE_U8 cg = ( (PALETTIZE_U8) ( ( color & 0x0000ff00 ) >> 8  ) );\n\t\t        PALETTIZE_U8 cb = ( (PALETTIZE_U8) ( ( color & 0x000000ff )       ) );\n                PALETTIZE_U32 pal = palettize_internal_rgb16_to_rgb32( palette[ i ] );\n\t\t        PALETTIZE_U8 pr = ( (PALETTIZE_U8) ( ( pal & 0x00ff0000 ) >> 16) );\n\t\t        PALETTIZE_U8 pg = ( (PALETTIZE_U8) ( ( pal & 0x0000ff00 ) >> 8 ) );\n\t\t        PALETTIZE_U8 pb = ( (PALETTIZE_U8) ( ( pal & 0x000000ff )      ) );\n                int dr = ( (int) cr) - ( (int) pr );\n                int db = ( (int) cb) - ( (int) pb );\n                int dg = ( (int) cg) - ( (int) pg );\n                int dist_sq = dr * dr + dg * dg + db * db;\n                if( dist_sq < mindist_sq ) { mindist_sq = dist_sq; best_index = i; }\n\t\t        }\n\t\t\t*output++ = (PALETTIZE_U8) best_index;\n            }\n        }\n    }\n\n#endif /* PALETTIZE_IMPLEMENTATION */\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2017 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "palrle.h",
          "type": "blob",
          "size": 17.31640625,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\npalrle.h - v0.1 - Run-length encoding of palettized bitmaps, for C/C++.\n\nDo this:\n    #define PALRLE_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef palrle_h\n#define palrle_h\n\n#ifndef PALRLE_U8\n    #define PALRLE_U8 unsigned char\n#endif\n#ifndef PALRLE_U16\n    #define PALRLE_U16 unsigned short\n#endif\n#ifndef PALRLE_U32\n    #define PALRLE_U32 unsigned int\n#endif\n\ntypedef struct palrle_data_t {\n    PALRLE_U32 size;\n    PALRLE_U16 width;\n    PALRLE_U16 height;\n    PALRLE_U16 xoffset;\n    PALRLE_U16 yoffset;\n    PALRLE_U16 hpitch;\n    PALRLE_U16 vpitch;\n    PALRLE_U16 palette_count;\n    PALRLE_U8 data[ 1 ]; // \"open\" array\n} palrle_data_t;\n\npalrle_data_t* palrle_encode( PALRLE_U8* pixels, int width, int height, PALRLE_U32* palette, int palette_count, void* memctx );\npalrle_data_t* palrle_encode_mask( PALRLE_U8* pixels, PALRLE_U8* mask, int width, int height, PALRLE_U32* palette, int palette_count, void* memctx );\n//palrle_data_t* palrle_encode_transparency_index( PALRLE_U8* pixels, PALRLE_U8 transparency_index, int width, int height, PALRLE_U32* palette, int palette_count, void* memctx );\n\nvoid palrle_decode( palrle_data_t* rle_data, PALRLE_U8* pixels, PALRLE_U8* mask );\n\nvoid palrle_blit( palrle_data_t* rle_data, int x, int y, PALRLE_U8* pixels, int width, int height );\n\nvoid palrle_free( palrle_data_t* rle_data, void* memctx );\n\n\n#endif /* palrle_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef PALRLE_IMPLEMENTATION\n#undef PALRLE_IMPLEMENTATION\n\n#ifndef PALRLE_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define PALRLE_MALLOC( ctx, size ) ( malloc( size ) )\n    #define PALRLE_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\npalrle_data_t* palrle_encode( PALRLE_U8* pixels, int width, int height, PALRLE_U32* palette, int palette_count, void* memctx ) {\n    (void) memctx;\n\n    int xmin = 0;\n    int xmax = width - 1;\n    int ymin = 0;\n    int ymax = height - 1;\n    int hpitch = xmax - xmin + 1;\n    int vpitch = ymax - ymin + 1;\n\n    // Bitmap is completely empty, so just store the palette and dimensions\n    if( hpitch <= 0 || vpitch <= 0 ) {\n        size_t size = sizeof( palrle_data_t ) - sizeof( PALRLE_U8 ) + sizeof( PALRLE_U32 ) * palette_count;\n        palrle_data_t* data = (palrle_data_t*) PALRLE_MALLOC( memctx, size );\n        data->size = (PALRLE_U32) size;\n        data->width = (PALRLE_U16) width;\n        data->height = (PALRLE_U16) height;\n        data->xoffset = 0;\n        data->yoffset = 0;\n        data->hpitch = 0;\n        data->vpitch = 0;\n        data->palette_count = (PALRLE_U16) palette_count;\n        if( palette ) memcpy( data->data, palette, sizeof( PALRLE_U32 ) * palette_count );\n        return data;\n    }\n\n    palrle_data_t* data = (palrle_data_t*) PALRLE_MALLOC( memctx,\n        sizeof( palrle_data_t ) + // size for the struct itself\n        sizeof( PALRLE_U32 ) * palette_count + // size for storing palette entries\n        sizeof( PALRLE_U32 ) * vpitch + // size for storing the offset for each row\n        hpitch * vpitch * 2 ); // assume worst case - we should never need more than twice the number of pixels\n    memset( data, 0, sizeof( palrle_data_t ) + sizeof( PALRLE_U32 ) * palette_count + sizeof( PALRLE_U32 ) * vpitch +\n        hpitch * vpitch * 2 );\n\n\n    data->size = (PALRLE_U32) ( sizeof( palrle_data_t ) - sizeof( PALRLE_U8 ) );\n    data->width = (PALRLE_U16) width;\n    data->height = (PALRLE_U16) height;\n    data->xoffset = (PALRLE_U16) xmin;\n    data->yoffset = (PALRLE_U16) ymin;\n    data->hpitch = (PALRLE_U16) hpitch;\n    data->vpitch = (PALRLE_U16) vpitch;\n    data->palette_count = (PALRLE_U16) palette_count;\n    if( palette ) memcpy( data->data, palette, sizeof( PALRLE_U32 ) * palette_count );\n\n    int row_offset = (int)( sizeof( PALRLE_U32 ) * palette_count );\n    int rle_offset = (int)( row_offset + sizeof( PALRLE_U32 ) * vpitch );\n    for( int y = 0; y < vpitch; ++y ) {\n        *( (PALRLE_U32*)&data->data[ row_offset ] ) = (PALRLE_U32) rle_offset;\n        row_offset += sizeof( PALRLE_U32 );\n        int x = 0;\n        while( x < hpitch ) {\n            // add empty pixel count\n            data->data[ rle_offset++ ] = (PALRLE_U8) 0;\n\n            // add non-empty pixels\n            int color = pixels[ x + xmin + ( y + ymin ) * width ];\n            int count = 0;\n            int tx = x;\n            while( tx < hpitch ) {\n                if( pixels[ tx + xmin + ( y + ymin ) * width ] != color ) break;\n                if( count >= 127 ) break;\n                ++count;\n                ++tx;\n            }\n\n            if( count == 0 ) {\n                data->data[ rle_offset++ ] = 0;\n                continue;\n            }\n\n            if( count > 2 ) { // store as a run\n                data->data[ rle_offset++ ] = (PALRLE_U8) count; // number of pixels\n                data->data[ rle_offset++ ] = (PALRLE_U8) color; // of palette index `color`\n                x = tx;\n            } else { // store as unique values\n                PALRLE_U8* uniques_out = &data->data[ rle_offset++ ];\n                int uniques = 1;\n                data->data[ rle_offset++ ] = (PALRLE_U8) color;\n                ++x;\n\n                // add pixexls until we encounter a run\n                while( x < hpitch ) {\n                    // check the length of the next run\n                    color = pixels[ x + xmin + ( y + ymin ) * width ];\n                    count = 0;\n                    tx = x;\n                    while( tx < hpitch ) {\n                        if( pixels[ tx + xmin + ( y + ymin ) * width ] != color ) break;\n                        if( count > 2 ) break; // No need to keep counting, we know this is a run\n                        ++count;\n                        ++tx;\n                    }\n                    if( count > 2 || count == 0 ) {\n                        break;\n                    } else {\n                        if( uniques >= 128 ) break;\n                        ++uniques;\n                        data->data[ rle_offset++ ] = (PALRLE_U8) color;\n                        ++x;\n                    }\n                }\n                *uniques_out = (PALRLE_U8)( (char) -uniques );\n            }\n        }\n    }\n    data->size += rle_offset;\n\n    return data;\n}\n\n\npalrle_data_t* palrle_encode_mask( PALRLE_U8* pixels, PALRLE_U8* mask, int width, int height, PALRLE_U32* palette, int palette_count, void* memctx ) {\n    (void) memctx;\n    // Crop to smallest non-empty region\n    int xmin = width;\n    int xmax = 0;\n    int ymin = height;\n    int ymax = 0;\n    for( int y = 0; y < height; ++y ) {\n        for( int x = 0; x < width; ++x ) {\n            if( mask[ x + y * width ] ) {\n                if( x < xmin ) xmin = x;\n                if( y < ymin ) ymin = y;\n                if( x > xmax ) xmax = x;\n                if( y > ymax ) ymax = y;\n            }\n        }\n    }\n    int hpitch = xmax - xmin + 1;\n    int vpitch = ymax - ymin + 1;\n\n    // Bitmap is completely empty, so just store the palette and dimensions\n    if( hpitch <= 0 || vpitch <= 0 ) {\n        size_t size = sizeof( palrle_data_t ) - sizeof( PALRLE_U8 ) + sizeof( PALRLE_U32 ) * palette_count;\n        palrle_data_t* data = (palrle_data_t*) PALRLE_MALLOC( memctx, size );\n        data->size = (PALRLE_U32) size;\n        data->width = (PALRLE_U16) width;\n        data->height = (PALRLE_U16) height;\n        data->xoffset = 0;\n        data->yoffset = 0;\n        data->hpitch = 0;\n        data->vpitch = 0;\n        data->palette_count = (PALRLE_U16) palette_count;\n        if( palette ) memcpy( data->data, palette, sizeof( PALRLE_U32 ) * palette_count );\n        return data;\n    }\n\n    palrle_data_t* data = (palrle_data_t*) PALRLE_MALLOC( memctx,\n        sizeof( palrle_data_t ) + // size for the struct itself\n        sizeof( PALRLE_U32 ) * palette_count + // size for storing palette entries\n        sizeof( PALRLE_U32 ) * vpitch + // size for storing the offset for each row\n        hpitch * vpitch * 2 ); // assume worst case - we should never need more than twice the number of pixels\n    memset( data, 0, sizeof( palrle_data_t ) + sizeof( PALRLE_U32 ) * palette_count + sizeof( PALRLE_U32 ) * vpitch +\n        hpitch * vpitch * 2 );\n\n\n    data->size = (PALRLE_U32) ( sizeof( palrle_data_t ) - sizeof( PALRLE_U8 ) );\n    data->width = (PALRLE_U16) width;\n    data->height = (PALRLE_U16) height;\n    data->xoffset = (PALRLE_U16) xmin;\n    data->yoffset = (PALRLE_U16) ymin;\n    data->hpitch = (PALRLE_U16) hpitch;\n    data->vpitch = (PALRLE_U16) vpitch;\n    data->palette_count = (PALRLE_U16) palette_count;\n    if( palette ) memcpy( data->data, palette, sizeof( PALRLE_U32 ) * palette_count );\n\n    int row_offset = (int)( sizeof( PALRLE_U32 ) * palette_count );\n    int rle_offset = (int)( row_offset + sizeof( PALRLE_U32 ) * vpitch );\n    for( int y = 0; y < vpitch; ++y ) {\n        *( (PALRLE_U32*)&data->data[ row_offset ] ) = (PALRLE_U32) rle_offset;\n        row_offset += sizeof( PALRLE_U32 );\n        int x = 0;\n        while( x < hpitch ) {\n            // add empty pixel count\n            int empty = 0;\n            while( x < hpitch ) {\n                if( mask[ x + xmin + ( y + ymin ) * width ] != 0 ) break;\n                if( empty >= 255 ) {\n                    data->data[ rle_offset++ ] = 255; // 255 empty pixels\n                    data->data[ rle_offset++ ] = 0; // 0 non-empty pixels\n                    empty = 0;\n                }\n                ++empty;\n                ++x;\n            }\n            data->data[ rle_offset++ ] = (PALRLE_U8) empty;\n\n            // add non-empty pixels\n            int color = pixels[ x + xmin + ( y + ymin ) * width ];\n            int count = 0;\n            int tx = x;\n            while( tx < hpitch ) {\n                if( mask[ tx + xmin + ( y + ymin ) * width ] == 0 ) break;\n                if( pixels[ tx + xmin + ( y + ymin ) * width ] != color ) break;\n                if( count >= 127 ) break;\n                ++count;\n                ++tx;\n            }\n\n            if( count == 0 ) {\n                data->data[ rle_offset++ ] = 0;\n                continue;\n            }\n\n            if( count > 2 ) { // store as a run\n                data->data[ rle_offset++ ] = (PALRLE_U8) count; // number of pixels\n                data->data[ rle_offset++ ] = (PALRLE_U8) color; // of palette index `color`\n                x = tx;\n            } else { // store as unique values\n                PALRLE_U8* uniques_out = &data->data[ rle_offset++ ];\n                int uniques = 1;\n                data->data[ rle_offset++ ] = (PALRLE_U8) color;\n                ++x;\n\n                // add pixexls until we encounter a run\n                while( x < hpitch ) {\n                    // check the length of the next run\n                    color = pixels[ x + xmin + ( y + ymin ) * width ];\n                    count = 0;\n                    tx = x;\n                    while( tx < hpitch ) {\n                        if( mask[ tx + xmin + ( y + ymin ) * width ] == 0 ) break;\n                        if( pixels[ tx + xmin + ( y + ymin ) * width ] != color ) break;\n                        if( count > 2 ) break; // No need to keep counting, we know this is a run\n                        ++count;\n                        ++tx;\n                    }\n                    if( count > 2 || count == 0 ) {\n                        break;\n                    } else {\n                        if( uniques >= 128 ) break;\n                        ++uniques;\n                        data->data[ rle_offset++ ] = (PALRLE_U8) color;\n                        ++x;\n                    }\n                }\n                *uniques_out = (PALRLE_U8)( (char) -uniques );\n            }\n        }\n    }\n    data->size += rle_offset;\n\n    return data;\n}\n\n\n/*\npalrle_data_t* palrle_encode_transparency_index( PALRLE_U8* pixels, PALRLE_U8 transparency_index, int width, int height, PALRLE_U32* palette, int palette_count, void* memctx ) {\n    (void) pixels, transparency_index, width, height, memctx;\n    return 0;\n}\n*/\n\n\n\nvoid palrle_decode( palrle_data_t* rle_data, PALRLE_U8* pixels, PALRLE_U8* mask ) {\n    memset( pixels, 0, rle_data->width * rle_data->height * sizeof( PALRLE_U8 ) );\n    if( mask ) memset( mask, 0, rle_data->width * rle_data->height * sizeof( PALRLE_U8 ) );\n    PALRLE_U8* data = &rle_data->data[ sizeof( PALRLE_U32 ) * ( rle_data->palette_count + rle_data->vpitch ) ];\n    for( int y = 0; y < rle_data->vpitch; ++y ) {\n        int x = 0;\n        while( x < rle_data->hpitch ) {\n            x += *data++;\n            char count = (char)( *data++ );\n            if( count > 0 ) {\n                PALRLE_U8 color = *data++;\n                for( int i = 0; i < count; ++i ) {\n                    pixels[ rle_data->xoffset + x + ( rle_data->yoffset + y ) * rle_data->width ] = color;\n                    if( mask ) mask[ rle_data->xoffset + x + ( rle_data->yoffset + y ) * rle_data->width ] = 255;\n                    ++x;\n                }\n            } else {\n                for( int i = 0; i < -count; ++i ) {\n                    pixels[ rle_data->xoffset + x + ( rle_data->yoffset + y ) * rle_data->width ] = *data++;\n                    if( mask ) mask[ rle_data->xoffset + x + ( rle_data->yoffset + y ) * rle_data->width ] = 255;\n                    ++x;\n                }\n            }\n        }\n    }\n}\n\n\nvoid palrle_blit( palrle_data_t* rle_data, int x, int y, PALRLE_U8* pixels, int width, int height ) {\n    PALRLE_U8* data = &rle_data->data[ sizeof( PALRLE_U32 ) * ( rle_data->palette_count + rle_data->vpitch ) ];\n    for( int iy = 0; iy < rle_data->vpitch; ++iy ) {\n        int ix = 0;\n        while( ix < rle_data->hpitch ) {\n            ix += *data++;\n            char count = (char)( *data++ );\n            if( count > 0 ) {\n                PALRLE_U8 color = *data++;\n                for( int i = 0; i < count; ++i ) {\n                    int xp = rle_data->xoffset + ix + x;\n                    int yp = rle_data->yoffset + iy + y;\n                    if( xp > 0 && yp > 0 && xp < width && yp < height ) pixels[ xp + yp * width ] = color;\n                    ++ix;\n                }\n            } else {\n                for( int i = 0; i < -count; ++i ) {\n                    PALRLE_U8 color = *data++;\n                    int xp = rle_data->xoffset + ix + x;\n                    int yp = rle_data->yoffset + iy + y;\n                    if( xp > 0 && yp > 0 && xp < width && yp < height ) pixels[ xp + yp * width ] = color;\n                    ++ix;\n                }\n            }\n        }\n    }\n}\n\n\nvoid palrle_free( palrle_data_t* rle_data, void* memctx ) {\n    (void) rle_data, (void) memctx;\n    PALRLE_FREE( memctx, rle_data );\n}\n\n#endif /* PALRLE_IMPLEMENTATION */\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2019 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "pixelfont.h",
          "type": "blob",
          "size": 18.6376953125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\npixelfont.h - v0.1 - Custom pixel font format builder and renderer.\n\nDo this:\n    #define PIXELFONT_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n\nIf you want to generate pixelfonts through the pixelfont_builder api, do this:\n    #define PIXELFONT_BUILDER_IMPLEMENTATION\nbefore include the file to create the implementation.\n\n*/\n\n#ifndef pixelfont_h\n#define pixelfont_h\n\n#ifndef PIXELFONT_I8\n    #define PIXELFONT_I8 signed char\n#endif\n\n#ifndef PIXELFONT_U8\n    #define PIXELFONT_U8 unsigned char\n#endif\n\n#ifndef PIXELFONT_U32\n    #define PIXELFONT_U32 unsigned int\n#endif\n\ntypedef struct pixelfont_t\n    {\n    PIXELFONT_U32 size_in_bytes;\n    PIXELFONT_U8 height;\n    PIXELFONT_U8 line_spacing;\n    PIXELFONT_U8 baseline;\n    PIXELFONT_U32 offsets[ 256 ];\n    PIXELFONT_U8 glyphs[ 1 ]; // \"open\" array - ok to access out of bounds (use size_in_bytes to determine the end)\n    } pixelfont_t;\n\n\ntypedef enum pixelfont_align_t\n    {\n    PIXELFONT_ALIGN_LEFT,\n    PIXELFONT_ALIGN_RIGHT,\n    PIXELFONT_ALIGN_CENTER,\n    } pixelfont_align_t;\n\n\ntypedef enum pixelfont_bold_t\n    {\n    PIXELFONT_BOLD_OFF,\n    PIXELFONT_BOLD_ON,\n    } pixelfont_bold_t;\n\n\ntypedef enum pixelfont_italic_t\n    {\n    PIXELFONT_ITALIC_OFF,\n    PIXELFONT_ITALIC_ON,\n    } pixelfont_italic_t;\n\n\ntypedef enum pixelfont_underline_t\n    {\n    PIXELFONT_UNDERLINE_OFF,\n    PIXELFONT_UNDERLINE_ON,\n    } pixelfont_underline_t;\n\n\ntypedef struct pixelfont_bounds_t\n    {\n    int width;\n    int height;\n    } pixelfont_bounds_t;\n\n\n\ntypedef struct pixelfont_builder_t pixelfont_builder_t;\n\npixelfont_builder_t* pixelfont_builder_create( int height, int baseline, int line_spacing, void* memctx );\nvoid pixelfont_builder_destroy( pixelfont_builder_t* builder );\n\nvoid pixelfont_builder_glyph( pixelfont_builder_t* builder, int glyph, int pixels_stride, PIXELFONT_U8* pixels, int width, int lead, int trail );\nvoid pixelfont_builder_kerning( pixelfont_builder_t* builder, int glyph, int follower, int adjust );\n\npixelfont_t* pixelfont_builder_font( pixelfont_builder_t* builder );\n\n#endif /* pixelfont_h */\n\n\n// The following will be defined each time the file is included. By defining PIXELFONT_COLOR and PIXELFONT_FUNC_NAME\n// it is possible to create declarations for different pixel formats. By defining the same ones, and the additional\n// PIXELFONT_PIXEL_FUNC before including the implementation part, the corresponding definition can be created.\n\n#ifndef PIXELFONT_COLOR\n    #define PIXELFONT_COLOR PIXELFONT_U8\n#endif\n\n#ifndef PIXELFONT_FUNC_NAME\n    #define PIXELFONT_FUNC_NAME pixelfont_blit\n#endif\n\nvoid PIXELFONT_FUNC_NAME( pixelfont_t const* font, int x, int y, char const* text, PIXELFONT_COLOR color,\n    PIXELFONT_COLOR* target, int width, int height, pixelfont_align_t align, int wrap_width, int hspacing,\n    int vspacing, int limit, pixelfont_bold_t bold, pixelfont_italic_t italic, pixelfont_underline_t underline,\n    pixelfont_bounds_t* bounds );\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef PIXELFONT_IMPLEMENTATION\n#undef PIXELFONT_IMPLEMENTATION\n\n#ifndef PIXELFONT_PIXEL_FUNC\n    #define PIXELFONT_PIXEL_FUNC( dst, fnt, col ) *(dst) = (col);\n#endif\n\nvoid PIXELFONT_FUNC_NAME( pixelfont_t const* font, int x, int y, char const* text, PIXELFONT_COLOR color,\n    PIXELFONT_COLOR* target, int width, int height, pixelfont_align_t align, int wrap_width, int hspacing,\n    int vspacing,  int limit, pixelfont_bold_t bold, pixelfont_italic_t italic, pixelfont_underline_t underline,\n    pixelfont_bounds_t* bounds )\n    {\n    int xp = x;\n    int yp = y;\n    int max_x = x;\n    int last_x_on_line = xp;\n    int count = 0;\n    char const* str = text;\n    while( *str )\n        {\n        int line_char_count = 0;\n        int line_width = 0;\n        int last_space_char_count = 0;\n        int last_space_width = 0;\n        char const* tstr = str;\n        while( *tstr != '\\n' && *tstr != '\\0' && ( wrap_width <= 0 || line_width <= wrap_width  ) )\n            {\n            if( *tstr <= ' ' )\n                {\n                last_space_char_count = line_char_count;\n                last_space_width = line_width;\n                }\n            PIXELFONT_U8 const* g = font->glyphs + font->offsets[ (int) *tstr ];\n            line_width += (PIXELFONT_I8) *g++;\n            int w = *g++;\n            g += font->height * w;\n            line_width += (PIXELFONT_I8) *g++;\n            line_width += hspacing + ( bold ? 1 : 0 );\n            ++tstr;\n            int kern = *g++;\n            for( int k = 0; k < kern; ++k )\n                if( *g++ == *tstr ) { line_width += (PIXELFONT_I8) *g++; break; } else ++g;\n            ++line_char_count;\n            }\n\n        int skip_space = 0;\n        if( wrap_width > 0 && line_width > wrap_width )\n            {\n            if( last_space_char_count > 0 ) line_char_count = last_space_char_count;\n            line_width = last_space_width;\n            skip_space = 1;\n            }\n\n        if( wrap_width > 0 )\n            {\n            if( align == PIXELFONT_ALIGN_RIGHT ) x += wrap_width - line_width;\n            if( align == PIXELFONT_ALIGN_CENTER ) x += ( wrap_width - line_width ) / 2;\n            }\n        else\n            {\n            if( align == PIXELFONT_ALIGN_RIGHT ) x -= line_width;\n            if( align == PIXELFONT_ALIGN_CENTER ) x -= line_width / 2;\n            }\n\n        for( int c = 0; c < line_char_count; ++c )\n            {\n            PIXELFONT_U8 const* g = font->glyphs + font->offsets[ (int) *str ];\n            x += (PIXELFONT_I8) *g++;\n            int w = *g++;\n            int h = font->height;\n            for( int iy = y; iy < y + h; ++iy )\n                {\n                int xs = x + ( italic ? ( h - ( iy - y ) ) / 2 - 1 : 0 );\n                for( int ix = xs; ix < xs + w; ++ix )\n                    {\n                    int p = *g++;\n                    if( p && target )\n                        if( limit < 0 || count < limit )\n                            if( ix >= 0 && iy >= 0 && ix < width && iy < height )\n                                {\n                                last_x_on_line = ix >= last_x_on_line ? ix + ( bold ? 1 : 0 ) : last_x_on_line;\n                                PIXELFONT_PIXEL_FUNC( ( &target[ ix + iy * width ] ), (PIXELFONT_U8)p, color );\n                                if( bold && ix + 1 < width )\n                                    PIXELFONT_PIXEL_FUNC( ( &target[ ix + 1 + iy * width ] ), (PIXELFONT_U8)p, color );\n                                }\n                    }\n                }\n\n            x += (PIXELFONT_I8) *g++;\n            x += hspacing + ( bold ? 1 : 0 );\n            ++str;\n            ++count;\n\n            int kern = *g++;\n            for( int k = 0; k < kern; ++k )\n                if( *g++ == *str ) { x += (PIXELFONT_I8) *g++; break; } else ++g;\n\n            }\n\n            if( underline && target && y + font->baseline + 1 >= 0 && y + font->baseline + 1 < height && last_x_on_line > xp )\n                for( int ix = xp; ix <= last_x_on_line; ++ix )\n                    if( ix >= 0 && ix < width )\n                        PIXELFONT_PIXEL_FUNC( ( &target[ ix + ( y + font->baseline + 1 ) * width ] ), (PIXELFONT_U8)255, color );\n            last_x_on_line = xp;\n            max_x = x > max_x ? x : max_x;\n            x = xp;\n            y += font->line_spacing + vspacing;\n            if( *str == '\\n' ) ++str;\n            if( *str && skip_space && *str <= ' ' ) ++str;\n        }\n\n    if( bounds )\n        {\n        bounds->width = wrap_width > 0 ? wrap_width : ( max_x - xp );\n        bounds->height = y - yp;\n        }\n    }\n\n\n#undef PIXELFONT_COLOR\n#undef PIXELFONT_FUNC_NAME\n\n#endif /* PIXELFONT_IMPLEMENTATION */\n\n\n\n#ifdef PIXELFONT_BUILDER_IMPLEMENTATION\n#undef PIXELFONT_BUILDER_IMPLEMENTATION\n\n\n#ifndef PIXELFONT_MALLOC\n    #undef _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define PIXELFONT_MALLOC( ctx, size ) ( malloc( size ) )\n    #define PIXELFONT_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\n#ifndef PIXELFONT_MEMCPY\n    #undef _CRT_NONSTDC_NO_DEPRECATE\n    #define _CRT_NONSTDC_NO_DEPRECATE\n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define PIXELFONT_MEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif\n\n\ntypedef struct pixelfont_builder_glyph_t\n    {\n    int lead;\n    int trail;\n    int width;\n    PIXELFONT_U8* pixels;\n    } pixelfont_builder_glyph_t;\n\n\ntypedef struct pixelfont_builder_kerning_t\n    {\n    int glyph;\n    int follower;\n    int adjust;\n    } pixelfont_builder_kerning_t;\n\n\nstruct pixelfont_builder_t\n    {\n    void* memctx;\n    pixelfont_t* font;\n    int height;\n    int baseline;\n    int line_spacing;\n\n    pixelfont_builder_glyph_t glyphs[ 256 ];\n\n    int kernings_capacity;\n    int kernings_count;\n    pixelfont_builder_kerning_t* kernings;\n    };\n\n\npixelfont_builder_t* pixelfont_builder_create( int height, int baseline, int line_spacing, void* memctx )\n    {\n    pixelfont_builder_t* builder = (pixelfont_builder_t*) PIXELFONT_MALLOC( memctx, sizeof( pixelfont_builder_t ) ) ;\n    memset( builder, 0, sizeof( *builder ) );\n    builder->memctx = memctx;\n    builder->font = 0;\n    builder->height = height < 0 ? 0 : height > 255 ? 255 : height;\n    builder->baseline = baseline < 0 ? 0 : baseline > 255 ? 255 : baseline;\n    builder->line_spacing = line_spacing < 0 ? 0 : line_spacing > 255 ? 255 : line_spacing;\n    builder->kernings_capacity = 0;\n    builder->kernings_count = 0;\n    builder->kernings = 0;\n    return builder;\n    }\n\n\nvoid pixelfont_builder_destroy( pixelfont_builder_t* builder )\n    {\n    for( int i = 0; i < sizeof( builder->glyphs ) / sizeof( *builder->glyphs ); ++i )\n        if( builder->glyphs[ i ].pixels ) PIXELFONT_FREE( builder->memctx, builder->glyphs[ i ].pixels );\n\n    if( builder->kernings ) PIXELFONT_FREE( builder->memctx, builder->kernings );\n    if( builder->font ) PIXELFONT_FREE( builder->memctx, builder->font );\n    PIXELFONT_FREE( builder->memctx, builder );\n    }\n\n\nvoid pixelfont_builder_glyph( pixelfont_builder_t* builder, int glyph, int pixels_stride, PIXELFONT_U8* pixels, int width, int lead, int trail )\n    {\n    if( glyph < 0 || glyph > 255 ) return;\n\n    if( builder->glyphs[ glyph ].pixels ) PIXELFONT_FREE( builder->memctx, builder->glyphs[ glyph ].pixels );\n    builder->glyphs[ glyph ].pixels = 0;\n    builder->glyphs[ glyph ].lead = 0;\n    builder->glyphs[ glyph ].trail = 0;\n    builder->glyphs[ glyph ].width = 0;\n\n    if( pixels && width > 0 )\n        {\n        builder->glyphs[ glyph ].pixels = (PIXELFONT_U8*) PIXELFONT_MALLOC( builder->memctx, width * builder->height * sizeof( PIXELFONT_U8 ) );\n        for( int y = 0; y < builder->height; ++y )\n            for( int x = 0; x < width; ++x )\n                builder->glyphs[ glyph ].pixels[ x + y * width ] = pixels[ x + y * pixels_stride ];\n        builder->glyphs[ glyph ].lead = lead < -127 ? -127 : lead > 127 ? 127 : lead;\n        builder->glyphs[ glyph ].trail = trail < -127 ? -127 : trail > 127 ? 127 : trail;\n        builder->glyphs[ glyph ].width = width < 0 ? 0 : width > 255 ? 255 : width;\n        }\n    else if( lead || trail )\n        {\n        builder->glyphs[ glyph ].pixels = (PIXELFONT_U8*) PIXELFONT_MALLOC( builder->memctx, 1 );\n        builder->glyphs[ glyph ].lead = lead < -127 ? -127 : lead > 127 ? 127 : lead;\n        builder->glyphs[ glyph ].trail = trail < -127 ? -127 : trail > 127 ? 127 : trail;\n        builder->glyphs[ glyph ].width = 0;\n        }\n    }\n\n\nvoid pixelfont_builder_kerning( pixelfont_builder_t* builder, int glyph, int follower, int adjust )\n    {\n    adjust = adjust < -127 ? -127 : adjust > 127 ? 127 : adjust;\n\n    for( int i = 0; i < builder->kernings_count; ++i )\n        {\n        if( builder->kernings[ i ].glyph == glyph && builder->kernings[ i ].follower == follower )\n            {\n            if( adjust )\n                builder->kernings[ i ].adjust = adjust;\n            else\n                builder->kernings[ i ] = builder->kernings[ --builder->kernings_count ];\n            return;\n            }\n        }\n\n    if( adjust )\n        {\n        if( !builder->kernings || builder->kernings_count >= builder->kernings_capacity )\n            {\n            builder->kernings_capacity = builder->kernings_capacity ? builder->kernings_capacity * 2 : 256;\n            pixelfont_builder_kerning_t* kernings = (pixelfont_builder_kerning_t*) PIXELFONT_MALLOC( builder->memctx,\n                sizeof( pixelfont_builder_kerning_t ) * builder->kernings_capacity );\n            if( builder->kernings )\n                {\n                PIXELFONT_MEMCPY( kernings, builder->kernings, sizeof( pixelfont_builder_kerning_t ) * builder->kernings_count );\n                PIXELFONT_FREE( builder->memctx, builder->kernings );\n                }\n            builder->kernings = kernings;\n            }\n\n        builder->kernings[ builder->kernings_count ].glyph = glyph;\n        builder->kernings[ builder->kernings_count ].follower = follower;\n        builder->kernings[ builder->kernings_count ].adjust = adjust;\n        ++builder->kernings_count;\n        }\n    }\n\n\npixelfont_t* pixelfont_builder_font( pixelfont_builder_t* builder )\n    {\n    if( builder->font ) PIXELFONT_FREE( builder->memctx, builder->font );\n\n    PIXELFONT_U8 kerning_counts[ 256 ];\n    memset( kerning_counts, 0, sizeof( kerning_counts ) );\n    for( int i = 0; i < builder->kernings_count; ++i )\n        ++kerning_counts[ builder->kernings[ i ].glyph ];\n\n    PIXELFONT_U32 offsets[ 256 ];\n    memset( offsets, 0, sizeof( offsets ) );\n    PIXELFONT_U32 current_offset = 0;\n    int total_width = 0;\n    int glyph_count = 0;\n    for( int i = 0; i < sizeof( builder->glyphs ) / sizeof( *builder->glyphs ); ++i )\n        {\n        if( builder->glyphs[ i ].pixels )\n            {\n            ++glyph_count;\n            total_width += builder->glyphs[ i ].width;\n            offsets[ i ] = current_offset;\n            current_offset += 1 + kerning_counts[ i ] + 3 + builder->glyphs[ i ].width * builder->height;\n            }\n        }\n\n    size_t size_in_bytes = sizeof( pixelfont_t ) - sizeof( PIXELFONT_U8 ); // base size excluding final placeholder byte\n    size_in_bytes += glyph_count + 2 * builder->kernings_count; // kerning pair count for each glyph + all kerning data\n    size_in_bytes += 3 * glyph_count; // lead, trail and width for each glyph\n    size_in_bytes += total_width * builder->height; // pixel data for all glyphs\n\n    pixelfont_t* font = (pixelfont_t*) PIXELFONT_MALLOC( builder->memctx, size_in_bytes );\n    memset( font, 0, sizeof( *font ) );\n    font->size_in_bytes = (PIXELFONT_U32) size_in_bytes;\n    font->height = (PIXELFONT_U8) builder->height;\n    font->line_spacing = (PIXELFONT_U8) builder->line_spacing;\n    font->baseline = (PIXELFONT_U8) builder->baseline;\n    memcpy( font->offsets, offsets, sizeof( font->offsets ) );\n\n    for( int i = 0; i < sizeof( builder->glyphs ) / sizeof( *builder->glyphs ); ++i )\n        {\n        if( builder->glyphs[ i ].pixels )\n            {\n            PIXELFONT_U8* src = builder->glyphs[ i ].pixels;\n            PIXELFONT_U8* out = font->glyphs + offsets[ i ];\n            *out++ = (PIXELFONT_U8) builder->glyphs[ i ].lead;\n            *out++ = (PIXELFONT_U8) builder->glyphs[ i ].width;\n            for( int y = 0; y < builder->height; ++y )\n                for( int x = 0; x < builder->glyphs[ i ].width; ++x )\n                    *out++ = *src++;\n            *out++ = (PIXELFONT_U8) builder->glyphs[ i ].trail;\n\n            *out++ = kerning_counts[ i ];\n            for( int j = 0; j < builder->kernings_count; ++j )\n                {\n                if( builder->kernings[ j ].glyph == i )\n                    {\n                    *out++ = (PIXELFONT_U8) builder->kernings[ j ].follower;\n                    *out++ = (PIXELFONT_U8) builder->kernings[ j ].adjust;\n                    }\n                }\n            }\n        }\n\n    builder->font = font;\n    return builder->font;\n    }\n\n\n#endif /* PIXELFONT_BUILDER_IMPLEMENTATION */\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2017 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "rnd.h",
          "type": "blob",
          "size": 17.5966796875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nrnd.h - v1.0 - Pseudo-random number generators for C/C++.\n\nDo this:\n    #define RND_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef rnd_h\n#define rnd_h\n\n#ifndef RND_U32\n    #define RND_U32 unsigned int\n#endif\n#ifndef RND_U64\n    #define RND_U64 unsigned long long\n#endif\n\ntypedef struct rnd_pcg_t { RND_U64 state[ 2 ]; } rnd_pcg_t;\nvoid rnd_pcg_seed( rnd_pcg_t* pcg, RND_U32 seed );\nRND_U32 rnd_pcg_next( rnd_pcg_t* pcg );\nfloat rnd_pcg_nextf( rnd_pcg_t* pcg );\nint rnd_pcg_range( rnd_pcg_t* pcg, int min, int max );\n\ntypedef struct rnd_well_t { RND_U32 state[ 17 ]; } rnd_well_t;\nvoid rnd_well_seed( rnd_well_t* well, RND_U32 seed );\nRND_U32 rnd_well_next( rnd_well_t* well );\nfloat rnd_well_nextf( rnd_well_t* well );\nint rnd_well_range( rnd_well_t* well, int min, int max );\n\ntypedef struct rnd_gamerand_t { RND_U32 state[ 2 ]; } rnd_gamerand_t;\nvoid rnd_gamerand_seed( rnd_gamerand_t* gamerand, RND_U32 seed );\nRND_U32 rnd_gamerand_next( rnd_gamerand_t* gamerand );\nfloat rnd_gamerand_nextf( rnd_gamerand_t* gamerand );\nint rnd_gamerand_range( rnd_gamerand_t* gamerand, int min, int max );\n\ntypedef struct rnd_xorshift_t { RND_U64 state[ 2 ]; } rnd_xorshift_t;\nvoid rnd_xorshift_seed( rnd_xorshift_t* xorshift, RND_U64 seed );\nRND_U64 rnd_xorshift_next( rnd_xorshift_t* xorshift );\nfloat rnd_xorshift_nextf( rnd_xorshift_t* xorshift );\nint rnd_xorshift_range( rnd_xorshift_t* xorshift, int min, int max );\n\n#endif /* rnd_h */\n\n/**\n\nrnd.h\n=====\n\nPseudo-random number generators for C/C++.\n\n\nExample\n-------\n\nA basic example showing how to use the PCG set of random functions.\n\n    #define  RND_IMPLEMENTATION\n    #include \"rnd.h\"\n\n    #include <stdio.h> // for printf\n    #include <time.h> // for time\n    \n    int main( int argc, char** argv ) {\n\n        rnd_pcg_t pcg;\n        rnd_pcg_seed( &pcg, 0u ); // initialize generator\n\n        // print a handful of random integers\n        // these will be the same on every run, as we \n        // seeded the rng with a fixed value\n        for( int i = 0; i < 5; ++i ) {\n            RND_U32 n = rnd_pcg_next( &pcg );\n            printf( \"%08x, \", n );\n        }\n        printf( \"\\n\" );\n\n        // reseed with a value which is different on each run\n        time_t seconds;\n        time( &seconds );\n        rnd_pcg_seed( &pcg, (RND_U32) seconds ); \n\n        // print another handful of random integers\n        // these will be different on every run\n        for( int i = 0; i < 5; ++i ) {\n            RND_U32 n = rnd_pcg_next( &pcg );\n            printf( \"%08x, \", n );\n        }\n        printf( \"\\n\" );\n\n\n        // print a handful of random floats\n        for( int i = 0; i < 5; ++i ) {\n            float f = rnd_pcg_nextf( &pcg );\n            printf( \"%f, \", f );\n        }\n        printf( \"\\n\" );\n\n        // print random integers in the range 1 to 6\n        for( int i = 0; i < 15; ++i ) {\n            int r = rnd_pcg_range( &pcg, 1, 6 );\n            printf( \"%d, \", r );\n        }\n        printf( \"\\n\" );\n\n        return 0;\n    }\n\n\nAPI Documentation\n-----------------\n\nrnd.h is a single-header library, and does not need any .lib files or other binaries, or any build scripts. To use it,\nyou just include rnd.h to get the API declarations. To get the definitions, you must include rnd.h from *one* single C \nor C++ file, and #define the symbol `RND_IMPLEMENTATION` before you do. \n\nThe library is meant for general-purpose use, such as games and similar apps. It is not meant to be used for \ncryptography and similar use cases.\n\n\n### Customization\n\nrnd.h allows for specifying the exact type of 32 and 64 bit unsigned integers to be used in its API. By default, these\ndefault to `unsigned int` and `unsigned long long`, but can be redefined by #defining RND_U32 and RND_U64 respectively\nbefore including rnd.h. This is useful if you, for example, use the types from `<stdint.h>` in the rest of your program, \nand you want rnd.h to use compatible types. In this case, you would include rnd.h using the following code:\n\n    #define RND_U32 uint32_t\n    #define RND_U64 uint64_t\n    #include \"rnd.h\"\n\nNote that when customizing the data type, you need to use the same definition in every place where you include rnd.h, \nas it affect the declarations as well as the definitions.\n\n\n### The generators\n\nThe library includes four different generators: PCG, WELL, GameRand and XorShift. They all have different \ncharacteristics, and you might want to use them for different things. GameRand is very fast, but does not give a great\ndistribution or period length. XorShift is the only one returning a 64-bit value. WELL is an improvement of the often\nused Mersenne Twister, and has quite a large internal state. PCG is small, fast and has a small state. If you don't\nhave any specific reason, you may default to using PCG.\n\nAll generators expose their internal state, so it is possible to save this state and later restore it, to resume the \nrandom sequence from the same point.\n\n\n#### PCG - Permuted Congruential Generator\n\nPCG is a family of simple fast space-efficient statistically good algorithms for random number generation. Unlike many \ngeneral-purpose RNGs, they are also hard to predict.\n\nMore information can be found here: \n\nhttp://www.pcg-random.org/\n\n\n#### WELL - Well Equidistributed Long-period Linear\n\nRandom number generation, using the WELL algorithm by F. Panneton, P. L'Ecuyer and M. Matsumoto.\nMore information in the original paper: \n\nhttp://www.iro.umontreal.ca/~panneton/WELLRNG.html\n\nThis code is originally based on WELL512 C/C++ code written by Chris Lomont (published in Game Programming Gems 7) \nand placed in the public domain. \n\nhttp://lomont.org/Math/Papers/2008/Lomont_PRNG_2008.pdf\n\n\n#### GameRand\n\nBased on the random number generator by Ian C. Bullard:\n\nhttp://www.redditmirror.cc/cache/websites/mjolnirstudios.com_7yjlc/mjolnirstudios.com/IanBullard/files/79ffbca75a75720f066d491e9ea935a0-10.html\n\nGameRand is a random number generator based off an \"Image of the Day\" posted by Stephan Schaem. More information here:\n\nhttp://www.flipcode.com/archives/07-15-2002.shtml\n\n\n#### XorShift \n\nA random number generator of the type LFSR (linear feedback shift registers). This specific implementation uses the\nXorShift+ variation, and returns 64-bit random numbers.\n\nMore information can be found here: \n\nhttps://en.wikipedia.org/wiki/Xorshift\n\n\n\nrnd_pcg_seed\n------------\n\n    void rnd_pcg_seed( rnd_pcg_t* pcg, RND_U32 seed )\n\nInitialize a PCG generator with the specified seed. The generator is not valid until it's been seeded.\n\n\nrnd_pcg_next\n------------\n\n    RND_U32 rnd_pcg_next( rnd_pcg_t* pcg )\n\nReturns a random number N in the range: 0 <= N <= 0xffffffff, from the specified PCG generator.\n\n\nrnd_pcg_nextf\n-------------\n\n    float rnd_pcg_nextf( rnd_pcg_t* pcg )\n\nReturns a random float X in the range: 0.0f <= X < 1.0f, from the specified PCG generator.\n\n\nrnd_pcg_range\n-------------\n\n    int rnd_pcg_range( rnd_pcg_t* pcg, int min, int max )\n\nReturns a random integer N in the range: min <= N <= max, from the specified PCG generator.\n\n\nrnd_well_seed\n-------------\n\n    void rnd_well_seed( rnd_well_t* well, RND_U32 seed )\n\nInitialize a WELL generator with the specified seed. The generator is not valid until it's been seeded.\n\n\nrnd_well_next\n-------------\n\n    RND_U32 rnd_well_next( rnd_well_t* well )\n\nReturns a random number N in the range: 0 <= N <= 0xffffffff, from the specified WELL generator.\n\n\nrnd_well_nextf\n--------------\n    float rnd_well_nextf( rnd_well_t* well )\n\nReturns a random float X in the range: 0.0f <= X < 1.0f, from the specified WELL generator.\n\n\nrnd_well_range\n--------------\n\n    int rnd_well_range( rnd_well_t* well, int min, int max )\n\nReturns a random integer N in the range: min <= N <= max, from the specified WELL generator.\n\n\nrnd_gamerand_seed\n-----------------\n\n    void rnd_gamerand_seed( rnd_gamerand_t* gamerand, RND_U32 seed )\n\nInitialize a GameRand generator with the specified seed. The generator is not valid until it's been seeded.\n\n\nrnd_gamerand_next\n-----------------\n\n    RND_U32 rnd_gamerand_next( rnd_gamerand_t* gamerand )\n\nReturns a random number N in the range: 0 <= N <= 0xffffffff, from the specified GameRand generator.\n\n\nrnd_gamerand_nextf\n------------------\n\n    float rnd_gamerand_nextf( rnd_gamerand_t* gamerand )\n\nReturns a random float X in the range: 0.0f <= X < 1.0f, from the specified GameRand generator.\n\n\nrnd_gamerand_range\n------------------\n\n    int rnd_gamerand_range( rnd_gamerand_t* gamerand, int min, int max )\n\nReturns a random integer N in the range: min <= N <= max, from the specified GameRand generator.\n\n\nrnd_xorshift_seed\n-----------------\n\n    void rnd_xorshift_seed( rnd_xorshift_t* xorshift, RND_U64 seed )\n\nInitialize a XorShift generator with the specified seed. The generator is not valid until it's been seeded.\n\n\nrnd_xorshift_next\n-----------------\n\n    RND_U64 rnd_xorshift_next( rnd_xorshift_t* xorshift )\n\nReturns a random number N in the range: 0 <= N <= 0xffffffffffffffff, from the specified XorShift generator.\n\n\nrnd_xorshift_nextf\n------------------\n\n    float rnd_xorshift_nextf( rnd_xorshift_t* xorshift )\n\nReturns a random float X in the range: 0.0f <= X < 1.0f, from the specified XorShift generator.\n\n\nrnd_xorshift_range\n------------------\n\n    int rnd_xorshift_range( rnd_xorshift_t* xorshift, int min, int max )\n\nReturns a random integer N in the range: min <= N <= max, from the specified XorShift generator.\n\n\n*/\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef RND_IMPLEMENTATION\n#undef RND_IMPLEMENTATION\n\n// Convert a randomized RND_U32 value to a float value x in the range 0.0f <= x < 1.0f. Contributed by Jonatan Hedborg\nstatic float rnd_internal_float_normalized_from_u32( RND_U32 value )\n    {\n    RND_U32 exponent = 127;\n    RND_U32 mantissa = value >> 9;\n    RND_U32 result = ( exponent << 23 ) | mantissa;\n    float fresult = *(float*)( &result );\n    return fresult - 1.0f;\n    }\n\n\nstatic RND_U32 rnd_internal_murmur3_avalanche32( RND_U32 h )\n    {\n    h ^= h >> 16;\n    h *= 0x85ebca6b;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35;\n    h ^= h >> 16;\n    return h;\n    }\n\n\nstatic RND_U64 rnd_internal_murmur3_avalanche64( RND_U64 h )\n    {\n    h ^= h >> 33;\n    h *= 0xff51afd7ed558ccd;\n    h ^= h >> 33;\n    h *= 0xc4ceb9fe1a85ec53;\n    h ^= h >> 33;\n    return h;\n    }\n\n\nvoid rnd_pcg_seed( rnd_pcg_t* pcg, RND_U32 seed )\n    {\n    RND_U64 value = ( ( (RND_U64) seed ) << 1ULL ) | 1ULL;\n    value = rnd_internal_murmur3_avalanche64( value );\n    pcg->state[ 0 ] = 0U;\n    pcg->state[ 1 ] = ( value << 1ULL ) | 1ULL;\n    rnd_pcg_next( pcg );\n    pcg->state[ 0 ] += rnd_internal_murmur3_avalanche64( value );\n    rnd_pcg_next( pcg );\n    }\n\n\nRND_U32 rnd_pcg_next( rnd_pcg_t* pcg )\n    {\n    RND_U64 oldstate = pcg->state[ 0 ];\n    pcg->state[ 0 ] = oldstate * 0x5851f42d4c957f2dULL + pcg->state[ 1 ];\n    RND_U32 xorshifted = (RND_U32)( ( ( oldstate >> 18ULL)  ^ oldstate ) >> 27ULL );\n    RND_U32 rot = (RND_U32)( oldstate >> 59ULL );\n    return ( xorshifted >> rot ) | ( xorshifted << ( ( -(int) rot ) & 31 ) );\n    }\n\n\nfloat rnd_pcg_nextf( rnd_pcg_t* pcg )\n    {\n    return rnd_internal_float_normalized_from_u32( rnd_pcg_next( pcg ) );\n    }\n\n\nint rnd_pcg_range( rnd_pcg_t* pcg, int min, int max )\n    {\n    int const range = ( max - min ) + 1;\n    if( range <= 0 ) return min;\n    int const value = (int) ( rnd_pcg_nextf( pcg ) * range );\n    return min + value; \n    }\n\n\nvoid rnd_well_seed( rnd_well_t* well, RND_U32 seed )\n    {\n    RND_U32 value = rnd_internal_murmur3_avalanche32( ( seed << 1U ) | 1U );\n    well->state[ 16 ] = 0;\n    well->state[ 0 ] = value ^ 0xf68a9fc1U;\n    for( int i = 1; i < 16; ++i ) \n        well->state[ i ] = ( 0x6c078965U * ( well->state[ i - 1 ] ^ ( well->state[ i - 1 ] >> 30 ) ) + i ); \n    }\n\n\nRND_U32 rnd_well_next( rnd_well_t* well )\n    {\n    RND_U32 a = well->state[ well->state[ 16 ] ];\n    RND_U32 c = well->state[ ( well->state[ 16 ] + 13 ) & 15 ];\n    RND_U32 b = a ^ c ^ ( a << 16 ) ^ ( c << 15 );\n    c = well->state[ ( well->state[ 16 ] + 9 ) & 15 ];\n    c ^= ( c >> 11 );\n    a = well->state[ well->state[ 16 ] ] = b ^ c;\n    RND_U32 d = a ^ ( ( a << 5 ) & 0xda442d24U );\n    well->state[ 16 ] = (well->state[ 16 ] + 15 ) & 15;\n    a = well->state[ well->state[ 16 ] ];\n    well->state[ well->state[ 16 ] ] = a ^ b ^ d ^ ( a << 2 ) ^ ( b << 18 ) ^ ( c << 28 );\n    return well->state[ well->state[ 16 ] ];\n    }\n\n\nfloat rnd_well_nextf( rnd_well_t* well )\n    {\n    return rnd_internal_float_normalized_from_u32( rnd_well_next( well ) );\n    }\n\n\nint rnd_well_range( rnd_well_t* well, int min, int max )\n    {\n    int const range = ( max - min ) + 1;\n    if( range <= 0 ) return min;\n    int const value = (int) ( rnd_well_nextf( well ) * range );\n    return min + value; \n    }\n\n\nvoid rnd_gamerand_seed( rnd_gamerand_t* gamerand, RND_U32 seed )\n    {\n    RND_U32 value = rnd_internal_murmur3_avalanche32( ( seed << 1U ) | 1U );\n    gamerand->state[ 0 ] = value;\n    gamerand->state[ 1 ] = value ^ 0x49616e42U;\n    }\n\n\nRND_U32 rnd_gamerand_next( rnd_gamerand_t* gamerand )\n    {\n    gamerand->state[ 0 ] = ( gamerand->state[ 0 ] << 16 ) + ( gamerand->state[ 0 ] >> 16 );\n    gamerand->state[ 0 ] += gamerand->state[ 1 ];\n    gamerand->state[ 1 ] += gamerand->state[ 0 ];\n    return gamerand->state[ 0 ];\n    }\n\n\nfloat rnd_gamerand_nextf( rnd_gamerand_t* gamerand )\n    {\n    return rnd_internal_float_normalized_from_u32( rnd_gamerand_next( gamerand ) );\n    }\n\n\nint rnd_gamerand_range( rnd_gamerand_t* gamerand, int min, int max )\n    {\n    int const range = ( max - min ) + 1;\n    if( range <= 0 ) return min;\n    int const value = (int) ( rnd_gamerand_nextf( gamerand ) * range );\n    return min + value; \n    }\n\n\nvoid rnd_xorshift_seed( rnd_xorshift_t* xorshift, RND_U64 seed )\n    {\n    RND_U64 value = rnd_internal_murmur3_avalanche64( ( seed << 1ULL ) | 1ULL );\n    xorshift->state[ 0 ] = value;\n    value = rnd_internal_murmur3_avalanche64( value );\n    xorshift->state[ 1 ] = value;\n    }\n\n\nRND_U64 rnd_xorshift_next( rnd_xorshift_t* xorshift )\n    {\n    RND_U64 x = xorshift->state[ 0 ];\n    RND_U64 const y = xorshift->state[ 1 ];\n    xorshift->state[ 0 ] = y;\n    x ^= x << 23;\n    x ^= x >> 17;\n    x ^= y ^ ( y >> 26 );\n    xorshift->state[ 1 ] = x;\n    return x + y;\n    }\n\n\nfloat rnd_xorshift_nextf( rnd_xorshift_t* xorshift )\n    {\n    return rnd_internal_float_normalized_from_u32( (RND_U32)( rnd_xorshift_next( xorshift ) >> 32 ) );\n    }\n\n\nint rnd_xorshift_range( rnd_xorshift_t* xorshift, int min, int max )\n    {\n    int const range = ( max - min ) + 1;\n    if( range <= 0 ) return min;\n    int const value = (int) ( rnd_xorshift_nextf( xorshift ) * range );\n    return min + value; \n   }\n\n\n\n#endif /* RND_IMPLEMENTATION */\n\n/*\n\ncontributors:\n\tJonatan Hedborg (unsigned int to normalized float conversion)\n\nrevision history:\n    1.0     first publicly released version \n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\nBased on public domain implementation - original licenses can be found next to \nthe relevant implementation sections of this file.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2016 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/"
        },
        {
          "name": "samplerate.h",
          "type": "blob",
          "size": 9715.197265625,
          "content": ""
        },
        {
          "name": "speech.h",
          "type": "blob",
          "size": 176.1181640625,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nspeech.h - v0.1 - Very basic text-to-speech synthesizer library for C/C++.\n\nDo this:\n    #define SPEECH_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n\n------------------------------------------------------------------------------\n\nThis file contains modified code based on the TTS code from the SoLoud audio\nengine (http://sol.gfxile.net/soloud/), which in turn is based on rsynth by \nNick Ing-Simmons (et al). I have not included any code which were under the \nSoLoud license (ZLib/LibPNG). I've basically just merged the code into a \nsingle header library, converted it from C++ to C, and put my own interface \non top of it instead of the original SoLoud interface.\n\nThe original license text can be found at the end of this file, and I place my\nchanges under the same license.\n\n                        / Mattias Gustavsson ( mattias@mattiasgustavsson.com )\n*/\n\n#ifndef speech_h\n#define speech_h\n\nshort* speech_gen( int* samples_pairs_generated, char const* str, void* memctx );\nvoid speech_free( short* sample_pairs, void* memctx );\n\n#endif /* speech_h */\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifdef SPEECH_IMPLEMENTATION\n#undef SPEECH_IMPLEMENTATION\n\n#pragma warning( push )\n#pragma warning( disable: 4706 ) // assignment within conditional expression\n\n#ifndef SPEECH_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #if defined(__cplusplus)\n        #define SPEECH_MALLOC( ctx, size ) ( ::malloc( size ) )\n        #define SPEECH_FREE( ctx, ptr ) ( ::free( ptr ) )\n    #else\n        #define SPEECH_MALLOC( ctx, size ) ( malloc( size ) )\n        #define SPEECH_FREE( ctx, ptr ) ( free( ptr ) )\n    #endif\n#endif\n\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <math.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n\n#define TTS_PI 3.1415926535897932384626433832795f\n\n\nstruct tts_darray_t {\n    void* memctx;\n    char *mData;\n    int mUsed;\n    int mAllocated;\n    int mAllocChunk;\n    char mem[ 1024 ];\n};\n\n\nstatic void tts_darray_init( struct tts_darray_t* darray, void* memctx ) {\n    darray->memctx = memctx;\n    darray->mAllocChunk = 1024;\n    darray->mUsed = 0;\n    darray->mAllocated = sizeof( darray->mem );\n    darray->mData = darray->mem;\n}\n\n\nstatic void tts_darray_clear( struct tts_darray_t* darray ) {\n    if( darray->mData != darray->mem ) SPEECH_FREE( darray->memctx, darray->mData );\n    darray->mAllocChunk = 1024;\n    darray->mUsed = 0;\n    darray->mAllocated = sizeof( darray->mem );\n    darray->mData = darray->mem;\n}\n\n\nstatic void tts_darray_term( struct tts_darray_t* darray ) {\n    tts_darray_clear( darray );\n}\n\n\nstatic char* tts_darray_getDataInPos( struct tts_darray_t* darray, int aPosition ) {\n    if( aPosition < darray->mAllocated && aPosition < darray->mUsed )\n        return darray->mData + aPosition;\n\n    if( aPosition >= darray->mAllocated ) {\n        int newsize = darray->mAllocated;\n\n        while( newsize <= aPosition ) {\n            newsize += darray->mAllocChunk;\n            darray->mAllocChunk *= 2;\n        }\n\n        char* newdata = (char*) SPEECH_MALLOC( darray->memctx, newsize );\n        if( !newdata ) {\n            if( darray->mData != darray->mem ) SPEECH_FREE( memctx, darray->mData);\n            darray->mData = NULL;\n            darray->mAllocated = darray->mUsed = 0;\n            return NULL;\n        }\n        memcpy( newdata, darray->mData, darray->mAllocated );\n        if( darray->mData != darray->mem ) {\n            SPEECH_FREE( darray->memctx, darray->mData );\n        }\n        darray->mData = newdata;\n        darray->mAllocated = newsize;           \n    }\n\n    if( aPosition >= darray->mUsed ) {\n        darray->mUsed = aPosition + 1;\n    }\n\n    return darray->mData + aPosition;\n}\n\n\nstatic void tts_darray_put( struct tts_darray_t* darray, int aData ) {\n    char *s = tts_darray_getDataInPos( darray, darray->mUsed );\n\n    *s = (char) aData;\n}\n\n\nstatic int tts_darray_getSize( struct tts_darray_t* darray ) { \n    return darray->mUsed; \n}\n\n\nstatic char* tts_darray_getData( struct tts_darray_t* darray ) { \n    return darray->mData; \n} \n\nstruct tts_resonator_t {\n    float mA, mB, mC, mP1, mP2;\n};\n\n\n/* Convert formant freqencies and bandwidth into resonator difference equation coefficents */\nstatic void tts_resonator_initResonator(\n    struct tts_resonator_t* resonator,\n    int aFrequency,                       /* Frequency of resonator in Hz  */\n    int aBandwidth,                      /* Bandwidth of resonator in Hz  */\n    int aSamplerate )\n{\n    float arg = ( -TTS_PI / aSamplerate ) * aBandwidth;\n    float r = (float) exp( arg );  \n    resonator->mC = -( r * r );             \n    arg = ( -2.0f * TTS_PI / aSamplerate ) * aFrequency;\n    resonator->mB = r * (float) cos( arg ) * 2.0f;   \n    resonator->mA = 1.0f - resonator->mB - resonator->mC;    \n}\n\n\n/* Convert formant freqencies and bandwidth into anti-resonator difference equation constants */\nstatic void tts_resonator_initAntiresonator(\n    struct tts_resonator_t* resonator,\n    int aFrequency,                       /* Frequency of resonator in Hz  */\n    int aBandwidth,                      /* Bandwidth of resonator in Hz  */\n    int aSamplerate ) {\n\n    tts_resonator_initResonator( resonator, aFrequency, aBandwidth, aSamplerate ); /* First compute ordinary resonator coefficients */\n    /* Now convert to antiresonator coefficients */\n    resonator->mA = 1.0f / resonator->mA;             /* a'=  1/a */\n    resonator->mB *= -resonator->mA;                  /* b'= -b/a */\n    resonator->mC *= -resonator->mA;                  /* c'= -c/a */\n}\n\n\n/* Generic resonator function */\nstatic float tts_resonator_resonate( struct tts_resonator_t* resonator, float input ) {\n    float x = resonator->mA * input + resonator->mB * resonator->mP1 + resonator->mC * resonator->mP2;\n    resonator->mP2 = resonator->mP1;\n    resonator->mP1 = x;\n    return x;\n}\n\n\n/* Generic anti-resonator function\n    Same as resonator except that a,b,c need to be set with initAntiresonator()\n    and we save inputs in p1/p2 rather than outputs.\n    There is currently only one of these - \"mNasalZero\"\n*/\n/*  Output = (mNasalZero.a * input) + (mNasalZero.b * oldin1) + (mNasalZero.c * oldin2) */\n\nstatic float tts_resonator_antiresonate( struct tts_resonator_t* resonator, float input ) {\n    float x = resonator->mA * input + resonator->mB * resonator->mP1 + resonator->mC * resonator->mP2;\n    resonator->mP2 = resonator->mP1;\n    resonator->mP1 = input;\n    return x;\n}\n\n\nstatic void tts_resonator_init( struct tts_resonator_t* resonator ) {\n    resonator->mA = resonator->mB = resonator->mC = resonator->mP1 = resonator->mP2 = 0;\n}\n\n\nstatic void tts_resonator_setGain( struct tts_resonator_t* resonator, float aG ) {\n    resonator->mA *= aG;\n}\n\n\n\n#define TTS_CASCADE_PARALLEL      1\n#define TTS_ALL_PARALLEL          2\n#define TTS_NPAR                 40\n\nstruct tts_klatt_frame_t {\n    int mF0FundamentalFreq;          // Voicing fund freq in Hz                       \n    int mVoicingAmpdb;               // Amp of voicing in dB,            0 to   70    \n    int mFormant1Freq;               // First formant freq in Hz,        200 to 1300  \n    int mFormant1Bandwidth;          // First formant bw in Hz,          40 to 1000   \n    int mFormant2Freq;               // Second formant freq in Hz,       550 to 3000  \n    int mFormant2Bandwidth;          // Second formant bw in Hz,         40 to 1000   \n    int mFormant3Freq;               // Third formant freq in Hz,        1200 to 4999 \n    int mFormant3Bandwidth;          // Third formant bw in Hz,          40 to 1000   \n    int mFormant4Freq;               // Fourth formant freq in Hz,       1200 to 4999 \n    int mFormant4Bandwidth;          // Fourth formant bw in Hz,         40 to 1000   \n    int mFormant5Freq;               // Fifth formant freq in Hz,        1200 to 4999 \n    int mFormant5Bandwidth;          // Fifth formant bw in Hz,          40 to 1000   \n    int mFormant6Freq;               // Sixth formant freq in Hz,        1200 to 4999 \n    int mFormant6Bandwidth;          // Sixth formant bw in Hz,          40 to 2000   \n    int mNasalZeroFreq;              // Nasal zero freq in Hz,           248 to  528  \n    int mNasalZeroBandwidth;         // Nasal zero bw in Hz,             40 to 1000   \n    int mNasalPoleFreq;              // Nasal pole freq in Hz,           248 to  528  \n    int mNasalPoleBandwidth;         // Nasal pole bw in Hz,             40 to 1000   \n    int mAspirationAmpdb;            // Amp of aspiration in dB,         0 to   70    \n    int mNoSamplesInOpenPeriod;      // # of samples in open period,     10 to   65   \n    int mVoicingBreathiness;         // Breathiness in voicing,          0 to   80    \n    int mVoicingSpectralTiltdb;      // Voicing spectral tilt in dB,     0 to   24    \n    int mFricationAmpdb;             // Amp of frication in dB,          0 to   80    \n    int mSkewnessOfAlternatePeriods; // Skewness of alternate periods,   0 to   40 in sample#/2\n    int mFormant1Ampdb;              // Amp of par 1st formant in dB,    0 to   80  \n    int mFormant1ParallelBandwidth;  // Par. 1st formant bw in Hz,       40 to 1000 \n    int mFormant2Ampdb;              // Amp of F2 frication in dB,       0 to   80  \n    int mFormant2ParallelBandwidth;  // Par. 2nd formant bw in Hz,       40 to 1000 \n    int mFormant3Ampdb;              // Amp of F3 frication in dB,       0 to   80  \n    int mFormant3ParallelBandwidth;  // Par. 3rd formant bw in Hz,       40 to 1000 \n    int mFormant4Ampdb;              // Amp of F4 frication in dB,       0 to   80  \n    int mFormant4ParallelBandwidth;  // Par. 4th formant bw in Hz,       40 to 1000 \n    int mFormant5Ampdb;              // Amp of F5 frication in dB,       0 to   80  \n    int mFormant5ParallelBandwidth;  // Par. 5th formant bw in Hz,       40 to 1000 \n    int mFormant6Ampdb;              // Amp of F6 (same as r6pa),        0 to   80  \n    int mFormant6ParallelBandwidth;  // Par. 6th formant bw in Hz,       40 to 2000 \n    int mParallelNasalPoleAmpdb;     // Amp of par nasal pole in dB,     0 to   80  \n    int mBypassFricationAmpdb;       // Amp of bypass fric. in dB,       0 to   80  \n    int mPalallelVoicingAmpdb;       // Amp of voicing,  par in dB,      0 to   70  \n    int mOverallGaindb;              // Overall gain, 60 dB is unity,    0 to   60  \n};\n\n\nstruct tts_slope_t {\n    float mValue;                   /* boundary value */\n    int mTime;                      /* transition time */\n};\n\n\nstatic void tts_slope_init( struct tts_slope_t* slope ) {\n    slope->mValue = 0.0f;\n    slope->mTime = 0;\n}\n\n\nstruct tts_interp_t {\n    float mSteady;\n    float mFixed;\n    char  mProportion;\n    char  mExtDelay;\n    char  mIntDelay;\n};\n\n\n\nenum tts_eparm_t {\n    TTS_ELM_FN, TTS_ELM_F1, TTS_ELM_F2, TTS_ELM_F3, \n    TTS_ELM_B1, TTS_ELM_B2, TTS_ELM_B3, TTS_ELM_AN, \n    TTS_ELM_A1, TTS_ELM_A2, TTS_ELM_A3, TTS_ELM_A4, \n    TTS_ELM_A5, TTS_ELM_A6, TTS_ELM_AB, TTS_ELM_AV, \n    TTS_ELM_AVC, TTS_ELM_ASP, TTS_ELM_AF, \n    TTS_ELM_COUNT\n};\n \n\nstruct tts_element_t {\n      const char *mName; // unused\n      const char mRK;\n      const char mDU;\n      const char mUD;\n      unsigned char mFont; // unused\n      const char  *mDict; // unused\n      const char  *mIpa; // unused\n      int   mFeat; // only TTS_ELM_FEATURE_VWL\n      struct tts_interp_t mInterpolator[ TTS_ELM_COUNT ];\n};\n\n\nstruct tts_klatt_t {\n    // resonators\n    struct tts_resonator_t mParallelFormant1, mParallelFormant2, mParallelFormant3, \n                       mParallelFormant4, mParallelFormant5, mParallelFormant6,\n                       mParallelResoNasalPole, mNasalPole, mNasalZero, \n                       mCritDampedGlotLowPassFilter, mDownSampLowPassFilter, \n                       mOutputLowPassFilter;\n\n    int mF0Flutter;\n    int mSampleRate;\n    int mNspFr;\n    int mF0FundamentalFreq;        // Voicing fund freq in Hz  \n    int mVoicingAmpdb;          // Amp of voicing in dB,    0 to   70  \n    int mSkewnessOfAlternatePeriods;         // Skewness of alternate periods,0 to   40  \n    int mTimeCount;     // used for f0 flutter\n    int mNPer;          // Current loc in voicing period   40000 samp/s\n    int mT0;            // Fundamental period in output samples times 4 \n    int mNOpen;         // Number of samples in open phase of period  \n    int mNMod;          // Position in period to begin noise amp. modul \n\n    // Various amplitude variables used in main loop\n\n    float mAmpVoice;     // mVoicingAmpdb converted to linear gain  \n    float mAmpBypas;     // mBypassFricationAmpdb converted to linear gain  \n    float mAmpAspir;     // AP converted to linear gain  \n    float mAmpFrica;     // mFricationAmpdb converted to linear gain  \n    float mAmpBreth;     // ATURB converted to linear gain  \n\n    // State variables of sound sources\n\n    int mSkew;                  // Alternating jitter, in half-period units  \n    float mNatglotA;           // Makes waveshape of glottal pulse when open  \n    float mNatglotB;           // Makes waveshape of glottal pulse when open  \n    float mVWave;               // Ditto, but before multiplication by mVoicingAmpdb  \n    float mVLast;               // Previous output of voice  \n    float mNLast;               // Previous output of random number generator  \n    float mGlotLast;            // Previous value of glotout  \n    float mDecay;               // mVoicingSpectralTiltdb converted to exponential time const  \n    float mOneMd;               // in voicing one-pole TTS_ELM_FEATURE_LOW-pass filter  \n\n    int mElementCount;\n    unsigned char* mElement;\n    int mElementIndex;\n    struct tts_klatt_frame_t mKlattFramePars;\n    struct tts_element_t* mLastElement;\n    int mTStress;\n    int mNTStress;\n    struct tts_slope_t mStressS;\n    struct tts_slope_t mStressE;\n    float mTop;\n\n    int count; // MG: REINIT AT LONG PAUSE\n};\n\n\nenum tts_elm_feature_t {\n    TTS_ELM_FEATURE_ALV = 0x00000001,\n    TTS_ELM_FEATURE_APR = 0x00000002,\n    TTS_ELM_FEATURE_BCK = 0x00000004,\n    TTS_ELM_FEATURE_BLB = 0x00000008,\n    TTS_ELM_FEATURE_CNT = 0x00000010,\n    TTS_ELM_FEATURE_DNT = 0x00000020,\n    TTS_ELM_FEATURE_FNT = 0x00000040,\n    TTS_ELM_FEATURE_FRC = 0x00000080,\n    TTS_ELM_FEATURE_GLT = 0x00000100,\n    TTS_ELM_FEATURE_HGH = 0x00000200,\n    TTS_ELM_FEATURE_LAT = 0x00000400,\n    TTS_ELM_FEATURE_LBD = 0x00000800,\n    TTS_ELM_FEATURE_LBV = 0x00001000,\n    TTS_ELM_FEATURE_LMD = 0x00002000,\n    TTS_ELM_FEATURE_LOW = 0x00004000,\n    TTS_ELM_FEATURE_MDL = 0x00008000,\n    TTS_ELM_FEATURE_NAS = 0x00010000,\n    TTS_ELM_FEATURE_PAL = 0x00020000,\n    TTS_ELM_FEATURE_PLA = 0x00040000,\n    TTS_ELM_FEATURE_RND = 0x00080000,\n    TTS_ELM_FEATURE_RZD = 0x00100000,\n    TTS_ELM_FEATURE_SMH = 0x00200000,\n    TTS_ELM_FEATURE_STP = 0x00400000,\n    TTS_ELM_FEATURE_UMD = 0x00800000,\n    TTS_ELM_FEATURE_UNR = 0x01000000,\n    TTS_ELM_FEATURE_VCD = 0x02000000,\n    TTS_ELM_FEATURE_VEL = 0x04000000,\n    TTS_ELM_FEATURE_VLS = 0x08000000,\n    TTS_ELM_FEATURE_VWL = 0x10000000\n};\n\n\nenum tts_elm_t \n{\n    TTS_ELM_END = 0,    \n    TTS_ELM_Q,  TTS_ELM_P,  TTS_ELM_PY, TTS_ELM_PZ, TTS_ELM_T,  TTS_ELM_TY, \n    TTS_ELM_TZ, TTS_ELM_K,  TTS_ELM_KY, TTS_ELM_KZ, TTS_ELM_B,  TTS_ELM_BY, TTS_ELM_BZ, \n    TTS_ELM_D,  TTS_ELM_DY, TTS_ELM_DZ, TTS_ELM_G,  TTS_ELM_GY, TTS_ELM_GZ, TTS_ELM_M,  \n    TTS_ELM_N,  TTS_ELM_NG, TTS_ELM_F,  TTS_ELM_TH, TTS_ELM_S,  TTS_ELM_SH, TTS_ELM_X,\n    TTS_ELM_H,  TTS_ELM_V,  TTS_ELM_QQ, TTS_ELM_DH, TTS_ELM_DI, TTS_ELM_Z,  TTS_ELM_ZZ,\n    TTS_ELM_ZH, TTS_ELM_CH, TTS_ELM_CI, TTS_ELM_J,  TTS_ELM_JY, TTS_ELM_L,  TTS_ELM_LL,\n    TTS_ELM_RX, TTS_ELM_R,  TTS_ELM_W,  TTS_ELM_Y,  TTS_ELM_I,  TTS_ELM_E,  TTS_ELM_AA,\n    TTS_ELM_U,  TTS_ELM_O,  TTS_ELM_OO, TTS_ELM_A,  TTS_ELM_EE, TTS_ELM_ER, TTS_ELM_AR,\n    TTS_ELM_AW, TTS_ELM_UU, TTS_ELM_AI, TTS_ELM_IE, TTS_ELM_OI, TTS_ELM_OU, TTS_ELM_OV,\n    TTS_ELM_OA, TTS_ELM_IA, TTS_ELM_IB, TTS_ELM_AIR,TTS_ELM_OOR,TTS_ELM_OR\n};\n\n\n#define TTS_PHONEME_COUNT 52\n#define TTS_AMP_ADJ 14\n#define TTS_StressDur(e) (((e->mDU + e->mUD)/2))\n\n\n\n\nstruct tts_phoneme_to_elements_t  {\n    int mKey;\n    char mData[8];\n};\n\n\n/* Order is important - 2 byte phonemes first, otherwise\n   the search function will fail*/\nstatic struct tts_phoneme_to_elements_t tts_phoneme_to_elements[TTS_PHONEME_COUNT] = {\n    /* mKey, count, 0-7 elements */\n/* tS */ 0x5374, 2, TTS_ELM_CH, TTS_ELM_CI, 0, 0, 0, 0, 0,\n/* dZ */ 0x5a64, 4, TTS_ELM_J, TTS_ELM_JY, TTS_ELM_QQ, TTS_ELM_JY, 0, 0, 0,\n/* rr */ 0x7272, 3, TTS_ELM_R, TTS_ELM_QQ, TTS_ELM_R, 0, 0, 0, 0,\n/* eI */ 0x4965, 2, TTS_ELM_AI, TTS_ELM_I, 0, 0, 0, 0, 0,\n/* aI */ 0x4961, 2, TTS_ELM_IE, TTS_ELM_I, 0, 0, 0, 0, 0,\n/* oI */ 0x496f, 2, TTS_ELM_OI, TTS_ELM_I, 0, 0, 0, 0, 0,\n/* aU */ 0x5561, 2, TTS_ELM_OU, TTS_ELM_OV, 0, 0, 0, 0, 0,\n/* @U */ 0x5540, 2, TTS_ELM_OA, TTS_ELM_OV, 0, 0, 0, 0, 0,\n/* I@ */ 0x4049, 2, TTS_ELM_IA, TTS_ELM_IB, 0, 0, 0, 0, 0,\n/* e@ */ 0x4065, 2, TTS_ELM_AIR, TTS_ELM_IB, 0, 0, 0, 0, 0,\n/* U@ */ 0x4055, 2, TTS_ELM_OOR, TTS_ELM_IB, 0, 0, 0, 0, 0,\n/* O@ */ 0x404f, 2, TTS_ELM_OR, TTS_ELM_IB, 0, 0, 0, 0, 0,\n/* oU */ 0x556f, 2, TTS_ELM_OI, TTS_ELM_OV, 0, 0, 0, 0, 0,\n/*    */ 0x0020, 1, TTS_ELM_Q, 0, 0, 0, 0, 0, 0,\n/* p  */ 0x0070, 3, TTS_ELM_P, TTS_ELM_PY, TTS_ELM_PZ, 0, 0, 0, 0,\n/* t  */ 0x0074, 3, TTS_ELM_T, TTS_ELM_TY, TTS_ELM_TZ, 0, 0, 0, 0,\n/* k  */ 0x006b, 3, TTS_ELM_K, TTS_ELM_KY, TTS_ELM_KZ, 0, 0, 0, 0,\n/* b  */ 0x0062, 3, TTS_ELM_B, TTS_ELM_BY, TTS_ELM_BZ, 0, 0, 0, 0,\n/* d  */ 0x0064, 3, TTS_ELM_D, TTS_ELM_DY, TTS_ELM_DZ, 0, 0, 0, 0,\n/* g  */ 0x0067, 3, TTS_ELM_G, TTS_ELM_GY, TTS_ELM_GZ, 0, 0, 0, 0,\n/* m  */ 0x006d, 1, TTS_ELM_M, 0, 0, 0, 0, 0, 0,\n/* n  */ 0x006e, 1, TTS_ELM_N, 0, 0, 0, 0, 0, 0,\n/* N  */ 0x004e, 1, TTS_ELM_NG, 0, 0, 0, 0, 0, 0,\n/* f  */ 0x0066, 1, TTS_ELM_F, 0, 0, 0, 0, 0, 0,\n/* T  */ 0x0054, 1, TTS_ELM_TH, 0, 0, 0, 0, 0, 0,\n/* s  */ 0x0073, 1, TTS_ELM_S, 0, 0, 0, 0, 0, 0,\n/* S  */ 0x0053, 1, TTS_ELM_SH, 0, 0, 0, 0, 0, 0,\n/* h  */ 0x0068, 1, TTS_ELM_H, 0, 0, 0, 0, 0, 0,\n/* v  */ 0x0076, 3, TTS_ELM_V, TTS_ELM_QQ, TTS_ELM_V, 0, 0, 0, 0,\n/* D  */ 0x0044, 3, TTS_ELM_DH, TTS_ELM_QQ, TTS_ELM_DI, 0, 0, 0, 0,\n/* z  */ 0x007a, 3, TTS_ELM_Z, TTS_ELM_QQ, TTS_ELM_ZZ, 0, 0, 0, 0,\n/* Z  */ 0x005a, 3, TTS_ELM_ZH, TTS_ELM_QQ, TTS_ELM_ZH, 0, 0, 0, 0,\n/* l  */ 0x006c, 1, TTS_ELM_L, 0, 0, 0, 0, 0, 0,\n/* r  */ 0x0072, 1, TTS_ELM_R, 0, 0, 0, 0, 0, 0,\n/* R  */ 0x0052, 1, TTS_ELM_RX, 0, 0, 0, 0, 0, 0,\n/* w  */ 0x0077, 1, TTS_ELM_W, 0, 0, 0, 0, 0, 0,\n/* x  */ 0x0078, 1, TTS_ELM_X, 0, 0, 0, 0, 0, 0,\n/* %  */ 0x0025, 1, TTS_ELM_QQ, 0, 0, 0, 0, 0, 0,\n/* j  */ 0x006a, 1, TTS_ELM_Y, 0, 0, 0, 0, 0, 0,\n/* I  */ 0x0049, 1, TTS_ELM_I, 0, 0, 0, 0, 0, 0,\n/* e  */ 0x0065, 1, TTS_ELM_E, 0, 0, 0, 0, 0, 0,\n/* &  */ 0x0026, 1, TTS_ELM_AA, 0, 0, 0, 0, 0, 0,\n/* V  */ 0x0056, 1, TTS_ELM_U, 0, 0, 0, 0, 0, 0,\n/* 0  */ 0x0030, 1, TTS_ELM_O, 0, 0, 0, 0, 0, 0,\n/* U  */ 0x0055, 1, TTS_ELM_OO, 0, 0, 0, 0, 0, 0,\n/* @  */ 0x0040, 1, TTS_ELM_A, 0, 0, 0, 0, 0, 0,\n/* i  */ 0x0069, 1, TTS_ELM_EE, 0, 0, 0, 0, 0, 0,\n/* 3  */ 0x0033, 1, TTS_ELM_ER, 0, 0, 0, 0, 0, 0,\n/* A  */ 0x0041, 1, TTS_ELM_AR, 0, 0, 0, 0, 0, 0,\n/* O  */ 0x004f, 1, TTS_ELM_AW, 0, 0, 0, 0, 0, 0,\n/* u  */ 0x0075, 1, TTS_ELM_UU, 0, 0, 0, 0, 0, 0,\n/* o  */ 0x006f, 1, TTS_ELM_OI, 0, 0, 0, 0, 0, 0,\n};\n\n\nstatic struct tts_element_t tts_gElement[] = {\n/*mName, mRK, mDU, mUD, mFont, mDict, mIpa, mFeat, interpolators*/\n/* (mSteady, mFixed, mProportion, mExtDelay, mIntDelay) */\n{\"END\", 31, 5, 5,0x00,NULL,NULL,0,\n {\n  {   270,    135,  50,  3,  3}, /* TTS_ELM_FN       0 */\n  {   490,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {  1480,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2500,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_AN   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A1   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A2   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A3   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A4   -10.5 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"Q\",   29, 6, 6,0x00,NULL,NULL,0,\n {\n  {   270,    135,  50,  3,  3}, /* TTS_ELM_FN       0 */\n  {   490,      0, 100,  3,  3}, /* TTS_ELM_F1       0 */\n  {  1480,      0, 100,  3,  3}, /* TTS_ELM_F2       0 */\n  {  2500,      0, 100,  3,  3}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  3,  3}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  3,  3}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  3}, /* TTS_ELM_B3       0 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_AN   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A1   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A2   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A3   -10.5 */\n  {   -30,  -10.5, 100,  3,  0}, /* TTS_ELM_A4   -10.5 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"P\",   23, 8, 8,0x70,\"p\",\"p\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {   760,    350,  50,  2,  2}, /* TTS_ELM_F2     -30 */\n  {  2500,      0, 100,  0,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"PY\",  29, 1, 1,0x70,\"p\",\"p\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {   760,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2500,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {    49,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 43.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"PZ\",  23, 2, 2,0x70,\"p\",\"p\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {   760,    350,  50,  2,  2}, /* TTS_ELM_F2     -30 */\n  {  2500,      0, 100,  2,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  2,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 33.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"T\",   23, 6, 6,0x74,\"t\",\"t\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  2,  2}, /* TTS_ELM_F2      60 */\n  {  2680,   2680,   0,  0,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  0,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"TY\",  29, 1, 1,0x74,\"t\",\"t\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {  1780,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2680,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 50.75,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"TZ\",  23, 2, 2,0x74,\"t\",\"t\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  1}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  2,  1}, /* TTS_ELM_F2      60 */\n  {  2680,   2680,   0,  2,  0}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  1}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  1}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  2,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"K\",   23, 8, 8,0x6B,\"k\",\"k\",TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VEL|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  3,  3}, /* TTS_ELM_F1      15 */\n  {  1480,   1550,  50,  3,  3}, /* TTS_ELM_F2     810 */\n  {  2620,   1580,  50,  3,  3}, /* TTS_ELM_F3     270 */\n  {    60,     30,  50,  3,  3}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  3}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  3}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"KY\",  29, 1, 1,0x6B,\"k\",\"k\",TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VEL|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {  1480,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2620,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 50.75,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 50.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"KZ\",  23, 4, 4,0x6B,\"k\",\"k\",TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VEL|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  3,  3}, /* TTS_ELM_F1      15 */\n  {  1480,   1550,  50,  3,  3}, /* TTS_ELM_F2     810 */\n  {  2620,   1580,  50,  3,  3}, /* TTS_ELM_F3     270 */\n  {    60,     30,  50,  3,  3}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  3}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  3}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 19.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"B\",   26,12,12,0x62,\"b\",\"b\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {   760,    350,  50,  2,  2}, /* TTS_ELM_F2     -30 */\n  {  2500,      0, 100,  0,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"BY\",  29, 1, 1,0x62,\"b\",\"b\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {   760,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2500,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {    49,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 43.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"BZ\",  26, 0, 0,0x62,\"b\",\"b\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  0}, /* TTS_ELM_F1      15 */\n  {   760,    350,  50,  2,  0}, /* TTS_ELM_F2     -30 */\n  {  2500,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  0}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"D\",   26, 8, 8,0x64,\"d\",\"d\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  2,  2}, /* TTS_ELM_F2      60 */\n  {  2680,   2680,   0,  2,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  2,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"DY\",  29, 1, 1,0x64,\"d\",\"d\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {  1780,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2680,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {    35,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {  45.5,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"DZ\",  26, 1, 1,0x64,\"d\",\"d\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  0}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  2,  0}, /* TTS_ELM_F2      60 */\n  {  2680,   2680,   0,  2,  0}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  0}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  0}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  2,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  38.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    35,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n\n{\"G\",   26,12,12,0x67,\"g\",\"g\",TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD|TTS_ELM_FEATURE_VEL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  3,  3}, /* TTS_ELM_F1      15 */\n  {  1480,   1550,  50,  3,  3}, /* TTS_ELM_F2     810 */\n  {  2620,   1580,  50,  3,  3}, /* TTS_ELM_F3     270 */\n  {    60,     30,  50,  3,  3}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  3}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  3}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {    35,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"GY\",  29, 1, 1,0x67,\"g\",\"g\",TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD|TTS_ELM_FEATURE_VEL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {  1480,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2620,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {    35,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  45.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"GZ\",  26, 2, 2,0x67,\"g\",\"g\",TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD|TTS_ELM_FEATURE_VEL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  3,  2}, /* TTS_ELM_F1      15 */\n  {  1480,   1550,  50,  3,  2}, /* TTS_ELM_F2     810 */\n  {  2620,   1580,  50,  3,  2}, /* TTS_ELM_F3     270 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {    35,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {    35,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    14,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"M\",   15, 8, 8,0x6D,\"m\",\"m\",TTS_ELM_FEATURE_BLB|TTS_ELM_FEATURE_NAS,\n {\n  {   360,    360,   0,  3,  0}, /* TTS_ELM_FN       0 */\n  {   480,    480,   0,  3,  0}, /* TTS_ELM_F1       0 */\n  {  1000,    350,  50,  3,  0}, /* TTS_ELM_F2    -150 */\n  {  2200,      0, 100,  5,  0}, /* TTS_ELM_F3       0 */\n  {    40,     20,  50,  3,  0}, /* TTS_ELM_B1       0 */\n  {   175,     87,  50,  3,  0}, /* TTS_ELM_B2    -0.5 */\n  {   120,      0, 100,  5,  0}, /* TTS_ELM_B3       0 */\n  {    42,     21,  50,  3,  0}, /* TTS_ELM_AN       0 */\n  {    26,    -10, 100,  3,  0}, /* TTS_ELM_A1     -10 */\n  {    30,    -10, 100,  3,  0}, /* TTS_ELM_A2     -10 */\n  {    33,    -10, 100,  3,  0}, /* TTS_ELM_A3     -10 */\n  {   -30,    -10, 100,  3,  0}, /* TTS_ELM_A4     -10 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  2,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  2,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  2,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  2,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"N\",   15, 8, 8,0x6E,\"n\",\"n\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_NAS,\n {\n  {   450,    450,   0,  3,  0}, /* TTS_ELM_FN       0 */\n  {   480,    480,   0,  3,  0}, /* TTS_ELM_F1       0 */\n  {  1780,    950,  50,  3,  3}, /* TTS_ELM_F2      60 */\n  {  2620,   2680,   0,  3,  0}, /* TTS_ELM_F3      60 */\n  {    40,     20,  50,  3,  0}, /* TTS_ELM_B1       0 */\n  {   300,    150,  50,  3,  3}, /* TTS_ELM_B2       0 */\n  {   260,    130,  50,  3,  0}, /* TTS_ELM_B3       0 */\n  {    42,     21,  50,  3,  0}, /* TTS_ELM_AN       0 */\n  {    35,    -10, 100,  3,  0}, /* TTS_ELM_A1     -10 */\n  {    35,    -10, 100,  3,  0}, /* TTS_ELM_A2     -10 */\n  {    35,    -10, 100,  3,  0}, /* TTS_ELM_A3     -10 */\n  {    20,    -10, 100,  3,  0}, /* TTS_ELM_A4     -10 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  2,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  2,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  2,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  2,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"NG\",  15, 8, 8,0x4E,\"N\",\"N\",TTS_ELM_FEATURE_NAS|TTS_ELM_FEATURE_VEL,\n {\n  {   360,    360,   0,  3,  0}, /* TTS_ELM_FN       0 */\n  {   480,    480,   0,  3,  0}, /* TTS_ELM_F1       0 */\n  {   820,   1550,  50,  5,  3}, /* TTS_ELM_F2    1140 */\n  {  2800,   1580,  50,  3,  3}, /* TTS_ELM_F3     180 */\n  {   160,     80,   0,  5,  0}, /* TTS_ELM_B1     -80 */\n  {   150,     75,  50,  5,  3}, /* TTS_ELM_B2       0 */\n  {   100,     50,  50,  3,  0}, /* TTS_ELM_B3       0 */\n  {    42,     21,  50,  3,  3}, /* TTS_ELM_AN       0 */\n  {    20,      0, 100,  3,  0}, /* TTS_ELM_A1       0 */\n  {    30,      0, 100,  3,  0}, /* TTS_ELM_A2       0 */\n  {    35,      0, 100,  3,  0}, /* TTS_ELM_A3       0 */\n  {     0,      0, 100,  3,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  3,  0}, /* TTS_ELM_AB       0 */\n  {    52,     26,  50,  2,  0}, /* TTS_ELM_AV       0 */\n  {    56,     28,  50,  2,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  2,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  2,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"F\",   18,12,12,0x66,\"f\",\"f\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_LBD|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   400,    170,  50,  3,  2}, /* TTS_ELM_F1     -30 */\n  {  1420,    350,  50,  3,  2}, /* TTS_ELM_F2    -360 */\n  {  2560,    980,  50,  3,  2}, /* TTS_ELM_F3    -300 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {     0,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {     0,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {    54,     27,  50,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    32,     16,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    54,     30,  50,  0,  0}  /* TTS_ELM_AF       3 */\n }\n},\n\n{\"TH\",  18,15,15,0x54,\"T\",\"T\",TTS_ELM_FEATURE_DNT|TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   400,    170,  50,  3,  2}, /* TTS_ELM_F1     -30 */\n  {  1780,   1190,  50,  3,  2}, /* TTS_ELM_F2     300 */\n  {  2680,   2680,   0,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 22.75,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"S\",   18,12,12,0x73,\"s\",\"s\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   400,    170,  50,  3,  2}, /* TTS_ELM_F1     -30 */\n  {  1720,    950,  50,  3,  2}, /* TTS_ELM_F2      90 */\n  {  2620,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {   200,    100,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    96,     48,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   220,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    32,     16,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"SH\",  18,12,12,0x53,\"S\",\"S\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_PLA|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   400,    170,  50,  3,  2}, /* TTS_ELM_F1     -30 */\n  {  2200,   1190,  50,  3,  2}, /* TTS_ELM_F2      90 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {    42,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"X\",   18,12,12,0x78,\"x\",\"x\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VEL|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  3,  3}, /* TTS_ELM_F1      15 */\n  {  1480,   1550,  50,  3,  3}, /* TTS_ELM_F2     810 */\n  {  2620,   1580,  50,  3,  3}, /* TTS_ELM_F3     270 */\n  {    60,     30,  50,  3,  3}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  3}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  3}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 19.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"H\",    9,10,10,0x68,\"h\",\"h\",TTS_ELM_FEATURE_APR|TTS_ELM_FEATURE_GLT,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,      0, 100,  0,  7}, /* TTS_ELM_F1       0 */\n  {  1480,      0, 100,  0,  7}, /* TTS_ELM_F2       0 */\n  {  2500,      0, 100,  0,  7}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  7}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  7}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  7}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  7}, /* TTS_ELM_AN       0 */\n  {    35,    -14, 100,  0,  7}, /* TTS_ELM_A1     -14 */\n  { 36.75,    -14, 100,  0,  7}, /* TTS_ELM_A2     -14 */\n  { 26.25,     -7, 100,  0,  7}, /* TTS_ELM_A3      -7 */\n  { 22.75,   -3.5, 100,  0,  7}, /* TTS_ELM_A4    -3.5 */\n  {   -30,      0, 100,  0,  7}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  7}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  7}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"V\",   20, 4, 4,0x76,\"v\",\"v\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_LBD|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  1420,    350,  50,  3,  2}, /* TTS_ELM_F2    -360 */\n  {  2560,    980,  50,  3,  2}, /* TTS_ELM_F3    -300 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 33.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"QQ\",  30, 0, 0,0x5A,\"Z\",\"Z\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,      0, 100,  0,  0}, /* TTS_ELM_F1       0 */\n  {  1420,      0, 100,  0,  0}, /* TTS_ELM_F2       0 */\n  {  2560,      0, 100,  0,  0}, /* TTS_ELM_F3       0 */\n  {    60,      0, 100,  0,  0}, /* TTS_ELM_B1       0 */\n  {    90,      0, 100,  0,  0}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  0,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 40.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 33.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"DH\",  20, 4, 4,0x54,\"D\",\"D\",TTS_ELM_FEATURE_DNT|TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  1600,   1190,  50,  3,  2}, /* TTS_ELM_F2     390 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {    54,     27,  50,  0,  0}, /* TTS_ELM_AB       0 */\n  {    36,     18,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    54,     27,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"DI\",  20, 4, 4,0x54,\"D\",\"D\",TTS_ELM_FEATURE_DNT|TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  1600,   1190,  50,  3,  2}, /* TTS_ELM_F2     390 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    28,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"Z\",   20, 4, 4,0x7A,\"z\",\"z\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  1720,    950,  50,  3,  2}, /* TTS_ELM_F2      90 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    40,     20,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    54,     27,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"ZZ\",  20, 4, 4,0x7A,\"z\",\"z\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  1720,    950,  50,  3,  2}, /* TTS_ELM_F2      90 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {  24.5,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"ZH\",  20, 4, 4,0x5A,\"Z\",\"Z\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_PLA|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  2020,   1190,  50,  3,  2}, /* TTS_ELM_F2     180 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"CH\",  23, 4, 4,0x74,\"t\",\"t\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  2,  2}, /* TTS_ELM_F2      60 */\n  {  2680,   2680,   0,  2,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  2,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"CI\",  18, 8, 8,0x53,\"S\",\"S\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_PLA|TTS_ELM_FEATURE_VLS,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   400,    170,  50,  3,  2}, /* TTS_ELM_F1     -30 */\n  {  2020,   1190,  50,  3,  2}, /* TTS_ELM_F2     180 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {    42,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {    60,     30,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {    60,     30,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"J\",   26, 4, 4,0x64,\"d\",\"d\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_STP|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,    110,  50,  2,  2}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  2,  2}, /* TTS_ELM_F2      60 */\n  {  2680,   2680,   0,  2,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  2,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  2,  2}, /* TTS_ELM_B2       0 */\n  {   150,    150,   0,  2,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  {  31.5,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"JY\",  20, 3, 3,0x5A,\"Z\",\"Z\",TTS_ELM_FEATURE_FRC|TTS_ELM_FEATURE_PLA|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   280,    170,  50,  3,  2}, /* TTS_ELM_F1      30 */\n  {  2020,   1190,  50,  3,  2}, /* TTS_ELM_F2     180 */\n  {  2560,      0, 100,  3,  2}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  3,  2}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  3,  2}, /* TTS_ELM_B2       0 */\n  {   150,      0, 100,  3,  2}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 29.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"L\",   11, 8, 8,0x6C,\"l\",\"l\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_LAT|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   460,    230,  50,  6,  0}, /* TTS_ELM_F1       0 */\n  {  1480,    710,  50,  6,  0}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  6,  0}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  6,  0}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  6,  0}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  6,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    21,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"LL\",  11, 8, 8,0x6C,\"l\",\"l\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_LAT|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   460,    230,  50,  6,  0}, /* TTS_ELM_F1       0 */\n  {   940,    470,  50,  6,  0}, /* TTS_ELM_F2       0 */\n  {  2500,   1220,  50,  6,  0}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  6,  0}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  6,  0}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  6,  0}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AN       0 */\n  { 36.75,      0, 100,  0,  0}, /* TTS_ELM_A1       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A2       0 */\n  { 26.25,      0, 100,  0,  0}, /* TTS_ELM_A3       0 */\n  {    21,      0, 100,  0,  0}, /* TTS_ELM_A4       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A5       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_A6       0 */\n  {   -30,      0, 100,  0,  0}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"RX\",  10,10,10,0xD5,\"R\",\"<TTS_ELM_FEATURE_RZD>\",TTS_ELM_FEATURE_RZD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,      0, 100,  0,  5}, /* TTS_ELM_F1       0 */\n  {  1180,      0, 100,  0,  5}, /* TTS_ELM_F2       0 */\n  {  1600,   1600,   0,  5,  5}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  0,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {    70,     35,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  {    42,     21,  50,  5,  5}, /* TTS_ELM_A1       0 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A2       0 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A3       0 */\n  {   -30,      0,  50,  5,  5}, /* TTS_ELM_A4      15 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    50,     25,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"R\",   10,11,11,0xA8,\"r\",\"r\",TTS_ELM_FEATURE_ALV|TTS_ELM_FEATURE_APR,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,      0, 100,  0,  5}, /* TTS_ELM_F1       0 */\n  {  1180,    590,  50,  5,  5}, /* TTS_ELM_F2       0 */\n  {  1600,    740,  50,  5,  5}, /* TTS_ELM_F3     -60 */\n  {    60,      0, 100,  0,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  {    42,     21,  50,  5,  5}, /* TTS_ELM_A1       0 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A2       0 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A3       0 */\n  {   -30,      0,  50,  5,  5}, /* TTS_ELM_A4      15 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"W\",   10, 8, 8,0x77,\"w\",\"w\",TTS_ELM_FEATURE_APR|TTS_ELM_FEATURE_LBV|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   190,     50,  50,  4,  4}, /* TTS_ELM_F1     -45 */\n  {   760,    350,  50,  4,  4}, /* TTS_ELM_F2     -30 */\n  {  2020,    980,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 43.75,     21,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {    28,     14,  50,  4,  4}, /* TTS_ELM_A2       0 */\n  {    21,   10.5,  50,  4,  4}, /* TTS_ELM_A3       0 */\n  {   -30,      0,  50,  4,  4}, /* TTS_ELM_A4      15 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"Y\",   10, 7, 7,0x6A,\"j\",\"j\",TTS_ELM_FEATURE_APR|TTS_ELM_FEATURE_PAL|TTS_ELM_FEATURE_VCD,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   250,    110,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {  2500,   1190,  50,  4,  4}, /* TTS_ELM_F2     -60 */\n  {  2980,   1460,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 33.25,   17.5,  50,  4,  4}, /* TTS_ELM_A2   0.875 */\n  {  38.5,   17.5,  50,  4,  4}, /* TTS_ELM_A3   -1.75 */\n  {  31.5,     14,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"I\",    2, 8, 6,0x49,\"I\",\"I\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_SMH|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   400,    170,  50,  4,  4}, /* TTS_ELM_F1     -30 */\n  {  2080,   1070,  50,  4,  4}, /* TTS_ELM_F2      30 */\n  {  2560,   1340,  50,  4,  4}, /* TTS_ELM_F3      60 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 36.75,   17.5,  50,  4,  4}, /* TTS_ELM_A2  -0.875 */\n  {    35,   17.5,  50,  4,  4}, /* TTS_ELM_A3       0 */\n  { 29.75,     14,  50,  4,  4}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"E\",    2, 8, 4,0x45,\"e\",\"E\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   640,    350,  50,  4,  4}, /* TTS_ELM_F1      30 */\n  {  2020,   1070,  50,  4,  4}, /* TTS_ELM_F2      60 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {    42,     21,  50,  4,  4}, /* TTS_ELM_A2       0 */\n  {  38.5,   17.5,  50,  4,  4}, /* TTS_ELM_A3   -1.75 */\n  {  31.5,     14,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"AA\",   2,10, 5,0x51,\"&\",\"&\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_LOW|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   790,    410,  50,  4,  4}, /* TTS_ELM_F1      15 */\n  {  1780,    950,  50,  4,  4}, /* TTS_ELM_F2      60 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {   130,     65,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 47.25,   24.5,  50,  4,  4}, /* TTS_ELM_A2   0.875 */\n  {  38.5,   17.5,  50,  4,  4}, /* TTS_ELM_A3   -1.75 */\n  {  31.5,     14,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"U\",    2, 9, 6,0xC3,\"V\",\"V\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   700,    350,  50,  4,  4}, /* TTS_ELM_F1       0 */\n  {  1360,    710,  50,  4,  4}, /* TTS_ELM_F2      30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 43.75,     21,  50,  4,  4}, /* TTS_ELM_A2  -0.875 */\n  {  31.5,     14,  50,  4,  4}, /* TTS_ELM_A3   -1.75 */\n  {  24.5,   10.5,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"O\",    2, 9, 6,0x81,\"0\",\"A.\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_LOW|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   610,    290,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {   880,    470,  50,  4,  4}, /* TTS_ELM_F2      30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 47.25,   24.5,  50,  4,  4}, /* TTS_ELM_A2   0.875 */\n  { 22.75,   10.5,  50,  4,  4}, /* TTS_ELM_A3  -0.875 */\n  { 15.75,      7,  50,  4,  4}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OO\",   2, 6, 4,0x55,\"U\",\"U\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_SMH|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   370,    170,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {  1000,    470,  50,  4,  4}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {    42,     21,  50,  4,  4}, /* TTS_ELM_A2       0 */\n  {    28,     14,  50,  4,  4}, /* TTS_ELM_A3       0 */\n  { 22.75,   10.5,  50,  4,  4}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"A\",    2, 4, 4,0xAB,\"@\",\"@\",TTS_ELM_FEATURE_CNT|TTS_ELM_FEATURE_MDL|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,    230,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {  1480,    710,  50,  4,  4}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A2  -0.875 */\n  { 33.25,   17.5,  50,  4,  4}, /* TTS_ELM_A3   0.875 */\n  { 26.25,     14,  50,  4,  4}, /* TTS_ELM_A4   0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"EE\",   2,11, 7,0x69,\"i\",\"i\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_HGH|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   250,    110,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {  2320,   1190,  50,  4,  4}, /* TTS_ELM_F2      30 */\n  {  3200,   1580,  50,  4,  4}, /* TTS_ELM_F3     -20 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 33.25,   17.5,  50,  4,  4}, /* TTS_ELM_A2   0.875 */\n  { 36.75,   17.5,  50,  4,  4}, /* TTS_ELM_A3  -0.875 */\n  {  31.5,     14,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"ER\",   2,16,16,0xCE,\"3\",\"V\\\"\",TTS_ELM_FEATURE_CNT|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   580,    290,  50,  4,  4}, /* TTS_ELM_F1       0 */\n  {  1420,    710,  50,  4,  4}, /* TTS_ELM_F2       0 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {  45.5,     21,  50,  4,  4}, /* TTS_ELM_A2   -1.75 */\n  { 33.25,   17.5,  50,  4,  4}, /* TTS_ELM_A3   0.875 */\n  { 26.25,     14,  50,  4,  4}, /* TTS_ELM_A4   0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"AR\",   2,15,15,0x41,\"A\",\"A\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_LOW|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   790,    410,  50,  4,  4}, /* TTS_ELM_F1      15 */\n  {   880,    470,  50,  4,  4}, /* TTS_ELM_F2      30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {    49,   24.5,  50,  4,  4}, /* TTS_ELM_A2       0 */\n  { 29.75,     14,  50,  4,  4}, /* TTS_ELM_A3  -0.875 */\n  { 22.75,   10.5,  50,  4,  4}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"AW\",   2,16,10,0x8D,\"O\",\"O\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,    230,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {   820,    470,  50,  4,  4}, /* TTS_ELM_F2      60 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {  45.5,     21,  50,  4,  4}, /* TTS_ELM_A2   -1.75 */\n  { 22.75,   10.5,  50,  4,  4}, /* TTS_ELM_A3  -0.875 */\n  {  17.5,      7,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"UU\",   2,14, 9,0x75,\"u\",\"u\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_HGH|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   250,    110,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {   880,    470,  50,  4,  4}, /* TTS_ELM_F2      30 */\n  {  2200,   1100,  50,  4,  4}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {  38.5,   17.5,  50,  4,  4}, /* TTS_ELM_A2   -1.75 */\n  {  17.5,      7,  50,  4,  4}, /* TTS_ELM_A3   -1.75 */\n  {  10.5,    3.5,  50,  4,  4}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"AI\",   2, 9, 6,0x45,\"e\",\"E\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   640,    290,  50,  5,  5}, /* TTS_ELM_F1     -30 */\n  {  1600,    830,  50,  5,  5}, /* TTS_ELM_F2      30 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {  45.5,     21,  50,  5,  5}, /* TTS_ELM_A2   -1.75 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A3       0 */\n  { 29.75,     14,  50,  5,  5}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"IE\",   2, 9, 6,0x61,\"a\",\"a\",TTS_ELM_FEATURE_CNT|TTS_ELM_FEATURE_LOW|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   790,    410,  50,  5,  5}, /* TTS_ELM_F1      15 */\n  {   880,    470,  50,  5,  5}, /* TTS_ELM_F2      30 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {    49,   24.5,  50,  5,  5}, /* TTS_ELM_A2       0 */\n  { 29.75,     14,  50,  5,  5}, /* TTS_ELM_A3  -0.875 */\n  { 22.75,   10.5,  50,  5,  5}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OI\",   2, 9, 6,0x6F,\"o\",\"o\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_UMD|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,    230,  50,  5,  5}, /* TTS_ELM_F1     -15 */\n  {   820,    350,  50,  5,  5}, /* TTS_ELM_F2     -60 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {  45.5,     21,  50,  5,  5}, /* TTS_ELM_A2   -1.75 */\n  { 22.75,   10.5,  50,  5,  5}, /* TTS_ELM_A3  -0.875 */\n  {  17.5,      7,  50,  5,  5}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OU\",   2, 9, 6,0x61,\"a\",\"a\",TTS_ELM_FEATURE_CNT|TTS_ELM_FEATURE_LOW|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   790,    410,  50,  5,  5}, /* TTS_ELM_F1      15 */\n  {  1300,    590,  50,  5,  5}, /* TTS_ELM_F2     -60 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  { 47.25,   24.5,  50,  5,  5}, /* TTS_ELM_A2   0.875 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A3       0 */\n  {    28,     14,  50,  5,  5}, /* TTS_ELM_A4       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OV\",   2, 8, 6,0x55,\"U\",\"U\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_SMH|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   370,    170,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {  1000,    470,  50,  4,  4}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  {    42,     21,  50,  4,  4}, /* TTS_ELM_A2       0 */\n  {    28,     14,  50,  4,  4}, /* TTS_ELM_A3       0 */\n  { 22.75,   10.5,  50,  4,  4}, /* TTS_ELM_A4  -0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OA\",   2, 9, 6,0xAB,\"@\",\"@\",TTS_ELM_FEATURE_CNT|TTS_ELM_FEATURE_MDL|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,    230,  50,  5,  5}, /* TTS_ELM_F1     -15 */\n  {  1480,    710,  50,  5,  5}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A2  -0.875 */\n  { 33.25,   17.5,  50,  5,  5}, /* TTS_ELM_A3   0.875 */\n  { 26.25,     14,  50,  5,  5}, /* TTS_ELM_A4   0.875 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"IA\",   2, 9, 6,0x49,\"I\",\"I\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_SMH|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   310,    170,  50,  5,  5}, /* TTS_ELM_F1      15 */\n  {  2200,   1070,  50,  5,  5}, /* TTS_ELM_F2     -30 */\n  {  2920,   1460,  50,  5,  5}, /* TTS_ELM_F3       0 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {    35,   17.5,  50,  5,  5}, /* TTS_ELM_A2       0 */\n  { 36.75,   17.5,  50,  5,  5}, /* TTS_ELM_A3  -0.875 */\n  {  31.5,     14,  50,  5,  5}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"IB\",   2, 8, 6,0x51,\"@\",\"@\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_LOW|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,    230,  50,  4,  4}, /* TTS_ELM_F1     -15 */\n  {  1480,    710,  50,  4,  4}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  4,  4}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  4,  4}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  4,  4}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  4,  4}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  4,  4}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A1  -0.875 */\n  { 50.75,   24.5,  50,  4,  4}, /* TTS_ELM_A2  -0.875 */\n  { 33.25,   17.5,  50,  4,  4}, /* TTS_ELM_A3   0.875 */\n  { 26.25,     14,  50,  4,  4}, /* TTS_ELM_A4   0.875 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  4,  4}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"AIR\",  2, 9, 6,0x45,\"e\",\"E\",TTS_ELM_FEATURE_FNT|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_UNR|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   640,    350,  50,  5,  5}, /* TTS_ELM_F1      30 */\n  {  2020,   1070,  50,  5,  5}, /* TTS_ELM_F2      60 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {    42,     21,  50,  5,  5}, /* TTS_ELM_A2       0 */\n  {  38.5,   17.5,  50,  5,  5}, /* TTS_ELM_A3   -1.75 */\n  {  31.5,     14,  50,  5,  5}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OOR\",  2, 9, 6,0x55,\"U\",\"U\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_SMH|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   370,    170,  50,  5,  5}, /* TTS_ELM_F1     -15 */\n  {  1000,    470,  50,  5,  5}, /* TTS_ELM_F2     -30 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {    42,     21,  50,  5,  5}, /* TTS_ELM_A2       0 */\n  {    28,     14,  50,  5,  5}, /* TTS_ELM_A3       0 */\n  { 22.75,      7,  50,  5,  5}, /* TTS_ELM_A4  -4.375 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n},\n\n{\"OR\",   2, 9, 6,0x8D,\"O\",\"O\",TTS_ELM_FEATURE_BCK|TTS_ELM_FEATURE_LMD|TTS_ELM_FEATURE_RND|TTS_ELM_FEATURE_VWL,\n {\n  {   270,    135,  50,  0,  0}, /* TTS_ELM_FN       0 */\n  {   490,    230,  50,  5,  5}, /* TTS_ELM_F1     -15 */\n  {   820,    470,  50,  5,  5}, /* TTS_ELM_F2      60 */\n  {  2500,   1220,  50,  5,  5}, /* TTS_ELM_F3     -30 */\n  {    60,     30,  50,  5,  5}, /* TTS_ELM_B1       0 */\n  {    90,     45,  50,  5,  5}, /* TTS_ELM_B2       0 */\n  {   150,     75,  50,  5,  5}, /* TTS_ELM_B3       0 */\n  {   -30,      0, 100,  5,  5}, /* TTS_ELM_AN       0 */\n  { 50.75,   24.5,  50,  5,  5}, /* TTS_ELM_A1  -0.875 */\n  {  45.5,     21,  50,  5,  5}, /* TTS_ELM_A2   -1.75 */\n  { 22.75,   10.5,  50,  5,  5}, /* TTS_ELM_A3  -0.875 */\n  {  17.5,      7,  50,  5,  5}, /* TTS_ELM_A4   -1.75 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A5       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_A6       0 */\n  {   -30,    -15,  50,  5,  5}, /* TTS_ELM_AB       0 */\n  {    62,     31,  50,  0,  0}, /* TTS_ELM_AV       0 */\n  {    16,      8,  50,  0,  0}, /* TTS_ELM_AVC      0 */\n  {     0,      0,  50,  0,  0}, /* TTS_ELM_ASP      0 */\n  {     0,      0,  50,  0,  0}  /* TTS_ELM_AF       0 */\n }\n} \n\n};\n\nstatic short tts_clip( float input ) {\n    int temp = (int)input;\n    /* tts_clip on boundaries of 16-bit word */\n\n    if (temp < -32767) {\n        //assert?\n        temp = -32767;\n    } else if (temp > 32767) {\n        //assert?\n        temp = 32767;\n    }\n\n    return (short)(temp);\n}\n\n/* Convert from decibels to a linear scale factor */\nstatic float tts_DBtoLIN(int dB) {\n    /*\n    * Convertion table, db to linear, 87 dB --> 32767\n    *                                 86 dB --> 29491 (1 dB down = 0.5**1/6)\n    *                                 ...\n    *                                 81 dB --> 16384 (6 dB down = 0.5)\n    *                                 ...\n    *                                  0 dB -->     0\n    *\n    * The just noticeable difference for a change in intensity of a vowel\n    *   is approximately 1 dB.  Thus all amplitudes are quantized to 1 dB\n    *   steps.\n    */\n\n    static const float amptable[88] = {\n        0.0, 0.0, 0.0, 0.0, 0.0,\n        0.0, 0.0, 0.0, 0.0, 0.0,\n        0.0, 0.0, 0.0, 6.0, 7.0,\n        8.0, 9.0, 10.0, 11.0, 13.0,\n        14.0, 16.0, 18.0, 20.0, 22.0,\n        25.0, 28.0, 32.0, 35.0, 40.0,\n        45.0, 51.0, 57.0, 64.0, 71.0,\n        80.0, 90.0, 101.0, 114.0, 128.0,\n        142.0, 159.0, 179.0, 202.0, 227.0,\n        256.0, 284.0, 318.0, 359.0, 405.0,\n        455.0, 512.0, 568.0, 638.0, 719.0,\n        811.0, 911.0, 1024.0, 1137.0, 1276.0,\n        1438.0, 1622.0, 1823.0, 2048.0, 2273.0,\n        2552.0, 2875.0, 3244.0, 3645.0, 4096.0,\n        4547.0, 5104.0, 5751.0, 6488.0, 7291.0,\n        8192.0, 9093.0, 10207.0, 11502.0, 12976.0,\n        14582.0, 16384.0, 18350.0, 20644.0, 23429.0,\n        26214.0, 29491.0, 32767.0\n    };\n\n    // Check limits or argument (can be removed in final product)\n    if (dB < 0) {\n        dB = 0;\n    } else if (dB >= 88) {\n        dB = 87;\n    }\n\n    return amptable[dB] * 0.001f;\n}\n\n\n\nstatic void tts_klatt_frame_init( struct tts_klatt_frame_t* klatt_frame ) {\n    klatt_frame->mF0FundamentalFreq = 1330;   \n    klatt_frame->mVoicingAmpdb = 60;              \n    klatt_frame->mFormant1Freq = 500;  \n    klatt_frame->mFormant1Bandwidth = 60;     \n    klatt_frame->mFormant2Freq = 1500;            \n    klatt_frame->mFormant2Bandwidth = 90;\n    klatt_frame->mFormant3Freq = 2800;        \n    klatt_frame->mFormant3Bandwidth = 150;        \n    klatt_frame->mFormant4Freq = 3250; \n    klatt_frame->mFormant4Bandwidth = 200;    \n    klatt_frame->mFormant5Freq = 3700;            \n    klatt_frame->mFormant5Bandwidth = 200;  \n    klatt_frame->mFormant6Freq = 4990;        \n    klatt_frame->mFormant6Bandwidth = 500;        \n    klatt_frame->mNasalZeroFreq = 270;  \n    klatt_frame->mNasalZeroBandwidth = 100;   \n    klatt_frame->mNasalPoleFreq = 270;            \n    klatt_frame->mNasalPoleBandwidth = 100; \n    klatt_frame->mAspirationAmpdb = 0;        \n    klatt_frame->mNoSamplesInOpenPeriod = 30;     \n    klatt_frame->mVoicingBreathiness = 0;      \n    klatt_frame->mVoicingSpectralTiltdb = 10; \n    klatt_frame->mFricationAmpdb = 0;             \n    klatt_frame->mSkewnessOfAlternatePeriods = 0;   \n    klatt_frame->mFormant1Ampdb = 0;          \n    klatt_frame->mFormant1ParallelBandwidth = 80; \n    klatt_frame->mFormant2Ampdb = 0;      \n    klatt_frame->mFormant2ParallelBandwidth = 200; \n    klatt_frame->mFormant3Ampdb = 0;         \n    klatt_frame->mFormant3ParallelBandwidth = 350;\n    klatt_frame->mFormant4Ampdb = 0;          \n    klatt_frame->mFormant4ParallelBandwidth = 500; \n    klatt_frame->mFormant5Ampdb = 0;      \n    klatt_frame->mFormant5ParallelBandwidth = 600; \n    klatt_frame->mFormant6Ampdb = 0;         \n    klatt_frame->mFormant6ParallelBandwidth = 800;    \n    klatt_frame->mParallelNasalPoleAmpdb = 0; \n    klatt_frame->mBypassFricationAmpdb = 0;       \n    klatt_frame->mPalallelVoicingAmpdb = 0;   \n    klatt_frame->mOverallGaindb = 62;\n};\n\n\n/*\nfunction FLUTTER\n\nThis function adds F0 flutter, as specified in:\n\n\"Analysis, synthesis and perception of voice quality variations among\nfemale and male talkers\" D.H. Klatt and L.C. Klatt JASA 87(2) February 1990.\nFlutter is added by applying a quasi-random element constructed from three\nslowly varying sine waves.\n*/\nstatic void tts_klatt_flutter( struct tts_klatt_t* klatt, struct tts_klatt_frame_t* pars ) {\n    int original_f0 = pars->mF0FundamentalFreq / 10;\n    float fla = (float) klatt->mF0Flutter / 50;\n    float flb = (float) original_f0 / 100;\n    float flc = (float)sin(2 * TTS_PI * 12.7 * klatt->mTimeCount);\n    float fld = (float)sin(2 * TTS_PI * 7.1 * klatt->mTimeCount);\n    float fle = (float)sin(2 * TTS_PI * 4.7 * klatt->mTimeCount);\n    float delta_f0 = fla * flb * (flc + fld + fle) * 10;\n    klatt->mF0FundamentalFreq += (int) delta_f0;\n}\n\n/* Vwave is the differentiated glottal flow waveform, there is a weak\nspectral zero around 800 Hz, magic constants a,b reset pitch-synch\n*/\n\nstatic float tts_klatt_natural_source( struct tts_klatt_t* klatt, int aNper ) {\n    // See if glottis open \n\n    if (aNper < klatt->mNOpen) {\n        float lgtemp;\n        klatt->mNatglotA -= klatt->mNatglotB;\n        klatt->mVWave += klatt->mNatglotA;\n        lgtemp = klatt->mVWave * 0.028f;        /* function of samp_rate ? */\n        return (lgtemp);\n    } else {\n        // Glottis closed \n        klatt->mVWave = 0.0;\n        return (0.0);\n    }\n}\n\n/* Reset selected parameters pitch-synchronously */\n\nstatic void tts_klatt_pitch_synch_par_reset( struct tts_klatt_t* klatt, struct tts_klatt_frame_t* frame, int ns ) {\n    /*\n    * Constant natglot[] controls shape of glottal pulse as a function\n    * of desired duration of open phase N0\n    * (Note that N0 is specified in terms of 40,000 samples/sec of speech)\n    *\n    *    Assume voicing waveform V(t) has form: k1 t**2 - k2 t**3\n    *\n    *    If the radiation characterivative, a temporal derivative\n    *      is folded in, and we go from continuous time to discrete\n    *      integers n:  dV/dt = mVWave[n]\n    *                         = sum over i=1,2,...,n of { a - (i * b) }\n    *                         = a n  -  b/2 n**2\n    *\n    *      where the  constants a and b control the detailed shape\n    *      and amplitude of the voicing waveform over the open\n    *      potion of the voicing cycle \"mNOpen\".\n    *\n    *    Let integral of dV/dt have no net dc flow --> a = (b * mNOpen) / 3\n    *\n    *    Let maximum of dUg(n)/dn be constant --> b = gain / (mNOpen * mNOpen)\n    *      meaning as mNOpen gets bigger, V has bigger peak proportional to n\n    *\n    *    Thus, to generate the table below for 40 <= mNOpen <= 263:\n    *\n    *      natglot[mNOpen - 40] = 1920000 / (mNOpen * mNOpen)\n    */\n    static const short natglot[ 224 ] = {\n        1200, 1142, 1088, 1038, 991, 948, 907, 869, 833, 799,\n        768, 738, 710, 683, 658, 634, 612, 590, 570, 551,\n        533, 515, 499, 483, 468, 454, 440, 427, 415, 403,\n        391, 380, 370, 360, 350, 341, 332, 323, 315, 307,\n        300, 292, 285, 278, 272, 265, 259, 253, 247, 242,\n        237, 231, 226, 221, 217, 212, 208, 204, 199, 195,\n        192, 188, 184, 180, 177, 174, 170, 167, 164, 161,\n        158, 155, 153, 150, 147, 145, 142, 140, 137, 135,\n        133, 131, 128, 126, 124, 122, 120, 119, 117, 115,\n        113, 111, 110, 108, 106, 105, 103, 102, 100, 99,\n        97, 96, 95, 93, 92, 91, 90, 88, 87, 86,\n        85, 84, 83, 82, 80, 79, 78, 77, 76, 75,\n        75, 74, 73, 72, 71, 70, 69, 68, 68, 67,\n        66, 65, 64, 64, 63, 62, 61, 61, 60, 59,\n        59, 58, 57, 57, 56, 56, 55, 55, 54, 54,\n        53, 53, 52, 52, 51, 51, 50, 50, 49, 49,\n        48, 48, 47, 47, 46, 46, 45, 45, 44, 44,\n        43, 43, 42, 42, 41, 41, 41, 41, 40, 40,\n        39, 39, 38, 38, 38, 38, 37, 37, 36, 36,\n        36, 36, 35, 35, 35, 35, 34, 34, 33, 33,\n        33, 33, 32, 32, 32, 32, 31, 31, 31, 31,\n        30, 30, 30, 30, 29, 29, 29, 29, 28, 28,\n        28, 28, 27, 27\n    };\n\n    if( klatt->mF0FundamentalFreq > 0) {\n        klatt->mT0 = (40 * klatt->mSampleRate) / klatt->mF0FundamentalFreq;\n\n        /* Period in samp*4 */\n        klatt->mAmpVoice = tts_DBtoLIN(klatt->mVoicingAmpdb);\n\n        /* Duration of period before amplitude modulation */\n        klatt->mNMod = klatt->mT0;\n\n        if (klatt->mVoicingAmpdb > 0) {\n            klatt->mNMod >>= 1;\n        }\n\n        /* Breathiness of voicing waveform */\n\n        klatt->mAmpBreth = tts_DBtoLIN(frame->mVoicingBreathiness) * 0.1f;\n\n        /* Set open phase of glottal period */\n        /* where  40 <= open phase <= 263 */\n\n        klatt->mNOpen = 4 * frame->mNoSamplesInOpenPeriod;\n\n        if (klatt->mNOpen >= (klatt->mT0 - 1)) {\n            klatt->mNOpen = klatt->mT0 - 2;\n        }\n\n        if (klatt->mNOpen < 40) {\n            klatt->mNOpen = 40;                  /* F0 max = 1000 Hz */\n        }\n\n        /* Reset a & b, which determine shape of \"natural\" glottal waveform */\n\n        klatt->mNatglotB = natglot[klatt->mNOpen - 40];\n        klatt->mNatglotA = (klatt->mNatglotB * klatt->mNOpen) * .333f;\n\n        /* Reset width of \"impulsive\" glottal pulse */\n\n        int temp;\n        float temp1;\n\n        temp = klatt->mSampleRate / klatt->mNOpen;\n        tts_resonator_initResonator( &klatt->mCritDampedGlotLowPassFilter, 0L, temp, klatt->mSampleRate);\n\n        /* Make gain at F1 about constant */\n\n        temp1 = klatt->mNOpen * .00833f;\n        tts_resonator_setGain( &klatt->mCritDampedGlotLowPassFilter, temp1 * temp1);\n\n        /* Truncate skewness so as not to exceed duration of closed phase\n        of glottal period */\n\n        temp = klatt->mT0 - klatt->mNOpen;\n\n        if (klatt->mSkewnessOfAlternatePeriods > temp) {\n            klatt->mSkewnessOfAlternatePeriods = temp;\n        }\n\n        if (klatt->mSkew >= 0) {\n            klatt->mSkew = klatt->mSkewnessOfAlternatePeriods;                /* Reset mSkew to requested mSkewnessOfAlternatePeriods */\n        } else {\n            klatt->mSkew = -klatt->mSkewnessOfAlternatePeriods;\n        }\n\n        /* Add skewness to closed portion of voicing period */\n\n        klatt->mT0 = klatt->mT0 + klatt->mSkew;\n        klatt->mSkew = -klatt->mSkew;\n    } else {\n        klatt->mT0 = 4;                        /* Default for f0 undefined */\n        klatt->mAmpVoice = 0.0;\n        klatt->mNMod = klatt->mT0;\n        klatt->mAmpBreth = 0.0;\n        klatt->mNatglotA = 0.0;\n        klatt->mNatglotB = 0.0;\n    }\n\n    /* Reset these pars pitch synchronously or at update rate if f0=0 */\n\n    if( (klatt->mT0 != 4) || (ns == 0) ) {\n        /* Set one-pole TTS_ELM_FEATURE_LOW-pass filter that tilts glottal source */\n        klatt->mDecay = (0.033f * frame->mVoicingSpectralTiltdb);  /* Function of samp_rate ? */\n\n        if (klatt->mDecay > 0.0f) {\n            klatt->mOneMd = 1.0f - klatt->mDecay;\n        } else {\n            klatt->mOneMd = 1.0f;\n        }\n    }\n}\n\n\n/* Get variable parameters from host computer,\ninitially also get definition of fixed pars\n*/\n\nstatic void tts_klatt_frame_setup( struct tts_klatt_t* klatt, struct tts_klatt_frame_t* frame ) {\n    int mOverallGaindb;                       /* Overall gain, 60 dB is unity  0 to   60  */\n    float amp_parF1;                 /* mFormant1Ampdb converted to linear gain  */\n    float amp_parFN;                 /* mParallelNasalPoleAmpdb converted to linear gain  */\n    float amp_parF2;                 /* mFormant2Ampdb converted to linear gain  */\n    float amp_parF3;                 /* mFormant3Ampdb converted to linear gain  */\n    float amp_parF4;                 /* mFormant4Ampdb converted to linear gain  */\n    float amp_parF5;                 /* mFormant5Ampdb converted to linear gain  */\n    float amp_parF6;                 /* mFormant6Ampdb converted to linear gain  */\n\n    /* Read  speech frame definition into temp store\n       and move some parameters into active use immediately\n       (voice-excited ones are updated pitch synchronously\n       to avoid waveform glitches).\n     */\n\n    klatt->mF0FundamentalFreq = frame->mF0FundamentalFreq;\n    klatt->mVoicingAmpdb = frame->mVoicingAmpdb - 7;\n\n    if (klatt->mVoicingAmpdb < 0) klatt->mVoicingAmpdb = 0;\n\n    klatt->mAmpAspir = tts_DBtoLIN(frame->mAspirationAmpdb) * .05f;\n    klatt->mAmpFrica = tts_DBtoLIN(frame->mFricationAmpdb) * 0.25f;\n    klatt->mSkewnessOfAlternatePeriods = frame->mSkewnessOfAlternatePeriods;\n\n    /* Fudge factors (which comprehend affects of formants on each other?)\n       with these in place TTS_ALL_PARALLEL should sound as close as\n       possible to TTS_CASCADE_PARALLEL.\n       Possible problem feeding in Holmes's amplitudes given this.\n    */\n    amp_parF1 = tts_DBtoLIN(frame->mFormant1Ampdb) * 0.4f;  /* -7.96 dB */\n    amp_parF2 = tts_DBtoLIN(frame->mFormant2Ampdb) * 0.15f; /* -16.5 dB */\n    amp_parF3 = tts_DBtoLIN(frame->mFormant3Ampdb) * 0.06f; /* -24.4 dB */\n    amp_parF4 = tts_DBtoLIN(frame->mFormant4Ampdb) * 0.04f; /* -28.0 dB */\n    amp_parF5 = tts_DBtoLIN(frame->mFormant5Ampdb) * 0.022f;    /* -33.2 dB */\n    amp_parF6 = tts_DBtoLIN(frame->mFormant6Ampdb) * 0.03f; /* -30.5 dB */\n    amp_parFN = tts_DBtoLIN(frame->mParallelNasalPoleAmpdb) * 0.6f; /* -4.44 dB */\n    klatt->mAmpBypas = tts_DBtoLIN(frame->mBypassFricationAmpdb) * 0.05f;  /* -26.0 db */\n\n    // Set coeficients of nasal resonator and zero antiresonator \n    tts_resonator_initResonator( &klatt->mNasalPole, frame->mNasalPoleFreq, frame->mNasalPoleBandwidth, klatt->mSampleRate);\n\n    tts_resonator_initAntiresonator( &klatt->mNasalZero, frame->mNasalZeroFreq, frame->mNasalZeroBandwidth, klatt->mSampleRate);\n\n    // Set coefficients of parallel resonators, and amplitude of outputs \n    tts_resonator_initResonator( &klatt->mParallelFormant1, frame->mFormant1Freq, frame->mFormant1ParallelBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelFormant1, amp_parF1);\n\n    tts_resonator_initResonator( &klatt->mParallelResoNasalPole, frame->mNasalPoleFreq, frame->mNasalPoleBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelResoNasalPole, amp_parFN);\n\n    tts_resonator_initResonator( &klatt->mParallelFormant2, frame->mFormant2Freq, frame->mFormant2ParallelBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelFormant2, amp_parF2);\n\n    tts_resonator_initResonator( &klatt->mParallelFormant3, frame->mFormant3Freq, frame->mFormant3ParallelBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelFormant3, amp_parF3);\n\n    tts_resonator_initResonator( &klatt->mParallelFormant4, frame->mFormant4Freq, frame->mFormant4ParallelBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelFormant4, amp_parF4);\n\n    tts_resonator_initResonator( &klatt->mParallelFormant5, frame->mFormant5Freq, frame->mFormant5ParallelBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelFormant5, amp_parF5);\n\n    tts_resonator_initResonator( &klatt->mParallelFormant6, frame->mFormant6Freq, frame->mFormant6ParallelBandwidth, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mParallelFormant6, amp_parF6);\n\n\n    /* fold overall gain into output resonator */\n    mOverallGaindb = frame->mOverallGaindb - 3;\n\n    if (mOverallGaindb <= 0)\n        mOverallGaindb = 57;\n\n    /* output TTS_ELM_FEATURE_LOW-pass filter - resonator with freq 0 and BW = globals->mSampleRate\n    Thus 3db point is globals->mSampleRate/2 i.e. Nyquist limit.\n    Only 3db down seems rather mild...\n    */\n    tts_resonator_initResonator( &klatt->mOutputLowPassFilter, 0L, (int) klatt->mSampleRate, klatt->mSampleRate);\n    tts_resonator_setGain( &klatt->mOutputLowPassFilter, tts_DBtoLIN(mOverallGaindb));\n}\n\n/*\nfunction PARWAV\n\nCONVERT FRAME OF PARAMETER DATA TO A WAVEFORM CHUNK\nSynthesize globals->mNspFr samples of waveform and store in jwave[].\n*/\n\nstatic void tts_klatt_parwave(struct tts_klatt_t* klatt, struct tts_klatt_frame_t* frame, short int *jwave) {\n    /* Output of cascade branch, also final output  */\n\n    /* Initialize synthesizer and get specification for current speech\n    frame from host microcomputer */\n\n    tts_klatt_frame_setup( klatt, frame );\n\n    if( klatt->mF0Flutter != 0 ) {\n        klatt->mTimeCount++;                  /* used for f0 flutter */\n        tts_klatt_flutter( klatt, frame );       /* add f0 flutter */\n    }\n\n    /* MAIN LOOP, for each output sample of current frame: */\n\n    int ns;\n    for( ns = 0; ns < klatt->mNspFr; ns++ ) {\n        // TODO: get rid of static var\n        static unsigned int seed = 5; /* Fixed staring value */\n        float noise;\n        int n4;\n        float sourc;                   /* Sound source if all-parallel config used  */\n        float glotout;                 /* Output of glottal sound source  */\n        float par_glotout;             /* Output of parallelglottal sound sourc  */\n        float voice = 0;               /* Current sample of voicing waveform  */\n        float frics;                   /* Frication sound source  */\n        float aspiration;              /* Aspiration sound source  */\n        int nrand;                    /* Varible used by random number generator  */\n\n        /* Our own code like rand(), but portable\n        whole upper 31 bits of seed random\n        assumes 32-bit unsigned arithmetic\n        with untested code to handle larger.\n        */\n        seed = ( seed * 1664525 + 1 ) & 0xFFFFFFFF;\n        \n        /* Shift top bits of seed up to top of int then back down to LS 14 bits */\n        /* Assumes 8 bits per sizeof unit i.e. a \"byte\" */\n        nrand = (((int) seed) << (8 * sizeof(int) - 32)) >> (8 * sizeof(int) - 14);\n\n        /* Tilt down noise spectrum by soft TTS_ELM_FEATURE_LOW-pass filter having\n        *    a pole near the origin in the z-plane, i.e.\n        *    output = input + (0.75 * lastoutput) */\n\n        noise = nrand + (0.75f * klatt->mNLast);   /* Function of samp_rate ? */\n\n        klatt->mNLast = noise;\n\n        /* Amplitude modulate noise (reduce noise amplitude during\n        second half of glottal period) if voicing simultaneously present\n        */\n\n        if( klatt->mNPer > klatt->mNMod ) {\n            noise *= 0.5f;\n        }\n\n        /* Compute frication noise */\n        sourc = frics = klatt->mAmpFrica * noise;\n\n        /* Compute voicing waveform : (run glottal source simulation at\n        4 times normal sample rate to minimize quantization noise in\n        period of female voice)\n        */\n\n        for( n4 = 0; n4 < 4; n4++ ) {\n            /* use a more-natural-shaped source waveform with excitation\n            occurring both upon opening and upon closure, stronest at closure */\n            voice = tts_klatt_natural_source(klatt, klatt->mNPer);\n\n            /* Reset period when counter 'mNPer' reaches mT0 */\n\n            if( klatt->mNPer >= klatt->mT0 ) {\n                klatt->mNPer = 0;\n                tts_klatt_pitch_synch_par_reset( klatt, frame, ns );\n            }\n\n            /* Low-pass filter voicing waveform before downsampling from 4*globals->mSampleRate */\n            /* to globals->mSampleRate samples/sec.  Resonator f=.09*globals->mSampleRate, bw=.06*globals->mSampleRate  */\n\n            voice = tts_resonator_resonate( &klatt->mDownSampLowPassFilter, voice); /* in=voice, out=voice */\n\n            /* Increment counter that keeps track of 4*globals->mSampleRate samples/sec */\n            klatt->mNPer++;\n        }\n\n        /* Tilt spectrum of voicing source down by soft TTS_ELM_FEATURE_LOW-pass filtering, amount\n        of tilt determined by mVoicingSpectralTiltdb\n        */\n        voice = (voice * klatt->mOneMd) + (klatt->mVLast * klatt->mDecay);\n\n        klatt->mVLast = voice;\n\n        /* Add breathiness during glottal open phase */\n        if( klatt->mNPer < klatt->mNOpen ) {\n            /* Amount of breathiness determined by parameter mVoicingBreathiness */\n            /* Use nrand rather than noise because noise is TTS_ELM_FEATURE_LOW-passed */\n            voice += klatt->mAmpBreth * nrand;\n        }\n\n        /* Set amplitude of voicing */\n        glotout = klatt->mAmpVoice * voice;\n\n        /* Compute aspiration amplitude and add to voicing source */\n        aspiration = klatt->mAmpAspir * noise;\n\n        glotout += aspiration;\n\n        par_glotout = glotout;\n\n        /* NIS - rsynth \"hack\"\n        As Holmes' scheme is weak at nasals and (physically) nasal cavity\n        is \"back near glottis\" feed glottal source through nasal resonators\n        Don't think this is quite right, but improves things a bit\n        */\n        par_glotout = tts_resonator_antiresonate( &klatt->mNasalZero, par_glotout);\n        par_glotout = tts_resonator_resonate( &klatt->mNasalPole, par_glotout);\n        /* And just use mParallelFormant1 NOT mParallelResoNasalPole */     \n        float out = tts_resonator_resonate( &klatt->mParallelFormant1, par_glotout);\n        /* Sound sourc for other parallel resonators is frication\n        plus first difference of voicing waveform.\n        */\n        sourc += (par_glotout - klatt->mGlotLast);\n        klatt->mGlotLast = par_glotout;\n\n        /* Standard parallel vocal tract\n        Formants F6,F5,F4,F3,F2, outputs added with alternating sign\n        */\n        out = tts_resonator_resonate( &klatt->mParallelFormant6, sourc) - out;\n        out = tts_resonator_resonate( &klatt->mParallelFormant5, sourc) - out;\n        out = tts_resonator_resonate( &klatt->mParallelFormant4, sourc) - out;\n        out = tts_resonator_resonate( &klatt->mParallelFormant3, sourc) - out;\n        out = tts_resonator_resonate( &klatt->mParallelFormant2, sourc) - out;\n        out = klatt->mAmpBypas * sourc - out;\n        out = tts_resonator_resonate( &klatt->mOutputLowPassFilter, out);\n\n        *jwave++ = tts_clip(out); /* Convert back to integer */\n    }\n}\n\n\n\nstatic char * tts_phoneme_to_element_lookup( char *s, void ** data ) {\n    int key8 = *s;\n    int key16 = key8 + (s[1] << 8);\n    if (s[1] == 0) key16 = -1; // avoid key8==key16\n    int i;\n    for (i = 0; i < TTS_PHONEME_COUNT; i++) {\n        if (tts_phoneme_to_elements[i].mKey == key16) {\n            *data = &tts_phoneme_to_elements[i].mData;\n            return s+2;\n        }\n        if (tts_phoneme_to_elements[i].mKey == key8) {\n            *data = &tts_phoneme_to_elements[i].mData;\n            return s+1;\n        }\n    }\n    // should never happen\n    *data = NULL;\n    return s+1;\n}\n\n\n\nstatic int tts_phone_to_elm( char *aPhoneme, int aCount, struct tts_darray_t *aElement ) {\n    int stress = 0;\n    char *s = aPhoneme;\n    int t = 0;\n    char *limit = s + aCount;\n\n    while (s < limit && *s) {\n        char *e = NULL;\n        s = tts_phoneme_to_element_lookup(s, (void**)&e);\n\n        if (e) {\n            int n = *e++;\n\n            while (n-- > 0) {\n                int x = *e++;\n                struct tts_element_t * p = &tts_gElement[x];\n                /* This works because only vowels have mUD != mDU,\n                and we set stress just before a vowel\n                */\n                tts_darray_put( aElement, x );\n\n                if (!(p->mFeat & TTS_ELM_FEATURE_VWL))\n                    stress = 0;\n\n                int stressdur = TTS_StressDur(p);\n\n                t += stressdur;\n\n                tts_darray_put( aElement, stressdur);\n                tts_darray_put( aElement, stress);\n            }\n        } else {\n            char ch = *s++;\n\n            switch (ch) {\n                case '\\'':                /* Primary stress */\n                    stress = 3;\n                    break;\n                case ',':                 /* Secondary stress */\n                    stress = 2;\n                    break;\n                case '+':                 /* Tertiary stress */\n                    stress = 1;\n                    break;\n                case '-':                 /* hyphen in input */\n                    break;\n                default:\n//                  fprintf(stderr, \"Ignoring %c in '%.*s'\\n\", ch, aCount, aPhoneme);\n                    break;\n            }\n        }\n    }\n\n    return t;\n}\n\n\n\n/* 'a' is dominant element, 'b' is dominated\n    ext is flag to say to use external times from 'a' rather\n    than internal i.e. ext != 0 if 'a' is NOT current element.\n */\n\nstatic void tts_set_trans( struct tts_slope_t* t, struct tts_element_t* a, struct tts_element_t* b, int ext, int e ) {\n    (void) e;\n    int i;\n\n    for (i = 0; i < TTS_ELM_COUNT; i++) {\n        t[i].mTime = ((ext) ? a->mInterpolator[i].mExtDelay : a->mInterpolator[i].mIntDelay);\n\n        if (t[i].mTime) {\n            t[i].mValue = a->mInterpolator[i].mFixed + (a->mInterpolator[i].mProportion * b->mInterpolator[i].mSteady) * 0.01f; // mProportion is in scale 0..100, so *0.01.\n        } else {\n            t[i].mValue = b->mInterpolator[i].mSteady;\n        }\n    }\n}\n\n\nstatic float tts_lerp( float a, float b, int t, int d ) {\n    if (t <= 0) {\n        return a;\n    }\n\n    if (t >= d) {\n        return b;\n    }\n\n    float f = (float)t / (float)d;\n    return a + (b - a) * f;\n}\n\n\nstatic float tts_interpolate( struct tts_slope_t* aStartSlope, struct tts_slope_t* aEndSlope, float aMidValue, int aTime, int aDuration )\n{\n    int steadyTime = aDuration - (aStartSlope->mTime + aEndSlope->mTime);\n\n    if( steadyTime >= 0 ) {\n        // Interpolate to a midpoint, stay there for a while, then tts_interpolate to end\n\n        if( aTime < aStartSlope->mTime ) {\n            // tts_interpolate to the first value\n            return tts_lerp(aStartSlope->mValue, aMidValue, aTime, aStartSlope->mTime);\n        }\n        // reached midpoint\n\n        aTime -= aStartSlope->mTime;\n\n        if( aTime <= steadyTime ) {\n            // still at steady state\n            return aMidValue;  \n        }\n\n        // tts_interpolate to the end\n        return tts_lerp(aMidValue, aEndSlope->mValue, aTime - steadyTime, aEndSlope->mTime);\n    } else {\n        // No steady state\n        float f = 1.0f - ((float) aTime / (float) aDuration);\n        float sp = tts_lerp(aStartSlope->mValue, aMidValue, aTime, aStartSlope->mTime);\n        float ep = tts_lerp(aEndSlope->mValue, aMidValue, aDuration - aTime, aEndSlope->mTime);\n        return f * sp + ((float) 1.0 - f) * ep;\n    }\n}\n\n\n\nstatic void tts_klatt_initsynth( struct tts_klatt_t* klatt, int aElementCount,unsigned char *aElement ) {\n    klatt->mElement = aElement;\n    klatt->mElementCount = aElementCount;\n    klatt->mElementIndex = 0;\n    klatt->mLastElement = &tts_gElement[0];\n    klatt->mTStress = 0;\n    klatt->mNTStress = 0;\n    klatt->mKlattFramePars.mF0FundamentalFreq = 1330;\n    klatt->mTop = 1.1f * klatt->mKlattFramePars.mF0FundamentalFreq;\n    klatt->mKlattFramePars.mNasalPoleFreq = (int)klatt->mLastElement->mInterpolator[TTS_ELM_FN].mSteady;\n    klatt->mKlattFramePars.mFormant1ParallelBandwidth = klatt->mKlattFramePars.mFormant1Bandwidth = 60;\n    klatt->mKlattFramePars.mFormant2ParallelBandwidth = klatt->mKlattFramePars.mFormant2Bandwidth = 90;\n    klatt->mKlattFramePars.mFormant3ParallelBandwidth = klatt->mKlattFramePars.mFormant3Bandwidth = 150;\n//  klatt->mKlattFramePars.mFormant4ParallelBandwidth = (default)\n\n    // Set stress attack/decay slope \n    klatt->mStressS.mTime = 40;\n    klatt->mStressE.mTime = 40;\n    klatt->mStressE.mValue = 0.0;\n}\n\n\nint tts_klatt_synth( struct tts_klatt_t* klatt, int aSampleCount, short *aSamplePointer) {\n    (void) aSampleCount;\n\n    short *samp = aSamplePointer;\n\n    if( klatt->mElementIndex >= klatt->mElementCount )\n        return -1;\n\n    struct tts_element_t * currentElement = &tts_gElement[klatt->mElement[klatt->mElementIndex++]];\n    int dur = klatt->mElement[klatt->mElementIndex++];\n    klatt->mElementIndex++; // skip stress \n\n    // Skip zero length elements which are only there to affect\n    // boundary values of adjacent elements     \n\n    if (dur > 0) {\n        struct tts_element_t* ne = (klatt->mElementIndex < klatt->mElementCount) ? &tts_gElement[klatt->mElement[klatt->mElementIndex]] : &tts_gElement[0];\n        struct tts_slope_t start[TTS_ELM_COUNT];\n        struct tts_slope_t end[TTS_ELM_COUNT];\n        int t;\n\n        if (currentElement->mRK > klatt->mLastElement->mRK) {\n            tts_set_trans(start, currentElement, klatt->mLastElement, 0, 's');\n            // we dominate last \n        } else {\n            tts_set_trans(start, klatt->mLastElement, currentElement, 1, 's');\n            // last dominates us \n        }\n\n        if (ne->mRK > currentElement->mRK) {\n            tts_set_trans(end, ne, currentElement, 1, 'e');\n            // next dominates us \n        } else {\n            tts_set_trans(end, currentElement, ne, 0, 'e');\n            // we dominate next \n        }\n\n        for (t = 0; t < dur; t++, klatt->mTStress++) {\n            float base = klatt->mTop * 0.8f; // 3 * top / 5 \n            float tp[TTS_ELM_COUNT];\n\n            if (klatt->mTStress == klatt->mNTStress) {\n                int j = klatt->mElementIndex;\n                klatt->mStressS = klatt->mStressE;\n                klatt->mTStress = 0;\n                klatt->mNTStress = dur;\n\n                while (j <= klatt->mElementCount) {\n                    struct tts_element_t* e = (j < klatt->mElementCount) ? &tts_gElement[klatt->mElement[j++]] : &tts_gElement[0];\n                    int du = (j < klatt->mElementCount) ? klatt->mElement[j++] : 0;\n                    int s  = (j < klatt->mElementCount) ? klatt->mElement[j++] : 3;\n\n                    if (s || e->mFeat & TTS_ELM_FEATURE_VWL) {\n                        int d = 0;\n\n                        if (s)\n                            klatt->mStressE.mValue = (float) s / 3;\n                        else\n                            klatt->mStressE.mValue = (float) 0.1;\n\n                        do {\n                            d += du;\n                            e = (j < klatt->mElementCount) ? &tts_gElement[klatt->mElement[j++]] : &tts_gElement[0];\n                            du = klatt->mElement[j++];\n                        } while ((e->mFeat & TTS_ELM_FEATURE_VWL) && klatt->mElement[j++] == s);\n\n                        klatt->mNTStress += d / 2;\n\n                        break;\n                    }\n\n                    klatt->mNTStress += du;\n                }\n            }\n\n            for (int j = 0; j < TTS_ELM_COUNT; j++) {\n                tp[j] = tts_interpolate(&start[j], &end[j], (float) currentElement->mInterpolator[j].mSteady, t, dur);\n            }\n\n            // Now call the synth for each frame \n\n            klatt->mKlattFramePars.mF0FundamentalFreq = (int)(base + (klatt->mTop - base) * tts_interpolate(&klatt->mStressS, &klatt->mStressE, (float) 0, klatt->mTStress, klatt->mNTStress));\n            klatt->mKlattFramePars.mVoicingAmpdb = klatt->mKlattFramePars.mPalallelVoicingAmpdb = (int)tp[TTS_ELM_AV];\n            klatt->mKlattFramePars.mFricationAmpdb = (int)tp[TTS_ELM_AF];\n            klatt->mKlattFramePars.mNasalZeroFreq = (int)tp[TTS_ELM_FN];\n            klatt->mKlattFramePars.mAspirationAmpdb = (int)tp[TTS_ELM_ASP];\n            klatt->mKlattFramePars.mVoicingBreathiness = (int)tp[TTS_ELM_AVC];\n            klatt->mKlattFramePars.mFormant1ParallelBandwidth = klatt->mKlattFramePars.mFormant1Bandwidth = (int)tp[TTS_ELM_B1];\n            klatt->mKlattFramePars.mFormant2ParallelBandwidth = klatt->mKlattFramePars.mFormant2Bandwidth = (int)tp[TTS_ELM_B2];\n            klatt->mKlattFramePars.mFormant3ParallelBandwidth = klatt->mKlattFramePars.mFormant3Bandwidth = (int)tp[TTS_ELM_B3];\n            klatt->mKlattFramePars.mFormant1Freq = (int)tp[TTS_ELM_F1];\n            klatt->mKlattFramePars.mFormant2Freq = (int)tp[TTS_ELM_F2];\n            klatt->mKlattFramePars.mFormant3Freq = (int)tp[TTS_ELM_F3];\n\n            // TTS_AMP_ADJ + is a kludge to get amplitudes up to klatt-compatible levels\n                \n                \n            //pars.mParallelNasalPoleAmpdb  = TTS_AMP_ADJ + tp[TTS_ELM_AN];\n                \n            klatt->mKlattFramePars.mBypassFricationAmpdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_AB];\n            klatt->mKlattFramePars.mFormant5Ampdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_A5];\n            klatt->mKlattFramePars.mFormant6Ampdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_A6];\n            klatt->mKlattFramePars.mFormant1Ampdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_A1];\n            klatt->mKlattFramePars.mFormant2Ampdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_A2];\n            klatt->mKlattFramePars.mFormant3Ampdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_A3];\n            klatt->mKlattFramePars.mFormant4Ampdb = TTS_AMP_ADJ + (int)tp[TTS_ELM_A4];\n\n            tts_klatt_parwave( klatt, &klatt->mKlattFramePars, samp);\n\n            samp += klatt->mNspFr;\n\n            // Declination of f0 envelope 0.25Hz / cS \n            klatt->mTop -= 0.5;\n        }\n    }\n\n    klatt->mLastElement = currentElement;\n\n    /* MG: BEGIN REINIT AT LONG PAUSE */\n    if( currentElement->mName[0] == 'Q' && currentElement->mName[1] == '\\0' ) {\n        ++klatt->count; \n    } else {\n        klatt->count = 0;\n    }\n    if( klatt->count == 3 ) {\n        klatt->mTStress = 0;\n        klatt->mNTStress = 0;\n        klatt->mKlattFramePars.mF0FundamentalFreq = 1330;\n        klatt->mTop = 1.1f * klatt->mKlattFramePars.mF0FundamentalFreq;\n        klatt->mKlattFramePars.mNasalPoleFreq = (int)klatt->mLastElement->mInterpolator[TTS_ELM_FN].mSteady;\n        klatt->mKlattFramePars.mFormant1ParallelBandwidth = klatt->mKlattFramePars.mFormant1Bandwidth = 60;\n        klatt->mKlattFramePars.mFormant2ParallelBandwidth = klatt->mKlattFramePars.mFormant2Bandwidth = 90;\n        klatt->mKlattFramePars.mFormant3ParallelBandwidth = klatt->mKlattFramePars.mFormant3Bandwidth = 150;\n    //  mKlattFramePars.mFormant4ParallelBandwidth = (default)\n\n        // Set stress attack/decay slope \n        klatt->mStressS.mTime = 40;\n        klatt->mStressE.mTime = 40;\n        klatt->mStressE.mValue = 0.0;\n    }\n    /* MG: END REINIT AT LONG PAUSE */\n\n    return (int)(samp - aSamplePointer);\n}\n\n\nstatic void tts_klatt_init( struct tts_klatt_t* klatt ) {\n    memset( klatt, 0, sizeof( *klatt ) );\n    tts_klatt_frame_init( &klatt->mKlattFramePars );\n    klatt->mSampleRate = 11025;\n    klatt->mF0Flutter = 0;\n\n    int FLPhz = (950 * klatt->mSampleRate) / 10000;\n    int BLPhz = (630 * klatt->mSampleRate) / 10000;\n    klatt->mNspFr = (int)(klatt->mSampleRate * 10) / 1000;\n\n    tts_resonator_initResonator( &klatt->mDownSampLowPassFilter, FLPhz, BLPhz, klatt->mSampleRate );\n\n    klatt->mNPer = 0;                        /* LG */\n    klatt->mT0 = 0;                          /* LG */\n\n    klatt->mVLast = 0;                       /* Previous output of voice  */\n    klatt->mNLast = 0;                       /* Previous output of random number generator  */\n    klatt->mGlotLast = 0;                    /* Previous value of glotout  */\n    klatt->count = 0;\n}\n\n\n\nstatic const char *tts_ASCII[] = {\n    \"null\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"\", \"\", \"\", \"\",\n    \"space\", \"exclamation mark\", \"double quote\", \"hash\",\n    \"dollar\", \"percent\", \"ampersand\", \"quote\",\n    \"open parenthesis\", \"close parenthesis\", \"asterisk\", \"plus\",\n    \"comma\", \"minus\", \"full stop\", \"slash\",\n    \"zero\", \"one\", \"two\", \"three\",\n    \"four\", \"five\", \"six\", \"seven\",\n    \"eight\", \"nine\", \"colon\", \"semi colon\",\n    \"less than\", \"equals\", \"greater than\", \"question mark\",\n#ifndef TTS_ALPHA_IN_DICT\n    \"at\", \"ay\", \"bee\", \"see\",\n    \"dee\", \"e\", \"eff\", \"gee\",\n    \"aych\", \"i\", \"jay\", \"kay\",\n    \"ell\", \"em\", \"en\", \"ohe\",\n    \"pee\", \"kju\", \"are\", \"es\",\n    \"tee\", \"you\", \"vee\", \"double you\",\n    \"eks\", \"why\", \"zed\", \"open bracket\",\n#else                             /* TTS_ALPHA_IN_DICT */\n    \"at\", \"A\", \"B\", \"C\",\n    \"D\", \"E\", \"F\", \"G\",\n    \"H\", \"I\", \"J\", \"K\",\n    \"L\", \"M\", \"N\", \"O\",\n    \"P\", \"Q\", \"R\", \"S\",\n    \"T\", \"U\", \"V\", \"W\",\n    \"X\", \"Y\", \"Z\", \"open bracket\",\n#endif                            /* TTS_ALPHA_IN_DICT */\n    \"back slash\", \"close bracket\", \"circumflex\", \"underscore\",\n#ifndef TTS_ALPHA_IN_DICT\n    \"back quote\", \"ay\", \"bee\", \"see\",\n    \"dee\", \"e\", \"eff\", \"gee\",\n    \"aych\", \"i\", \"jay\", \"kay\",\n    \"ell\", \"em\", \"en\", \"ohe\",\n    \"pee\", \"kju\", \"are\", \"es\",\n    \"tee\", \"you\", \"vee\", \"double you\",\n    \"eks\", \"why\", \"zed\", \"open brace\",\n#else                             /* TTS_ALPHA_IN_DICT */\n    \"back quote\", \"A\", \"B\", \"C\",\n    \"D\", \"E\", \"F\", \"G\",\n    \"H\", \"I\", \"J\", \"K\",\n    \"L\", \"M\", \"N\", \"O\",\n    \"P\", \"Q\", \"R\", \"S\",\n    \"T\", \"U\", \"V\", \"W\",\n    \"X\", \"Y\", \"Z\", \"open brace\",\n#endif                            /* TTS_ALPHA_IN_DICT */\n    \"vertical bar\", \"close brace\", \"tilde\", \"delete\",\n    NULL\n};\n\n/* Context definitions */\nstatic const char tts_Anything[] = \"\";\n/* No context requirement */\n\nstatic const char tts_Nothing[] = \" \";\n/* Context is beginning or end of word */\n\nstatic const char tts_Silent[] = \"\";\n/* No phonemes */\n\n\n#define TTS_LEFT_PART       0\n#define TTS_MATCH_PART      1\n#define TTS_RIGHT_PART      2\n#define TTS_OUT_PART        3\n\ntypedef const char *tts_Rule[4];\n/* tts_Rule is an array of 4 character pointers */\n\n\n/*0 = Punctuation */\n/*\n**      TTS_LEFT_PART       TTS_MATCH_PART      TTS_RIGHT_PART      TTS_OUT_PART\n*/\n\n\nstatic tts_Rule tts_punct_rules[] = {\n    {tts_Anything, \" \", tts_Anything, \" \"},\n    {tts_Anything, \"-\", tts_Anything, \"\"},\n    {\".\", \"'S\", tts_Anything, \"z\"},\n    {\"#:.E\", \"'S\", tts_Anything, \"z\"},\n    {\"#\", \"'S\", tts_Anything, \"z\"},\n    {tts_Anything, \"'\", tts_Anything, \"\"},\n    {tts_Anything, \",\", tts_Anything, \" \"},\n    {tts_Anything, \".\", tts_Anything, \" \"},\n    {tts_Anything, \"?\", tts_Anything, \" \"},\n    {tts_Anything, \"!\", tts_Anything, \" \"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_A_rules[] = {\n    {tts_Anything, \"A\", tts_Nothing, \"@\"},\n    {tts_Nothing, \"ARE\", tts_Nothing, \"0r\"},\n    {tts_Nothing, \"AR\", \"O\", \"@r\"},\n    {tts_Anything, \"AR\", \"#\", \"er\"},\n    {\"^\", \"AS\", \"#\", \"eIs\"},\n    {tts_Anything, \"A\", \"WA\", \"@\"},\n    {tts_Anything, \"AW\", tts_Anything, \"O\"},\n    {\" :\", \"ANY\", tts_Anything, \"eni\"},\n    {tts_Anything, \"A\", \"^+#\", \"eI\"},\n    {\"#:\", \"ALLY\", tts_Anything, \"@li\"},\n    {tts_Nothing, \"AL\", \"#\", \"@l\"},\n    {tts_Anything, \"AGAIN\", tts_Anything, \"@gen\"},\n    {\"#:\", \"AG\", \"E\", \"IdZ\"},\n    {tts_Anything, \"A\", \"^+:#\", \"&\"},\n    {\" :\", \"A\", \"^+ \", \"eI\"},\n    {tts_Anything, \"A\", \"^%\", \"eI\"},\n    {tts_Nothing, \"ARR\", tts_Anything, \"@r\"},\n    {tts_Anything, \"ARR\", tts_Anything, \"&r\"},\n    {\" :\", \"AR\", tts_Nothing, \"0r\"},\n    {tts_Anything, \"AR\", tts_Nothing, \"3\"},\n    {tts_Anything, \"AR\", tts_Anything, \"0r\"},\n    {tts_Anything, \"AIR\", tts_Anything, \"er\"},\n    {tts_Anything, \"AI\", tts_Anything, \"eI\"},\n    {tts_Anything, \"AY\", tts_Anything, \"eI\"},\n    {tts_Anything, \"AU\", tts_Anything, \"O\"},\n    {\"#:\", \"AL\", tts_Nothing, \"@l\"},\n    {\"#:\", \"ALS\", tts_Nothing, \"@lz\"},\n    {tts_Anything, \"ALK\", tts_Anything, \"Ok\"},\n    {tts_Anything, \"AL\", \"^\", \"Ol\"},\n    {\" :\", \"ABLE\", tts_Anything, \"eIb@l\"},\n    {tts_Anything, \"ABLE\", tts_Anything, \"@b@l\"},\n    {tts_Anything, \"ANG\", \"+\", \"eIndZ\"},\n    {\"^\", \"A\", \"^#\", \"eI\"},\n    {tts_Anything, \"A\", tts_Anything, \"&\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_B_rules[] = {\n    {tts_Nothing, \"BE\", \"^#\", \"bI\"},\n    {tts_Anything, \"BEING\", tts_Anything, \"biIN\"},\n    {tts_Nothing, \"BOTH\", tts_Nothing, \"b@UT\"},\n    {tts_Nothing, \"BUS\", \"#\", \"bIz\"},\n    {tts_Anything, \"BUIL\", tts_Anything, \"bIl\"},\n    {tts_Anything, \"B\", tts_Anything, \"b\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_C_rules[] = {\n    {tts_Nothing, \"CH\", \"^\", \"k\"},\n    {\"^E\", \"CH\", tts_Anything, \"k\"},\n    {tts_Anything, \"CH\", tts_Anything, \"tS\"},\n    {\" S\", \"CI\", \"#\", \"saI\"},\n    {tts_Anything, \"CI\", \"A\", \"S\"},\n    {tts_Anything, \"CI\", \"O\", \"S\"},\n    {tts_Anything, \"CI\", \"EN\", \"S\"},\n    {tts_Anything, \"C\", \"+\", \"s\"},\n    {tts_Anything, \"CK\", tts_Anything, \"k\"},\n    {tts_Anything, \"COM\", \"%\", \"kVm\"},\n    {tts_Anything, \"C\", tts_Anything, \"k\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_D_rules[] = {\n    {\"#:\", \"DED\", tts_Nothing, \"dId\"},\n    {\".E\", \"D\", tts_Nothing, \"d\"},\n    {\"#:^E\", \"D\", tts_Nothing, \"t\"},\n    {tts_Nothing, \"DE\", \"^#\", \"dI\"},\n    {tts_Nothing, \"DO\", tts_Nothing, \"mDU\"},\n    {tts_Nothing, \"DOES\", tts_Anything, \"dVz\"},\n    {tts_Nothing, \"DOING\", tts_Anything, \"duIN\"},\n    {tts_Nothing, \"DOW\", tts_Anything, \"daU\"},\n    {tts_Anything, \"DU\", \"A\", \"dZu\"},\n    {tts_Anything, \"D\", tts_Anything, \"d\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_E_rules[] = {\n    {\"#:\", \"E\", tts_Nothing, \"\"},\n    {\"':^\", \"E\", tts_Nothing, \"\"},\n    {\" :\", \"E\", tts_Nothing, \"i\"},\n    {\"#\", \"ED\", tts_Nothing, \"d\"},\n    {\"#:\", \"E\", \"D \", \"\"},\n    {tts_Anything, \"EV\", \"ER\", \"ev\"},\n    {tts_Anything, \"E\", \"^%\", \"i\"},\n    {tts_Anything, \"ERI\", \"#\", \"iri\"},\n    {tts_Anything, \"ERI\", tts_Anything, \"erI\"},\n    {\"#:\", \"ER\", \"#\", \"3\"},\n    {tts_Anything, \"ER\", \"#\", \"er\"},\n    {tts_Anything, \"ER\", tts_Anything, \"3\"},\n    {tts_Nothing, \"EVEN\", tts_Anything, \"iven\"},\n    {\"#:\", \"E\", \"W\", \"\"},\n    {\"T\", \"EW\", tts_Anything, \"u\"},\n    {\"S\", \"EW\", tts_Anything, \"u\"},\n    {\"R\", \"EW\", tts_Anything, \"u\"},\n    {\"D\", \"EW\", tts_Anything, \"u\"},\n    {\"L\", \"EW\", tts_Anything, \"u\"},\n    {\"Z\", \"EW\", tts_Anything, \"u\"},\n    {\"N\", \"EW\", tts_Anything, \"u\"},\n    {\"J\", \"EW\", tts_Anything, \"u\"},\n    {\"TH\", \"EW\", tts_Anything, \"u\"},\n    {\"CH\", \"EW\", tts_Anything, \"u\"},\n    {\"SH\", \"EW\", tts_Anything, \"u\"},\n    {tts_Anything, \"EW\", tts_Anything, \"ju\"},\n    {tts_Anything, \"E\", \"O\", \"i\"},\n    {\"#:S\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:C\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:G\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:Z\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:X\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:J\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:CH\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:SH\", \"ES\", tts_Nothing, \"Iz\"},\n    {\"#:\", \"E\", \"S \", \"\"},\n    {\"#:\", \"ELY\", tts_Nothing, \"li\"},\n    {\"#:\", \"EMENT\", tts_Anything, \"ment\"},\n    {tts_Anything, \"EFUL\", tts_Anything, \"fUl\"},\n    {tts_Anything, \"EE\", tts_Anything, \"i\"},\n    {tts_Anything, \"EARN\", tts_Anything, \"3n\"},\n    {tts_Nothing, \"EAR\", \"^\", \"3\"},\n    {tts_Anything, \"EAD\", tts_Anything, \"ed\"},\n    {\"#:\", \"EA\", tts_Nothing, \"i@\"},\n    {tts_Anything, \"EA\", \"SU\", \"e\"},\n    {tts_Anything, \"EA\", tts_Anything, \"i\"},\n    {tts_Anything, \"EIGH\", tts_Anything, \"eI\"},\n    {tts_Anything, \"EI\", tts_Anything, \"i\"},\n    {tts_Nothing, \"EYE\", tts_Anything, \"aI\"},\n    {tts_Anything, \"EY\", tts_Anything, \"i\"},\n    {tts_Anything, \"EU\", tts_Anything, \"ju\"},\n    {tts_Anything, \"E\", tts_Anything, \"e\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_F_rules[] = {\n    {tts_Anything, \"FUL\", tts_Anything, \"fUl\"},\n    {tts_Anything, \"F\", tts_Anything, \"f\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_G_rules[] = {\n    {tts_Anything, \"GIV\", tts_Anything, \"gIv\"},\n    {tts_Nothing, \"G\", \"I^\", \"g\"},\n    {tts_Anything, \"GE\", \"T\", \"ge\"},\n    {\"SU\", \"GGES\", tts_Anything, \"gdZes\"},\n    {tts_Anything, \"GG\", tts_Anything, \"g\"},\n    {\" B#\", \"G\", tts_Anything, \"g\"},\n    {tts_Anything, \"G\", \"+\", \"dZ\"},\n    {tts_Anything, \"GREAT\", tts_Anything, \"greIt\"},\n    {\"#\", \"GH\", tts_Anything, \"\"},\n    {tts_Anything, \"G\", tts_Anything, \"g\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_H_rules[] = {\n    {tts_Nothing, \"HAV\", tts_Anything, \"h&v\"},\n    {tts_Nothing, \"HERE\", tts_Anything, \"hir\"},\n    {tts_Nothing, \"HOUR\", tts_Anything, \"aU3\"},\n    {tts_Anything, \"HOW\", tts_Anything, \"haU\"},\n    {tts_Anything, \"H\", \"#\", \"h\"},\n    {tts_Anything, \"H\", tts_Anything, \"\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_I_rules[] = {\n    {tts_Nothing, \"IAIN\", tts_Nothing, \"I@n\"},\n    {tts_Nothing, \"ING\", tts_Nothing, \"IN\"},\n    {tts_Nothing, \"IN\", tts_Anything, \"In\"},\n    {tts_Nothing, \"I\", tts_Nothing, \"aI\"},\n    {tts_Anything, \"IN\", \"D\", \"aIn\"},\n    {tts_Anything, \"IER\", tts_Anything, \"i3\"},\n    {\"#:R\", \"IED\", tts_Anything, \"id\"},\n    {tts_Anything, \"IED\", tts_Nothing, \"aId\"},\n    {tts_Anything, \"IEN\", tts_Anything, \"ien\"},\n    {tts_Anything, \"IE\", \"T\", \"aIe\"},\n    {\" :\", \"I\", \"%\", \"aI\"},\n    {tts_Anything, \"I\", \"%\", \"i\"},\n    {tts_Anything, \"IE\", tts_Anything, \"i\"},\n    {tts_Anything, \"I\", \"^+:#\", \"I\"},\n    {tts_Anything, \"IR\", \"#\", \"aIr\"},\n    {tts_Anything, \"IZ\", \"%\", \"aIz\"},\n    {tts_Anything, \"IS\", \"%\", \"aIz\"},\n    {tts_Anything, \"I\", \"D%\", \"aI\"},\n    {\"+^\", \"I\", \"^+\", \"I\"},\n    {tts_Anything, \"I\", \"T%\", \"aI\"},\n    {\"#:^\", \"I\", \"^+\", \"I\"},\n    {tts_Anything, \"I\", \"^+\", \"aI\"},\n    {tts_Anything, \"IR\", tts_Anything, \"3\"},\n    {tts_Anything, \"IGH\", tts_Anything, \"aI\"},\n    {tts_Anything, \"ILD\", tts_Anything, \"aIld\"},\n    {tts_Anything, \"IGN\", tts_Nothing, \"aIn\"},\n    {tts_Anything, \"IGN\", \"^\", \"aIn\"},\n    {tts_Anything, \"IGN\", \"%\", \"aIn\"},\n    {tts_Anything, \"IQUE\", tts_Anything, \"ik\"},\n    {\"^\", \"I\", \"^#\", \"aI\"},\n    {tts_Anything, \"I\", tts_Anything, \"I\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_J_rules[] = {\n    {tts_Anything, \"J\", tts_Anything, \"dZ\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_K_rules[] = {\n    {tts_Nothing, \"K\", \"N\", \"\"},\n    {tts_Anything, \"K\", tts_Anything, \"k\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_L_rules[] = {\n    {tts_Anything, \"LO\", \"C#\", \"l@U\"},\n    {\"L\", \"L\", tts_Anything, \"\"},\n    {\"#:^\", \"L\", \"%\", \"@l\"},\n    {tts_Anything, \"LEAD\", tts_Anything, \"lid\"},\n    {tts_Anything, \"L\", tts_Anything, \"l\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_M_rules[] = {\n    {tts_Anything, \"MOV\", tts_Anything, \"muv\"},\n    {\"#\", \"MM\", \"#\", \"m\"},\n    {tts_Anything, \"M\", tts_Anything, \"m\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_N_rules[] = {\n    {\"E\", \"NG\", \"+\", \"ndZ\"},\n    {tts_Anything, \"NG\", \"R\", \"Ng\"},\n    {tts_Anything, \"NG\", \"#\", \"Ng\"},\n    {tts_Anything, \"NGL\", \"%\", \"Ng@l\"},\n    {tts_Anything, \"NG\", tts_Anything, \"N\"},\n    {tts_Anything, \"NK\", tts_Anything, \"Nk\"},\n    {tts_Nothing, \"NOW\", tts_Nothing, \"naU\"},\n    {\"#\", \"NG\", tts_Nothing, \"Ng\"},\n    {tts_Anything, \"N\", tts_Anything, \"n\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_O_rules[] = {\n    {tts_Anything, \"OF\", tts_Nothing, \"@v\"},\n    {tts_Anything, \"OROUGH\", tts_Anything, \"3@U\"},\n    {\"#:\", \"OR\", tts_Nothing, \"3\"},\n    {\"#:\", \"ORS\", tts_Nothing, \"3z\"},\n    {tts_Anything, \"OR\", tts_Anything, \"Or\"},\n    {tts_Nothing, \"ONE\", tts_Anything, \"wVn\"},\n    {tts_Anything, \"OW\", tts_Anything, \"@U\"},\n    {tts_Nothing, \"OVER\", tts_Anything, \"@Uv3\"},\n    {tts_Anything, \"OV\", tts_Anything, \"Vv\"},\n    {tts_Anything, \"O\", \"^%\", \"@U\"},\n    {tts_Anything, \"O\", \"^EN\", \"@U\"},\n    {tts_Anything, \"O\", \"^I#\", \"@U\"},\n    {tts_Anything, \"OL\", \"D\", \"@Ul\"},\n    {tts_Anything, \"OUGHT\", tts_Anything, \"Ot\"},\n    {tts_Anything, \"OUGH\", tts_Anything, \"Vf\"},\n    {tts_Nothing, \"OU\", tts_Anything, \"aU\"},\n    {\"H\", \"OU\", \"S#\", \"aU\"},\n    {tts_Anything, \"OUS\", tts_Anything, \"@s\"},\n    {tts_Anything, \"OUR\", tts_Anything, \"Or\"},\n    {tts_Anything, \"OULD\", tts_Anything, \"Ud\"},\n    {\"^\", \"OU\", \"^L\", \"V\"},\n    {tts_Anything, \"OUP\", tts_Anything, \"up\"},\n    {tts_Anything, \"OU\", tts_Anything, \"aU\"},\n    {tts_Anything, \"OY\", tts_Anything, \"oI\"},\n    {tts_Anything, \"OING\", tts_Anything, \"@UIN\"},\n    {tts_Anything, \"OI\", tts_Anything, \"oI\"},\n    {tts_Anything, \"OOR\", tts_Anything, \"Or\"},\n    {tts_Anything, \"OOK\", tts_Anything, \"Uk\"},\n    {tts_Anything, \"OOD\", tts_Anything, \"Ud\"},\n    {tts_Anything, \"OO\", tts_Anything, \"u\"},\n    {tts_Anything, \"O\", \"E\", \"@U\"},\n    {tts_Anything, \"O\", tts_Nothing, \"@U\"},\n    {tts_Anything, \"OA\", tts_Anything, \"@U\"},\n    {tts_Nothing, \"ONLY\", tts_Anything, \"@Unli\"},\n    {tts_Nothing, \"ONCE\", tts_Anything, \"wVns\"},\n    {tts_Anything, \"ON'T\", tts_Anything, \"@Unt\"},\n    {\"C\", \"O\", \"N\", \"0\"},\n    {tts_Anything, \"O\", \"NG\", \"O\"},\n    {\" :^\", \"O\", \"N\", \"V\"},\n    {\"I\", \"ON\", tts_Anything, \"@n\"},\n    {\"#:\", \"ON\", tts_Nothing, \"@n\"},\n    {\"#^\", \"ON\", tts_Anything, \"@n\"},\n    {tts_Anything, \"O\", \"ST \", \"@U\"},\n    {tts_Anything, \"OF\", \"^\", \"Of\"},\n    {tts_Anything, \"OTHER\", tts_Anything, \"VD3\"},\n    {tts_Anything, \"OSS\", tts_Nothing, \"Os\"},\n    {\"#:^\", \"OM\", tts_Anything, \"Vm\"},\n    {tts_Anything, \"O\", tts_Anything, \"0\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_P_rules[] = {\n    {tts_Anything, \"PH\", tts_Anything, \"f\"},\n    {tts_Anything, \"PEOP\", tts_Anything, \"pip\"},\n    {tts_Anything, \"POW\", tts_Anything, \"paU\"},\n    {tts_Anything, \"PUT\", tts_Nothing, \"pUt\"},\n    {tts_Anything, \"P\", tts_Anything, \"p\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_Q_rules[] = {\n    {tts_Anything, \"QUAR\", tts_Anything, \"kwOr\"},\n    {tts_Anything, \"QU\", tts_Anything, \"kw\"},\n    {tts_Anything, \"Q\", tts_Anything, \"k\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_R_rules[] = {\n    {tts_Nothing, \"RE\", \"^#\", \"ri\"},\n    {tts_Anything, \"R\", tts_Anything, \"r\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_S_rules[] = {\n    {tts_Anything, \"SH\", tts_Anything, \"S\"},\n    {\"#\", \"SION\", tts_Anything, \"Z@n\"},\n    {tts_Anything, \"SOME\", tts_Anything, \"sVm\"},\n    {\"#\", \"SUR\", \"#\", \"Z3\"},\n    {tts_Anything, \"SUR\", \"#\", \"S3\"},\n    {\"#\", \"SU\", \"#\", \"Zu\"},\n    {\"#\", \"SSU\", \"#\", \"Su\"},\n    {\"#\", \"SED\", tts_Nothing, \"zd\"},\n    {\"#\", \"S\", \"#\", \"z\"},\n    {tts_Anything, \"SAID\", tts_Anything, \"sed\"},\n    {\"^\", \"SION\", tts_Anything, \"S@n\"},\n    {tts_Anything, \"S\", \"S\", \"\"},\n    {\".\", \"S\", tts_Nothing, \"z\"},\n    {\"#:.E\", \"S\", tts_Nothing, \"z\"},\n    {\"#:^##\", \"S\", tts_Nothing, \"z\"},\n    {\"#:^#\", \"S\", tts_Nothing, \"s\"},\n    {\"U\", \"S\", tts_Nothing, \"s\"},\n    {\" :#\", \"S\", tts_Nothing, \"z\"},\n    {tts_Nothing, \"SCH\", tts_Anything, \"sk\"},\n    {tts_Anything, \"S\", \"C+\", \"\"},\n    {\"#\", \"SM\", tts_Anything, \"zm\"},\n    {\"#\", \"SN\", \"'\", \"z@n\"},\n    {tts_Anything, \"S\", tts_Anything, \"s\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_T_rules[] = {\n    {tts_Nothing, \"THE\", tts_Nothing, \"D@\"},\n    {tts_Anything, \"TO\", tts_Nothing, \"tu\"},\n    {tts_Anything, \"THAT\", tts_Nothing, \"D&t\"},\n    {tts_Nothing, \"THIS\", tts_Nothing, \"DIs\"},\n    {tts_Nothing, \"THEY\", tts_Anything, \"DeI\"},\n    {tts_Nothing, \"THERE\", tts_Anything, \"Der\"},\n    {tts_Anything, \"THER\", tts_Anything, \"D3\"},\n    {tts_Anything, \"THEIR\", tts_Anything, \"Der\"},\n    {tts_Nothing, \"THAN\", tts_Nothing, \"D&n\"},\n    {tts_Nothing, \"THEM\", tts_Nothing, \"Dem\"},\n    {tts_Anything, \"THESE\", tts_Nothing, \"Diz\"},\n    {tts_Nothing, \"THEN\", tts_Anything, \"Den\"},\n    {tts_Anything, \"THROUGH\", tts_Anything, \"Tru\"},\n    {tts_Anything, \"THOSE\", tts_Anything, \"D@Uz\"},\n    {tts_Anything, \"THOUGH\", tts_Nothing, \"D@U\"},\n    {tts_Nothing, \"THUS\", tts_Anything, \"DVs\"},\n    {tts_Anything, \"TH\", tts_Anything, \"T\"},\n    {\"#:\", \"TED\", tts_Nothing, \"tId\"},\n    {\"S\", \"TI\", \"#N\", \"tS\"},\n    {tts_Anything, \"TI\", \"O\", \"S\"},\n    {tts_Anything, \"TI\", \"A\", \"S\"},\n    {tts_Anything, \"TIEN\", tts_Anything, \"S@n\"},\n    {tts_Anything, \"TUR\", \"#\", \"tS3\"},\n    {tts_Anything, \"TU\", \"A\", \"tSu\"},\n    {tts_Nothing, \"TWO\", tts_Anything, \"tu\"},\n    {tts_Anything, \"T\", tts_Anything, \"t\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_U_rules[] = {\n    {tts_Nothing, \"UN\", \"I\", \"jun\"},\n    {tts_Nothing, \"UN\", tts_Anything, \"Vn\"},\n    {tts_Nothing, \"UPON\", tts_Anything, \"@pOn\"},\n    {\"T\", \"UR\", \"#\", \"Ur\"},\n    {\"S\", \"UR\", \"#\", \"Ur\"},\n    {\"R\", \"UR\", \"#\", \"Ur\"},\n    {\"D\", \"UR\", \"#\", \"Ur\"},\n    {\"L\", \"UR\", \"#\", \"Ur\"},\n    {\"Z\", \"UR\", \"#\", \"Ur\"},\n    {\"N\", \"UR\", \"#\", \"Ur\"},\n    {\"J\", \"UR\", \"#\", \"Ur\"},\n    {\"TH\", \"UR\", \"#\", \"Ur\"},\n    {\"CH\", \"UR\", \"#\", \"Ur\"},\n    {\"SH\", \"UR\", \"#\", \"Ur\"},\n    {tts_Anything, \"UR\", \"#\", \"jUr\"},\n    {tts_Anything, \"UR\", tts_Anything, \"3\"},\n    {tts_Anything, \"U\", \"^ \", \"V\"},\n    {tts_Anything, \"U\", \"^^\", \"V\"},\n    {tts_Anything, \"UY\", tts_Anything, \"aI\"},\n    {\" G\", \"U\", \"#\", \"\"},\n    {\"G\", \"U\", \"%\", \"\"},\n    {\"G\", \"U\", \"#\", \"w\"},\n    {\"#N\", \"U\", tts_Anything, \"ju\"},\n    {\"T\", \"U\", tts_Anything, \"u\"},\n    {\"S\", \"U\", tts_Anything, \"u\"},\n    {\"R\", \"U\", tts_Anything, \"u\"},\n    {\"D\", \"U\", tts_Anything, \"u\"},\n    {\"L\", \"U\", tts_Anything, \"u\"},\n    {\"Z\", \"U\", tts_Anything, \"u\"},\n    {\"N\", \"U\", tts_Anything, \"u\"},\n    {\"J\", \"U\", tts_Anything, \"u\"},\n    {\"TH\", \"U\", tts_Anything, \"u\"},\n    {\"CH\", \"U\", tts_Anything, \"u\"},\n    {\"SH\", \"U\", tts_Anything, \"u\"},\n    {tts_Anything, \"U\", tts_Anything, \"ju\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_V_rules[] = {\n    {tts_Anything, \"VIEW\", tts_Anything, \"vju\"},\n    {tts_Anything, \"V\", tts_Anything, \"v\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_W_rules[] = {\n    {tts_Nothing, \"WERE\", tts_Anything, \"w3\"},\n    {tts_Anything, \"WA\", \"S\", \"w0\"},\n    {tts_Anything, \"WA\", \"T\", \"w0\"},\n    {tts_Anything, \"WHERE\", tts_Anything, \"hwer\"},\n    {tts_Anything, \"WHAT\", tts_Anything, \"hw0t\"},\n    {tts_Anything, \"WHOL\", tts_Anything, \"h@Ul\"},\n    {tts_Anything, \"WHO\", tts_Anything, \"hu\"},\n    {tts_Anything, \"WH\", tts_Anything, \"hw\"},\n    {tts_Anything, \"WAR\", tts_Anything, \"wOr\"},\n    {tts_Anything, \"WOR\", \"^\", \"w3\"},\n    {tts_Anything, \"WR\", tts_Anything, \"r\"},\n    {tts_Anything, \"W\", tts_Anything, \"w\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_X_rules[] = {\n    {tts_Anything, \"X\", tts_Anything, \"ks\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_Y_rules[] = {\n    {tts_Anything, \"YOUNG\", tts_Anything, \"jVN\"},\n    {tts_Nothing, \"YOU\", tts_Anything, \"ju\"},\n    {tts_Nothing, \"YES\", tts_Anything, \"jes\"},\n    {tts_Nothing, \"Y\", tts_Anything, \"j\"},\n    {\"#:^\", \"Y\", tts_Nothing, \"i\"},\n    {\"#:^\", \"Y\", \"I\", \"i\"},\n    {\" :\", \"Y\", tts_Nothing, \"aI\"},\n    {\" :\", \"Y\", \"#\", \"aI\"},\n    {\" :\", \"Y\", \"^+:#\", \"I\"},\n    {\" :\", \"Y\", \"^#\", \"aI\"},\n    {tts_Anything, \"Y\", tts_Anything, \"I\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule tts_Z_rules[] = {\n    {tts_Anything, \"Z\", tts_Anything, \"z\"},\n    {tts_Anything, 0, tts_Anything, tts_Silent},\n};\n\nstatic tts_Rule *tts_Rules[] = {\n    tts_punct_rules,\n    tts_A_rules, tts_B_rules, tts_C_rules, tts_D_rules, tts_E_rules, tts_F_rules, tts_G_rules,\n    tts_H_rules, tts_I_rules, tts_J_rules, tts_K_rules, tts_L_rules, tts_M_rules, tts_N_rules,\n    tts_O_rules, tts_P_rules, tts_Q_rules, tts_R_rules, tts_S_rules, tts_T_rules, tts_U_rules,\n    tts_V_rules, tts_W_rules, tts_X_rules, tts_Y_rules, tts_Z_rules\n};\n\n\nstatic const char *tts_Cardinals[] = {\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \n    \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n    \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \n    \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n};\n\n\nstatic const char *tts_Twenties[] = {\n    \"twenty\", \"thirty\", \"forty\", \"fifty\",\n    \"sixty\", \"seventy\", \"eighty\", \"ninety\"\n};\n\n\nstatic const char *tts_Ordinals[] = {\n    \"zeroth\", \"first\", \"second\", \"third\", \"fourth\", \n    \"fifth\", \"sixth\", \"seventh\",\"eighth\", \"ninth\",\n    \"tenth\", \"eleventh\", \"twelfth\", \"thirteenth\", \"fourteenth\", \n    \"fifteenth\", \"sixteenth\", \"seventeenth\", \"eighteenth\", \"nineteenth\"\n};\n\n\nstatic const char *tts_Ord_twenties[] = {\n    \"twentieth\", \"thirtieth\", \"fortieth\", \"fiftieth\",\n    \"sixtieth\", \"seventieth\", \"eightieth\", \"ninetieth\"\n};\n\n\nstatic int tts_xlate_string(const char *string, struct tts_darray_t *phone, void* memctx);\n\n\n/*\n** Translate a number to phonemes.  This version is for CARDINAL numbers.\n**       Note: this is recursive.\n*/\nstatic int tts_xlate_cardinal(int value, struct tts_darray_t* phone, void* memctx)\n{\n    int nph = 0;\n\n    if (value < 0) {\n        nph += tts_xlate_string(\"minus\", phone, memctx);\n        value = (-value);\n\n        if (value < 0) {                 /* Overflow!  -32768 */\n            nph += tts_xlate_string(\"a lot\", phone, memctx);\n            return nph;\n        }\n    }\n\n    if (value >= 1000000000L) {\n        /* Billions */\n        nph += tts_xlate_cardinal(value / 1000000000L, phone, memctx);\n        nph += tts_xlate_string(\"billion\", phone, memctx);\n        value = value % 1000000000;\n\n        if (value == 0)\n            return nph;                   /* Even billion */\n\n        if (value < 100)\n            nph += tts_xlate_string(\"and\", phone, memctx);\n\n        /* as in THREE BILLION AND FIVE */\n    }\n\n    if (value >= 1000000L) {\n        /* Millions */\n        nph += tts_xlate_cardinal(value / 1000000L, phone, memctx);\n        nph += tts_xlate_string(\"million\", phone, memctx);\n        value = value % 1000000L;\n\n        if (value == 0)\n            return nph;                   /* Even million */\n\n        if (value < 100)\n            nph += tts_xlate_string(\"and\", phone, memctx);\n\n        /* as in THREE MILLION AND FIVE */\n    }\n\n    /* Thousands 1000..1099 2000..99999 */\n    /* 1100 to 1999 is eleven-hunderd to ninteen-hunderd */\n\n    if ((value >= 1000L && value <= 1099L) || value >= 2000L) {\n        nph += tts_xlate_cardinal(value / 1000L, phone, memctx);\n        nph += tts_xlate_string(\"thousand\", phone, memctx);\n        value = value % 1000L;\n\n        if (value == 0)\n            return nph;                   /* Even thousand */\n\n        if (value < 100)\n            nph += tts_xlate_string(\"and\", phone, memctx);\n\n        /* as in THREE THOUSAND AND FIVE */\n    }\n\n    if (value >= 100L) {\n        nph += tts_xlate_string(tts_Cardinals[value / 100], phone, memctx);\n        nph += tts_xlate_string(\"hundred\", phone, memctx);\n        value = value % 100;\n\n        if (value == 0)\n            return nph;                   /* Even hundred */\n    }\n\n    if (value >= 20) {\n        nph += tts_xlate_string(tts_Twenties[(value - 20) / 10], phone, memctx);\n        value = value % 10;\n\n        if (value == 0)\n            return nph;                   /* Even ten */\n    }\n\n    nph += tts_xlate_string(tts_Cardinals[value], phone, memctx);\n\n    return nph;\n}\n\n/*\n** Translate a number to phonemes.  This version is for ORDINAL numbers.\n**       Note: this is recursive.\n*/\n#if 0\nstatic int tts_xlate_ordinal(int value, darray *phone) {\n    int nph = 0;\n\n    if (value < 0) {\n        nph += tts_xlate_string(\"minus\", phone);\n        value = (-value);\n\n        if (value < 0) {                 /* Overflow!  -32768 */\n            nph += tts_xlate_string(\"a lot\", phone);\n            return nph;\n        }\n    }\n\n    if (value >= 1000000000L) {\n        /* Billions */\n        nph += tts_xlate_cardinal(value / 1000000000L, phone);\n        value = value % 1000000000;\n\n        if (value == 0)\n        {\n            nph += tts_xlate_string(\"billionth\", phone);\n            return nph;                  /* Even billion */\n        }\n\n        nph += tts_xlate_string(\"billion\", phone);\n\n        if (value < 100)\n            nph += tts_xlate_string(\"and\", phone);\n\n        /* as in THREE BILLION AND FIVE */\n    }\n\n    if (value >= 1000000L) {\n        /* Millions */\n        nph += tts_xlate_cardinal(value / 1000000L, phone);\n        value = value % 1000000L;\n\n        if (value == 0)\n        {\n            nph += tts_xlate_string(\"millionth\", phone);\n            return nph;                  /* Even million */\n        }\n\n        nph += tts_xlate_string(\"million\", phone);\n\n        if (value < 100)\n            nph += tts_xlate_string(\"and\", phone);\n\n        /* as in THREE MILLION AND FIVE */\n    }\n\n    /* Thousands 1000..1099 2000..99999 */\n    /* 1100 to 1999 is eleven-hunderd to ninteen-hunderd */\n\n    if ((value >= 1000L && value <= 1099L) || value >= 2000L) {\n        nph += tts_xlate_cardinal(value / 1000L, phone);\n        value = value % 1000L;\n\n        if (value == 0)\n        {\n            nph += tts_xlate_string(\"thousandth\", phone);\n            return nph;                  /* Even thousand */\n        }\n\n        nph += tts_xlate_string(\"thousand\", phone);\n\n        if (value < 100)\n            nph += tts_xlate_string(\"and\", phone);\n\n        /* as in THREE THOUSAND AND FIVE */\n    }\n\n    if (value >= 100L) {\n        nph += tts_xlate_string(tts_Cardinals[value / 100], phone);\n        value = value % 100;\n\n        if (value == 0)\n        {\n            nph += tts_xlate_string(\"hundredth\", phone);\n            return nph;                  /* Even hundred */\n        }\n\n        nph += tts_xlate_string(\"hundred\", phone);\n    }\n\n    if (value >= 20) {\n        if ((value % 10) == 0)\n        {\n            nph += tts_xlate_string(tts_Ord_twenties[(value - 20) / 10], phone);\n            return nph;                  /* Even ten */\n        }\n\n        nph += tts_xlate_string(tts_Twenties[(value - 20) / 10], phone);\n\n        value = value % 10;\n    }\n\n    nph += tts_xlate_string(tts_Ordinals[value], phone);\n\n    return nph;\n}\n#endif\n\n\nstatic int tts_isvowel(int chr) {\n    return (chr == 'A' || chr == 'E' || chr == 'I' ||\n        chr == 'O' || chr == 'U');\n}\n\nstatic int tts_isconsonant(int chr) {\n    return (isupper(chr) && !tts_isvowel(chr));\n}\n\nstatic int tts_leftmatch(\n    const char *pattern,                    /* first char of pattern to match in text */\n    const char *context) {                     /* last char of text to be matched */\n \n    const char *pat;\n    const char *text;\n    int count;\n\n    if (*pattern == '\\0') {\n        /* null string matches any context */\n        return 1;\n    }\n\n    /* point to last character in pattern string */\n    count = (int)strlen(pattern);\n\n    pat = pattern + (count - 1);\n\n    text = context;\n\n    for (; count > 0; pat--, count--) {\n        /* First check for simple text or space */\n        if (isalpha(*pat) || *pat == '\\'' || *pat == ' ') {\n            if (*pat != *text) {\n                return 0;\n            } else {\n                text--;\n                continue;\n            }\n        }\n\n        switch (*pat) {\n            case '#':                   /* One or more vowels */\n                if (!tts_isvowel(*text))\n                    return 0;\n                text--;\n                while (tts_isvowel(*text))\n                    text--;\n                break;\n\n            case ':':                   /* Zero or more consonants */\n                while (tts_isconsonant(*text))\n                    text--;\n                break;\n\n            case '^':                   /* One consonant */\n                if (!tts_isconsonant(*text))\n                    return 0;\n                text--;\n                break;\n\n            case '.':                   /* B, D, V, G, J, L, M, N, R, W, Z */\n                if (*text != 'B' && *text != 'D' && *text != 'V'\n                    && *text != 'G' && *text != 'J' && *text != 'L'\n                    && *text != 'M' && *text != 'N' && *text != 'R'\n                    && *text != 'W' && *text != 'Z')\n                    return 0;\n                text--;\n                break;\n\n            case '+':                   /* E, I or Y (front vowel) */\n                if (*text != 'E' && *text != 'I' && *text != 'Y')\n                    return 0;\n                text--;\n                break;\n\n            case '%':\n            default:\n                // fprintf(stderr, \"Bad char in left rule: '%c'\\n\", *pat);\n                return 0;\n        }\n    }\n\n    return 1;\n}\n\nstatic int tts_rightmatch(\n    const char *pattern,                    /* first char of pattern to match in text */\n    const char *context) {                  /* last char of text to be matched */\n\n    const char *pat;\n    const char *text;\n\n    if (*pattern == '\\0')\n        /* null string matches any context */\n        return 1;\n\n    pat = pattern;\n\n    text = context;\n\n    for (pat = pattern; *pat != '\\0'; pat++) {\n        /* First check for simple text or space */\n        if (isalpha(*pat) || *pat == '\\'' || *pat == ' ') {\n            if (*pat != *text) {\n                return 0;\n            } else {\n                text++;\n                continue;\n            }\n        }\n\n        switch (*pat) {\n            case '#':                   /* One or more vowels */\n                if (!tts_isvowel(*text))\n                    return 0;\n                text++;\n                while (tts_isvowel(*text))\n                    text++;\n                break;\n\n            case ':':                   /* Zero or more consonants */\n                while (tts_isconsonant(*text))\n                    text++;\n                break;\n\n            case '^':                   /* One consonant */\n                if (!tts_isconsonant(*text))\n                    return 0;\n                text++;\n                break;\n\n            case '.':                   /* B, D, V, G, J, L, M, N, R, W, Z */\n                if (*text != 'B' && *text != 'D' && *text != 'V'\n                    && *text != 'G' && *text != 'J' && *text != 'L'\n                    && *text != 'M' && *text != 'N' && *text != 'R'\n                    && *text != 'W' && *text != 'Z')\n                    return 0;\n                text++;\n                break;\n\n            case '+':                   /* E, I or Y (front vowel) */\n                if (*text != 'E' && *text != 'I' && *text != 'Y')\n                    return 0;\n                text++;\n                break;\n\n            case '%':                   /* ER, E, ES, ED, ING, ELY (a suffix) */\n                if (*text == 'E') {\n                    text++;\n                    if (*text == 'L') {\n                        text++;\n                        if (*text == 'Y') {\n                            text++;\n                            break;\n                        } else {\n                            text--;               /* Don't gobble L */\n                            break;\n                        }\n                    } else {\n                        if (*text == 'R' || *text == 'S' || *text == 'D')\n                            text++;\n                    }\n                    break;\n                } else if (*text == 'I') {\n                    text++;\n                    if (*text == 'N') {\n                        text++;\n                        if (*text == 'G') {\n                            text++;\n                            break;\n                        }\n                    }\n\n                    return 0;\n                } else {\n                    return 0;\n                }\n\n            default:\n                // fprintf(stderr, \"Bad char in right rule:'%c'\\n\", *pat);\n                return 0;\n        }\n    }\n\n    return 1;\n}\n\n\n\nstatic void tts_phone_cat(struct tts_darray_t *arg, const char *s) {\n    char ch;\n\n    while ((ch = *s++))\n        tts_darray_put( arg, ch );\n}\n\n\nstatic int tts_find_rule( struct tts_darray_t* arg, char *word, int index, tts_Rule *rules ) {\n    for (;;) {                        /* Search for the rule */\n        tts_Rule *rule;\n        const char *left,\n            *match,\n            *right,\n            *output;\n        int remainder;\n        rule = rules++;\n        match = (*rule)[1];\n\n        if (match == 0) {\n            /* bad symbol! */\n            fprintf(stderr, \"Error: Can't find rule for: '%c' in \\\"%s\\\"\\n\",\n                word[index], word);\n            return index + 1;            /* Skip it! */\n        }\n\n        for (remainder = index; *match != '\\0'; match++, remainder++) {\n            if (*match != word[remainder])\n                break;\n        }\n\n        if (*match != '\\0')\n            continue;                     /* found missmatch */\n\n        left = (*rule)[0];\n\n        right = (*rule)[2];\n\n        if (!tts_leftmatch(left, &word[index - 1]))\n            continue;\n\n        if (!tts_rightmatch(right, &word[remainder]))\n            continue;\n\n        output = (*rule)[3];\n\n        tts_phone_cat(arg, output);\n\n        return remainder;\n    }\n}\n\n\nstatic void tts_guess_word( struct tts_darray_t *arg, char *word ) {\n    int index;                       /* Current position in word */\n    int type;                        /* First letter of match part */\n    index = 1;                       /* Skip the initial blank */\n\n    do {\n        if (isupper(word[index]))\n            type = word[index] - 'A' + 1;\n        else\n            type = 0;\n\n        index = tts_find_rule(arg, word, index, tts_Rules[type]);\n    } while (word[index] != '\\0');\n}\n\n\nstatic int tts_NRL(const char *s, int n, struct tts_darray_t *phone, void* memctx ) {\n    (void) memctx;\n    int old = tts_darray_getSize( phone );\n    char mem[ 64 ];    \n    char *word = mem;\n    if( n + 3 > sizeof( mem ) ) word = (char *) SPEECH_MALLOC( memctx, n + 3);\n    char *d = word;\n    *d++ = ' ';\n\n    while (n-- > 0) {\n        char ch = *s++;\n\n        if (islower(ch))\n            ch = (char) toupper(ch);\n\n        *d++ = ch;\n    }\n\n    *d++ = ' '; // kinda unnecessary\n\n    *d = '\\0';\n    tts_guess_word(phone, word);\n    if( word != mem ) SPEECH_FREE( memctx, word );\n    return tts_darray_getSize( phone ) - old;\n}\n\n\nstatic int tts_spell_out(const char *word, int n, struct tts_darray_t *phone, void* memctx)\n{\n    int nph = 0;\n\n    while (n-- > 0) {\n        nph += tts_xlate_string(tts_ASCII[*word++ & 0x7F], phone, memctx);\n    }\n\n    return nph;\n}\n\nstatic int tts_suspect_word(const char *s, int n) {\n    int i = 0;\n    int seen_lower = 0;\n    int seen_upper = 0;\n    int seen_vowel = 0;\n    int last = 0;\n\n    for (i = 0; i < n; i++) {\n        char ch = *s++;\n\n        if (i && last != '-' && isupper(ch))\n            seen_upper = 1;\n\n        if (islower(ch)) {\n            seen_lower = 1;\n            ch = (char) toupper(ch);\n        }\n\n        if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch == 'Y')\n            seen_vowel = 1;\n\n        last = ch;\n    }\n\n    return !seen_vowel || (seen_upper && seen_lower) || !seen_lower;\n}\n\nstatic int tts_xlate_word(const char *word, int n, struct tts_darray_t *phone, void* memctx) {\n    int nph = 0;\n\n    if (*word != '[') {\n        if (tts_suspect_word(word, n)) {\n            return tts_spell_out(word, n, phone, memctx);\n        } else {\n            nph += tts_NRL(word, n, phone, memctx);\n        }\n    } else {\n        if ((++word)[(--n) - 1] == ']')\n            n--;\n\n        while (n-- > 0) {\n            tts_darray_put( phone, *word++);\n            nph++;\n        }\n    }\n\n    tts_darray_put( phone, ' ');\n\n    return nph + 1;\n}\n\n\nstatic int tts_xlate_string(const char *string, struct tts_darray_t *phone, void* memctx) {\n    int nph = 0;\n    const char *s = string;\n    char ch;\n\n    while (isspace(ch = *s))\n        s++;\n\n    while ((ch = *s)) {\n        const char *word = s;\n\n        if (isalpha(ch)) {\n            while (isalpha(ch = *s) || ((ch == '\\'' || ch == '-' || ch == '.') && isalpha(s[1])))\n                s++;\n\n            if (!ch || isspace(ch) || ispunct(ch) || (isdigit(ch) && !tts_suspect_word(word, (int)(s - word)))) {\n                nph += tts_xlate_word(word, (int)(s - word), phone, memctx);\n            } else {\n                while ((ch = *s) && !isspace(ch) && !ispunct(ch))\n                    s++;\n\n                nph += tts_spell_out(word, (int)(s - word), phone, memctx);\n            }\n        } else {\n            if (isdigit(ch) || (ch == '-' && isdigit(s[1]))) {\n                int sign = (ch == '-') ? -1 : 1;\n                int value = 0;\n\n                if (sign < 0)\n                    ch = *++s;\n\n                while (isdigit(ch = *s)) {\n                    value = value * 10 + ch - '0';\n                    s++;\n                }\n\n                if (ch == '.' && isdigit(s[1])) {\n                    word = ++s;\n                    nph += tts_xlate_cardinal(value * sign, phone, memctx);\n                    nph += tts_xlate_string(\"point\", phone, memctx);\n\n                    while (isdigit(ch = *s))\n                        s++;\n\n                    nph += tts_spell_out(word, (int)(s - word), phone, memctx);\n                } else {\n                    /* check for ordinals, date, time etc. can go in here */\n                    nph += tts_xlate_cardinal(value * sign, phone, memctx);\n                }\n            } else {\n                if (ch == '[' && strchr(s, ']')) {\n                    const char *w = s;\n\n                    while (*s && *s++ != ']')\n                        /* nothing */\n                        ;\n\n                    nph += tts_xlate_word(w, (int)(s - w), phone, memctx);\n                } else {\n                    if (ispunct(ch)) {\n                        switch (ch) {\n                            case '!':\n                            case '?':\n                            case '.': {\n                                s++;\n                                tts_darray_put( phone, ' ');\n                            } break;\n\n                            case '\"':                 /* change pitch ? */\n                            case ':':\n                            case '-':\n                            case ';':\n                            case ',':\n                            case '(':\n                            case ')': {\n                                s++;\n                                tts_darray_put( phone, ' ');\n                            } break;\n\n                            case '[': {\n                                const char *e = strchr(s, ']');\n\n                                if (e) {\n                                    s++;\n\n                                    while (s < e)\n                                        tts_darray_put( phone, *s++);\n\n                                    s = e + 1;\n\n                                    break;\n                                }\n                            }\n                            default: {\n                                nph += tts_spell_out(word, 1, phone, memctx);\n                                s++;\n                            } break;\n                        }\n                    } else {\n                        while ((ch = *s) && !isspace(ch))\n                            s++;\n\n                        nph += tts_spell_out(word, (int)(s - word), phone, memctx);\n                    }\n\n                    while (isspace(ch = *s))\n                        s++;\n                }\n            }\n        }\n    }\n\n    return nph;\n}\n\n\n\nshort* speech_gen( int* samples_pairs_generated, char const* str, void* memctx ) {\n    struct tts_darray_t element;\n    tts_darray_init( &element, memctx );\n\n    struct tts_darray_t phone;\n    tts_darray_init( &phone, memctx );\n\n    tts_xlate_string( str, &phone, memctx );\n    int frames = tts_phone_to_elm( tts_darray_getData( &phone ), tts_darray_getSize( &phone ), &element );\n\n    struct tts_klatt_t synth;\n    tts_klatt_init( &synth );\n    \n    int sample_count = synth.mNspFr * frames;\n\n    if( samples_pairs_generated ) *samples_pairs_generated = sample_count * 4;\n    short* sample_pairs = (short*) SPEECH_MALLOC( memctx, sample_count * 8 * sizeof( short ) );   \n\n    short* samples = (short*) sample_pairs;\n\n    tts_klatt_initsynth( &synth, tts_darray_getSize( &element ), (unsigned char*) tts_darray_getData( &element )) ;\n    int x = 0;\n    int pos = 0;\n    while( x >= 0 ) {\n        x = tts_klatt_synth( &synth, 0, &samples[ pos ] );\n        if( x < 0 ) break;\n        pos += x;\n    }\n\n    short* in = samples + sample_count;\n    short* out = sample_pairs + sample_count * 4 * 2;\n    short prev_sample = 0;\n    while( out > sample_pairs ) {\n        out -= 4 *2;\n        --in;\n        short sample = *in;\n        int o[ 8 ];\n        o[0] = ( ((sample + (3 * prev_sample)) >> 2) ) * 2;\n        o[1] = ( ((sample + prev_sample) >> 1) ) * 2;\n        o[2] = ( (((3 * sample) + prev_sample) >> 2) ) * 2;\n        o[3] = ( sample ) * 2;\n        o[4] = ( ((sample + (3 * prev_sample)) >> 2) ) * 2;\n        o[5] = ( ((sample + prev_sample) >> 1) ) * 2;\n        o[6] = ( (((3 * sample) + prev_sample) >> 2) ) * 2;\n        o[7] = ( sample ) * 2;\n        prev_sample = sample;\n        for( int i = 0; i < 8; ++i ) out[ i ] = (short)( o[ i ] > 32767 ? 32767 : o[ i ] < -32767 ? -32767 : o[ i ] );\n    }\n    \n    tts_darray_term( &phone );\n    tts_darray_term( &element );\n    return sample_pairs;\n}\n\n\nvoid speech_free( short* sample_pairs, void* memctx ) {\n    (void) memctx;\n    SPEECH_FREE( memctx, sample_pairs );\n}\n\n\n#pragma warning( pop )\n\n#endif /* SPEECH_IMPLEMENTATION */\n\n\n/*\n----------------------------------------------------------------------------\n    LICENSE\n----------------------------------------------------------------------------\n\nThe speech synth is based on rsynth by the late Nick Ing-Simmons (et al).\n\nHe described the legal status as:\n\n    This is a text to speech system produced by integrating various pieces \n    of code and tables of data, which are all (I believe) in the public \n    domain.\n    \nSince then, the rsynth source code has passed legal checks by several open \nsource organizations, so it \"should\" be pretty safe.\n\nThe primary copyright claims seem to have to do with text-to-speech \ndictionary use, which I've removed completely.\n\nI've done some serious refactoring, clean-up and feature removal on the \nsource, as all I need is \"a\" free, simple speech synth, not a \"good\" speech \nsynth. Since I've removed a bunch of stuff, this is probably safer public \ndomain release than the original.\n\n(I'm rather surprised there's no good public domain speech synths out \nthere; after all, it's 2013..)\n\nI'm placing my changes in public domain as well, or if that's not \nacceptable for you, then CC0:\nhttp://creativecommons.org/publicdomain/zero/1.0/\n\nThe SoLoud interface files (soloud_speech.*) are under ZLib/LibPNG license.\n\n-- Jari Komppa 2013\n   \n----------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "strpool.h",
          "type": "blob",
          "size": 50.5986328125,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nstrpool.h - v1.4 - Highly efficient string pool for C/C++.\n\nDo this:\n    #define STRPOOL_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef strpool_h\n#define strpool_h\n\n#ifndef STRPOOL_U32\n    #define STRPOOL_U32 unsigned int\n#endif\n#ifndef STRPOOL_U64\n    #define STRPOOL_U64 unsigned long long\n#endif\n\ntypedef struct strpool_t strpool_t;\n\ntypedef struct strpool_config_t\n    {\n    void* memctx;\n    int ignore_case;\n    int counter_bits;\n    int index_bits;\n    int entry_capacity;\n    int block_capacity;\n    int block_size;\n    int min_length;\n    } strpool_config_t;\n\nextern strpool_config_t const strpool_default_config;\n\nvoid strpool_init( strpool_t* pool, strpool_config_t const* config );\nvoid strpool_term( strpool_t* pool );\n\nvoid strpool_defrag( strpool_t* pool );\n\nSTRPOOL_U64 strpool_inject( strpool_t* pool, char const* string, int length );\nvoid strpool_discard( strpool_t* pool, STRPOOL_U64 handle );\n\nint strpool_incref( strpool_t* pool, STRPOOL_U64 handle );\nint strpool_decref( strpool_t* pool, STRPOOL_U64 handle );\nint strpool_getref( strpool_t* pool, STRPOOL_U64 handle );\n\nint strpool_isvalid( strpool_t const* pool, STRPOOL_U64 handle );\n\nchar const* strpool_cstr( strpool_t const* pool, STRPOOL_U64 handle );\nint strpool_length( strpool_t const* pool, STRPOOL_U64 handle );\n\nchar* strpool_collate( strpool_t const* pool, int* count );\nvoid strpool_free_collated( strpool_t const* pool, char* collated_ptr );\n\n#endif /* strpool_h */\n\n\n/**\nstrpool.h\n=========\n\nHighly efficient string pool for C/C++.\n\n\nExample\n-------\n\n    #define  STRPOOL_IMPLEMENTATION\n    #include \"strpool.h\"\n\n    #include <stdio.h> // for printf\n    #include <string.h> // for strlen\n\n    int main( int argc, char** argv ) {\n\n        strpool_config_t conf = strpool_default_config;\n        //conf.ignore_case = true;\n\n        strpool_t pool;\n        strpool_init( &pool, &conf );\n\n        STRPOOL_U64 str_a = strpool_inject( &pool, \"This is a test string\", (int) strlen( \"This is a test string\" ) );\n        STRPOOL_U64 str_b = strpool_inject( &pool, \"THIS IS A TEST STRING\", (int) strlen( \"THIS IS A TEST STRING\" ) );\n    \n        printf( \"%s\\n\", strpool_cstr( &pool, str_a ) );\n        printf( \"%s\\n\", strpool_cstr( &pool, str_b ) );\n        printf( \"%s\\n\", str_a == str_b ? \"Strings are the same\" : \"Strings are different\" );\n    \n        strpool_term( &pool );\n        return 0;\n    }\n\n\nAPI Documentation\n-----------------\n\nstrpool.h is a system for string interning, where each string is stored only once. It makes comparing strings very fast,\nas it will just be uint64 comparison rather than looping over strings and comparing character by character. strpool.h is\nalso optimized for fast creation of strings, and with an efficient memory allocation scheme.\n\nstrpool.h is a single-header library, and does not need any .lib files or other binaries, or any build scripts. To use \nit, you just include strpool.h to get the API declarations. To get the definitions, you must include strpool.h from \n*one* single C or C++ file, and #define the symbol `STRPOOL_IMPLEMENTATION` before you do. \n\n\n### Customization\n\nThere are a few different things in strpool.h which are configurable by #defines. Most of the API use the `int` data \ntype, for integer values where the exact size is not important. However, for some functions, it specifically makes use \nof 32 and 64 bit data types. These default to using `unsigned int` and `unsigned long long` by default, but can be\nredefined by #defining STRPOOL_U32 and STRPOOL_U64 respectively, before including strpool.h. This is useful if you, for \nexample, use the types from `<stdint.h>` in the rest of your program, and you want strpool.h to use compatible types. In \nthis case, you would include strpool.h using the following code:\n\n    #define STRPOOL_U32 uint32_t\n    #define STRPOOL_U64 uint64_t\n    #include \"strpool.h\"\n\nNote that when customizing the data types, you need to use the same definition in every place where you include \nstrpool.h, as they affect the declarations as well as the definitions.\n\nThe rest of the customizations only affect the implementation, so will only need to be defined in the file where you\nhave the #define STRPOOL_IMPLEMENTATION.\n\nNote that if all customizations are utilized, strpool.h will include no external files whatsoever, which might be useful\nif you need full control over what code is being built.\n\n\n#### Custom memory allocators\n\nTo store strings and the internal structures (entry list, hashtable etc) strpool.h needs to dodynamic allocation by \ncalling `malloc`. Programs might want to keep track of allocations done, or use custom defined pools to allocate memory \nfrom. strpool.h allows for specifying custom memory allocation functions for `malloc` and `free`.\nThis is done with the following code:\n\n    #define STRPOOL_IMPLEMENTATION\n    #define STRPOOL_MALLOC( ctx, size ) ( my_custom_malloc( ctx, size ) )\n    #define STRPOOL_FREE( ctx, ptr ) ( my_custom_free( ctx, ptr ) )\n    #include \"strpool.h\"\n\nwhere `my_custom_malloc` and `my_custom_free` are your own memory allocation/deallocation functions. The `ctx` parameter\nis an optional parameter of type `void*`. When `strpool_init` is called, you can set the `memctx` field of the `config`\nparameter, to a pointer to anything you like, and which will be passed through as the `ctx` parameter to every \n`STRPOOL_MALLOC`/`STRPOOL_FREE` call. For example, if you are doing memory tracking, you can pass a pointer to your \ntracking data as `memctx`, and in your custom allocation/deallocation function, you can cast the `ctx` param back to the \nright type, and access the tracking data.\n\nIf no custom allocator is defined, strpool.h will default to `malloc` and `free` from the C runtime library.\n\n\n#### Custom assert\n\nstrpool.h makes use of asserts to report usage errors and failed allocation errors. By default, it makes use of the C \nruntime library `assert` macro, which only executes in debug builds. However, it allows for substituting with your own\nassert function or macro using the following code:\n\n    #define STRPOOL_IMPLEMENTATION\n    #define STRPOOL_ASSERT( condition ) ( my_custom_assert( condition ) )\n    #include \"strpool.h\"\n\nNote that if you only want the asserts to trigger in debug builds, you must add a check for this in your custom assert.\n\n\n#### Custom C runtime function\n\nThe library makes use of four additional functions from the C runtime library, and for full flexibility, it allows you \nto substitute them for your own. Here's an example:\n\n    #define STRPOOL_IMPLEMENTATION\n    #define STRPOOL_MEMSET( ptr, val, cnt ) ( my_memset_func( ptr, val, cnt ) )\n    #define STRPOOL_MEMCPY( dst, src, cnt ) ( my_memcpy_func( dst, src, cnt ) )\n    #define STRPOOL_MEMCMP( pr1, pr2, cnt ) ( my_memcmp_func( pr1, pr2, cnt ) )\n    #define STRPOOL_STRNICMP( s1, s2, len ) ( my_strnicmp_func( s1, s2, len ) )\n    #include \"strpool.h\"\n\nIf no custom function is defined, strpool.h will default to the C runtime library equivalent.\n\n\nstrpool_init\n------------\n\n    void strpool_init( strpool_t* pool, strpool_config_t const* config )\n\nInitializes an instance of the string pool. The `config` parameter allows for controlling the behavior of the pool\ninstance. It contains the following fields:\n\n* memctx - pointer to user defined data which will be passed through to custom STRPOOL_MALLOC/STRPOOL_FREE calls. May \n    be NULL.\n* ignore_case - set to 0 to make strings case sensitive, set to 1 to make strings case insensitive. Default is 0.\n* counter_bits - how many bits of the string handle to use for keeping track of handle reuse and invalidation. Default\n    is 32. See below for details about the handle bits.\n* index_bits - how many bits of the string handle to use for referencing string instances. Default is 32. See below for \n    details about the handle bits.\n* entry_capacity - number of string instance entries to pre-allocate space for when pool is initialized. Default \n    is space for 4096 string entries.\n* block_capacity - number of string storage block entries to pre-allocate space for when pool is initialized. Default \n    is space for 32 entries of block information - though only a single block will be pre-allocated.\n* block_size - size to allocate for each string storage block. A higher value might mean you often have more memory \n    allocated than is actually being used. A lower value means you will be making allocations more often. Default \n    is 256 kilobyte. \n* min_length - minimum space to allocate for each string. A higher value wastes more space, but makes it more likely \n    that recycled storage can be re-used by subsequent requests. Default is a string length of 23 characters.\n\nThe function `strpool_inject` returns a 64-bit handle. Using the settings `counter_bits`/`index_bits`, you can control\nhow many bits of the handle is in use, and how many are used for index vs counter. For example, setting `counter_bits`\nto 8 and `index_bits` to 24, you will get a handle which only uses 32 bits in total, can store some 16 million different\nstrings (2^24 -1), with a reuse counter going up to 255 before wrapping around. In this scenario, the 64-bit handle \nreturned from strpool_inject can be safely truncated and stored in a 32-bit variable. Any combination of counter vs \nindex bits is possible, but the number of strings which can be stored will be limited by `index_bits`. \n\nThe counter bits need a more detailed description. When a string is added via `strpool_inject`, you get a handle back, \nwhich is used to reference the string. You might store this handle in various data structures. When removing a string by\ncalling `strpool_discard`, the index part of that handle will be recycled, and re-used for future `strpool_inject`.\nHowever, when a string is discarded, the counter part of the handle will be increased, so the system knows that any \nhandles that are still being kept around in any data structure, does no longer point to a valid string (and thus will \nreturn a NULL string pointer when queried through `strpool_cstr`). If your use case involves creating a bunch of strings\nand just keeping them around until the application terminates, it is fine to specify 0 for `counter_bits`, thereby\neffectively disabling the handle validation all together. If you have a case where strings are being repeatedly created \nand removed, but strings are queried very frequently, then you can specify a low number for `counter_bits` (since you \ncan invalidate any stored handles as soon as you find out it's been invalidated). If you have a case where handles might\nsit inside data structures for a long period of time before you check their validity, you best specify a high value for\n`counter_bits`. The default value is 32 bits for index and 32 bits for counter.\n\n\nstrpool_term\n------------\n\n    void strpool_term( strpool_t* pool )\n\nTerminates a string pool instance, releasing all memory used by it. No further calls to the strpool API are valid until\nthe instance is reinitialized by another call to `strpool_init`.\n\n\nstrpool_defrag\n--------------\n\n    void strpool_defrag( strpool_t* pool )\n\nAs strings are added to and removed from the pool, the memory blocks holding the strings may get fragmented, making them\ntake up more allocated memory than is actually needed to store the set of strings, should they be packed tightly,\n`strpool_defrag` consolidates all strings into a single memory block (which might well be larger than the block size \nspecified when the pool was initialized), and recreates the internal hash table. Any additionally allocated memory \nblocks will be deallocated, making the memory used by the pool as little as it can be to fit the current set of strings.\nAll string handles remain valid after a call to `strpool_defrag`.\n\n\nstrpool_inject\n--------------\n\n    STRPOOL_U64 strpool_inject( strpool_t* pool, char const* string, int length )\n\nAdds a string to the pool, and returns a handle for the added string. If the string doesn't exist, it will be stored in\nan unused part of an already allocated storage block (or a new block will be allocated if there is no free space large\nenough to hold the string), and inserted into the internal hash table. If the string already exists, a handle to the\nexisting string will be returned. If the `string` parameter is already pointing to a string stored in the pool, there \nare specific optimizations for avoiding to loop over it to calculate the hash for it, with the idea being that you \nshould be able to use char* types when you're passing strings around, and use the string pool for storage, without too\nmuch of a performance penalty. `string` does not have to be null terminated, but when it is retrieved from the string \npool, it will be. If `string` is NULL or length is 0, a handle with a value of 0 will be returned, to signify empty\nstring.\n\n\nstrpool_discard\n---------------\n\n    void strpool_discard( strpool_t* pool, STRPOOL_U64 handle )\n\nRemoves a string from the pool. Any handles held for the string will be invalid after this. Memory used for storing the\nstring will be recycled and used for further `strpool_inject` calls. If `handle` is invalid, `strpool_discard` will do\nnothing.\n\n\nstrpool_incref\n--------------\n\n    int strpool_incref( strpool_t* pool, STRPOOL_U64 handle )\n\n`strpool.h` supports reference counting of strings. It is optional and not automatic, and does not automatically discard\nstrings when the reference count reaches 0. To use reference counting, make sure to call `strpool_incref` whenever you\nadd a string (after having called `strpool_inject`), and to call `strpool_decref` whenever you want to remove a string\n(but only call `strpool_discard` if reference count have reached 0). It would be advisable to write wrapper functions\nto ensure consistency in this, or if C++ is used, a wrapper class with constructors/destructor. `strpool_incref` returns\nthe reference count after increasing it. If `handle` is invalid, `strpool_incref` will do nothing, and return 0.\n\n\nstrpool_decref\n--------------\n\n    int strpool_decref( strpool_t* pool, STRPOOL_U64 handle )\n\nDecreases the reference count of the specified string by 1, returning the reference count after decrementing. If the\nreference count is less than 1, an assert will be triggered. If `handle` is invalid, `strpool_decref` will do nothing, \nand return 0.\n\n\nstrpool_getref\n--------------\n\n    int strpool_getref( strpool_t* pool, STRPOOL_U64 handle )\n\nReturns the current reference count for the specified string. If `handle` is invalid, `strpool_getref` will do nothing, \nand return 0.\n\n\nstrpool_isvalid\n---------------\n    \n    int strpool_isvalid( strpool_t const* pool, STRPOOL_U64 handle )\n\nReturns 1 if the specified string handle is valid, and 0 if it is not. \n\n\nstrpool_cstr\n------------\n\n    char const* strpool_cstr( strpool_t const* pool, STRPOOL_U64 handle )\n\nReturns the zero-terminated C string for the specified string handle. The resulting string pointer is only valid as long\nas no call is made to `strpool_init`, `strpool_term`, `strpool_defrag` or `strpool_discard`. It is therefor recommended\nto never store the C string pointer, and always grab it fresh by another call to `strpool_cstr` when it is needed.\n`strpool_cstr` is a very fast function to call - it does little more than an array lookup. If `handle` is invalid, \n`strpool_cstr` returns NULL. \n\n\nstrpool_length\n--------------\n\n    int strpool_length( strpool_t const* pool, STRPOOL_U64 handle )\n\nReturns the length, in characters, of the specified string. The resulting value is only valid as long as no call is made \nto `strpool_init`, `strpool_term`, `strpool_defrag` or `strpool_discard`. It is therefor recommended to never store the \nvalue, and always grab it fresh by another call to `strpool_length` when it is needed. `strpool_length` is a very fast \nfunction to call - it does little more than an array lookup. If `handle` is invalid, `strpool_length` returns 0.\n\n\nstrpool_collate\n---------------\n\n    char* strpool_collate( strpool_t const* pool, int* count )\n\nReturns a list of all the strings currently stored in the string pool, and stores the number of strings in the int\nvariable pointed to by `count`. If there are no strings in the string pool, `strpool_collate` returns NULL. The pointer\nreturned points to the first character of the first string. Strings are zero-terminated, and immediately after the \ntermination character, comes the first character of the next string.\n\n\nstrpool_free_collated\n---------------------\n\n    void strpool_free_collated( strpool_t const* pool, char* collated_ptr )\n\nReleases the memory returned by `strpool_collate`. \n\n*/\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifndef strpool_impl\n#define strpool_impl\n\nstruct strpool_internal_hash_slot_t;\nstruct strpool_internal_entry_t;\nstruct strpool_internal_handle_t;\nstruct strpool_internal_block_t;\n\nstruct strpool_t\n    {\n    void* memctx;\n    int ignore_case;\n    int counter_shift;\n    STRPOOL_U64 counter_mask;\n    STRPOOL_U64 index_mask;\n\n    int initial_entry_capacity;\n    int initial_block_capacity;\n    int block_size;\n    int min_data_size;\n\n    struct strpool_internal_hash_slot_t* hash_table;\n    int hash_capacity;\n\n    struct strpool_internal_entry_t* entries;\n    int entry_capacity;\n    int entry_count;\n\n    struct strpool_internal_handle_t* handles;\n    int handle_capacity;\n    int handle_count;\n    int handle_freelist_head;\n    int handle_freelist_tail;\n\n    struct strpool_internal_block_t* blocks;\n    int block_capacity;\n    int block_count;\n    int current_block;\n    };\n\n\n#endif /* strpool_impl */\n\n\n#ifdef STRPOOL_IMPLEMENTATION\n#undef STRPOOL_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <stddef.h>\n\n#ifndef STRPOOL_ASSERT\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <assert.h>\n    #define STRPOOL_ASSERT( expression, message ) assert( ( expression ) && ( message ) )\n#endif\n\n#ifndef STRPOOL_MEMSET\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define STRPOOL_MEMSET( ptr, val, cnt ) ( memset( ptr, val, cnt ) )\n#endif \n\n#ifndef STRPOOL_MEMCPY\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define STRPOOL_MEMCPY( dst, src, cnt ) ( memcpy( dst, src, cnt ) )\n#endif \n\n#ifndef STRPOOL_MEMCMP\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <string.h>\n    #define STRPOOL_MEMCMP( pr1, pr2, cnt ) ( memcmp( pr1, pr2, cnt ) )\n#endif \n\n#ifndef STRPOOL_STRNICMP\n    #ifdef _WIN32\n        #define _CRT_NONSTDC_NO_DEPRECATE \n        #define _CRT_SECURE_NO_WARNINGS\n        #include <string.h>\n        #define STRPOOL_STRNICMP( s1, s2, len ) ( strnicmp( s1, s2, len ) )\n    #else\n        #include <string.h>\n        #define STRPOOL_STRNICMP( s1, s2, len ) ( strncasecmp( s1, s2, len ) )        \n    #endif\n#endif \n\n#ifndef STRPOOL_MALLOC\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdlib.h>\n    #define STRPOOL_MALLOC( ctx, size ) ( malloc( size ) )\n    #define STRPOOL_FREE( ctx, ptr ) ( free( ptr ) )\n#endif\n\n\ntypedef struct strpool_internal_hash_slot_t\n    {\n    STRPOOL_U32 hash_key;\n    int entry_index;\n    int base_count;\n    } strpool_internal_hash_slot_t;\n\n\ntypedef struct strpool_internal_entry_t\n    {\n    int hash_slot;\n    int handle_index;\n    char* data;\n    int size;\n    int length;\n    int refcount;\n    } strpool_internal_entry_t;\n\n\ntypedef struct strpool_internal_handle_t\n    {\n    int entry_index;\n    int counter;\n    } strpool_internal_handle_t;\n\n\ntypedef struct strpool_internal_block_t\n    {\n    int capacity;\n    char* data;\n    char* tail;\n    int free_list;\n    } strpool_internal_block_t;\n\n\ntypedef struct strpool_internal_free_block_t\n    {\n    int size;\n    int next;\n    } strpool_internal_free_block_t;\n\n\nstrpool_config_t const strpool_default_config = \n    { \n    /* memctx         = */ 0,\n    /* ignore_case    = */ 0,\n    /* counter_bits   = */ 32,\n    /* index_bits     = */ 32,\n    /* entry_capacity = */ 4096, \n    /* block_capacity = */ 32, \n    /* block_size     = */ 256 * 1024, \n    /* min_length     = */ 23,\n    };\n\n\n\nstatic STRPOOL_U32 strpool_internal_pow2ceil( STRPOOL_U32 v )\n    {\n    --v;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    ++v;\n    v += ( v == 0 );\n    return v;\n    }\n\n\nstatic int strpool_internal_add_block( strpool_t* pool, int size )\n    {\n    if( pool->block_count >= pool->block_capacity ) \n        {\n        pool->block_capacity *= 2;\n        strpool_internal_block_t* new_blocks = (strpool_internal_block_t*) STRPOOL_MALLOC( pool->memctx, \n            pool->block_capacity * sizeof( *pool->blocks ) );\n        STRPOOL_ASSERT( new_blocks, \"Allocation failed\" );\n        STRPOOL_MEMCPY( new_blocks, pool->blocks, pool->block_count * sizeof( *pool->blocks ) );\n        STRPOOL_FREE( pool->memctx, pool->blocks );\n        pool->blocks = new_blocks;\n        }\n    pool->blocks[ pool->block_count ].capacity = size;\n    pool->blocks[ pool->block_count ].data = (char*) STRPOOL_MALLOC( pool->memctx, (size_t) size );\n    STRPOOL_ASSERT( pool->blocks[ pool->block_count ].data, \"Allocation failed\" );\n    pool->blocks[ pool->block_count ].tail = pool->blocks[ pool->block_count ].data;\n    pool->blocks[ pool->block_count ].free_list = -1;\n    return pool->block_count++;\n    }\n\n\nvoid strpool_init( strpool_t* pool, strpool_config_t const* config )\n    {\n    if( !config ) config = &strpool_default_config;\n\n    pool->memctx = config->memctx;\n    pool->ignore_case = config->ignore_case;\n\n    STRPOOL_ASSERT( config->counter_bits + config->index_bits <= 64, \"Total bit count exceeds 64\" );\n    pool->counter_shift = config->index_bits;\n    pool->counter_mask = ( 1ULL << (STRPOOL_U64) config->counter_bits ) - 1;\n    pool->index_mask = ( 1ULL << (STRPOOL_U64) config->index_bits ) - 1;\n\n    pool->initial_entry_capacity = \n        (int) strpool_internal_pow2ceil( config->entry_capacity > 1 ? (STRPOOL_U32)config->entry_capacity : 2U );\n    pool->initial_block_capacity = \n        (int) strpool_internal_pow2ceil( config->block_capacity > 1 ? (STRPOOL_U32)config->block_capacity : 2U );\n    pool->block_size = \n        (int) strpool_internal_pow2ceil( config->block_size > 256 ? (STRPOOL_U32)config->block_size : 256U );\n    pool->min_data_size = \n        (int) ( sizeof( int ) * 2 + 1 + ( config->min_length > 8 ? (STRPOOL_U32)config->min_length : 8U ) );\n\n    pool->hash_capacity = pool->initial_entry_capacity * 2;\n    pool->entry_capacity = pool->initial_entry_capacity;\n    pool->handle_capacity = pool->initial_entry_capacity;\n    pool->block_capacity = pool->initial_block_capacity;    \n\n    pool->handle_freelist_head = -1;\n    pool->handle_freelist_tail = -1;\n    pool->block_count = 0;\n    pool->handle_count = 0;\n    pool->entry_count = 0;\n    \n    pool->hash_table = (strpool_internal_hash_slot_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->hash_capacity * sizeof( *pool->hash_table ) );\n    STRPOOL_ASSERT( pool->hash_table, \"Allocation failed\" );\n    STRPOOL_MEMSET( pool->hash_table, 0, pool->hash_capacity * sizeof( *pool->hash_table ) );\n    pool->entries = (strpool_internal_entry_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->entry_capacity * sizeof( *pool->entries ) );\n    STRPOOL_ASSERT( pool->entries, \"Allocation failed\" );\n    pool->handles = (strpool_internal_handle_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->handle_capacity * sizeof( *pool->handles ) );\n    STRPOOL_ASSERT( pool->handles, \"Allocation failed\" );\n    pool->blocks = (strpool_internal_block_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->block_capacity * sizeof( *pool->blocks ) );\n    STRPOOL_ASSERT( pool->blocks, \"Allocation failed\" );\n\n    pool->current_block = strpool_internal_add_block( pool, pool->block_size );\n    }\n\n\nvoid strpool_term( strpool_t* pool )\n    {\n#if 0\n    // Debug statistics\n    printf( \"\\n\\n\" );\n    printf( \"Handles: %d/%d\\n\", pool->handle_count, pool->handle_capacity );\n    printf( \"Entries: %d/%d\\n\", pool->entry_count, pool->entry_capacity );\n    printf( \"Hashtable: %d/%d\\n\", pool->entry_count, pool->hash_capacity );\n    printf( \"Blocks: %d/%d\\n\", pool->block_count, pool->block_capacity );\n    for( int i = 0; i < pool->block_count; ++i )\n        {\n        printf( \"\\n\" );\n        printf( \"BLOCK: %d\\n\", i );\n        printf( \"Capacity: %d\\n\", pool->blocks[ i ].capacity );\n        printf( \"Free: [ %d ]\", (int)( pool->blocks[ i ].capacity - ( pool->blocks[ i ].tail - pool->blocks[ i ].data ) ) );\n        int fl = pool->blocks[ i ].free_list;\n        int count = 0;\n        int size = 0;\n        int total = 0;\n        while( fl >= 0 )\n            {\n            strpool_internal_free_block_t* free_entry = (strpool_internal_free_block_t*) ( pool->blocks[ i ].data + fl );\n            total += free_entry->size;\n            if( size == 0 ) { size = free_entry->size; }\n            if( size != free_entry->size )\n                {\n                printf( \", %dx%d\", count, size );\n                count = 1;\n                size = free_entry->size;\n                }\n            else\n                {\n                ++count;\n                }\n            fl = free_entry->next;\n            }\n        if( size != 0 ) printf( \", %dx%d\", count, size );\n        printf( \", { %d }\\n\", total );\n        }\n    printf( \"\\n\\n\" );\n#endif\n\n    for( int i = 0; i < pool->block_count; ++i ) STRPOOL_FREE( pool->memctx, pool->blocks[ i ].data );\n    STRPOOL_FREE( pool->memctx, pool->blocks );         \n    STRPOOL_FREE( pool->memctx, pool->handles );            \n    STRPOOL_FREE( pool->memctx, pool->entries );            \n    STRPOOL_FREE( pool->memctx, pool->hash_table );         \n    }\n\n\nvoid strpool_defrag( strpool_t* pool )\n    {\n    int data_size = 0;\n    int count = 0;\n    for( int i = 0; i < pool->entry_count; ++i )\n        {\n        strpool_internal_entry_t* entry = &pool->entries[ i ];\n        if( entry->refcount > 0 )\n            {\n            data_size += entry->size;\n            ++count;\n            }\n        }\n\n    int data_capacity = data_size < pool->block_size ? \n        pool->block_size : (int)strpool_internal_pow2ceil( (STRPOOL_U32)data_size );\n\n    int hash_capacity = count + count / 2;\n    hash_capacity = hash_capacity < ( pool->initial_entry_capacity * 2 ) ? \n        ( pool->initial_entry_capacity * 2 ) : (int)strpool_internal_pow2ceil( (STRPOOL_U32)hash_capacity );\n    strpool_internal_hash_slot_t* hash_table = (strpool_internal_hash_slot_t*) STRPOOL_MALLOC( pool->memctx, \n        hash_capacity * sizeof( *hash_table ) );\n    STRPOOL_ASSERT( hash_table, \"Allocation failed\" );\n    STRPOOL_MEMSET( hash_table, 0, hash_capacity * sizeof( *hash_table ) );\n\n    char* data = (char*) STRPOOL_MALLOC( pool->memctx, (size_t) data_capacity );\n    STRPOOL_ASSERT( data, \"Allocation failed\" );\n    int capacity = count < pool->initial_entry_capacity ? \n        pool->initial_entry_capacity : (int)strpool_internal_pow2ceil( (STRPOOL_U32)count );\n    strpool_internal_entry_t* entries = (strpool_internal_entry_t*) STRPOOL_MALLOC( pool->memctx, \n        capacity * sizeof( *entries ) );\n    STRPOOL_ASSERT( entries, \"Allocation failed\" );\n    int index = 0;\n    char* tail = data;\n    for( int i = 0; i < pool->entry_count; ++i )\n        {\n        strpool_internal_entry_t* entry = &pool->entries[ i ];\n        if( entry->refcount > 0 )\n            {\n            entries[ index ] = *entry;\n\n            STRPOOL_U32 hash = pool->hash_table[ entry->hash_slot ].hash_key;\n            int base_slot = (int)( hash & (STRPOOL_U32)( hash_capacity - 1 ) );\n            int slot = base_slot;\n            while( hash_table[ slot ].hash_key )\n                slot = (slot + 1 ) & ( hash_capacity - 1 );\n            STRPOOL_ASSERT( hash, \"Invalid hash\" );\n            hash_table[ slot ].hash_key = hash;\n            hash_table[ slot ].entry_index = index;\n            ++hash_table[ base_slot ].base_count;\n\n            entries[ index ].hash_slot = slot;\n            entries[ index ].data = tail;\n            entries[ index ].handle_index = entry->handle_index;\n            pool->handles[ entry->handle_index ].entry_index = index;\n            STRPOOL_MEMCPY( tail, entry->data, entry->length + 1 + 2 * sizeof( STRPOOL_U32 ) );\n            tail += entry->size;\n            ++index;\n            }\n        }\n\n\n    STRPOOL_FREE( pool->memctx, pool->hash_table );\n    STRPOOL_FREE( pool->memctx, pool->entries );\n    for( int i = 0; i < pool->block_count; ++i ) STRPOOL_FREE( pool->memctx, pool->blocks[ i ].data );\n\n    if( pool->block_capacity != pool->initial_block_capacity )\n        {\n        STRPOOL_FREE( pool->memctx, pool->blocks );\n        pool->blocks = (strpool_internal_block_t*) STRPOOL_MALLOC( pool->memctx, \n            pool->initial_block_capacity * sizeof( *pool->blocks ) );\n        STRPOOL_ASSERT( pool->blocks, \"Allocation failed\" );\n        }\n    pool->block_capacity = pool->initial_block_capacity;\n    pool->block_count = 1;\n    pool->current_block = 0;\n    pool->blocks[ 0 ].capacity = data_capacity;\n    pool->blocks[ 0 ].data = data;\n    pool->blocks[ 0 ].tail = tail;\n    pool->blocks[ 0 ].free_list = -1;\n    \n    pool->hash_table = hash_table;\n    pool->hash_capacity = hash_capacity;\n\n    pool->entries = entries;\n    pool->entry_capacity = capacity;\n    pool->entry_count = count;\n    }\n\n\nstatic STRPOOL_U64 strpool_internal_make_handle( int index, int counter, STRPOOL_U64 index_mask, int counter_shift, \n    STRPOOL_U64 counter_mask )\n    {\n    STRPOOL_U64 i = (STRPOOL_U64) ( index + 1 );\n    STRPOOL_U64 c = (STRPOOL_U64) counter;\n    return ( ( c & counter_mask ) << counter_shift ) | ( i & index_mask );\n    }\n\n\nstatic int strpool_internal_counter_from_handle( STRPOOL_U64 handle, int counter_shift, STRPOOL_U64 counter_mask  )\n    {\n    return (int) ( ( handle >> counter_shift ) & counter_mask ) ;\n    }\n    \n\nstatic int strpool_internal_index_from_handle( STRPOOL_U64 handle, STRPOOL_U64 index_mask )\n    {\n    return ( (int) ( handle & index_mask ) ) - 1;\n    }\n\n\nstatic strpool_internal_entry_t* strpool_internal_get_entry( strpool_t const* pool, STRPOOL_U64 handle )\n    {\n    int index = strpool_internal_index_from_handle( handle, pool->index_mask );\n    int counter = strpool_internal_counter_from_handle( handle, pool->counter_shift, pool->counter_mask );\n\n    if( index >= 0 && index < pool->handle_count && \n        counter == (int) ( pool->handles[ index ].counter & pool->counter_mask ) )\n            return &pool->entries[ pool->handles[ index ].entry_index ];\n\n    return 0;\n    }\n\n\nstatic STRPOOL_U32 strpool_internal_find_in_blocks( strpool_t const* pool, char const* string, int length )\n    {\n    for( int i = 0; i < pool->block_count; ++i )\n        {\n        strpool_internal_block_t* block = &pool->blocks[ i ];\n        // Check if string comes from pool\n        if( string >= block->data + 2 * sizeof( STRPOOL_U32 ) && string < block->data + block->capacity ) \n            {\n            STRPOOL_U32* ptr = (STRPOOL_U32*) string;\n            int stored_length = (int)( *( ptr - 1 ) ); // Length is stored immediately before string\n            if( stored_length != length || string[ length ] != '\\0' ) return 0; // Invalid string\n            STRPOOL_U32 hash = *( ptr - 2 ); // Hash is stored before the length field\n            return hash;\n            }\n        }\n\n    return 0;\n    }\n\n\nstatic STRPOOL_U32 strpool_internal_calculate_hash( char const* string, int length, int ignore_case )\n    {\n    STRPOOL_U32 hash = 5381U; \n\n    if( ignore_case) \n        {\n        for( int i = 0; i < length; ++i )\n            {\n            char c = string[ i ];\n            c = ( c <= 'z' && c >= 'a' ) ? c - ( 'a' - 'A' ) : c;\n            hash = ( ( hash << 5U ) + hash) ^ c;\n            }\n        }\n    else\n        {\n        for( int i = 0; i < length; ++i )\n            {\n            char c = string[ i ];\n            hash = ( ( hash << 5U ) + hash) ^ c;\n            }\n        }\n\n    hash = ( hash == 0 ) ? 1 : hash; // We can't allow 0-value hash keys, but dupes are ok\n    return hash;\n    }\n\n\nstatic void strpool_internal_expand_hash_table( strpool_t* pool )\n    {\n    int old_capacity = pool->hash_capacity;\n    strpool_internal_hash_slot_t* old_table = pool->hash_table;\n\n    pool->hash_capacity *= 2;\n\n    pool->hash_table = (strpool_internal_hash_slot_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->hash_capacity * sizeof( *pool->hash_table ) );\n    STRPOOL_ASSERT( pool->hash_table, \"Allocation failed\" );\n    STRPOOL_MEMSET( pool->hash_table, 0, pool->hash_capacity * sizeof( *pool->hash_table ) );\n\n    for( int i = 0; i < old_capacity; ++i )\n        {\n        STRPOOL_U32 hash_key = old_table[ i ].hash_key;\n        if( hash_key )\n            {\n            int base_slot = (int)( hash_key & (STRPOOL_U32)( pool->hash_capacity - 1 ) );\n            int slot = base_slot;\n            while( pool->hash_table[ slot ].hash_key )\n                slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n            STRPOOL_ASSERT( hash_key, \"Invalid hash\" );\n            pool->hash_table[ slot ].hash_key = hash_key;\n            pool->hash_table[ slot ].entry_index = old_table[ i ].entry_index;  \n            pool->entries[ pool->hash_table[ slot ].entry_index ].hash_slot = slot; \n            ++pool->hash_table[ base_slot ].base_count;\n            }               \n        }\n\n    STRPOOL_FREE( pool->memctx, old_table );\n    }\n\n\nstatic void strpool_internal_expand_entries( strpool_t* pool )\n    {\n    pool->entry_capacity *= 2;\n    strpool_internal_entry_t* new_entries = (strpool_internal_entry_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->entry_capacity * sizeof( *pool->entries ) );\n    STRPOOL_ASSERT( new_entries, \"Allocation failed\" );\n    STRPOOL_MEMCPY( new_entries, pool->entries, pool->entry_count * sizeof( *pool->entries ) );\n    STRPOOL_FREE( pool->memctx, pool->entries );\n    pool->entries = new_entries;    \n    }\n\n\nstatic void strpool_internal_expand_handles( strpool_t* pool )\n    {\n    pool->handle_capacity *= 2;\n    strpool_internal_handle_t* new_handles = (strpool_internal_handle_t*) STRPOOL_MALLOC( pool->memctx, \n        pool->handle_capacity * sizeof( *pool->handles ) );\n    STRPOOL_ASSERT( new_handles, \"Allocation failed\" );\n    STRPOOL_MEMCPY( new_handles, pool->handles, pool->handle_count * sizeof( *pool->handles ) );\n    STRPOOL_FREE( pool->memctx, pool->handles );\n    pool->handles = new_handles;\n    }\n\n\nstatic char* strpool_internal_get_data_storage( strpool_t* pool, int size, int* alloc_size )\n    {\n    if( size < sizeof( strpool_internal_free_block_t ) ) size = sizeof( strpool_internal_free_block_t );\n    if( size < pool->min_data_size ) size = pool->min_data_size;\n    size = (int)strpool_internal_pow2ceil( (STRPOOL_U32)size );\n    \n    // Try to find a large enough free slot in existing blocks\n    for( int i = 0; i < pool->block_count; ++i )\n        {\n        int free_list = pool->blocks[ i ].free_list;\n        int prev_list = -1;\n        while( free_list >= 0 )\n            {\n            strpool_internal_free_block_t* free_entry = \n                (strpool_internal_free_block_t*) ( pool->blocks[ i ].data + free_list );\n            if( free_entry->size / 2 < size ) \n                {\n                // At this point, all remaining slots are too small, so bail out if the current slot is not large enough\n                if( free_entry->size < size ) break; \n\n                if( prev_list < 0 )\n                    {\n                    pool->blocks[ i ].free_list = free_entry->next;         \n                    }\n                else\n                    {\n                    strpool_internal_free_block_t* prev_entry = \n                        (strpool_internal_free_block_t*) ( pool->blocks[ i ].data + prev_list );\n                    prev_entry->next = free_entry->next;\n                    }\n                *alloc_size = free_entry->size;\n                return (char*) free_entry;\n                }\n            prev_list = free_list;\n            free_list = free_entry->next;\n            }\n        }\n\n    // Use current block, if enough space left\n    int offset = (int) ( pool->blocks[ pool->current_block ].tail - pool->blocks[ pool->current_block ].data );\n    if( size <= pool->blocks[ pool->current_block ].capacity - offset )\n        {\n        char* data = pool->blocks[ pool->current_block ].tail;\n        pool->blocks[ pool->current_block ].tail += size;\n        *alloc_size = size;\n        return data;\n        }\n\n    // Allocate a new block\n    pool->current_block = strpool_internal_add_block( pool, size > pool->block_size ? size : pool->block_size );\n    char* data = pool->blocks[ pool->current_block ].tail;\n    pool->blocks[ pool->current_block ].tail += size;\n    *alloc_size = size;\n    return data;\n    }\n    \n\nSTRPOOL_U64 strpool_inject( strpool_t* pool, char const* string, int length )\n    {\n    if( !string || length <= 0 ) return 0;\n\n    STRPOOL_U32 hash = strpool_internal_find_in_blocks( pool, string, length );\n    // If no stored hash, calculate it from data\n    if( !hash ) hash = strpool_internal_calculate_hash( string, length, pool->ignore_case ); \n\n    // Return handle to existing string, if it is already in pool\n    int base_slot = (int)( hash & (STRPOOL_U32)( pool->hash_capacity - 1 ) );\n    int base_count = pool->hash_table[ base_slot ].base_count;\n    int slot = base_slot;\n    int first_free = slot;\n    while( base_count > 0 )\n        {\n        STRPOOL_U32 slot_hash = pool->hash_table[ slot ].hash_key;\n        if( slot_hash == 0 && pool->hash_table[ first_free ].hash_key != 0 ) first_free = slot;\n        int slot_base = (int)( slot_hash & (STRPOOL_U32)( pool->hash_capacity - 1 ) );\n        if( slot_base == base_slot ) \n            {\n            STRPOOL_ASSERT( base_count > 0, \"Invalid base count\" );\n            --base_count;\n            if( slot_hash == hash )\n                {\n                int index = pool->hash_table[ slot ].entry_index;\n                strpool_internal_entry_t* entry = &pool->entries[ index ];\n                if( entry->length == length && \n                    ( \n                       ( !pool->ignore_case &&   STRPOOL_MEMCMP( entry->data + 2 * sizeof( STRPOOL_U32 ), string, (size_t)length ) == 0 )\n                    || (  pool->ignore_case && STRPOOL_STRNICMP( entry->data + 2 * sizeof( STRPOOL_U32 ), string, (size_t)length ) == 0 ) \n                    ) \n                  )\n                    {\n                    int handle_index = entry->handle_index;\n                    return strpool_internal_make_handle( handle_index, pool->handles[ handle_index ].counter, \n                        pool->index_mask, pool->counter_shift, pool->counter_mask );\n                    }\n                }\n            }\n        slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n        }   \n\n    // This is a new string, so let's add it\n\n    if( pool->entry_count >= ( pool->hash_capacity  - pool->hash_capacity / 3 ) )\n        {\n        strpool_internal_expand_hash_table( pool );\n\n        base_slot = (int)( hash & (STRPOOL_U32)( pool->hash_capacity - 1 ) );\n        slot = base_slot;\n        first_free = slot;\n        while( base_count )\n            {\n            STRPOOL_U32 slot_hash = pool->hash_table[ slot ].hash_key;\n            if( slot_hash == 0 && pool->hash_table[ first_free ].hash_key != 0 ) first_free = slot;\n            int slot_base = (int)( slot_hash & (STRPOOL_U32)( pool->hash_capacity - 1 ) );\n            if( slot_base == base_slot )  --base_count;\n            slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n            }       \n        }\n        \n    slot = first_free;\n    while( pool->hash_table[ slot ].hash_key )\n        slot = ( slot + 1 ) & ( pool->hash_capacity - 1 );\n\n    if( pool->entry_count >= pool->entry_capacity )\n        strpool_internal_expand_entries( pool );\n\n    STRPOOL_ASSERT( !pool->hash_table[ slot ].hash_key && ( hash & ( (STRPOOL_U32) pool->hash_capacity - 1 ) ) == (STRPOOL_U32) base_slot, \"Invalid slot\" );\n    STRPOOL_ASSERT( hash, \"Invalid hash\" );\n    pool->hash_table[ slot ].hash_key = hash;\n    pool->hash_table[ slot ].entry_index = pool->entry_count;\n    ++pool->hash_table[ base_slot ].base_count;\n\n    int handle_index;\n\n    if( pool->handle_count < pool->handle_capacity )\n        {\n        handle_index = pool->handle_count;\n        pool->handles[ pool->handle_count ].counter = 1;\n        ++pool->handle_count;           \n        }\n    else if( pool->handle_freelist_head >= 0 )\n        {\n        handle_index = pool->handle_freelist_head;\n        if( pool->handle_freelist_tail == pool->handle_freelist_head ) \n            pool->handle_freelist_tail = pool->handles[ pool->handle_freelist_head ].entry_index;\n        pool->handle_freelist_head = pool->handles[ pool->handle_freelist_head ].entry_index;                       \n        }\n    else\n        {\n        strpool_internal_expand_handles( pool );\n        handle_index = pool->handle_count;\n        pool->handles[ pool->handle_count ].counter = 1;\n        ++pool->handle_count;           \n        }\n\n    pool->handles[ handle_index ].entry_index = pool->entry_count;\n        \n    strpool_internal_entry_t* entry = &pool->entries[ pool->entry_count ];\n    ++pool->entry_count;\n        \n    int data_size = length + 1 + (int) ( 2 * sizeof( STRPOOL_U32 ) );\n    char* data = strpool_internal_get_data_storage( pool, data_size, &data_size );\n    entry->hash_slot = slot;\n    entry->handle_index = handle_index;\n    entry->data = data;\n    entry->size = data_size;\n    entry->length = length;\n    entry->refcount = 0;\n\n    *(STRPOOL_U32*)(data) = hash;\n    data += sizeof( STRPOOL_U32 );\n    *(STRPOOL_U32*)(data) = (STRPOOL_U32) length;\n    data += sizeof( STRPOOL_U32 );\n    STRPOOL_MEMCPY( data, string, (size_t) length ); \n    data[ length ] = 0; // Ensure trailing zero\n\n    return strpool_internal_make_handle( handle_index, pool->handles[ handle_index ].counter, pool->index_mask, \n        pool->counter_shift, pool->counter_mask );\n    }\n\n\nvoid strpool_discard( strpool_t* pool, STRPOOL_U64 handle )\n    {   \n    strpool_internal_entry_t* entry = strpool_internal_get_entry( pool, handle );\n    if( entry && entry->refcount == 0 )\n        {\n        int entry_index = pool->handles[ entry->handle_index ].entry_index;\n\n        // recycle string mem\n        for( int i = 0; i < pool->block_count; ++i )\n            {\n            strpool_internal_block_t* block = &pool->blocks[ i ];\n            if( entry->data >= block->data && entry->data <= block->tail )\n                {\n                if( block->free_list < 0 )\n                    {\n                    strpool_internal_free_block_t* new_entry = (strpool_internal_free_block_t*) ( entry->data );\n                    block->free_list = (int) ( entry->data - block->data );\n                    new_entry->next = -1;\n                    new_entry->size = entry->size;\n                    }\n                else\n                    {\n                    int free_list = block->free_list;\n                    int prev_list = -1;\n                    while( free_list >= 0 )\n                        {\n                        strpool_internal_free_block_t* free_entry = \n                            (strpool_internal_free_block_t*) ( pool->blocks[ i ].data + free_list );\n                        if( free_entry->size <= entry->size ) \n                            {\n                            strpool_internal_free_block_t* new_entry = (strpool_internal_free_block_t*) ( entry->data );\n                            if( prev_list < 0 )\n                                {\n                                new_entry->next = pool->blocks[ i ].free_list;\n                                pool->blocks[ i ].free_list = (int) ( entry->data - block->data );          \n                                }\n                            else\n                                {\n                                strpool_internal_free_block_t* prev_entry = \n                                    (strpool_internal_free_block_t*) ( pool->blocks[ i ].data + prev_list );\n                                prev_entry->next = (int) ( entry->data - block->data );\n                                new_entry->next = free_entry->next;\n                                }\n                            new_entry->size = entry->size;\n                            break;\n                            }\n                        prev_list = free_list;\n                        free_list = free_entry->next;\n                        }\n                    }\n                break;\n                }\n            }\n\n        // recycle handle\n        if( pool->handle_freelist_tail < 0 )\n            {\n            STRPOOL_ASSERT( pool->handle_freelist_head < 0, \"Freelist error\" );\n            pool->handle_freelist_head = entry->handle_index;\n            pool->handle_freelist_tail = entry->handle_index;\n            }\n        else\n            {\n            pool->handles[ pool->handle_freelist_tail ].entry_index = entry->handle_index;\n            pool->handle_freelist_tail = entry->handle_index;\n            }\n        ++pool->handles[ entry->handle_index ].counter; // invalidate handle via counter\n        pool->handles[ entry->handle_index ].entry_index = -1;\n\n        // recycle hash slot\n        STRPOOL_U32 hash = pool->hash_table[ entry->hash_slot ].hash_key;\n        int base_slot = (int)( hash & (STRPOOL_U32)( pool->hash_capacity - 1 ) );\n        STRPOOL_ASSERT( hash, \"Invalid hash\" );\n        --pool->hash_table[ base_slot ].base_count;\n        pool->hash_table[ entry->hash_slot ].hash_key = 0;\n\n        // recycle entry\n        if( entry_index != pool->entry_count - 1 )\n            {\n            pool->entries[ entry_index ] = pool->entries[ pool->entry_count - 1 ];\n            pool->hash_table[ pool->entries[ entry_index ].hash_slot ].entry_index = entry_index;\n            pool->handles[ pool->entries[ entry_index ].handle_index ].entry_index = entry_index;\n            }\n        --pool->entry_count;\n        }       \n\n    }\n\n\nint strpool_incref( strpool_t* pool, STRPOOL_U64 handle )\n    {\n    strpool_internal_entry_t* entry = strpool_internal_get_entry( pool, handle );\n    if( entry )\n        {\n        ++entry->refcount;\n        return entry->refcount;\n        }\n    return 0;\n    }\n\n\nint strpool_decref( strpool_t* pool, STRPOOL_U64 handle )\n    {\n    strpool_internal_entry_t* entry = strpool_internal_get_entry( pool, handle );\n    if( entry )\n        {\n        STRPOOL_ASSERT( entry->refcount > 0, \"Invalid ref count\" );\n        --entry->refcount;\n        return entry->refcount;\n        }\n    return 0;\n    }\n\n\nint strpool_getref( strpool_t* pool, STRPOOL_U64 handle )\n    {\n    strpool_internal_entry_t* entry = strpool_internal_get_entry( pool, handle );\n    if( entry ) return entry->refcount;\n    return 0;\n    }\n\n\nint strpool_isvalid( strpool_t const* pool, STRPOOL_U64 handle )\n    {\n    strpool_internal_entry_t const* entry = strpool_internal_get_entry( pool, handle );\n    if( entry ) return 1;\n    return 0;\n    }\n\n\nchar const* strpool_cstr( strpool_t const* pool, STRPOOL_U64 handle )\n    {\n    strpool_internal_entry_t const* entry = strpool_internal_get_entry( pool, handle );\n    if( entry ) return entry->data + 2 * sizeof( STRPOOL_U32 ); // Skip leading hash value\n    return NULL;\n    }\n\n\nint strpool_length( strpool_t const* pool, STRPOOL_U64 handle )\n    {\n    strpool_internal_entry_t const* entry = strpool_internal_get_entry( pool, handle );\n    if( entry ) return entry->length;\n    return 0;\n    }\n\n\nchar* strpool_collate( strpool_t const* pool, int* count )\n    {\n    int size = 0;\n    for( int i = 0; i < pool->entry_count; ++i ) size += pool->entries[ i ].length + 1;\n    if( size == 0 ) return NULL;\n\n    char* strings = (char*) STRPOOL_MALLOC( pool->memctx, (size_t) size );\n    STRPOOL_ASSERT( strings, \"Allocation failed\" );\n    *count = pool->entry_count;\n    char* ptr = strings;\n    for( int i = 0; i < pool->entry_count; ++i )\n        {\n        int len = pool->entries[ i ].length + 1;\n        char* src = pool->entries[ i ].data + 2 * sizeof( STRPOOL_U32 );\n        STRPOOL_MEMCPY( ptr, src, (size_t) len );\n        ptr += len;\n        }\n    return strings;\n    }\n\n\nvoid strpool_free_collated( strpool_t const* pool, char* collated_ptr )\n    {\n    (void) pool;\n    STRPOOL_FREE( pool->memctx, collated_ptr );\n    }\n\n\n#endif /* STRPOOL_IMPLEMENTATION */\n\n\n/*\nrevision history:\n    1.4     fixed find_in_blocks substring bug, removed realloc, added docs\n    1.3     fixed typo in mask bit shift\n    1.2     made it possible to override standard library functions\n    1.1     added is_valid function to query a handles validity\n    1.0     first released version  \n*/\n\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "sysfont.h",
          "type": "blob",
          "size": 27.4365234375,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nsysfont.h - v1.0 - Simple debug text renderer for C/C++.\n*/\n\n#ifndef sysfont_h\n#define sysfont_h\n\n#ifndef SYSFONT_U8\n\t#define SYSFONT_U8 unsigned char\n#endif\n#ifndef SYSFONT_U16\n\t#define SYSFONT_U16 unsigned short\n#endif\n#ifndef SYSFONT_U32\n\t#define SYSFONT_U32 unsigned int\n#endif\n\nvoid sysfont_9x16_u8( SYSFONT_U8* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U8  color );\nvoid sysfont_9x16_u16( SYSFONT_U16* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U16 color );\nvoid sysfont_9x16_u32( SYSFONT_U32* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U32 color );\n\nvoid sysfont_8x8_u8( SYSFONT_U8* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U8  color );\nvoid sysfont_8x8_u16( SYSFONT_U16* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U16 color );\nvoid sysfont_8x8_u32( SYSFONT_U32* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U32 color );\n\n#define SYSFONT_TEXWIDTH 256\n#define SYSFONT_TEXHEIGHT 256\n#define SYSFONT_TEX8X8OFS 160\nvoid sysfont_texture_u8( SYSFONT_U8* texture, int pitch_in_bytes, SYSFONT_U8 color, SYSFONT_U8 bgcolor );\nvoid sysfont_texture_u16( SYSFONT_U16* texture, int pitch_in_bytes, SYSFONT_U16 color, SYSFONT_U16 bgcolor );\nvoid sysfont_texture_u32( SYSFONT_U32* texture, int pitch_in_bytes, SYSFONT_U32 color, SYSFONT_U32 bgcolor );\n\n#endif /* sysfont_h */\n\n\n/*\n\nExamples:\n\n------------------------------------------------------------------------------\n\n\t#define SYSFONT_IMPLEMENTATION\n\t#include \"sysfont.h\"\n\n\t#define STB_IMAGE_WRITE_IMPLEMENTATION\n\t#include \"stb_image_write.h\"\n\n\tint main()\n\t\t{\n\t\tstatic unsigned tex[ SYSFONT_TEXWIDTH * SYSFONT_TEXHEIGHT ];\n\t\tsysfont_texture_u32( tex, SYSFONT_TEXWIDTH * sizeof( unsigned ),  0xffffffff, 0xff000000 );\n\t\tstbi_write_png( \"texture.png\", SYSFONT_TEXWIDTH, SYSFONT_TEXHEIGHT, 4, tex, SYSFONT_TEXWIDTH * 4 );\n\n\t\tstatic unsigned test[ 320 * 200 ];\n\t\tfor( int i = 0; i < 320 * 200; ++i ) test[ i ] = 0xff800000;\n\t\tsysfont_9x16_u32( test, 320, 200, 20, 40, \"A world can only take so much.\", 0xffff00ff );\n\t\tsysfont_8x8_u32( test, 320, 200, 30, 80, \"Testing the sysfont lib.\", 0xff00ffff );\n\t\tstbi_write_png( \"test.png\", 320, 200, 4, test, 320 * 4 );\n\t\n\t\treturn 0;\n\t\t}\n*/\n\n\n/*\n----------------------\n\tIMPLEMENTATION\n----------------------\n*/\n\n#ifdef SYSFONT_IMPLEMENTATION\n\n\n#define SYSFONT_DATA static SYSFONT_U32 sysfont_data[] = { \\\n0x00000000,0x00000000,0xfc00ff00,0x00000003,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xfc00ff00,0x00000003,0x80010000,0xc0000000,0x00000007,0x00000000,0x01f8fc00,0x00000000,0xfc00ff00,0x9f83c3c3,0xc003003f,0x6fe33060,0x180c000c,0x00000030,0x03fd0200,0x06030000,0xfc00ff00,0x99866383,0xe0070c31,0xcdb330f0,0x3c1e0000,0x00000030,0xb36d4a00,0x0f078081,0xfc00ff00,0x9f8662c3,0xf00f0c3f,0x8db331f8,0x7e3f0003,0x00000030,0xfbfd0200,0x1f8781c3,0x0c78ff00,0x81866263,0xf81f6db1,0xcdb33060,0x180c0006,0x00606030,0xfbfd0200,0x3fdce3e3,0x64cce70c,0x818660f2,0xfe7f1e31,0x6de33060,0x180c000c,0x0030c030,0xfb0d7a00,0x3fdce7f3,0xf484c31e,0x8183c19a,0xf81f73b1,0x6d833060,0x180c000c,0x03f9fc30,0xfb9d3200,0x1f9ce3e3,0xf484c31e,0x8181819a,0xf00f1e31,0xcd8331f8,0x183f1fc6,0x0030c030,0xf3fd0200,0x060301c1,0x64cce70c,0x81c7e19a,0xe0076db9,0x8d8000f0,0x181e1fc3,0x006060fc,0xe3fd0200,0x06030080,0x0c78ff00,0xc1e1819b,0xc0030c39,0x0d833060,0x180c1fc6,0x00000078,0x41f8fc00,0x0f078000,0xfc00ff00,0xc0e180f3,0x80010c19,0x6d833000,0x183f1fcc,0x00000030,0x00000000,0x00000000,0xfc00ff00,0xc0000003,0x00000000,0xc0000000,0x00000007,0x00000000,0x00000000,0x00000000,0xfc00ff00,0x00000003,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xfc00ff00,0x00000003,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xfc00ff00,0x00000003,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0x00000000,0x00000000,0x00001800,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x19800000,0x00001800,0x00000060,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x19830000,0x70003e00,0x01830060,0x00000000,0x03c00000,0x301f0f83,0x03f870fe,0x00000000,0x19878000,0xd800631b,0x03018060,0x00000000,0x86600000,0x383198c3,0x03181806,0xf8200000,0x09078003,0xd886431b,0x0600c030,0x00000000,0xcc320000,0x3c301803,0x03000c06,0xf8704800,0x80078003,0x70c6033f,0x8600c000,0x00000c19,0x0c330000,0x36300c03,0x03000c06,0xf070cc03,0x00030001,0xb8603e1b,0x0600c001,0x00000c0f,0x0db18000,0x331e0603,0x0180fc7e,0xf0f9fe03,0x00030001,0xec30601b,0xc600c000,0xfe003f3f,0x0db0c000,0x7f300303,0x00c18cc0,0xe0f8cc03,0x00030000,0xcc18601b,0x0600c000,0x00000c0f,0x0c306000,0x30300183,0x00618cc0,0xe1fc487f,0x80000000,0xcc0c613f,0x8600c000,0x00180c19,0x0c303000,0x303000c3,0x00618cc0,0x41fc0000,0x00030000,0xccc6631b,0x03018000,0x00180000,0x06601860,0x303198c3,0x00618cc6,0x00000000,0x00030000,0xb8c23e1b,0x01830001,0x00180000,0xc3c00860,0x781f1fcf,0x0060f87c,0x00000000,0x00000000,0x00001800,0x00000000,0x000c0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001800,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00007c3e,0x00000000,0xfc10001f,0xcfe1f1e0,0x78631e1f,0x60f339e0,0x3f1f18d8,0x01f0fc7c,0x0000c663,0x81800600,0x98383e31,0x8cc36331,0x30633319,0xe06330c0,0x663199dc,0x031998c6,0xc060c663,0x83000300,0x986c6331,0x88c66219,0x30632191,0xe06330c0,0x66319bdf,0x031998c6,0xc060c663,0x060fc180,0x98c66318,0x82c66019,0x30630185,0xe061b0c0,0x66319fdf,0x003198c6,0x0000fc3e,0x0c0000c0,0xf8c67b0c,0x83c66018,0x307f0187,0x6060f0c0,0x3e319edb,0x00e0f8c6,0x0000c063,0x18000060,0x98fe7b0c,0x82c66019,0x30633d85,0x6060f0c0,0x06319cd8,0x0180d8c6,0x0000c063,0x0c0fc0c0,0x98c67b0c,0x80c66019,0x30633181,0x6061b0cc,0x063198d8,0x030198c6,0xc060c063,0x06000180,0x98c63b00,0x88c66219,0x30633181,0x646330cc,0x063198d8,0x031998d6,0xc0606063,0x03000300,0x98c6030c,0x8cc36331,0x30633301,0x666330cc,0x063198d8,0x031998f6,0x60003c3e,0x01800600,0xfcc63e0c,0xcfe1f1e0,0x78632e03,0x67f33878,0x0f1f18d8,0x01f19c7c,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000060,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x000000e0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0x00000000,0x00000000,0x20000000,0x0000c000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x70000000,0x0000c000,0x00000000,0x00000000,0x00000000,0x00000000,0x1b0cc6ff,0x3fd86c36,0xd878001e,0xc0018000,0x00380001,0x00700070,0x1c039803,0x00000000,0x1b0cc6db,0x30d86c36,0x8c600106,0x80000001,0x00300001,0x006000d8,0x18031803,0x00000000,0x1b0cc699,0x18586666,0x00600306,0x80000000,0x00300001,0x00600098,0x18030000,0x00000000,0x1b0cc618,0x0c0cc3c6,0x00600706,0x83c00000,0x7c3c1f07,0x83637018,0x18331c03,0x01f0ecce,0x1b0cc618,0x06078186,0x00600e06,0x86000000,0xc636318d,0x06e1983c,0x181b1803,0x031999fe,0xdb0cc618,0x03030186,0x00601c06,0x87c00000,0xfe330199,0x06619818,0x180f1803,0x031999b6,0xdb0cc618,0x018303c6,0x00603806,0x86600000,0x06330199,0x06619818,0x180f1803,0x031999b6,0xf998c618,0x20c30667,0x00607006,0x86600000,0x06330199,0x06619818,0x181b1803,0x031999b6,0x30f0c618,0x30c30c33,0x00606006,0x86600000,0xc6333199,0x06619818,0x18331803,0x031999b6,0x30607c3c,0x3fc78c33,0x0078401e,0x8dc00000,0x7c6e1f0f,0x8671f03c,0x3c339807,0x01f199b6,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00018000,0x00001980,0x00000000,0x00000000,0x00000000,0x00000000,0x000007f8,0x00000000,0x00019800,0x00001980,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000f000,0x00000f00,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xc00040c0,0x08000700,0x00001800,0x00000000,0x00000080,0x00000000,0x81c18380,0x663c001b,0x8330e060,0x1c000d81,0x033030c6,0x00000000,0x000000c0,0x00000000,0xc30180c0,0x0066000e,0x0001b030,0x36000703,0x00006000,0x00000000,0x000000c0,0x00000000,0x030180c0,0x00430400,0x00000000,0x001e0000,0x00000000,0xf0ecdc3b,0xb0c663f1,0xfcc6c361,0x030180c1,0x66030e00,0xc1e0f0f8,0x3e330783,0x00e0f87c,0x19b86666,0xb0c660c3,0xccc66661,0x0e000070,0x66031b00,0x0301818c,0x63030c06,0x00c18cc6,0x31986666,0xb0c660c0,0x60c63c61,0x030180c0,0x66033180,0xc3e1f1fc,0x7f030f87,0x00c1fcfe,0xe0186666,0xb0c660c0,0x30c6186d,0x030180c0,0x66433180,0x6331980c,0x03330cc6,0x00c00c06,0x80186666,0x998660c1,0x18c63c6d,0x030180c0,0x66663180,0x6331980c,0x031e0cc6,0x00c00c06,0x18186666,0x8f0666c3,0x8cc6667f,0x030180c1,0x663c3f80,0x6331998c,0x63180cc6,0x00c18cc6,0xf03c7c3e,0x060dc381,0xfcfcc333,0x01c18381,0xdc300000,0xc6e370f8,0x3e301b8d,0x01e0f87c,0x00006006,0x00000000,0x00c00000,0x00000000,0x00600000,0x00000000,0x001e0000,0x00000000,0x00006006,0x00000000,0x00600000,0x00000000,0x003e0000,0x00000000,0x00000000,0x00000000,0x0000f00f,0x00000000,0x003e0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0xe0000000,0x00000180,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x000000dc,0xb18c0c18,0x000000c1,0x300c0004,0xcc600030,0x001c0c18,0x018380fc,0x000c0606,0x00e0f076,0xe000183c,0x1f000060,0x7818630e,0x00063060,0x86360c00,0x00c6c199,0x6e060303,0x01b0d800,0x00203066,0x0d800000,0xcc30001b,0xc7c000c0,0xcc263f18,0x8060c198,0x3b030181,0x01b0d8c6,0xe0700000,0x0cc007f0,0x00000000,0xcc600000,0x78066198,0x0000c0f8,0x00000000,0x00e1f0ce,0xb0d8381c,0x0ccec661,0xcc7c3e1f,0xcc663198,0x300f0198,0x81e0c118,0x3b198f83,0x000000de,0x198c3018,0x9fdb8063,0xccc66331,0xcc663198,0xfe060198,0x0303f199,0x661998c3,0x01f1f8fe,0x198c3018,0x8cdb03e3,0xccc66331,0xcc663198,0x30060198,0x03e0c3d8,0x661998c3,0x000000f6,0xf9fc3018,0x8ccfc063,0xccc66331,0xcc663198,0xfe066198,0x0330c199,0x661998c3,0x000000e6,0x198c3018,0x8cc36063,0xccc66331,0xcc663198,0x30063f18,0x0330c198,0x661998c3,0x000000c6,0x198c3018,0x8cc76663,0xccc66331,0xcc663198,0x30670c18,0x0330c198,0x661998c3,0x000000c6,0x198c783c,0x1cddc7f3,0xb87c3e1f,0x87c7e371,0x303f0c0f,0x86e0c33c,0x66370f87,0x000000c6,0x00000000,0x00000000,0x00000000,0x00060000,0x00000000,0x0000d800,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00030000,0x00000000,0x00007000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001e000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0x00000000,0x00000000,0xef558800,0x030180c6,0xd800001b,0x86c001b0,0x1800060d,0x00c00030,0x18000000,0x00000030,0xb8aa2200,0x030180c7,0xd800001b,0x86c001b0,0x1800060d,0x00c00030,0x1800000c,0x00030030,0xef558800,0x030180c6,0xd800001b,0x86c001b0,0x1800060d,0x00c00030,0x1800000c,0x00030432,0xb8aa2200,0x030180c7,0xd800001b,0x86c001b0,0x1800060d,0x00c00030,0x18000000,0x00000633,0xef558800,0x030180c6,0xd800001b,0x86c001b0,0x1800060d,0x00c00030,0x9800000c,0x9b030331,0xb8aa220d,0x03e180c7,0xde1f001b,0x86f3f9b0,0x180007cd,0x00c00030,0xc1fcfe0c,0x0d830180,0xef55881b,0x030180c6,0xc018001b,0x860301b0,0x1800060d,0x00c00030,0x61800606,0x06c300c0,0xb8aa2236,0xc3e1f0c7,0xde1f3f9b,0xe7f379b0,0xf80f87cf,0x0fc7ffff,0x31800603,0x0d878660,0xef55881b,0x030180c6,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0x99800663,0x9b078733,0xb8aa220d,0x030180c7,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0xc9800663,0x00078696,0xef558800,0x030180c6,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0x0000003e,0x000307c3,0xb8aa2200,0x030180c7,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0x80000000,0x00000601,0xef558800,0x030180c6,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0xc0000000,0x00000607,0xb8aa2200,0x030180c7,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0x00000000,0x00000000,0xef558800,0x030180c6,0xd818361b,0x000361b0,0x000c0000,0x00c06000,0x00000000,0x00000000,0xb8aa2200,0x030180c7,0xd818361b,0x000361b0,0x000c0000,0x00c06000, \\\n0x60603000,0x1b0006c3,0xb0006c00,0x0006c0c1,0x00183600,0x01836000,0x00ff8003,0x0fffc01e,0x60603000,0x1b0006c3,0xb0006c00,0x0006c0c1,0x00183600,0x01836000,0x00ff8003,0x0fffc01e,0x60603000,0x1b0006c3,0xb0006c00,0x0006c0c1,0x00183600,0x01836000,0x00ff8003,0x0fffc01e,0x60603000,0x1b0006c3,0xb0006c00,0x0006c0c1,0x00183600,0x01836000,0x00ff8003,0x0fffc01e,0x60603000,0x1b0006c3,0xb0006c00,0x0006c0c1,0x00183600,0x01836000,0x00ff8003,0x0fffc01e,0x67e03000,0xfbff9ec3,0xbfffecff,0x3fe6cfff,0xf1f83600,0x1ff36003,0x00ff8003,0x0fffc01e,0x60603000,0x000180c3,0x00000c00,0x0006c000,0x30183600,0x01836000,0x00ff8003,0x0fffc01e,0x67e3ffff,0xfffd9fcf,0xbfffecf7,0xffffffff,0xf1f8fe7f,0xfffffff3,0xfffffe03,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f,0x60603000,0x000d8003,0xb0006c36,0x03000001,0x3000001b,0x018361b0,0xffff8600,0x0007c01f, \\\n0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000003,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x1c000003,0x07800000,0x01fc3c00,0x00000000,0x70000000,0x000003c0,0x0000000e,0x07000000,0x36000003,0x01800000,0x018c6600,0x000007f0,0xd8387e00,0x18000060,0x00001f03,0x0d818030,0x36000003,0x01800000,0xf98c6600,0x19800633,0x8c6c1837,0x8c0000c1,0x307f3181,0x0d80c060,0x1c000603,0x01800000,0xb00c666e,0x998fc061,0x8cc63c1d,0x8fc7e181,0x30003181,0x018060c0,0x00370603,0x01800000,0xb00c363b,0x198360c1,0x8cc6660c,0x9b6db3e1,0xfc00318f,0x01803180,0x001d8003,0x01800000,0xb00c661b,0x19836181,0xd8fe660c,0x9b6db330,0x307f3181,0x018060c0,0x00001f83,0x01b80030,0xb00cc61b,0x198360c1,0xd8c6660c,0x99edb330,0x30003181,0x6180c060,0x00370003,0x01b06030,0xb00cc61b,0x0f836061,0xd8c63c0c,0x8fc7e330,0x00003181,0x61818030,0x001d8603,0x01b00000,0xb00cc63b,0x01836631,0xd86c180c,0x00c00330,0x007f3183,0x61800000,0x00000603,0x01e00000,0xb00c666e,0x0181c7f1,0xdc387e0c,0x006001e1,0xfe00318e,0xc183f1f9,0x00000001,0x01c00000,0x00000000,0x00c00000,0x00000000,0x00000000,0x00000000,0x01800000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01800000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01800000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01800000,0x00000000,0x00000000, \\\n0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001c1b,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00003636,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001836,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f80c36,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f82636,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f83e36,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f80000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f80000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f80000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00f80000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000, \\\n0x367e7e00,0x00081c08,0xf0ff00ff,0x18fefc3c,0x66184001,0x18007cfe,0x00001818,0x00000000,0x7fff8100,0x00083e1c,0xe0c33cff,0xdbc6cc66,0x663c7007,0x3c00c6db,0x0c18183c,0xff182400,0x7fdba500,0x181c1c3e,0xf09966e7,0x3cfefc66,0x667e7c1f,0x7e001cdb,0x0630187e,0xff3c6603,0x7fff8100,0x3c3e7f7f,0xbebd42c3,0xe7c60c66,0x66187f7f,0x180036de,0x7f7f1818,0x7e7eff03,0x3ec3bd00,0x3c7f7f3e,0x33bd42c3,0xe7c60c3c,0x66187c1f,0x7e7e36d8,0x06307e18,0x3cff6603,0x1ce79900,0x183e6b1c,0x339966e7,0x3ce60e18,0x007e7007,0x3c7e1cd8,0x0c183c18,0x18ff247f,0x08ff8100,0x00080808,0x33c33cff,0xdb670f7e,0x663c4001,0x187e33d8,0x00001818,0x00000000,0x007e7e00,0x001c1c00,0x1eff00ff,0x18030718,0x00180000,0xff001e00,0x00000000,0x00000000,0x36360c00,0x061c000c,0x00000618,0x60000000,0x1e1e0c3e,0x3f1c3f38,0x00001e1e,0x1e060018,0x36361e00,0x0636633e,0x0c660c0c,0x30000000,0x33330e63,0x3306033c,0x0c0c3333,0x330c000c,0x7f361e00,0x031c3303,0x0c3c1806,0x18000000,0x30300c73,0x30031f36,0x0c0c3333,0x30183f06,0x36000c00,0x006e181e,0x3fff1806,0x0c003f00,0x1c1c0c7b,0x181f3033,0x00003e1e,0x18300003,0x7f000c00,0x003b0c30,0x0c3c1806,0x06000000,0x30060c6f,0x0c33307f,0x00003033,0x0c180006,0x36000000,0x0033661f,0x0c660c0c,0x030c000c,0x33330c67,0x0c333330,0x0c0c1833,0x000c3f0c,0x36000c00,0x006e630c,0x00000618,0x010c000c,0x1e3f3f3e,0x0c1e1e78,0x0c0c0e1e,0x0c060018,0x00000000,0x00000000,0x00000000,0x00000006,0x00000000,0x00000000,0x06000000,0x00000000, \\\n0x3c3f0c3e,0x3c7f7f1f,0x67781e33,0x1c63630f,0x1e3f1e3f,0x6333333f,0x1e7f3363,0x00081e03,0x66661e63,0x66464636,0x66300c33,0x36677706,0x33663366,0x6333332d,0x06633363,0x001c1806,0x0366337b,0x03161666,0x36300c33,0x636f7f06,0x06663366,0x6333330c,0x06313336,0x0036180c,0x033e337b,0x031e1e66,0x1e300c3f,0x637b7f06,0x0c3e333e,0x6b33330c,0x06181e1c,0x00631818,0x03663f7b,0x73161666,0x36330c33,0x63736b46,0x18363b06,0x7f33330c,0x064c0c1c,0x00001830,0x66663303,0x66064636,0x66330c33,0x36636366,0x33661e06,0x771e330c,0x06660c36,0x00001860,0x3c3f331e,0x7c0f7f1f,0x671e1e33,0x1c63637f,0x1e67380f,0x630c3f1e,0x1e7f1e63,0x00001e40,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xff000000,0x0007000c,0x001c0038,0x07300c07,0x0000000e,0x00000000,0x00000008,0x38000000,0x006e0718,0x0006000c,0x00360030,0x06000006,0x0000000c,0x00000000,0x0000000c,0x0c000000,0x083b0c18,0x1e061e18,0x6e061e30,0x66300e36,0x1e1f330c,0x3e3b6e3b,0x6333333e,0x0c3f3363,0x1c000c18,0x333e3000,0x330f333e,0x36300c6e,0x33337f0c,0x036e3366,0x6b33330c,0x07193336,0x36003800,0x03663e00,0x33063f33,0x1e300c66,0x33337f0c,0x1e663366,0x7f33330c,0x0c0c331c,0x63000c18,0x33663300,0x3e060333,0x36330c66,0x33336b0c,0x30063e3e,0x7f1e332c,0x0c263e36,0x63000c18,0x1e3b6e00,0x300f1e6e,0x67331e67,0x1e33631e,0x1f0f3006,0x360c6e18,0x383f3063,0x7f000718,0x00000000,0x1f000000,0x001e0000,0x00000000,0x0000780f,0x00000000,0x00001f00,0x00000000, \\\n0x7e38001e,0x000c0733,0x3307337e,0x0c63073e,0x1e7c0038,0x001e0000,0x1833c300,0x701f331c,0xc3003333,0x000c0000,0x000000c3,0x0c1c0063,0x33360000,0x07330733,0x18001833,0xd8333336,0x3c1e0003,0x1e1e1e1e,0x0e1e1e3c,0x00360e1c,0x0033fe3f,0x00000000,0x7e333c00,0x18331e26,0x60333333,0x03303030,0x0c333366,0x1e630c18,0x1e7f3006,0x33331e1e,0x03336633,0x3c5f3f0f,0x7c3f331e,0x033e3e3e,0x0c3f3f7e,0x337f0c18,0x3333fe1e,0x33333333,0x03336633,0x18630c06,0x66033318,0x1e333333,0x0c030306,0x3f630c18,0x33333306,0x33333333,0x7e333c3e,0x18f33f67,0xfc1e7e30,0x307e7e7e,0x1e1e1e3c,0x33631e3c,0x1e73fe3f,0x7e7e1e1e,0x181e1830,0x1b630c3f,0x0000001e,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x1800001f,0x0ee30c00,0x00001c38,0x1c3c3f00,0xc300000c,0x000018c3,0x18dbaa44,0x006c1818,0x006c6c00,0x00186c6c,0x38380000,0x3636001f,0x63000000,0x33cc1863,0x18ee5511,0x006c1818,0x006c6c00,0x00186c6c,0x00000e1e,0x36363300,0x3300000c,0x66660033,0x18dbaa44,0x006c1f18,0x7f6c6f1f,0x001f6c6f,0x331e0c30,0x1c7c371f,0x7b3f3f06,0xcc3318db,0x18775511,0x006c1818,0x606c6018,0x00186c60,0x33330c3e,0x00003f33,0xcc300303,0x666618ec,0x18dbaa44,0x7f6f1f1f,0x6f6c6f1f,0x1f1f7f7f,0x33330c33,0x3e7e3b33,0x66300333,0x33cc18f6,0x18ee5511,0x6c6c1818,0x6c6c6c18,0x18000000,0x7e1e1e7e,0x00003333,0x3300001e,0x000018f3,0x18dbaa44,0x6c6c1818,0x6c6c6c18,0x18000000,0x00000000,0x00000000,0xf0000000,0x000000c0,0x18775511,0x6c6c1818,0x6c6c6c18,0x18000000, \\\n0x18001818,0x6c181800,0x006c006c,0x186c006c,0x6c00006c,0x6c000018,0xff001818,0xfff00f00,0x18001818,0x6c181800,0x006c006c,0x186c006c,0x6c00006c,0x6c000018,0xff001818,0xfff00f00,0x18001818,0x6cf81800,0xffeffcec,0xffefffec,0x6c00ff6c,0x6c00f8f8,0xff0018ff,0xfff00f00,0x18001818,0x6c181800,0x00000c0c,0x0000000c,0x6c00006c,0x6c001818,0xff001818,0xfff00f00,0xf8fffff8,0xecf8ffff,0xefffecfc,0xffefffec,0xfcffffff,0xfffcf8f8,0xfff81fff,0x00f00fff,0x18180000,0x6c181800,0x6c006c00,0x006c006c,0x006c1800,0x6c6c1800,0xff180018,0x00f00fff,0x18180000,0x6c181800,0x6c006c00,0x006c006c,0x006c1800,0x6c6c1800,0xff180018,0x00f00fff,0x18180000,0x6c181800,0x6c006c00,0x006c006c,0x006c1800,0x6c6c1800,0xff180018,0x00f00fff,0x00000000,0x0000003f,0x381c1c3f,0x1e1c6000,0x18060c00,0x000c1870,0xf000001c,0x00000e1e,0x7f3f1e00,0x6e660033,0x0c36360c,0x33063000,0x0c0c0c3f,0x6e0c18d8,0x30000036,0x00001836,0x3633336e,0x3b667e06,0x1863631e,0x33037e7e,0x06183f00,0x3b0018d8,0x30000036,0x003c0c36,0x36031f3b,0x18661b0c,0x3e637f33,0x331fdbdb,0x0c0c0c3f,0x003f1818,0x3000181c,0x003c0636,0x36033313,0x18661b06,0x33366333,0x3303dbdb,0x18060c00,0x6e001818,0x37181800,0x003c1e36,0x36031f3b,0x183e1b33,0x3336361e,0x33067e7e,0x0000003f,0x3b0c1b18,0x36000000,0x003c0000,0x3603036e,0x18060e3f,0x1e771c0c,0x331c0600,0x3f3f3f00,0x000c1b18,0x3c000000,0x00000000,0x00000300,0x00030000,0x0000003f,0x00000300,0x00000000,0x00000e18,0x38000000,0x00000000, \\\n};\t\n\n\n#define SYSFONT_DRAW( T, M, W, H, O ) \\\n\tSYSFONT_DATA \\\n\tif( !text || !pixels ) return; \\\n\tchar const* str = text; \\\n\tSYSFONT_U32* const data = sysfont_data; \\\n\tint px = x; \\\n\twhile( *str ) \\\n\t\t{ \\\n\t\tSYSFONT_U8 c = (SYSFONT_U8) *str++; \\\n\t\tint sx = ( c % M ) * W; \\\n\t\tint sy = ( c / M ) * H + O; \\\n\t\tint dx = px; \\\n\t\tint dy = y; \\\n\t\tfor( int iy = 0; iy < H; ++iy ) \\\n\t\t\t{ \\\n\t\t\tfor( int ix = 0; ix < W; ++ix ) \\\n\t\t\t\t{ \\\n\t\t\t\tint v = ( sx + ix ) / 32; \\\n\t\t\t\tint u = ( sx + ix ) - ( v * 32 ); \\\n\t\t\t\tSYSFONT_U32 b = data[ v + ( sy + iy ) * 8 ]; \\\n\t\t\t\tif( b & ( 1 << u ) ) \\\n\t\t\t\t\t{ \\\n\t\t\t\t\tint xp = dx + ix; \\\n\t\t\t\t\tint yp = dy + iy; \\\n\t\t\t\t\tif( xp >= 0 && xp < width && yp >= 0 && yp < height ) pixels[ xp + yp * width ] = color; \\\n\t\t\t\t\t} \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\tpx += W; \\\n\t\t}\n\n\n#define SYSFONT_TEX( T ) \\\n\tSYSFONT_DATA \\\n\tSYSFONT_U32* src = sysfont_data; \\\n\tT* row = texture; \\\n\tfor( int iy = 0; iy < 224; ++iy ) \\\n\t\t{ \\\n\t\tT* dst = row; \\\n\t\tfor( int ix = 0; ix < 256 / 32; ++ix ) \\\n\t\t\t{ \\\n\t\t\tSYSFONT_U32 b = *src++; \\\n\t\t\tfor( int i = 0; i < 32; ++i ) \\\n\t\t\t\t*dst++ = ( b & ( 1 << i ) ) ? color : bgcolor; \\\n\t\t\t} \\\n\t\trow = (T*) ( ( (SYSFONT_U8*) row ) + pitch_in_bytes ); \\\n\t\t} \\\n\tfor( int iy = 224; iy < 256; ++iy ) \\\n\t\t{ \\\n\t\tT* dst = row; \\\n\t\tfor( int ix = 0; ix < 256; ++ix ) \\\n\t\t\t*dst++ = bgcolor; \\\n\t\trow = (T*) ( ( (SYSFONT_U8*) row ) + pitch_in_bytes ); \\\n\t\t}\n\n\nvoid sysfont_9x16_u8( SYSFONT_U8* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U8 color ) \n\t{ \n\tSYSFONT_DRAW( SYSFONT_U8, 28, 9, 16, 0 ); \n\t}\n\n\nvoid sysfont_9x16_u16( SYSFONT_U16* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U16 color ) \n\t{ \n\tSYSFONT_DRAW( SYSFONT_U16, 28, 9, 16, 0 ); \n\t}\n\n\nvoid sysfont_9x16_u32( SYSFONT_U32* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U32 color ) \n\t{ \n\tSYSFONT_DRAW( SYSFONT_U32, 28, 9, 16, 0 ); \n\t}\n\n\nvoid sysfont_8x8_u8( SYSFONT_U8* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U8 color ) \n\t{ \n\tSYSFONT_DRAW( SYSFONT_U8, 32, 8, 8, 160 ); \n\t}\n\n\nvoid sysfont_8x8_u16( SYSFONT_U16* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U16 color ) \n\t{ \n\tSYSFONT_DRAW( SYSFONT_U16, 32, 8, 8, 160 ); \n\t}\n\n\nvoid sysfont_8x8_u32( SYSFONT_U32* pixels, int width, int height, int x, int y, char const* text, SYSFONT_U32 color ) \n\t{ \n\tSYSFONT_DRAW( SYSFONT_U32, 32, 8, 8, 160 ); \n\t}\n\n\nvoid sysfont_texture_u8( SYSFONT_U8* texture, int pitch_in_bytes, SYSFONT_U8 color, SYSFONT_U8 bgcolor ) \n\t{ \n\tSYSFONT_TEX(SYSFONT_U8); \n\t}\n\n\nvoid sysfont_texture_u16( SYSFONT_U16* texture, int pitch_in_bytes, SYSFONT_U16 color, SYSFONT_U16 bgcolor ) \n\t{ \n\tSYSFONT_TEX(SYSFONT_U16); \n\t}\n\n\nvoid sysfont_texture_u32( SYSFONT_U32* texture, int pitch_in_bytes, SYSFONT_U32 color, SYSFONT_U32 bgcolor ) \n\t{ \n\tSYSFONT_TEX(SYSFONT_U32); \n\t}\n\n\n#undef SYSFONT_TEX\n#undef SYSFONT_DRAW\n#undef SYSFONT_DATA\n\n#endif /* SYSFONT_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "testfw.h",
          "type": "blob",
          "size": 22.271484375,
          "content": "/*\n------------------------------------------------------------------------------\n\t\t  Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\ntestfw.h - v1.1 - Basic test framework for C/C++.\n\nDo this:\n\t#define TESTFW_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef testfw_h\n#define testfw_h\n\n#define TESTFW_INIT() testfw_init()\n#define TESTFW_SUMMARY() testfw_summary( __FILE__, __func__, __LINE__ )\n#if defined( _WIN32 ) && !defined( TESTFW_NO_SEH ) && !defined( __TINYC__ )\n    #if defined __cplusplus\n        extern \"C\" unsigned long __cdecl _exception_code(void);\n    #else\n        unsigned long __cdecl _exception_code(void);\n    #endif\n    #define TESTFW_TEST_BEGIN( desc ) testfw_test_begin( desc, __FILE__, __func__, __LINE__ ); __try {\n    #define TESTFW_TEST_END() } __except( 1 /*EXCEPTION_EXECUTE_HANDLER*/ ) \\\n        { testfw_exception( _exception_code/*GetExceptionCode*/() ); } \\\n        testfw_test_end( __FILE__, __func__, __LINE__ )\n#else\n    #define TESTFW_TEST_BEGIN( desc ) testfw_test_begin( desc, __FILE__, __func__, __LINE__ ); {\n    #define TESTFW_TEST_END() testfw_test_end( __FILE__, __func__, __LINE__ ); }\n#endif\n#define TESTFW_EXPECTED( expression ) testfw_expected( (expression) ? 1 : 0, #expression, __FILE__, __func__, __LINE__ )\n\nvoid testfw_init( void );\nint testfw_summary( char const* filename, char const* funcname, int line );\nvoid testfw_test_begin( char const* desc, char const* filename, char const* funcname, int line );\nvoid testfw_test_end( char const* filename, char const* funcname, int line );\nvoid testfw_expected( int expression, char const* expression_str, char const* filename, char const* funcname, int line );\nvoid testfw_print_test_desc( void );\nvoid testfw_print_failure( char const* filename, int line );\nvoid testfw_assertion_count_inc( void );\nvoid testfw_current_test_assertion_failed( void );\n#if defined( _WIN32 ) && !defined( TESTFW_NO_SEH ) && !defined( __TINYC__ )\n    void testfw_exception( unsigned int exception_code );\n#endif\n\n\n#endif /* testfw_h */\n\n\n\n#ifdef TESTFW_IMPLEMENTATION\n#undef TESTFW_IMPLEMENTATION\n\n#define _CRT_NONSTDC_NO_DEPRECATE \n#define _CRT_SECURE_NO_WARNINGS\n#include <string.h>\n\n#if defined( _WIN32 ) && !defined( __TINYC__ )\n    #pragma warning( push ) \n    #pragma warning( disable: 4619 ) // pragma warning : there is no warning number 'number'\n    #pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' \n    #include <crtdbg.h>\n    #pragma warning( pop ) \n#endif /* _WIN32 */\n\n#ifndef TESTFW_PRINTF\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n    #include <stdio.h>\n\n    #define TESTFW_PRINTF( format, ... ) printf( format, ##__VA_ARGS__ ) \n#endif\n\n#ifdef TESTFW_NO_ANSI\n    #define TESTFW_ANSI_BLACK \"\"\n    #define TESTFW_ANSI_BLUE \"\"\n    #define TESTFW_ANSI_GREEN \"\"\n    #define TESTFW_ANSI_CYAN \"\"\n    #define TESTFW_ANSI_RED \"\"\n    #define TESTFW_ANSI_MAGENTA \"\"\n    #define TESTFW_ANSI_BROWN \"\"\n    #define TESTFW_ANSI_LIGHT_GREY \"\"\n    #define TESTFW_ANSI_GREY \"\"\n    #define TESTFW_ANSI_LIGHT_BLUE \"\"\n    #define TESTFW_ANSI_LIGHT_GREEN \"\"\n    #define TESTFW_ANSI_LIGHT_CYAN \"\"\n    #define TESTFW_ANSI_LIGHT_RED \"\"\n    #define TESTFW_ANSI_LIGHT_MAGENTA \"\"\n    #define TESTFW_ANSI_YELLOW \"\"\n    #define TESTFW_ANSI_WHITE \"\"\n    #define TESTFW_ANSI_RESET \"\"\n#else\n    #ifndef TESTFW_ANSI_BLACK\n        #define TESTFW_ANSI_BLACK \"\\x1b[30m\"\n    #endif\n    #ifndef TESTFW_ANSI_BLUE\n        #define TESTFW_ANSI_BLUE \"\\x1b[34m\"\n    #endif\n    #ifndef TESTFW_ANSI_GREEN\n        #define TESTFW_ANSI_GREEN \"\\x1b[32m\"\n    #endif\n    #ifndef TESTFW_ANSI_CYAN\n        #define TESTFW_ANSI_CYAN \"\\x1b[36m\"\n    #endif\n    #ifndef TESTFW_ANSI_RED\n        #define TESTFW_ANSI_RED \"\\x1b[31m\"\n    #endif\n    #ifndef TESTFW_ANSI_MAGENTA\n        #define TESTFW_ANSI_MAGENTA \"\\x1b[35m\"\n    #endif\n    #ifndef TESTFW_ANSI_BROWN\n        #define TESTFW_ANSI_BROWN \"\\x1b[33m\"\n    #endif\n    #ifndef TESTFW_ANSI_LIGHT_GREY\n        #define TESTFW_ANSI_LIGHT_GREY \"\\x1b[37m\"\n    #endif\n    #ifndef TESTFW_ANSI_GREY\n        #define TESTFW_ANSI_GREY \"\\x1b[30;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_LIGHT_BLUE\n        #define TESTFW_ANSI_LIGHT_BLUE \"\\x1b[34;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_LIGHT_GREEN\n        #define TESTFW_ANSI_LIGHT_GREEN \"\\x1b[32;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_LIGHT_CYAN\n        #define TESTFW_ANSI_LIGHT_CYAN \"\\x1b[36;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_LIGHT_RED\n        #define TESTFW_ANSI_LIGHT_RED \"\\x1b[31;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_LIGHT_MAGENTA\n        #define TESTFW_ANSI_LIGHT_MAGENTA \"\\x1b[35;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_YELLOW\n        #define TESTFW_ANSI_YELLOW \"\\x1b[33;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_WHITE\n        #define TESTFW_ANSI_WHITE \"\\x1b[37;1m\"\n    #endif\n    #ifndef TESTFW_ANSI_RESET\n        #define TESTFW_ANSI_RESET \"\\x1b[0m\"\n    #endif\n#endif\n\n\nstruct testfw_internal_current_test_state_t\n    {\n    int is_active;\n    char const* file;\n    char const* func;\n    int line;\n    char const* desc;\n    int desc_printed;\n    int counted_as_failed;\n    };\n\n\nstatic struct \n    {\n    int tests_total;\n    int tests_failed;\n    int assertions_total;\n    int assertions_failed;\n    struct testfw_internal_current_test_state_t current_test;\n    #if defined( _WIN32 ) && defined( _DEBUG )  && !defined( __TINYC__ )\n        int total_leaks;\n    #endif\n    } testfw_internal_state;\n\n\nstatic void testfw_internal_print_progress_divider( char ch, int fail, int total )\n    {\n    int width = 79;\n    int first = (int)( ( width * fail ) / ( total ? total : 1 ) );\n    int second = width - first;\n    if( fail > 0 && first == 0 )\n        {\n        ++first;\n        --second;\n        }\n    TESTFW_PRINTF( \"%s\", TESTFW_ANSI_LIGHT_RED );\n    for( int i = 0; i < first; ++i ) TESTFW_PRINTF( \"%c\", ch );\n    TESTFW_PRINTF( \"%s\", TESTFW_ANSI_LIGHT_GREEN );\n    for( int i = 0; i < second; ++i ) TESTFW_PRINTF( \"%c\", ch );\n    TESTFW_PRINTF( \"%s\", TESTFW_ANSI_RESET );\n    TESTFW_PRINTF( \"\\n\" );\n    }\n\n\n#if defined( _WIN32 ) && defined( _DEBUG ) && !defined( __TINYC__ )\n\n    static int testfw_internal_debug_report_hook( int report_type, char* message, int* return_value ) \n        { \n        _flushall();\n        (void) report_type;\n        *return_value = 0; // Don't break to debugger\n\n        if( stricmp( message, \"Detected memory leaks!\\n\" ) == 0 )\n            {\n            TESTFW_PRINTF( \"-------------------------------------------------------------------------------\\n\" );\n            TESTFW_PRINTF( \"%sMEMORY CHECKS FAILED:%s Detected memory leaks\\n\", TESTFW_ANSI_LIGHT_RED, \n                TESTFW_ANSI_RESET );\n            return 1; // Tell CRT not to print the message\n            }\n        else if( stricmp( message, \"Dumping objects ->\\n\" ) == 0 )\n            {\n            TESTFW_PRINTF( \"-------------------------------------------------------------------------------\\n\" );\n            TESTFW_PRINTF( \"\\n\" );\n            return 1; // Tell CRT not to print the message\n            }\n        else if( stricmp( message, \"Object dump complete.\\n\" ) == 0 )\n            {\n            TESTFW_PRINTF( \"\\n\" );\n            _CrtMemState state;\n            _CrtMemCheckpoint( &state );\n\n            static char const* const block_use_names[ 5 ] = { \"Free\", \"Normal\", \"CRT\", \"Ignore\", \"Client\", };\n            for( unsigned int i = 0; i < 5; ++i )\n                {\n                if( i != 2 && state.lCounts[ i ] )\n                    TESTFW_PRINTF( \"%lld bytes in %lld %hs Blocks.\\n\", (long long) state.lSizes[ i ], \n                        (long long) state.lCounts[ i ], block_use_names[ i ] );\n                }\n\n            TESTFW_PRINTF( \"\\n\" );\n            TESTFW_PRINTF( \"High water mark: %lld bytes.\\n\", (long long)state.lHighWaterCount);\n            TESTFW_PRINTF( \"All allocations: %lld bytes.\\n\",   (long long)state.lTotalCount);\n            TESTFW_PRINTF( \"\\n\" );\n            TESTFW_PRINTF( \"===============================================================================\\n\" );\n            TESTFW_PRINTF( \"%sMEMORY LEAKS: %d%s\\n\\n\", TESTFW_ANSI_LIGHT_RED, testfw_internal_state.total_leaks, TESTFW_ANSI_RESET );\n            return 1; // Tell CRT not to print the message\n            }\n        else if( strnicmp( message, \" Data: <\", 8 ) == 0 )\n            {\n            ++testfw_internal_state.total_leaks;\n            return 1; // Tell CRT not to print the message\n            }\n    \n        return 0;  // Tell CRT it can print the message, as we didn't handle it\n        }\n\n#endif /* _WIN32 && _DEBUG */\n\n\n#if defined( _WIN32 ) \n    #include <windows.h>\n#endif\n\n\nvoid testfw_init( void )\n    {\n    memset( &testfw_internal_state, 0, sizeof( testfw_internal_state ) );\n\n    #if defined( _WIN32 ) \n        #if !defined( __TINYC__ )\n            int flag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG ); // Get current flag\n            flag ^= _CRTDBG_LEAK_CHECK_DF; // Turn on leak-checking bit\n            _CrtSetDbgFlag( flag ); // Set flag to the new value\n            _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );\n            _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );\n            _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );\n            _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );\n            _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );\n            _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );\n            _CrtSetReportHook2( _CRT_RPTHOOK_INSTALL, testfw_internal_debug_report_hook );\n            _CrtSetReportHook( testfw_internal_debug_report_hook );\n        #endif /* __TINYC__ */\n        HANDLE handle = GetStdHandle( STD_OUTPUT_HANDLE );\n        if( handle != INVALID_HANDLE_VALUE ) {\n            DWORD mode = 0;\n            GetConsoleMode( handle, &mode );\n            SetConsoleMode( handle, mode | 0x0004 /*ENABLE_VIRTUAL_TERMINAL_PROCESSING*/ );\n        }\n    #endif /* _WIN32 */\n    }\n\n\nstatic int testfw_internal_must_be_in_test( void )\n    {\n    if( !testfw_internal_state.current_test.is_active )\n        TESTFW_PRINTF( \"\\n\\n%sEXPECTED TO BE IN AN ACTIVE TEST, BUT NO TEST IS CURRENTLY ACTIVE.%s\\n\\n\", \n            TESTFW_ANSI_LIGHT_RED, TESTFW_ANSI_RESET );\n    return !testfw_internal_state.current_test.is_active;\n    }\n\n\nstatic int testfw_internal_can_not_be_in_test( void )\n    {\n    if( testfw_internal_state.current_test.is_active )\n        TESTFW_PRINTF( \"\\n\\n%sEXPECTED TO NOT BE IN AN ACTIVE TEST, BUT A TEST IS CURRENTLY ACTIVE.%s\\n\\n\", \n            TESTFW_ANSI_LIGHT_RED, TESTFW_ANSI_RESET );\n    return testfw_internal_state.current_test.is_active;\n    }\n\n\nvoid testfw_print_test_desc( void )\n    {\n    if( testfw_internal_must_be_in_test() ) return;\n\n    if( !testfw_internal_state.current_test.desc_printed ) \n        {\n        testfw_internal_state.current_test.desc_printed = 1;\n        \n        TESTFW_PRINTF( \"\\n\" );\n        TESTFW_PRINTF( \"-------------------------------------------------------------------------------\\n\" );\n        TESTFW_PRINTF( \"%s\\n\", testfw_internal_state.current_test.desc ? testfw_internal_state.current_test.desc : \n            \"<NO DESCRIPTION>\" ); \n        TESTFW_PRINTF( \"-------------------------------------------------------------------------------\\n\" );\n        TESTFW_PRINTF( \"%s%s(%d): %s%s\\n\", TESTFW_ANSI_LIGHT_GREY, testfw_internal_state.current_test.file, \n            testfw_internal_state.current_test.line, TESTFW_ANSI_RESET, testfw_internal_state.current_test.func );\n        \n        TESTFW_PRINTF( \"%s\", TESTFW_ANSI_LIGHT_GREY );\n        TESTFW_PRINTF( \"...............................................................................\\n\" );\n        TESTFW_PRINTF( \"%s\", TESTFW_ANSI_RESET );\n        } \n    }\n\n\nint testfw_summary( char const* filename, char const* funcname, int line )\n    {\n    (void) filename; (void) funcname; (void) line;\n    \n    if( testfw_internal_can_not_be_in_test() ) return -1;\n\n    TESTFW_PRINTF( \"\\n\" );\n    testfw_internal_print_progress_divider( '=', testfw_internal_state.tests_failed, testfw_internal_state.tests_total );   \n    if( testfw_internal_state.tests_failed == 0 && testfw_internal_state.assertions_failed == 0 )\n        {\n        TESTFW_PRINTF( \"%sAll tests passed%s (%d assertions in %d test cases)\\n\", TESTFW_ANSI_LIGHT_GREEN, \n            TESTFW_ANSI_RESET, testfw_internal_state.assertions_total, testfw_internal_state.tests_total );\n        }\n    else\n        {\n        TESTFW_PRINTF( \"test cases: %4d |%s %4d passed %s|%s %4d failed%s\\n\", testfw_internal_state.tests_total,\n            TESTFW_ANSI_LIGHT_GREEN, testfw_internal_state.tests_total - testfw_internal_state.tests_failed, \n            TESTFW_ANSI_RESET, TESTFW_ANSI_LIGHT_RED, testfw_internal_state.tests_failed, TESTFW_ANSI_RESET );\n        TESTFW_PRINTF( \"assertions: %4d |%s %4d passed %s|%s %4d failed%s\\n\", testfw_internal_state.assertions_total, \n            TESTFW_ANSI_LIGHT_GREEN, testfw_internal_state.assertions_total - testfw_internal_state.assertions_failed, \n            TESTFW_ANSI_RESET, TESTFW_ANSI_LIGHT_RED, testfw_internal_state.assertions_failed, TESTFW_ANSI_RESET );\n        }\n\n    TESTFW_PRINTF( \"\\n\\n\" );\n\n    #if defined( _WIN32 ) && defined( _DEBUG ) && !defined( __TINYC__ )\n        int result = _CrtDumpMemoryLeaks();\n        testfw_internal_state.tests_failed += result ? 1 : 0;\n    #endif\n\n    return testfw_internal_state.tests_failed;\n    }\n\n\nvoid testfw_test_begin( char const* desc, char const* filename, char const* funcname, int line )\n    {\n    if( testfw_internal_can_not_be_in_test() ) return;\n\n    memset( &testfw_internal_state.current_test, 0, sizeof( testfw_internal_state.current_test ) );    \n    testfw_internal_state.current_test.is_active = 1;\n    testfw_internal_state.current_test.file = filename;\n    testfw_internal_state.current_test.func = funcname;\n    testfw_internal_state.current_test.line = line;\n    testfw_internal_state.current_test.desc = desc;\n    testfw_internal_state.current_test.desc_printed = 0;\n    testfw_internal_state.current_test.counted_as_failed = 0;\n\n    ++testfw_internal_state.tests_total;\n    }\n\n\nvoid testfw_test_end( char const* filename, char const* funcname, int line )\n    {\n    (void) filename; (void) funcname; (void) line;\n    if( testfw_internal_must_be_in_test() ) return;\n\n    memset( &testfw_internal_state.current_test, 0, sizeof( testfw_internal_state.current_test ) );    \n    }\n\n\n#if defined( _WIN32 ) && !defined( TESTFW_NO_SEH ) && !defined( __TINYC__ )\n    #pragma warning( push )\n    #pragma warning( disable: 4668 )\n    #include <windows.h>\n    #pragma warning( pop )\n\n    void testfw_exception( unsigned int exception_code )\n        {\n        if( testfw_internal_must_be_in_test() ) return;\n\n        if( !testfw_internal_state.current_test.counted_as_failed ) \n            {\n            testfw_internal_state.current_test.counted_as_failed = 1;\n            ++testfw_internal_state.tests_failed;\n            }\n\n        char exception_str[ 64 ];\n        switch( exception_code ) \n            {\n            case EXCEPTION_ACCESS_VIOLATION:\n                strcpy( exception_str, \"EXCEPTION_ACCESS_VIOLATION\" );\n                break;\n            case EXCEPTION_DATATYPE_MISALIGNMENT:\n                strcpy( exception_str, \"EXCEPTION_DATATYPE_MISALIGNMENT\" );\n                break;\n            case EXCEPTION_BREAKPOINT:\n                strcpy( exception_str, \"EXCEPTION_BREAKPOINT\" );\n                break;\n            case EXCEPTION_SINGLE_STEP:\n                strcpy( exception_str, \"EXCEPTION_SINGLE_STEP\" );\n                break;\n            case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n                strcpy( exception_str, \"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\" );\n                break;\n            case EXCEPTION_FLT_DENORMAL_OPERAND:\n                strcpy( exception_str, \"EXCEPTION_FLT_DENORMAL_OPERAND\" );\n                break;\n            case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n                strcpy( exception_str, \"EXCEPTION_FLT_DIVIDE_BY_ZERO\" );\n                break;\n            case EXCEPTION_FLT_INEXACT_RESULT:\n                strcpy( exception_str, \"EXCEPTION_FLT_INEXACT_RESULT\" );\n                break;\n            case EXCEPTION_FLT_INVALID_OPERATION:\n                strcpy( exception_str, \"EXCEPTION_FLT_INVALID_OPERATION\" );\n                break;\n            case EXCEPTION_FLT_OVERFLOW:\n                strcpy( exception_str, \"EXCEPTION_FLT_OVERFLOW\" );\n                break;\n            case EXCEPTION_FLT_STACK_CHECK:\n                strcpy( exception_str, \"EXCEPTION_FLT_STACK_CHECK\" );\n                break;\n            case EXCEPTION_FLT_UNDERFLOW:\n                strcpy( exception_str, \"EXCEPTION_FLT_UNDERFLOW\" );\n                break;\n            case EXCEPTION_INT_DIVIDE_BY_ZERO:\n                strcpy( exception_str, \"EXCEPTION_INT_DIVIDE_BY_ZERO\" );\n                break;\n            case EXCEPTION_INT_OVERFLOW:\n                strcpy( exception_str, \"EXCEPTION_INT_OVERFLOW\" );\n                break;\n            case EXCEPTION_PRIV_INSTRUCTION:\n                strcpy( exception_str, \"EXCEPTION_PRIV_INSTRUCTION\" );\n                break;\n            case EXCEPTION_IN_PAGE_ERROR:\n                strcpy( exception_str, \"EXCEPTION_IN_PAGE_ERROR\" );\n                break;\n            case EXCEPTION_ILLEGAL_INSTRUCTION:\n                strcpy( exception_str, \"EXCEPTION_ILLEGAL_INSTRUCTION\" );\n                break;\n            case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n                strcpy( exception_str, \"EXCEPTION_NONCONTINUABLE_EXCEPTION\" );\n                break;\n            case EXCEPTION_STACK_OVERFLOW:\n                strcpy( exception_str, \"EXCEPTION_STACK_OVERFLOW\" );\n                break;\n            case EXCEPTION_INVALID_DISPOSITION:\n                strcpy( exception_str, \"EXCEPTION_INVALID_DISPOSITION\" );\n                break;\n            case EXCEPTION_GUARD_PAGE:\n                strcpy( exception_str, \"EXCEPTION_GUARD_PAGE\" );\n                break;\n            case EXCEPTION_INVALID_HANDLE:\n                strcpy( exception_str, \"EXCEPTION_INVALID_HANDLE\" );\n                break;\n            default:\n                sprintf( exception_str, \"%X\", exception_code );\n            }\n\n        testfw_print_test_desc();\n        TESTFW_PRINTF( \"\\n%s%s(%d): %sFAILED:%s\\n\", TESTFW_ANSI_LIGHT_GREY, testfw_internal_state.current_test.file, \n            testfw_internal_state.current_test.line, TESTFW_ANSI_LIGHT_RED, TESTFW_ANSI_RESET );\n        TESTFW_PRINTF( \"\\n  %sEXCEPTION( %s%s%s )%s\\n\", TESTFW_ANSI_CYAN, TESTFW_ANSI_WHITE, exception_str, \n            TESTFW_ANSI_LIGHT_GREY, TESTFW_ANSI_RESET );\n        }\n#endif\n\nvoid testfw_current_test_assertion_failed( void )\n    {\n    if( testfw_internal_must_be_in_test() ) return;\n\n    ++testfw_internal_state.assertions_failed;\n\n    if( !testfw_internal_state.current_test.counted_as_failed ) \n        {\n        testfw_internal_state.current_test.counted_as_failed = 1;\n        ++testfw_internal_state.tests_failed;\n        }\n    }\n\n\nvoid testfw_assertion_count_inc( void )\n    {\n    if( testfw_internal_must_be_in_test() ) return;\n\n    ++testfw_internal_state.assertions_total;\n    }\n\n\nvoid testfw_print_failure( char const* filename, int line )\n    {\n    TESTFW_PRINTF( \"\\n%s%s(%d): %sFAILED:%s\\n\", TESTFW_ANSI_LIGHT_GREY, filename, line, TESTFW_ANSI_LIGHT_RED, \n        TESTFW_ANSI_RESET );\n    }\n\n\nvoid testfw_expected( int expression, char const* expression_str, char const* filename, \n    char const* funcname, int line )\n    {\n    (void) funcname;\n    if( testfw_internal_must_be_in_test() ) return;\n\n    testfw_assertion_count_inc();\n\n    if( !expression ) \n        { \n        testfw_current_test_assertion_failed();\n        testfw_print_test_desc();\n        testfw_print_failure( filename, line );\n        TESTFW_PRINTF( \"\\n  %sTESTFW_EXPECTED( %s%s%s )%s\\n\", TESTFW_ANSI_LIGHT_MAGENTA, TESTFW_ANSI_WHITE, expression_str, \n            TESTFW_ANSI_LIGHT_MAGENTA, TESTFW_ANSI_RESET );\n        }\n    }\n\n#endif /* TESTFW_IMPLEMENTATION */\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2019 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        },
        {
          "name": "thread.h",
          "type": "blob",
          "size": 44.3388671875,
          "content": "/*\n------------------------------------------------------------------------------\n          Licensing information can be found at the end of the file.\n------------------------------------------------------------------------------\n\nthread.h - v0.3 - Cross platform threading functions for C/C++.\n\nDo this:\n    #define THREAD_IMPLEMENTATION\nbefore you include this file in *one* C/C++ file to create the implementation.\n*/\n\n#ifndef thread_h\n#define thread_h\n\n#ifndef THREAD_U64\n    #define THREAD_U64 unsigned long long\n#endif\n\n#define THREAD_STACK_SIZE_DEFAULT ( 0 )\n#define THREAD_SIGNAL_WAIT_INFINITE ( -1 )\n#define THREAD_QUEUE_WAIT_INFINITE ( -1 )\n\ntypedef void* thread_id_t;\nthread_id_t thread_current_thread_id( void );\nvoid thread_yield( void );\nvoid thread_set_high_priority( void );\nvoid thread_exit( int return_code );\n\ntypedef void* thread_ptr_t;\nthread_ptr_t thread_create( int (*thread_proc)( void* ), void* user_data, int stack_size );\nvoid thread_destroy( thread_ptr_t thread );\nint thread_join( thread_ptr_t thread );\nint thread_detach( thread_ptr_t thread );\n\ntypedef union thread_mutex_t thread_mutex_t;\nvoid thread_mutex_init( thread_mutex_t* mutex );\nvoid thread_mutex_term( thread_mutex_t* mutex );\nvoid thread_mutex_lock( thread_mutex_t* mutex );\nvoid thread_mutex_unlock( thread_mutex_t* mutex );\n\ntypedef union thread_signal_t thread_signal_t;\nvoid thread_signal_init( thread_signal_t* signal );\nvoid thread_signal_term( thread_signal_t* signal );\nvoid thread_signal_raise( thread_signal_t* signal );\nint thread_signal_wait( thread_signal_t* signal, int timeout_ms );\n\ntypedef union thread_atomic_int_t thread_atomic_int_t;\nint thread_atomic_int_load( thread_atomic_int_t* atomic );\nvoid thread_atomic_int_store( thread_atomic_int_t* atomic, int desired );\nint thread_atomic_int_inc( thread_atomic_int_t* atomic );\nint thread_atomic_int_dec( thread_atomic_int_t* atomic );\nint thread_atomic_int_add( thread_atomic_int_t* atomic, int value );\nint thread_atomic_int_sub( thread_atomic_int_t* atomic, int value );\nint thread_atomic_int_swap( thread_atomic_int_t* atomic, int desired );\nint thread_atomic_int_compare_and_swap( thread_atomic_int_t* atomic, int expected, int desired );\n\ntypedef union thread_atomic_ptr_t thread_atomic_ptr_t;\nvoid* thread_atomic_ptr_load( thread_atomic_ptr_t* atomic );\nvoid thread_atomic_ptr_store( thread_atomic_ptr_t* atomic, void* desired );\nvoid* thread_atomic_ptr_swap( thread_atomic_ptr_t* atomic, void* desired );\nvoid* thread_atomic_ptr_compare_and_swap( thread_atomic_ptr_t* atomic, void* expected, void* desired );\n\ntypedef union thread_timer_t thread_timer_t;\nvoid thread_timer_init( thread_timer_t* timer );\nvoid thread_timer_term( thread_timer_t* timer );\nvoid thread_timer_wait( thread_timer_t* timer, THREAD_U64 nanoseconds );\n\ntypedef void* thread_tls_t;\nthread_tls_t thread_tls_create( void );\nvoid thread_tls_destroy( thread_tls_t tls );\nvoid thread_tls_set( thread_tls_t tls, void* value );\nvoid* thread_tls_get( thread_tls_t tls );\n\ntypedef struct thread_queue_t thread_queue_t;\nvoid thread_queue_init( thread_queue_t* queue, int size, void** values, int count );\nvoid thread_queue_term( thread_queue_t* queue );\nint thread_queue_produce( thread_queue_t* queue, void* value, int timeout_ms );\nvoid* thread_queue_consume( thread_queue_t* queue, int timeout_ms );\nint thread_queue_count( thread_queue_t* queue );\n\n#endif /* thread_h */\n\n\n/**\n\nthread.h \n========\n\nCross platform threading functions for C/C++.\n\nExample\n-------\n\nHere's a basic sample program which starts a second thread which just waits and prints a message.\n\n    #define  THREAD_IMPLEMENTATION\n    #include \"thread.h\"\n\n    #include <stdio.h> // for printf\n    \n    int thread_proc( void* user_data) {\n        thread_timer_t timer;\n        thread_timer_init( &timer );\n\n        int count = 0;\n        thread_atomic_int_t* exit_flag = (thread_atomic_int_t*) user_data;\n        while( thread_atomic_int_load( exit_flag ) == 0 ) {\n            printf( \"Thread... \" );\n            thread_timer_wait( &timer, 1000000000 ); // sleep for a second\n            ++count;\n        }\n\n        thread_timer_term( &timer );\n        printf( \"Done\\n\" );\n        return count;\n    }\n\n    int main( int argc, char** argv ) {        \n        thread_atomic_int_t exit_flag;\n        thread_atomic_int_store( &exit_flag, 0 );\n\n        thread_ptr_t thread = thread_create( thread_proc, &exit_flag, \"Example thread\", THREAD_STACK_SIZE_DEFAULT );\n\n        thread_timer_t timer;\n        thread_timer_init( &timer );\n        for( int i = 0; i < 5; ++i ) {\n            printf( \"Main... \" );\n            thread_timer_wait( &timer, 2000000000 ); // sleep for two seconds\n        }\n        thread_timer_term( &timer );\n        \n        thread_atomic_int_store( &exit_flag, 1 ); // signal thread to exit\n        int retval = thread_join( thread );\n\n        printf( \"Count: %d\\n\", retval );\n\n        thread_destroy( thread );\n        return retval;\n    }\n\n\nAPI Documentation\n-----------------\n\nthread.h is a single-header library, and does not need any .lib files or other binaries, or any build scripts. To use it,\nyou just include thread.h to get the API declarations. To get the definitions, you must include thread.h from *one* \nsingle C or C++ file, and #define the symbol `THREAD_IMPLEMENTATION` before you do. \n\n\n### Customization\n\nthread.h allows for specifying the exact type of 64-bit unsigned integer to be used in its API. By default, it is \ndefined as `unsigned long long`, but as this is not a standard type on all compilers, you can redefine it by #defining \nTHREAD_U64 before including thread.h. This is useful if you, for example, use the types from `<stdint.h>` in the rest of \nyour program, and you want thread.h to use compatible types. In this case, you would include thread.h using the \nfollowing code:\n\n    #define THREAD_U64 uint64_t\n    #include \"thread.h\"\n\nNote that when customizing this data type, you need to use the same definition in every place where you include \nthread.h, as it affect the declarations as well as the definitions.\n\n\nthread_current_thread_id\n------------------------\n\n    thread_id_t thread_current_thread_id( void )\n\nReturns a unique identifier for the calling thread. After the thread terminates, the id might be reused for new threads.\n\n\nthread_yield\n------------\n\n    void thread_yield( void )\n\nMakes the calling thread yield execution to another thread. The operating system controls which thread is switched to.\n\n\nthread_set_high_priority\n------------------------\n\n    void thread_set_high_priority( void )\n\nWhen created, threads are set to run at normal priority. In some rare cases, such as a sound buffer update loop, it can\nbe necessary to have one thread of your application run on a higher priority than the rest. Calling \n`thread_set_high_priority` will raise the priority of the calling thread, giving it a chance to be run more often.\nDo not increase the priority of a thread unless you absolutely have to, as it can negatively affect performance if used\nwithout care.\n\n\nthread_exit\n-----------\n\n    void thread_exit( int return_code )\n\nExits the calling thread, as if you had done `return return_code;` from the main body of the thread function.\n\n\nthread_create\n-------------\n\n    thread_ptr_t thread_create( int (*thread_proc)( void* ), void* user_data, int stack_size )\n\nCreates a new thread running the `thread_proc` function, passing the `user_data` through to it. The thread will have \nthe stack size specified in the `stack_size` parameter. To get the operating system default stack size, use the \ndefined constant `THREAD_STACK_SIZE_DEFAULT`. When returning from the thread_proc function, the value you return can \nbe received in another thread by calling thread_join. `thread_create` returns a pointer to the thread instance, which \ncan be used as a parameter to the functions `thread_destroy` and `thread_join`.\n\n\nthread_destroy\n--------------\n\n    void thread_destroy( thread_ptr_t thread )\n\nDestroys a thread that was created by calling `thread_create`. Make sure the thread has exited before you attempt to \ndestroy it. This can be accomplished by calling `thread_join`. It is not possible for force termination of a thread by\ncalling `thread_destroy`.\n\n\nthread_join\n-----------\n\n    int thread_join( thread_ptr_t thread )\n\nWaits for the specified thread to exit. Returns the value which the thread returned when exiting.\n\n\nthread_detach\n-------------\n\n    int thread_detach( thread_ptr_t thread )\n\nMarks the thread as detached. When a detached thread terminates, its resources are automatically released back to the\nsystem without the need for another thread to join with the terminated thread.\n    \n    \nthread_mutex_init\n-----------------\n    \n    void thread_mutex_init( thread_mutex_t* mutex )\n\nInitializes the specified mutex instance, preparing it for use. A mutex can be used to lock sections of code, such that\nit can only be run by one thread at a time.\n\n\nthread_mutex_term\n-----------------\n\n    void thread_mutex_term( thread_mutex_t* mutex )\n\nTerminates the specified mutex instance, releasing any system resources held by it.\n\n\nthread_mutex_lock\n-----------------\n\n    void thread_mutex_lock( thread_mutex_t* mutex )\n\nTakes an exclusive lock on a mutex. If the lock is already taken by another thread, `thread_mutex_lock` will yield the\ncalling thread and wait for the lock to become available before returning. The mutex must be initialized by calling\n`thread_mutex_init` before it can be locked.\n\n\nthread_mutex_unlock\n-------------------\n\n    void thread_mutex_unlock( thread_mutex_t* mutex )\n\nReleases a lock taken by calling `thread_mutex_lock`. \n\n\nthread_signal_init\n------------------\n\n    void thread_signal_init( thread_signal_t* signal )\n\nInitializes the specified signal instance, preparing it for use. A signal works like a flag, which can be waited on by\none thread, until it is raised from another thread. \n\n\nthread_signal_term\n------------------\n\n    void thread_signal_term( thread_signal_t* signal )\n\nTerminates the specified signal instance, releasing any system resources held by it.\n\n\nthread_signal_raise\n-------------------\n\n    void thread_signal_raise( thread_signal_t* signal )\n\nRaise the specified signal. Other threads waiting for the signal will proceed.  \n\n\nthread_signal_wait\n------------------\n\n    int thread_signal_wait( thread_signal_t* signal, int timeout_ms )\n\nWaits for a signal to be raised, or until `timeout_ms` milliseconds have passed. If the wait timed out, a value of 0 is\nreturned, otherwise a non-zero value is returned. If the `timeout_ms` parameter is THREAD_SIGNAL_WAIT_INFINITE, \n`thread_signal_wait` waits indefinitely.\n\n\nthread_atomic_int_load\n----------------------\n\n    int thread_atomic_int_load( thread_atomic_int_t* atomic )\n\nReturns the value of `atomic` as an atomic operation.\n\n\nthread_atomic_int_store\n-----------------------\n\n    void thread_atomic_int_store( thread_atomic_int_t* atomic, int desired )\n\nSets the value of `atomic` as an atomic operation.\n\n\nthread_atomic_int_inc\n---------------------\n\n    int thread_atomic_int_inc( thread_atomic_int_t* atomic )\n\nIncrements the value of `atomic` by one, as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_int_dec\n---------------------\n\n    int thread_atomic_int_dec( thread_atomic_int_t* atomic )\n\nDecrements the value of `atomic` by one, as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_int_add\n---------------------\n\n    int thread_atomic_int_add( thread_atomic_int_t* atomic, int value )\n\nAdds the specified value to `atomic`, as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_int_sub\n---------------------\n\n    int thread_atomic_int_sub( thread_atomic_int_t* atomic, int value )\n\nSubtracts the specified value to `atomic`, as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_int_swap\n----------------------\n\n    int thread_atomic_int_swap( thread_atomic_int_t* atomic, int desired )\n\nSets the value of `atomic` as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_int_compare_and_swap\n----------------------------------\n\n    int thread_atomic_int_compare_and_swap( thread_atomic_int_t* atomic, int expected, int desired )\n\nCompares the value of `atomic` to the value of `expected`, and if they match, sets the vale of `atomic` to `desired`,\nall as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_ptr_load\n----------------------\n\n    void* thread_atomic_ptr_load( thread_atomic_ptr_t* atomic )\n\nReturns the value of `atomic` as an atomic operation.\n\n\nthread_atomic_ptr_store\n-----------------------\n\n    void thread_atomic_ptr_store( thread_atomic_ptr_t* atomic, void* desired )\n\nSets the value of `atomic` as an atomic operation.\n\n\nthread_atomic_ptr_swap\n----------------------\n\n    void* thread_atomic_ptr_swap( thread_atomic_ptr_t* atomic, void* desired )\n\nSets the value of `atomic` as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_atomic_ptr_compare_and_swap\n----------------------------------\n\n    void* thread_atomic_ptr_compare_and_swap( thread_atomic_ptr_t* atomic, void* expected, void* desired )\n\nCompares the value of `atomic` to the value of `expected`, and if they match, sets the vale of `atomic` to `desired`,\nall as an atomic operation. Returns the value `atomic` had before the operation.\n\n\nthread_timer_init\n-----------------\n    \n    void thread_timer_init( thread_timer_t* timer )\n\nInitializes the specified timer instance, preparing it for use. A timer can be used to sleep a thread for a high \nprecision duration.\n\n\nthread_timer_term\n-----------------\n\n    void thread_timer_term( thread_timer_t* timer )\n\nTerminates the specified timer instance, releasing any system resources held by it.\n\n\nthread_timer_wait\n-----------------\n\n    void thread_timer_wait( thread_timer_t* timer, THREAD_U64 nanoseconds )\n\nWaits until `nanoseconds` amount of time have passed, before returning.\n\n\nthread_tls_create\n-----------------\n    \n    thread_tls_t thread_tls_create( void )\n\nCreates  a thread local storage (TLS) index. Once created, each thread has its own value for that TLS index, which can\nbe set or retrieved individually.\n\n\nthread_tls_destroy\n------------------\n    \n    void thread_tls_destroy( thread_tls_t tls )\n\nDestroys the specified TLS index. No further calls to `thread_tls_set` or `thread_tls_get` are valid after this.\n\n\nthread_tls_set\n--------------\n\n    void thread_tls_set( thread_tls_t tls, void* value )\n\nStores a value in the calling thread's slot for the specified TLS index. Each thread has its own value for each TLS \nindex.\n\n\nthread_tls_get\n--------------\n\n    void* thread_tls_get( thread_tls_t tls )\n\nRetrieves the value from the calling thread's slot for the specified TLS index. Each thread has its own value for each \nTLS index.\n\n\nthread_queue_init\n-----------------\n\n    void thread_queue_init( thread_queue_t* queue, int size, void** values, int count )\n\nInitializes the specified queue instance, preparing it for use. The queue is a lock-free (but not wait-free)\nsingle-producer/single-consumer queue - it will not acquire any locks as long as there is space for adding or items to\nbe consume, but will lock and wait when there is not. The `size` parameter specifies the number of elements in the \nqueue. The `values` parameter is an array of queue slots (`size` elements in length), each being of type `void*`. If\nthe queue is initially empty, the `count` parameter should be 0, otherwise it indicates the number of entires, from the\nstart of the `values` array, that the queue is initialized with. The `values` array is not copied, and must remain valid\nuntil `thread_queue_term` is called.\n\n\nthread_queue_term\n-----------------\n\n    void thread_queue_term( thread_queue_t* queue )\n\nTerminates the specified queue instance, releasing any system resources held by it.\n\n\nthread_queue_produce\n--------------------\n\n    int thread_queue_produce( thread_queue_t* queue, void* value, int timeout_ms )\n\nAdds an element to a single-producer/single-consumer queue. If there is space in the queue to add another element, no\nlock will be taken. If the queue is full, calling thread will sleep until an element is consumed from another thread, \nbefore adding the element, or until `timeout_ms` milliseconds have passed. If the wait timed out, a value of 0 is \nreturned, otherwise a non-zero value is returned. If the `timeout_ms` parameter is THREAD_QUEUE_WAIT_INFINITE,  \n`thread_queue_produce` waits indefinitely.\n\n\nthread_queue_consume\n--------------------\n\n    void* thread_queue_consume( thread_queue_t* queue, int timeout_ms )\n\nRemoves an element from a single-producer/single-consumer queue. If the queue contains at least one element, no lock \nwill be taken. If the queue is empty, the calling thread will sleep until an element is added from another thread, or \nuntil `timeout_ms` milliseconds have passed. If the wait timed out, a value of NULL is returned, otherwise \n`thread_queue_consume` returns the value that was removed from the queue. If the `timeout_ms` parameter is \nTHREAD_QUEUE_WAIT_INFINITE, `thread_queue_consume` waits indefinitely.\n\n\nthread_queue_count\n------------------\n\n    int thread_queue_count( thread_queue_t* queue )\n\nReturns the number of elements currently held in a single-producer/single-consumer queue. Be aware that by the time you\nget the count, it might have changed by another thread calling consume or produce, so use with care.\n\n*/\n\n\n/*\n----------------------\n    IMPLEMENTATION\n----------------------\n*/\n\n#ifndef thread_impl\n#define thread_impl\n\nunion thread_mutex_t \n    { \n    void* align; \n    char data[ 64 ];\n    };\n\nunion thread_signal_t \n    { \n    void* align; \n    char data[ 116 ];\n    };\n\nunion thread_atomic_int_t \n    {\n    void* align;\n    long i;\n    };\n\nunion thread_atomic_ptr_t \n    {\n    void* ptr;\n    };\n\nunion thread_timer_t \n    { \n    void* data; \n    char d[ 8 ]; \n    };\n\nstruct thread_queue_t\n    {\n    thread_signal_t data_ready;\n    thread_signal_t space_open;\n    thread_atomic_int_t count;\n    thread_atomic_int_t head;\n    thread_atomic_int_t tail;\n    void** values;\n    int size;\n    #ifndef NDEBUG\n        thread_atomic_int_t id_produce_is_set;\n        thread_id_t id_produce;\n        thread_atomic_int_t id_consume_is_set;\n        thread_id_t id_consume;\n    #endif\n    };\n\n#endif /* thread_impl */\n\n\n\n#ifdef THREAD_IMPLEMENTATION\n#undef THREAD_IMPLEMENTATION\n\n#ifndef THREAD_ASSERT\n    #undef _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #undef _CRT_SECURE_NO_WARNINGS\n    #define _CRT_SECURE_NO_WARNINGS\n    #include <assert.h>\n    #define THREAD_ASSERT( expression, message ) assert( ( expression ) && ( message ) )\n#endif\n\n\n#if defined( _WIN32 )\n\n    #pragma comment( lib, \"winmm.lib\" )\n\n    #define _CRT_NONSTDC_NO_DEPRECATE \n    #define _CRT_SECURE_NO_WARNINGS\n\n    #if !defined( _WIN32_WINNT ) || _WIN32_WINNT < 0x0501 \n        #undef _WIN32_WINNT\n        #define _WIN32_WINNT 0x501// requires Windows XP minimum\n    #endif\n\n    #define _WINSOCKAPI_\n    #pragma warning( push )\n    #pragma warning( disable: 4619 ) \n    #pragma warning( disable: 4668 ) // 'symbol' is not defined as a preprocessor macro, replacing with '0' for 'directives'\n    #pragma warning( disable: 4768 ) // __declspec attributes before linkage specification are ignored\t\n    #pragma warning( disable: 4255 ) // 'function' : no function prototype given: converting '()' to '(void)'\n    #include <windows.h>\n    #pragma warning( pop )\n\n   \n#elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n    #include <pthread.h>\n    #include <errno.h>\n    #include <string.h>\n    #include <sys/time.h>\n    #include <stdint.h>\n\n#else \n    #error Unknown platform.\n#endif\n\n\n\nthread_id_t thread_current_thread_id( void )\n    {\n    #if defined( _WIN32 )\n\n        return (void*) (uintptr_t)GetCurrentThreadId();\n\n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n    \n        return (void*) pthread_self();\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_yield( void )\n    {\n    #if defined( _WIN32 )\n\n        SwitchToThread();\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n    \n        sched_yield();\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_exit( int return_code )\n    {\n    #if defined( _WIN32 )\n\n        ExitThread( (DWORD) return_code );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n    \n        pthread_exit( (void*)(uintptr_t) return_code );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nthread_ptr_t thread_create( int (*thread_proc)( void* ), void* user_data, int stack_size )\n    {\n    #if defined( _WIN32 )\n\n        DWORD thread_id;\n        HANDLE handle = CreateThread( NULL, stack_size > 0 ? (size_t)stack_size : 0U, \n            (LPTHREAD_START_ROUTINE)(uintptr_t) thread_proc, user_data, 0, &thread_id );\n        if( !handle ) return NULL;\n\n        return (thread_ptr_t) handle;\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_t thread;\n        if( 0 != pthread_create( &thread, NULL, ( void* (*)( void * ) ) thread_proc, user_data ) )\n            return NULL;\n\n        return (thread_ptr_t) thread;\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_destroy( thread_ptr_t thread )\n    {\n    #if defined( _WIN32 )\n\n        WaitForSingleObject( (HANDLE) thread, INFINITE );\n        CloseHandle( (HANDLE) thread );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_join( (pthread_t) thread, NULL );\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_join( thread_ptr_t thread )\n    {\n    #if defined( _WIN32 )\n\n        WaitForSingleObject( (HANDLE) thread, INFINITE );\n        DWORD retval;\n        GetExitCodeThread( (HANDLE) thread, &retval );\n        return (int) retval;\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        void* retval;\n        pthread_join( (pthread_t) thread, &retval );\n        return (int)(uintptr_t) retval;\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_detach( thread_ptr_t thread )\n    {\n    #if defined( _WIN32 )\n\n        return CloseHandle( (HANDLE) thread ) != 0;\n\n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return pthread_detach( (pthread_t) thread ) == 0;\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n    \nvoid thread_set_high_priority( void )\n    {\n    #if defined( _WIN32 )\n\n        SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        struct sched_param sp;\n        memset( &sp, 0, sizeof( sp ) );\n        sp.sched_priority = sched_get_priority_min( SCHED_RR );\n        pthread_setschedparam( pthread_self(), SCHED_RR, &sp);\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_mutex_init( thread_mutex_t* mutex )\n    {\n    #if defined( _WIN32 )\n\n        // Compile-time size check\n        #pragma warning( push )\n        #pragma warning( disable: 4214 ) // nonstandard extension used: bit field types other than int\n        struct x { char thread_mutex_type_too_small : ( sizeof( thread_mutex_t ) < sizeof( CRITICAL_SECTION ) ? 0 : 1 ); }; \n        #pragma warning( pop )\n\n        InitializeCriticalSectionAndSpinCount( (CRITICAL_SECTION*) mutex, 32 );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        // Compile-time size check\n        struct x { char thread_mutex_type_too_small : ( sizeof( thread_mutex_t ) < sizeof( pthread_mutex_t ) ? 0 : 1 ); };\n\n        pthread_mutex_init( (pthread_mutex_t*) mutex, NULL );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_mutex_term( thread_mutex_t* mutex )\n    {\n    #if defined( _WIN32 )\n        \n        DeleteCriticalSection( (CRITICAL_SECTION*) mutex );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_destroy( (pthread_mutex_t*) mutex );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_mutex_lock( thread_mutex_t* mutex )\n    {\n    #if defined( _WIN32 )\n\n        EnterCriticalSection( (CRITICAL_SECTION*) mutex );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_lock( (pthread_mutex_t*) mutex );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_mutex_unlock( thread_mutex_t* mutex )\n    {\n    #if defined( _WIN32 )\n\n        LeaveCriticalSection( (CRITICAL_SECTION*) mutex );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_unlock( (pthread_mutex_t*) mutex );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nstruct thread_internal_signal_t\n    {\n    #if defined( _WIN32 )\n\n        #if _WIN32_WINNT >= 0x0600\n            CRITICAL_SECTION mutex;\n            CONDITION_VARIABLE condition;\n            int value;\n        #else \n            #pragma message( \"Warning: _WIN32_WINNT < 0x0600 - condition variables not available\" )\n            HANDLE event;\n        #endif \n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_t mutex;\n        pthread_cond_t condition;\n        int value;\n\n    #else \n        #error Unknown platform.\n    #endif\n    };\n\n\nvoid thread_signal_init( thread_signal_t* signal )\n    {\n    // Compile-time size check\n    #pragma warning( push )\n    #pragma warning( disable: 4214 ) // nonstandard extension used: bit field types other than int\n    struct x { char thread_signal_type_too_small : ( sizeof( thread_signal_t ) < sizeof( struct thread_internal_signal_t ) ? 0 : 1 ); };\n    #pragma warning( pop )\n    \n    struct thread_internal_signal_t* internal = (struct thread_internal_signal_t*) signal;\n        \n    #if defined( _WIN32 )\n\n        #if _WIN32_WINNT >= 0x0600\n            InitializeCriticalSectionAndSpinCount( &internal->mutex, 32 );\n            InitializeConditionVariable( &internal->condition );\n            internal->value = 0;\n        #else \n            internal->event = CreateEvent( NULL, FALSE, FALSE, NULL );\n        #endif \n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_init( &internal->mutex, NULL );\n        pthread_cond_init( &internal->condition, NULL );\n        internal->value = 0;\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\n void thread_signal_term( thread_signal_t* signal )\n    {\n    struct thread_internal_signal_t* internal = (struct thread_internal_signal_t*) signal;\n\n    #if defined( _WIN32 )\n\n        #if _WIN32_WINNT >= 0x0600\n            DeleteCriticalSection( &internal->mutex );\n        #else \n            CloseHandle( internal->event );\n        #endif \n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_destroy( &internal->mutex );\n        pthread_cond_destroy( &internal->condition );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_signal_raise( thread_signal_t* signal )\n    {\n    struct thread_internal_signal_t* internal = (struct thread_internal_signal_t*) signal;\n\n    #if defined( _WIN32 )\n\n        #if _WIN32_WINNT >= 0x0600\n            EnterCriticalSection( &internal->mutex );\n            internal->value = 1;\n            LeaveCriticalSection( &internal->mutex );       \n            WakeConditionVariable( &internal->condition );\n        #else \n            SetEvent( internal->event );\n        #endif \n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_mutex_lock( &internal->mutex );\n        internal->value = 1;\n        pthread_mutex_unlock( &internal->mutex );\n        pthread_cond_signal( &internal->condition );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_signal_wait( thread_signal_t* signal, int timeout_ms )\n    {\n    struct thread_internal_signal_t* internal = (struct thread_internal_signal_t*) signal;\n\n    #if defined( _WIN32 )\n\n        #if _WIN32_WINNT >= 0x0600\n            int timed_out = 0;\n            EnterCriticalSection( &internal->mutex );\n            while( internal->value == 0 )\n                {\n                BOOL res = SleepConditionVariableCS( &internal->condition, &internal->mutex, timeout_ms < 0 ? INFINITE : timeout_ms );\n                if( !res && GetLastError() == ERROR_TIMEOUT ) { timed_out = 1; break; }\n                }\n            internal->value = 0;\n            LeaveCriticalSection( &internal->mutex );       \n            return !timed_out;\n        #else \n            int failed = WAIT_OBJECT_0 != WaitForSingleObject( internal->event, timeout_ms < 0 ? INFINITE : timeout_ms );\n            return !failed;\n        #endif \n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        struct timespec ts;\n        if( timeout_ms >= 0 )\n            {\n            struct timeval tv;\n            gettimeofday( &tv, NULL );\n            ts.tv_sec = time( NULL ) + timeout_ms / 1000;\n            ts.tv_nsec = tv.tv_usec * 1000 + 1000 * 1000 * ( timeout_ms % 1000 );\n            ts.tv_sec += ts.tv_nsec / ( 1000 * 1000 * 1000 );\n            ts.tv_nsec %= ( 1000 * 1000 * 1000 );\n            }\n\n        int timed_out = 0;\n        pthread_mutex_lock( &internal->mutex );\n        while( internal->value == 0 )\n            {\n            if( timeout_ms < 0 ) \n                pthread_cond_wait( &internal->condition, &internal->mutex );\n            else if( pthread_cond_timedwait( &internal->condition, &internal->mutex, &ts ) == ETIMEDOUT )\n                {\n                timed_out = 1;\n                break;\n                }\n\n            }           \n        if( !timed_out ) internal->value = 0;\n        pthread_mutex_unlock( &internal->mutex );\n        return !timed_out;\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_load( thread_atomic_int_t* atomic )\n    {\n    #if defined( _WIN32 )\n\n        return InterlockedCompareExchange( &atomic->i, 0, 0 );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return (int)__sync_fetch_and_add( &atomic->i, 0 );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_atomic_int_store( thread_atomic_int_t* atomic, int desired )\n    {\n    #if defined( _WIN32 )\n    \n        InterlockedExchange( &atomic->i, desired );\n\n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        __sync_fetch_and_and( &atomic->i, 0 );\n        __sync_fetch_and_or( &atomic->i, desired );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_inc( thread_atomic_int_t* atomic )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedIncrement( &atomic->i ) - 1;\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return (int)__sync_fetch_and_add( &atomic->i, 1 );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_dec( thread_atomic_int_t* atomic )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedDecrement( &atomic->i ) + 1;\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return (int)__sync_fetch_and_sub( &atomic->i, 1 );\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_add( thread_atomic_int_t* atomic, int value )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedExchangeAdd ( &atomic->i, value );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return (int)__sync_fetch_and_add( &atomic->i, value );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_sub( thread_atomic_int_t* atomic, int value )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedExchangeAdd( &atomic->i, -value );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return (int)__sync_fetch_and_sub( &atomic->i, value );\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_swap( thread_atomic_int_t* atomic, int desired )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedExchange( &atomic->i, desired );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        int old = (int)__sync_lock_test_and_set( &atomic->i, desired );\n        __sync_lock_release( &atomic->i );\n        return old;\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nint thread_atomic_int_compare_and_swap( thread_atomic_int_t* atomic, int expected, int desired )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedCompareExchange( &atomic->i, desired, expected );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return (int)__sync_val_compare_and_swap( &atomic->i, expected, desired );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid* thread_atomic_ptr_load( thread_atomic_ptr_t* atomic )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedCompareExchangePointer( &atomic->ptr, 0, 0 );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return __sync_fetch_and_add( &atomic->ptr, 0 );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_atomic_ptr_store( thread_atomic_ptr_t* atomic, void* desired )\n    {\n    #if defined( _WIN32 )\n    \n        #pragma warning( push )\n        #pragma warning( disable: 4302 ) // 'type cast' : truncation from 'void *' to 'LONG'\n        #pragma warning( disable: 4311 ) // pointer truncation from 'void *' to 'LONG'\n        #pragma warning( disable: 4312 ) // conversion from 'LONG' to 'PVOID' of greater size\n        InterlockedExchangePointer( &atomic->ptr, desired );\n        #pragma warning( pop )\n\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        __sync_lock_test_and_set( &atomic->ptr, desired );\n        __sync_lock_release( &atomic->ptr );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid* thread_atomic_ptr_swap( thread_atomic_ptr_t* atomic, void* desired )\n    {\n    #if defined( _WIN32 )\n    \n        #pragma warning( push )\n        #pragma warning( disable: 4302 ) // 'type cast' : truncation from 'void *' to 'LONG'\n        #pragma warning( disable: 4311 ) // pointer truncation from 'void *' to 'LONG'\n        #pragma warning( disable: 4312 ) // conversion from 'LONG' to 'PVOID' of greater size\n        return InterlockedExchangePointer( &atomic->ptr, desired );\n        #pragma warning( pop )\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        void* old = __sync_lock_test_and_set( &atomic->ptr, desired );\n        __sync_lock_release( &atomic->ptr );\n        return old;\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid* thread_atomic_ptr_compare_and_swap( thread_atomic_ptr_t* atomic, void* expected, void* desired )\n    {\n    #if defined( _WIN32 )\n    \n        return InterlockedCompareExchangePointer( &atomic->ptr, desired, expected );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return __sync_val_compare_and_swap( &atomic->ptr, expected, desired );\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_timer_init( thread_timer_t* timer )\n    {\n    #if defined( _WIN32 )\n\n        // Compile-time size check\n        #pragma warning( push )\n        #pragma warning( disable: 4214 ) // nonstandard extension used: bit field types other than int\n        struct x { char thread_timer_type_too_small : ( sizeof( thread_mutex_t ) < sizeof( HANDLE ) ? 0 : 1 ); }; \n        #pragma warning( pop )\n\n        TIMECAPS tc;\n        if( timeGetDevCaps( &tc, sizeof( TIMECAPS ) ) == TIMERR_NOERROR ) \n            timeBeginPeriod( tc.wPeriodMin );\n\n        *(HANDLE*)timer = CreateWaitableTimer( NULL, TRUE, NULL );\n\n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        // Nothing\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_timer_term( thread_timer_t* timer )\n    {\n    #if defined( _WIN32 )\n\n        CloseHandle( *(HANDLE*)timer );\n    \n        TIMECAPS tc;\n        if( timeGetDevCaps( &tc, sizeof( TIMECAPS ) ) == TIMERR_NOERROR ) \n            timeEndPeriod( tc.wPeriodMin );\n\n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        // Nothing\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_timer_wait( thread_timer_t* timer, THREAD_U64 nanoseconds )\n    {\n    #if defined( _WIN32 )\n\n        LARGE_INTEGER due_time;\n        due_time.QuadPart = - (LONGLONG) ( nanoseconds / 100 );\n        BOOL b = SetWaitableTimer( *(HANDLE*)timer, &due_time, 0, 0, 0, FALSE );\n        (void) b;\n        WaitForSingleObject( *(HANDLE*)timer, INFINITE ); \n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        struct timespec rem;\n        struct timespec req;\n        req.tv_sec = nanoseconds / 1000000000ULL;\n        req.tv_nsec = nanoseconds - req.tv_sec * 1000000000ULL;\n        while( nanosleep( &req, &rem ) )\n            req = rem;\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nthread_tls_t thread_tls_create( void )\n    {\n    #if defined( _WIN32 )\n\n        DWORD tls = TlsAlloc();      \n        if( tls == TLS_OUT_OF_INDEXES )\n            return NULL;\n        else\n            return (thread_tls_t) (uintptr_t) tls;\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_key_t tls;\n        if( pthread_key_create( &tls, NULL ) == 0 )\n            return (thread_tls_t) tls;\n        else\n            return NULL;\n\n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_tls_destroy( thread_tls_t tls )\n    {\n    #if defined( _WIN32 )\n\n        TlsFree( (DWORD) (uintptr_t) tls );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_key_delete( (pthread_key_t) (uintptr_t) tls );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_tls_set( thread_tls_t tls, void* value )\n    {\n    #if defined( _WIN32 )\n\n        TlsSetValue( (DWORD) (uintptr_t) tls, value );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        pthread_setspecific( (pthread_key_t) (uintptr_t) tls, value );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid* thread_tls_get( thread_tls_t tls )\n    {\n    #if defined( _WIN32 )\n\n        return TlsGetValue( (DWORD) (uintptr_t) tls );\n    \n    #elif defined( __linux__ ) || defined( __APPLE__ ) || defined( __ANDROID__ )\n\n        return pthread_getspecific( (pthread_key_t) (uintptr_t) tls );\n    \n    #else \n        #error Unknown platform.\n    #endif\n    }\n\n\nvoid thread_queue_init( thread_queue_t* queue, int size, void** values, int count )\n    {\n    queue->values = values;\n    thread_signal_init( &queue->data_ready );\n    thread_signal_init( &queue->space_open );\n    thread_atomic_int_store( &queue->head, 0 );\n    thread_atomic_int_store( &queue->tail, count > size ? size : count );\n    thread_atomic_int_store( &queue->count, count > size ? size : count );\n    queue->size = size;\n    #ifndef NDEBUG\n        thread_atomic_int_store( &queue->id_produce_is_set, 0 );\n        thread_atomic_int_store( &queue->id_consume_is_set, 0 );\n    #endif\n    }\n\n\nvoid thread_queue_term( thread_queue_t* queue )\n    {\n    thread_signal_term( &queue->space_open );\n    thread_signal_term( &queue->data_ready );\n    }\n\n\nint thread_queue_produce( thread_queue_t* queue, void* value, int timeout_ms )\n    {\n    #ifndef NDEBUG\n        if( thread_atomic_int_compare_and_swap( &queue->id_produce_is_set, 0, 1 ) == 0 )\n            queue->id_produce = thread_current_thread_id();\n        THREAD_ASSERT( thread_current_thread_id() == queue->id_produce, \"thread_queue_produce called from multiple threads\" );\n    #endif\n    while( thread_atomic_int_load( &queue->count ) == queue->size )  // TODO: fix signal so that this can be an \"if\" instead of \"while\"\n        {\n        if( timeout_ms == 0 ) return 0;\n        if( thread_signal_wait( &queue->space_open, timeout_ms == THREAD_QUEUE_WAIT_INFINITE ? THREAD_SIGNAL_WAIT_INFINITE : timeout_ms ) == 0 )\n            return 0;\n        }\n    int tail = thread_atomic_int_inc( &queue->tail );\n    queue->values[ tail % queue->size ] = value;\n    if( thread_atomic_int_inc( &queue->count ) == 0 )\n        thread_signal_raise( &queue->data_ready );\n    return 1;\n    }\n\n\nvoid* thread_queue_consume( thread_queue_t* queue, int timeout_ms )\n    {\n    #ifndef NDEBUG\n        if( thread_atomic_int_compare_and_swap( &queue->id_consume_is_set, 0, 1 ) == 0 )\n            queue->id_consume = thread_current_thread_id();\n        THREAD_ASSERT( thread_current_thread_id() == queue->id_consume, \"thread_queue_consume called from multiple threads\" );\n    #endif\n    while( thread_atomic_int_load( &queue->count ) == 0 ) // TODO: fix signal so that this can be an \"if\" instead of \"while\"\n        {\n        if( timeout_ms == 0 ) return NULL;\n        if( thread_signal_wait( &queue->data_ready, timeout_ms == THREAD_QUEUE_WAIT_INFINITE ? THREAD_SIGNAL_WAIT_INFINITE : timeout_ms ) == 0 )\n            return NULL;\n        }\n    int head = thread_atomic_int_inc( &queue->head );\n    void* retval = queue->values[ head % queue->size ];\n    if( thread_atomic_int_dec( &queue->count ) == queue->size )\n        thread_signal_raise( &queue->space_open );\n    return retval;\n    }\n\n    \nint thread_queue_count( thread_queue_t* queue )\n    {\n    return thread_atomic_int_load( &queue->count );\n    }\n\n\n#endif /* THREAD_IMPLEMENTATION */\n\n/*\nrevision history:\n    0.3     set_high_priority API change. Fixed spurious wakeup bug in signal. Added \n            timeout param to queue produce/consume. Various cleanup and trivial fixes.\n    0.2     first publicly released version \n*/\n\n/*\n------------------------------------------------------------------------------\n\nThis software is available under 2 licenses - you may choose the one you like.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE A - MIT License\n\nCopyright (c) 2015 Mattias Gustavsson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of \nthis software and associated documentation files (the \"Software\"), to deal in \nthe Software without restriction, including without limitation the rights to \nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software is furnished to do \nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \nSOFTWARE.\n\n------------------------------------------------------------------------------\n\nALTERNATIVE B - Public Domain (www.unlicense.org)\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this \nsoftware, either in source code form or as a compiled binary, for any purpose, \ncommercial or non-commercial, and by any means.\n\nIn jurisdictions that recognize copyright laws, the author or authors of this \nsoftware dedicate any and all copyright interest in the software to the public \ndomain. We make this dedication for the benefit of the public at large and to \nthe detriment of our heirs and successors. We intend this dedication to be an \novert act of relinquishment in perpetuity of all present and future rights to \nthis software under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN \nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n------------------------------------------------------------------------------\n*/\n"
        }
      ]
    }
  ]
}