{
  "metadata": {
    "timestamp": 1736709933009,
    "page": 461,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "adafruit/Adafruit-GFX-Library",
      "stars": 2450,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.109375,
          "content": "default.vim\nfontconvert/fontconvert\n# Our handy .gitignore for automation ease\nDoxyfile*\ndoxygen_sqlite3.db\nhtml"
        },
        {
          "name": "Adafruit_GFX.cpp",
          "type": "blob",
          "size": 91.28515625,
          "content": "/*\nThis is the core graphics library for all our displays, providing a common\nset of graphics primitives (points, lines, circles, etc.).  It needs to be\npaired with a hardware-specific library for each display device we carry\n(to handle the lower-level functions).\n\nAdafruit invests time and resources providing this open source code, please\nsupport Adafruit & open-source hardware by purchasing products from Adafruit!\n\nCopyright (c) 2013 Adafruit Industries.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"Adafruit_GFX.h\"\n#include \"glcdfont.c\"\n#ifdef __AVR__\n#include <avr/pgmspace.h>\n#elif defined(ESP8266) || defined(ESP32)\n#include <pgmspace.h>\n#endif\n\n// Many (but maybe not all) non-AVR board installs define macros\n// for compatibility with existing PROGMEM-reading AVR code.\n// Do our own checks and defines here for good measure...\n\n#ifndef pgm_read_byte\n#define pgm_read_byte(addr) (*(const unsigned char *)(addr))\n#endif\n#ifndef pgm_read_word\n#define pgm_read_word(addr) (*(const unsigned short *)(addr))\n#endif\n#ifndef pgm_read_dword\n#define pgm_read_dword(addr) (*(const unsigned long *)(addr))\n#endif\n\n// Pointers are a peculiar case...typically 16-bit on AVR boards,\n// 32 bits elsewhere.  Try to accommodate both...\n\n#if !defined(__INT_MAX__) || (__INT_MAX__ > 0xFFFF)\n#define pgm_read_pointer(addr) ((void *)pgm_read_dword(addr))\n#else\n#define pgm_read_pointer(addr) ((void *)pgm_read_word(addr))\n#endif\n\ninline GFXglyph *pgm_read_glyph_ptr(const GFXfont *gfxFont, uint8_t c) {\n#ifdef __AVR__\n  return &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);\n#else\n  // expression in __AVR__ section may generate \"dereferencing type-punned\n  // pointer will break strict-aliasing rules\" warning In fact, on other\n  // platforms (such as STM32) there is no need to do this pointer magic as\n  // program memory may be read in a usual way So expression may be simplified\n  return gfxFont->glyph + c;\n#endif //__AVR__\n}\n\ninline uint8_t *pgm_read_bitmap_ptr(const GFXfont *gfxFont) {\n#ifdef __AVR__\n  return (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);\n#else\n  // expression in __AVR__ section generates \"dereferencing type-punned pointer\n  // will break strict-aliasing rules\" warning In fact, on other platforms (such\n  // as STM32) there is no need to do this pointer magic as program memory may\n  // be read in a usual way So expression may be simplified\n  return gfxFont->bitmap;\n#endif //__AVR__\n}\n\n#ifndef min\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\n#ifndef _swap_int16_t\n#define _swap_int16_t(a, b)                                                    \\\n  {                                                                            \\\n    int16_t t = a;                                                             \\\n    a = b;                                                                     \\\n    b = t;                                                                     \\\n  }\n#endif\n\n/**************************************************************************/\n/*!\n   @brief    Instatiate a GFX context for graphics! Can only be done by a\n   superclass\n   @param    w   Display width, in pixels\n   @param    h   Display height, in pixels\n*/\n/**************************************************************************/\nAdafruit_GFX::Adafruit_GFX(int16_t w, int16_t h) : WIDTH(w), HEIGHT(h) {\n  _width = WIDTH;\n  _height = HEIGHT;\n  rotation = 0;\n  cursor_y = cursor_x = 0;\n  textsize_x = textsize_y = 1;\n  textcolor = textbgcolor = 0xFFFF;\n  wrap = true;\n  _cp437 = false;\n  gfxFont = NULL;\n}\n\n/**************************************************************************/\n/*!\n   @brief    Write a line.  Bresenham's algorithm - thx wikpedia\n    @param    x0  Start point x coordinate\n    @param    y0  Start point y coordinate\n    @param    x1  End point x coordinate\n    @param    y1  End point y coordinate\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,\n                             uint16_t color) {\n#if defined(ESP8266)\n  yield();\n#endif\n  int16_t steep = abs(y1 - y0) > abs(x1 - x0);\n  if (steep) {\n    _swap_int16_t(x0, y0);\n    _swap_int16_t(x1, y1);\n  }\n\n  if (x0 > x1) {\n    _swap_int16_t(x0, x1);\n    _swap_int16_t(y0, y1);\n  }\n\n  int16_t dx, dy;\n  dx = x1 - x0;\n  dy = abs(y1 - y0);\n\n  int16_t err = dx / 2;\n  int16_t ystep;\n\n  if (y0 < y1) {\n    ystep = 1;\n  } else {\n    ystep = -1;\n  }\n\n  for (; x0 <= x1; x0++) {\n    if (steep) {\n      writePixel(y0, x0, color);\n    } else {\n      writePixel(x0, y0, color);\n    }\n    err -= dy;\n    if (err < 0) {\n      y0 += ystep;\n      err += dx;\n    }\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Start a display-writing routine, overwrite in subclasses.\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::startWrite() {}\n\n/**************************************************************************/\n/*!\n   @brief    Write a pixel, overwrite in subclasses if startWrite is defined!\n    @param   x   x coordinate\n    @param   y   y coordinate\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color) {\n  drawPixel(x, y, color);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Write a perfectly vertical line, overwrite in subclasses if\n   startWrite is defined!\n    @param    x   Top-most x coordinate\n    @param    y   Top-most y coordinate\n    @param    h   Height in pixels\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::writeFastVLine(int16_t x, int16_t y, int16_t h,\n                                  uint16_t color) {\n  // Overwrite in subclasses if startWrite is defined!\n  // Can be just writeLine(x, y, x, y+h-1, color);\n  // or writeFillRect(x, y, 1, h, color);\n  drawFastVLine(x, y, h, color);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Write a perfectly horizontal line, overwrite in subclasses if\n   startWrite is defined!\n    @param    x   Left-most x coordinate\n    @param    y   Left-most y coordinate\n    @param    w   Width in pixels\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::writeFastHLine(int16_t x, int16_t y, int16_t w,\n                                  uint16_t color) {\n  // Overwrite in subclasses if startWrite is defined!\n  // Example: writeLine(x, y, x+w-1, y, color);\n  // or writeFillRect(x, y, w, 1, color);\n  drawFastHLine(x, y, w, color);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Write a rectangle completely with one color, overwrite in\n   subclasses if startWrite is defined!\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    w   Width in pixels\n    @param    h   Height in pixels\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                                 uint16_t color) {\n  // Overwrite in subclasses if desired!\n  fillRect(x, y, w, h, color);\n}\n\n/**************************************************************************/\n/*!\n   @brief    End a display-writing routine, overwrite in subclasses if\n   startWrite is defined!\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::endWrite() {}\n\n/**************************************************************************/\n/*!\n   @brief    Draw a perfectly vertical line (this is often optimized in a\n   subclass!)\n    @param    x   Top-most x coordinate\n    @param    y   Top-most y coordinate\n    @param    h   Height in pixels\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,\n                                 uint16_t color) {\n  startWrite();\n  writeLine(x, y, x, y + h - 1, color);\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief    Draw a perfectly horizontal line (this is often optimized in a\n   subclass!)\n    @param    x   Left-most x coordinate\n    @param    y   Left-most y coordinate\n    @param    w   Width in pixels\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w,\n                                 uint16_t color) {\n  startWrite();\n  writeLine(x, y, x + w - 1, y, color);\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief    Fill a rectangle completely with one color. Update in subclasses if\n   desired!\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    w   Width in pixels\n    @param    h   Height in pixels\n   @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                            uint16_t color) {\n  startWrite();\n  for (int16_t i = x; i < x + w; i++) {\n    writeFastVLine(i, y, h, color);\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief    Fill the screen completely with one color. Update in subclasses if\n   desired!\n    @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::fillScreen(uint16_t color) {\n  fillRect(0, 0, _width, _height, color);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Draw a line\n    @param    x0  Start point x coordinate\n    @param    y0  Start point y coordinate\n    @param    x1  End point x coordinate\n    @param    y1  End point y coordinate\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,\n                            uint16_t color) {\n  // Update in subclasses if desired!\n  if (x0 == x1) {\n    if (y0 > y1)\n      _swap_int16_t(y0, y1);\n    drawFastVLine(x0, y0, y1 - y0 + 1, color);\n  } else if (y0 == y1) {\n    if (x0 > x1)\n      _swap_int16_t(x0, x1);\n    drawFastHLine(x0, y0, x1 - x0 + 1, color);\n  } else {\n    startWrite();\n    writeLine(x0, y0, x1, y1, color);\n    endWrite();\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Draw a circle outline\n    @param    x0   Center-point x coordinate\n    @param    y0   Center-point y coordinate\n    @param    r   Radius of circle\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawCircle(int16_t x0, int16_t y0, int16_t r,\n                              uint16_t color) {\n#if defined(ESP8266)\n  yield();\n#endif\n  int16_t f = 1 - r;\n  int16_t ddF_x = 1;\n  int16_t ddF_y = -2 * r;\n  int16_t x = 0;\n  int16_t y = r;\n\n  startWrite();\n  writePixel(x0, y0 + r, color);\n  writePixel(x0, y0 - r, color);\n  writePixel(x0 + r, y0, color);\n  writePixel(x0 - r, y0, color);\n\n  while (x < y) {\n    if (f >= 0) {\n      y--;\n      ddF_y += 2;\n      f += ddF_y;\n    }\n    x++;\n    ddF_x += 2;\n    f += ddF_x;\n\n    writePixel(x0 + x, y0 + y, color);\n    writePixel(x0 - x, y0 + y, color);\n    writePixel(x0 + x, y0 - y, color);\n    writePixel(x0 - x, y0 - y, color);\n    writePixel(x0 + y, y0 + x, color);\n    writePixel(x0 - y, y0 + x, color);\n    writePixel(x0 + y, y0 - x, color);\n    writePixel(x0 - y, y0 - x, color);\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n    @brief    Quarter-circle drawer, used to do circles and roundrects\n    @param    x0   Center-point x coordinate\n    @param    y0   Center-point y coordinate\n    @param    r   Radius of circle\n    @param    cornername  Mask bit #1 or bit #2 to indicate which quarters of\n   the circle we're doing\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawCircleHelper(int16_t x0, int16_t y0, int16_t r,\n                                    uint8_t cornername, uint16_t color) {\n  int16_t f = 1 - r;\n  int16_t ddF_x = 1;\n  int16_t ddF_y = -2 * r;\n  int16_t x = 0;\n  int16_t y = r;\n\n  while (x < y) {\n    if (f >= 0) {\n      y--;\n      ddF_y += 2;\n      f += ddF_y;\n    }\n    x++;\n    ddF_x += 2;\n    f += ddF_x;\n    if (cornername & 0x4) {\n      writePixel(x0 + x, y0 + y, color);\n      writePixel(x0 + y, y0 + x, color);\n    }\n    if (cornername & 0x2) {\n      writePixel(x0 + x, y0 - y, color);\n      writePixel(x0 + y, y0 - x, color);\n    }\n    if (cornername & 0x8) {\n      writePixel(x0 - y, y0 + x, color);\n      writePixel(x0 - x, y0 + y, color);\n    }\n    if (cornername & 0x1) {\n      writePixel(x0 - y, y0 - x, color);\n      writePixel(x0 - x, y0 - y, color);\n    }\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Draw a circle with filled color\n    @param    x0   Center-point x coordinate\n    @param    y0   Center-point y coordinate\n    @param    r   Radius of circle\n    @param    color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::fillCircle(int16_t x0, int16_t y0, int16_t r,\n                              uint16_t color) {\n  startWrite();\n  writeFastVLine(x0, y0 - r, 2 * r + 1, color);\n  fillCircleHelper(x0, y0, r, 3, 0, color);\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n    @brief  Quarter-circle drawer with fill, used for circles and roundrects\n    @param  x0       Center-point x coordinate\n    @param  y0       Center-point y coordinate\n    @param  r        Radius of circle\n    @param  corners  Mask bits indicating which quarters we're doing\n    @param  delta    Offset from center-point, used for round-rects\n    @param  color    16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::fillCircleHelper(int16_t x0, int16_t y0, int16_t r,\n                                    uint8_t corners, int16_t delta,\n                                    uint16_t color) {\n\n  int16_t f = 1 - r;\n  int16_t ddF_x = 1;\n  int16_t ddF_y = -2 * r;\n  int16_t x = 0;\n  int16_t y = r;\n  int16_t px = x;\n  int16_t py = y;\n\n  delta++; // Avoid some +1's in the loop\n\n  while (x < y) {\n    if (f >= 0) {\n      y--;\n      ddF_y += 2;\n      f += ddF_y;\n    }\n    x++;\n    ddF_x += 2;\n    f += ddF_x;\n    // These checks avoid double-drawing certain lines, important\n    // for the SSD1306 library which has an INVERT drawing mode.\n    if (x < (y + 1)) {\n      if (corners & 1)\n        writeFastVLine(x0 + x, y0 - y, 2 * y + delta, color);\n      if (corners & 2)\n        writeFastVLine(x0 - x, y0 - y, 2 * y + delta, color);\n    }\n    if (y != py) {\n      if (corners & 1)\n        writeFastVLine(x0 + py, y0 - px, 2 * px + delta, color);\n      if (corners & 2)\n        writeFastVLine(x0 - py, y0 - px, 2 * px + delta, color);\n      py = y;\n    }\n    px = x;\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a rectangle with no fill color\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    w   Width in pixels\n    @param    h   Height in pixels\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                            uint16_t color) {\n  startWrite();\n  writeFastHLine(x, y, w, color);\n  writeFastHLine(x, y + h - 1, w, color);\n  writeFastVLine(x, y, h, color);\n  writeFastVLine(x + w - 1, y, h, color);\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a rounded rectangle with no fill color\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    w   Width in pixels\n    @param    h   Height in pixels\n    @param    r   Radius of corner rounding\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawRoundRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                                 int16_t r, uint16_t color) {\n  int16_t max_radius = ((w < h) ? w : h) / 2; // 1/2 minor axis\n  if (r > max_radius)\n    r = max_radius;\n  // smarter version\n  startWrite();\n  writeFastHLine(x + r, y, w - 2 * r, color);         // Top\n  writeFastHLine(x + r, y + h - 1, w - 2 * r, color); // Bottom\n  writeFastVLine(x, y + r, h - 2 * r, color);         // Left\n  writeFastVLine(x + w - 1, y + r, h - 2 * r, color); // Right\n  // draw four corners\n  drawCircleHelper(x + r, y + r, r, 1, color);\n  drawCircleHelper(x + w - r - 1, y + r, r, 2, color);\n  drawCircleHelper(x + w - r - 1, y + h - r - 1, r, 4, color);\n  drawCircleHelper(x + r, y + h - r - 1, r, 8, color);\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a rounded rectangle with fill color\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    w   Width in pixels\n    @param    h   Height in pixels\n    @param    r   Radius of corner rounding\n    @param    color 16-bit 5-6-5 Color to draw/fill with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::fillRoundRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                                 int16_t r, uint16_t color) {\n  int16_t max_radius = ((w < h) ? w : h) / 2; // 1/2 minor axis\n  if (r > max_radius)\n    r = max_radius;\n  // smarter version\n  startWrite();\n  writeFillRect(x + r, y, w - 2 * r, h, color);\n  // draw four corners\n  fillCircleHelper(x + w - r - 1, y + r, r, 1, h - 2 * r - 1, color);\n  fillCircleHelper(x + r, y + r, r, 2, h - 2 * r - 1, color);\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a triangle with no fill color\n    @param    x0  Vertex #0 x coordinate\n    @param    y0  Vertex #0 y coordinate\n    @param    x1  Vertex #1 x coordinate\n    @param    y1  Vertex #1 y coordinate\n    @param    x2  Vertex #2 x coordinate\n    @param    y2  Vertex #2 y coordinate\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1,\n                                int16_t x2, int16_t y2, uint16_t color) {\n  drawLine(x0, y0, x1, y1, color);\n  drawLine(x1, y1, x2, y2, color);\n  drawLine(x2, y2, x0, y0, color);\n}\n\n/**************************************************************************/\n/*!\n   @brief     Draw a triangle with color-fill\n    @param    x0  Vertex #0 x coordinate\n    @param    y0  Vertex #0 y coordinate\n    @param    x1  Vertex #1 x coordinate\n    @param    y1  Vertex #1 y coordinate\n    @param    x2  Vertex #2 x coordinate\n    @param    y2  Vertex #2 y coordinate\n    @param    color 16-bit 5-6-5 Color to fill/draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1,\n                                int16_t x2, int16_t y2, uint16_t color) {\n\n  int16_t a, b, y, last;\n\n  // Sort coordinates by Y order (y2 >= y1 >= y0)\n  if (y0 > y1) {\n    _swap_int16_t(y0, y1);\n    _swap_int16_t(x0, x1);\n  }\n  if (y1 > y2) {\n    _swap_int16_t(y2, y1);\n    _swap_int16_t(x2, x1);\n  }\n  if (y0 > y1) {\n    _swap_int16_t(y0, y1);\n    _swap_int16_t(x0, x1);\n  }\n\n  startWrite();\n  if (y0 == y2) { // Handle awkward all-on-same-line case as its own thing\n    a = b = x0;\n    if (x1 < a)\n      a = x1;\n    else if (x1 > b)\n      b = x1;\n    if (x2 < a)\n      a = x2;\n    else if (x2 > b)\n      b = x2;\n    writeFastHLine(a, y0, b - a + 1, color);\n    endWrite();\n    return;\n  }\n\n  int16_t dx01 = x1 - x0, dy01 = y1 - y0, dx02 = x2 - x0, dy02 = y2 - y0,\n          dx12 = x2 - x1, dy12 = y2 - y1;\n  int32_t sa = 0, sb = 0;\n\n  // For upper part of triangle, find scanline crossings for segments\n  // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1\n  // is included here (and second loop will be skipped, avoiding a /0\n  // error there), otherwise scanline y1 is skipped here and handled\n  // in the second loop...which also avoids a /0 error here if y0=y1\n  // (flat-topped triangle).\n  if (y1 == y2)\n    last = y1; // Include y1 scanline\n  else\n    last = y1 - 1; // Skip it\n\n  for (y = y0; y <= last; y++) {\n    a = x0 + sa / dy01;\n    b = x0 + sb / dy02;\n    sa += dx01;\n    sb += dx02;\n    /* longhand:\n    a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);\n    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);\n    */\n    if (a > b)\n      _swap_int16_t(a, b);\n    writeFastHLine(a, y, b - a + 1, color);\n  }\n\n  // For lower part of triangle, find scanline crossings for segments\n  // 0-2 and 1-2.  This loop is skipped if y1=y2.\n  sa = (int32_t)dx12 * (y - y1);\n  sb = (int32_t)dx02 * (y - y0);\n  for (; y <= y2; y++) {\n    a = x1 + sa / dy12;\n    b = x0 + sb / dy02;\n    sa += dx12;\n    sb += dx02;\n    /* longhand:\n    a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);\n    b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);\n    */\n    if (a > b)\n      _swap_int16_t(a, b);\n    writeFastHLine(a, y, b - a + 1, color);\n  }\n  endWrite();\n}\n\n// BITMAP / XBITMAP / GRAYSCALE / RGB BITMAP FUNCTIONS ---------------------\n\n/**************************************************************************/\n/*!\n   @brief      Draw a PROGMEM-resident 1-bit image at the specified (x,y)\n   position, using the specified foreground color (unset bits are transparent).\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with monochrome bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[],\n                              int16_t w, int16_t h, uint16_t color) {\n\n  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte\n  uint8_t b = 0;\n\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);\n      if (b & 0x80)\n        writePixel(x + i, y, color);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief      Draw a PROGMEM-resident 1-bit image at the specified (x,y)\n   position, using the specified foreground (for set bits) and background (unset\n   bits) colors.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with monochrome bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n    @param    color 16-bit 5-6-5 Color to draw pixels with\n    @param    bg 16-bit 5-6-5 Color to draw background with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[],\n                              int16_t w, int16_t h, uint16_t color,\n                              uint16_t bg) {\n\n  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte\n  uint8_t b = 0;\n\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);\n      writePixel(x + i, y, (b & 0x80) ? color : bg);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief      Draw a RAM-resident 1-bit image at the specified (x,y) position,\n   using the specified foreground color (unset bits are transparent).\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with monochrome bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n    @param    color 16-bit 5-6-5 Color to draw with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,\n                              int16_t h, uint16_t color) {\n\n  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte\n  uint8_t b = 0;\n\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = bitmap[j * byteWidth + i / 8];\n      if (b & 0x80)\n        writePixel(x + i, y, color);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief      Draw a RAM-resident 1-bit image at the specified (x,y) position,\n   using the specified foreground (for set bits) and background (unset bits)\n   colors.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with monochrome bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n    @param    color 16-bit 5-6-5 Color to draw pixels with\n    @param    bg 16-bit 5-6-5 Color to draw background with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,\n                              int16_t h, uint16_t color, uint16_t bg) {\n\n  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte\n  uint8_t b = 0;\n\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = bitmap[j * byteWidth + i / 8];\n      writePixel(x + i, y, (b & 0x80) ? color : bg);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief      Draw PROGMEM-resident XBitMap Files (*.xbm), exported from GIMP.\n   Usage: Export from GIMP to *.xbm, rename *.xbm to *.c and open in editor.\n   C Array can be directly used with this function.\n   There is no RAM-resident version of this function; if generating bitmaps\n   in RAM, use the format defined by drawBitmap() and call that instead.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with monochrome bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n    @param    color 16-bit 5-6-5 Color to draw pixels with\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawXBitmap(int16_t x, int16_t y, const uint8_t bitmap[],\n                               int16_t w, int16_t h, uint16_t color) {\n\n  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte\n  uint8_t b = 0;\n\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b >>= 1;\n      else\n        b = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);\n      // Nearly identical to drawBitmap(), only the bit order\n      // is reversed here (left-to-right = LSB to MSB):\n      if (b & 0x01)\n        writePixel(x + i, y, color);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a PROGMEM-resident 8-bit image (grayscale) at the specified\n   (x,y) pos. Specifically for 8-bit display devices such as IS31FL3731; no\n   color reduction/expansion is performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with grayscale bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawGrayscaleBitmap(int16_t x, int16_t y,\n                                       const uint8_t bitmap[], int16_t w,\n                                       int16_t h) {\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      writePixel(x + i, y, (uint8_t)pgm_read_byte(&bitmap[j * w + i]));\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a RAM-resident 8-bit image (grayscale) at the specified (x,y)\n   pos. Specifically for 8-bit display devices such as IS31FL3731; no color\n   reduction/expansion is performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with grayscale bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawGrayscaleBitmap(int16_t x, int16_t y, uint8_t *bitmap,\n                                       int16_t w, int16_t h) {\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      writePixel(x + i, y, bitmap[j * w + i]);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a PROGMEM-resident 8-bit image (grayscale) with a 1-bit mask\n   (set bits = opaque, unset bits = clear) at the specified (x,y) position.\n   BOTH buffers (grayscale and mask) must be PROGMEM-resident.\n   Specifically for 8-bit display devices such as IS31FL3731; no color\n   reduction/expansion is performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with grayscale bitmap\n    @param    mask  byte array with mask bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawGrayscaleBitmap(int16_t x, int16_t y,\n                                       const uint8_t bitmap[],\n                                       const uint8_t mask[], int16_t w,\n                                       int16_t h) {\n  int16_t bw = (w + 7) / 8; // Bitmask scanline pad = whole byte\n  uint8_t b = 0;\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = pgm_read_byte(&mask[j * bw + i / 8]);\n      if (b & 0x80) {\n        writePixel(x + i, y, (uint8_t)pgm_read_byte(&bitmap[j * w + i]));\n      }\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a RAM-resident 8-bit image (grayscale) with a 1-bit mask\n   (set bits = opaque, unset bits = clear) at the specified (x,y) position.\n   BOTH buffers (grayscale and mask) must be RAM-residentt, no mix-and-match\n   Specifically for 8-bit display devices such as IS31FL3731; no color\n   reduction/expansion is performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with grayscale bitmap\n    @param    mask  byte array with mask bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawGrayscaleBitmap(int16_t x, int16_t y, uint8_t *bitmap,\n                                       uint8_t *mask, int16_t w, int16_t h) {\n  int16_t bw = (w + 7) / 8; // Bitmask scanline pad = whole byte\n  uint8_t b = 0;\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = mask[j * bw + i / 8];\n      if (b & 0x80) {\n        writePixel(x + i, y, bitmap[j * w + i]);\n      }\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a PROGMEM-resident 16-bit image (RGB 5/6/5) at the specified\n   (x,y) position. For 16-bit display devices; no color reduction performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with 16-bit color bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawRGBBitmap(int16_t x, int16_t y, const uint16_t bitmap[],\n                                 int16_t w, int16_t h) {\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      writePixel(x + i, y, pgm_read_word(&bitmap[j * w + i]));\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a RAM-resident 16-bit image (RGB 5/6/5) at the specified (x,y)\n   position. For 16-bit display devices; no color reduction performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with 16-bit color bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawRGBBitmap(int16_t x, int16_t y, uint16_t *bitmap,\n                                 int16_t w, int16_t h) {\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      writePixel(x + i, y, bitmap[j * w + i]);\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a PROGMEM-resident 16-bit image (RGB 5/6/5) with a 1-bit mask\n   (set bits = opaque, unset bits = clear) at the specified (x,y) position. BOTH\n   buffers (color and mask) must be PROGMEM-resident. For 16-bit display\n   devices; no color reduction performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with 16-bit color bitmap\n    @param    mask  byte array with monochrome mask bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawRGBBitmap(int16_t x, int16_t y, const uint16_t bitmap[],\n                                 const uint8_t mask[], int16_t w, int16_t h) {\n  int16_t bw = (w + 7) / 8; // Bitmask scanline pad = whole byte\n  uint8_t b = 0;\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = pgm_read_byte(&mask[j * bw + i / 8]);\n      if (b & 0x80) {\n        writePixel(x + i, y, pgm_read_word(&bitmap[j * w + i]));\n      }\n    }\n  }\n  endWrite();\n}\n\n/**************************************************************************/\n/*!\n   @brief   Draw a RAM-resident 16-bit image (RGB 5/6/5) with a 1-bit mask (set\n   bits = opaque, unset bits = clear) at the specified (x,y) position. BOTH\n   buffers (color and mask) must be RAM-resident. For 16-bit display devices; no\n   color reduction performed.\n    @param    x   Top left corner x coordinate\n    @param    y   Top left corner y coordinate\n    @param    bitmap  byte array with 16-bit color bitmap\n    @param    mask  byte array with monochrome mask bitmap\n    @param    w   Width of bitmap in pixels\n    @param    h   Height of bitmap in pixels\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawRGBBitmap(int16_t x, int16_t y, uint16_t *bitmap,\n                                 uint8_t *mask, int16_t w, int16_t h) {\n  int16_t bw = (w + 7) / 8; // Bitmask scanline pad = whole byte\n  uint8_t b = 0;\n  startWrite();\n  for (int16_t j = 0; j < h; j++, y++) {\n    for (int16_t i = 0; i < w; i++) {\n      if (i & 7)\n        b <<= 1;\n      else\n        b = mask[j * bw + i / 8];\n      if (b & 0x80) {\n        writePixel(x + i, y, bitmap[j * w + i]);\n      }\n    }\n  }\n  endWrite();\n}\n\n// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------\n\n// Draw a character\n/**************************************************************************/\n/*!\n   @brief   Draw a single character\n    @param    x   Bottom left corner x coordinate\n    @param    y   Bottom left corner y coordinate\n    @param    c   The 8-bit font-indexed character (likely ascii)\n    @param    color 16-bit 5-6-5 Color to draw chraracter with\n    @param    bg 16-bit 5-6-5 Color to fill background with (if same as color,\n   no background)\n    @param    size  Font magnification level, 1 is 'original' size\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,\n                            uint16_t color, uint16_t bg, uint8_t size) {\n  drawChar(x, y, c, color, bg, size, size);\n}\n\n// Draw a character\n/**************************************************************************/\n/*!\n   @brief   Draw a single character\n    @param    x   Bottom left corner x coordinate\n    @param    y   Bottom left corner y coordinate\n    @param    c   The 8-bit font-indexed character (likely ascii)\n    @param    color 16-bit 5-6-5 Color to draw chraracter with\n    @param    bg 16-bit 5-6-5 Color to fill background with (if same as color,\n   no background)\n    @param    size_x  Font magnification level in X-axis, 1 is 'original' size\n    @param    size_y  Font magnification level in Y-axis, 1 is 'original' size\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,\n                            uint16_t color, uint16_t bg, uint8_t size_x,\n                            uint8_t size_y) {\n\n  if (!gfxFont) { // 'Classic' built-in font\n\n    if ((x >= _width) ||              // Clip right\n        (y >= _height) ||             // Clip bottom\n        ((x + 6 * size_x - 1) < 0) || // Clip left\n        ((y + 8 * size_y - 1) < 0))   // Clip top\n      return;\n\n    if (!_cp437 && (c >= 176))\n      c++; // Handle 'classic' charset behavior\n\n    startWrite();\n    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns\n      uint8_t line = pgm_read_byte(&font[c * 5 + i]);\n      for (int8_t j = 0; j < 8; j++, line >>= 1) {\n        if (line & 1) {\n          if (size_x == 1 && size_y == 1)\n            writePixel(x + i, y + j, color);\n          else\n            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,\n                          color);\n        } else if (bg != color) {\n          if (size_x == 1 && size_y == 1)\n            writePixel(x + i, y + j, bg);\n          else\n            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);\n        }\n      }\n    }\n    if (bg != color) { // If opaque, draw vertical line for last column\n      if (size_x == 1 && size_y == 1)\n        writeFastVLine(x + 5, y, 8, bg);\n      else\n        writeFillRect(x + 5 * size_x, y, size_x, 8 * size_y, bg);\n    }\n    endWrite();\n\n  } else { // Custom font\n\n    // Character is assumed previously filtered by write() to eliminate\n    // newlines, returns, non-printable characters, etc.  Calling\n    // drawChar() directly with 'bad' characters of font may cause mayhem!\n\n    c -= (uint8_t)pgm_read_byte(&gfxFont->first);\n    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);\n    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);\n\n    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);\n    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);\n    int8_t xo = pgm_read_byte(&glyph->xOffset),\n           yo = pgm_read_byte(&glyph->yOffset);\n    uint8_t xx, yy, bits = 0, bit = 0;\n    int16_t xo16 = 0, yo16 = 0;\n\n    if (size_x > 1 || size_y > 1) {\n      xo16 = xo;\n      yo16 = yo;\n    }\n\n    // Todo: Add character clipping here\n\n    // NOTE: THERE IS NO 'BACKGROUND' COLOR OPTION ON CUSTOM FONTS.\n    // THIS IS ON PURPOSE AND BY DESIGN.  The background color feature\n    // has typically been used with the 'classic' font to overwrite old\n    // screen contents with new data.  This ONLY works because the\n    // characters are a uniform size; it's not a sensible thing to do with\n    // proportionally-spaced fonts with glyphs of varying sizes (and that\n    // may overlap).  To replace previously-drawn text when using a custom\n    // font, use the getTextBounds() function to determine the smallest\n    // rectangle encompassing a string, erase the area with fillRect(),\n    // then draw new text.  This WILL infortunately 'blink' the text, but\n    // is unavoidable.  Drawing 'background' pixels will NOT fix this,\n    // only creates a new set of problems.  Have an idea to work around\n    // this (a canvas object type for MCUs that can afford the RAM and\n    // displays supporting setAddrWindow() and pushColors()), but haven't\n    // implemented this yet.\n\n    startWrite();\n    for (yy = 0; yy < h; yy++) {\n      for (xx = 0; xx < w; xx++) {\n        if (!(bit++ & 7)) {\n          bits = pgm_read_byte(&bitmap[bo++]);\n        }\n        if (bits & 0x80) {\n          if (size_x == 1 && size_y == 1) {\n            writePixel(x + xo + xx, y + yo + yy, color);\n          } else {\n            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,\n                          size_x, size_y, color);\n          }\n        }\n        bits <<= 1;\n      }\n    }\n    endWrite();\n\n  } // End classic vs custom font\n}\n/**************************************************************************/\n/*!\n    @brief  Print one byte/character of data, used to support print()\n    @param  c  The 8-bit ascii character to write\n*/\n/**************************************************************************/\nsize_t Adafruit_GFX::write(uint8_t c) {\n  if (!gfxFont) { // 'Classic' built-in font\n\n    if (c == '\\n') {              // Newline?\n      cursor_x = 0;               // Reset x to zero,\n      cursor_y += textsize_y * 8; // advance y one line\n    } else if (c != '\\r') {       // Ignore carriage returns\n      if (wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?\n        cursor_x = 0;                                       // Reset x to zero,\n        cursor_y += textsize_y * 8; // advance y one line\n      }\n      drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,\n               textsize_y);\n      cursor_x += textsize_x * 6; // Advance x one char\n    }\n\n  } else { // Custom font\n\n    if (c == '\\n') {\n      cursor_x = 0;\n      cursor_y +=\n          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);\n    } else if (c != '\\r') {\n      uint8_t first = pgm_read_byte(&gfxFont->first);\n      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {\n        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);\n        uint8_t w = pgm_read_byte(&glyph->width),\n                h = pgm_read_byte(&glyph->height);\n        if ((w > 0) && (h > 0)) { // Is there an associated bitmap?\n          int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic\n          if (wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {\n            cursor_x = 0;\n            cursor_y += (int16_t)textsize_y *\n                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);\n          }\n          drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,\n                   textsize_y);\n        }\n        cursor_x +=\n            (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;\n      }\n    }\n  }\n  return 1;\n}\n\n/**************************************************************************/\n/*!\n    @brief   Set text 'magnification' size. Each increase in s makes 1 pixel\n   that much bigger.\n    @param  s  Desired text size. 1 is default 6x8, 2 is 12x16, 3 is 18x24, etc\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::setTextSize(uint8_t s) { setTextSize(s, s); }\n\n/**************************************************************************/\n/*!\n    @brief   Set text 'magnification' size. Each increase in s makes 1 pixel\n   that much bigger.\n    @param  s_x  Desired text width magnification level in X-axis. 1 is default\n    @param  s_y  Desired text width magnification level in Y-axis. 1 is default\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::setTextSize(uint8_t s_x, uint8_t s_y) {\n  textsize_x = (s_x > 0) ? s_x : 1;\n  textsize_y = (s_y > 0) ? s_y : 1;\n}\n\n/**************************************************************************/\n/*!\n    @brief      Set rotation setting for display\n    @param  x   0 thru 3 corresponding to 4 cardinal rotations\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::setRotation(uint8_t x) {\n  rotation = (x & 3);\n  switch (rotation) {\n  case 0:\n  case 2:\n    _width = WIDTH;\n    _height = HEIGHT;\n    break;\n  case 1:\n  case 3:\n    _width = HEIGHT;\n    _height = WIDTH;\n    break;\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief Set the font to display when print()ing, either custom or default\n    @param  f  The GFXfont object, if NULL use built in 6x8 font\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::setFont(const GFXfont *f) {\n  if (f) {          // Font struct pointer passed in?\n    if (!gfxFont) { // And no current font struct?\n      // Switching from classic to new font behavior.\n      // Move cursor pos down 6 pixels so it's on baseline.\n      cursor_y += 6;\n    }\n  } else if (gfxFont) { // NULL passed.  Current font struct defined?\n    // Switching from new to classic font behavior.\n    // Move cursor pos up 6 pixels so it's at top-left of char.\n    cursor_y -= 6;\n  }\n  gfxFont = (GFXfont *)f;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Helper to determine size of a character with current font/size.\n            Broke this out as it's used by both the PROGMEM- and RAM-resident\n            getTextBounds() functions.\n    @param  c     The ASCII character in question\n    @param  x     Pointer to x location of character. Value is modified by\n                  this function to advance to next character.\n    @param  y     Pointer to y location of character. Value is modified by\n                  this function to advance to next character.\n    @param  minx  Pointer to minimum X coordinate, passed in to AND returned\n                  by this function -- this is used to incrementally build a\n                  bounding rectangle for a string.\n    @param  miny  Pointer to minimum Y coord, passed in AND returned.\n    @param  maxx  Pointer to maximum X coord, passed in AND returned.\n    @param  maxy  Pointer to maximum Y coord, passed in AND returned.\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::charBounds(unsigned char c, int16_t *x, int16_t *y,\n                              int16_t *minx, int16_t *miny, int16_t *maxx,\n                              int16_t *maxy) {\n\n  if (gfxFont) {\n\n    if (c == '\\n') { // Newline?\n      *x = 0;        // Reset x to zero, advance y by one line\n      *y += textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);\n    } else if (c != '\\r') { // Not a carriage return; is normal char\n      uint8_t first = pgm_read_byte(&gfxFont->first),\n              last = pgm_read_byte(&gfxFont->last);\n      if ((c >= first) && (c <= last)) { // Char present in this font?\n        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);\n        uint8_t gw = pgm_read_byte(&glyph->width),\n                gh = pgm_read_byte(&glyph->height),\n                xa = pgm_read_byte(&glyph->xAdvance);\n        int8_t xo = pgm_read_byte(&glyph->xOffset),\n               yo = pgm_read_byte(&glyph->yOffset);\n        if (wrap && ((*x + (((int16_t)xo + gw) * textsize_x)) > _width)) {\n          *x = 0; // Reset x to zero, advance y by one line\n          *y += textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);\n        }\n        int16_t tsx = (int16_t)textsize_x, tsy = (int16_t)textsize_y,\n                x1 = *x + xo * tsx, y1 = *y + yo * tsy, x2 = x1 + gw * tsx - 1,\n                y2 = y1 + gh * tsy - 1;\n        if (x1 < *minx)\n          *minx = x1;\n        if (y1 < *miny)\n          *miny = y1;\n        if (x2 > *maxx)\n          *maxx = x2;\n        if (y2 > *maxy)\n          *maxy = y2;\n        *x += xa * tsx;\n      }\n    }\n\n  } else { // Default font\n\n    if (c == '\\n') {        // Newline?\n      *x = 0;               // Reset x to zero,\n      *y += textsize_y * 8; // advance y one line\n      // min/max x/y unchaged -- that waits for next 'normal' character\n    } else if (c != '\\r') { // Normal char; ignore carriage returns\n      if (wrap && ((*x + textsize_x * 6) > _width)) { // Off right?\n        *x = 0;                                       // Reset x to zero,\n        *y += textsize_y * 8;                         // advance y one line\n      }\n      int x2 = *x + textsize_x * 6 - 1, // Lower-right pixel of char\n          y2 = *y + textsize_y * 8 - 1;\n      if (x2 > *maxx)\n        *maxx = x2; // Track max x, y\n      if (y2 > *maxy)\n        *maxy = y2;\n      if (*x < *minx)\n        *minx = *x; // Track min x, y\n      if (*y < *miny)\n        *miny = *y;\n      *x += textsize_x * 6; // Advance x one char\n    }\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief  Helper to determine size of a string with current font/size.\n            Pass string and a cursor position, returns UL corner and W,H.\n    @param  str  The ASCII string to measure\n    @param  x    The current cursor X\n    @param  y    The current cursor Y\n    @param  x1   The boundary X coordinate, returned by function\n    @param  y1   The boundary Y coordinate, returned by function\n    @param  w    The boundary width, returned by function\n    @param  h    The boundary height, returned by function\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::getTextBounds(const char *str, int16_t x, int16_t y,\n                                 int16_t *x1, int16_t *y1, uint16_t *w,\n                                 uint16_t *h) {\n\n  uint8_t c; // Current character\n  int16_t minx = 0x7FFF, miny = 0x7FFF, maxx = -1, maxy = -1; // Bound rect\n  // Bound rect is intentionally initialized inverted, so 1st char sets it\n\n  *x1 = x; // Initial position is value passed in\n  *y1 = y;\n  *w = *h = 0; // Initial size is zero\n\n  while ((c = *str++)) {\n    // charBounds() modifies x/y to advance for each character,\n    // and min/max x/y are updated to incrementally build bounding rect.\n    charBounds(c, &x, &y, &minx, &miny, &maxx, &maxy);\n  }\n\n  if (maxx >= minx) {     // If legit string bounds were found...\n    *x1 = minx;           // Update x1 to least X coord,\n    *w = maxx - minx + 1; // And w to bound rect width\n  }\n  if (maxy >= miny) { // Same for height\n    *y1 = miny;\n    *h = maxy - miny + 1;\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief    Helper to determine size of a string with current font/size. Pass\n   string and a cursor position, returns UL corner and W,H.\n    @param    str    The ascii string to measure (as an arduino String() class)\n    @param    x      The current cursor X\n    @param    y      The current cursor Y\n    @param    x1     The boundary X coordinate, set by function\n    @param    y1     The boundary Y coordinate, set by function\n    @param    w      The boundary width, set by function\n    @param    h      The boundary height, set by function\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::getTextBounds(const String &str, int16_t x, int16_t y,\n                                 int16_t *x1, int16_t *y1, uint16_t *w,\n                                 uint16_t *h) {\n  if (str.length() != 0) {\n    getTextBounds(const_cast<char *>(str.c_str()), x, y, x1, y1, w, h);\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief    Helper to determine size of a PROGMEM string with current\n   font/size. Pass string and a cursor position, returns UL corner and W,H.\n    @param    str     The flash-memory ascii string to measure\n    @param    x       The current cursor X\n    @param    y       The current cursor Y\n    @param    x1      The boundary X coordinate, set by function\n    @param    y1      The boundary Y coordinate, set by function\n    @param    w      The boundary width, set by function\n    @param    h      The boundary height, set by function\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::getTextBounds(const __FlashStringHelper *str, int16_t x,\n                                 int16_t y, int16_t *x1, int16_t *y1,\n                                 uint16_t *w, uint16_t *h) {\n  uint8_t *s = (uint8_t *)str, c;\n\n  *x1 = x;\n  *y1 = y;\n  *w = *h = 0;\n\n  int16_t minx = _width, miny = _height, maxx = -1, maxy = -1;\n\n  while ((c = pgm_read_byte(s++)))\n    charBounds(c, &x, &y, &minx, &miny, &maxx, &maxy);\n\n  if (maxx >= minx) {\n    *x1 = minx;\n    *w = maxx - minx + 1;\n  }\n  if (maxy >= miny) {\n    *y1 = miny;\n    *h = maxy - miny + 1;\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief      Invert the display (ideally using built-in hardware command)\n    @param   i  True if you want to invert, false to make 'normal'\n*/\n/**************************************************************************/\nvoid Adafruit_GFX::invertDisplay(bool i) {\n  // Do nothing, must be subclassed if supported by hardware\n  (void)i; // disable -Wunused-parameter warning\n}\n\n/***************************************************************************/\n\n/**************************************************************************/\n/*!\n   @brief    Create a simple drawn button UI element\n*/\n/**************************************************************************/\nAdafruit_GFX_Button::Adafruit_GFX_Button(void) { _gfx = 0; }\n\n/**************************************************************************/\n/*!\n   @brief    Initialize button with our desired color/size/settings\n   @param    gfx     Pointer to our display so we can draw to it!\n   @param    x       The X coordinate of the center of the button\n   @param    y       The Y coordinate of the center of the button\n   @param    w       Width of the buttton\n   @param    h       Height of the buttton\n   @param    outline  Color of the outline (16-bit 5-6-5 standard)\n   @param    fill  Color of the button fill (16-bit 5-6-5 standard)\n   @param    textcolor  Color of the button label (16-bit 5-6-5 standard)\n   @param    label  Ascii string of the text inside the button\n   @param    textsize The font magnification of the label text\n*/\n/**************************************************************************/\n// Classic initButton() function: pass center & size\nvoid Adafruit_GFX_Button::initButton(Adafruit_GFX *gfx, int16_t x, int16_t y,\n                                     uint16_t w, uint16_t h, uint16_t outline,\n                                     uint16_t fill, uint16_t textcolor,\n                                     char *label, uint8_t textsize) {\n  // Tweak arguments and pass to the newer initButtonUL() function...\n  initButtonUL(gfx, x - (w / 2), y - (h / 2), w, h, outline, fill, textcolor,\n               label, textsize);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Initialize button with our desired color/size/settings\n   @param    gfx     Pointer to our display so we can draw to it!\n   @param    x       The X coordinate of the center of the button\n   @param    y       The Y coordinate of the center of the button\n   @param    w       Width of the buttton\n   @param    h       Height of the buttton\n   @param    outline  Color of the outline (16-bit 5-6-5 standard)\n   @param    fill  Color of the button fill (16-bit 5-6-5 standard)\n   @param    textcolor  Color of the button label (16-bit 5-6-5 standard)\n   @param    label  Ascii string of the text inside the button\n   @param    textsize_x The font magnification in X-axis of the label text\n   @param    textsize_y The font magnification in Y-axis of the label text\n*/\n/**************************************************************************/\n// Classic initButton() function: pass center & size\nvoid Adafruit_GFX_Button::initButton(Adafruit_GFX *gfx, int16_t x, int16_t y,\n                                     uint16_t w, uint16_t h, uint16_t outline,\n                                     uint16_t fill, uint16_t textcolor,\n                                     char *label, uint8_t textsize_x,\n                                     uint8_t textsize_y) {\n  // Tweak arguments and pass to the newer initButtonUL() function...\n  initButtonUL(gfx, x - (w / 2), y - (h / 2), w, h, outline, fill, textcolor,\n               label, textsize_x, textsize_y);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Initialize button with our desired color/size/settings, with\n   upper-left coordinates\n   @param    gfx     Pointer to our display so we can draw to it!\n   @param    x1       The X coordinate of the Upper-Left corner of the button\n   @param    y1       The Y coordinate of the Upper-Left corner of the button\n   @param    w       Width of the buttton\n   @param    h       Height of the buttton\n   @param    outline  Color of the outline (16-bit 5-6-5 standard)\n   @param    fill  Color of the button fill (16-bit 5-6-5 standard)\n   @param    textcolor  Color of the button label (16-bit 5-6-5 standard)\n   @param    label  Ascii string of the text inside the button\n   @param    textsize The font magnification of the label text\n*/\n/**************************************************************************/\nvoid Adafruit_GFX_Button::initButtonUL(Adafruit_GFX *gfx, int16_t x1,\n                                       int16_t y1, uint16_t w, uint16_t h,\n                                       uint16_t outline, uint16_t fill,\n                                       uint16_t textcolor, char *label,\n                                       uint8_t textsize) {\n  initButtonUL(gfx, x1, y1, w, h, outline, fill, textcolor, label, textsize,\n               textsize);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Initialize button with our desired color/size/settings, with\n   upper-left coordinates\n   @param    gfx     Pointer to our display so we can draw to it!\n   @param    x1       The X coordinate of the Upper-Left corner of the button\n   @param    y1       The Y coordinate of the Upper-Left corner of the button\n   @param    w       Width of the buttton\n   @param    h       Height of the buttton\n   @param    outline  Color of the outline (16-bit 5-6-5 standard)\n   @param    fill  Color of the button fill (16-bit 5-6-5 standard)\n   @param    textcolor  Color of the button label (16-bit 5-6-5 standard)\n   @param    label  Ascii string of the text inside the button\n   @param    textsize_x The font magnification in X-axis of the label text\n   @param    textsize_y The font magnification in Y-axis of the label text\n*/\n/**************************************************************************/\nvoid Adafruit_GFX_Button::initButtonUL(Adafruit_GFX *gfx, int16_t x1,\n                                       int16_t y1, uint16_t w, uint16_t h,\n                                       uint16_t outline, uint16_t fill,\n                                       uint16_t textcolor, char *label,\n                                       uint8_t textsize_x, uint8_t textsize_y) {\n  _x1 = x1;\n  _y1 = y1;\n  _w = w;\n  _h = h;\n  _outlinecolor = outline;\n  _fillcolor = fill;\n  _textcolor = textcolor;\n  _textsize_x = textsize_x;\n  _textsize_y = textsize_y;\n  _gfx = gfx;\n  strncpy(_label, label, 9);\n  _label[9] = 0; // strncpy does not place a null at the end.\n                 // When 'label' is >9 characters, _label is not terminated.\n}\n\n/**************************************************************************/\n/*!\n   @brief    Draw the button on the screen\n   @param    inverted Whether to draw with fill/text swapped to indicate\n   'pressed'\n*/\n/**************************************************************************/\nvoid Adafruit_GFX_Button::drawButton(bool inverted) {\n  uint16_t fill, outline, text;\n\n  if (!inverted) {\n    fill = _fillcolor;\n    outline = _outlinecolor;\n    text = _textcolor;\n  } else {\n    fill = _textcolor;\n    outline = _outlinecolor;\n    text = _fillcolor;\n  }\n\n  uint8_t r = min(_w, _h) / 4; // Corner radius\n  _gfx->fillRoundRect(_x1, _y1, _w, _h, r, fill);\n  _gfx->drawRoundRect(_x1, _y1, _w, _h, r, outline);\n\n  _gfx->setCursor(_x1 + (_w / 2) - (strlen(_label) * 3 * _textsize_x),\n                  _y1 + (_h / 2) - (4 * _textsize_y));\n  _gfx->setTextColor(text);\n  _gfx->setTextSize(_textsize_x, _textsize_y);\n  _gfx->print(_label);\n}\n\n/**************************************************************************/\n/*!\n    @brief    Helper to let us know if a coordinate is within the bounds of the\n   button\n    @param    x       The X coordinate to check\n    @param    y       The Y coordinate to check\n    @returns  True if within button graphics outline\n*/\n/**************************************************************************/\nbool Adafruit_GFX_Button::contains(int16_t x, int16_t y) {\n  return ((x >= _x1) && (x < (int16_t)(_x1 + _w)) && (y >= _y1) &&\n          (y < (int16_t)(_y1 + _h)));\n}\n\n/**************************************************************************/\n/*!\n   @brief    Query whether the button was pressed since we last checked state\n   @returns  True if was not-pressed before, now is.\n*/\n/**************************************************************************/\nbool Adafruit_GFX_Button::justPressed() { return (currstate && !laststate); }\n\n/**************************************************************************/\n/*!\n   @brief    Query whether the button was released since we last checked state\n   @returns  True if was pressed before, now is not.\n*/\n/**************************************************************************/\nbool Adafruit_GFX_Button::justReleased() { return (!currstate && laststate); }\n\n// -------------------------------------------------------------------------\n\n// GFXcanvas1, GFXcanvas8 and GFXcanvas16 (currently a WIP, don't get too\n// comfy with the implementation) provide 1-, 8- and 16-bit offscreen\n// canvases, the address of which can be passed to drawBitmap() or\n// pushColors() (the latter appears only in a couple of GFX-subclassed TFT\n// libraries at this time).  This is here mostly to help with the recently-\n// added proportionally-spaced fonts; adds a way to refresh a section of the\n// screen without a massive flickering clear-and-redraw...but maybe you'll\n// find other uses too.  VERY RAM-intensive, since the buffer is in MCU\n// memory and not the display driver...GXFcanvas1 might be minimally useful\n// on an Uno-class board, but this and the others are much more likely to\n// require at least a Mega or various recent ARM-type boards (recommended,\n// as the text+bitmap draw can be pokey).  GFXcanvas1 requires 1 bit per\n// pixel (rounded up to nearest byte per scanline), GFXcanvas8 is 1 byte\n// per pixel (no scanline pad), and GFXcanvas16 uses 2 bytes per pixel (no\n// scanline pad).\n// NOT EXTENSIVELY TESTED YET.  MAY CONTAIN WORST BUGS KNOWN TO HUMANKIND.\n\n#ifdef __AVR__\n// Bitmask tables of 0x80>>X and ~(0x80>>X), because X>>Y is slow on AVR\nconst uint8_t PROGMEM GFXcanvas1::GFXsetBit[] = {0x80, 0x40, 0x20, 0x10,\n                                                 0x08, 0x04, 0x02, 0x01};\nconst uint8_t PROGMEM GFXcanvas1::GFXclrBit[] = {0x7F, 0xBF, 0xDF, 0xEF,\n                                                 0xF7, 0xFB, 0xFD, 0xFE};\n#endif\n\n/**************************************************************************/\n/*!\n   @brief    Instatiate a GFX 1-bit canvas context for graphics\n   @param    w   Display width, in pixels\n   @param    h   Display height, in pixels\n*/\n/**************************************************************************/\nGFXcanvas1::GFXcanvas1(uint16_t w, uint16_t h) : Adafruit_GFX(w, h) {\n  uint32_t bytes = ((w + 7) / 8) * h;\n  if ((buffer = (uint8_t *)malloc(bytes))) {\n    memset(buffer, 0, bytes);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Delete the canvas, free memory\n*/\n/**************************************************************************/\nGFXcanvas1::~GFXcanvas1(void) {\n  if (buffer)\n    free(buffer);\n}\n\n/**************************************************************************/\n/*!\n    @brief  Draw a pixel to the canvas framebuffer\n    @param  x     x coordinate\n    @param  y     y coordinate\n    @param  color Binary (on or off) color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas1::drawPixel(int16_t x, int16_t y, uint16_t color) {\n  if (buffer) {\n    if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))\n      return;\n\n    int16_t t;\n    switch (rotation) {\n    case 1:\n      t = x;\n      x = WIDTH - 1 - y;\n      y = t;\n      break;\n    case 2:\n      x = WIDTH - 1 - x;\n      y = HEIGHT - 1 - y;\n      break;\n    case 3:\n      t = x;\n      x = y;\n      y = HEIGHT - 1 - t;\n      break;\n    }\n\n    uint8_t *ptr = &buffer[(x / 8) + y * ((WIDTH + 7) / 8)];\n#ifdef __AVR__\n    if (color)\n      *ptr |= pgm_read_byte(&GFXsetBit[x & 7]);\n    else\n      *ptr &= pgm_read_byte(&GFXclrBit[x & 7]);\n#else\n    if (color)\n      *ptr |= 0x80 >> (x & 7);\n    else\n      *ptr &= ~(0x80 >> (x & 7));\n#endif\n  }\n}\n\n/**********************************************************************/\n/*!\n        @brief    Get the pixel color value at a given coordinate\n        @param    x   x coordinate\n        @param    y   y coordinate\n        @returns  The desired pixel's binary color value, either 0x1 (on) or 0x0\n   (off)\n*/\n/**********************************************************************/\nbool GFXcanvas1::getPixel(int16_t x, int16_t y) const {\n  int16_t t;\n  switch (rotation) {\n  case 1:\n    t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    break;\n  case 2:\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n    break;\n  case 3:\n    t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    break;\n  }\n  return getRawPixel(x, y);\n}\n\n/**********************************************************************/\n/*!\n        @brief    Get the pixel color value at a given, unrotated coordinate.\n              This method is intended for hardware drivers to get pixel value\n              in physical coordinates.\n        @param    x   x coordinate\n        @param    y   y coordinate\n        @returns  The desired pixel's binary color value, either 0x1 (on) or 0x0\n   (off)\n*/\n/**********************************************************************/\nbool GFXcanvas1::getRawPixel(int16_t x, int16_t y) const {\n  if ((x < 0) || (y < 0) || (x >= WIDTH) || (y >= HEIGHT))\n    return 0;\n  if (buffer) {\n    uint8_t *ptr = &buffer[(x / 8) + y * ((WIDTH + 7) / 8)];\n\n#ifdef __AVR__\n    return ((*ptr) & pgm_read_byte(&GFXsetBit[x & 7])) != 0;\n#else\n    return ((*ptr) & (0x80 >> (x & 7))) != 0;\n#endif\n  }\n  return 0;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Fill the framebuffer completely with one color\n    @param  color Binary (on or off) color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas1::fillScreen(uint16_t color) {\n  if (buffer) {\n    uint32_t bytes = ((WIDTH + 7) / 8) * HEIGHT;\n    memset(buffer, color ? 0xFF : 0x00, bytes);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief  Speed optimized vertical line drawing\n   @param  x      Line horizontal start point\n   @param  y      Line vertical start point\n   @param  h      Length of vertical line to be drawn, including first point\n   @param  color  Color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas1::drawFastVLine(int16_t x, int16_t y, int16_t h,\n                               uint16_t color) {\n\n  if (h < 0) { // Convert negative heights to positive equivalent\n    h *= -1;\n    y -= h - 1;\n    if (y < 0) {\n      h += y;\n      y = 0;\n    }\n  }\n\n  // Edge rejection (no-draw if totally off canvas)\n  if ((x < 0) || (x >= width()) || (y >= height()) || ((y + h - 1) < 0)) {\n    return;\n  }\n\n  if (y < 0) { // Clip top\n    h += y;\n    y = 0;\n  }\n  if (y + h > height()) { // Clip bottom\n    h = height() - y;\n  }\n\n  if (getRotation() == 0) {\n    drawFastRawVLine(x, y, h, color);\n  } else if (getRotation() == 1) {\n    int16_t t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    x -= h - 1;\n    drawFastRawHLine(x, y, h, color);\n  } else if (getRotation() == 2) {\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n\n    y -= h - 1;\n    drawFastRawVLine(x, y, h, color);\n  } else if (getRotation() == 3) {\n    int16_t t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    drawFastRawHLine(x, y, h, color);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief  Speed optimized horizontal line drawing\n   @param  x      Line horizontal start point\n   @param  y      Line vertical start point\n   @param  w      Length of horizontal line to be drawn, including first point\n   @param  color  Color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas1::drawFastHLine(int16_t x, int16_t y, int16_t w,\n                               uint16_t color) {\n  if (w < 0) { // Convert negative widths to positive equivalent\n    w *= -1;\n    x -= w - 1;\n    if (x < 0) {\n      w += x;\n      x = 0;\n    }\n  }\n\n  // Edge rejection (no-draw if totally off canvas)\n  if ((y < 0) || (y >= height()) || (x >= width()) || ((x + w - 1) < 0)) {\n    return;\n  }\n\n  if (x < 0) { // Clip left\n    w += x;\n    x = 0;\n  }\n  if (x + w >= width()) { // Clip right\n    w = width() - x;\n  }\n\n  if (getRotation() == 0) {\n    drawFastRawHLine(x, y, w, color);\n  } else if (getRotation() == 1) {\n    int16_t t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    drawFastRawVLine(x, y, w, color);\n  } else if (getRotation() == 2) {\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n\n    x -= w - 1;\n    drawFastRawHLine(x, y, w, color);\n  } else if (getRotation() == 3) {\n    int16_t t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    y -= w - 1;\n    drawFastRawVLine(x, y, w, color);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized vertical line drawing into the raw canvas buffer\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    h   length of vertical line to be drawn, including first point\n   @param    color   Binary (on or off) color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas1::drawFastRawVLine(int16_t x, int16_t y, int16_t h,\n                                  uint16_t color) {\n  // x & y already in raw (rotation 0) coordinates, no need to transform.\n  int16_t row_bytes = ((WIDTH + 7) / 8);\n  uint8_t *ptr = &buffer[(x / 8) + y * row_bytes];\n\n  if (color > 0) {\n#ifdef __AVR__\n    uint8_t bit_mask = pgm_read_byte(&GFXsetBit[x & 7]);\n#else\n    uint8_t bit_mask = (0x80 >> (x & 7));\n#endif\n    for (int16_t i = 0; i < h; i++) {\n      *ptr |= bit_mask;\n      ptr += row_bytes;\n    }\n  } else {\n#ifdef __AVR__\n    uint8_t bit_mask = pgm_read_byte(&GFXclrBit[x & 7]);\n#else\n    uint8_t bit_mask = ~(0x80 >> (x & 7));\n#endif\n    for (int16_t i = 0; i < h; i++) {\n      *ptr &= bit_mask;\n      ptr += row_bytes;\n    }\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized horizontal line drawing into the raw canvas buffer\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    w   length of horizontal line to be drawn, including first point\n   @param    color   Binary (on or off) color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas1::drawFastRawHLine(int16_t x, int16_t y, int16_t w,\n                                  uint16_t color) {\n  // x & y already in raw (rotation 0) coordinates, no need to transform.\n  int16_t rowBytes = ((WIDTH + 7) / 8);\n  uint8_t *ptr = &buffer[(x / 8) + y * rowBytes];\n  size_t remainingWidthBits = w;\n\n  // check to see if first byte needs to be partially filled\n  if ((x & 7) > 0) {\n    // create bit mask for first byte\n    uint8_t startByteBitMask = 0x00;\n    for (int8_t i = (x & 7); ((i < 8) && (remainingWidthBits > 0)); i++) {\n#ifdef __AVR__\n      startByteBitMask |= pgm_read_byte(&GFXsetBit[i]);\n#else\n      startByteBitMask |= (0x80 >> i);\n#endif\n      remainingWidthBits--;\n    }\n    if (color > 0) {\n      *ptr |= startByteBitMask;\n    } else {\n      *ptr &= ~startByteBitMask;\n    }\n\n    ptr++;\n  }\n\n  // do the next remainingWidthBits bits\n  if (remainingWidthBits > 0) {\n    size_t remainingWholeBytes = remainingWidthBits / 8;\n    size_t lastByteBits = remainingWidthBits % 8;\n    uint8_t wholeByteColor = color > 0 ? 0xFF : 0x00;\n\n    memset(ptr, wholeByteColor, remainingWholeBytes);\n\n    if (lastByteBits > 0) {\n      uint8_t lastByteBitMask = 0x00;\n      for (size_t i = 0; i < lastByteBits; i++) {\n#ifdef __AVR__\n        lastByteBitMask |= pgm_read_byte(&GFXsetBit[i]);\n#else\n        lastByteBitMask |= (0x80 >> i);\n#endif\n      }\n      ptr += remainingWholeBytes;\n\n      if (color > 0) {\n        *ptr |= lastByteBitMask;\n      } else {\n        *ptr &= ~lastByteBitMask;\n      }\n    }\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Instatiate a GFX 8-bit canvas context for graphics\n   @param    w   Display width, in pixels\n   @param    h   Display height, in pixels\n*/\n/**************************************************************************/\nGFXcanvas8::GFXcanvas8(uint16_t w, uint16_t h) : Adafruit_GFX(w, h) {\n  uint32_t bytes = w * h;\n  if ((buffer = (uint8_t *)malloc(bytes))) {\n    memset(buffer, 0, bytes);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Delete the canvas, free memory\n*/\n/**************************************************************************/\nGFXcanvas8::~GFXcanvas8(void) {\n  if (buffer)\n    free(buffer);\n}\n\n/**************************************************************************/\n/*!\n    @brief  Draw a pixel to the canvas framebuffer\n    @param  x   x coordinate\n    @param  y   y coordinate\n    @param  color 8-bit Color to fill with. Only lower byte of uint16_t is used.\n*/\n/**************************************************************************/\nvoid GFXcanvas8::drawPixel(int16_t x, int16_t y, uint16_t color) {\n  if (buffer) {\n    if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))\n      return;\n\n    int16_t t;\n    switch (rotation) {\n    case 1:\n      t = x;\n      x = WIDTH - 1 - y;\n      y = t;\n      break;\n    case 2:\n      x = WIDTH - 1 - x;\n      y = HEIGHT - 1 - y;\n      break;\n    case 3:\n      t = x;\n      x = y;\n      y = HEIGHT - 1 - t;\n      break;\n    }\n\n    buffer[x + y * WIDTH] = color;\n  }\n}\n\n/**********************************************************************/\n/*!\n        @brief    Get the pixel color value at a given coordinate\n        @param    x   x coordinate\n        @param    y   y coordinate\n        @returns  The desired pixel's 8-bit color value\n*/\n/**********************************************************************/\nuint8_t GFXcanvas8::getPixel(int16_t x, int16_t y) const {\n  int16_t t;\n  switch (rotation) {\n  case 1:\n    t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    break;\n  case 2:\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n    break;\n  case 3:\n    t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    break;\n  }\n  return getRawPixel(x, y);\n}\n\n/**********************************************************************/\n/*!\n        @brief    Get the pixel color value at a given, unrotated coordinate.\n              This method is intended for hardware drivers to get pixel value\n              in physical coordinates.\n        @param    x   x coordinate\n        @param    y   y coordinate\n        @returns  The desired pixel's 8-bit color value\n*/\n/**********************************************************************/\nuint8_t GFXcanvas8::getRawPixel(int16_t x, int16_t y) const {\n  if ((x < 0) || (y < 0) || (x >= WIDTH) || (y >= HEIGHT))\n    return 0;\n  if (buffer) {\n    return buffer[x + y * WIDTH];\n  }\n  return 0;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Fill the framebuffer completely with one color\n    @param  color 8-bit Color to fill with. Only lower byte of uint16_t is used.\n*/\n/**************************************************************************/\nvoid GFXcanvas8::fillScreen(uint16_t color) {\n  if (buffer) {\n    memset(buffer, color, WIDTH * HEIGHT);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief  Speed optimized vertical line drawing\n   @param  x      Line horizontal start point\n   @param  y      Line vertical start point\n   @param  h      Length of vertical line to be drawn, including first point\n   @param  color  8-bit Color to fill with. Only lower byte of uint16_t is\n                  used.\n*/\n/**************************************************************************/\nvoid GFXcanvas8::drawFastVLine(int16_t x, int16_t y, int16_t h,\n                               uint16_t color) {\n  if (h < 0) { // Convert negative heights to positive equivalent\n    h *= -1;\n    y -= h - 1;\n    if (y < 0) {\n      h += y;\n      y = 0;\n    }\n  }\n\n  // Edge rejection (no-draw if totally off canvas)\n  if ((x < 0) || (x >= width()) || (y >= height()) || ((y + h - 1) < 0)) {\n    return;\n  }\n\n  if (y < 0) { // Clip top\n    h += y;\n    y = 0;\n  }\n  if (y + h > height()) { // Clip bottom\n    h = height() - y;\n  }\n\n  if (getRotation() == 0) {\n    drawFastRawVLine(x, y, h, color);\n  } else if (getRotation() == 1) {\n    int16_t t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    x -= h - 1;\n    drawFastRawHLine(x, y, h, color);\n  } else if (getRotation() == 2) {\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n\n    y -= h - 1;\n    drawFastRawVLine(x, y, h, color);\n  } else if (getRotation() == 3) {\n    int16_t t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    drawFastRawHLine(x, y, h, color);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief  Speed optimized horizontal line drawing\n   @param  x      Line horizontal start point\n   @param  y      Line vertical start point\n   @param  w      Length of horizontal line to be drawn, including 1st point\n   @param  color  8-bit Color to fill with. Only lower byte of uint16_t is\n                  used.\n*/\n/**************************************************************************/\nvoid GFXcanvas8::drawFastHLine(int16_t x, int16_t y, int16_t w,\n                               uint16_t color) {\n\n  if (w < 0) { // Convert negative widths to positive equivalent\n    w *= -1;\n    x -= w - 1;\n    if (x < 0) {\n      w += x;\n      x = 0;\n    }\n  }\n\n  // Edge rejection (no-draw if totally off canvas)\n  if ((y < 0) || (y >= height()) || (x >= width()) || ((x + w - 1) < 0)) {\n    return;\n  }\n\n  if (x < 0) { // Clip left\n    w += x;\n    x = 0;\n  }\n  if (x + w >= width()) { // Clip right\n    w = width() - x;\n  }\n\n  if (getRotation() == 0) {\n    drawFastRawHLine(x, y, w, color);\n  } else if (getRotation() == 1) {\n    int16_t t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    drawFastRawVLine(x, y, w, color);\n  } else if (getRotation() == 2) {\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n\n    x -= w - 1;\n    drawFastRawHLine(x, y, w, color);\n  } else if (getRotation() == 3) {\n    int16_t t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    y -= w - 1;\n    drawFastRawVLine(x, y, w, color);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized vertical line drawing into the raw canvas buffer\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    h   length of vertical line to be drawn, including first point\n   @param    color   8-bit Color to fill with. Only lower byte of uint16_t is\n   used.\n*/\n/**************************************************************************/\nvoid GFXcanvas8::drawFastRawVLine(int16_t x, int16_t y, int16_t h,\n                                  uint16_t color) {\n  // x & y already in raw (rotation 0) coordinates, no need to transform.\n  uint8_t *buffer_ptr = buffer + y * WIDTH + x;\n  for (int16_t i = 0; i < h; i++) {\n    (*buffer_ptr) = color;\n    buffer_ptr += WIDTH;\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized horizontal line drawing into the raw canvas buffer\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    w   length of horizontal line to be drawn, including first point\n   @param    color   8-bit Color to fill with. Only lower byte of uint16_t is\n   used.\n*/\n/**************************************************************************/\nvoid GFXcanvas8::drawFastRawHLine(int16_t x, int16_t y, int16_t w,\n                                  uint16_t color) {\n  // x & y already in raw (rotation 0) coordinates, no need to transform.\n  memset(buffer + y * WIDTH + x, color, w);\n}\n\n/**************************************************************************/\n/*!\n   @brief    Instatiate a GFX 16-bit canvas context for graphics\n   @param    w   Display width, in pixels\n   @param    h   Display height, in pixels\n*/\n/**************************************************************************/\nGFXcanvas16::GFXcanvas16(uint16_t w, uint16_t h) : Adafruit_GFX(w, h) {\n  uint32_t bytes = w * h * 2;\n  if ((buffer = (uint16_t *)malloc(bytes))) {\n    memset(buffer, 0, bytes);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Delete the canvas, free memory\n*/\n/**************************************************************************/\nGFXcanvas16::~GFXcanvas16(void) {\n  if (buffer)\n    free(buffer);\n}\n\n/**************************************************************************/\n/*!\n    @brief  Draw a pixel to the canvas framebuffer\n    @param  x   x coordinate\n    @param  y   y coordinate\n    @param  color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas16::drawPixel(int16_t x, int16_t y, uint16_t color) {\n  if (buffer) {\n    if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))\n      return;\n\n    int16_t t;\n    switch (rotation) {\n    case 1:\n      t = x;\n      x = WIDTH - 1 - y;\n      y = t;\n      break;\n    case 2:\n      x = WIDTH - 1 - x;\n      y = HEIGHT - 1 - y;\n      break;\n    case 3:\n      t = x;\n      x = y;\n      y = HEIGHT - 1 - t;\n      break;\n    }\n\n    buffer[x + y * WIDTH] = color;\n  }\n}\n\n/**********************************************************************/\n/*!\n        @brief    Get the pixel color value at a given coordinate\n        @param    x   x coordinate\n        @param    y   y coordinate\n        @returns  The desired pixel's 16-bit 5-6-5 color value\n*/\n/**********************************************************************/\nuint16_t GFXcanvas16::getPixel(int16_t x, int16_t y) const {\n  int16_t t;\n  switch (rotation) {\n  case 1:\n    t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    break;\n  case 2:\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n    break;\n  case 3:\n    t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    break;\n  }\n  return getRawPixel(x, y);\n}\n\n/**********************************************************************/\n/*!\n        @brief    Get the pixel color value at a given, unrotated coordinate.\n              This method is intended for hardware drivers to get pixel value\n              in physical coordinates.\n        @param    x   x coordinate\n        @param    y   y coordinate\n        @returns  The desired pixel's 16-bit 5-6-5 color value\n*/\n/**********************************************************************/\nuint16_t GFXcanvas16::getRawPixel(int16_t x, int16_t y) const {\n  if ((x < 0) || (y < 0) || (x >= WIDTH) || (y >= HEIGHT))\n    return 0;\n  if (buffer) {\n    return buffer[x + y * WIDTH];\n  }\n  return 0;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Fill the framebuffer completely with one color\n    @param  color 16-bit 5-6-5 Color to fill with\n*/\n/**************************************************************************/\nvoid GFXcanvas16::fillScreen(uint16_t color) {\n  if (buffer) {\n    uint8_t hi = color >> 8, lo = color & 0xFF;\n    if (hi == lo) {\n      memset(buffer, lo, WIDTH * HEIGHT * 2);\n    } else {\n      uint32_t i, pixels = WIDTH * HEIGHT;\n      for (i = 0; i < pixels; i++)\n        buffer[i] = color;\n    }\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief  Reverses the \"endian-ness\" of each 16-bit pixel within the\n            canvas; little-endian to big-endian, or big-endian to little.\n            Most microcontrollers (such as SAMD) are little-endian, while\n            most displays tend toward big-endianness. All the drawing\n            functions (including RGB bitmap drawing) take care of this\n            automatically, but some specialized code (usually involving\n            DMA) can benefit from having pixel data already in the\n            display-native order. Note that this does NOT convert to a\n            SPECIFIC endian-ness, it just flips the bytes within each word.\n*/\n/**************************************************************************/\nvoid GFXcanvas16::byteSwap(void) {\n  if (buffer) {\n    uint32_t i, pixels = WIDTH * HEIGHT;\n    for (i = 0; i < pixels; i++)\n      buffer[i] = __builtin_bswap16(buffer[i]);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized vertical line drawing\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    h   length of vertical line to be drawn, including first point\n   @param    color   color 16-bit 5-6-5 Color to draw line with\n*/\n/**************************************************************************/\nvoid GFXcanvas16::drawFastVLine(int16_t x, int16_t y, int16_t h,\n                                uint16_t color) {\n  if (h < 0) { // Convert negative heights to positive equivalent\n    h *= -1;\n    y -= h - 1;\n    if (y < 0) {\n      h += y;\n      y = 0;\n    }\n  }\n\n  // Edge rejection (no-draw if totally off canvas)\n  if ((x < 0) || (x >= width()) || (y >= height()) || ((y + h - 1) < 0)) {\n    return;\n  }\n\n  if (y < 0) { // Clip top\n    h += y;\n    y = 0;\n  }\n  if (y + h > height()) { // Clip bottom\n    h = height() - y;\n  }\n\n  if (getRotation() == 0) {\n    drawFastRawVLine(x, y, h, color);\n  } else if (getRotation() == 1) {\n    int16_t t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    x -= h - 1;\n    drawFastRawHLine(x, y, h, color);\n  } else if (getRotation() == 2) {\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n\n    y -= h - 1;\n    drawFastRawVLine(x, y, h, color);\n  } else if (getRotation() == 3) {\n    int16_t t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    drawFastRawHLine(x, y, h, color);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief  Speed optimized horizontal line drawing\n   @param  x      Line horizontal start point\n   @param  y      Line vertical start point\n   @param  w      Length of horizontal line to be drawn, including 1st point\n   @param  color  Color 16-bit 5-6-5 Color to draw line with\n*/\n/**************************************************************************/\nvoid GFXcanvas16::drawFastHLine(int16_t x, int16_t y, int16_t w,\n                                uint16_t color) {\n  if (w < 0) { // Convert negative widths to positive equivalent\n    w *= -1;\n    x -= w - 1;\n    if (x < 0) {\n      w += x;\n      x = 0;\n    }\n  }\n\n  // Edge rejection (no-draw if totally off canvas)\n  if ((y < 0) || (y >= height()) || (x >= width()) || ((x + w - 1) < 0)) {\n    return;\n  }\n\n  if (x < 0) { // Clip left\n    w += x;\n    x = 0;\n  }\n  if (x + w >= width()) { // Clip right\n    w = width() - x;\n  }\n\n  if (getRotation() == 0) {\n    drawFastRawHLine(x, y, w, color);\n  } else if (getRotation() == 1) {\n    int16_t t = x;\n    x = WIDTH - 1 - y;\n    y = t;\n    drawFastRawVLine(x, y, w, color);\n  } else if (getRotation() == 2) {\n    x = WIDTH - 1 - x;\n    y = HEIGHT - 1 - y;\n\n    x -= w - 1;\n    drawFastRawHLine(x, y, w, color);\n  } else if (getRotation() == 3) {\n    int16_t t = x;\n    x = y;\n    y = HEIGHT - 1 - t;\n    y -= w - 1;\n    drawFastRawVLine(x, y, w, color);\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized vertical line drawing into the raw canvas buffer\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    h   length of vertical line to be drawn, including first point\n   @param    color   color 16-bit 5-6-5 Color to draw line with\n*/\n/**************************************************************************/\nvoid GFXcanvas16::drawFastRawVLine(int16_t x, int16_t y, int16_t h,\n                                   uint16_t color) {\n  // x & y already in raw (rotation 0) coordinates, no need to transform.\n  uint16_t *buffer_ptr = buffer + y * WIDTH + x;\n  for (int16_t i = 0; i < h; i++) {\n    (*buffer_ptr) = color;\n    buffer_ptr += WIDTH;\n  }\n}\n\n/**************************************************************************/\n/*!\n   @brief    Speed optimized horizontal line drawing into the raw canvas buffer\n   @param    x   Line horizontal start point\n   @param    y   Line vertical start point\n   @param    w   length of horizontal line to be drawn, including first point\n   @param    color   color 16-bit 5-6-5 Color to draw line with\n*/\n/**************************************************************************/\nvoid GFXcanvas16::drawFastRawHLine(int16_t x, int16_t y, int16_t w,\n                                   uint16_t color) {\n  // x & y already in raw (rotation 0) coordinates, no need to transform.\n  uint32_t buffer_index = y * WIDTH + x;\n  for (uint32_t i = buffer_index; i < buffer_index + w; i++) {\n    buffer[i] = color;\n  }\n}\n"
        },
        {
          "name": "Adafruit_GFX.h",
          "type": "blob",
          "size": 16.65625,
          "content": "#ifndef _ADAFRUIT_GFX_H\n#define _ADAFRUIT_GFX_H\n\n#if ARDUINO >= 100\n#include \"Arduino.h\"\n#include \"Print.h\"\n#else\n#include \"WProgram.h\"\n#endif\n#include \"gfxfont.h\"\n\n#include <Adafruit_I2CDevice.h>\n#include <Adafruit_SPIDevice.h>\n\n/// A generic graphics superclass that can handle all sorts of drawing. At a\n/// minimum you can subclass and provide drawPixel(). At a maximum you can do a\n/// ton of overriding to optimize. Used for any/all Adafruit displays!\nclass Adafruit_GFX : public Print {\n\npublic:\n  Adafruit_GFX(int16_t w, int16_t h); // Constructor\n\n  /**********************************************************************/\n  /*!\n    @brief  Draw to the screen/framebuffer/etc.\n    Must be overridden in subclass.\n    @param  x    X coordinate in pixels\n    @param  y    Y coordinate in pixels\n    @param color  16-bit pixel color.\n  */\n  /**********************************************************************/\n  virtual void drawPixel(int16_t x, int16_t y, uint16_t color) = 0;\n\n  // TRANSACTION API / CORE DRAW API\n  // These MAY be overridden by the subclass to provide device-specific\n  // optimized code.  Otherwise 'generic' versions are used.\n  virtual void startWrite(void);\n  virtual void writePixel(int16_t x, int16_t y, uint16_t color);\n  virtual void writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                             uint16_t color);\n  virtual void writeFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  virtual void writeFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  virtual void writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,\n                         uint16_t color);\n  virtual void endWrite(void);\n\n  // CONTROL API\n  // These MAY be overridden by the subclass to provide device-specific\n  // optimized code.  Otherwise 'generic' versions are used.\n  virtual void setRotation(uint8_t r);\n  virtual void invertDisplay(bool i);\n\n  // BASIC DRAW API\n  // These MAY be overridden by the subclass to provide device-specific\n  // optimized code.  Otherwise 'generic' versions are used.\n\n  // It's good to implement those, even if using transaction API\n  virtual void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  virtual void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  virtual void fillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                        uint16_t color);\n  virtual void fillScreen(uint16_t color);\n  // Optional and probably not necessary to change\n  virtual void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,\n                        uint16_t color);\n  virtual void drawRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                        uint16_t color);\n\n  // These exist only with Adafruit_GFX (no subclass overrides)\n  void drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color);\n  void drawCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername,\n                        uint16_t color);\n  void fillCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color);\n  void fillCircleHelper(int16_t x0, int16_t y0, int16_t r, uint8_t cornername,\n                        int16_t delta, uint16_t color);\n  void drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2,\n                    int16_t y2, uint16_t color);\n  void fillTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2,\n                    int16_t y2, uint16_t color);\n  void drawRoundRect(int16_t x0, int16_t y0, int16_t w, int16_t h,\n                     int16_t radius, uint16_t color);\n  void fillRoundRect(int16_t x0, int16_t y0, int16_t w, int16_t h,\n                     int16_t radius, uint16_t color);\n  void drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w,\n                  int16_t h, uint16_t color);\n  void drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w,\n                  int16_t h, uint16_t color, uint16_t bg);\n  void drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h,\n                  uint16_t color);\n  void drawBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w, int16_t h,\n                  uint16_t color, uint16_t bg);\n  void drawXBitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w,\n                   int16_t h, uint16_t color);\n  void drawGrayscaleBitmap(int16_t x, int16_t y, const uint8_t bitmap[],\n                           int16_t w, int16_t h);\n  void drawGrayscaleBitmap(int16_t x, int16_t y, uint8_t *bitmap, int16_t w,\n                           int16_t h);\n  void drawGrayscaleBitmap(int16_t x, int16_t y, const uint8_t bitmap[],\n                           const uint8_t mask[], int16_t w, int16_t h);\n  void drawGrayscaleBitmap(int16_t x, int16_t y, uint8_t *bitmap, uint8_t *mask,\n                           int16_t w, int16_t h);\n  void drawRGBBitmap(int16_t x, int16_t y, const uint16_t bitmap[], int16_t w,\n                     int16_t h);\n  void drawRGBBitmap(int16_t x, int16_t y, uint16_t *bitmap, int16_t w,\n                     int16_t h);\n  void drawRGBBitmap(int16_t x, int16_t y, const uint16_t bitmap[],\n                     const uint8_t mask[], int16_t w, int16_t h);\n  void drawRGBBitmap(int16_t x, int16_t y, uint16_t *bitmap, uint8_t *mask,\n                     int16_t w, int16_t h);\n  void drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color,\n                uint16_t bg, uint8_t size);\n  void drawChar(int16_t x, int16_t y, unsigned char c, uint16_t color,\n                uint16_t bg, uint8_t size_x, uint8_t size_y);\n  void getTextBounds(const char *string, int16_t x, int16_t y, int16_t *x1,\n                     int16_t *y1, uint16_t *w, uint16_t *h);\n  void getTextBounds(const __FlashStringHelper *s, int16_t x, int16_t y,\n                     int16_t *x1, int16_t *y1, uint16_t *w, uint16_t *h);\n  void getTextBounds(const String &str, int16_t x, int16_t y, int16_t *x1,\n                     int16_t *y1, uint16_t *w, uint16_t *h);\n  void setTextSize(uint8_t s);\n  void setTextSize(uint8_t sx, uint8_t sy);\n  void setFont(const GFXfont *f = NULL);\n\n  /**********************************************************************/\n  /*!\n    @brief  Set text cursor location\n    @param  x    X coordinate in pixels\n    @param  y    Y coordinate in pixels\n  */\n  /**********************************************************************/\n  void setCursor(int16_t x, int16_t y) {\n    cursor_x = x;\n    cursor_y = y;\n  }\n\n  /**********************************************************************/\n  /*!\n    @brief   Set text font color with transparant background\n    @param   c   16-bit 5-6-5 Color to draw text with\n    @note    For 'transparent' background, background and foreground\n             are set to same color rather than using a separate flag.\n  */\n  /**********************************************************************/\n  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }\n\n  /**********************************************************************/\n  /*!\n    @brief   Set text font color with custom background color\n    @param   c   16-bit 5-6-5 Color to draw text with\n    @param   bg  16-bit 5-6-5 Color to draw background/fill with\n  */\n  /**********************************************************************/\n  void setTextColor(uint16_t c, uint16_t bg) {\n    textcolor = c;\n    textbgcolor = bg;\n  }\n\n  /**********************************************************************/\n  /*!\n  @brief  Set whether text that is too long for the screen width should\n          automatically wrap around to the next line (else clip right).\n  @param  w  true for wrapping, false for clipping\n  */\n  /**********************************************************************/\n  void setTextWrap(bool w) { wrap = w; }\n\n  /**********************************************************************/\n  /*!\n    @brief  Enable (or disable) Code Page 437-compatible charset.\n            There was an error in glcdfont.c for the longest time -- one\n            character (#176, the 'light shade' block) was missing -- this\n            threw off the index of every character that followed it.\n            But a TON of code has been written with the erroneous\n            character indices. By default, the library uses the original\n            'wrong' behavior and old sketches will still work. Pass\n            'true' to this function to use correct CP437 character values\n            in your code.\n    @param  x  true = enable (new behavior), false = disable (old behavior)\n  */\n  /**********************************************************************/\n  void cp437(bool x = true) { _cp437 = x; }\n\n  using Print::write;\n#if ARDUINO >= 100\n  virtual size_t write(uint8_t);\n#else\n  virtual void write(uint8_t);\n#endif\n\n  /************************************************************************/\n  /*!\n    @brief      Get width of the display, accounting for current rotation\n    @returns    Width in pixels\n  */\n  /************************************************************************/\n  int16_t width(void) const { return _width; };\n\n  /************************************************************************/\n  /*!\n    @brief      Get height of the display, accounting for current rotation\n    @returns    Height in pixels\n  */\n  /************************************************************************/\n  int16_t height(void) const { return _height; }\n\n  /************************************************************************/\n  /*!\n    @brief      Get rotation setting for display\n    @returns    0 thru 3 corresponding to 4 cardinal rotations\n  */\n  /************************************************************************/\n  uint8_t getRotation(void) const { return rotation; }\n\n  // get current cursor position (get rotation safe maximum values,\n  // using: width() for x, height() for y)\n  /************************************************************************/\n  /*!\n    @brief  Get text cursor X location\n    @returns    X coordinate in pixels\n  */\n  /************************************************************************/\n  int16_t getCursorX(void) const { return cursor_x; }\n\n  /************************************************************************/\n  /*!\n    @brief      Get text cursor Y location\n    @returns    Y coordinate in pixels\n  */\n  /************************************************************************/\n  int16_t getCursorY(void) const { return cursor_y; };\n\nprotected:\n  void charBounds(unsigned char c, int16_t *x, int16_t *y, int16_t *minx,\n                  int16_t *miny, int16_t *maxx, int16_t *maxy);\n  int16_t WIDTH;        ///< This is the 'raw' display width - never changes\n  int16_t HEIGHT;       ///< This is the 'raw' display height - never changes\n  int16_t _width;       ///< Display width as modified by current rotation\n  int16_t _height;      ///< Display height as modified by current rotation\n  int16_t cursor_x;     ///< x location to start print()ing text\n  int16_t cursor_y;     ///< y location to start print()ing text\n  uint16_t textcolor;   ///< 16-bit background color for print()\n  uint16_t textbgcolor; ///< 16-bit text color for print()\n  uint8_t textsize_x;   ///< Desired magnification in X-axis of text to print()\n  uint8_t textsize_y;   ///< Desired magnification in Y-axis of text to print()\n  uint8_t rotation;     ///< Display rotation (0 thru 3)\n  bool wrap;            ///< If set, 'wrap' text at right edge of display\n  bool _cp437;          ///< If set, use correct CP437 charset (default is off)\n  GFXfont *gfxFont;     ///< Pointer to special font\n};\n\n/// A simple drawn button UI element\nclass Adafruit_GFX_Button {\n\npublic:\n  Adafruit_GFX_Button(void);\n  // \"Classic\" initButton() uses center & size\n  void initButton(Adafruit_GFX *gfx, int16_t x, int16_t y, uint16_t w,\n                  uint16_t h, uint16_t outline, uint16_t fill,\n                  uint16_t textcolor, char *label, uint8_t textsize);\n  void initButton(Adafruit_GFX *gfx, int16_t x, int16_t y, uint16_t w,\n                  uint16_t h, uint16_t outline, uint16_t fill,\n                  uint16_t textcolor, char *label, uint8_t textsize_x,\n                  uint8_t textsize_y);\n  // New/alt initButton() uses upper-left corner & size\n  void initButtonUL(Adafruit_GFX *gfx, int16_t x1, int16_t y1, uint16_t w,\n                    uint16_t h, uint16_t outline, uint16_t fill,\n                    uint16_t textcolor, char *label, uint8_t textsize);\n  void initButtonUL(Adafruit_GFX *gfx, int16_t x1, int16_t y1, uint16_t w,\n                    uint16_t h, uint16_t outline, uint16_t fill,\n                    uint16_t textcolor, char *label, uint8_t textsize_x,\n                    uint8_t textsize_y);\n  void drawButton(bool inverted = false);\n  bool contains(int16_t x, int16_t y);\n\n  /**********************************************************************/\n  /*!\n    @brief    Sets button state, should be done by some touch function\n    @param    p  True for pressed, false for not.\n  */\n  /**********************************************************************/\n  void press(bool p) {\n    laststate = currstate;\n    currstate = p;\n  }\n\n  bool justPressed();\n  bool justReleased();\n\n  /**********************************************************************/\n  /*!\n    @brief    Query whether the button is currently pressed\n    @returns  True if pressed\n  */\n  /**********************************************************************/\n  bool isPressed(void) { return currstate; };\n\nprivate:\n  Adafruit_GFX *_gfx;\n  int16_t _x1, _y1; // Coordinates of top-left corner\n  uint16_t _w, _h;\n  uint8_t _textsize_x;\n  uint8_t _textsize_y;\n  uint16_t _outlinecolor, _fillcolor, _textcolor;\n  char _label[10];\n\n  bool currstate, laststate;\n};\n\n/// A GFX 1-bit canvas context for graphics\nclass GFXcanvas1 : public Adafruit_GFX {\npublic:\n  GFXcanvas1(uint16_t w, uint16_t h);\n  ~GFXcanvas1(void);\n  void drawPixel(int16_t x, int16_t y, uint16_t color);\n  void fillScreen(uint16_t color);\n  void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  bool getPixel(int16_t x, int16_t y) const;\n  /**********************************************************************/\n  /*!\n    @brief    Get a pointer to the internal buffer memory\n    @returns  A pointer to the allocated buffer\n  */\n  /**********************************************************************/\n  uint8_t *getBuffer(void) const { return buffer; }\n\nprotected:\n  bool getRawPixel(int16_t x, int16_t y) const;\n  void drawFastRawVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  void drawFastRawHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  uint8_t *buffer; ///< Raster data: no longer private, allow subclass access\n\nprivate:\n#ifdef __AVR__\n  // Bitmask tables of 0x80>>X and ~(0x80>>X), because X>>Y is slow on AVR\n  static const uint8_t PROGMEM GFXsetBit[], GFXclrBit[];\n#endif\n};\n\n/// A GFX 8-bit canvas context for graphics\nclass GFXcanvas8 : public Adafruit_GFX {\npublic:\n  GFXcanvas8(uint16_t w, uint16_t h);\n  ~GFXcanvas8(void);\n  void drawPixel(int16_t x, int16_t y, uint16_t color);\n  void fillScreen(uint16_t color);\n  void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  uint8_t getPixel(int16_t x, int16_t y) const;\n  /**********************************************************************/\n  /*!\n   @brief    Get a pointer to the internal buffer memory\n   @returns  A pointer to the allocated buffer\n  */\n  /**********************************************************************/\n  uint8_t *getBuffer(void) const { return buffer; }\n\nprotected:\n  uint8_t getRawPixel(int16_t x, int16_t y) const;\n  void drawFastRawVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  void drawFastRawHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  uint8_t *buffer; ///< Raster data: no longer private, allow subclass access\n};\n\n///  A GFX 16-bit canvas context for graphics\nclass GFXcanvas16 : public Adafruit_GFX {\npublic:\n  GFXcanvas16(uint16_t w, uint16_t h);\n  ~GFXcanvas16(void);\n  void drawPixel(int16_t x, int16_t y, uint16_t color);\n  void fillScreen(uint16_t color);\n  void byteSwap(void);\n  void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  uint16_t getPixel(int16_t x, int16_t y) const;\n  /**********************************************************************/\n  /*!\n    @brief    Get a pointer to the internal buffer memory\n    @returns  A pointer to the allocated buffer\n  */\n  /**********************************************************************/\n  uint16_t *getBuffer(void) const { return buffer; }\n\nprotected:\n  uint16_t getRawPixel(int16_t x, int16_t y) const;\n  void drawFastRawVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  void drawFastRawHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  uint16_t *buffer; ///< Raster data: no longer private, allow subclass access\n};\n\n#endif // _ADAFRUIT_GFX_H\n"
        },
        {
          "name": "Adafruit_GrayOLED.cpp",
          "type": "blob",
          "size": 15.0537109375,
          "content": "/*!\n * @file Adafruit_GrayOLED.cpp\n *\n * This is documentation for Adafruit's generic library for grayscale\n * OLED displays: http://www.adafruit.com/category/63_98\n *\n * These displays use I2C or SPI to communicate. I2C requires 2 pins\n * (SCL+SDA) and optionally a RESET pin. SPI requires 4 pins (MOSI, SCK,\n * select, data/command) and optionally a reset pin. Hardware SPI or\n * 'bitbang' software SPI are both supported.\n *\n * Adafruit invests time and resources providing this open source code,\n * please support Adafruit and open-source hardware by purchasing\n * products from Adafruit!\n *\n */\n\n// Not for ATtiny, at all\n#if !defined(__AVR_ATtiny85__) && !defined(__AVR_ATtiny84__)\n\n#include \"Adafruit_GrayOLED.h\"\n#include <Adafruit_GFX.h>\n\n// SOME DEFINES AND STATIC VARIABLES USED INTERNALLY -----------------------\n\n#define grayoled_swap(a, b)                                                    \\\n  (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b))) ///< No-temp-var swap operation\n\n// CONSTRUCTORS, DESTRUCTOR ------------------------------------------------\n\n/*!\n    @brief  Constructor for I2C-interfaced OLED displays.\n    @param  bpp Bits per pixel, 1 for monochrome, 4 for 16-gray\n    @param  w\n            Display width in pixels\n    @param  h\n            Display height in pixels\n    @param  twi\n            Pointer to an existing TwoWire instance (e.g. &Wire, the\n            microcontroller's primary I2C bus).\n    @param  rst_pin\n            Reset pin (using Arduino pin numbering), or -1 if not used\n            (some displays might be wired to share the microcontroller's\n            reset pin).\n    @param  clkDuring\n            Speed (in Hz) for Wire transmissions in library calls.\n            Defaults to 400000 (400 KHz), a known 'safe' value for most\n            microcontrollers, and meets the OLED datasheet spec.\n            Some systems can operate I2C faster (800 KHz for ESP32, 1 MHz\n            for many other 32-bit MCUs), and some (perhaps not all)\n            Many OLED's can work with this -- so it's optionally be specified\n            here and is not a default behavior. (Ignored if using pre-1.5.7\n            Arduino software, which operates I2C at a fixed 100 KHz.)\n    @param  clkAfter\n            Speed (in Hz) for Wire transmissions following library\n            calls. Defaults to 100000 (100 KHz), the default Arduino Wire\n            speed. This is done rather than leaving it at the 'during' speed\n            because other devices on the I2C bus might not be compatible\n            with the faster rate. (Ignored if using pre-1.5.7 Arduino\n            software, which operates I2C at a fixed 100 KHz.)\n    @note   Call the object's begin() function before use -- buffer\n            allocation is performed there!\n*/\nAdafruit_GrayOLED::Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h,\n                                     TwoWire *twi, int8_t rst_pin,\n                                     uint32_t clkDuring, uint32_t clkAfter)\n    : Adafruit_GFX(w, h), i2c_preclk(clkDuring), i2c_postclk(clkAfter),\n      buffer(NULL), dcPin(-1), csPin(-1), rstPin(rst_pin), _bpp(bpp) {\n  i2c_dev = NULL;\n  _theWire = twi;\n}\n\n/*!\n    @brief  Constructor for SPI GrayOLED displays, using software (bitbang)\n            SPI.\n    @param  bpp Bits per pixel, 1 for monochrome, 4 for 16-gray\n    @param  w\n            Display width in pixels\n    @param  h\n            Display height in pixels\n    @param  mosi_pin\n            MOSI (master out, slave in) pin (using Arduino pin numbering).\n            This transfers serial data from microcontroller to display.\n    @param  sclk_pin\n            SCLK (serial clock) pin (using Arduino pin numbering).\n            This clocks each bit from MOSI.\n    @param  dc_pin\n            Data/command pin (using Arduino pin numbering), selects whether\n            display is receiving commands (low) or data (high).\n    @param  rst_pin\n            Reset pin (using Arduino pin numbering), or -1 if not used\n            (some displays might be wired to share the microcontroller's\n            reset pin).\n    @param  cs_pin\n            Chip-select pin (using Arduino pin numbering) for sharing the\n            bus with other devices. Active low.\n    @note   Call the object's begin() function before use -- buffer\n            allocation is performed there!\n*/\nAdafruit_GrayOLED::Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h,\n                                     int8_t mosi_pin, int8_t sclk_pin,\n                                     int8_t dc_pin, int8_t rst_pin,\n                                     int8_t cs_pin)\n    : Adafruit_GFX(w, h), dcPin(dc_pin), csPin(cs_pin), rstPin(rst_pin),\n      _bpp(bpp) {\n\n  spi_dev = new Adafruit_SPIDevice(cs_pin, sclk_pin, -1, mosi_pin, 1000000);\n}\n\n/*!\n    @brief  Constructor for SPI GrayOLED displays, using native hardware SPI.\n    @param  bpp Bits per pixel, 1 for monochrome, 4 for 16-gray\n    @param  w\n            Display width in pixels\n    @param  h\n            Display height in pixels\n    @param  spi\n            Pointer to an existing SPIClass instance (e.g. &SPI, the\n            microcontroller's primary SPI bus).\n    @param  dc_pin\n            Data/command pin (using Arduino pin numbering), selects whether\n            display is receiving commands (low) or data (high).\n    @param  rst_pin\n            Reset pin (using Arduino pin numbering), or -1 if not used\n            (some displays might be wired to share the microcontroller's\n            reset pin).\n    @param  cs_pin\n            Chip-select pin (using Arduino pin numbering) for sharing the\n            bus with other devices. Active low.\n    @param  bitrate\n            SPI clock rate for transfers to this display. Default if\n            unspecified is 8000000UL (8 MHz).\n    @note   Call the object's begin() function before use -- buffer\n            allocation is performed there!\n*/\nAdafruit_GrayOLED::Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h,\n                                     SPIClass *spi, int8_t dc_pin,\n                                     int8_t rst_pin, int8_t cs_pin,\n                                     uint32_t bitrate)\n    : Adafruit_GFX(w, h), dcPin(dc_pin), csPin(cs_pin), rstPin(rst_pin),\n      _bpp(bpp) {\n\n  spi_dev = new Adafruit_SPIDevice(cs_pin, bitrate, SPI_BITORDER_MSBFIRST,\n                                   SPI_MODE0, spi);\n}\n\n/*!\n    @brief  Destructor for Adafruit_GrayOLED object.\n*/\nAdafruit_GrayOLED::~Adafruit_GrayOLED(void) {\n  if (buffer) {\n    free(buffer);\n    buffer = NULL;\n  }\n  if (spi_dev)\n    delete spi_dev;\n  if (i2c_dev)\n    delete i2c_dev;\n}\n\n// LOW-LEVEL UTILS ---------------------------------------------------------\n\n/*!\n    @brief Issue single command byte to OLED, using I2C or hard/soft SPI as\n   needed.\n    @param c The single byte command\n*/\nvoid Adafruit_GrayOLED::oled_command(uint8_t c) {\n  if (i2c_dev) {                // I2C\n    uint8_t buf[2] = {0x00, c}; // Co = 0, D/C = 0\n    i2c_dev->write(buf, 2);\n  } else { // SPI (hw or soft) -- transaction started in calling function\n    digitalWrite(dcPin, LOW);\n    spi_dev->write(&c, 1);\n  }\n}\n\n// Issue list of commands to GrayOLED\n/*!\n    @brief Issue multiple bytes of commands OLED, using I2C or hard/soft SPI as\n   needed.\n    @param c Pointer to the command array\n    @param n The number of bytes in the command array\n    @returns True for success on ability to write the data in I2C.\n*/\n\nbool Adafruit_GrayOLED::oled_commandList(const uint8_t *c, uint8_t n) {\n  if (i2c_dev) {            // I2C\n    uint8_t dc_byte = 0x00; // Co = 0, D/C = 0\n    if (!i2c_dev->write((uint8_t *)c, n, true, &dc_byte, 1)) {\n      return false;\n    }\n  } else { // SPI -- transaction started in calling function\n    digitalWrite(dcPin, LOW);\n    if (!spi_dev->write((uint8_t *)c, n)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ALLOCATE & INIT DISPLAY -------------------------------------------------\n\n/*!\n    @brief  Allocate RAM for image buffer, initialize peripherals and pins.\n            Note that subclasses must call this before other begin() init\n    @param  addr\n            I2C address of corresponding oled display.\n            SPI displays (hardware or software) do not use addresses, but\n            this argument is still required. Default if unspecified is 0x3C.\n    @param  reset\n            If true, and if the reset pin passed to the constructor is\n            valid, a hard reset will be performed before initializing the\n            display. If using multiple oled displays on the same bus, and\n            if they all share the same reset pin, you should only pass true\n            on the first display being initialized, false on all others,\n            else the already-initialized displays would be reset. Default if\n            unspecified is true.\n    @return true on successful allocation/init, false otherwise.\n            Well-behaved code should check the return value before\n            proceeding.\n    @note   MUST call this function before any drawing or updates!\n*/\nbool Adafruit_GrayOLED::_init(uint8_t addr, bool reset) {\n\n  // attempt to malloc the bitmap framebuffer\n  if ((!buffer) &&\n      !(buffer = (uint8_t *)malloc(_bpp * WIDTH * ((HEIGHT + 7) / 8)))) {\n    return false;\n  }\n\n  // Reset OLED if requested and reset pin specified in constructor\n  if (reset && (rstPin >= 0)) {\n    pinMode(rstPin, OUTPUT);\n    digitalWrite(rstPin, HIGH);\n    delay(10);                  // VDD goes high at start, pause\n    digitalWrite(rstPin, LOW);  // Bring reset low\n    delay(10);                  // Wait 10 ms\n    digitalWrite(rstPin, HIGH); // Bring out of reset\n    delay(10);\n  }\n\n  // Setup pin directions\n  if (_theWire) { // using I2C\n    i2c_dev = new Adafruit_I2CDevice(addr, _theWire);\n    // look for i2c address:\n    if (!i2c_dev || !i2c_dev->begin()) {\n      return false;\n    }\n  } else { // Using one of the SPI modes, either soft or hardware\n    if (!spi_dev || !spi_dev->begin()) {\n      return false;\n    }\n    pinMode(dcPin, OUTPUT); // Set data/command pin as output\n  }\n\n  clearDisplay();\n\n  // set max dirty window\n  window_x1 = 0;\n  window_y1 = 0;\n  window_x2 = WIDTH - 1;\n  window_y2 = HEIGHT - 1;\n\n  return true; // Success\n}\n\n// DRAWING FUNCTIONS -------------------------------------------------------\n\n/*!\n    @brief  Set/clear/invert a single pixel. This is also invoked by the\n            Adafruit_GFX library in generating many higher-level graphics\n            primitives.\n    @param  x\n            Column of display -- 0 at left to (screen width - 1) at right.\n    @param  y\n            Row of display -- 0 at top to (screen height -1) at bottom.\n    @param  color\n            Pixel color, one of: MONOOLED_BLACK, MONOOLED_WHITE or\n   MONOOLED_INVERT.\n    @note   Changes buffer contents only, no immediate effect on display.\n            Follow up with a call to display(), or with other graphics\n            commands as needed by one's own application.\n*/\nvoid Adafruit_GrayOLED::drawPixel(int16_t x, int16_t y, uint16_t color) {\n  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {\n    // Pixel is in-bounds. Rotate coordinates if needed.\n    switch (getRotation()) {\n    case 1:\n      grayoled_swap(x, y);\n      x = WIDTH - x - 1;\n      break;\n    case 2:\n      x = WIDTH - x - 1;\n      y = HEIGHT - y - 1;\n      break;\n    case 3:\n      grayoled_swap(x, y);\n      y = HEIGHT - y - 1;\n      break;\n    }\n\n    // adjust dirty window\n    window_x1 = min(window_x1, x);\n    window_y1 = min(window_y1, y);\n    window_x2 = max(window_x2, x);\n    window_y2 = max(window_y2, y);\n\n    if (_bpp == 1) {\n      switch (color) {\n      case MONOOLED_WHITE:\n        buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));\n        break;\n      case MONOOLED_BLACK:\n        buffer[x + (y / 8) * WIDTH] &= ~(1 << (y & 7));\n        break;\n      case MONOOLED_INVERSE:\n        buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));\n        break;\n      }\n    }\n    if (_bpp == 4) {\n      uint8_t *pixelptr = &buffer[x / 2 + (y * WIDTH / 2)];\n      // Serial.printf(\"(%d, %d) -> offset %d\\n\", x, y, x/2 + (y * WIDTH / 2));\n      if (x % 2 == 0) { // even, left nibble\n        uint8_t t = pixelptr[0] & 0x0F;\n        t |= (color & 0xF) << 4;\n        pixelptr[0] = t;\n      } else { // odd, right lower nibble\n        uint8_t t = pixelptr[0] & 0xF0;\n        t |= color & 0xF;\n        pixelptr[0] = t;\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Clear contents of display buffer (set all pixels to off).\n    @note   Changes buffer contents only, no immediate effect on display.\n            Follow up with a call to display(), or with other graphics\n            commands as needed by one's own application.\n*/\nvoid Adafruit_GrayOLED::clearDisplay(void) {\n  memset(buffer, 0, _bpp * WIDTH * ((HEIGHT + 7) / 8));\n  // set max dirty window\n  window_x1 = 0;\n  window_y1 = 0;\n  window_x2 = WIDTH - 1;\n  window_y2 = HEIGHT - 1;\n}\n\n/*!\n    @brief  Return color of a single pixel in display buffer.\n    @param  x\n            Column of display -- 0 at left to (screen width - 1) at right.\n    @param  y\n            Row of display -- 0 at top to (screen height -1) at bottom.\n    @return true if pixel is set (usually MONOOLED_WHITE, unless display invert\n   mode is enabled), false if clear (MONOOLED_BLACK).\n    @note   Reads from buffer contents; may not reflect current contents of\n            screen if display() has not been called.\n*/\nbool Adafruit_GrayOLED::getPixel(int16_t x, int16_t y) {\n  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {\n    // Pixel is in-bounds. Rotate coordinates if needed.\n    switch (getRotation()) {\n    case 1:\n      grayoled_swap(x, y);\n      x = WIDTH - x - 1;\n      break;\n    case 2:\n      x = WIDTH - x - 1;\n      y = HEIGHT - y - 1;\n      break;\n    case 3:\n      grayoled_swap(x, y);\n      y = HEIGHT - y - 1;\n      break;\n    }\n    return (buffer[x + (y / 8) * WIDTH] & (1 << (y & 7)));\n  }\n  return false; // Pixel out of bounds\n}\n\n/*!\n    @brief  Get base address of display buffer for direct reading or writing.\n    @return Pointer to an unsigned 8-bit array, column-major, columns padded\n            to full byte boundary if needed.\n*/\nuint8_t *Adafruit_GrayOLED::getBuffer(void) { return buffer; }\n\n// OTHER HARDWARE SETTINGS -------------------------------------------------\n\n/*!\n    @brief  Enable or disable display invert mode (white-on-black vs\n            black-on-white). Handy for testing!\n    @param  i\n            If true, switch to invert mode (black-on-white), else normal\n            mode (white-on-black).\n    @note   This has an immediate effect on the display, no need to call the\n            display() function -- buffer contents are not changed, rather a\n            different pixel mode of the display hardware is used. When\n            enabled, drawing MONOOLED_BLACK (value 0) pixels will actually draw\n   white, MONOOLED_WHITE (value 1) will draw black.\n*/\nvoid Adafruit_GrayOLED::invertDisplay(bool i) {\n  oled_command(i ? GRAYOLED_INVERTDISPLAY : GRAYOLED_NORMALDISPLAY);\n}\n\n/*!\n    @brief  Adjust the display contrast.\n    @param  level The contrast level from 0 to 0x7F\n    @note   This has an immediate effect on the display, no need to call the\n            display() function -- buffer contents are not changed.\n*/\nvoid Adafruit_GrayOLED::setContrast(uint8_t level) {\n  uint8_t cmd[] = {GRAYOLED_SETCONTRAST, level};\n  oled_commandList(cmd, 2);\n}\n\n#endif /* ATTIN85 not supported */\n"
        },
        {
          "name": "Adafruit_GrayOLED.h",
          "type": "blob",
          "size": 3.8193359375,
          "content": "/*!\n * @file Adafruit_GrayOLED.h\n *\n * This is part of for Adafruit's GFX library, supplying generic support\n * for grayscale OLED displays: http://www.adafruit.com/category/63_98\n *\n * These displays use I2C or SPI to communicate. I2C requires 2 pins\n * (SCL+SDA) and optionally a RESET pin. SPI requires 4 pins (MOSI, SCK,\n * select, data/command) and optionally a reset pin. Hardware SPI or\n * 'bitbang' software SPI are both supported.\n *\n * Adafruit invests time and resources providing this open source code,\n * please support Adafruit and open-source hardware by purchasing\n * products from Adafruit!\n *\n * Written by Limor Fried/Ladyada for Adafruit Industries, with\n * contributions from the open source community.\n *\n * BSD license, all text above, and the splash screen header file,\n * must be included in any redistribution.\n *\n */\n\n#ifndef _Adafruit_GRAYOLED_H_\n#define _Adafruit_GRAYOLED_H_\n\n// Not for ATtiny, at all\n#if !defined(__AVR_ATtiny85__) && !defined(__AVR_ATtiny84__)\n\n#include <Adafruit_GFX.h>\n#include <Adafruit_I2CDevice.h>\n#include <Adafruit_SPIDevice.h>\n#include <SPI.h>\n#include <Wire.h>\n\n#define GRAYOLED_SETCONTRAST 0x81   ///< Generic contrast for almost all OLEDs\n#define GRAYOLED_NORMALDISPLAY 0xA6 ///< Generic non-invert for almost all OLEDs\n#define GRAYOLED_INVERTDISPLAY 0xA7 ///< Generic invert for almost all OLEDs\n\n#define MONOOLED_BLACK 0   ///< Default black 'color' for monochrome OLEDS\n#define MONOOLED_WHITE 1   ///< Default white 'color' for monochrome OLEDS\n#define MONOOLED_INVERSE 2 ///< Default inversion command for monochrome OLEDS\n\n/*!\n    @brief  Class that stores state and functions for interacting with\n            generic grayscale OLED displays.\n*/\nclass Adafruit_GrayOLED : public Adafruit_GFX {\npublic:\n  Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h, TwoWire *twi = &Wire,\n                    int8_t rst_pin = -1, uint32_t preclk = 400000,\n                    uint32_t postclk = 100000);\n  Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h, int8_t mosi_pin,\n                    int8_t sclk_pin, int8_t dc_pin, int8_t rst_pin,\n                    int8_t cs_pin);\n  Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h, SPIClass *spi,\n                    int8_t dc_pin, int8_t rst_pin, int8_t cs_pin,\n                    uint32_t bitrate = 8000000UL);\n\n  ~Adafruit_GrayOLED(void);\n\n  /**\n   @brief The function that sub-classes define that writes out the buffer to\n   the display over I2C or SPI\n   **/\n  virtual void display(void) = 0;\n  void clearDisplay(void);\n  void invertDisplay(bool i);\n  void setContrast(uint8_t contrastlevel);\n  void drawPixel(int16_t x, int16_t y, uint16_t color);\n  bool getPixel(int16_t x, int16_t y);\n  uint8_t *getBuffer(void);\n\n  void oled_command(uint8_t c);\n  bool oled_commandList(const uint8_t *c, uint8_t n);\n\nprotected:\n  bool _init(uint8_t i2caddr = 0x3C, bool reset = true);\n\n  Adafruit_SPIDevice *spi_dev = NULL; ///< The SPI interface BusIO device\n  Adafruit_I2CDevice *i2c_dev = NULL; ///< The I2C interface BusIO device\n  int32_t i2c_preclk = 400000,        ///< Configurable 'high speed' I2C rate\n      i2c_postclk = 100000;           ///< Configurable 'low speed' I2C rate\n  uint8_t *buffer = NULL; ///< Internal 1:1 framebuffer of display mem\n\n  int16_t window_x1, ///< Dirty tracking window minimum x\n      window_y1,     ///< Dirty tracking window minimum y\n      window_x2,     ///< Dirty tracking window maximum x\n      window_y2;     ///< Dirty tracking window maximum y\n\n  int dcPin,  ///< The Arduino pin connected to D/C (for SPI)\n      csPin,  ///< The Arduino pin connected to CS (for SPI)\n      rstPin; ///< The Arduino pin connected to reset (-1 if unused)\n\n  uint8_t _bpp = 1; ///< Bits per pixel color for this display\nprivate:\n  TwoWire *_theWire = NULL; ///< The underlying hardware I2C\n};\n\n#endif // end __AVR_ATtiny85__ __AVR_ATtiny84__\n#endif // _Adafruit_GrayOLED_H_\n"
        },
        {
          "name": "Adafruit_SPITFT.cpp",
          "type": "blob",
          "size": 96.8359375,
          "content": "/*!\n * @file Adafruit_SPITFT.cpp\n *\n * @mainpage Adafruit SPI TFT Displays (and some others)\n *\n * @section intro_sec Introduction\n *\n * Part of Adafruit's GFX graphics library. Originally this class was\n * written to handle a range of color TFT displays connected via SPI,\n * but over time this library and some display-specific subclasses have\n * mutated to include some color OLEDs as well as parallel-interfaced\n * displays. The name's been kept for the sake of older code.\n *\n * Adafruit invests time and resources providing this open source code,\n * please support Adafruit and open-source hardware by purchasing\n * products from Adafruit!\n\n * @section dependencies Dependencies\n *\n * This library depends on <a href=\"https://github.com/adafruit/Adafruit_GFX\">\n * Adafruit_GFX</a> being present on your system. Please make sure you have\n * installed the latest version before using this library.\n *\n * @section author Author\n *\n * Written by Limor \"ladyada\" Fried for Adafruit Industries,\n * with contributions from the open source community.\n *\n * @section license License\n *\n * BSD license, all text here must be included in any redistribution.\n */\n\n// Not for ATtiny, at all\n#if !defined(__AVR_ATtiny85__) && !defined(__AVR_ATtiny84__)\n\n#include \"Adafruit_SPITFT.h\"\n\n#if defined(__AVR__)\n#if defined(__AVR_XMEGA__) // only tested with __AVR_ATmega4809__\n#define AVR_WRITESPI(x)                                                        \\\n  for (SPI0_DATA = (x); (!(SPI0_INTFLAGS & _BV(SPI_IF_bp)));)\n#else\n#define AVR_WRITESPI(x) for (SPDR = (x); (!(SPSR & _BV(SPIF)));)\n#endif\n#endif\n\n#if defined(PORT_IOBUS)\n// On SAMD21, redefine digitalPinToPort() to use the slightly-faster\n// PORT_IOBUS rather than PORT (not needed on SAMD51).\n#undef digitalPinToPort\n#define digitalPinToPort(P) (&(PORT_IOBUS->Group[g_APinDescription[P].ulPort]))\n#endif // end PORT_IOBUS\n\n#if defined(USE_SPI_DMA) && (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n// #pragma message (\"GFX DMA IS ENABLED. HIGHLY EXPERIMENTAL.\")\n#include \"wiring_private.h\" // pinPeripheral() function\n#include <Adafruit_ZeroDMA.h>\n#include <malloc.h>          // memalign() function\n#define tcNum 2              // Timer/Counter for parallel write strobe PWM\n#define wrPeripheral PIO_CCL // Use CCL to invert write strobe\n\n// DMA transfer-in-progress indicator and callback\nstatic volatile bool dma_busy = false;\nstatic void dma_callback(Adafruit_ZeroDMA *dma) { dma_busy = false; }\n\n#if defined(__SAMD51__)\n// Timer/counter info by index #\nstatic const struct {\n  Tc *tc;   // -> Timer/Counter base address\n  int gclk; // GCLK ID\n  int evu;  // EVSYS user ID\n} tcList[] = {{TC0, TC0_GCLK_ID, EVSYS_ID_USER_TC0_EVU},\n              {TC1, TC1_GCLK_ID, EVSYS_ID_USER_TC1_EVU},\n              {TC2, TC2_GCLK_ID, EVSYS_ID_USER_TC2_EVU},\n              {TC3, TC3_GCLK_ID, EVSYS_ID_USER_TC3_EVU},\n#if defined(TC4)\n              {TC4, TC4_GCLK_ID, EVSYS_ID_USER_TC4_EVU},\n#endif\n#if defined(TC5)\n              {TC5, TC5_GCLK_ID, EVSYS_ID_USER_TC5_EVU},\n#endif\n#if defined(TC6)\n              {TC6, TC6_GCLK_ID, EVSYS_ID_USER_TC6_EVU},\n#endif\n#if defined(TC7)\n              {TC7, TC7_GCLK_ID, EVSYS_ID_USER_TC7_EVU}\n#endif\n};\n#define NUM_TIMERS (sizeof tcList / sizeof tcList[0]) ///< # timer/counters\n#endif                                                // end __SAMD51__\n\n#endif // end USE_SPI_DMA\n\n// Possible values for Adafruit_SPITFT.connection:\n#define TFT_HARD_SPI 0 ///< Display interface = hardware SPI\n#define TFT_SOFT_SPI 1 ///< Display interface = software SPI\n#define TFT_PARALLEL 2 ///< Display interface = 8- or 16-bit parallel\n\n// CONSTRUCTORS ------------------------------------------------------------\n\n/*!\n    @brief   Adafruit_SPITFT constructor for software (bitbang) SPI.\n    @param   w     Display width in pixels at default rotation setting (0).\n    @param   h     Display height in pixels at default rotation setting (0).\n    @param   cs    Arduino pin # for chip-select (-1 if unused, tie CS low).\n    @param   dc    Arduino pin # for data/command select (required).\n    @param   mosi  Arduino pin # for bitbang SPI MOSI signal (required).\n    @param   sck   Arduino pin # for bitbang SPI SCK signal (required).\n    @param   rst   Arduino pin # for display reset (optional, display reset\n                   can be tied to MCU reset, default of -1 means unused).\n    @param   miso  Arduino pin # for bitbang SPI MISO signal (optional,\n                   -1 default, many displays don't support SPI read).\n    @note    Output pins are not initialized; application typically will\n             need to call subclass' begin() function, which in turn calls\n             this library's initSPI() function to initialize pins.\n*/\nAdafruit_SPITFT::Adafruit_SPITFT(uint16_t w, uint16_t h, int8_t cs, int8_t dc,\n                                 int8_t mosi, int8_t sck, int8_t rst,\n                                 int8_t miso)\n    : Adafruit_GFX(w, h), connection(TFT_SOFT_SPI), _rst(rst), _cs(cs),\n      _dc(dc) {\n  swspi._sck = sck;\n  swspi._mosi = mosi;\n  swspi._miso = miso;\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(CORE_TEENSY)\n#if !defined(KINETISK)\n  dcPinMask = digitalPinToBitMask(dc);\n  swspi.sckPinMask = digitalPinToBitMask(sck);\n  swspi.mosiPinMask = digitalPinToBitMask(mosi);\n#endif\n  dcPortSet = portSetRegister(dc);\n  dcPortClr = portClearRegister(dc);\n  swspi.sckPortSet = portSetRegister(sck);\n  swspi.sckPortClr = portClearRegister(sck);\n  swspi.mosiPortSet = portSetRegister(mosi);\n  swspi.mosiPortClr = portClearRegister(mosi);\n  if (cs >= 0) {\n#if !defined(KINETISK)\n    csPinMask = digitalPinToBitMask(cs);\n#endif\n    csPortSet = portSetRegister(cs);\n    csPortClr = portClearRegister(cs);\n  } else {\n#if !defined(KINETISK)\n    csPinMask = 0;\n#endif\n    csPortSet = dcPortSet;\n    csPortClr = dcPortClr;\n  }\n  if (miso >= 0) {\n    swspi.misoPort = portInputRegister(miso);\n#if !defined(KINETISK)\n    swspi.misoPinMask = digitalPinToBitMask(miso);\n#endif\n  } else {\n    swspi.misoPort = portInputRegister(dc);\n  }\n#else  // !CORE_TEENSY\n  dcPinMask = digitalPinToBitMask(dc);\n  swspi.sckPinMask = digitalPinToBitMask(sck);\n  swspi.mosiPinMask = digitalPinToBitMask(mosi);\n  dcPortSet = &(PORT->Group[g_APinDescription[dc].ulPort].OUTSET.reg);\n  dcPortClr = &(PORT->Group[g_APinDescription[dc].ulPort].OUTCLR.reg);\n  swspi.sckPortSet = &(PORT->Group[g_APinDescription[sck].ulPort].OUTSET.reg);\n  swspi.sckPortClr = &(PORT->Group[g_APinDescription[sck].ulPort].OUTCLR.reg);\n  swspi.mosiPortSet = &(PORT->Group[g_APinDescription[mosi].ulPort].OUTSET.reg);\n  swspi.mosiPortClr = &(PORT->Group[g_APinDescription[mosi].ulPort].OUTCLR.reg);\n  if (cs >= 0) {\n    csPinMask = digitalPinToBitMask(cs);\n    csPortSet = &(PORT->Group[g_APinDescription[cs].ulPort].OUTSET.reg);\n    csPortClr = &(PORT->Group[g_APinDescription[cs].ulPort].OUTCLR.reg);\n  } else {\n    // No chip-select line defined; might be permanently tied to GND.\n    // Assign a valid GPIO register (though not used for CS), and an\n    // empty pin bitmask...the nonsense bit-twiddling might be faster\n    // than checking _cs and possibly branching.\n    csPortSet = dcPortSet;\n    csPortClr = dcPortClr;\n    csPinMask = 0;\n  }\n  if (miso >= 0) {\n    swspi.misoPinMask = digitalPinToBitMask(miso);\n    swspi.misoPort = (PORTreg_t)portInputRegister(digitalPinToPort(miso));\n  } else {\n    swspi.misoPinMask = 0;\n    swspi.misoPort = (PORTreg_t)portInputRegister(digitalPinToPort(dc));\n  }\n#endif // end !CORE_TEENSY\n#else  // !HAS_PORT_SET_CLR\n  dcPort = (PORTreg_t)portOutputRegister(digitalPinToPort(dc));\n  dcPinMaskSet = digitalPinToBitMask(dc);\n  swspi.sckPort = (PORTreg_t)portOutputRegister(digitalPinToPort(sck));\n  swspi.sckPinMaskSet = digitalPinToBitMask(sck);\n  swspi.mosiPort = (PORTreg_t)portOutputRegister(digitalPinToPort(mosi));\n  swspi.mosiPinMaskSet = digitalPinToBitMask(mosi);\n  if (cs >= 0) {\n    csPort = (PORTreg_t)portOutputRegister(digitalPinToPort(cs));\n    csPinMaskSet = digitalPinToBitMask(cs);\n  } else {\n    // No chip-select line defined; might be permanently tied to GND.\n    // Assign a valid GPIO register (though not used for CS), and an\n    // empty pin bitmask...the nonsense bit-twiddling might be faster\n    // than checking _cs and possibly branching.\n    csPort = dcPort;\n    csPinMaskSet = 0;\n  }\n  if (miso >= 0) {\n    swspi.misoPort = (PORTreg_t)portInputRegister(digitalPinToPort(miso));\n    swspi.misoPinMask = digitalPinToBitMask(miso);\n  } else {\n    swspi.misoPort = (PORTreg_t)portInputRegister(digitalPinToPort(dc));\n    swspi.misoPinMask = 0;\n  }\n  csPinMaskClr = ~csPinMaskSet;\n  dcPinMaskClr = ~dcPinMaskSet;\n  swspi.sckPinMaskClr = ~swspi.sckPinMaskSet;\n  swspi.mosiPinMaskClr = ~swspi.mosiPinMaskSet;\n#endif // !end HAS_PORT_SET_CLR\n#endif // end USE_FAST_PINIO\n}\n\n/*!\n    @brief   Adafruit_SPITFT constructor for hardware SPI using the board's\n             default SPI peripheral.\n    @param   w     Display width in pixels at default rotation setting (0).\n    @param   h     Display height in pixels at default rotation setting (0).\n    @param   cs    Arduino pin # for chip-select (-1 if unused, tie CS low).\n    @param   dc    Arduino pin # for data/command select (required).\n    @param   rst   Arduino pin # for display reset (optional, display reset\n                   can be tied to MCU reset, default of -1 means unused).\n    @note    Output pins are not initialized; application typically will\n             need to call subclass' begin() function, which in turn calls\n             this library's initSPI() function to initialize pins.\n*/\n#if defined(ESP8266) // See notes below\nAdafruit_SPITFT::Adafruit_SPITFT(uint16_t w, uint16_t h, int8_t cs, int8_t dc,\n                                 int8_t rst)\n    : Adafruit_GFX(w, h), connection(TFT_HARD_SPI), _rst(rst), _cs(cs),\n      _dc(dc) {\n  hwspi._spi = &SPI;\n}\n#else  // !ESP8266\nAdafruit_SPITFT::Adafruit_SPITFT(uint16_t w, uint16_t h, int8_t cs, int8_t dc,\n                                 int8_t rst)\n    : Adafruit_SPITFT(w, h, &SPI, cs, dc, rst) {\n  // This just invokes the hardware SPI constructor below,\n  // passing the default SPI device (&SPI).\n}\n#endif // end !ESP8266\n\n#if !defined(ESP8266)\n// ESP8266 compiler freaks out at this constructor -- it can't disambiguate\n// beteween the SPIClass pointer (argument #3) and a regular integer.\n// Solution here it to just not offer this variant on the ESP8266. You can\n// use the default hardware SPI peripheral, or you can use software SPI,\n// but if there's any library out there that creates a 'virtual' SPIClass\n// peripheral and drives it with software bitbanging, that's not supported.\n/*!\n    @brief   Adafruit_SPITFT constructor for hardware SPI using a specific\n             SPI peripheral.\n    @param   w         Display width in pixels at default rotation (0).\n    @param   h         Display height in pixels at default rotation (0).\n    @param   spiClass  Pointer to SPIClass type (e.g. &SPI or &SPI1).\n    @param   cs        Arduino pin # for chip-select (-1 if unused, tie CS low).\n    @param   dc        Arduino pin # for data/command select (required).\n    @param   rst       Arduino pin # for display reset (optional, display reset\n                       can be tied to MCU reset, default of -1 means unused).\n    @note    Output pins are not initialized in constructor; application\n             typically will need to call subclass' begin() function, which\n             in turn calls this library's initSPI() function to initialize\n             pins. EXCEPT...if you have built your own SERCOM SPI peripheral\n             (calling the SPIClass constructor) rather than one of the\n             built-in SPI devices (e.g. &SPI, &SPI1 and so forth), you will\n             need to call the begin() function for your object as well as\n             pinPeripheral() for the MOSI, MISO and SCK pins to configure\n             GPIO manually. Do this BEFORE calling the display-specific\n             begin or init function. Unfortunate but unavoidable.\n*/\nAdafruit_SPITFT::Adafruit_SPITFT(uint16_t w, uint16_t h, SPIClass *spiClass,\n                                 int8_t cs, int8_t dc, int8_t rst)\n    : Adafruit_GFX(w, h), connection(TFT_HARD_SPI), _rst(rst), _cs(cs),\n      _dc(dc) {\n  hwspi._spi = spiClass;\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(CORE_TEENSY)\n#if !defined(KINETISK)\n  dcPinMask = digitalPinToBitMask(dc);\n#endif\n  dcPortSet = portSetRegister(dc);\n  dcPortClr = portClearRegister(dc);\n  if (cs >= 0) {\n#if !defined(KINETISK)\n    csPinMask = digitalPinToBitMask(cs);\n#endif\n    csPortSet = portSetRegister(cs);\n    csPortClr = portClearRegister(cs);\n  } else { // see comments below\n#if !defined(KINETISK)\n    csPinMask = 0;\n#endif\n    csPortSet = dcPortSet;\n    csPortClr = dcPortClr;\n  }\n#else  // !CORE_TEENSY\n  dcPinMask = digitalPinToBitMask(dc);\n  dcPortSet = &(PORT->Group[g_APinDescription[dc].ulPort].OUTSET.reg);\n  dcPortClr = &(PORT->Group[g_APinDescription[dc].ulPort].OUTCLR.reg);\n  if (cs >= 0) {\n    csPinMask = digitalPinToBitMask(cs);\n    csPortSet = &(PORT->Group[g_APinDescription[cs].ulPort].OUTSET.reg);\n    csPortClr = &(PORT->Group[g_APinDescription[cs].ulPort].OUTCLR.reg);\n  } else {\n    // No chip-select line defined; might be permanently tied to GND.\n    // Assign a valid GPIO register (though not used for CS), and an\n    // empty pin bitmask...the nonsense bit-twiddling might be faster\n    // than checking _cs and possibly branching.\n    csPortSet = dcPortSet;\n    csPortClr = dcPortClr;\n    csPinMask = 0;\n  }\n#endif // end !CORE_TEENSY\n#else  // !HAS_PORT_SET_CLR\n  dcPort = (PORTreg_t)portOutputRegister(digitalPinToPort(dc));\n  dcPinMaskSet = digitalPinToBitMask(dc);\n  if (cs >= 0) {\n    csPort = (PORTreg_t)portOutputRegister(digitalPinToPort(cs));\n    csPinMaskSet = digitalPinToBitMask(cs);\n  } else {\n    // No chip-select line defined; might be permanently tied to GND.\n    // Assign a valid GPIO register (though not used for CS), and an\n    // empty pin bitmask...the nonsense bit-twiddling might be faster\n    // than checking _cs and possibly branching.\n    csPort = dcPort;\n    csPinMaskSet = 0;\n  }\n  csPinMaskClr = ~csPinMaskSet;\n  dcPinMaskClr = ~dcPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#endif // end USE_FAST_PINIO\n}\n#endif // end !ESP8266\n\n/*!\n    @brief   Adafruit_SPITFT constructor for parallel display connection.\n    @param   w         Display width in pixels at default rotation (0).\n    @param   h         Display height in pixels at default rotation (0).\n    @param   busWidth  If tft16 (enumeration in header file), is a 16-bit\n                       parallel connection, else 8-bit.\n                       16-bit isn't fully implemented or tested yet so\n                       applications should pass \"tft8bitbus\" for now...needed to\n                       stick a required enum argument in there to\n                       disambiguate this constructor from the soft-SPI case.\n                       Argument is ignored on 8-bit architectures (no 'wide'\n                       support there since PORTs are 8 bits anyway).\n    @param   d0        Arduino pin # for data bit 0 (1+ are extrapolated).\n                       The 8 (or 16) data bits MUST be contiguous and byte-\n                       aligned (or word-aligned for wide interface) within\n                       the same PORT register (might not correspond to\n                       Arduino pin sequence).\n    @param   wr        Arduino pin # for write strobe (required).\n    @param   dc        Arduino pin # for data/command select (required).\n    @param   cs        Arduino pin # for chip-select (optional, -1 if unused,\n                       tie CS low).\n    @param   rst       Arduino pin # for display reset (optional, display reset\n                       can be tied to MCU reset, default of -1 means unused).\n    @param   rd        Arduino pin # for read strobe (optional, -1 if unused).\n    @note    Output pins are not initialized; application typically will need\n             to call subclass' begin() function, which in turn calls this\n             library's initSPI() function to initialize pins.\n             Yes, the name is a misnomer...this library originally handled\n             only SPI displays, parallel being a recent addition (but not\n             wanting to break existing code).\n*/\nAdafruit_SPITFT::Adafruit_SPITFT(uint16_t w, uint16_t h, tftBusWidth busWidth,\n                                 int8_t d0, int8_t wr, int8_t dc, int8_t cs,\n                                 int8_t rst, int8_t rd)\n    : Adafruit_GFX(w, h), connection(TFT_PARALLEL), _rst(rst), _cs(cs),\n      _dc(dc) {\n  tft8._d0 = d0;\n  tft8._wr = wr;\n  tft8._rd = rd;\n  tft8.wide = (busWidth == tft16bitbus);\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(CORE_TEENSY)\n  tft8.wrPortSet = portSetRegister(wr);\n  tft8.wrPortClr = portClearRegister(wr);\n#if !defined(KINETISK)\n  dcPinMask = digitalPinToBitMask(dc);\n#endif\n  dcPortSet = portSetRegister(dc);\n  dcPortClr = portClearRegister(dc);\n  if (cs >= 0) {\n#if !defined(KINETISK)\n    csPinMask = digitalPinToBitMask(cs);\n#endif\n    csPortSet = portSetRegister(cs);\n    csPortClr = portClearRegister(cs);\n  } else { // see comments below\n#if !defined(KINETISK)\n    csPinMask = 0;\n#endif\n    csPortSet = dcPortSet;\n    csPortClr = dcPortClr;\n  }\n  if (rd >= 0) { // if read-strobe pin specified...\n#if defined(KINETISK)\n    tft8.rdPinMask = 1;\n#else // !KINETISK\n    tft8.rdPinMask = digitalPinToBitMask(rd);\n#endif\n    tft8.rdPortSet = portSetRegister(rd);\n    tft8.rdPortClr = portClearRegister(rd);\n  } else {\n    tft8.rdPinMask = 0;\n    tft8.rdPortSet = dcPortSet;\n    tft8.rdPortClr = dcPortClr;\n  }\n  // These are all uint8_t* pointers -- elsewhere they're recast\n  // as necessary if a 'wide' 16-bit interface is in use.\n  tft8.writePort = portOutputRegister(d0);\n  tft8.readPort = portInputRegister(d0);\n  tft8.dirSet = portModeRegister(d0);\n  tft8.dirClr = portModeRegister(d0);\n#else  // !CORE_TEENSY\n  tft8.wrPinMask = digitalPinToBitMask(wr);\n  tft8.wrPortSet = &(PORT->Group[g_APinDescription[wr].ulPort].OUTSET.reg);\n  tft8.wrPortClr = &(PORT->Group[g_APinDescription[wr].ulPort].OUTCLR.reg);\n  dcPinMask = digitalPinToBitMask(dc);\n  dcPortSet = &(PORT->Group[g_APinDescription[dc].ulPort].OUTSET.reg);\n  dcPortClr = &(PORT->Group[g_APinDescription[dc].ulPort].OUTCLR.reg);\n  if (cs >= 0) {\n    csPinMask = digitalPinToBitMask(cs);\n    csPortSet = &(PORT->Group[g_APinDescription[cs].ulPort].OUTSET.reg);\n    csPortClr = &(PORT->Group[g_APinDescription[cs].ulPort].OUTCLR.reg);\n  } else {\n    // No chip-select line defined; might be permanently tied to GND.\n    // Assign a valid GPIO register (though not used for CS), and an\n    // empty pin bitmask...the nonsense bit-twiddling might be faster\n    // than checking _cs and possibly branching.\n    csPortSet = dcPortSet;\n    csPortClr = dcPortClr;\n    csPinMask = 0;\n  }\n  if (rd >= 0) { // if read-strobe pin specified...\n    tft8.rdPinMask = digitalPinToBitMask(rd);\n    tft8.rdPortSet = &(PORT->Group[g_APinDescription[rd].ulPort].OUTSET.reg);\n    tft8.rdPortClr = &(PORT->Group[g_APinDescription[rd].ulPort].OUTCLR.reg);\n  } else {\n    tft8.rdPinMask = 0;\n    tft8.rdPortSet = dcPortSet;\n    tft8.rdPortClr = dcPortClr;\n  }\n  // Get pointers to PORT write/read/dir bytes within 32-bit PORT\n  uint8_t dBit = g_APinDescription[d0].ulPin; // d0 bit # in PORT\n  PortGroup *p = (&(PORT->Group[g_APinDescription[d0].ulPort]));\n  uint8_t offset = dBit / 8; // d[7:0] byte # within PORT\n  if (tft8.wide)\n    offset &= ~1; // d[15:8] byte # within PORT\n  // These are all uint8_t* pointers -- elsewhere they're recast\n  // as necessary if a 'wide' 16-bit interface is in use.\n  tft8.writePort = (volatile uint8_t *)&(p->OUT.reg) + offset;\n  tft8.readPort = (volatile uint8_t *)&(p->IN.reg) + offset;\n  tft8.dirSet = (volatile uint8_t *)&(p->DIRSET.reg) + offset;\n  tft8.dirClr = (volatile uint8_t *)&(p->DIRCLR.reg) + offset;\n#endif // end !CORE_TEENSY\n#else  // !HAS_PORT_SET_CLR\n  tft8.wrPort = (PORTreg_t)portOutputRegister(digitalPinToPort(wr));\n  tft8.wrPinMaskSet = digitalPinToBitMask(wr);\n  dcPort = (PORTreg_t)portOutputRegister(digitalPinToPort(dc));\n  dcPinMaskSet = digitalPinToBitMask(dc);\n  if (cs >= 0) {\n    csPort = (PORTreg_t)portOutputRegister(digitalPinToPort(cs));\n    csPinMaskSet = digitalPinToBitMask(cs);\n  } else {\n    // No chip-select line defined; might be permanently tied to GND.\n    // Assign a valid GPIO register (though not used for CS), and an\n    // empty pin bitmask...the nonsense bit-twiddling might be faster\n    // than checking _cs and possibly branching.\n    csPort = dcPort;\n    csPinMaskSet = 0;\n  }\n  if (rd >= 0) { // if read-strobe pin specified...\n    tft8.rdPort = (PORTreg_t)portOutputRegister(digitalPinToPort(rd));\n    tft8.rdPinMaskSet = digitalPinToBitMask(rd);\n  } else {\n    tft8.rdPort = dcPort;\n    tft8.rdPinMaskSet = 0;\n  }\n  csPinMaskClr = ~csPinMaskSet;\n  dcPinMaskClr = ~dcPinMaskSet;\n  tft8.wrPinMaskClr = ~tft8.wrPinMaskSet;\n  tft8.rdPinMaskClr = ~tft8.rdPinMaskSet;\n  tft8.writePort = (PORTreg_t)portOutputRegister(digitalPinToPort(d0));\n  tft8.readPort = (PORTreg_t)portInputRegister(digitalPinToPort(d0));\n  tft8.portDir = (PORTreg_t)portModeRegister(digitalPinToPort(d0));\n#endif // end !HAS_PORT_SET_CLR\n#endif // end USE_FAST_PINIO\n}\n\n// end constructors -------\n\n// CLASS MEMBER FUNCTIONS --------------------------------------------------\n\n// begin() and setAddrWindow() MUST be declared by any subclass.\n\n/*!\n    @brief  Configure microcontroller pins for TFT interfacing. Typically\n            called by a subclass' begin() function.\n    @param  freq     SPI frequency when using hardware SPI. If default (0)\n                     is passed, will fall back on a device-specific value.\n                     Value is ignored when using software SPI or parallel\n                     connection.\n    @param  spiMode  SPI mode when using hardware SPI. MUST be one of the\n                     values SPI_MODE0, SPI_MODE1, SPI_MODE2 or SPI_MODE3\n                     defined in SPI.h. Do NOT attempt to pass '0' for\n                     SPI_MODE0 and so forth...the values are NOT the same!\n                     Use ONLY the defines! (Pity it's not an enum.)\n    @note   Another anachronistically-named function; this is called even\n            when the display connection is parallel (not SPI). Also, this\n            could probably be made private...quite a few class functions\n            were generously put in the public section.\n*/\nvoid Adafruit_SPITFT::initSPI(uint32_t freq, uint8_t spiMode) {\n\n  if (!freq)\n    freq = DEFAULT_SPI_FREQ; // If no freq specified, use default\n\n  // Init basic control pins common to all connection types\n  if (_cs >= 0) {\n    pinMode(_cs, OUTPUT);\n    digitalWrite(_cs, HIGH); // Deselect\n  }\n  pinMode(_dc, OUTPUT);\n  digitalWrite(_dc, HIGH); // Data mode\n\n  if (connection == TFT_HARD_SPI) {\n\n#if defined(SPI_HAS_TRANSACTION)\n    hwspi.settings = SPISettings(freq, MSBFIRST, spiMode);\n#else\n    hwspi._freq = freq; // Save freq value for later\n#endif\n    hwspi._mode = spiMode; // Save spiMode value for later\n    // Call hwspi._spi->begin() ONLY if this is among the 'established'\n    // SPI interfaces in variant.h. For DIY roll-your-own SERCOM SPIs,\n    // begin() and pinPeripheral() calls MUST be made in one's calling\n    // code, BEFORE the screen-specific begin/init function is called.\n    // Reason for this is that SPI::begin() makes its own calls to\n    // pinPeripheral() based on g_APinDescription[n].ulPinType, which\n    // on non-established SPI interface pins will always be PIO_DIGITAL\n    // or similar, while we need PIO_SERCOM or PIO_SERCOM_ALT...it's\n    // highly unique between devices and variants for each pin or\n    // SERCOM so we can't make those calls ourselves here. And the SPI\n    // device needs to be set up before calling this because it's\n    // immediately followed with initialization commands. Blargh.\n    if (\n#if !defined(SPI_INTERFACES_COUNT)\n        1\n#else\n#if SPI_INTERFACES_COUNT > 0\n        (hwspi._spi == &SPI)\n#endif\n#if SPI_INTERFACES_COUNT > 1\n        || (hwspi._spi == &SPI1)\n#endif\n#if SPI_INTERFACES_COUNT > 2\n        || (hwspi._spi == &SPI2)\n#endif\n#if SPI_INTERFACES_COUNT > 3\n        || (hwspi._spi == &SPI3)\n#endif\n#if SPI_INTERFACES_COUNT > 4\n        || (hwspi._spi == &SPI4)\n#endif\n#if SPI_INTERFACES_COUNT > 5\n        || (hwspi._spi == &SPI5)\n#endif\n#endif // end SPI_INTERFACES_COUNT\n    ) {\n      hwspi._spi->begin();\n    }\n  } else if (connection == TFT_SOFT_SPI) {\n\n    pinMode(swspi._mosi, OUTPUT);\n    digitalWrite(swspi._mosi, LOW);\n    pinMode(swspi._sck, OUTPUT);\n    digitalWrite(swspi._sck, LOW);\n    if (swspi._miso >= 0) {\n      pinMode(swspi._miso, INPUT);\n    }\n\n  } else { // TFT_PARALLEL\n           // Initialize data pins.  We were only passed d0, so scan\n           // the pin description list looking for the other pins.\n           // They'll be on the same PORT, and within the next 7 (or 15) bits\n           // (because we need to write to a contiguous PORT byte or word).\n#if defined(__AVR__)\n    // PORT registers are 8 bits wide, so just need a register match...\n    for (uint8_t i = 0; i < NUM_DIGITAL_PINS; i++) {\n      if ((PORTreg_t)portOutputRegister(digitalPinToPort(i)) ==\n          tft8.writePort) {\n        pinMode(i, OUTPUT);\n        digitalWrite(i, LOW);\n      }\n    }\n#elif defined(USE_FAST_PINIO)\n#if defined(CORE_TEENSY)\n    if (!tft8.wide) {\n      *tft8.dirSet = 0xFF;    // Set port to output\n      *tft8.writePort = 0x00; // Write all 0s\n    } else {\n      *(volatile uint16_t *)tft8.dirSet = 0xFFFF;\n      *(volatile uint16_t *)tft8.writePort = 0x0000;\n    }\n#else  // !CORE_TEENSY\n    uint8_t portNum = g_APinDescription[tft8._d0].ulPort, // d0 PORT #\n        dBit = g_APinDescription[tft8._d0].ulPin,         // d0 bit in PORT\n        lastBit = dBit + (tft8.wide ? 15 : 7);\n    for (uint8_t i = 0; i < PINS_COUNT; i++) {\n      if ((g_APinDescription[i].ulPort == portNum) &&\n          (g_APinDescription[i].ulPin >= dBit) &&\n          (g_APinDescription[i].ulPin <= (uint32_t)lastBit)) {\n        pinMode(i, OUTPUT);\n        digitalWrite(i, LOW);\n      }\n    }\n#endif // end !CORE_TEENSY\n#endif\n    pinMode(tft8._wr, OUTPUT);\n    digitalWrite(tft8._wr, HIGH);\n    if (tft8._rd >= 0) {\n      pinMode(tft8._rd, OUTPUT);\n      digitalWrite(tft8._rd, HIGH);\n    }\n  }\n\n  if (_rst >= 0) {\n    // Toggle _rst low to reset\n    pinMode(_rst, OUTPUT);\n    digitalWrite(_rst, HIGH);\n    delay(100);\n    digitalWrite(_rst, LOW);\n    delay(100);\n    digitalWrite(_rst, HIGH);\n    delay(200);\n  }\n\n#if defined(USE_SPI_DMA) && (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n  if (((connection == TFT_HARD_SPI) || (connection == TFT_PARALLEL)) &&\n      (dma.allocate() == DMA_STATUS_OK)) { // Allocate channel\n    // The DMA library needs to alloc at least one valid descriptor,\n    // so we do that here. It's not used in the usual sense though,\n    // just before a transfer we copy descriptor[0] to this address.\n    if (dptr = dma.addDescriptor(NULL, NULL, 42, DMA_BEAT_SIZE_BYTE, false,\n                                 false)) {\n      // Alloc 2 scanlines worth of pixels on display's major axis,\n      // whichever that is, rounding each up to 2-pixel boundary.\n      int major = (WIDTH > HEIGHT) ? WIDTH : HEIGHT;\n      major += (major & 1);   // -> next 2-pixel bound, if needed.\n      maxFillLen = major * 2; // 2 scanlines\n      // Note to future self: if you decide to make the pixel buffer\n      // much larger, remember that DMA transfer descriptors can't\n      // exceed 65,535 bytes (not 65,536), meaning 32,767 pixels max.\n      // Not that we have that kind of RAM to throw around right now.\n      if ((pixelBuf[0] = (uint16_t *)malloc(maxFillLen * sizeof(uint16_t)))) {\n        // Alloc OK. Get pointer to start of second scanline.\n        pixelBuf[1] = &pixelBuf[0][major];\n        // Determine number of DMA descriptors needed to cover\n        // entire screen when entire 2-line pixelBuf is used\n        // (round up for fractional last descriptor).\n        int numDescriptors = (WIDTH * HEIGHT + (maxFillLen - 1)) / maxFillLen;\n        // DMA descriptors MUST be 128-bit (16 byte) aligned.\n        // memalign() is considered obsolete but it's replacements\n        // (aligned_alloc() or posix_memalign()) are not currently\n        // available in the version of ARM GCC in use, but this\n        // is, so here we are.\n        if ((descriptor = (DmacDescriptor *)memalign(\n                 16, numDescriptors * sizeof(DmacDescriptor)))) {\n          int dmac_id;\n          volatile uint32_t *data_reg;\n\n          if (connection == TFT_HARD_SPI) {\n            // THIS IS AN AFFRONT TO NATURE, but I don't know\n            // any \"clean\" way to get the sercom number from the\n            // the SPIClass pointer (e.g. &SPI or &SPI1), which\n            // is all we have to work with. SPIClass does contain\n            // a SERCOM pointer but it is a PRIVATE member!\n            // Doing an UNSPEAKABLY HORRIBLE THING here, directly\n            // accessing the first 32-bit value in the SPIClass\n            // structure, knowing that's (currently) where the\n            // SERCOM pointer lives, but this ENTIRELY DEPENDS on\n            // that structure not changing nor the compiler\n            // rearranging things. Oh the humanity!\n\n            if (*(SERCOM **)hwspi._spi == &sercom0) {\n              dmac_id = SERCOM0_DMAC_ID_TX;\n              data_reg = &SERCOM0->SPI.DATA.reg;\n#if defined SERCOM1\n            } else if (*(SERCOM **)hwspi._spi == &sercom1) {\n              dmac_id = SERCOM1_DMAC_ID_TX;\n              data_reg = &SERCOM1->SPI.DATA.reg;\n#endif\n#if defined SERCOM2\n            } else if (*(SERCOM **)hwspi._spi == &sercom2) {\n              dmac_id = SERCOM2_DMAC_ID_TX;\n              data_reg = &SERCOM2->SPI.DATA.reg;\n#endif\n#if defined SERCOM3\n            } else if (*(SERCOM **)hwspi._spi == &sercom3) {\n              dmac_id = SERCOM3_DMAC_ID_TX;\n              data_reg = &SERCOM3->SPI.DATA.reg;\n#endif\n#if defined SERCOM4\n            } else if (*(SERCOM **)hwspi._spi == &sercom4) {\n              dmac_id = SERCOM4_DMAC_ID_TX;\n              data_reg = &SERCOM4->SPI.DATA.reg;\n#endif\n#if defined SERCOM5\n            } else if (*(SERCOM **)hwspi._spi == &sercom5) {\n              dmac_id = SERCOM5_DMAC_ID_TX;\n              data_reg = &SERCOM5->SPI.DATA.reg;\n#endif\n#if defined SERCOM6\n            } else if (*(SERCOM **)hwspi._spi == &sercom6) {\n              dmac_id = SERCOM6_DMAC_ID_TX;\n              data_reg = &SERCOM6->SPI.DATA.reg;\n#endif\n#if defined SERCOM7\n            } else if (*(SERCOM **)hwspi._spi == &sercom7) {\n              dmac_id = SERCOM7_DMAC_ID_TX;\n              data_reg = &SERCOM7->SPI.DATA.reg;\n#endif\n            }\n            dma.setPriority(DMA_PRIORITY_3);\n            dma.setTrigger(dmac_id);\n            dma.setAction(DMA_TRIGGER_ACTON_BEAT);\n\n            // Initialize descriptor list.\n            for (int d = 0; d < numDescriptors; d++) {\n              // No need to set SRCADDR, DESCADDR or BTCNT --\n              // those are done in the pixel-writing functions.\n              descriptor[d].BTCTRL.bit.VALID = true;\n              descriptor[d].BTCTRL.bit.EVOSEL = DMA_EVENT_OUTPUT_DISABLE;\n              descriptor[d].BTCTRL.bit.BLOCKACT = DMA_BLOCK_ACTION_NOACT;\n              descriptor[d].BTCTRL.bit.BEATSIZE = DMA_BEAT_SIZE_BYTE;\n              descriptor[d].BTCTRL.bit.DSTINC = 0;\n              descriptor[d].BTCTRL.bit.STEPSEL = DMA_STEPSEL_SRC;\n              descriptor[d].BTCTRL.bit.STEPSIZE =\n                  DMA_ADDRESS_INCREMENT_STEP_SIZE_1;\n              descriptor[d].DSTADDR.reg = (uint32_t)data_reg;\n            }\n\n          } else { // Parallel connection\n\n#if defined(__SAMD51__)\n            int dmaChannel = dma.getChannel();\n            // Enable event output, use EVOSEL output\n            DMAC->Channel[dmaChannel].CHEVCTRL.bit.EVOE = 1;\n            DMAC->Channel[dmaChannel].CHEVCTRL.bit.EVOMODE = 0;\n\n            // CONFIGURE TIMER/COUNTER (for write strobe)\n\n            Tc *timer = tcList[tcNum].tc; // -> Timer struct\n            int id = tcList[tcNum].gclk;  // Timer GCLK ID\n            GCLK_PCHCTRL_Type pchctrl;\n\n            // Set up timer clock source from GCLK\n            GCLK->PCHCTRL[id].bit.CHEN = 0; // Stop timer\n            while (GCLK->PCHCTRL[id].bit.CHEN)\n              ; // Wait for it\n            pchctrl.bit.GEN = GCLK_PCHCTRL_GEN_GCLK0_Val;\n            pchctrl.bit.CHEN = 1; // Enable\n            GCLK->PCHCTRL[id].reg = pchctrl.reg;\n            while (!GCLK->PCHCTRL[id].bit.CHEN)\n              ; // Wait for it\n\n            // Disable timer/counter before configuring it\n            timer->COUNT8.CTRLA.bit.ENABLE = 0;\n            while (timer->COUNT8.SYNCBUSY.bit.STATUS)\n              ;\n\n            timer->COUNT8.WAVE.bit.WAVEGEN = 2;    // NPWM\n            timer->COUNT8.CTRLA.bit.MODE = 1;      // 8-bit\n            timer->COUNT8.CTRLA.bit.PRESCALER = 0; // 1:1\n            while (timer->COUNT8.SYNCBUSY.bit.STATUS)\n              ;\n\n            timer->COUNT8.CTRLBCLR.bit.DIR = 1; // Count UP\n            while (timer->COUNT8.SYNCBUSY.bit.CTRLB)\n              ;\n            timer->COUNT8.CTRLBSET.bit.ONESHOT = 1; // One-shot\n            while (timer->COUNT8.SYNCBUSY.bit.CTRLB)\n              ;\n            timer->COUNT8.PER.reg = 6; // PWM top\n            while (timer->COUNT8.SYNCBUSY.bit.PER)\n              ;\n            timer->COUNT8.CC[0].reg = 2; // Compare\n            while (timer->COUNT8.SYNCBUSY.bit.CC0)\n              ;\n            // Enable async input events,\n            // event action = restart.\n            timer->COUNT8.EVCTRL.bit.TCEI = 1;\n            timer->COUNT8.EVCTRL.bit.EVACT = 1;\n\n            // Enable timer\n            timer->COUNT8.CTRLA.reg |= TC_CTRLA_ENABLE;\n            while (timer->COUNT8.SYNCBUSY.bit.STATUS)\n              ;\n\n#if (wrPeripheral == PIO_CCL)\n            // CONFIGURE CCL (inverts timer/counter output)\n\n            MCLK->APBCMASK.bit.CCL_ = 1;         // Enable CCL clock\n            CCL->CTRL.bit.ENABLE = 0;            // Disable to config\n            CCL->CTRL.bit.SWRST = 1;             // Reset CCL registers\n            CCL->LUTCTRL[tcNum].bit.ENABLE = 0;  // Disable LUT\n            CCL->LUTCTRL[tcNum].bit.FILTSEL = 0; // No filter\n            CCL->LUTCTRL[tcNum].bit.INSEL0 = 6;  // TC input\n            CCL->LUTCTRL[tcNum].bit.INSEL1 = 0;  // MASK\n            CCL->LUTCTRL[tcNum].bit.INSEL2 = 0;  // MASK\n            CCL->LUTCTRL[tcNum].bit.TRUTH = 1;   // Invert in 0\n            CCL->LUTCTRL[tcNum].bit.ENABLE = 1;  // Enable LUT\n            CCL->CTRL.bit.ENABLE = 1;            // Enable CCL\n#endif\n\n            // CONFIGURE EVENT SYSTEM\n\n            // Set up event system clock source from GCLK...\n            // Disable EVSYS, wait for disable\n            GCLK->PCHCTRL[EVSYS_GCLK_ID_0].bit.CHEN = 0;\n            while (GCLK->PCHCTRL[EVSYS_GCLK_ID_0].bit.CHEN)\n              ;\n            pchctrl.bit.GEN = GCLK_PCHCTRL_GEN_GCLK0_Val;\n            pchctrl.bit.CHEN = 1; // Re-enable\n            GCLK->PCHCTRL[EVSYS_GCLK_ID_0].reg = pchctrl.reg;\n            // Wait for it, then enable EVSYS clock\n            while (!GCLK->PCHCTRL[EVSYS_GCLK_ID_0].bit.CHEN)\n              ;\n            MCLK->APBBMASK.bit.EVSYS_ = 1;\n\n            // Connect Timer EVU to ch 0\n            EVSYS->USER[tcList[tcNum].evu].reg = 1;\n            // Datasheet recommends single write operation;\n            // reg instead of bit. Also datasheet: PATH bits\n            // must be zero when using async!\n            EVSYS_CHANNEL_Type ev;\n            ev.reg = 0;\n            ev.bit.PATH = 2;                  // Asynchronous\n            ev.bit.EVGEN = 0x22 + dmaChannel; // DMA channel 0+\n            EVSYS->Channel[0].CHANNEL.reg = ev.reg;\n\n            // Initialize descriptor list.\n            for (int d = 0; d < numDescriptors; d++) {\n              // No need to set SRCADDR, DESCADDR or BTCNT --\n              // those are done in the pixel-writing functions.\n              descriptor[d].BTCTRL.bit.VALID = true;\n              // Event strobe on beat xfer:\n              descriptor[d].BTCTRL.bit.EVOSEL = 0x3;\n              descriptor[d].BTCTRL.bit.BLOCKACT = DMA_BLOCK_ACTION_NOACT;\n              descriptor[d].BTCTRL.bit.BEATSIZE =\n                  tft8.wide ? DMA_BEAT_SIZE_HWORD : DMA_BEAT_SIZE_BYTE;\n              descriptor[d].BTCTRL.bit.SRCINC = 1;\n              descriptor[d].BTCTRL.bit.DSTINC = 0;\n              descriptor[d].BTCTRL.bit.STEPSEL = DMA_STEPSEL_SRC;\n              descriptor[d].BTCTRL.bit.STEPSIZE =\n                  DMA_ADDRESS_INCREMENT_STEP_SIZE_1;\n              descriptor[d].DSTADDR.reg = (uint32_t)tft8.writePort;\n            }\n#endif      // __SAMD51\n          } // end parallel-specific DMA setup\n\n          lastFillColor = 0x0000;\n          lastFillLen = 0;\n          dma.setCallback(dma_callback);\n          return; // Success!\n                  // else clean up any partial allocation...\n        }         // end descriptor memalign()\n        free(pixelBuf[0]);\n        pixelBuf[0] = pixelBuf[1] = NULL;\n      }         // end pixelBuf malloc()\n                // Don't currently have a descriptor delete function in\n                // ZeroDMA lib, but if we did, it would be called here.\n    }           // end addDescriptor()\n    dma.free(); // Deallocate DMA channel\n  }\n#endif // end USE_SPI_DMA\n}\n\n/*!\n    @brief  Allow changing the SPI clock speed after initialization\n    @param  freq Desired frequency of SPI clock, may not be the\n    end frequency you get based on what the chip can do!\n*/\nvoid Adafruit_SPITFT::setSPISpeed(uint32_t freq) {\n#if defined(SPI_HAS_TRANSACTION)\n  hwspi.settings = SPISettings(freq, MSBFIRST, hwspi._mode);\n#else\n  hwspi._freq = freq; // Save freq value for later\n#endif\n}\n\n/*!\n    @brief  Call before issuing command(s) or data to display. Performs\n            chip-select (if required) and starts an SPI transaction (if\n            using hardware SPI and transactions are supported). Required\n            for all display types; not an SPI-specific function.\n*/\nvoid Adafruit_SPITFT::startWrite(void) {\n  SPI_BEGIN_TRANSACTION();\n  if (_cs >= 0)\n    SPI_CS_LOW();\n}\n\n/*!\n    @brief  Call after issuing command(s) or data to display. Performs\n            chip-deselect (if required) and ends an SPI transaction (if\n            using hardware SPI and transactions are supported). Required\n            for all display types; not an SPI-specific function.\n*/\nvoid Adafruit_SPITFT::endWrite(void) {\n  if (_cs >= 0)\n    SPI_CS_HIGH();\n  SPI_END_TRANSACTION();\n}\n\n// -------------------------------------------------------------------------\n// Lower-level graphics operations. These functions require a chip-select\n// and/or SPI transaction around them (via startWrite(), endWrite() above).\n// Higher-level graphics primitives might start a single transaction and\n// then make multiple calls to these functions (e.g. circle or text\n// rendering might make repeated lines or rects) before ending the\n// transaction. It's more efficient than starting a transaction every time.\n\n/*!\n    @brief  Draw a single pixel to the display at requested coordinates.\n            Not self-contained; should follow a startWrite() call.\n    @param  x      Horizontal position (0 = left).\n    @param  y      Vertical position   (0 = top).\n    @param  color  16-bit pixel color in '565' RGB format.\n*/\nvoid Adafruit_SPITFT::writePixel(int16_t x, int16_t y, uint16_t color) {\n  if ((x >= 0) && (x < _width) && (y >= 0) && (y < _height)) {\n    setAddrWindow(x, y, 1, 1);\n    SPI_WRITE16(color);\n  }\n}\n\n/*!\n    @brief  Swap bytes in an array of pixels; converts little-to-big or\n            big-to-little endian. Used by writePixels() below in some\n            situations, but may also be helpful for user code occasionally.\n    @param  src   Source address of 16-bit pixels buffer.\n    @param  len   Number of pixels to byte-swap.\n    @param  dest  Optional destination address if different than src --\n                  otherwise, if NULL (default) or same address is passed,\n                  pixel buffer is overwritten in-place.\n*/\nvoid Adafruit_SPITFT::swapBytes(uint16_t *src, uint32_t len, uint16_t *dest) {\n  if (!dest)\n    dest = src; // NULL -> overwrite src buffer\n  for (uint32_t i = 0; i < len; i++) {\n    dest[i] = __builtin_bswap16(src[i]);\n  }\n}\n\n/*!\n    @brief  Issue a series of pixels from memory to the display. Not self-\n            contained; should follow startWrite() and setAddrWindow() calls.\n    @param  colors     Pointer to array of 16-bit pixel values in '565' RGB\n                       format.\n    @param  len        Number of elements in 'colors' array.\n    @param  block      If true (default case if unspecified), function blocks\n                       until DMA transfer is complete. This is simply IGNORED\n                       if DMA is not enabled. If false, the function returns\n                       immediately after the last DMA transfer is started,\n                       and one should use the dmaWait() function before\n                       doing ANY other display-related activities (or even\n                       any SPI-related activities, if using an SPI display\n                       that shares the bus with other devices).\n    @param  bigEndian  If true, bitmap in memory is in big-endian order (most\n                       significant byte first). By default this is false, as\n                       most microcontrollers seem to be little-endian and\n                       16-bit pixel values must be byte-swapped before\n                       issuing to the display (which tend toward big-endian\n                       when using SPI or 8-bit parallel). If an application\n                       can optimize around this -- for example, a bitmap in a\n                       uint16_t array having the byte values already ordered\n                       big-endian, this can save time here, ESPECIALLY if\n                       using this function's non-blocking DMA mode.\n*/\nvoid Adafruit_SPITFT::writePixels(uint16_t *colors, uint32_t len, bool block,\n                                  bool bigEndian) {\n\n  if (!len)\n    return; // Avoid 0-byte transfers\n\n  // avoid paramater-not-used complaints\n  (void)block;\n  (void)bigEndian;\n\n#if defined(ESP32)\n  if (connection == TFT_HARD_SPI) {\n    if (!bigEndian) {\n      hwspi._spi->writePixels(colors, len * 2); // Inbuilt endian-swap\n    } else {\n      hwspi._spi->writeBytes((uint8_t *)colors, len * 2); // Issue bytes direct\n    }\n    return;\n  }\n#elif defined(ARDUINO_NRF52_ADAFRUIT) &&                                       \\\n    defined(NRF52840_XXAA) // Adafruit nRF52 use SPIM3 DMA at 32Mhz\n  if (!bigEndian) {\n    swapBytes(colors, len); // convert little-to-big endian for display\n  }\n  hwspi._spi->transfer(colors, NULL, 2 * len); // NULL RX to avoid overwrite\n  if (!bigEndian) {\n    swapBytes(colors, len); // big-to-little endian to restore pixel buffer\n  }\n\n  return;\n#elif defined(ARDUINO_ARCH_RP2040)\n  spi_inst_t *pi_spi = hwspi._spi == &SPI ? spi0 : spi1;\n\n  if (!bigEndian) {\n    // switch to 16-bit writes\n    hw_write_masked(&spi_get_hw(pi_spi)->cr0, 15 << SPI_SSPCR0_DSS_LSB,\n                    SPI_SSPCR0_DSS_BITS);\n    spi_write16_blocking(pi_spi, colors, len);\n    // switch back to 8-bit\n    hw_write_masked(&spi_get_hw(pi_spi)->cr0, 7 << SPI_SSPCR0_DSS_LSB,\n                    SPI_SSPCR0_DSS_BITS);\n  } else {\n    spi_write_blocking(pi_spi, (uint8_t *)colors, len * 2);\n  }\n  return;\n#elif defined(ARDUINO_ARCH_RTTHREAD)\n  if (!bigEndian) {\n    swapBytes(colors, len); // convert little-to-big endian for display\n  }\n  hwspi._spi->transfer(colors, 2 * len);\n  if (!bigEndian) {\n    swapBytes(colors, len); // big-to-little endian to restore pixel buffer\n  }\n  return;\n#elif defined(USE_SPI_DMA) &&                                                  \\\n    (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n  if ((connection == TFT_HARD_SPI) || (connection == TFT_PARALLEL)) {\n    int maxSpan = maxFillLen / 2; // One scanline max\n    uint8_t pixelBufIdx = 0;      // Active pixel buffer number\n#if defined(__SAMD51__)\n    if (connection == TFT_PARALLEL) {\n      // Switch WR pin to PWM or CCL\n      pinPeripheral(tft8._wr, wrPeripheral);\n    }\n#endif // end __SAMD51__\n    if (!bigEndian) { // Normal little-endian situation...\n      while (len) {\n        int count = (len < maxSpan) ? len : maxSpan;\n\n        // Because TFT and SAMD endianisms are different, must swap\n        // bytes from the 'colors' array passed into a DMA working\n        // buffer. This can take place while the prior DMA transfer\n        // is in progress, hence the need for two pixelBufs.\n        swapBytes(colors, count, pixelBuf[pixelBufIdx]);\n        colors += count;\n\n        // The transfers themselves are relatively small, so we don't\n        // need a long descriptor list. We just alternate between the\n        // first two, sharing pixelBufIdx for that purpose.\n        descriptor[pixelBufIdx].SRCADDR.reg =\n            (uint32_t)pixelBuf[pixelBufIdx] + count * 2;\n        descriptor[pixelBufIdx].BTCTRL.bit.SRCINC = 1;\n        descriptor[pixelBufIdx].BTCNT.reg = count * 2;\n        descriptor[pixelBufIdx].DESCADDR.reg = 0;\n\n        while (dma_busy)\n          ; // Wait for prior line to finish\n\n        // Move new descriptor into place...\n        memcpy(dptr, &descriptor[pixelBufIdx], sizeof(DmacDescriptor));\n        dma_busy = true;\n        dma.startJob(); // Trigger SPI DMA transfer\n        if (connection == TFT_PARALLEL)\n          dma.trigger();\n        pixelBufIdx = 1 - pixelBufIdx; // Swap DMA pixel buffers\n\n        len -= count;\n      }\n    } else { // bigEndian == true\n      // With big-endian pixel data, this can be handled as a single\n      // DMA transfer using chained descriptors. Even full screen, this\n      // needs only a relatively short descriptor list, each\n      // transferring a max of 32,767 (not 32,768) pixels. The list\n      // was allocated large enough to accommodate a full screen's\n      // worth of data, so this won't run past the end of the list.\n      int d, numDescriptors = (len + 32766) / 32767;\n      for (d = 0; d < numDescriptors; d++) {\n        int count = (len < 32767) ? len : 32767;\n        descriptor[d].SRCADDR.reg = (uint32_t)colors + count * 2;\n        descriptor[d].BTCTRL.bit.SRCINC = 1;\n        descriptor[d].BTCNT.reg = count * 2;\n        descriptor[d].DESCADDR.reg = (uint32_t)&descriptor[d + 1];\n        len -= count;\n        colors += count;\n      }\n      descriptor[d - 1].DESCADDR.reg = 0;\n\n      while (dma_busy)\n        ; // Wait for prior transfer (if any) to finish\n\n      // Move first descriptor into place and start transfer...\n      memcpy(dptr, &descriptor[0], sizeof(DmacDescriptor));\n      dma_busy = true;\n      dma.startJob(); // Trigger SPI DMA transfer\n      if (connection == TFT_PARALLEL)\n        dma.trigger();\n    } // end bigEndian\n\n    lastFillColor = 0x0000; // pixelBuf has been sullied\n    lastFillLen = 0;\n    if (block) {\n      while (dma_busy)\n        ; // Wait for last line to complete\n#if defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO)\n      if (connection == TFT_HARD_SPI) {\n        // See SAMD51/21 note in writeColor()\n        hwspi._spi->setDataMode(hwspi._mode);\n      } else {\n        pinPeripheral(tft8._wr, PIO_OUTPUT); // Switch WR back to GPIO\n      }\n#endif // end __SAMD51__ || ARDUINO_SAMD_ZERO\n    }\n    return;\n  }\n#endif // end USE_SPI_DMA\n\n  // All other cases (bitbang SPI or non-DMA hard SPI or parallel),\n  // use a loop with the normal 16-bit data write function:\n\n  if (!bigEndian) {\n    while (len--) {\n      SPI_WRITE16(*colors++);\n    }\n  } else {\n    // Well this is awkward. SPI_WRITE16() was designed for little-endian\n    // hosts and big-endian displays as that's nearly always the typical\n    // case. If the bigEndian flag was set, data is already in display's\n    // order...so each pixel needs byte-swapping before being issued.\n    // Rather than having a separate big-endian SPI_WRITE16 (adding more\n    // bloat), it's preferred if calling function is smart and only uses\n    // bigEndian where DMA is supported. But we gotta handle this...\n    while (len--) {\n      SPI_WRITE16(__builtin_bswap16(*colors++));\n    }\n  }\n}\n\n/*!\n    @brief  Wait for the last DMA transfer in a prior non-blocking\n            writePixels() call to complete. This does nothing if DMA\n            is not enabled, and is not needed if blocking writePixels()\n            was used (as is the default case).\n*/\nvoid Adafruit_SPITFT::dmaWait(void) {\n#if defined(USE_SPI_DMA) && (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n  while (dma_busy)\n    ;\n#if defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO)\n  if (connection == TFT_HARD_SPI) {\n    // See SAMD51/21 note in writeColor()\n    hwspi._spi->setDataMode(hwspi._mode);\n  } else {\n    pinPeripheral(tft8._wr, PIO_OUTPUT); // Switch WR back to GPIO\n  }\n#endif // end __SAMD51__ || ARDUINO_SAMD_ZERO\n#endif\n}\n\n/*!\n    @brief  Check if DMA transfer is active. Always returts false if DMA\n            is not enabled.\n    @return true if DMA is enabled and transmitting data, false otherwise.\n*/\nbool Adafruit_SPITFT::dmaBusy(void) const {\n#if defined(USE_SPI_DMA) && (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n  return dma_busy;\n#else\n  return false;\n#endif\n}\n\n/*!\n    @brief  Issue a series of pixels, all the same color. Not self-\n            contained; should follow startWrite() and setAddrWindow() calls.\n    @param  color  16-bit pixel color in '565' RGB format.\n    @param  len    Number of pixels to draw.\n*/\nvoid Adafruit_SPITFT::writeColor(uint16_t color, uint32_t len) {\n\n  if (!len)\n    return; // Avoid 0-byte transfers\n\n  uint8_t hi = color >> 8, lo = color;\n\n#if defined(ESP32) // ESP32 has a special SPI pixel-writing function...\n  if (connection == TFT_HARD_SPI) {\n#define SPI_MAX_PIXELS_AT_ONCE 32\n#define TMPBUF_LONGWORDS (SPI_MAX_PIXELS_AT_ONCE + 1) / 2\n#define TMPBUF_PIXELS (TMPBUF_LONGWORDS * 2)\n    static uint32_t temp[TMPBUF_LONGWORDS];\n    uint32_t c32 = color * 0x00010001;\n    uint16_t bufLen = (len < TMPBUF_PIXELS) ? len : TMPBUF_PIXELS, xferLen,\n             fillLen;\n    // Fill temp buffer 32 bits at a time\n    fillLen = (bufLen + 1) / 2; // Round up to next 32-bit boundary\n    for (uint32_t t = 0; t < fillLen; t++) {\n      temp[t] = c32;\n    }\n    // Issue pixels in blocks from temp buffer\n    while (len) {                              // While pixels remain\n      xferLen = (bufLen < len) ? bufLen : len; // How many this pass?\n      writePixels((uint16_t *)temp, xferLen);\n      len -= xferLen;\n    }\n    return;\n  }\n#elif defined(ARDUINO_NRF52_ADAFRUIT) &&                                       \\\n    defined(NRF52840_XXAA) // Adafruit nRF52840 use SPIM3 DMA at 32Mhz\n  // at most 2 scan lines\n  uint32_t const pixbufcount = min(len, ((uint32_t)2 * width()));\n  uint16_t *pixbuf = (uint16_t *)rtos_malloc(2 * pixbufcount);\n\n  // use SPI3 DMA if we could allocate buffer, else fall back to writing each\n  // pixel loop below\n  if (pixbuf) {\n    uint16_t const swap_color = __builtin_bswap16(color);\n\n    // fill buffer with color\n    for (uint32_t i = 0; i < pixbufcount; i++) {\n      pixbuf[i] = swap_color;\n    }\n\n    while (len) {\n      uint32_t const count = min(len, pixbufcount);\n      writePixels(pixbuf, count, true, true);\n      len -= count;\n    }\n\n    rtos_free(pixbuf);\n    return;\n  }\n#elif defined(ARDUINO_ARCH_RTTHREAD)\n  uint16_t pixbufcount;\n  uint16_t *pixbuf;\n  int16_t lines = height() / 4;\n#define QUICKPATH_MAX_LEN 16\n  uint16_t quickpath_buffer[QUICKPATH_MAX_LEN];\n\n  do {\n    pixbufcount = min(len, (lines * width()));\n    if (pixbufcount > QUICKPATH_MAX_LEN) {\n      pixbuf = (uint16_t *)rt_malloc(2 * pixbufcount);\n    } else {\n      pixbuf = quickpath_buffer;\n    }\n    lines -= 2;\n  } while (!pixbuf && lines > 0);\n\n  if (pixbuf) {\n    uint16_t const swap_color = __builtin_bswap16(color);\n\n    while (len) {\n      uint16_t count = min(len, pixbufcount);\n      // fill buffer with color\n      for (uint16_t i = 0; i < count; i++) {\n        pixbuf[i] = swap_color;\n      }\n      // Don't need to swap color inside the function\n      // It has been done outside this function\n      writePixels(pixbuf, count, true, true);\n      len -= count;\n    }\n    if (pixbufcount > QUICKPATH_MAX_LEN) {\n      rt_free(pixbuf);\n    }\n#undef QUICKPATH_MAX_LEN\n    return;\n  }\n#else // !ESP32\n#if defined(USE_SPI_DMA) && (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n  if (((connection == TFT_HARD_SPI) || (connection == TFT_PARALLEL)) &&\n      (len >= 16)) { // Don't bother with DMA on short pixel runs\n    int i, d, numDescriptors;\n    if (hi == lo) { // If high & low bytes are same...\n      onePixelBuf = color;\n      // Can do this with a relatively short descriptor list,\n      // each transferring a max of 32,767 (not 32,768) pixels.\n      // This won't run off the end of the allocated descriptor list,\n      // since we're using much larger chunks per descriptor here.\n      numDescriptors = (len + 32766) / 32767;\n      for (d = 0; d < numDescriptors; d++) {\n        int count = (len < 32767) ? len : 32767;\n        descriptor[d].SRCADDR.reg = (uint32_t)&onePixelBuf;\n        descriptor[d].BTCTRL.bit.SRCINC = 0;\n        descriptor[d].BTCNT.reg = count * 2;\n        descriptor[d].DESCADDR.reg = (uint32_t)&descriptor[d + 1];\n        len -= count;\n      }\n      descriptor[d - 1].DESCADDR.reg = 0;\n    } else {\n      // If high and low bytes are distinct, it's necessary to fill\n      // a buffer with pixel data (swapping high and low bytes because\n      // TFT and SAMD are different endianisms) and create a longer\n      // descriptor list pointing repeatedly to this data. We can do\n      // this slightly faster working 2 pixels (32 bits) at a time.\n      uint32_t *pixelPtr = (uint32_t *)pixelBuf[0],\n               twoPixels = __builtin_bswap16(color) * 0x00010001;\n      // We can avoid some or all of the buffer-filling if the color\n      // is the same as last time...\n      if (color == lastFillColor) {\n        // If length is longer than prior instance, fill only the\n        // additional pixels in the buffer and update lastFillLen.\n        if (len > lastFillLen) {\n          int fillStart = lastFillLen / 2,\n              fillEnd = (((len < maxFillLen) ? len : maxFillLen) + 1) / 2;\n          for (i = fillStart; i < fillEnd; i++)\n            pixelPtr[i] = twoPixels;\n          lastFillLen = fillEnd * 2;\n        } // else do nothing, don't set pixels or change lastFillLen\n      } else {\n        int fillEnd = (((len < maxFillLen) ? len : maxFillLen) + 1) / 2;\n        for (i = 0; i < fillEnd; i++)\n          pixelPtr[i] = twoPixels;\n        lastFillLen = fillEnd * 2;\n        lastFillColor = color;\n      }\n\n      numDescriptors = (len + maxFillLen - 1) / maxFillLen;\n      for (d = 0; d < numDescriptors; d++) {\n        int pixels = (len < maxFillLen) ? len : maxFillLen, bytes = pixels * 2;\n        descriptor[d].SRCADDR.reg = (uint32_t)pixelPtr + bytes;\n        descriptor[d].BTCTRL.bit.SRCINC = 1;\n        descriptor[d].BTCNT.reg = bytes;\n        descriptor[d].DESCADDR.reg = (uint32_t)&descriptor[d + 1];\n        len -= pixels;\n      }\n      descriptor[d - 1].DESCADDR.reg = 0;\n    }\n    memcpy(dptr, &descriptor[0], sizeof(DmacDescriptor));\n#if defined(__SAMD51__)\n    if (connection == TFT_PARALLEL) {\n      // Switch WR pin to PWM or CCL\n      pinPeripheral(tft8._wr, wrPeripheral);\n    }\n#endif // end __SAMD51__\n\n    dma_busy = true;\n    dma.startJob();\n    if (connection == TFT_PARALLEL)\n      dma.trigger();\n    while (dma_busy)\n      ; // Wait for completion\n      // Unfortunately blocking is necessary. An earlier version returned\n      // immediately and checked dma_busy on startWrite() instead, but it\n      // turns out to be MUCH slower on many graphics operations (as when\n      // drawing lines, pixel-by-pixel), perhaps because it's a volatile\n      // type and doesn't cache. Working on this.\n#if defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO)\n    if (connection == TFT_HARD_SPI) {\n      // SAMD51: SPI DMA seems to leave the SPI peripheral in a freaky\n      // state on completion. Workaround is to explicitly set it back...\n      // (5/17/2019: apparently SAMD21 too, in certain cases, observed\n      // with ST7789 display.)\n      hwspi._spi->setDataMode(hwspi._mode);\n    } else {\n      pinPeripheral(tft8._wr, PIO_OUTPUT); // Switch WR back to GPIO\n    }\n#endif // end __SAMD51__\n    return;\n  }\n#endif // end USE_SPI_DMA\n#endif // end !ESP32\n\n  // All other cases (non-DMA hard SPI, bitbang SPI, parallel)...\n\n  if (connection == TFT_HARD_SPI) {\n#if defined(ESP8266)\n    do {\n      uint32_t pixelsThisPass = len;\n      if (pixelsThisPass > 50000)\n        pixelsThisPass = 50000;\n      len -= pixelsThisPass;\n      delay(1); // Periodic delay on long fills\n      while (pixelsThisPass--) {\n        hwspi._spi->write(hi);\n        hwspi._spi->write(lo);\n      }\n    } while (len);\n#elif defined(ARDUINO_ARCH_RP2040)\n    spi_inst_t *pi_spi = hwspi._spi == &SPI ? spi0 : spi1;\n    color = __builtin_bswap16(color);\n\n    while (len--)\n      spi_write_blocking(pi_spi, (uint8_t *)&color, 2);\n#else // !ESP8266 && !ARDUINO_ARCH_RP2040\n    while (len--) {\n#if defined(__AVR__)\n      AVR_WRITESPI(hi);\n      AVR_WRITESPI(lo);\n#elif defined(ESP32)\n      hwspi._spi->write(hi);\n      hwspi._spi->write(lo);\n#else\n      hwspi._spi->transfer(hi);\n      hwspi._spi->transfer(lo);\n#endif\n    }\n#endif // end !ESP8266\n  } else if (connection == TFT_SOFT_SPI) {\n#if defined(ESP8266)\n    do {\n      uint32_t pixelsThisPass = len;\n      if (pixelsThisPass > 20000)\n        pixelsThisPass = 20000;\n      len -= pixelsThisPass;\n      yield(); // Periodic yield() on long fills\n      while (pixelsThisPass--) {\n        for (uint16_t bit = 0, x = color; bit < 16; bit++) {\n          if (x & 0x8000)\n            SPI_MOSI_HIGH();\n          else\n            SPI_MOSI_LOW();\n          SPI_SCK_HIGH();\n          SPI_SCK_LOW();\n          x <<= 1;\n        }\n      }\n    } while (len);\n#else // !ESP8266\n    while (len--) {\n#if defined(__AVR__)\n      for (uint8_t bit = 0, x = hi; bit < 8; bit++) {\n        if (x & 0x80)\n          SPI_MOSI_HIGH();\n        else\n          SPI_MOSI_LOW();\n        SPI_SCK_HIGH();\n        SPI_SCK_LOW();\n        x <<= 1;\n      }\n      for (uint8_t bit = 0, x = lo; bit < 8; bit++) {\n        if (x & 0x80)\n          SPI_MOSI_HIGH();\n        else\n          SPI_MOSI_LOW();\n        SPI_SCK_HIGH();\n        SPI_SCK_LOW();\n        x <<= 1;\n      }\n#else      // !__AVR__\n      for (uint16_t bit = 0, x = color; bit < 16; bit++) {\n        if (x & 0x8000)\n          SPI_MOSI_HIGH();\n        else\n          SPI_MOSI_LOW();\n        SPI_SCK_HIGH();\n        x <<= 1;\n        SPI_SCK_LOW();\n      }\n#endif     // end !__AVR__\n    }\n#endif     // end !ESP8266\n  } else { // PARALLEL\n    if (hi == lo) {\n#if defined(__AVR__)\n      len *= 2;\n      *tft8.writePort = hi;\n      while (len--) {\n        TFT_WR_STROBE();\n      }\n#elif defined(USE_FAST_PINIO)\n      if (!tft8.wide) {\n        len *= 2;\n        *tft8.writePort = hi;\n      } else {\n        *(volatile uint16_t *)tft8.writePort = color;\n      }\n      while (len--) {\n        TFT_WR_STROBE();\n      }\n#endif\n    } else {\n      while (len--) {\n#if defined(__AVR__)\n        *tft8.writePort = hi;\n        TFT_WR_STROBE();\n        *tft8.writePort = lo;\n#elif defined(USE_FAST_PINIO)\n        if (!tft8.wide) {\n          *tft8.writePort = hi;\n          TFT_WR_STROBE();\n          *tft8.writePort = lo;\n        } else {\n          *(volatile uint16_t *)tft8.writePort = color;\n        }\n#endif\n        TFT_WR_STROBE();\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Draw a filled rectangle to the display. Not self-contained;\n            should follow startWrite(). Typically used by higher-level\n            graphics primitives; user code shouldn't need to call this and\n            is likely to use the self-contained fillRect() instead.\n            writeFillRect() performs its own edge clipping and rejection;\n            see writeFillRectPreclipped() for a more 'raw' implementation.\n    @param  x      Horizontal position of first corner.\n    @param  y      Vertical position of first corner.\n    @param  w      Rectangle width in pixels (positive = right of first\n                   corner, negative = left of first corner).\n    @param  h      Rectangle height in pixels (positive = below first\n                   corner, negative = above first corner).\n    @param  color  16-bit fill color in '565' RGB format.\n    @note   Written in this deep-nested way because C by definition will\n            optimize for the 'if' case, not the 'else' -- avoids branches\n            and rejects clipped rectangles at the least-work possibility.\n*/\nvoid Adafruit_SPITFT::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                                    uint16_t color) {\n  if (w && h) {   // Nonzero width and height?\n    if (w < 0) {  // If negative width...\n      x += w + 1; //   Move X to left edge\n      w = -w;     //   Use positive width\n    }\n    if (x < _width) { // Not off right\n      if (h < 0) {    // If negative height...\n        y += h + 1;   //   Move Y to top edge\n        h = -h;       //   Use positive height\n      }\n      if (y < _height) { // Not off bottom\n        int16_t x2 = x + w - 1;\n        if (x2 >= 0) { // Not off left\n          int16_t y2 = y + h - 1;\n          if (y2 >= 0) { // Not off top\n            // Rectangle partly or fully overlaps screen\n            if (x < 0) {\n              x = 0;\n              w = x2 + 1;\n            } // Clip left\n            if (y < 0) {\n              y = 0;\n              h = y2 + 1;\n            } // Clip top\n            if (x2 >= _width) {\n              w = _width - x;\n            } // Clip right\n            if (y2 >= _height) {\n              h = _height - y;\n            } // Clip bottom\n            writeFillRectPreclipped(x, y, w, h, color);\n          }\n        }\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Draw a horizontal line on the display. Performs edge clipping\n            and rejection. Not self-contained; should follow startWrite().\n            Typically used by higher-level graphics primitives; user code\n            shouldn't need to call this and is likely to use the self-\n            contained drawFastHLine() instead.\n    @param  x      Horizontal position of first point.\n    @param  y      Vertical position of first point.\n    @param  w      Line width in pixels (positive = right of first point,\n                   negative = point of first corner).\n    @param  color  16-bit line color in '565' RGB format.\n*/\nvoid inline Adafruit_SPITFT::writeFastHLine(int16_t x, int16_t y, int16_t w,\n                                            uint16_t color) {\n  if ((y >= 0) && (y < _height) && w) { // Y on screen, nonzero width\n    if (w < 0) {                        // If negative width...\n      x += w + 1;                       //   Move X to left edge\n      w = -w;                           //   Use positive width\n    }\n    if (x < _width) { // Not off right\n      int16_t x2 = x + w - 1;\n      if (x2 >= 0) { // Not off left\n        // Line partly or fully overlaps screen\n        if (x < 0) {\n          x = 0;\n          w = x2 + 1;\n        } // Clip left\n        if (x2 >= _width) {\n          w = _width - x;\n        } // Clip right\n        writeFillRectPreclipped(x, y, w, 1, color);\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Draw a vertical line on the display. Performs edge clipping and\n            rejection. Not self-contained; should follow startWrite().\n            Typically used by higher-level graphics primitives; user code\n            shouldn't need to call this and is likely to use the self-\n            contained drawFastVLine() instead.\n    @param  x      Horizontal position of first point.\n    @param  y      Vertical position of first point.\n    @param  h      Line height in pixels (positive = below first point,\n                   negative = above first point).\n    @param  color  16-bit line color in '565' RGB format.\n*/\nvoid inline Adafruit_SPITFT::writeFastVLine(int16_t x, int16_t y, int16_t h,\n                                            uint16_t color) {\n  if ((x >= 0) && (x < _width) && h) { // X on screen, nonzero height\n    if (h < 0) {                       // If negative height...\n      y += h + 1;                      //   Move Y to top edge\n      h = -h;                          //   Use positive height\n    }\n    if (y < _height) { // Not off bottom\n      int16_t y2 = y + h - 1;\n      if (y2 >= 0) { // Not off top\n        // Line partly or fully overlaps screen\n        if (y < 0) {\n          y = 0;\n          h = y2 + 1;\n        } // Clip top\n        if (y2 >= _height) {\n          h = _height - y;\n        } // Clip bottom\n        writeFillRectPreclipped(x, y, 1, h, color);\n      }\n    }\n  }\n}\n\n/*!\n    @brief  A lower-level version of writeFillRect(). This version requires\n            all inputs are in-bounds, that width and height are positive,\n            and no part extends offscreen. NO EDGE CLIPPING OR REJECTION IS\n            PERFORMED. If higher-level graphics primitives are written to\n            handle their own clipping earlier in the drawing process, this\n            can avoid unnecessary function calls and repeated clipping\n            operations in the lower-level functions.\n    @param  x      Horizontal position of first corner. MUST BE WITHIN\n                   SCREEN BOUNDS.\n    @param  y      Vertical position of first corner. MUST BE WITHIN SCREEN\n                   BOUNDS.\n    @param  w      Rectangle width in pixels. MUST BE POSITIVE AND NOT\n                   EXTEND OFF SCREEN.\n    @param  h      Rectangle height in pixels. MUST BE POSITIVE AND NOT\n                   EXTEND OFF SCREEN.\n    @param  color  16-bit fill color in '565' RGB format.\n    @note   This is a new function, no graphics primitives besides rects\n            and horizontal/vertical lines are written to best use this yet.\n*/\ninline void Adafruit_SPITFT::writeFillRectPreclipped(int16_t x, int16_t y,\n                                                     int16_t w, int16_t h,\n                                                     uint16_t color) {\n  setAddrWindow(x, y, w, h);\n  writeColor(color, (uint32_t)w * h);\n}\n\n// -------------------------------------------------------------------------\n// Ever-so-slightly higher-level graphics operations. Similar to the 'write'\n// functions above, but these contain their own chip-select and SPI\n// transactions as needed (via startWrite(), endWrite()). They're typically\n// used solo -- as graphics primitives in themselves, not invoked by higher-\n// level primitives (which should use the functions above for better\n// performance).\n\n/*!\n    @brief  Draw a single pixel to the display at requested coordinates.\n            Self-contained and provides its own transaction as needed\n            (see writePixel(x,y,color) for a lower-level variant).\n            Edge clipping is performed here.\n    @param  x      Horizontal position (0 = left).\n    @param  y      Vertical position   (0 = top).\n    @param  color  16-bit pixel color in '565' RGB format.\n*/\nvoid Adafruit_SPITFT::drawPixel(int16_t x, int16_t y, uint16_t color) {\n  // Clip first...\n  if ((x >= 0) && (x < _width) && (y >= 0) && (y < _height)) {\n    // THEN set up transaction (if needed) and draw...\n    startWrite();\n    setAddrWindow(x, y, 1, 1);\n    SPI_WRITE16(color);\n    endWrite();\n  }\n}\n\n/*!\n    @brief  Draw a filled rectangle to the display. Self-contained and\n            provides its own transaction as needed (see writeFillRect() or\n            writeFillRectPreclipped() for lower-level variants). Edge\n            clipping and rejection is performed here.\n    @param  x      Horizontal position of first corner.\n    @param  y      Vertical position of first corner.\n    @param  w      Rectangle width in pixels (positive = right of first\n                   corner, negative = left of first corner).\n    @param  h      Rectangle height in pixels (positive = below first\n                   corner, negative = above first corner).\n    @param  color  16-bit fill color in '565' RGB format.\n    @note   This repeats the writeFillRect() function almost in its entirety,\n            with the addition of a transaction start/end. It's done this way\n            (rather than starting the transaction and calling writeFillRect()\n            to handle clipping and so forth) so that the transaction isn't\n            performed at all if the rectangle is rejected. It's really not\n            that much code.\n*/\nvoid Adafruit_SPITFT::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                               uint16_t color) {\n  if (w && h) {   // Nonzero width and height?\n    if (w < 0) {  // If negative width...\n      x += w + 1; //   Move X to left edge\n      w = -w;     //   Use positive width\n    }\n    if (x < _width) { // Not off right\n      if (h < 0) {    // If negative height...\n        y += h + 1;   //   Move Y to top edge\n        h = -h;       //   Use positive height\n      }\n      if (y < _height) { // Not off bottom\n        int16_t x2 = x + w - 1;\n        if (x2 >= 0) { // Not off left\n          int16_t y2 = y + h - 1;\n          if (y2 >= 0) { // Not off top\n            // Rectangle partly or fully overlaps screen\n            if (x < 0) {\n              x = 0;\n              w = x2 + 1;\n            } // Clip left\n            if (y < 0) {\n              y = 0;\n              h = y2 + 1;\n            } // Clip top\n            if (x2 >= _width) {\n              w = _width - x;\n            } // Clip right\n            if (y2 >= _height) {\n              h = _height - y;\n            } // Clip bottom\n            startWrite();\n            writeFillRectPreclipped(x, y, w, h, color);\n            endWrite();\n          }\n        }\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Draw a horizontal line on the display. Self-contained and\n            provides its own transaction as needed (see writeFastHLine() for\n            a lower-level variant). Edge clipping and rejection is performed\n            here.\n    @param  x      Horizontal position of first point.\n    @param  y      Vertical position of first point.\n    @param  w      Line width in pixels (positive = right of first point,\n                   negative = point of first corner).\n    @param  color  16-bit line color in '565' RGB format.\n    @note   This repeats the writeFastHLine() function almost in its\n            entirety, with the addition of a transaction start/end. It's\n            done this way (rather than starting the transaction and calling\n            writeFastHLine() to handle clipping and so forth) so that the\n            transaction isn't performed at all if the line is rejected.\n*/\nvoid Adafruit_SPITFT::drawFastHLine(int16_t x, int16_t y, int16_t w,\n                                    uint16_t color) {\n  if ((y >= 0) && (y < _height) && w) { // Y on screen, nonzero width\n    if (w < 0) {                        // If negative width...\n      x += w + 1;                       //   Move X to left edge\n      w = -w;                           //   Use positive width\n    }\n    if (x < _width) { // Not off right\n      int16_t x2 = x + w - 1;\n      if (x2 >= 0) { // Not off left\n        // Line partly or fully overlaps screen\n        if (x < 0) {\n          x = 0;\n          w = x2 + 1;\n        } // Clip left\n        if (x2 >= _width) {\n          w = _width - x;\n        } // Clip right\n        startWrite();\n        writeFillRectPreclipped(x, y, w, 1, color);\n        endWrite();\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Draw a vertical line on the display. Self-contained and provides\n            its own transaction as needed (see writeFastHLine() for a lower-\n            level variant). Edge clipping and rejection is performed here.\n    @param  x      Horizontal position of first point.\n    @param  y      Vertical position of first point.\n    @param  h      Line height in pixels (positive = below first point,\n                   negative = above first point).\n    @param  color  16-bit line color in '565' RGB format.\n    @note   This repeats the writeFastVLine() function almost in its\n            entirety, with the addition of a transaction start/end. It's\n            done this way (rather than starting the transaction and calling\n            writeFastVLine() to handle clipping and so forth) so that the\n            transaction isn't performed at all if the line is rejected.\n*/\nvoid Adafruit_SPITFT::drawFastVLine(int16_t x, int16_t y, int16_t h,\n                                    uint16_t color) {\n  if ((x >= 0) && (x < _width) && h) { // X on screen, nonzero height\n    if (h < 0) {                       // If negative height...\n      y += h + 1;                      //   Move Y to top edge\n      h = -h;                          //   Use positive height\n    }\n    if (y < _height) { // Not off bottom\n      int16_t y2 = y + h - 1;\n      if (y2 >= 0) { // Not off top\n        // Line partly or fully overlaps screen\n        if (y < 0) {\n          y = 0;\n          h = y2 + 1;\n        } // Clip top\n        if (y2 >= _height) {\n          h = _height - y;\n        } // Clip bottom\n        startWrite();\n        writeFillRectPreclipped(x, y, 1, h, color);\n        endWrite();\n      }\n    }\n  }\n}\n\n/*!\n    @brief  Essentially writePixel() with a transaction around it. I don't\n            think this is in use by any of our code anymore (believe it was\n            for some older BMP-reading examples), but is kept here in case\n            any user code relies on it. Consider it DEPRECATED.\n    @param  color  16-bit pixel color in '565' RGB format.\n*/\nvoid Adafruit_SPITFT::pushColor(uint16_t color) {\n  startWrite();\n  SPI_WRITE16(color);\n  endWrite();\n}\n\n/*!\n    @brief  Draw a 16-bit image (565 RGB) at the specified (x,y) position.\n            For 16-bit display devices; no color reduction performed.\n            Adapted from https://github.com/PaulStoffregen/ILI9341_t3\n            by Marc MERLIN. See examples/pictureEmbed to use this.\n            5/6/2017: function name and arguments have changed for\n            compatibility with current GFX library and to avoid naming\n            problems in prior implementation.  Formerly drawBitmap() with\n            arguments in different order. Handles its own transaction and\n            edge clipping/rejection.\n    @param  x        Top left corner horizontal coordinate.\n    @param  y        Top left corner vertical coordinate.\n    @param  pcolors  Pointer to 16-bit array of pixel values.\n    @param  w        Width of bitmap in pixels.\n    @param  h        Height of bitmap in pixels.\n*/\nvoid Adafruit_SPITFT::drawRGBBitmap(int16_t x, int16_t y, uint16_t *pcolors,\n                                    int16_t w, int16_t h) {\n\n  int16_t x2, y2;                 // Lower-right coord\n  if ((x >= _width) ||            // Off-edge right\n      (y >= _height) ||           // \" top\n      ((x2 = (x + w - 1)) < 0) || // \" left\n      ((y2 = (y + h - 1)) < 0))\n    return; // \" bottom\n\n  int16_t bx1 = 0, by1 = 0, // Clipped top-left within bitmap\n      saveW = w;            // Save original bitmap width value\n  if (x < 0) {              // Clip left\n    w += x;\n    bx1 = -x;\n    x = 0;\n  }\n  if (y < 0) { // Clip top\n    h += y;\n    by1 = -y;\n    y = 0;\n  }\n  if (x2 >= _width)\n    w = _width - x; // Clip right\n  if (y2 >= _height)\n    h = _height - y; // Clip bottom\n\n  pcolors += by1 * saveW + bx1; // Offset bitmap ptr to clipped top-left\n  startWrite();\n  setAddrWindow(x, y, w, h); // Clipped area\n  while (h--) {              // For each (clipped) scanline...\n    writePixels(pcolors, w); // Push one (clipped) row\n    pcolors += saveW;        // Advance pointer by one full (unclipped) line\n  }\n  endWrite();\n}\n\n// -------------------------------------------------------------------------\n// Miscellaneous class member functions that don't draw anything.\n\n/*!\n    @brief  Invert the colors of the display (if supported by hardware).\n            Self-contained, no transaction setup required.\n    @param  i  true = inverted display, false = normal display.\n*/\nvoid Adafruit_SPITFT::invertDisplay(bool i) {\n  startWrite();\n  writeCommand(i ? invertOnCommand : invertOffCommand);\n  endWrite();\n}\n\n/*!\n    @brief   Given 8-bit red, green and blue values, return a 'packed'\n             16-bit color value in '565' RGB format (5 bits red, 6 bits\n             green, 5 bits blue). This is just a mathematical operation,\n             no hardware is touched.\n    @param   red    8-bit red brightnesss (0 = off, 255 = max).\n    @param   green  8-bit green brightnesss (0 = off, 255 = max).\n    @param   blue   8-bit blue brightnesss (0 = off, 255 = max).\n    @return  'Packed' 16-bit color value (565 format).\n*/\nuint16_t Adafruit_SPITFT::color565(uint8_t red, uint8_t green, uint8_t blue) {\n  return ((red & 0xF8) << 8) | ((green & 0xFC) << 3) | (blue >> 3);\n}\n\n/*!\n@brief   Adafruit_SPITFT Send Command handles complete sending of commands and\ndata\n@param   commandByte       The Command Byte\n@param   dataBytes         A pointer to the Data bytes to send\n@param   numDataBytes      The number of bytes we should send\n*/\nvoid Adafruit_SPITFT::sendCommand(uint8_t commandByte, uint8_t *dataBytes,\n                                  uint8_t numDataBytes) {\n  SPI_BEGIN_TRANSACTION();\n  if (_cs >= 0)\n    SPI_CS_LOW();\n\n  SPI_DC_LOW();          // Command mode\n  spiWrite(commandByte); // Send the command byte\n\n  SPI_DC_HIGH();\n  for (int i = 0; i < numDataBytes; i++) {\n    if ((connection == TFT_PARALLEL) && tft8.wide) {\n      SPI_WRITE16(*(uint16_t *)dataBytes);\n      dataBytes += 2;\n    } else {\n      spiWrite(*dataBytes); // Send the data bytes\n      dataBytes++;\n    }\n  }\n\n  if (_cs >= 0)\n    SPI_CS_HIGH();\n  SPI_END_TRANSACTION();\n}\n\n/*!\n @brief   Adafruit_SPITFT Send Command handles complete sending of commands and\n data\n @param   commandByte       The Command Byte\n @param   dataBytes         A pointer to the Data bytes to send\n @param   numDataBytes      The number of bytes we should send\n */\nvoid Adafruit_SPITFT::sendCommand(uint8_t commandByte, const uint8_t *dataBytes,\n                                  uint8_t numDataBytes) {\n  SPI_BEGIN_TRANSACTION();\n  if (_cs >= 0)\n    SPI_CS_LOW();\n\n  SPI_DC_LOW();          // Command mode\n  spiWrite(commandByte); // Send the command byte\n\n  SPI_DC_HIGH();\n  for (int i = 0; i < numDataBytes; i++) {\n    if ((connection == TFT_PARALLEL) && tft8.wide) {\n      SPI_WRITE16(*(uint16_t *)dataBytes);\n      dataBytes += 2;\n    } else {\n      spiWrite(pgm_read_byte(dataBytes++));\n    }\n  }\n\n  if (_cs >= 0)\n    SPI_CS_HIGH();\n  SPI_END_TRANSACTION();\n}\n\n/*!\n @brief  Adafruit_SPITFT sendCommand16 handles complete sending of\n         commands and data for 16-bit parallel displays. Currently somewhat\n         rigged for the NT35510, which has the odd behavior of wanting\n         commands 16-bit, but subsequent data as 8-bit values, despite\n         the 16-bit bus (high byte is always 0). Also seems to require\n         issuing and incrementing address with each transfer.\n @param  commandWord   The command word (16 bits)\n @param  dataBytes     A pointer to the data bytes to send\n @param  numDataBytes  The number of bytes we should send\n */\nvoid Adafruit_SPITFT::sendCommand16(uint16_t commandWord,\n                                    const uint8_t *dataBytes,\n                                    uint8_t numDataBytes) {\n  SPI_BEGIN_TRANSACTION();\n  if (_cs >= 0)\n    SPI_CS_LOW();\n\n  if (numDataBytes == 0) {\n    SPI_DC_LOW();             // Command mode\n    SPI_WRITE16(commandWord); // Send the command word\n    SPI_DC_HIGH();            // Data mode\n  }\n  for (int i = 0; i < numDataBytes; i++) {\n    SPI_DC_LOW();             // Command mode\n    SPI_WRITE16(commandWord); // Send the command word\n    SPI_DC_HIGH();            // Data mode\n    commandWord++;\n    SPI_WRITE16((uint16_t)pgm_read_byte(dataBytes++));\n  }\n\n  if (_cs >= 0)\n    SPI_CS_HIGH();\n  SPI_END_TRANSACTION();\n}\n\n/*!\n @brief   Read 8 bits of data from display configuration memory (not RAM).\n This is highly undocumented/supported and should be avoided,\n function is only included because some of the examples use it.\n @param   commandByte\n The command register to read data from.\n @param   index\n The byte index into the command to read from.\n @return  Unsigned 8-bit data read from display register.\n */\n/**************************************************************************/\nuint8_t Adafruit_SPITFT::readcommand8(uint8_t commandByte, uint8_t index) {\n  uint8_t result;\n  startWrite();\n  SPI_DC_LOW(); // Command mode\n  spiWrite(commandByte);\n  SPI_DC_HIGH(); // Data mode\n  do {\n    result = spiRead();\n  } while (index--); // Discard bytes up to index'th\n  endWrite();\n  return result;\n}\n\n/*!\n @brief   Read 16 bits of data from display register.\n          For 16-bit parallel displays only.\n @param   addr  Command/register to access.\n @return  Unsigned 16-bit data.\n */\nuint16_t Adafruit_SPITFT::readcommand16(uint16_t addr) {\n#if defined(USE_FAST_PINIO) // NOT SUPPORTED without USE_FAST_PINIO\n  uint16_t result = 0;\n  if ((connection == TFT_PARALLEL) && tft8.wide) {\n    startWrite();\n    SPI_DC_LOW(); // Command mode\n    SPI_WRITE16(addr);\n    SPI_DC_HIGH(); // Data mode\n    TFT_RD_LOW();  // Read line LOW\n#if defined(HAS_PORT_SET_CLR)\n    *(volatile uint16_t *)tft8.dirClr = 0xFFFF;   // Input state\n    result = *(volatile uint16_t *)tft8.readPort; // 16-bit read\n    *(volatile uint16_t *)tft8.dirSet = 0xFFFF;   // Output state\n#else                                             // !HAS_PORT_SET_CLR\n    *(volatile uint16_t *)tft8.portDir = 0x0000;    // Input state\n    result = *(volatile uint16_t *)tft8.readPort;   // 16-bit read\n    *(volatile uint16_t *)tft8.portDir = 0xFFFF;    // Output state\n#endif                                            // end !HAS_PORT_SET_CLR\n    TFT_RD_HIGH();                                // Read line HIGH\n    endWrite();\n  }\n  return result;\n#else\n  (void)addr; // disable -Wunused-parameter warning\n  return 0;\n#endif // end !USE_FAST_PINIO\n}\n\n// -------------------------------------------------------------------------\n// Lowest-level hardware-interfacing functions. Many of these are inline and\n// compile to different things based on #defines -- typically just a few\n// instructions. Others, not so much, those are not inlined.\n\n/*!\n    @brief  Start an SPI transaction if using the hardware SPI interface to\n            the display. If using an earlier version of the Arduino platform\n            (before the addition of SPI transactions), this instead attempts\n            to set up the SPI clock and mode. No action is taken if the\n            connection is not hardware SPI-based. This does NOT include a\n            chip-select operation -- see startWrite() for a function that\n            encapsulated both actions.\n*/\ninline void Adafruit_SPITFT::SPI_BEGIN_TRANSACTION(void) {\n  if (connection == TFT_HARD_SPI) {\n#if defined(SPI_HAS_TRANSACTION)\n    hwspi._spi->beginTransaction(hwspi.settings);\n#else // No transactions, configure SPI manually...\n#if defined(__AVR__) || defined(TEENSYDUINO) || defined(ARDUINO_ARCH_STM32F1)\n    hwspi._spi->setClockDivider(SPI_CLOCK_DIV2);\n#elif defined(__arm__)\n    hwspi._spi->setClockDivider(11);\n#elif defined(ESP8266) || defined(ESP32)\n    hwspi._spi->setFrequency(hwspi._freq);\n#elif defined(RASPI) || defined(ARDUINO_ARCH_STM32F1)\n    hwspi._spi->setClock(hwspi._freq);\n#endif\n    hwspi._spi->setBitOrder(MSBFIRST);\n    hwspi._spi->setDataMode(hwspi._mode);\n#endif // end !SPI_HAS_TRANSACTION\n  }\n}\n\n/*!\n    @brief  End an SPI transaction if using the hardware SPI interface to\n            the display. No action is taken if the connection is not\n            hardware SPI-based or if using an earlier version of the Arduino\n            platform (before the addition of SPI transactions). This does\n            NOT include a chip-deselect operation -- see endWrite() for a\n            function that encapsulated both actions.\n*/\ninline void Adafruit_SPITFT::SPI_END_TRANSACTION(void) {\n#if defined(SPI_HAS_TRANSACTION)\n  if (connection == TFT_HARD_SPI) {\n    hwspi._spi->endTransaction();\n  }\n#endif\n}\n\n/*!\n    @brief  Issue a single 8-bit value to the display. Chip-select,\n            transaction and data/command selection must have been\n            previously set -- this ONLY issues the byte. This is another of\n            those functions in the library with a now-not-accurate name\n            that's being maintained for compatibility with outside code.\n            This function is used even if display connection is parallel.\n    @param  b  8-bit value to write.\n*/\nvoid Adafruit_SPITFT::spiWrite(uint8_t b) {\n  if (connection == TFT_HARD_SPI) {\n#if defined(__AVR__)\n    AVR_WRITESPI(b);\n#elif defined(ESP8266) || defined(ESP32)\n    hwspi._spi->write(b);\n#elif defined(ARDUINO_ARCH_RP2040)\n    spi_inst_t *pi_spi = hwspi._spi == &SPI ? spi0 : spi1;\n    spi_write_blocking(pi_spi, &b, 1);\n#else\n    hwspi._spi->transfer(b);\n#endif\n  } else if (connection == TFT_SOFT_SPI) {\n    for (uint8_t bit = 0; bit < 8; bit++) {\n      if (b & 0x80)\n        SPI_MOSI_HIGH();\n      else\n        SPI_MOSI_LOW();\n      SPI_SCK_HIGH();\n      b <<= 1;\n      SPI_SCK_LOW();\n    }\n  } else { // TFT_PARALLEL\n#if defined(__AVR__)\n    *tft8.writePort = b;\n#elif defined(USE_FAST_PINIO)\n    if (!tft8.wide)\n      *tft8.writePort = b;\n    else\n      *(volatile uint16_t *)tft8.writePort = b;\n#endif\n    TFT_WR_STROBE();\n  }\n}\n\n/*!\n    @brief  Write a single command byte to the display. Chip-select and\n            transaction must have been previously set -- this ONLY sets\n            the device to COMMAND mode, issues the byte and then restores\n            DATA mode. There is no corresponding explicit writeData()\n            function -- just use spiWrite().\n    @param  cmd  8-bit command to write.\n*/\nvoid Adafruit_SPITFT::writeCommand(uint8_t cmd) {\n  SPI_DC_LOW();\n  spiWrite(cmd);\n  SPI_DC_HIGH();\n}\n\n/*!\n    @brief   Read a single 8-bit value from the display. Chip-select and\n             transaction must have been previously set -- this ONLY reads\n             the byte. This is another of those functions in the library\n             with a now-not-accurate name that's being maintained for\n             compatibility with outside code. This function is used even if\n             display connection is parallel.\n    @return  Unsigned 8-bit value read (always zero if USE_FAST_PINIO is\n             not supported by the MCU architecture).\n*/\nuint8_t Adafruit_SPITFT::spiRead(void) {\n  uint8_t b = 0;\n  uint16_t w = 0;\n  if (connection == TFT_HARD_SPI) {\n    return hwspi._spi->transfer((uint8_t)0);\n  } else if (connection == TFT_SOFT_SPI) {\n    if (swspi._miso >= 0) {\n      for (uint8_t i = 0; i < 8; i++) {\n        SPI_SCK_HIGH();\n        b <<= 1;\n        if (SPI_MISO_READ())\n          b++;\n        SPI_SCK_LOW();\n      }\n    }\n    return b;\n  } else { // TFT_PARALLEL\n    if (tft8._rd >= 0) {\n#if defined(USE_FAST_PINIO)\n      TFT_RD_LOW(); // Read line LOW\n#if defined(__AVR__)\n      *tft8.portDir = 0x00; // Set port to input state\n      w = *tft8.readPort;   // Read value from port\n      *tft8.portDir = 0xFF; // Restore port to output\n#else                       // !__AVR__\n      if (!tft8.wide) {                             // 8-bit TFT connection\n#if defined(HAS_PORT_SET_CLR)\n        *tft8.dirClr = 0xFF;                        // Set port to input state\n        w = *tft8.readPort;                         // Read value from port\n        *tft8.dirSet = 0xFF;                        // Restore port to output\n#else  // !HAS_PORT_SET_CLR\n        *tft8.portDir = 0x00;                        // Set port to input state\n        w = *tft8.readPort;                          // Read value from port\n        *tft8.portDir = 0xFF;                        // Restore port to output\n#endif // end HAS_PORT_SET_CLR\n      } else {                                      // 16-bit TFT connection\n#if defined(HAS_PORT_SET_CLR)\n        *(volatile uint16_t *)tft8.dirClr = 0xFFFF; // Input state\n        w = *(volatile uint16_t *)tft8.readPort;    // 16-bit read\n        *(volatile uint16_t *)tft8.dirSet = 0xFFFF; // Output state\n#else  // !HAS_PORT_SET_CLR\n        *(volatile uint16_t *)tft8.portDir = 0x0000; // Input state\n        w = *(volatile uint16_t *)tft8.readPort;     // 16-bit read\n        *(volatile uint16_t *)tft8.portDir = 0xFFFF; // Output state\n#endif // end !HAS_PORT_SET_CLR\n      }\n      TFT_RD_HIGH();                                 // Read line HIGH\n#endif // end !__AVR__\n#else  // !USE_FAST_PINIO\n      w = 0; // Parallel TFT is NOT SUPPORTED without USE_FAST_PINIO\n#endif // end !USE_FAST_PINIO\n    }\n    return w;\n  }\n}\n\n/*!\n    @brief  Issue a single 16-bit value to the display. Chip-select,\n            transaction and data/command selection must have been\n            previously set -- this ONLY issues the word.\n            Thus operates ONLY on 'wide' (16-bit) parallel displays!\n    @param  w  16-bit value to write.\n*/\nvoid Adafruit_SPITFT::write16(uint16_t w) {\n  if (connection == TFT_PARALLEL) {\n#if defined(USE_FAST_PINIO)\n    if (tft8.wide)\n      *(volatile uint16_t *)tft8.writePort = w;\n#else\n    (void)w; // disable -Wunused-parameter warning\n#endif\n    TFT_WR_STROBE();\n  }\n}\n\n/*!\n    @brief  Write a single command word to the display. Chip-select and\n            transaction must have been previously set -- this ONLY sets\n            the device to COMMAND mode, issues the byte and then restores\n            DATA mode. This operates ONLY on 'wide' (16-bit) parallel\n            displays!\n    @param  cmd  16-bit command to write.\n*/\nvoid Adafruit_SPITFT::writeCommand16(uint16_t cmd) {\n  SPI_DC_LOW();\n  write16(cmd);\n  SPI_DC_HIGH();\n}\n\n/*!\n    @brief   Read a single 16-bit value from the display. Chip-select and\n             transaction must have been previously set -- this ONLY reads\n             the byte. This operates ONLY on 'wide' (16-bit) parallel\n             displays!\n    @return  Unsigned 16-bit value read (always zero if USE_FAST_PINIO is\n             not supported by the MCU architecture).\n*/\nuint16_t Adafruit_SPITFT::read16(void) {\n  uint16_t w = 0;\n  if (connection == TFT_PARALLEL) {\n    if (tft8._rd >= 0) {\n#if defined(USE_FAST_PINIO)\n      TFT_RD_LOW();    // Read line LOW\n      if (tft8.wide) { // 16-bit TFT connection\n#if defined(HAS_PORT_SET_CLR)\n        *(volatile uint16_t *)tft8.dirClr = 0xFFFF; // Input state\n        w = *(volatile uint16_t *)tft8.readPort;    // 16-bit read\n        *(volatile uint16_t *)tft8.dirSet = 0xFFFF; // Output state\n#else                                               // !HAS_PORT_SET_CLR\n        *(volatile uint16_t *)tft8.portDir = 0x0000; // Input state\n        w = *(volatile uint16_t *)tft8.readPort;     // 16-bit read\n        *(volatile uint16_t *)tft8.portDir = 0xFFFF; // Output state\n#endif                                              // end !HAS_PORT_SET_CLR\n      }\n      TFT_RD_HIGH(); // Read line HIGH\n#else                // !USE_FAST_PINIO\n      w = 0; // Parallel TFT is NOT SUPPORTED without USE_FAST_PINIO\n#endif               // end !USE_FAST_PINIO\n    }\n  }\n  return w;\n}\n\n/*!\n    @brief  Set the software (bitbang) SPI MOSI line HIGH.\n*/\ninline void Adafruit_SPITFT::SPI_MOSI_HIGH(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n  *swspi.mosiPortSet = 1;\n#else // !KINETISK\n  *swspi.mosiPortSet = swspi.mosiPinMask;\n#endif\n#else  // !HAS_PORT_SET_CLR\n  *swspi.mosiPort |= swspi.mosiPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(swspi._mosi, HIGH);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief  Set the software (bitbang) SPI MOSI line LOW.\n*/\ninline void Adafruit_SPITFT::SPI_MOSI_LOW(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n  *swspi.mosiPortClr = 1;\n#else // !KINETISK\n  *swspi.mosiPortClr = swspi.mosiPinMask;\n#endif\n#else  // !HAS_PORT_SET_CLR\n  *swspi.mosiPort &= swspi.mosiPinMaskClr;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(swspi._mosi, LOW);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief  Set the software (bitbang) SPI SCK line HIGH.\n*/\ninline void Adafruit_SPITFT::SPI_SCK_HIGH(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n  *swspi.sckPortSet = 1;\n#else // !KINETISK\n  *swspi.sckPortSet = swspi.sckPinMask;\n#endif\n#else  // !HAS_PORT_SET_CLR\n  *swspi.sckPort |= swspi.sckPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(swspi._sck, HIGH);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief  Set the software (bitbang) SPI SCK line LOW.\n*/\ninline void Adafruit_SPITFT::SPI_SCK_LOW(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n  *swspi.sckPortClr = 1;\n#else // !KINETISK\n  *swspi.sckPortClr = swspi.sckPinMask;\n#endif\n#else  // !HAS_PORT_SET_CLR\n  *swspi.sckPort &= swspi.sckPinMaskClr;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(swspi._sck, LOW);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief   Read the state of the software (bitbang) SPI MISO line.\n    @return  true if HIGH, false if LOW.\n*/\ninline bool Adafruit_SPITFT::SPI_MISO_READ(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(KINETISK)\n  return *swspi.misoPort;\n#else  // !KINETISK\n  return *swspi.misoPort & swspi.misoPinMask;\n#endif // end !KINETISK\n#else  // !USE_FAST_PINIO\n  return digitalRead(swspi._miso);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief  Issue a single 16-bit value to the display. Chip-select,\n            transaction and data/command selection must have been\n            previously set -- this ONLY issues the word. Despite the name,\n            this function is used even if display connection is parallel;\n            name was maintaned for backward compatibility. Naming is also\n            not consistent with the 8-bit version, spiWrite(). Sorry about\n            that. Again, staying compatible with outside code.\n    @param  w  16-bit value to write.\n*/\nvoid Adafruit_SPITFT::SPI_WRITE16(uint16_t w) {\n  if (connection == TFT_HARD_SPI) {\n#if defined(__AVR__)\n    AVR_WRITESPI(w >> 8);\n    AVR_WRITESPI(w);\n#elif defined(ESP8266) || defined(ESP32)\n    hwspi._spi->write16(w);\n#elif defined(ARDUINO_ARCH_RP2040)\n    spi_inst_t *pi_spi = hwspi._spi == &SPI ? spi0 : spi1;\n    w = __builtin_bswap16(w);\n    spi_write_blocking(pi_spi, (uint8_t *)&w, 2);\n#elif defined(ARDUINO_ARCH_RTTHREAD)\n    hwspi._spi->transfer16(w);\n#else\n    // MSB, LSB because TFTs are generally big-endian\n    hwspi._spi->transfer(w >> 8);\n    hwspi._spi->transfer(w);\n#endif\n  } else if (connection == TFT_SOFT_SPI) {\n    for (uint8_t bit = 0; bit < 16; bit++) {\n      if (w & 0x8000)\n        SPI_MOSI_HIGH();\n      else\n        SPI_MOSI_LOW();\n      SPI_SCK_HIGH();\n      SPI_SCK_LOW();\n      w <<= 1;\n    }\n  } else { // TFT_PARALLEL\n#if defined(__AVR__)\n    *tft8.writePort = w >> 8;\n    TFT_WR_STROBE();\n    *tft8.writePort = w;\n#elif defined(USE_FAST_PINIO)\n    if (!tft8.wide) {\n      *tft8.writePort = w >> 8;\n      TFT_WR_STROBE();\n      *tft8.writePort = w;\n    } else {\n      *(volatile uint16_t *)tft8.writePort = w;\n    }\n#endif\n    TFT_WR_STROBE();\n  }\n}\n\n/*!\n    @brief  Issue a single 32-bit value to the display. Chip-select,\n            transaction and data/command selection must have been\n            previously set -- this ONLY issues the longword. Despite the\n            name, this function is used even if display connection is\n            parallel; name was maintaned for backward compatibility. Naming\n            is also not consistent with the 8-bit version, spiWrite().\n            Sorry about that. Again, staying compatible with outside code.\n    @param  l  32-bit value to write.\n*/\nvoid Adafruit_SPITFT::SPI_WRITE32(uint32_t l) {\n  if (connection == TFT_HARD_SPI) {\n#if defined(__AVR__)\n    AVR_WRITESPI(l >> 24);\n    AVR_WRITESPI(l >> 16);\n    AVR_WRITESPI(l >> 8);\n    AVR_WRITESPI(l);\n#elif defined(ESP8266) || defined(ESP32)\n    hwspi._spi->write32(l);\n#elif defined(ARDUINO_ARCH_RP2040)\n    spi_inst_t *pi_spi = hwspi._spi == &SPI ? spi0 : spi1;\n    l = __builtin_bswap32(l);\n    spi_write_blocking(pi_spi, (uint8_t *)&l, 4);\n#elif defined(ARDUINO_ARCH_RTTHREAD)\n    hwspi._spi->transfer16(l >> 16);\n    hwspi._spi->transfer16(l);\n#else\n    hwspi._spi->transfer(l >> 24);\n    hwspi._spi->transfer(l >> 16);\n    hwspi._spi->transfer(l >> 8);\n    hwspi._spi->transfer(l);\n#endif\n  } else if (connection == TFT_SOFT_SPI) {\n    for (uint8_t bit = 0; bit < 32; bit++) {\n      if (l & 0x80000000)\n        SPI_MOSI_HIGH();\n      else\n        SPI_MOSI_LOW();\n      SPI_SCK_HIGH();\n      SPI_SCK_LOW();\n      l <<= 1;\n    }\n  } else { // TFT_PARALLEL\n#if defined(__AVR__)\n    *tft8.writePort = l >> 24;\n    TFT_WR_STROBE();\n    *tft8.writePort = l >> 16;\n    TFT_WR_STROBE();\n    *tft8.writePort = l >> 8;\n    TFT_WR_STROBE();\n    *tft8.writePort = l;\n#elif defined(USE_FAST_PINIO)\n    if (!tft8.wide) {\n      *tft8.writePort = l >> 24;\n      TFT_WR_STROBE();\n      *tft8.writePort = l >> 16;\n      TFT_WR_STROBE();\n      *tft8.writePort = l >> 8;\n      TFT_WR_STROBE();\n      *tft8.writePort = l;\n    } else {\n      *(volatile uint16_t *)tft8.writePort = l >> 16;\n      TFT_WR_STROBE();\n      *(volatile uint16_t *)tft8.writePort = l;\n    }\n#endif\n    TFT_WR_STROBE();\n  }\n}\n\n/*!\n    @brief  Set the WR line LOW, then HIGH. Used for parallel-connected\n            interfaces when writing data.\n*/\ninline void Adafruit_SPITFT::TFT_WR_STROBE(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n  *tft8.wrPortClr = 1;\n  *tft8.wrPortSet = 1;\n#else  // !KINETISK\n  *tft8.wrPortClr = tft8.wrPinMask;\n  *tft8.wrPortSet = tft8.wrPinMask;\n#endif // end !KINETISK\n#else  // !HAS_PORT_SET_CLR\n  *tft8.wrPort &= tft8.wrPinMaskClr;\n  *tft8.wrPort |= tft8.wrPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(tft8._wr, LOW);\n  digitalWrite(tft8._wr, HIGH);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief  Set the RD line HIGH. Used for parallel-connected interfaces\n            when reading data.\n*/\ninline void Adafruit_SPITFT::TFT_RD_HIGH(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n  *tft8.rdPortSet = tft8.rdPinMask;\n#else  // !HAS_PORT_SET_CLR\n  *tft8.rdPort |= tft8.rdPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(tft8._rd, HIGH);\n#endif // end !USE_FAST_PINIO\n}\n\n/*!\n    @brief  Set the RD line LOW. Used for parallel-connected interfaces\n            when reading data.\n*/\ninline void Adafruit_SPITFT::TFT_RD_LOW(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n  *tft8.rdPortClr = tft8.rdPinMask;\n#else  // !HAS_PORT_SET_CLR\n  *tft8.rdPort &= tft8.rdPinMaskClr;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n  digitalWrite(tft8._rd, LOW);\n#endif // end !USE_FAST_PINIO\n}\n\n#endif // end __AVR_ATtiny85__ __AVR_ATtiny84__\n"
        },
        {
          "name": "Adafruit_SPITFT.h",
          "type": "blob",
          "size": 24.333984375,
          "content": "/*!\n * @file Adafruit_SPITFT.h\n *\n * Part of Adafruit's GFX graphics library. Originally this class was\n * written to handle a range of color TFT displays connected via SPI,\n * but over time this library and some display-specific subclasses have\n * mutated to include some color OLEDs as well as parallel-interfaced\n * displays. The name's been kept for the sake of older code.\n *\n * Adafruit invests time and resources providing this open source code,\n * please support Adafruit and open-source hardware by purchasing\n * products from Adafruit!\n *\n * Written by Limor \"ladyada\" Fried for Adafruit Industries,\n * with contributions from the open source community.\n *\n * BSD license, all text here must be included in any redistribution.\n */\n\n#ifndef _ADAFRUIT_SPITFT_H_\n#define _ADAFRUIT_SPITFT_H_\n\n// Not for ATtiny, at all\n#if !defined(__AVR_ATtiny85__) && !defined(__AVR_ATtiny84__)\n\n#include \"Adafruit_GFX.h\"\n#include <SPI.h>\n\n// HARDWARE CONFIG ---------------------------------------------------------\n\n#if defined(__AVR__)\ntypedef uint8_t ADAGFX_PORT_t;       ///< PORT values are 8-bit\n#define USE_FAST_PINIO               ///< Use direct PORT register access\n#elif defined(ARDUINO_STM32_FEATHER) // WICED\ntypedef class HardwareSPI SPIClass;        ///< SPI is a bit odd on WICED\ntypedef uint32_t ADAGFX_PORT_t;            ///< PORT values are 32-bit\n#elif defined(__arm__)\n#if defined(ARDUINO_ARCH_SAMD)\n// Adafruit M0, M4\ntypedef uint32_t ADAGFX_PORT_t; ///< PORT values are 32-bit\n#define USE_FAST_PINIO   ///< Use direct PORT register access\n#define HAS_PORT_SET_CLR ///< PORTs have set & clear registers\n#elif defined(CORE_TEENSY)\n// PJRC Teensy 4.x\n#if defined(__IMXRT1052__) || defined(__IMXRT1062__) // Teensy 4.x\ntypedef uint32_t ADAGFX_PORT_t; ///< PORT values are 32-bit\n                                // PJRC Teensy 3.x\n#else\ntypedef uint8_t ADAGFX_PORT_t; ///< PORT values are 8-bit\n#endif\n#define USE_FAST_PINIO   ///< Use direct PORT register access\n#define HAS_PORT_SET_CLR ///< PORTs have set & clear registers\n#else\n// Arduino Due?\ntypedef uint32_t ADAGFX_PORT_t; ///< PORT values are 32-bit\n// USE_FAST_PINIO not available here (yet)...Due has a totally different\n// GPIO register set and will require some changes elsewhere (e.g. in\n// constructors especially).\n#endif\n#else                                      // !ARM\n// Probably ESP8266 or ESP32. USE_FAST_PINIO is not available here (yet)\n// but don't worry about it too much...the digitalWrite() implementation\n// on these platforms is reasonably efficient and already RAM-resident,\n// only gotcha then is no parallel connection support for now.\ntypedef uint32_t ADAGFX_PORT_t; ///< PORT values are 32-bit\n#endif                                     // end !ARM\ntypedef volatile ADAGFX_PORT_t *PORTreg_t; ///< PORT register type\n\n#if defined(__AVR__)\n#define DEFAULT_SPI_FREQ 8000000L ///< Hardware SPI default speed\n#else\n#define DEFAULT_SPI_FREQ 16000000L ///< Hardware SPI default speed\n#endif\n\n#if defined(ADAFRUIT_PYPORTAL) || defined(ADAFRUIT_PYPORTAL_M4_TITANO) ||      \\\n    defined(ADAFRUIT_PYBADGE_M4_EXPRESS) ||                                    \\\n    defined(ADAFRUIT_PYGAMER_M4_EXPRESS) ||                                    \\\n    defined(ADAFRUIT_MONSTER_M4SK_EXPRESS) || defined(NRF52_SERIES) ||         \\\n    defined(ADAFRUIT_CIRCUITPLAYGROUND_M0)\n#define USE_SPI_DMA ///< Auto DMA\n#else\n                                           //#define USE_SPI_DMA ///< If set,\n                                           // use DMA if available\n#endif\n// Another \"oops\" name -- this now also handles parallel DMA.\n// If DMA is enabled, Arduino sketch MUST #include <Adafruit_ZeroDMA.h>\n// Estimated RAM usage:\n// 4 bytes/pixel on display major axis + 8 bytes/pixel on minor axis,\n// e.g. 320x240 pixels = 320 * 4 + 240 * 8 = 3,200 bytes.\n\n#if defined(USE_SPI_DMA) && (defined(__SAMD51__) || defined(ARDUINO_SAMD_ZERO))\n#include <Adafruit_ZeroDMA.h>\n#endif\n\n// This is kind of a kludge. Needed a way to disambiguate the software SPI\n// and parallel constructors via their argument lists. Originally tried a\n// bool as the first argument to the parallel constructor (specifying 8-bit\n// vs 16-bit interface) but the compiler regards this as equivalent to an\n// integer and thus still ambiguous. SO...the parallel constructor requires\n// an enumerated type as the first argument: tft8 (for 8-bit parallel) or\n// tft16 (for 16-bit)...even though 16-bit isn't fully implemented or tested\n// and might never be, still needed that disambiguation from soft SPI.\n/*! For first arg to parallel constructor */\nenum tftBusWidth { tft8bitbus, tft16bitbus };\n\n// CLASS DEFINITION --------------------------------------------------------\n\n/*!\n  @brief  Adafruit_SPITFT is an intermediary class between Adafruit_GFX\n          and various hardware-specific subclasses for different displays.\n          It handles certain operations that are common to a range of\n          displays (address window, area fills, etc.). Originally these were\n          all color TFT displays interfaced via SPI, but it's since expanded\n          to include color OLEDs and parallel-interfaced TFTs. THE NAME HAS\n          BEEN KEPT TO AVOID BREAKING A LOT OF SUBCLASSES AND EXAMPLE CODE.\n          Many of the class member functions similarly live on with names\n          that don't necessarily accurately describe what they're doing,\n          again to avoid breaking a lot of other code. If in doubt, read\n          the comments.\n*/\nclass Adafruit_SPITFT : public Adafruit_GFX {\n\npublic:\n  // CONSTRUCTORS --------------------------------------------------------\n\n  // Software SPI constructor: expects width & height (at default rotation\n  // setting 0), 4 signal pins (cs, dc, mosi, sclk), 2 optional pins\n  // (reset, miso). cs argument is required but can be -1 if unused --\n  // rather than moving it to the optional arguments, it was done this way\n  // to avoid breaking existing code (-1 option was a later addition).\n  Adafruit_SPITFT(uint16_t w, uint16_t h, int8_t cs, int8_t dc, int8_t mosi,\n                  int8_t sck, int8_t rst = -1, int8_t miso = -1);\n\n  // Hardware SPI constructor using the default SPI port: expects width &\n  // height (at default rotation setting 0), 2 signal pins (cs, dc),\n  // optional reset pin. cs is required but can be -1 if unused -- rather\n  // than moving it to the optional arguments, it was done this way to\n  // avoid breaking existing code (-1 option was a later addition).\n  Adafruit_SPITFT(uint16_t w, uint16_t h, int8_t cs, int8_t dc,\n                  int8_t rst = -1);\n\n#if !defined(ESP8266) // See notes in .cpp\n  // Hardware SPI constructor using an arbitrary SPI peripheral: expects\n  // width & height (rotation 0), SPIClass pointer, 2 signal pins (cs, dc)\n  // and optional reset pin. cs is required but can be -1 if unused.\n  Adafruit_SPITFT(uint16_t w, uint16_t h, SPIClass *spiClass, int8_t cs,\n                  int8_t dc, int8_t rst = -1);\n#endif // end !ESP8266\n\n  // Parallel constructor: expects width & height (rotation 0), flag\n  // indicating whether 16-bit (true) or 8-bit (false) interface, 3 signal\n  // pins (d0, wr, dc), 3 optional pins (cs, rst, rd). 16-bit parallel\n  // isn't even fully implemented but the 'wide' flag was added as a\n  // required argument to avoid ambiguity with other constructors.\n  Adafruit_SPITFT(uint16_t w, uint16_t h, tftBusWidth busWidth, int8_t d0,\n                  int8_t wr, int8_t dc, int8_t cs = -1, int8_t rst = -1,\n                  int8_t rd = -1);\n\n  // DESTRUCTOR ----------------------------------------------------------\n\n  ~Adafruit_SPITFT(){};\n\n  // CLASS MEMBER FUNCTIONS ----------------------------------------------\n\n  // These first two functions MUST be declared by subclasses:\n\n  /*!\n      @brief  Display-specific initialization function.\n      @param  freq  SPI frequency, in hz (or 0 for default or unused).\n  */\n  virtual void begin(uint32_t freq) = 0;\n\n  /*!\n      @brief  Set up the specific display hardware's \"address window\"\n              for subsequent pixel-pushing operations.\n      @param  x  Leftmost pixel of area to be drawn (MUST be within\n                 display bounds at current rotation setting).\n      @param  y  Topmost pixel of area to be drawn (MUST be within\n                 display bounds at current rotation setting).\n      @param  w  Width of area to be drawn, in pixels (MUST be >0 and,\n                 added to x, within display bounds at current rotation).\n      @param  h  Height of area to be drawn, in pixels (MUST be >0 and,\n                 added to x, within display bounds at current rotation).\n  */\n  virtual void setAddrWindow(uint16_t x, uint16_t y, uint16_t w,\n                             uint16_t h) = 0;\n\n  // Remaining functions do not need to be declared in subclasses\n  // unless they wish to provide hardware-specific optimizations.\n  // Brief comments here...documented more thoroughly in .cpp file.\n\n  // Subclass' begin() function invokes this to initialize hardware.\n  // freq=0 to use default SPI speed. spiMode must be one of the SPI_MODEn\n  // values defined in SPI.h, which are NOT the same as 0 for SPI_MODE0,\n  // 1 for SPI_MODE1, etc...use ONLY the SPI_MODEn defines! Only!\n  // Name is outdated (interface may be parallel) but for compatibility:\n  void initSPI(uint32_t freq = 0, uint8_t spiMode = SPI_MODE0);\n  void setSPISpeed(uint32_t freq);\n  // Chip select and/or hardware SPI transaction start as needed:\n  void startWrite(void);\n  // Chip deselect and/or hardware SPI transaction end as needed:\n  void endWrite(void);\n  void sendCommand(uint8_t commandByte, uint8_t *dataBytes,\n                   uint8_t numDataBytes);\n  void sendCommand(uint8_t commandByte, const uint8_t *dataBytes = NULL,\n                   uint8_t numDataBytes = 0);\n  void sendCommand16(uint16_t commandWord, const uint8_t *dataBytes = NULL,\n                     uint8_t numDataBytes = 0);\n  uint8_t readcommand8(uint8_t commandByte, uint8_t index = 0);\n  uint16_t readcommand16(uint16_t addr);\n\n  // These functions require a chip-select and/or SPI transaction\n  // around them. Higher-level graphics primitives might start a\n  // single transaction and then make multiple calls to these functions\n  // (e.g. circle or text rendering might make repeated lines or rects)\n  // before ending the transaction. It's more efficient than starting a\n  // transaction every time.\n  void writePixel(int16_t x, int16_t y, uint16_t color);\n  void writePixels(uint16_t *colors, uint32_t len, bool block = true,\n                   bool bigEndian = false);\n  void writeColor(uint16_t color, uint32_t len);\n  void writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,\n                     uint16_t color);\n  void writeFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  void writeFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  // This is a new function, similar to writeFillRect() except that\n  // all arguments MUST be onscreen, sorted and clipped. If higher-level\n  // primitives can handle their own sorting/clipping, it avoids repeating\n  // such operations in the low-level code, making it potentially faster.\n  // CALLING THIS WITH UNCLIPPED OR NEGATIVE VALUES COULD BE DISASTROUS.\n  inline void writeFillRectPreclipped(int16_t x, int16_t y, int16_t w,\n                                      int16_t h, uint16_t color);\n  // Another new function, companion to the new non-blocking\n  // writePixels() variant.\n  void dmaWait(void);\n  // Used by writePixels() in some situations, but might have rare need in\n  // user code, so it's public...\n  bool dmaBusy(void) const; // true if DMA is used and busy, false otherwise\n  void swapBytes(uint16_t *src, uint32_t len, uint16_t *dest = NULL);\n\n  // These functions are similar to the 'write' functions above, but with\n  // a chip-select and/or SPI transaction built-in. They're typically used\n  // solo -- that is, as graphics primitives in themselves, not invoked by\n  // higher-level primitives (which should use the functions above).\n  void drawPixel(int16_t x, int16_t y, uint16_t color);\n  void fillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color);\n  void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color);\n  void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color);\n  // A single-pixel push encapsulated in a transaction. I don't think\n  // this is used anymore (BMP demos might've used it?) but is provided\n  // for backward compatibility, consider it deprecated:\n  void pushColor(uint16_t color);\n\n  using Adafruit_GFX::drawRGBBitmap; // Check base class first\n  void drawRGBBitmap(int16_t x, int16_t y, uint16_t *pcolors, int16_t w,\n                     int16_t h);\n\n  void invertDisplay(bool i);\n  uint16_t color565(uint8_t r, uint8_t g, uint8_t b);\n\n  // Despite parallel additions, function names kept for compatibility:\n  void spiWrite(uint8_t b);          // Write single byte as DATA\n  void writeCommand(uint8_t cmd);    // Write single byte as COMMAND\n  uint8_t spiRead(void);             // Read single byte of data\n  void write16(uint16_t w);          // Write 16-bit value as DATA\n  void writeCommand16(uint16_t cmd); // Write 16-bit value as COMMAND\n  uint16_t read16(void);             // Read single 16-bit value\n\n  // Most of these low-level functions were formerly macros in\n  // Adafruit_SPITFT_Macros.h. Some have been made into inline functions\n  // to avoid macro mishaps. Despite the addition of code for a parallel\n  // display interface, the names have been kept for backward\n  // compatibility (some subclasses may be invoking these):\n  void SPI_WRITE16(uint16_t w); // Not inline\n  void SPI_WRITE32(uint32_t l); // Not inline\n  // Old code had both a spiWrite16() function and SPI_WRITE16 macro\n  // in addition to the SPI_WRITE32 macro. The latter two have been\n  // made into functions here, and spiWrite16() removed (use SPI_WRITE16()\n  // instead). It looks like most subclasses had gotten comfortable with\n  // SPI_WRITE16 and SPI_WRITE32 anyway so those names were kept rather\n  // than the less-obnoxious camelcase variants, oh well.\n\n  // Placing these functions entirely in the class definition inlines\n  // them implicitly them while allowing their use in other code:\n\n  /*!\n      @brief  Set the chip-select line HIGH. Does NOT check whether CS pin\n              is set (>=0), that should be handled in calling function.\n              Despite function name, this is used even if the display\n              connection is parallel.\n  */\n  void SPI_CS_HIGH(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n    *csPortSet = 1;\n#else  // !KINETISK\n    *csPortSet = csPinMask;\n#endif // end !KINETISK\n#else  // !HAS_PORT_SET_CLR\n    *csPort |= csPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n    digitalWrite(_cs, HIGH);\n#endif // end !USE_FAST_PINIO\n  }\n\n  /*!\n      @brief  Set the chip-select line LOW. Does NOT check whether CS pin\n              is set (>=0), that should be handled in calling function.\n              Despite function name, this is used even if the display\n              connection is parallel.\n  */\n  void SPI_CS_LOW(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n    *csPortClr = 1;\n#else  // !KINETISK\n    *csPortClr = csPinMask;\n#endif // end !KINETISK\n#else  // !HAS_PORT_SET_CLR\n    *csPort &= csPinMaskClr;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n    digitalWrite(_cs, LOW);\n#endif // end !USE_FAST_PINIO\n  }\n\n  /*!\n      @brief  Set the data/command line HIGH (data mode).\n  */\n  void SPI_DC_HIGH(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n    *dcPortSet = 1;\n#else  // !KINETISK\n    *dcPortSet = dcPinMask;\n#endif // end !KINETISK\n#else  // !HAS_PORT_SET_CLR\n    *dcPort |= dcPinMaskSet;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n    digitalWrite(_dc, HIGH);\n#endif // end !USE_FAST_PINIO\n  }\n\n  /*!\n      @brief  Set the data/command line LOW (command mode).\n  */\n  void SPI_DC_LOW(void) {\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if defined(KINETISK)\n    *dcPortClr = 1;\n#else  // !KINETISK\n    *dcPortClr = dcPinMask;\n#endif // end !KINETISK\n#else  // !HAS_PORT_SET_CLR\n    *dcPort &= dcPinMaskClr;\n#endif // end !HAS_PORT_SET_CLR\n#else  // !USE_FAST_PINIO\n    digitalWrite(_dc, LOW);\n#endif // end !USE_FAST_PINIO\n  }\n\nprotected:\n  // A few more low-level member functions -- some may have previously\n  // been macros. Shouldn't have a need to access these externally, so\n  // they've been moved to the protected section. Additionally, they're\n  // declared inline here and the code is in the .cpp file, since outside\n  // code doesn't need to see these.\n  inline void SPI_MOSI_HIGH(void);\n  inline void SPI_MOSI_LOW(void);\n  inline void SPI_SCK_HIGH(void);\n  inline void SPI_SCK_LOW(void);\n  inline bool SPI_MISO_READ(void);\n  inline void SPI_BEGIN_TRANSACTION(void);\n  inline void SPI_END_TRANSACTION(void);\n  inline void TFT_WR_STROBE(void); // Parallel interface write strobe\n  inline void TFT_RD_HIGH(void);   // Parallel interface read high\n  inline void TFT_RD_LOW(void);    // Parallel interface read low\n\n  // CLASS INSTANCE VARIABLES --------------------------------------------\n\n  // Here be dragons! There's a big union of three structures here --\n  // one each for hardware SPI, software (bitbang) SPI, and parallel\n  // interfaces. This is to save some memory, since a display's connection\n  // will be only one of these. The order of some things is a little weird\n  // in an attempt to get values to align and pack better in RAM.\n\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n  PORTreg_t csPortSet; ///< PORT register for chip select SET\n  PORTreg_t csPortClr; ///< PORT register for chip select CLEAR\n  PORTreg_t dcPortSet; ///< PORT register for data/command SET\n  PORTreg_t dcPortClr; ///< PORT register for data/command CLEAR\n#else                  // !HAS_PORT_SET_CLR\n  PORTreg_t csPort;                 ///< PORT register for chip select\n  PORTreg_t dcPort;                 ///< PORT register for data/command\n#endif                 // end HAS_PORT_SET_CLR\n#endif                 // end USE_FAST_PINIO\n#if defined(__cplusplus) && (__cplusplus >= 201100)\n  union {\n#endif\n    struct {          //   Values specific to HARDWARE SPI:\n      SPIClass *_spi; ///< SPI class pointer\n#if defined(SPI_HAS_TRANSACTION)\n      SPISettings settings; ///< SPI transaction settings\n#else\n    uint32_t _freq; ///< SPI bitrate (if no SPI transactions)\n#endif\n      uint32_t _mode; ///< SPI data mode (transactions or no)\n    } hwspi;          ///< Hardware SPI values\n    struct {          //   Values specific to SOFTWARE SPI:\n#if defined(USE_FAST_PINIO)\n      PORTreg_t misoPort; ///< PORT (PIN) register for MISO\n#if defined(HAS_PORT_SET_CLR)\n      PORTreg_t mosiPortSet; ///< PORT register for MOSI SET\n      PORTreg_t mosiPortClr; ///< PORT register for MOSI CLEAR\n      PORTreg_t sckPortSet;  ///< PORT register for SCK SET\n      PORTreg_t sckPortClr;  ///< PORT register for SCK CLEAR\n#if !defined(KINETISK)\n      ADAGFX_PORT_t mosiPinMask; ///< Bitmask for MOSI\n      ADAGFX_PORT_t sckPinMask;  ///< Bitmask for SCK\n#endif                           // end !KINETISK\n#else                            // !HAS_PORT_SET_CLR\n      PORTreg_t mosiPort;           ///< PORT register for MOSI\n      PORTreg_t sckPort;            ///< PORT register for SCK\n      ADAGFX_PORT_t mosiPinMaskSet; ///< Bitmask for MOSI SET (OR)\n      ADAGFX_PORT_t mosiPinMaskClr; ///< Bitmask for MOSI CLEAR (AND)\n      ADAGFX_PORT_t sckPinMaskSet;  ///< Bitmask for SCK SET (OR bitmask)\n      ADAGFX_PORT_t sckPinMaskClr;  ///< Bitmask for SCK CLEAR (AND)\n#endif                           // end HAS_PORT_SET_CLR\n#if !defined(KINETISK)\n      ADAGFX_PORT_t misoPinMask; ///< Bitmask for MISO\n#endif                           // end !KINETISK\n#endif                           // end USE_FAST_PINIO\n      int8_t _mosi;              ///< MOSI pin #\n      int8_t _miso;              ///< MISO pin #\n      int8_t _sck;               ///< SCK pin #\n    } swspi;                     ///< Software SPI values\n    struct {                     //   Values specific to 8-bit parallel:\n#if defined(USE_FAST_PINIO)\n\n#if defined(__IMXRT1052__) || defined(__IMXRT1062__) // Teensy 4.x\n      volatile uint32_t *writePort; ///< PORT register for DATA WRITE\n      volatile uint32_t *readPort;  ///< PORT (PIN) register for DATA READ\n#else\n      volatile uint8_t *writePort;  ///< PORT register for DATA WRITE\n      volatile uint8_t *readPort;   ///< PORT (PIN) register for DATA READ\n#endif\n#if defined(HAS_PORT_SET_CLR)\n      // Port direction register pointers are always 8-bit regardless of\n      // PORTreg_t -- even if 32-bit port, we modify a byte-aligned 8 bits.\n#if defined(__IMXRT1052__) || defined(__IMXRT1062__) // Teensy 4.x\n      volatile uint32_t *dirSet; ///< PORT byte data direction SET\n      volatile uint32_t *dirClr; ///< PORT byte data direction CLEAR\n#else\n      volatile uint8_t *dirSet; ///< PORT byte data direction SET\n      volatile uint8_t *dirClr; ///< PORT byte data direction CLEAR\n#endif\n      PORTreg_t wrPortSet; ///< PORT register for write strobe SET\n      PORTreg_t wrPortClr; ///< PORT register for write strobe CLEAR\n      PORTreg_t rdPortSet; ///< PORT register for read strobe SET\n      PORTreg_t rdPortClr; ///< PORT register for read strobe CLEAR\n#if !defined(KINETISK)\n      ADAGFX_PORT_t wrPinMask; ///< Bitmask for write strobe\n#endif                         // end !KINETISK\n      ADAGFX_PORT_t rdPinMask; ///< Bitmask for read strobe\n#else                          // !HAS_PORT_SET_CLR\n      // Port direction register pointer is always 8-bit regardless of\n      // PORTreg_t -- even if 32-bit port, we modify a byte-aligned 8 bits.\n      volatile uint8_t *portDir;  ///< PORT direction register\n      PORTreg_t wrPort;           ///< PORT register for write strobe\n      PORTreg_t rdPort;           ///< PORT register for read strobe\n      ADAGFX_PORT_t wrPinMaskSet; ///< Bitmask for write strobe SET (OR)\n      ADAGFX_PORT_t wrPinMaskClr; ///< Bitmask for write strobe CLEAR (AND)\n      ADAGFX_PORT_t rdPinMaskSet; ///< Bitmask for read strobe SET (OR)\n      ADAGFX_PORT_t rdPinMaskClr; ///< Bitmask for read strobe CLEAR (AND)\n#endif                         // end HAS_PORT_SET_CLR\n#endif                         // end USE_FAST_PINIO\n      int8_t _d0;              ///< Data pin 0 #\n      int8_t _wr;              ///< Write strobe pin #\n      int8_t _rd;              ///< Read strobe pin # (or -1)\n      bool wide = 0;           ///< If true, is 16-bit interface\n    } tft8;                    ///< Parallel interface settings\n#if defined(__cplusplus) && (__cplusplus >= 201100)\n  }; ///< Only one interface is active\n#endif\n#if defined(USE_SPI_DMA) &&                                                    \\\n    (defined(__SAMD51__) ||                                                    \\\n     defined(ARDUINO_SAMD_ZERO))     // Used by hardware SPI and tft8\n  Adafruit_ZeroDMA dma;              ///< DMA instance\n  DmacDescriptor *dptr = NULL;       ///< 1st descriptor\n  DmacDescriptor *descriptor = NULL; ///< Allocated descriptor list\n  uint16_t *pixelBuf[2];             ///< Working buffers\n  uint16_t maxFillLen;               ///< Max pixels per DMA xfer\n  uint16_t lastFillColor = 0;        ///< Last color used w/fill\n  uint32_t lastFillLen = 0;          ///< # of pixels w/last fill\n  uint8_t onePixelBuf;               ///< For hi==lo fill\n#endif\n#if defined(USE_FAST_PINIO)\n#if defined(HAS_PORT_SET_CLR)\n#if !defined(KINETISK)\n  ADAGFX_PORT_t csPinMask; ///< Bitmask for chip select\n  ADAGFX_PORT_t dcPinMask; ///< Bitmask for data/command\n#endif                     // end !KINETISK\n#else                      // !HAS_PORT_SET_CLR\n  ADAGFX_PORT_t csPinMaskSet;     ///< Bitmask for chip select SET (OR)\n  ADAGFX_PORT_t csPinMaskClr;     ///< Bitmask for chip select CLEAR (AND)\n  ADAGFX_PORT_t dcPinMaskSet;     ///< Bitmask for data/command SET (OR)\n  ADAGFX_PORT_t dcPinMaskClr;     ///< Bitmask for data/command CLEAR (AND)\n#endif                     // end HAS_PORT_SET_CLR\n#endif                     // end USE_FAST_PINIO\n  uint8_t connection;      ///< TFT_HARD_SPI, TFT_SOFT_SPI, etc.\n  int8_t _rst;             ///< Reset pin # (or -1)\n  int8_t _cs;              ///< Chip select pin # (or -1)\n  int8_t _dc;              ///< Data/command pin #\n\n  int16_t _xstart = 0;          ///< Internal framebuffer X offset\n  int16_t _ystart = 0;          ///< Internal framebuffer Y offset\n  uint8_t invertOnCommand = 0;  ///< Command to enable invert mode\n  uint8_t invertOffCommand = 0; ///< Command to disable invert mode\n\n  uint32_t _freq = 0; ///< Dummy var to keep subclasses happy\n};\n\n#endif // end __AVR_ATtiny85__ __AVR_ATtiny84__\n#endif // end _ADAFRUIT_SPITFT_H_\n"
        },
        {
          "name": "Adafruit_SPITFT_Macros.h",
          "type": "blob",
          "size": 0.3212890625,
          "content": "// THIS FILE INTENTIONALLY LEFT BLANK.\n\n// Macros previously #defined here have been made into (mostly) inline\n// functions in the Adafruit_SPITFT class. Other libraries might still\n// contain code trying to #include this header file, so until everything's\n// updated this file still exists (but doing nothing) to avoid trouble.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 0.361328125,
          "content": "# Adafruit GFX Library\r\n# https://github.com/adafruit/Adafruit-GFX-Library\r\n# BSD License\r\n\r\ncmake_minimum_required(VERSION 3.5)\r\n\r\nidf_component_register(SRCS \"Adafruit_GFX.cpp\" \"Adafruit_GrayOLED.cpp\" \"Adafruit_SPITFT.cpp\" \"glcdfont.c\"\r\n                       INCLUDE_DIRS \".\"\r\n                       REQUIRES arduino Adafruit_BusIO)\r\n\r\nproject(Adafruit-GFX-Library)\r\n"
        },
        {
          "name": "Fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.66015625,
          "content": "# Adafruit GFX Library ![Build Status](https://github.com/adafruit/Adafruit-GFX-Library/workflows/Arduino%20Library%20CI/badge.svg)\n\nThis is the core graphics library for all our displays, providing a common set of graphics primitives (points, lines, circles, etc.). It needs to be paired with a hardware-specific library for each display device we carry (to handle the lower-level functions).\n\nAdafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit!\n\nWritten by Limor Fried/Ladyada for Adafruit Industries.\nBSD license, check license.txt for more information.\nAll text above must be included in any redistribution.\n\nRecent Arduino IDE releases include the Library Manager for easy installation. Otherwise, to download, click the DOWNLOAD ZIP button, uncompress and rename the uncompressed folder Adafruit_GFX. Confirm that the Adafruit_GFX folder contains Adafruit_GFX.cpp and Adafruit_GFX.h. Place the Adafruit_GFX library folder your ArduinoSketchFolder/Libraries/ folder. You may need to create the Libraries subfolder if its your first library. Restart the IDE.\n\n**You will also need to install the latest Adafruit BusIO library.** Search for \"Adafruit BusIO\" in the library manager, or install by hand from https://github.com/adafruit/Adafruit_BusIO\n\n# Useful Resources\n\n- Image2Code: This is a handy Java GUI utility to convert a BMP file into the array code necessary to display the image with the drawBitmap function. Check out the code at ehubin's GitHub repository: https://github.com/ehubin/Adafruit-GFX-Library/tree/master/Img2Code\n\n- drawXBitmap function: You can use the GIMP photo editor to save a .xbm file and use the array saved in the file to draw a bitmap with the drawXBitmap function. See the pull request here for more details: https://github.com/adafruit/Adafruit-GFX-Library/pull/31\n\n- 'Fonts' folder contains bitmap fonts for use with recent (1.1 and later) Adafruit_GFX. To use a font in your Arduino sketch, \\#include the corresponding .h file and pass address of GFXfont struct to setFont(). Pass NULL to revert to 'classic' fixed-space bitmap font.\n\n- 'fontconvert' folder contains a command-line tool for converting TTF fonts to Adafruit_GFX header format.\n\n- You can also use [this GFX Font Customiser tool](https://github.com/tchapi/Adafruit-GFX-Font-Customiser) (_web version [here](https://tchapi.github.io/Adafruit-GFX-Font-Customiser/)_) to customize or correct the output from [fontconvert](https://github.com/adafruit/Adafruit-GFX-Library/tree/master/fontconvert), and create fonts with only a subset of characters to optimize size.\n\n---\n\n### Roadmap\n\nThe PRIME DIRECTIVE is to maintain backward compatibility with existing Arduino sketches -- many are hosted elsewhere and don't track changes here, some are in print and can never be changed! This \"little\" library has grown organically over time and sometimes we paint ourselves into a design corner and just have to live with it or add progressively more ungainly workarounds.\n\n**We are grateful for everyone's contributions, but pull requests for the following will NOT be merged:**\n\n- Additional or incompatible font formats (see Prime Directive above). There are already two formats and the code is quite bloaty there as it is. This also creates liabilities for tools and documentation. What's there isn't perfect but it does the job.\n\n- Additional or incompatible bitmap formats, for similar reasons. It's getting messy.\n\n- Adding background color to custom fonts to erase prior screen contents. The ONLY acceptable methods are to clear the area with a filled rect, or (to avoid flicker) draw text into a GFXcanvas1 and copy to screen with drawBitmap() w/background color. This is on purpose and by design. We've discussed this. Glyphs can overlap.\n\n- Scrolling, whether hardware- or software-based. Such implementations tend to rely on hardware-specific features (not universally available), read access to the screen's framebuffer (ditto) and/or the addition of virtual functions in GFX which them must be added in *every* subclass, of which there are many. The GFX API is largely \"set\" at this point and this is just a limitation we live with now.\n\n- Please don't reformat code for the sake of reformatting code. The resulting large \"visual diff\" makes it impossible to untangle actual bug fixes from merely rearranged lines. clang-format will be the final arbiter.\n\n- Please no more pentagram-drawing PRs. Any oddly-specific drawing functions can go in your own code and aren't helpful in a library context.\n\nIf you *must* have one of these features, consider creating a fork with the features required for your project...it's easy to keep synced with the upstream code.\n"
        },
        {
          "name": "component.mk",
          "type": "blob",
          "size": 0.0302734375,
          "content": "COMPONENT_ADD_INCLUDEDIRS = .\r\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fontconvert",
          "type": "tree",
          "content": null
        },
        {
          "name": "gfxfont.h",
          "type": "blob",
          "size": 1.08203125,
          "content": "// Font structures for newer Adafruit_GFX (1.1 and later).\n// Example fonts are included in 'Fonts' directory.\n// To use a font in your Arduino sketch, #include the corresponding .h\n// file and pass address of GFXfont struct to setFont().  Pass NULL to\n// revert to 'classic' fixed-space bitmap font.\n\n#ifndef _GFXFONT_H_\n#define _GFXFONT_H_\n\n/// Font data stored PER GLYPH\ntypedef struct {\n  uint16_t bitmapOffset; ///< Pointer into GFXfont->bitmap\n  uint8_t width;         ///< Bitmap dimensions in pixels\n  uint8_t height;        ///< Bitmap dimensions in pixels\n  uint8_t xAdvance;      ///< Distance to advance cursor (x axis)\n  int8_t xOffset;        ///< X dist from cursor pos to UL corner\n  int8_t yOffset;        ///< Y dist from cursor pos to UL corner\n} GFXglyph;\n\n/// Data stored for FONT AS A WHOLE\ntypedef struct {\n  uint8_t *bitmap;  ///< Glyph bitmaps, concatenated\n  GFXglyph *glyph;  ///< Glyph array\n  uint16_t first;   ///< ASCII extents (first char)\n  uint16_t last;    ///< ASCII extents (last char)\n  uint8_t yAdvance; ///< Newline distance (y axis)\n} GFXfont;\n\n#endif // _GFXFONT_H_\n"
        },
        {
          "name": "glcdfont.c",
          "type": "blob",
          "size": 8.8515625,
          "content": "// This is the 'classic' fixed-space bitmap font for Adafruit_GFX since 1.0.\n// See gfxfont.h for newer custom bitmap font info.\n\n#ifndef FONT5X7_H\n#define FONT5X7_H\n\n#ifdef __AVR__\n#include <avr/io.h>\n#include <avr/pgmspace.h>\n#elif defined(ESP8266)\n#include <pgmspace.h>\n#elif defined(__IMXRT1052__) || defined(__IMXRT1062__)\n// PROGMEM is defefind for T4 to place data in specific memory section\n#undef PROGMEM\n#define PROGMEM\n#else\n#define PROGMEM\n#endif\n\n// Standard ASCII 5x7 font\n\nstatic const unsigned char font[] PROGMEM = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B,\n    0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C,\n    0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,\n    0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24,\n    0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E,\n    0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F,\n    0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C,\n    0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F,\n    0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89,\n    0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94,\n    0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20, 0x10, 0x08, 0x08,\n    0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E, 0x10, 0x10, 0x10,\n    0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E, 0x38, 0x30, 0x06,\n    0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F,\n    0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14,\n    0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64, 0x62, 0x36, 0x49,\n    0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00, 0x1C, 0x22, 0x41,\n    0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08,\n    0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00, 0x08, 0x08, 0x08,\n    0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02,\n    0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x72, 0x49,\n    0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F,\n    0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41,\n    0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36, 0x46, 0x49, 0x49,\n    0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00,\n    0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x41,\n    0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59,\n    0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E,\n    0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49,\n    0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41, 0x41, 0x51, 0x73,\n    0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x20, 0x40,\n    0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F, 0x40, 0x40, 0x40,\n    0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E,\n    0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x3E, 0x41, 0x51,\n    0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49, 0x49, 0x49, 0x32,\n    0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20,\n    0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63, 0x14, 0x08, 0x14,\n    0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,\n    0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x41, 0x41,\n    0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40, 0x40, 0x40, 0x40,\n    0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78, 0x40, 0x7F, 0x28,\n    0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38, 0x44, 0x44, 0x28,\n    0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E, 0x09, 0x02, 0x18,\n    0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x44, 0x7D,\n    0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,\n    0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04, 0x78, 0x7C, 0x08,\n    0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC, 0x18, 0x24, 0x24,\n    0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x48,\n    0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40,\n    0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C,\n    0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x44, 0x64,\n    0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x77, 0x00,\n    0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02, 0x04, 0x02, 0x3C,\n    0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40,\n    0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55, 0x55, 0x79, 0x41,\n    0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut\n    0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E,\n    0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54,\n    0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,\n    0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0x7D, 0x12, 0x11,\n    0x12, 0x7D, // A-umlaut\n    0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54,\n    0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49,\n    0x32, 0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut\n    0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42,\n    0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42, 0x42,\n    0x3D, // O-umlaut\n    0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E,\n    0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6,\n    0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00,\n    0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40,\n    0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D,\n    0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48,\n    0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\n    0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,\n    0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A,\n    0x14, 0x08, 0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old\n                                              // code\n    0xAA, 0x55, 0xAA, 0x55, 0xAA,             // 50% block\n    0xFF, 0x55, 0xFF, 0x55, 0xFF,             // 75% block\n    0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14,\n    0x14, 0xFF, 0x00, 0x10, 0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10,\n    0xF0, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,\n    0x00, 0xFF, 0x00, 0xFF, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17,\n    0x10, 0x1F, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00,\n    0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10,\n    0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF,\n    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,\n    0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F,\n    0x10, 0x17, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17,\n    0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14,\n    0x14, 0x14, 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17,\n    0x14, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10,\n    0x10, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00,\n    0x1F, 0x14, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0,\n    0x10, 0x10, 0xFF, 0x10, 0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10,\n    0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44,\n    0x38, 0x44, 0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta\n    0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02, 0x63, 0x55,\n    0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E, 0x20, 0x1E,\n    0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x1C,\n    0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30, 0x4A, 0x4D,\n    0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A, 0x46, 0x3D,\n    0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x2A, 0x2A,\n    0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51, 0x4A, 0x44,\n    0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01, 0x03, 0xE0,\n    0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36, 0x12, 0x36,\n    0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18, 0x18, 0x00,\n    0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01, 0x00, 0x1F,\n    0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C, 0x3C, 0x3C,\n    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP\n};\n\n// allow clean compilation with [-Wunused-const-variable=] and [-Wall]\nstatic inline void avoid_unused_const_variable_compiler_warning(void) {\n  (void)font;\n}\n\n#endif // FONT5X7_H\n"
        },
        {
          "name": "library.properties",
          "type": "blob",
          "size": 0.4033203125,
          "content": "name=Adafruit GFX Library\nversion=1.11.11\nauthor=Adafruit\nmaintainer=Adafruit <info@adafruit.com>\nsentence=Adafruit GFX graphics core library, this is the 'core' class that all our other graphics libraries derive from.\nparagraph=Install this library in addition to the display library for your hardware.\ncategory=Display\nurl=https://github.com/adafruit/Adafruit-GFX-Library\narchitectures=*\ndepends=Adafruit BusIO\n"
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.3125,
          "content": "Software License Agreement (BSD License)\n\nCopyright (c) 2012 Adafruit Industries.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n- Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n- Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
        }
      ]
    }
  ]
}