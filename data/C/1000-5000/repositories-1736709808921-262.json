{
  "metadata": {
    "timestamp": 1736709808921,
    "page": 262,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DhavalKapil/icmptunnel",
      "stars": 3109,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0380859375,
          "content": "*.o\ntest_client\ntest_server\nicmptunnel\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0283203125,
          "content": "language: c\nscript: make all\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.490234375,
          "content": "CC=gcc\nCFLAGS=-I. -O3 -Wall\nDEPS = icmp.h tunnel.h\n\n%.o: %.c $(DEPS)\n\t$(CC) -c -o $@ $< $(CFLAGS)\n\nicmptunnel: icmptunnel.o icmp.o tunnel.o\n\t$(CC) -o icmptunnel icmp.o tunnel.o icmptunnel.o $(CFLAGS)\n\ntest_server: icmp.o test_server.o\n\t$(CC) -o test_server icmp.o test_server.o $(CFLAGS)\n\ntest_client: icmp.o test_client.o\n\t$(CC) -o test_client icmp.o test_client.o $(CFLAGS)\n\ntest: test_server test_client\n\nall: icmptunnel test_server test_client\n\nclean:\n\trm -f *.o test_server test_client icmptunnel\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.1962890625,
          "content": "# icmptunnel [![Build Status](https://travis-ci.org/DhavalKapil/icmptunnel.svg?branch=master)](https://travis-ci.org/DhavalKapil/icmptunnel)\n\n> Transparently tunnel your IP traffic through ICMP echo and reply packets.\n\n'icmptunnel' works by encapsulating your IP traffic in ICMP echo packets and sending them to your own proxy server. The proxy server decapsulates the packet and forwards the IP traffic. The incoming IP packets which are destined for the client are again encapsulated in ICMP reply packets and sent back to the client. The IP traffic is sent in the 'data' field of ICMP packets.\n\n[RFC 792](http://www.ietf.org/rfc/rfc792.txt), which is IETF's rules governing ICMP packets, allows for an arbitrary data length for any type 0 (echo reply) or 8 (echo message) ICMP packets.\n\nSo basically the client machine uses only the ICMP protocol to communicate with the proxy server. Applications running on the client machine are oblivious to this fact and work seamlessly.\n\n## Use Cases\n\n1. **Bypassing Captive Portals**: Many public Wi-Fi use [Captive Portals](https://en.wikipedia.org/wiki/Captive_portal) to authenticate users, i.e. after connecting to the Wi-Fi the user is redirected to a webpage that requires a login. icmptunnel can be used to bypass such authentications in transport/application layers.\n\n2. **Bypassing firewalls**: Firewalls are set up in various networks to block certain type of traffic. icmptunnel can be used to bypass such firewall rules. Obfuscating the data payload can also be helpful to bypass some firewalls.\n\n3. **Encrypted Communication Channel**: Adding sufficient encryption to the data, icmptunnel can be used to establish an encrypted communication channel between two host machines. \n\n## Requirements\n\n1. A POSIX-compliant host with root access that will be communicating with only ICMP protocol. This will be the client.\n\n2. A POSIX-compliant host with root access with full access to the internet. This will act as our proxy server.\n\n3. The proxy server should be accessible from the client host.\n\n_Note: Although icmptunnel has been successfully tested on Ubuntu 14.04 LTS, it should work on others as well._\n\n## Step-by-step instructions\n\n1. Install `make` on both machines.\n\n2. Clone this repository using this command:\n\n  ```\n  git clone https://github.com/DhavalKapil/icmptunnel\n  ```\n\n3. Run `make`:\n\n  ```\n  make\n  ```\n\n4. On the server side run the tunnel with root privileges:\n\n  ```\n  [sudo] ./icmptunnel -s 10.0.1.1\n  ```\n\n5. On the client side, find out your gateway and the corresponding interface:\n\n  ```\n  route -n\n\n  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\n\n  0.0.0.0         172.25.30.1     0.0.0.0         UG    0      0        0 eth0\n  ```\n\n  Edit client.sh and replace \\<server\\> with the IP address of the proxy server. \\<gateway\\> with gateway address obtained above and similarly for \\<interface\\>.\n\n6. Check the DNS server at client side. Make sure it does not use any server not accessible by our proxy server. One suggestion is to use `8.8.8.8`(Google's DNS server) which will be accessible to the proxy server. You would need to edit your DNS settings for this. *You might need to manually delete the route for your local DNS server from your routing table.*\n\n7. Run the tunnel on your client with root privileges:\n\n  ```\n  [sudo] ./icmptunnel -c <server>\n  ```\n\nThe tunnel should run and your client machine should be able to access the internet. All traffic will be tunneled through ICMP.\n\n## Architecture\n\nicmptunnel works by creating a virtual tunnel interface(say `tun0`). All the user traffic on the client host is routed to `tun0`. icmptunnel listens on this interface for IP packets. These packets are encapsulated in an ICMP echo packet(i.e. the payload of the ICMP packet is nothing but the original IP packet). This newly generated ICMP packet is sent outside the client machine, to the proxy server, through the restricted internet connection.\n\nThe proxy server receives these ICMP packets and decapsulates the original IP packet. This is retransmitted onto the Internet after implementing IP masquerading. Hence, the target believes that it's the proxy server making the request. The target then responds back to the proxy server with an IP packet. This is again captured by icmptunnel, encapsulated in an ICMP reply packet and send back to the client. \n\nOn the client side, the IP packet is retrieved from the payload of the ICMP reply packet and injected in `tun0`. The user applications read from this virtual interface and hence get the proper IP packet.\n\n#### Overall Architecture\n\n```\n+--------------+                         +------------+\n|              |       ICMP traffic      |            |       IP traffic\n|    Client    |  ------------------->   |   Proxy    |   ------------------>\n|              |  <-------------------   |   Server   |   <------------------\n|              |    through restricted   |            |     proper internet\n+--------------+         internet        +------------+\n```\n\n#### Client Architecture\n\n```\n+--------------+                                    +------------+\n|              |  IP traffic  +------+  IP traffic  |            |   ICMP traffic\n|     User     |  --------->  | tun0 |  --------->  | icmptunnel | --------------->\n| Applications |  <---------  +------+  <---------  |  program   | <---------------\n|              |        (Virtual Interface)         |            |    restricted \n+--------------+                                    +------------+     internet\n```\n\n#### Proxy Server Architecture\n\n```\n                 +------------+\n  ICMP traffic   |            |  IP traffic     +------+       NAT/Masquerading\n---------------> | icmptunnel | ------------>   | tun0 |    ---------------------> \n<--------------- |  program   | <------------   +------+    <---------------------\n   restricted    |            |           (Virtual Interface)   proper internet\n    internet     +------------+\n```\n\n## Implementation\n\n* ICMP is implemented using raw C sockets.\n\n* The checksum is calculated using the algorithm given in [RFC 1071](https://tools.ietf.org/html/rfc1071).\n\n* [Tun](https://www.kernel.org/doc/Documentation/networking/tuntap.txt) driver is used for creating a virtual interface and binding to user space programs.\n\n* The virtual interface is configured through `ifconfig`.\n\n* `route` is used to change the routing tables of the client so as to route all traffic to the virtual tunnel interface.\n\n* `dd` is used to temporarily change the setting of IP forwarding and replying back to ICMP requests on the side of the proxy server.\n\n* `iptables` is used to set up `nat` on the server side.\n\n## Demo\n\n### Network Setup\n\nProxy server is connected to `eth0`. This interface provides full internet connection.\n\nBoth the client and proxy server are connected to `wlan0`(a WiFi hotspot). This hotspot is configured not to provide any internet connection.\n\n`tun0` will be created in both the client and the proxy server.\n\nThe client will make an HTTP request to [dhavalkapil.com](https://dhavalkapil.com).\n\n[Wireshark](https://www.wireshark.org/) is used to capture network traffic at both ends on various interface.\n\n### Screenshots of network traffic\n\n1. `tun0` on client side\n\n  ![tun0 client side](https://i.imgur.com/EnStcDO.png?1)\n\n  The usual HTTP request is visible along with response.\n\n2. `wlan0` on client side\n\n  ![wlan0 client side](https://i.imgur.com/EKEqCGv.png?1)\n\n  All traffic is ICMP. The HTTP/IP packet can be seen as part of the payload of the ICMP packet.\n\n3. `wlan0` on proxy server side\n\n  ![wlan0 proxy server side](https://i.imgur.com/6OhsUyZ.png?1)\n\n  The ICMP packets sent by the client can be seen.\n\n4. `tun0` on proxy server side\n\n  ![tun0 proxy server side](https://i.imgur.com/OCq9aZe.png?1)\n\n  The HTTP/IP packets are decapsulated and sent through `tun0`.\n\n5. `eth0` on proxy server side\n\n  ![eth0 proxy server side](https://i.imgur.com/HQigUea.png?1)\n  \n  The HTTP/IP packets are forwarded to the internet. Notice how the source IP has been masqueraded because of `nat`.\n\n## Contribution\n\nFeel free to [file issues](https://github.com/DhavalKapil/icmptunnel/issues) and submit [pull requests](https://github.com/DhavalKapil/icmptunnel/pulls) â€“ contributions are welcome.\n\n## License\n\nicmptunnel is licensed under the [MIT license](http://dhaval.mit-license.org/).\n"
        },
        {
          "name": "client.sh",
          "type": "blob",
          "size": 0.37890625,
          "content": "#!/bin/sh\n\n# Assigining an IP address and mask to 'tun0' interface\nifconfig tun0 mtu 1472 up 10.0.1.2 netmask 255.255.255.0\n\n# Modifying IP routing tables\nroute del default\n# 'server' is the IP address of the proxy server\n# 'gateway' and 'interface' can be obtained by usint the command: 'route -n'\nroute add -host <server> gw <gateway> dev <interface>\nroute add default gw 10.0.1.1 tun0\n"
        },
        {
          "name": "icmp.c",
          "type": "blob",
          "size": 5.6416015625,
          "content": "/**\n *  icmp.c\n */\n\n#include \"icmp.h\"\n#include <arpa/inet.h>\n#include <stdint.h>\n#include <string.h>\n#include <netinet/ip.h>\n#include <netinet/ip_icmp.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * Function to calculate checksum\n */\nuint16_t in_cksum(uint16_t *addr, int len);\n\n/**\n * Function to fill up common headers for IP and ICMP\n */\nvoid prepare_headers(struct iphdr *ip, struct icmphdr *icmp);\n\n/**\n * Function to set packet type as ECHO\n */\nvoid set_echo_type(struct icmp_packet *packet)\n{\n  packet->type = ICMP_ECHO;\n}\n\n/**\n * Function to set packet type as REPLY\n */\nvoid set_reply_type(struct icmp_packet *packet)\n{\n  packet->type = ICMP_ECHOREPLY;\n}\n\n/**\n * Function to open a socket for icmp\n */\nint open_icmp_socket()\n{\n  int sock_fd, on = 1;\n\n  sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);\n\n  if (sock_fd == -1) {\n    perror(\"Unable to open ICMP socket\\n\");\n    exit(EXIT_FAILURE);\n  }\n  \n  // Providing IP Headers\n  if (setsockopt(sock_fd, IPPROTO_IP, IP_HDRINCL, (const char *)&on, sizeof(on)) == -1) {\n    perror(\"Unable to set IP_HDRINCL socket option\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  return sock_fd;\n}\n\n/**\n * Function to bind the socket to INADDR_ANY\n */\nvoid bind_icmp_socket(int sock_fd)\n{\n  struct sockaddr_in servaddr;\n\n  // Initializing servaddr to bind to all interfaces\n  memset(&servaddr, 0, sizeof(struct sockaddr_in));\n  servaddr.sin_family = AF_INET;\n  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n  // binding the socket\n  if (bind(sock_fd, (struct sockaddr *)&servaddr, sizeof(struct sockaddr_in)) == -1) {\n    perror(\"Unable to bind\\n\");\n    exit(EXIT_FAILURE);\n  }\n}\n\n/**\n * Function to send ICMP Packet\n */\nvoid send_icmp_packet(int sock_fd, struct icmp_packet *packet_details)\n{\n  // Source and destination IPs\n  struct in_addr src_addr;\n  struct in_addr dest_addr;\n\n  struct iphdr *ip;\n  struct icmphdr *icmp;\n  char *icmp_payload;\n\n  int packet_size;\n  char *packet;\n\n  struct sockaddr_in servaddr;\n\n  inet_pton(AF_INET, packet_details->src_addr, &src_addr);\n  inet_pton(AF_INET, packet_details->dest_addr, &dest_addr);\n\n  packet_size = sizeof(struct iphdr) + sizeof(struct icmphdr) + packet_details->payload_size;\n  packet = calloc(packet_size, sizeof(uint8_t));\n  if (packet == NULL) {\n    perror(\"No memory available\\n\");\n    close_icmp_socket(sock_fd);\n    exit(EXIT_FAILURE);\n  }\n\n  // Initializing header and payload pointers\n  ip = (struct iphdr *)packet;\n  icmp = (struct icmphdr *)(packet + sizeof(struct iphdr));\n  icmp_payload = (char *)(packet + sizeof(struct iphdr) + sizeof(struct icmphdr));\n\n  prepare_headers(ip, icmp);\n\n  ip->tot_len = htons(packet_size);\n  ip->saddr = src_addr.s_addr;\n  ip->daddr = dest_addr.s_addr;\n\n  memcpy(icmp_payload, packet_details->payload, packet_details->payload_size);\n\n  icmp->type = packet_details->type;\n  icmp->checksum = 0;\n  icmp->checksum = in_cksum((unsigned short *)icmp, sizeof(struct icmphdr) + packet_details->payload_size);\n\n  memset(&servaddr, 0, sizeof(struct sockaddr_in));\n  servaddr.sin_family = AF_INET;\n  servaddr.sin_addr.s_addr = dest_addr.s_addr;\n\n  // Sending the packet\n  sendto(sock_fd, packet, packet_size, 0, (struct sockaddr *)&servaddr, sizeof(struct sockaddr_in));\n\n  free(packet);\n}\n\n/**\n * Function to receive an ICMP packet\n */\nvoid receive_icmp_packet(int sock_fd, struct icmp_packet *packet_details)\n{\n  struct sockaddr_in src_addr;\n  //struct sockaddr_in dest_addr;\n\n  struct iphdr *ip;\n  struct icmphdr *icmp;\n  char *icmp_payload;\n\n  int packet_size;\n  char *packet;\n\n  socklen_t src_addr_size;\n  int enc_MTU; //encapsulated MTU\n\n  enc_MTU = MTU + sizeof(struct iphdr) + sizeof(struct icmphdr);\n\n  packet = calloc(enc_MTU, sizeof(uint8_t));\n  if (packet == NULL) {\n    perror(\"No memory available\\n\");\n    close_icmp_socket(sock_fd);\n    exit(-1);\n  }\n\n  src_addr_size = sizeof(struct sockaddr_in);\n  \n  // Receiving packet\n  packet_size = recvfrom(sock_fd, packet, enc_MTU, 0, (struct sockaddr *)&(src_addr), &src_addr_size);\n\n  ip = (struct iphdr *)packet;\n  icmp = (struct icmphdr *)(packet + sizeof(struct iphdr));\n  icmp_payload = (char *)(packet + sizeof(struct iphdr) + sizeof(struct icmphdr));\n\n  // Filling up packet_details\n  inet_ntop(AF_INET, &(ip->saddr), packet_details->src_addr, INET_ADDRSTRLEN);\n  inet_ntop(AF_INET, &(ip->daddr), packet_details->dest_addr, INET_ADDRSTRLEN);\n  packet_details->type = icmp->type;\n  packet_details->payload_size = packet_size - sizeof(struct iphdr) - sizeof(struct icmphdr);\n  packet_details->payload = calloc(packet_details->payload_size, sizeof(uint8_t));\n  if (packet_details->payload == NULL) {\n    perror(\"No memory available\\n\");\n    close_icmp_socket(sock_fd);\n    exit(-1);\n  }\n\n  memcpy(packet_details->payload, icmp_payload, packet_details->payload_size);\n\n  free(packet);\n}\n\n/**\n * Function to close the icmp socket\n */\nvoid close_icmp_socket(int sock_fd)\n{\n  close(sock_fd);\n}\n\n/**\n * Function to calculate checksum\n */\nuint16_t in_cksum(uint16_t *addr, int len)\n{\n  int nleft = len;\n  uint32_t sum = 0;\n  uint16_t *w = addr;\n  uint16_t answer = 0;\n\n  // Adding 16 bits sequentially in sum\n  while (nleft > 1) {\n    sum += *w;\n    nleft -= 2;\n    w++;\n  }\n\n  // If an odd byte is left\n  if (nleft == 1) {\n    *(unsigned char *) (&answer) = *(unsigned char *) w;\n    sum += answer;\n  }\n\n  sum = (sum >> 16) + (sum & 0xffff);\n  sum += (sum >> 16);\n  answer = ~sum;\n\n  return answer;\n}\n\n/**\n * Function to fill up common headers for IP and ICMP\n */\nvoid prepare_headers(struct iphdr *ip, struct icmphdr *icmp)\n{\n  ip->version = 4;\n  ip->ihl = 5;\n  ip->tos = 0;\n  ip->id = rand();\n  ip->frag_off = 0;\n  ip->ttl = 255;\n  ip->protocol = IPPROTO_ICMP;\n\n  icmp->code = 0;\n  icmp->un.echo.sequence = rand();\n  icmp->un.echo.id = rand();\n  icmp->checksum = 0;   \n}\n"
        },
        {
          "name": "icmp.h",
          "type": "blob",
          "size": 0.8818359375,
          "content": "/**\n *  icmp.h\n */\n \n#ifndef icmp_guard\n#define icmp_guard\n\n// Maximum transmission unit\n#define MTU 1472\n\nstruct icmp_packet\n{\n  char src_addr[100];\n  char dest_addr[100];\n  int type;\n  char *payload;\n  int payload_size;\n};\n\n/**\n * Function to set packet type as ECHO\n */\nvoid set_echo_type(struct icmp_packet *packet);\n\n/**\n * Function to set packet type as REPLY\n */\nvoid set_reply_type(struct icmp_packet *packet);\n\n/**\n * Function to open a socket for icmp\n */\nint open_icmp_socket();\n\n/**\n * Function to bind the socket to INADDR_ANY\n */\nvoid bind_icmp_socket(int sock_fd);\n\n/**\n * Function to send ICMP Packet\n */\nvoid send_icmp_packet(int sock_fd, struct icmp_packet *packet_details);\n\n/**\n * Function to receive ICMP Packet\n */\nvoid receive_icmp_packet(int sock_fd, struct icmp_packet *packet_details);\n\n/**\n * Function to close the icmp socket\n */\nvoid close_icmp_socket(int sock_fd);\n\n#endif\n"
        },
        {
          "name": "icmptunnel.c",
          "type": "blob",
          "size": 0.76171875,
          "content": "/**\n * icmp_tunnel.c\n */\n\n#include \"tunnel.h\"\n\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define ARG_SERVER_MODE \"-s\"\n#define ARG_CLIENT_MODE \"-c\"\n\nvoid usage()\n{\n  printf(\"Wrong argument\\n\");\n  fprintf(stdout, \"usage: icmptunnel [-s serverip] | [-c clientip]\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n  char ip_addr[100] = {0,};\n  if ((argc < 3) || ((strlen(argv[2]) + 1) > sizeof(ip_addr))) {\n    usage();\n    exit(EXIT_FAILURE);\n  }\n  memcpy(ip_addr, argv[2], strlen(argv[2]) + 1);\n\n  if (strncmp(argv[1], ARG_SERVER_MODE, strlen(argv[1])) == 0) {\n    run_tunnel(ip_addr, 1);\n  }\n  else if (strncmp(argv[1], ARG_CLIENT_MODE, strlen(argv[1])) == 0) {\n    run_tunnel(ip_addr, 0);\n  }\n  else {\n    usage();\n    exit(EXIT_FAILURE);\n  }\n\n  return EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "server.sh",
          "type": "blob",
          "size": 0.408203125,
          "content": "#!/bin/sh\n\n# Assigining an IP address and mask to 'tun0' interface\nifconfig tun0 mtu 1472 up 10.0.1.1 netmask 255.255.255.0 \n\n# Preventing the kernel to reply to any ICMP pings\necho 1 | dd of=/proc/sys/net/ipv4/icmp_echo_ignore_all\n\n# Enabling IP forwarding\necho 1 | dd of=/proc/sys/net/ipv4/ip_forward\n\n# Adding an iptables rule to masquerade for 10.0.0.0/8\niptables -t nat -A POSTROUTING -s 10.0.0.0/8 -j MASQUERADE\n"
        },
        {
          "name": "test_client.c",
          "type": "blob",
          "size": 0.4921875,
          "content": "#include \"icmp.h\"\n#include <string.h>\n\nint main()\n{\n  struct icmp_packet packet;\n  char *src_ip;\n  char *dest_ip;\n  int sock_fd;\n\n  src_ip = \"127.0.0.2\";\n  dest_ip = \"127.0.0.1\";\n\n  strncpy(packet.src_addr, src_ip, strlen(src_ip) + 1);\n  strncpy(packet.dest_addr, dest_ip, strlen(dest_ip) + 1);\n  set_reply_type(&packet);\n  packet.payload = \"ZZZZZZ\";\n  packet.payload_size = strlen(packet.payload);\n\n  sock_fd = open_icmp_socket();\n\n  send_icmp_packet(sock_fd, &packet);\n\n  close_icmp_socket(sock_fd);\n}\n"
        },
        {
          "name": "test_server.c",
          "type": "blob",
          "size": 0.4453125,
          "content": "#include \"icmp.h\"\n\n#include <stdio.h>\n#include <string.h>\n \n \nint main()\n{\n  struct icmp_packet packet;\n  int sock_fd;\n \n  sock_fd = open_icmp_socket();\n  bind_icmp_socket(sock_fd);\n\n  printf(\"server initialized\\n\");\n  while(1)\n  {\n    receive_icmp_packet(sock_fd, &packet);\n    printf(\"%s\\n\", packet.src_addr);\n    printf(\"%s\\n\", packet.dest_addr);\n    printf(\"%d\\n\", packet.type);\n    printf(\"%s\\n\", packet.payload);\n  }\n \n  close_icmp_socket(sock_fd);\n}"
        },
        {
          "name": "tunnel.c",
          "type": "blob",
          "size": 5.8017578125,
          "content": "/**\n *  tunnel.c\n */\n\n#include \"icmp.h\"\n#include \"tunnel.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <linux/if.h>\n#include <linux/if_tun.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n\n#define DEFAULT_ROUTE   \"0.0.0.0\"\n\n/**\n * Function to allocate a tunnel\n */\nint tun_alloc(char *dev, int flags)\n{\n  struct ifreq ifr;\n  int tun_fd, err;\n  char *clonedev = \"/dev/net/tun\";\n  printf(\"[DEBUG] Allocating tunnel\\n\");\n\n  tun_fd = open(clonedev, O_RDWR);\n\n  if(tun_fd == -1) {\n    perror(\"Unable to open clone device\\n\");\n    exit(EXIT_FAILURE);\n  }\n  \n  memset(&ifr, 0, sizeof(ifr));\n\n  ifr.ifr_flags = flags;\n\n  if (*dev) {\n    strncpy(ifr.ifr_name, dev, IFNAMSIZ);\n  }\n\n  if ((err=ioctl(tun_fd, TUNSETIFF, (void *)&ifr)) < 0) {\n    close(tun_fd);\n    fprintf(stderr, \"Error returned by ioctl(): %s\\n\", strerror(err));\n    perror(\"Error in tun_alloc()\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"[DEBUG] Allocatating tunnel2\");\n\n  printf(\"[DEBUG] Created tunnel %s\\n\", dev);\n\n  return tun_fd;\n}\n\n/**\n * Function to read from a tunnel\n */\nint tun_read(int tun_fd, char *buffer, int length)\n{\n  int bytes_read;\n  printf(\"[DEBUG] Reading from tunnel\\n\");\n  bytes_read = read(tun_fd, buffer, length);\n\n  if (bytes_read == -1) {\n    perror(\"Unable to read from tunnel\\n\");\n    exit(EXIT_FAILURE);\n  }\n  else {\n    return bytes_read;\n  }\n}\n\n/**\n * Function to write to a tunnel\n */\nint tun_write(int tun_fd, char *buffer, int length)\n{\n  int bytes_written;\n  printf(\"[DEBUG] Writing to tunnel\\n\");\n  bytes_written = write(tun_fd, buffer, length);\n\n  if (bytes_written == -1) {\n    perror(\"Unable to write to tunnel\\n\");\n    exit(EXIT_FAILURE);\n  }\n  else {\n    return bytes_written;\n  }\n}\n\n/**\n * Function to configure the network\n */\nvoid configure_network(int server)\n{\n  int pid, status;\n  char path[100];\n  char *const args[] = {path, NULL};\n\n  if (server) {\n    if (sizeof(SERVER_SCRIPT) > sizeof(path)){\n      perror(\"Server script path is too long\\n\");\n      exit(EXIT_FAILURE);\n    }\n    strncpy(path, SERVER_SCRIPT, strlen(SERVER_SCRIPT) + 1);\n  }\n  else {\n    if (sizeof(CLIENT_SCRIPT) > sizeof(path)){\n      perror(\"Client script path is too long\\n\");\n      exit(EXIT_FAILURE);\n    }\n    strncpy(path, CLIENT_SCRIPT, strlen(CLIENT_SCRIPT) + 1);\n  }\n\n  pid = fork();\n\n  if (pid == -1) {\n    perror(\"Unable to fork\\n\");\n    exit(EXIT_FAILURE);\n  }\n  \n  if (pid==0) {\n    // Child process, run the script\n    exit(execv(path, args));\n  }\n  else {\n    // Parent process\n    waitpid(pid, &status, 0);\n    if (WEXITSTATUS(status) == 0) {\n      // Script executed correctly\n      printf(\"[DEBUG] Script ran successfully\\n\");\n    }\n    else {\n      // Some error\n      printf(\"[DEBUG] Error in running script\\n\");\n    }\n  }\n}\n\n\n/**\n * Function to run the tunnel\n */\nvoid run_tunnel(char *dest, int server)\n{\n  struct icmp_packet packet;\n  int tun_fd, sock_fd;\n\n  fd_set fs;\n\n  tun_fd = tun_alloc(\"tun0\", IFF_TUN | IFF_NO_PI);\n\n  printf(\"[DEBUG] Starting tunnel - Dest: %s, Server: %d\\n\", dest, server);\n  printf(\"[DEBUG] Opening ICMP socket\\n\");\n  sock_fd = open_icmp_socket();\n\n  if (server) {\n    printf(\"[DEBUG] Binding ICMP socket\\n\");\n    bind_icmp_socket(sock_fd);\n  }\n\n  configure_network(server);\n\n  while (1) {\n    FD_ZERO(&fs);\n    FD_SET(tun_fd, &fs);\n    FD_SET(sock_fd, &fs);\n\n    select(tun_fd>sock_fd?tun_fd+1:sock_fd+1, &fs, NULL, NULL, NULL);\n\n    if (FD_ISSET(tun_fd, &fs)) {\n      printf(\"[DEBUG] Data needs to be readed from tun device\\n\");\n      // Reading data from tun device and sending ICMP packet\n\n      printf(\"[DEBUG] Preparing ICMP packet to be sent\\n\");\n      // Preparing ICMP packet to be sent\n      memset(&packet, 0, sizeof(struct icmp_packet));\n      printf(\"[DEBUG] Destination address: %s\\n\", dest);\n\n      if (sizeof(DEFAULT_ROUTE) > sizeof(packet.src_addr)){\n        perror(\"Lack of space: size of DEFAULT_ROUTE > size of src_addr\\n\");\n        close(tun_fd);\n        close(sock_fd);\n        exit(EXIT_FAILURE);\n      }\n      strncpy(packet.src_addr, DEFAULT_ROUTE, strlen(DEFAULT_ROUTE) + 1);\n\n      if ((strlen(dest) + 1) > sizeof(packet.dest_addr)){\n        perror(\"Lack of space for copy size of DEFAULT_ROUTE > size of dest_addr\\n\");\n        close(sock_fd);\n        exit(EXIT_FAILURE);\n      }\n      strncpy(packet.dest_addr, dest, strlen(dest) + 1);\n\n      if(server) {\n        set_reply_type(&packet);\n      }\n      else {\n        set_echo_type(&packet);\n      }\n      packet.payload = calloc(MTU, sizeof(uint8_t));\n      if (packet.payload == NULL){\n        perror(\"No memory available\\n\");\n        exit(EXIT_FAILURE);\n      }\n\n      packet.payload_size  = tun_read(tun_fd, packet.payload, MTU);\n      if(packet.payload_size  == -1) {\n        perror(\"Error while reading from tun device\\n\");\n        exit(EXIT_FAILURE);\n      }\n\n      printf(\"[DEBUG] Sending ICMP packet with payload_size: %d, payload: %s\\n\", packet.payload_size, packet.payload);\n      // Sending ICMP packet\n      send_icmp_packet(sock_fd, &packet);\n\n      free(packet.payload);\n    }\n\n    if (FD_ISSET(sock_fd, &fs)) {\n      printf(\"[DEBUG] Received ICMP packet\\n\");\n      // Reading data from remote socket and sending to tun device\n\n      // Getting ICMP packet\n      memset(&packet, 0, sizeof(struct icmp_packet));\n      receive_icmp_packet(sock_fd, &packet);\n\n      printf(\"[DEBUG] Read ICMP packet with src: %s, dest: %s, payload_size: %d, payload: %s\\n\", packet.src_addr, packet.dest_addr, packet.payload_size, packet.payload);\n      // Writing out to tun device\n      tun_write(tun_fd, packet.payload, packet.payload_size);\n\n      printf(\"[DEBUG] Src address being copied: %s\\n\", packet.src_addr);\n      strncpy(dest, packet.src_addr, strlen(packet.src_addr) + 1);\n      free(packet.payload);\n    }\n  }\n\n}\n"
        },
        {
          "name": "tunnel.h",
          "type": "blob",
          "size": 0.478515625,
          "content": "/**\n *  tunnel.h\n */\n\n#ifndef tunnel_gaurd\n#define tunnel_gaurd\n\n#define SERVER_SCRIPT \"server.sh\"\n#define CLIENT_SCRIPT \"client.sh\"\n\n/**\n * Function to allocate a tunnel\n */\nint tun_alloc(char *dev, int flags);\n\n/**\n * Function to read from a tunnel\n */\nint tun_read(int tun_fd, char *buffer, int length);\n\n/**\n * Function to write to a tunnel\n */\nint tun_write(int tun_fd, char *buffer, int length);\n\n/**\n * Function to run the tunnel\n */\nvoid run_tunnel(char *dest, int server);\n\n#endif\n"
        }
      ]
    }
  ]
}