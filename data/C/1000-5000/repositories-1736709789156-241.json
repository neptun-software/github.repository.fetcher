{
  "metadata": {
    "timestamp": 1736709789156,
    "page": 241,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "curl/trurl",
      "stars": 3204,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".checksrc",
          "type": "blob",
          "size": 0.017578125,
          "content": "disable FOPENMODE\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.591796875,
          "content": "# compiled program\n/trurl\n/trurl.1\n_trurl.zsh\n\n# Prerequisites\n*.d\n\n# Object files\n*.o\n*.ko\n*.obj\n*.elf\n\n# Linker output\n*.ilk\n*.map\n*.exp\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Libraries\n*.lib\n*.a\n*.la\n*.lo\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex\n\n# Debug files\n*.dSYM/\n*.su\n*.idb\n*.pdb\n\n# Kernel Module Compile Results\n*.mod*\n*.cmd\n.tmp_versions/\nmodules.order\nModule.symvers\nMkfile.old\ndkms.conf\n\n# Output files from msvc\nwinbuild/bin/\nwinbuild/obj/\n\n# Dependencies for msvc from vcpkg\nwinbuild/vcpkg_installed/\n\n# vim\n*.sw*\n"
        },
        {
          "name": ".reuse",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.9296875,
          "content": "# Contributing to trurl\nThis document is intended to provide a framework for contributing to trurl. This document will go over requesting new features, fixing existing bugs and effectively\nusing the internal tooling to help PRs merge quickly.\n\n## Opening an issue\ntrurl uses GitHubs issue tracking to track upcoming work. If you have a feature you want to add or find a bug simply open an issue in the\n[issues tab](https://github.com/curl/trurl/issues). Briefly describe the feature you are requesting and why you think it may be valuable for trurl. If you are\nreporting a bug be prepared for questions as we will want to reproduce it locally. In general providing the output of `trurl --version` along with the operating\nsystem / Distro you are running is a good starting point.\n\n## Writing a good PR\ntrurl is a relatively straightforward code base, so it is best to keep your PRs straightforward as well. Avoid trying to fix many bugs in one PR, and instead\nuse many smaller PRs as this avoids potential conflicts when merging. trurl is written in C and uses the [curl code style](https://curl.se/dev/code-style.html).\nPRs that do not follow to code style will not be merged in.\n\ntrurl is in its early stages, so it's important to open a PR against a recent version of the source code, as a lot can change over a few days.\nPreferably you would open a PR against the most recent commit in master.\n\nIf you are implementing a new feature, it must be submitted with tests and documentation. The process for writing tests is explained below in the tooling section. Documentation exists\nin two locations, the man page ([trurl.1](https://github.com/curl/trurl/blob/master/trurl.1)) and the help prompt when running `trurl -h`. Most documentation changes\nwill go in the man page, but if you add a new command line argument then it must be documented in the help page.\n\nIt is also important to be prepared for feedback on your PR and adjust it promptly.\n\n\n## Tooling\nThe trurl repository has a few small helper tools to make development easier.\n\n**checksrc.pl** is used to ensure the code style is correct. It accepts C files as command line arguments, and returns nothing if the code style is valid. If the\ncode style is incorrect, checksrc.pl will provide the line the error is on and a brief description of what is wrong. You may run `make checksrc` to scan the entire\nrepository for style compliance.\n\n**test.py** is used to run automated tests for trurl. It loads in tests from `test.json` (described below) and reports the number of tests passed. You may specify\nthe tests to run by passing a list of comma-separated numbers as command line arguments, such as `4,8,15,16,23,42` Note there is no space between the numbers. `test.py`\nmay also use valgrind to test for memory errors by passing `--with-valgrind` as a command line argument, it should be noted that this may take a while to run all the tests.\n`test.py` will also skip tests that require a specific curl runtime or buildtime.\n\n### Adding tests\nTests are located in [tests.json](https://github.com/curl/trurl/blob/master/tests.json). This file is an array of json objects when outline an input and what the expected\noutput should be. Below is a simple example of a single test:\n```json\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    }\n  ```\n  `\"arguments\"` is an array of the arguments to run in the test, so if you wanted to pass multiple arguments it would look something like:\n  ```json\n     {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se:22/\",\n                \"-s\",\n                \"port=443\",\n                \"--get\",\n                \"{url}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    }\n```\ntrurl may also return json. It you are adding a test that returns json to stdout, write the json directly instead of a string in the examples above. Below is an example\nof what stdout should be if it is a json test, where `\"input\"` is what trurl accepts from the command line and `\"expected\"` is what trurl should return.\n```json\n\"expected\": {\n    \"stdout\": [\n        {\n          \"url\": \"https://curl.se/\",\n          \"scheme\": \"https\",\n          \"host\": \"curl.se\",\n          \"port\": \"443\",\n          \"raw_port\": \"\",\n          \"path\": \"/\",\n          \"query\": \"\",\n          \"params\": []\n        }\n    ],\n    \"returncode\": 0,\n    \"stderr\": \"\"\n}\n```\n\n# Tips to make opening a PR easier\n- Run `make checksrc` and `make test-memory` locally before opening a PR. These ran automatically when a PR is opened so you might as well make sure they pass before-hand.\n- Update the man page and the help prompt accordingly. Documentation is annoying but if everyone writes a little it's not bad.\n- Add tests to cover new features or the bug you fixed.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0625,
          "content": "COPYRIGHT AND PERMISSION NOTICE\n\nCopyright (c) 2023 - 2024, Daniel Stenberg, <daniel@haxx.se>, and many\ncontributors, see the THANKS file.\n\nAll rights reserved.\n\nPermission to use, copy, modify, and distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright\nnotice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\nOR OTHER DEALINGS IN THE SOFTWARE.\n\nExcept as contained in this notice, the name of a copyright holder shall not\nbe used in advertising or otherwise to promote the sale, use or other dealings\nin this Software without prior written authorization of the copyright holder.\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.3525390625,
          "content": "##########################################################################\n#                                  _   _ ____  _\n#  Project                     ___| | | |  _ \\| |\n#                             / __| | | | |_) | |\n#                            | (__| |_| |  _ <| |___\n#                             \\___|\\___/|_| \\_\\_____|\n#\n# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n#\n# This software is licensed as described in the file COPYING, which\n# you should have received as part of this distribution. The terms\n# are also available at https://curl.se/docs/copyright.html.\n#\n# You may opt to use, copy, modify, merge, publish, distribute and/or sell\n# copies of the Software, and permit persons to whom the Software is\n# furnished to do so, under the terms of the COPYING file.\n#\n# This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n# KIND, either express or implied.\n#\n# SPDX-License-Identifier: curl\n#\n##########################################################################\n\nTARGET = trurl\nOBJS = trurl.o\nifndef TRURL_IGNORE_CURL_CONFIG\nLDLIBS += $$(curl-config --libs)\nCFLAGS += $$(curl-config --cflags)\nendif\nCFLAGS += -W -Wall -Wshadow -pedantic\nCFLAGS += -Wconversion -Wmissing-prototypes -Wwrite-strings -Wsign-compare -Wno-sign-conversion\nifndef NDEBUG\nCFLAGS += -Werror -g\nendif\nMANUAL = trurl.1\n\nPREFIX ?= /usr/local\nBINDIR ?= $(PREFIX)/bin\nMANDIR ?= $(PREFIX)/share/man/man1\nZSH_COMPLETIONSDIR ?= $(PREFIX)/share/zsh/site-functions\nCOMPLETION_FILES=completions/_trurl.zsh\n\nINSTALL ?= install\nPYTHON3 ?= python3\n\n$(TARGET): $(OBJS)\n\t$(CC) $(LDFLAGS) $(OBJS) -o $(TARGET) $(LDLIBS)\n\ntrurl.o: trurl.c version.h\n\n.PHONY: install\ninstall:\n\t$(INSTALL) -d $(DESTDIR)$(BINDIR)\n\t$(INSTALL) -m 0755 $(TARGET) $(DESTDIR)$(BINDIR)\n\t$(INSTALL) -d $(DESTDIR)$(MANDIR)\n\t(if test -f $(MANUAL); then \\\n\t$(INSTALL) -m 0644 $(MANUAL) $(DESTDIR)$(MANDIR); \\\n\tfi)\n\t(if test -f $(COMPLETION_FILES); then \\\n\t$(INSTALL) -d $(DESTDIR)$(ZSH_COMPLETIONSDIR); \\\n\t$(INSTALL) -m 0755 $(COMPLETION_FILES) $(ZSH_COMPLETIONSDIR)/_trurl; \\\n\tfi)\n\n.PHONY: clean\nclean:\n\trm -f $(OBJS) $(TARGET) $(COMPLETION_FILES)\n\n.PHONY: test\ntest: $(TARGET)\n\t@$(PYTHON3) test.py\n\n.PHONY: test-memory\ntest-memory: $(TARGET)\n\t@$(PYTHON3) test.py --with-valgrind\n\n.PHONY: checksrc\nchecksrc:\n\t./checksrc.pl trurl.c version.h\n\n.PHONY: completions\ncompletions: trurl.md\n\t./completions/generate_completions.sh $^\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.4443359375,
          "content": "\n# [![trurl logo](https://curl.se/logo/trurl-logo.svg)](https://curl.se/trurl)\n\n# trurl\n\nCommand line tool for URL parsing and manipulation\n\n[Video presentation](https://youtu.be/oDL7DVszr2w)\n\n## Examples\n\n**Replace the hostname of a URL:**\n\n```text\n$ trurl --url https://curl.se --set host=example.com\nhttps://example.com/\n```\n\n**Create a URL by setting components:**\n\n```text\n$ trurl --set host=example.com --set scheme=ftp\nftp://example.com/\n```\n\n**Redirect a URL:**\n\n```text\n$ trurl --url https://curl.se/we/are.html --redirect here.html\nhttps://curl.se/we/here.html\n```\n\n**Change port number:**\n\n```text\n$ trurl --url https://curl.se/we/../are.html --set port=8080\nhttps://curl.se:8080/are.html\n```\n\n**Extract the path from a URL:**\n\n```text\n$ trurl --url https://curl.se/we/are.html --get '{path}'\n/we/are.html\n```\n\n**Extract the port from a URL:**\n\n```text\n$ trurl --url https://curl.se/we/are.html --get '{port}'\n443\n```\n\n**Append a path segment to a URL:**\n\n```text\n$ trurl --url https://curl.se/hello --append path=you\nhttps://curl.se/hello/you\n```\n\n**Append a query segment to a URL:**\n\n```text\n$ trurl --url \"https://curl.se?name=hello\" --append query=search=string\nhttps://curl.se/?name=hello&search=string\n```\n\n**Read URLs from stdin:**\n\n```text\n$ cat urllist.txt | trurl --url-file -\n...\n```\n\n**Output JSON:**\n\n```text\n$ trurl \"https://fake.host/hello#frag\" --set user=::moo:: --json\n[\n  {\n    \"url\": \"https://%3a%3amoo%3a%3a@fake.host/hello#frag\",\n    \"parts\": {\n      \"scheme\": \"https\",\n      \"user\": \"::moo::\",\n      \"host\": \"fake.host\",\n      \"path\": \"/hello\",\n      \"fragment\": \"frag\"\n    }\n  }\n]\n```\n\n**Remove tracking tuples from query:**\n\n```text\n$ trurl \"https://curl.se?search=hey&utm_source=tracker\" --qtrim \"utm_*\"\nhttps://curl.se/?search=hey\n```\n\n**Show a specific query key value:**\n\n```text\n$ trurl \"https://example.com?a=home&here=now&thisthen\" -g '{query:a}'\nhome\n```\n\n**Sort the key/value pairs in the query component:**\n\n```text\n$ trurl \"https://example.com?b=a&c=b&a=c\" --sort-query\nhttps://example.com?a=c&b=a&c=b\n```\n\n**Work with a query that uses a semicolon separator:**\n\n```text\n$ trurl \"https://curl.se?search=fool;page=5\" --qtrim \"search\" --query-separator \";\"\nhttps://curl.se?page=5\n```\n\n**Accept spaces in the URL path:**\n\n```text\n$ trurl \"https://curl.se/this has space/index.html\" --accept-space\nhttps://curl.se/this%20has%20space/index.html\n```\n\n## Install\n\n### Linux\n\nIt is quite easy to compile the C source with GCC:\n\n```text\n$ make\ncc  -W -Wall -pedantic -g   -c -o trurl.o trurl.c\ncc   trurl.o  -lcurl -o trurl\n```\n\ntrurl is also available in [some package managers](https://github.com/curl/trurl/wiki/Get-trurl-for-your-OS). If it is not listed you can try searching for it using the package manager of your preferred distribution.\n\n### Windows\n\n1. Download and run [Cygwin installer.](https://www.cygwin.com/install.html)\n2. Follow the instructions provided by the installer. When prompted to select packages, make sure to choose the following: curl, libcurl-devel, libcurl4, make and gcc-core.\n3. (optional) Add the Cygwin bin directory to your system PATH variable.\n4. Use `make`, just like on Linux.\n\n## Prerequisites\n\nDevelopment files of libcurl (e.g. `libcurl4-openssl-dev` or\n`libcurl4-gnutls-dev`) are needed for compilation. Requires libcurl version\n7.62.0 or newer (the first libcurl to ship the URL parsing API).\n\ntrurl also uses `CURLUPART_ZONEID` added in libcurl 7.81.0 and\n`curl_url_strerror()` added in libcurl 7.80.0\n\nIt would certainly be possible to make trurl work with older libcurl versions\nif someone wanted to.\n\n### Older libcurls\n\ntrurl builds with libcurl older than 7.81.0 but will then not work as\ngood. For all the documented goodness, use a more modern libcurl.\n\n### trurl / libcurl Compatibility\n\n| trurl Feature   |  Minimum libcurl Version |\n|-----------------|--------------------------|\n| imap-options    |   7.30.0                 |\n| normalize-ipv   |   7.77.0                 | \n| white-space     |   7.78.0                 |\n| url-strerror    |   7.80.0                 |\n| zone-id         |   7.81.0                 |\n| punycode        |   7.88.0                 |\n| punycode2idn    |   8.3.0                  |\n| no-guess-scheme |   8.9.0                  |\n\nFor more details on how trurl will behave if these features are missing see [URL Quirks](https://github.com/curl/trurl/blob/master/URL-QUIRKS.md).\nTo see the features your version of trurl supports as well as the version of libcurl it is built with, run the following command:  `trurl --version`\n\n"
        },
        {
          "name": "RELEASE-NOTES",
          "type": "blob",
          "size": 0.41015625,
          "content": "# trurl 0.16\n\n## News\n\n- introduce --qtrim for trimming queries (only)\n- Lots of new tests\n- Expanded documentation \n\n## Bugfixes\n\n- normalize the fragment\n- make sure URL encoded %-hex is done lowercase\n- silence --replace-append when appending\n- normalize user, password and options\n- clarify the --help text for --urlencode\n- fix a few returns codes for out of memory\n\nContributors to this release:\n\n Daniel Stenberg\n"
        },
        {
          "name": "RELEASE-PROCEDURE.md",
          "type": "blob",
          "size": 0.609375,
          "content": "trurl release procedure - how to do a release\n==============================================\n\nin the source code repo\n-----------------------\n\n- edit `RELEASE-NOTES` to be accurate\n\n- run `./mkrelease [version]`\n\n- make sure all relevant changes are committed on the master branch\n\n- tag the git repo in this style: `git tag -a trurl-[version]` -a annotates\n  the tag\n\n- push the git commits and the new tag\n\n- Go to https://github.com/curl/trurl/tags and edit the tag as a release\n  Consider allowing it to make a discussion post about it.\n\ncelebrate\n---------\n\n- suitable beverage intake is encouraged for the festivities\n"
        },
        {
          "name": "THANKS",
          "type": "blob",
          "size": 0.5126953125,
          "content": "This project exists only thanks to the awesome people who make it happen. The\nfollowing friends have contributed:\n\nDan Fandrich\nDaniel Gustafsson\nDaniel Stenberg\nEhsan\nEmanuele Torre\nEnno Tensing\nGustavo Costa\nHåvard Bønes\nJacob Mealey\nJay Satiro\nJeremy Lecour\nKrishean Draconis\nLuca Barbato\nma\nMarian Posaceanu\nMartin Hauke\nMichael Ablassmeier\nMichael Lass\nNekobit\nNicolas CARPi\nOlaf Alders\nPascal Knecht\nPaul Roub\nPaul Wise\nRenato Botelho\nRuoyu Zhong\nSajad F. Maghrebi\nSevan Janiyan\nViktor Szakats\n積丹尼 Dan Jacobson\n"
        },
        {
          "name": "URL-QUIRKS.md",
          "type": "blob",
          "size": 1.8154296875,
          "content": "# URL Quirks\n\nThis is a collection of peculiarities you may find in trurl due to bugs or\nchanges/improvements in libcurl's URL handling.\n\n## The URL API\n\nWas introduced in libcurl 7.62.0. No older libcurl versions can be used.\n\nBuild-time requirement.\n\n## Extracting zone id\n\nAdded in libcurl 7.65.0. The `CURLUE_NO_ZONEID` error code was added in\n7.81.0.\n\nBuild-time requirement.\n\n## Normalizing IPv4 addresses\n\nAdded in libcurl 7.77.0. Before that, the source formatting was kept.\n\nRun-time requirement.\n\n## Allow space\n\nThe libcurl URL parser was given the ability to allow spaces in libcurl\n7.78.0. trurl therefore cannot offer this feature with older libcurl versions.\n\nBuild-time requirement.\n\n## `curl_url_strerror()`\n\nThis API call was added in 7.80.0, using a libcurl version older than this\nwill make trurl output less good error messages.\n\nBuild-time requirement.\n\n## Normalizing IPv6 addresses\n\nImplemented in libcurl 7.81.0. Before this, the source formatting was kept.\n\nRun-time requirement.\n\n## `CURLU_PUNYCODE`\n\nAdded in libcurl 7.88.0.\n\nBuild-time requirement.\n\n## Accepting % in host names\n\nThe host name parser has been made stricter over time, with the most recent\nenhancement merged for libcurl 8.0.0.\n\nRun-time requirement.\n\n## Parsing IPv6 literals when libcurl does not support IPv6\n\nBefore libcurl 8.0.0 the URL parser was not able to parse IPv6 addresses if\nlibcurl itself was built without IPv6 capabilities.\n\nRun-time requirement.\n\n## URL encoding of fragments\n\nThis was a libcurl bug, fixed in libcurl 8.1.0\n\nRun-time requirement.\n\n## Bad IPv4 numerical address\n\nThe normalization of IPv4 addresses would just ignore bad addresses, while\nnewer libcurl versions will reject host names using invalid IPv4 addresses.\nFixed in 8.1.0\n\nRun-time requirement.\n\n## Set illegal scheme\n\nPermitted before libcurl 8.1.0\n\nRun-time requirement.\n"
        },
        {
          "name": "checksrc.pl",
          "type": "blob",
          "size": 31.787109375,
          "content": "#!/usr/bin/env perl\n#***************************************************************************\n#                                  _   _ ____  _\n#  Project                     ___| | | |  _ \\| |\n#                             / __| | | | |_) | |\n#                            | (__| |_| |  _ <| |___\n#                             \\___|\\___/|_| \\_\\_____|\n#\n# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n#\n# This software is licensed as described in the file COPYING, which\n# you should have received as part of this distribution. The terms\n# are also available at https://curl.se/docs/copyright.html.\n#\n# You may opt to use, copy, modify, merge, publish, distribute and/or sell\n# copies of the Software, and permit persons to whom the Software is\n# furnished to do so, under the terms of the COPYING file.\n#\n# This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n# KIND, either express or implied.\n#\n# SPDX-License-Identifier: curl\n#\n###########################################################################\n\nuse strict;\nuse warnings;\n\nmy $max_column = 79;\nmy $indent = 2;\n\nmy $warnings = 0;\nmy $swarnings = 0;\nmy $errors = 0;\nmy $serrors = 0;\nmy $suppressed; # skipped problems\nmy $file;\nmy $dir=\".\";\nmy $wlist=\"\";\nmy @alist;\nmy $windows_os = $^O eq 'MSWin32' || $^O eq 'cygwin' || $^O eq 'msys';\nmy $verbose;\nmy %skiplist;\n\nmy %ignore;\nmy %ignore_set;\nmy %ignore_used;\nmy @ignore_line;\n\nmy %warnings_extended = (\n    'COPYRIGHTYEAR'    => 'copyright year incorrect',\n    'STRERROR',        => 'strerror() detected',\n    );\n\nmy %warnings = (\n    'ASSIGNWITHINCONDITION' => 'assignment within conditional expression',\n    'ASTERISKNOSPACE'  => 'pointer declared without space before asterisk',\n    'ASTERISKSPACE'    => 'pointer declared with space after asterisk',\n    'BADCOMMAND'       => 'bad !checksrc! instruction',\n    'BANNEDFUNC'       => 'a banned function was used',\n    'BRACEELSE'        => '} else on the same line',\n    'BRACEPOS'         => 'wrong position for an open brace',\n    'BRACEWHILE'       => 'A single space between open brace and while',\n    'COMMANOSPACE'     => 'comma without following space',\n    'COMMENTNOSPACEEND' => 'no space before */',\n    'COMMENTNOSPACESTART' => 'no space following /*',\n    'COPYRIGHT'        => 'file missing a copyright statement',\n    'CPPCOMMENTS'      => '// comment detected',\n    'DOBRACE'          => 'A single space between do and open brace',\n    'EMPTYLINEBRACE'   => 'Empty line before the open brace',\n    'EQUALSNOSPACE'    => 'equals sign without following space',\n    'EQUALSNULL'       => 'if/while comparison with == NULL',\n    'EXCLAMATIONSPACE' => 'Whitespace after exclamation mark in expression',\n    'FOPENMODE'        => 'fopen needs a macro for the mode string',\n    'INCLUDEDUP',      => 'same file is included again',\n    'INDENTATION'      => 'wrong start column for code',\n    'LONGLINE'         => \"Line longer than $max_column\",\n    'MULTISPACE'       => 'multiple spaces used when not suitable',\n    'NOSPACEEQUALS'    => 'equals sign without preceding space',\n    'NOTEQUALSZERO',   => 'if/while comparison with != 0',\n    'ONELINECONDITION' => 'conditional block on the same line as the if()',\n    'OPENCOMMENT'      => 'file ended with a /* comment still \"open\"',\n    'PARENBRACE'       => '){ without sufficient space',\n    'RETURNNOSPACE'    => 'return without space',\n    'SEMINOSPACE'      => 'semicolon without following space',\n    'SIZEOFNOPAREN'    => 'use of sizeof without parentheses',\n    'SNPRINTF'         => 'use of snprintf',\n    'SPACEAFTERPAREN'  => 'space after open parenthesis',\n    'SPACEBEFORECLOSE' => 'space before a close parenthesis',\n    'SPACEBEFORECOMMA' => 'space before a comma',\n    'SPACEBEFOREPAREN' => 'space before an open parenthesis',\n    'SPACESEMICOLON'   => 'space before semicolon',\n    'SPACESWITCHCOLON' => 'space before colon of switch label',\n    'TABS'             => 'TAB characters not allowed',\n    'TRAILINGSPACE'    => 'Trailing whitespace on the line',\n    'TYPEDEFSTRUCT'    => 'typedefed struct',\n    'UNUSEDIGNORE'     => 'a warning ignore was not used',\n    );\n\nsub readskiplist {\n    open(my $W, '<', \"$dir/checksrc.skip\") or return;\n    my @all=<$W>;\n    for(@all) {\n        $windows_os ? $_ =~ s/\\r?\\n$// : chomp;\n        $skiplist{$_}=1;\n    }\n    close($W);\n}\n\n# Reads the .checksrc in $dir for any extended warnings to enable locally.\n# Currently there is no support for disabling warnings from the standard set,\n# and since that's already handled via !checksrc! commands there is probably\n# little use to add it.\nsub readlocalfile {\n    my $i = 0;\n\n    open(my $rcfile, \"<\", \"$dir/.checksrc\") or return;\n\n    while(<$rcfile>) {\n        $i++;\n\n        # Lines starting with '#' are considered comments\n        if (/^\\s*(#.*)/) {\n            next;\n        }\n        elsif (/^\\s*enable ([A-Z]+)$/) {\n            if(!defined($warnings_extended{$1})) {\n                print STDERR \"invalid warning specified in .checksrc: \\\"$1\\\"\\n\";\n                next;\n            }\n            $warnings{$1} = $warnings_extended{$1};\n        }\n        elsif (/^\\s*disable ([A-Z]+)$/) {\n            if(!defined($warnings{$1})) {\n                print STDERR \"invalid warning specified in .checksrc: \\\"$1\\\"\\n\";\n                next;\n            }\n            # Accept-list\n            push @alist, $1;\n        }\n        else {\n            die \"Invalid format in $dir/.checksrc on line $i\\n\";\n        }\n    }\n    close($rcfile);\n}\n\nsub checkwarn {\n    my ($name, $num, $col, $file, $line, $msg, $error) = @_;\n\n    my $w=$error?\"error\":\"warning\";\n    my $nowarn=0;\n\n    #if(!$warnings{$name}) {\n    #    print STDERR \"Dev! there's no description for $name!\\n\";\n    #}\n\n    # checksrc.skip\n    if($skiplist{$line}) {\n        $nowarn = 1;\n    }\n    # !checksrc! controlled\n    elsif($ignore{$name}) {\n        $ignore{$name}--;\n        $ignore_used{$name}++;\n        $nowarn = 1;\n        if(!$ignore{$name}) {\n            # reached zero, enable again\n            enable_warn($name, $num, $file, $line);\n        }\n    }\n\n    if($nowarn) {\n        $suppressed++;\n        if($w) {\n            $swarnings++;\n        }\n        else {\n            $serrors++;\n        }\n        return;\n    }\n\n    if($w) {\n        $warnings++;\n    }\n    else {\n        $errors++;\n    }\n\n    $col++;\n    print \"$file:$num:$col: $w: $msg ($name)\\n\";\n    print \" $line\\n\";\n\n    if($col < 80) {\n        my $pref = (' ' x $col);\n        print \"${pref}^\\n\";\n    }\n}\n\n$file = shift @ARGV;\n\nwhile(defined $file) {\n\n    if($file =~ /-D(.*)/) {\n        $dir = $1;\n        $file = shift @ARGV;\n        next;\n    }\n    elsif($file =~ /-W(.*)/) {\n        $wlist .= \" $1 \";\n        $file = shift @ARGV;\n        next;\n    }\n    elsif($file =~ /-A(.+)/) {\n        push @alist, $1;\n        $file = shift @ARGV;\n        next;\n    }\n    elsif($file =~ /-i([1-9])/) {\n        $indent = $1 + 0;\n        $file = shift @ARGV;\n        next;\n    }\n    elsif($file =~ /-m([0-9]+)/) {\n        $max_column = $1 + 0;\n        $file = shift @ARGV;\n        next;\n    }\n    elsif($file =~ /^(-h|--help)/) {\n        undef $file;\n        last;\n    }\n\n    last;\n}\n\nif(!$file) {\n    print \"checksrc.pl [option] <file1> [file2] ...\\n\";\n    print \" Options:\\n\";\n    print \"  -A[rule]  Accept this violation, can be used multiple times\\n\";\n    print \"  -D[DIR]   Directory to prepend file names\\n\";\n    print \"  -h        Show help output\\n\";\n    print \"  -W[file]  Skip the given file - ignore all its flaws\\n\";\n    print \"  -i<n>     Indent spaces. Default: 2\\n\";\n    print \"  -m<n>     Maximum line length. Default: 79\\n\";\n    print \"\\nDetects and warns for these problems:\\n\";\n    my @allw = keys %warnings;\n    push @allw, keys %warnings_extended;\n    for my $w (sort @allw) {\n        if($warnings{$w}) {\n            printf (\" %-18s: %s\\n\", $w, $warnings{$w});\n        }\n        else {\n            printf (\" %-18s: %s[*]\\n\", $w, $warnings_extended{$w});\n        }\n    }\n    print \" [*] = disabled by default\\n\";\n    exit;\n}\n\nreadskiplist();\nreadlocalfile();\n\ndo {\n    if(\"$wlist\" !~ / $file /) {\n        my $fullname = $file;\n        $fullname = \"$dir/$file\" if ($fullname !~ '^\\.?\\.?/');\n        scanfile($fullname);\n    }\n    $file = shift @ARGV;\n\n} while($file);\n\nsub accept_violations {\n    for my $r (@alist) {\n        if(!$warnings{$r}) {\n            print \"'$r' is not a warning to accept!\\n\";\n            exit;\n        }\n        $ignore{$r}=999999;\n        $ignore_used{$r}=0;\n    }\n}\n\nsub checksrc_clear {\n    undef %ignore;\n    undef %ignore_set;\n    undef @ignore_line;\n}\n\nsub checksrc_endoffile {\n    my ($file) = @_;\n    for(keys %ignore_set) {\n        if($ignore_set{$_} && !$ignore_used{$_}) {\n            checkwarn(\"UNUSEDIGNORE\", $ignore_set{$_},\n                      length($_)+11, $file,\n                      $ignore_line[$ignore_set{$_}],\n                      \"Unused ignore: $_\");\n        }\n    }\n}\n\nsub enable_warn {\n    my ($what, $line, $file, $l) = @_;\n\n    # switch it back on, but warn if not triggered!\n    if(!$ignore_used{$what}) {\n        checkwarn(\"UNUSEDIGNORE\",\n                  $line, length($what) + 11, $file, $l,\n                  \"No warning was inhibited!\");\n    }\n    $ignore_set{$what}=0;\n    $ignore_used{$what}=0;\n    $ignore{$what}=0;\n}\nsub checksrc {\n    my ($cmd, $line, $file, $l) = @_;\n    if($cmd =~ / *([^ ]*) *(.*)/) {\n        my ($enable, $what) = ($1, $2);\n        $what =~ s: *\\*/$::; # cut off end of C comment\n        # print \"ENABLE $enable WHAT $what\\n\";\n        if($enable eq \"disable\") {\n            my ($warn, $scope)=($1, $2);\n            if($what =~ /([^ ]*) +(.*)/) {\n                ($warn, $scope)=($1, $2);\n            }\n            else {\n                $warn = $what;\n                $scope = 1;\n            }\n            # print \"IGNORE $warn for SCOPE $scope\\n\";\n            if($scope eq \"all\") {\n                $scope=999999;\n            }\n\n            # Comparing for a literal zero rather than the scalar value zero\n            # covers the case where $scope contains the ending '*' from the\n            # comment. If we use a scalar comparison (==) we induce warnings\n            # on non-scalar contents.\n            if($scope eq \"0\") {\n                checkwarn(\"BADCOMMAND\",\n                          $line, 0, $file, $l,\n                          \"Disable zero not supported, did you mean to enable?\");\n            }\n            elsif($ignore_set{$warn}) {\n                checkwarn(\"BADCOMMAND\",\n                          $line, 0, $file, $l,\n                          \"$warn already disabled from line $ignore_set{$warn}\");\n            }\n            else {\n                $ignore{$warn}=$scope;\n                $ignore_set{$warn}=$line;\n                $ignore_line[$line]=$l;\n            }\n        }\n        elsif($enable eq \"enable\") {\n            enable_warn($what, $line, $file, $l);\n        }\n        else {\n            checkwarn(\"BADCOMMAND\",\n                      $line, 0, $file, $l,\n                      \"Illegal !checksrc! command\");\n        }\n    }\n}\n\nsub nostrings {\n    my ($str) = @_;\n    $str =~ s/\\\".*\\\"//g;\n    return $str;\n}\n\nsub scanfile {\n    my ($file) = @_;\n\n    my $line = 1;\n    my $prevl=\"\";\n    my $prevpl=\"\";\n    my $l = \"\";\n    my $prep = 0;\n    my $prevp = 0;\n    open(my $R, '<', $file) || die \"failed to open $file\";\n\n    my $incomment=0;\n    my @copyright=();\n    my %includes;\n    checksrc_clear(); # for file based ignores\n    accept_violations();\n\n    while(<$R>) {\n        $windows_os ? $_ =~ s/\\r?\\n$// : chomp;\n        my $l = $_;\n        my $ol = $l; # keep the unmodified line for error reporting\n        my $column = 0;\n\n        # check for !checksrc! commands\n        if($l =~ /\\!checksrc\\! (.*)/) {\n            my $cmd = $1;\n            checksrc($cmd, $line, $file, $l)\n        }\n\n        # check for a copyright statement and save the years\n        if($l =~ /\\* +copyright .* (\\d\\d\\d\\d|)/i) {\n            my $count = 0;\n            while($l =~ /([\\d]{4})/g) {\n                push @copyright, {\n                  year => $1,\n                  line => $line,\n                  col => index($l, $1),\n                  code => $l\n                };\n                $count++;\n            }\n            if(!$count) {\n                # year-less\n                push @copyright, {\n                    year => -1,\n                    line => $line,\n                    col => index($l, $1),\n                    code => $l\n                };\n            }\n        }\n\n        # detect long lines\n        if(length($l) > $max_column) {\n            checkwarn(\"LONGLINE\", $line, length($l), $file, $l,\n                      \"Longer than $max_column columns\");\n        }\n        # detect TAB characters\n        if($l =~ /^(.*)\\t/) {\n            checkwarn(\"TABS\",\n                      $line, length($1), $file, $l, \"Contains TAB character\", 1);\n        }\n        # detect trailing whitespace\n        if($l =~ /^(.*)[ \\t]+\\z/) {\n            checkwarn(\"TRAILINGSPACE\",\n                      $line, length($1), $file, $l, \"Trailing whitespace\");\n        }\n\n        # no space after comment start\n        if($l =~ /^(.*)\\/\\*\\w/) {\n            checkwarn(\"COMMENTNOSPACESTART\",\n                      $line, length($1) + 2, $file, $l,\n                      \"Missing space after comment start\");\n        }\n        # no space at comment end\n        if($l =~ /^(.*)\\w\\*\\//) {\n            checkwarn(\"COMMENTNOSPACEEND\",\n                      $line, length($1) + 1, $file, $l,\n                      \"Missing space end comment end\");\n        }\n        # ------------------------------------------------------------\n        # Above this marker, the checks were done on lines *including*\n        # comments\n        # ------------------------------------------------------------\n\n        # strip off C89 comments\n\n      comment:\n        if(!$incomment) {\n            if($l =~ s/\\/\\*.*\\*\\// /g) {\n                # full /* comments */ were removed!\n            }\n            if($l =~ s/\\/\\*.*//) {\n                # start of /* comment was removed\n                $incomment = 1;\n            }\n        }\n        else {\n            if($l =~ s/.*\\*\\///) {\n                # end of comment */ was removed\n                $incomment = 0;\n                goto comment;\n            }\n            else {\n                # still within a comment\n                $l=\"\";\n            }\n        }\n\n        # ------------------------------------------------------------\n        # Below this marker, the checks were done on lines *without*\n        # comments\n        # ------------------------------------------------------------\n\n        # prev line was a preprocessor **and** ended with a backslash\n        if($prep && ($prevpl =~ /\\\\ *\\z/)) {\n            # this is still a preprocessor line\n            $prep = 1;\n            goto preproc;\n        }\n        $prep = 0;\n\n        # crude attempt to detect // comments without too many false\n        # positives\n        if($l =~ /^(([^\"\\*]*)[^:\"]|)\\/\\//) {\n            checkwarn(\"CPPCOMMENTS\",\n                      $line, length($1), $file, $l, \"\\/\\/ comment\");\n        }\n\n        if($l =~ /^(\\#\\s*include\\s+)([\\\">].*[>}\"])/) {\n            my ($pre, $path) = ($1, $2);\n            if($includes{$path}) {\n                checkwarn(\"INCLUDEDUP\",\n                          $line, length($1), $file, $l, \"duplicated include\");\n            }\n            $includes{$path} = $l;\n        }\n\n        # detect and strip preprocessor directives\n        if($l =~ /^[ \\t]*\\#/) {\n            # preprocessor line\n            $prep = 1;\n            goto preproc;\n        }\n\n        my $nostr = nostrings($l);\n        # check spaces after for/if/while/function call\n        if($nostr =~ /^(.*)(for|if|while|switch| ([a-zA-Z0-9_]+)) \\((.)/) {\n            my ($leading, $word, $extra, $first)=($1,$2,$3,$4);\n            if($1 =~ / *\\#/) {\n                # this is a #if, treat it differently\n            }\n            elsif(defined $3 && $3 eq \"return\") {\n                # return must have a space\n            }\n            elsif(defined $3 && $3 eq \"case\") {\n                # case must have a space\n            }\n            elsif(($first eq \"*\") && ($word !~ /(for|if|while|switch)/)) {\n                # A \"(*\" beginning makes the space OK because it wants to\n                # allow function pointer declared\n            }\n            elsif($1 =~ / *typedef/) {\n                # typedefs can use space-paren\n            }\n            else {\n                checkwarn(\"SPACEBEFOREPAREN\", $line, length($leading)+length($word), $file, $l,\n                          \"$word with space\");\n            }\n        }\n        # check for '== NULL' in if/while conditions but not if the thing on\n        # the left of it is a function call\n        if($nostr =~ /^(.*)(if|while)(\\(.*?)([!=]= NULL|NULL [!=]=)/) {\n            checkwarn(\"EQUALSNULL\", $line,\n                      length($1) + length($2) + length($3),\n                      $file, $l, \"we prefer !variable instead of \\\"== NULL\\\" comparisons\");\n        }\n\n        # check for '!= 0' in if/while conditions but not if the thing on\n        # the left of it is a function call\n        if($nostr =~ /^(.*)(if|while)(\\(.*[^)]) != 0[^x]/) {\n            checkwarn(\"NOTEQUALSZERO\", $line,\n                      length($1) + length($2) + length($3),\n                      $file, $l, \"we prefer if(rc) instead of \\\"rc != 0\\\" comparisons\");\n        }\n\n        # check spaces in 'do {'\n        if($nostr =~ /^( *)do( *)\\{/ && length($2) != 1) {\n            checkwarn(\"DOBRACE\", $line, length($1) + 2, $file, $l, \"one space after do before brace\");\n        }\n        # check spaces in 'do {'\n        elsif($nostr =~ /^( *)\\}( *)while/ && length($2) != 1) {\n            checkwarn(\"BRACEWHILE\", $line, length($1) + 2, $file, $l, \"one space between brace and while\");\n        }\n        if($nostr =~ /^((.*\\s)(if) *\\()(.*)\\)(.*)/) {\n            my $pos = length($1);\n            my $postparen = $5;\n            my $cond = $4;\n            if($cond =~ / = /) {\n                checkwarn(\"ASSIGNWITHINCONDITION\",\n                          $line, $pos+1, $file, $l,\n                          \"assignment within conditional expression\");\n            }\n            my $temp = $cond;\n            $temp =~ s/\\(//g; # remove open parens\n            my $openc = length($cond) - length($temp);\n\n            $temp = $cond;\n            $temp =~ s/\\)//g; # remove close parens\n            my $closec = length($cond) - length($temp);\n            my $even = $openc == $closec;\n\n            if($l =~ / *\\#/) {\n                # this is a #if, treat it differently\n            }\n            elsif($even && $postparen &&\n               ($postparen !~ /^ *$/) && ($postparen !~ /^ *[,{&|\\\\]+/)) {\n                checkwarn(\"ONELINECONDITION\",\n                          $line, length($l)-length($postparen), $file, $l,\n                          \"conditional block on the same line\");\n            }\n        }\n        # check spaces after open parentheses\n        if($l =~ /^(.*[a-z])\\( /i) {\n            checkwarn(\"SPACEAFTERPAREN\",\n                      $line, length($1)+1, $file, $l,\n                      \"space after open parenthesis\");\n        }\n\n        # check spaces before close parentheses, unless it was a space or a\n        # close parenthesis!\n        if($l =~ /(.*[^\\) ]) \\)/) {\n            checkwarn(\"SPACEBEFORECLOSE\",\n                      $line, length($1)+1, $file, $l,\n                      \"space before close parenthesis\");\n        }\n\n        # check spaces before comma!\n        if($l =~ /(.*[^ ]) ,/) {\n            checkwarn(\"SPACEBEFORECOMMA\",\n                      $line, length($1)+1, $file, $l,\n                      \"space before comma\");\n        }\n\n        # check for \"return(\" without space\n        if($l =~ /^(.*)return\\(/) {\n            if($1 =~ / *\\#/) {\n                # this is a #if, treat it differently\n            }\n            else {\n                checkwarn(\"RETURNNOSPACE\", $line, length($1)+6, $file, $l,\n                          \"return without space before paren\");\n            }\n        }\n\n        # check for \"sizeof\" without parenthesis\n        if(($l =~ /^(.*)sizeof *([ (])/) && ($2 ne \"(\")) {\n            if($1 =~ / *\\#/) {\n                # this is a #if, treat it differently\n            }\n            else {\n                checkwarn(\"SIZEOFNOPAREN\", $line, length($1)+6, $file, $l,\n                          \"sizeof without parenthesis\");\n            }\n        }\n\n        # check for comma without space\n        if($l =~ /^(.*),[^ \\n]/) {\n            my $pref=$1;\n            my $ign=0;\n            if($pref =~ / *\\#/) {\n                # this is a #if, treat it differently\n                $ign=1;\n            }\n            elsif($pref =~ /\\/\\*/) {\n                # this is a comment\n                $ign=1;\n            }\n            elsif($pref =~ /[\\\"\\']/) {\n                $ign = 1;\n                # There is a quote here, figure out whether the comma is\n                # within a string or '' or not.\n                if($pref =~ /\\\"/) {\n                    # within a string\n                }\n                elsif($pref =~ /\\'$/) {\n                    # a single letter\n                }\n                else {\n                    $ign = 0;\n                }\n            }\n            if(!$ign) {\n                checkwarn(\"COMMANOSPACE\", $line, length($pref)+1, $file, $l,\n                          \"comma without following space\");\n            }\n        }\n\n        # check for \"} else\"\n        if($l =~ /^(.*)\\} *else/) {\n            checkwarn(\"BRACEELSE\",\n                      $line, length($1), $file, $l, \"else after closing brace on same line\");\n        }\n        # check for \"){\"\n        if($l =~ /^(.*)\\)\\{/) {\n            checkwarn(\"PARENBRACE\",\n                      $line, length($1)+1, $file, $l, \"missing space after close paren\");\n        }\n        # check for \"^{\" with an empty line before it\n        if(($l =~ /^\\{/) && ($prevl =~ /^[ \\t]*\\z/)) {\n            checkwarn(\"EMPTYLINEBRACE\",\n                      $line, 0, $file, $l, \"empty line before open brace\");\n        }\n\n        # check for space before the semicolon last in a line\n        if($l =~ /^(.*[^ ].*) ;$/) {\n            checkwarn(\"SPACESEMICOLON\",\n                      $line, length($1), $file, $ol, \"no space before semicolon\");\n        }\n\n        # check for space before the colon in a switch label\n        if($l =~ /^( *(case .+|default)) :/) {\n            checkwarn(\"SPACESWITCHCOLON\",\n                      $line, length($1), $file, $ol, \"no space before colon of switch label\");\n        }\n\n        # scan for use of banned functions\n        if($l =~ /^(.*\\W)\n                   (gmtime|localtime|\n                    gets|\n                    strtok|\n                    v?sprintf|\n                    (str|_mbs|_tcs|_wcs)n?cat|\n                    LoadLibrary(Ex)?(A|W)?)\n                   \\s*\\(\n                 /x) {\n            checkwarn(\"BANNEDFUNC\",\n                      $line, length($1), $file, $ol,\n                      \"use of $2 is banned\");\n        }\n        if($warnings{\"STRERROR\"}) {\n            # scan for use of banned strerror. This is not a BANNEDFUNC to\n            # allow for individual enable/disable of this warning.\n            if($l =~ /^(.*\\W)(strerror)\\s*\\(/x) {\n                if($1 !~ /^ *\\#/) {\n                    # skip preprocessor lines\n                    checkwarn(\"STRERROR\",\n                              $line, length($1), $file, $ol,\n                              \"use of $2 is banned\");\n                }\n            }\n        }\n        # scan for use of snprintf for curl-internals reasons\n        if($l =~ /^(.*\\W)(v?snprintf)\\s*\\(/x) {\n            checkwarn(\"SNPRINTF\",\n                      $line, length($1), $file, $ol,\n                      \"use of $2 is banned\");\n        }\n\n        # scan for use of non-binary fopen without the macro\n        if($l =~ /^(.*\\W)fopen\\s*\\([^,]*, *\\\"([^\"]*)/) {\n            my $mode = $2;\n            if($mode !~ /b/) {\n                checkwarn(\"FOPENMODE\",\n                          $line, length($1), $file, $ol,\n                          \"use of non-binary fopen without FOPEN_* macro: $mode\");\n            }\n        }\n\n        # check for open brace first on line but not first column only alert\n        # if previous line ended with a close paren and it wasn't a cpp line\n        if(($prevl =~ /\\)\\z/) && ($l =~ /^( +)\\{/) && !$prevp) {\n            checkwarn(\"BRACEPOS\",\n                      $line, length($1), $file, $ol, \"badly placed open brace\");\n        }\n\n        # if the previous line starts with if/while/for AND ends with an open\n        # brace, or an else statement, check that this line is indented $indent\n        # more steps, if not a cpp line\n        if(!$prevp && ($prevl =~ /^( *)((if|while|for)\\(.*\\{|else)\\z/)) {\n            my $first = length($1);\n            # this line has some character besides spaces\n            if($l =~ /^( *)[^ ]/) {\n                my $second = length($1);\n                my $expect = $first+$indent;\n                if($expect != $second) {\n                    my $diff = $second - $first;\n                    checkwarn(\"INDENTATION\", $line, length($1), $file, $ol,\n                              \"not indented $indent steps (uses $diff)\");\n\n                }\n            }\n        }\n\n        # if the previous line starts with if/while/for AND ends with a closed\n        # parenthesis and there's an equal number of open and closed\n        # parentheses, check that this line is indented $indent more steps, if\n        # not a cpp line\n        elsif(!$prevp && ($prevl =~ /^( *)(if|while|for)(\\(.*\\))\\z/)) {\n            my $first = length($1);\n            my $op = $3;\n            my $cl = $3;\n\n            $op =~ s/[^(]//g;\n            $cl =~ s/[^)]//g;\n\n            if(length($op) == length($cl)) {\n                # this line has some character besides spaces\n                if($l =~ /^( *)[^ ]/) {\n                    my $second = length($1);\n                    my $expect = $first+$indent;\n                    if($expect != $second) {\n                        my $diff = $second - $first;\n                        checkwarn(\"INDENTATION\", $line, length($1), $file, $ol,\n                                  \"not indented $indent steps (uses $diff)\");\n                    }\n                }\n            }\n        }\n\n        # check for 'char * name'\n        if(($l =~ /(^.*(char|int|long|void|CURL|CURLM|CURLMsg|[cC]url_[A-Za-z_]+|struct [a-zA-Z_]+) *(\\*+)) (\\w+)/) && ($4 !~ /^(const|volatile)$/)) {\n            checkwarn(\"ASTERISKSPACE\",\n                      $line, length($1), $file, $ol,\n                      \"space after declarative asterisk\");\n        }\n        # check for 'char*'\n        if(($l =~ /(^.*(char|int|long|void|curl_slist|CURL|CURLM|CURLMsg|curl_httppost|sockaddr_in|FILE)\\*)/)) {\n            checkwarn(\"ASTERISKNOSPACE\",\n                      $line, length($1)-1, $file, $ol,\n                      \"no space before asterisk\");\n        }\n\n        # check for 'void func() {', but avoid false positives by requiring\n        # both an open and closed parentheses before the open brace\n        if($l =~ /^((\\w).*)\\{\\z/) {\n            my $k = $1;\n            $k =~ s/const *//;\n            $k =~ s/static *//;\n            if($k =~ /\\(.*\\)/) {\n                checkwarn(\"BRACEPOS\",\n                          $line, length($l)-1, $file, $ol,\n                          \"wrongly placed open brace\");\n            }\n        }\n\n        # check for equals sign without spaces next to it\n        if($nostr =~ /(.*)\\=[a-z0-9]/i) {\n            checkwarn(\"EQUALSNOSPACE\",\n                      $line, length($1)+1, $file, $ol,\n                      \"no space after equals sign\");\n        }\n        # check for equals sign without spaces before it\n        elsif($nostr =~ /(.*)[a-z0-9]\\=/i) {\n            checkwarn(\"NOSPACEEQUALS\",\n                      $line, length($1)+1, $file, $ol,\n                      \"no space before equals sign\");\n        }\n\n        # check for plus signs without spaces next to it\n        if($nostr =~ /(.*)[^+]\\+[a-z0-9]/i) {\n            checkwarn(\"PLUSNOSPACE\",\n                      $line, length($1)+1, $file, $ol,\n                      \"no space after plus sign\");\n        }\n        # check for plus sign without spaces before it\n        elsif($nostr =~ /(.*)[a-z0-9]\\+[^+]/i) {\n            checkwarn(\"NOSPACEPLUS\",\n                      $line, length($1)+1, $file, $ol,\n                      \"no space before plus sign\");\n        }\n\n        # check for semicolons without space next to it\n        if($nostr =~ /(.*)\\;[a-z0-9]/i) {\n            checkwarn(\"SEMINOSPACE\",\n                      $line, length($1)+1, $file, $ol,\n                      \"no space after semicolon\");\n        }\n\n        # typedef struct ... {\n        if($nostr =~ /^(.*)typedef struct.*{/) {\n            checkwarn(\"TYPEDEFSTRUCT\",\n                      $line, length($1)+1, $file, $ol,\n                      \"typedef'ed struct\");\n        }\n\n        if($nostr =~ /(.*)! +(\\w|\\()/) {\n            checkwarn(\"EXCLAMATIONSPACE\",\n                      $line, length($1)+1, $file, $ol,\n                      \"space after exclamation mark\");\n        }\n\n        # check for more than one consecutive space before open brace or\n        # question mark. Skip lines containing strings since they make it hard\n        # due to artificially getting multiple spaces\n        if(($l eq $nostr) &&\n           $nostr =~ /^(.*(\\S)) + [{?]/i) {\n            checkwarn(\"MULTISPACE\",\n                      $line, length($1)+1, $file, $ol,\n                      \"multiple spaces\");\n        }\n      preproc:\n        $line++;\n        $prevp = $prep;\n        $prevl = $ol if(!$prep);\n        $prevpl = $ol if($prep);\n    }\n\n    if(!scalar(@copyright)) {\n        checkwarn(\"COPYRIGHT\", 1, 0, $file, \"\", \"Missing copyright statement\", 1);\n    }\n\n    # COPYRIGHTYEAR is an extended warning so we must first see if it has been\n    # enabled in .checksrc\n    if(defined($warnings{\"COPYRIGHTYEAR\"})) {\n        # The check for updated copyrightyear is overly complicated in order to\n        # not punish current hacking for past sins. The copyright years are\n        # right now a bit behind, so enforcing copyright year checking on all\n        # files would cause hundreds of errors. Instead we only look at files\n        # which are tracked in the Git repo and edited in the workdir, or\n        # committed locally on the branch without being in upstream master.\n        #\n        # The simple and naive test is to simply check for the current year,\n        # but updating the year even without an edit is against project policy\n        # (and it would fail every file on January 1st).\n        #\n        # A rather more interesting, and correct, check would be to not test\n        # only locally committed files but inspect all files wrt the year of\n        # their last commit. Removing the `git rev-list origin/master..HEAD`\n        # condition below will enforce copyright year checks against the year\n        # the file was last committed (and thus edited to some degree).\n        my $commityear = undef;\n        @copyright = sort {$$b{year} cmp $$a{year}} @copyright;\n\n        # if the file is modified, assume commit year this year\n        if(`git status -s -- $file` =~ /^ [MARCU]/) {\n            $commityear = (localtime(time))[5] + 1900;\n        }\n        else {\n            # min-parents=1 to ignore wrong initial commit in truncated repos\n            my $grl = `git rev-list --max-count=1 --min-parents=1 --timestamp HEAD -- $file`;\n            if($grl) {\n                chomp $grl;\n                $commityear = (localtime((split(/ /, $grl))[0]))[5] + 1900;\n            }\n        }\n\n        if(defined($commityear) && scalar(@copyright) &&\n           $copyright[0]{year} != $commityear) {\n            checkwarn(\"COPYRIGHTYEAR\", $copyright[0]{line}, $copyright[0]{col},\n                      $file, $copyright[0]{code},\n                      \"Copyright year out of date, should be $commityear, \" .\n                      \"is $copyright[0]{year}\", 1);\n        }\n    }\n\n    if($incomment) {\n        checkwarn(\"OPENCOMMENT\", 1, 0, $file, \"\", \"Missing closing comment\", 1);\n    }\n\n    checksrc_endoffile($file);\n\n    close($R);\n\n}\n\n\nif($errors || $warnings || $verbose) {\n    printf \"checksrc: %d errors and %d warnings\\n\", $errors, $warnings;\n    if($suppressed) {\n        printf \"checksrc: %d errors and %d warnings suppressed\\n\",\n        $serrors,\n        $swarnings;\n    }\n    exit 5; # return failure\n}\n"
        },
        {
          "name": "completions",
          "type": "tree",
          "content": null
        },
        {
          "name": "mkrelease",
          "type": "blob",
          "size": 2.2958984375,
          "content": "#!/bin/sh\n##########################################################################\n#                                  _   _ ____  _\n#  Project                     ___| | | |  _ \\| |\n#                             / __| | | | |_) | |\n#                            | (__| |_| |  _ <| |___\n#                             \\___|\\___/|_| \\_\\_____|\n#\n# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n#\n# This software is licensed as described in the file COPYING, which\n# you should have received as part of this distribution. The terms\n# are also available at https://curl.se/docs/copyright.html.\n#\n# You may opt to use, copy, modify, merge, publish, distribute and/or sell\n# copies of the Software, and permit persons to whom the Software is\n# furnished to do so, under the terms of the COPYING file.\n#\n# This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n# KIND, either express or implied.\n#\n# SPDX-License-Identifier: curl\n#\n##########################################################################\n\nset -eu\n\nexport LC_ALL=C\nexport TZ=UTC\n\nversion=\"${1:-}\"\n\nif [ -z \"$version\" ]; then\n  echo \"Specify a version number!\"\n  exit\nfi\n\nrel=\"trurl-$version\"\n\nmkdir $rel\n\n# update title in markdown manpage\nsed -ie \"s/^Source: trurl \\([0-9.]*\\)/Source: trurl $version/\" trurl.md\n\n# update version number in header file\nsed -ie \"s/\\\"[\\.0-9]*\\\"/\\\"$version\\\"/\" version.h\n\n# render the manpage into nroff\n./curl/scripts/cd2nroff trurl.md > $rel/trurl.1\n\n# create a release directory tree\ncp -p --parents $(git ls-files | grep -vE '^(.github/|.reuse/|.gitignore|LICENSES/)') $rel\n\n# create tarball from the tree\ntargz=\"$rel.tar.gz\"\ntar cfz \"$targz\" \"$rel\"\n\ntimestamp=${SOURCE_DATE_EPOCH:-$(date +\"%s\")}\nfilestamp=$(date -d \"@$timestamp\" +\"%Y%m%d%H%M.%S\")\n\nretar() {\n  tempdir=$1\n  rm -rf \"$tempdir\"\n  mkdir \"$tempdir\"\n  cd \"$tempdir\"\n  gzip -dc \"../$targz\" | tar -xf -\n  find trurl-* -depth -exec touch -c -t \"$filestamp\" '{}' +\n  tar --create --format=ustar --owner=0 --group=0 --numeric-owner --sort=name trurl-* | gzip --best --no-name > out.tar.gz\n  mv out.tar.gz ../\n  cd ..\n  rm -rf \"$tempdir\"\n}\n\n# make it reproducible\nretar \".tarbuild\"\nmv out.tar.gz \"$targz\"\n\n# remove the temporary directory\nrm -rf $rel\n\n# Set deterministic timestamp\ntouch -c -t \"$filestamp\" \"$targz\"\n\necho \"Now sign the release:\"\necho \"gpg -b -a '$targz'\"\n"
        },
        {
          "name": "test.py",
          "type": "blob",
          "size": 9.490234375,
          "content": "#!/usr/bin/env python3\n##########################################################################\n#                                  _   _ ____  _\n#  Project                     ___| | | |  _ \\| |\n#                             / __| | | | |_) | |\n#                            | (__| |_| |  _ <| |___\n#                             \\___|\\___/|_| \\_\\_____|\n#\n# Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n#\n# This software is licensed as described in the file COPYING, which\n# you should have received as part of this distribution. The terms\n# are also available at https://curl.se/docs/copyright.html.\n#\n# You may opt to use, copy, modify, merge, publish, distribute and/or sell\n# copies of the Software, and permit persons to whom the Software is\n# furnished to do so, under the terms of the COPYING file.\n#\n# This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n# KIND, either express or implied.\n#\n# SPDX-License-Identifier: curl\n#\n##########################################################################\n\nimport sys\nfrom os import getcwd, path\nimport json\nimport shlex\nfrom subprocess import PIPE, run, Popen\nfrom dataclasses import dataclass, asdict\nfrom typing import Any, Optional, TextIO\nimport locale\n\nPROGNAME = \"trurl\"\nTESTFILE = \"tests.json\"\nVALGRINDTEST = \"valgrind\"\nVALGRINDARGS = [\"--error-exitcode=1\", \"--leak-check=full\", \"-q\"]\n\nRED = \"\\033[91m\"  # used to mark unsuccessful tests\nNOCOLOR = \"\\033[0m\"\n\nEXIT_SUCCESS = 0\nEXIT_ERROR = 1\n\n@dataclass\nclass CommandOutput:\n    stdout: Any\n    returncode: int\n    stderr: str\n\n\ndef testComponent(value, exp):\n    if isinstance(exp, bool):\n        result = value == 0 or value not in (\"\", [])\n        if exp:\n            return result\n        else:\n            return not result\n\n    return value == exp\n\n# checks if valgrind is installed\ndef check_valgrind():\n    process = Popen(VALGRINDTEST + \" --version\",\n                    shell=True, stdout=PIPE, stderr=PIPE, encoding=\"utf-8\")\n    output, error = process.communicate()\n    if output.startswith(VALGRINDTEST) and not len(error):\n        return True\n    return False\n\n\ndef getcharmap():\n    process = Popen(\"locale charmap\", shell=True, stdout=PIPE, stderr=PIPE, encoding=\"utf-8\");\n    output, error = process.communicate()\n    return output.strip()\n\n\nclass TestCase:\n    def __init__(self, testIndex, runnerCmd, baseCmd, **testCase):\n        self.testIndex = testIndex\n        self.runnerCmd = runnerCmd\n        self.baseCmd = baseCmd\n        self.arguments = testCase[\"input\"][\"arguments\"]\n        self.expected = testCase[\"expected\"]\n        self.commandOutput: CommandOutput = None\n        self.testPassed: bool = False\n\n    def runCommand(self, cmdfilter: Optional[str], runWithValgrind: bool):\n        # Skip test if none of the arguments contain the keyword\n        if cmdfilter and all(cmdfilter not in arg for arg in self.arguments):\n            return False\n\n        cmd = [self.baseCmd]\n        args = self.arguments\n        if self.runnerCmd != \"\":\n            cmd = [self.runnerCmd]\n            args = [self.baseCmd] + self.arguments\n        elif runWithValgrind:\n            cmd = [VALGRINDTEST]\n            args = VALGRINDARGS + [self.baseCmd] + self.arguments\n\n        output = run(\n            cmd + args,\n            stdout=PIPE, stderr=PIPE,\n            encoding=\"utf-8\"\n        )\n\n        if isinstance(self.expected[\"stdout\"], list):\n            # if we don't expect string, parse to json\n            try:\n                stdout = json.loads(output.stdout)\n            except json.decoder.JSONDecodeError:\n                stdout = None\n        else:\n            stdout = output.stdout\n\n        # assume stderr is always going to be string\n        stderr = output.stderr\n\n        # runners (e.g. wine) spill their own output into stderr,\n        # ignore stderr tests when using a runner.\n        if self.runnerCmd != \"\" and \"stderr\" in self.expected:\n            stderr = self.expected[\"stderr\"]\n\n        self.commandOutput = CommandOutput(stdout, output.returncode, stderr)\n        return True\n\n    def test(self):\n        # return true only if stdout, stderr and errorcode\n        # are equal to the ones found in the testfile\n        self.testPassed = all(\n            testComponent(asdict(self.commandOutput)[k], exp)\n            for k, exp in self.expected.items())\n        return self.testPassed\n\n    def _printVerbose(self, output: TextIO):\n        self._printConcise(output)\n\n        for component, exp in self.expected.items():\n            value = asdict(self.commandOutput)[component]\n            itemFail = self.commandOutput.returncode == 1 or \\\n                not testComponent(value, exp)\n\n            print(f\"--- {component} --- \", file=output)\n            print(\"expected:\", file=output)\n            print(\"nothing\" if exp is False else\n                  \"something\" if exp is True else\n                  f\"{exp!r}\",file=output)\n            print(\"got:\", file=output)\n\n            header = RED if itemFail else \"\"\n            footer = NOCOLOR if itemFail else \"\"\n            print(f\"{header}{value!r}{footer}\", file=output)\n\n        print()\n\n    def _printConcise(self, output: TextIO):\n        if self.testPassed:\n            header = \"\"\n            result = \"passed\"\n            footer = \"\"\n        else:\n            header = RED\n            result = \"failed\"\n            footer = NOCOLOR\n        text = f\"{self.testIndex}: {result}\\t{shlex.join(self.arguments)}\"\n        print(f\"{header}{text}{footer}\", file=output)\n\n\n    def printDetail(self, verbose: bool = False, failed: bool = False):\n        output: TextIO = sys.stderr if failed else sys.stdout\n        if verbose:\n            self._printVerbose(output)\n        else:\n            self._printConcise(output)\n\n\ndef main(argc, argv):\n    ret = EXIT_SUCCESS\n    baseDir = path.dirname(path.realpath(argv[0]))\n    locale.setlocale(locale.LC_ALL, \"\")\n    # python on windows does not always seem to find the\n    # executable if it is in a different output directory than\n    # the python script, even if it is in the current working\n    # directory, using absolute paths to the executable and json\n    # file makes it reliably find the executable\n    baseCmd = path.join(getcwd(), PROGNAME)\n    # the .exe on the end is necessary when using absolute paths\n    if sys.platform == \"win32\" or sys.platform == \"cygwin\":\n        baseCmd += \".exe\"\n\n    with open(path.join(baseDir, TESTFILE), \"r\", encoding=\"utf-8\") as file:\n        allTests = json.load(file)\n        testIndexesToRun = []\n\n    # if argv[1] exists and starts with int\n    cmdfilter = \"\"\n    testIndexesToRun = list(range(len(allTests)))\n    runWithValgrind = False\n    verboseDetail = False\n    runnerCmd = \"\"\n\n    if argc > 1:\n        for arg in argv[1:]:\n            if arg[0].isnumeric():\n                # run only test cases separated by \",\"\n                testIndexesToRun = []\n\n                for caseIndex in arg.split(\",\"):\n                    testIndexesToRun.append(int(caseIndex))\n            elif arg == \"--with-valgrind\":\n                runWithValgrind = True\n            elif arg == \"--verbose\":\n                verboseDetail = True\n            elif arg.startswith(\"--trurl=\"):\n                baseCmd = arg[len(\"--trurl=\"):]\n            elif arg.startswith(\"--runner=\"):\n                runnerCmd = arg[len(\"--runner=\"):]\n            else:\n                cmdfilter = argv[1]\n\n    if runWithValgrind and not check_valgrind():\n        print(f'Error: {VALGRINDTEST} is not installed!', file=sys.stderr)\n        return EXIT_ERROR\n\n    # check if the trurl executable exists\n    if path.isfile(baseCmd):\n        # get the version info for the feature list\n        args = [\"--version\"]\n        if runnerCmd != \"\":\n            cmd = [runnerCmd]\n            args = [baseCmd] + args\n        else:\n            cmd = [baseCmd]\n        output = run(\n            cmd + args,\n            stdout=PIPE, stderr=PIPE,\n            encoding=\"utf-8\"\n        )\n        features = output.stdout.split('\\n')[1].split()[1:]\n\n        numTestsFailed = 0\n        numTestsPassed = 0\n        numTestsSkipped = 0\n        for testIndex in testIndexesToRun:\n            # skip tests if required features are not met\n            required = allTests[testIndex].get(\"required\", None)\n            if required and not set(required).issubset(set(features)):\n                print(f\"Missing feature, skipping test {testIndex + 1}.\")\n                numTestsSkipped += 1\n                continue\n            encoding = allTests[testIndex].get(\"encoding\", None)\n            if encoding and encoding != getcharmap():\n                print(f\"Invalid locale, skipping test {testIndex + 1}.\")\n                numTestsSkipped += 1\n                continue;\n\n            test = TestCase(testIndex + 1, runnerCmd, baseCmd, **allTests[testIndex])\n\n            if test.runCommand(cmdfilter, runWithValgrind):\n                if test.test():  # passed\n                    test.printDetail(verbose=verboseDetail)\n                    numTestsPassed += 1\n\n                else:\n                    test.printDetail(verbose=True, failed=True)\n                    numTestsFailed += 1\n\n        # finally print the results to terminal\n        print(\"Finished:\")\n        result = \", \".join([\n            f\"Failed: {numTestsFailed}\",\n            f\"Passed: {numTestsPassed}\",\n            f\"Skipped: {numTestsSkipped}\",\n            f\"Total: {len(testIndexesToRun)}\"\n        ])\n        if (numTestsFailed == 0):\n            print(\"Passed! - \", result)\n        else:\n            ret = f\"Failed! - {result}\"\n    else:\n        ret = f\" error: File \\\"{baseCmd}\\\" not found!\"\n    return ret\n\n\nif __name__ == \"__main__\":\n    sys.exit(main(len(sys.argv), sys.argv))\n"
        },
        {
          "name": "testfiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests.json",
          "type": "blob",
          "size": 78.625,
          "content": "[\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"hp://example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"hp://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": []\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: not enough input for a URL\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 7\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"ftp.example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"ftp://ftp.example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/../moo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/.././moo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/test/../moo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"--append\",\n                \"path=moo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://localhost/moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-a\",\n                \"path=moo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://localhost/moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--set\",\n                \"host=moo\",\n                \"--set\",\n                \"scheme=http\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://moo/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-shost=moo\",\n                \"-sscheme=http\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://moo/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--set=host=moo\",\n                \"--set=scheme=http\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://moo/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"host=moo\",\n                \"-s\",\n                \"scheme=http\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://moo/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--set\",\n                \"host=moo\",\n                \"--set\",\n                \"scheme=https\",\n                \"--set\",\n                \"port=999\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://moo:999/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--set\",\n                \"host=moo\",\n                \"--set\",\n                \"scheme=ftps\",\n                \"--set\",\n                \"path=/hello\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"ftps://moo/hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se\",\n                \"--set\",\n                \"host=example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--set\",\n                \"host=example.com\",\n                \"--set\",\n                \"scheme=ftp\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"ftp://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html\",\n                \"--redirect\",\n                \"here.html\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/we/here.html\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/../are.html\",\n                \"--set\",\n                \"port=8080\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se:8080/are.html\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"imap://curl.se:22/\",\n                \"-s\",\n                \"port=143\"\n            ]\n        },\n        \"required\": [\"imap-options\"],\n        \"expected\": {\n            \"stdout\": \"imap://curl.se/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--keep-port\",\n                \"https://curl.se:22/\",\n                \"-s\",\n                \"port=443\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se:443/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--keep-port\",\n                \"https://curl.se:22/\",\n                \"-s\",\n                \"port=443\",\n                \"--get\",\n                \"{url}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se:443/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html\",\n                \"--get\",\n                \"{path}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"/we/are.html\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html\",\n                \"-g{path}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"/we/are.html\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--default-port\",\n                \"--url\",\n                \"imap://curl.se/we/are.html\",\n                \"--get\",\n                \"{port}\"\n            ]\n        },\n        \"required\": [\"imap-options\"],\n        \"expected\": {\n            \"stdout\": \"143\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html\",\n                \"--get\",\n                \"{scheme}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html\",\n                \"--get\",\n                \"{:scheme}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se:55/we/are.html\",\n                \"--get\",\n                \"{url:port}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"55\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/%2e%61%13\",\n                \"--get\",\n                \"{:path}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"/.a%13\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se?%2e%61%13\",\n                \"--get\",\n                \"{:query}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \".a%13\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/#%2e%61%13\",\n                \"--get\",\n                \"{:fragment}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \".a%13\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://example.com/#%2e%61%13%Fa\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/#.a%13%fa\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://hello@curl.se/we/are.html\",\n                \"--get\",\n                \"{user}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://hello:secret@curl.se/we/are.html\",\n                \"--get\",\n                \"{password}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"secret\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"imap://hello:secret;crazy@curl.se/we/are.html\",\n                \"--get\",\n                \"{options}\"\n            ]\n        },\n        \"required\": [\"imap-options\"],\n        \"expected\": {\n            \"stdout\": \"crazy\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html\",\n                \"--get\",\n                \"{host}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"curl.se\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://10.1/we/are.html\",\n                \"--get\",\n                \"{host}\"\n            ]\n        },\n        \"required\": [\"normalize-ipv4\"],\n        \"expected\": {\n            \"stdout\": \"10.0.0.1\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://[fe80::0000:20c:29ff:fe9c:409b]:8080/we/are.html\",\n                \"--get\",\n                \"{host}\"\n            ]\n        },\n        \"required\": [\"zone-id\"],\n        \"expected\": {\n            \"stdout\": \"[fe80::20c:29ff:fe9c:409b]\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://[fe80::0000:20c:29ff:fe9c:409b%euth0]:8080/we/are.html\",\n                \"--get\",\n                \"{zoneid}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"euth0\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://[fe80::0000:20c:29ff:fe9c:409b%eth0]:8080/we/are.html\",\n                \"--get\",\n                \"{zoneid}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"eth0\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html?user=many#more\",\n                \"--get\",\n                \"{query}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"user=many\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html?user=many#more\",\n                \"--get\",\n                \"{fragment}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"more\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"imap://curl.se/we/are.html\",\n                \"-g\",\n                \"{default:port}\"\n            ]\n        },\n        \"required\": [\"imap-options\"],\n        \"expected\": {\n            \"stdout\": \"143\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--append\",\n                \"path=you\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/hello/you\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--append\",\n                \"path=you index.html\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/hello/you%20index.html\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se?name=hello\",\n                \"--append\",\n                \"query=search=string\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/?name=hello&search=string\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--set\",\n                \"user=:hej:\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://%3ahej%3a@curl.se/hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--set\",\n                \"user=hej\",\n                \"--set\",\n                \"password=secret\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://hej:secret@curl.se/hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--set\",\n                \"query:=user=me\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/hello?user=me\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--set\",\n                \"query=user=me\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/hello?user%3dme\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--set\",\n                \"fragment= hello\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/hello#%20hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/hello\",\n                \"--set\",\n                \"fragment:=%20hello\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/hello#%20hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"--append\",\n                \"query=hello=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://localhost/?hello=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-a\",\n                \"query=hello=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://localhost/?hello=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker\",\n                \"--trim\",\n                \"query=utm_*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?search=hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker\",\n                \"--qtrim\",\n                \"utm_*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?search=hello\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker&more=data\",\n                \"--trim\",\n                \"query=utm_*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?search=hello&more=data\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker&more=data\",\n                \"--qtrim\",\n                \"utm_*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?search=hello&more=data\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&more=data\",\n                \"--qtrim\",\n                \"utm_*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?search=hello&more=data\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm_source=tracker\",\n                \"--trim\",\n                \"query=utm_*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker&more=data\",\n                \"--qtrim\",\n                \"utm_source\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?search=hello&more=data\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker&more=data\",\n                \"--qtrim\",\n                \"utm_source\",\n                \"--qtrim\",\n                \"more\",\n                \"--qtrim\",\n                \"search\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--accept-space\",\n                \"--url\",\n                \"gopher://localhost/ with space\"\n            ]\n        },\n        \"required\": [\"white-space\"],\n        \"expected\": {\n            \"stdout\": \"gopher://localhost/%20with%20space\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--accept-space\",\n                \"--url\",\n                \"https://localhost/?with space\"\n            ]\n        },\n        \"required\": [\"white-space\"],\n        \"expected\": {\n            \"stdout\": \"https://localhost/?with+space\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://daniel@curl.se:22/\",\n                \"-s\",\n                \"port=\",\n                \"-s\",\n                \"user=\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?moo&search=hello\",\n                \"--qtrim\",\n                \"search\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&moo\",\n                \"--qtrim\",\n                \"search\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello\",\n                \"--qtrim\",\n                \"search\",\n                \"--append\",\n                \"query=moo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?moo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--keep-port\",\n                \"https://hello:443/foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://hello:443/foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--keep-port\",\n                \"ftp://hello:21/foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"ftp://hello:21/foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://hello:443/foo\",\n                \"-s\",\n                \"scheme=ftp\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"ftp://hello:443/foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--keep-port\",\n                \"ftp://hello:443/foo\",\n                \"-s\",\n                \"scheme=https\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://hello:443/foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm_source=tra%20cker&address%20=home&here=now&thisthen\",\n                \"-g\",\n                \"{query:utm_source}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"tra cker\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm_source=tra%20cker&address%20=home&here=now&thisthen\",\n                \"-g\",\n                \"{:query:utm_source}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"tra+cker\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm_source=tra%20cker&address%20=home&here=now&thisthen\",\n                \"-g\",\n                \"{:query:utm_}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm_source=tra%20cker&address%20=home&here=now&thisthen\",\n                \"-g\",\n                \"{:query:UTM_SOURCE}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm_source=tracker&monkey=123\",\n                \"--sort-query\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?monkey=123&utm_source=tracker\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?a=b&c=d&\",\n                \"--sort-query\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?a=b&c=d\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?a=b&c=d&\",\n                \"--sort-query\",\n                \"--trim\",\n                \"query=a\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?c=d\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com:29\",\n                \"--set\",\n                \"port=\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"HTTPS://example.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://EXAMPLE.com\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://EXAMPLE.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://example.com/FOO/BAR\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/FOO/BAR\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"[2001:0db8:0000:0000:0000:ff00:0042:8329]\"\n            ]\n        },\n        \"required\": [\"zone-id\"],\n        \"expected\": {\n            \"stdout\": \"http://[2001:db8::ff00:42:8329]/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm=tra%20cker:address%20=home:here=now:thisthen\",\n                \"--sort-query\",\n                \"--query-separator\",\n                \":\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?address+=home:here=now:thisthen:utm=tra+cker\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"foo?a=bCd=eCe=f\",\n                \"--query-separator\",\n                \"C\",\n                \"--trim\",\n                \"query=d\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://foo/?a=bCe=f\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-g\",\n                \"{scheme} {host\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"http {host\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-g\",\n                \"[scheme] [host\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"http [host\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-g\",\n                \"\\\\{{scheme}\\\\[\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"{http[\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-g\",\n                \"\\\\\\\\[\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"\\\\[\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://u:s@foo?moo\",\n                \"-g\",\n                \"[scheme][user][password][query]\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"httpsusmoo\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"hej?a=b&a=c&a=d&b=a\",\n                \"-g\",\n                \"{query-all:a}\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"b c d\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se?name=mr%00smith\",\n                \"--get\",\n                \"{query:name}\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"mr.smith\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--keep-port\",\n                \"https://curl.se\",\n                \"--iterate\",\n                \"port=80 81 443\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"https://curl.se:80/\\nhttps://curl.se:81/\\nhttps://curl.se:443/\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se\",\n                \"--iterate\",\n                \"port=81 443\",\n                \"--iterate\",\n                \"scheme=sftp moo\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"sftp://curl.se:81/\\nmoo://curl.se:81/\\nsftp://curl.se:443/\\nmoo://curl.se:443/\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se\",\n                \"--iterate\",\n                \"port=81 443\",\n                \"--iterate\",\n                \"scheme=sftp moo\",\n                \"--iterate\",\n                \"port=2 1\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"trurl error: duplicate component for iterate: port\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 11,\n            \"stdout\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se\",\n                \"-s\",\n                \"host=localhost\",\n                \"--iterate\",\n                \"port=22 23\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"https://localhost:22/\\nhttps://localhost:23/\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"hello@localhost\",\n                \"--iterate\",\n                \"host=one two\",\n                \"-g\",\n                \"{host} {user}\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"one hello\\ntwo hello\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?utm=tra%20cker&address%20=home&here=now&thisthen\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"https://example.com/?utm=tra+cker&address+=home&here=now&thisthen\",\n                    \"parts\": {\n                        \"scheme\": \"https\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\",\n                        \"query\": \"utm=tra cker&address =home&here=now&thisthen\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"utm\",\n                            \"value\": \"tra cker\"\n                        },\n                        {\n                            \"key\": \"address \",\n                            \"value\": \"home\"\n                        },\n                        {\n                            \"key\": \"here\",\n                            \"value\": \"now\"\n                        },\n                        {\n                            \"key\": \"thisthen\",\n                            \"value\": \"\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"ftp://smith:secret@example.com:33/path?search=me#where\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"ftp://smith:secret@example.com:33/path?search=me#where\",\n                    \"parts\": {\n                        \"scheme\": \"ftp\",\n                        \"user\": \"smith\",\n                        \"password\": \"secret\",\n                        \"host\": \"example.com\",\n                        \"port\": \"33\",\n                        \"path\": \"/path\",\n                        \"query\": \"search=me\",\n                        \"fragment\": \"where\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"search\",\n                            \"value\": \"me\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"http://example.com/\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\"\n                    }\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"other.com\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"http://example.com/\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\"\n                    }\n                },\n                {\n                    \"url\": \"http://other.com/\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"other.com\",\n                        \"path\": \"/\"\n                    }\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"--iterate\",\n                \"host=one two\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"http://one/\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"one\",\n                        \"path\": \"/\"\n                    }\n                },\n                {\n                    \"url\": \"http://two/\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"two\",\n                        \"path\": \"/\"\n                    }\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--json\",\n                \"-s\",\n                \"scheme=irc\",\n                \"-s\",\n                \"host=curl.se\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"irc://curl.se/\",\n                    \"parts\": {\n                        \"scheme\": \"irc\",\n                        \"host\": \"curl.se\",\n                        \"path\": \"/\"\n                    }\n                }\n            ],\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--json\",\n                \"-s\",\n                \"host=curl.se\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [],\n            \"returncode\": 7,\n            \"stderr\": \"trurl error: not enough input for a URL\\ntrurl error: Try trurl -h for help\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--verify\",\n                \"--json\",\n                \"ftp://example.org\",\n                \"\",\n                \"git://curl.se/\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"ftp://example.org/\",\n                    \"parts\": {\n                        \"scheme\": \"ftp\",\n                        \"host\": \"example.org\",\n                        \"path\": \"/\"\n                    }\n                }\n            ],\n            \"returncode\": 9,\n            \"stderr\": true\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"scheme=imap\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"returncode\": 7,\n            \"stderr\": \"trurl error: not enough input for a URL\\ntrurl error: Try trurl -h for help\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-g\",\n                \"{query:}\",\n                \"http://localhost/?=bar\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"bar\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--json\",\n                \"https://curl.se/?&&&\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"https://curl.se/?&&&\",\n                    \"parts\": {\n                        \"scheme\": \"https\",\n                        \"host\": \"curl.se\",\n                        \"path\": \"/\",\n                        \"query\": \"&&&\"\n                    },\n                    \"params\": []\n                }\n            ],\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--json\",\n                \"--trim\",\n                \"query=f*\",\n                \"localhost?foo&bar=ar\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"http://localhost/?bar=ar\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"localhost\",\n                        \"path\": \"/\",\n                        \"query\": \"bar=ar\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"bar\",\n                            \"value\": \"ar\"\n                        }\n                    ]\n                }\n            ],\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?search=hello&utm_source=tracker&utm_block&testing\",\n                \"--trim\",\n                \"query=utm_*\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"https://example.com/?search=hello&testing\",\n                    \"parts\": {\n                        \"scheme\": \"https\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\",\n                        \"query\": \"search=hello&testing\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"search\",\n                            \"value\": \"hello\"\n                        },\n                        {\n                            \"key\": \"testing\",\n                            \"value\": \"\"\n                        }\n                    ]\n                }\n            ],\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://räksmörgås.se\",\n                \"-g\",\n                \"{default:puny:url}\"\n            ]\n        },\n        \"required\": [\"punycode\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"https://xn--rksmrgs-5wao1o.se:443/\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://räksmörgås.se\",\n                \"-g\",\n                \"{puny:url}\"\n            ]\n        },\n        \"required\": [\"punycode\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"https://xn--rksmrgs-5wao1o.se/\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://räksmörgås.se\",\n                \"-g\",\n                \"{puny:host}\"\n            ]\n        },\n        \"required\": [\"punycode\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": \"xn--rksmrgs-5wao1o.se\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"imap://user:password;crazy@[ff00::1234%hello]:1234/path?a=b&c=d#fragment\",\n                \"--json\"\n            ]\n        },\n        \"required\": [\"imap-options\"],\n        \"expected\": {\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"imap://user:password;crazy@[ff00::1234%25hello]:1234/path?a=b&c=d#fragment\",\n                    \"parts\": {\n                        \"scheme\": \"imap\",\n                        \"user\": \"user\",\n                        \"password\": \"password\",\n                        \"options\": \"crazy\",\n                        \"host\": \"[ff00::1234]\",\n                        \"port\": \"1234\",\n                        \"path\": \"/path\",\n                        \"query\": \"a=b&c=d\",\n                        \"fragment\": \"fragment\",\n                        \"zoneid\": \"hello\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"a\",\n                            \"value\": \"b\"\n                        },\n                        {\n                            \"key\": \"c\",\n                            \"value\": \"d\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"imap://example.com/\",\n                \"--get\",\n                \"port: {port}, default:port: {default:port}\"\n            ]\n        },\n        \"required\": [\"imap-options\"],\n        \"expected\": {\n            \"returncode\": 0,\n            \"stdout\": \"port: , default:port: 143\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.com:8080/\",\n                \"--get\",\n                \"port: {port}, default:port: {default:port}\"\n            ]\n        },\n        \"expected\": {\n            \"returncode\": 0,\n            \"stdout\": \"port: 8080, default:port: 8080\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"localhost\",\n                \"-s\",\n                \"host=foo\",\n                \"--iterate\",\n                \"host=bar baz\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"returncode\": 11,\n            \"stderr\": \"trurl error: duplicate --iterate and --set for component host\\ntrurl error: Try trurl -h for help\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"emanuele6://curl.se/trurl\",\n                \"\",\n                \"https://example.org\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"emanuele6://curl.se/trurl\\nhttps://example.org/\\n\",\n            \"returncode\": 0,\n            \"stderr\": true\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--verify\",\n                \"--no-guess-scheme\",\n                \"hello\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"returncode\": 9,\n            \"stderr\": \"trurl error: Bad scheme [hello]\\ntrurl error: Try trurl -h for help\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--verify\",\n                \"-f\",\n                \"testfiles/test0000.txt\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.org/\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"trurl note: skipping long line\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-f\",\n                \"testfiles/test0001.txt\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/\\nhttps://docs.python.org/\\ngit://github.com/curl/curl.git\\nhttp://example.org/\\nxyz://hello/?hi\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--no-guess-scheme\",\n                \"foo\",\n                \"hi\",\n                \"https://example.org\",\n                \"hey\",\n                \"git://curl.se\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.org/\\ngit://curl.se/\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"trurl note: Bad scheme [foo]\\ntrurl note: Bad scheme [hi]\\ntrurl note: Bad scheme [hey]\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-f\",\n                \"testfiles/test0002.txt\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"[]\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--accept-space\",\n                \"-s\",\n                \"query:=x=10&x=2 3\",\n                \"localhost\"\n            ]\n        },\n        \"required\": [\"white-space\"],\n        \"expected\": {\n            \"stdout\": \"http://localhost/?x=10&x=2+3\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"path=\\\\\\\\\",\n                \"-g\",\n                \"{path}\\\\n{:path}\",\n                \"localhost\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"/\\\\\\\\\\n/%5c%5c\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"path=\\\\\\\\\",\n                \"--json\",\n                \"localhost\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"http://localhost/%5c%5c\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"localhost\",\n                        \"path\": \"/\\\\\\\\\"\n                    }\n                }\n            ],\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"path=\\\\\\\\\",\n                \"-g\",\n                \"{path}\\\\n{:path}\",\n                \"--urlencode\",\n                \"localhost\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"/%5c%5c\\n/%5c%5c\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"path=abc\\\\\\\\\",\n                \"-s\",\n                \"query:=a&b&a%26b\",\n                \"--urlencode\",\n                \"--json\",\n                \"localhost\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": [\n                {\n                    \"url\": \"http://localhost/abc%5c%5c?a&b&a%26b\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"localhost\",\n                        \"path\": \"/abc%5c%5c\",\n                        \"query\": \"a&b&a%26b\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"a\",\n                            \"value\": \"\"\n                        },\n                        {\n                            \"key\": \"b\",\n                            \"value\": \"\"\n                        },\n                        {\n                            \"key\": \"a&b\",\n                            \"value\": \"\"\n                        }\n                    ]\n                }\n            ],\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-s\",\n                \"scheme:=http\",\n                \"-s\",\n                \"host:=localhost\",\n                \"-s\",\n                \"path:=/ABC%5C%5C\",\n                \"-s\",\n                \"query:=a&b&a%26b\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://localhost/ABC%5c%5c?a&b&a%26b\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-g\",\n                \"{query:b}\\\\t{query-all:a}\\\\n{:query:b}\\\\t{:query-all:a}\",\n                \"https://example.org/foo?a=1&b=%23&a=%26#hello\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"#\\t1 &\\n%23\\t1 %26\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--urlencode\",\n                \"-g\",\n                \"{query:b}\\\\t{query-all:a}\\\\n{:query:b}\\\\t{:query-all:a}\",\n                \"https://example.org/foo?a=1&b=%23&a=%26#hello\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"%23\\t1 %26\\n%23\\t1 %26\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"-a\",\n                \"query=c=moo\",\n                \"--sort-query\",\n                \"https://example.org/foo?x=hi#rye\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.org/foo?c=moo&x=hi#rye\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--qtrim\",\n                \"a\",\n                \"-a\",\n                \"query=a=ciao\",\n                \"-a\",\n                \"query=b=salve\",\n                \"https://example.org/foo?a=hi&b=hello&x=y\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.org/foo?b=hello&x=y&a=ciao&b=salve\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\" : {\n            \"arguments\": [\n                \"http://example.com/?q=mr%00smith\",\n                \"--json\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"http://example.com/?q=mr%00smith\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\",\n                        \"query\": \"q=mr%00smith\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"q\",\n                            \"value\": \"mr\\u0000smith\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\" : {\n            \"arguments\": [\n                \"http://example.com/?q=mr%00sm%00ith\",\n                \"--json\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"http://example.com/?q=mr%00sm%00ith\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\",\n                        \"query\": \"q=mr%00sm%00ith\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"q\",\n                            \"value\": \"mr\\u0000sm\\u0000ith\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\" : {\n            \"arguments\": [\n                \"http://example.com/?q=mr%00%00%00smith\",\n                \"--json\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"\",\n            \"returncode\": 0,\n            \"stdout\": [\n                {\n                    \"url\": \"http://example.com/?q=mr%00%00%00smith\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.com\",\n                        \"path\": \"/\",\n                        \"query\": \"q=mr%00%00%00smith\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"q\",\n                            \"value\": \"mr\\u0000\\u0000\\u0000smith\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"https://curl.se/we/are.html?*=moo&user=many#more\",\n                \"--qtrim\",\n                \"\\\\*\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://curl.se/we/are.html?user=many#more\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"http://xn--rksmrgs-5wao1o/\",\n                \"--as-idn\"\n            ]\n        },\n        \"required\": [\"punycode2idn\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stdout\": \"http://räksmörgås/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"http://xn--rksmrgs-5wao1o/\",\n                \"-g\",\n                \"{idn:host}\"\n            ]\n        },\n        \"required\": [\"punycode2idn\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stdout\": \"räksmörgås\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"http://xn-----/\",\n                \"--as-idn\",\n                \"--quiet\"\n            ]\n        },\n        \"required\": [\"punycode2idn\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stdout\": \"http://xn-----/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"http://xn-----/\",\n                \"--as-idn\"\n            ]\n        },\n        \"required\": [\"punycode2idn\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stdout\": \"http://xn-----/\\n\",\n            \"stderr\": \"trurl note: Error converting url to IDN [Bad hostname]\\n\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--verify\",\n                \"-f\",\n                \"testfiles/test0000.txt\",\n                \"--quiet\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.org/\\n\",\n            \"returncode\": 0,\n            \"stderr\": \"\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--curl\",\n                \"--verify\",\n                \"foo://bar\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": true,\n            \"returncode\": 9\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://test.org/?key=val\",\n                \"--replace\",\n                \"key=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://test.org/?key=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://test.org/?that=thing&key=val\",\n                \"--replace\",\n                \"key=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://test.org/?that=thing&key=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://test.org/?that=thing&key\",\n                \"--replace\",\n                \"key=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://test.org/?that=thing&key=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://test.org/?that=thing&key=foo\",\n                \"--replace\",\n                \"key\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://test.org/?that=thing&key\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com?a=123&b=321&b=987\",\n                \"--replace\",\n                \"b=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/?a=123&b=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.org/?quest=best\",\n                \"--replace\",\n                \"quest=%00\",\n                \"--json\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n\t\t\t\"stdout\": [{\n\t\t\t\t\"url\": \"http://example.org/?quest=%2500\",\n\t\t\t\t\"parts\": {\n\t\t\t\t\t\"scheme\": \"http\",\n\t\t\t\t\t\"host\": \"example.org\",\n\t\t\t\t\t\"path\": \"/\",\n                    \"query\": \"quest=%2500\"\n\t\t\t\t},\n\t\t\t\t\"params\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"key\": \"quest\",\n\t\t\t\t\t\t\"value\": \"%00\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}],\n\t\t\t\"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--replace\"\n            ]\n        }, \n        \"expected\": {\n            \"stderr\": \"trurl error: No data passed to replace component\\ntrurl error: Try trurl -h for help\\n\",\n            \"stdout\":\"\",\n            \"returncode\": 12\n        }\n    },\n    {\n    \"input\": {\n            \"arguments\": [\n                \"http://test.org/?that=thing\",\n                \"--force-replace\",\n                \"key=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://test.org/?that=thing&key=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n    \"input\": {\n            \"arguments\": [\n                \"http://test.org/?that=thing\",\n                \"--replace-append\",\n                \"key=foo\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://test.org/?that=thing&key=foo\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"0?00%000000000000000000000=0000000000\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://0.0.0.0/?00%000000000000000000000=0000000000\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--json\",\n                \"0?0%000000000000000000000000000000000\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n            \"returncode\": 0,\n            \"stderr\": \"\",\n            \"stdout\": [\n                {\n                    \"url\": \"http://0.0.0.0/?0%000000000000000000000000000000000\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"0.0.0.0\",\n                        \"path\": \"/\",\n                        \"query\": \"0%000000000000000000000000000000000\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"0\\u00000000000000000000000000000000000\",\n                            \"value\": \"\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--json\",\n                \"0?0%000000000000000000000000000000000=000%0000000000\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n            \"returncode\": 0,\n            \"stderr\": \"\",\n            \"stdout\": [\n                {\n                    \"url\": \"http://0.0.0.0/?0%000000000000000000000000000000000=000%0000000000\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"0.0.0.0\",\n                        \"path\": \"/\",\n                        \"query\": \"0%000000000000000000000000000000000=000%0000000000\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"0\\u00000000000000000000000000000000000\",\n                            \"value\": \"000\\u000000000000\"\n                        }\n                    ]\n                }\n            ]\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--set\",\n                \"host=[::1]\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://[::1]/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com:88\",\n                \"--set\",\n                \"port?=99\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com:88/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--set\",\n                \"port?=99\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com:99/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--append\",\n                \"query=add\",\n                \"--iterate\",\n                \"scheme=http ftp\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/?add\\nftp://example.com/?add\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--append\",\n                \"path=add\",\n                \"--iterate\",\n                \"scheme=http ftp\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/add\\nftp://example.com/add\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--append\",\n                \"path=add\",\n                \"--append\",\n                \"path=two\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/add/two\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se?name=mr%00smith\",\n                \"--get\",\n                \"{query}\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"trurl note: URL decode error, most likely because of rubbish in the input (query)\\n\",\n            \"returncode\": 0,\n            \"stdout\": \"\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://curl.se?name=mr%00smith\",\n                \"--get\",\n                \"{strict:query}\"\n            ]\n        },\n        \"expected\": {\n            \"stderr\": \"trurl error: problems URL decoding query\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 10,\n            \"stdout\": \"\"\n        }\n    },\n    {\n        \"required\": [\"no-guess-scheme\"],\n        \"input\": {\n            \"arguments\": [\n                \"example.com\",\n                \"--set\",\n                \"scheme?=https\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"ftp://example.com\",\n                \"--set\",\n                \"scheme?=https\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"ftp://example.com/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/%18\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\":[\n                {\n                    \"url\": \"http://example.org/%18\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.org\",\n                        \"path\": \"/\\u0018\"\n                    }\n                }\n            ],\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/%18\",\n                \"--json\",\n                \"--urlencode\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\":[\n                {\n                    \"url\": \"http://example.org/%18\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.org\",\n                        \"path\": \"/%18\"\n                    }\n                }\n            ],\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/one/t%61o/%2F%42/\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/one/tao/%2fB/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/one/t%61o/%2F%42/\",\n                \"--append\",\n                \"path=%61\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/one/tao/%2fB/%2561\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://ex%61mple.com/h%61s/?wh%61t\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"https://example.com/has/?what\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/\",\n                \"--get\",\n                \"{must:query}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: missing must:query\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 10\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/?\",\n                \"--get\",\n                \"{must:query}\"\n            ]\n        },\n        \"required\": [\"get-empty\"],\n        \"expected\": {\n            \"stdout\": \"\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"https://example.com/\",\n                \"--get\",\n                \"{must:fragment}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: missing must:fragment\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 10\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/%18\",\n                \"--get\",\n                \"{path}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"/\\u0018\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/?a=&b=1\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.org/?a=&b=1\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/?a=1&b=\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.org/?a=1&b=\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/?a=1&b=&c=2\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.org/?a=1&b=&c=2\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/?a=1&b=&c=2\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\":[\n                {\n                    \"url\": \"http://example.org/?a=1&b=&c=2\",\n                    \"parts\": {\n                        \"scheme\": \"http\",\n                        \"host\": \"example.org\",\n                        \"path\": \"/\",\n                        \"query\": \"a=1&b=&c=2\"\n                    },\n                    \"params\": [\n                        {\n                            \"key\": \"a\",\n                            \"value\": \"1\"\n                        },\n                        {\n                            \"key\": \"b\",\n                            \"value\": \"\"\n                        },\n                        {\n                            \"key\": \"c\",\n                            \"value\": \"2\"\n                        }\n                    ]\n                }\n            ],\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.org/?=1&b=2&c=&=3\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.org/?=1&b=2&c=&=3\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.com/?a=%5D\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/?a=%5d\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"http://example.com/?a=%5D&b=%5D\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"http://example.com/?a=%5d&b=%5d\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"sftp://us%65r:pwd;giraffe@odd\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"sftp://user:pwd%3bgiraffe@odd/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"imap://us%65r:pwd;gir%41ffe@odd\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"imap://user:pwd;girAffe@odd/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"sftp://us%65r:pwd;giraffe@odd\",\n                \"--get\",\n                \"[password]\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"pwd;giraffe\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"sftp://us%65r:pwd;giraffe@odd\",\n                \"--get\",\n                \"[:password]\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"pwd%3bgiraffe\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\",\n                \"http://åäö/\",\n                \"--punycode\",\n                \"-s\",\n                \"port=21\"\n            ]\n        },\n        \"required\": [\"punycode\"],\n        \"encoding\": \"UTF-8\",\n        \"expected\": {\n            \"stdout\": \"http://xn--4cab6c:21/\\n\",\n            \"stderr\": \"\",\n            \"returncode\": 0\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"sftp://odd\",\n                \"--set\",\n                \"port=144\",\n                \"--set\",\n                \"port=145\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: duplicate --set for component port\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 5\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"sftp://odd\",\n                \"--get\",\n                \"[port]\",\n                \"--get\",\n                \"{port}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: only one --get is supported\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 4\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"-f\",\n                \"testfiles/test0000.txt\",\n                \"-f\",\n                \"testfiles/test0000.txt\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"returncode\": 4,\n            \"stderr\": \"trurl error: only one --url-file is supported\\ntrurl error: Try trurl -h for help\\n\"\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"--url\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: Missing argument for --url\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 3\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--set\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: Missing argument for --set\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 3\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--redirect\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: Missing argument for --redirect\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 3\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--get\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: Missing argument for --get\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 3\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--replace\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: No data passed to replace component\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 12\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--replace-append\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: No data passed to replace component\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 12\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--append\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: Missing argument for --append\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 3\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--query-separator\",\n                \"''\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: only single-letter query separators are supported\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 4\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--query-separator\",\n                \"aa\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: only single-letter query separators are supported\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 4\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--json\",\n                \"--get\",\n                \"{port}\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: --get is mutually exclusive with --json\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 4\n        }\n    },\n    {\n        \"input\": {\n            \"arguments\": [\n                \"url\",\n                \"--get\",\n                \"{port}\",\n                \"--json\"\n            ]\n        },\n        \"expected\": {\n            \"stdout\": \"\",\n            \"stderr\": \"trurl error: --json is mutually exclusive with --get\\ntrurl error: Try trurl -h for help\\n\",\n            \"returncode\": 4\n        }\n    }\n]\n"
        },
        {
          "name": "trurl.c",
          "type": "blob",
          "size": 56.1943359375,
          "content": "/***************************************************************************\n *                             _                   _\n *  Project                   | |_ _ __ _   _ _ __| |\n *                            | __| '__| | | | '__| |\n *                            | |_| |  | |_| | |  | |\n *                             \\__|_|   \\__,_|_|  |_|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n#include <curl/mprintf.h>\n#include <stdint.h>\n\n#if defined(_MSC_VER) && (_MSC_VER < 1800)\ntypedef enum {\n  bool_false = 0,\n  bool_true  = 1\n} bool;\n#define false bool_false\n#define true  bool_true\n#else\n#include <stdbool.h>\n#endif\n\n#include <locale.h> /* for setlocale() */\n\n#include \"version.h\"\n\n#ifdef _MSC_VER\n#define strdup _strdup\n#endif\n\n#if CURL_AT_LEAST_VERSION(7,77,0)\n#define SUPPORTS_NORM_IPV4\n#endif\n#if CURL_AT_LEAST_VERSION(7,81,0)\n#define SUPPORTS_ZONEID\n#endif\n#if CURL_AT_LEAST_VERSION(7,80,0)\n#define SUPPORTS_URL_STRERROR\n#endif\n#if CURL_AT_LEAST_VERSION(7,78,0)\n#define SUPPORTS_ALLOW_SPACE\n#else\n#define CURLU_ALLOW_SPACE 0\n#endif\n#if CURL_AT_LEAST_VERSION(7,88,0)\n#define SUPPORTS_PUNYCODE\n#endif\n#if CURL_AT_LEAST_VERSION(8,3,0)\n#define SUPPORTS_PUNY2IDN\n#endif\n#if CURL_AT_LEAST_VERSION(7,30,0)\n#define SUPPORTS_IMAP_OPTIONS\n#endif\n#if CURL_AT_LEAST_VERSION(8,9,0)\n#define SUPPORTS_NO_GUESS_SCHEME\n#else\n#define CURLU_NO_GUESS_SCHEME 0\n#endif\n#if CURL_AT_LEAST_VERSION(8,8,0)\n#define SUPPORTS_GET_EMPTY\n#else\n#define CURLU_GET_EMPTY 0\n#endif\n\n#define OUTPUT_URL      0  /* default */\n#define OUTPUT_SCHEME   1\n#define OUTPUT_USER     2\n#define OUTPUT_PASSWORD 3\n#define OUTPUT_OPTIONS  4\n#define OUTPUT_HOST     5\n#define OUTPUT_PORT     6\n#define OUTPUT_PATH     7\n#define OUTPUT_QUERY    8\n#define OUTPUT_FRAGMENT 9\n#define OUTPUT_ZONEID   10\n\n#define NUM_COMPONENTS 10 /* excluding \"url\" */\n\n#define PROGNAME        \"trurl\"\n\n#define REPLACE_NULL_BYTE '.' /* for query:key extractions */\n\nenum {\n  VARMODIFIER_URLENCODED = 1 << 1,\n  VARMODIFIER_DEFAULT    = 1 << 2,\n  VARMODIFIER_PUNY       = 1 << 3,\n  VARMODIFIER_PUNY2IDN   = 1 << 4,\n  VARMODIFIER_EMPTY      = 1 << 8,\n};\n\nstruct var {\n  const char *name;\n  CURLUPart part;\n};\n\nstruct string {\n  char *str;\n  size_t len;\n};\n\nstatic const struct var variables[] = {\n  {\"scheme\",   CURLUPART_SCHEME},\n  {\"user\",     CURLUPART_USER},\n  {\"password\", CURLUPART_PASSWORD},\n  {\"options\",  CURLUPART_OPTIONS},\n  {\"host\",     CURLUPART_HOST},\n  {\"port\",     CURLUPART_PORT},\n  {\"path\",     CURLUPART_PATH},\n  {\"query\",    CURLUPART_QUERY},\n  {\"fragment\", CURLUPART_FRAGMENT},\n  {\"zoneid\",   CURLUPART_ZONEID},\n  {NULL, 0}\n};\n\n#define ERROR_PREFIX PROGNAME \" error: \"\n#define WARN_PREFIX PROGNAME \" note: \"\n\n/* error codes */\n#define ERROR_FILE   1\n#define ERROR_APPEND 2 /* --append mistake */\n#define ERROR_ARG    3 /* a command line option misses its argument */\n#define ERROR_FLAG   4 /* a command line flag mistake */\n#define ERROR_SET    5 /* a --set problem */\n#define ERROR_MEM    6 /* out of memory */\n#define ERROR_URL    7 /* could not get a URL out of the set components */\n#define ERROR_TRIM   8 /* a --qtrim problem */\n#define ERROR_BADURL 9 /* if --verify is set and the URL cannot parse */\n#define ERROR_GET   10 /* bad --get syntax */\n#define ERROR_ITER  11 /* bad --iterate syntax */\n#define ERROR_REPL  12 /* a --replace problem */\n\n#ifndef SUPPORTS_URL_STRERROR\n/* provide a fake local mockup */\nstatic char *curl_url_strerror(CURLUcode error)\n{\n  static char buffer[128];\n  curl_msnprintf(buffer, sizeof(buffer), \"URL error %u\", (int)error);\n  return buffer;\n}\n#endif\n\n/* Mapping table to go from lowercase to uppercase for plain ASCII.*/\nstatic const unsigned char touppermap[256] = {\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\n79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 65,\n66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\n85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,\n134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165,\n166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,\n198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213,\n214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,\n230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245,\n246, 247, 248, 249, 250, 251, 252, 253, 254, 255\n};\n\n/* Portable, ASCII-consistent toupper. Do not use toupper() because its\n   behavior is altered by the current locale. */\n#define raw_toupper(in) touppermap[(unsigned int)in]\n\n/*\n * casecompare() does ASCII based case insensitive checks, as a strncasecmp\n * replacement.\n */\n\nstatic int casecompare(const char *first, const char *second, size_t max)\n{\n  while(*first && *second && max) {\n    int diff = raw_toupper(*first) - raw_toupper(*second);\n    if(diff)\n      /* get out of the loop as soon as they don't match */\n      return diff;\n    max--;\n    first++;\n    second++;\n  }\n  if(!max)\n    return 0; /* identical to this point */\n\n  return raw_toupper(*first) - raw_toupper(*second);\n}\n\nstatic void message_low(const char *prefix, const char *suffix,\n                        const char *fmt, va_list ap)\n{\n  fputs(prefix, stderr);\n  vfprintf(stderr, fmt, ap);\n  fputs(suffix, stderr);\n}\n\nstatic void warnf_low(const char *fmt, va_list ap)\n{\n  message_low(WARN_PREFIX, \"\\n\", fmt, ap);\n}\n\nstatic void warnf(const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  warnf_low(fmt, ap);\n  va_end(ap);\n}\n\nstatic void help(void)\n{\n  int i;\n  fputs(\n    \"Usage: \" PROGNAME \" [options] [URL]\\n\"\n    \"  -a, --append [component]=[data]  - append data to component\\n\"\n    \"      --accept-space               - give in to this URL abuse\\n\"\n    \"      --as-idn                     - encode hostnames in idn\\n\"\n    \"      --curl                       - only schemes supported by libcurl\\n\"\n    \"      --default-port               - add known default ports\\n\"\n    \"  -f, --url-file [file/-]          - read URLs from file or stdin\\n\"\n    \"  -g, --get [{component}s]         - output component(s)\\n\"\n    \"  -h, --help                       - this help\\n\"\n    \"      --iterate [component]=[list] - create multiple URL outputs\\n\"\n    \"      --json                       - output URL as JSON\\n\"\n    \"      --keep-port                  - keep known default ports\\n\"\n    \"      --no-guess-scheme            - require scheme in URLs\\n\"\n    \"      --punycode                   - encode hostnames in punycode\\n\"\n    \"      --qtrim [what]               - trim the query\\n\"\n    \"      --query-separator [letter]   - if something else than '&'\\n\"\n    \"      --quiet                      - Suppress (some) notes and comments\\n\"\n    \"      --redirect [URL]             - redirect to this\\n\"\n    \"      --replace [data]             - replaces a query [data]\\n\"\n    \"      --replace-append [data]      - appends a new query if not found\\n\"\n    \"  -s, --set [component]=[data]     - set component content\\n\"\n    \"      --sort-query                 - alpha-sort the query pairs\\n\"\n    \"      --url [URL]                  - URL to work with\\n\"\n    \"      --urlencode                  - show components URL encoded\\n\"\n    \"  -v, --version                    - show version\\n\"\n    \"      --verify                     - return error on (first) bad URL\\n\"\n    \" URL COMPONENTS:\\n\"\n    \"  \", stdout);\n  fputs(\"url, \", stdout);\n  for(i = 0; i< NUM_COMPONENTS ; i++) {\n    printf(\"%s%s\", i?\", \":\"\", variables[i].name);\n  }\n  fputs(\"\\n\", stdout);\n  exit(0);\n}\n\nstatic void show_version(void)\n{\n  curl_version_info_data *data = curl_version_info(CURLVERSION_NOW);\n  /* puny code isn't guaranteed based on the version, so it must be polled\n   * from libcurl */\n#if defined(SUPPORTS_PUNYCODE) || defined(SUPPORTS_PUNY2IDN)\n  bool supports_puny = (data->features & CURL_VERSION_IDN) != 0;\n#endif\n#if defined(SUPPORTS_IMAP_OPTIONS)\n  bool supports_imap = false;\n  const char *const *protocol_name = data->protocols;\n  while(*protocol_name && !supports_imap) {\n    supports_imap = !strncmp(*protocol_name, \"imap\", 3);\n    protocol_name++;\n  }\n#endif\n\n  fprintf(stdout, \"%s version %s libcurl/%s [built-with %s]\\n\",\n          PROGNAME, TRURL_VERSION_TXT, data->version, LIBCURL_VERSION);\n  fprintf(stdout, \"features:\");\n#ifdef SUPPORTS_GET_EMPTY\n  fprintf(stdout, \" get-empty\");\n#endif\n#ifdef SUPPORTS_IMAP_OPTIONS\n  if(supports_imap)\n    fprintf(stdout, \" imap-options\");\n#endif\n#ifdef SUPPORTS_NO_GUESS_SCHEME\n  fprintf(stdout, \" no-guess-scheme\");\n#endif\n#ifdef SUPPORTS_NORM_IPV4\n  fprintf(stdout, \" normalize-ipv4\");\n#endif\n#ifdef SUPPORTS_PUNYCODE\n  if(supports_puny)\n    fprintf(stdout, \" punycode\");\n#endif\n#ifdef SUPPORTS_PUNY2IDN\n  if(supports_puny)\n    fprintf(stdout, \" punycode2idn\");\n#endif\n#ifdef SUPPORTS_URL_STRERROR\n  fprintf(stdout, \" url-strerror\");\n#endif\n#ifdef SUPPORTS_ALLOW_SPACE\n  fprintf(stdout, \" white-space\");\n#endif\n#ifdef SUPPORTS_ZONEID\n  fprintf(stdout, \" zone-id\");\n#endif\n\n  fprintf(stdout, \"\\n\");\n  exit(0);\n}\n\nstruct iterinfo {\n  CURLU *uh;\n  const char *part;\n  size_t plen;\n  char *ptr;\n  unsigned int varmask; /* sets 1 << [component] */\n};\n\nstruct option {\n  struct curl_slist *url_list;\n  struct curl_slist *append_path;\n  struct curl_slist *append_query;\n  struct curl_slist *set_list;\n  struct curl_slist *trim_list;\n  struct curl_slist *iter_list;\n  struct curl_slist *replace_list;\n  const char *redirect;\n  const char *qsep;\n  const char *format;\n  FILE *url;\n  bool urlopen;\n  bool jsonout;\n  bool verify;\n  bool accept_space;\n  bool curl;\n  bool default_port;\n  bool keep_port;\n  bool punycode;\n  bool puny2idn;\n  bool sort_query;\n  bool no_guess_scheme;\n  bool urlencode;\n  bool end_of_options;\n  bool quiet_warnings;\n  bool force_replace;\n\n  /* -- stats -- */\n  unsigned int urls;\n};\n\nstatic void trurl_warnf(struct option *o, const char *fmt, ...)\n{\n  if(!o->quiet_warnings) {\n    va_list ap;\n    va_start(ap, fmt);\n    fputs(WARN_PREFIX, stderr);\n    vfprintf(stderr, fmt, ap);\n    fputs(\"\\n\", stderr);\n    va_end(ap);\n  }\n}\n\n#define MAX_QPAIRS 1000\nstruct string qpairs[MAX_QPAIRS]; /* encoded */\nstruct string qpairsdec[MAX_QPAIRS]; /* decoded */\nint nqpairs; /* how many is stored */\n\nstatic void trurl_cleanup_options(struct option *o)\n{\n  if(!o)\n    return;\n  curl_slist_free_all(o->url_list);\n  curl_slist_free_all(o->set_list);\n  curl_slist_free_all(o->iter_list);\n  curl_slist_free_all(o->append_query);\n  curl_slist_free_all(o->trim_list);\n  curl_slist_free_all(o->replace_list);\n  curl_slist_free_all(o->append_path);\n}\n\nstatic void errorf_low(const char *fmt, va_list ap)\n{\n  message_low(ERROR_PREFIX, \"\\n\"\n              ERROR_PREFIX \"Try \" PROGNAME \" -h for help\\n\", fmt, ap);\n}\n\nstatic void errorf(struct option *o, int exit_code, const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  errorf_low(fmt, ap);\n  va_end(ap);\n  trurl_cleanup_options(o);\n  curl_global_cleanup();\n  exit(exit_code);\n}\n\nstatic char *xstrdup(struct option *o, const char *ptr)\n{\n  char *temp = strdup(ptr);\n  if(!temp)\n    errorf(o, ERROR_MEM, \"out of memory\");\n  return temp;\n}\n\nstatic void verify(struct option *o, int exit_code, const char *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n  if(!o->verify) {\n    warnf_low(fmt, ap);\n    va_end(ap);\n  }\n  else {\n    /* make sure to terminate the JSON array */\n    if(o->jsonout)\n      printf(\"%s]\\n\", o->urls ? \"\\n\" : \"\");\n    errorf_low(fmt, ap);\n    va_end(ap);\n    trurl_cleanup_options(o);\n    curl_global_cleanup();\n    exit(exit_code);\n  }\n}\n\nstatic char *strurldecode(const char *url, int inlength, int *outlength)\n{\n  return curl_easy_unescape(NULL, inlength ? url : \"\", inlength,\n                            outlength);\n}\n\nstatic void urladd(struct option *o, const char *url)\n{\n  struct curl_slist *n;\n  n = curl_slist_append(o->url_list, url);\n  if(n)\n    o->url_list = n;\n}\n\n\n/* read URLs from this file/stdin */\nstatic void urlfile(struct option *o, const char *file)\n{\n  FILE *f;\n  if(o->url)\n    errorf(o, ERROR_FLAG, \"only one --url-file is supported\");\n  if(strcmp(\"-\", file)) {\n    f = fopen(file, \"rt\");\n    if(!f)\n      errorf(o, ERROR_FILE, \"--url-file %s not found\", file);\n    o->urlopen = true;\n  }\n  else\n    f = stdin;\n  o->url = f;\n}\n\nstatic void pathadd(struct option *o, const char *path)\n{\n  struct curl_slist *n;\n  char *urle = curl_easy_escape(NULL, path, 0);\n  if(urle) {\n    n = curl_slist_append(o->append_path, urle);\n    if(n) {\n      o->append_path = n;\n    }\n    curl_free(urle);\n  }\n}\n\nstatic char *encodeassign(const char *query)\n{\n  char *p = strchr(query, '=');\n  char *urle;\n  if(p) {\n    /* URL encode the left and the right side of the '=' separately */\n    char *f1 = curl_easy_escape(NULL, query, (int)(p - query));\n    char *f2 = curl_easy_escape(NULL, p + 1, 0);\n    urle = curl_maprintf(\"%s=%s\", f1, f2);\n    curl_free(f1);\n    curl_free(f2);\n  }\n  else\n    urle = curl_easy_escape(NULL, query, 0);\n  return urle;\n}\n\nstatic void queryadd(struct option *o, const char *query)\n{\n  char *urle = encodeassign(query);\n  if(urle) {\n    struct curl_slist *n = curl_slist_append(o->append_query, urle);\n    if(n)\n      o->append_query = n;\n    curl_free(urle);\n  }\n}\n\nstatic void appendadd(struct option *o,\n                      const char *arg)\n{\n  if(!strncmp(\"path=\", arg, 5))\n    pathadd(o, arg + 5);\n  else if(!strncmp(\"query=\", arg, 6))\n    queryadd(o, arg + 6);\n  else\n    errorf(o, ERROR_APPEND, \"--append unsupported component: %s\", arg);\n}\n\nstatic void setadd(struct option *o,\n                   const char *set) /* [component]=[data] */\n{\n  struct curl_slist *n;\n  n = curl_slist_append(o->set_list, set);\n  if(n)\n    o->set_list = n;\n}\n\nstatic void iteradd(struct option *o,\n                    const char *iter) /* [component]=[data] */\n{\n  struct curl_slist *n;\n  n = curl_slist_append(o->iter_list, iter);\n  if(n)\n    o->iter_list = n;\n}\n\nstatic void trimadd(struct option *o,\n                    const char *trim) /* [component]=[data] */\n{\n  struct curl_slist *n;\n  n = curl_slist_append(o->trim_list, trim);\n  if(n)\n    o->trim_list = n;\n}\n\nstatic void replaceadd(struct option *o,\n                       const char *replace_list) /* [component]=[data] */\n{\n  if(replace_list) {\n    char *urle = encodeassign(replace_list);\n    if(urle) {\n      struct curl_slist *n = curl_slist_append(o->replace_list, urle);\n      if(n)\n        o->replace_list = n;\n      curl_free(urle);\n    }\n  }\n  else\n    errorf(o, ERROR_REPL, \"No data passed to replace component\");\n}\n\nstatic bool longarg(const char *flag, const char *check)\n{\n  /* the given flag might end with an equals sign */\n  size_t len = strlen(flag);\n  return (!strcmp(flag, check) ||\n          (!strncmp(flag, check, len) && check[len] == '='));\n}\n\nstatic bool checkoptarg(struct option *o, const char *flag,\n                        const char *given,\n                        const char *arg)\n{\n  bool shortopt = false;\n  if((flag[0] == '-') && (flag[1] != '-'))\n    shortopt = true;\n  if((!shortopt && longarg(flag, given)) ||\n     (!strncmp(flag, given, 2) && shortopt)) {\n    if(!arg)\n      errorf(o, ERROR_ARG, \"Missing argument for %s\", flag);\n    return true;\n  }\n  return false;\n}\n\nstatic int getarg(struct option *o,\n                  const char *flag,\n                  const char *arg,\n                  bool *usedarg)\n{\n  bool gap = true;\n  *usedarg = false;\n\n  if((flag[0] == '-') && (flag[1] != '-') && flag[2]) {\n    arg = (char *)&flag[2];\n    gap = false;\n  }\n  else if((flag[0] == '-') && (flag[1] == '-')) {\n    char *equals = strchr(&flag[2], '=');\n    if(equals) {\n      arg = (char *)&equals[1];\n      gap = false;\n    }\n  }\n\n  if(!strcmp(\"--\", flag))\n    o->end_of_options = true;\n  else if(!strcmp(\"-v\", flag) || !strcmp(\"--version\", flag))\n    show_version();\n  else if(!strcmp(\"-h\", flag) || !strcmp(\"--help\", flag))\n    help();\n  else if(checkoptarg(o, \"--url\", flag, arg)) {\n    urladd(o, arg);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"-f\", flag, arg) ||\n          checkoptarg(o, \"--url-file\", flag, arg)) {\n    urlfile(o, arg);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"-a\", flag, arg) ||\n          checkoptarg(o, \"--append\", flag, arg)) {\n    appendadd(o, arg);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"-s\", flag, arg) ||\n          checkoptarg(o, \"--set\", flag, arg)) {\n    setadd(o, arg);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"--iterate\", flag, arg)) {\n    iteradd(o, arg);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"--redirect\", flag, arg)) {\n    if(o->redirect)\n      errorf(o, ERROR_FLAG, \"only one --redirect is supported\");\n    o->redirect = arg;\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"--query-separator\", flag, arg)) {\n    if(o->qsep)\n      errorf(o, ERROR_FLAG, \"only one --query-separator is supported\");\n    if(strlen(arg) != 1)\n      errorf(o, ERROR_FLAG,\n                   \"only single-letter query separators are supported\");\n    o->qsep = arg;\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"--trim\", flag, arg)) {\n    if(strncmp(arg, \"query=\", 6))\n      errorf(o, ERROR_TRIM, \"Unsupported trim component: %s\", arg);\n\n    trimadd(o, &arg[6]);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"--qtrim\", flag, arg)) {\n    trimadd(o, arg);\n    *usedarg = gap;\n  }\n  else if(checkoptarg(o, \"-g\", flag, arg) ||\n          checkoptarg(o, \"--get\", flag, arg)) {\n    if(o->format)\n      errorf(o, ERROR_FLAG, \"only one --get is supported\");\n    if(o->jsonout)\n      errorf(o, ERROR_FLAG,\n                   \"--get is mutually exclusive with --json\");\n    o->format = arg;\n    *usedarg = gap;\n  }\n  else if(!strcmp(\"--json\", flag)) {\n    if(o->format)\n      errorf(o, ERROR_FLAG, \"--json is mutually exclusive with --get\");\n    o->jsonout = true;\n  }\n  else if(!strcmp(\"--verify\", flag))\n    o->verify = true;\n  else if(!strcmp(\"--accept-space\", flag)) {\n#ifdef SUPPORTS_ALLOW_SPACE\n    o->accept_space = true;\n#else\n    trurl_warnf(o,\n        \"built with too old libcurl version, --accept-space does not work\");\n#endif\n  }\n  else if(!strcmp(\"--curl\", flag))\n    o->curl = true;\n  else if(!strcmp(\"--default-port\", flag))\n    o->default_port = true;\n  else if(!strcmp(\"--keep-port\", flag))\n    o->keep_port = true;\n  else if(!strcmp(\"--punycode\", flag)) {\n    if(o->puny2idn)\n      errorf(o, ERROR_FLAG, \"--punycode is mutually exclusive with --as-idn\");\n    o->punycode = true;\n  }\n  else if(!strcmp(\"--as-idn\", flag)) {\n    if(o->punycode)\n      errorf(o, ERROR_FLAG, \"--as-idn is mutually exclusive with --punycode\");\n    o->puny2idn = true;\n  }\n  else if(!strcmp(\"--no-guess-scheme\", flag))\n    o->no_guess_scheme = true;\n  else if(!strcmp(\"--sort-query\", flag))\n    o->sort_query = true;\n  else if(!strcmp(\"--urlencode\", flag))\n    o->urlencode = true;\n  else if(!strcmp(\"--quiet\", flag))\n    o->quiet_warnings = true;\n  else if(!strcmp(\"--replace\", flag)) {\n    replaceadd(o, arg);\n    *usedarg = gap;\n  }\n  else if(!strcmp(\"--replace-append\", flag) ||\n          !strcmp(\"--force-replace\", flag)) { /* the initial name */\n    replaceadd(o, arg);\n    o->force_replace = true;\n    *usedarg = gap;\n  }\n  else\n    return 1;  /* unrecognized option */\n  return 0;\n}\n\nstatic void showqkey(FILE *stream, const char *key, size_t klen,\n                     bool urldecode, bool showall)\n{\n  int i;\n  bool shown = false;\n  struct string *qp = urldecode ? qpairsdec : qpairs;\n\n  for(i = 0; i< nqpairs; i++) {\n    if(!strncmp(key, qp[i].str, klen) && (qp[i].str[klen] == '=')) {\n      if(shown)\n        fputc(' ', stream);\n      fprintf(stream, \"%.*s\", (int) (qp[i].len - klen - 1),\n              &qp[i].str[klen + 1]);\n      if(!showall)\n        break;\n      shown = true;\n    }\n  }\n}\n\n/* component to variable pointer */\nstatic const struct var *comp2var(const char *name, size_t vlen)\n{\n  int i;\n  for(i = 0; variables[i].name; i++)\n    if((strlen(variables[i].name) == vlen) &&\n       !strncmp(name, variables[i].name, vlen))\n      return &variables[i];\n  return NULL;\n}\n\nstatic CURLUcode geturlpart(struct option *o, int modifiers, CURLU *uh,\n                            CURLUPart part, char **out)\n{\n  CURLUcode rc =\n    curl_url_get(uh, part, out,\n                 (((modifiers & VARMODIFIER_DEFAULT) ||\n                   o->default_port) ?\n                  CURLU_DEFAULT_PORT :\n                  ((part != CURLUPART_URL || o->keep_port) ?\n                   0 : CURLU_NO_DEFAULT_PORT))|\n#ifdef SUPPORTS_PUNYCODE\n                 (((modifiers & VARMODIFIER_PUNY) || o->punycode) ?\n                  CURLU_PUNYCODE : 0)|\n#endif\n#ifdef SUPPORTS_PUNY2IDN\n                 (((modifiers & VARMODIFIER_PUNY2IDN) || o->puny2idn) ?\n                  CURLU_PUNY2IDN : 0) |\n#endif\n#ifdef SUPPORTS_GET_EMPTY\n                 ((modifiers & VARMODIFIER_EMPTY) ? CURLU_GET_EMPTY : 0) |\n#endif\n                 (o->curl ? 0 : CURLU_NON_SUPPORT_SCHEME)|\n                 (((modifiers & VARMODIFIER_URLENCODED) ||\n                   o->urlencode) ?\n                  0 :CURLU_URLDECODE));\n\n#ifdef SUPPORTS_PUNY2IDN\n  /* retry get w/ out puny2idn to handle invalid punycode conversions */\n  if(rc == CURLUE_BAD_HOSTNAME &&\n     (o->puny2idn || (modifiers & VARMODIFIER_PUNY2IDN))) {\n    curl_free(*out);\n    modifiers &= ~VARMODIFIER_PUNY2IDN;\n    o->puny2idn = false;\n    trurl_warnf(o,\n                \"Error converting url to IDN [%s]\",\n                curl_url_strerror(rc));\n    return geturlpart(o, modifiers, uh, part, out);\n  }\n#endif\n  return rc;\n}\n\nstatic bool is_valid_trurl_error(CURLUcode rc)\n{\n  switch(rc) {\n    case CURLUE_OK:\n    case CURLUE_NO_SCHEME:\n    case CURLUE_NO_USER:\n    case CURLUE_NO_PASSWORD:\n    case CURLUE_NO_OPTIONS:\n    case CURLUE_NO_HOST:\n    case CURLUE_NO_PORT:\n    case CURLUE_NO_QUERY:\n    case CURLUE_NO_FRAGMENT:\n#ifdef SUPPORTS_ZONEID\n    case CURLUE_NO_ZONEID:\n#endif\n    /* silently ignore */\n      return false;\n    default:\n      return true;\n    }\n  return true;\n}\n\nstatic void showurl(FILE *stream, struct option *o, int modifiers,\n                    CURLU *uh)\n{\n  char *url;\n  CURLUcode rc = geturlpart(o, modifiers, uh, CURLUPART_URL, &url);\n  if(rc) {\n    trurl_cleanup_options(o);\n    verify(o, ERROR_BADURL, \"invalid url [%s]\", curl_url_strerror(rc));\n    return;\n  }\n  fputs(url, stream);\n  curl_free(url);\n}\n\nstatic void get(struct option *o, CURLU *uh)\n{\n  FILE *stream = stdout;\n  const char *ptr = o->format;\n  bool done = false;\n  char startbyte = 0;\n  char endbyte = 0;\n\n  while(ptr && *ptr && !done) {\n    if(!startbyte && (('{' == *ptr) || ('[' == *ptr))) {\n      startbyte = *ptr;\n      if('{' == *ptr)\n        endbyte = '}';\n      else\n        endbyte = ']';\n    }\n    if(startbyte == *ptr) {\n      if(startbyte == ptr[1]) {\n        /* an escaped {-letter */\n        fputc(startbyte, stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        const char *start = ptr;\n        char *end;\n        char *cl;\n        size_t vlen;\n        bool isquery = false;\n        bool queryall = false;\n        bool strict = false; /* strict mode, fail on URL decode problems */\n        bool must = false; /* must mode, fail on missing component */\n        int mods = 0;\n        end = strchr(ptr, endbyte);\n        ptr++; /* pass the { */\n        if(!end) {\n          /* syntax error */\n          fputc(startbyte, stream);\n          continue;\n        }\n\n        /* {path} {:path} {/path} */\n        if(*ptr == ':') {\n          mods |= VARMODIFIER_URLENCODED;\n          ptr++;\n        }\n        vlen = end - ptr;\n        do {\n          size_t wordlen;\n          cl = memchr(ptr, ':', vlen);\n          if(!cl)\n            break;\n          wordlen = cl - ptr + 1;\n\n          /* modifiers! */\n          if(!strncmp(ptr, \"default:\", wordlen))\n            mods |= VARMODIFIER_DEFAULT;\n          else if(!strncmp(ptr, \"puny:\", wordlen)) {\n            if(mods & VARMODIFIER_PUNY2IDN)\n              errorf(o, ERROR_GET,\n                     \"puny modifier is mutually exclusive with idn\");\n            mods |= VARMODIFIER_PUNY;\n          }\n          else if(!strncmp(ptr, \"idn:\", wordlen)) {\n            if(mods & VARMODIFIER_PUNY)\n              errorf(o, ERROR_GET,\n                     \"idn modifier is mutually exclusive with puny\");\n            mods |= VARMODIFIER_PUNY2IDN;\n          }\n          else if(!strncmp(ptr, \"strict:\", wordlen))\n            strict = true;\n          else if(!strncmp(ptr, \"must:\", wordlen)) {\n            must = true;\n            mods |= VARMODIFIER_EMPTY;\n          }\n          else if(!strncmp(ptr, \"url:\", wordlen))\n            mods |= VARMODIFIER_URLENCODED;\n          else {\n            if(!strncmp(ptr, \"query-all:\", wordlen)) {\n              isquery = true;\n              queryall = true;\n            }\n            else if(!strncmp(ptr, \"query:\", wordlen))\n              isquery = true;\n            else {\n              /* syntax error */\n              vlen = 0;\n              end[1] = '\\0';\n            }\n            break;\n          }\n\n          ptr = cl + 1;\n          vlen = end - ptr;\n        } while(true);\n\n        if(isquery) {\n          showqkey(stream, cl + 1, end - cl - 1,\n                   !o->urlencode && !(mods & VARMODIFIER_URLENCODED),\n                   queryall);\n        }\n        else if(!vlen)\n          errorf(o, ERROR_GET, \"Bad --get syntax: %s\", start);\n        else if(!strncmp(ptr, \"url\", vlen))\n          showurl(stream, o, mods, uh);\n        else {\n          const struct var *v = comp2var(ptr, vlen);\n          if(v) {\n            char *nurl;\n            /* ask for it URL encode always, to avoid libcurl warning on\n               content */\n            CURLUcode rc = geturlpart(o, mods | VARMODIFIER_URLENCODED,\n                                      uh, v->part, &nurl);\n            if(!rc && !(mods & VARMODIFIER_URLENCODED) && !o->urlencode) {\n              /* it should not be encoded in the output */\n              int olen;\n              char *dec = curl_easy_unescape(NULL, nurl, 0, &olen);\n              curl_free(nurl);\n              if(memchr(dec, '\\0', (size_t)olen)) {\n                /* a binary zero cannot be shown */\n                rc = CURLUE_URLDECODE;\n                curl_free(dec);\n                dec = NULL;\n              }\n              nurl = dec;\n            }\n\n            if(rc == CURLUE_OK) {\n              fputs(nurl, stream);\n              curl_free(nurl);\n            }\n            else if(!is_valid_trurl_error(rc) && must)\n              errorf(o, ERROR_GET, \"missing must:%s\", v->name);\n            else if(is_valid_trurl_error(rc) || strict) {\n              if((rc == CURLUE_URLDECODE) && strict)\n                errorf(o, ERROR_GET, \"problems URL decoding %s\", v->name);\n              else\n                trurl_warnf(o, \"%s (%s)\", curl_url_strerror(rc), v->name);\n            }\n          }\n          else\n            errorf(o, ERROR_GET, \"\\\"%.*s\\\" is not a recognized URL component\",\n                   (int)vlen, ptr);\n        }\n        ptr = end + 1; /* pass the end */\n      }\n    }\n    else if('\\\\' == *ptr && ptr[1]) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      case '\\\\':\n        fputc('\\\\', stream);\n        break;\n      case '{':\n        fputc('{', stream);\n        break;\n      case '[':\n        fputc('[', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n  fputc('\\n', stream);\n}\n\nstatic const struct var *setone(CURLU *uh, const char *setline,\n                                struct option *o)\n{\n  char *ptr = strchr(setline, '=');\n  const struct var *v = NULL;\n  if(ptr && (ptr > setline)) {\n    size_t vlen = ptr - setline;\n    bool urlencode = true;\n    bool conditional = false;\n    bool found = false;\n    if(vlen) {\n      int back = -1;\n      size_t reqlen = 1;\n      while(vlen > reqlen) {\n        if(ptr[back] == ':') {\n          urlencode = false;\n          vlen--;\n        }\n        else if(ptr[back] == '?') {\n          conditional = true;\n          vlen--;\n        }\n        else\n          break;\n        reqlen++;\n        back--;\n      }\n    }\n    v = comp2var(setline, vlen);\n    if(v) {\n      CURLUcode rc = CURLUE_OK;\n      bool skip = false;\n      if((v->part == CURLUPART_HOST) && ('[' == ptr[1]))\n        /* when setting an IPv6 numerical address, disable URL encoding */\n        urlencode = false;\n\n      if(conditional) {\n        char *piece;\n        rc = curl_url_get(uh, v->part, &piece, CURLU_NO_GUESS_SCHEME);\n        if(!rc) {\n          skip = true;\n          curl_free(piece);\n        }\n      }\n\n      if(!skip)\n        rc = curl_url_set(uh, v->part, ptr[1] ? &ptr[1] : NULL,\n                          (o->curl ? 0 : CURLU_NON_SUPPORT_SCHEME)|\n                          (urlencode ? CURLU_URLENCODE : 0) );\n      if(rc)\n        warnf(\"Error setting %s: %s\", v->name, curl_url_strerror(rc));\n      found = true;\n    }\n    if(!found)\n      errorf(o, ERROR_SET,\n                   \"unknown component: %.*s\", (int)vlen, setline);\n  }\n  else\n    errorf(o, ERROR_SET, \"invalid --set syntax: %s\", setline);\n  return v;\n}\n\nstatic unsigned int set(CURLU *uh,\n                        struct option *o)\n{\n  struct curl_slist *node;\n  unsigned int mask = 0;\n  for(node =  o->set_list; node; node = node->next) {\n    const struct var *v;\n    char *setline = node->data;\n    v = setone(uh, setline, o);\n    if(v) {\n      if(mask & (1 << v->part))\n        errorf(o, ERROR_SET,\n                     \"duplicate --set for component %s\", v->name);\n      mask |= (1 << v->part);\n    }\n  }\n  return mask; /* the set components */\n}\n\nstatic void jsonString(FILE *stream, const char *in, size_t len,\n                       bool lowercase)\n{\n  const unsigned char *i = (unsigned char *)in;\n  const char *in_end = &in[len];\n  fputc('\\\"', stream);\n  for(; i < (unsigned char *)in_end; i++) {\n    switch(*i) {\n    case '\\\\':\n      fputs(\"\\\\\\\\\", stream);\n      break;\n    case '\\\"':\n      fputs(\"\\\\\\\"\", stream);\n      break;\n    case '\\b':\n      fputs(\"\\\\b\", stream);\n      break;\n    case '\\f':\n      fputs(\"\\\\f\", stream);\n      break;\n    case '\\n':\n      fputs(\"\\\\n\", stream);\n      break;\n    case '\\r':\n      fputs(\"\\\\r\", stream);\n      break;\n    case '\\t':\n      fputs(\"\\\\t\", stream);\n      break;\n    default:\n      if(*i < 32)\n        fprintf(stream, \"\\\\u%04x\", *i);\n      else {\n        char out = *i;\n        if(lowercase && (out >= 'A' && out <= 'Z'))\n          /* do not use tolower() since that's locale specific */\n          out |= ('a' - 'A');\n        fputc(out, stream);\n      }\n      break;\n    }\n  }\n  fputc('\\\"', stream);\n}\n\nstatic void json(struct option *o, CURLU *uh)\n{\n  int i;\n  bool first = true;\n  char *url;\n  CURLUcode rc = geturlpart(o, 0, uh, CURLUPART_URL, &url);\n  if(rc) {\n    trurl_cleanup_options(o);\n    verify(o, ERROR_BADURL, \"invalid url [%s]\", curl_url_strerror(rc));\n    return;\n  }\n  printf(\"%s\\n  {\\n    \\\"url\\\": \", o->urls ? \",\" : \"\");\n  jsonString(stdout, url, strlen(url), false);\n  curl_free(url);\n  fputs(\",\\n    \\\"parts\\\": {\\n\", stdout);\n  /* special error handling required to not print params array. */\n  bool params_errors = false;\n  for(i = 0; variables[i].name; i++) {\n    char *part;\n    /* ask for the URL encoded version so that weird control characters do not\n       cause problems. URL decode it when push to json. */\n    rc = geturlpart(o, VARMODIFIER_URLENCODED, uh, variables[i].part, &part);\n    if(!rc) {\n      int olen;\n      char *dec = NULL;\n\n      if(!o->urlencode) {\n        if(variables[i].part == CURLUPART_QUERY) {\n          /* query parts have '+' for space */\n          char *n;\n          char *p = part;\n          do {\n            n = strchr(p, '+');\n            if(n) {\n              *n = ' ';\n              p = n + 1;\n            }\n          } while(n);\n        }\n\n        dec = curl_easy_unescape(NULL, part, 0, &olen);\n        if(!dec)\n          errorf(o, ERROR_MEM, \"out of memory\");\n      }\n\n      if(!first)\n        fputs(\",\\n\", stdout);\n      first = false;\n      printf(\"      \\\"%s\\\": \", variables[i].name);\n      if(dec)\n        jsonString(stdout, dec, (size_t)olen, false);\n      else\n        jsonString(stdout, part, strlen(part), false);\n      curl_free(part);\n      curl_free(dec);\n    }\n    else if(is_valid_trurl_error(rc)) {\n        trurl_warnf(o, \"%s (%s)\", curl_url_strerror(rc), variables[i].name);\n        params_errors = true;\n    }\n  }\n  fputs(\"\\n    }\", stdout);\n  first = true;\n  if(nqpairs && !params_errors) {\n    int j;\n    fputs(\",\\n    \\\"params\\\": [\\n\", stdout);\n    for(j = 0 ; j < nqpairs; j++) {\n      const char *sep = memchr(qpairsdec[j].str, '=', qpairsdec[j].len);\n      const char *value = sep ? sep + 1 : \"\";\n      int value_len = (int) qpairsdec[j].len - (int)(value - qpairsdec[j].str);\n      /* don't print out empty/trimmed values */\n      if(!qpairsdec[j].len || !qpairsdec[j].str[0])\n        continue;\n      if(!first)\n        fputs(\",\\n\", stdout);\n      first = false;\n      fputs(\"      {\\n        \\\"key\\\": \", stdout);\n      jsonString(stdout, qpairsdec[j].str,\n                 sep ? (size_t)(sep - qpairsdec[j].str) :\n                       qpairsdec[j].len,\n                 false);\n      fputs(\",\\n        \\\"value\\\": \", stdout);\n      jsonString(stdout, sep?value:\"\", sep?value_len:0, false);\n      fputs(\"\\n      }\", stdout);\n    }\n    fputs(\"\\n    ]\", stdout);\n  }\n  fputs(\"\\n  }\", stdout);\n}\n\n/* --trim query=\"utm_*\" */\nstatic bool trim(struct option *o)\n{\n  bool query_is_modified = false;\n  struct curl_slist *node;\n  for(node = o->trim_list; node; node = node->next) {\n    char *ptr = node->data;\n    if(ptr) {\n      /* 'ptr' should be a fixed string or a pattern ending with an\n         asterisk */\n      size_t inslen;\n      bool pattern = false;\n      int i;\n      char *temp = NULL;\n\n      inslen = strlen(ptr);\n      if(inslen) {\n        pattern = ptr[inslen - 1] == '*';\n        if(pattern && (inslen > 1)) {\n          pattern ^= ptr[inslen - 2] == '\\\\';\n          if(!pattern) {\n            /* the two final letters are \\*, but the backslash needs to be\n               removed. Get a copy and edit that accordingly. */\n            temp = xstrdup(o, ptr);\n            temp[inslen - 2] = '*';\n            temp[inslen - 1] = '\\0';\n            ptr = temp;\n            inslen--; /* one byte shorter now */\n          }\n        }\n        if(pattern)\n          inslen--;\n      }\n\n      for(i = 0 ; i < nqpairs; i++) {\n        char *q = qpairs[i].str;\n        char *sep = strchr(q, '=');\n        size_t qlen;\n        if(sep)\n          qlen = sep - q;\n        else\n          qlen = strlen(q);\n\n        if((pattern && (inslen <= qlen) && !casecompare(q, ptr, inslen)) ||\n           (!pattern && (inslen == qlen) && !casecompare(q, ptr, inslen))) {\n          /* this qpair should be stripped out */\n          free(qpairs[i].str);\n          free(qpairsdec[i].str);\n          qpairs[i].str = xstrdup(o, \"\"); /* marked as deleted */\n          qpairs[i].len = 0;\n          qpairsdec[i].str = xstrdup(o, \"\"); /* marked as deleted */\n          qpairsdec[i].len = 0;\n          query_is_modified = true;\n        }\n      }\n      free(temp);\n    }\n  }\n  return query_is_modified;\n}\n\nstatic char *decodequery(char *str, size_t len, int *olen)\n{\n  /* handle '+' to ' ' outside of the libcurl call */\n  char *p = str;\n  size_t plen = len;\n  do {\n    char *n = memchr(p, '+', plen);\n    if(n) {\n      *n = ' ';\n      ++n;\n      plen -= (n - p);\n    }\n    p = n;\n  } while(p);\n  return curl_easy_unescape(NULL, str, (int)len, olen);\n}\n\n/* the unusual thing here is that we let '*' remain as-is */\n#define ISURLPUNTCS(x) (((x) == '-') || ((x) == '.') || ((x) == '_') || \\\n                        ((x) == '~') || ((x) == '*'))\n#define ISUPPER(x)  (((x) >= 'A') && ((x) <= 'Z'))\n#define ISLOWER(x)  (((x) >= 'a') && ((x) <= 'z'))\n#define ISDIGIT(x)  (((x) >= '0') && ((x) <= '9'))\n#define ISALNUM(x)  (ISDIGIT(x) || ISLOWER(x) || ISUPPER(x))\n#define ISUNRESERVED(x) (ISALNUM(x) || ISURLPUNTCS(x))\n\nstatic char *encodequery(char *str, size_t len)\n{\n  /* to handle ' ' to '+' escaping we cannot use libcurl's URL encode\n     function */\n  char *dupe = malloc(len * 3 + 1); /* worst case */\n  char *p = dupe;\n  if(!p)\n    return NULL;\n\n  while(len--) {\n    /* treat the characters unsigned */\n    unsigned char in = (unsigned char)*str++;\n\n    if(in == ' ')\n      *dupe++ = '+';\n    else if(ISUNRESERVED(in))\n      *dupe++ = in;\n    else {\n      /* encode it */\n      const char hex[] = \"0123456789abcdef\";\n      dupe[0]='%';\n      dupe[1] = hex[in>>4];\n      dupe[2] = hex[in & 0xf];\n      dupe += 3;\n    }\n  }\n  *dupe = 0;\n  return p;\n}\n\n/* URL decode, then URL encode it back to normalize. But don't touch\n   the first '=' if there is one */\nstatic struct string *memdupzero(char *source, size_t len, bool *modified)\n{\n  struct string *ret = calloc(1, sizeof(struct string));\n  char *left = NULL;\n  char *right = NULL;\n  char *el = NULL;\n  char *er = NULL;\n  char *encode = NULL;\n  if(!ret)\n    return NULL;\n\n  if(len) {\n    char *sep = memchr(source, '=', len);\n    int olen;\n    if(!sep) { /* no '=' */\n      char *decode = decodequery(source, (int)len, &olen);\n      if(decode)\n        encode = encodequery(decode, olen);\n      else\n        goto error;\n      curl_free(decode);\n    }\n    else {\n      int llen;\n      int rlen;\n      int leftside;\n      int rightside;\n\n      /* decode both sides */\n      leftside = (int)(sep - source);\n      if(leftside) {\n        left = decodequery(source, leftside, &llen);\n        if(!left)\n          goto error;\n      }\n      else {\n        left = NULL;\n        llen = 0;\n      }\n\n      /* length on the right side of '=': */\n      rightside = (int)len - (int)(sep - source) - 1;\n\n      if(rightside) {\n        right = decodequery(sep + 1,\n                            (int)len - (int)(sep - source) - 1, &rlen);\n        if(!right)\n          goto error;\n      }\n      else {\n        right = NULL;\n        rlen = 0;\n      }\n\n      /* encode both sides again */\n      if(left) {\n        el = encodequery(left, llen);\n        if(!el)\n          goto error;\n      }\n      if(right) {\n        er = encodequery(right, rlen);\n        if(!er)\n          goto error;\n      }\n\n      encode = curl_maprintf(\"%s=%s\", el ? el : \"\", er ? er : \"\");\n      if(!encode)\n        goto error;\n    }\n    olen = (int)strlen(encode);\n\n    if(((size_t)olen != len) || strcmp(encode, source))\n      *modified |= true;\n    ret->str = encode;\n    ret->len = olen;\n  }\n  curl_free(left);\n  curl_free(right);\n  free(el);\n  free(er);\n  return ret;\nerror:\n  curl_free(left);\n  curl_free(right);\n  free(el);\n  free(er);\n  free(encode);\n  free(ret);\n  return NULL;\n}\n\n/* URL decode the pair and return it in an allocated chunk */\nstatic struct string *memdupdec(char *source, size_t len, bool json)\n{\n  char *sep = memchr(source, '=', len);\n  char *left = NULL;\n  char *right = NULL;\n  int right_len = 0;\n  int left_len = 0;\n  char *str;\n  struct string *ret;\n  left = strurldecode(source, (int)(sep ? (size_t)(sep - source) : len),\n                      &left_len);\n  if(sep) {\n    char *p;\n    int plen;\n    right = strurldecode(sep + 1, (int)(len - (sep - source) - 1),\n                         &right_len);\n\n    /* convert null bytes to periods */\n    for(plen = right_len, p = right; plen; plen--, p++) {\n      if(!*p && !json) {\n        *p = REPLACE_NULL_BYTE;\n      }\n    }\n  }\n  str = malloc(sizeof(char) * (left_len + (sep?(right_len + 1):0)));\n  if(!str) {\n    curl_free(right);\n    curl_free(left);\n    return NULL;\n  }\n  memcpy(str, left, left_len);\n  if(sep) {\n    str[left_len] = '=';\n    memcpy(str + 1 + left_len, right, right_len);\n  }\n  curl_free(right);\n  curl_free(left);\n  ret = malloc(sizeof(struct string));\n  if(!ret) {\n    free(str);\n    return NULL;\n  }\n  ret->str = str;\n  ret->len = left_len + (sep?(right_len + 1):0);\n  return ret;\n}\n\n\nstatic void freeqpairs(void)\n{\n  int i;\n  for(i = 0; i<nqpairs; i++) {\n    if(qpairs[i].len) {\n      free(qpairs[i].str);\n      qpairs[i].str = NULL;\n      free(qpairsdec[i].str);\n      qpairsdec[i].str = NULL;\n    }\n  }\n  nqpairs = 0;\n}\n\n/* store the pair both encoded and decoded, return if modified */\nstatic bool addqpair(char *pair, size_t len, bool json)\n{\n  struct string *p = NULL;\n  struct string *pdec = NULL;\n  bool modified = false;\n  if(nqpairs < MAX_QPAIRS) {\n    p = memdupzero(pair, len, &modified);\n    pdec = memdupdec(pair, len, json);\n    if(p && pdec) {\n      qpairs[nqpairs].str = p->str;\n      qpairs[nqpairs].len = p->len;\n      qpairsdec[nqpairs].str = pdec->str;\n      qpairsdec[nqpairs].len = pdec->len;\n      nqpairs++;\n    }\n  }\n  else\n    warnf(\"too many query pairs\");\n\n  if(pdec)\n    free(pdec);\n  if(p)\n    free(p);\n  return modified;\n}\n\n/* convert the query string into an array of name=data pair */\nstatic bool extractqpairs(CURLU *uh, struct option *o)\n{\n  char *q = NULL;\n  bool modified = false;\n  memset(qpairs, 0, sizeof(qpairs));\n  nqpairs = 0;\n  /* extract the query */\n  if(!curl_url_get(uh, CURLUPART_QUERY, &q, 0)) {\n    char *p = q;\n    char *amp;\n    while(*p) {\n      size_t len;\n      amp = strchr(p, o->qsep[0]);\n      if(!amp)\n        len = strlen(p);\n      else\n        len = amp - p;\n      modified |= addqpair(p, len, o->jsonout);\n      if(amp)\n        p = amp + 1;\n      else\n        break;\n    }\n  }\n  curl_free(q);\n  return modified;\n}\n\nstatic void qpair2query(CURLU *uh, struct option *o)\n{\n  int i;\n  char *nq = NULL;\n  for(i = 0; i<nqpairs; i++) {\n    char *oldnq = nq;\n    nq = curl_maprintf(\"%s%s%s\", nq ? nq : \"\",\n                       (nq && *nq && *(qpairs[i].str)) ? o->qsep : \"\",\n                       qpairs[i].str);\n    curl_free(oldnq);\n  }\n  if(nq) {\n    int rc = curl_url_set(uh, CURLUPART_QUERY, nq, 0);\n    if(rc)\n      trurl_warnf(o, \"internal problem: failed to store updated query in URL\");\n  }\n  curl_free(nq);\n}\n\n/* sort case insensitively */\nstatic int cmpfunc(const void *p1, const void *p2)\n{\n  int i;\n  int len = (int)((((struct string *)p1)->len) < (((struct string *)p2)->len)?\n                  (((struct string *)p1)->len) : (((struct string *)p2)->len));\n\n  for(i = 0; i < len; i++) {\n    char c1 = ((struct string *)p1)->str[i] | ('a' - 'A');\n    char c2 = ((struct string *)p2)->str[i] | ('a' - 'A');\n    if(c1 != c2)\n      return c1 - c2;\n  }\n\n  return 0;\n}\n\nstatic bool sortquery(struct option *o)\n{\n  if(o->sort_query) {\n    /* not these two lists may no longer be the same order after the sort */\n    qsort(&qpairs[0], nqpairs, sizeof(struct string), cmpfunc);\n    qsort(&qpairsdec[0], nqpairs, sizeof(struct string), cmpfunc);\n    return true;\n  }\n  return false;\n}\n\nstatic bool replace(struct option *o)\n{\n  bool query_is_modified = false;\n  struct curl_slist *node;\n  for(node = o->replace_list; node; node = node->next) {\n    struct string key;\n    struct string value;\n    bool replaced = false;\n    int i;\n    key.str = node->data;\n    value.str = strchr(key.str, '=');\n    if(value.str) {\n      key.len = value.str++ - key.str;\n      value.len = strlen(value.str);\n    }\n    else {\n      key.len = strlen(key.str);\n      value.str = NULL;\n      value.len = 0;\n    }\n    for(i = 0; i < nqpairs; i++) {\n      char *q = qpairs[i].str;\n      /* not the correct query, move on */\n      if(strncmp(q, key.str, key.len))\n        continue;\n      free(qpairs[i].str);\n      free(qpairsdec[i].str);\n      /* this is a duplicate remove it. */\n      if(replaced) {\n        qpairs[i].len = 0;\n        qpairs[i].str = xstrdup(o, \"\");\n        qpairsdec[i].len = 0;\n        qpairsdec[i].str = xstrdup(o, \"\");\n        continue;\n      }\n      struct string *pdec =\n        memdupdec(key.str, key.len + value.len + 1, o->jsonout);\n      struct string *p = memdupzero(key.str, key.len + value.len +\n                                    (value.str ? 1 : 0),\n                                    &query_is_modified);\n      qpairs[i].len = p->len;\n      qpairs[i].str = p->str;\n      qpairsdec[i].len = pdec->len;\n      qpairsdec[i].str = pdec->str;\n      free(pdec);\n      free(p);\n      query_is_modified = replaced = true;\n    }\n\n    if(!replaced && o->force_replace) {\n      addqpair(key.str, strlen(key.str), o->jsonout);\n      query_is_modified = true;\n    }\n  }\n  return query_is_modified;\n}\n\nstatic CURLUcode seturl(struct option *o, CURLU *uh, const char *url)\n{\n  return curl_url_set(uh, CURLUPART_URL, url,\n                      (o->no_guess_scheme ?\n                       0 : CURLU_GUESS_SCHEME)|\n                      (o->curl ? 0 : CURLU_NON_SUPPORT_SCHEME)|\n                      (o->accept_space ?\n                       CURLU_ALLOW_SPACE : 0)|\n                      CURLU_URLENCODE);\n}\n\nstatic char *canonical_path(const char *path)\n{\n  /* split the path per slash, URL decode + encode, then put together again */\n  size_t len = strlen(path);\n  char *sl;\n  char *dupe = NULL;\n\n  do {\n    char *opath;\n    char *npath;\n    char *ndupe;\n    int olen;\n    sl = memchr(path, '/', len);\n    size_t partlen = sl ? (size_t)(sl - path) : len;\n\n    if(partlen) {\n      /* First URL decode the part */\n      opath = curl_easy_unescape(NULL, path, (int)partlen, &olen);\n      if(!opath)\n        return NULL;\n\n      /* Then URL encode it again */\n      npath = curl_easy_escape(NULL, opath, olen);\n      curl_free(opath);\n      if(!npath)\n        return NULL;\n\n      ndupe = curl_maprintf(\"%s%s%s\", dupe ? dupe : \"\", npath, sl ? \"/\": \"\");\n      curl_free(npath);\n    }\n    else if(sl) {\n      /* zero length part but a slash */\n      ndupe = curl_maprintf(\"%s/\", dupe ? dupe : \"\");\n    }\n    else {\n      /* no part, no slash */\n      break;\n    }\n    curl_free(dupe);\n    if(!ndupe)\n      return NULL;\n\n    dupe = ndupe;\n    if(sl) {\n      path = sl + 1;\n      len -= partlen + 1;\n    }\n\n  } while(sl);\n\n  return dupe;\n}\n\nstatic void normalize_part(struct option *o, CURLU *uh, CURLUPart part)\n{\n  char *ptr;\n  size_t ptrlen = 0;\n  (void)curl_url_get(uh, part, &ptr, 0);\n\n  if(ptr)\n    ptrlen = strlen(ptr);\n\n  if(ptrlen) {\n    int olen;\n    char *uptr;\n    /* First URL decode the component */\n    char *rawptr = curl_easy_unescape(NULL, ptr, (int)ptrlen, &olen);\n    if(!rawptr)\n      errorf(o, ERROR_MEM, \"out of memory\");\n\n    /* Then URL encode it again */\n    uptr = curl_easy_escape(NULL, rawptr, olen);\n    curl_free(rawptr);\n    if(!uptr)\n      errorf(o, ERROR_MEM, \"out of memory\");\n\n    if(strcmp(ptr, uptr))\n      /* changed, store the updated one */\n      (void)curl_url_set(uh, part, uptr, 0);\n    curl_free(uptr);\n  }\n  curl_free(ptr);\n}\n\n\nstatic void singleurl(struct option *o,\n                      const char *url, /* might be NULL */\n                      struct iterinfo *iinfo,\n                      struct curl_slist *iter)\n{\n  CURLU *uh = iinfo->uh;\n  bool first_lap = true;\n  if(!uh) {\n    uh = curl_url();\n    if(!uh)\n      errorf(o, ERROR_MEM, \"out of memory\");\n    if(url) {\n      CURLUcode rc = seturl(o, uh, url);\n      if(rc) {\n        curl_url_cleanup(uh);\n        verify(o, ERROR_BADURL, \"%s [%s]\", curl_url_strerror(rc), url);\n        return;\n      }\n      if(o->redirect) {\n        rc = seturl(o, uh, o->redirect);\n        if(rc) {\n          curl_url_cleanup(uh);\n          verify(o, ERROR_BADURL, \"invalid redirection: %s [%s]\",\n                 curl_url_strerror(rc), o->redirect);\n          return;\n        }\n      }\n    }\n  }\n  do {\n    struct curl_slist *p;\n    bool url_is_invalid = false;\n    bool query_is_modified = false;\n    unsigned setmask = 0;\n\n    /* set everything */\n    setmask = set(uh, o);\n\n    if(iter) {\n      char iterbuf[1024];\n      /* \"part=item1 item2 item2\" */\n      const char *part;\n      size_t plen;\n      const char *w;\n      size_t wlen;\n      char *sep;\n      bool urlencode = true;\n      const struct var *v;\n\n      if(!iinfo->ptr) {\n        part = iter->data;\n        sep = strchr(part, '=');\n        if(!sep)\n          errorf(o, ERROR_ITER, \"wrong iterate syntax\");\n        plen = sep - part;\n        if(sep[-1] == ':') {\n          urlencode = false;\n          plen--;\n        }\n        w = sep + 1;\n        /* store for next lap */\n        iinfo->part = part;\n        iinfo->plen = plen;\n        v = comp2var(part, plen);\n        if(!v) {\n          curl_url_cleanup(uh);\n          errorf(o, ERROR_ITER, \"bad component for iterate\");\n        }\n        if(iinfo->varmask & (1<<v->part)) {\n          curl_url_cleanup(uh);\n          errorf(o, ERROR_ITER,\n                       \"duplicate component for iterate: %s\", v->name);\n        }\n        if(setmask & (1 << v->part)) {\n          curl_url_cleanup(uh);\n          errorf(o, ERROR_ITER,\n                 \"duplicate --iterate and --set for component %s\",\n                 v->name);\n        }\n      }\n      else {\n        part = iinfo->part;\n        plen = iinfo->plen;\n        v = comp2var(part, plen);\n        w = iinfo->ptr;\n      }\n\n      sep = strchr(w, ' ');\n      if(sep) {\n        wlen = sep - w;\n        iinfo->ptr = sep + 1; /* next word is here */\n      }\n      else {\n        /* last word */\n        wlen = strlen(w);\n        iinfo->ptr = NULL;\n      }\n      (void)curl_msnprintf(iterbuf, sizeof(iterbuf),\n                           \"%.*s%s=%.*s\", (int)plen, part,\n                           urlencode ? \"\" : \":\",\n                           (int)wlen, w);\n      setone(uh, iterbuf, o);\n      if(iter->next) {\n        struct iterinfo info;\n        memset(&info, 0, sizeof(info));\n        info.uh = uh;\n        info.varmask = iinfo->varmask | (1 << v->part);\n        singleurl(o, url, &info, iter->next);\n      }\n    }\n\n    if(first_lap) {\n      /* extract the current path */\n      char *opath;\n      char *cpath;\n      bool path_is_modified = false;\n      if(curl_url_get(uh, CURLUPART_PATH, &opath, 0))\n        errorf(o, ERROR_MEM, \"out of memory\");\n\n      /* append path segments */\n      for(p = o->append_path; p; p = p->next) {\n        char *apath = p->data;\n        char *npath;\n        size_t olen;\n\n        /* does the existing path end with a slash, then don't\n           add one in between */\n        olen = strlen(opath);\n\n        /* append the new segment */\n        npath = curl_maprintf(\"%s%s%s\", opath,\n                              opath[olen-1] == '/' ? \"\" : \"/\",\n                              apath);\n        curl_free(opath);\n        opath = npath;\n        path_is_modified = true;\n      }\n      cpath = canonical_path(opath);\n      if(!cpath)\n        errorf(o, ERROR_MEM, \"out of memory\");\n\n      if(strcmp(cpath, opath)) {\n        /* updated */\n        path_is_modified = true;\n        curl_free(opath);\n        opath = cpath;\n      }\n      else\n        curl_free(cpath);\n      if(path_is_modified) {\n        /* set the new path */\n        if(curl_url_set(uh, CURLUPART_PATH, opath, 0))\n          errorf(o, ERROR_MEM, \"out of memory\");\n      }\n      curl_free(opath);\n\n      normalize_part(o, uh, CURLUPART_FRAGMENT);\n      normalize_part(o, uh, CURLUPART_USER);\n      normalize_part(o, uh, CURLUPART_PASSWORD);\n      normalize_part(o, uh, CURLUPART_OPTIONS);\n    }\n\n    query_is_modified |= extractqpairs(uh, o);\n\n    /* trim parts */\n    query_is_modified |= trim(o);\n\n    /* replace parts */\n    query_is_modified |= replace(o);\n\n    if(first_lap) {\n      /* append query segments */\n      for(p = o->append_query; p; p = p->next) {\n        addqpair(p->data, strlen(p->data), o->jsonout);\n        query_is_modified = true;\n      }\n    }\n\n    /* sort query */\n    query_is_modified |= sortquery(o);\n\n    /* put the query back */\n    if(query_is_modified)\n      qpair2query(uh, o);\n\n    /* make sure the URL is still valid */\n    if(!url || o->redirect || o->set_list || o->append_path) {\n      char *ourl = NULL;\n      CURLUcode rc = curl_url_get(uh, CURLUPART_URL, &ourl, 0);\n      if(rc) {\n        if(o->verify) /* only clean up if we're exiting */\n          curl_url_cleanup(uh);\n        verify(o, ERROR_URL, \"not enough input for a URL\");\n        url_is_invalid = true;\n      }\n      else {\n        rc = seturl(o, uh, ourl);\n        if(rc) {\n          if(o->verify) /* only clean up if we're exiting */\n            curl_url_cleanup(uh);\n          verify(o, ERROR_BADURL, \"%s [%s]\", curl_url_strerror(rc),\n                 ourl);\n          url_is_invalid = true;\n        }\n        else {\n          char *nurl = NULL;\n          rc = curl_url_get(uh, CURLUPART_URL, &nurl, 0);\n          if(!rc)\n            curl_free(nurl);\n          else {\n            if(o->verify) /* only clean up if we're exiting */\n              curl_url_cleanup(uh);\n            verify(o, ERROR_BADURL, \"url became invalid\");\n            url_is_invalid = true;\n          }\n        }\n        curl_free(ourl);\n      }\n    }\n\n    if(iter && iter->next)\n      ;\n    else if(url_is_invalid)\n      ;\n    else if(o->jsonout)\n      json(o, uh);\n    else if(o->format) {\n      /* custom output format */\n      get(o, uh);\n    }\n    else {\n      /* default output is full URL */\n      char *nurl = NULL;\n      int rc = geturlpart(o, 0, uh, CURLUPART_URL, &nurl);\n      if(!rc) {\n        printf(\"%s\\n\", nurl);\n        curl_free(nurl);\n      }\n    }\n\n    fflush(stdout);\n\n    freeqpairs();\n\n    o->urls++;\n\n    first_lap = false;\n  } while(iinfo->ptr);\n  if(!iinfo->uh)\n    curl_url_cleanup(uh);\n}\n\nint main(int argc, const char **argv)\n{\n  int exit_status = 0;\n  struct option o;\n  struct curl_slist *node;\n  memset(&o, 0, sizeof(o));\n  setlocale(LC_ALL, \"\");\n  curl_global_init(CURL_GLOBAL_ALL);\n\n  for(argc--, argv++; argc > 0; argc--, argv++) {\n    bool usedarg = false;\n    if(!o.end_of_options && argv[0][0] == '-') {\n      /* dash-dash prefixed */\n      if(getarg(&o, argv[0], argv[1], &usedarg)) {\n        /* if the long option ends with an equals sign, cut it there,\n           if it is a short option, show just two letters */\n        size_t not_e = argv[0][1] == '-' ? strcspn(argv[0], \"=\") : 2;\n        errorf(&o, ERROR_FLAG, \"unknown option: %.*s\", (int)not_e, argv[0]);\n      }\n    }\n    else {\n      /* this is a URL */\n      urladd(&o, argv[0]);\n    }\n    if(usedarg) {\n      /* skip the parsed argument */\n      argc--;\n      argv++;\n    }\n  }\n  if(!o.qsep)\n    o.qsep = \"&\";\n\n  if(o.jsonout)\n    putchar('[');\n\n  if(o.url) {\n    /* this is a file to read URLs from */\n    char buffer[4096]; /* arbitrary max */\n    bool end_of_file = false;\n    while(!end_of_file && fgets(buffer, sizeof(buffer), o.url)) {\n      char *eol = strchr(buffer, '\\n');\n      if(eol && (eol > buffer)) {\n        if(eol[-1] == '\\r')\n          /* CRLF detected */\n          eol--;\n      }\n      else if(eol == buffer) {\n        /* empty line */\n        continue;\n      }\n      else if(feof(o.url)) {\n        /* end of file */\n        eol = strlen(buffer) + buffer;\n        end_of_file = true;\n      }\n      else {\n        /* line too long */\n        int ch;\n        trurl_warnf(&o, \"skipping long line\");\n        do {\n          ch = getc(o.url);\n        } while(ch != EOF && ch != '\\n');\n        if(ch == EOF) {\n          if(ferror(o.url))\n            trurl_warnf(&o, \"getc: %s\", strerror(errno));\n          end_of_file = true;\n        }\n        continue;\n      }\n\n      /* trim trailing spaces and tabs */\n      while((eol > buffer) &&\n            ((eol[-1] == ' ') || eol[-1] == '\\t'))\n        eol--;\n\n      if(eol > buffer) {\n        /* if there is actual content left to deal with */\n        struct iterinfo iinfo;\n        memset(&iinfo, 0, sizeof(iinfo));\n        *eol = 0; /* end of URL */\n        singleurl(&o, buffer, &iinfo, o.iter_list);\n      }\n    }\n\n    if(!end_of_file && ferror(o.url))\n      trurl_warnf(&o, \"fgets: %s\", strerror(errno));\n    if(o.urlopen)\n      fclose(o.url);\n  }\n  else {\n    /* not reading URLs from a file */\n    node = o.url_list;\n    do {\n      if(node) {\n        const char *url = node->data;\n        struct iterinfo iinfo;\n        memset(&iinfo, 0, sizeof(iinfo));\n        singleurl(&o, url, &iinfo, o.iter_list);\n        node = node->next;\n      }\n      else {\n        struct iterinfo iinfo;\n        memset(&iinfo, 0, sizeof(iinfo));\n        o.verify = true;\n        singleurl(&o, NULL, &iinfo, o.iter_list);\n      }\n    } while(node);\n  }\n  if(o.jsonout)\n    printf(\"%s]\\n\", o.urls ? \"\\n\" : \"\");\n  /* we're done with libcurl, so clean it up */\n  trurl_cleanup_options(&o);\n  curl_global_cleanup();\n  return exit_status;\n}\n"
        },
        {
          "name": "trurl.md",
          "type": "blob",
          "size": 23.9091796875,
          "content": "---\nc: Copyright (C) Daniel Stenberg, <daniel.se>, et al.\nSPDX-License-Identifier: curl\nTitle: trurl\nSection: 1\nSource: trurl 0.16\nSee-also:\n  - curl (1)\n  - wcurl (1)\n---\n\n# NAME\n\ntrurl - transpose URLs\n\n# SYNOPSIS\n\n**trurl [options / URLs]**\n\n# DESCRIPTION\n\n**trurl** parses, manipulates and outputs URLs and parts of URLs.\n\nIt uses the RFC 3986 definition of URLs and it uses libcurl's URL parser to do\nso, which includes a few \"extensions\". The URL support is limited to\n\"hierarchical\" URLs, the ones that use `://` separators after the scheme.\n\nTypically you pass in one or more URLs and decide what of that you want\noutput. Possibly modifying the URL as well.\n\ntrurl knows URLs and every URL consists of up to ten separate and independent\n*components*. These components can be extracted, removed and updated with\ntrurl and they are referred to by their respective names: scheme, user,\npassword, options, host, port, path, query, fragment and zoneid.\n\n# NORMALIZATION\n\nWhen provided a URL to work with, trurl \"normalizes\" it. It means that\nindividual URL components are URL decoded then URL encoded back again and set\nin the URL.\n\nExample:\n\n    $ trurl 'http://ex%61mple:80/%62ath/a/../b?%2e%FF#tes%74'\n    http://example/bath/b?.%ff#test\n\n# OPTIONS\n\nOptions start with one or two dashes. Many of the options require an\nadditional value next to them.\n\nAny other argument is interpreted as a URL argument, and is treated as if it\nwas following a `--url` option.\n\nThe first argument that is exactly two dashes (`--`), marks the end of\noptions; any argument after the end of options is interpreted as a URL\nargument even if it starts with a dash.\n\nLong options can be provided either as `--flag argument` or as\n`--flag=argument`.\n\n## -a, --append [component]=[data]\n\nAppend data to a component. This can only append data to the path and the\nquery components.\n\nFor path, this URL encodes and appends the new segment to the path, separated\nwith a slash.\n\nFor query, this URL encodes and appends the new segment to the query,\nseparated with an ampersand (&). If the appended segment contains an equal\nsign (`=`) that one is kept verbatim and both sides of the first occurrence\nare URL encoded separately.\n\n## --accept-space\n\nWhen set, trurl tries to accept spaces as part of the URL and instead URL\nencode such occurrences accordingly.\n\nAccording to RFC 3986, a space cannot legally be part of a URL. This option\nprovides a best-effort to convert the provided string into a valid URL.\n\n## --as-idn\n\nConverts a punycode ASCII hostname to its original International Domain Name\nin Unicode. If the hostname is not using punycode then the original hostname\nis used.\n\n## --curl\n\nOnly accept URL schemes supported by libcurl.\n\n## --default-port\n\nWhen set, trurl uses the scheme's default port number for URLs with a known\nscheme, and without an explicit port number.\n\nNote that trurl only knows default port numbers for URL schemes that are\nsupported by libcurl.\n\nSince, by default, trurl removes default port numbers from URLs with a known\nscheme, this option is pretty much ignored unless one of *--get*, *--json*,\nand *--keep-port* is not also specified.\n\n## -f, --url-file [filename]\n\nRead URLs to work on from the given file. Use the filename `-` (a single\nminus) to tell trurl to read the URLs from stdin.\n\nEach line needs to be a single valid URL. trurl removes one carriage return\ncharacter at the end of the line if present, trims off all the trailing space\nand tab characters, and skips all empty (after trimming) lines.\n\nThe maximum line length supported in a file like this is 4094 bytes. Lines\nthat exceed that length are skipped, and a warning is printed to stderr when\nthey are encountered.\n\n## -g, --get [format]\n\nOutput text and URL data according to the provided format string. Components\nfrom the URL can be output when specified as **{component}** or\n**[component]**, with the name of the part show within curly braces or\nbrackets. You can not mix braces and brackets for this purpose in the same\ncommand line.\n\nThe following component names are available (case sensitive): url, scheme,\nuser, password, options, host, port, path, query, fragment and zoneid.\n\n**{component}** expands to nothing if the given component does not have a\nvalue.\n\nComponents are shown URL decoded by default.\n\nURL decoding a component may cause problems to display it. Such problems make\na warning get displayed unless **--quiet** is used.\n\ntrurl supports a range of different qualifiers, or prefixes, to the component\nthat changes how it handles it:\n\nIf **url:** is specified, like `{url:path}`, the component gets output URL\nencoded. As a shortcut, `url:` also works written as a single colon:\n`{:path}`.\n\nIf **strict:** is specified, like `{strict:path}`, URL decode problems are\nturned into errors. In this stricter mode, a URL decode problem makes trurl\nstop what it is doing and return with exit code 10.\n\nIf **must:** is specified, like `{must:query}`, it makes trurl return an error\nif the requested component does not exist in the URL. By default a missing\ncomponent will just be shown blank.\n\nIf **default:** is specified, like `{default:url}` or `{default:port}`, and\nthe port is not explicitly specified in the URL, the scheme's default port is\noutput if it is known.\n\nIf **puny:** is specified, like `{puny:url}` or `{puny:host}`, the punycoded\nversion of the hostname is used in the output. This option is mutually\nexclusive with **idn:**.\n\nIf **idn:** is specified like `{idn:url}` or `{idn:host}`, the International\nDomain Name version of the hostname is used in the output if it is provided\nas a correctly encoded punycode version. This option is mutually exclusive\nwith **puny:**.\n\nIf *--default-port* is specified, all formats are expanded as if they used\n*default:*; and if *--punycode* is used, all formats are expanded as if they\nused *puny:*. Also note that `{url}` is affected by the *--keep-port* option.\n\nHosts provided as IPv6 numerical addresses are provided within square\nbrackets. Like `[fe80::20c:29ff:fe9c:409b]`.\n\nHosts provided as IPv4 numerical addresses are *normalized* and provided as\nfour dot-separated decimal numbers when output.\n\nYou can access specific keys in the query string using the format\n**{query:key}**. Then the value of the first matching key is output using a\ncase sensitive match. When extracting a URL decoded query key that contains\n`%00`, such octet is replaced with a single period `.` in the output.\n\nYou can access specific keys in the query string and out all values using the\nformat **{query-all:key}**. This looks for *key* case sensitively and outputs\nall values for that key space-separated.\n\nThe *format* string supports the following backslash sequences:\n\n\\\\ - backslash\n\n\\\\t - tab\n\n\\\\n - newline\n\n\\\\r - carriage return\n\n\\\\{ - an open curly brace that does not start a variable\n\n\\\\[ - an open bracket that does not start a variable\n\nAll other text in the format string is shown as-is.\n\n## -h, --help\n\nShow the help output.\n\n## --iterate [component]=[item1 item2 ...]\n\nSet the component to multiple values and output the result once for each\niteration. Several combined iterations are allowed to generate combinations,\nbut only one *--iterate* option per component. The listed items to iterate\nover should be separated by single spaces.\n\nExample:\n\n    $ trurl example.com --iterate=scheme=\"ftp https\" --iterate=port=\"22 80\"\n    ftp://example.com:22/\n    ftp://example.com:80/\n    https://example.com:22/\n    https://example.com:80/\n\n## --json\n\nOutputs all set components of the URLs as JSON objects. All components of the\nURL that have data get populated in the parts object using their component\nnames. See below for details on the format.\n\nThe URL components are provided URL decoded. Change that with **--urlencode**.\n\n## --keep-port\n\nBy default, trurl removes default port numbers from URLs with a known scheme\neven if they are explicitly specified in the input URL. This options, makes\ntrurl not remove them.\n\nExample:\n\n    $ trurl https://example.com:443/ --keep-port\n    https://example.com:443/\n\n## --no-guess-scheme\n\nDisables libcurl's scheme guessing feature. URLs that do not contain a scheme\nare treated as invalid URLs.\n\nExample:\n\n    $ trurl example.com --no-guess-scheme\n    trurl note: Bad scheme [example.com]\n\n## --punycode\n\nUses the punycode version of the hostname, which is how International Domain\nNames are converted into plain ASCII. If the hostname is not using IDN, the\nregular ASCII name is used.\n\nExample:\n\n    $ trurl http://åäö/ --punycode\n    http://xn--4cab6c/\n\n## --qtrim [what]\n\nTrims data off a query.\n\n*what* is specified as a full name of a name/value pair, or as a word prefix\n(using a single trailing asterisk (`*`)) which makes trurl remove the tuples\nfrom the query string that match the instruction.\n\nTo match a literal trailing asterisk instead of using a wildcard, escape it\nwith a backslash in front of it. Like `\\\\*`.\n\n## --query-separator [what]\n\nSpecify the single letter used for separating query pairs. The default is `&`\nbut at least in the past sometimes semicolons `;` or even colons `:` have been\nused for this purpose. If your URL uses something other than the default\nletter, setting the right one makes sure trurl can do its query operations\nproperly.\n\nExample:\n\n    $ trurl \"https://curl.se?b=name:a=age\" --sort-query --query-separator \":\"\n    https://curl.se/?a=age:b=name\n\n## --quiet\n\nSuppress (some) notes and warnings.\n\n## --redirect [URL]\n\nRedirect the URL to this new location. The redirection is performed on the\nbase URL, so, if no base URL is specified, no redirection is performed.\n\nExample:\n\n    $ trurl --url https://curl.se/we/are.html --redirect ../here.html\n    https://curl.se/here.html\n\n## --replace [data]\n\nReplaces a URL query.\n\ndata can either take the form of a single value, or as a key/value pair in the\nshape *foo=bar*. If replace is called on an item that is not in the list of\nqueries trurl ignores that item.\n\ntrurl URL encodes both sides of the `=` character in the given input data\nargument.\n\n## --replace-append [data]\n\nWorks the same as *--replace*, but trurl appends a missing query string if\nit is not in the query list already.\n\n## -s, --set [component][:]=[data]\n\nSet this URL component. Setting blank string (`\"\"`) clears the component from\nthe URL.\n\nThe following components can be set: url, scheme, user, password, options,\nhost, port, path, query, fragment and zoneid.\n\nIf a simple `=`-assignment is used, the data is URL encoded when applied. If\n`:=` is used, the data is assumed to already be URL encoded and stored as-is.\n\nIf `?=` is used, the set is only performed if the component is not already\nset. It avoids overwriting any already set data.\n\nYou can also combine `:` and `?` into `?:=` if desired.\n\nIf no URL or *--url-file* argument is provided, trurl tries to create a URL\nusing the components provided by the *--set* options. If not enough components\nare specified, this fails.\n\n## --sort-query\n\nThe \"variable=content\" tuplets in the query component are sorted in a case\ninsensitive alphabetical order. This helps making URLs identical that\notherwise only had their query pairs in different orders.\n\n## --trim [component]=[what]\n\nDeprecated: use **--qtrim**.\n\nTrims data off a component. Currently this can only trim a query component.\n\n*what* is specified as a full word or as a word prefix (using a single\ntrailing asterisk (`*`)) which makes trurl remove the tuples from the query\nstring that match the instruction.\n\nTo match a literal trailing asterisk instead of using a wildcard, escape it\nwith a backslash in front of it. Like `\\\\*`.\n\n## --url [URL]\n\nSet the input URL to work with. The URL may be provided without a scheme,\nwhich then typically is not actually a legal URL but trurl tries to figure\nout what is meant and guess what scheme to use (unless *--no-guess-scheme*\nis used).\n\nProviding multiple URLs makes trurl act on all URLs in a serial fashion.\n\nIf the URL cannot be parsed for whatever reason, trurl simply moves on to\nthe next provided URL - unless *--verify* is used.\n\n## --urlencode\n\nOutputs URL encoded version of components by default when using *--get* or\n*--json*.\n\n## -v, --version\n\nShow version information and exit.\n\n## --verify\n\nWhen a URL is provided, return error immediately if it does not parse as a\nvalid URL. In normal cases, trurl can forgive a bad URL input.\n\n# URL COMPONENTS\n\n## scheme\n\nThis is the leading character sequence of a URL, excluding the \"://\"\nseparator. It cannot be specified URL encoded.\n\nA URL cannot exist without a scheme, but unless **--no-guess-scheme** is used\ntrurl guesses what scheme that was intended if none was provided.\n\nExamples:\n\n    $ trurl https://odd/ -g '{scheme}'\n    https\n\n    $ trurl odd -g '{scheme}'\n    http\n\n    $ trurl odd -g '{scheme}' --no-guess-scheme\n    trurl note: Bad scheme [odd]\n\n## user\n\nAfter the scheme separator, there can be a username provided. If it ends with\na colon (`:`), there is a password provided. If it ends with an at character\n(`@`) there is no password provided in the URL.\n\nExample:\n\n    $ trurl https://user%3a%40:secret@odd/ -g '{user}'\n    user:@\n\n## password\n\nIf the password ends with a semicolon (`;`) there is an options field\nfollowing. This field is only accepted by trurl for URLs using the IMAP\nscheme.\n\nExample:\n\n    $ trurl https://user:secr%65t@odd/ -g '{password}'\n    secret\n\n## options\n\nThis field can only end with an at character (`@`) that separates the options\nfrom the hostname.\n\n    $ trurl 'imap://user:pwd;giraffe@odd' -g '{options}'\n    giraffe\n\nIf the scheme is not IMAP, the `giraffe` part is instead considered part of\nthe password:\n\n    $ trurl 'sftp://user:pwd;giraffe@odd' -g '{password}'\n    pwd;giraffe\n\nWe strongly advice users to %-encode `;`, `:` and `@` in URLs of course to\nreduce the risk for confusions.\n\n## host\n\nThe host component is the hostname or a numerical IP address. If a hostname is\nprovided, it can be an International Domain Name non-ASCII characters. A\nhostname can be provided URL encoded.\n\ntrurl provides options for working with the IDN hostnames either as IDN or in\nits punycode version.\n\nExample, convert an IDN name to punycode in the output:\n\n    $ trurl http://åäö/ --punycode\n    http://xn--4cab6c/\n\nOr the reverse, convert a punycode hostname into its IDN version:\n\n    $ trurl http://xn--4cab6c/ --as-idn\n    http://åäö/\n\nIf the URL's hostname starts with an open bracket (`[`) it is a numerical IPv6\naddress that also must end with a closing bracket (`]`). trurl normalizes IPv6\naddreses.\n\nExample:\n\n    $ trurl 'http://[2001:9b1:0:0:0:0:7b97:364b]/'\n    http://[2001:9b1::7b97:364b]/\n\nA numerical IPV4 address can be specified using one, two, three or four\nnumbers separated with dots and they can use decimal, octal or hexadecimal.\ntrurl normalizes provided addresses and uses four dotted decimal numbers in\nits output.\n\nExamples:\n\n    $ trurl http://646464646/\n    http://38.136.68.134/\n\n    $ trurl http://246.646/\n    http://246.0.2.134/\n\n    $ trurl http://246.46.646/\n    http://246.46.2.134/\n\n    $ trurl http://0x14.0xb3022/\n    http://20.11.48.34/\n\n## zoneid\n\nIf the provided host is an IPv6 address, it might contain a specific zoneid. A\nnumber or a network interface name normally.\n\nExample:\n\n    $ trurl 'http://[2001:9b1::f358:1ba4:7b97:364b%enp3s0]/' -g '{zoneid}'\n    enp3s0\n\n## port\n\nIf the host ends with a colon (`:`) then a port number follows. It is a 16 bit\ndecimal number that may not be URL encoded.\n\ntrurl knows the default port number for many URL schemes so it can show port\nnumbers for a URL even if none was explicitly used in the URL. With\n**--default-port** it can add the default port to a URL even when not provide.\n\nExample:\n\n    $ trurl http:/a --default-port\n    http://a:80/\n\nSimilarly, trurl normally hides the port number if the given number is the\ndefault.\n\nExample:\n\n    $ trurl http:/a:80\n    http://a/\n\nBut a user can make trurl keep the port even if it is the default, with\n**--keep-port**.\n\nExample:\n\n    $ trurl http:/a:80 --keep-port\n    http://a:80/\n\n## path\n\nA URL path is assumed to always start with and contain at least a slash (`/`),\neven if none is actually provided in the URL.\n\nExample:\n\n    $ trurl http://xn--4cab6c -g '[path]'\n    /\n\nWhen setting the path, trurl will inject a leading slash if none is provided:\n\n    $ trurl http://hello -s path=\"pony\"\n    http://hello/pony\n\n    $ trurl http://hello -s path=\"/pony\"\n    http://hello/pony\n\nIf the input path contains dotdot or dot-slash sequences, they are normalized\naway.\n\nExample:\n\n    $ trurl http://hej/one/../two/../three/./four\n    http://hej/three/four\n\nYou can append a new segment to an existing path with **--append** like this:\n\n    $ trurl http://twelve/three?hello --append path=four\n    http://twelve/three/four?hello\n\n## query\n\nThe query part does not include the leading question mark (`?`) separator when\nextracted with trurl.\n\nExample:\n\n    $ trurl http://horse?elephant -g '{query}'\n    elephant\n\nExample, if you set the query with a leading question mark:\n\n    $ trurl http://horse?elephant -s \"query=?elephant\"\n    http://horse/?%3felephant\n\nQuery parts are often made up of a series of name=value pairs separated with\nampersands (`&`), and trurl offers several ways to work with such.\n\nAppend a new name value pair to a URL with **--append**:\n\n    $ trurl http://host?name=hello --append query=search=life\n    http://host/?name=hello&search=life\n\nYou cam **--replace** the value of a specific existing name among the pairs:\n\n    $ trurl 'http://alpha?one=real&two=fake' --replace two=alsoreal\n    http://alpha/?one=real&two=alsoreal\n\nIf the specific name you want to replace perhaps does not exist in the URL,\nyou can opt to replace *or* append the pair:\n\n    $ trurl 'http://alpha?one=real&two=fake' --replace-append three=alsoreal\n    http://alpha/?one=real&two=fake&three=alsoreal\n\nIn order to perhaps compare two URLs using query name value pairs, sorting\nthem first at least increases the chances of it working:\n\n    $ trurl \"http://alpha/?one=real&two=fake&three=alsoreal\" --sort-query\n    http://alpha/?one=real&three=alsoreal&two=fake\n\nRemove name/value pairs from the URL by specifying exact name or wildcard\npattern with **--qtrim**:\n\n    $ trurl 'https://example.com?a12=hej&a23=moo&b12=foo' --qtrim a*'\n    https://example.com/?b12=foo\n\n## fragment\n\nThe fragment part does not include the leading hash sign (`#`) separator when\nextracted with trurl.\n\nExample:\n\n    $ trurl http://horse#elephant -g '{fragment}'\n    elephant\n\nExample, if you set the fragment with a leading hash sign:\n\n    $ trurl \"http://horse#elephant\" -s \"fragment=#zebra\"\n    http://horse/#%23zebra\n\nThe fragment part of a URL is for local purposes only. The data in there is\nnever actually sent over the network when a URL is used for transfers.\n\n## url\n\ntrurl supports **url** as a named component for **--get** to allow for more\npowerful outputs, but of course it is not actually a \"component\"; it is the\nfull URL.\n\nExample:\n\n    $ trurl ftps://example.com:2021/p%61th -g '{url}'\n    ftps://example.com:2021/path\n\n# JSON output format\n\nThe *--json* option outputs a JSON array with one or more objects. One for\neach URL. Each URL JSON object contains a number of properties, a series of\nkey/value pairs. The exact set present depends on the given URL.\n\n## url\n\nThis key exists in every object. It is the complete URL. Affected by\n*--default-port*, *--keep-port*, and *--punycode*.\n\n## parts\n\nThis key exists in every object, and contains an object with a key for each of\nthe settable URL components. If a component is missing, it means it is not\npresent in the URL. The parts are URL decoded unless *--urlencode* is used.\n\n## parts.scheme\nThe URL scheme.\n\n## parts.user\nThe username.\n\n## parts.password\nThe password.\n\n## parts.options\nThe options. Note that only a few URL schemes support the \"options\"\ncomponent.\n\n## parts.host\nThe normalized hostname. It might be a UTF-8 name if an IDN name was used. It\ncan also be a normalized IPv4 or IPv6 address. An IPv6 address always starts\nwith a bracket (**[**) - and no other hostnames can contain such a symbol. If\n*--punycode* is used, the punycode version of the host is outputted instead.\n\n## parts.port\nThe provided port number as a string. If the port number was not provided in\nthe URL, but the scheme is a known one, and *--default-port* is in use, the\ndefault port for that scheme is provided here.\n\n## parts.path\nThe path. Including the leading slash.\n\n## parts.query\nThe full query, excluding the question mark separator.\n\n## parts.fragment\nThe fragment, excluding the pound sign separator.\n\n## parts.zoneid\nThe zone id, which can only be present in an IPv6 address. When this key is\npresent, then **host** is an IPv6 numerical address.\n\n## params\n\nThis key contains an array of query key/value objects. Each such pair is\nlisted with \"key\" and \"value\" and their respective contents in the output.\n\nThe key/values are extracted from the query where they are separated by\nampersands (**&**) - or the user sets with **--query-separator**.\n\nThe query pairs are listed in the order of appearance in a left-to-right\norder, but can be made alpha-sorted with **--sort-query**.\n\nIt is only present if the URL has a query.\n\n# EXAMPLES\n\n## Replace the hostname of a URL\n\n~~~\n$ trurl --url https://curl.se --set host=example.com\nhttps://example.com/\n~~~\n\n## Create a URL by setting components\n\n~~~\n $ trurl --set host=example.com --set scheme=ftp\n ftp://example.com/\n~~~\n\n## Redirect a URL\n\n~~~\n$ trurl --url https://curl.se/we/are.html --redirect here.html\nhttps://curl.se/we/here.html\n~~~\n\n## Change port number\n\nThis also shows how trurl removes dot-dot sequences\n~~~\n$ trurl --url https://curl.se/we/../are.html --set port=8080\nhttps://curl.se:8080/are.html\n~~~\n\n## Extract the path from a URL\n\n~~~\n$ trurl --url https://curl.se/we/are.html --get '{path}'\n/we/are.html\n~~~\n\n## Extract the port from a URL\n\nThis gets the default port based on the scheme if the port is not set in the\nURL.\n~~~\n$ trurl --url https://curl.se/we/are.html --get '{default:port}'\n443\n~~~\n\n## Append a path segment to a URL\n\n~~~\n$ trurl --url https://curl.se/hello --append path=you\nhttps://curl.se/hello/you\n~~~\n\n## Append a query segment to a URL\n\n~~~\n$ trurl --url \"https://curl.se?name=hello\" --append query=search=string\n https://curl.se/?name=hello&search=string\n~~~\n\n## Read URLs from stdin\n\n~~~\n$ cat urllist.txt | trurl --url-file -\n\\&...\n~~~\n\n## Output JSON\n\n~~~\n$ trurl \"https://fake.host/search?q=answers&user=me#frag\" --json\n[\n  {\n    \"url\": \"https://fake.host/search?q=answers&user=me#frag\",\n    \"parts\": [\n        \"scheme\": \"https\",\n        \"host\": \"fake.host\",\n        \"path\": \"/search\",\n        \"query\": \"q=answers&user=me\"\n        \"fragment\": \"frag\",\n    ],\n    \"params\": [\n      {\n        \"key\": \"q\",\n        \"value\": \"answers\"\n      },\n      {\n        \"key\": \"user\",\n        \"value\": \"me\"\n      }\n    ]\n  }\n]\n~~~\n\n## Remove tracking tuples from query\n\n~~~\n$ trurl \"https://curl.se?search=hey&utm_source=tracker\" --qtrim \"utm_*\"\nhttps://curl.se/?search=hey\n~~~\n\n## Show a specific query key value\n\n~~~\n$ trurl \"https://example.com?a=home&here=now&thisthen\" -g '{query:a}'\nhome\n~~~\n\n## Sort the key/value pairs in the query component\n\n~~~\n$ trurl \"https://example.com?b=a&c=b&a=c\" --sort-query\nhttps://example.com?a=c&b=a&c=b\n~~~\n\n## Work with a query that uses a semicolon separator\n\n~~~\n$ trurl \"https://curl.se?search=fool;page=5\" --qtrim \"search\" --query-separator \";\"\nhttps://curl.se?page=5\n~~~\n\n## Accept spaces in the URL path\n\n~~~\n$ trurl \"https://curl.se/this has space/index.html\" --accept-space\nhttps://curl.se/this%20has%20space/index.html\n~~~\n\n## Create multiple variations of a URL with different schemes\n\n~~~\n$ trurl \"https://curl.se/path/index.html\" --iterate \"scheme=http ftp sftp\"\nhttp://curl.se/path/index.html\nftp://curl.se/path/index.html\nsftp://curl.se/path/index.html\n~~~\n\n# EXIT CODES\n\ntrurl returns a non-zero exit code to indicate problems.\n\n## 1\n\nA problem with --url-file\n\n## 2\n\nA problem with --append\n\n## 3\n\nA command line option misses an argument\n\n## 4\n\nA command line option mistake or an illegal option combination.\n\n## 5\n\nA problem with --set\n\n## 6\n\nOut of memory\n\n## 7\n\nCould not output a valid URL\n\n## 8\n\nA problem with --qtrim\n\n## 9\n\nIf --verify is set and the input URL cannot parse.\n\n## 10\n\nA problem with --get\n\n## 11\n\nA problem with --iterate\n\n## 12\n\nA problem with --replace or --replace-append\n\n# WWW\n\nhttps://curl.se/trurl\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 1.107421875,
          "content": "#ifndef TRURL_VERSION_H\n#define TRURL_VERSION_H\n/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * SPDX-License-Identifier: curl\n *\n ***************************************************************************/\n\n#define TRURL_VERSION_TXT \"0.16\"\n\n#endif\n"
        },
        {
          "name": "winbuild",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}