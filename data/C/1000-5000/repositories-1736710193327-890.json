{
  "metadata": {
    "timestamp": 1736710193327,
    "page": 890,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lieff/minimp3",
      "stars": 1649,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0791015625,
          "content": ".vscode\nfate-suite.ffmpeg.org\nplayer/SDL\nminimp3\nminimp3_arm\n*.gcda\n*.gcno\n*.gcov"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.638671875,
          "content": "dist: bionic\nlanguage: c\naddons:\n  apt:\n    packages:\n      - build-essential\n      - libc6-dev-i386\n      - linux-libc-dev:i386\n      - gcc-arm-none-eabi\n      - libnewlib-arm-none-eabi\n      - gcc-7-multilib\n      - gcc-7-aarch64-linux-gnu\n      - gcc-7-powerpc-linux-gnu\n      - gcc-aarch64-linux-gnu\n      - gcc-powerpc-linux-gnu\n      - libc6-arm64-cross\n      - libc6-powerpc-cross\n      - libc6-dev-arm64-cross\n      - libc6-dev-powerpc-cross\n      - qemu\n      - lcov\n\nos:\n    - linux\n\ncompiler:\n    - gcc\n\nscript:\n    - scripts/build.sh\n    - (pushd player/; ./build.sh linux; popd)\n\nafter_success:\n    - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 6.40234375,
          "content": "CC0 1.0 Universal\n\nStatement of Purpose\n\nThe laws of most jurisdictions throughout the world automatically confer\nexclusive Copyright and Related Rights (defined below) upon the creator and\nsubsequent owner(s) (each and all, an \"owner\") of an original work of\nauthorship and/or a database (each, a \"Work\").\n\nCertain owners wish to permanently relinquish those rights to a Work for the\npurpose of contributing to a commons of creative, cultural and scientific\nworks (\"Commons\") that the public can reliably and without fear of later\nclaims of infringement build upon, modify, incorporate in other works, reuse\nand redistribute as freely as possible in any form whatsoever and for any\npurposes, including without limitation commercial purposes. These owners may\ncontribute to the Commons to promote the ideal of a free culture and the\nfurther production of creative, cultural and scientific works, or to gain\nreputation or greater distribution for their Work in part through the use and\nefforts of others.\n\nFor these and/or other purposes and motivations, and without any expectation\nof additional consideration or compensation, the person associating CC0 with a\nWork (the \"Affirmer\"), to the extent that he or she is an owner of Copyright\nand Related Rights in the Work, voluntarily elects to apply CC0 to the Work\nand publicly distribute the Work under its terms, with knowledge of his or her\nCopyright and Related Rights in the Work and the meaning and intended legal\neffect of CC0 on those rights.\n\n1. Copyright and Related Rights. A Work made available under CC0 may be\nprotected by copyright and related or neighboring rights (\"Copyright and\nRelated Rights\"). Copyright and Related Rights include, but are not limited\nto, the following:\n\n  i. the right to reproduce, adapt, distribute, perform, display, communicate,\n  and translate a Work;\n\n  ii. moral rights retained by the original author(s) and/or performer(s);\n\n  iii. publicity and privacy rights pertaining to a person's image or likeness\n  depicted in a Work;\n\n  iv. rights protecting against unfair competition in regards to a Work,\n  subject to the limitations in paragraph 4(a), below;\n\n  v. rights protecting the extraction, dissemination, use and reuse of data in\n  a Work;\n\n  vi. database rights (such as those arising under Directive 96/9/EC of the\n  European Parliament and of the Council of 11 March 1996 on the legal\n  protection of databases, and under any national implementation thereof,\n  including any amended or successor version of such directive); and\n\n  vii. other similar, equivalent or corresponding rights throughout the world\n  based on applicable law or treaty, and any national implementations thereof.\n\n2. Waiver. To the greatest extent permitted by, but not in contravention of,\napplicable law, Affirmer hereby overtly, fully, permanently, irrevocably and\nunconditionally waives, abandons, and surrenders all of Affirmer's Copyright\nand Related Rights and associated claims and causes of action, whether now\nknown or unknown (including existing as well as future claims and causes of\naction), in the Work (i) in all territories worldwide, (ii) for the maximum\nduration provided by applicable law or treaty (including future time\nextensions), (iii) in any current or future medium and for any number of\ncopies, and (iv) for any purpose whatsoever, including without limitation\ncommercial, advertising or promotional purposes (the \"Waiver\"). Affirmer makes\nthe Waiver for the benefit of each member of the public at large and to the\ndetriment of Affirmer's heirs and successors, fully intending that such Waiver\nshall not be subject to revocation, rescission, cancellation, termination, or\nany other legal or equitable action to disrupt the quiet enjoyment of the Work\nby the public as contemplated by Affirmer's express Statement of Purpose.\n\n3. Public License Fallback. Should any part of the Waiver for any reason be\njudged legally invalid or ineffective under applicable law, then the Waiver\nshall be preserved to the maximum extent permitted taking into account\nAffirmer's express Statement of Purpose. In addition, to the extent the Waiver\nis so judged Affirmer hereby grants to each affected person a royalty-free,\nnon transferable, non sublicensable, non exclusive, irrevocable and\nunconditional license to exercise Affirmer's Copyright and Related Rights in\nthe Work (i) in all territories worldwide, (ii) for the maximum duration\nprovided by applicable law or treaty (including future time extensions), (iii)\nin any current or future medium and for any number of copies, and (iv) for any\npurpose whatsoever, including without limitation commercial, advertising or\npromotional purposes (the \"License\"). The License shall be deemed effective as\nof the date CC0 was applied by Affirmer to the Work. Should any part of the\nLicense for any reason be judged legally invalid or ineffective under\napplicable law, such partial invalidity or ineffectiveness shall not\ninvalidate the remainder of the License, and in such case Affirmer hereby\naffirms that he or she will not (i) exercise any of his or her remaining\nCopyright and Related Rights in the Work or (ii) assert any associated claims\nand causes of action with respect to the Work, in either case contrary to\nAffirmer's express Statement of Purpose.\n\n4. Limitations and Disclaimers.\n\n  a. No trademark or patent rights held by Affirmer are waived, abandoned,\n  surrendered, licensed or otherwise affected by this document.\n\n  b. Affirmer offers the Work as-is and makes no representations or warranties\n  of any kind concerning the Work, express, implied, statutory or otherwise,\n  including without limitation warranties of title, merchantability, fitness\n  for a particular purpose, non infringement, or the absence of latent or\n  other defects, accuracy, or the present or absence of errors, whether or not\n  discoverable, all to the greatest extent permissible under applicable law.\n\n  c. Affirmer disclaims responsibility for clearing rights of other persons\n  that may apply to the Work or any use thereof, including without limitation\n  any person's Copyright and Related Rights in the Work. Further, Affirmer\n  disclaims responsibility for obtaining any necessary consents, permissions\n  or other rights required for any use of the Work.\n\n  d. Affirmer understands and acknowledges that Creative Commons is not a\n  party to this document and has no duty or obligation with respect to this\n  CC0 or use of the Work.\n\nFor more information, please see\n<http://creativecommons.org/publicdomain/zero/1.0/>\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.6025390625,
          "content": "minimp3\n==========\n\n[![Build Status](https://travis-ci.org/lieff/minimp3.svg)](https://travis-ci.org/lieff/minimp3)\n<a href=\"https://scan.coverity.com/projects/lieff-minimp3\">\n  <img alt=\"Coverity Scan Build Status\"\n       src=\"https://scan.coverity.com/projects/14844/badge.svg\"/>\n</a>\n[![codecov](https://codecov.io/gh/lieff/minimp3/branch/master/graph/badge.svg)](https://codecov.io/gh/lieff/minimp3)\n\nMinimalistic, single-header library for decoding MP3. minimp3 is designed to be\nsmall, fast (with SSE and NEON support), and accurate (ISO conformant). You can\nfind a rough benchmark below, measured using ``perf`` on an i7-6700K, IO\nincluded, no CPU heat to address speedstep:\n\n| Vector      | Hz    | Samples| Sec    | Clockticks | Clockticks per second | PSNR | Max diff |\n| ----------- | ----- | ------ | ------ | --------- | ------ | ------ | - |\n|compl.bit    | 48000 | 248832 | 5.184  | 14306684  | 2.759M | 124.22 | 1 |\n|he_32khz.bit | 32000 | 172800 | 5.4    | 8426158   | 1.560M | 139.67 | 1 |\n|he_44khz.bit | 44100 | 472320 | 10.710 | 21296300  | 1.988M | 144.04 | 1 |\n|he_48khz.bit | 48000 | 172800 | 3.6    | 8453846   | 2.348M | 139.67 | 1 |\n|hecommon.bit | 44100 | 69120  | 1.567  | 3169715   | 2.022M | 133.93 | 1 |\n|he_free.bit  | 44100 | 156672 | 3.552  | 5798418   | 1.632M | 137.48 | 1 |\n|he_mode.bit  | 44100 | 262656 | 5.955  | 9882314   | 1.659M | 118.00 | 1 |\n|si.bit       | 44100 | 135936 | 3.082  | 7170520   | 2.326M | 120.30 | 1 |\n|si_block.bit | 44100 | 73728  | 1.671  | 4233136   | 2.533M | 125.18 | 1 |\n|si_huff.bit  | 44100 | 86400  | 1.959  | 4785322   | 2.442M | 107.98 | 1 |\n|sin1k0db.bit | 44100 | 725760 | 16.457 | 24842977  | 1.509M | 111.03 | 1 |\n\nConformance test passed on all vectors (PSNR > 96db).\n\n## Comparison with keyj's [minimp3](https://keyj.emphy.de/minimp3/)\n\nComparison by features:\n\n| Keyj minimp3 | Current |\n| ------------ | ------- |\n| Fixed point  | Floating point |\n| source: 84kb | 70kb |\n| binary: 34kb (20kb compressed) | 30kb (20kb) |\n| no vector opts | SSE/NEON intrinsics |\n| no free format | free format support |\n\nBelow, you can find the benchmark and conformance test for keyj's minimp3:\n\n\n| Vector      | Hz    | Samples| Sec    | Clockticks | Clockticks per second | PSNR | Max diff |\n| ----------- | ----- | ------ | ------ | --------- | ------  | ----- | - |\n|compl.bit    | 48000 | 248832 | 5.184  | 31849373  | 6.143M  | 71.50 | 41 |\n|he_32khz.bit | 32000 | 172800 | 5.4    | 26302319  | 4.870M  | 71.63 | 24 |\n|he_44khz.bit | 44100 | 472320 | 10.710 | 41628861  | 3.886M  | 71.63 | 24 |\n|he_48khz.bit | 48000 | 172800 | 3.6    | 25899527  | 7.194M  | 71.63 | 24 |\n|hecommon.bit | 44100 | 69120  | 1.567  | 20437779  | 13.039M | 71.58 | 25 |\n|he_free.bit  | 44100 | 0 | 0  | -  | - | -  | - |\n|he_mode.bit  | 44100 | 262656 | 5.955  | 30988984  | 5.203M  | 71.78 | 27 |\n|si.bit       | 44100 | 135936 | 3.082  | 24096223  | 7.817M  | 72.35 | 36 |\n|si_block.bit | 44100 | 73728  | 1.671  | 20722017  | 12.394M | 71.84 | 26 |\n|si_huff.bit  | 44100 | 86400  | 1.959  | 21121376  | 10.780M | 27.80 | 65535 |\n|sin1k0db.bit | 44100 | 730368 | 16.561 | 55569636  | 3.355M  | 0.15  | 58814 |\n\nKeyj minimp3 conformance test fails on all vectors (PSNR < 96db), and free\nformat is unsupported. This caused some problems when it was used\n[here](https://github.com/lieff/lvg), and was the main motivation for this work.\n\n## Usage\n\nFirst, we need to initialize the decoder structure:\n\n```c\n//#define MINIMP3_ONLY_MP3\n//#define MINIMP3_ONLY_SIMD\n//#define MINIMP3_NO_SIMD\n//#define MINIMP3_NONSTANDARD_BUT_LOGICAL\n//#define MINIMP3_FLOAT_OUTPUT\n#define MINIMP3_IMPLEMENTATION\n#include \"minimp3.h\"\n...\n    static mp3dec_t mp3d;\n    mp3dec_init(&mp3d);\n```\n\nNote that you must define ``MINIMP3_IMPLEMENTATION`` in exactly one source file.\nYou can ``#include`` ``minimp3.h`` in as many files as you like.\nAlso you can use ``MINIMP3_ONLY_MP3`` define to strip MP1/MP2 decoding code.\nMINIMP3_ONLY_SIMD define controls generic (non SSE/NEON) code generation (always enabled on x64/arm64 targets).\nIn case you do not want any platform-specific SIMD optimizations, you can define ``MINIMP3_NO_SIMD``.\nMINIMP3_NONSTANDARD_BUT_LOGICAL define saves some code bytes, and enforces non-standard but logical behaviour of mono-stereo transition (rare case).\nMINIMP3_FLOAT_OUTPUT makes ``mp3dec_decode_frame()`` output to be float instead of short and additional function mp3dec_f32_to_s16 will be available for float->short conversion if needed.\n\nThen. we decode the input stream frame-by-frame:\n\n```c\n    /*typedef struct\n    {\n        int frame_bytes;\n        int channels;\n        int hz;\n        int layer;\n        int bitrate_kbps;\n    } mp3dec_frame_info_t;*/\n    mp3dec_frame_info_t info;\n    short pcm[MINIMP3_MAX_SAMPLES_PER_FRAME];\n    /*unsigned char *input_buf; - input byte stream*/\n    samples = mp3dec_decode_frame(&mp3d, input_buf, buf_size, pcm, &info);\n```\n\nThe ``mp3dec_decode_frame()`` function decodes one full MP3 frame from the\ninput buffer, which must be large enough to hold one full frame.\n\nThe decoder will analyze the input buffer to properly sync with the MP3 stream,\nand will skip ID3 data, as well as any data which is not valid. Short buffers\nmay cause false sync and can produce 'squealing' artefacts. The bigger the size\nof the input buffer, the more reliable the sync procedure. We recommend having\nas many as 10 consecutive MP3 frames (~16KB) in the input buffer at a time.\n\nAt end of stream just pass rest of the buffer, sync procedure should work even\nwith just 1 frame in stream (except for free format and garbage at the end can\nmess things up, so id3v1 and ape tags must be removed first).\n\nFor free format there minimum 3 frames needed to do proper sync: 2 frames to\ndetect frame length and 1 next frame to check detect is good.\n\nThe size of the consumed MP3 data is returned in the ``mp3dec_frame_info_t``\nfield of the ``frame_bytes`` struct; you must remove the data corresponding to\nthe ``frame_bytes`` field  from the input buffer before the next decoder\ninvocation.\n\nThe decoding function returns the number of decoded samples. The following cases\nare possible:\n\n- **0:** No MP3 data was found in the input buffer\n- **384:**  Layer 1\n- **576:**  MPEG 2 Layer 3\n- **1152:** Otherwise\n\nThe following is a description of the possible combinations of the number of\nsamples and ``frame_bytes`` field values:\n\n- More than 0 samples and ``frame_bytes > 0``:  Succesful decode\n- 0 samples and ``frame_bytes >  0``: The decoder skipped ID3 or invalid data\n- 0 samples and ``frame_bytes == 0``: Insufficient data\n\nIf ``frame_bytes == 0``, the other fields may be uninitialized or unchanged; if\n``frame_bytes != 0``, the other fields are available. The application may call\n``mp3dec_init()`` when changing decode position, but this is not necessary.\n\nAs a special case, the decoder supports already split MP3 streams (for example,\nafter doing an MP4 demux). In this case, the input buffer must contain _exactly\none_ non-free-format frame.\n\n## Seeking\n\nYou can seek to any byte in the stream and call ``mp3dec_decode_frame``; this\nwill work in almost all cases, but is not completely guaranteed. Probablility of\nsync procedure failure lowers when MAX_FRAME_SYNC_MATCHES value grows. Default\nMAX_FRAME_SYNC_MATCHES=10 and probablility of sync failure should be very low.\nIf granule data is accidentally detected as a valid MP3 header, short audio artefacting is\npossible.\n\nHigh-level mp3dec_ex_seek function supports precise seek to sample (MP3D_SEEK_TO_SAMPLE)\nusing index and binary search.\n\n## Track length detect\n\nIf the file is known to be cbr, then all frames have equal size and\nlack ID3 tags, which allows us to decode the first frame and calculate all frame\npositions as ``frame_bytes * N``. However, because of padding, frames can differ\nin size even in this case.\n\nIn general case whole stream scan is needed to calculate it's length. Scan can be\nomitted if vbr tag is present (added by encoders like lame and ffmpeg), which contains\nlength info. High-level functions automatically use the vbr tag if present.\n\n## High-level API\n\nIf you need only decode file/buffer or use precise seek, you can use optional high-level API.\nJust ``#include`` ``minimp3_ex.h`` instead and use following additional functions:\n\n```c\n#define MP3D_SEEK_TO_BYTE   0\n#define MP3D_SEEK_TO_SAMPLE 1\n\n#define MINIMP3_PREDECODE_FRAMES 2 /* frames to pre-decode and skip after seek (to fill internal structures) */\n/*#define MINIMP3_SEEK_IDX_LINEAR_SEARCH*/ /* define to use linear index search instead of binary search on seek */\n#define MINIMP3_IO_SIZE (128*1024) /* io buffer size for streaming functions, must be greater than MINIMP3_BUF_SIZE */\n#define MINIMP3_BUF_SIZE (16*1024) /* buffer which can hold minimum 10 consecutive mp3 frames (~16KB) worst case */\n#define MINIMP3_ENABLE_RING 0      /* enable hardware magic ring buffer if available, to make less input buffer memmove(s) in callback IO mode */\n\n#define MP3D_E_MEMORY  -1\n#define MP3D_E_IOERROR -2\n\ntypedef struct\n{\n    mp3d_sample_t *buffer;\n    size_t samples; /* channels included, byte size = samples*sizeof(mp3d_sample_t) */\n    int channels, hz, layer, avg_bitrate_kbps;\n} mp3dec_file_info_t;\n\ntypedef size_t (*MP3D_READ_CB)(void *buf, size_t size, void *user_data);\ntypedef int (*MP3D_SEEK_CB)(uint64_t position, void *user_data);\n\ntypedef struct\n{\n    MP3D_READ_CB read;\n    void *read_data;\n    MP3D_SEEK_CB seek;\n    void *seek_data;\n} mp3dec_io_t;\n\ntypedef struct\n{\n    uint64_t samples;\n    mp3dec_frame_info_t info;\n    int last_error;\n    ...\n} mp3dec_ex_t;\n\ntypedef int (*MP3D_ITERATE_CB)(void *user_data, const uint8_t *frame, int frame_size, int free_format_bytes, size_t buf_size, uint64_t offset, mp3dec_frame_info_t *info);\ntypedef int (*MP3D_PROGRESS_CB)(void *user_data, size_t file_size, uint64_t offset, mp3dec_frame_info_t *info);\n\n/* decode whole buffer block */\nint mp3dec_load_buf(mp3dec_t *dec, const uint8_t *buf, size_t buf_size, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\nint mp3dec_load_cb(mp3dec_t *dec, mp3dec_io_t *io, uint8_t *buf, size_t buf_size, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\n/* iterate through frames */\nint mp3dec_iterate_buf(const uint8_t *buf, size_t buf_size, MP3D_ITERATE_CB callback, void *user_data);\nint mp3dec_iterate_cb(mp3dec_io_t *io, uint8_t *buf, size_t buf_size, MP3D_ITERATE_CB callback, void *user_data);\n/* streaming decoder with seeking capability */\nint mp3dec_ex_open_buf(mp3dec_ex_t *dec, const uint8_t *buf, size_t buf_size, int seek_method);\nint mp3dec_ex_open_cb(mp3dec_ex_t *dec, mp3dec_io_t *io, int seek_method);\nvoid mp3dec_ex_close(mp3dec_ex_t *dec);\nint mp3dec_ex_seek(mp3dec_ex_t *dec, uint64_t position);\nsize_t mp3dec_ex_read(mp3dec_ex_t *dec, mp3d_sample_t *buf, size_t samples);\n#ifndef MINIMP3_NO_STDIO\n/* stdio versions of file load, iterate and stream */\nint mp3dec_load(mp3dec_t *dec, const char *file_name, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\nint mp3dec_iterate(const char *file_name, MP3D_ITERATE_CB callback, void *user_data);\nint mp3dec_ex_open(mp3dec_ex_t *dec, const char *file_name, int seek_method);\n#ifdef _WIN32\nint mp3dec_load_w(mp3dec_t *dec, const wchar_t *file_name, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\nint mp3dec_iterate_w(const wchar_t *file_name, MP3D_ITERATE_CB callback, void *user_data);\nint mp3dec_ex_open_w(mp3dec_ex_t *dec, const wchar_t *file_name, int seek_method);\n#endif\n#endif\n```\n\nUse MINIMP3_NO_STDIO define to exclude STDIO functions.\nMINIMP3_ALLOW_MONO_STEREO_TRANSITION allows mixing mono and stereo in same file.\nIn that case ``mp3dec_frame_info_t->channels = 0`` is reported on such files and correct channels number passed to progress_cb callback for each frame in mp3dec_frame_info_t structure.\nMP3D_PROGRESS_CB is optional and can be NULL, example of file decoding:\n\n```c\n    mp3dec_t mp3d;\n    mp3dec_file_info_t info;\n    if (mp3dec_load(&mp3d, input_file_name, &info, NULL, NULL))\n    {\n        /* error */\n    }\n    /* mp3dec_file_info_t contains decoded samples and info,\n       use free(info.buffer) to deallocate samples */\n```\n\nExample of file decoding with seek capability:\n\n```c\n    mp3dec_ex_t dec;\n    if (mp3dec_ex_open(&dec, input_file_name, MP3D_SEEK_TO_SAMPLE))\n    {\n        /* error */\n    }\n    /* dec.samples, dec.info.hz, dec.info.layer, dec.info.channels should be filled */\n    if (mp3dec_ex_seek(&dec, position))\n    {\n        /* error */\n    }\n    mp3d_sample_t *buffer = malloc(dec.samples*sizeof(mp3d_sample_t));\n    size_t readed = mp3dec_ex_read(&dec, buffer, dec.samples);\n    if (readed != dec.samples) /* normal eof or error condition */\n    {\n        if (dec.last_error)\n        {\n            /* error */\n        }\n    }\n```\n\n## Bindings\n\n * https://github.com/tosone/minimp3 - go bindings\n * https://github.com/notviri/rmp3 - rust `no_std` bindings which don't allocate.\n * https://github.com/germangb/minimp3-rs - rust bindings\n * https://github.com/johangu/node-minimp3 - NodeJS bindings\n * https://github.com/pyminimp3/pyminimp3 - python bindings\n * https://github.com/bashi/minimp3-wasm - wasm bindings\n * https://github.com/DasZiesel/minimp3-delphi - delphi bindings\n * https://github.com/mgeier/minimp3_ex-sys - low-level rust bindings to `minimp3_ex`\n\n## Interesting links\n\n * https://keyj.emphy.de/minimp3/\n * https://github.com/technosaurus/PDMP3\n * https://github.com/technosaurus/PDMP2\n * https://github.com/packjpg/packMP3\n * https://sites.google.com/a/kmlager.com/www/projects\n * https://sourceforge.net/projects/mp3dec/\n * http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html\n * http://www.mp3-converter.com/mp3codec/\n * http://www.multiweb.cz/twoinches/mp3inside.htm\n * https://www.mp3-tech.org/\n * https://id3.org/mp3Frame\n * https://www.datavoyage.com/mpgscript/mpeghdr.htm\n"
        },
        {
          "name": "fuzzing",
          "type": "tree",
          "content": null
        },
        {
          "name": "huffopt",
          "type": "tree",
          "content": null
        },
        {
          "name": "minimp3.h",
          "type": "blob",
          "size": 75.001953125,
          "content": "#ifndef MINIMP3_H\n#define MINIMP3_H\n/*\n    https://github.com/lieff/minimp3\n    To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide.\n    This software is distributed without any warranty.\n    See <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n#include <stdint.h>\n\n#define MINIMP3_MAX_SAMPLES_PER_FRAME (1152*2)\n\ntypedef struct\n{\n    int frame_bytes, frame_offset, channels, hz, layer, bitrate_kbps;\n} mp3dec_frame_info_t;\n\ntypedef struct\n{\n    float mdct_overlap[2][9*32], qmf_state[15*2*32];\n    int reserv, free_format_bytes;\n    unsigned char header[4], reserv_buf[511];\n} mp3dec_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\nvoid mp3dec_init(mp3dec_t *dec);\n#ifndef MINIMP3_FLOAT_OUTPUT\ntypedef int16_t mp3d_sample_t;\n#else /* MINIMP3_FLOAT_OUTPUT */\ntypedef float mp3d_sample_t;\nvoid mp3dec_f32_to_s16(const float *in, int16_t *out, int num_samples);\n#endif /* MINIMP3_FLOAT_OUTPUT */\nint mp3dec_decode_frame(mp3dec_t *dec, const uint8_t *mp3, int mp3_bytes, mp3d_sample_t *pcm, mp3dec_frame_info_t *info);\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#endif /* MINIMP3_H */\n#if defined(MINIMP3_IMPLEMENTATION) && !defined(_MINIMP3_IMPLEMENTATION_GUARD)\n#define _MINIMP3_IMPLEMENTATION_GUARD\n\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_FREE_FORMAT_FRAME_SIZE  2304    /* more than ISO spec's */\n#ifndef MAX_FRAME_SYNC_MATCHES\n#define MAX_FRAME_SYNC_MATCHES      10\n#endif /* MAX_FRAME_SYNC_MATCHES */\n\n#define MAX_L3_FRAME_PAYLOAD_BYTES  MAX_FREE_FORMAT_FRAME_SIZE /* MUST be >= 320000/8/32000*1152 = 1440 */\n\n#define MAX_BITRESERVOIR_BYTES      511\n#define SHORT_BLOCK_TYPE            2\n#define STOP_BLOCK_TYPE             3\n#define MODE_MONO                   3\n#define MODE_JOINT_STEREO           1\n#define HDR_SIZE                    4\n#define HDR_IS_MONO(h)              (((h[3]) & 0xC0) == 0xC0)\n#define HDR_IS_MS_STEREO(h)         (((h[3]) & 0xE0) == 0x60)\n#define HDR_IS_FREE_FORMAT(h)       (((h[2]) & 0xF0) == 0)\n#define HDR_IS_CRC(h)               (!((h[1]) & 1))\n#define HDR_TEST_PADDING(h)         ((h[2]) & 0x2)\n#define HDR_TEST_MPEG1(h)           ((h[1]) & 0x8)\n#define HDR_TEST_NOT_MPEG25(h)      ((h[1]) & 0x10)\n#define HDR_TEST_I_STEREO(h)        ((h[3]) & 0x10)\n#define HDR_TEST_MS_STEREO(h)       ((h[3]) & 0x20)\n#define HDR_GET_STEREO_MODE(h)      (((h[3]) >> 6) & 3)\n#define HDR_GET_STEREO_MODE_EXT(h)  (((h[3]) >> 4) & 3)\n#define HDR_GET_LAYER(h)            (((h[1]) >> 1) & 3)\n#define HDR_GET_BITRATE(h)          ((h[2]) >> 4)\n#define HDR_GET_SAMPLE_RATE(h)      (((h[2]) >> 2) & 3)\n#define HDR_GET_MY_SAMPLE_RATE(h)   (HDR_GET_SAMPLE_RATE(h) + (((h[1] >> 3) & 1) + ((h[1] >> 4) & 1))*3)\n#define HDR_IS_FRAME_576(h)         ((h[1] & 14) == 2)\n#define HDR_IS_LAYER_1(h)           ((h[1] & 6) == 6)\n\n#define BITS_DEQUANTIZER_OUT        -1\n#define MAX_SCF                     (255 + BITS_DEQUANTIZER_OUT*4 - 210)\n#define MAX_SCFI                    ((MAX_SCF + 3) & ~3)\n\n#define MINIMP3_MIN(a, b)           ((a) > (b) ? (b) : (a))\n#define MINIMP3_MAX(a, b)           ((a) < (b) ? (b) : (a))\n\n#if !defined(MINIMP3_NO_SIMD)\n\n#if !defined(MINIMP3_ONLY_SIMD) && (defined(_M_X64) || defined(__x86_64__) || defined(__aarch64__) || defined(_M_ARM64))\n/* x64 always have SSE2, arm64 always have neon, no need for generic code */\n#define MINIMP3_ONLY_SIMD\n#endif /* SIMD checks... */\n\n#if (defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))) || ((defined(__i386__) || defined(__x86_64__)) && defined(__SSE2__))\n#if defined(_MSC_VER)\n#include <intrin.h>\n#endif /* defined(_MSC_VER) */\n#include <immintrin.h>\n#define HAVE_SSE 1\n#define HAVE_SIMD 1\n#define VSTORE _mm_storeu_ps\n#define VLD _mm_loadu_ps\n#define VSET _mm_set1_ps\n#define VADD _mm_add_ps\n#define VSUB _mm_sub_ps\n#define VMUL _mm_mul_ps\n#define VMAC(a, x, y) _mm_add_ps(a, _mm_mul_ps(x, y))\n#define VMSB(a, x, y) _mm_sub_ps(a, _mm_mul_ps(x, y))\n#define VMUL_S(x, s)  _mm_mul_ps(x, _mm_set1_ps(s))\n#define VREV(x) _mm_shuffle_ps(x, x, _MM_SHUFFLE(0, 1, 2, 3))\ntypedef __m128 f4;\n#if defined(_MSC_VER) || defined(MINIMP3_ONLY_SIMD)\n#define minimp3_cpuid __cpuid\n#else /* defined(_MSC_VER) || defined(MINIMP3_ONLY_SIMD) */\nstatic __inline__ __attribute__((always_inline)) void minimp3_cpuid(int CPUInfo[], const int InfoType)\n{\n#if defined(__PIC__)\n    __asm__ __volatile__(\n#if defined(__x86_64__)\n        \"push %%rbx\\n\"\n        \"cpuid\\n\"\n        \"xchgl %%ebx, %1\\n\"\n        \"pop  %%rbx\\n\"\n#else /* defined(__x86_64__) */\n        \"xchgl %%ebx, %1\\n\"\n        \"cpuid\\n\"\n        \"xchgl %%ebx, %1\\n\"\n#endif /* defined(__x86_64__) */\n        : \"=a\" (CPUInfo[0]), \"=r\" (CPUInfo[1]), \"=c\" (CPUInfo[2]), \"=d\" (CPUInfo[3])\n        : \"a\" (InfoType));\n#else /* defined(__PIC__) */\n    __asm__ __volatile__(\n        \"cpuid\"\n        : \"=a\" (CPUInfo[0]), \"=b\" (CPUInfo[1]), \"=c\" (CPUInfo[2]), \"=d\" (CPUInfo[3])\n        : \"a\" (InfoType));\n#endif /* defined(__PIC__)*/\n}\n#endif /* defined(_MSC_VER) || defined(MINIMP3_ONLY_SIMD) */\nstatic int have_simd(void)\n{\n#ifdef MINIMP3_ONLY_SIMD\n    return 1;\n#else /* MINIMP3_ONLY_SIMD */\n    static int g_have_simd;\n    int CPUInfo[4];\n#ifdef MINIMP3_TEST\n    static int g_counter;\n    if (g_counter++ > 100)\n        return 0;\n#endif /* MINIMP3_TEST */\n    if (g_have_simd)\n        goto end;\n    minimp3_cpuid(CPUInfo, 0);\n    g_have_simd = 1;\n    if (CPUInfo[0] > 0)\n    {\n        minimp3_cpuid(CPUInfo, 1);\n        g_have_simd = (CPUInfo[3] & (1 << 26)) + 1; /* SSE2 */\n    }\nend:\n    return g_have_simd - 1;\n#endif /* MINIMP3_ONLY_SIMD */\n}\n#elif defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64)\n#include <arm_neon.h>\n#define HAVE_SSE 0\n#define HAVE_SIMD 1\n#define VSTORE vst1q_f32\n#define VLD vld1q_f32\n#define VSET vmovq_n_f32\n#define VADD vaddq_f32\n#define VSUB vsubq_f32\n#define VMUL vmulq_f32\n#define VMAC(a, x, y) vmlaq_f32(a, x, y)\n#define VMSB(a, x, y) vmlsq_f32(a, x, y)\n#define VMUL_S(x, s)  vmulq_f32(x, vmovq_n_f32(s))\n#define VREV(x) vcombine_f32(vget_high_f32(vrev64q_f32(x)), vget_low_f32(vrev64q_f32(x)))\ntypedef float32x4_t f4;\nstatic int have_simd()\n{   /* TODO: detect neon for !MINIMP3_ONLY_SIMD */\n    return 1;\n}\n#else /* SIMD checks... */\n#define HAVE_SSE 0\n#define HAVE_SIMD 0\n#ifdef MINIMP3_ONLY_SIMD\n#error MINIMP3_ONLY_SIMD used, but SSE/NEON not enabled\n#endif /* MINIMP3_ONLY_SIMD */\n#endif /* SIMD checks... */\n#else /* !defined(MINIMP3_NO_SIMD) */\n#define HAVE_SIMD 0\n#endif /* !defined(MINIMP3_NO_SIMD) */\n\n#if defined(__ARM_ARCH) && (__ARM_ARCH >= 6) && !defined(__aarch64__) && !defined(_M_ARM64)\n#define HAVE_ARMV6 1\nstatic __inline__ __attribute__((always_inline)) int32_t minimp3_clip_int16_arm(int32_t a)\n{\n    int32_t x = 0;\n    __asm__ (\"ssat %0, #16, %1\" : \"=r\"(x) : \"r\"(a));\n    return x;\n}\n#else\n#define HAVE_ARMV6 0\n#endif\n\ntypedef struct\n{\n    const uint8_t *buf;\n    int pos, limit;\n} bs_t;\n\ntypedef struct\n{\n    float scf[3*64];\n    uint8_t total_bands, stereo_bands, bitalloc[64], scfcod[64];\n} L12_scale_info;\n\ntypedef struct\n{\n    uint8_t tab_offset, code_tab_width, band_count;\n} L12_subband_alloc_t;\n\ntypedef struct\n{\n    const uint8_t *sfbtab;\n    uint16_t part_23_length, big_values, scalefac_compress;\n    uint8_t global_gain, block_type, mixed_block_flag, n_long_sfb, n_short_sfb;\n    uint8_t table_select[3], region_count[3], subblock_gain[3];\n    uint8_t preflag, scalefac_scale, count1_table, scfsi;\n} L3_gr_info_t;\n\ntypedef struct\n{\n    bs_t bs;\n    uint8_t maindata[MAX_BITRESERVOIR_BYTES + MAX_L3_FRAME_PAYLOAD_BYTES];\n    L3_gr_info_t gr_info[4];\n    float grbuf[2][576], scf[40], syn[18 + 15][2*32];\n    uint8_t ist_pos[2][39];\n} mp3dec_scratch_t;\n\nstatic void bs_init(bs_t *bs, const uint8_t *data, int bytes)\n{\n    bs->buf   = data;\n    bs->pos   = 0;\n    bs->limit = bytes*8;\n}\n\nstatic uint32_t get_bits(bs_t *bs, int n)\n{\n    uint32_t next, cache = 0, s = bs->pos & 7;\n    int shl = n + s;\n    const uint8_t *p = bs->buf + (bs->pos >> 3);\n    if ((bs->pos += n) > bs->limit)\n        return 0;\n    next = *p++ & (255 >> s);\n    while ((shl -= 8) > 0)\n    {\n        cache |= next << shl;\n        next = *p++;\n    }\n    return cache | (next >> -shl);\n}\n\nstatic int hdr_valid(const uint8_t *h)\n{\n    return h[0] == 0xff &&\n        ((h[1] & 0xF0) == 0xf0 || (h[1] & 0xFE) == 0xe2) &&\n        (HDR_GET_LAYER(h) != 0) &&\n        (HDR_GET_BITRATE(h) != 15) &&\n        (HDR_GET_SAMPLE_RATE(h) != 3);\n}\n\nstatic int hdr_compare(const uint8_t *h1, const uint8_t *h2)\n{\n    return hdr_valid(h2) &&\n        ((h1[1] ^ h2[1]) & 0xFE) == 0 &&\n        ((h1[2] ^ h2[2]) & 0x0C) == 0 &&\n        !(HDR_IS_FREE_FORMAT(h1) ^ HDR_IS_FREE_FORMAT(h2));\n}\n\nstatic unsigned hdr_bitrate_kbps(const uint8_t *h)\n{\n    static const uint8_t halfrate[2][3][15] = {\n        { { 0,4,8,12,16,20,24,28,32,40,48,56,64,72,80 }, { 0,4,8,12,16,20,24,28,32,40,48,56,64,72,80 }, { 0,16,24,28,32,40,48,56,64,72,80,88,96,112,128 } },\n        { { 0,16,20,24,28,32,40,48,56,64,80,96,112,128,160 }, { 0,16,24,28,32,40,48,56,64,80,96,112,128,160,192 }, { 0,16,32,48,64,80,96,112,128,144,160,176,192,208,224 } },\n    };\n    return 2*halfrate[!!HDR_TEST_MPEG1(h)][HDR_GET_LAYER(h) - 1][HDR_GET_BITRATE(h)];\n}\n\nstatic unsigned hdr_sample_rate_hz(const uint8_t *h)\n{\n    static const unsigned g_hz[3] = { 44100, 48000, 32000 };\n    return g_hz[HDR_GET_SAMPLE_RATE(h)] >> (int)!HDR_TEST_MPEG1(h) >> (int)!HDR_TEST_NOT_MPEG25(h);\n}\n\nstatic unsigned hdr_frame_samples(const uint8_t *h)\n{\n    return HDR_IS_LAYER_1(h) ? 384 : (1152 >> (int)HDR_IS_FRAME_576(h));\n}\n\nstatic int hdr_frame_bytes(const uint8_t *h, int free_format_size)\n{\n    int frame_bytes = hdr_frame_samples(h)*hdr_bitrate_kbps(h)*125/hdr_sample_rate_hz(h);\n    if (HDR_IS_LAYER_1(h))\n    {\n        frame_bytes &= ~3; /* slot align */\n    }\n    return frame_bytes ? frame_bytes : free_format_size;\n}\n\nstatic int hdr_padding(const uint8_t *h)\n{\n    return HDR_TEST_PADDING(h) ? (HDR_IS_LAYER_1(h) ? 4 : 1) : 0;\n}\n\n#ifndef MINIMP3_ONLY_MP3\nstatic const L12_subband_alloc_t *L12_subband_alloc_table(const uint8_t *hdr, L12_scale_info *sci)\n{\n    const L12_subband_alloc_t *alloc;\n    int mode = HDR_GET_STEREO_MODE(hdr);\n    int nbands, stereo_bands = (mode == MODE_MONO) ? 0 : (mode == MODE_JOINT_STEREO) ? (HDR_GET_STEREO_MODE_EXT(hdr) << 2) + 4 : 32;\n\n    if (HDR_IS_LAYER_1(hdr))\n    {\n        static const L12_subband_alloc_t g_alloc_L1[] = { { 76, 4, 32 } };\n        alloc = g_alloc_L1;\n        nbands = 32;\n    } else if (!HDR_TEST_MPEG1(hdr))\n    {\n        static const L12_subband_alloc_t g_alloc_L2M2[] = { { 60, 4, 4 }, { 44, 3, 7 }, { 44, 2, 19 } };\n        alloc = g_alloc_L2M2;\n        nbands = 30;\n    } else\n    {\n        static const L12_subband_alloc_t g_alloc_L2M1[] = { { 0, 4, 3 }, { 16, 4, 8 }, { 32, 3, 12 }, { 40, 2, 7 } };\n        int sample_rate_idx = HDR_GET_SAMPLE_RATE(hdr);\n        unsigned kbps = hdr_bitrate_kbps(hdr) >> (int)(mode != MODE_MONO);\n        if (!kbps) /* free-format */\n        {\n            kbps = 192;\n        }\n\n        alloc = g_alloc_L2M1;\n        nbands = 27;\n        if (kbps < 56)\n        {\n            static const L12_subband_alloc_t g_alloc_L2M1_lowrate[] = { { 44, 4, 2 }, { 44, 3, 10 } };\n            alloc = g_alloc_L2M1_lowrate;\n            nbands = sample_rate_idx == 2 ? 12 : 8;\n        } else if (kbps >= 96 && sample_rate_idx != 1)\n        {\n            nbands = 30;\n        }\n    }\n\n    sci->total_bands = (uint8_t)nbands;\n    sci->stereo_bands = (uint8_t)MINIMP3_MIN(stereo_bands, nbands);\n\n    return alloc;\n}\n\nstatic void L12_read_scalefactors(bs_t *bs, uint8_t *pba, uint8_t *scfcod, int bands, float *scf)\n{\n    static const float g_deq_L12[18*3] = {\n#define DQ(x) 9.53674316e-07f/x, 7.56931807e-07f/x, 6.00777173e-07f/x\n        DQ(3),DQ(7),DQ(15),DQ(31),DQ(63),DQ(127),DQ(255),DQ(511),DQ(1023),DQ(2047),DQ(4095),DQ(8191),DQ(16383),DQ(32767),DQ(65535),DQ(3),DQ(5),DQ(9)\n    };\n    int i, m;\n    for (i = 0; i < bands; i++)\n    {\n        float s = 0;\n        int ba = *pba++;\n        int mask = ba ? 4 + ((19 >> scfcod[i]) & 3) : 0;\n        for (m = 4; m; m >>= 1)\n        {\n            if (mask & m)\n            {\n                int b = get_bits(bs, 6);\n                s = g_deq_L12[ba*3 - 6 + b % 3]*(1 << 21 >> b/3);\n            }\n            *scf++ = s;\n        }\n    }\n}\n\nstatic void L12_read_scale_info(const uint8_t *hdr, bs_t *bs, L12_scale_info *sci)\n{\n    static const uint8_t g_bitalloc_code_tab[] = {\n        0,17, 3, 4, 5,6,7, 8,9,10,11,12,13,14,15,16,\n        0,17,18, 3,19,4,5, 6,7, 8, 9,10,11,12,13,16,\n        0,17,18, 3,19,4,5,16,\n        0,17,18,16,\n        0,17,18,19, 4,5,6, 7,8, 9,10,11,12,13,14,15,\n        0,17,18, 3,19,4,5, 6,7, 8, 9,10,11,12,13,14,\n        0, 2, 3, 4, 5,6,7, 8,9,10,11,12,13,14,15,16\n    };\n    const L12_subband_alloc_t *subband_alloc = L12_subband_alloc_table(hdr, sci);\n\n    int i, k = 0, ba_bits = 0;\n    const uint8_t *ba_code_tab = g_bitalloc_code_tab;\n\n    for (i = 0; i < sci->total_bands; i++)\n    {\n        uint8_t ba;\n        if (i == k)\n        {\n            k += subband_alloc->band_count;\n            ba_bits = subband_alloc->code_tab_width;\n            ba_code_tab = g_bitalloc_code_tab + subband_alloc->tab_offset;\n            subband_alloc++;\n        }\n        ba = ba_code_tab[get_bits(bs, ba_bits)];\n        sci->bitalloc[2*i] = ba;\n        if (i < sci->stereo_bands)\n        {\n            ba = ba_code_tab[get_bits(bs, ba_bits)];\n        }\n        sci->bitalloc[2*i + 1] = sci->stereo_bands ? ba : 0;\n    }\n\n    for (i = 0; i < 2*sci->total_bands; i++)\n    {\n        sci->scfcod[i] = sci->bitalloc[i] ? HDR_IS_LAYER_1(hdr) ? 2 : get_bits(bs, 2) : 6;\n    }\n\n    L12_read_scalefactors(bs, sci->bitalloc, sci->scfcod, sci->total_bands*2, sci->scf);\n\n    for (i = sci->stereo_bands; i < sci->total_bands; i++)\n    {\n        sci->bitalloc[2*i + 1] = 0;\n    }\n}\n\nstatic int L12_dequantize_granule(float *grbuf, bs_t *bs, L12_scale_info *sci, int group_size)\n{\n    int i, j, k, choff = 576;\n    for (j = 0; j < 4; j++)\n    {\n        float *dst = grbuf + group_size*j;\n        for (i = 0; i < 2*sci->total_bands; i++)\n        {\n            int ba = sci->bitalloc[i];\n            if (ba != 0)\n            {\n                if (ba < 17)\n                {\n                    int half = (1 << (ba - 1)) - 1;\n                    for (k = 0; k < group_size; k++)\n                    {\n                        dst[k] = (float)((int)get_bits(bs, ba) - half);\n                    }\n                } else\n                {\n                    unsigned mod = (2 << (ba - 17)) + 1;    /* 3, 5, 9 */\n                    unsigned code = get_bits(bs, mod + 2 - (mod >> 3));  /* 5, 7, 10 */\n                    for (k = 0; k < group_size; k++, code /= mod)\n                    {\n                        dst[k] = (float)((int)(code % mod - mod/2));\n                    }\n                }\n            }\n            dst += choff;\n            choff = 18 - choff;\n        }\n    }\n    return group_size*4;\n}\n\nstatic void L12_apply_scf_384(L12_scale_info *sci, const float *scf, float *dst)\n{\n    int i, k;\n    memcpy(dst + 576 + sci->stereo_bands*18, dst + sci->stereo_bands*18, (sci->total_bands - sci->stereo_bands)*18*sizeof(float));\n    for (i = 0; i < sci->total_bands; i++, dst += 18, scf += 6)\n    {\n        for (k = 0; k < 12; k++)\n        {\n            dst[k + 0]   *= scf[0];\n            dst[k + 576] *= scf[3];\n        }\n    }\n}\n#endif /* MINIMP3_ONLY_MP3 */\n\nstatic int L3_read_side_info(bs_t *bs, L3_gr_info_t *gr, const uint8_t *hdr)\n{\n    static const uint8_t g_scf_long[8][23] = {\n        { 6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54,0 },\n        { 12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2,0 },\n        { 6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54,0 },\n        { 6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,54,62,70,76,36,0 },\n        { 6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54,0 },\n        { 4,4,4,4,4,4,6,6,8,8,10,12,16,20,24,28,34,42,50,54,76,158,0 },\n        { 4,4,4,4,4,4,6,6,6,8,10,12,16,18,22,28,34,40,46,54,54,192,0 },\n        { 4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102,26,0 }\n    };\n    static const uint8_t g_scf_short[8][40] = {\n        { 4,4,4,4,4,4,4,4,4,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,24,24,24,30,30,30,40,40,40,18,18,18,0 },\n        { 8,8,8,8,8,8,8,8,8,12,12,12,16,16,16,20,20,20,24,24,24,28,28,28,36,36,36,2,2,2,2,2,2,2,2,2,26,26,26,0 },\n        { 4,4,4,4,4,4,4,4,4,6,6,6,6,6,6,8,8,8,10,10,10,14,14,14,18,18,18,26,26,26,32,32,32,42,42,42,18,18,18,0 },\n        { 4,4,4,4,4,4,4,4,4,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,24,24,24,32,32,32,44,44,44,12,12,12,0 },\n        { 4,4,4,4,4,4,4,4,4,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,24,24,24,30,30,30,40,40,40,18,18,18,0 },\n        { 4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,22,22,22,30,30,30,56,56,56,0 },\n        { 4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,6,6,6,10,10,10,12,12,12,14,14,14,16,16,16,20,20,20,26,26,26,66,66,66,0 },\n        { 4,4,4,4,4,4,4,4,4,4,4,4,6,6,6,8,8,8,12,12,12,16,16,16,20,20,20,26,26,26,34,34,34,42,42,42,12,12,12,0 }\n    };\n    static const uint8_t g_scf_mixed[8][40] = {\n        { 6,6,6,6,6,6,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,24,24,24,30,30,30,40,40,40,18,18,18,0 },\n        { 12,12,12,4,4,4,8,8,8,12,12,12,16,16,16,20,20,20,24,24,24,28,28,28,36,36,36,2,2,2,2,2,2,2,2,2,26,26,26,0 },\n        { 6,6,6,6,6,6,6,6,6,6,6,6,8,8,8,10,10,10,14,14,14,18,18,18,26,26,26,32,32,32,42,42,42,18,18,18,0 },\n        { 6,6,6,6,6,6,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,24,24,24,32,32,32,44,44,44,12,12,12,0 },\n        { 6,6,6,6,6,6,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,24,24,24,30,30,30,40,40,40,18,18,18,0 },\n        { 4,4,4,4,4,4,6,6,4,4,4,6,6,6,8,8,8,10,10,10,12,12,12,14,14,14,18,18,18,22,22,22,30,30,30,56,56,56,0 },\n        { 4,4,4,4,4,4,6,6,4,4,4,6,6,6,6,6,6,10,10,10,12,12,12,14,14,14,16,16,16,20,20,20,26,26,26,66,66,66,0 },\n        { 4,4,4,4,4,4,6,6,4,4,4,6,6,6,8,8,8,12,12,12,16,16,16,20,20,20,26,26,26,34,34,34,42,42,42,12,12,12,0 }\n    };\n\n    unsigned tables, scfsi = 0;\n    int main_data_begin, part_23_sum = 0;\n    int sr_idx = HDR_GET_MY_SAMPLE_RATE(hdr); sr_idx -= (sr_idx != 0);\n    int gr_count = HDR_IS_MONO(hdr) ? 1 : 2;\n\n    if (HDR_TEST_MPEG1(hdr))\n    {\n        gr_count *= 2;\n        main_data_begin = get_bits(bs, 9);\n        scfsi = get_bits(bs, 7 + gr_count);\n    } else\n    {\n        main_data_begin = get_bits(bs, 8 + gr_count) >> gr_count;\n    }\n\n    do\n    {\n        if (HDR_IS_MONO(hdr))\n        {\n            scfsi <<= 4;\n        }\n        gr->part_23_length = (uint16_t)get_bits(bs, 12);\n        part_23_sum += gr->part_23_length;\n        gr->big_values = (uint16_t)get_bits(bs,  9);\n        if (gr->big_values > 288)\n        {\n            return -1;\n        }\n        gr->global_gain = (uint8_t)get_bits(bs, 8);\n        gr->scalefac_compress = (uint16_t)get_bits(bs, HDR_TEST_MPEG1(hdr) ? 4 : 9);\n        gr->sfbtab = g_scf_long[sr_idx];\n        gr->n_long_sfb  = 22;\n        gr->n_short_sfb = 0;\n        if (get_bits(bs, 1))\n        {\n            gr->block_type = (uint8_t)get_bits(bs, 2);\n            if (!gr->block_type)\n            {\n                return -1;\n            }\n            gr->mixed_block_flag = (uint8_t)get_bits(bs, 1);\n            gr->region_count[0] = 7;\n            gr->region_count[1] = 255;\n            if (gr->block_type == SHORT_BLOCK_TYPE)\n            {\n                scfsi &= 0x0F0F;\n                if (!gr->mixed_block_flag)\n                {\n                    gr->region_count[0] = 8;\n                    gr->sfbtab = g_scf_short[sr_idx];\n                    gr->n_long_sfb = 0;\n                    gr->n_short_sfb = 39;\n                } else\n                {\n                    gr->sfbtab = g_scf_mixed[sr_idx];\n                    gr->n_long_sfb = HDR_TEST_MPEG1(hdr) ? 8 : 6;\n                    gr->n_short_sfb = 30;\n                }\n            }\n            tables = get_bits(bs, 10);\n            tables <<= 5;\n            gr->subblock_gain[0] = (uint8_t)get_bits(bs, 3);\n            gr->subblock_gain[1] = (uint8_t)get_bits(bs, 3);\n            gr->subblock_gain[2] = (uint8_t)get_bits(bs, 3);\n        } else\n        {\n            gr->block_type = 0;\n            gr->mixed_block_flag = 0;\n            tables = get_bits(bs, 15);\n            gr->region_count[0] = (uint8_t)get_bits(bs, 4);\n            gr->region_count[1] = (uint8_t)get_bits(bs, 3);\n            gr->region_count[2] = 255;\n        }\n        gr->table_select[0] = (uint8_t)(tables >> 10);\n        gr->table_select[1] = (uint8_t)((tables >> 5) & 31);\n        gr->table_select[2] = (uint8_t)((tables) & 31);\n        gr->preflag = HDR_TEST_MPEG1(hdr) ? get_bits(bs, 1) : (gr->scalefac_compress >= 500);\n        gr->scalefac_scale = (uint8_t)get_bits(bs, 1);\n        gr->count1_table = (uint8_t)get_bits(bs, 1);\n        gr->scfsi = (uint8_t)((scfsi >> 12) & 15);\n        scfsi <<= 4;\n        gr++;\n    } while(--gr_count);\n\n    if (part_23_sum + bs->pos > bs->limit + main_data_begin*8)\n    {\n        return -1;\n    }\n\n    return main_data_begin;\n}\n\nstatic void L3_read_scalefactors(uint8_t *scf, uint8_t *ist_pos, const uint8_t *scf_size, const uint8_t *scf_count, bs_t *bitbuf, int scfsi)\n{\n    int i, k;\n    for (i = 0; i < 4 && scf_count[i]; i++, scfsi *= 2)\n    {\n        int cnt = scf_count[i];\n        if (scfsi & 8)\n        {\n            memcpy(scf, ist_pos, cnt);\n        } else\n        {\n            int bits = scf_size[i];\n            if (!bits)\n            {\n                memset(scf, 0, cnt);\n                memset(ist_pos, 0, cnt);\n            } else\n            {\n                int max_scf = (scfsi < 0) ? (1 << bits) - 1 : -1;\n                for (k = 0; k < cnt; k++)\n                {\n                    int s = get_bits(bitbuf, bits);\n                    ist_pos[k] = (s == max_scf ? -1 : s);\n                    scf[k] = s;\n                }\n            }\n        }\n        ist_pos += cnt;\n        scf += cnt;\n    }\n    scf[0] = scf[1] = scf[2] = 0;\n}\n\nstatic float L3_ldexp_q2(float y, int exp_q2)\n{\n    static const float g_expfrac[4] = { 9.31322575e-10f,7.83145814e-10f,6.58544508e-10f,5.53767716e-10f };\n    int e;\n    do\n    {\n        e = MINIMP3_MIN(30*4, exp_q2);\n        y *= g_expfrac[e & 3]*(1 << 30 >> (e >> 2));\n    } while ((exp_q2 -= e) > 0);\n    return y;\n}\n\nstatic void L3_decode_scalefactors(const uint8_t *hdr, uint8_t *ist_pos, bs_t *bs, const L3_gr_info_t *gr, float *scf, int ch)\n{\n    static const uint8_t g_scf_partitions[3][28] = {\n        { 6,5,5, 5,6,5,5,5,6,5, 7,3,11,10,0,0, 7, 7, 7,0, 6, 6,6,3, 8, 8,5,0 },\n        { 8,9,6,12,6,9,9,9,6,9,12,6,15,18,0,0, 6,15,12,0, 6,12,9,6, 6,18,9,0 },\n        { 9,9,6,12,9,9,9,9,9,9,12,6,18,18,0,0,12,12,12,0,12, 9,9,6,15,12,9,0 }\n    };\n    const uint8_t *scf_partition = g_scf_partitions[!!gr->n_short_sfb + !gr->n_long_sfb];\n    uint8_t scf_size[4], iscf[40];\n    int i, scf_shift = gr->scalefac_scale + 1, gain_exp, scfsi = gr->scfsi;\n    float gain;\n\n    if (HDR_TEST_MPEG1(hdr))\n    {\n        static const uint8_t g_scfc_decode[16] = { 0,1,2,3, 12,5,6,7, 9,10,11,13, 14,15,18,19 };\n        int part = g_scfc_decode[gr->scalefac_compress];\n        scf_size[1] = scf_size[0] = (uint8_t)(part >> 2);\n        scf_size[3] = scf_size[2] = (uint8_t)(part & 3);\n    } else\n    {\n        static const uint8_t g_mod[6*4] = { 5,5,4,4,5,5,4,1,4,3,1,1,5,6,6,1,4,4,4,1,4,3,1,1 };\n        int k, modprod, sfc, ist = HDR_TEST_I_STEREO(hdr) && ch;\n        sfc = gr->scalefac_compress >> ist;\n        for (k = ist*3*4; sfc >= 0; sfc -= modprod, k += 4)\n        {\n            for (modprod = 1, i = 3; i >= 0; i--)\n            {\n                scf_size[i] = (uint8_t)(sfc / modprod % g_mod[k + i]);\n                modprod *= g_mod[k + i];\n            }\n        }\n        scf_partition += k;\n        scfsi = -16;\n    }\n    L3_read_scalefactors(iscf, ist_pos, scf_size, scf_partition, bs, scfsi);\n\n    if (gr->n_short_sfb)\n    {\n        int sh = 3 - scf_shift;\n        for (i = 0; i < gr->n_short_sfb; i += 3)\n        {\n            iscf[gr->n_long_sfb + i + 0] += gr->subblock_gain[0] << sh;\n            iscf[gr->n_long_sfb + i + 1] += gr->subblock_gain[1] << sh;\n            iscf[gr->n_long_sfb + i + 2] += gr->subblock_gain[2] << sh;\n        }\n    } else if (gr->preflag)\n    {\n        static const uint8_t g_preamp[10] = { 1,1,1,1,2,2,3,3,3,2 };\n        for (i = 0; i < 10; i++)\n        {\n            iscf[11 + i] += g_preamp[i];\n        }\n    }\n\n    gain_exp = gr->global_gain + BITS_DEQUANTIZER_OUT*4 - 210 - (HDR_IS_MS_STEREO(hdr) ? 2 : 0);\n    gain = L3_ldexp_q2(1 << (MAX_SCFI/4),  MAX_SCFI - gain_exp);\n    for (i = 0; i < (int)(gr->n_long_sfb + gr->n_short_sfb); i++)\n    {\n        scf[i] = L3_ldexp_q2(gain, iscf[i] << scf_shift);\n    }\n}\n\nstatic const float g_pow43[129 + 16] = {\n    0,-1,-2.519842f,-4.326749f,-6.349604f,-8.549880f,-10.902724f,-13.390518f,-16.000000f,-18.720754f,-21.544347f,-24.463781f,-27.473142f,-30.567351f,-33.741992f,-36.993181f,\n    0,1,2.519842f,4.326749f,6.349604f,8.549880f,10.902724f,13.390518f,16.000000f,18.720754f,21.544347f,24.463781f,27.473142f,30.567351f,33.741992f,36.993181f,40.317474f,43.711787f,47.173345f,50.699631f,54.288352f,57.937408f,61.644865f,65.408941f,69.227979f,73.100443f,77.024898f,81.000000f,85.024491f,89.097188f,93.216975f,97.382800f,101.593667f,105.848633f,110.146801f,114.487321f,118.869381f,123.292209f,127.755065f,132.257246f,136.798076f,141.376907f,145.993119f,150.646117f,155.335327f,160.060199f,164.820202f,169.614826f,174.443577f,179.305980f,184.201575f,189.129918f,194.090580f,199.083145f,204.107210f,209.162385f,214.248292f,219.364564f,224.510845f,229.686789f,234.892058f,240.126328f,245.389280f,250.680604f,256.000000f,261.347174f,266.721841f,272.123723f,277.552547f,283.008049f,288.489971f,293.998060f,299.532071f,305.091761f,310.676898f,316.287249f,321.922592f,327.582707f,333.267377f,338.976394f,344.709550f,350.466646f,356.247482f,362.051866f,367.879608f,373.730522f,379.604427f,385.501143f,391.420496f,397.362314f,403.326427f,409.312672f,415.320884f,421.350905f,427.402579f,433.475750f,439.570269f,445.685987f,451.822757f,457.980436f,464.158883f,470.357960f,476.577530f,482.817459f,489.077615f,495.357868f,501.658090f,507.978156f,514.317941f,520.677324f,527.056184f,533.454404f,539.871867f,546.308458f,552.764065f,559.238575f,565.731879f,572.243870f,578.774440f,585.323483f,591.890898f,598.476581f,605.080431f,611.702349f,618.342238f,625.000000f,631.675540f,638.368763f,645.079578f\n};\n\nstatic float L3_pow_43(int x)\n{\n    float frac;\n    int sign, mult = 256;\n\n    if (x < 129)\n    {\n        return g_pow43[16 + x];\n    }\n\n    if (x < 1024)\n    {\n        mult = 16;\n        x <<= 3;\n    }\n\n    sign = 2*x & 64;\n    frac = (float)((x & 63) - sign) / ((x & ~63) + sign);\n    return g_pow43[16 + ((x + sign) >> 6)]*(1.f + frac*((4.f/3) + frac*(2.f/9)))*mult;\n}\n\nstatic void L3_huffman(float *dst, bs_t *bs, const L3_gr_info_t *gr_info, const float *scf, int layer3gr_limit)\n{\n    static const int16_t tabs[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        785,785,785,785,784,784,784,784,513,513,513,513,513,513,513,513,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,\n        -255,1313,1298,1282,785,785,785,785,784,784,784,784,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,290,288,\n        -255,1313,1298,1282,769,769,769,769,529,529,529,529,529,529,529,529,528,528,528,528,528,528,528,528,512,512,512,512,512,512,512,512,290,288,\n        -253,-318,-351,-367,785,785,785,785,784,784,784,784,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,819,818,547,547,275,275,275,275,561,560,515,546,289,274,288,258,\n        -254,-287,1329,1299,1314,1312,1057,1057,1042,1042,1026,1026,784,784,784,784,529,529,529,529,529,529,529,529,769,769,769,769,768,768,768,768,563,560,306,306,291,259,\n        -252,-413,-477,-542,1298,-575,1041,1041,784,784,784,784,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,-383,-399,1107,1092,1106,1061,849,849,789,789,1104,1091,773,773,1076,1075,341,340,325,309,834,804,577,577,532,532,516,516,832,818,803,816,561,561,531,531,515,546,289,289,288,258,\n        -252,-429,-493,-559,1057,1057,1042,1042,529,529,529,529,529,529,529,529,784,784,784,784,769,769,769,769,512,512,512,512,512,512,512,512,-382,1077,-415,1106,1061,1104,849,849,789,789,1091,1076,1029,1075,834,834,597,581,340,340,339,324,804,833,532,532,832,772,818,803,817,787,816,771,290,290,290,290,288,258,\n        -253,-349,-414,-447,-463,1329,1299,-479,1314,1312,1057,1057,1042,1042,1026,1026,785,785,785,785,784,784,784,784,769,769,769,769,768,768,768,768,-319,851,821,-335,836,850,805,849,341,340,325,336,533,533,579,579,564,564,773,832,578,548,563,516,321,276,306,291,304,259,\n        -251,-572,-733,-830,-863,-879,1041,1041,784,784,784,784,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,-511,-527,-543,1396,1351,1381,1366,1395,1335,1380,-559,1334,1138,1138,1063,1063,1350,1392,1031,1031,1062,1062,1364,1363,1120,1120,1333,1348,881,881,881,881,375,374,359,373,343,358,341,325,791,791,1123,1122,-703,1105,1045,-719,865,865,790,790,774,774,1104,1029,338,293,323,308,-799,-815,833,788,772,818,803,816,322,292,307,320,561,531,515,546,289,274,288,258,\n        -251,-525,-605,-685,-765,-831,-846,1298,1057,1057,1312,1282,785,785,785,785,784,784,784,784,769,769,769,769,512,512,512,512,512,512,512,512,1399,1398,1383,1367,1382,1396,1351,-511,1381,1366,1139,1139,1079,1079,1124,1124,1364,1349,1363,1333,882,882,882,882,807,807,807,807,1094,1094,1136,1136,373,341,535,535,881,775,867,822,774,-591,324,338,-671,849,550,550,866,864,609,609,293,336,534,534,789,835,773,-751,834,804,308,307,833,788,832,772,562,562,547,547,305,275,560,515,290,290,\n        -252,-397,-477,-557,-622,-653,-719,-735,-750,1329,1299,1314,1057,1057,1042,1042,1312,1282,1024,1024,785,785,785,785,784,784,784,784,769,769,769,769,-383,1127,1141,1111,1126,1140,1095,1110,869,869,883,883,1079,1109,882,882,375,374,807,868,838,881,791,-463,867,822,368,263,852,837,836,-543,610,610,550,550,352,336,534,534,865,774,851,821,850,805,593,533,579,564,773,832,578,578,548,548,577,577,307,276,306,291,516,560,259,259,\n        -250,-2107,-2507,-2764,-2909,-2974,-3007,-3023,1041,1041,1040,1040,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,-767,-1052,-1213,-1277,-1358,-1405,-1469,-1535,-1550,-1582,-1614,-1647,-1662,-1694,-1726,-1759,-1774,-1807,-1822,-1854,-1886,1565,-1919,-1935,-1951,-1967,1731,1730,1580,1717,-1983,1729,1564,-1999,1548,-2015,-2031,1715,1595,-2047,1714,-2063,1610,-2079,1609,-2095,1323,1323,1457,1457,1307,1307,1712,1547,1641,1700,1699,1594,1685,1625,1442,1442,1322,1322,-780,-973,-910,1279,1278,1277,1262,1276,1261,1275,1215,1260,1229,-959,974,974,989,989,-943,735,478,478,495,463,506,414,-1039,1003,958,1017,927,942,987,957,431,476,1272,1167,1228,-1183,1256,-1199,895,895,941,941,1242,1227,1212,1135,1014,1014,490,489,503,487,910,1013,985,925,863,894,970,955,1012,847,-1343,831,755,755,984,909,428,366,754,559,-1391,752,486,457,924,997,698,698,983,893,740,740,908,877,739,739,667,667,953,938,497,287,271,271,683,606,590,712,726,574,302,302,738,736,481,286,526,725,605,711,636,724,696,651,589,681,666,710,364,467,573,695,466,466,301,465,379,379,709,604,665,679,316,316,634,633,436,436,464,269,424,394,452,332,438,363,347,408,393,448,331,422,362,407,392,421,346,406,391,376,375,359,1441,1306,-2367,1290,-2383,1337,-2399,-2415,1426,1321,-2431,1411,1336,-2447,-2463,-2479,1169,1169,1049,1049,1424,1289,1412,1352,1319,-2495,1154,1154,1064,1064,1153,1153,416,390,360,404,403,389,344,374,373,343,358,372,327,357,342,311,356,326,1395,1394,1137,1137,1047,1047,1365,1392,1287,1379,1334,1364,1349,1378,1318,1363,792,792,792,792,1152,1152,1032,1032,1121,1121,1046,1046,1120,1120,1030,1030,-2895,1106,1061,1104,849,849,789,789,1091,1076,1029,1090,1060,1075,833,833,309,324,532,532,832,772,818,803,561,561,531,560,515,546,289,274,288,258,\n        -250,-1179,-1579,-1836,-1996,-2124,-2253,-2333,-2413,-2477,-2542,-2574,-2607,-2622,-2655,1314,1313,1298,1312,1282,785,785,785,785,1040,1040,1025,1025,768,768,768,768,-766,-798,-830,-862,-895,-911,-927,-943,-959,-975,-991,-1007,-1023,-1039,-1055,-1070,1724,1647,-1103,-1119,1631,1767,1662,1738,1708,1723,-1135,1780,1615,1779,1599,1677,1646,1778,1583,-1151,1777,1567,1737,1692,1765,1722,1707,1630,1751,1661,1764,1614,1736,1676,1763,1750,1645,1598,1721,1691,1762,1706,1582,1761,1566,-1167,1749,1629,767,766,751,765,494,494,735,764,719,749,734,763,447,447,748,718,477,506,431,491,446,476,461,505,415,430,475,445,504,399,460,489,414,503,383,474,429,459,502,502,746,752,488,398,501,473,413,472,486,271,480,270,-1439,-1455,1357,-1471,-1487,-1503,1341,1325,-1519,1489,1463,1403,1309,-1535,1372,1448,1418,1476,1356,1462,1387,-1551,1475,1340,1447,1402,1386,-1567,1068,1068,1474,1461,455,380,468,440,395,425,410,454,364,467,466,464,453,269,409,448,268,432,1371,1473,1432,1417,1308,1460,1355,1446,1459,1431,1083,1083,1401,1416,1458,1445,1067,1067,1370,1457,1051,1051,1291,1430,1385,1444,1354,1415,1400,1443,1082,1082,1173,1113,1186,1066,1185,1050,-1967,1158,1128,1172,1097,1171,1081,-1983,1157,1112,416,266,375,400,1170,1142,1127,1065,793,793,1169,1033,1156,1096,1141,1111,1155,1080,1126,1140,898,898,808,808,897,897,792,792,1095,1152,1032,1125,1110,1139,1079,1124,882,807,838,881,853,791,-2319,867,368,263,822,852,837,866,806,865,-2399,851,352,262,534,534,821,836,594,594,549,549,593,593,533,533,848,773,579,579,564,578,548,563,276,276,577,576,306,291,516,560,305,305,275,259,\n        -251,-892,-2058,-2620,-2828,-2957,-3023,-3039,1041,1041,1040,1040,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,-511,-527,-543,-559,1530,-575,-591,1528,1527,1407,1526,1391,1023,1023,1023,1023,1525,1375,1268,1268,1103,1103,1087,1087,1039,1039,1523,-604,815,815,815,815,510,495,509,479,508,463,507,447,431,505,415,399,-734,-782,1262,-815,1259,1244,-831,1258,1228,-847,-863,1196,-879,1253,987,987,748,-767,493,493,462,477,414,414,686,669,478,446,461,445,474,429,487,458,412,471,1266,1264,1009,1009,799,799,-1019,-1276,-1452,-1581,-1677,-1757,-1821,-1886,-1933,-1997,1257,1257,1483,1468,1512,1422,1497,1406,1467,1496,1421,1510,1134,1134,1225,1225,1466,1451,1374,1405,1252,1252,1358,1480,1164,1164,1251,1251,1238,1238,1389,1465,-1407,1054,1101,-1423,1207,-1439,830,830,1248,1038,1237,1117,1223,1148,1236,1208,411,426,395,410,379,269,1193,1222,1132,1235,1221,1116,976,976,1192,1162,1177,1220,1131,1191,963,963,-1647,961,780,-1663,558,558,994,993,437,408,393,407,829,978,813,797,947,-1743,721,721,377,392,844,950,828,890,706,706,812,859,796,960,948,843,934,874,571,571,-1919,690,555,689,421,346,539,539,944,779,918,873,932,842,903,888,570,570,931,917,674,674,-2575,1562,-2591,1609,-2607,1654,1322,1322,1441,1441,1696,1546,1683,1593,1669,1624,1426,1426,1321,1321,1639,1680,1425,1425,1305,1305,1545,1668,1608,1623,1667,1592,1638,1666,1320,1320,1652,1607,1409,1409,1304,1304,1288,1288,1664,1637,1395,1395,1335,1335,1622,1636,1394,1394,1319,1319,1606,1621,1392,1392,1137,1137,1137,1137,345,390,360,375,404,373,1047,-2751,-2767,-2783,1062,1121,1046,-2799,1077,-2815,1106,1061,789,789,1105,1104,263,355,310,340,325,354,352,262,339,324,1091,1076,1029,1090,1060,1075,833,833,788,788,1088,1028,818,818,803,803,561,561,531,531,816,771,546,546,289,274,288,258,\n        -253,-317,-381,-446,-478,-509,1279,1279,-811,-1179,-1451,-1756,-1900,-2028,-2189,-2253,-2333,-2414,-2445,-2511,-2526,1313,1298,-2559,1041,1041,1040,1040,1025,1025,1024,1024,1022,1007,1021,991,1020,975,1019,959,687,687,1018,1017,671,671,655,655,1016,1015,639,639,758,758,623,623,757,607,756,591,755,575,754,559,543,543,1009,783,-575,-621,-685,-749,496,-590,750,749,734,748,974,989,1003,958,988,973,1002,942,987,957,972,1001,926,986,941,971,956,1000,910,985,925,999,894,970,-1071,-1087,-1102,1390,-1135,1436,1509,1451,1374,-1151,1405,1358,1480,1420,-1167,1507,1494,1389,1342,1465,1435,1450,1326,1505,1310,1493,1373,1479,1404,1492,1464,1419,428,443,472,397,736,526,464,464,486,457,442,471,484,482,1357,1449,1434,1478,1388,1491,1341,1490,1325,1489,1463,1403,1309,1477,1372,1448,1418,1433,1476,1356,1462,1387,-1439,1475,1340,1447,1402,1474,1324,1461,1371,1473,269,448,1432,1417,1308,1460,-1711,1459,-1727,1441,1099,1099,1446,1386,1431,1401,-1743,1289,1083,1083,1160,1160,1458,1445,1067,1067,1370,1457,1307,1430,1129,1129,1098,1098,268,432,267,416,266,400,-1887,1144,1187,1082,1173,1113,1186,1066,1050,1158,1128,1143,1172,1097,1171,1081,420,391,1157,1112,1170,1142,1127,1065,1169,1049,1156,1096,1141,1111,1155,1080,1126,1154,1064,1153,1140,1095,1048,-2159,1125,1110,1137,-2175,823,823,1139,1138,807,807,384,264,368,263,868,838,853,791,867,822,852,837,866,806,865,790,-2319,851,821,836,352,262,850,805,849,-2399,533,533,835,820,336,261,578,548,563,577,532,532,832,772,562,562,547,547,305,275,560,515,290,290,288,258 };\n    static const uint8_t tab32[] = { 130,162,193,209,44,28,76,140,9,9,9,9,9,9,9,9,190,254,222,238,126,94,157,157,109,61,173,205 };\n    static const uint8_t tab33[] = { 252,236,220,204,188,172,156,140,124,108,92,76,60,44,28,12 };\n    static const int16_t tabindex[2*16] = { 0,32,64,98,0,132,180,218,292,364,426,538,648,746,0,1126,1460,1460,1460,1460,1460,1460,1460,1460,1842,1842,1842,1842,1842,1842,1842,1842 };\n    static const uint8_t g_linbits[] =  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,6,8,10,13,4,5,6,7,8,9,11,13 };\n\n#define PEEK_BITS(n)  (bs_cache >> (32 - n))\n#define FLUSH_BITS(n) { bs_cache <<= (n); bs_sh += (n); }\n#define CHECK_BITS    while (bs_sh >= 0) { bs_cache |= (uint32_t)*bs_next_ptr++ << bs_sh; bs_sh -= 8; }\n#define BSPOS         ((bs_next_ptr - bs->buf)*8 - 24 + bs_sh)\n\n    float one = 0.0f;\n    int ireg = 0, big_val_cnt = gr_info->big_values;\n    const uint8_t *sfb = gr_info->sfbtab;\n    const uint8_t *bs_next_ptr = bs->buf + bs->pos/8;\n    uint32_t bs_cache = (((bs_next_ptr[0]*256u + bs_next_ptr[1])*256u + bs_next_ptr[2])*256u + bs_next_ptr[3]) << (bs->pos & 7);\n    int pairs_to_decode, np, bs_sh = (bs->pos & 7) - 8;\n    bs_next_ptr += 4;\n\n    while (big_val_cnt > 0)\n    {\n        int tab_num = gr_info->table_select[ireg];\n        int sfb_cnt = gr_info->region_count[ireg++];\n        const int16_t *codebook = tabs + tabindex[tab_num];\n        int linbits = g_linbits[tab_num];\n        if (linbits)\n        {\n            do\n            {\n                np = *sfb++ / 2;\n                pairs_to_decode = MINIMP3_MIN(big_val_cnt, np);\n                one = *scf++;\n                do\n                {\n                    int j, w = 5;\n                    int leaf = codebook[PEEK_BITS(w)];\n                    while (leaf < 0)\n                    {\n                        FLUSH_BITS(w);\n                        w = leaf & 7;\n                        leaf = codebook[PEEK_BITS(w) - (leaf >> 3)];\n                    }\n                    FLUSH_BITS(leaf >> 8);\n\n                    for (j = 0; j < 2; j++, dst++, leaf >>= 4)\n                    {\n                        int lsb = leaf & 0x0F;\n                        if (lsb == 15)\n                        {\n                            lsb += PEEK_BITS(linbits);\n                            FLUSH_BITS(linbits);\n                            CHECK_BITS;\n                            *dst = one*L3_pow_43(lsb)*((int32_t)bs_cache < 0 ? -1: 1);\n                        } else\n                        {\n                            *dst = g_pow43[16 + lsb - 16*(bs_cache >> 31)]*one;\n                        }\n                        FLUSH_BITS(lsb ? 1 : 0);\n                    }\n                    CHECK_BITS;\n                } while (--pairs_to_decode);\n            } while ((big_val_cnt -= np) > 0 && --sfb_cnt >= 0);\n        } else\n        {\n            do\n            {\n                np = *sfb++ / 2;\n                pairs_to_decode = MINIMP3_MIN(big_val_cnt, np);\n                one = *scf++;\n                do\n                {\n                    int j, w = 5;\n                    int leaf = codebook[PEEK_BITS(w)];\n                    while (leaf < 0)\n                    {\n                        FLUSH_BITS(w);\n                        w = leaf & 7;\n                        leaf = codebook[PEEK_BITS(w) - (leaf >> 3)];\n                    }\n                    FLUSH_BITS(leaf >> 8);\n\n                    for (j = 0; j < 2; j++, dst++, leaf >>= 4)\n                    {\n                        int lsb = leaf & 0x0F;\n                        *dst = g_pow43[16 + lsb - 16*(bs_cache >> 31)]*one;\n                        FLUSH_BITS(lsb ? 1 : 0);\n                    }\n                    CHECK_BITS;\n                } while (--pairs_to_decode);\n            } while ((big_val_cnt -= np) > 0 && --sfb_cnt >= 0);\n        }\n    }\n\n    for (np = 1 - big_val_cnt;; dst += 4)\n    {\n        const uint8_t *codebook_count1 = (gr_info->count1_table) ? tab33 : tab32;\n        int leaf = codebook_count1[PEEK_BITS(4)];\n        if (!(leaf & 8))\n        {\n            leaf = codebook_count1[(leaf >> 3) + (bs_cache << 4 >> (32 - (leaf & 3)))];\n        }\n        FLUSH_BITS(leaf & 7);\n        if (BSPOS > layer3gr_limit)\n        {\n            break;\n        }\n#define RELOAD_SCALEFACTOR  if (!--np) { np = *sfb++/2; if (!np) break; one = *scf++; }\n#define DEQ_COUNT1(s) if (leaf & (128 >> s)) { dst[s] = ((int32_t)bs_cache < 0) ? -one : one; FLUSH_BITS(1) }\n        RELOAD_SCALEFACTOR;\n        DEQ_COUNT1(0);\n        DEQ_COUNT1(1);\n        RELOAD_SCALEFACTOR;\n        DEQ_COUNT1(2);\n        DEQ_COUNT1(3);\n        CHECK_BITS;\n    }\n\n    bs->pos = layer3gr_limit;\n}\n\nstatic void L3_midside_stereo(float *left, int n)\n{\n    int i = 0;\n    float *right = left + 576;\n#if HAVE_SIMD\n    if (have_simd())\n    {\n        for (; i < n - 3; i += 4)\n        {\n            f4 vl = VLD(left + i);\n            f4 vr = VLD(right + i);\n            VSTORE(left + i, VADD(vl, vr));\n            VSTORE(right + i, VSUB(vl, vr));\n        }\n#ifdef __GNUC__\n        /* Workaround for spurious -Waggressive-loop-optimizations warning from gcc.\n         * For more info see: https://github.com/lieff/minimp3/issues/88\n         */\n        if (__builtin_constant_p(n % 4 == 0) && n % 4 == 0)\n            return;\n#endif\n    }\n#endif /* HAVE_SIMD */\n    for (; i < n; i++)\n    {\n        float a = left[i];\n        float b = right[i];\n        left[i] = a + b;\n        right[i] = a - b;\n    }\n}\n\nstatic void L3_intensity_stereo_band(float *left, int n, float kl, float kr)\n{\n    int i;\n    for (i = 0; i < n; i++)\n    {\n        left[i + 576] = left[i]*kr;\n        left[i] = left[i]*kl;\n    }\n}\n\nstatic void L3_stereo_top_band(const float *right, const uint8_t *sfb, int nbands, int max_band[3])\n{\n    int i, k;\n\n    max_band[0] = max_band[1] = max_band[2] = -1;\n\n    for (i = 0; i < nbands; i++)\n    {\n        for (k = 0; k < sfb[i]; k += 2)\n        {\n            if (right[k] != 0 || right[k + 1] != 0)\n            {\n                max_band[i % 3] = i;\n                break;\n            }\n        }\n        right += sfb[i];\n    }\n}\n\nstatic void L3_stereo_process(float *left, const uint8_t *ist_pos, const uint8_t *sfb, const uint8_t *hdr, int max_band[3], int mpeg2_sh)\n{\n    static const float g_pan[7*2] = { 0,1,0.21132487f,0.78867513f,0.36602540f,0.63397460f,0.5f,0.5f,0.63397460f,0.36602540f,0.78867513f,0.21132487f,1,0 };\n    unsigned i, max_pos = HDR_TEST_MPEG1(hdr) ? 7 : 64;\n\n    for (i = 0; sfb[i]; i++)\n    {\n        unsigned ipos = ist_pos[i];\n        if ((int)i > max_band[i % 3] && ipos < max_pos)\n        {\n            float kl, kr, s = HDR_TEST_MS_STEREO(hdr) ? 1.41421356f : 1;\n            if (HDR_TEST_MPEG1(hdr))\n            {\n                kl = g_pan[2*ipos];\n                kr = g_pan[2*ipos + 1];\n            } else\n            {\n                kl = 1;\n                kr = L3_ldexp_q2(1, (ipos + 1) >> 1 << mpeg2_sh);\n                if (ipos & 1)\n                {\n                    kl = kr;\n                    kr = 1;\n                }\n            }\n            L3_intensity_stereo_band(left, sfb[i], kl*s, kr*s);\n        } else if (HDR_TEST_MS_STEREO(hdr))\n        {\n            L3_midside_stereo(left, sfb[i]);\n        }\n        left += sfb[i];\n    }\n}\n\nstatic void L3_intensity_stereo(float *left, uint8_t *ist_pos, const L3_gr_info_t *gr, const uint8_t *hdr)\n{\n    int max_band[3], n_sfb = gr->n_long_sfb + gr->n_short_sfb;\n    int i, max_blocks = gr->n_short_sfb ? 3 : 1;\n\n    L3_stereo_top_band(left + 576, gr->sfbtab, n_sfb, max_band);\n    if (gr->n_long_sfb)\n    {\n        max_band[0] = max_band[1] = max_band[2] = MINIMP3_MAX(MINIMP3_MAX(max_band[0], max_band[1]), max_band[2]);\n    }\n    for (i = 0; i < max_blocks; i++)\n    {\n        int default_pos = HDR_TEST_MPEG1(hdr) ? 3 : 0;\n        int itop = n_sfb - max_blocks + i;\n        int prev = itop - max_blocks;\n        ist_pos[itop] = max_band[i] >= prev ? default_pos : ist_pos[prev];\n    }\n    L3_stereo_process(left, ist_pos, gr->sfbtab, hdr, max_band, gr[1].scalefac_compress & 1);\n}\n\nstatic void L3_reorder(float *grbuf, float *scratch, const uint8_t *sfb)\n{\n    int i, len;\n    float *src = grbuf, *dst = scratch;\n\n    for (;0 != (len = *sfb); sfb += 3, src += 2*len)\n    {\n        for (i = 0; i < len; i++, src++)\n        {\n            *dst++ = src[0*len];\n            *dst++ = src[1*len];\n            *dst++ = src[2*len];\n        }\n    }\n    memcpy(grbuf, scratch, (dst - scratch)*sizeof(float));\n}\n\nstatic void L3_antialias(float *grbuf, int nbands)\n{\n    static const float g_aa[2][8] = {\n        {0.85749293f,0.88174200f,0.94962865f,0.98331459f,0.99551782f,0.99916056f,0.99989920f,0.99999316f},\n        {0.51449576f,0.47173197f,0.31337745f,0.18191320f,0.09457419f,0.04096558f,0.01419856f,0.00369997f}\n    };\n\n    for (; nbands > 0; nbands--, grbuf += 18)\n    {\n        int i = 0;\n#if HAVE_SIMD\n        if (have_simd()) for (; i < 8; i += 4)\n        {\n            f4 vu = VLD(grbuf + 18 + i);\n            f4 vd = VLD(grbuf + 14 - i);\n            f4 vc0 = VLD(g_aa[0] + i);\n            f4 vc1 = VLD(g_aa[1] + i);\n            vd = VREV(vd);\n            VSTORE(grbuf + 18 + i, VSUB(VMUL(vu, vc0), VMUL(vd, vc1)));\n            vd = VADD(VMUL(vu, vc1), VMUL(vd, vc0));\n            VSTORE(grbuf + 14 - i, VREV(vd));\n        }\n#endif /* HAVE_SIMD */\n#ifndef MINIMP3_ONLY_SIMD\n        for(; i < 8; i++)\n        {\n            float u = grbuf[18 + i];\n            float d = grbuf[17 - i];\n            grbuf[18 + i] = u*g_aa[0][i] - d*g_aa[1][i];\n            grbuf[17 - i] = u*g_aa[1][i] + d*g_aa[0][i];\n        }\n#endif /* MINIMP3_ONLY_SIMD */\n    }\n}\n\nstatic void L3_dct3_9(float *y)\n{\n    float s0, s1, s2, s3, s4, s5, s6, s7, s8, t0, t2, t4;\n\n    s0 = y[0]; s2 = y[2]; s4 = y[4]; s6 = y[6]; s8 = y[8];\n    t0 = s0 + s6*0.5f;\n    s0 -= s6;\n    t4 = (s4 + s2)*0.93969262f;\n    t2 = (s8 + s2)*0.76604444f;\n    s6 = (s4 - s8)*0.17364818f;\n    s4 += s8 - s2;\n\n    s2 = s0 - s4*0.5f;\n    y[4] = s4 + s0;\n    s8 = t0 - t2 + s6;\n    s0 = t0 - t4 + t2;\n    s4 = t0 + t4 - s6;\n\n    s1 = y[1]; s3 = y[3]; s5 = y[5]; s7 = y[7];\n\n    s3 *= 0.86602540f;\n    t0 = (s5 + s1)*0.98480775f;\n    t4 = (s5 - s7)*0.34202014f;\n    t2 = (s1 + s7)*0.64278761f;\n    s1 = (s1 - s5 - s7)*0.86602540f;\n\n    s5 = t0 - s3 - t2;\n    s7 = t4 - s3 - t0;\n    s3 = t4 + s3 - t2;\n\n    y[0] = s4 - s7;\n    y[1] = s2 + s1;\n    y[2] = s0 - s3;\n    y[3] = s8 + s5;\n    y[5] = s8 - s5;\n    y[6] = s0 + s3;\n    y[7] = s2 - s1;\n    y[8] = s4 + s7;\n}\n\nstatic void L3_imdct36(float *grbuf, float *overlap, const float *window, int nbands)\n{\n    int i, j;\n    static const float g_twid9[18] = {\n        0.73727734f,0.79335334f,0.84339145f,0.88701083f,0.92387953f,0.95371695f,0.97629601f,0.99144486f,0.99904822f,0.67559021f,0.60876143f,0.53729961f,0.46174861f,0.38268343f,0.30070580f,0.21643961f,0.13052619f,0.04361938f\n    };\n\n    for (j = 0; j < nbands; j++, grbuf += 18, overlap += 9)\n    {\n        float co[9], si[9];\n        co[0] = -grbuf[0];\n        si[0] = grbuf[17];\n        for (i = 0; i < 4; i++)\n        {\n            si[8 - 2*i] =   grbuf[4*i + 1] - grbuf[4*i + 2];\n            co[1 + 2*i] =   grbuf[4*i + 1] + grbuf[4*i + 2];\n            si[7 - 2*i] =   grbuf[4*i + 4] - grbuf[4*i + 3];\n            co[2 + 2*i] = -(grbuf[4*i + 3] + grbuf[4*i + 4]);\n        }\n        L3_dct3_9(co);\n        L3_dct3_9(si);\n\n        si[1] = -si[1];\n        si[3] = -si[3];\n        si[5] = -si[5];\n        si[7] = -si[7];\n\n        i = 0;\n\n#if HAVE_SIMD\n        if (have_simd()) for (; i < 8; i += 4)\n        {\n            f4 vovl = VLD(overlap + i);\n            f4 vc = VLD(co + i);\n            f4 vs = VLD(si + i);\n            f4 vr0 = VLD(g_twid9 + i);\n            f4 vr1 = VLD(g_twid9 + 9 + i);\n            f4 vw0 = VLD(window + i);\n            f4 vw1 = VLD(window + 9 + i);\n            f4 vsum = VADD(VMUL(vc, vr1), VMUL(vs, vr0));\n            VSTORE(overlap + i, VSUB(VMUL(vc, vr0), VMUL(vs, vr1)));\n            VSTORE(grbuf + i, VSUB(VMUL(vovl, vw0), VMUL(vsum, vw1)));\n            vsum = VADD(VMUL(vovl, vw1), VMUL(vsum, vw0));\n            VSTORE(grbuf + 14 - i, VREV(vsum));\n        }\n#endif /* HAVE_SIMD */\n        for (; i < 9; i++)\n        {\n            float ovl  = overlap[i];\n            float sum  = co[i]*g_twid9[9 + i] + si[i]*g_twid9[0 + i];\n            overlap[i] = co[i]*g_twid9[0 + i] - si[i]*g_twid9[9 + i];\n            grbuf[i]      = ovl*window[0 + i] - sum*window[9 + i];\n            grbuf[17 - i] = ovl*window[9 + i] + sum*window[0 + i];\n        }\n    }\n}\n\nstatic void L3_idct3(float x0, float x1, float x2, float *dst)\n{\n    float m1 = x1*0.86602540f;\n    float a1 = x0 - x2*0.5f;\n    dst[1] = x0 + x2;\n    dst[0] = a1 + m1;\n    dst[2] = a1 - m1;\n}\n\nstatic void L3_imdct12(float *x, float *dst, float *overlap)\n{\n    static const float g_twid3[6] = { 0.79335334f,0.92387953f,0.99144486f, 0.60876143f,0.38268343f,0.13052619f };\n    float co[3], si[3];\n    int i;\n\n    L3_idct3(-x[0], x[6] + x[3], x[12] + x[9], co);\n    L3_idct3(x[15], x[12] - x[9], x[6] - x[3], si);\n    si[1] = -si[1];\n\n    for (i = 0; i < 3; i++)\n    {\n        float ovl  = overlap[i];\n        float sum  = co[i]*g_twid3[3 + i] + si[i]*g_twid3[0 + i];\n        overlap[i] = co[i]*g_twid3[0 + i] - si[i]*g_twid3[3 + i];\n        dst[i]     = ovl*g_twid3[2 - i] - sum*g_twid3[5 - i];\n        dst[5 - i] = ovl*g_twid3[5 - i] + sum*g_twid3[2 - i];\n    }\n}\n\nstatic void L3_imdct_short(float *grbuf, float *overlap, int nbands)\n{\n    for (;nbands > 0; nbands--, overlap += 9, grbuf += 18)\n    {\n        float tmp[18];\n        memcpy(tmp, grbuf, sizeof(tmp));\n        memcpy(grbuf, overlap, 6*sizeof(float));\n        L3_imdct12(tmp, grbuf + 6, overlap + 6);\n        L3_imdct12(tmp + 1, grbuf + 12, overlap + 6);\n        L3_imdct12(tmp + 2, overlap, overlap + 6);\n    }\n}\n\nstatic void L3_change_sign(float *grbuf)\n{\n    int b, i;\n    for (b = 0, grbuf += 18; b < 32; b += 2, grbuf += 36)\n        for (i = 1; i < 18; i += 2)\n            grbuf[i] = -grbuf[i];\n}\n\nstatic void L3_imdct_gr(float *grbuf, float *overlap, unsigned block_type, unsigned n_long_bands)\n{\n    static const float g_mdct_window[2][18] = {\n        { 0.99904822f,0.99144486f,0.97629601f,0.95371695f,0.92387953f,0.88701083f,0.84339145f,0.79335334f,0.73727734f,0.04361938f,0.13052619f,0.21643961f,0.30070580f,0.38268343f,0.46174861f,0.53729961f,0.60876143f,0.67559021f },\n        { 1,1,1,1,1,1,0.99144486f,0.92387953f,0.79335334f,0,0,0,0,0,0,0.13052619f,0.38268343f,0.60876143f }\n    };\n    if (n_long_bands)\n    {\n        L3_imdct36(grbuf, overlap, g_mdct_window[0], n_long_bands);\n        grbuf += 18*n_long_bands;\n        overlap += 9*n_long_bands;\n    }\n    if (block_type == SHORT_BLOCK_TYPE)\n        L3_imdct_short(grbuf, overlap, 32 - n_long_bands);\n    else\n        L3_imdct36(grbuf, overlap, g_mdct_window[block_type == STOP_BLOCK_TYPE], 32 - n_long_bands);\n}\n\nstatic void L3_save_reservoir(mp3dec_t *h, mp3dec_scratch_t *s)\n{\n    int pos = (s->bs.pos + 7)/8u;\n    int remains = s->bs.limit/8u - pos;\n    if (remains > MAX_BITRESERVOIR_BYTES)\n    {\n        pos += remains - MAX_BITRESERVOIR_BYTES;\n        remains = MAX_BITRESERVOIR_BYTES;\n    }\n    if (remains > 0)\n    {\n        memmove(h->reserv_buf, s->maindata + pos, remains);\n    }\n    h->reserv = remains;\n}\n\nstatic int L3_restore_reservoir(mp3dec_t *h, bs_t *bs, mp3dec_scratch_t *s, int main_data_begin)\n{\n    int frame_bytes = (bs->limit - bs->pos)/8;\n    int bytes_have = MINIMP3_MIN(h->reserv, main_data_begin);\n    memcpy(s->maindata, h->reserv_buf + MINIMP3_MAX(0, h->reserv - main_data_begin), MINIMP3_MIN(h->reserv, main_data_begin));\n    memcpy(s->maindata + bytes_have, bs->buf + bs->pos/8, frame_bytes);\n    bs_init(&s->bs, s->maindata, bytes_have + frame_bytes);\n    return h->reserv >= main_data_begin;\n}\n\nstatic void L3_decode(mp3dec_t *h, mp3dec_scratch_t *s, L3_gr_info_t *gr_info, int nch)\n{\n    int ch;\n\n    for (ch = 0; ch < nch; ch++)\n    {\n        int layer3gr_limit = s->bs.pos + gr_info[ch].part_23_length;\n        L3_decode_scalefactors(h->header, s->ist_pos[ch], &s->bs, gr_info + ch, s->scf, ch);\n        L3_huffman(s->grbuf[ch], &s->bs, gr_info + ch, s->scf, layer3gr_limit);\n    }\n\n    if (HDR_TEST_I_STEREO(h->header))\n    {\n        L3_intensity_stereo(s->grbuf[0], s->ist_pos[1], gr_info, h->header);\n    } else if (HDR_IS_MS_STEREO(h->header))\n    {\n        L3_midside_stereo(s->grbuf[0], 576);\n    }\n\n    for (ch = 0; ch < nch; ch++, gr_info++)\n    {\n        int aa_bands = 31;\n        int n_long_bands = (gr_info->mixed_block_flag ? 2 : 0) << (int)(HDR_GET_MY_SAMPLE_RATE(h->header) == 2);\n\n        if (gr_info->n_short_sfb)\n        {\n            aa_bands = n_long_bands - 1;\n            L3_reorder(s->grbuf[ch] + n_long_bands*18, s->syn[0], gr_info->sfbtab + gr_info->n_long_sfb);\n        }\n\n        L3_antialias(s->grbuf[ch], aa_bands);\n        L3_imdct_gr(s->grbuf[ch], h->mdct_overlap[ch], gr_info->block_type, n_long_bands);\n        L3_change_sign(s->grbuf[ch]);\n    }\n}\n\nstatic void mp3d_DCT_II(float *grbuf, int n)\n{\n    static const float g_sec[24] = {\n        10.19000816f,0.50060302f,0.50241929f,3.40760851f,0.50547093f,0.52249861f,2.05778098f,0.51544732f,0.56694406f,1.48416460f,0.53104258f,0.64682180f,1.16943991f,0.55310392f,0.78815460f,0.97256821f,0.58293498f,1.06067765f,0.83934963f,0.62250412f,1.72244716f,0.74453628f,0.67480832f,5.10114861f\n    };\n    int i, k = 0;\n#if HAVE_SIMD\n    if (have_simd()) for (; k < n; k += 4)\n    {\n        f4 t[4][8], *x;\n        float *y = grbuf + k;\n\n        for (x = t[0], i = 0; i < 8; i++, x++)\n        {\n            f4 x0 = VLD(&y[i*18]);\n            f4 x1 = VLD(&y[(15 - i)*18]);\n            f4 x2 = VLD(&y[(16 + i)*18]);\n            f4 x3 = VLD(&y[(31 - i)*18]);\n            f4 t0 = VADD(x0, x3);\n            f4 t1 = VADD(x1, x2);\n            f4 t2 = VMUL_S(VSUB(x1, x2), g_sec[3*i + 0]);\n            f4 t3 = VMUL_S(VSUB(x0, x3), g_sec[3*i + 1]);\n            x[0] = VADD(t0, t1);\n            x[8] = VMUL_S(VSUB(t0, t1), g_sec[3*i + 2]);\n            x[16] = VADD(t3, t2);\n            x[24] = VMUL_S(VSUB(t3, t2), g_sec[3*i + 2]);\n        }\n        for (x = t[0], i = 0; i < 4; i++, x += 8)\n        {\n            f4 x0 = x[0], x1 = x[1], x2 = x[2], x3 = x[3], x4 = x[4], x5 = x[5], x6 = x[6], x7 = x[7], xt;\n            xt = VSUB(x0, x7); x0 = VADD(x0, x7);\n            x7 = VSUB(x1, x6); x1 = VADD(x1, x6);\n            x6 = VSUB(x2, x5); x2 = VADD(x2, x5);\n            x5 = VSUB(x3, x4); x3 = VADD(x3, x4);\n            x4 = VSUB(x0, x3); x0 = VADD(x0, x3);\n            x3 = VSUB(x1, x2); x1 = VADD(x1, x2);\n            x[0] = VADD(x0, x1);\n            x[4] = VMUL_S(VSUB(x0, x1), 0.70710677f);\n            x5 = VADD(x5, x6);\n            x6 = VMUL_S(VADD(x6, x7), 0.70710677f);\n            x7 = VADD(x7, xt);\n            x3 = VMUL_S(VADD(x3, x4), 0.70710677f);\n            x5 = VSUB(x5, VMUL_S(x7, 0.198912367f)); /* rotate by PI/8 */\n            x7 = VADD(x7, VMUL_S(x5, 0.382683432f));\n            x5 = VSUB(x5, VMUL_S(x7, 0.198912367f));\n            x0 = VSUB(xt, x6); xt = VADD(xt, x6);\n            x[1] = VMUL_S(VADD(xt, x7), 0.50979561f);\n            x[2] = VMUL_S(VADD(x4, x3), 0.54119611f);\n            x[3] = VMUL_S(VSUB(x0, x5), 0.60134488f);\n            x[5] = VMUL_S(VADD(x0, x5), 0.89997619f);\n            x[6] = VMUL_S(VSUB(x4, x3), 1.30656302f);\n            x[7] = VMUL_S(VSUB(xt, x7), 2.56291556f);\n        }\n\n        if (k > n - 3)\n        {\n#if HAVE_SSE\n#define VSAVE2(i, v) _mm_storel_pi((__m64 *)(void*)&y[i*18], v)\n#else /* HAVE_SSE */\n#define VSAVE2(i, v) vst1_f32((float32_t *)&y[i*18],  vget_low_f32(v))\n#endif /* HAVE_SSE */\n            for (i = 0; i < 7; i++, y += 4*18)\n            {\n                f4 s = VADD(t[3][i], t[3][i + 1]);\n                VSAVE2(0, t[0][i]);\n                VSAVE2(1, VADD(t[2][i], s));\n                VSAVE2(2, VADD(t[1][i], t[1][i + 1]));\n                VSAVE2(3, VADD(t[2][1 + i], s));\n            }\n            VSAVE2(0, t[0][7]);\n            VSAVE2(1, VADD(t[2][7], t[3][7]));\n            VSAVE2(2, t[1][7]);\n            VSAVE2(3, t[3][7]);\n        } else\n        {\n#define VSAVE4(i, v) VSTORE(&y[i*18], v)\n            for (i = 0; i < 7; i++, y += 4*18)\n            {\n                f4 s = VADD(t[3][i], t[3][i + 1]);\n                VSAVE4(0, t[0][i]);\n                VSAVE4(1, VADD(t[2][i], s));\n                VSAVE4(2, VADD(t[1][i], t[1][i + 1]));\n                VSAVE4(3, VADD(t[2][1 + i], s));\n            }\n            VSAVE4(0, t[0][7]);\n            VSAVE4(1, VADD(t[2][7], t[3][7]));\n            VSAVE4(2, t[1][7]);\n            VSAVE4(3, t[3][7]);\n        }\n    } else\n#endif /* HAVE_SIMD */\n#ifdef MINIMP3_ONLY_SIMD\n    {} /* for HAVE_SIMD=1, MINIMP3_ONLY_SIMD=1 case we do not need non-intrinsic \"else\" branch */\n#else /* MINIMP3_ONLY_SIMD */\n    for (; k < n; k++)\n    {\n        float t[4][8], *x, *y = grbuf + k;\n\n        for (x = t[0], i = 0; i < 8; i++, x++)\n        {\n            float x0 = y[i*18];\n            float x1 = y[(15 - i)*18];\n            float x2 = y[(16 + i)*18];\n            float x3 = y[(31 - i)*18];\n            float t0 = x0 + x3;\n            float t1 = x1 + x2;\n            float t2 = (x1 - x2)*g_sec[3*i + 0];\n            float t3 = (x0 - x3)*g_sec[3*i + 1];\n            x[0] = t0 + t1;\n            x[8] = (t0 - t1)*g_sec[3*i + 2];\n            x[16] = t3 + t2;\n            x[24] = (t3 - t2)*g_sec[3*i + 2];\n        }\n        for (x = t[0], i = 0; i < 4; i++, x += 8)\n        {\n            float x0 = x[0], x1 = x[1], x2 = x[2], x3 = x[3], x4 = x[4], x5 = x[5], x6 = x[6], x7 = x[7], xt;\n            xt = x0 - x7; x0 += x7;\n            x7 = x1 - x6; x1 += x6;\n            x6 = x2 - x5; x2 += x5;\n            x5 = x3 - x4; x3 += x4;\n            x4 = x0 - x3; x0 += x3;\n            x3 = x1 - x2; x1 += x2;\n            x[0] = x0 + x1;\n            x[4] = (x0 - x1)*0.70710677f;\n            x5 =  x5 + x6;\n            x6 = (x6 + x7)*0.70710677f;\n            x7 =  x7 + xt;\n            x3 = (x3 + x4)*0.70710677f;\n            x5 -= x7*0.198912367f;  /* rotate by PI/8 */\n            x7 += x5*0.382683432f;\n            x5 -= x7*0.198912367f;\n            x0 = xt - x6; xt += x6;\n            x[1] = (xt + x7)*0.50979561f;\n            x[2] = (x4 + x3)*0.54119611f;\n            x[3] = (x0 - x5)*0.60134488f;\n            x[5] = (x0 + x5)*0.89997619f;\n            x[6] = (x4 - x3)*1.30656302f;\n            x[7] = (xt - x7)*2.56291556f;\n\n        }\n        for (i = 0; i < 7; i++, y += 4*18)\n        {\n            y[0*18] = t[0][i];\n            y[1*18] = t[2][i] + t[3][i] + t[3][i + 1];\n            y[2*18] = t[1][i] + t[1][i + 1];\n            y[3*18] = t[2][i + 1] + t[3][i] + t[3][i + 1];\n        }\n        y[0*18] = t[0][7];\n        y[1*18] = t[2][7] + t[3][7];\n        y[2*18] = t[1][7];\n        y[3*18] = t[3][7];\n    }\n#endif /* MINIMP3_ONLY_SIMD */\n}\n\n#ifndef MINIMP3_FLOAT_OUTPUT\nstatic int16_t mp3d_scale_pcm(float sample)\n{\n#if HAVE_ARMV6\n    int32_t s32 = (int32_t)(sample + .5f);\n    s32 -= (s32 < 0);\n    int16_t s = (int16_t)minimp3_clip_int16_arm(s32);\n#else\n    if (sample >=  32766.5) return (int16_t) 32767;\n    if (sample <= -32767.5) return (int16_t)-32768;\n    int16_t s = (int16_t)(sample + .5f);\n    s -= (s < 0);   /* away from zero, to be compliant */\n#endif\n    return s;\n}\n#else /* MINIMP3_FLOAT_OUTPUT */\nstatic float mp3d_scale_pcm(float sample)\n{\n    return sample*(1.f/32768.f);\n}\n#endif /* MINIMP3_FLOAT_OUTPUT */\n\nstatic void mp3d_synth_pair(mp3d_sample_t *pcm, int nch, const float *z)\n{\n    float a;\n    a  = (z[14*64] - z[    0]) * 29;\n    a += (z[ 1*64] + z[13*64]) * 213;\n    a += (z[12*64] - z[ 2*64]) * 459;\n    a += (z[ 3*64] + z[11*64]) * 2037;\n    a += (z[10*64] - z[ 4*64]) * 5153;\n    a += (z[ 5*64] + z[ 9*64]) * 6574;\n    a += (z[ 8*64] - z[ 6*64]) * 37489;\n    a +=  z[ 7*64]             * 75038;\n    pcm[0] = mp3d_scale_pcm(a);\n\n    z += 2;\n    a  = z[14*64] * 104;\n    a += z[12*64] * 1567;\n    a += z[10*64] * 9727;\n    a += z[ 8*64] * 64019;\n    a += z[ 6*64] * -9975;\n    a += z[ 4*64] * -45;\n    a += z[ 2*64] * 146;\n    a += z[ 0*64] * -5;\n    pcm[16*nch] = mp3d_scale_pcm(a);\n}\n\nstatic void mp3d_synth(float *xl, mp3d_sample_t *dstl, int nch, float *lins)\n{\n    int i;\n    float *xr = xl + 576*(nch - 1);\n    mp3d_sample_t *dstr = dstl + (nch - 1);\n\n    static const float g_win[] = {\n        -1,26,-31,208,218,401,-519,2063,2000,4788,-5517,7134,5959,35640,-39336,74992,\n        -1,24,-35,202,222,347,-581,2080,1952,4425,-5879,7640,5288,33791,-41176,74856,\n        -1,21,-38,196,225,294,-645,2087,1893,4063,-6237,8092,4561,31947,-43006,74630,\n        -1,19,-41,190,227,244,-711,2085,1822,3705,-6589,8492,3776,30112,-44821,74313,\n        -1,17,-45,183,228,197,-779,2075,1739,3351,-6935,8840,2935,28289,-46617,73908,\n        -1,16,-49,176,228,153,-848,2057,1644,3004,-7271,9139,2037,26482,-48390,73415,\n        -2,14,-53,169,227,111,-919,2032,1535,2663,-7597,9389,1082,24694,-50137,72835,\n        -2,13,-58,161,224,72,-991,2001,1414,2330,-7910,9592,70,22929,-51853,72169,\n        -2,11,-63,154,221,36,-1064,1962,1280,2006,-8209,9750,-998,21189,-53534,71420,\n        -2,10,-68,147,215,2,-1137,1919,1131,1692,-8491,9863,-2122,19478,-55178,70590,\n        -3,9,-73,139,208,-29,-1210,1870,970,1388,-8755,9935,-3300,17799,-56778,69679,\n        -3,8,-79,132,200,-57,-1283,1817,794,1095,-8998,9966,-4533,16155,-58333,68692,\n        -4,7,-85,125,189,-83,-1356,1759,605,814,-9219,9959,-5818,14548,-59838,67629,\n        -4,7,-91,117,177,-106,-1428,1698,402,545,-9416,9916,-7154,12980,-61289,66494,\n        -5,6,-97,111,163,-127,-1498,1634,185,288,-9585,9838,-8540,11455,-62684,65290\n    };\n    float *zlin = lins + 15*64;\n    const float *w = g_win;\n\n    zlin[4*15]     = xl[18*16];\n    zlin[4*15 + 1] = xr[18*16];\n    zlin[4*15 + 2] = xl[0];\n    zlin[4*15 + 3] = xr[0];\n\n    zlin[4*31]     = xl[1 + 18*16];\n    zlin[4*31 + 1] = xr[1 + 18*16];\n    zlin[4*31 + 2] = xl[1];\n    zlin[4*31 + 3] = xr[1];\n\n    mp3d_synth_pair(dstr, nch, lins + 4*15 + 1);\n    mp3d_synth_pair(dstr + 32*nch, nch, lins + 4*15 + 64 + 1);\n    mp3d_synth_pair(dstl, nch, lins + 4*15);\n    mp3d_synth_pair(dstl + 32*nch, nch, lins + 4*15 + 64);\n\n#if HAVE_SIMD\n    if (have_simd()) for (i = 14; i >= 0; i--)\n    {\n#define VLOAD(k) f4 w0 = VSET(*w++); f4 w1 = VSET(*w++); f4 vz = VLD(&zlin[4*i - 64*k]); f4 vy = VLD(&zlin[4*i - 64*(15 - k)]);\n#define V0(k) { VLOAD(k) b =         VADD(VMUL(vz, w1), VMUL(vy, w0)) ; a =         VSUB(VMUL(vz, w0), VMUL(vy, w1));  }\n#define V1(k) { VLOAD(k) b = VADD(b, VADD(VMUL(vz, w1), VMUL(vy, w0))); a = VADD(a, VSUB(VMUL(vz, w0), VMUL(vy, w1))); }\n#define V2(k) { VLOAD(k) b = VADD(b, VADD(VMUL(vz, w1), VMUL(vy, w0))); a = VADD(a, VSUB(VMUL(vy, w1), VMUL(vz, w0))); }\n        f4 a, b;\n        zlin[4*i]     = xl[18*(31 - i)];\n        zlin[4*i + 1] = xr[18*(31 - i)];\n        zlin[4*i + 2] = xl[1 + 18*(31 - i)];\n        zlin[4*i + 3] = xr[1 + 18*(31 - i)];\n        zlin[4*i + 64] = xl[1 + 18*(1 + i)];\n        zlin[4*i + 64 + 1] = xr[1 + 18*(1 + i)];\n        zlin[4*i - 64 + 2] = xl[18*(1 + i)];\n        zlin[4*i - 64 + 3] = xr[18*(1 + i)];\n\n        V0(0) V2(1) V1(2) V2(3) V1(4) V2(5) V1(6) V2(7)\n\n        {\n#ifndef MINIMP3_FLOAT_OUTPUT\n#if HAVE_SSE\n            static const f4 g_max = { 32767.0f, 32767.0f, 32767.0f, 32767.0f };\n            static const f4 g_min = { -32768.0f, -32768.0f, -32768.0f, -32768.0f };\n            __m128i pcm8 = _mm_packs_epi32(_mm_cvtps_epi32(_mm_max_ps(_mm_min_ps(a, g_max), g_min)),\n                                           _mm_cvtps_epi32(_mm_max_ps(_mm_min_ps(b, g_max), g_min)));\n            dstr[(15 - i)*nch] = _mm_extract_epi16(pcm8, 1);\n            dstr[(17 + i)*nch] = _mm_extract_epi16(pcm8, 5);\n            dstl[(15 - i)*nch] = _mm_extract_epi16(pcm8, 0);\n            dstl[(17 + i)*nch] = _mm_extract_epi16(pcm8, 4);\n            dstr[(47 - i)*nch] = _mm_extract_epi16(pcm8, 3);\n            dstr[(49 + i)*nch] = _mm_extract_epi16(pcm8, 7);\n            dstl[(47 - i)*nch] = _mm_extract_epi16(pcm8, 2);\n            dstl[(49 + i)*nch] = _mm_extract_epi16(pcm8, 6);\n#else /* HAVE_SSE */\n            int16x4_t pcma, pcmb;\n            a = VADD(a, VSET(0.5f));\n            b = VADD(b, VSET(0.5f));\n            pcma = vqmovn_s32(vqaddq_s32(vcvtq_s32_f32(a), vreinterpretq_s32_u32(vcltq_f32(a, VSET(0)))));\n            pcmb = vqmovn_s32(vqaddq_s32(vcvtq_s32_f32(b), vreinterpretq_s32_u32(vcltq_f32(b, VSET(0)))));\n            vst1_lane_s16(dstr + (15 - i)*nch, pcma, 1);\n            vst1_lane_s16(dstr + (17 + i)*nch, pcmb, 1);\n            vst1_lane_s16(dstl + (15 - i)*nch, pcma, 0);\n            vst1_lane_s16(dstl + (17 + i)*nch, pcmb, 0);\n            vst1_lane_s16(dstr + (47 - i)*nch, pcma, 3);\n            vst1_lane_s16(dstr + (49 + i)*nch, pcmb, 3);\n            vst1_lane_s16(dstl + (47 - i)*nch, pcma, 2);\n            vst1_lane_s16(dstl + (49 + i)*nch, pcmb, 2);\n#endif /* HAVE_SSE */\n\n#else /* MINIMP3_FLOAT_OUTPUT */\n\n            static const f4 g_scale = { 1.0f/32768.0f, 1.0f/32768.0f, 1.0f/32768.0f, 1.0f/32768.0f };\n            a = VMUL(a, g_scale);\n            b = VMUL(b, g_scale);\n#if HAVE_SSE\n            _mm_store_ss(dstr + (15 - i)*nch, _mm_shuffle_ps(a, a, _MM_SHUFFLE(1, 1, 1, 1)));\n            _mm_store_ss(dstr + (17 + i)*nch, _mm_shuffle_ps(b, b, _MM_SHUFFLE(1, 1, 1, 1)));\n            _mm_store_ss(dstl + (15 - i)*nch, _mm_shuffle_ps(a, a, _MM_SHUFFLE(0, 0, 0, 0)));\n            _mm_store_ss(dstl + (17 + i)*nch, _mm_shuffle_ps(b, b, _MM_SHUFFLE(0, 0, 0, 0)));\n            _mm_store_ss(dstr + (47 - i)*nch, _mm_shuffle_ps(a, a, _MM_SHUFFLE(3, 3, 3, 3)));\n            _mm_store_ss(dstr + (49 + i)*nch, _mm_shuffle_ps(b, b, _MM_SHUFFLE(3, 3, 3, 3)));\n            _mm_store_ss(dstl + (47 - i)*nch, _mm_shuffle_ps(a, a, _MM_SHUFFLE(2, 2, 2, 2)));\n            _mm_store_ss(dstl + (49 + i)*nch, _mm_shuffle_ps(b, b, _MM_SHUFFLE(2, 2, 2, 2)));\n#else /* HAVE_SSE */\n            vst1q_lane_f32(dstr + (15 - i)*nch, a, 1);\n            vst1q_lane_f32(dstr + (17 + i)*nch, b, 1);\n            vst1q_lane_f32(dstl + (15 - i)*nch, a, 0);\n            vst1q_lane_f32(dstl + (17 + i)*nch, b, 0);\n            vst1q_lane_f32(dstr + (47 - i)*nch, a, 3);\n            vst1q_lane_f32(dstr + (49 + i)*nch, b, 3);\n            vst1q_lane_f32(dstl + (47 - i)*nch, a, 2);\n            vst1q_lane_f32(dstl + (49 + i)*nch, b, 2);\n#endif /* HAVE_SSE */\n#endif /* MINIMP3_FLOAT_OUTPUT */\n        }\n    } else\n#endif /* HAVE_SIMD */\n#ifdef MINIMP3_ONLY_SIMD\n    {} /* for HAVE_SIMD=1, MINIMP3_ONLY_SIMD=1 case we do not need non-intrinsic \"else\" branch */\n#else /* MINIMP3_ONLY_SIMD */\n    for (i = 14; i >= 0; i--)\n    {\n#define LOAD(k) float w0 = *w++; float w1 = *w++; float *vz = &zlin[4*i - k*64]; float *vy = &zlin[4*i - (15 - k)*64];\n#define S0(k) { int j; LOAD(k); for (j = 0; j < 4; j++) b[j]  = vz[j]*w1 + vy[j]*w0, a[j]  = vz[j]*w0 - vy[j]*w1; }\n#define S1(k) { int j; LOAD(k); for (j = 0; j < 4; j++) b[j] += vz[j]*w1 + vy[j]*w0, a[j] += vz[j]*w0 - vy[j]*w1; }\n#define S2(k) { int j; LOAD(k); for (j = 0; j < 4; j++) b[j] += vz[j]*w1 + vy[j]*w0, a[j] += vy[j]*w1 - vz[j]*w0; }\n        float a[4], b[4];\n\n        zlin[4*i]     = xl[18*(31 - i)];\n        zlin[4*i + 1] = xr[18*(31 - i)];\n        zlin[4*i + 2] = xl[1 + 18*(31 - i)];\n        zlin[4*i + 3] = xr[1 + 18*(31 - i)];\n        zlin[4*(i + 16)]   = xl[1 + 18*(1 + i)];\n        zlin[4*(i + 16) + 1] = xr[1 + 18*(1 + i)];\n        zlin[4*(i - 16) + 2] = xl[18*(1 + i)];\n        zlin[4*(i - 16) + 3] = xr[18*(1 + i)];\n\n        S0(0) S2(1) S1(2) S2(3) S1(4) S2(5) S1(6) S2(7)\n\n        dstr[(15 - i)*nch] = mp3d_scale_pcm(a[1]);\n        dstr[(17 + i)*nch] = mp3d_scale_pcm(b[1]);\n        dstl[(15 - i)*nch] = mp3d_scale_pcm(a[0]);\n        dstl[(17 + i)*nch] = mp3d_scale_pcm(b[0]);\n        dstr[(47 - i)*nch] = mp3d_scale_pcm(a[3]);\n        dstr[(49 + i)*nch] = mp3d_scale_pcm(b[3]);\n        dstl[(47 - i)*nch] = mp3d_scale_pcm(a[2]);\n        dstl[(49 + i)*nch] = mp3d_scale_pcm(b[2]);\n    }\n#endif /* MINIMP3_ONLY_SIMD */\n}\n\nstatic void mp3d_synth_granule(float *qmf_state, float *grbuf, int nbands, int nch, mp3d_sample_t *pcm, float *lins)\n{\n    int i;\n    for (i = 0; i < nch; i++)\n    {\n        mp3d_DCT_II(grbuf + 576*i, nbands);\n    }\n\n    memcpy(lins, qmf_state, sizeof(float)*15*64);\n\n    for (i = 0; i < nbands; i += 2)\n    {\n        mp3d_synth(grbuf + i, pcm + 32*nch*i, nch, lins + i*64);\n    }\n#ifndef MINIMP3_NONSTANDARD_BUT_LOGICAL\n    if (nch == 1)\n    {\n        for (i = 0; i < 15*64; i += 2)\n        {\n            qmf_state[i] = lins[nbands*64 + i];\n        }\n    } else\n#endif /* MINIMP3_NONSTANDARD_BUT_LOGICAL */\n    {\n        memcpy(qmf_state, lins + nbands*64, sizeof(float)*15*64);\n    }\n}\n\nstatic int mp3d_match_frame(const uint8_t *hdr, int mp3_bytes, int frame_bytes)\n{\n    int i, nmatch;\n    for (i = 0, nmatch = 0; nmatch < MAX_FRAME_SYNC_MATCHES; nmatch++)\n    {\n        i += hdr_frame_bytes(hdr + i, frame_bytes) + hdr_padding(hdr + i);\n        if (i + HDR_SIZE > mp3_bytes)\n            return nmatch > 0;\n        if (!hdr_compare(hdr, hdr + i))\n            return 0;\n    }\n    return 1;\n}\n\nstatic int mp3d_find_frame(const uint8_t *mp3, int mp3_bytes, int *free_format_bytes, int *ptr_frame_bytes)\n{\n    int i, k;\n    for (i = 0; i < mp3_bytes - HDR_SIZE; i++, mp3++)\n    {\n        if (hdr_valid(mp3))\n        {\n            int frame_bytes = hdr_frame_bytes(mp3, *free_format_bytes);\n            int frame_and_padding = frame_bytes + hdr_padding(mp3);\n\n            for (k = HDR_SIZE; !frame_bytes && k < MAX_FREE_FORMAT_FRAME_SIZE && i + 2*k < mp3_bytes - HDR_SIZE; k++)\n            {\n                if (hdr_compare(mp3, mp3 + k))\n                {\n                    int fb = k - hdr_padding(mp3);\n                    int nextfb = fb + hdr_padding(mp3 + k);\n                    if (i + k + nextfb + HDR_SIZE > mp3_bytes || !hdr_compare(mp3, mp3 + k + nextfb))\n                        continue;\n                    frame_and_padding = k;\n                    frame_bytes = fb;\n                    *free_format_bytes = fb;\n                }\n            }\n            if ((frame_bytes && i + frame_and_padding <= mp3_bytes &&\n                mp3d_match_frame(mp3, mp3_bytes - i, frame_bytes)) ||\n                (!i && frame_and_padding == mp3_bytes))\n            {\n                *ptr_frame_bytes = frame_and_padding;\n                return i;\n            }\n            *free_format_bytes = 0;\n        }\n    }\n    *ptr_frame_bytes = 0;\n    return mp3_bytes;\n}\n\nvoid mp3dec_init(mp3dec_t *dec)\n{\n    dec->header[0] = 0;\n}\n\nint mp3dec_decode_frame(mp3dec_t *dec, const uint8_t *mp3, int mp3_bytes, mp3d_sample_t *pcm, mp3dec_frame_info_t *info)\n{\n    int i = 0, igr, frame_size = 0, success = 1;\n    const uint8_t *hdr;\n    bs_t bs_frame[1];\n    mp3dec_scratch_t scratch;\n\n    if (mp3_bytes > 4 && dec->header[0] == 0xff && hdr_compare(dec->header, mp3))\n    {\n        frame_size = hdr_frame_bytes(mp3, dec->free_format_bytes) + hdr_padding(mp3);\n        if (frame_size != mp3_bytes && (frame_size + HDR_SIZE > mp3_bytes || !hdr_compare(mp3, mp3 + frame_size)))\n        {\n            frame_size = 0;\n        }\n    }\n    if (!frame_size)\n    {\n        memset(dec, 0, sizeof(mp3dec_t));\n        i = mp3d_find_frame(mp3, mp3_bytes, &dec->free_format_bytes, &frame_size);\n        if (!frame_size || i + frame_size > mp3_bytes)\n        {\n            info->frame_bytes = i;\n            return 0;\n        }\n    }\n\n    hdr = mp3 + i;\n    memcpy(dec->header, hdr, HDR_SIZE);\n    info->frame_bytes = i + frame_size;\n    info->frame_offset = i;\n    info->channels = HDR_IS_MONO(hdr) ? 1 : 2;\n    info->hz = hdr_sample_rate_hz(hdr);\n    info->layer = 4 - HDR_GET_LAYER(hdr);\n    info->bitrate_kbps = hdr_bitrate_kbps(hdr);\n\n    if (!pcm)\n    {\n        return hdr_frame_samples(hdr);\n    }\n\n    bs_init(bs_frame, hdr + HDR_SIZE, frame_size - HDR_SIZE);\n    if (HDR_IS_CRC(hdr))\n    {\n        get_bits(bs_frame, 16);\n    }\n\n    if (info->layer == 3)\n    {\n        int main_data_begin = L3_read_side_info(bs_frame, scratch.gr_info, hdr);\n        if (main_data_begin < 0 || bs_frame->pos > bs_frame->limit)\n        {\n            mp3dec_init(dec);\n            return 0;\n        }\n        success = L3_restore_reservoir(dec, bs_frame, &scratch, main_data_begin);\n        if (success)\n        {\n            for (igr = 0; igr < (HDR_TEST_MPEG1(hdr) ? 2 : 1); igr++, pcm += 576*info->channels)\n            {\n                memset(scratch.grbuf[0], 0, 576*2*sizeof(float));\n                L3_decode(dec, &scratch, scratch.gr_info + igr*info->channels, info->channels);\n                mp3d_synth_granule(dec->qmf_state, scratch.grbuf[0], 18, info->channels, pcm, scratch.syn[0]);\n            }\n        }\n        L3_save_reservoir(dec, &scratch);\n    } else\n    {\n#ifdef MINIMP3_ONLY_MP3\n        return 0;\n#else /* MINIMP3_ONLY_MP3 */\n        L12_scale_info sci[1];\n        L12_read_scale_info(hdr, bs_frame, sci);\n\n        memset(scratch.grbuf[0], 0, 576*2*sizeof(float));\n        for (i = 0, igr = 0; igr < 3; igr++)\n        {\n            if (12 == (i += L12_dequantize_granule(scratch.grbuf[0] + i, bs_frame, sci, info->layer | 1)))\n            {\n                i = 0;\n                L12_apply_scf_384(sci, sci->scf + igr, scratch.grbuf[0]);\n                mp3d_synth_granule(dec->qmf_state, scratch.grbuf[0], 12, info->channels, pcm, scratch.syn[0]);\n                memset(scratch.grbuf[0], 0, 576*2*sizeof(float));\n                pcm += 384*info->channels;\n            }\n            if (bs_frame->pos > bs_frame->limit)\n            {\n                mp3dec_init(dec);\n                return 0;\n            }\n        }\n#endif /* MINIMP3_ONLY_MP3 */\n    }\n    return success*hdr_frame_samples(dec->header);\n}\n\n#ifdef MINIMP3_FLOAT_OUTPUT\nvoid mp3dec_f32_to_s16(const float *in, int16_t *out, int num_samples)\n{\n    int i = 0;\n#if HAVE_SIMD\n    int aligned_count = num_samples & ~7;\n    for(; i < aligned_count; i += 8)\n    {\n        static const f4 g_scale = { 32768.0f, 32768.0f, 32768.0f, 32768.0f };\n        f4 a = VMUL(VLD(&in[i  ]), g_scale);\n        f4 b = VMUL(VLD(&in[i+4]), g_scale);\n#if HAVE_SSE\n        static const f4 g_max = { 32767.0f, 32767.0f, 32767.0f, 32767.0f };\n        static const f4 g_min = { -32768.0f, -32768.0f, -32768.0f, -32768.0f };\n        __m128i pcm8 = _mm_packs_epi32(_mm_cvtps_epi32(_mm_max_ps(_mm_min_ps(a, g_max), g_min)),\n                                       _mm_cvtps_epi32(_mm_max_ps(_mm_min_ps(b, g_max), g_min)));\n        out[i  ] = _mm_extract_epi16(pcm8, 0);\n        out[i+1] = _mm_extract_epi16(pcm8, 1);\n        out[i+2] = _mm_extract_epi16(pcm8, 2);\n        out[i+3] = _mm_extract_epi16(pcm8, 3);\n        out[i+4] = _mm_extract_epi16(pcm8, 4);\n        out[i+5] = _mm_extract_epi16(pcm8, 5);\n        out[i+6] = _mm_extract_epi16(pcm8, 6);\n        out[i+7] = _mm_extract_epi16(pcm8, 7);\n#else /* HAVE_SSE */\n        int16x4_t pcma, pcmb;\n        a = VADD(a, VSET(0.5f));\n        b = VADD(b, VSET(0.5f));\n        pcma = vqmovn_s32(vqaddq_s32(vcvtq_s32_f32(a), vreinterpretq_s32_u32(vcltq_f32(a, VSET(0)))));\n        pcmb = vqmovn_s32(vqaddq_s32(vcvtq_s32_f32(b), vreinterpretq_s32_u32(vcltq_f32(b, VSET(0)))));\n        vst1_lane_s16(out+i  , pcma, 0);\n        vst1_lane_s16(out+i+1, pcma, 1);\n        vst1_lane_s16(out+i+2, pcma, 2);\n        vst1_lane_s16(out+i+3, pcma, 3);\n        vst1_lane_s16(out+i+4, pcmb, 0);\n        vst1_lane_s16(out+i+5, pcmb, 1);\n        vst1_lane_s16(out+i+6, pcmb, 2);\n        vst1_lane_s16(out+i+7, pcmb, 3);\n#endif /* HAVE_SSE */\n    }\n#endif /* HAVE_SIMD */\n    for(; i < num_samples; i++)\n    {\n        float sample = in[i] * 32768.0f;\n        if (sample >=  32766.5)\n            out[i] = (int16_t) 32767;\n        else if (sample <= -32767.5)\n            out[i] = (int16_t)-32768;\n        else\n        {\n            int16_t s = (int16_t)(sample + .5f);\n            s -= (s < 0);   /* away from zero, to be compliant */\n            out[i] = s;\n        }\n    }\n}\n#endif /* MINIMP3_FLOAT_OUTPUT */\n#endif /* MINIMP3_IMPLEMENTATION && !_MINIMP3_IMPLEMENTATION_GUARD */\n"
        },
        {
          "name": "minimp3_ex.h",
          "type": "blob",
          "size": 48.3505859375,
          "content": "#ifndef MINIMP3_EXT_H\n#define MINIMP3_EXT_H\n/*\n    https://github.com/lieff/minimp3\n    To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide.\n    This software is distributed without any warranty.\n    See <http://creativecommons.org/publicdomain/zero/1.0/>.\n*/\n#include <stddef.h>\n#include \"minimp3.h\"\n\n/* flags for mp3dec_ex_open_* functions */\n#define MP3D_SEEK_TO_BYTE   0      /* mp3dec_ex_seek seeks to byte in stream */\n#define MP3D_SEEK_TO_SAMPLE 1      /* mp3dec_ex_seek precisely seeks to sample using index (created during duration calculation scan or when mp3dec_ex_seek called) */\n#define MP3D_DO_NOT_SCAN    2      /* do not scan whole stream for duration if vbrtag not found, mp3dec_ex_t::samples will be filled only if mp3dec_ex_t::vbr_tag_found == 1 */\n#ifdef MINIMP3_ALLOW_MONO_STEREO_TRANSITION\n#define MP3D_ALLOW_MONO_STEREO_TRANSITION  4\n#define MP3D_FLAGS_MASK 7\n#else\n#define MP3D_FLAGS_MASK 3\n#endif\n\n/* compile-time config */\n#define MINIMP3_PREDECODE_FRAMES 2 /* frames to pre-decode and skip after seek (to fill internal structures) */\n/*#define MINIMP3_SEEK_IDX_LINEAR_SEARCH*/ /* define to use linear index search instead of binary search on seek */\n#define MINIMP3_IO_SIZE (128*1024) /* io buffer size for streaming functions, must be greater than MINIMP3_BUF_SIZE */\n#define MINIMP3_BUF_SIZE (16*1024) /* buffer which can hold minimum 10 consecutive mp3 frames (~16KB) worst case */\n/*#define MINIMP3_SCAN_LIMIT (256*1024)*/ /* how many bytes will be scanned to search first valid mp3 frame, to prevent stall on large non-mp3 files */\n#define MINIMP3_ENABLE_RING 0      /* WIP enable hardware magic ring buffer if available, to make less input buffer memmove(s) in callback IO mode */\n\n/* return error codes */\n#define MP3D_E_PARAM   -1\n#define MP3D_E_MEMORY  -2\n#define MP3D_E_IOERROR -3\n#define MP3D_E_USER    -4  /* can be used to stop processing from callbacks without indicating specific error */\n#define MP3D_E_DECODE  -5  /* decode error which can't be safely skipped, such as sample rate, layer and channels change */\n\ntypedef struct\n{\n    mp3d_sample_t *buffer;\n    size_t samples; /* channels included, byte size = samples*sizeof(mp3d_sample_t) */\n    int channels, hz, layer, avg_bitrate_kbps;\n} mp3dec_file_info_t;\n\ntypedef struct\n{\n    const uint8_t *buffer;\n    size_t size;\n} mp3dec_map_info_t;\n\ntypedef struct\n{\n    uint64_t sample;\n    uint64_t offset;\n} mp3dec_frame_t;\n\ntypedef struct\n{\n    mp3dec_frame_t *frames;\n    size_t num_frames, capacity;\n} mp3dec_index_t;\n\ntypedef size_t (*MP3D_READ_CB)(void *buf, size_t size, void *user_data);\ntypedef int (*MP3D_SEEK_CB)(uint64_t position, void *user_data);\n\ntypedef struct\n{\n    MP3D_READ_CB read;\n    void *read_data;\n    MP3D_SEEK_CB seek;\n    void *seek_data;\n} mp3dec_io_t;\n\ntypedef struct\n{\n    mp3dec_t mp3d;\n    mp3dec_map_info_t file;\n    mp3dec_io_t *io;\n    mp3dec_index_t index;\n    uint64_t offset, samples, detected_samples, cur_sample, start_offset, end_offset;\n    mp3dec_frame_info_t info;\n    mp3d_sample_t buffer[MINIMP3_MAX_SAMPLES_PER_FRAME];\n    size_t input_consumed, input_filled;\n    int is_file, flags, vbr_tag_found, indexes_built;\n    int free_format_bytes;\n    int buffer_samples, buffer_consumed, to_skip, start_delay;\n    int last_error;\n} mp3dec_ex_t;\n\ntypedef int (*MP3D_ITERATE_CB)(void *user_data, const uint8_t *frame, int frame_size, int free_format_bytes, size_t buf_size, uint64_t offset, mp3dec_frame_info_t *info);\ntypedef int (*MP3D_PROGRESS_CB)(void *user_data, size_t file_size, uint64_t offset, mp3dec_frame_info_t *info);\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* detect mp3/mpa format */\nint mp3dec_detect_buf(const uint8_t *buf, size_t buf_size);\nint mp3dec_detect_cb(mp3dec_io_t *io, uint8_t *buf, size_t buf_size);\n/* decode whole buffer block */\nint mp3dec_load_buf(mp3dec_t *dec, const uint8_t *buf, size_t buf_size, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\nint mp3dec_load_cb(mp3dec_t *dec, mp3dec_io_t *io, uint8_t *buf, size_t buf_size, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\n/* iterate through frames */\nint mp3dec_iterate_buf(const uint8_t *buf, size_t buf_size, MP3D_ITERATE_CB callback, void *user_data);\nint mp3dec_iterate_cb(mp3dec_io_t *io, uint8_t *buf, size_t buf_size, MP3D_ITERATE_CB callback, void *user_data);\n/* streaming decoder with seeking capability */\nint mp3dec_ex_open_buf(mp3dec_ex_t *dec, const uint8_t *buf, size_t buf_size, int flags);\nint mp3dec_ex_open_cb(mp3dec_ex_t *dec, mp3dec_io_t *io, int flags);\nvoid mp3dec_ex_close(mp3dec_ex_t *dec);\nint mp3dec_ex_seek(mp3dec_ex_t *dec, uint64_t position);\nsize_t mp3dec_ex_read_frame(mp3dec_ex_t *dec, mp3d_sample_t **buf, mp3dec_frame_info_t *frame_info, size_t max_samples);\nsize_t mp3dec_ex_read(mp3dec_ex_t *dec, mp3d_sample_t *buf, size_t samples);\n#ifndef MINIMP3_NO_STDIO\n/* stdio versions of file detect, load, iterate and stream */\nint mp3dec_detect(const char *file_name);\nint mp3dec_load(mp3dec_t *dec, const char *file_name, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\nint mp3dec_iterate(const char *file_name, MP3D_ITERATE_CB callback, void *user_data);\nint mp3dec_ex_open(mp3dec_ex_t *dec, const char *file_name, int flags);\n#ifdef _WIN32\nint mp3dec_detect_w(const wchar_t *file_name);\nint mp3dec_load_w(mp3dec_t *dec, const wchar_t *file_name, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data);\nint mp3dec_iterate_w(const wchar_t *file_name, MP3D_ITERATE_CB callback, void *user_data);\nint mp3dec_ex_open_w(mp3dec_ex_t *dec, const wchar_t *file_name, int flags);\n#endif\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif /*MINIMP3_EXT_H*/\n\n#if defined(MINIMP3_IMPLEMENTATION) && !defined(_MINIMP3_EX_IMPLEMENTATION_GUARD)\n#define _MINIMP3_EX_IMPLEMENTATION_GUARD\n#include <limits.h>\n#include \"minimp3.h\"\n\nstatic void mp3dec_skip_id3v1(const uint8_t *buf, size_t *pbuf_size)\n{\n    size_t buf_size = *pbuf_size;\n#ifndef MINIMP3_NOSKIP_ID3V1\n    if (buf_size >= 128 && !memcmp(buf + buf_size - 128, \"TAG\", 3))\n    {\n        buf_size -= 128;\n        if (buf_size >= 227 && !memcmp(buf + buf_size - 227, \"TAG+\", 4))\n            buf_size -= 227;\n    }\n#endif\n#ifndef MINIMP3_NOSKIP_APEV2\n    if (buf_size > 32 && !memcmp(buf + buf_size - 32, \"APETAGEX\", 8))\n    {\n        buf_size -= 32;\n        const uint8_t *tag = buf + buf_size + 8 + 4;\n        uint32_t tag_size = (uint32_t)(tag[3] << 24) | (tag[2] << 16) | (tag[1] << 8) | tag[0];\n        if (buf_size >= tag_size)\n            buf_size -= tag_size;\n    }\n#endif\n    *pbuf_size = buf_size;\n}\n\nstatic size_t mp3dec_skip_id3v2(const uint8_t *buf, size_t buf_size)\n{\n#define MINIMP3_ID3_DETECT_SIZE 10\n#ifndef MINIMP3_NOSKIP_ID3V2\n    if (buf_size >= MINIMP3_ID3_DETECT_SIZE && !memcmp(buf, \"ID3\", 3) && !((buf[5] & 15) || (buf[6] & 0x80) || (buf[7] & 0x80) || (buf[8] & 0x80) || (buf[9] & 0x80)))\n    {\n        size_t id3v2size = (((buf[6] & 0x7f) << 21) | ((buf[7] & 0x7f) << 14) | ((buf[8] & 0x7f) << 7) | (buf[9] & 0x7f)) + 10;\n        if ((buf[5] & 16))\n            id3v2size += 10; /* footer */\n        return id3v2size;\n    }\n#endif\n    return 0;\n}\n\nstatic void mp3dec_skip_id3(const uint8_t **pbuf, size_t *pbuf_size)\n{\n    uint8_t *buf = (uint8_t *)(*pbuf);\n    size_t buf_size = *pbuf_size;\n    size_t id3v2size = mp3dec_skip_id3v2(buf, buf_size);\n    if (id3v2size)\n    {\n        if (id3v2size >= buf_size)\n            id3v2size = buf_size;\n        buf      += id3v2size;\n        buf_size -= id3v2size;\n    }\n    mp3dec_skip_id3v1(buf, &buf_size);\n    *pbuf = (const uint8_t *)buf;\n    *pbuf_size = buf_size;\n}\n\nstatic int mp3dec_check_vbrtag(const uint8_t *frame, int frame_size, uint32_t *frames, int *delay, int *padding)\n{\n    static const char g_xing_tag[4] = { 'X', 'i', 'n', 'g' };\n    static const char g_info_tag[4] = { 'I', 'n', 'f', 'o' };\n#define FRAMES_FLAG     1\n#define BYTES_FLAG      2\n#define TOC_FLAG        4\n#define VBR_SCALE_FLAG  8\n    /* Side info offsets after header:\n    /                Mono  Stereo\n    /  MPEG1          17     32\n    /  MPEG2 & 2.5     9     17*/\n    bs_t bs[1];\n    L3_gr_info_t gr_info[4];\n    bs_init(bs, frame + HDR_SIZE, frame_size - HDR_SIZE);\n    if (HDR_IS_CRC(frame))\n        get_bits(bs, 16);\n    if (L3_read_side_info(bs, gr_info, frame) < 0)\n        return 0; /* side info corrupted */\n\n    const uint8_t *tag = frame + HDR_SIZE + bs->pos/8;\n    if (memcmp(g_xing_tag, tag, 4) && memcmp(g_info_tag, tag, 4))\n        return 0;\n    int flags = tag[7];\n    if (!((flags & FRAMES_FLAG)))\n        return -1;\n    tag += 8;\n    *frames = (uint32_t)(tag[0] << 24) | (tag[1] << 16) | (tag[2] << 8) | tag[3];\n    tag += 4;\n    if (flags & BYTES_FLAG)\n        tag += 4;\n    if (flags & TOC_FLAG)\n        tag += 100;\n    if (flags & VBR_SCALE_FLAG)\n        tag += 4;\n    *delay = *padding = 0;\n    if (*tag)\n    {   /* extension, LAME, Lavc, etc. Should be the same structure. */\n        tag += 21;\n        if (tag - frame + 14 >= frame_size)\n            return 0;\n        *delay   = ((tag[0] << 4) | (tag[1] >> 4)) + (528 + 1);\n        *padding = (((tag[1] & 0xF) << 8) | tag[2]) - (528 + 1);\n    }\n    return 1;\n}\n\nint mp3dec_detect_buf(const uint8_t *buf, size_t buf_size)\n{\n    return mp3dec_detect_cb(0, (uint8_t *)buf, buf_size);\n}\n\nint mp3dec_detect_cb(mp3dec_io_t *io, uint8_t *buf, size_t buf_size)\n{\n    if (!buf || (size_t)-1 == buf_size || (io && buf_size < MINIMP3_BUF_SIZE))\n        return MP3D_E_PARAM;\n    size_t filled = buf_size;\n    if (io)\n    {\n        if (io->seek(0, io->seek_data))\n            return MP3D_E_IOERROR;\n        filled = io->read(buf, MINIMP3_ID3_DETECT_SIZE, io->read_data);\n        if (filled > MINIMP3_ID3_DETECT_SIZE)\n            return MP3D_E_IOERROR;\n    }\n    if (filled < MINIMP3_ID3_DETECT_SIZE)\n        return MP3D_E_USER; /* too small, can't be mp3/mpa */\n    if (mp3dec_skip_id3v2(buf, filled))\n        return 0; /* id3v2 tag is enough evidence */\n    if (io)\n    {\n        size_t readed = io->read(buf + MINIMP3_ID3_DETECT_SIZE, buf_size - MINIMP3_ID3_DETECT_SIZE, io->read_data);\n        if (readed > (buf_size - MINIMP3_ID3_DETECT_SIZE))\n            return MP3D_E_IOERROR;\n        filled += readed;\n        if (filled < MINIMP3_BUF_SIZE)\n            mp3dec_skip_id3v1(buf, &filled);\n    } else\n    {\n        mp3dec_skip_id3v1(buf, &filled);\n        if (filled > MINIMP3_BUF_SIZE)\n            filled = MINIMP3_BUF_SIZE;\n    }\n    int free_format_bytes, frame_size;\n    mp3d_find_frame(buf, filled, &free_format_bytes, &frame_size);\n    if (frame_size)\n        return 0; /* MAX_FRAME_SYNC_MATCHES consecutive frames found */\n    return MP3D_E_USER;\n}\n\nint mp3dec_load_buf(mp3dec_t *dec, const uint8_t *buf, size_t buf_size, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data)\n{\n    return mp3dec_load_cb(dec, 0, (uint8_t *)buf, buf_size, info, progress_cb, user_data);\n}\n\nint mp3dec_load_cb(mp3dec_t *dec, mp3dec_io_t *io, uint8_t *buf, size_t buf_size, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data)\n{\n    if (!dec || !buf || !info || (size_t)-1 == buf_size || (io && buf_size < MINIMP3_BUF_SIZE))\n        return MP3D_E_PARAM;\n    uint64_t detected_samples = 0;\n    size_t orig_buf_size = buf_size;\n    int to_skip = 0;\n    mp3dec_frame_info_t frame_info;\n    memset(info, 0, sizeof(*info));\n    memset(&frame_info, 0, sizeof(frame_info));\n\n    /* skip id3 */\n    size_t filled = 0, consumed = 0;\n    int eof = 0, ret = 0;\n    if (io)\n    {\n        if (io->seek(0, io->seek_data))\n            return MP3D_E_IOERROR;\n        filled = io->read(buf, MINIMP3_ID3_DETECT_SIZE, io->read_data);\n        if (filled > MINIMP3_ID3_DETECT_SIZE)\n            return MP3D_E_IOERROR;\n        if (MINIMP3_ID3_DETECT_SIZE != filled)\n            return 0;\n        size_t id3v2size = mp3dec_skip_id3v2(buf, filled);\n        if (id3v2size)\n        {\n            if (io->seek(id3v2size, io->seek_data))\n                return MP3D_E_IOERROR;\n            filled = io->read(buf, buf_size, io->read_data);\n            if (filled > buf_size)\n                return MP3D_E_IOERROR;\n        } else\n        {\n            size_t readed = io->read(buf + MINIMP3_ID3_DETECT_SIZE, buf_size - MINIMP3_ID3_DETECT_SIZE, io->read_data);\n            if (readed > (buf_size - MINIMP3_ID3_DETECT_SIZE))\n                return MP3D_E_IOERROR;\n            filled += readed;\n        }\n        if (filled < MINIMP3_BUF_SIZE)\n            mp3dec_skip_id3v1(buf, &filled);\n    } else\n    {\n        mp3dec_skip_id3((const uint8_t **)&buf, &buf_size);\n        if (!buf_size)\n            return 0;\n    }\n    /* try to make allocation size assumption by first frame or vbr tag */\n    mp3dec_init(dec);\n    int samples;\n    do\n    {\n        uint32_t frames;\n        int i, delay, padding, free_format_bytes = 0, frame_size = 0;\n        const uint8_t *hdr;\n        if (io)\n        {\n            if (!eof && filled - consumed < MINIMP3_BUF_SIZE)\n            {   /* keep minimum 10 consecutive mp3 frames (~16KB) worst case */\n                memmove(buf, buf + consumed, filled - consumed);\n                filled -= consumed;\n                consumed = 0;\n                size_t readed = io->read(buf + filled, buf_size - filled, io->read_data);\n                if (readed > (buf_size - filled))\n                    return MP3D_E_IOERROR;\n                if (readed != (buf_size - filled))\n                    eof = 1;\n                filled += readed;\n                if (eof)\n                    mp3dec_skip_id3v1(buf, &filled);\n            }\n            i = mp3d_find_frame(buf + consumed, filled - consumed, &free_format_bytes, &frame_size);\n            consumed += i;\n            hdr = buf + consumed;\n        } else\n        {\n            i = mp3d_find_frame(buf, buf_size, &free_format_bytes, &frame_size);\n            buf      += i;\n            buf_size -= i;\n            hdr = buf;\n        }\n        if (i && !frame_size)\n            continue;\n        if (!frame_size)\n            return 0;\n        frame_info.channels = HDR_IS_MONO(hdr) ? 1 : 2;\n        frame_info.hz = hdr_sample_rate_hz(hdr);\n        frame_info.layer = 4 - HDR_GET_LAYER(hdr);\n        frame_info.bitrate_kbps = hdr_bitrate_kbps(hdr);\n        frame_info.frame_bytes = frame_size;\n        samples = hdr_frame_samples(hdr)*frame_info.channels;\n        if (3 != frame_info.layer)\n            break;\n        int ret = mp3dec_check_vbrtag(hdr, frame_size, &frames, &delay, &padding);\n        if (ret > 0)\n        {\n            padding *= frame_info.channels;\n            to_skip = delay*frame_info.channels;\n            detected_samples = samples*(uint64_t)frames;\n            if (detected_samples >= (uint64_t)to_skip)\n                detected_samples -= to_skip;\n            if (padding > 0 && detected_samples >= (uint64_t)padding)\n                detected_samples -= padding;\n            if (!detected_samples)\n                return 0;\n        }\n        if (ret)\n        {\n            if (io)\n            {\n                consumed += frame_size;\n            } else\n            {\n                buf      += frame_size;\n                buf_size -= frame_size;\n            }\n        }\n        break;\n    } while(1);\n    size_t allocated = MINIMP3_MAX_SAMPLES_PER_FRAME*sizeof(mp3d_sample_t);\n    if (detected_samples)\n        allocated += detected_samples*sizeof(mp3d_sample_t);\n    else\n        allocated += (buf_size/frame_info.frame_bytes)*samples*sizeof(mp3d_sample_t);\n    info->buffer = (mp3d_sample_t*)malloc(allocated);\n    if (!info->buffer)\n        return MP3D_E_MEMORY;\n    /* save info */\n    info->channels = frame_info.channels;\n    info->hz       = frame_info.hz;\n    info->layer    = frame_info.layer;\n    /* decode all frames */\n    size_t avg_bitrate_kbps = 0, frames = 0;\n    do\n    {\n        if ((allocated - info->samples*sizeof(mp3d_sample_t)) < MINIMP3_MAX_SAMPLES_PER_FRAME*sizeof(mp3d_sample_t))\n        {\n            allocated *= 2;\n            mp3d_sample_t *alloc_buf = (mp3d_sample_t*)realloc(info->buffer, allocated);\n            if (!alloc_buf)\n                return MP3D_E_MEMORY;\n            info->buffer = alloc_buf;\n        }\n        if (io)\n        {\n            if (!eof && filled - consumed < MINIMP3_BUF_SIZE)\n            {   /* keep minimum 10 consecutive mp3 frames (~16KB) worst case */\n                memmove(buf, buf + consumed, filled - consumed);\n                filled -= consumed;\n                consumed = 0;\n                size_t readed = io->read(buf + filled, buf_size - filled, io->read_data);\n                if (readed != (buf_size - filled))\n                    eof = 1;\n                filled += readed;\n                if (eof)\n                    mp3dec_skip_id3v1(buf, &filled);\n            }\n            samples = mp3dec_decode_frame(dec, buf + consumed, filled - consumed, info->buffer + info->samples, &frame_info);\n            consumed += frame_info.frame_bytes;\n        } else\n        {\n            samples = mp3dec_decode_frame(dec, buf, MINIMP3_MIN(buf_size, (size_t)INT_MAX), info->buffer + info->samples, &frame_info);\n            buf      += frame_info.frame_bytes;\n            buf_size -= frame_info.frame_bytes;\n        }\n        if (samples)\n        {\n            if (info->hz != frame_info.hz || info->layer != frame_info.layer)\n            {\n                ret = MP3D_E_DECODE;\n                break;\n            }\n            if (info->channels && info->channels != frame_info.channels)\n            {\n#ifdef MINIMP3_ALLOW_MONO_STEREO_TRANSITION\n                info->channels = 0; /* mark file with mono-stereo transition */\n#else\n                ret = MP3D_E_DECODE;\n                break;\n#endif\n            }\n            samples *= frame_info.channels;\n            if (to_skip)\n            {\n                size_t skip = MINIMP3_MIN(samples, to_skip);\n                to_skip -= skip;\n                samples -= skip;\n                memmove(info->buffer, info->buffer + skip, samples*sizeof(mp3d_sample_t));\n            }\n            info->samples += samples;\n            avg_bitrate_kbps += frame_info.bitrate_kbps;\n            frames++;\n            if (progress_cb)\n            {\n                ret = progress_cb(user_data, orig_buf_size, orig_buf_size - buf_size, &frame_info);\n                if (ret)\n                    break;\n            }\n        }\n    } while (frame_info.frame_bytes);\n    if (detected_samples && info->samples > detected_samples)\n        info->samples = detected_samples; /* cut padding */\n    /* reallocate to normal buffer size */\n    if (allocated != info->samples*sizeof(mp3d_sample_t))\n    {\n        mp3d_sample_t *alloc_buf = (mp3d_sample_t*)realloc(info->buffer, info->samples*sizeof(mp3d_sample_t));\n        if (!alloc_buf && info->samples)\n            return MP3D_E_MEMORY;\n        info->buffer = alloc_buf;\n    }\n    if (frames)\n        info->avg_bitrate_kbps = avg_bitrate_kbps/frames;\n    return ret;\n}\n\nint mp3dec_iterate_buf(const uint8_t *buf, size_t buf_size, MP3D_ITERATE_CB callback, void *user_data)\n{\n    const uint8_t *orig_buf = buf;\n    if (!buf || (size_t)-1 == buf_size || !callback)\n        return MP3D_E_PARAM;\n    /* skip id3 */\n    mp3dec_skip_id3(&buf, &buf_size);\n    if (!buf_size)\n        return 0;\n    mp3dec_frame_info_t frame_info;\n    memset(&frame_info, 0, sizeof(frame_info));\n    do\n    {\n        int free_format_bytes = 0, frame_size = 0, ret;\n        int i = mp3d_find_frame(buf, buf_size, &free_format_bytes, &frame_size);\n        buf      += i;\n        buf_size -= i;\n        if (i && !frame_size)\n            continue;\n        if (!frame_size)\n            break;\n        const uint8_t *hdr = buf;\n        frame_info.channels = HDR_IS_MONO(hdr) ? 1 : 2;\n        frame_info.hz = hdr_sample_rate_hz(hdr);\n        frame_info.layer = 4 - HDR_GET_LAYER(hdr);\n        frame_info.bitrate_kbps = hdr_bitrate_kbps(hdr);\n        frame_info.frame_bytes = frame_size;\n\n        if (callback)\n        {\n            if ((ret = callback(user_data, hdr, frame_size, free_format_bytes, buf_size, hdr - orig_buf, &frame_info)))\n                return ret;\n        }\n        buf      += frame_size;\n        buf_size -= frame_size;\n    } while (1);\n    return 0;\n}\n\nint mp3dec_iterate_cb(mp3dec_io_t *io, uint8_t *buf, size_t buf_size, MP3D_ITERATE_CB callback, void *user_data)\n{\n    if (!io || !buf || (size_t)-1 == buf_size || buf_size < MINIMP3_BUF_SIZE || !callback)\n        return MP3D_E_PARAM;\n    size_t filled = io->read(buf, MINIMP3_ID3_DETECT_SIZE, io->read_data), consumed = 0;\n    uint64_t readed = 0;\n    mp3dec_frame_info_t frame_info;\n    int eof = 0;\n    memset(&frame_info, 0, sizeof(frame_info));\n    if (filled > MINIMP3_ID3_DETECT_SIZE)\n        return MP3D_E_IOERROR;\n    if (MINIMP3_ID3_DETECT_SIZE != filled)\n        return 0;\n    size_t id3v2size = mp3dec_skip_id3v2(buf, filled);\n    if (id3v2size)\n    {\n        if (io->seek(id3v2size, io->seek_data))\n            return MP3D_E_IOERROR;\n        filled = io->read(buf, buf_size, io->read_data);\n        if (filled > buf_size)\n            return MP3D_E_IOERROR;\n        readed += id3v2size;\n    } else\n    {\n        size_t readed = io->read(buf + MINIMP3_ID3_DETECT_SIZE, buf_size - MINIMP3_ID3_DETECT_SIZE, io->read_data);\n        if (readed > (buf_size - MINIMP3_ID3_DETECT_SIZE))\n            return MP3D_E_IOERROR;\n        filled += readed;\n    }\n    if (filled < MINIMP3_BUF_SIZE)\n        mp3dec_skip_id3v1(buf, &filled);\n    do\n    {\n        int free_format_bytes = 0, frame_size = 0, ret;\n        int i = mp3d_find_frame(buf + consumed, filled - consumed, &free_format_bytes, &frame_size);\n        if (i && !frame_size)\n        {\n            consumed += i;\n            continue;\n        }\n        if (!frame_size)\n            break;\n        const uint8_t *hdr = buf + consumed + i;\n        frame_info.channels = HDR_IS_MONO(hdr) ? 1 : 2;\n        frame_info.hz = hdr_sample_rate_hz(hdr);\n        frame_info.layer = 4 - HDR_GET_LAYER(hdr);\n        frame_info.bitrate_kbps = hdr_bitrate_kbps(hdr);\n        frame_info.frame_bytes = frame_size;\n\n        readed += i;\n        if (callback)\n        {\n            if ((ret = callback(user_data, hdr, frame_size, free_format_bytes, filled - consumed, readed, &frame_info)))\n                return ret;\n        }\n        readed += frame_size;\n        consumed += i + frame_size;\n        if (!eof && filled - consumed < MINIMP3_BUF_SIZE)\n        {   /* keep minimum 10 consecutive mp3 frames (~16KB) worst case */\n            memmove(buf, buf + consumed, filled - consumed);\n            filled -= consumed;\n            consumed = 0;\n            size_t readed = io->read(buf + filled, buf_size - filled, io->read_data);\n            if (readed > (buf_size - filled))\n                return MP3D_E_IOERROR;\n            if (readed != (buf_size - filled))\n                eof = 1;\n            filled += readed;\n            if (eof)\n                mp3dec_skip_id3v1(buf, &filled);\n        }\n    } while (1);\n    return 0;\n}\n\nstatic int mp3dec_load_index(void *user_data, const uint8_t *frame, int frame_size, int free_format_bytes, size_t buf_size, uint64_t offset, mp3dec_frame_info_t *info)\n{\n    mp3dec_frame_t *idx_frame;\n    mp3dec_ex_t *dec = (mp3dec_ex_t *)user_data;\n    if (!dec->index.frames && !dec->start_offset)\n    {   /* detect VBR tag and try to avoid full scan */\n        uint32_t frames;\n        int delay, padding;\n        dec->info = *info;\n        dec->start_offset = dec->offset = offset;\n        dec->end_offset   = offset + buf_size;\n        dec->free_format_bytes = free_format_bytes; /* should not change */\n        if (3 == dec->info.layer)\n        {\n            int ret = mp3dec_check_vbrtag(frame, frame_size, &frames, &delay, &padding);\n            if (ret)\n                dec->start_offset = dec->offset = offset + frame_size;\n            if (ret > 0)\n            {\n                padding *= info->channels;\n                dec->start_delay = dec->to_skip = delay*info->channels;\n                dec->samples = hdr_frame_samples(frame)*info->channels*(uint64_t)frames;\n                if (dec->samples >= (uint64_t)dec->start_delay)\n                    dec->samples -= dec->start_delay;\n                if (padding > 0 && dec->samples >= (uint64_t)padding)\n                    dec->samples -= padding;\n                dec->detected_samples = dec->samples;\n                dec->vbr_tag_found = 1;\n                return MP3D_E_USER;\n            } else if (ret < 0)\n                return 0;\n        }\n    }\n    if (dec->flags & MP3D_DO_NOT_SCAN)\n        return MP3D_E_USER;\n    if (dec->index.num_frames + 1 > dec->index.capacity)\n    {\n        if (!dec->index.capacity)\n            dec->index.capacity = 4096;\n        else\n            dec->index.capacity *= 2;\n        mp3dec_frame_t *alloc_buf = (mp3dec_frame_t *)realloc((void*)dec->index.frames, sizeof(mp3dec_frame_t)*dec->index.capacity);\n        if (!alloc_buf)\n            return MP3D_E_MEMORY;\n        dec->index.frames = alloc_buf;\n    }\n    idx_frame = &dec->index.frames[dec->index.num_frames++];\n    idx_frame->offset = offset;\n    idx_frame->sample = dec->samples;\n    if (!dec->buffer_samples && dec->index.num_frames < 256)\n    {   /* for some cutted mp3 frames, bit-reservoir not filled and decoding can't be started from first frames */\n        /* try to decode up to 255 first frames till samples starts to decode */\n        dec->buffer_samples = mp3dec_decode_frame(&dec->mp3d, frame, MINIMP3_MIN(buf_size, (size_t)INT_MAX), dec->buffer, info);\n        dec->samples += dec->buffer_samples*info->channels;\n    } else\n        dec->samples += hdr_frame_samples(frame)*info->channels;\n    return 0;\n}\n\nint mp3dec_ex_open_buf(mp3dec_ex_t *dec, const uint8_t *buf, size_t buf_size, int flags)\n{\n    if (!dec || !buf || (size_t)-1 == buf_size || (flags & (~MP3D_FLAGS_MASK)))\n        return MP3D_E_PARAM;\n    memset(dec, 0, sizeof(*dec));\n    dec->file.buffer = buf;\n    dec->file.size   = buf_size;\n    dec->flags       = flags;\n    mp3dec_init(&dec->mp3d);\n    int ret = mp3dec_iterate_buf(dec->file.buffer, dec->file.size, mp3dec_load_index, dec);\n    if (ret && MP3D_E_USER != ret)\n        return ret;\n    mp3dec_init(&dec->mp3d);\n    dec->buffer_samples = 0;\n    dec->indexes_built = !(dec->vbr_tag_found || (flags & MP3D_DO_NOT_SCAN));\n    dec->flags &= (~MP3D_DO_NOT_SCAN);\n    return 0;\n}\n\n#ifndef MINIMP3_SEEK_IDX_LINEAR_SEARCH\nstatic size_t mp3dec_idx_binary_search(mp3dec_index_t *idx, uint64_t position)\n{\n    size_t end = idx->num_frames, start = 0, index = 0;\n    while (start <= end)\n    {\n        size_t mid = (start + end) / 2;\n        if (idx->frames[mid].sample >= position)\n        {   /* move left side. */\n            if (idx->frames[mid].sample == position)\n                return mid;\n            end = mid - 1;\n        }  else\n        {   /* move to right side */\n            index = mid;\n            start = mid + 1;\n            if (start == idx->num_frames)\n                break;\n        }\n    }\n    return index;\n}\n#endif\n\nint mp3dec_ex_seek(mp3dec_ex_t *dec, uint64_t position)\n{\n    size_t i;\n    if (!dec)\n        return MP3D_E_PARAM;\n    if (!(dec->flags & MP3D_SEEK_TO_SAMPLE))\n    {\n        if (dec->io)\n        {\n            dec->offset = position;\n        } else\n        {\n            dec->offset = MINIMP3_MIN(position, dec->file.size);\n        }\n        dec->cur_sample = 0;\n        goto do_exit;\n    }\n    dec->cur_sample = position;\n    position += dec->start_delay;\n    if (0 == position)\n    {   /* optimize seek to zero, no index needed */\nseek_zero:\n        dec->offset  = dec->start_offset;\n        dec->to_skip = 0;\n        goto do_exit;\n    }\n    if (!dec->indexes_built)\n    {   /* no index created yet (vbr tag used to calculate track length or MP3D_DO_NOT_SCAN open flag used) */\n        dec->indexes_built = 1;\n        dec->samples = 0;\n        dec->buffer_samples = 0;\n        if (dec->io)\n        {\n            if (dec->io->seek(dec->start_offset, dec->io->seek_data))\n                return MP3D_E_IOERROR;\n            int ret = mp3dec_iterate_cb(dec->io, (uint8_t *)dec->file.buffer, dec->file.size, mp3dec_load_index, dec);\n            if (ret && MP3D_E_USER != ret)\n                return ret;\n        } else\n        {\n            int ret = mp3dec_iterate_buf(dec->file.buffer + dec->start_offset, dec->file.size - dec->start_offset, mp3dec_load_index, dec);\n            if (ret && MP3D_E_USER != ret)\n                return ret;\n        }\n        for (i = 0; i < dec->index.num_frames; i++)\n            dec->index.frames[i].offset += dec->start_offset;\n        dec->samples = dec->detected_samples;\n    }\n    if (!dec->index.frames)\n        goto seek_zero; /* no frames in file - seek to zero */\n#ifdef MINIMP3_SEEK_IDX_LINEAR_SEARCH\n    for (i = 0; i < dec->index.num_frames; i++)\n    {\n        if (dec->index.frames[i].sample >= position)\n            break;\n    }\n#else\n    i = mp3dec_idx_binary_search(&dec->index, position);\n#endif\n    if (i)\n    {\n        int to_fill_bytes = 511;\n        int skip_frames = MINIMP3_PREDECODE_FRAMES\n#ifdef MINIMP3_SEEK_IDX_LINEAR_SEARCH\n         + ((dec->index.frames[i].sample == position) ? 0 : 1)\n#endif\n        ;\n        i -= MINIMP3_MIN(i, (size_t)skip_frames);\n        if (3 == dec->info.layer)\n        {\n            while (i && to_fill_bytes)\n            {   /* make sure bit-reservoir is filled when we start decoding */\n                bs_t bs[1];\n                L3_gr_info_t gr_info[4];\n                int frame_bytes, frame_size;\n                const uint8_t *hdr;\n                if (dec->io)\n                {\n                    hdr = dec->file.buffer;\n                    if (dec->io->seek(dec->index.frames[i - 1].offset, dec->io->seek_data))\n                        return MP3D_E_IOERROR;\n                    size_t readed = dec->io->read((uint8_t *)hdr, HDR_SIZE, dec->io->read_data);\n                    if (readed != HDR_SIZE)\n                        return MP3D_E_IOERROR;\n                    frame_size = hdr_frame_bytes(hdr, dec->free_format_bytes) + hdr_padding(hdr);\n                    readed = dec->io->read((uint8_t *)hdr + HDR_SIZE, frame_size - HDR_SIZE, dec->io->read_data);\n                    if (readed != (size_t)(frame_size - HDR_SIZE))\n                        return MP3D_E_IOERROR;\n                    bs_init(bs, hdr + HDR_SIZE, frame_size - HDR_SIZE);\n                } else\n                {\n                    hdr = dec->file.buffer + dec->index.frames[i - 1].offset;\n                    frame_size = hdr_frame_bytes(hdr, dec->free_format_bytes) + hdr_padding(hdr);\n                    bs_init(bs, hdr + HDR_SIZE, frame_size - HDR_SIZE);\n                }\n                if (HDR_IS_CRC(hdr))\n                    get_bits(bs, 16);\n                i--;\n                if (L3_read_side_info(bs, gr_info, hdr) < 0)\n                    break; /* frame not decodable, we can start from here */\n                frame_bytes = (bs->limit - bs->pos)/8;\n                to_fill_bytes -= MINIMP3_MIN(to_fill_bytes, frame_bytes);\n            }\n        }\n    }\n    dec->offset = dec->index.frames[i].offset;\n    dec->to_skip = position - dec->index.frames[i].sample;\n    while ((i + 1) < dec->index.num_frames && !dec->index.frames[i].sample && !dec->index.frames[i + 1].sample)\n    {   /* skip not decodable first frames */\n        const uint8_t *hdr;\n        if (dec->io)\n        {\n            hdr = dec->file.buffer;\n            if (dec->io->seek(dec->index.frames[i].offset, dec->io->seek_data))\n                return MP3D_E_IOERROR;\n            size_t readed = dec->io->read((uint8_t *)hdr, HDR_SIZE, dec->io->read_data);\n            if (readed != HDR_SIZE)\n                return MP3D_E_IOERROR;\n        } else\n            hdr = dec->file.buffer + dec->index.frames[i].offset;\n        dec->to_skip += hdr_frame_samples(hdr)*dec->info.channels;\n        i++;\n    }\ndo_exit:\n    if (dec->io)\n    {\n        if (dec->io->seek(dec->offset, dec->io->seek_data))\n            return MP3D_E_IOERROR;\n    }\n    dec->buffer_samples  = 0;\n    dec->buffer_consumed = 0;\n    dec->input_consumed  = 0;\n    dec->input_filled    = 0;\n    dec->last_error      = 0;\n    mp3dec_init(&dec->mp3d);\n    return 0;\n}\n\nsize_t mp3dec_ex_read_frame(mp3dec_ex_t *dec, mp3d_sample_t **buf, mp3dec_frame_info_t *frame_info, size_t max_samples)\n{\n    if (!dec || !buf || !frame_info)\n    {\n        if (dec)\n            dec->last_error = MP3D_E_PARAM;\n        return 0;\n    }\n    if (dec->detected_samples && dec->cur_sample >= dec->detected_samples)\n        return 0; /* at end of stream */\n    if (dec->last_error)\n        return 0; /* error eof state, seek can reset it */\n    *buf = NULL;\n    uint64_t end_offset = dec->end_offset ? dec->end_offset : dec->file.size;\n    int eof = 0;\n    while (dec->buffer_consumed == dec->buffer_samples)\n    {\n        const uint8_t *dec_buf;\n        if (dec->io)\n        {\n            if (!eof && (dec->input_filled - dec->input_consumed) < MINIMP3_BUF_SIZE)\n            {   /* keep minimum 10 consecutive mp3 frames (~16KB) worst case */\n                memmove((uint8_t*)dec->file.buffer, (uint8_t*)dec->file.buffer + dec->input_consumed, dec->input_filled - dec->input_consumed);\n                dec->input_filled -= dec->input_consumed;\n                dec->input_consumed = 0;\n                size_t readed = dec->io->read((uint8_t*)dec->file.buffer + dec->input_filled, dec->file.size - dec->input_filled, dec->io->read_data);\n                if (readed > (dec->file.size - dec->input_filled))\n                {\n                    dec->last_error = MP3D_E_IOERROR;\n                    readed = 0;\n                }\n                if (readed != (dec->file.size - dec->input_filled))\n                    eof = 1;\n                dec->input_filled += readed;\n                if (eof)\n                    mp3dec_skip_id3v1((uint8_t*)dec->file.buffer, &dec->input_filled);\n            }\n            dec_buf = dec->file.buffer + dec->input_consumed;\n            if (!(dec->input_filled - dec->input_consumed))\n                return 0;\n            dec->buffer_samples = mp3dec_decode_frame(&dec->mp3d, dec_buf, dec->input_filled - dec->input_consumed, dec->buffer, frame_info);\n            dec->input_consumed += frame_info->frame_bytes;\n        } else\n        {\n            dec_buf = dec->file.buffer + dec->offset;\n            uint64_t buf_size = end_offset - dec->offset;\n            if (!buf_size)\n                return 0;\n            dec->buffer_samples = mp3dec_decode_frame(&dec->mp3d, dec_buf, MINIMP3_MIN(buf_size, (uint64_t)INT_MAX), dec->buffer, frame_info);\n        }\n        dec->buffer_consumed = 0;\n        if (dec->info.hz != frame_info->hz || dec->info.layer != frame_info->layer)\n        {\nreturn_e_decode:\n            dec->last_error = MP3D_E_DECODE;\n            return 0;\n        }\n        if (dec->buffer_samples)\n        {\n            dec->buffer_samples *= frame_info->channels;\n            if (dec->to_skip)\n            {\n                size_t skip = MINIMP3_MIN(dec->buffer_samples, dec->to_skip);\n                dec->buffer_consumed += skip;\n                dec->to_skip -= skip;\n            }\n            if (\n#ifdef MINIMP3_ALLOW_MONO_STEREO_TRANSITION\n                !(dec->flags & MP3D_ALLOW_MONO_STEREO_TRANSITION) &&\n#endif\n                dec->buffer_consumed != dec->buffer_samples && dec->info.channels != frame_info->channels)\n            {\n                goto return_e_decode;\n            }\n        } else if (dec->to_skip)\n        {   /* In mp3 decoding not always can start decode from any frame because of bit reservoir,\n               count skip samples for such frames */\n            int frame_samples = hdr_frame_samples(dec_buf)*frame_info->channels;\n            dec->to_skip -= MINIMP3_MIN(frame_samples, dec->to_skip);\n        }\n        dec->offset += frame_info->frame_bytes;\n    }\n    size_t out_samples = MINIMP3_MIN((size_t)(dec->buffer_samples - dec->buffer_consumed), max_samples);\n    if (dec->detected_samples)\n    {   /* count decoded samples to properly cut padding */\n        if (dec->cur_sample + out_samples >= dec->detected_samples)\n            out_samples = dec->detected_samples - dec->cur_sample;\n    }\n    dec->cur_sample += out_samples;\n    *buf = dec->buffer + dec->buffer_consumed;\n    dec->buffer_consumed += out_samples;\n    return out_samples;\n}\n\nsize_t mp3dec_ex_read(mp3dec_ex_t *dec, mp3d_sample_t *buf, size_t samples)\n{\n    if (!dec || !buf)\n    {\n        if (dec)\n            dec->last_error = MP3D_E_PARAM;\n        return 0;\n    }\n    mp3dec_frame_info_t frame_info;\n    memset(&frame_info, 0, sizeof(frame_info));\n    size_t samples_requested = samples;\n    while (samples)\n    {\n        mp3d_sample_t *buf_frame = NULL;\n        size_t read_samples = mp3dec_ex_read_frame(dec, &buf_frame, &frame_info, samples);\n        if (!read_samples)\n        {\n            break;\n        }\n        memcpy(buf, buf_frame, read_samples * sizeof(mp3d_sample_t));\n        buf += read_samples;\n        samples -= read_samples;\n    }\n    return samples_requested - samples;\n}\n\nint mp3dec_ex_open_cb(mp3dec_ex_t *dec, mp3dec_io_t *io, int flags)\n{\n    if (!dec || !io || (flags & (~MP3D_FLAGS_MASK)))\n        return MP3D_E_PARAM;\n    memset(dec, 0, sizeof(*dec));\n#ifdef MINIMP3_HAVE_RING\n    int ret;\n    if (ret = mp3dec_open_ring(&dec->file, MINIMP3_IO_SIZE))\n        return ret;\n#else\n    dec->file.size = MINIMP3_IO_SIZE;\n    dec->file.buffer = (const uint8_t*)malloc(dec->file.size);\n    if (!dec->file.buffer)\n        return MP3D_E_MEMORY;\n#endif\n    dec->flags = flags;\n    dec->io = io;\n    mp3dec_init(&dec->mp3d);\n    if (io->seek(0, io->seek_data))\n        return MP3D_E_IOERROR;\n    int ret = mp3dec_iterate_cb(io, (uint8_t *)dec->file.buffer, dec->file.size, mp3dec_load_index, dec);\n    if (ret && MP3D_E_USER != ret)\n        return ret;\n    if (dec->io->seek(dec->start_offset, dec->io->seek_data))\n        return MP3D_E_IOERROR;\n    mp3dec_init(&dec->mp3d);\n    dec->buffer_samples = 0;\n    dec->indexes_built = !(dec->vbr_tag_found || (flags & MP3D_DO_NOT_SCAN));\n    dec->flags &= (~MP3D_DO_NOT_SCAN);\n    return 0;\n}\n\n\n#ifndef MINIMP3_NO_STDIO\n\n#if defined(__linux__) || defined(__FreeBSD__)\n#include <errno.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#if !defined(_GNU_SOURCE)\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#endif\n#if !defined(MAP_POPULATE) && defined(__linux__)\n#define MAP_POPULATE 0x08000\n#elif !defined(MAP_POPULATE)\n#define MAP_POPULATE 0\n#endif\n\nstatic void mp3dec_close_file(mp3dec_map_info_t *map_info)\n{\n    if (map_info->buffer && MAP_FAILED != map_info->buffer)\n        munmap((void *)map_info->buffer, map_info->size);\n    map_info->buffer = 0;\n    map_info->size   = 0;\n}\n\nstatic int mp3dec_open_file(const char *file_name, mp3dec_map_info_t *map_info)\n{\n    if (!file_name)\n        return MP3D_E_PARAM;\n    int file;\n    struct stat st;\n    memset(map_info, 0, sizeof(*map_info));\nretry_open:\n    file = open(file_name, O_RDONLY);\n    if (file < 0 && (errno == EAGAIN || errno == EINTR))\n        goto retry_open;\n    if (file < 0 || fstat(file, &st) < 0)\n    {\n        close(file);\n        return MP3D_E_IOERROR;\n    }\n\n    map_info->size = st.st_size;\nretry_mmap:\n    map_info->buffer = (const uint8_t *)mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE | MAP_POPULATE, file, 0);\n    if (MAP_FAILED == map_info->buffer && (errno == EAGAIN || errno == EINTR))\n        goto retry_mmap;\n    close(file);\n    if (MAP_FAILED == map_info->buffer)\n        return MP3D_E_IOERROR;\n    return 0;\n}\n\n#if MINIMP3_ENABLE_RING && defined(__linux__) && defined(_GNU_SOURCE)\n#define MINIMP3_HAVE_RING\nstatic void mp3dec_close_ring(mp3dec_map_info_t *map_info)\n{\n#if defined(__linux__) && defined(_GNU_SOURCE)\n    if (map_info->buffer && MAP_FAILED != map_info->buffer)\n        munmap((void *)map_info->buffer, map_info->size*2);\n#else\n    if (map_info->buffer)\n    {\n        shmdt(map_info->buffer);\n        shmdt(map_info->buffer + map_info->size);\n    }\n#endif\n    map_info->buffer = 0;\n    map_info->size   = 0;\n}\n\nstatic int mp3dec_open_ring(mp3dec_map_info_t *map_info, size_t size)\n{\n    int memfd, page_size;\n#if defined(__linux__) && defined(_GNU_SOURCE)\n    void *buffer;\n    int res;\n#endif\n    memset(map_info, 0, sizeof(*map_info));\n\n#ifdef _SC_PAGESIZE\n    page_size = sysconf(_SC_PAGESIZE);\n#else\n    page_size = getpagesize();\n#endif\n    map_info->size = (size + page_size - 1)/page_size*page_size;\n\n#if defined(__linux__) && defined(_GNU_SOURCE)\n    memfd = memfd_create(\"mp3_ring\", 0);\n    if (memfd < 0)\n        return MP3D_E_MEMORY;\n\nretry_ftruncate:\n    res = ftruncate(memfd, map_info->size);\n    if (res && (errno == EAGAIN || errno == EINTR))\n        goto retry_ftruncate;\n    if (res)\n        goto error;\n\nretry_mmap:\n    map_info->buffer = (const uint8_t *)mmap(NULL, map_info->size*2, PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    if (MAP_FAILED == map_info->buffer && (errno == EAGAIN || errno == EINTR))\n        goto retry_mmap;\n    if (MAP_FAILED == map_info->buffer || !map_info->buffer)\n        goto error;\nretry_mmap2:\n    buffer = mmap((void *)map_info->buffer, map_info->size, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, memfd, 0);\n    if (MAP_FAILED == map_info->buffer && (errno == EAGAIN || errno == EINTR))\n        goto retry_mmap2;\n    if (MAP_FAILED == map_info->buffer || buffer != (void *)map_info->buffer)\n        goto error;\nretry_mmap3:\n    buffer = mmap((void *)map_info->buffer + map_info->size, map_info->size, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, memfd, 0);\n    if (MAP_FAILED == map_info->buffer && (errno == EAGAIN || errno == EINTR))\n        goto retry_mmap3;\n    if (MAP_FAILED == map_info->buffer || buffer != (void *)(map_info->buffer + map_info->size))\n        goto error;\n\n    close(memfd);\n    return 0;\nerror:\n    close(memfd);\n    mp3dec_close_ring(map_info);\n    return MP3D_E_MEMORY;\n#else\n    memfd = shmget(IPC_PRIVATE, map_info->size, IPC_CREAT | 0700);\n    if (memfd < 0)\n        return MP3D_E_MEMORY;\nretry_mmap:\n    map_info->buffer = (const uint8_t *)mmap(NULL, map_info->size*2, PROT_NONE, MAP_PRIVATE, -1, 0);\n    if (MAP_FAILED == map_info->buffer && (errno == EAGAIN || errno == EINTR))\n        goto retry_mmap;\n    if (MAP_FAILED == map_info->buffer)\n        goto error;\n    if (map_info->buffer != shmat(memfd, map_info->buffer, 0))\n        goto error;\n    if ((map_info->buffer + map_info->size) != shmat(memfd, map_info->buffer + map_info->size, 0))\n        goto error;\n    if (shmctl(memfd, IPC_RMID, NULL) < 0)\n        return MP3D_E_MEMORY;\n    return 0;\nerror:\n    shmctl(memfd, IPC_RMID, NULL);\n    mp3dec_close_ring(map_info);\n    return MP3D_E_MEMORY;\n#endif\n}\n#endif /*MINIMP3_ENABLE_RING*/\n#elif defined(_WIN32)\n#include <windows.h>\n\nstatic void mp3dec_close_file(mp3dec_map_info_t *map_info)\n{\n    if (map_info->buffer)\n        UnmapViewOfFile(map_info->buffer);\n    map_info->buffer = 0;\n    map_info->size   = 0;\n}\n\nstatic int mp3dec_open_file_h(HANDLE file, mp3dec_map_info_t *map_info)\n{\n    memset(map_info, 0, sizeof(*map_info));\n\n    HANDLE mapping = NULL;\n    LARGE_INTEGER s;\n    s.LowPart = GetFileSize(file, (DWORD*)&s.HighPart);\n    if (s.LowPart == INVALID_FILE_SIZE && GetLastError() != NO_ERROR)\n        goto error;\n    map_info->size = s.QuadPart;\n\n    mapping = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL);\n    if (!mapping)\n        goto error;\n    map_info->buffer = (const uint8_t*)MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, s.QuadPart);\n    CloseHandle(mapping);\n    if (!map_info->buffer)\n        goto error;\n\n    CloseHandle(file);\n    return 0;\nerror:\n    mp3dec_close_file(map_info);\n    CloseHandle(file);\n    return MP3D_E_IOERROR;\n}\n\nstatic int mp3dec_open_file(const char *file_name, mp3dec_map_info_t *map_info)\n{\n    if (!file_name)\n        return MP3D_E_PARAM;\n    HANDLE file = CreateFileA(file_name, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);\n    if (INVALID_HANDLE_VALUE == file)\n        return MP3D_E_IOERROR;\n    return mp3dec_open_file_h(file, map_info);\n}\n\nstatic int mp3dec_open_file_w(const wchar_t *file_name, mp3dec_map_info_t *map_info)\n{\n    if (!file_name)\n        return MP3D_E_PARAM;\n    HANDLE file = CreateFileW(file_name, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);\n    if (INVALID_HANDLE_VALUE == file)\n        return MP3D_E_IOERROR;\n    return mp3dec_open_file_h(file, map_info);\n}\n#else\n#include <stdio.h>\n\nstatic void mp3dec_close_file(mp3dec_map_info_t *map_info)\n{\n    if (map_info->buffer)\n        free((void *)map_info->buffer);\n    map_info->buffer = 0;\n    map_info->size = 0;\n}\n\nstatic int mp3dec_open_file(const char *file_name, mp3dec_map_info_t *map_info)\n{\n    if (!file_name)\n        return MP3D_E_PARAM;\n    memset(map_info, 0, sizeof(*map_info));\n    FILE *file = fopen(file_name, \"rb\");\n    if (!file)\n        return MP3D_E_IOERROR;\n    int res = MP3D_E_IOERROR;\n    long size = -1;\n    if (fseek(file, 0, SEEK_END))\n        goto error;\n    size = ftell(file);\n    if (size < 0)\n        goto error;\n    map_info->size = (size_t)size;\n    if (fseek(file, 0, SEEK_SET))\n        goto error;\n    map_info->buffer = (uint8_t *)malloc(map_info->size);\n    if (!map_info->buffer)\n    {\n        res = MP3D_E_MEMORY;\n        goto error;\n    }\n    if (fread((void *)map_info->buffer, 1, map_info->size, file) != map_info->size)\n        goto error;\n    fclose(file);\n    return 0;\nerror:\n    mp3dec_close_file(map_info);\n    fclose(file);\n    return res;\n}\n#endif\n\nstatic int mp3dec_detect_mapinfo(mp3dec_map_info_t *map_info)\n{\n    int ret = mp3dec_detect_buf(map_info->buffer, map_info->size);\n    mp3dec_close_file(map_info);\n    return ret;\n}\n\nstatic int mp3dec_load_mapinfo(mp3dec_t *dec, mp3dec_map_info_t *map_info, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data)\n{\n    int ret = mp3dec_load_buf(dec, map_info->buffer, map_info->size, info, progress_cb, user_data);\n    mp3dec_close_file(map_info);\n    return ret;\n}\n\nstatic int mp3dec_iterate_mapinfo(mp3dec_map_info_t *map_info, MP3D_ITERATE_CB callback, void *user_data)\n{\n    int ret = mp3dec_iterate_buf(map_info->buffer, map_info->size, callback, user_data);\n    mp3dec_close_file(map_info);\n    return ret;\n}\n\nstatic int mp3dec_ex_open_mapinfo(mp3dec_ex_t *dec, int flags)\n{\n    int ret = mp3dec_ex_open_buf(dec, dec->file.buffer, dec->file.size, flags);\n    dec->is_file = 1;\n    if (ret)\n        mp3dec_ex_close(dec);\n    return ret;\n}\n\nint mp3dec_detect(const char *file_name)\n{\n    int ret;\n    mp3dec_map_info_t map_info;\n    if ((ret = mp3dec_open_file(file_name, &map_info)))\n        return ret;\n    return mp3dec_detect_mapinfo(&map_info);\n}\n\nint mp3dec_load(mp3dec_t *dec, const char *file_name, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data)\n{\n    int ret;\n    mp3dec_map_info_t map_info;\n    if ((ret = mp3dec_open_file(file_name, &map_info)))\n        return ret;\n    return mp3dec_load_mapinfo(dec, &map_info, info, progress_cb, user_data);\n}\n\nint mp3dec_iterate(const char *file_name, MP3D_ITERATE_CB callback, void *user_data)\n{\n    int ret;\n    mp3dec_map_info_t map_info;\n    if ((ret = mp3dec_open_file(file_name, &map_info)))\n        return ret;\n    return mp3dec_iterate_mapinfo(&map_info, callback, user_data);\n}\n\nint mp3dec_ex_open(mp3dec_ex_t *dec, const char *file_name, int flags)\n{\n    int ret;\n    if (!dec)\n        return MP3D_E_PARAM;\n    if ((ret = mp3dec_open_file(file_name, &dec->file)))\n        return ret;\n    return mp3dec_ex_open_mapinfo(dec, flags);\n}\n\nvoid mp3dec_ex_close(mp3dec_ex_t *dec)\n{\n#ifdef MINIMP3_HAVE_RING\n    if (dec->io)\n        mp3dec_close_ring(&dec->file);\n#else\n    if (dec->io && dec->file.buffer)\n        free((void*)dec->file.buffer);\n#endif\n    if (dec->is_file)\n        mp3dec_close_file(&dec->file);\n    if (dec->index.frames)\n        free(dec->index.frames);\n    memset(dec, 0, sizeof(*dec));\n}\n\n#ifdef _WIN32\nint mp3dec_detect_w(const wchar_t *file_name)\n{\n    int ret;\n    mp3dec_map_info_t map_info;\n    if ((ret = mp3dec_open_file_w(file_name, &map_info)))\n        return ret;\n    return mp3dec_detect_mapinfo(&map_info);\n}\n\nint mp3dec_load_w(mp3dec_t *dec, const wchar_t *file_name, mp3dec_file_info_t *info, MP3D_PROGRESS_CB progress_cb, void *user_data)\n{\n    int ret;\n    mp3dec_map_info_t map_info;\n    if ((ret = mp3dec_open_file_w(file_name, &map_info)))\n        return ret;\n    return mp3dec_load_mapinfo(dec, &map_info, info, progress_cb, user_data);\n}\n\nint mp3dec_iterate_w(const wchar_t *file_name, MP3D_ITERATE_CB callback, void *user_data)\n{\n    int ret;\n    mp3dec_map_info_t map_info;\n    if ((ret = mp3dec_open_file_w(file_name, &map_info)))\n        return ret;\n    return mp3dec_iterate_mapinfo(&map_info, callback, user_data);\n}\n\nint mp3dec_ex_open_w(mp3dec_ex_t *dec, const wchar_t *file_name, int flags)\n{\n    int ret;\n    if ((ret = mp3dec_open_file_w(file_name, &dec->file)))\n        return ret;\n    return mp3dec_ex_open_mapinfo(dec, flags);\n}\n#endif\n#else /* MINIMP3_NO_STDIO */\nvoid mp3dec_ex_close(mp3dec_ex_t *dec)\n{\n#ifdef MINIMP3_HAVE_RING\n    if (dec->io)\n        mp3dec_close_ring(&dec->file);\n#else\n    if (dec->io && dec->file.buffer)\n        free((void*)dec->file.buffer);\n#endif\n    if (dec->index.frames)\n        free(dec->index.frames);\n    memset(dec, 0, sizeof(*dec));\n}\n#endif\n\n#endif /* MINIMP3_IMPLEMENTATION && !_MINIMP3_EX_IMPLEMENTATION_GUARD */\n"
        },
        {
          "name": "minimp3_test.c",
          "type": "blob",
          "size": 26.46875,
          "content": "#ifdef MINIMP3_TEST\nstatic int malloc_num = 0, fail_malloc_num = -1;\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\nstatic void *local_malloc(size_t size)\n{\n    /*printf(\"%d malloc(%d)\\n\", malloc_num, (int)size);*/\n    if (fail_malloc_num == malloc_num)\n        return 0;\n    malloc_num++;\n    return malloc(size);\n}\n#define malloc local_malloc\nvoid *local_realloc(void *ptr, size_t new_size)\n{\n    /*printf(\"%d realloc(%d)\\n\", malloc_num, (int)new_size);*/\n    if (fail_malloc_num == malloc_num)\n        return 0;\n    malloc_num++;\n    return realloc(ptr, new_size);\n}\n#define realloc local_realloc\nvoid *local_mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)\n{\n    /*printf(\"%d mmap(%d)\\n\", malloc_num, (int)length);*/\n    if (fail_malloc_num == malloc_num)\n        return MAP_FAILED;\n    malloc_num++;\n    return mmap(addr, length, prot, flags, fd, offset);\n}\n#define mmap local_mmap\n#endif\n\n/*#define MINIMP3_ONLY_MP3*/\n/*#define MINIMP3_ONLY_SIMD*/\n/*#define MINIMP3_NONSTANDARD_BUT_LOGICAL*/\n#define MINIMP3_IMPLEMENTATION\n#define MINIMP3_ALLOW_MONO_STEREO_TRANSITION\n#include \"minimp3_ex.h\"\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#if defined(_MSC_VER)\n    #define strcasecmp(str1, str2) _strnicmp(str1, str2, strlen(str2))\n#else\n    #include <strings.h>\n#endif\n\n#define MODE_LOAD     0\n#define MODE_LOAD_BUF 1\n#define MODE_LOAD_CB  2\n#define MODE_ITERATE  3\n#define MODE_ITERATE_BUF 4\n#define MODE_ITERATE_CB  5\n#define MODE_STREAM     6\n#define MODE_STREAM_BUF 7\n#define MODE_STREAM_CB  8\n#define MODE_DETECT     9\n#define MODE_DETECT_BUF 10\n#define MODE_DETECT_CB  11\n\nstatic int16_t read16le(const void *p)\n{\n    const uint8_t *src = (const uint8_t *)p;\n    return ((src[0]) << 0) | ((src[1]) << 8);\n}\n\n#ifndef MINIMP3_NO_WAV\nstatic char *wav_header(int hz, int ch, int bips, int data_bytes)\n{\n    static char hdr[44] = \"RIFFsizeWAVEfmt \\x10\\0\\0\\0\\1\\0ch_hz_abpsbabsdatasize\";\n    unsigned long nAvgBytesPerSec = bips*ch*hz >> 3;\n    unsigned int nBlockAlign      = bips*ch >> 3;\n\n    *(int32_t *)(void*)(hdr + 0x04) = 44 + data_bytes - 8;   /* File size - 8 */\n    *(int16_t *)(void*)(hdr + 0x14) = 1;                     /* Integer PCM format */\n    *(int16_t *)(void*)(hdr + 0x16) = ch;\n    *(int32_t *)(void*)(hdr + 0x18) = hz;\n    *(int32_t *)(void*)(hdr + 0x1C) = nAvgBytesPerSec;\n    *(int16_t *)(void*)(hdr + 0x20) = nBlockAlign;\n    *(int16_t *)(void*)(hdr + 0x22) = bips;\n    *(int32_t *)(void*)(hdr + 0x28) = data_bytes;\n    return hdr;\n}\n#endif\n\nstatic unsigned char *preload(FILE *file, int *data_size)\n{\n    unsigned char *data;\n    *data_size = 0;\n    if (!file)\n        return 0;\n    if (fseek(file, 0, SEEK_END))\n        return 0;\n    *data_size = (int)ftell(file);\n    if (*data_size < 0)\n        return 0;\n    if (fseek(file, 0, SEEK_SET))\n        return 0;\n    data = (unsigned char*)malloc(*data_size);\n#define FAIL_MEM(data) \\\n    if (!(data)) \\\n    { \\\n        printf(\"error: not enough memory\\n\"); \\\n        exit(1); \\\n    }\n    FAIL_MEM(data);\n    if ((int)fread(data, 1, *data_size, file) != *data_size)\n        exit(1);\n    return data;\n}\n\nstatic int io_num, fail_io_num = -1;\nstatic int wave_out = 0, mode = 0, position = 0, portion = 0, seek_to_byte = 0;\n\nstatic size_t read_cb(void *buf, size_t size, void *user_data)\n{\n    /*printf(\"%d read_cb(%d)\\n\", io_num, (int)size);*/\n    if (fail_io_num == io_num++)\n        return -1;\n    return fread(buf, 1, size, (FILE*)user_data);\n}\n\nstatic int seek_cb(uint64_t position, void *user_data)\n{\n    /*printf(\"%d seek_cb(%d)\\n\", io_num, (int)position);*/\n    if (fail_io_num == io_num++)\n        return -1;\n    return fseek((FILE*)user_data, position, SEEK_SET);\n}\n\ntypedef struct\n{\n    mp3dec_t *mp3d;\n    mp3dec_file_info_t *info;\n    size_t allocated;\n} frames_iterate_data;\n\nstatic int frames_iterate_cb(void *user_data, const uint8_t *frame, int frame_size, int free_format_bytes, size_t buf_size, uint64_t offset, mp3dec_frame_info_t *info)\n{\n    (void)buf_size;\n    (void)offset;\n    (void)free_format_bytes;\n    frames_iterate_data *d = user_data;\n    d->info->channels = info->channels;\n    d->info->hz       = info->hz;\n    d->info->layer    = info->layer;\n    /*printf(\"%d %d %d\\n\", frame_size, (int)offset, info->channels);*/\n    if ((d->allocated - d->info->samples*sizeof(mp3d_sample_t)) < MINIMP3_MAX_SAMPLES_PER_FRAME*sizeof(mp3d_sample_t))\n    {\n        if (!d->allocated)\n            d->allocated = 1024*1024;\n        else\n            d->allocated *= 2;\n        mp3d_sample_t *alloc_buf = realloc(d->info->buffer, d->allocated);\n        if (!alloc_buf)\n            return MP3D_E_MEMORY;\n        d->info->buffer = alloc_buf;\n    }\n    int samples = mp3dec_decode_frame(d->mp3d, frame, frame_size, d->info->buffer + d->info->samples, info);\n    if (samples)\n    {\n        d->info->samples += samples*info->channels;\n    }\n    return 0;\n}\n\nstatic int progress_cb(void *user_data, size_t file_size, uint64_t offset, mp3dec_frame_info_t *info)\n{\n    (void)user_data;\n    (void)file_size;\n    (void)offset;\n    (void)info;\n    return MP3D_E_USER;\n}\n\nstatic void decode_file(const char *input_file_name, const unsigned char *buf_ref, int ref_size, FILE *file_out)\n{\n    mp3dec_t mp3d;\n    int i, res = -1, data_bytes, total_samples = 0, maxdiff = 0;\n    int no_std_vec = strstr(input_file_name, \"nonstandard\") || strstr(input_file_name, \"ILL\");\n    uint8_t *buf = 0;\n    double MSE = 0.0, psnr;\n\n    mp3dec_io_t io;\n    mp3dec_file_info_t info;\n    memset(&info, 0, sizeof(info));\n    io.read = read_cb;\n    io.seek = seek_cb;\n    if (MODE_LOAD == mode)\n    {\n        res = mp3dec_load(&mp3d, input_file_name, &info, 0, 0);\n    } else if (MODE_LOAD_BUF == mode)\n    {\n        int size = 0;\n        FILE *file = fopen(input_file_name, \"rb\");\n        uint8_t *buf = preload(file, &size);\n        fclose(file);\n        res = buf ? mp3dec_load_buf(&mp3d, buf, size, &info, 0, 0) : MP3D_E_IOERROR;\n        free(buf);\n    } else if (MODE_LOAD_CB == mode)\n    {\n        uint8_t *io_buf = malloc(MINIMP3_IO_SIZE);\n        FAIL_MEM(io_buf);\n        FILE *file = fopen(input_file_name, \"rb\");\n        io.read_data = io.seek_data = file;\n        res = file ? mp3dec_load_cb(&mp3d, &io, io_buf, MINIMP3_IO_SIZE, &info, 0, 0) : MP3D_E_IOERROR;\n        fclose((FILE*)io.read_data);\n        free(io_buf);\n    } else if (MODE_ITERATE == mode)\n    {\n        frames_iterate_data d = { &mp3d, &info, 0 };\n        mp3dec_init(&mp3d);\n        res = mp3dec_iterate(input_file_name, frames_iterate_cb, &d);\n    } else if (MODE_ITERATE_BUF == mode)\n    {\n        int size = 0;\n        FILE *file = fopen(input_file_name, \"rb\");\n        uint8_t *buf = preload(file, &size);\n        fclose(file);\n        frames_iterate_data d = { &mp3d, &info, 0 };\n        mp3dec_init(&mp3d);\n        res = buf ? mp3dec_iterate_buf(buf, size, frames_iterate_cb, &d) : MP3D_E_IOERROR;\n        free(buf);\n    } else if (MODE_ITERATE_CB == mode)\n    {\n        uint8_t *io_buf = malloc(MINIMP3_IO_SIZE);\n        FAIL_MEM(io_buf);\n        FILE *file = fopen(input_file_name, \"rb\");\n        io.read_data = io.seek_data = file;\n        frames_iterate_data d = { &mp3d, &info, 0 };\n        mp3dec_init(&mp3d);\n        res = file ? mp3dec_iterate_cb(&io, io_buf, MINIMP3_IO_SIZE, frames_iterate_cb, &d) : MP3D_E_IOERROR;\n        fclose((FILE*)io.read_data);\n        free(io_buf);\n    } else if (MODE_STREAM == mode || MODE_STREAM_BUF == mode || MODE_STREAM_CB == mode)\n    {\n        mp3dec_ex_t dec;\n        size_t readed;\n        if (MODE_STREAM == mode)\n        {\n            res = mp3dec_ex_open(&dec, input_file_name, (seek_to_byte ? MP3D_SEEK_TO_BYTE : MP3D_SEEK_TO_SAMPLE) | MP3D_ALLOW_MONO_STEREO_TRANSITION);\n        } else if (MODE_STREAM_BUF == mode)\n        {\n            int size = 0;\n            FILE *file = fopen(input_file_name, \"rb\");\n            buf = preload(file, &size);\n            fclose(file);\n            res = buf ? mp3dec_ex_open_buf(&dec, buf, size, (seek_to_byte ? MP3D_SEEK_TO_BYTE : MP3D_SEEK_TO_SAMPLE) | MP3D_ALLOW_MONO_STEREO_TRANSITION) : MP3D_E_IOERROR;\n        } else if (MODE_STREAM_CB == mode)\n        {\n            FILE *file = fopen(input_file_name, \"rb\");\n            io.read_data = io.seek_data = file;\n            res = file ? mp3dec_ex_open_cb(&dec, &io, (seek_to_byte ? MP3D_SEEK_TO_BYTE : MP3D_SEEK_TO_SAMPLE) | MP3D_ALLOW_MONO_STEREO_TRANSITION) : MP3D_E_IOERROR;\n        }\n        if (res)\n        {\n            printf(\"error: mp3dec_ex_open()=%d failed\\n\", res);\n            exit(1);\n        }\n        info.samples = dec.samples;\n        info.buffer  = malloc(dec.samples*sizeof(mp3d_sample_t));\n        FAIL_MEM(info.buffer);\n        info.hz      = dec.info.hz;\n        info.layer   = dec.info.layer;\n        info.channels = dec.info.channels;\n        if (position < 0 && -2 != position)\n        {\n#ifdef _WIN32\n            LARGE_INTEGER t;\n            QueryPerformanceCounter(&t);\n            srand(t.QuadPart);\n#else\n            srand(time(0));\n#endif\n            position = info.samples > 500 ? (uint64_t)(info.samples - 500)*rand()/RAND_MAX : 0;\n            printf(\"info: seek to %d/%d\\n\", position, (int)info.samples);\n        }\n        if (position)\n        {\n            if (-2 == position)\n                position = 0;\n            if (!seek_to_byte)\n            {\n                info.samples -= MINIMP3_MIN(info.samples, (size_t)position);\n                int skip_ref = MINIMP3_MIN((size_t)ref_size, position*sizeof(int16_t));\n                buf_ref  += skip_ref;\n                ref_size -= skip_ref;\n            }\n            res = mp3dec_ex_seek(&dec, position);\n            if (res)\n            {\n                printf(\"error: mp3dec_ex_seek()=%d failed\\n\", res);\n                exit(1);\n            }\n        }\n        if (portion < 0)\n        {\n            portion = (uint64_t)(info.samples + 150)*rand()/RAND_MAX;\n            printf(\"info: read by %d samples\\n\", portion);\n        }\n        if (0 == portion)\n            portion = info.samples;\n        int samples = info.samples, samples_readed = 0;\n        while (samples)\n        {\n            int to_read = MINIMP3_MIN(samples, portion);\n            readed = mp3dec_ex_read(&dec, info.buffer + samples_readed, portion);\n            samples -= readed;\n            samples_readed += readed;\n            if (readed != (size_t)to_read)\n            {\n                if (seek_to_byte && readed < (size_t)to_read)\n                    break;\n                printf(\"error: mp3dec_ex_read() readed less than expected, last_error=%d\\n\", dec.last_error);\n                exit(1);\n            }\n        }\n        readed = mp3dec_ex_read(&dec, info.buffer, 1);\n        if (readed)\n        {\n            printf(\"error: mp3dec_ex_read() readed more than expected, last_error=%d\\n\", dec.last_error);\n            exit(1);\n        }\n        if (seek_to_byte)\n        {\n            info.samples = samples_readed;\n        }\n        mp3dec_ex_close(&dec);\n        if (MODE_STREAM_BUF == mode && buf)\n            free(buf);\n        if (MODE_STREAM_CB == mode)\n            fclose((FILE*)io.read_data);\n    } else if (MODE_DETECT == mode || MODE_DETECT_BUF == mode || MODE_DETECT_CB == mode)\n    {\n        if (MODE_DETECT == mode)\n        {\n            res = mp3dec_detect(input_file_name);\n        } else if (MODE_DETECT_BUF == mode)\n        {\n            int size = 0;\n            FILE *file = fopen(input_file_name, \"rb\");\n            buf = preload(file, &size);\n            fclose(file);\n            res = buf ? mp3dec_detect_buf(buf, size) : MP3D_E_IOERROR;\n        } else if (MODE_DETECT_CB == mode)\n        {\n            uint8_t *io_buf = malloc(MINIMP3_BUF_SIZE);\n            FAIL_MEM(io_buf);\n            FILE *file = fopen(input_file_name, \"rb\");\n            io.read_data = io.seek_data = file;\n            res = file ? mp3dec_detect_cb(&io, io_buf, MINIMP3_BUF_SIZE) : MP3D_E_IOERROR;\n            free(io_buf);\n        }\n        if (MP3D_E_USER == res)\n        {\n            printf(\"info: not an mp3/mpa file\\n\");\n            exit(1);\n        } else if (res)\n        {\n            printf(\"error: mp3dec_detect*()=%d failed\\n\", res);\n            exit(1);\n        }\n        printf(\"info: mp3/mpa file detected\\n\");\n        exit(0);\n    } else\n    {\n        printf(\"error: unknown mode\\n\");\n        exit(1);\n    }\n    if (res && MP3D_E_DECODE != res)\n    {\n        printf(\"error: read function failed, code=%d\\n\", res);\n        exit(1);\n    }\n#ifdef MINIMP3_FLOAT_OUTPUT\n    int16_t *buffer = malloc(info.samples*sizeof(int16_t));\n    FAIL_MEM(buffer);\n    mp3dec_f32_to_s16(info.buffer, buffer, info.samples);\n    free(info.buffer);\n#else\n    int16_t *buffer = info.buffer;\n#endif\n#ifndef MINIMP3_NO_WAV\n    if (wave_out && file_out)\n        fwrite(wav_header(0, 0, 0, 0), 1, 44, file_out);\n#endif\n    total_samples += info.samples;\n    if (buf_ref)\n    {\n        size_t ref_samples = ref_size/2;\n        int len_match = ref_samples == info.samples;\n        int relaxed_len_match = len_match || (ref_samples + 1152) == info.samples || (ref_samples + 2304) == info.samples;\n        int seek_len_match = (ref_samples <= info.samples) || (ref_samples + 2304) >= info.samples;\n        if ((((!relaxed_len_match && MODE_STREAM != mode && MODE_STREAM_BUF != mode && MODE_STREAM_CB != mode) || !seek_len_match) && (3 == info.layer || 0 == info.layer) && !no_std_vec) || (no_std_vec && !len_match))\n        {   /* some standard vectors are for some reason a little shorter */\n            printf(\"error: reference and produced number of samples do not match (%d/%d)\\n\", (int)ref_samples, (int)info.samples);\n            exit(1);\n        }\n        int max_samples = MINIMP3_MIN(ref_samples, info.samples);\n        for (i = 0; i < max_samples; i++)\n        {\n            int MSEtemp = abs((int)buffer[i] - (int)(int16_t)read16le(&buf_ref[i*sizeof(int16_t)]));\n            if (MSEtemp > maxdiff)\n                maxdiff = MSEtemp;\n            MSE += (float)MSEtemp*(float)MSEtemp;\n        }\n    }\n    if (file_out)\n        fwrite(buffer, info.samples, sizeof(int16_t), file_out);\n    if (buffer)\n        free(buffer);\n\n#ifndef LIBFUZZER\n    MSE /= total_samples ? total_samples : 1;\n    if (0 == MSE)\n        psnr = 99.0;\n    else\n        psnr = 10.0*log10(((double)0x7fff*0x7fff)/MSE);\n    printf(\"rate=%d samples=%d max_diff=%d PSNR=%f\\n\", info.hz, total_samples, maxdiff, psnr);\n    if (psnr < 96)\n    {\n        printf(\"error: PSNR compliance failed\\n\");\n        exit(1);\n    }\n#endif\n#ifndef MINIMP3_NO_WAV\n    if (wave_out && file_out)\n    {\n        data_bytes = ftell(file_out) - 44;\n        rewind(file_out);\n        fwrite(wav_header(info.hz, info.channels, 16, data_bytes), 1, 44, file_out);\n    }\n#endif\n}\n\nstatic int self_test(const char *input_file_name)\n{\n    int ret, size = 0;\n    mp3dec_t mp3d;\n    mp3dec_ex_t dec;\n    mp3dec_frame_info_t frame_info;\n    mp3dec_file_info_t finfo;\n    mp3dec_io_t io;\n    FILE *file = fopen(input_file_name, \"rb\");\n    uint8_t *buf = preload(file, &size);\n    fclose(file);\n    int samples = mp3dec_decode_frame(&mp3d, buf, size, 0, &frame_info);\n    free(buf);\n#define ASSERT(c) if (!(c)) { printf(\"failed, line=%d\\n\", __LINE__); exit(1); }\n    ASSERT(1152 == samples);\n\n    ret = mp3dec_detect_buf(0, size);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_detect_buf(buf, (size_t)-1);\n    ASSERT(MP3D_E_PARAM == ret);\n\n    ret = mp3dec_load_buf(0, buf, size, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_buf(&mp3d, 0, size, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_buf(&mp3d, buf, (size_t)-1, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_buf(&mp3d, buf, size, 0, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n\n    memset(&finfo, 0xff, sizeof(finfo));\n    ret = mp3dec_load_buf(&mp3d, buf, 0, &finfo, 0, 0);\n    ASSERT(0 == ret && 0 == finfo.samples);\n\n    ret = mp3dec_detect_cb(&io, 0, size);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_detect_cb(&io, buf, (size_t)-1);\n    ASSERT(MP3D_E_PARAM == ret);\n\n    ret = mp3dec_load_cb(0, &io, buf, size, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_cb(&mp3d, &io, 0, size, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_cb(&mp3d, &io, buf, (size_t)-1, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_cb(&mp3d, &io, buf, size, 0, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load_cb(&mp3d, &io, buf, 0, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n\n    ret = mp3dec_iterate_buf(0, size, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_buf(buf, (size_t)-1, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_buf(buf, size, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_buf(buf, 0, frames_iterate_cb, 0);\n    ASSERT(0 == ret);\n\n    ret = mp3dec_iterate_cb(0, buf, size, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_cb(&io, 0, size, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_cb(&io, buf, (size_t)-1, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_cb(&io, buf, size, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate_cb(&io, buf, 0, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n\n    memset(&dec, 0, sizeof(dec));\n    ret = mp3dec_ex_seek(&dec, 10); /* seek with zero initialized decoder - no-op without fail */\n    ASSERT(0 == ret);\n    ret = mp3dec_ex_read(&dec, (mp3d_sample_t*)buf, 10); /* read with zero initialized decoder - reads zero samples */\n    ASSERT(0 == ret);\n    mp3dec_ex_close(&dec); /* close zero initialized decoder - should not crash */\n\n    ret = mp3dec_ex_open_buf(0, buf, size, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open_buf(&dec, 0, size, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open_buf(&dec, buf, (size_t)-1, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open_buf(&dec, buf, size, MP3D_SEEK_TO_SAMPLE | (MP3D_FLAGS_MASK + 1));\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open_buf(&dec, buf, 0, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(0 == ret);\n    ret = mp3dec_ex_read(&dec, (mp3d_sample_t*)buf, 10);\n    ASSERT(0 == ret);\n    mp3dec_ex_close(&dec);\n\n    ret = mp3dec_ex_open_cb(0, &io, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open_cb(&dec, 0, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open_cb(&dec, &io, MP3D_SEEK_TO_SAMPLE | (MP3D_FLAGS_MASK + 1));\n    ASSERT(MP3D_E_PARAM == ret);\n\n    ret = mp3dec_ex_seek(0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n\n    ret = mp3dec_ex_read(0, (mp3d_sample_t*)buf, 10);\n    ASSERT(0 == ret); /* invalid param case, no decoder structure to report an error */\n    ret = mp3dec_ex_read(&dec, 0, 10);\n    ASSERT(0 == ret && MP3D_E_PARAM == dec.last_error); /* invalid param case */\n    ret = mp3dec_ex_read_frame(0, (mp3d_sample_t**)buf, &frame_info, 10);\n    ASSERT(0 == ret); /* invalid param case, no decoder structure to report an error */\n    ret = mp3dec_ex_read_frame(&dec, 0, &frame_info, 10);\n    ASSERT(0 == ret && MP3D_E_PARAM == dec.last_error); /* invalid param case */\n    ret = mp3dec_ex_read_frame(&dec, (mp3d_sample_t**)buf, 0, 10);\n    ASSERT(0 == ret && MP3D_E_PARAM == dec.last_error); /* invalid param case */\n\n    ret = mp3dec_load(0, input_file_name, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load(&mp3d, 0, &finfo, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load(&mp3d, input_file_name, 0, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_load(&mp3d, \"not_foud\", &finfo, 0, 0);\n    ASSERT(MP3D_E_IOERROR == ret);\n\n    memset(&mp3d, 0xff, sizeof(mp3d));\n    memset(&finfo, 0xff, sizeof(finfo));\n    ret = mp3dec_load(&mp3d, input_file_name, &finfo, progress_cb, 0);\n    ASSERT(MP3D_E_USER == ret && 2304 == finfo.samples && 44100 == finfo.hz && 2 == finfo.channels && 3 == finfo.layer);\n    ASSERT(NULL != finfo.buffer);\n    free(finfo.buffer);\n\n    ret = mp3dec_iterate(0, frames_iterate_cb, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate(input_file_name, 0, 0);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_iterate(\"not_foud\", frames_iterate_cb, 0);\n    ASSERT(MP3D_E_IOERROR == ret);\n\n    ret = mp3dec_ex_open(0, input_file_name, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open(&dec, 0, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open(&dec, input_file_name, MP3D_SEEK_TO_SAMPLE | (MP3D_FLAGS_MASK + 1));\n    ASSERT(MP3D_E_PARAM == ret);\n    ret = mp3dec_ex_open(&dec, \"not_foud\", MP3D_SEEK_TO_SAMPLE);\n    ASSERT(MP3D_E_IOERROR == ret);\n\n    file = fopen(input_file_name, \"rb\");\n    io.read = read_cb;\n    io.seek = seek_cb;\n    io.read_data = io.seek_data = file;\n\n    ret = mp3dec_ex_open_cb(&dec, &io, MP3D_SEEK_TO_SAMPLE);\n    ASSERT(0 == ret);\n    ASSERT(5 == io_num);\n    ASSERT(725760 == dec.samples); /* num samples detected */\n    fail_io_num = 5;\n    mp3d_sample_t sample;\n    size_t readed = mp3dec_ex_read(&dec, &sample, 1);\n    ASSERT(0 == readed);\n    ASSERT(MP3D_E_IOERROR == dec.last_error);\n    readed = mp3dec_ex_read(&dec, &sample, 1);\n    ASSERT(0 == readed);\n    ASSERT(MP3D_E_IOERROR == dec.last_error); /* stays in error state */\n    ret = mp3dec_ex_seek(&dec, 0);\n    ASSERT(0 == ret);\n    ASSERT(0 == dec.last_error); /* error state reset */\n    readed = mp3dec_ex_read(&dec, &sample, 1);\n    ASSERT(1 == readed);\n    mp3dec_ex_close(&dec);\n\n    ret = mp3dec_ex_open_cb(&dec, &io, MP3D_SEEK_TO_SAMPLE | MP3D_DO_NOT_SCAN);\n    ASSERT(0 == ret);\n    ASSERT(0 == dec.samples); /* num samples do not detected because of MP3D_DO_NOT_SCAN */\n    readed = mp3dec_ex_read(&dec, &sample, 1);\n    ASSERT(1 == readed);\n    mp3dec_ex_close(&dec);\n\n    fclose((FILE*)io.read_data);\n    printf(\"passed\\n\");\n    return 0;\n}\n\n#ifdef LIBFUZZER\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)\n{\n    decode_file(Data, Size, 0, 0, 0, 0);\n    return 0;\n}\n#else\n\n#if defined(__arm__) || defined(__aarch64__) || defined(__PPC__)\nint main2(int argc, char *argv[]);\nint main2(int argc, char *argv[])\n#else\nint main(int argc, char *argv[])\n#endif\n{\n    int i, ref_size, do_self_test = 0;\n    for(i = 1; i < argc; i++)\n    {\n        if (argv[i][0] != '-')\n            break;\n        switch (argv[i][1])\n        {\n        case 'm': i++; if (i < argc) mode = atoi(argv[i]); break;\n        case 's': i++; if (i < argc) position = atoi(argv[i]); break;\n        case 'p': i++; if (i < argc) portion  = atoi(argv[i]); break;\n        case 'e': i++; if (i < argc) fail_io_num = atoi(argv[i]); break;\n#ifdef MINIMP3_TEST\n        case 'f': i++; if (i < argc) fail_malloc_num = atoi(argv[i]); break;\n#endif\n        case 'b': seek_to_byte = 1; break;\n        case 't': do_self_test = 1; break;\n        default:\n            printf(\"error: unrecognized option\\n\");\n            return 1;\n        }\n    }\n    char *ref_file_name    = (argc > (i + 1)) ? argv[i + 1] : NULL;\n    char *output_file_name = (argc > (i + 2)) ? argv[i + 2] : NULL;\n    FILE *file_out = NULL;\n    if (output_file_name)\n    {\n        file_out = fopen(output_file_name, \"wb\");\n#ifndef MINIMP3_NO_WAV\n        char *ext = strrchr(output_file_name, '.');\n        if (ext && !strcasecmp(ext + 1, \"wav\"))\n            wave_out = 1;\n#endif\n    }\n    FILE *file_ref = ref_file_name ? fopen(ref_file_name, \"rb\") : NULL;\n    unsigned char *buf_ref = preload(file_ref, &ref_size);\n    if (file_ref)\n        fclose(file_ref);\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n    __AFL_INIT();\n    while (__AFL_LOOP(1000)) {\n#endif\n    char *input_file_name  = (argc > i) ? argv[i] : NULL;\n    if (!input_file_name)\n    {\n        printf(\"error: no file names given\\n\");\n        return 1;\n    }\n    if (do_self_test)\n        return self_test(input_file_name);\n    decode_file(input_file_name, buf_ref, ref_size, file_out);\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n    }\n#endif\n    if (buf_ref)\n        free(buf_ref);\n    if (file_out)\n        fclose(file_out);\n    return 0;\n}\n\n#if defined(__arm__) || defined(__aarch64__) || defined(__PPC__)\nstatic const char *g_files[] = {\n    \"vectors/ILL2_center2.bit\",\n    \"vectors/ILL2_dual.bit\",\n    \"vectors/ILL2_dynx22.bit\",\n    \"vectors/ILL2_dynx31.bit\",\n    \"vectors/ILL2_dynx32.bit\",\n    \"vectors/ILL2_ext_switching.bit\",\n    \"vectors/ILL2_layer1.bit\",\n    \"vectors/ILL2_layer3.bit\",\n    \"vectors/ILL2_mono.bit\",\n    \"vectors/ILL2_multilingual.bit\",\n    \"vectors/ILL2_overalloc1.bit\",\n    \"vectors/ILL2_overalloc2.bit\",\n    \"vectors/ILL2_prediction.bit\",\n    \"vectors/ILL2_samples.bit\",\n    \"vectors/ILL2_scf63.bit\",\n    \"vectors/ILL2_tca21.bit\",\n    \"vectors/ILL2_tca30.bit\",\n    \"vectors/ILL2_tca30_PC.bit\",\n    \"vectors/ILL2_tca31_mtx0.bit\",\n    \"vectors/ILL2_tca31_mtx2.bit\",\n    \"vectors/ILL2_tca31_PC.bit\",\n    \"vectors/ILL2_tca32_PC.bit\",\n    \"vectors/ILL2_wrongcrc.bit\",\n    \"vectors/ILL4_ext_id1.bit\",\n    \"vectors/ILL4_sync.bit\",\n    \"vectors/ILL4_wrongcrc.bit\",\n    \"vectors/ILL4_wrong_length1.bit\",\n    \"vectors/ILL4_wrong_length2.bit\",\n    \"vectors/l1-fl1.bit\",\n    \"vectors/l1-fl2.bit\",\n    \"vectors/l1-fl3.bit\",\n    \"vectors/l1-fl4.bit\",\n    \"vectors/l1-fl5.bit\",\n    \"vectors/l1-fl6.bit\",\n    \"vectors/l1-fl7.bit\",\n    \"vectors/l1-fl8.bit\",\n    \"vectors/l2-fl10.bit\",\n    \"vectors/l2-fl11.bit\",\n    \"vectors/l2-fl12.bit\",\n    \"vectors/l2-fl13.bit\",\n    \"vectors/l2-fl14.bit\",\n    \"vectors/l2-fl15.bit\",\n    \"vectors/l2-fl16.bit\",\n    \"vectors/l2-nonstandard-fl1_fl2_ff.bit\",\n    \"vectors/l2-nonstandard-free_format.bit\",\n    \"vectors/l2-nonstandard-test32-size.bit\",\n    \"vectors/l2-test32.bit\",\n    \"vectors/l3-compl.bit\",\n    \"vectors/l3-he_32khz.bit\",\n    \"vectors/l3-he_44khz.bit\",\n    \"vectors/l3-he_48khz.bit\",\n    \"vectors/l3-hecommon.bit\",\n    \"vectors/l3-he_free.bit\",\n    \"vectors/l3-he_mode.bit\",\n    \"vectors/l3-nonstandard-big-iscf.bit\",\n    \"vectors/l3-nonstandard-compl-sideinfo-bigvalues.bit\",\n    \"vectors/l3-nonstandard-compl-sideinfo-blocktype.bit\",\n    \"vectors/l3-nonstandard-compl-sideinfo-size.bit\",\n    \"vectors/l3-nonstandard-sideinfo-size.bit\",\n    \"vectors/l3-si.bit\",\n    \"vectors/l3-si_block.bit\",\n    \"vectors/l3-si_huff.bit\",\n    \"vectors/l3-sin1k0db.bit\",\n    \"vectors/l3-test45.bit\",\n    \"vectors/l3-test46.bit\",\n    \"vectors/M2L3_bitrate_16_all.bit\",\n    \"vectors/M2L3_bitrate_22_all.bit\",\n    \"vectors/M2L3_bitrate_24_all.bit\",\n    \"vectors/M2L3_compl24.bit\",\n    \"vectors/M2L3_noise.bit\"\n};\nint main()\n{\n    size_t i;\n    char buf[256];\n    char *v[3];\n    v[2] = buf;\n    for (i = 0; i < sizeof(g_files)/sizeof(g_files[0]); i++)\n    {\n        int ret;\n        const char *file = g_files[i];\n        size_t len = strlen(file);\n        strcpy(buf, file);\n        buf[len - 3] = 'p';\n        buf[len - 2] = 'c';\n        buf[len - 1] = 'm';\n        v[1] = (char*)file;\n        printf(\"%s\\n\", file);\n        ret = main2(3, v);\n        if (ret)\n            return ret;\n    }\n    return 0;\n}\n#endif\n#endif\n"
        },
        {
          "name": "player",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "vectors",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}