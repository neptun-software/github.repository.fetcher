{
  "metadata": {
    "timestamp": 1736709915434,
    "page": 429,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "benhoyt/inih",
      "stars": 2534,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "fuzzing/findings\nfuzzing/inihfuzz\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.474609375,
          "content": "\nThe \"inih\" library is distributed under the New BSD license:\n\nCopyright (c) 2009, Ben Hoyt\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Ben Hoyt nor the names of its contributors\n      may be used to endorse or promote products derived from this software\n      without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY BEN HOYT ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL BEN HOYT BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.666015625,
          "content": "# inih (INI Not Invented Here)\n\n[![Tests](https://github.com/benhoyt/inih/actions/workflows/tests.yml/badge.svg)](https://github.com/benhoyt/inih/actions/workflows/tests.yml)\n\n**inih (INI Not Invented Here)** is a simple [.INI file](http://en.wikipedia.org/wiki/INI_file) parser written in C. It's only a couple of pages of code, and it was designed to be _small and simple_, so it's good for embedded systems. It's also more or less compatible with Python's [ConfigParser](http://docs.python.org/library/configparser.html) style of .INI files, including RFC 822-style multi-line syntax and `name: value` entries.\n\nTo use it, just give `ini_parse()` an INI file, and it will call a callback for every `name=value` pair parsed, giving you strings for the section, name, and value. It's done this way (\"SAX style\") because it works well on low-memory embedded systems, but also because it makes for a KISS implementation.\n\nYou can also call `ini_parse_file()` to parse directly from a `FILE*` object, `ini_parse_string()` to parse data from a string, or `ini_parse_stream()` to parse using a custom fgets-style reader function for custom I/O.\n\nDownload a release, browse the source, or read about [how to use inih in a DRY style](http://blog.brush.co.nz/2009/08/xmacros/) with X-Macros.\n\n\n## Compile-time options ##\n\nYou can control various aspects of inih using preprocessor defines:\n\n### Syntax options ###\n\n  * **Multi-line entries:** By default, inih supports multi-line entries in the style of Python's ConfigParser. To disable, add `-DINI_ALLOW_MULTILINE=0`.\n  * **UTF-8 BOM:** By default, inih allows a UTF-8 BOM sequence (0xEF 0xBB 0xBF) at the start of INI files. To disable, add `-DINI_ALLOW_BOM=0`.\n  * **Inline comments:** By default, inih allows inline comments with the `;` character. To disable, add `-DINI_ALLOW_INLINE_COMMENTS=0`. You can also specify which character(s) start an inline comment using `INI_INLINE_COMMENT_PREFIXES`.\n  * **Start-of-line comments:** By default, inih allows both `;` and `#` to start a comment at the beginning of a line. You can override this by changing `INI_START_COMMENT_PREFIXES`.\n  * **Allow no value:** By default, inih treats a name with no value (no `=` or `:` on the line) as an error. To allow names with no values, add `-DINI_ALLOW_NO_VALUE=1`, and inih will call your handler function with value set to NULL.\n\n### Parsing options ###\n\n  * **Stop on first error:** By default, inih keeps parsing the rest of the file after an error. To stop parsing on the first error, add `-DINI_STOP_ON_FIRST_ERROR=1`.\n  * **Report line numbers:** By default, the `ini_handler` callback doesn't receive the line number as a parameter. If you need that, add `-DINI_HANDLER_LINENO=1`.\n  * **Call handler on new section:** By default, inih only calls the handler on each `name=value` pair. To detect new sections (e.g., the INI file has multiple sections with the same name), add `-DINI_CALL_HANDLER_ON_NEW_SECTION=1`. Your handler function will then be called each time a new section is encountered, with `section` set to the new section name but `name` and `value` set to NULL.\n\n### Memory options ###\n\n  * **Stack vs heap:** By default, inih creates a fixed-sized line buffer on the stack. To allocate on the heap using `malloc` instead, specify `-DINI_USE_STACK=0`.\n  * **Maximum line length:** The default maximum line length (for stack or heap) is 200 bytes. To override this, add something like `-DINI_MAX_LINE=1000`. Note that `INI_MAX_LINE` must be 3 more than the longest line (due to `\\r`, `\\n`, and the NUL).\n  * **Initial malloc size:** `INI_INITIAL_ALLOC` specifies the initial malloc size when using the heap. It defaults to 200 bytes.\n  * **Allow realloc:** By default when using the heap (`-DINI_USE_STACK=0`), inih allocates a fixed-sized buffer of `INI_INITIAL_ALLOC` bytes. To allow this to grow to `INI_MAX_LINE` bytes, doubling if needed, set `-DINI_ALLOW_REALLOC=1`.\n  * **Custom allocator:** By default when using the heap, the standard library's `malloc`, `free`, and `realloc` functions are used; to use a custom allocator, specify `-DINI_CUSTOM_ALLOCATOR=1` (and `-DINI_USE_STACK=0`). You must define and link functions named `ini_malloc`, `ini_free`, and (if `INI_ALLOW_REALLOC` is set) `ini_realloc`, which must have the same signatures as the `stdlib.h` memory allocation functions.\n\n## Simple example in C ##\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"../ini.h\"\n\ntypedef struct\n{\n    int version;\n    const char* name;\n    const char* email;\n} configuration;\n\nstatic int handler(void* user, const char* section, const char* name,\n                   const char* value)\n{\n    configuration* pconfig = (configuration*)user;\n\n    #define MATCH(s, n) strcmp(section, s) == 0 && strcmp(name, n) == 0\n    if (MATCH(\"protocol\", \"version\")) {\n        pconfig->version = atoi(value);\n    } else if (MATCH(\"user\", \"name\")) {\n        pconfig->name = strdup(value);\n    } else if (MATCH(\"user\", \"email\")) {\n        pconfig->email = strdup(value);\n    } else {\n        return 0;  /* unknown section/name, error */\n    }\n    return 1;\n}\n\nint main(int argc, char* argv[])\n{\n    configuration config;\n\n    if (ini_parse(\"test.ini\", handler, &config) < 0) {\n        printf(\"Can't load 'test.ini'\\n\");\n        return 1;\n    }\n    printf(\"Config loaded from 'test.ini': version=%d, name=%s, email=%s\\n\",\n        config.version, config.name, config.email);\n    return 0;\n}\n```\n\n\n## C++ example ##\n\nIf you're into C++ and the STL, there is also an easy-to-use [INIReader class](https://github.com/benhoyt/inih/blob/master/cpp/INIReader.h) that stores values in a `map` and lets you `Get()` them:\n\n```cpp\n#include <iostream>\n#include \"INIReader.h\"\n\nint main()\n{\n    INIReader reader(\"../examples/test.ini\");\n\n    if (reader.ParseError() < 0) {\n        std::cout << \"Can't load 'test.ini'\\n\";\n        return 1;\n    }\n    std::cout << \"Config loaded from 'test.ini': version=\"\n              << reader.GetInteger(\"protocol\", \"version\", -1) << \", name=\"\n              << reader.Get(\"user\", \"name\", \"UNKNOWN\") << \", email=\"\n              << reader.Get(\"user\", \"email\", \"UNKNOWN\") << \", pi=\"\n              << reader.GetReal(\"user\", \"pi\", -1) << \", active=\"\n              << reader.GetBoolean(\"user\", \"active\", true) << \"\\n\";\n    return 0;\n}\n```\n\nThis simple C++ API works fine, but it's not very fully-fledged. I'm not planning to work more on the C++ API at the moment, so if you want a bit more power (for example `GetSections()` and `GetFields()` functions), see these forks:\n\n  * https://github.com/Blandinium/inih\n  * https://github.com/OSSystems/inih\n\n\n## Differences from ConfigParser ##\n\nSome differences between inih and Python's [ConfigParser](http://docs.python.org/library/configparser.html) standard library module:\n\n* INI name=value pairs given above any section headers are treated as valid items with no section (section name is an empty string). In ConfigParser having no section is an error.\n* Line continuations are handled with leading whitespace on continued lines (like ConfigParser). However, instead of concatenating continued lines together, they are treated as separate values for the same key (unlike ConfigParser).\n\n\n## Platform-specific notes ##\n\n* Windows/Win32 uses UTF-16 filenames natively, so to handle Unicode paths you need to call `_wfopen()` to open a file and then `ini_parse_file()` to parse it; inih does not include `wchar_t` or Unicode handling.\n\n## Meson notes ##\n\n* The `meson.build` file is not required to use or compile inih, its main purpose is for distributions.\n* By default Meson is set up for distro installation, but this behavior can be configured for embedded use cases:\n  * with `-Ddefault_library=static` static libraries are built.\n  * with `-Ddistro_install=false` libraries, headers and pkg-config files won't be installed.\n  * with `-Dwith_INIReader=false` you can disable building the C++ library.\n* All compile-time options are implemented in Meson as well, you can take a look at [meson_options.txt](https://github.com/benhoyt/inih/blob/master/meson_options.txt) for their definition. These won't work if `distro_install` is set to `true`.\n* If you want to use inih for programs which may be shipped in a distro, consider linking against the shared libraries. The pkg-config entries are `inih` and `INIReader`.\n* In case you use inih as a Meson subproject, you can use the `inih_dep` and `INIReader_dep` dependency variables. You might want to set `default_library=static` and `distro_install=false` for the subproject. An official Wrap is provided on [WrapDB](https://wrapdb.mesonbuild.com/inih).\n* For packagers: if you want to tag the version in the pkg-config file, you will need to do this downstream. Add `version : '<version_as_int>',` after the `license` tag in the `project()` function and `version : meson.project_version(),` after the `soversion` tag in both `library()` functions.\n\n## Using inih with tipi.build\n\n`inih` can be easily used in [tipi.build](https://tipi.build) projects simply by adding the following entry to your `.tipi/deps` (replace `r56` with the latest version tag):\n\n```json\n{\n    \"benhoyt/inih\": { \"@\": \"r56\" }\n}\n```\n\nThe required include path in your project is:\n\n```c\n#include <ini.h>\n```\n\n## Building from vcpkg ##\n\nYou can build and install inih using [vcpkg](https://github.com/microsoft/vcpkg/) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    ./vcpkg install inih\n\nThe inih port in vcpkg is kept up to date by microsoft team members and community contributors.\nIf the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n## Related links ##\n\n* [Conan package for inih](https://github.com/mohamedghita/conan-inih) (Conan is a C/C++ package manager)\n"
        },
        {
          "name": "cpp",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzzing",
          "type": "tree",
          "content": null
        },
        {
          "name": "ini.c",
          "type": "blob",
          "size": 8.2646484375,
          "content": "/* inih -- simple .INI file parser\n\nSPDX-License-Identifier: BSD-3-Clause\n\nCopyright (C) 2009-2020, Ben Hoyt\n\ninih is released under the New BSD license (see LICENSE.txt). Go to the project\nhome page for more info:\n\nhttps://github.com/benhoyt/inih\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n#include \"ini.h\"\n\n#if !INI_USE_STACK\n#if INI_CUSTOM_ALLOCATOR\n#include <stddef.h>\nvoid* ini_malloc(size_t size);\nvoid ini_free(void* ptr);\nvoid* ini_realloc(void* ptr, size_t size);\n#else\n#include <stdlib.h>\n#define ini_malloc malloc\n#define ini_free free\n#define ini_realloc realloc\n#endif\n#endif\n\n#define MAX_SECTION 50\n#define MAX_NAME 50\n\n/* Used by ini_parse_string() to keep track of string parsing state. */\ntypedef struct {\n    const char* ptr;\n    size_t num_left;\n} ini_parse_string_ctx;\n\n/* Strip whitespace chars off end of given string, in place. Return s. */\nstatic char* ini_rstrip(char* s)\n{\n    char* p = s + strlen(s);\n    while (p > s && isspace((unsigned char)(*--p)))\n        *p = '\\0';\n    return s;\n}\n\n/* Return pointer to first non-whitespace char in given string. */\nstatic char* ini_lskip(const char* s)\n{\n    while (*s && isspace((unsigned char)(*s)))\n        s++;\n    return (char*)s;\n}\n\n/* Return pointer to first char (of chars) or inline comment in given string,\n   or pointer to NUL at end of string if neither found. Inline comment must\n   be prefixed by a whitespace character to register as a comment. */\nstatic char* ini_find_chars_or_comment(const char* s, const char* chars)\n{\n#if INI_ALLOW_INLINE_COMMENTS\n    int was_space = 0;\n    while (*s && (!chars || !strchr(chars, *s)) &&\n           !(was_space && strchr(INI_INLINE_COMMENT_PREFIXES, *s))) {\n        was_space = isspace((unsigned char)(*s));\n        s++;\n    }\n#else\n    while (*s && (!chars || !strchr(chars, *s))) {\n        s++;\n    }\n#endif\n    return (char*)s;\n}\n\n/* Similar to strncpy, but ensures dest (size bytes) is\n   NUL-terminated, and doesn't pad with NULs. */\nstatic char* ini_strncpy0(char* dest, const char* src, size_t size)\n{\n    /* Could use strncpy internally, but it causes gcc warnings (see issue #91) */\n    size_t i;\n    for (i = 0; i < size - 1 && src[i]; i++)\n        dest[i] = src[i];\n    dest[i] = '\\0';\n    return dest;\n}\n\n/* See documentation in header file. */\nint ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,\n                     void* user)\n{\n    /* Uses a fair bit of stack (use heap instead if you need to) */\n#if INI_USE_STACK\n    char line[INI_MAX_LINE];\n    size_t max_line = INI_MAX_LINE;\n#else\n    char* line;\n    size_t max_line = INI_INITIAL_ALLOC;\n#endif\n#if INI_ALLOW_REALLOC && !INI_USE_STACK\n    char* new_line;\n    size_t offset;\n#endif\n    char section[MAX_SECTION] = \"\";\n#if INI_ALLOW_MULTILINE\n    char prev_name[MAX_NAME] = \"\";\n#endif\n\n    char* start;\n    char* end;\n    char* name;\n    char* value;\n    int lineno = 0;\n    int error = 0;\n\n#if !INI_USE_STACK\n    line = (char*)ini_malloc(INI_INITIAL_ALLOC);\n    if (!line) {\n        return -2;\n    }\n#endif\n\n#if INI_HANDLER_LINENO\n#define HANDLER(u, s, n, v) handler(u, s, n, v, lineno)\n#else\n#define HANDLER(u, s, n, v) handler(u, s, n, v)\n#endif\n\n    /* Scan through stream line by line */\n    while (reader(line, (int)max_line, stream) != NULL) {\n#if INI_ALLOW_REALLOC && !INI_USE_STACK\n        offset = strlen(line);\n        while (offset == max_line - 1 && line[offset - 1] != '\\n') {\n            max_line *= 2;\n            if (max_line > INI_MAX_LINE)\n                max_line = INI_MAX_LINE;\n            new_line = ini_realloc(line, max_line);\n            if (!new_line) {\n                ini_free(line);\n                return -2;\n            }\n            line = new_line;\n            if (reader(line + offset, (int)(max_line - offset), stream) == NULL)\n                break;\n            if (max_line >= INI_MAX_LINE)\n                break;\n            offset += strlen(line + offset);\n        }\n#endif\n\n        lineno++;\n\n        start = line;\n#if INI_ALLOW_BOM\n        if (lineno == 1 && (unsigned char)start[0] == 0xEF &&\n                           (unsigned char)start[1] == 0xBB &&\n                           (unsigned char)start[2] == 0xBF) {\n            start += 3;\n        }\n#endif\n        start = ini_rstrip(ini_lskip(start));\n\n        if (strchr(INI_START_COMMENT_PREFIXES, *start)) {\n            /* Start-of-line comment */\n        }\n#if INI_ALLOW_MULTILINE\n        else if (*prev_name && *start && start > line) {\n#if INI_ALLOW_INLINE_COMMENTS\n            end = ini_find_chars_or_comment(start, NULL);\n            if (*end)\n                *end = '\\0';\n            ini_rstrip(start);\n#endif\n            /* Non-blank line with leading whitespace, treat as continuation\n               of previous name's value (as per Python configparser). */\n            if (!HANDLER(user, section, prev_name, start) && !error)\n                error = lineno;\n        }\n#endif\n        else if (*start == '[') {\n            /* A \"[section]\" line */\n            end = ini_find_chars_or_comment(start + 1, \"]\");\n            if (*end == ']') {\n                *end = '\\0';\n                ini_strncpy0(section, start + 1, sizeof(section));\n#if INI_ALLOW_MULTILINE\n                *prev_name = '\\0';\n#endif\n#if INI_CALL_HANDLER_ON_NEW_SECTION\n                if (!HANDLER(user, section, NULL, NULL) && !error)\n                    error = lineno;\n#endif\n            }\n            else if (!error) {\n                /* No ']' found on section line */\n                error = lineno;\n            }\n        }\n        else if (*start) {\n            /* Not a comment, must be a name[=:]value pair */\n            end = ini_find_chars_or_comment(start, \"=:\");\n            if (*end == '=' || *end == ':') {\n                *end = '\\0';\n                name = ini_rstrip(start);\n                value = end + 1;\n#if INI_ALLOW_INLINE_COMMENTS\n                end = ini_find_chars_or_comment(value, NULL);\n                if (*end)\n                    *end = '\\0';\n#endif\n                value = ini_lskip(value);\n                ini_rstrip(value);\n\n#if INI_ALLOW_MULTILINE\n                ini_strncpy0(prev_name, name, sizeof(prev_name));\n#endif\n                /* Valid name[=:]value pair found, call handler */\n                if (!HANDLER(user, section, name, value) && !error)\n                    error = lineno;\n            }\n            else if (!error) {\n                /* No '=' or ':' found on name[=:]value line */\n#if INI_ALLOW_NO_VALUE\n                *end = '\\0';\n                name = ini_rstrip(start);\n                if (!HANDLER(user, section, name, NULL) && !error)\n                    error = lineno;\n#else\n                error = lineno;\n#endif\n            }\n        }\n\n#if INI_STOP_ON_FIRST_ERROR\n        if (error)\n            break;\n#endif\n    }\n\n#if !INI_USE_STACK\n    ini_free(line);\n#endif\n\n    return error;\n}\n\n/* See documentation in header file. */\nint ini_parse_file(FILE* file, ini_handler handler, void* user)\n{\n    return ini_parse_stream((ini_reader)fgets, file, handler, user);\n}\n\n/* See documentation in header file. */\nint ini_parse(const char* filename, ini_handler handler, void* user)\n{\n    FILE* file;\n    int error;\n\n    file = fopen(filename, \"r\");\n    if (!file)\n        return -1;\n    error = ini_parse_file(file, handler, user);\n    fclose(file);\n    return error;\n}\n\n/* An ini_reader function to read the next line from a string buffer. This\n   is the fgets() equivalent used by ini_parse_string(). */\nstatic char* ini_reader_string(char* str, int num, void* stream) {\n    ini_parse_string_ctx* ctx = (ini_parse_string_ctx*)stream;\n    const char* ctx_ptr = ctx->ptr;\n    size_t ctx_num_left = ctx->num_left;\n    char* strp = str;\n    char c;\n\n    if (ctx_num_left == 0 || num < 2)\n        return NULL;\n\n    while (num > 1 && ctx_num_left != 0) {\n        c = *ctx_ptr++;\n        ctx_num_left--;\n        *strp++ = c;\n        if (c == '\\n')\n            break;\n        num--;\n    }\n\n    *strp = '\\0';\n    ctx->ptr = ctx_ptr;\n    ctx->num_left = ctx_num_left;\n    return str;\n}\n\n/* See documentation in header file. */\nint ini_parse_string(const char* string, ini_handler handler, void* user) {\n    ini_parse_string_ctx ctx;\n\n    ctx.ptr = string;\n    ctx.num_left = strlen(string);\n    return ini_parse_stream((ini_reader)ini_reader_string, &ctx, handler,\n                            user);\n}\n"
        },
        {
          "name": "ini.h",
          "type": "blob",
          "size": 5.6884765625,
          "content": "/* inih -- simple .INI file parser\n\nSPDX-License-Identifier: BSD-3-Clause\n\nCopyright (C) 2009-2020, Ben Hoyt\n\ninih is released under the New BSD license (see LICENSE.txt). Go to the project\nhome page for more info:\n\nhttps://github.com/benhoyt/inih\n\n*/\n\n#ifndef INI_H\n#define INI_H\n\n/* Make this header file easier to include in C++ code */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n\n/* Nonzero if ini_handler callback should accept lineno parameter. */\n#ifndef INI_HANDLER_LINENO\n#define INI_HANDLER_LINENO 0\n#endif\n\n/* Visibility symbols, required for Windows DLLs */\n#ifndef INI_API\n#if defined _WIN32 || defined __CYGWIN__\n#\tifdef INI_SHARED_LIB\n#\t\tifdef INI_SHARED_LIB_BUILDING\n#\t\t\tdefine INI_API __declspec(dllexport)\n#\t\telse\n#\t\t\tdefine INI_API __declspec(dllimport)\n#\t\tendif\n#\telse\n#\t\tdefine INI_API\n#\tendif\n#else\n#\tif defined(__GNUC__) && __GNUC__ >= 4\n#\t\tdefine INI_API __attribute__ ((visibility (\"default\")))\n#\telse\n#\t\tdefine INI_API\n#\tendif\n#endif\n#endif\n\n/* Typedef for prototype of handler function. */\n#if INI_HANDLER_LINENO\ntypedef int (*ini_handler)(void* user, const char* section,\n                           const char* name, const char* value,\n                           int lineno);\n#else\ntypedef int (*ini_handler)(void* user, const char* section,\n                           const char* name, const char* value);\n#endif\n\n/* Typedef for prototype of fgets-style reader function. */\ntypedef char* (*ini_reader)(char* str, int num, void* stream);\n\n/* Parse given INI-style file. May have [section]s, name=value pairs\n   (whitespace stripped), and comments starting with ';' (semicolon). Section\n   is \"\" if name=value pair parsed before any section heading. name:value\n   pairs are also supported as a concession to Python's configparser.\n\n   For each name=value pair parsed, call handler function with given user\n   pointer as well as section, name, and value (data only valid for duration\n   of handler call). Handler should return nonzero on success, zero on error.\n\n   Returns 0 on success, line number of first error on parse error (doesn't\n   stop on first error), -1 on file open error, or -2 on memory allocation\n   error (only when INI_USE_STACK is zero).\n*/\nINI_API int ini_parse(const char* filename, ini_handler handler, void* user);\n\n/* Same as ini_parse(), but takes a FILE* instead of filename. This doesn't\n   close the file when it's finished -- the caller must do that. */\nINI_API int ini_parse_file(FILE* file, ini_handler handler, void* user);\n\n/* Same as ini_parse(), but takes an ini_reader function pointer instead of\n   filename. Used for implementing custom or string-based I/O (see also\n   ini_parse_string). */\nINI_API int ini_parse_stream(ini_reader reader, void* stream, ini_handler handler,\n                     void* user);\n\n/* Same as ini_parse(), but takes a zero-terminated string with the INI data\ninstead of a file. Useful for parsing INI data from a network socket or\nalready in memory. */\nINI_API int ini_parse_string(const char* string, ini_handler handler, void* user);\n\n/* Nonzero to allow multi-line value parsing, in the style of Python's\n   configparser. If allowed, ini_parse() will call the handler with the same\n   name for each subsequent line parsed. */\n#ifndef INI_ALLOW_MULTILINE\n#define INI_ALLOW_MULTILINE 1\n#endif\n\n/* Nonzero to allow a UTF-8 BOM sequence (0xEF 0xBB 0xBF) at the start of\n   the file. See https://github.com/benhoyt/inih/issues/21 */\n#ifndef INI_ALLOW_BOM\n#define INI_ALLOW_BOM 1\n#endif\n\n/* Chars that begin a start-of-line comment. Per Python configparser, allow\n   both ; and # comments at the start of a line by default. */\n#ifndef INI_START_COMMENT_PREFIXES\n#define INI_START_COMMENT_PREFIXES \";#\"\n#endif\n\n/* Nonzero to allow inline comments (with valid inline comment characters\n   specified by INI_INLINE_COMMENT_PREFIXES). Set to 0 to turn off and match\n   Python 3.2+ configparser behaviour. */\n#ifndef INI_ALLOW_INLINE_COMMENTS\n#define INI_ALLOW_INLINE_COMMENTS 1\n#endif\n#ifndef INI_INLINE_COMMENT_PREFIXES\n#define INI_INLINE_COMMENT_PREFIXES \";\"\n#endif\n\n/* Nonzero to use stack for line buffer, zero to use heap (malloc/free). */\n#ifndef INI_USE_STACK\n#define INI_USE_STACK 1\n#endif\n\n/* Maximum line length for any line in INI file (stack or heap). Note that\n   this must be 3 more than the longest line (due to '\\r', '\\n', and '\\0'). */\n#ifndef INI_MAX_LINE\n#define INI_MAX_LINE 200\n#endif\n\n/* Nonzero to allow heap line buffer to grow via realloc(), zero for a\n   fixed-size buffer of INI_MAX_LINE bytes. Only applies if INI_USE_STACK is\n   zero. */\n#ifndef INI_ALLOW_REALLOC\n#define INI_ALLOW_REALLOC 0\n#endif\n\n/* Initial size in bytes for heap line buffer. Only applies if INI_USE_STACK\n   is zero. */\n#ifndef INI_INITIAL_ALLOC\n#define INI_INITIAL_ALLOC 200\n#endif\n\n/* Stop parsing on first error (default is to keep parsing). */\n#ifndef INI_STOP_ON_FIRST_ERROR\n#define INI_STOP_ON_FIRST_ERROR 0\n#endif\n\n/* Nonzero to call the handler at the start of each new section (with\n   name and value NULL). Default is to only call the handler on\n   each name=value pair. */\n#ifndef INI_CALL_HANDLER_ON_NEW_SECTION\n#define INI_CALL_HANDLER_ON_NEW_SECTION 0\n#endif\n\n/* Nonzero to allow a name without a value (no '=' or ':' on the line) and\n   call the handler with value NULL in this case. Default is to treat\n   no-value lines as an error. */\n#ifndef INI_ALLOW_NO_VALUE\n#define INI_ALLOW_NO_VALUE 0\n#endif\n\n/* Nonzero to use custom ini_malloc, ini_free, and ini_realloc memory\n   allocation functions (INI_USE_STACK must also be 0). These functions must\n   have the same signatures as malloc/free/realloc and behave in a similar\n   way. ini_realloc is only needed if INI_ALLOW_REALLOC is set. */\n#ifndef INI_CUSTOM_ALLOCATOR\n#define INI_CUSTOM_ALLOCATOR 0\n#endif\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* INI_H */\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 3.740234375,
          "content": "project('inih',\n    ['c'],\n    license : 'BSD-3-Clause',\n    version : '58',\n    default_options : ['cpp_std=c++11'],\n    meson_version: '>=0.56.0'\n)\n\n#### options ####\narg_static = []\ndistro_install = get_option('distro_install')\nextra_args = []\n\nif distro_install\n    pkg = import('pkgconfig')\nelse\n    if not get_option('multi-line_entries')\n        arg_static += ['-DINI_ALLOW_MULTILINE=0']\n    endif\n    if not get_option('utf-8_bom')\n        arg_static += ['-DINI_ALLOW_BOM=0']\n    endif\n    if not get_option('inline_comments')\n        arg_static += ['-DINI_ALLOW_INLINE_COMMENTS=0']\n    endif\n    inline_comment_prefix = get_option('inline_comment_prefix')\n    if inline_comment_prefix != ';'\n        arg_static += ['-DINI_INLINE_COMMENT_PREFIXES=\"' + inline_comment_prefix + '\"']\n    endif\n    sol_comment_prefix = get_option('start-of-line_comment_prefix')\n    if sol_comment_prefix != ';#'\n        arg_static += ['-DINI_START_COMMENT_PREFIXES=\"' + sol_comment_prefix + '\"']\n    endif\n    if get_option('allow_no_value')\n        arg_static += ['-DINI_ALLOW_NO_VALUE=1']\n    endif\n    if get_option('stop_on_first_error')\n        arg_static += ['-DINI_STOP_ON_FIRST_ERROR=1']\n    endif\n    if get_option('report_line_numbers')\n        arg_static += ['-DINI_HANDLER_LINENO=1']\n    endif\n    if get_option('call_handler_on_new_section')\n        arg_static += ['-DINI_CALL_HANDLER_ON_NEW_SECTION=1']\n    endif\n    if get_option('use_heap')\n        arg_static += ['-DINI_USE_STACK=0']\n    endif\n    max_line_length = get_option('max_line_length')\n    if max_line_length != 200\n        arg_static += ['-DINI_MAX_LINE=' + max_line_length.to_string()]\n    endif\n    initial_malloc_size = get_option('initial_malloc_size')\n    if initial_malloc_size != 200\n        arg_static += ['-DINI_INITIAL_ALLOC=' + initial_malloc_size.to_string()]\n    endif\n    if get_option('allow_realloc')\n        arg_static += ['-DINI_ALLOW_REALLOC=1']\n    endif\nendif\n\nif host_machine.system() == 'windows'\n    lib = get_option('default_library')\n    if lib == 'both'\n        error('default_library=both is not supported on Windows')\n    elif lib == 'shared'\n        extra_args += '-DINI_SHARED_LIB'\n        add_project_arguments('-DINI_SHARED_LIB_BUILDING', language: ['c', 'cpp'])\n    endif\nendif\n\n#### inih ####\ninc_inih = include_directories('.')\n\nsrc_inih = files('ini.c')\n\nlib_inih = library('inih',\n    [src_inih],\n    include_directories : inc_inih,\n    c_args : [arg_static, extra_args],\n    install : distro_install,\n    soversion : '0',\n    gnu_symbol_visibility: 'hidden'\n)\n\nif distro_install\n    install_headers('ini.h')\n\n    pkg.generate(lib_inih,\n        name : 'inih',\n        description : 'simple .INI file parser',\n        extra_cflags : extra_args,\n    )\nendif\n\ninih_dep = declare_dependency(\n    link_with : lib_inih,\n    compile_args : arg_static + extra_args,\n    include_directories : inc_inih\n)\n\nsubdir('tests')\n\n#### INIReader ####\nif get_option('with_INIReader')\n    add_languages('cpp')\n    inc_INIReader = include_directories('cpp')\n\n    src_INIReader = files(join_paths('cpp', 'INIReader.cpp'))\n\n    lib_INIReader = library('INIReader',\n        src_INIReader,\n        cpp_args : extra_args,\n        include_directories : inc_INIReader,\n        dependencies : inih_dep,\n        install : distro_install,\n        soversion : '0',\n        gnu_symbol_visibility: 'hidden'\n    )\n\n    if distro_install\n        install_headers('cpp/INIReader.h')\n\n        pkg.generate(lib_INIReader,\n            name : 'INIReader',\n            description : 'simple .INI file parser for C++',\n            extra_cflags : extra_args,\n        )\n    endif\n\n    INIReader_dep = declare_dependency(\n        link_with : lib_INIReader,\n        include_directories : inc_INIReader,\n        compile_args : extra_args\n    )\n\n    subdir('examples')\nendif\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 2.015625,
          "content": "option('distro_install',\n  type : 'boolean',\n  value : true,\n  description : 'install shared libs, headers and pkg-config entries'\n)\noption('with_INIReader',\n  type : 'boolean',\n  value : true,\n  description : 'compile and (if selected) install INIReader'\n)\noption('multi-line_entries',\n  type : 'boolean',\n  value : true,\n  description : 'support for multi-line entries in the style of Python\\'s ConfigParser'\n)\noption('utf-8_bom',\n  type : 'boolean',\n  value : true,\n  description : 'allow a UTF-8 BOM sequence (0xEF 0xBB 0xBF) at the start of INI files'\n)\noption('inline_comments',\n  type : 'boolean',\n  value : true,\n  description : 'allow inline comments with the comment prefix character'\n)\noption('inline_comment_prefix',\n  type : 'string',\n  value : ';',\n  description : 'character(s) to start an inline comment (if enabled)'\n)\noption('start-of-line_comment_prefix',\n  type : 'string',\n  value : ';#',\n  description : 'character(s) to start a comment at the beginning of a line'\n)\noption('allow_no_value',\n  type : 'boolean',\n  value : false,\n  description : 'allow name with no value'\n)\noption('stop_on_first_error',\n  type : 'boolean',\n  value : false,\n  description : 'stop parsing after an error'\n)\noption('report_line_numbers',\n  type : 'boolean',\n  value : false,\n  description : 'report line number on ini_handler callback'\n)\noption('call_handler_on_new_section',\n  type : 'boolean',\n  value : false,\n  description : 'call the handler each time a new section is encountered'\n)\noption('use_heap',\n  type : 'boolean',\n  value : false,\n  description : 'allocate memory on the heap using malloc instead using a fixed-sized line buffer on the stack'\n)\noption('max_line_length',\n  type : 'integer',\n  value : 200,\n  description : 'maximum line length in bytes'\n)\noption('initial_malloc_size',\n  type : 'integer',\n  value : 200,\n  description : 'initial malloc size in bytes (when using the heap)'\n)\noption('allow_realloc',\n  type : 'boolean',\n  value : false,\n  description : 'allow initial malloc size to grow to max line length (when using the heap)'\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}