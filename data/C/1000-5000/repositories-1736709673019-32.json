{
  "metadata": {
    "timestamp": 1736709673019,
    "page": 32,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jpmens/jo",
      "stars": 4693,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4296875,
          "content": "*.dSYM\n.DS_Store\n*.o\n*.so\n*.la\n*.lai\n*.so.*\n\n# Autotools junk\n.libs\n.deps\n.dirstamp\nlibtool\n*.log\nstamp-h1\nconfig.log\nconfig.status\nautom4te.cache\nINSTALL\nMakefile\njo-*.tar.gz\nconfigure\naclocal.m4\nMakefile.in\nversion.h\nconfig.cache\nm4/libtool.m4\nm4/ltoptions.m4\nm4/ltsugar.m4\nm4/ltversion.m4\nm4/lt~obsolete.m4\n*.trs\ninstall-sh\ndepcomp\nmissing\nbuild-aux/compile\nbuild-aux/depcomp\nbuild-aux/install-sh\nbuild-aux/missing\n\ntests/jo.07.sh\njo\ng\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.244140625,
          "content": "os:\n - linux\n - osx\n\narch:\n  - amd64\n  - ppc64le\nsudo: false\nlanguage: c\ncompiler:\n - gcc\n - clang\nbefore_install:\n - echo $TRAVIS_OS_NAME\n - uname -a\n - echo $LANG\n - echo $LC_ALL\nbefore_script:\n - autoreconf -i\n - ./configure\nscript:\n - make check\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0654296875,
          "content": "Jan-Piet Mens <jpmens@gmail.com>\nAdrian Ho <the.gromgit@gmail.com>\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.96875,
          "content": "/*\n * Copyright (C) 2016 Jan-Piet Mens <jpmens@gmail.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n#--------------------------------------------------------------------\njson.[ch]\n\n/*\n  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)\n  All rights reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 3.0087890625,
          "content": "\n2022-11-04 1.9\n- FIX: fix reading of long lines from stdin (mk 2) (#195)\n- FIX: add missing test files (#196)\n\n2022-11-04 1.8\n- FIX: fix reading of long lines from stdin (mk 2) (#195)\n\n2022-10-29 1.7\n- FIX: fix warnings on Windows build and reimplement err{x,} functions (#193)\n- FIX: fix reading of long lines from stdin and refactor slurp_file() in the process. (#192)\n- NEW: Add option -o outfile for when not run from a shell and redirect '>' is not an option. (#189)\n- FIX: fix tables in jo.md (#167)\n\n2022-01-05 1.6\n\n- FIX: repair tests broken by AUTHORS change (#164)\n- FIX: repair make distcheck by removing copied _jo zsh functions\n\n2022-01-04 1.5\n\n- NEW: replace asserts with human errors (#162)\n- NEW: zsh completion (#158)\n- FIX: stdin filter on Windows (#\n- FIX: several cleanups\n- NEW: Meson build\n- UPD: snap to newer base (#149)\n- NEW: option to deduplicate keys (#143, #145)\n- NEW: Filter functionality (#141)\n- FIX: file embedding\n- FIX: add missing tests to Makefile.am\n\n2020-07-18 1.4\n\n- FIX: Coercion flag logic now permits getopt(3) double-dash\n- FIX: Documentation clarifies special characters\n- FIX: Jo builds on snap builds (#110)\n- FIX: Jo builds on systems with slightly older pkg-config (#107)\n\n\n2019-11-04 1.3\n- FIX: Escaped @ (\"\\@\") is treated as \"@\" (#42, #103)\n- NEW: Support reading JSON array elements (#91)\n- UPD: Add home and removable-media interfaces to snap (#94)\n- FIX: fix unlikely crash after malloc fail when base64 encoding.\n- NEW: Support reading nested data from pipes (#82)\n\n2018-12-10 1.2\n- NEW: Dockerfile (#76)\n- UPD: add examples of empty arrays/objects to manual (#74)\n- NEW: support -e to ignore empty stdin; contributed by Robi Karp\n- NEW: object-path support (#57)\n\n2017-05-18 1.1\n- NEW: type coercion (#55)\n- FIX: quotes in quotes and double quotes at begin of string (#47)\n- FIX: catch null value in assignmen (#46)\n- NEW: support for key:=file.json for reading object values from a file (#43)\n- NEW: PPA contributed by Ross Duggan in #32\n- FIX: \"null\" is now handled like we handle \"true\" and \"false\"; disable with -B\n- NEW: more tests in the test suite\n\n2016-03-11 1.0\n- NEW: read JSON element values from files (#22)\n- FIX: usage diagnostic\n- NEW: add support for OpenBSD pledge(2) (#21)\n\n2016-03-10 0.9\n- UPD: revert support for $JO_PRETTY et. al; it was a bad idea\n\n2016-03-10 0.8\n- UPD: new test suite\n- NEW: support for nested elements (#19)\n- NEW: if $JO_PRETTY is set, jo will always pretty-print\n- NEW: Define $JO_SPACER to any desired number of spaces or tabs for pretty-printing (#18)\n\n2016-03-09 0.7\n- NEW: strings \"true\"/\"false\" now default to booleans; avoid with -B (#17)\n- FIX: test.sh get quotes to prevent failures with pdksh (#16)\n- FIX: pretty-print Version if requested (#15)\n- FIX: Add cast to suppress warning when compiling with GCC 4.8.4 (#14)\n\n2016-03-08 0.6\n- FIX: make build work on CentOS 6 (#13)\n- NEW: JSONy version with -V\n\n2016-03-08 0.5\n- FIX: fileno error (#12)\n\n2016-03-08 0.4\n- NEW: Win32 support for CJK contributed by @mattn\n\n2016-03-08 0.3\n- NEW: autotools support\n- NEW: option -v\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.244140625,
          "content": "FROM alpine AS builder\nRUN apk -U add automake autoconf build-base make pkgconf\nCOPY . /src\nWORKDIR /src\nRUN autoreconf -i && ./configure && make check && make install\n\nFROM alpine\nCOPY --from=builder /usr/local/bin/jo /bin/jo\nENTRYPOINT [\"/bin/jo\"]\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 2.28125,
          "content": "\nAM_CFLAGS\t= -Wall -O2\n\nbin_PROGRAMS\t= jo\njo_SOURCES\t= jo.c json.c json.h base64.c base64.h\njo_EXTRA\t= jo.pandoc\ndist_man_MANS\t= jo.1\njo_LDADD\t= -lm\n\nbashcompdir = @bashcompdir@\ndist_bashcomp_DATA = jo.bash\n\nzshcompdir = $(datadir)/zsh/site-functions\ndist_zshcomp_DATA = jo.zsh\ninstall-data-hook:\n\tmv -f $(DESTDIR)$(zshcompdir)/jo.zsh $(DESTDIR)$(zshcompdir)/_jo\n\nuninstall-local:\n\trm -f $(DESTDIR)$(zshcompdir)/_jo\n\nif USE_PANDOC\n# Add targets to rebuild pages\njo.1: jo.pandoc\n\t@test -n \"$(PANDOC)\" || \\\n\t  { echo 'pandoc' not found during configure.; exit 1; }\n\t$(PANDOC) -s -w man -f markdown -o $@ $<\n\njo.md: jo.pandoc\n\t@test -n \"$(PANDOC)\" || \\\n\t  { echo 'pandoc' not found during configure.; exit 1; }\n\t$(PANDOC) -s -w gfm -f markdown-smart -o $@ $<\n\nendif\n\n# docdir\t\t= $(datadir)/doc/@PACKAGE@\n# doc_DATA\t= README.md \n\n# If on OS/X, fail if $COPYFILE_DISABLE is not in the environment\n# so that tar doesn't bundle the AppleDouble attributes\n\ndist-hook:\n\tif test $$(uname -s) = \"Darwin\" -a \"x$$COPYFILE_DISABLE\" = \"x\"; then echo \"Set COPYFILE_DISABLE before making dist\" >&2; exit 2; fi \n\nTEST_LOG_DRIVER = env AM_TAP_AWK='$(AWK)' $(SHELL) \\\n                  $(top_srcdir)/build-aux/tap-driver.sh\n\nTESTS\t\t= tests/jo.test\n\nEXTRA_DIST\t= $(jo_EXTRA) \\\n\t\t  $(TESTS) \\\n\t\t  tests/jo.01.sh tests/jo.01.exp \\\n\t\t  tests/jo.02.sh tests/jo.02.exp \\\n\t\t  tests/jo.03.sh tests/jo.03.exp \\\n\t\t  tests/jo.04.sh tests/jo.04.exp \\\n\t\t  tests/jo.05.sh tests/jo.05.exp \\\n\t\t  tests/jo.06.sh tests/jo.06.exp \\\n\t\t  tests/jo.07.sh.in \\\n\t\t  tests/jo.08.sh tests/jo.08.exp \\\n\t\t  tests/jo.09.sh tests/jo.09.exp \\\n\t\t  tests/jo.10.sh tests/jo.10.exp \\\n\t\t  tests/jo.11.sh tests/jo.11.exp \\\n\t\t  tests/jo.12.sh tests/jo.12.exp \\\n\t\t  tests/jo.13.sh tests/jo.13.exp tests/jo-logo.png \\\n\t\t  tests/jo.14.sh tests/jo.14.exp \\\n\t\t  tests/jo.15.sh tests/jo.15.exp \\\n\t\t  tests/jo.16.sh tests/jo.16.exp \\\n\t\t  tests/jo.17.sh tests/jo.17.exp tests/jo-creator.txt \\\n\t\t  tests/jo.18.sh tests/jo.18.exp \\\n\t\t  tests/jo.19.sh tests/jo.19.exp \\\n\t\t  tests/jo.20.sh tests/jo.20.exp tests/jo-large1.json tests/jo-large2.json \\\n\t\t  tests/jo.21.sh tests/jo.21.exp \\\n\t\t  tests/jo.22.sh tests/jo.22.exp \\\n\t\t  tests/jo.23.sh tests/jo.23.exp \\\n\t\t  tests/jo.24.sh tests/jo.24.exp \\\n\t\t  tests/jo.25.sh tests/jo.25.exp \\\n\t\t  tests/jo.26.sh tests/jo.26.exp \\\n\t\t  tests/jo.27.sh tests/jo.27.exp\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.0087890625,
          "content": "README.md"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.791015625,
          "content": "# jo\n\n![jo logo](tests/jo-logo.png)\n\nThis is `jo`, a small utility to create JSON objects\n\n```bash\n$ jo -p name=jo n=17 parser=false\n{\n    \"name\": \"jo\",\n    \"n\": 17,\n    \"parser\": false\n}\n```\n\nor arrays\n\n```bash\n$ seq 1 10 | jo -a\n[1,2,3,4,5,6,7,8,9,10]\n```\n\nIt has a [manual](jo.md), and you can read [why I wrote jo](http://jpmens.net/2016/03/05/a-shell-command-to-create-json-jo/).\n\n## Build from Release tarball\n\nTo build from [a release](https://github.com/jpmens/jo/releases) you will need a C compiler to install from a source tarball which you download from the [Releases page](https://github.com/jpmens/jo/releases).\n\n```bash\ntar xvzf jo-1.3.tar.gz\ncd jo-1.3\nautoreconf -i\n./configure\nmake check\nmake install\n```\n\n\n## Build from Github\n\n[![Build Status](https://api.travis-ci.com/jpmens/jo.svg?branch=master)](https://travis-ci.com/github/jpmens/jo)\n\nTo install from the repository, you will need a C compiler as well as a relatively recent version of _automake_ and _autoconf_.\n\n```bash\ngit clone https://github.com/jpmens/jo.git\ncd jo\nautoreconf -i\n./configure\nmake check\nmake install\n```\n\n## Install\n\n### Homebrew\n\n```bash\nbrew install jo\n```\n\n### MacPorts\n\n```bash\nsudo port install jo\n```\n\n### Ubuntu\n\n```\napt-get install jo\n```\n\n### Gentoo\n\n```\nemerge jo\n```\n\n### Fedora\n\n```\ndnf install jo\n```\n\n### Snap\n\nThanks to [Roger Light](https://twitter.com/ralight/status/1166023769623867398), _jo_ is available as a [snap package](https://snapcraft.io/jo). Use `snap install jo` from a Linux distro that supports snaps.\n\n### Windows\n```cmd\nscoop install jo\n```\n\n### Windows WSL2\n\nAs shown in [#175](https://github.com/jpmens/jo/issues/175) when using _git_ on Windows WSL2 it should be necessary to disable automatic CRLF conversion in _git_ or the tests will fail:\n\n```cmd\ngit config --local core.autocrlf false\n```\n\n### AIX\n\n_jo_ builds and passes all tests on AIX 7.1 using the _autoconf_, _automake_, _gcc_, and _pkg-config_ RPMs from IBM's [AIX Toolbox for Open Source Software](https://www.ibm.com/support/pages/node/883796).  The _xlclang_ compiler from IBM's xlC/C++ suite for AIX will also build _jo_.\n\n## Others\n\n* [voidlinux](https://github.com/voidlinux/void-packages/tree/master/srcpkgs/jo)\n* [ArchLinux](https://archlinux.org/packages/extra/x86_64/jo/)\n* [OpenBSD](http://openports.se/textproc/jo)\n* [FreeBSD](https://www.freshports.org/textproc/jo)\n* [Guix](https://packages.guix.gnu.org/packages/jo/)\n* [pkgsrc](http://pkgsrc.se/textproc/jo)\n* [repology.org](https://repology.org/metapackage/jo/versions)\n* [Docker](https://hub.docker.com/repository/docker/jpmens/jo)\n\n## See also\n\n* [gjo](https://github.com/skanehira/gjo)\n* [rjo](https://github.com/dskkato/rjo)\n* [jjo](https://github.com/memoryhole/jjo)\n* [jf](https://github.com/sayanarijit/jf)\n\n## Credits\n\n* `json.[ch]` by 2011 Joseph A. Adams (joeyadams3.14159[at]gmail.com).\n"
        },
        {
          "name": "base64.c",
          "type": "blob",
          "size": 2.3486328125,
          "content": "/*\n\n\tThis code is public domain software.\n\n*/\n\n#include \"base64.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n//  base64 encoding\n//\n//  buf:     binary input data\n//  size:    size of input (bytes)\n//  return:  base64-encoded string (null-terminated)\n//           memory for output will be allocated here, free it later\n//\nchar* base64_encode(const void* buf, size_t size)\n{\n\tstatic const char base64[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\tchar* str = (char*) malloc((size+3)*4/3 + 1);\n\n\tchar* p = str;\n\tconst unsigned char* q = (const unsigned char*) buf;\n\tsize_t i = 0;\n\n\tif (str == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (i < size) {\n\t\tint c = q[i++];\n\t\tc *= 256;\n\t\tif (i < size)\n            c += q[i];\n\t\ti++;\n\n\t\tc *= 256;\n\t\tif (i < size)\n            c += q[i];\n\t\ti++;\n\n\t\t*p++ = base64[(c & 0x00fc0000) >> 18];\n\t\t*p++ = base64[(c & 0x0003f000) >> 12];\n\n\t\tif (i > size + 1)\n\t\t\t*p++ = '=';\n\t\telse\n\t\t\t*p++ = base64[(c & 0x00000fc0) >> 6];\n\n\t\tif (i > size)\n\t\t\t*p++ = '=';\n\t\telse\n\t\t\t*p++ = base64[c & 0x0000003f];\n\t}\n\n\t*p = 0;\n\n\treturn str;\n}\n\n\n//  single base64 character conversion\n//\nstatic int POS(char c)\n{\n\tif (c>='A' && c<='Z') return c - 'A';\n\tif (c>='a' && c<='z') return c - 'a' + 26;\n\tif (c>='0' && c<='9') return c - '0' + 52;\n\tif (c == '+') return 62;\n\tif (c == '/') return 63;\n\tif (c == '=') return -1;\n    return -2;\n}\n\n//  base64 decoding\n//\n//  s:       base64 string, must be null-terminated\n//  data:    output buffer for decoded data\n//  data_len size of decoded data\n//  return:  allocated data buffer\n//\nvoid* base64_decode(const char* s, size_t *data_len)\n{\n    const char *p;\n    unsigned char *q, *data;\n    int n[4] = { 0, 0, 0, 0 };\n\n\tsize_t len = strlen(s);\n\tif (len % 4)\n\t\treturn NULL;\n\tdata = (unsigned char*) malloc(len/4*3);\n\tq = (unsigned char*) data;\n\n\tfor (p = s; *p; ) {\n\t    n[0] = POS(*p++);\n\t    n[1] = POS(*p++);\n\t    n[2] = POS(*p++);\n\t    n[3] = POS(*p++);\n\n            if (n[0] == -2 || n[1] == -2 || n[2] == -2 || n[3] == -2)\n                return NULL;\n\n\t    if (n[0] == -1 || n[1] == -1)\n\t\treturn NULL;\n\n\t    if (n[2] == -1 && n[3] != -1)\n\t\treturn NULL;\n\n            q[0] = (n[0] << 2) + (n[1] >> 4);\n\t    if (n[2] != -1)\n                q[1] = ((n[1] & 15) << 4) + (n[2] >> 2);\n\t    if (n[3] != -1)\n                q[2] = ((n[2] & 3) << 6) + n[3];\n\t    q += 3;\n\t}\n\n\t*data_len = q-data - (n[2]==-1) - (n[3]==-1);\n\n\treturn data;\n}\n"
        },
        {
          "name": "base64.h",
          "type": "blob",
          "size": 0.1767578125,
          "content": "#ifndef BASE64_H_GUARD\n#define BASE64_H_GUARD\n\n#include <stddef.h>\n\nchar* base64_encode(const void* buf, size_t size);\nvoid* base64_decode(const char* s, size_t *data_len);\n\n#endif\n"
        },
        {
          "name": "build-aux",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 1.6484375,
          "content": "AC_PREREQ([2.63])\nAC_INIT([jo], [1.9], [jp@mens.de])\nAC_CONFIG_AUX_DIR([build-aux])\nAC_CONFIG_SRCDIR([jo.c])\n\n# Checks for programs.\nAC_PROG_CC\n\n# Checks for header files.\nAC_USE_SYSTEM_EXTENSIONS\nAC_CHECK_HEADERS([stddef.h stdint.h stdlib.h string.h unistd.h stdbool.h])\n\n# Checks for library functions.\n# AC_FUNC_MALLOC\n# AC_FUNC_REALLOC\nAC_FUNC_STRTOD\nAC_CHECK_FUNCS([strchr strrchr strlcpy strlcat snprintf pledge err errx])\n\n# backport PKG_CHECK_VAR from pkgconfig 0.29\nm4_ifndef([PKG_CHECK_VAR], [AC_DEFUN([PKG_CHECK_VAR],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nAC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl\n\n_PKG_CONFIG([$1], [variable=\"][$3][\"], [$2])\nAS_VAR_COPY([$1], [pkg_cv_][$1])\n\nAS_VAR_IF([$1], [\"\"], [$5], [$4])dnl\n])dnl PKG_CHECK_VAR\n])\n\n\nAM_INIT_AUTOMAKE([foreign -Wall])\nAM_SILENT_RULES([yes])\nAC_REQUIRE_AUX_FILE([tap-driver.sh])\n\nAC_ARG_VAR(PANDOC, [pandoc path])\nAC_PATH_PROG(PANDOC, [pandoc], [])\nif test -z \"$PANDOC\"\nthen\n  AC_MSG_WARN([pandoc not found, man pages rebuild will not be possible])\nfi\nAM_CONDITIONAL([USE_PANDOC], [test -n \"$PANDOC\"])\n\nPKG_CHECK_VAR(bashcompdir, [bash-completion], [completionsdir], ,\n     bashcompdir=\"${sysconfdir}/bash_completion.d\")\nAC_SUBST(bashcompdir)\n\nAC_CONFIG_FILES([Makefile tests/jo.07.sh])\nAC_OUTPUT\n\necho \"\n  Jo.............: version $PACKAGE_VERSION\n  Prefix.........: $prefix\n  C compiler.....: $CC $CFLAGS $CPPFLAGS\n  Pandoc.........: ${PANDOC:-NONE}\n  Bash completion: $bashcompdir/jo.bash\n\n  Now type 'make @<:@<target>@:>@'\n    where the optional <target> is:\n      all                - build all binaries\n      check              - run the tests\n      install            - install everything\n\"\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "jo.1",
          "type": "blob",
          "size": 11.658203125,
          "content": "'\\\" t\n.\\\" Automatically generated by Pandoc 2.12\n.\\\"\n.TH \"JO\" \"1\" \"\" \"User Manuals\" \"\"\n.hy\n.SH NAME\n.PP\njo - JSON output from a shell\n.SH SYNOPSIS\n.PP\njo [-p] [-a] [-B] [-D] [-e] [-n] [-v] [-V] [-d keydelim] [-f file]\n[\\[en]] [ [-s|-n|-b] word \\&...]\n.SH DESCRIPTION\n.PP\n\\f[I]jo\\f[R] creates a JSON string on \\f[I]stdout\\f[R] from\n\\f[I]word\\f[R]s given it as arguments or read from \\f[I]stdin\\f[R].\nIf \\f[C]-f\\f[R] is specified, \\f[I]jo\\f[R] first loads the contents of\n\\f[I]file\\f[R] as a JSON object or array, then modifies it with\nsubsequent \\f[I]word\\f[R]s before printing the final JSON string to\n\\f[I]stdout\\f[R].\n\\f[I]file\\f[R] may be specified as \\f[C]-\\f[R] to read from\n\\f[I]jo\\f[R]\\[cq]s standard input; this takes precedence over reading\n\\f[I]word\\f[R]s from \\f[I]stdin\\f[R].\n.PP\nWithout option \\f[C]-a\\f[R] it generates an object whereby each\n\\f[I]word\\f[R] is a \\f[C]key=value\\f[R] (or \\f[C]key\\[at]value\\f[R])\npair with \\f[I]key\\f[R] being the JSON object element and\n\\f[I]value\\f[R] its value.\n\\f[I]jo\\f[R] attempts to guess the type of \\f[I]value\\f[R] in order to\ncreate number (using \\f[I]strtod(3)\\f[R]), string, or null values in\nJSON.\n.PP\nA missing or empty \\f[I]value\\f[R] normally results in an element whose\nvalue is \\f[C]null\\f[R].\nIf \\f[C]-n\\f[R] is specified, this element is not created.\n.PP\n\\f[I]jo\\f[R] normally treats \\f[I]key\\f[R] as a literal string value.\nIf the \\f[C]-d\\f[R] option is specified, \\f[I]key\\f[R] will be\ninterpreted as an \\f[I]object path\\f[R], whose individual components are\nseparated by the first character of \\f[I]keydelim\\f[R].\n.PP\n\\f[I]jo\\f[R] normally treats \\f[I]value\\f[R] as a literal string value,\nunless it begins with one of the following characters:\n.PP\n.TS\ntab(@);\nl l.\nT{\nvalue\nT}@T{\naction\nT}\n_\nT{\n\\[at]file\nT}@T{\nsubstitute the contents of \\f[I]file\\f[R] as-is\nT}\nT{\n%file\nT}@T{\nsubstitute the contents of \\f[I]file\\f[R] in base64-encoded form\nT}\nT{\n:file\nT}@T{\ninterpret the contents of \\f[I]file\\f[R] as JSON, and substitute the\nresult\nT}\n.TE\n.PP\nEscape the special character with a backslash to prevent this\ninterpretation.\n.PP\n\\f[I]jo\\f[R] treats \\f[C]key\\[at]value\\f[R] specifically as boolean JSON\nelements: if the value begins with \\f[C]T\\f[R], \\f[C]t\\f[R], or the\nnumeric value is greater than zero, the result is \\f[C]true\\f[R], else\n\\f[C]false\\f[R].\n.PP\n\\f[I]jo\\f[R] creates an array instead of an object when \\f[C]-a\\f[R] is\nspecified.\n.PP\nWhen the \\f[C]:=\\f[R] operator is used in a \\f[I]word\\f[R], the name to\nthe right of \\f[C]:=\\f[R] is a file containing JSON which is parsed and\nassigned to the key left of the operator.\nThe file may be specified as \\f[C]-\\f[R] to read from \\f[I]jo\\f[R]\\[cq]s\nstandard input.\n.SH TYPE COERCION\n.PP\n\\f[I]jo\\f[R]\\[cq]s type guesses can be overridden on a per-word basis by\nprefixing \\f[I]word\\f[R] with \\f[C]-s\\f[R] for \\f[I]string\\f[R],\n\\f[C]-n\\f[R] for \\f[I]number\\f[R], or \\f[C]-b\\f[R] for\n\\f[I]boolean\\f[R].\nThe list of \\f[I]word\\f[R]s \\f[I]must\\f[R] be prefixed with\n\\f[C]--\\f[R], to indicate to \\f[I]jo\\f[R] that there are no more global\noptions.\n.PP\nType coercion works as follows:\n.PP\n.TS\ntab(@);\nl l l l l.\nT{\nword\nT}@T{\n-s\nT}@T{\n-n\nT}@T{\n-b\nT}@T{\ndefault\nT}\n_\nT{\na=\nT}@T{\n\\[lq]a\\[rq]:\\[dq]\\[dq]\nT}@T{\n\\[lq]a\\[rq]:0\nT}@T{\n\\[lq]a\\[rq]:false\nT}@T{\n\\[lq]a\\[rq]:null\nT}\nT{\na=string\nT}@T{\n\\[lq]a\\[rq]:\\[lq]string\\[rq]\nT}@T{\n\\[lq]a\\[rq]:6\nT}@T{\n\\[lq]a\\[rq]:true\nT}@T{\n\\[lq]a\\[rq]:\\[lq]string\\[rq]\nT}\nT{\na=\\[dq]quoted\\[dq]\nT}@T{\n\\[lq]a\\[rq]:\\[lq]\\[dq]quoted\\[dq]\\[rq]\nT}@T{\n\\[lq]a\\[rq]:8\nT}@T{\n\\[lq]a\\[rq]:true\nT}@T{\n\\[lq]a\\[rq]:\\[lq]\\[dq]quoted\\[dq]\\[rq]\nT}\nT{\na=12345\nT}@T{\n\\[lq]a\\[rq]:\\[lq]12345\\[rq]\nT}@T{\n\\[lq]a\\[rq]:12345\nT}@T{\n\\[lq]a\\[rq]:true\nT}@T{\n\\[lq]a\\[rq]:12345\nT}\nT{\na=true\nT}@T{\n\\[lq]a\\[rq]:\\[lq]true\\[rq]\nT}@T{\n\\[lq]a\\[rq]:1\nT}@T{\n\\[lq]a\\[rq]:true\nT}@T{\n\\[lq]a\\[rq]:true\nT}\nT{\na=false\nT}@T{\n\\[lq]a\\[rq]:\\[lq]false\\[rq]\nT}@T{\n\\[lq]a\\[rq]:0\nT}@T{\n\\[lq]a\\[rq]:false\nT}@T{\n\\[lq]a\\[rq]:false\nT}\nT{\na=null\nT}@T{\n\\[lq]a\\[rq]:\\[dq]\\[dq]\nT}@T{\n\\[lq]a\\[rq]:0\nT}@T{\n\\[lq]a\\[rq]:false\nT}@T{\n\\[lq]a\\[rq]:null\nT}\n.TE\n.PP\nCoercing a non-number string to number outputs the \\f[I]length\\f[R] of\nthe string.\n.PP\nCoercing a non-boolean string to boolean outputs \\f[C]false\\f[R] if the\nstring is empty, \\f[C]true\\f[R] otherwise.\n.PP\nType coercion only applies to \\f[C]key=value\\f[R] words, and individual\nwords in a \\f[C]-a\\f[R] array.\nCoercing other words has no effect.\n.SH EXAMPLES\n.PP\nCreate an object.\nNote how the incorrectly-formatted float value becomes a string:\n.IP\n.nf\n\\f[C]\n$ jo tst=1457081292 lat=12.3456 cc=FR badfloat=3.14159.26 name=\\[dq]JP Mens\\[dq] nada= coffee\\[at]T\n{\\[dq]tst\\[dq]:1457081292,\\[dq]lat\\[dq]:12.3456,\\[dq]cc\\[dq]:\\[dq]FR\\[dq],\\[dq]badfloat\\[dq]:\\[dq]3.14159.26\\[dq],\\[dq]name\\[dq]:\\[dq]JP Mens\\[dq],\\[dq]nada\\[dq]:null,\\[dq]coffee\\[dq]:true}\n\\f[R]\n.fi\n.PP\nPretty-print an array with a list of files in the current directory:\n.IP\n.nf\n\\f[C]\n$ jo -p -a *\n[\n \\[dq]Makefile\\[dq],\n \\[dq]README.md\\[dq],\n \\[dq]jo.1\\[dq],\n \\[dq]jo.c\\[dq],\n \\[dq]jo.pandoc\\[dq],\n \\[dq]json.c\\[dq],\n \\[dq]json.h\\[dq]\n]\n\\f[R]\n.fi\n.PP\nCreate objects within objects; this works because if the first character\nof value is an open brace or a bracket we attempt to decode the\nremainder as JSON.\nBeware spaces in strings \\&...\n.IP\n.nf\n\\f[C]\n$ jo -p name=JP object=$(jo fruit=Orange hungry\\[at]0 point=$(jo x=10 y=20 list=$(jo -a 1 2 3 4 5)) number=17) sunday\\[at]0\n{\n \\[dq]name\\[dq]: \\[dq]JP\\[dq],\n \\[dq]object\\[dq]: {\n  \\[dq]fruit\\[dq]: \\[dq]Orange\\[dq],\n  \\[dq]hungry\\[dq]: false,\n  \\[dq]point\\[dq]: {\n   \\[dq]x\\[dq]: 10,\n   \\[dq]y\\[dq]: 20,\n   \\[dq]list\\[dq]: [\n    1,\n    2,\n    3,\n    4,\n    5\n   ]\n  },\n  \\[dq]number\\[dq]: 17\n },\n \\[dq]sunday\\[dq]: false\n}\n\\f[R]\n.fi\n.PP\nBooleans as strings or as boolean (pay particular attention to\n\\f[I]switch\\f[R]; the \\f[C]-B\\f[R] option disables the default detection\nof the \\[lq]\\f[C]true\\f[R]\\[rq], \\[lq]\\f[C]false\\f[R]\\[rq], and\n\\[lq]\\f[C]null\\f[R]\\[rq] strings):\n.IP\n.nf\n\\f[C]\n$ jo switch=true morning\\[at]0\n{\\[dq]switch\\[dq]:true,\\[dq]morning\\[dq]:false}\n\n$ jo -B switch=true morning\\[at]0\n{\\[dq]switch\\[dq]:\\[dq]true\\[dq],\\[dq]morning\\[dq]:false}\n\\f[R]\n.fi\n.PP\nElements (objects and arrays) can be nested.\nThe following example nests an array called \\f[I]point\\f[R] and an\nobject named \\f[I]geo\\f[R]:\n.IP\n.nf\n\\f[C]\n$ jo -p name=Jane point[]=1 point[]=2 geo[lat]=10 geo[lon]=20\n{\n   \\[dq]name\\[dq]: \\[dq]Jane\\[dq],\n   \\[dq]point\\[dq]: [\n      1,\n      2\n   ],\n   \\[dq]geo\\[dq]: {\n      \\[dq]lat\\[dq]: 10,\n      \\[dq]lon\\[dq]: 20\n   }\n}\n\\f[R]\n.fi\n.PP\nThe same example, using object paths:\n.IP\n.nf\n\\f[C]\n$ jo -p -d. name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20\n{\n   \\[dq]name\\[dq]: \\[dq]Jane\\[dq],\n   \\[dq]point\\[dq]: [\n      1,\n      2\n   ],\n   \\[dq]geo\\[dq]: {\n      \\[dq]lat\\[dq]: 10,\n      \\[dq]lon\\[dq]: 20\n   }\n}\n\\f[R]\n.fi\n.PP\nWithout \\f[C]-d\\f[R], a different object is generated:\n.IP\n.nf\n\\f[C]\n$ jo -p name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20\n{\n   \\[dq]name\\[dq]: \\[dq]Jane\\[dq],\n   \\[dq]point\\[dq]: [\n      1,\n      2\n   ],\n   \\[dq]geo.lat\\[dq]: 10,\n   \\[dq]geo.lon\\[dq]: 20\n}\n\\f[R]\n.fi\n.PP\nCreate empty objects or arrays, intentionally or potentially:\n.IP\n.nf\n\\f[C]\n$ jo < /dev/null\n{}\n\n$ MY_ARRAY=(a=1 b=2)\n$ jo -a \\[dq]${MY_ARRAY[\\[at]]}\\[dq] < /dev/null\n[\\[dq]a=1\\[dq],\\[dq]b=2\\[dq]]\n\\f[R]\n.fi\n.PP\nType coercion:\n.IP\n.nf\n\\f[C]\n$ jo -p -- -s a=true b=true -s c=123 d=123 -b e=\\[dq]1\\[dq] -b f=\\[dq]true\\[dq] -n g=\\[dq]This is a test\\[dq] -b h=\\[dq]This is a test\\[dq]\n{\n   \\[dq]a\\[dq]: \\[dq]true\\[dq],\n   \\[dq]b\\[dq]: true,\n   \\[dq]c\\[dq]: \\[dq]123\\[dq],\n   \\[dq]d\\[dq]: 123,\n   \\[dq]e\\[dq]: true,\n   \\[dq]f\\[dq]: true,\n   \\[dq]g\\[dq]: 14,\n   \\[dq]h\\[dq]: true\n}\n\n$ jo -a -- -s 123 -n \\[dq]This is a test\\[dq] -b C_Rocks 456\n[\\[dq]123\\[dq],14,true,456]\n\\f[R]\n.fi\n.PP\nRead element values from files: a value which starts with\n\\f[C]\\[at]\\f[R] is read in plain whereas if it begins with a \\f[C]%\\f[R]\nit will be base64-encoded and if it starts with \\f[C]:\\f[R] the contents\nare interpreted as JSON:\n.IP\n.nf\n\\f[C]\n$ jo program=jo authors=\\[at]AUTHORS\n{\\[dq]program\\[dq]:\\[dq]jo\\[dq],\\[dq]authors\\[dq]:\\[dq]Jan-Piet Mens <jpmens\\[at]gmail.com>\\[dq]}\n\n$ jo filename=AUTHORS content=%AUTHORS\n{\\[dq]filename\\[dq]:\\[dq]AUTHORS\\[dq],\\[dq]content\\[dq]:\\[dq]SmFuLVBpZXQgTWVucyA8anBtZW5zQGdtYWlsLmNvbT4K\\[dq]}\n\n$ jo nested=:nested.json\n{\\[dq]nested\\[dq]:{\\[dq]field1\\[dq]:123,\\[dq]field2\\[dq]:\\[dq]abc\\[dq]}}\n\\f[R]\n.fi\n.PP\nThese characters can be escaped to avoid interpretation:\n.IP\n.nf\n\\f[C]\n$ jo name=\\[dq]JP Mens\\[dq] twitter=\\[aq]\\[rs]\\[at]jpmens\\[aq]\n{\\[dq]name\\[dq]:\\[dq]JP Mens\\[dq],\\[dq]twitter\\[dq]:\\[dq]\\[at]jpmens\\[dq]}\n\n$ jo char=\\[dq] \\[dq] URIescape=\\[rs]\\[rs]%20\n{\\[dq]char\\[dq]:\\[dq] \\[dq],\\[dq]URIescape\\[dq]:\\[dq]%20\\[dq]}\n\n$ jo action=\\[dq]split window\\[dq] vimcmd=\\[dq]\\[rs]:split\\[dq]\n{\\[dq]action\\[dq]:\\[dq]split window\\[dq],\\[dq]vimcmd\\[dq]:\\[dq]:split\\[dq]}\n\\f[R]\n.fi\n.PP\nRead element values from a file in order to overcome ARG_MAX limits\nduring object assignment:\n.IP\n.nf\n\\f[C]\n$ ls | jo -a > child.json\n$ jo files:=child.json\n{\\[dq]files\\[dq]:[\\[dq]AUTHORS\\[dq],\\[dq]COPYING\\[dq],\\[dq]ChangeLog\\[dq] ....\n\n$ ls *.c | jo -a > source.json; ls *.h | jo -a > headers.json\n$ jo -a :source.json :headers.json\n[[\\[dq]base64.c\\[dq],\\[dq]jo.c\\[dq],\\[dq]json.c\\[dq]],[\\[dq]base64.h\\[dq],\\[dq]json.h\\[dq]]]\n\\f[R]\n.fi\n.PP\nAdd elements to existing JSON:\n.IP\n.nf\n\\f[C]\n$ jo -f source.json 1 | jo -f - 2 3\n[\\[dq]base64.c\\[dq],\\[dq]jo.c\\[dq],\\[dq]json.c\\[dq],1,2,3]\n\n$ curl -s \\[aq]https://noembed.com/embed?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ\\[aq] | jo -f - status=Rickrolled\n{ ...., \\[dq]type\\[dq]:\\[dq]video\\[dq],\\[dq]author_url\\[dq]:\\[dq]https://www.youtube.com/user/RickAstleyVEVO\\[dq],\\[dq]status\\[dq]:\\[dq]Rickrolled\\[dq]}\n\\f[R]\n.fi\n.PP\nDeduplicate object keys (\\f[I]jo\\f[R] appends duplicate object keys by\ndefault):\n.IP\n.nf\n\\f[C]\n$ jo a=1 b=2 a=3\n{\\[dq]a\\[dq]:1,\\[dq]b\\[dq]:2,\\[dq]a\\[dq]:3}\n$ jo -D a=1 b=2 a=3\n{\\[dq]a\\[dq]:3,\\[dq]b\\[dq]:2}\n\\f[R]\n.fi\n.SH OPTIONS\n.PP\n\\f[I]jo\\f[R] understands the following global options.\n.TP\n-a\nInterpret the list of \\f[I]words\\f[R] as array values and produce an\narray instead of an object.\n.TP\n-B\nBy default, \\f[I]jo\\f[R] interprets the strings \\[lq]\\f[C]true\\f[R]\\[rq]\nand \\[lq]\\f[C]false\\f[R]\\[rq] as boolean elements \\f[C]true\\f[R] and\n\\f[C]false\\f[R] respectively, and \\[lq]\\f[C]null\\f[R]\\[rq] as\n\\f[C]null\\f[R].\nDisable with this option.\n.TP\n-D\nDeduplicate object keys.\n.TP\n-e\nIgnore empty stdin (i.e.\\ don\\[cq]t produce a diagnostic error when\n\\f[I]stdin\\f[R] is empty)\n.TP\n-n\nDo not add keys with empty values.\n.TP\n-p\nPretty-print the JSON string on output instead of the terse one-line\noutput it prints by default.\n.TP\n-v\nShow version and exit.\n.TP\n-V\nShow version as a JSON object and exit.\n.SH BUGS\n.PP\nProbably.\n.PP\nIf a value given to \\f[I]jo\\f[R] expands to empty in the shell, then\n\\f[I]jo\\f[R] produces a \\f[C]null\\f[R] in object mode, and might appear\nto hang in array mode; it is not hanging, rather it\\[cq]s reading\n\\f[I]stdin\\f[R].\nThis is not a bug.\n.PP\nNumeric values are converted to numbers which can produce undesired\nresults.\nIf you quote a numeric value, \\f[I]jo\\f[R] will make it a string.\nCompare the following:\n.IP\n.nf\n\\f[C]\n$ jo a=1.0\n{\\[dq]a\\[dq]:1}\n$ jo a=\\[rs]\\[dq]1.0\\[rs]\\[dq]\n{\\[dq]a\\[dq]:\\[dq]1.0\\[dq]}\n\\f[R]\n.fi\n.PP\nOmitting a closing bracket on a nested element causes a diagnostic\nmessage to print, but the output contains garbage anyway.\nThis was designed thusly.\n.SH RETURN CODES\n.PP\n\\f[I]jo\\f[R] exits with a code 0 on success and non-zero on failure\nafter indicating what caused the failure.\n.SH AVAILABILITY\n.PP\n<http://github.com/jpmens/jo>\n.SH CREDITS\n.IP \\[bu] 2\nThis program uses \\f[C]json.[ch]\\f[R], by Joseph A.\nAdams.\n.SH SEE ALSO\n.IP \\[bu] 2\n<https://stedolan.github.io/jq/>\n.IP \\[bu] 2\n<https://github.com/micha/jsawk>\n.IP \\[bu] 2\n<https://github.com/jtopjian/jsed>\n.IP \\[bu] 2\nstrtod(3)\n.SH AUTHOR\n.PP\nJan-Piet Mens <http://jpmens.net>\n"
        },
        {
          "name": "jo.bash",
          "type": "blob",
          "size": 0.990234375,
          "content": "# bash completion for jo(1)\n\n_jo() {\n\n    # Don't split words on =, for =@ and =% handling\n    COMP_WORDBREAKS=${COMP_WORDBREAKS//=}\n\n    # No completion if an exit causing flag is around\n    local i\n    for i in ${!COMP_WORDS[@]}; do\n        [[ $i -ne $COMP_CWORD && ${COMP_WORDS[i]} == -*[hvV]* ]] && return 0\n    done\n\n    # Complete available options following a dash\n    if [[ $2 == -* ]]; then\n        COMPREPLY=( $(compgen -W '-a -B -h -p -v -V' -- \"$2\") )\n        return 0\n    fi\n\n    # Complete filenames on =@ and =%\n    if [[ $2 == *=[@%]* ]]; then\n        local file prefix\n        file=\"${2#*=[@%]}\"\n        prefix=\"${2:0:${#2}-${#file}}\"\n        compopt -o filenames\n        COMPREPLY=( $(compgen -f -- \"$file\") )\n        if [[ ${#COMPREPLY[@]} -eq 1 ]]; then\n            if [[ -d \"${COMPREPLY[0]}\" ]]; then\n                COMPREPLY[0]+=/\n                compopt -o nospace\n            fi\n            COMPREPLY[0]=\"$prefix${COMPREPLY[0]}\"\n        fi\n        return 0\n    fi\n\n} &&\ncomplete -F _jo jo\n"
        },
        {
          "name": "jo.c",
          "type": "blob",
          "size": 19.5771484375,
          "content": "#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#ifndef _AIX\n# include <getopt.h>\n#endif\n#include <ctype.h>\n#if !defined(WIN32) && !defined(_AIX)\n# include <err.h>\n#endif\n#include \"json.h\"\n#include \"base64.h\"\n\n/*\n * Copyright (C) 2016-2019 Jan-Piet Mens <jp@mens.de>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n#define SPACER\t\t\"   \"\n#define FLAG_ARRAY\t0x01\n#define FLAG_PRETTY\t0x02\n#define FLAG_NOBOOL\t0x04\n#define FLAG_BOOLEAN\t0x08\n#define FLAG_NOSTDIN\t0x10\n#define FLAG_SKIPNULLS\t0x20\n#define FLAG_MASK\t(FLAG_ARRAY | FLAG_PRETTY | FLAG_NOBOOL | FLAG_BOOLEAN | FLAG_NOSTDIN | FLAG_SKIPNULLS)\n\n/* Size of buffer blocks for pipe slurping */\n#define SLURP_BLOCK_SIZE 4096\n\nstatic JsonNode *pile;\t\t/* pile of nested objects/arrays */\n\n#if defined(_WIN32) || defined(_AIX)\n#include <errno.h>\n#include <stdarg.h>\nstatic inline void err(int eval, const char *fmt, ...) {\n\tint errnum = errno;\n\n\tva_list ap;\n\tva_start(ap, fmt);\n\n\tfprintf(stderr, \"jo: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \": %s\\n\", strerror(errnum));\n\n\tva_end(ap);\n\texit(eval);\n}\nstatic inline void errx(int eval, const char *fmt, ...) {\n\tva_list ap;\n\tva_start(ap, fmt);\n\n\tfprintf(stderr, \"jo: \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \"\\n\");\n\n\tva_end(ap);\n\texit(eval);\n}\n#endif\n\n#if defined(_WIN32) && !defined(fseeko)\n# define fseeko\tfseek\n# define ftello\tftell\n#endif\n\n#define TAG_TO_FLAGS(tag) ((FLAG_MASK + 1) * (tag))\n#define TAG_FLAG_BOOL     (TAG_TO_FLAGS(JSON_BOOL))\n#define TAG_FLAG_STRING   (TAG_TO_FLAGS(JSON_STRING))\n#define TAG_FLAG_NUMBER   (TAG_TO_FLAGS(JSON_NUMBER))\n#define COERCE_MASK       (TAG_FLAG_BOOL | TAG_FLAG_STRING | TAG_FLAG_NUMBER)\n\nJsonTag flags_to_tag(int flags) {\n\treturn flags / (FLAG_MASK + 1);\n}\n\nvoid json_copy_to_object(JsonNode * obj, JsonNode * object_or_array, int clobber)\n{\n\tJsonNode *node, *node_child, *obj_child;\n\n\tif (obj->tag != JSON_OBJECT && obj->tag != JSON_ARRAY)\n\t\treturn;\n\n\tjson_foreach(node, object_or_array) {\n\t\tif (!clobber & (json_find_member(obj, node->key) != NULL))\n\t\t\tcontinue;\t/* Don't clobber existing keys */\n\t\tif (obj->tag == JSON_OBJECT) {\n\t\t\tif (node->tag == JSON_STRING)\n\t\t\t\tjson_append_member(obj, node->key, json_mkstring(node->string_));\n\t\t\telse if (node->tag == JSON_NUMBER)\n\t\t\t\tjson_append_member(obj, node->key, json_mknumber(node->number_));\n\t\t\telse if (node->tag == JSON_BOOL)\n\t\t\t\tjson_append_member(obj, node->key, json_mkbool(node->bool_));\n\t\t\telse if (node->tag == JSON_NULL)\n\t\t\t\tjson_append_member(obj, node->key, json_mknull());\n\t\t\telse if (node->tag == JSON_OBJECT) {\n\t\t\t\t/* Deep-copy existing object to new object */\n\t\t\t\tjson_append_member(obj, node->key, (obj_child = json_mkobject()));\n\t\t\t\tjson_foreach(node_child, node) {\n\t\t\t\t\tjson_copy_to_object(obj_child, node_child, clobber);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tfprintf(stderr, \"PANIC: unhandled JSON type %d\\n\", node->tag);\n\t\t} else if (obj->tag == JSON_ARRAY) {\n\t\t\tif (node->tag == JSON_STRING)\n\t\t\t\tjson_append_element(obj, json_mkstring(node->string_));\n\t\t\tif (node->tag == JSON_NUMBER)\n\t\t\t\tjson_append_element(obj, json_mknumber(node->number_));\n\t\t\tif (node->tag == JSON_BOOL)\n\t\t\t\tjson_append_element(obj, json_mkbool(node->bool_));\n\t\t\tif (node->tag == JSON_NULL)\n\t\t\t\tjson_append_element(obj, json_mknull());\n\t\t}\n\t}\n}\n\nint slurp(FILE *fp, char **bufp, off_t bufblk_sz, int eos_char, size_t *out_len, bool fold_newlines)\n{\n\tchar *buf;\n\tint result = 0;\n\tsize_t i = 0;\n\tint ch = EOF;\n\tsize_t buffer_len = bufblk_sz;\n\n\tif ((buf = malloc(buffer_len)) == NULL) {\n\t\tresult = -1;\n\t} else {\n\t\twhile ((ch = fgetc(fp)) != eos_char && ch != EOF) {\n\t\t\tif (i == (buffer_len - 1)) {\n\t\t\t\tbuffer_len += bufblk_sz;\n\t\t\t\tif ((buf = realloc(buf, buffer_len)) == NULL) {\n\t\t\t\t\tresult = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ch != '\\n' || !fold_newlines) {\n\t\t\t\tbuf[i++] = ch;\n\t\t\t}\n\t\t}\n\t}\n\tif (result < 0) {\n\t\tfree(buf);\n\t\tbuf = NULL;\n\t} else {\n\t\tbuf[i] = 0;\n\t}\n\t*out_len = i;\n        *bufp = buf;\n\treturn result;\n}\n\nchar *slurp_file(const char* filename, size_t *out_len, bool fold_newlines)\n{\n\tchar *buf;\n\toff_t buffer_len;\n\tFILE *fp;\n\tbool use_stdin = strcmp(filename, \"-\") == 0;\n\n\tif (use_stdin) fp = stdin;\n\telse if ((fp = fopen(filename, \"r\")) == NULL) {\n\t\tperror(filename);\n\t\terrx(1, \"Cannot open %s for reading\", filename);\n\t}\n\tif (fseeko(fp, 0, SEEK_END) != 0) {\n\t\t/* If we cannot seek, we're operating off a pipe and\n\t\t   need to dynamically grow the buffer that we're\n\t\t   reading into */\n\t\tbuffer_len = SLURP_BLOCK_SIZE;\n\t} else {\n\t\tbuffer_len = ftello(fp) + 1;\n\t\tfseeko(fp, 0, SEEK_SET);\n\t}\n\n\tif (slurp(fp, &buf, buffer_len, EOF, out_len, fold_newlines) < 0) {\n\t\terrx(1, \"File %s is too large to be read into memory\", filename);\n\t}\n\tif (!use_stdin) fclose(fp);\n\treturn buf;\n}\n\nchar *slurp_line(FILE *fp, size_t *out_len)\n{\n\tchar *buf;\n\n\tif (slurp(fp, &buf, SLURP_BLOCK_SIZE, '\\n', out_len, false) < 0) {\n\t\terrx(1, \"Line too large to be read into memory\");\n\t}\n\treturn buf;\n}\n\nJsonNode *jo_mknull(JsonTag type) {\n\tswitch (type) {\n\t\tcase JSON_STRING:\n\t\t\treturn json_mkstring(\"\");\n\t\t\tbreak;\n\t\tcase JSON_NUMBER:\n\t\t\treturn json_mknumber(0);\n\t\t\tbreak;\n\t\tcase JSON_BOOL:\n\t\t\treturn json_mkbool(false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn json_mknull();\n\t\t\tbreak;\n\t}\n}\n\nJsonNode *jo_mkbool(bool b, JsonTag type) {\n\tswitch (type) {\n\t\tcase JSON_STRING:\n\t\t\treturn json_mkstring(b ? \"true\" : \"false\");\n\t\t\tbreak;\n\t\tcase JSON_NUMBER:\n\t\t\treturn json_mknumber(b ? 1 : 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn json_mkbool(b);\n\t\t\tbreak;\n\t}\n}\n\nJsonNode *jo_mkstring(char *str, JsonTag type) {\n\tswitch (type) {\n\t\tcase JSON_NUMBER:\n\t\t\t/* Length of string */\n\t\t\treturn json_mknumber(strlen(str));\n\t\t\tbreak;\n\t\tcase JSON_BOOL:\n\t\t\t/* True if not empty */\n\t\t\treturn json_mkbool(strlen(str) > 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn json_mkstring(str);\n\t\t\tbreak;\n\t}\n}\n\nJsonNode *jo_mknumber(char *str, JsonTag type) {\n\t/* ASSUMPTION: str already tested as valid number */\n\tdouble n = strtod(str, NULL);\n\n\tswitch (type) {\n\t\tcase JSON_STRING:\n\t\t\t/* Just return the original representation */\n\t\t\treturn json_mkstring(str);\n\t\t\tbreak;\n\t\tcase JSON_BOOL:\n\t\t\treturn json_mkbool(n != 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ASSUMPTION: str already tested as valid number */\n\t\t\treturn json_mknumber(n);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * Attempt to \"sniff\" the type of data in `str' and return\n * a JsonNode of the correct JSON type.\n */\n\nJsonNode *vnode(char *str, int flags)\n{\n\tJsonTag type = flags_to_tag(flags);\n\n\tif (strlen(str) == 0) {\n\t\treturn (flags & FLAG_SKIPNULLS) ? (JsonNode *)NULL : jo_mknull(type);\n\t}\n\n\t/* If str begins with a double quote, keep it a string */\n\n\tif (*str == '\"') {\n#if 0\n\t\tchar *bp = str + strlen(str) - 1;\n\n\t\tif (bp > str && *bp == '\"')\n\t\t\t*bp = 0;\t\t/* Chop closing double quote */\n\t\treturn json_mkstring(str + 1);\n#endif\n\t\treturn jo_mkstring(str, type);\n\t}\n\n\tchar *endptr;\n\tdouble num = strtod(str, &endptr);\n\n\tif (!*endptr && isfinite(num)) {\n\t\treturn jo_mknumber(str, type);\n\t}\n\n\tif (!(flags & FLAG_NOBOOL)) {\n\t\tif (strcmp(str, \"true\") == 0) {\n\t\t\treturn jo_mkbool(true, type);\n\t\t} else if (strcmp(str, \"false\") == 0) {\n\t\t\treturn jo_mkbool(false, type);\n\t\t} else if (strcmp(str, \"null\") == 0) {\n\t\t\treturn jo_mknull(type);\n\t\t}\n\t}\n\n\tif (*str == '\\\\') {\n\t\t++str;\n\t} else {\n\t\tif (*str == '@' || *str == '%' || *str == ':') {\n\t\t\tchar *filename = str + 1, *content;\n\t\t\tbool binmode = (*str == '%');\n\t\t\tbool jsonmode = (*str == ':');\n\t\t\tsize_t len = 0;\n\t\t\tJsonNode *j = NULL;\n\t\n\t\t\tif ((content = slurp_file(filename, &len, false)) == NULL) {\n\t\t\t\terrx(1, \"Error reading file %s\", filename);\n\t\t\t}\n\t\n\t\t\tif (binmode) {\n\t\t\t\tchar *encoded;\n\t\n\t\t\t\tif ((encoded = base64_encode(content, len)) == NULL) {\n\t\t\t\t\terrx(1, \"Cannot base64-encode file %s\", filename);\n\t\t\t\t}\n\t\n\t\t\t\tj = json_mkstring(encoded);\n\t\t\t\tfree(encoded);\n\t\t\t} else if (jsonmode) {\n\t\t\t\tj = json_decode(content);\n\t\t\t\tif (j == NULL) {\n\t\t\t\t\terrx(1, \"Cannot decode JSON in file %s\", filename);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// If it got this far without valid JSON, just consider it a string\n\t\t\tif (j == NULL) {\n\t\t\t\tchar *bp = content + strlen(content) - 1;\n\t\n\t\t\t\tif (*bp == '\\n') *bp-- = 0;\n\t\t\t\tif (*bp == '\\r') *bp = 0;\n\t\t\t\tj = json_mkstring(content);\n\t\t\t}\n\t\t\tfree(content);\n\t\t\treturn (j);\n\t\t}\n\t}\n\n\tif (*str == '{' || *str == '[') {\n\t\tif (type == JSON_STRING) {\n\t\t\treturn json_mkstring(str);\n\t\t}\n\t\tJsonNode *obj = json_decode(str);\n\n\t\tif (obj == NULL) {\n\t\t\t/* JSON cannot be decoded; return the string */\n\t\t\t// fprintf(stderr, \"Cannot decode JSON from %s\\n\", str);\n\n\t\t\tobj = json_mkstring(str);\n\t\t}\n\n\t\treturn (obj);\n\t}\n\n\treturn jo_mkstring(str, type);\n}\n\n/*\n * Attempt to sniff `str' into a boolean; return a\n * corresponding JsonNode for it.\n */\n\nJsonNode *boolnode(char *str)\n{\n\tif (strlen(str) == 0) {\n\t\treturn json_mknull();\n\t}\n\n\tif (tolower((unsigned char) *str) == 't') {\n\t\treturn json_mkbool(1);\n\t}\n\n\treturn json_mkbool(atoi(str));\n}\n\nint usage(char *prog)\n{\n\tfprintf(stderr, \"Usage: %s [-a] [-B] [-D] [-d keydelim] [-p] [-e] [-n] [-o outfile] [-v] [-V] [-f file] [--] [-s|-n|-b] [word...]\\n\", prog);\n\tfprintf(stderr, \"\\tword is key=value or key@value\\n\");\n\tfprintf(stderr, \"\\t-a creates an array of words\\n\");\n\tfprintf(stderr, \"\\t-B disable boolean true/false/null detection\\n\");\n\tfprintf(stderr, \"\\t-D deduplicate object keys\\n\");\n\tfprintf(stderr, \"\\t-d key will be object path separated by keydelim\\n\");\n\tfprintf(stderr, \"\\t-f load file as JSON object or array\\n\");\n\tfprintf(stderr, \"\\t-p pretty-prints JSON on output\\n\");\n\tfprintf(stderr, \"\\t-e quit if stdin is empty do not wait for input\\n\");\n\tfprintf(stderr, \"\\t-s coerce type guessing to string\\n\");\n\tfprintf(stderr, \"\\t-b coerce type guessing to bool\\n\");\n\tfprintf(stderr, \"\\t-n coerce type guessing to number\\n\");\n\tfprintf(stderr, \"\\t-o output to the given file\\n\");\n\tfprintf(stderr, \"\\t-v show version\\n\");\n\tfprintf(stderr, \"\\t-V show version in JSON\\n\");\n\n\treturn (-1);\n}\n\n/*\n * Check whether we're being given nested arrays or objects.\n * `kv' contains the \"key\" such as \"number\" or \"point[]\" or\n * \"geo[lat]\". `value' the actual value for that element.\n *\n * Returns true if nesting is completely handled, otherwise:\n *   *keyp   -> remaining key for caller to insert \"value\"\n *   *baseop -> object node in which caller should insert \"value\"\n */\n\nbool resolve_nested(int flags, char **keyp, char key_delim, JsonNode *value, JsonNode **baseop)\n{\n\tchar *member = NULL, *bo, *bc, *so;\t\t/* bracket open, close, sub-object */\n\tJsonNode *op;\n\tint found = false;\n\n\t(void)flags;\n\n\tif (key_delim) {\n\t\t/* First construct nested object */\n\t\twhile ((so = strchr(*keyp, key_delim)) != NULL) {\n\t\t\t*so = 0;\n\t\t\tif ((op = json_find_member(*baseop, *keyp)) == NULL) {\n\t\t\t\t/* Add a nested object node */\n\t\t\t\top = json_mkobject();\n\t\t\t\tjson_append_member(*baseop, *keyp, op);\n\t\t\t}\n\t\t\t*baseop = op;\n\t\t\t*keyp = so + 1;\n\t\t}\n\t}\n\n\t/* Now check for trailing geo[] or geo[lat] */\n\tif ((bo = strchr(*keyp, '[')) != NULL) {\n\t\tif (*(bo+1) == ']') {\n\t\t\t*bo = 0;\n\t\t} else if ((bc = strchr(bo + 1, ']')) == NULL) {\n\t\t\tfprintf(stderr, \"missing closing bracket on %s\\n\", *keyp);\n\t\t\treturn (false);\n\t\t} else {\n\t\t\t*bo = *bc = 0;\n\t\t\tmember = bo + 1;\n\t\t}\n\n\t\t/*\n\t\t * *keyp is now `geo' for both `geo[]` and `geo[lat]`\n\t\t * member is null for the former and \"lat\" for the latter.\n\t\t * Find an existing object in *baseop for this member name\n\t\t * or create a new one if we don't have it.\n\t\t */\n\n\t\tif ((op = json_find_member(*baseop, *keyp)) != NULL) {\n\t\t\tfound = true;\n\t\t} else {\n\t\t\top = (member == NULL) ? json_mkarray() : json_mkobject();\n\t\t}\n\n\t\tif (member == NULL) {\t\t/* we're doing an array */\n\t\t\tjson_append_element(op, value);\n\t\t} else {\t\t\t/* we're doing an object */\n\t\t\tjson_append_member(op, member, value);\n\t\t}\n\n\t\tif (!found) {\n\t\t\tjson_append_member(*baseop, *keyp, op);\n\t\t}\n\n\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nint member_to_object(JsonNode *object, int flags, char key_delim, char *kv)\n{\n\t/* we expect key=value or key:value (boolean on last) */\n\tchar *p = strchr(kv, '=');\n\tchar *q = strchr(kv, '@');\n\tchar *r = strchr(kv, ':');\n\n\tif ((r && *(r+1) == '=') && !q) {\n\t\tchar *filename = p + 1;\n\t\tchar *content;\n\t\tsize_t len;\n\n\t\tif ((content = slurp_file(filename, &len, false)) == NULL) {\n\t\t\terrx(1, \"Error reading file %s\", filename);\n\t\t}\n\n\t\tJsonNode *o = json_decode(content);\n\t\tfree(content);\n\n\t\tif (o == NULL) {\n\t\t\terrx(1, \"Cannot decode JSON in file %s\", filename);\n\t\t}\n\n\t\t*r = 0;\t\t/* Chop at \":=\" */\n\t\tif (!resolve_nested(flags, &kv, key_delim, o, &object))\n\t\t\tjson_append_member(object, kv, o);\n\t\treturn (0);\n\t}\n\n\tif (!p && !q && !r) {\n\t\treturn (-1);\n\t}\n\n\tJsonNode *val;\n\tif (p) {\n\t\t*p = 0;\n\t\tval = vnode(p+1, flags);\n\n\t\tif (!resolve_nested(flags, &kv, key_delim, val, &object))\n\t\t\tjson_append_member(object, kv, val);\n\t} else {\n\t\tif (q) {\n\t\t\t*q = 0;\n\t\t\tval = boolnode(q+1);\n\n\t\t\tif (!resolve_nested(flags | FLAG_BOOLEAN, &kv, key_delim, val, &object))\n\t\t\t\tjson_append_member(object, kv, val);\n\t\t}\n\t}\n\treturn (0);\n}\n\n/*\n * Append kv to the array or object.\n */\n\nvoid append_kv(JsonNode *object_or_array, int flags, char key_delim, char *kv)\n{\n\tif (flags & FLAG_ARRAY) {\n\t\tjson_append_element(object_or_array, vnode(kv, flags));\n\t} else {\n\t\tif (member_to_object(object_or_array, flags, key_delim, kv) == -1) {\n\t\t\tfprintf(stderr, \"Argument `%s' is neither k=v nor k@v\\n\", kv);\n\t\t}\n\t}\n}\n\n#ifdef _WIN32\n#include <windows.h>\nchar* utf8_from_locale(const char *str, size_t len)\n{\n\twchar_t* wcsp;\n\tchar* mbsp;\n\tsize_t mbssize, wcssize;\n\n\tif (len == 0) {\n\t\treturn strdup(\"\");\n\t}\n\tif (len == (size_t)-1) {\n\t\tlen = strlen(str);\n\t}\n\twcssize = MultiByteToWideChar(GetACP(), 0, str, len,  NULL, 0);\n\twcsp = (wchar_t*) malloc((wcssize + 1) * sizeof(wchar_t));\n\tif (!wcsp) {\n\t\treturn NULL;\n\t}\n\twcssize = MultiByteToWideChar(GetACP(), 0, str, len, wcsp, wcssize + 1);\n\twcsp[wcssize] = 0;\n\n\tmbssize = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR) wcsp, -1, NULL, 0, NULL, NULL);\n\tmbsp = (char*) malloc((mbssize + 1));\n\tif (!mbsp) {\n\t\tfree(wcsp);\n\t\treturn NULL;\n\t}\n\tmbssize = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR) wcsp, -1, mbsp, mbssize, NULL, NULL);\n\tmbsp[mbssize] = 0;\n\tfree(wcsp);\n\treturn mbsp;\n}\n# define utf8_free(p) free(p)\n\nchar* locale_from_utf8(const char *utf8, size_t len)\n{\n\twchar_t* wcsp;\n\tchar* mbsp;\n\tsize_t mbssize, wcssize;\n\n\tif (len == 0) {\n\t\treturn strdup(\"\");\n\t}\n\tif (len == (size_t)-1) {\n\t\tlen = strlen(utf8);\n\t}\n\twcssize = MultiByteToWideChar(CP_UTF8, 0, utf8, len,  NULL, 0);\n\twcsp = (wchar_t*) malloc((wcssize + 1) * sizeof(wchar_t));\n\tif (!wcsp) {\n\t\treturn NULL;\n\t}\n\twcssize = MultiByteToWideChar(CP_UTF8, 0, utf8, len, wcsp, wcssize + 1);\n\twcsp[wcssize] = 0;\n\tmbssize = WideCharToMultiByte(GetACP(), 0, (LPCWSTR) wcsp, -1, NULL, 0, NULL, NULL);\n\tmbsp = (char*) malloc((mbssize + 1));\n\tif (!mbsp) {\n\t\tfree(wcsp);\n\t\treturn NULL;\n\t}\n\tmbssize = WideCharToMultiByte(GetACP(), 0, (LPCWSTR) wcsp, -1, mbsp, mbssize, NULL, NULL);\n\tmbsp[mbssize] = 0;\n\tfree(wcsp);\n\treturn mbsp;\n}\n# define locale_free(p) free(p)\n#else\n# define utf8_from_locale(p, l) (p)\n# define utf8_free(p) do {} while (0)\n# define locale_from_utf8(p, l) (p)\n# define locale_free(p) do {} while (0)\n#endif\n\nchar *stringify(JsonNode *json, int flags)\n{\n\tint pretty = flags & FLAG_PRETTY;\n\n\treturn json_stringify(json, (pretty) ? SPACER : NULL);\n}\n\nint version(int flags)\n{\n\tJsonNode *json = json_mkobject();\n\tchar *js;\n\n\tjson_append_member(json, \"program\", json_mkstring(\"jo\"));\n\tjson_append_member(json, \"author\", json_mkstring(\"Jan-Piet Mens\"));\n\tjson_append_member(json, \"repo\", json_mkstring(\"https://github.com/jpmens/jo\"));\n\tjson_append_member(json, \"version\", json_mkstring(PACKAGE_VERSION));\n\n\tif ((js = stringify(json, flags)) != NULL) {\n\t\tprintf(\"%s\\n\", js);\n\t\tfree(js);\n\t}\n\tjson_delete(json);\n\treturn (0);\n}\n\nint main(int argc, char **argv)\n{\n\tint c, key_delim = 0;\n\tbool showversion = false;\n\tchar *kv, *js_string, *progname, *buf, *p;\n\tchar *in_file = NULL, *in_str;\n\tchar *out_file = NULL;\n\tFILE *out = stdout;\n\tsize_t in_len = 0;\n\tint ttyin = isatty(fileno(stdin));\n\tint ttyout = isatty(fileno(stdout));\n\tint flags = 0;\n\tJsonNode *json, *op;\n\n#if HAVE_PLEDGE\n\tif (pledge(\"stdio rpath\", NULL) == -1) {\n\t\terr(1, \"pledge\");\n\t}\n#endif\n\n\tprogname = (progname = strrchr(*argv, '/')) ? progname + 1 : *argv;\n\n\twhile ((c = getopt(argc, argv, \"aBDd:f:hpeno:vV\")) != EOF) {\n\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\t\tflags |= FLAG_ARRAY;\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tflags |= FLAG_NOBOOL;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tjson_dedup_members(true);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tkey_delim = optarg[0];\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tin_file = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tusage(progname);\n\t\t\t\treturn (0);\n\t\t\tcase 'p':\n\t\t\t\tflags |= FLAG_PRETTY;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tflags |= FLAG_NOSTDIN;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tflags |= FLAG_SKIPNULLS;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tout_file = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tprintf(\"jo %s\\n\", PACKAGE_VERSION);\n\t\t\t\texit(0);\n\t\t\tcase 'V':\n\t\t\t\tshowversion = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\texit(usage(progname));\n\t\t}\n\t}\n\n\tif (showversion) {\n\t\treturn(version(flags));\n\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tpile = json_mkobject();\n\tif (in_file != NULL) {\n\t\tif ((in_str = slurp_file(in_file, &in_len, false)) == NULL) {\n\t\t\terrx(1, \"Error reading file %s\", in_file);\n\t\t}\n\t\tjson = json_decode(in_str);\n\t\tif (json) {\n\t\t\tswitch (json->tag) {\n\t\t\t\tcase JSON_ARRAY:\n\t\t\t\t\tflags |= FLAG_ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase JSON_OBJECT:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terrx(1, \"Input JSON not an array or object: %s\", stringify(json, flags));\n\t\t\t}\n\t\t} else\n\t\t\tjson = (flags & FLAG_ARRAY) ? json_mkarray() : json_mkobject();\n\t} else {\n\t\tjson = (flags & FLAG_ARRAY) ? json_mkarray() : json_mkobject();\n\t}\n\n\tif (argc == 0) {\n\t\tif (flags & FLAG_NOSTDIN) {\n\t\t\treturn(0);\n\t\t}\n\t\twhile ((buf = slurp_line(stdin, &in_len)) != NULL && in_len > 0) {\n\t\t\tp = ttyin ? utf8_from_locale(buf, -1) : buf;\n\t\t\tappend_kv(json, flags, key_delim, p);\n\t\t\tif (ttyin) utf8_free(p);\n\t\t\tif (buf) free(buf);\n\t\t}\n\t} else {\n\t\twhile ((kv = *argv++)) {\n\t\t\tif (kv[0] == '-' && !(flags & COERCE_MASK)) {\n\t\t\t\t/* Set one-shot coerce flag */\n\t\t\t\tswitch (kv[1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tflags |= TAG_FLAG_BOOL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tflags |= TAG_FLAG_STRING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\tflags |= TAG_FLAG_NUMBER;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* Treat as normal input */\n\t\t\t\t\t\tp = utf8_from_locale(kv, -1);\n\t\t\t\t\t\tappend_kv(json, flags, key_delim, p);\n\t\t\t\t\t\tutf8_free(p);\n\t\t\t\t\t\t/* Reset any one-shot coerce flags */\n\t\t\t\t\t\tflags &= ~(COERCE_MASK);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tp = utf8_from_locale(kv, -1);\n\t\t\t\tappend_kv(json, flags, key_delim, p);\n\t\t\t\tutf8_free(p);\n\t\t\t\t/* Reset any one-shot coerce flags */\n\t\t\t\tflags &= ~(COERCE_MASK);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * See if we have any nested objects or arrays in the pile,\n\t * and copy these into our main object if so.\n\t */\n\n\tjson_foreach(op, pile) {\n\t\tJsonNode *o;\n\n\t\tif (op->tag == JSON_ARRAY) {\n\t\t\to = json_mkarray();\n\t\t} else if (op->tag == JSON_OBJECT) {\n\t\t\to = json_mkobject();\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tjson_copy_to_object(o, op, 0);\n\t\tjson_append_member(json, op->key, o);\n\t}\n\n\n\tif ((js_string = stringify(json, flags)) == NULL) {\n\t\tfprintf(stderr, \"Invalid JSON\\n\");\n\t\texit(2);\n\t}\n\n\tif (out_file != NULL) {\n\t\tout = fopen(out_file, \"w\");\n\t\tif (out == NULL) {\n\t\t\tperror(out_file);\n\t\t\terrx(1, \"Cannot open %s for writing\", out_file);\n\t\t}\n\t\tttyout = isatty(fileno(out));\n\t}\n\tp = ttyout ? locale_from_utf8(js_string, -1) : js_string;\n\tfprintf(out, \"%s\\n\", p);\n\tif (ttyout) locale_free(p);\n\tfree(js_string);\n\tjson_delete(json);\n\tjson_delete(pile);\n\treturn (0);\n}\n"
        },
        {
          "name": "jo.md",
          "type": "blob",
          "size": 9.6298828125,
          "content": "# NAME\n\njo - JSON output from a shell\n\n# SYNOPSIS\n\njo \\[-p\\] \\[-a\\] \\[-B\\] \\[-D\\] \\[-e\\] \\[-n\\] \\[-v\\] \\[-V\\] \\[-d\nkeydelim\\] \\[-f file\\] \\[--\\] \\[ \\[-s|-n|-b\\] word ...\\]\n\n# DESCRIPTION\n\n*jo* creates a JSON string on *stdout* from *word*s given it as\narguments or read from *stdin*. If `-f` is specified, *jo* first loads\nthe contents of *file* as a JSON object or array, then modifies it with\nsubsequent *word*s before printing the final JSON string to *stdout*.\n*file* may be specified as `-` to read from *jo*'s standard input; this\ntakes precedence over reading *word*s from *stdin*.\n\nWithout option `-a` it generates an object whereby each *word* is a\n`key=value` (or `key@value`) pair with *key* being the JSON object\nelement and *value* its value. *jo* attempts to guess the type of\n*value* in order to create number (using *strtod(3)*), string, or null\nvalues in JSON.\n\nA missing or empty *value* normally results in an element whose value is\n`null`. If `-n` is specified, this element is not created.\n\n*jo* normally treats *key* as a literal string value. If the `-d` option\nis specified, *key* will be interpreted as an *object path*, whose\nindividual components are separated by the first character of\n*keydelim*.\n\n*jo* normally treats *value* as a literal string value, unless it begins\nwith one of the following characters:\n\n| value | action                                                              |\n| ----- | ------------------------------------------------------------------- |\n| @file | substitute the contents of *file* as-is                             |\n| %file | substitute the contents of *file* in base64-encoded form            |\n| :file | interpret the contents of *file* as JSON, and substitute the result |\n\nEscape the special character with a backslash to prevent this\ninterpretation.\n\n*jo* treats `key@value` specifically as boolean JSON elements: if the\nvalue begins with `T`, `t`, or the numeric value is greater than zero,\nthe result is `true`, else `false`.\n\n*jo* creates an array instead of an object when `-a` is specified.\n\nWhen the `:=` operator is used in a *word*, the name to the right of\n`:=` is a file containing JSON which is parsed and assigned to the key\nleft of the operator. The file may be specified as `-` to read from\n*jo*'s standard input.\n\n# TYPE COERCION\n\n*jo*'s type guesses can be overridden on a per-word basis by prefixing\n*word* with `-s` for *string*, `-n` for *number*, or `-b` for *boolean*.\nThe list of *word*s *must* be prefixed with `--`, to indicate to *jo*\nthat there are no more global options.\n\nType coercion works as follows:\n\n| word       | \\-s            | \\-n       | \\-b       | default        |\n| :--------- | :------------- | :-------- | :-------- | :------------- |\n| a=         | \"a\":\"\"         | \"a\":0     | \"a\":false | \"a\":null       |\n| a=string   | \"a\":\"string\"   | \"a\":6     | \"a\":true  | \"a\":\"string\"   |\n| a=\"quoted\" | \"a\":\"\"quoted\"\" | \"a\":8     | \"a\":true  | \"a\":\"\"quoted\"\" |\n| a=12345    | \"a\":\"12345\"    | \"a\":12345 | \"a\":true  | \"a\":12345      |\n| a=true     | \"a\":\"true\"     | \"a\":1     | \"a\":true  | \"a\":true       |\n| a=false    | \"a\":\"false\"    | \"a\":0     | \"a\":false | \"a\":false      |\n| a=null     | \"a\":\"\"         | \"a\":0     | \"a\":false | \"a\":null       |\n\nCoercing a non-number string to number outputs the *length* of the\nstring.\n\nCoercing a non-boolean string to boolean outputs `false` if the string\nis empty, `true` otherwise.\n\nType coercion only applies to `key=value` words, and individual words in\na `-a` array. Coercing other words has no effect.\n\n# EXAMPLES\n\nCreate an object. Note how the incorrectly-formatted float value becomes\na string:\n\n    $ jo tst=1457081292 lat=12.3456 cc=FR badfloat=3.14159.26 name=\"JP Mens\" nada= coffee@T\n    {\"tst\":1457081292,\"lat\":12.3456,\"cc\":\"FR\",\"badfloat\":\"3.14159.26\",\"name\":\"JP Mens\",\"nada\":null,\"coffee\":true}\n\nPretty-print an array with a list of files in the current directory:\n\n    $ jo -p -a *\n    [\n     \"Makefile\",\n     \"README.md\",\n     \"jo.1\",\n     \"jo.c\",\n     \"jo.pandoc\",\n     \"json.c\",\n     \"json.h\"\n    ]\n\nCreate objects within objects; this works because if the first character\nof value is an open brace or a bracket we attempt to decode the\nremainder as JSON. Beware spaces in strings ...\n\n    $ jo -p name=JP object=$(jo fruit=Orange hungry@0 point=$(jo x=10 y=20 list=$(jo -a 1 2 3 4 5)) number=17) sunday@0\n    {\n     \"name\": \"JP\",\n     \"object\": {\n      \"fruit\": \"Orange\",\n      \"hungry\": false,\n      \"point\": {\n       \"x\": 10,\n       \"y\": 20,\n       \"list\": [\n        1,\n        2,\n        3,\n        4,\n        5\n       ]\n      },\n      \"number\": 17\n     },\n     \"sunday\": false\n    }\n\nBooleans as strings or as boolean (pay particular attention to *switch*;\nthe `-B` option disables the default detection of the \"`true`\",\n\"`false`\", and \"`null`\" strings):\n\n    $ jo switch=true morning@0\n    {\"switch\":true,\"morning\":false}\n    \n    $ jo -B switch=true morning@0\n    {\"switch\":\"true\",\"morning\":false}\n\nElements (objects and arrays) can be nested. The following example nests\nan array called *point* and an object named *geo*:\n\n    $ jo -p name=Jane point[]=1 point[]=2 geo[lat]=10 geo[lon]=20\n    {\n       \"name\": \"Jane\",\n       \"point\": [\n          1,\n          2\n       ],\n       \"geo\": {\n          \"lat\": 10,\n          \"lon\": 20\n       }\n    }\n\nThe same example, using object paths:\n\n    $ jo -p -d. name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20\n    {\n       \"name\": \"Jane\",\n       \"point\": [\n          1,\n          2\n       ],\n       \"geo\": {\n          \"lat\": 10,\n          \"lon\": 20\n       }\n    }\n\nWithout `-d`, a different object is generated:\n\n    $ jo -p name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20\n    {\n       \"name\": \"Jane\",\n       \"point\": [\n          1,\n          2\n       ],\n       \"geo.lat\": 10,\n       \"geo.lon\": 20\n    }\n\nCreate empty objects or arrays, intentionally or potentially:\n\n    $ jo < /dev/null\n    {}\n    \n    $ MY_ARRAY=(a=1 b=2)\n    $ jo -a \"${MY_ARRAY[@]}\" < /dev/null\n    [\"a=1\",\"b=2\"]\n\nType coercion:\n\n    $ jo -p -- -s a=true b=true -s c=123 d=123 -b e=\"1\" -b f=\"true\" -n g=\"This is a test\" -b h=\"This is a test\"\n    {\n       \"a\": \"true\",\n       \"b\": true,\n       \"c\": \"123\",\n       \"d\": 123,\n       \"e\": true,\n       \"f\": true,\n       \"g\": 14,\n       \"h\": true\n    }\n    \n    $ jo -a -- -s 123 -n \"This is a test\" -b C_Rocks 456\n    [\"123\",14,true,456]\n\nRead element values from files: a value which starts with `@` is read in\nplain whereas if it begins with a `%` it will be base64-encoded and if\nit starts with `:` the contents are interpreted as JSON:\n\n    $ jo program=jo authors=@AUTHORS\n    {\"program\":\"jo\",\"authors\":\"Jan-Piet Mens <jpmens@gmail.com>\"}\n    \n    $ jo filename=AUTHORS content=%AUTHORS\n    {\"filename\":\"AUTHORS\",\"content\":\"SmFuLVBpZXQgTWVucyA8anBtZW5zQGdtYWlsLmNvbT4K\"}\n    \n    $ jo nested=:nested.json\n    {\"nested\":{\"field1\":123,\"field2\":\"abc\"}}\n\nThese characters can be escaped to avoid interpretation:\n\n    $ jo name=\"JP Mens\" twitter='\\@jpmens'\n    {\"name\":\"JP Mens\",\"twitter\":\"@jpmens\"}\n    \n    $ jo char=\" \" URIescape=\\\\%20\n    {\"char\":\" \",\"URIescape\":\"%20\"}\n    \n    $ jo action=\"split window\" vimcmd=\"\\:split\"\n    {\"action\":\"split window\",\"vimcmd\":\":split\"}\n\nRead element values from a file in order to overcome ARG\\_MAX limits\nduring object assignment:\n\n    $ ls | jo -a > child.json\n    $ jo files:=child.json\n    {\"files\":[\"AUTHORS\",\"COPYING\",\"ChangeLog\" ....\n    \n    $ ls *.c | jo -a > source.json; ls *.h | jo -a > headers.json\n    $ jo -a :source.json :headers.json\n    [[\"base64.c\",\"jo.c\",\"json.c\"],[\"base64.h\",\"json.h\"]]\n\nAdd elements to existing JSON:\n\n    $ jo -f source.json 1 | jo -f - 2 3\n    [\"base64.c\",\"jo.c\",\"json.c\",1,2,3]\n    \n    $ curl -s 'https://noembed.com/embed?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ' | jo -f - status=Rickrolled\n    { ...., \"type\":\"video\",\"author_url\":\"https://www.youtube.com/user/RickAstleyVEVO\",\"status\":\"Rickrolled\"}\n\nDeduplicate object keys (*jo* appends duplicate object keys by default):\n\n    $ jo a=1 b=2 a=3\n    {\"a\":1,\"b\":2,\"a\":3}\n    $ jo -D a=1 b=2 a=3\n    {\"a\":3,\"b\":2}\n\n# OPTIONS\n\n*jo* understands the following global options.\n\n  - \\-a  \n    Interpret the list of *words* as array values and produce an array\n    instead of an object.\n  - \\-B  \n    By default, *jo* interprets the strings \"`true`\" and \"`false`\" as\n    boolean elements `true` and `false` respectively, and \"`null`\" as\n    `null`. Disable with this option.\n  - \\-D  \n    Deduplicate object keys.\n  - \\-e  \n    Ignore empty stdin (i.e. don't produce a diagnostic error when\n    *stdin* is empty)\n  - \\-n  \n    Do not add keys with empty values.\n  - \\-p  \n    Pretty-print the JSON string on output instead of the terse one-line\n    output it prints by default.\n  - \\-v  \n    Show version and exit.\n  - \\-V  \n    Show version as a JSON object and exit.\n\n# BUGS\n\nProbably.\n\nIf a value given to *jo* expands to empty in the shell, then *jo*\nproduces a `null` in object mode, and might appear to hang in array\nmode; it is not hanging, rather it's reading *stdin*. This is not a bug.\n\nNumeric values are converted to numbers which can produce undesired\nresults. If you quote a numeric value, *jo* will make it a string.\nCompare the following:\n\n    $ jo a=1.0\n    {\"a\":1}\n    $ jo a=\\\"1.0\\\"\n    {\"a\":\"1.0\"}\n\nOmitting a closing bracket on a nested element causes a diagnostic\nmessage to print, but the output contains garbage anyway. This was\ndesigned thusly.\n\n# RETURN CODES\n\n*jo* exits with a code 0 on success and non-zero on failure after\nindicating what caused the failure.\n\n# AVAILABILITY\n\n<http://github.com/jpmens/jo>\n\n# CREDITS\n\n  - This program uses `json.[ch]`, by Joseph A. Adams.\n\n# SEE ALSO\n\n  - <https://stedolan.github.io/jq/>\n  - <https://github.com/micha/jsawk>\n  - <https://github.com/jtopjian/jsed>\n  - strtod(3)\n\n# AUTHOR\n\nJan-Piet Mens <http://jpmens.net>\n"
        },
        {
          "name": "jo.pandoc",
          "type": "blob",
          "size": 8.919921875,
          "content": "% JO(1) User Manuals\n\n# NAME\n\njo - JSON output from a shell\n\n# SYNOPSIS\n\njo [-p] [-a] [-B] [-D] [-e] [-n] [-v] [-V] [-d keydelim] [-f file] [--] [ [-s|-n|-b] word ...]\n\n# DESCRIPTION\n\n*jo* creates a JSON string on _stdout_ from *word*s given it as arguments or read from _stdin_.\nIf `-f` is specified, *jo* first loads the contents of _file_ as a JSON object or array, then\nmodifies it with subsequent *word*s before printing the final JSON string to _stdout_.\n_file_ may be specified as `-` to read from _jo_'s standard input; this takes precedence over\nreading *word*s from _stdin_.\n\nWithout option `-a` it generates an object whereby each _word_ is a `key=value` (or `key@value`)\npair with _key_ being the JSON object element and _value_ its value. *jo* attempts to\nguess the type of _value_ in order to create number (using _strtod(3)_), string, or null values in JSON.\n\nA missing or empty _value_ normally results in an element whose value is `null`. If `-n` is specified, this\nelement is not created.\n\n*jo* normally treats _key_ as a literal string value. If the `-d` option is specified, _key_ will be\ninterpreted as an _object path_, whose individual components are separated by the first character of _keydelim_.\n\n*jo* normally treats _value_ as a literal string value, unless it begins with one of the following characters:\n\nvalue action\n----- ------\n@file substitute the contents of _file_ as-is\n%file substitute the contents of _file_ in base64-encoded form\n:file interpret the contents of _file_ as JSON, and substitute the result\n\nEscape the special character with a backslash to prevent this interpretation.\n\n*jo* treats `key@value` specifically as boolean JSON elements: if the value begins with `T`, `t`,\nor the numeric value is greater than zero, the result is `true`, else `false`.\n\n*jo* creates an array instead of an object when `-a` is specified.\n\nWhen the `:=` operator is used in a _word_, the name to the right of `:=` is a file containing JSON which is parsed and assigned to the key left of the operator. The file may be specified as `-` to read from _jo_'s standard input.\n\n\n# TYPE COERCION\n\n*jo*'s type guesses can be overridden on a per-word basis by prefixing _word_ with `-s` for _string_,\n`-n` for _number_, or `-b` for _boolean_. The list of *word*s *must* be prefixed with `--`, to indicate\nto *jo* that there are no more global options.\n\nType coercion works as follows:\n\nword         -s               -n           -b        default\n------------ ---------------- ------------ --------- ----------------\na=           \"a\":\"\"           \"a\":0        \"a\":false \"a\":null\na=string     \"a\":\"string\"     \"a\":6        \"a\":true  \"a\":\"string\"\na=\\\"quoted\\\" \"a\":\"\\\"quoted\\\"\" \"a\":8        \"a\":true  \"a\":\"\\\"quoted\\\"\"\na=12345      \"a\":\"12345\"      \"a\":12345    \"a\":true  \"a\":12345\na=true       \"a\":\"true\"       \"a\":1        \"a\":true  \"a\":true\na=false      \"a\":\"false\"      \"a\":0        \"a\":false \"a\":false\na=null       \"a\":\"\"           \"a\":0        \"a\":false \"a\":null\n\nCoercing a non-number string to number outputs the _length_ of the string.\n\nCoercing a non-boolean string to boolean outputs `false` if the string is empty, `true` otherwise.\n\nType coercion only applies to `key=value` words, and individual words in a `-a` array.\nCoercing other words has no effect.\n\n# EXAMPLES\n\nCreate an object. Note how the incorrectly-formatted float value becomes a string:\n\n\t$ jo tst=1457081292 lat=12.3456 cc=FR badfloat=3.14159.26 name=\"JP Mens\" nada= coffee@T\n\t{\"tst\":1457081292,\"lat\":12.3456,\"cc\":\"FR\",\"badfloat\":\"3.14159.26\",\"name\":\"JP Mens\",\"nada\":null,\"coffee\":true}\n\nPretty-print an array with a list of files in the current directory:\n\n\t$ jo -p -a *\n\t[\n\t \"Makefile\",\n\t \"README.md\",\n\t \"jo.1\",\n\t \"jo.c\",\n\t \"jo.pandoc\",\n\t \"json.c\",\n\t \"json.h\"\n\t]\n\nCreate objects within objects; this works because if the first character of value is an open brace or a bracket we attempt to decode the remainder as JSON. Beware spaces in strings ...\n\n\t$ jo -p name=JP object=$(jo fruit=Orange hungry@0 point=$(jo x=10 y=20 list=$(jo -a 1 2 3 4 5)) number=17) sunday@0\n\t{\n\t \"name\": \"JP\",\n\t \"object\": {\n\t  \"fruit\": \"Orange\",\n\t  \"hungry\": false,\n\t  \"point\": {\n\t   \"x\": 10,\n\t   \"y\": 20,\n\t   \"list\": [\n\t    1,\n\t    2,\n\t    3,\n\t    4,\n\t    5\n\t   ]\n\t  },\n\t  \"number\": 17\n\t },\n\t \"sunday\": false\n\t}\n\nBooleans as strings or as boolean (pay particular attention to _switch_; the `-B` option disables the default detection of the \"`true`\", \"`false`\", and \"`null`\" strings):\n\n\t$ jo switch=true morning@0\n\t{\"switch\":true,\"morning\":false}\n\n\t$ jo -B switch=true morning@0\n\t{\"switch\":\"true\",\"morning\":false}\n\nElements (objects and arrays) can be nested. The following example nests an array called _point_ and an object named _geo_:\n\n\t$ jo -p name=Jane point[]=1 point[]=2 geo[lat]=10 geo[lon]=20\n\t{\n\t   \"name\": \"Jane\",\n\t   \"point\": [\n\t      1,\n\t      2\n\t   ],\n\t   \"geo\": {\n\t      \"lat\": 10,\n\t      \"lon\": 20\n\t   }\n\t}\n\nThe same example, using object paths:\n\n\t$ jo -p -d. name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20\n\t{\n\t   \"name\": \"Jane\",\n\t   \"point\": [\n\t      1,\n\t      2\n\t   ],\n\t   \"geo\": {\n\t      \"lat\": 10,\n\t      \"lon\": 20\n\t   }\n\t}\n\nWithout `-d`, a different object is generated:\n\n\t$ jo -p name=Jane point[]=1 point[]=2 geo.lat=10 geo.lon=20\n\t{\n\t   \"name\": \"Jane\",\n\t   \"point\": [\n\t      1,\n\t      2\n\t   ],\n\t   \"geo.lat\": 10,\n\t   \"geo.lon\": 20\n\t}\n\nCreate empty objects or arrays, intentionally or potentially:\n\n\t$ jo < /dev/null\n\t{}\n\n\t$ MY_ARRAY=(a=1 b=2)\n\t$ jo -a \"${MY_ARRAY[@]}\" < /dev/null\n\t[\"a=1\",\"b=2\"]\n\n\nType coercion:\n\n\t$ jo -p -- -s a=true b=true -s c=123 d=123 -b e=\"1\" -b f=\"true\" -n g=\"This is a test\" -b h=\"This is a test\"\n\t{\n\t   \"a\": \"true\",\n\t   \"b\": true,\n\t   \"c\": \"123\",\n\t   \"d\": 123,\n\t   \"e\": true,\n\t   \"f\": true,\n\t   \"g\": 14,\n\t   \"h\": true\n\t}\n\n\t$ jo -a -- -s 123 -n \"This is a test\" -b C_Rocks 456\n\t[\"123\",14,true,456]\n\nRead element values from files: a value which starts with `@` is read in plain whereas if it begins with a `%` it will be base64-encoded and if it starts with `:` the contents are interpreted as JSON:\n\n\t$ jo program=jo authors=@AUTHORS\n\t{\"program\":\"jo\",\"authors\":\"Jan-Piet Mens <jpmens@gmail.com>\"}\n\n\t$ jo filename=AUTHORS content=%AUTHORS\n\t{\"filename\":\"AUTHORS\",\"content\":\"SmFuLVBpZXQgTWVucyA8anBtZW5zQGdtYWlsLmNvbT4K\"}\n\n\t$ jo nested=:nested.json\n\t{\"nested\":{\"field1\":123,\"field2\":\"abc\"}}\n\nThese characters can be escaped to avoid interpretation:\n\n\t$ jo name=\"JP Mens\" twitter='\\@jpmens'\n\t{\"name\":\"JP Mens\",\"twitter\":\"@jpmens\"}\n\n\t$ jo char=\" \" URIescape=\\\\%20\n\t{\"char\":\" \",\"URIescape\":\"%20\"}\n\n\t$ jo action=\"split window\" vimcmd=\"\\:split\"\n\t{\"action\":\"split window\",\"vimcmd\":\":split\"}\n\nRead element values from a file in order to overcome ARG_MAX limits during object assignment:\n\n\t$ ls | jo -a > child.json\n\t$ jo files:=child.json\n\t{\"files\":[\"AUTHORS\",\"COPYING\",\"ChangeLog\" ....\n\n\t$ ls *.c | jo -a > source.json; ls *.h | jo -a > headers.json\n\t$ jo -a :source.json :headers.json\n\t[[\"base64.c\",\"jo.c\",\"json.c\"],[\"base64.h\",\"json.h\"]]\n\nAdd elements to existing JSON:\n\n\t$ jo -f source.json 1 | jo -f - 2 3\n\t[\"base64.c\",\"jo.c\",\"json.c\",1,2,3]\n\n\t$ curl -s 'https://noembed.com/embed?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ' | jo -f - status=Rickrolled\n\t{ ...., \"type\":\"video\",\"author_url\":\"https://www.youtube.com/user/RickAstleyVEVO\",\"status\":\"Rickrolled\"}\n\nDeduplicate object keys (*jo* appends duplicate object keys by default):\n\n\t$ jo a=1 b=2 a=3\n\t{\"a\":1,\"b\":2,\"a\":3}\n\t$ jo -D a=1 b=2 a=3\n\t{\"a\":3,\"b\":2}\n\n# OPTIONS\n\n*jo* understands the following global options.\n\n-a\n:   Interpret the list of _words_ as array values and produce an array instead of\n    an object.\n\n-B\n:   By default, *jo* interprets the strings \"`true`\" and \"`false`\" as boolean elements\n    `true` and `false` respectively, and \"`null`\" as `null`. Disable with this option.\n\n-D\n:   Deduplicate object keys.\n\n-e\n:   Ignore empty stdin (i.e. don't produce a diagnostic error when *stdin*\n    is empty)\n\n-n\n:   Do not add keys with empty values.\n\n-p\n:   Pretty-print the JSON string on output instead of the terse one-line output it\n    prints by default.\n\n-v\n:   Show version and exit.\n\n-V\n:   Show version as a JSON object and exit.\n\n# BUGS\n\nProbably.\n\nIf a value given to *jo* expands to empty in the shell, then *jo* produces a `null` in object mode, and might appear to hang in array mode; it is not hanging, rather it's reading _stdin_. This is not a bug.\n\nNumeric values are converted to numbers which can produce undesired results. If you quote a numeric value, *jo* will make it a string. Compare the following:\n\n\t$ jo a=1.0\n\t{\"a\":1}\n\t$ jo a=\\\"1.0\\\"\n\t{\"a\":\"1.0\"}\n\nOmitting a closing bracket on a nested element causes a diagnostic message to print, but the output contains garbage anyway. This was designed thusly.\n\n# RETURN CODES\n\n*jo* exits with a code 0 on success and non-zero on failure after indicating what\ncaused the failure.\n\n# AVAILABILITY\n\n<http://github.com/jpmens/jo>\n\n# CREDITS\n\n* This program uses `json.[ch]`, by Joseph A. Adams.\n\n# SEE ALSO\n\n* <https://stedolan.github.io/jq/>\n* <https://github.com/micha/jsawk>\n* <https://github.com/jtopjian/jsed>\n* strtod(3)\n\n# AUTHOR\n\nJan-Piet Mens <http://jpmens.net>\n\n"
        },
        {
          "name": "jo.zsh",
          "type": "blob",
          "size": 2.28125,
          "content": "#compdef jo\n\n# Completion function for zsh\n# Store this file in a directory listed in $fpath for it to be picked up\n# by compinit. It needs to be named with an initial underscore, e.g. _jo\n\nlocal curcontext=\"$curcontext\" sep\nlocal -i aopt nm=$compstate[nmatches]\nlocal -a expl line state state_descr disp\nlocal -A opt_args\n\n_arguments -C -s -A \"-*\" \\\n  '(-h)-p[pretty-print JSON on output]' \\\n  '(-d -h)-a[create an array of words]' \\\n  '(-v -V -h)-B[disable interpretation of true/false/null strings]' \\\n  '(-v -V -h)-D[deduplicate object keys]' \\\n  '(-v -V -h)-f+[first load file then modify it]:file:_files -g \"*.json(-.)\"' \\\n  \"(-v -V -h)-e[if stdin is empty don't wait for input - quit]\" \\\n  \"(-v -V -h)-n[don't add keys with empty values]\" \\\n  '(-v -V -h)-o+[specify output file]:file:_files' \\\n  '(- *)-v[show version information]' \\\n  '(-a -B -e -h -v *)-V[show version in JSON]' \\\n  '(-a -h -v -V)-d+[key will be object path separated by given delimiter]:key delimiter' \\\n  '(- *)-h[show usage information]' \\\n  '*::word:->words'\n\nif [[ -n $state ]]; then\n  aopt=$+opt_args[-a]\n  _arguments \\\n    '*-s[coerce type guessing to string]: :->words' \\\n    '*-b[coerce type guessing to bool]: :->words' \\\n    '*-n[coerce type guessing to number]: :->words' \\\n    '*: :->words'\n\n  if (( aopt )); then\n    _message -e words 'array element'\n  elif compset -P 1 '*:='; then\n    _alternative 'files:file:_files' 'operators:stdin:(-)'\n  elif compset -P 1 '*='; then\n    if compset -P '[@%:]'; then\n      _files\n    else\n      _describe -t operators \"file prefix\" '(\n        @:substitute\\ file\\ as-is\n        %:substitute\\ file\\ in\\ base64-encoded\\ form\n        \\\\::substitute\\ file\\ as\\ JSON\n      )' -S ''\n      _message -e values value\n    fi\n  elif compset -P 1 '?*@'; then\n    _description booleans expl 'boolean'\n    compadd -M 'm:{a-zA-Z}={A-Za-z} m:{10}={TF}' \"$expl[@]\" True False\n  else\n    if compset -P '[^-]*'; then\n      zstyle -s \":completion:${curcontext}:operators\" list-separator sep || sep=--\n      disp=(\n        \"@  $sep boolean element\"\n        \"=  $sep value\"\n        \":= $sep substitute JSON file\"\n        \"[] $sep array element\"\n      )\n      _description operators expl 'operator'\n      compadd -S '' \"$expl[@]\" -ld disp '@' '=' ':=' '[]='\n    fi\n    _message -e keys key\n  fi\nfi\n\n[[ nm -ne compstate[nmatches] ]]\n"
        },
        {
          "name": "json.c",
          "type": "blob",
          "size": 30.5908203125,
          "content": "/*\n  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)\n  All rights reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#include \"json.h\"\n\n#include <assert.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define out_of_memory() do {                    \\\n\t\tfprintf(stderr, \"Out of memory.\\n\");    \\\n\t\texit(EXIT_FAILURE);                     \\\n\t} while (0)\n\n#if defined(_WIN32) || defined(_AIX)\n# define failx(e, n, f, ...)\tif (!(e)) {\t\\\n\t\tfprintf(stderr, \"jo: JSON_ERR: \" f \"\\n\", __VA_ARGS__);\t\\\n\t\texit(n);\t\\\n\t}\n#else\n# include <err.h>\n# define failx(e, n, f, ...)\tif (!(e)) {\t\\\n\t\terrx(n, \"JSON_ERR: \" f, __VA_ARGS__);\t\\\n\t}\n#endif\n\n/* Sadly, strdup is not portable. */\nstatic char *json_strdup(const char *str)\n{\n\tsize_t n = strlen(str) + 1;\n\tchar *ret = (char*) malloc(n);\n\tif (ret == NULL)\n\t\tout_of_memory();\n#if HAVE_STRLCPY\n\tstrlcpy(ret, str, n);\n#else\n\tstrcpy(ret, str);\n#endif\n\treturn ret;\n}\n\n/* String buffer */\n\ntypedef struct\n{\n\tchar *cur;\n\tchar *end;\n\tchar *start;\n} SB;\n\nstatic void sb_init(SB *sb)\n{\n\tsb->start = (char*) malloc(17);\n\tif (sb->start == NULL)\n\t\tout_of_memory();\n\tsb->cur = sb->start;\n\tsb->end = sb->start + 16;\n}\n\n/* sb and need may be evaluated multiple times. */\n#define sb_need(sb, need) do {                  \\\n\t\tif ((sb)->end - (sb)->cur < (need))     \\\n\t\t\tsb_grow(sb, need);                  \\\n\t} while (0)\n\nstatic void sb_grow(SB *sb, int need)\n{\n\tsize_t length = sb->cur - sb->start;\n\tsize_t alloc = sb->end - sb->start;\n\t\n\tdo {\n\t\talloc *= 2;\n\t} while (alloc < length + need);\n\t\n\tsb->start = (char*) realloc(sb->start, alloc + 1);\n\tif (sb->start == NULL)\n\t\tout_of_memory();\n\tsb->cur = sb->start + length;\n\tsb->end = sb->start + alloc;\n}\n\nstatic void sb_put(SB *sb, const char *bytes, int count)\n{\n\tsb_need(sb, count);\n\tmemcpy(sb->cur, bytes, count);\n\tsb->cur += count;\n}\n\n#define sb_putc(sb, c) do {         \\\n\t\tif ((sb)->cur >= (sb)->end) \\\n\t\t\tsb_grow(sb, 1);         \\\n\t\t*(sb)->cur++ = (c);         \\\n\t} while (0)\n\nstatic void sb_puts(SB *sb, const char *str)\n{\n\tsb_put(sb, str, strlen(str));\n}\n\nstatic char *sb_finish(SB *sb)\n{\n\t*sb->cur = 0;\n\tassert(sb->start <= sb->cur && strlen(sb->start) == (size_t)(sb->cur - sb->start));\n\treturn sb->start;\n}\n\nstatic void sb_free(SB *sb)\n{\n\tfree(sb->start);\n}\n\n/*\n * Unicode helper functions\n *\n * These are taken from the ccan/charset module and customized a bit.\n * Putting them here means the compiler can (choose to) inline them,\n * and it keeps ccan/json from having a dependency.\n */\n\n/*\n * Type for Unicode codepoints.\n * We need our own because wchar_t might be 16 bits.\n */\ntypedef uint32_t js_uchar_t;\n\n/*\n * Validate a single UTF-8 character starting at @s.\n * The string must be null-terminated.\n *\n * If it's valid, return its length (1 thru 4).\n * If it's invalid or clipped, return 0.\n *\n * This function implements the syntax given in RFC3629, which is\n * the same as that given in The Unicode Standard, Version 6.0.\n *\n * It has the following properties:\n *\n *  * All codepoints U+0000..U+10FFFF may be encoded,\n *    except for U+D800..U+DFFF, which are reserved\n *    for UTF-16 surrogate pair encoding.\n *  * UTF-8 byte sequences longer than 4 bytes are not permitted,\n *    as they exceed the range of Unicode.\n *  * The sixty-six Unicode \"non-characters\" are permitted\n *    (namely, U+FDD0..U+FDEF, U+xxFFFE, and U+xxFFFF).\n */\nstatic int utf8_validate_cz(const char *s)\n{\n\tunsigned char c = *s++;\n\t\n\tif (c <= 0x7F) {        /* 00..7F */\n\t\treturn 1;\n\t} else if (c <= 0xC1) { /* 80..C1 */\n\t\t/* Disallow overlong 2-byte sequence. */\n\t\treturn 0;\n\t} else if (c <= 0xDF) { /* C2..DF */\n\t\t/* Make sure subsequent byte is in the range 0x80..0xBF. */\n\t\tif (((unsigned char)*s++ & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\t\n\t\treturn 2;\n\t} else if (c <= 0xEF) { /* E0..EF */\n\t\t/* Disallow overlong 3-byte sequence. */\n\t\tif (c == 0xE0 && (unsigned char)*s < 0xA0)\n\t\t\treturn 0;\n\t\t\n\t\t/* Disallow U+D800..U+DFFF. */\n\t\tif (c == 0xED && (unsigned char)*s > 0x9F)\n\t\t\treturn 0;\n\t\t\n\t\t/* Make sure subsequent bytes are in the range 0x80..0xBF. */\n\t\tif (((unsigned char)*s++ & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\tif (((unsigned char)*s++ & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\t\n\t\treturn 3;\n\t} else if (c <= 0xF4) { /* F0..F4 */\n\t\t/* Disallow overlong 4-byte sequence. */\n\t\tif (c == 0xF0 && (unsigned char)*s < 0x90)\n\t\t\treturn 0;\n\t\t\n\t\t/* Disallow codepoints beyond U+10FFFF. */\n\t\tif (c == 0xF4 && (unsigned char)*s > 0x8F)\n\t\t\treturn 0;\n\t\t\n\t\t/* Make sure subsequent bytes are in the range 0x80..0xBF. */\n\t\tif (((unsigned char)*s++ & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\tif (((unsigned char)*s++ & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\tif (((unsigned char)*s++ & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\t\n\t\treturn 4;\n\t} else {                /* F5..FF */\n\t\treturn 0;\n\t}\n}\n\n/* Validate a null-terminated UTF-8 string. */\nstatic bool utf8_validate(const char *s)\n{\n\tint len;\n\t\n\tfor (; *s != 0; s += len) {\n\t\tlen = utf8_validate_cz(s);\n\t\tif (len == 0)\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\n/*\n * Read a single UTF-8 character starting at @s,\n * returning the length, in bytes, of the character read.\n *\n * This function assumes input is valid UTF-8,\n * and that there are enough characters in front of @s.\n */\nstatic int utf8_read_char(const char *s, js_uchar_t *out)\n{\n\tconst unsigned char *c = (const unsigned char*) s;\n\t\n\tassert(utf8_validate_cz(s));\n\n\tif (c[0] <= 0x7F) {\n\t\t/* 00..7F */\n\t\t*out = c[0];\n\t\treturn 1;\n\t} else if (c[0] <= 0xDF) {\n\t\t/* C2..DF (unless input is invalid) */\n\t\t*out = ((js_uchar_t)c[0] & 0x1F) << 6 |\n\t\t       ((js_uchar_t)c[1] & 0x3F);\n\t\treturn 2;\n\t} else if (c[0] <= 0xEF) {\n\t\t/* E0..EF */\n\t\t*out = ((js_uchar_t)c[0] &  0xF) << 12 |\n\t\t       ((js_uchar_t)c[1] & 0x3F) << 6  |\n\t\t       ((js_uchar_t)c[2] & 0x3F);\n\t\treturn 3;\n\t} else {\n\t\t/* F0..F4 (unless input is invalid) */\n\t\t*out = ((js_uchar_t)c[0] &  0x7) << 18 |\n\t\t       ((js_uchar_t)c[1] & 0x3F) << 12 |\n\t\t       ((js_uchar_t)c[2] & 0x3F) << 6  |\n\t\t       ((js_uchar_t)c[3] & 0x3F);\n\t\treturn 4;\n\t}\n}\n\n/*\n * Write a single UTF-8 character to @s,\n * returning the length, in bytes, of the character written.\n *\n * @unicode must be U+0000..U+10FFFF, but not U+D800..U+DFFF.\n *\n * This function will write up to 4 bytes to @out.\n */\nstatic int utf8_write_char(js_uchar_t unicode, char *out)\n{\n\tunsigned char *o = (unsigned char*) out;\n\t\n\tfailx(\n\t\tunicode <= 0x10FFFF && !(unicode >= 0xD800 && unicode <= 0xDFFF),\n\t\t1,\n\t\t\"Illegal Unicode codepoint 0x%08X found\",\n\t\tunicode\n\t);\n\n\tif (unicode <= 0x7F) {\n\t\t/* U+0000..U+007F */\n\t\t*o++ = unicode;\n\t\treturn 1;\n\t} else if (unicode <= 0x7FF) {\n\t\t/* U+0080..U+07FF */\n\t\t*o++ = 0xC0 | unicode >> 6;\n\t\t*o++ = 0x80 | (unicode & 0x3F);\n\t\treturn 2;\n\t} else if (unicode <= 0xFFFF) {\n\t\t/* U+0800..U+FFFF */\n\t\t*o++ = 0xE0 | unicode >> 12;\n\t\t*o++ = 0x80 | (unicode >> 6 & 0x3F);\n\t\t*o++ = 0x80 | (unicode & 0x3F);\n\t\treturn 3;\n\t} else {\n\t\t/* U+10000..U+10FFFF */\n\t\t*o++ = 0xF0 | unicode >> 18;\n\t\t*o++ = 0x80 | (unicode >> 12 & 0x3F);\n\t\t*o++ = 0x80 | (unicode >> 6 & 0x3F);\n\t\t*o++ = 0x80 | (unicode & 0x3F);\n\t\treturn 4;\n\t}\n}\n\n/*\n * Compute the Unicode codepoint of a UTF-16 surrogate pair.\n *\n * @uc should be 0xD800..0xDBFF, and @lc should be 0xDC00..0xDFFF.\n * If they aren't, this function returns false.\n */\nstatic bool from_surrogate_pair(uint16_t uc, uint16_t lc, js_uchar_t *unicode)\n{\n\tif (uc >= 0xD800 && uc <= 0xDBFF && lc >= 0xDC00 && lc <= 0xDFFF) {\n\t\t*unicode = 0x10000 + ((((js_uchar_t)uc & 0x3FF) << 10) | (lc & 0x3FF));\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/*\n * Construct a UTF-16 surrogate pair given a Unicode codepoint.\n *\n * @unicode must be U+10000..U+10FFFF.\n */\nstatic void to_surrogate_pair(js_uchar_t unicode, uint16_t *uc, uint16_t *lc)\n{\n\tjs_uchar_t n;\n\t\n\tfailx(\n\t\tunicode >= 0x10000 && unicode <= 0x10FFFF,\n\t\t1,\n\t\t\"Cannot construct UTF-16 surrogate pair for Unicode codepoint 0x%08X\",\n\t\tunicode\n\t);\n\t\n\tn = unicode - 0x10000;\n\t*uc = ((n >> 10) & 0x3FF) | 0xD800;\n\t*lc = (n & 0x3FF) | 0xDC00;\n}\n\n#define is_space(c) ((c) == '\\t' || (c) == '\\n' || (c) == '\\r' || (c) == ' ')\n#define is_digit(c) ((c) >= '0' && (c) <= '9')\n\nstatic bool parse_value     (const char **sp, JsonNode        **out);\nstatic bool parse_string    (const char **sp, char            **out);\nstatic bool parse_number    (const char **sp, double           *out);\nstatic bool parse_array     (const char **sp, JsonNode        **out);\nstatic bool parse_object    (const char **sp, JsonNode        **out);\nstatic bool parse_hex16     (const char **sp, uint16_t         *out);\n\nstatic bool expect_literal  (const char **sp, const char *str);\nstatic void skip_space      (const char **sp);\n\nstatic void emit_value              (SB *out, const JsonNode *node);\nstatic void emit_value_indented     (SB *out, const JsonNode *node, const char *space, int indent_level);\nstatic void emit_string             (SB *out, const char *str);\nstatic void emit_number             (SB *out, double num);\nstatic void emit_array              (SB *out, const JsonNode *array);\nstatic void emit_array_indented     (SB *out, const JsonNode *array, const char *space, int indent_level);\nstatic void emit_object             (SB *out, const JsonNode *object);\nstatic void emit_object_indented    (SB *out, const JsonNode *object, const char *space, int indent_level);\n\nstatic int write_hex16(char *out, uint16_t val);\n\nstatic JsonNode *mknode(JsonTag tag);\nstatic void append_node(JsonNode *parent, JsonNode *child);\nstatic void prepend_node(JsonNode *parent, JsonNode *child);\nstatic void insert_node(JsonNode *parent, JsonNode *child);\nstatic void append_member(JsonNode *object, char *key, JsonNode *value);\n\nstatic void (*append_member_node_fn)(JsonNode *parent, JsonNode *child) = append_node;\n\n/* Assertion-friendly validity checks */\nstatic bool tag_is_valid(unsigned int tag);\nstatic bool number_is_valid(const char *num);\n\nJsonNode *json_decode(const char *json)\n{\n\tconst char *s = json;\n\tJsonNode *ret;\n\t\n\tskip_space(&s);\n\tif (!parse_value(&s, &ret))\n\t\treturn NULL;\n\t\n\tskip_space(&s);\n\tif (*s != 0) {\n\t\tjson_delete(ret);\n\t\treturn NULL;\n\t}\n\t\n\treturn ret;\n}\n\nchar *json_encode(const JsonNode *node)\n{\n\treturn json_stringify(node, NULL);\n}\n\nchar *json_encode_string(const char *str)\n{\n\tSB sb;\n\tsb_init(&sb);\n\t\n\temit_string(&sb, str);\n\t\n\treturn sb_finish(&sb);\n}\n\nchar *json_stringify(const JsonNode *node, const char *space)\n{\n\tSB sb;\n\tsb_init(&sb);\n\t\n\tif (space != NULL)\n\t\temit_value_indented(&sb, node, space, 0);\n\telse\n\t\temit_value(&sb, node);\n\t\n\treturn sb_finish(&sb);\n}\n\nvoid json_delete(JsonNode *node)\n{\n\tif (node != NULL) {\n\t\tjson_remove_from_parent(node);\n\t\t\n\t\tswitch (node->tag) {\n\t\t\tcase JSON_STRING:\n\t\t\t\tfree(node->string_);\n\t\t\t\tbreak;\n\t\t\tcase JSON_ARRAY:\n\t\t\tcase JSON_OBJECT:\n\t\t\t{\n\t\t\t\tJsonNode *child, *next;\n\t\t\t\tfor (child = node->children.head; child != NULL; child = next) {\n\t\t\t\t\tnext = child->next;\n\t\t\t\t\tjson_delete(child);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:;\n\t\t}\n\t\t\n\t\tfree(node);\n\t}\n}\n\nbool json_validate(const char *json)\n{\n\tconst char *s = json;\n\t\n\tskip_space(&s);\n\tif (!parse_value(&s, NULL))\n\t\treturn false;\n\t\n\tskip_space(&s);\n\tif (*s != 0)\n\t\treturn false;\n\t\n\treturn true;\n}\n\nJsonNode *json_find_element(JsonNode *array, int index)\n{\n\tJsonNode *element;\n\tint i = 0;\n\t\n\tif (array == NULL || array->tag != JSON_ARRAY)\n\t\treturn NULL;\n\t\n\tjson_foreach(element, array) {\n\t\tif (i == index)\n\t\t\treturn element;\n\t\ti++;\n\t}\n\t\n\treturn NULL;\n}\n\nJsonNode *json_find_member(JsonNode *object, const char *name)\n{\n\tJsonNode *member;\n\t\n\tif (object == NULL || object->tag != JSON_OBJECT)\n\t\treturn NULL;\n\t\n\tjson_foreach(member, object)\n\t\tif (strcmp(member->key, name) == 0)\n\t\t\treturn member;\n\t\n\treturn NULL;\n}\n\nJsonNode *json_first_child(const JsonNode *node)\n{\n\tif (node != NULL && (node->tag == JSON_ARRAY || node->tag == JSON_OBJECT))\n\t\treturn node->children.head;\n\treturn NULL;\n}\n\nstatic JsonNode *mknode(JsonTag tag)\n{\n\tJsonNode *ret = (JsonNode*) calloc(1, sizeof(JsonNode));\n\tif (ret == NULL)\n\t\tout_of_memory();\n\tret->tag = tag;\n\treturn ret;\n}\n\nJsonNode *json_mknull(void)\n{\n\treturn mknode(JSON_NULL);\n}\n\nJsonNode *json_mkbool(bool b)\n{\n\tJsonNode *ret = mknode(JSON_BOOL);\n\tret->bool_ = b;\n\treturn ret;\n}\n\nstatic JsonNode *mkstring(char *s)\n{\n\tJsonNode *ret = mknode(JSON_STRING);\n\tret->string_ = s;\n\treturn ret;\n}\n\nJsonNode *json_mkstring(const char *s)\n{\n\treturn mkstring(json_strdup(s));\n}\n\nJsonNode *json_mknumber(double n)\n{\n\tJsonNode *node = mknode(JSON_NUMBER);\n\tnode->number_ = n;\n\treturn node;\n}\n\nJsonNode *json_mkarray(void)\n{\n\treturn mknode(JSON_ARRAY);\n}\n\nJsonNode *json_mkobject(void)\n{\n\treturn mknode(JSON_OBJECT);\n}\n\nstatic void append_node(JsonNode *parent, JsonNode *child)\n{\n\tif (!child) return;\n\tchild->parent = parent;\n\tchild->prev = parent->children.tail;\n\tchild->next = NULL;\n\t\n\tif (parent->children.tail != NULL)\n\t\tparent->children.tail->next = child;\n\telse\n\t\tparent->children.head = child;\n\tparent->children.tail = child;\n}\n\nstatic void prepend_node(JsonNode *parent, JsonNode *child)\n{\n\tif (!child) return;\n\tchild->parent = parent;\n\tchild->prev = NULL;\n\tchild->next = parent->children.head;\n\t\n\tif (parent->children.head != NULL)\n\t\tparent->children.head->prev = child;\n\telse\n\t\tparent->children.tail = child;\n\tparent->children.head = child;\n}\n\nstatic void insert_node(JsonNode *parent, JsonNode *child)\n{\n\tif (!child) return;\n\tJsonNode *this = parent->children.head;\n\n\twhile (this != NULL && strcmp(this->key, child->key))\n\t\tthis = this->next;\n\n\tif (this != NULL)\n\t{\n\t\t/* we found a matching key, insert before this node */\n\t\tif (this->prev == NULL)\n\t\t{\n\t\t\tprepend_node(parent, child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchild->parent = parent;\n\t\t\tchild->next = this->next;\n\t\t\tchild->prev = this->prev;\n\t\t\tthis->prev->next = child;\n\t\t\tthis->prev = child;\n\t\t}\n\t\tjson_delete(this);\n\t}\n\telse\n\t\tappend_node(parent, child);\n}\n\nstatic void append_member(JsonNode *object, char *key, JsonNode *value)\n{\n\tif (!value) return;\n\tvalue->key = key;\n\tappend_member_node_fn(object, value);\n}\n\nvoid json_append_element(JsonNode *array, JsonNode *element)\n{\n\tif (!element) return;\n\tfailx(\n\t\tarray->tag == JSON_ARRAY,\n\t\t1,\n\t\t\"Cannot append %s to non-array %s\",\n\t\tjson_encode(element),\n\t\tjson_encode(array)\n\t);\n\tassert(element->parent == NULL);\n\t\n\tappend_node(array, element);\n}\n\nvoid json_prepend_element(JsonNode *array, JsonNode *element)\n{\n\tif (!element) return;\n\tfailx(\n\t\tarray->tag == JSON_ARRAY,\n\t\t1,\n\t\t\"Cannot append %s to non-array %s\",\n\t\tjson_encode(element),\n\t\tjson_encode(array)\n\t);\n\tassert(element->parent == NULL);\n\t\n\tprepend_node(array, element);\n}\n\nvoid json_append_member(JsonNode *object, const char *key, JsonNode *value)\n{\n\tif (!value) return;\n\tfailx(\n\t\tobject->tag == JSON_OBJECT,\n\t\t1,\n\t\t\"Cannot add {\\\"%s\\\":%s} to non-object %s\",\n\t\tkey,\n\t\tjson_encode(value),\n\t\tjson_encode(object)\n\t);\n\tassert(value->parent == NULL);\n\t\n\tappend_member(object, json_strdup(key), value);\n}\n\nvoid json_prepend_member(JsonNode *object, const char *key, JsonNode *value)\n{\n\tif (!value) return;\n\tfailx(\n\t\tobject->tag == JSON_OBJECT,\n\t\t1,\n\t\t\"Cannot add {\\\"%s\\\":%s} to non-object %s\",\n\t\tkey,\n\t\tjson_encode(value),\n\t\tjson_encode(object)\n\t);\n\tassert(value->parent == NULL);\n\t\n\tvalue->key = json_strdup(key);\n\tprepend_node(object, value);\n}\n\nvoid json_dedup_members(bool b)\n{\n\tappend_member_node_fn = b ? insert_node : append_node;\n}\n\nvoid json_remove_from_parent(JsonNode *node)\n{\n\tJsonNode *parent = node->parent;\n\t\n\tif (parent != NULL) {\n\t\tif (node->prev != NULL)\n\t\t\tnode->prev->next = node->next;\n\t\telse\n\t\t\tparent->children.head = node->next;\n\t\tif (node->next != NULL)\n\t\t\tnode->next->prev = node->prev;\n\t\telse\n\t\t\tparent->children.tail = node->prev;\n\t\t\n\t\tfree(node->key);\n\t\t\n\t\tnode->parent = NULL;\n\t\tnode->prev = node->next = NULL;\n\t\tnode->key = NULL;\n\t}\n}\n\nstatic bool parse_value(const char **sp, JsonNode **out)\n{\n\tconst char *s = *sp;\n\t\n\tswitch (*s) {\n\t\tcase 'n':\n\t\t\tif (expect_literal(&s, \"null\")) {\n\t\t\t\tif (out)\n\t\t\t\t\t*out = json_mknull();\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\n\t\tcase 'f':\n\t\t\tif (expect_literal(&s, \"false\")) {\n\t\t\t\tif (out)\n\t\t\t\t\t*out = json_mkbool(false);\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\n\t\tcase 't':\n\t\t\tif (expect_literal(&s, \"true\")) {\n\t\t\t\tif (out)\n\t\t\t\t\t*out = json_mkbool(true);\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\n\t\tcase '\"': {\n\t\t\tchar *str;\n\t\t\tif (parse_string(&s, out ? &str : NULL)) {\n\t\t\t\tif (out)\n\t\t\t\t\t*out = mkstring(str);\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tcase '[':\n\t\t\tif (parse_array(&s, out)) {\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\n\t\tcase '{':\n\t\t\tif (parse_object(&s, out)) {\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t\n\t\tdefault: {\n\t\t\tdouble num;\n\t\t\tif (parse_number(&s, out ? &num : NULL)) {\n\t\t\t\tif (out)\n\t\t\t\t\t*out = json_mknumber(num);\n\t\t\t\t*sp = s;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nstatic bool parse_array(const char **sp, JsonNode **out)\n{\n\tconst char *s = *sp;\n\tJsonNode *ret = out ? json_mkarray() : NULL;\n\tJsonNode *element;\n\t\n\tif (*s++ != '[')\n\t\tgoto failure;\n\tskip_space(&s);\n\t\n\tif (*s == ']') {\n\t\ts++;\n\t\tgoto success;\n\t}\n\t\n\tfor (;;) {\n\t\tif (!parse_value(&s, out ? &element : NULL))\n\t\t\tgoto failure;\n\t\tskip_space(&s);\n\t\t\n\t\tif (out)\n\t\t\tjson_append_element(ret, element);\n\t\t\n\t\tif (*s == ']') {\n\t\t\ts++;\n\t\t\tgoto success;\n\t\t}\n\t\t\n\t\tif (*s++ != ',')\n\t\t\tgoto failure;\n\t\tskip_space(&s);\n\t}\n\t\nsuccess:\n\t*sp = s;\n\tif (out)\n\t\t*out = ret;\n\treturn true;\n\nfailure:\n\tjson_delete(ret);\n\treturn false;\n}\n\nstatic bool parse_object(const char **sp, JsonNode **out)\n{\n\tconst char *s = *sp;\n\tJsonNode *ret = out ? json_mkobject() : NULL;\n\tchar *key;\n\tJsonNode *value;\n\t\n\tif (*s++ != '{')\n\t\tgoto failure;\n\tskip_space(&s);\n\t\n\tif (*s == '}') {\n\t\ts++;\n\t\tgoto success;\n\t}\n\t\n\tfor (;;) {\n\t\tif (!parse_string(&s, out ? &key : NULL))\n\t\t\tgoto failure;\n\t\tskip_space(&s);\n\t\t\n\t\tif (*s++ != ':')\n\t\t\tgoto failure_free_key;\n\t\tskip_space(&s);\n\t\t\n\t\tif (!parse_value(&s, out ? &value : NULL))\n\t\t\tgoto failure_free_key;\n\t\tskip_space(&s);\n\t\t\n\t\tif (out)\n\t\t\tappend_member(ret, key, value);\n\t\t\n\t\tif (*s == '}') {\n\t\t\ts++;\n\t\t\tgoto success;\n\t\t}\n\t\t\n\t\tif (*s++ != ',')\n\t\t\tgoto failure;\n\t\tskip_space(&s);\n\t}\n\t\nsuccess:\n\t*sp = s;\n\tif (out)\n\t\t*out = ret;\n\treturn true;\n\nfailure_free_key:\n\tif (out)\n\t\tfree(key);\nfailure:\n\tjson_delete(ret);\n\treturn false;\n}\n\nbool parse_string(const char **sp, char **out)\n{\n\tconst char *s = *sp;\n\tSB sb;\n\tchar throwaway_buffer[4];\n\t\t/* enough space for a UTF-8 character */\n\tchar *b;\n\t\n\tif (*s++ != '\"')\n\t\treturn false;\n\t\n\tif (out) {\n\t\tsb_init(&sb);\n\t\tsb_need(&sb, 4);\n\t\tb = sb.cur;\n\t} else {\n\t\tb = throwaway_buffer;\n\t}\n\t\n\twhile (*s != '\"') {\n\t\tunsigned char c = *s++;\n\t\t\n\t\t/* Parse next character, and write it to b. */\n\t\tif (c == '\\\\') {\n\t\t\tc = *s++;\n\t\t\tswitch (c) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '/':\n\t\t\t\t\t*b++ = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t*b++ = '\\b';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\t*b++ = '\\f';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\t*b++ = '\\n';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\t*b++ = '\\r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\t*b++ = '\\t';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t{\n\t\t\t\t\tuint16_t uc, lc;\n\t\t\t\t\tjs_uchar_t unicode;\n\t\t\t\t\t\n\t\t\t\t\tif (!parse_hex16(&s, &uc))\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t\n\t\t\t\t\tif (uc >= 0xD800 && uc <= 0xDFFF) {\n\t\t\t\t\t\t/* Handle UTF-16 surrogate pair. */\n\t\t\t\t\t\tif (*s++ != '\\\\' || *s++ != 'u' || !parse_hex16(&s, &lc))\n\t\t\t\t\t\t\tgoto failed; /* Incomplete surrogate pair. */\n\t\t\t\t\t\tif (!from_surrogate_pair(uc, lc, &unicode))\n\t\t\t\t\t\t\tgoto failed; /* Invalid surrogate pair. */\n\t\t\t\t\t} else if (uc == 0) {\n\t\t\t\t\t\t/* Disallow \"\\u0000\". */\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunicode = uc;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tb += utf8_write_char(unicode, b);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t/* Invalid escape */\n\t\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else if (c <= 0x1F) {\n\t\t\t/* Control characters are not allowed in string literals. */\n\t\t\tgoto failed;\n\t\t} else {\n\t\t\t/* Validate and echo a UTF-8 character. */\n\t\t\tint len;\n\t\t\t\n\t\t\ts--;\n\t\t\tlen = utf8_validate_cz(s);\n\t\t\tif (len == 0)\n\t\t\t\tgoto failed; /* Invalid UTF-8 character. */\n\t\t\t\n\t\t\twhile (len--)\n\t\t\t\t*b++ = *s++;\n\t\t}\n\t\t\n\t\t/*\n\t\t * Update sb to know about the new bytes,\n\t\t * and set up b to write another character.\n\t\t */\n\t\tif (out) {\n\t\t\tsb.cur = b;\n\t\t\tsb_need(&sb, 4);\n\t\t\tb = sb.cur;\n\t\t} else {\n\t\t\tb = throwaway_buffer;\n\t\t}\n\t}\n\ts++;\n\t\n\tif (out)\n\t\t*out = sb_finish(&sb);\n\t*sp = s;\n\treturn true;\n\nfailed:\n\tif (out)\n\t\tsb_free(&sb);\n\treturn false;\n}\n\n/*\n * The JSON spec says that a number shall follow this precise pattern\n * (spaces and quotes added for readability):\n *\t '-'? (0 | [1-9][0-9]*) ('.' [0-9]+)? ([Ee] [+-]? [0-9]+)?\n *\n * However, some JSON parsers are more liberal.  For instance, PHP accepts\n * '.5' and '1.'.  JSON.parse accepts '+3'.\n *\n * This function takes the strict approach.\n */\nbool parse_number(const char **sp, double *out)\n{\n\tconst char *s = *sp;\n\n\t/* '-'? */\n\tif (*s == '-')\n\t\ts++;\n\n\t/* (0 | [1-9][0-9]*) */\n\tif (*s == '0') {\n\t\ts++;\n\t} else {\n\t\tif (!is_digit(*s))\n\t\t\treturn false;\n\t\tdo {\n\t\t\ts++;\n\t\t} while (is_digit(*s));\n\t}\n\n\t/* ('.' [0-9]+)? */\n\tif (*s == '.') {\n\t\ts++;\n\t\tif (!is_digit(*s))\n\t\t\treturn false;\n\t\tdo {\n\t\t\ts++;\n\t\t} while (is_digit(*s));\n\t}\n\n\t/* ([Ee] [+-]? [0-9]+)? */\n\tif (*s == 'E' || *s == 'e') {\n\t\ts++;\n\t\tif (*s == '+' || *s == '-')\n\t\t\ts++;\n\t\tif (!is_digit(*s))\n\t\t\treturn false;\n\t\tdo {\n\t\t\ts++;\n\t\t} while (is_digit(*s));\n\t}\n\n\tif (out)\n\t\t*out = strtod(*sp, NULL);\n\n\t*sp = s;\n\treturn true;\n}\n\nstatic void skip_space(const char **sp)\n{\n\tconst char *s = *sp;\n\twhile (is_space(*s))\n\t\ts++;\n\t*sp = s;\n}\n\nstatic void emit_value(SB *out, const JsonNode *node)\n{\n\tassert(tag_is_valid(node->tag));\n\tswitch (node->tag) {\n\t\tcase JSON_NULL:\n\t\t\tsb_puts(out, \"null\");\n\t\t\tbreak;\n\t\tcase JSON_BOOL:\n\t\t\tsb_puts(out, node->bool_ ? \"true\" : \"false\");\n\t\t\tbreak;\n\t\tcase JSON_STRING:\n\t\t\temit_string(out, node->string_);\n\t\t\tbreak;\n\t\tcase JSON_NUMBER:\n\t\t\temit_number(out, node->number_);\n\t\t\tbreak;\n\t\tcase JSON_ARRAY:\n\t\t\temit_array(out, node);\n\t\t\tbreak;\n\t\tcase JSON_OBJECT:\n\t\t\temit_object(out, node);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n}\n\nvoid emit_value_indented(SB *out, const JsonNode *node, const char *space, int indent_level)\n{\n\tassert(tag_is_valid(node->tag));\n\tswitch (node->tag) {\n\t\tcase JSON_NULL:\n\t\t\tsb_puts(out, \"null\");\n\t\t\tbreak;\n\t\tcase JSON_BOOL:\n\t\t\tsb_puts(out, node->bool_ ? \"true\" : \"false\");\n\t\t\tbreak;\n\t\tcase JSON_STRING:\n\t\t\temit_string(out, node->string_);\n\t\t\tbreak;\n\t\tcase JSON_NUMBER:\n\t\t\temit_number(out, node->number_);\n\t\t\tbreak;\n\t\tcase JSON_ARRAY:\n\t\t\temit_array_indented(out, node, space, indent_level);\n\t\t\tbreak;\n\t\tcase JSON_OBJECT:\n\t\t\temit_object_indented(out, node, space, indent_level);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t}\n}\n\nstatic void emit_array(SB *out, const JsonNode *array)\n{\n\tconst JsonNode *element;\n\t\n\tsb_putc(out, '[');\n\tjson_foreach(element, array) {\n\t\temit_value(out, element);\n\t\tif (element->next != NULL)\n\t\t\tsb_putc(out, ',');\n\t}\n\tsb_putc(out, ']');\n}\n\nstatic void emit_array_indented(SB *out, const JsonNode *array, const char *space, int indent_level)\n{\n\tconst JsonNode *element = array->children.head;\n\tint i;\n\t\n\tif (element == NULL) {\n\t\tsb_puts(out, \"[]\");\n\t\treturn;\n\t}\n\t\n\tsb_puts(out, \"[\\n\");\n\twhile (element != NULL) {\n\t\tfor (i = 0; i < indent_level + 1; i++)\n\t\t\tsb_puts(out, space);\n\t\temit_value_indented(out, element, space, indent_level + 1);\n\t\t\n\t\telement = element->next;\n\t\tsb_puts(out, element != NULL ? \",\\n\" : \"\\n\");\n\t}\n\tfor (i = 0; i < indent_level; i++)\n\t\tsb_puts(out, space);\n\tsb_putc(out, ']');\n}\n\nstatic void emit_object(SB *out, const JsonNode *object)\n{\n\tconst JsonNode *member;\n\t\n\tsb_putc(out, '{');\n\tjson_foreach(member, object) {\n\t\temit_string(out, member->key);\n\t\tsb_putc(out, ':');\n\t\temit_value(out, member);\n\t\tif (member->next != NULL)\n\t\t\tsb_putc(out, ',');\n\t}\n\tsb_putc(out, '}');\n}\n\nstatic void emit_object_indented(SB *out, const JsonNode *object, const char *space, int indent_level)\n{\n\tconst JsonNode *member = object->children.head;\n\tint i;\n\t\n\tif (member == NULL) {\n\t\tsb_puts(out, \"{}\");\n\t\treturn;\n\t}\n\t\n\tsb_puts(out, \"{\\n\");\n\twhile (member != NULL) {\n\t\tfor (i = 0; i < indent_level + 1; i++)\n\t\t\tsb_puts(out, space);\n\t\temit_string(out, member->key);\n\t\tsb_puts(out, \": \");\n\t\temit_value_indented(out, member, space, indent_level + 1);\n\t\t\n\t\tmember = member->next;\n\t\tsb_puts(out, member != NULL ? \",\\n\" : \"\\n\");\n\t}\n\tfor (i = 0; i < indent_level; i++)\n\t\tsb_puts(out, space);\n\tsb_putc(out, '}');\n}\n\nvoid emit_string(SB *out, const char *str)\n{\n\tbool escape_unicode = false;\n\tconst char *s = str;\n\tchar *b;\n\t\n\tassert(utf8_validate(str));\n\t\n\t/*\n\t * 14 bytes is enough space to write up to two\n\t * \\uXXXX escapes and two quotation marks.\n\t */\n\tsb_need(out, 14);\n\tb = out->cur;\n\t\n\t*b++ = '\"';\n\twhile (*s != 0) {\n\t\tunsigned char c = *s++;\n\t\t\n\t\t/* Encode the next character, and write it to b. */\n\t\tswitch (c) {\n\t\t\tcase '\"':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = '\"';\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\tbreak;\n\t\t\tcase '\\b':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = 'b';\n\t\t\t\tbreak;\n\t\t\tcase '\\f':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = 'f';\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = 'n';\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = 'r';\n\t\t\t\tbreak;\n\t\t\tcase '\\t':\n\t\t\t\t*b++ = '\\\\';\n\t\t\t\t*b++ = 't';\n\t\t\t\tbreak;\n\t\t\tdefault: {\n\t\t\t\tint len;\n\t\t\t\t\n\t\t\t\ts--;\n\t\t\t\tlen = utf8_validate_cz(s);\n\t\t\t\t\n\t\t\t\tif (len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Handle invalid UTF-8 character gracefully in production\n\t\t\t\t\t * by writing a replacement character (U+FFFD)\n\t\t\t\t\t * and skipping a single byte.\n\t\t\t\t\t *\n\t\t\t\t\t * This should never happen when assertions are enabled\n\t\t\t\t\t * due to the assertion at the beginning of this function.\n\t\t\t\t\t */\n\t\t\t\t\tassert(false);\n\t\t\t\t\tif (escape_unicode) {\n#if HAVE_STRLCPY\n\t\t\t\t\t\tstrlcpy(b, \"\\\\uFFFD\", out->end - out->start );\n#else\n\t\t\t\t\t\tstrcpy(b, \"\\\\uFFFD\");\n#endif\n\t\t\t\t\t\tb += 6;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*b++ = (char)0xEF;\n\t\t\t\t\t\t*b++ = (char)0xBF;\n\t\t\t\t\t\t*b++ = (char)0xBD;\n\t\t\t\t\t}\n\t\t\t\t\ts++;\n\t\t\t\t} else if (c < 0x1F || (c >= 0x80 && escape_unicode)) {\n\t\t\t\t\t/* Encode using \\u.... */\n\t\t\t\t\tuint32_t unicode;\n\t\t\t\t\t\n\t\t\t\t\ts += utf8_read_char(s, &unicode);\n\t\t\t\t\t\n\t\t\t\t\tif (unicode <= 0xFFFF) {\n\t\t\t\t\t\t*b++ = '\\\\';\n\t\t\t\t\t\t*b++ = 'u';\n\t\t\t\t\t\tb += write_hex16(b, unicode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Produce a surrogate pair. */\n\t\t\t\t\t\tuint16_t uc, lc;\n\t\t\t\t\t\tassert(unicode <= 0x10FFFF);\n\t\t\t\t\t\tto_surrogate_pair(unicode, &uc, &lc);\n\t\t\t\t\t\t*b++ = '\\\\';\n\t\t\t\t\t\t*b++ = 'u';\n\t\t\t\t\t\tb += write_hex16(b, uc);\n\t\t\t\t\t\t*b++ = '\\\\';\n\t\t\t\t\t\t*b++ = 'u';\n\t\t\t\t\t\tb += write_hex16(b, lc);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Write the character directly. */\n\t\t\t\t\twhile (len--)\n\t\t\t\t\t\t*b++ = *s++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Update *out to know about the new bytes,\n\t\t * and set up b to write another encoded character.\n\t\t */\n\t\tout->cur = b;\n\t\tsb_need(out, 14);\n\t\tb = out->cur;\n\t}\n\t*b++ = '\"';\n\t\n\tout->cur = b;\n}\n\nstatic void emit_number(SB *out, double num)\n{\n\t/*\n\t * This isn't exactly how JavaScript renders numbers,\n\t * but it should produce valid JSON for reasonable numbers\n\t * preserve precision well enough, and avoid some oddities\n\t * like 0.3 -> 0.299999999999999988898 .\n\t */\n\tchar buf[64];\n\tsnprintf(buf, sizeof(buf), \"%.16g\", num);\n\t\n\tif (number_is_valid(buf))\n\t\tsb_puts(out, buf);\n\telse\n\t\tsb_puts(out, \"null\");\n}\n\nstatic bool tag_is_valid(unsigned int tag)\n{\n\treturn (/* tag >= JSON_NULL && */ tag <= JSON_OBJECT);\n}\n\nstatic bool number_is_valid(const char *num)\n{\n\treturn (parse_number(&num, NULL) && *num == '\\0');\n}\n\nstatic bool expect_literal(const char **sp, const char *str)\n{\n\tconst char *s = *sp;\n\t\n\twhile (*str != '\\0')\n\t\tif (*s++ != *str++)\n\t\t\treturn false;\n\t\n\t*sp = s;\n\treturn true;\n}\n\n/*\n * Parses exactly 4 hex characters (capital or lowercase).\n * Fails if any input chars are not [0-9A-Fa-f].\n */\nstatic bool parse_hex16(const char **sp, uint16_t *out)\n{\n\tconst char *s = *sp;\n\tuint16_t ret = 0;\n\tuint16_t i;\n\tuint16_t tmp;\n\tchar c;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tc = *s++;\n\t\tif (c >= '0' && c <= '9')\n\t\t\ttmp = c - '0';\n\t\telse if (c >= 'A' && c <= 'F')\n\t\t\ttmp = c - 'A' + 10;\n\t\telse if (c >= 'a' && c <= 'f')\n\t\t\ttmp = c - 'a' + 10;\n\t\telse\n\t\t\treturn false;\n\n\t\tret <<= 4;\n\t\tret += tmp;\n\t}\n\t\n\tif (out)\n\t\t*out = ret;\n\t*sp = s;\n\treturn true;\n}\n\n/*\n * Encodes a 16-bit number into hexadecimal,\n * writing exactly 4 hex chars.\n */\nstatic int write_hex16(char *out, uint16_t val)\n{\n\tconst char *hex = \"0123456789ABCDEF\";\n\t\n\t*out++ = hex[(val >> 12) & 0xF];\n\t*out++ = hex[(val >> 8)  & 0xF];\n\t*out++ = hex[(val >> 4)  & 0xF];\n\t*out++ = hex[ val        & 0xF];\n\t\n\treturn 4;\n}\n\nbool json_check(const JsonNode *node, char errmsg[256])\n{\n\t#define problem(...) do { \\\n\t\t\tif (errmsg != NULL) \\\n\t\t\t\tsnprintf(errmsg, 256, __VA_ARGS__); \\\n\t\t\treturn false; \\\n\t\t} while (0)\n\t\n\tif (node->key != NULL && !utf8_validate(node->key))\n\t\tproblem(\"key contains invalid UTF-8\");\n\t\n\tif (!tag_is_valid(node->tag))\n\t\tproblem(\"tag is invalid (%u)\", node->tag);\n\t\n\tif (node->tag == JSON_BOOL) {\n\t\tif (node->bool_ != false && node->bool_ != true)\n\t\t\tproblem(\"bool_ is neither false (%d) nor true (%d)\", (int)false, (int)true);\n\t} else if (node->tag == JSON_STRING) {\n\t\tif (node->string_ == NULL)\n\t\t\tproblem(\"string_ is NULL\");\n\t\tif (!utf8_validate(node->string_))\n\t\t\tproblem(\"string_ contains invalid UTF-8\");\n\t} else if (node->tag == JSON_ARRAY || node->tag == JSON_OBJECT) {\n\t\tJsonNode *head = node->children.head;\n\t\tJsonNode *tail = node->children.tail;\n\t\t\n\t\tif (head == NULL || tail == NULL) {\n\t\t\tif (head != NULL)\n\t\t\t\tproblem(\"tail is NULL, but head is not\");\n\t\t\tif (tail != NULL)\n\t\t\t\tproblem(\"head is NULL, but tail is not\");\n\t\t} else {\n\t\t\tJsonNode *child;\n\t\t\tJsonNode *last = NULL;\n\t\t\t\n\t\t\tif (head->prev != NULL)\n\t\t\t\tproblem(\"First child's prev pointer is not NULL\");\n\t\t\t\n\t\t\tfor (child = head; child != NULL; last = child, child = child->next) {\n\t\t\t\tif (child == node)\n\t\t\t\t\tproblem(\"node is its own child\");\n\t\t\t\tif (child->next == child)\n\t\t\t\t\tproblem(\"child->next == child (cycle)\");\n\t\t\t\tif (child->next == head)\n\t\t\t\t\tproblem(\"child->next == head (cycle)\");\n\t\t\t\t\n\t\t\t\tif (child->parent != node)\n\t\t\t\t\tproblem(\"child does not point back to parent\");\n\t\t\t\tif (child->next != NULL && child->next->prev != child)\n\t\t\t\t\tproblem(\"child->next does not point back to child\");\n\t\t\t\t\n\t\t\t\tif (node->tag == JSON_ARRAY && child->key != NULL)\n\t\t\t\t\tproblem(\"Array element's key is not NULL\");\n\t\t\t\tif (node->tag == JSON_OBJECT && child->key == NULL)\n\t\t\t\t\tproblem(\"Object member's key is NULL\");\n\t\t\t\t\n\t\t\t\tif (!json_check(child, errmsg))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (last != tail)\n\t\t\t\tproblem(\"tail does not match pointer found by starting at head and following next links\");\n\t\t}\n\t}\n\t\n\treturn true;\n\t\n\t#undef problem\n}\n"
        },
        {
          "name": "json.h",
          "type": "blob",
          "size": 3.4423828125,
          "content": "/*\n  Copyright (C) 2011 Joseph A. Adams (joeyadams3.14159@gmail.com)\n  All rights reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#ifndef CCAN_JSON_H\n#define CCAN_JSON_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\ntypedef enum {\n\tJSON_NULL,\n\tJSON_BOOL,\n\tJSON_STRING,\n\tJSON_NUMBER,\n\tJSON_ARRAY,\n\tJSON_OBJECT,\n} JsonTag;\n\ntypedef struct JsonNode JsonNode;\n\nstruct JsonNode\n{\n\t/* only if parent is an object or array (NULL otherwise) */\n\tJsonNode *parent;\n\tJsonNode *prev, *next;\n\t\n\t/* only if parent is an object (NULL otherwise) */\n\tchar *key; /* Must be valid UTF-8. */\n\t\n\tJsonTag tag;\n\tunion {\n\t\t/* JSON_BOOL */\n\t\tbool bool_;\n\t\t\n\t\t/* JSON_STRING */\n\t\tchar *string_; /* Must be valid UTF-8. */\n\t\t\n\t\t/* JSON_NUMBER */\n\t\tdouble number_;\n\t\t\n\t\t/* JSON_ARRAY */\n\t\t/* JSON_OBJECT */\n\t\tstruct {\n\t\t\tJsonNode *head, *tail;\n\t\t} children;\n\t};\n};\n\n/*** Encoding, decoding, and validation ***/\n\nJsonNode   *json_decode         (const char *json);\nchar       *json_encode         (const JsonNode *node);\nchar       *json_encode_string  (const char *str);\nchar       *json_stringify      (const JsonNode *node, const char *space);\nvoid        json_delete         (JsonNode *node);\n\nbool        json_validate       (const char *json);\n\n/*** Lookup and traversal ***/\n\nJsonNode   *json_find_element   (JsonNode *array, int index);\nJsonNode   *json_find_member    (JsonNode *object, const char *key);\n\nJsonNode   *json_first_child    (const JsonNode *node);\n\n#define json_foreach(i, object_or_array)            \\\n\tfor ((i) = json_first_child(object_or_array);   \\\n\t\t (i) != NULL;                               \\\n\t\t (i) = (i)->next)\n\n/*** Construction and manipulation ***/\n\nJsonNode *json_mknull(void);\nJsonNode *json_mkbool(bool b);\nJsonNode *json_mkstring(const char *s);\nJsonNode *json_mknumber(double n);\nJsonNode *json_mkarray(void);\nJsonNode *json_mkobject(void);\n\nvoid json_append_element(JsonNode *array, JsonNode *element);\nvoid json_prepend_element(JsonNode *array, JsonNode *element);\nvoid json_append_member(JsonNode *object, const char *key, JsonNode *value);\nvoid json_prepend_member(JsonNode *object, const char *key, JsonNode *value);\nvoid json_dedup_members(bool b);\n\nvoid json_remove_from_parent(JsonNode *node);\n\n/*** Debugging ***/\n\n/*\n * Look for structure and encoding problems in a JsonNode or its descendents.\n *\n * If a problem is detected, return false, writing a description of the problem\n * to errmsg (unless errmsg is NULL).\n */\nbool json_check(const JsonNode *node, char errmsg[256]);\n\n#endif\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 2.337890625,
          "content": "project('jo', 'c',\n        version: '1.9',\n        license: 'GPL-2.0-or-later',\n        meson_version: '>=0.57.0',\n        default_options: ['warning_level=3', 'optimization=2'])\n\n\nPACKAGE_VERSION = meson.project_version()\n\ncc = meson.get_compiler('c')\n\nheaders = [\n    'stddef.h',\n    'stdint.h',\n    'stdlib.h',\n    'string.h',\n    'unistd.h',\n    'stdbool.h'\n]\n\nfunctions = [\n    'strchr',\n    'strrchr',\n    'strlcpy',\n    'strlcat',\n    'snprintf',\n    'pledge',\n    'err',\n    'errx'\n]\n\nforeach h: headers\ncc.has_header(h, required: true)\nendforeach\nforeach f: functions\nadd_project_arguments(\n    '-DHAVE_@0@='.format(f.to_upper()) +\n    cc.has_function(f).to_int().to_string(),\n    language: 'c')\nendforeach\n\nadd_project_arguments('-DPACKAGE_VERSION=\"@0@\"'.format(PACKAGE_VERSION),\n                      language: 'c')\n\n\npandoc = find_program('pandoc', required: false)\nif not pandoc.found()\nwarning('pandoc not found, man pages rebuild will not be possible')\njo1 = 'jo.1'\nelse\npandoc_commands = [pandoc, '-s', '-w', 'man', '-f', 'markdown', '-o']\njo1 = custom_target('jo.1',\n                    output: 'jo.1',\n                    input: 'jo.pandoc',\n                    build_always_stale: true,\n                    command: [pandoc_commands, '@OUTPUT@', '@INPUT@']).full_path()\nrun_command(pandoc_commands,\n            join_paths(meson.current_build_dir(), 'jo.1'),\n            join_paths(meson.current_source_dir(), 'jo.pandoc'),\n            check: false)\ncustom_target('jo.md',\n              output: 'jo.md',\n              input: 'jo.pandoc',\n              build_always_stale: true,\n              command: [pandoc, '-s', '-w', 'gfm', '-f', 'markdown-smart', '-o', '@OUTPUT@', '@INPUT@'])\nendif\n\ninstall_man(jo1)\n\nbashcomp = dependency('bash-completion', required: false)\nif bashcomp.found()\nbashcompdir = bashcomp.get_variable(pkgconfig: 'completionsdir')\nelse\nbashcompdir = join_paths(get_option('sysconfdir'), 'bash_completion.d')\nendif\n\ninstall_data('jo.bash', install_dir: bashcompdir)\n\nm_dep = cc.find_library('m', required : false)\n\nexecutable('jo',\n           'jo.c',\n           'base64.c',\n           'base64.h',\n           'json.c',\n           dependencies: m_dep,\n           install: true)\n\nsummary({'Prefix': get_option('prefix'),\n         'C compiler': cc.get_id(),\n         'Pandoc': pandoc,\n         'Bash completion': join_paths(bashcompdir, 'jo.bash'),\n         })\n"
        },
        {
          "name": "press.md",
          "type": "blob",
          "size": 3.091796875,
          "content": "## \"Press\" reports\n\n* [Hacker News](https://news.ycombinator.com/item?id=11230023)\n* [Lobsters](https://lobste.rs/s/tyehi1/a_shell_command_to_create_json_jo)\n* [reddit](https://www.reddit.com/r/programming/comments/49sx6x/a_shell_command_to_create_json_jo)\n* [Hacker News](https://news.ycombinator.com/item?id=11272678)\n* [Trivium](http://chneukirchen.org/trivium/2016-05-13)\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">Didn&#39;t realize I was only half a man while living without it!!!<br><br> <a href=\"https://t.co/gSsbJtvjDW\">https://t.co/gSsbJtvjDW</a></p>&mdash; Andy Fuchs (@tiptronic) <a href=\"https://twitter.com/tiptronic/status/705747046079340544\">March 4, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">The kind of &quot;why didn&#39;t *I* think of this?&quot; <a href=\"https://t.co/VlDC79midI\">https://t.co/VlDC79midI</a></p>&mdash; Yiorgos Adamopoulos (@hakmem) <a href=\"https://twitter.com/hakmem/status/706181245328293888\">March 5, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"fr\" dir=\"ltr\">jq&#39;s companion <a href=\"https://t.co/vwYwVxwB4S\">https://t.co/vwYwVxwB4S</a></p>&mdash; Sylvain (@flyinva) <a href=\"https://twitter.com/flyinva/status/706567570141351936\">March 6, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\"><a href=\"https://twitter.com/jpmens\">@jpmens</a> <a href=\"https://twitter.com/miekg\">@miekg</a> i Love Jo.</p>&mdash; Robert Weigraeber (@robert_we) <a href=\"https://twitter.com/robert_we/status/706182485261086724\">March 5, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">This is brilliant: a super convenient CLI interface to creating JSON output! <a href=\"https://t.co/jeirtyhUMY\">https://t.co/jeirtyhUMY</a></p>&mdash; ma.ttias.be (@mattiasgeniar) <a href=\"https://twitter.com/mattiasgeniar/status/707152566719782912\">March 8, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">jo - generate JSON at the command line. <a href=\"https://t.co/WfnboVl3BB\">https://t.co/WfnboVl3BB</a></p>&mdash; One Thing Well (@onethingwell) <a href=\"https://twitter.com/onethingwell/status/707611961039704068\">March 9, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">jo -p artist=&quot;Vanessa Paradis&quot; song=&quot;Joe le taxi&quot; year=1987</p>&mdash; Frederic Cambus (@fcambus) <a href=\"https://twitter.com/fcambus/status/707860299467120640\">March 10, 2016</a></blockquote> <script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n"
        },
        {
          "name": "rpm-build",
          "type": "tree",
          "content": null
        },
        {
          "name": "snapcraft.yaml",
          "type": "blob",
          "size": 0.369140625,
          "content": "name: jo\nversion: \"1.9\"\nsummary: jo\ndescription: |\n  This is jo, a small utility to create JSON objects or arrays.\n\nconfinement: strict\ngrade: stable\nbase: core20\n\napps:\n  jo:\n    command: usr/local/bin/jo\n    plugs: [home, removable-media]\n\nparts:\n  jo:\n    plugin: autotools\n    source-type: git\n    source: https://github.com/jpmens/jo\n    build-packages:\n      - pkg-config\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}