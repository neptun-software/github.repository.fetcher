{
  "metadata": {
    "timestamp": 1736709745982,
    "page": 162,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "philippe44/AirConnect",
      "stars": 3655,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.369140625,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n\n# Standard to msysgit\n*.doc\t diff=astextplain\n*.DOC\t diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF\t diff=astextplain\n*.rtf\t diff=astextplain\n*.RTF\t diff=astextplain\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.1982421875,
          "content": "# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\nRC*\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n#*.dll\n\n# Fortran module files\n*.mod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n#*.exe\n*.out\n*.app\n\n# =========================\n# Operating System Files\n# =========================\n\n# OSX\n# =========================\n\n.DS_Store\n.AppleDouble\n.LSOverride\n\n# Thumbnails\n._*\n\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n# Windows\n# =========================\n\n# Windows image file caches\nThumbs.db\nehthumbs.db\n\n# Folder config file\nDesktop.ini\n\n# Recycle Bin used on file shares\n$RECYCLE.BIN/\n\n# Windows Installer files\n*.cab\n*.msi\n*.msm\n*.msp\n\n# Windows shortcuts\n*.lnk\n\n# C++ builder related\ntest/\nmisc/\n__history\n/package*.*\n_backup/\n*.pcm\n*.cbproj\n*.groupproj\n*.zip\n*.z\n*.local\n*.$$$\n*.res\n*.i??\n*.map\n*.tds\n*-idx*\n*.save*\n*.pcm\n*.#*\n*.bin\n*.log\n*.bak\n*.pdb\n*.user\ntests/\nbin/bcc/\nbin/msvc\n.vs/\n__recovery/\n*.sln\nbuild/\nair*/bin\n*.bat\nbin/\n!AirConnect*.zip\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 1.2119140625,
          "content": "[submodule \"common/dmap-parser\"]\n\tpath = common/dmap-parser\n\turl = https://github.com/philippe44/dmap-parser\n[submodule \"aircast/nanopb\"]\n\tpath = aircast/nanopb\n\turl = https://github.com/nanopb/nanopb\n[submodule \"aircast/libjansson\"]\n\tpath = aircast/libjansson\n\turl = https://github.com/philippe44/libjansson\n\tfetchRecurseSubmodules = no\t\n[submodule \"common/libpupnp\"]\n\tpath = common/libpupnp\n\turl = https://github.com/philippe44/libpupnp\n\tfetchRecurseSubmodules = no\t\n[submodule \"common/libopenssl\"]\n\tpath = common/libopenssl\n\turl = https://github.com/philippe44/libopenssl\n\tfetchRecurseSubmodules = no\t\n[submodule \"common/libmdns\"]\n\tpath = common/libmdns\n\turl = https://github.com/philippe44/libmdns\n\tfetchRecurseSubmodules = no\n[submodule \"common/libcodecs\"]\n\tpath = common/libcodecs\n\turl = https://github.com/philippe44/libcodecs\n\tfetchRecurseSubmodules = no\n[submodule \"common/crosstools\"]\n\tpath = common/crosstools\n\turl = https://github.com/philippe44/crosstools\n[submodule \"common/libraop\"]\n\tpath = common/libraop\n\turl = https://github.com/philippe44/libraop\n\tfetchRecurseSubmodules = no\t\n[submodule \"common/libpthreads4w\"]\n\tpath = common/libpthreads4w\n\turl = https://github.com/philippe44/libpthreads4w\n\tfetchRecurseSubmodules = no\t\n"
        },
        {
          "name": "AirConnect-1.8.3.zip",
          "type": "blob",
          "size": 67915.35546875,
          "content": ""
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 15.767578125,
          "content": "1.8.3 \n - (aircast) stream type is LIVE and duration is not part of metadata\n \n1.8.2\n - UpnpResolveURL needs one extra byte if RelURL parameters does not start with a '/'\n - use setlocale() so that atof does not fail on '.'\n \n1.8.1\n - handle double resend from iOS and silence after flush\n \n1.8.0\n - refactor raop flush/first packet\n \n1.7.1\n - alternate getting of TransportInfo and PositionInfo (increase polling speed)\n - ignore any frame seq below or equal flush seqno, even after a record\n \n1.7.0\n - allow icy on every codec, just provide interval, let user config and requesting player decide\n - (airupnp) only re-acquire state on play action completion. This is not needed on stop/pause and will create issues like fake stops\n\n1.6.3\n - (airupnp) on error, reset counter to 0 if player responds\n \n1.6.2\n - (airupnp) when player timeout's, use its DescDocURL, not the UpdateData which is NULL...\n \n1.6.1\n - be more relax wrt player deletion and verify with either failed doc download (airupnp) or no response to ping (aircast)\n \n1.6.0\n - (airupnp) remove possibility to tweak ProtocolInfo, it's useless\n - only send silence on first GET (after a flush) and close socket on flush\n - close socket immediately on flush which should stop playback right away \n \n1.5.4\n - use updated libcodec and libraop for alac\n \n1.5.3\n - previous version had a miss build\t\n - fully add aac \n - add extension to stream's url \n - flc -> flac (but flc still works)\n \n1.5.2\n - updated libraries with alac fixes (zero-initialized encoded buffer)\n \n1.5.1\n - (airupnp) call http_pico_close on exit\n - fix all known memory leaks\n - use updated libcodecs that fixes codec close crash (NULL ptr)\n \n1.5.0\n - add aac codec (use refactored libraop and move encoder to libcodecs\n\n1.4.0\n - proper fix of HTTP frame sending & filling\n \n1.3.4\n - libraop was sending 1 instead of 0 on icy retransmit since day one ... can't believe it\n \n1.3.3\n - RTP and NTP order was not fixed either\n \n1.3.2\n - fix http_fill\n\n1.3.1\n - updated libraop allows subsequent GET, even with no range, to restart from 0 for players that open, close and re-open (for no reason)\n \n1.3.0\n - add -N to allow simple name transformation\n \n1.2.5\n - (aircast) ignore SIGPIPE (picohttp)\n - (aircast) fix queue walker\n \n1.2.4\n - use fixed libraop for unknown RTSP queries that should return no headers\n \n1.2.3\n - (airupnp) test errorcoutn for < 0, not just -1\n - (aircast) must increase number of clients for a source\n \n1.2.2\n - (airupnp) fix upnp socket error deteection\n \n1.2.1\n - (airupnp) unified source with spotconnect\n - (aircast) revert exclusion of devices based on netmask\n - display iface and network at start\n - update XML_UpdateNode bug\n \n1.2.0\n - use libraop version that re-sends HTTP when *explictely* request a range 0-XXX to try to cope with player that don't understand what HTTP protocol is and keep askign for a small \"chunk\"\n - aircast display iface name upon startup\n \n1.1.9\n - HTTP exec function should not crash on error when there is no token returned\n \n1.1.8\n - json_pack with \"so\" does not require object's ref to be decremented\n \n1.1.7\n - Don't call metadata callback on flush as it causes spurious play, call it on \"STREAMER_PLAY\" if we have metadata\n \n1.1.6\n - update openssl to 1.1.1u\n\n1.1.5\n - use shutdown instead of close in picohttp server when source has not been found or HEAD was used\n \n1.1.4\n - Make static few function of aircast.c that should have been\n - (aircast) update of config file was not done on new device creation\n  \n1.1.3\n - (aircast) fix netmask endianness which created false expiries\n\n1.1.2\n - (aircast) mDNS searcher was not regularly calling back\n \n1.1.1\n  - remove group volume scaling on SetVolume\n  \n1.1.0\n - airupnp : add artwork in mp3 mode\n - aircast : add metadata (including artwork)\n\n1.0.16\n - bring back armv5 build\n - fixes big memory leak in upnp\n\n1.0.14\n - change network binding for UPnP: get name\n \n1.0.13\n - don't use debug libs for Windows\n \n1.0.12\n - update libraop (no functional change)\n \n1.0.11\n - mdnssvc API change\n\n1.0.10\n - Use (almost) full static GLIBC (-nss)\n\n1.0.9\n - add armv6\n\n1.0.8\n - fix mdnssd\n \n1.0.7\n - update libmdns (no unicast and compliant mode)\n \n1.0.6\n - request specific libcrypto & libssl version for MacOS\n \n1.0.5\n - remove UPnP IPv6 support\n \n1.0.4\n - update mdnssd for unicast  \n \n1.0.3\n - update mdnssd that was binding queries to a port for no reason causing a race failure on freebsd\n \n1.0.2\n - mips is usually bigendian\n \n1.0.1\n - use new compilers so that min glib is 2.23\n \n1.0.0\n - new build system\n  - fix IGMP snooping (hopefully)\n  \n0.2.51.2\n - fix HTTP2 upgrade response to \"Connection\"\n - audio/mp3 is not a correct mimetype...\n \n0.2.51.1\n - Fix CVE-2017-12087\n \n0.2.51.0\n - invoke stop callback on TEARDOWN first\n \n0.2.50.5\n - mdns fix for blank name field\n \n0.2.50.4\n - fix sslsym.c macros that were still incorrect\n \n0.2.50.3\n - noflush was not effective for aircast\n \n0.2.50.2\n - make sslsym compatible with openSSL 1.1.x\n \n0.2.50.1\n - noflush properly send silent frames at the right speed\n\n0.2.50.0\n - flush was broken since 0.2.27.0\n - add --noflush options (and force :f in latencies if set)\n - increment stream index at each SetURI/LOAD to make it unique\n \n0.2.44.1\n - (aircast) reset \"Remove\" flag when adding \n \n0.2.44.0\n - openssl 1.1.x compatibility\n \n0.2.43.1\n - address valgrind complaints\n \n0.2.43.0\n - don't remove unresponsive UPnP devices when playing\n - don't remove CC devices that still respond to ping\n \n0.2.42.1\n - re-align airupnp & aircast version numbers\n \n0.2.42.0\n - a bit of cleaning wrt below issue\n - use \"binding\" as general parameter name for upnp/cast\n \n0.2.41.2\n - %&@!* of Linux does not handle sscanf with %[^:]:%u when the first string is empty\n \n0.2.41.1\n - RTSP port was not bound to range!\n \n0.2.41.0\n - allow chunked encoding and fixed length\n - DLNA.ORG_PN was missing for mp3\n\n0.2.40.0\n - add HTTP header callback for better DLNA handling\n - answer to getcontentFeatures\n \n0.2.30.0\n - add port range\n \n0.2.28.5\n - tweak HTTP logs\n \n0.2.28.4\n - http_parse SDEBUG statement did not print received line\n \n0.2.28.3\n - remove stristr and clean strcasestr case called with NULL\n \n0.2.28.2\n - exclude NULL modelnumber when -o is specified unless they are explicitely autorized\n \n0.2.28.1\n - check that model & modelnumber are not NULL before looking of exclusion\n \n0.2.28.0\n - make max_players a parameter\n\n0.2.27.1\n - handle range request beyond count better\n\n0.2.27.0\n - (airupnp) add -u and UPnPMax config options to set the max upnp search\n \n0.2.26.1\n - (airupnp) config update shall not be done when there is not config\n \n0.2.26.0\n - (aircast) add -v <factor> to globally set group media volume\n\n0.2.25.0\n - (airupnp) search for mediarenderer:2\n \n0.2.24.7\n - garbadge left in airupnp.c\n \n0.2.24.6\n - Can't re-send more bytes than we've received\n \n0.2.24.5\n - (aircast) clear SSL context on shutdown\n \n0.2.24.4\n - race condition where the UPnP/CC device could be stopped by a flush after it started to play due to de-sync of flush/play (RTP) detetcion\n \n0.2.24.3\n - (airupnp) add remote_title\n \n0.2.24.2\n - restore trailing '+' UPnP name changes\n \n0.2.24.1\n - do not copy NULL strings ... (util.c)\n \n0.2.24.0\n - do not send body when method is HEAD\n\n0.2.23.1\n - A records expiration\n\n0.2.23.0\n - improve mDNS detection on multiple VLAN\n\n0.2.22.1\n - (upnp) -o option matches on exact model numbers only\n\n0.2.22.0\n - (upnp) add -o option to enable only listed model numbers\n\n0.2.21.3\n - remove un-necessary muted flag \n - in Volume feedback, CalcGroupVolume was called before caller device was updated\n \n0.2.21.2\n - Can't use Sonos' group volume API as it takes time to \"settle down\", so need to create our own\n \n0.2.21.1\n - handle master's volume within all devices loop\n \n0.2.21.0\n - volume timestamp moved to UPnP/CC side instead of RAOP\n\n0.2.20.0 \n - modify libupnp to search using unicast, but not device seems to support uPnP 1.1\n - CheckAndLock waqs not locking device\n - double timestamp to handle fast volume changes\n - do not delete UPnP context when a Sonos player becomes a slave to manage volume for Sonos groups\n \n0.2.13.1\n - revert buffer indexing modifications\n\n0.2.13.0\n - follow original name change\n\n0.2.12.2\n - correct a key problem with circula buffer management and fill estimation\n - integer promotion caused u16 comparisons to be wrong\n \n0.2.12.1\n - UDP sockets don't need shutdown\n - destroy ab_mutex on thread termination\n \n0.2.12.0\n- static versions now include full static openssl \n \n0.2.11.0\n - revert previous change but force short int promotio in buf_fill calculation\n - add protocolInfo as a parameter\n \n0.2.10.3\n - ancient 32 bits overflow bug in expected playtime calculation\n \n0.2.10.2\n - update built-in dll version to ones that do not need VS\n - add x86_64 static version\n \n0.2.10.1\n - Windows 10 does has renamed libeay32.dll to libcrypto.dll and ssleay32.dll to libssl.dll (and does not even include it)\n - do not crash when SSL not found\n \n0.2.10.0\n - openSSL loaded manually for compatibility => no need any more to deal with various openssl versions!\n \n0.2.9.0\n - (aircast) authorize \"on behalf\" announces as long as they are not from a group member\n\n0.2.8.0\n - silence frames count on http reconnect shall be 0 when already sending silence\n - limit packet recovery to max of rtp latency and http delay\n - misc network congestion corrections\n - forced fill http moved to :f option on latencies\n - add <drift> parameter\n - STILL NEED TO KNOW WHY AIRCAST LOCKS ON EXIT \n\n0.2.7.0\n - add parameter to disable range acceptance in hairtunes (needed for shairtunes2)\n - send silence frames as soon as playtime reached to ensure continuous HTTP stream\n - reduce initial silence frames by number of already received frames\n - discriminate FLUSH send at start to clean pipe from FLUSH used to stop playback using RECORD values and timer\n - resend timeout was wrong (in http thread)\n - silence frames count on http reconnect shall be 0 when already sending silence\n - discard NTP sync that have a larger roundtrip (100ms)\n - RTP latency can be negative to force filling of silence frame when buffer is empty but playtime has elapsed (continuous stream)\n\n0.2.6.1\n - (cast) simplify device removal (no explicit wakeup call)\n \n0.2.6.0\n - move RTSP server back to using accept() instead of select() and use connect() to close the connection\n - remove usage of sleep() to redeuce CPU consumption in idle\n\n0.2.5.0\n  - backport some squeeze2upnp/cast changes with no impact\n  - add -n option in airupnp to exclude model number\n  \n0.2.4.0\n - Detect main IP address change and restart\n \n0.2.3.1\n - version mistake with 0.2.3.0\n \n0.2.3.0\n - add -c <codec> command line\n - work with CC that require a range request (buffer up to 2MB)\n - metadata was freed after ctx was released\n - silence frame shall be ignored when range requested\n - default codec for upnp was 'flac' instead of 'flc'\n \n0.2.2.6\n - set length for silent frame now that length must be returned\n \n0.2.2.5\n - aesiv and aeskey can start with a '\\0', use a decrypt explicit boolean\n - QueueFlush correction\n \n0.2.2.4 \n - Group update could free NULL pointer (cast only)\n\n0.2.2.3\n - artwork was not a duplication, hence releasing metadata was failing (upnp only)\n \n0.2.2.2\n - update build toolchain to full cross compiling, including OSX, FreeBSD and Solaris\n - added Linux ppc\n - (cast) stop receiver should send STOP to sessionId, not mediaSessionId\n \n0.2.2.1\n - flac codec name is 'flc' not 'flac'\n\n0.2.2.0\n - add mp3 for encoding and icy metadata\n - use Sonos radio stream url for mp3\n - add option to set flac compression level\n - encoder was not mutex protected against flush\n  \n0.2.1.1\n - Some controlers like AirParrot do not send encrypted audio\n \n0.2.1.0\n - add static <artwork> parameter\n - 32 bits comparaison correction\n - (aircast) do not set playing state on \"buffering\" event\n \n0.2.0.8\n - add aarch64\n \n0.2.0.7\n - loglimit was not used in airupnp\n \n0.2.0.6\n - kd_dump was writing in a NULL string when no header was received\n \n0.2.0.5\n - alac.c compiles depends on endianness\n - Some players (Roon) send a FLUSH after a TEARDOWN which caused access to a NULL hairtunes context\n - When changing track, the previous HTTP socket was used to send new track, causing miss of flac header & track beginning yielding to very long CC start\n  \n0.2.0.4\n - (airupnp) backporting of squeeze2upnp modifications\n - Add TCP_NODELAY to HTTP socket\n\n0.2.0.3\n - race condition & double free when stopping device (credit @codepeon)\n - http parsing error caused memory leak (headers not released)\n - cosmetic changes\n - (airupnp) backport squeeze2upnp modification (AVTSetURI)\n - (airupnp) subscription complete failure could lead to access NULL pointer\n \n0.2.0.2\n - On keep-alive UPnP result, always move to next item if device found in list (even if removed as a Sonos slave)\n - only use SEARCH_RESULT and not ADVERTISEMENT_ALIVE for keep-alive\n \n0.2.0.1\n - (airupnp) search for master should return true in case of UPnP error\n - (aircast) mDNS search for groups was messed-up\n \n0.2.0.0\n - new handling of discovery (mDNS-SD and UPnP) for on-the-fly player addition / removal (no more discovery time and removal counts)\n - Review of all mutex-related issue and various risk of unprotected code\n - review of memory leaks (only the SSL remains, which is the same all over execution)\n - mDNS records is now 120s (per RFQ) and not 75m so that in case of crash, player do not appear sticky for some applications\n - add possibility to dump players ('dump' & 'dumpall' commmands)\n - in SETUP response, cport and tport are set to 0 by default which will cause session to fail if none of these are provided\n - handle \"header folding\" in HTTP response\n - HTTP headers w/o : should not crash kbd_free\n - use closesocket under Windows, not close!\n - (aircast) SSL context is not deleted at every disconnect to avoid memory leaks\n - (aircast) wrong volume local change when mute was set\n  \n0.1.6.1\n - add Solaris i86pc build\n - change some mdns options\n \n0.1.5.3\n - compile flag to store streams\n \n0.1.5.2\n - FreeBSD does not exit accept() even when socket shutdown properly, need to use select()\n \n0.1.5.1\n - memory leak correction in isMatsre & GetGroupVolume (@codepeon)\n \n0.1.5.0\n - add \"+\" after default name to identify AirConnect players\n \n0.1.4.4\n - always remove players on BYEBYE message\n \n0.1.4.3\n - (airupnp) default name is zone name for Sonos device\n\n0.1.4.2\n - (airupnp) properly eliminate Sonos slaves\n \n0.1.4.1\n - misc Sonos group cleaning\n \n0.1.4.0\n - (airupnp) detect Sonos groups and do not add slaves\n - (airupnp) add Sonos groups volume\n \n0.1.3.2\n - discovery and exit (-i) could abort without searching on aircast\n - new devices were not added to existing file when using -I\n \n0.1.3.1\n - when cannot start, exit with no-zero code\n \n0.1.3.0\n - title changed to \"Streaming from AirConnect\"\n - code cleaning\n \n0.1.2.0\n - send minimum metadata\n - (aircast) remove unused config items \n \n0.1.1.0\n - support wav and pcm codecs\n \n0.1.0.5\n  - rare race condition in UPnP search timeout/result\n\n0.1.0.4\n - flac_ready boolean was un-necessary\n - wait for playing (RTP) before sending silent frames\n - was sending a few raw frames at the beginning when using flac\n - functions renaming for better consistency\n \n0.1.0.3\n - pthread_join of remote search could be called twice\n - update renderer thread cleaned for better exit\n - memory leaks correction\n \n0.1.0.2\n - code cleaning\n - exclusion (-m) parsing was wrong and \";\" is not a valid separator\n \n0.1.0.0\n - HTTP delay uses silence frames\n \n0.0.2.7\n - do not hold RTP frames when they are available! only hold missing one, up to RTP latency\n - add HTTP delay for Chromecast as well\n\n0.0.2.6\n - NULL (empty xml item) was causing crash and default save set <latency> to empty\n \n0.0.2.5\n - <name> in config file was not taken into account\n\n0.0.2.4 \n - only notify of playback when frame is not silence (all 0) to avoid iOS 10.x spurious play\n - add wav header so that wav can be used in AirCast as well\n\n0.0.2.3\n - increase SO_SNDBUF to try to better handle sloppy networks\n \n0.0.2.2\n - high CPU usage in http frames handling\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.1875,
          "content": "(c) Philippe, philippe_44@outlook.com\n\nThis is under MIT license (https://mit-license.org)\n\nThis program uses 3rd party software that is licensed by their \nauthor under their own conditions. \n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.330078125,
          "content": "# AirConnect: Send audio to UPnP/Sonos/Chromecast players using AirPlay\nUse these applications to add AirPlay capabilities to Chromecast and UPnP (like Sonos) players, to make them appear as AirPlay devices.\n\nAirConnect can run on any machine that has access to your local network (Windows, MacOS x86 and arm64, Linux x86, x86_64, arm, aarch64, sparc, mips, powerpc, Solaris and FreeBSD). It does not need to be on your main computer. (For example, a Raspberry Pi works well). It will detect UPnP/Sonos/Chromecast players, create as many virtual AirPlay devices as needed, and act as a bridge/proxy between AirPlay clients (iPhone, iPad, iTunes, MacOS, AirFoil ...) and the real UPnP/Sonos/Chromecast players.\n\nThe audio, after being decoded from alac, can be sent in plain, or re-encoded using mp3, aac or flac. Most players will not display metadata (artist, title, album, artwork ...) except when mp3 or aac re-encoding are used and for UPnP/DLNA devices that support icy protocol. Chromecast players support this after version 1.1.x\n\n## Installing\n\n1. Pre-built binaries are in `AirConnect-<X.Y.Z>.zip`. It can be downloaded manually in a terminal by typing `wget https://raw.githubusercontent.com/philippe44/AirConnect/master/airconnect-<X.Y.Z>.zip`. Unzip the file an select the bianry that works for your system.\n\n\t* For **Chromecast**, the file is `aircast-<os>-<cpu>` (so `aircast-macos-x86_64` for Chromecast on MacOS + Intel CPU) \n\t* For **UPnP/Sonos**, the file is `airupnp-<os>-<cpu>` (so `airupnp-macos-arm64` for UPnP/Sonos on MacOS + arm CPU) \n\n2. There is a \"-static\" version of each application that has all static libraries built-in. Use of these is (really) not recommended unless the regular version fails. For MacOS users, you need to install openSSL and do the following steps to use the dynamic load library version:\n\t- install openssl: `brew install openssl`. This creates libraries (or at least links) into `/usr/local/opt/openssl[/x.y.z]/lib` where optional 'x.y.z' is a version number\n\t- create links to these libraries: \n\t```\n\tln -s /usr/local/opt/openssl[/x.y.z]/lib/libcrypto.dylib /usr/local/lib/libcrypto.dylib \n\tln -s /usr/local/opt/openssl[/x.y.z]/lib/libssl.dylib /usr/local/lib/libssl.dylib \n\t```\n\n3. For Windows, install the Microsoft VC++ redistributable found [here](https://learn.microsoft.com/en-US/cpp/windows/latest-supported-vc-redist?view=msvc-170)\n\tYou will also need to grab the 2 dlls files and put them in the same directory as the exe file\n\n4. Store the \\<executable\\> (e.g. `airupnp-linux-aarch64`) in any directory. \n\n4. On non-Windows machines, open a terminal and change directories to where the executable is stored and run `chmod +x <executable>` (Example: `chmod +x airupnp-macos`). File permissions might need to be set.\n\n5. Don't use firewall or set ports using options below and open them. \n\t- Port 5353 (UDP) is needed to listen to mDNS messages\n\t- Each device uses 1 port permanently (RTSP) and when playing adds 1 port for HTTP and 3 ports for RTP (use `-g`or \\<ports\\> parameter, default is random)\n\t- UPnP adds one extra port for discovery (use `-b` or \\<upnp_socket\\> parameter, default is 49152 and user value must be *above* this)\n\n6. [@faserF](https://github.com/FaserF) has made a [script](https://github.com/philippe44/AirConnect/blob/master/updater) for install/update \nter)\n\n7. In Docker, you must use 'host' mode to enable audio webserver. Note that you can't have a NAT between your devices and the machine where AirConnect runs.\n\n## Running\n\nDouble click the \\<executable\\> or launch it by typing `./<executable>` in the same command line window. \n\n<strong>For Sonos & Heos players, set latency by adding `-l 1000:2000` on the command line.</strong> (Example: `./airupnp-macos -l 1000:2000`) \n\nYou should start to see lots of log messages on screen. Using your iOS/Mac/iTunes/Airfoil/other client, you should now see new AirPlay devices and can try to play audio to them. \n\nIf it works, type `exit`, which terminates the executable, and then, on non-Windows/MacOS machines, relaunch it with `-z` so that it can run in the background and you can close the command line window. You can also start it automatically using any startup script or a Linux service as explained below. Nothing else should be required, no library or anything to install.\n\n*For each platform, there is a normal and a '-static' version. This one includes all libraries directly inside the application, so normally there is no dependence to 3rd party shared libraries, including SSL. You can try it if the normal fails to load (especially on old systems), but static linkage is a blessing a curse (exact reasons out of scope of this README). Now, if the static version still does not work, there are other solutions that are pretty technical, see [here](https://github.com/philippe44/cross-compiling#running-an-application-by-forcing-glibc-and-glibcxx). Best is that you open an issue if you want help with that.*\n\n## Common information:\n\n<strong>Use `-h` for command line details</strong>\n- When started in interactive mode (w/o -Z or -z option) a few commands can be typed at the prompt\n\t- `exit`\n\t- `save <file>` : save the current configuration in file named [name]\n- Volume changes made in native control applications are synchronized with AirPlay client\n- Pause, Stop, Next, Prev using native control application are sent to AirPlay client - once paused, \"native\" play will not work\n- Re-scan for new / lost players happens every 30s\n- A config file (default `config.xml`) can be created for advanced tweaking (a reference version can be generated using  the `-i <file>` command line)\n- Chromecast groups are supported. Use `-v` to set the media volume factor for all devices (0.5 by default)\n- use `-c mp3[:<rate>]|aac[:<rate>]|flac[:0..9]|wav|pcm` to set codec use for re-encoding audio \n- When you have more than one ethernet card, you case use `-b [ip]` to set what card to bind to. Note that 0.0.0.0 is not authorized\n- Use `-u <version>` to set the maximum UPnP searched version\n- Use `-b [ip|iface][:port]` to set network interface (ip@ or interface name as reported by ifconfig/ipconfig) to use and, for airupnp only, UPnP port to listen to (must be above the default 49152)\n- Use `-a <port>[:<count>]` to specify a port range (default count is 128, sets RTP and HTTP ports)\n- Use `-g -3|-1|0|` to tweak http transfer mode where -3 = chunked, -1 = no content-length and 0 = fixed (dummy) length (see \"HTTP content-length\" below)\"\n- Use `-N \"<format>\"` to change the default name of AirPlay players (the player name followed by '+' by default). It's a C-string format where '%s' is the player's name, so default is \"%s+\"\n- Use of `-z` disables interactive mode (no TTY) **and** self-daemonizes (use `-p <file>` to get the PID). Use of `-Z` only disables interactive mode \n- <strong>Do not daemonize (using & or any other method) the executable w/o disabling interactive mode (`-Z`), otherwise it will consume all CPU. On Linux, FreeBSD and Solaris, best is to use `-z`. Note that -z option is not available on MacOS or Windows</strong>\n- A 'click' noise can be heard when timings are adjusted by adding or skipping one 8ms frame. Use `-r` to disable such adjustements (or use `<drift>` option in config file), but that might cause overrun or underrun on long playbacks\n- <strong>This is an audio-only application. Do not expect to play a video on your device and have the audio from UPnP/Sonos or ChromeCast synchronized. It does not, cannot and will not work, regardless of any latency parameter. Please do not open tickets requesting this (see details below to understand why)</strong>\n\n## Config file parameters \n\nThe default configuration file is `config.xml`, stored in the same directory as the \\<executable\\>. Each of parameters below can be set in the `<common>` section to apply to all devices. It can also be set in any `<device>` section to apply only to a specific device and overload the value set in `<common>`. Use the `-x <config>`command line option to use a config file of your choice.\n\n- `latency <[rtp][:http][:f]>` \t: (default: (0:0))buffering tweaking, needed when audio is shuttering or for bad networks (delay playback start)\n\t* [rtp] \t: ms of buffering of RTP (AirPlay) audio. Below 500ms is not recommended. 0 = use value from AirPlay. A negative value force sending of silence frames when no AirPlay audio has been received after 'RTP' ms, to force a continuous stream. If not, the UPnP/CC player will be not receive audio and some might close the connection after a while, although most players will simply be silent until stream restarts. This shall not be necessary in most of the case.\n\t* [http]\t: ms of buffering silence for HTTP audio (not needed normaly, except for Sonos)\n\t* [f]\t\t: when network congestion happens, source frames will not be received at all. Set this parameter to force sending silence frame then. Otherwise, no HTTP data will be sent and player might close the connection\n- `drift <0|1>`\t   : enable adding or dropping a frame when case source frames producion is too fast or too slow\n- `enabled <0|1>`  : in common section, enables new discovered players by default. In a dedicated section, enables the player\n- `name`           : The name that will appear for the device in AirPlay. You can change the default name.\n- `upnp_max`       : set the maximum UPnP version use to search players (default 1)\n- `http_length`    : same as `-g` command line parameter\n- `metadata <0|1>` : send metadata to player (only for mp3 and aac codecs and if player supports ICY protocol)\n- `artwork`        : an URL to an artwork to be displayed on player\n- `flush <0|1>`    : (default 1) set AirPlay *FLUSH* commands response (see also --noflush in [Misc tips](#misc-tips) section)\n- `media_volume\t<0..1>` : (default 0.5) Applies a scaling factor to device's hardware volume (chromecast only)\n- `codec <mp3[:<bitrate>]|aac[:<bitrate>]|flac[:0..9]|wav|pcm>`\t: format used to send HTTP audio. FLAC is recommended but uses more CPU (pcm only available for UPnP). For example, `mp3:320` for 320Kb/s MP3 encoding.\n\nThese are the global parameters\n\n- `max_players`            : set the maximum of players (default 32)\n- `log_limit <-1 | n>`     : (default -1) when using log file, limits its size to 'n' MB (-1 = no limit)\n- `ports <port>[:<count>]` : set port range to use (see -a)\n\n## Start automatically in Linux\n\n1. Create a file in `/etc/systemd/system`, e.g. `airupnp.service` with the following content (assuming the airupnp binary is in `/var/lib/airconnect`)\n\n```\n[Unit]  \nDescription=AirUPnP bridge  \nAfter=network-online.target  \nWants=network-online.target  \n\n[Service]  \nExecStart=/var/lib/airconnect/airupnp-linux-arm -l 1000:2000 -Z -x /var/lib/airconnect/airupnp.xml   \nRestart=on-failure  \nRestartSec=30  \n\n[Install]  \nWantedBy=multi-user.target   \n```\n2. Enable the service `sudo systemctl enable airupnp.service`\n\n3. Start the service `sudo service airupnp start`\n\nTo start or stop the service manually, type `sudo service airupnp start|stop` in a command line window\n\nTo disable the service, type `sudo systemctl disable airupnp.service`\n\nTo view the log, `journalctl -u airupnp.service`\n\nOn rPi lite, add the following to the /boot/cmdline.txt: init=/bin/systemd\n\nObviously, from the above example, only use -x if you want a custom configuration. Thanks [@cactus](https://github.com/cactus) for systemd cleaning\n\n[@1activegeek](https://github.com/1activegeek) has made a docker container [here](https://github.com/1activegeek/docker-airconnect) that follows the update of this repository - thanks!\n\n## Start automatically in MacOS (credits @aiwipro)\n\nCreate the file com.aircast.bridge.plist in ~/Library/LaunchAgents/ \n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>Label</key>\n    <string>com.aircast.bridge</string>\n    <key>ProgramArguments</key>\n    <array>\n        <string>/[path]/aircast-macos</string>\n\t<string>-Z</string>\n        <string>-x</string>\n        <string>/[path]/aircast.xml</string>\n        <string>-f</string>\n        <string>/[path]/aircast.log</string>\n    </array>\n    <key>RunAtLoad</key>\n    <true/>\n    <key>LaunchOnlyOnce</key>\n    <true/>\n    <key>KeepAlive</key>\n    <true/>\n</dict>\n</plist>\n```\n\nWhere `[path]` is the path where you've stored the aircast executable (without the []). It can be for example `Users/xxx/airconnect` where `xxx` is your user name \n\n## Start automatically under Windows\n\nThere are many tools that allow an application to be run as a service. You can try this [one](http://nssm.cc/)\n\n## Synology installation\n\n[@eizedev](https://github.com/eizedev) is now maitaining a package for automatic installation & launch of airupnp on Syno's [here](https://github.com/eizedev/AirConnect-Synology)\n\n## Player specific hints and tips\n\n#### Sonos\nThe upnp version is often used with Sonos players. When a Sonos group is created, only the master of that group will appear as an AirPlay player and others will be removed if they were already detected. If the group is later split, then individual players will re-appear. \n\nWhen changing volume of a group, each player's volume is changed trying to respect the relative values. It's not perfect and stil under test now. To reset all volumes to the same value, simply move the cursor to 0 and then to the new value. All players will have the same volume then. You need to use the Sonos application to change individual volumes.\n\nTo identify your Sonos players, pick an identified IP address, and visit the Sonos status page in your browser, like `http://192.168.1.126:1400/support/review`. Click `Zone Players` and you will see the identifiers for your players in the `UUID` column.\n\n#### Bose SoundTouch\n[@chpusch](https://github.com/chpusch) has found that Bose SoundTouch work well including synchonisation (as for Sonos, you need to use Bose's native application for grouping / ungrouping). I don't have a SoundTouch system so I cannot do the level of slave/master detection I did for Sonos\n\n#### Pioneer/Phorus/Play-Fi\nSome of these speakers only support mp3\n## Misc tips\n \n- When players disappear regularly, it might be that your router is filtering out multicast packets. For example, for a Asus AC-RT68U, you have to login by ssh and run echo 0 > /sys/class/net/br0/bridge/multicast_snooping but it does not stay after a reboot.\n\n- Lots of users seems to have problem with Unify and broadcasting / finding players. Here is a guide https://www.neilgrogan.com/ubnt-sonos/ made by somebody who fixes the issue for his Sonos\n\n- Some AirPlay controller send a FLUSH and immediately start sending new audio when skipping track. This causes AirConnect to issue a STOP and almost immediately a PLAY command which seems to be a problem for certain players (Sonos in some cases). A possible workaround is to ignore FLUSH request (see config file or use --noflush on the command line) but this has side effect on pause as silence frames are sent. At best restart is delayed and worse case it might not work with some codec (flac)\n\n- Some older Avahi distributions grab the port mDNS port 5353 for exclusive use, preventing AirConnect to respond to queries. Please set `disallow-other-stacks=no`in `/etc/avahi/avahi-daemon.conf`\n\n- If the non-static version fails to load complaining that GLIBCXX_3.4.29 is missing, please have a look [there](https://github.com/philippe44/cross-compiling#running-an-application-by-forcing-glibc-and-glibcxx) and use the existing libraries I've provided in that repository. You can simply copy the right `libstdc++.so.6.0.29` in the directory where AirConnect is and create symlink for `libstdc++.so` and `libstdc++.so.6`, then use the `LD_LIBRARY_PATH='$ORIGIN' <app>` trick, it will work without messing anything in your system.\n\n## HTTP & UPnP specificities\n### HTTP content-length and transfer modes\nLots of UPnP player have very poor quality HTTP and UPnP stacks, in addition of UPnP itself being a poorly defined/certified standard. One of the main difficulty comes from the fact that AirConnect cannot provide the length of the file being streamed as the source is an infinite real time RTP flow coming from the AirPlay source.\n\nThe HTTP standard is clear that the \"content-length\" header is optional and can be omitted when server does not know the size of the source. If the client is HTTP 1.1 there is another possibility which is to use \"chunked\" mode where the body of the message is divided into chunks of variable length. This is *explicitely* made for case of unknown source length and an HTTP client that claims to support 1.1 **must** support chunked-encoding.\n\nThe default mode of AirUPnP is \"no content-length\" (\\<http_length\\> = -1) but unfortunately, some players can't deal with that. You can then try \"chunked-encoding\" (\\<http_length> = -3) but some players who claim to be HTTP 1.1 do not support it. There is a last resort option to add a large fake `content-length` (\\<http_length\\> = 0). It is set to 2^31-1, so around 5 hours of playback with flac re-encoding. Note that if player is HTTP 1.0 and http_header is set to -3, AirUPnP will fallback no content-length. The command line option `-g` has the same effect that \\<http_length\\> in the \\<common\\> section of a config file.\n\nThis might still not work as some players do not understand that the source is not a randomly accessible (searchable) file and want to get the first(e.g.) 128kB to try to do some smart guess on the length, close the connection, re-open it from the beginning and expect to have the same content. I'm trying to keep a buffer of last recently sent bytes to be able to resend-it, but that does not always works. Normally, players should understand that when they ask for a range and the response is 200 (full content), it *means* the source does not support range request but some don't (I've tried to add a header \"accept: no-range but that makes things worse most of the time).\n\n## Delay when switching track or source\n\nI've received that question many times: why is there (sometimes) many seconds of delay when I switch track (or source) from my iPhone before I hear the change?\n\nTo understand, it's better that you read the next paragraph, but as you probably won't, here is a quick summary of how AirPlay works. As far as the sender (e.g. your iPhone) is concerned, once the connection with an AirPlay 'speaker' is established, this connection is almost like a analogue wire with a delay (buffer) of 1 or 2 seconds. \n\nWhat iOS does nowadays is that when you switch between tracks, instead of closing the connection and re-creating one, it just pushes the new audio through the existing connection, so you might have the 1~2 seconds of previous audio in the pipe before the new audio plays. Same thing when stopping/pausing playback, iOS simply stops pushing audio through the wire. \n\nThere is a function to \"flush\" the audio in the pipe so that new audio plays immediately, but I've seen that recent versions of iOS don't use it anymore (or some applications decide to not flush while they could). That's not a big deal with most AirPlay speakers, it's a 1~2 second delay.\n\nBut with AirConnect, the AirPlay speaker is not a speaker, it's a UPnP or Chromecast player. They do not at all act like virtual wires, they instead expect to have the whole track available as a file and retrieve data from it as needed. In fact, one of the key functions that AirConnect does is looking like a wire to iPhone and looking like a file to the UPnP/CC. \n\nUsually, UPnP/CC players consume a large chunk of that 'file' before they start to play to handle network congestion, but some don't and simply start playing at the first received byte, counting that the large chunk will come quickly. But that chunk/buffer does not exist for AirConnect as audio is produced in real time by the iPhone. So if a player starts at the first byte, it will very likely lack audio data when a network congestion occurs and playback will stutter. The parameter `http latency` solves this issue by creating a silence buffer sent in a burst when establishing a connection, but this creates a permanent delay between the iPhone and the player. Some UPnP/CC players wait to have buffered enough data before they start playing and again, because that data is built in real time by AirConnect, this other delay adds up to the latency parameter (even if http latency is 0). \n\nWhen you switch between tracks or sources (or pause/stop), if your iPhone sends this \"flush\" command, then AirConnect immediately stops the UPnP/CC player. But if there is no flush command, it will play until these silence + self buffers are consumed ... that can be more than a few seconds.\n\nIn addition the delay can increase with time depending of clock speed difference between the iPhone and the UPnP/CC. Say that the iPhone's clock is 1% faster than the player's clock, then when it has produced 300s (5mins) of audio, the player has received it all but it has only played 297s, so there is an additional delay of 3s. If the iPhone moves track without the flush command, then the UPnP/CC player will start playing new audio (or stop) `http latency` + self-buffer length + 3 seconds later ... that can be a lot!\n\nUnfortunately, there is nothing I can do about that. By not using the \"flush\" command, iOS or application using AirPlay create an issue that AirConnect has no way to identify or avoid.\n\n## Latency parameters explained:\n\nThese bridges receive realtime \"synchronous\" audio from the AirPlay controller in the format of RTP frames and forward it to the Chromecast/UPnP/Sonos player in an HTTP \"asynchronous\" continuous audio binary format (notion of frames does not exist on that side). In other words, the AirPlay clients \"push\" the audio using RTP and the Chromecast/UPnP/Sonos players \"pull\" the audio using an HTTP GET request. \n\nA player using HTTP to get its audio expects to receive an initial large portion of audio as the response to its GET and this creates a large enough buffer to handle most further network congestion/delays. The rest of the audio transmission is regulated by the player using TCP flow control. But when the source is an AirPlay RTP device, there is no such large portion of audio available in advance to be sent to the Player, as the audio comes to the bridge in real time. Every 8ms, a RTP frame is received and is immediately forwarded as the continuation of the HTTP body. If the CC/UPnP/Sonos players starts to play immediately the 1st received audio sample, expecting an initial burst to follow, then any network congestion delaying RTP audio will starve the player and create shuttering. \n\nThe [http] parameter allow a certain amount of silence frames to be sent to the Chromecast/UPnP/Sonos player, in a burst at the beginning. Then, while this \"artificial\" silence is being played, it's possible for the bridge to build a buffer of RTP frames that will then hide network delays that might happen in further RTP frames transmission. This delays the start of the playback by [http] ms.\n\nBut RTP frames are transmitted using UDP, which means there is no guarantee of delivery, so frames might be lost from time to time (happens often on WiFi networks). To allow detection of lost frames, they are numbered sequentially (1,2 ... n) so every time two received frames are not consecutive, the missing ones can be requested again by the AirPlay receiver. \n\nNormally, the bridge forwards immediately every RTP frame using HTTP and again, in HTTP, the notion of frame numbers does not exit, it's just the continuous binary audio. So it's not possible to send audio non-sequentially when using HTTP \n\nFor example, if received RTP frames are numbered 1,2,3,6, this bridge will forward (once decoded and transformed into raw audio) 1,2,3 immediately using HTTP but when it receives 6, it will re-request 4 and 5 to be resent and hold 6 while waiting (if 6 were to be transmitted immediately, the Chromecast/UPnP/Sonos will play 1,2,3,6 ... not nice). The [rtp] parameter sets for how long frame 6 shall be held before adding two silence frames for 4 and 5 and send sending 4,5,6. Obviously, if this delay is larger than the buffer in the Chromecast/UPnP/Sonos player, playback will stop by lack of audio. Note that [rtp] does not delay playback start.\n\nWhen [f] is set, silence frames will be inserted as soon as no RTP frames have been received during [rtp] ms. This ensure that a continuous stream of audio is available on the HTTP server. This might be necessary for some players that close the HTTP connection if they have not received data for some time. It's unlikely though. Note that otherwise when RTP stream is interrupted for more than [http] ms, the UPnP/CC player will stop anyway as it will have empty buffers. Still, as soon as the RTP stream resumes, the bridge will receive frame N, where the last received one might be N-500. So it will request the (up to) [rtp] missing ones (might be less than 500), and restart playing at N-[http], so potentially silence will be inserted. \n\nMany have asked for a way to do video/audio synchronisation so that UPnP (Sonos) players can be used as speakers when playing video on a computer or tablet (YouTube for example). Due to this RTP-to-HTTP bridging, this cannot be done as the exact time when an audio frame is played cannot be controlled on the HTTP client. AirPlay speakers can achieve that because the iPhone/iPad/MAC player will  \"delay\" the video by a known amount, send the audio in advance (usually 2 sec) and then control the exact time when this audio is output by the speaker. But although AirConnect has the exact request timing and maintains synchronization with the player, it cannot \"relay\" that synchronization to the speakers. UPnP protocol does not allow this and Sonos has not made their protocol public. Sometimes you might get lucky because the video-to-audio delay will almost match the HTTP player delay, but it is not reproductible and will not be stable over time.\n\n## Compiling from source\nIt's a Makefile-oriented build, and there is a bash script (built.sh) and Windows one (build.cmd). The bash script is intended for cross-platform build and you might be able to call directly your native compiler, but have a look at the command line in the build.sh to make sure it can work. \n\nPlease see [here](https://github.com/philippe44/cross-compiling/blob/master/README.md#organizing-submodules--packages) to know how to rebuild my apps in general:\n\nOtherwise, you can just get the source code and pre-built binaries:\n```\ncd ~\ngit clone http://github.com/philippe44/airconnect\ncd ~/airconnect\ngit submodule update --init\n\n```\nNB: you can speed up all clonings by a lot by adding `--depth 1` option to just to a shallow clone (you probably don't need all the commits)\n\nand build doing:\n```\ncd ~/airconnect/airupnp\nmake\n```\n\n"
        },
        {
          "name": "aircast",
          "type": "tree",
          "content": null
        },
        {
          "name": "airupnp.service",
          "type": "blob",
          "size": 0.2861328125,
          "content": "[Unit]  \nDescription=AirUPnP bridge  \nAfter=network-online.target  \nWants=network-online.target  \n\n[Service]  \nExecStart=/var/lib/airconnect/airupnp-linux-arm -l 1000:2000 -Z -x /var/lib/airconnect/airupnp.xml   \nRestart=on-failure  \nRestartSec=30  \n\n[Install]  \nWantedBy=multi-user.target   \n"
        },
        {
          "name": "airupnp",
          "type": "tree",
          "content": null
        },
        {
          "name": "build.cmd",
          "type": "blob",
          "size": 0.2900390625,
          "content": "setlocal\n\ncall \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\"\n\n\nif /I [%1] == [rebuild] (\n\tset option=\"-t:Rebuild\"\n)\n\nmsbuild AirConnect.sln /property:Configuration=Release %option%\nmsbuild AirConnect.sln /property:Configuration=Static %option%\n\nendlocal"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 2.5849609375,
          "content": "#!/bin/bash\n\nlist=\"x86_64-linux-gnu-gcc x86-linux-gnu-gcc arm-linux-gnueabi-gcc aarch64-linux-gnu-gcc \\\n      sparc64-linux-gnu-gcc mips-linux-gnu-gcc mipsel-linux-gnu-gcc powerpc-linux-gnu-gcc x86_64-macos-darwin-gcc \\\n      arm64-macos-darwin-cc x86_64-freebsd-gnu-gcc x86_64-solaris-gnu-gcc armv6-linux-gnueabi-gcc \\\n      armv5-linux-gnueabi-gcc\"\n\ndeclare -A alias=( [x86-linux-gnu-gcc]=i686-stretch-linux-gnu-gcc \\\n                   [x86_64-linux-gnu-gcc]=x86_64-stretch-linux-gnu-gcc \\\n                   [arm-linux-gnueabi-gcc]=armv7-stretch-linux-gnueabi-gcc \\\n                   [armv5-linux-gnueabi-gcc]=armv6-stretch-linux-gnueabi-gcc \\\n                   [armv6-linux-gnueabi-gcc]=armv6-stretch-linux-gnueabi-gcc \\\n                   [aarch64-linux-gnu-gcc]=aarch64-stretch-linux-gnu-gcc \\\n                   [sparc64-linux-gnu-gcc]=sparc64-stretch-linux-gnu-gcc \\\n                   [mips-linux-gnu-gcc]=mips64-stretch-linux-gnu-gcc \\\n\t\t   [mipsel-linux-gnu-gcc]=mips64el-stretch-linux-gnu-gcc \\\n\t\t   [powerpc-linux-gnu-gcc]=powerpc64-stretch-linux-gnu-gcc \\\n                   [x86_64-macos-darwin-gcc]=x86_64-apple-darwin19-gcc \\\n                   [arm64-macos-darwin-cc]=arm64-apple-darwin20.4-cc \\\n                   [x86_64-freebsd-gnu-gcc]=x86_64-cross-freebsd12.3-gcc \\\n                   [x86_64-solaris-gnu-gcc]=x86_64-cross-solaris2.x-gcc )\n\ndeclare -A cflags=( [sparc64-linux-gnu-gcc]=\"-mcpu=v7\" \\\n                    [mips-linux-gnu-gcc]=\"-march=mips32\" \\\n                    [mipsel-linux-gnu-gcc]=\"-march=mips32\" \\\n                    [armv5-linux-gnueabi-gcc]=\"-march=armv5t -mfloat-abi=soft\" \\\n                    [powerpc-linux-gnu-gcc]=\"-m32\" )\n\t\t\t\t\t\t\t\ndeclare -a compilers\n\nIFS= read -ra candidates <<< \"$list\"\n\n# do we have \"clean\" somewhere in parameters (assuming no compiler has \"clean\" in it...\nif [[ $@[*]} =~ clean ]]; then\n\tclean=\"clean\"\nfi\t\n\n# first select platforms/compilers\nfor cc in ${candidates[@]}; do\n\t# check compiler first\n\tif ! command -v ${alias[$cc]:-$cc} &> /dev/null; then\n\t\tif command -v $cc &> /dev/null; then\n\t\t\tunset alias[$cc]\n\t\telse\t\n\t\t\tcontinue\n\t\tfi\t\n\tfi\n\n\tif [[ $# == 0 || ($# == 1 && -n $clean) ]]; then\n\t\tcompilers+=($cc)\n\t\tcontinue\n\tfi\n\n\tfor arg in $@\n\tdo\n\t\tif [[ $cc =~ $arg ]]; then \n\t\t\tcompilers+=($cc)\n\t\tfi\n\tdone\ndone\n\n# then do the work\nfor cc in ${compilers[@]}\ndo\n\tIFS=- read -r platform host dummy <<< $cc\n\t\n\texport CFLAGS=${cflags[$cc]}\n\texport CC=${alias[$cc]:-$cc} \n\t\n\t# don't let clang create temp files\n\tif [[ $CC =~ -cc ]]; then\n\t\tCFLAGS+=\"-fno-temp-file\"\n\tfi\t\n\t\n\tmake CC=$CC HOST=$host PLATFORM=$platform $clean -j8\n\t\n\tif [[ -n $clean ]]; then\n\t\tcontinue\n\tfi\ndone\n"
        },
        {
          "name": "buildall.sh",
          "type": "blob",
          "size": 0.080078125,
          "content": "cd airupnp && ../build.sh $1 $2 && cd ..\ncd aircast && ../build.sh $1 $2 && cd ..\n"
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "updater",
          "type": "blob",
          "size": 4.125,
          "content": "#!/bin/bash\n#AirConnect Updater - Pull latest Update from https://github.com/philippe44/AirConnect\n#AirConnect by philippe44 - updater script by FaserF https://github.com/FaserF\n\n#Variables\nnewversion=0000\ncurrentversion=0000\nstate=NoLocalInstallationFound\ncurrentdirectory=$PWD\ntmpfolder=/tmp/AirConnect\nbackupfolder=$tmpfolder/backup\ndownloadfolder=$tmpfolder/download\n\n\nfunction checkLocalInstallation() {\n\tif [ -f \"CHANGELOG\" ] && [ -f \"airupnp.service\" ]\n\tthen\n\t\techo \"Current installation detected\"\n\n\t\t#Remeber current install directory\n\t\tcurrentdirectory=$PWD\n\n\t\t#Set state\n\t\tstate=LocalInstallationFound\n\tfi\n\tif [ -f \"$currentdirectory/AirConnect/CHANGELOG\" ]  &&  [ -f \"$currentdirectory/AirConnect/airupnp.service\" ]\n\tthen\n\t\techo \"Current installation detected in subfolder AirConnect\"\n\t\t\n\t\t#Remeber current install directory\n\t\tcurrentdirectory=$PWD/AirConnect\n\t\t\n\t\t#Set state\n\t\tstate=LocalInstallationFound\n\tfi\n}\n\n\nfunction cleanInstall() {\n\techo \"First installation...\"\n\n\t#Ask for target installation directory\n\tread -p \"Enter full path where to install: \" targetdirectory\n\n\tif test -z \"targetdirectory\"\n\tthen\n\t\t# install to current path if nothing is entered\n\t\ttargetdirectory=$PWD\n\tfi\n\n\tif [ \"targetdirectory\" = \"/\" ]\n\tthen\n\t\techo \"Error: Can't install at root\"\n\t\texit 1\n\tfi\n\n\t#Create target directory\n\tif [ ! -d \"$targetdirectory\" ]\n\tthen\n\t\tmkdir \"$targetdirectory\"\n\tfi\n\n\t#Install newest version\n\techo \"----\"\n\techo \"Installing newest version...\"\n\techo \"----\"\n\tgit clone --depth=1 https://github.com/philippe44/AirConnect.git $targetdirectory 2>&1 >/dev/null \n}\n\n\nfunction prepareTmpFolder() {\n\t#Delete previous folder if still exist \n\tif [ -d \"$tmpfolder\" ]\n\tthen\n\t  rm -rf $tmpfolder\n\tfi\n\n\t#Create new empty tmp folders\n\tmkdir $tmpfolder\n\tmkdir $tmpfolder/backup\n\tmkdir $tmpfolder/download\n}\n\n\nfunction searchNewVersion() {\n\t#Checking for new Updates\n\techo \"----\"\n\techo \"Checking for new updates\"\n\techo \"----\"\n\t\n\t#Download online changelog\n\tdownload https://raw.githubusercontent.com/philippe44/AirConnect/master/CHANGELOG $tmpfolder/CHANGELOG\n\n\t#Calculate online version\n\tnewversion=$(head -n 1 $tmpfolder/CHANGELOG)\n\tnewversion=${newversion//[-._]}\n\n\t#Delete online changelog\n\trm $tmpfolder/CHANGELOG\n\t\n\t#Grep current version number\n\tcurrentversion=$(head -n 1 $currentdirectory/CHANGELOG)\n\tcurrentversion=${currentversion//[-._]}\n\n\tif [ \"$newversion\" -gt \"$currentversion\" ]\n\tthen\n\t    echo \"Found new version: $newversion\"\n\t\tstate=NewVersionFoundOnGithub\n\telse\n\t    echo \"No new update found\"\n\tfi\n}\n\n\nfunction backupCurrentVersion() {\n\techo \"----\"\n\techo \"Backing up old version...\"\n\tmv $currentdirectory/* $tmpfolder/backup\n}\n\n\nfunction updateCurrentVersion() {\n\t#Remove previous version files\n\trm -rf $currentdirectory/*\n\n\t#Download newest Version\n\techo \"----\"\n\techo \"Update version...\"\n\techo \"----\"\n\tgit clone --depth=1 https://github.com/philippe44/AirConnect.git $downloadfolder 2>&1 >/dev/null\n\n\t#Install\n\tmv $downloadfolder/* $currentdirectory\n}\n\n\nfunction validateUpdatedVersion() {\n\tversioncheck=$(head -n 1 $currentdirectory/CHANGELOG)\n\tversioncheck=${versioncheck//[-._]}\n\n\tif [ \"$versioncheck\" -eq \"$newversion\" ]\n\tthen\n\t    echo \"----\"\n\t    echo \"Update done\"\n\t    echo \"----\"\n\t    echo \"New Version: $versioncheck\"\n\telse\n\t    echo \"----\"\n\t    echo \"Update failed\"\n\t    echo \"----\"\n\t    echo \"Current Version: $currentversion\"\t\n\tfi\n\n\techo \"-----\"\n\techo \"Old version backup in: $backupfolder\"\n}\n\n\nfunction download() {\n    url=$1\n    filename=$2\n\n    if [ -x \"$(which wget)\" ] ; then\n        wget -q $url -O $2\n    elif [ -x \"$(which curl)\" ]; then\n        curl -o $2 -sfL $url\n    else\n        echo \"Could not find curl or wget, please install one.\" >&2\n    fi\n}\n\n\n#\n# Main\n#########################################\n#\n#\n\n#Check if AirConnect is already installed\ncheckLocalInstallation\n\nif [ $state = \"NoLocalInstallationFound\" ]\nthen\n\t#Install new version\n\tcleanInstall\nelse\n\t#Create needed folder\n\tprepareTmpFolder\n\t\n\t#Check if a new version is available\n\tsearchNewVersion\n\t\n\tif [ $state = \"NewVersionFoundOnGithub\" ]\n\tthen\n\t\t#Backup Current Installation\n\t\tbackupCurrentVersion\n\t\t\n\t\t#Update Current Installation\n\t\tupdateCurrentVersion\n\t\t\n\t\t#Validate Version\n\t\tvalidateUpdatedVersion\n\tfi\nfi\n"
        }
      ]
    }
  ]
}