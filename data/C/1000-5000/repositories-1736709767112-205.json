{
  "metadata": {
    "timestamp": 1736709767112,
    "page": 205,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "darkk/redsocks",
      "stars": 3369,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0390625,
          "content": "*.o\nconfig.h\ntags\nredsocks\n.depend\n/gen\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1318359375,
          "content": "os:\n  - linux\n  - osx\n\naddons:\n  apt:\n    packages:\n    - libevent-dev\n\nlanguage: c\n\ncompiler:\n  - gcc\n  - clang\n\nscript:\n  - make all\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.8974609375,
          "content": "-include make.conf\nOBJS := parser.o main.o redsocks.o log.o http-connect.o socks4.o socks5.o http-relay.o base.o base64.o md5.o http-auth.o utils.o redudp.o dnstc.o dnsu2t.o gen/version.o\nifeq ($(DBG_BUILD),1)\nOBJS += debug.o\nendif\nSRCS := $(OBJS:.o=.c)\nCONF := config.h\nDEPS := .depend\nOUT := redsocks\nVERSION := 0.5\n\nLIBS := -levent_core\nifeq ($(DBG_BUILD),1)\n# -levent_extra is required only for `http` and `debug`\nLIBS += -levent_extra\nendif\nCFLAGS += -g -O2\n# _GNU_SOURCE is used to get splice(2), it also implies _BSD_SOURCE\noverride CFLAGS += -std=c99 -D_XOPEN_SOURCE=600 -D_DEFAULT_SOURCE -D_GNU_SOURCE -Wall\n\nall: $(OUT)\n\n.PHONY: all clean distclean test\n\ntags: *.c *.h\n\tctags -R\n\n$(CONF):\n\t@case `uname` in \\\n\tLinux*) \\\n\t\techo \"#define USE_IPTABLES\" >$(CONF) \\\n\t\t;; \\\n\tOpenBSD) \\\n\t\techo \"#define USE_PF\" >$(CONF) \\\n\t\t;; \\\n\t*) \\\n\t\techo \"Unknown system, only generic firewall code is compiled\" 1>&2; \\\n\t\techo \"/* Unknown system, only generic firewall code is compiled */\" >$(CONF) \\\n\t\t;; \\\n\tesac\nifeq ($(DBG_BUILD),1)\n\techo \"#define DBG_BUILD 1\" >>$(CONF)\nendif\n\n# Dependency on .git is useful to rebuild `version.c' after commit, but it breaks non-git builds.\ngen/version.c: *.c *.h gen/.build\n\trm -f $@.tmp\n\techo '/* this file is auto-generated during build */' > $@.tmp\n\techo '#include \"../version.h\"' >> $@.tmp\n\techo 'const char* redsocks_version = ' >> $@.tmp\n\tif [ -d .git ]; then \\\n\t\techo '\"redsocks.git/'`git describe --tags`'\"'; \\\n\t\tif [ `git status --porcelain | grep -v -c '^??'` != 0 ]; then \\\n\t\t\techo '\"'\"-unclean-$$(date --rfc-3339=seconds | tr ' ' 'T')-$${USER}@$$(uname -n)\"'\"'; \\\n\t\tfi \\\n\telse \\\n\t\techo '\"redsocks/$(VERSION)\"'; \\\n\tfi >> $@.tmp\n\techo ';' >> $@.tmp\n\tmv -f $@.tmp $@\n\ngen/.build:\n\tmkdir -p gen\n\ttouch $@\n\nbase.c: $(CONF)\n\n$(DEPS): $(SRCS)\n\tgcc -MM $(SRCS) 2>/dev/null >$(DEPS) || \\\n\t( \\\n\t\tfor I in $(wildcard *.h); do \\\n\t\t\texport $${I//[-.]/_}_DEPS=\"`sed '/^\\#[ \\t]*include \\?\"\\(.*\\)\".*/!d;s//\\1/' $$I`\"; \\\n\t\tdone; \\\n\t\techo -n >$(DEPS); \\\n\t\tfor SRC in $(SRCS); do \\\n\t\t\techo -n \"$${SRC%.c}.o: \" >>$(DEPS); \\\n\t\t\texport SRC_DEPS=\"`sed '/\\#[ \\t]*include \\?\"\\(.*\\)\".*/!d;s//\\1/' $$SRC | sort`\"; \\\n\t\t\twhile true; do \\\n\t\t\t\texport SRC_DEPS_OLD=\"$$SRC_DEPS\"; \\\n\t\t\t\texport SRC_DEEP_DEPS=\"\"; \\\n\t\t\t\tfor HDR in $$SRC_DEPS; do \\\n\t\t\t\t\teval export SRC_DEEP_DEPS=\"\\\"$$SRC_DEEP_DEPS \\$$$${HDR//[-.]/_}_DEPS\\\"\"; \\\n\t\t\t\tdone; \\\n\t\t\t\texport SRC_DEPS=\"`echo $$SRC_DEPS $$SRC_DEEP_DEPS | sed 's/  */\\n/g' | sort -u`\"; \\\n\t\t\t\ttest \"$$SRC_DEPS\" = \"$$SRC_DEPS_OLD\" && break; \\\n\t\t\tdone; \\\n\t\t\techo $$SRC $$SRC_DEPS >>$(DEPS); \\\n\t\tdone; \\\n\t)\n\n-include $(DEPS)\n\n$(OUT): $(OBJS)\n\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS) $(LIBS)\n\nclean:\n\t$(RM) $(OUT) $(CONF) $(OBJS)\n\ndistclean: clean\n\t$(RM) tags $(DEPS)\n\t$(RM) -r gen\n\ntests/__build-tstamp__: $(OUT) tests/[a-z]* tests/[a-z]*/*\n\tcd tests && ./build\n\ttouch $@\n\ntests/prlimit-nofile: tests/prlimit-nofile.c\n\t$(CC) $(CFLAGS) -o $@ $^\n\ntest: tests/__build-tstamp__ tests/prlimit-nofile\n\tcd tests && env $(TEST_ENV) ./run\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.4306640625,
          "content": "# redsocks â€“ transparent TCP-to-proxy redirector\n\nThis tool allows you to redirect any TCP connection to SOCKS or HTTPS\nproxy using your firewall, so redirection may be system-wide or network-wide.\n\nWhen is redsocks useful?\n\n* you want to route part of TCP traffic via OpenSSH `DynamicForward` Socks5\n  port using firewall policies. That was original redsocks development goal;\n* you use DVB ISP and this ISP provides internet connectivity with some\n  special daemon that may be also called \"Internet accelerator\" and the\n  accelerator acts as a proxy and has no \"transparent proxy\" feature and you\n  need it. [Globax](http://www.globax.biz) was an example of alike accelerator,\n  but Globax 5 has transparent proxy feature. That was the second redsocks`\n  development goal;\n* you have to pass traffic through proxy due to corporate network limitation.\n  That was never a goal for redsocks, but users have reported success with\n  some proxy configurations.\n\nWhen is redsocks probably a wrong tool?\n\n* redirecting traffic to [tor](https://www.torproject.org). First, you **have**\n  to [use tor-aware software for anonymity](https://www.torproject.org/download/download.html.en#warning).\n  Second, [use `TransPort`](https://trac.torproject.org/projects/tor/wiki/doc/TransparentProxy)\n  if you don't actually need anonymity. Third, question everything :-)\n* trying to redirect traffic of significant number of connections over single\n  SSH connection. That's not exactly [TCP over TCP](http://sites.inka.de/bigred/devel/tcp-tcp.html),\n  but [head-of-line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking)\n  will still happen and performance of real-time applications (IM, interactive\n  Web applications) may be degraded during bulk transfers;\n* trying to make non-transparent HTTP-proxy (not HTTPS-proxy) transparent using\n  `http-relay` module. First, it will likely be broken as the code is hack.\n  Second, the code is vulnerable to `CVE-2009-0801` and will unlikely be ever fixed;\n* making \"really\" transparent proxy, redsocks acts at TCP level, so three-way\n  handshake is completed and redsocks accepts connection before connection\n  through proxy (and _to_ proxy) is established;\n* trying to redirect traffic of significant number of connections in\n  resource-constrained environment like SOHO Linux router. Throughput of single\n  connection may be good enough like 40 Mbit/s\n  on [TP-Link TD-W8980](https://wiki.openwrt.org/toh/tp-link/td-w8980),\n  but amount of concurrent connections may be limiting factor as TCP buffers\n  are still consumed;\n* redirecting traffic to proxy on mobile device running Android or iOS as it'll require\n  [rooting](https://en.wikipedia.org/wiki/Rooting_(Android)) to update firewall\n  rules. Probably, the better way is to use on-device VPN daemon to intercept\n  traffic via [`VpnService` API for Android](https://developer.android.com/reference/android/net/VpnService.html)\n  and [`NETunnelProvider` family of APIs for iOS](https://developer.apple.com/documentation/networkextension).\n  That may require some code doing [TCP Reassembly](https://wiki.wireshark.org/TCP_Reassembly)\n  like [`tun2socks`](https://github.com/ambrop72/badvpn/wiki/Tun2socks).\n\nLinux/iptables is supported.  OpenBSD/pf and FreeBSD/ipfw may work with some\nhacks. The author has no permanent root access to machines running OpenBSD,\nFreeBSD and MacOSX to test and develop for these platforms.\n\n[Transocks](http://transocks.sourceforge.net/) is alike project but it has\nnoticeable performance penality.\n\n[Transsocks_ev](http://oss.tiggerswelt.net/transocks_ev/)\nis alike project too, but it has no HTTPS-proxy support\nand does not support authentication.\n\nSeveral Android apps also use redsocks under-the-hood:\n[ProxyDroid](https://github.com/madeye/proxydroid)\n[<i class=\"fa fa-play\"></i>](https://market.android.com/details?id=org.proxydroid) and\n[sshtunnel](https://code.google.com/archive/p/sshtunnel/)\n[<i class=\"fa fa-play\"></i>](https://market.android.com/details?id=org.sshtunnel).\nAnd that's over 1'500'000 downloads! Wow!\n\n## Features\n\nRedirect any TCP connection to Socks4, Socks5 or HTTPS (HTTP/CONNECT)\nproxy server.\n\nLogin/password authentication is supported for Socks5/HTTPS connections.\nSocks4 supports only username, password is ignored. for HTTPS, currently\nonly Basic and Digest scheme is supported.\n\nRedirect UDP packets via Socks5 proxy server. NB: UDP still goes via UDP, so\nyou can't relay UDP via OpenSSH.\n\nHandle DNS/UDP queries sending \"truncated reply\" as an answer or making them\nDNS/TCP queries to some recursive resolver.\n\nRedirect any HTTP connection to proxy that does not support transparent\nproxying (e.g. old SQUID had broken `acl myport' for such connections).\n\n### Enforcing DNS over TCP using `dnstc`\n\nDNS is running over UDP and it may be an issue in some environments as proxy\nservers usually don't handle UDP as a first-class citizen.  Redsocks includes\n`dnstc` that is fake and really dumb DNS server that returns \"truncated answer\"\nto every query via UDP. RFC-compliant resolver should repeat same query via TCP\nin this case - so the request can be redirected using usual redsocks facilities.\n\nKnown compliant resolvers are:\n\n* bind9 (server);\n* dig, nslookup (tools based on bind9 code).\n\nKnown non-compliant resolvers are:\n\n* eglibc resolver fails without any attempt to send request via TCP;\n* powerdns-recursor can't properly startup without UDP connectivity as it\n  can't load root hints.\n\nOn the other hand, DNS via TCP using bind9 may be painfully slow.\nIf your bind9 setup is really slow, you may want to try\n[pdnsd](http://www.phys.uu.nl/~rombouts/pdnsd.html) caching server\nthat can run in TCP-only mode.\n\n### Relaying DNS/UDP to DNS/TCP via `dnsu2t`\n\nThe code acts as DNS server that multiplexes several UDP queries into single\nstream of TCP queries over keep-alive connection to upstream DNS server that\nshould be recursive resolver. TCP connection may be handled by `redsocks`\nitself if firewall is configured with corresponding rules.\n\nDifferent resolvers have different timeouts and allow different count of\nin-flight connections, so you have to tune options yourself for optimal\nperformance (with some black magic, as script testing for optimal DNS/TCP\nconnection parameters is not written yet).\n\nThere are other programs doing alike job (with, probably, different bugs)\n\n* [ttdnsd](http://www.mulliner.org/collin/ttdnsd.php)\n* [dns2socks](https://github.com/qiuzi/dns2socks) for Windows\n* [tcpdnsproxy](https://github.com/jtripper/dns-tcp-socks-proxy)\n\n## Source\n\nSource is available at [<i class=\"fa fa-github\"></i> GitHub](https://github.com/darkk/redsocks).\n\nIssue tracker is also at GitHub, but keep in mind that the project is not\nactively maintained, so feature requests will unlikely be implemented within\nreasonable timeframe.  Reproducable bugs having clean desciption will likely be\nfixed. Destiny of hard-to-reproduce bugs is hard to predict.\n\nNew network protocols will unlikely be implemented within this source tree, but\nif you're seeking for censorship circumvention protocols, you may want to take\na look at [redsocks2](https://github.com/semigodking/redsocks) by Zhuofei Wang\nAKA @semigodking who is actively maintaining the fork with GFW in mind.\n\n## License\n\nAll source code is licensed under Apache 2.0 license.\nYou can get a copy at http://www.apache.org/licenses/LICENSE-2.0.html\n\n## Packages\n\n* Archlinux: https://aur.archlinux.org/packages/redsocks-git\n* Debian: http://packages.debian.org/search?searchon=names&keywords=redsocks\n* Gentoo (zugaina overlay): http://gpo.zugaina.org/net-proxy/redsocks\n* Gentoo: https://packages.gentoo.org/packages/net-proxy/redsocks\n* Ubuntu: http://packages.ubuntu.com/search?searchon=names&keywords=redsocks\n\n## Compilation\n\n[libevent-2.0.x](http://libevent.org/) is required.\n\ngcc and clang are supported right now, other compilers can be used\nbut may require some code changes.\n\nCompilation is as easy as running `make`, there is no `./configure` magic.\n\nGNU Make works, other implementations of make were not tested.\n\n## Running\n\nProgram has following command-line options:\n\n* `-c` sets proper path to config file (\"./redsocks.conf\" is default one)\n* `-t` tests config file syntax\n* `-p` set a file to write the getpid() into\n\nFollowing signals are understood:\nSIGUSR1 dumps list of connected clients to log,\nSIGTERM and SIGINT terminates daemon, all active connections are closed.\n\nYou can see configuration file example in [redsocks.conf.example](https://github.com/darkk/redsocks/blob/master/redsocks.conf.example).\n\n### iptables example\n\nYou have to build iptables with connection tracking and REDIRECT target.\n\n```\n# Create new chain\nroot# iptables -t nat -N REDSOCKS\n\n# Ignore LANs and some other reserved addresses.\n# See http://en.wikipedia.org/wiki/Reserved_IP_addresses#Reserved_IPv4_addresses\n# and http://tools.ietf.org/html/rfc5735 for full list of reserved networks.\nroot# iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 100.64.0.0/10 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 198.18.0.0/15 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN\nroot# iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN\n\n# Anything else should be redirected to port 12345\nroot# iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345\n\n# Any tcp connection made by `luser' should be redirected.\nroot# iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner luser -j REDSOCKS\n\n# You can also control that in more precise way using `gid-owner` from\n# iptables.\nroot# groupadd socksified\nroot# usermod --append --groups socksified luser\nroot# iptables -t nat -A OUTPUT -p tcp -m owner --gid-owner socksified -j REDSOCKS\n\n# Now you can launch your specific application with GID `socksified` and it\n# will be... socksified. See following commands (numbers may vary).\n# Note: you may have to relogin to apply `usermod` changes.\nluser$ id\nuid=1000(luser) gid=1000(luser) groups=1000(luser),1001(socksified)\nluser$ sg socksified -c id\nuid=1000(luser) gid=1001(socksified) groups=1000(luser),1001(socksified)\nluser$ sg socksified -c \"firefox\"\n\n# If you want to configure socksifying router, you should look at\n# doc/iptables-packet-flow.png, doc/iptables-packet-flow-ng.png and\n# https://en.wikipedia.org/wiki/File:Netfilter-packet-flow.svg\n# Note, you should have proper `local_ip' value to get external packets with\n# redsocks, default 127.0.0.1 will not go. See iptables(8) manpage regarding\n# REDIRECT target for details.\n# Depending on your network configuration iptables conf. may be as easy as:\nroot# iptables -t nat -A PREROUTING --in-interface eth_int -p tcp -j REDSOCKS\n```\n\n### Note about GID-based redirection\n\nKeep in mind, that changed GID affects filesystem permissions, so if your\napplication creates some files, the files will be created with luser:socksified\nowner/group. So, if you're not the only user in the group `socksified` and your\numask allows to create group-readable files and your directory permissions, and\nso on, blah-blah, etc. THEN you may expose your files to another user.\nOk, you have been warned.\n\n## Homepage\n\nhttp://darkk.net.ru/redsocks/\n\nMailing list: [redsocks@librelist.com](mailto:redsocks@librelist.com).\n\nMailing list also has [archives](http://librelist.com/browser/redsocks/).\n\n## Author\n\nThis program was written by Leonid Evdokimov <leon@darkk.net.ru>\n"
        },
        {
          "name": "base.c",
          "type": "blob",
          "size": 13.7578125,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <pwd.h>\n#include <grp.h>\n#include <stdlib.h>\n#include \"config.h\"\n#if defined USE_IPTABLES\n# include <limits.h>\n# include <linux/netfilter_ipv4.h>\n#endif\n#if defined USE_PF\n# include <net/if.h>\n# include <net/pfvar.h>\n# include <sys/ioctl.h>\n# include <errno.h>\n#endif\n#include \"log.h\"\n#include \"main.h\"\n#include \"parser.h\"\n#include \"redsocks.h\"\n\ntypedef struct redirector_subsys_t {\n\tint (*init)();\n\tvoid (*fini)();\n\tint (*getdestaddr)(int fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr, struct sockaddr_in *destaddr);\n\tconst char *name;\n\t// some subsystems may store data here:\n\tint private;\n} redirector_subsys;\n\ntypedef struct base_instance_t {\n\tint configured;\n\tchar *chroot;\n\tchar *user;\n\tchar *group;\n\tchar *redirector_name;\n\tredirector_subsys *redirector;\n\tchar *log_name;\n\tbool log_debug;\n\tbool log_info;\n\tbool daemon;\n#if defined(TCP_KEEPIDLE) && defined(TCP_KEEPCNT) && defined(TCP_KEEPINTVL)\n\tuint16_t tcp_keepalive_time;\n\tuint16_t tcp_keepalive_probes;\n\tuint16_t tcp_keepalive_intvl;\n#endif\n\tuint32_t rlimit_nofile;\n\tuint32_t redsocks_conn_max;\n\tuint32_t connpres_idle_timeout;\n\tuint32_t max_accept_backoff_ms;\n} base_instance;\n\nstatic base_instance instance;\n\n#if defined __FreeBSD__ || defined USE_PF\nstatic int redir_open_private(const char *fname, int flags)\n{\n\tint fd = open(fname, flags);\n\tif (fd < 0) {\n\t\tlog_errno(LOG_ERR, \"open(%s)\", fname);\n\t\treturn -1;\n\t}\n\tinstance.redirector->private = fd;\n\treturn 0;\n}\n\nstatic void redir_close_private()\n{\n\tclose(instance.redirector->private);\n\tinstance.redirector->private = -1;\n}\n#endif\n\n#ifdef __FreeBSD__\nstatic int redir_init_ipf()\n{\n#ifdef IPNAT_NAME\n\tconst char *fname = IPNAT_NAME;\n#else\n\tconst char *fname = IPL_NAME;\n#endif\n\treturn redir_open_private(fname, O_RDONLY);\n}\n\nstatic int getdestaddr_ipf(int fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr, struct sockaddr_in *destaddr)\n{\n\tint natfd = instance.redirector->private;\n\tstruct natlookup natLookup;\n\tint x;\n#if defined(IPFILTER_VERSION) && (IPFILTER_VERSION >= 4000027)\n\tstruct ipfobj obj;\n#else\n\tstatic int siocgnatl_cmd = SIOCGNATL & 0xff;\n#endif\n\n#if defined(IPFILTER_VERSION) && (IPFILTER_VERSION >= 4000027)\n\tobj.ipfo_rev = IPFILTER_VERSION;\n\tobj.ipfo_size = sizeof(natLookup);\n\tobj.ipfo_ptr = &natLookup;\n\tobj.ipfo_type = IPFOBJ_NATLOOKUP;\n\tobj.ipfo_offset = 0;\n#endif\n\n\tnatLookup.nl_inport = bindaddr->sin_port;\n\tnatLookup.nl_outport = client->sin_port;\n\tnatLookup.nl_inip = bindaddr->sin_addr;\n\tnatLookup.nl_outip = client->sin_addr;\n\tnatLookup.nl_flags = IPN_TCP;\n#if defined(IPFILTER_VERSION) && (IPFILTER_VERSION >= 4000027)\n\tx = ioctl(natfd, SIOCGNATL, &obj);\n#else\n\t/*\n\t * IP-Filter changed the type for SIOCGNATL between\n\t * 3.3 and 3.4.  It also changed the cmd value for\n\t * SIOCGNATL, so at least we can detect it.  We could\n\t * put something in configure and use ifdefs here, but\n\t * this seems simpler.\n\t */\n\tif (63 == siocgnatl_cmd) {\n\t\tstruct natlookup *nlp = &natLookup;\n\t\tx = ioctl(natfd, SIOCGNATL, &nlp);\n\t} else {\n\t\tx = ioctl(natfd, SIOCGNATL, &natLookup);\n\t}\n#endif\n\tif (x < 0) {\n\t\tif (errno != ESRCH)\n\t\t\tlog_errno(LOG_WARNING, \"ioctl(SIOCGNATL)\\n\");\n\t\treturn -1;\n\t} else {\n\t\tdestaddr->sin_family = AF_INET;\n\t\tdestaddr->sin_port = natLookup.nl_realport;\n\t\tdestaddr->sin_addr = natLookup.nl_realip;\n\t\treturn 0;\n\t}\n}\n#endif\n\n#ifdef USE_PF\nstatic int redir_init_pf()\n{\n\treturn redir_open_private(\"/dev/pf\", O_RDWR);\n}\n\nstatic int getdestaddr_pf(\n\t\tint fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr,\n\t\tstruct sockaddr_in *destaddr)\n{\n\tint pffd = instance.redirector->private;\n\tstruct pfioc_natlook nl;\n\tint saved_errno;\n\tchar clientaddr_str[INET6_ADDRSTRLEN], bindaddr_str[INET6_ADDRSTRLEN];\n\n\tmemset(&nl, 0, sizeof(struct pfioc_natlook));\n\tnl.saddr.v4.s_addr = client->sin_addr.s_addr;\n\tnl.sport = client->sin_port;\n\tnl.daddr.v4.s_addr = bindaddr->sin_addr.s_addr;\n\tnl.dport = bindaddr->sin_port;\n\tnl.af = AF_INET;\n\tnl.proto = IPPROTO_TCP;\n\tnl.direction = PF_OUT;\n\n\tif (ioctl(pffd, DIOCNATLOOK, &nl) != 0) {\n\t\tif (errno == ENOENT) {\n\t\t\tnl.direction = PF_IN; // required to redirect local packets\n\t\t\tif (ioctl(pffd, DIOCNATLOOK, &nl) != 0) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tdestaddr->sin_family = AF_INET;\n\tdestaddr->sin_port = nl.rdport;\n\tdestaddr->sin_addr = nl.rdaddr.v4;\n\treturn 0;\n\nfail:\n\tsaved_errno = errno;\n\tif (!inet_ntop(client->sin_family, &client->sin_addr, clientaddr_str, sizeof(clientaddr_str)))\n\t\tstrncpy(clientaddr_str, \"???\", sizeof(clientaddr_str));\n\tif (!inet_ntop(bindaddr->sin_family, &bindaddr->sin_addr, bindaddr_str, sizeof(bindaddr_str)))\n\t\tstrncpy(bindaddr_str, \"???\", sizeof(bindaddr_str));\n\n\terrno = saved_errno;\n\tlog_errno(LOG_WARNING, \"ioctl(DIOCNATLOOK {src=%s:%d, dst=%s:%d})\",\n\t\t\t  clientaddr_str, ntohs(nl.sport), bindaddr_str, ntohs(nl.dport));\n\treturn -1;\n}\n#endif\n\n#ifdef USE_IPTABLES\nstatic int getdestaddr_iptables(int fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr, struct sockaddr_in *destaddr)\n{\n\tsocklen_t socklen = sizeof(*destaddr);\n\tint error;\n\n\terror = getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, destaddr, &socklen);\n\tif (error) {\n\t\tlog_errno(LOG_WARNING, \"getsockopt\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int getdestaddr_generic(int fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr, struct sockaddr_in *destaddr)\n{\n\tsocklen_t socklen = sizeof(*destaddr);\n\tint error;\n\n\terror = getsockname(fd, (struct sockaddr*)destaddr, &socklen);\n\tif (error) {\n\t\tlog_errno(LOG_WARNING, \"getsockopt\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint getdestaddr(int fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr, struct sockaddr_in *destaddr)\n{\n\treturn instance.redirector->getdestaddr(fd, client, bindaddr, destaddr);\n}\n\nint apply_tcp_keepalive(int fd)\n{\n\tstruct { int level, option, value; } opt[] = {\n\t\t{ SOL_SOCKET, SO_KEEPALIVE, 1 },\n\t\t{ IPPROTO_TCP, TCP_KEEPIDLE, instance.tcp_keepalive_time },\n\t\t{ IPPROTO_TCP, TCP_KEEPCNT, instance.tcp_keepalive_probes },\n\t\t{ IPPROTO_TCP, TCP_KEEPINTVL, instance.tcp_keepalive_intvl },\n\t};\n\tfor (int i = 0; i < SIZEOF_ARRAY(opt); ++i) {\n\t\tif (opt[i].value) {\n\t\t\tint error = setsockopt(fd, opt[i].level, opt[i].option, &opt[i].value, sizeof(opt[i].value));\n\t\t\tif (error) {\n\t\t\t\tlog_errno(LOG_WARNING, \"setsockopt(%d, %d, %d, &%d, %zu)\", fd, opt[i].level, opt[i].option, opt[i].value, sizeof(opt[i].value));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nuint32_t max_accept_backoff_ms()\n{\n\treturn instance.max_accept_backoff_ms;\n}\n\nuint32_t redsocks_conn_max()\n{\n\treturn instance.redsocks_conn_max;\n}\n\nuint32_t connpres_idle_timeout()\n{\n\treturn instance.connpres_idle_timeout;\n}\n\nstatic redirector_subsys redirector_subsystems[] =\n{\n#ifdef __FreeBSD__\n\t{ .name = \"ipf\", .init = redir_init_ipf, .fini = redir_close_private, .getdestaddr = getdestaddr_ipf },\n#endif\n#ifdef USE_PF\n\t{ .name = \"pf\",  .init = redir_init_pf,  .fini = redir_close_private, .getdestaddr = getdestaddr_pf },\n#endif\n#ifdef USE_IPTABLES\n\t{ .name = \"iptables\", .getdestaddr = getdestaddr_iptables },\n#endif\n\t{ .name = \"generic\",  .getdestaddr = getdestaddr_generic  },\n};\n\n/***********************************************************************\n * `base` config parsing\n */\nstatic parser_entry base_entries[] =\n{\n\t{ .key = \"chroot\",     .type = pt_pchar,   .addr = &instance.chroot },\n\t{ .key = \"user\",       .type = pt_pchar,   .addr = &instance.user },\n\t{ .key = \"group\",      .type = pt_pchar,   .addr = &instance.group },\n\t{ .key = \"redirector\", .type = pt_pchar,   .addr = &instance.redirector_name },\n\t{ .key = \"log\",        .type = pt_pchar,   .addr = &instance.log_name },\n\t{ .key = \"log_debug\",  .type = pt_bool,    .addr = &instance.log_debug },\n\t{ .key = \"log_info\",   .type = pt_bool,    .addr = &instance.log_info },\n\t{ .key = \"daemon\",     .type = pt_bool,    .addr = &instance.daemon },\n#if defined(TCP_KEEPIDLE) && defined(TCP_KEEPCNT) && defined(TCP_KEEPINTVL)\n\t{ .key = \"tcp_keepalive_time\",   .type = pt_uint16, .addr = &instance.tcp_keepalive_time },\n\t{ .key = \"tcp_keepalive_probes\", .type = pt_uint16, .addr = &instance.tcp_keepalive_probes },\n\t{ .key = \"tcp_keepalive_intvl\",  .type = pt_uint16, .addr = &instance.tcp_keepalive_intvl },\n#endif\n\t{ .key = \"rlimit_nofile\", .type = pt_uint32, .addr = &instance.rlimit_nofile },\n\t{ .key = \"redsocks_conn_max\", .type = pt_uint32, .addr = &instance.redsocks_conn_max },\n\t{ .key = \"connpres_idle_timeout\", .type = pt_uint32, .addr = &instance.connpres_idle_timeout },\n\t{ .key = \"max_accept_backoff\", .type = pt_uint32, .addr = &instance.max_accept_backoff_ms },\n\t{ }\n};\n\nstatic int base_onenter(parser_section *section)\n{\n\tif (instance.configured) {\n\t\tparser_error(section->context, \"only one instance of base is valid\");\n\t\treturn -1;\n\t}\n\tmemset(&instance, 0, sizeof(instance));\n\tinstance.configured = 1;\n\tinstance.max_accept_backoff_ms = 60000;\n\tinstance.connpres_idle_timeout = 7440;\n\treturn 0;\n}\n\nstatic int base_onexit(parser_section *section)\n{\n\tif (!instance.max_accept_backoff_ms) {\n\t\tparser_error(section->context, \"`max_accept_backoff` must be positive, 0 ms is too low\");\n\t\treturn -1;\n\t}\n\n\tif (instance.redirector_name) {\n\t\tredirector_subsys *ss;\n\t\tFOREACH(ss, redirector_subsystems) {\n\t\t\tif (!strcmp(ss->name, instance.redirector_name)) {\n\t\t\t\tinstance.redirector = ss;\n\t\t\t\tinstance.redirector->private = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!instance.redirector) {\n\t\t\tparser_error(section->context, \"invalid `redirector` set <%s>\", instance.redirector_name);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse {\n\t\tparser_error(section->context, \"no `redirector` set\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic parser_section base_conf_section =\n{\n\t.name    = \"base\",\n\t.entries = base_entries,\n\t.onenter = base_onenter,\n\t.onexit  = base_onexit\n};\n\n/***********************************************************************\n * `base` initialization\n */\nstatic int base_fini();\n\nstatic int base_init()\n{\n\tuid_t uid = -1;\n\tgid_t gid = -1;\n\tint devnull = -1;\n\n\tif (!instance.configured) {\n\t\tlog_error(LOG_ERR, \"there is no configured instance of `base`, check config file\");\n\t\treturn -1;\n\t}\n\n\tif (instance.redirector->init && instance.redirector->init() < 0)\n\t\treturn -1;\n\n\tif (instance.user) {\n\t\tstruct passwd *pw = getpwnam(instance.user);\n\t\tif (pw == NULL) {\n\t\t\tlog_errno(LOG_ERR, \"getpwnam(%s)\", instance.user);\n\t\t\tgoto fail;\n\t\t}\n\t\tuid = pw->pw_uid;\n\t}\n\n\tif (instance.group) {\n\t\tstruct group *gr = getgrnam(instance.group);\n\t\tif (gr == NULL) {\n\t\t\tlog_errno(LOG_ERR, \"getgrnam(%s)\", instance.group);\n\t\t\tgoto fail;\n\t\t}\n\t\tgid = gr->gr_gid;\n\t}\n\n\tif (log_preopen(\n\t\t\tinstance.log_name ? instance.log_name : instance.daemon ? \"syslog:daemon\" : \"stderr\",\n\t\t\tinstance.log_debug,\n\t\t\tinstance.log_info\n\t) < 0 ) {\n\t\tgoto fail;\n\t}\n\n\tif (instance.rlimit_nofile) {\n\t\tstruct rlimit rlmt;\n\t\trlmt.rlim_cur = instance.rlimit_nofile;\n\t\trlmt.rlim_max = instance.rlimit_nofile;\n\t\tif (setrlimit(RLIMIT_NOFILE, &rlmt) != 0) {\n\t\t\tlog_errno(LOG_ERR, \"setrlimit(RLIMIT_NOFILE, %u)\", instance.rlimit_nofile);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tstruct rlimit rlmt;\n\t\tif (getrlimit(RLIMIT_NOFILE, &rlmt) != 0) {\n\t\t\tlog_errno(LOG_ERR, \"getrlimit(RLIMIT_NOFILE)\");\n\t\t\tgoto fail;\n\t\t}\n\t\tinstance.rlimit_nofile = rlmt.rlim_cur;\n\t}\n\n\tif (!instance.redsocks_conn_max) {\n\t\tinstance.redsocks_conn_max = (instance.rlimit_nofile - instance.rlimit_nofile / 4)\n\t\t\t/ (redsocks_has_splice_instance() ? 6 : 2);\n\t}\n\n\tif (instance.daemon) {\n\t\tdevnull = open(\"/dev/null\", O_RDWR);\n\t\tif (devnull == -1) {\n\t\t\tlog_errno(LOG_ERR, \"open(\\\"/dev/null\\\", O_RDWR\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (instance.chroot) {\n\t\tif (chroot(instance.chroot) < 0) {\n\t\t\tlog_errno(LOG_ERR, \"chroot(%s)\", instance.chroot);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (instance.daemon || instance.chroot) {\n\t\tif (chdir(\"/\") < 0) {\n\t\t\tlog_errno(LOG_ERR, \"chdir(\\\"/\\\")\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (instance.group) {\n\t\tif (setgid(gid) < 0) {\n\t\t\tlog_errno(LOG_ERR, \"setgid(%i)\", gid);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (instance.user) {\n\t\tif (setuid(uid) < 0) {\n\t\t\tlog_errno(LOG_ERR, \"setuid(%i)\", uid);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (instance.daemon) {\n\t\tswitch (fork()) {\n\t\tcase -1: // error\n\t\t\tlog_errno(LOG_ERR, \"fork()\");\n\t\t\tgoto fail;\n\t\tcase 0:  // child\n\t\t\tbreak;\n\t\tdefault: // parent, pid is returned\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t}\n\n\tlog_open(); // child has nothing to do with TTY\n\n\tif (instance.daemon) {\n\t\tif (setsid() < 0) {\n\t\t\tlog_errno(LOG_ERR, \"setsid()\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tint fds[] = { STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO };\n\t\tint *pfd;\n\t\tFOREACH(pfd, fds)\n\t\t\tif (dup2(devnull, *pfd) < 0) {\n\t\t\t\tlog_errno(LOG_ERR, \"dup2(devnull, %i)\", *pfd);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\tclose(devnull);\n\t}\n\treturn 0;\nfail:\n\tif (devnull != -1)\n\t\tclose(devnull);\n\n\tbase_fini();\n\n\treturn -1;\n}\n\nstatic int base_fini()\n{\n\tif (instance.redirector->fini)\n\t\tinstance.redirector->fini();\n\n\tfree(instance.chroot);\n\tfree(instance.user);\n\tfree(instance.group);\n\tfree(instance.redirector_name);\n\tfree(instance.log_name);\n\n\tmemset(&instance, 0, sizeof(instance));\n\n\treturn 0;\n}\n\napp_subsys base_subsys =\n{\n\t.init = base_init,\n\t.fini = base_fini,\n\t.conf_section = &base_conf_section,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "base.h",
          "type": "blob",
          "size": 0.4853515625,
          "content": "#ifndef BASE_H_SUN_JUN__3_20_15_57_2007\n#define BASE_H_SUN_JUN__3_20_15_57_2007\n\nint getdestaddr(int fd, const struct sockaddr_in *client, const struct sockaddr_in *bindaddr, struct sockaddr_in *destaddr);\nint apply_tcp_keepalive(int fd);\n\nuint32_t redsocks_conn_max();\nuint32_t connpres_idle_timeout();\nuint32_t max_accept_backoff_ms();\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* BASE_H_SUN_JUN__3_20_15_57_2007 */\n"
        },
        {
          "name": "base64.c",
          "type": "blob",
          "size": 3.095703125,
          "content": "/*\n * Copyright (c) 2006 Ryan Martell. (rdm4@martellventures.com)\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * @brief Base64 encode/decode\n * @author Ryan Martell <rdm4@martellventures.com> (with lots of Michael)\n */\n\n#include <limits.h>\n#include \"utils.h\"\n#include \"base64.h\"\n\n/* ---------------- private code */\nstatic const uint8_t map2[] =\n{\n    0x3e, 0xff, 0xff, 0xff, 0x3f, 0x34, 0x35, 0x36,\n    0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01,\n    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,\n    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1a, 0x1b,\n    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33\n};\n\nint base64_decode(uint8_t *out, const char *in, int out_size)\n{\n    int i, v;\n    uint8_t *dst = out;\n\n    v = 0;\n    for (i = 0; in[i] && in[i] != '='; i++) {\n        unsigned int index= in[i]-43;\n        if (index>=SIZEOF_ARRAY(map2) || map2[index] == 0xff)\n            return -1;\n        v = (v << 6) + map2[index];\n        if (i & 3) {\n            if (dst - out < out_size) {\n                *dst++ = v >> (6 - 2 * (i & 3));\n            }\n        }\n    }\n\n    return dst - out;\n}\n\n/*****************************************************************************\n* b64_encode: Stolen from VLC's http.c.\n* Simplified by Michael.\n* Fixed edge cases and made it work from data (vs. strings) by Ryan.\n*****************************************************************************/\n\nchar *base64_encode(char *out, int out_size, const uint8_t *in, int in_size)\n{\n    static const char b64[] =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    char *ret, *dst;\n    unsigned i_bits = 0;\n    int i_shift = 0;\n    int bytes_remaining = in_size;\n\n    if (in_size >= UINT_MAX / 4 ||\n        out_size < BASE64_SIZE(in_size))\n        return NULL;\n    ret = dst = out;\n    while (bytes_remaining) {\n        i_bits = (i_bits << 8) + *in++;\n        bytes_remaining--;\n        i_shift += 8;\n\n        do {\n            *dst++ = b64[(i_bits << 6 >> i_shift) & 0x3f];\n            i_shift -= 6;\n        } while (i_shift > 6 || (bytes_remaining == 0 && i_shift > 0));\n    }\n    while ((dst - ret) & 3)\n        *dst++ = '=';\n    *dst = '\\0';\n\n    return ret;\n}\n"
        },
        {
          "name": "base64.h",
          "type": "blob",
          "size": 1.794921875,
          "content": "/*\n * Copyright (c) 2006 Ryan Martell. (rdm4@martellventures.com)\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef BASE64_H\n#define BASE64_H\n\n#include <stdint.h>\n\n/**\n * Decode a base64-encoded string.\n *\n * @param out      buffer for decoded data\n * @param in       null-terminated input string\n * @param out_size size in bytes of the out buffer, must be at\n *                 least 3/4 of the length of in\n * @return         number of bytes written, or a negative value in case of\n *                 invalid input\n */\nint base64_decode(uint8_t *out, const char *in, int out_size);\n\n/**\n * Encode data to base64 and null-terminate.\n *\n * @param out      buffer for encoded data\n * @param out_size size in bytes of the output buffer, must be at\n *                 least BASE64_SIZE(in_size)\n * @param in_size  size in bytes of the 'in' buffer\n * @return         'out' or NULL in case of error\n */\nchar *base64_encode(char *out, int out_size, const uint8_t *in, int in_size);\n\n/**\n * Calculate the output size needed to base64-encode x bytes.\n */\n#define BASE64_SIZE(x)  (((x)+2) / 3 * 4 + 1)\n\n#endif /* BASE64_H */\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug.c",
          "type": "blob",
          "size": 4.1904296875,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include \"parser.h\"\n#include \"main.h\"\n#include \"log.h\"\n#include \"utils.h\"\n#include <event2/http.h>\n#include <event2/buffer.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\ntypedef struct debug_instance_t {\n\tint configured;\n\tchar* http_ip;\n\tuint16_t http_port;\n\tstruct evhttp* http_server;\n} debug_instance;\n\nstatic debug_instance instance = {\n\t.configured = 0,\n};\n\nstatic parser_entry debug_entries[] =\n{\n\t{ .key = \"http_ip\", .type = pt_pchar },\n\t{ .key = \"http_port\", .type = pt_uint16 },\n\t{ }\n};\n\nstatic int debug_onenter(parser_section *section)\n{\n\tif (instance.configured) {\n\t\tparser_error(section->context, \"only one instance of debug is valid\");\n\t\treturn -1;\n\t}\n\tmemset(&instance, 0, sizeof(instance));\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr =\n\t\t\t(strcmp(entry->key, \"http_ip\") == 0) ? (void*)&instance.http_ip:\n\t\t\t(strcmp(entry->key, \"http_port\") == 0) ? (void*)&instance.http_port :\n\t\t\tNULL;\n\treturn 0;\n}\n\nstatic int debug_onexit(parser_section *section)\n{\n\tinstance.configured = 1;\n\tif (!instance.http_ip)\n\t\tinstance.http_ip = strdup(\"localhost\");\n\treturn 0;\n}\n\nstatic parser_section debug_conf_section =\n{\n\t.name    = \"debug\",\n\t.entries = debug_entries,\n\t.onenter = debug_onenter,\n\t.onexit  = debug_onexit,\n};\n\nstatic void debug_pipe(struct evhttp_request *req, void *arg)\n{\n\tUNUSED(arg);\n\tint fds[2];\n\tint code = (pipe(fds) == 0) ? HTTP_OK : HTTP_SERVUNAVAIL;\n\tevhttp_send_reply(req, code, NULL, NULL);\n}\nstatic void debug_meminfo_json(struct evhttp_request *req, void *arg)\n{\n\tUNUSED(arg);\n\n\tstruct evbuffer* body = evbuffer_new();\n\tevbuffer_add(body, \"{\", 1);\n\t\n\tFILE* fd = fopen(\"/proc/vmstat\", \"r\");\n\twhile (!feof(fd)) {\n\t\tchar buf[64];\n\t\tsize_t pages;\n\t\tif (fscanf(fd, \"%63s %zu\", buf, &pages) == 2 && strncmp(buf, \"nr_\", 3) == 0) {\n\t\t\tevbuffer_add_printf(body, \"\\\"%s\\\": %zu, \", buf, pages);\n\t\t}\n\t\tfor (int c = 0; c != EOF && c != '\\n'; c = fgetc(fd))\n\t\t\t;\n\t}\n\tfclose(fd);\n\n\tsize_t vmsize, rss, share, text, z, data;\n\tfd = fopen(\"/proc/self/statm\", \"r\");\n\tif (fscanf(fd, \"%zu %zu %zu %zu %zu %zu %zu\", &vmsize, &rss, &share, &text, &z, &data, &z) == 7) {\n\t\tevbuffer_add_printf(body,\n\t\t\t\"\\\"vmsize\\\": %zu, \\\"vmrss\\\": %zu, \\\"share\\\": %zu, \\\"text\\\": %zu, \\\"data\\\": %zu, \",\n\t\t\tvmsize, rss, share, text, data);\n\t\t\n\t}\n\tfclose(fd);\n\tevbuffer_add_printf(body, \"\\\"getpagesize\\\": %d}\", getpagesize());\n\n\tevhttp_send_reply(req, HTTP_OK, NULL, body);\n\tevbuffer_free(body);\n}\n\nstatic int debug_fini();\n\nstatic int debug_init(struct event_base* evbase)\n{\n\tif (!instance.http_port)\n\t\treturn 0;\n\n\tinstance.http_server = evhttp_new(evbase);\n\tif (!instance.http_server) {\n\t\tlog_errno(LOG_ERR, \"evhttp_new()\");\n\t\tgoto fail;\n\t}\n\n\tif (evhttp_bind_socket(instance.http_server, instance.http_ip, instance.http_port) != 0) {\n\t\tlog_errno(LOG_ERR, \"evhttp_bind_socket()\");\n\t\tgoto fail;\n\t}\n\n\tif (evhttp_set_cb(instance.http_server, \"/debug/pipe\", debug_pipe, NULL) != 0) {\n\t\tlog_errno(LOG_ERR, \"evhttp_set_cb()\");\n\t\tgoto fail;\n\t}\n\n\tif (evhttp_set_cb(instance.http_server, \"/debug/meminfo.json\", debug_meminfo_json, NULL) != 0) {\n\t\tlog_errno(LOG_ERR, \"evhttp_set_cb()\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdebug_fini();\n\treturn -1;\n}\n\nstatic int debug_fini()\n{\n\tif (instance.http_server) {\n\t\tevhttp_free(instance.http_server);\n\t\tinstance.http_server = 0;\n\t}\n\tfree(instance.http_ip);\n\tmemset(&instance, 0, sizeof(instance));\n\treturn 0;\n}\n\napp_subsys debug_subsys =\n{\n\t.init = debug_init,\n\t.fini = debug_fini,\n\t.conf_section = &debug_conf_section,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "dnstc.c",
          "type": "blob",
          "size": 6.423828125,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\n#include \"list.h\"\n#include \"log.h\"\n#include \"parser.h\"\n#include \"main.h\"\n#include \"redsocks.h\"\n#include \"dnstc.h\"\n#include \"utils.h\"\n\n#define dnstc_log_error(prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 0, &clientaddr, &self->config.bindaddr, prio, ## msg)\n#define dnstc_log_errno(prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 1, &clientaddr, &self->config.bindaddr, prio, ## msg)\n\nstatic void dnstc_fini_instance(dnstc_instance *instance);\nstatic int dnstc_fini();\n\ntypedef struct dns_header_t {\n\tuint16_t id;\n\tuint8_t qr_opcode_aa_tc_rd;\n\tuint8_t ra_z_rcode;\n\tuint16_t qdcount;\n\tuint16_t ancount;\n\tuint16_t nscount;\n\tuint16_t arcount; // may be >0 for EDNS queries\n} PACKED dns_header;\n\n#define DNS_QR 0x80\n#define DNS_TC 0x02\n#define DNS_Z  0x70\n\n/***********************************************************************\n * Logic\n */\nstatic void dnstc_pkt_from_client(int fd, short what, void *_arg)\n{\n\tdnstc_instance *self = _arg;\n\tstruct sockaddr_in clientaddr;\n\tunion {\n\t\tchar raw[0xFFFF]; // UDP packet can't be larger then that\n\t\tdns_header h;\n\t} buf;\n\tssize_t pktlen, outgoing;\n\n\tassert(fd == event_get_fd(&self->listener));\n\tpktlen = red_recv_udp_pkt(fd, buf.raw, sizeof(buf), &clientaddr, NULL);\n\tif (pktlen == -1)\n\t\treturn;\n\n\tif (pktlen <= sizeof(dns_header)) {\n\t\tdnstc_log_error(LOG_INFO, \"incomplete DNS request\");\n\t\treturn;\n\t}\n\n\tif (1\n\t\t&& (buf.h.qr_opcode_aa_tc_rd & DNS_QR) == 0 /* query */\n\t\t&& (buf.h.ra_z_rcode & DNS_Z) == 0 /* Z is Zero */\n\t\t&& buf.h.qdcount /* some questions */\n\t\t&& !buf.h.ancount && !buf.h.nscount /* no answers */\n\t) {\n\t\tbuf.h.qr_opcode_aa_tc_rd |= DNS_QR;\n\t\tbuf.h.qr_opcode_aa_tc_rd |= DNS_TC;\n\t\toutgoing = sendto(fd, buf.raw, pktlen, 0,\n\t\t                  (struct sockaddr*)&clientaddr, sizeof(clientaddr));\n\t\tif (outgoing != pktlen)\n\t\t\tdnstc_log_errno(LOG_WARNING, \"sendto: I was sending %zd bytes, but only %zd were sent.\",\n\t\t\t                pktlen, outgoing);\n\t\telse\n\t\t\tdnstc_log_error(LOG_INFO, \"sent truncated DNS reply\");\n\t}\n\telse {\n\t\tdnstc_log_error(LOG_INFO, \"malformed DNS request\");\n\t}\n}\n\n/***********************************************************************\n * Init / shutdown\n */\nstatic parser_entry dnstc_entries[] =\n{\n\t{ .key = \"local_ip\",   .type = pt_in_addr },\n\t{ .key = \"local_port\", .type = pt_uint16 },\n\t{ }\n};\n\nstatic list_head instances = LIST_HEAD_INIT(instances);\n\nstatic int dnstc_onenter(parser_section *section)\n{\n\tdnstc_instance *instance = calloc(1, sizeof(*instance));\n\tif (!instance) {\n\t\tparser_error(section->context, \"Not enough memory\");\n\t\treturn -1;\n\t}\n\n\tINIT_LIST_HEAD(&instance->list);\n\tinstance->config.bindaddr.sin_family = AF_INET;\n\tinstance->config.bindaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr =\n\t\t\t(strcmp(entry->key, \"local_ip\") == 0)   ? (void*)&instance->config.bindaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"local_port\") == 0) ? (void*)&instance->config.bindaddr.sin_port :\n\t\t\tNULL;\n\tsection->data = instance;\n\treturn 0;\n}\n\nstatic int dnstc_onexit(parser_section *section)\n{\n\tdnstc_instance *instance = section->data;\n\n\tsection->data = NULL;\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr = NULL;\n\n\tinstance->config.bindaddr.sin_port = htons(instance->config.bindaddr.sin_port);\n\n\tlist_add(&instance->list, &instances);\n\n\treturn 0;\n}\n\nstatic int dnstc_init_instance(dnstc_instance *instance)\n{\n\t/* FIXME: dnstc_fini_instance is called in case of failure, this\n\t *        function will remove instance from instances list - result\n\t *        looks ugly.\n\t */\n\tint error;\n\tint fd = -1;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd == -1) {\n\t\tlog_errno(LOG_ERR, \"socket\");\n\t\tgoto fail;\n\t}\n\n\terror = bind(fd, (struct sockaddr*)&instance->config.bindaddr, sizeof(instance->config.bindaddr));\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"bind\");\n\t\tgoto fail;\n\t}\n\n\terror = fcntl_nonblock(fd);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"fcntl\");\n\t\tgoto fail;\n\t}\n\n\tevent_set(&instance->listener, fd, EV_READ | EV_PERSIST, dnstc_pkt_from_client, instance);\n\terror = event_add(&instance->listener, NULL);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"event_add\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdnstc_fini_instance(instance);\n\n\tif (fd != -1) {\n\t\tif (close(fd) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"close\");\n\t}\n\n\treturn -1;\n}\n\n/* Drops instance completely, freeing its memory and removing from\n * instances list.\n */\nstatic void dnstc_fini_instance(dnstc_instance *instance)\n{\n\tif (event_initialized(&instance->listener)) {\n\t\tif (event_del(&instance->listener) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"event_del\");\n\t\tif (close(event_get_fd(&instance->listener)) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"close\");\n\t\tmemset(&instance->listener, 0, sizeof(instance->listener));\n\t}\n\n\tlist_del(&instance->list);\n\n\tmemset(instance, 0, sizeof(*instance));\n\tfree(instance);\n}\n\nstatic int dnstc_init()\n{\n\tdnstc_instance *tmp, *instance = NULL;\n\n\t// TODO: init debug_dumper\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list) {\n\t\tif (dnstc_init_instance(instance) != 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdnstc_fini();\n\treturn -1;\n}\n\nstatic int dnstc_fini()\n{\n\tdnstc_instance *tmp, *instance = NULL;\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list)\n\t\tdnstc_fini_instance(instance);\n\n\treturn 0;\n}\n\nstatic parser_section dnstc_conf_section =\n{\n\t.name    = \"dnstc\",\n\t.entries = dnstc_entries,\n\t.onenter = dnstc_onenter,\n\t.onexit  = dnstc_onexit\n};\n\napp_subsys dnstc_subsys =\n{\n\t.init = dnstc_init,\n\t.fini = dnstc_fini,\n\t.conf_section = &dnstc_conf_section,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "dnstc.h",
          "type": "blob",
          "size": 0.3662109375,
          "content": "#ifndef DNSTC_H\n#define DNSTC_H\n\ntypedef struct dnstc_config_t {\n\tstruct sockaddr_in bindaddr;\n} dnstc_config;\n\ntypedef struct dnstc_instance_t {\n\tlist_head       list;\n\tdnstc_config    config;\n\tstruct event    listener;\n} dnstc_instance;\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* REDUDP_H */\n"
        },
        {
          "name": "dnsu2t.c",
          "type": "blob",
          "size": 13.7998046875,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <assert.h>\n#include <search.h>\n#include <errno.h>\n\n#include \"list.h\"\n#include \"log.h\"\n#include \"parser.h\"\n#include \"main.h\"\n#include \"redsocks.h\"\n#include \"dnsu2t.h\"\n#include \"utils.h\"\n\n#define dnsu2t_log_error(prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 0, &clientaddr, &self->config.bindaddr, prio, ## msg)\n#define dnsu2t_log_errno(prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 1, &clientaddr, &self->config.bindaddr, prio, ## msg)\n\nstatic void dnsu2t_fini_instance(dnsu2t_instance *instance);\nstatic int dnsu2t_fini();\nstatic void dnsu2t_pkt_from_client(int fd, short what, void *_arg);\nstatic void dnsu2t_pkt_from_relay(int fd, short what, void *_arg);\nstatic void dnsu2t_relay_writable(int fd, short what, void *_arg);\nstatic void dnsu2t_close_relay(dnsu2t_instance *self);\n\n// this DNS query (IN SOA for `.`) acts as in-band DNS ping\nstatic const uint8_t dnsq_soa_root[] = {\n\t0x00, 0x00, 0x01, 0x20,\n\t0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x06, 0x00, 0x01};\n\ntypedef struct inflight_req_t {\n\tuint16_t id; // in network byte order\n\tstruct sockaddr_in clientaddr;\n\n} inflight_req;\n\nstatic int inflight_cmp(const void *a, const void *b)\n{\n\treturn memcmp(a, b, sizeof(uint16_t));\n}\n\n/***********************************************************************\n * Logic\n */\nstatic void dnsu2t_pkt_from_client(int srvfd, short what, void *_arg)\n{\n\tdnsu2t_instance *self = _arg;\n\tstruct sockaddr_in clientaddr;\n\tssize_t pktlen;\n\tdns_tcp_pkt in;\n\n\tassert(srvfd == event_get_fd(&self->listener));\n\tpktlen = red_recv_udp_pkt(srvfd, in.dns.raw, sizeof(in.dns.raw), &clientaddr, NULL);\n\tif (pktlen == -1)\n\t\treturn;\n\n\tif (pktlen <= sizeof(dns_header)) {\n\t\tdnsu2t_log_error(LOG_NOTICE, \"incomplete DNS request\");\n\t\treturn;\n\t}\n\n\tif (pktlen > 0xffff\n\t\t|| (in.dns.hdr.qr_opcode_aa_tc_rd & DNS_QR) != 0 /* not a query */\n\t\t|| in.dns.hdr.qdcount == 0 /* no questions */\n\t\t|| in.dns.hdr.ancount || in.dns.hdr.nscount /* some answers */\n\t) {\n\t\tdnsu2t_log_error(LOG_NOTICE, \"malformed DNS request\");\n\t\treturn;\n\t}\n\n\tinflight_req **preq = tfind(&in.dns.hdr.id, &self->inflight_root, inflight_cmp);\n\tif (preq) {\n\t\t// Technically, it's possible to re-number request and maintain matching\n\t\t// for up to 65535 in-flight requests, but I'm a bit lazy for that.\n\t\tassert((*preq)->id == in.dns.hdr.id);\n\t\tif (memcmp(&(*preq)->clientaddr, &clientaddr, sizeof(clientaddr)) != 0) {\n\t\t\t// that's not just re-transmission\n\t\t\tchar other_addr[RED_INET_ADDRSTRLEN];\n\t\t\tdnsu2t_log_error(LOG_WARNING, \"DNS request #%04x already in-flight from %s, renumbering not implemented\",\n\t\t\t\t\tntohs(in.dns.hdr.id),\n\t\t\t\t\tred_inet_ntop(&(*preq)->clientaddr, other_addr, sizeof(other_addr)));\n\t\t}\n\t\treturn;\n\t}\n\n\tin.sz = htons((uint16_t)pktlen);\n\tpktlen += sizeof(in.sz);\n\n\tint fd = -1;\n\tinflight_req *node = calloc(1, sizeof(inflight_req));\n\tnode->id = in.dns.hdr.id;\n\tnode->clientaddr = clientaddr;\n\n\tint sent;\n\tif (!event_initialized(&self->relay_rd)) {\n\t\tfd = red_socket_client(SOCK_STREAM);\n\t\tif (fd < 0)\n\t\t\tgoto fail;\n\n\t\tevent_set(&self->relay_rd, fd, EV_READ | EV_PERSIST, dnsu2t_pkt_from_relay, self);\n\t\tevent_set(&self->relay_wr, fd, EV_WRITE, dnsu2t_relay_writable, self);\n\t\tfd = -1;\n\n\t\t// The timeout on a persistent event resets whenever the event's callback runs.\n\t\tconst struct timeval relay_timeout = { .tv_sec = self->config.relay_timeout };\n\t\tif (event_add(&self->relay_rd, &relay_timeout) != 0) {\n\t\t\tdnsu2t_log_error(LOG_ERR, \"event_add\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (event_add(&self->relay_wr, &relay_timeout) != 0) {\n\t\t\tdnsu2t_log_error(LOG_ERR, \"event_add\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t// MSG_FASTOPEN is available since Linux 3.6 released on 30 Sep 2012\n\t\tsent = sendto(event_get_fd(&self->relay_rd), &in, pktlen, MSG_FASTOPEN,\n\t\t\t(struct sockaddr*)&self->config.relayaddr, sizeof(self->config.relayaddr));\n\t\t// Also, socket is not writable, right after MSG_FASTOPEN, so listener\n\t\t// should be temporary disabled.\n\t\tif (event_del(&self->listener))\n\t\t\tdnsu2t_log_error(LOG_ERR, \"event_del\");\n\t} else {\n\t\tsent = write(event_get_fd(&self->relay_rd), &in, pktlen);\n\t}\n\n\tif (sent == pktlen || (sent == -1 && errno == EINPROGRESS)) {\n\t\tself->request_count++;\n\t\tself->inflight_count++;\n\t\tif (self->inflight_count >= self->config.inflight_max) {\n\t\t\tif (event_del(&self->listener))\n\t\t\t\tdnsu2t_log_error(LOG_ERR, \"event_del\");\n\t\t}\n\t\tinflight_req **new = tsearch(node, &self->inflight_root, inflight_cmp);\n\t\tif (!new)\n\t\t\tabort(); // ultimate ENOMEM handler\n\t\tassert(*new == node); // WAT?\n\t\tnode = NULL;\n\t\tdnsu2t_log_error(LOG_DEBUG, \"DNS request #%04x\", ntohs(in.dns.hdr.id));\n\n\t}\n\telse if (sent == -1) {\n\t\tdnsu2t_log_errno(LOG_DEBUG, \"DNS request #%04x write()\", ntohs(in.dns.hdr.id));\n\t\tgoto fail;\n\t}\n\telse if (sent != pktlen) {\n\t\tdnsu2t_log_error(LOG_WARNING, \"short write is not handled\");\n\t\tif (shutdown(fd, SHUT_WR) != 0)\n\t\t\tdnsu2t_log_error(LOG_ERR, \"shutdown\");\n\t\t// no more writes to broken stream, but that's not fatal failure\n\t\tif (event_del(&self->listener))\n\t\t\tdnsu2t_log_error(LOG_ERR, \"event_del\");\n\t\tself->reqstream_broken = true;\n\t}\n\n\treturn;\n\nfail:\n\tif (fd != -1)\n\t\tredsocks_close(fd);\n\tif (node)\n\t\tfree(node);\n\tdnsu2t_close_relay(self);\n}\n\nstatic void free_inflight_req(void *p)\n{\n\tinflight_req *preq = p;\n\tfree(preq);\n}\n\nstatic void dnsu2t_close_relay(dnsu2t_instance *self)\n{\n\tif (event_initialized(&self->relay_rd)) {\n\t\tint fd = event_get_fd(&self->relay_rd);\n\t\tassert(fd == event_get_fd(&self->relay_wr));\n\t\tif (event_del(&self->relay_rd) == -1)\n\t\t\tlog_error(LOG_ERR, \"event_del\");\n\t\tif (event_del(&self->relay_wr) == -1)\n\t\t\tlog_error(LOG_ERR, \"event_del\");\n\t\tredsocks_close(fd);\n\t\tmemset(&self->relay_rd, 0, sizeof(self->relay_rd));\n\t\tmemset(&self->relay_wr, 0, sizeof(self->relay_wr));\n\n\t\t// possibly `listener` is temporary disabled and we're in connection\n\t\t// cleanup code path, so let's enable it back\n\t\tif (!event_pending(&self->listener, EV_READ, NULL)) {\n\t\t\tif (event_add(&self->listener, NULL) != 0) {\n\t\t\t\tlog_error(LOG_ERR, \"event_del\");\n\t\t\t}\n\t\t}\n\t}\n\tif (self->inflight_count) {\n\t\tlog_error(LOG_WARNING, \"%d in-flight DNS request lost (%d served)\", self->inflight_count, self->request_count - self->inflight_count);\n\t}\n\ttdestroy(self->inflight_root, free_inflight_req);\n\tself->inflight_root = NULL; // WTF?\n\tself->inflight_count = 0;\n\tself->request_count = 0;\n\tself->reqstream_broken = false;\n\t// assert(!!self->inflight_count == !!self->inflight_root);\n}\n\nvoid dnsu2t_relay_writable(int fd, short what, void *_arg)\n{\n\tdnsu2t_instance *self = _arg;\n\tassert(event_get_fd(&self->relay_wr) == fd);\n\tif ((what & EV_WRITE) && self->inflight_count < self->config.inflight_max && !self->reqstream_broken) {\n\t\tif (event_add(&self->listener, NULL) != 0)\n\t\t\tlog_errno(LOG_ERR, \"event_add\");\n\t}\n}\n\nvoid dnsu2t_pkt_from_relay(int fd, short what, void *_arg)\n{\n\tdnsu2t_instance *self = _arg;\n\tassert(event_get_fd(&self->relay_rd) == fd);\n\n\tif (what & EV_READ) {\n\t\tchar* dst = ((char*)&self->pkt) + self->pkt_size;\n\t\tif (self->pkt_size)\n\t\t\tlog_error(LOG_DEBUG, \"partial packet, off=%lu\", self->pkt_size);\n\t\tconst size_t bufsz = sizeof(self->pkt) - self->pkt_size;\n\t\tassert(bufsz > 0 && self->pkt_size >= 0);\n\t\tssize_t rcvd = recv(fd, dst, bufsz, 0);\n\t\tif (rcvd > 0) {\n\t\t\tself->pkt_size += rcvd;\n\t\t\twhile (self->pkt_size >= sizeof(self->pkt.sz)) {\n\t\t\t\tconst ssize_t pktlen = ntohs(self->pkt.sz);\n\t\t\t\tconst ssize_t tcplen = pktlen + sizeof(self->pkt.sz);\n\t\t\t\tif (pktlen <= sizeof(dns_header)) {\n\t\t\t\t\tlog_error(LOG_NOTICE, \"malformed DNS reply\");\n\t\t\t\t\tdnsu2t_close_relay(self);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (self->pkt_size >= tcplen) {\n\t\t\t\t\tinflight_req **preq = tfind(&self->pkt.dns.hdr.id, &self->inflight_root, inflight_cmp);\n\t\t\t\t\tif (preq) {\n\t\t\t\t\t\tinflight_req *req = *preq;\n\t\t\t\t\t\tassert(self->pkt.dns.hdr.id == req->id);\n\t\t\t\t\t\tlog_error(LOG_DEBUG, \"DNS reply #%04x\", ntohs(self->pkt.dns.hdr.id));\n\t\t\t\t\t\tint sent = sendto(event_get_fd(&self->listener),\n\t\t\t\t\t\t\t&self->pkt.dns, pktlen, 0,\n\t\t\t\t\t\t\t(struct sockaddr*)&req->clientaddr, sizeof(req->clientaddr));\n\t\t\t\t\t\tif (sent == -1) {\n\t\t\t\t\t\t\tlog_errno(LOG_WARNING, \"sendto\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sent != pktlen) {\n\t\t\t\t\t\t\tlog_errno(LOG_WARNING, \"short sendto\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself->inflight_count--;\n\t\t\t\t\t\tif (self->inflight_count < self->config.inflight_max && !self->reqstream_broken) {\n\t\t\t\t\t\t\tif (event_add(&self->listener, NULL))\n\t\t\t\t\t\t\t\tlog_error(LOG_ERR, \"event_del\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinflight_req* parent = tdelete(req, &self->inflight_root, inflight_cmp);\n\t\t\t\t\t\tassert(parent);\n\t\t\t\t\t\tfree(req);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog_error(LOG_NOTICE, \"DNS reply #%04x unexpected\",\n\t\t\t\t\t\t\t\tntohs(self->pkt.dns.hdr.id));\n\t\t\t\t\t}\n\t\t\t\t\tif (self->pkt_size == tcplen) {\n\t\t\t\t\t\tself->pkt_size = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar* src = ((char*)&self->pkt) + tcplen;\n\t\t\t\t\t\tself->pkt_size -= tcplen;\n\t\t\t\t\t\tmemmove(&self->pkt, src, self->pkt_size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // nothing to consume so far\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (rcvd == 0) {\n\t\t\tlog_error(LOG_DEBUG, \"EOF from DNS server\");\n\t\t\tdnsu2t_close_relay(self);\n\t\t}\n\t\telse {\n\t\t\tlog_errno(LOG_DEBUG, \"recv\");\n\t\t\tdnsu2t_close_relay(self);\n\t\t}\n\t}\n\tif (what & EV_TIMEOUT) {\n\t\tlog_error(LOG_DEBUG, \"TIMEOUT from DNS server\");\n\t\tdnsu2t_close_relay(self);\n\t}\n}\n\n/***********************************************************************\n * Init / shutdown\n */\nstatic parser_entry dnsu2t_entries[] =\n{\n\t{ .key = \"local_ip\",        .type = pt_in_addr },\n\t{ .key = \"local_port\",      .type = pt_uint16 },\n\t{ .key = \"remote_ip\",       .type = pt_in_addr },\n\t{ .key = \"remote_port\",     .type = pt_uint16 },\n\t{ .key = \"remote_timeout\",  .type = pt_uint16 },\n\t{ .key = \"inflight_max\",    .type = pt_uint16 },\n\t{ }\n};\n\nstatic list_head instances = LIST_HEAD_INIT(instances);\n\nstatic int dnsu2t_onenter(parser_section *section)\n{\n\tdnsu2t_instance *instance = calloc(1, sizeof(*instance));\n\tif (!instance) {\n\t\tparser_error(section->context, \"Not enough memory\");\n\t\treturn -1;\n\t}\n\n\tINIT_LIST_HEAD(&instance->list);\n\tinstance->config.bindaddr.sin_family = AF_INET;\n\tinstance->config.bindaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tinstance->config.bindaddr.sin_port = htons(53);;\n\tinstance->config.relayaddr.sin_family = AF_INET;\n\tinstance->config.relayaddr.sin_port = htons(53);\n\tinstance->config.relay_timeout = 30;\n\tinstance->config.inflight_max = 16;\n\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr =\n\t\t\t(strcmp(entry->key, \"local_ip\") == 0)   ? (void*)&instance->config.bindaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"local_port\") == 0) ? (void*)&instance->config.bindaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"remote_ip\") == 0)  ? (void*)&instance->config.relayaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"remote_port\") == 0)? (void*)&instance->config.relayaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"remote_timeout\") == 0)? (void*)&instance->config.relay_timeout:\n\t\t\t(strcmp(entry->key, \"inflight_max\") == 0)? (void*)&instance->config.inflight_max :\n\t\t\tNULL;\n\tsection->data = instance;\n\treturn 0;\n}\n\nstatic int dnsu2t_onexit(parser_section *section)\n{\n\tdnsu2t_instance *instance = section->data;\n\n\tsection->data = NULL;\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr = NULL;\n\n\tinstance->config.bindaddr.sin_port = htons(instance->config.bindaddr.sin_port);\n\tinstance->config.relayaddr.sin_port = htons(instance->config.relayaddr.sin_port);\n\n\tlist_add(&instance->list, &instances);\n\n\treturn 0;\n}\n\nstatic int dnsu2t_init_instance(dnsu2t_instance *instance)\n{\n\tint error;\n\tint fd = red_socket_server(SOCK_DGRAM, &instance->config.bindaddr);\n\n\tif (fd == -1) {\n\t\tgoto fail;\n\t}\n\n\tevent_set(&instance->listener, fd, EV_READ | EV_PERSIST, dnsu2t_pkt_from_client, instance);\n\terror = event_add(&instance->listener, NULL);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"event_add\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdnsu2t_fini_instance(instance);\n\n\tif (fd != -1) {\n\t\tif (close(fd) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"close\");\n\t}\n\n\treturn -1;\n}\n\n/* Drops instance completely, freeing its memory and removing from\n * instances list.\n */\nstatic void dnsu2t_fini_instance(dnsu2t_instance *instance)\n{\n\tdnsu2t_close_relay(instance);\n\n\tif (event_initialized(&instance->listener)) {\n\t\tif (event_del(&instance->listener) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"event_del\");\n\t\tif (close(event_get_fd(&instance->listener)) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"close\");\n\t\tmemset(&instance->listener, 0, sizeof(instance->listener));\n\t}\n\n\tlist_del(&instance->list);\n\n\tmemset(instance, 0, sizeof(*instance));\n\tfree(instance);\n}\n\nstatic int dnsu2t_init()\n{\n\tdnsu2t_instance *tmp, *instance = NULL;\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list) {\n\t\tif (dnsu2t_init_instance(instance) != 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdnsu2t_fini();\n\treturn -1;\n}\n\nstatic int dnsu2t_fini()\n{\n\tdnsu2t_instance *tmp, *instance = NULL;\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list)\n\t\tdnsu2t_fini_instance(instance);\n\n\treturn 0;\n}\n\nstatic parser_section dnsu2t_conf_section =\n{\n\t.name    = \"dnsu2t\",\n\t.entries = dnsu2t_entries,\n\t.onenter = dnsu2t_onenter,\n\t.onexit  = dnsu2t_onexit\n};\n\napp_subsys dnsu2t_subsys =\n{\n\t.init = dnsu2t_init,\n\t.fini = dnsu2t_fini,\n\t.conf_section = &dnsu2t_conf_section,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "dnsu2t.h",
          "type": "blob",
          "size": 1.150390625,
          "content": "#ifndef DNSU2T_H\n#define DNSU2T_H\n\n#include \"utils.h\"\n\ntypedef struct dnsu2t_config_t {\n\tstruct sockaddr_in bindaddr;\n\tstruct sockaddr_in relayaddr;\n\tuint16_t           relay_timeout;\n\tuint16_t           inflight_max;\n} dnsu2t_config;\n\ntypedef struct dns_header_t {\n\tuint16_t id;\n\tuint8_t qr_opcode_aa_tc_rd;\n\tuint8_t ra_z_rcode;\n\tuint16_t qdcount;\n\tuint16_t ancount;\n\tuint16_t nscount;\n\tuint16_t arcount; // may be >0 for EDNS queries\n} PACKED dns_header;\n\n#define DNS_QR 0x80\n#define DNS_TC 0x02\n#define DNS_Z  0x70\n\ntypedef struct dns_tcp_pkt_t {\n\tuint16_t sz;\n\tunion {\n\t\tdns_header hdr;\n\t\tchar raw[0xffff];\n\t} dns;\n} PACKED dns_tcp_pkt;\n\ntypedef struct dnsu2t_instance_t {\n\tlist_head          list;\n\tdnsu2t_config      config;\n\tstruct event       listener;\n\n\tstruct event       relay_rd;\n\tstruct event       relay_wr;\n\n\tbool               reqstream_broken;\n\tint                request_count;\n\tint                inflight_count;\n\tvoid*              inflight_root;\n\n\tssize_t            pkt_size;\n\tdns_tcp_pkt        pkt;\n} dnsu2t_instance;\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* DNSU2T_H */\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "http-auth.c",
          "type": "blob",
          "size": 7.765625,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n *\n * http-auth library, provide basic and digest scheme\n *\t see RFC 2617 for details \n */\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"md5.h\"\n#include \"base64.h\"\n#include \"log.h\"\n#include \"http-auth.h\"\n\nchar* basic_authentication_encode(const char *user, const char *passwd)\n{\n\t/* prepare the user:pass key pair */\n\tint pair_len = strlen(user) + 1 + strlen(passwd);\n\tchar pair[pair_len + 1];\n\n\tsprintf(pair, \"%s:%s\", user, passwd);\n\n\t/* calculate the final string length */\n\tint basic_len = BASE64_SIZE(pair_len);\n\tchar *basic_ptr = calloc(basic_len + 1, 1);\n\n\tif (!base64_encode(basic_ptr, basic_len, (const uint8_t*)pair, pair_len))\n\t\treturn NULL;\n\n\treturn basic_ptr;\n}\n\n#define MD5_HASHLEN (16)\n\nstatic void dump_hash(char *buf, const unsigned char *hash) \n{\n\tint i;\n\n\tfor (i = 0; i < MD5_HASHLEN; i++) {\n\t\tbuf += sprintf(buf, \"%02x\", hash[i]);\n\t}\n\n\t*buf = 0;\n}\n\ntypedef struct {\n\tconst char *b, *e;\n} param_token;\n\n/* Extract a parameter from the string (typically an HTTP header) at\n   **SOURCE and advance SOURCE to the next parameter.  Return false\n   when there are no more parameters to extract.  The name of the\n   parameter is returned in NAME, and the value in VALUE.  If the\n   parameter has no value, the token's b==e.*/\n\nstatic int extract_param(const char **source, param_token *name, param_token *value, char separator)\n{\n\tconst char *p = *source;\n\n\twhile (isspace (*p)) \n\t\t++p;\n\n\tif (!*p)\n\t{\n\t\t*source = p;\n\t\treturn 0;             /* no error; nothing more to extract */\n\t}\n\n\t/* Extract name. */\n\tname->b = p;\n\twhile (*p && !isspace (*p) && *p != '=' && *p != separator) \n\t\t++p;\n\tname->e = p;\n\tif (name->b == name->e)\n\t\treturn 0;               /* empty name: error */\n\n\twhile (isspace (*p)) \n\t\t++p;\n\tif (*p == separator || !*p)           /* no value */\n\t{\n\t\tvalue->b = value->e = \"\";\n\t\tif (*p == separator) ++p;\n\t\t*source = p;\n\t\treturn 1;\n\t}\n\tif (*p != '=')\n\t\treturn 0;               /* error */\n\n\t/* *p is '=', extract value */\n\t++p;\n\twhile (isspace (*p)) ++p;\n\tif (*p == '\"')                /* quoted */\n\t{\n\t\tvalue->b = ++p;\n\t\twhile (*p && *p != '\"') ++p;\n\t\tif (!*p)\n\t\t\treturn 0;\n\t\tvalue->e = p++;\n\t\t/* Currently at closing quote; find the end of param. */\n\t\twhile (isspace (*p)) ++p;\n\t\twhile (*p && *p != separator) ++p;\n\t\tif (*p == separator)\n\t\t\t++p;\n\t\telse if (*p)\n\t\t\t/* garbage after closed quote, e.g. foo=\"bar\"baz */\n\t\t\treturn 0;\n\t}\n\telse                          /* unquoted */\n\t{\n\t\tvalue->b = p;\n\t\twhile (*p && *p != separator) ++p;\n\t\tvalue->e = p;\n\t\twhile (value->e != value->b && isspace (value->e[-1]))\n\t\t\t--value->e;\n\t\tif (*p == separator) ++p;\n\t}\n\t*source = p;\n\treturn 1;\n\n}\n\nchar* digest_authentication_encode(const char *line, const char *user, const char *passwd, \n\t\tconst char *method, const char *path, int count, const char *cnonce)\n{\n\tchar *realm = NULL, *opaque = NULL, *nonce = NULL, *qop = NULL;\n\tchar nc[9];\n\tsprintf(nc, \"%08x\", count);\n\n\tconst char *ptr = line;\n\tparam_token name, value;\n\n\twhile (extract_param(&ptr, &name, &value, ',')) {\n\t\tint namelen = name.e - name.b;\n\t\tint valuelen = value.e - value.b;\n\t\t\n\t\tif (strncasecmp(name.b, \"realm\" , namelen) == 0) {\n\t\t\tstrncpy(realm  = calloc(valuelen + 1, 1), value.b, valuelen);\n\t\t\trealm[valuelen] = '\\0';\n\t\t}\n\t\telse if (strncasecmp(name.b, \"opaque\", namelen) == 0) {\n\t\t\tstrncpy(opaque = calloc(valuelen + 1, 1), value.b, valuelen);\n\t\t\topaque[valuelen] = '\\0';\n\t\t}\n\t\telse if (strncasecmp(name.b, \"nonce\" , namelen) == 0) {\n\t\t\tstrncpy(nonce  = calloc(valuelen + 1, 1), value.b, valuelen);\n\t\t\tnonce[valuelen] = '\\0';\n\t\t}\n\t\telse if (strncasecmp(name.b, \"qop\"   , namelen) == 0) {\n\t\t\tstrncpy(qop    = calloc(valuelen + 1, 1), value.b, valuelen);\n\t\t\tqop[valuelen] = '\\0';\n\t\t}\n\t}\n\n\tif (!realm || !nonce || !user || !passwd || !path || !method) {\n\t\tfree(realm);\n\t\tfree(opaque);\n\t\tfree(nonce);\n\t\tfree(qop);\n\t\treturn NULL;\n\t}\n\n\tif (qop && strncasecmp(qop, \"auth\", 5) != 0) {\n\t\t/* FIXME: currently don't support auth-int, only \"auth\" is supported */\n\t\tfree(realm);\n\t\tfree(opaque);\n\t\tfree(nonce);\n\t\tfree(qop);\n\t\treturn NULL;\n\t}\n\n\t/* calculate the digest value */\n\tmd5_state_t ctx;\n\tmd5_byte_t hash[MD5_HASHLEN];\n\tchar a1buf[MD5_HASHLEN * 2 + 1], a2buf[MD5_HASHLEN * 2 + 1];\n\tchar response[MD5_HASHLEN * 2 + 1];\n\n\t/* A1 = username-value \":\" realm-value \":\" passwd */\n\tmd5_init(&ctx);\n\tmd5_append(&ctx, (md5_byte_t*)user, strlen(user));\n\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\tmd5_append(&ctx, (md5_byte_t*)realm, strlen(realm));\n\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\tmd5_append(&ctx, (md5_byte_t*)passwd, strlen(passwd));\n\tmd5_finish(&ctx, hash);\n\tdump_hash(a1buf, hash);\n\n\t/* A2 = Method \":\" digest-uri-value */\n\tmd5_init(&ctx);\n\tmd5_append(&ctx, (md5_byte_t*)method, strlen(method));\n\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\tmd5_append(&ctx, (md5_byte_t*)path, strlen(path));\n\tmd5_finish(&ctx, hash);\n\tdump_hash(a2buf, hash);\n\n\t/* qop set: request-digest = H(A1) \":\" nonce-value \":\" nc-value \":\" cnonce-value \":\" qop-value \":\" H(A2) */\n\t/* not set: request-digest = H(A1) \":\" nonce-value \":\" H(A2) */\n\tmd5_init(&ctx);\n\tmd5_append(&ctx, (md5_byte_t*)a1buf, strlen(a1buf));\n\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\tmd5_append(&ctx, (md5_byte_t*)nonce, strlen(nonce));\n\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\tif (qop) {\n\t\tmd5_append(&ctx, (md5_byte_t*)nc, strlen(nc));\n\t\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\t\tmd5_append(&ctx, (md5_byte_t*)cnonce, strlen(cnonce));\n\t\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\t\tmd5_append(&ctx, (md5_byte_t*)qop, strlen(qop));\n\t\tmd5_append(&ctx, (md5_byte_t*)\":\", 1);\n\t}\n\tmd5_append(&ctx, (md5_byte_t*)a2buf, strlen(a2buf));\n\tmd5_finish(&ctx, hash);\n\tdump_hash(response, hash);\n\n\t/* prepare the final string */\n\tint len = 256;\n\tlen += strlen(user);\n\tlen += strlen(realm);\n\tlen += strlen(nonce);\n\tlen += strlen(path);\n\tlen += strlen(response);\n\n\tif (qop) {\n\t\tlen += strlen(qop);\n\t\tlen += strlen(nc);\n\t\tlen += strlen(cnonce);\n\t}\n\n\tif (opaque) {\n\t\tlen += strlen(opaque);\n\t}\n\n\tchar *res = (char*)malloc(len);\n\tif (!qop) {\n\t\tsprintf(res, \"username=\\\"%s\\\", realm=\\\"%s\\\", nonce=\\\"%s\\\", uri=\\\"%s\\\", response=\\\"%s\\\"\", \n\t\t\t\tuser, realm, nonce, path, response);\n\t} else {\n\t\tsprintf(res, \"username=\\\"%s\\\", realm=\\\"%s\\\", nonce=\\\"%s\\\", uri=\\\"%s\\\", response=\\\"%s\\\", qop=%s, nc=%s, cnonce=\\\"%s\\\"\",\n\t\t\t\tuser, realm, nonce, path, response, qop, nc, cnonce);\n\t}\n\n\tif (opaque) {\n\t\tchar *p = res + strlen(res);\n\t\tstrcat (p, \", opaque=\\\"\");\n\t\tstrcat (p, opaque);\n\t\tstrcat (p, \"\\\"\");\n\t}\n\n\tfree(realm);\n\tfree(opaque);\n\tfree(nonce);\n\tfree(qop);\n\treturn res;\n}\n\nconst char *auth_request_header = \"Proxy-Authenticate:\";\nconst char *auth_response_header = \"Proxy-Authorization:\";\n\nchar *http_auth_request_header(struct evbuffer *src, struct evbuffer *tee)\n{\n\tchar *line;\n\tfor (;;) {\n\t\tline = redsocks_evbuffer_readline(src);\n\t\tif (tee && line) {\n\t\t\tif (evbuffer_add(tee, line, strlen(line)) != 0 ||\n\t\t\t    evbuffer_add(tee, \"\\r\\n\", 2) != 0)\n\t\t\t{\n\t\t\t\tlog_error(LOG_NOTICE, \"evbuffer_add\");\n\t\t\t\tfree(line);\n\t\t\t\treturn NULL; // I'm going up straight to the 403...\n\t\t\t}\n\t\t}\n\t\t// FIXME: multi-line headers are not supported\n\t\tif (line == NULL || *line == '\\0' || strchr(line, ':') == NULL) {\n\t\t\tfree(line);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (strncasecmp(line, auth_request_header, strlen(auth_request_header)) == 0)\n\t\t\treturn line;\n\t\tfree(line);\n\t}\n}\n"
        },
        {
          "name": "http-auth.h",
          "type": "blob",
          "size": 0.900390625,
          "content": "#ifndef HTTP_AUTH_H\n#define HTTP_AUTH_H\n\n#include \"redsocks.h\"\n\ntypedef struct http_auth_t {\n\tchar *last_auth_query;\n\tint last_auth_count;\n} http_auth;\n\nstatic inline http_auth* red_http_auth(redsocks_instance *i)\n{\n\treturn (http_auth*)(i + 1);\n}\n\n/*\n * Create the authentication header contents for the `Basic' scheme.\n * This is done by encoding the string \"USER:PASS\" to base64 and\n * prepending the string \"Basic \" in front of it.\n *\n */\n\nchar* basic_authentication_encode(const char *user, const char *passwd);\n\n/*\n * Create the authentication header contents for the 'Digest' scheme.\n * only md5 method is available, see RFC 2617 for detail.\n *\n */\nchar* digest_authentication_encode(const char *line, const char *user, const char *passwd, \n\t\tconst char *method, const char *path, int count, const char *cnonce);\n\nchar *http_auth_request_header(struct evbuffer *src, struct evbuffer *tee);\n\n#endif /* HTTP_AUTH_H */\n"
        },
        {
          "name": "http-connect.c",
          "type": "blob",
          "size": 9.7734375,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n *\n * http-connect upstream module for redsocks\n */\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"log.h\"\n#include \"redsocks.h\"\n#include \"http-auth.h\"\n\ntypedef enum httpc_state_t {\n\thttpc_new,\n\thttpc_request_sent,\n\thttpc_reply_came, // 200 OK came, skipping headers...\n\thttpc_headers_skipped, // starting pump!\n\thttpc_no_way, // proxy can't handle the request\n\thttpc_MAX,\n} httpc_state;\n\n\n#define HTTP_HEAD_WM_HIGH 4096  // that should be enough for one HTTP line.\n\n\nstatic void httpc_client_init(redsocks_client *client)\n{\n\tclient->state = httpc_new;\n}\n\nstatic void httpc_instance_fini(redsocks_instance *instance)\n{\n\thttp_auth *auth = red_http_auth(instance);\n\tfree(auth->last_auth_query);\n\tauth->last_auth_query = NULL;\n}\n\nstatic struct evbuffer *httpc_mkconnect(redsocks_client *client);\n\nextern const char *auth_request_header;\nextern const char *auth_response_header;\n\nstatic void httpc_read_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\n\tassert(client->relay == buffev);\n\tassert(client->state == httpc_request_sent || client->state == httpc_reply_came);\n\n\tredsocks_touch_client(client);\n\n\t// evbuffer_add() triggers callbacks, so we can't write to client->client\n\t// till we know that we're going to ONFAIL_FORWARD_HTTP_ERR.\n\t// And the decision is made when all the headers are processed.\n\tstruct evbuffer* tee = NULL;\n\tconst bool do_errtee = client->instance->config.on_proxy_fail == ONFAIL_FORWARD_HTTP_ERR;\n\n\tif (client->state == httpc_request_sent) {\n\t\tsize_t len = evbuffer_get_length(buffev->input);\n\t\tchar *line = redsocks_evbuffer_readline(buffev->input);\n\t\tif (line) {\n\t\t\tunsigned int code;\n\t\t\tif (sscanf(line, \"HTTP/%*u.%*u %u\", &code) == 1) { // 1 == one _assigned_ match\n\t\t\t\tif (code == 407) { // auth failed\n\t\t\t\t\thttp_auth *auth = red_http_auth(client->instance);\n\n\t\t\t\t\tif (auth->last_auth_query != NULL && auth->last_auth_count == 1) {\n\t\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy auth failed: %s\", line);\n\t\t\t\t\t\tclient->state = httpc_no_way;\n\t\t\t\t\t} else if (client->instance->config.login == NULL || client->instance->config.password == NULL) {\n\t\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy auth required, but no login/password configured: %s\", line);\n\t\t\t\t\t\tclient->state = httpc_no_way;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (do_errtee)\n\t\t\t\t\t\t\ttee = evbuffer_new();\n\t\t\t\t\t\tchar *auth_request = http_auth_request_header(buffev->input, tee);\n\t\t\t\t\t\tif (!auth_request) {\n\t\t\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy auth required, but no <%s> header found: %s\", auth_request_header, line);\n\t\t\t\t\t\t\tclient->state = httpc_no_way;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfree(line);\n\t\t\t\t\t\t\tif (tee)\n\t\t\t\t\t\t\t\tevbuffer_free(tee);\n\t\t\t\t\t\t\tfree(auth->last_auth_query);\n\t\t\t\t\t\t\tchar *ptr = auth_request;\n\n\t\t\t\t\t\t\tptr += strlen(auth_request_header);\n\t\t\t\t\t\t\twhile (isspace(*ptr))\n\t\t\t\t\t\t\t\tptr++;\n\n\t\t\t\t\t\t\tsize_t last_auth_query_len = strlen(ptr) + 1;\n\t\t\t\t\t\t\tauth->last_auth_query = calloc(last_auth_query_len, 1);\n\t\t\t\t\t\t\tmemcpy(auth->last_auth_query, ptr, last_auth_query_len);\n\t\t\t\t\t\t\tauth->last_auth_count = 0;\n\n\t\t\t\t\t\t\tfree(auth_request);\n\n\t\t\t\t\t\t\tif (bufferevent_disable(client->relay, EV_WRITE)) {\n\t\t\t\t\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_disable\");\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* close relay tunnel */\n\t\t\t\t\t\t\tredsocks_bufferevent_free(client->relay);\n\n\t\t\t\t\t\t\t/* set to initial state*/\n\t\t\t\t\t\t\tclient->state = httpc_new;\n\n\t\t\t\t\t\t\t/* and reconnect */\n\t\t\t\t\t\t\tredsocks_connect_relay(client);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (200 <= code && code <= 299) {\n\t\t\t\t\tclient->state = httpc_reply_came;\n\t\t\t\t} else {\n\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy error: %s\", line);\n\t\t\t\t\tclient->state = httpc_no_way;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy bad firstline: %s\", line);\n\t\t\t\tclient->state = httpc_no_way;\n\t\t\t}\n\t\t\tif (do_errtee && client->state == httpc_no_way) {\n\t\t\t\tif (bufferevent_write(client->client, line, strlen(line)) != 0 ||\n\t\t\t\t    bufferevent_write(client->client, \"\\r\\n\", 2) != 0)\n\t\t\t\t{\n\t\t\t\t\tredsocks_log_errno(client, LOG_NOTICE, \"bufferevent_write\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(line);\n\t\t}\n\t\telse if (len >= HTTP_HEAD_WM_HIGH) {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy reply is too long, %zu bytes\", len);\n\t\t\tclient->state = httpc_no_way;\n\t\t}\n\t}\n\n\tif (do_errtee && client->state == httpc_no_way) {\n\t\tif (tee) {\n\t\t\tif (bufferevent_write_buffer(client->client, tee) != 0) {\n\t\t\t\tredsocks_log_errno(client, LOG_NOTICE, \"bufferevent_write_buffer\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tredsocks_shutdown(client, client->client, SHUT_RD);\n\t\tconst size_t avail = evbuffer_get_length(client->client->input);\n\t\tif (avail) {\n\t\t\tif (evbuffer_drain(client->client->input, avail) != 0) {\n\t\t\t\tredsocks_log_errno(client, LOG_NOTICE, \"evbuffer_drain\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tredsocks_shutdown(client, client->relay, SHUT_WR);\n\t\tclient->state = httpc_headers_skipped;\n\t}\n\nfail:\n\tif (tee) {\n\t\tevbuffer_free(tee);\n\t}\n\n\tif (client->state == httpc_no_way) {\n\t\tredsocks_drop_client(client);\n\t\treturn;\n\t}\n\n\twhile (client->state == httpc_reply_came) {\n\t\tchar *line = redsocks_evbuffer_readline(buffev->input);\n\t\tif (line) {\n\t\t\tif (strlen(line) == 0) {\n\t\t\t\tclient->state = httpc_headers_skipped;\n\t\t\t}\n\t\t\tfree(line);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (client->state == httpc_headers_skipped) {\n\t\tredsocks_start_relay(client);\n\t}\n}\n\nstatic struct evbuffer *httpc_mkconnect(redsocks_client *client)\n{\n\tstruct evbuffer *buff = NULL, *retval = NULL;\n\tchar *auth_string = NULL;\n\tint len;\n\n\tbuff = evbuffer_new();\n\tif (!buff) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"evbuffer_new\");\n\t\tgoto fail;\n\t}\n\n\thttp_auth *auth = red_http_auth(client->instance);\n\t++auth->last_auth_count;\n\n\tconst char *auth_scheme = NULL;\n\n\tif (auth->last_auth_query != NULL) {\n\t\t/* find previous auth challange */\n\n\t\tif (strncasecmp(auth->last_auth_query, \"Basic\", 5) == 0) {\n\t\t\tauth_string = basic_authentication_encode(client->instance->config.login, client->instance->config.password);\n\t\t\tauth_scheme = \"Basic\";\n\t\t} else if (strncasecmp(auth->last_auth_query, \"Digest\", 6) == 0) {\n\t\t\t/* calculate uri */\n\t\t\tchar uri[128];\n\t\t\tsnprintf(uri, 128, \"%s:%u\", inet_ntoa(client->destaddr.sin_addr), ntohs(client->destaddr.sin_port));\n\n\t\t\t/* prepare an random string for cnounce */\n\t\t\tchar cnounce[17];\n\t\t\tsnprintf(cnounce, sizeof(cnounce), \"%08x%08x\", red_randui32(), red_randui32());\n\n\t\t\tauth_string = digest_authentication_encode(auth->last_auth_query + 7, //line\n\t\t\t\t\tclient->instance->config.login, client->instance->config.password, //user, pass\n\t\t\t\t\t\"CONNECT\", uri, auth->last_auth_count, cnounce); // method, path, nc, cnounce\n\t\t\tauth_scheme = \"Digest\";\n\t\t}\n\t}\n\n\t// TODO: do accurate evbuffer_expand() while cleaning up http-auth\n\tlen = evbuffer_add_printf(buff, \"CONNECT %s:%u HTTP/1.0\\r\\n\",\n\t\tinet_ntoa(client->destaddr.sin_addr),\n\t\tntohs(client->destaddr.sin_port));\n\tif (len < 0) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"evbufer_add_printf\");\n\t\tgoto fail;\n\t}\n\n\tif (auth_string) {\n\t\tlen = evbuffer_add_printf(buff, \"%s %s %s\\r\\n\",\n\t\t\tauth_response_header, auth_scheme, auth_string);\n\t\tif (len < 0) {\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"evbufer_add_printf\");\n\t\t\tgoto fail;\n\t\t}\n\t\tfree(auth_string);\n\t\tauth_string = NULL;\n\t}\n\n\tconst enum disclose_src_e disclose_src = client->instance->config.disclose_src;\n\tif (disclose_src != DISCLOSE_NONE) {\n\t\tchar clientip[INET_ADDRSTRLEN];\n\t\tconst char *ip = inet_ntop(client->clientaddr.sin_family, &client->clientaddr.sin_addr, clientip, sizeof(clientip));\n\t\tif (!ip) {\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"inet_ntop\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (disclose_src == DISCLOSE_X_FORWARDED_FOR) {\n\t\t\tlen = evbuffer_add_printf(buff, \"X-Forwarded-For: %s\\r\\n\", ip);\n\t\t} else if (disclose_src == DISCLOSE_FORWARDED_IP) {\n\t\t\tlen = evbuffer_add_printf(buff, \"Forwarded: for=%s\\r\\n\", ip);\n\t\t} else if (disclose_src == DISCLOSE_FORWARDED_IPPORT) {\n\t\t\tlen = evbuffer_add_printf(buff, \"Forwarded: for=\\\"%s:%d\\\"\\r\\n\", ip,\n\t\t\t\tntohs(client->clientaddr.sin_port));\n\t\t}\n\t\tif (len < 0) {\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"evbufer_add_printf\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlen = evbuffer_add(buff, \"\\r\\n\", 2);\n\tif (len < 0) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"evbufer_add\");\n\t\tgoto fail;\n\t}\n\n\tretval = buff;\n\tbuff = NULL;\n\nfail:\n\tif (auth_string)\n\t\tfree(auth_string);\n\tif (buff)\n\t\tevbuffer_free(buff);\n\treturn retval;\n}\n\n\nstatic void httpc_write_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\n\tredsocks_touch_client(client);\n\n\tif (client->state == httpc_new) {\n\t\tredsocks_write_helper_ex(\n\t\t\tbuffev, client,\n\t\t\thttpc_mkconnect, httpc_request_sent, 1, HTTP_HEAD_WM_HIGH\n\t\t\t);\n\t}\n\telse if (client->state >= httpc_request_sent) {\n\t\tbufferevent_disable(buffev, EV_WRITE);\n\t}\n}\n\n\nrelay_subsys http_connect_subsys =\n{\n\t.name                 = \"http-connect\",\n\t.payload_len          = 0,\n\t.instance_payload_len = sizeof(http_auth),\n\t.readcb               = httpc_read_cb,\n\t.writecb              = httpc_write_cb,\n\t.init                 = httpc_client_init,\n\t.instance_fini        = httpc_instance_fini,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "http-relay.c",
          "type": "blob",
          "size": 15.5615234375,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n *\n * http-relay upstream module for redsocks\n */\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"log.h\"\n#include \"redsocks.h\"\n#include \"http-auth.h\"\n#include \"utils.h\"\n\n#define HTTP_HEAD_WM_HIGH (4096)\n\ntypedef enum httpr_state_t {\n\thttpr_new,\n\thttpr_recv_request_headers,\n\thttpr_request_sent,\n\thttpr_reply_came,\n\thttpr_headers_skipped,\n\thttpr_MAX,\n} httpr_state;\n\ntypedef struct httpr_buffer_t {\n\tchar *buff;\n\tint len;\n\tint max_len;\n} httpr_buffer;\n\ntypedef struct httpr_client_t {\n\tchar *firstline;\n\tchar *host;\n\tint has_host;\n\thttpr_buffer client_buffer;\n\thttpr_buffer relay_buffer;\n} httpr_client;\n\nextern const char *auth_request_header;\nextern const char *auth_response_header;\n\nstatic void httpr_connect_relay(redsocks_client *client);\n\nstatic int httpr_buffer_init(httpr_buffer *buff)\n{\n\tbuff->max_len = 4096;\n\tbuff->len = 0;\n\tbuff->buff = calloc(buff->max_len, 1);\n\tif (!buff->buff)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void httpr_buffer_fini(httpr_buffer *buff)\n{\n\tfree(buff->buff);\n\tbuff->buff = NULL;\n}\n\nstatic int httpr_buffer_append(httpr_buffer *buff, const char *data, int len)\n{\n\twhile (buff->len + len + 1 > buff->max_len) {\n\t\t/* double the buffer size */\n\t\tbuff->max_len *= 2;\n\t}\n\tchar *new_buff = calloc(buff->max_len, 1);\n\tif (!new_buff) {\n\t\treturn -1;\n\t}\n\tmemcpy(new_buff, buff->buff, buff->len);\n\tmemcpy(new_buff + buff->len, data, len);\n\tbuff->len += len;\n\tnew_buff[buff->len] = '\\0';\n\tfree(buff->buff);\n\tbuff->buff = new_buff;\n\treturn 0;\n}\n\nstatic void httpr_client_init(redsocks_client *client)\n{\n\thttpr_client *httpr = red_payload(client);\n\n\tclient->state = httpr_new;\n\tmemset(httpr, 0, sizeof(*httpr));\n\thttpr_buffer_init(&httpr->client_buffer);\n\thttpr_buffer_init(&httpr->relay_buffer);\n}\n\nstatic void httpr_client_fini(redsocks_client *client)\n{\n\thttpr_client *httpr = red_payload(client);\n\n\tfree(httpr->firstline);\n\thttpr->firstline = NULL;\n\tfree(httpr->host);\n\thttpr->host = NULL;\n\thttpr_buffer_fini(&httpr->client_buffer);\n\thttpr_buffer_fini(&httpr->relay_buffer);\n}\n\nstatic void httpr_instance_init(redsocks_instance *instance)\n{\n\tlog_error(LOG_WARNING, \"You should avoid `http-relay`, e.g. due to CVE-2009-0801\");\n}\n\nstatic void httpr_instance_fini(redsocks_instance *instance)\n{\n\thttp_auth *auth = red_http_auth(instance);\n\tfree(auth->last_auth_query);\n\tauth->last_auth_query = NULL;\n}\n\nstatic void httpr_relay_read_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\thttpr_client *httpr = red_payload(client);\n\tint dropped = 0;\n\n\tassert(client->state >= httpr_request_sent);\n\n\tredsocks_touch_client(client);\n\n\thttpr_buffer_fini(&httpr->relay_buffer);\n\thttpr_buffer_init(&httpr->relay_buffer);\n\n\tif (client->state == httpr_request_sent) {\n\t\tsize_t len = evbuffer_get_length(buffev->input);\n\t\tchar *line = redsocks_evbuffer_readline(buffev->input);\n\t\tif (line) {\n\t\t\thttpr_buffer_append(&httpr->relay_buffer, line, strlen(line));\n\t\t\thttpr_buffer_append(&httpr->relay_buffer, \"\\r\\n\", 2);\n\t\t\tunsigned int code;\n\t\t\tif (sscanf(line, \"HTTP/%*u.%*u %u\", &code) == 1) { // 1 == one _assigned_ match\n\t\t\t\tif (code == 407) { // auth failed\n\t\t\t\t\thttp_auth *auth = red_http_auth(client->instance);\n\n\t\t\t\t\tif (auth->last_auth_query != NULL && auth->last_auth_count == 1) {\n\t\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy auth failed: %s\", line);\n\t\t\t\t\t\tredsocks_drop_client(client);\n\t\t\t\t\t\tdropped = 1;\n\t\t\t\t\t} else if (client->instance->config.login == NULL || client->instance->config.password == NULL) {\n\t\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy auth required, but no login/password configured: %s\", line);\n\t\t\t\t\t\tredsocks_drop_client(client);\n\t\t\t\t\t\tdropped = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfree(line);\n\t\t\t\t\t\tchar *auth_request = http_auth_request_header(buffev->input, NULL);\n\n\t\t\t\t\t\tif (!auth_request) {\n\t\t\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy auth required, but no <%s> header found: %s\", auth_request_header, line);\n\t\t\t\t\t\t\tredsocks_drop_client(client);\n\t\t\t\t\t\t\tdropped = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfree(auth->last_auth_query);\n\t\t\t\t\t\t\tchar *ptr = auth_request;\n\n\t\t\t\t\t\t\tptr += strlen(auth_request_header);\n\t\t\t\t\t\t\twhile (isspace(*ptr))\n\t\t\t\t\t\t\t\tptr++;\n\n\t\t\t\t\t\t\tauth->last_auth_query = calloc(strlen(ptr) + 1, 1);\n\t\t\t\t\t\t\tstrcpy(auth->last_auth_query, ptr);\n\t\t\t\t\t\t\tauth->last_auth_count = 0;\n\n\t\t\t\t\t\t\tfree(auth_request);\n\n\t\t\t\t\t\t\thttpr_buffer_fini(&httpr->relay_buffer);\n\n\t\t\t\t\t\t\tif (bufferevent_disable(client->relay, EV_WRITE)) {\n\t\t\t\t\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_disable\");\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* close relay tunnel */\n\t\t\t\t\t\t\tredsocks_bufferevent_free(client->relay);\n\n\t\t\t\t\t\t\t/* set to initial state*/\n\t\t\t\t\t\t\tclient->state = httpr_recv_request_headers;\n\n\t\t\t\t\t\t\t/* and reconnect */\n\t\t\t\t\t\t\tredsocks_connect_relay(client);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (100 <= code && code <= 999) {\n\t\t\t\t\tclient->state = httpr_reply_came;\n\t\t\t\t} else {\n\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy error: %s\", line);\n\t\t\t\t\tredsocks_drop_client(client);\n\t\t\t\t\tdropped = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy bad firstline: %s\", line);\n\t\t\t\tredsocks_drop_client(client);\n\t\t\t\tdropped = 1;\n\t\t\t}\n\t\t\tfree(line);\n\t\t}\n\t\telse if (len >= HTTP_HEAD_WM_HIGH) {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"HTTP Proxy reply is too long, %zu bytes\", len);\n\t\t\tredsocks_drop_client(client);\n\t\t\tdropped = 1;\n\t\t}\n\t}\n\n\tif (dropped)\n\t\treturn;\n\n\twhile (client->state == httpr_reply_came) {\n\t\tchar *line = redsocks_evbuffer_readline(buffev->input);\n\t\tif (line) {\n\t\t\thttpr_buffer_append(&httpr->relay_buffer, line, strlen(line));\n\t\t\thttpr_buffer_append(&httpr->relay_buffer, \"\\r\\n\", 2);\n\t\t\tif (strlen(line) == 0) {\n\t\t\t\tclient->state = httpr_headers_skipped;\n\t\t\t}\n\t\t\tfree(line);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (client->state == httpr_headers_skipped) {\n\t\tif (bufferevent_write(client->client, httpr->relay_buffer.buff, httpr->relay_buffer.len) != 0) {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"bufferevent_write\");\n\t\t\tredsocks_drop_client(client);\n\t\t\treturn;\n\t\t}\n\t\tredsocks_start_relay(client);\n\t}\n\n}\n\nstatic void httpr_relay_write_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\thttpr_client *httpr = red_payload(client);\n\tint len = 0;\n\n\tassert(client->state >= httpr_recv_request_headers);\n\n\tredsocks_touch_client(client);\n\n\tif (client->state == httpr_recv_request_headers) {\n\t\tif (httpr->firstline) {\n\t\t\tlen = bufferevent_write(client->relay, httpr->firstline, strlen(httpr->firstline));\n\t\t\tif (len < 0) {\n\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_write\");\n\t\t\t\tredsocks_drop_client(client);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\thttp_auth *auth = red_http_auth(client->instance);\n\t\t++auth->last_auth_count;\n\n\t\tconst char *auth_scheme = NULL;\n\t\tchar *auth_string = NULL;\n\n\t\tif (auth->last_auth_query != NULL) {\n\t\t\t/* find previous auth challange */\n\n\t\t\tif (strncasecmp(auth->last_auth_query, \"Basic\", 5) == 0) {\n\t\t\t\tauth_string = basic_authentication_encode(client->instance->config.login, client->instance->config.password);\n\t\t\t\tauth_scheme = \"Basic\";\n\t\t\t} else if (strncasecmp(auth->last_auth_query, \"Digest\", 6) == 0 && httpr->firstline) {\n\t\t\t\t/* calculate method & uri */\n\t\t\t\tchar *ptr = strchr(httpr->firstline, ' '), *ptr2;\n\t\t\t\tchar *method = calloc(ptr - httpr->firstline + 1, 1);\n\t\t\t\tmemcpy(method, httpr->firstline, ptr - httpr->firstline);\n\t\t\t\tmethod[ptr - httpr->firstline] = 0;\n\n\t\t\t\tptr = strchr(httpr->firstline, '/');\n\t\t\t\tif (!ptr || *++ptr != '/') {\n\t\t\t\t\tfree(method);\n\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"malformed request came\");\n\t\t\t\t\tredsocks_drop_client(client);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!(ptr = strchr(++ptr, '/')) || !(ptr2 = strchr(ptr, ' '))) {\n\t\t\t\t\tfree(method);\n\t\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"malformed request came\");\n\t\t\t\t\tredsocks_drop_client(client);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tchar *uri = calloc(ptr2 - ptr + 1, 1);\n\t\t\t\tmemcpy(uri, ptr, ptr2 - ptr);\n\t\t\t\turi[ptr2 - ptr] = 0;\n\n\t\t\t\t/* prepare an random string for cnounce */\n\t\t\t\tchar cnounce[17];\n\t\t\t\tsnprintf(cnounce, sizeof(cnounce), \"%08x%08x\", red_randui32(), red_randui32());\n\n\t\t\t\tauth_string = digest_authentication_encode(auth->last_auth_query + 7, //line\n\t\t\t\t\t\tclient->instance->config.login, client->instance->config.password, //user, pass\n\t\t\t\t\t\tmethod, uri, auth->last_auth_count, cnounce); // method, path, nc, cnounce\n\n\t\t\t\tfree(method);\n\t\t\t\tfree(uri);\n\t\t\t\tauth_scheme = \"Digest\";\n\t\t\t}\n\t\t}\n\n\t\tif (auth_string != NULL) {\n\t\t\tlen = 0;\n\t\t\tlen |= bufferevent_write(client->relay, auth_response_header, strlen(auth_response_header));\n\t\t\tlen |= bufferevent_write(client->relay, \" \", 1);\n\t\t\tlen |= bufferevent_write(client->relay, auth_scheme, strlen(auth_scheme));\n\t\t\tlen |= bufferevent_write(client->relay, \" \", 1);\n\t\t\tlen |= bufferevent_write(client->relay, auth_string, strlen(auth_string));\n\t\t\tlen |= bufferevent_write(client->relay, \"\\r\\n\", 2);\n\t\t\tif (len) {\n\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_write\");\n\t\t\t\tredsocks_drop_client(client);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfree(auth_string);\n\n\t\tlen = bufferevent_write(client->relay, httpr->client_buffer.buff, httpr->client_buffer.len);\n\t\tif (len < 0) {\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_write\");\n\t\t\tredsocks_drop_client(client);\n\t\t\treturn;\n\t\t}\n\n\t\tclient->state = httpr_request_sent;\n\n\t\tbufferevent_setwatermark(buffev, EV_READ, 1, HTTP_HEAD_WM_HIGH);\n\t\tbufferevent_enable(buffev, EV_READ);\n\t}\n}\n\n// drops client on failure\nstatic int httpr_append_header(redsocks_client *client, char *line)\n{\n\thttpr_client *httpr = red_payload(client);\n\n\tif (httpr_buffer_append(&httpr->client_buffer, line, strlen(line)) != 0)\n\t\treturn -1;\n\tif (httpr_buffer_append(&httpr->client_buffer, \"\\x0d\\x0a\", 2) != 0)\n\t\treturn -1;\n\treturn 0;\n}\n\n// This function is not reenterable\nstatic char *fmt_http_host(struct sockaddr_in addr)\n{\n\tstatic char host[] = \"123.123.123.123:12345\";\n\tif (ntohs(addr.sin_port) == 80)\n\t\treturn inet_ntoa(addr.sin_addr);\n\telse {\n\t\tsnprintf(host, sizeof(host),\n\t\t\t\t\"%s:%u\",\n\t\t\t\tinet_ntoa(addr.sin_addr),\n\t\t\t\tntohs(addr.sin_port)\n\t\t\t\t);\n\t\treturn host;\n\t}\n}\n\nstatic int httpr_toss_http_firstline(redsocks_client *client)\n{\n\thttpr_client *httpr = red_payload(client);\n\tchar *uri = NULL;\n\tchar *host = httpr->has_host ? httpr->host : fmt_http_host(client->destaddr);\n\n\tassert(httpr->firstline);\n\n\turi = strchr(httpr->firstline, ' ');\n\tif (uri)\n\t\turi += 1; // one char further\n\telse {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"malformed request came\");\n\t\tgoto fail;\n\t}\n\n\thttpr_buffer nbuff;\n\tif (httpr_buffer_init(&nbuff) != 0) {\n\t\tredsocks_log_error(client, LOG_ERR, \"httpr_buffer_init\");\n\t\tgoto fail;\n\t}\n\n\tif (httpr_buffer_append(&nbuff, httpr->firstline, uri - httpr->firstline) != 0)\n\t\tgoto addition_fail;\n\tif (httpr_buffer_append(&nbuff, \"http://\", 7) != 0)\n\t\tgoto addition_fail;\n\tif (httpr_buffer_append(&nbuff, host, strlen(host)) != 0)\n\t\tgoto addition_fail;\n\tif (httpr_buffer_append(&nbuff, uri, strlen(uri)) != 0)\n\t\tgoto addition_fail;\n\tif (httpr_buffer_append(&nbuff, \"\\x0d\\x0a\", 2) != 0)\n\t\tgoto addition_fail;\n\n\tfree(httpr->firstline);\n\n\thttpr->firstline = calloc(nbuff.len + 1, 1);\n\tstrcpy(httpr->firstline, nbuff.buff);\n\thttpr_buffer_fini(&nbuff);\n\treturn 0;\n\naddition_fail:\n\thttpr_buffer_fini(&nbuff);\nfail:\n\tredsocks_log_error(client, LOG_ERR, \"httpr_toss_http_firstline\");\n\treturn -1;\n}\n\nstatic void httpr_client_read_content(struct bufferevent *buffev, redsocks_client *client)\n{\n\thttpr_client *httpr = red_payload(client);\n\n\tstatic int post_buffer_len = 64 * 1024;\n\tchar *post_buffer = calloc(post_buffer_len, 1);\n\tif (!post_buffer) {\n\t\tredsocks_log_error(client, LOG_ERR, \"run out of memory\");\n\t\tredsocks_drop_client(client);\n\t\treturn;\n\t}\n\tint error;\n\twhile (true) {\n\t\terror = evbuffer_remove(buffev->input, post_buffer, post_buffer_len);\n\t\tif (error < 0) {\n\t\t\tfree(post_buffer);\n\t\t\tredsocks_log_error(client, LOG_ERR, \"evbuffer_remove\");\n\t\t\tredsocks_drop_client(client);\n\t\t\treturn;\n\t\t}\n\t\tif (error == 0)\n\t\t\tbreak;\n\t\thttpr_buffer_append(&httpr->client_buffer, post_buffer, error);\n\t\tif (client->relay && client->state >= httpr_request_sent) {\n\t\t\tif (bufferevent_write(client->relay, post_buffer, error) != 0) {\n\t\t\t\tfree(post_buffer);\n\t\t\t\tredsocks_log_error(client, LOG_ERR, \"bufferevent_write\");\n\t\t\t\tredsocks_drop_client(client);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t}\n\tfree(post_buffer);\n}\n\nstatic void httpr_client_read_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\thttpr_client *httpr = red_payload(client);\n\n\tredsocks_touch_client(client);\n\n\tif (client->state >= httpr_recv_request_headers) {\n\t\thttpr_client_read_content(buffev, client);\n\t\treturn;\n\t}\n\n\tchar *line = NULL;\n\tint connect_relay = 0;\n\n\twhile (!connect_relay && (line = redsocks_evbuffer_readline(buffev->input))) {\n\t\tint skip_line = 0;\n\t\tint do_drop = 0;\n\n\t\tif (strlen(line) > 0) {\n\t\t\tif (!httpr->firstline) {\n\t\t\t\thttpr->firstline = line;\n\t\t\t\tline = 0;\n\t\t\t}\n\t\t\telse if (strncasecmp(line, \"Host\", 4) == 0) {\n\t\t\t\thttpr->has_host = 1;\n\t\t\t\tchar *ptr = line + 5;\n\t\t\t\twhile (*ptr && isspace(*ptr))\n\t\t\t\t\tptr ++;\n\t\t\t\thttpr->host = calloc(strlen(ptr) + 1, 1);\n\t\t\t\tstrcpy(httpr->host, ptr);\n\t\t\t} else if (strncasecmp(line, \"Proxy-Connection\", 16) == 0)\n\t\t\t\tskip_line = 1;\n\t\t\telse if (strncasecmp(line, \"Connection\", 10) == 0)\n\t\t\t\tskip_line = 1;\n\n\t\t}\n\t\telse { // last line of request\n\t\t\tif (!httpr->firstline || httpr_toss_http_firstline(client) < 0)\n\t\t\t\tdo_drop = 1;\n\n\t\t\tif (!httpr->has_host) {\n\t\t\t\tchar host[32]; // \"Host: 123.456.789.012:34567\"\n\t\t\t\tint written_wo_null = snprintf(host, sizeof(host), \"Host: %s\",\n\t\t\t\t                               fmt_http_host(client->destaddr));\n\t\t\t\tUNUSED(written_wo_null);\n\t\t\t\tassert(0 < written_wo_null && written_wo_null < sizeof(host));\n\t\t\t\tif (httpr_append_header(client, host) < 0)\n\t\t\t\t\tdo_drop = 1;\n\t\t\t}\n\n\t\t\tif (httpr_append_header(client, \"Proxy-Connection: close\") < 0)\n\t\t\t\tdo_drop = 1;\n\n\t\t\tif (httpr_append_header(client, \"Connection: close\") < 0)\n\t\t\t\tdo_drop = 1;\n\n\t\t\tconnect_relay = 1;\n\t\t}\n\n\t\tif (line && !skip_line)\n\t\t\tif (httpr_append_header(client, line) < 0)\n\t\t\t\tdo_drop = 1;\n\n\t\tfree(line);\n\n\t\tif (do_drop) {\n\t\t\tredsocks_drop_client(client);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (connect_relay) {\n\t\tclient->state = httpr_recv_request_headers;\n\t\thttpr_client_read_content(buffev, client);\n\t\tredsocks_connect_relay(client);\n\t}\n}\n\nstatic void httpr_connect_relay(redsocks_client *client)\n{\n\tint error;\n\n\tclient->client->readcb = httpr_client_read_cb;\n\terror = bufferevent_enable(client->client, EV_READ);\n\tif (error) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_enable\");\n\t\tredsocks_drop_client(client);\n\t}\n}\n\nrelay_subsys http_relay_subsys =\n{\n\t.name                 = \"http-relay\",\n\t.payload_len          = sizeof(httpr_client),\n\t.instance_payload_len = sizeof(http_auth),\n\t.init                 = httpr_client_init,\n\t.fini                 = httpr_client_fini,\n\t.connect_relay        = httpr_connect_relay,\n\t.readcb               = httpr_relay_read_cb,\n\t.writecb              = httpr_relay_write_cb,\n\t.instance_init        = httpr_instance_init,\n\t.instance_fini        = httpr_instance_fini,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "libc-compat.h",
          "type": "blob",
          "size": 0.94921875,
          "content": "#ifndef UUID_67C91670_FCCB_4855_BDF7_609F1EECB8B4\n#define UUID_67C91670_FCCB_4855_BDF7_609F1EECB8B4\n\n/* all these definitions, are included into bits/in.h from libc6-dev 2.15-0ubuntu10\n * from Ubuntu 12.04 and is not included into libc6-dev 2.11.1-0ubuntu7.10 from\n * Ubuntu 10.04.\n * linux/in.h is not included directly because of lots of redefinitions,\n * extracting single value from linux/in.h is not done because it looks like\n * autotools reinvention */\n#ifndef IP_ORIGDSTADDR\n#   warning Using hardcoded value for IP_ORIGDSTADDR as libc headers do not define it.\n#   define IP_ORIGDSTADDR 20\n#endif\n\n#ifndef IP_RECVORIGDSTADDR\n#   warning Using hardcoded value for IP_RECVORIGDSTADDR as libc headers do not define it.\n#   define IP_RECVORIGDSTADDR IP_ORIGDSTADDR\n#endif\n\n#ifndef IP_TRANSPARENT\n#   warning Using hardcoded value for IP_TRANSPARENT as libc headers do not define it.\n#   define IP_TRANSPARENT 19\n#endif\n\n#endif // 67C91670_FCCB_4855_BDF7_609F1EECB8B4\n"
        },
        {
          "name": "libevent-compat.h",
          "type": "blob",
          "size": 0.41796875,
          "content": "#ifndef UUID_FC148CFA_5ECC_488E_8A62_CD39406C9F1E\n#define UUID_FC148CFA_5ECC_488E_8A62_CD39406C9F1E\n\n/* evutil_socket_t is macros in libevent-2.0, not typedef, libevent-1.4 is\n * still supported because of Ubuntu 10.04 LTS */\n#ifndef evutil_socket_t\n#   warning Using hardcoded value for evutil_socket_t as libevent headers do not define it.\n#   define evutil_socket_t int\n#endif\n\n#endif // FC148CFA_5ECC_488E_8A62_CD39406C9F1E\n"
        },
        {
          "name": "list.h",
          "type": "blob",
          "size": 12.3232421875,
          "content": "#ifndef _LINUX_LIST_H\n#define _LINUX_LIST_H\n/** That's taken from linux-2.6.18.2 source tree with light modifications\n * I don't know what copyright to place here but that's GPLv2 code so\n * I assume I'm free to reuse it.\n */\n#include \"utils.h\" // container_of\n\n\n/*\n * These are non-NULL pointers that will result in page faults\n * under normal circumstances, used to verify that nobody uses\n * non-initialized list entries.\n */\n#define LIST_POISON1  ((void *) 0x00100100)\n#define LIST_POISON2  ((void *) 0x00200200)\n\n/*\n * Simple doubly linked list implementation.\n *\n * Some of the internal functions (\"__xxx\") are useful when\n * manipulating whole lists rather than single entries, as\n * sometimes we already know the next/prev entries and we can\n * generate better code by using them directly rather than\n * using the generic single-entry routines.\n */\n\ntypedef struct list_head_t {\n\tstruct list_head_t *next, *prev;\n} list_head;\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n\tstruct list_head_t name = LIST_HEAD_INIT(name)\n\nstatic inline void INIT_LIST_HEAD(struct list_head_t *list)\n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n\n/*\n * Insert a new entry between two known consecutive entries.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_add(struct list_head_t *new,\n\t\t\t      struct list_head_t *prev,\n\t\t\t      struct list_head_t *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n\n/**\n * list_add - add a new entry\n * @new: new entry to be added\n * @head: list head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void list_add(struct list_head_t *new, struct list_head_t *head)\n{\n\t__list_add(new, head, head->next);\n}\n\n/**\n * list_add_tail - add a new entry\n * @new: new entry to be added\n * @head: list head to add it before\n *\n * Insert a new entry before the specified head.\n * This is useful for implementing queues.\n */\nstatic inline void list_add_tail(struct list_head_t *new, struct list_head_t *head)\n{\n\t__list_add(new, head->prev, head);\n}\n\n/*\n * Delete a list entry by making the prev/next entries\n * point to each other.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_del(struct list_head_t * prev, struct list_head_t * next)\n{\n\tnext->prev = prev;\n\tprev->next = next;\n}\n\n/**\n * list_del - deletes entry from list.\n * @entry: the element to delete from the list.\n * Note: list_empty on entry does not return true after this, the entry is\n * in an undefined state.\n */\nstatic inline void list_del(struct list_head_t *entry)\n{\n\t__list_del(entry->prev, entry->next);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n\n/**\n * list_replace - replace old entry by new one\n * @old : the element to be replaced\n * @new : the new element to insert\n * Note: if 'old' was empty, it will be overwritten.\n */\nstatic inline void list_replace(struct list_head_t *old,\n\t\t\t\tstruct list_head_t *new)\n{\n\tnew->next = old->next;\n\tnew->next->prev = new;\n\tnew->prev = old->prev;\n\tnew->prev->next = new;\n}\n\nstatic inline void list_replace_init(struct list_head_t *old,\n\t\t\t\t\tstruct list_head_t *new)\n{\n\tlist_replace(old, new);\n\tINIT_LIST_HEAD(old);\n}\n\n/**\n * list_del_init - deletes entry from list and reinitialize it.\n * @entry: the element to delete from the list.\n */\nstatic inline void list_del_init(struct list_head_t *entry)\n{\n\t__list_del(entry->prev, entry->next);\n\tINIT_LIST_HEAD(entry);\n}\n\n/**\n * list_move - delete from one list and add as another's head\n * @list: the entry to move\n * @head: the head that will precede our entry\n */\nstatic inline void list_move(struct list_head_t *list, struct list_head_t *head)\n{\n        __list_del(list->prev, list->next);\n        list_add(list, head);\n}\n\n/**\n * list_move_tail - delete from one list and add as another's tail\n * @list: the entry to move\n * @head: the head that will follow our entry\n */\nstatic inline void list_move_tail(struct list_head_t *list,\n\t\t\t\t  struct list_head_t *head)\n{\n        __list_del(list->prev, list->next);\n        list_add_tail(list, head);\n}\n\n/**\n * list_is_last - tests whether @list is the last entry in list @head\n * @list: the entry to test\n * @head: the head of the list\n */\nstatic inline int list_is_last(const struct list_head_t *list,\n\t\t\t\tconst struct list_head_t *head)\n{\n\treturn list->next == head;\n}\n\n/**\n * list_empty - tests whether a list is empty\n * @head: the list to test.\n */\nstatic inline int list_empty(const struct list_head_t *head)\n{\n\treturn head->next == head;\n}\n\n/**\n * list_empty_careful - tests whether a list is empty and not being modified\n * @head: the list to test\n *\n * Description:\n * tests whether a list is empty _and_ checks that no other CPU might be\n * in the process of modifying either member (next or prev)\n *\n * NOTE: using list_empty_careful() without synchronization\n * can only be safe if the only activity that can happen\n * to the list entry is list_del_init(). Eg. it cannot be used\n * if another CPU could re-list_add() it.\n */\nstatic inline int list_empty_careful(const struct list_head_t *head)\n{\n\tstruct list_head_t *next = head->next;\n\treturn (next == head) && (next == head->prev);\n}\n\nstatic inline void __list_splice(struct list_head_t *list,\n\t\t\t\t struct list_head_t *head)\n{\n\tstruct list_head_t *first = list->next;\n\tstruct list_head_t *last = list->prev;\n\tstruct list_head_t *at = head->next;\n\n\tfirst->prev = head;\n\thead->next = first;\n\n\tlast->next = at;\n\tat->prev = last;\n}\n\n/**\n * list_splice - join two lists\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n */\nstatic inline void list_splice(struct list_head_t *list, struct list_head_t *head)\n{\n\tif (!list_empty(list))\n\t\t__list_splice(list, head);\n}\n\n/**\n * list_splice_init - join two lists and reinitialise the emptied list.\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n *\n * The list at @list is reinitialised\n */\nstatic inline void list_splice_init(struct list_head_t *list,\n\t\t\t\t    struct list_head_t *head)\n{\n\tif (!list_empty(list)) {\n\t\t__list_splice(list, head);\n\t\tINIT_LIST_HEAD(list);\n\t}\n}\n\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head_t pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n/**\n * list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head_t to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each(pos, head) \\\n\tfor (pos = (head)->next; pos != (head); \\\n        \tpos = pos->next)\n\n/**\n * __list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head_t to use as a loop cursor.\n * @head:\tthe head for your list.\n *\n * This variant differs from list_for_each() in that it's the\n * simplest possible list iteration code, no prefetching is done.\n * Use this for code that knows the list to be very short (empty\n * or 1 entry) most of the time.\n */\n#define __list_for_each(pos, head) \\\n\tfor (pos = (head)->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_prev\t-\titerate over a list backwards\n * @pos:\tthe &struct list_head_t to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev(pos, head) \\\n\tfor (pos = (head)->prev; pos != (head); \\\n        \tpos = pos->prev)\n\n/**\n * list_for_each_safe - iterate over a list safe against removal of list entry\n * @pos:\tthe &struct list_head_t to use as a loop cursor.\n * @n:\t\tanother &struct list_head_t to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->next, n = pos->next; pos != (head); \\\n\t\tpos = n, n = pos->next)\n\n/**\n * list_for_each_entry\t-\titerate over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_entry((head)->next, __typeof(*pos), member);\t\\\n\t     &pos->member != (head); \t\\\n\t     pos = list_entry(pos->member.next, __typeof(*pos), member))\n\n/**\n * list_for_each_entry_reverse - iterate backwards over list of given type.\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_reverse(pos, head, member)\t\t\t\\\n\tfor (pos = list_entry((head)->prev, __typeof(*pos), member);\t\\\n\t     &pos->member != (head); \t\\\n\t     pos = list_entry(pos->member.prev, __typeof(*pos), member))\n\n/**\n * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue\n * @pos:\tthe type * to use as a start point\n * @head:\tthe head of the list\n * @member:\tthe name of the list_struct within the struct.\n *\n * Prepares a pos entry for use as a start point in list_for_each_entry_continue.\n */\n#define list_prepare_entry(pos, head, member) \\\n\t((pos) ? : list_entry(head, __typeof(*pos), member))\n\n/**\n * list_for_each_entry_continue - continue iteration over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Continue to iterate over list of given type, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue(pos, head, member) \t\t\\\n\tfor (pos = list_entry(pos->member.next, __typeof(*pos), member);\t\\\n\t     &pos->member != (head);\t\\\n\t     pos = list_entry(pos->member.next, __typeof(*pos), member))\n\n/**\n * list_for_each_entry_from - iterate over list of given type from the current point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate over list of given type, continuing from current position.\n */\n#define list_for_each_entry_from(pos, head, member) \t\t\t\\\n\tfor (; &pos->member != (head);\t\\\n\t     pos = list_entry(pos->member.next, __typeof(*pos), member))\n\n/**\n * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n */\n#define list_for_each_entry_safe(pos, n, head, member)\t\t\t\\\n\tfor (pos = list_entry((head)->next, __typeof(*pos), member),\t\\\n\t\tn = list_entry(pos->member.next, __typeof(*pos), member);\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = n, n = list_entry(n->member.next, __typeof(*n), member))\n\n/**\n * list_for_each_entry_safe_continue\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate over list of given type, continuing after current point,\n * safe against removal of list entry.\n */\n#define list_for_each_entry_safe_continue(pos, n, head, member) \t\t\\\n\tfor (pos = list_entry(pos->member.next, __typeof(*pos), member), \t\t\\\n\t\tn = list_entry(pos->member.next, __typeof(*pos), member);\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\t\\\n\t     pos = n, n = list_entry(n->member.next, __typeof(*n), member))\n\n/**\n * list_for_each_entry_safe_from\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate over list of given type from current point, safe against\n * removal of list entry.\n */\n#define list_for_each_entry_safe_from(pos, n, head, member) \t\t\t\\\n\tfor (n = list_entry(pos->member.next, __typeof(*pos), member);\t\t\\\n\t     &pos->member != (head);\t\t\t\t\t\t\\\n\t     pos = n, n = list_entry(n->member.next, __typeof(*n), member))\n\n/**\n * list_for_each_entry_safe_reverse\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_struct within the struct.\n *\n * Iterate backwards over list of given type, safe against removal\n * of list entry.\n */\n#define list_for_each_entry_safe_reverse(pos, n, head, member)\t\t\\\n\tfor (pos = list_entry((head)->prev, __typeof(*pos), member),\t\\\n\t\tn = list_entry(pos->member.prev, __typeof(*pos), member);\t\\\n\t     &pos->member != (head); \t\t\t\t\t\\\n\t     pos = n, n = list_entry(n->member.prev, __typeof(*n), member))\n\n#endif\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 5.5849609375,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <event.h>\n#include \"utils.h\"\n#include \"log.h\"\n\nconst char *error_lowmem = \"<Can't print error, not enough memory>\";\n\ntypedef void (*log_func)(const char *file, int line, const char *func, int priority, const char *message, const char *appendix);\n\nstatic const char* getprioname(int priority)\n{\n\tswitch (priority) {\n\t\tcase LOG_EMERG:   return \"emerg\";\n\t\tcase LOG_ALERT:   return \"alert\";\n\t\tcase LOG_CRIT:    return \"crit\";\n\t\tcase LOG_ERR:     return \"err\";\n\t\tcase LOG_WARNING: return \"warning\";\n\t\tcase LOG_NOTICE:  return \"notice\";\n\t\tcase LOG_INFO:    return \"info\";\n\t\tcase LOG_DEBUG:   return \"debug\";\n\t\tdefault:          return \"?\";\n\t}\n}\n\nstatic void fprint_timestamp(\n\t\tFILE* fd,\n\t\tconst char *file, int line, const char *func, int priority, const char *message, const char *appendix)\n{\n\tstruct timeval tv = { };\n\tgettimeofday(&tv, 0);\n\n\t/* XXX: there is no error-checking, IMHO it's better to lose messages\n\t *      then to die and stop service */\n\tconst char* sprio = getprioname(priority);\n\tif (appendix)\n\t\tfprintf(fd, \"%lu.%6.6lu %s %s:%u %s(...) %s: %s\\n\", tv.tv_sec, tv.tv_usec, sprio, file, line, func, message, appendix);\n\telse\n\t\tfprintf(fd, \"%lu.%6.6lu %s %s:%u %s(...) %s\\n\", tv.tv_sec, tv.tv_usec, sprio, file, line, func, message);\n}\n\nstatic void stderr_msg(const char *file, int line, const char *func, int priority, const char *message, const char *appendix)\n{\n\tfprint_timestamp(stderr, file, line, func, priority, message, appendix);\n}\n\nstatic FILE *logfile = NULL;\n\nstatic void logfile_msg(const char *file, int line, const char *func, int priority, const char *message, const char *appendix)\n{\n\tfprint_timestamp(logfile, file, line, func, priority, message, appendix);\n\tfflush(logfile);\n}\n\nstatic void syslog_msg(const char *file, int line, const char *func, int priority, const char *message, const char *appendix)\n{\n\tif (appendix)\n\t\tsyslog(priority, \"%s: %s\\n\", message, appendix);\n\telse\n\t\tsyslog(priority, \"%s\\n\", message);\n}\n\nstatic log_func log_msg = stderr_msg;\nstatic log_func log_msg_next = NULL;\nstatic bool should_log_info = true;\nstatic bool should_log_debug = false;\n\nbool should_log(int priority)\n{\n\treturn (priority != LOG_DEBUG && priority != LOG_INFO)\n\t    || (priority == LOG_DEBUG && should_log_debug)\n\t    || (priority == LOG_INFO && should_log_info);\n}\n\nint log_preopen(const char *dst, bool log_debug, bool log_info)\n{\n\tconst char *syslog_prefix = \"syslog:\";\n\tconst char *file_prefix = \"file:\";\n\tshould_log_debug = log_debug;\n\tshould_log_info = log_info;\n\tif (strcmp(dst, \"stderr\") == 0) {\n\t\tlog_msg_next = stderr_msg;\n\t}\n\telse if (strncmp(dst, syslog_prefix, strlen(syslog_prefix)) == 0) {\n\t\tconst char *facility_name = dst + strlen(syslog_prefix);\n\t\tint facility = -1;\n\t\tint logmask;\n\t\tstruct {\n\t\t\tchar *name; int value;\n\t\t} *ptpl, tpl[] = {\n\t\t\t{ \"daemon\", LOG_DAEMON },\n\t\t\t{ \"local0\", LOG_LOCAL0 },\n\t\t\t{ \"local1\", LOG_LOCAL1 },\n\t\t\t{ \"local2\", LOG_LOCAL2 },\n\t\t\t{ \"local3\", LOG_LOCAL3 },\n\t\t\t{ \"local4\", LOG_LOCAL4 },\n\t\t\t{ \"local5\", LOG_LOCAL5 },\n\t\t\t{ \"local6\", LOG_LOCAL6 },\n\t\t\t{ \"local7\", LOG_LOCAL7 },\n\t\t};\n\n\t\tFOREACH(ptpl, tpl)\n\t\t\tif (strcmp(facility_name, ptpl->name) == 0) {\n\t\t\t\tfacility = ptpl->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (facility == -1) {\n\t\t\tlog_error(LOG_ERR, \"log_preopen(%s, ...): unknown syslog facility\", dst);\n\t\t\treturn -1;\n\t\t}\n\n\t\topenlog(\"redsocks\", LOG_NDELAY | LOG_PID, facility);\n\n\t\tlogmask = setlogmask(0);\n\t\tif (!log_debug)\n\t\t\tlogmask &= ~(LOG_MASK(LOG_DEBUG));\n\t\tif (!log_info)\n\t\t\tlogmask &= ~(LOG_MASK(LOG_INFO));\n\t\tsetlogmask(logmask);\n\n\t\tlog_msg_next = syslog_msg;\n\t}\n\telse if (strncmp(dst, file_prefix, strlen(file_prefix)) == 0) {\n\t\tconst char *filename = dst + strlen(file_prefix);\n\t\tif ((logfile = fopen(filename, \"a\")) == NULL) {\n\t\t\tlog_error(LOG_ERR, \"log_preopen(%s, ...): %s\", dst, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tlog_msg_next = logfile_msg;\n\t\t/* TODO: add log rotation */\n\t}\n\telse {\n\t\tlog_error(LOG_ERR, \"log_preopen(%s, ...): unknown destination\", dst);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid log_open()\n{\n\tlog_msg = log_msg_next;\n\tlog_msg_next = NULL;\n}\n\nvoid _log_vwrite(const char *file, int line, const char *func, int do_errno, int priority, const char *fmt, va_list ap)\n{\n\tif (!should_log(priority))\n\t\treturn;\n\n\tint saved_errno = errno;\n\tstruct evbuffer *buff = evbuffer_new();\n\tconst char *message;\n\n\tif (buff) {\n\t\tevbuffer_add_vprintf(buff, fmt, ap);\n\t\tmessage = (const char*)evbuffer_pullup(buff, -1);\n\t}\n\telse\n\t\tmessage = error_lowmem;\n\n\tlog_msg(file, line, func, priority, message, do_errno ? strerror(saved_errno) : NULL);\n\n\tif (buff)\n\t\tevbuffer_free(buff);\n}\n\nvoid _log_write(const char *file, int line, const char *func, int do_errno, int priority, const char *fmt, ...)\n{\n\tif (!should_log(priority))\n\t\treturn;\n\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t_log_vwrite(file, line, func, do_errno, priority, fmt, ap);\n\tva_end(ap);\n}\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 0.916015625,
          "content": "#ifndef LOG_H_WED_JAN_24_18_21_27_2007\n#define LOG_H_WED_JAN_24_18_21_27_2007\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <syslog.h>\n\n#define log_errno(prio, msg...) _log_write(__FILE__, __LINE__, __func__, 1, prio, ## msg)\n#define log_error(prio, msg...) _log_write(__FILE__, __LINE__, __func__, 0, prio, ## msg)\n\nextern const char *error_lowmem;\n\nint log_preopen(const char *dst, bool log_debug, bool log_info);\nvoid log_open();\n\nbool should_log(int priority);\n\nvoid _log_vwrite(const char *file, int line, const char *func, int do_errno, int priority, const char *fmt, va_list ap);\n\nvoid _log_write(const char *file, int line, const char *func, int do_errno, int priority, const char *fmt, ...)\n#if defined(__GNUC__)\n\t__attribute__ (( format (printf, 6, 7) ))\n#endif\n;\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* LOG_H_WED_JAN_24_18_21_27_2007 */\n\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 4.802734375,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <sys/time.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n#include <assert.h>\n#include <event.h>\n#include \"log.h\"\n#include \"main.h\"\n#include \"utils.h\"\n#include \"version.h\"\n#include \"config.h\"\n#include \"base.h\"\n\nextern app_subsys redsocks_subsys;\nextern app_subsys debug_subsys;\nextern app_subsys base_subsys;\nextern app_subsys redudp_subsys;\nextern app_subsys dnstc_subsys;\nextern app_subsys dnsu2t_subsys;\n\napp_subsys *subsystems[] = {\n\t&redsocks_subsys,\n#ifdef DBG_BUILD\n\t&debug_subsys,\n#endif\n\t&base_subsys,\n\t&redudp_subsys,\n\t&dnstc_subsys,\n\t&dnsu2t_subsys,\n};\n\nstatic const char *confname = \"redsocks.conf\";\nstatic const char *pidfile = NULL;\n\nstatic void terminate(int sig, short what, void *_arg)\n{\n\tif (event_loopbreak() != 0)\n\t\tlog_error(LOG_WARNING, \"event_loopbreak\");\n}\n\nint main(int argc, char **argv)\n{\n\tint error;\n\tapp_subsys **ss;\n\tint exit_signals[2] = {SIGTERM, SIGINT};\n\tstruct event terminators[2];\n\tbool conftest = false;\n\tint opt;\n\tint i;\n\n\tevutil_secure_rng_init();\n\twhile ((opt = getopt(argc, argv, \"h?vtc:p:\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\tconftest = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfname = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tputs(redsocks_version);\n\t\t\tprintf(\"Built with libevent-%s\\n\", LIBEVENT_VERSION);\n\t\t\tprintf(\"Runs  with libevent-%s\\n\", event_get_version());\n\t\t\tif (LIBEVENT_VERSION_NUMBER != event_get_version_number()) {\n\t\t\t\tprintf(\"Warning: libevent version number mismatch.\\n\"\n\t\t\t\t       \"  Headers: %8x\\n\"\n\t\t\t\t       \"  Runtime: %8x\\n\", LIBEVENT_VERSION_NUMBER, event_get_version_number());\n\t\t\t}\n\t\t\treturn EXIT_SUCCESS;\n\t\tdefault:\n\t\t\tprintf(\n\t\t\t\t\"Usage: %s [-?hvt] [-c config] [-p pidfile]\\n\"\n\t\t\t\t\"  -h, -?       this message\\n\"\n\t\t\t\t\"  -v           print version\\n\"\n\t\t\t\t\"  -t           test config syntax\\n\"\n\t\t\t\t\"  -p           write pid to pidfile\\n\",\n\t\t\t\targv[0]);\n\t\t\treturn (opt == '?' || opt == 'h') ? EXIT_SUCCESS : EXIT_FAILURE;\n\t\t}\n\t}\n\n\tif (event_get_struct_event_size() != sizeof(struct event)) {\n\t\tputs(\"libevent event_get_struct_event_size() != sizeof(struct event)! Check `redsocks -v` and recompile redsocks\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tFILE *f = fopen(confname, \"r\");\n\tif (!f) {\n\t\tperror(\"Unable to open config file\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tparser_context* parser = parser_start(f);\n\tif (!parser) {\n\t\tperror(\"Not enough memory for parser\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tFOREACH(ss, subsystems)\n\t\tif ((*ss)->conf_section)\n\t\t\tparser_add_section(parser, (*ss)->conf_section);\n\terror = parser_run(parser);\n\tparser_stop(parser);\n\tfclose(f);\n\n\tif (error)\n\t\treturn EXIT_FAILURE;\n\n\tif (conftest)\n\t\treturn EXIT_SUCCESS;\n\n\tstruct event_base* evbase = event_init();\n\tmemset(terminators, 0, sizeof(terminators));\n\n\tFOREACH(ss, subsystems) {\n\t\tif ((*ss)->init) {\n\t\t\terror = (*ss)->init(evbase);\n\t\t\tif (error)\n\t\t\t\tgoto shutdown;\n\t\t}\n\t}\n\n\tif (pidfile) {\n\t\tf = fopen(pidfile, \"w\");\n\t\tif (!f) {\n\t\t\tperror(\"Unable to open pidfile for write\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\tfprintf(f, \"%d\\n\", getpid());\n\t\tfclose(f);\n\t}\n\n\tassert(SIZEOF_ARRAY(exit_signals) == SIZEOF_ARRAY(terminators));\n\tfor (i = 0; i < SIZEOF_ARRAY(exit_signals); i++) {\n\t\tsignal_set(&terminators[i], exit_signals[i], terminate, NULL);\n\t\tif (signal_add(&terminators[i], NULL) != 0) {\n\t\t\tlog_errno(LOG_ERR, \"signal_add\");\n\t\t\tgoto shutdown;\n\t\t}\n\t}\n\n\tif (LIBEVENT_VERSION_NUMBER != event_get_version_number()) {\n\t\tlog_error(LOG_WARNING, \"libevent version mismatch! headers %8x, runtime %8x\\n\", LIBEVENT_VERSION_NUMBER, event_get_version_number());\n\t}\n\n\tlog_error(LOG_NOTICE, \"redsocks started, conn_max=%u\", redsocks_conn_max());\n\n\tevent_dispatch();\n\n\tlog_error(LOG_NOTICE, \"redsocks goes down\");\n\nshutdown:\n\tfor (i = 0; i < SIZEOF_ARRAY(exit_signals); i++) {\n\t\tif (signal_initialized(&terminators[i])) {\n\t\t\tif (signal_del(&terminators[i]) != 0)\n\t\t\t\tlog_errno(LOG_WARNING, \"signal_del\");\n\t\t\tmemset(&terminators[i], 0, sizeof(terminators[i]));\n\t\t}\n\t}\n\n\tfor (--ss; ss >= subsystems; ss--)\n\t\tif ((*ss)->fini)\n\t\t\t(*ss)->fini();\n\n\tevent_base_free(evbase);\n\n\treturn !error ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "main.h",
          "type": "blob",
          "size": 0.6474609375,
          "content": "#ifndef MAIN_H_TUE_JAN_23_15_38_25_2007\n#define MAIN_H_TUE_JAN_23_15_38_25_2007\n\n#include \"parser.h\"\n\nstruct event_base;\n\ntypedef struct app_subsys_t {\n\tint (*init)(struct event_base*);\n\tint (*fini)();\n\tparser_section* conf_section;\n} app_subsys;\n\n#define SIZEOF_ARRAY(arr)        (sizeof(arr) / sizeof(arr[0]))\n#define FOREACH(ptr, array)      for (ptr = array; ptr < array + SIZEOF_ARRAY(array); ptr++)\n#define FOREACH_REV(ptr, array)  for (ptr = array + SIZEOF_ARRAY(array) - 1; ptr >= array; ptr--)\n\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* MAIN_H_TUE_JAN_23_15_38_25_2007 */\n"
        },
        {
          "name": "md5.c",
          "type": "blob",
          "size": 11.7490234375,
          "content": "/*\n  Copyright (C) 1999, 2000, 2002 Aladdin Enterprises.  All rights reserved.\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  L. Peter Deutsch\n  ghost@aladdin.com\n\n */\n/* $Id: md5.c,v 1.6 2002/04/13 19:20:28 lpd Exp $ */\n/*\n  Independent implementation of MD5 (RFC 1321).\n\n  This code implements the MD5 Algorithm defined in RFC 1321, whose\n  text is available at\n\thttp://www.ietf.org/rfc/rfc1321.txt\n  The code is derived from the text of the RFC, including the test suite\n  (section A.5) but excluding the rest of Appendix A.  It does not include\n  any code or documentation that is identified in the RFC as being\n  copyrighted.\n\n  The original and principal author of md5.c is L. Peter Deutsch\n  <ghost@aladdin.com>.  Other authors are noted in the change history\n  that follows (in reverse chronological order):\n\n  2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order\n\teither statically or dynamically; added missing #include <string.h>\n\tin library.\n  2002-03-11 lpd Corrected argument list for main(), and added int return\n\ttype, in test program and T value program.\n  2002-02-21 lpd Added missing #include <stdio.h> in test program.\n  2000-07-03 lpd Patched to eliminate warnings about \"constant is\n\tunsigned in ANSI C, signed in traditional\"; made test program\n\tself-checking.\n  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.\n  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).\n  1999-05-03 lpd Original version.\n */\n\n#include \"md5.h\"\n#include <string.h>\n\n#undef BYTE_ORDER\t/* 1 = big-endian, -1 = little-endian, 0 = unknown */\n#ifdef ARCH_IS_BIG_ENDIAN\n#  define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1)\n#else\n#  define BYTE_ORDER 0\n#endif\n\n#define T_MASK ((md5_word_t)~0)\n#define T1 /* 0xd76aa478 */ (T_MASK ^ 0x28955b87)\n#define T2 /* 0xe8c7b756 */ (T_MASK ^ 0x173848a9)\n#define T3    0x242070db\n#define T4 /* 0xc1bdceee */ (T_MASK ^ 0x3e423111)\n#define T5 /* 0xf57c0faf */ (T_MASK ^ 0x0a83f050)\n#define T6    0x4787c62a\n#define T7 /* 0xa8304613 */ (T_MASK ^ 0x57cfb9ec)\n#define T8 /* 0xfd469501 */ (T_MASK ^ 0x02b96afe)\n#define T9    0x698098d8\n#define T10 /* 0x8b44f7af */ (T_MASK ^ 0x74bb0850)\n#define T11 /* 0xffff5bb1 */ (T_MASK ^ 0x0000a44e)\n#define T12 /* 0x895cd7be */ (T_MASK ^ 0x76a32841)\n#define T13    0x6b901122\n#define T14 /* 0xfd987193 */ (T_MASK ^ 0x02678e6c)\n#define T15 /* 0xa679438e */ (T_MASK ^ 0x5986bc71)\n#define T16    0x49b40821\n#define T17 /* 0xf61e2562 */ (T_MASK ^ 0x09e1da9d)\n#define T18 /* 0xc040b340 */ (T_MASK ^ 0x3fbf4cbf)\n#define T19    0x265e5a51\n#define T20 /* 0xe9b6c7aa */ (T_MASK ^ 0x16493855)\n#define T21 /* 0xd62f105d */ (T_MASK ^ 0x29d0efa2)\n#define T22    0x02441453\n#define T23 /* 0xd8a1e681 */ (T_MASK ^ 0x275e197e)\n#define T24 /* 0xe7d3fbc8 */ (T_MASK ^ 0x182c0437)\n#define T25    0x21e1cde6\n#define T26 /* 0xc33707d6 */ (T_MASK ^ 0x3cc8f829)\n#define T27 /* 0xf4d50d87 */ (T_MASK ^ 0x0b2af278)\n#define T28    0x455a14ed\n#define T29 /* 0xa9e3e905 */ (T_MASK ^ 0x561c16fa)\n#define T30 /* 0xfcefa3f8 */ (T_MASK ^ 0x03105c07)\n#define T31    0x676f02d9\n#define T32 /* 0x8d2a4c8a */ (T_MASK ^ 0x72d5b375)\n#define T33 /* 0xfffa3942 */ (T_MASK ^ 0x0005c6bd)\n#define T34 /* 0x8771f681 */ (T_MASK ^ 0x788e097e)\n#define T35    0x6d9d6122\n#define T36 /* 0xfde5380c */ (T_MASK ^ 0x021ac7f3)\n#define T37 /* 0xa4beea44 */ (T_MASK ^ 0x5b4115bb)\n#define T38    0x4bdecfa9\n#define T39 /* 0xf6bb4b60 */ (T_MASK ^ 0x0944b49f)\n#define T40 /* 0xbebfbc70 */ (T_MASK ^ 0x4140438f)\n#define T41    0x289b7ec6\n#define T42 /* 0xeaa127fa */ (T_MASK ^ 0x155ed805)\n#define T43 /* 0xd4ef3085 */ (T_MASK ^ 0x2b10cf7a)\n#define T44    0x04881d05\n#define T45 /* 0xd9d4d039 */ (T_MASK ^ 0x262b2fc6)\n#define T46 /* 0xe6db99e5 */ (T_MASK ^ 0x1924661a)\n#define T47    0x1fa27cf8\n#define T48 /* 0xc4ac5665 */ (T_MASK ^ 0x3b53a99a)\n#define T49 /* 0xf4292244 */ (T_MASK ^ 0x0bd6ddbb)\n#define T50    0x432aff97\n#define T51 /* 0xab9423a7 */ (T_MASK ^ 0x546bdc58)\n#define T52 /* 0xfc93a039 */ (T_MASK ^ 0x036c5fc6)\n#define T53    0x655b59c3\n#define T54 /* 0x8f0ccc92 */ (T_MASK ^ 0x70f3336d)\n#define T55 /* 0xffeff47d */ (T_MASK ^ 0x00100b82)\n#define T56 /* 0x85845dd1 */ (T_MASK ^ 0x7a7ba22e)\n#define T57    0x6fa87e4f\n#define T58 /* 0xfe2ce6e0 */ (T_MASK ^ 0x01d3191f)\n#define T59 /* 0xa3014314 */ (T_MASK ^ 0x5cfebceb)\n#define T60    0x4e0811a1\n#define T61 /* 0xf7537e82 */ (T_MASK ^ 0x08ac817d)\n#define T62 /* 0xbd3af235 */ (T_MASK ^ 0x42c50dca)\n#define T63    0x2ad7d2bb\n#define T64 /* 0xeb86d391 */ (T_MASK ^ 0x14792c6e)\n\n\nstatic void md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)\n{\n\tmd5_word_t\n\t\ta = pms->abcd[0], b = pms->abcd[1],\n\t\tc = pms->abcd[2], d = pms->abcd[3];\n\tmd5_word_t t;\n#if BYTE_ORDER > 0\n\t/* Define storage only for big-endian CPUs. */\n\tmd5_word_t X[16];\n#else\n\t/* Define storage for little-endian or both types of CPUs. */\n\tmd5_word_t xbuf[16];\n\tconst md5_word_t *X;\n#endif\n\n\t{\n#if BYTE_ORDER == 0\n\t\t/*\n\t\t * Determine dynamically whether this is a big-endian or\n\t\t * little-endian machine, since we can use a more efficient\n\t\t * algorithm on the latter.\n\t\t */\n\t\tstatic const int w = 1;\n\n\t\tif (*((const md5_byte_t *)&w)) /* dynamic little-endian */\n#endif\n#if BYTE_ORDER <= 0\t\t/* little-endian */\n\t\t{\n\t\t\t/*\n\t\t\t * On little-endian machines, we can process properly aligned\n\t\t\t * data without copying it.\n\t\t\t */\n\t\t\tif (!((data - (const md5_byte_t *)0) & 3)) {\n\t\t\t\t/* data are properly aligned */\n\t\t\t\tX = (const md5_word_t *)data;\n\t\t\t} else {\n\t\t\t\t/* not aligned */\n\t\t\t\tmemcpy(xbuf, data, 64);\n\t\t\t\tX = xbuf;\n\t\t\t}\n\t\t}\n#endif\n#if BYTE_ORDER == 0\n\t\telse\t\t\t/* dynamic big-endian */\n#endif\n#if BYTE_ORDER >= 0\t\t/* big-endian */\n\t\t{\n\t\t\t/*\n\t\t\t * On big-endian machines, we must arrange the bytes in the\n\t\t\t * right order.\n\t\t\t */\n\t\t\tconst md5_byte_t *xp = data;\n\t\t\tint i;\n\n#  if BYTE_ORDER == 0\n\t\t\tX = xbuf;\t\t/* (dynamic only) */\n#  else\n#    define xbuf X\t\t/* (static only) */\n#  endif\n\t\t\tfor (i = 0; i < 16; ++i, xp += 4)\n\t\t\t\txbuf[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);\n\t\t}\n#endif\n\t}\n\n#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))\n\n\t/* Round 1. */\n\t/* Let [abcd k s i] denote the operation\n\t   a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */\n#define F(x, y, z) (((x) & (y)) | (~(x) & (z)))\n#define SET(a, b, c, d, k, s, Ti)\\\n\tt = a + F(b,c,d) + X[k] + Ti;\\\n\ta = ROTATE_LEFT(t, s) + b\n\t/* Do the following 16 operations. */\n\tSET(a, b, c, d,  0,  7,  T1);\n\tSET(d, a, b, c,  1, 12,  T2);\n\tSET(c, d, a, b,  2, 17,  T3);\n\tSET(b, c, d, a,  3, 22,  T4);\n\tSET(a, b, c, d,  4,  7,  T5);\n\tSET(d, a, b, c,  5, 12,  T6);\n\tSET(c, d, a, b,  6, 17,  T7);\n\tSET(b, c, d, a,  7, 22,  T8);\n\tSET(a, b, c, d,  8,  7,  T9);\n\tSET(d, a, b, c,  9, 12, T10);\n\tSET(c, d, a, b, 10, 17, T11);\n\tSET(b, c, d, a, 11, 22, T12);\n\tSET(a, b, c, d, 12,  7, T13);\n\tSET(d, a, b, c, 13, 12, T14);\n\tSET(c, d, a, b, 14, 17, T15);\n\tSET(b, c, d, a, 15, 22, T16);\n#undef SET\n\n\t/* Round 2. */\n\t/* Let [abcd k s i] denote the operation\n\t   a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */\n#define G(x, y, z) (((x) & (z)) | ((y) & ~(z)))\n#define SET(a, b, c, d, k, s, Ti)\\\n\tt = a + G(b,c,d) + X[k] + Ti;\\\n\ta = ROTATE_LEFT(t, s) + b\n\t/* Do the following 16 operations. */\n\tSET(a, b, c, d,  1,  5, T17);\n\tSET(d, a, b, c,  6,  9, T18);\n\tSET(c, d, a, b, 11, 14, T19);\n\tSET(b, c, d, a,  0, 20, T20);\n\tSET(a, b, c, d,  5,  5, T21);\n\tSET(d, a, b, c, 10,  9, T22);\n\tSET(c, d, a, b, 15, 14, T23);\n\tSET(b, c, d, a,  4, 20, T24);\n\tSET(a, b, c, d,  9,  5, T25);\n\tSET(d, a, b, c, 14,  9, T26);\n\tSET(c, d, a, b,  3, 14, T27);\n\tSET(b, c, d, a,  8, 20, T28);\n\tSET(a, b, c, d, 13,  5, T29);\n\tSET(d, a, b, c,  2,  9, T30);\n\tSET(c, d, a, b,  7, 14, T31);\n\tSET(b, c, d, a, 12, 20, T32);\n#undef SET\n\n\t/* Round 3. */\n\t/* Let [abcd k s t] denote the operation\n\t   a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */\n#define H(x, y, z) ((x) ^ (y) ^ (z))\n#define SET(a, b, c, d, k, s, Ti)\\\n\tt = a + H(b,c,d) + X[k] + Ti;\\\n\ta = ROTATE_LEFT(t, s) + b\n\t/* Do the following 16 operations. */\n\tSET(a, b, c, d,  5,  4, T33);\n\tSET(d, a, b, c,  8, 11, T34);\n\tSET(c, d, a, b, 11, 16, T35);\n\tSET(b, c, d, a, 14, 23, T36);\n\tSET(a, b, c, d,  1,  4, T37);\n\tSET(d, a, b, c,  4, 11, T38);\n\tSET(c, d, a, b,  7, 16, T39);\n\tSET(b, c, d, a, 10, 23, T40);\n\tSET(a, b, c, d, 13,  4, T41);\n\tSET(d, a, b, c,  0, 11, T42);\n\tSET(c, d, a, b,  3, 16, T43);\n\tSET(b, c, d, a,  6, 23, T44);\n\tSET(a, b, c, d,  9,  4, T45);\n\tSET(d, a, b, c, 12, 11, T46);\n\tSET(c, d, a, b, 15, 16, T47);\n\tSET(b, c, d, a,  2, 23, T48);\n#undef SET\n\n\t/* Round 4. */\n\t/* Let [abcd k s t] denote the operation\n\t   a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */\n#define I(x, y, z) ((y) ^ ((x) | ~(z)))\n#define SET(a, b, c, d, k, s, Ti)\\\n\tt = a + I(b,c,d) + X[k] + Ti;\\\n\ta = ROTATE_LEFT(t, s) + b\n\t/* Do the following 16 operations. */\n\tSET(a, b, c, d,  0,  6, T49);\n\tSET(d, a, b, c,  7, 10, T50);\n\tSET(c, d, a, b, 14, 15, T51);\n\tSET(b, c, d, a,  5, 21, T52);\n\tSET(a, b, c, d, 12,  6, T53);\n\tSET(d, a, b, c,  3, 10, T54);\n\tSET(c, d, a, b, 10, 15, T55);\n\tSET(b, c, d, a,  1, 21, T56);\n\tSET(a, b, c, d,  8,  6, T57);\n\tSET(d, a, b, c, 15, 10, T58);\n\tSET(c, d, a, b,  6, 15, T59);\n\tSET(b, c, d, a, 13, 21, T60);\n\tSET(a, b, c, d,  4,  6, T61);\n\tSET(d, a, b, c, 11, 10, T62);\n\tSET(c, d, a, b,  2, 15, T63);\n\tSET(b, c, d, a,  9, 21, T64);\n#undef SET\n\n\t/* Then perform the following additions. (That is increment each\n\t   of the four registers by the value it had before this block\n\t   was started.) */\n\tpms->abcd[0] += a;\n\tpms->abcd[1] += b;\n\tpms->abcd[2] += c;\n\tpms->abcd[3] += d;\n}\n\nvoid md5_init(md5_state_t *pms)\n{\n\tpms->count[0] = pms->count[1] = 0;\n\tpms->abcd[0] = 0x67452301;\n\tpms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;\n\tpms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;\n\tpms->abcd[3] = 0x10325476;\n}\n\nvoid md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)\n{\n\tconst md5_byte_t *p = data;\n\tint left = nbytes;\n\tint offset = (pms->count[0] >> 3) & 63;\n\tmd5_word_t nbits = (md5_word_t)(nbytes << 3);\n\n\tif (nbytes <= 0)\n\t\treturn;\n\n\t/* Update the message length. */\n\tpms->count[1] += nbytes >> 29;\n\tpms->count[0] += nbits;\n\tif (pms->count[0] < nbits)\n\t\tpms->count[1]++;\n\n\t/* Process an initial partial block. */\n\tif (offset) {\n\t\tint copy = (offset + nbytes > 64 ? 64 - offset : nbytes);\n\n\t\tmemcpy(pms->buf + offset, p, copy);\n\t\tif (offset + copy < 64)\n\t\t\treturn;\n\t\tp += copy;\n\t\tleft -= copy;\n\t\tmd5_process(pms, pms->buf);\n\t}\n\n\t/* Process full blocks. */\n\tfor (; left >= 64; p += 64, left -= 64)\n\t\tmd5_process(pms, p);\n\n\t/* Process a final partial block. */\n\tif (left)\n\t\tmemcpy(pms->buf, p, left);\n}\n\nvoid md5_finish(md5_state_t *pms, md5_byte_t digest[16])\n{\n\tstatic const md5_byte_t pad[64] = {\n\t\t0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tmd5_byte_t data[8];\n\tint i;\n\n\t/* Save the length before padding. */\n\tfor (i = 0; i < 8; ++i)\n\t\tdata[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));\n\t/* Pad to 56 bytes mod 64. */\n\tmd5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);\n\t/* Append the length. */\n\tmd5_append(pms, data, 8);\n\tfor (i = 0; i < 16; ++i)\n\t\tdigest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));\n}\n"
        },
        {
          "name": "md5.h",
          "type": "blob",
          "size": 3.3125,
          "content": "/*\n  Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  L. Peter Deutsch\n  ghost@aladdin.com\n\n */\n/* $Id: md5.h,v 1.4 2002/04/13 19:20:28 lpd Exp $ */\n/*\n  Independent implementation of MD5 (RFC 1321).\n\n  This code implements the MD5 Algorithm defined in RFC 1321, whose\n  text is available at\n\thttp://www.ietf.org/rfc/rfc1321.txt\n  The code is derived from the text of the RFC, including the test suite\n  (section A.5) but excluding the rest of Appendix A.  It does not include\n  any code or documentation that is identified in the RFC as being\n  copyrighted.\n\n  The original and principal author of md5.h is L. Peter Deutsch\n  <ghost@aladdin.com>.  Other authors are noted in the change history\n  that follows (in reverse chronological order):\n\n  2002-04-13 lpd Removed support for non-ANSI compilers; removed\n\treferences to Ghostscript; clarified derivation from RFC 1321;\n\tnow handles byte order either statically or dynamically.\n  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.\n  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);\n\tadded conditionalization for C++ compilation from Martin\n\tPurschke <purschke@bnl.gov>.\n  1999-05-03 lpd Original version.\n */\n\n#ifndef md5_INCLUDED\n#  define md5_INCLUDED\n\n/*\n * This package supports both compile-time and run-time determination of CPU\n * byte order.  If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be\n * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is\n * defined as non-zero, the code will be compiled to run only on big-endian\n * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to\n * run on either big- or little-endian CPUs, but will run slightly less\n * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.\n */\n\ntypedef unsigned char md5_byte_t; /* 8-bit byte */\ntypedef unsigned int md5_word_t; /* 32-bit word */\n\n/* Define the state of the MD5 Algorithm. */\ntypedef struct md5_state_s {\n    md5_word_t count[2];\t/* message length in bits, lsw first */\n    md5_word_t abcd[4];\t\t/* digest buffer */\n    md5_byte_t buf[64];\t\t/* accumulate block */\n} md5_state_t;\n\n#ifdef __cplusplus\nextern \"C\" \n{\n#endif\n\n/* Initialize the algorithm. */\nvoid md5_init(md5_state_t *pms);\n\n/* Append a string to the message. */\nvoid md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes);\n\n/* Finish the message and return the digest. */\nvoid md5_finish(md5_state_t *pms, md5_byte_t digest[16]);\n\n#ifdef __cplusplus\n}  /* end extern \"C\" */\n#endif\n\n#endif /* md5_INCLUDED */\n"
        },
        {
          "name": "parser.c",
          "type": "blob",
          "size": 16.201171875,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <assert.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"utils.h\"\n#include \"parser.h\"\n#include \"log.h\"\n\n#define FREE(ptr) do { free(ptr); ptr = NULL; } while (0)\n\ntypedef int (*value_parser)(parser_context *context, void *addr, const char *token);\nstruct parser_context_t {\n\tFILE *fd;\n\tparser_section *sections;\n\tint line;\n\tint error;\n\tstruct {\n\t\tsize_t size;\n\t\tsize_t filled;\n\t\tchar *data;\n\t} buffer;\n};\n\n\nvoid parser_error(parser_context *context, const char *fmt, ...)\n{\n\tva_list ap;\n\tstruct evbuffer *buff = evbuffer_new();\n\tconst char *msg;\n\n\tva_start(ap, fmt);\n\tif (buff) {\n\t\tevbuffer_add_vprintf(buff, fmt, ap);\n\t\tmsg = (const char*)evbuffer_pullup(buff, -1);\n\t}\n\telse\n\t\tmsg = error_lowmem;\n\tva_end(ap);\n\n\tcontext->error = 1;\n\tfprintf(stderr, \"file parsing error at line %u: %s\\n\", context->line, msg);\n\tif (buff)\n\t\tevbuffer_free(buff);\n}\n\nparser_context* parser_start(FILE *fd)\n{\n\tparser_context *ret = calloc(1, sizeof(parser_context));\n\tif (!ret)\n\t\treturn NULL;\n\tret->fd = fd;\n\tret->buffer.size = 128; // should be big enough to fetch whole ``line``\n\tret->buffer.data = malloc(ret->buffer.size);\n\tif (!ret->buffer.data) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nvoid parser_add_section(parser_context *context, parser_section *section)\n{\n\tsection->next = context->sections;\n\tcontext->sections = section;\n\tsection->context = context;\n}\n\nvoid parser_stop(parser_context *context)\n{\n\tfree(context->buffer.data);\n\tfree(context);\n}\n\nstatic char unescape(int c)\n{\n\tswitch (c) {\n\t\tcase 'n': return '\\n';\n\t\tcase 't': return '\\t';\n\t\tcase 'r': return '\\r';\n\n\t\tcase '\\\\': return '\\\\';\n\t\tcase '\\'': return '\\'';\n\t\tcase '\\\"': return '\\\"';\n\n\t\tdefault: return 0;\n\t}\n}\n\n/** returns NULL on invalid OR incomplete token\n */\nstatic char *gettoken(parser_context *context, char **iter)\n{\n\tchar *ret = NULL;\n\tsize_t len = 0;\n\tenum {\n\t\tgt_cstr,\n\t\tgt_plainstr\n\t} copytype;\n\n\t// skip spaces\n\twhile (**iter && isspace(**iter))\n\t\t(*iter)++;\n\tif ( !**iter )\n\t\treturn NULL;\n\n\t// count strlen() of output buffer\n\tif ( **iter == '\\\"' ) { // string with escapes and spaces\n\t\tchar *p = *iter + 1;\n\n\t\tcopytype = gt_cstr;\n\t\twhile ( 1 ) {\n\t\t\tif (*p == '\\0')\n\t\t\t\treturn NULL;\n\t\t\tif (*p == '\\\"')\n\t\t\t\tbreak;\n\t\t\tif (*p == '\\\\') {\n\t\t\t\tif ( p[1] != '\\0') {\n\t\t\t\t\tif ( unescape(p[1]) )\n\t\t\t\t\t\tp++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tparser_error(context, \"unknown escaped char after \\\\\");\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen++;\n\t\t\tp++;\n\t\t}\n\t}\n\telse if ( isdigit(**iter) ) { // integer OR IP/NETMASK\n\t\tchar *p = *iter;\n\t\tcopytype = gt_plainstr;\n\t\twhile ( 1 ) {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\treturn NULL;\n\t\t\telse if ( isdigit(*p) || *p == '.' )\n\t\t\t\tp++;\n\t\t\telse if ( *p == '/' ) {\n\t\t\t\tif (isdigit(p[1]))\n\t\t\t\t\tp++;\n\t\t\t\telse if (p[1] == '/' || p[1] == '*') // comment token is coming!\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tlen = p - *iter;\n\t}\n\telse if ( isalpha(**iter) ) { // simple-string\n\t\tchar *p = *iter;\n\t\tcopytype = gt_plainstr;\n\t\twhile ( 1 ) {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\treturn NULL;\n\t\t\telse if (isalnum(*p) || *p == '_' || *p == '.' || *p == '-') // for domain-names\n\t\t\t\tp++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tlen = p - *iter;\n\t}\n\telse if ( **iter == '{' || **iter == '}' || **iter == '=' || **iter == ';' ) { // config punctuation\n\t\tcopytype = gt_plainstr;\n\t\tlen = 1;\n\t}\n\telse if ( **iter == '/' && ( (*iter)[1] == '/' || (*iter)[1] == '*' ) ) { // comment-start\n\t\tcopytype = gt_plainstr;\n\t\tlen = 2;\n\t}\n\telse {\n\t\tparser_error(context, \"unexpected char\");\n\t\treturn NULL;\n\t}\n\n\tret = malloc(len + 1);\n\tif (!ret) {\n\t\tparser_error(context, \"malloc failed\");\n\t\treturn NULL;\n\t}\n\n\tif (copytype == gt_cstr) {\n\t\tchar *p = ret;\n\t\t(*iter)++;\n\t\twhile ( 1 ) {\n\t\t\tif (**iter == '\\\"') {\n\t\t\t\t(*iter)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (**iter == '\\\\') {\n\t\t\t\t*p = unescape(*(*iter + 1));\n\t\t\t\t(*iter)++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*p = **iter;\n\t\t\t}\n\t\t\t(*iter)++;\n\t\t\tp++;\n\t\t}\n\t\t*p = 0;\n\t}\n\telse if (copytype == gt_plainstr) {\n\t\tmemcpy(ret, *iter, len);\n\t\t*iter += len;\n\t\tret[len] = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void context_filled_add(parser_context *context, int shift)\n{\n\tcontext->buffer.filled += shift;\n\tcontext->buffer.data[context->buffer.filled] = 0;\n}\n\nstatic void context_filled_set(parser_context *context, size_t val)\n{\n\tcontext->buffer.filled = val;\n\tcontext->buffer.data[context->buffer.filled] = 0;\n}\n\nstatic int vp_pbool(parser_context *context, void *addr, const char *token)\n{\n\tchar *strtrue[] = { \"ok\", \"on\", \"yes\", \"true\" };\n\tchar *strfalse[] = { \"off\", \"no\", \"false\" };\n\tchar **tpl;\n\n\tFOREACH(tpl, strtrue)\n\t\tif (strcmp(token, *tpl) == 0) {\n\t\t\t*(bool*)addr = true;\n\t\t\treturn 0;\n\t\t}\n\n\tFOREACH(tpl, strfalse)\n\t\tif (strcmp(token, *tpl) == 0) {\n\t\t\t*(bool*)addr = false;\n\t\t\treturn 0;\n\t\t}\n\n\tparser_error(context, \"boolean is not parsed\");\n\treturn -1;\n}\n\nstatic int vp_disclose_src(parser_context *context, void *addr, const char *token)\n{\n\tenum disclose_src_e *dst = addr;\n\tstruct { char *name; enum disclose_src_e value; } opt[] = {\n\t\t{ \"off\", DISCLOSE_NONE },\n\t\t{ \"no\", DISCLOSE_NONE },\n\t\t{ \"false\", DISCLOSE_NONE },\n\t\t{ \"X-Forwarded-For\", DISCLOSE_X_FORWARDED_FOR },\n\t\t{ \"Forwarded_ip\", DISCLOSE_FORWARDED_IP },\n\t\t{ \"Forwarded_ipport\", DISCLOSE_FORWARDED_IPPORT },\n\t};\n\tfor (int i = 0; i < SIZEOF_ARRAY(opt); ++i) {\n\t\tif (strcmp(token, opt[i].name) == 0) {\n\t\t\t*dst = opt[i].value;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tparser_error(context, \"disclose_src <%s> is not parsed\", token);\n\treturn -1;\n}\n\nstatic int vp_on_proxy_fail(parser_context *context, void *addr, const char *token)\n{\n\tenum on_proxy_fail_e *dst = addr;\n\tstruct { char *name; enum on_proxy_fail_e value; } opt[] = {\n\t\t{ \"close\", ONFAIL_CLOSE },\n\t\t{ \"forward_http_err\", ONFAIL_FORWARD_HTTP_ERR },\n\t};\n\tfor (int i = 0; i < SIZEOF_ARRAY(opt); ++i) {\n\t\tif (strcmp(token, opt[i].name) == 0) {\n\t\t\t*dst = opt[i].value;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tparser_error(context, \"on_proxy_fail <%s> is not parsed\", token);\n\treturn -1;\n}\n\nstatic int vp_pchar(parser_context *context, void *addr, const char *token)\n{\n\tchar *p = strdup(token);\n\tif (!p) {\n\t\tparser_error(context, \"strdup failed\");\n\t\treturn -1;\n\t}\n\t*(char**)addr = p;\n\treturn 0;\n}\n\nstatic int vp_uint16(parser_context *context, void *addr, const char *token)\n{\n\tchar *end;\n\tunsigned long int uli = strtoul(token, &end, 0);\n\tif (uli > 0xFFFF) {\n\t\tparser_error(context, \"integer out of 16bit range\");\n\t\treturn -1;\n\t}\n\tif (*end != '\\0') {\n\t\tparser_error(context, \"integer is not parsed\");\n\t\treturn -1;\n\t}\n\t*(uint16_t*)addr = (uint16_t)uli;\n\treturn 0;\n}\n\nstatic int vp_uint32(parser_context *context, void *addr, const char *token)\n{\n\tchar *end;\n\tuint32_t uli = strtoul(token, &end, 0);\n\tif (*end != '\\0') {\n\t\tparser_error(context, \"integer is not parsed\");\n\t\treturn -1;\n\t}\n\t*(uint32_t*)addr = uli;\n\treturn 0;\n}\n\nstatic int vp_in_addr(parser_context *context, void *addr, const char *token)\n{\n\tstruct in_addr ia;\n\n\tif (inet_aton(token, &ia)) {\n\t\tmemcpy(addr, &ia, sizeof(ia));\n\t}\n\telse {\n\t\tstruct addrinfo *ainfo, hints;\n\t\tint err;\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = AF_INET; /* IPv4-only */\n\t\thints.ai_socktype = SOCK_STREAM; /* I want to have one address once and ONLY once, that's why I specify socktype and protocol */\n\t\thints.ai_protocol = IPPROTO_TCP;\n\t\thints.ai_flags = AI_ADDRCONFIG; /* I don't need IPv4 addrs without IPv4 connectivity */\n\t\terr = getaddrinfo(token, NULL, &hints, &ainfo);\n\t\tif (err == 0) {\n\t\t\tint count, taken;\n\t\t\tstruct addrinfo *iter;\n\t\t\tstruct sockaddr_in *resolved_addr;\n\t\t\tfor (iter = ainfo, count = 0; iter; iter = iter->ai_next, ++count)\n\t\t\t\t;\n\t\t\ttaken = red_randui32() % count;\n\t\t\tfor (iter = ainfo; taken > 0; iter = iter->ai_next, --taken)\n\t\t\t\t;\n\t\t\tresolved_addr = (struct sockaddr_in*)iter->ai_addr;\n\t\t\tassert(resolved_addr->sin_family == iter->ai_family && iter->ai_family == AF_INET);\n\t\t\tif (count != 1)\n\t\t\t\tlog_error(LOG_WARNING, \"%s resolves to %d addresses, using %s\",\n\t\t\t\t          token, count, inet_ntoa(resolved_addr->sin_addr));\n\t\t\tmemcpy(addr, &resolved_addr->sin_addr, sizeof(ia));\n\t\t\tfreeaddrinfo(ainfo);\n\t\t}\n\t\telse {\n\t\t\tif (err == EAI_SYSTEM)\n\t\t\t\tparser_error(context, \"unable to resolve %s, error %d (%s)\", token, errno, strerror(errno));\n\t\t\telse\n\t\t\t\tparser_error(context, \"unable to resolve %s, getaddrinfo error %d (%s)\", token, err, gai_strerror(err));\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vp_in_addr2(parser_context *context, void *addr, const char *token)\n{\n\tchar *host = NULL, *mask = NULL;\n\tstruct in_addr ia;\n\tint retval = 0;\n\n\thost = strdup(token);\n\tif (!host) {\n\t\tparser_error(context, \"strdup failed\");\n\t\treturn -1;\n\t}\n\tmask = strchr(host, '/');\n\tif (mask) {\n\t\t*mask = '\\0';\n\t\tmask++;\n\t}\n\n\tif (inet_aton(host, &ia)) {\n\t\tmemcpy(addr, &ia, sizeof(ia));\n\t}\n\telse {\n\t\tparser_error(context, \"invalid IP address\");\n\t\tretval = -1;\n\t}\n\n\tif (mask) {\n\t\tstruct in_addr *pinmask = ((struct in_addr*)addr) + 1;\n\t\tchar *end;\n\t\tunsigned long int uli = strtoul(mask, &end, 0);;\n\t\tif (*end == '.') {\n\t\t\tif (inet_aton(mask, &ia)) {\n\t\t\t\tmemcpy(pinmask , &ia, sizeof(ia));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparser_error(context, \"invalid IP address\");\n\t\t\t\tretval = -1;\n\t\t\t}\n\t\t}\n\t\telse if (0 < uli && uli < 32) {\n\t\t\tpinmask->s_addr = htonl((INADDR_BROADCAST << (32 - uli)));\n\t\t}\n\t\telse {\n\t\t\tparser_error(context, \"number of netmask bits out of range\");\n\t\t\tretval = -1;\n\t\t}\n\t}\n\n\tfree(host);\n\treturn retval;\n}\n\nstatic int vp_obsolete(parser_context *context, void *addr, const char *token)\n{\n\tparser_error(context, \"obsolete key, delete it\");\n\treturn -1;\n}\n\nstatic int vp_redsocks_max_accept_backoff(parser_context *context, void *addr, const char *token)\n{\n\tparser_error(context, \"max_accept_backoff is not per-port setting anymore, move it from `redsocks` to `base`\");\n\treturn -1;\n}\n\nstatic value_parser value_parser_by_type[] =\n{\n\t[pt_bool] = vp_pbool,\n\t[pt_pchar] = vp_pchar,\n\t[pt_uint16] = vp_uint16,\n\t[pt_uint32] = vp_uint32,\n\t[pt_in_addr] = vp_in_addr,\n\t[pt_in_addr2] = vp_in_addr2,\n\t[pt_disclose_src] = vp_disclose_src,\n\t[pt_on_proxy_fail] = vp_on_proxy_fail,\n\t[pt_obsolete] = vp_obsolete,\n\t[pt_redsocks_max_accept_backoff] = vp_redsocks_max_accept_backoff,\n};\n\nint parser_run(parser_context *context)\n{\n\tchar *section_token = NULL, *key_token = NULL, *value_token = NULL;\n\tparser_section *section = NULL;\n\tbool in_comment = false;\n\tbool need_more_space = false;\n\tbool need_more_data  = true;\n\twhile ( !context->error && !feof(context->fd) ) {\n\t\tassert(context->buffer.filled < context->buffer.size); // ``<`` and not ``<=``\n\n\t\tif (need_more_space) {\n\t\t\tchar *new = realloc(context->buffer.data, context->buffer.size * 2);\n\t\t\tif (!new) {\n\t\t\t\tparser_error(context, \"realloc failure\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcontext->buffer.data = new;\n\t\t\tcontext->buffer.size *= 2;\n\t\t\tneed_more_space = false;\n\t\t}\n\n\t\tif (need_more_data) { // read one line per call\n\t\t\tchar *sbegin = context->buffer.data + context->buffer.filled;\n\t\t\tint len;\n\t\t\tif (fgets(sbegin, context->buffer.size - context->buffer.filled, context->fd) == NULL) {\n\t\t\t\tif (ferror(context->fd)) {\n\t\t\t\t\tparser_error(context, \"file read failure\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen(sbegin);\n\t\t\tcontext_filled_add(context, +len);\n\t\t\tif (len > 0 && sbegin[len - 1] == '\\n') {\n\t\t\t\tcontext->line++;\n\t\t\t\tneed_more_data = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tneed_more_space = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ( in_comment ) {\n\t\t\tchar *endc = strstr(context->buffer.data, \"*/\");\n\t\t\tif (endc) {\n\t\t\t\tendc += 2;\n\t\t\t\tint comment_len = endc - context->buffer.data;\n\t\t\t\tmemmove(context->buffer.data, endc, context->buffer.filled - comment_len);\n\t\t\t\tcontext_filled_add(context, -comment_len);\n\t\t\t\tin_comment = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext_filled_set(context, 0);\n\t\t\t\tneed_more_data = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tchar *token = NULL, *iter = context->buffer.data;\n\t\twhile ( !context->error && !in_comment && (token = gettoken(context, &iter)) ) {\n\t\t\tif (strcmp(token, \"//\") == 0) {\n\t\t\t\tchar *endc = strchr(iter, '\\n');\n\t\t\t\titer -= 2;\n\t\t\t\tendc += 1;\n\t\t\t\t// |*data          |*iter        |*endc       -->|<--.filled\n\t\t\t\tint moved_len = context->buffer.filled - (endc - context->buffer.data);\n\t\t\t\tmemmove(iter, endc, moved_len);\n\t\t\t\tcontext_filled_add(context, -(endc - iter));\n\t\t\t}\n\t\t\telse if (strcmp(token, \"/*\") == 0) {\n\t\t\t\tint moved_len = iter - context->buffer.data;\n\t\t\t\tmemmove(context->buffer.data, iter, context->buffer.filled - moved_len);\n\t\t\t\tcontext_filled_add(context, -moved_len);\n\t\t\t\titer = context->buffer.data;\n\t\t\t\tin_comment = true;\n\t\t\t}\n\t\t\telse if (strcmp(token, \"{\") == 0) { // } - I love folding\n\t\t\t\tif (section) {\n\t\t\t\t\tparser_error(context, \"section-in-section is invalid\");\n\t\t\t\t}\n\t\t\t\telse if (!section_token) {\n\t\t\t\t\tparser_error(context, \"expected token before ``{''\"); // } - I love folding\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (parser_section *p = context->sections; p; p = p->next) {\n\t\t\t\t\t\tif (strcmp(p->name, section_token) == 0) {\n\t\t\t\t\t\t\tsection = p;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (section) {\n\t\t\t\t\t\tif (section->onenter)\n\t\t\t\t\t\t\tif ( section->onenter(section) == -1 )\n\t\t\t\t\t\t\t\tparser_error(context, \"section->onenter failed\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tparser_error(context, \"unknown section <%s>\", section_token);\n\t\t\t\t\t}\n\t\t\t\t\tFREE(section_token);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(token, \"}\") == 0) { // { - I love folding\n\t\t\t\tif (section) {\n\t\t\t\t\tif (section->onexit)\n\t\t\t\t\t\tif ( section->onexit(section) == -1 )\n\t\t\t\t\t\t\tparser_error(context, \"section->onexit failed\");\n\t\t\t\t\tsection = NULL;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser_error(context, \"can't close non-opened section\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(token, \"=\") == 0) {\n\t\t\t\tif (!section) {\n\t\t\t\t\tparser_error(context, \"assignment used outside of any section\");\n\t\t\t\t}\n\t\t\t\telse if (!key_token) {\n\t\t\t\t\tparser_error(context, \"assignment used without key\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t; // What can I do? :)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(token, \";\") == 0) {\n\t\t\t\tif (!section) {\n\t\t\t\t\tparser_error(context, \"assignment termination outside of any section\");\n\t\t\t\t}\n\t\t\t\telse if (key_token && !value_token) {\n\t\t\t\t\tparser_error(context, \"assignment has only key <%s> but no value\", key_token);\n\t\t\t\t}\n\t\t\t\telse if (key_token && value_token) {\n\t\t\t\t\tparser_entry *e;\n\t\t\t\t\tfor (e = section->entries; e->key; e++)\n\t\t\t\t\t\tif (strcmp(e->key, key_token) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (e->key) {\n\t\t\t\t\t\tif ( (value_parser_by_type[e->type])(context, e->addr, value_token) == -1 )\n\t\t\t\t\t\t\tparser_error(context, \"value <%s> can't be parsed for key <%s>\", value_token, key_token);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tparser_error(context, \"assignment with unknown key <%s>\", key_token);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t\tFREE(key_token);\n\t\t\t\tFREE(value_token);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!section && !section_token) {\n\t\t\t\t\tsection_token = token;\n\t\t\t\t\ttoken = 0;\n\t\t\t\t}\n\t\t\t\telse if (section && !key_token) {\n\t\t\t\t\tkey_token = token;\n\t\t\t\t\ttoken = 0;\n\t\t\t\t}\n\t\t\t\telse if (section && key_token && !value_token) {\n\t\t\t\t\tvalue_token = token;\n\t\t\t\t\ttoken = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparser_error(context, \"invalid token order: key_token=%s, value_token=%s, next token=%s\",\n\t\t\t\t\t             key_token, value_token, token);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(token);\n\t\t}\n\t\tint moved_len = iter - context->buffer.data;\n\t\tmemmove(context->buffer.data, iter, context->buffer.filled - moved_len);\n\t\tcontext_filled_add(context, -moved_len);\n\n\t\tif (!token)\n\t\t\tneed_more_data = true;\n\t}\n\t// file-error goes is thrown here\n\tif (section)\n\t\tparser_error(context, \"unclosed section\");\n\tif (section_token) {\n\t\tparser_error(context, \"stale section_token\");\n\t\tfree(section_token);\n\t}\n\tif (key_token) {\n\t\tparser_error(context, \"stale key_token\");\n\t\tfree(key_token);\n\t}\n\tif (value_token) {\n\t\tparser_error(context, \"stale value_token\");\n\t\tfree(value_token);\n\t}\n\treturn context->error ? -1 : 0;\n}\n\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "parser.h",
          "type": "blob",
          "size": 1.7314453125,
          "content": "#ifndef PARSER_H_THU_JAN_11_04_49_38_2007\n#define PARSER_H_THU_JAN_11_04_49_38_2007\n\n#include <stdio.h>\n#include <stdbool.h>\n\nenum disclose_src_e {\n\tDISCLOSE_NONE,\n\tDISCLOSE_X_FORWARDED_FOR,\n\tDISCLOSE_FORWARDED_IP,\n\tDISCLOSE_FORWARDED_IPPORT,\n};\n\nenum on_proxy_fail_e {\n\tONFAIL_CLOSE,\n\tONFAIL_FORWARD_HTTP_ERR,\n};\n\ntypedef enum {\n\tpt_bool,      // \"bool\" from stdbool.h, not \"_Bool\" or anything else\n\tpt_pchar,\n\tpt_uint16,\n\tpt_uint32,\n\tpt_in_addr,\n\tpt_in_addr2,  // inaddr[0] = net, inaddr[1] = netmask\n\tpt_disclose_src,\n\tpt_on_proxy_fail,\n\tpt_obsolete,\n\tpt_redsocks_max_accept_backoff,\n} parser_type;\n\ntypedef struct parser_entry_t {\n\tconst char    *key;\n\tparser_type    type;\n\tvoid          *addr;\n} parser_entry;\n\n\ntypedef struct parser_context_t parser_context;\n\n\ntypedef struct parser_section_t parser_section;\ntypedef int  (*parser_section_onenter)(parser_section *section);\ntypedef int  (*parser_section_onexit)(parser_section *section);\n\nstruct parser_section_t {\n\tparser_section         *next;\n\tparser_context         *context;\n\tconst char             *name;\n\tparser_section_onenter  onenter; // is called on entry to section\n\tparser_section_onexit   onexit;  // is called on exit from section\n\tparser_entry           *entries;\n\tvoid                   *data;\n};\n\n\n\nparser_context* parser_start(FILE *fd);\nvoid parser_add_section(parser_context *context, parser_section *section);\nint parser_run(parser_context *context);\nvoid parser_error(parser_context *context, const char *fmt, ...)\n#if defined(__GNUC__)\n\t__attribute__ (( format (printf, 2, 3) ))\n#endif\n;\nvoid parser_stop(parser_context *context);\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* PARSER_H_THU_JAN_11_04_49_38_2007 */\n"
        },
        {
          "name": "redsocks.c",
          "type": "blob",
          "size": 43.705078125,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <time.h>\n#include <errno.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <event.h>\n#include \"list.h\"\n#include \"parser.h\"\n#include \"log.h\"\n#include \"main.h\"\n#include \"base.h\"\n#include \"redsocks.h\"\n#include \"utils.h\"\n#include \"libevent-compat.h\"\n\n\n#define REDSOCKS_RELAY_HALFBUFF  4096\n\nenum pump_state_t {\n\tpump_active = -1,\n\tpump_MAX = 0,\n};\n\nstatic const char *redsocks_event_str(unsigned short what);\nstatic int redsocks_start_bufferpump(redsocks_client *client);\nstatic int redsocks_start_splicepump(redsocks_client *client);\n\nstatic void redsocks_conn_list_del(redsocks_client *client);\n\nextern relay_subsys http_connect_subsys;\nextern relay_subsys http_relay_subsys;\nextern relay_subsys socks4_subsys;\nextern relay_subsys socks5_subsys;\nstatic relay_subsys *relay_subsystems[] =\n{\n\t&http_connect_subsys,\n\t&http_relay_subsys,\n\t&socks4_subsys,\n\t&socks5_subsys,\n};\n\nstatic list_head instances = LIST_HEAD_INIT(instances);\n\n// Managing connection pressure.\nstatic uint32_t redsocks_conn;\nstatic uint32_t accept_backoff_ms;\nstatic struct event accept_backoff_ev;\n\nstatic parser_entry redsocks_entries[] =\n{\n\t{ .key = \"local_ip\",   .type = pt_in_addr },\n\t{ .key = \"local_port\", .type = pt_uint16 },\n\t{ .key = \"ip\",         .type = pt_in_addr },\n\t{ .key = \"port\",       .type = pt_uint16 },\n\t{ .key = \"type\",       .type = pt_pchar },\n\t{ .key = \"login\",      .type = pt_pchar },\n\t{ .key = \"password\",   .type = pt_pchar },\n\t{ .key = \"listenq\",    .type = pt_uint16 },\n\t{ .key = \"splice\",     .type = pt_bool },\n\t{ .key = \"disclose_src\", .type = pt_disclose_src },\n\t{ .key = \"on_proxy_fail\", .type = pt_on_proxy_fail },\n\t{ }\n};\n\nstatic bool is_splice_good()\n{\n\tstruct utsname u;\n\tif (uname(&u) != 0) {\n\t\treturn false;\n\t}\n\n\tunsigned long int v[4] = { 0, 0, 0, 0 };\n\tchar *rel = u.release;\n\tfor (int i = 0; i < SIZEOF_ARRAY(v); ++i) {\n\t\tv[i] = strtoul(rel, &rel, 0);\n\t\twhile (*rel && !isdigit(*rel))\n\t\t\t++rel;\n\t}\n\n\t// haproxy assumes that splice \"works\" for 2.6.27.13+\n\treturn (v[0] > 2) ||\n\t       (v[0] == 2 && v[1] > 6) ||\n\t       (v[0] == 2 && v[1] == 6 && v[2] > 27) ||\n\t       (v[0] == 2 && v[1] == 6 && v[2] == 27 && v[3] >= 13);\n}\n\nstatic int redsocks_onenter(parser_section *section)\n{\n\t// FIXME: find proper way to calulate instance_payload_len\n\tint instance_payload_len = 0;\n\trelay_subsys **ss;\n\tFOREACH(ss, relay_subsystems)\n\t\tif (instance_payload_len < (*ss)->instance_payload_len)\n\t\t\tinstance_payload_len = (*ss)->instance_payload_len;\n\n\tredsocks_instance *instance = calloc(1, sizeof(*instance) + instance_payload_len);\n\tif (!instance) {\n\t\tparser_error(section->context, \"Not enough memory\");\n\t\treturn -1;\n\t}\n\n\tINIT_LIST_HEAD(&instance->list);\n\tINIT_LIST_HEAD(&instance->clients);\n\tinstance->config.bindaddr.sin_family = AF_INET;\n\tinstance->config.bindaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tinstance->config.relayaddr.sin_family = AF_INET;\n\tinstance->config.relayaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t/* Default value can be checked in run-time, but I doubt anyone needs that.\n\t * Linux:   sysctl net.core.somaxconn\n\t * FreeBSD: sysctl kern.ipc.somaxconn */\n\tinstance->config.listenq = SOMAXCONN;\n\tinstance->config.use_splice = is_splice_good();\n\tinstance->config.disclose_src = DISCLOSE_NONE;\n\tinstance->config.on_proxy_fail = ONFAIL_CLOSE;\n\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr =\n\t\t\t(strcmp(entry->key, \"local_ip\") == 0)   ? (void*)&instance->config.bindaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"local_port\") == 0) ? (void*)&instance->config.bindaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"ip\") == 0)         ? (void*)&instance->config.relayaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"port\") == 0)       ? (void*)&instance->config.relayaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"type\") == 0)       ? (void*)&instance->config.type :\n\t\t\t(strcmp(entry->key, \"login\") == 0)      ? (void*)&instance->config.login :\n\t\t\t(strcmp(entry->key, \"password\") == 0)   ? (void*)&instance->config.password :\n\t\t\t(strcmp(entry->key, \"listenq\") == 0)    ? (void*)&instance->config.listenq :\n\t\t\t(strcmp(entry->key, \"splice\") == 0)     ? (void*)&instance->config.use_splice :\n\t\t\t(strcmp(entry->key, \"disclose_src\") == 0) ? (void*)&instance->config.disclose_src :\n\t\t\t(strcmp(entry->key, \"on_proxy_fail\") == 0) ? (void*)&instance->config.on_proxy_fail :\n\t\t\tNULL;\n\tsection->data = instance;\n\treturn 0;\n}\n\nstatic int redsocks_onexit(parser_section *section)\n{\n\t/* FIXME: Rewrite in bullet-proof style. There are memory leaks if config\n\t *        file is not correct, so correct on-the-fly config reloading is\n\t *        currently impossible.\n\t */\n\tredsocks_instance *instance = section->data;\n\n\tsection->data = NULL;\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr = NULL;\n\n\tinstance->config.bindaddr.sin_port = htons(instance->config.bindaddr.sin_port);\n\tinstance->config.relayaddr.sin_port = htons(instance->config.relayaddr.sin_port);\n\n\tif (instance->config.type) {\n\t\trelay_subsys **ss;\n\t\tFOREACH(ss, relay_subsystems) {\n\t\t\tif (!strcmp((*ss)->name, instance->config.type)) {\n\t\t\t\tinstance->relay_ss = *ss;\n\t\t\t\tlist_add(&instance->list, &instances);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!instance->relay_ss) {\n\t\t\tparser_error(section->context, \"invalid `type` <%s> for redsocks\", instance->config.type);\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse {\n\t\tparser_error(section->context, \"no `type` for redsocks\");\n\t\treturn -1;\n\t}\n\n\tif (instance->config.disclose_src != DISCLOSE_NONE && instance->relay_ss != &http_connect_subsys) {\n\t\tparser_error(section->context, \"only `http-connect` supports `disclose_src` at the moment\");\n\t\treturn -1;\n\t}\n\n\tif (instance->config.on_proxy_fail != ONFAIL_CLOSE && instance->relay_ss != &http_connect_subsys) {\n\t\tparser_error(section->context, \"only `http-connect` supports `on_proxy_fail` at the moment\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic parser_section redsocks_conf_section =\n{\n\t.name    = \"redsocks\",\n\t.entries = redsocks_entries,\n\t.onenter = redsocks_onenter,\n\t.onexit  = redsocks_onexit\n};\n\nvoid redsocks_log_write_plain(\n\t\tconst char *file, int line, const char *func, int do_errno,\n\t\tconst struct sockaddr_in *clientaddr, const struct sockaddr_in *destaddr,\n\t\tint priority, const char *orig_fmt, ...\n) {\n\tif (!should_log(priority))\n\t\treturn;\n\n\tint saved_errno = errno;\n\tstruct evbuffer *fmt = evbuffer_new();\n\tva_list ap;\n\tchar clientaddr_str[RED_INET_ADDRSTRLEN], destaddr_str[RED_INET_ADDRSTRLEN];\n\n\tif (!fmt) {\n\t\tlog_errno(LOG_ERR, \"evbuffer_new()\");\n\t\t// no return, as I have to call va_start/va_end\n\t}\n\n\tif (fmt) {\n\t\tevbuffer_add_printf(fmt, \"[%s->%s]: %s\",\n\t\t\t\tred_inet_ntop(clientaddr, clientaddr_str, sizeof(clientaddr_str)),\n\t\t\t\tred_inet_ntop(destaddr, destaddr_str, sizeof(destaddr_str)),\n\t\t\t\torig_fmt);\n\t}\n\n\tva_start(ap, orig_fmt);\n\tif (fmt) {\n\t\terrno = saved_errno;\n\t\t_log_vwrite(file, line, func, do_errno, priority, (const char*)evbuffer_pullup(fmt, -1), ap);\n\t\tevbuffer_free(fmt);\n\t}\n\tva_end(ap);\n}\n\nvoid redsocks_touch_client(redsocks_client *client)\n{\n\tredsocks_gettimeofday(&client->last_event);\n}\n\nstatic bool shut_both(redsocks_client *client)\n{\n\treturn client->relay_evshut == (EV_READ|EV_WRITE) && client->client_evshut == (EV_READ|EV_WRITE);\n}\n\nstatic int bufprio(redsocks_client *client, struct bufferevent *buffev)\n{\n\t// client errors are logged with LOG_INFO, server errors with LOG_NOTICE\n\treturn (buffev == client->client) ? LOG_INFO : LOG_NOTICE;\n}\n\nstatic const char* bufname(redsocks_client *client, struct bufferevent *buf)\n{\n\tassert(buf == client->client || buf == client->relay);\n\treturn buf == client->client ? \"client\" : \"relay\";\n}\n\nstatic void redsocks_relay_readcb(redsocks_client *client, struct bufferevent *from, struct bufferevent *to)\n{\n\tif (evbuffer_get_length(to->output) < to->wm_write.high) {\n\t\tif (bufferevent_write_buffer(to, from->input) == -1)\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_write_buffer\");\n\t}\n\telse {\n\t\tif (bufferevent_get_enabled(from) & EV_READ) {\n\t\t\tredsocks_log_error(client, LOG_DEBUG, \"backpressure: bufferevent_disable(%s, EV_READ)\", bufname(client, from));\n\t\t\tif (bufferevent_disable(from, EV_READ) == -1)\n\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_disable\");\n\t\t}\n\t}\n}\n\nstatic void redsocks_relay_writecb(redsocks_client *client, struct bufferevent *from, struct bufferevent *to)\n{\n\tassert(from == client->client || from == client->relay);\n\tchar from_eof = (from == client->client ? client->client_evshut : client->relay_evshut) & EV_READ;\n\n\tif (evbuffer_get_length(from->input) == 0 && from_eof) {\n\t\tredsocks_shutdown(client, to, SHUT_WR);\n\t}\n\telse if (evbuffer_get_length(to->output) < to->wm_write.high) {\n\t\tif (bufferevent_write_buffer(to, from->input) == -1)\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_write_buffer\");\n\t\tif (!from_eof && !(bufferevent_get_enabled(from) & EV_READ)) {\n\t\t\tredsocks_log_error(client, LOG_DEBUG, \"backpressure: bufferevent_enable(%s, EV_READ)\", bufname(client, from));\n\t\t\tif (bufferevent_enable(from, EV_READ) == -1)\n\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_enable\");\n\t\t}\n\t}\n}\n\nstatic void redsocks_relay_relayreadcb(struct bufferevent *from, void *_client)\n{\n\tredsocks_client *client = _client;\n\tredsocks_touch_client(client);\n\tredsocks_relay_readcb(client, client->relay, client->client);\n}\n\nstatic void redsocks_relay_relaywritecb(struct bufferevent *to, void *_client)\n{\n\tredsocks_client *client = _client;\n\tredsocks_touch_client(client);\n\tredsocks_relay_writecb(client, client->client, client->relay);\n}\n\nstatic void redsocks_relay_clientreadcb(struct bufferevent *from, void *_client)\n{\n\tredsocks_client *client = _client;\n\tredsocks_touch_client(client);\n\tredsocks_relay_readcb(client, client->client, client->relay);\n}\n\nstatic void redsocks_relay_clientwritecb(struct bufferevent *to, void *_client)\n{\n\tredsocks_client *client = _client;\n\tredsocks_touch_client(client);\n\tredsocks_relay_writecb(client, client->relay, client->client);\n}\n\nvoid redsocks_start_relay(redsocks_client *client)\n{\n\tif (client->instance->relay_ss->fini)\n\t\tclient->instance->relay_ss->fini(client);\n\n\tclient->state = pump_active;\n\n\tint error = ((client->instance->config.use_splice) ? redsocks_start_splicepump : redsocks_start_bufferpump)(client);\n\tif (!error)\n\t\tredsocks_log_error(client, LOG_DEBUG, \"data relaying started\");\n\telse\n\t\tredsocks_drop_client(client);\n}\n\nstatic int redsocks_start_bufferpump(redsocks_client *client)\n{\n\t// wm_write.high is respected by libevent-2.0.22 only for ssl and filters,\n\t// so it's implemented in redsocks callbacks.  wm_read.high works as expected.\n\tbufferevent_setwatermark(client->client, EV_READ|EV_WRITE, 0, REDSOCKS_RELAY_HALFBUFF);\n\tbufferevent_setwatermark(client->relay, EV_READ|EV_WRITE, 0, REDSOCKS_RELAY_HALFBUFF);\n\n\tclient->client->readcb = redsocks_relay_clientreadcb;\n\tclient->client->writecb = redsocks_relay_clientwritecb;\n\tclient->relay->readcb = redsocks_relay_relayreadcb;\n\tclient->relay->writecb = redsocks_relay_relaywritecb;\n\n\tint error = bufferevent_enable(client->client, (EV_READ|EV_WRITE) & ~(client->client_evshut));\n\tif (!error)\n\t\terror = bufferevent_enable(client->relay, (EV_READ|EV_WRITE) & ~(client->relay_evshut));\n\tif (error)\n\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_enable\");\n\treturn error;\n}\n\nstatic int pipeprio(redsocks_pump *pump, int fd)\n{\n\t// client errors are logged with LOG_INFO, server errors with LOG_NOTICE\n\treturn (fd == event_get_fd(&pump->client_read)) ? LOG_INFO : LOG_NOTICE;\n}\n\nstatic const char* pipename(redsocks_pump *pump, int fd)\n{\n\treturn (fd == event_get_fd(&pump->client_read)) ? \"client\" : \"relay\";\n}\n\nstatic void bufferevent_free_unused(struct bufferevent **p) {\n\tif (*p && !evbuffer_get_length((*p)->input) && !evbuffer_get_length((*p)->output)) {\n\t\tbufferevent_free(*p);\n\t\t*p = NULL;\n\t}\n}\n\nstatic bool would_block(int e) {\n\treturn e == EAGAIN || e == EWOULDBLOCK;\n}\n\ntypedef struct redsplice_write_ctx_t {\n\t// drain ebsrc[0], ebsrc[1], pisrc in that order\n\tstruct evbuffer *ebsrc[2];\n\tsplice_pipe *pisrc;\n\tstruct event *evsrc;\n\tstruct event *evdst;\n\tconst evshut_t *shut_src;\n\tevshut_t *shut_dst;\n} redsplice_write_ctx;\n\nstatic void redsplice_write_cb(redsocks_pump *pump, redsplice_write_ctx *c, int out)\n{\n\tbool has_data = false; // there is some pending data to be written\n\tbool can_write = true; // socket SEEMS TO BE writable\n\n\t// short write -- goto read/write management\n\t// write error -- drop client alltogether\n\t// full write  -- take next buffer\n\t// got EOF & no data -- relay EOF\n\n\tfor (int i = 0; i < SIZEOF_ARRAY(c->ebsrc); ++i) {\n\t\tstruct evbuffer *ebsrc = c->ebsrc[i];\n\t\tif (ebsrc) {\n\t\t\tconst size_t avail = evbuffer_get_length(ebsrc);\n\t\t\thas_data = !!avail;\n\t\t\tif (avail) {\n\t\t\t\tconst ssize_t sent = evbuffer_write(ebsrc, out);\n\t\t\t\tif (sent == -1) {\n\t\t\t\t\tif (would_block(errno)) { // short (zero) write\n\t\t\t\t\t\tcan_write = false;\n\t\t\t\t\t\tgoto decide;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tredsocks_log_errno(&pump->c, pipeprio(pump, out), \"evbuffer_write(to %s, %zu)\", pipename(pump, out), avail);\n\t\t\t\t\t\tredsocks_drop_client(&pump->c);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (avail == sent) {\n\t\t\t\t\thas_data = false; // unless stated otherwise\n\t\t\t\t} else { // short write\n\t\t\t\t\tcan_write = false;\n\t\t\t\t\tgoto decide;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdo {\n\t\thas_data = !!c->pisrc->size;\n\t\tconst size_t avail = c->pisrc->size;\n\t\tif (avail) {\n\t\t\tconst ssize_t sent = splice(c->pisrc->read, NULL, out, NULL, avail, SPLICE_F_MOVE|SPLICE_F_NONBLOCK);\n\t\t\tif (sent == -1) {\n\t\t\t\tif (would_block(errno)) { // short (zero) write\n\t\t\t\t\tcan_write = false;\n\t\t\t\t\tgoto decide;\n\t\t\t\t} else {\n\t\t\t\t\tredsocks_log_errno(&pump->c, pipeprio(pump, out), \"splice(to %s)\", pipename(pump, out));\n\t\t\t\t\tredsocks_drop_client(&pump->c);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc->pisrc->size -= sent;\n\t\t\t\tif (avail == sent) {\n\t\t\t\t\thas_data = false;\n\t\t\t\t} else { // short write\n\t\t\t\t\tcan_write = false;\n\t\t\t\t\tgoto decide;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (0);\n\ndecide:\n\tif (!has_data && (*c->shut_src & EV_READ) && !(*c->shut_dst & EV_WRITE)) {\n\t\tif (shutdown(out, SHUT_WR) != 0) {\n\t\t\tredsocks_log_errno(&pump->c, LOG_ERR, \"shutdown(%s, SHUT_WR)\", pipename(pump, out));\n\t\t}\n\t\t*c->shut_dst |= EV_WRITE;\n\t\tcan_write = false;\n\t\tassert(!c->pisrc->size);\n\t\tredsocks_close(c->pisrc->read);\n\t\tc->pisrc->read = -1;\n\t\tredsocks_close(c->pisrc->write);\n\t\tc->pisrc->write = -1;\n\t\tif (shut_both(&pump->c)) {\n\t\t\tredsocks_drop_client(&pump->c);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tassert(!(can_write && has_data)); // incomplete write to writable socket\n\n\tif (!can_write && has_data) {\n\t\tif (event_pending(c->evsrc, EV_READ, NULL))\n\t\t\tredsocks_log_error(&pump->c, LOG_DEBUG, \"backpressure: event_del(%s_read)\", pipename(pump, event_get_fd(c->evsrc)));\n\t\tredsocks_event_del(&pump->c, c->evsrc);\n\t\tredsocks_event_add(&pump->c, c->evdst);\n\t} else if (can_write && !has_data) {\n\t\tif (!event_pending(c->evsrc, EV_READ, NULL))\n\t\t\tredsocks_log_error(&pump->c, LOG_DEBUG, \"backpressure: event_add(%s_read)\", pipename(pump, event_get_fd(c->evsrc)));\n\t\tredsocks_event_add(&pump->c, c->evsrc);\n\t\tredsocks_event_del(&pump->c, c->evdst);\n\t} else if (!can_write && !has_data) { // something like EOF\n\t\tredsocks_event_del(&pump->c, c->evsrc);\n\t\tredsocks_event_del(&pump->c, c->evdst);\n\t}\n}\n\ntypedef struct redsplice_read_ctx_t {\n\tsplice_pipe *dst;\n\tstruct event *evsrc;\n\tstruct event *evdst;\n\tevshut_t *shut_src;\n} redsplice_read_ctx;\n\nstatic void redsplice_read_cb(redsocks_pump *pump, redsplice_read_ctx *c, int in)\n{\n\tconst size_t pipesize = 1048576; // some default value from fs.pipe-max-size\n\tconst ssize_t got = splice(in, NULL, c->dst->write, NULL, pipesize, SPLICE_F_MOVE|SPLICE_F_NONBLOCK);\n\tif (got == -1) {\n\t\tif (would_block(errno)) {\n\t\t\t// there is data at `in', but pipe is full\n\t\t\tif (!event_pending(c->evsrc, EV_READ, NULL))\n\t\t\t\tredsocks_log_error(&pump->c, LOG_DEBUG, \"backpressure: event_del(%s_read)\", pipename(pump, event_get_fd(c->evsrc)));\n\t\t\tredsocks_event_del(&pump->c, c->evsrc);\n\t\t} else {\n\t\t\tredsocks_log_errno(&pump->c, pipeprio(pump, in), \"splice(from %s)\", pipename(pump, in));\n\t\t\tredsocks_drop_client(&pump->c);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (got == 0) { // got EOF\n\t\tif (shutdown(in, SHUT_RD) != 0) {\n\t\t\tif (errno != ENOTCONN) { // do not log common case for splice()\n\t\t\t\tredsocks_log_errno(&pump->c, LOG_DEBUG, \"shutdown(%s, SHUT_RD) after EOF\", pipename(pump, in));\n\t\t\t}\n\t\t}\n\t\t*c->shut_src |= EV_READ;\n\t\tredsocks_event_del(&pump->c, c->evsrc);\n\t} else {\n\t\tc->dst->size += got;\n\t}\n\tevent_active(c->evdst, EV_WRITE, 0);\n}\n\nstatic void redsocks_touch_pump(redsocks_pump *pump)\n{\n\tredsocks_touch_client(&pump->c);\n\tbufferevent_free_unused(&pump->c.client);\n\tbufferevent_free_unused(&pump->c.relay);\n}\n\nstatic void redsplice_relay_read(int fd, short what, void *_pump)\n{\n\tredsocks_pump *pump = _pump;\n\tassert(fd == event_get_fd(&pump->relay_read) && (what & EV_READ));\n\tredsocks_touch_pump(pump);\n\tredsplice_read_ctx c = {\n\t\t.dst = &pump->reply,\n\t\t.evsrc = &pump->relay_read,\n\t\t.evdst = &pump->client_write,\n\t\t.shut_src = &pump->c.relay_evshut,\n\t};\n\tredsplice_read_cb(pump, &c, fd);\n}\n\nstatic void redsplice_client_read(int fd, short what, void *_pump)\n{\n\tredsocks_pump *pump = _pump;\n\tassert(fd == event_get_fd(&pump->client_read) && (what & EV_READ));\n\tredsocks_touch_pump(pump);\n\tredsplice_read_ctx c = {\n\t\t.dst = &pump->request,\n\t\t.evsrc = &pump->client_read,\n\t\t.evdst = &pump->relay_write,\n\t\t.shut_src = &pump->c.client_evshut,\n\t};\n\tredsplice_read_cb(pump, &c, fd);\n}\n\nstatic void redsplice_relay_write(int fd, short what, void *_pump)\n{\n\tredsocks_pump *pump = _pump;\n\tassert(fd == event_get_fd(&pump->relay_write) && (what & EV_WRITE));\n\tredsocks_touch_pump(pump);\n\tredsplice_write_ctx c = {\n\t\t.ebsrc = {\n\t\t\tpump->c.relay ? pump->c.relay->output : NULL,\n\t\t\tpump->c.client ? pump->c.client->input : NULL,\n\t\t},\n\t\t.pisrc = &pump->request,\n\t\t.evsrc = &pump->client_read,\n\t\t.evdst = &pump->relay_write,\n\t\t.shut_src = &pump->c.client_evshut,\n\t\t.shut_dst = &pump->c.relay_evshut,\n\t};\n\tredsplice_write_cb(pump, &c, fd);\n}\n\nstatic void redsplice_client_write(int fd, short what, void *_pump)\n{\n\tredsocks_pump *pump = _pump;\n\tassert(fd == event_get_fd(&pump->client_write) && (what & EV_WRITE));\n\tredsocks_touch_pump(pump);\n\tredsplice_write_ctx c = {\n\t\t.ebsrc = {\n\t\t\tpump->c.client ? pump->c.client->output : NULL,\n\t\t\tpump->c.relay ? pump->c.relay->input : NULL,\n\t\t},\n\t\t.pisrc = &pump->reply,\n\t\t.evsrc = &pump->relay_read,\n\t\t.evdst = &pump->client_write,\n\t\t.shut_src = &pump->c.relay_evshut,\n\t\t.shut_dst = &pump->c.client_evshut,\n\t};\n\tredsplice_write_cb(pump, &c, fd);\n}\n\nstatic int redsocks_start_splicepump(redsocks_client *client)\n{\n\tint error = bufferevent_disable(client->client, EV_READ|EV_WRITE);\n\tif (!error)\n\t\terror = bufferevent_disable(client->relay, EV_READ|EV_WRITE);\n\tif (error) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_disable\");\n\t\treturn error;\n\t}\n\n\t// going to steal this buffers to the socket\n\tevbuffer_unfreeze(client->client->input, 0);\n\tevbuffer_unfreeze(client->client->output, 1);\n\tevbuffer_unfreeze(client->relay->input, 0);\n\tevbuffer_unfreeze(client->relay->output, 1);\n\n\tredsocks_pump *pump = red_pump(client);\n\tif (!error)\n\t\terror = pipe2(&pump->request.read, O_NONBLOCK);\n\tif (!error)\n\t\terror = pipe2(&pump->reply.read, O_NONBLOCK);\n\tif (error) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"pipe2\");\n\t\treturn error;\n\t}\n\n\tstruct event_base *base = NULL;\n\tconst int relay_fd = bufferevent_getfd(client->relay);\n\tconst int client_fd = bufferevent_getfd(client->client);\n\tif (!error)\n\t\terror = event_assign(&pump->client_read, base, client_fd, EV_READ|EV_PERSIST, redsplice_client_read, pump);\n\tif (!error)\n\t\terror = event_assign(&pump->client_write, base, client_fd, EV_WRITE|EV_PERSIST, redsplice_client_write, pump);\n\tif (!error)\n\t\terror = event_assign(&pump->relay_read, base, relay_fd, EV_READ|EV_PERSIST, redsplice_relay_read, pump);\n\tif (!error)\n\t\terror = event_assign(&pump->relay_write, base, relay_fd, EV_WRITE|EV_PERSIST, redsplice_relay_write, pump);\n\tif (error) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"event_assign\");\n\t\treturn error;\n\t}\n\n\tredsocks_bufferevent_dropfd(client, client->relay);\n\tredsocks_bufferevent_dropfd(client, client->client);\n\n\t// flush buffers (if any) and enable EV_READ callbacks\n\tevent_active(&pump->client_write, EV_WRITE, 0);\n\tevent_active(&pump->relay_write, EV_WRITE, 0);\n\tredsocks_event_add(&pump->c, &pump->client_read);\n\tredsocks_event_add(&pump->c, &pump->relay_read);\n\n\treturn 0;\n}\n\nstatic bool has_loopback_destination(redsocks_client *client)\n{\n\tconst uint32_t net = ntohl(client->destaddr.sin_addr.s_addr) >> 24;\n\treturn 0 == memcmp(&client->destaddr.sin_addr, &client->instance->config.relayaddr.sin_addr, sizeof(client->destaddr.sin_addr))\n\t    || net == 127 || net == 0;\n}\n\nvoid redsocks_drop_client(redsocks_client *client)\n{\n\tif (shut_both(client)) {\n\t\tredsocks_log_error(client, LOG_INFO, \"connection closed\");\n\t} else {\n\t\tif (has_loopback_destination(client)) {\n\t\t\tstatic time_t last = 0;\n\t\t\tconst time_t now = redsocks_time(NULL);\n\t\t\tif (now - last >= 3600) {\n\t\t\t\t// log this warning once an hour to save some debugging time, OTOH it may be valid traffic in some cases\n\t\t\t\tredsocks_log_error(client, LOG_NOTICE, \"client tries to connect to the proxy using proxy! Usual proxy security policy is to drop alike connection\");\n\t\t\t\tlast = now;\n\t\t\t}\n\t\t}\n\n\t\tstruct timeval now, idle;\n\t\tredsocks_gettimeofday(&now); // FIXME: use CLOCK_MONOTONIC\n\t\ttimersub(&now, &client->last_event, &idle);\n\t\tredsocks_log_error(client, LOG_INFO, \"dropping client (%s), relay (%s), idle %ld.%06lds\",\n\t\t\tredsocks_event_str( (~client->client_evshut) & (EV_READ|EV_WRITE) ),\n\t\t\tredsocks_event_str( (~client->relay_evshut) & (EV_READ|EV_WRITE) ),\n\t\t\tidle.tv_sec, idle.tv_usec);\n\t}\n\n\tif (client->instance->relay_ss->fini)\n\t\tclient->instance->relay_ss->fini(client);\n\n\tif (client->client)\n\t\tredsocks_bufferevent_free(client->client);\n\n\tif (client->relay)\n\t\tredsocks_bufferevent_free(client->relay);\n\n\tif (client->instance->config.use_splice) {\n\t\tredsocks_pump *pump = red_pump(client);\n\n\t\tif (pump->request.read != -1)\n\t\t\tredsocks_close(pump->request.read);\n\t\tif (pump->request.write != -1)\n\t\t\tredsocks_close(pump->request.write);\n\t\tif (pump->reply.read != -1)\n\t\t\tredsocks_close(pump->reply.read);\n\t\tif (pump->reply.write != -1)\n\t\t\tredsocks_close(pump->reply.write);\n\n\t\t// redsocks_close MAY log error if some of events was not properly initialized\n\t\tint fd = -1;\n\t\tif (event_initialized(&pump->client_read)) {\n\t\t\tfd = event_get_fd(&pump->client_read);\n\t\t\tredsocks_event_del(&pump->c, &pump->client_read);\n\t\t}\n\t\tif (event_initialized(&pump->client_write)) {\n\t\t\tredsocks_event_del(&pump->c, &pump->client_write);\n\t\t}\n\t\tif (fd != -1)\n\t\t\tredsocks_close(fd);\n\n\t\tfd = -1;\n\t\tif (event_initialized(&pump->relay_read)) {\n\t\t\tfd = event_get_fd(&pump->relay_read);\n\t\t\tredsocks_event_del(&pump->c, &pump->relay_read);\n\t\t}\n\t\tif (event_initialized(&pump->relay_write)) {\n\t\t\tredsocks_event_del(&pump->c, &pump->relay_write);\n\t\t}\n\t\tif (fd != -1) {\n\t\t\tredsocks_close(fd);\n\t\t}\n\t}\n\tredsocks_conn_list_del(client);\n\tfree(client);\n}\n\nvoid redsocks_shutdown(redsocks_client *client, struct bufferevent *buffev, int how)\n{\n\tshort evhow = 0;\n\tconst char *strev, *strhow = NULL, *strevhow = NULL;\n\tunsigned short *pevshut;\n\n\tassert(how == SHUT_RD || how == SHUT_WR || how == SHUT_RDWR);\n\tassert(buffev == client->client || buffev == client->relay);\n\tassert(event_get_fd(&buffev->ev_read) == event_get_fd(&buffev->ev_write));\n\n\tif (how == SHUT_RD) {\n\t\tstrhow = \"SHUT_RD\";\n\t\tevhow = EV_READ;\n\t\tstrevhow = \"EV_READ\";\n\t}\n\telse if (how == SHUT_WR) {\n\t\tstrhow = \"SHUT_WR\";\n\t\tevhow = EV_WRITE;\n\t\tstrevhow = \"EV_WRITE\";\n\t}\n\telse if (how == SHUT_RDWR) {\n\t\tstrhow = \"SHUT_RDWR\";\n\t\tevhow = EV_READ|EV_WRITE;\n\t\tstrevhow = \"EV_READ|EV_WRITE\";\n\t}\n\n\tassert(strhow && strevhow);\n\n\tstrev = bufname(client, buffev);\n\tpevshut = buffev == client->client ? &client->client_evshut : &client->relay_evshut;\n\n\t// if EV_WRITE is already shut and we're going to shutdown read then\n\t// we're either going to abort data flow (bad behaviour) or confirm EOF\n\t// and in this case socket is already SHUT_RD'ed\n\tif ( !(how == SHUT_RD && (*pevshut & EV_WRITE)) ) {\n\t\tif (shutdown(event_get_fd(&buffev->ev_read), how) != 0)\n\t\t\tredsocks_log_errno(client, LOG_ERR, \"shutdown(%s, %s)\", strev, strhow);\n\t} else {\n\t\tredsocks_log_error(client, LOG_DEBUG, \"ignored shutdown(%s, %s)\", strev, strhow);\n\t}\n\n\tredsocks_log_error(client, LOG_DEBUG, \"shutdown: bufferevent_disable(%s, %s)\", strev, strevhow);\n\tif (bufferevent_disable(buffev, evhow) != 0)\n\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_disable(%s, %s)\", strev, strevhow);\n\n\t*pevshut |= evhow;\n\n\tif (shut_both(client)) {\n\t\tredsocks_log_error(client, LOG_DEBUG, \"both client and server disconnected\");\n\t\tredsocks_drop_client(client);\n\t}\n}\n\n// I assume that -1 is invalid errno value\nstatic int redsocks_socket_geterrno(redsocks_client *client, struct bufferevent *buffev)\n{\n\tint pseudo_errno = red_socket_geterrno(buffev);\n\tif (pseudo_errno == -1) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"red_socket_geterrno\");\n\t\treturn -1;\n\t}\n\treturn pseudo_errno;\n}\n\nstatic void redsocks_event_error(struct bufferevent *buffev, short what, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\tassert(buffev == client->relay || buffev == client->client);\n\tconst int bakerrno = errno;\n\n\tredsocks_touch_client(client);\n\n\tif (what == (EVBUFFER_READ|EVBUFFER_EOF)) {\n\t\tstruct bufferevent *antiev;\n\t\tif (buffev == client->relay)\n\t\t\tantiev = client->client;\n\t\telse\n\t\t\tantiev = client->relay;\n\n\t\tredsocks_shutdown(client, buffev, SHUT_RD);\n\n\t\t// If the client has already sent EOF and the pump is not active\n\t\t// (relay is activating), the code should not shutdown write-pipe.\n\t\tif (client->state == pump_active && antiev != NULL && evbuffer_get_length(antiev->output) == 0)\n\t\t\tredsocks_shutdown(client, antiev, SHUT_WR);\n\t}\n\telse {\n\t\tconst int sockrrno = redsocks_socket_geterrno(client, buffev);\n\t\tconst char *errsrc = \"\";\n\t\tif (sockrrno != -1 && sockrrno != 0) {\n\t\t\terrno = sockrrno;\n\t\t\terrsrc = \"socket \";\n\t\t} else {\n\t\t\terrno = bakerrno;\n\t\t}\n\t\tredsocks_log_errno(client, bufprio(client, buffev), \"%s %serror, code \" event_fmt_str,\n\t\t\t\tbufname(client, buffev),\n\t\t\t\terrsrc,\n\t\t\t\tevent_fmt(what));\n\t\tredsocks_drop_client(client);\n\t}\n}\n\nint sizes_equal(size_t a, size_t b)\n{\n\treturn a == b;\n}\n\nint sizes_greater_equal(size_t a, size_t b)\n{\n\treturn a >= b;\n}\n\nint redsocks_read_expected(redsocks_client *client, struct evbuffer *input, void *data, size_comparator comparator, size_t expected)\n{\n\tsize_t len = evbuffer_get_length(input);\n\tif (comparator(len, expected)) {\n\t\tint read = evbuffer_remove(input, data, expected);\n\t\tUNUSED(read);\n\t\tassert(read == expected);\n\t\treturn 0;\n\t}\n\telse {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"Can't get expected amount of data\");\n\t\tredsocks_drop_client(client);\n\t\treturn -1;\n\t}\n}\n\nstruct evbuffer *mkevbuffer(void *data, size_t len)\n{\n\tstruct evbuffer *buff = NULL, *retval = NULL;\n\n\tbuff = evbuffer_new();\n\tif (!buff) {\n\t\tlog_errno(LOG_ERR, \"evbuffer_new\");\n\t\tgoto fail;\n\t}\n\n\tif (evbuffer_add(buff, data, len) < 0) {\n\t\tlog_errno(LOG_ERR, \"evbuffer_add\");\n\t\tgoto fail;\n\t}\n\n\tretval = buff;\n\tbuff = NULL;\n\nfail:\n\tif (buff)\n\t\tevbuffer_free(buff);\n\treturn retval;\n}\n\nint redsocks_write_helper_ex(\n\tstruct bufferevent *buffev, redsocks_client *client,\n\tredsocks_message_maker mkmessage, int state, size_t wm_low, size_t wm_high)\n{\n\tassert(client);\n\treturn redsocks_write_helper_ex_plain(buffev, client, (redsocks_message_maker_plain)mkmessage,\n\t                                      client, state, wm_low, wm_high);\n}\n\nint redsocks_write_helper_ex_plain(\n\tstruct bufferevent *buffev, redsocks_client *client,\n\tredsocks_message_maker_plain mkmessage, void *p, int state, size_t wm_low, size_t wm_high)\n{\n\tint len;\n\tstruct evbuffer *buff = NULL;\n\tint drop = 1;\n\n\tif (mkmessage) {\n\t\tbuff = mkmessage(p);\n\t\tif (!buff)\n\t\t\tgoto fail;\n\n\t\tassert(!client || buffev == client->relay);\n\t\tlen = bufferevent_write_buffer(buffev, buff);\n\t\tif (len < 0) {\n\t\t\tif (client)\n\t\t\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_write_buffer\");\n\t\t\telse\n\t\t\t\tlog_errno(LOG_ERR, \"bufferevent_write_buffer\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (client)\n\t\tclient->state = state;\n\tbufferevent_setwatermark(buffev, EV_READ, wm_low, wm_high);\n\tbufferevent_enable(buffev, EV_READ);\n\tdrop = 0;\n\nfail:\n\tif (buff)\n\t\tevbuffer_free(buff);\n\tif (drop && client)\n\t\tredsocks_drop_client(client);\n\treturn drop ? -1 : 0;\n}\n\nint redsocks_write_helper(\n\tstruct bufferevent *buffev, redsocks_client *client,\n\tredsocks_message_maker mkmessage, int state, size_t wm_only)\n{\n\tassert(client);\n\treturn redsocks_write_helper_ex(buffev, client, mkmessage, state, wm_only, wm_only);\n}\n\nstatic void redsocks_relay_connected(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\n\tassert(buffev == client->relay);\n\n\tredsocks_touch_client(client);\n\n\tif (!red_is_socket_connected_ok(buffev)) {\n\t\tredsocks_log_errno(client, LOG_NOTICE, \"red_is_socket_connected_ok\");\n\t\tgoto fail;\n\t}\n\n\tclient->relay->readcb = client->instance->relay_ss->readcb;\n\tclient->relay->writecb = client->instance->relay_ss->writecb;\n\tclient->relay->writecb(buffev, _arg);\n\treturn;\n\nfail:\n\tredsocks_drop_client(client);\n}\n\nvoid redsocks_connect_relay(redsocks_client *client)\n{\n\tclient->relay = red_connect_relay(&client->instance->config.relayaddr,\n\t\t\t                          redsocks_relay_connected, redsocks_event_error, client);\n\tif (!client->relay) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"red_connect_relay\");\n\t\tredsocks_drop_client(client);\n\t}\n}\n\nstatic struct timeval drop_idle_connections()\n{\n\tassert(connpres_idle_timeout() > 0);\n\tstruct timeval now, zero, max_idle, best_next;\n\tgettimeofday(&now, NULL); // FIXME: use CLOCK_MONOTONIC\n\ttimerclear(&zero);\n\ttimerclear(&max_idle);\n\tmax_idle.tv_sec = connpres_idle_timeout();\n\tbest_next = max_idle;\n\n\tredsocks_instance *instance;\n\tlist_for_each_entry(instance, &instances, list) {\n\t\tredsocks_client *tmp, *client;\n\t\tlist_for_each_entry_safe(client, tmp, &instance->clients, list) {\n\t\t\tstruct timeval idle;\n\t\t\ttimersub(&now, &client->last_event, &idle);\n\t\t\tif (timercmp(&idle, &zero, <=) || timercmp(&max_idle, &idle, <=)) {\n\t\t\t\tredsocks_drop_client(client);\n\t\t\t\tbest_next = zero;\n\t\t\t} else {\n\t\t\t\tstruct timeval delay;\n\t\t\t\ttimersub(&max_idle, &idle, &delay);\n\t\t\t\tif (timercmp(&delay, &best_next, <)) {\n\t\t\t\t\tbest_next = delay;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn best_next;\n}\n\nstatic bool conn_pressure_ongoing()\n{\n\tif (redsocks_conn >= redsocks_conn_max())\n\t\treturn true;\n\tint fd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd == -1)\n\t\treturn true;\n\tclose(fd);\n\treturn false;\n}\n\nstatic void conn_pressure()\n{\n\tstruct timeval next;\n\ttimerclear(&next);\n\n\tif (connpres_idle_timeout()) {\n\t\tnext = drop_idle_connections();\n\t\tif (!timerisset(&next)) {\n\t\t\tlog_error(LOG_WARNING, \"dropped connections idle for %d+ seconds\", connpres_idle_timeout());\n\t\t\treturn; // pressure solved\n\t\t}\n\t}\n\n\taccept_backoff_ms = (accept_backoff_ms << 1) + 1;\n\tclamp_value(accept_backoff_ms, 1, max_accept_backoff_ms());\n\tuint32_t delay = (red_randui32() % accept_backoff_ms) + 1;\n\tstruct timeval tvdelay = { delay / 1000, (delay % 1000) * 1000 };\n\n\tif (timerisset(&next) && timercmp(&next, &tvdelay, <) ) {\n\t\ttvdelay = next;\n\t}\n\n\tlog_error(LOG_WARNING, \"accept: backing off for %ld.%06lds\", tvdelay.tv_sec, tvdelay.tv_usec);\n\n\tif (event_add(&accept_backoff_ev, &tvdelay) != 0)\n\t\tlog_errno(LOG_ERR, \"event_add\");\n\n\tredsocks_instance *self = NULL;\n\tlist_for_each_entry(self, &instances, list) {\n\t\tif (event_del(&self->listener) != 0)\n\t\t\tlog_errno(LOG_ERR, \"event_del\");\n\t}\n}\n\n// if there are no idle connections delay to the nearest one is returned\nstatic void accept_enable()\n{\n\tredsocks_instance *self = NULL;\n\tlist_for_each_entry(self, &instances, list) {\n\t\tif (event_add(&self->listener, NULL) != 0)\n\t\t\tlog_errno(LOG_ERR, \"event_add\");\n\t}\n}\n\nstatic void conn_pressure_lowered()\n{\n\tif (redsocks_conn >= redsocks_conn_max())\n\t\treturn; // lowered... not so much!\n\n\tif (event_pending(&accept_backoff_ev, EV_TIMEOUT, NULL)) {\n\t\tif (event_del(&accept_backoff_ev) != 0)\n\t\t\tlog_errno(LOG_ERR, \"event_del\");\n\t\taccept_enable();\n\t}\n}\n\nstatic void redsocks_accept_backoff(int fd, short what, void *_null)\n{\n\tif (conn_pressure_ongoing()) {\n\t\tconn_pressure(); // rearm timeout\n\t} else {\n\t\taccept_enable(); // `accept_backoff_ev` is not pending now\n\t}\n}\n\nvoid redsocks_close_internal(int fd, const char* file, int line, const char *func)\n{\n\tif (close(fd) == 0) {\n\t\tconn_pressure_lowered();\n\t}\n\telse {\n\t\tconst int do_errno = 1;\n\t\t_log_write(file, line, func, do_errno, LOG_WARNING, \"close\");\n\t}\n}\n\nvoid redsocks_event_add_internal(redsocks_client *client, struct event *ev, const char *file, int line, const char *func)\n{\n\tif (event_add(ev, NULL) != 0) {\n\t\tconst int do_errno = 1;\n\t\tredsocks_log_write_plain(file, line, func, do_errno, &(client)->clientaddr, &(client)->destaddr, LOG_WARNING, \"event_add\");\n\t}\n}\n\nvoid redsocks_event_del_internal(redsocks_client *client, struct event *ev, const char *file, int line, const char *func)\n{\n\tif (event_del(ev) != 0) {\n\t\tconst int do_errno = 1;\n\t\tredsocks_log_write_plain(file, line, func, do_errno, &(client)->clientaddr, &(client)->destaddr, LOG_WARNING, \"event_del\");\n\t}\n}\n\nvoid redsocks_bufferevent_dropfd_internal(redsocks_client *client, struct bufferevent *ev, const char *file, int line, const char *func)\n{\n\tif (bufferevent_setfd(ev, -1) != 0) {\n\t\tconst int do_errno = 1;\n\t\tredsocks_log_write_plain(file, line, func, do_errno, &(client)->clientaddr, &(client)->destaddr, LOG_WARNING, \"bufferevent_setfd\");\n\t}\n}\n\nvoid redsocks_bufferevent_free(struct bufferevent *buffev)\n{\n\tint fd = bufferevent_getfd(buffev);\n\tif (bufferevent_setfd(buffev, -1)) { // to avoid EBADFD warnings from epoll\n\t\tlog_errno(LOG_WARNING, \"bufferevent_setfd\");\n\t}\n\tbufferevent_free(buffev);\n\tif (fd != -1)\n\t\tredsocks_close(fd);\n}\n\nstatic void redsocks_conn_list_add(redsocks_instance *self, redsocks_client *client)\n{\n\tassert(list_empty(&client->list));\n\tassert(redsocks_conn < redsocks_conn_max());\n\tlist_add(&client->list, &self->clients);\n\tredsocks_conn++;\n\tif (redsocks_conn >= redsocks_conn_max()) {\n\t\tlog_error(LOG_WARNING, \"reached redsocks_conn_max limit, %d connections\", redsocks_conn);\n\t\tconn_pressure();\n\t}\n}\n\nstatic void redsocks_conn_list_del(redsocks_client *client)\n{\n\tif (!list_empty(&client->list)) {\n\t\tredsocks_conn--;\n\t\tlist_del(&client->list);\n\t}\n\tconn_pressure_lowered();\n}\n\nstatic void redsocks_accept_client(int fd, short what, void *_arg)\n{\n\tredsocks_instance *self = _arg;\n\tredsocks_client   *client = NULL;\n\tstruct sockaddr_in clientaddr;\n\tstruct sockaddr_in myaddr;\n\tstruct sockaddr_in destaddr;\n\tsocklen_t          addrlen = sizeof(clientaddr);\n\tint client_fd = -1;\n\tint error;\n\n\tassert(redsocks_conn < redsocks_conn_max());\n\n\t// working with client_fd\n\tclient_fd = accept(fd, (struct sockaddr*)&clientaddr, &addrlen);\n\tif (client_fd == -1) {\n\t\tconst int e = errno;\n\t\tlog_errno(LOG_WARNING, \"accept\");\n\t\t/* Different systems use different `errno` value to signal different\n\t\t * `lack of file descriptors` conditions. Here are most of them.  */\n\t\tif (e == ENFILE || e == EMFILE || e == ENOBUFS || e == ENOMEM) {\n\t\t\tconn_pressure();\n\t\t}\n\t\tgoto fail;\n\t}\n\taccept_backoff_ms = 0;\n\n\t// socket is really bound now (it could be bound to 0.0.0.0)\n\taddrlen = sizeof(myaddr);\n\terror = getsockname(client_fd, (struct sockaddr*)&myaddr, &addrlen);\n\tif (error) {\n\t\tlog_errno(LOG_WARNING, \"getsockname\");\n\t\tgoto fail;\n\t}\n\n\terror = getdestaddr(client_fd, &clientaddr, &myaddr, &destaddr);\n\tif (error) {\n\t\tgoto fail;\n\t}\n\n\terror = fcntl_nonblock(client_fd);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"fcntl\");\n\t\tgoto fail;\n\t}\n\n\tif (apply_tcp_keepalive(client_fd))\n\t\tgoto fail;\n\n\t// everything seems to be ok, let's allocate some memory\n\tclient = calloc(1, sizeof_client(self));\n\tif (!client) {\n\t\tlog_errno(LOG_ERR, \"calloc\");\n\t\tgoto fail;\n\t}\n\tclient->instance = self;\n\tif (client->instance->config.use_splice) {\n\t\tredsocks_pump *pump = red_pump(client);\n\t\tpump->request.read = -1;\n\t\tpump->request.write = -1;\n\t\tpump->reply.read = -1;\n\t\tpump->reply.write = -1;\n\t}\n\tmemcpy(&client->clientaddr, &clientaddr, sizeof(clientaddr));\n\tmemcpy(&client->destaddr, &destaddr, sizeof(destaddr));\n\tINIT_LIST_HEAD(&client->list);\n\tself->relay_ss->init(client);\n\n\tif (redsocks_gettimeofday(&client->first_event) != 0)\n\t\tgoto fail;\n\n\tredsocks_touch_client(client);\n\n\tclient->client = bufferevent_new(client_fd, NULL, NULL, redsocks_event_error, client);\n\tif (!client->client) {\n\t\tlog_errno(LOG_ERR, \"bufferevent_new\");\n\t\tgoto fail;\n\t}\n\tclient_fd = -1;\n\n\tredsocks_conn_list_add(self, client);\n\n\t// enable reading to handle EOF from client\n\tif (bufferevent_enable(client->client, EV_READ) != 0) {\n\t\tredsocks_log_errno(client, LOG_ERR, \"bufferevent_enable\");\n\t\tgoto fail;\n\t}\n\n\tredsocks_log_error(client, LOG_INFO, \"accepted\");\n\n\tif (self->relay_ss->connect_relay)\n\t\tself->relay_ss->connect_relay(client);\n\telse\n\t\tredsocks_connect_relay(client);\n\n\treturn;\n\nfail:\n\tif (client) {\n\t\tredsocks_drop_client(client);\n\t}\n\tif (client_fd != -1)\n\t\tredsocks_close(client_fd);\n}\n\nstatic const char *redsocks_evshut_str(unsigned short evshut)\n{\n\treturn\n\t\tevshut == EV_READ ? \"SHUT_RD\" :\n\t\tevshut == EV_WRITE ? \"SHUT_WR\" :\n\t\tevshut == (EV_READ|EV_WRITE) ? \"SHUT_RDWR\" :\n\t\tevshut == 0 ? \"\" :\n\t\t\"???\";\n}\n\nstatic const char *redsocks_event_str(unsigned short what)\n{\n\treturn\n\t\twhat == EV_READ ? \"R/-\" :\n\t\twhat == EV_WRITE ? \"-/W\" :\n\t\twhat == (EV_READ|EV_WRITE) ? \"R/W\" :\n\t\twhat == 0 ? \"-/-\" :\n\t\t\"???\";\n}\n\nstatic uint32_t redsocks_debug_dump_instance(redsocks_instance *instance, struct timeval *now)\n{\n\tredsocks_client *client = NULL;\n\tuint32_t conn = 0;\n\tchar bindaddr_str[RED_INET_ADDRSTRLEN];\n\n\tlog_error(LOG_NOTICE, \"Dumping client list for %s at %s:\", instance->config.type, red_inet_ntop(&instance->config.bindaddr, bindaddr_str, sizeof(bindaddr_str)));\n\tlist_for_each_entry(client, &instance->clients, list) {\n\t\tconn++;\n\t\tconst char *s_client_evshut = redsocks_evshut_str(client->client_evshut);\n\t\tconst char *s_relay_evshut = redsocks_evshut_str(client->relay_evshut);\n\t\tstruct timeval age, idle;\n\t\ttimersub(now, &client->first_event, &age);\n\t\ttimersub(now, &client->last_event, &idle);\n\n\t\tif (!instance->config.use_splice) {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"client: %i (%s)%s%s, relay: %i (%s)%s%s, age: %ld.%06ld sec, idle: %ld.%06ld sec.\",\n\t\t\t\tclient->client ? bufferevent_getfd(client->client) : -1,\n\t\t\t\tclient->client ? redsocks_event_str(client->client->enabled) : \"NULL\",\n\t\t\t\ts_client_evshut[0] ? \" \" : \"\",\n\t\t\t\ts_client_evshut,\n\t\t\t\tclient->relay ? bufferevent_getfd(client->relay) : -1,\n\t\t\t\tclient->relay ? redsocks_event_str(client->relay->enabled) : \"NULL\",\n\t\t\t\ts_relay_evshut[0] ? \" \" : \"\",\n\t\t\t\ts_relay_evshut,\n\t\t\t\tage.tv_sec, age.tv_usec,\n\t\t\t\tidle.tv_sec, idle.tv_usec);\n\t\t} else {\n\t\t\tredsocks_pump *pump = red_pump(client);\n\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"client: buf %i (%s) splice %i (%s/%s) pipe[%d, %d]=%zu%s%s, relay: buf %i (%s) splice %i (%s/%s) pipe[%d, %d]=%zu%s%s, age: %ld.%06ld sec, idle: %ld.%06ld sec.\",\n\t\t\t\tclient->client ? bufferevent_getfd(client->client) : -1,\n\t\t\t\tclient->client ? redsocks_event_str(client->client->enabled) : \"NULL\",\n\t\t\t\tevent_get_fd(&pump->client_read),\n\t\t\t\tevent_pending(&pump->client_read, EV_READ, NULL) ? \"R\" : \"-\",\n\t\t\t\tevent_pending(&pump->client_write, EV_WRITE, NULL) ? \"W\" : \"-\",\n\t\t\t\tpump->request.read,\n\t\t\t\tpump->request.write,\n\t\t\t\tpump->request.size,\n\t\t\t\ts_client_evshut[0] ? \" \" : \"\",\n\t\t\t\ts_client_evshut,\n\n\t\t\t\tclient->relay ? bufferevent_getfd(client->relay) : -1,\n\t\t\t\tclient->relay ? redsocks_event_str(client->relay->enabled) : \"NULL\",\n\t\t\t\tevent_get_fd(&pump->relay_read),\n\t\t\t\tevent_pending(&pump->relay_read, EV_READ, NULL) ? \"R\" : \"-\",\n\t\t\t\tevent_pending(&pump->relay_write, EV_WRITE, NULL) ? \"W\" : \"-\",\n\t\t\t\tpump->reply.read,\n\t\t\t\tpump->reply.write,\n\t\t\t\tpump->reply.size,\n\t\t\t\ts_relay_evshut[0] ? \" \" : \"\",\n\t\t\t\ts_relay_evshut,\n\n\t\t\t\tage.tv_sec, age.tv_usec,\n\t\t\t\tidle.tv_sec, idle.tv_usec);\n\t\t}\n\t}\n\tlog_error(LOG_NOTICE, \"End of client list. %d clients.\", conn);\n\treturn conn;\n}\n\nstatic void redsocks_debug_dump(int sig, short what, void *_arg)\n{\n\tredsocks_instance *instance = NULL;\n\tstruct timeval now;\n\tredsocks_gettimeofday(&now);\n\tuint32_t conn = 0;\n\n\tlist_for_each_entry(instance, &instances, list)\n\t\tconn += redsocks_debug_dump_instance(instance, &now);\n\tassert(conn == redsocks_conn);\n}\n\nbool redsocks_has_splice_instance()\n{\n\t// only i->config is initialised at the moment\n\tredsocks_instance *i = NULL;\n\tlist_for_each_entry(i, &instances, list) {\n\t\tif (i->config.use_splice)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void redsocks_fini_instance(redsocks_instance *instance);\n\nstatic int redsocks_init_instance(redsocks_instance *instance)\n{\n\t/* FIXME: redsocks_fini_instance is called in case of failure, this\n\t *        function will remove instance from instances list - result\n\t *        looks ugly.\n\t */\n\tint error;\n\tint fd = -1;\n\n\tfd = red_socket_server(SOCK_STREAM, &instance->config.bindaddr);\n\tif (fd == -1) {\n\t\tgoto fail;\n\t}\n\n\terror = listen(fd, instance->config.listenq);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"listen\");\n\t\tgoto fail;\n\t}\n\n\tevent_set(&instance->listener, fd, EV_READ | EV_PERSIST, redsocks_accept_client, instance);\n\tfd = -1;\n\n\terror = event_add(&instance->listener, NULL);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"event_add\");\n\t\tgoto fail;\n\t}\n\n\tif (instance->relay_ss->instance_init)\n\t\tinstance->relay_ss->instance_init(instance);\n\n\treturn 0;\n\nfail:\n\tredsocks_fini_instance(instance);\n\n\tif (fd != -1) {\n\t\tredsocks_close(fd);\n\t}\n\n\treturn -1;\n}\n\n/* Drops instance completely, freeing its memory and removing from\n * instances list.\n */\nstatic void redsocks_fini_instance(redsocks_instance *instance) {\n\tif (!list_empty(&instance->clients)) {\n\t\tredsocks_client *tmp, *client = NULL;\n\n\t\tlog_error(LOG_WARNING, \"There are connected clients during shutdown! Disconnecting them.\");\n\t\tlist_for_each_entry_safe(client, tmp, &instance->clients, list) {\n\t\t\tredsocks_drop_client(client);\n\t\t}\n\t}\n\n\tif (instance->relay_ss->instance_fini)\n\t\tinstance->relay_ss->instance_fini(instance);\n\n\tif (event_initialized(&instance->listener)) {\n\t\tif (event_del(&instance->listener) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"event_del\");\n\t\tredsocks_close(event_get_fd(&instance->listener));\n\t\tmemset(&instance->listener, 0, sizeof(instance->listener));\n\t}\n\n\tlist_del(&instance->list);\n\n\tfree(instance->config.type);\n\tfree(instance->config.login);\n\tfree(instance->config.password);\n\n\tmemset(instance, 0, sizeof(*instance));\n\tfree(instance);\n}\n\nstatic int redsocks_fini();\n\nstatic struct event debug_dumper;\n\nstatic int redsocks_init() {\n\tstruct sigaction sa = { }, sa_old = { };\n\tredsocks_instance *tmp, *instance = NULL;\n\n\tredsocks_conn = 0;\n\n\tsa.sa_handler = SIG_IGN;\n\tsa.sa_flags = SA_RESTART;\n\tif (sigaction(SIGPIPE, &sa, &sa_old) == -1) {\n\t\tlog_errno(LOG_ERR, \"sigaction\");\n\t\treturn -1;\n\t}\n\n\tsignal_set(&debug_dumper, SIGUSR1, redsocks_debug_dump, NULL);\n\tif (signal_add(&debug_dumper, NULL) != 0) {\n\t\tlog_errno(LOG_ERR, \"signal_add\");\n\t\tgoto fail;\n\t}\n\n\tevent_set(&accept_backoff_ev, -1, 0, redsocks_accept_backoff, NULL);\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list) {\n\t\tif (redsocks_init_instance(instance) != 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\t// that was the first resource allocation, it return's on failure, not goto-fail's\n\tsigaction(SIGPIPE, &sa_old, NULL);\n\n\tredsocks_fini();\n\n\treturn -1;\n}\n\nstatic int redsocks_fini()\n{\n\tredsocks_instance *tmp, *instance = NULL;\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list)\n\t\tredsocks_fini_instance(instance);\n\n\tassert(redsocks_conn == 0);\n\n\tif (signal_initialized(&debug_dumper)) {\n\t\tif (signal_del(&debug_dumper) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"signal_del\");\n\t\tmemset(&debug_dumper, 0, sizeof(debug_dumper));\n\t}\n\n\treturn 0;\n}\n\napp_subsys redsocks_subsys =\n{\n\t.init = redsocks_init,\n\t.fini = redsocks_fini,\n\t.conf_section = &redsocks_conf_section,\n};\n\n\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "redsocks.conf.example",
          "type": "blob",
          "size": 5.91015625,
          "content": "base {\n\t// debug: connection progress\n\tlog_debug = off;\n\n\t// info: start and end of client session\n\tlog_info = on;\n\n\t/* possible `log' values are:\n\t *   stderr\n\t *   \"file:/path/to/file\"\n\t *   syslog:FACILITY  facility is any of \"daemon\", \"local0\"...\"local7\"\n\t */\n\tlog = stderr;\n\t// log = \"file:/path/to/file\";\n\t// log = \"syslog:local7\";\n\n\t// detach from console\n\tdaemon = off;\n\n\t/* Change uid, gid and root directory, these options require root\n\t * privilegies on startup.\n\t * Note, your chroot may requre /etc/localtime if you write log to syslog.\n\t * Log is opened before chroot & uid changing.\n\t * Debian, Ubuntu and some other distributions use `nogroup` instead of\n\t * `nobody`, so change it according to your system if you want redsocks\n\t * to drop root privileges.\n\t */\n\t// user = nobody;\n\t// group = nobody;\n\t// chroot = \"/var/chroot\";\n\n\t/* possible `redirector' values are:\n\t *   iptables   - for Linux\n\t *   ipf        - for FreeBSD\n\t *   pf         - for OpenBSD\n\t *   generic    - some generic redirector that MAY work\n\t */\n\tredirector = iptables;\n\n\t/* Override per-socket values for TCP_KEEPIDLE, TCP_KEEPCNT,\n\t * and TCP_KEEPINTVL. see man 7 tcp for details.\n\t * `redsocks' relies on SO_KEEPALIVE option heavily. */\n\t//tcp_keepalive_time = 0;\n\t//tcp_keepalive_probes = 0;\n\t//tcp_keepalive_intvl = 0;\n\n\t// Every `redsocks` connection needs two file descriptors for sockets.\n\t// If `splice` is enabled, it also needs four file descriptors for\n\t// pipes.  `redudp` is not accounted at the moment.  When max number of\n\t// connection is reached, redsocks tries to close idle connections. If\n\t// there are no idle connections, it stops accept()'ing new\n\t// connections, although kernel continues to fill listenq.\n\n\t// Set maximum number of open file descriptors (also known as `ulimit -n`).\n\t//  0 -- do not modify startup limit (default)\n\t// rlimit_nofile = 0;\n\n\t// Set maximum number of served connections. Default is to deduce safe\n\t// limit from `splice` setting and RLIMIT_NOFILE.\n\t// redsocks_conn_max = 0;\n\n\t// Close connections idle for N seconds when/if connection count\n\t// limit is hit.\n\t//  0 -- do not close idle connections\n\t//  7440 -- 2 hours 4 minutes, see RFC 5382 (default)\n\t// connpres_idle_timeout = 7440;\n\n\t// `max_accept_backoff` is a delay in milliseconds to retry `accept()`\n\t// after failure (e.g. due to lack of file descriptors). It's just a\n\t// safety net for misconfigured `redsocks_conn_max`, you should tune\n\t// redsocks_conn_max if accept backoff happens.\n\t// max_accept_backoff = 60000;\n}\n\nredsocks {\n\t/* `local_ip' defaults to 127.0.0.1 for security reasons,\n\t * use 0.0.0.0 if you want to listen on every interface.\n\t * `local_*' are used as port to redirect to.\n\t */\n\tlocal_ip = 127.0.0.1;\n\tlocal_port = 12345;\n\n\t// listen() queue length. Default value is SOMAXCONN and it should be\n\t// good enough for most of us.\n\t// listenq = 128; // SOMAXCONN equals 128 on my Linux box.\n\n\t// Enable or disable faster data pump based on splice(2) syscall.\n\t// Default value depends on your kernel version, true for 2.6.27.13+\n\t// splice = false;\n\n\t// `ip' and `port' are IP and tcp-port of proxy-server\n\t// You can also use hostname instead of IP, only one (random)\n\t// address of multihomed host will be used.\n\tip = example.org;\n\tport = 1080;\n\n\t// known types: socks4, socks5, http-connect, http-relay\n\ttype = socks5;\n\n\t// login = \"foobar\";\n\t// password = \"baz\";\n\n\t// known ways to disclose client IP to the proxy:\n\t//  false -- disclose nothing\n\t// http-connect supports:\n\t//  X-Forwarded-For  -- X-Forwarded-For: IP\n\t//  Forwarded_ip     -- Forwarded: for=IP # see RFC7239\n\t//  Forwarded_ipport -- Forwarded: for=\"IP:port\" # see RFC7239\n\t// disclose_src = false;\n\n\t// various ways to handle proxy failure\n\t//  close -- just close connection (default)\n\t//  forward_http_err -- forward HTTP error page from proxy as-is\n\t// on_proxy_fail = close;\n}\n\nredudp {\n\t// `local_ip' should not be 0.0.0.0 as it's also used for outgoing\n\t// packets that are sent as replies - and it should be fixed\n\t// if we want NAT to work properly.\n\tlocal_ip = 127.0.0.1;\n\tlocal_port = 10053;\n\n\t// `ip' and `port' of socks5 proxy server.\n\tip = 10.0.0.1;\n\tport = 1080;\n\tlogin = username;\n\tpassword = pazzw0rd;\n\n\t// redsocks knows about two options while redirecting UDP packets at\n\t// linux: TPROXY and REDIRECT.  TPROXY requires more complex routing\n\t// configuration and fresh kernel (>= 2.6.37 according to squid\n\t// developers[1]) but has hack-free way to get original destination\n\t// address, REDIRECT is easier to configure, but requires `dest_ip` and\n\t// `dest_port` to be set, limiting packet redirection to single\n\t// destination.\n\t// [1] http://wiki.squid-cache.org/Features/Tproxy4\n\tdest_ip = 8.8.8.8;\n\tdest_port = 53;\n\n\tudp_timeout = 30;\n\tudp_timeout_stream = 180;\n}\n\ndnstc {\n\t// fake and really dumb DNS server that returns \"truncated answer\" to\n\t// every query via UDP, RFC-compliant resolver should repeat same query\n\t// via TCP in this case.\n\tlocal_ip = 127.0.0.1;\n\tlocal_port = 5300;\n}\n\ndnsu2t {\n\t// fake and a bit less dumb DNS server that converts several UDP\n\t// queries into single pipelined TCP stream of DNS queries.\n\tlocal_ip = 127.0.0.1;\n\tlocal_port = 5313;\n\n\t// See https://en.wikipedia.org/wiki/Public_recursive_name_server\n\t// NB: TCP connection to this ${ip}:${port} is not passed through\n\t// proxy, configure your firewall rules if you want that.\n\tremote_ip = 8.8.8.8;\n\tremote_port = 53;\n\n\t// Maximum amount of concurrent in-flight DNS queries sent to remote server.\n\t// Some public DNS servers seem to limit it and terminate connections\n\t// with high count of in-flight requests, so it's trade-off between\n\t// request latency and availability. In-flight requests are not cached,\n\t// so they're lost in case of DNS/TCP connection termination.\n\t// inflight_max = 16;\n\n\t// I/O timeout of remote endpoint. Default value is quite conservative and\n\t// corresponds to the highest timeout among public servers from Wikipedia.\n\t// remote_timeout = 30;\n}\n\n// you can add more `redsocks' and `redudp' sections if you need.\n"
        },
        {
          "name": "redsocks.h",
          "type": "blob",
          "size": 6.060546875,
          "content": "#ifndef REDSOCKS_H_WED_JAN_24_22_17_11_2007\n#define REDSOCKS_H_WED_JAN_24_22_17_11_2007\n#include <sys/time.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <assert.h>\n#include <event.h>\n#include \"list.h\"\n#include \"parser.h\"\n\n\nstruct redsocks_client_t;\nstruct redsocks_instance_t;\n\ntypedef struct relay_subsys_t {\n\tchar   *name;\n\tsize_t  payload_len; // size of relay-specific data in client section\n\tsize_t  instance_payload_len; // size of relay-specify data in instance section\n\tevbuffercb readcb;\n\tevbuffercb writecb;\n\tvoid       (*init)(struct redsocks_client_t *client);\n\tvoid       (*fini)(struct redsocks_client_t *client);\n\tvoid       (*instance_init)(struct redsocks_instance_t *instance);\n\tvoid       (*instance_fini)(struct redsocks_instance_t *instance);\n\t// connect_relay (if any) is called instead of redsocks_connect_relay after client connection acceptance\n\tvoid       (*connect_relay)(struct redsocks_client_t *client);\n} relay_subsys;\n\ntypedef struct redsocks_config_t {\n\tstruct sockaddr_in bindaddr;\n\tstruct sockaddr_in relayaddr;\n\tchar *type;\n\tchar *login;\n\tchar *password;\n\tuint16_t listenq;\n\tbool use_splice;\n\tenum disclose_src_e disclose_src;\n\tenum on_proxy_fail_e on_proxy_fail;\n} redsocks_config;\n\ntypedef struct redsocks_instance_t {\n\tlist_head       list;\n\tredsocks_config config;\n\tstruct event    listener;\n\tlist_head       clients;\n\trelay_subsys   *relay_ss;\n} redsocks_instance;\n\ntypedef unsigned short evshut_t; // EV_READ | EV_WRITE\n\ntypedef struct redsocks_client_t {\n\tlist_head           list;\n\tredsocks_instance  *instance;\n\tstruct bufferevent *client;\n\tstruct bufferevent *relay;\n\tstruct sockaddr_in  clientaddr;\n\tstruct sockaddr_in  destaddr;\n\tint                 state;         // it's used by bottom layer\n\tevshut_t            client_evshut;\n\tevshut_t            relay_evshut;\n\tstruct timeval      first_event;\n\tstruct timeval      last_event;\n} redsocks_client;\n\ntypedef struct splice_pipe_t {\n\tint read;\n\tint write;\n\tsize_t size;\n} splice_pipe;\n\ntypedef struct redsocks_pump_t {\n\t/* Quick-n-dirty test show, that some Linux 4.4.0 build uses ~1.5 kb of\n\t * slab_unreclaimable RAM per every pipe pair. Most of connections are\n\t * usually idle and it's possble to save some measurable amount of RAM\n\t * using shared pipe pool. */\n\tredsocks_client c;\n\tsplice_pipe request;\n\tsplice_pipe reply;\n\tstruct event client_read;\n\tstruct event client_write;\n\tstruct event relay_read;\n\tstruct event relay_write;\n} redsocks_pump;\n\nstatic inline size_t sizeof_client(redsocks_instance *i)\n{\n\treturn ((i->config.use_splice) ? sizeof(redsocks_pump) : sizeof(redsocks_client)) + i->relay_ss->payload_len;\n}\n\nstatic inline void* red_payload(redsocks_client *c)\n{\n\treturn (c->instance->config.use_splice) ? (void*)(((redsocks_pump*)c) + 1) : (void*)(c + 1);\n}\n\nstatic inline redsocks_pump* red_pump(redsocks_client *c)\n{\n\tassert(c->instance->config.use_splice);\n\treturn (redsocks_pump*)c;\n}\n\nvoid redsocks_shutdown(redsocks_client *client, struct bufferevent *buffev, int how);\nvoid redsocks_drop_client(redsocks_client *client);\nvoid redsocks_touch_client(redsocks_client *client);\nvoid redsocks_connect_relay(redsocks_client *client);\nvoid redsocks_start_relay(redsocks_client *client);\nbool redsocks_has_splice_instance();\n\ntypedef int (*size_comparator)(size_t a, size_t b);\nint sizes_equal(size_t a, size_t b);\nint sizes_greater_equal(size_t a, size_t b);\n/** helper for functions when we expect ONLY reply of some size and anything else is error\n */\nint redsocks_read_expected(redsocks_client *client, struct evbuffer *input, void *data, size_comparator comparator, size_t expected);\n\ntypedef struct evbuffer* (*redsocks_message_maker)(redsocks_client *client);\ntypedef struct evbuffer* (*redsocks_message_maker_plain)(void *p);\nstruct evbuffer *mkevbuffer(void *data, size_t len);\n/* Yahoo! This code is ex-plain! :-D */\nint redsocks_write_helper_ex_plain(\n\tstruct bufferevent *buffev, redsocks_client *client,\n\tredsocks_message_maker_plain mkmessage, void *p, int state, size_t wm_low, size_t wm_high);\nint redsocks_write_helper_ex(\n\tstruct bufferevent *buffev, redsocks_client *client,\n\tredsocks_message_maker mkmessage, int state, size_t wm_low, size_t wm_high);\nint redsocks_write_helper(\n\tstruct bufferevent *buffev, redsocks_client *client,\n\tredsocks_message_maker mkmessage, int state, size_t wm_only);\n\n\n#define redsocks_close(fd) redsocks_close_internal((fd), __FILE__, __LINE__, __func__)\nvoid redsocks_close_internal(int fd, const char* file, int line, const char *func);\n\n#define redsocks_event_add(client, ev) redsocks_event_add_internal((client), (ev), __FILE__, __LINE__, __func__)\nvoid redsocks_event_add_internal(redsocks_client *client, struct event *ev, const char *file, int line, const char *func);\n\n#define redsocks_event_del(client, ev) redsocks_event_del_internal((client), (ev), __FILE__, __LINE__, __func__)\nvoid redsocks_event_del_internal(redsocks_client *client, struct event *ev, const char *file, int line, const char *func);\n\n#define redsocks_bufferevent_dropfd(client, ev) redsocks_bufferevent_dropfd_internal((client), (ev), __FILE__, __LINE__, __func__)\nvoid redsocks_bufferevent_dropfd_internal(redsocks_client *client, struct bufferevent *ev, const char *file, int line, const char *func);\n\n// I have to account descriptiors for accept-backoff, that's why BEV_OPT_CLOSE_ON_FREE is not used.\nvoid redsocks_bufferevent_free(struct bufferevent *buffev);\n\n#define redsocks_log_error(client, prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 0, &(client)->clientaddr, &(client)->destaddr, prio, ## msg)\n#define redsocks_log_errno(client, prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 1, &(client)->clientaddr, &(client)->destaddr, prio, ## msg)\nvoid redsocks_log_write_plain(\n\t\tconst char *file, int line, const char *func, int do_errno,\n\t\tconst struct sockaddr_in *clientaddr, const struct sockaddr_in *destaddr,\n\t\tint priority, const char *fmt, ...)\n#if defined(__GNUC__)\n\t__attribute__ (( format (printf, 8, 9) ))\n#endif\n;\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* REDSOCKS_H_WED_JAN_24_22_17_11_2007 */\n\n"
        },
        {
          "name": "redsocks.service",
          "type": "blob",
          "size": 0.427734375,
          "content": "[Unit]\nDescription=Transparent redirector of any TCP connection to proxy using your firewall\n\n[Service]\nType=forking\nPIDFile=/run/redsocks/redsocks.pid\nEnvironmentFile=/etc/conf.d/redsocks\nUser=redsocks\nExecStartPre=/usr/bin/redsocks -t -c $REDSOCKS_CONF\nExecStart=/usr/bin/redsocks -c $REDSOCKS_CONF \\\n  -p /run/redsocks/redsocks.pid\nExecStopPost=/bin/rm /run/redsocks/redsocks.pid\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "redudp.c",
          "type": "blob",
          "size": 25.04296875,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdlib.h>\n#include <search.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <assert.h>\n\n#include \"list.h\"\n#include \"log.h\"\n#include \"socks5.h\"\n#include \"parser.h\"\n#include \"main.h\"\n#include \"redsocks.h\"\n#include \"redudp.h\"\n#include \"libc-compat.h\"\n\n#define redudp_log_error(client, prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 0, &(client)->clientaddr, get_destaddr(client), prio, ## msg)\n#define redudp_log_errno(client, prio, msg...) \\\n\tredsocks_log_write_plain(__FILE__, __LINE__, __func__, 1, &(client)->clientaddr, get_destaddr(client), prio, ## msg)\n\nstatic void redudp_pkt_from_socks(int fd, short what, void *_arg);\nstatic void redudp_drop_client(redudp_client *client);\nstatic void redudp_fini_instance(redudp_instance *instance);\nstatic int redudp_fini();\nstatic int redudp_transparent(int fd);\n\ntypedef struct redudp_expected_assoc_reply_t {\n\tsocks5_reply h;\n\tsocks5_addr_ipv4 ip;\n} PACKED redudp_expected_assoc_reply;\n\nstruct bound_udp4_key {\n\tstruct in_addr sin_addr;\n\tuint16_t       sin_port;\n};\n\nstruct bound_udp4 {\n\tstruct bound_udp4_key key;\n\tint ref;\n\tint fd;\n};\n\n/***********************************************************************\n * Helpers\n */\n// TODO: separate binding to privileged process (this operation requires uid-0)\nstatic void* root_bound_udp4 = NULL; // to avoid two binds to same IP:port\n\nstatic int bound_udp4_cmp(const void *a, const void *b)\n{\n\treturn memcmp(a, b, sizeof(struct bound_udp4_key));\n}\n\nstatic void bound_udp4_mkkey(struct bound_udp4_key *key, const struct sockaddr_in *addr)\n{\n\tmemset(key, 0, sizeof(*key));\n\tkey->sin_addr = addr->sin_addr;\n\tkey->sin_port = addr->sin_port;\n}\n\nstatic int bound_udp4_get(const struct sockaddr_in *addr)\n{\n\tstruct bound_udp4_key key;\n\tstruct bound_udp4 *node, **pnode;\n\n\tbound_udp4_mkkey(&key, addr);\n\t// I assume, that memory allocation for lookup is awful, so I use\n\t// tfind/tsearch pair instead of tsearch/check-result.\n\tpnode = tfind(&key, &root_bound_udp4, bound_udp4_cmp);\n\tif (pnode) {\n\t\tassert((*pnode)->ref > 0);\n\t\t(*pnode)->ref++;\n\t\treturn (*pnode)->fd;\n\t}\n\n\tnode = calloc(1, sizeof(*node));\n\tif (!node) {\n\t\tlog_errno(LOG_ERR, \"calloc\");\n\t\tgoto fail;\n\t}\n\n\tnode->key = key;\n\tnode->ref = 1;\n\tnode->fd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (node->fd == -1) {\n\t\tlog_errno(LOG_ERR, \"socket\");\n\t\tgoto fail;\n\t}\n\n\tif (0 != redudp_transparent(node->fd))\n\t\tgoto fail;\n\n\tif (0 != bind(node->fd, (struct sockaddr*)addr, sizeof(*addr))) {\n\t\tlog_errno(LOG_ERR, \"bind\");\n\t\tgoto fail;\n\t}\n\n\tpnode = tsearch(node, &root_bound_udp4, bound_udp4_cmp);\n\tif (!pnode) {\n\t\tlog_errno(LOG_ERR, \"tsearch(%p) == %p\", node, pnode);\n\t\tgoto fail;\n\t}\n\tassert(node == *pnode);\n\n\treturn node->fd;\n\nfail:\n\tif (node) {\n\t\tif (node->fd != -1)\n\t\t\tredsocks_close(node->fd);\n\t\tfree(node);\n\t}\n\treturn -1;\n}\n\nstatic void bound_udp4_put(const struct sockaddr_in *addr)\n{\n\tstruct bound_udp4_key key;\n\tstruct bound_udp4 **pnode, *node;\n\tvoid *parent;\n\n\tbound_udp4_mkkey(&key, addr);\n\tpnode = tfind(&key, &root_bound_udp4, bound_udp4_cmp);\n\tassert(pnode && (*pnode)->ref > 0);\n\n\tnode = *pnode;\n\n\tnode->ref--;\n\tif (node->ref)\n\t\treturn;\n\n\tparent = tdelete(node, &root_bound_udp4, bound_udp4_cmp);\n\tassert(parent);\n\n\tredsocks_close(node->fd); // expanding `pnode` to avoid use after free\n\tfree(node);\n}\n\nstatic int redudp_transparent(int fd)\n{\n\tint on = 1;\n\tint error = setsockopt(fd, SOL_IP, IP_TRANSPARENT, &on, sizeof(on));\n\tif (error)\n\t\tlog_errno(LOG_ERR, \"setsockopt(..., SOL_IP, IP_TRANSPARENT)\");\n\treturn error;\n}\n\nstatic int do_tproxy(redudp_instance* instance)\n{\n\treturn instance->config.destaddr.sin_addr.s_addr == 0;\n}\n\nstatic struct sockaddr_in* get_destaddr(redudp_client *client)\n{\n\tif (do_tproxy(client->instance))\n\t\treturn &client->destaddr;\n\telse\n\t\treturn &client->instance->config.destaddr;\n}\n\nstatic void redudp_fill_preamble(socks5_udp_preabmle *preamble, redudp_client *client)\n{\n\tpreamble->reserved = 0;\n\tpreamble->frag_no = 0; /* fragmentation is not supported */\n\tpreamble->addrtype = socks5_addrtype_ipv4;\n\tpreamble->ip.addr = get_destaddr(client)->sin_addr.s_addr;\n\tpreamble->ip.port = get_destaddr(client)->sin_port;\n}\n\nstatic struct evbuffer* socks5_mkmethods_plain_wrapper(void *p)\n{\n\tint *do_password = p;\n\treturn socks5_mkmethods_plain(*do_password);\n}\n\nstatic struct evbuffer* socks5_mkpassword_plain_wrapper(void *p)\n{\n\tredudp_instance *self = p;\n\treturn socks5_mkpassword_plain(self->config.login, self->config.password);\n}\n\nstatic struct evbuffer* socks5_mkassociate(void *p)\n{\n\tstruct sockaddr_in sa;\n\tp = p; /* Make compiler happy */\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\treturn socks5_mkcommand_plain(socks5_cmd_udp_associate, &sa);\n}\n\n/***********************************************************************\n * Logic\n */\nstatic void redudp_drop_client(redudp_client *client)\n{\n\tredudp_log_error(client, LOG_INFO, \"Dropping...\");\n\tenqueued_packet *q, *tmp;\n\tif (event_initialized(&client->timeout)) {\n\t\tif (event_del(&client->timeout) == -1)\n\t\t\tredudp_log_errno(client, LOG_ERR, \"event_del\");\n\t}\n\tif (client->relay)\n\t\tredsocks_bufferevent_free(client->relay);\n\tif (event_initialized(&client->udprelay)) {\n\t\tint fd = event_get_fd(&client->udprelay);\n\t\tif (event_del(&client->udprelay) == -1)\n\t\t\tredudp_log_errno(client, LOG_ERR, \"event_del\");\n\t\tredsocks_close(fd);\n\t}\n\tif (client->sender_fd != -1)\n\t\tbound_udp4_put(&client->destaddr);\n\tlist_for_each_entry_safe(q, tmp, &client->queue, list) {\n\t\tlist_del(&q->list);\n\t\tfree(q);\n\t}\n\tlist_del(&client->list);\n\tfree(client);\n}\n\nstatic void redudp_bump_timeout(redudp_client *client)\n{\n\tstruct timeval tv;\n\ttv.tv_sec = client->instance->config.udp_timeout;\n\ttv.tv_usec = 0;\n\t// TODO: implement udp_timeout_stream\n\tif (event_add(&client->timeout, &tv) != 0) {\n\t\tredudp_log_error(client, LOG_WARNING, \"event_add(&client->timeout, ...)\");\n\t\tredudp_drop_client(client);\n\t}\n}\n\nstatic void redudp_forward_pkt(redudp_client *client, char *buf, size_t pktlen)\n{\n\tsocks5_udp_preabmle req;\n\tstruct msghdr msg;\n\tstruct iovec io[2];\n\tssize_t outgoing, fwdlen = pktlen + sizeof(req);\n\n\tredudp_fill_preamble(&req, client);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_name = &client->udprelayaddr;\n\tmsg.msg_namelen = sizeof(client->udprelayaddr);\n\tmsg.msg_iov = io;\n\tmsg.msg_iovlen = SIZEOF_ARRAY(io);\n\n\tio[0].iov_base = &req;\n\tio[0].iov_len = sizeof(req);\n\tio[1].iov_base = buf;\n\tio[1].iov_len = pktlen;\n\n\toutgoing = sendmsg(event_get_fd(&client->udprelay), &msg, 0);\n\tif (outgoing == -1) {\n\t\tredudp_log_errno(client, LOG_WARNING, \"sendmsg: Can't forward packet, dropping it\");\n\t\treturn;\n\t}\n\telse if (outgoing != fwdlen) {\n\t\tredudp_log_error(client, LOG_WARNING, \"sendmsg: I was sending %zd bytes, but only %zd were sent.\", fwdlen, outgoing);\n\t\treturn;\n\t}\n}\n\nstatic int redudp_enqeue_pkt(redudp_client *client, char *buf, size_t pktlen)\n{\n\tenqueued_packet *q = NULL;\n\n\tredudp_log_error(client, LOG_DEBUG, \"<trace>\");\n\n\tif (client->queue_len >= client->instance->config.max_pktqueue) {\n\t\tredudp_log_error(client, LOG_WARNING, \"There are already %u packets in queue. Dropping.\",\n\t\t                 client->queue_len);\n\t\treturn -1;\n\t}\n\n\tq = calloc(1, sizeof(enqueued_packet) + pktlen);\n\tif (!q) {\n\t\tredudp_log_errno(client, LOG_ERR, \"Can't enqueue packet: calloc\");\n\t\treturn -1;\n\t}\n\n\tq->len = pktlen;\n\tmemcpy(q->data, buf, pktlen);\n\tclient->queue_len += 1;\n\tlist_add_tail(&q->list, &client->queue);\n\treturn 0;\n}\n\nstatic void redudp_flush_queue(redudp_client *client)\n{\n\tenqueued_packet *q, *tmp;\n\tredudp_log_error(client, LOG_INFO, \"Starting UDP relay\");\n\tlist_for_each_entry_safe(q, tmp, &client->queue, list) {\n\t\tredudp_forward_pkt(client, q->data, q->len);\n\t\tlist_del(&q->list);\n\t\tfree(q);\n\t}\n\tclient->queue_len = 0;\n\tassert(list_empty(&client->queue));\n}\n\nstatic void redudp_read_assoc_reply(struct bufferevent *buffev, void *_arg)\n{\n\tredudp_client *client = _arg;\n\tredudp_expected_assoc_reply reply;\n\tint read = evbuffer_remove(buffev->input, &reply, sizeof(reply));\n\tint fd = -1;\n\tint error;\n\tredudp_log_error(client, LOG_DEBUG, \"<trace>\");\n\n\tif (read != sizeof(reply)) {\n\t\tredudp_log_errno(client, LOG_NOTICE, \"evbuffer_remove returned only %i bytes instead of expected %zu\",\n\t\t                 read, sizeof(reply));\n\t\tgoto fail;\n\t}\n\n\tif (reply.h.ver != socks5_ver) {\n\t\tredudp_log_error(client, LOG_NOTICE, \"Socks5 server reported unexpected reply version: %u\", reply.h.ver);\n\t\tgoto fail;\n\t}\n\n\tif (reply.h.status != socks5_status_succeeded) {\n\t\tredudp_log_error(client, LOG_NOTICE, \"Socks5 server status: \\\"%s\\\" (%i)\",\n\t\t\t\tsocks5_status_to_str(reply.h.status), reply.h.status);\n\t\tgoto fail;\n\t}\n\n\tif (reply.h.addrtype != socks5_addrtype_ipv4) {\n\t\tredudp_log_error(client, LOG_NOTICE, \"Socks5 server reported unexpected address type for UDP dgram destination: %u\",\n\t\t                 reply.h.addrtype);\n\t\tgoto fail;\n\t}\n\n\tclient->udprelayaddr.sin_family = AF_INET;\n\tclient->udprelayaddr.sin_port = reply.ip.port;\n\tclient->udprelayaddr.sin_addr.s_addr = reply.ip.addr;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd == -1) {\n\t\tredudp_log_errno(client, LOG_ERR, \"socket\");\n\t\tgoto fail;\n\t}\n\n\terror = connect(fd, (struct sockaddr*)&client->udprelayaddr, sizeof(client->udprelayaddr));\n\tif (error) {\n\t\tredudp_log_errno(client, LOG_NOTICE, \"connect\");\n\t\tgoto fail;\n\t}\n\n\tevent_set(&client->udprelay, fd, EV_READ | EV_PERSIST, redudp_pkt_from_socks, client);\n\terror = event_add(&client->udprelay, NULL);\n\tif (error) {\n\t\tredudp_log_errno(client, LOG_ERR, \"event_add\");\n\t\tgoto fail;\n\t}\n\n\tredudp_flush_queue(client);\n\t// TODO: bufferevent_disable ?\n\n\treturn;\n\nfail:\n\tif (fd != -1)\n\t\tredsocks_close(fd);\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_read_auth_reply(struct bufferevent *buffev, void *_arg)\n{\n\tredudp_client *client = _arg;\n\tsocks5_auth_reply reply;\n\tint read = evbuffer_remove(buffev->input, &reply, sizeof(reply));\n\tint error;\n\tredudp_log_error(client, LOG_DEBUG, \"<trace>\");\n\n\tif (read != sizeof(reply)) {\n\t\tredudp_log_errno(client, LOG_NOTICE, \"evbuffer_remove returned only %i bytes instead of expected %zu\",\n\t\t                 read, sizeof(reply));\n\t\tgoto fail;\n\t}\n\n\tif (reply.ver != socks5_password_ver || reply.status != socks5_password_passed) {\n\t\tredudp_log_error(client, LOG_NOTICE, \"Socks5 authentication error. Version: %u, error code: %u\",\n\t\t                 reply.ver, reply.status);\n\t\tgoto fail;\n\t}\n\n\terror = redsocks_write_helper_ex_plain(\n\t\t\tclient->relay, NULL, socks5_mkassociate, NULL, 0, /* last two are ignored */\n\t\t\tsizeof(redudp_expected_assoc_reply), sizeof(redudp_expected_assoc_reply));\n\tif (error)\n\t\tgoto fail;\n\n\tclient->relay->readcb = redudp_read_assoc_reply;\n\n\treturn;\n\nfail:\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_read_auth_methods(struct bufferevent *buffev, void *_arg)\n{\n\tredudp_client *client = _arg;\n\tint do_password = socks5_is_valid_cred(client->instance->config.login, client->instance->config.password);\n\tsocks5_method_reply reply;\n\tint read = evbuffer_remove(buffev->input, &reply, sizeof(reply));\n\tconst char *error = NULL;\n\tint ierror = 0;\n\tredudp_log_error(client, LOG_DEBUG, \"<trace>\");\n\n\tif (read != sizeof(reply)) {\n\t\tredudp_log_errno(client, LOG_NOTICE, \"evbuffer_remove returned only %i bytes instead of expected %zu\",\n\t\t                 read, sizeof(reply));\n\t\tgoto fail;\n\t}\n\n\terror = socks5_is_known_auth_method(&reply, do_password);\n\tif (error) {\n\t\tredudp_log_error(client, LOG_NOTICE, \"socks5_is_known_auth_method: %s\", error);\n\t\tgoto fail;\n\t}\n\telse if (reply.method == socks5_auth_none) {\n\t\tierror = redsocks_write_helper_ex_plain(\n\t\t\t\tclient->relay, NULL, socks5_mkassociate, NULL, 0, /* last two are ignored */\n\t\t\t\tsizeof(redudp_expected_assoc_reply), sizeof(redudp_expected_assoc_reply));\n\t\tif (ierror)\n\t\t\tgoto fail;\n\n\t\tclient->relay->readcb = redudp_read_assoc_reply;\n\t}\n\telse if (reply.method == socks5_auth_password) {\n\t\tierror = redsocks_write_helper_ex_plain(\n\t\t\t\tclient->relay, NULL, socks5_mkpassword_plain_wrapper, client->instance, 0, /* last one is ignored */\n\t\t\t\tsizeof(socks5_auth_reply), sizeof(socks5_auth_reply));\n\t\tif (ierror)\n\t\t\tgoto fail;\n\n\t\tclient->relay->readcb = redudp_read_auth_reply;\n\t}\n\n\treturn;\n\nfail:\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_relay_connected(struct bufferevent *buffev, void *_arg)\n{\n\tredudp_client *client = _arg;\n\tint do_password = socks5_is_valid_cred(client->instance->config.login, client->instance->config.password);\n\tint error;\n\tchar relayaddr_str[RED_INET_ADDRSTRLEN];\n\tredudp_log_error(client, LOG_DEBUG, \"via %s\", red_inet_ntop(&client->instance->config.relayaddr, relayaddr_str, sizeof(relayaddr_str)));\n\n\tif (!red_is_socket_connected_ok(buffev)) {\n\t\tredudp_log_errno(client, LOG_NOTICE, \"red_is_socket_connected_ok\");\n\t\tgoto fail;\n\t}\n\n\terror = redsocks_write_helper_ex_plain(\n\t\t\tclient->relay, NULL, socks5_mkmethods_plain_wrapper, &do_password, 0 /* does not matter */,\n\t\t\tsizeof(socks5_method_reply), sizeof(socks5_method_reply));\n\tif (error)\n\t\tgoto fail;\n\n\tclient->relay->readcb = redudp_read_auth_methods;\n\tclient->relay->writecb = 0;\n\t//bufferevent_disable(buffev, EV_WRITE); // I don't want to check for writeability.\n\treturn;\n\nfail:\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_relay_error(struct bufferevent *buffev, short what, void *_arg)\n{\n\tredudp_client *client = _arg;\n\t// TODO: FIXME: Implement me\n\tredudp_log_error(client, LOG_NOTICE, \"redudp_relay_error\");\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_timeout(int fd, short what, void *_arg)\n{\n\tredudp_client *client = _arg;\n\tredudp_log_error(client, LOG_INFO, \"Client timeout. First: %li, last_client: %li, last_relay: %li.\",\n\t                 client->first_event, client->last_client_event, client->last_relay_event);\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_first_pkt_from_client(redudp_instance *self, struct sockaddr_in *clientaddr, struct sockaddr_in *destaddr, char *buf, size_t pktlen)\n{\n\tredudp_client *client = calloc(1, sizeof(*client));\n\n\tif (!client) {\n\t\tlog_errno(LOG_WARNING, \"calloc\");\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&client->list);\n\tINIT_LIST_HEAD(&client->queue);\n\tclient->instance = self;\n\tmemcpy(&client->clientaddr, clientaddr, sizeof(*clientaddr));\n\tif (destaddr)\n\t\tmemcpy(&client->destaddr, destaddr, sizeof(client->destaddr));\n\tevtimer_set(&client->timeout, redudp_timeout, client);\n\t// XXX: self->relay_ss->init(client);\n\n\tclient->sender_fd = -1; // it's postponed until socks-server replies to avoid trivial DoS\n\n\tclient->relay = red_connect_relay(&client->instance->config.relayaddr,\n\t                                  redudp_relay_connected, redudp_relay_error, client);\n\tif (!client->relay)\n\t\tgoto fail;\n\n\tif (redsocks_time(&client->first_event) == (time_t)-1)\n\t\tgoto fail;\n\tclient->last_client_event = client->first_event;\n\tredudp_bump_timeout(client);\n\n\tif (redudp_enqeue_pkt(client, buf, pktlen) == -1)\n\t\tgoto fail;\n\n\tlist_add(&client->list, &self->clients);\n\tredudp_log_error(client, LOG_INFO, \"got 1st packet from client\");\n\treturn;\n\nfail:\n\tredudp_drop_client(client);\n}\n\nstatic void redudp_pkt_from_socks(int fd, short what, void *_arg)\n{\n\tredudp_client *client = _arg;\n\tunion {\n\t\tchar buf[0xFFFF];\n\t\tsocks5_udp_preabmle header;\n\t} pkt;\n\tssize_t pktlen, fwdlen, outgoing;\n\tstruct sockaddr_in udprelayaddr;\n\n\tassert(fd == event_get_fd(&client->udprelay));\n\n\tpktlen = red_recv_udp_pkt(fd, pkt.buf, sizeof(pkt.buf), &udprelayaddr, NULL);\n\tif (pktlen == -1)\n\t\treturn;\n\n\tif (memcmp(&udprelayaddr, &client->udprelayaddr, sizeof(udprelayaddr)) != 0) {\n\t\tchar buf[RED_INET_ADDRSTRLEN];\n\t\tredudp_log_error(client, LOG_NOTICE, \"Got packet from unexpected address %s.\",\n\t\t                 red_inet_ntop(&udprelayaddr, buf, sizeof(buf)));\n\t\treturn;\n\t}\n\n\tif (pkt.header.frag_no != 0) {\n\t\t// FIXME: does anybody need it?\n\t\tredudp_log_error(client, LOG_WARNING, \"Got fragment #%u. Packet fragmentation is not supported!\",\n\t\t                 pkt.header.frag_no);\n\t\treturn;\n\t}\n\n\tif (pkt.header.addrtype != socks5_addrtype_ipv4) {\n\t\tredudp_log_error(client, LOG_NOTICE, \"Got address type #%u instead of expected #%u (IPv4).\",\n\t\t                 pkt.header.addrtype, socks5_addrtype_ipv4);\n\t\treturn;\n\t}\n\n\tif (pkt.header.ip.port != get_destaddr(client)->sin_port ||\n\t    pkt.header.ip.addr != get_destaddr(client)->sin_addr.s_addr)\n\t{\n\t\tchar buf[RED_INET_ADDRSTRLEN];\n\t\tstruct sockaddr_in pktaddr = {\n\t\t\t.sin_family = AF_INET,\n\t\t\t.sin_addr   = { pkt.header.ip.addr },\n\t\t\t.sin_port   = pkt.header.ip.port,\n\t\t};\n\t\tredudp_log_error(client, LOG_NOTICE, \"Socks5 server relayed packet from unexpected address %s.\",\n\t\t                 red_inet_ntop(&pktaddr, buf, sizeof(buf)));\n\t\treturn;\n\t}\n\n\tredsocks_time(&client->last_relay_event);\n\tredudp_bump_timeout(client);\n\n\tif (do_tproxy(client->instance) && client->sender_fd == -1) {\n\t\tclient->sender_fd = bound_udp4_get(&client->destaddr);\n\t\tif (client->sender_fd == -1) {\n\t\t\tredudp_log_error(client, LOG_WARNING, \"bound_udp4_get failure\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfwdlen = pktlen - sizeof(pkt.header);\n\toutgoing = sendto(do_tproxy(client->instance)\n\t                      ? client->sender_fd\n\t                      : event_get_fd(&client->instance->listener),\n\t                  pkt.buf + sizeof(pkt.header), fwdlen, 0,\n\t                  (struct sockaddr*)&client->clientaddr, sizeof(client->clientaddr));\n\tif (outgoing != fwdlen) {\n\t\tredudp_log_error(client, LOG_WARNING, \"sendto: I was sending %zd bytes, but only %zd were sent.\",\n\t\t                 fwdlen, outgoing);\n\t\treturn;\n\t}\n}\n\nstatic void redudp_pkt_from_client(int fd, short what, void *_arg)\n{\n\tredudp_instance *self = _arg;\n\tstruct sockaddr_in clientaddr, destaddr, *pdestaddr;\n\tchar buf[0xFFFF]; // UDP packet can't be larger then that\n\tssize_t pktlen;\n\tredudp_client *tmp, *client = NULL;\n\n\tpdestaddr = do_tproxy(self) ? &destaddr : NULL;\n\n\tassert(fd == event_get_fd(&self->listener));\n\tpktlen = red_recv_udp_pkt(fd, buf, sizeof(buf), &clientaddr, pdestaddr);\n\tif (pktlen == -1)\n\t\treturn;\n\n\t// TODO: this lookup may be SLOOOOOW.\n\tlist_for_each_entry(tmp, &self->clients, list) {\n\t\t// TODO: check destaddr\n\t\tif (0 == memcmp(&clientaddr, &tmp->clientaddr, sizeof(clientaddr))) {\n\t\t\tclient = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (client) {\n\t\tredsocks_time(&client->last_client_event);\n\t\tredudp_bump_timeout(client);\n\t\tif (event_initialized(&client->udprelay)) {\n\t\t\tredudp_forward_pkt(client, buf, pktlen);\n\t\t}\n\t\telse {\n\t\t\tredudp_enqeue_pkt(client, buf, pktlen);\n\t\t}\n\t}\n\telse {\n\t\tredudp_first_pkt_from_client(self, &clientaddr, pdestaddr, buf, pktlen);\n\t}\n}\n\n/***********************************************************************\n * Init / shutdown\n */\nstatic parser_entry redudp_entries[] =\n{\n\t{ .key = \"local_ip\",   .type = pt_in_addr },\n\t{ .key = \"local_port\", .type = pt_uint16 },\n\t{ .key = \"ip\",         .type = pt_in_addr },\n\t{ .key = \"port\",       .type = pt_uint16 },\n\t{ .key = \"login\",      .type = pt_pchar },\n\t{ .key = \"password\",   .type = pt_pchar },\n\t{ .key = \"dest_ip\",    .type = pt_in_addr },\n\t{ .key = \"dest_port\",  .type = pt_uint16 },\n\t{ .key = \"udp_timeout\", .type = pt_uint16 },\n\t{ .key = \"udp_timeout_stream\", .type = pt_uint16 },\n\t{ }\n};\n\nstatic list_head instances = LIST_HEAD_INIT(instances);\n\nstatic int redudp_onenter(parser_section *section)\n{\n\tredudp_instance *instance = calloc(1, sizeof(*instance));\n\tif (!instance) {\n\t\tparser_error(section->context, \"Not enough memory\");\n\t\treturn -1;\n\t}\n\n\tINIT_LIST_HEAD(&instance->list);\n\tINIT_LIST_HEAD(&instance->clients);\n\tinstance->config.bindaddr.sin_family = AF_INET;\n\tinstance->config.bindaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tinstance->config.relayaddr.sin_family = AF_INET;\n\tinstance->config.relayaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tinstance->config.destaddr.sin_family = AF_INET;\n\tinstance->config.max_pktqueue = 5;\n\tinstance->config.udp_timeout = 30;\n\tinstance->config.udp_timeout_stream = 180;\n\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr =\n\t\t\t(strcmp(entry->key, \"local_ip\") == 0)   ? (void*)&instance->config.bindaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"local_port\") == 0) ? (void*)&instance->config.bindaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"ip\") == 0)         ? (void*)&instance->config.relayaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"port\") == 0)       ? (void*)&instance->config.relayaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"login\") == 0)      ? (void*)&instance->config.login :\n\t\t\t(strcmp(entry->key, \"password\") == 0)   ? (void*)&instance->config.password :\n\t\t\t(strcmp(entry->key, \"dest_ip\") == 0)    ? (void*)&instance->config.destaddr.sin_addr :\n\t\t\t(strcmp(entry->key, \"dest_port\") == 0)  ? (void*)&instance->config.destaddr.sin_port :\n\t\t\t(strcmp(entry->key, \"max_pktqueue\") == 0) ? (void*)&instance->config.max_pktqueue :\n\t\t\t(strcmp(entry->key, \"udp_timeout\") == 0) ? (void*)&instance->config.udp_timeout:\n\t\t\t(strcmp(entry->key, \"udp_timeout_stream\") == 0) ? (void*)&instance->config.udp_timeout_stream :\n\t\t\tNULL;\n\tsection->data = instance;\n\treturn 0;\n}\n\nstatic int redudp_onexit(parser_section *section)\n{\n\tredudp_instance *instance = section->data;\n\n\tsection->data = NULL;\n\tfor (parser_entry *entry = &section->entries[0]; entry->key; entry++)\n\t\tentry->addr = NULL;\n\n\tinstance->config.bindaddr.sin_port = htons(instance->config.bindaddr.sin_port);\n\tinstance->config.relayaddr.sin_port = htons(instance->config.relayaddr.sin_port);\n\tinstance->config.destaddr.sin_port = htons(instance->config.destaddr.sin_port);\n\n\tif (instance->config.udp_timeout_stream < instance->config.udp_timeout) {\n\t\tparser_error(section->context, \"udp_timeout_stream should be not less then udp_timeout\");\n\t\treturn -1;\n\t}\n\n\tlist_add(&instance->list, &instances);\n\n\treturn 0;\n}\n\nstatic int redudp_init_instance(redudp_instance *instance)\n{\n\t/* FIXME: redudp_fini_instance is called in case of failure, this\n\t *        function will remove instance from instances list - result\n\t *        looks ugly.\n\t */\n\tint error;\n\tint fd = -1;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd == -1) {\n\t\tlog_errno(LOG_ERR, \"socket\");\n\t\tgoto fail;\n\t}\n\n\tif (do_tproxy(instance)) {\n\t\tint on = 1;\n\t\tchar buf[RED_INET_ADDRSTRLEN];\n\t\t// iptables TPROXY target does not send packets to non-transparent sockets\n\t\tif (0 != redudp_transparent(fd))\n\t\t\tgoto fail;\n\n\t\terror = setsockopt(fd, SOL_IP, IP_RECVORIGDSTADDR, &on, sizeof(on));\n\t\tif (error) {\n\t\t\tlog_errno(LOG_ERR, \"setsockopt(listener, SOL_IP, IP_RECVORIGDSTADDR)\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlog_error(LOG_DEBUG, \"redudp @ %s: TPROXY\", red_inet_ntop(&instance->config.bindaddr, buf, sizeof(buf)));\n\t}\n\telse {\n\t\tchar buf1[RED_INET_ADDRSTRLEN], buf2[RED_INET_ADDRSTRLEN];\n\t\tlog_error(LOG_DEBUG, \"redudp @ %s: destaddr=%s\",\n\t\t\tred_inet_ntop(&instance->config.bindaddr, buf1, sizeof(buf1)),\n\t\t\tred_inet_ntop(&instance->config.destaddr, buf2, sizeof(buf2)));\n\t}\n\n\terror = bind(fd, (struct sockaddr*)&instance->config.bindaddr, sizeof(instance->config.bindaddr));\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"bind\");\n\t\tgoto fail;\n\t}\n\n\terror = fcntl_nonblock(fd);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"fcntl\");\n\t\tgoto fail;\n\t}\n\n\tevent_set(&instance->listener, fd, EV_READ | EV_PERSIST, redudp_pkt_from_client, instance);\n\terror = event_add(&instance->listener, NULL);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"event_add\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tredudp_fini_instance(instance);\n\n\tif (fd != -1) {\n\t\tredsocks_close(fd);\n\t}\n\n\treturn -1;\n}\n\n/* Drops instance completely, freeing its memory and removing from\n * instances list.\n */\nstatic void redudp_fini_instance(redudp_instance *instance)\n{\n\tif (!list_empty(&instance->clients)) {\n\t\tredudp_client *tmp, *client = NULL;\n\n\t\tlog_error(LOG_WARNING, \"There are connected clients during shutdown! Disconnecting them.\");\n\t\tlist_for_each_entry_safe(client, tmp, &instance->clients, list) {\n\t\t\tredudp_drop_client(client);\n\t\t}\n\t}\n\n\tif (event_initialized(&instance->listener)) {\n\t\tif (event_del(&instance->listener) != 0)\n\t\t\tlog_errno(LOG_WARNING, \"event_del\");\n\t\tredsocks_close(event_get_fd(&instance->listener));\n\t\tmemset(&instance->listener, 0, sizeof(instance->listener));\n\t}\n\n\tlist_del(&instance->list);\n\n\tfree(instance->config.login);\n\tfree(instance->config.password);\n\n\tmemset(instance, 0, sizeof(*instance));\n\tfree(instance);\n}\n\nstatic int redudp_init()\n{\n\tredudp_instance *tmp, *instance = NULL;\n\n\t// TODO: init debug_dumper\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list) {\n\t\tif (redudp_init_instance(instance) != 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tredudp_fini();\n\treturn -1;\n}\n\nstatic int redudp_fini()\n{\n\tredudp_instance *tmp, *instance = NULL;\n\n\tlist_for_each_entry_safe(instance, tmp, &instances, list)\n\t\tredudp_fini_instance(instance);\n\n\treturn 0;\n}\n\nstatic parser_section redudp_conf_section =\n{\n\t.name    = \"redudp\",\n\t.entries = redudp_entries,\n\t.onenter = redudp_onenter,\n\t.onexit  = redudp_onexit\n};\n\napp_subsys redudp_subsys =\n{\n\t.init = redudp_init,\n\t.fini = redudp_fini,\n\t.conf_section = &redudp_conf_section,\n};\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "redudp.h",
          "type": "blob",
          "size": 1.3193359375,
          "content": "#ifndef REDUDP_H\n#define REDUDP_H\n\ntypedef struct redudp_config_t {\n\tstruct sockaddr_in bindaddr;\n\tstruct sockaddr_in relayaddr;\n\t// TODO:           outgoingaddr;\n\tstruct sockaddr_in destaddr;\n\tchar *login;\n\tchar *password;\n\tuint16_t max_pktqueue;\n\tuint16_t udp_timeout;\n\tuint16_t udp_timeout_stream;\n} redudp_config;\n\ntypedef struct redudp_instance_t {\n\tlist_head       list;\n\tredudp_config   config;\n\tstruct event    listener;\n\tlist_head       clients;\n} redudp_instance;\n\ntypedef struct redudp_client_t {\n\tlist_head           list;\n\tredudp_instance    *instance;\n\tstruct sockaddr_in  clientaddr;\n\tstruct sockaddr_in  destaddr;\n\tint                 sender_fd; // shared between several clients socket (bound to `destaddr`)\n\tstruct event        timeout;\n\tstruct bufferevent *relay;\n\tstruct event        udprelay;\n\tstruct sockaddr_in  udprelayaddr;\n\tint                 state;         // it's used by bottom layer\n\ttime_t              first_event;\n\ttime_t              last_client_event;\n\ttime_t              last_relay_event;\n\tunsigned int        queue_len;\n\tlist_head           queue;\n} redudp_client;\n\ntypedef struct enqueued_packet_t {\n\tlist_head  list;\n\tsize_t     len;\n\tchar       data[1];\n} enqueued_packet;\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* REDUDP_H */\n"
        },
        {
          "name": "socks4.c",
          "type": "blob",
          "size": 3.9990234375,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include \"log.h\"\n#include \"redsocks.h\"\n\ntypedef enum socks4_state_t {\n\tsocks4_new,\n\tsocks4_request_sent,\n\tsocks4_reply_came,\n\tsocks4_MAX,\n} socks4_state;\n\ntypedef struct socks4_req_t {\n\tuint8_t ver;\n\tuint8_t cmd;\n\tuint16_t port;\n\tuint32_t addr;\n\tchar login[1]; // we need at least zero-byte\n} PACKED socks4_req;\n\nconst int socks4_ver = 4;\nconst int socks4_cmd_connect = 1;\nconst int socks4_cmd_bind = 2;\n\ntypedef struct socks4_reply_t {\n\tuint8_t ver;\n\tuint8_t status;\n\tuint16_t port;\n\tuint32_t addr;\n} PACKED socks4_reply;\n\nconst int socks4_status_ok = 90;\nconst int socks4_status_fail = 91;\nconst int socks4_status_no_ident = 92;\nconst int socks4_status_fake_ident = 93;\n\n\nstatic void socks4_instance_init(redsocks_instance *instance)\n{\n\tif (instance->config.password)\n\t\tlog_error(LOG_WARNING, \"password <%s> is ignored for socks4 connections\", instance->config.password);\n}\n\nstatic void socks4_client_init(redsocks_client *client)\n{\n\tclient->state = socks4_new;\n}\n\n\nstatic void socks4_read_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\n\tassert(client->state >= socks4_request_sent);\n\n\tredsocks_touch_client(client);\n\n\tif (client->state == socks4_request_sent) {\n\t\tsocks4_reply reply;\n\n\t\tif (redsocks_read_expected(client, buffev->input, &reply, sizes_greater_equal, sizeof(reply)) < 0)\n\t\t\treturn;\n\n\t\tclient->state = socks4_reply_came;\n\t\tif (reply.ver != 0) {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks4 server reported unexpected reply version...\");\n\t\t\tredsocks_drop_client(client);\n\t\t}\n\t\telse if (reply.status == socks4_status_ok)\n\t\t\tredsocks_start_relay(client);\n\t\telse {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks4 server status: %s (%i)\",\n\t\t\t\treply.status == socks4_status_fail ? \"fail\" :\n\t\t\t\treply.status == socks4_status_no_ident ? \"no ident\" :\n\t\t\t\treply.status == socks4_status_fake_ident ? \"fake ident\" : \"?\",\n\t\t\t\treply.status);\n\t\t\tredsocks_drop_client(client);\n\t\t}\n\t}\n}\n\nstatic struct evbuffer *socks4_mkconnect(redsocks_client *client)\n{\n\tconst redsocks_config *config = &client->instance->config;\n\tconst char *username = config->login ? config->login : \"\";\n\t// space for \\0 comes from socks4_req->login\n\tsize_t username_len = strlen(username);\n\tsize_t len = sizeof(socks4_req) + username_len;\n\tsocks4_req *req = calloc(1, len);\n\n\treq->ver = socks4_ver;\n\treq->cmd = socks4_cmd_connect;\n\treq->port = client->destaddr.sin_port;\n\treq->addr = client->destaddr.sin_addr.s_addr;\n\tmemcpy(req->login, username, username_len + 1);\n\n\tstruct evbuffer *ret = mkevbuffer(req, len);\n\tfree(req);\n\treturn ret;\n}\n\nstatic void socks4_write_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\n\tredsocks_touch_client(client);\n\n\tif (client->state == socks4_new) {\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tsocks4_mkconnect, socks4_request_sent, sizeof(socks4_reply)\n\t\t\t);\n\t}\n\telse if (client->state >= socks4_request_sent) {\n\t\tbufferevent_disable(buffev, EV_WRITE);\n\t}\n}\n\n\nrelay_subsys socks4_subsys =\n{\n\t.name                 = \"socks4\",\n\t.payload_len          = 0,\n\t.instance_payload_len = 0,\n\t.readcb               = socks4_read_cb,\n\t.writecb              = socks4_write_cb,\n\t.init                 = socks4_client_init,\n\t.instance_init        = socks4_instance_init,\n};\n\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "socks5.c",
          "type": "blob",
          "size": 9.806640625,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <sys/socket.h>\n#include \"utils.h\"\n#include \"log.h\"\n#include \"redsocks.h\"\n#include \"socks5.h\"\n\ntypedef enum socks5_state_t {\n\tsocks5_new,\n\tsocks5_method_sent,\n\tsocks5_auth_sent,\n\tsocks5_request_sent,\n\tsocks5_skip_domain,\n\tsocks5_skip_address,\n\tsocks5_MAX,\n} socks5_state;\n\ntypedef struct socks5_client_t {\n\tint do_password; // 1 - password authentication is possible\n\tint to_skip;     // valid while reading last reply (after main request)\n} socks5_client;\n\nconst char *socks5_strstatus[] = {\n\t\"ok\",\n\t\"server failure\",\n\t\"connection not allowed by ruleset\",\n\t\"network unreachable\",\n\t\"host unreachable\",\n\t\"connection refused\",\n\t\"TTL expired\",\n\t\"command not supported\",\n\t\"address type not supported\",\n};\nconst size_t socks5_strstatus_len = SIZEOF_ARRAY(socks5_strstatus);\n\nconst char* socks5_status_to_str(int socks5_status)\n{\n\tif (0 <= socks5_status && socks5_status < socks5_strstatus_len) {\n\t\treturn socks5_strstatus[socks5_status];\n\t}\n\telse {\n\t\treturn \"\";\n\t}\n}\n\nbool socks5_is_valid_cred(const char *login, const char *password)\n{\n\tif (!login || !password)\n\t\treturn false;\n\tif (strlen(login) > 255) {\n\t\tlog_error(LOG_WARNING, \"Socks5 login can't be more than 255 chars, <%s> is too long\", login);\n\t\treturn false;\n\t}\n\tif (strlen(password) > 255) {\n\t\tlog_error(LOG_WARNING, \"Socks5 password can't be more than 255 chars, <%s> is too long\", password);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void socks5_instance_init(redsocks_instance *instance)\n{\n\tredsocks_config *config = &instance->config;\n\tif (config->login || config->password) {\n\t\tbool deauth = false;\n\t\tif (config->login && config->password) {\n\t\t\tdeauth = ! socks5_is_valid_cred(config->login, config->password);\n\t\t} else  {\n\t\t\tlog_error(LOG_WARNING, \"Socks5 needs either both login and password or none of them\");\n\t\t\tdeauth = true;\n\t\t}\n\t\tif (deauth) {\n\t\t\tfree(config->login);\n\t\t\tfree(config->password);\n\t\t\tconfig->login = config->password = NULL;\n\t\t}\n\t}\n}\n\nstatic void socks5_client_init(redsocks_client *client)\n{\n\tsocks5_client *socks5 = red_payload(client);\n\tconst redsocks_config *config = &client->instance->config;\n\n\tclient->state = socks5_new;\n\tsocks5->do_password = (config->login && config->password) ? 1 : 0;\n}\n\nstatic struct evbuffer *socks5_mkmethods(redsocks_client *client)\n{\n\tsocks5_client *socks5 = red_payload(client);\n\treturn socks5_mkmethods_plain(socks5->do_password);\n}\n\nstruct evbuffer *socks5_mkmethods_plain(int do_password)\n{\n\tassert(do_password == 0 || do_password == 1);\n\tint len = sizeof(socks5_method_req) + do_password;\n    socks5_method_req *req = calloc(1, len);\n\n\treq->ver = socks5_ver;\n\treq->num_methods = 1 + do_password;\n\treq->methods[0] = socks5_auth_none;\n\tif (do_password)\n\t\treq->methods[1] = socks5_auth_password;\n\n\tstruct evbuffer *ret = mkevbuffer(req, len);\n\tfree(req);\n\treturn ret;\n}\n\nstatic struct evbuffer *socks5_mkpassword(redsocks_client *client)\n{\n\treturn socks5_mkpassword_plain(client->instance->config.login, client->instance->config.password);\n}\n\nstruct evbuffer *socks5_mkpassword_plain(const char *login, const char *password)\n{\n\tsize_t ulen = strlen(login);\n\tsize_t plen = strlen(password);\n\tsize_t length =  1 /* version */ + 1 + ulen + 1 + plen;\n\tuint8_t req[length];\n\n\treq[0] = socks5_password_ver; // RFC 1929 says so\n\treq[1] = ulen;\n\tmemcpy(&req[2], login, ulen);\n\treq[2+ulen] = plen;\n\tmemcpy(&req[3+ulen], password, plen);\n\treturn mkevbuffer(req, length);\n}\n\nstruct evbuffer *socks5_mkcommand_plain(int socks5_cmd, const struct sockaddr_in *destaddr)\n{\n\tstruct {\n\t\tsocks5_req head;\n\t\tsocks5_addr_ipv4 ip;\n\t} PACKED req;\n\n\tassert(destaddr->sin_family == AF_INET);\n\n\treq.head.ver = socks5_ver;\n\treq.head.cmd = socks5_cmd;\n\treq.head.reserved = 0;\n\treq.head.addrtype = socks5_addrtype_ipv4;\n\treq.ip.addr = destaddr->sin_addr.s_addr;\n\treq.ip.port = destaddr->sin_port;\n\treturn mkevbuffer(&req, sizeof(req));\n}\n\nstatic struct evbuffer *socks5_mkconnect(redsocks_client *client)\n{\n\treturn socks5_mkcommand_plain(socks5_cmd_connect, &client->destaddr);\n}\n\nstatic void socks5_write_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\n\tredsocks_touch_client(client);\n\n\tif (client->state == socks5_new) {\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tsocks5_mkmethods, socks5_method_sent, sizeof(socks5_method_reply)\n\t\t\t);\n\t}\n}\n\nconst char* socks5_is_known_auth_method(socks5_method_reply *reply, int do_password)\n{\n\tif (reply->ver != socks5_ver)\n\t\treturn \"Socks5 server reported unexpected auth methods reply version...\";\n\telse if (reply->method == socks5_auth_invalid)\n\t\treturn \"Socks5 server refused all our auth methods.\";\n\telse if (reply->method != socks5_auth_none && !(reply->method == socks5_auth_password && do_password))\n\t\treturn \"Socks5 server requested unexpected auth method...\";\n\telse\n\t\treturn NULL;\n}\n\nstatic void socks5_read_auth_methods(struct bufferevent *buffev, redsocks_client *client, socks5_client *socks5)\n{\n\tsocks5_method_reply reply;\n\tconst char *error = NULL;\n\n\tif (redsocks_read_expected(client, buffev->input, &reply, sizes_equal, sizeof(reply)) < 0)\n\t\treturn;\n\n\terror = socks5_is_known_auth_method(&reply, socks5->do_password);\n\tif (error) {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"socks5_is_known_auth_method: %s\", error);\n\t\tredsocks_drop_client(client);\n\t}\n\telse if (reply.method == socks5_auth_none) {\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tsocks5_mkconnect, socks5_request_sent, sizeof(socks5_reply)\n\t\t\t);\n\t}\n\telse if (reply.method == socks5_auth_password) {\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tsocks5_mkpassword, socks5_auth_sent, sizeof(socks5_auth_reply)\n\t\t\t);\n\t}\n}\n\nstatic void socks5_read_auth_reply(struct bufferevent *buffev, redsocks_client *client, socks5_client *socks5)\n{\n\tsocks5_auth_reply reply;\n\n\tif (redsocks_read_expected(client, buffev->input, &reply, sizes_equal, sizeof(reply)) < 0)\n\t\treturn;\n\n\tif (reply.ver != socks5_password_ver) {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks5 server reported unexpected auth reply version %d\", reply.ver);\n\t\tredsocks_drop_client(client);\n\t}\n\telse if (reply.status == socks5_password_passed)\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tsocks5_mkconnect, socks5_request_sent, sizeof(socks5_reply)\n\t\t\t);\n\telse {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks5 auth failure, status %i\", reply.status);\n\t\tredsocks_drop_client(client);\n    }\n}\n\nstatic void socks5_read_reply(struct bufferevent *buffev, redsocks_client *client, socks5_client *socks5)\n{\n\tsocks5_reply reply;\n\n\tif (redsocks_read_expected(client, buffev->input, &reply, sizes_greater_equal, sizeof(reply)) < 0)\n\t\treturn;\n\n\tif (reply.ver != socks5_ver) {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks5 server reported unexpected reply version...\");\n\t\tredsocks_drop_client(client);\n\t}\n\telse if (reply.status == socks5_status_succeeded) {\n\t\tsocks5_state nextstate;\n\t\tsize_t len;\n\n\t\tif (reply.addrtype == socks5_addrtype_ipv4) {\n\t\t\tlen = socks5->to_skip = sizeof(socks5_addr_ipv4);\n\t\t\tnextstate = socks5_skip_address;\n\t\t}\n\t\telse if (reply.addrtype == socks5_addrtype_ipv6) {\n\t\t\tlen = socks5->to_skip = sizeof(socks5_addr_ipv6);\n\t\t\tnextstate = socks5_skip_address;\n\t\t}\n\t\telse if (reply.addrtype == socks5_addrtype_domain) {\n\t\t\tsocks5_addr_domain domain;\n\t\t\tlen = sizeof(domain.size);\n\t\t\tnextstate = socks5_skip_domain;\n\t\t}\n\t\telse {\n\t\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks5 server reported unexpected address type...\");\n\t\t\tredsocks_drop_client(client);\n\t\t\treturn;\n\t\t}\n\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tNULL, nextstate, len\n\t\t\t);\n\t}\n\telse {\n\t\tredsocks_log_error(client, LOG_NOTICE, \"Socks5 server status: %s (%i)\",\n\t\t\t\t/* 0 <= reply.status && */ reply.status < SIZEOF_ARRAY(socks5_strstatus)\n\t\t\t\t? socks5_strstatus[reply.status] : \"?\", reply.status);\n\t\tredsocks_drop_client(client);\n\t}\n}\n\nstatic void socks5_read_cb(struct bufferevent *buffev, void *_arg)\n{\n\tredsocks_client *client = _arg;\n\tsocks5_client *socks5 = red_payload(client);\n\n\tredsocks_touch_client(client);\n\n\tif (client->state == socks5_method_sent) {\n\t\tsocks5_read_auth_methods(buffev, client, socks5);\n\t}\n\telse if (client->state == socks5_auth_sent) {\n\t\tsocks5_read_auth_reply(buffev, client, socks5);\n\t}\n\telse if (client->state == socks5_request_sent) {\n\t\tsocks5_read_reply(buffev, client, socks5);\n\t}\n\telse if (client->state == socks5_skip_domain) {\n\t\tsocks5_addr_ipv4 ipv4; // all socks5_addr*.port are equal\n\t\tuint8_t size;\n\t\tif (redsocks_read_expected(client, buffev->input, &size, sizes_greater_equal, sizeof(size)) < 0)\n\t\t\treturn;\n\t\tsocks5->to_skip = size + sizeof(ipv4.port);\n\t\tredsocks_write_helper(\n\t\t\tbuffev, client,\n\t\t\tNULL, socks5_skip_address, socks5->to_skip\n\t\t\t);\n\t}\n\telse if (client->state == socks5_skip_address) {\n\t\tuint8_t data[socks5->to_skip];\n\t\tif (redsocks_read_expected(client, buffev->input, data, sizes_greater_equal, socks5->to_skip) < 0)\n\t\t\treturn;\n\t\tredsocks_start_relay(client);\n\t}\n\telse {\n\t\tredsocks_drop_client(client);\n\t}\n}\n\nrelay_subsys socks5_subsys =\n{\n\t.name                 = \"socks5\",\n\t.payload_len          = sizeof(socks5_client),\n\t.instance_payload_len = 0,\n\t.readcb               = socks5_read_cb,\n\t.writecb              = socks5_write_cb,\n\t.init                 = socks5_client_init,\n\t.instance_init        = socks5_instance_init,\n};\n\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n"
        },
        {
          "name": "socks5.h",
          "type": "blob",
          "size": 2.91796875,
          "content": "#ifndef SOCKS5_H\n#define SOCKS5_H\n\n#include <stdint.h>\n#include \"utils.h\"\n\ntypedef struct socks5_method_req_t {\n\tuint8_t ver;\n\tuint8_t num_methods;\n\tuint8_t methods[1]; // at least one\n} PACKED socks5_method_req;\n\ntypedef struct socks5_method_reply_t {\n\tuint8_t ver;\n\tuint8_t method;\n} PACKED socks5_method_reply;\n\nstatic const int socks5_ver = 5;\n\nstatic const int socks5_auth_none = 0x00;\nstatic const int socks5_auth_gssapi = 0x01;\nstatic const int socks5_auth_password = 0x02;\nstatic const int socks5_auth_invalid = 0xFF;\n\ntypedef struct socks5_auth_reply_t {\n\tuint8_t ver;\n\tuint8_t status;\n} PACKED socks5_auth_reply;\n\nstatic const int socks5_password_ver = 0x01;\nstatic const int socks5_password_passed = 0x00;\n\n\ntypedef struct socks5_addr_ipv4_t {\n\tuint32_t addr;\n\tuint16_t port;\n} PACKED socks5_addr_ipv4;\n\ntypedef struct socks5_addr_domain_t {\n\tuint8_t size;\n\tuint8_t more[1];\n\t/* uint16_t port; */\n} PACKED socks5_addr_domain;\n\ntypedef struct socks5_addr_ipv6_t {\n\tuint8_t addr[16];\n\tuint16_t port;\n} PACKED socks5_addr_ipv6;\n\ntypedef struct socks5_req_t {\n\tuint8_t ver;\n\tuint8_t cmd;\n\tuint8_t reserved;\n\tuint8_t addrtype;\n\t/* socks5_addr_* */\n} PACKED socks5_req;\n\ntypedef struct socks5_reply_t {\n\tuint8_t ver;\n\tuint8_t status;\n\tuint8_t reserved;\n\tuint8_t addrtype;\n\t/* socks5_addr_* */\n} PACKED socks5_reply;\n\ntypedef struct socks5_udp_preabmle_t {\n\tuint16_t reserved;\n\tuint8_t  frag_no;\n\tuint8_t  addrtype;   /* 0x01 for IPv4 */\n\t/* socks5_addr_* */\n\tsocks5_addr_ipv4 ip; /* I support only IPv4 at the moment */\n} PACKED socks5_udp_preabmle;\n\nstatic const int socks5_reply_maxlen = 512; // as domain name can't be longer than 256 bytes\nstatic const int socks5_addrtype_ipv4 = 1;\nstatic const int socks5_addrtype_domain = 3;\nstatic const int socks5_addrtype_ipv6 = 4;\nstatic const int socks5_status_succeeded = 0;\nstatic const int socks5_status_server_failure = 1;\nstatic const int socks5_status_connection_not_allowed_by_ruleset = 2;\nstatic const int socks5_status_Network_unreachable = 3;\nstatic const int socks5_status_Host_unreachable = 4;\nstatic const int socks5_status_Connection_refused = 5;\nstatic const int socks5_status_TTL_expired = 6;\nstatic const int socks5_status_Command_not_supported = 7;\nstatic const int socks5_status_Address_type_not_supported = 8;\n\n\nconst char* socks5_status_to_str(int socks5_status);\nbool socks5_is_valid_cred(const char *login, const char *password);\n\nstruct evbuffer *socks5_mkmethods_plain(int do_password);\nstruct evbuffer *socks5_mkpassword_plain(const char *login, const char *password);\nconst char* socks5_is_known_auth_method(socks5_method_reply *reply, int do_password);\n\nstatic const int socks5_cmd_connect = 1;\nstatic const int socks5_cmd_bind = 2;\nstatic const int socks5_cmd_udp_associate = 3;\nstruct evbuffer *socks5_mkcommand_plain(int socks5_cmd, const struct sockaddr_in *destaddr);\n\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* SOCKS5_H */\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 6.857421875,
          "content": "/* redsocks - transparent TCP-to-proxy redirector\n * Copyright (C) 2007-2018 Leonid Evdokimov <leon@darkk.net.ru>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License.  You may obtain a copy\n * of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"log.h\"\n#include \"base.h\"\n#include \"utils.h\"\n#include \"redsocks.h\" // for redsocks_close\n#include \"libc-compat.h\"\n\nint red_recv_udp_pkt(int fd, char *buf, size_t buflen, struct sockaddr_in *inaddr, struct sockaddr_in *toaddr)\n{\n\tsocklen_t addrlen = sizeof(*inaddr);\n\tssize_t pktlen;\n\tstruct msghdr msg;\n\tstruct iovec io;\n\tchar control[1024];\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_name = inaddr;\n\tmsg.msg_namelen = sizeof(*inaddr);\n\tmsg.msg_iov = &io;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = control;\n\tmsg.msg_controllen = sizeof(control);\n\tio.iov_base = buf;\n\tio.iov_len = buflen;\n\n\tpktlen = recvmsg(fd, &msg, 0);\n\tif (pktlen == -1) {\n\t\tlog_errno(LOG_WARNING, \"recvfrom\");\n\t\treturn -1;\n\t}\n\n\tif (toaddr) {\n\t\tmemset(toaddr, 0, sizeof(*toaddr));\n\t\tfor (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (\n\t\t\t\tcmsg->cmsg_level == SOL_IP &&\n\t\t\t\tcmsg->cmsg_type == IP_ORIGDSTADDR &&\n\t\t\t\tcmsg->cmsg_len >= CMSG_LEN(sizeof(*toaddr))\n\t\t\t) {\n\t\t\t\tstruct sockaddr_in* cmsgaddr = (struct sockaddr_in*)CMSG_DATA(cmsg);\n\t\t\t\tchar buf[RED_INET_ADDRSTRLEN];\n\t\t\t\tlog_error(LOG_DEBUG, \"IP_ORIGDSTADDR: %s\", red_inet_ntop(cmsgaddr, buf, sizeof(buf)));\n\t\t\t\tmemcpy(toaddr, cmsgaddr, sizeof(*toaddr));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog_error(LOG_WARNING, \"unexepcted cmsg (level,type) = (%d,%d)\",\n\t\t\t\t\tcmsg->cmsg_level, cmsg->cmsg_type);\n\t\t\t}\n\t\t}\n\t\tif (toaddr->sin_family != AF_INET) {\n\t\t\tlog_error(LOG_WARNING, \"(SOL_IP, IP_ORIGDSTADDR) not found\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (addrlen != sizeof(*inaddr)) {\n\t\tlog_error(LOG_WARNING, \"unexpected address length %u instead of %zu\", addrlen, sizeof(*inaddr));\n\t\treturn -1;\n\t}\n\n\tif (pktlen >= buflen) {\n\t\tchar buf[RED_INET_ADDRSTRLEN];\n\t\tlog_error(LOG_WARNING, \"wow! Truncated udp packet of size %zd from %s! impossible! dropping it...\",\n\t\t          pktlen, red_inet_ntop(inaddr, buf, sizeof(buf)));\n\t\treturn -1;\n\t}\n\n\treturn pktlen;\n}\n\nuint32_t red_randui32()\n{\n\tuint32_t ret;\n\tevutil_secure_rng_get_bytes(&ret, sizeof(ret));\n\treturn ret;\n}\n\ntime_t redsocks_time(time_t *t)\n{\n\ttime_t retval;\n\tretval = time(t);\n\tif (retval == ((time_t) -1))\n\t\tlog_errno(LOG_WARNING, \"time\");\n\treturn retval;\n}\n\nint redsocks_gettimeofday(struct timeval *tv)\n{\n\tint retval = gettimeofday(tv, NULL);\n\tif (retval != 0)\n\t\tlog_errno(LOG_WARNING, \"gettimeofday\");\n\treturn retval;\n}\n\nchar *redsocks_evbuffer_readline(struct evbuffer *buf)\n{\n#if _EVENT_NUMERIC_VERSION >= 0x02000000\n\treturn evbuffer_readln(buf, NULL, EVBUFFER_EOL_CRLF);\n#else\n\treturn evbuffer_readline(buf);\n#endif\n}\n\nint red_socket_client(int type)\n{\n\tint fd = -1;\n\tint error;\n\n\tfd = socket(AF_INET, type, 0);\n\tif (fd == -1) {\n\t\tlog_errno(LOG_ERR, \"socket\");\n\t\tgoto fail;\n\t}\n\n\terror = fcntl_nonblock(fd);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"fcntl\");\n\t\tgoto fail;\n\t}\n\n\tif (type == SOCK_STREAM) {\n\t\tif (apply_tcp_keepalive(fd))\n\t\t\tgoto fail;\n\t}\n\n\treturn fd;\n\nfail:\n\tif (fd != -1)\n\t\tredsocks_close(fd);\n\treturn -1;\n}\n\nint red_socket_server(int type, struct sockaddr_in *bindaddr)\n{\n\tint on = 1;\n\tint error;\n\tint fd = red_socket_client(type);\n\tif (fd == -1)\n\t\tgoto fail;\n\n\terror = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"setsockopt\");\n\t\tgoto fail;\n\t}\n\n\terror = bind(fd, (struct sockaddr*)bindaddr, sizeof(*bindaddr));\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"bind\");\n\t\tgoto fail;\n\t}\n\n\treturn fd;\nfail:\n\tif (fd != -1)\n\t\tredsocks_close(fd);\n\treturn -1;\n\n}\n\n\nstruct bufferevent* red_connect_relay(struct sockaddr_in *addr, evbuffercb writecb, everrorcb errorcb, void *cbarg)\n{\n\tstruct bufferevent *retval = NULL;\n\tint relay_fd = -1;\n\tint error;\n\n\trelay_fd = red_socket_client(SOCK_STREAM);\n\n\terror = connect(relay_fd, (struct sockaddr*)addr, sizeof(*addr));\n\tif (error && errno != EINPROGRESS) {\n\t\tlog_errno(LOG_NOTICE, \"connect\");\n\t\tgoto fail;\n\t}\n\n\tretval = bufferevent_new(relay_fd, NULL, writecb, errorcb, cbarg);\n\tif (!retval) {\n\t\tlog_errno(LOG_ERR, \"bufferevent_new\");\n\t\tgoto fail;\n\t}\n\n\trelay_fd = -1;\n\n\terror = bufferevent_enable(retval, EV_WRITE); // we wait for connection...\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"bufferevent_enable\");\n\t\tgoto fail;\n\t}\n\n\treturn retval;\n\nfail:\n\tif (relay_fd != -1)\n\t\tredsocks_close(relay_fd);\n\tif (retval)\n\t\tredsocks_bufferevent_free(retval);\n\treturn NULL;\n}\n\nint red_socket_geterrno(struct bufferevent *buffev)\n{\n\tint error;\n\tint pseudo_errno;\n\tsocklen_t optlen = sizeof(pseudo_errno);\n\n\tassert(event_get_fd(&buffev->ev_read) == event_get_fd(&buffev->ev_write));\n\n\terror = getsockopt(event_get_fd(&buffev->ev_read), SOL_SOCKET, SO_ERROR, &pseudo_errno, &optlen);\n\tif (error) {\n\t\tlog_errno(LOG_ERR, \"getsockopt\");\n\t\treturn -1;\n\t}\n\treturn pseudo_errno;\n}\n\n/** simple fcntl(2) wrapper, provides errno and all logging to caller\n * I have to use it in event-driven code because of accept(2) (see NOTES)\n * and connect(2) (see ERRORS about EINPROGRESS)\n */\nint fcntl_nonblock(int fd)\n{\n\tint error;\n\tint flags;\n\n\tflags = fcntl(fd, F_GETFL);\n\tif (flags == -1)\n\t\treturn -1;\n\n\terror = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n\tif (error)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint red_is_socket_connected_ok(struct bufferevent *buffev)\n{\n\tint pseudo_errno = red_socket_geterrno(buffev);\n\n\tif (pseudo_errno == -1) {\n\t\treturn 0;\n\t}\n\telse if (pseudo_errno) {\n\t\terrno = pseudo_errno;\n\t\tlog_errno(LOG_NOTICE, \"connect\");\n\t\treturn 0;\n\t}\n\telse {\n\t\treturn 1;\n\t}\n}\n\nchar *red_inet_ntop(const struct sockaddr_in* sa, char* buffer, size_t buffer_size)\n{\n\tconst char *retval = 0;\n\tsize_t len = 0;\n\tuint16_t port;\n\tconst char placeholder[] = \"???:???\";\n\n\tassert(buffer_size >= RED_INET_ADDRSTRLEN);\n\n\tmemset(buffer, 0, buffer_size);\n\tif (sa->sin_family == AF_INET) {\n\t\tretval = inet_ntop(AF_INET, &sa->sin_addr, buffer, buffer_size);\n\t\tport = ((struct sockaddr_in*)sa)->sin_port;\n\t}\n\telse if (sa->sin_family == AF_INET6) {\n\t\tretval = inet_ntop(AF_INET6, &((const struct sockaddr_in6*)sa)->sin6_addr, buffer, buffer_size);\n\t\tport = ((struct sockaddr_in6*)sa)->sin6_port;\n\t}\n\tif (retval) {\n\t\tassert(retval == buffer);\n\t\tlen = strlen(retval);\n\t\tsnprintf(buffer + len, buffer_size - len, \":%d\", ntohs(port));\n\t}\n\telse {\n\t\tstrcpy(buffer, placeholder);\n\t}\n\treturn buffer;\n}\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 2.7470703125,
          "content": "#ifndef UTILS_H_SAT_FEB__2_02_24_05_2008\n#define UTILS_H_SAT_FEB__2_02_24_05_2008\n\n#include <stddef.h>\n#include <time.h>\n#include <event.h>\n\nstruct sockaddr_in;\n\n#define SIZEOF_ARRAY(arr)        (sizeof(arr) / sizeof(arr[0]))\n#define FOREACH(ptr, array)      for (ptr = array; ptr < array + SIZEOF_ARRAY(array); ptr++)\n#define FOREACH_REV(ptr, array)  for (ptr = array + SIZEOF_ARRAY(array) - 1; ptr >= array; ptr--)\n\n#define UNUSED(x)                ((void)(x))\n\n#if defined __GNUC__\n#define PACKED __attribute__((packed))\n#else\n#error Unknown compiler, modify utils.h for it\n#endif\n\n\n#ifdef __GNUC__\n#define member_type(type, member) __typeof(((type *)0)->member)\n#else\n#define member_type(type, member) const void\n#endif\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) \\\n\t((type *)( \\\n\t\t(char *)(member_type(type, member) *){ ptr } - offsetof(type, member) \\\n\t))\n\n\n#define clamp_value(value, min_val, max_val) do { \\\n       if (value < min_val) \\\n               value = min_val; \\\n       if (value > max_val) \\\n               value = max_val; \\\n} while (0)\n\n\nuint32_t red_randui32();\ntime_t redsocks_time(time_t *t);\nint redsocks_gettimeofday(struct timeval *tv);\nchar *redsocks_evbuffer_readline(struct evbuffer *buf);\nstruct bufferevent* red_connect_relay(struct sockaddr_in *addr, evbuffercb writecb, everrorcb errorcb, void *cbarg);\nint red_socket_geterrno(struct bufferevent *buffev);\nint red_socket_client(int type);\nint red_socket_server(int type, struct sockaddr_in *bindaddr);\nint red_is_socket_connected_ok(struct bufferevent *buffev);\nint red_recv_udp_pkt(int fd, char *buf, size_t buflen, struct sockaddr_in *fromaddr, struct sockaddr_in *toaddr);\n\nint fcntl_nonblock(int fd);\n\n#define event_fmt_str \"%s|%s|%s|%s|%s|0x%x\"\n#define event_fmt(what) \\\n\t\t\t\t(what) & EVBUFFER_READ ? \"EVBUFFER_READ\" : \"0\", \\\n\t\t\t\t(what) & EVBUFFER_WRITE ? \"EVBUFFER_WRITE\" : \"0\", \\\n\t\t\t\t(what) & EVBUFFER_EOF ? \"EVBUFFER_EOF\" : \"0\", \\\n\t\t\t\t(what) & EVBUFFER_ERROR ? \"EVBUFFER_ERROR\" : \"0\", \\\n\t\t\t\t(what) & EVBUFFER_TIMEOUT ? \"EVBUFFER_TIMEOUT\" : \"0\", \\\n\t\t\t\t(what) & ~(EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF|EVBUFFER_ERROR|EVBUFFER_TIMEOUT)\n\n#if INET6_ADDRSTRLEN < INET_ADDRSTRLEN\n#\terror Impossible happens: INET6_ADDRSTRLEN < INET_ADDRSTRLEN\n#else\n#\tdefine RED_INET_ADDRSTRLEN (INET6_ADDRSTRLEN + 1 + 5 + 1) // addr + : + port + \\0\n#endif\nchar *red_inet_ntop(const struct sockaddr_in* sa, char* buffer, size_t buffer_size);\n\n/* vim:set tabstop=4 softtabstop=4 shiftwidth=4: */\n/* vim:set foldmethod=marker foldlevel=32 foldmarker={,}: */\n#endif /* UTILS_H_SAT_FEB__2_02_24_05_2008 */\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 0.166015625,
          "content": "#ifndef VERSION_H_SUN_NOV_27_03_22_30_2011\n#define VERSION_H_SUN_NOV_27_03_22_30_2011\n\nextern const char* redsocks_version;\n\n#endif // VERSION_H_SUN_NOV_27_03_22_30_2011\n"
        }
      ]
    }
  ]
}