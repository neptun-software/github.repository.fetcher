{
  "metadata": {
    "timestamp": 1736709699535,
    "page": 73,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "attractivechaos/klib",
      "stars": 4242,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.458984375,
          "content": "# General\n*.a\n*.dSYM/\n*.la\n*.lo\n*.o\n*.opensdf\n*.orig\n*.sdf\n*.suo\n*.swp\n*.tests\n*.vcxproj.filters\n*.vcxproj.user\n*~\n.git\nTAGS\n\n# Mac/Xcode-specfic\nxcuserdata\ncontents.xcworkspacedata\n.DS_Store\n._*\n\n# Test byproducts\ntest/kbtree_test\ntest/khash_keith\ntest/khash_keith2\ntest/khash_test\ntest/klist_test\ntest/kmin_test\ntest/kseq_bench\ntest/kseq_bench2\ntest/kseq_test\ntest/ksort_test\ntest/ksort_test-stl\ntest/kstring_bench\ntest/kstring_bench2\ntest/kstring_test\ntest/kvec_test\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0791015625,
          "content": "The MIT License\n\nCopyright (c) 2008-     Attractive Chaos <attractor@live.co.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.8525390625,
          "content": "# Klib: a Generic Library in C\n\n## <a name=\"overview\"></a>Overview\n\nKlib is a standalone and lightweight C library distributed under [MIT/X11\nlicense][1]. Most components are independent of external libraries, except the\nstandard C library, and independent of each other. To use a component of this\nlibrary, you only need to copy a couple of files to your source code tree\nwithout worrying about library dependencies.\n\nKlib strives for efficiency and a small memory footprint. Some components, such\nas khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient\nimplementations of similar algorithms or data structures in all programming\nlanguages, in terms of both speed and memory use.\n\nA new documentation is available [here](http://attractivechaos.github.io/klib/)\nwhich includes most information in this README file.\n\n#### Common components\n\n* [khash.h][khash]: generic [hash table][2] with open addressing.\n* [kbtree.h][kbtree]: generic search tree based on [B-tree][3].\n* [kavl.h][kavl]: generic intrusive [AVL tree][wiki-avl].\n* [ksort.h][ksort]: generic sort, including [introsort][4], [merge sort][5], [heap sort][6], [comb sort][7], [Knuth shuffle][8] and the [k-small][9] algorithm.\n* [kseq.h][kseq]: generic stream buffer and a [FASTA][10]/[FASTQ][11] format parser.\n* kvec.h: generic dynamic array.\n* klist.h: generic single-linked list and [memory pool][12].\n* kstring.{h,c}: basic string library.\n* kmath.{h,c}: numerical routines including [MT19937-64][13] [pseudorandom generator][14], basic [nonlinear programming][15] and a few special math functions.\n* [ketopt.h][ketopt]: portable command-line argument parser with getopt\\_long-like API.\n\n#### Components for more specific use cases\n\n* ksa.c: constructing [suffix arrays][16] for strings with multiple sentinels, based on a revised [SAIS algorithm][17].\n* knetfile.{h,c}: random access to remote files on HTTP or FTP.\n* kopen.c: smart stream opening.\n* khmm.{h,c}: basic [HMM][18] library.\n* ksw.(h,c}: Striped [Smith-Waterman algorithm][19].\n* knhx.{h,c}: [Newick tree format][20] parser.\n\n\n## <a name=\"methodology\"></a>Methodology\n\nFor the implementation of generic [containers][21], klib extensively uses C\nmacros. To use these data structures, we usually need to instantiate methods by\nexpanding a long macro. This makes the source code look unusual or even ugly\nand adds difficulty to debugging. Unfortunately, for efficient generic\nprogramming in C that lacks [template][22], using macros is the only\nsolution. Only with macros, we can write a generic container which, once\ninstantiated, compete with a type-specific container in efficiency. Some\ngeneric libraries in C, such as [Glib][23], use the `void*` type to implement\ncontainers. These implementations are usually slower and use more memory than\nklib (see [this benchmark][31]).\n\nTo effectively use klib, it is important to understand how it achieves generic\nprogramming. We will use the hash table library as an example:\n\n    #include \"khash.h\"\n    KHASH_MAP_INIT_INT(m32, char)        // instantiate structs and methods\n    int main() {\n        int ret, is_missing;\n        khint_t k;\n        khash_t(m32) *h = kh_init(m32);  // allocate a hash table\n        k = kh_put(m32, h, 5, &ret);     // insert a key to the hash table\n        if (!ret) kh_del(m32, h, k);\n        kh_value(h, k) = 10;             // set the value\n        k = kh_get(m32, h, 10);          // query the hash table\n        is_missing = (k == kh_end(h));   // test if the key is present\n        k = kh_get(m32, h, 5);\n        kh_del(m32, h, k);               // remove a key-value pair\n        for (k = kh_begin(h); k != kh_end(h); ++k)  // traverse\n            if (kh_exist(h, k))          // test if a bucket contains data\n    \t\t\tkh_value(h, k) = 1;\n        kh_destroy(m32, h);              // deallocate the hash table\n        return 0;\n    }\n\nIn this example, the second line instantiates a hash table with `unsigned` as\nthe key type and `char` as the value type. `m32` names such a type of hash table.\nAll types and functions associated with this name are macros, which will be\nexplained later. Macro `kh_init()` initiates a hash table and `kh_destroy()`\nfrees it. `kh_put()` inserts a key and returns the iterator (or the position)\nin the hash table. `kh_get()` and `kh_del()` get a key and delete an element,\nrespectively. Macro `kh_exist()` tests if an iterator (or a position) is filled\nwith data.\n\nAn immediate question is this piece of code does not look like a valid C\nprogram (e.g. lacking semicolon, assignment to an _apparent_ function call and\n_apparent_ undefined `m32` 'variable'). To understand why the code is correct,\nlet's go a bit further into the source code of `khash.h`, whose skeleton looks\nlike:\n\n    #define KHASH_INIT(name, SCOPE, key_t, val_t, is_map, _hashf, _hasheq) \\\n      typedef struct { \\\n        int n_buckets, size, n_occupied, upper_bound; \\\n        unsigned *flags; \\\n        key_t *keys; \\\n        val_t *vals; \\\n      } kh_##name##_t; \\\n      SCOPE inline kh_##name##_t *init_##name() { \\\n        return (kh_##name##_t*)calloc(1, sizeof(kh_##name##_t)); \\\n      } \\\n      SCOPE inline int get_##name(kh_##name##_t *h, key_t k) \\\n      ... \\\n      SCOPE inline void destroy_##name(kh_##name##_t *h) { \\\n        if (h) { \\\n          free(h->keys); free(h->flags); free(h->vals); free(h); \\\n        } \\\n      }\n    \n    #define _int_hf(key) (unsigned)(key)\n    #define _int_heq(a, b) (a == b)\n    #define khash_t(name) kh_##name##_t\n    #define kh_value(h, k) ((h)->vals[k])\n    #define kh_begin(h, k) 0\n    #define kh_end(h) ((h)->n_buckets)\n    #define kh_init(name) init_##name()\n    #define kh_get(name, h, k) get_##name(h, k)\n    #define kh_destroy(name, h) destroy_##name(h)\n    ...\n    #define KHASH_MAP_INIT_INT(name, val_t) \\\n    \tKHASH_INIT(name, static, unsigned, val_t, is_map, _int_hf, _int_heq)\n\n`KHASH_INIT()` is a huge macro defining all the structs and methods. When this\nmacro is called, all the code inside it will be inserted by the [C\npreprocess][37] to the place where it is called. If the macro is called\nmultiple times, multiple copies of the code will be inserted. To avoid naming\nconflict of hash tables with different key-value types, the library uses [token\nconcatenation][36], which is a preprocessor feature whereby we can substitute\npart of a symbol based on the parameter of the macro. In the end, the C\npreprocessor will generate the following code and feed it to the compiler\n(macro `kh_exist(h,k)` is a little complex and not expanded for simplicity):\n\n    typedef struct {\n      int n_buckets, size, n_occupied, upper_bound;\n      unsigned *flags;\n      unsigned *keys;\n      char *vals;\n    } kh_m32_t;\n    static inline kh_m32_t *init_m32() {\n      return (kh_m32_t*)calloc(1, sizeof(kh_m32_t));\n    }\n    static inline int get_m32(kh_m32_t *h, unsigned k)\n    ...\n    static inline void destroy_m32(kh_m32_t *h) {\n      if (h) {\n        free(h->keys); free(h->flags); free(h->vals); free(h);\n      }\n    }\n\n\tint main() {\n\t\tint ret, is_missing;\n\t\tkhint_t k;\n\t\tkh_m32_t *h = init_m32();\n\t\tk = put_m32(h, 5, &ret);\n\t\tif (!ret) del_m32(h, k);\n\t\th->vals[k] = 10;\n\t\tk = get_m32(h, 10);\n\t\tis_missing = (k == h->n_buckets);\n\t\tk = get_m32(h, 5);\n\t\tdel_m32(h, k);\n\t\tfor (k = 0; k != h->n_buckets; ++k)\n\t\t\tif (kh_exist(h, k)) h->vals[k] = 1;\n\t\tdestroy_m32(h);\n\t\treturn 0;\n\t}\n\nThis is the C program we know.\n\nFrom this example, we can see that macros and the C preprocessor plays a key\nrole in klib. Klib is fast partly because the compiler knows the key-value\ntype at the compile time and is able to optimize the code to the same level\nas type-specific code. A generic library written with `void*` will not get such\nperformance boost.\n\nMassively inserting code upon instantiation may remind us of C++'s slow\ncompiling speed and huge binary size when STL/boost is in use. Klib is much\nbetter in this respect due to its small code size and component independency.\nInserting several hundreds lines of code won't make compiling obviously slower.\n\n## <a name=\"resources\"></a>Resources\n\n* Library documentation, if present, is available in the header files. Examples\ncan be found in the [test/][24] directory.\n* **Obsolete** documentation of the hash table library can be found at\n[SourceForge][25]. This README is partly adapted from the old documentation.\n* [Blog post][26] describing the hash table library.\n* [Blog post][27] on why using `void*` for generic programming may be inefficient.\n* [Blog post][28] on the generic stream buffer.\n* [Blog post][29] evaluating the performance of `kvec.h`.\n* [Blog post][30] arguing B-tree may be a better data structure than a binary search tree.\n* [Blog post][31] evaluating the performance of `khash.h` and `kbtree.h` among many other implementations.\n[An older version][33] of the benchmark is also available.\n* [Blog post][34] benchmarking internal sorting algorithms and implementations.\n* [Blog post][32] on the k-small algorithm.\n* [Blog post][35] on the Hooke-Jeeve's algorithm for nonlinear programming.\n\n[1]: http://en.wikipedia.org/wiki/MIT_License\n[2]: https://en.wikipedia.org/wiki/Hash_table\n[3]: http://en.wikipedia.org/wiki/B-tree\n[4]: http://en.wikipedia.org/wiki/Introsort\n[5]: http://en.wikipedia.org/wiki/Merge_sort\n[6]: http://en.wikipedia.org/wiki/Heapsort\n[7]: http://en.wikipedia.org/wiki/Comb_sort\n[8]: http://en.wikipedia.org/wiki/Fisher-Yates_shuffle\n[9]: http://en.wikipedia.org/wiki/Selection_algorithm\n[10]: http://en.wikipedia.org/wiki/FASTA_format\n[11]: http://en.wikipedia.org/wiki/FASTQ_format\n[12]: http://en.wikipedia.org/wiki/Memory_pool\n[13]: http://en.wikipedia.org/wiki/Mersenne_twister\n[14]: http://en.wikipedia.org/wiki/Pseudorandom_generator\n[15]: http://en.wikipedia.org/wiki/Nonlinear_programming\n[16]: http://en.wikipedia.org/wiki/Suffix_array\n[17]: https://sites.google.com/site/yuta256/sais\n[18]: http://en.wikipedia.org/wiki/Hidden_Markov_model\n[19]: http://en.wikipedia.org/wiki/Smith-Waterman_algorithm\n[20]: http://en.wikipedia.org/wiki/Newick_format\n[21]: http://en.wikipedia.org/wiki/Container_(abstract_data_type)\n[22]: http://en.wikipedia.org/wiki/Template_(C%2B%2B)\n[23]: http://en.wikipedia.org/wiki/GLib\n[24]: https://github.com/attractivechaos/klib/tree/master/test\n[25]: http://klib.sourceforge.net/\n[26]: http://attractivechaos.wordpress.com/2008/09/02/implementing-generic-hash-library-in-c/\n[27]: http://attractivechaos.wordpress.com/2008/10/02/using-void-in-generic-c-programming-may-be-inefficient/\n[28]: http://attractivechaos.wordpress.com/2008/10/11/a-generic-buffered-stream-wrapper/\n[29]: http://attractivechaos.wordpress.com/2008/09/19/c-array-vs-c-vector/\n[30]: http://attractivechaos.wordpress.com/2008/09/24/b-tree-vs-binary-search-tree/\n[31]: http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/\n[32]: http://attractivechaos.wordpress.com/2008/09/13/calculating-median/\n[33]: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/\n[34]: http://attractivechaos.wordpress.com/2008/08/28/comparison-of-internal-sorting-algorithms/\n[35]: http://attractivechaos.wordpress.com/2008/08/24/derivative-free-optimization-dfo/\n[36]: http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation\n[37]: http://en.wikipedia.org/wiki/C_preprocessor\n\n[wiki-avl]: https://en.wikipedia.org/wiki/AVL_tree\n\n[kbtree]: http://attractivechaos.github.io/klib/#KBtree%3A%20generic%20ordered%20map:%5B%5BKBtree%3A%20generic%20ordered%20map%5D%5D\n[khash]: http://attractivechaos.github.io/klib/#Khash%3A%20generic%20hash%20table:%5B%5BKhash%3A%20generic%20hash%20table%5D%5D\n[kseq]: http://attractivechaos.github.io/klib/#Kseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser:%5B%5BKseq%3A%20stream%20buffer%20and%20FASTA%2FQ%20parser%5D%5D\n[ksort]: http://attractivechaos.github.io/klib/#Ksort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small:%5B%5BKsort%3A%20sorting%2C%20shuffling%2C%20heap%20and%20k-small%5D%5D\n[kavl]: http://attractivechaos.github.io/klib/#KAVL%3A%20generic%20intrusive%20AVL%20tree\n[ketopt]: http://attractivechaos.github.io/klib/#Ketopt%3A%20parsing%20command-line%20arguments\n"
        },
        {
          "name": "bgzf.c",
          "type": "blob",
          "size": 16.6826171875,
          "content": "/* The MIT License\n\n   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology\n                 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   THE SOFTWARE.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/types.h>\n#include \"bgzf.h\"\n\n#ifdef _USE_KNETFILE\n#include \"knetfile.h\"\ntypedef knetFile *_bgzf_file_t;\n#define _bgzf_open(fn, mode) knet_open(fn, mode)\n#define _bgzf_dopen(fp, mode) knet_dopen(fp, mode)\n#define _bgzf_close(fp) knet_close(fp)\n#define _bgzf_fileno(fp) ((fp)->fd)\n#define _bgzf_tell(fp) knet_tell(fp)\n#define _bgzf_seek(fp, offset, whence) knet_seek(fp, offset, whence)\n#define _bgzf_read(fp, buf, len) knet_read(fp, buf, len)\n#define _bgzf_write(fp, buf, len) knet_write(fp, buf, len)\n#else // ~defined(_USE_KNETFILE)\n#if defined(_WIN32) || defined(_MSC_VER)\n#define ftello(fp) ftell(fp)\n#define fseeko(fp, offset, whence) fseek(fp, offset, whence)\n#else // ~defined(_WIN32)\nextern off_t ftello(FILE *stream);\nextern int fseeko(FILE *stream, off_t offset, int whence);\n#endif // ~defined(_WIN32)\ntypedef FILE *_bgzf_file_t;\n#define _bgzf_open(fn, mode) fopen(fn, mode)\n#define _bgzf_dopen(fp, mode) fdopen(fp, mode)\n#define _bgzf_close(fp) fclose(fp)\n#define _bgzf_fileno(fp) fileno(fp)\n#define _bgzf_tell(fp) ftello(fp)\n#define _bgzf_seek(fp, offset, whence) fseeko(fp, offset, whence)\n#define _bgzf_read(fp, buf, len) fread(buf, 1, len, fp)\n#define _bgzf_write(fp, buf, len) fwrite(buf, 1, len, fp)\n#endif // ~define(_USE_KNETFILE)\n\n#define BLOCK_HEADER_LENGTH 18\n#define BLOCK_FOOTER_LENGTH 8\n\n/* BGZF/GZIP header (speciallized from RFC 1952; little endian):\n +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n | 31|139|  8|  4|              0|  0|255|      6| 66| 67|      2|BLK_LEN|\n +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n*/\nstatic const uint8_t g_magic[19] = \"\\037\\213\\010\\4\\0\\0\\0\\0\\0\\377\\6\\0\\102\\103\\2\\0\\0\\0\";\n\n#ifdef BGZF_CACHE\ntypedef struct {\n\tint size;\n\tuint8_t *block;\n\tint64_t end_offset;\n} cache_t;\n#include \"khash.h\"\nKHASH_MAP_INIT_INT64(cache, cache_t)\n#endif\n\nstatic inline void packInt16(uint8_t *buffer, uint16_t value)\n{\n\tbuffer[0] = value;\n\tbuffer[1] = value >> 8;\n}\n\nstatic inline int unpackInt16(const uint8_t *buffer)\n{\n\treturn buffer[0] | buffer[1] << 8;\n}\n\nstatic inline void packInt32(uint8_t *buffer, uint32_t value)\n{\n\tbuffer[0] = value;\n\tbuffer[1] = value >> 8;\n\tbuffer[2] = value >> 16;\n\tbuffer[3] = value >> 24;\n}\n\nstatic BGZF *bgzf_read_init()\n{\n\tBGZF *fp;\n\tfp = calloc(1, sizeof(BGZF));\n\tfp->open_mode = 'r';\n\tfp->uncompressed_block = malloc(BGZF_MAX_BLOCK_SIZE);\n\tfp->compressed_block = malloc(BGZF_MAX_BLOCK_SIZE);\n#ifdef BGZF_CACHE\n\tfp->cache = kh_init(cache);\n#endif\n\treturn fp;\n}\n\nstatic BGZF *bgzf_write_init(int compress_level) // compress_level==-1 for the default level\n{\n\tBGZF *fp;\n\tfp = calloc(1, sizeof(BGZF));\n\tfp->open_mode = 'w';\n\tfp->uncompressed_block = malloc(BGZF_MAX_BLOCK_SIZE);\n\tfp->compressed_block = malloc(BGZF_MAX_BLOCK_SIZE);\n\tfp->compress_level = compress_level < 0? Z_DEFAULT_COMPRESSION : compress_level; // Z_DEFAULT_COMPRESSION==-1\n\tif (fp->compress_level > 9) fp->compress_level = Z_DEFAULT_COMPRESSION;\n\treturn fp;\n}\n// get the compress level from the mode string\nstatic int mode2level(const char *__restrict mode)\n{\n\tint i, compress_level = -1;\n\tfor (i = 0; mode[i]; ++i)\n\t\tif (mode[i] >= '0' && mode[i] <= '9') break;\n\tif (mode[i]) compress_level = (int)mode[i] - '0';\n\tif (strchr(mode, 'u')) compress_level = 0;\n\treturn compress_level;\n}\n\nBGZF *bgzf_open(const char *path, const char *mode)\n{\n\tBGZF *fp = 0;\n\tif (strchr(mode, 'r') || strchr(mode, 'R')) {\n\t\t_bgzf_file_t fpr;\n\t\tif ((fpr = _bgzf_open(path, \"r\")) == 0) return 0;\n\t\tfp = bgzf_read_init();\n\t\tfp->fp = fpr;\n\t} else if (strchr(mode, 'w') || strchr(mode, 'W')) {\n\t\tFILE *fpw;\n\t\tif ((fpw = fopen(path, \"w\")) == 0) return 0;\n\t\tfp = bgzf_write_init(mode2level(mode));\n\t\tfp->fp = fpw;\n\t}\n\treturn fp;\n}\n\nBGZF *bgzf_dopen(int fd, const char *mode)\n{\n\tBGZF *fp = 0;\n\tif (strchr(mode, 'r') || strchr(mode, 'R')) {\n\t\t_bgzf_file_t fpr;\n\t\tif ((fpr = _bgzf_dopen(fd, \"r\")) == 0) return 0;\n\t\tfp = bgzf_read_init();\n\t\tfp->fp = fpr;\n\t} else if (strchr(mode, 'w') || strchr(mode, 'W')) {\n\t\tFILE *fpw;\n\t\tif ((fpw = fdopen(fd, \"w\")) == 0) return 0;\n\t\tfp = bgzf_write_init(mode2level(mode));\n\t\tfp->fp = fpw;\n\t}\n\treturn fp;\n}\n\n// Deflate the block in fp->uncompressed_block into fp->compressed_block. Also adds an extra field that stores the compressed block length.\nstatic int deflate_block(BGZF *fp, int block_length)\n{\n\tuint8_t *buffer = fp->compressed_block;\n\tint buffer_size = BGZF_BLOCK_SIZE;\n\tint input_length = block_length;\n\tint compressed_length = 0;\n\tint remaining;\n\tuint32_t crc;\n\n\tassert(block_length <= BGZF_BLOCK_SIZE); // guaranteed by the caller\n\tmemcpy(buffer, g_magic, BLOCK_HEADER_LENGTH); // the last two bytes are a place holder for the length of the block\n\twhile (1) { // loop to retry for blocks that do not compress enough\n\t\tint status;\n\t\tz_stream zs;\n\t\tzs.zalloc = NULL;\n\t\tzs.zfree = NULL;\n\t\tzs.next_in = fp->uncompressed_block;\n\t\tzs.avail_in = input_length;\n\t\tzs.next_out = (void*)&buffer[BLOCK_HEADER_LENGTH];\n\t\tzs.avail_out = buffer_size - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;\n\t\tstatus = deflateInit2(&zs, fp->compress_level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY); // -15 to disable zlib header/footer\n\t\tif (status != Z_OK) {\n\t\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\t\treturn -1;\n\t\t}\n\t\tstatus = deflate(&zs, Z_FINISH);\n\t\tif (status != Z_STREAM_END) { // not compressed enough\n\t\t\tdeflateEnd(&zs); // reset the stream\n\t\t\tif (status == Z_OK) { // reduce the size and recompress\n\t\t\t\tinput_length -= 1024;\n\t\t\t\tassert(input_length > 0); // logically, this should not happen\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\t\treturn -1;\n\t\t}\n\t\tif (deflateEnd(&zs) != Z_OK) {\n\t\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\t\treturn -1;\n\t\t}\n\t\tcompressed_length = zs.total_out;\n\t\tcompressed_length += BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;\n\t\tassert(compressed_length <= BGZF_BLOCK_SIZE);\n\t\tbreak;\n\t}\n\n\tassert(compressed_length > 0);\n\tpackInt16((uint8_t*)&buffer[16], compressed_length - 1); // write the compressed_length; -1 to fit 2 bytes\n\tcrc = crc32(0L, NULL, 0L);\n\tcrc = crc32(crc, fp->uncompressed_block, input_length);\n\tpackInt32((uint8_t*)&buffer[compressed_length-8], crc);\n\tpackInt32((uint8_t*)&buffer[compressed_length-4], input_length);\n\n\tremaining = block_length - input_length;\n\tif (remaining > 0) {\n\t\tassert(remaining <= input_length);\n\t\tmemcpy(fp->uncompressed_block, fp->uncompressed_block + input_length, remaining);\n\t}\n\tfp->block_offset = remaining;\n\treturn compressed_length;\n}\n\n// Inflate the block in fp->compressed_block into fp->uncompressed_block\nstatic int inflate_block(BGZF* fp, int block_length)\n{\n\tz_stream zs;\n\tzs.zalloc = NULL;\n\tzs.zfree = NULL;\n\tzs.next_in = fp->compressed_block + 18;\n\tzs.avail_in = block_length - 16;\n\tzs.next_out = fp->uncompressed_block;\n\tzs.avail_out = BGZF_BLOCK_SIZE;\n\n\tif (inflateInit2(&zs, -15) != Z_OK) {\n\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\treturn -1;\n\t}\n\tif (inflate(&zs, Z_FINISH) != Z_STREAM_END) {\n\t\tinflateEnd(&zs);\n\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\treturn -1;\n\t}\n\tif (inflateEnd(&zs) != Z_OK) {\n\t\tfp->errcode |= BGZF_ERR_ZLIB;\n\t\treturn -1;\n\t}\n\treturn zs.total_out;\n}\n\nstatic int check_header(const uint8_t *header)\n{\n\treturn (header[0] == 31 && header[1] == 139 && header[2] == 8 && (header[3] & 4) != 0\n\t\t\t&& unpackInt16((uint8_t*)&header[10]) == 6\n\t\t\t&& header[12] == 'B' && header[13] == 'C'\n\t\t\t&& unpackInt16((uint8_t*)&header[14]) == 2);\n}\n\n#ifdef BGZF_CACHE\nstatic void free_cache(BGZF *fp)\n{\n\tkhint_t k;\n\tkhash_t(cache) *h = (khash_t(cache)*)fp->cache;\n\tif (fp->open_mode != 'r') return;\n\tfor (k = kh_begin(h); k < kh_end(h); ++k)\n\t\tif (kh_exist(h, k)) free(kh_val(h, k).block);\n\tkh_destroy(cache, h);\n}\n\nstatic int load_block_from_cache(BGZF *fp, int64_t block_address)\n{\n\tkhint_t k;\n\tcache_t *p;\n\tkhash_t(cache) *h = (khash_t(cache)*)fp->cache;\n\tk = kh_get(cache, h, block_address);\n\tif (k == kh_end(h)) return 0;\n\tp = &kh_val(h, k);\n\tif (fp->block_length != 0) fp->block_offset = 0;\n\tfp->block_address = block_address;\n\tfp->block_length = p->size;\n\tmemcpy(fp->uncompressed_block, p->block, BGZF_BLOCK_SIZE);\n\t_bgzf_seek((_bgzf_file_t)fp->fp, p->end_offset, SEEK_SET);\n\treturn p->size;\n}\n\nstatic void cache_block(BGZF *fp, int size)\n{\n\tint ret;\n\tkhint_t k;\n\tcache_t *p;\n\tkhash_t(cache) *h = (khash_t(cache)*)fp->cache;\n\tif (BGZF_BLOCK_SIZE >= fp->cache_size) return;\n\tif ((kh_size(h) + 1) * BGZF_BLOCK_SIZE > fp->cache_size) {\n\t\t/* A better way would be to remove the oldest block in the\n\t\t * cache, but here we remove a random one for simplicity. This\n\t\t * should not have a big impact on performance. */\n\t\tfor (k = kh_begin(h); k < kh_end(h); ++k)\n\t\t\tif (kh_exist(h, k)) break;\n\t\tif (k < kh_end(h)) {\n\t\t\tfree(kh_val(h, k).block);\n\t\t\tkh_del(cache, h, k);\n\t\t}\n\t}\n\tk = kh_put(cache, h, fp->block_address, &ret);\n\tif (ret == 0) return; // if this happens, a bug!\n\tp = &kh_val(h, k);\n\tp->size = fp->block_length;\n\tp->end_offset = fp->block_address + size;\n\tp->block = malloc(BGZF_BLOCK_SIZE);\n\tmemcpy(kh_val(h, k).block, fp->uncompressed_block, BGZF_BLOCK_SIZE);\n}\n#else\nstatic void free_cache(BGZF *fp) {}\nstatic int load_block_from_cache(BGZF *fp, int64_t block_address) {return 0;}\nstatic void cache_block(BGZF *fp, int size) {}\n#endif\n\nint bgzf_read_block(BGZF *fp)\n{\n\tuint8_t header[BLOCK_HEADER_LENGTH], *compressed_block;\n\tint count, size = 0, block_length, remaining;\n\tint64_t block_address;\n\tblock_address = _bgzf_tell((_bgzf_file_t)fp->fp);\n\tif (load_block_from_cache(fp, block_address)) return 0;\n\tcount = _bgzf_read(fp->fp, header, sizeof(header));\n\tif (count == 0) { // no data read\n\t\tfp->block_length = 0;\n\t\treturn 0;\n\t}\n\tif (count != sizeof(header) || !check_header(header)) {\n\t\tfp->errcode |= BGZF_ERR_HEADER;\n\t\treturn -1;\n\t}\n\tsize = count;\n\tblock_length = unpackInt16((uint8_t*)&header[16]) + 1; // +1 because when writing this number, we used \"-1\"\n\tcompressed_block = (uint8_t*)fp->compressed_block;\n\tmemcpy(compressed_block, header, BLOCK_HEADER_LENGTH);\n\tremaining = block_length - BLOCK_HEADER_LENGTH;\n\tcount = _bgzf_read(fp->fp, &compressed_block[BLOCK_HEADER_LENGTH], remaining);\n\tif (count != remaining) {\n\t\tfp->errcode |= BGZF_ERR_IO;\n\t\treturn -1;\n\t}\n\tsize += count;\n\tif ((count = inflate_block(fp, block_length)) < 0) return -1;\n\tif (fp->block_length != 0) fp->block_offset = 0; // Do not reset offset if this read follows a seek.\n\tfp->block_address = block_address;\n\tfp->block_length = count;\n\tcache_block(fp, size);\n\treturn 0;\n}\n\nssize_t bgzf_read(BGZF *fp, void *data, ssize_t length)\n{\n\tssize_t bytes_read = 0;\n\tuint8_t *output = data;\n\tif (length <= 0) return 0;\n\tassert(fp->open_mode == 'r');\n\twhile (bytes_read < length) {\n\t\tint copy_length, available = fp->block_length - fp->block_offset;\n\t\tuint8_t *buffer;\n\t\tif (available <= 0) {\n\t\t\tif (bgzf_read_block(fp) != 0) return -1;\n\t\t\tavailable = fp->block_length - fp->block_offset;\n\t\t\tif (available <= 0) break;\n\t\t}\n\t\tcopy_length = length - bytes_read < available? length - bytes_read : available;\n\t\tbuffer = fp->uncompressed_block;\n\t\tmemcpy(output, buffer + fp->block_offset, copy_length);\n\t\tfp->block_offset += copy_length;\n\t\toutput += copy_length;\n\t\tbytes_read += copy_length;\n\t}\n\tif (fp->block_offset == fp->block_length) {\n\t\tfp->block_address = _bgzf_tell((_bgzf_file_t)fp->fp);\n\t\tfp->block_offset = fp->block_length = 0;\n\t}\n\treturn bytes_read;\n}\n\nint bgzf_flush(BGZF *fp)\n{\n\tassert(fp->open_mode == 'w');\n\twhile (fp->block_offset > 0) {\n\t\tint block_length;\n\t\tblock_length = deflate_block(fp, fp->block_offset);\n\t\tif (block_length < 0) return -1;\n\t\tif (fwrite(fp->compressed_block, 1, block_length, fp->fp) != block_length) {\n\t\t\tfp->errcode |= BGZF_ERR_IO; // possibly truncated file\n\t\t\treturn -1;\n\t\t}\n\t\tfp->block_address += block_length;\n\t}\n\treturn 0;\n}\n\nint bgzf_flush_try(BGZF *fp, ssize_t size)\n{\n\tif (fp->block_offset + size > BGZF_BLOCK_SIZE)\n\t\treturn bgzf_flush(fp);\n\treturn -1;\n}\n\nssize_t bgzf_write(BGZF *fp, const void *data, ssize_t length)\n{\n\tconst uint8_t *input = data;\n\tint block_length = BGZF_BLOCK_SIZE, bytes_written;\n\tassert(fp->open_mode == 'w');\n\tinput = data;\n\tbytes_written = 0;\n\twhile (bytes_written < length) {\n\t\tuint8_t* buffer = fp->uncompressed_block;\n\t\tint copy_length = block_length - fp->block_offset < length - bytes_written? block_length - fp->block_offset : length - bytes_written;\n\t\tmemcpy(buffer + fp->block_offset, input, copy_length);\n\t\tfp->block_offset += copy_length;\n\t\tinput += copy_length;\n\t\tbytes_written += copy_length;\n\t\tif (fp->block_offset == block_length && bgzf_flush(fp)) break;\n\t}\n\treturn bytes_written;\n}\n\nint bgzf_close(BGZF* fp)\n{\n\tint ret, count, block_length;\n\tif (fp == 0) return -1;\n\tif (fp->open_mode == 'w') {\n\t\tif (bgzf_flush(fp) != 0) return -1;\n\t\tblock_length = deflate_block(fp, 0); // write an empty block\n\t\tcount = fwrite(fp->compressed_block, 1, block_length, fp->fp);\n\t\tif (fflush(fp->fp) != 0) {\n\t\t\tfp->errcode |= BGZF_ERR_IO;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = fp->open_mode == 'w'? fclose(fp->fp) : _bgzf_close(fp->fp);\n\tif (ret != 0) return -1;\n\tfree(fp->uncompressed_block);\n\tfree(fp->compressed_block);\n\tfree_cache(fp);\n\tfree(fp);\n\treturn 0;\n}\n\nvoid bgzf_set_cache_size(BGZF *fp, int cache_size)\n{\n\tif (fp) fp->cache_size = cache_size;\n}\n\nint bgzf_check_EOF(BGZF *fp)\n{\n\tstatic uint8_t magic[28] = \"\\037\\213\\010\\4\\0\\0\\0\\0\\0\\377\\6\\0\\102\\103\\2\\0\\033\\0\\3\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\tuint8_t buf[28];\n\toff_t offset;\n\toffset = _bgzf_tell((_bgzf_file_t)fp->fp);\n\tif (_bgzf_seek(fp->fp, -28, SEEK_END) < 0) return 0;\n\t_bgzf_read(fp->fp, buf, 28);\n\t_bgzf_seek(fp->fp, offset, SEEK_SET);\n\treturn (memcmp(magic, buf, 28) == 0)? 1 : 0;\n}\n\nint64_t bgzf_seek(BGZF* fp, int64_t pos, int where)\n{\n\tint block_offset;\n\tint64_t block_address;\n\n\tif (fp->open_mode != 'r' || where != SEEK_SET) {\n\t\tfp->errcode |= BGZF_ERR_MISUSE;\n\t\treturn -1;\n\t}\n\tblock_offset = pos & 0xFFFF;\n\tblock_address = pos >> 16;\n\tif (_bgzf_seek(fp->fp, block_address, SEEK_SET) < 0) {\n\t\tfp->errcode |= BGZF_ERR_IO;\n\t\treturn -1;\n\t}\n\tfp->block_length = 0;  // indicates current block has not been loaded\n\tfp->block_address = block_address;\n\tfp->block_offset = block_offset;\n\treturn 0;\n}\n\nint bgzf_is_bgzf(const char *fn)\n{\n\tuint8_t buf[16];\n\tint n;\n\t_bgzf_file_t fp;\n\tif ((fp = _bgzf_open(fn, \"r\")) == 0) return 0;\n\tn = _bgzf_read(fp, buf, 16);\n\t_bgzf_close(fp);\n\tif (n != 16) return 0;\n\treturn memcmp(g_magic, buf, 16) == 0? 1 : 0;\n}\n\nint bgzf_getc(BGZF *fp)\n{\n\tint c;\n\tif (fp->block_offset >= fp->block_length) {\n\t\tif (bgzf_read_block(fp) != 0) return -2; /* error */\n\t\tif (fp->block_length == 0) return -1; /* end-of-file */\n\t}\n\tc = ((unsigned char*)fp->uncompressed_block)[fp->block_offset++];\n    if (fp->block_offset == fp->block_length) {\n        fp->block_address = _bgzf_tell((_bgzf_file_t)fp->fp);\n        fp->block_offset = 0;\n        fp->block_length = 0;\n    }\n\treturn c;\n}\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\nint bgzf_getline(BGZF *fp, int delim, kstring_t *str)\n{\n\tint l, state = 0;\n\tunsigned char *buf = (unsigned char*)fp->uncompressed_block;\n\tstr->l = 0;\n\tdo {\n\t\tif (fp->block_offset >= fp->block_length) {\n\t\t\tif (bgzf_read_block(fp) != 0) { state = -2; break; }\n\t\t\tif (fp->block_length == 0) { state = -1; break; }\n\t\t}\n\t\tfor (l = fp->block_offset; l < fp->block_length && buf[l] != delim; ++l);\n\t\tif (l < fp->block_length) state = 1;\n\t\tl -= fp->block_offset;\n\t\tif (str->l + l + 1 >= str->m) {\n\t\t\tstr->m = str->l + l + 2;\n\t\t\tkroundup32(str->m);\n\t\t\tstr->s = (char*)realloc(str->s, str->m);\n\t\t}\n\t\tmemcpy(str->s + str->l, buf + fp->block_offset, l);\n\t\tstr->l += l;\n\t\tfp->block_offset += l + 1;\n\t\tif (fp->block_offset >= fp->block_length) {\n\t\t\tfp->block_address = _bgzf_tell((_bgzf_file_t)fp->fp);\n\t\t\tfp->block_offset = 0;\n\t\t\tfp->block_length = 0;\n\t\t} \n\t} while (state == 0);\n\tif (str->l == 0 && state < 0) return state;\n\tstr->s[str->l] = 0;\n\treturn str->l;\n}\n"
        },
        {
          "name": "bgzf.h",
          "type": "blob",
          "size": 5.7236328125,
          "content": "/* The MIT License\n\n   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology\n                 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in\n   all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   THE SOFTWARE.\n*/\n\n/* The BGZF library was originally written by Bob Handsaker from the Broad\n * Institute. It was later improved by the SAMtools developers. */\n\n#ifndef __BGZF_H\n#define __BGZF_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <zlib.h>\n\n#define BGZF_BLOCK_SIZE     0x10000\n#define BGZF_MAX_BLOCK_SIZE 0x10000\n\n#define BGZF_ERR_ZLIB   1\n#define BGZF_ERR_HEADER 2\n#define BGZF_ERR_IO     4\n#define BGZF_ERR_MISUSE 8\n\ntypedef struct {\n    int open_mode:8, compress_level:8, errcode:16;\n\tint cache_size;\n    int block_length, block_offset;\n    int64_t block_address;\n    void *uncompressed_block, *compressed_block;\n\tvoid *cache; // a pointer to a hash table\n\tvoid *fp; // actual file handler; FILE* on writing; FILE* or knetFile* on reading\n} BGZF;\n\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\t/******************\n\t * Basic routines *\n\t ******************/\n\n\t/**\n\t * Open an existing file descriptor for reading or writing.\n\t *\n\t * @param fd    file descriptor\n\t * @param mode  mode matching /[rwu0-9]+/: 'r' for reading, 'w' for writing and a digit specifies\n\t *              the zlib compression level; if both 'r' and 'w' are present, 'w' is ignored.\n\t * @return      BGZF file handler; 0 on error\n\t */\n\tBGZF* bgzf_dopen(int fd, const char *mode);\n\n\t#define bgzf_fdopen(fd, mode) bgzf_dopen((fd), (mode)) // for backward compatibility\n\n\t/**\n\t * Open the specified file for reading or writing.\n\t */\n\tBGZF* bgzf_open(const char* path, const char *mode);\n\n\t/**\n\t * Close the BGZF and free all associated resources.\n\t *\n\t * @param fp    BGZF file handler\n\t * @return      0 on success and -1 on error\n\t */\n\tint bgzf_close(BGZF *fp);\n\n\t/**\n\t * Read up to _length_ bytes from the file storing into _data_.\n\t *\n\t * @param fp     BGZF file handler\n\t * @param data   data array to read into\n\t * @param length size of data to read\n\t * @return       number of bytes actually read; 0 on end-of-file and -1 on error\n\t */\n\tssize_t bgzf_read(BGZF *fp, void *data, ssize_t length);\n\n\t/**\n\t * Write _length_ bytes from _data_ to the file.\n\t *\n\t * @param fp     BGZF file handler\n\t * @param data   data array to write\n\t * @param length size of data to write\n\t * @return       number of bytes actually written; -1 on error\n\t */\n\tssize_t bgzf_write(BGZF *fp, const void *data, ssize_t length);\n\n\t/**\n\t * Write the data in the buffer to the file.\n\t */\n\tint bgzf_flush(BGZF *fp);\n\n\t/**\n\t * Return a virtual file pointer to the current location in the file.\n\t * No interpetation of the value should be made, other than a subsequent\n\t * call to bgzf_seek can be used to position the file at the same point.\n\t * Return value is non-negative on success.\n\t */\n\t#define bgzf_tell(fp) ((fp->block_address << 16) | (fp->block_offset & 0xFFFF))\n\n\t/**\n\t * Set the file to read from the location specified by _pos_.\n\t *\n\t * @param fp     BGZF file handler\n\t * @param pos    virtual file offset returned by bgzf_tell()\n\t * @param whence must be SEEK_SET\n\t * @return       0 on success and -1 on error\n\t */\n\tint64_t bgzf_seek(BGZF *fp, int64_t pos, int whence);\n\n\t/**\n\t * Check if the BGZF end-of-file (EOF) marker is present\n\t *\n\t * @param fp    BGZF file handler opened for reading\n\t * @return      1 if EOF is present; 0 if not or on I/O error\n\t */\n\tint bgzf_check_EOF(BGZF *fp);\n\n\t/**\n\t * Check if a file is in the BGZF format\n\t *\n\t * @param fn    file name\n\t * @return      1 if _fn_ is BGZF; 0 if not or on I/O error\n\t */\n\t int bgzf_is_bgzf(const char *fn);\n\n\t/*********************\n\t * Advanced routines *\n\t *********************/\n\n\t/**\n\t * Set the cache size. Only effective when compiled with -DBGZF_CACHE.\n\t *\n\t * @param fp    BGZF file handler\n\t * @param size  size of cache in bytes; 0 to disable caching (default)\n\t */\n\tvoid bgzf_set_cache_size(BGZF *fp, int size);\n\n\t/**\n\t * Flush the file if the remaining buffer size is smaller than _size_ \n\t */\n\tint bgzf_flush_try(BGZF *fp, ssize_t size);\n\n\t/**\n\t * Read one byte from a BGZF file. It is faster than bgzf_read()\n\t * @param fp     BGZF file handler\n\t * @return       byte read; -1 on end-of-file or error\n\t */\n\tint bgzf_getc(BGZF *fp);\n\n\t/**\n\t * Read one line from a BGZF file. It is faster than bgzf_getc()\n\t *\n\t * @param fp     BGZF file handler\n\t * @param delim  delimitor\n\t * @param str    string to write to; must be initialized\n\t * @return       length of the string; 0 on end-of-file; negative on error\n\t */\n\tint bgzf_getline(BGZF *fp, int delim, kstring_t *str);\n\n\t/**\n\t * Read the next BGZF block.\n\t */\n\tint bgzf_read_block(BGZF *fp);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "cpp",
          "type": "tree",
          "content": null
        },
        {
          "name": "kalloc.c",
          "type": "blob",
          "size": 7.865234375,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"kalloc.h\"\n\n/* In kalloc, a *core* is a large chunk of contiguous memory. Each core is\n * associated with a master header, which keeps the size of the current core\n * and the pointer to next core. Kalloc allocates small *blocks* of memory from\n * the cores and organizes free memory blocks in a circular single-linked list.\n *\n * In the following diagram, \"@\" stands for the header of a free block (of type\n * header_t), \"#\" for the header of an allocated block (of type size_t), \"-\"\n * for free memory, and \"+\" for allocated memory.\n *\n * master        This region is core 1.          master           This region is core 2.\n *      |                                             |\n *      *@-------#++++++#++++++++++++@--------        *@----------#++++++++++++#+++++++@------------\n *       |                           |                 |                               |\n *       p=p->ptr->ptr->ptr->ptr     p->ptr            p->ptr->ptr                     p->ptr->ptr->ptr\n */\ntypedef struct header_t {\n\tsize_t size;\n\tstruct header_t *ptr;\n} header_t;\n\ntypedef struct {\n\tvoid *par;\n\tsize_t min_core_size;\n\theader_t base, *loop_head, *core_head; /* base is a zero-sized block always kept in the loop */\n} kmem_t;\n\nstatic void panic(const char *s)\n{\n\tfprintf(stderr, \"%s\\n\", s);\n\tabort();\n}\n\nvoid *km_init2(void *km_par, size_t min_core_size)\n{\n\tkmem_t *km;\n\tkm = (kmem_t*)kcalloc(km_par, 1, sizeof(kmem_t));\n\tkm->par = km_par;\n\tif (km_par) km->min_core_size = min_core_size > 0? min_core_size : ((kmem_t*)km_par)->min_core_size - 2;\n\telse km->min_core_size = min_core_size > 0? min_core_size : 0x80000;\n\treturn (void*)km;\n}\n\nvoid *km_init(void) { return km_init2(0, 0); }\n\nvoid km_destroy(void *_km)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tvoid *km_par;\n\theader_t *p, *q;\n\tif (km == NULL) return;\n\tkm_par = km->par;\n\tfor (p = km->core_head; p != NULL;) {\n\t\tq = p->ptr;\n\t\tkfree(km_par, p);\n\t\tp = q;\n\t}\n\tkfree(km_par, km);\n}\n\nstatic header_t *morecore(kmem_t *km, size_t nu)\n{\n\theader_t *q;\n\tsize_t bytes, *p;\n\tnu = (nu + 1 + (km->min_core_size - 1)) / km->min_core_size * km->min_core_size; /* the first +1 for core header */\n\tbytes = nu * sizeof(header_t);\n\tq = (header_t*)kmalloc(km->par, bytes);\n\tif (!q) panic(\"[morecore] insufficient memory\");\n\tq->ptr = km->core_head, q->size = nu, km->core_head = q;\n\tp = (size_t*)(q + 1);\n\t*p = nu - 1; /* the size of the free block; -1 because the first unit is used for the core header */\n\tkfree(km, p + 1); /* initialize the new \"core\"; NB: the core header is not looped. */\n\treturn km->loop_head;\n}\n\nvoid kfree(void *_km, void *ap) /* kfree() also adds a new core to the circular list */\n{\n\theader_t *p, *q;\n\tkmem_t *km = (kmem_t*)_km;\n\t\n\tif (!ap) return;\n\tif (km == NULL) {\n\t\tfree(ap);\n\t\treturn;\n\t}\n\tp = (header_t*)((size_t*)ap - 1);\n\tp->size = *((size_t*)ap - 1);\n\t/* Find the pointer that points to the block to be freed. The following loop can stop on two conditions:\n\t *\n\t * a) \"p>q && p<q->ptr\": @------#++++++++#+++++++@-------    @---------------#+++++++@-------\n\t *    (can also be in    |      |                |        -> |                       |\n\t *     two cores)        q      p           q->ptr           q                  q->ptr\n\t *\n\t *                       @--------    #+++++++++@--------    @--------    @------------------\n\t *                       |            |         |         -> |            |\n\t *                       q            p    q->ptr            q       q->ptr\n\t *\n\t * b) \"q>=q->ptr && (p>q || p<q->ptr)\":  @-------#+++++   @--------#+++++++     @-------#+++++   @----------------\n\t *                                       |                |        |         -> |                |\n\t *                                  q->ptr                q        p       q->ptr                q\n\t *\n\t *                                       #+++++++@-----   #++++++++@-------     @-------------   #++++++++@-------\n\t *                                       |       |                 |         -> |                         |\n\t *                                       p  q->ptr                 q       q->ptr                         q\n\t */\n\tfor (q = km->loop_head; !(p > q && p < q->ptr); q = q->ptr)\n\t\tif (q >= q->ptr && (p > q || p < q->ptr)) break;\n\tif (p + p->size == q->ptr) { /* two adjacent blocks, merge p and q->ptr (the 2nd and 4th cases) */\n\t\tp->size += q->ptr->size;\n\t\tp->ptr = q->ptr->ptr;\n\t} else if (p + p->size > q->ptr && q->ptr >= p) {\n\t\tpanic(\"[kfree] The end of the allocated block enters a free block.\");\n\t} else p->ptr = q->ptr; /* backup q->ptr */\n\n\tif (q + q->size == p) { /* two adjacent blocks, merge q and p (the other two cases) */\n\t\tq->size += p->size;\n\t\tq->ptr = p->ptr;\n\t\tkm->loop_head = q;\n\t} else if (q + q->size > p && p >= q) {\n\t\tpanic(\"[kfree] The end of a free block enters the allocated block.\");\n\t} else km->loop_head = p, q->ptr = p; /* in two cores, cannot be merged; create a new block in the list */\n}\n\nvoid *kmalloc(void *_km, size_t n_bytes)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tsize_t n_units;\n\theader_t *p, *q;\n\n\tif (n_bytes == 0) return 0;\n\tif (km == NULL) return malloc(n_bytes);\n\tn_units = (n_bytes + sizeof(size_t) + sizeof(header_t) - 1) / sizeof(header_t); /* header+n_bytes requires at least this number of units */\n\n\tif (!(q = km->loop_head)) /* the first time when kmalloc() is called, intialize it */\n\t\tq = km->loop_head = km->base.ptr = &km->base;\n\tfor (p = q->ptr;; q = p, p = p->ptr) { /* search for a suitable block */\n\t\tif (p->size >= n_units) { /* p->size if the size of current block. This line means the current block is large enough. */\n\t\t\tif (p->size == n_units) q->ptr = p->ptr; /* no need to split the block */\n\t\t\telse { /* split the block. NB: memory is allocated at the end of the block! */\n\t\t\t\tp->size -= n_units; /* reduce the size of the free block */\n\t\t\t\tp += p->size; /* p points to the allocated block */\n\t\t\t\t*(size_t*)p = n_units; /* set the size */\n\t\t\t}\n\t\t\tkm->loop_head = q; /* set the end of chain */\n\t\t\treturn (size_t*)p + 1;\n\t\t}\n\t\tif (p == km->loop_head) { /* then ask for more \"cores\" */\n\t\t\tif ((p = morecore(km, n_units)) == 0) return 0;\n\t\t}\n\t}\n}\n\nvoid *kcalloc(void *_km, size_t count, size_t size)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tvoid *p;\n\tif (size == 0 || count == 0) return 0;\n\tif (km == NULL) return calloc(count, size);\n\tp = kmalloc(km, count * size);\n\tmemset(p, 0, count * size);\n\treturn p;\n}\n\nvoid *krealloc(void *_km, void *ap, size_t n_bytes) // TODO: this can be made more efficient in principle\n{\n\tkmem_t *km = (kmem_t*)_km;\n\tsize_t cap, *p, *q;\n\n\tif (n_bytes == 0) {\n\t\tkfree(km, ap); return 0;\n\t}\n\tif (km == NULL) return realloc(ap, n_bytes);\n\tif (ap == NULL) return kmalloc(km, n_bytes);\n\tp = (size_t*)ap - 1;\n\tcap = (*p) * sizeof(header_t) - sizeof(size_t);\n\tif (cap >= n_bytes) return ap; /* TODO: this prevents shrinking */\n\tq = (size_t*)kmalloc(km, n_bytes);\n\tmemcpy(q, ap, cap);\n\tkfree(km, ap);\n\treturn q;\n}\n\nvoid *krelocate(void *km, void *ap, size_t n_bytes)\n{\n\tvoid *p;\n\tif (km == 0 || ap == 0) return ap;\n\tp = kmalloc(km, n_bytes);\n\tmemcpy(p, ap, n_bytes);\n\tkfree(km, ap);\n\treturn p;\n}\n\nvoid km_stat(const void *_km, km_stat_t *s)\n{\n\tkmem_t *km = (kmem_t*)_km;\n\theader_t *p;\n\tmemset(s, 0, sizeof(km_stat_t));\n\tif (km == NULL || km->loop_head == NULL) return;\n\tfor (p = km->loop_head;; p = p->ptr) {\n\t\ts->available += p->size * sizeof(header_t);\n\t\tif (p->size != 0) ++s->n_blocks; /* &kmem_t::base is always one of the cores. It is zero-sized. */\n\t\tif (p->ptr > p && p + p->size > p->ptr)\n\t\t\tpanic(\"[km_stat] The end of a free block enters another free block.\");\n\t\tif (p->ptr == km->loop_head) break;\n\t}\n\tfor (p = km->core_head; p != NULL; p = p->ptr) {\n\t\tsize_t size = p->size * sizeof(header_t);\n\t\t++s->n_cores;\n\t\ts->capacity += size;\n\t\ts->largest = s->largest > size? s->largest : size;\n\t}\n}\n\nvoid km_stat_print(const void *km)\n{\n\tkm_stat_t st;\n\tkm_stat(km, &st);\n\tfprintf(stderr, \"[km_stat] cap=%ld, avail=%ld, largest=%ld, n_core=%ld, n_block=%ld\\n\",\n\t\t\tst.capacity, st.available, st.largest, st.n_blocks, st.n_cores);\n}\n"
        },
        {
          "name": "kalloc.h",
          "type": "blob",
          "size": 2.568359375,
          "content": "#ifndef _KALLOC_H_\n#define _KALLOC_H_\n\n#include <stddef.h> /* for size_t */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\tsize_t capacity, available, n_blocks, n_cores, largest;\n} km_stat_t;\n\nvoid *kmalloc(void *km, size_t size);\nvoid *krealloc(void *km, void *ptr, size_t size);\nvoid *krelocate(void *km, void *ap, size_t n_bytes);\nvoid *kcalloc(void *km, size_t count, size_t size);\nvoid kfree(void *km, void *ptr);\n\nvoid *km_init(void);\nvoid *km_init2(void *km_par, size_t min_core_size);\nvoid km_destroy(void *km);\nvoid km_stat(const void *_km, km_stat_t *s);\nvoid km_stat_print(const void *km);\n\n#ifdef __cplusplus\n}\n#endif\n\n#define Kmalloc(km, type, cnt)       ((type*)kmalloc((km), (cnt) * sizeof(type)))\n#define Kcalloc(km, type, cnt)       ((type*)kcalloc((km), (cnt), sizeof(type)))\n#define Krealloc(km, type, ptr, cnt) ((type*)krealloc((km), (ptr), (cnt) * sizeof(type)))\n\n#define Kexpand(km, type, a, m) do { \\\n\t\t(m) = (m) >= 4? (m) + ((m)>>1) : 16; \\\n\t\t(a) = Krealloc(km, type, (a), (m)); \\\n\t} while (0)\n\n#define KMALLOC(km, ptr, len) ((ptr) = (__typeof__(ptr))kmalloc((km), (len) * sizeof(*(ptr))))\n#define KCALLOC(km, ptr, len) ((ptr) = (__typeof__(ptr))kcalloc((km), (len), sizeof(*(ptr))))\n#define KREALLOC(km, ptr, len) ((ptr) = (__typeof__(ptr))krealloc((km), (ptr), (len) * sizeof(*(ptr))))\n\n#define KEXPAND(km, a, m) do { \\\n\t\t(m) = (m) >= 4? (m) + ((m)>>1) : 16; \\\n\t\tKREALLOC((km), (a), (m)); \\\n\t} while (0)\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define KALLOC_POOL_INIT2(SCOPE, name, kmptype_t) \\\n\ttypedef struct { \\\n\t\tsize_t cnt, n, max; \\\n\t\tkmptype_t **buf; \\\n\t\tvoid *km; \\\n\t} kmp_##name##_t; \\\n\tSCOPE kmp_##name##_t *kmp_init_##name(void *km) { \\\n\t\tkmp_##name##_t *mp; \\\n\t\tmp = Kcalloc(km, kmp_##name##_t, 1); \\\n\t\tmp->km = km; \\\n\t\treturn mp; \\\n\t} \\\n\tSCOPE void kmp_destroy_##name(kmp_##name##_t *mp) { \\\n\t\tsize_t k; \\\n\t\tfor (k = 0; k < mp->n; ++k) kfree(mp->km, mp->buf[k]); \\\n\t\tkfree(mp->km, mp->buf); kfree(mp->km, mp); \\\n\t} \\\n\tSCOPE kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) { \\\n\t\t++mp->cnt; \\\n\t\tif (mp->n == 0) return (kmptype_t*)kcalloc(mp->km, 1, sizeof(kmptype_t)); \\\n\t\treturn mp->buf[--mp->n]; \\\n\t} \\\n\tSCOPE void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \\\n\t\t--mp->cnt; \\\n\t\tif (mp->n == mp->max) Kexpand(mp->km, kmptype_t*, mp->buf, mp->max); \\\n\t\tmp->buf[mp->n++] = p; \\\n\t}\n\n#define KALLOC_POOL_INIT(name, kmptype_t) \\\n\tKALLOC_POOL_INIT2(static inline klib_unused, name, kmptype_t)\n\n#endif\n"
        },
        {
          "name": "kavl-lite.h",
          "type": "blob",
          "size": 9.6279296875,
          "content": "/* The MIT License\n\n   Copyright (c) 2021 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* An example:\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"kavl-lite.h\"\n\nstruct my_node {\n  char key;\n  KAVLL_HEAD(struct my_node) head;\n};\n#define my_cmp(p, q) (((q)->key < (p)->key) - ((p)->key < (q)->key))\nKAVLL_INIT(my, struct my_node, head, my_cmp)\n\nint main(void) {\n  const char *str = \"MNOLKQOPHIA\"; // from wiki, except a duplicate\n  struct my_node *root = 0;\n  int i, l = strlen(str);\n  for (i = 0; i < l; ++i) {        // insert in the input order\n    struct my_node *q, *p = malloc(sizeof(*p));\n    p->key = str[i];\n    q = my_insert(&root, p);\n    if (p != q) free(p);           // if already present, free\n  }\n  my_itr_t itr;\n  my_itr_first(root, &itr);  // place at first\n  do {                             // traverse\n    const struct my_node *p = kavll_at(&itr);\n    putchar(p->key);\n    free((void*)p);                // free node\n  } while (my_itr_next(&itr));\n  putchar('\\n');\n  return 0;\n}\n*/\n\n#ifndef KAVL_LITE_H\n#define KAVL_LITE_H\n\n#ifdef __STRICT_ANSI__\n#define inline __inline__\n#endif\n\n#define KAVLL_MAX_DEPTH 64\n\n#define KAVLL_HEAD(__type) \\\n\tstruct { \\\n\t\t__type *p[2]; \\\n\t\tsigned char balance; /* balance factor */ \\\n\t}\n\n#define __KAVLL_FIND(pre, __scope, __type, __head,  __cmp) \\\n\t__scope __type *pre##_find(const __type *root, const __type *x) { \\\n\t\tconst __type *p = root; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\treturn (__type*)p; \\\n\t}\n\n#define __KAVLL_ROTATE(pre, __type, __head) \\\n\t/* one rotation: (a,(b,c)q)p => ((a,b)p,c)q */ \\\n\tstatic inline __type *pre##_rotate1(__type *p, int dir) { /* dir=0 to left; dir=1 to right */ \\\n\t\tint opp = 1 - dir; /* opposite direction */ \\\n\t\t__type *q = p->__head.p[opp]; \\\n\t\tp->__head.p[opp] = q->__head.p[dir]; \\\n\t\tq->__head.p[dir] = p; \\\n\t\treturn q; \\\n\t} \\\n\t/* two consecutive rotations: (a,((b,c)r,d)q)p => ((a,b)p,(c,d)q)r */ \\\n\tstatic inline __type *pre##_rotate2(__type *p, int dir) { \\\n\t\tint b1, opp = 1 - dir; \\\n\t\t__type *q = p->__head.p[opp], *r = q->__head.p[dir]; \\\n\t\tp->__head.p[opp] = r->__head.p[dir]; \\\n\t\tr->__head.p[dir] = p; \\\n\t\tq->__head.p[dir] = r->__head.p[opp]; \\\n\t\tr->__head.p[opp] = q; \\\n\t\tb1 = dir == 0? +1 : -1; \\\n\t\tif (r->__head.balance == b1) q->__head.balance = 0, p->__head.balance = -b1; \\\n\t\telse if (r->__head.balance == 0) q->__head.balance = p->__head.balance = 0; \\\n\t\telse q->__head.balance = b1, p->__head.balance = 0; \\\n\t\tr->__head.balance = 0; \\\n\t\treturn r; \\\n\t}\n\n#define __KAVLL_INSERT(pre, __scope, __type, __head, __cmp) \\\n\t__scope __type *pre##_insert(__type **root_, __type *x) { \\\n\t\tunsigned char stack[KAVLL_MAX_DEPTH]; \\\n\t\t__type *path[KAVLL_MAX_DEPTH]; \\\n\t\t__type *bp, *bq; \\\n\t\t__type *p, *q, *r = 0; /* _r_ is potentially the new root */ \\\n\t\tint which = 0, top, b1, path_len; \\\n\t\tbp = *root_, bq = 0; \\\n\t\t/* find the insertion location */ \\\n\t\tfor (p = bp, q = bq, top = path_len = 0; p; q = p, p = p->__head.p[which]) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp == 0) return p; \\\n\t\t\tif (p->__head.balance != 0) \\\n\t\t\t\tbq = q, bp = p, top = 0; \\\n\t\t\tstack[top++] = which = (cmp > 0); \\\n\t\t\tpath[path_len++] = p; \\\n\t\t} \\\n\t\tx->__head.balance = 0, x->__head.p[0] = x->__head.p[1] = 0; \\\n\t\tif (q == 0) *root_ = x; \\\n\t\telse q->__head.p[which] = x; \\\n\t\tif (bp == 0) return x; \\\n\t\tfor (p = bp, top = 0; p != x; p = p->__head.p[stack[top]], ++top) /* update balance factors */ \\\n\t\t\tif (stack[top] == 0) --p->__head.balance; \\\n\t\t\telse ++p->__head.balance; \\\n\t\tif (bp->__head.balance > -2 && bp->__head.balance < 2) return x; /* no re-balance needed */ \\\n\t\t/* re-balance */ \\\n\t\twhich = (bp->__head.balance < 0); \\\n\t\tb1 = which == 0? +1 : -1; \\\n\t\tq = bp->__head.p[1 - which]; \\\n\t\tif (q->__head.balance == b1) { \\\n\t\t\tr = pre##_rotate1(bp, which); \\\n\t\t\tq->__head.balance = bp->__head.balance = 0; \\\n\t\t} else r = pre##_rotate2(bp, which); \\\n\t\tif (bq == 0) *root_ = r; \\\n\t\telse bq->__head.p[bp != bq->__head.p[0]] = r; \\\n\t\treturn x; \\\n\t}\n\n#define __KAVLL_ERASE(pre, __scope, __type, __head, __cmp) \\\n\t__scope __type *pre##_erase(__type **root_, const __type *x) { \\\n\t\t__type *p, *path[KAVLL_MAX_DEPTH], fake; \\\n\t\tunsigned char dir[KAVLL_MAX_DEPTH]; \\\n\t\tint d = 0, cmp; \\\n\t\tfake.__head.p[0] = *root_, fake.__head.p[1] = 0; \\\n\t\tif (x) { \\\n\t\t\tfor (cmp = -1, p = &fake; cmp; cmp = __cmp(x, p)) { \\\n\t\t\t\tint which = (cmp > 0); \\\n\t\t\t\tdir[d] = which; \\\n\t\t\t\tpath[d++] = p; \\\n\t\t\t\tp = p->__head.p[which]; \\\n\t\t\t\tif (p == 0) return 0; \\\n\t\t\t} \\\n\t\t} else { \\\n\t\t\tfor (p = &fake; p; p = p->__head.p[0]) \\\n\t\t\t\tdir[d] = 0, path[d++] = p; \\\n\t\t\tp = path[--d]; \\\n\t\t} \\\n\t\tif (p->__head.p[1] == 0) { /* ((1,.)2,3)4 => (1,3)4; p=2 */ \\\n\t\t\tpath[d-1]->__head.p[dir[d-1]] = p->__head.p[0]; \\\n\t\t} else { \\\n\t\t\t__type *q = p->__head.p[1]; \\\n\t\t\tif (q->__head.p[0] == 0) { /* ((1,2)3,4)5 => ((1)2,4)5; p=3 */ \\\n\t\t\t\tq->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = q; \\\n\t\t\t\tpath[d] = q, dir[d++] = 1; \\\n\t\t\t} else { /* ((1,((.,2)3,4)5)6,7)8 => ((1,(2,4)5)3,7)8; p=6 */ \\\n\t\t\t\t__type *r; \\\n\t\t\t\tint e = d++; /* backup _d_ */\\\n\t\t\t\tfor (;;) { \\\n\t\t\t\t\tdir[d] = 0; \\\n\t\t\t\t\tpath[d++] = q; \\\n\t\t\t\t\tr = q->__head.p[0]; \\\n\t\t\t\t\tif (r->__head.p[0] == 0) break; \\\n\t\t\t\t\tq = r; \\\n\t\t\t\t} \\\n\t\t\t\tr->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.p[0] = r->__head.p[1]; \\\n\t\t\t\tr->__head.p[1] = p->__head.p[1]; \\\n\t\t\t\tr->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[e-1]->__head.p[dir[e-1]] = r; \\\n\t\t\t\tpath[e] = r, dir[e] = 1; \\\n\t\t\t} \\\n\t\t} \\\n\t\twhile (--d > 0) { \\\n\t\t\t__type *q = path[d]; \\\n\t\t\tint which, other, b1 = 1, b2 = 2; \\\n\t\t\twhich = dir[d], other = 1 - which; \\\n\t\t\tif (which) b1 = -b1, b2 = -b2; \\\n\t\t\tq->__head.balance += b1; \\\n\t\t\tif (q->__head.balance == b1) break; \\\n\t\t\telse if (q->__head.balance == b2) { \\\n\t\t\t\t__type *r = q->__head.p[other]; \\\n\t\t\t\tif (r->__head.balance == -b1) { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = pre##_rotate2(q, which); \\\n\t\t\t\t} else { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = pre##_rotate1(q, which); \\\n\t\t\t\t\tif (r->__head.balance == 0) { \\\n\t\t\t\t\t\tr->__head.balance = -b1; \\\n\t\t\t\t\t\tq->__head.balance = b1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t} else r->__head.balance = q->__head.balance = 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\t*root_ = fake.__head.p[0]; \\\n\t\treturn p; \\\n\t}\n\n#define kavll_free(__type, __head, __root, __free) do { \\\n\t\t__type *_p, *_q; \\\n\t\tfor (_p = __root; _p; _p = _q) { \\\n\t\t\tif (_p->__head.p[0] == 0) { \\\n\t\t\t\t_q = _p->__head.p[1]; \\\n\t\t\t\t__free(_p); \\\n\t\t\t} else { \\\n\t\t\t\t_q = _p->__head.p[0]; \\\n\t\t\t\t_p->__head.p[0] = _q->__head.p[1]; \\\n\t\t\t\t_q->__head.p[1] = _p; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define kavll_size(__type, __head, __root, __cnt) do { \\\n\t\t__type *_p, *_q; \\\n\t\t*(__cnt) = 0; \\\n\t\tfor (_p = __root; _p; _p = _q) { \\\n\t\t\tif (_p->__head.p[0] == 0) { \\\n\t\t\t\t_q = _p->__head.p[1]; \\\n\t\t\t\t++*(__cnt); \\\n\t\t\t} else { \\\n\t\t\t\t_q = _p->__head.p[0]; \\\n\t\t\t\t_p->__head.p[0] = _q->__head.p[1]; \\\n\t\t\t\t_q->__head.p[1] = _p; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define __KAVLL_ITR(pre, __scope, __type, __head, __cmp) \\\n\ttypedef struct pre##_itr_t { \\\n\t\tconst __type *stack[KAVLL_MAX_DEPTH], **top, *right; /* _right_ points to the right child of *top */ \\\n\t} pre##_itr_t; \\\n\t__scope void pre##_itr_first(const __type *root, struct pre##_itr_t *itr) { \\\n\t\tconst __type *p; \\\n\t\tfor (itr->top = itr->stack - 1, p = root; p; p = p->__head.p[0]) \\\n\t\t\t*++itr->top = p; \\\n\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t} \\\n\t__scope int pre##_itr_find(const __type *root, const __type *x, struct pre##_itr_t *itr) { \\\n\t\tconst __type *p = root; \\\n\t\titr->top = itr->stack - 1; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) *++itr->top = p, p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (p) { \\\n\t\t\t*++itr->top = p; \\\n\t\t\titr->right = p->__head.p[1]; \\\n\t\t\treturn 1; \\\n\t\t} else if (itr->top >= itr->stack) { \\\n\t\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t\t\treturn 0; \\\n\t\t} else return 0; \\\n\t} \\\n\t__scope int pre##_itr_next(struct pre##_itr_t *itr) { \\\n\t\tfor (;;) { \\\n\t\t\tconst __type *p; \\\n\t\t\tfor (p = itr->right, --itr->top; p; p = p->__head.p[0]) \\\n\t\t\t\t*++itr->top = p; \\\n\t\t\tif (itr->top < itr->stack) return 0; \\\n\t\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t\t\treturn 1; \\\n\t\t} \\\n\t}\n\n#define kavll_at(itr) ((itr)->top < (itr)->stack? 0 : *(itr)->top)\n\n#define KAVLL_INIT2(pre, __scope, __type, __head, __cmp) \\\n\t__KAVLL_FIND(pre, __scope, __type, __head,  __cmp) \\\n\t__KAVLL_ROTATE(pre, __type, __head) \\\n\t__KAVLL_INSERT(pre, __scope, __type, __head, __cmp) \\\n\t__KAVLL_ERASE(pre, __scope, __type, __head, __cmp) \\\n\t__KAVLL_ITR(pre, __scope, __type, __head, __cmp)\n\n#define KAVLL_INIT(pre, __type, __head, __cmp) \\\n\tKAVLL_INIT2(pre,, __type, __head, __cmp)\n\n#endif\n"
        },
        {
          "name": "kavl.h",
          "type": "blob",
          "size": 12.9189453125,
          "content": "/* The MIT License\n\n   Copyright (c) 2018 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* An example:\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"kavl.h\"\n\nstruct my_node {\n  char key;\n  KAVL_HEAD(struct my_node) head;\n};\n#define my_cmp(p, q) (((q)->key < (p)->key) - ((p)->key < (q)->key))\nKAVL_INIT(my, struct my_node, head, my_cmp)\n\nint main(void) {\n  const char *str = \"MNOLKQOPHIA\"; // from wiki, except a duplicate\n  struct my_node *root = 0;\n  int i, l = strlen(str);\n  for (i = 0; i < l; ++i) {        // insert in the input order\n    struct my_node *q, *p = malloc(sizeof(*p));\n    p->key = str[i];\n    q = kavl_insert(my, &root, p, 0);\n    if (p != q) free(p);           // if already present, free\n  }\n  kavl_itr_t(my) itr;\n  kavl_itr_first(my, root, &itr);  // place at first\n  do {                             // traverse\n    const struct my_node *p = kavl_at(&itr);\n    putchar(p->key);\n    free((void*)p);                // free node\n  } while (kavl_itr_next(my, &itr));\n  putchar('\\n');\n  return 0;\n}\n*/\n\n#ifndef KAVL_H\n#define KAVL_H\n\n#ifdef __STRICT_ANSI__\n#define inline __inline__\n#endif\n\n#define KAVL_MAX_DEPTH 64\n\n#define kavl_size(head, p) ((p)? (p)->head.size : 0)\n#define kavl_size_child(head, q, i) ((q)->head.p[(i)]? (q)->head.p[(i)]->head.size : 0)\n\n#define KAVL_HEAD(__type) \\\n\tstruct { \\\n\t\t__type *p[2]; \\\n\t\tsigned char balance; /* balance factor */ \\\n\t\tunsigned size; /* #elements in subtree */ \\\n\t}\n\n#define __KAVL_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__scope __type *kavl_find_##suf(const __type *root, const __type *x, unsigned *cnt_) { \\\n\t\tconst __type *p = root; \\\n\t\tunsigned cnt = 0; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += kavl_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\treturn (__type*)p; \\\n\t}\n\n#define __KAVL_ROTATE(suf, __type, __head) \\\n\t/* one rotation: (a,(b,c)q)p => ((a,b)p,c)q */ \\\n\tstatic inline __type *kavl_rotate1_##suf(__type *p, int dir) { /* dir=0 to left; dir=1 to right */ \\\n\t\tint opp = 1 - dir; /* opposite direction */ \\\n\t\t__type *q = p->__head.p[opp]; \\\n\t\tunsigned size_p = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - kavl_size_child(__head, q, dir); \\\n\t\tq->__head.size = size_p; \\\n\t\tp->__head.p[opp] = q->__head.p[dir]; \\\n\t\tq->__head.p[dir] = p; \\\n\t\treturn q; \\\n\t} \\\n\t/* two consecutive rotations: (a,((b,c)r,d)q)p => ((a,b)p,(c,d)q)r */ \\\n\tstatic inline __type *kavl_rotate2_##suf(__type *p, int dir) { \\\n\t\tint b1, opp = 1 - dir; \\\n\t\t__type *q = p->__head.p[opp], *r = q->__head.p[dir]; \\\n\t\tunsigned size_x_dir = kavl_size_child(__head, r, dir); \\\n\t\tr->__head.size = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - size_x_dir; \\\n\t\tq->__head.size -= size_x_dir + 1; \\\n\t\tp->__head.p[opp] = r->__head.p[dir]; \\\n\t\tr->__head.p[dir] = p; \\\n\t\tq->__head.p[dir] = r->__head.p[opp]; \\\n\t\tr->__head.p[opp] = q; \\\n\t\tb1 = dir == 0? +1 : -1; \\\n\t\tif (r->__head.balance == b1) q->__head.balance = 0, p->__head.balance = -b1; \\\n\t\telse if (r->__head.balance == 0) q->__head.balance = p->__head.balance = 0; \\\n\t\telse q->__head.balance = b1, p->__head.balance = 0; \\\n\t\tr->__head.balance = 0; \\\n\t\treturn r; \\\n\t}\n\n#define __KAVL_INSERT(suf, __scope, __type, __head, __cmp) \\\n\t__scope __type *kavl_insert_##suf(__type **root_, __type *x, unsigned *cnt_) { \\\n\t\tunsigned char stack[KAVL_MAX_DEPTH]; \\\n\t\t__type *path[KAVL_MAX_DEPTH]; \\\n\t\t__type *bp, *bq; \\\n\t\t__type *p, *q, *r = 0; /* _r_ is potentially the new root */ \\\n\t\tint i, which = 0, top, b1, path_len; \\\n\t\tunsigned cnt = 0; \\\n\t\tbp = *root_, bq = 0; \\\n\t\t/* find the insertion location */ \\\n\t\tfor (p = bp, q = bq, top = path_len = 0; p; q = p, p = p->__head.p[which]) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += kavl_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp == 0) { \\\n\t\t\t\tif (cnt_) *cnt_ = cnt; \\\n\t\t\t\treturn p; \\\n\t\t\t} \\\n\t\t\tif (p->__head.balance != 0) \\\n\t\t\t\tbq = q, bp = p, top = 0; \\\n\t\t\tstack[top++] = which = (cmp > 0); \\\n\t\t\tpath[path_len++] = p; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tx->__head.balance = 0, x->__head.size = 1, x->__head.p[0] = x->__head.p[1] = 0; \\\n\t\tif (q == 0) *root_ = x; \\\n\t\telse q->__head.p[which] = x; \\\n\t\tif (bp == 0) return x; \\\n\t\tfor (i = 0; i < path_len; ++i) ++path[i]->__head.size; \\\n\t\tfor (p = bp, top = 0; p != x; p = p->__head.p[stack[top]], ++top) /* update balance factors */ \\\n\t\t\tif (stack[top] == 0) --p->__head.balance; \\\n\t\t\telse ++p->__head.balance; \\\n\t\tif (bp->__head.balance > -2 && bp->__head.balance < 2) return x; /* no re-balance needed */ \\\n\t\t/* re-balance */ \\\n\t\twhich = (bp->__head.balance < 0); \\\n\t\tb1 = which == 0? +1 : -1; \\\n\t\tq = bp->__head.p[1 - which]; \\\n\t\tif (q->__head.balance == b1) { \\\n\t\t\tr = kavl_rotate1_##suf(bp, which); \\\n\t\t\tq->__head.balance = bp->__head.balance = 0; \\\n\t\t} else r = kavl_rotate2_##suf(bp, which); \\\n\t\tif (bq == 0) *root_ = r; \\\n\t\telse bq->__head.p[bp != bq->__head.p[0]] = r; \\\n\t\treturn x; \\\n\t}\n\n#define __KAVL_ERASE(suf, __scope, __type, __head, __cmp) \\\n\t__scope __type *kavl_erase_##suf(__type **root_, const __type *x, unsigned *cnt_) { \\\n\t\t__type *p, *path[KAVL_MAX_DEPTH], fake; \\\n\t\tunsigned char dir[KAVL_MAX_DEPTH]; \\\n\t\tint i, d = 0, cmp; \\\n\t\tunsigned cnt = 0; \\\n\t\tfake.__head.p[0] = *root_, fake.__head.p[1] = 0; \\\n\t\tif (cnt_) *cnt_ = 0; \\\n\t\tif (x) { \\\n\t\t\tfor (cmp = -1, p = &fake; cmp; cmp = __cmp(x, p)) { \\\n\t\t\t\tint which = (cmp > 0); \\\n\t\t\t\tif (cmp > 0) cnt += kavl_size_child(__head, p, 0) + 1; \\\n\t\t\t\tdir[d] = which; \\\n\t\t\t\tpath[d++] = p; \\\n\t\t\t\tp = p->__head.p[which]; \\\n\t\t\t\tif (p == 0) { \\\n\t\t\t\t\tif (cnt_) *cnt_ = 0; \\\n\t\t\t\t\treturn 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t\tcnt += kavl_size_child(__head, p, 0) + 1; /* because p==x is not counted */ \\\n\t\t} else { \\\n\t\t\tfor (p = &fake, cnt = 1; p; p = p->__head.p[0]) \\\n\t\t\t\tdir[d] = 0, path[d++] = p; \\\n\t\t\tp = path[--d]; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tfor (i = 1; i < d; ++i) --path[i]->__head.size; \\\n\t\tif (p->__head.p[1] == 0) { /* ((1,.)2,3)4 => (1,3)4; p=2 */ \\\n\t\t\tpath[d-1]->__head.p[dir[d-1]] = p->__head.p[0]; \\\n\t\t} else { \\\n\t\t\t__type *q = p->__head.p[1]; \\\n\t\t\tif (q->__head.p[0] == 0) { /* ((1,2)3,4)5 => ((1)2,4)5; p=3 */ \\\n\t\t\t\tq->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = q; \\\n\t\t\t\tpath[d] = q, dir[d++] = 1; \\\n\t\t\t\tq->__head.size = p->__head.size - 1; \\\n\t\t\t} else { /* ((1,((.,2)3,4)5)6,7)8 => ((1,(2,4)5)3,7)8; p=6 */ \\\n\t\t\t\t__type *r; \\\n\t\t\t\tint e = d++; /* backup _d_ */\\\n\t\t\t\tfor (;;) { \\\n\t\t\t\t\tdir[d] = 0; \\\n\t\t\t\t\tpath[d++] = q; \\\n\t\t\t\t\tr = q->__head.p[0]; \\\n\t\t\t\t\tif (r->__head.p[0] == 0) break; \\\n\t\t\t\t\tq = r; \\\n\t\t\t\t} \\\n\t\t\t\tr->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.p[0] = r->__head.p[1]; \\\n\t\t\t\tr->__head.p[1] = p->__head.p[1]; \\\n\t\t\t\tr->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[e-1]->__head.p[dir[e-1]] = r; \\\n\t\t\t\tpath[e] = r, dir[e] = 1; \\\n\t\t\t\tfor (i = e + 1; i < d; ++i) --path[i]->__head.size; \\\n\t\t\t\tr->__head.size = p->__head.size - 1; \\\n\t\t\t} \\\n\t\t} \\\n\t\twhile (--d > 0) { \\\n\t\t\t__type *q = path[d]; \\\n\t\t\tint which, other, b1 = 1, b2 = 2; \\\n\t\t\twhich = dir[d], other = 1 - which; \\\n\t\t\tif (which) b1 = -b1, b2 = -b2; \\\n\t\t\tq->__head.balance += b1; \\\n\t\t\tif (q->__head.balance == b1) break; \\\n\t\t\telse if (q->__head.balance == b2) { \\\n\t\t\t\t__type *r = q->__head.p[other]; \\\n\t\t\t\tif (r->__head.balance == -b1) { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = kavl_rotate2_##suf(q, which); \\\n\t\t\t\t} else { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = kavl_rotate1_##suf(q, which); \\\n\t\t\t\t\tif (r->__head.balance == 0) { \\\n\t\t\t\t\t\tr->__head.balance = -b1; \\\n\t\t\t\t\t\tq->__head.balance = b1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t} else r->__head.balance = q->__head.balance = 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\t*root_ = fake.__head.p[0]; \\\n\t\treturn p; \\\n\t}\n\n#define kavl_free(__type, __head, __root, __free) do { \\\n\t\t__type *_p, *_q; \\\n\t\tfor (_p = __root; _p; _p = _q) { \\\n\t\t\tif (_p->__head.p[0] == 0) { \\\n\t\t\t\t_q = _p->__head.p[1]; \\\n\t\t\t\t__free(_p); \\\n\t\t\t} else { \\\n\t\t\t\t_q = _p->__head.p[0]; \\\n\t\t\t\t_p->__head.p[0] = _q->__head.p[1]; \\\n\t\t\t\t_q->__head.p[1] = _p; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define __KAVL_ITR(suf, __scope, __type, __head, __cmp) \\\n\tstruct kavl_itr_##suf { \\\n\t\tconst __type *stack[KAVL_MAX_DEPTH], **top, *right; /* _right_ points to the right child of *top */ \\\n\t}; \\\n\t__scope void kavl_itr_first_##suf(const __type *root, struct kavl_itr_##suf *itr) { \\\n\t\tconst __type *p; \\\n\t\tfor (itr->top = itr->stack - 1, p = root; p; p = p->__head.p[0]) \\\n\t\t\t*++itr->top = p; \\\n\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t} \\\n\t__scope int kavl_itr_find_##suf(const __type *root, const __type *x, struct kavl_itr_##suf *itr) { \\\n\t\tconst __type *p = root; \\\n\t\titr->top = itr->stack - 1; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) *++itr->top = p, p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (p) { \\\n\t\t\t*++itr->top = p; \\\n\t\t\titr->right = p->__head.p[1]; \\\n\t\t\treturn 1; \\\n\t\t} else if (itr->top >= itr->stack) { \\\n\t\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t\t\treturn 0; \\\n\t\t} else return 0; \\\n\t} \\\n\t__scope int kavl_itr_next_##suf(struct kavl_itr_##suf *itr) { \\\n\t\tfor (;;) { \\\n\t\t\tconst __type *p; \\\n\t\t\tfor (p = itr->right, --itr->top; p; p = p->__head.p[0]) \\\n\t\t\t\t*++itr->top = p; \\\n\t\t\tif (itr->top < itr->stack) return 0; \\\n\t\t\titr->right = (*itr->top)->__head.p[1]; \\\n\t\t\treturn 1; \\\n\t\t} \\\n\t}\n\n/**\n * Insert a node to the tree\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node to insert (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return _x_ if not present in the tree, or the node equal to x.\n */\n#define kavl_insert(suf, proot, x, cnt) kavl_insert_##suf(proot, x, cnt)\n\n/**\n * Find a node in the tree\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param root    root of the tree\n * @param x       node value to find (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return node equal to _x_ if present, or NULL if absent\n */\n#define kavl_find(suf, root, x, cnt) kavl_find_##suf(root, x, cnt)\n\n/**\n * Delete a node from the tree\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node value to delete; if NULL, delete the first node (in)\n *\n * @return node removed from the tree if present, or NULL if absent\n */\n#define kavl_erase(suf, proot, x, cnt) kavl_erase_##suf(proot, x, cnt)\n#define kavl_erase_first(suf, proot) kavl_erase_##suf(proot, 0, 0)\n\n#define kavl_itr_t(suf) struct kavl_itr_##suf\n\n/**\n * Place the iterator at the smallest object\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param root    root of the tree\n * @param itr     iterator\n */\n#define kavl_itr_first(suf, root, itr) kavl_itr_first_##suf(root, itr)\n\n/**\n * Place the iterator at the object equal to or greater than the query\n *\n * @param suf     name suffix used in KAVL_INIT()\n * @param root    root of the tree\n * @param x       query (in)\n * @param itr     iterator (out)\n *\n * @return 1 if find; 0 otherwise. kavl_at(itr) is NULL if and only if query is\n *         larger than all objects in the tree\n */\n#define kavl_itr_find(suf, root, x, itr) kavl_itr_find_##suf(root, x, itr)\n\n/**\n * Move to the next object in order\n *\n * @param itr     iterator (modified)\n *\n * @return 1 if there is a next object; 0 otherwise\n */\n#define kavl_itr_next(suf, itr) kavl_itr_next_##suf(itr)\n\n/**\n * Return the pointer at the iterator\n *\n * @param itr     iterator\n *\n * @return pointer if present; NULL otherwise\n */\n#define kavl_at(itr) ((itr)->top < (itr)->stack? 0 : *(itr)->top)\n\n#define KAVL_INIT2(suf, __scope, __type, __head, __cmp) \\\n\t__KAVL_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__KAVL_ROTATE(suf, __type, __head) \\\n\t__KAVL_INSERT(suf, __scope, __type, __head, __cmp) \\\n\t__KAVL_ERASE(suf, __scope, __type, __head, __cmp) \\\n\t__KAVL_ITR(suf, __scope, __type, __head, __cmp)\n\n#define KAVL_INIT(suf, __type, __head, __cmp) \\\n\tKAVL_INIT2(suf,, __type, __head, __cmp)\n\n#endif\n"
        },
        {
          "name": "kbit.h",
          "type": "blob",
          "size": 1.0615234375,
          "content": "#ifndef KBIT_H\n#define KBIT_H\n\n#include <stdint.h>\n\nstatic inline uint64_t kbi_popcount64(uint64_t y) // standard popcount; from wikipedia\n{\n\ty -= ((y >> 1) & 0x5555555555555555ull);\n\ty = (y & 0x3333333333333333ull) + (y >> 2 & 0x3333333333333333ull);\n\treturn ((y + (y >> 4)) & 0xf0f0f0f0f0f0f0full) * 0x101010101010101ull >> 56;\n}\n\nstatic inline uint64_t kbi_DNAcount64(uint64_t y, int c) // count #A/C/G/T from a 2-bit encoded integer; from BWA\n{\n\t// reduce nucleotide counting to bits counting\n\ty = ((c&2)? y : ~y) >> 1 & ((c&1)? y : ~y) & 0x5555555555555555ull;\n\t// count the number of 1s in y\n\ty = (y & 0x3333333333333333ull) + (y >> 2 & 0x3333333333333333ull);\n\treturn ((y + (y >> 4)) & 0xf0f0f0f0f0f0f0full) * 0x101010101010101ull >> 56;\n}\n\n#ifndef kroundup32 // round a 32-bit integer to the next closet integer; from \"bit twiddling hacks\"\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#ifndef kbi_swap\n#define kbi_swap(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b))) // from \"bit twiddling hacks\"\n#endif\n\n#endif\n"
        },
        {
          "name": "kbtree.h",
          "type": "blob",
          "size": 16.80859375,
          "content": "/*-\n * Copyright 1997-1999, 2001, John-Mark Gurney.\n *           2008-2009, Attractive Chaos <attractor@live.co.uk>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef __AC_KBTREE_H\n#define __AC_KBTREE_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n#define KB_MAX_DEPTH 64\n\ntypedef struct {\n\tint32_t is_internal:1, n:31;\n} kbnode_t;\n\ntypedef struct {\n\tkbnode_t *x;\n\tint i;\n} kbpos_t;\n\ntypedef struct {\n\tkbpos_t stack[KB_MAX_DEPTH], *p;\n} kbitr_t;\n\n#define\t__KB_KEY(type, x)\t((type*)((char*)x + 4))\n#define __KB_PTR(btr, x)\t((kbnode_t**)((char*)x + btr->off_ptr))\n\n#define __KB_TREE_T(name)\t\t\t\t\t\t\\\n\ttypedef struct {\t\t\t\t\t\t\t\\\n\t\tkbnode_t *root;\t\t\t\t\t\t\t\\\n\t\tint\toff_key, off_ptr, ilen, elen;\t\t\\\n\t\tint\tn, t;\t\t\t\t\t\t\t\t\\\n\t\tint\tn_keys, n_nodes;\t\t\t\t\t\\\n\t} kbtree_##name##_t;\n\n#define __KB_INIT(name, key_t)\t\t\t\t\t\t\t\t\t\t\t\\\n\tkbtree_##name##_t *kb_init_##name(int size)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbtree_##name##_t *b;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tb = (kbtree_##name##_t*)calloc(1, sizeof(kbtree_##name##_t));\t\\\n\t\tb->t = ((size - 4 - sizeof(void*)) / (sizeof(void*) + sizeof(key_t)) + 1) >> 1; \\\n\t\tif (b->t < 2) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfree(b); return 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tb->n = 2 * b->t - 1;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tb->off_ptr = 4 + b->n * sizeof(key_t);\t\t\t\t\t\t\t\\\n\t\tb->ilen = (4 + sizeof(void*) + b->n * (sizeof(void*) + sizeof(key_t)) + 3) >> 2 << 2; \\\n\t\tb->elen = (b->off_ptr + 3) >> 2 << 2;\t\t\t\t\t\t\t\\\n\t\tb->root = (kbnode_t*)calloc(1, b->ilen);\t\t\t\t\t\t\\\n\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn b;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __kb_destroy(b) do {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, max = 8;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x, **top, **stack = 0;\t\t\t\t\t\t\t\t\\\n\t\tif (b) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttop = stack = (kbnode_t**)calloc(max, sizeof(kbnode_t*));\t\\\n\t\t\t*top++ = (b)->root;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\twhile (top != stack) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tx = *--top;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (x->is_internal == 0) { free(x); continue; }\t\t\t\\\n\t\t\t\tfor (i = 0; i <= x->n; ++i)\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__KB_PTR(b, x)[i]) {\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tif (top - stack == max) {\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tmax <<= 1;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tstack = (kbnode_t**)realloc(stack, max * sizeof(kbnode_t*)); \\\n\t\t\t\t\t\t\ttop = stack + (max>>1);\t\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t*top++ = __KB_PTR(b, x)[i];\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(x);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(b); free(stack);\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __KB_GET_AUX1(name, key_t, __cmp)\t\t\t\t\t\t\t\t\\\n\tstatic inline int __kb_getp_aux_##name(const kbnode_t * __restrict x, const key_t * __restrict k, int *r) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint tr, *rr, begin = 0, end = x->n;\t\t\t\t\t\t\t\t\\\n\t\tif (x->n == 0) return -1;\t\t\t\t\t\t\t\t\t\t\\\n\t\trr = r? r : &tr;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (begin < end) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tint mid = (begin + end) >> 1;\t\t\t\t\t\t\t\t\\\n\t\t\tif (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\\n\t\t\telse end = mid;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (begin == x->n) { *rr = 1; return x->n - 1; }\t\t\t\t\\\n\t\tif ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin;\t\\\n\t\treturn begin;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KB_GET(name, key_t)\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t *kb_getp_##name(kbtree_##name##_t *b, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\\n\t\t\tif (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i];\t\t\\\n\t\t\tif (x->is_internal == 0) return 0;\t\t\t\t\t\t\t\\\n\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline key_t *kb_get_##name(kbtree_##name##_t *b, const key_t k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn kb_getp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KB_INTERVAL(name, key_t)\t\t\t\t\t\t\t\t\t\t\\\n\tstatic void kb_intervalp_##name(kbtree_##name##_t *b, const key_t * __restrict k, key_t **lower, key_t **upper)\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x = b->root;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t*lower = *upper = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile (x) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\t\\\n\t\t\tif (i >= 0 && r == 0) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t*lower = *upper = &__KB_KEY(key_t, x)[i];\t\t\t\t\\\n\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (i >= 0) *lower = &__KB_KEY(key_t, x)[i];\t\t\t\t\\\n\t\t\tif (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1];\t\t\\\n\t\t\tif (x->is_internal == 0) return;\t\t\t\t\t\t\t\\\n\t\t\tx = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void kb_interval_##name(kbtree_##name##_t *b, const key_t k, key_t **lower, key_t **upper) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkb_intervalp_##name(b, &k, lower, upper);\t\t\t\t\t\t\\\n\t}\n\n#define __KB_PUT(name, key_t, __cmp)\t\t\t\t\t\t\t\t\t\\\n\t/* x must be an internal node */\t\t\t\t\t\t\t\t\t\\\n\tstatic void __kb_split_##name(kbtree_##name##_t *b, kbnode_t *x, int i, kbnode_t *y) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *z;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tz = (kbnode_t*)calloc(1, y->is_internal? b->ilen : b->elen);\t\\\n\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tz->is_internal = y->is_internal;\t\t\t\t\t\t\t\t\\\n\t\tz->n = b->t - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy(__KB_KEY(key_t, z), __KB_KEY(key_t, y) + b->t, sizeof(key_t) * (b->t - 1)); \\\n\t\tif (y->is_internal) memcpy(__KB_PTR(b, z), __KB_PTR(b, y) + b->t, sizeof(void*) * b->t); \\\n\t\ty->n = b->t - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemmove(__KB_PTR(b, x) + i + 2, __KB_PTR(b, x) + i + 1, sizeof(void*) * (x->n - i)); \\\n\t\t__KB_PTR(b, x)[i + 1] = z;\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemmove(__KB_KEY(key_t, x) + i + 1, __KB_KEY(key_t, x) + i, sizeof(key_t) * (x->n - i)); \\\n\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[b->t - 1];\t\t\t\\\n\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t *__kb_putp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i = x->n - 1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkey_t *ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, 0);\t\t\t\t\t\t\t\\\n\t\t\tif (i != x->n - 1)\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i + 2, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\tret = &__KB_KEY(key_t, x)[i + 1];\t\t\t\t\t\t\t\\\n\t\t\t*ret = *k;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t++x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = __kb_getp_aux_##name(x, k, 0) + 1;\t\t\t\t\t\t\\\n\t\t\tif (__KB_PTR(b, x)[i]->n == 2 * b->t - 1) {\t\t\t\t\t\\\n\t\t\t\t__kb_split_##name(b, x, i, __KB_PTR(b, x)[i]);\t\t\t\\\n\t\t\t\tif (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i;\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tret = __kb_putp_aux_##name(b, __KB_PTR(b, x)[i], k);\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn ret; \t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t *kb_putp_##name(kbtree_##name##_t *b, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *r, *s;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t++b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tr = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (r->n == 2 * b->t - 1) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t++b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ts = (kbnode_t*)calloc(1, b->ilen);\t\t\t\t\t\t\t\\\n\t\t\tb->root = s; s->is_internal = 1; s->n = 0;\t\t\t\t\t\\\n\t\t\t__KB_PTR(b, s)[0] = r;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__kb_split_##name(b, s, 0, r);\t\t\t\t\t\t\t\t\\\n\t\t\tr = s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn __kb_putp_aux_##name(b, r, k);\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void kb_put_##name(kbtree_##name##_t *b, const key_t k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkb_putp_##name(b, &k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n\n#define __KB_DEL(name, key_t)\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t __kb_delp_aux_##name(kbtree_##name##_t *b, kbnode_t *x, const key_t * __restrict k, int s) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint yn, zn, i, r = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *xp, *y, *z;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkey_t kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x == 0) return *k;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (s) { /* s can only be 0, 1 or 2 */\t\t\t\t\t\t\t\\\n\t\t\tr = x->is_internal == 0? 0 : s == 1? 1 : -1;\t\t\t\t\\\n\t\t\ti = s == 1? x->n - 1 : -1;\t\t\t\t\t\t\t\t\t\\\n\t\t} else i = __kb_getp_aux_##name(x, k, &r);\t\t\t\t\t\t\\\n\t\tif (x->is_internal == 0) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (s == 2) ++i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (r == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif ((yn = __KB_PTR(b, x)[i]->n) >= b->t) {\t\t\t\t\t\\\n\t\t\t\txp = __KB_PTR(b, x)[i];\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 1); \\\n\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if ((zn = __KB_PTR(b, x)[i + 1]->n) >= b->t) {\t\t\\\n\t\t\t\txp = __KB_PTR(b, x)[i + 1];\t\t\t\t\t\t\t\t\\\n\t\t\t\tkp = __KB_KEY(key_t, x)[i];\t\t\t\t\t\t\t\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i] = __kb_delp_aux_##name(b, xp, 0, 2); \\\n\t\t\t\treturn kp;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (yn == b->t - 1 && zn == b->t - 1) {\t\t\t\t\\\n\t\t\t\ty = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1];\t\t\\\n\t\t\t\t__KB_KEY(key_t, y)[y->n++] = *k;\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, z), z->n * sizeof(key_t)); \\\n\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, z), (z->n + 1) * sizeof(void*)); \\\n\t\t\t\ty->n += z->n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t\tmemmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (x->n - i - 1) * sizeof(void*)); \\\n\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(z);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\treturn __kb_delp_aux_##name(b, y, k, s);\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t++i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif ((xp = __KB_PTR(b, x)[i])->n == b->t - 1) {\t\t\t\t\t\\\n\t\t\tif (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n >= b->t) {\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, xp) + 1, __KB_KEY(key_t, xp), xp->n * sizeof(key_t)); \\\n\t\t\t\tif (xp->is_internal) memmove(__KB_PTR(b, xp) + 1, __KB_PTR(b, xp), (xp->n + 1) * sizeof(void*)); \\\n\t\t\t\t__KB_KEY(key_t, xp)[0] = __KB_KEY(key_t, x)[i - 1];\t\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\\n\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\\n\t\t\t\t--y->n; ++xp->n;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= b->t) { \\\n\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\\n\t\t\t\t__KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0];\t\t\t\\\n\t\t\t\tif (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\\n\t\t\t\t--y->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, y), __KB_KEY(key_t, y) + 1, y->n * sizeof(key_t)); \\\n\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y), __KB_PTR(b, y) + 1, (y->n + 1) * sizeof(void*)); \\\n\t\t\t} else if (i > 0 && (y = __KB_PTR(b, x)[i - 1])->n == b->t - 1) { \\\n\t\t\t\t__KB_KEY(key_t, y)[y->n++] = __KB_KEY(key_t, x)[i - 1];\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, y) + y->n, __KB_KEY(key_t, xp), xp->n * sizeof(key_t));\t\\\n\t\t\t\tif (y->is_internal) memmove(__KB_PTR(b, y) + y->n, __KB_PTR(b, xp), (xp->n + 1) * sizeof(void*)); \\\n\t\t\t\ty->n += xp->n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i - 1, __KB_KEY(key_t, x) + i, (x->n - i) * sizeof(key_t)); \\\n\t\t\t\tmemmove(__KB_PTR(b, x) + i, __KB_PTR(b, x) + i + 1, (x->n - i) * sizeof(void*)); \\\n\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(xp);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\txp = y;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n == b->t - 1) { \\\n\t\t\t\t__KB_KEY(key_t, xp)[xp->n++] = __KB_KEY(key_t, x)[i];\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, xp) + xp->n, __KB_KEY(key_t, y), y->n * sizeof(key_t));\t\\\n\t\t\t\tif (xp->is_internal) memmove(__KB_PTR(b, xp) + xp->n, __KB_PTR(b, y), (y->n + 1) * sizeof(void*)); \\\n\t\t\t\txp->n += y->n;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemmove(__KB_KEY(key_t, x) + i, __KB_KEY(key_t, x) + i + 1, (x->n - i - 1) * sizeof(key_t)); \\\n\t\t\t\tmemmove(__KB_PTR(b, x) + i + 1, __KB_PTR(b, x) + i + 2, (x->n - i - 1) * sizeof(void*)); \\\n\t\t\t\t--x->n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tfree(y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn __kb_delp_aux_##name(b, xp, k, s);\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic key_t kb_delp_##name(kbtree_##name##_t *b, const key_t * __restrict k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkbnode_t *x;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkey_t ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tret = __kb_delp_aux_##name(b, b->root, k, 0);\t\t\t\t\t\\\n\t\t--b->n_keys;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (b->root->n == 0 && b->root->is_internal) {\t\t\t\t\t\\\n\t\t\t--b->n_nodes;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tx = b->root;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tb->root = __KB_PTR(b, x)[0];\t\t\t\t\t\t\t\t\\\n\t\t\tfree(x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline key_t kb_del_##name(kbtree_##name##_t *b, const key_t k) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn kb_delp_##name(b, &k);\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KB_ITR(name, key_t) \\\n\tstatic inline void kb_itr_first_##name(kbtree_##name##_t *b, kbitr_t *itr) \\\n\t{ \\\n\t\titr->p = 0; \\\n\t\tif (b->n_keys == 0) return; \\\n\t\titr->p = itr->stack; \\\n\t\titr->p->x = b->root; itr->p->i = 0; \\\n\t\twhile (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\\n\t\t\tkbnode_t *x = itr->p->x; \\\n\t\t\t++itr->p; \\\n\t\t\titr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\\n\t\t} \\\n\t} \\\n\tstatic int kb_itr_get_##name(kbtree_##name##_t *b, const key_t * __restrict k, kbitr_t *itr) \\\n\t{ \\\n\t\tint i, r = 0; \\\n\t\titr->p = itr->stack; \\\n\t\titr->p->x = b->root; itr->p->i = 0; \\\n\t\twhile (itr->p->x) { \\\n\t\t\ti = __kb_getp_aux_##name(itr->p->x, k, &r); \\\n\t\t\tif (i >= 0 && r == 0) return 0; \\\n\t\t\tif (itr->p->x->is_internal == 0) return -1; \\\n\t\t\titr->p[1].x = __KB_PTR(b, itr->p->x)[i + 1]; \\\n\t\t\titr->p[1].i = i; \\\n\t\t\t++itr->p; \\\n\t\t} \\\n\t\treturn -1; \\\n\t} \\\n\tstatic inline int kb_itr_next_##name(kbtree_##name##_t *b, kbitr_t *itr) \\\n\t{ \\\n\t\tif (itr->p < itr->stack) return 0; \\\n\t\tfor (;;) { \\\n\t\t\t++itr->p->i; \\\n\t\t\twhile (itr->p->x && itr->p->i <= itr->p->x->n) { \\\n\t\t\t\titr->p[1].i = 0; \\\n\t\t\t\titr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\\n\t\t\t\t++itr->p; \\\n\t\t\t} \\\n\t\t\t--itr->p; \\\n\t\t\tif (itr->p < itr->stack) return 0; \\\n\t\t\tif (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\\n\t\t} \\\n\t}\n\n#define KBTREE_INIT(name, key_t, __cmp)\t\t\t\\\n\t__KB_TREE_T(name)\t\t\t\t\t\t\t\\\n\t__KB_INIT(name, key_t)\t\t\t\t\t\t\\\n\t__KB_GET_AUX1(name, key_t, __cmp)\t\t\t\\\n\t__KB_GET(name, key_t)\t\t\t\t\t\t\\\n\t__KB_INTERVAL(name, key_t)\t\t\t\t\t\\\n\t__KB_PUT(name, key_t, __cmp)\t\t\t\t\\\n\t__KB_DEL(name, key_t) \\\n\t__KB_ITR(name, key_t)\n\n#define KB_DEFAULT_SIZE 512\n\n#define kbtree_t(name) kbtree_##name##_t\n#define kb_init(name, s) kb_init_##name(s)\n#define kb_destroy(name, b) __kb_destroy(b)\n#define kb_get(name, b, k) kb_get_##name(b, k)\n#define kb_put(name, b, k) kb_put_##name(b, k)\n#define kb_del(name, b, k) kb_del_##name(b, k)\n#define kb_interval(name, b, k, l, u) kb_interval_##name(b, k, l, u)\n#define kb_getp(name, b, k) kb_getp_##name(b, k)\n#define kb_putp(name, b, k) kb_putp_##name(b, k)\n#define kb_delp(name, b, k) kb_delp_##name(b, k)\n#define kb_intervalp(name, b, k, l, u) kb_intervalp_##name(b, k, l, u)\n\n#define kb_itr_first(name, b, i) kb_itr_first_##name(b, i)\n#define kb_itr_get(name, b, k, i) kb_itr_get_##name(b, k, i)\n#define kb_itr_next(name, b, i) kb_itr_next_##name(b, i)\n#define kb_itr_key(type, itr) __KB_KEY(type, (itr)->p->x)[(itr)->p->i]\n#define kb_itr_valid(itr) ((itr)->p >= (itr)->stack)\n\n#define kb_size(b) ((b)->n_keys)\n\n#define kb_generic_cmp(a, b) (((b) < (a)) - ((a) < (b)))\n#define kb_str_cmp(a, b) strcmp(a, b)\n\n/* The following is *DEPRECATED*!!! Use the iterator interface instead! */\n\ntypedef struct {\n\tkbnode_t *x;\n\tint i;\n} __kbstack_t;\n\n#define __kb_traverse(key_t, b, __func) do {\t\t\t\t\t\t\t\\\n\t\tint __kmax = 8;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t__kbstack_t *__kstack, *__kp;\t\t\t\t\t\t\t\t\t\\\n\t\t__kp = __kstack = (__kbstack_t*)calloc(__kmax, sizeof(__kbstack_t)); \\\n\t\t__kp->x = (b)->root; __kp->i = 0;\t\t\t\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\twhile (__kp->x && __kp->i <= __kp->x->n) {\t\t\t\t\t\\\n\t\t\t\tif (__kp - __kstack == __kmax - 1) {\t\t\t\t\t\\\n\t\t\t\t\t__kmax <<= 1;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t__kstack = (__kbstack_t*)realloc(__kstack, __kmax * sizeof(__kbstack_t)); \\\n\t\t\t\t\t__kp = __kstack + (__kmax>>1) - 1;\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t(__kp+1)->i = 0; (__kp+1)->x = __kp->x->is_internal? __KB_PTR(b, __kp->x)[__kp->i] : 0; \\\n\t\t\t\t++__kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t--__kp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (__kp >= __kstack) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__kp->x && __kp->i < __kp->x->n) __func(&__KB_KEY(key_t, __kp->x)[__kp->i]); \\\n\t\t\t\t++__kp->i;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else break;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(__kstack);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define __kb_get_first(key_t, b, ret) do {\t\\\n\t\tkbnode_t *__x = (b)->root;\t\t\t\\\n\t\twhile (__KB_PTR(b, __x)[0] != 0)\t\\\n\t\t\t__x = __KB_PTR(b, __x)[0];\t\t\\\n\t\t(ret) = __KB_KEY(key_t, __x)[0];\t\\\n\t} while (0)\n\n#endif\n"
        },
        {
          "name": "kdq.h",
          "type": "blob",
          "size": 4.171875,
          "content": "#ifndef __AC_KDQ_H\n#define __AC_KDQ_H\n\n#include <stdlib.h>\n#include <string.h>\n\n#define __KDQ_TYPE(type) \\\n\ttypedef struct { \\\n\t\tsize_t front:58, bits:6, count, mask; \\\n\t\ttype *a; \\\n\t} kdq_##type##_t;\n\n#define kdq_t(type) kdq_##type##_t\n#define kdq_size(q) ((q)->count)\n#define kdq_first(q) ((q)->a[(q)->front])\n#define kdq_last(q) ((q)->a[((q)->front + (q)->count - 1) & (q)->mask])\n#define kdq_at(q, i) ((q)->a[((q)->front + (i)) & (q)->mask])\n\n#define __KDQ_IMPL(type, SCOPE) \\\n\tSCOPE kdq_##type##_t *kdq_init_##type() \\\n\t{ \\\n\t\tkdq_##type##_t *q; \\\n\t\tq = (kdq_##type##_t*)calloc(1, sizeof(kdq_##type##_t)); \\\n\t\tq->bits = 2, q->mask = (1ULL<<q->bits) - 1; \\\n\t\tq->a = (type*)malloc((1<<q->bits) * sizeof(type)); \\\n\t\treturn q; \\\n\t} \\\n\tSCOPE void kdq_destroy_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\tif (q == 0) return; \\\n\t\tfree(q->a); free(q); \\\n\t} \\\n\tSCOPE int kdq_resize_##type(kdq_##type##_t *q, int new_bits) \\\n\t{ \\\n\t\tsize_t new_size = 1ULL<<new_bits, old_size = 1ULL<<q->bits; \\\n\t\tif (new_size < q->count) { /* not big enough */ \\\n\t\t\tint i; \\\n\t\t\tfor (i = 0; i < 64; ++i) \\\n\t\t\t\tif (1ULL<<i > q->count) break; \\\n\t\t\tnew_bits = i, new_size = 1ULL<<new_bits; \\\n\t\t} \\\n\t\tif (new_bits == q->bits) return q->bits; /* unchanged */ \\\n\t\tif (new_bits > q->bits) q->a = (type*)realloc(q->a, (1ULL<<new_bits) * sizeof(type)); \\\n\t\tif (q->front + q->count <= old_size) { /* unwrapped */ \\\n\t\t\tif (q->front + q->count > new_size) /* only happens for shrinking */ \\\n\t\t\t\tmemmove(q->a, q->a + new_size, (q->front + q->count - new_size) * sizeof(type)); \\\n\t\t} else { /* wrapped */ \\\n\t\t\tmemmove(q->a + (new_size - (old_size - q->front)), q->a + q->front, (old_size - q->front) * sizeof(type)); \\\n\t\t\tq->front = new_size - (old_size - q->front); \\\n\t\t} \\\n\t\tq->bits = new_bits, q->mask = (1ULL<<q->bits) - 1; \\\n\t\tif (new_bits < q->bits) q->a = (type*)realloc(q->a, (1ULL<<new_bits) * sizeof(type)); \\\n\t\treturn q->bits; \\\n\t} \\\n\tSCOPE type *kdq_pushp_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\tif (q->count == 1ULL<<q->bits) kdq_resize_##type(q, q->bits + 1); \\\n\t\treturn &q->a[((q->count++) + q->front) & (q)->mask]; \\\n\t} \\\n\tSCOPE void kdq_push_##type(kdq_##type##_t *q, type v) \\\n\t{ \\\n\t\tif (q->count == 1ULL<<q->bits) kdq_resize_##type(q, q->bits + 1); \\\n\t\tq->a[((q->count++) + q->front) & (q)->mask] = v; \\\n\t} \\\n\tSCOPE type *kdq_unshiftp_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\tif (q->count == 1ULL<<q->bits) kdq_resize_##type(q, q->bits + 1); \\\n\t\t++q->count; \\\n\t\tq->front = q->front? q->front - 1 : (1ULL<<q->bits) - 1; \\\n\t\treturn &q->a[q->front]; \\\n\t} \\\n\tSCOPE void kdq_unshift_##type(kdq_##type##_t *q, type v) \\\n\t{ \\\n\t\ttype *p; \\\n\t\tp = kdq_unshiftp_##type(q); \\\n\t\t*p = v; \\\n\t} \\\n\tSCOPE type *kdq_pop_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\treturn q->count? &q->a[((--q->count) + q->front) & q->mask] : 0; \\\n\t} \\\n\tSCOPE type *kdq_shift_##type(kdq_##type##_t *q) \\\n\t{ \\\n\t\ttype *d = 0; \\\n\t\tif (q->count == 0) return 0; \\\n\t\td = &q->a[q->front++]; \\\n\t\tq->front &= q->mask; \\\n\t\t--q->count; \\\n\t\treturn d; \\\n\t}\n\n#define KDQ_INIT2(type, SCOPE) \\\n\t__KDQ_TYPE(type) \\\n\t__KDQ_IMPL(type, SCOPE)\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define KDQ_INIT(type) KDQ_INIT2(type, static inline klib_unused)\n\n#define KDQ_DECLARE(type) \\\n\t__KDQ_TYPE(type) \\\n\tkdq_##type##_t *kdq_init_##type(); \\\n\tvoid kdq_destroy_##type(kdq_##type##_t *q); \\\n\tint kdq_resize_##type(kdq_##type##_t *q, int new_bits); \\\n\ttype *kdq_pushp_##type(kdq_##type##_t *q); \\\n\tvoid kdq_push_##type(kdq_##type##_t *q, type v); \\\n\ttype *kdq_unshiftp_##type(kdq_##type##_t *q); \\\n\tvoid kdq_unshift_##type(kdq_##type##_t *q, type v); \\\n\ttype *kdq_pop_##type(kdq_##type##_t *q); \\\n\ttype *kdq_shift_##type(kdq_##type##_t *q);\n\n#define kdq_init(type) kdq_init_##type()\n#define kdq_destroy(type, q) kdq_destroy_##type(q)\n#define kdq_resize(type, q, new_bits) kdq_resize_##type(q, new_bits)\n#define kdq_pushp(type, q) kdq_pushp_##type(q)\n#define kdq_push(type, q, v) kdq_push_##type(q, v)\n#define kdq_pop(type, q) kdq_pop_##type(q)\n#define kdq_unshiftp(type, q) kdq_unshiftp_##type(q)\n#define kdq_unshift(type, q, v) kdq_unshift_##type(q, v)\n#define kdq_shift(type, q) kdq_shift_##type(q)\n\n#endif\n"
        },
        {
          "name": "keigen.c",
          "type": "blob",
          "size": 3.63671875,
          "content": "#include <math.h>\n#include <stdlib.h>\n#include \"keigen.h\"\n\nvoid ke_core_strq(int n, double *q, double *b, double *c)\n{\n\tint\ti, j, k, u, v;\n\tdouble h, f, g, h2;\n\tfor (i = n - 1; i >= 1; i--) {\n\t\th = 0.0;\n\t\tif (i > 1)\n\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\tu = i * n + k;\n\t\t\t\th = h + q[u] * q[u];\n\t\t\t}\n\t\tif (h + 1.0 == 1.0) {\n\t\t\tc[i] = 0.0;\n\t\t\tif (i == 1)\n\t\t\t\tc[i] = q[i * n + i - 1];\n\t\t\tb[i] = 0.0;\n\t\t} else {\n\t\t\tc[i] = sqrt(h);\n\t\t\tu = i * n + i - 1;\n\t\t\tif (q[u] > 0.0)\n\t\t\t\tc[i] = -c[i];\n\t\t\th = h - q[u] * c[i];\n\t\t\tq[u] = q[u] - c[i];\n\t\t\tf = 0.0;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tq[j * n + i] = q[i * n + j] / h;\n\t\t\t\tg = 0.0;\n\t\t\t\tfor (k = 0; k <= j; k++)\n\t\t\t\t\tg = g + q[j * n + k] * q[i * n + k];\n\t\t\t\tif (j + 1 < i)\n\t\t\t\t\tfor (k = j + 1; k <= i - 1; k++)\n\t\t\t\t\t\tg = g + q[k * n + j] * q[i * n + k];\n\t\t\t\tc[j] = g / h;\n\t\t\t\tf = f + g * q[j * n + i];\n\t\t\t}\n\t\t\th2 = f / (h + h);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tf = q[i * n + j];\n\t\t\t\tg = c[j] - h2 * f;\n\t\t\t\tc[j] = g;\n\t\t\t\tfor (k = 0; k <= j; k++) {\n\t\t\t\t\tu = j * n + k;\n\t\t\t\t\tq[u] = q[u] - f * c[k] - g * q[i * n + k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[i] = h;\n\t\t}\n\t}\n\tfor (i = 0; i < n - 1; i++)\n\t\tc[i] = c[i + 1];\n\tc[n - 1] = 0.0;\n\tb[0] = 0.0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (b[i] != 0.0 && i - 1 >= 0)\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tg = 0.0;\n\t\t\t\tfor (k = 0; k < i; k++)\n\t\t\t\t\tg = g + q[i * n + k] * q[k * n + j];\n\t\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\t\tu = k * n + j;\n\t\t\t\t\tq[u] = q[u] - g * q[k * n + i];\n\t\t\t\t}\n\t\t\t}\n\t\tu = i * n + i;\n\t\tb[i] = q[u];\n\t\tq[u] = 1.0;\n\t\tif (i - 1 >= 0)\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tq[i * n + j] = 0.0;\n\t\t\t\tq[j * n + i] = 0.0;\n\t\t\t}\n\t}\n}\n\nint ke_core_sstq(int n, double *b, double *c, double *q, int cal_ev, double eps, int l)\n{\n\tint i, j, k, m, it, u, v;\n\tdouble d, f, h, g, p, r, e, s;\n\tc[n - 1] = 0.0;\n\td = 0.0;\n\tf = 0.0;\n\tfor (j = 0; j < n; j++) {\n\t\tit = 0;\n\t\th = eps * (fabs(b[j]) + fabs(c[j]));\n\t\tif (h > d)\n\t\t\td = h;\n\t\tm = j;\n\t\twhile (m < n && fabs(c[m]) > d)\n\t\t\tm = m + 1;\n\t\tif (m != j) {\n\t\t\tdo {\n\t\t\t\tif (it == l) return KE_EXCESS_ITER;\n\t\t\t\tit = it + 1;\n\t\t\t\tg = b[j];\n\t\t\t\tp = (b[j + 1] - g) / (2.0 * c[j]);\n\t\t\t\tr = sqrt(p * p + 1.0);\n\t\t\t\tif (p >= 0.0)\n\t\t\t\t\tb[j] = c[j] / (p + r);\n\t\t\t\telse\n\t\t\t\t\tb[j] = c[j] / (p - r);\n\t\t\t\th = g - b[j];\n\t\t\t\tfor (i = j + 1; i < n; i++)\n\t\t\t\t\tb[i] = b[i] - h;\n\t\t\t\tf = f + h;\n\t\t\t\tp = b[m];\n\t\t\t\te = 1.0;\n\t\t\t\ts = 0.0;\n\t\t\t\tfor (i = m - 1; i >= j; i--) {\n\t\t\t\t\tg = e * c[i];\n\t\t\t\t\th = e * p;\n\t\t\t\t\tif (fabs(p) >= fabs(c[i])) {\n\t\t\t\t\t\te = c[i] / p;\n\t\t\t\t\t\tr = sqrt(e * e + 1.0);\n\t\t\t\t\t\tc[i + 1] = s * p * r;\n\t\t\t\t\t\ts = e / r;\n\t\t\t\t\t\te = 1.0 / r;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = p / c[i];\n\t\t\t\t\t\tr = sqrt(e * e + 1.0);\n\t\t\t\t\t\tc[i + 1] = s * c[i] * r;\n\t\t\t\t\t\ts = 1.0 / r;\n\t\t\t\t\t\te = e / r;\n\t\t\t\t\t}\n\t\t\t\t\tp = e * b[i] - s * g;\n\t\t\t\t\tb[i + 1] = h + s * (e * g + s * b[i]);\n\t\t\t\t\tif (cal_ev) {\n\t\t\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t\t\tu = k * n + i + 1;\n\t\t\t\t\t\t\tv = u - 1;\n\t\t\t\t\t\t\th = q[u];\n\t\t\t\t\t\t\tq[u] = s * q[v] + e * h;\n\t\t\t\t\t\t\tq[v] = e * q[v] - s * h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[j] = s * p;\n\t\t\t\tb[j] = e * p;\n\t\t\t}\n\t\t\twhile (fabs(c[j]) > d);\n\t\t}\n\t\tb[j] = b[j] + f;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tk = i;\n\t\tp = b[i];\n\t\tif (i + 1 < n) {\n\t\t\tj = i + 1;\n\t\t\twhile (j < n && b[j] <= p) {\n\t\t\t\tk = j;\n\t\t\t\tp = b[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\t\tif (k != i) {\n\t\t\tb[k] = b[i];\n\t\t\tb[i] = p;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tu = j * n + i;\n\t\t\t\tv = j * n + k;\n\t\t\t\tp = q[u];\n\t\t\t\tq[u] = q[v];\n\t\t\t\tq[v] = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define MALLOC(type, size) ((type*)malloc(size * sizeof(type)))\n\nint ke_eigen_sd(int n, double *a, double *v, int cal_ev, double eps, int max_iter)\n{\n\tdouble *c;\n\tint r;\n\tif (1.0 + eps <= 1.0) eps = 1e-7;\n\tif (max_iter <= 0) max_iter = 50;\n\tc = MALLOC(double, n);\n\tke_core_strq(n, a, v, c);\n\tr = ke_core_sstq(n, v, c, a, cal_ev, eps, max_iter);\n\tfree(c);\n\treturn r;\n}\n"
        },
        {
          "name": "keigen.h",
          "type": "blob",
          "size": 1.5341796875,
          "content": "#ifndef KEIGEN_H\n#define KEIGEN_H\n\n#define KE_EXCESS_ITER (-1)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * Compute eigenvalues/vectors for a dense symmetric matrix\n *\n * @param n       dimension\n * @param a       input matrix and eigenvalues on return ([n*n]; in & out)\n * @param v       eigenvalues ([n]; out)\n * @param cal_ev  compute eigenvectos or not (faster without vectors)\n * @param eps     precision (<=0 for default)\n * @param max_itr max iteration (<=0 for detaul)\n *\n * @return 0 on success; KE_EXCESS_ITER if too many iterations\n */\nint ke_eigen_sd(int n, double *a, double *v, int cal_ev, double eps, int max_iter);\n\n/**\n * Transform a real symmetric matrix to a tridiagonal matrix\n *\n * @param n       dimension\n * @param q       input matrix and transformation matrix ([n*n]; in & out)\n * @param b       diagonal ([n]; out)\n * @param c       subdiagonal ([n]; out)\n */\nvoid ke_core_strq(int n, double *q, double *b, double *c);\n\n/**\n * Compute eigenvalues and eigenvectors for a tridiagonal matrix\n *\n * @param n       dimension\n * @param b       diagonal and eigenvalues on return ([n]; in & out)\n * @param c       subdiagonal ([n]; in)\n * @param q       transformation matrix and eigenvectors on return ([n*n]; in & out)\n * @param cal_ev  compute eigenvectors or not (faster without vectors)\n * @param eps     precision\n * @param l       max iterations\n *\n * @return 0 on success; KE_EXCESS_ITER if too many iterations\n */\nint ke_core_sstq(int n, double *b, double *c, double *q, int cal_ev, double eps, int l);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "ketopt.h",
          "type": "blob",
          "size": 3.8818359375,
          "content": "#ifndef KETOPT_H\n#define KETOPT_H\n\n#include <string.h> /* for strchr() and strncmp() */\n\n#define ko_no_argument       0\n#define ko_required_argument 1\n#define ko_optional_argument 2\n\ntypedef struct {\n\tint ind;   /* equivalent to optind */\n\tint opt;   /* equivalent to optopt */\n\tchar *arg; /* equivalent to optarg */\n\tint longidx; /* index of a long option; or -1 if short */\n\t/* private variables not intended for external uses */\n\tint i, pos, n_args;\n} ketopt_t;\n\ntypedef struct {\n\tchar *name;\n\tint has_arg;\n\tint val;\n} ko_longopt_t;\n\nstatic ketopt_t KETOPT_INIT = { 1, 0, 0, -1, 1, 0, 0 };\n\nstatic void ketopt_permute(char *argv[], int j, int n) /* move argv[j] over n elements to the left */\n{\n\tint k;\n\tchar *p = argv[j];\n\tfor (k = 0; k < n; ++k)\n\t\targv[j - k] = argv[j - k - 1];\n\targv[j - k] = p;\n}\n\n/**\n * Parse command-line options and arguments\n *\n * This fuction has a similar interface to GNU's getopt_long(). Each call\n * parses one option and returns the option name.  s->arg points to the option\n * argument if present. The function returns -1 when all command-line arguments\n * are parsed. In this case, s->ind is the index of the first non-option\n * argument.\n *\n * @param s         status; shall be initialized to KETOPT_INIT on the first call\n * @param argc      length of argv[]\n * @param argv      list of command-line arguments; argv[0] is ignored\n * @param permute   non-zero to move options ahead of non-option arguments\n * @param ostr      option string\n * @param longopts  long options\n *\n * @return ASCII for a short option; ko_longopt_t::val for a long option; -1 if\n *         argv[] is fully processed; '?' for an unknown option or an ambiguous\n *         long option; ':' if an option argument is missing\n */\nstatic int ketopt(ketopt_t *s, int argc, char *argv[], int permute, const char *ostr, const ko_longopt_t *longopts)\n{\n\tint opt = -1, i0, j;\n\tif (permute) {\n\t\twhile (s->i < argc && (argv[s->i][0] != '-' || argv[s->i][1] == '\\0'))\n\t\t\t++s->i, ++s->n_args;\n\t}\n\ts->arg = 0, s->longidx = -1, i0 = s->i;\n\tif (s->i >= argc || argv[s->i][0] != '-' || argv[s->i][1] == '\\0') {\n\t\ts->ind = s->i - s->n_args;\n\t\treturn -1;\n\t}\n\tif (argv[s->i][0] == '-' && argv[s->i][1] == '-') { /* \"--\" or a long option */\n\t\tif (argv[s->i][2] == '\\0') { /* a bare \"--\" */\n\t\t\tketopt_permute(argv, s->i, s->n_args);\n\t\t\t++s->i, s->ind = s->i - s->n_args;\n\t\t\treturn -1;\n\t\t}\n\t\ts->opt = 0, opt = '?', s->pos = -1;\n\t\tif (longopts) { /* parse long options */\n\t\t\tint k, n_exact = 0, n_partial = 0;\n\t\t\tconst ko_longopt_t *o = 0, *o_exact = 0, *o_partial = 0;\n\t\t\tfor (j = 2; argv[s->i][j] != '\\0' && argv[s->i][j] != '='; ++j) {} /* find the end of the option name */\n\t\t\tfor (k = 0; longopts[k].name != 0; ++k)\n\t\t\t\tif (strncmp(&argv[s->i][2], longopts[k].name, j - 2) == 0) {\n\t\t\t\t\tif (longopts[k].name[j - 2] == 0) ++n_exact, o_exact = &longopts[k];\n\t\t\t\t\telse ++n_partial, o_partial = &longopts[k];\n\t\t\t\t}\n\t\t\tif (n_exact > 1 || (n_exact == 0 && n_partial > 1)) return '?';\n\t\t\to = n_exact == 1? o_exact : n_partial == 1? o_partial : 0;\n\t\t\tif (o) {\n\t\t\t\ts->opt = opt = o->val, s->longidx = o - longopts;\n\t\t\t\tif (argv[s->i][j] == '=') s->arg = &argv[s->i][j + 1];\n\t\t\t\tif (o->has_arg == 1 && argv[s->i][j] == '\\0') {\n\t\t\t\t\tif (s->i < argc - 1) s->arg = argv[++s->i];\n\t\t\t\t\telse opt = ':'; /* missing option argument */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { /* a short option */\n\t\tconst char *p;\n\t\tif (s->pos == 0) s->pos = 1;\n\t\topt = s->opt = argv[s->i][s->pos++];\n\t\tp = strchr((char*)ostr, opt);\n\t\tif (p == 0) {\n\t\t\topt = '?'; /* unknown option */\n\t\t} else if (p[1] == ':') {\n\t\t\tif (argv[s->i][s->pos] == 0) {\n\t\t\t\tif (s->i < argc - 1) s->arg = argv[++s->i];\n\t\t\t\telse opt = ':'; /* missing option argument */\n\t\t\t} else s->arg = &argv[s->i][s->pos];\n\t\t\ts->pos = -1;\n\t\t}\n\t}\n\tif (s->pos < 0 || argv[s->i][s->pos] == 0) {\n\t\t++s->i, s->pos = 0;\n\t\tif (s->n_args > 0) /* permute */\n\t\t\tfor (j = i0; j < s->i; ++j)\n\t\t\t\tketopt_permute(argv, j, s->n_args);\n\t}\n\ts->ind = s->i - s->n_args;\n\treturn opt;\n}\n\n#endif\n"
        },
        {
          "name": "kexpr.c",
          "type": "blob",
          "size": 16.5390625,
          "content": "#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <math.h>\n#include \"kexpr.h\"\n\n/***************\n * Definitions *\n ***************/\n\n#define KEO_NULL  0\n#define KEO_POS   1\n#define KEO_NEG   2\n#define KEO_BNOT  3\n#define KEO_LNOT  4\n#define KEO_POW   5\n#define KEO_MUL   6\n#define KEO_DIV   7\n#define KEO_IDIV  8\n#define KEO_MOD   9\n#define KEO_ADD  10\n#define KEO_SUB  11\n#define KEO_LSH  12\n#define KEO_RSH  13\n#define KEO_LT   14\n#define KEO_LE   15\n#define KEO_GT   16\n#define KEO_GE   17\n#define KEO_EQ   18\n#define KEO_NE   19\n#define KEO_BAND 20\n#define KEO_BXOR 21\n#define KEO_BOR  22\n#define KEO_LAND 23\n#define KEO_LOR  24\n\n#define KET_NULL  0\n#define KET_VAL   1\n#define KET_OP    2\n#define KET_FUNC  3\n\n#define KEF_NULL  0\n#define KEF_REAL  1\n\nstruct ke1_s;\n\ntypedef struct ke1_s {\n\tuint32_t ttype:16, vtype:10, assigned:1, user_func:5; // ttype: token type; vtype: value type\n\tint32_t op:8, n_args:24; // op: operator, n_args: number of arguments\n\tchar *name; // variable name or function name\n\tunion {\n\t\tvoid (*builtin)(struct ke1_s *a, struct ke1_s *b); // execution function\n\t\tdouble (*real_func1)(double);\n\t\tdouble (*real_func2)(double, double);\n\t} f;\n\tdouble r;\n\tint64_t i;\n\tchar *s;\n} ke1_t;\n\nstatic int ke_op[25] = {\n\t0,\n\t1<<1|1, 1<<1|1, 1<<1|1, 1<<1|1, // unary operators\n\t2<<1|1, // pow()\n\t3<<1, 3<<1, 3<<1, 3<<1, // * / // %\n\t4<<1, 4<<1, // + and -\n\t5<<1, 5<<1, // << and >>\n\t6<<1, 6<<1, 6<<1, 6<<1, // < > <= >=\n\t7<<1, 7<<1, // == !=\n\t8<<1, // &\n\t9<<1, // ^\n\t10<<1,// |\n\t11<<1,// &&\n\t12<<1 // ||\n};\n\nstatic const char *ke_opstr[] = {\n\t\"\",\n\t\"+(1)\", \"-(1)\", \"~\", \"!\",\n\t\"**\",\n\t\"*\", \"/\", \"//\", \"%\",\n\t\"+\", \"-\",\n\t\"<<\", \">>\",\n\t\"<\", \"<=\", \">\", \">=\",\n\t\"==\", \"!=\",\n\t\"&\",\n\t\"^\",\n\t\"|\",\n\t\"&&\",\n\t\"||\"\n};\n\nstruct kexpr_s {\n\tint n;\n\tke1_t *e;\n};\n\n/**********************\n * Operator functions *\n **********************/\n\n#define KE_GEN_CMP(_type, _op) \\\n\tstatic void ke_op_##_type(ke1_t *p, ke1_t *q) { \\\n\t\tif (p->vtype == KEV_STR && q->vtype == KEV_STR) p->i = (strcmp(p->s, q->s) _op 0); \\\n\t\telse p->i = p->vtype == KEV_REAL || q->vtype == KEV_REAL? (p->r _op q->r) : (p->i _op q->i); \\\n\t\tp->r = (double)p->i; \\\n\t\tp->vtype = KEV_INT; \\\n\t}\n\nKE_GEN_CMP(KEO_LT, <)\nKE_GEN_CMP(KEO_LE, <=)\nKE_GEN_CMP(KEO_GT, >)\nKE_GEN_CMP(KEO_GE, >=)\nKE_GEN_CMP(KEO_EQ, ==)\nKE_GEN_CMP(KEO_NE, !=)\n\n#define KE_GEN_BIN_INT(_type, _op) \\\n\tstatic void ke_op_##_type(ke1_t *p, ke1_t *q) { \\\n\t\tp->i _op q->i; p->r = (double)p->i; \\\n\t\tp->vtype = KEV_INT; \\\n\t}\n\nKE_GEN_BIN_INT(KEO_BAND, &=)\nKE_GEN_BIN_INT(KEO_BOR, |=)\nKE_GEN_BIN_INT(KEO_BXOR, ^=)\nKE_GEN_BIN_INT(KEO_LSH, <<=)\nKE_GEN_BIN_INT(KEO_RSH, >>=)\nKE_GEN_BIN_INT(KEO_MOD, %=)\nKE_GEN_BIN_INT(KEO_IDIV, /=)\n\n#define KE_GEN_BIN_BOTH(_type, _op) \\\n\tstatic void ke_op_##_type(ke1_t *p, ke1_t *q) { \\\n\t\tp->i _op q->i; p->r _op q->r; \\\n\t\tp->vtype = p->vtype == KEV_REAL || q->vtype == KEV_REAL? KEV_REAL : KEV_INT; \\\n\t}\n\nKE_GEN_BIN_BOTH(KEO_ADD, +=)\nKE_GEN_BIN_BOTH(KEO_SUB, -=)\nKE_GEN_BIN_BOTH(KEO_MUL, *=)\n\nstatic void ke_op_KEO_DIV(ke1_t *p, ke1_t *q)  { p->r /= q->r, p->i = (int64_t)(p->r + .5); p->vtype = KEV_REAL; }\nstatic void ke_op_KEO_LAND(ke1_t *p, ke1_t *q) { p->i = (p->i && q->i); p->r = p->i; p->vtype = KEV_INT; }\nstatic void ke_op_KEO_LOR(ke1_t *p, ke1_t *q)  { p->i = (p->i || q->i); p->r = p->i; p->vtype = KEV_INT; }\nstatic void ke_op_KEO_POW(ke1_t *p, ke1_t *q)  { p->r = pow(p->r, q->r), p->i = (int64_t)(p->r + .5); p->vtype = p->vtype == KEV_REAL || q->vtype == KEV_REAL? KEV_REAL : KEV_INT; }\nstatic void ke_op_KEO_BNOT(ke1_t *p, ke1_t *q) { p->i = ~p->i; p->r = (double)p->i; p->vtype = KEV_INT; }\nstatic void ke_op_KEO_LNOT(ke1_t *p, ke1_t *q) { p->i = !p->i; p->r = (double)p->i; p->vtype = KEV_INT; }\nstatic void ke_op_KEO_POS(ke1_t *p, ke1_t *q)  { } // do nothing\nstatic void ke_op_KEO_NEG(ke1_t *p, ke1_t *q)  { p->i = -p->i, p->r = -p->r; }\n\nstatic void ke_func1_abs(ke1_t *p, ke1_t *q) { if (p->vtype == KEV_INT) p->i = abs(p->i), p->r = (double)p->i; else p->r = fabs(p->r), p->i = (int64_t)(p->r + .5); }\n\n/**********\n * Parser *\n **********/\n\nstatic inline char *mystrndup(const char *src, int n)\n{\n\tchar *dst;\n\tdst = (char*)calloc(n + 1, 1);\n\tstrncpy(dst, src, n);\n\treturn dst;\n}\n\n// parse a token except \"(\", \")\" and \",\"\nstatic ke1_t ke_read_token(char *p, char **r, int *err, int last_is_val) // it doesn't parse parentheses\n{\n\tchar *q = p;\n\tke1_t e;\n\tmemset(&e, 0, sizeof(ke1_t));\n\tif (isalpha(*p) || *p == '_') { // a variable or a function\n\t\tfor (; *p && (*p == '_' || isalnum(*p)); ++p);\n\t\tif (*p == '(') e.ttype = KET_FUNC, e.n_args = 1;\n\t\telse e.ttype = KET_VAL, e.vtype = KEV_REAL;\n\t\te.name = mystrndup(q, p - q);\n\t\te.i = 0, e.r = 0.;\n\t\t*r = p;\n\t} else if (isdigit(*p) || *p == '.') { // a number\n\t\tlong x;\n\t\tdouble y;\n\t\tchar *pp;\n\t\te.ttype = KET_VAL;\n\t\ty = strtod(q, &p);\n\t\tx = strtol(q, &pp, 0); // FIXME: check int/double parsing errors\n\t\tif (q == p && q == pp) { // parse error\n\t\t\t*err |= KEE_NUM;\n\t\t} else if (p > pp) { // has \".\" or \"[eE]\"; then it is a real number\n\t\t\te.vtype = KEV_REAL;\n\t\t\te.i = (int64_t)(y + .5), e.r = y;\n\t\t\t*r = p;\n\t\t} else {\n\t\t\te.vtype = KEV_INT;\n\t\t\te.i = x, e.r = y;\n\t\t\t*r = pp;\n\t\t}\n\t} else if (*p == '\"' || *p == '\\'') { // a string value\n\t\tint c = *p;\n\t\tfor (++p; *p && *p != c; ++p)\n\t\t\tif (*p == '\\\\') ++p; // escaping\n\t\tif (*p == c) {\n\t\t\te.ttype = KET_VAL, e.vtype = KEV_STR;\n\t\t\te.s = mystrndup(q + 1, p - q - 1);\n\t\t\t*r = p + 1;\n\t\t} else *err |= KEE_UNQU, *r = p;\n\t} else { // an operator\n\t\te.ttype = KET_OP;\n\t\tif (*p == '*' && p[1] == '*') e.op = KEO_POW, e.f.builtin = ke_op_KEO_POW, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '*') e.op = KEO_MUL, e.f.builtin = ke_op_KEO_MUL, e.n_args = 2, *r = q + 1; // FIXME: NOT working for unary operators\n\t\telse if (*p == '/' && p[1] == '/') e.op = KEO_IDIV, e.f.builtin = ke_op_KEO_IDIV, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '/') e.op = KEO_DIV, e.f.builtin = ke_op_KEO_DIV, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '%') e.op = KEO_MOD, e.f.builtin = ke_op_KEO_MOD, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '+') {\n\t\t\tif (last_is_val) e.op = KEO_ADD, e.f.builtin = ke_op_KEO_ADD, e.n_args = 2;\n\t\t\telse e.op = KEO_POS, e.f.builtin = ke_op_KEO_POS, e.n_args = 1;\n\t\t\t*r = q + 1;\n\t\t} else if (*p == '-') {\n\t\t\tif (last_is_val) e.op = KEO_SUB, e.f.builtin = ke_op_KEO_SUB, e.n_args = 2;\n\t\t\telse e.op = KEO_NEG, e.f.builtin = ke_op_KEO_NEG, e.n_args = 1;\n\t\t\t*r = q + 1;\n\t\t} else if (*p == '=' && p[1] == '=') e.op = KEO_EQ, e.f.builtin = ke_op_KEO_EQ, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '!' && p[1] == '=') e.op = KEO_NE, e.f.builtin = ke_op_KEO_NE, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '<' && p[1] == '>') e.op = KEO_NE, e.f.builtin = ke_op_KEO_NE, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '>' && p[1] == '=') e.op = KEO_GE, e.f.builtin = ke_op_KEO_GE, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '<' && p[1] == '=') e.op = KEO_LE, e.f.builtin = ke_op_KEO_LE, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '>' && p[1] == '>') e.op = KEO_RSH, e.f.builtin = ke_op_KEO_RSH, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '<' && p[1] == '<') e.op = KEO_LSH, e.f.builtin = ke_op_KEO_LSH, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '>') e.op = KEO_GT, e.f.builtin = ke_op_KEO_GT, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '<') e.op = KEO_LT, e.f.builtin = ke_op_KEO_LT, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '|' && p[1] == '|') e.op = KEO_LOR, e.f.builtin = ke_op_KEO_LOR, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '&' && p[1] == '&') e.op = KEO_LAND, e.f.builtin = ke_op_KEO_LAND, e.n_args = 2, *r = q + 2;\n\t\telse if (*p == '|') e.op = KEO_BOR, e.f.builtin = ke_op_KEO_BOR, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '&') e.op = KEO_BAND, e.f.builtin = ke_op_KEO_BAND, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '^') e.op = KEO_BXOR, e.f.builtin = ke_op_KEO_BXOR, e.n_args = 2, *r = q + 1;\n\t\telse if (*p == '~') e.op = KEO_BNOT, e.f.builtin = ke_op_KEO_BNOT, e.n_args = 1, *r = q + 1;\n\t\telse if (*p == '!') e.op = KEO_LNOT, e.f.builtin = ke_op_KEO_LNOT, e.n_args = 1, *r = q + 1;\n\t\telse e.ttype = KET_NULL, *err |= KEE_UNOP;\n\t}\n\treturn e;\n}\n\nstatic inline ke1_t *push_back(ke1_t **a, int *n, int *m)\n{\n\tif (*n == *m) {\n\t\tint old_m = *m;\n\t\t*m = *m? *m<<1 : 8;\n\t\t*a = (ke1_t*)realloc(*a, *m * sizeof(ke1_t));\n\t\tmemset(*a + old_m, 0, (*m - old_m) * sizeof(ke1_t));\n\t}\n\treturn &(*a)[(*n)++];\n}\n\nstatic ke1_t *ke_parse_core(const char *_s, int *_n, int *err)\n{\n\tchar *s, *p, *q;\n\tint n_out, m_out, n_op, m_op, last_is_val = 0;\n\tke1_t *out, *op, *t, *u;\n\n\t*err = 0; *_n = 0;\n\ts = strdup(_s); // make a copy\n\tfor (p = q = s; *p; ++p) // squeeze out spaces\n\t\tif (!isspace(*p)) *q++ = *p;\n\t*q++ = 0;\n\n\tout = op = 0;\n\tn_out = m_out = n_op = m_op = 0;\n\tp = s;\n\twhile (*p) {\n\t\tif (*p == '(') {\n\t\t\tt = push_back(&op, &n_op, &m_op); // push to the operator stack\n\t\t\tt->op = -1, t->ttype = KET_NULL; // ->op < 0 for a left parenthsis\n\t\t\t++p;\n\t\t} else if (*p == ')') {\n\t\t\twhile (n_op > 0 && op[n_op-1].op >= 0) { // move operators to the output until we see a left parenthesis\n\t\t\t\tu = push_back(&out, &n_out, &m_out);\n\t\t\t\t*u = op[--n_op];\n\t\t\t}\n\t\t\tif (n_op == 0) { // error: extra right parenthesis\n\t\t\t\t*err |= KEE_UNRP;\n\t\t\t\tbreak;\n\t\t\t} else --n_op; // pop out '('\n\t\t\tif (n_op > 0 && op[n_op-1].ttype == KET_FUNC) { // the top of the operator stack is a function\n\t\t\t\tu = push_back(&out, &n_out, &m_out); // move it to the output\n\t\t\t\t*u = op[--n_op];\n\t\t\t\tif (u->n_args == 1 && strcmp(u->name, \"abs\") == 0) u->f.builtin = ke_func1_abs;\n\t\t\t}\n\t\t\t++p;\n\t\t} else if (*p == ',') { // function arguments separator\n\t\t\twhile (n_op > 0 && op[n_op-1].op >= 0) {\n\t\t\t\tu = push_back(&out, &n_out, &m_out);\n\t\t\t\t*u = op[--n_op];\n\t\t\t}\n\t\t\tif (n_op < 2 || op[n_op-2].ttype != KET_FUNC) { // we should at least see a function and a left parenthesis\n\t\t\t\t*err |= KEE_FUNC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++op[n_op-2].n_args;\n\t\t\t++p;\n\t\t} else { // output-able token\n\t\t\tke1_t v;\n\t\t\tv = ke_read_token(p, &p, err, last_is_val);\n\t\t\tif (*err) break;\n\t\t\tif (v.ttype == KET_VAL) {\n\t\t\t\tu = push_back(&out, &n_out, &m_out);\n\t\t\t\t*u = v;\n\t\t\t\tlast_is_val = 1;\n\t\t\t} else if (v.ttype == KET_FUNC) {\n\t\t\t\tt = push_back(&op, &n_op, &m_op);\n\t\t\t\t*t = v;\n\t\t\t\tlast_is_val = 0;\n\t\t\t} else if (v.ttype == KET_OP) {\n\t\t\t\tint oi = ke_op[v.op];\n\t\t\t\twhile (n_op > 0 && op[n_op-1].ttype == KET_OP) {\n\t\t\t\t\tint pre = ke_op[op[n_op-1].op]>>1;\n\t\t\t\t\tif (((oi&1) && oi>>1 <= pre) || (!(oi&1) && oi>>1 < pre)) break;\n\t\t\t\t\tu = push_back(&out, &n_out, &m_out);\n\t\t\t\t\t*u = op[--n_op];\n\t\t\t\t}\n\t\t\t\tt = push_back(&op, &n_op, &m_op);\n\t\t\t\t*t = v;\n\t\t\t\tlast_is_val = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*err == 0) {\n\t\twhile (n_op > 0 && op[n_op-1].op >= 0) {\n\t\t\tu = push_back(&out, &n_out, &m_out);\n\t\t\t*u = op[--n_op];\n\t\t}\n\t\tif (n_op > 0) *err |= KEE_UNLP;\n\t}\n\t\n\tif (*err == 0) { // then check if the number of args is correct\n\t\tint i, n;\n\t\tfor (i = n = 0; i < n_out; ++i) {\n\t\t\tke1_t *e = &out[i];\n\t\t\tif (e->ttype == KET_VAL) ++n;\n\t\t\telse n -= e->n_args - 1;\n\t\t}\n\t\tif (n != 1) *err |= KEE_ARG;\n\t}\n\n\tfree(op); free(s);\n\tif (*err) {\n\t\tfree(out);\n\t\treturn 0;\n\t}\n\t*_n = n_out;\n\treturn out;\n}\n\nkexpr_t *ke_parse(const char *_s, int *err)\n{\n\tint n;\n\tke1_t *e;\n\tkexpr_t *ke;\n\te = ke_parse_core(_s, &n, err);\n\tif (*err) return 0;\n\tke = (kexpr_t*)calloc(1, sizeof(kexpr_t));\n\tke->n = n, ke->e = e;\n\treturn ke;\n}\n\nint ke_eval(const kexpr_t *ke, int64_t *_i, double *_r, const char **_p, int *ret_type)\n{\n\tke1_t *stack, *p, *q;\n\tint i, top = 0, err = 0;\n\t*_i = 0, *_r = 0., *ret_type = 0;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif ((e->ttype == KET_OP || e->ttype == KET_FUNC) && e->f.builtin == 0) err |= KEE_UNFUNC;\n\t\telse if (e->ttype == KET_VAL && e->name && e->assigned == 0) err |= KEE_UNVAR;\n\t}\n\tstack = (ke1_t*)malloc(ke->n * sizeof(ke1_t));\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_OP || e->ttype == KET_FUNC) {\n\t\t\tif (e->n_args == 2 && e->f.builtin) {\n\t\t\t\tq = &stack[--top], p = &stack[top-1];\n\t\t\t\tif (e->user_func) {\n\t\t\t\t\tif (e->user_func == KEF_REAL)\n\t\t\t\t\t\tp->r = e->f.real_func2(p->r, q->r), p->i = (int64_t)(p->r + .5), p->vtype = KEV_REAL;\n\t\t\t\t} else e->f.builtin(p, q);\n\t\t\t} else if (e->n_args == 1 && e->f.builtin) {\n\t\t\t\tp = &stack[top-1];\n\t\t\t\tif (e->user_func) {\n\t\t\t\t\tif (e->user_func == KEF_REAL)\n\t\t\t\t\t\tp->r = e->f.real_func1(p->r), p->i = (int64_t)(p->r + .5), p->vtype = KEV_REAL;\n\t\t\t\t} else e->f.builtin(&stack[top-1], 0);\n\t\t\t} else top -= e->n_args - 1;\n\t\t} else stack[top++] = *e;\n\t}\n\t*ret_type = stack->vtype;\n\t*_i = stack->i, *_r = stack->r, *_p = stack->s;\n\tfree(stack);\n\treturn err;\n}\t\n\nint64_t ke_eval_int(const kexpr_t *ke, int *err)\n{\n\tint int_ret;\n\tint64_t i;\n\tdouble r;\n\tconst char *s;\n\t*err = ke_eval(ke, &i, &r, &s, &int_ret);\n\treturn i;\n}\n\ndouble ke_eval_real(const kexpr_t *ke, int *err)\n{\n\tint int_ret;\n\tint64_t i;\n\tdouble r;\n\tconst char *s;\n\t*err = ke_eval(ke, &i, &r, &s, &int_ret);\n\treturn r;\n}\n\nvoid ke_destroy(kexpr_t *ke)\n{\n\tint i;\n\tif (ke == 0) return;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tfree(ke->e[i].name);\n\t\tfree(ke->e[i].s);\n\t}\n\tfree(ke->e); free(ke);\n}\n\nint ke_set_int(kexpr_t *ke, const char *var, int64_t y)\n{\n\tint i, n = 0;\n\tdouble yy = (double)y;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_VAL && e->name && strcmp(e->name, var) == 0)\n\t\t\te->i = y, e->r = yy, e->vtype = KEV_INT, e->assigned = 1, ++n;\n\t}\n\treturn n;\n}\n\nint ke_set_real(kexpr_t *ke, const char *var, double x)\n{\n\tint i, n = 0;\n\tint64_t xx = (int64_t)(x + .5);\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_VAL && e->name && strcmp(e->name, var) == 0)\n\t\t\te->r = x, e->i = xx, e->vtype = KEV_REAL, e->assigned = 1, ++n;\n\t}\n\treturn n;\n}\n\nint ke_set_str(kexpr_t *ke, const char *var, const char *x)\n{\n\tint i, n = 0;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_VAL && e->name && strcmp(e->name, var) == 0) {\n\t\t\tif (e->vtype == KEV_STR) free(e->s);\n\t\t\te->s = strdup(x);\n\t\t\te->i = 0, e->r = 0., e->assigned = 1;\n\t\t\te->vtype = KEV_STR;\n\t\t\t++n;\n\t\t}\n\t}\n\treturn n;\n}\n\nint ke_set_real_func1(kexpr_t *ke, const char *name, double (*func)(double))\n{\n\tint i, n = 0;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_FUNC && e->n_args == 1 && strcmp(e->name, name) == 0)\n\t\t\te->f.real_func1 = func, e->user_func = KEF_REAL, ++n;\n\t}\n\treturn n;\n}\n\nint ke_set_real_func2(kexpr_t *ke, const char *name, double (*func)(double, double))\n{\n\tint i, n = 0;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_FUNC && e->n_args == 2 && strcmp(e->name, name) == 0)\n\t\t\te->f.real_func2 = func, e->user_func = KEF_REAL, ++n;\n\t}\n\treturn n;\n}\n\nint ke_set_default_func(kexpr_t *ke)\n{\n\tint n = 0;\n\tn += ke_set_real_func1(ke, \"exp\", exp);\n\tn += ke_set_real_func1(ke, \"log\", log);\n\tn += ke_set_real_func1(ke, \"log10\", log10);\n\tn += ke_set_real_func1(ke, \"sqrt\", sqrt);\n\tn += ke_set_real_func1(ke, \"sin\", sin);\n\tn += ke_set_real_func1(ke, \"cos\", cos);\n\tn += ke_set_real_func1(ke, \"tan\", tan);\n\tn += ke_set_real_func2(ke, \"pow\", pow);\n\treturn n;\n}\n\nvoid ke_unset(kexpr_t *ke)\n{\n\tint i;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tke1_t *e = &ke->e[i];\n\t\tif (e->ttype == KET_VAL && e->name) e->assigned = 0;\n\t}\n}\n\nvoid ke_print(const kexpr_t *ke)\n{\n\tint i;\n\tif (ke == 0) return;\n\tfor (i = 0; i < ke->n; ++i) {\n\t\tconst ke1_t *u = &ke->e[i];\n\t\tif (i) putchar(' ');\n\t\tif (u->ttype == KET_VAL) {\n\t\t\tif (u->name) printf(\"%s\", u->name);\n\t\t\telse if (u->vtype == KEV_REAL) printf(\"%g\", u->r);\n\t\t\telse if (u->vtype == KEV_INT) printf(\"%lld\", (long long)u->i);\n\t\t\telse if (u->vtype == KEV_STR) printf(\"\\\"%s\\\"\", u->s);\n\t\t} else if (u->ttype == KET_OP) {\n\t\t\tprintf(\"%s\", ke_opstr[u->op]);\n\t\t} else if (u->ttype == KET_FUNC) {\n\t\t\tprintf(\"%s(%d)\", u->name, u->n_args);\n\t\t}\n\t}\n\tputchar('\\n');\n}\n\n\n#ifdef KE_MAIN\n#include <unistd.h>\n\nint main(int argc, char *argv[])\n{\n\tint c, err, to_print = 0, is_int = 0;\n\tkexpr_t *ke;\n\n\twhile ((c = getopt(argc, argv, \"pi\")) >= 0) {\n\t\tif (c == 'p') to_print = 1;\n\t\telse if (c == 'i') is_int = 1;\n\t}\n\tif (optind == argc) {\n\t\tfprintf(stderr, \"Usage: %s [-pi] <expr>\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\tke = ke_parse(argv[optind], &err);\n\tif (err) {\n\t\tfprintf(stderr, \"Parse error: 0x%x\\n\", err);\n\t\treturn 1;\n\t}\n\tke_set_default_func(ke);\n\tif (!to_print) {\n\t\tint64_t vi;\n\t\tdouble vr;\n\t\tconst char *vs;\n\t\tint i, ret_type;\n\t\tif (argc - optind > 1) {\n\t\t\tfor (i = optind + 1; i < argc; ++i) {\n\t\t\t\tchar *p, *s = argv[i];\n\t\t\t\tfor (p = s; *p && *p != '='; ++p);\n\t\t\t\tif (*p == 0) continue; // not an assignment\n\t\t\t\t*p = 0;\n\t\t\t\tke_set_real(ke, s, strtod(p+1, &p));\n\t\t\t}\n\t\t}\n\t\terr |= ke_eval(ke, &vi, &vr, &vs, &ret_type);\n\t\tif (err & KEE_UNFUNC)\n\t\t\tfprintf(stderr, \"Evaluation warning: an undefined function returns the first function argument.\\n\");\n\t\tif (err & KEE_UNVAR) fprintf(stderr, \"Evaluation warning: unassigned variables are set to 0.\\n\");\n\t\tif (ret_type == KEV_INT) printf(\"%lld\\n\", (long long)vi);\n\t\telse if (ret_type == KEV_REAL) printf(\"%g\\n\", vr);\n\t\telse printf(\"%s\\n\", vs);\n\t} else ke_print(ke);\n\tke_destroy(ke);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kexpr.h",
          "type": "blob",
          "size": 1.9580078125,
          "content": "#ifndef KEXPR_H\n#define KEXPR_H\n\n#include <stdint.h>\n\nstruct kexpr_s;\ntypedef struct kexpr_s kexpr_t;\n\n// Parse errors\n#define KEE_UNQU    0x01 // unmatched quotation marks\n#define KEE_UNLP    0x02 // unmatched left parentheses\n#define KEE_UNRP    0x04 // unmatched right parentheses\n#define KEE_UNOP    0x08 // unknown operators\n#define KEE_FUNC    0x10 // wrong function syntax\n#define KEE_ARG     0x20\n#define KEE_NUM     0x40 // fail to parse a number\n\n// Evaluation errors\n#define KEE_UNFUNC  0x40 // undefined function\n#define KEE_UNVAR   0x80 // unassigned variable\n\n// Return type\n#define KEV_REAL  1\n#define KEV_INT   2\n#define KEV_STR   3\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\t// parse an expression and return errors in $err\n\tkexpr_t *ke_parse(const char *_s, int *err);\n\n\t// free memory allocated during parsing\n\tvoid ke_destroy(kexpr_t *ke);\n\n\t// set a variable to integer value and return the occurrence of the variable\n\tint ke_set_int(kexpr_t *ke, const char *var, int64_t x);\n\n\t// set a variable to real value and return the occurrence of the variable\n\tint ke_set_real(kexpr_t *ke, const char *var, double x);\n\n\t// set a variable to string value and return the occurrence of the variable\n\tint ke_set_str(kexpr_t *ke, const char *var, const char *x);\n\n\t// set a user-defined function\n\tint ke_set_real_func1(kexpr_t *ke, const char *name, double (*func)(double));\n\tint ke_set_real_func2(kexpr_t *ke, const char *name, double (*func)(double, double));\n\n\t// set default math functions\n\tint ke_set_default_func(kexpr_t *ke);\n\n\t// mark all variable as unset\n\tvoid ke_unset(kexpr_t *e);\n\n\t// evaluate expression; return error code; final value is returned via pointers\n\tint ke_eval(const kexpr_t *ke, int64_t *_i, double *_r, const char **_s, int *ret_type);\n\tint64_t ke_eval_int(const kexpr_t *ke, int *err);\n\tdouble ke_eval_real(const kexpr_t *ke, int *err);\n\n\t// print the expression in Reverse Polish notation (RPN)\n\tvoid ke_print(const kexpr_t *ke);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "kgraph.h",
          "type": "blob",
          "size": 2.7275390625,
          "content": "#ifndef AC_KGRAPH_H\n#define AC_KGRAPH_H\n\n#include <stdint.h>\n#include <stdlib.h>\n#include \"khash.h\"\n#include \"kbtree.h\"\n\ntypedef unsigned kgint_t;\n\n#define kgraph_t(name) kh_##name##_t\n\n#define __KG_BASIC(name, SCOPE, vertex_t, arc_t, ehn) \\\n\tSCOPE kgraph_t(name) *kg_init_##name(void) { return kh_init(name); } \\\n\tSCOPE void kg_destroy_##name(kgraph_t(name) *g) { \\\n\t\tkhint_t k; \\\n\t\tif (g == 0) return; \\\n\t\tfor (k = kh_begin(g); k != kh_end(g); ++k) \\\n\t\t\tif (kh_exist(g, k)) kh_destroy(ehn, kh_val(g, k)._arc); \\\n\t\tkh_destroy(name, g); \\\n\t} \\\n\tSCOPE vertex_t *kg_get_v_##name(kgraph_t(name) *g, kgint_t v) { \\\n\t\tkhint_t k = kh_get(name, g, v); \\\n\t\treturn k == kh_end(g)? 0 : &kh_val(g, k); \\\n\t} \\\n\tSCOPE vertex_t *kg_put_v_##name(kgraph_t(name) *g, kgint_t v, int *absent) { \\\n\t\tkhint_t k; \\\n\t\tk = kh_put(name, g, v, absent); \\\n\t\tif (*absent) kh_val(g, k)._arc = kh_init(ehn); \\\n\t\treturn &kh_val(g, k); \\\n\t} \\\n\tSCOPE void kg_put_a_##name(kgraph_t(name) *g, kgint_t vbeg, kgint_t vend, int dir, arc_t **pb, arc_t **pe) { \\\n\t\tvertex_t *p; \\\n\t\tkhint_t k; \\\n\t\tint absent; \\\n\t\tp = kg_put_v_##name(g, vbeg, &absent); \\\n\t\tk = kh_put(ehn, p->_arc, vend<<2|dir, &absent); \\\n\t\t*pb = &kh_val(p->_arc, k); \\\n\t\tp = kg_put_v_##name(g, vend, &absent); \\\n\t\tk = kh_put(ehn, p->_arc, vbeg<<2|(~dir&3), &absent); \\\n\t\t*pe = &kh_val(p->_arc, k); \\\n\t} \\\n\tSCOPE vertex_t *kg_del_v_##name(kgraph_t(name) *g, kgint_t v) { \\\n\t\tkhint_t k, k0, k2, k3; \\\n\t\tkhash_t(ehn) *h; \\\n\t\tk0 = k = kh_get(name, g, v); \\\n\t\tif (k == kh_end(g)) return 0; /* not present in the graph */ \\\n\t\th = kh_val(g, k)._arc; \\\n\t\tfor (k = kh_begin(h); k != kh_end(h); ++k) /* remove v from its neighbors */ \\\n\t\t\tif (kh_exist(h, k)) { \\\n\t\t\t\tk2 = kh_get(name, g, kh_key(h, k)>>2); \\\n\t\t\t\t/* assert(k2 != kh_end(g)); */ \\\n\t\t\t\tk3 = kh_get(ehn, kh_val(g, k2)._arc, v<<2|(~kh_key(h, k)&3)); \\\n\t\t\t\t/* assert(k3 != kh_end(kh_val(g, k2)._arc)); */ \\\n\t\t\t\tkh_del(ehn, kh_val(g, k2)._arc, k3); \\\n\t\t\t} \\\n\t\tkh_destroy(ehn, h); \\\n\t\tkh_del(name, g, k0); \\\n\t\treturn &kh_val(g, k0); \\\n\t}\n\n#define KGRAPH_PRINT(name, SCOPE) \\\n\tSCOPE void kg_print_##name(kgraph_t(name) *g) { \\\n\t\tkhint_t k, k2; \\\n\t\tfor (k = kh_begin(g); k != kh_end(g); ++k) \\\n\t\t\tif (kh_exist(g, k)) { \\\n\t\t\t\tprintf(\"v %u\\n\", kh_key(g, k)); \\\n\t\t\t\tfor (k2 = kh_begin(kh_val(g, k)._arc); k2 != kh_end(kh_val(g, k)._arc); ++k2) \\\n\t\t\t\t\tif (kh_exist(kh_val(g, k)._arc, k2) && kh_key(g, k) < kh_key(kh_val(g, k)._arc, k2)>>2) \\\n\t\t\t\t\t\tprintf(\"a %u%c%c%u\\n\", kh_key(g, k), \"><\"[kh_key(kh_val(g, k)._arc, k2)>>1&1], \\\n\t\t\t\t\t\t\t\t\"><\"[kh_key(kh_val(g, k)._arc, k2)&1], kh_key(kh_val(g, k)._arc, k2)>>2); \\\n\t\t\t} \\\n\t}\n\n#define KGRAPH_INIT(name, SCOPE, vertex_t, arc_t, ehn) \\\n\tKHASH_INIT2(name, SCOPE, kgint_t, vertex_t, 1, kh_int_hash_func, kh_int_hash_equal) \\\n\t__KG_BASIC(name, SCOPE, vertex_t, arc_t, ehn)\n\n#endif\n"
        },
        {
          "name": "khash.h",
          "type": "blob",
          "size": 21.0380859375,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"khash.h\"\nKHASH_MAP_INIT_INT(32, char)\nint main() {\n\tint ret, is_missing;\n\tkhiter_t k;\n\tkhash_t(32) *h = kh_init(32);\n\tk = kh_put(32, h, 5, &ret);\n\tkh_value(h, k) = 10;\n\tk = kh_get(32, h, 10);\n\tis_missing = (k == kh_end(h));\n\tk = kh_get(32, h, 5);\n\tkh_del(32, h, k);\n\tfor (k = kh_begin(h); k != kh_end(h); ++k)\n\t\tif (kh_exist(h, k)) kh_value(h, k) = 1;\n\tkh_destroy(32, h);\n\treturn 0;\n}\n*/\n\n/*\n  2013-05-02 (0.2.8):\n\n\t* Use quadratic probing. When the capacity is power of 2, stepping function\n\t  i*(i+1)/2 guarantees to traverse each bucket. It is better than double\n\t  hashing on cache performance and is more robust than linear probing.\n\n\t  In theory, double hashing should be more robust than quadratic probing.\n\t  However, my implementation is probably not for large hash tables, because\n\t  the second hash function is closely tied to the first hash function,\n\t  which reduce the effectiveness of double hashing.\n\n\tReference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php\n\n  2011-12-29 (0.2.7):\n\n    * Minor code clean up; no actual effect.\n\n  2011-09-16 (0.2.6):\n\n\t* The capacity is a power of 2. This seems to dramatically improve the\n\t  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:\n\n\t   - http://code.google.com/p/ulib/\n\t   - http://nothings.org/computer/judy/\n\n\t* Allow to optionally use linear probing which usually has better\n\t  performance for random input. Double hashing is still the default as it\n\t  is more robust to certain non-random input.\n\n\t* Added Wang's integer hash function (not used by default). This hash\n\t  function is more robust to certain non-random input.\n\n  2011-02-14 (0.2.5):\n\n    * Allow to declare global functions.\n\n  2009-09-26 (0.2.4):\n\n    * Improve portability\n\n  2008-09-19 (0.2.3):\n\n\t* Corrected the example\n\t* Improved interfaces\n\n  2008-09-11 (0.2.2):\n\n\t* Improved speed a little in kh_put()\n\n  2008-09-10 (0.2.1):\n\n\t* Added kh_clear()\n\t* Fixed a compiling error\n\n  2008-09-02 (0.2.0):\n\n\t* Changed to token concatenation which increases flexibility.\n\n  2008-08-31 (0.1.2):\n\n\t* Fixed a bug in kh_get(), which has not been tested previously.\n\n  2008-08-31 (0.1.1):\n\n\t* Added destructor\n*/\n\n\n#ifndef __AC_KHASH_H\n#define __AC_KHASH_H\n\n/*!\n  @header\n\n  Generic hash table library.\n */\n\n#define AC_VERSION_KHASH_H \"0.2.8\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n/* compiler specific configuration */\n\n#if UINT_MAX == 0xffffffffu\ntypedef unsigned int khint32_t;\n#elif ULONG_MAX == 0xffffffffu\ntypedef unsigned long khint32_t;\n#endif\n\n#if ULONG_MAX == ULLONG_MAX\ntypedef unsigned long khint64_t;\n#else\ntypedef unsigned long long khint64_t;\n#endif\n\n#ifndef kh_inline\n#ifdef _MSC_VER\n#define kh_inline __inline\n#else\n#define kh_inline inline\n#endif\n#endif /* kh_inline */\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\ntypedef khint32_t khint_t;\ntypedef khint_t khiter_t;\n\n#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)\n#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)\n#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)\n#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))\n#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))\n#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))\n#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))\n\n#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#ifndef kcalloc\n#define kcalloc(N,Z) calloc(N,Z)\n#endif\n#ifndef kmalloc\n#define kmalloc(Z) malloc(Z)\n#endif\n#ifndef krealloc\n#define krealloc(P,Z) realloc(P,Z)\n#endif\n#ifndef kfree\n#define kfree(P) free(P)\n#endif\n\nstatic const double __ac_HASH_UPPER = 0.77;\n\n#define __KHASH_TYPE(name, khkey_t, khval_t) \\\n\ttypedef struct kh_##name##_s { \\\n\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\\n\t\tkhint32_t *flags; \\\n\t\tkhkey_t *keys; \\\n\t\tkhval_t *vals; \\\n\t} kh_##name##_t;\n\n#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)\t \t\t\t\t\t\\\n\textern kh_##name##_t *kh_init_##name(void);\t\t\t\t\t\t\t\\\n\textern void kh_destroy_##name(kh_##name##_t *h);\t\t\t\t\t\\\n\textern void kh_clear_##name(kh_##name##_t *h);\t\t\t\t\t\t\\\n\textern khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); \t\\\n\textern int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); \\\n\textern khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); \\\n\textern void kh_del_##name(kh_##name##_t *h, khint_t x);\n\n#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tSCOPE kh_##name##_t *kh_init_##name(void) {\t\t\t\t\t\t\t\\\n\t\treturn (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_destroy_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree((void *)h->keys); kfree(h->flags);\t\t\t\t\t\\\n\t\t\tkfree((void *)h->vals);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_clear_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h && h->flags) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \\\n\t\t\th->size = h->n_occupied = 0;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) \t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_buckets) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t k, i, last, mask, step = 0; \\\n\t\t\tmask = h->n_buckets - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t\tk = __hash_func(key); i = k & mask;\t\t\t\t\t\t\t\\\n\t\t\tlast = i; \\\n\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\ti = (i + (++step)) & mask; \\\n\t\t\t\tif (i == last) return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\treturn __ac_iseither(h->flags, i)? h->n_buckets : i;\t\t\\\n\t\t} else return 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \\\n\t{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \\\n\t\tkhint32_t *new_flags = 0;\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t j = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkroundup32(new_n_buckets); \t\t\t\t\t\t\t\t\t\\\n\t\t\tif (new_n_buckets < 4) new_n_buckets = 4;\t\t\t\t\t\\\n\t\t\tif (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;\t/* requested size is too small */ \\\n\t\t\telse { /* hash table size to be changed (shrink or expand); rehash */ \\\n\t\t\t\tnew_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));\t\\\n\t\t\t\tif (!new_flags) return -1;\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \\\n\t\t\t\tif (h->n_buckets < new_n_buckets) {\t/* expand */\t\t\\\n\t\t\t\t\tkhkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\t\tif (!new_keys) { kfree(new_flags); return -1; }\t\t\\\n\t\t\t\t\th->keys = new_keys;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tkhval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t\t\t\tif (!new_vals) { kfree(new_flags); return -1; }\t\\\n\t\t\t\t\t\th->vals = new_vals;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t} /* otherwise shrink */\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (j) { /* rehashing is needed */\t\t\t\t\t\t\t\t\\\n\t\t\tfor (j = 0; j != h->n_buckets; ++j) {\t\t\t\t\t\t\\\n\t\t\t\tif (__ac_iseither(h->flags, j) == 0) {\t\t\t\t\t\\\n\t\t\t\t\tkhkey_t key = h->keys[j];\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhval_t val;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhint_t new_mask;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tnew_mask = new_n_buckets - 1; \t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) val = h->vals[j];\t\t\t\t\t\\\n\t\t\t\t\t__ac_set_isdel_true(h->flags, j);\t\t\t\t\t\\\n\t\t\t\t\twhile (1) { /* kick-out process; sort of like in Cuckoo hashing */ \\\n\t\t\t\t\t\tkhint_t k, i, step = 0; \\\n\t\t\t\t\t\tk = __hash_func(key);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\ti = k & new_mask;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\twhile (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \\\n\t\t\t\t\t\t__ac_set_isempty_false(new_flags, i);\t\t\t\\\n\t\t\t\t\t\tif (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \\\n\t\t\t\t\t\t\t{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \\\n\t\t\t\t\t\t\tif (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \\\n\t\t\t\t\t\t\t__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \\\n\t\t\t\t\t\t} else { /* write the element and jump out of the loop */ \\\n\t\t\t\t\t\t\th->keys[i] = key;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tif (kh_is_map) h->vals[i] = val;\t\t\t\\\n\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \\\n\t\t\t\th->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\tif (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(h->flags); /* free the working space */\t\t\t\t\\\n\t\t\th->flags = new_flags;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\th->n_buckets = new_n_buckets;\t\t\t\t\t\t\t\t\\\n\t\t\th->n_occupied = h->size;\t\t\t\t\t\t\t\t\t\\\n\t\t\th->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_occupied >= h->upper_bound) { /* update the hash table */ \\\n\t\t\tif (h->n_buckets > (h->size<<1)) {\t\t\t\t\t\t\t\\\n\t\t\t\tif (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear \"deleted\" elements */ \\\n\t\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \\\n\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \\\n\t\t\tx = site = h->n_buckets; k = __hash_func(key); i = k & mask; \\\n\t\t\tif (__ac_isempty(h->flags, i)) x = i; /* for speed up */\t\\\n\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tlast = i; \\\n\t\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\t\tif (__ac_isdel(h->flags, i)) site = i;\t\t\t\t\\\n\t\t\t\t\ti = (i + (++step)) & mask; \\\n\t\t\t\t\tif (i == last) { x = site; break; }\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (x == h->n_buckets) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \\\n\t\t\t\t\telse x = i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (__ac_isempty(h->flags, x)) { /* not present at all */\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size; ++h->n_occupied;\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else if (__ac_isdel(h->flags, x)) { /* deleted */\t\t\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 2;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \\\n\t\treturn x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x != h->n_buckets && !__ac_iseither(h->flags, x)) {\t\t\t\\\n\t\t\t__ac_set_isdel_true(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t--h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)\n\n#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tKHASH_INIT2(name, static kh_inline klib_unused, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n/* --- BEGIN OF HASH FUNCTIONS --- */\n\n/*! @function\n  @abstract     Integer hash function\n  @param  key   The integer [khint32_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int_hash_func(key) (khint32_t)(key)\n/*! @function\n  @abstract     Integer comparison function\n */\n#define kh_int_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     64-bit integer hash function\n  @param  key   The integer [khint64_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)\n/*! @function\n  @abstract     64-bit integer comparison function\n */\n#define kh_int64_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     const char* hash function\n  @param  s     Pointer to a null terminated string\n  @return       The hash value\n */\nstatic kh_inline khint_t __ac_X31_hash_string(const char *s)\n{\n\tkhint_t h = (khint_t)*s;\n\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;\n\treturn h;\n}\n/*! @function\n  @abstract     Another interface to const char* hash function\n  @param  key   Pointer to a null terminated string [const char*]\n  @return       The hash value [khint_t]\n */\n#define kh_str_hash_func(key) __ac_X31_hash_string(key)\n/*! @function\n  @abstract     Const char* comparison function\n */\n#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)\n\nstatic kh_inline khint_t __ac_Wang_hash(khint_t key)\n{\n    key += ~(key << 15);\n    key ^=  (key >> 10);\n    key +=  (key << 3);\n    key ^=  (key >> 6);\n    key += ~(key << 11);\n    key ^=  (key >> 16);\n    return key;\n}\n#define kh_int_hash_func2(key) __ac_Wang_hash((khint_t)key)\n\n/* --- END OF HASH FUNCTIONS --- */\n\n/* Other convenient macros... */\n\n/*!\n  @abstract Type of the hash table.\n  @param  name  Name of the hash table [symbol]\n */\n#define khash_t(name) kh_##name##_t\n\n/*! @function\n  @abstract     Initiate a hash table.\n  @param  name  Name of the hash table [symbol]\n  @return       Pointer to the hash table [khash_t(name)*]\n */\n#define kh_init(name) kh_init_##name()\n\n/*! @function\n  @abstract     Destroy a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_destroy(name, h) kh_destroy_##name(h)\n\n/*! @function\n  @abstract     Reset a hash table without deallocating memory.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_clear(name, h) kh_clear_##name(h)\n\n/*! @function\n  @abstract     Resize a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  s     New size [khint_t]\n */\n#define kh_resize(name, h, s) kh_resize_##name(h, s)\n\n/*! @function\n  @abstract     Insert a key to the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @param  r     Extra return code: -1 if the operation failed;\n                0 if the key is present in the hash table;\n                1 if the bucket is empty (never used); 2 if the element in\n\t\t\t\tthe bucket has been deleted [int*]\n  @return       Iterator to the inserted element [khint_t]\n */\n#define kh_put(name, h, k, r) kh_put_##name(h, k, r)\n\n/*! @function\n  @abstract     Retrieve a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @return       Iterator to the found element, or kh_end(h) if the element is absent [khint_t]\n */\n#define kh_get(name, h, k) kh_get_##name(h, k)\n\n/*! @function\n  @abstract     Remove a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Iterator to the element to be deleted [khint_t]\n */\n#define kh_del(name, h, k) kh_del_##name(h, k)\n\n/*! @function\n  @abstract     Test whether a bucket contains data.\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       1 if containing data; 0 otherwise [int]\n */\n#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))\n\n/*! @function\n  @abstract     Get key given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Key [type of keys]\n */\n#define kh_key(h, x) ((h)->keys[x])\n\n/*! @function\n  @abstract     Get value given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Value [type of values]\n  @discussion   For hash sets, calling this results in segfault.\n */\n#define kh_val(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Alias of kh_val()\n */\n#define kh_value(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Get the start iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The start iterator [khint_t]\n */\n#define kh_begin(h) (khint_t)(0)\n\n/*! @function\n  @abstract     Get the end iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The end iterator [khint_t]\n */\n#define kh_end(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Get the number of elements in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of elements in the hash table [khint_t]\n */\n#define kh_size(h) ((h)->size)\n\n/*! @function\n  @abstract     Get the number of buckets in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of buckets in the hash table [khint_t]\n */\n#define kh_n_buckets(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Iterate over the entries in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  kvar  Variable to which key will be assigned\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/*! @function\n  @abstract     Iterate over the values in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/* More convenient interfaces */\n\n/*! @function\n  @abstract     Instantiate a hash set containing integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash set containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)\n\ntypedef const char *kh_cstr_t;\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_STR(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)\n\n#endif /* __AC_KHASH_H */\n"
        },
        {
          "name": "khashl.h",
          "type": "blob",
          "size": 20.349609375,
          "content": "/* The MIT License\n\n   Copyright (c) 2019- by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#ifndef __AC_KHASHL_H\n#define __AC_KHASHL_H\n\n#define AC_VERSION_KHASHL_H \"r30\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n/************************************\n * Compiler specific configurations *\n ************************************/\n\n#if UINT_MAX == 0xffffffffu\ntypedef unsigned int khint32_t;\n#elif ULONG_MAX == 0xffffffffu\ntypedef unsigned long khint32_t;\n#endif\n\n#if ULONG_MAX == ULLONG_MAX\ntypedef unsigned long khint64_t;\n#else\ntypedef unsigned long long khint64_t;\n#endif\n\n#ifndef kh_inline\n#ifdef _MSC_VER\n#define kh_inline __inline\n#else\n#define kh_inline inline\n#endif\n#endif /* kh_inline */\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define KH_LOCAL static kh_inline klib_unused\n\ntypedef khint32_t khint_t;\ntypedef const char *kh_cstr_t;\n\n/***********************\n * Configurable macros *\n ***********************/\n\n#ifndef kh_max_count /* set the max load factor */\n#define kh_max_count(cap) (((cap)>>1) + ((cap)>>2)) /* default load factor: 75% */\n#endif\n\n#ifndef kh_packed /* pack the key-value struct */\n#define kh_packed __attribute__ ((__packed__))\n#endif\n\n#if !defined(Kmalloc) || !defined(Kcalloc) || !defined(Krealloc) || !defined(Kfree)\n#define Kmalloc(km, type, cnt)       ((type*)malloc((cnt) * sizeof(type)))\n#define Kcalloc(km, type, cnt)       ((type*)calloc((cnt), sizeof(type)))\n#define Krealloc(km, type, ptr, cnt) ((type*)realloc((ptr), (cnt) * sizeof(type)))\n#define Kfree(km, ptr)               free(ptr)\n#endif\n\n/****************************\n * Simple private functions *\n ****************************/\n\n#define __kh_used(flag, i)       (flag[i>>5] >> (i&0x1fU) & 1U)\n#define __kh_set_used(flag, i)   (flag[i>>5] |= 1U<<(i&0x1fU))\n#define __kh_set_unused(flag, i) (flag[i>>5] &= ~(1U<<(i&0x1fU)))\n\n#define __kh_fsize(m) ((m) < 32? 1 : (m)>>5)\n\nstatic kh_inline khint_t __kh_h2b(khint_t hash, khint_t bits) { return hash * 2654435769U >> (32 - bits); } /* Fibonacci hashing */\n\n/*******************\n * Hash table base *\n *******************/\n\n#define __KHASHL_TYPE(HType, khkey_t) \\\n\ttypedef struct HType { \\\n\t\tvoid *km; \\\n\t\tkhint_t bits, count; \\\n\t\tkhint32_t *used; \\\n\t\tkhkey_t *keys; \\\n\t} HType;\n\n#define __KHASHL_PROTOTYPES(HType, prefix, khkey_t) \\\n\textern HType *prefix##_init(void); \\\n\textern HType *prefix##_init2(void *km); \\\n\textern void prefix##_destroy(HType *h); \\\n\textern void prefix##_clear(HType *h); \\\n\textern khint_t prefix##_getp(const HType *h, const khkey_t *key); \\\n\textern int prefix##_resize(HType *h, khint_t new_n_buckets); \\\n\textern khint_t prefix##_putp(HType *h, const khkey_t *key, int *absent); \\\n\textern void prefix##_del(HType *h, khint_t k);\n\n#define __KHASHL_IMPL_BASIC(SCOPE, HType, prefix) \\\n\tSCOPE HType *prefix##_init2(void *km) { \\\n\t\tHType *h = Kcalloc(km, HType, 1); \\\n\t\th->km = km; \\\n\t\treturn h; \\\n\t} \\\n\tSCOPE HType *prefix##_init(void) { return prefix##_init2(0); } \\\n\tSCOPE void prefix##_destroy(HType *h) { \\\n\t\tif (!h) return; \\\n\t\tKfree(h->km, (void*)h->keys); Kfree(h->km, h->used); \\\n\t\tKfree(h->km, h); \\\n\t} \\\n\tSCOPE void prefix##_clear(HType *h) { \\\n\t\tif (h && h->used) { \\\n\t\t\tkhint_t n_buckets = (khint_t)1U << h->bits; \\\n\t\t\tmemset(h->used, 0, __kh_fsize(n_buckets) * sizeof(khint32_t)); \\\n\t\t\th->count = 0; \\\n\t\t} \\\n\t}\n\n#define __KHASHL_IMPL_GET(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\tSCOPE khint_t prefix##_getp_core(const HType *h, const khkey_t *key, khint_t hash) { \\\n\t\tkhint_t i, last, n_buckets, mask; \\\n\t\tif (h->keys == 0) return 0; \\\n\t\tn_buckets = (khint_t)1U << h->bits; \\\n\t\tmask = n_buckets - 1U; \\\n\t\ti = last = __kh_h2b(hash, h->bits); \\\n\t\twhile (__kh_used(h->used, i) && !__hash_eq(h->keys[i], *key)) { \\\n\t\t\ti = (i + 1U) & mask; \\\n\t\t\tif (i == last) return n_buckets; \\\n\t\t} \\\n\t\treturn !__kh_used(h->used, i)? n_buckets : i; \\\n\t} \\\n\tSCOPE khint_t prefix##_getp(const HType *h, const khkey_t *key) { return prefix##_getp_core(h, key, __hash_fn(*key)); } \\\n\tSCOPE khint_t prefix##_get(const HType *h, khkey_t key) { return prefix##_getp_core(h, &key, __hash_fn(key)); }\n\n#define __KHASHL_IMPL_RESIZE(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\tSCOPE int prefix##_resize(HType *h, khint_t new_n_buckets) { \\\n\t\tkhint32_t *new_used = 0; \\\n\t\tkhint_t j = 0, x = new_n_buckets, n_buckets, new_bits, new_mask; \\\n\t\twhile ((x >>= 1) != 0) ++j; \\\n\t\tif (new_n_buckets & (new_n_buckets - 1)) ++j; \\\n\t\tnew_bits = j > 2? j : 2; \\\n\t\tnew_n_buckets = (khint_t)1U << new_bits; \\\n\t\tif (h->count > kh_max_count(new_n_buckets)) return 0; /* requested size is too small */ \\\n\t\tnew_used = Kmalloc(h->km, khint32_t, __kh_fsize(new_n_buckets)); \\\n\t\tmemset(new_used, 0, __kh_fsize(new_n_buckets) * sizeof(khint32_t)); \\\n\t\tif (!new_used) return -1; /* not enough memory */ \\\n\t\tn_buckets = h->keys? (khint_t)1U<<h->bits : 0U; \\\n\t\tif (n_buckets < new_n_buckets) { /* expand */ \\\n\t\t\tkhkey_t *new_keys = Krealloc(h->km, khkey_t, h->keys, new_n_buckets); \\\n\t\t\tif (!new_keys) { Kfree(h->km, new_used); return -1; } \\\n\t\t\th->keys = new_keys; \\\n\t\t} /* otherwise shrink */ \\\n\t\tnew_mask = new_n_buckets - 1; \\\n\t\tfor (j = 0; j != n_buckets; ++j) { \\\n\t\t\tkhkey_t key; \\\n\t\t\tif (!__kh_used(h->used, j)) continue; \\\n\t\t\tkey = h->keys[j]; \\\n\t\t\t__kh_set_unused(h->used, j); \\\n\t\t\twhile (1) { /* kick-out process; sort of like in Cuckoo hashing */ \\\n\t\t\t\tkhint_t i; \\\n\t\t\t\ti = __kh_h2b(__hash_fn(key), new_bits); \\\n\t\t\t\twhile (__kh_used(new_used, i)) i = (i + 1) & new_mask; \\\n\t\t\t\t__kh_set_used(new_used, i); \\\n\t\t\t\tif (i < n_buckets && __kh_used(h->used, i)) { /* kick out the existing element */ \\\n\t\t\t\t\t{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \\\n\t\t\t\t\t__kh_set_unused(h->used, i); /* mark it as deleted in the old hash table */ \\\n\t\t\t\t} else { /* write the element and jump out of the loop */ \\\n\t\t\t\t\th->keys[i] = key; \\\n\t\t\t\t\tbreak; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\tif (n_buckets > new_n_buckets) /* shrink the hash table */ \\\n\t\t\th->keys = Krealloc(h->km, khkey_t, (void*)h->keys, new_n_buckets); \\\n\t\tKfree(h->km, h->used); /* free the working space */ \\\n\t\th->used = new_used, h->bits = new_bits; \\\n\t\treturn 0; \\\n\t}\n\n#define __KHASHL_IMPL_PUT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\tSCOPE khint_t prefix##_putp_core(HType *h, const khkey_t *key, khint_t hash, int *absent) { \\\n\t\tkhint_t n_buckets, i, last, mask; \\\n\t\tn_buckets = h->keys? (khint_t)1U<<h->bits : 0U; \\\n\t\t*absent = -1; \\\n\t\tif (h->count >= kh_max_count(n_buckets)) { /* rehashing */ \\\n\t\t\tif (prefix##_resize(h, n_buckets + 1U) < 0) \\\n\t\t\t\treturn n_buckets; \\\n\t\t\tn_buckets = (khint_t)1U<<h->bits; \\\n\t\t} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \\\n\t\tmask = n_buckets - 1; \\\n\t\ti = last = __kh_h2b(hash, h->bits); \\\n\t\twhile (__kh_used(h->used, i) && !__hash_eq(h->keys[i], *key)) { \\\n\t\t\ti = (i + 1U) & mask; \\\n\t\t\tif (i == last) break; \\\n\t\t} \\\n\t\tif (!__kh_used(h->used, i)) { /* not present at all */ \\\n\t\t\th->keys[i] = *key; \\\n\t\t\t__kh_set_used(h->used, i); \\\n\t\t\t++h->count; \\\n\t\t\t*absent = 1; \\\n\t\t} else *absent = 0; /* Don't touch h->keys[i] if present */ \\\n\t\treturn i; \\\n\t} \\\n\tSCOPE khint_t prefix##_putp(HType *h, const khkey_t *key, int *absent) { return prefix##_putp_core(h, key, __hash_fn(*key), absent); } \\\n\tSCOPE khint_t prefix##_put(HType *h, khkey_t key, int *absent) { return prefix##_putp_core(h, &key, __hash_fn(key), absent); }\n\n#define __KHASHL_IMPL_DEL(SCOPE, HType, prefix, khkey_t, __hash_fn) \\\n\tSCOPE int prefix##_del(HType *h, khint_t i) { \\\n\t\tkhint_t j = i, k, mask, n_buckets; \\\n\t\tif (h->keys == 0) return 0; \\\n\t\tn_buckets = (khint_t)1U<<h->bits; \\\n\t\tmask = n_buckets - 1U; \\\n\t\twhile (1) { \\\n\t\t\tj = (j + 1U) & mask; \\\n\t\t\tif (j == i || !__kh_used(h->used, j)) break; /* j==i only when the table is completely full */ \\\n\t\t\tk = __kh_h2b(__hash_fn(h->keys[j]), h->bits); \\\n\t\t\tif ((j > i && (k <= i || k > j)) || (j < i && (k <= i && k > j))) \\\n\t\t\t\th->keys[i] = h->keys[j], i = j; \\\n\t\t} \\\n\t\t__kh_set_unused(h->used, i); \\\n\t\t--h->count; \\\n\t\treturn 1; \\\n\t}\n\n#define KHASHL_DECLARE(HType, prefix, khkey_t) \\\n\t__KHASHL_TYPE(HType, khkey_t) \\\n\t__KHASHL_PROTOTYPES(HType, prefix, khkey_t)\n\n#define KHASHL_INIT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\t__KHASHL_TYPE(HType, khkey_t) \\\n\t__KHASHL_IMPL_BASIC(SCOPE, HType, prefix) \\\n\t__KHASHL_IMPL_GET(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\t__KHASHL_IMPL_RESIZE(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\t__KHASHL_IMPL_PUT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\t__KHASHL_IMPL_DEL(SCOPE, HType, prefix, khkey_t, __hash_fn)\n\n/***************************\n * Ensemble of hash tables *\n ***************************/\n\ntypedef struct {\n\tkhint_t sub, pos;\n} kh_ensitr_t;\n\n#define KHASHE_INIT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\tKHASHL_INIT(KH_LOCAL, HType##_sub, prefix##_sub, khkey_t, __hash_fn, __hash_eq) \\\n\ttypedef struct HType { \\\n\t\tvoid *km; \\\n\t\tkhint64_t count:54, bits:8; \\\n\t\tHType##_sub *sub; \\\n\t} HType; \\\n\tSCOPE HType *prefix##_init2(void *km, int bits) { \\\n\t\tHType *g; \\\n\t\tg = Kcalloc(km, HType, 1); \\\n\t\tg->bits = bits, g->km = km; \\\n\t\tg->sub = Kcalloc(km, HType##_sub, 1U<<bits); \\\n\t\treturn g; \\\n\t} \\\n\tSCOPE HType *prefix##_init(int bits) { return prefix##_init2(0, bits); } \\\n\tSCOPE void prefix##_destroy(HType *g) { \\\n\t\tint t; \\\n\t\tif (!g) return; \\\n\t\tfor (t = 0; t < 1<<g->bits; ++t) { Kfree(g->km, (void*)g->sub[t].keys); Kfree(g->km, g->sub[t].used); } \\\n\t\tKfree(g->km, g->sub); Kfree(g->km, g); \\\n\t} \\\n\tSCOPE kh_ensitr_t prefix##_getp(const HType *g, const khkey_t *key) { \\\n\t\tkhint_t hash, low, ret; \\\n\t\tkh_ensitr_t r; \\\n\t\tHType##_sub *h; \\\n\t\thash = __hash_fn(*key); \\\n\t\tlow = hash & ((1U<<g->bits) - 1); \\\n\t\th = &g->sub[low]; \\\n\t\tret = prefix##_sub_getp_core(h, key, hash); \\\n\t\tif (ret == kh_end(h)) r.sub = low, r.pos = (khint_t)-1; \\\n\t\telse r.sub = low, r.pos = ret; \\\n\t\treturn r; \\\n\t} \\\n\tSCOPE kh_ensitr_t prefix##_get(const HType *g, const khkey_t key) { return prefix##_getp(g, &key); } \\\n\tSCOPE kh_ensitr_t prefix##_putp(HType *g, const khkey_t *key, int *absent) { \\\n\t\tkhint_t hash, low, ret; \\\n\t\tkh_ensitr_t r; \\\n\t\tHType##_sub *h; \\\n\t\thash = __hash_fn(*key); \\\n\t\tlow = hash & ((1U<<g->bits) - 1); \\\n\t\th = &g->sub[low]; \\\n\t\tret = prefix##_sub_putp_core(h, key, hash, absent); \\\n\t\tif (*absent) ++g->count; \\\n\t\tr.sub = low, r.pos = ret; \\\n\t\treturn r; \\\n\t} \\\n\tSCOPE kh_ensitr_t prefix##_put(HType *g, const khkey_t key, int *absent) { return prefix##_putp(g, &key, absent); } \\\n\tSCOPE int prefix##_del(HType *g, kh_ensitr_t itr) { \\\n\t\tHType##_sub *h = &g->sub[itr.sub]; \\\n\t\tint ret; \\\n\t\tret = prefix##_sub_del(h, itr.pos); \\\n\t\tif (ret) --g->count; \\\n\t\treturn ret; \\\n\t} \\\n\tSCOPE void prefix##_clear(HType *g) { \\\n\t\tint i; \\\n\t\tfor (i = 0; i < 1U<<g->bits; ++i) prefix##_sub_clear(&g->sub[i]); \\\n\t\tg->count = 0; \\\n\t}\n\n/*****************************\n * More convenient interface *\n *****************************/\n\n/* common */\n\n#define KHASHL_SET_INIT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\ttypedef struct { khkey_t key; } kh_packed HType##_s_bucket_t; \\\n\tstatic kh_inline khint_t prefix##_s_hash(HType##_s_bucket_t x) { return __hash_fn(x.key); } \\\n\tstatic kh_inline int prefix##_s_eq(HType##_s_bucket_t x, HType##_s_bucket_t y) { return __hash_eq(x.key, y.key); } \\\n\tKHASHL_INIT(KH_LOCAL, HType, prefix##_s, HType##_s_bucket_t, prefix##_s_hash, prefix##_s_eq) \\\n\tSCOPE HType *prefix##_init(void) { return prefix##_s_init(); } \\\n\tSCOPE HType *prefix##_init2(void *km) { return prefix##_s_init2(km); } \\\n\tSCOPE void prefix##_destroy(HType *h) { prefix##_s_destroy(h); } \\\n\tSCOPE void prefix##_resize(HType *h, khint_t new_n_buckets) { prefix##_s_resize(h, new_n_buckets); } \\\n\tSCOPE khint_t prefix##_get(const HType *h, khkey_t key) { HType##_s_bucket_t t; t.key = key; return prefix##_s_getp(h, &t); } \\\n\tSCOPE int prefix##_del(HType *h, khint_t k) { return prefix##_s_del(h, k); } \\\n\tSCOPE khint_t prefix##_put(HType *h, khkey_t key, int *absent) { HType##_s_bucket_t t; t.key = key; return prefix##_s_putp(h, &t, absent); } \\\n\tSCOPE void prefix##_clear(HType *h) { prefix##_s_clear(h); }\n\n#define KHASHL_MAP_INIT(SCOPE, HType, prefix, khkey_t, kh_val_t, __hash_fn, __hash_eq) \\\n\ttypedef struct { khkey_t key; kh_val_t val; } kh_packed HType##_m_bucket_t; \\\n\tstatic kh_inline khint_t prefix##_m_hash(HType##_m_bucket_t x) { return __hash_fn(x.key); } \\\n\tstatic kh_inline int prefix##_m_eq(HType##_m_bucket_t x, HType##_m_bucket_t y) { return __hash_eq(x.key, y.key); } \\\n\tKHASHL_INIT(KH_LOCAL, HType, prefix##_m, HType##_m_bucket_t, prefix##_m_hash, prefix##_m_eq) \\\n\tSCOPE HType *prefix##_init(void) { return prefix##_m_init(); } \\\n\tSCOPE HType *prefix##_init2(void *km) { return prefix##_m_init2(km); } \\\n\tSCOPE void prefix##_destroy(HType *h) { prefix##_m_destroy(h); } \\\n\tSCOPE void prefix##_resize(HType *h, khint_t new_n_buckets) { prefix##_m_resize(h, new_n_buckets); } \\\n\tSCOPE khint_t prefix##_get(const HType *h, khkey_t key) { HType##_m_bucket_t t; t.key = key; return prefix##_m_getp(h, &t); } \\\n\tSCOPE int prefix##_del(HType *h, khint_t k) { return prefix##_m_del(h, k); } \\\n\tSCOPE khint_t prefix##_put(HType *h, khkey_t key, int *absent) { HType##_m_bucket_t t; t.key = key; return prefix##_m_putp(h, &t, absent); } \\\n\tSCOPE void prefix##_clear(HType *h) { prefix##_m_clear(h); }\n\n/* cached hashes to trade memory for performance when hashing and comparison are expensive */\n\n#define __kh_cached_hash(x) ((x).hash)\n\n#define KHASHL_CSET_INIT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\ttypedef struct { khkey_t key; khint_t hash; } kh_packed HType##_cs_bucket_t; \\\n\tstatic kh_inline int prefix##_cs_eq(HType##_cs_bucket_t x, HType##_cs_bucket_t y) { return x.hash == y.hash && __hash_eq(x.key, y.key); } \\\n\tKHASHL_INIT(KH_LOCAL, HType, prefix##_cs, HType##_cs_bucket_t, __kh_cached_hash, prefix##_cs_eq) \\\n\tSCOPE HType *prefix##_init(void) { return prefix##_cs_init(); } \\\n\tSCOPE void prefix##_destroy(HType *h) { prefix##_cs_destroy(h); } \\\n\tSCOPE khint_t prefix##_get(const HType *h, khkey_t key) { HType##_cs_bucket_t t; t.key = key; t.hash = __hash_fn(key); return prefix##_cs_getp(h, &t); } \\\n\tSCOPE int prefix##_del(HType *h, khint_t k) { return prefix##_cs_del(h, k); } \\\n\tSCOPE khint_t prefix##_put(HType *h, khkey_t key, int *absent) { HType##_cs_bucket_t t; t.key = key, t.hash = __hash_fn(key); return prefix##_cs_putp(h, &t, absent); } \\\n\tSCOPE void prefix##_clear(HType *h) { prefix##_cs_clear(h); }\n\n#define KHASHL_CMAP_INIT(SCOPE, HType, prefix, khkey_t, kh_val_t, __hash_fn, __hash_eq) \\\n\ttypedef struct { khkey_t key; kh_val_t val; khint_t hash; } kh_packed HType##_cm_bucket_t; \\\n\tstatic kh_inline int prefix##_cm_eq(HType##_cm_bucket_t x, HType##_cm_bucket_t y) { return x.hash == y.hash && __hash_eq(x.key, y.key); } \\\n\tKHASHL_INIT(KH_LOCAL, HType, prefix##_cm, HType##_cm_bucket_t, __kh_cached_hash, prefix##_cm_eq) \\\n\tSCOPE HType *prefix##_init(void) { return prefix##_cm_init(); } \\\n\tSCOPE void prefix##_destroy(HType *h) { prefix##_cm_destroy(h); } \\\n\tSCOPE khint_t prefix##_get(const HType *h, khkey_t key) { HType##_cm_bucket_t t; t.key = key; t.hash = __hash_fn(key); return prefix##_cm_getp(h, &t); } \\\n\tSCOPE int prefix##_del(HType *h, khint_t k) { return prefix##_cm_del(h, k); } \\\n\tSCOPE khint_t prefix##_put(HType *h, khkey_t key, int *absent) { HType##_cm_bucket_t t; t.key = key, t.hash = __hash_fn(key); return prefix##_cm_putp(h, &t, absent); } \\\n\tSCOPE void prefix##_clear(HType *h) { prefix##_cm_clear(h); }\n\n/* ensemble for huge hash tables */\n\n#define KHASHE_SET_INIT(SCOPE, HType, prefix, khkey_t, __hash_fn, __hash_eq) \\\n\ttypedef struct { khkey_t key; } kh_packed HType##_es_bucket_t; \\\n\tstatic kh_inline khint_t prefix##_es_hash(HType##_es_bucket_t x) { return __hash_fn(x.key); } \\\n\tstatic kh_inline int prefix##_es_eq(HType##_es_bucket_t x, HType##_es_bucket_t y) { return __hash_eq(x.key, y.key); } \\\n\tKHASHE_INIT(KH_LOCAL, HType, prefix##_es, HType##_es_bucket_t, prefix##_es_hash, prefix##_es_eq) \\\n\tSCOPE HType *prefix##_init(int bits) { return prefix##_es_init(bits); } \\\n\tSCOPE void prefix##_destroy(HType *h) { prefix##_es_destroy(h); } \\\n\tSCOPE kh_ensitr_t prefix##_get(const HType *h, khkey_t key) { HType##_es_bucket_t t; t.key = key; return prefix##_es_getp(h, &t); } \\\n\tSCOPE int prefix##_del(HType *h, kh_ensitr_t k) { return prefix##_es_del(h, k); } \\\n\tSCOPE kh_ensitr_t prefix##_put(HType *h, khkey_t key, int *absent) { HType##_es_bucket_t t; t.key = key; return prefix##_es_putp(h, &t, absent); } \\\n\tSCOPE void prefix##_clear(HType *h) { prefix##_es_clear(h); }\n\n#define KHASHE_MAP_INIT(SCOPE, HType, prefix, khkey_t, kh_val_t, __hash_fn, __hash_eq) \\\n\ttypedef struct { khkey_t key; kh_val_t val; } kh_packed HType##_em_bucket_t; \\\n\tstatic kh_inline khint_t prefix##_em_hash(HType##_em_bucket_t x) { return __hash_fn(x.key); } \\\n\tstatic kh_inline int prefix##_em_eq(HType##_em_bucket_t x, HType##_em_bucket_t y) { return __hash_eq(x.key, y.key); } \\\n\tKHASHE_INIT(KH_LOCAL, HType, prefix##_em, HType##_em_bucket_t, prefix##_em_hash, prefix##_em_eq) \\\n\tSCOPE HType *prefix##_init(int bits) { return prefix##_em_init(bits); } \\\n\tSCOPE void prefix##_destroy(HType *h) { prefix##_em_destroy(h); } \\\n\tSCOPE kh_ensitr_t prefix##_get(const HType *h, khkey_t key) { HType##_em_bucket_t t; t.key = key; return prefix##_em_getp(h, &t); } \\\n\tSCOPE int prefix##_del(HType *h, kh_ensitr_t k) { return prefix##_em_del(h, k); } \\\n\tSCOPE kh_ensitr_t prefix##_put(HType *h, khkey_t key, int *absent) { HType##_em_bucket_t t; t.key = key; return prefix##_em_putp(h, &t, absent); } \\\n\tSCOPE void prefix##_clear(HType *h) { prefix##_em_clear(h); }\n\n/**************************\n * Public macro functions *\n **************************/\n\n#define kh_bucket(h, x) ((h)->keys[x])\n#define kh_size(h) ((h)->count)\n#define kh_capacity(h) ((h)->keys? 1U<<(h)->bits : 0U)\n#define kh_end(h) kh_capacity(h)\n\n#define kh_key(h, x) ((h)->keys[x].key)\n#define kh_val(h, x) ((h)->keys[x].val)\n#define kh_exist(h, x) __kh_used((h)->used, (x))\n\n#define kh_foreach(h, x) for ((x) = 0; (x) != kh_end(h); ++(x)) if (kh_exist((h), (x)))\n\n#define kh_ens_key(g, x) kh_key(&(g)->sub[(x).sub], (x).pos)\n#define kh_ens_val(g, x) kh_val(&(g)->sub[(x).sub], (x).pos)\n#define kh_ens_exist(g, x) kh_exist(&(g)->sub[(x).sub], (x).pos)\n#define kh_ens_is_end(x) ((x).pos == (khint_t)-1)\n#define kh_ens_size(g) ((g)->count)\n\n#define kh_ens_foreach(g, x) for ((x).sub = 0; (x).sub != 1<<(g)->bits; ++(x).sub) for ((x).pos = 0; (x).pos != kh_end(&(g)->sub[(x).sub]); ++(x).pos) if (kh_ens_exist((g), (x)))\n\n/**************************************\n * Common hash and equality functions *\n **************************************/\n\n#define kh_eq_generic(a, b) ((a) == (b))\n#define kh_eq_str(a, b) (strcmp((a), (b)) == 0)\n#define kh_hash_dummy(x) ((khint_t)(x))\n\nstatic kh_inline khint_t kh_hash_uint32(khint_t x) { /* murmur finishing */\n\tx ^= x >> 16;\n\tx *= 0x85ebca6bU;\n\tx ^= x >> 13;\n\tx *= 0xc2b2ae35U;\n\tx ^= x >> 16;\n\treturn x;\n}\n\nstatic kh_inline khint_t kh_hash_uint64(khint64_t x) { /* splitmix64; see https://nullprogram.com/blog/2018/07/31/ for inversion */\n\tx ^= x >> 30;\n\tx *= 0xbf58476d1ce4e5b9ULL;\n\tx ^= x >> 27;\n\tx *= 0x94d049bb133111ebULL;\n\tx ^= x >> 31;\n\treturn (khint_t)x;\n}\n\nstatic kh_inline khint_t kh_hash_str(kh_cstr_t s) { /* FNV1a */\n\tkhint_t h = 2166136261U;\n\tconst unsigned char *t = (const unsigned char*)s;\n\tfor (; *t; ++t)\n\t\th ^= *t, h *= 16777619;\n\treturn h;\n}\n\nstatic kh_inline khint_t kh_hash_bytes(int len, const unsigned char *s) {\n\tkhint_t h = 2166136261U;\n\tint i;\n\tfor (i = 0; i < len; ++i)\n\t\th ^= s[i], h *= 16777619;\n\treturn h;\n}\n\n#endif /* __AC_KHASHL_H */\n"
        },
        {
          "name": "khmm.c",
          "type": "blob",
          "size": 10.5712890625,
          "content": "#include <math.h>\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"khmm.h\"\n\n// new/delete hmm_par_t\n\nhmm_par_t *hmm_new_par(int m, int n)\n{\n\thmm_par_t *hp;\n\tint i;\n\tassert(m > 0 && n > 0);\n\thp = (hmm_par_t*)calloc(1, sizeof(hmm_par_t));\n\thp->m = m; hp->n = n;\n\thp->a0 = (FLOAT*)calloc(n, sizeof(FLOAT));\n\thp->a = (FLOAT**)calloc2(n, n, sizeof(FLOAT));\n\thp->e = (FLOAT**)calloc2(m + 1, n, sizeof(FLOAT));\n\thp->ae = (FLOAT**)calloc2((m + 1) * n, n, sizeof(FLOAT));\n\tfor (i = 0; i != n; ++i) hp->e[m][i] = 1.0;\n\treturn hp;\n}\nvoid hmm_delete_par(hmm_par_t *hp)\n{\n\tint i;\n\tif (hp == 0) return;\n\tfor (i = 0; i != hp->n; ++i) free(hp->a[i]);\n\tfor (i = 0; i <= hp->m; ++i) free(hp->e[i]);\n\tfor (i = 0; i < (hp->m + 1) * hp->n; ++i) free(hp->ae[i]);\n\tfree(hp->a); free(hp->e); free(hp->a0); free(hp->ae);\n\tfree(hp);\n}\n\n// new/delete hmm_data_t\n\nhmm_data_t *hmm_new_data(int L, const char *seq, const hmm_par_t *hp)\n{\n\thmm_data_t *hd;\n\thd = (hmm_data_t*)calloc(1, sizeof(hmm_data_t));\n\thd->L = L;\n\thd->seq = (char*)malloc(L + 1);\n\tmemcpy(hd->seq + 1, seq, L);\n\treturn hd;\n}\nvoid hmm_delete_data(hmm_data_t *hd)\n{\n\tint i;\n\tif (hd == 0) return;\n\tfor (i = 0; i <= hd->L; ++i) {\n\t\tif (hd->f) free(hd->f[i]);\n\t\tif (hd->b) free(hd->b[i]);\n\t}\n\tfree(hd->f); free(hd->b); free(hd->s); free(hd->v); free(hd->p); free(hd->seq);\n\tfree(hd);\n}\n\n// new/delete hmm_exp_t\n\nhmm_exp_t *hmm_new_exp(const hmm_par_t *hp)\n{\n\thmm_exp_t *he;\n\tassert(hp);\n\the = (hmm_exp_t*)calloc(1, sizeof(hmm_exp_t));\n\the->m = hp->m; he->n = hp->n;\n\the->A0 = (FLOAT*)calloc(hp->n, sizeof(FLOAT));\n\the->A = (FLOAT**)calloc2(hp->n, hp->n, sizeof(FLOAT));\n\the->E = (FLOAT**)calloc2(hp->m + 1, hp->n, sizeof(FLOAT));\n\treturn he;\n}\nvoid hmm_delete_exp(hmm_exp_t *he)\n{\n\tint i;\n\tif (he == 0) return;\n\tfor (i = 0; i != he->n; ++i) free(he->A[i]);\n\tfor (i = 0; i <= he->m; ++i) free(he->E[i]);\n\tfree(he->A); free(he->E); free(he->A0);\n\tfree(he);\n}\n\n// Viterbi algorithm\n\nFLOAT hmm_Viterbi(const hmm_par_t *hp, hmm_data_t *hd)\n{\n\tFLOAT **la, **le, *preV, *curV, max;\n\tint **Vmax, max_l; // backtrace matrix\n\tint k, l, b, u;\n\t\n\tif (hd->v) free(hd->v);\n\thd->v = (int*)calloc(hd->L+1, sizeof(int));\n\tla = (FLOAT**)calloc2(hp->n, hp->n, sizeof(FLOAT));\n\tle = (FLOAT**)calloc2(hp->m + 1, hp->n, sizeof(FLOAT));\n\tVmax = (int**)calloc2(hd->L+1, hp->n, sizeof(int));\n\tpreV = (FLOAT*)malloc(sizeof(FLOAT) * hp->n);\n\tcurV = (FLOAT*)malloc(sizeof(FLOAT) * hp->n);\n\tfor (k = 0; k != hp->n; ++k)\n\t\tfor (l = 0; l != hp->n; ++l)\n\t\t\tla[k][l] = log(hp->a[l][k]); // this is not a bug\n\tfor (b = 0; b != hp->m; ++b)\n\t\tfor (k = 0; k != hp->n; ++k)\n\t\t\tle[b][k] = log(hp->e[b][k]);\n\tfor (k = 0; k != hp->n; ++k) le[hp->m][k] = 0.0;\n\t// V_k(1)\n\tfor (k = 0; k != hp->n; ++k) {\n\t\tpreV[k] = le[(int)hd->seq[1]][k] + log(hp->a0[k]);\n\t\tVmax[1][k] = 0;\n\t}\n\t// all the rest\n\tfor (u = 2; u <= hd->L; ++u) {\n\t\tFLOAT *tmp, *leu = le[(int)hd->seq[u]];\n\t\tfor (k = 0; k != hp->n; ++k) {\n\t\t\tFLOAT *laa = la[k];\n\t\t\tfor (l = 0, max = -HMM_INF, max_l = -1; l != hp->n; ++l) {\n\t\t\t\tif (max < preV[l] + laa[l]) {\n\t\t\t\t\tmax = preV[l] + laa[l];\n\t\t\t\t\tmax_l = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(max_l >= 0); // cannot be zero\n\t\t\tcurV[k] = leu[k] + max;\n\t\t\tVmax[u][k] = max_l;\n\t\t}\n\t\ttmp = curV; curV = preV; preV = tmp; // swap\n\t}\n\t// backtrace\n\tfor (k = 0, max_l = -1, max = -HMM_INF; k != hp->n; ++k) {\n\t\tif (max < preV[k]) {\n\t\t\tmax = preV[k]; max_l = k;\n\t\t}\n\t}\n\tassert(max_l >= 0); // cannot be zero\n\thd->v[hd->L] = max_l;\n\tfor (u = hd->L; u >= 1; --u)\n\t\thd->v[u-1] = Vmax[u][hd->v[u]];\n\tfor (k = 0; k != hp->n; ++k) free(la[k]);\n\tfor (b = 0; b < hp->m; ++b) free(le[b]);\n\tfor (u = 0; u <= hd->L; ++u) free(Vmax[u]);\n\tfree(la); free(le); free(Vmax); free(preV); free(curV);\n\thd->status |= HMM_VITERBI;\n\treturn max;\n}\n\n// forward algorithm\n\nvoid hmm_forward(const hmm_par_t *hp, hmm_data_t *hd)\n{\n\tFLOAT sum, tmp, **at;\n\tint u, k, l;\n\tint n, m, L;\n\tassert(hp && hd);\n\t// allocate memory for hd->f and hd->s\n\tn = hp->n; m = hp->m; L = hd->L;\n\tif (hd->s) free(hd->s);\n\tif (hd->f) { \n\t\tfor (k = 0; k <= hd->L; ++k) free(hd->f[k]);\n\t\tfree(hd->f);\n\t}\n\thd->f = (FLOAT**)calloc2(hd->L+1, hp->n, sizeof(FLOAT));\n\thd->s = (FLOAT*)calloc(hd->L+1, sizeof(FLOAT));\n\thd->status &= ~(unsigned)HMM_FORWARD;\n\t// at[][] array helps to improve the cache efficiency\n\tat = (FLOAT**)calloc2(n, n, sizeof(FLOAT));\n\t// transpose a[][]\n\tfor (k = 0; k != n; ++k)\n\t\tfor (l = 0; l != n; ++l)\n\t\t\tat[k][l] = hp->a[l][k];\n\t// f[0], but it should never be used\n\thd->s[0] = 1.0;\n\tfor (k = 0; k != n; ++k) hd->f[0][k] = 0.0;\n\t// f[1]\n\tfor (k = 0, sum = 0.0; k != n; ++k)\n\t\tsum += (hd->f[1][k] = hp->a0[k] * hp->e[(int)hd->seq[1]][k]);\n\tfor (k = 0; k != n; ++k) hd->f[1][k] /= sum;\n\thd->s[1] = sum;\n\t// f[2..hmmL], the core loop\n\tfor (u = 2; u <= L; ++u) {\n\t\tFLOAT *fu = hd->f[u], *fu1 = hd->f[u-1], *eu = hp->e[(int)hd->seq[u]];\n\t\tfor (k = 0, sum = 0.0; k != n; ++k) {\n\t\t\tFLOAT *aa = at[k];\n\t\t\tfor (l = 0, tmp = 0.0; l != n; ++l) tmp += fu1[l] * aa[l];\n\t\t\tsum += (fu[k] = eu[k] * tmp);\n\t\t}\n\t\tfor (k = 0; k != n; ++k) fu[k] /= sum;\n\t\thd->s[u] = sum;\n\t}\n\t// free at array\n\tfor (k = 0; k != hp->n; ++k) free(at[k]);\n\tfree(at);\n\thd->status |= HMM_FORWARD;\n}\n\n//  precalculate hp->ae\n\nvoid hmm_pre_backward(hmm_par_t *hp)\n{\n\tint m, n, b, k, l;\n\tassert(hp);\n\tm = hp->m; n = hp->n;\n\tfor (b = 0; b <= m; ++b) {\n\t\tfor (k = 0; k != n; ++k) {\n\t\t\tFLOAT *p = hp->ae[b * hp->n + k];\n\t\t\tfor (l = 0; l != n; ++l)\n\t\t\t\tp[l] = hp->e[b][l] * hp->a[k][l];\n\t\t}\n\t}\n}\n\n// backward algorithm\n\nvoid hmm_backward(const hmm_par_t *hp, hmm_data_t *hd)\n{\n\tFLOAT tmp;\n\tint k, l, u;\n\tint m, n, L;\n\tassert(hp && hd);\n\tassert(hd->status & HMM_FORWARD);\n\t// allocate memory for hd->b\n\tm = hp->m; n = hp->n; L = hd->L;\n\tif (hd->b) { \n\t\tfor (k = 0; k <= hd->L; ++k) free(hd->b[k]);\n\t\tfree(hd->b);\n\t}\n\thd->status &= ~(unsigned)HMM_BACKWARD;\n\thd->b = (FLOAT**)calloc2(L+1, hp->n, sizeof(FLOAT));\n\t// b[L]\n\tfor (k = 0; k != hp->n; ++k) hd->b[L][k] = 1.0 / hd->s[L];\n\t// b[1..L-1], the core loop\n\tfor (u = L-1; u >= 1; --u) {\n\t\tFLOAT *bu1 = hd->b[u+1], **p = hp->ae + (int)hd->seq[u+1] * n;\n\t\tfor (k = 0; k != n; ++k) {\n\t\t\tFLOAT *q = p[k];\n\t\t\tfor (l = 0, tmp = 0.0; l != n; ++l) tmp += q[l] * bu1[l];\n\t\t\thd->b[u][k] = tmp / hd->s[u];\n\t\t}\n\t}\n\thd->status |= HMM_BACKWARD;\n\tfor (l = 0, tmp = 0.0; l != n; ++l)\n\t\ttmp += hp->a0[l] * hd->b[1][l] * hp->e[(int)hd->seq[1]][l];\n\tif (tmp > 1.0 + 1e-6 || tmp < 1.0 - 1e-6) // in theory, tmp should always equal to 1\n\t\tfprintf(stderr, \"++ Underflow may have happened (%lg).\\n\", tmp);\n}\n\n// log-likelihood of the observation\n\nFLOAT hmm_lk(const hmm_data_t *hd)\n{\n    FLOAT sum = 0.0, prod = 1.0;\n\tint u, L;\n\tL = hd->L;\n\tassert(hd->status & HMM_FORWARD);\n\tfor (u = 1; u <= L; ++u) {\n\t\tprod *= hd->s[u];\n\t\tif (prod < HMM_TINY || prod >= 1.0/HMM_TINY) { // reset\n\t\t\tsum += log(prod);\n\t\t\tprod = 1.0;\n\t\t}\n\t}\n\tsum += log(prod);\n\treturn sum;\n}\n\n// posterior decoding\n\nvoid hmm_post_decode(const hmm_par_t *hp, hmm_data_t *hd)\n{\n\tint u, k;\n\tassert(hd->status && HMM_BACKWARD);\n\tif (hd->p) free(hd->p);\n\thd->p = (int*)calloc(hd->L + 1, sizeof(int));\n\tfor (u = 1; u <= hd->L; ++u) {\n\t\tFLOAT prob, max, *fu = hd->f[u], *bu = hd->b[u], su = hd->s[u];\n\t\tint max_k;\n\t\tfor (k = 0, max = -1.0, max_k = -1; k != hp->n; ++k) {\n\t\t\tif (max < (prob = fu[k] * bu[k] * su)) {\n\t\t\t\tmax = prob; max_k = k;\n\t\t\t}\n\t\t}\n\t\tassert(max_k >= 0);\n\t\thd->p[u] = max_k;\n\t}\n\thd->status |= HMM_POSTDEC;\n}\n\n// posterior probability of states\n\nFLOAT hmm_post_state(const hmm_par_t *hp, const hmm_data_t *hd, int u, FLOAT *prob)\n{\n\tFLOAT sum = 0.0, ss = hd->s[u], *fu = hd->f[u], *bu = hd->b[u];\n\tint k;\n\tfor (k = 0; k != hp->n; ++k)\n\t\tsum += (prob[k] = fu[k] * bu[k] * ss);\n\treturn sum; // in theory, this should always equal to 1.0\n}\n\n// expected counts\n\nhmm_exp_t *hmm_expect(const hmm_par_t *hp, const hmm_data_t *hd)\n{\n\tint k, l, u, b, m, n;\n\thmm_exp_t *he;\n\tassert(hd->status & HMM_BACKWARD);\n\the = hmm_new_exp(hp);\n\t// initialization\n\tm = hp->m; n = hp->n;\n\tfor (k = 0; k != n; ++k)\n\t\tfor (l = 0; l != n; ++l) he->A[k][l] = HMM_TINY;\n\tfor (b = 0; b <= m; ++b)\n\t\tfor (l = 0; l != n; ++l) he->E[b][l] = HMM_TINY;\n\t// calculate A_{kl} and E_k(b), k,l\\in[0,n)\n\tfor (u = 1; u < hd->L; ++u) {\n\t\tFLOAT *fu = hd->f[u], *bu = hd->b[u], *bu1 = hd->b[u+1], ss = hd->s[u];\n\t\tFLOAT *Ec = he->E[(int)hd->seq[u]], **p = hp->ae + (int)hd->seq[u+1] * n;\n\t\tfor (k = 0; k != n; ++k) {\n\t\t\tFLOAT *q = p[k], *AA = he->A[k], fuk = fu[k];\n\t\t\tfor (l = 0; l != n; ++l) // this is cache-efficient\n\t\t\t\tAA[l] += fuk * q[l] * bu1[l];\n\t\t\tEc[k] += fuk * bu[k] * ss;\n\t\t}\n\t}\n\t// calculate A0_l\n\tfor (l = 0; l != n; ++l)\n\t\the->A0[l] += hp->a0[l] * hp->e[(int)hd->seq[1]][l] * hd->b[1][l];\n\treturn he;\n}\n\nFLOAT hmm_Q0(const hmm_par_t *hp, hmm_exp_t *he)\n{\n\tint k, l, b;\n\tFLOAT sum = 0.0;\n\tfor (k = 0; k != hp->n; ++k) {\n\t\tFLOAT tmp;\n\t\tfor (b = 0, tmp = 0.0; b != hp->m; ++b) tmp += he->E[b][k];\n\t\tfor (b = 0; b != hp->m; ++b)\n\t\t\tsum += he->E[b][k] * log(he->E[b][k] / tmp);\n\t}\n\tfor (k = 0; k != hp->n; ++k) {\n\t\tFLOAT tmp, *A = he->A[k];\n\t\tfor (l = 0, tmp = 0.0; l != hp->n; ++l) tmp += A[l];\n\t\tfor (l = 0; l != hp->n; ++l) sum += A[l] * log(A[l] / tmp);\n\t}\n\treturn (he->Q0 = sum);\n}\n\n// add he0 to he1\n\nvoid hmm_add_expect(const hmm_exp_t *he0, hmm_exp_t *he1)\n{\n\tint b, k, l;\n\tassert(he0->m == he1->m && he0->n == he1->n);\n\tfor (k = 0; k != he1->n; ++k) {\n\t\the1->A0[k] += he0->A0[k];\n\t\tfor (l = 0; l != he1->n; ++l)\n\t\t\the1->A[k][l] += he0->A[k][l];\n\t}\n\tfor (b = 0; b != he1->m; ++b) {\n\t\tfor (l = 0; l != he1->n; ++l)\n\t\t\the1->E[b][l] += he0->E[b][l];\n\t}\n}\n\n// the EM-Q function\n\nFLOAT hmm_Q(const hmm_par_t *hp, const hmm_exp_t *he)\n{\n\tFLOAT sum = 0.0;\n\tint bb, k, l;\n\tfor (bb = 0; bb != he->m; ++bb) {\n\t\tFLOAT *eb = hp->e[bb], *Eb = he->E[bb];\n\t\tfor (k = 0; k != hp->n; ++k) {\n\t\t\tif (eb[k] <= 0.0) return -HMM_INF;\n\t\t\tsum += Eb[k] * log(eb[k]);\n\t\t}\n\t}\n\tfor (k = 0; k != he->n; ++k) {\n\t\tFLOAT *Ak = he->A[k], *ak = hp->a[k];\n\t\tfor (l = 0; l != he->n; ++l) {\n\t\t\tif (ak[l] <= 0.0) return -HMM_INF;\n\t\t\tsum += Ak[l] * log(ak[l]);\n\t\t}\n\t}\n\treturn (sum -= he->Q0);\n}\n\n// simulate sequence\n\nchar *hmm_simulate(const hmm_par_t *hp, int L)\n{\n\tint i, k, l, b;\n\tFLOAT x, y, **et;\n\tchar *seq;\n\tseq = (char*)calloc(L+1, 1);\n\t// calculate the transpose of hp->e[][]\n\tet = (FLOAT**)calloc2(hp->n, hp->m, sizeof(FLOAT));\n\tfor (k = 0; k != hp->n; ++k)\n\t\tfor (b = 0; b != hp->m; ++b)\n\t\t\tet[k][b] = hp->e[b][k];\n\t// the initial state, drawn from a0[]\n\tx = drand48();\n\tfor (k = 0, y = 0.0; k != hp->n; ++k) {\n\t\ty += hp->a0[k];\n\t\tif (y >= x) break;\n\t}\n\t// main loop\n\tfor (i = 0; i != L; ++i) {\n\t\tFLOAT *el, *ak = hp->a[k];\n\t\tx = drand48();\n\t\tfor (l = 0, y = 0.0; l != hp->n; ++l) {\n\t\t\ty += ak[l];\n\t\t\tif (y >= x) break;\n\t\t}\n\t\tel = et[l];\n\t\tx = drand48();\n\t\tfor (b = 0, y = 0.0; b != hp->m; ++b) {\n\t\t\ty += el[b];\n\t\t\tif (y >= x) break;\n\t\t} \n\t\tseq[i] = b;\n\t\tk = l;\n\t}\n\tfor (k = 0; k != hp->n; ++k) free(et[k]);\n\tfree(et);\n\treturn seq;\n}\n"
        },
        {
          "name": "khmm.h",
          "type": "blob",
          "size": 2.8603515625,
          "content": "#ifndef AC_SCHMM_H_\n#define AC_SCHMM_H_\n\n/*\n * Last Modified: 2008-03-10\n * Version: 0.1.0-8\n *\n * 2008-03-10, 0.1.0-8: make icc report two more \"VECTORIZED\"\n * 2008-03-10, 0.1.0-7: accelerate for some CPU\n * 2008-02-07, 0.1.0-6: simulate sequences\n * 2008-01-15, 0.1.0-5: goodness of fit\n * 2007-11-20, 0.1.0-4: add function declaration of hmm_post_decode()\n * 2007-11-09: fix a memory leak\n */\n\n#include <stdlib.h>\n\n#define HMM_VERSION \"0.1.0-7\"\n\n#define HMM_FORWARD  0x02\n#define HMM_BACKWARD 0x04\n#define HMM_VITERBI  0x40\n#define HMM_POSTDEC  0x80\n\n#ifndef FLOAT\n#define FLOAT double\n#endif\n#define HMM_TINY     1e-25\n#define HMM_INF      1e300\n\ntypedef struct\n{\n\tint m, n; // number of symbols, number of states\n\tFLOAT **a, **e; // transition matrix and emitting probilities\n\tFLOAT **ae; // auxiliary array for acceleration, should be calculated by hmm_pre_backward()\n\tFLOAT *a0; // trasition matrix from the start state\n} hmm_par_t;\n\ntypedef struct\n{\n\tint L;\n\tunsigned status;\n\tchar *seq;\n\tFLOAT **f, **b, *s;\n\tint *v; // Viterbi path\n\tint *p; // posterior decoding\n} hmm_data_t;\n\ntypedef struct\n{\n\tint m, n;\n\tFLOAT Q0, **A, **E, *A0;\n} hmm_exp_t;\n\ntypedef struct\n{\n\tint l, *obs;\n\tFLOAT *thr;\n} hmm_gof_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\t/* initialize and destroy hmm_par_t */\n\thmm_par_t *hmm_new_par(int m, int n);\n\tvoid hmm_delete_par(hmm_par_t *hp);\n\t/* initialize and destroy hmm_data_t */\n\thmm_data_t *hmm_new_data(int L, const char *seq, const hmm_par_t *hp);\n\tvoid hmm_delete_data(hmm_data_t *hd);\n\t/* initialize and destroy hmm_exp_t */\n\thmm_exp_t *hmm_new_exp(const hmm_par_t *hp);\n\tvoid hmm_delete_exp(hmm_exp_t *he);\n\t/* Viterbi, forward and backward algorithms */\n\tFLOAT hmm_Viterbi(const hmm_par_t *hp, hmm_data_t *hd);\n\tvoid hmm_pre_backward(hmm_par_t *hp);\n\tvoid hmm_forward(const hmm_par_t *hp, hmm_data_t *hd);\n\tvoid hmm_backward(const hmm_par_t *hp, hmm_data_t *hd);\n\t/* log-likelihood of the observations (natural based) */\n\tFLOAT hmm_lk(const hmm_data_t *hd);\n\t/* posterior probability at the position on the sequence */\n\tFLOAT hmm_post_state(const hmm_par_t *hp, const hmm_data_t *hd, int u, FLOAT *prob);\n\t/* posterior decoding */\n\tvoid hmm_post_decode(const hmm_par_t *hp, hmm_data_t *hd);\n\t/* expected counts of transitions and emissions */\n\thmm_exp_t *hmm_expect(const hmm_par_t *hp, const hmm_data_t *hd);\n\t/* add he0 counts to he1 counts*/\n\tvoid hmm_add_expect(const hmm_exp_t *he0, hmm_exp_t *he1);\n\t/* the Q function that should be maximized in EM */\n\tFLOAT hmm_Q(const hmm_par_t *hp, const hmm_exp_t *he);\n\tFLOAT hmm_Q0(const hmm_par_t *hp, hmm_exp_t *he);\n\t/* simulate sequences */\n\tchar *hmm_simulate(const hmm_par_t *hp, int L);\n#ifdef __cplusplus\n}\n#endif\n\nstatic inline void **calloc2(int n_row, int n_col, int size)\n{\n\tchar **p;\n\tint k;\n\tp = (char**)malloc(sizeof(char*) * n_row);\n\tfor (k = 0; k != n_row; ++k)\n\t\tp[k] = (char*)calloc(n_col, size);\n\treturn (void**)p;\n}\n\n#endif\n"
        },
        {
          "name": "klist.h",
          "type": "blob",
          "size": 4.966796875,
          "content": "/* The MIT License\n\n   Copyright (c) 2008-2009, by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#ifndef _AC_KLIST_H\n#define _AC_KLIST_H\n\n#include <stdlib.h>\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\n#define KMEMPOOL_INIT2(SCOPE, name, kmptype_t, kmpfree_f)\t\t\t\t\\\n\ttypedef struct {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t cnt, n, max;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkmptype_t **buf;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} kmp_##name##_t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE kmp_##name##_t *kmp_init_##name(void) {\t\t\t\t\t\t\\\n\t\treturn calloc(1, sizeof(kmp_##name##_t));\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kmp_destroy_##name(kmp_##name##_t *mp) {\t\t\t\t\t\\\n\t\tsize_t k;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (k = 0; k < mp->n; ++k) {\t\t\t\t\t\t\t\t\t\\\n\t\t\tkmpfree_f(mp->buf[k]); free(mp->buf[k]);\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(mp->buf); free(mp);\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) {\t\t\t\t\\\n\t\t++mp->cnt;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (mp->n == 0) return calloc(1, sizeof(kmptype_t));\t\t\t\\\n\t\treturn mp->buf[--mp->n];\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) {\t\t\\\n\t\t--mp->cnt;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (mp->n == mp->max) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmp->max = mp->max? mp->max<<1 : 16;\t\t\t\t\t\t\t\\\n\t\t\tmp->buf = realloc(mp->buf, sizeof(kmptype_t *) * mp->max);\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tmp->buf[mp->n++] = p;\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f)\t\t\t\t\t\t\\\n\tKMEMPOOL_INIT2(static inline klib_unused, name, kmptype_t, kmpfree_f)\n\n#define kmempool_t(name) kmp_##name##_t\n#define kmp_init(name) kmp_init_##name()\n#define kmp_destroy(name, mp) kmp_destroy_##name(mp)\n#define kmp_alloc(name, mp) kmp_alloc_##name(mp)\n#define kmp_free(name, mp, p) kmp_free_##name(mp, p)\n\n#define KLIST_INIT2(SCOPE, name, kltype_t, kmpfree_t)\t\t\t\t\t\\\n\tstruct __kl1_##name {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkltype_t data;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tstruct __kl1_##name *next;\t\t\t\t\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\ttypedef struct __kl1_##name kl1_##name;\t\t\t\t\t\t\t\t\\\n\tKMEMPOOL_INIT2(SCOPE, name, kl1_##name, kmpfree_t)\t\t\t\t\t\\\n\ttypedef struct {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkl1_##name *head, *tail;\t\t\t\t\t\t\t\t\t\t\\\n\t\tkmp_##name##_t *mp;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} kl_##name##_t;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE kl_##name##_t *kl_init_##name(void) {\t\t\t\t\t\t\t\\\n\t\tkl_##name##_t *kl = calloc(1, sizeof(kl_##name##_t));\t\t\t\\\n\t\tkl->mp = kmp_init(name);\t\t\t\t\t\t\t\t\t\t\\\n\t\tkl->head = kl->tail = kmp_alloc(name, kl->mp);\t\t\t\t\t\\\n\t\tkl->head->next = 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn kl;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kl_destroy_##name(kl_##name##_t *kl) {\t\t\t\t\t\\\n\t\tkl1_##name *p;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (p = kl->head; p != kl->tail; p = p->next)\t\t\t\t\t\\\n\t\t\tkmp_free(name, kl->mp, p);\t\t\t\t\t\t\t\t\t\\\n\t\tkmp_free(name, kl->mp, p);\t\t\t\t\t\t\t\t\t\t\\\n\t\tkmp_destroy(name, kl->mp);\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(kl);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE kltype_t *kl_pushp_##name(kl_##name##_t *kl) {\t\t\t\t\\\n\t\tkl1_##name *q, *p = kmp_alloc(name, kl->mp);\t\t\t\t\t\\\n\t\tq = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p;\t\\\n\t\t++kl->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn &q->data;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE int kl_shift_##name(kl_##name##_t *kl, kltype_t *d) {\t\t\t\\\n\t\tkl1_##name *p;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (kl->head->next == 0) return -1;\t\t\t\t\t\t\t\t\\\n\t\t--kl->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tp = kl->head; kl->head = kl->head->next;\t\t\t\t\t\t\\\n\t\tif (d) *d = p->data;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkmp_free(name, kl->mp, p);\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define KLIST_INIT(name, kltype_t, kmpfree_t)\t\t\t\t\t\t\t\\\n\tKLIST_INIT2(static inline klib_unused, name, kltype_t, kmpfree_t)\n\n#define kliter_t(name) kl1_##name\n#define klist_t(name) kl_##name##_t\n#define kl_val(iter) ((iter)->data)\n#define kl_next(iter) ((iter)->next)\n#define kl_begin(kl) ((kl)->head)\n#define kl_end(kl) ((kl)->tail)\n\n#define kl_init(name) kl_init_##name()\n#define kl_destroy(name, kl) kl_destroy_##name(kl)\n#define kl_pushp(name, kl) kl_pushp_##name(kl)\n#define kl_shift(name, kl, d) kl_shift_##name(kl, d)\n\n#endif\n"
        },
        {
          "name": "kmath.c",
          "type": "blob",
          "size": 13.4345703125,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include \"kmath.h\"\n\n/******************************\n *** Non-linear programming ***\n ******************************/\n\n/* Hooke-Jeeves algorithm for nonlinear minimization\n \n   Based on the pseudocodes by Bell and Pike (CACM 9(9):684-685), and\n   the revision by Tomlin and Smith (CACM 12(11):637-638). Both of the\n   papers are comments on Kaupe's Algorithm 178 \"Direct Search\" (ACM\n   6(6):313-314). The original algorithm was designed by Hooke and\n   Jeeves (ACM 8:212-229). This program is further revised according to\n   Johnson's implementation at Netlib (opt/hooke.c).\n \n   Hooke-Jeeves algorithm is very simple and it works quite well on a\n   few examples. However, it might fail to converge due to its heuristic\n   nature. A possible improvement, as is suggested by Johnson, may be to\n   choose a small r at the beginning to quickly approach to the minimum\n   and a large r at later step to hit the minimum.\n */\n\nstatic double __kmin_hj_aux(kmin_f func, int n, double *x1, void *data, double fx1, double *dx, int *n_calls)\n{\n\tint k, j = *n_calls;\n\tdouble ftmp;\n\tfor (k = 0; k != n; ++k) {\n\t\tx1[k] += dx[k];\n\t\tftmp = func(n, x1, data); ++j;\n\t\tif (ftmp < fx1) fx1 = ftmp;\n\t\telse { /* search the opposite direction */\n\t\t\tdx[k] = 0.0 - dx[k];\n\t\t\tx1[k] += dx[k] + dx[k];\n\t\t\tftmp = func(n, x1, data); ++j;\n\t\t\tif (ftmp < fx1) fx1 = ftmp;\n\t\t\telse x1[k] -= dx[k]; /* back to the original x[k] */\n\t\t}\n\t}\n\t*n_calls = j;\n\treturn fx1; /* here: fx1=f(n,x1) */\n}\n\ndouble kmin_hj(kmin_f func, int n, double *x, void *data, double r, double eps, int max_calls)\n{\n\tdouble fx, fx1, *x1, *dx, radius;\n\tint k, n_calls = 0;\n\tx1 = (double*)calloc(n, sizeof(double));\n\tdx = (double*)calloc(n, sizeof(double));\n\tfor (k = 0; k != n; ++k) { /* initial directions, based on MGJ */\n\t\tdx[k] = fabs(x[k]) * r;\n\t\tif (dx[k] == 0) dx[k] = r;\n\t}\n\tradius = r;\n\tfx1 = fx = func(n, x, data); ++n_calls;\n\tfor (;;) {\n\t\tmemcpy(x1, x, n * sizeof(double)); /* x1 = x */\n\t\tfx1 = __kmin_hj_aux(func, n, x1, data, fx, dx, &n_calls);\n\t\twhile (fx1 < fx) {\n\t\t\tfor (k = 0; k != n; ++k) {\n\t\t\t\tdouble t = x[k];\n\t\t\t\tdx[k] = x1[k] > x[k]? fabs(dx[k]) : 0.0 - fabs(dx[k]);\n\t\t\t\tx[k] = x1[k];\n\t\t\t\tx1[k] = x1[k] + x1[k] - t;\n\t\t\t}\n\t\t\tfx = fx1;\n\t\t\tif (n_calls >= max_calls) break;\n\t\t\tfx1 = func(n, x1, data); ++n_calls;\n\t\t\tfx1 = __kmin_hj_aux(func, n, x1, data, fx1, dx, &n_calls);\n\t\t\tif (fx1 >= fx) break;\n\t\t\tfor (k = 0; k != n; ++k)\n\t\t\t\tif (fabs(x1[k] - x[k]) > .5 * fabs(dx[k])) break;\n\t\t\tif (k == n) break;\n\t\t}\n\t\tif (radius >= eps) {\n\t\t\tif (n_calls >= max_calls) break;\n\t\t\tradius *= r;\n\t\t\tfor (k = 0; k != n; ++k) dx[k] *= r;\n\t\t} else break; /* converge */\n\t}\n\tfree(x1); free(dx);\n\treturn fx1;\n}\n\n// I copied this function somewhere several years ago with some of my modifications, but I forgot the source.\ndouble kmin_brent(kmin1_f func, double a, double b, void *data, double tol, double *xmin)\n{\n\tdouble bound, u, r, q, fu, tmp, fa, fb, fc, c;\n\tconst double gold1 = 1.6180339887;\n\tconst double gold2 = 0.3819660113;\n\tconst double tiny = 1e-20;\n\tconst int max_iter = 100;\n\n\tdouble e, d, w, v, mid, tol1, tol2, p, eold, fv, fw;\n\tint iter;\n\n\tfa = func(a, data); fb = func(b, data);\n\tif (fb > fa) { // swap, such that f(a) > f(b)\n\t\ttmp = a; a = b; b = tmp;\n\t\ttmp = fa; fa = fb; fb = tmp;\n\t}\n\tc = b + gold1 * (b - a), fc = func(c, data); // golden section extrapolation\n\twhile (fb > fc) {\n\t\tbound = b + 100.0 * (c - b); // the farthest point where we want to go\n\t\tr = (b - a) * (fb - fc);\n\t\tq = (b - c) * (fb - fa);\n\t\tif (fabs(q - r) < tiny) { // avoid 0 denominator\n\t\t\ttmp = q > r? tiny : 0.0 - tiny;\n\t\t} else tmp = q - r;\n\t\tu = b - ((b - c) * q - (b - a) * r) / (2.0 * tmp); // u is the parabolic extrapolation point\n\t\tif ((b > u && u > c) || (b < u && u < c)) { // u lies between b and c\n\t\t\tfu = func(u, data);\n\t\t\tif (fu < fc) { // (b,u,c) bracket the minimum\n\t\t\t\ta = b; b = u; fa = fb; fb = fu;\n\t\t\t\tbreak;\n\t\t\t} else if (fu > fb) { // (a,b,u) bracket the minimum\n\t\t\t\tc = u; fc = fu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tu = c + gold1 * (c - b); fu = func(u, data); // golden section extrapolation\n\t\t} else if ((c > u && u > bound) || (c < u && u < bound)) { // u lies between c and bound\n\t\t\tfu = func(u, data);\n\t\t\tif (fu < fc) { // fb > fc > fu\n\t\t\t\tb = c; c = u; u = c + gold1 * (c - b);\n\t\t\t\tfb = fc; fc = fu; fu = func(u, data);\n\t\t\t} else { // (b,c,u) bracket the minimum\n\t\t\t\ta = b; b = c; c = u;\n\t\t\t\tfa = fb; fb = fc; fc = fu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((u > bound && bound > c) || (u < bound && bound < c)) { // u goes beyond the bound\n\t\t\tu = bound; fu = func(u, data);\n\t\t} else { // u goes the other way around, use golden section extrapolation\n\t\t\tu = c + gold1 * (c - b); fu = func(u, data);\n\t\t}\n\t\ta = b; b = c; c = u;\n\t\tfa = fb; fb = fc; fc = fu;\n\t}\n\tif (a > c) u = a, a = c, c = u; // swap\n\n\t// now, a<b<c, fa>fb and fb<fc, move on to Brent's algorithm\n\te = d = 0.0;\n\tw = v = b; fv = fw = fb;\n\tfor (iter = 0; iter != max_iter; ++iter) {\n\t\tmid = 0.5 * (a + c);\n\t\ttol2 = 2.0 * (tol1 = tol * fabs(b) + tiny);\n\t\tif (fabs(b - mid) <= (tol2 - 0.5 * (c - a))) {\n\t\t\t*xmin = b; return fb; // found\n\t\t}\n\t\tif (fabs(e) > tol1) {\n\t\t\t// related to parabolic interpolation\n\t\t\tr = (b - w) * (fb - fv);\n\t\t\tq = (b - v) * (fb - fw);\n\t\t\tp = (b - v) * q - (b - w) * r;\n\t\t\tq = 2.0 * (q - r);\n\t\t\tif (q > 0.0) p = 0.0 - p;\n\t\t\telse q = 0.0 - q;\n\t\t\teold = e; e = d;\n\t\t\tif (fabs(p) >= fabs(0.5 * q * eold) || p <= q * (a - b) || p >= q * (c - b)) {\n\t\t\t\td = gold2 * (e = (b >= mid ? a - b : c - b));\n\t\t\t} else {\n\t\t\t\td = p / q; u = b + d; // actual parabolic interpolation happens here\n\t\t\t\tif (u - a < tol2 || c - u < tol2)\n\t\t\t\t\td = (mid > b)? tol1 : 0.0 - tol1;\n\t\t\t}\n\t\t} else d = gold2 * (e = (b >= mid ? a - b : c - b)); // golden section interpolation\n\t\tu = fabs(d) >= tol1 ? b + d : b + (d > 0.0? tol1 : -tol1);\n\t\tfu = func(u, data);\n\t\tif (fu <= fb) { // u is the minimum point so far\n\t\t\tif (u >= b) a = b;\n\t\t\telse c = b;\n\t\t\tv = w; w = b; b = u; fv = fw; fw = fb; fb = fu;\n\t\t} else { // adjust (a,c) and (u,v,w)\n\t\t\tif (u < b) a = u;\n\t\t\telse c = u;\n\t\t\tif (fu <= fw || w == b) {\n\t\t\t\tv = w; w = u;\n\t\t\t\tfv = fw; fw = fu;\n\t\t\t} else if (fu <= fv || v == b || v == w) {\n\t\t\t\tv = u; fv = fu;\n\t\t\t}\n\t\t}\n\t}\n\t*xmin = b;\n\treturn fb;\n}\n\nstatic inline float SIGN(float a, float b)\n{\n\treturn b >= 0 ? (a >= 0 ? a : -a) : (a >= 0 ? -a : a);\n}\n\ndouble krf_brent(double x1, double x2, double tol, double (*func)(double, void*), void *data, int *err)\n{\n\tconst int max_iter = 100;\n\tconst double eps = 3e-8f;\n\tint i;\n\tdouble a = x1, b = x2, c = x2, d, e, min1, min2;\n\tdouble fa, fb, fc, p, q, r, s, tol1, xm;\n\n\t*err = 0;\n\tfa = func(a, data), fb = func(b, data);\n\tif ((fa > 0.0f && fb > 0.0f) || (fa < 0.0f && fb < 0.0f)) {\n\t\t*err = -1;\n\t\treturn 0.0f;\n\t}\n\tfc = fb;\n\tfor (i = 0; i < max_iter; ++i) {\n\t\tif ((fb > 0.0f && fc > 0.0f) || (fb < 0.0f && fc < 0.0f)) {\n\t\t\tc = a;\n\t\t\tfc = fa;\n\t\t\te = d = b - a;\n\t\t}\n\t\tif (fabs(fc) < fabs(fb)) {\n\t\t\ta = b, b = c, c = a;\n\t\t\tfa = fb, fb = fc, fc = fa;\n\t\t}\n\t\ttol1 = 2.0f * eps * fabs(b) + 0.5f * tol;\n\t\txm = 0.5f * (c - b);\n\t\tif (fabs(xm) <= tol1 || fb == 0.0f)\n\t\t\treturn b;\n\t\tif (fabs(e) >= tol1 && fabs(fa) > fabs(fb)) {\n\t\t\ts = fb / fa;\n\t\t\tif (a == c) {\n\t\t\t\tp = 2.0f * xm * s;\n\t\t\t\tq = 1.0f - s;\n\t\t\t} else {\n\t\t\t\tq = fa / fc;\n\t\t\t\tr = fb / fc;\n\t\t\t\tp = s * (2.0f * xm * q * (q - r) - (b - a) * (r - 1.0f));\n\t\t\t\tq = (q - 1.0f) * (r - 1.0f) * (s - 1.0f);\n\t\t\t}\n\t\t\tif (p > 0.0f) q = -q;\n\t\t\tp = fabs(p);\n\t\t\tmin1 = 3.0f * xm * q - fabs(tol1 * q);\n\t\t\tmin2 = fabs(e * q);\n\t\t\tif (2.0f * p < (min1 < min2 ? min1 : min2)) {\n\t\t\t\te = d;\n\t\t\t\td = p / q;\n\t\t\t} else {\n\t\t\t\td = xm;\n\t\t\t\te = d;\n\t\t\t}\n\t\t} else {\n\t\t\td = xm;\n\t\t\te = d;\n\t\t}\n\t\ta = b;\n\t\tfa = fb;\n\t\tif (fabs(d) > tol1) b += d;\n\t\telse b += SIGN(tol1, xm);\n\t\tfb = func(b, data);\n\t}\n\t*err = -2;\n\treturn 0.0;\n}\n\n/*************************\n *** Special functions ***\n *************************/\n\n/* Log gamma function\n * \\log{\\Gamma(z)}\n * AS245, 2nd algorithm, http://lib.stat.cmu.edu/apstat/245\n */\ndouble kf_lgamma(double z)\n{\n\tdouble x = 0;\n\tx += 0.1659470187408462e-06 / (z+7);\n\tx += 0.9934937113930748e-05 / (z+6);\n\tx -= 0.1385710331296526     / (z+5);\n\tx += 12.50734324009056      / (z+4);\n\tx -= 176.6150291498386      / (z+3);\n\tx += 771.3234287757674      / (z+2);\n\tx -= 1259.139216722289      / (z+1);\n\tx += 676.5203681218835      / z;\n\tx += 0.9999999999995183;\n\treturn log(x) - 5.58106146679532777 - z + (z-0.5) * log(z+6.5);\n}\n\n/* complementary error function\n * \\frac{2}{\\sqrt{\\pi}} \\int_x^{\\infty} e^{-t^2} dt\n * AS66, 2nd algorithm, http://lib.stat.cmu.edu/apstat/66\n */\ndouble kf_erfc(double x)\n{\n\tconst double p0 = 220.2068679123761;\n\tconst double p1 = 221.2135961699311;\n\tconst double p2 = 112.0792914978709;\n\tconst double p3 = 33.912866078383;\n\tconst double p4 = 6.37396220353165;\n\tconst double p5 = .7003830644436881;\n\tconst double p6 = .03526249659989109;\n\tconst double q0 = 440.4137358247522;\n\tconst double q1 = 793.8265125199484;\n\tconst double q2 = 637.3336333788311;\n\tconst double q3 = 296.5642487796737;\n\tconst double q4 = 86.78073220294608;\n\tconst double q5 = 16.06417757920695;\n\tconst double q6 = 1.755667163182642;\n\tconst double q7 = .08838834764831844;\n\tdouble expntl, z, p;\n\tz = fabs(x) * M_SQRT2;\n\tif (z > 37.) return x > 0.? 0. : 2.;\n\texpntl = exp(z * z * - .5);\n\tif (z < 10. / M_SQRT2) // for small z\n\t    p = expntl * ((((((p6 * z + p5) * z + p4) * z + p3) * z + p2) * z + p1) * z + p0)\n\t\t\t/ (((((((q7 * z + q6) * z + q5) * z + q4) * z + q3) * z + q2) * z + q1) * z + q0);\n\telse p = expntl / 2.506628274631001 / (z + 1. / (z + 2. / (z + 3. / (z + 4. / (z + .65)))));\n\treturn x > 0.? 2. * p : 2. * (1. - p);\n}\n\n/* The following computes regularized incomplete gamma functions.\n * Formulas are taken from Wiki, with additional input from Numerical\n * Recipes in C (for modified Lentz's algorithm) and AS245\n * (http://lib.stat.cmu.edu/apstat/245).\n *\n * A good online calculator is available at:\n *\n *   http://www.danielsoper.com/statcalc/calc23.aspx\n *\n * It calculates upper incomplete gamma function, which equals\n * kf_gammaq(s,z)*tgamma(s).\n */\n\n#define KF_GAMMA_EPS 1e-14\n#define KF_TINY 1e-290\n\n// regularized lower incomplete gamma function, by series expansion\nstatic double _kf_gammap(double s, double z)\n{\n\tdouble sum, x;\n\tint k;\n\tfor (k = 1, sum = x = 1.; k < 100; ++k) {\n\t\tsum += (x *= z / (s + k));\n\t\tif (x / sum < KF_GAMMA_EPS) break;\n\t}\n\treturn exp(s * log(z) - z - kf_lgamma(s + 1.) + log(sum));\n}\n// regularized upper incomplete gamma function, by continued fraction\nstatic double _kf_gammaq(double s, double z)\n{\n\tint j;\n\tdouble C, D, f;\n\tf = 1. + z - s; C = f; D = 0.;\n\t// Modified Lentz's algorithm for computing continued fraction\n\t// See Numerical Recipes in C, 2nd edition, section 5.2\n\tfor (j = 1; j < 100; ++j) {\n\t\tdouble a = j * (s - j), b = (j<<1) + 1 + z - s, d;\n\t\tD = b + a * D;\n\t\tif (D < KF_TINY) D = KF_TINY;\n\t\tC = b + a / C;\n\t\tif (C < KF_TINY) C = KF_TINY;\n\t\tD = 1. / D;\n\t\td = C * D;\n\t\tf *= d;\n\t\tif (fabs(d - 1.) < KF_GAMMA_EPS) break;\n\t}\n\treturn exp(s * log(z) - z - kf_lgamma(s) - log(f));\n}\n\ndouble kf_gammap(double s, double z)\n{\n\treturn z <= 1. || z < s? _kf_gammap(s, z) : 1. - _kf_gammaq(s, z);\n}\n\ndouble kf_gammaq(double s, double z)\n{\n\treturn z <= 1. || z < s? 1. - _kf_gammap(s, z) : _kf_gammaq(s, z);\n}\n\n/* Regularized incomplete beta function. The method is taken from\n * Numerical Recipe in C, 2nd edition, section 6.4. The following web\n * page calculates the incomplete beta function, which equals\n * kf_betai(a,b,x) * gamma(a) * gamma(b) / gamma(a+b):\n *\n *   http://www.danielsoper.com/statcalc/calc36.aspx\n */\nstatic double kf_betai_aux(double a, double b, double x)\n{\n\tdouble C, D, f;\n\tint j;\n\tif (x == 0.) return 0.;\n\tif (x == 1.) return 1.;\n\tf = 1.; C = f; D = 0.;\n\t// Modified Lentz's algorithm for computing continued fraction\n\tfor (j = 1; j < 200; ++j) {\n\t\tdouble aa, d;\n\t\tint m = j>>1;\n\t\taa = (j&1)? -(a + m) * (a + b + m) * x / ((a + 2*m) * (a + 2*m + 1))\n\t\t\t: m * (b - m) * x / ((a + 2*m - 1) * (a + 2*m));\n\t\tD = 1. + aa * D;\n\t\tif (D < KF_TINY) D = KF_TINY;\n\t\tC = 1. + aa / C;\n\t\tif (C < KF_TINY) C = KF_TINY;\n\t\tD = 1. / D;\n\t\td = C * D;\n\t\tf *= d;\n\t\tif (fabs(d - 1.) < KF_GAMMA_EPS) break;\n\t}\n\treturn exp(kf_lgamma(a+b) - kf_lgamma(a) - kf_lgamma(b) + a * log(x) + b * log(1.-x)) / a / f;\n}\ndouble kf_betai(double a, double b, double x)\n{\n\treturn x < (a + 1.) / (a + b + 2.)? kf_betai_aux(a, b, x) : 1. - kf_betai_aux(b, a, 1. - x);\n}\n\n/******************\n *** Statistics ***\n ******************/\n\ndouble km_ks_dist(int na, const double a[], int nb, const double b[]) // a[] and b[] MUST BE sorted\n{\n\tint ia = 0, ib = 0;\n\tdouble fa = 0, fb = 0, sup = 0, na1 = 1. / na, nb1 = 1. / nb;\n\twhile (ia < na || ib < nb) {\n\t\tif (ia == na) fb += nb1, ++ib;\n\t\telse if (ib == nb) fa += na1, ++ia;\n\t\telse if (a[ia] < b[ib]) fa += na1, ++ia;\n\t\telse if (a[ia] > b[ib]) fb += nb1, ++ib;\n\t\telse fa += na1, fb += nb1, ++ia, ++ib;\n\t\tif (sup < fabs(fa - fb)) sup = fabs(fa - fb);\n\t}\n\treturn sup;\n}\n\n#ifdef KF_MAIN\n#include <stdio.h>\n#include \"ksort.h\"\nKSORT_INIT_GENERIC(double)\nint main(int argc, char *argv[])\n{\n\tdouble x = 5.5, y = 3;\n\tdouble a, b;\n\tdouble xx[] = {0.22, -0.87, -2.39, -1.79, 0.37, -1.54, 1.28, -0.31, -0.74, 1.72, 0.38, -0.17, -0.62, -1.10, 0.30, 0.15, 2.30, 0.19, -0.50, -0.09};\n\tdouble yy[] = {-5.13, -2.19, -2.43, -3.83, 0.50, -3.25, 4.32, 1.63, 5.18, -0.43, 7.11, 4.87, -3.10, -5.81, 3.76, 6.31, 2.58, 0.07, 5.76, 3.50};\n\tks_introsort(double, 20, xx); ks_introsort(double, 20, yy);\n\tprintf(\"K-S distance: %f\\n\", km_ks_dist(20, xx, 20, yy));\n\tprintf(\"erfc(%lg): %lg, %lg\\n\", x, erfc(x), kf_erfc(x));\n\tprintf(\"upper-gamma(%lg,%lg): %lg\\n\", x, y, kf_gammaq(y, x)*tgamma(y));\n\ta = 2; b = 2; x = 0.5;\n\tprintf(\"incomplete-beta(%lg,%lg,%lg): %lg\\n\", a, b, x, kf_betai(a, b, x) / exp(kf_lgamma(a+b) - kf_lgamma(a) - kf_lgamma(b)));\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kmath.h",
          "type": "blob",
          "size": 1.0498046875,
          "content": "#ifndef AC_KMATH_H\n#define AC_KMATH_H\n\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\t/**************************\n\t * Non-linear programming *\n\t **************************/\n\n\t#define KMIN_RADIUS  0.5\n\t#define KMIN_EPS     1e-7\n\t#define KMIN_MAXCALL 50000\n\n\ttypedef double (*kmin_f)(int, double*, void*);\n\ttypedef double (*kmin1_f)(double, void*);\n\n\tdouble kmin_hj(kmin_f func, int n, double *x, void *data, double r, double eps, int max_calls); // Hooke-Jeeves'\n\tdouble kmin_brent(kmin1_f func, double a, double b, void *data, double tol, double *xmin); // Brent's 1-dimenssion\n\n\t/*********************\n\t * Special functions *\n\t *********************/\n\n\tdouble kf_lgamma(double z); // log gamma function\n\tdouble kf_erfc(double x); // complementary error function\n\tdouble kf_gammap(double s, double z); // regularized lower incomplete gamma function\n\tdouble kf_gammaq(double s, double z); // regularized upper incomplete gamma function\n\tdouble kf_betai(double a, double b, double x); // regularized incomplete beta function\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "knetfile.c",
          "type": "blob",
          "size": 18.0341796875,
          "content": "/* The MIT License\n\n   Copyright (c) 2008 by Genome Research Ltd (GRL).\n                 2010 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* Probably I will not do socket programming in the next few years and\n   therefore I decide to heavily annotate this file, for Linux and\n   Windows as well.  -ac */\n\n#include <time.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n\n#ifndef _WIN32\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#endif\n\n#include \"knetfile.h\"\n\n/* In winsock.h, the type of a socket is SOCKET, which is: \"typedef\n * u_int SOCKET\". An invalid SOCKET is: \"(SOCKET)(~0)\", or signed\n * integer -1. In knetfile.c, I use \"int\" for socket type\n * throughout. This should be improved to avoid confusion.\n *\n * In Linux/Mac, recv() and read() do almost the same thing. You can see\n * in the header file that netread() is simply an alias of read(). In\n * Windows, however, they are different and using recv() is mandatory.\n */\n\n/* This function tests if the file handler is ready for reading (or\n * writing if is_read==0). */\nstatic int socket_wait(int fd, int is_read)\n{\n\tfd_set fds, *fdr = 0, *fdw = 0;\n\tstruct timeval tv;\n\tint ret;\n\ttv.tv_sec = 5; tv.tv_usec = 0; // 5 seconds time out\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\tif (is_read) fdr = &fds;\n\telse fdw = &fds;\n\tret = select(fd+1, fdr, fdw, 0, &tv);\n#ifndef _WIN32\n\tif (ret == -1) perror(\"select\");\n#else\n\tif (ret == 0)\n\t\tfprintf(stderr, \"select time-out\\n\");\n\telse if (ret == SOCKET_ERROR)\n\t\tfprintf(stderr, \"select: %d\\n\", WSAGetLastError());\n#endif\n\treturn ret;\n}\n\n#ifndef _WIN32\n/* This function does not work with Windows due to the lack of\n * getaddrinfo() in winsock. It is addapted from an example in \"Beej's\n * Guide to Network Programming\" (http://beej.us/guide/bgnet/). */\nstatic int socket_connect(const char *host, const char *port)\n{\n#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)\n\n\tint ai_err, on = 1, fd;\n\tstruct linger lng = { 0, 0 };\n\tstruct addrinfo hints, *res = 0;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\t/* In Unix/Mac, getaddrinfo() is the most convenient way to get\n\t * server information. */\n\tif ((ai_err = getaddrinfo(host, port, &hints, &res)) != 0) { fprintf(stderr, \"can't resolve %s:%s: %s\\n\", host, port, gai_strerror(ai_err)); return -1; }\n\tif ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect(\"socket\");\n\t/* The following two setsockopt() are used by ftplib\n\t * (http://nbpfaus.net/~pfau/ftplib/). I am not sure if they\n\t * necessary. */\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect(\"setsockopt\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect(\"setsockopt\");\n\tif (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect(\"connect\");\n\tfreeaddrinfo(res);\n\treturn fd;\n}\n#else\n/* MinGW's printf has problem with \"%lld\" */\nchar *int64tostr(char *buf, int64_t x)\n{\n\tint cnt;\n\tint i = 0;\n\tdo {\n\t\tbuf[i++] = '0' + x % 10;\n\t\tx /= 10;\n\t} while (x);\n\tbuf[i] = 0;\n\tfor (cnt = i, i = 0; i < cnt/2; ++i) {\n\t\tint c = buf[i]; buf[i] = buf[cnt-i-1]; buf[cnt-i-1] = c;\n\t}\n\treturn buf;\n}\n\nint64_t strtoint64(const char *buf)\n{\n\tint64_t x;\n\tfor (x = 0; *buf != '\\0'; ++buf)\n\t\tx = x * 10 + ((int64_t) *buf - 48);\n\treturn x;\n}\n/* In windows, the first thing is to establish the TCP connection. */\nint knet_win32_init()\n{\n\tWSADATA wsaData;\n\treturn WSAStartup(MAKEWORD(2, 2), &wsaData);\n}\nvoid knet_win32_destroy()\n{\n\tWSACleanup();\n}\n/* A slightly modfied version of the following function also works on\n * Mac (and presummably Linux). However, this function is not stable on\n * my Mac. It sometimes works fine but sometimes does not. Therefore for\n * non-Windows OS, I do not use this one. */\nstatic SOCKET socket_connect(const char *host, const char *port)\n{\n#define __err_connect(func)\t\t\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfprintf(stderr, \"%s: %d\\n\", func, WSAGetLastError());\t\\\n\t\treturn -1;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tint on = 1;\n\tSOCKET fd;\n\tstruct linger lng = { 0, 0 };\n\tstruct sockaddr_in server;\n\tstruct hostent *hp = 0;\n\t// open socket\n\tif ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) __err_connect(\"socket\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&on, sizeof(on)) == -1) __err_connect(\"setsockopt\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char*)&lng, sizeof(lng)) == -1) __err_connect(\"setsockopt\");\n\t// get host info\n\tif (isalpha(host[0])) hp = gethostbyname(host);\n\telse {\n\t\tstruct in_addr addr;\n\t\taddr.s_addr = inet_addr(host);\n\t\thp = gethostbyaddr((char*)&addr, 4, AF_INET);\n\t}\n\tif (hp == 0) __err_connect(\"gethost\");\n\t// connect\n\tserver.sin_addr.s_addr = *((unsigned long*)hp->h_addr);\n\tserver.sin_family= AF_INET;\n\tserver.sin_port = htons(atoi(port));\n\tif (connect(fd, (struct sockaddr*)&server, sizeof(server)) != 0) __err_connect(\"connect\");\n\t// freehostent(hp); // strangely in MSDN, hp is NOT freed (memory leak?!)\n\treturn fd;\n}\n#endif\n\nstatic off_t my_netread(int fd, void *buf, off_t len)\n{\n\toff_t rest = len, curr, l = 0;\n\t/* recv() and read() may not read the required length of data with\n\t * one call. They have to be called repeatedly. */\n\twhile (rest) {\n\t\tif (socket_wait(fd, 1) <= 0) break; // socket is not ready for reading\n\t\tcurr = netread(fd, buf + l, rest);\n\t\t/* According to the glibc manual, section 13.2, a zero returned\n\t\t * value indicates end-of-file (EOF), which should mean that\n\t\t * read() will not return zero if EOF has not been met but data\n\t\t * are not immediately available. */\n\t\tif (curr == 0) break;\n\t\tl += curr; rest -= curr;\n\t}\n\treturn l;\n}\n\n/*************************\n * FTP specific routines *\n *************************/\n\nstatic int kftp_get_response(knetFile *ftp)\n{\n#ifndef _WIN32\n\tunsigned char c;\n#else\n\tchar c;\n#endif\n\tint n = 0;\n\tchar *p;\n\tif (socket_wait(ftp->ctrl_fd, 1) <= 0) return 0;\n\twhile (netread(ftp->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O\n\t\t//fputc(c, stderr);\n\t\tif (n >= ftp->max_response) {\n\t\t\tftp->max_response = ftp->max_response? ftp->max_response<<1 : 256;\n\t\t\tftp->response = (char*)realloc(ftp->response, ftp->max_response);\n\t\t}\n\t\tftp->response[n++] = c;\n\t\tif (c == '\\n') {\n\t\t\tif (n >= 4 && isdigit(ftp->response[0]) && isdigit(ftp->response[1]) && isdigit(ftp->response[2])\n\t\t\t\t&& ftp->response[3] != '-') break;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (n < 2) return -1;\n\tftp->response[n-2] = 0;\n\treturn strtol(ftp->response, &p, 0);\n}\n\nstatic int kftp_send_cmd(knetFile *ftp, const char *cmd, int is_get)\n{\n\tif (socket_wait(ftp->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing\n\tnetwrite(ftp->ctrl_fd, cmd, strlen(cmd));\n\treturn is_get? kftp_get_response(ftp) : 0;\n}\n\nstatic int kftp_pasv_prep(knetFile *ftp)\n{\n\tchar *p;\n\tint v[6];\n\tkftp_send_cmd(ftp, \"PASV\\r\\n\", 1);\n\tfor (p = ftp->response; *p && *p != '('; ++p);\n\tif (*p != '(') return -1;\n\t++p;\n\tsscanf(p, \"%d,%d,%d,%d,%d,%d\", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);\n\tmemcpy(ftp->pasv_ip, v, 4 * sizeof(int));\n\tftp->pasv_port = (v[4]<<8&0xff00) + v[5];\n\treturn 0;\n}\n\n\nstatic int kftp_pasv_connect(knetFile *ftp)\n{\n\tchar host[80], port[10];\n\tif (ftp->pasv_port == 0) {\n\t\tfprintf(stderr, \"[kftp_pasv_connect] kftp_pasv_prep() is not called before hand.\\n\");\n\t\treturn -1;\n\t}\n\tsprintf(host, \"%d.%d.%d.%d\", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);\n\tsprintf(port, \"%d\", ftp->pasv_port);\n\tftp->fd = socket_connect(host, port);\n\tif (ftp->fd == -1) return -1;\n\treturn 0;\n}\n\nint kftp_connect(knetFile *ftp)\n{\n\tftp->ctrl_fd = socket_connect(ftp->host, ftp->port);\n\tif (ftp->ctrl_fd == -1) return -1;\n\tkftp_get_response(ftp);\n\tkftp_send_cmd(ftp, \"USER anonymous\\r\\n\", 1);\n\tkftp_send_cmd(ftp, \"PASS kftp@\\r\\n\", 1);\n\tkftp_send_cmd(ftp, \"TYPE I\\r\\n\", 1);\n\treturn 0;\n}\n\nint kftp_reconnect(knetFile *ftp)\n{\n\tif (ftp->ctrl_fd != -1) {\n\t\tnetclose(ftp->ctrl_fd);\n\t\tftp->ctrl_fd = -1;\n\t}\n\tnetclose(ftp->fd);\n\tftp->fd = -1;\n\treturn kftp_connect(ftp);\n}\n\n// initialize ->type, ->host, ->retr and ->size\nknetFile *kftp_parse_url(const char *fn, const char *mode)\n{\n\tknetFile *fp;\n\tchar *p;\n\tint l;\n\tif (strstr(fn, \"ftp://\") != fn) return 0;\n\tfor (p = (char*)fn + 6; *p && *p != '/'; ++p);\n\tif (*p != '/') return 0;\n\tl = p - fn - 6;\n\tfp = (knetFile*)calloc(1, sizeof(knetFile));\n\tfp->type = KNF_TYPE_FTP;\n\tfp->fd = -1;\n\t/* the Linux/Mac version of socket_connect() also recognizes a port\n\t * like \"ftp\", but the Windows version does not. */\n\tfp->port = strdup(\"21\");\n\tfp->host = (char*)calloc(l + 1, 1);\n\tif (strchr(mode, 'c')) fp->no_reconnect = 1;\n\tstrncpy(fp->host, fn + 6, l);\n\tfp->retr = (char*)calloc(strlen(p) + 8, 1);\n\tsprintf(fp->retr, \"RETR %s\\r\\n\", p);\n    fp->size_cmd = (char*)calloc(strlen(p) + 8, 1);\n    sprintf(fp->size_cmd, \"SIZE %s\\r\\n\", p);\n\tfp->seek_offset = 0;\n\treturn fp;\n}\n// place ->fd at offset off\nint kftp_connect_file(knetFile *fp)\n{\n\tint ret;\n\tlong long file_size;\n\tif (fp->fd != -1) {\n\t\tnetclose(fp->fd);\n\t\tif (fp->no_reconnect) kftp_get_response(fp);\n\t}\n\tkftp_pasv_prep(fp);\n    kftp_send_cmd(fp, fp->size_cmd, 1);\n#ifndef _WIN32\n    if ( sscanf(fp->response,\"%*d %lld\", &file_size) != 1 )\n    {\n        fprintf(stderr,\"[kftp_connect_file] %s\\n\", fp->response);\n        return -1;\n    }\n#else\n\tconst char *p = fp->response;\n\twhile (*p != ' ') ++p;\n\twhile (*p < '0' || *p > '9') ++p;\n\tfile_size = strtoint64(p);\n#endif\n\tfp->file_size = file_size;\n\tif (fp->offset>=0) {\n\t\tchar tmp[32];\n#ifndef _WIN32\n\t\tsprintf(tmp, \"REST %lld\\r\\n\", (long long)fp->offset);\n#else\n\t\tstrcpy(tmp, \"REST \");\n\t\tint64tostr(tmp + 5, fp->offset);\n\t\tstrcat(tmp, \"\\r\\n\");\n#endif\n\t\tkftp_send_cmd(fp, tmp, 1);\n\t}\n\tkftp_send_cmd(fp, fp->retr, 0);\n\tkftp_pasv_connect(fp);\n\tret = kftp_get_response(fp);\n\tif (ret != 150) {\n\t\tfprintf(stderr, \"[kftp_connect_file] %s\\n\", fp->response);\n\t\tnetclose(fp->fd);\n\t\tfp->fd = -1;\n\t\treturn -1;\n\t}\n\tfp->is_ready = 1;\n\treturn 0;\n}\n\n\n/**************************\n * HTTP specific routines *\n **************************/\n\nknetFile *khttp_parse_url(const char *fn, const char *mode)\n{\n\tknetFile *fp;\n\tchar *p, *proxy, *q;\n\tint l;\n\tif (strstr(fn, \"http://\") != fn) return 0;\n\t// set ->http_host\n\tfor (p = (char*)fn + 7; *p && *p != '/'; ++p);\n\tl = p - fn - 7;\n\tfp = (knetFile*)calloc(1, sizeof(knetFile));\n\tfp->http_host = (char*)calloc(l + 1, 1);\n\tstrncpy(fp->http_host, fn + 7, l);\n\tfp->http_host[l] = 0;\n\tfor (q = fp->http_host; *q && *q != ':'; ++q);\n\tif (*q == ':') *q++ = 0;\n\t// get http_proxy\n\tproxy = getenv(\"http_proxy\");\n\t// set ->host, ->port and ->path\n\tif (proxy == 0) {\n\t\tfp->host = strdup(fp->http_host); // when there is no proxy, server name is identical to http_host name.\n\t\tfp->port = strdup(*q? q : \"80\");\n\t\tfp->path = strdup(*p? p : \"/\");\n\t} else {\n\t\tfp->host = (strstr(proxy, \"http://\") == proxy)? strdup(proxy + 7) : strdup(proxy);\n\t\tfor (q = fp->host; *q && *q != ':'; ++q);\n\t\tif (*q == ':') *q++ = 0; \n\t\tfp->port = strdup(*q? q : \"80\");\n\t\tfp->path = strdup(fn);\n\t}\n\tfp->type = KNF_TYPE_HTTP;\n\tfp->ctrl_fd = fp->fd = -1;\n\tfp->seek_offset = 0;\n\treturn fp;\n}\n\nint khttp_connect_file(knetFile *fp)\n{\n\tint ret, l = 0;\n\tchar *buf, *p;\n\tif (fp->fd != -1) netclose(fp->fd);\n\tfp->fd = socket_connect(fp->host, fp->port);\n\tbuf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.\n\tl += sprintf(buf + l, \"GET %s HTTP/1.0\\r\\nHost: %s\\r\\n\", fp->path, fp->http_host);\n    l += sprintf(buf + l, \"Range: bytes=%lld-\\r\\n\", (long long)fp->offset);\n\tl += sprintf(buf + l, \"\\r\\n\");\n\tnetwrite(fp->fd, buf, l);\n\tl = 0;\n\twhile (netread(fp->fd, buf + l, 1)) { // read HTTP header; FIXME: bad efficiency\n\t\tif (buf[l] == '\\n' && l >= 3)\n\t\t\tif (strncmp(buf + l - 3, \"\\r\\n\\r\\n\", 4) == 0) break;\n\t\t++l;\n\t}\n\tbuf[l] = 0;\n\tif (l < 14) { // prematured header\n\t\tnetclose(fp->fd);\n\t\tfp->fd = -1;\n\t\treturn -1;\n\t}\n\tret = strtol(buf + 8, &p, 0); // HTTP return code\n\tif (ret == 200 && fp->offset>0) { // 200 (complete result); then skip beginning of the file\n\t\toff_t rest = fp->offset;\n\t\twhile (rest) {\n\t\t\toff_t l = rest < 0x10000? rest : 0x10000;\n\t\t\trest -= my_netread(fp->fd, buf, l);\n\t\t}\n\t} else if (ret != 206 && ret != 200) {\n\t\tfree(buf);\n\t\tfprintf(stderr, \"[khttp_connect_file] fail to open file (HTTP code: %d).\\n\", ret);\n\t\tnetclose(fp->fd);\n\t\tfp->fd = -1;\n\t\treturn -1;\n\t}\n\tfree(buf);\n\tfp->is_ready = 1;\n\treturn 0;\n}\n\n/********************\n * Generic routines *\n ********************/\n\nknetFile *knet_open(const char *fn, const char *mode)\n{\n\tknetFile *fp = 0;\n\tif (mode[0] != 'r') {\n\t\tfprintf(stderr, \"[kftp_open] only mode \\\"r\\\" is supported.\\n\");\n\t\treturn 0;\n\t}\n\tif (strstr(fn, \"ftp://\") == fn) {\n\t\tfp = kftp_parse_url(fn, mode);\n\t\tif (fp == 0) return 0;\n\t\tif (kftp_connect(fp) == -1) {\n\t\t\tknet_close(fp);\n\t\t\treturn 0;\n\t\t}\n\t\tkftp_connect_file(fp);\n\t} else if (strstr(fn, \"http://\") == fn) {\n\t\tfp = khttp_parse_url(fn, mode);\n\t\tif (fp == 0) return 0;\n\t\tkhttp_connect_file(fp);\n\t} else { // local file\n#ifdef _WIN32\n\t\t/* In windows, O_BINARY is necessary. In Linux/Mac, O_BINARY may\n\t\t * be undefined on some systems, although it is defined on my\n\t\t * Mac and the Linux I have tested on. */\n\t\tint fd = open(fn, O_RDONLY | O_BINARY);\n#else\t\t\n\t\tint fd = open(fn, O_RDONLY);\n#endif\n\t\tif (fd == -1) {\n\t\t\tperror(\"open\");\n\t\t\treturn 0;\n\t\t}\n\t\tfp = (knetFile*)calloc(1, sizeof(knetFile));\n\t\tfp->type = KNF_TYPE_LOCAL;\n\t\tfp->fd = fd;\n\t\tfp->ctrl_fd = -1;\n\t}\n\tif (fp && fp->fd == -1) {\n\t\tknet_close(fp);\n\t\treturn 0;\n\t}\n\treturn fp;\n}\n\nknetFile *knet_dopen(int fd, const char *mode)\n{\n\tknetFile *fp = (knetFile*)calloc(1, sizeof(knetFile));\n\tfp->type = KNF_TYPE_LOCAL;\n\tfp->fd = fd;\n\treturn fp;\n}\n\noff_t knet_read(knetFile *fp, void *buf, off_t len)\n{\n\toff_t l = 0;\n\tif (fp->fd == -1) return 0;\n\tif (fp->type == KNF_TYPE_FTP) {\n\t\tif (fp->is_ready == 0) {\n\t\t\tif (!fp->no_reconnect) kftp_reconnect(fp);\n\t\t\tkftp_connect_file(fp);\n\t\t}\n\t} else if (fp->type == KNF_TYPE_HTTP) {\n\t\tif (fp->is_ready == 0)\n\t\t\tkhttp_connect_file(fp);\n\t}\n\tif (fp->type == KNF_TYPE_LOCAL) { // on Windows, the following block is necessary; not on UNIX\n\t\toff_t rest = len, curr;\n\t\twhile (rest) {\n\t\t\tdo {\n\t\t\t\tcurr = read(fp->fd, buf + l, rest);\n\t\t\t} while (curr < 0 && EINTR == errno);\n\t\t\tif (curr < 0) return -1;\n\t\t\tif (curr == 0) break;\n\t\t\tl += curr; rest -= curr;\n\t\t}\n\t} else l = my_netread(fp->fd, buf, len);\n\tfp->offset += l;\n\treturn l;\n}\n\noff_t knet_seek(knetFile *fp, int64_t off, int whence)\n{\n\tif (whence == SEEK_SET && off == fp->offset) return 0;\n\tif (fp->type == KNF_TYPE_LOCAL) {\n\t\t/* Be aware that lseek() returns the offset after seeking,\n\t\t * while fseek() returns zero on success. */\n\t\toff_t offset = lseek(fp->fd, off, whence);\n\t\tif (offset == -1) {\n            // Be silent, it is OK for knet_seek to fail when the file is streamed\n            // fprintf(stderr,\"[knet_seek] %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tfp->offset = offset;\n\t\treturn off;\n\t} else if (fp->type == KNF_TYPE_FTP) {\n        if (whence==SEEK_CUR)\n            fp->offset += off;\n        else if (whence==SEEK_SET)\n            fp->offset = off;\n        else if ( whence==SEEK_END)\n            fp->offset = fp->file_size+off;\n\t\tfp->is_ready = 0;\n\t\treturn off;\n\t} else if (fp->type == KNF_TYPE_HTTP) {\n\t\tif (whence == SEEK_END) { // FIXME: can we allow SEEK_END in future?\n\t\t\tfprintf(stderr, \"[knet_seek] SEEK_END is not supported for HTTP. Offset is unchanged.\\n\");\n\t\t\terrno = ESPIPE;\n\t\t\treturn -1;\n\t\t}\n        if (whence==SEEK_CUR)\n            fp->offset += off;\n        else if (whence==SEEK_SET)\n            fp->offset = off;\n\t\tfp->is_ready = 0;\n\t\treturn off;\n\t}\n\terrno = EINVAL;\n    fprintf(stderr,\"[knet_seek] %s\\n\", strerror(errno));\n\treturn -1;\n}\n\nint knet_close(knetFile *fp)\n{\n\tif (fp == 0) return 0;\n\tif (fp->ctrl_fd != -1) netclose(fp->ctrl_fd); // FTP specific\n\tif (fp->fd != -1) {\n\t\t/* On Linux/Mac, netclose() is an alias of close(), but on\n\t\t * Windows, it is an alias of closesocket(). */\n\t\tif (fp->type == KNF_TYPE_LOCAL) close(fp->fd);\n\t\telse netclose(fp->fd);\n\t}\n\tfree(fp->host); free(fp->port);\n\tfree(fp->response); free(fp->retr); // FTP specific\n\tfree(fp->path); free(fp->http_host); // HTTP specific\n\tfree(fp);\n\treturn 0;\n}\n\n#ifdef KNETFILE_MAIN\nint main(void)\n{\n\tchar *buf;\n\tknetFile *fp;\n\tint type = 4, l;\n#ifdef _WIN32\n\tknet_win32_init();\n#endif\n\tbuf = calloc(0x100000, 1);\n\tif (type == 0) {\n\t\tfp = knet_open(\"knetfile.c\", \"r\");\n\t\tknet_seek(fp, 1000, SEEK_SET);\n\t} else if (type == 1) { // NCBI FTP, large file\n\t\tfp = knet_open(\"ftp://ftp.ncbi.nih.gov/1000genomes/ftp/data/NA12878/alignment/NA12878.chrom6.SLX.SRP000032.2009_06.bam\", \"r\");\n\t\tknet_seek(fp, 2500000000ll, SEEK_SET);\n\t\tl = knet_read(fp, buf, 255);\n\t} else if (type == 2) {\n\t\tfp = knet_open(\"ftp://ftp.sanger.ac.uk/pub4/treefam/tmp/index.shtml\", \"r\");\n\t\tknet_seek(fp, 1000, SEEK_SET);\n\t} else if (type == 3) {\n\t\tfp = knet_open(\"http://www.sanger.ac.uk/Users/lh3/index.shtml\", \"r\");\n\t\tknet_seek(fp, 1000, SEEK_SET);\n\t} else if (type == 4) {\n\t\tfp = knet_open(\"http://www.sanger.ac.uk/Users/lh3/ex1.bam\", \"r\");\n\t\tknet_read(fp, buf, 10000);\n\t\tknet_seek(fp, 20000, SEEK_SET);\n\t\tknet_seek(fp, 10000, SEEK_SET);\n\t\tl = knet_read(fp, buf+10000, 10000000) + 10000;\n\t}\n\tif (type != 4 && type != 1) {\n\t\tknet_read(fp, buf, 255);\n\t\tbuf[255] = 0;\n\t\tprintf(\"%s\\n\", buf);\n\t} else write(fileno(stdout), buf, l);\n\tknet_close(fp);\n\tfree(buf);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "knetfile.h",
          "type": "blob",
          "size": 1.5732421875,
          "content": "#ifndef KNETFILE_H\n#define KNETFILE_H\n\n#include <stdint.h>\n#include <fcntl.h>\n\n#ifndef _WIN32\n#define netread(fd, ptr, len) read(fd, ptr, len)\n#define netwrite(fd, ptr, len) write(fd, ptr, len)\n#define netclose(fd) close(fd)\n#else\n#include <winsock2.h>\n#define netread(fd, ptr, len) recv(fd, ptr, len, 0)\n#define netwrite(fd, ptr, len) send(fd, ptr, len, 0)\n#define netclose(fd) closesocket(fd)\n#endif\n\n// FIXME: currently I/O is unbuffered\n\n#define KNF_TYPE_LOCAL 1\n#define KNF_TYPE_FTP   2\n#define KNF_TYPE_HTTP  3\n\ntypedef struct knetFile_s {\n\tint type, fd;\n\tint64_t offset;\n\tchar *host, *port;\n\n\t// the following are for FTP only\n\tint ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;\n\tchar *response, *retr, *size_cmd;\n\tint64_t seek_offset; // for lazy seek\n    int64_t file_size;\n\n\t// the following are for HTTP only\n\tchar *path, *http_host;\n} knetFile;\n\n#define knet_tell(fp) ((fp)->offset)\n#define knet_fileno(fp) ((fp)->fd)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n\tint knet_win32_init();\n\tvoid knet_win32_destroy();\n#endif\n\n\tknetFile *knet_open(const char *fn, const char *mode);\n\n\t/* \n\t   This only works with local files.\n\t */\n\tknetFile *knet_dopen(int fd, const char *mode);\n\n\t/*\n\t  If ->is_ready==0, this routine updates ->fd; otherwise, it simply\n\t  reads from ->fd.\n\t */\n\toff_t knet_read(knetFile *fp, void *buf, off_t len);\n\n\t/*\n\t  This routine only sets ->offset and ->is_ready=0. It does not\n\t  communicate with the FTP server.\n\t */\n\toff_t knet_seek(knetFile *fp, int64_t off, int whence);\n\tint knet_close(knetFile *fp);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "knhx.c",
          "type": "blob",
          "size": 3.93359375,
          "content": "#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"knhx.h\"\n\ntypedef struct {\n\tint error, n, max;\n\tknhx1_t *node;\n} knaux_t;\n\nstatic inline char *add_node(const char *s, knaux_t *aux, int x)\n{\n\tchar *p, *nbeg, *nend = 0;\n\tknhx1_t *r;\n\tif (aux->n == aux->max) {\n\t\taux->max = aux->max? aux->max<<1 : 8;\n\t\taux->node = (knhx1_t*)realloc(aux->node, sizeof(knhx1_t) * aux->max);\n\t}\n\tr = aux->node + (aux->n++);\n\tr->n = x; r->parent = -1;\n\tfor (p = (char*)s, nbeg = p, r->d = -1.0; *p && *p != ',' && *p != ')'; ++p) {\n\t\tif (*p == '[') {\n\t\t\tif (nend == 0) nend = p;\n\t\t\tdo ++p; while (*p && *p != ']');\n\t\t\tif (*p == 0) {\n\t\t\t\taux->error |= KNERR_BRACKET;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (*p == ':') {\n\t\t\tif (nend == 0) nend = p;\n\t\t\tr->d = strtod(p + 1, &p);\n\t\t\t--p;\n\t\t} else if (!isgraph(*p)) if (nend == 0) nend = p;\n\t}\n\tif (nend == 0) nend = p;\n\tif (nend != nbeg) {\n\t\tr->name = (char*)calloc(nend - nbeg + 1, 1);\n\t\tstrncpy(r->name, nbeg, nend - nbeg);\n\t} else r->name = strdup(\"\");\n\treturn p;\n}\n\nknhx1_t *kn_parse(const char *nhx, int *_n, int *_error)\n{\n\tchar *p;\n\tint *stack, top, max;\n\tknaux_t *aux;\n\tknhx1_t *ret;\n\n#define __push_back(y) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (top == max) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmax = max? max<<1 : 16;\t\t\t\t\t\t\t\t\\\n\t\t\tstack = (int*)realloc(stack, sizeof(int) * max);\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tstack[top++] = (y);\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n\tstack = 0; top = max = 0;\n\tp = (char*)nhx;\n\taux = (knaux_t*)calloc(1, sizeof(knaux_t));\n\twhile (*p) {\n\t\twhile (*p && !isgraph(*p)) ++p;\n\t\tif (*p == 0) break;\n\t\tif (*p == ',') ++p;\n\t\telse if (*p == '(') {\n\t\t\t__push_back(-1);\n\t\t\t++p;\n\t\t} else if (*p == ')') {\n\t\t\tint x = aux->n, m, i;\n\t\t\tfor (i = top - 1; i >= 0; --i)\n\t\t\t\tif (stack[i] < 0) break;\n\t\t\tm = top - 1 - i;\n\t\t\tp = add_node(p + 1, aux, m);\n\t\t\taux->node[x].child = (int*)calloc(m, sizeof(int));\n\t\t\tfor (i = top - 1, m = m - 1; m >= 0; --m, --i) {\n\t\t\t\taux->node[x].child[m] = stack[i];\n\t\t\t\taux->node[stack[i]].parent = x;\n\t\t\t}\n\t\t\ttop = i;\n\t\t\t__push_back(x);\n\t\t} else {\n\t\t\t__push_back(aux->n);\n\t\t\tp = add_node(p, aux, 0);\n\t\t}\n\t}\n\t*_n = aux->n;\n\t*_error = aux->error;\n\tret = aux->node;\n\tfree(aux); free(stack);\n\treturn ret;\n}\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\nstatic inline int kputsn(const char *p, int l, kstring_t *s)\n{\n\tif (s->l + l + 1 >= s->m) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\tmemcpy(s->s + s->l, p, l);\n\ts->l += l; s->s[s->l] = 0;\n\treturn l;\n}\n\nstatic inline int kputc(int c, kstring_t *s)\n{\n\tif (s->l + 1 >= s->m) {\n\t\ts->m = s->l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\ts->s[s->l++] = c; s->s[s->l] = 0;\n\treturn c;\n}\n\nstatic void format_node_recur(const knhx1_t *node, const knhx1_t *p, kstring_t *s, char *numbuf)\n{\n\tif (p->n) {\n\t\tint i;\n\t\tkputc('(', s);\n\t\tfor (i = 0; i < p->n; ++i) {\n\t\t\tif (i) kputc(',', s);\n\t\t\tformat_node_recur(node, &node[p->child[i]], s, numbuf);\n\t\t}\n\t\tkputc(')', s);\n\t\tif (p->name) kputsn(p->name, strlen(p->name), s);\n\t\tif (p->d >= 0) {\n\t\t\tsprintf(numbuf, \":%g\", p->d);\n\t\t\tkputsn(numbuf, strlen(numbuf), s);\n\t\t}\n\t} else {\n\t  kputsn(p->name, strlen(p->name), s);\n\t  if (p->d >= 0) {\n\t    sprintf(numbuf, \":%g\", p->d);\n\t    kputsn(numbuf, strlen(numbuf), s);\n\t  }\n\t}\n}\n\nvoid kn_format(const knhx1_t *node, int root, kstring_t *s) // TODO: get rid of recursion\n{\n\tchar numbuf[128];\n\tformat_node_recur(node, &node[root], s, numbuf);\n}\n\n#ifdef KNHX_MAIN\nint main(int argc, char *argv[])\n{\n\tchar *s = \"((a[abc],d1)x:0.5,((b[&&NHX:S=MOUSE],h2)[&&NHX:S=HUMAN:B=99][blabla][&&NHX:K=foo],c))\";\n\tknhx1_t *node;\n\tint i, j, n, error;\n\tkstring_t str;\n\tnode = kn_parse(s, &n, &error);\n\tfor (i = 0; i < n; ++i) {\n\t\tknhx1_t *p = node + i;\n\t\tprintf(\"[%d] %s\\t%d\\t%d\\t%g\", i, p->name, p->parent, p->n, p->d);\n\t\tfor (j = 0; j < p->n; ++j)\n\t\t\tprintf(\"\\t%d\", p->child[j]);\n\t\tputchar('\\n');\n\t}\n\tstr.l = str.m = 0; str.s = 0;\n\tkn_format(node, n-1, &str);\n\tputs(str.s);\n\tfree(str.s);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "knhx.h",
          "type": "blob",
          "size": 0.556640625,
          "content": "#ifndef KNHX_H_\n#define KNHX_H_\n\n#define KNERR_MISSING_LEFT   0x01\n#define KNERR_MISSING_RGHT   0x02\n#define KNERR_BRACKET        0x04\n#define KNERR_COLON          0x08\n\ntypedef struct {\n\tint parent, n;\n\tint *child;\n\tchar *name;\n\tdouble d;\n} knhx1_t;\n\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tknhx1_t *kn_parse(const char *nhx, int *_n, int *_error);\n\tvoid kn_format(const knhx1_t *node, int root, kstring_t *s);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "kopen.c",
          "type": "blob",
          "size": 8.9365234375,
          "content": "#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sys/types.h>\n#ifndef _WIN32\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#endif\n\n#ifdef _WIN32\n#define _KO_NO_NET\n#endif\n\n#ifndef _KO_NO_NET\nstatic int socket_wait(int fd, int is_read)\n{\n\tfd_set fds, *fdr = 0, *fdw = 0;\n\tstruct timeval tv;\n\tint ret;\n\ttv.tv_sec = 5; tv.tv_usec = 0; // 5 seconds time out\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\tif (is_read) fdr = &fds;\n\telse fdw = &fds;\n\tret = select(fd+1, fdr, fdw, 0, &tv);\n\tif (ret == -1) perror(\"select\");\n\treturn ret;\n}\n\nstatic int socket_connect(const char *host, const char *port)\n{\n#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)\n\n\tint ai_err, on = 1, fd;\n\tstruct linger lng = { 0, 0 };\n\tstruct addrinfo hints, *res = 0;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tif ((ai_err = getaddrinfo(host, port, &hints, &res)) != 0) { fprintf(stderr, \"can't resolve %s:%s: %s\\n\", host, port, gai_strerror(ai_err)); return -1; }\n\tif ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect(\"socket\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect(\"setsockopt\");\n\tif (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect(\"setsockopt\");\n\tif (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect(\"connect\");\n\tfreeaddrinfo(res);\n\treturn fd;\n#undef __err_connect\n}\n\nstatic int http_open(const char *fn)\n{\n\tchar *p, *proxy, *q, *http_host, *host, *port, *path, *buf;\n\tint fd, ret, l;\n\n\t/* parse URL; adapted from khttp_parse_url() in knetfile.c */\n\tif (strstr(fn, \"http://\") != fn) return 0;\n\t// set ->http_host\n\tfor (p = (char*)fn + 7; *p && *p != '/'; ++p);\n\tl = p - fn - 7;\n\thttp_host = calloc(l + 1, 1);\n\tstrncpy(http_host, fn + 7, l);\n\thttp_host[l] = 0;\n\tfor (q = http_host; *q && *q != ':'; ++q);\n\tif (*q == ':') *q++ = 0;\n\t// get http_proxy\n\tproxy = getenv(\"http_proxy\");\n\t// set host, port and path\n\tif (proxy == 0) {\n\t\thost = strdup(http_host); // when there is no proxy, server name is identical to http_host name.\n\t\tport = strdup(*q? q : \"80\");\n\t\tpath = strdup(*p? p : \"/\");\n\t} else {\n\t\thost = (strstr(proxy, \"http://\") == proxy)? strdup(proxy + 7) : strdup(proxy);\n\t\tfor (q = host; *q && *q != ':'; ++q);\n\t\tif (*q == ':') *q++ = 0; \n\t\tport = strdup(*q? q : \"80\");\n\t\tpath = strdup(fn);\n\t}\n\n\t/* connect; adapted from khttp_connect() in knetfile.c */\n\tl = 0;\n\tfd = socket_connect(host, port);\n\tbuf = calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.\n\tl += sprintf(buf + l, \"GET %s HTTP/1.0\\r\\nHost: %s\\r\\n\", path, http_host);\n\tl += sprintf(buf + l, \"\\r\\n\");\n\twrite(fd, buf, l);\n\tl = 0;\n\twhile (read(fd, buf + l, 1)) { // read HTTP header; FIXME: bad efficiency\n\t\tif (buf[l] == '\\n' && l >= 3)\n\t\t\tif (strncmp(buf + l - 3, \"\\r\\n\\r\\n\", 4) == 0) break;\n\t\t++l;\n\t}\n\tbuf[l] = 0;\n\tif (l < 14) { // prematured header\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\tret = strtol(buf + 8, &p, 0); // HTTP return code\n\tif (ret != 200) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\tfree(buf); free(http_host); free(host); free(port); free(path);\n\treturn fd;\n}\n\ntypedef struct {\n\tint max_response, ctrl_fd;\n\tchar *response;\n} ftpaux_t;\n\nstatic int kftp_get_response(ftpaux_t *aux)\n{\n\tunsigned char c;\n\tint n = 0;\n\tchar *p;\n\tif (socket_wait(aux->ctrl_fd, 1) <= 0) return 0;\n\twhile (read(aux->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O\n\t\tif (n >= aux->max_response) {\n\t\t\taux->max_response = aux->max_response? aux->max_response<<1 : 256;\n\t\t\taux->response = realloc(aux->response, aux->max_response);\n\t\t}\n\t\taux->response[n++] = c;\n\t\tif (c == '\\n') {\n\t\t\tif (n >= 4 && isdigit(aux->response[0]) && isdigit(aux->response[1]) && isdigit(aux->response[2])\n\t\t\t\t&& aux->response[3] != '-') break;\n\t\t\tn = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (n < 2) return -1;\n\taux->response[n-2] = 0;\n\treturn strtol(aux->response, &p, 0);\n}\n\nstatic int kftp_send_cmd(ftpaux_t *aux, const char *cmd, int is_get)\n{\n\tif (socket_wait(aux->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing\n\twrite(aux->ctrl_fd, cmd, strlen(cmd));\n\treturn is_get? kftp_get_response(aux) : 0;\n}\n\nstatic int ftp_open(const char *fn)\n{\n\tchar *p, *host = 0, *port = 0, *retr = 0;\n\tchar host2[80], port2[10];\n\tint v[6], l, fd = -1, ret, pasv_port, pasv_ip[4];\n\tftpaux_t aux;\n\t\n\t/* parse URL */\n\tif (strstr(fn, \"ftp://\") != fn) return 0;\n\tfor (p = (char*)fn + 6; *p && *p != '/'; ++p);\n\tif (*p != '/') return 0;\n\tl = p - fn - 6;\n\tport = strdup(\"21\");\n\thost = calloc(l + 1, 1);\n\tstrncpy(host, fn + 6, l);\n\tretr = calloc(strlen(p) + 8, 1);\n\tsprintf(retr, \"RETR %s\\r\\n\", p);\n\t\n\t/* connect to ctrl */\n\tmemset(&aux, 0, sizeof(ftpaux_t));\n\taux.ctrl_fd = socket_connect(host, port);\n\tif (aux.ctrl_fd == -1) goto ftp_open_end; /* fail to connect ctrl */\n\n\t/* connect to the data stream */\n\tkftp_get_response(&aux);\n\tkftp_send_cmd(&aux, \"USER anonymous\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"PASS kopen@\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"TYPE I\\r\\n\", 1);\n\tkftp_send_cmd(&aux, \"PASV\\r\\n\", 1);\n\tfor (p = aux.response; *p && *p != '('; ++p);\n\tif (*p != '(') goto ftp_open_end;\n\t++p;\n\tsscanf(p, \"%d,%d,%d,%d,%d,%d\", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);\n\tmemcpy(pasv_ip, v, 4 * sizeof(int));\n\tpasv_port = (v[4]<<8&0xff00) + v[5];\n\tkftp_send_cmd(&aux, retr, 0);\n\tsprintf(host2, \"%d.%d.%d.%d\", pasv_ip[0], pasv_ip[1], pasv_ip[2], pasv_ip[3]);\n\tsprintf(port2, \"%d\", pasv_port);\n\tfd = socket_connect(host2, port2);\n\tif (fd == -1) goto ftp_open_end;\n\tret = kftp_get_response(&aux);\n\tif (ret != 150) {\n\t\tclose(fd);\n\t\tfd = -1;\n\t}\n\tclose(aux.ctrl_fd);\n\nftp_open_end:\n\tfree(host); free(port); free(retr); free(aux.response);\n\treturn fd;\n}\n#endif /* !defined(_KO_NO_NET) */\n\nstatic char **cmd2argv(const char *cmd)\n{\n\tint i, beg, end, argc;\n\tchar **argv, *p, *q, *str;\n\tend = strlen(cmd);\n\tfor (i = end - 1; i >= 0; --i)\n\t\tif (!isspace(cmd[i])) break;\n\tend = i + 1;\n\tfor (beg = 0; beg < end; ++beg)\n\t\tif (!isspace(cmd[beg])) break;\n\tif (beg == end) return 0;\n\tfor (i = beg + 1, argc = 0; i < end; ++i)\n\t\tif (isspace(cmd[i]) && !isspace(cmd[i-1]))\n\t\t\t++argc;\n\targv = (char**)calloc(argc + 2, sizeof(void*));\n\targv[0] = str = (char*)calloc(end - beg + 1, 1);\n\tstrncpy(argv[0], cmd + beg, end - beg);\n\tfor (i = argc = 1, q = p = str; i < end - beg; ++i)\n\t\tif (isspace(str[i])) str[i] = 0;\n\t\telse if (str[i] && str[i-1] == 0) argv[argc++] = &str[i];\n\treturn argv;\n}\n\n#define KO_STDIN    1\n#define KO_FILE     2\n#define KO_PIPE     3\n#define KO_HTTP     4\n#define KO_FTP      5\n\ntypedef struct {\n\tint type, fd;\n\tpid_t pid;\n} koaux_t;\n\nvoid *kopen(const char *fn, int *_fd)\n{\n\tkoaux_t *aux = 0;\n\t*_fd = -1;\n\tif (strstr(fn, \"http://\") == fn) {\n\t\taux = calloc(1, sizeof(koaux_t));\n\t\taux->type = KO_HTTP;\n\t\taux->fd = http_open(fn);\n\t} else if (strstr(fn, \"ftp://\") == fn) {\n\t\taux = calloc(1, sizeof(koaux_t));\n\t\taux->type = KO_FTP;\n\t\taux->fd = ftp_open(fn);\n\t} else if (strcmp(fn, \"-\") == 0) {\n\t\taux = calloc(1, sizeof(koaux_t));\n\t\taux->type = KO_STDIN;\n\t\taux->fd = STDIN_FILENO;\n\t} else {\n\t\tconst char *p, *q;\n\t\tfor (p = fn; *p; ++p)\n\t\t\tif (!isspace(*p)) break;\n\t\tif (*p == '<') { // pipe open\n\t\t\tint need_shell, pfd[2];\n\t\t\tpid_t pid;\n\t\t\t// a simple check to see if we need to invoke a shell; not always working\n\t\t\tfor (q = p + 1; *q; ++q)\n\t\t\t\tif (ispunct(*q) && *q != '.' && *q != '_' && *q != '-' && *q != ':')\n\t\t\t\t\tbreak;\n\t\t\tneed_shell = (*q != 0);\n\t\t\tpipe(pfd);\n\t\t\tpid = vfork();\n\t\t\tif (pid == -1) { /* vfork() error */\n\t\t\t\tclose(pfd[0]); close(pfd[1]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (pid == 0) { /* the child process */\n\t\t\t\tchar **argv; /* FIXME: I do not know if this will lead to a memory leak */\n\t\t\t\tclose(pfd[0]);\n\t\t\t\tdup2(pfd[1], STDOUT_FILENO);\n\t\t\t\tclose(pfd[1]);\n\t\t\t\tif (!need_shell) {\n\t\t\t\t\targv = cmd2argv(p + 1);\n\t\t\t\t\texecvp(argv[0], argv);\n\t\t\t\t\tfree(argv[0]); free(argv);\n\t\t\t\t} else execl(\"/bin/sh\", \"sh\", \"-c\", p + 1, NULL);\n\t\t\t\texit(1);\n\t\t\t} else { /* parent process */\n\t\t\t\tclose(pfd[1]);\n\t\t\t\taux = calloc(1, sizeof(koaux_t));\n\t\t\t\taux->type = KO_PIPE;\n\t\t\t\taux->fd = pfd[0];\n\t\t\t\taux->pid = pid;\n\t\t\t}\n\t\t} else {\n#ifdef _WIN32\n\t\t\t*_fd = open(fn, O_RDONLY | O_BINARY);\n#else\n\t\t\t*_fd = open(fn, O_RDONLY);\n#endif\n\t\t\tif (*_fd) {\n\t\t\t\taux = calloc(1, sizeof(koaux_t));\n\t\t\t\taux->type = KO_FILE;\n\t\t\t\taux->fd = *_fd;\n\t\t\t}\n\t\t}\n\t}\n\t*_fd = aux->fd;\n\treturn aux;\n}\n\nint kclose(void *a)\n{\n\tkoaux_t *aux = (koaux_t*)a;\n\tif (aux->type == KO_PIPE) {\n\t\tint status;\n\t\tpid_t pid;\n\t\tpid = waitpid(aux->pid, &status, WNOHANG);\n\t\tif (pid != aux->pid) kill(aux->pid, 15);\n\t}\n\treturn 0;\n}\n\n#ifdef _KO_MAIN\n#define BUF_SIZE 0x10000\nint main(int argc, char *argv[])\n{\n\tvoid *x;\n\tint l, fd;\n\tunsigned char buf[BUF_SIZE];\n\tFILE *fp;\n\tif (argc == 1) {\n\t\tfprintf(stderr, \"Usage: kopen <file>\\n\");\n\t\treturn 1;\n\t}\n\tx = kopen(argv[1], &fd);\n\tfp = fdopen(fd, \"r\");\n\tif (fp == 0) {\n\t\tfprintf(stderr, \"ERROR: fail to open the input\\n\");\n\t\treturn 1;\n\t}\n\tdo {\n\t\tif ((l = fread(buf, 1, BUF_SIZE, fp)) != 0)\n\t\t\tfwrite(buf, 1, l, stdout);\n\t} while (l == BUF_SIZE);\n\tfclose(fp);\n\tkclose(x);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "krmq.h",
          "type": "blob",
          "size": 16.044921875,
          "content": "/* The MIT License\n\n   Copyright (c) 2019 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* An example:\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"krmq.h\"\n\nstruct my_node {\n  char key;\n  KRMQ_HEAD(struct my_node) head;\n};\n#define my_cmp(p, q) (((q)->key < (p)->key) - ((p)->key < (q)->key))\nKRMQ_INIT(my, struct my_node, head, my_cmp)\n\nint main(void) {\n  const char *str = \"MNOLKQOPHIA\"; // from wiki, except a duplicate\n  struct my_node *root = 0;\n  int i, l = strlen(str);\n  for (i = 0; i < l; ++i) {        // insert in the input order\n    struct my_node *q, *p = malloc(sizeof(*p));\n    p->key = str[i];\n    q = krmq_insert(my, &root, p, 0);\n    if (p != q) free(p);           // if already present, free\n  }\n  krmq_itr_t(my) itr;\n  krmq_itr_first(my, root, &itr);  // place at first\n  do {                             // traverse\n    const struct my_node *p = krmq_at(&itr);\n    putchar(p->key);\n    free((void*)p);                // free node\n  } while (krmq_itr_next(my, &itr));\n  putchar('\\n');\n  return 0;\n}\n*/\n\n#ifndef KRMQ_H\n#define KRMQ_H\n\n#ifdef __STRICT_ANSI__\n#define inline __inline__\n#endif\n\n#define KRMQ_MAX_DEPTH 64\n\n#define krmq_size(head, p) ((p)? (p)->head.size : 0)\n#define krmq_size_child(head, q, i) ((q)->head.p[(i)]? (q)->head.p[(i)]->head.size : 0)\n\n#define KRMQ_HEAD(__type) \\\n\tstruct { \\\n\t\t__type *p[2], *s; \\\n\t\tsigned char balance; /* balance factor */ \\\n\t\tunsigned size; /* #elements in subtree */ \\\n\t}\n\n#define __KRMQ_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__scope __type *krmq_find_##suf(const __type *root, const __type *x, unsigned *cnt_) { \\\n\t\tconst __type *p = root; \\\n\t\tunsigned cnt = 0; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += krmq_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\treturn (__type*)p; \\\n\t} \\\n\t__scope __type *krmq_interval_##suf(const __type *root, const __type *x, __type **lower, __type **upper) { \\\n\t\tconst __type *p = root, *l = 0, *u = 0; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) u = p, p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) l = p, p = p->__head.p[1]; \\\n\t\t\telse { l = u = p; break; } \\\n\t\t} \\\n\t\tif (lower) *lower = (__type*)l; \\\n\t\tif (upper) *upper = (__type*)u; \\\n\t\treturn (__type*)p; \\\n\t}\n\n#define __KRMQ_RMQ(suf, __scope, __type, __head,  __cmp, __lt2) \\\n\t__scope __type *krmq_rmq_##suf(const __type *root, const __type *lo, const __type *up) { /* CLOSED interval */ \\\n\t\tconst __type *p = root, *path[2][KRMQ_MAX_DEPTH], *min; \\\n\t\tint plen[2] = {0, 0}, pcmp[2][KRMQ_MAX_DEPTH], i, cmp, lca; \\\n\t\tif (root == 0) return 0; \\\n\t\twhile (p) { \\\n\t\t\tcmp = __cmp(lo, p); \\\n\t\t\tpath[0][plen[0]] = p, pcmp[0][plen[0]++] = cmp; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tp = root; \\\n\t\twhile (p) { \\\n\t\t\tcmp = __cmp(up, p); \\\n\t\t\tpath[1][plen[1]] = p, pcmp[1][plen[1]++] = cmp; \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\tfor (i = 0; i < plen[0] && i < plen[1]; ++i) /* find the LCA */ \\\n\t\t\tif (path[0][i] == path[1][i] && pcmp[0][i] <= 0 && pcmp[1][i] >= 0) \\\n\t\t\t\tbreak; \\\n\t\tif (i == plen[0] || i == plen[1]) return 0; /* no elements in the closed interval */ \\\n\t\tlca = i, min = path[0][lca]; \\\n\t\tfor (i = lca + 1; i < plen[0]; ++i) { \\\n\t\t\tif (pcmp[0][i] <= 0) { \\\n\t\t\t\tif (__lt2(path[0][i], min)) min = path[0][i]; \\\n\t\t\t\tif (path[0][i]->__head.p[1] && __lt2(path[0][i]->__head.p[1]->__head.s, min)) \\\n\t\t\t\t\tmin = path[0][i]->__head.p[1]->__head.s; \\\n\t\t\t} \\\n\t\t} \\\n\t\tfor (i = lca + 1; i < plen[1]; ++i) { \\\n\t\t\tif (pcmp[1][i] >= 0) { \\\n\t\t\t\tif (__lt2(path[1][i], min)) min = path[1][i]; \\\n\t\t\t\tif (path[1][i]->__head.p[0] && __lt2(path[1][i]->__head.p[0]->__head.s, min)) \\\n\t\t\t\t\tmin = path[1][i]->__head.p[0]->__head.s; \\\n\t\t\t} \\\n\t\t} \\\n\t\treturn (__type*)min; \\\n\t}\n\n#define __KRMQ_ROTATE(suf, __type, __head, __lt2) \\\n\t/* */ \\\n\tstatic inline void krmq_update_min_##suf(__type *p, const __type *q, const __type *r) { \\\n\t\tp->__head.s = !q || __lt2(p, q->__head.s)? p : q->__head.s; \\\n\t\tp->__head.s = !r || __lt2(p->__head.s, r->__head.s)? p->__head.s : r->__head.s; \\\n\t} \\\n\t/* one rotation: (a,(b,c)q)p => ((a,b)p,c)q */ \\\n\tstatic inline __type *krmq_rotate1_##suf(__type *p, int dir) { /* dir=0 to left; dir=1 to right */ \\\n\t\tint opp = 1 - dir; /* opposite direction */ \\\n\t\t__type *q = p->__head.p[opp], *s = p->__head.s; \\\n\t\tunsigned size_p = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - krmq_size_child(__head, q, dir); \\\n\t\tq->__head.size = size_p; \\\n\t\tkrmq_update_min_##suf(p, p->__head.p[dir], q->__head.p[dir]); \\\n\t\tq->__head.s = s; \\\n\t\tp->__head.p[opp] = q->__head.p[dir]; \\\n\t\tq->__head.p[dir] = p; \\\n\t\treturn q; \\\n\t} \\\n\t/* two consecutive rotations: (a,((b,c)r,d)q)p => ((a,b)p,(c,d)q)r */ \\\n\tstatic inline __type *krmq_rotate2_##suf(__type *p, int dir) { \\\n\t\tint b1, opp = 1 - dir; \\\n\t\t__type *q = p->__head.p[opp], *r = q->__head.p[dir], *s = p->__head.s; \\\n\t\tunsigned size_x_dir = krmq_size_child(__head, r, dir); \\\n\t\tr->__head.size = p->__head.size; \\\n\t\tp->__head.size -= q->__head.size - size_x_dir; \\\n\t\tq->__head.size -= size_x_dir + 1; \\\n\t\tkrmq_update_min_##suf(p, p->__head.p[dir], r->__head.p[dir]); \\\n\t\tkrmq_update_min_##suf(q, q->__head.p[opp], r->__head.p[opp]); \\\n\t\tr->__head.s = s; \\\n\t\tp->__head.p[opp] = r->__head.p[dir]; \\\n\t\tr->__head.p[dir] = p; \\\n\t\tq->__head.p[dir] = r->__head.p[opp]; \\\n\t\tr->__head.p[opp] = q; \\\n\t\tb1 = dir == 0? +1 : -1; \\\n\t\tif (r->__head.balance == b1) q->__head.balance = 0, p->__head.balance = -b1; \\\n\t\telse if (r->__head.balance == 0) q->__head.balance = p->__head.balance = 0; \\\n\t\telse q->__head.balance = b1, p->__head.balance = 0; \\\n\t\tr->__head.balance = 0; \\\n\t\treturn r; \\\n\t}\n\n#define __KRMQ_INSERT(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__scope __type *krmq_insert_##suf(__type **root_, __type *x, unsigned *cnt_) { \\\n\t\tunsigned char stack[KRMQ_MAX_DEPTH]; \\\n\t\t__type *path[KRMQ_MAX_DEPTH]; \\\n\t\t__type *bp, *bq; \\\n\t\t__type *p, *q, *r = 0; /* _r_ is potentially the new root */ \\\n\t\tint i, which = 0, top, b1, path_len; \\\n\t\tunsigned cnt = 0; \\\n\t\tbp = *root_, bq = 0; \\\n\t\t/* find the insertion location */ \\\n\t\tfor (p = bp, q = bq, top = path_len = 0; p; q = p, p = p->__head.p[which]) { \\\n\t\t\tint cmp; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp >= 0) cnt += krmq_size_child(__head, p, 0) + 1; \\\n\t\t\tif (cmp == 0) { \\\n\t\t\t\tif (cnt_) *cnt_ = cnt; \\\n\t\t\t\treturn p; \\\n\t\t\t} \\\n\t\t\tif (p->__head.balance != 0) \\\n\t\t\t\tbq = q, bp = p, top = 0; \\\n\t\t\tstack[top++] = which = (cmp > 0); \\\n\t\t\tpath[path_len++] = p; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tx->__head.balance = 0, x->__head.size = 1, x->__head.p[0] = x->__head.p[1] = 0, x->__head.s = x; \\\n\t\tif (q == 0) *root_ = x; \\\n\t\telse q->__head.p[which] = x; \\\n\t\tif (bp == 0) return x; \\\n\t\tfor (i = 0; i < path_len; ++i) ++path[i]->__head.size; \\\n\t\tfor (i = path_len - 1; i >= 0; --i) { \\\n\t\t\tkrmq_update_min_##suf(path[i], path[i]->__head.p[0], path[i]->__head.p[1]); \\\n\t\t\tif (path[i]->__head.s != x) break; \\\n\t\t} \\\n\t\tfor (p = bp, top = 0; p != x; p = p->__head.p[stack[top]], ++top) /* update balance factors */ \\\n\t\t\tif (stack[top] == 0) --p->__head.balance; \\\n\t\t\telse ++p->__head.balance; \\\n\t\tif (bp->__head.balance > -2 && bp->__head.balance < 2) return x; /* no re-balance needed */ \\\n\t\t/* re-balance */ \\\n\t\twhich = (bp->__head.balance < 0); \\\n\t\tb1 = which == 0? +1 : -1; \\\n\t\tq = bp->__head.p[1 - which]; \\\n\t\tif (q->__head.balance == b1) { \\\n\t\t\tr = krmq_rotate1_##suf(bp, which); \\\n\t\t\tq->__head.balance = bp->__head.balance = 0; \\\n\t\t} else r = krmq_rotate2_##suf(bp, which); \\\n\t\tif (bq == 0) *root_ = r; \\\n\t\telse bq->__head.p[bp != bq->__head.p[0]] = r; \\\n\t\treturn x; \\\n\t}\n\n#define __KRMQ_ERASE(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__scope __type *krmq_erase_##suf(__type **root_, const __type *x, unsigned *cnt_) { \\\n\t\t__type *p, *path[KRMQ_MAX_DEPTH], fake; \\\n\t\tunsigned char dir[KRMQ_MAX_DEPTH]; \\\n\t\tint i, d = 0, cmp; \\\n\t\tunsigned cnt = 0; \\\n\t\tfake.__head.p[0] = *root_, fake.__head.p[1] = 0; \\\n\t\tif (cnt_) *cnt_ = 0; \\\n\t\tif (x) { \\\n\t\t\tfor (cmp = -1, p = &fake; cmp; cmp = __cmp(x, p)) { \\\n\t\t\t\tint which = (cmp > 0); \\\n\t\t\t\tif (cmp > 0) cnt += krmq_size_child(__head, p, 0) + 1; \\\n\t\t\t\tdir[d] = which; \\\n\t\t\t\tpath[d++] = p; \\\n\t\t\t\tp = p->__head.p[which]; \\\n\t\t\t\tif (p == 0) { \\\n\t\t\t\t\tif (cnt_) *cnt_ = 0; \\\n\t\t\t\t\treturn 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t\tcnt += krmq_size_child(__head, p, 0) + 1; /* because p==x is not counted */ \\\n\t\t} else { \\\n\t\t\tfor (p = &fake, cnt = 1; p; p = p->__head.p[0]) \\\n\t\t\t\tdir[d] = 0, path[d++] = p; \\\n\t\t\tp = path[--d]; \\\n\t\t} \\\n\t\tif (cnt_) *cnt_ = cnt; \\\n\t\tfor (i = 1; i < d; ++i) --path[i]->__head.size; \\\n\t\tif (p->__head.p[1] == 0) { /* ((1,.)2,3)4 => (1,3)4; p=2 */ \\\n\t\t\tpath[d-1]->__head.p[dir[d-1]] = p->__head.p[0]; \\\n\t\t} else { \\\n\t\t\t__type *q = p->__head.p[1]; \\\n\t\t\tif (q->__head.p[0] == 0) { /* ((1,2)3,4)5 => ((1)2,4)5; p=3,q=2 */ \\\n\t\t\t\tq->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = q; \\\n\t\t\t\tpath[d] = q, dir[d++] = 1; \\\n\t\t\t\tq->__head.size = p->__head.size - 1; \\\n\t\t\t} else { /* ((1,((.,2)3,4)5)6,7)8 => ((1,(2,4)5)3,7)8; p=6 */ \\\n\t\t\t\t__type *r; \\\n\t\t\t\tint e = d++; /* backup _d_ */\\\n\t\t\t\tfor (;;) { \\\n\t\t\t\t\tdir[d] = 0; \\\n\t\t\t\t\tpath[d++] = q; \\\n\t\t\t\t\tr = q->__head.p[0]; \\\n\t\t\t\t\tif (r->__head.p[0] == 0) break; \\\n\t\t\t\t\tq = r; \\\n\t\t\t\t} \\\n\t\t\t\tr->__head.p[0] = p->__head.p[0]; \\\n\t\t\t\tq->__head.p[0] = r->__head.p[1]; \\\n\t\t\t\tr->__head.p[1] = p->__head.p[1]; \\\n\t\t\t\tr->__head.balance = p->__head.balance; \\\n\t\t\t\tpath[e-1]->__head.p[dir[e-1]] = r; \\\n\t\t\t\tpath[e] = r, dir[e] = 1; \\\n\t\t\t\tfor (i = e + 1; i < d; ++i) --path[i]->__head.size; \\\n\t\t\t\tr->__head.size = p->__head.size - 1; \\\n\t\t\t} \\\n\t\t} \\\n\t\tfor (i = d - 1; i >= 0; --i) /* not sure why adding condition \"path[i]->__head.s==p\" doesn't work */ \\\n\t\t\tkrmq_update_min_##suf(path[i], path[i]->__head.p[0], path[i]->__head.p[1]); \\\n\t\twhile (--d > 0) { \\\n\t\t\t__type *q = path[d]; \\\n\t\t\tint which, other, b1 = 1, b2 = 2; \\\n\t\t\twhich = dir[d], other = 1 - which; \\\n\t\t\tif (which) b1 = -b1, b2 = -b2; \\\n\t\t\tq->__head.balance += b1; \\\n\t\t\tif (q->__head.balance == b1) break; \\\n\t\t\telse if (q->__head.balance == b2) { \\\n\t\t\t\t__type *r = q->__head.p[other]; \\\n\t\t\t\tif (r->__head.balance == -b1) { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = krmq_rotate2_##suf(q, which); \\\n\t\t\t\t} else { \\\n\t\t\t\t\tpath[d-1]->__head.p[dir[d-1]] = krmq_rotate1_##suf(q, which); \\\n\t\t\t\t\tif (r->__head.balance == 0) { \\\n\t\t\t\t\t\tr->__head.balance = -b1; \\\n\t\t\t\t\t\tq->__head.balance = b1; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t} else r->__head.balance = q->__head.balance = 0; \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\t*root_ = fake.__head.p[0]; \\\n\t\treturn p; \\\n\t}\n\n#define krmq_free(__type, __head, __root, __free) do { \\\n\t\t__type *_p, *_q; \\\n\t\tfor (_p = __root; _p; _p = _q) { \\\n\t\t\tif (_p->__head.p[0] == 0) { \\\n\t\t\t\t_q = _p->__head.p[1]; \\\n\t\t\t\t__free(_p); \\\n\t\t\t} else { \\\n\t\t\t\t_q = _p->__head.p[0]; \\\n\t\t\t\t_p->__head.p[0] = _q->__head.p[1]; \\\n\t\t\t\t_q->__head.p[1] = _p; \\\n\t\t\t} \\\n\t\t} \\\n\t} while (0)\n\n#define __KRMQ_ITR(suf, __scope, __type, __head, __cmp) \\\n\tstruct krmq_itr_##suf { \\\n\t\tconst __type *stack[KRMQ_MAX_DEPTH], **top; \\\n\t}; \\\n\t__scope void krmq_itr_first_##suf(const __type *root, struct krmq_itr_##suf *itr) { \\\n\t\tconst __type *p; \\\n\t\tfor (itr->top = itr->stack - 1, p = root; p; p = p->__head.p[0]) \\\n\t\t\t*++itr->top = p; \\\n\t} \\\n\t__scope int krmq_itr_find_##suf(const __type *root, const __type *x, struct krmq_itr_##suf *itr) { \\\n\t\tconst __type *p = root; \\\n\t\titr->top = itr->stack - 1; \\\n\t\twhile (p != 0) { \\\n\t\t\tint cmp; \\\n\t\t\t*++itr->top = p; \\\n\t\t\tcmp = __cmp(x, p); \\\n\t\t\tif (cmp < 0) p = p->__head.p[0]; \\\n\t\t\telse if (cmp > 0) p = p->__head.p[1]; \\\n\t\t\telse break; \\\n\t\t} \\\n\t\treturn p? 1 : 0; \\\n\t} \\\n\t__scope int krmq_itr_next_bidir_##suf(struct krmq_itr_##suf *itr, int dir) { \\\n\t\tconst __type *p; \\\n\t\tif (itr->top < itr->stack) return 0; \\\n\t\tdir = !!dir; \\\n\t\tp = (*itr->top)->__head.p[dir]; \\\n\t\tif (p) { /* go down */ \\\n\t\t\tfor (; p; p = p->__head.p[!dir]) \\\n\t\t\t\t*++itr->top = p; \\\n\t\t\treturn 1; \\\n\t\t} else { /* go up */ \\\n\t\t\tdo { \\\n\t\t\t\tp = *itr->top--; \\\n\t\t\t} while (itr->top >= itr->stack && p == (*itr->top)->__head.p[dir]); \\\n\t\t\treturn itr->top < itr->stack? 0 : 1; \\\n\t\t} \\\n\t} \\\n\n/**\n * Insert a node to the tree\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node to insert (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return _x_ if not present in the tree, or the node equal to x.\n */\n#define krmq_insert(suf, proot, x, cnt) krmq_insert_##suf(proot, x, cnt)\n\n/**\n * Find a node in the tree\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param root    root of the tree\n * @param x       node value to find (in)\n * @param cnt     number of nodes smaller than or equal to _x_; can be NULL (out)\n *\n * @return node equal to _x_ if present, or NULL if absent\n */\n#define krmq_find(suf, root, x, cnt) krmq_find_##suf(root, x, cnt)\n#define krmq_interval(suf, root, x, lower, upper) krmq_interval_##suf(root, x, lower, upper)\n#define krmq_rmq(suf, root, lo, up) krmq_rmq_##suf(root, lo, up)\n\n/**\n * Delete a node from the tree\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param proot   pointer to the root of the tree (in/out: root may change)\n * @param x       node value to delete; if NULL, delete the first node (in)\n *\n * @return node removed from the tree if present, or NULL if absent\n */\n#define krmq_erase(suf, proot, x, cnt) krmq_erase_##suf(proot, x, cnt)\n#define krmq_erase_first(suf, proot) krmq_erase_##suf(proot, 0, 0)\n\n#define krmq_itr_t(suf) struct krmq_itr_##suf\n\n/**\n * Place the iterator at the smallest object\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param root    root of the tree\n * @param itr     iterator\n */\n#define krmq_itr_first(suf, root, itr) krmq_itr_first_##suf(root, itr)\n\n/**\n * Place the iterator at the object equal to or greater than the query\n *\n * @param suf     name suffix used in KRMQ_INIT()\n * @param root    root of the tree\n * @param x       query (in)\n * @param itr     iterator (out)\n *\n * @return 1 if find; 0 otherwise. krmq_at(itr) is NULL if and only if query is\n *         larger than all objects in the tree\n */\n#define krmq_itr_find(suf, root, x, itr) krmq_itr_find_##suf(root, x, itr)\n\n/**\n * Move to the next object in order\n *\n * @param itr     iterator (modified)\n *\n * @return 1 if there is a next object; 0 otherwise\n */\n#define krmq_itr_next(suf, itr) krmq_itr_next_bidir_##suf(itr, 1)\n#define krmq_itr_prev(suf, itr) krmq_itr_next_bidir_##suf(itr, 0)\n\n/**\n * Return the pointer at the iterator\n *\n * @param itr     iterator\n *\n * @return pointer if present; NULL otherwise\n */\n#define krmq_at(itr) ((itr)->top < (itr)->stack? 0 : *(itr)->top)\n\n#define KRMQ_INIT2(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__KRMQ_FIND(suf, __scope, __type, __head,  __cmp) \\\n\t__KRMQ_RMQ(suf, __scope, __type, __head,  __cmp, __lt2) \\\n\t__KRMQ_ROTATE(suf, __type, __head, __lt2) \\\n\t__KRMQ_INSERT(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__KRMQ_ERASE(suf, __scope, __type, __head, __cmp, __lt2) \\\n\t__KRMQ_ITR(suf, __scope, __type, __head, __cmp)\n\n#define KRMQ_INIT(suf, __type, __head, __cmp, __lt2) \\\n\tKRMQ_INIT2(suf,, __type, __head, __cmp, __lt2)\n\n#endif\n"
        },
        {
          "name": "krng.h",
          "type": "blob",
          "size": 1.1201171875,
          "content": "#ifndef KRNG_H\n#define KRNG_H\n\ntypedef struct {\n\tuint64_t s[2];\n} krng_t;\n\nstatic inline uint64_t kr_splitmix64(uint64_t x)\n{\n\tuint64_t z = (x += 0x9E3779B97F4A7C15ULL);\n\tz = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9ULL;\n\tz = (z ^ (z >> 27)) * 0x94D049BB133111EBULL;\n\treturn z ^ (z >> 31);\n}\n\nstatic inline uint64_t kr_rand_r(krng_t *r)\n{\n\tconst uint64_t s0 = r->s[0];\n\tuint64_t s1 = r->s[1];\n\tconst uint64_t result = s0 + s1;\n\ts1 ^= s0;\n\tr->s[0] = (s0 << 55 | s0 >> 9) ^ s1 ^ (s1 << 14);\n\tr->s[1] = s0 << 36 | s0 >> 28;\n\treturn result;\n}\n\nstatic inline void kr_jump_r(krng_t *r)\n{\n\tstatic const uint64_t JUMP[] = { 0xbeac0467eba5facbULL, 0xd86b048b86aa9922ULL };\n\tuint64_t s0 = 0, s1 = 0;\n\tint i, b;\n\tfor (i = 0; i < 2; ++i)\n\t\tfor (b = 0; b < 64; b++) {\n\t\t\tif (JUMP[i] & 1ULL << b)\n\t\t\t\ts0 ^= r->s[0], s1 ^= r->s[1];\n\t\t\tkr_rand_r(r);\n\t\t}\n\tr->s[0] = s0, r->s[1] = s1;\n}\n\nstatic inline void kr_srand_r(krng_t *r, uint64_t seed)\n{\n\tr->s[0] = kr_splitmix64(seed);\n\tr->s[1] = kr_splitmix64(r->s[0]);\n}\n\nstatic inline double kr_drand_r(krng_t *r)\n{\n\tunion { uint64_t i; double d; } u;\n\tu.i = 0x3FFULL << 52 | kr_rand_r(r) >> 12;\n\treturn u.d - 1.0;\n}\n\n#endif\n"
        },
        {
          "name": "ksa.c",
          "type": "blob",
          "size": 8.626953125,
          "content": "/*\n * Copyright (c) 2008 Yuta Mori    All Rights Reserved.\n *               2011 Attractive Chaos <attractor@live.co.uk>\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* This is a library for constructing the suffix array for a string containing\n * multiple sentinels with sentinels all represented by 0. The last symbol in\n * the string must be a sentinel. The library is modified from an early version\n * of Yuta Mori's SAIS library, but is slower than the lastest SAIS by about\n * 30%, partly due to the recent optimization Yuta has applied and partly due\n * to the extra comparisons between sentinels. This is not the first effort in\n * supporting multi-sentinel strings, but is probably the easiest to use. */\n\n#include <stdlib.h>\n\n#ifdef _KSA64\n#include <stdint.h>\ntypedef int64_t saint_t;\n#define SAINT_MAX INT64_MAX\n#define SAIS_CORE ksa_core64\n#define SAIS_BWT  ksa_bwt64\n#define SAIS_MAIN ksa_sa64\n#else\n#include <limits.h>\ntypedef int saint_t;\n#define SAINT_MAX INT_MAX\n#define SAIS_CORE ksa_core\n#define SAIS_BWT  ksa_bwt\n#define SAIS_MAIN ksa_sa\n#endif\n\n/* T is of type \"const unsigned char*\". If T[i] is a sentinel, chr(i) takes a negative value */\n#define chr(i) (cs == sizeof(saint_t) ? ((const saint_t *)T)[i] : (T[i]? (saint_t)T[i] : i - SAINT_MAX))\n\n/** Count the occurrences of each symbol */\nstatic void getCounts(const unsigned char *T, saint_t *C, saint_t n, saint_t k, int cs)\n{\n\tsaint_t i;\n\tfor (i = 0; i < k; ++i) C[i] = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tsaint_t c = chr(i);\n\t\t++C[c > 0? c : 0];\n\t}\n}\n\n/**\n * Find the end of each bucket\n *\n * @param C   occurrences computed by getCounts(); input\n * @param B   start/end of each bucket; output\n * @param k   size of alphabet\n * @param end compute the end of bucket if true; otherwise compute the end\n */\nstatic inline void getBuckets(const saint_t *C, saint_t *B, saint_t k, saint_t end)\n{\n\tsaint_t i, sum = 0;\n\tif (end) for (i = 0; i < k; ++i) sum += C[i], B[i] = sum;\n\telse for (i = 0; i < k; ++i) sum += C[i], B[i] = sum - C[i];\n}\n\n/** Induced sort */\nstatic void induceSA(const unsigned char *T, saint_t *SA, saint_t *C, saint_t *B, saint_t n, saint_t k, saint_t cs)\n{\n\tsaint_t *b, i, j;\n\tsaint_t  c0, c1;\n\t/* left-to-right induced sort (for L-type) */\n\tif (C == B) getCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 0);\t/* find starts of buckets */\n\tfor (i = 0, b = 0, c1 = -1; i < n; ++i) {\n\t\tj = SA[i], SA[i] = ~j;\n\t\tif (0 < j) { /* >0 if j-1 is L-type; <0 if S-type; ==0 undefined */\n\t\t\t--j;\n\t\t\tif ((c0 = chr(j)) != c1) {\n\t\t\t\tB[c1 > 0? c1 : 0] = b - SA;\n\t\t\t\tc1 = c0;\n\t\t\t\tb = SA + B[c1 > 0? c1 : 0];\n\t\t\t}\n\t\t\t*b++ = (0 < j && chr(j - 1) < c1) ? ~j : j;\n\t\t}\n\t}\n\t/* right-to-left induced sort (for S-type) */\n\tif (C == B) getCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = n - 1, b = 0, c1 = -1; 0 <= i; --i) {\n\t\tif (0 < (j = SA[i])) { /* the prefix is S-type */\n\t\t\t--j;\n\t\t\tif ((c0 = chr(j)) != c1) {\n\t\t\t\tB[c1 > 0? c1 : 0] = b - SA;\n\t\t\t\tc1 = c0;\n\t\t\t\tb = SA + B[c1 > 0? c1 : 0];\n\t\t\t}\n\t\t\tif (c0 > 0) *--b = (j == 0 || chr(j - 1) > c1) ? ~j : j;\n\t\t} else SA[i] = ~j; /* if L-type, change the sign */\n\t}\n}\n\n/**\n * Recursively construct the suffix array for a string containing multiple\n * sentinels. NULL is taken as the sentinel.\n *\n * @param T   NULL terminated input string (there can be multiple NULLs)\n * @param SA  output suffix array\n * @param fs  working space available in SA (typically 0 when first called)\n * @param n   length of T, including the trailing NULL\n * @param k   size of the alphabet (typically 256 when first called)\n * @param cs  # bytes per element in T; 1 or sizeof(saint_t) (typically 1 when first called)\n *\n * @return    0 upon success\n */\nint SAIS_CORE(const unsigned char *T, saint_t *SA, saint_t fs, saint_t n, saint_t k, int cs)\n{\n\tsaint_t *C, *B;\n\tsaint_t  i, j, c, m, q, qlen, name;\n\tsaint_t  c0, c1;\n\n\t/* STAGE I: reduce the problem by at least 1/2 sort all the S-substrings */\n\tif (k <= fs) C = SA + n, B = (k <= fs - k) ? C + k : C;\n\telse {\n\t\tif ((C = (saint_t*)malloc(k * (1 + (cs == 1)) * sizeof(saint_t))) == NULL) return -2;\n\t\tB = cs == 1? C + k : C;\n\t}\n\tgetCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = 0; i < n; ++i) SA[i] = 0;\n\t/* mark L and S (the t array in Nong et al.), and keep the positions of LMS in the buckets */\n\tfor (i = n - 2, c = 1, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\tif ((c0 = chr(i)) < c1 + c) c = 1; /* c1 = chr(i+1); c==1 if in an S run */\n\t\telse if (c) SA[--B[c1 > 0? c1 : 0]] = i + 1, c = 0;\n\t}\n\tinduceSA(T, SA, C, B, n, k, cs);\n\tif (fs < k) free(C);\n\t/* pack all the sorted LMS into the first m items of SA \n\t   2*m must be not larger than n (see Nong et al. for the proof) */\n\tfor (i = 0, m = 0; i < n; ++i) {\n\t\tsaint_t p = SA[i];\n\t\tif (p == n - 1) SA[m++] = p;\n\t\telse if (0 < p && chr(p - 1) > (c0 = chr(p))) {\n\t\t\tfor (j = p + 1; j < n && c0 == (c1 = chr(j)); ++j);\n\t\t\tif (j < n && c0 < c1) SA[m++] = p;\n\t\t}\n\t}\n\tfor (i = m; i < n; ++i) SA[i] = 0;\t/* init the name array buffer */\n\t/* store the length of all substrings */\n\tfor (i = n - 2, j = n, c = 1, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\tif ((c0 = chr(i)) < c1 + c) c = 1; /* c1 = chr(i+1) */\n\t\telse if (c) SA[m + ((i + 1) >> 1)] = j - i - 1, j = i + 1, c = 0;\n\t}\n\t/* find the lexicographic names of all substrings */\n\tfor (i = 0, name = 0, q = n, qlen = 0; i < m; ++i) {\n\t\tsaint_t p = SA[i], plen = SA[m + (p >> 1)], diff = 1;\n\t\tif (plen == qlen) {\n\t\t\tfor (j = 0; j < plen && chr(p + j) == chr(q + j); j++);\n\t\t\tif (j == plen) diff = 0;\n\t\t}\n\t\tif (diff) ++name, q = p, qlen = plen;\n\t\tSA[m + (p >> 1)] = name;\n\t}\n\n\t/* STAGE II: solve the reduced problem; recurse if names are not yet unique */\n\tif (name < m) {\n\t\tsaint_t *RA = SA + n + fs - m - 1;\n\t\tfor (i = n - 1, j = m - 1; m <= i; --i)\n\t\t\tif (SA[i] != 0) RA[j--] = SA[i];\n\t\tRA[m] = 0; // add a sentinel; in the resulting SA, SA[0]==m always stands\n\t\tif (SAIS_CORE((unsigned char *)RA, SA, fs + n - m * 2 - 2, m + 1, name + 1, sizeof(saint_t)) != 0) return -2;\n\t\tfor (i = n - 2, j = m - 1, c = 1, c1 = chr(n - 1); 0 <= i; --i, c1 = c0) {\n\t\t\tif ((c0 = chr(i)) < c1 + c) c = 1;\n\t\t\telse if (c) RA[j--] = i + 1, c = 0; /* get p1 */\n\t\t}\n\t\tfor (i = 0; i < m; ++i) SA[i] = RA[SA[i+1]]; /* get index  */\n\t}\n\n\t/* STAGE III: induce the result for the original problem */\n\tif (k <= fs) C = SA + n, B = (k <= fs - k) ? C + k : C;\n\telse {\n\t\tif ((C = (saint_t*)malloc(k * (1 + (cs == 1)) * sizeof(saint_t))) == NULL) return -2;\n\t\tB = cs == 1? C + k : C;\n\t}\n\t/* put all LMS characters into their buckets */\n\tgetCounts(T, C, n, k, cs);\n\tgetBuckets(C, B, k, 1);\t/* find ends of buckets */\n\tfor (i = m; i < n; ++i) SA[i] = 0; /* init SA[m..n-1] */\n\tfor (i = m - 1; 0 <= i; --i) {\n\t\tj = SA[i], SA[i] = 0;\n\t\tc = chr(j);\n\t\tSA[--B[c > 0? c : 0]] = j;\n\t}\n\tinduceSA(T, SA, C, B, n, k, cs);\n\tif (fs < k) free(C);\n\treturn 0;\n}\n\n/**\n * Construct the suffix array for a NULL terminated string possibly containing\n * multiple sentinels (NULLs).\n *\n * @param T[0..n-1]  NULL terminated input string\n * @param SA[0..n-1] output suffix array\n * @param n          length of the given string, including NULL\n * @param k          size of the alphabet including the sentinel; no more than 256\n * @return           0 upon success\n */\nint SAIS_MAIN(const unsigned char *T, saint_t *SA, saint_t n, int k)\n{\n\tif (T == NULL || SA == NULL || T[n - 1] != '\\0' || n <= 0) return -1;\n\tif (k < 0 || k > 256) k = 256;\n\treturn SAIS_CORE(T, SA, 0, n, (saint_t)k, 1);\n}\n\nint SAIS_BWT(unsigned char *T, saint_t n, int k)\n{\n\tsaint_t *SA, i;\n\tint ret;\n\tif ((SA = malloc(n * sizeof(saint_t))) == 0) return -1;\n\tif ((ret = SAIS_MAIN(T, SA, n, k)) != 0) return ret;\n\tfor (i = 0; i < n; ++i)\n\t\tif (SA[i]) SA[i] = T[SA[i] - 1]; // if SA[i]==0, SA[i]=0\n\tfor (i = 0; i < n; ++i) T[i] = SA[i];\n\tfree(SA);\n\treturn 0;\n}\n"
        },
        {
          "name": "kseq.h",
          "type": "blob",
          "size": 9.0068359375,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/* Last Modified: 05MAR2012 */\n\n#ifndef AC_KSEQ_H\n#define AC_KSEQ_H\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define KS_SEP_SPACE 0 // isspace(): \\t, \\n, \\v, \\f, \\r\n#define KS_SEP_TAB   1 // isspace() && !' '\n#define KS_SEP_LINE  2 // line separator: \"\\n\" (Unix) or \"\\r\\n\" (Windows)\n#define KS_SEP_MAX   2\n\n#define __KS_TYPE(type_t)\t\t\t\t\t\t\\\n\ttypedef struct __kstream_t {\t\t\t\t\\\n\t\tunsigned char *buf;\t\t\t\t\t\t\\\n\t\tint begin, end, is_eof;\t\t\t\t\t\\\n\t\ttype_t f;\t\t\t\t\t\t\t\t\\\n\t} kstream_t;\n\n#define ks_err(ks) ((ks)->end == -1)\n#define ks_eof(ks) ((ks)->is_eof && (ks)->begin >= (ks)->end)\n#define ks_rewind(ks) ((ks)->is_eof = (ks)->begin = (ks)->end = 0)\n\n#define __KS_BASIC(type_t, __bufsize)\t\t\t\t\t\t\t\t\\\n\tstatic inline kstream_t *ks_init(type_t f)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkstream_t *ks = (kstream_t*)calloc(1, sizeof(kstream_t));\t\\\n\t\tks->f = f;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tks->buf = (unsigned char*)malloc(__bufsize);\t\t\t\t\\\n\t\treturn ks;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void ks_destroy(kstream_t *ks)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (ks) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfree(ks->buf);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfree(ks);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define __KS_GETC(__read, __bufsize)\t\t\t\t\t\t\\\n\tstatic inline int ks_getc(kstream_t *ks)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (ks_err(ks)) return -3;\t\t\t\t\t\t\t\\\n\t\tif (ks->is_eof && ks->begin >= ks->end) return -1;\t\\\n\t\tif (ks->begin >= ks->end) {\t\t\t\t\t\t\t\\\n\t\t\tks->begin = 0;\t\t\t\t\t\t\t\t\t\\\n\t\t\tks->end = __read(ks->f, ks->buf, __bufsize);\t\\\n\t\t\tif (ks->end == 0) { ks->is_eof = 1; return -1;}\t\\\n\t\t\tif (ks->end == -1) { ks->is_eof = 1; return -3;}\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn (int)ks->buf[ks->begin++];\t\t\t\t\t\\\n\t}\n\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#define __KS_GETUNTIL(__read, __bufsize)\t\t\t\t\t\t\t\t\\\n\tstatic int ks_getuntil2(kstream_t *ks, int delimiter, kstring_t *str, int *dret, int append) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint gotany = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (dret) *dret = 0;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tstr->l = append? str->l : 0;\t\t\t\t\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tint i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (ks_err(ks)) return -3;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (ks->begin >= ks->end) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (!ks->is_eof) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tks->begin = 0;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tks->end = __read(ks->f, ks->buf, __bufsize);\t\t\\\n\t\t\t\t\tif (ks->end == 0) { ks->is_eof = 1; break; }\t\t\\\n\t\t\t\t\tif (ks->end == -1) { ks->is_eof = 1; return -3; }\t\\\n\t\t\t\t} else break;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (delimiter == KS_SEP_LINE) {\t\t\t\t\t\t\t\t\\\n\t\t\t\tunsigned char *sep = memchr(ks->buf + ks->begin, '\\n', ks->end - ks->begin); \\\n\t\t\t\ti = sep != NULL ? sep - ks->buf : ks->end;\t\t\t\t\\\n\t\t\t} else if (delimiter > KS_SEP_MAX) {\t\t\t\t\t\t\\\n\t\t\t\tunsigned char *sep = memchr(ks->buf + ks->begin, delimiter, ks->end - ks->begin); \\\n\t\t\t\ti = sep != NULL ? sep - ks->buf : ks->end;\t\t\t\t\\\n\t\t\t} else if (delimiter == KS_SEP_SPACE) {\t\t\t\t\t\t\\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i)\t\t\t\t\t\\\n\t\t\t\t\tif (isspace(ks->buf[i])) break;\t\t\t\t\t\t\\\n\t\t\t} else if (delimiter == KS_SEP_TAB) {\t\t\t\t\t\t\\\n\t\t\t\tfor (i = ks->begin; i < ks->end; ++i)\t\t\t\t\t\\\n\t\t\t\t\tif (isspace(ks->buf[i]) && ks->buf[i] != ' ') break; \\\n\t\t\t} else i = 0; /* never come to here! */\t\t\t\t\t\t\\\n\t\t\tif (str->m - str->l < (size_t)(i - ks->begin + 1)) {\t\t\\\n\t\t\t\tstr->m = str->l + (i - ks->begin) + 1;\t\t\t\t\t\\\n\t\t\t\tkroundup32(str->m);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tstr->s = (char*)realloc(str->s, str->m);\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tgotany = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemcpy(str->s + str->l, ks->buf + ks->begin, i - ks->begin); \\\n\t\t\tstr->l = str->l + (i - ks->begin);\t\t\t\t\t\t\t\\\n\t\t\tks->begin = i + 1;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (i < ks->end) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (dret) *dret = ks->buf[i];\t\t\t\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (!gotany && ks_eof(ks)) return -1;\t\t\t\t\t\t\t\\\n\t\tif (str->s == 0) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tstr->m = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tstr->s = (char*)calloc(1, 1);\t\t\t\t\t\t\t\t\\\n\t\t} else if (delimiter == KS_SEP_LINE && str->l > 1 && str->s[str->l-1] == '\\r') --str->l; \\\n\t\tstr->s[str->l] = '\\0';\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn str->l;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} \\\n\tstatic inline int ks_getuntil(kstream_t *ks, int delimiter, kstring_t *str, int *dret) \\\n\t{ return ks_getuntil2(ks, delimiter, str, dret, 0); }\n\n#define KSTREAM_INIT(type_t, __read, __bufsize) \\\n\t__KS_TYPE(type_t)\t\t\t\t\t\t\t\\\n\t__KS_BASIC(type_t, __bufsize)\t\t\t\t\\\n\t__KS_GETC(__read, __bufsize)\t\t\t\t\\\n\t__KS_GETUNTIL(__read, __bufsize)\n\n#define kseq_rewind(ks) ((ks)->last_char = (ks)->f->is_eof = (ks)->f->begin = (ks)->f->end = 0)\n\n#define __KSEQ_BASIC(SCOPE, type_t)\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE kseq_t *kseq_init(type_t fd)\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkseq_t *s = (kseq_t*)calloc(1, sizeof(kseq_t));\t\t\t\t\t\\\n\t\ts->f = ks_init(fd);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kseq_destroy(kseq_t *ks)\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (!ks) return;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(ks->name.s); free(ks->comment.s); free(ks->seq.s);\tfree(ks->qual.s); \\\n\t\tks_destroy(ks->f);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(ks);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n/* Return value:\n   >=0  length of the sequence (normal)\n   -1   end-of-file\n   -2   truncated quality string\n   -3   error reading stream\n */\n#define __KSEQ_READ(SCOPE) \\\n\tSCOPE int kseq_read(kseq_t *seq) \\\n\t{ \\\n\t\tint c,r; \\\n\t\tkstream_t *ks = seq->f; \\\n\t\tif (seq->last_char == 0) { /* then jump to the next header line */ \\\n\t\t\twhile ((c = ks_getc(ks)) >= 0 && c != '>' && c != '@'); \\\n\t\t\tif (c < 0) return c; /* end of file or error*/ \\\n\t\t\tseq->last_char = c; \\\n\t\t} /* else: the first header char has been read in the previous call */ \\\n\t\tseq->comment.l = seq->seq.l = seq->qual.l = 0; /* reset all members */ \\\n\t\tif ((r=ks_getuntil(ks, 0, &seq->name, &c)) < 0) return r;  /* normal exit: EOF or error */ \\\n\t\tif (c != '\\n') ks_getuntil(ks, KS_SEP_LINE, &seq->comment, 0); /* read FASTA/Q comment */ \\\n\t\tif (seq->seq.s == 0) { /* we can do this in the loop below, but that is slower */ \\\n\t\t\tseq->seq.m = 256; \\\n\t\t\tseq->seq.s = (char*)malloc(seq->seq.m); \\\n\t\t} \\\n\t\twhile ((c = ks_getc(ks)) >= 0 && c != '>' && c != '+' && c != '@') { \\\n\t\t\tif (c == '\\n') continue; /* skip empty lines */ \\\n\t\t\tseq->seq.s[seq->seq.l++] = c; /* this is safe: we always have enough space for 1 char */ \\\n\t\t\tks_getuntil2(ks, KS_SEP_LINE, &seq->seq, 0, 1); /* read the rest of the line */ \\\n\t\t} \\\n\t\tif (c == '>' || c == '@') seq->last_char = c; /* the first header char has been read */\t\\\n\t\tif (seq->seq.l + 1 >= seq->seq.m) { /* seq->seq.s[seq->seq.l] below may be out of boundary */ \\\n\t\t\tseq->seq.m = seq->seq.l + 2; \\\n\t\t\tkroundup32(seq->seq.m); /* rounded to the next closest 2^k */ \\\n\t\t\tseq->seq.s = (char*)realloc(seq->seq.s, seq->seq.m); \\\n\t\t} \\\n\t\tseq->seq.s[seq->seq.l] = 0;\t/* null terminated string */ \\\n\t\tif (c != '+') return seq->seq.l; /* FASTA */ \\\n\t\tif (seq->qual.m < seq->seq.m) {\t/* allocate memory for qual in case insufficient */ \\\n\t\t\tseq->qual.m = seq->seq.m; \\\n\t\t\tseq->qual.s = (char*)realloc(seq->qual.s, seq->qual.m); \\\n\t\t} \\\n\t\twhile ((c = ks_getc(ks)) >= 0 && c != '\\n'); /* skip the rest of '+' line */ \\\n\t\tif (c == -1) return -2; /* error: no quality string */ \\\n\t\twhile ((c = ks_getuntil2(ks, KS_SEP_LINE, &seq->qual, 0, 1) >= 0 && seq->qual.l < seq->seq.l)); \\\n\t\tif (c == -3) return -3; /* stream error */ \\\n\t\tseq->last_char = 0;\t/* we have not come to the next header line */ \\\n\t\tif (seq->seq.l != seq->qual.l) return -2; /* error: qual string is of a different length */ \\\n\t\treturn seq->seq.l; \\\n\t}\n\n#define __KSEQ_TYPE(type_t)\t\t\t\t\t\t\\\n\ttypedef struct {\t\t\t\t\t\t\t\\\n\t\tkstring_t name, comment, seq, qual;\t\t\\\n\t\tint last_char;\t\t\t\t\t\t\t\\\n\t\tkstream_t *f;\t\t\t\t\t\t\t\\\n\t} kseq_t;\n\n#define KSEQ_INIT2(SCOPE, type_t, __read)\t\t\\\n\tKSTREAM_INIT(type_t, __read, 16384)\t\t\t\\\n\t__KSEQ_TYPE(type_t)\t\t\t\t\t\t\t\\\n\t__KSEQ_BASIC(SCOPE, type_t)\t\t\t\t\t\\\n\t__KSEQ_READ(SCOPE)\n\n#define KSEQ_INIT(type_t, __read) KSEQ_INIT2(static, type_t, __read)\n\n#define KSEQ_DECLARE(type_t) \\\n\t__KS_TYPE(type_t) \\\n\t__KSEQ_TYPE(type_t) \\\n\textern kseq_t *kseq_init(type_t fd); \\\n\tvoid kseq_destroy(kseq_t *ks); \\\n\tint kseq_read(kseq_t *seq);\n\n#endif\n"
        },
        {
          "name": "kson.c",
          "type": "blob",
          "size": 6.623046875,
          "content": "#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n#include \"kson.h\"\n\n/*************\n *** Parse ***\n *************/\n\nkson_node_t *kson_parse_core(const char *json, long *_n, int *error, long *parsed_len)\n{\n\tlong *stack = 0, top = 0, max = 0, n_a = 0, m_a = 0, i, j;\n\tkson_node_t *a = 0, *u;\n\tconst char *p, *q;\n\tsize_t *tmp;\n\n#define __push_back(y) do { \\\n\t\tif (top == max) { \\\n\t\t\tmax = max? max<<1 : 4; \\\n\t\t\tstack = (long*)realloc(stack, sizeof(long) * max); \\\n\t\t} \\\n\t\tstack[top++] = (y); \\\n\t} while (0)\n\n#define __new_node(z) do { \\\n\t\tif (n_a == m_a) { \\\n\t\t\tlong old_m = m_a; \\\n\t\t\tm_a = m_a? m_a<<1 : 4; \\\n\t\t\ta = (kson_node_t*)realloc(a, sizeof(kson_node_t) * m_a); \\\n\t\t\tmemset(a + old_m, 0, sizeof(kson_node_t) * (m_a - old_m)); \\\n\t\t} \\\n\t\t*(z) = &a[n_a++]; \\\n\t} while (0)\n\n\tassert(sizeof(size_t) == sizeof(kson_node_t*));\n\t*error = KSON_OK;\n\tfor (p = json; *p; ++p) {\n\t\twhile (*p && isspace(*p)) ++p;\n\t\tif (*p == 0) break;\n\t\tif (*p == ',') { // comma is somewhat redundant\n\t\t} else if (*p == '[' || *p == '{') {\n\t\t\tint t = *p == '['? -1 : -2;\n\t\t\tif (top < 2 || stack[top-1] != -3) { // unnamed internal node\n\t\t\t\t__push_back(n_a);\n\t\t\t\t__new_node(&u);\n\t\t\t\t__push_back(t);\n\t\t\t} else stack[top-1] = t; // named internal node\n\t\t} else if (*p == ']' || *p == '}') {\n\t\t\tlong i, start, t = *p == ']'? -1 : -2;\n\t\t\tfor (i = top - 1; i >= 0 && stack[i] != t; --i);\n\t\t\tif (i < 0) { // error: an extra right bracket\n\t\t\t\t*error = KSON_ERR_EXTRA_RIGHT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = i;\n\t\t\tu = &a[stack[start-1]];\n\t\t\tu->key = u->v.str;\n\t\t\tu->n = top - 1 - start;\n\t\t\tu->v.child = (kson_node_t**)malloc(u->n * sizeof(kson_node_t*));\n\t\t\ttmp = (size_t*)u->v.child;\n\t\t\tfor (i = start + 1; i < top; ++i)\n\t\t\t\ttmp[i - start - 1] = stack[i];\n\t\t\tu->type = *p == ']'? KSON_TYPE_BRACKET : KSON_TYPE_BRACE;\n\t\t\tif ((top = start) == 1) break; // completed one object; remaining characters discarded\n\t\t} else if (*p == ':') {\n\t\t\tif (top == 0 || stack[top-1] == -3) {\n\t\t\t\t*error = KSON_ERR_NO_KEY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__push_back(-3);\n\t\t} else {\n\t\t\tint c = *p;\n\t\t\t// get the node to modify\n\t\t\tif (top >= 2 && stack[top-1] == -3) { // we have a key:value pair here\n\t\t\t\t--top;\n\t\t\t\tu = &a[stack[top-1]];\n\t\t\t\tu->key = u->v.str; // move old value to key\n\t\t\t} else { // don't know if this is a bare value or a key:value pair; keep it as a value for now\n\t\t\t\t__push_back(n_a);\n\t\t\t\t__new_node(&u);\n\t\t\t}\n\t\t\t// parse string\n\t\t\tif (c == '\\'' || c == '\"') {\n\t\t\t\tfor (q = ++p; *q && *q != c; ++q)\n\t\t\t\t\tif (*q == '\\\\') ++q;\n\t\t\t} else {\n\t\t\t\tfor (q = p; *q && *q != ']' && *q != '}' && *q != ',' && *q != ':' && *q != '\\n'; ++q)\n\t\t\t\t\tif (*q == '\\\\') ++q;\n\t\t\t}\n\t\t\tu->v.str = (char*)malloc(q - p + 1); strncpy(u->v.str, p, q - p); u->v.str[q-p] = 0; // equivalent to u->v.str=strndup(p, q-p)\n\t\t\tu->type = c == '\\''? KSON_TYPE_SGL_QUOTE : c == '\"'? KSON_TYPE_DBL_QUOTE : KSON_TYPE_NO_QUOTE;\n\t\t\tp = c == '\\'' || c == '\"'? q : q - 1;\n\t\t}\n\t}\n\twhile (*p && isspace(*p)) ++p; // skip trailing blanks\n\tif (parsed_len) *parsed_len = p - json;\n\tif (top != 1) *error = KSON_ERR_EXTRA_LEFT;\n\n\tfor (i = 0; i < n_a; ++i)\n\t\tfor (j = 0, u = &a[i], tmp = (size_t*)u->v.child; j < (long)u->n; ++j)\n\t\t\tu->v.child[j] = &a[tmp[j]];\n\n\tfree(stack);\n\t*_n = n_a;\n\treturn a;\n}\n\nvoid kson_destroy(kson_t *kson)\n{\n\tlong i;\n\tif (kson == 0) return;\n\tfor (i = 0; i < kson->n_nodes; ++i) {\n\t\tfree(kson->root[i].key); free(kson->root[i].v.str);\n\t}\n\tfree(kson->root); free(kson);\n}\n\nkson_t *kson_parse(const char *json)\n{\n\tkson_t *kson;\n\tint error;\n\tkson = (kson_t*)calloc(1, sizeof(kson_t));\n\tkson->root = kson_parse_core(json, &kson->n_nodes, &error, 0);\n\tif (error) {\n\t\tkson_destroy(kson);\n\t\treturn 0;\n\t}\n\treturn kson;\n}\n\n/*************\n *** Query ***\n *************/\n\nconst kson_node_t *kson_by_path(const kson_node_t *p, int depth, ...)\n{\n\tva_list ap;\n\tva_start(ap, depth);\n\twhile (p && depth > 0) {\n\t\tif (p->type == KSON_TYPE_BRACE) {\n\t\t\tp = kson_by_key(p, va_arg(ap, const char*));\n\t\t} else if (p->type == KSON_TYPE_BRACKET) {\n\t\t\tp = kson_by_index(p, va_arg(ap, long));\n\t\t} else break;\n\t\t--depth;\n\t}\n\tva_end(ap);\n\treturn p;\n}\n\n/**************\n *** Fromat ***\n **************/\n\nvoid kson_format_recur(const kson_node_t *p, int depth)\n{\n\tlong i;\n\tif (p->key) printf(\"\\\"%s\\\":\", p->key);\n\tif (p->type == KSON_TYPE_BRACKET || p->type == KSON_TYPE_BRACE) {\n\t\tputchar(p->type == KSON_TYPE_BRACKET? '[' : '{');\n\t\tif (p->n) {\n\t\t\tputchar('\\n'); for (i = 0; i <= depth; ++i) fputs(\"  \", stdout);\n\t\t\tfor (i = 0; i < (long)p->n; ++i) {\n\t\t\t\tif (i) {\n\t\t\t\t\tint i;\n\t\t\t\t\tputchar(',');\n\t\t\t\t\tputchar('\\n'); for (i = 0; i <= depth; ++i) fputs(\"  \", stdout);\n\t\t\t\t}\n\t\t\t\tkson_format_recur(p->v.child[i], depth + 1);\n\t\t\t}\n\t\t\tputchar('\\n'); for (i = 0; i < depth; ++i) fputs(\"  \", stdout);\n\t\t}\n\t\tputchar(p->type == KSON_TYPE_BRACKET? ']' : '}');\n\t} else {\n\t\tif (p->type != KSON_TYPE_NO_QUOTE)\n\t\t\tputchar(p->type == KSON_TYPE_SGL_QUOTE? '\\'' : '\"');\n\t\tfputs(p->v.str, stdout);\n\t\tif (p->type != KSON_TYPE_NO_QUOTE)\n\t\t\tputchar(p->type == KSON_TYPE_SGL_QUOTE? '\\'' : '\"');\n\t}\n}\n\nvoid kson_format(const kson_node_t *root)\n{\n\tkson_format_recur(root, 0);\n\tputchar('\\n');\n}\n\n/*********************\n *** Main function ***\n *********************/\n\n#ifdef KSON_MAIN\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\nint main(int argc, char *argv[])\n{\n\tkson_t *kson = 0;\n\tif (argc > 1) {\n\t\tFILE *fp;\n\t\tint len = 0, max = 0, tmp, i;\n\t\tchar *json = 0, buf[0x10000];\n\t\tif ((fp = fopen(argv[1], \"rb\")) != 0) {\n\t\t\t// read the entire file into a string\n\t\t\twhile ((tmp = fread(buf, 1, 0x10000, fp)) != 0) {\n\t\t\t\tif (len + tmp + 1 > max) {\n\t\t\t\t\tmax = len + tmp + 1;\n\t\t\t\t\tkroundup32(max);\n\t\t\t\t\tjson = (char*)realloc(json, max);\n\t\t\t\t}\n\t\t\t\tmemcpy(json + len, buf, tmp);\n\t\t\t\tlen += tmp;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\t// parse\n\t\t\tkson = kson_parse(json);\n\t\t\tfree(json);\n\t\t\tif (kson) {\n\t\t\t\tkson_format(kson->root);\n\t\t\t\tif (argc > 2) {\n\t\t\t\t\t// path finding\n\t\t\t\t\tconst kson_node_t *p = kson->root;\n\t\t\t\t\tfor (i = 2; i < argc && p; ++i) {\n\t\t\t\t\t\tif (p->type == KSON_TYPE_BRACKET)\n\t\t\t\t\t\t\tp = kson_by_index(p, atoi(argv[i]));\n\t\t\t\t\t\telse if (p->type == KSON_TYPE_BRACE)\n\t\t\t\t\t\t\tp = kson_by_key(p, argv[i]);\n\t\t\t\t\t\telse p = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tif (kson_is_internal(p)) printf(\"Reached an internal node\\n\");\n\t\t\t\t\t\telse printf(\"Value: %s\\n\", p->v.str);\n\t\t\t\t\t} else printf(\"Failed to find the slot\\n\");\n\t\t\t\t}\n\t\t\t} else printf(\"Failed to parse\\n\");\n\t\t}\n\t} else {\n\t\tkson = kson_parse(\"{'a' : 1,'b':[0,'isn\\\\'t',true],'d':[{\\n\\n\\n}]}\");\n\t\tif (kson) {\n\t\t\tconst kson_node_t *p = kson_by_path(kson->root, 2, \"b\", 1);\n\t\t\tif (p) printf(\"*** %s\\n\", p->v.str);\n\t\t\telse printf(\"!!! not found\\n\");\n\t\t\tkson_format(kson->root);\n\t\t} else {\n\t\t\tprintf(\"Failed to parse\\n\");\n\t\t}\n\t}\n\tkson_destroy(kson);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kson.h",
          "type": "blob",
          "size": 1.326171875,
          "content": "#ifndef KSON_H\n#define KSON_H\n\n#include <string.h>\n\n#define KSON_TYPE_NO_QUOTE  1\n#define KSON_TYPE_SGL_QUOTE 2\n#define KSON_TYPE_DBL_QUOTE 3\n#define KSON_TYPE_BRACKET   4\n#define KSON_TYPE_BRACE     5\n\n#define KSON_OK              0\n#define KSON_ERR_EXTRA_LEFT  1\n#define KSON_ERR_EXTRA_RIGHT 2\n#define KSON_ERR_NO_KEY      3\n\ntypedef struct kson_node_s {\n\tunsigned long long type:3, n:61;\n\tchar *key;\n\tunion {\n\t\tstruct kson_node_s **child;\n\t\tchar *str;\n\t} v;\n} kson_node_t;\n\ntypedef struct {\n\tlong n_nodes;\n\tkson_node_t *root;\n} kson_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tkson_t *kson_parse(const char *json);\n\tvoid kson_destroy(kson_t *kson);\n\tconst kson_node_t *kson_by_path(const kson_node_t *root, int path_len, ...);\n\tvoid kson_format(const kson_node_t *root);\n\n#ifdef __cplusplus\n}\n#endif\n\n#define kson_is_internal(p) ((p)->type == KSON_TYPE_BRACKET || (p)->type == KSON_TYPE_BRACE)\n\nstatic inline const kson_node_t *kson_by_key(const kson_node_t *p, const char *key)\n{\n\tlong i;\n\tif (!kson_is_internal(p)) return 0;\n\tfor (i = 0; i < (long)p->n; ++i) {\n\t\tconst kson_node_t *q = p->v.child[i];\n\t\tif (q->key && strcmp(q->key, key) == 0)\n\t\t\treturn q;\n\t}\n\treturn 0;\n}\n\nstatic inline const kson_node_t *kson_by_index(const kson_node_t *p, long i)\n{\n\tif (!kson_is_internal(p)) return 0;\n\treturn 0 <= i && i < (long)p->n? p->v.child[i] : 0;\n}\n\n#endif\n"
        },
        {
          "name": "ksort.h",
          "type": "blob",
          "size": 11.9873046875,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2011 Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  2011-04-10 (0.1.6):\n\n  \t* Added sample\n\n  2011-03 (0.1.5):\n\n\t* Added shuffle/permutation\n\n  2008-11-16 (0.1.4):\n\n    * Fixed a bug in introsort() that happens in rare cases.\n\n  2008-11-05 (0.1.3):\n\n    * Fixed a bug in introsort() for complex comparisons.\n\n\t* Fixed a bug in mergesort(). The previous version is not stable.\n\n  2008-09-15 (0.1.2):\n\n\t* Accelerated introsort. On my Mac (not on another Linux machine),\n\t  my implementation is as fast as std::sort on random input.\n\n\t* Added combsort and in introsort, switch to combsort if the\n\t  recursion is too deep.\n\n  2008-09-13 (0.1.1):\n\n\t* Added k-small algorithm\n\n  2008-09-05 (0.1.0):\n\n\t* Initial version\n\n*/\n\n#ifndef AC_KSORT_H\n#define AC_KSORT_H\n\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tvoid *left, *right;\n\tint depth;\n} ks_isort_stack_t;\n\n#define KSORT_SWAP(type_t, a, b) { register type_t t=(a); (a)=(b); (b)=t; }\n\n#define KSORT_INIT(name, type_t, __sort_lt)\t\t\t\t\t\t\t\t\\\n\tvoid ks_mergesort_##name(size_t n, type_t array[], type_t temp[])\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *a2[2], *a, *b;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint curr, shift;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ta2[0] = array;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ta2[1] = temp? temp : (type_t*)malloc(sizeof(type_t) * n);\t\t\\\n\t\tfor (curr = 0, shift = 0; (1ul<<shift) < n; ++shift) {\t\t\t\\\n\t\t\ta = a2[curr]; b = a2[1-curr];\t\t\t\t\t\t\t\t\\\n\t\t\tif (shift == 0) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\ttype_t *p = b, *i, *eb = a + n;\t\t\t\t\t\t\t\\\n\t\t\t\tfor (i = a; i < eb; i += 2) {\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (i == eb - 1) *p++ = *i;\t\t\t\t\t\t\t\\\n\t\t\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tif (__sort_lt(*(i+1), *i)) {\t\t\t\t\t\\\n\t\t\t\t\t\t\t*p++ = *(i+1); *p++ = *i;\t\t\t\t\t\\\n\t\t\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t*p++ = *i; *p++ = *(i+1);\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tsize_t i, step = 1ul<<shift;\t\t\t\t\t\t\t\\\n\t\t\t\tfor (i = 0; i < n; i += step<<1) {\t\t\t\t\t\t\\\n\t\t\t\t\ttype_t *p, *j, *k, *ea, *eb;\t\t\t\t\t\t\\\n\t\t\t\t\tif (n < i + step) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tea = a + n; eb = a;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tea = a + i + step;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\teb = a + (n < i + (step<<1)? n : i + (step<<1)); \\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tj = a + i; k = a + i + step; p = b + i;\t\t\t\t\\\n\t\t\t\t\twhile (j < ea && k < eb) {\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tif (__sort_lt(*k, *j)) *p++ = *k++;\t\t\t\t\\\n\t\t\t\t\t\telse *p++ = *j++;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\twhile (j < ea) *p++ = *j++;\t\t\t\t\t\t\t\\\n\t\t\t\t\twhile (k < eb) *p++ = *k++;\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tcurr = 1 - curr;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (curr == 1) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttype_t *p = a2[0], *i = a2[1], *eb = array + n;\t\t\t\t\\\n\t\t\tfor (; p < eb; ++i) *p++ = *i;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (temp == 0) free(a2[1]);\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_heapadjust_##name(size_t i, size_t n, type_t l[])\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t k = i;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t tmp = l[i];\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\twhile ((k = (k << 1) + 1) < n) {\t\t\t\t\t\t\t\t\\\n\t\t\tif (k != n - 1 && __sort_lt(l[k], l[k+1])) ++k;\t\t\t\t\\\n\t\t\tif (__sort_lt(l[k], tmp)) break;\t\t\t\t\t\t\t\\\n\t\t\tl[i] = l[k]; i = k;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tl[i] = tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_heapmake_##name(size_t lsize, type_t l[])\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = (lsize >> 1) - 1; i != (size_t)(-1); --i)\t\t\t\t\\\n\t\t\tks_heapadjust_##name(i, lsize, l);\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_heapsort_##name(size_t lsize, type_t l[])\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = lsize - 1; i > 0; --i) {\t\t\t\t\t\t\t\t\\\n\t\t\ttype_t tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttmp = *l; *l = l[i]; l[i] = tmp; ks_heapadjust_##name(0, i, l); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstatic inline void __ks_insertsort_##name(type_t *s, type_t *t)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *i, *j, swap_tmp;\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = s + 1; i < t; ++i)\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (j = i; j > s && __sort_lt(*j, *(j-1)); --j) {\t\t\t\\\n\t\t\t\tswap_tmp = *j; *j = *(j-1); *(j-1) = swap_tmp;\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_combsort_##name(size_t n, type_t a[])\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tconst double shrink_factor = 1.2473309501039786540366528676643; \\\n\t\tint do_swap;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tsize_t gap = n;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t tmp, *i, *j;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (gap > 2) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tgap = (size_t)(gap / shrink_factor);\t\t\t\t\t\\\n\t\t\t\tif (gap == 9 || gap == 10) gap = 11;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tdo_swap = 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (i = a; i < a + n - gap; ++i) {\t\t\t\t\t\t\t\\\n\t\t\t\tj = i + gap;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*j, *i)) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\ttmp = *i; *i = *j; *j = tmp;\t\t\t\t\t\t\\\n\t\t\t\t\tdo_swap = 1;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while (do_swap || gap > 2);\t\t\t\t\t\t\t\t\t\\\n\t\tif (gap != 1) __ks_insertsort_##name(a, a + n);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_introsort_##name(size_t n, type_t a[])\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tks_isort_stack_t *top, *stack;\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t rp, swap_tmp;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *s, *t, *i, *j, *k;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (n < 1) return;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\telse if (n == 2) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (__sort_lt(a[1], a[0])) { swap_tmp = a[0]; a[0] = a[1]; a[1] = swap_tmp; } \\\n\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (d = 2; 1ul<<d < n; ++d);\t\t\t\t\t\t\t\t\t\\\n\t\tstack = (ks_isort_stack_t*)malloc(sizeof(ks_isort_stack_t) * ((sizeof(size_t)*d)+2)); \\\n\t\ttop = stack; s = a; t = a + (n-1); d <<= 1;\t\t\t\t\t\t\\\n\t\twhile (1) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (s < t) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (--d == 0) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tks_combsort_##name(t - s + 1, s);\t\t\t\t\t\\\n\t\t\t\t\tt = s;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\ti = s; j = t; k = i + ((j-i)>>1) + 1;\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*k, *i)) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__sort_lt(*k, *j)) k = j;\t\t\t\t\t\t\\\n\t\t\t\t} else k = __sort_lt(*j, *i)? i : j;\t\t\t\t\t\\\n\t\t\t\trp = *k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (k != t) { swap_tmp = *k; *k = *t; *t = swap_tmp; }\t\\\n\t\t\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tdo ++i; while (__sort_lt(*i, rp));\t\t\t\t\t\\\n\t\t\t\t\tdo --j; while (i <= j && __sort_lt(rp, *j));\t\t\\\n\t\t\t\t\tif (j <= i) break;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tswap_tmp = *i; *i = *j; *j = swap_tmp;\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tswap_tmp = *i; *i = *t; *t = swap_tmp;\t\t\t\t\t\\\n\t\t\t\tif (i-s > t-i) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (i-s > 16) { top->left = s; top->right = i-1; top->depth = d; ++top; } \\\n\t\t\t\t\ts = t-i > 16? i+1 : t;\t\t\t\t\t\t\t\t\\\n\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (t-i > 16) { top->left = i+1; top->right = t; top->depth = d; ++top; } \\\n\t\t\t\t\tt = i-s > 16? i-1 : s;\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (top == stack) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tfree(stack);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t__ks_insertsort_##name(a, a+n);\t\t\t\t\t\t\\\n\t\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t} else { --top; s = (type_t*)top->left; t = (type_t*)top->right; d = top->depth; } \\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t/* This function is adapted from: http://ndevilla.free.fr/median/ */ \\\n\t/* 0 <= kk < n */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\ttype_t ks_ksmall_##name(size_t n, type_t arr[], size_t kk)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ttype_t *low, *high, *k, *ll, *hh, *mid;\t\t\t\t\t\t\t\\\n\t\tlow = arr; high = arr + n - 1; k = arr + kk;\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (high <= low) return *k;\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (high == low + 1) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \\\n\t\t\t\treturn *k;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmid = low + (high - low) / 2;\t\t\t\t\t\t\t\t\\\n\t\t\tif (__sort_lt(*high, *mid)) KSORT_SWAP(type_t, *mid, *high); \\\n\t\t\tif (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \\\n\t\t\tif (__sort_lt(*low, *mid)) KSORT_SWAP(type_t, *mid, *low);\t\\\n\t\t\tKSORT_SWAP(type_t, *mid, *(low+1));\t\t\t\t\t\t\t\\\n\t\t\tll = low + 1; hh = high;\t\t\t\t\t\t\t\t\t\\\n\t\t\tfor (;;) {\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tdo ++ll; while (__sort_lt(*ll, *low));\t\t\t\t\t\\\n\t\t\t\tdo --hh; while (__sort_lt(*low, *hh));\t\t\t\t\t\\\n\t\t\t\tif (hh < ll) break;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tKSORT_SWAP(type_t, *ll, *hh);\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tKSORT_SWAP(type_t, *low, *hh);\t\t\t\t\t\t\t\t\\\n\t\t\tif (hh <= k) low = ll;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (hh >= k) high = hh - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_shuffle_##name(size_t n, type_t a[])\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tint i, j;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = n; i > 1; --i) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ttype_t tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tj = (int)(drand48() * i);\t\t\t\t\t\t\t\t\t\\\n\t\t\ttmp = a[j]; a[j] = a[i-1]; a[i-1] = tmp;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid ks_sample_##name(size_t n, size_t r, type_t a[]) /* FIXME: NOT TESTED!!! */ \\\n\t{ /* reference: http://code.activestate.com/recipes/272884/ */ \\\n\t\tint i, k, pop = n; \\\n\t\tfor (i = (int)r, k = 0; i >= 0; --i) { \\\n\t\t\tdouble z = 1., x = drand48(); \\\n\t\t\ttype_t tmp; \\\n\t\t\twhile (x < z) z -= z * i / (pop--); \\\n\t\t\tif (k != n - pop - 1) tmp = a[k], a[k] = a[n-pop-1], a[n-pop-1] = tmp; \\\n\t\t\t++k; \\\n\t\t} \\\n\t}\n\n#define ks_mergesort(name, n, a, t) ks_mergesort_##name(n, a, t)\n#define ks_introsort(name, n, a) ks_introsort_##name(n, a)\n#define ks_combsort(name, n, a) ks_combsort_##name(n, a)\n#define ks_heapsort(name, n, a) ks_heapsort_##name(n, a)\n#define ks_heapmake(name, n, a) ks_heapmake_##name(n, a)\n#define ks_heapadjust(name, i, n, a) ks_heapadjust_##name(i, n, a)\n#define ks_ksmall(name, n, a, k) ks_ksmall_##name(n, a, k)\n#define ks_shuffle(name, n, a) ks_shuffle_##name(n, a)\n\n#define ks_lt_generic(a, b) ((a) < (b))\n#define ks_lt_str(a, b) (strcmp((a), (b)) < 0)\n\ntypedef const char *ksstr_t;\n\n#define KSORT_INIT_GENERIC(type_t) KSORT_INIT(type_t, type_t, ks_lt_generic)\n#define KSORT_INIT_STR KSORT_INIT(str, ksstr_t, ks_lt_str)\n\n#define RS_MIN_SIZE 64\n#define RS_MAX_BITS 8\n\n#define KRADIX_SORT_INIT(name, rstype_t, rskey, sizeof_key) \\\n\ttypedef struct { \\\n\t\trstype_t *b, *e; \\\n\t} rsbucket_##name##_t; \\\n\tvoid rs_insertsort_##name(rstype_t *beg, rstype_t *end) \\\n\t{ \\\n\t\trstype_t *i; \\\n\t\tfor (i = beg + 1; i < end; ++i) \\\n\t\t\tif (rskey(*i) < rskey(*(i - 1))) { \\\n\t\t\t\trstype_t *j, tmp = *i; \\\n\t\t\t\tfor (j = i; j > beg && rskey(tmp) < rskey(*(j-1)); --j) \\\n\t\t\t\t\t*j = *(j - 1); \\\n\t\t\t\t*j = tmp; \\\n\t\t\t} \\\n\t} \\\n\tvoid rs_sort_##name(rstype_t *beg, rstype_t *end, int n_bits, int s) \\\n\t{ \\\n\t\trstype_t *i; \\\n\t\tint size = 1<<n_bits, m = size - 1; \\\n\t\trsbucket_##name##_t *k, b[1<<RS_MAX_BITS], *be = b + size; \\\n\t\tassert(n_bits <= RS_MAX_BITS); \\\n\t\tfor (k = b; k != be; ++k) k->b = k->e = beg; \\\n\t\tfor (i = beg; i != end; ++i) ++b[rskey(*i)>>s&m].e; \\\n\t\tfor (k = b + 1; k != be; ++k) \\\n\t\t\tk->e += (k-1)->e - beg, k->b = (k-1)->e; \\\n\t\tfor (k = b; k != be;) { \\\n\t\t\tif (k->b != k->e) { \\\n\t\t\t\trsbucket_##name##_t *l; \\\n\t\t\t\tif ((l = b + (rskey(*k->b)>>s&m)) != k) { \\\n\t\t\t\t\trstype_t tmp = *k->b, swap; \\\n\t\t\t\t\tdo { \\\n\t\t\t\t\t\tswap = tmp; tmp = *l->b; *l->b++ = swap; \\\n\t\t\t\t\t\tl = b + (rskey(tmp)>>s&m); \\\n\t\t\t\t\t} while (l != k); \\\n\t\t\t\t\t*k->b++ = tmp; \\\n\t\t\t\t} else ++k->b; \\\n\t\t\t} else ++k; \\\n\t\t} \\\n\t\tfor (b->b = beg, k = b + 1; k != be; ++k) k->b = (k-1)->e; \\\n\t\tif (s) { \\\n\t\t\ts = s > n_bits? s - n_bits : 0; \\\n\t\t\tfor (k = b; k != be; ++k) \\\n\t\t\t\tif (k->e - k->b > RS_MIN_SIZE) rs_sort_##name(k->b, k->e, n_bits, s); \\\n\t\t\t\telse if (k->e - k->b > 1) rs_insertsort_##name(k->b, k->e); \\\n\t\t} \\\n\t} \\\n\tvoid radix_sort_##name(rstype_t *beg, rstype_t *end) \\\n\t{ \\\n\t\tif (end - beg <= RS_MIN_SIZE) rs_insertsort_##name(beg, end); \\\n\t\telse rs_sort_##name(beg, end, RS_MAX_BITS, (sizeof_key - 1) * RS_MAX_BITS); \\\n\t}\n\n#endif\n"
        },
        {
          "name": "kstring.c",
          "type": "blob",
          "size": 6.0400390625,
          "content": "#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdint.h>\n#include \"kstring.h\"\n\nint kvsprintf(kstring_t *s, const char *fmt, va_list ap)\n{\n\tva_list args;\n\tint l;\n\tva_copy(args, ap);\n\tl = vsnprintf(s->s + s->l, s->m - s->l, fmt, args); // This line does not work with glibc 2.0. See `man snprintf'.\n\tva_end(args);\n\tif (l + 1 > s->m - s->l) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t\tva_copy(args, ap);\n\t\tl = vsnprintf(s->s + s->l, s->m - s->l, fmt, args);\n\t\tva_end(args);\n\t}\n\ts->l += l;\n\treturn l;\n}\n\nint ksprintf(kstring_t *s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint l;\n\tva_start(ap, fmt);\n\tl = kvsprintf(s, fmt, ap);\n\tva_end(ap);\n\treturn l;\n}\n\nchar *kstrtok(const char *str, const char *sep_in, ks_tokaux_t *aux)\n{\n\tconst unsigned char *p, *start, *sep = (unsigned char *) sep_in;\n\tif (sep) { // set up the table\n\t\tif (str == 0 && aux->finished) return 0; // no need to set up if we have finished\n\t\taux->finished = 0;\n\t\tif (sep[0] && sep[1]) {\n\t\t\taux->sep = -1;\n\t\t\taux->tab[0] = aux->tab[1] = aux->tab[2] = aux->tab[3] = 0;\n\t\t\tfor (p = sep; *p; ++p) aux->tab[*p>>6] |= 1ull<<(*p&0x3f);\n\t\t} else aux->sep = sep[0];\n\t}\n\tif (aux->finished) return 0;\n\telse if (str) start = (unsigned char *) str, aux->finished = 0;\n\telse start = (unsigned char *) aux->p + 1;\n\tif (aux->sep < 0) {\n\t\tfor (p = start; *p; ++p)\n\t\t\tif (aux->tab[*p>>6]>>(*p&0x3f)&1) break;\n\t} else {\n\t\tfor (p = start; *p; ++p)\n\t\t\tif (*p == aux->sep) break;\n\t}\n\taux->p = (const char *) p; // end of token\n\tif (*p == 0) aux->finished = 1; // no more tokens\n\treturn (char*)start;\n}\n\n// s MUST BE a null terminated string; l = strlen(s)\nint ksplit_core(char *s, int delimiter, int *_max, int **_offsets)\n{\n\tint i, n, max, last_char, last_start, *offsets, l;\n\tn = 0; max = *_max; offsets = *_offsets;\n\tl = strlen(s);\n\t\n#define __ksplit_aux do {\t\t\t\t\t\t\\\n\t\tif (_offsets) {\t\t\t\t\t\t\\\n\t\t\ts[i] = 0;\t\t\t\t\t\\\n\t\t\tif (n == max) {\t\t\t\t\t\\\n\t\t\t\tint *tmp;\t\t\t\t\\\n\t\t\t\tmax = max? max<<1 : 2;\t\t\t\\\n\t\t\t\tif ((tmp = (int*)realloc(offsets, sizeof(int) * max))) {  \\\n\t\t\t\t\toffsets = tmp;\t\t\t\\\n\t\t\t\t} else\t{\t\t\t\t\\\n\t\t\t\t\tfree(offsets);\t\t\t\\\n\t\t\t\t\t*_offsets = NULL;\t\t\\\n\t\t\t\t\treturn 0;\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\toffsets[n++] = last_start;\t\t\t\\\n\t\t} else ++n;\t\t\t\t\t\t\\\n\t} while (0)\n\n\tfor (i = 0, last_char = last_start = 0; i <= l; ++i) {\n\t\tif (delimiter == 0) {\n\t\t\tif (isspace(s[i]) || s[i] == 0) {\n\t\t\t\tif (isgraph(last_char)) __ksplit_aux; // the end of a field\n\t\t\t} else {\n\t\t\t\tif (isspace(last_char) || last_char == 0) last_start = i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (s[i] == delimiter || s[i] == 0) {\n\t\t\t\tif (last_char != 0 && last_char != delimiter) __ksplit_aux; // the end of a field\n\t\t\t} else {\n\t\t\t\tif (last_char == delimiter || last_char == 0) last_start = i;\n\t\t\t}\n\t\t}\n\t\tlast_char = s[i];\n\t}\n\t*_max = max; *_offsets = offsets;\n\treturn n;\n}\n\nint kgetline(kstring_t *s, kgets_func *fgets_fn, void *fp)\n{\n\tsize_t l0 = s->l;\n\n\twhile (s->l == l0 || s->s[s->l-1] != '\\n') {\n\t\tif (s->m - s->l < 200) ks_resize(s, s->m + 200);\n\t\tif (fgets_fn(s->s + s->l, s->m - s->l, fp) == NULL) break;\n\t\ts->l += strlen(s->s + s->l);\n\t}\n\n\tif (s->l == l0) return EOF;\n\n\tif (s->l > l0 && s->s[s->l-1] == '\\n') {\n\t\ts->l--;\n\t\tif (s->l > l0 && s->s[s->l-1] == '\\r') s->l--;\n\t}\n\ts->s[s->l] = '\\0';\n\treturn 0;\n}\n\n/**********************\n * Boyer-Moore search *\n **********************/\n\ntypedef unsigned char ubyte_t;\n\n// reference: http://www-igm.univ-mlv.fr/~lecroq/string/node14.html\nstatic int *ksBM_prep(const ubyte_t *pat, int m)\n{\n\tint i, *suff, *prep, *bmGs, *bmBc;\n\tprep = (int*)calloc(m + 256, sizeof(int));\n\tbmGs = prep; bmBc = prep + m;\n\t{ // preBmBc()\n\t\tfor (i = 0; i < 256; ++i) bmBc[i] = m;\n\t\tfor (i = 0; i < m - 1; ++i) bmBc[pat[i]] = m - i - 1;\n\t}\n\tsuff = (int*)calloc(m, sizeof(int));\n\t{ // suffixes()\n\t\tint f = 0, g;\n\t\tsuff[m - 1] = m;\n\t\tg = m - 1;\n\t\tfor (i = m - 2; i >= 0; --i) {\n\t\t\tif (i > g && suff[i + m - 1 - f] < i - g)\n\t\t\t\tsuff[i] = suff[i + m - 1 - f];\n\t\t\telse {\n\t\t\t\tif (i < g) g = i;\n\t\t\t\tf = i;\n\t\t\t\twhile (g >= 0 && pat[g] == pat[g + m - 1 - f]) --g;\n\t\t\t\tsuff[i] = f - g;\n\t\t\t}\n\t\t}\n\t}\n\t{ // preBmGs()\n\t\tint j = 0;\n\t\tfor (i = 0; i < m; ++i) bmGs[i] = m;\n\t\tfor (i = m - 1; i >= 0; --i)\n\t\t\tif (suff[i] == i + 1)\n\t\t\t\tfor (; j < m - 1 - i; ++j)\n\t\t\t\t\tif (bmGs[j] == m)\n\t\t\t\t\t\tbmGs[j] = m - 1 - i;\n\t\tfor (i = 0; i <= m - 2; ++i)\n\t\t\tbmGs[m - 1 - suff[i]] = m - 1 - i;\n\t}\n\tfree(suff);\n\treturn prep;\n}\n\nvoid *kmemmem(const void *_str, int n, const void *_pat, int m, int **_prep)\n{\n\tint i, j, *prep = 0, *bmGs, *bmBc;\n\tconst ubyte_t *str, *pat;\n\tstr = (const ubyte_t*)_str; pat = (const ubyte_t*)_pat;\n\tprep = (_prep == 0 || *_prep == 0)? ksBM_prep(pat, m) : *_prep;\n\tif (_prep && *_prep == 0) *_prep = prep;\n\tbmGs = prep; bmBc = prep + m;\n\tj = 0;\n\twhile (j <= n - m) {\n\t\tfor (i = m - 1; i >= 0 && pat[i] == str[i+j]; --i);\n\t\tif (i >= 0) {\n\t\t\tint max = bmBc[str[i+j]] - m + 1 + i;\n\t\t\tif (max < bmGs[i]) max = bmGs[i];\n\t\t\tj += max;\n\t\t} else return (void*)(str + j);\n\t}\n\tif (_prep == 0) free(prep);\n\treturn 0;\n}\n\nchar *kstrstr(const char *str, const char *pat, int **_prep)\n{\n\treturn (char*)kmemmem(str, strlen(str), pat, strlen(pat), _prep);\n}\n\nchar *kstrnstr(const char *str, const char *pat, int n, int **_prep)\n{\n\treturn (char*)kmemmem(str, n, pat, strlen(pat), _prep);\n}\n\n/***********************\n * The main() function *\n ***********************/\n\n#ifdef KSTRING_MAIN\n#include <stdio.h>\nint main()\n{\n\tkstring_t *s;\n\tint *fields, n, i;\n\tks_tokaux_t aux;\n\tchar *p;\n\ts = (kstring_t*)calloc(1, sizeof(kstring_t));\n\t// test ksprintf()\n\tksprintf(s, \" abcdefg:    %d \", 100);\n\tprintf(\"'%s'\\n\", s->s);\n\t// test ksplit()\n\tfields = ksplit(s, 0, &n);\n\tfor (i = 0; i < n; ++i)\n\t\tprintf(\"field[%d] = '%s'\\n\", i, s->s + fields[i]);\n\t// test kstrtok()\n\ts->l = 0;\n\tfor (p = kstrtok(\"ab:cde:fg/hij::k\", \":/\", &aux); p; p = kstrtok(0, 0, &aux)) {\n\t\tkputsn(p, aux.p - p, s);\n\t\tkputc('\\n', s);\n\t}\n\tprintf(\"%s\", s->s);\n\t// free\n\tfree(s->s); free(s); free(fields);\n\n\t{\n\t\tstatic char *str = \"abcdefgcdgcagtcakcdcd\";\n\t\tstatic char *pat = \"cd\";\n\t\tchar *ret, *s = str;\n\t\tint *prep = 0;\n\t\twhile ((ret = kstrstr(s, pat, &prep)) != 0) {\n\t\t\tprintf(\"match: %s\\n\", ret);\n\t\t\ts = ret + prep[0];\n\t\t}\n\t\tfree(prep);\n\t}\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kstring.h",
          "type": "blob",
          "size": 6.8798828125,
          "content": "/* The MIT License\n\n   Copyright (c) by Attractive Chaos <attractor@live.co.uk> \n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#ifndef KSTRING_H\n#define KSTRING_H\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)\n#define KS_ATTR_PRINTF(fmt, arg) __attribute__((__format__ (__printf__, fmt, arg)))\n#else\n#define KS_ATTR_PRINTF(fmt, arg)\n#endif\n\n\n/* kstring_t is a simple non-opaque type whose fields are likely to be\n * used directly by user code (but see also ks_str() and ks_len() below).\n * A kstring_t object is initialised by either of\n *       kstring_t str = { 0, 0, NULL };\n *       kstring_t str; ...; str.l = str.m = 0; str.s = NULL;\n * and either ownership of the underlying buffer should be given away before\n * the object disappears (see ks_release() below) or the kstring_t should be\n * destroyed with  free(str.s);  */\n#ifndef KSTRING_T\n#define KSTRING_T kstring_t\ntypedef struct __kstring_t {\n\tsize_t l, m;\n\tchar *s;\n} kstring_t;\n#endif\n\ntypedef struct {\n\tuint64_t tab[4];\n\tint sep, finished;\n\tconst char *p; // end of the current token\n} ks_tokaux_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\tint kvsprintf(kstring_t *s, const char *fmt, va_list ap) KS_ATTR_PRINTF(2,0);\n\tint ksprintf(kstring_t *s, const char *fmt, ...) KS_ATTR_PRINTF(2,3);\n\tint ksplit_core(char *s, int delimiter, int *_max, int **_offsets);\n\tchar *kstrstr(const char *str, const char *pat, int **_prep);\n\tchar *kstrnstr(const char *str, const char *pat, int n, int **_prep);\n\tvoid *kmemmem(const void *_str, int n, const void *_pat, int m, int **_prep);\n\n\t/* kstrtok() is similar to strtok_r() except that str is not\n\t * modified and both str and sep can be NULL. For efficiency, it is\n\t * actually recommended to set both to NULL in the subsequent calls\n\t * if sep is not changed. */\n\tchar *kstrtok(const char *str, const char *sep, ks_tokaux_t *aux);\n\n\t/* kgetline() uses the supplied fgets()-like function to read a \"\\n\"-\n\t * or \"\\r\\n\"-terminated line from fp.  The line read is appended to the\n\t * kstring without its terminator and 0 is returned; EOF is returned at\n\t * EOF or on error (determined by querying fp, as per fgets()). */\n\ttypedef char *kgets_func(char *, int, void *);\n\tint kgetline(kstring_t *s, kgets_func *fgets, void *fp);\n\n#ifdef __cplusplus\n}\n#endif\n\nstatic inline int ks_resize(kstring_t *s, size_t size)\n{\n\tif (s->m < size) {\n\t\tchar *tmp;\n\t\ts->m = size;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic inline char *ks_str(kstring_t *s)\n{\n\treturn s->s;\n}\n\nstatic inline size_t ks_len(kstring_t *s)\n{\n\treturn s->l;\n}\n\n// Give ownership of the underlying buffer away to something else (making\n// that something else responsible for freeing it), leaving the kstring_t\n// empty and ready to be used again, or ready to go out of scope without\n// needing  free(str.s)  to prevent a memory leak.\nstatic inline char *ks_release(kstring_t *s)\n{\n\tchar *ss = s->s;\n\ts->l = s->m = 0;\n\ts->s = NULL;\n\treturn ss;\n}\n\nstatic inline int kputsn(const char *p, int l, kstring_t *s)\n{\n\tif (s->l + l + 1 >= s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\tmemcpy(s->s + s->l, p, l);\n\ts->l += l;\n\ts->s[s->l] = 0;\n\treturn l;\n}\n\nstatic inline int kputs(const char *p, kstring_t *s)\n{\n\treturn kputsn(p, strlen(p), s);\n}\n\nstatic inline int kputc(int c, kstring_t *s)\n{\n\tif (s->l + 1 >= s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + 2;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\ts->s[s->l++] = c;\n\ts->s[s->l] = 0;\n\treturn c;\n}\n\nstatic inline int kputc_(int c, kstring_t *s)\n{\n\tif (s->l + 1 > s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + 1;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\ts->s[s->l++] = c;\n\treturn 1;\n}\n\nstatic inline int kputsn_(const void *p, int l, kstring_t *s)\n{\n\tif (s->l + l > s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + l;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\tmemcpy(s->s + s->l, p, l);\n\ts->l += l;\n\treturn l;\n}\n\nstatic inline int kputw(int c, kstring_t *s)\n{\n\tchar buf[16];\n\tint i, l = 0;\n\tunsigned int x = c;\n\tif (c < 0) x = -x;\n\tdo { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);\n\tif (c < 0) buf[l++] = '-';\n\tif (s->l + l + 1 >= s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\tfor (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];\n\ts->s[s->l] = 0;\n\treturn 0;\n}\n\nstatic inline int kputuw(unsigned c, kstring_t *s)\n{\n\tchar buf[16];\n\tint l, i;\n\tunsigned x;\n\tif (c == 0) return kputc('0', s);\n\tfor (l = 0, x = c; x > 0; x /= 10) buf[l++] = x%10 + '0';\n\tif (s->l + l + 1 >= s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\tfor (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];\n\ts->s[s->l] = 0;\n\treturn 0;\n}\n\nstatic inline int kputl(long c, kstring_t *s)\n{\n\tchar buf[32];\n\tint i, l = 0;\n\tunsigned long x = c;\n\tif (c < 0) x = -x;\n\tdo { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);\n\tif (c < 0) buf[l++] = '-';\n\tif (s->l + l + 1 >= s->m) {\n\t\tchar *tmp;\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\tif ((tmp = (char*)realloc(s->s, s->m)))\n\t\t\ts->s = tmp;\n\t\telse\n\t\t\treturn EOF;\n\t}\n\tfor (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];\n\ts->s[s->l] = 0;\n\treturn 0;\n}\n\n/*\n * Returns 's' split by delimiter, with *n being the number of components;\n *         NULL on failue.\n */\nstatic inline int *ksplit(kstring_t *s, int delimiter, int *n)\n{\n\tint max = 0, *offsets = 0;\n\t*n = ksplit_core(s->s, delimiter, &max, &offsets);\n\treturn offsets;\n}\n\n#endif\n"
        },
        {
          "name": "ksw.c",
          "type": "blob",
          "size": 21.6904296875,
          "content": "/* The MIT License\n\n   Copyright (c) 2011 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <emmintrin.h>\n#include \"ksw.h\"\n\n#ifdef __GNUC__\n#define LIKELY(x) __builtin_expect((x),1)\n#define UNLIKELY(x) __builtin_expect((x),0)\n#else\n#define LIKELY(x) (x)\n#define UNLIKELY(x) (x)\n#endif\n\nconst kswr_t g_defr = { 0, -1, -1, -1, -1, -1, -1 };\n\nstruct _kswq_t {\n\tint qlen, slen;\n\tuint8_t shift, mdiff, max, size;\n\t__m128i *qp, *H0, *H1, *E, *Hmax;\n};\n\n/**\n * Initialize the query data structure\n *\n * @param size   Number of bytes used to store a score; valid valures are 1 or 2\n * @param qlen   Length of the query sequence\n * @param query  Query sequence\n * @param m      Size of the alphabet\n * @param mat    Scoring matrix in a one-dimension array\n *\n * @return       Query data structure\n */\nkswq_t *ksw_qinit(int size, int qlen, const uint8_t *query, int m, const int8_t *mat)\n{\n\tkswq_t *q;\n\tint slen, a, tmp, p;\n\n\tsize = size > 1? 2 : 1;\n\tp = 8 * (3 - size); // # values per __m128i\n\tslen = (qlen + p - 1) / p; // segmented length\n\tq = (kswq_t*)malloc(sizeof(kswq_t) + 256 + 16 * slen * (m + 4)); // a single block of memory\n\tq->qp = (__m128i*)(((size_t)q + sizeof(kswq_t) + 15) >> 4 << 4); // align memory\n\tq->H0 = q->qp + slen * m;\n\tq->H1 = q->H0 + slen;\n\tq->E  = q->H1 + slen;\n\tq->Hmax = q->E + slen;\n\tq->slen = slen; q->qlen = qlen; q->size = size;\n\t// compute shift\n\ttmp = m * m;\n\tfor (a = 0, q->shift = 127, q->mdiff = 0; a < tmp; ++a) { // find the minimum and maximum score\n\t\tif (mat[a] < (int8_t)q->shift) q->shift = mat[a];\n\t\tif (mat[a] > (int8_t)q->mdiff) q->mdiff = mat[a];\n\t}\n\tq->max = q->mdiff;\n\tq->shift = 256 - q->shift; // NB: q->shift is uint8_t\n\tq->mdiff += q->shift; // this is the difference between the min and max scores\n\t// An example: p=8, qlen=19, slen=3 and segmentation:\n\t//  {{0,3,6,9,12,15,18,-1},{1,4,7,10,13,16,-1,-1},{2,5,8,11,14,17,-1,-1}}\n\tif (size == 1) {\n\t\tint8_t *t = (int8_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]) + q->shift;\n\t\t}\n\t} else {\n\t\tint16_t *t = (int16_t*)q->qp;\n\t\tfor (a = 0; a < m; ++a) {\n\t\t\tint i, k, nlen = slen * p;\n\t\t\tconst int8_t *ma = mat + a * m;\n\t\t\tfor (i = 0; i < slen; ++i)\n\t\t\t\tfor (k = i; k < nlen; k += slen) // p iterations\n\t\t\t\t\t*t++ = (k >= qlen? 0 : ma[query[k]]);\n\t\t}\n\t}\n\treturn q;\n}\n\nkswr_t ksw_u8(kswq_t *q, int tlen, const uint8_t *target, int _gapo, int _gape, int xtra) // the first gap costs -(_o+_e)\n{\n\tint slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;\n\tuint64_t *b;\n\t__m128i zero, gapoe, gape, shift, *H0, *H1, *E, *Hmax;\n\tkswr_t r;\n\n#define __max_16(ret, xx) do { \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 8)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 4)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 2)); \\\n\t\t(xx) = _mm_max_epu8((xx), _mm_srli_si128((xx), 1)); \\\n    \t(ret) = _mm_extract_epi16((xx), 0) & 0x00ff; \\\n\t} while (0)\n\n\t// initialization\n\tr = g_defr;\n\tminsc = (xtra&KSW_XSUBO)? xtra&0xffff : 0x10000;\n\tendsc = (xtra&KSW_XSTOP)? xtra&0xffff : 0x10000;\n\tm_b = n_b = 0; b = 0;\n\tzero = _mm_set1_epi32(0);\n\tgapoe = _mm_set1_epi8(_gapo + _gape);\n\tgape = _mm_set1_epi8(_gape);\n\tshift = _mm_set1_epi8(q->shift);\n\tH0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;\n\tslen = q->slen;\n\tfor (i = 0; i < slen; ++i) {\n\t\t_mm_store_si128(E + i, zero);\n\t\t_mm_store_si128(H0 + i, zero);\n\t\t_mm_store_si128(Hmax + i, zero);\n\t}\n\t// the core loop\n\tfor (i = 0; i < tlen; ++i) {\n\t\tint j, k, cmp, imax;\n\t\t__m128i e, h, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector\n\t\th = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example\n\t\th = _mm_slli_si128(h, 1); // h=H(i-1,-1); << instead of >> because x64 is little-endian\n\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t/* SW cells are computed in the following order:\n\t\t\t *   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}\n\t\t\t *   E(i+1,j) = max{H(i,j)-q, E(i,j)-r}\n\t\t\t *   F(i,j+1) = max{H(i,j)-q, F(i,j)-r}\n\t\t\t */\n\t\t\t// compute H'(i,j); note that at the beginning, h=H'(i-1,j-1)\n\t\t\th = _mm_adds_epu8(h, _mm_load_si128(S + j));\n\t\t\th = _mm_subs_epu8(h, shift); // h=H'(i-1,j-1)+S(i,j)\n\t\t\te = _mm_load_si128(E + j); // e=E'(i,j)\n\t\t\th = _mm_max_epu8(h, e);\n\t\t\th = _mm_max_epu8(h, f); // h=H'(i,j)\n\t\t\tmax = _mm_max_epu8(max, h); // set max\n\t\t\t_mm_store_si128(H1 + j, h); // save to H'(i,j)\n\t\t\t// now compute E'(i+1,j)\n\t\t\th = _mm_subs_epu8(h, gapoe); // h=H'(i,j)-gapo\n\t\t\te = _mm_subs_epu8(e, gape); // e=E'(i,j)-gape\n\t\t\te = _mm_max_epu8(e, h); // e=E'(i+1,j)\n\t\t\t_mm_store_si128(E + j, e); // save to E'(i+1,j)\n\t\t\t// now compute F'(i,j+1)\n\t\t\tf = _mm_subs_epu8(f, gape);\n\t\t\tf = _mm_max_epu8(f, h);\n\t\t\t// get H'(i-1,j) and prepare for the next j\n\t\t\th = _mm_load_si128(H0 + j); // h=H'(i-1,j)\n\t\t}\n\t\t// NB: we do not need to set E(i,j) as we disallow adjecent insertion and then deletion\n\t\tfor (k = 0; LIKELY(k < 16); ++k) { // this block mimics SWPS3; NB: H(i,j) updated in the lazy-F loop cannot exceed max\n\t\t\tf = _mm_slli_si128(f, 1);\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t\th = _mm_load_si128(H1 + j);\n\t\t\t\th = _mm_max_epu8(h, f); // h=H'(i,j)\n\t\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\t\th = _mm_subs_epu8(h, gapoe);\n\t\t\t\tf = _mm_subs_epu8(f, gape);\n\t\t\t\tcmp = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_subs_epu8(f, h), zero));\n\t\t\t\tif (UNLIKELY(cmp == 0xffff)) goto end_loop16;\n\t\t\t}\n\t\t}\nend_loop16:\n\t\t//int k;for (k=0;k<16;++k)printf(\"%d \", ((uint8_t*)&max)[k]);printf(\"\\n\");\n\t\t__max_16(imax, max); // imax is the maximum number in max\n\t\tif (imax >= minsc) { // write the b array; this condition adds branching unfornately\n\t\t\tif (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) { // then append\n\t\t\t\tif (n_b == m_b) {\n\t\t\t\t\tm_b = m_b? m_b<<1 : 8;\n\t\t\t\t\tb = (uint64_t*)realloc(b, 8 * m_b);\n\t\t\t\t}\n\t\t\t\tb[n_b++] = (uint64_t)imax<<32 | i;\n\t\t\t} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last\n\t\t}\n\t\tif (imax > gmax) {\n\t\t\tgmax = imax; te = i; // te is the end position on the target\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) // keep the H1 vector\n\t\t\t\t_mm_store_si128(Hmax + j, _mm_load_si128(H1 + j));\n\t\t\tif (gmax + q->shift >= 255 || gmax >= endsc) break;\n\t\t}\n\t\tS = H1; H1 = H0; H0 = S; // swap H0 and H1\n\t}\n\tr.score = gmax + q->shift < 255? gmax : 255;\n\tr.te = te;\n\tif (r.score != 255) { // get a->qe, the end of query match; find the 2nd best score\n\t\tint max = -1, low, high, qlen = slen * 16;\n\t\tuint8_t *t = (uint8_t*)Hmax;\n\t\tfor (i = 0; i < qlen; ++i, ++t)\n\t\t\tif ((int)*t > max) max = *t, r.qe = i / 16 + i % 16 * slen;\n\t\t//printf(\"%d,%d\\n\", max, gmax);\n\t\tif (b) {\n\t\t\ti = (r.score + q->max - 1) / q->max;\n\t\t\tlow = te - i; high = te + i;\n\t\t\tfor (i = 0; i < n_b; ++i) {\n\t\t\t\tint e = (int32_t)b[i];\n\t\t\t\tif ((e < low || e > high) && (int)(b[i]>>32) > r.score2)\n\t\t\t\t\tr.score2 = b[i]>>32, r.te2 = e;\n\t\t\t}\n\t\t}\n\t}\n\tfree(b);\n\treturn r;\n}\n\nkswr_t ksw_i16(kswq_t *q, int tlen, const uint8_t *target, int _gapo, int _gape, int xtra) // the first gap costs -(_o+_e)\n{\n\tint slen, i, m_b, n_b, te = -1, gmax = 0, minsc, endsc;\n\tuint64_t *b;\n\t__m128i zero, gapoe, gape, *H0, *H1, *E, *Hmax;\n\tkswr_t r;\n\n#define __max_8(ret, xx) do { \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 8)); \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 4)); \\\n\t\t(xx) = _mm_max_epi16((xx), _mm_srli_si128((xx), 2)); \\\n    \t(ret) = _mm_extract_epi16((xx), 0); \\\n\t} while (0)\n\n\t// initialization\n\tr = g_defr;\n\tminsc = (xtra&KSW_XSUBO)? xtra&0xffff : 0x10000;\n\tendsc = (xtra&KSW_XSTOP)? xtra&0xffff : 0x10000;\n\tm_b = n_b = 0; b = 0;\n\tzero = _mm_set1_epi32(0);\n\tgapoe = _mm_set1_epi16(_gapo + _gape);\n\tgape = _mm_set1_epi16(_gape);\n\tH0 = q->H0; H1 = q->H1; E = q->E; Hmax = q->Hmax;\n\tslen = q->slen;\n\tfor (i = 0; i < slen; ++i) {\n\t\t_mm_store_si128(E + i, zero);\n\t\t_mm_store_si128(H0 + i, zero);\n\t\t_mm_store_si128(Hmax + i, zero);\n\t}\n\t// the core loop\n\tfor (i = 0; i < tlen; ++i) {\n\t\tint j, k, imax;\n\t\t__m128i e, h, f = zero, max = zero, *S = q->qp + target[i] * slen; // s is the 1st score vector\n\t\th = _mm_load_si128(H0 + slen - 1); // h={2,5,8,11,14,17,-1,-1} in the above example\n\t\th = _mm_slli_si128(h, 2);\n\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\th = _mm_adds_epi16(h, *S++);\n\t\t\te = _mm_load_si128(E + j);\n\t\t\th = _mm_max_epi16(h, e);\n\t\t\th = _mm_max_epi16(h, f);\n\t\t\tmax = _mm_max_epi16(max, h);\n\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\th = _mm_subs_epu16(h, gapoe);\n\t\t\te = _mm_subs_epu16(e, gape);\n\t\t\te = _mm_max_epi16(e, h);\n\t\t\t_mm_store_si128(E + j, e);\n\t\t\tf = _mm_subs_epu16(f, gape);\n\t\t\tf = _mm_max_epi16(f, h);\n\t\t\th = _mm_load_si128(H0 + j);\n\t\t}\n\t\tfor (k = 0; LIKELY(k < 16); ++k) {\n\t\t\tf = _mm_slli_si128(f, 2);\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j) {\n\t\t\t\th = _mm_load_si128(H1 + j);\n\t\t\t\th = _mm_max_epi16(h, f);\n\t\t\t\t_mm_store_si128(H1 + j, h);\n\t\t\t\th = _mm_subs_epu16(h, gapoe);\n\t\t\t\tf = _mm_subs_epu16(f, gape);\n\t\t\t\tif(UNLIKELY(!_mm_movemask_epi8(_mm_cmpgt_epi16(f, h)))) goto end_loop8;\n\t\t\t}\n\t\t}\nend_loop8:\n\t\t__max_8(imax, max);\n\t\tif (imax >= minsc) {\n\t\t\tif (n_b == 0 || (int32_t)b[n_b-1] + 1 != i) {\n\t\t\t\tif (n_b == m_b) {\n\t\t\t\t\tm_b = m_b? m_b<<1 : 8;\n\t\t\t\t\tb = (uint64_t*)realloc(b, 8 * m_b);\n\t\t\t\t}\n\t\t\t\tb[n_b++] = (uint64_t)imax<<32 | i;\n\t\t\t} else if ((int)(b[n_b-1]>>32) < imax) b[n_b-1] = (uint64_t)imax<<32 | i; // modify the last\n\t\t}\n\t\tif (imax > gmax) {\n\t\t\tgmax = imax; te = i;\n\t\t\tfor (j = 0; LIKELY(j < slen); ++j)\n\t\t\t\t_mm_store_si128(Hmax + j, _mm_load_si128(H1 + j));\n\t\t\tif (gmax >= endsc) break;\n\t\t}\n\t\tS = H1; H1 = H0; H0 = S;\n\t}\n\tr.score = gmax; r.te = te;\n\t{\n\t\tint max = -1, low, high, qlen = slen * 8;\n\t\tuint16_t *t = (uint16_t*)Hmax;\n\t\tfor (i = 0, r.qe = -1; i < qlen; ++i, ++t)\n\t\t\tif ((int)*t > max) max = *t, r.qe = i / 8 + i % 8 * slen;\n\t\tif (b) {\n\t\t\ti = (r.score + q->max - 1) / q->max;\n\t\t\tlow = te - i; high = te + i;\n\t\t\tfor (i = 0; i < n_b; ++i) {\n\t\t\t\tint e = (int32_t)b[i];\n\t\t\t\tif ((e < low || e > high) && (int)(b[i]>>32) > r.score2)\n\t\t\t\t\tr.score2 = b[i]>>32, r.te2 = e;\n\t\t\t}\n\t\t}\n\t}\n\tfree(b);\n\treturn r;\n}\n\nstatic void revseq(int l, uint8_t *s)\n{\n\tint i, t;\n\tfor (i = 0; i < l>>1; ++i)\n\t\tt = s[i], s[i] = s[l - 1 - i], s[l - 1 - i] = t;\n}\n\nkswr_t ksw_align(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int xtra, kswq_t **qry)\n{\n\tint size;\n\tkswq_t *q;\n\tkswr_t r, rr;\n\tkswr_t (*func)(kswq_t*, int, const uint8_t*, int, int, int);\n\n\tq = (qry && *qry)? *qry : ksw_qinit((xtra&KSW_XBYTE)? 1 : 2, qlen, query, m, mat);\n\tif (qry && *qry == 0) *qry = q;\n\tfunc = q->size == 2? ksw_i16 : ksw_u8;\n\tsize = q->size;\n\tr = func(q, tlen, target, gapo, gape, xtra);\n\tif (qry == 0) free(q);\n\tif ((xtra&KSW_XSTART) == 0 || ((xtra&KSW_XSUBO) && r.score < (xtra&0xffff))) return r;\n\trevseq(r.qe + 1, query); revseq(r.te + 1, target); // +1 because qe/te points to the exact end, not the position after the end\n\tq = ksw_qinit(size, r.qe + 1, query, m, mat);\n\trr = func(q, tlen, target, gapo, gape, KSW_XSTOP | r.score);\n\trevseq(r.qe + 1, query); revseq(r.te + 1, target);\n\tfree(q);\n\tif (r.score == rr.score)\n\t\tr.tb = r.te - rr.te, r.qb = r.qe - rr.qe;\n\treturn r;\n}\n\n/********************\n *** SW extension ***\n ********************/\n\ntypedef struct {\n\tint32_t h, e;\n} eh_t;\n\nint ksw_extend(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int h0, int *_qle, int *_tle)\n{\n\teh_t *eh; // score array\n\tint8_t *qp; // query profile\n\tint i, j, k, gapoe = gapo + gape, beg, end, max, max_i, max_j, max_gap;\n\tif (h0 < 0) h0 = 0;\n\t// allocate memory\n\tqp = malloc(qlen * m);\n\teh = calloc(qlen + 1, 8);\n\t// generate the query profile\n\tfor (k = i = 0; k < m; ++k) {\n\t\tconst int8_t *p = &mat[k * m];\n\t\tfor (j = 0; j < qlen; ++j) qp[i++] = p[query[j]];\n\t}\n\t// fill the first row\n\teh[0].h = h0; eh[1].h = h0 > gapoe? h0 - gapoe : 0;\n\tfor (j = 2; j <= qlen && eh[j-1].h > gape; ++j)\n\t\teh[j].h = eh[j-1].h - gape;\n\t// adjust $w if it is too large\n\tk = m * m;\n\tfor (i = 0, max = 0; i < k; ++i) // get the max score\n\t\tmax = max > mat[i]? max : mat[i];\n\tmax_gap = (int)((double)(qlen * max - gapo) / gape + 1.);\n\tmax_gap = max_gap > 1? max_gap : 1;\n\tw = w < max_gap? w : max_gap;\n\t// DP loop\n\tmax = h0, max_i = max_j = -1;\n\tbeg = 0, end = qlen;\n\tfor (i = 0; LIKELY(i < tlen); ++i) {\n\t\tint f = 0, h1, m = 0, mj = -1;\n\t\tint8_t *q = &qp[target[i] * qlen];\n\t\t// compute the first column\n\t\th1 = h0 - (gapo + gape * (i + 1));\n\t\tif (h1 < 0) h1 = 0;\n\t\t// apply the band and the constraint (if provided)\n\t\tif (beg < i - w) beg = i - w;\n\t\tif (end > i + w + 1) end = i + w + 1;\n\t\tif (end > qlen) end = qlen;\n\t\tfor (j = beg; LIKELY(j < end); ++j) {\n\t\t\t// At the beginning of the loop: eh[j] = { H(i-1,j-1), E(i,j) }, f = F(i,j) and h1 = H(i,j-1)\n\t\t\t// Similar to SSE2-SW, cells are computed in the following order:\n\t\t\t//   H(i,j)   = max{H(i-1,j-1)+S(i,j), E(i,j), F(i,j)}\n\t\t\t//   E(i+1,j) = max{H(i,j)-gapo, E(i,j)} - gape\n\t\t\t//   F(i,j+1) = max{H(i,j)-gapo, F(i,j)} - gape\n\t\t\teh_t *p = &eh[j];\n\t\t\tint h = p->h, e = p->e; // get H(i-1,j-1) and E(i-1,j)\n\t\t\tp->h = h1;          // set H(i,j-1) for the next row\n\t\t\th += q[j];\n\t\t\th = h > e? h : e;\n\t\t\th = h > f? h : f;\n\t\t\th1 = h;             // save H(i,j) to h1 for the next column\n\t\t\tmj = m > h? mj : j;\n\t\t\tm = m > h? m : h;   // m is stored at eh[mj+1]\n\t\t\th -= gapoe;\n\t\t\th = h > 0? h : 0;\n\t\t\te -= gape;\n\t\t\te = e > h? e : h;   // computed E(i+1,j)\n\t\t\tp->e = e;           // save E(i+1,j) for the next row\n\t\t\tf -= gape;\n\t\t\tf = f > h? f : h;   // computed F(i,j+1)\n\t\t}\n\t\teh[end].h = h1; eh[end].e = 0;\n\t\tif (m == 0) break;\n\t\tif (m > max) max = m, max_i = i, max_j = mj;\n\t\t// update beg and end for the next round\n\t\tfor (j = mj; j >= beg && eh[j].h; --j);\n\t\tbeg = j + 1;\n\t\tfor (j = mj + 2; j <= end && eh[j].h; ++j);\n\t\tend = j;\n\t\t//beg = 0; end = qlen; // uncomment this line for debugging\n\t}\n\tfree(eh); free(qp);\n\tif (_qle) *_qle = max_j + 1;\n\tif (_tle) *_tle = max_i + 1;\n\treturn max;\n}\n\n/********************\n * Global alignment *\n ********************/\n\n#define MINUS_INF -0x40000000\n\nstatic inline uint32_t *push_cigar(int *n_cigar, int *m_cigar, uint32_t *cigar, int op, int len)\n{\n\tif (*n_cigar == 0 || op != (cigar[(*n_cigar) - 1]&0xf)) {\n\t\tif (*n_cigar == *m_cigar) {\n\t\t\t*m_cigar = *m_cigar? (*m_cigar)<<1 : 4;\n\t\t\tcigar = realloc(cigar, (*m_cigar) << 2);\n\t\t}\n\t\tcigar[(*n_cigar)++] = len<<4 | op;\n\t} else cigar[(*n_cigar)-1] += len<<4;\n\treturn cigar;\n}\n\nint ksw_global(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int *n_cigar_, uint32_t **cigar_)\n{\n\teh_t *eh;\n\tint8_t *qp; // query profile\n\tint i, j, k, gapoe = gapo + gape, score, n_col;\n\tuint8_t *z; // backtrack matrix; in each cell: f<<4|e<<2|h; in principle, we can halve the memory, but backtrack will be a little more complex\n\tif (n_cigar_) *n_cigar_ = 0;\n\t// allocate memory\n\tn_col = qlen < 2*w+1? qlen : 2*w+1; // maximum #columns of the backtrack matrix\n\tz = malloc(n_col * tlen);\n\tqp = malloc(qlen * m);\n\teh = calloc(qlen + 1, 8);\n\t// generate the query profile\n\tfor (k = i = 0; k < m; ++k) {\n\t\tconst int8_t *p = &mat[k * m];\n\t\tfor (j = 0; j < qlen; ++j) qp[i++] = p[query[j]];\n\t}\n\t// fill the first row\n\teh[0].h = 0; eh[0].e = MINUS_INF;\n\tfor (j = 1; j <= qlen && j <= w; ++j)\n\t\teh[j].h = -(gapo + gape * j), eh[j].e = MINUS_INF;\n\tfor (; j <= qlen; ++j) eh[j].h = eh[j].e = MINUS_INF; // everything is -inf outside the band\n\t// DP loop\n\tfor (i = 0; LIKELY(i < tlen); ++i) { // target sequence is in the outer loop\n\t\tint32_t f = MINUS_INF, h1, beg, end;\n\t\tint8_t *q = &qp[target[i] * qlen];\n\t\tuint8_t *zi = &z[i * n_col];\n\t\tbeg = i > w? i - w : 0;\n\t\tend = i + w + 1 < qlen? i + w + 1 : qlen; // only loop through [beg,end) of the query sequence\n\t\th1 = beg == 0? -(gapo + gape * (i + 1)) : MINUS_INF;\n\t\tfor (j = beg; LIKELY(j < end); ++j) {\n\t\t\t// This loop is organized in a similar way to ksw_extend() and ksw_sse2(), except:\n\t\t\t// 1) not checking h>0; 2) recording direction for backtracking\n\t\t\teh_t *p = &eh[j];\n\t\t\tint32_t h = p->h, e = p->e;\n\t\t\tuint8_t d; // direction\n\t\t\tp->h = h1;\n\t\t\th += q[j];\n\t\t\td = h > e? 0 : 1;\n\t\t\th = h > e? h : e;\n\t\t\td = h > f? d : 2;\n\t\t\th = h > f? h : f;\n\t\t\th1 = h;\n\t\t\th -= gapoe;\n\t\t\te -= gape;\n\t\t\td |= e > h? 1<<2 : 0;\n\t\t\te = e > h? e : h;\n\t\t\tp->e = e;\n\t\t\tf -= gape;\n\t\t\td |= f > h? 2<<4 : 0; // if we want to halve the memory, use one bit only, instead of two\n\t\t\tf = f > h? f : h;\n\t\t\tzi[j - beg] = d; // z[i,j] keeps h for the current cell and e/f for the next cell\n\t\t}\n\t\teh[end].h = h1; eh[end].e = MINUS_INF;\n\t}\n\tscore = eh[qlen].h;\n\tif (n_cigar_ && cigar_) { // backtrack\n\t\tint n_cigar = 0, m_cigar = 0, which = 0;\n\t\tuint32_t *cigar = 0, tmp;\n\t\ti = tlen - 1; k = (i + w + 1 < qlen? i + w + 1 : qlen) - 1; // (i,k) points to the last cell\n\t\twhile (i >= 0 && k >= 0) {\n\t\t\twhich = z[i * n_col + (k - (i > w? i - w : 0))] >> (which<<1) & 3;\n\t\t\tif (which == 0)      cigar = push_cigar(&n_cigar, &m_cigar, cigar, 0, 1), --i, --k;\n\t\t\telse if (which == 1) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 2, 1), --i;\n\t\t\telse                 cigar = push_cigar(&n_cigar, &m_cigar, cigar, 1, 1), --k;\n\t\t}\n\t\tif (i >= 0) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 2, i + 1);\n\t\tif (k >= 0) cigar = push_cigar(&n_cigar, &m_cigar, cigar, 1, k + 1);\n\t\tfor (i = 0; i < n_cigar>>1; ++i) // reverse CIGAR\n\t\t\ttmp = cigar[i], cigar[i] = cigar[n_cigar-1-i], cigar[n_cigar-1-i] = tmp;\n\t\t*n_cigar_ = n_cigar, *cigar_ = cigar;\n\t}\n\tfree(eh); free(qp); free(z);\n\treturn score;\n}\n\n/*******************************************\n * Main function (not compiled by default) *\n *******************************************/\n\n#ifdef _KSW_MAIN\n\n#include <unistd.h>\n#include <stdio.h>\n#include <zlib.h>\n#include \"kseq.h\"\nKSEQ_INIT(gzFile, gzread)\n\nunsigned char seq_nt4_table[256] = {\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,\n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 0, 4, 1,  4, 4, 4, 2,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  3, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4, \n\t4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4\n};\n\nint main(int argc, char *argv[])\n{\n\tint c, sa = 1, sb = 3, i, j, k, forward_only = 0, max_rseq = 0;\n\tint8_t mat[25];\n\tint gapo = 5, gape = 2, minsc = 0, xtra = KSW_XSTART;\n\tuint8_t *rseq = 0;\n\tgzFile fpt, fpq;\n\tkseq_t *kst, *ksq;\n\n\t// parse command line\n\twhile ((c = getopt(argc, argv, \"a:b:q:r:ft:1\")) >= 0) {\n\t\tswitch (c) {\n\t\t\tcase 'a': sa = atoi(optarg); break;\n\t\t\tcase 'b': sb = atoi(optarg); break;\n\t\t\tcase 'q': gapo = atoi(optarg); break;\n\t\t\tcase 'r': gape = atoi(optarg); break;\n\t\t\tcase 't': minsc = atoi(optarg); break;\n\t\t\tcase 'f': forward_only = 1; break;\n\t\t\tcase '1': xtra |= KSW_XBYTE; break;\n\t\t}\n\t}\n\tif (optind + 2 > argc) {\n\t\tfprintf(stderr, \"Usage: ksw [-1] [-f] [-a%d] [-b%d] [-q%d] [-r%d] [-t%d] <target.fa> <query.fa>\\n\", sa, sb, gapo, gape, minsc);\n\t\treturn 1;\n\t}\n\tif (minsc > 0xffff) minsc = 0xffff;\n\txtra |= KSW_XSUBO | minsc;\n\t// initialize scoring matrix\n\tfor (i = k = 0; i < 4; ++i) {\n\t\tfor (j = 0; j < 4; ++j)\n\t\t\tmat[k++] = i == j? sa : -sb;\n\t\tmat[k++] = 0; // ambiguous base\n\t}\n\tfor (j = 0; j < 5; ++j) mat[k++] = 0;\n\t// open file\n\tfpt = gzopen(argv[optind],   \"r\"); kst = kseq_init(fpt);\n\tfpq = gzopen(argv[optind+1], \"r\"); ksq = kseq_init(fpq);\n\t// all-pair alignment\n\twhile (kseq_read(ksq) > 0) {\n\t\tkswq_t *q[2] = {0, 0};\n\t\tkswr_t r;\n\t\tfor (i = 0; i < (int)ksq->seq.l; ++i) ksq->seq.s[i] = seq_nt4_table[(int)ksq->seq.s[i]];\n\t\tif (!forward_only) { // reverse\n\t\t\tif ((int)ksq->seq.m > max_rseq) {\n\t\t\t\tmax_rseq = ksq->seq.m;\n\t\t\t\trseq = (uint8_t*)realloc(rseq, max_rseq);\n\t\t\t}\n\t\t\tfor (i = 0, j = ksq->seq.l - 1; i < (int)ksq->seq.l; ++i, --j)\n\t\t\t\trseq[j] = ksq->seq.s[i] == 4? 4 : 3 - ksq->seq.s[i];\n\t\t}\n\t\tgzrewind(fpt); kseq_rewind(kst);\n\t\twhile (kseq_read(kst) > 0) {\n\t\t\tfor (i = 0; i < (int)kst->seq.l; ++i) kst->seq.s[i] = seq_nt4_table[(int)kst->seq.s[i]];\n\t\t\tr = ksw_align(ksq->seq.l, (uint8_t*)ksq->seq.s, kst->seq.l, (uint8_t*)kst->seq.s, 5, mat, gapo, gape, xtra, &q[0]);\n\t\t\tif (r.score >= minsc)\n\t\t\t\tprintf(\"%s\\t%d\\t%d\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", kst->name.s, r.tb, r.te+1, ksq->name.s, r.qb, r.qe+1, r.score, r.score2, r.te2);\n\t\t\tif (rseq) {\n\t\t\t\tr = ksw_align(ksq->seq.l, rseq, kst->seq.l, (uint8_t*)kst->seq.s, 5, mat, gapo, gape, xtra, &q[1]);\n\t\t\t\tif (r.score >= minsc)\n\t\t\t\t\tprintf(\"%s\\t%d\\t%d\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", kst->name.s, r.tb, r.te+1, ksq->name.s, (int)ksq->seq.l - r.qb, (int)ksq->seq.l - 1 - r.qe, r.score, r.score2, r.te2);\n\t\t\t}\n\t\t}\n\t\tfree(q[0]); free(q[1]);\n\t}\n\tfree(rseq);\n\tkseq_destroy(kst); gzclose(fpt);\n\tkseq_destroy(ksq); gzclose(fpq);\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "ksw.h",
          "type": "blob",
          "size": 2.6669921875,
          "content": "#ifndef __AC_KSW_H\n#define __AC_KSW_H\n\n#include <stdint.h>\n\n#define KSW_XBYTE  0x10000\n#define KSW_XSTOP  0x20000\n#define KSW_XSUBO  0x40000\n#define KSW_XSTART 0x80000\n\nstruct _kswq_t;\ntypedef struct _kswq_t kswq_t;\n\ntypedef struct {\n\tint score; // best score\n\tint te, qe; // target end and query end\n\tint score2, te2; // second best score and ending position on the target\n\tint tb, qb; // target start and query start\n} kswr_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\t/**\n\t * Aligning two sequences\n\t *\n\t * @param qlen    length of the query sequence (typically <tlen)\n\t * @param query   query sequence with 0 <= query[i] < m\n\t * @param tlen    length of the target sequence\n\t * @param target  target sequence\n\t * @param m       number of residue types\n\t * @param mat     m*m scoring matrix in one-dimention array\n\t * @param gapo    gap open penalty; a gap of length l cost \"-(gapo+l*gape)\"\n\t * @param gape    gap extension penalty\n\t * @param xtra    extra information (see below)\n\t * @param qry     query profile (see below)\n\t *\n\t * @return        alignment information in a struct; unset values to -1\n\t *\n\t * When xtra==0, ksw_align() uses a signed two-byte integer to store a\n\t * score and only finds the best score and the end positions. The 2nd best\n\t * score or the start positions are not attempted. The default behavior can\n\t * be tuned by setting KSW_X* flags:\n\t *\n\t *   KSW_XBYTE:  use an unsigned byte to store a score. If overflow occurs,\n\t *               kswr_t::score will be set to 255\n\t *\n\t *   KSW_XSUBO:  track the 2nd best score and the ending position on the\n\t *               target if the 2nd best is higher than (xtra&0xffff)\n\t *\n\t *   KSW_XSTOP:  stop if the maximum score is above (xtra&0xffff)\n\t *\n\t *   KSW_XSTART: find the start positions\n\t *\n\t * When *qry==NULL, ksw_align() will compute and allocate the query profile\n\t * and when the function returns, *qry will point to the profile, which can\n\t * be deallocated simply by free(). If one query is aligned against multiple\n\t * target sequences, *qry should be set to NULL during the first call and\n\t * freed after the last call. Note that qry can equal 0. In this case, the\n\t * query profile will be deallocated in ksw_align().\n\t */\n\tkswr_t ksw_align(int qlen, uint8_t *query, int tlen, uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int xtra, kswq_t **qry);\n\n\tint ksw_extend(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int h0, int *_qle, int *_tle);\n\tint ksw_global(int qlen, const uint8_t *query, int tlen, const uint8_t *target, int m, const int8_t *mat, int gapo, int gape, int w, int *_n_cigar, uint32_t **_cigar);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "kthread.c",
          "type": "blob",
          "size": 6.693359375,
          "content": "#include <pthread.h>\n#include <stdlib.h>\n#include <limits.h>\n\n/************\n * kt_for() *\n ************/\n\nstruct kt_for_t;\n\ntypedef struct {\n\tstruct kt_for_t *t;\n\tlong i;\n} ktf_worker_t;\n\ntypedef struct kt_for_t {\n\tint n_threads;\n\tlong n;\n\tktf_worker_t *w;\n\tvoid (*func)(void*,long,int);\n\tvoid *data;\n} kt_for_t;\n\nstatic inline long steal_work(kt_for_t *t)\n{\n\tint i, min_i = -1;\n\tlong k, min = LONG_MAX;\n\tfor (i = 0; i < t->n_threads; ++i)\n\t\tif (min > t->w[i].i) min = t->w[i].i, min_i = i;\n\tk = __sync_fetch_and_add(&t->w[min_i].i, t->n_threads);\n\treturn k >= t->n? -1 : k;\n}\n\nstatic void *ktf_worker(void *data)\n{\n\tktf_worker_t *w = (ktf_worker_t*)data;\n\tlong i;\n\tfor (;;) {\n\t\ti = __sync_fetch_and_add(&w->i, w->t->n_threads);\n\t\tif (i >= w->t->n) break;\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\t}\n\twhile ((i = steal_work(w->t)) >= 0)\n\t\tw->t->func(w->t->data, i, w - w->t->w);\n\tpthread_exit(0);\n}\n\nvoid kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n)\n{\n\tif (n_threads > 1) {\n\t\tint i;\n\t\tkt_for_t t;\n\t\tpthread_t *tid;\n\t\tt.func = func, t.data = data, t.n_threads = n_threads, t.n = n;\n\t\tt.w = (ktf_worker_t*)alloca(n_threads * sizeof(ktf_worker_t));\n\t\ttid = (pthread_t*)alloca(n_threads * sizeof(pthread_t));\n\t\tfor (i = 0; i < n_threads; ++i)\n\t\t\tt.w[i].t = &t, t.w[i].i = i;\n\t\tfor (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktf_worker, &t.w[i]);\n\t\tfor (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);\n\t} else {\n\t\tlong j;\n\t\tfor (j = 0; j < n; ++j) func(data, j, 0);\n\t}\n}\n\n/***************************\n * kt_for with thread pool *\n ***************************/\n\nstruct kt_forpool_t;\n\ntypedef struct {\n\tstruct kt_forpool_t *t;\n\tlong i;\n\tint action;\n} kto_worker_t;\n\ntypedef struct kt_forpool_t {\n\tint n_threads, n_pending;\n\tlong n;\n\tpthread_t *tid;\n\tkto_worker_t *w;\n\tvoid (*func)(void*,long,int);\n\tvoid *data;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cv_m, cv_s;\n} kt_forpool_t;\n\nstatic inline long kt_fp_steal_work(kt_forpool_t *t)\n{\n\tint i, min_i = -1;\n\tlong k, min = LONG_MAX;\n\tfor (i = 0; i < t->n_threads; ++i)\n\t\tif (min > t->w[i].i) min = t->w[i].i, min_i = i;\n\tk = __sync_fetch_and_add(&t->w[min_i].i, t->n_threads);\n\treturn k >= t->n? -1 : k;\n}\n\nstatic void *kt_fp_worker(void *data)\n{\n\tkto_worker_t *w = (kto_worker_t*)data;\n\tkt_forpool_t *fp = w->t;\n\tfor (;;) {\n\t\tlong i;\n\t\tint action;\n\t\tpthread_mutex_lock(&fp->mutex);\n\t\tif (--fp->n_pending == 0)\n\t\t\tpthread_cond_signal(&fp->cv_m);\n\t\tw->action = 0;\n\t\twhile (w->action == 0) pthread_cond_wait(&fp->cv_s, &fp->mutex);\n\t\taction = w->action;\n\t\tpthread_mutex_unlock(&fp->mutex);\n\t\tif (action < 0) break;\n\t\tfor (;;) { // process jobs allocated to this worker\n\t\t\ti = __sync_fetch_and_add(&w->i, fp->n_threads);\n\t\t\tif (i >= fp->n) break;\n\t\t\tfp->func(fp->data, i, w - fp->w);\n\t\t}\n\t\twhile ((i = kt_fp_steal_work(fp)) >= 0) // steal jobs allocated to other workers\n\t\t\tfp->func(fp->data, i, w - fp->w);\n\t}\n\tpthread_exit(0);\n}\n\nvoid *kt_forpool_init(int n_threads)\n{\n\tkt_forpool_t *fp;\n\tint i;\n\tfp = (kt_forpool_t*)calloc(1, sizeof(kt_forpool_t));\n\tfp->n_threads = fp->n_pending = n_threads;\n\tfp->tid = (pthread_t*)calloc(fp->n_threads, sizeof(pthread_t));\n\tfp->w = (kto_worker_t*)calloc(fp->n_threads, sizeof(kto_worker_t));\n\tfor (i = 0; i < fp->n_threads; ++i) fp->w[i].t = fp;\n\tpthread_mutex_init(&fp->mutex, 0);\n\tpthread_cond_init(&fp->cv_m, 0);\n\tpthread_cond_init(&fp->cv_s, 0);\n\tfor (i = 0; i < fp->n_threads; ++i) pthread_create(&fp->tid[i], 0, kt_fp_worker, &fp->w[i]);\n\tpthread_mutex_lock(&fp->mutex);\n\twhile (fp->n_pending) pthread_cond_wait(&fp->cv_m, &fp->mutex);\n\tpthread_mutex_unlock(&fp->mutex);\n\treturn fp;\n}\n\nvoid kt_forpool_destroy(void *_fp)\n{\n\tkt_forpool_t *fp = (kt_forpool_t*)_fp;\n\tint i;\n\tfor (i = 0; i < fp->n_threads; ++i) fp->w[i].action = -1;\n\tpthread_cond_broadcast(&fp->cv_s);\n\tfor (i = 0; i < fp->n_threads; ++i) pthread_join(fp->tid[i], 0);\n\tpthread_cond_destroy(&fp->cv_s);\n\tpthread_cond_destroy(&fp->cv_m);\n\tpthread_mutex_destroy(&fp->mutex);\n\tfree(fp->w); free(fp->tid); free(fp);\n}\n\nvoid kt_forpool(void *_fp, void (*func)(void*,long,int), void *data, long n)\n{\n\tkt_forpool_t *fp = (kt_forpool_t*)_fp;\n\tlong i;\n\tif (fp && fp->n_threads > 1) {\n\t\tfp->n = n, fp->func = func, fp->data = data, fp->n_pending = fp->n_threads;\n\t\tfor (i = 0; i < fp->n_threads; ++i) fp->w[i].i = i, fp->w[i].action = 1;\n\t\tpthread_mutex_lock(&fp->mutex);\n\t\tpthread_cond_broadcast(&fp->cv_s);\n\t\twhile (fp->n_pending) pthread_cond_wait(&fp->cv_m, &fp->mutex);\n\t\tpthread_mutex_unlock(&fp->mutex);\n\t} else for (i = 0; i < n; ++i) func(data, i, 0);\n}\n\n/*****************\n * kt_pipeline() *\n *****************/\n\nstruct ktp_t;\n\ntypedef struct {\n\tstruct ktp_t *pl;\n\tint64_t index;\n\tint step;\n\tvoid *data;\n} ktp_worker_t;\n\ntypedef struct ktp_t {\n\tvoid *shared;\n\tvoid *(*func)(void*, int, void*);\n\tint64_t index;\n\tint n_workers, n_steps;\n\tktp_worker_t *workers;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t cv;\n} ktp_t;\n\nstatic void *ktp_worker(void *data)\n{\n\tktp_worker_t *w = (ktp_worker_t*)data;\n\tktp_t *p = w->pl;\n\twhile (w->step < p->n_steps) {\n\t\t// test whether we can kick off the job with this worker\n\t\tpthread_mutex_lock(&p->mutex);\n\t\tfor (;;) {\n\t\t\tint i;\n\t\t\t// test whether another worker is doing the same step\n\t\t\tfor (i = 0; i < p->n_workers; ++i) {\n\t\t\t\tif (w == &p->workers[i]) continue; // ignore itself\n\t\t\t\tif (p->workers[i].step <= w->step && p->workers[i].index < w->index)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == p->n_workers) break; // no workers with smaller indices are doing w->step or the previous steps\n\t\t\tpthread_cond_wait(&p->cv, &p->mutex);\n\t\t}\n\t\tpthread_mutex_unlock(&p->mutex);\n\n\t\t// working on w->step\n\t\tw->data = p->func(p->shared, w->step, w->step? w->data : 0); // for the first step, input is NULL\n\n\t\t// update step and let other workers know\n\t\tpthread_mutex_lock(&p->mutex);\n\t\tw->step = w->step == p->n_steps - 1 || w->data? (w->step + 1) % p->n_steps : p->n_steps;\n\t\tif (w->step == 0) w->index = p->index++;\n\t\tpthread_cond_broadcast(&p->cv);\n\t\tpthread_mutex_unlock(&p->mutex);\n\t}\n\tpthread_exit(0);\n}\n\nvoid kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps)\n{\n\tktp_t aux;\n\tpthread_t *tid;\n\tint i;\n\n\tif (n_threads < 1) n_threads = 1;\n\taux.n_workers = n_threads;\n\taux.n_steps = n_steps;\n\taux.func = func;\n\taux.shared = shared_data;\n\taux.index = 0;\n\tpthread_mutex_init(&aux.mutex, 0);\n\tpthread_cond_init(&aux.cv, 0);\n\n\taux.workers = (ktp_worker_t*)alloca(n_threads * sizeof(ktp_worker_t));\n\tfor (i = 0; i < n_threads; ++i) {\n\t\tktp_worker_t *w = &aux.workers[i];\n\t\tw->step = 0; w->pl = &aux; w->data = 0;\n\t\tw->index = aux.index++;\n\t}\n\n\ttid = (pthread_t*)alloca(n_threads * sizeof(pthread_t));\n\tfor (i = 0; i < n_threads; ++i) pthread_create(&tid[i], 0, ktp_worker, &aux.workers[i]);\n\tfor (i = 0; i < n_threads; ++i) pthread_join(tid[i], 0);\n\n\tpthread_mutex_destroy(&aux.mutex);\n\tpthread_cond_destroy(&aux.cv);\n}\n"
        },
        {
          "name": "kthread.h",
          "type": "blob",
          "size": 0.43359375,
          "content": "#ifndef KTHREAD_H\n#define KTHREAD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid kt_for(int n_threads, void (*func)(void*,long,int), void *data, long n);\nvoid kt_pipeline(int n_threads, void *(*func)(void*, int, void*), void *shared_data, int n_steps);\n\nvoid *kt_forpool_init(int n_threads);\nvoid kt_forpool_destroy(void *_fp);\nvoid kt_forpool(void *_fp, void (*func)(void*,long,int), void *data, long n);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "kurl.c",
          "type": "blob",
          "size": 16.44921875,
          "content": "#include <stdio.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <assert.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <curl/curl.h>\n#include \"kurl.h\"\n\n/**********************\n *** Core kurl APIs ***\n **********************/\n\n#define KU_DEF_BUFLEN   0x8000\n#define KU_MAX_SKIP     (KU_DEF_BUFLEN<<1) // if seek step is smaller than this, skip\n\n#define kurl_isfile(u) ((u)->fd >= 0)\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\nstruct kurl_t {\n\tCURLM *multi; // cURL multi handler\n\tCURL *curl;   // cURL easy handle\n\tuint8_t *buf; // buffer\n\toff_t off0;   // offset of the first byte in the buffer; the actual file offset equals off0 + p_buf\n\tint fd;       // file descriptor for a normal file; <0 for a remote file\n\tint m_buf;    // max buffer size; for a remote file, CURL_MAX_WRITE_SIZE*2 is recommended\n\tint l_buf;    // length of the buffer; l_buf == 0 iff the input read entirely; l_buf <= m_buf\n\tint p_buf;    // file position in the buffer; p_buf <= l_buf\n\tint done_reading; // true if we can read nothing from the file; buffer may not be empty even if done_reading is set\n\tint err;      // error code\n\tstruct curl_slist *hdr;\n};\n\ntypedef struct {\n\tchar *url, *date, *auth;\n} s3aux_t;\n\nint kurl_init(void) // required for SSL and win32 socket; NOT thread safe\n{\n\treturn curl_global_init(CURL_GLOBAL_DEFAULT);\n}\n\nvoid kurl_destroy(void)\n{\n\tcurl_global_cleanup();\n}\n\nstatic int prepare(kurl_t *ku, int do_seek)\n{\n\tif (kurl_isfile(ku)) {\n\t\tif (do_seek && lseek(ku->fd, ku->off0, SEEK_SET) != ku->off0)\n\t\t\treturn -1;\n\t} else { // FIXME: for S3, we need to re-authorize\n\t\tint rc;\n\t\trc = curl_multi_remove_handle(ku->multi, ku->curl);\n\t\trc = curl_easy_setopt(ku->curl, CURLOPT_RESUME_FROM, ku->off0);\n\t\trc = curl_multi_add_handle(ku->multi, ku->curl);\n\t}\n\tku->p_buf = ku->l_buf = 0; // empty the buffer\n\treturn 0;\n}\n\nstatic size_t write_cb(char *ptr, size_t size, size_t nmemb, void *data) // callback required by cURL\n{\n\tkurl_t *ku = (kurl_t*)data;\n\tssize_t nbytes = size * nmemb;\n\tif (nbytes + ku->l_buf > ku->m_buf)\n\t\treturn CURL_WRITEFUNC_PAUSE;\n\tmemcpy(ku->buf + ku->l_buf, ptr, nbytes);\n\tku->l_buf += nbytes;\n\treturn nbytes;\n}\n\nstatic int fill_buffer(kurl_t *ku) // fill the buffer\n{\n\tassert(ku->p_buf == ku->l_buf); // buffer is always used up when fill_buffer() is called; otherwise a bug\n\tku->off0 += ku->l_buf;\n\tku->p_buf = ku->l_buf = 0;\n\tif (ku->done_reading) return 0;\n\tif (kurl_isfile(ku)) {\n\t\t// The following block is equivalent to \"ku->l_buf = read(ku->fd, ku->buf, ku->m_buf)\" on Mac.\n\t\t// On Linux, the man page does not specify whether read() guarantees to read ku->m_buf bytes\n\t\t// even if ->fd references a normal file with sufficient remaining bytes.\n\t\twhile (ku->l_buf < ku->m_buf) {\n\t\t\tint l;\n\t\t\tl = read(ku->fd, ku->buf + ku->l_buf, ku->m_buf - ku->l_buf);\n\t\t\tif (l == 0) break;\n\t\t\tku->l_buf += l;\n\t\t}\n\t\tif (ku->l_buf < ku->m_buf) ku->done_reading = 1;\n\t} else {\n\t\tint n_running, rc;\n\t\tfd_set fdr, fdw, fde;\n\t\tdo {\n\t\t\tint maxfd = -1;\n\t\t\tlong curl_to = -1;\n\t\t\tstruct timeval to;\n\t\t\t// the following is adaped from docs/examples/fopen.c \n\t\t\tto.tv_sec = 10, to.tv_usec = 0; // 10 seconds\n\t\t\tcurl_multi_timeout(ku->multi, &curl_to);\n\t\t\tif (curl_to >= 0) {\n\t\t\t\tto.tv_sec = curl_to / 1000;\n\t\t\t\tif (to.tv_sec > 1) to.tv_sec = 1;\n\t\t\t\telse to.tv_usec = (curl_to % 1000) * 1000;\n\t\t\t}\n\t\t\tFD_ZERO(&fdr); FD_ZERO(&fdw); FD_ZERO(&fde);\n\t\t\tcurl_multi_fdset(ku->multi, &fdr, &fdw, &fde, &maxfd); // FIXME: check return code\n\t\t\tif (maxfd >= 0 && (rc = select(maxfd+1, &fdr, &fdw, &fde, &to)) < 0) break;\n\t\t\tif (maxfd < 0) { // check curl_multi_fdset.3 about why we wait for 100ms here\n\t\t\t\tstruct timespec req, rem;\n\t\t\t\treq.tv_sec = 0; req.tv_nsec = 100000000; // this is 100ms\n\t\t\t\tnanosleep(&req, &rem);\n\t\t\t}\n\t\t\tcurl_easy_pause(ku->curl, CURLPAUSE_CONT);\n\t\t\trc = curl_multi_perform(ku->multi, &n_running); // FIXME: check return code\n\t\t} while (n_running && ku->l_buf < ku->m_buf - CURL_MAX_WRITE_SIZE);\n\t\tif (ku->l_buf < ku->m_buf - CURL_MAX_WRITE_SIZE) ku->done_reading = 1;\n\t}\n\treturn ku->l_buf;\n}\n\nint kurl_close(kurl_t *ku)\n{\n\tif (ku == 0) return 0;\n\tif (ku->fd < 0) {\n\t\tcurl_multi_remove_handle(ku->multi, ku->curl);\n\t\tcurl_easy_cleanup(ku->curl);\n\t\tcurl_multi_cleanup(ku->multi);\n\t\tif (ku->hdr) curl_slist_free_all(ku->hdr);\n\t} else close(ku->fd);\n\tfree(ku->buf);\n\tfree(ku);\n\treturn 0;\n}\n\nkurl_t *kurl_open(const char *url, kurl_opt_t *opt)\n{\n\textern s3aux_t s3_parse(const char *url, const char *_id, const char *_secret, const char *fn);\n\tconst char *p, *q;\n\tkurl_t *ku;\n\tint fd = -1, is_file = 1, failed = 0;\n\n\tp = strstr(url, \"://\");\n\tif (p && *p) {\n\t\tfor (q = url; q != p; ++q)\n\t\t\tif (!isalnum(*q)) break;\n\t\tif (q == p) is_file = 0;\n\t}\n\tif (is_file && (fd = open(url, O_RDONLY)) < 0) return 0;\n\n\tku = (kurl_t*)calloc(1, sizeof(kurl_t));\n\tku->fd = is_file? fd : -1;\n\tif (!kurl_isfile(ku)) {\n\t\tku->multi = curl_multi_init();\n\t\tku->curl  = curl_easy_init();\n\t\tif (strstr(url, \"s3://\") == url) {\n\t\t\ts3aux_t a;\n\t\t\ta = s3_parse(url, (opt? opt->s3keyid : 0), (opt? opt->s3secretkey : 0), (opt? opt->s3key_fn : 0));\n\t\t\tif (a.url == 0 || a.date == 0 || a.auth == 0) {\n\t\t\t\tkurl_close(ku);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tku->hdr = curl_slist_append(ku->hdr, a.date);\n\t\t\tku->hdr = curl_slist_append(ku->hdr, a.auth);\n\t\t\tcurl_easy_setopt(ku->curl, CURLOPT_URL, a.url);\n\t\t\tcurl_easy_setopt(ku->curl, CURLOPT_HTTPHEADER, ku->hdr);\n\t\t\tfree(a.date); free(a.auth); free(a.url);\n\t\t} else curl_easy_setopt(ku->curl, CURLOPT_URL, url);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_WRITEDATA, ku);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_VERBOSE, 0L);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_NOSIGNAL, 1L);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_WRITEFUNCTION, write_cb);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_SSL_VERIFYPEER, 0L);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_SSL_VERIFYHOST, 0L);\n\t\tcurl_easy_setopt(ku->curl, CURLOPT_FOLLOWLOCATION, 1L);\n\t}\n\tku->m_buf = KU_DEF_BUFLEN;\n\tif (!kurl_isfile(ku) && ku->m_buf < CURL_MAX_WRITE_SIZE * 2)\n\t\tku->m_buf = CURL_MAX_WRITE_SIZE * 2; // for remote files, the buffer set to 2*CURL_MAX_WRITE_SIZE\n\tku->buf = (uint8_t*)calloc(ku->m_buf, 1);\n\tif (kurl_isfile(ku)) failed = (fill_buffer(ku) <= 0);\n\telse failed = (prepare(ku, 0) < 0 || fill_buffer(ku) <= 0);\n\tif (failed) {\n\t\tkurl_close(ku);\n\t\treturn 0;\n\t}\n\treturn ku;\n}\n\nkurl_t *kurl_dopen(int fd)\n{\n\tkurl_t *ku;\n\tku = (kurl_t*)calloc(1, sizeof(kurl_t));\n\tku->fd = fd;\n\tku->m_buf = KU_DEF_BUFLEN;\n\tku->buf = (uint8_t*)calloc(ku->m_buf, 1);\n\tif (prepare(ku, 0) < 0 || fill_buffer(ku) <= 0) {\n\t\tkurl_close(ku);\n\t\treturn 0;\n\t}\n\treturn ku;\n}\n\nint kurl_buflen(kurl_t *ku, int len)\n{\n\tif (len <= 0 || len < ku->l_buf) return ku->m_buf;\n\tif (!kurl_isfile(ku) && len < CURL_MAX_WRITE_SIZE * 2) return ku->m_buf;\n\tku->m_buf = len;\n\tkroundup32(ku->m_buf);\n\tku->buf = (uint8_t*)realloc(ku->buf, ku->m_buf);\n\treturn ku->m_buf;\n}\n\nssize_t kurl_read(kurl_t *ku, void *buf, size_t nbytes)\n{\n\tssize_t rest = nbytes;\n\tif (ku->l_buf == 0) return 0; // end-of-file\n\twhile (rest) {\n\t\tif (ku->l_buf - ku->p_buf >= rest) {\n\t\t\tif (buf) memcpy((uint8_t*)buf + (nbytes - rest), ku->buf + ku->p_buf, rest);\n\t\t\tku->p_buf += rest;\n\t\t\trest = 0;\n\t\t} else {\n\t\t\tint ret;\n\t\t\tif (buf && ku->l_buf > ku->p_buf)\n\t\t\t\tmemcpy((uint8_t*)buf + (nbytes - rest), ku->buf + ku->p_buf, ku->l_buf - ku->p_buf);\n\t\t\trest -= ku->l_buf - ku->p_buf;\n\t\t\tku->p_buf = ku->l_buf;\n\t\t\tret = fill_buffer(ku);\n\t\t\tif (ret <= 0) break;\n\t\t}\n\t}\n\treturn nbytes - rest;\n}\n\noff_t kurl_seek(kurl_t *ku, off_t offset, int whence) // FIXME: sometimes when seek() fails, read() will fail as well.\n{\n\toff_t new_off = -1, cur_off;\n\tint failed = 0, seek_end = 0;\n\tif (ku == 0) return -1;\n\tcur_off = ku->off0 + ku->p_buf;\n\tif (whence == SEEK_SET) new_off = offset;\n\telse if (whence == SEEK_CUR) new_off += cur_off + offset;\n\telse if (whence == SEEK_END && kurl_isfile(ku)) new_off = lseek(ku->fd, offset, SEEK_END), seek_end = 1;\n\telse { // not supported whence\n\t\tku->err = KURL_INV_WHENCE;\n\t\treturn -1;\n\t}\n\tif (new_off < 0) { // negtive absolute offset\n\t\tku->err = KURL_SEEK_OUT;\n\t\treturn -1;\n\t}\n\tif (!seek_end && new_off >= cur_off && new_off - cur_off + ku->p_buf < ku->l_buf) {\n\t\tku->p_buf += new_off - cur_off;\n\t\treturn ku->off0 + ku->p_buf;\n\t}\n\tif (seek_end || new_off < cur_off || new_off - cur_off > KU_MAX_SKIP) { // if jump is large, do actual seek\n\t\tku->off0 = new_off;\n\t\tku->done_reading = 0;\n\t\tif (prepare(ku, 1) < 0 || fill_buffer(ku) <= 0) failed = 1;\n\t} else { // if jump is small, read through\n\t\toff_t r;\n\t\tr = kurl_read(ku, 0, new_off - cur_off);\n\t\tif (r + cur_off != new_off) failed = 1; // out of range\n\t}\n\tif (failed) ku->err = KURL_SEEK_OUT, ku->l_buf = ku->p_buf = 0, new_off = -1;\n\treturn new_off;\n}\n\noff_t kurl_tell(const kurl_t *ku)\n{\n\tif (ku == 0) return -1;\n\treturn ku->off0 + ku->p_buf;\n}\n\nint kurl_eof(const kurl_t *ku)\n{\n\tif (ku == 0) return 1;\n\treturn (ku->l_buf == 0); // unless file end, buffer should never be empty\n}\n\nint kurl_fileno(const kurl_t *ku)\n{\n\tif (ku == 0) return -1;\n\treturn ku->fd;\n}\n\nint kurl_error(const kurl_t *ku)\n{\n\tif (ku == 0) return KURL_NULL;\n\treturn ku->err;\n}\n\n/*****************\n *** HMAC-SHA1 ***\n *****************/\n\n/* This code is public-domain - it is based on libcrypt placed in the public domain by Wei Dai and other contributors. */\n\n#define HASH_LENGTH 20\n#define BLOCK_LENGTH 64\n\ntypedef struct sha1nfo {\n\tunion { uint8_t b[BLOCK_LENGTH]; uint32_t w[BLOCK_LENGTH/4]; } buf;\n\tuint8_t bufOffset;\n\tunion { uint8_t b[HASH_LENGTH]; uint32_t w[HASH_LENGTH/4]; } state;\n\tuint32_t byteCount;\n\tuint8_t keyBuffer[BLOCK_LENGTH];\n\tuint8_t innerHash[HASH_LENGTH];\n} sha1nfo;\n\nvoid sha1_init(sha1nfo *s)\n{\n\tconst uint8_t table[] = { 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef, 0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10, 0xf0,0xe1,0xd2,0xc3 };\n\tmemcpy(s->state.b, table, HASH_LENGTH);\n\ts->byteCount = 0;\n\ts->bufOffset = 0;\n}\n\n#define rol32(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic void sha1_hashBlock(sha1nfo *s)\n{\n\tuint32_t i, t, a = s->state.w[0], b = s->state.w[1], c = s->state.w[2], d = s->state.w[3], e = s->state.w[4];\n\tfor (i = 0; i < 80; i++) {\n\t\tif (i >= 16) {\n\t\t\tt = s->buf.w[(i+13)&15] ^ s->buf.w[(i+8)&15] ^ s->buf.w[(i+2)&15] ^ s->buf.w[i&15];\n\t\t\ts->buf.w[i&15] = rol32(t, 1);\n\t\t}\n\t\tif (i < 20)      t = 0x5a827999 + (d ^ (b & (c ^ d)));\n\t\telse if (i < 40) t = 0x6ed9eba1 + (b ^ c ^ d);\n\t\telse if (i < 60) t = 0x8f1bbcdc + ((b & c) | (d & (b | c)));\n\t\telse             t = 0xca62c1d6 + (b ^ c ^ d);\n\t\tt += rol32(a, 5) + e + s->buf.w[i&15];\n\t\te = d; d = c; c = rol32(b, 30); b = a; a = t;\n\t}\n\ts->state.w[0] += a; s->state.w[1] += b; s->state.w[2] += c; s->state.w[3] += d; s->state.w[4] += e;\n}\n\nstatic inline void sha1_add(sha1nfo *s, uint8_t data)\n{\n\ts->buf.b[s->bufOffset ^ 3] = data;\n\tif (++s->bufOffset == BLOCK_LENGTH) {\n\t\tsha1_hashBlock(s);\n\t\ts->bufOffset = 0;\n\t}\n}\n\nvoid sha1_write1(sha1nfo *s, uint8_t data)\n{\n\t++s->byteCount;\n\tsha1_add(s, data);\n}\n\nvoid sha1_write(sha1nfo *s, const char *data, size_t len)\n{\n\twhile (len--) sha1_write1(s, (uint8_t)*data++);\n}\n\nconst uint8_t *sha1_final(sha1nfo *s)\n{\n\tint i;\n\tsha1_add(s, 0x80);\n\twhile (s->bufOffset != 56) sha1_add(s, 0);\n\tsha1_add(s, 0);\n\tsha1_add(s, 0);\n\tsha1_add(s, 0);\n\tsha1_add(s, s->byteCount >> 29);\n\tsha1_add(s, s->byteCount >> 21);\n\tsha1_add(s, s->byteCount >> 13);\n\tsha1_add(s, s->byteCount >> 5);\n\tsha1_add(s, s->byteCount << 3);\n\tfor (i = 0; i < 5; ++i) {\n\t\tuint32_t a = s->state.w[i];\n\t\ts->state.w[i] = a<<24 | (a<<8&0x00ff0000) | (a>>8&0x0000ff00) | a>>24;\n\t}\n\treturn s->state.b;\n}\n\n#define HMAC_IPAD 0x36\n#define HMAC_OPAD 0x5c\n\nvoid sha1_init_hmac(sha1nfo *s, const uint8_t* key, int l_key)\n{\n\tuint8_t i;\n\tmemset(s->keyBuffer, 0, BLOCK_LENGTH);\n\tif (l_key > BLOCK_LENGTH) {\n\t\tsha1_init(s);\n\t\twhile (l_key--) sha1_write1(s, *key++);\n\t\tmemcpy(s->keyBuffer, sha1_final(s), HASH_LENGTH);\n\t} else memcpy(s->keyBuffer, key, l_key);\n\tsha1_init(s);\n\tfor (i = 0; i < BLOCK_LENGTH; ++i)\n\t\tsha1_write1(s, s->keyBuffer[i] ^ HMAC_IPAD);\n}\n\nconst uint8_t *sha1_final_hmac(sha1nfo *s)\n{\n\tuint8_t i;\n\tmemcpy(s->innerHash, sha1_final(s), HASH_LENGTH);\n\tsha1_init(s);\n\tfor (i = 0; i < BLOCK_LENGTH; ++i) sha1_write1(s, s->keyBuffer[i] ^ HMAC_OPAD);\n\tfor (i = 0; i < HASH_LENGTH; ++i) sha1_write1(s, s->innerHash[i]);\n\treturn sha1_final(s);\n}\n\n/*******************\n *** S3 protocol ***\n *******************/\n\n#include <time.h>\n#include <ctype.h>\n\nstatic void s3_sign(const char *key, const char *data, char out[29])\n{\n\tconst char *b64tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tconst uint8_t *digest;\n\tint i, j, rest;\n\tsha1nfo s;\n\tsha1_init_hmac(&s, (uint8_t*)key, strlen(key));\n\tsha1_write(&s, data, strlen(data));\n\tdigest = sha1_final_hmac(&s);\n\tfor (j = i = 0, rest = 8; i < 20; ++j) { // base64 encoding\n\t\tif (rest <= 6) {\n\t\t\tint next = i < 19? digest[i+1] : 0;\n\t\t\tout[j] = b64tab[(int)(digest[i] << (6-rest) & 0x3f) | next >> (rest+2)], ++i, rest += 2;\n\t\t} else out[j] = b64tab[(int)digest[i] >> (rest-6) & 0x3f], rest -= 6;\n\t}\n\tout[j++] = '='; out[j] = 0; // SHA1 digest always has 160 bits, or 20 bytes. We need one '=' at the end.\n}\n\nstatic char *s3_read_awssecret(const char *fn)\n{\n\tchar *p, *secret, buf[128], *path;\n\tFILE *fp;\n\tint l;\n\tif (fn == 0) {\n\t\tchar *home;\n\t\thome = getenv(\"HOME\");\n\t\tif (home == 0) return 0;\n\t\tl = strlen(home) + 12;\n\t\tpath = (char*)malloc(strlen(home) + 12);\n\t\tstrcat(strcpy(path, home), \"/.awssecret\");\n\t} else path = (char*)fn;\n\tfp = fopen(path, \"r\");\n\tif (path != fn) free(path);\n\tif (fp == 0) return 0;\n\tl = fread(buf, 1, 127, fp);\n\tfclose(fp);\n\tbuf[l] = 0;\n\tfor (p = buf; *p != 0 && *p != '\\n'; ++p);\n\tif (*p == 0) return 0;\n\t*p = 0; secret = p + 1;\n\tfor (++p; *p != 0 && *p != '\\n'; ++p);\n\t*p = 0;\n\tl = p - buf + 1;\n\tp = (char*)malloc(l);\n\tmemcpy(p, buf, l);\n\treturn p;\n}\n\ntypedef struct { int l, m; char *s; } kstring_t;\n\nstatic inline int kputsn(const char *p, int l, kstring_t *s)\n{\n\tif (s->l + l + 1 >= s->m) {\n\t\ts->m = s->l + l + 2;\n\t\tkroundup32(s->m);\n\t\ts->s = (char*)realloc(s->s, s->m);\n\t}\n\tmemcpy(s->s + s->l, p, l);\n\ts->l += l;\n\ts->s[s->l] = 0;\n\treturn l;\n}\n\ns3aux_t s3_parse(const char *url, const char *_id, const char *_secret, const char *fn_secret)\n{\n\tconst char *id, *secret, *bucket, *obj;\n\tchar *id_secret = 0, date[64], sig[29];\n\ttime_t t;\n\tstruct tm tmt;\n\ts3aux_t a = {0,0};\n\tkstring_t str = {0,0,0};\n\t// parse URL\n\tif (strstr(url, \"s3://\") != url) return a;\n\tbucket = url + 5;\n\tfor (obj = bucket; *obj && *obj != '/'; ++obj);\n\tif (*obj == 0) return a; // no object\n\t// acquire AWS credential and time\n\tif (_id == 0 || _secret == 0) {\n\t\tid_secret = s3_read_awssecret(fn_secret);\n\t\tif (id_secret == 0) return a; // fail to read the AWS credential\n\t\tid = id_secret;\n\t\tsecret = id_secret + strlen(id) + 1;\n\t} else id = _id, secret = _secret;\n\t// compose URL for curl\n\tkputsn(\"https://\", 8, &str);\n\tkputsn(bucket, obj - bucket, &str);\n\tkputsn(\".s3.amazonaws.com\", 17, &str);\n\tkputsn(obj, strlen(obj), &str);\n\ta.url = str.s;\n\t// compose the Date line\n\tstr.l = str.m = 0; str.s = 0;\n\tt = time(0);\n\tstrftime(date, 64, \"%a, %d %b %Y %H:%M:%S +0000\", gmtime_r(&t, &tmt));\n\tkputsn(\"Date: \", 6, &str);\n\tkputsn(date, strlen(date), &str);\n\ta.date = str.s;\n\t// compose the string to sign and sign it\n\tstr.l = str.m = 0; str.s = 0;\n\tkputsn(\"GET\\n\\n\\n\", 6, &str);\n\tkputsn(date, strlen(date), &str);\n\tkputsn(\"\\n\", 1, &str);\n\tkputsn(bucket-1, strlen(bucket-1), &str);\n\ts3_sign(secret, str.s, sig);\n\t// compose the Authorization line\n\tstr.l = 0;\n\tkputsn(\"Authorization: AWS \", 19, &str);\n\tkputsn(id, strlen(id), &str);\n\tkputsn(\":\", 1, &str);\n\tkputsn(sig, strlen(sig), &str);\n\ta.auth = str.s;\n//\tprintf(\"curl -H '%s' -H '%s' %s\\n\", a.date, a.auth, a.url);\n\treturn a;\n}\n\n/*********************\n *** Main function ***\n *********************/\n\n#ifdef KURL_MAIN\nint main(int argc, char *argv[])\n{\n\tkurl_t *f;\n\tint c, l, l_buf = 0x10000;\n\toff_t start = 0, rest = -1;\n\tuint8_t *buf;\n\tchar *p;\n\tkurl_opt_t opt;\n\n\tmemset(&opt, 0, sizeof(kurl_opt_t));\n\twhile ((c = getopt(argc, argv, \"c:l:a:\")) >= 0) {\n\t\tif (c == 'c') start = strtol(optarg, &p, 0);\n\t\telse if (c == 'l') rest = strtol(optarg, &p, 0);\n\t\telse if (c == 'a') opt.s3key_fn = optarg;\n\t}\n\tif (optind == argc) {\n\t\tfprintf(stderr, \"Usage: kurl [-c start] [-l length] <url>\\n\");\n\t\treturn 1;\n\t}\n\tkurl_init();\n\tf = kurl_open(argv[optind], &opt);\n\tif (f == 0) {\n\t\tfprintf(stderr, \"ERROR: fail to open URL\\n\");\n\t\treturn 2;\n\t}\n\tif (start > 0) {\n\t\tif (kurl_seek(f, start, SEEK_SET) < 0) {\n\t\t\tkurl_close(f);\n\t\t\tfprintf(stderr, \"ERROR: fail to seek\\n\");\n\t\t\treturn 3;\n\t\t}\n\t}\n\tbuf = (uint8_t*)calloc(l_buf, 1);\n\twhile (rest != 0) {\n\t\tint to_read = rest > 0 && rest < l_buf? rest : l_buf;\n\t\tl = kurl_read(f, buf, to_read);\n\t\tif (l == 0) break;\n\t\tfwrite(buf, 1, l, stdout);\n\t\trest -= l;\n\t}\n\tfree(buf);\n\tkurl_close(f);\n\tkurl_destroy();\n\treturn 0;\n}\n#endif\n"
        },
        {
          "name": "kurl.h",
          "type": "blob",
          "size": 1.2724609375,
          "content": "#ifndef KURL_H\n#define KURL_H\n\n#include <sys/types.h>\n\n#define KURL_NULL       1\n#define KURL_INV_WHENCE 2\n#define KURL_SEEK_OUT   3\n#define KURL_NO_AUTH    4\n\nstruct kurl_t;\ntypedef struct kurl_t kurl_t;\n\ntypedef struct {\n\tconst char *s3keyid;\n\tconst char *s3secretkey;\n\tconst char *s3key_fn;\n} kurl_opt_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint kurl_init(void);\nvoid kurl_destroy(void);\n\nkurl_t *kurl_open(const char *url, kurl_opt_t *opt);\nkurl_t *kurl_dopen(int fd);\nint kurl_close(kurl_t *ku);\nssize_t kurl_read(kurl_t *ku, void *buf, size_t nbytes);\noff_t kurl_seek(kurl_t *ku, off_t offset, int whence);\nint kurl_buflen(kurl_t *ku, int len);\n\noff_t kurl_tell(const kurl_t *ku);\nint kurl_eof(const kurl_t *ku);\nint kurl_fileno(const kurl_t *ku);\nint kurl_error(const kurl_t *ku);\n\n#ifdef __cplusplus\n}\n#endif\n\n#ifndef KNETFILE_H\n#define KNETFILE_H\ntypedef kurl_t knetFile;\n#define knet_open(fn, mode) kurl_open(fn, 0)\n#define knet_dopen(fd, mode) kurl_dopen(fd)\n#define knet_close(fp) kurl_close(fp)\n#define knet_read(fp, buf, len) kurl_read(fp, buf, len)\n#define knet_seek(fp, off, whence) kurl_seek(fp, off, whence)\n#define knet_tell(fp) kurl_tell(fp)\n#define knet_fileno(fp) kurl_fileno(fp)\n#define knet_win32_init() kurl_init()\n#define knet_win32_destroy() kurl_destroy()\n#endif\n\n#endif\n"
        },
        {
          "name": "kvec.h",
          "type": "blob",
          "size": 2.8125,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"kvec.h\"\nint main() {\n\tkvec_t(int) array;\n\tkv_init(array);\n\tkv_push(int, array, 10); // append\n\tkv_a(int, array, 20) = 5; // dynamic\n\tkv_A(array, 20) = 4; // static\n\tkv_destroy(array);\n\treturn 0;\n}\n*/\n\n/*\n  2008-09-22 (0.1.0):\n\n\t* The initial version.\n\n*/\n\n#ifndef AC_KVEC_H\n#define AC_KVEC_H\n\n#include <stdlib.h>\n\n#define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n\n#define kvec_t(type) struct { size_t n, m; type *a; }\n#define kv_init(v) ((v).n = (v).m = 0, (v).a = 0)\n#define kv_destroy(v) free((v).a)\n#define kv_A(v, i) ((v).a[(i)])\n#define kv_pop(v) ((v).a[--(v).n])\n#define kv_size(v) ((v).n)\n#define kv_max(v) ((v).m)\n\n#define kv_resize(type, v, s)  ((v).m = (s), (v).a = (type*)realloc((v).a, sizeof(type) * (v).m))\n\n#define kv_copy(type, v1, v0) do {\t\t\t\t\t\t\t\\\n\t\tif ((v1).m < (v0).n) kv_resize(type, v1, (v0).n);\t\\\n\t\t(v1).n = (v0).n;\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy((v1).a, (v0).a, sizeof(type) * (v0).n);\t\t\\\n\t} while (0)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#define kv_push(type, v, x) do {\t\t\t\t\t\t\t\t\t\\\n\t\tif ((v).n == (v).m) {\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t(v).m = (v).m? (v).m<<1 : 2;\t\t\t\t\t\t\t\\\n\t\t\t(v).a = (type*)realloc((v).a, sizeof(type) * (v).m);\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(v).a[(v).n++] = (x);\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define kv_pushp(type, v) (((v).n == (v).m)?\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t   ((v).m = ((v).m? (v).m<<1 : 2),\t\t\t\t\\\n\t\t\t\t\t\t\t(v).a = (type*)realloc((v).a, sizeof(type) * (v).m), 0)\t\\\n\t\t\t\t\t\t   : 0), ((v).a + ((v).n++))\n\n#define kv_a(type, v, i) (((v).m <= (size_t)(i)? \\\n\t\t\t\t\t\t  ((v).m = (v).n = (i) + 1, kv_roundup32((v).m), \\\n\t\t\t\t\t\t   (v).a = (type*)realloc((v).a, sizeof(type) * (v).m), 0) \\\n\t\t\t\t\t\t  : (v).n <= (size_t)(i)? (v).n = (i) + 1 \\\n\t\t\t\t\t\t  : 0), (v).a[(i)])\n\n#endif\n"
        },
        {
          "name": "lua",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}