{
  "metadata": {
    "timestamp": 1736710128615,
    "page": 771,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "spencertipping/jit-tutorial",
      "stars": 1813,
      "defaultBranch": "master",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.7978515625,
          "content": "# How to write a JIT compiler\nFirst up, you probably don't want to. JIT, or more accurately \"dynamic code\ngeneration,\" is typically not the most effective way to optimize a project, and\ncommon techniques end up trading away a lot of portability and require fairly\ndetailed knowledge about processor-level optimization.\n\nThat said, though, writing JIT compiler is a lot of fun and a great way to\nlearn stuff. The first thing to do is to write an interpreter.\n\n**NOTE:** If you don't have solid grasp of UNIX system-level programming, you\nmight want to read about [how to write a\nshell](https://github.com/spencertipping/shell-tutorial), which covers a lot of\nthe fundamentals.\n\n## MandelASM\nGPUs are fine for machine learning, but serious fractal enthusiasts design\ntheir own processors to generate Mandelbrot sets. And the first step in\nprocessor design, of course, is to write an emulator for it. Our emulator will\ninterpret the machine code we want to run and emit an image to stdout.\n\nTo keep it simple, our processor has four complex-valued registers called `a`,\n`b`, `c`, and `d`, and it supports three in-place operations:\n\n- `=ab`: assign register `a` to register `b`\n- `+ab`: add register `a` to register `b`\n- `*ab`: multiply register `b` by register `a`\n\nFor each pixel, the interpreter will zero all of the registers and then set `a`\nto the current pixel's coordinates. It then iterates the machine code for up to\n256 iterations waiting for register `b` to \"overflow\" (i.e. for its complex\nabsolute value to exceed 2). That means that the code for a standard Mandelbrot\nset is `*bb+ab`.\n\n### Simple interpreter\nThe first thing to do is write up a bare-bones interpreter in C. It would be\nsimpler to use `complex.h` here, but I'm going to write it in terms of\nindividual numbers because the JIT compiler will end up generating the longhand\nlogic. In production code we'd include bounds-checks and stuff, but I'm\nomitting those here for simplicity.\n\n```c\n// simple.c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define sqr(x) ((x) * (x))\n\ntypedef struct { double r; double i; } complex;\n\nvoid interpret(complex *registers, char const *code) {\n  complex *src, *dst;\n  double r, i;\n  for (; *code; code += 3) {\n    dst = &registers[code[2] - 'a'];\n    src = &registers[code[1] - 'a'];\n    switch (*code) {\n      case '=':\n        dst->r = src->r;\n        dst->i = src->i;\n        break;\n      case '+':\n        dst->r += src->r;\n        dst->i += src->i;\n        break;\n      case '*':\n        r = dst->r * src->r - dst->i * src->i;\n        i = dst->r * src->i + dst->i * src->r;\n        dst->r = r;\n        dst->i = i;\n        break;\n      default:\n        fprintf(stderr, \"undefined instruction %s (ASCII %x)\\n\", code, *code);\n        exit(1);\n    }\n  }\n}\n\nint main(int argc, char **argv) {\n  complex registers[4];\n  int i, x, y;\n  char line[1600];\n  printf(\"P5\\n%d %d\\n%d\\n\", 1600, 900, 255);\n  for (y = 0; y < 900; ++y) {\n    for (x = 0; x < 1600; ++x) {\n      registers[0].r = 2 * 1.6 * (x / 1600.0 - 0.5);\n      registers[0].i = 2 * 0.9 * (y /  900.0 - 0.5);\n      for (i = 1; i < 4; ++i) registers[i].r = registers[i].i = 0;\n      for (i = 0; i < 256 && sqr(registers[1].r) + sqr(registers[1].i) < 4; ++i)\n        interpret(registers, argv[1]);\n      line[x] = i;\n    }\n    fwrite(line, 1, sizeof(line), stdout);\n  }\n  return 0;\n}\n```\n\nNow we can see the results by using `display` from ImageMagick\n(`apt-get install imagemagick`), or by saving to a file:\n\n```sh\n$ gcc simple.c -o simple\n$ ./simple *bb+ab | display -           # imagemagick version\n$ ./simple *bb+ab > output.pgm          # save a grayscale PPM image\n$ time ./simple *bb+ab > /dev/null      # quick benchmark\nreal\t0m2.369s\nuser\t0m2.364s\nsys\t0m0.000s\n$\n```\n\n![image](http://spencertipping.com/mandelbrot-output.png)\n\n### Performance analysis\n**In the real world, JIT is absolutely the wrong move for this problem.**\n\nArray languages like APL, Matlab, and to a large extent Perl, Python, etc,\nmanage to achieve reasonable performance by having interpreter operations that\napply over a large number of data elements at a time. We've got exactly that\nsituation here: in the real world it's a lot more practical to vectorize the\noperations to apply simultaneously to a screen-worth of data at a time -- then\nwe'd have nice options like offloading stuff to a GPU, etc.\n\nHowever, since the point here is to compile stuff, on we go.\n\nJIT can basically eliminate the interpreter overhead, which we can easily model\nhere by replacing `interpret()` with a hard-coded Mandelbrot calculation. This\nwill provide an upper bound on realistic JIT performance, since we're unlikely\nto optimize as well as `gcc` does.\n\n```c\n// hardcoded.c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define sqr(x) ((x) * (x))\n\ntypedef struct { double r; double i; } complex;\n\nvoid interpret(complex *registers, char const *code) {\n  complex *a = &registers[0];\n  complex *b = &registers[1];\n  double r, i;\n  r = b->r * b->r - b->i * b->i;\n  i = b->r * b->i + b->i * b->r;\n  b->r = r;\n  b->i = i;\n  b->r += a->r;\n  b->i += a->i;\n}\n\nint main(int argc, char **argv) {\n  complex registers[4];\n  int i, x, y;\n  char line[1600];\n  printf(\"P5\\n%d %d\\n%d\\n\", 1600, 900, 255);\n  for (y = 0; y < 900; ++y) {\n    for (x = 0; x < 1600; ++x) {\n      registers[0].r = 2 * 1.6 * (x / 1600.0 - 0.5);\n      registers[0].i = 2 * 0.9 * (y /  900.0 - 0.5);\n      for (i = 1; i < 4; ++i) registers[i].r = registers[i].i = 0;\n      for (i = 0; i < 256 && sqr(registers[1].r) + sqr(registers[1].i) < 4; ++i)\n        interpret(registers, argv[1]);\n      line[x] = i;\n    }\n    fwrite(line, 1, sizeof(line), stdout);\n  }\n  return 0;\n}\n```\n\nThis version runs about twice as fast as the simple interpreter:\n\n```sh\n$ gcc hardcoded.c -o hardcoded\n$ time ./hardcoded *bb+ab > /dev/null\nreal\t0m1.329s\nuser\t0m1.328s\nsys\t0m0.000s\n$\n```\n\n### JIT design and the x86-64 calling convention\nThe basic strategy is to replace `interpret(registers, code)` with a function\n`compile(code)` that returns a pointer to a function whose signature is this:\n`void compiled(registers*)`. The memory for the function needs to be allocated\nusing `mmap` so we can set permission for the processor to execute it.\n\nThe easiest way to start with something like this is probably to emit the\nassembly for `simple.c` to see how it works:\n\n```sh\n$ gcc -S simple.c\n```\n\nEdited/annotated highlights from the assembly `simple.s`, which is much more\ncomplicated than what we'll end up generating:\n\n```s\ninterpret:\n        // The stack contains local variables referenced to the \"base pointer\"\n        // stored in hardware register %rbp. Here's the layout:\n        //\n        //   double i  = -8(%rbp)\n        //   double r  = -16(%rbp)\n        //   src       = -24(%rbp)\n        //   dst       = -32(%rbp)\n        //   registers = -40(%rbp)      <- comes in as an argument in %rdi\n        //   code      = -48(%rbp)      <- comes in as an argument in %rsi\n\n        pushq   %rbp\n        movq    %rsp, %rbp              // standard x86-64 function header\n        subq    $48, %rsp               // allocate space for six local vars\n        movq    %rdi, -40(%rbp)         // registers arg -> local var\n        movq    %rsi, -48(%rbp)         // code arg -> local var\n        jmp     for_loop_condition      // commence loopage\n```\n\nBefore getting to the rest, I wanted to call out the `%rsi` and `%rdi` stuff\nand explain a bit about how calls work on x86-64. `%rsi` and `%rdi` seem\narbitrary, which they are to some extent -- C obeys a platform-specific calling\nconvention that specifies how arguments get passed in. On x86-64, up to six\narguments come in as registers; after that they get pushed onto the stack. If\nyou're returning a value, it goes into `%rax`.\n\nThe return address is automatically pushed onto the stack by `call`\ninstructions like `e8 <32-bit relative>`. So internally, `call` is the same as\n`push ADDRESS; jmp <call-site>; ADDRESS: ...`. `ret` is the same as `pop %rip`,\nexcept that you can't pop into `%rip`. This means that the return address is\nalways the most immediate value on the stack.\n\nPart of the calling convention also requires callees to save a couple of\nregisters and use `%rbp` to be a copy of `%rsp` at function-call-time, but our\nJIT can mostly ignore this stuff because it doesn't call back into C.\n\n```s\nfor_loop_body:\n        // (a bunch of stuff to set up *src and *dst)\n\n        cmpl    $43, %eax               // case '+'\n        je      add_branch\n        cmpl    $61, %eax               // case '='\n        je      assign_branch\n        cmpl    $42, %eax               // case '*'\n        je      mult_branch\n        jmp     switch_default          // default\n\nassign_branch:\n        // the \"bunch of stuff\" above calculated *src and *dst, which are\n        // stored in -24(%rbp) and -32(%rbp).\n        movq    -24(%rbp), %rax         // %rax = src\n        movsd   (%rax), %xmm0           // %xmm0 = src.r\n        movq    -32(%rbp), %rax         // %rax = dst\n        movsd   %xmm0, (%rax)           // dst.r = %xmm0\n\n        movq    -24(%rbp), %rax         // %rax = src\n        movsd   8(%rax), %xmm0          // %xmm0 = src.i\n        movq    -32(%rbp), %rax         // %rax = dst\n        movsd   %xmm0, 8(%rax)          // dst.i = %xmm0\n\n        jmp     for_loop_step\n\nadd_branch:\n        movq    -32(%rbp), %rax         // %rax = dst\n        movsd   (%rax), %xmm1           // %xmm1 = dst.r\n        movq    -24(%rbp), %rax         // %rax = src\n        movsd   (%rax), %xmm0           // %xmm0 = src.r\n        addsd   %xmm1, %xmm0            // %xmm0 += %xmm1\n        movq    -32(%rbp), %rax         // %rax = dst\n        movsd   %xmm0, (%rax)           // dst.r = %xmm0\n\n        movq    -32(%rbp), %rax         // same thing for src.i and dst.i\n        movsd   8(%rax), %xmm1\n        movq    -24(%rbp), %rax\n        movsd   8(%rax), %xmm0\n        addsd   %xmm1, %xmm0\n        movq    -32(%rbp), %rax\n        movsd   %xmm0, 8(%rax)\n\n        jmp     for_loop_step\n\nmult_branch:\n        movq    -32(%rbp), %rax\n        movsd   (%rax), %xmm1\n        movq    -24(%rbp), %rax\n        movsd   (%rax), %xmm0\n        mulsd   %xmm1, %xmm0\n        movq    -32(%rbp), %rax\n        movsd   8(%rax), %xmm2\n        movq    -24(%rbp), %rax\n        movsd   8(%rax), %xmm1\n        mulsd   %xmm2, %xmm1\n        subsd   %xmm1, %xmm0\n        movsd   %xmm0, -16(%rbp)        // double r = src.r*dst.r - src.i*dst.i\n\n        movq    -32(%rbp), %rax\n        movsd   (%rax), %xmm1\n        movq    -24(%rbp), %rax\n        movsd   8(%rax), %xmm0\n        mulsd   %xmm0, %xmm1\n        movq    -32(%rbp), %rax\n        movsd   8(%rax), %xmm2\n        movq    -24(%rbp), %rax\n        movsd   (%rax), %xmm0\n        mulsd   %xmm2, %xmm0\n        addsd   %xmm1, %xmm0\n        movsd   %xmm0, -8(%rbp)         // double i = src.r*dst.i + src.i*dst.r\n\n        movq    -32(%rbp), %rax\n        movsd   -16(%rbp), %xmm0\n        movsd   %xmm0, (%rax)           // dst.r = r\n        movq    -32(%rbp), %rax\n        movsd   -8(%rbp), %xmm0\n        movsd   %xmm0, 8(%rax)          // dst.i = i\n        jmp     for_loop_step\n\nfor_loop_step:\n        addq    $3, -48(%rbp)\n\nfor_loop_condition:\n        movq    -48(%rbp), %rax         // %rax = code (the pointer)\n        movzbl  (%rax), %eax            // %eax = *code (move one byte)\n        testb   %al, %al                // is %eax 0?\n        jne     for_loop_body           // if no, then continue\n\n        leave                           // otherwise rewind stack\n        ret                             // pop and jmp\n```\n\n#### Compilation strategy\nMost of the above is register-shuffling fluff that we can get rid of. We're\ncompiling the code up front, which means all of our register addresses are\nknown quantities and we won't need any unknown indirection at runtime. So all\nof the shuffling into and out of `%rax` can be replaced by a much simpler move\ndirectly to or from `N(%rdi)` -- since `%rdi` is the argument that points to\nthe first register's real component.\n\nIf you haven't already, at this point I'd recommend downloading the [Intel\nsoftware developer's\nmanual](https://software.intel.com/en-us/articles/intel-sdm), of which volume 2\ndescribes the semantics and machine code representation of every instruction.\n\n**NOTE:** GCC uses AT&T assembly syntax, whereas the Intel manuals use Intel\nassembly syntax. An important difference is that AT&T reverses the arguments:\n`mov %rax, %rbx` (AT&T syntax) assigns to `%rbx`, whereas `mov rax, rbx` (Intel\nsyntax) assigns to `rax`. All of my code examples use AT&T, and none of this\nwill matter once we're working with machine code.\n\n##### Example: the Mandelbrot function `*bb+ab`\n```s\n// Step 1: multiply register B by itself\nmovsd 16(%rdi), %xmm0                   // %xmm0 = b.r\nmovsd 24(%rdi), %xmm1                   // %xmm1 = b.i\nmovsd 16(%rdi), %xmm2                   // %xmm2 = b.r\nmovsd 24(%rdi), %xmm3                   // %xmm3 = b.i\nmovsd %xmm0, %xmm4                      // %xmm4 = b.r\nmulsd %xmm2, %xmm4                      // %xmm4 = b.r*b.r\nmovsd %xmm1, %xmm5                      // %xmm5 = b.i\nmulsd %xmm3, %xmm5                      // %xmm5 = b.i*b.i\nsubsd %xmm5, %xmm4                      // %xmm4 = b.r*b.r - b.i*b.i\nmovsd %xmm4, 16(%rdi)                   // b.r = %xmm4\n\nmulsd %xmm0, %xmm3                      // %xmm3 = b.r*b.i\nmulsd %xmm1, %xmm2                      // %xmm2 = b.i*b.r\naddsd %xmm3, %xmm2                      // %xmm2 = b.r*b.i + b.i*b.r\nmovsd %xmm2, 24(%rdi)                   // b.i = %xmm2\n\n// Step 2: add register A to register B\nmovpd (%rdi), %xmm0                     // %xmm0 = (a.r, a.i)\naddpd %xmm0, 16(%rdi)                   // %xmm0 += (b.r, b.i)\nmovpd %xmm0, 16(%rdi)                   // (b.r, b.i) = %xmm0\n```\n\nThe multiplication code isn't optimized for the squaring-a-register use case;\ninstead, I left it fully general so we can use it as a template when we start\ngenerating machine code.\n\n### JIT mechanics\nBefore we compile a real language, let's just get a basic code generator\nworking.\n\n```c\n// jitproto.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n\ntypedef long(*fn)(long);\n\nfn compile_identity(void) {\n  // Allocate some memory and set its permissions correctly. In particular, we\n  // need PROT_EXEC (which isn't normally enabled for data memory, e.g. from\n  // malloc()), which tells the processor it's ok to execute it as machine\n  // code.\n  char *memory = mmap(NULL,             // address\n                      4096,             // size\n                      PROT_READ | PROT_WRITE | PROT_EXEC,\n                      MAP_PRIVATE | MAP_ANONYMOUS,\n                      -1,               // fd (not used here)\n                      0);               // offset (not used here)\n  if (memory == MAP_FAILED) {\n    perror(\"failed to allocate memory\");\n    exit(1);\n  }\n\n  int i = 0;\n\n  // mov %rdi, %rax\n  memory[i++] = 0x48;           // REX.W prefix\n  memory[i++] = 0x8b;           // MOV opcode, register/register\n  memory[i++] = 0xc7;           // MOD/RM byte for %rdi -> %rax\n\n  // ret\n  memory[i++] = 0xc3;           // RET opcode\n\n  return (fn) memory;\n}\n\nint main() {\n  fn f = compile_identity();\n  int i;\n  for (i = 0; i < 10; ++i)\n    printf(\"f(%d) = %ld\\n\", i, (*f)(i));\n  munmap(f, 4096);\n  return 0;\n}\n```\n\nThis does what we expect: we've just produced an identity function.\n\n```sh\n$ gcc jitproto.c -o jitproto\n$ ./jitproto\nf(0) = 0\nf(1) = 1\nf(2) = 2\nf(3) = 3\nf(4) = 4\nf(5) = 5\nf(6) = 6\nf(7) = 7\nf(8) = 8\nf(9) = 9\n```\n\n**TODO:** explanation about userspace page mapping/permissions, and how ELF\ninstructions tie into this (maybe also explain stuff like the FD table while\nwe're at it)\n\n#### Generating MandelASM machine code\nThis is where we start to get some serious mileage out of the Intel manuals. We\nneed encodings for the following instructions:\n\n- `f2 0f 11`: `movsd reg -> memory`\n- `f2 0f 10`: `movsd memory -> reg`\n- `f2 0f 59`: `mulsd reg -> reg`\n- `f2 0f 58`: `addsd reg -> reg`\n- `f2 0f 5c`: `subsd reg -> reg`\n- `66 0f 11`: `movpd reg -> memory` (technically `movupd` for unaligned move)\n- `66 0f 10`: `movpd memory -> reg`\n- `66 0f 58`: `addpd memory -> reg`\n\n##### The gnarly bits: how operands are specified\nChapter 2 of the Intel manual volume 2 contains a roundabout, confusing\ndescription of operand encoding, so I'll try to sum up the basics here.\n(**TODO**)\n\nFor the operators above, we've got two ModR/M configurations:\n\n- `movsd reg <-> X(%rdi)`: mod = 01, r/m = 111, disp8 = X\n- `addsd reg -> reg`: mod = 11\n\nAt the byte level, they're written like this:\n\n```\nmovsd %xmm0, 16(%rdi)           # f2 0f 11 47 10\n  # modr/m = b01 000 111 = 47\n  # disp   = 16          = 10\n\naddsd %xmm3, %xmm4              # f2 0f 58 e3\n  # modr/m = b11 100 011 = e3\n```\n\n##### A simple micro-assembler\n```h\n// micro-asm.h\n#include <stdarg.h>\ntypedef struct {\n  char *dest;\n} microasm;\n\n// this makes it more obvious what we're doing later on\n#define xmm(n) (n)\n\nvoid asm_write(microasm *a, int n, ...) {\n  va_list bytes;\n  int i;\n  va_start(bytes, n);\n  for (i = 0; i < n; ++i) *(a->dest++) = (char) va_arg(bytes, int);\n  va_end(bytes);\n}\n\nvoid movsd_reg_memory(microasm *a, char reg, char disp)\n{ asm_write(a, 5, 0xf2, 0x0f, 0x11, 0x47 | reg << 3, disp); }\n\nvoid movsd_memory_reg(microasm *a, char disp, char reg)\n{ asm_write(a, 5, 0xf2, 0x0f, 0x10, 0x47 | reg << 3, disp); }\n\nvoid movsd_reg_reg(microasm *a, char src, char dst)\n{ asm_write(a, 4, 0xf2, 0x0f, 0x11, 0xc0 | src << 3 | dst); }\n\nvoid mulsd(microasm *a, char src, char dst)\n{ asm_write(a, 4, 0xf2, 0x0f, 0x59, 0xc0 | dst << 3 | src); }\n\nvoid addsd(microasm *a, char src, char dst)\n{ asm_write(a, 4, 0xf2, 0x0f, 0x58, 0xc0 | dst << 3 | src); }\n\nvoid subsd(microasm *a, char src, char dst)\n{ asm_write(a, 4, 0xf2, 0x0f, 0x5c, 0xc0 | dst << 3 | src); }\n\nvoid movpd_reg_memory(microasm *a, char reg, char disp)\n{ asm_write(a, 5, 0x66, 0x0f, 0x11, 0x47 | reg << 3, disp); }\n\nvoid movpd_memory_reg(microasm *a, char disp, char reg)\n{ asm_write(a, 5, 0x66, 0x0f, 0x10, 0x47 | reg << 3, disp); }\n\nvoid addpd_memory_reg(microasm *a, char disp, char reg)\n{ asm_write(a, 5, 0x66, 0x0f, 0x58, 0x47 | reg << 3, disp); }\n```\n\n##### Putting it all together\nNow that we can write assembly-level stuff, we can take the structure from the\nprototype JIT compiler and modify it to compile MandelASM.\n\n```c\n// mandeljit.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n\n#include \"micro-asm.h\"\n\n#define sqr(x) ((x) * (x))\n\ntypedef struct { double r; double i; } complex;\ntypedef void(*compiled)(complex*);\n\n#define offsetof(type, field) ((unsigned long) &(((type *) 0)->field))\n\ncompiled compile(char *code) {\n  char *memory = mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC,\n                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  microasm a = { .dest = memory };\n  char src_dsp, dst_dsp;\n  char const r = offsetof(complex, r);\n  char const i = offsetof(complex, i);\n\n  for (; *code; code += 3) {\n    src_dsp = sizeof(complex) * (code[1] - 'a');\n    dst_dsp = sizeof(complex) * (code[2] - 'a');\n    switch (*code) {\n      case '=':\n        movpd_memory_reg(&a, src_dsp, xmm(0));\n        movpd_reg_memory(&a, xmm(0), dst_dsp);\n        break;\n\n      case '+':\n        movpd_memory_reg(&a, src_dsp, xmm(0));\n        addpd_memory_reg(&a, dst_dsp, xmm(0));\n        movpd_reg_memory(&a, xmm(0), dst_dsp);\n        break;\n\n      case '*':\n        movsd_memory_reg(&a, src_dsp + r, xmm(0));\n        movsd_memory_reg(&a, src_dsp + i, xmm(1));\n        movsd_memory_reg(&a, dst_dsp + r, xmm(2));\n        movsd_memory_reg(&a, dst_dsp + i, xmm(3));\n        movsd_reg_reg   (&a, xmm(0), xmm(4));\n        mulsd           (&a, xmm(2), xmm(4));\n        movsd_reg_reg   (&a, xmm(1), xmm(5));\n        mulsd           (&a, xmm(3), xmm(5));\n        subsd           (&a, xmm(5), xmm(4));\n        movsd_reg_memory(&a, xmm(4), dst_dsp + r);\n\n        mulsd           (&a, xmm(0), xmm(3));\n        mulsd           (&a, xmm(1), xmm(2));\n        addsd           (&a, xmm(3), xmm(2));\n        movsd_reg_memory(&a, xmm(2), dst_dsp + i);\n        break;\n\n      default:\n        fprintf(stderr, \"undefined instruction %s (ASCII %x)\\n\", code, *code);\n        exit(1);\n    }\n  }\n\n  // Return to caller (important! otherwise we'll segfault)\n  asm_write(&a, 1, 0xc3);\n\n  return (compiled) memory;\n}\n\nint main(int argc, char **argv) {\n  compiled fn = compile(argv[1]);\n  complex registers[4];\n  int i, x, y;\n  char line[1600];\n  printf(\"P5\\n%d %d\\n%d\\n\", 1600, 900, 255);\n  for (y = 0; y < 900; ++y) {\n    for (x = 0; x < 1600; ++x) {\n      registers[0].r = 2 * 1.6 * (x / 1600.0 - 0.5);\n      registers[0].i = 2 * 0.9 * (y /  900.0 - 0.5);\n      for (i = 1; i < 4; ++i) registers[i].r = registers[i].i = 0;\n      for (i = 0; i < 256 && sqr(registers[1].r) + sqr(registers[1].i) < 4; ++i)\n        (*fn)(registers);\n      line[x] = i;\n    }\n    fwrite(line, 1, sizeof(line), stdout);\n  }\n  return 0;\n}\n```\n\nNow let's benchmark the interpreted and JIT-compiled versions:\n\n```sh\n$ gcc mandeljit.c -o mandeljit\n$ time ./simple *bb+ab > /dev/null\nreal\t0m2.348s\nuser\t0m2.344s\nsys\t0m0.000s\n$ time ./mandeljit *bb+ab > /dev/null\nreal    0m1.462s\nuser    0m1.460s\nsys     0m0.000s\n```\n\nVery close to the limit performance of the hardcoded version. And, of course,\nthe JIT-compiled result is identical to the interpreted one:\n\n```sh\n$ ./simple *bb+ab | md5sum\n12a1013d55ee17998390809ffd671dbc  -\n$ ./mandeljit *bb+ab | md5sum\n12a1013d55ee17998390809ffd671dbc  -\n```\n\n## Further reading\n### Debugging JIT compilers\nFirst, you need a good scotch; this one should work.\n\n![image](https://cdn1.masterofmalt.com/whiskies/p-2813/laphroaig-quarter-cask-whisky.jpg?ss=2.0)\n\nOnce you've got that set up, `gdb` can probably be scripted to do what you\nneed. I've [used it somewhat\nsuccessfully](https://github.com/spencertipping/canard/blob/circular/bin/canard.debug.gdb)\nto debug a bunch of hand-written self-modifying machine code with no debugging\nsymbols -- the limitations of the approach ended up being whiskey-related\nrather than any deficiency of GDB itself.\n\nI've also had some luck using [radare2](http://www.radare.org/r/) to figure out\nwhen I was generating bogus instructions.\n\nOffline disassemblers like NASM and YASM won't help you.\n\n### Low-level\n- The Intel guides cover a lot of stuff we didn't end up using here: addressing\n  modes, instructions, etc. If you're serious about writing JIT compilers, it's\n  worth an in-depth read.\n\n- [Agner Fog's guides to processor-level\n  optimization](http://www.agner.org/optimize/): an insanely detailed tour\n  through processor internals, instruction parsing pipelines, and pretty much\n  every variant of every processor in existence.\n\n- [The V8 source\n  code](https://github.com/v8/v8/blob/master/src/codegen/x64/assembler-x64.h): how JIT\n  assemblers are actually written\n\n- [The JVM source\n  code](https://github.com/openjdk/jdk/tree/master/src/hotspot/)\n\n- [Jonesforth](http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.S;h=45e6e854a5d2a4c3f26af264dfce56379d401425;hb=HEAD):\n  a well-documented example of low-level code generation and interpreter\n  structure (sort of a JIT alternative)\n\n- [Canard machine\n  code](https://github.com/spencertipping/canard/blob/circular/bin/canard.md#introduction):\n  similar to jonesforth, but uses machine code for its data structures\n"
        },
        {
          "name": "hardcoded.c",
          "type": "blob",
          "size": 0.943359375,
          "content": "// hardcoded.c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define sqr(x) ((x) * (x))\n\ntypedef struct { double r; double i; } complex;\n\nvoid interpret(complex *registers, char const *code) {\n  complex *a = &registers[0];\n  complex *b = &registers[1];\n  double r, i;\n  r = b->r * b->r - b->i * b->i;\n  i = b->r * b->i + b->i * b->r;\n  b->r = r;\n  b->i = i;\n  b->r += a->r;\n  b->i += a->i;\n}\n\nint main(int argc, char **argv) {\n  complex registers[4];\n  int i, x, y;\n  char line[1600];\n  printf(\"P5\\n%d %d\\n%d\\n\", 1600, 900, 255);\n  for (y = 0; y < 900; ++y) {\n    for (x = 0; x < 1600; ++x) {\n      registers[0].r = 2 * 1.6 * (x / 1600.0 - 0.5);\n      registers[0].i = 2 * 0.9 * (y /  900.0 - 0.5);\n      for (i = 1; i < 4; ++i) registers[i].r = registers[i].i = 0;\n      for (i = 0; i < 256 && sqr(registers[1].r) + sqr(registers[1].i) < 4; ++i)\n        interpret(registers, argv[1]);\n      line[x] = i;\n    }\n    fwrite(line, 1, sizeof(line), stdout);\n  }\n  return 0;\n}\n"
        },
        {
          "name": "jitproto.c",
          "type": "blob",
          "size": 1.2001953125,
          "content": "// jitproto.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n\ntypedef long(*fn)(long);\n\nfn compile_identity(void) {\n  // Allocate some memory and set its permissions correctly. In particular, we\n  // need PROT_EXEC (which isn't normally enabled for data memory, e.g. from\n  // malloc()), which tells the processor it's ok to execute it as machine\n  // code.\n  char *memory = mmap(NULL,             // address\n                      4096,             // size\n                      PROT_READ | PROT_WRITE | PROT_EXEC,\n                      MAP_PRIVATE | MAP_ANONYMOUS,\n                      -1,               // fd (not used here)\n                      0);               // offset (not used here)\n  if (!memory) {\n    perror(\"failed to allocate memory\");\n    exit(1);\n  }\n\n  int i = 0;\n\n  // mov %rdi, %rax\n  memory[i++] = 0x48;           // REX.W prefix\n  memory[i++] = 0x8b;           // MOV opcode, register/register\n  memory[i++] = 0xc7;           // MOD/RM byte for %rdi -> %rax\n\n  // ret\n  memory[i++] = 0xc3;           // RET opcode\n\n  return (fn) memory;\n}\n\nint main() {\n  fn f = compile_identity();\n  int i;\n  for (i = 0; i < 10; ++i)\n    printf(\"f(%d) = %ld\\n\", i, (*f)(i));\n  munmap(f, 4096);\n  return 0;\n}\n"
        },
        {
          "name": "mandeljit.c",
          "type": "blob",
          "size": 2.4931640625,
          "content": "// mandeljit.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n\n#include \"micro-asm.h\"\n\n#define sqr(x) ((x) * (x))\n\ntypedef struct { double r; double i; } complex;\ntypedef void(*compiled)(complex*);\n\n#define offsetof(type, field) ((unsigned long) &(((type *) 0)->field))\n\ncompiled compile(char *code) {\n  char *memory = mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC,\n                      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  microasm a = { .dest = memory };\n  char src_dsp, dst_dsp;\n  char const r = offsetof(complex, r);\n  char const i = offsetof(complex, i);\n\n  for (; *code; code += 3) {\n    src_dsp = sizeof(complex) * (code[1] - 'a');\n    dst_dsp = sizeof(complex) * (code[2] - 'a');\n    switch (*code) {\n      case '=':\n        movpd_memory_reg(&a, src_dsp, xmm(0));\n        movpd_reg_memory(&a, xmm(0), dst_dsp);\n        break;\n\n      case '+':\n        movpd_memory_reg(&a, src_dsp, xmm(0));\n        addpd_memory_reg(&a, dst_dsp, xmm(0));\n        movpd_reg_memory(&a, xmm(0), dst_dsp);\n        break;\n\n      case '*':\n        movsd_memory_reg(&a, src_dsp + r, xmm(0));\n        movsd_memory_reg(&a, src_dsp + i, xmm(1));\n        movsd_memory_reg(&a, dst_dsp + r, xmm(2));\n        movsd_memory_reg(&a, dst_dsp + i, xmm(3));\n        movsd_reg_reg   (&a, xmm(0), xmm(4));\n        mulsd           (&a, xmm(2), xmm(4));\n        movsd_reg_reg   (&a, xmm(1), xmm(5));\n        mulsd           (&a, xmm(3), xmm(5));\n        subsd           (&a, xmm(5), xmm(4));\n        movsd_reg_memory(&a, xmm(4), dst_dsp + r);\n\n        mulsd           (&a, xmm(0), xmm(3));\n        mulsd           (&a, xmm(1), xmm(2));\n        addsd           (&a, xmm(3), xmm(2));\n        movsd_reg_memory(&a, xmm(2), dst_dsp + i);\n        break;\n\n      default:\n        fprintf(stderr, \"undefined instruction %s (ASCII %x)\\n\", code, *code);\n        exit(1);\n    }\n  }\n\n  // Return to caller (important!)\n  asm_write(&a, 1, 0xc3);\n\n  return (compiled) memory;\n}\n\nint main(int argc, char **argv) {\n  compiled fn = compile(argv[1]);\n  complex registers[4];\n  int i, x, y;\n  char line[1600];\n  printf(\"P5\\n%d %d\\n%d\\n\", 1600, 900, 255);\n  for (y = 0; y < 900; ++y) {\n    for (x = 0; x < 1600; ++x) {\n      registers[0].r = 2 * 1.6 * (x / 1600.0 - 0.5);\n      registers[0].i = 2 * 0.9 * (y /  900.0 - 0.5);\n      for (i = 1; i < 4; ++i) registers[i].r = registers[i].i = 0;\n      for (i = 0; i < 256 && sqr(registers[1].r) + sqr(registers[1].i) < 4; ++i)\n        (*fn)(registers);\n      line[x] = i;\n    }\n    fwrite(line, 1, sizeof(line), stdout);\n  }\n  return 0;\n}\n"
        },
        {
          "name": "micro-asm.h",
          "type": "blob",
          "size": 1.37109375,
          "content": "// micro-asm.h\n#include <stdarg.h>\ntypedef struct {\n  char *dest;\n} microasm;\n\n// this makes it more obvious what we're doing later on\n#define xmm(n) (n)\n\nvoid asm_write(microasm *a, int n, ...) {\n  va_list bytes;\n  int i;\n  va_start(bytes, n);\n  for (i = 0; i < n; ++i) *(a->dest++) = (char) va_arg(bytes, int);\n  va_end(bytes);\n}\n\nvoid movpd_reg_memory(microasm *a, char reg,  char disp) { asm_write(a, 5, 0x66, 0x0f, 0x11, 0x47 | reg << 3, disp); }\nvoid movpd_memory_reg(microasm *a, char disp, char reg)  { asm_write(a, 5, 0x66, 0x0f, 0x10, 0x47 | reg << 3, disp); }\nvoid addpd_memory_reg(microasm *a, char disp, char reg)  { asm_write(a, 5, 0x66, 0x0f, 0x58, 0x47 | reg << 3, disp); }\nvoid movsd_reg_memory(microasm *a, char reg,  char disp) { asm_write(a, 5, 0xf2, 0x0f, 0x11, 0x47 | reg << 3, disp); }\nvoid movsd_memory_reg(microasm *a, char disp, char reg)  { asm_write(a, 5, 0xf2, 0x0f, 0x10, 0x47 | reg << 3, disp); }\nvoid movsd_reg_reg   (microasm *a, char src,  char dst)  { asm_write(a, 4, 0xf2, 0x0f, 0x11, 0xc0 | src << 3 | dst); }\nvoid mulsd           (microasm *a, char src,  char dst)  { asm_write(a, 4, 0xf2, 0x0f, 0x59, 0xc0 | dst << 3 | src); }\nvoid addsd           (microasm *a, char src,  char dst)  { asm_write(a, 4, 0xf2, 0x0f, 0x58, 0xc0 | dst << 3 | src); }\nvoid subsd           (microasm *a, char src,  char dst)  { asm_write(a, 4, 0xf2, 0x0f, 0x5c, 0xc0 | dst << 3 | src); }\n"
        },
        {
          "name": "simple.c",
          "type": "blob",
          "size": 1.3447265625,
          "content": "// simple.c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define sqr(x) ((x) * (x))\n\ntypedef struct { double r; double i; } complex;\n\nvoid interpret(complex *registers, char const *code) {\n  complex *src, *dst;\n  double r, i;\n  for (; *code; code += 3) {\n    dst = &registers[code[2] - 'a'];\n    src = &registers[code[1] - 'a'];\n    switch (*code) {\n      case '=':\n        dst->r = src->r;\n        dst->i = src->i;\n        break;\n      case '+':\n        dst->r += src->r;\n        dst->i += src->i;\n        break;\n      case '*':\n        r = dst->r * src->r - dst->i * src->i;\n        i = dst->r * src->i + dst->i * src->r;\n        dst->r = r;\n        dst->i = i;\n        break;\n      default:\n        fprintf(stderr, \"undefined instruction %s (ASCII %x)\\n\", code, *code);\n        exit(1);\n    }\n  }\n}\n\nint main(int argc, char **argv) {\n  complex registers[4];\n  int i, x, y;\n  char line[1600];\n  printf(\"P5\\n%d %d\\n%d\\n\", 1600, 900, 255);\n  for (y = 0; y < 900; ++y) {\n    for (x = 0; x < 1600; ++x) {\n      registers[0].r = 2 * 1.6 * (x / 1600.0 - 0.5);\n      registers[0].i = 2 * 0.9 * (y /  900.0 - 0.5);\n      for (i = 1; i < 4; ++i) registers[i].r = registers[i].i = 0;\n      for (i = 0; i < 256 && sqr(registers[1].r) + sqr(registers[1].i) < 4; ++i)\n        interpret(registers, argv[1]);\n      line[x] = i;\n    }\n    fwrite(line, 1, sizeof(line), stdout);\n  }\n  return 0;\n}\n"
        },
        {
          "name": "simple.s",
          "type": "blob",
          "size": 5.013671875,
          "content": "\t.file\t\"simple.c\"\n\t.section\t.rodata\n\t.align 8\n.LC0:\n\t.string\t\"undefined instruction %s (ASCII %x)\\n\"\n\t.text\n\t.globl\tinterpret\n\t.type\tinterpret, @function\ninterpret:\n.LFB2:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$48, %rsp\n\tmovq\t%rdi, -40(%rbp)\n\tmovq\t%rsi, -48(%rbp)\n\tjmp\t.L2\n.L8:\n\tmovq\t-48(%rbp), %rax\n\taddq\t$2, %rax\n\tmovzbl\t(%rax), %eax\n\tmovsbq\t%al, %rax\n\tsalq\t$4, %rax\n\tleaq\t-1552(%rax), %rdx\n\tmovq\t-40(%rbp), %rax\n\taddq\t%rdx, %rax\n\tmovq\t%rax, -32(%rbp)\n\tmovq\t-48(%rbp), %rax\n\taddq\t$1, %rax\n\tmovzbl\t(%rax), %eax\n\tmovsbq\t%al, %rax\n\tsalq\t$4, %rax\n\tleaq\t-1552(%rax), %rdx\n\tmovq\t-40(%rbp), %rax\n\taddq\t%rdx, %rax\n\tmovq\t%rax, -24(%rbp)\n\tmovq\t-48(%rbp), %rax\n\tmovzbl\t(%rax), %eax\n\tmovsbl\t%al, %eax\n\tcmpl\t$43, %eax\n\tje\t.L4\n\tcmpl\t$61, %eax\n\tje\t.L5\n\tcmpl\t$42, %eax\n\tje\t.L6\n\tjmp\t.L9\n.L5:\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t(%rax), %xmm0\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t%xmm0, (%rax)\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t8(%rax), %xmm0\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t%xmm0, 8(%rax)\n\tjmp\t.L7\n.L4:\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t(%rax), %xmm1\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t(%rax), %xmm0\n\taddsd\t%xmm1, %xmm0\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t%xmm0, (%rax)\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t8(%rax), %xmm1\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t8(%rax), %xmm0\n\taddsd\t%xmm1, %xmm0\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t%xmm0, 8(%rax)\n\tjmp\t.L7\n.L6:\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t(%rax), %xmm1\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t(%rax), %xmm0\n\tmulsd\t%xmm1, %xmm0\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t8(%rax), %xmm2\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t8(%rax), %xmm1\n\tmulsd\t%xmm2, %xmm1\n\tsubsd\t%xmm1, %xmm0\n\tmovsd\t%xmm0, -16(%rbp)\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t(%rax), %xmm1\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t8(%rax), %xmm0\n\tmulsd\t%xmm0, %xmm1\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t8(%rax), %xmm2\n\tmovq\t-24(%rbp), %rax\n\tmovsd\t(%rax), %xmm0\n\tmulsd\t%xmm2, %xmm0\n\taddsd\t%xmm1, %xmm0\n\tmovsd\t%xmm0, -8(%rbp)\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t-16(%rbp), %xmm0\n\tmovsd\t%xmm0, (%rax)\n\tmovq\t-32(%rbp), %rax\n\tmovsd\t-8(%rbp), %xmm0\n\tmovsd\t%xmm0, 8(%rax)\n\tjmp\t.L7\n.L9:\n\tmovq\t-48(%rbp), %rax\n\tmovzbl\t(%rax), %eax\n\tmovsbl\t%al, %ecx\n\tmovq\tstderr(%rip), %rax\n\tmovq\t-48(%rbp), %rdx\n\tmovl\t$.LC0, %esi\n\tmovq\t%rax, %rdi\n\tmovl\t$0, %eax\n\tcall\tfprintf\n\tmovl\t$1, %edi\n\tcall\texit\n.L7:\n\taddq\t$3, -48(%rbp)\n.L2:\n\tmovq\t-48(%rbp), %rax\n\tmovzbl\t(%rax), %eax\n\ttestb\t%al, %al\n\tjne\t.L8\n\tnop\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE2:\n\t.size\tinterpret, .-interpret\n\t.section\t.rodata\n.LC1:\n\t.string\t\"P5\\n%d %d\\n%d\\n\"\n\t.text\n\t.globl\tmain\n\t.type\tmain, @function\nmain:\n.LFB3:\n\t.cfi_startproc\n\tpushq\t%rbp\n\t.cfi_def_cfa_offset 16\n\t.cfi_offset 6, -16\n\tmovq\t%rsp, %rbp\n\t.cfi_def_cfa_register 6\n\tsubq\t$1712, %rsp\n\tmovl\t%edi, -1700(%rbp)\n\tmovq\t%rsi, -1712(%rbp)\n\tmovq\t%fs:40, %rax\n\tmovq\t%rax, -8(%rbp)\n\txorl\t%eax, %eax\n\tmovl\t$255, %ecx\n\tmovl\t$900, %edx\n\tmovl\t$1600, %esi\n\tmovl\t$.LC1, %edi\n\tmovl\t$0, %eax\n\tcall\tprintf\n\tmovl\t$0, -1684(%rbp)\n\tjmp\t.L11\n.L19:\n\tmovl\t$0, -1688(%rbp)\n\tjmp\t.L12\n.L18:\n\tpxor\t%xmm0, %xmm0\n\tcvtsi2sd\t-1688(%rbp), %xmm0\n\tmovsd\t.LC2(%rip), %xmm1\n\tdivsd\t%xmm1, %xmm0\n\tmovsd\t.LC3(%rip), %xmm1\n\tsubsd\t%xmm1, %xmm0\n\tmovsd\t.LC4(%rip), %xmm1\n\tmulsd\t%xmm1, %xmm0\n\tmovsd\t%xmm0, -1680(%rbp)\n\tpxor\t%xmm0, %xmm0\n\tcvtsi2sd\t-1684(%rbp), %xmm0\n\tmovsd\t.LC5(%rip), %xmm1\n\tdivsd\t%xmm1, %xmm0\n\tmovsd\t.LC3(%rip), %xmm1\n\tsubsd\t%xmm1, %xmm0\n\tmovsd\t.LC6(%rip), %xmm1\n\tmulsd\t%xmm1, %xmm0\n\tmovsd\t%xmm0, -1672(%rbp)\n\tmovl\t$1, -1692(%rbp)\n\tjmp\t.L13\n.L14:\n\tmovl\t-1692(%rbp), %eax\n\tcltq\n\tsalq\t$4, %rax\n\taddq\t%rbp, %rax\n\tsubq\t$1672, %rax\n\tpxor\t%xmm0, %xmm0\n\tmovsd\t%xmm0, (%rax)\n\tmovl\t-1692(%rbp), %eax\n\tcltq\n\tsalq\t$4, %rax\n\taddq\t%rbp, %rax\n\tsubq\t$1672, %rax\n\tmovsd\t(%rax), %xmm0\n\tmovl\t-1692(%rbp), %eax\n\tcltq\n\tsalq\t$4, %rax\n\taddq\t%rbp, %rax\n\tsubq\t$1680, %rax\n\tmovsd\t%xmm0, (%rax)\n\taddl\t$1, -1692(%rbp)\n.L13:\n\tcmpl\t$3, -1692(%rbp)\n\tjle\t.L14\n\tmovl\t$0, -1692(%rbp)\n\tjmp\t.L15\n.L17:\n\tmovq\t-1712(%rbp), %rax\n\taddq\t$8, %rax\n\tmovq\t(%rax), %rdx\n\tleaq\t-1680(%rbp), %rax\n\tmovq\t%rdx, %rsi\n\tmovq\t%rax, %rdi\n\tcall\tinterpret\n\taddl\t$1, -1692(%rbp)\n.L15:\n\tcmpl\t$255, -1692(%rbp)\n\tjg\t.L16\n\tmovsd\t-1664(%rbp), %xmm1\n\tmovsd\t-1664(%rbp), %xmm0\n\tmulsd\t%xmm0, %xmm1\n\tmovsd\t-1656(%rbp), %xmm2\n\tmovsd\t-1656(%rbp), %xmm0\n\tmulsd\t%xmm2, %xmm0\n\taddsd\t%xmm1, %xmm0\n\tmovsd\t.LC8(%rip), %xmm1\n\tucomisd\t%xmm0, %xmm1\n\tja\t.L17\n.L16:\n\tmovl\t-1692(%rbp), %eax\n\tmovl\t%eax, %edx\n\tmovl\t-1688(%rbp), %eax\n\tcltq\n\tmovb\t%dl, -1616(%rbp,%rax)\n\taddl\t$1, -1688(%rbp)\n.L12:\n\tcmpl\t$1599, -1688(%rbp)\n\tjle\t.L18\n\tmovq\tstdout(%rip), %rdx\n\tleaq\t-1616(%rbp), %rax\n\tmovq\t%rdx, %rcx\n\tmovl\t$1600, %edx\n\tmovl\t$1, %esi\n\tmovq\t%rax, %rdi\n\tcall\tfwrite\n\taddl\t$1, -1684(%rbp)\n.L11:\n\tcmpl\t$899, -1684(%rbp)\n\tjle\t.L19\n\tmovl\t$0, %eax\n\tmovq\t-8(%rbp), %rcx\n\txorq\t%fs:40, %rcx\n\tje\t.L21\n\tcall\t__stack_chk_fail\n.L21:\n\tleave\n\t.cfi_def_cfa 7, 8\n\tret\n\t.cfi_endproc\n.LFE3:\n\t.size\tmain, .-main\n\t.section\t.rodata\n\t.align 8\n.LC2:\n\t.long\t0\n\t.long\t1083768832\n\t.align 8\n.LC3:\n\t.long\t0\n\t.long\t1071644672\n\t.align 8\n.LC4:\n\t.long\t2576980378\n\t.long\t1074370969\n\t.align 8\n.LC5:\n\t.long\t0\n\t.long\t1082925056\n\t.align 8\n.LC6:\n\t.long\t3435973837\n\t.long\t1073532108\n\t.align 8\n.LC8:\n\t.long\t0\n\t.long\t1074790400\n\t.ident\t\"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609\"\n\t.section\t.note.GNU-stack,\"\",@progbits\n"
        }
      ]
    }
  ]
}